<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 29943:7e4d2d1cab11d7e423b5f3eaed2617add76e480b</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 7e4d2d1cab11d7e423b5f3eaed2617add76e480b" />
<meta property="og:url" content="/comm-central/rev/7e4d2d1cab11d7e423b5f3eaed2617add76e480b" />
<meta property="og:description" content="Bug 1643561 - Apply M-C clang-format rules to ldap c-sdk. rs=mkmelin" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 7e4d2d1cab11d7e423b5f3eaed2617add76e480b 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/7e4d2d1cab11d7e423b5f3eaed2617add76e480b">shortlog</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/7e4d2d1cab11d7e423b5f3eaed2617add76e480b">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b">files</a> |
changeset |
<a href="/comm-central/raw-rev/7e4d2d1cab11d7e423b5f3eaed2617add76e480b">raw</a>  | <a href="/comm-central/archive/7e4d2d1cab11d7e423b5f3eaed2617add76e480b.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1643561">Bug 1643561</a> - Apply M-C clang-format rules to ldap c-sdk. rs=mkmelin
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#66;&#101;&#110;&#32;&#67;&#97;&#109;&#112;&#98;&#101;&#108;&#108;&#32;&#60;&#98;&#101;&#110;&#99;&#64;&#116;&#104;&#117;&#110;&#100;&#101;&#114;&#98;&#105;&#114;&#100;&#46;&#110;&#101;&#116;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 23 Jun 2020 13:24:50 +1200</td></tr>

<tr>
 <td>changeset 29943</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/7e4d2d1cab11d7e423b5f3eaed2617add76e480b">7e4d2d1cab11d7e423b5f3eaed2617add76e480b</a></td>
</tr>



<tr>
<td>parent 29942</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/d051d1812f3ca38505bc4e5779330b603dee20e3">d051d1812f3ca38505bc4e5779330b603dee20e3</a>
</td>
</tr>

<tr>
<td>child 29944</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/7e71e1df6485ea0e667a4a9b9465b5904a55214d">7e71e1df6485ea0e667a4a9b9465b5904a55214d</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=7e4d2d1cab11d7e423b5f3eaed2617add76e480b">17609</a></td></tr>
<tr><td>push user</td><td>benc@thunderbird.net</td></tr>
<tr><td>push date</td><td class="date age">Tue, 23 Jun 2020 02:52:17 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@7e4d2d1cab11 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=7e4d2d1cab11d7e423b5f3eaed2617add76e480b">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=7e4d2d1cab11d7e423b5f3eaed2617add76e480b&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7e4d2d1cab11d7e423b5f3eaed2617add76e480b&newProject=comm-central&newRevision=7e4d2d1cab11d7e423b5f3eaed2617add76e480b&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7e4d2d1cab11d7e423b5f3eaed2617add76e480b&newProject=comm-central&newRevision=7e4d2d1cab11d7e423b5f3eaed2617add76e480b&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=7e4d2d1cab11d7e423b5f3eaed2617add76e480b&newProject=comm-central&newRevision=7e4d2d1cab11d7e423b5f3eaed2617add76e480b&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28mkmelin%29&revcount=50">mkmelin</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1643561">1643561</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1643561">Bug 1643561</a> - Apply M-C clang-format rules to ldap c-sdk. rs=mkmelin</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/disptmpl.h">ldap/c-sdk/include/disptmpl.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/disptmpl.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/disptmpl.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/disptmpl.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/disptmpl.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/disptmpl.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/iutil.h">ldap/c-sdk/include/iutil.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/iutil.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/iutil.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/iutil.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/iutil.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/iutil.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lber.h">ldap/c-sdk/include/lber.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lber.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lber.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lber.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lber.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lber.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lcache.h">ldap/c-sdk/include/lcache.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lcache.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lcache.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lcache.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lcache.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/lcache.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-deprecated.h">ldap/c-sdk/include/ldap-deprecated.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-deprecated.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-deprecated.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-deprecated.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-deprecated.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-deprecated.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-extension.h">ldap/c-sdk/include/ldap-extension.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-extension.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-extension.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-extension.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-extension.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-extension.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-standard.h">ldap/c-sdk/include/ldap-standard.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-standard.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-standard.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-standard.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-standard.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-standard.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-to-be-deprecated.h">ldap/c-sdk/include/ldap-to-be-deprecated.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-to-be-deprecated.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-to-be-deprecated.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-to-be-deprecated.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-to-be-deprecated.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap-to-be-deprecated.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap_ssl.h">ldap/c-sdk/include/ldap_ssl.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap_ssl.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap_ssl.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap_ssl.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap_ssl.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldap_ssl.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldaplog.h">ldap/c-sdk/include/ldaplog.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldaplog.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldaplog.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldaplog.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldaplog.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldaplog.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldappr.h">ldap/c-sdk/include/ldappr.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldappr.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldappr.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldappr.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldappr.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldappr.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldif.h">ldap/c-sdk/include/ldif.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldif.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldif.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldif.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldif.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/ldif.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/portable.h">ldap/c-sdk/include/portable.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/portable.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/portable.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/portable.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/portable.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/portable.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/proto-ntutil.h">ldap/c-sdk/include/proto-ntutil.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/proto-ntutil.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/proto-ntutil.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/proto-ntutil.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/proto-ntutil.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/proto-ntutil.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/regex.h">ldap/c-sdk/include/regex.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/regex.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/regex.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/regex.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/regex.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/regex.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/srchpref.h">ldap/c-sdk/include/srchpref.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/srchpref.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/srchpref.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/srchpref.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/srchpref.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/include/srchpref.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/bprint.c">ldap/c-sdk/libraries/liblber/bprint.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/bprint.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/bprint.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/bprint.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/bprint.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/bprint.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/decode.c">ldap/c-sdk/libraries/liblber/decode.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/decode.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/decode.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/decode.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/decode.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/decode.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/dtest.c">ldap/c-sdk/libraries/liblber/dtest.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/dtest.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/dtest.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/dtest.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/dtest.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/dtest.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/encode.c">ldap/c-sdk/libraries/liblber/encode.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/encode.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/encode.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/encode.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/encode.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/encode.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/etest.c">ldap/c-sdk/libraries/liblber/etest.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/etest.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/etest.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/etest.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/etest.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/etest.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/idtest.c">ldap/c-sdk/libraries/liblber/idtest.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/idtest.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/idtest.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/idtest.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/idtest.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/idtest.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/io.c">ldap/c-sdk/libraries/liblber/io.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/io.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/io.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/io.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/io.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/io.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/lber-int.h">ldap/c-sdk/libraries/liblber/lber-int.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/lber-int.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/lber-int.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/lber-int.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/lber-int.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/liblber/lber-int.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/abandon.c">ldap/c-sdk/libraries/libldap/abandon.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/abandon.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/abandon.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/abandon.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/abandon.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/abandon.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/add.c">ldap/c-sdk/libraries/libldap/add.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/add.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/add.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/add.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/add.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/add.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/authzidctrl.c">ldap/c-sdk/libraries/libldap/authzidctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/authzidctrl.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/authzidctrl.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/authzidctrl.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/authzidctrl.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/authzidctrl.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/bind.c">ldap/c-sdk/libraries/libldap/bind.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/bind.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/bind.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/bind.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/bind.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/bind.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cache.c">ldap/c-sdk/libraries/libldap/cache.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cache.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cache.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cache.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cache.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cache.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charray.c">ldap/c-sdk/libraries/libldap/charray.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charray.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charray.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charray.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charray.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charray.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charset.c">ldap/c-sdk/libraries/libldap/charset.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charset.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charset.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charset.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charset.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/charset.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cldap.c">ldap/c-sdk/libraries/libldap/cldap.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cldap.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cldap.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cldap.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cldap.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/cldap.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compare.c">ldap/c-sdk/libraries/libldap/compare.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compare.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compare.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compare.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compare.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compare.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compat.c">ldap/c-sdk/libraries/libldap/compat.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compat.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compat.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compat.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compat.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/compat.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/control.c">ldap/c-sdk/libraries/libldap/control.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/control.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/control.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/control.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/control.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/control.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/countvalues.c">ldap/c-sdk/libraries/libldap/countvalues.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/countvalues.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/countvalues.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/countvalues.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/countvalues.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/countvalues.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/delete.c">ldap/c-sdk/libraries/libldap/delete.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/delete.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/delete.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/delete.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/delete.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/delete.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/disptmpl.c">ldap/c-sdk/libraries/libldap/disptmpl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/disptmpl.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/disptmpl.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/disptmpl.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/disptmpl.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/disptmpl.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/dsparse.c">ldap/c-sdk/libraries/libldap/dsparse.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/dsparse.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/dsparse.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/dsparse.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/dsparse.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/dsparse.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/error.c">ldap/c-sdk/libraries/libldap/error.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/error.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/error.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/error.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/error.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/error.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/extendop.c">ldap/c-sdk/libraries/libldap/extendop.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/extendop.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/extendop.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/extendop.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/extendop.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/extendop.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/free.c">ldap/c-sdk/libraries/libldap/free.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/free.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/free.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/free.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/free.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/free.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/freevalues.c">ldap/c-sdk/libraries/libldap/freevalues.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/freevalues.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/freevalues.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/freevalues.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/freevalues.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/freevalues.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/friendly.c">ldap/c-sdk/libraries/libldap/friendly.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/friendly.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/friendly.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/friendly.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/friendly.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/friendly.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getattr.c">ldap/c-sdk/libraries/libldap/getattr.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getattr.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getattr.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getattr.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getattr.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getattr.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdn.c">ldap/c-sdk/libraries/libldap/getdn.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdn.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdn.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdn.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdn.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdn.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdxbyname.c">ldap/c-sdk/libraries/libldap/getdxbyname.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdxbyname.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdxbyname.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdxbyname.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdxbyname.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getdxbyname.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getentry.c">ldap/c-sdk/libraries/libldap/getentry.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getentry.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getentry.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getentry.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getentry.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getentry.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getfilter.c">ldap/c-sdk/libraries/libldap/getfilter.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getfilter.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getfilter.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getfilter.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getfilter.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getfilter.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getoption.c">ldap/c-sdk/libraries/libldap/getoption.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getoption.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getoption.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getoption.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getoption.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getoption.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getvalues.c">ldap/c-sdk/libraries/libldap/getvalues.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getvalues.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getvalues.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getvalues.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getvalues.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/getvalues.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ldap-int.h">ldap/c-sdk/libraries/libldap/ldap-int.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ldap-int.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ldap-int.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ldap-int.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ldap-int.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ldap-int.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/memcache.c">ldap/c-sdk/libraries/libldap/memcache.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/memcache.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/memcache.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/memcache.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/memcache.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/memcache.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/message.c">ldap/c-sdk/libraries/libldap/message.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/message.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/message.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/message.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/message.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/message.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/modify.c">ldap/c-sdk/libraries/libldap/modify.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/modify.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/modify.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/modify.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/modify.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/modify.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/mozock.c">ldap/c-sdk/libraries/libldap/mozock.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/mozock.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/mozock.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/mozock.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/mozock.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/mozock.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/nsprthreadtest.c">ldap/c-sdk/libraries/libldap/nsprthreadtest.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/nsprthreadtest.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/nsprthreadtest.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/nsprthreadtest.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/nsprthreadtest.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/nsprthreadtest.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/open.c">ldap/c-sdk/libraries/libldap/open.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/open.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/open.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/open.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/open.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/open.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/os-ip.c">ldap/c-sdk/libraries/libldap/os-ip.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/os-ip.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/os-ip.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/os-ip.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/os-ip.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/os-ip.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">ldap/c-sdk/libraries/libldap/proxyauthctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/psearch.c">ldap/c-sdk/libraries/libldap/psearch.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/psearch.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/psearch.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/psearch.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/psearch.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/psearch.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pthreadtest.c">ldap/c-sdk/libraries/libldap/pthreadtest.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pthreadtest.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pthreadtest.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pthreadtest.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pthreadtest.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pthreadtest.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwmodext.c">ldap/c-sdk/libraries/libldap/pwmodext.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwmodext.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwmodext.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwmodext.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwmodext.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwmodext.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwpctrl.c">ldap/c-sdk/libraries/libldap/pwpctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwpctrl.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwpctrl.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwpctrl.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwpctrl.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/pwpctrl.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/referral.c">ldap/c-sdk/libraries/libldap/referral.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/referral.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/referral.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/referral.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/referral.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/referral.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/regex.c">ldap/c-sdk/libraries/libldap/regex.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/regex.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/regex.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/regex.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/regex.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/regex.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/rename.c">ldap/c-sdk/libraries/libldap/rename.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/rename.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/rename.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/rename.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/rename.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/rename.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/request.c">ldap/c-sdk/libraries/libldap/request.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/request.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/request.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/request.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/request.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/request.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/reslist.c">ldap/c-sdk/libraries/libldap/reslist.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/reslist.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/reslist.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/reslist.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/reslist.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/reslist.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/result.c">ldap/c-sdk/libraries/libldap/result.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/result.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/result.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/result.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/result.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/result.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslbind.c">ldap/c-sdk/libraries/libldap/saslbind.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslbind.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslbind.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslbind.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslbind.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslbind.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslio.c">ldap/c-sdk/libraries/libldap/saslio.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslio.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslio.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslio.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslio.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/saslio.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sbind.c">ldap/c-sdk/libraries/libldap/sbind.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sbind.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sbind.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sbind.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sbind.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sbind.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/search.c">ldap/c-sdk/libraries/libldap/search.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/search.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/search.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/search.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/search.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/search.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/setoption.c">ldap/c-sdk/libraries/libldap/setoption.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/setoption.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/setoption.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/setoption.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/setoption.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/setoption.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sort.c">ldap/c-sdk/libraries/libldap/sort.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sort.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sort.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sort.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sort.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sort.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sortctrl.c">ldap/c-sdk/libraries/libldap/sortctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sortctrl.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sortctrl.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sortctrl.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sortctrl.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/sortctrl.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/srchpref.c">ldap/c-sdk/libraries/libldap/srchpref.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/srchpref.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/srchpref.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/srchpref.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/srchpref.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/srchpref.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/test.c">ldap/c-sdk/libraries/libldap/test.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/test.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/test.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/test.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/test.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/test.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmplout.c">ldap/c-sdk/libraries/libldap/tmplout.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmplout.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmplout.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmplout.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmplout.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmplout.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmpltest.c">ldap/c-sdk/libraries/libldap/tmpltest.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmpltest.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmpltest.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmpltest.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmpltest.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/tmpltest.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ufn.c">ldap/c-sdk/libraries/libldap/ufn.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ufn.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ufn.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ufn.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ufn.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/ufn.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unbind.c">ldap/c-sdk/libraries/libldap/unbind.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unbind.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unbind.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unbind.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unbind.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unbind.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unescape.c">ldap/c-sdk/libraries/libldap/unescape.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unescape.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unescape.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unescape.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unescape.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/unescape.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/url.c">ldap/c-sdk/libraries/libldap/url.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/url.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/url.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/url.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/url.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/url.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/userstatusctrl.c">ldap/c-sdk/libraries/libldap/userstatusctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/userstatusctrl.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/userstatusctrl.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/userstatusctrl.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/userstatusctrl.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/userstatusctrl.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/vlistctrl.c">ldap/c-sdk/libraries/libldap/vlistctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/vlistctrl.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/vlistctrl.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/vlistctrl.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/vlistctrl.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/vlistctrl.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/whoami.c">ldap/c-sdk/libraries/libldap/whoami.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/whoami.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/whoami.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/whoami.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/whoami.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldap/whoami.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldif/line64.c">ldap/c-sdk/libraries/libldif/line64.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldif/line64.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldif/line64.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldif/line64.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldif/line64.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libldif/line64.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-dns.c">ldap/c-sdk/libraries/libprldap/ldappr-dns.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-dns.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-dns.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-dns.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-dns.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-dns.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-int.h">ldap/c-sdk/libraries/libprldap/ldappr-int.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-int.h">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-int.h">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-int.h">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-int.h">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-int.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-io.c">ldap/c-sdk/libraries/libprldap/ldappr-io.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-io.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-io.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-io.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-io.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-io.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-public.c">ldap/c-sdk/libraries/libprldap/ldappr-public.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-public.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-public.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-public.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-public.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-public.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">ldap/c-sdk/libraries/libprldap/ldappr-threads.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">file</a> |
<a href="/comm-central/annotate/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">annotate</a> |
<a href="/comm-central/diff/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">diff</a> |
<a href="/comm-central/comparison/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">comparison</a> |
<a href="/comm-central/log/7e4d2d1cab11d7e423b5f3eaed2617add76e480b/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/ldap/c-sdk/include/disptmpl.h</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/ldap/c-sdk/include/disptmpl.h</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -157,56 +157,56 @@ extern &quot;C&quot; {</span>
<a href="#l1.4"></a><span id="l1.4"> #define LDAP_DITEM_OPT_HIDEIFFALSE 0x00000020L /* booleans only */</span>
<a href="#l1.5"></a><span id="l1.5"> </span>
<a href="#l1.6"></a><span id="l1.6"> /*</span>
<a href="#l1.7"></a><span id="l1.7">  * display template item structure</span>
<a href="#l1.8"></a><span id="l1.8">  */</span>
<a href="#l1.9"></a><span id="l1.9"> struct ldap_tmplitem {</span>
<a href="#l1.10"></a><span id="l1.10">   unsigned long ti_syntaxid;</span>
<a href="#l1.11"></a><span id="l1.11">   unsigned long ti_options;</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  char *ti_attrname;</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-  char *ti_label;</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineminus">-  char **ti_args;</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineminus">-  struct ldap_tmplitem *ti_next_in_row;</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineminus">-  struct ldap_tmplitem *ti_next_in_col;</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineminus">-  void *ti_appdata;</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+  char* ti_attrname;</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+  char* ti_label;</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+  char** ti_args;</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+  struct ldap_tmplitem* ti_next_in_row;</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineplus">+  struct ldap_tmplitem* ti_next_in_col;</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+  void* ti_appdata;</span>
<a href="#l1.24"></a><span id="l1.24"> };</span>
<a href="#l1.25"></a><span id="l1.25"> </span>
<a href="#l1.26"></a><span id="l1.26" class="difflineminus">-#define NULLTMPLITEM ((struct ldap_tmplitem *)0)</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+#define NULLTMPLITEM ((struct ldap_tmplitem*)0)</span>
<a href="#l1.28"></a><span id="l1.28"> </span>
<a href="#l1.29"></a><span id="l1.29" class="difflineminus">-#define LDAP_SET_TMPLITEM_APPDATA(ti, datap) (ti)-&gt;ti_appdata = (void *)(datap)</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+#define LDAP_SET_TMPLITEM_APPDATA(ti, datap) (ti)-&gt;ti_appdata = (void*)(datap)</span>
<a href="#l1.31"></a><span id="l1.31"> </span>
<a href="#l1.32"></a><span id="l1.32"> #define LDAP_GET_TMPLITEM_APPDATA(ti, type) (type)((ti)-&gt;ti_appdata)</span>
<a href="#l1.33"></a><span id="l1.33"> </span>
<a href="#l1.34"></a><span id="l1.34"> #define LDAP_IS_TMPLITEM_OPTION_SET(ti, option) \</span>
<a href="#l1.35"></a><span id="l1.35">   (((ti)-&gt;ti_options &amp; option) != 0)</span>
<a href="#l1.36"></a><span id="l1.36"> </span>
<a href="#l1.37"></a><span id="l1.37"> /*</span>
<a href="#l1.38"></a><span id="l1.38">  * object class array structure</span>
<a href="#l1.39"></a><span id="l1.39">  */</span>
<a href="#l1.40"></a><span id="l1.40"> struct ldap_oclist {</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineminus">-  char **oc_objclasses;</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineminus">-  struct ldap_oclist *oc_next;</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+  char** oc_objclasses;</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+  struct ldap_oclist* oc_next;</span>
<a href="#l1.45"></a><span id="l1.45"> };</span>
<a href="#l1.46"></a><span id="l1.46"> </span>
<a href="#l1.47"></a><span id="l1.47" class="difflineminus">-#define NULLOCLIST ((struct ldap_oclist *)0)</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+#define NULLOCLIST ((struct ldap_oclist*)0)</span>
<a href="#l1.49"></a><span id="l1.49"> </span>
<a href="#l1.50"></a><span id="l1.50"> /*</span>
<a href="#l1.51"></a><span id="l1.51">  * add defaults list</span>
<a href="#l1.52"></a><span id="l1.52">  */</span>
<a href="#l1.53"></a><span id="l1.53"> struct ldap_adddeflist {</span>
<a href="#l1.54"></a><span id="l1.54">   int ad_source;</span>
<a href="#l1.55"></a><span id="l1.55"> #define LDAP_ADSRC_CONSTANTVALUE 1</span>
<a href="#l1.56"></a><span id="l1.56"> #define LDAP_ADSRC_ADDERSDN 2</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineminus">-  char *ad_attrname;</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineminus">-  char *ad_value;</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineminus">-  struct ldap_adddeflist *ad_next;</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+  char* ad_attrname;</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+  char* ad_value;</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+  struct ldap_adddeflist* ad_next;</span>
<a href="#l1.63"></a><span id="l1.63"> };</span>
<a href="#l1.64"></a><span id="l1.64"> </span>
<a href="#l1.65"></a><span id="l1.65" class="difflineminus">-#define NULLADLIST ((struct ldap_adddeflist *)0)</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+#define NULLADLIST ((struct ldap_adddeflist*)0)</span>
<a href="#l1.67"></a><span id="l1.67"> </span>
<a href="#l1.68"></a><span id="l1.68"> /*</span>
<a href="#l1.69"></a><span id="l1.69">  * display template global options</span>
<a href="#l1.70"></a><span id="l1.70">  * if this bit is set in dt_options, it applies.</span>
<a href="#l1.71"></a><span id="l1.71">  */</span>
<a href="#l1.72"></a><span id="l1.72"> /*</span>
<a href="#l1.73"></a><span id="l1.73">  * users should be allowed to try to add objects of these entries</span>
<a href="#l1.74"></a><span id="l1.74">  */</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineat">@@ -221,143 +221,143 @@ struct ldap_adddeflist {</span>
<a href="#l1.76"></a><span id="l1.76">  * this template is an alternate view, not a primary view</span>
<a href="#l1.77"></a><span id="l1.77">  */</span>
<a href="#l1.78"></a><span id="l1.78"> #define LDAP_DTMPL_OPT_ALTVIEW 0x00000004L</span>
<a href="#l1.79"></a><span id="l1.79"> </span>
<a href="#l1.80"></a><span id="l1.80"> /*</span>
<a href="#l1.81"></a><span id="l1.81">  * display template structure</span>
<a href="#l1.82"></a><span id="l1.82">  */</span>
<a href="#l1.83"></a><span id="l1.83"> struct ldap_disptmpl {</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineminus">-  char *dt_name;</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineminus">-  char *dt_pluralname;</span>
<a href="#l1.86"></a><span id="l1.86" class="difflineminus">-  char *dt_iconname;</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineplus">+  char* dt_name;</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineplus">+  char* dt_pluralname;</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineplus">+  char* dt_iconname;</span>
<a href="#l1.90"></a><span id="l1.90">   unsigned long dt_options;</span>
<a href="#l1.91"></a><span id="l1.91" class="difflineminus">-  char *dt_authattrname;</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineminus">-  char *dt_defrdnattrname;</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineminus">-  char *dt_defaddlocation;</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineminus">-  struct ldap_oclist *dt_oclist;</span>
<a href="#l1.95"></a><span id="l1.95" class="difflineminus">-  struct ldap_adddeflist *dt_adddeflist;</span>
<a href="#l1.96"></a><span id="l1.96" class="difflineminus">-  struct ldap_tmplitem *dt_items;</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineminus">-  void *dt_appdata;</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineminus">-  struct ldap_disptmpl *dt_next;</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+  char* dt_authattrname;</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+  char* dt_defrdnattrname;</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+  char* dt_defaddlocation;</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+  struct ldap_oclist* dt_oclist;</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+  struct ldap_adddeflist* dt_adddeflist;</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineplus">+  struct ldap_tmplitem* dt_items;</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineplus">+  void* dt_appdata;</span>
<a href="#l1.106"></a><span id="l1.106" class="difflineplus">+  struct ldap_disptmpl* dt_next;</span>
<a href="#l1.107"></a><span id="l1.107"> };</span>
<a href="#l1.108"></a><span id="l1.108"> </span>
<a href="#l1.109"></a><span id="l1.109" class="difflineminus">-#define NULLDISPTMPL ((struct ldap_disptmpl *)0)</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+#define NULLDISPTMPL ((struct ldap_disptmpl*)0)</span>
<a href="#l1.111"></a><span id="l1.111"> </span>
<a href="#l1.112"></a><span id="l1.112" class="difflineminus">-#define LDAP_SET_DISPTMPL_APPDATA(dt, datap) (dt)-&gt;dt_appdata = (void *)(datap)</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineplus">+#define LDAP_SET_DISPTMPL_APPDATA(dt, datap) (dt)-&gt;dt_appdata = (void*)(datap)</span>
<a href="#l1.114"></a><span id="l1.114"> </span>
<a href="#l1.115"></a><span id="l1.115"> #define LDAP_GET_DISPTMPL_APPDATA(dt, type) (type)((dt)-&gt;dt_appdata)</span>
<a href="#l1.116"></a><span id="l1.116"> </span>
<a href="#l1.117"></a><span id="l1.117"> #define LDAP_IS_DISPTMPL_OPTION_SET(dt, option) \</span>
<a href="#l1.118"></a><span id="l1.118">   (((dt)-&gt;dt_options &amp; option) != 0)</span>
<a href="#l1.119"></a><span id="l1.119"> </span>
<a href="#l1.120"></a><span id="l1.120"> #define LDAP_TMPL_ERR_VERSION 1</span>
<a href="#l1.121"></a><span id="l1.121"> #define LDAP_TMPL_ERR_MEM 2</span>
<a href="#l1.122"></a><span id="l1.122"> #define LDAP_TMPL_ERR_SYNTAX 3</span>
<a href="#l1.123"></a><span id="l1.123"> #define LDAP_TMPL_ERR_FILE 4</span>
<a href="#l1.124"></a><span id="l1.124"> </span>
<a href="#l1.125"></a><span id="l1.125"> /*</span>
<a href="#l1.126"></a><span id="l1.126">  * buffer size needed for entry2text and vals2text</span>
<a href="#l1.127"></a><span id="l1.127">  */</span>
<a href="#l1.128"></a><span id="l1.128"> #define LDAP_DTMPL_BUFSIZ 8192</span>
<a href="#l1.129"></a><span id="l1.129"> </span>
<a href="#l1.130"></a><span id="l1.130" class="difflineminus">-typedef int (*writeptype)(void *writeparm, char *p, int len);</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineplus">+typedef int (*writeptype)(void* writeparm, char* p, int len);</span>
<a href="#l1.132"></a><span id="l1.132"> </span>
<a href="#l1.133"></a><span id="l1.133"> LDAP_API(int)</span>
<a href="#l1.134"></a><span id="l1.134"> LDAP_CALL</span>
<a href="#l1.135"></a><span id="l1.135" class="difflineminus">-ldap_init_templates(char *file, struct ldap_disptmpl **tmpllistp);</span>
<a href="#l1.136"></a><span id="l1.136" class="difflineplus">+ldap_init_templates(char* file, struct ldap_disptmpl** tmpllistp);</span>
<a href="#l1.137"></a><span id="l1.137"> </span>
<a href="#l1.138"></a><span id="l1.138"> LDAP_API(int)</span>
<a href="#l1.139"></a><span id="l1.139"> LDAP_CALL</span>
<a href="#l1.140"></a><span id="l1.140" class="difflineminus">-ldap_init_templates_buf(char *buf, long buflen,</span>
<a href="#l1.141"></a><span id="l1.141" class="difflineminus">-                        struct ldap_disptmpl **tmpllistp);</span>
<a href="#l1.142"></a><span id="l1.142" class="difflineplus">+ldap_init_templates_buf(char* buf, long buflen,</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineplus">+                        struct ldap_disptmpl** tmpllistp);</span>
<a href="#l1.144"></a><span id="l1.144"> </span>
<a href="#l1.145"></a><span id="l1.145"> LDAP_API(void)</span>
<a href="#l1.146"></a><span id="l1.146"> LDAP_CALL</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineminus">-ldap_free_templates(struct ldap_disptmpl *tmpllist);</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineplus">+ldap_free_templates(struct ldap_disptmpl* tmpllist);</span>
<a href="#l1.149"></a><span id="l1.149"> </span>
<a href="#l1.150"></a><span id="l1.150" class="difflineminus">-LDAP_API(struct ldap_disptmpl *)</span>
<a href="#l1.151"></a><span id="l1.151" class="difflineplus">+LDAP_API(struct ldap_disptmpl*)</span>
<a href="#l1.152"></a><span id="l1.152"> LDAP_CALL</span>
<a href="#l1.153"></a><span id="l1.153" class="difflineminus">-ldap_first_disptmpl(struct ldap_disptmpl *tmpllist);</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineplus">+ldap_first_disptmpl(struct ldap_disptmpl* tmpllist);</span>
<a href="#l1.155"></a><span id="l1.155"> </span>
<a href="#l1.156"></a><span id="l1.156" class="difflineminus">-LDAP_API(struct ldap_disptmpl *)</span>
<a href="#l1.157"></a><span id="l1.157" class="difflineplus">+LDAP_API(struct ldap_disptmpl*)</span>
<a href="#l1.158"></a><span id="l1.158"> LDAP_CALL</span>
<a href="#l1.159"></a><span id="l1.159" class="difflineminus">-ldap_next_disptmpl(struct ldap_disptmpl *tmpllist, struct ldap_disptmpl *tmpl);</span>
<a href="#l1.160"></a><span id="l1.160" class="difflineplus">+ldap_next_disptmpl(struct ldap_disptmpl* tmpllist, struct ldap_disptmpl* tmpl);</span>
<a href="#l1.161"></a><span id="l1.161"> </span>
<a href="#l1.162"></a><span id="l1.162" class="difflineminus">-LDAP_API(struct ldap_disptmpl *)</span>
<a href="#l1.163"></a><span id="l1.163" class="difflineplus">+LDAP_API(struct ldap_disptmpl*)</span>
<a href="#l1.164"></a><span id="l1.164"> LDAP_CALL</span>
<a href="#l1.165"></a><span id="l1.165" class="difflineminus">-ldap_name2template(char *name, struct ldap_disptmpl *tmpllist);</span>
<a href="#l1.166"></a><span id="l1.166" class="difflineplus">+ldap_name2template(char* name, struct ldap_disptmpl* tmpllist);</span>
<a href="#l1.167"></a><span id="l1.167"> </span>
<a href="#l1.168"></a><span id="l1.168" class="difflineminus">-LDAP_API(struct ldap_disptmpl *)</span>
<a href="#l1.169"></a><span id="l1.169" class="difflineplus">+LDAP_API(struct ldap_disptmpl*)</span>
<a href="#l1.170"></a><span id="l1.170"> LDAP_CALL</span>
<a href="#l1.171"></a><span id="l1.171" class="difflineminus">-ldap_oc2template(char **oclist, struct ldap_disptmpl *tmpllist);</span>
<a href="#l1.172"></a><span id="l1.172" class="difflineplus">+ldap_oc2template(char** oclist, struct ldap_disptmpl* tmpllist);</span>
<a href="#l1.173"></a><span id="l1.173"> </span>
<a href="#l1.174"></a><span id="l1.174" class="difflineminus">-LDAP_API(char **)</span>
<a href="#l1.175"></a><span id="l1.175" class="difflineplus">+LDAP_API(char**)</span>
<a href="#l1.176"></a><span id="l1.176"> LDAP_CALL</span>
<a href="#l1.177"></a><span id="l1.177" class="difflineminus">-ldap_tmplattrs(struct ldap_disptmpl *tmpl, char **includeattrs, int exclude,</span>
<a href="#l1.178"></a><span id="l1.178" class="difflineplus">+ldap_tmplattrs(struct ldap_disptmpl* tmpl, char** includeattrs, int exclude,</span>
<a href="#l1.179"></a><span id="l1.179">                unsigned long syntaxmask);</span>
<a href="#l1.180"></a><span id="l1.180"> </span>
<a href="#l1.181"></a><span id="l1.181" class="difflineminus">-LDAP_API(struct ldap_tmplitem *)</span>
<a href="#l1.182"></a><span id="l1.182" class="difflineplus">+LDAP_API(struct ldap_tmplitem*)</span>
<a href="#l1.183"></a><span id="l1.183"> LDAP_CALL</span>
<a href="#l1.184"></a><span id="l1.184" class="difflineminus">-ldap_first_tmplrow(struct ldap_disptmpl *tmpl);</span>
<a href="#l1.185"></a><span id="l1.185" class="difflineplus">+ldap_first_tmplrow(struct ldap_disptmpl* tmpl);</span>
<a href="#l1.186"></a><span id="l1.186"> </span>
<a href="#l1.187"></a><span id="l1.187" class="difflineminus">-LDAP_API(struct ldap_tmplitem *)</span>
<a href="#l1.188"></a><span id="l1.188" class="difflineplus">+LDAP_API(struct ldap_tmplitem*)</span>
<a href="#l1.189"></a><span id="l1.189"> LDAP_CALL</span>
<a href="#l1.190"></a><span id="l1.190" class="difflineminus">-ldap_next_tmplrow(struct ldap_disptmpl *tmpl, struct ldap_tmplitem *row);</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineplus">+ldap_next_tmplrow(struct ldap_disptmpl* tmpl, struct ldap_tmplitem* row);</span>
<a href="#l1.192"></a><span id="l1.192"> </span>
<a href="#l1.193"></a><span id="l1.193" class="difflineminus">-LDAP_API(struct ldap_tmplitem *)</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineplus">+LDAP_API(struct ldap_tmplitem*)</span>
<a href="#l1.195"></a><span id="l1.195"> LDAP_CALL</span>
<a href="#l1.196"></a><span id="l1.196" class="difflineminus">-ldap_first_tmplcol(struct ldap_disptmpl *tmpl, struct ldap_tmplitem *row);</span>
<a href="#l1.197"></a><span id="l1.197" class="difflineplus">+ldap_first_tmplcol(struct ldap_disptmpl* tmpl, struct ldap_tmplitem* row);</span>
<a href="#l1.198"></a><span id="l1.198"> </span>
<a href="#l1.199"></a><span id="l1.199" class="difflineminus">-LDAP_API(struct ldap_tmplitem *)</span>
<a href="#l1.200"></a><span id="l1.200" class="difflineplus">+LDAP_API(struct ldap_tmplitem*)</span>
<a href="#l1.201"></a><span id="l1.201"> LDAP_CALL</span>
<a href="#l1.202"></a><span id="l1.202" class="difflineminus">-ldap_next_tmplcol(struct ldap_disptmpl *tmpl, struct ldap_tmplitem *row,</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineminus">-                  struct ldap_tmplitem *col);</span>
<a href="#l1.204"></a><span id="l1.204" class="difflineplus">+ldap_next_tmplcol(struct ldap_disptmpl* tmpl, struct ldap_tmplitem* row,</span>
<a href="#l1.205"></a><span id="l1.205" class="difflineplus">+                  struct ldap_tmplitem* col);</span>
<a href="#l1.206"></a><span id="l1.206"> </span>
<a href="#l1.207"></a><span id="l1.207"> LDAP_API(int)</span>
<a href="#l1.208"></a><span id="l1.208"> LDAP_CALL</span>
<a href="#l1.209"></a><span id="l1.209" class="difflineminus">-ldap_entry2text(LDAP *ld, char *buf, LDAPMessage *entry,</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineminus">-                struct ldap_disptmpl *tmpl, char **defattrs, char ***defvals,</span>
<a href="#l1.211"></a><span id="l1.211" class="difflineminus">-                writeptype writeproc, void *writeparm, char *eol, int rdncount,</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineplus">+ldap_entry2text(LDAP* ld, char* buf, LDAPMessage* entry,</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineplus">+                struct ldap_disptmpl* tmpl, char** defattrs, char*** defvals,</span>
<a href="#l1.214"></a><span id="l1.214" class="difflineplus">+                writeptype writeproc, void* writeparm, char* eol, int rdncount,</span>
<a href="#l1.215"></a><span id="l1.215">                 unsigned long opts);</span>
<a href="#l1.216"></a><span id="l1.216"> </span>
<a href="#l1.217"></a><span id="l1.217"> LDAP_API(int)</span>
<a href="#l1.218"></a><span id="l1.218"> LDAP_CALL</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineminus">-ldap_vals2text(LDAP *ld, char *buf, char **vals, char *label, int labelwidth,</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineminus">-               unsigned long syntaxid, writeptype writeproc, void *writeparm,</span>
<a href="#l1.221"></a><span id="l1.221" class="difflineminus">-               char *eol, int rdncount);</span>
<a href="#l1.222"></a><span id="l1.222" class="difflineplus">+ldap_vals2text(LDAP* ld, char* buf, char** vals, char* label, int labelwidth,</span>
<a href="#l1.223"></a><span id="l1.223" class="difflineplus">+               unsigned long syntaxid, writeptype writeproc, void* writeparm,</span>
<a href="#l1.224"></a><span id="l1.224" class="difflineplus">+               char* eol, int rdncount);</span>
<a href="#l1.225"></a><span id="l1.225"> </span>
<a href="#l1.226"></a><span id="l1.226"> LDAP_API(int)</span>
<a href="#l1.227"></a><span id="l1.227"> LDAP_CALL</span>
<a href="#l1.228"></a><span id="l1.228" class="difflineminus">-ldap_entry2text_search(LDAP *ld, char *dn, char *base, LDAPMessage *entry,</span>
<a href="#l1.229"></a><span id="l1.229" class="difflineminus">-                       struct ldap_disptmpl *tmpllist, char **defattrs,</span>
<a href="#l1.230"></a><span id="l1.230" class="difflineminus">-                       char ***defvals, writeptype writeproc, void *writeparm,</span>
<a href="#l1.231"></a><span id="l1.231" class="difflineminus">-                       char *eol, int rdncount, unsigned long opts);</span>
<a href="#l1.232"></a><span id="l1.232" class="difflineplus">+ldap_entry2text_search(LDAP* ld, char* dn, char* base, LDAPMessage* entry,</span>
<a href="#l1.233"></a><span id="l1.233" class="difflineplus">+                       struct ldap_disptmpl* tmpllist, char** defattrs,</span>
<a href="#l1.234"></a><span id="l1.234" class="difflineplus">+                       char*** defvals, writeptype writeproc, void* writeparm,</span>
<a href="#l1.235"></a><span id="l1.235" class="difflineplus">+                       char* eol, int rdncount, unsigned long opts);</span>
<a href="#l1.236"></a><span id="l1.236"> </span>
<a href="#l1.237"></a><span id="l1.237"> LDAP_API(int)</span>
<a href="#l1.238"></a><span id="l1.238"> LDAP_CALL</span>
<a href="#l1.239"></a><span id="l1.239" class="difflineminus">-ldap_entry2html(LDAP *ld, char *buf, LDAPMessage *entry,</span>
<a href="#l1.240"></a><span id="l1.240" class="difflineminus">-                struct ldap_disptmpl *tmpl, char **defattrs, char ***defvals,</span>
<a href="#l1.241"></a><span id="l1.241" class="difflineminus">-                writeptype writeproc, void *writeparm, char *eol, int rdncount,</span>
<a href="#l1.242"></a><span id="l1.242" class="difflineminus">-                unsigned long opts, char *urlprefix, char *base);</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineplus">+ldap_entry2html(LDAP* ld, char* buf, LDAPMessage* entry,</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineplus">+                struct ldap_disptmpl* tmpl, char** defattrs, char*** defvals,</span>
<a href="#l1.245"></a><span id="l1.245" class="difflineplus">+                writeptype writeproc, void* writeparm, char* eol, int rdncount,</span>
<a href="#l1.246"></a><span id="l1.246" class="difflineplus">+                unsigned long opts, char* urlprefix, char* base);</span>
<a href="#l1.247"></a><span id="l1.247"> </span>
<a href="#l1.248"></a><span id="l1.248"> LDAP_API(int)</span>
<a href="#l1.249"></a><span id="l1.249"> LDAP_CALL</span>
<a href="#l1.250"></a><span id="l1.250" class="difflineminus">-ldap_vals2html(LDAP *ld, char *buf, char **vals, char *label, int labelwidth,</span>
<a href="#l1.251"></a><span id="l1.251" class="difflineminus">-               unsigned long syntaxid, writeptype writeproc, void *writeparm,</span>
<a href="#l1.252"></a><span id="l1.252" class="difflineminus">-               char *eol, int rdncount, char *urlprefix);</span>
<a href="#l1.253"></a><span id="l1.253" class="difflineplus">+ldap_vals2html(LDAP* ld, char* buf, char** vals, char* label, int labelwidth,</span>
<a href="#l1.254"></a><span id="l1.254" class="difflineplus">+               unsigned long syntaxid, writeptype writeproc, void* writeparm,</span>
<a href="#l1.255"></a><span id="l1.255" class="difflineplus">+               char* eol, int rdncount, char* urlprefix);</span>
<a href="#l1.256"></a><span id="l1.256"> </span>
<a href="#l1.257"></a><span id="l1.257"> LDAP_API(int)</span>
<a href="#l1.258"></a><span id="l1.258"> LDAP_CALL</span>
<a href="#l1.259"></a><span id="l1.259" class="difflineminus">-ldap_entry2html_search(LDAP *ld, char *dn, char *base, LDAPMessage *entry,</span>
<a href="#l1.260"></a><span id="l1.260" class="difflineminus">-                       struct ldap_disptmpl *tmpllist, char **defattrs,</span>
<a href="#l1.261"></a><span id="l1.261" class="difflineminus">-                       char ***defvals, writeptype writeproc, void *writeparm,</span>
<a href="#l1.262"></a><span id="l1.262" class="difflineminus">-                       char *eol, int rdncount, unsigned long opts,</span>
<a href="#l1.263"></a><span id="l1.263" class="difflineminus">-                       char *urlprefix);</span>
<a href="#l1.264"></a><span id="l1.264" class="difflineplus">+ldap_entry2html_search(LDAP* ld, char* dn, char* base, LDAPMessage* entry,</span>
<a href="#l1.265"></a><span id="l1.265" class="difflineplus">+                       struct ldap_disptmpl* tmpllist, char** defattrs,</span>
<a href="#l1.266"></a><span id="l1.266" class="difflineplus">+                       char*** defvals, writeptype writeproc, void* writeparm,</span>
<a href="#l1.267"></a><span id="l1.267" class="difflineplus">+                       char* eol, int rdncount, unsigned long opts,</span>
<a href="#l1.268"></a><span id="l1.268" class="difflineplus">+                       char* urlprefix);</span>
<a href="#l1.269"></a><span id="l1.269"> </span>
<a href="#l1.270"></a><span id="l1.270" class="difflineminus">-LDAP_API(char *)</span>
<a href="#l1.271"></a><span id="l1.271" class="difflineplus">+LDAP_API(char*)</span>
<a href="#l1.272"></a><span id="l1.272"> LDAP_CALL</span>
<a href="#l1.273"></a><span id="l1.273"> ldap_tmplerr2string(int err);</span>
<a href="#l1.274"></a><span id="l1.274"> </span>
<a href="#l1.275"></a><span id="l1.275"> #ifdef __cplusplus</span>
<a href="#l1.276"></a><span id="l1.276"> }</span>
<a href="#l1.277"></a><span id="l1.277"> #endif</span>
<a href="#l1.278"></a><span id="l1.278"> #endif /* _DISPTMPL_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/ldap/c-sdk/include/iutil.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/ldap/c-sdk/include/iutil.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -47,26 +47,26 @@</span>
<a href="#l2.4"></a><span id="l2.4"> extern &quot;C&quot; {</span>
<a href="#l2.5"></a><span id="l2.5"> #endif /* __cplusplus */</span>
<a href="#l2.6"></a><span id="l2.6"> </span>
<a href="#l2.7"></a><span id="l2.7"> /* from iutil-lock.c */</span>
<a href="#l2.8"></a><span id="l2.8"> </span>
<a href="#l2.9"></a><span id="l2.9"> #ifdef _WINDOWS</span>
<a href="#l2.10"></a><span id="l2.10"> #  define LDAP_MUTEX_T HANDLE</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-extern char *ldap_strdup();</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-extern unsigned char *ldap_utf8_nextchar();</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineminus">-extern char **ldap_explode_ava();</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+extern char* ldap_strdup();</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+extern unsigned char* ldap_utf8_nextchar();</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+extern char** ldap_explode_ava();</span>
<a href="#l2.18"></a><span id="l2.18"> extern int ldap_utf8_toupper();</span>
<a href="#l2.19"></a><span id="l2.19"> </span>
<a href="#l2.20"></a><span id="l2.20" class="difflineminus">-int pthread_mutex_init(LDAP_MUTEX_T *mp, void *attr);</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineminus">-static void *pthread_mutex_alloc(void);</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineminus">-int pthread_mutex_destroy(LDAP_MUTEX_T *mp);</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineminus">-static void pthread_mutex_free(void *mutexp);</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineminus">-int pthread_mutex_lock(LDAP_MUTEX_T *mp);</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineminus">-int pthread_mutex_unlock(LDAP_MUTEX_T *mp);</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+int pthread_mutex_init(LDAP_MUTEX_T* mp, void* attr);</span>
<a href="#l2.27"></a><span id="l2.27" class="difflineplus">+static void* pthread_mutex_alloc(void);</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineplus">+int pthread_mutex_destroy(LDAP_MUTEX_T* mp);</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+static void pthread_mutex_free(void* mutexp);</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+int pthread_mutex_lock(LDAP_MUTEX_T* mp);</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+int pthread_mutex_unlock(LDAP_MUTEX_T* mp);</span>
<a href="#l2.32"></a><span id="l2.32"> </span>
<a href="#l2.33"></a><span id="l2.33"> #endif /* _WINDOWS */</span>
<a href="#l2.34"></a><span id="l2.34"> </span>
<a href="#l2.35"></a><span id="l2.35"> #ifdef __cplusplus</span>
<a href="#l2.36"></a><span id="l2.36"> }</span>
<a href="#l2.37"></a><span id="l2.37"> #endif /* __cplusplus */</span>
<a href="#l2.38"></a><span id="l2.38"> #endif /* _IUTIL_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/ldap/c-sdk/include/lber.h</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/ldap/c-sdk/include/lber.h</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -107,43 +107,43 @@ extern &quot;C&quot; {</span>
<a href="#l3.4"></a><span id="l3.4"> #define LBER_SOCKBUF_OPT_DESC 0x010</span>
<a href="#l3.5"></a><span id="l3.5"> #define LBER_SOCKBUF_OPT_COPYDESC 0x020</span>
<a href="#l3.6"></a><span id="l3.6"> #define LBER_SOCKBUF_OPT_READ_FN 0x040</span>
<a href="#l3.7"></a><span id="l3.7"> #define LBER_SOCKBUF_OPT_WRITE_FN 0x080</span>
<a href="#l3.8"></a><span id="l3.8"> #define LBER_SOCKBUF_OPT_EXT_IO_FNS 0x100</span>
<a href="#l3.9"></a><span id="l3.9"> #define LBER_SOCKBUF_OPT_VALID_TAG 0x200</span>
<a href="#l3.10"></a><span id="l3.10"> #define LBER_SOCKBUF_OPT_SOCK_ARG 0x400</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-#define LBER_OPT_ON ((void *)1)</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-#define LBER_OPT_OFF ((void *)0)</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+#define LBER_OPT_ON ((void*)1)</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+#define LBER_OPT_OFF ((void*)0)</span>
<a href="#l3.16"></a><span id="l3.16"> </span>
<a href="#l3.17"></a><span id="l3.17"> typedef unsigned int ber_len_t;  /* for BER len */</span>
<a href="#l3.18"></a><span id="l3.18"> typedef unsigned int ber_tag_t;  /* for BER tags */</span>
<a href="#l3.19"></a><span id="l3.19"> typedef int ber_int_t;           /* for BER ints, enums, and Booleans */</span>
<a href="#l3.20"></a><span id="l3.20"> typedef unsigned int ber_uint_t; /* unsigned equivalent of ber_int_t */</span>
<a href="#l3.21"></a><span id="l3.21"> typedef int ber_slen_t;          /* signed equivalent of ber_len_t */</span>
<a href="#l3.22"></a><span id="l3.22"> </span>
<a href="#l3.23"></a><span id="l3.23"> typedef struct berval {</span>
<a href="#l3.24"></a><span id="l3.24">   ber_len_t bv_len;</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineminus">-  char *bv_val;</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+  char* bv_val;</span>
<a href="#l3.27"></a><span id="l3.27"> } BerValue;</span>
<a href="#l3.28"></a><span id="l3.28"> </span>
<a href="#l3.29"></a><span id="l3.29"> typedef struct berelement BerElement;</span>
<a href="#l3.30"></a><span id="l3.30"> typedef struct sockbuf Sockbuf;</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-typedef int (*BERTranslateProc)(char **bufp, ber_uint_t *buflenp,</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+typedef int (*BERTranslateProc)(char** bufp, ber_uint_t* buflenp,</span>
<a href="#l3.33"></a><span id="l3.33">                                 int free_input);</span>
<a href="#l3.34"></a><span id="l3.34"> #ifndef macintosh</span>
<a href="#l3.35"></a><span id="l3.35"> #  if defined(_WINDOWS) || defined(_WIN32) || defined(_CONSOLE)</span>
<a href="#l3.36"></a><span id="l3.36"> #    include &lt;winsock.h&gt; /* for SOCKET */</span>
<a href="#l3.37"></a><span id="l3.37"> typedef SOCKET LBER_SOCKET;</span>
<a href="#l3.38"></a><span id="l3.38"> #  else</span>
<a href="#l3.39"></a><span id="l3.39"> typedef long LBER_SOCKET;</span>
<a href="#l3.40"></a><span id="l3.40"> #  endif /* _WINDOWS */</span>
<a href="#l3.41"></a><span id="l3.41"> #else    /* macintosh */</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineminus">-typedef void *LBER_SOCKET;</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+typedef void* LBER_SOCKET;</span>
<a href="#l3.44"></a><span id="l3.44"> #endif   /* macintosh */</span>
<a href="#l3.45"></a><span id="l3.45"> </span>
<a href="#l3.46"></a><span id="l3.46"> /* calling conventions used by library */</span>
<a href="#l3.47"></a><span id="l3.47"> #ifndef LDAP_CALL</span>
<a href="#l3.48"></a><span id="l3.48"> #  if defined(_WINDOWS) || defined(_WIN32)</span>
<a href="#l3.49"></a><span id="l3.49"> #    define LDAP_C __cdecl</span>
<a href="#l3.50"></a><span id="l3.50"> #    ifndef _WIN32</span>
<a href="#l3.51"></a><span id="l3.51"> #      define __stdcall _far _pascal</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineat">@@ -176,165 +176,165 @@ typedef void *LBER_SOCKET;</span>
<a href="#l3.53"></a><span id="l3.53"> struct lextiof_socket_private;  /* Defined by the extended I/O */</span>
<a href="#l3.54"></a><span id="l3.54">                                 /* callback functions */</span>
<a href="#l3.55"></a><span id="l3.55"> struct lextiof_session_private; /* Defined by the extended I/O */</span>
<a href="#l3.56"></a><span id="l3.56">                                 /* callback functions */</span>
<a href="#l3.57"></a><span id="l3.57"> </span>
<a href="#l3.58"></a><span id="l3.58"> /* This is modeled after the PRIOVec that is passed to the NSPR</span>
<a href="#l3.59"></a><span id="l3.59">    writev function! The void* is a char* in that struct */</span>
<a href="#l3.60"></a><span id="l3.60"> typedef struct ldap_x_iovec {</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineminus">-  char *ldapiov_base;</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+  char* ldapiov_base;</span>
<a href="#l3.63"></a><span id="l3.63">   int ldapiov_len;</span>
<a href="#l3.64"></a><span id="l3.64"> } ldap_x_iovec;</span>
<a href="#l3.65"></a><span id="l3.65"> </span>
<a href="#l3.66"></a><span id="l3.66"> /*</span>
<a href="#l3.67"></a><span id="l3.67">  * libldap read and write I/O function callbacks.  The rest of the I/O callback</span>
<a href="#l3.68"></a><span id="l3.68">  * types are defined in ldap.h</span>
<a href="#l3.69"></a><span id="l3.69">  */</span>
<a href="#l3.70"></a><span id="l3.70"> typedef int(LDAP_C LDAP_CALLBACK LDAP_IOF_READ_CALLBACK)(LBER_SOCKET s,</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-                                                         void *buf,</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+                                                         void* buf,</span>
<a href="#l3.73"></a><span id="l3.73">                                                          int bufsize);</span>
<a href="#l3.74"></a><span id="l3.74"> typedef int(LDAP_C LDAP_CALLBACK LDAP_IOF_WRITE_CALLBACK)(LBER_SOCKET s,</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineminus">-                                                          const void *buf,</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+                                                          const void* buf,</span>
<a href="#l3.77"></a><span id="l3.77">                                                           int len);</span>
<a href="#l3.78"></a><span id="l3.78"> typedef int(LDAP_C LDAP_CALLBACK LDAP_X_EXTIOF_READ_CALLBACK)(</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineminus">-    int s, void *buf, int bufsize, struct lextiof_socket_private *socketarg);</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+    int s, void* buf, int bufsize, struct lextiof_socket_private* socketarg);</span>
<a href="#l3.81"></a><span id="l3.81"> typedef int(LDAP_C LDAP_CALLBACK LDAP_X_EXTIOF_WRITE_CALLBACK)(</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineminus">-    int s, const void *buf, int len, struct lextiof_socket_private *socketarg);</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+    int s, const void* buf, int len, struct lextiof_socket_private* socketarg);</span>
<a href="#l3.84"></a><span id="l3.84"> typedef int(LDAP_C LDAP_CALLBACK LDAP_X_EXTIOF_WRITEV_CALLBACK)(</span>
<a href="#l3.85"></a><span id="l3.85">     int s, const ldap_x_iovec iov[], int iovcnt,</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineminus">-    struct lextiof_socket_private *socketarg);</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineplus">+    struct lextiof_socket_private* socketarg);</span>
<a href="#l3.88"></a><span id="l3.88"> </span>
<a href="#l3.89"></a><span id="l3.89"> /*</span>
<a href="#l3.90"></a><span id="l3.90">  * Structure for use with LBER_SOCKBUF_OPT_EXT_IO_FNS:</span>
<a href="#l3.91"></a><span id="l3.91">  */</span>
<a href="#l3.92"></a><span id="l3.92"> struct lber_x_ext_io_fns {</span>
<a href="#l3.93"></a><span id="l3.93">   /* lbextiofn_size should always be set to LBER_X_EXTIO_FNS_SIZE */</span>
<a href="#l3.94"></a><span id="l3.94">   int lbextiofn_size;</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineminus">-  LDAP_X_EXTIOF_READ_CALLBACK *lbextiofn_read;</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineminus">-  LDAP_X_EXTIOF_WRITE_CALLBACK *lbextiofn_write;</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineminus">-  struct lextiof_socket_private *lbextiofn_socket_arg;</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineminus">-  LDAP_X_EXTIOF_WRITEV_CALLBACK *lbextiofn_writev;</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+  LDAP_X_EXTIOF_READ_CALLBACK* lbextiofn_read;</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+  LDAP_X_EXTIOF_WRITE_CALLBACK* lbextiofn_write;</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+  struct lextiof_socket_private* lbextiofn_socket_arg;</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+  LDAP_X_EXTIOF_WRITEV_CALLBACK* lbextiofn_writev;</span>
<a href="#l3.103"></a><span id="l3.103"> };</span>
<a href="#l3.104"></a><span id="l3.104"> #define LBER_X_EXTIO_FNS_SIZE sizeof(struct lber_x_ext_io_fns)</span>
<a href="#l3.105"></a><span id="l3.105"> </span>
<a href="#l3.106"></a><span id="l3.106"> /*</span>
<a href="#l3.107"></a><span id="l3.107">  * liblber memory allocation callback functions.  These are global to all</span>
<a href="#l3.108"></a><span id="l3.108">  *  Sockbufs and BerElements.  Install your own functions by using a call</span>
<a href="#l3.109"></a><span id="l3.109">  *  like this: ber_set_option( NULL, LBER_OPT_MEMALLOC_FN_PTRS, &amp;memalloc_fns );</span>
<a href="#l3.110"></a><span id="l3.110">  */</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineminus">-typedef void *(LDAP_C LDAP_CALLBACK LDAP_MALLOC_CALLBACK)(size_t size);</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineminus">-typedef void *(LDAP_C LDAP_CALLBACK LDAP_CALLOC_CALLBACK)(size_t nelem,</span>
<a href="#l3.113"></a><span id="l3.113" class="difflineminus">-                                                          size_t elsize);</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineminus">-typedef void *(LDAP_C LDAP_CALLBACK LDAP_REALLOC_CALLBACK)(void *ptr,</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineminus">-                                                           size_t size);</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineminus">-typedef void(LDAP_C LDAP_CALLBACK LDAP_FREE_CALLBACK)(void *ptr);</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+typedef void*(LDAP_C LDAP_CALLBACK LDAP_MALLOC_CALLBACK)(size_t size);</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineplus">+typedef void*(LDAP_C LDAP_CALLBACK LDAP_CALLOC_CALLBACK)(size_t nelem,</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+                                                         size_t elsize);</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+typedef void*(LDAP_C LDAP_CALLBACK LDAP_REALLOC_CALLBACK)(void* ptr,</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+                                                          size_t size);</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineplus">+typedef void(LDAP_C LDAP_CALLBACK LDAP_FREE_CALLBACK)(void* ptr);</span>
<a href="#l3.123"></a><span id="l3.123"> </span>
<a href="#l3.124"></a><span id="l3.124"> struct lber_memalloc_fns {</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineminus">-  LDAP_MALLOC_CALLBACK *lbermem_malloc;</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineminus">-  LDAP_CALLOC_CALLBACK *lbermem_calloc;</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineminus">-  LDAP_REALLOC_CALLBACK *lbermem_realloc;</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineminus">-  LDAP_FREE_CALLBACK *lbermem_free;</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+  LDAP_MALLOC_CALLBACK* lbermem_malloc;</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+  LDAP_CALLOC_CALLBACK* lbermem_calloc;</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+  LDAP_REALLOC_CALLBACK* lbermem_realloc;</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+  LDAP_FREE_CALLBACK* lbermem_free;</span>
<a href="#l3.133"></a><span id="l3.133"> };</span>
<a href="#l3.134"></a><span id="l3.134"> </span>
<a href="#l3.135"></a><span id="l3.135"> /*</span>
<a href="#l3.136"></a><span id="l3.136">  * decode routines</span>
<a href="#l3.137"></a><span id="l3.137">  */</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineminus">-LDAP_API(ber_tag_t) LDAP_CALL ber_get_tag(BerElement *ber);</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineminus">-LDAP_API(ber_tag_t) LDAP_CALL ber_skip_tag(BerElement *ber, ber_len_t *len);</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineminus">-LDAP_API(ber_tag_t) LDAP_CALL ber_peek_tag(BerElement *ber, ber_len_t *len);</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineminus">-LDAP_API(ber_tag_t) LDAP_CALL ber_get_int(BerElement *ber, ber_int_t *num);</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineplus">+LDAP_API(ber_tag_t) LDAP_CALL ber_get_tag(BerElement* ber);</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+LDAP_API(ber_tag_t) LDAP_CALL ber_skip_tag(BerElement* ber, ber_len_t* len);</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineplus">+LDAP_API(ber_tag_t) LDAP_CALL ber_peek_tag(BerElement* ber, ber_len_t* len);</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineplus">+LDAP_API(ber_tag_t) LDAP_CALL ber_get_int(BerElement* ber, ber_int_t* num);</span>
<a href="#l3.146"></a><span id="l3.146"> LDAP_API(ber_tag_t)</span>
<a href="#l3.147"></a><span id="l3.147" class="difflineminus">-LDAP_CALL ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);</span>
<a href="#l3.148"></a><span id="l3.148" class="difflineminus">-LDAP_API(ber_tag_t) LDAP_CALL ber_get_stringa(BerElement *ber, char **buf);</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineplus">+LDAP_CALL ber_get_stringb(BerElement* ber, char* buf, ber_len_t* len);</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+LDAP_API(ber_tag_t) LDAP_CALL ber_get_stringa(BerElement* ber, char** buf);</span>
<a href="#l3.151"></a><span id="l3.151"> LDAP_API(ber_tag_t)</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineminus">-LDAP_CALL ber_get_stringal(BerElement *ber, struct berval **bv);</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineplus">+LDAP_CALL ber_get_stringal(BerElement* ber, struct berval** bv);</span>
<a href="#l3.154"></a><span id="l3.154"> LDAP_API(ber_tag_t)</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineminus">-LDAP_CALL ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *len);</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineminus">-LDAP_API(ber_tag_t) LDAP_CALL ber_get_null(BerElement *ber);</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+LDAP_CALL ber_get_bitstringa(BerElement* ber, char** buf, ber_len_t* len);</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+LDAP_API(ber_tag_t) LDAP_CALL ber_get_null(BerElement* ber);</span>
<a href="#l3.159"></a><span id="l3.159"> LDAP_API(ber_tag_t)</span>
<a href="#l3.160"></a><span id="l3.160" class="difflineminus">-LDAP_CALL ber_get_boolean(BerElement *ber, ber_int_t *boolval);</span>
<a href="#l3.161"></a><span id="l3.161" class="difflineplus">+LDAP_CALL ber_get_boolean(BerElement* ber, ber_int_t* boolval);</span>
<a href="#l3.162"></a><span id="l3.162"> LDAP_API(ber_tag_t)</span>
<a href="#l3.163"></a><span id="l3.163" class="difflineminus">-LDAP_CALL ber_first_element(BerElement *ber, ber_len_t *len, char **last);</span>
<a href="#l3.164"></a><span id="l3.164" class="difflineplus">+LDAP_CALL ber_first_element(BerElement* ber, ber_len_t* len, char** last);</span>
<a href="#l3.165"></a><span id="l3.165"> LDAP_API(ber_tag_t)</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineminus">-LDAP_CALL ber_next_element(BerElement *ber, ber_len_t *len, char *last);</span>
<a href="#l3.167"></a><span id="l3.167" class="difflineminus">-LDAP_API(ber_tag_t) LDAP_C ber_scanf(BerElement *ber, const char *fmt, ...);</span>
<a href="#l3.168"></a><span id="l3.168" class="difflineminus">-LDAP_API(void) LDAP_CALL ber_bvfree(struct berval *bv);</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineminus">-LDAP_API(void) LDAP_CALL ber_bvecfree(struct berval **bv);</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineminus">-LDAP_API(void) LDAP_CALL ber_svecfree(char **vals);</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineminus">-LDAP_API(struct berval *) LDAP_CALL ber_bvdup(const struct berval *bv);</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+LDAP_CALL ber_next_element(BerElement* ber, ber_len_t* len, char* last);</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+LDAP_API(ber_tag_t) LDAP_C ber_scanf(BerElement* ber, const char* fmt, ...);</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineplus">+LDAP_API(void) LDAP_CALL ber_bvfree(struct berval* bv);</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineplus">+LDAP_API(void) LDAP_CALL ber_bvecfree(struct berval** bv);</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineplus">+LDAP_API(void) LDAP_CALL ber_svecfree(char** vals);</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+LDAP_API(struct berval*) LDAP_CALL ber_bvdup(const struct berval* bv);</span>
<a href="#l3.178"></a><span id="l3.178"> LDAP_API(void)</span>
<a href="#l3.179"></a><span id="l3.179"> LDAP_CALL</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineminus">-ber_set_string_translators(BerElement *ber, BERTranslateProc encode_proc,</span>
<a href="#l3.181"></a><span id="l3.181" class="difflineplus">+ber_set_string_translators(BerElement* ber, BERTranslateProc encode_proc,</span>
<a href="#l3.182"></a><span id="l3.182">                            BERTranslateProc decode_proc);</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineminus">-LDAP_API(BerElement *) LDAP_CALL ber_init(const struct berval *bv);</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineplus">+LDAP_API(BerElement*) LDAP_CALL ber_init(const struct berval* bv);</span>
<a href="#l3.185"></a><span id="l3.185"> </span>
<a href="#l3.186"></a><span id="l3.186"> /*</span>
<a href="#l3.187"></a><span id="l3.187">  * encoding routines</span>
<a href="#l3.188"></a><span id="l3.188">  */</span>
<a href="#l3.189"></a><span id="l3.189"> LDAP_API(int)</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineminus">-LDAP_CALL ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineplus">+LDAP_CALL ber_put_enum(BerElement* ber, ber_int_t num, ber_tag_t tag);</span>
<a href="#l3.192"></a><span id="l3.192"> LDAP_API(int)</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineminus">-LDAP_CALL ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+LDAP_CALL ber_put_int(BerElement* ber, ber_int_t num, ber_tag_t tag);</span>
<a href="#l3.195"></a><span id="l3.195"> LDAP_API(int)</span>
<a href="#l3.196"></a><span id="l3.196"> LDAP_CALL</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineminus">-ber_put_ostring(BerElement *ber, char *str, ber_len_t len, ber_tag_t tag);</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+ber_put_ostring(BerElement* ber, char* str, ber_len_t len, ber_tag_t tag);</span>
<a href="#l3.199"></a><span id="l3.199"> LDAP_API(int)</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineminus">-LDAP_CALL ber_put_string(BerElement *ber, char *str, ber_tag_t tag);</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+LDAP_CALL ber_put_string(BerElement* ber, char* str, ber_tag_t tag);</span>
<a href="#l3.202"></a><span id="l3.202"> LDAP_API(int)</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineminus">-LDAP_CALL ber_put_bitstring(BerElement *ber, char *str, ber_len_t bitlen,</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+LDAP_CALL ber_put_bitstring(BerElement* ber, char* str, ber_len_t bitlen,</span>
<a href="#l3.205"></a><span id="l3.205">                             ber_tag_t tag);</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineminus">-LDAP_API(int) LDAP_CALL ber_put_null(BerElement *ber, ber_tag_t tag);</span>
<a href="#l3.207"></a><span id="l3.207" class="difflineplus">+LDAP_API(int) LDAP_CALL ber_put_null(BerElement* ber, ber_tag_t tag);</span>
<a href="#l3.208"></a><span id="l3.208"> LDAP_API(int)</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineminus">-LDAP_CALL ber_put_boolean(BerElement *ber, ber_int_t boolval, ber_tag_t tag);</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineminus">-LDAP_API(int) LDAP_CALL ber_start_seq(BerElement *ber, ber_tag_t tag);</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineminus">-LDAP_API(int) LDAP_CALL ber_start_set(BerElement *ber, ber_tag_t tag);</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineminus">-LDAP_API(int) LDAP_CALL ber_put_seq(BerElement *ber);</span>
<a href="#l3.213"></a><span id="l3.213" class="difflineminus">-LDAP_API(int) LDAP_CALL ber_put_set(BerElement *ber);</span>
<a href="#l3.214"></a><span id="l3.214" class="difflineminus">-LDAP_API(int) LDAP_C ber_printf(BerElement *ber, const char *fmt, ...);</span>
<a href="#l3.215"></a><span id="l3.215" class="difflineminus">-LDAP_API(int) LDAP_CALL ber_flatten(BerElement *ber, struct berval **bvPtr);</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+LDAP_CALL ber_put_boolean(BerElement* ber, ber_int_t boolval, ber_tag_t tag);</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+LDAP_API(int) LDAP_CALL ber_start_seq(BerElement* ber, ber_tag_t tag);</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+LDAP_API(int) LDAP_CALL ber_start_set(BerElement* ber, ber_tag_t tag);</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineplus">+LDAP_API(int) LDAP_CALL ber_put_seq(BerElement* ber);</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+LDAP_API(int) LDAP_CALL ber_put_set(BerElement* ber);</span>
<a href="#l3.221"></a><span id="l3.221" class="difflineplus">+LDAP_API(int) LDAP_C ber_printf(BerElement* ber, const char* fmt, ...);</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+LDAP_API(int) LDAP_CALL ber_flatten(BerElement* ber, struct berval** bvPtr);</span>
<a href="#l3.223"></a><span id="l3.223"> </span>
<a href="#l3.224"></a><span id="l3.224"> /*</span>
<a href="#l3.225"></a><span id="l3.225">  * miscellaneous routines</span>
<a href="#l3.226"></a><span id="l3.226">  */</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineminus">-LDAP_API(void) LDAP_CALL ber_free(BerElement *ber, int freebuf);</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineminus">-LDAP_API(void) LDAP_CALL ber_special_free(void *buf, BerElement *ber);</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineminus">-LDAP_API(int) LDAP_CALL ber_flush(Sockbuf *sb, BerElement *ber, int freeit);</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineminus">-LDAP_API(BerElement *) LDAP_CALL ber_alloc(void);</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineminus">-LDAP_API(BerElement *) LDAP_CALL der_alloc(void);</span>
<a href="#l3.232"></a><span id="l3.232" class="difflineminus">-LDAP_API(BerElement *) LDAP_CALL ber_alloc_t(int options);</span>
<a href="#l3.233"></a><span id="l3.233" class="difflineminus">-LDAP_API(void *) LDAP_CALL ber_special_alloc(size_t size, BerElement **ppBer);</span>
<a href="#l3.234"></a><span id="l3.234" class="difflineminus">-LDAP_API(BerElement *) LDAP_CALL ber_dup(BerElement *ber);</span>
<a href="#l3.235"></a><span id="l3.235" class="difflineplus">+LDAP_API(void) LDAP_CALL ber_free(BerElement* ber, int freebuf);</span>
<a href="#l3.236"></a><span id="l3.236" class="difflineplus">+LDAP_API(void) LDAP_CALL ber_special_free(void* buf, BerElement* ber);</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineplus">+LDAP_API(int) LDAP_CALL ber_flush(Sockbuf* sb, BerElement* ber, int freeit);</span>
<a href="#l3.238"></a><span id="l3.238" class="difflineplus">+LDAP_API(BerElement*) LDAP_CALL ber_alloc(void);</span>
<a href="#l3.239"></a><span id="l3.239" class="difflineplus">+LDAP_API(BerElement*) LDAP_CALL der_alloc(void);</span>
<a href="#l3.240"></a><span id="l3.240" class="difflineplus">+LDAP_API(BerElement*) LDAP_CALL ber_alloc_t(int options);</span>
<a href="#l3.241"></a><span id="l3.241" class="difflineplus">+LDAP_API(void*) LDAP_CALL ber_special_alloc(size_t size, BerElement** ppBer);</span>
<a href="#l3.242"></a><span id="l3.242" class="difflineplus">+LDAP_API(BerElement*) LDAP_CALL ber_dup(BerElement* ber);</span>
<a href="#l3.243"></a><span id="l3.243"> LDAP_API(ber_tag_t)</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineminus">-LDAP_CALL ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineplus">+LDAP_CALL ber_get_next(Sockbuf* sb, ber_len_t* len, BerElement* ber);</span>
<a href="#l3.246"></a><span id="l3.246"> LDAP_API(ber_tag_t)</span>
<a href="#l3.247"></a><span id="l3.247" class="difflineminus">-LDAP_CALL ber_get_next_buffer(void *buffer, size_t buffer_size, ber_len_t *len,</span>
<a href="#l3.248"></a><span id="l3.248" class="difflineminus">-                              BerElement *ber, ber_len_t *Bytes_Scanned);</span>
<a href="#l3.249"></a><span id="l3.249" class="difflineplus">+LDAP_CALL ber_get_next_buffer(void* buffer, size_t buffer_size, ber_len_t* len,</span>
<a href="#l3.250"></a><span id="l3.250" class="difflineplus">+                              BerElement* ber, ber_len_t* Bytes_Scanned);</span>
<a href="#l3.251"></a><span id="l3.251"> LDAP_API(ber_tag_t)</span>
<a href="#l3.252"></a><span id="l3.252" class="difflineminus">-LDAP_CALL ber_get_next_buffer_ext(void *buffer, size_t buffer_size,</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineminus">-                                  ber_len_t *len, BerElement *ber,</span>
<a href="#l3.254"></a><span id="l3.254" class="difflineminus">-                                  ber_len_t *Bytes_Scanned, Sockbuf *sb);</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineplus">+LDAP_CALL ber_get_next_buffer_ext(void* buffer, size_t buffer_size,</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineplus">+                                  ber_len_t* len, BerElement* ber,</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineplus">+                                  ber_len_t* Bytes_Scanned, Sockbuf* sb);</span>
<a href="#l3.258"></a><span id="l3.258"> LDAP_API(ber_int_t)</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineminus">-LDAP_CALL ber_read(BerElement *ber, char *buf, ber_len_t len);</span>
<a href="#l3.260"></a><span id="l3.260" class="difflineplus">+LDAP_CALL ber_read(BerElement* ber, char* buf, ber_len_t len);</span>
<a href="#l3.261"></a><span id="l3.261"> LDAP_API(ber_int_t)</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineminus">-LDAP_CALL ber_write(BerElement *ber, char *buf, ber_len_t len, int nosos);</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineminus">-LDAP_API(void) LDAP_CALL ber_init_w_nullchar(BerElement *ber, int options);</span>
<a href="#l3.264"></a><span id="l3.264" class="difflineminus">-LDAP_API(void) LDAP_CALL ber_reset(BerElement *ber, int was_writing);</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineminus">-LDAP_API(size_t) LDAP_CALL ber_get_buf_datalen(BerElement *ber);</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineplus">+LDAP_CALL ber_write(BerElement* ber, char* buf, ber_len_t len, int nosos);</span>
<a href="#l3.267"></a><span id="l3.267" class="difflineplus">+LDAP_API(void) LDAP_CALL ber_init_w_nullchar(BerElement* ber, int options);</span>
<a href="#l3.268"></a><span id="l3.268" class="difflineplus">+LDAP_API(void) LDAP_CALL ber_reset(BerElement* ber, int was_writing);</span>
<a href="#l3.269"></a><span id="l3.269" class="difflineplus">+LDAP_API(size_t) LDAP_CALL ber_get_buf_datalen(BerElement* ber);</span>
<a href="#l3.270"></a><span id="l3.270"> LDAP_API(int)</span>
<a href="#l3.271"></a><span id="l3.271" class="difflineminus">-LDAP_CALL ber_stack_init(BerElement *ber, int options, char *buf, size_t size);</span>
<a href="#l3.272"></a><span id="l3.272" class="difflineminus">-LDAP_API(char *) LDAP_CALL ber_get_buf_databegin(BerElement *ber);</span>
<a href="#l3.273"></a><span id="l3.273" class="difflineminus">-LDAP_API(void) LDAP_CALL ber_sockbuf_free_data(Sockbuf *p);</span>
<a href="#l3.274"></a><span id="l3.274" class="difflineplus">+LDAP_CALL ber_stack_init(BerElement* ber, int options, char* buf, size_t size);</span>
<a href="#l3.275"></a><span id="l3.275" class="difflineplus">+LDAP_API(char*) LDAP_CALL ber_get_buf_databegin(BerElement* ber);</span>
<a href="#l3.276"></a><span id="l3.276" class="difflineplus">+LDAP_API(void) LDAP_CALL ber_sockbuf_free_data(Sockbuf* p);</span>
<a href="#l3.277"></a><span id="l3.277"> LDAP_API(int)</span>
<a href="#l3.278"></a><span id="l3.278" class="difflineminus">-LDAP_CALL ber_set_option(BerElement *ber, int option, void *value);</span>
<a href="#l3.279"></a><span id="l3.279" class="difflineplus">+LDAP_CALL ber_set_option(BerElement* ber, int option, void* value);</span>
<a href="#l3.280"></a><span id="l3.280"> LDAP_API(int)</span>
<a href="#l3.281"></a><span id="l3.281" class="difflineminus">-LDAP_CALL ber_get_option(BerElement *ber, int option, void *value);</span>
<a href="#l3.282"></a><span id="l3.282" class="difflineminus">-LDAP_API(Sockbuf *) LDAP_CALL ber_sockbuf_alloc(void);</span>
<a href="#l3.283"></a><span id="l3.283" class="difflineminus">-LDAP_API(void) LDAP_CALL ber_sockbuf_free(Sockbuf *p);</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineplus">+LDAP_CALL ber_get_option(BerElement* ber, int option, void* value);</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineplus">+LDAP_API(Sockbuf*) LDAP_CALL ber_sockbuf_alloc(void);</span>
<a href="#l3.286"></a><span id="l3.286" class="difflineplus">+LDAP_API(void) LDAP_CALL ber_sockbuf_free(Sockbuf* p);</span>
<a href="#l3.287"></a><span id="l3.287"> LDAP_API(int)</span>
<a href="#l3.288"></a><span id="l3.288" class="difflineminus">-LDAP_CALL ber_sockbuf_set_option(Sockbuf *sb, int option, void *value);</span>
<a href="#l3.289"></a><span id="l3.289" class="difflineplus">+LDAP_CALL ber_sockbuf_set_option(Sockbuf* sb, int option, void* value);</span>
<a href="#l3.290"></a><span id="l3.290"> LDAP_API(int)</span>
<a href="#l3.291"></a><span id="l3.291" class="difflineminus">-LDAP_CALL ber_sockbuf_get_option(Sockbuf *sb, int option, void *value);</span>
<a href="#l3.292"></a><span id="l3.292" class="difflineplus">+LDAP_CALL ber_sockbuf_get_option(Sockbuf* sb, int option, void* value);</span>
<a href="#l3.293"></a><span id="l3.293"> </span>
<a href="#l3.294"></a><span id="l3.294"> #ifdef __cplusplus</span>
<a href="#l3.295"></a><span id="l3.295"> }</span>
<a href="#l3.296"></a><span id="l3.296"> #endif</span>
<a href="#l3.297"></a><span id="l3.297"> #endif /* _LBER_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/ldap/c-sdk/include/lcache.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/ldap/c-sdk/include/lcache.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -58,45 +58,45 @@ extern &quot;C&quot; {</span>
<a href="#l4.4"></a><span id="l4.4"> #  else /* _WINDOWS */</span>
<a href="#l4.5"></a><span id="l4.5"> #    define LDAP_C</span>
<a href="#l4.6"></a><span id="l4.6"> #    define LDAP_CALLBACK</span>
<a href="#l4.7"></a><span id="l4.7"> #    define LDAP_PASCAL</span>
<a href="#l4.8"></a><span id="l4.8"> #    define LDAP_CALL</span>
<a href="#l4.9"></a><span id="l4.9"> #  endif /* _WINDOWS */</span>
<a href="#l4.10"></a><span id="l4.10"> #endif   /* LDAP_CALL */</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-LDAP_API(int) LDAP_C lcache_init(LDAP *ld, void *arg);</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+LDAP_API(int) LDAP_C lcache_init(LDAP* ld, void* arg);</span>
<a href="#l4.14"></a><span id="l4.14"> LDAP_API(int)</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineminus">-LDAP_C lcache_bind(LDAP *ld, int msgid, unsigned long tag, const char *dn,</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">-                   struct berval *cred, int method);</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineminus">-LDAP_API(int) LDAP_C lcache_unbind(LDAP *ld, int msgid, unsigned long tag);</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+LDAP_C lcache_bind(LDAP* ld, int msgid, unsigned long tag, const char* dn,</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+                   struct berval* cred, int method);</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+LDAP_API(int) LDAP_C lcache_unbind(LDAP* ld, int msgid, unsigned long tag);</span>
<a href="#l4.21"></a><span id="l4.21"> LDAP_API(int)</span>
<a href="#l4.22"></a><span id="l4.22"> LDAP_C</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineminus">-lcache_search(LDAP *ld, int msgid, unsigned long tag, const char *dn, int scope,</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineminus">-              const char *filter, char **attrs, int attrsonly);</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+lcache_search(LDAP* ld, int msgid, unsigned long tag, const char* dn, int scope,</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+              const char* filter, char** attrs, int attrsonly);</span>
<a href="#l4.27"></a><span id="l4.27"> LDAP_API(int)</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineminus">-LDAP_C lcache_compare(LDAP *ld, int msgid, unsigned long tag, const char *dn,</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineminus">-                      const char *attr, struct berval *val);</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+LDAP_C lcache_compare(LDAP* ld, int msgid, unsigned long tag, const char* dn,</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+                      const char* attr, struct berval* val);</span>
<a href="#l4.32"></a><span id="l4.32"> LDAP_API(int)</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineminus">-LDAP_C lcache_add(LDAP *ld, int msgid, unsigned long tag, const char *dn,</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineminus">-                  LDAPMod **entry);</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+LDAP_C lcache_add(LDAP* ld, int msgid, unsigned long tag, const char* dn,</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+                  LDAPMod** entry);</span>
<a href="#l4.37"></a><span id="l4.37"> LDAP_API(int)</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineminus">-LDAP_C lcache_delete(LDAP *ld, int msgid, unsigned long tag, const char *dn);</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+LDAP_C lcache_delete(LDAP* ld, int msgid, unsigned long tag, const char* dn);</span>
<a href="#l4.40"></a><span id="l4.40"> LDAP_API(int)</span>
<a href="#l4.41"></a><span id="l4.41"> LDAP_C</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineminus">-lcache_rename(LDAP *ld, int msgid, unsigned long tag, const char *dn,</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineminus">-              const char *newrdn, const char *newparent, int deleteoldrdn);</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+lcache_rename(LDAP* ld, int msgid, unsigned long tag, const char* dn,</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+              const char* newrdn, const char* newparent, int deleteoldrdn);</span>
<a href="#l4.46"></a><span id="l4.46"> LDAP_API(int)</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineminus">-LDAP_C lcache_modify(LDAP *ld, int msgid, unsigned long tag, const char *dn,</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineminus">-                     LDAPMod **mods);</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+LDAP_C lcache_modify(LDAP* ld, int msgid, unsigned long tag, const char* dn,</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+                     LDAPMod** mods);</span>
<a href="#l4.51"></a><span id="l4.51"> LDAP_API(int)</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineminus">-LDAP_C lcache_modrdn(LDAP *ld, int msgid, unsigned long tag, const char *dn,</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineminus">-                     const char *newrdn, int deleteoldrdn);</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+LDAP_C lcache_modrdn(LDAP* ld, int msgid, unsigned long tag, const char* dn,</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+                     const char* newrdn, int deleteoldrdn);</span>
<a href="#l4.56"></a><span id="l4.56"> LDAP_API(int)</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineminus">-LDAP_C lcache_result(LDAP *ld, int msgid, int all, struct timeval *timeout,</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineminus">-                     LDAPMessage **result);</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineminus">-LDAP_API(int) LDAP_C lcache_flush(LDAP *ld, char *dn, char *filter);</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+LDAP_C lcache_result(LDAP* ld, int msgid, int all, struct timeval* timeout,</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineplus">+                     LDAPMessage** result);</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+LDAP_API(int) LDAP_C lcache_flush(LDAP* ld, char* dn, char* filter);</span>
<a href="#l4.63"></a><span id="l4.63"> </span>
<a href="#l4.64"></a><span id="l4.64"> #ifdef __cplusplus</span>
<a href="#l4.65"></a><span id="l4.65"> }</span>
<a href="#l4.66"></a><span id="l4.66"> #endif</span>
<a href="#l4.67"></a><span id="l4.67"> </span>
<a href="#l4.68"></a><span id="l4.68"> #endif /* _LCACHE_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/ldap/c-sdk/include/ldap-deprecated.h</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/ldap/c-sdk/include/ldap-deprecated.h</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -55,58 +55,58 @@</span>
<a href="#l5.4"></a><span id="l5.4"> </span>
<a href="#l5.5"></a><span id="l5.5"> #ifdef __cplusplus</span>
<a href="#l5.6"></a><span id="l5.6"> extern &quot;C&quot; {</span>
<a href="#l5.7"></a><span id="l5.7"> #endif</span>
<a href="#l5.8"></a><span id="l5.8"> </span>
<a href="#l5.9"></a><span id="l5.9"> /*</span>
<a href="#l5.10"></a><span id="l5.10">  * establish an ldap session</span>
<a href="#l5.11"></a><span id="l5.11">  */</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-LDAP_API(LDAP *) LDAP_CALL ldap_open(const char *host, int port);</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+LDAP_API(LDAP*) LDAP_CALL ldap_open(const char* host, int port);</span>
<a href="#l5.14"></a><span id="l5.14"> </span>
<a href="#l5.15"></a><span id="l5.15"> /*</span>
<a href="#l5.16"></a><span id="l5.16">  * Authentication methods:</span>
<a href="#l5.17"></a><span id="l5.17">  */</span>
<a href="#l5.18"></a><span id="l5.18"> #define LDAP_AUTH_NONE 0x00L</span>
<a href="#l5.19"></a><span id="l5.19"> #define LDAP_AUTH_SIMPLE 0x80L</span>
<a href="#l5.20"></a><span id="l5.20"> #define LDAP_AUTH_SASL 0xa3L</span>
<a href="#l5.21"></a><span id="l5.21"> LDAP_API(int)</span>
<a href="#l5.22"></a><span id="l5.22"> LDAP_CALL</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineminus">-ldap_bind(LDAP *ld, const char *who, const char *passwd, int authmethod);</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+ldap_bind(LDAP* ld, const char* who, const char* passwd, int authmethod);</span>
<a href="#l5.25"></a><span id="l5.25"> LDAP_API(int)</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineminus">-LDAP_CALL ldap_bind_s(LDAP *ld, const char *who, const char *cred, int method);</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineplus">+LDAP_CALL ldap_bind_s(LDAP* ld, const char* who, const char* cred, int method);</span>
<a href="#l5.28"></a><span id="l5.28"> </span>
<a href="#l5.29"></a><span id="l5.29"> LDAP_API(int)</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineminus">-LDAP_CALL ldap_modrdn(LDAP *ld, const char *dn, const char *newrdn);</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+LDAP_CALL ldap_modrdn(LDAP* ld, const char* dn, const char* newrdn);</span>
<a href="#l5.32"></a><span id="l5.32"> LDAP_API(int)</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineminus">-LDAP_CALL ldap_modrdn_s(LDAP *ld, const char *dn, const char *newrdn);</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+LDAP_CALL ldap_modrdn_s(LDAP* ld, const char* dn, const char* newrdn);</span>
<a href="#l5.35"></a><span id="l5.35"> LDAP_API(int)</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineminus">-LDAP_CALL ldap_modrdn2(LDAP *ld, const char *dn, const char *newrdn,</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineplus">+LDAP_CALL ldap_modrdn2(LDAP* ld, const char* dn, const char* newrdn,</span>
<a href="#l5.38"></a><span id="l5.38">                        int deleteoldrdn);</span>
<a href="#l5.39"></a><span id="l5.39"> LDAP_API(int)</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineminus">-LDAP_CALL ldap_modrdn2_s(LDAP *ld, const char *dn, const char *newrdn,</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+LDAP_CALL ldap_modrdn2_s(LDAP* ld, const char* dn, const char* newrdn,</span>
<a href="#l5.42"></a><span id="l5.42">                          int deleteoldrdn);</span>
<a href="#l5.43"></a><span id="l5.43"> </span>
<a href="#l5.44"></a><span id="l5.44" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_perror(LDAP *ld, const char *s);</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_result2error(LDAP *ld, LDAPMessage *r, int freeit);</span>
<a href="#l5.46"></a><span id="l5.46" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_perror(LDAP* ld, const char* s);</span>
<a href="#l5.47"></a><span id="l5.47" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_result2error(LDAP* ld, LDAPMessage* r, int freeit);</span>
<a href="#l5.48"></a><span id="l5.48"> </span>
<a href="#l5.49"></a><span id="l5.49"> /*</span>
<a href="#l5.50"></a><span id="l5.50">  * Preferred language and get_lang_values (an API extension --</span>
<a href="#l5.51"></a><span id="l5.51">  * LDAP_API_FEATURE_X_GETLANGVALUES)</span>
<a href="#l5.52"></a><span id="l5.52">  *</span>
<a href="#l5.53"></a><span id="l5.53">  * The following two APIs are deprecated</span>
<a href="#l5.54"></a><span id="l5.54">  */</span>
<a href="#l5.55"></a><span id="l5.55"> </span>
<a href="#l5.56"></a><span id="l5.56"> #define LDAP_OPT_PREFERRED_LANGUAGE 0x14 /* 20 - API extension */</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineminus">-LDAP_API(char **)</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineminus">-LDAP_CALL ldap_get_lang_values(LDAP *ld, LDAPMessage *entry, const char *target,</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineminus">-                               char **type);</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineminus">-LDAP_API(struct berval **)</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineminus">-LDAP_CALL ldap_get_lang_values_len(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineminus">-                                   const char *target, char **type);</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+LDAP_API(char**)</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+LDAP_CALL ldap_get_lang_values(LDAP* ld, LDAPMessage* entry, const char* target,</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+                               char** type);</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+LDAP_API(struct berval**)</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+LDAP_CALL ldap_get_lang_values_len(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+                                   const char* target, char** type);</span>
<a href="#l5.69"></a><span id="l5.69"> </span>
<a href="#l5.70"></a><span id="l5.70"> /*</span>
<a href="#l5.71"></a><span id="l5.71">  * Asynchronous I/O (an API extension).</span>
<a href="#l5.72"></a><span id="l5.72">  */</span>
<a href="#l5.73"></a><span id="l5.73"> /*</span>
<a href="#l5.74"></a><span id="l5.74">  * This option enables completely asynchronous IO.  It works by using ioctl()</span>
<a href="#l5.75"></a><span id="l5.75">  * on the fd, (or tlook())</span>
<a href="#l5.76"></a><span id="l5.76">  */</span>
<a href="#l5.77"></a><span id="l5.77" class="difflineat">@@ -122,26 +122,26 @@ LDAP_CALL ldap_get_lang_values_len(LDAP </span>
<a href="#l5.78"></a><span id="l5.78"> typedef struct _LDAPVersion {</span>
<a href="#l5.79"></a><span id="l5.79">   int sdk_version;      /* Version of the SDK, * 100 */</span>
<a href="#l5.80"></a><span id="l5.80">   int protocol_version; /* Highest protocol version supported, * 100 */</span>
<a href="#l5.81"></a><span id="l5.81">   int SSL_version;      /* SSL version if this SDK supports it, * 100 */</span>
<a href="#l5.82"></a><span id="l5.82">   int security_level;   /* highest level available */</span>
<a href="#l5.83"></a><span id="l5.83">   int reserved[4];</span>
<a href="#l5.84"></a><span id="l5.84"> } LDAPVersion;</span>
<a href="#l5.85"></a><span id="l5.85"> #define LDAP_SECURITY_NONE 0</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_version(LDAPVersion *ver);</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_version(LDAPVersion* ver);</span>
<a href="#l5.88"></a><span id="l5.88"> </span>
<a href="#l5.89"></a><span id="l5.89"> /* use ldap_create_filter() instead of ldap_build_filter() */</span>
<a href="#l5.90"></a><span id="l5.90"> LDAP_API(void)</span>
<a href="#l5.91"></a><span id="l5.91" class="difflineminus">-LDAP_CALL ldap_build_filter(char *buf, unsigned long buflen, char *pattern,</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineminus">-                            char *prefix, char *suffix, char *attr, char *value,</span>
<a href="#l5.93"></a><span id="l5.93" class="difflineminus">-                            char **valwords);</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineplus">+LDAP_CALL ldap_build_filter(char* buf, unsigned long buflen, char* pattern,</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineplus">+                            char* prefix, char* suffix, char* attr, char* value,</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+                            char** valwords);</span>
<a href="#l5.97"></a><span id="l5.97"> /* use ldap_set_filter_additions() instead of ldap_setfilteraffixes() */</span>
<a href="#l5.98"></a><span id="l5.98"> LDAP_API(void)</span>
<a href="#l5.99"></a><span id="l5.99" class="difflineminus">-LDAP_CALL ldap_setfilteraffixes(LDAPFiltDesc *lfdp, char *prefix, char *suffix);</span>
<a href="#l5.100"></a><span id="l5.100" class="difflineplus">+LDAP_CALL ldap_setfilteraffixes(LDAPFiltDesc* lfdp, char* prefix, char* suffix);</span>
<a href="#l5.101"></a><span id="l5.101"> </span>
<a href="#l5.102"></a><span id="l5.102"> /* older result types a server can return -- use LDAP_RES_MODDN instead */</span>
<a href="#l5.103"></a><span id="l5.103"> #define LDAP_RES_MODRDN LDAP_RES_MODDN</span>
<a href="#l5.104"></a><span id="l5.104"> #define LDAP_RES_RENAME LDAP_RES_MODDN</span>
<a href="#l5.105"></a><span id="l5.105"> </span>
<a href="#l5.106"></a><span id="l5.106"> /* older error messages */</span>
<a href="#l5.107"></a><span id="l5.107"> #define LDAP_AUTH_METHOD_NOT_SUPPORTED LDAP_STRONG_AUTH_NOT_SUPPORTED</span>
<a href="#l5.108"></a><span id="l5.108"> </span>
<a href="#l5.109"></a><span id="l5.109" class="difflineat">@@ -153,62 +153,62 @@ LDAP_CALL ldap_setfilteraffixes(LDAPFilt</span>
<a href="#l5.110"></a><span id="l5.110"> #define LDAP_OPT_CACHE_ENABLE 0x0F   /* 15 - API extension */</span>
<a href="#l5.111"></a><span id="l5.111"> </span>
<a href="#l5.112"></a><span id="l5.112"> /* cache strategies */</span>
<a href="#l5.113"></a><span id="l5.113"> #define LDAP_CACHE_CHECK 0</span>
<a href="#l5.114"></a><span id="l5.114"> #define LDAP_CACHE_POPULATE 1</span>
<a href="#l5.115"></a><span id="l5.115"> #define LDAP_CACHE_LOCALDB 2</span>
<a href="#l5.116"></a><span id="l5.116"> </span>
<a href="#l5.117"></a><span id="l5.117"> typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_BIND_CALLBACK)(</span>
<a href="#l5.118"></a><span id="l5.118" class="difflineminus">-    LDAP *ld, int msgid, unsigned long tag, const char *dn,</span>
<a href="#l5.119"></a><span id="l5.119" class="difflineminus">-    const struct berval *creds, int method);</span>
<a href="#l5.120"></a><span id="l5.120" class="difflineplus">+    LDAP* ld, int msgid, unsigned long tag, const char* dn,</span>
<a href="#l5.121"></a><span id="l5.121" class="difflineplus">+    const struct berval* creds, int method);</span>
<a href="#l5.122"></a><span id="l5.122"> typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_UNBIND_CALLBACK)(</span>
<a href="#l5.123"></a><span id="l5.123" class="difflineminus">-    LDAP *ld, int unused0, unsigned long unused1);</span>
<a href="#l5.124"></a><span id="l5.124" class="difflineplus">+    LDAP* ld, int unused0, unsigned long unused1);</span>
<a href="#l5.125"></a><span id="l5.125"> typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_SEARCH_CALLBACK)(</span>
<a href="#l5.126"></a><span id="l5.126" class="difflineminus">-    LDAP *ld, int msgid, unsigned long tag, const char *base, int scope,</span>
<a href="#l5.127"></a><span id="l5.127" class="difflineminus">-    const char LDAP_CALLBACK *filter, char **attrs, int attrsonly);</span>
<a href="#l5.128"></a><span id="l5.128" class="difflineplus">+    LDAP* ld, int msgid, unsigned long tag, const char* base, int scope,</span>
<a href="#l5.129"></a><span id="l5.129" class="difflineplus">+    const char LDAP_CALLBACK* filter, char** attrs, int attrsonly);</span>
<a href="#l5.130"></a><span id="l5.130"> typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_COMPARE_CALLBACK)(</span>
<a href="#l5.131"></a><span id="l5.131" class="difflineminus">-    LDAP *ld, int msgid, unsigned long tag, const char *dn, const char *attr,</span>
<a href="#l5.132"></a><span id="l5.132" class="difflineminus">-    const struct berval *value);</span>
<a href="#l5.133"></a><span id="l5.133" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_ADD_CALLBACK)(LDAP *ld, int msgid,</span>
<a href="#l5.134"></a><span id="l5.134" class="difflineplus">+    LDAP* ld, int msgid, unsigned long tag, const char* dn, const char* attr,</span>
<a href="#l5.135"></a><span id="l5.135" class="difflineplus">+    const struct berval* value);</span>
<a href="#l5.136"></a><span id="l5.136" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_ADD_CALLBACK)(LDAP* ld, int msgid,</span>
<a href="#l5.137"></a><span id="l5.137">                                                        unsigned long tag,</span>
<a href="#l5.138"></a><span id="l5.138" class="difflineminus">-                                                       const char *dn,</span>
<a href="#l5.139"></a><span id="l5.139" class="difflineminus">-                                                       LDAPMod **attrs);</span>
<a href="#l5.140"></a><span id="l5.140" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_DELETE_CALLBACK)(LDAP *ld, int msgid,</span>
<a href="#l5.141"></a><span id="l5.141" class="difflineplus">+                                                       const char* dn,</span>
<a href="#l5.142"></a><span id="l5.142" class="difflineplus">+                                                       LDAPMod** attrs);</span>
<a href="#l5.143"></a><span id="l5.143" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_DELETE_CALLBACK)(LDAP* ld, int msgid,</span>
<a href="#l5.144"></a><span id="l5.144">                                                           unsigned long tag,</span>
<a href="#l5.145"></a><span id="l5.145" class="difflineminus">-                                                          const char *dn);</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_MODIFY_CALLBACK)(LDAP *ld, int msgid,</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineplus">+                                                          const char* dn);</span>
<a href="#l5.148"></a><span id="l5.148" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_MODIFY_CALLBACK)(LDAP* ld, int msgid,</span>
<a href="#l5.149"></a><span id="l5.149">                                                           unsigned long tag,</span>
<a href="#l5.150"></a><span id="l5.150" class="difflineminus">-                                                          const char *dn,</span>
<a href="#l5.151"></a><span id="l5.151" class="difflineminus">-                                                          LDAPMod **mods);</span>
<a href="#l5.152"></a><span id="l5.152" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_MODRDN_CALLBACK)(LDAP *ld, int msgid,</span>
<a href="#l5.153"></a><span id="l5.153" class="difflineplus">+                                                          const char* dn,</span>
<a href="#l5.154"></a><span id="l5.154" class="difflineplus">+                                                          LDAPMod** mods);</span>
<a href="#l5.155"></a><span id="l5.155" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_MODRDN_CALLBACK)(LDAP* ld, int msgid,</span>
<a href="#l5.156"></a><span id="l5.156">                                                           unsigned long tag,</span>
<a href="#l5.157"></a><span id="l5.157" class="difflineminus">-                                                          const char *dn,</span>
<a href="#l5.158"></a><span id="l5.158" class="difflineminus">-                                                          const char *newrdn,</span>
<a href="#l5.159"></a><span id="l5.159" class="difflineplus">+                                                          const char* dn,</span>
<a href="#l5.160"></a><span id="l5.160" class="difflineplus">+                                                          const char* newrdn,</span>
<a href="#l5.161"></a><span id="l5.161">                                                           int deleteoldrdn);</span>
<a href="#l5.162"></a><span id="l5.162"> typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_RESULT_CALLBACK)(</span>
<a href="#l5.163"></a><span id="l5.163" class="difflineminus">-    LDAP *ld, int msgid, int all, struct timeval *timeout,</span>
<a href="#l5.164"></a><span id="l5.164" class="difflineminus">-    LDAPMessage **result);</span>
<a href="#l5.165"></a><span id="l5.165" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_FLUSH_CALLBACK)(LDAP *ld,</span>
<a href="#l5.166"></a><span id="l5.166" class="difflineminus">-                                                         const char *dn,</span>
<a href="#l5.167"></a><span id="l5.167" class="difflineminus">-                                                         const char *filter);</span>
<a href="#l5.168"></a><span id="l5.168" class="difflineplus">+    LDAP* ld, int msgid, int all, struct timeval* timeout,</span>
<a href="#l5.169"></a><span id="l5.169" class="difflineplus">+    LDAPMessage** result);</span>
<a href="#l5.170"></a><span id="l5.170" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_CF_FLUSH_CALLBACK)(LDAP* ld,</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineplus">+                                                         const char* dn,</span>
<a href="#l5.172"></a><span id="l5.172" class="difflineplus">+                                                         const char* filter);</span>
<a href="#l5.173"></a><span id="l5.173"> </span>
<a href="#l5.174"></a><span id="l5.174"> struct ldap_cache_fns {</span>
<a href="#l5.175"></a><span id="l5.175" class="difflineminus">-  void *lcf_private;</span>
<a href="#l5.176"></a><span id="l5.176" class="difflineminus">-  LDAP_CF_BIND_CALLBACK *lcf_bind;</span>
<a href="#l5.177"></a><span id="l5.177" class="difflineminus">-  LDAP_CF_UNBIND_CALLBACK *lcf_unbind;</span>
<a href="#l5.178"></a><span id="l5.178" class="difflineminus">-  LDAP_CF_SEARCH_CALLBACK *lcf_search;</span>
<a href="#l5.179"></a><span id="l5.179" class="difflineminus">-  LDAP_CF_COMPARE_CALLBACK *lcf_compare;</span>
<a href="#l5.180"></a><span id="l5.180" class="difflineminus">-  LDAP_CF_ADD_CALLBACK *lcf_add;</span>
<a href="#l5.181"></a><span id="l5.181" class="difflineminus">-  LDAP_CF_DELETE_CALLBACK *lcf_delete;</span>
<a href="#l5.182"></a><span id="l5.182" class="difflineminus">-  LDAP_CF_MODIFY_CALLBACK *lcf_modify;</span>
<a href="#l5.183"></a><span id="l5.183" class="difflineminus">-  LDAP_CF_MODRDN_CALLBACK *lcf_modrdn;</span>
<a href="#l5.184"></a><span id="l5.184" class="difflineminus">-  LDAP_CF_RESULT_CALLBACK *lcf_result;</span>
<a href="#l5.185"></a><span id="l5.185" class="difflineminus">-  LDAP_CF_FLUSH_CALLBACK *lcf_flush;</span>
<a href="#l5.186"></a><span id="l5.186" class="difflineplus">+  void* lcf_private;</span>
<a href="#l5.187"></a><span id="l5.187" class="difflineplus">+  LDAP_CF_BIND_CALLBACK* lcf_bind;</span>
<a href="#l5.188"></a><span id="l5.188" class="difflineplus">+  LDAP_CF_UNBIND_CALLBACK* lcf_unbind;</span>
<a href="#l5.189"></a><span id="l5.189" class="difflineplus">+  LDAP_CF_SEARCH_CALLBACK* lcf_search;</span>
<a href="#l5.190"></a><span id="l5.190" class="difflineplus">+  LDAP_CF_COMPARE_CALLBACK* lcf_compare;</span>
<a href="#l5.191"></a><span id="l5.191" class="difflineplus">+  LDAP_CF_ADD_CALLBACK* lcf_add;</span>
<a href="#l5.192"></a><span id="l5.192" class="difflineplus">+  LDAP_CF_DELETE_CALLBACK* lcf_delete;</span>
<a href="#l5.193"></a><span id="l5.193" class="difflineplus">+  LDAP_CF_MODIFY_CALLBACK* lcf_modify;</span>
<a href="#l5.194"></a><span id="l5.194" class="difflineplus">+  LDAP_CF_MODRDN_CALLBACK* lcf_modrdn;</span>
<a href="#l5.195"></a><span id="l5.195" class="difflineplus">+  LDAP_CF_RESULT_CALLBACK* lcf_result;</span>
<a href="#l5.196"></a><span id="l5.196" class="difflineplus">+  LDAP_CF_FLUSH_CALLBACK* lcf_flush;</span>
<a href="#l5.197"></a><span id="l5.197"> };</span>
<a href="#l5.198"></a><span id="l5.198"> </span>
<a href="#l5.199"></a><span id="l5.199"> LDAP_API(int)</span>
<a href="#l5.200"></a><span id="l5.200" class="difflineminus">-LDAP_CALL ldap_cache_flush(LDAP *ld, const char *dn, const char *filter);</span>
<a href="#l5.201"></a><span id="l5.201" class="difflineplus">+LDAP_CALL ldap_cache_flush(LDAP* ld, const char* dn, const char* filter);</span>
<a href="#l5.202"></a><span id="l5.202"> </span>
<a href="#l5.203"></a><span id="l5.203"> #ifdef __cplusplus</span>
<a href="#l5.204"></a><span id="l5.204"> }</span>
<a href="#l5.205"></a><span id="l5.205"> #endif</span>
<a href="#l5.206"></a><span id="l5.206"> #endif /* _LDAP_DEPRECATED_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/ldap/c-sdk/include/ldap-extension.h</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/ldap/c-sdk/include/ldap-extension.h</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -72,17 +72,17 @@ extern &quot;C&quot; {</span>
<a href="#l6.4"></a><span id="l6.4"> #define LDAP_API_FEATURE_X_CLIENT_SIDE_SORT 1</span>
<a href="#l6.5"></a><span id="l6.5"> #define LDAP_API_FEATURE_X_URL_FUNCTIONS 1</span>
<a href="#l6.6"></a><span id="l6.6"> #define LDAP_API_FEATURE_X_FILTER_FUNCTIONS 1</span>
<a href="#l6.7"></a><span id="l6.7"> </span>
<a href="#l6.8"></a><span id="l6.8"> #define LDAP_ROOT_DSE &quot;&quot; /* API extension */</span>
<a href="#l6.9"></a><span id="l6.9"> </span>
<a href="#l6.10"></a><span id="l6.10"> #define LDAP_OPT_DESC 0x01 /*  1 */</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-#define NULLMSG ((LDAPMessage *)0)</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+#define NULLMSG ((LDAPMessage*)0)</span>
<a href="#l6.14"></a><span id="l6.14"> </span>
<a href="#l6.15"></a><span id="l6.15"> /*built-in SASL methods */</span>
<a href="#l6.16"></a><span id="l6.16"> #define LDAP_SASL_EXTERNAL &quot;EXTERNAL&quot; /* TLS/SSL extension */</span>
<a href="#l6.17"></a><span id="l6.17"> </span>
<a href="#l6.18"></a><span id="l6.18"> /* possible error codes we can be returned */</span>
<a href="#l6.19"></a><span id="l6.19"> #define LDAP_PARTIAL_RESULTS 0x09 /* 9 (UMich LDAPv2 extn) */</span>
<a href="#l6.20"></a><span id="l6.20"> #define NAME_ERROR(n) ((n &amp; 0xf0) == 0x20)</span>
<a href="#l6.21"></a><span id="l6.21"> </span>
<a href="#l6.22"></a><span id="l6.22" class="difflineat">@@ -140,28 +140,28 @@ extern &quot;C&quot; {</span>
<a href="#l6.23"></a><span id="l6.23"> #define LDAP_CONTROL_GETEFFECTIVERIGHTS_REQUEST &quot;1.3.6.1.4.1.42.2.27.9.5.2&quot;</span>
<a href="#l6.24"></a><span id="l6.24"> </span>
<a href="#l6.25"></a><span id="l6.25"> /* Password Policy Control to get account availability */</span>
<a href="#l6.26"></a><span id="l6.26"> #define LDAP_CONTROL_ACCOUNT_USABLE &quot;1.3.6.1.4.1.42.2.27.9.5.8&quot;</span>
<a href="#l6.27"></a><span id="l6.27"> </span>
<a href="#l6.28"></a><span id="l6.28"> /* &quot;Who am I?&quot; Extended Operation */</span>
<a href="#l6.29"></a><span id="l6.29"> #define LDAP_EXOP_WHO_AM_I &quot;1.3.6.1.4.1.4203.1.11.3&quot;</span>
<a href="#l6.30"></a><span id="l6.30"> </span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_ber_free(BerElement *ber, int freebuf);</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_ber_free(BerElement* ber, int freebuf);</span>
<a href="#l6.33"></a><span id="l6.33"> </span>
<a href="#l6.34"></a><span id="l6.34" class="difflineminus">-LDAP_API(LDAPControl *)</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineminus">-LDAP_CALL ldap_find_control(const char *oid, LDAPControl **ctrls);</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+LDAP_API(LDAPControl*)</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+LDAP_CALL ldap_find_control(const char* oid, LDAPControl** ctrls);</span>
<a href="#l6.38"></a><span id="l6.38"> </span>
<a href="#l6.39"></a><span id="l6.39"> /*</span>
<a href="#l6.40"></a><span id="l6.40">  * Server side sorting of search results (an LDAPv3 extension --</span>
<a href="#l6.41"></a><span id="l6.41">  * LDAP_API_FEATURE_SERVER_SIDE_SORT)</span>
<a href="#l6.42"></a><span id="l6.42">  */</span>
<a href="#l6.43"></a><span id="l6.43"> typedef struct LDAPsortkey { /* structure for a sort-key */</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineminus">-  char *sk_attrtype;</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineminus">-  char *sk_matchruleoid;</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+  char* sk_attrtype;</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+  char* sk_matchruleoid;</span>
<a href="#l6.48"></a><span id="l6.48">   int sk_reverseorder;</span>
<a href="#l6.49"></a><span id="l6.49"> } LDAPsortkey;</span>
<a href="#l6.50"></a><span id="l6.50"> </span>
<a href="#l6.51"></a><span id="l6.51"> /* where LDAP_CONTROL_ACCOUNT_USABLE control parse results */</span>
<a href="#l6.52"></a><span id="l6.52"> typedef struct LDAPuserstatus { /* user account availability   */</span>
<a href="#l6.53"></a><span id="l6.53">   unsigned int us_available;    /* availability status         */</span>
<a href="#l6.54"></a><span id="l6.54"> #define LDAP_US_ACCOUNT_USABLE 1</span>
<a href="#l6.55"></a><span id="l6.55"> #define LDAP_US_ACCOUNT_NOT_USABLE 0</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineat">@@ -190,205 +190,205 @@ typedef enum passpolicyerror_enum {</span>
<a href="#l6.57"></a><span id="l6.57">   PP_passwordTooShort = 6,</span>
<a href="#l6.58"></a><span id="l6.58">   PP_passwordTooYoung = 7,</span>
<a href="#l6.59"></a><span id="l6.59">   PP_passwordInHistory = 8,</span>
<a href="#l6.60"></a><span id="l6.60">   PP_noError = 65535</span>
<a href="#l6.61"></a><span id="l6.61"> } LDAPPasswordPolicyError;</span>
<a href="#l6.62"></a><span id="l6.62"> </span>
<a href="#l6.63"></a><span id="l6.63"> LDAP_API(int)</span>
<a href="#l6.64"></a><span id="l6.64"> LDAP_CALL</span>
<a href="#l6.65"></a><span id="l6.65" class="difflineminus">-ldap_create_sort_control(LDAP *ld, LDAPsortkey **sortKeyList,</span>
<a href="#l6.66"></a><span id="l6.66" class="difflineminus">-                         const char ctl_iscritical, LDAPControl **ctrlp);</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineplus">+ldap_create_sort_control(LDAP* ld, LDAPsortkey** sortKeyList,</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+                         const char ctl_iscritical, LDAPControl** ctrlp);</span>
<a href="#l6.69"></a><span id="l6.69"> LDAP_API(int)</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineminus">-LDAP_CALL ldap_parse_sort_control(LDAP *ld, LDAPControl **ctrls,</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineminus">-                                  ber_int_t *result, char **attribute);</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+LDAP_CALL ldap_parse_sort_control(LDAP* ld, LDAPControl** ctrls,</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+                                  ber_int_t* result, char** attribute);</span>
<a href="#l6.74"></a><span id="l6.74"> </span>
<a href="#l6.75"></a><span id="l6.75" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_free_sort_keylist(LDAPsortkey **sortKeyList);</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_free_sort_keylist(LDAPsortkey** sortKeyList);</span>
<a href="#l6.77"></a><span id="l6.77"> LDAP_API(int)</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineminus">-LDAP_CALL ldap_create_sort_keylist(LDAPsortkey ***sortKeyList,</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineminus">-                                   const char *string_rep);</span>
<a href="#l6.80"></a><span id="l6.80" class="difflineplus">+LDAP_CALL ldap_create_sort_keylist(LDAPsortkey*** sortKeyList,</span>
<a href="#l6.81"></a><span id="l6.81" class="difflineplus">+                                   const char* string_rep);</span>
<a href="#l6.82"></a><span id="l6.82"> </span>
<a href="#l6.83"></a><span id="l6.83"> LDAP_API(int)</span>
<a href="#l6.84"></a><span id="l6.84" class="difflineminus">-LDAP_CALL ldap_create_userstatus_control(LDAP *ld, const char ctl_iscritical,</span>
<a href="#l6.85"></a><span id="l6.85" class="difflineminus">-                                         LDAPControl **ctrlp);</span>
<a href="#l6.86"></a><span id="l6.86" class="difflineplus">+LDAP_CALL ldap_create_userstatus_control(LDAP* ld, const char ctl_iscritical,</span>
<a href="#l6.87"></a><span id="l6.87" class="difflineplus">+                                         LDAPControl** ctrlp);</span>
<a href="#l6.88"></a><span id="l6.88"> LDAP_API(int)</span>
<a href="#l6.89"></a><span id="l6.89" class="difflineminus">-LDAP_CALL ldap_parse_userstatus_control(LDAP *ld, LDAPControl **ctrlp,</span>
<a href="#l6.90"></a><span id="l6.90" class="difflineminus">-                                        LDAPuserstatus *us);</span>
<a href="#l6.91"></a><span id="l6.91" class="difflineplus">+LDAP_CALL ldap_parse_userstatus_control(LDAP* ld, LDAPControl** ctrlp,</span>
<a href="#l6.92"></a><span id="l6.92" class="difflineplus">+                                        LDAPuserstatus* us);</span>
<a href="#l6.93"></a><span id="l6.93"> </span>
<a href="#l6.94"></a><span id="l6.94"> LDAP_API(int)</span>
<a href="#l6.95"></a><span id="l6.95" class="difflineminus">-LDAP_CALL ldap_create_passwordpolicy_control(LDAP *ld, LDAPControl **ctrlp);</span>
<a href="#l6.96"></a><span id="l6.96" class="difflineplus">+LDAP_CALL ldap_create_passwordpolicy_control(LDAP* ld, LDAPControl** ctrlp);</span>
<a href="#l6.97"></a><span id="l6.97"> LDAP_API(int)</span>
<a href="#l6.98"></a><span id="l6.98"> LDAP_CALL</span>
<a href="#l6.99"></a><span id="l6.99" class="difflineminus">-ldap_create_passwordpolicy_control_ext(LDAP *ld, const char ctl_iscritical,</span>
<a href="#l6.100"></a><span id="l6.100" class="difflineminus">-                                       LDAPControl **ctrlp);</span>
<a href="#l6.101"></a><span id="l6.101" class="difflineplus">+ldap_create_passwordpolicy_control_ext(LDAP* ld, const char ctl_iscritical,</span>
<a href="#l6.102"></a><span id="l6.102" class="difflineplus">+                                       LDAPControl** ctrlp);</span>
<a href="#l6.103"></a><span id="l6.103"> LDAP_API(int)</span>
<a href="#l6.104"></a><span id="l6.104"> LDAP_CALL</span>
<a href="#l6.105"></a><span id="l6.105" class="difflineminus">-ldap_parse_passwordpolicy_control(LDAP *ld, LDAPControl *ctrlp,</span>
<a href="#l6.106"></a><span id="l6.106" class="difflineminus">-                                  ber_int_t *expirep, ber_int_t *gracep,</span>
<a href="#l6.107"></a><span id="l6.107" class="difflineminus">-                                  LDAPPasswordPolicyError *errorp);</span>
<a href="#l6.108"></a><span id="l6.108" class="difflineplus">+ldap_parse_passwordpolicy_control(LDAP* ld, LDAPControl* ctrlp,</span>
<a href="#l6.109"></a><span id="l6.109" class="difflineplus">+                                  ber_int_t* expirep, ber_int_t* gracep,</span>
<a href="#l6.110"></a><span id="l6.110" class="difflineplus">+                                  LDAPPasswordPolicyError* errorp);</span>
<a href="#l6.111"></a><span id="l6.111"> LDAP_API(int)</span>
<a href="#l6.112"></a><span id="l6.112"> LDAP_CALL</span>
<a href="#l6.113"></a><span id="l6.113" class="difflineminus">-ldap_parse_passwordpolicy_control_ext(LDAP *ld, LDAPControl **ctrlp,</span>
<a href="#l6.114"></a><span id="l6.114" class="difflineminus">-                                      ber_int_t *expirep, ber_int_t *gracep,</span>
<a href="#l6.115"></a><span id="l6.115" class="difflineminus">-                                      LDAPPasswordPolicyError *errorp);</span>
<a href="#l6.116"></a><span id="l6.116" class="difflineminus">-LDAP_API(const char *)</span>
<a href="#l6.117"></a><span id="l6.117" class="difflineplus">+ldap_parse_passwordpolicy_control_ext(LDAP* ld, LDAPControl** ctrlp,</span>
<a href="#l6.118"></a><span id="l6.118" class="difflineplus">+                                      ber_int_t* expirep, ber_int_t* gracep,</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineplus">+                                      LDAPPasswordPolicyError* errorp);</span>
<a href="#l6.120"></a><span id="l6.120" class="difflineplus">+LDAP_API(const char*)</span>
<a href="#l6.121"></a><span id="l6.121"> LDAP_CALL ldap_passwordpolicy_err2txt(LDAPPasswordPolicyError err);</span>
<a href="#l6.122"></a><span id="l6.122"> </span>
<a href="#l6.123"></a><span id="l6.123"> LDAP_API(int)</span>
<a href="#l6.124"></a><span id="l6.124" class="difflineminus">-LDAP_CALL ldap_create_authzid_control(LDAP *ld, const char ctl_iscritical,</span>
<a href="#l6.125"></a><span id="l6.125" class="difflineminus">-                                      LDAPControl **ctrlp);</span>
<a href="#l6.126"></a><span id="l6.126" class="difflineplus">+LDAP_CALL ldap_create_authzid_control(LDAP* ld, const char ctl_iscritical,</span>
<a href="#l6.127"></a><span id="l6.127" class="difflineplus">+                                      LDAPControl** ctrlp);</span>
<a href="#l6.128"></a><span id="l6.128"> LDAP_API(int)</span>
<a href="#l6.129"></a><span id="l6.129"> LDAP_CALL</span>
<a href="#l6.130"></a><span id="l6.130" class="difflineminus">-ldap_parse_authzid_control(LDAP *ld, LDAPControl **ctrlp, char **authzid);</span>
<a href="#l6.131"></a><span id="l6.131" class="difflineplus">+ldap_parse_authzid_control(LDAP* ld, LDAPControl** ctrlp, char** authzid);</span>
<a href="#l6.132"></a><span id="l6.132"> </span>
<a href="#l6.133"></a><span id="l6.133"> LDAP_API(int)</span>
<a href="#l6.134"></a><span id="l6.134" class="difflineminus">-LDAP_CALL ldap_whoami(LDAP *ld, LDAPControl **serverctrls,</span>
<a href="#l6.135"></a><span id="l6.135" class="difflineminus">-                      LDAPControl **clientctrls, int *msgidp);</span>
<a href="#l6.136"></a><span id="l6.136" class="difflineplus">+LDAP_CALL ldap_whoami(LDAP* ld, LDAPControl** serverctrls,</span>
<a href="#l6.137"></a><span id="l6.137" class="difflineplus">+                      LDAPControl** clientctrls, int* msgidp);</span>
<a href="#l6.138"></a><span id="l6.138"> LDAP_API(int)</span>
<a href="#l6.139"></a><span id="l6.139" class="difflineminus">-LDAP_CALL ldap_whoami_s(LDAP *ld, struct berval **authzid,</span>
<a href="#l6.140"></a><span id="l6.140" class="difflineminus">-                        LDAPControl **serverctrls, LDAPControl **clientctrls);</span>
<a href="#l6.141"></a><span id="l6.141" class="difflineplus">+LDAP_CALL ldap_whoami_s(LDAP* ld, struct berval** authzid,</span>
<a href="#l6.142"></a><span id="l6.142" class="difflineplus">+                        LDAPControl** serverctrls, LDAPControl** clientctrls);</span>
<a href="#l6.143"></a><span id="l6.143"> LDAP_API(int)</span>
<a href="#l6.144"></a><span id="l6.144"> LDAP_CALL</span>
<a href="#l6.145"></a><span id="l6.145" class="difflineminus">-ldap_parse_whoami(LDAP *ld, LDAPMessage *result, struct berval **authzid);</span>
<a href="#l6.146"></a><span id="l6.146" class="difflineplus">+ldap_parse_whoami(LDAP* ld, LDAPMessage* result, struct berval** authzid);</span>
<a href="#l6.147"></a><span id="l6.147"> </span>
<a href="#l6.148"></a><span id="l6.148"> LDAP_API(int)</span>
<a href="#l6.149"></a><span id="l6.149" class="difflineminus">-LDAP_CALL ldap_create_geteffectiveRights_control(LDAP *ld, const char *authzid,</span>
<a href="#l6.150"></a><span id="l6.150" class="difflineminus">-                                                 const char **attrlist,</span>
<a href="#l6.151"></a><span id="l6.151" class="difflineplus">+LDAP_CALL ldap_create_geteffectiveRights_control(LDAP* ld, const char* authzid,</span>
<a href="#l6.152"></a><span id="l6.152" class="difflineplus">+                                                 const char** attrlist,</span>
<a href="#l6.153"></a><span id="l6.153">                                                  const char ctl_iscritical,</span>
<a href="#l6.154"></a><span id="l6.154" class="difflineminus">-                                                 LDAPControl **ctrlp);</span>
<a href="#l6.155"></a><span id="l6.155" class="difflineplus">+                                                 LDAPControl** ctrlp);</span>
<a href="#l6.156"></a><span id="l6.156"> </span>
<a href="#l6.157"></a><span id="l6.157"> /*</span>
<a href="#l6.158"></a><span id="l6.158">  * Virtual list view (an LDAPv3 extension -- LDAP_API_FEATURE_VIRTUAL_LIST_VIEW)</span>
<a href="#l6.159"></a><span id="l6.159">  */</span>
<a href="#l6.160"></a><span id="l6.160"> /*</span>
<a href="#l6.161"></a><span id="l6.161">  * structure that describes a VirtualListViewRequest control.</span>
<a href="#l6.162"></a><span id="l6.162">  * note that ldvlist_index and ldvlist_size are only relevant to</span>
<a href="#l6.163"></a><span id="l6.163">  * ldap_create_virtuallist_control() if ldvlist_attrvalue is NULL.</span>
<a href="#l6.164"></a><span id="l6.164">  */</span>
<a href="#l6.165"></a><span id="l6.165"> typedef struct ldapvirtuallist {</span>
<a href="#l6.166"></a><span id="l6.166">   ber_int_t ldvlist_before_count; /* # entries before target */</span>
<a href="#l6.167"></a><span id="l6.167">   ber_int_t ldvlist_after_count;  /* # entries after target */</span>
<a href="#l6.168"></a><span id="l6.168" class="difflineminus">-  char *ldvlist_attrvalue;        /* jump to this value */</span>
<a href="#l6.169"></a><span id="l6.169" class="difflineplus">+  char* ldvlist_attrvalue;        /* jump to this value */</span>
<a href="#l6.170"></a><span id="l6.170">   ber_int_t ldvlist_index;        /* list offset */</span>
<a href="#l6.171"></a><span id="l6.171">   ber_int_t ldvlist_size;         /* number of items in vlist */</span>
<a href="#l6.172"></a><span id="l6.172" class="difflineminus">-  void *ldvlist_extradata;        /* for use by application */</span>
<a href="#l6.173"></a><span id="l6.173" class="difflineplus">+  void* ldvlist_extradata;        /* for use by application */</span>
<a href="#l6.174"></a><span id="l6.174"> } LDAPVirtualList;</span>
<a href="#l6.175"></a><span id="l6.175"> </span>
<a href="#l6.176"></a><span id="l6.176"> /*</span>
<a href="#l6.177"></a><span id="l6.177">  * VLV functions:</span>
<a href="#l6.178"></a><span id="l6.178">  */</span>
<a href="#l6.179"></a><span id="l6.179"> LDAP_API(int)</span>
<a href="#l6.180"></a><span id="l6.180" class="difflineminus">-LDAP_CALL ldap_create_virtuallist_control(LDAP *ld, LDAPVirtualList *ldvlistp,</span>
<a href="#l6.181"></a><span id="l6.181" class="difflineminus">-                                          LDAPControl **ctrlp);</span>
<a href="#l6.182"></a><span id="l6.182" class="difflineplus">+LDAP_CALL ldap_create_virtuallist_control(LDAP* ld, LDAPVirtualList* ldvlistp,</span>
<a href="#l6.183"></a><span id="l6.183" class="difflineplus">+                                          LDAPControl** ctrlp);</span>
<a href="#l6.184"></a><span id="l6.184"> </span>
<a href="#l6.185"></a><span id="l6.185"> LDAP_API(int)</span>
<a href="#l6.186"></a><span id="l6.186" class="difflineminus">-LDAP_CALL ldap_parse_virtuallist_control(LDAP *ld, LDAPControl **ctrls,</span>
<a href="#l6.187"></a><span id="l6.187" class="difflineminus">-                                         ber_int_t *target_posp,</span>
<a href="#l6.188"></a><span id="l6.188" class="difflineminus">-                                         ber_int_t *list_sizep, int *errcodep);</span>
<a href="#l6.189"></a><span id="l6.189" class="difflineplus">+LDAP_CALL ldap_parse_virtuallist_control(LDAP* ld, LDAPControl** ctrls,</span>
<a href="#l6.190"></a><span id="l6.190" class="difflineplus">+                                         ber_int_t* target_posp,</span>
<a href="#l6.191"></a><span id="l6.191" class="difflineplus">+                                         ber_int_t* list_sizep, int* errcodep);</span>
<a href="#l6.192"></a><span id="l6.192"> </span>
<a href="#l6.193"></a><span id="l6.193"> /*</span>
<a href="#l6.194"></a><span id="l6.194">  * Routines for creating persistent search controls and for handling</span>
<a href="#l6.195"></a><span id="l6.195">  * &quot;entry changed notification&quot; controls (an LDAPv3 extension --</span>
<a href="#l6.196"></a><span id="l6.196">  * LDAP_API_FEATURE_PERSISTENT_SEARCH)</span>
<a href="#l6.197"></a><span id="l6.197">  */</span>
<a href="#l6.198"></a><span id="l6.198"> #define LDAP_CHANGETYPE_ADD 1</span>
<a href="#l6.199"></a><span id="l6.199"> #define LDAP_CHANGETYPE_DELETE 2</span>
<a href="#l6.200"></a><span id="l6.200"> #define LDAP_CHANGETYPE_MODIFY 4</span>
<a href="#l6.201"></a><span id="l6.201"> #define LDAP_CHANGETYPE_MODDN 8</span>
<a href="#l6.202"></a><span id="l6.202"> #define LDAP_CHANGETYPE_ANY (1 | 2 | 4 | 8)</span>
<a href="#l6.203"></a><span id="l6.203"> LDAP_API(int)</span>
<a href="#l6.204"></a><span id="l6.204"> LDAP_CALL</span>
<a href="#l6.205"></a><span id="l6.205" class="difflineminus">-ldap_create_persistentsearch_control(LDAP *ld, int changetypes, int changesonly,</span>
<a href="#l6.206"></a><span id="l6.206" class="difflineplus">+ldap_create_persistentsearch_control(LDAP* ld, int changetypes, int changesonly,</span>
<a href="#l6.207"></a><span id="l6.207">                                      int return_echg_ctls, char ctl_iscritical,</span>
<a href="#l6.208"></a><span id="l6.208" class="difflineminus">-                                     LDAPControl **ctrlp);</span>
<a href="#l6.209"></a><span id="l6.209" class="difflineplus">+                                     LDAPControl** ctrlp);</span>
<a href="#l6.210"></a><span id="l6.210"> LDAP_API(int)</span>
<a href="#l6.211"></a><span id="l6.211"> LDAP_CALL</span>
<a href="#l6.212"></a><span id="l6.212" class="difflineminus">-ldap_parse_entrychange_control(LDAP *ld, LDAPControl **ctrls,</span>
<a href="#l6.213"></a><span id="l6.213" class="difflineminus">-                               ber_int_t *chgtypep, char **prevdnp,</span>
<a href="#l6.214"></a><span id="l6.214" class="difflineminus">-                               int *chgnumpresentp, ber_int_t *chgnump);</span>
<a href="#l6.215"></a><span id="l6.215" class="difflineplus">+ldap_parse_entrychange_control(LDAP* ld, LDAPControl** ctrls,</span>
<a href="#l6.216"></a><span id="l6.216" class="difflineplus">+                               ber_int_t* chgtypep, char** prevdnp,</span>
<a href="#l6.217"></a><span id="l6.217" class="difflineplus">+                               int* chgnumpresentp, ber_int_t* chgnump);</span>
<a href="#l6.218"></a><span id="l6.218"> </span>
<a href="#l6.219"></a><span id="l6.219"> /*</span>
<a href="#l6.220"></a><span id="l6.220">  * Routines for creating Proxied Authorization controls (an LDAPv3</span>
<a href="#l6.221"></a><span id="l6.221">  * extension -- LDAP_API_FEATURE_PROXY_AUTHORIZATION)</span>
<a href="#l6.222"></a><span id="l6.222">  * ldap_create_proxyauth_control() is for the old (version 1) control.</span>
<a href="#l6.223"></a><span id="l6.223">  * ldap_create_proxiedauth_control() is for the newer (version 2) control.</span>
<a href="#l6.224"></a><span id="l6.224">  */</span>
<a href="#l6.225"></a><span id="l6.225"> LDAP_API(int)</span>
<a href="#l6.226"></a><span id="l6.226" class="difflineminus">-LDAP_CALL ldap_create_proxyauth_control(LDAP *ld, const char *dn,</span>
<a href="#l6.227"></a><span id="l6.227" class="difflineplus">+LDAP_CALL ldap_create_proxyauth_control(LDAP* ld, const char* dn,</span>
<a href="#l6.228"></a><span id="l6.228">                                         const char ctl_iscritical,</span>
<a href="#l6.229"></a><span id="l6.229" class="difflineminus">-                                        LDAPControl **ctrlp);</span>
<a href="#l6.230"></a><span id="l6.230" class="difflineplus">+                                        LDAPControl** ctrlp);</span>
<a href="#l6.231"></a><span id="l6.231"> LDAP_API(int)</span>
<a href="#l6.232"></a><span id="l6.232" class="difflineminus">-LDAP_CALL ldap_create_proxiedauth_control(LDAP *ld, const char *authzid,</span>
<a href="#l6.233"></a><span id="l6.233" class="difflineminus">-                                          LDAPControl **ctrlp);</span>
<a href="#l6.234"></a><span id="l6.234" class="difflineplus">+LDAP_CALL ldap_create_proxiedauth_control(LDAP* ld, const char* authzid,</span>
<a href="#l6.235"></a><span id="l6.235" class="difflineplus">+                                          LDAPControl** ctrlp);</span>
<a href="#l6.236"></a><span id="l6.236"> </span>
<a href="#l6.237"></a><span id="l6.237"> /*</span>
<a href="#l6.238"></a><span id="l6.238">  * Functions to get and set LDAP error information (API extension --</span>
<a href="#l6.239"></a><span id="l6.239">  * LDAP_API_FEATURE_X_LDERRNO )</span>
<a href="#l6.240"></a><span id="l6.240">  *</span>
<a href="#l6.241"></a><span id="l6.241">  * By using LDAP_OPT_THREAD_FN_PTRS, you can arrange for the error info. to</span>
<a href="#l6.242"></a><span id="l6.242">  * be thread-specific.</span>
<a href="#l6.243"></a><span id="l6.243">  */</span>
<a href="#l6.244"></a><span id="l6.244" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_get_lderrno(LDAP *ld, char **m, char **s);</span>
<a href="#l6.245"></a><span id="l6.245" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_set_lderrno(LDAP *ld, int e, char *m, char *s);</span>
<a href="#l6.246"></a><span id="l6.246" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_get_lderrno(LDAP* ld, char** m, char** s);</span>
<a href="#l6.247"></a><span id="l6.247" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_set_lderrno(LDAP* ld, int e, char* m, char* s);</span>
<a href="#l6.248"></a><span id="l6.248"> </span>
<a href="#l6.249"></a><span id="l6.249"> /*</span>
<a href="#l6.250"></a><span id="l6.250">  * LDAP URL functions and definitions (an API extension --</span>
<a href="#l6.251"></a><span id="l6.251">  * LDAP_API_FEATURE_X_URL_FUNCTIONS)</span>
<a href="#l6.252"></a><span id="l6.252">  */</span>
<a href="#l6.253"></a><span id="l6.253"> /*</span>
<a href="#l6.254"></a><span id="l6.254">  * types for ldap URL handling</span>
<a href="#l6.255"></a><span id="l6.255">  */</span>
<a href="#l6.256"></a><span id="l6.256"> typedef struct ldap_url_desc {</span>
<a href="#l6.257"></a><span id="l6.257" class="difflineminus">-  char *lud_host;</span>
<a href="#l6.258"></a><span id="l6.258" class="difflineplus">+  char* lud_host;</span>
<a href="#l6.259"></a><span id="l6.259">   int lud_port;</span>
<a href="#l6.260"></a><span id="l6.260" class="difflineminus">-  char *lud_dn;</span>
<a href="#l6.261"></a><span id="l6.261" class="difflineminus">-  char **lud_attrs;</span>
<a href="#l6.262"></a><span id="l6.262" class="difflineplus">+  char* lud_dn;</span>
<a href="#l6.263"></a><span id="l6.263" class="difflineplus">+  char** lud_attrs;</span>
<a href="#l6.264"></a><span id="l6.264">   int lud_scope;</span>
<a href="#l6.265"></a><span id="l6.265" class="difflineminus">-  char *lud_filter;</span>
<a href="#l6.266"></a><span id="l6.266" class="difflineplus">+  char* lud_filter;</span>
<a href="#l6.267"></a><span id="l6.267">   unsigned long lud_options;</span>
<a href="#l6.268"></a><span id="l6.268"> #define LDAP_URL_OPT_SECURE 0x01</span>
<a href="#l6.269"></a><span id="l6.269" class="difflineminus">-  char *lud_string; /* for internal use only */</span>
<a href="#l6.270"></a><span id="l6.270" class="difflineplus">+  char* lud_string; /* for internal use only */</span>
<a href="#l6.271"></a><span id="l6.271"> } LDAPURLDesc;</span>
<a href="#l6.272"></a><span id="l6.272"> </span>
<a href="#l6.273"></a><span id="l6.273" class="difflineminus">-#define NULLLDAPURLDESC ((LDAPURLDesc *)NULL)</span>
<a href="#l6.274"></a><span id="l6.274" class="difflineplus">+#define NULLLDAPURLDESC ((LDAPURLDesc*)NULL)</span>
<a href="#l6.275"></a><span id="l6.275"> </span>
<a href="#l6.276"></a><span id="l6.276"> /*</span>
<a href="#l6.277"></a><span id="l6.277">  * possible errors returned by ldap_url_parse()</span>
<a href="#l6.278"></a><span id="l6.278">  */</span>
<a href="#l6.279"></a><span id="l6.279"> #define LDAP_URL_ERR_NOTLDAP 1  /* URL doesn't begin with &quot;ldap://&quot; */</span>
<a href="#l6.280"></a><span id="l6.280"> #define LDAP_URL_ERR_NODN 2     /* URL has no DN (required) */</span>
<a href="#l6.281"></a><span id="l6.281"> #define LDAP_URL_ERR_BADSCOPE 3 /* URL scope string is invalid */</span>
<a href="#l6.282"></a><span id="l6.282"> #define LDAP_URL_ERR_MEM 4      /* can't allocate memory space */</span>
<a href="#l6.283"></a><span id="l6.283"> #define LDAP_URL_ERR_PARAM 5    /* bad parameter to an URL function */</span>
<a href="#l6.284"></a><span id="l6.284"> #define LDAP_URL_UNRECOGNIZED_CRITICAL_EXTENSION 6</span>
<a href="#l6.285"></a><span id="l6.285"> </span>
<a href="#l6.286"></a><span id="l6.286"> /*</span>
<a href="#l6.287"></a><span id="l6.287">  * URL functions:</span>
<a href="#l6.288"></a><span id="l6.288">  */</span>
<a href="#l6.289"></a><span id="l6.289" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_is_ldap_url(const char *url);</span>
<a href="#l6.290"></a><span id="l6.290" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_url_parse(const char *url, LDAPURLDesc **ludpp);</span>
<a href="#l6.291"></a><span id="l6.291" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_is_ldap_url(const char* url);</span>
<a href="#l6.292"></a><span id="l6.292" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_url_parse(const char* url, LDAPURLDesc** ludpp);</span>
<a href="#l6.293"></a><span id="l6.293"> LDAP_API(int)</span>
<a href="#l6.294"></a><span id="l6.294" class="difflineminus">-LDAP_CALL ldap_url_parse_no_defaults(const char *url, LDAPURLDesc **ludpp,</span>
<a href="#l6.295"></a><span id="l6.295" class="difflineplus">+LDAP_CALL ldap_url_parse_no_defaults(const char* url, LDAPURLDesc** ludpp,</span>
<a href="#l6.296"></a><span id="l6.296">                                      int dn_required);</span>
<a href="#l6.297"></a><span id="l6.297" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_free_urldesc(LDAPURLDesc *ludp);</span>
<a href="#l6.298"></a><span id="l6.298" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_free_urldesc(LDAPURLDesc* ludp);</span>
<a href="#l6.299"></a><span id="l6.299"> LDAP_API(int)</span>
<a href="#l6.300"></a><span id="l6.300" class="difflineminus">-LDAP_CALL ldap_url_search(LDAP *ld, const char *url, int attrsonly);</span>
<a href="#l6.301"></a><span id="l6.301" class="difflineplus">+LDAP_CALL ldap_url_search(LDAP* ld, const char* url, int attrsonly);</span>
<a href="#l6.302"></a><span id="l6.302"> LDAP_API(int)</span>
<a href="#l6.303"></a><span id="l6.303" class="difflineminus">-LDAP_CALL ldap_url_search_s(LDAP *ld, const char *url, int attrsonly,</span>
<a href="#l6.304"></a><span id="l6.304" class="difflineminus">-                            LDAPMessage **res);</span>
<a href="#l6.305"></a><span id="l6.305" class="difflineplus">+LDAP_CALL ldap_url_search_s(LDAP* ld, const char* url, int attrsonly,</span>
<a href="#l6.306"></a><span id="l6.306" class="difflineplus">+                            LDAPMessage** res);</span>
<a href="#l6.307"></a><span id="l6.307"> LDAP_API(int)</span>
<a href="#l6.308"></a><span id="l6.308" class="difflineminus">-LDAP_CALL ldap_url_search_st(LDAP *ld, const char *url, int attrsonly,</span>
<a href="#l6.309"></a><span id="l6.309" class="difflineminus">-                             struct timeval *timeout, LDAPMessage **res);</span>
<a href="#l6.310"></a><span id="l6.310" class="difflineplus">+LDAP_CALL ldap_url_search_st(LDAP* ld, const char* url, int attrsonly,</span>
<a href="#l6.311"></a><span id="l6.311" class="difflineplus">+                             struct timeval* timeout, LDAPMessage** res);</span>
<a href="#l6.312"></a><span id="l6.312"> </span>
<a href="#l6.313"></a><span id="l6.313"> /*</span>
<a href="#l6.314"></a><span id="l6.314">  * Function to dispose of an array of LDAPMod structures (an API extension).</span>
<a href="#l6.315"></a><span id="l6.315">  * Warning: don't use this unless the mods array was allocated using the</span>
<a href="#l6.316"></a><span id="l6.316">  * same memory allocator as is being used by libldap.</span>
<a href="#l6.317"></a><span id="l6.317">  */</span>
<a href="#l6.318"></a><span id="l6.318" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_mods_free(LDAPMod **mods, int freemods);</span>
<a href="#l6.319"></a><span id="l6.319" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_mods_free(LDAPMod** mods, int freemods);</span>
<a href="#l6.320"></a><span id="l6.320"> </span>
<a href="#l6.321"></a><span id="l6.321"> /*</span>
<a href="#l6.322"></a><span id="l6.322">  * SSL option (an API extension):</span>
<a href="#l6.323"></a><span id="l6.323">  */</span>
<a href="#l6.324"></a><span id="l6.324"> #define LDAP_OPT_SSL 0x0A /* 10 - API extension */</span>
<a href="#l6.325"></a><span id="l6.325"> </span>
<a href="#l6.326"></a><span id="l6.326"> /*</span>
<a href="#l6.327"></a><span id="l6.327">  * Referral hop limit (an API extension):</span>
<a href="#l6.328"></a><span id="l6.328" class="difflineat">@@ -396,58 +396,58 @@ LDAP_API(void) LDAP_CALL ldap_mods_free(</span>
<a href="#l6.329"></a><span id="l6.329"> #define LDAP_OPT_REFERRAL_HOP_LIMIT 0x10 /* 16 - API extension */</span>
<a href="#l6.330"></a><span id="l6.330"> </span>
<a href="#l6.331"></a><span id="l6.331"> /*</span>
<a href="#l6.332"></a><span id="l6.332">  * Rebind callback function (an API extension)</span>
<a href="#l6.333"></a><span id="l6.333">  */</span>
<a href="#l6.334"></a><span id="l6.334"> #define LDAP_OPT_REBIND_FN 0x06  /* 6 - API extension */</span>
<a href="#l6.335"></a><span id="l6.335"> #define LDAP_OPT_REBIND_ARG 0x07 /* 7 - API extension */</span>
<a href="#l6.336"></a><span id="l6.336"> typedef int(LDAP_CALL LDAP_CALLBACK LDAP_REBINDPROC_CALLBACK)(</span>
<a href="#l6.337"></a><span id="l6.337" class="difflineminus">-    LDAP *ld, char **dnp, char **passwdp, int *authmethodp, int freeit,</span>
<a href="#l6.338"></a><span id="l6.338" class="difflineminus">-    void *arg);</span>
<a href="#l6.339"></a><span id="l6.339" class="difflineplus">+    LDAP* ld, char** dnp, char** passwdp, int* authmethodp, int freeit,</span>
<a href="#l6.340"></a><span id="l6.340" class="difflineplus">+    void* arg);</span>
<a href="#l6.341"></a><span id="l6.341"> LDAP_API(void)</span>
<a href="#l6.342"></a><span id="l6.342" class="difflineminus">-LDAP_CALL ldap_set_rebind_proc(LDAP *ld, LDAP_REBINDPROC_CALLBACK *rebindproc,</span>
<a href="#l6.343"></a><span id="l6.343" class="difflineminus">-                               void *arg);</span>
<a href="#l6.344"></a><span id="l6.344" class="difflineplus">+LDAP_CALL ldap_set_rebind_proc(LDAP* ld, LDAP_REBINDPROC_CALLBACK* rebindproc,</span>
<a href="#l6.345"></a><span id="l6.345" class="difflineplus">+                               void* arg);</span>
<a href="#l6.346"></a><span id="l6.346"> </span>
<a href="#l6.347"></a><span id="l6.347"> /*</span>
<a href="#l6.348"></a><span id="l6.348">  * Thread function callbacks (an API extension --</span>
<a href="#l6.349"></a><span id="l6.349">  * LDAP_API_FEATURE_X_THREAD_FUNCTIONS).</span>
<a href="#l6.350"></a><span id="l6.350">  */</span>
<a href="#l6.351"></a><span id="l6.351"> #define LDAP_OPT_THREAD_FN_PTRS 0x05 /* 5 - API extension */</span>
<a href="#l6.352"></a><span id="l6.352"> </span>
<a href="#l6.353"></a><span id="l6.353"> /*</span>
<a href="#l6.354"></a><span id="l6.354">  * Thread callback functions:</span>
<a href="#l6.355"></a><span id="l6.355">  */</span>
<a href="#l6.356"></a><span id="l6.356" class="difflineminus">-typedef void *(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_ALLOC_CALLBACK)(void);</span>
<a href="#l6.357"></a><span id="l6.357" class="difflineminus">-typedef void(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_FREE_CALLBACK)(void *m);</span>
<a href="#l6.358"></a><span id="l6.358" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_LOCK_CALLBACK)(void *m);</span>
<a href="#l6.359"></a><span id="l6.359" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_UNLOCK_CALLBACK)(void *m);</span>
<a href="#l6.360"></a><span id="l6.360" class="difflineplus">+typedef void*(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_ALLOC_CALLBACK)(void);</span>
<a href="#l6.361"></a><span id="l6.361" class="difflineplus">+typedef void(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_FREE_CALLBACK)(void* m);</span>
<a href="#l6.362"></a><span id="l6.362" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_LOCK_CALLBACK)(void* m);</span>
<a href="#l6.363"></a><span id="l6.363" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_UNLOCK_CALLBACK)(void* m);</span>
<a href="#l6.364"></a><span id="l6.364"> typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_GET_ERRNO_CALLBACK)(void);</span>
<a href="#l6.365"></a><span id="l6.365"> typedef void(LDAP_C LDAP_CALLBACK LDAP_TF_SET_ERRNO_CALLBACK)(int e);</span>
<a href="#l6.366"></a><span id="l6.366" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_GET_LDERRNO_CALLBACK)(char **matchedp,</span>
<a href="#l6.367"></a><span id="l6.367" class="difflineminus">-                                                               char **errmsgp,</span>
<a href="#l6.368"></a><span id="l6.368" class="difflineminus">-                                                               void *arg);</span>
<a href="#l6.369"></a><span id="l6.369" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_GET_LDERRNO_CALLBACK)(char** matchedp,</span>
<a href="#l6.370"></a><span id="l6.370" class="difflineplus">+                                                               char** errmsgp,</span>
<a href="#l6.371"></a><span id="l6.371" class="difflineplus">+                                                               void* arg);</span>
<a href="#l6.372"></a><span id="l6.372"> typedef void(LDAP_C LDAP_CALLBACK LDAP_TF_SET_LDERRNO_CALLBACK)(int err,</span>
<a href="#l6.373"></a><span id="l6.373" class="difflineminus">-                                                                char *matched,</span>
<a href="#l6.374"></a><span id="l6.374" class="difflineminus">-                                                                char *errmsg,</span>
<a href="#l6.375"></a><span id="l6.375" class="difflineminus">-                                                                void *arg);</span>
<a href="#l6.376"></a><span id="l6.376" class="difflineplus">+                                                                char* matched,</span>
<a href="#l6.377"></a><span id="l6.377" class="difflineplus">+                                                                char* errmsg,</span>
<a href="#l6.378"></a><span id="l6.378" class="difflineplus">+                                                                void* arg);</span>
<a href="#l6.379"></a><span id="l6.379"> </span>
<a href="#l6.380"></a><span id="l6.380"> /*</span>
<a href="#l6.381"></a><span id="l6.381">  * Structure to hold thread function pointers:</span>
<a href="#l6.382"></a><span id="l6.382">  */</span>
<a href="#l6.383"></a><span id="l6.383"> struct ldap_thread_fns {</span>
<a href="#l6.384"></a><span id="l6.384" class="difflineminus">-  LDAP_TF_MUTEX_ALLOC_CALLBACK *ltf_mutex_alloc;</span>
<a href="#l6.385"></a><span id="l6.385" class="difflineminus">-  LDAP_TF_MUTEX_FREE_CALLBACK *ltf_mutex_free;</span>
<a href="#l6.386"></a><span id="l6.386" class="difflineminus">-  LDAP_TF_MUTEX_LOCK_CALLBACK *ltf_mutex_lock;</span>
<a href="#l6.387"></a><span id="l6.387" class="difflineminus">-  LDAP_TF_MUTEX_UNLOCK_CALLBACK *ltf_mutex_unlock;</span>
<a href="#l6.388"></a><span id="l6.388" class="difflineminus">-  LDAP_TF_GET_ERRNO_CALLBACK *ltf_get_errno;</span>
<a href="#l6.389"></a><span id="l6.389" class="difflineminus">-  LDAP_TF_SET_ERRNO_CALLBACK *ltf_set_errno;</span>
<a href="#l6.390"></a><span id="l6.390" class="difflineminus">-  LDAP_TF_GET_LDERRNO_CALLBACK *ltf_get_lderrno;</span>
<a href="#l6.391"></a><span id="l6.391" class="difflineminus">-  LDAP_TF_SET_LDERRNO_CALLBACK *ltf_set_lderrno;</span>
<a href="#l6.392"></a><span id="l6.392" class="difflineminus">-  void *ltf_lderrno_arg;</span>
<a href="#l6.393"></a><span id="l6.393" class="difflineplus">+  LDAP_TF_MUTEX_ALLOC_CALLBACK* ltf_mutex_alloc;</span>
<a href="#l6.394"></a><span id="l6.394" class="difflineplus">+  LDAP_TF_MUTEX_FREE_CALLBACK* ltf_mutex_free;</span>
<a href="#l6.395"></a><span id="l6.395" class="difflineplus">+  LDAP_TF_MUTEX_LOCK_CALLBACK* ltf_mutex_lock;</span>
<a href="#l6.396"></a><span id="l6.396" class="difflineplus">+  LDAP_TF_MUTEX_UNLOCK_CALLBACK* ltf_mutex_unlock;</span>
<a href="#l6.397"></a><span id="l6.397" class="difflineplus">+  LDAP_TF_GET_ERRNO_CALLBACK* ltf_get_errno;</span>
<a href="#l6.398"></a><span id="l6.398" class="difflineplus">+  LDAP_TF_SET_ERRNO_CALLBACK* ltf_set_errno;</span>
<a href="#l6.399"></a><span id="l6.399" class="difflineplus">+  LDAP_TF_GET_LDERRNO_CALLBACK* ltf_get_lderrno;</span>
<a href="#l6.400"></a><span id="l6.400" class="difflineplus">+  LDAP_TF_SET_LDERRNO_CALLBACK* ltf_set_lderrno;</span>
<a href="#l6.401"></a><span id="l6.401" class="difflineplus">+  void* ltf_lderrno_arg;</span>
<a href="#l6.402"></a><span id="l6.402"> };</span>
<a href="#l6.403"></a><span id="l6.403"> </span>
<a href="#l6.404"></a><span id="l6.404"> /*</span>
<a href="#l6.405"></a><span id="l6.405">  * Extended I/O function callbacks option (an API extension --</span>
<a href="#l6.406"></a><span id="l6.406">  * LDAP_API_FEATURE_X_EXTIO_FUNCTIONS).</span>
<a href="#l6.407"></a><span id="l6.407">  */</span>
<a href="#l6.408"></a><span id="l6.408"> #define LDAP_X_OPT_EXTIO_FN_PTRS (LDAP_OPT_PRIVATE_EXTENSION_BASE + 0x0F00)</span>
<a href="#l6.409"></a><span id="l6.409"> /* 0x4000 + 0x0F00 = 0x4F00 = 20224 - API extension */</span>
<a href="#l6.410"></a><span id="l6.410" class="difflineat">@@ -502,17 +502,17 @@ struct ldap_thread_fns {</span>
<a href="#l6.411"></a><span id="l6.411">  */</span>
<a href="#l6.412"></a><span id="l6.412"> #define LDAP_X_IO_TIMEOUT_NO_WAIT 0       /* return immediately */</span>
<a href="#l6.413"></a><span id="l6.413"> #define LDAP_X_IO_TIMEOUT_NO_TIMEOUT (-1) /* block indefinitely */</span>
<a href="#l6.414"></a><span id="l6.414"> </span>
<a href="#l6.415"></a><span id="l6.415"> /* LDAP poll()-like descriptor:</span>
<a href="#l6.416"></a><span id="l6.416">  */</span>
<a href="#l6.417"></a><span id="l6.417"> typedef struct ldap_x_pollfd { /* used by LDAP_X_EXTIOF_POLL_CALLBACK */</span>
<a href="#l6.418"></a><span id="l6.418">   int lpoll_fd;                /* integer file descriptor / socket */</span>
<a href="#l6.419"></a><span id="l6.419" class="difflineminus">-  struct lextiof_socket_private *lpoll_socketarg;</span>
<a href="#l6.420"></a><span id="l6.420" class="difflineplus">+  struct lextiof_socket_private* lpoll_socketarg;</span>
<a href="#l6.421"></a><span id="l6.421">   /* pointer socket and for use by */</span>
<a href="#l6.422"></a><span id="l6.422">   /* application */</span>
<a href="#l6.423"></a><span id="l6.423">   short lpoll_events;  /* requested event */</span>
<a href="#l6.424"></a><span id="l6.424">   short lpoll_revents; /* returned event */</span>
<a href="#l6.425"></a><span id="l6.425"> } LDAP_X_PollFD;</span>
<a href="#l6.426"></a><span id="l6.426"> </span>
<a href="#l6.427"></a><span id="l6.427"> /* Event flags for lpoll_events and lpoll_revents:</span>
<a href="#l6.428"></a><span id="l6.428">  */</span>
<a href="#l6.429"></a><span id="l6.429" class="difflineat">@@ -526,167 +526,167 @@ typedef struct ldap_x_pollfd { /* used b</span>
<a href="#l6.430"></a><span id="l6.430"> /* Options passed to LDAP_X_EXTIOF_CONNECT_CALLBACK to modify socket behavior:</span>
<a href="#l6.431"></a><span id="l6.431">  */</span>
<a href="#l6.432"></a><span id="l6.432"> #define LDAP_X_EXTIOF_OPT_NONBLOCKING 0x01 /* turn on non-blocking mode */</span>
<a href="#l6.433"></a><span id="l6.433"> #define LDAP_X_EXTIOF_OPT_SECURE 0x02      /* turn on 'secure' mode */</span>
<a href="#l6.434"></a><span id="l6.434"> </span>
<a href="#l6.435"></a><span id="l6.435"> /* extended I/O callback function prototypes:</span>
<a href="#l6.436"></a><span id="l6.436">  */</span>
<a href="#l6.437"></a><span id="l6.437"> typedef int(LDAP_C LDAP_CALLBACK LDAP_X_EXTIOF_CONNECT_CALLBACK)(</span>
<a href="#l6.438"></a><span id="l6.438" class="difflineminus">-    const char *hostlist, int port, /* host byte order */</span>
<a href="#l6.439"></a><span id="l6.439" class="difflineplus">+    const char* hostlist, int port, /* host byte order */</span>
<a href="#l6.440"></a><span id="l6.440">     int timeout /* milliseconds */,</span>
<a href="#l6.441"></a><span id="l6.441">     unsigned long options, /* bitmapped options */</span>
<a href="#l6.442"></a><span id="l6.442" class="difflineminus">-    struct lextiof_session_private *sessionarg,</span>
<a href="#l6.443"></a><span id="l6.443" class="difflineminus">-    struct lextiof_socket_private **socketargp);</span>
<a href="#l6.444"></a><span id="l6.444" class="difflineplus">+    struct lextiof_session_private* sessionarg,</span>
<a href="#l6.445"></a><span id="l6.445" class="difflineplus">+    struct lextiof_socket_private** socketargp);</span>
<a href="#l6.446"></a><span id="l6.446"> typedef int(LDAP_C LDAP_CALLBACK LDAP_X_EXTIOF_CLOSE_CALLBACK)(</span>
<a href="#l6.447"></a><span id="l6.447" class="difflineminus">-    int s, struct lextiof_socket_private *socketarg);</span>
<a href="#l6.448"></a><span id="l6.448" class="difflineplus">+    int s, struct lextiof_socket_private* socketarg);</span>
<a href="#l6.449"></a><span id="l6.449"> typedef int(LDAP_C LDAP_CALLBACK LDAP_X_EXTIOF_POLL_CALLBACK)(</span>
<a href="#l6.450"></a><span id="l6.450">     LDAP_X_PollFD fds[], int nfds, int timeout /* milliseconds */,</span>
<a href="#l6.451"></a><span id="l6.451" class="difflineminus">-    struct lextiof_session_private *sessionarg);</span>
<a href="#l6.452"></a><span id="l6.452" class="difflineplus">+    struct lextiof_session_private* sessionarg);</span>
<a href="#l6.453"></a><span id="l6.453"> typedef int(LDAP_C LDAP_CALLBACK LDAP_X_EXTIOF_NEWHANDLE_CALLBACK)(</span>
<a href="#l6.454"></a><span id="l6.454" class="difflineminus">-    LDAP *ld, struct lextiof_session_private *sessionarg);</span>
<a href="#l6.455"></a><span id="l6.455" class="difflineplus">+    LDAP* ld, struct lextiof_session_private* sessionarg);</span>
<a href="#l6.456"></a><span id="l6.456"> typedef void(LDAP_C LDAP_CALLBACK LDAP_X_EXTIOF_DISPOSEHANDLE_CALLBACK)(</span>
<a href="#l6.457"></a><span id="l6.457" class="difflineminus">-    LDAP *ld, struct lextiof_session_private *sessionarg);</span>
<a href="#l6.458"></a><span id="l6.458" class="difflineplus">+    LDAP* ld, struct lextiof_session_private* sessionarg);</span>
<a href="#l6.459"></a><span id="l6.459"> </span>
<a href="#l6.460"></a><span id="l6.460"> /* Structure to hold extended I/O function pointers:</span>
<a href="#l6.461"></a><span id="l6.461">  */</span>
<a href="#l6.462"></a><span id="l6.462"> struct ldap_x_ext_io_fns {</span>
<a href="#l6.463"></a><span id="l6.463">   /* lextiof_size should always be set to LDAP_X_EXTIO_FNS_SIZE */</span>
<a href="#l6.464"></a><span id="l6.464">   int lextiof_size;</span>
<a href="#l6.465"></a><span id="l6.465" class="difflineminus">-  LDAP_X_EXTIOF_CONNECT_CALLBACK *lextiof_connect;</span>
<a href="#l6.466"></a><span id="l6.466" class="difflineminus">-  LDAP_X_EXTIOF_CLOSE_CALLBACK *lextiof_close;</span>
<a href="#l6.467"></a><span id="l6.467" class="difflineminus">-  LDAP_X_EXTIOF_READ_CALLBACK *lextiof_read;</span>
<a href="#l6.468"></a><span id="l6.468" class="difflineminus">-  LDAP_X_EXTIOF_WRITE_CALLBACK *lextiof_write;</span>
<a href="#l6.469"></a><span id="l6.469" class="difflineminus">-  LDAP_X_EXTIOF_POLL_CALLBACK *lextiof_poll;</span>
<a href="#l6.470"></a><span id="l6.470" class="difflineminus">-  LDAP_X_EXTIOF_NEWHANDLE_CALLBACK *lextiof_newhandle;</span>
<a href="#l6.471"></a><span id="l6.471" class="difflineminus">-  LDAP_X_EXTIOF_DISPOSEHANDLE_CALLBACK *lextiof_disposehandle;</span>
<a href="#l6.472"></a><span id="l6.472" class="difflineminus">-  void *lextiof_session_arg;</span>
<a href="#l6.473"></a><span id="l6.473" class="difflineminus">-  LDAP_X_EXTIOF_WRITEV_CALLBACK *lextiof_writev;</span>
<a href="#l6.474"></a><span id="l6.474" class="difflineplus">+  LDAP_X_EXTIOF_CONNECT_CALLBACK* lextiof_connect;</span>
<a href="#l6.475"></a><span id="l6.475" class="difflineplus">+  LDAP_X_EXTIOF_CLOSE_CALLBACK* lextiof_close;</span>
<a href="#l6.476"></a><span id="l6.476" class="difflineplus">+  LDAP_X_EXTIOF_READ_CALLBACK* lextiof_read;</span>
<a href="#l6.477"></a><span id="l6.477" class="difflineplus">+  LDAP_X_EXTIOF_WRITE_CALLBACK* lextiof_write;</span>
<a href="#l6.478"></a><span id="l6.478" class="difflineplus">+  LDAP_X_EXTIOF_POLL_CALLBACK* lextiof_poll;</span>
<a href="#l6.479"></a><span id="l6.479" class="difflineplus">+  LDAP_X_EXTIOF_NEWHANDLE_CALLBACK* lextiof_newhandle;</span>
<a href="#l6.480"></a><span id="l6.480" class="difflineplus">+  LDAP_X_EXTIOF_DISPOSEHANDLE_CALLBACK* lextiof_disposehandle;</span>
<a href="#l6.481"></a><span id="l6.481" class="difflineplus">+  void* lextiof_session_arg;</span>
<a href="#l6.482"></a><span id="l6.482" class="difflineplus">+  LDAP_X_EXTIOF_WRITEV_CALLBACK* lextiof_writev;</span>
<a href="#l6.483"></a><span id="l6.483"> };</span>
<a href="#l6.484"></a><span id="l6.484"> #define LDAP_X_EXTIO_FNS_SIZE sizeof(struct ldap_x_ext_io_fns)</span>
<a href="#l6.485"></a><span id="l6.485"> </span>
<a href="#l6.486"></a><span id="l6.486"> /*</span>
<a href="#l6.487"></a><span id="l6.487">  * Utility functions for parsing space-separated host lists (useful for</span>
<a href="#l6.488"></a><span id="l6.488">  * implementing an extended I/O CONNECT callback function).</span>
<a href="#l6.489"></a><span id="l6.489">  */</span>
<a href="#l6.490"></a><span id="l6.490"> struct ldap_x_hostlist_status;</span>
<a href="#l6.491"></a><span id="l6.491"> LDAP_API(int)</span>
<a href="#l6.492"></a><span id="l6.492" class="difflineminus">-LDAP_CALL ldap_x_hostlist_first(const char *hostlist, int defport, char **hostp,</span>
<a href="#l6.493"></a><span id="l6.493" class="difflineminus">-                                int *portp /* host byte order */,</span>
<a href="#l6.494"></a><span id="l6.494" class="difflineminus">-                                struct ldap_x_hostlist_status **statusp);</span>
<a href="#l6.495"></a><span id="l6.495" class="difflineplus">+LDAP_CALL ldap_x_hostlist_first(const char* hostlist, int defport, char** hostp,</span>
<a href="#l6.496"></a><span id="l6.496" class="difflineplus">+                                int* portp /* host byte order */,</span>
<a href="#l6.497"></a><span id="l6.497" class="difflineplus">+                                struct ldap_x_hostlist_status** statusp);</span>
<a href="#l6.498"></a><span id="l6.498"> LDAP_API(int)</span>
<a href="#l6.499"></a><span id="l6.499" class="difflineminus">-LDAP_CALL ldap_x_hostlist_next(char **hostp, int *portp /* host byte order */,</span>
<a href="#l6.500"></a><span id="l6.500" class="difflineminus">-                               struct ldap_x_hostlist_status *status);</span>
<a href="#l6.501"></a><span id="l6.501" class="difflineplus">+LDAP_CALL ldap_x_hostlist_next(char** hostp, int* portp /* host byte order */,</span>
<a href="#l6.502"></a><span id="l6.502" class="difflineplus">+                               struct ldap_x_hostlist_status* status);</span>
<a href="#l6.503"></a><span id="l6.503"> LDAP_API(void)</span>
<a href="#l6.504"></a><span id="l6.504" class="difflineminus">-LDAP_CALL ldap_x_hostlist_statusfree(struct ldap_x_hostlist_status *status);</span>
<a href="#l6.505"></a><span id="l6.505" class="difflineplus">+LDAP_CALL ldap_x_hostlist_statusfree(struct ldap_x_hostlist_status* status);</span>
<a href="#l6.506"></a><span id="l6.506"> </span>
<a href="#l6.507"></a><span id="l6.507"> /*</span>
<a href="#l6.508"></a><span id="l6.508">  * Client side sorting of entries (an API extension --</span>
<a href="#l6.509"></a><span id="l6.509">  * LDAP_API_FEATURE_X_CLIENT_SIDE_SORT)</span>
<a href="#l6.510"></a><span id="l6.510">  */</span>
<a href="#l6.511"></a><span id="l6.511"> /*</span>
<a href="#l6.512"></a><span id="l6.512">  * Client side sorting callback functions:</span>
<a href="#l6.513"></a><span id="l6.513">  */</span>
<a href="#l6.514"></a><span id="l6.514" class="difflineminus">-typedef const struct berval *(LDAP_C LDAP_CALLBACK LDAP_KEYGEN_CALLBACK)(</span>
<a href="#l6.515"></a><span id="l6.515" class="difflineminus">-    void *arg, LDAP *ld, LDAPMessage *entry);</span>
<a href="#l6.516"></a><span id="l6.516" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_KEYCMP_CALLBACK)(void *arg,</span>
<a href="#l6.517"></a><span id="l6.517" class="difflineminus">-                                                       const struct berval *,</span>
<a href="#l6.518"></a><span id="l6.518" class="difflineminus">-                                                       const struct berval *);</span>
<a href="#l6.519"></a><span id="l6.519" class="difflineminus">-typedef void(LDAP_C LDAP_CALLBACK LDAP_KEYFREE_CALLBACK)(void *arg,</span>
<a href="#l6.520"></a><span id="l6.520" class="difflineminus">-                                                         const struct berval *);</span>
<a href="#l6.521"></a><span id="l6.521" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_CMP_CALLBACK)(const char *val1,</span>
<a href="#l6.522"></a><span id="l6.522" class="difflineminus">-                                                    const char *val2);</span>
<a href="#l6.523"></a><span id="l6.523" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_VALCMP_CALLBACK)(const char **val1p,</span>
<a href="#l6.524"></a><span id="l6.524" class="difflineminus">-                                                       const char **val2p);</span>
<a href="#l6.525"></a><span id="l6.525" class="difflineplus">+typedef const struct berval*(LDAP_C LDAP_CALLBACK LDAP_KEYGEN_CALLBACK)(</span>
<a href="#l6.526"></a><span id="l6.526" class="difflineplus">+    void* arg, LDAP* ld, LDAPMessage* entry);</span>
<a href="#l6.527"></a><span id="l6.527" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_KEYCMP_CALLBACK)(void* arg,</span>
<a href="#l6.528"></a><span id="l6.528" class="difflineplus">+                                                       const struct berval*,</span>
<a href="#l6.529"></a><span id="l6.529" class="difflineplus">+                                                       const struct berval*);</span>
<a href="#l6.530"></a><span id="l6.530" class="difflineplus">+typedef void(LDAP_C LDAP_CALLBACK LDAP_KEYFREE_CALLBACK)(void* arg,</span>
<a href="#l6.531"></a><span id="l6.531" class="difflineplus">+                                                         const struct berval*);</span>
<a href="#l6.532"></a><span id="l6.532" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_CMP_CALLBACK)(const char* val1,</span>
<a href="#l6.533"></a><span id="l6.533" class="difflineplus">+                                                    const char* val2);</span>
<a href="#l6.534"></a><span id="l6.534" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_VALCMP_CALLBACK)(const char** val1p,</span>
<a href="#l6.535"></a><span id="l6.535" class="difflineplus">+                                                       const char** val2p);</span>
<a href="#l6.536"></a><span id="l6.536"> </span>
<a href="#l6.537"></a><span id="l6.537"> /*</span>
<a href="#l6.538"></a><span id="l6.538">  * Client side sorting functions:</span>
<a href="#l6.539"></a><span id="l6.539">  */</span>
<a href="#l6.540"></a><span id="l6.540"> LDAP_API(int)</span>
<a href="#l6.541"></a><span id="l6.541"> LDAP_CALL</span>
<a href="#l6.542"></a><span id="l6.542" class="difflineminus">-ldap_keysort_entries(LDAP *ld, LDAPMessage **chain, void *arg,</span>
<a href="#l6.543"></a><span id="l6.543" class="difflineminus">-                     LDAP_KEYGEN_CALLBACK *gen, LDAP_KEYCMP_CALLBACK *cmp,</span>
<a href="#l6.544"></a><span id="l6.544" class="difflineminus">-                     LDAP_KEYFREE_CALLBACK *fre);</span>
<a href="#l6.545"></a><span id="l6.545" class="difflineplus">+ldap_keysort_entries(LDAP* ld, LDAPMessage** chain, void* arg,</span>
<a href="#l6.546"></a><span id="l6.546" class="difflineplus">+                     LDAP_KEYGEN_CALLBACK* gen, LDAP_KEYCMP_CALLBACK* cmp,</span>
<a href="#l6.547"></a><span id="l6.547" class="difflineplus">+                     LDAP_KEYFREE_CALLBACK* fre);</span>
<a href="#l6.548"></a><span id="l6.548"> LDAP_API(int)</span>
<a href="#l6.549"></a><span id="l6.549" class="difflineminus">-LDAP_CALL ldap_multisort_entries(LDAP *ld, LDAPMessage **chain, char **attr,</span>
<a href="#l6.550"></a><span id="l6.550" class="difflineminus">-                                 LDAP_CMP_CALLBACK *cmp);</span>
<a href="#l6.551"></a><span id="l6.551" class="difflineplus">+LDAP_CALL ldap_multisort_entries(LDAP* ld, LDAPMessage** chain, char** attr,</span>
<a href="#l6.552"></a><span id="l6.552" class="difflineplus">+                                 LDAP_CMP_CALLBACK* cmp);</span>
<a href="#l6.553"></a><span id="l6.553"> LDAP_API(int)</span>
<a href="#l6.554"></a><span id="l6.554" class="difflineminus">-LDAP_CALL ldap_sort_entries(LDAP *ld, LDAPMessage **chain, char *attr,</span>
<a href="#l6.555"></a><span id="l6.555" class="difflineminus">-                            LDAP_CMP_CALLBACK *cmp);</span>
<a href="#l6.556"></a><span id="l6.556" class="difflineplus">+LDAP_CALL ldap_sort_entries(LDAP* ld, LDAPMessage** chain, char* attr,</span>
<a href="#l6.557"></a><span id="l6.557" class="difflineplus">+                            LDAP_CMP_CALLBACK* cmp);</span>
<a href="#l6.558"></a><span id="l6.558"> LDAP_API(int)</span>
<a href="#l6.559"></a><span id="l6.559" class="difflineminus">-LDAP_CALL ldap_sort_values(LDAP *ld, char **vals, LDAP_VALCMP_CALLBACK *cmp);</span>
<a href="#l6.560"></a><span id="l6.560" class="difflineplus">+LDAP_CALL ldap_sort_values(LDAP* ld, char** vals, LDAP_VALCMP_CALLBACK* cmp);</span>
<a href="#l6.561"></a><span id="l6.561"> LDAP_API(int)</span>
<a href="#l6.562"></a><span id="l6.562" class="difflineminus">-LDAP_C LDAP_CALLBACK ldap_sort_strcasecmp(const char **a, const char **b);</span>
<a href="#l6.563"></a><span id="l6.563" class="difflineplus">+LDAP_C LDAP_CALLBACK ldap_sort_strcasecmp(const char** a, const char** b);</span>
<a href="#l6.564"></a><span id="l6.564"> </span>
<a href="#l6.565"></a><span id="l6.565"> /*</span>
<a href="#l6.566"></a><span id="l6.566">  * Filter functions and definitions (an API extension --</span>
<a href="#l6.567"></a><span id="l6.567">  * LDAP_API_FEATURE_X_FILTER_FUNCTIONS)</span>
<a href="#l6.568"></a><span id="l6.568">  */</span>
<a href="#l6.569"></a><span id="l6.569"> /*</span>
<a href="#l6.570"></a><span id="l6.570">  * Structures, constants, and types for filter utility routines:</span>
<a href="#l6.571"></a><span id="l6.571">  */</span>
<a href="#l6.572"></a><span id="l6.572"> typedef struct ldap_filt_info {</span>
<a href="#l6.573"></a><span id="l6.573" class="difflineminus">-  char *lfi_filter;</span>
<a href="#l6.574"></a><span id="l6.574" class="difflineminus">-  char *lfi_desc;</span>
<a href="#l6.575"></a><span id="l6.575" class="difflineplus">+  char* lfi_filter;</span>
<a href="#l6.576"></a><span id="l6.576" class="difflineplus">+  char* lfi_desc;</span>
<a href="#l6.577"></a><span id="l6.577">   int lfi_scope;   /* LDAP_SCOPE_BASE, etc */</span>
<a href="#l6.578"></a><span id="l6.578">   int lfi_isexact; /* exact match filter? */</span>
<a href="#l6.579"></a><span id="l6.579" class="difflineminus">-  struct ldap_filt_info *lfi_next;</span>
<a href="#l6.580"></a><span id="l6.580" class="difflineplus">+  struct ldap_filt_info* lfi_next;</span>
<a href="#l6.581"></a><span id="l6.581"> } LDAPFiltInfo;</span>
<a href="#l6.582"></a><span id="l6.582"> </span>
<a href="#l6.583"></a><span id="l6.583"> #define LDAP_FILT_MAXSIZ 1024</span>
<a href="#l6.584"></a><span id="l6.584"> </span>
<a href="#l6.585"></a><span id="l6.585"> typedef struct ldap_filt_list LDAPFiltList; /* opaque filter list handle */</span>
<a href="#l6.586"></a><span id="l6.586"> typedef struct ldap_filt_desc LDAPFiltDesc; /* opaque filter desc handle */</span>
<a href="#l6.587"></a><span id="l6.587"> </span>
<a href="#l6.588"></a><span id="l6.588"> /*</span>
<a href="#l6.589"></a><span id="l6.589">  * Filter utility functions:</span>
<a href="#l6.590"></a><span id="l6.590">  */</span>
<a href="#l6.591"></a><span id="l6.591" class="difflineminus">-LDAP_API(LDAPFiltDesc *) LDAP_CALL ldap_init_getfilter(char *fname);</span>
<a href="#l6.592"></a><span id="l6.592" class="difflineminus">-LDAP_API(LDAPFiltDesc *)</span>
<a href="#l6.593"></a><span id="l6.593" class="difflineminus">-LDAP_CALL ldap_init_getfilter_buf(char *buf, long buflen);</span>
<a href="#l6.594"></a><span id="l6.594" class="difflineminus">-LDAP_API(LDAPFiltInfo *)</span>
<a href="#l6.595"></a><span id="l6.595" class="difflineminus">-LDAP_CALL ldap_getfirstfilter(LDAPFiltDesc *lfdp, char *tagpat, char *value);</span>
<a href="#l6.596"></a><span id="l6.596" class="difflineminus">-LDAP_API(LDAPFiltInfo *) LDAP_CALL ldap_getnextfilter(LDAPFiltDesc *lfdp);</span>
<a href="#l6.597"></a><span id="l6.597" class="difflineplus">+LDAP_API(LDAPFiltDesc*) LDAP_CALL ldap_init_getfilter(char* fname);</span>
<a href="#l6.598"></a><span id="l6.598" class="difflineplus">+LDAP_API(LDAPFiltDesc*)</span>
<a href="#l6.599"></a><span id="l6.599" class="difflineplus">+LDAP_CALL ldap_init_getfilter_buf(char* buf, long buflen);</span>
<a href="#l6.600"></a><span id="l6.600" class="difflineplus">+LDAP_API(LDAPFiltInfo*)</span>
<a href="#l6.601"></a><span id="l6.601" class="difflineplus">+LDAP_CALL ldap_getfirstfilter(LDAPFiltDesc* lfdp, char* tagpat, char* value);</span>
<a href="#l6.602"></a><span id="l6.602" class="difflineplus">+LDAP_API(LDAPFiltInfo*) LDAP_CALL ldap_getnextfilter(LDAPFiltDesc* lfdp);</span>
<a href="#l6.603"></a><span id="l6.603"> LDAP_API(int)</span>
<a href="#l6.604"></a><span id="l6.604"> LDAP_CALL</span>
<a href="#l6.605"></a><span id="l6.605" class="difflineminus">-ldap_set_filter_additions(LDAPFiltDesc *lfdp, char *prefix, char *suffix);</span>
<a href="#l6.606"></a><span id="l6.606" class="difflineplus">+ldap_set_filter_additions(LDAPFiltDesc* lfdp, char* prefix, char* suffix);</span>
<a href="#l6.607"></a><span id="l6.607"> LDAP_API(int)</span>
<a href="#l6.608"></a><span id="l6.608" class="difflineminus">-LDAP_CALL ldap_create_filter(char *buf, unsigned long buflen, char *pattern,</span>
<a href="#l6.609"></a><span id="l6.609" class="difflineminus">-                             char *prefix, char *suffix, char *attr,</span>
<a href="#l6.610"></a><span id="l6.610" class="difflineminus">-                             char *value, char **valwords);</span>
<a href="#l6.611"></a><span id="l6.611" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_getfilter_free(LDAPFiltDesc *lfdp);</span>
<a href="#l6.612"></a><span id="l6.612" class="difflineplus">+LDAP_CALL ldap_create_filter(char* buf, unsigned long buflen, char* pattern,</span>
<a href="#l6.613"></a><span id="l6.613" class="difflineplus">+                             char* prefix, char* suffix, char* attr,</span>
<a href="#l6.614"></a><span id="l6.614" class="difflineplus">+                             char* value, char** valwords);</span>
<a href="#l6.615"></a><span id="l6.615" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_getfilter_free(LDAPFiltDesc* lfdp);</span>
<a href="#l6.616"></a><span id="l6.616"> </span>
<a href="#l6.617"></a><span id="l6.617"> /*</span>
<a href="#l6.618"></a><span id="l6.618">  * Friendly mapping structure and routines (an API extension)</span>
<a href="#l6.619"></a><span id="l6.619">  */</span>
<a href="#l6.620"></a><span id="l6.620"> typedef struct friendly {</span>
<a href="#l6.621"></a><span id="l6.621" class="difflineminus">-  char *f_unfriendly;</span>
<a href="#l6.622"></a><span id="l6.622" class="difflineminus">-  char *f_friendly;</span>
<a href="#l6.623"></a><span id="l6.623" class="difflineplus">+  char* f_unfriendly;</span>
<a href="#l6.624"></a><span id="l6.624" class="difflineplus">+  char* f_friendly;</span>
<a href="#l6.625"></a><span id="l6.625"> } * FriendlyMap;</span>
<a href="#l6.626"></a><span id="l6.626" class="difflineminus">-LDAP_API(char *)</span>
<a href="#l6.627"></a><span id="l6.627" class="difflineminus">-LDAP_CALL ldap_friendly_name(char *filename, char *name, FriendlyMap *map);</span>
<a href="#l6.628"></a><span id="l6.628" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_free_friendlymap(FriendlyMap *map);</span>
<a href="#l6.629"></a><span id="l6.629" class="difflineplus">+LDAP_API(char*)</span>
<a href="#l6.630"></a><span id="l6.630" class="difflineplus">+LDAP_CALL ldap_friendly_name(char* filename, char* name, FriendlyMap* map);</span>
<a href="#l6.631"></a><span id="l6.631" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_free_friendlymap(FriendlyMap* map);</span>
<a href="#l6.632"></a><span id="l6.632"> </span>
<a href="#l6.633"></a><span id="l6.633"> /*</span>
<a href="#l6.634"></a><span id="l6.634">  * In Memory Cache (an API extension -- LDAP_API_FEATURE_X_MEMCACHE)</span>
<a href="#l6.635"></a><span id="l6.635">  */</span>
<a href="#l6.636"></a><span id="l6.636"> typedef struct ldapmemcache LDAPMemCache; /* opaque in-memory cache handle */</span>
<a href="#l6.637"></a><span id="l6.637"> </span>
<a href="#l6.638"></a><span id="l6.638"> LDAP_API(int)</span>
<a href="#l6.639"></a><span id="l6.639"> LDAP_CALL ldap_memcache_init(unsigned long ttl, unsigned long size,</span>
<a href="#l6.640"></a><span id="l6.640" class="difflineminus">-                             char **baseDNs, struct ldap_thread_fns *thread_fns,</span>
<a href="#l6.641"></a><span id="l6.641" class="difflineminus">-                             LDAPMemCache **cachep);</span>
<a href="#l6.642"></a><span id="l6.642" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_memcache_set(LDAP *ld, LDAPMemCache *cache);</span>
<a href="#l6.643"></a><span id="l6.643" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_memcache_get(LDAP *ld, LDAPMemCache **cachep);</span>
<a href="#l6.644"></a><span id="l6.644" class="difflineplus">+                             char** baseDNs, struct ldap_thread_fns* thread_fns,</span>
<a href="#l6.645"></a><span id="l6.645" class="difflineplus">+                             LDAPMemCache** cachep);</span>
<a href="#l6.646"></a><span id="l6.646" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_memcache_set(LDAP* ld, LDAPMemCache* cache);</span>
<a href="#l6.647"></a><span id="l6.647" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_memcache_get(LDAP* ld, LDAPMemCache** cachep);</span>
<a href="#l6.648"></a><span id="l6.648"> LDAP_API(void)</span>
<a href="#l6.649"></a><span id="l6.649" class="difflineminus">-LDAP_CALL ldap_memcache_flush(LDAPMemCache *cache, char *dn, int scope);</span>
<a href="#l6.650"></a><span id="l6.650" class="difflineplus">+LDAP_CALL ldap_memcache_flush(LDAPMemCache* cache, char* dn, int scope);</span>
<a href="#l6.651"></a><span id="l6.651"> LDAP_API(void)</span>
<a href="#l6.652"></a><span id="l6.652" class="difflineminus">-LDAP_CALL ldap_memcache_flush_results(LDAPMemCache *cache, char *dn, int scope);</span>
<a href="#l6.653"></a><span id="l6.653" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_memcache_destroy(LDAPMemCache *cache);</span>
<a href="#l6.654"></a><span id="l6.654" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_memcache_update(LDAPMemCache *cache);</span>
<a href="#l6.655"></a><span id="l6.655" class="difflineplus">+LDAP_CALL ldap_memcache_flush_results(LDAPMemCache* cache, char* dn, int scope);</span>
<a href="#l6.656"></a><span id="l6.656" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_memcache_destroy(LDAPMemCache* cache);</span>
<a href="#l6.657"></a><span id="l6.657" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_memcache_update(LDAPMemCache* cache);</span>
<a href="#l6.658"></a><span id="l6.658"> </span>
<a href="#l6.659"></a><span id="l6.659"> /*</span>
<a href="#l6.660"></a><span id="l6.660">  * Timeout value for nonblocking connect call</span>
<a href="#l6.661"></a><span id="l6.661">  */</span>
<a href="#l6.662"></a><span id="l6.662"> #define LDAP_X_OPT_CONNECT_TIMEOUT (LDAP_OPT_PRIVATE_EXTENSION_BASE + 0x0F01)</span>
<a href="#l6.663"></a><span id="l6.663"> /* 0x4000 + 0x0F01 = 0x4F01 = 20225 - API extension */</span>
<a href="#l6.664"></a><span id="l6.664"> </span>
<a href="#l6.665"></a><span id="l6.665"> /*</span>
<a href="#l6.666"></a><span id="l6.666" class="difflineat">@@ -702,29 +702,29 @@ LDAP_API(void) LDAP_CALL ldap_memcache_u</span>
<a href="#l6.667"></a><span id="l6.667">  * functions by making a call like this:</span>
<a href="#l6.668"></a><span id="l6.668">  *    ldap_set_option( NULL, LDAP_OPT_MEMALLOC_FN_PTRS, &amp;memalloc_fns );</span>
<a href="#l6.669"></a><span id="l6.669">  *</span>
<a href="#l6.670"></a><span id="l6.670">  * look in lber.h for the function typedefs themselves.</span>
<a href="#l6.671"></a><span id="l6.671">  */</span>
<a href="#l6.672"></a><span id="l6.672"> #define LDAP_OPT_MEMALLOC_FN_PTRS 0x61 /* 97 - API extension */</span>
<a href="#l6.673"></a><span id="l6.673"> </span>
<a href="#l6.674"></a><span id="l6.674"> struct ldap_memalloc_fns {</span>
<a href="#l6.675"></a><span id="l6.675" class="difflineminus">-  LDAP_MALLOC_CALLBACK *ldapmem_malloc;</span>
<a href="#l6.676"></a><span id="l6.676" class="difflineminus">-  LDAP_CALLOC_CALLBACK *ldapmem_calloc;</span>
<a href="#l6.677"></a><span id="l6.677" class="difflineminus">-  LDAP_REALLOC_CALLBACK *ldapmem_realloc;</span>
<a href="#l6.678"></a><span id="l6.678" class="difflineminus">-  LDAP_FREE_CALLBACK *ldapmem_free;</span>
<a href="#l6.679"></a><span id="l6.679" class="difflineplus">+  LDAP_MALLOC_CALLBACK* ldapmem_malloc;</span>
<a href="#l6.680"></a><span id="l6.680" class="difflineplus">+  LDAP_CALLOC_CALLBACK* ldapmem_calloc;</span>
<a href="#l6.681"></a><span id="l6.681" class="difflineplus">+  LDAP_REALLOC_CALLBACK* ldapmem_realloc;</span>
<a href="#l6.682"></a><span id="l6.682" class="difflineplus">+  LDAP_FREE_CALLBACK* ldapmem_free;</span>
<a href="#l6.683"></a><span id="l6.683"> };</span>
<a href="#l6.684"></a><span id="l6.684"> </span>
<a href="#l6.685"></a><span id="l6.685"> /*</span>
<a href="#l6.686"></a><span id="l6.686">  * Memory allocation functions (an API extension)</span>
<a href="#l6.687"></a><span id="l6.687">  */</span>
<a href="#l6.688"></a><span id="l6.688" class="difflineminus">-void *ldap_x_malloc(size_t size);</span>
<a href="#l6.689"></a><span id="l6.689" class="difflineminus">-void *ldap_x_calloc(size_t nelem, size_t elsize);</span>
<a href="#l6.690"></a><span id="l6.690" class="difflineminus">-void *ldap_x_realloc(void *ptr, size_t size);</span>
<a href="#l6.691"></a><span id="l6.691" class="difflineminus">-void ldap_x_free(void *ptr);</span>
<a href="#l6.692"></a><span id="l6.692" class="difflineplus">+void* ldap_x_malloc(size_t size);</span>
<a href="#l6.693"></a><span id="l6.693" class="difflineplus">+void* ldap_x_calloc(size_t nelem, size_t elsize);</span>
<a href="#l6.694"></a><span id="l6.694" class="difflineplus">+void* ldap_x_realloc(void* ptr, size_t size);</span>
<a href="#l6.695"></a><span id="l6.695" class="difflineplus">+void ldap_x_free(void* ptr);</span>
<a href="#l6.696"></a><span id="l6.696"> </span>
<a href="#l6.697"></a><span id="l6.697"> /*</span>
<a href="#l6.698"></a><span id="l6.698">  * Server reconnect (an API extension).</span>
<a href="#l6.699"></a><span id="l6.699">  */</span>
<a href="#l6.700"></a><span id="l6.700"> #define LDAP_OPT_RECONNECT 0x62 /* 98 - API extension */</span>
<a href="#l6.701"></a><span id="l6.701"> </span>
<a href="#l6.702"></a><span id="l6.702"> /*</span>
<a href="#l6.703"></a><span id="l6.703">  * Extra thread callback functions (an API extension --</span>
<a href="#l6.704"></a><span id="l6.704" class="difflineat">@@ -732,93 +732,93 @@ void ldap_x_free(void *ptr);</span>
<a href="#l6.705"></a><span id="l6.705">  */</span>
<a href="#l6.706"></a><span id="l6.706"> #define LDAP_OPT_EXTRA_THREAD_FN_PTRS 0x65 /* 101 - API extension */</span>
<a href="#l6.707"></a><span id="l6.707"> </span>
<a href="#l6.708"></a><span id="l6.708"> /*</span>
<a href="#l6.709"></a><span id="l6.709">  * When bind is called, don't bind if there's a connection open with the same DN</span>
<a href="#l6.710"></a><span id="l6.710">  */</span>
<a href="#l6.711"></a><span id="l6.711"> #define LDAP_OPT_NOREBIND 0x66 /* 102 - API extension */</span>
<a href="#l6.712"></a><span id="l6.712"> </span>
<a href="#l6.713"></a><span id="l6.713" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_TRYLOCK_CALLBACK)(void *m);</span>
<a href="#l6.714"></a><span id="l6.714" class="difflineminus">-typedef void *(LDAP_C LDAP_CALLBACK LDAP_TF_SEMA_ALLOC_CALLBACK)(void);</span>
<a href="#l6.715"></a><span id="l6.715" class="difflineminus">-typedef void(LDAP_C LDAP_CALLBACK LDAP_TF_SEMA_FREE_CALLBACK)(void *s);</span>
<a href="#l6.716"></a><span id="l6.716" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_SEMA_WAIT_CALLBACK)(void *s);</span>
<a href="#l6.717"></a><span id="l6.717" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_SEMA_POST_CALLBACK)(void *s);</span>
<a href="#l6.718"></a><span id="l6.718" class="difflineminus">-typedef void *(LDAP_C LDAP_CALLBACK LDAP_TF_THREADID_CALLBACK)(void);</span>
<a href="#l6.719"></a><span id="l6.719" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_MUTEX_TRYLOCK_CALLBACK)(void* m);</span>
<a href="#l6.720"></a><span id="l6.720" class="difflineplus">+typedef void*(LDAP_C LDAP_CALLBACK LDAP_TF_SEMA_ALLOC_CALLBACK)(void);</span>
<a href="#l6.721"></a><span id="l6.721" class="difflineplus">+typedef void(LDAP_C LDAP_CALLBACK LDAP_TF_SEMA_FREE_CALLBACK)(void* s);</span>
<a href="#l6.722"></a><span id="l6.722" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_SEMA_WAIT_CALLBACK)(void* s);</span>
<a href="#l6.723"></a><span id="l6.723" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_TF_SEMA_POST_CALLBACK)(void* s);</span>
<a href="#l6.724"></a><span id="l6.724" class="difflineplus">+typedef void*(LDAP_C LDAP_CALLBACK LDAP_TF_THREADID_CALLBACK)(void);</span>
<a href="#l6.725"></a><span id="l6.725"> </span>
<a href="#l6.726"></a><span id="l6.726"> struct ldap_extra_thread_fns {</span>
<a href="#l6.727"></a><span id="l6.727" class="difflineminus">-  LDAP_TF_MUTEX_TRYLOCK_CALLBACK *ltf_mutex_trylock;</span>
<a href="#l6.728"></a><span id="l6.728" class="difflineminus">-  LDAP_TF_SEMA_ALLOC_CALLBACK *ltf_sema_alloc;</span>
<a href="#l6.729"></a><span id="l6.729" class="difflineminus">-  LDAP_TF_SEMA_FREE_CALLBACK *ltf_sema_free;</span>
<a href="#l6.730"></a><span id="l6.730" class="difflineminus">-  LDAP_TF_SEMA_WAIT_CALLBACK *ltf_sema_wait;</span>
<a href="#l6.731"></a><span id="l6.731" class="difflineminus">-  LDAP_TF_SEMA_POST_CALLBACK *ltf_sema_post;</span>
<a href="#l6.732"></a><span id="l6.732" class="difflineminus">-  LDAP_TF_THREADID_CALLBACK *ltf_threadid_fn;</span>
<a href="#l6.733"></a><span id="l6.733" class="difflineplus">+  LDAP_TF_MUTEX_TRYLOCK_CALLBACK* ltf_mutex_trylock;</span>
<a href="#l6.734"></a><span id="l6.734" class="difflineplus">+  LDAP_TF_SEMA_ALLOC_CALLBACK* ltf_sema_alloc;</span>
<a href="#l6.735"></a><span id="l6.735" class="difflineplus">+  LDAP_TF_SEMA_FREE_CALLBACK* ltf_sema_free;</span>
<a href="#l6.736"></a><span id="l6.736" class="difflineplus">+  LDAP_TF_SEMA_WAIT_CALLBACK* ltf_sema_wait;</span>
<a href="#l6.737"></a><span id="l6.737" class="difflineplus">+  LDAP_TF_SEMA_POST_CALLBACK* ltf_sema_post;</span>
<a href="#l6.738"></a><span id="l6.738" class="difflineplus">+  LDAP_TF_THREADID_CALLBACK* ltf_threadid_fn;</span>
<a href="#l6.739"></a><span id="l6.739"> };</span>
<a href="#l6.740"></a><span id="l6.740"> </span>
<a href="#l6.741"></a><span id="l6.741"> /*</span>
<a href="#l6.742"></a><span id="l6.742">  * Debugging level (an API extension)</span>
<a href="#l6.743"></a><span id="l6.743">  */</span>
<a href="#l6.744"></a><span id="l6.744"> #define LDAP_OPT_DEBUG_LEVEL 0x6E /* 110 - API extension */</span>
<a href="#l6.745"></a><span id="l6.745"> /* On UNIX, there's only one copy of ldap_debug */</span>
<a href="#l6.746"></a><span id="l6.746"> /* On NT, each dll keeps its own module_ldap_debug, which */</span>
<a href="#l6.747"></a><span id="l6.747"> /* points to the process' ldap_debug and needs initializing after load */</span>
<a href="#l6.748"></a><span id="l6.748"> #ifdef _WIN32</span>
<a href="#l6.749"></a><span id="l6.749" class="difflineminus">-extern int *module_ldap_debug;</span>
<a href="#l6.750"></a><span id="l6.750" class="difflineminus">-typedef void (*set_debug_level_fn_t)(int *);</span>
<a href="#l6.751"></a><span id="l6.751" class="difflineplus">+extern int* module_ldap_debug;</span>
<a href="#l6.752"></a><span id="l6.752" class="difflineplus">+typedef void (*set_debug_level_fn_t)(int*);</span>
<a href="#l6.753"></a><span id="l6.753"> #endif</span>
<a href="#l6.754"></a><span id="l6.754"> </span>
<a href="#l6.755"></a><span id="l6.755"> #ifdef LDAP_DNS</span>
<a href="#l6.756"></a><span id="l6.756"> #  define LDAP_OPT_DNS 0x0C /* 12 - API extension */</span>
<a href="#l6.757"></a><span id="l6.757"> #endif</span>
<a href="#l6.758"></a><span id="l6.758"> </span>
<a href="#l6.759"></a><span id="l6.759"> /*</span>
<a href="#l6.760"></a><span id="l6.760">  * UTF-8 routines (should these move into libnls?)</span>
<a href="#l6.761"></a><span id="l6.761">  */</span>
<a href="#l6.762"></a><span id="l6.762"> /* number of bytes in character */</span>
<a href="#l6.763"></a><span id="l6.763" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_utf8len(const char *);</span>
<a href="#l6.764"></a><span id="l6.764" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_utf8len(const char*);</span>
<a href="#l6.765"></a><span id="l6.765"> /* find next character */</span>
<a href="#l6.766"></a><span id="l6.766" class="difflineminus">-LDAP_API(char *) LDAP_CALL ldap_utf8next(char *);</span>
<a href="#l6.767"></a><span id="l6.767" class="difflineplus">+LDAP_API(char*) LDAP_CALL ldap_utf8next(char*);</span>
<a href="#l6.768"></a><span id="l6.768"> /* find previous character */</span>
<a href="#l6.769"></a><span id="l6.769" class="difflineminus">-LDAP_API(char *) LDAP_CALL ldap_utf8prev(char *);</span>
<a href="#l6.770"></a><span id="l6.770" class="difflineplus">+LDAP_API(char*) LDAP_CALL ldap_utf8prev(char*);</span>
<a href="#l6.771"></a><span id="l6.771"> /* copy one character */</span>
<a href="#l6.772"></a><span id="l6.772" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_utf8copy(char *dst, const char *src);</span>
<a href="#l6.773"></a><span id="l6.773" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_utf8copy(char* dst, const char* src);</span>
<a href="#l6.774"></a><span id="l6.774"> /* total number of characters */</span>
<a href="#l6.775"></a><span id="l6.775" class="difflineminus">-LDAP_API(size_t) LDAP_CALL ldap_utf8characters(const char *);</span>
<a href="#l6.776"></a><span id="l6.776" class="difflineplus">+LDAP_API(size_t) LDAP_CALL ldap_utf8characters(const char*);</span>
<a href="#l6.777"></a><span id="l6.777"> /* get one UCS-4 character, and move *src to the next character */</span>
<a href="#l6.778"></a><span id="l6.778" class="difflineminus">-LDAP_API(unsigned long) LDAP_CALL ldap_utf8getcc(const char **src);</span>
<a href="#l6.779"></a><span id="l6.779" class="difflineplus">+LDAP_API(unsigned long) LDAP_CALL ldap_utf8getcc(const char** src);</span>
<a href="#l6.780"></a><span id="l6.780"> /* UTF-8 aware strtok_r() */</span>
<a href="#l6.781"></a><span id="l6.781" class="difflineminus">-LDAP_API(char *)</span>
<a href="#l6.782"></a><span id="l6.782" class="difflineminus">-LDAP_CALL ldap_utf8strtok_r(char *src, const char *brk, char **next);</span>
<a href="#l6.783"></a><span id="l6.783" class="difflineplus">+LDAP_API(char*)</span>
<a href="#l6.784"></a><span id="l6.784" class="difflineplus">+LDAP_CALL ldap_utf8strtok_r(char* src, const char* brk, char** next);</span>
<a href="#l6.785"></a><span id="l6.785"> </span>
<a href="#l6.786"></a><span id="l6.786"> /* like isalnum(*s) in the C locale */</span>
<a href="#l6.787"></a><span id="l6.787" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_utf8isalnum(char *s);</span>
<a href="#l6.788"></a><span id="l6.788" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_utf8isalnum(char* s);</span>
<a href="#l6.789"></a><span id="l6.789"> /* like isalpha(*s) in the C locale */</span>
<a href="#l6.790"></a><span id="l6.790" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_utf8isalpha(char *s);</span>
<a href="#l6.791"></a><span id="l6.791" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_utf8isalpha(char* s);</span>
<a href="#l6.792"></a><span id="l6.792"> /* like isdigit(*s) in the C locale */</span>
<a href="#l6.793"></a><span id="l6.793" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_utf8isdigit(char *s);</span>
<a href="#l6.794"></a><span id="l6.794" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_utf8isdigit(char* s);</span>
<a href="#l6.795"></a><span id="l6.795"> /* like isxdigit(*s) in the C locale */</span>
<a href="#l6.796"></a><span id="l6.796" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_utf8isxdigit(char *s);</span>
<a href="#l6.797"></a><span id="l6.797" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_utf8isxdigit(char* s);</span>
<a href="#l6.798"></a><span id="l6.798"> /* like isspace(*s) in the C locale */</span>
<a href="#l6.799"></a><span id="l6.799" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_utf8isspace(char *s);</span>
<a href="#l6.800"></a><span id="l6.800" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_utf8isspace(char* s);</span>
<a href="#l6.801"></a><span id="l6.801"> </span>
<a href="#l6.802"></a><span id="l6.802" class="difflineminus">-#define LDAP_UTF8LEN(s) ((0x80 &amp; *(unsigned char *)(s)) ? ldap_utf8len(s) : 1)</span>
<a href="#l6.803"></a><span id="l6.803" class="difflineplus">+#define LDAP_UTF8LEN(s) ((0x80 &amp; *(unsigned char*)(s)) ? ldap_utf8len(s) : 1)</span>
<a href="#l6.804"></a><span id="l6.804"> #define LDAP_UTF8NEXT(s) \</span>
<a href="#l6.805"></a><span id="l6.805" class="difflineminus">-  ((0x80 &amp; *(unsigned char *)(s)) ? ldap_utf8next(s) : (s) + 1)</span>
<a href="#l6.806"></a><span id="l6.806" class="difflineplus">+  ((0x80 &amp; *(unsigned char*)(s)) ? ldap_utf8next(s) : (s) + 1)</span>
<a href="#l6.807"></a><span id="l6.807"> #define LDAP_UTF8INC(s) \</span>
<a href="#l6.808"></a><span id="l6.808" class="difflineminus">-  ((0x80 &amp; *(unsigned char *)(s)) ? s = ldap_utf8next(s) : ++s)</span>
<a href="#l6.809"></a><span id="l6.809" class="difflineplus">+  ((0x80 &amp; *(unsigned char*)(s)) ? s = ldap_utf8next(s) : ++s)</span>
<a href="#l6.810"></a><span id="l6.810"> </span>
<a href="#l6.811"></a><span id="l6.811"> #define LDAP_UTF8PREV(s) ldap_utf8prev(s)</span>
<a href="#l6.812"></a><span id="l6.812"> #define LDAP_UTF8DEC(s) (s = ldap_utf8prev(s))</span>
<a href="#l6.813"></a><span id="l6.813"> </span>
<a href="#l6.814"></a><span id="l6.814"> #define LDAP_UTF8COPY(d, s) \</span>
<a href="#l6.815"></a><span id="l6.815" class="difflineminus">-  ((0x80 &amp; *(unsigned char *)(s)) ? ldap_utf8copy(d, s) : ((*(d) = *(s)), 1))</span>
<a href="#l6.816"></a><span id="l6.816" class="difflineplus">+  ((0x80 &amp; *(unsigned char*)(s)) ? ldap_utf8copy(d, s) : ((*(d) = *(s)), 1))</span>
<a href="#l6.817"></a><span id="l6.817"> #define LDAP_UTF8GETCC(s) \</span>
<a href="#l6.818"></a><span id="l6.818" class="difflineminus">-  ((0x80 &amp; *(unsigned char *)(s)) ? ldap_utf8getcc(&amp;s) : *s++)</span>
<a href="#l6.819"></a><span id="l6.819" class="difflineplus">+  ((0x80 &amp; *(unsigned char*)(s)) ? ldap_utf8getcc(&amp;s) : *s++)</span>
<a href="#l6.820"></a><span id="l6.820"> #define LDAP_UTF8GETC(s) \</span>
<a href="#l6.821"></a><span id="l6.821" class="difflineminus">-  ((0x80 &amp; *(unsigned char *)(s)) ? ldap_utf8getcc((const char **)&amp;s) : *s++)</span>
<a href="#l6.822"></a><span id="l6.822" class="difflineplus">+  ((0x80 &amp; *(unsigned char*)(s)) ? ldap_utf8getcc((const char**)&amp;s) : *s++)</span>
<a href="#l6.823"></a><span id="l6.823"> </span>
<a href="#l6.824"></a><span id="l6.824"> /* SASL options */</span>
<a href="#l6.825"></a><span id="l6.825"> #define LDAP_OPT_X_SASL_MECH 0x6100</span>
<a href="#l6.826"></a><span id="l6.826"> #define LDAP_OPT_X_SASL_REALM 0x6101</span>
<a href="#l6.827"></a><span id="l6.827"> #define LDAP_OPT_X_SASL_AUTHCID 0x6102</span>
<a href="#l6.828"></a><span id="l6.828"> #define LDAP_OPT_X_SASL_AUTHZID 0x6103</span>
<a href="#l6.829"></a><span id="l6.829"> #define LDAP_OPT_X_SASL_SSF 0x6104          /* read-only */</span>
<a href="#l6.830"></a><span id="l6.830"> #define LDAP_OPT_X_SASL_SSF_EXTERNAL 0x6105 /* write-only */</span>
<a href="#l6.831"></a><span id="l6.831" class="difflineat">@@ -837,62 +837,62 @@ LDAP_API(int) LDAP_CALL ldap_utf8isspace</span>
<a href="#l6.832"></a><span id="l6.832"> #define LDAP_SASL_QUIET \</span>
<a href="#l6.833"></a><span id="l6.833">   2U /* no prompts - only use defaults (e.g. for non-interactive apps) */</span>
<a href="#l6.834"></a><span id="l6.834"> </span>
<a href="#l6.835"></a><span id="l6.835"> /*</span>
<a href="#l6.836"></a><span id="l6.836">  * V3 SASL Interaction Function Callback Prototype</span>
<a href="#l6.837"></a><span id="l6.837">  *      when using Cyrus SASL, interact is pointer to sasl_interact_t</span>
<a href="#l6.838"></a><span id="l6.838">  *  should likely passed in a control (and provided controls)</span>
<a href="#l6.839"></a><span id="l6.839">  */</span>
<a href="#l6.840"></a><span id="l6.840" class="difflineminus">-typedef int(LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults,</span>
<a href="#l6.841"></a><span id="l6.841" class="difflineminus">-                                     void *interact);</span>
<a href="#l6.842"></a><span id="l6.842" class="difflineplus">+typedef int(LDAP_SASL_INTERACT_PROC)(LDAP* ld, unsigned flags, void* defaults,</span>
<a href="#l6.843"></a><span id="l6.843" class="difflineplus">+                                     void* interact);</span>
<a href="#l6.844"></a><span id="l6.844"> </span>
<a href="#l6.845"></a><span id="l6.845"> LDAP_API(int)</span>
<a href="#l6.846"></a><span id="l6.846"> LDAP_CALL</span>
<a href="#l6.847"></a><span id="l6.847" class="difflineminus">-ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn, /* usually NULL */</span>
<a href="#l6.848"></a><span id="l6.848" class="difflineminus">-                             const char *saslMechanism,</span>
<a href="#l6.849"></a><span id="l6.849" class="difflineminus">-                             LDAPControl **serverControls,</span>
<a href="#l6.850"></a><span id="l6.850" class="difflineminus">-                             LDAPControl **clientControls,</span>
<a href="#l6.851"></a><span id="l6.851" class="difflineplus">+ldap_sasl_interactive_bind_s(LDAP* ld, const char* dn, /* usually NULL */</span>
<a href="#l6.852"></a><span id="l6.852" class="difflineplus">+                             const char* saslMechanism,</span>
<a href="#l6.853"></a><span id="l6.853" class="difflineplus">+                             LDAPControl** serverControls,</span>
<a href="#l6.854"></a><span id="l6.854" class="difflineplus">+                             LDAPControl** clientControls,</span>
<a href="#l6.855"></a><span id="l6.855"> </span>
<a href="#l6.856"></a><span id="l6.856">                              /* should be client controls */</span>
<a href="#l6.857"></a><span id="l6.857" class="difflineminus">-                             unsigned flags, LDAP_SASL_INTERACT_PROC *proc,</span>
<a href="#l6.858"></a><span id="l6.858" class="difflineminus">-                             void *defaults);</span>
<a href="#l6.859"></a><span id="l6.859" class="difflineplus">+                             unsigned flags, LDAP_SASL_INTERACT_PROC* proc,</span>
<a href="#l6.860"></a><span id="l6.860" class="difflineplus">+                             void* defaults);</span>
<a href="#l6.861"></a><span id="l6.861"> </span>
<a href="#l6.862"></a><span id="l6.862"> LDAP_API(int)</span>
<a href="#l6.863"></a><span id="l6.863"> LDAP_CALL ldap_sasl_interactive_bind_ext_s(</span>
<a href="#l6.864"></a><span id="l6.864" class="difflineminus">-    LDAP *ld, const char *dn, /* usually NULL */</span>
<a href="#l6.865"></a><span id="l6.865" class="difflineminus">-    const char *saslMechanism, LDAPControl **serverControls,</span>
<a href="#l6.866"></a><span id="l6.866" class="difflineminus">-    LDAPControl **clientControls,</span>
<a href="#l6.867"></a><span id="l6.867" class="difflineplus">+    LDAP* ld, const char* dn, /* usually NULL */</span>
<a href="#l6.868"></a><span id="l6.868" class="difflineplus">+    const char* saslMechanism, LDAPControl** serverControls,</span>
<a href="#l6.869"></a><span id="l6.869" class="difflineplus">+    LDAPControl** clientControls,</span>
<a href="#l6.870"></a><span id="l6.870"> </span>
<a href="#l6.871"></a><span id="l6.871">     /* should be client controls */</span>
<a href="#l6.872"></a><span id="l6.872" class="difflineminus">-    unsigned flags, LDAP_SASL_INTERACT_PROC *proc, void *defaults,</span>
<a href="#l6.873"></a><span id="l6.873" class="difflineminus">-    LDAPControl ***responseControls);</span>
<a href="#l6.874"></a><span id="l6.874" class="difflineplus">+    unsigned flags, LDAP_SASL_INTERACT_PROC* proc, void* defaults,</span>
<a href="#l6.875"></a><span id="l6.875" class="difflineplus">+    LDAPControl*** responseControls);</span>
<a href="#l6.876"></a><span id="l6.876"> </span>
<a href="#l6.877"></a><span id="l6.877"> /*</span>
<a href="#l6.878"></a><span id="l6.878">  * Password modify functions</span>
<a href="#l6.879"></a><span id="l6.879">  */</span>
<a href="#l6.880"></a><span id="l6.880"> LDAP_API(int)</span>
<a href="#l6.881"></a><span id="l6.881" class="difflineminus">-LDAP_CALL ldap_passwd(LDAP *ld, struct berval *userid, struct berval *oldpasswd,</span>
<a href="#l6.882"></a><span id="l6.882" class="difflineminus">-                      struct berval *newpasswd, LDAPControl **serverctrls,</span>
<a href="#l6.883"></a><span id="l6.883" class="difflineminus">-                      LDAPControl **clientctrls, int *msgidp);</span>
<a href="#l6.884"></a><span id="l6.884" class="difflineplus">+LDAP_CALL ldap_passwd(LDAP* ld, struct berval* userid, struct berval* oldpasswd,</span>
<a href="#l6.885"></a><span id="l6.885" class="difflineplus">+                      struct berval* newpasswd, LDAPControl** serverctrls,</span>
<a href="#l6.886"></a><span id="l6.886" class="difflineplus">+                      LDAPControl** clientctrls, int* msgidp);</span>
<a href="#l6.887"></a><span id="l6.887"> </span>
<a href="#l6.888"></a><span id="l6.888"> LDAP_API(int)</span>
<a href="#l6.889"></a><span id="l6.889"> LDAP_CALL</span>
<a href="#l6.890"></a><span id="l6.890" class="difflineminus">-ldap_passwd_s(LDAP *ld, struct berval *userid, struct berval *oldpasswd,</span>
<a href="#l6.891"></a><span id="l6.891" class="difflineminus">-              struct berval *newpasswd, struct berval *genpasswd,</span>
<a href="#l6.892"></a><span id="l6.892" class="difflineminus">-              LDAPControl **serverctrls, LDAPControl **clientctrls);</span>
<a href="#l6.893"></a><span id="l6.893" class="difflineplus">+ldap_passwd_s(LDAP* ld, struct berval* userid, struct berval* oldpasswd,</span>
<a href="#l6.894"></a><span id="l6.894" class="difflineplus">+              struct berval* newpasswd, struct berval* genpasswd,</span>
<a href="#l6.895"></a><span id="l6.895" class="difflineplus">+              LDAPControl** serverctrls, LDAPControl** clientctrls);</span>
<a href="#l6.896"></a><span id="l6.896"> </span>
<a href="#l6.897"></a><span id="l6.897"> LDAP_API(int)</span>
<a href="#l6.898"></a><span id="l6.898"> LDAP_CALL</span>
<a href="#l6.899"></a><span id="l6.899" class="difflineminus">-ldap_parse_passwd(LDAP *ld, LDAPMessage *result, struct berval *genpasswd);</span>
<a href="#l6.900"></a><span id="l6.900" class="difflineplus">+ldap_parse_passwd(LDAP* ld, LDAPMessage* result, struct berval* genpasswd);</span>
<a href="#l6.901"></a><span id="l6.901"> </span>
<a href="#l6.902"></a><span id="l6.902"> /*</span>
<a href="#l6.903"></a><span id="l6.903">  * in reslist.c</span>
<a href="#l6.904"></a><span id="l6.904">  */</span>
<a href="#l6.905"></a><span id="l6.905" class="difflineminus">-LDAP_API(LDAPMessage *)</span>
<a href="#l6.906"></a><span id="l6.906" class="difflineminus">-LDAP_CALL ldap_delete_result_entry(LDAPMessage **list, LDAPMessage *e);</span>
<a href="#l6.907"></a><span id="l6.907" class="difflineplus">+LDAP_API(LDAPMessage*)</span>
<a href="#l6.908"></a><span id="l6.908" class="difflineplus">+LDAP_CALL ldap_delete_result_entry(LDAPMessage** list, LDAPMessage* e);</span>
<a href="#l6.909"></a><span id="l6.909"> LDAP_API(void)</span>
<a href="#l6.910"></a><span id="l6.910" class="difflineminus">-LDAP_CALL ldap_add_result_entry(LDAPMessage **list, LDAPMessage *e);</span>
<a href="#l6.911"></a><span id="l6.911" class="difflineplus">+LDAP_CALL ldap_add_result_entry(LDAPMessage** list, LDAPMessage* e);</span>
<a href="#l6.912"></a><span id="l6.912"> </span>
<a href="#l6.913"></a><span id="l6.913"> #ifdef __cplusplus</span>
<a href="#l6.914"></a><span id="l6.914"> }</span>
<a href="#l6.915"></a><span id="l6.915"> #endif</span>
<a href="#l6.916"></a><span id="l6.916"> #endif /* _LDAP_EXTENSION_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/ldap/c-sdk/include/ldap-standard.h</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/ldap/c-sdk/include/ldap-standard.h</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -92,76 +92,76 @@ extern &quot;C&quot; {</span>
<a href="#l7.4"></a><span id="l7.4"> </span>
<a href="#l7.5"></a><span id="l7.5"> /*</span>
<a href="#l7.6"></a><span id="l7.6">  * Well-behaved private and experimental extensions will use option values</span>
<a href="#l7.7"></a><span id="l7.7">  * between 0x4000 (16384) and 0x7FFF (32767) inclusive.</span>
<a href="#l7.8"></a><span id="l7.8">  */</span>
<a href="#l7.9"></a><span id="l7.9"> #define LDAP_OPT_PRIVATE_EXTENSION_BASE 0x4000 /* to 0x7FFF inclusive */</span>
<a href="#l7.10"></a><span id="l7.10"> </span>
<a href="#l7.11"></a><span id="l7.11"> /* for on/off options */</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-#define LDAP_OPT_ON ((void *)1)</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineminus">-#define LDAP_OPT_OFF ((void *)0)</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+#define LDAP_OPT_ON ((void*)1)</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+#define LDAP_OPT_OFF ((void*)0)</span>
<a href="#l7.16"></a><span id="l7.16"> </span>
<a href="#l7.17"></a><span id="l7.17"> typedef struct ldap LDAP;           /* opaque connection handle */</span>
<a href="#l7.18"></a><span id="l7.18"> typedef struct ldapmsg LDAPMessage; /* opaque result/entry handle */</span>
<a href="#l7.19"></a><span id="l7.19"> </span>
<a href="#l7.20"></a><span id="l7.20"> /* structure representing an LDAP modification */</span>
<a href="#l7.21"></a><span id="l7.21"> typedef struct ldapmod {</span>
<a href="#l7.22"></a><span id="l7.22">   int mod_op; /* kind of mod + form of values*/</span>
<a href="#l7.23"></a><span id="l7.23"> #define LDAP_MOD_ADD 0x00</span>
<a href="#l7.24"></a><span id="l7.24"> #define LDAP_MOD_DELETE 0x01</span>
<a href="#l7.25"></a><span id="l7.25"> #define LDAP_MOD_REPLACE 0x02</span>
<a href="#l7.26"></a><span id="l7.26"> #define LDAP_MOD_BVALUES 0x80</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineminus">-  char *mod_type; /* attribute name to modify */</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineplus">+  char* mod_type; /* attribute name to modify */</span>
<a href="#l7.29"></a><span id="l7.29">   union mod_vals_u {</span>
<a href="#l7.30"></a><span id="l7.30" class="difflineminus">-    char **modv_strvals;</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-    struct berval **modv_bvals;</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+    char** modv_strvals;</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineplus">+    struct berval** modv_bvals;</span>
<a href="#l7.34"></a><span id="l7.34">   } mod_vals; /* values to add/delete/replace */</span>
<a href="#l7.35"></a><span id="l7.35"> #define mod_values mod_vals.modv_strvals</span>
<a href="#l7.36"></a><span id="l7.36"> #define mod_bvalues mod_vals.modv_bvals</span>
<a href="#l7.37"></a><span id="l7.37"> } LDAPMod;</span>
<a href="#l7.38"></a><span id="l7.38"> </span>
<a href="#l7.39"></a><span id="l7.39"> /*</span>
<a href="#l7.40"></a><span id="l7.40">  * structure for holding ldapv3 controls</span>
<a href="#l7.41"></a><span id="l7.41">  */</span>
<a href="#l7.42"></a><span id="l7.42"> typedef struct ldapcontrol {</span>
<a href="#l7.43"></a><span id="l7.43" class="difflineminus">-  char *ldctl_oid;</span>
<a href="#l7.44"></a><span id="l7.44" class="difflineplus">+  char* ldctl_oid;</span>
<a href="#l7.45"></a><span id="l7.45">   struct berval ldctl_value;</span>
<a href="#l7.46"></a><span id="l7.46">   char ldctl_iscritical;</span>
<a href="#l7.47"></a><span id="l7.47"> } LDAPControl;</span>
<a href="#l7.48"></a><span id="l7.48"> </span>
<a href="#l7.49"></a><span id="l7.49"> /*</span>
<a href="#l7.50"></a><span id="l7.50">  * LDAP API information.  Can be retrieved by using a sequence like:</span>
<a href="#l7.51"></a><span id="l7.51">  *</span>
<a href="#l7.52"></a><span id="l7.52">  *    LDAPAPIInfo ldai;</span>
<a href="#l7.53"></a><span id="l7.53">  *    ldai.ldapai_info_version = LDAP_API_INFO_VERSION;</span>
<a href="#l7.54"></a><span id="l7.54">  *    if ( ldap_get_option( NULL, LDAP_OPT_API_INFO, &amp;ldia ) == 0 ) ...</span>
<a href="#l7.55"></a><span id="l7.55">  */</span>
<a href="#l7.56"></a><span id="l7.56"> #define LDAP_API_INFO_VERSION 1</span>
<a href="#l7.57"></a><span id="l7.57"> typedef struct ldapapiinfo {</span>
<a href="#l7.58"></a><span id="l7.58">   int ldapai_info_version;     /* version of this struct (1) */</span>
<a href="#l7.59"></a><span id="l7.59">   int ldapai_api_version;      /* revision of API supported */</span>
<a href="#l7.60"></a><span id="l7.60">   int ldapai_protocol_version; /* highest LDAP version supported */</span>
<a href="#l7.61"></a><span id="l7.61" class="difflineminus">-  char **ldapai_extensions;    /* names of API extensions */</span>
<a href="#l7.62"></a><span id="l7.62" class="difflineminus">-  char *ldapai_vendor_name;    /* name of supplier */</span>
<a href="#l7.63"></a><span id="l7.63" class="difflineplus">+  char** ldapai_extensions;    /* names of API extensions */</span>
<a href="#l7.64"></a><span id="l7.64" class="difflineplus">+  char* ldapai_vendor_name;    /* name of supplier */</span>
<a href="#l7.65"></a><span id="l7.65">   int ldapai_vendor_version;   /* supplier-specific version times 100 */</span>
<a href="#l7.66"></a><span id="l7.66"> } LDAPAPIInfo;</span>
<a href="#l7.67"></a><span id="l7.67"> </span>
<a href="#l7.68"></a><span id="l7.68"> /*</span>
<a href="#l7.69"></a><span id="l7.69">  * LDAP API extended features info.  Can be retrieved by using a sequence like:</span>
<a href="#l7.70"></a><span id="l7.70">  *</span>
<a href="#l7.71"></a><span id="l7.71">  *    LDAPAPIFeatureInfo ldfi;</span>
<a href="#l7.72"></a><span id="l7.72">  *    ldfi.ldapaif_info_version = LDAP_FEATURE_INFO_VERSION;</span>
<a href="#l7.73"></a><span id="l7.73">  *    ldfi.ldapaif_name = &quot;VIRTUAL_LIST_VIEW&quot;;</span>
<a href="#l7.74"></a><span id="l7.74">  *    if ( ldap_get_option( NULL, LDAP_OPT_API_FEATURE_INFO, &amp;ldfi ) == 0 ) ...</span>
<a href="#l7.75"></a><span id="l7.75">  */</span>
<a href="#l7.76"></a><span id="l7.76"> #define LDAP_FEATURE_INFO_VERSION 1</span>
<a href="#l7.77"></a><span id="l7.77"> typedef struct ldap_apifeature_info {</span>
<a href="#l7.78"></a><span id="l7.78">   int ldapaif_info_version; /* version of this struct (1) */</span>
<a href="#l7.79"></a><span id="l7.79" class="difflineminus">-  char *ldapaif_name;       /* name of supported feature */</span>
<a href="#l7.80"></a><span id="l7.80" class="difflineplus">+  char* ldapaif_name;       /* name of supported feature */</span>
<a href="#l7.81"></a><span id="l7.81">   int ldapaif_version;      /* revision of supported feature */</span>
<a href="#l7.82"></a><span id="l7.82"> } LDAPAPIFeatureInfo;</span>
<a href="#l7.83"></a><span id="l7.83"> </span>
<a href="#l7.84"></a><span id="l7.84"> /* possible result types a server can return */</span>
<a href="#l7.85"></a><span id="l7.85"> #define LDAP_RES_BIND 0x61L             /* 97 */</span>
<a href="#l7.86"></a><span id="l7.86"> #define LDAP_RES_SEARCH_ENTRY 0x64L     /* 100 */</span>
<a href="#l7.87"></a><span id="l7.87"> #define LDAP_RES_SEARCH_RESULT 0x65L    /* 101 */</span>
<a href="#l7.88"></a><span id="l7.88"> #define LDAP_RES_MODIFY 0x67L           /* 103 */</span>
<a href="#l7.89"></a><span id="l7.89" class="difflineat">@@ -276,210 +276,210 @@ typedef struct ldap_apifeature_info {</span>
<a href="#l7.90"></a><span id="l7.90"> /*</span>
<a href="#l7.91"></a><span id="l7.91">  * Initializing an ldap session, set session handle options, and</span>
<a href="#l7.92"></a><span id="l7.92">  * closing an ldap session functions</span>
<a href="#l7.93"></a><span id="l7.93">  *</span>
<a href="#l7.94"></a><span id="l7.94">  * NOTE: If you want to use IPv6, you must use prldap creating a LDAP handle</span>
<a href="#l7.95"></a><span id="l7.95">  * with prldap_init instead of ldap_init. Or install the NSPR functions</span>
<a href="#l7.96"></a><span id="l7.96">  * by calling prldap_install_routines. (See the nspr samples in examples)</span>
<a href="#l7.97"></a><span id="l7.97">  */</span>
<a href="#l7.98"></a><span id="l7.98" class="difflineminus">-LDAP_API(LDAP *) LDAP_CALL ldap_init(const char *defhost, int defport);</span>
<a href="#l7.99"></a><span id="l7.99" class="difflineplus">+LDAP_API(LDAP*) LDAP_CALL ldap_init(const char* defhost, int defport);</span>
<a href="#l7.100"></a><span id="l7.100"> LDAP_API(int)</span>
<a href="#l7.101"></a><span id="l7.101" class="difflineminus">-LDAP_CALL ldap_set_option(LDAP *ld, int option, const void *optdata);</span>
<a href="#l7.102"></a><span id="l7.102" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_get_option(LDAP *ld, int option, void *optdata);</span>
<a href="#l7.103"></a><span id="l7.103" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_unbind(LDAP *ld);</span>
<a href="#l7.104"></a><span id="l7.104" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_unbind_s(LDAP *ld);</span>
<a href="#l7.105"></a><span id="l7.105" class="difflineplus">+LDAP_CALL ldap_set_option(LDAP* ld, int option, const void* optdata);</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_get_option(LDAP* ld, int option, void* optdata);</span>
<a href="#l7.107"></a><span id="l7.107" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_unbind(LDAP* ld);</span>
<a href="#l7.108"></a><span id="l7.108" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_unbind_s(LDAP* ld);</span>
<a href="#l7.109"></a><span id="l7.109"> </span>
<a href="#l7.110"></a><span id="l7.110"> /*</span>
<a href="#l7.111"></a><span id="l7.111">  * perform ldap operations</span>
<a href="#l7.112"></a><span id="l7.112">  */</span>
<a href="#l7.113"></a><span id="l7.113" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_abandon(LDAP *ld, int msgid);</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_add(LDAP *ld, const char *dn, LDAPMod **attrs);</span>
<a href="#l7.115"></a><span id="l7.115" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_add_s(LDAP *ld, const char *dn, LDAPMod **attrs);</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_abandon(LDAP* ld, int msgid);</span>
<a href="#l7.117"></a><span id="l7.117" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_add(LDAP* ld, const char* dn, LDAPMod** attrs);</span>
<a href="#l7.118"></a><span id="l7.118" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_add_s(LDAP* ld, const char* dn, LDAPMod** attrs);</span>
<a href="#l7.119"></a><span id="l7.119"> LDAP_API(int)</span>
<a href="#l7.120"></a><span id="l7.120" class="difflineminus">-LDAP_CALL ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineplus">+LDAP_CALL ldap_simple_bind(LDAP* ld, const char* who, const char* passwd);</span>
<a href="#l7.122"></a><span id="l7.122"> LDAP_API(int)</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineminus">-LDAP_CALL ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);</span>
<a href="#l7.124"></a><span id="l7.124" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_modify(LDAP *ld, const char *dn, LDAPMod **mods);</span>
<a href="#l7.125"></a><span id="l7.125" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_modify_s(LDAP *ld, const char *dn, LDAPMod **mods);</span>
<a href="#l7.126"></a><span id="l7.126" class="difflineplus">+LDAP_CALL ldap_simple_bind_s(LDAP* ld, const char* who, const char* passwd);</span>
<a href="#l7.127"></a><span id="l7.127" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_modify(LDAP* ld, const char* dn, LDAPMod** mods);</span>
<a href="#l7.128"></a><span id="l7.128" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_modify_s(LDAP* ld, const char* dn, LDAPMod** mods);</span>
<a href="#l7.129"></a><span id="l7.129"> LDAP_API(int)</span>
<a href="#l7.130"></a><span id="l7.130"> LDAP_CALL</span>
<a href="#l7.131"></a><span id="l7.131" class="difflineminus">-ldap_compare(LDAP *ld, const char *dn, const char *attr, const char *value);</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineplus">+ldap_compare(LDAP* ld, const char* dn, const char* attr, const char* value);</span>
<a href="#l7.133"></a><span id="l7.133"> LDAP_API(int)</span>
<a href="#l7.134"></a><span id="l7.134" class="difflineminus">-LDAP_CALL ldap_compare_s(LDAP *ld, const char *dn, const char *attr,</span>
<a href="#l7.135"></a><span id="l7.135" class="difflineminus">-                         const char *value);</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_delete(LDAP *ld, const char *dn);</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_delete_s(LDAP *ld, const char *dn);</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineplus">+LDAP_CALL ldap_compare_s(LDAP* ld, const char* dn, const char* attr,</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineplus">+                         const char* value);</span>
<a href="#l7.140"></a><span id="l7.140" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_delete(LDAP* ld, const char* dn);</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_delete_s(LDAP* ld, const char* dn);</span>
<a href="#l7.142"></a><span id="l7.142"> LDAP_API(int)</span>
<a href="#l7.143"></a><span id="l7.143" class="difflineminus">-LDAP_CALL ldap_search(LDAP *ld, const char *base, int scope, const char *filter,</span>
<a href="#l7.144"></a><span id="l7.144" class="difflineminus">-                      char **attrs, int attrsonly);</span>
<a href="#l7.145"></a><span id="l7.145" class="difflineplus">+LDAP_CALL ldap_search(LDAP* ld, const char* base, int scope, const char* filter,</span>
<a href="#l7.146"></a><span id="l7.146" class="difflineplus">+                      char** attrs, int attrsonly);</span>
<a href="#l7.147"></a><span id="l7.147"> LDAP_API(int)</span>
<a href="#l7.148"></a><span id="l7.148"> LDAP_CALL</span>
<a href="#l7.149"></a><span id="l7.149" class="difflineminus">-ldap_search_s(LDAP *ld, const char *base, int scope, const char *filter,</span>
<a href="#l7.150"></a><span id="l7.150" class="difflineminus">-              char **attrs, int attrsonly, LDAPMessage **res);</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineplus">+ldap_search_s(LDAP* ld, const char* base, int scope, const char* filter,</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineplus">+              char** attrs, int attrsonly, LDAPMessage** res);</span>
<a href="#l7.153"></a><span id="l7.153"> LDAP_API(int)</span>
<a href="#l7.154"></a><span id="l7.154" class="difflineminus">-LDAP_CALL ldap_search_st(LDAP *ld, const char *base, int scope,</span>
<a href="#l7.155"></a><span id="l7.155" class="difflineminus">-                         const char *filter, char **attrs, int attrsonly,</span>
<a href="#l7.156"></a><span id="l7.156" class="difflineminus">-                         struct timeval *timeout, LDAPMessage **res);</span>
<a href="#l7.157"></a><span id="l7.157" class="difflineplus">+LDAP_CALL ldap_search_st(LDAP* ld, const char* base, int scope,</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineplus">+                         const char* filter, char** attrs, int attrsonly,</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineplus">+                         struct timeval* timeout, LDAPMessage** res);</span>
<a href="#l7.160"></a><span id="l7.160"> </span>
<a href="#l7.161"></a><span id="l7.161"> /*</span>
<a href="#l7.162"></a><span id="l7.162">  * obtain result from ldap operation</span>
<a href="#l7.163"></a><span id="l7.163">  */</span>
<a href="#l7.164"></a><span id="l7.164"> LDAP_API(int)</span>
<a href="#l7.165"></a><span id="l7.165" class="difflineminus">-LDAP_CALL ldap_result(LDAP *ld, int msgid, int all, struct timeval *timeout,</span>
<a href="#l7.166"></a><span id="l7.166" class="difflineminus">-                      LDAPMessage **result);</span>
<a href="#l7.167"></a><span id="l7.167" class="difflineplus">+LDAP_CALL ldap_result(LDAP* ld, int msgid, int all, struct timeval* timeout,</span>
<a href="#l7.168"></a><span id="l7.168" class="difflineplus">+                      LDAPMessage** result);</span>
<a href="#l7.169"></a><span id="l7.169"> </span>
<a href="#l7.170"></a><span id="l7.170"> /*</span>
<a href="#l7.171"></a><span id="l7.171">  * peeking inside LDAP Messages and deallocating LDAP Messages</span>
<a href="#l7.172"></a><span id="l7.172">  */</span>
<a href="#l7.173"></a><span id="l7.173" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_msgfree(LDAPMessage *lm);</span>
<a href="#l7.174"></a><span id="l7.174" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_msgid(LDAPMessage *lm);</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_msgtype(LDAPMessage *lm);</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_msgfree(LDAPMessage* lm);</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_msgid(LDAPMessage* lm);</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_msgtype(LDAPMessage* lm);</span>
<a href="#l7.179"></a><span id="l7.179"> </span>
<a href="#l7.180"></a><span id="l7.180"> /*</span>
<a href="#l7.181"></a><span id="l7.181">  * Routines to parse/deal with results and errors returned</span>
<a href="#l7.182"></a><span id="l7.182">  */</span>
<a href="#l7.183"></a><span id="l7.183" class="difflineminus">-LDAP_API(char *) LDAP_CALL ldap_err2string(int err);</span>
<a href="#l7.184"></a><span id="l7.184" class="difflineminus">-LDAP_API(LDAPMessage *)</span>
<a href="#l7.185"></a><span id="l7.185" class="difflineminus">-LDAP_CALL ldap_first_entry(LDAP *ld, LDAPMessage *chain);</span>
<a href="#l7.186"></a><span id="l7.186" class="difflineminus">-LDAP_API(LDAPMessage *) LDAP_CALL ldap_next_entry(LDAP *ld, LDAPMessage *entry);</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_count_entries(LDAP *ld, LDAPMessage *chain);</span>
<a href="#l7.188"></a><span id="l7.188" class="difflineminus">-LDAP_API(char *) LDAP_CALL ldap_get_dn(LDAP *ld, LDAPMessage *entry);</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineminus">-LDAP_API(char *) LDAP_CALL ldap_dn2ufn(const char *dn);</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineminus">-LDAP_API(char **) LDAP_CALL ldap_explode_dn(const char *dn, const int notypes);</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineminus">-LDAP_API(char **)</span>
<a href="#l7.192"></a><span id="l7.192" class="difflineminus">-LDAP_CALL ldap_explode_rdn(const char *rdn, const int notypes);</span>
<a href="#l7.193"></a><span id="l7.193" class="difflineminus">-LDAP_API(char *)</span>
<a href="#l7.194"></a><span id="l7.194" class="difflineminus">-LDAP_CALL ldap_first_attribute(LDAP *ld, LDAPMessage *entry, BerElement **ber);</span>
<a href="#l7.195"></a><span id="l7.195" class="difflineminus">-LDAP_API(char *)</span>
<a href="#l7.196"></a><span id="l7.196" class="difflineminus">-LDAP_CALL ldap_next_attribute(LDAP *ld, LDAPMessage *entry, BerElement *ber);</span>
<a href="#l7.197"></a><span id="l7.197" class="difflineminus">-LDAP_API(char **)</span>
<a href="#l7.198"></a><span id="l7.198" class="difflineminus">-LDAP_CALL ldap_get_values(LDAP *ld, LDAPMessage *entry, const char *target);</span>
<a href="#l7.199"></a><span id="l7.199" class="difflineminus">-LDAP_API(struct berval **)</span>
<a href="#l7.200"></a><span id="l7.200" class="difflineminus">-LDAP_CALL ldap_get_values_len(LDAP *ld, LDAPMessage *entry, const char *target);</span>
<a href="#l7.201"></a><span id="l7.201" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_count_values(char **vals);</span>
<a href="#l7.202"></a><span id="l7.202" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_count_values_len(struct berval **vals);</span>
<a href="#l7.203"></a><span id="l7.203" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_value_free(char **vals);</span>
<a href="#l7.204"></a><span id="l7.204" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_value_free_len(struct berval **vals);</span>
<a href="#l7.205"></a><span id="l7.205" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_memfree(void *p);</span>
<a href="#l7.206"></a><span id="l7.206" class="difflineplus">+LDAP_API(char*) LDAP_CALL ldap_err2string(int err);</span>
<a href="#l7.207"></a><span id="l7.207" class="difflineplus">+LDAP_API(LDAPMessage*)</span>
<a href="#l7.208"></a><span id="l7.208" class="difflineplus">+LDAP_CALL ldap_first_entry(LDAP* ld, LDAPMessage* chain);</span>
<a href="#l7.209"></a><span id="l7.209" class="difflineplus">+LDAP_API(LDAPMessage*) LDAP_CALL ldap_next_entry(LDAP* ld, LDAPMessage* entry);</span>
<a href="#l7.210"></a><span id="l7.210" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_count_entries(LDAP* ld, LDAPMessage* chain);</span>
<a href="#l7.211"></a><span id="l7.211" class="difflineplus">+LDAP_API(char*) LDAP_CALL ldap_get_dn(LDAP* ld, LDAPMessage* entry);</span>
<a href="#l7.212"></a><span id="l7.212" class="difflineplus">+LDAP_API(char*) LDAP_CALL ldap_dn2ufn(const char* dn);</span>
<a href="#l7.213"></a><span id="l7.213" class="difflineplus">+LDAP_API(char**) LDAP_CALL ldap_explode_dn(const char* dn, const int notypes);</span>
<a href="#l7.214"></a><span id="l7.214" class="difflineplus">+LDAP_API(char**)</span>
<a href="#l7.215"></a><span id="l7.215" class="difflineplus">+LDAP_CALL ldap_explode_rdn(const char* rdn, const int notypes);</span>
<a href="#l7.216"></a><span id="l7.216" class="difflineplus">+LDAP_API(char*)</span>
<a href="#l7.217"></a><span id="l7.217" class="difflineplus">+LDAP_CALL ldap_first_attribute(LDAP* ld, LDAPMessage* entry, BerElement** ber);</span>
<a href="#l7.218"></a><span id="l7.218" class="difflineplus">+LDAP_API(char*)</span>
<a href="#l7.219"></a><span id="l7.219" class="difflineplus">+LDAP_CALL ldap_next_attribute(LDAP* ld, LDAPMessage* entry, BerElement* ber);</span>
<a href="#l7.220"></a><span id="l7.220" class="difflineplus">+LDAP_API(char**)</span>
<a href="#l7.221"></a><span id="l7.221" class="difflineplus">+LDAP_CALL ldap_get_values(LDAP* ld, LDAPMessage* entry, const char* target);</span>
<a href="#l7.222"></a><span id="l7.222" class="difflineplus">+LDAP_API(struct berval**)</span>
<a href="#l7.223"></a><span id="l7.223" class="difflineplus">+LDAP_CALL ldap_get_values_len(LDAP* ld, LDAPMessage* entry, const char* target);</span>
<a href="#l7.224"></a><span id="l7.224" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_count_values(char** vals);</span>
<a href="#l7.225"></a><span id="l7.225" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_count_values_len(struct berval** vals);</span>
<a href="#l7.226"></a><span id="l7.226" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_value_free(char** vals);</span>
<a href="#l7.227"></a><span id="l7.227" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_value_free_len(struct berval** vals);</span>
<a href="#l7.228"></a><span id="l7.228" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_memfree(void* p);</span>
<a href="#l7.229"></a><span id="l7.229"> </span>
<a href="#l7.230"></a><span id="l7.230"> /*</span>
<a href="#l7.231"></a><span id="l7.231">  * LDAPv3 extended operation calls</span>
<a href="#l7.232"></a><span id="l7.232">  */</span>
<a href="#l7.233"></a><span id="l7.233"> /*</span>
<a href="#l7.234"></a><span id="l7.234">  * Note: all of the new asynchronous calls return an LDAP error code,</span>
<a href="#l7.235"></a><span id="l7.235">  * not a message id.  A message id is returned via the int *msgidp</span>
<a href="#l7.236"></a><span id="l7.236">  * parameter (usually the last parameter) if appropriate.</span>
<a href="#l7.237"></a><span id="l7.237">  */</span>
<a href="#l7.238"></a><span id="l7.238"> LDAP_API(int)</span>
<a href="#l7.239"></a><span id="l7.239" class="difflineminus">-LDAP_CALL ldap_abandon_ext(LDAP *ld, int msgid, LDAPControl **serverctrls,</span>
<a href="#l7.240"></a><span id="l7.240" class="difflineminus">-                           LDAPControl **clientctrls);</span>
<a href="#l7.241"></a><span id="l7.241" class="difflineplus">+LDAP_CALL ldap_abandon_ext(LDAP* ld, int msgid, LDAPControl** serverctrls,</span>
<a href="#l7.242"></a><span id="l7.242" class="difflineplus">+                           LDAPControl** clientctrls);</span>
<a href="#l7.243"></a><span id="l7.243"> LDAP_API(int)</span>
<a href="#l7.244"></a><span id="l7.244" class="difflineminus">-LDAP_CALL ldap_add_ext(LDAP *ld, const char *dn, LDAPMod **attrs,</span>
<a href="#l7.245"></a><span id="l7.245" class="difflineminus">-                       LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l7.246"></a><span id="l7.246" class="difflineminus">-                       int *msgidp);</span>
<a href="#l7.247"></a><span id="l7.247" class="difflineplus">+LDAP_CALL ldap_add_ext(LDAP* ld, const char* dn, LDAPMod** attrs,</span>
<a href="#l7.248"></a><span id="l7.248" class="difflineplus">+                       LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l7.249"></a><span id="l7.249" class="difflineplus">+                       int* msgidp);</span>
<a href="#l7.250"></a><span id="l7.250"> LDAP_API(int)</span>
<a href="#l7.251"></a><span id="l7.251" class="difflineminus">-LDAP_CALL ldap_add_ext_s(LDAP *ld, const char *dn, LDAPMod **attrs,</span>
<a href="#l7.252"></a><span id="l7.252" class="difflineminus">-                         LDAPControl **serverctrls, LDAPControl **clientctrls);</span>
<a href="#l7.253"></a><span id="l7.253" class="difflineplus">+LDAP_CALL ldap_add_ext_s(LDAP* ld, const char* dn, LDAPMod** attrs,</span>
<a href="#l7.254"></a><span id="l7.254" class="difflineplus">+                         LDAPControl** serverctrls, LDAPControl** clientctrls);</span>
<a href="#l7.255"></a><span id="l7.255"> LDAP_API(int)</span>
<a href="#l7.256"></a><span id="l7.256" class="difflineminus">-LDAP_CALL ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,</span>
<a href="#l7.257"></a><span id="l7.257" class="difflineminus">-                         const struct berval *cred, LDAPControl **serverctrls,</span>
<a href="#l7.258"></a><span id="l7.258" class="difflineminus">-                         LDAPControl **clientctrls, int *msgidp);</span>
<a href="#l7.259"></a><span id="l7.259" class="difflineplus">+LDAP_CALL ldap_sasl_bind(LDAP* ld, const char* dn, const char* mechanism,</span>
<a href="#l7.260"></a><span id="l7.260" class="difflineplus">+                         const struct berval* cred, LDAPControl** serverctrls,</span>
<a href="#l7.261"></a><span id="l7.261" class="difflineplus">+                         LDAPControl** clientctrls, int* msgidp);</span>
<a href="#l7.262"></a><span id="l7.262"> LDAP_API(int)</span>
<a href="#l7.263"></a><span id="l7.263"> LDAP_CALL</span>
<a href="#l7.264"></a><span id="l7.264" class="difflineminus">-ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,</span>
<a href="#l7.265"></a><span id="l7.265" class="difflineminus">-                 const struct berval *cred, LDAPControl **serverctrls,</span>
<a href="#l7.266"></a><span id="l7.266" class="difflineminus">-                 LDAPControl **clientctrls, struct berval **servercredp);</span>
<a href="#l7.267"></a><span id="l7.267" class="difflineplus">+ldap_sasl_bind_s(LDAP* ld, const char* dn, const char* mechanism,</span>
<a href="#l7.268"></a><span id="l7.268" class="difflineplus">+                 const struct berval* cred, LDAPControl** serverctrls,</span>
<a href="#l7.269"></a><span id="l7.269" class="difflineplus">+                 LDAPControl** clientctrls, struct berval** servercredp);</span>
<a href="#l7.270"></a><span id="l7.270"> LDAP_API(int)</span>
<a href="#l7.271"></a><span id="l7.271" class="difflineminus">-LDAP_CALL ldap_modify_ext(LDAP *ld, const char *dn, LDAPMod **mods,</span>
<a href="#l7.272"></a><span id="l7.272" class="difflineminus">-                          LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l7.273"></a><span id="l7.273" class="difflineminus">-                          int *msgidp);</span>
<a href="#l7.274"></a><span id="l7.274" class="difflineplus">+LDAP_CALL ldap_modify_ext(LDAP* ld, const char* dn, LDAPMod** mods,</span>
<a href="#l7.275"></a><span id="l7.275" class="difflineplus">+                          LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l7.276"></a><span id="l7.276" class="difflineplus">+                          int* msgidp);</span>
<a href="#l7.277"></a><span id="l7.277"> LDAP_API(int)</span>
<a href="#l7.278"></a><span id="l7.278"> LDAP_CALL</span>
<a href="#l7.279"></a><span id="l7.279" class="difflineminus">-ldap_modify_ext_s(LDAP *ld, const char *dn, LDAPMod **mods,</span>
<a href="#l7.280"></a><span id="l7.280" class="difflineminus">-                  LDAPControl **serverctrls, LDAPControl **clientctrls);</span>
<a href="#l7.281"></a><span id="l7.281" class="difflineplus">+ldap_modify_ext_s(LDAP* ld, const char* dn, LDAPMod** mods,</span>
<a href="#l7.282"></a><span id="l7.282" class="difflineplus">+                  LDAPControl** serverctrls, LDAPControl** clientctrls);</span>
<a href="#l7.283"></a><span id="l7.283"> LDAP_API(int)</span>
<a href="#l7.284"></a><span id="l7.284" class="difflineminus">-LDAP_CALL ldap_rename(LDAP *ld, const char *dn, const char *newrdn,</span>
<a href="#l7.285"></a><span id="l7.285" class="difflineminus">-                      const char *newparent, int deleteoldrdn,</span>
<a href="#l7.286"></a><span id="l7.286" class="difflineminus">-                      LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l7.287"></a><span id="l7.287" class="difflineminus">-                      int *msgidp);</span>
<a href="#l7.288"></a><span id="l7.288" class="difflineplus">+LDAP_CALL ldap_rename(LDAP* ld, const char* dn, const char* newrdn,</span>
<a href="#l7.289"></a><span id="l7.289" class="difflineplus">+                      const char* newparent, int deleteoldrdn,</span>
<a href="#l7.290"></a><span id="l7.290" class="difflineplus">+                      LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l7.291"></a><span id="l7.291" class="difflineplus">+                      int* msgidp);</span>
<a href="#l7.292"></a><span id="l7.292"> LDAP_API(int)</span>
<a href="#l7.293"></a><span id="l7.293" class="difflineminus">-LDAP_CALL ldap_rename_s(LDAP *ld, const char *dn, const char *newrdn,</span>
<a href="#l7.294"></a><span id="l7.294" class="difflineminus">-                        const char *newparent, int deleteoldrdn,</span>
<a href="#l7.295"></a><span id="l7.295" class="difflineminus">-                        LDAPControl **serverctrls, LDAPControl **clientctrls);</span>
<a href="#l7.296"></a><span id="l7.296" class="difflineplus">+LDAP_CALL ldap_rename_s(LDAP* ld, const char* dn, const char* newrdn,</span>
<a href="#l7.297"></a><span id="l7.297" class="difflineplus">+                        const char* newparent, int deleteoldrdn,</span>
<a href="#l7.298"></a><span id="l7.298" class="difflineplus">+                        LDAPControl** serverctrls, LDAPControl** clientctrls);</span>
<a href="#l7.299"></a><span id="l7.299"> LDAP_API(int)</span>
<a href="#l7.300"></a><span id="l7.300"> LDAP_CALL</span>
<a href="#l7.301"></a><span id="l7.301" class="difflineminus">-ldap_compare_ext(LDAP *ld, const char *dn, const char *attr,</span>
<a href="#l7.302"></a><span id="l7.302" class="difflineminus">-                 const struct berval *bvalue, LDAPControl **serverctrls,</span>
<a href="#l7.303"></a><span id="l7.303" class="difflineminus">-                 LDAPControl **clientctrls, int *msgidp);</span>
<a href="#l7.304"></a><span id="l7.304" class="difflineplus">+ldap_compare_ext(LDAP* ld, const char* dn, const char* attr,</span>
<a href="#l7.305"></a><span id="l7.305" class="difflineplus">+                 const struct berval* bvalue, LDAPControl** serverctrls,</span>
<a href="#l7.306"></a><span id="l7.306" class="difflineplus">+                 LDAPControl** clientctrls, int* msgidp);</span>
<a href="#l7.307"></a><span id="l7.307"> LDAP_API(int)</span>
<a href="#l7.308"></a><span id="l7.308"> LDAP_CALL</span>
<a href="#l7.309"></a><span id="l7.309" class="difflineminus">-ldap_compare_ext_s(LDAP *ld, const char *dn, const char *attr,</span>
<a href="#l7.310"></a><span id="l7.310" class="difflineminus">-                   const struct berval *bvalue, LDAPControl **serverctrls,</span>
<a href="#l7.311"></a><span id="l7.311" class="difflineminus">-                   LDAPControl **clientctrls);</span>
<a href="#l7.312"></a><span id="l7.312" class="difflineplus">+ldap_compare_ext_s(LDAP* ld, const char* dn, const char* attr,</span>
<a href="#l7.313"></a><span id="l7.313" class="difflineplus">+                   const struct berval* bvalue, LDAPControl** serverctrls,</span>
<a href="#l7.314"></a><span id="l7.314" class="difflineplus">+                   LDAPControl** clientctrls);</span>
<a href="#l7.315"></a><span id="l7.315"> LDAP_API(int)</span>
<a href="#l7.316"></a><span id="l7.316" class="difflineminus">-LDAP_CALL ldap_delete_ext(LDAP *ld, const char *dn, LDAPControl **serverctrls,</span>
<a href="#l7.317"></a><span id="l7.317" class="difflineminus">-                          LDAPControl **clientctrls, int *msgidp);</span>
<a href="#l7.318"></a><span id="l7.318" class="difflineplus">+LDAP_CALL ldap_delete_ext(LDAP* ld, const char* dn, LDAPControl** serverctrls,</span>
<a href="#l7.319"></a><span id="l7.319" class="difflineplus">+                          LDAPControl** clientctrls, int* msgidp);</span>
<a href="#l7.320"></a><span id="l7.320"> LDAP_API(int)</span>
<a href="#l7.321"></a><span id="l7.321" class="difflineminus">-LDAP_CALL ldap_delete_ext_s(LDAP *ld, const char *dn, LDAPControl **serverctrls,</span>
<a href="#l7.322"></a><span id="l7.322" class="difflineminus">-                            LDAPControl **clientctrls);</span>
<a href="#l7.323"></a><span id="l7.323" class="difflineplus">+LDAP_CALL ldap_delete_ext_s(LDAP* ld, const char* dn, LDAPControl** serverctrls,</span>
<a href="#l7.324"></a><span id="l7.324" class="difflineplus">+                            LDAPControl** clientctrls);</span>
<a href="#l7.325"></a><span id="l7.325"> LDAP_API(int)</span>
<a href="#l7.326"></a><span id="l7.326" class="difflineminus">-LDAP_CALL ldap_search_ext(LDAP *ld, const char *base, int scope,</span>
<a href="#l7.327"></a><span id="l7.327" class="difflineminus">-                          const char *filter, char **attrs, int attrsonly,</span>
<a href="#l7.328"></a><span id="l7.328" class="difflineminus">-                          LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l7.329"></a><span id="l7.329" class="difflineminus">-                          struct timeval *timeoutp, int sizelimit, int *msgidp);</span>
<a href="#l7.330"></a><span id="l7.330" class="difflineplus">+LDAP_CALL ldap_search_ext(LDAP* ld, const char* base, int scope,</span>
<a href="#l7.331"></a><span id="l7.331" class="difflineplus">+                          const char* filter, char** attrs, int attrsonly,</span>
<a href="#l7.332"></a><span id="l7.332" class="difflineplus">+                          LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l7.333"></a><span id="l7.333" class="difflineplus">+                          struct timeval* timeoutp, int sizelimit, int* msgidp);</span>
<a href="#l7.334"></a><span id="l7.334"> LDAP_API(int)</span>
<a href="#l7.335"></a><span id="l7.335"> LDAP_CALL</span>
<a href="#l7.336"></a><span id="l7.336" class="difflineminus">-ldap_search_ext_s(LDAP *ld, const char *base, int scope, const char *filter,</span>
<a href="#l7.337"></a><span id="l7.337" class="difflineminus">-                  char **attrs, int attrsonly, LDAPControl **serverctrls,</span>
<a href="#l7.338"></a><span id="l7.338" class="difflineminus">-                  LDAPControl **clientctrls, struct timeval *timeoutp,</span>
<a href="#l7.339"></a><span id="l7.339" class="difflineminus">-                  int sizelimit, LDAPMessage **res);</span>
<a href="#l7.340"></a><span id="l7.340" class="difflineplus">+ldap_search_ext_s(LDAP* ld, const char* base, int scope, const char* filter,</span>
<a href="#l7.341"></a><span id="l7.341" class="difflineplus">+                  char** attrs, int attrsonly, LDAPControl** serverctrls,</span>
<a href="#l7.342"></a><span id="l7.342" class="difflineplus">+                  LDAPControl** clientctrls, struct timeval* timeoutp,</span>
<a href="#l7.343"></a><span id="l7.343" class="difflineplus">+                  int sizelimit, LDAPMessage** res);</span>
<a href="#l7.344"></a><span id="l7.344"> LDAP_API(int)</span>
<a href="#l7.345"></a><span id="l7.345" class="difflineminus">-LDAP_CALL ldap_extended_operation(LDAP *ld, const char *requestoid,</span>
<a href="#l7.346"></a><span id="l7.346" class="difflineminus">-                                  const struct berval *requestdata,</span>
<a href="#l7.347"></a><span id="l7.347" class="difflineminus">-                                  LDAPControl **serverctrls,</span>
<a href="#l7.348"></a><span id="l7.348" class="difflineminus">-                                  LDAPControl **clientctrls, int *msgidp);</span>
<a href="#l7.349"></a><span id="l7.349" class="difflineplus">+LDAP_CALL ldap_extended_operation(LDAP* ld, const char* requestoid,</span>
<a href="#l7.350"></a><span id="l7.350" class="difflineplus">+                                  const struct berval* requestdata,</span>
<a href="#l7.351"></a><span id="l7.351" class="difflineplus">+                                  LDAPControl** serverctrls,</span>
<a href="#l7.352"></a><span id="l7.352" class="difflineplus">+                                  LDAPControl** clientctrls, int* msgidp);</span>
<a href="#l7.353"></a><span id="l7.353"> LDAP_API(int)</span>
<a href="#l7.354"></a><span id="l7.354" class="difflineminus">-LDAP_CALL ldap_extended_operation_s(LDAP *ld, const char *requestoid,</span>
<a href="#l7.355"></a><span id="l7.355" class="difflineminus">-                                    const struct berval *requestdata,</span>
<a href="#l7.356"></a><span id="l7.356" class="difflineminus">-                                    LDAPControl **serverctrls,</span>
<a href="#l7.357"></a><span id="l7.357" class="difflineminus">-                                    LDAPControl **clientctrls, char **retoidp,</span>
<a href="#l7.358"></a><span id="l7.358" class="difflineminus">-                                    struct berval **retdatap);</span>
<a href="#l7.359"></a><span id="l7.359" class="difflineplus">+LDAP_CALL ldap_extended_operation_s(LDAP* ld, const char* requestoid,</span>
<a href="#l7.360"></a><span id="l7.360" class="difflineplus">+                                    const struct berval* requestdata,</span>
<a href="#l7.361"></a><span id="l7.361" class="difflineplus">+                                    LDAPControl** serverctrls,</span>
<a href="#l7.362"></a><span id="l7.362" class="difflineplus">+                                    LDAPControl** clientctrls, char** retoidp,</span>
<a href="#l7.363"></a><span id="l7.363" class="difflineplus">+                                    struct berval** retdatap);</span>
<a href="#l7.364"></a><span id="l7.364"> LDAP_API(int)</span>
<a href="#l7.365"></a><span id="l7.365" class="difflineminus">-LDAP_CALL ldap_unbind_ext(LDAP *ld, LDAPControl **serverctrls,</span>
<a href="#l7.366"></a><span id="l7.366" class="difflineminus">-                          LDAPControl **clientctrls);</span>
<a href="#l7.367"></a><span id="l7.367" class="difflineplus">+LDAP_CALL ldap_unbind_ext(LDAP* ld, LDAPControl** serverctrls,</span>
<a href="#l7.368"></a><span id="l7.368" class="difflineplus">+                          LDAPControl** clientctrls);</span>
<a href="#l7.369"></a><span id="l7.369"> </span>
<a href="#l7.370"></a><span id="l7.370"> /*</span>
<a href="#l7.371"></a><span id="l7.371">  * LDAPv3 extended parsing / result handling calls</span>
<a href="#l7.372"></a><span id="l7.372">  */</span>
<a href="#l7.373"></a><span id="l7.373"> LDAP_API(int)</span>
<a href="#l7.374"></a><span id="l7.374" class="difflineminus">-LDAP_CALL ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,</span>
<a href="#l7.375"></a><span id="l7.375" class="difflineminus">-                                      struct berval **servercredp, int freeit);</span>
<a href="#l7.376"></a><span id="l7.376" class="difflineplus">+LDAP_CALL ldap_parse_sasl_bind_result(LDAP* ld, LDAPMessage* res,</span>
<a href="#l7.377"></a><span id="l7.377" class="difflineplus">+                                      struct berval** servercredp, int freeit);</span>
<a href="#l7.378"></a><span id="l7.378"> LDAP_API(int)</span>
<a href="#l7.379"></a><span id="l7.379"> LDAP_CALL</span>
<a href="#l7.380"></a><span id="l7.380" class="difflineminus">-ldap_parse_result(LDAP *ld, LDAPMessage *res, int *errcodep, char **matcheddnp,</span>
<a href="#l7.381"></a><span id="l7.381" class="difflineminus">-                  char **errmsgp, char ***referralsp,</span>
<a href="#l7.382"></a><span id="l7.382" class="difflineminus">-                  LDAPControl ***serverctrlsp, int freeit);</span>
<a href="#l7.383"></a><span id="l7.383" class="difflineplus">+ldap_parse_result(LDAP* ld, LDAPMessage* res, int* errcodep, char** matcheddnp,</span>
<a href="#l7.384"></a><span id="l7.384" class="difflineplus">+                  char** errmsgp, char*** referralsp,</span>
<a href="#l7.385"></a><span id="l7.385" class="difflineplus">+                  LDAPControl*** serverctrlsp, int freeit);</span>
<a href="#l7.386"></a><span id="l7.386"> LDAP_API(int)</span>
<a href="#l7.387"></a><span id="l7.387" class="difflineminus">-LDAP_CALL ldap_parse_extended_result(LDAP *ld, LDAPMessage *res, char **retoidp,</span>
<a href="#l7.388"></a><span id="l7.388" class="difflineminus">-                                     struct berval **retdatap, int freeit);</span>
<a href="#l7.389"></a><span id="l7.389" class="difflineminus">-LDAP_API(LDAPMessage *)</span>
<a href="#l7.390"></a><span id="l7.390" class="difflineminus">-LDAP_CALL ldap_first_message(LDAP *ld, LDAPMessage *res);</span>
<a href="#l7.391"></a><span id="l7.391" class="difflineminus">-LDAP_API(LDAPMessage *) LDAP_CALL ldap_next_message(LDAP *ld, LDAPMessage *msg);</span>
<a href="#l7.392"></a><span id="l7.392" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_count_messages(LDAP *ld, LDAPMessage *res);</span>
<a href="#l7.393"></a><span id="l7.393" class="difflineminus">-LDAP_API(LDAPMessage *)</span>
<a href="#l7.394"></a><span id="l7.394" class="difflineminus">-LDAP_CALL ldap_first_reference(LDAP *ld, LDAPMessage *res);</span>
<a href="#l7.395"></a><span id="l7.395" class="difflineminus">-LDAP_API(LDAPMessage *)</span>
<a href="#l7.396"></a><span id="l7.396" class="difflineminus">-LDAP_CALL ldap_next_reference(LDAP *ld, LDAPMessage *ref);</span>
<a href="#l7.397"></a><span id="l7.397" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_count_references(LDAP *ld, LDAPMessage *res);</span>
<a href="#l7.398"></a><span id="l7.398" class="difflineplus">+LDAP_CALL ldap_parse_extended_result(LDAP* ld, LDAPMessage* res, char** retoidp,</span>
<a href="#l7.399"></a><span id="l7.399" class="difflineplus">+                                     struct berval** retdatap, int freeit);</span>
<a href="#l7.400"></a><span id="l7.400" class="difflineplus">+LDAP_API(LDAPMessage*)</span>
<a href="#l7.401"></a><span id="l7.401" class="difflineplus">+LDAP_CALL ldap_first_message(LDAP* ld, LDAPMessage* res);</span>
<a href="#l7.402"></a><span id="l7.402" class="difflineplus">+LDAP_API(LDAPMessage*) LDAP_CALL ldap_next_message(LDAP* ld, LDAPMessage* msg);</span>
<a href="#l7.403"></a><span id="l7.403" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_count_messages(LDAP* ld, LDAPMessage* res);</span>
<a href="#l7.404"></a><span id="l7.404" class="difflineplus">+LDAP_API(LDAPMessage*)</span>
<a href="#l7.405"></a><span id="l7.405" class="difflineplus">+LDAP_CALL ldap_first_reference(LDAP* ld, LDAPMessage* res);</span>
<a href="#l7.406"></a><span id="l7.406" class="difflineplus">+LDAP_API(LDAPMessage*)</span>
<a href="#l7.407"></a><span id="l7.407" class="difflineplus">+LDAP_CALL ldap_next_reference(LDAP* ld, LDAPMessage* ref);</span>
<a href="#l7.408"></a><span id="l7.408" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_count_references(LDAP* ld, LDAPMessage* res);</span>
<a href="#l7.409"></a><span id="l7.409"> LDAP_API(int)</span>
<a href="#l7.410"></a><span id="l7.410" class="difflineminus">-LDAP_CALL ldap_parse_reference(LDAP *ld, LDAPMessage *ref, char ***referralsp,</span>
<a href="#l7.411"></a><span id="l7.411" class="difflineminus">-                               LDAPControl ***serverctrlsp, int freeit);</span>
<a href="#l7.412"></a><span id="l7.412" class="difflineplus">+LDAP_CALL ldap_parse_reference(LDAP* ld, LDAPMessage* ref, char*** referralsp,</span>
<a href="#l7.413"></a><span id="l7.413" class="difflineplus">+                               LDAPControl*** serverctrlsp, int freeit);</span>
<a href="#l7.414"></a><span id="l7.414"> LDAP_API(int)</span>
<a href="#l7.415"></a><span id="l7.415" class="difflineminus">-LDAP_CALL ldap_get_entry_controls(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l7.416"></a><span id="l7.416" class="difflineminus">-                                  LDAPControl ***serverctrlsp);</span>
<a href="#l7.417"></a><span id="l7.417" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_control_free(LDAPControl *ctrl);</span>
<a href="#l7.418"></a><span id="l7.418" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_controls_free(LDAPControl **ctrls);</span>
<a href="#l7.419"></a><span id="l7.419" class="difflineplus">+LDAP_CALL ldap_get_entry_controls(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l7.420"></a><span id="l7.420" class="difflineplus">+                                  LDAPControl*** serverctrlsp);</span>
<a href="#l7.421"></a><span id="l7.421" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_control_free(LDAPControl* ctrl);</span>
<a href="#l7.422"></a><span id="l7.422" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_controls_free(LDAPControl** ctrls);</span>
<a href="#l7.423"></a><span id="l7.423"> </span>
<a href="#l7.424"></a><span id="l7.424"> #ifdef __cplusplus</span>
<a href="#l7.425"></a><span id="l7.425"> }</span>
<a href="#l7.426"></a><span id="l7.426"> #endif</span>
<a href="#l7.427"></a><span id="l7.427"> #endif /* _LDAP_STANDARD_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/ldap/c-sdk/include/ldap-to-be-deprecated.h</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/ldap/c-sdk/include/ldap-to-be-deprecated.h</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -64,137 +64,137 @@ extern &quot;C&quot; {</span>
<a href="#l8.4"></a><span id="l8.4">  */</span>
<a href="#l8.5"></a><span id="l8.5"> #define LDAP_OPT_IO_FN_PTRS 0x0B /* 11 - API extension */</span>
<a href="#l8.6"></a><span id="l8.6"> </span>
<a href="#l8.7"></a><span id="l8.7"> /*</span>
<a href="#l8.8"></a><span id="l8.8">  * I/O callback functions (note that types for the read and write callbacks</span>
<a href="#l8.9"></a><span id="l8.9">  * are actually in lber.h):</span>
<a href="#l8.10"></a><span id="l8.10">  */</span>
<a href="#l8.11"></a><span id="l8.11"> typedef int(LDAP_C LDAP_CALLBACK LDAP_IOF_SELECT_CALLBACK)(</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-    int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds,</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">-    struct timeval *timeout);</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+    int nfds, fd_set* readfds, fd_set* writefds, fd_set* errorfds,</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+    struct timeval* timeout);</span>
<a href="#l8.16"></a><span id="l8.16"> typedef LBER_SOCKET(LDAP_C LDAP_CALLBACK LDAP_IOF_SOCKET_CALLBACK)(</span>
<a href="#l8.17"></a><span id="l8.17">     int domain, int type, int protocol);</span>
<a href="#l8.18"></a><span id="l8.18"> typedef int(LDAP_C LDAP_CALLBACK LDAP_IOF_IOCTL_CALLBACK)(LBER_SOCKET s,</span>
<a href="#l8.19"></a><span id="l8.19">                                                           int option, ...);</span>
<a href="#l8.20"></a><span id="l8.20"> typedef int(LDAP_C LDAP_CALLBACK LDAP_IOF_CONNECT_CALLBACK)(</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineminus">-    LBER_SOCKET s, struct sockaddr *name, int namelen);</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+    LBER_SOCKET s, struct sockaddr* name, int namelen);</span>
<a href="#l8.23"></a><span id="l8.23"> typedef int(LDAP_C LDAP_CALLBACK LDAP_IOF_CLOSE_CALLBACK)(LBER_SOCKET s);</span>
<a href="#l8.24"></a><span id="l8.24"> typedef int(LDAP_C LDAP_CALLBACK LDAP_IOF_SSL_ENABLE_CALLBACK)(LBER_SOCKET s);</span>
<a href="#l8.25"></a><span id="l8.25"> </span>
<a href="#l8.26"></a><span id="l8.26"> /*</span>
<a href="#l8.27"></a><span id="l8.27">  * Structure to hold I/O function pointers:</span>
<a href="#l8.28"></a><span id="l8.28">  */</span>
<a href="#l8.29"></a><span id="l8.29"> struct ldap_io_fns {</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineminus">-  LDAP_IOF_READ_CALLBACK *liof_read;</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineminus">-  LDAP_IOF_WRITE_CALLBACK *liof_write;</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineminus">-  LDAP_IOF_SELECT_CALLBACK *liof_select;</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineminus">-  LDAP_IOF_SOCKET_CALLBACK *liof_socket;</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineminus">-  LDAP_IOF_IOCTL_CALLBACK *liof_ioctl;</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineminus">-  LDAP_IOF_CONNECT_CALLBACK *liof_connect;</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineminus">-  LDAP_IOF_CLOSE_CALLBACK *liof_close;</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineminus">-  LDAP_IOF_SSL_ENABLE_CALLBACK *liof_ssl_enable;</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+  LDAP_IOF_READ_CALLBACK* liof_read;</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+  LDAP_IOF_WRITE_CALLBACK* liof_write;</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineplus">+  LDAP_IOF_SELECT_CALLBACK* liof_select;</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+  LDAP_IOF_SOCKET_CALLBACK* liof_socket;</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineplus">+  LDAP_IOF_IOCTL_CALLBACK* liof_ioctl;</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineplus">+  LDAP_IOF_CONNECT_CALLBACK* liof_connect;</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+  LDAP_IOF_CLOSE_CALLBACK* liof_close;</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineplus">+  LDAP_IOF_SSL_ENABLE_CALLBACK* liof_ssl_enable;</span>
<a href="#l8.46"></a><span id="l8.46"> };</span>
<a href="#l8.47"></a><span id="l8.47"> </span>
<a href="#l8.48"></a><span id="l8.48"> /*</span>
<a href="#l8.49"></a><span id="l8.49">  * DNS resolver callbacks (an API extension --LDAP_API_FEATURE_X_DNS_FUNCTIONS).</span>
<a href="#l8.50"></a><span id="l8.50">  * Note that gethostbyaddr() is not currently used.</span>
<a href="#l8.51"></a><span id="l8.51">  */</span>
<a href="#l8.52"></a><span id="l8.52"> #define LDAP_OPT_DNS_FN_PTRS 0x60 /* 96 - API extension */</span>
<a href="#l8.53"></a><span id="l8.53"> </span>
<a href="#l8.54"></a><span id="l8.54"> typedef struct LDAPHostEnt {</span>
<a href="#l8.55"></a><span id="l8.55" class="difflineminus">-  char *ldaphe_name;       /* official name of host */</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineminus">-  char **ldaphe_aliases;   /* alias list */</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineplus">+  char* ldaphe_name;       /* official name of host */</span>
<a href="#l8.58"></a><span id="l8.58" class="difflineplus">+  char** ldaphe_aliases;   /* alias list */</span>
<a href="#l8.59"></a><span id="l8.59">   int ldaphe_addrtype;     /* host address type */</span>
<a href="#l8.60"></a><span id="l8.60">   int ldaphe_length;       /* length of address */</span>
<a href="#l8.61"></a><span id="l8.61" class="difflineminus">-  char **ldaphe_addr_list; /* list of addresses from name server */</span>
<a href="#l8.62"></a><span id="l8.62" class="difflineplus">+  char** ldaphe_addr_list; /* list of addresses from name server */</span>
<a href="#l8.63"></a><span id="l8.63"> } LDAPHostEnt;</span>
<a href="#l8.64"></a><span id="l8.64"> </span>
<a href="#l8.65"></a><span id="l8.65" class="difflineminus">-typedef LDAPHostEnt *(LDAP_C LDAP_CALLBACK LDAP_DNSFN_GETHOSTBYNAME)(</span>
<a href="#l8.66"></a><span id="l8.66" class="difflineminus">-    const char *name, LDAPHostEnt *result, char *buffer, int buflen,</span>
<a href="#l8.67"></a><span id="l8.67" class="difflineminus">-    int *statusp, void *extradata);</span>
<a href="#l8.68"></a><span id="l8.68" class="difflineminus">-typedef LDAPHostEnt *(LDAP_C LDAP_CALLBACK LDAP_DNSFN_GETHOSTBYADDR)(</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineminus">-    const char *addr, int length, int type, LDAPHostEnt *result, char *buffer,</span>
<a href="#l8.70"></a><span id="l8.70" class="difflineminus">-    int buflen, int *statusp, void *extradata);</span>
<a href="#l8.71"></a><span id="l8.71" class="difflineplus">+typedef LDAPHostEnt*(LDAP_C LDAP_CALLBACK LDAP_DNSFN_GETHOSTBYNAME)(</span>
<a href="#l8.72"></a><span id="l8.72" class="difflineplus">+    const char* name, LDAPHostEnt* result, char* buffer, int buflen,</span>
<a href="#l8.73"></a><span id="l8.73" class="difflineplus">+    int* statusp, void* extradata);</span>
<a href="#l8.74"></a><span id="l8.74" class="difflineplus">+typedef LDAPHostEnt*(LDAP_C LDAP_CALLBACK LDAP_DNSFN_GETHOSTBYADDR)(</span>
<a href="#l8.75"></a><span id="l8.75" class="difflineplus">+    const char* addr, int length, int type, LDAPHostEnt* result, char* buffer,</span>
<a href="#l8.76"></a><span id="l8.76" class="difflineplus">+    int buflen, int* statusp, void* extradata);</span>
<a href="#l8.77"></a><span id="l8.77"> typedef int(LDAP_C LDAP_CALLBACK LDAP_DNSFN_GETPEERNAME)(</span>
<a href="#l8.78"></a><span id="l8.78" class="difflineminus">-    LDAP *ld, struct sockaddr *netaddr, char *buffer, int buflen);</span>
<a href="#l8.79"></a><span id="l8.79" class="difflineplus">+    LDAP* ld, struct sockaddr* netaddr, char* buffer, int buflen);</span>
<a href="#l8.80"></a><span id="l8.80"> </span>
<a href="#l8.81"></a><span id="l8.81"> struct ldap_dns_fns {</span>
<a href="#l8.82"></a><span id="l8.82" class="difflineminus">-  void *lddnsfn_extradata;</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineplus">+  void* lddnsfn_extradata;</span>
<a href="#l8.84"></a><span id="l8.84">   int lddnsfn_bufsize;</span>
<a href="#l8.85"></a><span id="l8.85" class="difflineminus">-  LDAP_DNSFN_GETHOSTBYNAME *lddnsfn_gethostbyname;</span>
<a href="#l8.86"></a><span id="l8.86" class="difflineminus">-  LDAP_DNSFN_GETHOSTBYADDR *lddnsfn_gethostbyaddr;</span>
<a href="#l8.87"></a><span id="l8.87" class="difflineminus">-  LDAP_DNSFN_GETPEERNAME *lddnsfn_getpeername;</span>
<a href="#l8.88"></a><span id="l8.88" class="difflineplus">+  LDAP_DNSFN_GETHOSTBYNAME* lddnsfn_gethostbyname;</span>
<a href="#l8.89"></a><span id="l8.89" class="difflineplus">+  LDAP_DNSFN_GETHOSTBYADDR* lddnsfn_gethostbyaddr;</span>
<a href="#l8.90"></a><span id="l8.90" class="difflineplus">+  LDAP_DNSFN_GETPEERNAME* lddnsfn_getpeername;</span>
<a href="#l8.91"></a><span id="l8.91"> };</span>
<a href="#l8.92"></a><span id="l8.92"> </span>
<a href="#l8.93"></a><span id="l8.93"> /*</span>
<a href="#l8.94"></a><span id="l8.94">  * experimental DN format support</span>
<a href="#l8.95"></a><span id="l8.95">  */</span>
<a href="#l8.96"></a><span id="l8.96" class="difflineminus">-LDAP_API(char **) LDAP_CALL ldap_explode_dns(const char *dn);</span>
<a href="#l8.97"></a><span id="l8.97" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_is_dns_dn(const char *dn);</span>
<a href="#l8.98"></a><span id="l8.98" class="difflineplus">+LDAP_API(char**) LDAP_CALL ldap_explode_dns(const char* dn);</span>
<a href="#l8.99"></a><span id="l8.99" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_is_dns_dn(const char* dn);</span>
<a href="#l8.100"></a><span id="l8.100"> </span>
<a href="#l8.101"></a><span id="l8.101"> /*</span>
<a href="#l8.102"></a><span id="l8.102">  * user friendly naming/searching routines</span>
<a href="#l8.103"></a><span id="l8.103">  */</span>
<a href="#l8.104"></a><span id="l8.104" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_CANCELPROC_CALLBACK)(void *cl);</span>
<a href="#l8.105"></a><span id="l8.105" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_CANCELPROC_CALLBACK)(void* cl);</span>
<a href="#l8.106"></a><span id="l8.106"> LDAP_API(int)</span>
<a href="#l8.107"></a><span id="l8.107"> LDAP_CALL</span>
<a href="#l8.108"></a><span id="l8.108" class="difflineminus">-ldap_ufn_search_c(LDAP *ld, char *ufn, char **attrs, int attrsonly,</span>
<a href="#l8.109"></a><span id="l8.109" class="difflineminus">-                  LDAPMessage **res, LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l8.110"></a><span id="l8.110" class="difflineminus">-                  void *cancelparm);</span>
<a href="#l8.111"></a><span id="l8.111" class="difflineplus">+ldap_ufn_search_c(LDAP* ld, char* ufn, char** attrs, int attrsonly,</span>
<a href="#l8.112"></a><span id="l8.112" class="difflineplus">+                  LDAPMessage** res, LDAP_CANCELPROC_CALLBACK* cancelproc,</span>
<a href="#l8.113"></a><span id="l8.113" class="difflineplus">+                  void* cancelparm);</span>
<a href="#l8.114"></a><span id="l8.114"> LDAP_API(int)</span>
<a href="#l8.115"></a><span id="l8.115"> LDAP_CALL</span>
<a href="#l8.116"></a><span id="l8.116" class="difflineminus">-ldap_ufn_search_ct(LDAP *ld, char *ufn, char **attrs, int attrsonly,</span>
<a href="#l8.117"></a><span id="l8.117" class="difflineminus">-                   LDAPMessage **res, LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l8.118"></a><span id="l8.118" class="difflineminus">-                   void *cancelparm, char *tag1, char *tag2, char *tag3);</span>
<a href="#l8.119"></a><span id="l8.119" class="difflineplus">+ldap_ufn_search_ct(LDAP* ld, char* ufn, char** attrs, int attrsonly,</span>
<a href="#l8.120"></a><span id="l8.120" class="difflineplus">+                   LDAPMessage** res, LDAP_CANCELPROC_CALLBACK* cancelproc,</span>
<a href="#l8.121"></a><span id="l8.121" class="difflineplus">+                   void* cancelparm, char* tag1, char* tag2, char* tag3);</span>
<a href="#l8.122"></a><span id="l8.122"> LDAP_API(int)</span>
<a href="#l8.123"></a><span id="l8.123" class="difflineminus">-LDAP_CALL ldap_ufn_search_s(LDAP *ld, char *ufn, char **attrs, int attrsonly,</span>
<a href="#l8.124"></a><span id="l8.124" class="difflineminus">-                            LDAPMessage **res);</span>
<a href="#l8.125"></a><span id="l8.125" class="difflineminus">-LDAP_API(LDAPFiltDesc *) LDAP_CALL ldap_ufn_setfilter(LDAP *ld, char *fname);</span>
<a href="#l8.126"></a><span id="l8.126" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_ufn_setprefix(LDAP *ld, char *prefix);</span>
<a href="#l8.127"></a><span id="l8.127" class="difflineminus">-LDAP_API(int) LDAP_C ldap_ufn_timeout(void *tvparam);</span>
<a href="#l8.128"></a><span id="l8.128" class="difflineplus">+LDAP_CALL ldap_ufn_search_s(LDAP* ld, char* ufn, char** attrs, int attrsonly,</span>
<a href="#l8.129"></a><span id="l8.129" class="difflineplus">+                            LDAPMessage** res);</span>
<a href="#l8.130"></a><span id="l8.130" class="difflineplus">+LDAP_API(LDAPFiltDesc*) LDAP_CALL ldap_ufn_setfilter(LDAP* ld, char* fname);</span>
<a href="#l8.131"></a><span id="l8.131" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_ufn_setprefix(LDAP* ld, char* prefix);</span>
<a href="#l8.132"></a><span id="l8.132" class="difflineplus">+LDAP_API(int) LDAP_C ldap_ufn_timeout(void* tvparam);</span>
<a href="#l8.133"></a><span id="l8.133"> </span>
<a href="#l8.134"></a><span id="l8.134"> /*</span>
<a href="#l8.135"></a><span id="l8.135">  * utility routines</span>
<a href="#l8.136"></a><span id="l8.136">  */</span>
<a href="#l8.137"></a><span id="l8.137" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_charray_add(char ***a, char *s);</span>
<a href="#l8.138"></a><span id="l8.138" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_charray_merge(char ***a, char **s);</span>
<a href="#l8.139"></a><span id="l8.139" class="difflineminus">-LDAP_API(void) LDAP_CALL ldap_charray_free(char **array);</span>
<a href="#l8.140"></a><span id="l8.140" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_charray_inlist(char **a, char *s);</span>
<a href="#l8.141"></a><span id="l8.141" class="difflineminus">-LDAP_API(char **) LDAP_CALL ldap_charray_dup(char **a);</span>
<a href="#l8.142"></a><span id="l8.142" class="difflineminus">-LDAP_API(char **) LDAP_CALL ldap_str2charray(char *str, char *brkstr);</span>
<a href="#l8.143"></a><span id="l8.143" class="difflineminus">-LDAP_API(int) LDAP_CALL ldap_charray_position(char **a, char *s);</span>
<a href="#l8.144"></a><span id="l8.144" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_charray_add(char*** a, char* s);</span>
<a href="#l8.145"></a><span id="l8.145" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_charray_merge(char*** a, char** s);</span>
<a href="#l8.146"></a><span id="l8.146" class="difflineplus">+LDAP_API(void) LDAP_CALL ldap_charray_free(char** array);</span>
<a href="#l8.147"></a><span id="l8.147" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_charray_inlist(char** a, char* s);</span>
<a href="#l8.148"></a><span id="l8.148" class="difflineplus">+LDAP_API(char**) LDAP_CALL ldap_charray_dup(char** a);</span>
<a href="#l8.149"></a><span id="l8.149" class="difflineplus">+LDAP_API(char**) LDAP_CALL ldap_str2charray(char* str, char* brkstr);</span>
<a href="#l8.150"></a><span id="l8.150" class="difflineplus">+LDAP_API(int) LDAP_CALL ldap_charray_position(char** a, char* s);</span>
<a href="#l8.151"></a><span id="l8.151"> </span>
<a href="#l8.152"></a><span id="l8.152"> /* from ldap_ssl.h - the pkcs function and declaration */</span>
<a href="#l8.153"></a><span id="l8.153"> typedef int(LDAP_C LDAP_CALLBACK LDAP_PKCS_GET_TOKEN_CALLBACK)(</span>
<a href="#l8.154"></a><span id="l8.154" class="difflineminus">-    void *context, char **tokenname);</span>
<a href="#l8.155"></a><span id="l8.155" class="difflineplus">+    void* context, char** tokenname);</span>
<a href="#l8.156"></a><span id="l8.156"> typedef int(LDAP_C LDAP_CALLBACK LDAP_PKCS_GET_PIN_CALLBACK)(</span>
<a href="#l8.157"></a><span id="l8.157" class="difflineminus">-    void *context, const char *tokenname, char **tokenpin);</span>
<a href="#l8.158"></a><span id="l8.158" class="difflineplus">+    void* context, const char* tokenname, char** tokenpin);</span>
<a href="#l8.159"></a><span id="l8.159"> typedef int(LDAP_C LDAP_CALLBACK LDAP_PKCS_GET_CERTPATH_CALLBACK)(</span>
<a href="#l8.160"></a><span id="l8.160" class="difflineminus">-    void *context, char **certpath);</span>
<a href="#l8.161"></a><span id="l8.161" class="difflineplus">+    void* context, char** certpath);</span>
<a href="#l8.162"></a><span id="l8.162"> typedef int(LDAP_C LDAP_CALLBACK LDAP_PKCS_GET_KEYPATH_CALLBACK)(</span>
<a href="#l8.163"></a><span id="l8.163" class="difflineminus">-    void *context, char **keypath);</span>
<a href="#l8.164"></a><span id="l8.164" class="difflineplus">+    void* context, char** keypath);</span>
<a href="#l8.165"></a><span id="l8.165"> typedef int(LDAP_C LDAP_CALLBACK LDAP_PKCS_GET_MODPATH_CALLBACK)(</span>
<a href="#l8.166"></a><span id="l8.166" class="difflineminus">-    void *context, char **modulepath);</span>
<a href="#l8.167"></a><span id="l8.167" class="difflineplus">+    void* context, char** modulepath);</span>
<a href="#l8.168"></a><span id="l8.168"> typedef int(LDAP_C LDAP_CALLBACK LDAP_PKCS_GET_CERTNAME_CALLBACK)(</span>
<a href="#l8.169"></a><span id="l8.169" class="difflineminus">-    void *context, char **certname);</span>
<a href="#l8.170"></a><span id="l8.170" class="difflineplus">+    void* context, char** certname);</span>
<a href="#l8.171"></a><span id="l8.171"> typedef int(LDAP_C LDAP_CALLBACK LDAP_PKCS_GET_DONGLEFILENAME_CALLBACK)(</span>
<a href="#l8.172"></a><span id="l8.172" class="difflineminus">-    void *context, char **filename);</span>
<a href="#l8.173"></a><span id="l8.173" class="difflineplus">+    void* context, char** filename);</span>
<a href="#l8.174"></a><span id="l8.174"> </span>
<a href="#l8.175"></a><span id="l8.175"> #define PKCS_STRUCTURE_ID 1</span>
<a href="#l8.176"></a><span id="l8.176"> struct ldapssl_pkcs_fns {</span>
<a href="#l8.177"></a><span id="l8.177">   int local_structure_id;</span>
<a href="#l8.178"></a><span id="l8.178" class="difflineminus">-  void *local_data;</span>
<a href="#l8.179"></a><span id="l8.179" class="difflineminus">-  LDAP_PKCS_GET_CERTPATH_CALLBACK *pkcs_getcertpath;</span>
<a href="#l8.180"></a><span id="l8.180" class="difflineminus">-  LDAP_PKCS_GET_CERTNAME_CALLBACK *pkcs_getcertname;</span>
<a href="#l8.181"></a><span id="l8.181" class="difflineminus">-  LDAP_PKCS_GET_KEYPATH_CALLBACK *pkcs_getkeypath;</span>
<a href="#l8.182"></a><span id="l8.182" class="difflineminus">-  LDAP_PKCS_GET_MODPATH_CALLBACK *pkcs_getmodpath;</span>
<a href="#l8.183"></a><span id="l8.183" class="difflineminus">-  LDAP_PKCS_GET_PIN_CALLBACK *pkcs_getpin;</span>
<a href="#l8.184"></a><span id="l8.184" class="difflineminus">-  LDAP_PKCS_GET_TOKEN_CALLBACK *pkcs_gettokenname;</span>
<a href="#l8.185"></a><span id="l8.185" class="difflineminus">-  LDAP_PKCS_GET_DONGLEFILENAME_CALLBACK *pkcs_getdonglefilename;</span>
<a href="#l8.186"></a><span id="l8.186" class="difflineplus">+  void* local_data;</span>
<a href="#l8.187"></a><span id="l8.187" class="difflineplus">+  LDAP_PKCS_GET_CERTPATH_CALLBACK* pkcs_getcertpath;</span>
<a href="#l8.188"></a><span id="l8.188" class="difflineplus">+  LDAP_PKCS_GET_CERTNAME_CALLBACK* pkcs_getcertname;</span>
<a href="#l8.189"></a><span id="l8.189" class="difflineplus">+  LDAP_PKCS_GET_KEYPATH_CALLBACK* pkcs_getkeypath;</span>
<a href="#l8.190"></a><span id="l8.190" class="difflineplus">+  LDAP_PKCS_GET_MODPATH_CALLBACK* pkcs_getmodpath;</span>
<a href="#l8.191"></a><span id="l8.191" class="difflineplus">+  LDAP_PKCS_GET_PIN_CALLBACK* pkcs_getpin;</span>
<a href="#l8.192"></a><span id="l8.192" class="difflineplus">+  LDAP_PKCS_GET_TOKEN_CALLBACK* pkcs_gettokenname;</span>
<a href="#l8.193"></a><span id="l8.193" class="difflineplus">+  LDAP_PKCS_GET_DONGLEFILENAME_CALLBACK* pkcs_getdonglefilename;</span>
<a href="#l8.194"></a><span id="l8.194"> };</span>
<a href="#l8.195"></a><span id="l8.195"> </span>
<a href="#l8.196"></a><span id="l8.196" class="difflineminus">-LDAP_API(int) LDAP_CALL ldapssl_pkcs_init(const struct ldapssl_pkcs_fns *pfns);</span>
<a href="#l8.197"></a><span id="l8.197" class="difflineplus">+LDAP_API(int) LDAP_CALL ldapssl_pkcs_init(const struct ldapssl_pkcs_fns* pfns);</span>
<a href="#l8.198"></a><span id="l8.198"> </span>
<a href="#l8.199"></a><span id="l8.199"> #ifdef __cplusplus</span>
<a href="#l8.200"></a><span id="l8.200"> }</span>
<a href="#l8.201"></a><span id="l8.201"> #endif</span>
<a href="#l8.202"></a><span id="l8.202"> #endif /* _LDAP_TOBE_DEPRECATED_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/ldap/c-sdk/include/ldap_ssl.h</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/ldap/c-sdk/include/ldap_ssl.h</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -57,37 +57,37 @@ extern &quot;C&quot; {</span>
<a href="#l9.4"></a><span id="l9.4">  * an ExtendedRequest [LDAPv3] specifying the OID for the</span>
<a href="#l9.5"></a><span id="l9.5">  * Start TLS operation: RFC 2830</span>
<a href="#l9.6"></a><span id="l9.6">  */</span>
<a href="#l9.7"></a><span id="l9.7"> #  define LDAP_EXOP_START_TLS &quot;1.3.6.1.4.1.1466.20037&quot;</span>
<a href="#l9.8"></a><span id="l9.8"> </span>
<a href="#l9.9"></a><span id="l9.9"> /*</span>
<a href="#l9.10"></a><span id="l9.10">  * Initialize LDAP library for SSL</span>
<a href="#l9.11"></a><span id="l9.11">  */</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-LDAP *LDAP_CALL ldapssl_init(const char *defhost, int defport, int defsecure);</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+LDAP* LDAP_CALL ldapssl_init(const char* defhost, int defport, int defsecure);</span>
<a href="#l9.14"></a><span id="l9.14"> </span>
<a href="#l9.15"></a><span id="l9.15"> /*</span>
<a href="#l9.16"></a><span id="l9.16">  * Shutdown LDAP library for SSL :</span>
<a href="#l9.17"></a><span id="l9.17">  * Perform necessary cleanup and attempt to shutdown NSS. All existing</span>
<a href="#l9.18"></a><span id="l9.18">  * ld session handles should be ldap_unbind(ld) prior to calling this.</span>
<a href="#l9.19"></a><span id="l9.19">  */</span>
<a href="#l9.20"></a><span id="l9.20"> int LDAP_CALL ldapssl_shutdown();</span>
<a href="#l9.21"></a><span id="l9.21"> </span>
<a href="#l9.22"></a><span id="l9.22"> /* Initialize LDAP library for TLS(SSL) and sends StartTLS extended</span>
<a href="#l9.23"></a><span id="l9.23">  * operation to the Directory Server.</span>
<a href="#l9.24"></a><span id="l9.24">  * Returns LDAP_SUCCESS if all goes well.</span>
<a href="#l9.25"></a><span id="l9.25">  */</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineminus">-int LDAP_CALL ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls,</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineminus">-                               LDAPControl **clientctrls);</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineplus">+int LDAP_CALL ldap_start_tls_s(LDAP* ld, LDAPControl** serverctrls,</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineplus">+                               LDAPControl** clientctrls);</span>
<a href="#l9.30"></a><span id="l9.30"> /*</span>
<a href="#l9.31"></a><span id="l9.31">  * Install I/O routines to make SSL over LDAP possible.</span>
<a href="#l9.32"></a><span id="l9.32">  * Use this after ldap_init() or just use ldapssl_init() instead.</span>
<a href="#l9.33"></a><span id="l9.33">  * Returns 0 if all goes well.</span>
<a href="#l9.34"></a><span id="l9.34">  */</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineminus">-int LDAP_CALL ldapssl_install_routines(LDAP *ld);</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineplus">+int LDAP_CALL ldapssl_install_routines(LDAP* ld);</span>
<a href="#l9.37"></a><span id="l9.37"> </span>
<a href="#l9.38"></a><span id="l9.38"> /* The next four functions initialize the security code for SSL</span>
<a href="#l9.39"></a><span id="l9.39">  * The first one ldapssl_client_init() does initialization for SSL only</span>
<a href="#l9.40"></a><span id="l9.40">  * The next one supports server authentication using clientauth_init()</span>
<a href="#l9.41"></a><span id="l9.41">  * and allows the caller to specify the ssl strength to use in order to</span>
<a href="#l9.42"></a><span id="l9.42">  * verify the servers's certificate.</span>
<a href="#l9.43"></a><span id="l9.43">  * The next one supports ldapssl_clientauth_init() initializes security</span>
<a href="#l9.44"></a><span id="l9.44">  * for SSL for client authentication.  The third function initializes</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineat">@@ -115,17 +115,17 @@ int LDAP_CALL ldapssl_install_routines(L</span>
<a href="#l9.46"></a><span id="l9.46">  */</span>
<a href="#l9.47"></a><span id="l9.47"> </span>
<a href="#l9.48"></a><span id="l9.48"> /*</span>
<a href="#l9.49"></a><span id="l9.49">  * Initialize the secure parts (Security and SSL) of the runtime for use</span>
<a href="#l9.50"></a><span id="l9.50">  * by a client application.  This is only called once.</span>
<a href="#l9.51"></a><span id="l9.51">  * Returns 0 if all goes well.</span>
<a href="#l9.52"></a><span id="l9.52">  */</span>
<a href="#l9.53"></a><span id="l9.53"> </span>
<a href="#l9.54"></a><span id="l9.54" class="difflineminus">-int LDAP_CALL ldapssl_client_init(const char *certdbpath, void *certdbhandle);</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineplus">+int LDAP_CALL ldapssl_client_init(const char* certdbpath, void* certdbhandle);</span>
<a href="#l9.56"></a><span id="l9.56"> </span>
<a href="#l9.57"></a><span id="l9.57"> /*</span>
<a href="#l9.58"></a><span id="l9.58">  * Initialize the secure parts (Security and SSL) of the runtime for use</span>
<a href="#l9.59"></a><span id="l9.59">  * by a client application using server authentication.  This is only</span>
<a href="#l9.60"></a><span id="l9.60">  * called once.</span>
<a href="#l9.61"></a><span id="l9.61">  *</span>
<a href="#l9.62"></a><span id="l9.62">  * ldapssl_serverauth_init() is a server-authentication only version of</span>
<a href="#l9.63"></a><span id="l9.63">  * ldapssl_clientauth_init().  This function allows the sslstrength</span>
<a href="#l9.64"></a><span id="l9.64" class="difflineat">@@ -149,98 +149,98 @@ int LDAP_CALL ldapssl_client_init(const </span>
<a href="#l9.65"></a><span id="l9.65">  *                         one hostname and not a list of hosts.</span>
<a href="#l9.66"></a><span id="l9.66">  *                         Furthermore, the port number must be passed</span>
<a href="#l9.67"></a><span id="l9.67">  *                         via the &quot;defport&quot; parameter, and cannot</span>
<a href="#l9.68"></a><span id="l9.68">  *                         be passed via a host:port option.</span>
<a href="#l9.69"></a><span id="l9.69">  *</span>
<a href="#l9.70"></a><span id="l9.70">  * Returns 0 if all goes well.</span>
<a href="#l9.71"></a><span id="l9.71">  */</span>
<a href="#l9.72"></a><span id="l9.72"> </span>
<a href="#l9.73"></a><span id="l9.73" class="difflineminus">-int LDAP_CALL ldapssl_serverauth_init(const char *certdbpath,</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineminus">-                                      void *certdbhandle,</span>
<a href="#l9.75"></a><span id="l9.75" class="difflineplus">+int LDAP_CALL ldapssl_serverauth_init(const char* certdbpath,</span>
<a href="#l9.76"></a><span id="l9.76" class="difflineplus">+                                      void* certdbhandle,</span>
<a href="#l9.77"></a><span id="l9.77">                                       const int sslstrength);</span>
<a href="#l9.78"></a><span id="l9.78"> </span>
<a href="#l9.79"></a><span id="l9.79"> /*</span>
<a href="#l9.80"></a><span id="l9.80">  * Initialize the secure parts (Security and SSL) of the runtime for use</span>
<a href="#l9.81"></a><span id="l9.81">  * by a client application that may want to do SSL client authentication.</span>
<a href="#l9.82"></a><span id="l9.82">  * Returns 0 if all goes well.</span>
<a href="#l9.83"></a><span id="l9.83">  */</span>
<a href="#l9.84"></a><span id="l9.84"> </span>
<a href="#l9.85"></a><span id="l9.85" class="difflineminus">-int LDAP_CALL ldapssl_clientauth_init(const char *certdbpath,</span>
<a href="#l9.86"></a><span id="l9.86" class="difflineminus">-                                      void *certdbhandle, const int needkeydb,</span>
<a href="#l9.87"></a><span id="l9.87" class="difflineminus">-                                      const char *keydbpath, void *keydbhandle);</span>
<a href="#l9.88"></a><span id="l9.88" class="difflineplus">+int LDAP_CALL ldapssl_clientauth_init(const char* certdbpath,</span>
<a href="#l9.89"></a><span id="l9.89" class="difflineplus">+                                      void* certdbhandle, const int needkeydb,</span>
<a href="#l9.90"></a><span id="l9.90" class="difflineplus">+                                      const char* keydbpath, void* keydbhandle);</span>
<a href="#l9.91"></a><span id="l9.91"> </span>
<a href="#l9.92"></a><span id="l9.92"> /*</span>
<a href="#l9.93"></a><span id="l9.93">  * Initialize the secure parts (Security and SSL) of the runtime for use</span>
<a href="#l9.94"></a><span id="l9.94">  * by a client application that may want to do SSL client authentication.</span>
<a href="#l9.95"></a><span id="l9.95">  *</span>
<a href="#l9.96"></a><span id="l9.96">  * Please see the description of the sslstrength value in the</span>
<a href="#l9.97"></a><span id="l9.97">  * ldapssl_serverauth_init() function above and note the potential</span>
<a href="#l9.98"></a><span id="l9.98">  * problems which can be caused by passing in wrong host &amp; portname</span>
<a href="#l9.99"></a><span id="l9.99">  * values.  The same warning applies to the ldapssl_advclientauth_init()</span>
<a href="#l9.100"></a><span id="l9.100">  * function.</span>
<a href="#l9.101"></a><span id="l9.101">  *</span>
<a href="#l9.102"></a><span id="l9.102">  * Returns 0 if all goes well.</span>
<a href="#l9.103"></a><span id="l9.103">  */</span>
<a href="#l9.104"></a><span id="l9.104"> </span>
<a href="#l9.105"></a><span id="l9.105"> int LDAP_CALL ldapssl_advclientauth_init(</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineminus">-    const char *certdbpath, void *certdbhandle, const int needkeydb,</span>
<a href="#l9.107"></a><span id="l9.107" class="difflineminus">-    const char *keydbpath, void *keydbhandle, const int needsecmoddb,</span>
<a href="#l9.108"></a><span id="l9.108" class="difflineminus">-    const char *secmoddbpath, const int sslstrength);</span>
<a href="#l9.109"></a><span id="l9.109" class="difflineplus">+    const char* certdbpath, void* certdbhandle, const int needkeydb,</span>
<a href="#l9.110"></a><span id="l9.110" class="difflineplus">+    const char* keydbpath, void* keydbhandle, const int needsecmoddb,</span>
<a href="#l9.111"></a><span id="l9.111" class="difflineplus">+    const char* secmoddbpath, const int sslstrength);</span>
<a href="#l9.112"></a><span id="l9.112"> </span>
<a href="#l9.113"></a><span id="l9.113"> /*</span>
<a href="#l9.114"></a><span id="l9.114">  * get a meaningful error string back from the security library</span>
<a href="#l9.115"></a><span id="l9.115">  * this function should be called, if ldap_err2string doesn't</span>
<a href="#l9.116"></a><span id="l9.116">  * identify the error code.</span>
<a href="#l9.117"></a><span id="l9.117">  */</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineminus">-const char *LDAP_CALL ldapssl_err2string(const int prerrno);</span>
<a href="#l9.119"></a><span id="l9.119" class="difflineplus">+const char* LDAP_CALL ldapssl_err2string(const int prerrno);</span>
<a href="#l9.120"></a><span id="l9.120"> </span>
<a href="#l9.121"></a><span id="l9.121"> /*</span>
<a href="#l9.122"></a><span id="l9.122">  * Enable SSL client authentication on the given ld.</span>
<a href="#l9.123"></a><span id="l9.123">  * Returns 0 if all goes well.</span>
<a href="#l9.124"></a><span id="l9.124">  */</span>
<a href="#l9.125"></a><span id="l9.125" class="difflineminus">-int LDAP_CALL ldapssl_enable_clientauth(LDAP *ld, char *keynickname,</span>
<a href="#l9.126"></a><span id="l9.126" class="difflineminus">-                                        char *keypasswd, char *certnickname);</span>
<a href="#l9.127"></a><span id="l9.127" class="difflineplus">+int LDAP_CALL ldapssl_enable_clientauth(LDAP* ld, char* keynickname,</span>
<a href="#l9.128"></a><span id="l9.128" class="difflineplus">+                                        char* keypasswd, char* certnickname);</span>
<a href="#l9.129"></a><span id="l9.129"> </span>
<a href="#l9.130"></a><span id="l9.130"> /*</span>
<a href="#l9.131"></a><span id="l9.131">  * Set the SSL strength for an existing SSL-enabled LDAP session handle.</span>
<a href="#l9.132"></a><span id="l9.132">  *</span>
<a href="#l9.133"></a><span id="l9.133">  * See the description of ldapssl_serverauth_init() above for valid</span>
<a href="#l9.134"></a><span id="l9.134">  * sslstrength values. If ld is NULL, the default for new LDAP session</span>
<a href="#l9.135"></a><span id="l9.135">  * handles is set.</span>
<a href="#l9.136"></a><span id="l9.136">  *</span>
<a href="#l9.137"></a><span id="l9.137">  * Returns 0 if all goes well.</span>
<a href="#l9.138"></a><span id="l9.138">  */</span>
<a href="#l9.139"></a><span id="l9.139" class="difflineminus">-int LDAP_CALL ldapssl_set_strength(LDAP *ld, int sslstrength);</span>
<a href="#l9.140"></a><span id="l9.140" class="difflineplus">+int LDAP_CALL ldapssl_set_strength(LDAP* ld, int sslstrength);</span>
<a href="#l9.141"></a><span id="l9.141"> </span>
<a href="#l9.142"></a><span id="l9.142"> /*</span>
<a href="#l9.143"></a><span id="l9.143">  * Set or get SSL options for an existing SSL-enabled LDAP session handle.</span>
<a href="#l9.144"></a><span id="l9.144">  * If ld is NULL, the default options used for all future LDAP SSL sessions</span>
<a href="#l9.145"></a><span id="l9.145">  * are the ones affected. The option values are specific to the underlying</span>
<a href="#l9.146"></a><span id="l9.146">  * SSL provider; see ssl.h within the Network Security Services (NSS)</span>
<a href="#l9.147"></a><span id="l9.147">  * distribution for the options supported by NSS (the default SSL provider).</span>
<a href="#l9.148"></a><span id="l9.148">  *</span>
<a href="#l9.149"></a><span id="l9.149">  * The ldapssl_set_option() function should be called before any LDAP</span>
<a href="#l9.150"></a><span id="l9.150">  * connections are created.</span>
<a href="#l9.151"></a><span id="l9.151">  *</span>
<a href="#l9.152"></a><span id="l9.152">  * Both functions return 0 if all goes well.</span>
<a href="#l9.153"></a><span id="l9.153">  */</span>
<a href="#l9.154"></a><span id="l9.154" class="difflineminus">-int LDAP_CALL ldapssl_set_option(LDAP *ld, int option, int on);</span>
<a href="#l9.155"></a><span id="l9.155" class="difflineminus">-int LDAP_CALL ldapssl_get_option(LDAP *ld, int option, int *onp);</span>
<a href="#l9.156"></a><span id="l9.156" class="difflineplus">+int LDAP_CALL ldapssl_set_option(LDAP* ld, int option, int on);</span>
<a href="#l9.157"></a><span id="l9.157" class="difflineplus">+int LDAP_CALL ldapssl_get_option(LDAP* ld, int option, int* onp);</span>
<a href="#l9.158"></a><span id="l9.158"> </span>
<a href="#l9.159"></a><span id="l9.159"> /*</span>
<a href="#l9.160"></a><span id="l9.160">  * Import the file descriptor corresponding to the socket of an already</span>
<a href="#l9.161"></a><span id="l9.161">  * open LDAP connection into SSL, and update the socket and session</span>
<a href="#l9.162"></a><span id="l9.162">  * information accordingly. Returns 0 if all goes well.</span>
<a href="#l9.163"></a><span id="l9.163">  */</span>
<a href="#l9.164"></a><span id="l9.164" class="difflineminus">-int LDAP_CALL ldapssl_import_fd(LDAP *ld, int secure);</span>
<a href="#l9.165"></a><span id="l9.165" class="difflineplus">+int LDAP_CALL ldapssl_import_fd(LDAP* ld, int secure);</span>
<a href="#l9.166"></a><span id="l9.166"> </span>
<a href="#l9.167"></a><span id="l9.167"> /*</span>
<a href="#l9.168"></a><span id="l9.168">  * Reset an LDAP session from SSL to a non-secure status. Basically,</span>
<a href="#l9.169"></a><span id="l9.169">  * this function undoes the work done by ldapssl_install_routines.</span>
<a href="#l9.170"></a><span id="l9.170">  * Returns 0 if all goes well.</span>
<a href="#l9.171"></a><span id="l9.171">  */</span>
<a href="#l9.172"></a><span id="l9.172" class="difflineminus">-int LDAP_CALL ldapssl_reset_to_nonsecure(LDAP *ld);</span>
<a href="#l9.173"></a><span id="l9.173" class="difflineplus">+int LDAP_CALL ldapssl_reset_to_nonsecure(LDAP* ld);</span>
<a href="#l9.174"></a><span id="l9.174"> </span>
<a href="#l9.175"></a><span id="l9.175"> #  ifdef __cplusplus</span>
<a href="#l9.176"></a><span id="l9.176"> }</span>
<a href="#l9.177"></a><span id="l9.177"> #  endif</span>
<a href="#l9.178"></a><span id="l9.178"> #endif /* !defined(LDAP_SSL_H) */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/ldap/c-sdk/include/ldaplog.h</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/ldap/c-sdk/include/ldaplog.h</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -65,17 +65,17 @@ extern &quot;C&quot; {</span>
<a href="#l10.4"></a><span id="l10.4"> #define LDAPDebug(level, fmt, arg1, arg2, arg3)</span>
<a href="#l10.5"></a><span id="l10.5"> </span>
<a href="#l10.6"></a><span id="l10.6"> #ifdef LDAP_DEBUG</span>
<a href="#l10.7"></a><span id="l10.7"> #  undef LDAPDebug</span>
<a href="#l10.8"></a><span id="l10.8"> </span>
<a href="#l10.9"></a><span id="l10.9"> /* SLAPD_LOGGING should not be on for WINSOCK (16-bit Windows) */</span>
<a href="#l10.10"></a><span id="l10.10"> #  if defined(SLAPD_LOGGING)</span>
<a href="#l10.11"></a><span id="l10.11"> #    ifdef _WIN32</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-extern int *module_ldap_debug;</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+extern int* module_ldap_debug;</span>
<a href="#l10.14"></a><span id="l10.14"> #      define LDAPDebug(level, fmt, arg1, arg2, arg3)          \</span>
<a href="#l10.15"></a><span id="l10.15">         {                                                      \</span>
<a href="#l10.16"></a><span id="l10.16">           if (*module_ldap_debug &amp; level) {                    \</span>
<a href="#l10.17"></a><span id="l10.17">             slapd_log_error_proc(NULL, fmt, arg1, arg2, arg3); \</span>
<a href="#l10.18"></a><span id="l10.18">           }                                                    \</span>
<a href="#l10.19"></a><span id="l10.19">         }</span>
<a href="#l10.20"></a><span id="l10.20"> #    else /* _WIN32 */</span>
<a href="#l10.21"></a><span id="l10.21"> extern int ldap_debug;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/ldap/c-sdk/include/ldappr.h</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/ldap/c-sdk/include/ldappr.h</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -59,62 +59,62 @@ extern &quot;C&quot; {</span>
<a href="#l11.4"></a><span id="l11.4">  * this LDAP * handle from more than one thread.</span>
<a href="#l11.5"></a><span id="l11.5">  *</span>
<a href="#l11.6"></a><span id="l11.6">  * Returns an LDAP session handle (or NULL if an error occurs).</span>
<a href="#l11.7"></a><span id="l11.7">  *</span>
<a href="#l11.8"></a><span id="l11.8">  * NOTE: If you want to use IPv6, you must use prldap creating a LDAP handle</span>
<a href="#l11.9"></a><span id="l11.9">  * with this function prldap_init.  Prldap_init installs the appropriate</span>
<a href="#l11.10"></a><span id="l11.10">  * set of NSPR functions and prevents calling deprecated functions accidentally.</span>
<a href="#l11.11"></a><span id="l11.11">  */</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-LDAP *LDAP_CALL prldap_init(const char *defhost, int defport, int shared);</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+LDAP* LDAP_CALL prldap_init(const char* defhost, int defport, int shared);</span>
<a href="#l11.14"></a><span id="l11.14"> </span>
<a href="#l11.15"></a><span id="l11.15"> /*</span>
<a href="#l11.16"></a><span id="l11.16">  * Function: prldap_install_routines().</span>
<a href="#l11.17"></a><span id="l11.17">  *</span>
<a href="#l11.18"></a><span id="l11.18">  * Install NSPR I/O, threading, and DNS functions so they will be used by</span>
<a href="#l11.19"></a><span id="l11.19">  * 'ld'.</span>
<a href="#l11.20"></a><span id="l11.20">  *</span>
<a href="#l11.21"></a><span id="l11.21">  * If 'ld' is NULL, the functions are installed as the default functions</span>
<a href="#l11.22"></a><span id="l11.22">  * for all new LDAP * handles).</span>
<a href="#l11.23"></a><span id="l11.23">  *</span>
<a href="#l11.24"></a><span id="l11.24">  * Pass a non-zero value for the 'shared' parameter if you plan to use</span>
<a href="#l11.25"></a><span id="l11.25">  * this LDAP * handle from more than one thread.</span>
<a href="#l11.26"></a><span id="l11.26">  *</span>
<a href="#l11.27"></a><span id="l11.27">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l11.28"></a><span id="l11.28">  */</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineminus">-int LDAP_CALL prldap_install_routines(LDAP *ld, int shared);</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineplus">+int LDAP_CALL prldap_install_routines(LDAP* ld, int shared);</span>
<a href="#l11.31"></a><span id="l11.31"> </span>
<a href="#l11.32"></a><span id="l11.32"> /*</span>
<a href="#l11.33"></a><span id="l11.33">  * Function: prldap_set_session_option().</span>
<a href="#l11.34"></a><span id="l11.34">  *</span>
<a href="#l11.35"></a><span id="l11.35">  * Given an LDAP session handle or a session argument such is passed to</span>
<a href="#l11.36"></a><span id="l11.36">  * CONNECT, POLL, NEWHANDLE, or DISPOSEHANDLE extended I/O callbacks, set</span>
<a href="#l11.37"></a><span id="l11.37">  * an option that affects the prldap layer.</span>
<a href="#l11.38"></a><span id="l11.38">  *</span>
<a href="#l11.39"></a><span id="l11.39">  * If 'ld' and 'session&quot; are both NULL, the option is set as the default</span>
<a href="#l11.40"></a><span id="l11.40">  * for all new prldap sessions.</span>
<a href="#l11.41"></a><span id="l11.41">  *</span>
<a href="#l11.42"></a><span id="l11.42">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l11.43"></a><span id="l11.43">  */</span>
<a href="#l11.44"></a><span id="l11.44" class="difflineminus">-int LDAP_CALL prldap_set_session_option(LDAP *ld, void *sessionarg, int option,</span>
<a href="#l11.45"></a><span id="l11.45" class="difflineplus">+int LDAP_CALL prldap_set_session_option(LDAP* ld, void* sessionarg, int option,</span>
<a href="#l11.46"></a><span id="l11.46">                                         ...);</span>
<a href="#l11.47"></a><span id="l11.47"> </span>
<a href="#l11.48"></a><span id="l11.48"> /*</span>
<a href="#l11.49"></a><span id="l11.49">  * Function: prldap_get_session_option().</span>
<a href="#l11.50"></a><span id="l11.50">  *</span>
<a href="#l11.51"></a><span id="l11.51">  * Given an LDAP session handle or a session argument such is passed to</span>
<a href="#l11.52"></a><span id="l11.52">  * CONNECT, POLL, NEWHANDLE, or DISPOSEHANDLE extended I/O callbacks, retrieve</span>
<a href="#l11.53"></a><span id="l11.53">  * the setting for an option that affects the prldap layer.</span>
<a href="#l11.54"></a><span id="l11.54">  *</span>
<a href="#l11.55"></a><span id="l11.55">  * If 'ld' and 'session&quot; are both NULL, the default option value for all new</span>
<a href="#l11.56"></a><span id="l11.56">  * new prldap sessions is retrieved.</span>
<a href="#l11.57"></a><span id="l11.57">  *</span>
<a href="#l11.58"></a><span id="l11.58">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l11.59"></a><span id="l11.59">  */</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineminus">-int LDAP_CALL prldap_get_session_option(LDAP *ld, void *sessionarg, int option,</span>
<a href="#l11.61"></a><span id="l11.61" class="difflineplus">+int LDAP_CALL prldap_get_session_option(LDAP* ld, void* sessionarg, int option,</span>
<a href="#l11.62"></a><span id="l11.62">                                         ...);</span>
<a href="#l11.63"></a><span id="l11.63"> </span>
<a href="#l11.64"></a><span id="l11.64"> /*</span>
<a href="#l11.65"></a><span id="l11.65">  * Available options.</span>
<a href="#l11.66"></a><span id="l11.66">  */</span>
<a href="#l11.67"></a><span id="l11.67"> /*</span>
<a href="#l11.68"></a><span id="l11.68">  * PRLDAP_OPT_IO_MAX_TIMEOUT: the maximum time in milliseconds to</span>
<a href="#l11.69"></a><span id="l11.69">  * block waiting for a network I/O operation to complete.</span>
<a href="#l11.70"></a><span id="l11.70" class="difflineat">@@ -149,116 +149,116 @@ int LDAP_CALL prldap_get_session_option(</span>
<a href="#l11.71"></a><span id="l11.71"> /*</span>
<a href="#l11.72"></a><span id="l11.72">  * Data structure for session information.</span>
<a href="#l11.73"></a><span id="l11.73">  * seinfo_size should be set to PRLDAP_SESSIONINFO_SIZE before use.</span>
<a href="#l11.74"></a><span id="l11.74">  */</span>
<a href="#l11.75"></a><span id="l11.75"> struct prldap_session_private;</span>
<a href="#l11.76"></a><span id="l11.76"> </span>
<a href="#l11.77"></a><span id="l11.77"> typedef struct prldap_session_info {</span>
<a href="#l11.78"></a><span id="l11.78">   int seinfo_size;</span>
<a href="#l11.79"></a><span id="l11.79" class="difflineminus">-  struct prldap_session_private *seinfo_appdata;</span>
<a href="#l11.80"></a><span id="l11.80" class="difflineplus">+  struct prldap_session_private* seinfo_appdata;</span>
<a href="#l11.81"></a><span id="l11.81"> } PRLDAPSessionInfo;</span>
<a href="#l11.82"></a><span id="l11.82"> #define PRLDAP_SESSIONINFO_SIZE sizeof(PRLDAPSessionInfo)</span>
<a href="#l11.83"></a><span id="l11.83"> </span>
<a href="#l11.84"></a><span id="l11.84"> /*</span>
<a href="#l11.85"></a><span id="l11.85">  * Function: prldap_set_session_info().</span>
<a href="#l11.86"></a><span id="l11.86">  *</span>
<a href="#l11.87"></a><span id="l11.87">  * Given an LDAP session handle or a session argument such is passed to</span>
<a href="#l11.88"></a><span id="l11.88">  * CONNECT, POLL, NEWHANDLE, or DISPOSEHANDLE extended I/O callbacks,</span>
<a href="#l11.89"></a><span id="l11.89">  * set some application-specific data.  If ld is NULL, arg is used.  If</span>
<a href="#l11.90"></a><span id="l11.90">  * both ld and arg are NULL, LDAP_PARAM_ERROR is returned.</span>
<a href="#l11.91"></a><span id="l11.91">  *</span>
<a href="#l11.92"></a><span id="l11.92">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l11.93"></a><span id="l11.93">  */</span>
<a href="#l11.94"></a><span id="l11.94" class="difflineminus">-int LDAP_CALL prldap_set_session_info(LDAP *ld, void *sessionarg,</span>
<a href="#l11.95"></a><span id="l11.95" class="difflineminus">-                                      PRLDAPSessionInfo *seip);</span>
<a href="#l11.96"></a><span id="l11.96" class="difflineplus">+int LDAP_CALL prldap_set_session_info(LDAP* ld, void* sessionarg,</span>
<a href="#l11.97"></a><span id="l11.97" class="difflineplus">+                                      PRLDAPSessionInfo* seip);</span>
<a href="#l11.98"></a><span id="l11.98"> </span>
<a href="#l11.99"></a><span id="l11.99"> /*</span>
<a href="#l11.100"></a><span id="l11.100">  * Function: prldap_get_session_info().</span>
<a href="#l11.101"></a><span id="l11.101">  *</span>
<a href="#l11.102"></a><span id="l11.102">  * Given an LDAP session handle or a session argument such is passed to</span>
<a href="#l11.103"></a><span id="l11.103">  * CONNECT, POLL, NEWHANDLE, or DISPOSEHANDLE extended I/O callbacks,</span>
<a href="#l11.104"></a><span id="l11.104">  * retrieve some application-specific data.  If ld is NULL, arg is used.  If</span>
<a href="#l11.105"></a><span id="l11.105">  * both ld and arg are NULL, LDAP_PARAM_ERROR is returned.</span>
<a href="#l11.106"></a><span id="l11.106">  *</span>
<a href="#l11.107"></a><span id="l11.107">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well, in</span>
<a href="#l11.108"></a><span id="l11.108">  * which case the fields in the structure that seip points to are filled in).</span>
<a href="#l11.109"></a><span id="l11.109">  */</span>
<a href="#l11.110"></a><span id="l11.110" class="difflineminus">-int LDAP_CALL prldap_get_session_info(LDAP *ld, void *sessionarg,</span>
<a href="#l11.111"></a><span id="l11.111" class="difflineminus">-                                      PRLDAPSessionInfo *seip);</span>
<a href="#l11.112"></a><span id="l11.112" class="difflineplus">+int LDAP_CALL prldap_get_session_info(LDAP* ld, void* sessionarg,</span>
<a href="#l11.113"></a><span id="l11.113" class="difflineplus">+                                      PRLDAPSessionInfo* seip);</span>
<a href="#l11.114"></a><span id="l11.114"> </span>
<a href="#l11.115"></a><span id="l11.115"> /*</span>
<a href="#l11.116"></a><span id="l11.116">  * Data structure for socket specific information.</span>
<a href="#l11.117"></a><span id="l11.117">  * Note: soinfo_size should be set to PRLDAP_SOCKETINFO_SIZE before use.</span>
<a href="#l11.118"></a><span id="l11.118">  */</span>
<a href="#l11.119"></a><span id="l11.119"> struct prldap_socket_private;</span>
<a href="#l11.120"></a><span id="l11.120"> typedef struct prldap_socket_info {</span>
<a href="#l11.121"></a><span id="l11.121">   int soinfo_size;</span>
<a href="#l11.122"></a><span id="l11.122" class="difflineminus">-  PRFileDesc *soinfo_prfd;</span>
<a href="#l11.123"></a><span id="l11.123" class="difflineminus">-  struct prldap_socket_private *soinfo_appdata;</span>
<a href="#l11.124"></a><span id="l11.124" class="difflineplus">+  PRFileDesc* soinfo_prfd;</span>
<a href="#l11.125"></a><span id="l11.125" class="difflineplus">+  struct prldap_socket_private* soinfo_appdata;</span>
<a href="#l11.126"></a><span id="l11.126"> } PRLDAPSocketInfo;</span>
<a href="#l11.127"></a><span id="l11.127"> #define PRLDAP_SOCKETINFO_SIZE sizeof(PRLDAPSocketInfo)</span>
<a href="#l11.128"></a><span id="l11.128"> </span>
<a href="#l11.129"></a><span id="l11.129"> /*</span>
<a href="#l11.130"></a><span id="l11.130">  * Function: prldap_set_socket_info().</span>
<a href="#l11.131"></a><span id="l11.131">  *</span>
<a href="#l11.132"></a><span id="l11.132">  * Given an integer fd and a socket argument such as those passed to the</span>
<a href="#l11.133"></a><span id="l11.133">  * extended I/O callback functions, set socket specific information.</span>
<a href="#l11.134"></a><span id="l11.134">  *</span>
<a href="#l11.135"></a><span id="l11.135">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l11.136"></a><span id="l11.136">  *</span>
<a href="#l11.137"></a><span id="l11.137">  * Note: it is only safe to change soinfo_prfd from within the CONNECT</span>
<a href="#l11.138"></a><span id="l11.138">  * extended I/O callback function.</span>
<a href="#l11.139"></a><span id="l11.139">  */</span>
<a href="#l11.140"></a><span id="l11.140" class="difflineminus">-int LDAP_CALL prldap_set_socket_info(int fd, void *socketarg,</span>
<a href="#l11.141"></a><span id="l11.141" class="difflineminus">-                                     PRLDAPSocketInfo *soip);</span>
<a href="#l11.142"></a><span id="l11.142" class="difflineplus">+int LDAP_CALL prldap_set_socket_info(int fd, void* socketarg,</span>
<a href="#l11.143"></a><span id="l11.143" class="difflineplus">+                                     PRLDAPSocketInfo* soip);</span>
<a href="#l11.144"></a><span id="l11.144"> </span>
<a href="#l11.145"></a><span id="l11.145"> /*</span>
<a href="#l11.146"></a><span id="l11.146">  * Function: prldap_get_socket_info().</span>
<a href="#l11.147"></a><span id="l11.147">  *</span>
<a href="#l11.148"></a><span id="l11.148">  * Given an integer fd and a socket argument such as those passed to the</span>
<a href="#l11.149"></a><span id="l11.149">  * extended I/O callback functions, retrieve socket specific information.</span>
<a href="#l11.150"></a><span id="l11.150">  *</span>
<a href="#l11.151"></a><span id="l11.151">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well, in</span>
<a href="#l11.152"></a><span id="l11.152">  * which case the fields in the structure that soip points to are filled in).</span>
<a href="#l11.153"></a><span id="l11.153">  */</span>
<a href="#l11.154"></a><span id="l11.154" class="difflineminus">-int LDAP_CALL prldap_get_socket_info(int fd, void *socketarg,</span>
<a href="#l11.155"></a><span id="l11.155" class="difflineminus">-                                     PRLDAPSocketInfo *soip);</span>
<a href="#l11.156"></a><span id="l11.156" class="difflineplus">+int LDAP_CALL prldap_get_socket_info(int fd, void* socketarg,</span>
<a href="#l11.157"></a><span id="l11.157" class="difflineplus">+                                     PRLDAPSocketInfo* soip);</span>
<a href="#l11.158"></a><span id="l11.158"> </span>
<a href="#l11.159"></a><span id="l11.159"> /*</span>
<a href="#l11.160"></a><span id="l11.160">  * Function: prldap_get_default_socket_info().</span>
<a href="#l11.161"></a><span id="l11.161">  *</span>
<a href="#l11.162"></a><span id="l11.162">  * Given an LDAP session handle, retrieve socket specific information.</span>
<a href="#l11.163"></a><span id="l11.163">  * If ld is NULL, LDAP_PARAM_ERROR is returned.</span>
<a href="#l11.164"></a><span id="l11.164">  *</span>
<a href="#l11.165"></a><span id="l11.165">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well, in</span>
<a href="#l11.166"></a><span id="l11.166">  * which case the fields in the structure that soip points to are filled in).</span>
<a href="#l11.167"></a><span id="l11.167">  */</span>
<a href="#l11.168"></a><span id="l11.168" class="difflineminus">-int LDAP_CALL prldap_get_default_socket_info(LDAP *ld, PRLDAPSocketInfo *soip);</span>
<a href="#l11.169"></a><span id="l11.169" class="difflineplus">+int LDAP_CALL prldap_get_default_socket_info(LDAP* ld, PRLDAPSocketInfo* soip);</span>
<a href="#l11.170"></a><span id="l11.170"> </span>
<a href="#l11.171"></a><span id="l11.171"> /*</span>
<a href="#l11.172"></a><span id="l11.172">  * Function: prldap_set_default_socket_info().</span>
<a href="#l11.173"></a><span id="l11.173">  *</span>
<a href="#l11.174"></a><span id="l11.174">  * Given an LDAP session handle, set socket specific information.</span>
<a href="#l11.175"></a><span id="l11.175">  * If ld is NULL, LDAP_PARAM_ERROR is returned.</span>
<a href="#l11.176"></a><span id="l11.176">  *</span>
<a href="#l11.177"></a><span id="l11.177">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well, in</span>
<a href="#l11.178"></a><span id="l11.178">  * which case the fields in the structure that soip points to are filled in).</span>
<a href="#l11.179"></a><span id="l11.179">  */</span>
<a href="#l11.180"></a><span id="l11.180" class="difflineminus">-int LDAP_CALL prldap_set_default_socket_info(LDAP *ld, PRLDAPSocketInfo *soip);</span>
<a href="#l11.181"></a><span id="l11.181" class="difflineplus">+int LDAP_CALL prldap_set_default_socket_info(LDAP* ld, PRLDAPSocketInfo* soip);</span>
<a href="#l11.182"></a><span id="l11.182"> </span>
<a href="#l11.183"></a><span id="l11.183"> /* Function: prldap_is_installed()</span>
<a href="#l11.184"></a><span id="l11.184">  * Check if NSPR routine is installed</span>
<a href="#l11.185"></a><span id="l11.185">  */</span>
<a href="#l11.186"></a><span id="l11.186" class="difflineminus">-PRBool prldap_is_installed(LDAP *ld);</span>
<a href="#l11.187"></a><span id="l11.187" class="difflineplus">+PRBool prldap_is_installed(LDAP* ld);</span>
<a href="#l11.188"></a><span id="l11.188"> </span>
<a href="#l11.189"></a><span id="l11.189"> /* Function: prldap_import_connection().</span>
<a href="#l11.190"></a><span id="l11.190">  * Given a ldap handle with connection already done with ldap_init()</span>
<a href="#l11.191"></a><span id="l11.191">  * installs NSPR routines and imports the original connection info.</span>
<a href="#l11.192"></a><span id="l11.192">  *</span>
<a href="#l11.193"></a><span id="l11.193">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l11.194"></a><span id="l11.194">  */</span>
<a href="#l11.195"></a><span id="l11.195" class="difflineminus">-int LDAP_CALL prldap_import_connection(LDAP *ld);</span>
<a href="#l11.196"></a><span id="l11.196" class="difflineplus">+int LDAP_CALL prldap_import_connection(LDAP* ld);</span>
<a href="#l11.197"></a><span id="l11.197"> </span>
<a href="#l11.198"></a><span id="l11.198"> #ifdef __cplusplus</span>
<a href="#l11.199"></a><span id="l11.199"> }</span>
<a href="#l11.200"></a><span id="l11.200"> #endif</span>
<a href="#l11.201"></a><span id="l11.201"> #endif /* !defined(LDAP_PR_H) */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/ldap/c-sdk/include/ldif.h</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/ldap/c-sdk/include/ldif.h</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -85,29 +85,29 @@ extern &quot;C&quot; {</span>
<a href="#l12.4"></a><span id="l12.4"> /*</span>
<a href="#l12.5"></a><span id="l12.5">  * Options for ldif_put_type_and_value_with_options() and</span>
<a href="#l12.6"></a><span id="l12.6">  * ldif_type_and_value_with_options().</span>
<a href="#l12.7"></a><span id="l12.7">  */</span>
<a href="#l12.8"></a><span id="l12.8"> #define LDIF_OPT_NOWRAP 0x01UL</span>
<a href="#l12.9"></a><span id="l12.9"> #define LDIF_OPT_VALUE_IS_URL 0x02UL</span>
<a href="#l12.10"></a><span id="l12.10"> #define LDIF_OPT_MINIMAL_ENCODING 0x04UL</span>
<a href="#l12.11"></a><span id="l12.11"> </span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-int ldif_parse_line(char *line, char **type, char **value, int *vlen);</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineminus">-char *ldif_getline(char **next);</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineminus">-void ldif_put_type_and_value(char **out, char *t, char *val, int vlen);</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineminus">-void ldif_put_type_and_value_nowrap(char **out, char *t, char *val, int vlen);</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineminus">-void ldif_put_type_and_value_with_options(char **out, char *t, char *val,</span>
<a href="#l12.17"></a><span id="l12.17" class="difflineplus">+int ldif_parse_line(char* line, char** type, char** value, int* vlen);</span>
<a href="#l12.18"></a><span id="l12.18" class="difflineplus">+char* ldif_getline(char** next);</span>
<a href="#l12.19"></a><span id="l12.19" class="difflineplus">+void ldif_put_type_and_value(char** out, char* t, char* val, int vlen);</span>
<a href="#l12.20"></a><span id="l12.20" class="difflineplus">+void ldif_put_type_and_value_nowrap(char** out, char* t, char* val, int vlen);</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineplus">+void ldif_put_type_and_value_with_options(char** out, char* t, char* val,</span>
<a href="#l12.22"></a><span id="l12.22">                                           int vlen, unsigned long options);</span>
<a href="#l12.23"></a><span id="l12.23" class="difflineminus">-char *ldif_type_and_value(char *type, char *val, int vlen);</span>
<a href="#l12.24"></a><span id="l12.24" class="difflineminus">-char *ldif_type_and_value_nowrap(char *type, char *val, int vlen);</span>
<a href="#l12.25"></a><span id="l12.25" class="difflineminus">-char *ldif_type_and_value_with_options(char *type, char *val, int vlen,</span>
<a href="#l12.26"></a><span id="l12.26" class="difflineplus">+char* ldif_type_and_value(char* type, char* val, int vlen);</span>
<a href="#l12.27"></a><span id="l12.27" class="difflineplus">+char* ldif_type_and_value_nowrap(char* type, char* val, int vlen);</span>
<a href="#l12.28"></a><span id="l12.28" class="difflineplus">+char* ldif_type_and_value_with_options(char* type, char* val, int vlen,</span>
<a href="#l12.29"></a><span id="l12.29">                                        unsigned long options);</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineminus">-int ldif_base64_decode(char *src, unsigned char *dst);</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineminus">-int ldif_base64_encode(unsigned char *src, char *dst, int srclen, int lenused);</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineminus">-int ldif_base64_encode_nowrap(unsigned char *src, char *dst, int srclen,</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+int ldif_base64_decode(char* src, unsigned char* dst);</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+int ldif_base64_encode(unsigned char* src, char* dst, int srclen, int lenused);</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineplus">+int ldif_base64_encode_nowrap(unsigned char* src, char* dst, int srclen,</span>
<a href="#l12.36"></a><span id="l12.36">                               int lenused);</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineminus">-char *ldif_get_entry(FILE *fp, int *lineno);</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+char* ldif_get_entry(FILE* fp, int* lineno);</span>
<a href="#l12.39"></a><span id="l12.39"> </span>
<a href="#l12.40"></a><span id="l12.40"> #ifdef __cplusplus</span>
<a href="#l12.41"></a><span id="l12.41"> }</span>
<a href="#l12.42"></a><span id="l12.42"> #endif</span>
<a href="#l12.43"></a><span id="l12.43"> </span>
<a href="#l12.44"></a><span id="l12.44"> #endif /* _LDIF_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/ldap/c-sdk/include/portable.h</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/ldap/c-sdk/include/portable.h</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -178,17 +178,17 @@</span>
<a href="#l13.4"></a><span id="l13.4"> #    define NFDBITS 32</span>
<a href="#l13.5"></a><span id="l13.5"> #    define FD_SETSIZE 32</span>
<a href="#l13.6"></a><span id="l13.6"> #    define FD_SET(n, p) \</span>
<a href="#l13.7"></a><span id="l13.7">       ((p)-&gt;fds_bits[(n) / NFDBITS] |= (1 &lt;&lt; ((n) % NFDBITS)))</span>
<a href="#l13.8"></a><span id="l13.8"> #    define FD_CLR(n, p) \</span>
<a href="#l13.9"></a><span id="l13.9">       ((p)-&gt;fds_bits[(n) / NFDBITS] &amp;= ~(1 &lt;&lt; ((n) % NFDBITS)))</span>
<a href="#l13.10"></a><span id="l13.10"> #    define FD_ISSET(n, p) \</span>
<a href="#l13.11"></a><span id="l13.11">       ((p)-&gt;fds_bits[(n) / NFDBITS] &amp; (1 &lt;&lt; ((n) % NFDBITS)))</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-#    define FD_ZERO(p) bzero((char *)(p), sizeof(*(p)))</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+#    define FD_ZERO(p) bzero((char*)(p), sizeof(*(p)))</span>
<a href="#l13.14"></a><span id="l13.14"> #  endif /* !FD_SET */</span>
<a href="#l13.15"></a><span id="l13.15"> #endif   /* !WINSOCK &amp;&amp; !_WINDOWS &amp;&amp; !macintosh */</span>
<a href="#l13.16"></a><span id="l13.16"> </span>
<a href="#l13.17"></a><span id="l13.17"> /*</span>
<a href="#l13.18"></a><span id="l13.18">  * for connect() -- must we block signals when calling connect()?  This</span>
<a href="#l13.19"></a><span id="l13.19">  * is necessary on some buggy UNIXes.</span>
<a href="#l13.20"></a><span id="l13.20">  */</span>
<a href="#l13.21"></a><span id="l13.21"> #if !defined(NSLDAPI_CONNECT_MUST_NOT_BE_INTERRUPTED) &amp;&amp;                  \</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineat">@@ -239,22 +239,22 @@</span>
<a href="#l13.23"></a><span id="l13.23"> #endif</span>
<a href="#l13.24"></a><span id="l13.24"> </span>
<a href="#l13.25"></a><span id="l13.25"> #if (!defined(HPUX9)) &amp;&amp; (!defined(sunos4)) &amp;&amp; (!defined(SNI)) &amp;&amp; \</span>
<a href="#l13.26"></a><span id="l13.26">     (!defined(HAVE_TIME_R))</span>
<a href="#l13.27"></a><span id="l13.27"> #  define HAVE_TIME_R</span>
<a href="#l13.28"></a><span id="l13.28"> #endif</span>
<a href="#l13.29"></a><span id="l13.29"> </span>
<a href="#l13.30"></a><span id="l13.30"> #if defined(SNI) || defined(LINUX1_2)</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineminus">-int strcasecmp(const char *, const char *);</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+int strcasecmp(const char*, const char*);</span>
<a href="#l13.33"></a><span id="l13.33"> #  ifdef SNI</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineminus">-int strncasecmp(const char *, const char *, int);</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineplus">+int strncasecmp(const char*, const char*, int);</span>
<a href="#l13.36"></a><span id="l13.36"> #  endif /* SNI */</span>
<a href="#l13.37"></a><span id="l13.37"> #  ifdef LINUX1_2</span>
<a href="#l13.38"></a><span id="l13.38" class="difflineminus">-int strncasecmp(const char *, const char *, size_t);</span>
<a href="#l13.39"></a><span id="l13.39" class="difflineplus">+int strncasecmp(const char*, const char*, size_t);</span>
<a href="#l13.40"></a><span id="l13.40"> #  endif /* LINUX1_2 */</span>
<a href="#l13.41"></a><span id="l13.41"> #endif   /* SNI || LINUX1_2 */</span>
<a href="#l13.42"></a><span id="l13.42"> </span>
<a href="#l13.43"></a><span id="l13.43"> #if defined(_WINDOWS) || defined(macintosh) || defined(XP_OS2) || \</span>
<a href="#l13.44"></a><span id="l13.44">     defined(DARWIN)</span>
<a href="#l13.45"></a><span id="l13.45"> #  define GETHOSTBYNAME(n, r, b, l, e) gethostbyname(n)</span>
<a href="#l13.46"></a><span id="l13.46"> #  define NSLDAPI_CTIME(c, b, l) ctime(c)</span>
<a href="#l13.47"></a><span id="l13.47"> #  define STRTOK(s1, s2, l) strtok(s1, s2)</span>
<a href="#l13.48"></a><span id="l13.48" class="difflineat">@@ -286,17 +286,17 @@ int strncasecmp(const char *, const char</span>
<a href="#l13.49"></a><span id="l13.49"> */</span>
<a href="#l13.50"></a><span id="l13.50"> typedef char GETHOSTBYNAME_buf_t[NSLDAPI_NETDB_BUF_SIZE];</span>
<a href="#l13.51"></a><span id="l13.51"> #    define GETHOSTBYNAME_BUF_T GETHOSTBYNAME_buf_t</span>
<a href="#l13.52"></a><span id="l13.52"> #    define GETHOSTBYNAME(n, r, b, l, e) \</span>
<a href="#l13.53"></a><span id="l13.53">       (memset(&amp;b, 0, l), gethostbyname_r(n, r, &amp;b) ? NULL : r)</span>
<a href="#l13.54"></a><span id="l13.54"> #  elif defined(HPUX10)</span>
<a href="#l13.55"></a><span id="l13.55"> #    define GETHOSTBYNAME_BUF_T struct hostent_data</span>
<a href="#l13.56"></a><span id="l13.56"> #    define GETHOSTBYNAME(n, r, b, l, e) \</span>
<a href="#l13.57"></a><span id="l13.57" class="difflineminus">-      nsldapi_compat_gethostbyname_r(n, r, (char *)&amp;b, l, e)</span>
<a href="#l13.58"></a><span id="l13.58" class="difflineplus">+      nsldapi_compat_gethostbyname_r(n, r, (char*)&amp;b, l, e)</span>
<a href="#l13.59"></a><span id="l13.59"> #  elif defined(LINUX) || defined(DRAGONFLY)</span>
<a href="#l13.60"></a><span id="l13.60"> typedef char GETHOSTBYNAME_buf_t[NSLDAPI_NETDB_BUF_SIZE];</span>
<a href="#l13.61"></a><span id="l13.61"> #    define GETHOSTBYNAME_BUF_T GETHOSTBYNAME_buf_t</span>
<a href="#l13.62"></a><span id="l13.62"> #    define GETHOSTBYNAME(n, r, b, l, rp, e) gethostbyname_r(n, r, b, l, rp, e)</span>
<a href="#l13.63"></a><span id="l13.63"> #    define GETHOSTBYNAME_R_RETURNS_INT</span>
<a href="#l13.64"></a><span id="l13.64"> #  else</span>
<a href="#l13.65"></a><span id="l13.65"> typedef char GETHOSTBYNAME_buf_t[NSLDAPI_NETDB_BUF_SIZE];</span>
<a href="#l13.66"></a><span id="l13.66"> #    define GETHOSTBYNAME_BUF_T GETHOSTBYNAME_buf_t</span>
<a href="#l13.67"></a><span id="l13.67" class="difflineat">@@ -324,24 +324,24 @@ typedef char GETHOSTBYNAME_buf_t[NSLDAPI</span>
<a href="#l13.68"></a><span id="l13.68"> #  if defined(hpux9) || defined(SUNOS4) || defined(SNI) || defined(SCOOS) || \</span>
<a href="#l13.69"></a><span id="l13.69">       defined(BSDI) || defined(NCR) || defined(VMS) || defined(NEC) ||       \</span>
<a href="#l13.70"></a><span id="l13.70">       (defined(LINUX) &amp;&amp; __GNU_LIBRARY__ != 6) ||                            \</span>
<a href="#l13.71"></a><span id="l13.71">       (defined(AIX) &amp;&amp; !defined(USE_REENTRANT_LIBC))</span>
<a href="#l13.72"></a><span id="l13.72"> #    define STRTOK(s1, s2, l) strtok(s1, s2)</span>
<a href="#l13.73"></a><span id="l13.73"> #  else</span>
<a href="#l13.74"></a><span id="l13.74"> #    define HAVE_STRTOK_R</span>
<a href="#l13.75"></a><span id="l13.75"> #    ifndef strtok_r</span>
<a href="#l13.76"></a><span id="l13.76" class="difflineminus">-char *strtok_r(char *, const char *, char **);</span>
<a href="#l13.77"></a><span id="l13.77" class="difflineplus">+char* strtok_r(char*, const char*, char**);</span>
<a href="#l13.78"></a><span id="l13.78"> #    endif</span>
<a href="#l13.79"></a><span id="l13.79" class="difflineminus">-#    define STRTOK(s1, s2, l) (char *)strtok_r(s1, s2, l)</span>
<a href="#l13.80"></a><span id="l13.80" class="difflineplus">+#    define STRTOK(s1, s2, l) (char*)strtok_r(s1, s2, l)</span>
<a href="#l13.81"></a><span id="l13.81"> #  endif /* STRTOK */</span>
<a href="#l13.82"></a><span id="l13.82"> #endif   /* UNIX */</span>
<a href="#l13.83"></a><span id="l13.83"> </span>
<a href="#l13.84"></a><span id="l13.84"> #if defined(ultrix) || defined(nextstep)</span>
<a href="#l13.85"></a><span id="l13.85" class="difflineminus">-extern char *strdup();</span>
<a href="#l13.86"></a><span id="l13.86" class="difflineplus">+extern char* strdup();</span>
<a href="#l13.87"></a><span id="l13.87"> #endif /* ultrix || nextstep */</span>
<a href="#l13.88"></a><span id="l13.88"> </span>
<a href="#l13.89"></a><span id="l13.89"> #if defined(sunos4) || defined(OSF1)</span>
<a href="#l13.90"></a><span id="l13.90"> #  define BSD_TIME 1 /* for servers/slapd/log.h */</span>
<a href="#l13.91"></a><span id="l13.91"> #endif               /* sunos4 || osf */</span>
<a href="#l13.92"></a><span id="l13.92"> </span>
<a href="#l13.93"></a><span id="l13.93"> #if defined(XP_OS2)</span>
<a href="#l13.94"></a><span id="l13.94"> #  include &lt;machine/endian.h&gt; /* for htonl, et.al. */</span>
<a href="#l13.95"></a><span id="l13.95" class="difflineat">@@ -371,41 +371,41 @@ typedef unsigned long nsldapi_uint_32;</span>
<a href="#l13.96"></a><span id="l13.96"> #if defined(_IN_ADDR_T) || defined(aix) || defined(HPUX11) || defined(OSF1)</span>
<a href="#l13.97"></a><span id="l13.97"> typedef in_addr_t nsldapi_in_addr_t;</span>
<a href="#l13.98"></a><span id="l13.98"> #else</span>
<a href="#l13.99"></a><span id="l13.99"> typedef nsldapi_uint_32 nsldapi_in_addr_t;</span>
<a href="#l13.100"></a><span id="l13.100"> #endif</span>
<a href="#l13.101"></a><span id="l13.101"> </span>
<a href="#l13.102"></a><span id="l13.102"> #ifdef SUNOS4</span>
<a href="#l13.103"></a><span id="l13.103"> #  include &lt;pcfs/pc_dir.h&gt; /* for toupper() */</span>
<a href="#l13.104"></a><span id="l13.104" class="difflineminus">-int fprintf(FILE *, char *, ...);</span>
<a href="#l13.105"></a><span id="l13.105" class="difflineminus">-int fseek(FILE *, long, int);</span>
<a href="#l13.106"></a><span id="l13.106" class="difflineminus">-int fread(char *, int, int, FILE *);</span>
<a href="#l13.107"></a><span id="l13.107" class="difflineminus">-int fclose(FILE *);</span>
<a href="#l13.108"></a><span id="l13.108" class="difflineminus">-int fflush(FILE *);</span>
<a href="#l13.109"></a><span id="l13.109" class="difflineminus">-int rewind(FILE *);</span>
<a href="#l13.110"></a><span id="l13.110" class="difflineminus">-void *memmove(void *, const void *, size_t);</span>
<a href="#l13.111"></a><span id="l13.111" class="difflineminus">-int strcasecmp(char *, char *);</span>
<a href="#l13.112"></a><span id="l13.112" class="difflineminus">-int strncasecmp(char *, char *, int);</span>
<a href="#l13.113"></a><span id="l13.113" class="difflineminus">-time_t time(time_t *);</span>
<a href="#l13.114"></a><span id="l13.114" class="difflineminus">-void perror(char *);</span>
<a href="#l13.115"></a><span id="l13.115" class="difflineminus">-int fputc(char, FILE *);</span>
<a href="#l13.116"></a><span id="l13.116" class="difflineminus">-int fputs(char *, FILE *);</span>
<a href="#l13.117"></a><span id="l13.117" class="difflineminus">-int re_exec(char *);</span>
<a href="#l13.118"></a><span id="l13.118" class="difflineplus">+int fprintf(FILE*, char*, ...);</span>
<a href="#l13.119"></a><span id="l13.119" class="difflineplus">+int fseek(FILE*, long, int);</span>
<a href="#l13.120"></a><span id="l13.120" class="difflineplus">+int fread(char*, int, int, FILE*);</span>
<a href="#l13.121"></a><span id="l13.121" class="difflineplus">+int fclose(FILE*);</span>
<a href="#l13.122"></a><span id="l13.122" class="difflineplus">+int fflush(FILE*);</span>
<a href="#l13.123"></a><span id="l13.123" class="difflineplus">+int rewind(FILE*);</span>
<a href="#l13.124"></a><span id="l13.124" class="difflineplus">+void* memmove(void*, const void*, size_t);</span>
<a href="#l13.125"></a><span id="l13.125" class="difflineplus">+int strcasecmp(char*, char*);</span>
<a href="#l13.126"></a><span id="l13.126" class="difflineplus">+int strncasecmp(char*, char*, int);</span>
<a href="#l13.127"></a><span id="l13.127" class="difflineplus">+time_t time(time_t*);</span>
<a href="#l13.128"></a><span id="l13.128" class="difflineplus">+void perror(char*);</span>
<a href="#l13.129"></a><span id="l13.129" class="difflineplus">+int fputc(char, FILE*);</span>
<a href="#l13.130"></a><span id="l13.130" class="difflineplus">+int fputs(char*, FILE*);</span>
<a href="#l13.131"></a><span id="l13.131" class="difflineplus">+int re_exec(char*);</span>
<a href="#l13.132"></a><span id="l13.132"> int socket(int, int, int);</span>
<a href="#l13.133"></a><span id="l13.133" class="difflineminus">-void bzero(char *, int);</span>
<a href="#l13.134"></a><span id="l13.134" class="difflineminus">-unsigned long inet_addr(char *);</span>
<a href="#l13.135"></a><span id="l13.135" class="difflineminus">-char *inet_ntoa(struct in_addr);</span>
<a href="#l13.136"></a><span id="l13.136" class="difflineplus">+void bzero(char*, int);</span>
<a href="#l13.137"></a><span id="l13.137" class="difflineplus">+unsigned long inet_addr(char*);</span>
<a href="#l13.138"></a><span id="l13.138" class="difflineplus">+char* inet_ntoa(struct in_addr);</span>
<a href="#l13.139"></a><span id="l13.139"> int getdtablesize();</span>
<a href="#l13.140"></a><span id="l13.140" class="difflineminus">-int connect(int, struct sockaddr *, int);</span>
<a href="#l13.141"></a><span id="l13.141" class="difflineplus">+int connect(int, struct sockaddr*, int);</span>
<a href="#l13.142"></a><span id="l13.142"> #endif /* SUNOS4 */</span>
<a href="#l13.143"></a><span id="l13.143"> </span>
<a href="#l13.144"></a><span id="l13.144"> /* #if defined(SUNOS4) || defined(SNI) */</span>
<a href="#l13.145"></a><span id="l13.145"> #if defined(SUNOS4)</span>
<a href="#l13.146"></a><span id="l13.146" class="difflineminus">-int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);</span>
<a href="#l13.147"></a><span id="l13.147" class="difflineplus">+int select(int, fd_set*, fd_set*, fd_set*, struct timeval*);</span>
<a href="#l13.148"></a><span id="l13.148"> #endif /* SUNOS4 || SNI */</span>
<a href="#l13.149"></a><span id="l13.149"> </span>
<a href="#l13.150"></a><span id="l13.150"> /*</span>
<a href="#l13.151"></a><span id="l13.151">  * SAFEMEMCPY is an overlap-safe copy from s to d of n bytes</span>
<a href="#l13.152"></a><span id="l13.152">  */</span>
<a href="#l13.153"></a><span id="l13.153"> #ifdef macintosh</span>
<a href="#l13.154"></a><span id="l13.154"> #  define SAFEMEMCPY(d, s, n) BlockMoveData((Ptr)s, (Ptr)d, n)</span>
<a href="#l13.155"></a><span id="l13.155"> #else /* macintosh */</span>
<a href="#l13.156"></a><span id="l13.156" class="difflineat">@@ -446,15 +446,15 @@ int select(int, fd_set *, fd_set *, fd_s</span>
<a href="#l13.157"></a><span id="l13.157"> /* Define a macro to support large files */</span>
<a href="#l13.158"></a><span id="l13.158"> #ifdef _LARGEFILE64_SOURCE</span>
<a href="#l13.159"></a><span id="l13.159"> #  define NSLDAPI_FOPEN(filename, mode) fopen64(filename, mode)</span>
<a href="#l13.160"></a><span id="l13.160"> #else</span>
<a href="#l13.161"></a><span id="l13.161"> #  define NSLDAPI_FOPEN(filename, mode) fopen(filename, mode)</span>
<a href="#l13.162"></a><span id="l13.162"> #endif</span>
<a href="#l13.163"></a><span id="l13.163"> </span>
<a href="#l13.164"></a><span id="l13.164"> #if defined(LINUX) || defined(AIX) || defined(HPUX) || defined(_WINDOWS)</span>
<a href="#l13.165"></a><span id="l13.165" class="difflineminus">-size_t nsldapi_compat_strlcpy(char *dst, const char *src, size_t len);</span>
<a href="#l13.166"></a><span id="l13.166" class="difflineplus">+size_t nsldapi_compat_strlcpy(char* dst, const char* src, size_t len);</span>
<a href="#l13.167"></a><span id="l13.167"> #  define STRLCPY nsldapi_compat_strlcpy</span>
<a href="#l13.168"></a><span id="l13.168"> #else</span>
<a href="#l13.169"></a><span id="l13.169"> #  define STRLCPY strlcpy</span>
<a href="#l13.170"></a><span id="l13.170"> #endif</span>
<a href="#l13.171"></a><span id="l13.171"> </span>
<a href="#l13.172"></a><span id="l13.172"> #endif /* _PORTABLE_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/ldap/c-sdk/include/proto-ntutil.h</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/ldap/c-sdk/include/proto-ntutil.h</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -54,46 +54,46 @@</span>
<a href="#l14.4"></a><span id="l14.4"> extern int SlapdGetRegSZ(LPTSTR lpszRegKey, LPSTR lpszValueName,</span>
<a href="#l14.5"></a><span id="l14.5">                          LPTSTR lpszValue);</span>
<a href="#l14.6"></a><span id="l14.6"> </span>
<a href="#l14.7"></a><span id="l14.7"> /*</span>
<a href="#l14.8"></a><span id="l14.8">  *</span>
<a href="#l14.9"></a><span id="l14.9">  * getopt.c</span>
<a href="#l14.10"></a><span id="l14.10">  *</span>
<a href="#l14.11"></a><span id="l14.11">  */</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-extern int getopt(int argc, char *const *argv, const char *optstring);</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+extern int getopt(int argc, char* const* argv, const char* optstring);</span>
<a href="#l14.14"></a><span id="l14.14"> </span>
<a href="#l14.15"></a><span id="l14.15"> /*</span>
<a href="#l14.16"></a><span id="l14.16">  *</span>
<a href="#l14.17"></a><span id="l14.17">  * ntevent.c</span>
<a href="#l14.18"></a><span id="l14.18">  *</span>
<a href="#l14.19"></a><span id="l14.19">  */</span>
<a href="#l14.20"></a><span id="l14.20"> extern BOOL MultipleInstances();</span>
<a href="#l14.21"></a><span id="l14.21"> extern BOOL SlapdIsAService();</span>
<a href="#l14.22"></a><span id="l14.22"> extern void InitializeSlapdLogging(LPTSTR lpszRegLocation,</span>
<a href="#l14.23"></a><span id="l14.23">                                    LPTSTR lpszEventLogName,</span>
<a href="#l14.24"></a><span id="l14.24">                                    LPTSTR lpszMessageFile);</span>
<a href="#l14.25"></a><span id="l14.25"> extern void ReportSlapdEvent(WORD wEventType, DWORD dwIdEvent,</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineminus">-                             WORD wNumInsertStrings, char *pszStrings);</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineminus">-extern BOOL ReportSlapdStatusToSCMgr(SERVICE_STATUS *serviceStatus,</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineplus">+                             WORD wNumInsertStrings, char* pszStrings);</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineplus">+extern BOOL ReportSlapdStatusToSCMgr(SERVICE_STATUS* serviceStatus,</span>
<a href="#l14.30"></a><span id="l14.30">                                      SERVICE_STATUS_HANDLE serviceStatusHandle,</span>
<a href="#l14.31"></a><span id="l14.31">                                      HANDLE Event, DWORD dwCurrentState,</span>
<a href="#l14.32"></a><span id="l14.32">                                      DWORD dwWin32ExitCode, DWORD dwCheckPoint,</span>
<a href="#l14.33"></a><span id="l14.33">                                      DWORD dwWaitHint);</span>
<a href="#l14.34"></a><span id="l14.34"> extern void WINAPI SlapdServiceCtrlHandler(DWORD dwOpcode);</span>
<a href="#l14.35"></a><span id="l14.35" class="difflineminus">-extern BOOL SlapdGetServerNameFromCmdline(char *szServerName, char *szCmdLine);</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineplus">+extern BOOL SlapdGetServerNameFromCmdline(char* szServerName, char* szCmdLine);</span>
<a href="#l14.37"></a><span id="l14.37"> </span>
<a href="#l14.38"></a><span id="l14.38"> /*</span>
<a href="#l14.39"></a><span id="l14.39">  *</span>
<a href="#l14.40"></a><span id="l14.40">  * ntgetpassword.c</span>
<a href="#l14.41"></a><span id="l14.41">  *</span>
<a href="#l14.42"></a><span id="l14.42">  */</span>
<a href="#l14.43"></a><span id="l14.43"> #    ifdef NET_SSL</span>
<a href="#l14.44"></a><span id="l14.44" class="difflineminus">-extern char *Slapd_GetPassword();</span>
<a href="#l14.45"></a><span id="l14.45" class="difflineplus">+extern char* Slapd_GetPassword();</span>
<a href="#l14.46"></a><span id="l14.46"> #      ifdef FORTEZZA</span>
<a href="#l14.47"></a><span id="l14.47" class="difflineminus">-extern char *Slapd_GetFortezzaPIN();</span>
<a href="#l14.48"></a><span id="l14.48" class="difflineplus">+extern char* Slapd_GetFortezzaPIN();</span>
<a href="#l14.49"></a><span id="l14.49"> #      endif</span>
<a href="#l14.50"></a><span id="l14.50"> extern void CenterDialog(HWND hwndParent, HWND hwndDialog);</span>
<a href="#l14.51"></a><span id="l14.51"> #    endif /* NET_SSL */</span>
<a href="#l14.52"></a><span id="l14.52"> </span>
<a href="#l14.53"></a><span id="l14.53"> #  endif /* _PROTO_NTUTIL */</span>
<a href="#l14.54"></a><span id="l14.54"> </span>
<a href="#l14.55"></a><span id="l14.55"> #endif /* _WINDOWS */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/ldap/c-sdk/include/regex.h</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/ldap/c-sdk/include/regex.h</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -69,20 +69,20 @@ extern &quot;C&quot; {</span>
<a href="#l15.4"></a><span id="l15.4"> #      define LDAP_CALL</span>
<a href="#l15.5"></a><span id="l15.5"> #    endif</span>
<a href="#l15.6"></a><span id="l15.6"> #  endif</span>
<a href="#l15.7"></a><span id="l15.7"> </span>
<a href="#l15.8"></a><span id="l15.8"> #  ifdef NEEDPROTOS</span>
<a href="#l15.9"></a><span id="l15.9"> int re_init(void);</span>
<a href="#l15.10"></a><span id="l15.10"> void re_lock(void);</span>
<a href="#l15.11"></a><span id="l15.11"> int re_unlock(void);</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-char *LDAP_CALL re_comp(const char *pat);</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineminus">-int LDAP_CALL re_exec(const char *lp);</span>
<a href="#l15.14"></a><span id="l15.14" class="difflineminus">-void LDAP_CALL re_modw(char *s);</span>
<a href="#l15.15"></a><span id="l15.15" class="difflineminus">-int LDAP_CALL re_subs(char *src, char *dst);</span>
<a href="#l15.16"></a><span id="l15.16" class="difflineplus">+char* LDAP_CALL re_comp(const char* pat);</span>
<a href="#l15.17"></a><span id="l15.17" class="difflineplus">+int LDAP_CALL re_exec(const char* lp);</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineplus">+void LDAP_CALL re_modw(char* s);</span>
<a href="#l15.19"></a><span id="l15.19" class="difflineplus">+int LDAP_CALL re_subs(char* src, char* dst);</span>
<a href="#l15.20"></a><span id="l15.20"> #  else  /* NEEDPROTOS */</span>
<a href="#l15.21"></a><span id="l15.21"> int re_init();</span>
<a href="#l15.22"></a><span id="l15.22"> void re_lock();</span>
<a href="#l15.23"></a><span id="l15.23"> int re_unlock();</span>
<a href="#l15.24"></a><span id="l15.24"> char* LDAP_CALL re_comp();</span>
<a href="#l15.25"></a><span id="l15.25"> int LDAP_CALL re_exec();</span>
<a href="#l15.26"></a><span id="l15.26"> void LDAP_CALL re_modw();</span>
<a href="#l15.27"></a><span id="l15.27"> int LDAP_CALL re_subs();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/ldap/c-sdk/include/srchpref.h</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/ldap/c-sdk/include/srchpref.h</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -72,46 +72,46 @@ extern &quot;C&quot; {</span>
<a href="#l16.4"></a><span id="l16.4"> #    define LDAP_C</span>
<a href="#l16.5"></a><span id="l16.5"> #    define LDAP_CALLBACK</span>
<a href="#l16.6"></a><span id="l16.6"> #    define LDAP_PASCAL</span>
<a href="#l16.7"></a><span id="l16.7"> #    define LDAP_CALL</span>
<a href="#l16.8"></a><span id="l16.8"> #  endif /* _WINDOWS */</span>
<a href="#l16.9"></a><span id="l16.9"> #endif   /* LDAP_CALL */</span>
<a href="#l16.10"></a><span id="l16.10"> </span>
<a href="#l16.11"></a><span id="l16.11"> struct ldap_searchattr {</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-  char *sa_attrlabel;</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineminus">-  char *sa_attr;</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineplus">+  char* sa_attrlabel;</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineplus">+  char* sa_attr;</span>
<a href="#l16.16"></a><span id="l16.16">   /* max 32 matchtypes for now */</span>
<a href="#l16.17"></a><span id="l16.17">   unsigned long sa_matchtypebitmap;</span>
<a href="#l16.18"></a><span id="l16.18" class="difflineminus">-  char *sa_selectattr;</span>
<a href="#l16.19"></a><span id="l16.19" class="difflineminus">-  char *sa_selecttext;</span>
<a href="#l16.20"></a><span id="l16.20" class="difflineminus">-  struct ldap_searchattr *sa_next;</span>
<a href="#l16.21"></a><span id="l16.21" class="difflineplus">+  char* sa_selectattr;</span>
<a href="#l16.22"></a><span id="l16.22" class="difflineplus">+  char* sa_selecttext;</span>
<a href="#l16.23"></a><span id="l16.23" class="difflineplus">+  struct ldap_searchattr* sa_next;</span>
<a href="#l16.24"></a><span id="l16.24"> };</span>
<a href="#l16.25"></a><span id="l16.25"> </span>
<a href="#l16.26"></a><span id="l16.26"> struct ldap_searchmatch {</span>
<a href="#l16.27"></a><span id="l16.27" class="difflineminus">-  char *sm_matchprompt;</span>
<a href="#l16.28"></a><span id="l16.28" class="difflineminus">-  char *sm_filter;</span>
<a href="#l16.29"></a><span id="l16.29" class="difflineminus">-  struct ldap_searchmatch *sm_next;</span>
<a href="#l16.30"></a><span id="l16.30" class="difflineplus">+  char* sm_matchprompt;</span>
<a href="#l16.31"></a><span id="l16.31" class="difflineplus">+  char* sm_filter;</span>
<a href="#l16.32"></a><span id="l16.32" class="difflineplus">+  struct ldap_searchmatch* sm_next;</span>
<a href="#l16.33"></a><span id="l16.33"> };</span>
<a href="#l16.34"></a><span id="l16.34"> </span>
<a href="#l16.35"></a><span id="l16.35"> struct ldap_searchobj {</span>
<a href="#l16.36"></a><span id="l16.36" class="difflineminus">-  char *so_objtypeprompt;</span>
<a href="#l16.37"></a><span id="l16.37" class="difflineplus">+  char* so_objtypeprompt;</span>
<a href="#l16.38"></a><span id="l16.38">   unsigned long so_options;</span>
<a href="#l16.39"></a><span id="l16.39" class="difflineminus">-  char *so_prompt;</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineplus">+  char* so_prompt;</span>
<a href="#l16.41"></a><span id="l16.41">   short so_defaultscope;</span>
<a href="#l16.42"></a><span id="l16.42" class="difflineminus">-  char *so_filterprefix;</span>
<a href="#l16.43"></a><span id="l16.43" class="difflineminus">-  char *so_filtertag;</span>
<a href="#l16.44"></a><span id="l16.44" class="difflineminus">-  char *so_defaultselectattr;</span>
<a href="#l16.45"></a><span id="l16.45" class="difflineminus">-  char *so_defaultselecttext;</span>
<a href="#l16.46"></a><span id="l16.46" class="difflineminus">-  struct ldap_searchattr *so_salist;</span>
<a href="#l16.47"></a><span id="l16.47" class="difflineminus">-  struct ldap_searchmatch *so_smlist;</span>
<a href="#l16.48"></a><span id="l16.48" class="difflineminus">-  struct ldap_searchobj *so_next;</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineplus">+  char* so_filterprefix;</span>
<a href="#l16.50"></a><span id="l16.50" class="difflineplus">+  char* so_filtertag;</span>
<a href="#l16.51"></a><span id="l16.51" class="difflineplus">+  char* so_defaultselectattr;</span>
<a href="#l16.52"></a><span id="l16.52" class="difflineplus">+  char* so_defaultselecttext;</span>
<a href="#l16.53"></a><span id="l16.53" class="difflineplus">+  struct ldap_searchattr* so_salist;</span>
<a href="#l16.54"></a><span id="l16.54" class="difflineplus">+  struct ldap_searchmatch* so_smlist;</span>
<a href="#l16.55"></a><span id="l16.55" class="difflineplus">+  struct ldap_searchobj* so_next;</span>
<a href="#l16.56"></a><span id="l16.56"> };</span>
<a href="#l16.57"></a><span id="l16.57"> </span>
<a href="#l16.58"></a><span id="l16.58" class="difflineminus">-#define NULLSEARCHOBJ ((struct ldap_searchobj *)0)</span>
<a href="#l16.59"></a><span id="l16.59" class="difflineplus">+#define NULLSEARCHOBJ ((struct ldap_searchobj*)0)</span>
<a href="#l16.60"></a><span id="l16.60"> </span>
<a href="#l16.61"></a><span id="l16.61"> /*</span>
<a href="#l16.62"></a><span id="l16.62">  * global search object options</span>
<a href="#l16.63"></a><span id="l16.63">  */</span>
<a href="#l16.64"></a><span id="l16.64"> #define LDAP_SEARCHOBJ_OPT_INTERNAL 0x00000001</span>
<a href="#l16.65"></a><span id="l16.65"> </span>
<a href="#l16.66"></a><span id="l16.66"> #define LDAP_IS_SEARCHOBJ_OPTION_SET(so, option) \</span>
<a href="#l16.67"></a><span id="l16.67">   (((so)-&gt;so_options &amp; option) != 0)</span>
<a href="#l16.68"></a><span id="l16.68" class="difflineat">@@ -121,31 +121,31 @@ struct ldap_searchobj {</span>
<a href="#l16.69"></a><span id="l16.69"> </span>
<a href="#l16.70"></a><span id="l16.70"> #define LDAP_SEARCHPREF_ERR_VERSION 1</span>
<a href="#l16.71"></a><span id="l16.71"> #define LDAP_SEARCHPREF_ERR_MEM 2</span>
<a href="#l16.72"></a><span id="l16.72"> #define LDAP_SEARCHPREF_ERR_SYNTAX 3</span>
<a href="#l16.73"></a><span id="l16.73"> #define LDAP_SEARCHPREF_ERR_FILE 4</span>
<a href="#l16.74"></a><span id="l16.74"> </span>
<a href="#l16.75"></a><span id="l16.75"> LDAP_API(int)</span>
<a href="#l16.76"></a><span id="l16.76"> LDAP_CALL</span>
<a href="#l16.77"></a><span id="l16.77" class="difflineminus">-ldap_init_searchprefs(char *file, struct ldap_searchobj **solistp);</span>
<a href="#l16.78"></a><span id="l16.78" class="difflineplus">+ldap_init_searchprefs(char* file, struct ldap_searchobj** solistp);</span>
<a href="#l16.79"></a><span id="l16.79"> </span>
<a href="#l16.80"></a><span id="l16.80"> LDAP_API(int)</span>
<a href="#l16.81"></a><span id="l16.81"> LDAP_CALL</span>
<a href="#l16.82"></a><span id="l16.82" class="difflineminus">-ldap_init_searchprefs_buf(char *buf, long buflen,</span>
<a href="#l16.83"></a><span id="l16.83" class="difflineminus">-                          struct ldap_searchobj **solistp);</span>
<a href="#l16.84"></a><span id="l16.84" class="difflineplus">+ldap_init_searchprefs_buf(char* buf, long buflen,</span>
<a href="#l16.85"></a><span id="l16.85" class="difflineplus">+                          struct ldap_searchobj** solistp);</span>
<a href="#l16.86"></a><span id="l16.86"> </span>
<a href="#l16.87"></a><span id="l16.87"> LDAP_API(void)</span>
<a href="#l16.88"></a><span id="l16.88"> LDAP_CALL</span>
<a href="#l16.89"></a><span id="l16.89" class="difflineminus">-ldap_free_searchprefs(struct ldap_searchobj *solist);</span>
<a href="#l16.90"></a><span id="l16.90" class="difflineplus">+ldap_free_searchprefs(struct ldap_searchobj* solist);</span>
<a href="#l16.91"></a><span id="l16.91"> </span>
<a href="#l16.92"></a><span id="l16.92" class="difflineminus">-LDAP_API(struct ldap_searchobj *)</span>
<a href="#l16.93"></a><span id="l16.93" class="difflineplus">+LDAP_API(struct ldap_searchobj*)</span>
<a href="#l16.94"></a><span id="l16.94"> LDAP_CALL</span>
<a href="#l16.95"></a><span id="l16.95" class="difflineminus">-ldap_first_searchobj(struct ldap_searchobj *solist);</span>
<a href="#l16.96"></a><span id="l16.96" class="difflineplus">+ldap_first_searchobj(struct ldap_searchobj* solist);</span>
<a href="#l16.97"></a><span id="l16.97"> </span>
<a href="#l16.98"></a><span id="l16.98" class="difflineminus">-LDAP_API(struct ldap_searchobj *)</span>
<a href="#l16.99"></a><span id="l16.99" class="difflineplus">+LDAP_API(struct ldap_searchobj*)</span>
<a href="#l16.100"></a><span id="l16.100"> LDAP_CALL</span>
<a href="#l16.101"></a><span id="l16.101" class="difflineminus">-ldap_next_searchobj(struct ldap_searchobj *sollist, struct ldap_searchobj *so);</span>
<a href="#l16.102"></a><span id="l16.102" class="difflineplus">+ldap_next_searchobj(struct ldap_searchobj* sollist, struct ldap_searchobj* so);</span>
<a href="#l16.103"></a><span id="l16.103"> </span>
<a href="#l16.104"></a><span id="l16.104"> #ifdef __cplusplus</span>
<a href="#l16.105"></a><span id="l16.105"> }</span>
<a href="#l16.106"></a><span id="l16.106"> #endif</span>
<a href="#l16.107"></a><span id="l16.107"> #endif /* _SRCHPREF_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/bprint.c</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/bprint.c</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -41,17 +41,17 @@</span>
<a href="#l17.4"></a><span id="l17.4"> </span>
<a href="#l17.5"></a><span id="l17.5"> #ifdef LDAP_DEBUG</span>
<a href="#l17.6"></a><span id="l17.6"> /*</span>
<a href="#l17.7"></a><span id="l17.7">  * Print arbitrary stuff, for debugging.</span>
<a href="#l17.8"></a><span id="l17.8">  */</span>
<a href="#l17.9"></a><span id="l17.9"> </span>
<a href="#l17.10"></a><span id="l17.10"> #  define BPLEN 48</span>
<a href="#l17.11"></a><span id="l17.11"> </span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-void lber_bprint(char *data, int len) {</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+void lber_bprint(char* data, int len) {</span>
<a href="#l17.14"></a><span id="l17.14">   static char hexdig[] = &quot;0123456789abcdef&quot;;</span>
<a href="#l17.15"></a><span id="l17.15">   char out[BPLEN];</span>
<a href="#l17.16"></a><span id="l17.16">   int i = 0;</span>
<a href="#l17.17"></a><span id="l17.17"> </span>
<a href="#l17.18"></a><span id="l17.18">   memset(out, 0, BPLEN);</span>
<a href="#l17.19"></a><span id="l17.19">   for (;;) {</span>
<a href="#l17.20"></a><span id="l17.20">     if (len &lt; 1) {</span>
<a href="#l17.21"></a><span id="l17.21">       char msg[BPLEN + 80];</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineat">@@ -84,16 +84,16 @@ void lber_bprint(char *data, int len) {</span>
<a href="#l17.23"></a><span id="l17.23">       continue;</span>
<a href="#l17.24"></a><span id="l17.24">     }</span>
<a href="#l17.25"></a><span id="l17.25">     out[i++] = ' ';</span>
<a href="#l17.26"></a><span id="l17.26">   }</span>
<a href="#l17.27"></a><span id="l17.27"> }</span>
<a href="#l17.28"></a><span id="l17.28"> </span>
<a href="#l17.29"></a><span id="l17.29"> #endif</span>
<a href="#l17.30"></a><span id="l17.30"> </span>
<a href="#l17.31"></a><span id="l17.31" class="difflineminus">-void ber_err_print(char *data) {</span>
<a href="#l17.32"></a><span id="l17.32" class="difflineplus">+void ber_err_print(char* data) {</span>
<a href="#l17.33"></a><span id="l17.33"> #ifdef USE_DEBUG_WIN</span>
<a href="#l17.34"></a><span id="l17.34">   OutputDebugString(data);</span>
<a href="#l17.35"></a><span id="l17.35"> #else</span>
<a href="#l17.36"></a><span id="l17.36">   fputs(data, stderr);</span>
<a href="#l17.37"></a><span id="l17.37">   fflush(stderr);</span>
<a href="#l17.38"></a><span id="l17.38"> #endif</span>
<a href="#l17.39"></a><span id="l17.39"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/decode.c</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/decode.c</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -52,31 +52,31 @@</span>
<a href="#l18.4"></a><span id="l18.4"> #include &quot;lber-int.h&quot;</span>
<a href="#l18.5"></a><span id="l18.5"> </span>
<a href="#l18.6"></a><span id="l18.6"> /*</span>
<a href="#l18.7"></a><span id="l18.7">  * Note: ber_get_tag() only uses the ber_end and ber_ptr elements of ber.</span>
<a href="#l18.8"></a><span id="l18.8">  * If that changes, the ber_peek_tag() and/or ber_skip_tag() implementations</span>
<a href="#l18.9"></a><span id="l18.9">  * will need to be changed.</span>
<a href="#l18.10"></a><span id="l18.10">  */</span>
<a href="#l18.11"></a><span id="l18.11"> /* return the tag - LBER_DEFAULT returned means trouble */</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-ber_tag_t LDAP_CALL ber_get_tag(BerElement *ber) {</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+ber_tag_t LDAP_CALL ber_get_tag(BerElement* ber) {</span>
<a href="#l18.14"></a><span id="l18.14">   unsigned char xbyte;</span>
<a href="#l18.15"></a><span id="l18.15">   ber_tag_t tag;</span>
<a href="#l18.16"></a><span id="l18.16" class="difflineminus">-  char *tagp;</span>
<a href="#l18.17"></a><span id="l18.17" class="difflineplus">+  char* tagp;</span>
<a href="#l18.18"></a><span id="l18.18">   int i;</span>
<a href="#l18.19"></a><span id="l18.19"> </span>
<a href="#l18.20"></a><span id="l18.20" class="difflineminus">-  if (ber_read(ber, (char *)&amp;xbyte, 1) != 1) return (LBER_DEFAULT);</span>
<a href="#l18.21"></a><span id="l18.21" class="difflineplus">+  if (ber_read(ber, (char*)&amp;xbyte, 1) != 1) return (LBER_DEFAULT);</span>
<a href="#l18.22"></a><span id="l18.22"> </span>
<a href="#l18.23"></a><span id="l18.23">   if ((xbyte &amp; LBER_BIG_TAG_MASK) != LBER_BIG_TAG_MASK)</span>
<a href="#l18.24"></a><span id="l18.24">     return ((ber_uint_t)xbyte);</span>
<a href="#l18.25"></a><span id="l18.25"> </span>
<a href="#l18.26"></a><span id="l18.26" class="difflineminus">-  tagp = (char *)&amp;tag;</span>
<a href="#l18.27"></a><span id="l18.27" class="difflineplus">+  tagp = (char*)&amp;tag;</span>
<a href="#l18.28"></a><span id="l18.28">   tagp[0] = xbyte;</span>
<a href="#l18.29"></a><span id="l18.29">   for (i = 1; i &lt; sizeof(ber_int_t); i++) {</span>
<a href="#l18.30"></a><span id="l18.30" class="difflineminus">-    if (ber_read(ber, (char *)&amp;xbyte, 1) != 1) return (LBER_DEFAULT);</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineplus">+    if (ber_read(ber, (char*)&amp;xbyte, 1) != 1) return (LBER_DEFAULT);</span>
<a href="#l18.32"></a><span id="l18.32"> </span>
<a href="#l18.33"></a><span id="l18.33">     tagp[i] = xbyte;</span>
<a href="#l18.34"></a><span id="l18.34"> </span>
<a href="#l18.35"></a><span id="l18.35">     if (!(xbyte &amp; LBER_MORE_TAG_MASK)) break;</span>
<a href="#l18.36"></a><span id="l18.36">   }</span>
<a href="#l18.37"></a><span id="l18.37"> </span>
<a href="#l18.38"></a><span id="l18.38">   /* tag too big! */</span>
<a href="#l18.39"></a><span id="l18.39">   if (i == sizeof(ber_int_t)) return (LBER_DEFAULT);</span>
<a href="#l18.40"></a><span id="l18.40" class="difflineat">@@ -85,17 +85,17 @@ ber_tag_t LDAP_CALL ber_get_tag(BerEleme</span>
<a href="#l18.41"></a><span id="l18.41">   return (tag &gt;&gt; (sizeof(ber_int_t) - i - 1));</span>
<a href="#l18.42"></a><span id="l18.42"> }</span>
<a href="#l18.43"></a><span id="l18.43"> </span>
<a href="#l18.44"></a><span id="l18.44"> /*</span>
<a href="#l18.45"></a><span id="l18.45">  * Note: ber_skip_tag() only uses the ber_end and ber_ptr elements of ber.</span>
<a href="#l18.46"></a><span id="l18.46">  * If that changes, the implementation of ber_peek_tag() will need to</span>
<a href="#l18.47"></a><span id="l18.47">  * be changed.</span>
<a href="#l18.48"></a><span id="l18.48">  */</span>
<a href="#l18.49"></a><span id="l18.49" class="difflineminus">-ber_tag_t LDAP_CALL ber_skip_tag(BerElement *ber, ber_len_t *len) {</span>
<a href="#l18.50"></a><span id="l18.50" class="difflineplus">+ber_tag_t LDAP_CALL ber_skip_tag(BerElement* ber, ber_len_t* len) {</span>
<a href="#l18.51"></a><span id="l18.51">   ber_tag_t tag;</span>
<a href="#l18.52"></a><span id="l18.52">   unsigned char lc;</span>
<a href="#l18.53"></a><span id="l18.53">   int noctets, diff;</span>
<a href="#l18.54"></a><span id="l18.54">   ber_len_t netlen;</span>
<a href="#l18.55"></a><span id="l18.55"> </span>
<a href="#l18.56"></a><span id="l18.56">   /*</span>
<a href="#l18.57"></a><span id="l18.57">    * Any ber element looks like this: tag length contents.</span>
<a href="#l18.58"></a><span id="l18.58">    * Assuming everything's ok, we return the tag byte (we</span>
<a href="#l18.59"></a><span id="l18.59" class="difflineat">@@ -115,97 +115,97 @@ ber_tag_t LDAP_CALL ber_skip_tag(BerElem</span>
<a href="#l18.60"></a><span id="l18.60">   /*</span>
<a href="#l18.61"></a><span id="l18.61">    * Next, read the length.  The first byte contains the length of</span>
<a href="#l18.62"></a><span id="l18.62">    * the length.  If bit 8 is set, the length is the long form,</span>
<a href="#l18.63"></a><span id="l18.63">    * otherwise it's the short form.  We don't allow a length that's</span>
<a href="#l18.64"></a><span id="l18.64">    * greater than what we can hold in an unsigned long.</span>
<a href="#l18.65"></a><span id="l18.65">    */</span>
<a href="#l18.66"></a><span id="l18.66"> </span>
<a href="#l18.67"></a><span id="l18.67">   *len = netlen = 0;</span>
<a href="#l18.68"></a><span id="l18.68" class="difflineminus">-  if (ber_read(ber, (char *)&amp;lc, 1) != 1) return (LBER_DEFAULT);</span>
<a href="#l18.69"></a><span id="l18.69" class="difflineplus">+  if (ber_read(ber, (char*)&amp;lc, 1) != 1) return (LBER_DEFAULT);</span>
<a href="#l18.70"></a><span id="l18.70">   if (lc &amp; 0x80) {</span>
<a href="#l18.71"></a><span id="l18.71">     noctets = (lc &amp; 0x7f);</span>
<a href="#l18.72"></a><span id="l18.72">     if (noctets &gt; sizeof(ber_uint_t)) return (LBER_DEFAULT);</span>
<a href="#l18.73"></a><span id="l18.73">     diff = sizeof(ber_int_t) - noctets;</span>
<a href="#l18.74"></a><span id="l18.74" class="difflineminus">-    if (ber_read(ber, (char *)&amp;netlen + diff, noctets) != noctets)</span>
<a href="#l18.75"></a><span id="l18.75" class="difflineplus">+    if (ber_read(ber, (char*)&amp;netlen + diff, noctets) != noctets)</span>
<a href="#l18.76"></a><span id="l18.76">       return (LBER_DEFAULT);</span>
<a href="#l18.77"></a><span id="l18.77">     *len = LBER_NTOHL(netlen);</span>
<a href="#l18.78"></a><span id="l18.78">   } else {</span>
<a href="#l18.79"></a><span id="l18.79">     *len = lc;</span>
<a href="#l18.80"></a><span id="l18.80">   }</span>
<a href="#l18.81"></a><span id="l18.81"> </span>
<a href="#l18.82"></a><span id="l18.82">   return (tag);</span>
<a href="#l18.83"></a><span id="l18.83"> }</span>
<a href="#l18.84"></a><span id="l18.84"> </span>
<a href="#l18.85"></a><span id="l18.85"> /*</span>
<a href="#l18.86"></a><span id="l18.86">  * Note: Previously, we passed the &quot;ber&quot; parameter directly to ber_skip_tag(),</span>
<a href="#l18.87"></a><span id="l18.87">  * saving and restoring the ber_ptr element only.  We now take advantage</span>
<a href="#l18.88"></a><span id="l18.88">  * of the fact that the only ber structure elements touched by ber_skip_tag()</span>
<a href="#l18.89"></a><span id="l18.89">  * are ber_end and ber_ptr.  If that changes, this code must change too.</span>
<a href="#l18.90"></a><span id="l18.90">  */</span>
<a href="#l18.91"></a><span id="l18.91" class="difflineminus">-ber_tag_t LDAP_CALL ber_peek_tag(BerElement *ber, ber_len_t *len) {</span>
<a href="#l18.92"></a><span id="l18.92" class="difflineplus">+ber_tag_t LDAP_CALL ber_peek_tag(BerElement* ber, ber_len_t* len) {</span>
<a href="#l18.93"></a><span id="l18.93">   BerElement bercopy;</span>
<a href="#l18.94"></a><span id="l18.94"> </span>
<a href="#l18.95"></a><span id="l18.95">   bercopy.ber_end = ber-&gt;ber_end;</span>
<a href="#l18.96"></a><span id="l18.96">   bercopy.ber_ptr = ber-&gt;ber_ptr;</span>
<a href="#l18.97"></a><span id="l18.97">   return (ber_skip_tag(&amp;bercopy, len));</span>
<a href="#l18.98"></a><span id="l18.98"> }</span>
<a href="#l18.99"></a><span id="l18.99"> </span>
<a href="#l18.100"></a><span id="l18.100" class="difflineminus">-static int ber_getnint(BerElement *ber, ber_int_t *num, ber_slen_t len) {</span>
<a href="#l18.101"></a><span id="l18.101" class="difflineplus">+static int ber_getnint(BerElement* ber, ber_int_t* num, ber_slen_t len) {</span>
<a href="#l18.102"></a><span id="l18.102">   int i;</span>
<a href="#l18.103"></a><span id="l18.103">   ber_int_t value;</span>
<a href="#l18.104"></a><span id="l18.104">   unsigned char buffer[sizeof(ber_int_t)];</span>
<a href="#l18.105"></a><span id="l18.105">   /*</span>
<a href="#l18.106"></a><span id="l18.106">    * The tag and length have already been stripped off.  We should</span>
<a href="#l18.107"></a><span id="l18.107">    * be sitting right before len bytes of 2's complement integer,</span>
<a href="#l18.108"></a><span id="l18.108">    * ready to be read straight into an int.  We may have to sign</span>
<a href="#l18.109"></a><span id="l18.109">    * extend after we read it in.</span>
<a href="#l18.110"></a><span id="l18.110">    */</span>
<a href="#l18.111"></a><span id="l18.111"> </span>
<a href="#l18.112"></a><span id="l18.112">   if (len &gt; sizeof(ber_slen_t)) return (-1);</span>
<a href="#l18.113"></a><span id="l18.113"> </span>
<a href="#l18.114"></a><span id="l18.114">   /* read into the low-order bytes of netnum */</span>
<a href="#l18.115"></a><span id="l18.115" class="difflineminus">-  if (ber_read(ber, (char *)buffer, len) != len) return (-1);</span>
<a href="#l18.116"></a><span id="l18.116" class="difflineplus">+  if (ber_read(ber, (char*)buffer, len) != len) return (-1);</span>
<a href="#l18.117"></a><span id="l18.117"> </span>
<a href="#l18.118"></a><span id="l18.118">   /* This sets the required sign extension */</span>
<a href="#l18.119"></a><span id="l18.119">   if (len != 0) {</span>
<a href="#l18.120"></a><span id="l18.120">     value = 0x80 &amp; buffer[0] ? (-1) : 0;</span>
<a href="#l18.121"></a><span id="l18.121">   } else {</span>
<a href="#l18.122"></a><span id="l18.122">     value = 0;</span>
<a href="#l18.123"></a><span id="l18.123">   }</span>
<a href="#l18.124"></a><span id="l18.124"> </span>
<a href="#l18.125"></a><span id="l18.125">   for (i = 0; i &lt; len; i++) value = (value &lt;&lt; 8) | buffer[i];</span>
<a href="#l18.126"></a><span id="l18.126"> </span>
<a href="#l18.127"></a><span id="l18.127">   *num = value;</span>
<a href="#l18.128"></a><span id="l18.128"> </span>
<a href="#l18.129"></a><span id="l18.129">   return (len);</span>
<a href="#l18.130"></a><span id="l18.130"> }</span>
<a href="#l18.131"></a><span id="l18.131"> </span>
<a href="#l18.132"></a><span id="l18.132" class="difflineminus">-ber_tag_t LDAP_CALL ber_get_int(BerElement *ber, ber_int_t *num) {</span>
<a href="#l18.133"></a><span id="l18.133" class="difflineplus">+ber_tag_t LDAP_CALL ber_get_int(BerElement* ber, ber_int_t* num) {</span>
<a href="#l18.134"></a><span id="l18.134">   ber_tag_t tag;</span>
<a href="#l18.135"></a><span id="l18.135">   ber_len_t len;</span>
<a href="#l18.136"></a><span id="l18.136"> </span>
<a href="#l18.137"></a><span id="l18.137">   if ((tag = ber_skip_tag(ber, &amp;len)) == LBER_DEFAULT) return (LBER_DEFAULT);</span>
<a href="#l18.138"></a><span id="l18.138"> </span>
<a href="#l18.139"></a><span id="l18.139">   /*</span>
<a href="#l18.140"></a><span id="l18.140">    * len is being demoted to a long here --  possible conversion error</span>
<a href="#l18.141"></a><span id="l18.141">    */</span>
<a href="#l18.142"></a><span id="l18.142"> </span>
<a href="#l18.143"></a><span id="l18.143">   if (ber_getnint(ber, num, (int)len) != (ber_slen_t)len)</span>
<a href="#l18.144"></a><span id="l18.144">     return (LBER_DEFAULT);</span>
<a href="#l18.145"></a><span id="l18.145">   else</span>
<a href="#l18.146"></a><span id="l18.146">     return (tag);</span>
<a href="#l18.147"></a><span id="l18.147"> }</span>
<a href="#l18.148"></a><span id="l18.148"> </span>
<a href="#l18.149"></a><span id="l18.149" class="difflineminus">-ber_tag_t LDAP_CALL ber_get_stringb(BerElement *ber, char *buf,</span>
<a href="#l18.150"></a><span id="l18.150" class="difflineminus">-                                    ber_len_t *len) {</span>
<a href="#l18.151"></a><span id="l18.151" class="difflineplus">+ber_tag_t LDAP_CALL ber_get_stringb(BerElement* ber, char* buf,</span>
<a href="#l18.152"></a><span id="l18.152" class="difflineplus">+                                    ber_len_t* len) {</span>
<a href="#l18.153"></a><span id="l18.153">   ber_len_t datalen;</span>
<a href="#l18.154"></a><span id="l18.154">   ber_tag_t tag;</span>
<a href="#l18.155"></a><span id="l18.155"> #ifdef STR_TRANSLATION</span>
<a href="#l18.156"></a><span id="l18.156" class="difflineminus">-  char *transbuf;</span>
<a href="#l18.157"></a><span id="l18.157" class="difflineplus">+  char* transbuf;</span>
<a href="#l18.158"></a><span id="l18.158"> #endif /* STR_TRANSLATION */</span>
<a href="#l18.159"></a><span id="l18.159"> </span>
<a href="#l18.160"></a><span id="l18.160">   if ((tag = ber_skip_tag(ber, &amp;datalen)) == LBER_DEFAULT)</span>
<a href="#l18.161"></a><span id="l18.161">     return (LBER_DEFAULT);</span>
<a href="#l18.162"></a><span id="l18.162">   if (datalen &gt; (*len - 1)) return (LBER_DEFAULT);</span>
<a href="#l18.163"></a><span id="l18.163"> </span>
<a href="#l18.164"></a><span id="l18.164">   /*</span>
<a href="#l18.165"></a><span id="l18.165">    * datalen is being demoted to a long here --  possible conversion error</span>
<a href="#l18.166"></a><span id="l18.166" class="difflineat">@@ -232,26 +232,26 @@ ber_tag_t LDAP_CALL ber_get_stringb(BerE</span>
<a href="#l18.167"></a><span id="l18.167">     --datalen;</span>
<a href="#l18.168"></a><span id="l18.168">   }</span>
<a href="#l18.169"></a><span id="l18.169"> #endif /* STR_TRANSLATION */</span>
<a href="#l18.170"></a><span id="l18.170"> </span>
<a href="#l18.171"></a><span id="l18.171">   *len = datalen;</span>
<a href="#l18.172"></a><span id="l18.172">   return (tag);</span>
<a href="#l18.173"></a><span id="l18.173"> }</span>
<a href="#l18.174"></a><span id="l18.174"> </span>
<a href="#l18.175"></a><span id="l18.175" class="difflineminus">-ber_tag_t LDAP_CALL ber_get_stringa(BerElement *ber, char **buf) {</span>
<a href="#l18.176"></a><span id="l18.176" class="difflineplus">+ber_tag_t LDAP_CALL ber_get_stringa(BerElement* ber, char** buf) {</span>
<a href="#l18.177"></a><span id="l18.177">   ber_len_t datalen, ndatalen;</span>
<a href="#l18.178"></a><span id="l18.178">   ber_tag_t tag;</span>
<a href="#l18.179"></a><span id="l18.179"> </span>
<a href="#l18.180"></a><span id="l18.180">   if ((tag = ber_skip_tag(ber, &amp;datalen)) == LBER_DEFAULT)</span>
<a href="#l18.181"></a><span id="l18.181">     return (LBER_DEFAULT);</span>
<a href="#l18.182"></a><span id="l18.182"> </span>
<a href="#l18.183"></a><span id="l18.183">   if (((ndatalen = (size_t)datalen + 1) &lt; (size_t)datalen) ||</span>
<a href="#l18.184"></a><span id="l18.184">       (datalen &gt; (ber-&gt;ber_end - ber-&gt;ber_ptr)) ||</span>
<a href="#l18.185"></a><span id="l18.185" class="difflineminus">-      ((*buf = (char *)NSLBERI_MALLOC((size_t)ndatalen)) == NULL))</span>
<a href="#l18.186"></a><span id="l18.186" class="difflineplus">+      ((*buf = (char*)NSLBERI_MALLOC((size_t)ndatalen)) == NULL))</span>
<a href="#l18.187"></a><span id="l18.187">     return (LBER_DEFAULT);</span>
<a href="#l18.188"></a><span id="l18.188"> </span>
<a href="#l18.189"></a><span id="l18.189">   /*</span>
<a href="#l18.190"></a><span id="l18.190">    * datalen is being demoted to a long here --  possible conversion error</span>
<a href="#l18.191"></a><span id="l18.191">    */</span>
<a href="#l18.192"></a><span id="l18.192">   if (ber_read(ber, *buf, datalen) != (ber_slen_t)datalen) {</span>
<a href="#l18.193"></a><span id="l18.193">     NSLBERI_FREE(*buf);</span>
<a href="#l18.194"></a><span id="l18.194">     *buf = NULL;</span>
<a href="#l18.195"></a><span id="l18.195" class="difflineat">@@ -270,36 +270,36 @@ ber_tag_t LDAP_CALL ber_get_stringa(BerE</span>
<a href="#l18.196"></a><span id="l18.196">       return (LBER_DEFAULT);</span>
<a href="#l18.197"></a><span id="l18.197">     }</span>
<a href="#l18.198"></a><span id="l18.198">   }</span>
<a href="#l18.199"></a><span id="l18.199"> #endif /* STR_TRANSLATION */</span>
<a href="#l18.200"></a><span id="l18.200"> </span>
<a href="#l18.201"></a><span id="l18.201">   return (tag);</span>
<a href="#l18.202"></a><span id="l18.202"> }</span>
<a href="#l18.203"></a><span id="l18.203"> </span>
<a href="#l18.204"></a><span id="l18.204" class="difflineminus">-ber_tag_t LDAP_CALL ber_get_stringal(BerElement *ber, struct berval **bv) {</span>
<a href="#l18.205"></a><span id="l18.205" class="difflineplus">+ber_tag_t LDAP_CALL ber_get_stringal(BerElement* ber, struct berval** bv) {</span>
<a href="#l18.206"></a><span id="l18.206">   ber_len_t len, nlen;</span>
<a href="#l18.207"></a><span id="l18.207">   ber_tag_t tag;</span>
<a href="#l18.208"></a><span id="l18.208"> </span>
<a href="#l18.209"></a><span id="l18.209" class="difflineminus">-  if ((*bv = (struct berval *)NSLBERI_MALLOC(sizeof(struct berval))) == NULL) {</span>
<a href="#l18.210"></a><span id="l18.210" class="difflineplus">+  if ((*bv = (struct berval*)NSLBERI_MALLOC(sizeof(struct berval))) == NULL) {</span>
<a href="#l18.211"></a><span id="l18.211">     return (LBER_DEFAULT);</span>
<a href="#l18.212"></a><span id="l18.212">   }</span>
<a href="#l18.213"></a><span id="l18.213"> </span>
<a href="#l18.214"></a><span id="l18.214">   (*bv)-&gt;bv_val = NULL;</span>
<a href="#l18.215"></a><span id="l18.215">   (*bv)-&gt;bv_len = 0;</span>
<a href="#l18.216"></a><span id="l18.216"> </span>
<a href="#l18.217"></a><span id="l18.217">   if ((tag = ber_skip_tag(ber, &amp;len)) == LBER_DEFAULT) {</span>
<a href="#l18.218"></a><span id="l18.218">     NSLBERI_FREE(*bv);</span>
<a href="#l18.219"></a><span id="l18.219">     *bv = NULL;</span>
<a href="#l18.220"></a><span id="l18.220">     return (LBER_DEFAULT);</span>
<a href="#l18.221"></a><span id="l18.221">   }</span>
<a href="#l18.222"></a><span id="l18.222"> </span>
<a href="#l18.223"></a><span id="l18.223">   if (((nlen = (size_t)len + 1) &lt; (size_t)len) ||</span>
<a href="#l18.224"></a><span id="l18.224">       (len &gt; (ber-&gt;ber_end - ber-&gt;ber_ptr)) ||</span>
<a href="#l18.225"></a><span id="l18.225" class="difflineminus">-      (((*bv)-&gt;bv_val = (char *)NSLBERI_MALLOC((size_t)nlen)) == NULL)) {</span>
<a href="#l18.226"></a><span id="l18.226" class="difflineplus">+      (((*bv)-&gt;bv_val = (char*)NSLBERI_MALLOC((size_t)nlen)) == NULL)) {</span>
<a href="#l18.227"></a><span id="l18.227">     NSLBERI_FREE(*bv);</span>
<a href="#l18.228"></a><span id="l18.228">     *bv = NULL;</span>
<a href="#l18.229"></a><span id="l18.229">     return (LBER_DEFAULT);</span>
<a href="#l18.230"></a><span id="l18.230">   }</span>
<a href="#l18.231"></a><span id="l18.231"> </span>
<a href="#l18.232"></a><span id="l18.232">   /*</span>
<a href="#l18.233"></a><span id="l18.233">    * len is being demoted to a long here --  possible conversion error</span>
<a href="#l18.234"></a><span id="l18.234">    */</span>
<a href="#l18.235"></a><span id="l18.235" class="difflineat">@@ -327,31 +327,31 @@ ber_tag_t LDAP_CALL ber_get_stringal(Ber</span>
<a href="#l18.236"></a><span id="l18.236">     }</span>
<a href="#l18.237"></a><span id="l18.237">     (*bv)-&gt;bv_len = len - 1;</span>
<a href="#l18.238"></a><span id="l18.238">   }</span>
<a href="#l18.239"></a><span id="l18.239"> #endif /* STR_TRANSLATION */</span>
<a href="#l18.240"></a><span id="l18.240"> </span>
<a href="#l18.241"></a><span id="l18.241">   return (tag);</span>
<a href="#l18.242"></a><span id="l18.242"> }</span>
<a href="#l18.243"></a><span id="l18.243"> </span>
<a href="#l18.244"></a><span id="l18.244" class="difflineminus">-ber_tag_t LDAP_CALL ber_get_bitstringa(BerElement *ber, char **buf,</span>
<a href="#l18.245"></a><span id="l18.245" class="difflineminus">-                                       ber_len_t *blen) {</span>
<a href="#l18.246"></a><span id="l18.246" class="difflineplus">+ber_tag_t LDAP_CALL ber_get_bitstringa(BerElement* ber, char** buf,</span>
<a href="#l18.247"></a><span id="l18.247" class="difflineplus">+                                       ber_len_t* blen) {</span>
<a href="#l18.248"></a><span id="l18.248">   ber_len_t datalen;</span>
<a href="#l18.249"></a><span id="l18.249">   ber_tag_t tag;</span>
<a href="#l18.250"></a><span id="l18.250">   unsigned char unusedbits;</span>
<a href="#l18.251"></a><span id="l18.251"> </span>
<a href="#l18.252"></a><span id="l18.252">   if ((tag = ber_skip_tag(ber, &amp;datalen)) == LBER_DEFAULT)</span>
<a href="#l18.253"></a><span id="l18.253">     return (LBER_DEFAULT);</span>
<a href="#l18.254"></a><span id="l18.254">   --datalen;</span>
<a href="#l18.255"></a><span id="l18.255"> </span>
<a href="#l18.256"></a><span id="l18.256">   if ((datalen &gt; (ber-&gt;ber_end - ber-&gt;ber_ptr)) ||</span>
<a href="#l18.257"></a><span id="l18.257" class="difflineminus">-      ((*buf = (char *)NSLBERI_MALLOC((size_t)datalen)) == NULL))</span>
<a href="#l18.258"></a><span id="l18.258" class="difflineplus">+      ((*buf = (char*)NSLBERI_MALLOC((size_t)datalen)) == NULL))</span>
<a href="#l18.259"></a><span id="l18.259">     return (LBER_DEFAULT);</span>
<a href="#l18.260"></a><span id="l18.260"> </span>
<a href="#l18.261"></a><span id="l18.261" class="difflineminus">-  if (ber_read(ber, (char *)&amp;unusedbits, 1) != 1) {</span>
<a href="#l18.262"></a><span id="l18.262" class="difflineplus">+  if (ber_read(ber, (char*)&amp;unusedbits, 1) != 1) {</span>
<a href="#l18.263"></a><span id="l18.263">     NSLBERI_FREE(*buf);</span>
<a href="#l18.264"></a><span id="l18.264">     *buf = NULL;</span>
<a href="#l18.265"></a><span id="l18.265">     return (LBER_DEFAULT);</span>
<a href="#l18.266"></a><span id="l18.266">   }</span>
<a href="#l18.267"></a><span id="l18.267"> </span>
<a href="#l18.268"></a><span id="l18.268">   /*</span>
<a href="#l18.269"></a><span id="l18.269">    * datalen is being demoted to a long here --  possible conversion error</span>
<a href="#l18.270"></a><span id="l18.270">    */</span>
<a href="#l18.271"></a><span id="l18.271" class="difflineat">@@ -360,165 +360,165 @@ ber_tag_t LDAP_CALL ber_get_bitstringa(B</span>
<a href="#l18.272"></a><span id="l18.272">     *buf = NULL;</span>
<a href="#l18.273"></a><span id="l18.273">     return (LBER_DEFAULT);</span>
<a href="#l18.274"></a><span id="l18.274">   }</span>
<a href="#l18.275"></a><span id="l18.275"> </span>
<a href="#l18.276"></a><span id="l18.276">   *blen = datalen * 8 - unusedbits;</span>
<a href="#l18.277"></a><span id="l18.277">   return (tag);</span>
<a href="#l18.278"></a><span id="l18.278"> }</span>
<a href="#l18.279"></a><span id="l18.279"> </span>
<a href="#l18.280"></a><span id="l18.280" class="difflineminus">-ber_tag_t LDAP_CALL ber_get_null(BerElement *ber) {</span>
<a href="#l18.281"></a><span id="l18.281" class="difflineplus">+ber_tag_t LDAP_CALL ber_get_null(BerElement* ber) {</span>
<a href="#l18.282"></a><span id="l18.282">   ber_len_t len;</span>
<a href="#l18.283"></a><span id="l18.283">   ber_tag_t tag;</span>
<a href="#l18.284"></a><span id="l18.284"> </span>
<a href="#l18.285"></a><span id="l18.285">   if ((tag = ber_skip_tag(ber, &amp;len)) == LBER_DEFAULT) return (LBER_DEFAULT);</span>
<a href="#l18.286"></a><span id="l18.286"> </span>
<a href="#l18.287"></a><span id="l18.287">   if (len != 0) return (LBER_DEFAULT);</span>
<a href="#l18.288"></a><span id="l18.288"> </span>
<a href="#l18.289"></a><span id="l18.289">   return (tag);</span>
<a href="#l18.290"></a><span id="l18.290"> }</span>
<a href="#l18.291"></a><span id="l18.291"> </span>
<a href="#l18.292"></a><span id="l18.292" class="difflineminus">-ber_tag_t LDAP_CALL ber_get_boolean(BerElement *ber, ber_int_t *boolval) {</span>
<a href="#l18.293"></a><span id="l18.293" class="difflineplus">+ber_tag_t LDAP_CALL ber_get_boolean(BerElement* ber, ber_int_t* boolval) {</span>
<a href="#l18.294"></a><span id="l18.294">   int rc;</span>
<a href="#l18.295"></a><span id="l18.295"> </span>
<a href="#l18.296"></a><span id="l18.296">   rc = ber_get_int(ber, boolval);</span>
<a href="#l18.297"></a><span id="l18.297"> </span>
<a href="#l18.298"></a><span id="l18.298">   return (rc);</span>
<a href="#l18.299"></a><span id="l18.299"> }</span>
<a href="#l18.300"></a><span id="l18.300"> </span>
<a href="#l18.301"></a><span id="l18.301" class="difflineminus">-ber_tag_t LDAP_CALL ber_first_element(BerElement *ber, ber_len_t *len,</span>
<a href="#l18.302"></a><span id="l18.302" class="difflineminus">-                                      char **last) {</span>
<a href="#l18.303"></a><span id="l18.303" class="difflineplus">+ber_tag_t LDAP_CALL ber_first_element(BerElement* ber, ber_len_t* len,</span>
<a href="#l18.304"></a><span id="l18.304" class="difflineplus">+                                      char** last) {</span>
<a href="#l18.305"></a><span id="l18.305">   /* skip the sequence header, use the len to mark where to stop */</span>
<a href="#l18.306"></a><span id="l18.306">   if (ber_skip_tag(ber, len) == LBER_DEFAULT) {</span>
<a href="#l18.307"></a><span id="l18.307">     return (LBER_ERROR);</span>
<a href="#l18.308"></a><span id="l18.308">   }</span>
<a href="#l18.309"></a><span id="l18.309"> </span>
<a href="#l18.310"></a><span id="l18.310">   *last = ber-&gt;ber_ptr + *len;</span>
<a href="#l18.311"></a><span id="l18.311"> </span>
<a href="#l18.312"></a><span id="l18.312">   if (*last == ber-&gt;ber_ptr) {</span>
<a href="#l18.313"></a><span id="l18.313">     return (LBER_END_OF_SEQORSET);</span>
<a href="#l18.314"></a><span id="l18.314">   }</span>
<a href="#l18.315"></a><span id="l18.315"> </span>
<a href="#l18.316"></a><span id="l18.316">   return (ber_peek_tag(ber, len));</span>
<a href="#l18.317"></a><span id="l18.317"> }</span>
<a href="#l18.318"></a><span id="l18.318"> </span>
<a href="#l18.319"></a><span id="l18.319" class="difflineminus">-ber_tag_t LDAP_CALL ber_next_element(BerElement *ber, ber_len_t *len,</span>
<a href="#l18.320"></a><span id="l18.320" class="difflineminus">-                                     char *last) {</span>
<a href="#l18.321"></a><span id="l18.321" class="difflineplus">+ber_tag_t LDAP_CALL ber_next_element(BerElement* ber, ber_len_t* len,</span>
<a href="#l18.322"></a><span id="l18.322" class="difflineplus">+                                     char* last) {</span>
<a href="#l18.323"></a><span id="l18.323">   if (ber-&gt;ber_ptr == last) {</span>
<a href="#l18.324"></a><span id="l18.324">     return (LBER_END_OF_SEQORSET);</span>
<a href="#l18.325"></a><span id="l18.325">   }</span>
<a href="#l18.326"></a><span id="l18.326"> </span>
<a href="#l18.327"></a><span id="l18.327">   return (ber_peek_tag(ber, len));</span>
<a href="#l18.328"></a><span id="l18.328"> }</span>
<a href="#l18.329"></a><span id="l18.329"> </span>
<a href="#l18.330"></a><span id="l18.330"> /* VARARGS */</span>
<a href="#l18.331"></a><span id="l18.331" class="difflineminus">-ber_tag_t LDAP_C ber_scanf(BerElement *ber, const char *fmt, ...) {</span>
<a href="#l18.332"></a><span id="l18.332" class="difflineplus">+ber_tag_t LDAP_C ber_scanf(BerElement* ber, const char* fmt, ...) {</span>
<a href="#l18.333"></a><span id="l18.333">   va_list ap;</span>
<a href="#l18.334"></a><span id="l18.334">   char *last, *p;</span>
<a href="#l18.335"></a><span id="l18.335">   char *s, **ss, ***sss;</span>
<a href="#l18.336"></a><span id="l18.336">   struct berval ***bv, **bvp, *bval;</span>
<a href="#l18.337"></a><span id="l18.337">   int *i, j;</span>
<a href="#l18.338"></a><span id="l18.338">   ber_int_t *l, rc, tag;</span>
<a href="#l18.339"></a><span id="l18.339" class="difflineminus">-  ber_tag_t *t;</span>
<a href="#l18.340"></a><span id="l18.340" class="difflineplus">+  ber_tag_t* t;</span>
<a href="#l18.341"></a><span id="l18.341">   ber_len_t len;</span>
<a href="#l18.342"></a><span id="l18.342">   size_t array_size;</span>
<a href="#l18.343"></a><span id="l18.343"> </span>
<a href="#l18.344"></a><span id="l18.344">   va_start(ap, fmt);</span>
<a href="#l18.345"></a><span id="l18.345"> </span>
<a href="#l18.346"></a><span id="l18.346"> #ifdef LDAP_DEBUG</span>
<a href="#l18.347"></a><span id="l18.347">   if (lber_debug &amp; 64) {</span>
<a href="#l18.348"></a><span id="l18.348">     char msg[80];</span>
<a href="#l18.349"></a><span id="l18.349">     sprintf(msg, &quot;ber_scanf fmt (%s) ber:\n&quot;, fmt);</span>
<a href="#l18.350"></a><span id="l18.350">     ber_err_print(msg);</span>
<a href="#l18.351"></a><span id="l18.351">     ber_dump(ber, 1);</span>
<a href="#l18.352"></a><span id="l18.352">   }</span>
<a href="#l18.353"></a><span id="l18.353"> #endif</span>
<a href="#l18.354"></a><span id="l18.354" class="difflineminus">-  for (rc = 0, p = (char *)fmt; *p &amp;&amp; rc != LBER_DEFAULT; p++) {</span>
<a href="#l18.355"></a><span id="l18.355" class="difflineplus">+  for (rc = 0, p = (char*)fmt; *p &amp;&amp; rc != LBER_DEFAULT; p++) {</span>
<a href="#l18.356"></a><span id="l18.356">     switch (*p) {</span>
<a href="#l18.357"></a><span id="l18.357">       case 'a': /* octet string - allocate storage as needed */</span>
<a href="#l18.358"></a><span id="l18.358" class="difflineminus">-        ss = va_arg(ap, char **);</span>
<a href="#l18.359"></a><span id="l18.359" class="difflineplus">+        ss = va_arg(ap, char**);</span>
<a href="#l18.360"></a><span id="l18.360">         rc = ber_get_stringa(ber, ss);</span>
<a href="#l18.361"></a><span id="l18.361">         break;</span>
<a href="#l18.362"></a><span id="l18.362"> </span>
<a href="#l18.363"></a><span id="l18.363">       case 'b': /* boolean */</span>
<a href="#l18.364"></a><span id="l18.364" class="difflineminus">-        i = va_arg(ap, int *);</span>
<a href="#l18.365"></a><span id="l18.365" class="difflineplus">+        i = va_arg(ap, int*);</span>
<a href="#l18.366"></a><span id="l18.366">         rc = ber_get_boolean(ber, i);</span>
<a href="#l18.367"></a><span id="l18.367">         break;</span>
<a href="#l18.368"></a><span id="l18.368"> </span>
<a href="#l18.369"></a><span id="l18.369">       case 'e': /* enumerated */</span>
<a href="#l18.370"></a><span id="l18.370">       case 'i': /* int */</span>
<a href="#l18.371"></a><span id="l18.371" class="difflineminus">-        l = va_arg(ap, ber_slen_t *);</span>
<a href="#l18.372"></a><span id="l18.372" class="difflineplus">+        l = va_arg(ap, ber_slen_t*);</span>
<a href="#l18.373"></a><span id="l18.373">         rc = ber_get_int(ber, l);</span>
<a href="#l18.374"></a><span id="l18.374">         break;</span>
<a href="#l18.375"></a><span id="l18.375"> </span>
<a href="#l18.376"></a><span id="l18.376">       case 'l': /* length of next item */</span>
<a href="#l18.377"></a><span id="l18.377" class="difflineminus">-        l = va_arg(ap, ber_slen_t *);</span>
<a href="#l18.378"></a><span id="l18.378" class="difflineminus">-        rc = ber_peek_tag(ber, (ber_len_t *)l);</span>
<a href="#l18.379"></a><span id="l18.379" class="difflineplus">+        l = va_arg(ap, ber_slen_t*);</span>
<a href="#l18.380"></a><span id="l18.380" class="difflineplus">+        rc = ber_peek_tag(ber, (ber_len_t*)l);</span>
<a href="#l18.381"></a><span id="l18.381">         break;</span>
<a href="#l18.382"></a><span id="l18.382"> </span>
<a href="#l18.383"></a><span id="l18.383">       case 'n': /* null */</span>
<a href="#l18.384"></a><span id="l18.384">         rc = ber_get_null(ber);</span>
<a href="#l18.385"></a><span id="l18.385">         break;</span>
<a href="#l18.386"></a><span id="l18.386"> </span>
<a href="#l18.387"></a><span id="l18.387">       case 's': /* octet string - in a buffer */</span>
<a href="#l18.388"></a><span id="l18.388" class="difflineminus">-        s = va_arg(ap, char *);</span>
<a href="#l18.389"></a><span id="l18.389" class="difflineminus">-        l = va_arg(ap, ber_slen_t *);</span>
<a href="#l18.390"></a><span id="l18.390" class="difflineminus">-        rc = ber_get_stringb(ber, s, (ber_len_t *)l);</span>
<a href="#l18.391"></a><span id="l18.391" class="difflineplus">+        s = va_arg(ap, char*);</span>
<a href="#l18.392"></a><span id="l18.392" class="difflineplus">+        l = va_arg(ap, ber_slen_t*);</span>
<a href="#l18.393"></a><span id="l18.393" class="difflineplus">+        rc = ber_get_stringb(ber, s, (ber_len_t*)l);</span>
<a href="#l18.394"></a><span id="l18.394">         break;</span>
<a href="#l18.395"></a><span id="l18.395"> </span>
<a href="#l18.396"></a><span id="l18.396">       case 'o': /* octet string in a supplied berval */</span>
<a href="#l18.397"></a><span id="l18.397" class="difflineminus">-        bval = va_arg(ap, struct berval *);</span>
<a href="#l18.398"></a><span id="l18.398" class="difflineplus">+        bval = va_arg(ap, struct berval*);</span>
<a href="#l18.399"></a><span id="l18.399">         ber_peek_tag(ber, &amp;bval-&gt;bv_len);</span>
<a href="#l18.400"></a><span id="l18.400">         rc = ber_get_stringa(ber, &amp;bval-&gt;bv_val);</span>
<a href="#l18.401"></a><span id="l18.401">         break;</span>
<a href="#l18.402"></a><span id="l18.402"> </span>
<a href="#l18.403"></a><span id="l18.403">       case 'O': /* octet string - allocate &amp; include length */</span>
<a href="#l18.404"></a><span id="l18.404" class="difflineminus">-        bvp = va_arg(ap, struct berval **);</span>
<a href="#l18.405"></a><span id="l18.405" class="difflineplus">+        bvp = va_arg(ap, struct berval**);</span>
<a href="#l18.406"></a><span id="l18.406">         rc = ber_get_stringal(ber, bvp);</span>
<a href="#l18.407"></a><span id="l18.407">         break;</span>
<a href="#l18.408"></a><span id="l18.408"> </span>
<a href="#l18.409"></a><span id="l18.409">       case 'B': /* bit string - allocate storage as needed */</span>
<a href="#l18.410"></a><span id="l18.410" class="difflineminus">-        ss = va_arg(ap, char **);</span>
<a href="#l18.411"></a><span id="l18.411" class="difflineminus">-        l = va_arg(ap, ber_slen_t *); /* for length, in bits */</span>
<a href="#l18.412"></a><span id="l18.412" class="difflineminus">-        rc = ber_get_bitstringa(ber, ss, (ber_len_t *)l);</span>
<a href="#l18.413"></a><span id="l18.413" class="difflineplus">+        ss = va_arg(ap, char**);</span>
<a href="#l18.414"></a><span id="l18.414" class="difflineplus">+        l = va_arg(ap, ber_slen_t*); /* for length, in bits */</span>
<a href="#l18.415"></a><span id="l18.415" class="difflineplus">+        rc = ber_get_bitstringa(ber, ss, (ber_len_t*)l);</span>
<a href="#l18.416"></a><span id="l18.416">         break;</span>
<a href="#l18.417"></a><span id="l18.417"> </span>
<a href="#l18.418"></a><span id="l18.418">       case 't': /* tag of next item */</span>
<a href="#l18.419"></a><span id="l18.419" class="difflineminus">-        t = va_arg(ap, ber_tag_t *);</span>
<a href="#l18.420"></a><span id="l18.420" class="difflineplus">+        t = va_arg(ap, ber_tag_t*);</span>
<a href="#l18.421"></a><span id="l18.421">         *t = rc = ber_peek_tag(ber, &amp;len);</span>
<a href="#l18.422"></a><span id="l18.422">         break;</span>
<a href="#l18.423"></a><span id="l18.423"> </span>
<a href="#l18.424"></a><span id="l18.424">       case 'T': /* skip tag of next item */</span>
<a href="#l18.425"></a><span id="l18.425" class="difflineminus">-        t = va_arg(ap, ber_tag_t *);</span>
<a href="#l18.426"></a><span id="l18.426" class="difflineplus">+        t = va_arg(ap, ber_tag_t*);</span>
<a href="#l18.427"></a><span id="l18.427">         *t = rc = ber_skip_tag(ber, &amp;len);</span>
<a href="#l18.428"></a><span id="l18.428">         break;</span>
<a href="#l18.429"></a><span id="l18.429"> </span>
<a href="#l18.430"></a><span id="l18.430">       case 'v': /* sequence of strings */</span>
<a href="#l18.431"></a><span id="l18.431" class="difflineminus">-        sss = va_arg(ap, char ***);</span>
<a href="#l18.432"></a><span id="l18.432" class="difflineplus">+        sss = va_arg(ap, char***);</span>
<a href="#l18.433"></a><span id="l18.433">         *sss = NULL;</span>
<a href="#l18.434"></a><span id="l18.434">         j = 0;</span>
<a href="#l18.435"></a><span id="l18.435">         array_size = 0;</span>
<a href="#l18.436"></a><span id="l18.436">         for (tag = ber_first_element(ber, &amp;len, &amp;last);</span>
<a href="#l18.437"></a><span id="l18.437">              tag != LBER_DEFAULT &amp;&amp; tag != LBER_END_OF_SEQORSET &amp;&amp;</span>
<a href="#l18.438"></a><span id="l18.438">              rc != LBER_DEFAULT;</span>
<a href="#l18.439"></a><span id="l18.439">              tag = ber_next_element(ber, &amp;len, last)) {</span>
<a href="#l18.440"></a><span id="l18.440">           if (*sss == NULL) {</span>
<a href="#l18.441"></a><span id="l18.441">             /* Make room for at least 15 strings */</span>
<a href="#l18.442"></a><span id="l18.442" class="difflineminus">-            *sss = (char **)NSLBERI_MALLOC(16 * sizeof(char *));</span>
<a href="#l18.443"></a><span id="l18.443" class="difflineplus">+            *sss = (char**)NSLBERI_MALLOC(16 * sizeof(char*));</span>
<a href="#l18.444"></a><span id="l18.444">             if (!*sss) {</span>
<a href="#l18.445"></a><span id="l18.445">               rc = LBER_DEFAULT;</span>
<a href="#l18.446"></a><span id="l18.446">               break; /* out of memory - cannot continue */</span>
<a href="#l18.447"></a><span id="l18.447">             }</span>
<a href="#l18.448"></a><span id="l18.448">             array_size = 16;</span>
<a href="#l18.449"></a><span id="l18.449">           } else {</span>
<a href="#l18.450"></a><span id="l18.450" class="difflineminus">-            char **save_sss = *sss;</span>
<a href="#l18.451"></a><span id="l18.451" class="difflineplus">+            char** save_sss = *sss;</span>
<a href="#l18.452"></a><span id="l18.452">             if ((size_t)(j + 2) &gt; array_size) {</span>
<a href="#l18.453"></a><span id="l18.453">               /* We'v overflowed our buffer */</span>
<a href="#l18.454"></a><span id="l18.454" class="difflineminus">-              *sss = (char **)NSLBERI_REALLOC(</span>
<a href="#l18.455"></a><span id="l18.455" class="difflineminus">-                  *sss, (array_size * 2) * sizeof(char *));</span>
<a href="#l18.456"></a><span id="l18.456" class="difflineplus">+              *sss = (char**)NSLBERI_REALLOC(*sss,</span>
<a href="#l18.457"></a><span id="l18.457" class="difflineplus">+                                             (array_size * 2) * sizeof(char*));</span>
<a href="#l18.458"></a><span id="l18.458">               array_size = array_size * 2;</span>
<a href="#l18.459"></a><span id="l18.459">             }</span>
<a href="#l18.460"></a><span id="l18.460">             if (!*sss) {</span>
<a href="#l18.461"></a><span id="l18.461">               rc = LBER_DEFAULT;</span>
<a href="#l18.462"></a><span id="l18.462">               ber_svecfree(save_sss);</span>
<a href="#l18.463"></a><span id="l18.463">               break; /* out of memory - cannot continue */</span>
<a href="#l18.464"></a><span id="l18.464">             }</span>
<a href="#l18.465"></a><span id="l18.465">           }</span>
<a href="#l18.466"></a><span id="l18.466" class="difflineat">@@ -530,33 +530,33 @@ ber_tag_t LDAP_C ber_scanf(BerElement *b</span>
<a href="#l18.467"></a><span id="l18.467">           rc = LBER_DEFAULT;</span>
<a href="#l18.468"></a><span id="l18.468">         }</span>
<a href="#l18.469"></a><span id="l18.469">         if (*sss &amp;&amp; (j &gt; 0)) {</span>
<a href="#l18.470"></a><span id="l18.470">           (*sss)[j] = NULL;</span>
<a href="#l18.471"></a><span id="l18.471">         }</span>
<a href="#l18.472"></a><span id="l18.472">         break;</span>
<a href="#l18.473"></a><span id="l18.473"> </span>
<a href="#l18.474"></a><span id="l18.474">       case 'V': /* sequence of strings + lengths */</span>
<a href="#l18.475"></a><span id="l18.475" class="difflineminus">-        bv = va_arg(ap, struct berval ***);</span>
<a href="#l18.476"></a><span id="l18.476" class="difflineplus">+        bv = va_arg(ap, struct berval***);</span>
<a href="#l18.477"></a><span id="l18.477">         *bv = NULL;</span>
<a href="#l18.478"></a><span id="l18.478">         j = 0;</span>
<a href="#l18.479"></a><span id="l18.479">         for (tag = ber_first_element(ber, &amp;len, &amp;last);</span>
<a href="#l18.480"></a><span id="l18.480">              tag != LBER_DEFAULT &amp;&amp; tag != LBER_END_OF_SEQORSET &amp;&amp;</span>
<a href="#l18.481"></a><span id="l18.481">              rc != LBER_DEFAULT;</span>
<a href="#l18.482"></a><span id="l18.482">              tag = ber_next_element(ber, &amp;len, last)) {</span>
<a href="#l18.483"></a><span id="l18.483">           if (*bv == NULL) {</span>
<a href="#l18.484"></a><span id="l18.484" class="difflineminus">-            *bv = (struct berval **)NSLBERI_MALLOC(2 * sizeof(struct berval *));</span>
<a href="#l18.485"></a><span id="l18.485" class="difflineplus">+            *bv = (struct berval**)NSLBERI_MALLOC(2 * sizeof(struct berval*));</span>
<a href="#l18.486"></a><span id="l18.486">             if (!*bv) {</span>
<a href="#l18.487"></a><span id="l18.487">               rc = LBER_DEFAULT;</span>
<a href="#l18.488"></a><span id="l18.488">               break; /* out of memory - cannot continue */</span>
<a href="#l18.489"></a><span id="l18.489">             }</span>
<a href="#l18.490"></a><span id="l18.490">           } else {</span>
<a href="#l18.491"></a><span id="l18.491" class="difflineminus">-            struct berval **save_bv = *bv;</span>
<a href="#l18.492"></a><span id="l18.492" class="difflineminus">-            *bv = (struct berval **)NSLBERI_REALLOC(</span>
<a href="#l18.493"></a><span id="l18.493" class="difflineminus">-                *bv, (j + 2) * sizeof(struct berval *));</span>
<a href="#l18.494"></a><span id="l18.494" class="difflineplus">+            struct berval** save_bv = *bv;</span>
<a href="#l18.495"></a><span id="l18.495" class="difflineplus">+            *bv = (struct berval**)NSLBERI_REALLOC(</span>
<a href="#l18.496"></a><span id="l18.496" class="difflineplus">+                *bv, (j + 2) * sizeof(struct berval*));</span>
<a href="#l18.497"></a><span id="l18.497">             if (!*bv) {</span>
<a href="#l18.498"></a><span id="l18.498">               rc = LBER_DEFAULT;</span>
<a href="#l18.499"></a><span id="l18.499">               ber_bvecfree(save_bv);</span>
<a href="#l18.500"></a><span id="l18.500">               break; /* out of memory - cannot continue */</span>
<a href="#l18.501"></a><span id="l18.501">             }</span>
<a href="#l18.502"></a><span id="l18.502">           }</span>
<a href="#l18.503"></a><span id="l18.503">           rc = ber_get_stringal(ber, &amp;((*bv)[j]));</span>
<a href="#l18.504"></a><span id="l18.504">           j++;</span>
<a href="#l18.505"></a><span id="l18.505" class="difflineat">@@ -595,77 +595,77 @@ ber_tag_t LDAP_C ber_scanf(BerElement *b</span>
<a href="#l18.506"></a><span id="l18.506"> </span>
<a href="#l18.507"></a><span id="l18.507">   va_end(ap);</span>
<a href="#l18.508"></a><span id="l18.508"> </span>
<a href="#l18.509"></a><span id="l18.509">   if (rc == LBER_DEFAULT) {</span>
<a href="#l18.510"></a><span id="l18.510">     va_start(ap, fmt);</span>
<a href="#l18.511"></a><span id="l18.511">     for (p--; fmt &lt; p &amp;&amp; *fmt; fmt++) {</span>
<a href="#l18.512"></a><span id="l18.512">       switch (*fmt) {</span>
<a href="#l18.513"></a><span id="l18.513">         case 'a': /* octet string - allocate storage as needed */</span>
<a href="#l18.514"></a><span id="l18.514" class="difflineminus">-          ss = va_arg(ap, char **);</span>
<a href="#l18.515"></a><span id="l18.515" class="difflineplus">+          ss = va_arg(ap, char**);</span>
<a href="#l18.516"></a><span id="l18.516">           NSLBERI_FREE(*ss);</span>
<a href="#l18.517"></a><span id="l18.517">           *ss = NULL;</span>
<a href="#l18.518"></a><span id="l18.518">           break;</span>
<a href="#l18.519"></a><span id="l18.519"> </span>
<a href="#l18.520"></a><span id="l18.520">         case 'b': /* boolean */</span>
<a href="#l18.521"></a><span id="l18.521" class="difflineminus">-          i = va_arg(ap, int *);</span>
<a href="#l18.522"></a><span id="l18.522" class="difflineplus">+          i = va_arg(ap, int*);</span>
<a href="#l18.523"></a><span id="l18.523">           break;</span>
<a href="#l18.524"></a><span id="l18.524"> </span>
<a href="#l18.525"></a><span id="l18.525">         case 'e': /* enumerated */</span>
<a href="#l18.526"></a><span id="l18.526">         case 'i': /* int */</span>
<a href="#l18.527"></a><span id="l18.527" class="difflineminus">-          l = va_arg(ap, ber_slen_t *);</span>
<a href="#l18.528"></a><span id="l18.528" class="difflineplus">+          l = va_arg(ap, ber_slen_t*);</span>
<a href="#l18.529"></a><span id="l18.529">           break;</span>
<a href="#l18.530"></a><span id="l18.530"> </span>
<a href="#l18.531"></a><span id="l18.531">         case 'l': /* length of next item */</span>
<a href="#l18.532"></a><span id="l18.532" class="difflineminus">-          l = va_arg(ap, ber_slen_t *);</span>
<a href="#l18.533"></a><span id="l18.533" class="difflineplus">+          l = va_arg(ap, ber_slen_t*);</span>
<a href="#l18.534"></a><span id="l18.534">           break;</span>
<a href="#l18.535"></a><span id="l18.535"> </span>
<a href="#l18.536"></a><span id="l18.536">         case 'n': /* null */</span>
<a href="#l18.537"></a><span id="l18.537">           break;</span>
<a href="#l18.538"></a><span id="l18.538"> </span>
<a href="#l18.539"></a><span id="l18.539">         case 's': /* octet string - in a buffer */</span>
<a href="#l18.540"></a><span id="l18.540" class="difflineminus">-          s = va_arg(ap, char *);</span>
<a href="#l18.541"></a><span id="l18.541" class="difflineminus">-          l = va_arg(ap, ber_slen_t *);</span>
<a href="#l18.542"></a><span id="l18.542" class="difflineplus">+          s = va_arg(ap, char*);</span>
<a href="#l18.543"></a><span id="l18.543" class="difflineplus">+          l = va_arg(ap, ber_slen_t*);</span>
<a href="#l18.544"></a><span id="l18.544">           break;</span>
<a href="#l18.545"></a><span id="l18.545"> </span>
<a href="#l18.546"></a><span id="l18.546">         case 'o': /* octet string in a supplied berval */</span>
<a href="#l18.547"></a><span id="l18.547" class="difflineminus">-          bval = va_arg(ap, struct berval *);</span>
<a href="#l18.548"></a><span id="l18.548" class="difflineplus">+          bval = va_arg(ap, struct berval*);</span>
<a href="#l18.549"></a><span id="l18.549">           if (bval-&gt;bv_val) NSLBERI_FREE(bval-&gt;bv_val);</span>
<a href="#l18.550"></a><span id="l18.550">           memset(bval, 0, sizeof(struct berval));</span>
<a href="#l18.551"></a><span id="l18.551">           break;</span>
<a href="#l18.552"></a><span id="l18.552"> </span>
<a href="#l18.553"></a><span id="l18.553">         case 'O': /* octet string - allocate &amp; include length */</span>
<a href="#l18.554"></a><span id="l18.554" class="difflineminus">-          bvp = va_arg(ap, struct berval **);</span>
<a href="#l18.555"></a><span id="l18.555" class="difflineplus">+          bvp = va_arg(ap, struct berval**);</span>
<a href="#l18.556"></a><span id="l18.556">           ber_bvfree(*bvp);</span>
<a href="#l18.557"></a><span id="l18.557">           bvp = NULL;</span>
<a href="#l18.558"></a><span id="l18.558">           break;</span>
<a href="#l18.559"></a><span id="l18.559"> </span>
<a href="#l18.560"></a><span id="l18.560">         case 'B': /* bit string - allocate storage as needed */</span>
<a href="#l18.561"></a><span id="l18.561" class="difflineminus">-          ss = va_arg(ap, char **);</span>
<a href="#l18.562"></a><span id="l18.562" class="difflineminus">-          l = va_arg(ap, ber_slen_t *); /* for length, in bits */</span>
<a href="#l18.563"></a><span id="l18.563" class="difflineplus">+          ss = va_arg(ap, char**);</span>
<a href="#l18.564"></a><span id="l18.564" class="difflineplus">+          l = va_arg(ap, ber_slen_t*); /* for length, in bits */</span>
<a href="#l18.565"></a><span id="l18.565">           if (*ss) NSLBERI_FREE(*ss);</span>
<a href="#l18.566"></a><span id="l18.566">           *ss = NULL;</span>
<a href="#l18.567"></a><span id="l18.567">           break;</span>
<a href="#l18.568"></a><span id="l18.568"> </span>
<a href="#l18.569"></a><span id="l18.569">         case 't': /* tag of next item */</span>
<a href="#l18.570"></a><span id="l18.570" class="difflineminus">-          t = va_arg(ap, ber_tag_t *);</span>
<a href="#l18.571"></a><span id="l18.571" class="difflineplus">+          t = va_arg(ap, ber_tag_t*);</span>
<a href="#l18.572"></a><span id="l18.572">           break;</span>
<a href="#l18.573"></a><span id="l18.573"> </span>
<a href="#l18.574"></a><span id="l18.574">         case 'T': /* skip tag of next item */</span>
<a href="#l18.575"></a><span id="l18.575" class="difflineminus">-          t = va_arg(ap, ber_tag_t *);</span>
<a href="#l18.576"></a><span id="l18.576" class="difflineplus">+          t = va_arg(ap, ber_tag_t*);</span>
<a href="#l18.577"></a><span id="l18.577">           break;</span>
<a href="#l18.578"></a><span id="l18.578"> </span>
<a href="#l18.579"></a><span id="l18.579">         case 'v': /* sequence of strings */</span>
<a href="#l18.580"></a><span id="l18.580" class="difflineminus">-          sss = va_arg(ap, char ***);</span>
<a href="#l18.581"></a><span id="l18.581" class="difflineplus">+          sss = va_arg(ap, char***);</span>
<a href="#l18.582"></a><span id="l18.582">           ber_svecfree(*sss);</span>
<a href="#l18.583"></a><span id="l18.583">           *sss = NULL;</span>
<a href="#l18.584"></a><span id="l18.584">           break;</span>
<a href="#l18.585"></a><span id="l18.585"> </span>
<a href="#l18.586"></a><span id="l18.586">         case 'V': /* sequence of strings + lengths */</span>
<a href="#l18.587"></a><span id="l18.587" class="difflineminus">-          bv = va_arg(ap, struct berval ***);</span>
<a href="#l18.588"></a><span id="l18.588" class="difflineplus">+          bv = va_arg(ap, struct berval***);</span>
<a href="#l18.589"></a><span id="l18.589">           ber_bvecfree(*bv);</span>
<a href="#l18.590"></a><span id="l18.590">           *bv = NULL;</span>
<a href="#l18.591"></a><span id="l18.591">           break;</span>
<a href="#l18.592"></a><span id="l18.592"> </span>
<a href="#l18.593"></a><span id="l18.593">         case 'x': /* skip the next element - whatever it is */</span>
<a href="#l18.594"></a><span id="l18.594">           break;</span>
<a href="#l18.595"></a><span id="l18.595"> </span>
<a href="#l18.596"></a><span id="l18.596">         case '{': /* begin sequence */</span>
<a href="#l18.597"></a><span id="l18.597" class="difflineat">@@ -681,67 +681,67 @@ ber_tag_t LDAP_C ber_scanf(BerElement *b</span>
<a href="#l18.598"></a><span id="l18.598">       }</span>
<a href="#l18.599"></a><span id="l18.599">     } /* for */</span>
<a href="#l18.600"></a><span id="l18.600">     va_end(ap);</span>
<a href="#l18.601"></a><span id="l18.601">   } /* if */</span>
<a href="#l18.602"></a><span id="l18.602"> </span>
<a href="#l18.603"></a><span id="l18.603">   return (rc);</span>
<a href="#l18.604"></a><span id="l18.604"> }</span>
<a href="#l18.605"></a><span id="l18.605"> </span>
<a href="#l18.606"></a><span id="l18.606" class="difflineminus">-void LDAP_CALL ber_bvfree(struct berval *bv) {</span>
<a href="#l18.607"></a><span id="l18.607" class="difflineplus">+void LDAP_CALL ber_bvfree(struct berval* bv) {</span>
<a href="#l18.608"></a><span id="l18.608">   if (bv != NULL) {</span>
<a href="#l18.609"></a><span id="l18.609">     if (bv-&gt;bv_val != NULL) {</span>
<a href="#l18.610"></a><span id="l18.610">       NSLBERI_FREE(bv-&gt;bv_val);</span>
<a href="#l18.611"></a><span id="l18.611">     }</span>
<a href="#l18.612"></a><span id="l18.612" class="difflineminus">-    NSLBERI_FREE((char *)bv);</span>
<a href="#l18.613"></a><span id="l18.613" class="difflineplus">+    NSLBERI_FREE((char*)bv);</span>
<a href="#l18.614"></a><span id="l18.614">   }</span>
<a href="#l18.615"></a><span id="l18.615"> }</span>
<a href="#l18.616"></a><span id="l18.616"> </span>
<a href="#l18.617"></a><span id="l18.617" class="difflineminus">-void LDAP_CALL ber_bvecfree(struct berval **bv) {</span>
<a href="#l18.618"></a><span id="l18.618" class="difflineplus">+void LDAP_CALL ber_bvecfree(struct berval** bv) {</span>
<a href="#l18.619"></a><span id="l18.619">   int i;</span>
<a href="#l18.620"></a><span id="l18.620"> </span>
<a href="#l18.621"></a><span id="l18.621">   if (bv != NULL) {</span>
<a href="#l18.622"></a><span id="l18.622">     for (i = 0; bv[i] != NULL; i++) {</span>
<a href="#l18.623"></a><span id="l18.623">       ber_bvfree(bv[i]);</span>
<a href="#l18.624"></a><span id="l18.624">     }</span>
<a href="#l18.625"></a><span id="l18.625" class="difflineminus">-    NSLBERI_FREE((char *)bv);</span>
<a href="#l18.626"></a><span id="l18.626" class="difflineplus">+    NSLBERI_FREE((char*)bv);</span>
<a href="#l18.627"></a><span id="l18.627">   }</span>
<a href="#l18.628"></a><span id="l18.628"> }</span>
<a href="#l18.629"></a><span id="l18.629"> </span>
<a href="#l18.630"></a><span id="l18.630" class="difflineminus">-struct berval *LDAP_CALL ber_bvdup(const struct berval *bv) {</span>
<a href="#l18.631"></a><span id="l18.631" class="difflineminus">-  struct berval *new;</span>
<a href="#l18.632"></a><span id="l18.632" class="difflineplus">+struct berval* LDAP_CALL ber_bvdup(const struct berval* bv) {</span>
<a href="#l18.633"></a><span id="l18.633" class="difflineplus">+  struct berval* new;</span>
<a href="#l18.634"></a><span id="l18.634"> </span>
<a href="#l18.635"></a><span id="l18.635" class="difflineminus">-  if ((new = (struct berval *)NSLBERI_MALLOC(sizeof(struct berval))) == NULL) {</span>
<a href="#l18.636"></a><span id="l18.636" class="difflineplus">+  if ((new = (struct berval*)NSLBERI_MALLOC(sizeof(struct berval))) == NULL) {</span>
<a href="#l18.637"></a><span id="l18.637">     return (NULL);</span>
<a href="#l18.638"></a><span id="l18.638">   }</span>
<a href="#l18.639"></a><span id="l18.639">   if (bv-&gt;bv_val == NULL) {</span>
<a href="#l18.640"></a><span id="l18.640">     new-&gt;bv_val = NULL;</span>
<a href="#l18.641"></a><span id="l18.641">     new-&gt;bv_len = 0;</span>
<a href="#l18.642"></a><span id="l18.642">   } else {</span>
<a href="#l18.643"></a><span id="l18.643" class="difflineminus">-    if ((new-&gt;bv_val = (char *)NSLBERI_MALLOC(bv-&gt;bv_len + 1)) == NULL) {</span>
<a href="#l18.644"></a><span id="l18.644" class="difflineplus">+    if ((new-&gt;bv_val = (char*)NSLBERI_MALLOC(bv-&gt;bv_len + 1)) == NULL) {</span>
<a href="#l18.645"></a><span id="l18.645">       NSLBERI_FREE(new);</span>
<a href="#l18.646"></a><span id="l18.646">       new = NULL;</span>
<a href="#l18.647"></a><span id="l18.647">       return (NULL);</span>
<a href="#l18.648"></a><span id="l18.648">     }</span>
<a href="#l18.649"></a><span id="l18.649">     SAFEMEMCPY(new-&gt;bv_val, bv-&gt;bv_val, (size_t)bv-&gt;bv_len);</span>
<a href="#l18.650"></a><span id="l18.650">     new-&gt;bv_val[bv-&gt;bv_len] = '\0';</span>
<a href="#l18.651"></a><span id="l18.651">     new-&gt;bv_len = bv-&gt;bv_len;</span>
<a href="#l18.652"></a><span id="l18.652">   }</span>
<a href="#l18.653"></a><span id="l18.653"> </span>
<a href="#l18.654"></a><span id="l18.654">   return (new);</span>
<a href="#l18.655"></a><span id="l18.655"> }</span>
<a href="#l18.656"></a><span id="l18.656"> </span>
<a href="#l18.657"></a><span id="l18.657" class="difflineminus">-void LDAP_CALL ber_svecfree(char **vals) {</span>
<a href="#l18.658"></a><span id="l18.658" class="difflineplus">+void LDAP_CALL ber_svecfree(char** vals) {</span>
<a href="#l18.659"></a><span id="l18.659">   int i;</span>
<a href="#l18.660"></a><span id="l18.660"> </span>
<a href="#l18.661"></a><span id="l18.661">   if (vals == NULL) return;</span>
<a href="#l18.662"></a><span id="l18.662">   for (i = 0; vals[i] != NULL; i++) NSLBERI_FREE(vals[i]);</span>
<a href="#l18.663"></a><span id="l18.663" class="difflineminus">-  NSLBERI_FREE((char *)vals);</span>
<a href="#l18.664"></a><span id="l18.664" class="difflineplus">+  NSLBERI_FREE((char*)vals);</span>
<a href="#l18.665"></a><span id="l18.665"> }</span>
<a href="#l18.666"></a><span id="l18.666"> </span>
<a href="#l18.667"></a><span id="l18.667"> #ifdef STR_TRANSLATION</span>
<a href="#l18.668"></a><span id="l18.668" class="difflineminus">-void LDAP_CALL ber_set_string_translators(BerElement *ber,</span>
<a href="#l18.669"></a><span id="l18.669" class="difflineplus">+void LDAP_CALL ber_set_string_translators(BerElement* ber,</span>
<a href="#l18.670"></a><span id="l18.670">                                           BERTranslateProc encode_proc,</span>
<a href="#l18.671"></a><span id="l18.671">                                           BERTranslateProc decode_proc) {</span>
<a href="#l18.672"></a><span id="l18.672">   ber-&gt;ber_encode_translate_proc = encode_proc;</span>
<a href="#l18.673"></a><span id="l18.673">   ber-&gt;ber_decode_translate_proc = decode_proc;</span>
<a href="#l18.674"></a><span id="l18.674"> }</span>
<a href="#l18.675"></a><span id="l18.675"> #endif /* STR_TRANSLATION */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/dtest.c</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/dtest.c</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -58,30 +58,30 @@</span>
<a href="#l19.4"></a><span id="l19.4"> #    include &lt;windows.h&gt;</span>
<a href="#l19.5"></a><span id="l19.5"> #  else</span>
<a href="#l19.6"></a><span id="l19.6"> #    include &lt;sys/types.h&gt;</span>
<a href="#l19.7"></a><span id="l19.7"> #    include &lt;sys/socket.h&gt;</span>
<a href="#l19.8"></a><span id="l19.8"> #  endif /* _WIN32 */</span>
<a href="#l19.9"></a><span id="l19.9"> #endif   /* MACOS */</span>
<a href="#l19.10"></a><span id="l19.10"> #include &quot;lber.h&quot;</span>
<a href="#l19.11"></a><span id="l19.11"> </span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-int SSL_Recv(int s, char *b, unsigned l, int dummy) { return (read(s, b, l)); }</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+int SSL_Recv(int s, char* b, unsigned l, int dummy) { return (read(s, b, l)); }</span>
<a href="#l19.14"></a><span id="l19.14"> </span>
<a href="#l19.15"></a><span id="l19.15" class="difflineminus">-SSL_Send(int s, char *b, unsigned l, int dummy) { return (write(s, b, l)); }</span>
<a href="#l19.16"></a><span id="l19.16" class="difflineplus">+SSL_Send(int s, char* b, unsigned l, int dummy) { return (write(s, b, l)); }</span>
<a href="#l19.17"></a><span id="l19.17"> </span>
<a href="#l19.18"></a><span id="l19.18" class="difflineminus">-static void usage(char *name) {</span>
<a href="#l19.19"></a><span id="l19.19" class="difflineplus">+static void usage(char* name) {</span>
<a href="#l19.20"></a><span id="l19.20">   fprintf(stderr, &quot;usage: %s &lt; berfile\n&quot;, name);</span>
<a href="#l19.21"></a><span id="l19.21"> }</span>
<a href="#l19.22"></a><span id="l19.22"> </span>
<a href="#l19.23"></a><span id="l19.23" class="difflineminus">-main(int argc, char **argv) {</span>
<a href="#l19.24"></a><span id="l19.24" class="difflineplus">+main(int argc, char** argv) {</span>
<a href="#l19.25"></a><span id="l19.25">   long i, fd;</span>
<a href="#l19.26"></a><span id="l19.26">   ber_len_t len;</span>
<a href="#l19.27"></a><span id="l19.27">   ber_tag_t tag;</span>
<a href="#l19.28"></a><span id="l19.28" class="difflineminus">-  BerElement *ber;</span>
<a href="#l19.29"></a><span id="l19.29" class="difflineminus">-  Sockbuf *sb;</span>
<a href="#l19.30"></a><span id="l19.30" class="difflineplus">+  BerElement* ber;</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineplus">+  Sockbuf* sb;</span>
<a href="#l19.32"></a><span id="l19.32">   extern int lber_debug;</span>
<a href="#l19.33"></a><span id="l19.33"> </span>
<a href="#l19.34"></a><span id="l19.34">   lber_debug = 255;</span>
<a href="#l19.35"></a><span id="l19.35">   if (argc &gt; 1) {</span>
<a href="#l19.36"></a><span id="l19.36">     usage(argv[0]);</span>
<a href="#l19.37"></a><span id="l19.37">     exit(1);</span>
<a href="#l19.38"></a><span id="l19.38">   }</span>
<a href="#l19.39"></a><span id="l19.39"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/encode.c</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/encode.c</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -60,25 +60,25 @@ static int ber_calc_taglen(ber_tag_t tag</span>
<a href="#l20.4"></a><span id="l20.4">     mask = (0xff &lt;&lt; (i * 8));</span>
<a href="#l20.5"></a><span id="l20.5">     /* not all zero */</span>
<a href="#l20.6"></a><span id="l20.6">     if (tag &amp; mask) break;</span>
<a href="#l20.7"></a><span id="l20.7">   }</span>
<a href="#l20.8"></a><span id="l20.8"> </span>
<a href="#l20.9"></a><span id="l20.9">   return (i + 1);</span>
<a href="#l20.10"></a><span id="l20.10"> }</span>
<a href="#l20.11"></a><span id="l20.11"> </span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-static int ber_put_tag(BerElement *ber, ber_tag_t tag, int nosos) {</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+static int ber_put_tag(BerElement* ber, ber_tag_t tag, int nosos) {</span>
<a href="#l20.14"></a><span id="l20.14">   int taglen;</span>
<a href="#l20.15"></a><span id="l20.15">   ber_tag_t ntag;</span>
<a href="#l20.16"></a><span id="l20.16"> </span>
<a href="#l20.17"></a><span id="l20.17">   taglen = ber_calc_taglen(tag);</span>
<a href="#l20.18"></a><span id="l20.18"> </span>
<a href="#l20.19"></a><span id="l20.19">   ntag = LBER_HTONL(tag);</span>
<a href="#l20.20"></a><span id="l20.20"> </span>
<a href="#l20.21"></a><span id="l20.21" class="difflineminus">-  return (ber_write(ber, ((char *)&amp;ntag) + sizeof(ber_int_t) - taglen, taglen,</span>
<a href="#l20.22"></a><span id="l20.22" class="difflineplus">+  return (ber_write(ber, ((char*)&amp;ntag) + sizeof(ber_int_t) - taglen, taglen,</span>
<a href="#l20.23"></a><span id="l20.23">                     nosos));</span>
<a href="#l20.24"></a><span id="l20.24"> }</span>
<a href="#l20.25"></a><span id="l20.25"> </span>
<a href="#l20.26"></a><span id="l20.26"> static int ber_calc_lenlen(ber_len_t len) {</span>
<a href="#l20.27"></a><span id="l20.27">   /*</span>
<a href="#l20.28"></a><span id="l20.28">    * short len if it's less than 128 - one byte giving the len,</span>
<a href="#l20.29"></a><span id="l20.29">    * with bit 8 0.</span>
<a href="#l20.30"></a><span id="l20.30">    */</span>
<a href="#l20.31"></a><span id="l20.31" class="difflineat">@@ -92,30 +92,30 @@ static int ber_calc_lenlen(ber_len_t len</span>
<a href="#l20.32"></a><span id="l20.32"> </span>
<a href="#l20.33"></a><span id="l20.33">   if (len &lt;= 0xFF) return (2);</span>
<a href="#l20.34"></a><span id="l20.34">   if (len &lt;= 0xFFFF) return (3);</span>
<a href="#l20.35"></a><span id="l20.35">   if (len &lt;= 0xFFFFFF) return (4);</span>
<a href="#l20.36"></a><span id="l20.36"> </span>
<a href="#l20.37"></a><span id="l20.37">   return (5);</span>
<a href="#l20.38"></a><span id="l20.38"> }</span>
<a href="#l20.39"></a><span id="l20.39"> </span>
<a href="#l20.40"></a><span id="l20.40" class="difflineminus">-static int ber_put_len(BerElement *ber, ber_len_t len, int nosos) {</span>
<a href="#l20.41"></a><span id="l20.41" class="difflineplus">+static int ber_put_len(BerElement* ber, ber_len_t len, int nosos) {</span>
<a href="#l20.42"></a><span id="l20.42">   int i;</span>
<a href="#l20.43"></a><span id="l20.43">   char lenlen;</span>
<a href="#l20.44"></a><span id="l20.44">   ber_int_t mask;</span>
<a href="#l20.45"></a><span id="l20.45">   ber_len_t netlen;</span>
<a href="#l20.46"></a><span id="l20.46"> </span>
<a href="#l20.47"></a><span id="l20.47">   /*</span>
<a href="#l20.48"></a><span id="l20.48">    * short len if it's less than 128 - one byte giving the len,</span>
<a href="#l20.49"></a><span id="l20.49">    * with bit 8 0.</span>
<a href="#l20.50"></a><span id="l20.50">    */</span>
<a href="#l20.51"></a><span id="l20.51"> </span>
<a href="#l20.52"></a><span id="l20.52">   if (len &lt;= 127) {</span>
<a href="#l20.53"></a><span id="l20.53">     netlen = LBER_HTONL(len);</span>
<a href="#l20.54"></a><span id="l20.54" class="difflineminus">-    return (ber_write(ber, (char *)&amp;netlen + sizeof(ber_int_t) - 1, 1, nosos));</span>
<a href="#l20.55"></a><span id="l20.55" class="difflineplus">+    return (ber_write(ber, (char*)&amp;netlen + sizeof(ber_int_t) - 1, 1, nosos));</span>
<a href="#l20.56"></a><span id="l20.56">   }</span>
<a href="#l20.57"></a><span id="l20.57"> </span>
<a href="#l20.58"></a><span id="l20.58">   /*</span>
<a href="#l20.59"></a><span id="l20.59">    * long len otherwise - one byte with bit 8 set, giving the</span>
<a href="#l20.60"></a><span id="l20.60">    * length of the length, followed by the length itself.</span>
<a href="#l20.61"></a><span id="l20.61">    */</span>
<a href="#l20.62"></a><span id="l20.62"> </span>
<a href="#l20.63"></a><span id="l20.63">   /* find the first non-all-zero byte */</span>
<a href="#l20.64"></a><span id="l20.64" class="difflineat">@@ -128,23 +128,23 @@ static int ber_put_len(BerElement *ber, </span>
<a href="#l20.65"></a><span id="l20.65">   if (lenlen &gt; 4) return (-1);</span>
<a href="#l20.66"></a><span id="l20.66">   lenlen |= 0x80;</span>
<a href="#l20.67"></a><span id="l20.67"> </span>
<a href="#l20.68"></a><span id="l20.68">   /* write the length of the length */</span>
<a href="#l20.69"></a><span id="l20.69">   if (ber_write(ber, &amp;lenlen, 1, nosos) != 1) return (-1);</span>
<a href="#l20.70"></a><span id="l20.70"> </span>
<a href="#l20.71"></a><span id="l20.71">   /* write the length itself */</span>
<a href="#l20.72"></a><span id="l20.72">   netlen = LBER_HTONL(len);</span>
<a href="#l20.73"></a><span id="l20.73" class="difflineminus">-  if (ber_write(ber, (char *)&amp;netlen + (sizeof(ber_int_t) - i), i, nosos) != i)</span>
<a href="#l20.74"></a><span id="l20.74" class="difflineplus">+  if (ber_write(ber, (char*)&amp;netlen + (sizeof(ber_int_t) - i), i, nosos) != i)</span>
<a href="#l20.75"></a><span id="l20.75">     return (-1);</span>
<a href="#l20.76"></a><span id="l20.76"> </span>
<a href="#l20.77"></a><span id="l20.77">   return (i + 1);</span>
<a href="#l20.78"></a><span id="l20.78"> }</span>
<a href="#l20.79"></a><span id="l20.79"> </span>
<a href="#l20.80"></a><span id="l20.80" class="difflineminus">-static int ber_put_int_or_enum(BerElement *ber, ber_int_t num, ber_tag_t tag) {</span>
<a href="#l20.81"></a><span id="l20.81" class="difflineplus">+static int ber_put_int_or_enum(BerElement* ber, ber_int_t num, ber_tag_t tag) {</span>
<a href="#l20.82"></a><span id="l20.82">   int i, sign, taglen;</span>
<a href="#l20.83"></a><span id="l20.83">   int len, lenlen;</span>
<a href="#l20.84"></a><span id="l20.84">   ber_int_t netnum, mask;</span>
<a href="#l20.85"></a><span id="l20.85"> </span>
<a href="#l20.86"></a><span id="l20.86">   sign = (num &lt; 0);</span>
<a href="#l20.87"></a><span id="l20.87"> </span>
<a href="#l20.88"></a><span id="l20.88">   /*</span>
<a href="#l20.89"></a><span id="l20.89">    * high bit is set - look for first non-all-one byte</span>
<a href="#l20.90"></a><span id="l20.90" class="difflineat">@@ -171,36 +171,36 @@ static int ber_put_int_or_enum(BerElemen</span>
<a href="#l20.91"></a><span id="l20.91"> </span>
<a href="#l20.92"></a><span id="l20.92">   len = i + 1;</span>
<a href="#l20.93"></a><span id="l20.93"> </span>
<a href="#l20.94"></a><span id="l20.94">   if ((taglen = ber_put_tag(ber, tag, 0)) == -1) return (-1);</span>
<a href="#l20.95"></a><span id="l20.95"> </span>
<a href="#l20.96"></a><span id="l20.96">   if ((lenlen = ber_put_len(ber, len, 0)) == -1) return (-1);</span>
<a href="#l20.97"></a><span id="l20.97">   i++;</span>
<a href="#l20.98"></a><span id="l20.98">   netnum = LBER_HTONL(num);</span>
<a href="#l20.99"></a><span id="l20.99" class="difflineminus">-  if (ber_write(ber, (char *)&amp;netnum + (sizeof(ber_int_t) - i), i, 0) == i)</span>
<a href="#l20.100"></a><span id="l20.100" class="difflineplus">+  if (ber_write(ber, (char*)&amp;netnum + (sizeof(ber_int_t) - i), i, 0) == i)</span>
<a href="#l20.101"></a><span id="l20.101">     /* length of tag + length + contents */</span>
<a href="#l20.102"></a><span id="l20.102">     return (taglen + lenlen + i);</span>
<a href="#l20.103"></a><span id="l20.103"> </span>
<a href="#l20.104"></a><span id="l20.104">   return (-1);</span>
<a href="#l20.105"></a><span id="l20.105"> }</span>
<a href="#l20.106"></a><span id="l20.106"> </span>
<a href="#l20.107"></a><span id="l20.107" class="difflineminus">-int LDAP_CALL ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag) {</span>
<a href="#l20.108"></a><span id="l20.108" class="difflineplus">+int LDAP_CALL ber_put_enum(BerElement* ber, ber_int_t num, ber_tag_t tag) {</span>
<a href="#l20.109"></a><span id="l20.109">   if (tag == LBER_DEFAULT) tag = LBER_ENUMERATED;</span>
<a href="#l20.110"></a><span id="l20.110"> </span>
<a href="#l20.111"></a><span id="l20.111">   return (ber_put_int_or_enum(ber, num, tag));</span>
<a href="#l20.112"></a><span id="l20.112"> }</span>
<a href="#l20.113"></a><span id="l20.113"> </span>
<a href="#l20.114"></a><span id="l20.114" class="difflineminus">-int LDAP_CALL ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag) {</span>
<a href="#l20.115"></a><span id="l20.115" class="difflineplus">+int LDAP_CALL ber_put_int(BerElement* ber, ber_int_t num, ber_tag_t tag) {</span>
<a href="#l20.116"></a><span id="l20.116">   if (tag == LBER_DEFAULT) tag = LBER_INTEGER;</span>
<a href="#l20.117"></a><span id="l20.117"> </span>
<a href="#l20.118"></a><span id="l20.118">   return (ber_put_int_or_enum(ber, num, tag));</span>
<a href="#l20.119"></a><span id="l20.119"> }</span>
<a href="#l20.120"></a><span id="l20.120"> </span>
<a href="#l20.121"></a><span id="l20.121" class="difflineminus">-int LDAP_CALL ber_put_ostring(BerElement *ber, char *str, ber_len_t len,</span>
<a href="#l20.122"></a><span id="l20.122" class="difflineplus">+int LDAP_CALL ber_put_ostring(BerElement* ber, char* str, ber_len_t len,</span>
<a href="#l20.123"></a><span id="l20.123">                               ber_tag_t tag) {</span>
<a href="#l20.124"></a><span id="l20.124">   int taglen, lenlen, rc;</span>
<a href="#l20.125"></a><span id="l20.125"> #ifdef STR_TRANSLATION</span>
<a href="#l20.126"></a><span id="l20.126">   int free_str;</span>
<a href="#l20.127"></a><span id="l20.127"> #endif /* STR_TRANSLATION */</span>
<a href="#l20.128"></a><span id="l20.128"> </span>
<a href="#l20.129"></a><span id="l20.129">   if (tag == LBER_DEFAULT) tag = LBER_OCTETSTRING;</span>
<a href="#l20.130"></a><span id="l20.130"> </span>
<a href="#l20.131"></a><span id="l20.131" class="difflineat">@@ -235,91 +235,91 @@ int LDAP_CALL ber_put_ostring(BerElement</span>
<a href="#l20.132"></a><span id="l20.132">   if (free_str) {</span>
<a href="#l20.133"></a><span id="l20.133">     NSLBERI_FREE(str);</span>
<a href="#l20.134"></a><span id="l20.134">   }</span>
<a href="#l20.135"></a><span id="l20.135"> #endif /* STR_TRANSLATION */</span>
<a href="#l20.136"></a><span id="l20.136"> </span>
<a href="#l20.137"></a><span id="l20.137">   return (rc);</span>
<a href="#l20.138"></a><span id="l20.138"> }</span>
<a href="#l20.139"></a><span id="l20.139"> </span>
<a href="#l20.140"></a><span id="l20.140" class="difflineminus">-int LDAP_CALL ber_put_string(BerElement *ber, char *str, ber_tag_t tag) {</span>
<a href="#l20.141"></a><span id="l20.141" class="difflineplus">+int LDAP_CALL ber_put_string(BerElement* ber, char* str, ber_tag_t tag) {</span>
<a href="#l20.142"></a><span id="l20.142">   return (ber_put_ostring(ber, str, (ber_len_t)strlen(str), tag));</span>
<a href="#l20.143"></a><span id="l20.143"> }</span>
<a href="#l20.144"></a><span id="l20.144"> </span>
<a href="#l20.145"></a><span id="l20.145" class="difflineminus">-int LDAP_CALL ber_put_bitstring(BerElement *ber, char *str,</span>
<a href="#l20.146"></a><span id="l20.146" class="difflineplus">+int LDAP_CALL ber_put_bitstring(BerElement* ber, char* str,</span>
<a href="#l20.147"></a><span id="l20.147">                                 ber_len_t blen /* in bits */, ber_tag_t tag) {</span>
<a href="#l20.148"></a><span id="l20.148">   int taglen, lenlen, len;</span>
<a href="#l20.149"></a><span id="l20.149">   unsigned char unusedbits;</span>
<a href="#l20.150"></a><span id="l20.150"> </span>
<a href="#l20.151"></a><span id="l20.151">   if (tag == LBER_DEFAULT) tag = LBER_BITSTRING;</span>
<a href="#l20.152"></a><span id="l20.152"> </span>
<a href="#l20.153"></a><span id="l20.153">   if ((taglen = ber_put_tag(ber, tag, 0)) == -1) return (-1);</span>
<a href="#l20.154"></a><span id="l20.154"> </span>
<a href="#l20.155"></a><span id="l20.155">   len = (blen + 7) / 8;</span>
<a href="#l20.156"></a><span id="l20.156">   unusedbits = (unsigned char)(len * 8 - blen);</span>
<a href="#l20.157"></a><span id="l20.157">   if ((lenlen = ber_put_len(ber, len + 1, 0)) == -1) return (-1);</span>
<a href="#l20.158"></a><span id="l20.158"> </span>
<a href="#l20.159"></a><span id="l20.159" class="difflineminus">-  if (ber_write(ber, (char *)&amp;unusedbits, 1, 0) != 1) return (-1);</span>
<a href="#l20.160"></a><span id="l20.160" class="difflineplus">+  if (ber_write(ber, (char*)&amp;unusedbits, 1, 0) != 1) return (-1);</span>
<a href="#l20.161"></a><span id="l20.161"> </span>
<a href="#l20.162"></a><span id="l20.162">   if (ber_write(ber, str, len, 0) != len) return (-1);</span>
<a href="#l20.163"></a><span id="l20.163"> </span>
<a href="#l20.164"></a><span id="l20.164">   /* return length of tag + length + unused bit count + contents */</span>
<a href="#l20.165"></a><span id="l20.165">   return (taglen + 1 + lenlen + len);</span>
<a href="#l20.166"></a><span id="l20.166"> }</span>
<a href="#l20.167"></a><span id="l20.167"> </span>
<a href="#l20.168"></a><span id="l20.168" class="difflineminus">-int LDAP_CALL ber_put_null(BerElement *ber, ber_tag_t tag) {</span>
<a href="#l20.169"></a><span id="l20.169" class="difflineplus">+int LDAP_CALL ber_put_null(BerElement* ber, ber_tag_t tag) {</span>
<a href="#l20.170"></a><span id="l20.170">   int taglen;</span>
<a href="#l20.171"></a><span id="l20.171"> </span>
<a href="#l20.172"></a><span id="l20.172">   if (tag == LBER_DEFAULT) tag = LBER_NULL;</span>
<a href="#l20.173"></a><span id="l20.173"> </span>
<a href="#l20.174"></a><span id="l20.174">   if ((taglen = ber_put_tag(ber, tag, 0)) == -1) return (-1);</span>
<a href="#l20.175"></a><span id="l20.175"> </span>
<a href="#l20.176"></a><span id="l20.176">   if (ber_put_len(ber, 0, 0) != 1) return (-1);</span>
<a href="#l20.177"></a><span id="l20.177"> </span>
<a href="#l20.178"></a><span id="l20.178">   return (taglen + 1);</span>
<a href="#l20.179"></a><span id="l20.179"> }</span>
<a href="#l20.180"></a><span id="l20.180"> </span>
<a href="#l20.181"></a><span id="l20.181" class="difflineminus">-int LDAP_CALL ber_put_boolean(BerElement *ber, ber_int_t boolval,</span>
<a href="#l20.182"></a><span id="l20.182" class="difflineplus">+int LDAP_CALL ber_put_boolean(BerElement* ber, ber_int_t boolval,</span>
<a href="#l20.183"></a><span id="l20.183">                               ber_tag_t tag) {</span>
<a href="#l20.184"></a><span id="l20.184">   int taglen;</span>
<a href="#l20.185"></a><span id="l20.185">   unsigned char trueval = 0xff;</span>
<a href="#l20.186"></a><span id="l20.186">   unsigned char falseval = 0x00;</span>
<a href="#l20.187"></a><span id="l20.187"> </span>
<a href="#l20.188"></a><span id="l20.188">   if (tag == LBER_DEFAULT) tag = LBER_BOOLEAN;</span>
<a href="#l20.189"></a><span id="l20.189"> </span>
<a href="#l20.190"></a><span id="l20.190">   if ((taglen = ber_put_tag(ber, tag, 0)) == -1) return (-1);</span>
<a href="#l20.191"></a><span id="l20.191"> </span>
<a href="#l20.192"></a><span id="l20.192">   if (ber_put_len(ber, 1, 0) != 1) return (-1);</span>
<a href="#l20.193"></a><span id="l20.193"> </span>
<a href="#l20.194"></a><span id="l20.194" class="difflineminus">-  if (ber_write(ber, (char *)(boolval ? &amp;trueval : &amp;falseval), 1, 0) != 1)</span>
<a href="#l20.195"></a><span id="l20.195" class="difflineplus">+  if (ber_write(ber, (char*)(boolval ? &amp;trueval : &amp;falseval), 1, 0) != 1)</span>
<a href="#l20.196"></a><span id="l20.196">     return (-1);</span>
<a href="#l20.197"></a><span id="l20.197"> </span>
<a href="#l20.198"></a><span id="l20.198">   return (taglen + 2);</span>
<a href="#l20.199"></a><span id="l20.199"> }</span>
<a href="#l20.200"></a><span id="l20.200"> </span>
<a href="#l20.201"></a><span id="l20.201"> #define FOUR_BYTE_LEN 5</span>
<a href="#l20.202"></a><span id="l20.202"> </span>
<a href="#l20.203"></a><span id="l20.203"> /* the idea here is roughly this: we maintain a stack of these Seqorset</span>
<a href="#l20.204"></a><span id="l20.204">  * structures. This is pushed when we see the beginning of a new set or</span>
<a href="#l20.205"></a><span id="l20.205">  * sequence. It is popped when we see the end of a set or sequence.</span>
<a href="#l20.206"></a><span id="l20.206">  * Since we don't want to malloc and free these structures all the time,</span>
<a href="#l20.207"></a><span id="l20.207">  * we pre-allocate a small set of them within the ber element structure.</span>
<a href="#l20.208"></a><span id="l20.208">  * thus we need to spot when we've overflowed this stack and fall back to</span>
<a href="#l20.209"></a><span id="l20.209">  * malloc'ing instead.</span>
<a href="#l20.210"></a><span id="l20.210">  */</span>
<a href="#l20.211"></a><span id="l20.211" class="difflineminus">-static int ber_start_seqorset(BerElement *ber, ber_tag_t tag) {</span>
<a href="#l20.212"></a><span id="l20.212" class="difflineminus">-  Seqorset *new_sos;</span>
<a href="#l20.213"></a><span id="l20.213" class="difflineplus">+static int ber_start_seqorset(BerElement* ber, ber_tag_t tag) {</span>
<a href="#l20.214"></a><span id="l20.214" class="difflineplus">+  Seqorset* new_sos;</span>
<a href="#l20.215"></a><span id="l20.215"> </span>
<a href="#l20.216"></a><span id="l20.216">   /* can we fit into the local stack ? */</span>
<a href="#l20.217"></a><span id="l20.217">   if (ber-&gt;ber_sos_stack_posn &lt; SOS_STACK_SIZE) {</span>
<a href="#l20.218"></a><span id="l20.218">     /* yes */</span>
<a href="#l20.219"></a><span id="l20.219">     new_sos = &amp;ber-&gt;ber_sos_stack[ber-&gt;ber_sos_stack_posn];</span>
<a href="#l20.220"></a><span id="l20.220">   } else {</span>
<a href="#l20.221"></a><span id="l20.221">     /* no */</span>
<a href="#l20.222"></a><span id="l20.222" class="difflineminus">-    if ((new_sos = (Seqorset *)NSLBERI_MALLOC(sizeof(Seqorset))) ==</span>
<a href="#l20.223"></a><span id="l20.223" class="difflineplus">+    if ((new_sos = (Seqorset*)NSLBERI_MALLOC(sizeof(Seqorset))) ==</span>
<a href="#l20.224"></a><span id="l20.224">         NULLSEQORSET) {</span>
<a href="#l20.225"></a><span id="l20.225">       return (-1);</span>
<a href="#l20.226"></a><span id="l20.226">     }</span>
<a href="#l20.227"></a><span id="l20.227">   }</span>
<a href="#l20.228"></a><span id="l20.228">   ber-&gt;ber_sos_stack_posn++;</span>
<a href="#l20.229"></a><span id="l20.229"> </span>
<a href="#l20.230"></a><span id="l20.230">   if (ber-&gt;ber_sos == NULLSEQORSET)</span>
<a href="#l20.231"></a><span id="l20.231">     new_sos-&gt;sos_first = ber-&gt;ber_ptr;</span>
<a href="#l20.232"></a><span id="l20.232" class="difflineat">@@ -335,34 +335,34 @@ static int ber_start_seqorset(BerElement</span>
<a href="#l20.233"></a><span id="l20.233"> </span>
<a href="#l20.234"></a><span id="l20.234">   ber-&gt;ber_sos = new_sos;</span>
<a href="#l20.235"></a><span id="l20.235">   if (ber-&gt;ber_sos-&gt;sos_ptr &gt; ber-&gt;ber_end) {</span>
<a href="#l20.236"></a><span id="l20.236">     nslberi_ber_realloc(ber, ber-&gt;ber_sos-&gt;sos_ptr - ber-&gt;ber_end);</span>
<a href="#l20.237"></a><span id="l20.237">   }</span>
<a href="#l20.238"></a><span id="l20.238">   return (0);</span>
<a href="#l20.239"></a><span id="l20.239"> }</span>
<a href="#l20.240"></a><span id="l20.240"> </span>
<a href="#l20.241"></a><span id="l20.241" class="difflineminus">-int LDAP_CALL ber_start_seq(BerElement *ber, ber_tag_t tag) {</span>
<a href="#l20.242"></a><span id="l20.242" class="difflineplus">+int LDAP_CALL ber_start_seq(BerElement* ber, ber_tag_t tag) {</span>
<a href="#l20.243"></a><span id="l20.243">   if (tag == LBER_DEFAULT) tag = LBER_SEQUENCE;</span>
<a href="#l20.244"></a><span id="l20.244"> </span>
<a href="#l20.245"></a><span id="l20.245">   return (ber_start_seqorset(ber, tag));</span>
<a href="#l20.246"></a><span id="l20.246"> }</span>
<a href="#l20.247"></a><span id="l20.247"> </span>
<a href="#l20.248"></a><span id="l20.248" class="difflineminus">-int LDAP_CALL ber_start_set(BerElement *ber, ber_tag_t tag) {</span>
<a href="#l20.249"></a><span id="l20.249" class="difflineplus">+int LDAP_CALL ber_start_set(BerElement* ber, ber_tag_t tag) {</span>
<a href="#l20.250"></a><span id="l20.250">   if (tag == LBER_DEFAULT) tag = LBER_SET;</span>
<a href="#l20.251"></a><span id="l20.251"> </span>
<a href="#l20.252"></a><span id="l20.252">   return (ber_start_seqorset(ber, tag));</span>
<a href="#l20.253"></a><span id="l20.253"> }</span>
<a href="#l20.254"></a><span id="l20.254"> </span>
<a href="#l20.255"></a><span id="l20.255" class="difflineminus">-static int ber_put_seqorset(BerElement *ber) {</span>
<a href="#l20.256"></a><span id="l20.256" class="difflineplus">+static int ber_put_seqorset(BerElement* ber) {</span>
<a href="#l20.257"></a><span id="l20.257">   ber_len_t len, netlen;</span>
<a href="#l20.258"></a><span id="l20.258">   int taglen, lenlen;</span>
<a href="#l20.259"></a><span id="l20.259">   unsigned char ltag = 0x80 + FOUR_BYTE_LEN - 1;</span>
<a href="#l20.260"></a><span id="l20.260" class="difflineminus">-  Seqorset *next;</span>
<a href="#l20.261"></a><span id="l20.261" class="difflineminus">-  Seqorset **sos = &amp;ber-&gt;ber_sos;</span>
<a href="#l20.262"></a><span id="l20.262" class="difflineplus">+  Seqorset* next;</span>
<a href="#l20.263"></a><span id="l20.263" class="difflineplus">+  Seqorset** sos = &amp;ber-&gt;ber_sos;</span>
<a href="#l20.264"></a><span id="l20.264"> </span>
<a href="#l20.265"></a><span id="l20.265">   if (*sos == NULL) {</span>
<a href="#l20.266"></a><span id="l20.266">     /* No sequence or set to put... fatal error. */</span>
<a href="#l20.267"></a><span id="l20.267">     return (-1);</span>
<a href="#l20.268"></a><span id="l20.268">   }</span>
<a href="#l20.269"></a><span id="l20.269"> </span>
<a href="#l20.270"></a><span id="l20.270">   /*</span>
<a href="#l20.271"></a><span id="l20.271">    * If this is the toplevel sequence or set, we need to actually</span>
<a href="#l20.272"></a><span id="l20.272" class="difflineat">@@ -397,90 +397,90 @@ static int ber_put_seqorset(BerElement *</span>
<a href="#l20.273"></a><span id="l20.273">          * we don't actually need that much</span>
<a href="#l20.274"></a><span id="l20.274">          */</span>
<a href="#l20.275"></a><span id="l20.275">         SAFEMEMCPY((*sos)-&gt;sos_first + taglen + lenlen,</span>
<a href="#l20.276"></a><span id="l20.276">                    (*sos)-&gt;sos_first + taglen + FOUR_BYTE_LEN, len);</span>
<a href="#l20.277"></a><span id="l20.277">       }</span>
<a href="#l20.278"></a><span id="l20.278">     } else {</span>
<a href="#l20.279"></a><span id="l20.279">       /* Fill FOUR_BYTE_LEN bytes for length field */</span>
<a href="#l20.280"></a><span id="l20.280">       /* one byte of length length */</span>
<a href="#l20.281"></a><span id="l20.281" class="difflineminus">-      if (ber_write(ber, (char *)&amp;ltag, 1, 1) != 1) return (-1);</span>
<a href="#l20.282"></a><span id="l20.282" class="difflineplus">+      if (ber_write(ber, (char*)&amp;ltag, 1, 1) != 1) return (-1);</span>
<a href="#l20.283"></a><span id="l20.283"> </span>
<a href="#l20.284"></a><span id="l20.284">       /* the length itself */</span>
<a href="#l20.285"></a><span id="l20.285">       if (ber_write(ber,</span>
<a href="#l20.286"></a><span id="l20.286" class="difflineminus">-                    (char *)&amp;netlen + sizeof(ber_int_t) - (FOUR_BYTE_LEN - 1),</span>
<a href="#l20.287"></a><span id="l20.287" class="difflineplus">+                    (char*)&amp;netlen + sizeof(ber_int_t) - (FOUR_BYTE_LEN - 1),</span>
<a href="#l20.288"></a><span id="l20.288">                     FOUR_BYTE_LEN - 1, 1) != FOUR_BYTE_LEN - 1)</span>
<a href="#l20.289"></a><span id="l20.289">         return (-1);</span>
<a href="#l20.290"></a><span id="l20.290">     }</span>
<a href="#l20.291"></a><span id="l20.291">     /* The ber_ptr is at the set/seq start - move it to the end */</span>
<a href="#l20.292"></a><span id="l20.292">     ber-&gt;ber_ptr += len;</span>
<a href="#l20.293"></a><span id="l20.293">   } else {</span>
<a href="#l20.294"></a><span id="l20.294">     ber_tag_t ntag;</span>
<a href="#l20.295"></a><span id="l20.295"> </span>
<a href="#l20.296"></a><span id="l20.296">     /* the tag */</span>
<a href="#l20.297"></a><span id="l20.297">     taglen = ber_calc_taglen((*sos)-&gt;sos_tag);</span>
<a href="#l20.298"></a><span id="l20.298">     ntag = LBER_HTONL((*sos)-&gt;sos_tag);</span>
<a href="#l20.299"></a><span id="l20.299" class="difflineminus">-    SAFEMEMCPY((*sos)-&gt;sos_first, (char *)&amp;ntag + sizeof(ber_int_t) - taglen,</span>
<a href="#l20.300"></a><span id="l20.300" class="difflineplus">+    SAFEMEMCPY((*sos)-&gt;sos_first, (char*)&amp;ntag + sizeof(ber_int_t) - taglen,</span>
<a href="#l20.301"></a><span id="l20.301">                taglen);</span>
<a href="#l20.302"></a><span id="l20.302"> </span>
<a href="#l20.303"></a><span id="l20.303">     if (ber-&gt;ber_options &amp; LBER_OPT_USE_DER) {</span>
<a href="#l20.304"></a><span id="l20.304">       ltag = (lenlen == 1) ? (unsigned char)len</span>
<a href="#l20.305"></a><span id="l20.305">                            : (unsigned char)(0x80 + (lenlen - 1));</span>
<a href="#l20.306"></a><span id="l20.306">     }</span>
<a href="#l20.307"></a><span id="l20.307"> </span>
<a href="#l20.308"></a><span id="l20.308">     /* one byte of length length */</span>
<a href="#l20.309"></a><span id="l20.309">     SAFEMEMCPY((*sos)-&gt;sos_first + 1, &amp;ltag, 1);</span>
<a href="#l20.310"></a><span id="l20.310"> </span>
<a href="#l20.311"></a><span id="l20.311">     if (ber-&gt;ber_options &amp; LBER_OPT_USE_DER) {</span>
<a href="#l20.312"></a><span id="l20.312">       if (lenlen &gt; 1) {</span>
<a href="#l20.313"></a><span id="l20.313">         /* Write the length itself */</span>
<a href="#l20.314"></a><span id="l20.314">         SAFEMEMCPY((*sos)-&gt;sos_first + 2,</span>
<a href="#l20.315"></a><span id="l20.315" class="difflineminus">-                   (char *)&amp;netlen + sizeof(ber_uint_t) - (lenlen - 1),</span>
<a href="#l20.316"></a><span id="l20.316" class="difflineplus">+                   (char*)&amp;netlen + sizeof(ber_uint_t) - (lenlen - 1),</span>
<a href="#l20.317"></a><span id="l20.317">                    lenlen - 1);</span>
<a href="#l20.318"></a><span id="l20.318">       }</span>
<a href="#l20.319"></a><span id="l20.319">       if (lenlen != FOUR_BYTE_LEN) {</span>
<a href="#l20.320"></a><span id="l20.320">         /*</span>
<a href="#l20.321"></a><span id="l20.321">          * We set aside FOUR_BYTE_LEN bytes for</span>
<a href="#l20.322"></a><span id="l20.322">          * the length field.  Move the data if</span>
<a href="#l20.323"></a><span id="l20.323">          * we don't actually need that much</span>
<a href="#l20.324"></a><span id="l20.324">          */</span>
<a href="#l20.325"></a><span id="l20.325">         SAFEMEMCPY((*sos)-&gt;sos_first + taglen + lenlen,</span>
<a href="#l20.326"></a><span id="l20.326">                    (*sos)-&gt;sos_first + taglen + FOUR_BYTE_LEN, len);</span>
<a href="#l20.327"></a><span id="l20.327">       }</span>
<a href="#l20.328"></a><span id="l20.328">     } else {</span>
<a href="#l20.329"></a><span id="l20.329">       /* the length itself */</span>
<a href="#l20.330"></a><span id="l20.330">       SAFEMEMCPY((*sos)-&gt;sos_first + taglen + 1,</span>
<a href="#l20.331"></a><span id="l20.331" class="difflineminus">-                 (char *)&amp;netlen + sizeof(ber_int_t) - (FOUR_BYTE_LEN - 1),</span>
<a href="#l20.332"></a><span id="l20.332" class="difflineplus">+                 (char*)&amp;netlen + sizeof(ber_int_t) - (FOUR_BYTE_LEN - 1),</span>
<a href="#l20.333"></a><span id="l20.333">                  FOUR_BYTE_LEN - 1);</span>
<a href="#l20.334"></a><span id="l20.334">     }</span>
<a href="#l20.335"></a><span id="l20.335"> </span>
<a href="#l20.336"></a><span id="l20.336">     next-&gt;sos_clen += (taglen + lenlen + len);</span>
<a href="#l20.337"></a><span id="l20.337">     next-&gt;sos_ptr += (taglen + lenlen + len);</span>
<a href="#l20.338"></a><span id="l20.338">   }</span>
<a href="#l20.339"></a><span id="l20.339"> </span>
<a href="#l20.340"></a><span id="l20.340">   /* we're done with this seqorset, so free it up */</span>
<a href="#l20.341"></a><span id="l20.341">   /* was this one from the local stack ? */</span>
<a href="#l20.342"></a><span id="l20.342">   if (ber-&gt;ber_sos_stack_posn &lt;= SOS_STACK_SIZE) {</span>
<a href="#l20.343"></a><span id="l20.343">     /* yes */</span>
<a href="#l20.344"></a><span id="l20.344">   } else {</span>
<a href="#l20.345"></a><span id="l20.345">     /* no */</span>
<a href="#l20.346"></a><span id="l20.346" class="difflineminus">-    NSLBERI_FREE((char *)(*sos));</span>
<a href="#l20.347"></a><span id="l20.347" class="difflineplus">+    NSLBERI_FREE((char*)(*sos));</span>
<a href="#l20.348"></a><span id="l20.348">   }</span>
<a href="#l20.349"></a><span id="l20.349">   ber-&gt;ber_sos_stack_posn--;</span>
<a href="#l20.350"></a><span id="l20.350">   *sos = next;</span>
<a href="#l20.351"></a><span id="l20.351"> </span>
<a href="#l20.352"></a><span id="l20.352">   return (taglen + lenlen + len);</span>
<a href="#l20.353"></a><span id="l20.353"> }</span>
<a href="#l20.354"></a><span id="l20.354"> </span>
<a href="#l20.355"></a><span id="l20.355" class="difflineminus">-int LDAP_CALL ber_put_seq(BerElement *ber) { return (ber_put_seqorset(ber)); }</span>
<a href="#l20.356"></a><span id="l20.356" class="difflineplus">+int LDAP_CALL ber_put_seq(BerElement* ber) { return (ber_put_seqorset(ber)); }</span>
<a href="#l20.357"></a><span id="l20.357"> </span>
<a href="#l20.358"></a><span id="l20.358" class="difflineminus">-int LDAP_CALL ber_put_set(BerElement *ber) { return (ber_put_seqorset(ber)); }</span>
<a href="#l20.359"></a><span id="l20.359" class="difflineplus">+int LDAP_CALL ber_put_set(BerElement* ber) { return (ber_put_seqorset(ber)); }</span>
<a href="#l20.360"></a><span id="l20.360"> </span>
<a href="#l20.361"></a><span id="l20.361"> /* VARARGS */</span>
<a href="#l20.362"></a><span id="l20.362" class="difflineminus">-int LDAP_C ber_printf(BerElement *ber, const char *fmt, ...) {</span>
<a href="#l20.363"></a><span id="l20.363" class="difflineplus">+int LDAP_C ber_printf(BerElement* ber, const char* fmt, ...) {</span>
<a href="#l20.364"></a><span id="l20.364">   va_list ap;</span>
<a href="#l20.365"></a><span id="l20.365">   char *s, **ss;</span>
<a href="#l20.366"></a><span id="l20.366">   struct berval *bval, **bv;</span>
<a href="#l20.367"></a><span id="l20.367">   int rc, i;</span>
<a href="#l20.368"></a><span id="l20.368">   ber_len_t len;</span>
<a href="#l20.369"></a><span id="l20.369"> </span>
<a href="#l20.370"></a><span id="l20.370">   va_start(ap, fmt);</span>
<a href="#l20.371"></a><span id="l20.371"> </span>
<a href="#l20.372"></a><span id="l20.372" class="difflineat">@@ -509,55 +509,55 @@ int LDAP_C ber_printf(BerElement *ber, c</span>
<a href="#l20.373"></a><span id="l20.373">         rc = ber_put_enum(ber, (ber_int_t)i, ber-&gt;ber_tag);</span>
<a href="#l20.374"></a><span id="l20.374">         break;</span>
<a href="#l20.375"></a><span id="l20.375"> </span>
<a href="#l20.376"></a><span id="l20.376">       case 'n': /* null */</span>
<a href="#l20.377"></a><span id="l20.377">         rc = ber_put_null(ber, ber-&gt;ber_tag);</span>
<a href="#l20.378"></a><span id="l20.378">         break;</span>
<a href="#l20.379"></a><span id="l20.379"> </span>
<a href="#l20.380"></a><span id="l20.380">       case 'o': /* octet string (non-null terminated) */</span>
<a href="#l20.381"></a><span id="l20.381" class="difflineminus">-        s = va_arg(ap, char *);</span>
<a href="#l20.382"></a><span id="l20.382" class="difflineplus">+        s = va_arg(ap, char*);</span>
<a href="#l20.383"></a><span id="l20.383">         len = va_arg(ap, int);</span>
<a href="#l20.384"></a><span id="l20.384">         rc = ber_put_ostring(ber, s, len, ber-&gt;ber_tag);</span>
<a href="#l20.385"></a><span id="l20.385">         break;</span>
<a href="#l20.386"></a><span id="l20.386"> </span>
<a href="#l20.387"></a><span id="l20.387">       case 'O': /* berval octet string */</span>
<a href="#l20.388"></a><span id="l20.388" class="difflineminus">-        if ((bval = va_arg(ap, struct berval *)) == NULL) break;</span>
<a href="#l20.389"></a><span id="l20.389" class="difflineplus">+        if ((bval = va_arg(ap, struct berval*)) == NULL) break;</span>
<a href="#l20.390"></a><span id="l20.390">         if (bval-&gt;bv_len == 0) {</span>
<a href="#l20.391"></a><span id="l20.391">           rc = ber_put_ostring(ber, &quot;&quot;, 0, ber-&gt;ber_tag);</span>
<a href="#l20.392"></a><span id="l20.392">         } else {</span>
<a href="#l20.393"></a><span id="l20.393">           rc = ber_put_ostring(ber, bval-&gt;bv_val, bval-&gt;bv_len, ber-&gt;ber_tag);</span>
<a href="#l20.394"></a><span id="l20.394">         }</span>
<a href="#l20.395"></a><span id="l20.395">         break;</span>
<a href="#l20.396"></a><span id="l20.396"> </span>
<a href="#l20.397"></a><span id="l20.397">       case 's': /* string */</span>
<a href="#l20.398"></a><span id="l20.398" class="difflineminus">-        s = va_arg(ap, char *);</span>
<a href="#l20.399"></a><span id="l20.399" class="difflineplus">+        s = va_arg(ap, char*);</span>
<a href="#l20.400"></a><span id="l20.400">         rc = ber_put_string(ber, s, ber-&gt;ber_tag);</span>
<a href="#l20.401"></a><span id="l20.401">         break;</span>
<a href="#l20.402"></a><span id="l20.402"> </span>
<a href="#l20.403"></a><span id="l20.403">       case 'B': /* bit string */</span>
<a href="#l20.404"></a><span id="l20.404" class="difflineminus">-        s = va_arg(ap, char *);</span>
<a href="#l20.405"></a><span id="l20.405" class="difflineplus">+        s = va_arg(ap, char*);</span>
<a href="#l20.406"></a><span id="l20.406">         len = va_arg(ap, int); /* in bits */</span>
<a href="#l20.407"></a><span id="l20.407">         rc = ber_put_bitstring(ber, s, len, ber-&gt;ber_tag);</span>
<a href="#l20.408"></a><span id="l20.408">         break;</span>
<a href="#l20.409"></a><span id="l20.409"> </span>
<a href="#l20.410"></a><span id="l20.410">       case 't': /* tag for the next element */</span>
<a href="#l20.411"></a><span id="l20.411">         ber-&gt;ber_tag = va_arg(ap, ber_tag_t);</span>
<a href="#l20.412"></a><span id="l20.412">         ber-&gt;ber_usertag = 1;</span>
<a href="#l20.413"></a><span id="l20.413">         break;</span>
<a href="#l20.414"></a><span id="l20.414"> </span>
<a href="#l20.415"></a><span id="l20.415">       case 'v': /* vector of strings */</span>
<a href="#l20.416"></a><span id="l20.416" class="difflineminus">-        if ((ss = va_arg(ap, char **)) == NULL) break;</span>
<a href="#l20.417"></a><span id="l20.417" class="difflineplus">+        if ((ss = va_arg(ap, char**)) == NULL) break;</span>
<a href="#l20.418"></a><span id="l20.418">         for (i = 0; ss[i] != NULL; i++) {</span>
<a href="#l20.419"></a><span id="l20.419">           if ((rc = ber_put_string(ber, ss[i], ber-&gt;ber_tag)) == -1) break;</span>
<a href="#l20.420"></a><span id="l20.420">         }</span>
<a href="#l20.421"></a><span id="l20.421">         break;</span>
<a href="#l20.422"></a><span id="l20.422"> </span>
<a href="#l20.423"></a><span id="l20.423">       case 'V': /* sequences of strings + lengths */</span>
<a href="#l20.424"></a><span id="l20.424" class="difflineminus">-        if ((bv = va_arg(ap, struct berval **)) == NULL) break;</span>
<a href="#l20.425"></a><span id="l20.425" class="difflineplus">+        if ((bv = va_arg(ap, struct berval**)) == NULL) break;</span>
<a href="#l20.426"></a><span id="l20.426">         for (i = 0; bv[i] != NULL; i++) {</span>
<a href="#l20.427"></a><span id="l20.427">           if ((rc = ber_put_ostring(ber, bv[i]-&gt;bv_val, bv[i]-&gt;bv_len,</span>
<a href="#l20.428"></a><span id="l20.428">                                     ber-&gt;ber_tag)) == -1)</span>
<a href="#l20.429"></a><span id="l20.429">             break;</span>
<a href="#l20.430"></a><span id="l20.430">         }</span>
<a href="#l20.431"></a><span id="l20.431">         break;</span>
<a href="#l20.432"></a><span id="l20.432"> </span>
<a href="#l20.433"></a><span id="l20.433">       case '{': /* begin sequence */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/etest.c</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/etest.c</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -60,48 +60,48 @@</span>
<a href="#l21.4"></a><span id="l21.4"> #  ifdef _WIN32</span>
<a href="#l21.5"></a><span id="l21.5"> #    include &lt;windows.h&gt;</span>
<a href="#l21.6"></a><span id="l21.6"> #  else</span>
<a href="#l21.7"></a><span id="l21.7"> #    include &lt;sys/socket.h&gt;</span>
<a href="#l21.8"></a><span id="l21.8"> #  endif /* _WIN32 */</span>
<a href="#l21.9"></a><span id="l21.9"> #endif   /* MACOS */</span>
<a href="#l21.10"></a><span id="l21.10"> #include &quot;lber.h&quot;</span>
<a href="#l21.11"></a><span id="l21.11"> </span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-int SSL_Recv(int s, char *b, unsigned l, int dummy) { return (read(s, b, l)); }</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+int SSL_Recv(int s, char* b, unsigned l, int dummy) { return (read(s, b, l)); }</span>
<a href="#l21.14"></a><span id="l21.14"> </span>
<a href="#l21.15"></a><span id="l21.15" class="difflineminus">-SSL_Send(int s, char *b, unsigned l, int dummy) { return (write(s, b, l)); }</span>
<a href="#l21.16"></a><span id="l21.16" class="difflineplus">+SSL_Send(int s, char* b, unsigned l, int dummy) { return (write(s, b, l)); }</span>
<a href="#l21.17"></a><span id="l21.17"> </span>
<a href="#l21.18"></a><span id="l21.18" class="difflineminus">-int getline(char *prompt, char c, char *buf, int bsize) {</span>
<a href="#l21.19"></a><span id="l21.19" class="difflineminus">-  char *p;</span>
<a href="#l21.20"></a><span id="l21.20" class="difflineplus">+int getline(char* prompt, char c, char* buf, int bsize) {</span>
<a href="#l21.21"></a><span id="l21.21" class="difflineplus">+  char* p;</span>
<a href="#l21.22"></a><span id="l21.22"> </span>
<a href="#l21.23"></a><span id="l21.23">   if (prompt != NULL) {</span>
<a href="#l21.24"></a><span id="l21.24">     fprintf(stderr, &quot;%s: &quot;, prompt);</span>
<a href="#l21.25"></a><span id="l21.25">   } else {</span>
<a href="#l21.26"></a><span id="l21.26">     fprintf(stderr, &quot;enter value for '%c': &quot;, c);</span>
<a href="#l21.27"></a><span id="l21.27">   }</span>
<a href="#l21.28"></a><span id="l21.28">   if (fgets(buf, bsize, stdin) == NULL) {</span>
<a href="#l21.29"></a><span id="l21.29">     return (-1);</span>
<a href="#l21.30"></a><span id="l21.30">   }</span>
<a href="#l21.31"></a><span id="l21.31">   if ((p = strchr(buf, '\n')) != NULL) {</span>
<a href="#l21.32"></a><span id="l21.32">     *p = '\0';</span>
<a href="#l21.33"></a><span id="l21.33">   }</span>
<a href="#l21.34"></a><span id="l21.34"> </span>
<a href="#l21.35"></a><span id="l21.35">   return (0);</span>
<a href="#l21.36"></a><span id="l21.36"> }</span>
<a href="#l21.37"></a><span id="l21.37"> </span>
<a href="#l21.38"></a><span id="l21.38" class="difflineminus">-static void usage(char *name) {</span>
<a href="#l21.39"></a><span id="l21.39" class="difflineplus">+static void usage(char* name) {</span>
<a href="#l21.40"></a><span id="l21.40">   fprintf(stderr, &quot;usage: %s fmtstring\n&quot;, name);</span>
<a href="#l21.41"></a><span id="l21.41"> }</span>
<a href="#l21.42"></a><span id="l21.42"> </span>
<a href="#l21.43"></a><span id="l21.43" class="difflineminus">-main(int argc, char **argv) {</span>
<a href="#l21.44"></a><span id="l21.44" class="difflineplus">+main(int argc, char** argv) {</span>
<a href="#l21.45"></a><span id="l21.45">   int rc, fd;</span>
<a href="#l21.46"></a><span id="l21.46">   char *s, *p;</span>
<a href="#l21.47"></a><span id="l21.47">   void *arg1, *arg2;</span>
<a href="#l21.48"></a><span id="l21.48" class="difflineminus">-  Sockbuf *sb;</span>
<a href="#l21.49"></a><span id="l21.49" class="difflineminus">-  BerElement *ber;</span>
<a href="#l21.50"></a><span id="l21.50" class="difflineplus">+  Sockbuf* sb;</span>
<a href="#l21.51"></a><span id="l21.51" class="difflineplus">+  BerElement* ber;</span>
<a href="#l21.52"></a><span id="l21.52">   char fmt[2];</span>
<a href="#l21.53"></a><span id="l21.53">   char buf[BUFSIZ];</span>
<a href="#l21.54"></a><span id="l21.54">   extern int lber_debug;</span>
<a href="#l21.55"></a><span id="l21.55"> </span>
<a href="#l21.56"></a><span id="l21.56">   lber_debug = 255;</span>
<a href="#l21.57"></a><span id="l21.57">   if (argc &lt; 2) {</span>
<a href="#l21.58"></a><span id="l21.58">     usage(argv[0]);</span>
<a href="#l21.59"></a><span id="l21.59">     exit(1);</span>
<a href="#l21.60"></a><span id="l21.60" class="difflineat">@@ -119,43 +119,43 @@ main(int argc, char **argv) {</span>
<a href="#l21.61"></a><span id="l21.61">   rc = 0;</span>
<a href="#l21.62"></a><span id="l21.62">   fmt[1] = '\0';</span>
<a href="#l21.63"></a><span id="l21.63">   for (s = argv[1]; *s; s++) {</span>
<a href="#l21.64"></a><span id="l21.64">     switch (*s) {</span>
<a href="#l21.65"></a><span id="l21.65">       case 'i': /* int */</span>
<a href="#l21.66"></a><span id="l21.66">       case 'b': /* boolean */</span>
<a href="#l21.67"></a><span id="l21.67">       case 'e': /* enumeration */</span>
<a href="#l21.68"></a><span id="l21.68">         getline(NULL, *s, buf, sizeof(buf));</span>
<a href="#l21.69"></a><span id="l21.69" class="difflineminus">-        arg1 = (void *)atoi(buf);</span>
<a href="#l21.70"></a><span id="l21.70" class="difflineplus">+        arg1 = (void*)atoi(buf);</span>
<a href="#l21.71"></a><span id="l21.71">         break;</span>
<a href="#l21.72"></a><span id="l21.72"> </span>
<a href="#l21.73"></a><span id="l21.73">       case 'n': /* null */</span>
<a href="#l21.74"></a><span id="l21.74">         arg1 = NULL;</span>
<a href="#l21.75"></a><span id="l21.75">         break;</span>
<a href="#l21.76"></a><span id="l21.76"> </span>
<a href="#l21.77"></a><span id="l21.77">       case 'o': /* octet string (non-null terminated) */</span>
<a href="#l21.78"></a><span id="l21.78">         getline(NULL, *s, buf, sizeof(buf));</span>
<a href="#l21.79"></a><span id="l21.79" class="difflineminus">-        arg1 = (void *)buf;</span>
<a href="#l21.80"></a><span id="l21.80" class="difflineminus">-        arg2 = (void *)strlen(buf);</span>
<a href="#l21.81"></a><span id="l21.81" class="difflineplus">+        arg1 = (void*)buf;</span>
<a href="#l21.82"></a><span id="l21.82" class="difflineplus">+        arg2 = (void*)strlen(buf);</span>
<a href="#l21.83"></a><span id="l21.83">         break;</span>
<a href="#l21.84"></a><span id="l21.84"> </span>
<a href="#l21.85"></a><span id="l21.85">       case 's': /* string */</span>
<a href="#l21.86"></a><span id="l21.86">         getline(NULL, *s, buf, sizeof(buf));</span>
<a href="#l21.87"></a><span id="l21.87" class="difflineminus">-        arg1 = (void *)buf;</span>
<a href="#l21.88"></a><span id="l21.88" class="difflineplus">+        arg1 = (void*)buf;</span>
<a href="#l21.89"></a><span id="l21.89">         break;</span>
<a href="#l21.90"></a><span id="l21.90"> </span>
<a href="#l21.91"></a><span id="l21.91">       case 'B': /* bit string */</span>
<a href="#l21.92"></a><span id="l21.92">         getline(NULL, *s, buf, sizeof(buf));</span>
<a href="#l21.93"></a><span id="l21.93" class="difflineminus">-        arg1 = (void *)buf;</span>
<a href="#l21.94"></a><span id="l21.94" class="difflineminus">-        arg2 = (void *)strlen(buf);</span>
<a href="#l21.95"></a><span id="l21.95" class="difflineplus">+        arg1 = (void*)buf;</span>
<a href="#l21.96"></a><span id="l21.96" class="difflineplus">+        arg2 = (void*)strlen(buf);</span>
<a href="#l21.97"></a><span id="l21.97">         break;</span>
<a href="#l21.98"></a><span id="l21.98"> </span>
<a href="#l21.99"></a><span id="l21.99">       case 't': /* tag for the next element */</span>
<a href="#l21.100"></a><span id="l21.100">         getline(NULL, *s, buf, sizeof(buf));</span>
<a href="#l21.101"></a><span id="l21.101" class="difflineminus">-        arg1 = (void *)buf;</span>
<a href="#l21.102"></a><span id="l21.102" class="difflineplus">+        arg1 = (void*)buf;</span>
<a href="#l21.103"></a><span id="l21.103">         break;</span>
<a href="#l21.104"></a><span id="l21.104"> </span>
<a href="#l21.105"></a><span id="l21.105">       case '{': /* begin sequence */</span>
<a href="#l21.106"></a><span id="l21.106">       case '}': /* end sequence */</span>
<a href="#l21.107"></a><span id="l21.107">       case '[': /* begin set */</span>
<a href="#l21.108"></a><span id="l21.108">       case ']': /* end set */</span>
<a href="#l21.109"></a><span id="l21.109">         break;</span>
<a href="#l21.110"></a><span id="l21.110"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/idtest.c</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/idtest.c</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -48,19 +48,19 @@</span>
<a href="#l22.4"></a><span id="l22.4">  */</span>
<a href="#l22.5"></a><span id="l22.5"> </span>
<a href="#l22.6"></a><span id="l22.6"> /* idtest.c - ber decoding test program using isode libraries */</span>
<a href="#l22.7"></a><span id="l22.7"> </span>
<a href="#l22.8"></a><span id="l22.8"> #include &lt;stdio.h&gt;</span>
<a href="#l22.9"></a><span id="l22.9"> #include &lt;psap.h&gt;</span>
<a href="#l22.10"></a><span id="l22.10"> #include &lt;quipu/attr.h&gt;</span>
<a href="#l22.11"></a><span id="l22.11"> </span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-static usage(char *name) { fprintf(stderr, &quot;usage: %s\n&quot;, name); }</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+static usage(char* name) { fprintf(stderr, &quot;usage: %s\n&quot;, name); }</span>
<a href="#l22.14"></a><span id="l22.14"> </span>
<a href="#l22.15"></a><span id="l22.15" class="difflineminus">-main(int argc, char **argv) {</span>
<a href="#l22.16"></a><span id="l22.16" class="difflineplus">+main(int argc, char** argv) {</span>
<a href="#l22.17"></a><span id="l22.17">   PE pe;</span>
<a href="#l22.18"></a><span id="l22.18">   PS psin, psout, pserr;</span>
<a href="#l22.19"></a><span id="l22.19"> </span>
<a href="#l22.20"></a><span id="l22.20">   /* read the pe from standard in */</span>
<a href="#l22.21"></a><span id="l22.21">   if ((psin = ps_alloc(std_open)) == NULLPS) {</span>
<a href="#l22.22"></a><span id="l22.22">     perror(&quot;ps_alloc&quot;);</span>
<a href="#l22.23"></a><span id="l22.23">     exit(1);</span>
<a href="#l22.24"></a><span id="l22.24">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/io.c</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/io.c</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -54,37 +54,37 @@</span>
<a href="#l23.4"></a><span id="l23.4">   (sb-&gt;sb_ber.ber_end &gt; sb-&gt;sb_ber.ber_ptr    \</span>
<a href="#l23.5"></a><span id="l23.5">        ? (unsigned char)*sb-&gt;sb_ber.ber_ptr++ \</span>
<a href="#l23.6"></a><span id="l23.6">        : ber_filbuf(sb, len))</span>
<a href="#l23.7"></a><span id="l23.7"> </span>
<a href="#l23.8"></a><span id="l23.8"> #ifdef macintosh</span>
<a href="#l23.9"></a><span id="l23.9"> /*</span>
<a href="#l23.10"></a><span id="l23.10">  * MacTCP/OpenTransport</span>
<a href="#l23.11"></a><span id="l23.11">  */</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-#  define read(s, b, l) tcpread(s, 0, (unsigned char *)b, l, NULL)</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+#  define read(s, b, l) tcpread(s, 0, (unsigned char*)b, l, NULL)</span>
<a href="#l23.14"></a><span id="l23.14"> #  define MAX_WRITE 65535</span>
<a href="#l23.15"></a><span id="l23.15"> #  define BerWrite(sb, b, l) \</span>
<a href="#l23.16"></a><span id="l23.16" class="difflineminus">-    tcpwrite(sb-&gt;sb_sd, (unsigned char *)(b), (l &lt; MAX_WRITE) ? l : MAX_WRITE)</span>
<a href="#l23.17"></a><span id="l23.17" class="difflineplus">+    tcpwrite(sb-&gt;sb_sd, (unsigned char*)(b), (l &lt; MAX_WRITE) ? l : MAX_WRITE)</span>
<a href="#l23.18"></a><span id="l23.18"> #else /* macintosh */</span>
<a href="#l23.19"></a><span id="l23.19"> #  if defined(_WIN32) || defined(_WINDOWS) || defined(XP_OS2)</span>
<a href="#l23.20"></a><span id="l23.20"> /*</span>
<a href="#l23.21"></a><span id="l23.21">  * 32-bit Windows Socket API (under Windows NT or Windows 95)</span>
<a href="#l23.22"></a><span id="l23.22">  */</span>
<a href="#l23.23"></a><span id="l23.23"> #    define read(s, b, l) recv(s, b, l, 0)</span>
<a href="#l23.24"></a><span id="l23.24"> #    define BerWrite(s, b, l) send(s-&gt;sb_sd, b, l, 0)</span>
<a href="#l23.25"></a><span id="l23.25"> #  else /* _WIN32 */</span>
<a href="#l23.26"></a><span id="l23.26"> /*</span>
<a href="#l23.27"></a><span id="l23.27">  * everything else (Unix/BSD 4.3 socket API)</span>
<a href="#l23.28"></a><span id="l23.28">  */</span>
<a href="#l23.29"></a><span id="l23.29"> #    define BerWrite(sb, b, l) write(sb-&gt;sb_sd, b, l)</span>
<a href="#l23.30"></a><span id="l23.30" class="difflineminus">-#    define udp_read(sb, b, l, al)                                             \</span>
<a href="#l23.31"></a><span id="l23.31" class="difflineminus">-      recvfrom(sb-&gt;sb_sd, (char *)b, l, 0, (struct sockaddr *)sb-&gt;sb_fromaddr, \</span>
<a href="#l23.32"></a><span id="l23.32" class="difflineplus">+#    define udp_read(sb, b, l, al)                                           \</span>
<a href="#l23.33"></a><span id="l23.33" class="difflineplus">+      recvfrom(sb-&gt;sb_sd, (char*)b, l, 0, (struct sockaddr*)sb-&gt;sb_fromaddr, \</span>
<a href="#l23.34"></a><span id="l23.34">                (al = sizeof(struct sockaddr), &amp;al))</span>
<a href="#l23.35"></a><span id="l23.35" class="difflineminus">-#    define udp_write(sb, b, l)                                               \</span>
<a href="#l23.36"></a><span id="l23.36" class="difflineminus">-      sendto(sb-&gt;sb_sd, (char *)(b), l, 0, (struct sockaddr *)sb-&gt;sb_useaddr, \</span>
<a href="#l23.37"></a><span id="l23.37" class="difflineplus">+#    define udp_write(sb, b, l)                                             \</span>
<a href="#l23.38"></a><span id="l23.38" class="difflineplus">+      sendto(sb-&gt;sb_sd, (char*)(b), l, 0, (struct sockaddr*)sb-&gt;sb_useaddr, \</span>
<a href="#l23.39"></a><span id="l23.39">              sizeof(struct sockaddr))</span>
<a href="#l23.40"></a><span id="l23.40"> #  endif /* _WIN32 */</span>
<a href="#l23.41"></a><span id="l23.41"> #endif   /* macintosh */</span>
<a href="#l23.42"></a><span id="l23.42"> </span>
<a href="#l23.43"></a><span id="l23.43"> #ifndef udp_read</span>
<a href="#l23.44"></a><span id="l23.44"> #  define udp_read(sb, b, l, al) CLDAP NOT SUPPORTED</span>
<a href="#l23.45"></a><span id="l23.45"> #  define udp_write(sb, b, l) CLDAP NOT SUPPORTED</span>
<a href="#l23.46"></a><span id="l23.46"> #endif /* udp_read */</span>
<a href="#l23.47"></a><span id="l23.47" class="difflineat">@@ -94,42 +94,42 @@ size_t lber_bufsize = EXBUFSIZ;</span>
<a href="#l23.48"></a><span id="l23.48"> </span>
<a href="#l23.49"></a><span id="l23.49"> #ifdef LDAP_DEBUG</span>
<a href="#l23.50"></a><span id="l23.50"> int lber_debug;</span>
<a href="#l23.51"></a><span id="l23.51"> #endif</span>
<a href="#l23.52"></a><span id="l23.52"> </span>
<a href="#l23.53"></a><span id="l23.53"> /*</span>
<a href="#l23.54"></a><span id="l23.54">  * function prototypes</span>
<a href="#l23.55"></a><span id="l23.55">  */</span>
<a href="#l23.56"></a><span id="l23.56" class="difflineminus">-static void nslberi_install_compat_io_fns(Sockbuf *sb);</span>
<a href="#l23.57"></a><span id="l23.57" class="difflineminus">-static int nslberi_extread_compat(int s, void *buf, int len,</span>
<a href="#l23.58"></a><span id="l23.58" class="difflineminus">-                                  struct lextiof_socket_private *arg);</span>
<a href="#l23.59"></a><span id="l23.59" class="difflineminus">-static int nslberi_extwrite_compat(int s, const void *buf, int len,</span>
<a href="#l23.60"></a><span id="l23.60" class="difflineminus">-                                   struct lextiof_socket_private *arg);</span>
<a href="#l23.61"></a><span id="l23.61" class="difflineminus">-static ber_tag_t get_tag(Sockbuf *sb, BerElement *ber);</span>
<a href="#l23.62"></a><span id="l23.62" class="difflineminus">-static ber_len_t get_ber_len(BerElement *ber);</span>
<a href="#l23.63"></a><span id="l23.63" class="difflineminus">-static ber_len_t read_len_in_ber(Sockbuf *sb, BerElement *ber);</span>
<a href="#l23.64"></a><span id="l23.64" class="difflineplus">+static void nslberi_install_compat_io_fns(Sockbuf* sb);</span>
<a href="#l23.65"></a><span id="l23.65" class="difflineplus">+static int nslberi_extread_compat(int s, void* buf, int len,</span>
<a href="#l23.66"></a><span id="l23.66" class="difflineplus">+                                  struct lextiof_socket_private* arg);</span>
<a href="#l23.67"></a><span id="l23.67" class="difflineplus">+static int nslberi_extwrite_compat(int s, const void* buf, int len,</span>
<a href="#l23.68"></a><span id="l23.68" class="difflineplus">+                                   struct lextiof_socket_private* arg);</span>
<a href="#l23.69"></a><span id="l23.69" class="difflineplus">+static ber_tag_t get_tag(Sockbuf* sb, BerElement* ber);</span>
<a href="#l23.70"></a><span id="l23.70" class="difflineplus">+static ber_len_t get_ber_len(BerElement* ber);</span>
<a href="#l23.71"></a><span id="l23.71" class="difflineplus">+static ber_len_t read_len_in_ber(Sockbuf* sb, BerElement* ber);</span>
<a href="#l23.72"></a><span id="l23.72"> </span>
<a href="#l23.73"></a><span id="l23.73"> /*</span>
<a href="#l23.74"></a><span id="l23.74">  * internal global structure for memory allocation callback functions</span>
<a href="#l23.75"></a><span id="l23.75">  */</span>
<a href="#l23.76"></a><span id="l23.76"> static struct lber_memalloc_fns nslberi_memalloc_fns;</span>
<a href="#l23.77"></a><span id="l23.77"> </span>
<a href="#l23.78"></a><span id="l23.78"> /*</span>
<a href="#l23.79"></a><span id="l23.79">  * buffered read from &quot;sb&quot;.</span>
<a href="#l23.80"></a><span id="l23.80">  * returns value of first character read on success and -1 on error.</span>
<a href="#l23.81"></a><span id="l23.81">  */</span>
<a href="#l23.82"></a><span id="l23.82" class="difflineminus">-static int ber_filbuf(Sockbuf *sb, ber_slen_t len) {</span>
<a href="#l23.83"></a><span id="l23.83" class="difflineplus">+static int ber_filbuf(Sockbuf* sb, ber_slen_t len) {</span>
<a href="#l23.84"></a><span id="l23.84">   ssize_t rc;</span>
<a href="#l23.85"></a><span id="l23.85"> #ifdef CLDAP</span>
<a href="#l23.86"></a><span id="l23.86">   int addrlen;</span>
<a href="#l23.87"></a><span id="l23.87"> #endif /* CLDAP */</span>
<a href="#l23.88"></a><span id="l23.88"> </span>
<a href="#l23.89"></a><span id="l23.89">   if (sb-&gt;sb_ber.ber_buf == NULL) {</span>
<a href="#l23.90"></a><span id="l23.90" class="difflineminus">-    if ((sb-&gt;sb_ber.ber_buf = (char *)NSLBERI_MALLOC(READBUFSIZ)) == NULL) {</span>
<a href="#l23.91"></a><span id="l23.91" class="difflineplus">+    if ((sb-&gt;sb_ber.ber_buf = (char*)NSLBERI_MALLOC(READBUFSIZ)) == NULL) {</span>
<a href="#l23.92"></a><span id="l23.92">       return (-1);</span>
<a href="#l23.93"></a><span id="l23.93">     }</span>
<a href="#l23.94"></a><span id="l23.94">     sb-&gt;sb_ber.ber_flags &amp;= ~LBER_FLAG_NO_FREE_BUFFER;</span>
<a href="#l23.95"></a><span id="l23.95">     sb-&gt;sb_ber.ber_ptr = sb-&gt;sb_ber.ber_buf;</span>
<a href="#l23.96"></a><span id="l23.96">     sb-&gt;sb_ber.ber_end = sb-&gt;sb_ber.ber_buf;</span>
<a href="#l23.97"></a><span id="l23.97">   }</span>
<a href="#l23.98"></a><span id="l23.98"> </span>
<a href="#l23.99"></a><span id="l23.99">   if (sb-&gt;sb_naddr &gt; 0) {</span>
<a href="#l23.100"></a><span id="l23.100" class="difflineat">@@ -172,17 +172,17 @@ static int ber_filbuf(Sockbuf *sb, ber_s</span>
<a href="#l23.101"></a><span id="l23.101">     sb-&gt;sb_ber.ber_ptr = sb-&gt;sb_ber.ber_buf + 1;</span>
<a href="#l23.102"></a><span id="l23.102">     sb-&gt;sb_ber.ber_end = sb-&gt;sb_ber.ber_buf + rc;</span>
<a href="#l23.103"></a><span id="l23.103">     return ((unsigned char)*sb-&gt;sb_ber.ber_buf);</span>
<a href="#l23.104"></a><span id="l23.104">   }</span>
<a href="#l23.105"></a><span id="l23.105"> </span>
<a href="#l23.106"></a><span id="l23.106">   return (-1);</span>
<a href="#l23.107"></a><span id="l23.107"> }</span>
<a href="#l23.108"></a><span id="l23.108"> </span>
<a href="#l23.109"></a><span id="l23.109" class="difflineminus">-static ber_int_t BerRead(Sockbuf *sb, char *buf, ber_slen_t len) {</span>
<a href="#l23.110"></a><span id="l23.110" class="difflineplus">+static ber_int_t BerRead(Sockbuf* sb, char* buf, ber_slen_t len) {</span>
<a href="#l23.111"></a><span id="l23.111">   int c;</span>
<a href="#l23.112"></a><span id="l23.112">   ber_int_t nread = 0;</span>
<a href="#l23.113"></a><span id="l23.113"> </span>
<a href="#l23.114"></a><span id="l23.114">   while (len &gt; 0) {</span>
<a href="#l23.115"></a><span id="l23.115">     ber_int_t inberbuf = sb-&gt;sb_ber.ber_end - sb-&gt;sb_ber.ber_ptr;</span>
<a href="#l23.116"></a><span id="l23.116">     if (inberbuf &gt; 0) {</span>
<a href="#l23.117"></a><span id="l23.117">       size_t tocopy = len &gt; inberbuf ? inberbuf : len;</span>
<a href="#l23.118"></a><span id="l23.118">       SAFEMEMCPY(buf, sb-&gt;sb_ber.ber_ptr, tocopy);</span>
<a href="#l23.119"></a><span id="l23.119" class="difflineat">@@ -207,17 +207,17 @@ static ber_int_t BerRead(Sockbuf *sb, ch</span>
<a href="#l23.120"></a><span id="l23.120"> }</span>
<a href="#l23.121"></a><span id="l23.121"> </span>
<a href="#l23.122"></a><span id="l23.122"> /*</span>
<a href="#l23.123"></a><span id="l23.123">  * Note: ber_read() only uses the ber_end and ber_ptr elements of ber.</span>
<a href="#l23.124"></a><span id="l23.124">  * Functions like ber_get_tag(), ber_skip_tag, and ber_peek_tag() rely on</span>
<a href="#l23.125"></a><span id="l23.125">  * that fact, so if this code is changed to use any additional elements of</span>
<a href="#l23.126"></a><span id="l23.126">  * the ber structure, those functions will need to be changed as well.</span>
<a href="#l23.127"></a><span id="l23.127">  */</span>
<a href="#l23.128"></a><span id="l23.128" class="difflineminus">-ber_int_t LDAP_CALL ber_read(BerElement *ber, char *buf, ber_len_t len) {</span>
<a href="#l23.129"></a><span id="l23.129" class="difflineplus">+ber_int_t LDAP_CALL ber_read(BerElement* ber, char* buf, ber_len_t len) {</span>
<a href="#l23.130"></a><span id="l23.130">   ber_len_t actuallen;</span>
<a href="#l23.131"></a><span id="l23.131">   ber_uint_t nleft;</span>
<a href="#l23.132"></a><span id="l23.132"> </span>
<a href="#l23.133"></a><span id="l23.133">   nleft = ber-&gt;ber_end - ber-&gt;ber_ptr;</span>
<a href="#l23.134"></a><span id="l23.134">   actuallen = nleft &lt; len ? nleft : len;</span>
<a href="#l23.135"></a><span id="l23.135"> </span>
<a href="#l23.136"></a><span id="l23.136">   SAFEMEMCPY(buf, ber-&gt;ber_ptr, (size_t)actuallen);</span>
<a href="#l23.137"></a><span id="l23.137"> </span>
<a href="#l23.138"></a><span id="l23.138" class="difflineat">@@ -225,44 +225,44 @@ ber_int_t LDAP_CALL ber_read(BerElement </span>
<a href="#l23.139"></a><span id="l23.139"> </span>
<a href="#l23.140"></a><span id="l23.140">   return ((ber_int_t)actuallen);</span>
<a href="#l23.141"></a><span id="l23.141"> }</span>
<a href="#l23.142"></a><span id="l23.142"> </span>
<a href="#l23.143"></a><span id="l23.143"> /*</span>
<a href="#l23.144"></a><span id="l23.144">  * enlarge the ber buffer.</span>
<a href="#l23.145"></a><span id="l23.145">  * return 0 on success, -1 on error.</span>
<a href="#l23.146"></a><span id="l23.146">  */</span>
<a href="#l23.147"></a><span id="l23.147" class="difflineminus">-int nslberi_ber_realloc(BerElement *ber, ber_len_t len) {</span>
<a href="#l23.148"></a><span id="l23.148" class="difflineplus">+int nslberi_ber_realloc(BerElement* ber, ber_len_t len) {</span>
<a href="#l23.149"></a><span id="l23.149">   ber_uint_t need, have, total;</span>
<a href="#l23.150"></a><span id="l23.150">   size_t have_bytes;</span>
<a href="#l23.151"></a><span id="l23.151" class="difflineminus">-  Seqorset *s;</span>
<a href="#l23.152"></a><span id="l23.152" class="difflineplus">+  Seqorset* s;</span>
<a href="#l23.153"></a><span id="l23.153">   ber_int_t off;</span>
<a href="#l23.154"></a><span id="l23.154" class="difflineminus">-  char *oldbuf;</span>
<a href="#l23.155"></a><span id="l23.155" class="difflineplus">+  char* oldbuf;</span>
<a href="#l23.156"></a><span id="l23.156">   int freeoldbuf = 0;</span>
<a href="#l23.157"></a><span id="l23.157"> </span>
<a href="#l23.158"></a><span id="l23.158">   ber-&gt;ber_buf_reallocs++;</span>
<a href="#l23.159"></a><span id="l23.159"> </span>
<a href="#l23.160"></a><span id="l23.160">   have_bytes = ber-&gt;ber_end - ber-&gt;ber_buf;</span>
<a href="#l23.161"></a><span id="l23.161">   have = have_bytes / lber_bufsize;</span>
<a href="#l23.162"></a><span id="l23.162">   need = (len &lt; lber_bufsize ? 1 : (len + (lber_bufsize - 1)) / lber_bufsize);</span>
<a href="#l23.163"></a><span id="l23.163">   total = have * lber_bufsize + need * lber_bufsize * ber-&gt;ber_buf_reallocs;</span>
<a href="#l23.164"></a><span id="l23.164"> </span>
<a href="#l23.165"></a><span id="l23.165">   oldbuf = ber-&gt;ber_buf;</span>
<a href="#l23.166"></a><span id="l23.166"> </span>
<a href="#l23.167"></a><span id="l23.167">   if (ber-&gt;ber_buf == NULL) {</span>
<a href="#l23.168"></a><span id="l23.168" class="difflineminus">-    if ((ber-&gt;ber_buf = (char *)NSLBERI_MALLOC((size_t)total)) == NULL) {</span>
<a href="#l23.169"></a><span id="l23.169" class="difflineplus">+    if ((ber-&gt;ber_buf = (char*)NSLBERI_MALLOC((size_t)total)) == NULL) {</span>
<a href="#l23.170"></a><span id="l23.170">       return (-1);</span>
<a href="#l23.171"></a><span id="l23.171">     }</span>
<a href="#l23.172"></a><span id="l23.172">     ber-&gt;ber_flags &amp;= ~LBER_FLAG_NO_FREE_BUFFER;</span>
<a href="#l23.173"></a><span id="l23.173">   } else {</span>
<a href="#l23.174"></a><span id="l23.174">     if (!(ber-&gt;ber_flags &amp; LBER_FLAG_NO_FREE_BUFFER)) {</span>
<a href="#l23.175"></a><span id="l23.175">       freeoldbuf = 1;</span>
<a href="#l23.176"></a><span id="l23.176">     }</span>
<a href="#l23.177"></a><span id="l23.177">     /* transition to malloc'd buffer */</span>
<a href="#l23.178"></a><span id="l23.178" class="difflineminus">-    if ((ber-&gt;ber_buf = (char *)NSLBERI_MALLOC((size_t)total)) == NULL) {</span>
<a href="#l23.179"></a><span id="l23.179" class="difflineplus">+    if ((ber-&gt;ber_buf = (char*)NSLBERI_MALLOC((size_t)total)) == NULL) {</span>
<a href="#l23.180"></a><span id="l23.180">       return (-1);</span>
<a href="#l23.181"></a><span id="l23.181">     }</span>
<a href="#l23.182"></a><span id="l23.182">     ber-&gt;ber_flags &amp;= ~LBER_FLAG_NO_FREE_BUFFER;</span>
<a href="#l23.183"></a><span id="l23.183">     /* copy existing data into new malloc'd buffer */</span>
<a href="#l23.184"></a><span id="l23.184">     SAFEMEMCPY(ber-&gt;ber_buf, oldbuf, have_bytes);</span>
<a href="#l23.185"></a><span id="l23.185">   }</span>
<a href="#l23.186"></a><span id="l23.186"> </span>
<a href="#l23.187"></a><span id="l23.187">   ber-&gt;ber_end = ber-&gt;ber_buf + total;</span>
<a href="#l23.188"></a><span id="l23.188" class="difflineat">@@ -290,17 +290,17 @@ int nslberi_ber_realloc(BerElement *ber,</span>
<a href="#l23.189"></a><span id="l23.189">   }</span>
<a href="#l23.190"></a><span id="l23.190"> </span>
<a href="#l23.191"></a><span id="l23.191">   return (0);</span>
<a href="#l23.192"></a><span id="l23.192"> }</span>
<a href="#l23.193"></a><span id="l23.193"> </span>
<a href="#l23.194"></a><span id="l23.194"> /*</span>
<a href="#l23.195"></a><span id="l23.195">  * returns &quot;len&quot; on success and -1 on failure.</span>
<a href="#l23.196"></a><span id="l23.196">  */</span>
<a href="#l23.197"></a><span id="l23.197" class="difflineminus">-ber_int_t LDAP_CALL ber_write(BerElement *ber, char *buf, ber_len_t len,</span>
<a href="#l23.198"></a><span id="l23.198" class="difflineplus">+ber_int_t LDAP_CALL ber_write(BerElement* ber, char* buf, ber_len_t len,</span>
<a href="#l23.199"></a><span id="l23.199">                               int nosos) {</span>
<a href="#l23.200"></a><span id="l23.200">   if (nosos || ber-&gt;ber_sos == NULL) {</span>
<a href="#l23.201"></a><span id="l23.201">     if (ber-&gt;ber_ptr + len &gt; ber-&gt;ber_end) {</span>
<a href="#l23.202"></a><span id="l23.202">       if (nslberi_ber_realloc(ber, len) != 0) return (-1);</span>
<a href="#l23.203"></a><span id="l23.203">     }</span>
<a href="#l23.204"></a><span id="l23.204">     SAFEMEMCPY(ber-&gt;ber_ptr, buf, (size_t)len);</span>
<a href="#l23.205"></a><span id="l23.205">     ber-&gt;ber_ptr += len;</span>
<a href="#l23.206"></a><span id="l23.206">     return (len);</span>
<a href="#l23.207"></a><span id="l23.207" class="difflineat">@@ -310,29 +310,29 @@ ber_int_t LDAP_CALL ber_write(BerElement</span>
<a href="#l23.208"></a><span id="l23.208">     }</span>
<a href="#l23.209"></a><span id="l23.209">     SAFEMEMCPY(ber-&gt;ber_sos-&gt;sos_ptr, buf, (size_t)len);</span>
<a href="#l23.210"></a><span id="l23.210">     ber-&gt;ber_sos-&gt;sos_ptr += len;</span>
<a href="#l23.211"></a><span id="l23.211">     ber-&gt;ber_sos-&gt;sos_clen += len;</span>
<a href="#l23.212"></a><span id="l23.212">     return (len);</span>
<a href="#l23.213"></a><span id="l23.213">   }</span>
<a href="#l23.214"></a><span id="l23.214"> }</span>
<a href="#l23.215"></a><span id="l23.215"> </span>
<a href="#l23.216"></a><span id="l23.216" class="difflineminus">-void LDAP_CALL ber_free(BerElement *ber, int freebuf) {</span>
<a href="#l23.217"></a><span id="l23.217" class="difflineplus">+void LDAP_CALL ber_free(BerElement* ber, int freebuf) {</span>
<a href="#l23.218"></a><span id="l23.218">   if (ber != NULL) {</span>
<a href="#l23.219"></a><span id="l23.219">     if (freebuf &amp;&amp; !(ber-&gt;ber_flags &amp; LBER_FLAG_NO_FREE_BUFFER)) {</span>
<a href="#l23.220"></a><span id="l23.220">       NSLBERI_FREE(ber-&gt;ber_buf);</span>
<a href="#l23.221"></a><span id="l23.221">     }</span>
<a href="#l23.222"></a><span id="l23.222" class="difflineminus">-    NSLBERI_FREE((char *)ber);</span>
<a href="#l23.223"></a><span id="l23.223" class="difflineplus">+    NSLBERI_FREE((char*)ber);</span>
<a href="#l23.224"></a><span id="l23.224">   }</span>
<a href="#l23.225"></a><span id="l23.225"> }</span>
<a href="#l23.226"></a><span id="l23.226"> </span>
<a href="#l23.227"></a><span id="l23.227"> /*</span>
<a href="#l23.228"></a><span id="l23.228">  * return &gt;= 0 on success, -1 on failure.</span>
<a href="#l23.229"></a><span id="l23.229">  */</span>
<a href="#l23.230"></a><span id="l23.230" class="difflineminus">-int LDAP_CALL ber_flush(Sockbuf *sb, BerElement *ber, int freeit) {</span>
<a href="#l23.231"></a><span id="l23.231" class="difflineplus">+int LDAP_CALL ber_flush(Sockbuf* sb, BerElement* ber, int freeit) {</span>
<a href="#l23.232"></a><span id="l23.232">   ssize_t nwritten = 0, towrite, rc;</span>
<a href="#l23.233"></a><span id="l23.233">   int i = 0;</span>
<a href="#l23.234"></a><span id="l23.234"> </span>
<a href="#l23.235"></a><span id="l23.235">   if (ber-&gt;ber_rwptr == NULL) {</span>
<a href="#l23.236"></a><span id="l23.236">     ber-&gt;ber_rwptr = ber-&gt;ber_buf;</span>
<a href="#l23.237"></a><span id="l23.237">   } else if (ber-&gt;ber_rwptr &gt;= ber-&gt;ber_end) {</span>
<a href="#l23.238"></a><span id="l23.238">     /* we will use the ber_rwptr to continue an exited flush,</span>
<a href="#l23.239"></a><span id="l23.239">        so if rwptr is not within the buffer we return an error. */</span>
<a href="#l23.240"></a><span id="l23.240" class="difflineat">@@ -424,74 +424,74 @@ int LDAP_CALL ber_flush(Sockbuf *sb, Ber</span>
<a href="#l23.241"></a><span id="l23.241">   } while (towrite &gt; 0);</span>
<a href="#l23.242"></a><span id="l23.242"> </span>
<a href="#l23.243"></a><span id="l23.243">   if (freeit) ber_free(ber, 1);</span>
<a href="#l23.244"></a><span id="l23.244"> </span>
<a href="#l23.245"></a><span id="l23.245">   return (0);</span>
<a href="#l23.246"></a><span id="l23.246"> }</span>
<a href="#l23.247"></a><span id="l23.247"> </span>
<a href="#l23.248"></a><span id="l23.248"> /* we pre-allocate a buffer to save the extra malloc later */</span>
<a href="#l23.249"></a><span id="l23.249" class="difflineminus">-BerElement *LDAP_CALL ber_alloc_t(int options) {</span>
<a href="#l23.250"></a><span id="l23.250" class="difflineminus">-  BerElement *ber;</span>
<a href="#l23.251"></a><span id="l23.251" class="difflineplus">+BerElement* LDAP_CALL ber_alloc_t(int options) {</span>
<a href="#l23.252"></a><span id="l23.252" class="difflineplus">+  BerElement* ber;</span>
<a href="#l23.253"></a><span id="l23.253"> </span>
<a href="#l23.254"></a><span id="l23.254" class="difflineminus">-  if ((ber = (BerElement *)NSLBERI_CALLOC(</span>
<a href="#l23.255"></a><span id="l23.255" class="difflineplus">+  if ((ber = (BerElement*)NSLBERI_CALLOC(</span>
<a href="#l23.256"></a><span id="l23.256">            1, sizeof(struct berelement) + lber_bufsize)) == NULL) {</span>
<a href="#l23.257"></a><span id="l23.257">     return (NULL);</span>
<a href="#l23.258"></a><span id="l23.258">   }</span>
<a href="#l23.259"></a><span id="l23.259"> </span>
<a href="#l23.260"></a><span id="l23.260">   /*</span>
<a href="#l23.261"></a><span id="l23.261">    * for compatibility with the C LDAP API standard, we recognize</span>
<a href="#l23.262"></a><span id="l23.262">    * LBER_USE_DER as LBER_OPT_USE_DER.  See lber.h for a bit more info.</span>
<a href="#l23.263"></a><span id="l23.263">    */</span>
<a href="#l23.264"></a><span id="l23.264">   if (options &amp; LBER_USE_DER) {</span>
<a href="#l23.265"></a><span id="l23.265">     options &amp;= ~LBER_USE_DER;</span>
<a href="#l23.266"></a><span id="l23.266">     options |= LBER_OPT_USE_DER;</span>
<a href="#l23.267"></a><span id="l23.267">   }</span>
<a href="#l23.268"></a><span id="l23.268"> </span>
<a href="#l23.269"></a><span id="l23.269">   ber-&gt;ber_tag = LBER_DEFAULT;</span>
<a href="#l23.270"></a><span id="l23.270">   ber-&gt;ber_options = options;</span>
<a href="#l23.271"></a><span id="l23.271" class="difflineminus">-  ber-&gt;ber_buf = (char *)ber + sizeof(struct berelement);</span>
<a href="#l23.272"></a><span id="l23.272" class="difflineplus">+  ber-&gt;ber_buf = (char*)ber + sizeof(struct berelement);</span>
<a href="#l23.273"></a><span id="l23.273">   ber-&gt;ber_ptr = ber-&gt;ber_buf;</span>
<a href="#l23.274"></a><span id="l23.274">   ber-&gt;ber_end = ber-&gt;ber_buf + lber_bufsize;</span>
<a href="#l23.275"></a><span id="l23.275">   ber-&gt;ber_flags = LBER_FLAG_NO_FREE_BUFFER;</span>
<a href="#l23.276"></a><span id="l23.276"> </span>
<a href="#l23.277"></a><span id="l23.277">   return (ber);</span>
<a href="#l23.278"></a><span id="l23.278"> }</span>
<a href="#l23.279"></a><span id="l23.279"> </span>
<a href="#l23.280"></a><span id="l23.280" class="difflineminus">-BerElement *LDAP_CALL ber_alloc() { return (ber_alloc_t(0)); }</span>
<a href="#l23.281"></a><span id="l23.281" class="difflineplus">+BerElement* LDAP_CALL ber_alloc() { return (ber_alloc_t(0)); }</span>
<a href="#l23.282"></a><span id="l23.282"> </span>
<a href="#l23.283"></a><span id="l23.283" class="difflineminus">-BerElement *LDAP_CALL der_alloc() { return (ber_alloc_t(LBER_OPT_USE_DER)); }</span>
<a href="#l23.284"></a><span id="l23.284" class="difflineplus">+BerElement* LDAP_CALL der_alloc() { return (ber_alloc_t(LBER_OPT_USE_DER)); }</span>
<a href="#l23.285"></a><span id="l23.285"> </span>
<a href="#l23.286"></a><span id="l23.286" class="difflineminus">-BerElement *LDAP_CALL ber_dup(BerElement *ber) {</span>
<a href="#l23.287"></a><span id="l23.287" class="difflineminus">-  BerElement *new;</span>
<a href="#l23.288"></a><span id="l23.288" class="difflineplus">+BerElement* LDAP_CALL ber_dup(BerElement* ber) {</span>
<a href="#l23.289"></a><span id="l23.289" class="difflineplus">+  BerElement* new;</span>
<a href="#l23.290"></a><span id="l23.290"> </span>
<a href="#l23.291"></a><span id="l23.291">   if ((new = ber_alloc()) == NULL) return (NULL);</span>
<a href="#l23.292"></a><span id="l23.292"> </span>
<a href="#l23.293"></a><span id="l23.293">   *new = *ber;</span>
<a href="#l23.294"></a><span id="l23.294"> </span>
<a href="#l23.295"></a><span id="l23.295">   return (new);</span>
<a href="#l23.296"></a><span id="l23.296"> }</span>
<a href="#l23.297"></a><span id="l23.297"> </span>
<a href="#l23.298"></a><span id="l23.298" class="difflineminus">-void LDAP_CALL ber_init_w_nullchar(BerElement *ber, int options) {</span>
<a href="#l23.299"></a><span id="l23.299" class="difflineminus">-  (void)memset((char *)ber, '\0', sizeof(struct berelement));</span>
<a href="#l23.300"></a><span id="l23.300" class="difflineplus">+void LDAP_CALL ber_init_w_nullchar(BerElement* ber, int options) {</span>
<a href="#l23.301"></a><span id="l23.301" class="difflineplus">+  (void)memset((char*)ber, '\0', sizeof(struct berelement));</span>
<a href="#l23.302"></a><span id="l23.302">   ber-&gt;ber_tag = LBER_DEFAULT;</span>
<a href="#l23.303"></a><span id="l23.303"> </span>
<a href="#l23.304"></a><span id="l23.304">   /*</span>
<a href="#l23.305"></a><span id="l23.305">    * For compatibility with the C LDAP API standard, we recognize</span>
<a href="#l23.306"></a><span id="l23.306">    * LBER_USE_DER as LBER_OPT_USE_DER.  See lber.h for a bit more info.</span>
<a href="#l23.307"></a><span id="l23.307">    */</span>
<a href="#l23.308"></a><span id="l23.308">   if (options &amp; LBER_USE_DER) {</span>
<a href="#l23.309"></a><span id="l23.309">     options &amp;= ~LBER_USE_DER;</span>
<a href="#l23.310"></a><span id="l23.310">     options |= LBER_OPT_USE_DER;</span>
<a href="#l23.311"></a><span id="l23.311">   }</span>
<a href="#l23.312"></a><span id="l23.312"> </span>
<a href="#l23.313"></a><span id="l23.313">   ber-&gt;ber_options = options;</span>
<a href="#l23.314"></a><span id="l23.314"> }</span>
<a href="#l23.315"></a><span id="l23.315"> </span>
<a href="#l23.316"></a><span id="l23.316" class="difflineminus">-void LDAP_CALL ber_reset(BerElement *ber, int was_writing) {</span>
<a href="#l23.317"></a><span id="l23.317" class="difflineplus">+void LDAP_CALL ber_reset(BerElement* ber, int was_writing) {</span>
<a href="#l23.318"></a><span id="l23.318">   if (was_writing) {</span>
<a href="#l23.319"></a><span id="l23.319">     ber-&gt;ber_end = ber-&gt;ber_ptr;</span>
<a href="#l23.320"></a><span id="l23.320">     ber-&gt;ber_ptr = ber-&gt;ber_buf;</span>
<a href="#l23.321"></a><span id="l23.321">   } else {</span>
<a href="#l23.322"></a><span id="l23.322">     ber-&gt;ber_ptr = ber-&gt;ber_end;</span>
<a href="#l23.323"></a><span id="l23.323">   }</span>
<a href="#l23.324"></a><span id="l23.324"> </span>
<a href="#l23.325"></a><span id="l23.325">   ber-&gt;ber_rwptr = NULL;</span>
<a href="#l23.326"></a><span id="l23.326" class="difflineat">@@ -500,17 +500,17 @@ void LDAP_CALL ber_reset(BerElement *ber</span>
<a href="#l23.327"></a><span id="l23.327">   memset(ber-&gt;ber_struct, 0, BER_CONTENTS_STRUCT_SIZE);</span>
<a href="#l23.328"></a><span id="l23.328"> }</span>
<a href="#l23.329"></a><span id="l23.329"> </span>
<a href="#l23.330"></a><span id="l23.330"> /* Returns the length of the ber buffer so far,</span>
<a href="#l23.331"></a><span id="l23.331">    taking into account sequences/sets also.</span>
<a href="#l23.332"></a><span id="l23.332">    CAUTION: Returns 0 on null buffers as well</span>
<a href="#l23.333"></a><span id="l23.333">    as 0 on empty buffers!</span>
<a href="#l23.334"></a><span id="l23.334"> */</span>
<a href="#l23.335"></a><span id="l23.335" class="difflineminus">-size_t LDAP_CALL ber_get_buf_datalen(BerElement *ber) {</span>
<a href="#l23.336"></a><span id="l23.336" class="difflineplus">+size_t LDAP_CALL ber_get_buf_datalen(BerElement* ber) {</span>
<a href="#l23.337"></a><span id="l23.337">   size_t datalen;</span>
<a href="#l23.338"></a><span id="l23.338"> </span>
<a href="#l23.339"></a><span id="l23.339">   if ((ber == NULL) || (ber-&gt;ber_buf == NULL) || (ber-&gt;ber_ptr == NULL)) {</span>
<a href="#l23.340"></a><span id="l23.340">     datalen = 0;</span>
<a href="#l23.341"></a><span id="l23.341">   } else if (ber-&gt;ber_sos == NULLSEQORSET) {</span>
<a href="#l23.342"></a><span id="l23.342">     /* there are no sequences or sets yet,</span>
<a href="#l23.343"></a><span id="l23.343">        so just subtract ptr from the beginning of the ber buffer */</span>
<a href="#l23.344"></a><span id="l23.344">     datalen = ber-&gt;ber_ptr - ber-&gt;ber_buf;</span>
<a href="#l23.345"></a><span id="l23.345" class="difflineat">@@ -523,17 +523,17 @@ size_t LDAP_CALL ber_get_buf_datalen(Ber</span>
<a href="#l23.346"></a><span id="l23.346"> </span>
<a href="#l23.347"></a><span id="l23.347">   return datalen;</span>
<a href="#l23.348"></a><span id="l23.348"> }</span>
<a href="#l23.349"></a><span id="l23.349"> </span>
<a href="#l23.350"></a><span id="l23.350"> /*</span>
<a href="#l23.351"></a><span id="l23.351">   if buf is 0 then malloc a buffer of length size</span>
<a href="#l23.352"></a><span id="l23.352">   returns &gt; 0 on success, 0 otherwise</span>
<a href="#l23.353"></a><span id="l23.353"> */</span>
<a href="#l23.354"></a><span id="l23.354" class="difflineminus">-int LDAP_CALL ber_stack_init(BerElement *ber, int options, char *buf,</span>
<a href="#l23.355"></a><span id="l23.355" class="difflineplus">+int LDAP_CALL ber_stack_init(BerElement* ber, int options, char* buf,</span>
<a href="#l23.356"></a><span id="l23.356">                              size_t size) {</span>
<a href="#l23.357"></a><span id="l23.357">   if (NULL == ber) return 0;</span>
<a href="#l23.358"></a><span id="l23.358"> </span>
<a href="#l23.359"></a><span id="l23.359">   memset(ber, 0, sizeof(*ber));</span>
<a href="#l23.360"></a><span id="l23.360"> </span>
<a href="#l23.361"></a><span id="l23.361">   /*</span>
<a href="#l23.362"></a><span id="l23.362">    * for compatibility with the C LDAP API standard, we recognize</span>
<a href="#l23.363"></a><span id="l23.363">    * LBER_USE_DER as LBER_OPT_USE_DER.  See lber.h for a bit more info.</span>
<a href="#l23.364"></a><span id="l23.364" class="difflineat">@@ -550,53 +550,53 @@ int LDAP_CALL ber_stack_init(BerElement </span>
<a href="#l23.365"></a><span id="l23.365">   if (ber-&gt;ber_buf &amp;&amp; !(ber-&gt;ber_flags &amp; LBER_FLAG_NO_FREE_BUFFER)) {</span>
<a href="#l23.366"></a><span id="l23.366">     NSLBERI_FREE(ber-&gt;ber_buf);</span>
<a href="#l23.367"></a><span id="l23.367">   }</span>
<a href="#l23.368"></a><span id="l23.368"> </span>
<a href="#l23.369"></a><span id="l23.369">   if (buf) {</span>
<a href="#l23.370"></a><span id="l23.370">     ber-&gt;ber_buf = ber-&gt;ber_ptr = buf;</span>
<a href="#l23.371"></a><span id="l23.371">     ber-&gt;ber_flags = LBER_FLAG_NO_FREE_BUFFER;</span>
<a href="#l23.372"></a><span id="l23.372">   } else {</span>
<a href="#l23.373"></a><span id="l23.373" class="difflineminus">-    ber-&gt;ber_buf = ber-&gt;ber_ptr = (char *)NSLBERI_MALLOC(size);</span>
<a href="#l23.374"></a><span id="l23.374" class="difflineplus">+    ber-&gt;ber_buf = ber-&gt;ber_ptr = (char*)NSLBERI_MALLOC(size);</span>
<a href="#l23.375"></a><span id="l23.375">   }</span>
<a href="#l23.376"></a><span id="l23.376"> </span>
<a href="#l23.377"></a><span id="l23.377">   ber-&gt;ber_end = ber-&gt;ber_buf + size;</span>
<a href="#l23.378"></a><span id="l23.378"> </span>
<a href="#l23.379"></a><span id="l23.379">   return ber-&gt;ber_buf != 0;</span>
<a href="#l23.380"></a><span id="l23.380"> }</span>
<a href="#l23.381"></a><span id="l23.381"> </span>
<a href="#l23.382"></a><span id="l23.382"> /*</span>
<a href="#l23.383"></a><span id="l23.383">  * This call allows to release only the data part of</span>
<a href="#l23.384"></a><span id="l23.384">  * the target Sockbuf.</span>
<a href="#l23.385"></a><span id="l23.385">  * Other info of this Sockbuf are kept unchanged.</span>
<a href="#l23.386"></a><span id="l23.386">  */</span>
<a href="#l23.387"></a><span id="l23.387" class="difflineminus">-void LDAP_CALL ber_sockbuf_free_data(Sockbuf *p) {</span>
<a href="#l23.388"></a><span id="l23.388" class="difflineplus">+void LDAP_CALL ber_sockbuf_free_data(Sockbuf* p) {</span>
<a href="#l23.389"></a><span id="l23.389">   if (p != NULL) {</span>
<a href="#l23.390"></a><span id="l23.390">     if (p-&gt;sb_ber.ber_buf != NULL &amp;&amp;</span>
<a href="#l23.391"></a><span id="l23.391">         !(p-&gt;sb_ber.ber_flags &amp; LBER_FLAG_NO_FREE_BUFFER)) {</span>
<a href="#l23.392"></a><span id="l23.392">       NSLBERI_FREE(p-&gt;sb_ber.ber_buf);</span>
<a href="#l23.393"></a><span id="l23.393">       p-&gt;sb_ber.ber_buf = NULL;</span>
<a href="#l23.394"></a><span id="l23.394">     }</span>
<a href="#l23.395"></a><span id="l23.395">   }</span>
<a href="#l23.396"></a><span id="l23.396"> }</span>
<a href="#l23.397"></a><span id="l23.397"> </span>
<a href="#l23.398"></a><span id="l23.398"> /* simply returns ber_buf in the ber ...</span>
<a href="#l23.399"></a><span id="l23.399">    explicitly for DS MMR only...</span>
<a href="#l23.400"></a><span id="l23.400"> */</span>
<a href="#l23.401"></a><span id="l23.401" class="difflineminus">-char *LDAP_CALL ber_get_buf_databegin(BerElement *ber) {</span>
<a href="#l23.402"></a><span id="l23.402" class="difflineplus">+char* LDAP_CALL ber_get_buf_databegin(BerElement* ber) {</span>
<a href="#l23.403"></a><span id="l23.403">   if (NULL != ber) {</span>
<a href="#l23.404"></a><span id="l23.404">     return ber-&gt;ber_buf;</span>
<a href="#l23.405"></a><span id="l23.405">   } else {</span>
<a href="#l23.406"></a><span id="l23.406">     return NULL;</span>
<a href="#l23.407"></a><span id="l23.407">   }</span>
<a href="#l23.408"></a><span id="l23.408"> }</span>
<a href="#l23.409"></a><span id="l23.409"> </span>
<a href="#l23.410"></a><span id="l23.410"> #ifdef LDAP_DEBUG</span>
<a href="#l23.411"></a><span id="l23.411"> </span>
<a href="#l23.412"></a><span id="l23.412" class="difflineminus">-void ber_dump(BerElement *ber, int inout) {</span>
<a href="#l23.413"></a><span id="l23.413" class="difflineplus">+void ber_dump(BerElement* ber, int inout) {</span>
<a href="#l23.414"></a><span id="l23.414">   char msg[128];</span>
<a href="#l23.415"></a><span id="l23.415">   sprintf(msg, &quot;ber_dump: buf 0x%p, ptr 0x%p, rwptr 0x%p, end 0x%p\n&quot;,</span>
<a href="#l23.416"></a><span id="l23.416">           ber-&gt;ber_buf, ber-&gt;ber_ptr, ber-&gt;ber_rwptr, ber-&gt;ber_end);</span>
<a href="#l23.417"></a><span id="l23.417">   ber_err_print(msg);</span>
<a href="#l23.418"></a><span id="l23.418">   if (inout == 1) {</span>
<a href="#l23.419"></a><span id="l23.419">     sprintf(msg, &quot;          current len %ld, contents:\n&quot;,</span>
<a href="#l23.420"></a><span id="l23.420">             (long)(ber-&gt;ber_end - ber-&gt;ber_ptr));</span>
<a href="#l23.421"></a><span id="l23.421">     ber_err_print(msg);</span>
<a href="#l23.422"></a><span id="l23.422" class="difflineat">@@ -604,17 +604,17 @@ void ber_dump(BerElement *ber, int inout</span>
<a href="#l23.423"></a><span id="l23.423">   } else {</span>
<a href="#l23.424"></a><span id="l23.424">     sprintf(msg, &quot;          current len %ld, contents:\n&quot;,</span>
<a href="#l23.425"></a><span id="l23.425">             (long)(ber-&gt;ber_ptr - ber-&gt;ber_buf));</span>
<a href="#l23.426"></a><span id="l23.426">     ber_err_print(msg);</span>
<a href="#l23.427"></a><span id="l23.427">     lber_bprint(ber-&gt;ber_buf, ber-&gt;ber_ptr - ber-&gt;ber_buf);</span>
<a href="#l23.428"></a><span id="l23.428">   }</span>
<a href="#l23.429"></a><span id="l23.429"> }</span>
<a href="#l23.430"></a><span id="l23.430"> </span>
<a href="#l23.431"></a><span id="l23.431" class="difflineminus">-void ber_sos_dump(Seqorset *sos) {</span>
<a href="#l23.432"></a><span id="l23.432" class="difflineplus">+void ber_sos_dump(Seqorset* sos) {</span>
<a href="#l23.433"></a><span id="l23.433">   char msg[80];</span>
<a href="#l23.434"></a><span id="l23.434">   ber_err_print(&quot;*** sos dump ***\n&quot;);</span>
<a href="#l23.435"></a><span id="l23.435">   while (sos != NULLSEQORSET) {</span>
<a href="#l23.436"></a><span id="l23.436">     sprintf(msg, &quot;ber_sos_dump: clen %d first 0x%p ptr 0x%p\n&quot;, sos-&gt;sos_clen,</span>
<a href="#l23.437"></a><span id="l23.437">             sos-&gt;sos_first, sos-&gt;sos_ptr);</span>
<a href="#l23.438"></a><span id="l23.438">     ber_err_print(msg);</span>
<a href="#l23.439"></a><span id="l23.439">     sprintf(msg, &quot;              current len %ld contents:\n&quot;,</span>
<a href="#l23.440"></a><span id="l23.440">             (long)(sos-&gt;sos_ptr - sos-&gt;sos_first));</span>
<a href="#l23.441"></a><span id="l23.441" class="difflineat">@@ -625,73 +625,73 @@ void ber_sos_dump(Seqorset *sos) {</span>
<a href="#l23.442"></a><span id="l23.442">   }</span>
<a href="#l23.443"></a><span id="l23.443">   ber_err_print(&quot;*** end dump ***\n&quot;);</span>
<a href="#l23.444"></a><span id="l23.444"> }</span>
<a href="#l23.445"></a><span id="l23.445"> </span>
<a href="#l23.446"></a><span id="l23.446"> #endif</span>
<a href="#l23.447"></a><span id="l23.447"> </span>
<a href="#l23.448"></a><span id="l23.448"> /* return the tag - LBER_DEFAULT returned means trouble</span>
<a href="#l23.449"></a><span id="l23.449">  * assumes the tag is only one byte! */</span>
<a href="#l23.450"></a><span id="l23.450" class="difflineminus">-static ber_tag_t get_tag(Sockbuf *sb, BerElement *ber) {</span>
<a href="#l23.451"></a><span id="l23.451" class="difflineplus">+static ber_tag_t get_tag(Sockbuf* sb, BerElement* ber) {</span>
<a href="#l23.452"></a><span id="l23.452">   unsigned char xbyte;</span>
<a href="#l23.453"></a><span id="l23.453"> </span>
<a href="#l23.454"></a><span id="l23.454" class="difflineminus">-  if ((BerRead(sb, (char *)&amp;xbyte, 1)) != 1) {</span>
<a href="#l23.455"></a><span id="l23.455" class="difflineplus">+  if ((BerRead(sb, (char*)&amp;xbyte, 1)) != 1) {</span>
<a href="#l23.456"></a><span id="l23.456">     return (LBER_DEFAULT);</span>
<a href="#l23.457"></a><span id="l23.457">   }</span>
<a href="#l23.458"></a><span id="l23.458"> </span>
<a href="#l23.459"></a><span id="l23.459">   /* we only handle small (one byte) tags */</span>
<a href="#l23.460"></a><span id="l23.460">   if ((xbyte &amp; LBER_BIG_TAG_MASK) == LBER_BIG_TAG_MASK) {</span>
<a href="#l23.461"></a><span id="l23.461">     return (LBER_DEFAULT);</span>
<a href="#l23.462"></a><span id="l23.462">   }</span>
<a href="#l23.463"></a><span id="l23.463"> </span>
<a href="#l23.464"></a><span id="l23.464">   ber-&gt;ber_tag_contents[0] = xbyte;</span>
<a href="#l23.465"></a><span id="l23.465">   ber-&gt;ber_struct[BER_STRUCT_TAG].ldapiov_len = 1;</span>
<a href="#l23.466"></a><span id="l23.466">   return ((ber_tag_t)xbyte);</span>
<a href="#l23.467"></a><span id="l23.467"> }</span>
<a href="#l23.468"></a><span id="l23.468"> </span>
<a href="#l23.469"></a><span id="l23.469"> /* Error checking? */</span>
<a href="#l23.470"></a><span id="l23.470"> /* Takes a ber and returns the actual length */</span>
<a href="#l23.471"></a><span id="l23.471" class="difflineminus">-static ber_len_t get_ber_len(BerElement *ber) {</span>
<a href="#l23.472"></a><span id="l23.472" class="difflineplus">+static ber_len_t get_ber_len(BerElement* ber) {</span>
<a href="#l23.473"></a><span id="l23.473">   int noctets;</span>
<a href="#l23.474"></a><span id="l23.474">   ber_len_t len = 0;</span>
<a href="#l23.475"></a><span id="l23.475">   char xbyte;</span>
<a href="#l23.476"></a><span id="l23.476"> </span>
<a href="#l23.477"></a><span id="l23.477">   xbyte = ber-&gt;ber_len_contents[0];</span>
<a href="#l23.478"></a><span id="l23.478"> </span>
<a href="#l23.479"></a><span id="l23.479">   /* long form */</span>
<a href="#l23.480"></a><span id="l23.480">   if (xbyte &amp; 0x80) {</span>
<a href="#l23.481"></a><span id="l23.481">     noctets = (int)(xbyte &amp; 0x7f);</span>
<a href="#l23.482"></a><span id="l23.482">     if (noctets &gt;= MAX_LEN_SIZE) {</span>
<a href="#l23.483"></a><span id="l23.483">       return (LBER_DEFAULT);</span>
<a href="#l23.484"></a><span id="l23.484">     }</span>
<a href="#l23.485"></a><span id="l23.485" class="difflineminus">-    SAFEMEMCPY((char *)&amp;len + sizeof(ber_len_t) - noctets,</span>
<a href="#l23.486"></a><span id="l23.486" class="difflineplus">+    SAFEMEMCPY((char*)&amp;len + sizeof(ber_len_t) - noctets,</span>
<a href="#l23.487"></a><span id="l23.487">                &amp;ber-&gt;ber_len_contents[1], noctets);</span>
<a href="#l23.488"></a><span id="l23.488">     len = LBER_NTOHL(len);</span>
<a href="#l23.489"></a><span id="l23.489">     return (len);</span>
<a href="#l23.490"></a><span id="l23.490">   } else {</span>
<a href="#l23.491"></a><span id="l23.491">     return ((ber_len_t)(xbyte));</span>
<a href="#l23.492"></a><span id="l23.492">   }</span>
<a href="#l23.493"></a><span id="l23.493"> }</span>
<a href="#l23.494"></a><span id="l23.494"> </span>
<a href="#l23.495"></a><span id="l23.495"> /* LBER_DEFAULT means trouble</span>
<a href="#l23.496"></a><span id="l23.496">    reads in the length, stores it in ber-&gt;ber_struct, and returns get_ber_len */</span>
<a href="#l23.497"></a><span id="l23.497" class="difflineminus">-static ber_len_t read_len_in_ber(Sockbuf *sb, BerElement *ber) {</span>
<a href="#l23.498"></a><span id="l23.498" class="difflineplus">+static ber_len_t read_len_in_ber(Sockbuf* sb, BerElement* ber) {</span>
<a href="#l23.499"></a><span id="l23.499">   unsigned char xbyte;</span>
<a href="#l23.500"></a><span id="l23.500">   int noctets;</span>
<a href="#l23.501"></a><span id="l23.501">   int rc = 0, read_result = 0;</span>
<a href="#l23.502"></a><span id="l23.502"> </span>
<a href="#l23.503"></a><span id="l23.503">   /*</span>
<a href="#l23.504"></a><span id="l23.504">    * Next, read the length.  The first byte contains the length</span>
<a href="#l23.505"></a><span id="l23.505">    * of the length.  If bit 8 is set, the length is the long</span>
<a href="#l23.506"></a><span id="l23.506">    * form, otherwise it's the short form.  We don't allow a</span>
<a href="#l23.507"></a><span id="l23.507">    * length that's greater than what we can hold in a ber_int_t</span>
<a href="#l23.508"></a><span id="l23.508">    */</span>
<a href="#l23.509"></a><span id="l23.509">   if (ber-&gt;ber_tag_len_read == 1) {</span>
<a href="#l23.510"></a><span id="l23.510">     /* the length of the length hasn't been read yet */</span>
<a href="#l23.511"></a><span id="l23.511" class="difflineminus">-    if (BerRead(sb, (char *)&amp;xbyte, 1) != 1) {</span>
<a href="#l23.512"></a><span id="l23.512" class="difflineplus">+    if (BerRead(sb, (char*)&amp;xbyte, 1) != 1) {</span>
<a href="#l23.513"></a><span id="l23.513">       return (LBER_DEFAULT);</span>
<a href="#l23.514"></a><span id="l23.514">     }</span>
<a href="#l23.515"></a><span id="l23.515">     ber-&gt;ber_tag_len_read = 2;</span>
<a href="#l23.516"></a><span id="l23.516">     ber-&gt;ber_len_contents[0] = xbyte;</span>
<a href="#l23.517"></a><span id="l23.517">   } else {</span>
<a href="#l23.518"></a><span id="l23.518">     rc = ber-&gt;ber_tag_len_read - 2;</span>
<a href="#l23.519"></a><span id="l23.519">     xbyte = ber-&gt;ber_len_contents[0];</span>
<a href="#l23.520"></a><span id="l23.520">   }</span>
<a href="#l23.521"></a><span id="l23.521" class="difflineat">@@ -712,22 +712,22 @@ static ber_len_t read_len_in_ber(Sockbuf</span>
<a href="#l23.522"></a><span id="l23.522">     ber-&gt;ber_tag_len_read = rc + 2; /* adds tag (1 byte) and lenlen (1 byte) */</span>
<a href="#l23.523"></a><span id="l23.523">     ber-&gt;ber_struct[BER_STRUCT_LEN].ldapiov_len = 1 + noctets;</span>
<a href="#l23.524"></a><span id="l23.524">   } else { /* short form of the length value */</span>
<a href="#l23.525"></a><span id="l23.525">     ber-&gt;ber_struct[BER_STRUCT_LEN].ldapiov_len = 1;</span>
<a href="#l23.526"></a><span id="l23.526">   }</span>
<a href="#l23.527"></a><span id="l23.527">   return (get_ber_len(ber));</span>
<a href="#l23.528"></a><span id="l23.528"> }</span>
<a href="#l23.529"></a><span id="l23.529"> </span>
<a href="#l23.530"></a><span id="l23.530" class="difflineminus">-ber_tag_t LDAP_CALL ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber) {</span>
<a href="#l23.531"></a><span id="l23.531" class="difflineplus">+ber_tag_t LDAP_CALL ber_get_next(Sockbuf* sb, ber_len_t* len, BerElement* ber) {</span>
<a href="#l23.532"></a><span id="l23.532">   ber_len_t newlen;</span>
<a href="#l23.533"></a><span id="l23.533">   ber_len_t toread;</span>
<a href="#l23.534"></a><span id="l23.534">   ber_int_t rc;</span>
<a href="#l23.535"></a><span id="l23.535">   ber_len_t orig_taglen_read = 0;</span>
<a href="#l23.536"></a><span id="l23.536" class="difflineminus">-  char *orig_rwptr = ber-&gt;ber_rwptr ? ber-&gt;ber_rwptr : ber-&gt;ber_buf;</span>
<a href="#l23.537"></a><span id="l23.537" class="difflineplus">+  char* orig_rwptr = ber-&gt;ber_rwptr ? ber-&gt;ber_rwptr : ber-&gt;ber_buf;</span>
<a href="#l23.538"></a><span id="l23.538"> </span>
<a href="#l23.539"></a><span id="l23.539"> #ifdef LDAP_DEBUG</span>
<a href="#l23.540"></a><span id="l23.540">   if (lber_debug) ber_err_print(&quot;ber_get_next\n&quot;);</span>
<a href="#l23.541"></a><span id="l23.541"> #endif</span>
<a href="#l23.542"></a><span id="l23.542"> </span>
<a href="#l23.543"></a><span id="l23.543">   /*</span>
<a href="#l23.544"></a><span id="l23.544">    * When rwptr is NULL this signifies that the tag and length have not been</span>
<a href="#l23.545"></a><span id="l23.545">    * read in their entirety yet. (if at all)</span>
<a href="#l23.546"></a><span id="l23.546" class="difflineat">@@ -780,17 +780,17 @@ ber_tag_t LDAP_CALL ber_get_next(Sockbuf</span>
<a href="#l23.547"></a><span id="l23.547">       return (LBER_DEFAULT);</span>
<a href="#l23.548"></a><span id="l23.548">     }</span>
<a href="#l23.549"></a><span id="l23.549"> </span>
<a href="#l23.550"></a><span id="l23.550">     /* check to see if we already have enough memory allocated */</span>
<a href="#l23.551"></a><span id="l23.551">     if (((ber_len_t)ber-&gt;ber_end - (ber_len_t)ber-&gt;ber_buf) &lt; newlen) {</span>
<a href="#l23.552"></a><span id="l23.552">       if (ber-&gt;ber_buf &amp;&amp; !(ber-&gt;ber_flags &amp; LBER_FLAG_NO_FREE_BUFFER)) {</span>
<a href="#l23.553"></a><span id="l23.553">         NSLBERI_FREE(ber-&gt;ber_buf);</span>
<a href="#l23.554"></a><span id="l23.554">       }</span>
<a href="#l23.555"></a><span id="l23.555" class="difflineminus">-      if ((ber-&gt;ber_buf = (char *)NSLBERI_CALLOC(1, (size_t)newlen)) == NULL) {</span>
<a href="#l23.556"></a><span id="l23.556" class="difflineplus">+      if ((ber-&gt;ber_buf = (char*)NSLBERI_CALLOC(1, (size_t)newlen)) == NULL) {</span>
<a href="#l23.557"></a><span id="l23.557">         return (LBER_DEFAULT);</span>
<a href="#l23.558"></a><span id="l23.558">       }</span>
<a href="#l23.559"></a><span id="l23.559">       ber-&gt;ber_flags &amp;= ~LBER_FLAG_NO_FREE_BUFFER;</span>
<a href="#l23.560"></a><span id="l23.560">       orig_rwptr = ber-&gt;ber_buf;</span>
<a href="#l23.561"></a><span id="l23.561">     }</span>
<a href="#l23.562"></a><span id="l23.562"> </span>
<a href="#l23.563"></a><span id="l23.563">     ber-&gt;ber_len = newlen;</span>
<a href="#l23.564"></a><span id="l23.564">     ber-&gt;ber_ptr = ber-&gt;ber_buf;</span>
<a href="#l23.565"></a><span id="l23.565" class="difflineat">@@ -822,62 +822,62 @@ ber_tag_t LDAP_CALL ber_get_next(Sockbuf</span>
<a href="#l23.566"></a><span id="l23.566"> #endif</span>
<a href="#l23.567"></a><span id="l23.567"> </span>
<a href="#l23.568"></a><span id="l23.568">   *len = (ber_len_t)ber-&gt;ber_rwptr - (ber_len_t)orig_rwptr;</span>
<a href="#l23.569"></a><span id="l23.569">   ber-&gt;ber_rwptr = NULL;</span>
<a href="#l23.570"></a><span id="l23.570">   ber-&gt;ber_struct[BER_STRUCT_VAL].ldapiov_len = ber-&gt;ber_len;</span>
<a href="#l23.571"></a><span id="l23.571">   return (ber-&gt;ber_tag);</span>
<a href="#l23.572"></a><span id="l23.572"> }</span>
<a href="#l23.573"></a><span id="l23.573"> </span>
<a href="#l23.574"></a><span id="l23.574" class="difflineminus">-Sockbuf *LDAP_CALL ber_sockbuf_alloc() {</span>
<a href="#l23.575"></a><span id="l23.575" class="difflineminus">-  return ((Sockbuf *)NSLBERI_CALLOC(1, sizeof(struct sockbuf)));</span>
<a href="#l23.576"></a><span id="l23.576" class="difflineplus">+Sockbuf* LDAP_CALL ber_sockbuf_alloc() {</span>
<a href="#l23.577"></a><span id="l23.577" class="difflineplus">+  return ((Sockbuf*)NSLBERI_CALLOC(1, sizeof(struct sockbuf)));</span>
<a href="#l23.578"></a><span id="l23.578"> }</span>
<a href="#l23.579"></a><span id="l23.579"> </span>
<a href="#l23.580"></a><span id="l23.580" class="difflineminus">-void LDAP_CALL ber_sockbuf_free(Sockbuf *p) {</span>
<a href="#l23.581"></a><span id="l23.581" class="difflineplus">+void LDAP_CALL ber_sockbuf_free(Sockbuf* p) {</span>
<a href="#l23.582"></a><span id="l23.582">   if (p != NULL) {</span>
<a href="#l23.583"></a><span id="l23.583">     if (p-&gt;sb_ber.ber_buf != NULL &amp;&amp;</span>
<a href="#l23.584"></a><span id="l23.584">         !(p-&gt;sb_ber.ber_flags &amp; LBER_FLAG_NO_FREE_BUFFER)) {</span>
<a href="#l23.585"></a><span id="l23.585">       NSLBERI_FREE(p-&gt;sb_ber.ber_buf);</span>
<a href="#l23.586"></a><span id="l23.586">     }</span>
<a href="#l23.587"></a><span id="l23.587">     NSLBERI_FREE(p);</span>
<a href="#l23.588"></a><span id="l23.588">   }</span>
<a href="#l23.589"></a><span id="l23.589"> }</span>
<a href="#l23.590"></a><span id="l23.590"> </span>
<a href="#l23.591"></a><span id="l23.591"> /*</span>
<a href="#l23.592"></a><span id="l23.592">  * return 0 on success and -1 on error</span>
<a href="#l23.593"></a><span id="l23.593">  */</span>
<a href="#l23.594"></a><span id="l23.594" class="difflineminus">-int LDAP_CALL ber_set_option(struct berelement *ber, int option, void *value) {</span>
<a href="#l23.595"></a><span id="l23.595" class="difflineplus">+int LDAP_CALL ber_set_option(struct berelement* ber, int option, void* value) {</span>
<a href="#l23.596"></a><span id="l23.596">   /*</span>
<a href="#l23.597"></a><span id="l23.597">    * memory allocation callbacks are global, so it is OK to pass</span>
<a href="#l23.598"></a><span id="l23.598">    * NULL for ber.  Handle this as a special case.</span>
<a href="#l23.599"></a><span id="l23.599">    */</span>
<a href="#l23.600"></a><span id="l23.600">   if (option == LBER_OPT_MEMALLOC_FN_PTRS) {</span>
<a href="#l23.601"></a><span id="l23.601">     /* struct copy */</span>
<a href="#l23.602"></a><span id="l23.602" class="difflineminus">-    nslberi_memalloc_fns = *((struct lber_memalloc_fns *)value);</span>
<a href="#l23.603"></a><span id="l23.603" class="difflineplus">+    nslberi_memalloc_fns = *((struct lber_memalloc_fns*)value);</span>
<a href="#l23.604"></a><span id="l23.604">     return (0);</span>
<a href="#l23.605"></a><span id="l23.605">   }</span>
<a href="#l23.606"></a><span id="l23.606"> </span>
<a href="#l23.607"></a><span id="l23.607">   /*</span>
<a href="#l23.608"></a><span id="l23.608">    * lber_debug is global, so it is OK to pass</span>
<a href="#l23.609"></a><span id="l23.609">    * NULL for ber.  Handle this as a special case.</span>
<a href="#l23.610"></a><span id="l23.610">    */</span>
<a href="#l23.611"></a><span id="l23.611">   if (option == LBER_OPT_DEBUG_LEVEL) {</span>
<a href="#l23.612"></a><span id="l23.612"> #ifdef LDAP_DEBUG</span>
<a href="#l23.613"></a><span id="l23.613" class="difflineminus">-    lber_debug = *(int *)value;</span>
<a href="#l23.614"></a><span id="l23.614" class="difflineplus">+    lber_debug = *(int*)value;</span>
<a href="#l23.615"></a><span id="l23.615"> #endif</span>
<a href="#l23.616"></a><span id="l23.616">     return (0);</span>
<a href="#l23.617"></a><span id="l23.617">   }</span>
<a href="#l23.618"></a><span id="l23.618"> </span>
<a href="#l23.619"></a><span id="l23.619">   /*</span>
<a href="#l23.620"></a><span id="l23.620">    * lber_bufsize is global, so it is OK to pass</span>
<a href="#l23.621"></a><span id="l23.621">    * NULL for ber. Handle this as a special case.</span>
<a href="#l23.622"></a><span id="l23.622">    */</span>
<a href="#l23.623"></a><span id="l23.623">   if (option == LBER_OPT_BUFSIZE) {</span>
<a href="#l23.624"></a><span id="l23.624" class="difflineminus">-    if (*(size_t *)value &gt; EXBUFSIZ) {</span>
<a href="#l23.625"></a><span id="l23.625" class="difflineminus">-      lber_bufsize = *(size_t *)value;</span>
<a href="#l23.626"></a><span id="l23.626" class="difflineplus">+    if (*(size_t*)value &gt; EXBUFSIZ) {</span>
<a href="#l23.627"></a><span id="l23.627" class="difflineplus">+      lber_bufsize = *(size_t*)value;</span>
<a href="#l23.628"></a><span id="l23.628">     }</span>
<a href="#l23.629"></a><span id="l23.629">     return (0);</span>
<a href="#l23.630"></a><span id="l23.630">   }</span>
<a href="#l23.631"></a><span id="l23.631"> </span>
<a href="#l23.632"></a><span id="l23.632">   /*</span>
<a href="#l23.633"></a><span id="l23.633">    * all the rest require a non-NULL ber</span>
<a href="#l23.634"></a><span id="l23.634">    */</span>
<a href="#l23.635"></a><span id="l23.635">   if (!NSLBERI_VALID_BERELEMENT_POINTER(ber)) {</span>
<a href="#l23.636"></a><span id="l23.636" class="difflineat">@@ -889,98 +889,98 @@ int LDAP_CALL ber_set_option(struct bere</span>
<a href="#l23.637"></a><span id="l23.637">     case LBER_OPT_TRANSLATE_STRINGS:</span>
<a href="#l23.638"></a><span id="l23.638">       if (value != NULL) {</span>
<a href="#l23.639"></a><span id="l23.639">         ber-&gt;ber_options |= option;</span>
<a href="#l23.640"></a><span id="l23.640">       } else {</span>
<a href="#l23.641"></a><span id="l23.641">         ber-&gt;ber_options &amp;= ~option;</span>
<a href="#l23.642"></a><span id="l23.642">       }</span>
<a href="#l23.643"></a><span id="l23.643">       break;</span>
<a href="#l23.644"></a><span id="l23.644">     case LBER_OPT_REMAINING_BYTES:</span>
<a href="#l23.645"></a><span id="l23.645" class="difflineminus">-      ber-&gt;ber_end = ber-&gt;ber_ptr + *((ber_len_t *)value);</span>
<a href="#l23.646"></a><span id="l23.646" class="difflineplus">+      ber-&gt;ber_end = ber-&gt;ber_ptr + *((ber_len_t*)value);</span>
<a href="#l23.647"></a><span id="l23.647">       break;</span>
<a href="#l23.648"></a><span id="l23.648">     case LBER_OPT_TOTAL_BYTES:</span>
<a href="#l23.649"></a><span id="l23.649" class="difflineminus">-      ber-&gt;ber_end = ber-&gt;ber_buf + *((ber_len_t *)value);</span>
<a href="#l23.650"></a><span id="l23.650" class="difflineplus">+      ber-&gt;ber_end = ber-&gt;ber_buf + *((ber_len_t*)value);</span>
<a href="#l23.651"></a><span id="l23.651">       break;</span>
<a href="#l23.652"></a><span id="l23.652">     case LBER_OPT_BYTES_TO_WRITE:</span>
<a href="#l23.653"></a><span id="l23.653" class="difflineminus">-      ber-&gt;ber_ptr = ber-&gt;ber_buf + *((ber_len_t *)value);</span>
<a href="#l23.654"></a><span id="l23.654" class="difflineplus">+      ber-&gt;ber_ptr = ber-&gt;ber_buf + *((ber_len_t*)value);</span>
<a href="#l23.655"></a><span id="l23.655">       break;</span>
<a href="#l23.656"></a><span id="l23.656">     default:</span>
<a href="#l23.657"></a><span id="l23.657">       return (-1);</span>
<a href="#l23.658"></a><span id="l23.658">   }</span>
<a href="#l23.659"></a><span id="l23.659"> </span>
<a href="#l23.660"></a><span id="l23.660">   return (0);</span>
<a href="#l23.661"></a><span id="l23.661"> }</span>
<a href="#l23.662"></a><span id="l23.662"> </span>
<a href="#l23.663"></a><span id="l23.663"> /*</span>
<a href="#l23.664"></a><span id="l23.664">  * return 0 on success and -1 on error</span>
<a href="#l23.665"></a><span id="l23.665">  */</span>
<a href="#l23.666"></a><span id="l23.666" class="difflineminus">-int LDAP_CALL ber_get_option(struct berelement *ber, int option, void *value) {</span>
<a href="#l23.667"></a><span id="l23.667" class="difflineplus">+int LDAP_CALL ber_get_option(struct berelement* ber, int option, void* value) {</span>
<a href="#l23.668"></a><span id="l23.668">   /*</span>
<a href="#l23.669"></a><span id="l23.669">    * memory callocation callbacks are global, so it is OK to pass</span>
<a href="#l23.670"></a><span id="l23.670">    * NULL for ber.  Handle this as a special case</span>
<a href="#l23.671"></a><span id="l23.671">    */</span>
<a href="#l23.672"></a><span id="l23.672">   if (option == LBER_OPT_MEMALLOC_FN_PTRS) {</span>
<a href="#l23.673"></a><span id="l23.673">     /* struct copy */</span>
<a href="#l23.674"></a><span id="l23.674" class="difflineminus">-    *((struct lber_memalloc_fns *)value) = nslberi_memalloc_fns;</span>
<a href="#l23.675"></a><span id="l23.675" class="difflineplus">+    *((struct lber_memalloc_fns*)value) = nslberi_memalloc_fns;</span>
<a href="#l23.676"></a><span id="l23.676">     return (0);</span>
<a href="#l23.677"></a><span id="l23.677">   }</span>
<a href="#l23.678"></a><span id="l23.678"> </span>
<a href="#l23.679"></a><span id="l23.679">   /*</span>
<a href="#l23.680"></a><span id="l23.680">    * lber_debug is global, so it is OK to pass</span>
<a href="#l23.681"></a><span id="l23.681">    * NULL for ber.  Handle this as a special case.</span>
<a href="#l23.682"></a><span id="l23.682">    */</span>
<a href="#l23.683"></a><span id="l23.683">   if (option == LBER_OPT_DEBUG_LEVEL) {</span>
<a href="#l23.684"></a><span id="l23.684"> #ifdef LDAP_DEBUG</span>
<a href="#l23.685"></a><span id="l23.685" class="difflineminus">-    *(int *)value = lber_debug;</span>
<a href="#l23.686"></a><span id="l23.686" class="difflineplus">+    *(int*)value = lber_debug;</span>
<a href="#l23.687"></a><span id="l23.687"> #endif</span>
<a href="#l23.688"></a><span id="l23.688">     return (0);</span>
<a href="#l23.689"></a><span id="l23.689">   }</span>
<a href="#l23.690"></a><span id="l23.690"> </span>
<a href="#l23.691"></a><span id="l23.691">   /*</span>
<a href="#l23.692"></a><span id="l23.692">    * lber_bufsize is global, so it is OK to pass</span>
<a href="#l23.693"></a><span id="l23.693">    * NULL for ber. Handle this as a special case.</span>
<a href="#l23.694"></a><span id="l23.694">    */</span>
<a href="#l23.695"></a><span id="l23.695">   if (option == LBER_OPT_BUFSIZE) {</span>
<a href="#l23.696"></a><span id="l23.696" class="difflineminus">-    *(size_t *)value = lber_bufsize;</span>
<a href="#l23.697"></a><span id="l23.697" class="difflineplus">+    *(size_t*)value = lber_bufsize;</span>
<a href="#l23.698"></a><span id="l23.698">     return (0);</span>
<a href="#l23.699"></a><span id="l23.699">   }</span>
<a href="#l23.700"></a><span id="l23.700"> </span>
<a href="#l23.701"></a><span id="l23.701">   /*</span>
<a href="#l23.702"></a><span id="l23.702">    * all the rest require a non-NULL ber</span>
<a href="#l23.703"></a><span id="l23.703">    */</span>
<a href="#l23.704"></a><span id="l23.704">   if (!NSLBERI_VALID_BERELEMENT_POINTER(ber)) {</span>
<a href="#l23.705"></a><span id="l23.705">     return (-1);</span>
<a href="#l23.706"></a><span id="l23.706">   }</span>
<a href="#l23.707"></a><span id="l23.707"> </span>
<a href="#l23.708"></a><span id="l23.708">   switch (option) {</span>
<a href="#l23.709"></a><span id="l23.709">     case LBER_OPT_USE_DER:</span>
<a href="#l23.710"></a><span id="l23.710">     case LBER_OPT_TRANSLATE_STRINGS:</span>
<a href="#l23.711"></a><span id="l23.711" class="difflineminus">-      *((int *)value) = (ber-&gt;ber_options &amp; option);</span>
<a href="#l23.712"></a><span id="l23.712" class="difflineplus">+      *((int*)value) = (ber-&gt;ber_options &amp; option);</span>
<a href="#l23.713"></a><span id="l23.713">       break;</span>
<a href="#l23.714"></a><span id="l23.714">     case LBER_OPT_REMAINING_BYTES:</span>
<a href="#l23.715"></a><span id="l23.715" class="difflineminus">-      *((ber_len_t *)value) = ber-&gt;ber_end - ber-&gt;ber_ptr;</span>
<a href="#l23.716"></a><span id="l23.716" class="difflineplus">+      *((ber_len_t*)value) = ber-&gt;ber_end - ber-&gt;ber_ptr;</span>
<a href="#l23.717"></a><span id="l23.717">       break;</span>
<a href="#l23.718"></a><span id="l23.718">     case LBER_OPT_TOTAL_BYTES:</span>
<a href="#l23.719"></a><span id="l23.719" class="difflineminus">-      *((ber_len_t *)value) = ber-&gt;ber_end - ber-&gt;ber_buf;</span>
<a href="#l23.720"></a><span id="l23.720" class="difflineplus">+      *((ber_len_t*)value) = ber-&gt;ber_end - ber-&gt;ber_buf;</span>
<a href="#l23.721"></a><span id="l23.721">       break;</span>
<a href="#l23.722"></a><span id="l23.722">     case LBER_OPT_BYTES_TO_WRITE:</span>
<a href="#l23.723"></a><span id="l23.723" class="difflineminus">-      *((ber_len_t *)value) = ber-&gt;ber_ptr - ber-&gt;ber_buf;</span>
<a href="#l23.724"></a><span id="l23.724" class="difflineplus">+      *((ber_len_t*)value) = ber-&gt;ber_ptr - ber-&gt;ber_buf;</span>
<a href="#l23.725"></a><span id="l23.725">       break;</span>
<a href="#l23.726"></a><span id="l23.726">     default:</span>
<a href="#l23.727"></a><span id="l23.727">       return (-1);</span>
<a href="#l23.728"></a><span id="l23.728">   }</span>
<a href="#l23.729"></a><span id="l23.729"> </span>
<a href="#l23.730"></a><span id="l23.730">   return (0);</span>
<a href="#l23.731"></a><span id="l23.731"> }</span>
<a href="#l23.732"></a><span id="l23.732"> </span>
<a href="#l23.733"></a><span id="l23.733"> /*</span>
<a href="#l23.734"></a><span id="l23.734">  * return 0 on success and -1 on error</span>
<a href="#l23.735"></a><span id="l23.735">  */</span>
<a href="#l23.736"></a><span id="l23.736" class="difflineminus">-int LDAP_CALL ber_sockbuf_set_option(Sockbuf *sb, int option, void *value) {</span>
<a href="#l23.737"></a><span id="l23.737" class="difflineminus">-  struct lber_x_ext_io_fns *extiofns;</span>
<a href="#l23.738"></a><span id="l23.738" class="difflineplus">+int LDAP_CALL ber_sockbuf_set_option(Sockbuf* sb, int option, void* value) {</span>
<a href="#l23.739"></a><span id="l23.739" class="difflineplus">+  struct lber_x_ext_io_fns* extiofns;</span>
<a href="#l23.740"></a><span id="l23.740"> </span>
<a href="#l23.741"></a><span id="l23.741">   if (!NSLBERI_VALID_SOCKBUF_POINTER(sb)) {</span>
<a href="#l23.742"></a><span id="l23.742">     return (-1);</span>
<a href="#l23.743"></a><span id="l23.743">   }</span>
<a href="#l23.744"></a><span id="l23.744"> </span>
<a href="#l23.745"></a><span id="l23.745">   /* check for a NULL value for certain options. */</span>
<a href="#l23.746"></a><span id="l23.746">   if (NULL == value) {</span>
<a href="#l23.747"></a><span id="l23.747">     switch (option) {</span>
<a href="#l23.748"></a><span id="l23.748" class="difflineat">@@ -995,27 +995,27 @@ int LDAP_CALL ber_sockbuf_set_option(Soc</span>
<a href="#l23.749"></a><span id="l23.749">         break;</span>
<a href="#l23.750"></a><span id="l23.750">       default:</span>
<a href="#l23.751"></a><span id="l23.751">         return (-1);</span>
<a href="#l23.752"></a><span id="l23.752">     }</span>
<a href="#l23.753"></a><span id="l23.753">   }</span>
<a href="#l23.754"></a><span id="l23.754"> </span>
<a href="#l23.755"></a><span id="l23.755">   switch (option) {</span>
<a href="#l23.756"></a><span id="l23.756">     case LBER_SOCKBUF_OPT_VALID_TAG:</span>
<a href="#l23.757"></a><span id="l23.757" class="difflineminus">-      sb-&gt;sb_valid_tag = *((ber_tag_t *)value);</span>
<a href="#l23.758"></a><span id="l23.758" class="difflineplus">+      sb-&gt;sb_valid_tag = *((ber_tag_t*)value);</span>
<a href="#l23.759"></a><span id="l23.759">       /* use NULL to reset */</span>
<a href="#l23.760"></a><span id="l23.760">       if (value != NULL) {</span>
<a href="#l23.761"></a><span id="l23.761">         sb-&gt;sb_options |= option;</span>
<a href="#l23.762"></a><span id="l23.762">       } else {</span>
<a href="#l23.763"></a><span id="l23.763">         sb-&gt;sb_options &amp;= ~option;</span>
<a href="#l23.764"></a><span id="l23.764">       }</span>
<a href="#l23.765"></a><span id="l23.765">       break;</span>
<a href="#l23.766"></a><span id="l23.766">     case LBER_SOCKBUF_OPT_MAX_INCOMING_SIZE:</span>
<a href="#l23.767"></a><span id="l23.767">       if (value != NULL) {</span>
<a href="#l23.768"></a><span id="l23.768" class="difflineminus">-        sb-&gt;sb_max_incoming = *((ber_len_t *)value);</span>
<a href="#l23.769"></a><span id="l23.769" class="difflineplus">+        sb-&gt;sb_max_incoming = *((ber_len_t*)value);</span>
<a href="#l23.770"></a><span id="l23.770">         sb-&gt;sb_options |= option;</span>
<a href="#l23.771"></a><span id="l23.771">       } else {</span>
<a href="#l23.772"></a><span id="l23.772">         /* setting the max incoming to 0 seems to be the only</span>
<a href="#l23.773"></a><span id="l23.773">            way to tell the callers of ber_sockbuf_get_option</span>
<a href="#l23.774"></a><span id="l23.774">            that this option isn't set. */</span>
<a href="#l23.775"></a><span id="l23.775">         sb-&gt;sb_max_incoming = 0;</span>
<a href="#l23.776"></a><span id="l23.776">         sb-&gt;sb_options &amp;= ~option;</span>
<a href="#l23.777"></a><span id="l23.777">       }</span>
<a href="#l23.778"></a><span id="l23.778" class="difflineat">@@ -1025,33 +1025,33 @@ int LDAP_CALL ber_sockbuf_set_option(Soc</span>
<a href="#l23.779"></a><span id="l23.779">     case LBER_SOCKBUF_OPT_NO_READ_AHEAD:</span>
<a href="#l23.780"></a><span id="l23.780">       if (value != NULL) {</span>
<a href="#l23.781"></a><span id="l23.781">         sb-&gt;sb_options |= option;</span>
<a href="#l23.782"></a><span id="l23.782">       } else {</span>
<a href="#l23.783"></a><span id="l23.783">         sb-&gt;sb_options &amp;= ~option;</span>
<a href="#l23.784"></a><span id="l23.784">       }</span>
<a href="#l23.785"></a><span id="l23.785">       break;</span>
<a href="#l23.786"></a><span id="l23.786">     case LBER_SOCKBUF_OPT_DESC:</span>
<a href="#l23.787"></a><span id="l23.787" class="difflineminus">-      sb-&gt;sb_sd = *((LBER_SOCKET *)value);</span>
<a href="#l23.788"></a><span id="l23.788" class="difflineplus">+      sb-&gt;sb_sd = *((LBER_SOCKET*)value);</span>
<a href="#l23.789"></a><span id="l23.789">       break;</span>
<a href="#l23.790"></a><span id="l23.790">     case LBER_SOCKBUF_OPT_COPYDESC:</span>
<a href="#l23.791"></a><span id="l23.791" class="difflineminus">-      sb-&gt;sb_copyfd = *((LBER_SOCKET *)value);</span>
<a href="#l23.792"></a><span id="l23.792" class="difflineplus">+      sb-&gt;sb_copyfd = *((LBER_SOCKET*)value);</span>
<a href="#l23.793"></a><span id="l23.793">       break;</span>
<a href="#l23.794"></a><span id="l23.794">     case LBER_SOCKBUF_OPT_READ_FN:</span>
<a href="#l23.795"></a><span id="l23.795" class="difflineminus">-      sb-&gt;sb_io_fns.lbiof_read = (LDAP_IOF_READ_CALLBACK *)value;</span>
<a href="#l23.796"></a><span id="l23.796" class="difflineplus">+      sb-&gt;sb_io_fns.lbiof_read = (LDAP_IOF_READ_CALLBACK*)value;</span>
<a href="#l23.797"></a><span id="l23.797">       nslberi_install_compat_io_fns(sb);</span>
<a href="#l23.798"></a><span id="l23.798">       break;</span>
<a href="#l23.799"></a><span id="l23.799">     case LBER_SOCKBUF_OPT_WRITE_FN:</span>
<a href="#l23.800"></a><span id="l23.800" class="difflineminus">-      sb-&gt;sb_io_fns.lbiof_write = (LDAP_IOF_WRITE_CALLBACK *)value;</span>
<a href="#l23.801"></a><span id="l23.801" class="difflineplus">+      sb-&gt;sb_io_fns.lbiof_write = (LDAP_IOF_WRITE_CALLBACK*)value;</span>
<a href="#l23.802"></a><span id="l23.802">       nslberi_install_compat_io_fns(sb);</span>
<a href="#l23.803"></a><span id="l23.803">       break;</span>
<a href="#l23.804"></a><span id="l23.804">     case LBER_SOCKBUF_OPT_EXT_IO_FNS:</span>
<a href="#l23.805"></a><span id="l23.805" class="difflineminus">-      extiofns = (struct lber_x_ext_io_fns *)value;</span>
<a href="#l23.806"></a><span id="l23.806" class="difflineplus">+      extiofns = (struct lber_x_ext_io_fns*)value;</span>
<a href="#l23.807"></a><span id="l23.807">       if (extiofns == NULL) { /* remove */</span>
<a href="#l23.808"></a><span id="l23.808" class="difflineminus">-        (void)memset((char *)&amp;sb-&gt;sb_ext_io_fns, '\0',</span>
<a href="#l23.809"></a><span id="l23.809" class="difflineplus">+        (void)memset((char*)&amp;sb-&gt;sb_ext_io_fns, '\0',</span>
<a href="#l23.810"></a><span id="l23.810">                      sizeof(sb-&gt;sb_ext_io_fns));</span>
<a href="#l23.811"></a><span id="l23.811">       } else if (extiofns-&gt;lbextiofn_size == LBER_X_EXTIO_FNS_SIZE) {</span>
<a href="#l23.812"></a><span id="l23.812">         /* struct copy */</span>
<a href="#l23.813"></a><span id="l23.813">         sb-&gt;sb_ext_io_fns = *extiofns;</span>
<a href="#l23.814"></a><span id="l23.814">       } else if (extiofns-&gt;lbextiofn_size == LBER_X_EXTIO_FNS_SIZE_REV0) {</span>
<a href="#l23.815"></a><span id="l23.815">         /* backwards compatibility for older struct */</span>
<a href="#l23.816"></a><span id="l23.816">         sb-&gt;sb_ext_io_fns.lbextiofn_size = LBER_X_EXTIO_FNS_SIZE;</span>
<a href="#l23.817"></a><span id="l23.817">         sb-&gt;sb_ext_io_fns.lbextiofn_read = extiofns-&gt;lbextiofn_read;</span>
<a href="#l23.818"></a><span id="l23.818" class="difflineat">@@ -1059,133 +1059,133 @@ int LDAP_CALL ber_sockbuf_set_option(Soc</span>
<a href="#l23.819"></a><span id="l23.819">         sb-&gt;sb_ext_io_fns.lbextiofn_writev = NULL;</span>
<a href="#l23.820"></a><span id="l23.820">         sb-&gt;sb_ext_io_fns.lbextiofn_socket_arg = extiofns-&gt;lbextiofn_socket_arg;</span>
<a href="#l23.821"></a><span id="l23.821">       } else {</span>
<a href="#l23.822"></a><span id="l23.822">         return (-1);</span>
<a href="#l23.823"></a><span id="l23.823">       }</span>
<a href="#l23.824"></a><span id="l23.824">       break;</span>
<a href="#l23.825"></a><span id="l23.825">     case LBER_SOCKBUF_OPT_SOCK_ARG:</span>
<a href="#l23.826"></a><span id="l23.826">       sb-&gt;sb_ext_io_fns.lbextiofn_socket_arg =</span>
<a href="#l23.827"></a><span id="l23.827" class="difflineminus">-          (struct lextiof_socket_private *)value;</span>
<a href="#l23.828"></a><span id="l23.828" class="difflineplus">+          (struct lextiof_socket_private*)value;</span>
<a href="#l23.829"></a><span id="l23.829">       break;</span>
<a href="#l23.830"></a><span id="l23.830">     default:</span>
<a href="#l23.831"></a><span id="l23.831">       return (-1);</span>
<a href="#l23.832"></a><span id="l23.832">   }</span>
<a href="#l23.833"></a><span id="l23.833"> </span>
<a href="#l23.834"></a><span id="l23.834">   return (0);</span>
<a href="#l23.835"></a><span id="l23.835"> }</span>
<a href="#l23.836"></a><span id="l23.836"> </span>
<a href="#l23.837"></a><span id="l23.837"> /*</span>
<a href="#l23.838"></a><span id="l23.838">  * return 0 on success and -1 on error</span>
<a href="#l23.839"></a><span id="l23.839">  */</span>
<a href="#l23.840"></a><span id="l23.840" class="difflineminus">-int LDAP_CALL ber_sockbuf_get_option(Sockbuf *sb, int option, void *value) {</span>
<a href="#l23.841"></a><span id="l23.841" class="difflineminus">-  struct lber_x_ext_io_fns *extiofns;</span>
<a href="#l23.842"></a><span id="l23.842" class="difflineplus">+int LDAP_CALL ber_sockbuf_get_option(Sockbuf* sb, int option, void* value) {</span>
<a href="#l23.843"></a><span id="l23.843" class="difflineplus">+  struct lber_x_ext_io_fns* extiofns;</span>
<a href="#l23.844"></a><span id="l23.844"> </span>
<a href="#l23.845"></a><span id="l23.845">   if (!NSLBERI_VALID_SOCKBUF_POINTER(sb) || (NULL == value)) {</span>
<a href="#l23.846"></a><span id="l23.846">     return (-1);</span>
<a href="#l23.847"></a><span id="l23.847">   }</span>
<a href="#l23.848"></a><span id="l23.848"> </span>
<a href="#l23.849"></a><span id="l23.849">   switch (option) {</span>
<a href="#l23.850"></a><span id="l23.850">     case LBER_SOCKBUF_OPT_VALID_TAG:</span>
<a href="#l23.851"></a><span id="l23.851" class="difflineminus">-      *((ber_tag_t *)value) = sb-&gt;sb_valid_tag;</span>
<a href="#l23.852"></a><span id="l23.852" class="difflineplus">+      *((ber_tag_t*)value) = sb-&gt;sb_valid_tag;</span>
<a href="#l23.853"></a><span id="l23.853">       break;</span>
<a href="#l23.854"></a><span id="l23.854">     case LBER_SOCKBUF_OPT_MAX_INCOMING_SIZE:</span>
<a href="#l23.855"></a><span id="l23.855" class="difflineminus">-      *((ber_len_t *)value) = sb-&gt;sb_max_incoming;</span>
<a href="#l23.856"></a><span id="l23.856" class="difflineplus">+      *((ber_len_t*)value) = sb-&gt;sb_max_incoming;</span>
<a href="#l23.857"></a><span id="l23.857">       break;</span>
<a href="#l23.858"></a><span id="l23.858">     case LBER_SOCKBUF_OPT_TO_FILE:</span>
<a href="#l23.859"></a><span id="l23.859">     case LBER_SOCKBUF_OPT_TO_FILE_ONLY:</span>
<a href="#l23.860"></a><span id="l23.860">     case LBER_SOCKBUF_OPT_NO_READ_AHEAD:</span>
<a href="#l23.861"></a><span id="l23.861" class="difflineminus">-      *((int *)value) = (sb-&gt;sb_options &amp; option);</span>
<a href="#l23.862"></a><span id="l23.862" class="difflineplus">+      *((int*)value) = (sb-&gt;sb_options &amp; option);</span>
<a href="#l23.863"></a><span id="l23.863">       break;</span>
<a href="#l23.864"></a><span id="l23.864">     case LBER_SOCKBUF_OPT_DESC:</span>
<a href="#l23.865"></a><span id="l23.865" class="difflineminus">-      *((LBER_SOCKET *)value) = sb-&gt;sb_sd;</span>
<a href="#l23.866"></a><span id="l23.866" class="difflineplus">+      *((LBER_SOCKET*)value) = sb-&gt;sb_sd;</span>
<a href="#l23.867"></a><span id="l23.867">       break;</span>
<a href="#l23.868"></a><span id="l23.868">     case LBER_SOCKBUF_OPT_COPYDESC:</span>
<a href="#l23.869"></a><span id="l23.869" class="difflineminus">-      *((LBER_SOCKET *)value) = sb-&gt;sb_copyfd;</span>
<a href="#l23.870"></a><span id="l23.870" class="difflineplus">+      *((LBER_SOCKET*)value) = sb-&gt;sb_copyfd;</span>
<a href="#l23.871"></a><span id="l23.871">       break;</span>
<a href="#l23.872"></a><span id="l23.872">     case LBER_SOCKBUF_OPT_READ_FN:</span>
<a href="#l23.873"></a><span id="l23.873" class="difflineminus">-      *((LDAP_IOF_READ_CALLBACK **)value) = sb-&gt;sb_io_fns.lbiof_read;</span>
<a href="#l23.874"></a><span id="l23.874" class="difflineplus">+      *((LDAP_IOF_READ_CALLBACK**)value) = sb-&gt;sb_io_fns.lbiof_read;</span>
<a href="#l23.875"></a><span id="l23.875">       break;</span>
<a href="#l23.876"></a><span id="l23.876">     case LBER_SOCKBUF_OPT_WRITE_FN:</span>
<a href="#l23.877"></a><span id="l23.877" class="difflineminus">-      *((LDAP_IOF_WRITE_CALLBACK **)value) = sb-&gt;sb_io_fns.lbiof_write;</span>
<a href="#l23.878"></a><span id="l23.878" class="difflineplus">+      *((LDAP_IOF_WRITE_CALLBACK**)value) = sb-&gt;sb_io_fns.lbiof_write;</span>
<a href="#l23.879"></a><span id="l23.879">       break;</span>
<a href="#l23.880"></a><span id="l23.880">     case LBER_SOCKBUF_OPT_EXT_IO_FNS:</span>
<a href="#l23.881"></a><span id="l23.881" class="difflineminus">-      extiofns = (struct lber_x_ext_io_fns *)value;</span>
<a href="#l23.882"></a><span id="l23.882" class="difflineplus">+      extiofns = (struct lber_x_ext_io_fns*)value;</span>
<a href="#l23.883"></a><span id="l23.883">       if (extiofns == NULL) {</span>
<a href="#l23.884"></a><span id="l23.884">         return (-1);</span>
<a href="#l23.885"></a><span id="l23.885">       } else if (extiofns-&gt;lbextiofn_size == LBER_X_EXTIO_FNS_SIZE) {</span>
<a href="#l23.886"></a><span id="l23.886">         /* struct copy */</span>
<a href="#l23.887"></a><span id="l23.887">         *extiofns = sb-&gt;sb_ext_io_fns;</span>
<a href="#l23.888"></a><span id="l23.888">       } else if (extiofns-&gt;lbextiofn_size == LBER_X_EXTIO_FNS_SIZE_REV0) {</span>
<a href="#l23.889"></a><span id="l23.889">         /* backwards compatibility for older struct */</span>
<a href="#l23.890"></a><span id="l23.890">         extiofns-&gt;lbextiofn_read = sb-&gt;sb_ext_io_fns.lbextiofn_read;</span>
<a href="#l23.891"></a><span id="l23.891">         extiofns-&gt;lbextiofn_write = sb-&gt;sb_ext_io_fns.lbextiofn_write;</span>
<a href="#l23.892"></a><span id="l23.892">         extiofns-&gt;lbextiofn_socket_arg = sb-&gt;sb_ext_io_fns.lbextiofn_socket_arg;</span>
<a href="#l23.893"></a><span id="l23.893">       } else {</span>
<a href="#l23.894"></a><span id="l23.894">         return (-1);</span>
<a href="#l23.895"></a><span id="l23.895">       }</span>
<a href="#l23.896"></a><span id="l23.896">       break;</span>
<a href="#l23.897"></a><span id="l23.897">     case LBER_SOCKBUF_OPT_SOCK_ARG:</span>
<a href="#l23.898"></a><span id="l23.898" class="difflineminus">-      *((struct lextiof_socket_private **)value) =</span>
<a href="#l23.899"></a><span id="l23.899" class="difflineplus">+      *((struct lextiof_socket_private**)value) =</span>
<a href="#l23.900"></a><span id="l23.900">           sb-&gt;sb_ext_io_fns.lbextiofn_socket_arg;</span>
<a href="#l23.901"></a><span id="l23.901">       break;</span>
<a href="#l23.902"></a><span id="l23.902">     default:</span>
<a href="#l23.903"></a><span id="l23.903">       return (-1);</span>
<a href="#l23.904"></a><span id="l23.904">   }</span>
<a href="#l23.905"></a><span id="l23.905"> </span>
<a href="#l23.906"></a><span id="l23.906">   return (0);</span>
<a href="#l23.907"></a><span id="l23.907"> }</span>
<a href="#l23.908"></a><span id="l23.908"> </span>
<a href="#l23.909"></a><span id="l23.909"> /* new dboreham code below: */</span>
<a href="#l23.910"></a><span id="l23.910"> </span>
<a href="#l23.911"></a><span id="l23.911"> struct byte_buffer {</span>
<a href="#l23.912"></a><span id="l23.912" class="difflineminus">-  unsigned char *p;</span>
<a href="#l23.913"></a><span id="l23.913" class="difflineplus">+  unsigned char* p;</span>
<a href="#l23.914"></a><span id="l23.914">   int offset;</span>
<a href="#l23.915"></a><span id="l23.915">   int length;</span>
<a href="#l23.916"></a><span id="l23.916"> };</span>
<a href="#l23.917"></a><span id="l23.917"> typedef struct byte_buffer byte_buffer;</span>
<a href="#l23.918"></a><span id="l23.918"> </span>
<a href="#l23.919"></a><span id="l23.919"> /* This call allocates us a BerElement structure plus some extra memory.</span>
<a href="#l23.920"></a><span id="l23.920">  * It returns a pointer to the BerElement, plus a pointer to the extra memory.</span>
<a href="#l23.921"></a><span id="l23.921">  * This routine also allocates a ber data buffer within the same block, thus</span>
<a href="#l23.922"></a><span id="l23.922">  * saving a call to calloc later when we read data.</span>
<a href="#l23.923"></a><span id="l23.923">  */</span>
<a href="#l23.924"></a><span id="l23.924" class="difflineminus">-void *LDAP_CALL ber_special_alloc(size_t size, BerElement **ppBer) {</span>
<a href="#l23.925"></a><span id="l23.925" class="difflineminus">-  char *mem = NULL;</span>
<a href="#l23.926"></a><span id="l23.926" class="difflineplus">+void* LDAP_CALL ber_special_alloc(size_t size, BerElement** ppBer) {</span>
<a href="#l23.927"></a><span id="l23.927" class="difflineplus">+  char* mem = NULL;</span>
<a href="#l23.928"></a><span id="l23.928"> </span>
<a href="#l23.929"></a><span id="l23.929">   /* Make sure mem size requested is aligned */</span>
<a href="#l23.930"></a><span id="l23.930">   if (0 != (size &amp; 0x03)) {</span>
<a href="#l23.931"></a><span id="l23.931">     size += (sizeof(ber_int_t) - (size &amp; 0x03));</span>
<a href="#l23.932"></a><span id="l23.932">   }</span>
<a href="#l23.933"></a><span id="l23.933"> </span>
<a href="#l23.934"></a><span id="l23.934">   mem = NSLBERI_MALLOC(sizeof(struct berelement) + lber_bufsize + size);</span>
<a href="#l23.935"></a><span id="l23.935">   if (NULL == mem) {</span>
<a href="#l23.936"></a><span id="l23.936">     return NULL;</span>
<a href="#l23.937"></a><span id="l23.937">   }</span>
<a href="#l23.938"></a><span id="l23.938" class="difflineminus">-  *ppBer = (BerElement *)(mem + size);</span>
<a href="#l23.939"></a><span id="l23.939" class="difflineplus">+  *ppBer = (BerElement*)(mem + size);</span>
<a href="#l23.940"></a><span id="l23.940">   memset(*ppBer, 0, sizeof(struct berelement));</span>
<a href="#l23.941"></a><span id="l23.941">   (*ppBer)-&gt;ber_tag = LBER_DEFAULT;</span>
<a href="#l23.942"></a><span id="l23.942">   (*ppBer)-&gt;ber_buf = mem + size + sizeof(struct berelement);</span>
<a href="#l23.943"></a><span id="l23.943">   (*ppBer)-&gt;ber_ptr = (*ppBer)-&gt;ber_buf;</span>
<a href="#l23.944"></a><span id="l23.944">   (*ppBer)-&gt;ber_end = (*ppBer)-&gt;ber_buf + lber_bufsize;</span>
<a href="#l23.945"></a><span id="l23.945">   (*ppBer)-&gt;ber_flags = LBER_FLAG_NO_FREE_BUFFER;</span>
<a href="#l23.946"></a><span id="l23.946" class="difflineminus">-  return (void *)mem;</span>
<a href="#l23.947"></a><span id="l23.947" class="difflineplus">+  return (void*)mem;</span>
<a href="#l23.948"></a><span id="l23.948"> }</span>
<a href="#l23.949"></a><span id="l23.949"> </span>
<a href="#l23.950"></a><span id="l23.950" class="difflineminus">-void LDAP_CALL ber_special_free(void *buf, BerElement *ber) {</span>
<a href="#l23.951"></a><span id="l23.951" class="difflineplus">+void LDAP_CALL ber_special_free(void* buf, BerElement* ber) {</span>
<a href="#l23.952"></a><span id="l23.952">   if (!(ber-&gt;ber_flags &amp; LBER_FLAG_NO_FREE_BUFFER)) {</span>
<a href="#l23.953"></a><span id="l23.953">     NSLBERI_FREE(ber-&gt;ber_buf);</span>
<a href="#l23.954"></a><span id="l23.954">   }</span>
<a href="#l23.955"></a><span id="l23.955">   NSLBERI_FREE(buf);</span>
<a href="#l23.956"></a><span id="l23.956"> }</span>
<a href="#l23.957"></a><span id="l23.957"> </span>
<a href="#l23.958"></a><span id="l23.958"> /* Copy up to bytes_to_read bytes from b into return_buffer.</span>
<a href="#l23.959"></a><span id="l23.959">  * Returns a count of bytes copied (always &gt;= 0).</span>
<a href="#l23.960"></a><span id="l23.960">  */</span>
<a href="#l23.961"></a><span id="l23.961" class="difflineminus">-static int read_bytes(byte_buffer *b, unsigned char *return_buffer,</span>
<a href="#l23.962"></a><span id="l23.962" class="difflineplus">+static int read_bytes(byte_buffer* b, unsigned char* return_buffer,</span>
<a href="#l23.963"></a><span id="l23.963">                       int bytes_to_read) {</span>
<a href="#l23.964"></a><span id="l23.964">   /* copy up to bytes_to_read bytes into the caller's buffer, return the number</span>
<a href="#l23.965"></a><span id="l23.965">    * of bytes copied */</span>
<a href="#l23.966"></a><span id="l23.966">   int bytes_to_copy = 0;</span>
<a href="#l23.967"></a><span id="l23.967"> </span>
<a href="#l23.968"></a><span id="l23.968">   if (bytes_to_read &lt;= (b-&gt;length - b-&gt;offset)) {</span>
<a href="#l23.969"></a><span id="l23.969">     bytes_to_copy = bytes_to_read;</span>
<a href="#l23.970"></a><span id="l23.970">   } else {</span>
<a href="#l23.971"></a><span id="l23.971" class="difflineat">@@ -1198,31 +1198,31 @@ static int read_bytes(byte_buffer *b, un</span>
<a href="#l23.972"></a><span id="l23.972">   } else {</span>
<a href="#l23.973"></a><span id="l23.973">     SAFEMEMCPY(return_buffer, b-&gt;p + b-&gt;offset, bytes_to_copy);</span>
<a href="#l23.974"></a><span id="l23.974">     b-&gt;offset += bytes_to_copy;</span>
<a href="#l23.975"></a><span id="l23.975">   }</span>
<a href="#l23.976"></a><span id="l23.976">   return bytes_to_copy;</span>
<a href="#l23.977"></a><span id="l23.977"> }</span>
<a href="#l23.978"></a><span id="l23.978"> </span>
<a href="#l23.979"></a><span id="l23.979"> /* return the tag - LBER_DEFAULT returned means trouble */</span>
<a href="#l23.980"></a><span id="l23.980" class="difflineminus">-static ber_tag_t get_buffer_tag(byte_buffer *sb) {</span>
<a href="#l23.981"></a><span id="l23.981" class="difflineplus">+static ber_tag_t get_buffer_tag(byte_buffer* sb) {</span>
<a href="#l23.982"></a><span id="l23.982">   unsigned char xbyte;</span>
<a href="#l23.983"></a><span id="l23.983">   ber_tag_t tag;</span>
<a href="#l23.984"></a><span id="l23.984" class="difflineminus">-  char *tagp;</span>
<a href="#l23.985"></a><span id="l23.985" class="difflineplus">+  char* tagp;</span>
<a href="#l23.986"></a><span id="l23.986">   int i;</span>
<a href="#l23.987"></a><span id="l23.987"> </span>
<a href="#l23.988"></a><span id="l23.988">   if ((i = read_bytes(sb, &amp;xbyte, 1)) != 1) {</span>
<a href="#l23.989"></a><span id="l23.989">     return (LBER_DEFAULT);</span>
<a href="#l23.990"></a><span id="l23.990">   }</span>
<a href="#l23.991"></a><span id="l23.991"> </span>
<a href="#l23.992"></a><span id="l23.992">   if ((xbyte &amp; LBER_BIG_TAG_MASK) != LBER_BIG_TAG_MASK) {</span>
<a href="#l23.993"></a><span id="l23.993">     return ((ber_uint_t)xbyte);</span>
<a href="#l23.994"></a><span id="l23.994">   }</span>
<a href="#l23.995"></a><span id="l23.995"> </span>
<a href="#l23.996"></a><span id="l23.996" class="difflineminus">-  tagp = (char *)&amp;tag;</span>
<a href="#l23.997"></a><span id="l23.997" class="difflineplus">+  tagp = (char*)&amp;tag;</span>
<a href="#l23.998"></a><span id="l23.998">   tagp[0] = xbyte;</span>
<a href="#l23.999"></a><span id="l23.999">   for (i = 1; i &lt; sizeof(ber_int_t); i++) {</span>
<a href="#l23.1000"></a><span id="l23.1000">     if (read_bytes(sb, &amp;xbyte, 1) != 1) return (LBER_DEFAULT);</span>
<a href="#l23.1001"></a><span id="l23.1001"> </span>
<a href="#l23.1002"></a><span id="l23.1002">     tagp[i] = xbyte;</span>
<a href="#l23.1003"></a><span id="l23.1003"> </span>
<a href="#l23.1004"></a><span id="l23.1004">     if (!(xbyte &amp; LBER_MORE_TAG_MASK)) break;</span>
<a href="#l23.1005"></a><span id="l23.1005">   }</span>
<a href="#l23.1006"></a><span id="l23.1006" class="difflineat">@@ -1237,19 +1237,19 @@ static ber_tag_t get_buffer_tag(byte_buf</span>
<a href="#l23.1007"></a><span id="l23.1007"> /* Like ber_get_next, but from a byte buffer the caller already has. */</span>
<a href="#l23.1008"></a><span id="l23.1008"> /* Bytes_Scanned returns the number of bytes we actually looked at in the</span>
<a href="#l23.1009"></a><span id="l23.1009">  * buffer. */</span>
<a href="#l23.1010"></a><span id="l23.1010"> /* ber_get_next_buffer is now implemented in terms of ber_get_next_buffer_ext */</span>
<a href="#l23.1011"></a><span id="l23.1011"> /* and is here for backward compatibility.  This new function allows us to pass</span>
<a href="#l23.1012"></a><span id="l23.1012">  */</span>
<a href="#l23.1013"></a><span id="l23.1013"> /* the Sockbuf structure along */</span>
<a href="#l23.1014"></a><span id="l23.1014"> </span>
<a href="#l23.1015"></a><span id="l23.1015" class="difflineminus">-ber_uint_t LDAP_CALL ber_get_next_buffer(void *buffer, size_t buffer_size,</span>
<a href="#l23.1016"></a><span id="l23.1016" class="difflineminus">-                                         ber_len_t *len, BerElement *ber,</span>
<a href="#l23.1017"></a><span id="l23.1017" class="difflineminus">-                                         ber_uint_t *Bytes_Scanned) {</span>
<a href="#l23.1018"></a><span id="l23.1018" class="difflineplus">+ber_uint_t LDAP_CALL ber_get_next_buffer(void* buffer, size_t buffer_size,</span>
<a href="#l23.1019"></a><span id="l23.1019" class="difflineplus">+                                         ber_len_t* len, BerElement* ber,</span>
<a href="#l23.1020"></a><span id="l23.1020" class="difflineplus">+                                         ber_uint_t* Bytes_Scanned) {</span>
<a href="#l23.1021"></a><span id="l23.1021">   return (ber_get_next_buffer_ext(buffer, buffer_size, len, ber, Bytes_Scanned,</span>
<a href="#l23.1022"></a><span id="l23.1022">                                   NULL));</span>
<a href="#l23.1023"></a><span id="l23.1023"> }</span>
<a href="#l23.1024"></a><span id="l23.1024"> </span>
<a href="#l23.1025"></a><span id="l23.1025"> /*</span>
<a href="#l23.1026"></a><span id="l23.1026">  * Returns the tag of the message or LBER_ return code if an error occurs.</span>
<a href="#l23.1027"></a><span id="l23.1027">  *</span>
<a href="#l23.1028"></a><span id="l23.1028">  * If there was not enough data in the buffer to complete the message this</span>
<a href="#l23.1029"></a><span id="l23.1029" class="difflineat">@@ -1260,20 +1260,20 @@ ber_uint_t LDAP_CALL ber_get_next_buffer</span>
<a href="#l23.1030"></a><span id="l23.1030">  * type or the value preset via LBER_SOCKBUF_OPT_MAX_INCOMING_SIZE option,</span>
<a href="#l23.1031"></a><span id="l23.1031">  * *Bytes_Scanned is set to zero and return code is set to LBER_OVERFLOW.</span>
<a href="#l23.1032"></a><span id="l23.1032">  *</span>
<a href="#l23.1033"></a><span id="l23.1033">  * For backward compatibility errno is also set on these error conditions:</span>
<a href="#l23.1034"></a><span id="l23.1034">  *</span>
<a href="#l23.1035"></a><span id="l23.1035">  * EINVAL   - LBER_SOCKBUF_OPT_VALID_TAG option set but tag doesn't match.</span>
<a href="#l23.1036"></a><span id="l23.1036">  * EMSGSIZE - an overflow condition as described above for LBER_OVERFLOW.</span>
<a href="#l23.1037"></a><span id="l23.1037">  */</span>
<a href="#l23.1038"></a><span id="l23.1038" class="difflineminus">-ber_uint_t LDAP_CALL ber_get_next_buffer_ext(void *buffer, size_t buffer_size,</span>
<a href="#l23.1039"></a><span id="l23.1039" class="difflineminus">-                                             ber_len_t *len, BerElement *ber,</span>
<a href="#l23.1040"></a><span id="l23.1040" class="difflineminus">-                                             ber_uint_t *Bytes_Scanned,</span>
<a href="#l23.1041"></a><span id="l23.1041" class="difflineminus">-                                             Sockbuf *sock) {</span>
<a href="#l23.1042"></a><span id="l23.1042" class="difflineplus">+ber_uint_t LDAP_CALL ber_get_next_buffer_ext(void* buffer, size_t buffer_size,</span>
<a href="#l23.1043"></a><span id="l23.1043" class="difflineplus">+                                             ber_len_t* len, BerElement* ber,</span>
<a href="#l23.1044"></a><span id="l23.1044" class="difflineplus">+                                             ber_uint_t* Bytes_Scanned,</span>
<a href="#l23.1045"></a><span id="l23.1045" class="difflineplus">+                                             Sockbuf* sock) {</span>
<a href="#l23.1046"></a><span id="l23.1046">   ber_tag_t tag = 0;</span>
<a href="#l23.1047"></a><span id="l23.1047">   ber_len_t netlen;</span>
<a href="#l23.1048"></a><span id="l23.1048">   ber_len_t toread;</span>
<a href="#l23.1049"></a><span id="l23.1049">   unsigned char lc;</span>
<a href="#l23.1050"></a><span id="l23.1050">   ssize_t rc;</span>
<a href="#l23.1051"></a><span id="l23.1051">   int noctets, diff;</span>
<a href="#l23.1052"></a><span id="l23.1052">   byte_buffer sb = {0};</span>
<a href="#l23.1053"></a><span id="l23.1053"> </span>
<a href="#l23.1054"></a><span id="l23.1054" class="difflineat">@@ -1329,17 +1329,17 @@ ber_uint_t LDAP_CALL ber_get_next_buffer</span>
<a href="#l23.1055"></a><span id="l23.1055"> </span>
<a href="#l23.1056"></a><span id="l23.1056">     if (ber-&gt;ber_tag_len_read) {</span>
<a href="#l23.1057"></a><span id="l23.1057">       int nbytes;</span>
<a href="#l23.1058"></a><span id="l23.1058"> </span>
<a href="#l23.1059"></a><span id="l23.1059">       noctets = ((ber-&gt;ber_len_contents[0]) &amp; 0x7f);</span>
<a href="#l23.1060"></a><span id="l23.1060">       diff = noctets + 1 /* tag */ - ber-&gt;ber_tag_len_read;</span>
<a href="#l23.1061"></a><span id="l23.1061"> </span>
<a href="#l23.1062"></a><span id="l23.1062">       if ((nbytes = read_bytes(&amp;sb,</span>
<a href="#l23.1063"></a><span id="l23.1063" class="difflineminus">-                               (unsigned char *)&amp;ber-&gt;ber_len_contents[0] +</span>
<a href="#l23.1064"></a><span id="l23.1064" class="difflineplus">+                               (unsigned char*)&amp;ber-&gt;ber_len_contents[0] +</span>
<a href="#l23.1065"></a><span id="l23.1065">                                    ber-&gt;ber_tag_len_read,</span>
<a href="#l23.1066"></a><span id="l23.1066">                                diff)) != diff) {</span>
<a href="#l23.1067"></a><span id="l23.1067">         if (nbytes &gt; 0) ber-&gt;ber_tag_len_read += nbytes;</span>
<a href="#l23.1068"></a><span id="l23.1068"> </span>
<a href="#l23.1069"></a><span id="l23.1069">         goto premature_exit;</span>
<a href="#l23.1070"></a><span id="l23.1070">       }</span>
<a href="#l23.1071"></a><span id="l23.1071">       *len = get_ber_len(ber); /* cast ber-&gt;ber_len_contents to unsigned long */</span>
<a href="#l23.1072"></a><span id="l23.1072"> </span>
<a href="#l23.1073"></a><span id="l23.1073" class="difflineat">@@ -1363,29 +1363,29 @@ ber_uint_t LDAP_CALL ber_get_next_buffer</span>
<a href="#l23.1074"></a><span id="l23.1074">         if (noctets &gt; sizeof(ber_uint_t)) {</span>
<a href="#l23.1075"></a><span id="l23.1075"> #if !defined(macintosh) &amp;&amp; !defined(DOS)</span>
<a href="#l23.1076"></a><span id="l23.1076">           errno = EMSGSIZE;</span>
<a href="#l23.1077"></a><span id="l23.1077"> #endif</span>
<a href="#l23.1078"></a><span id="l23.1078">           *Bytes_Scanned = 0;</span>
<a href="#l23.1079"></a><span id="l23.1079">           return (LBER_OVERFLOW);</span>
<a href="#l23.1080"></a><span id="l23.1080">         }</span>
<a href="#l23.1081"></a><span id="l23.1081">         diff = sizeof(ber_uint_t) - noctets;</span>
<a href="#l23.1082"></a><span id="l23.1082" class="difflineminus">-        if ((nbytes = read_bytes(&amp;sb, (unsigned char *)&amp;netlen + diff,</span>
<a href="#l23.1083"></a><span id="l23.1083" class="difflineplus">+        if ((nbytes = read_bytes(&amp;sb, (unsigned char*)&amp;netlen + diff,</span>
<a href="#l23.1084"></a><span id="l23.1084">                                  noctets)) != noctets) {</span>
<a href="#l23.1085"></a><span id="l23.1085">           /*</span>
<a href="#l23.1086"></a><span id="l23.1086">            * The length is in long form and we don't get it in one</span>
<a href="#l23.1087"></a><span id="l23.1087">            * fragment, so stash partial length in the ber element</span>
<a href="#l23.1088"></a><span id="l23.1088">            * for later use</span>
<a href="#l23.1089"></a><span id="l23.1089">            */</span>
<a href="#l23.1090"></a><span id="l23.1090"> </span>
<a href="#l23.1091"></a><span id="l23.1091">           ber-&gt;ber_tag_len_read = nbytes + 1;</span>
<a href="#l23.1092"></a><span id="l23.1092">           ber-&gt;ber_len_contents[0] = lc;</span>
<a href="#l23.1093"></a><span id="l23.1093">           memset(&amp;(ber-&gt;ber_len_contents[1]), 0, sizeof(ber_uint_t));</span>
<a href="#l23.1094"></a><span id="l23.1094">           SAFEMEMCPY(&amp;(ber-&gt;ber_len_contents[1]),</span>
<a href="#l23.1095"></a><span id="l23.1095" class="difflineminus">-                     (unsigned char *)&amp;netlen + diff, nbytes);</span>
<a href="#l23.1096"></a><span id="l23.1096" class="difflineplus">+                     (unsigned char*)&amp;netlen + diff, nbytes);</span>
<a href="#l23.1097"></a><span id="l23.1097"> </span>
<a href="#l23.1098"></a><span id="l23.1098">           goto premature_exit;</span>
<a href="#l23.1099"></a><span id="l23.1099">         }</span>
<a href="#l23.1100"></a><span id="l23.1100">         *len = LBER_NTOHL(netlen);</span>
<a href="#l23.1101"></a><span id="l23.1101">       } else {</span>
<a href="#l23.1102"></a><span id="l23.1102">         *len = lc;</span>
<a href="#l23.1103"></a><span id="l23.1103">       }</span>
<a href="#l23.1104"></a><span id="l23.1104">     }</span>
<a href="#l23.1105"></a><span id="l23.1105" class="difflineat">@@ -1420,17 +1420,17 @@ ber_uint_t LDAP_CALL ber_get_next_buffer</span>
<a href="#l23.1106"></a><span id="l23.1106">     }</span>
<a href="#l23.1107"></a><span id="l23.1107">     ber-&gt;ber_ptr = ber-&gt;ber_buf;</span>
<a href="#l23.1108"></a><span id="l23.1108">     ber-&gt;ber_end = ber-&gt;ber_buf + *len;</span>
<a href="#l23.1109"></a><span id="l23.1109">     ber-&gt;ber_rwptr = ber-&gt;ber_buf;</span>
<a href="#l23.1110"></a><span id="l23.1110">   }</span>
<a href="#l23.1111"></a><span id="l23.1111"> </span>
<a href="#l23.1112"></a><span id="l23.1112">   toread = (ber_len_t)ber-&gt;ber_end - (ber_len_t)ber-&gt;ber_rwptr;</span>
<a href="#l23.1113"></a><span id="l23.1113">   do {</span>
<a href="#l23.1114"></a><span id="l23.1114" class="difflineminus">-    if ((rc = read_bytes(&amp;sb, (unsigned char *)ber-&gt;ber_rwptr,</span>
<a href="#l23.1115"></a><span id="l23.1115" class="difflineplus">+    if ((rc = read_bytes(&amp;sb, (unsigned char*)ber-&gt;ber_rwptr,</span>
<a href="#l23.1116"></a><span id="l23.1116">                          (ber_int_t)toread)) &lt;= 0) {</span>
<a href="#l23.1117"></a><span id="l23.1117">       goto premature_exit;</span>
<a href="#l23.1118"></a><span id="l23.1118">     }</span>
<a href="#l23.1119"></a><span id="l23.1119"> </span>
<a href="#l23.1120"></a><span id="l23.1120">     toread -= rc;</span>
<a href="#l23.1121"></a><span id="l23.1121">     ber-&gt;ber_rwptr += rc;</span>
<a href="#l23.1122"></a><span id="l23.1122">   } while (toread &gt; 0);</span>
<a href="#l23.1123"></a><span id="l23.1123"> </span>
<a href="#l23.1124"></a><span id="l23.1124" class="difflineat">@@ -1455,35 +1455,35 @@ error_exit:</span>
<a href="#l23.1125"></a><span id="l23.1125">  * are a BER encoding taken from the ber argument. The bvPtr pointer</span>
<a href="#l23.1126"></a><span id="l23.1126">  * points to the returned berval, which must be freed using</span>
<a href="#l23.1127"></a><span id="l23.1127">  * ber_bvfree().  This routine returns 0 on success and -1 on error.</span>
<a href="#l23.1128"></a><span id="l23.1128">  * The use of ber_flatten on a BerElement in which all '{' and '}'</span>
<a href="#l23.1129"></a><span id="l23.1129">  * format modifiers have not been properly matched can result in a</span>
<a href="#l23.1130"></a><span id="l23.1130">  * berval whose contents are not a valid BER encoding.</span>
<a href="#l23.1131"></a><span id="l23.1131">  * Note that the ber_ptr is not modified.</span>
<a href="#l23.1132"></a><span id="l23.1132">  */</span>
<a href="#l23.1133"></a><span id="l23.1133" class="difflineminus">-int LDAP_CALL ber_flatten(BerElement *ber, struct berval **bvPtr) {</span>
<a href="#l23.1134"></a><span id="l23.1134" class="difflineminus">-  struct berval *new;</span>
<a href="#l23.1135"></a><span id="l23.1135" class="difflineplus">+int LDAP_CALL ber_flatten(BerElement* ber, struct berval** bvPtr) {</span>
<a href="#l23.1136"></a><span id="l23.1136" class="difflineplus">+  struct berval* new;</span>
<a href="#l23.1137"></a><span id="l23.1137">   ber_len_t len;</span>
<a href="#l23.1138"></a><span id="l23.1138"> </span>
<a href="#l23.1139"></a><span id="l23.1139">   /* allocate a struct berval */</span>
<a href="#l23.1140"></a><span id="l23.1140" class="difflineminus">-  if ((new = (struct berval *)NSLBERI_MALLOC(sizeof(struct berval))) == NULL) {</span>
<a href="#l23.1141"></a><span id="l23.1141" class="difflineplus">+  if ((new = (struct berval*)NSLBERI_MALLOC(sizeof(struct berval))) == NULL) {</span>
<a href="#l23.1142"></a><span id="l23.1142">     return (-1);</span>
<a href="#l23.1143"></a><span id="l23.1143">   }</span>
<a href="#l23.1144"></a><span id="l23.1144"> </span>
<a href="#l23.1145"></a><span id="l23.1145">   /*</span>
<a href="#l23.1146"></a><span id="l23.1146">    * Copy everything from the BerElement's ber_buf to ber_ptr</span>
<a href="#l23.1147"></a><span id="l23.1147">    * into the berval structure.</span>
<a href="#l23.1148"></a><span id="l23.1148">    */</span>
<a href="#l23.1149"></a><span id="l23.1149">   if (ber == NULL) {</span>
<a href="#l23.1150"></a><span id="l23.1150">     new-&gt;bv_val = NULL;</span>
<a href="#l23.1151"></a><span id="l23.1151">     new-&gt;bv_len = 0;</span>
<a href="#l23.1152"></a><span id="l23.1152">   } else {</span>
<a href="#l23.1153"></a><span id="l23.1153">     len = ber-&gt;ber_ptr - ber-&gt;ber_buf;</span>
<a href="#l23.1154"></a><span id="l23.1154" class="difflineminus">-    if ((new-&gt;bv_val = (char *)NSLBERI_MALLOC(len + 1)) == NULL) {</span>
<a href="#l23.1155"></a><span id="l23.1155" class="difflineplus">+    if ((new-&gt;bv_val = (char*)NSLBERI_MALLOC(len + 1)) == NULL) {</span>
<a href="#l23.1156"></a><span id="l23.1156">       ber_bvfree(new);</span>
<a href="#l23.1157"></a><span id="l23.1157">       return (-1);</span>
<a href="#l23.1158"></a><span id="l23.1158">     }</span>
<a href="#l23.1159"></a><span id="l23.1159">     SAFEMEMCPY(new-&gt;bv_val, ber-&gt;ber_buf, (size_t)len);</span>
<a href="#l23.1160"></a><span id="l23.1160">     new-&gt;bv_val[len] = '\0';</span>
<a href="#l23.1161"></a><span id="l23.1161">     new-&gt;bv_len = len;</span>
<a href="#l23.1162"></a><span id="l23.1162">   }</span>
<a href="#l23.1163"></a><span id="l23.1163"> </span>
<a href="#l23.1164"></a><span id="l23.1164" class="difflineat">@@ -1493,18 +1493,18 @@ int LDAP_CALL ber_flatten(BerElement *be</span>
<a href="#l23.1165"></a><span id="l23.1165">   return (0);</span>
<a href="#l23.1166"></a><span id="l23.1166"> }</span>
<a href="#l23.1167"></a><span id="l23.1167"> </span>
<a href="#l23.1168"></a><span id="l23.1168"> /*</span>
<a href="#l23.1169"></a><span id="l23.1169">  * The ber_init function constructs and returns a new BerElement</span>
<a href="#l23.1170"></a><span id="l23.1170">  * containing a copy of the data in the bv argument.  ber_init</span>
<a href="#l23.1171"></a><span id="l23.1171">  * returns the null pointer on error.</span>
<a href="#l23.1172"></a><span id="l23.1172">  */</span>
<a href="#l23.1173"></a><span id="l23.1173" class="difflineminus">-BerElement *LDAP_CALL ber_init(const struct berval *bv) {</span>
<a href="#l23.1174"></a><span id="l23.1174" class="difflineminus">-  BerElement *ber;</span>
<a href="#l23.1175"></a><span id="l23.1175" class="difflineplus">+BerElement* LDAP_CALL ber_init(const struct berval* bv) {</span>
<a href="#l23.1176"></a><span id="l23.1176" class="difflineplus">+  BerElement* ber;</span>
<a href="#l23.1177"></a><span id="l23.1177"> </span>
<a href="#l23.1178"></a><span id="l23.1178">   /* construct BerElement */</span>
<a href="#l23.1179"></a><span id="l23.1179">   if ((ber = ber_alloc_t(0)) != NULLBER) {</span>
<a href="#l23.1180"></a><span id="l23.1180">     /* copy data from the bv argument into BerElement */</span>
<a href="#l23.1181"></a><span id="l23.1181">     /* XXXmcs: had to cast unsigned long bv_len to long */</span>
<a href="#l23.1182"></a><span id="l23.1182">     if ((ber_write(ber, bv-&gt;bv_val, bv-&gt;bv_len, 0)) != (ber_slen_t)bv-&gt;bv_len) {</span>
<a href="#l23.1183"></a><span id="l23.1183">       ber_free(ber, 1);</span>
<a href="#l23.1184"></a><span id="l23.1184">       return (NULL);</span>
<a href="#l23.1185"></a><span id="l23.1185" class="difflineat">@@ -1522,35 +1522,35 @@ BerElement *LDAP_CALL ber_init(const str</span>
<a href="#l23.1186"></a><span id="l23.1186">    * in the bv argument or a null pointer on error</span>
<a href="#l23.1187"></a><span id="l23.1187">    */</span>
<a href="#l23.1188"></a><span id="l23.1188">   return (ber);</span>
<a href="#l23.1189"></a><span id="l23.1189"> }</span>
<a href="#l23.1190"></a><span id="l23.1190"> </span>
<a href="#l23.1191"></a><span id="l23.1191"> /*</span>
<a href="#l23.1192"></a><span id="l23.1192">  * memory allocation functions.</span>
<a href="#l23.1193"></a><span id="l23.1193">  */</span>
<a href="#l23.1194"></a><span id="l23.1194" class="difflineminus">-void *nslberi_malloc(size_t size) {</span>
<a href="#l23.1195"></a><span id="l23.1195" class="difflineplus">+void* nslberi_malloc(size_t size) {</span>
<a href="#l23.1196"></a><span id="l23.1196">   return (nslberi_memalloc_fns.lbermem_malloc == NULL</span>
<a href="#l23.1197"></a><span id="l23.1197">               ? malloc(size)</span>
<a href="#l23.1198"></a><span id="l23.1198">               : nslberi_memalloc_fns.lbermem_malloc(size));</span>
<a href="#l23.1199"></a><span id="l23.1199"> }</span>
<a href="#l23.1200"></a><span id="l23.1200"> </span>
<a href="#l23.1201"></a><span id="l23.1201" class="difflineminus">-void *nslberi_calloc(size_t nelem, size_t elsize) {</span>
<a href="#l23.1202"></a><span id="l23.1202" class="difflineplus">+void* nslberi_calloc(size_t nelem, size_t elsize) {</span>
<a href="#l23.1203"></a><span id="l23.1203">   return (nslberi_memalloc_fns.lbermem_calloc == NULL</span>
<a href="#l23.1204"></a><span id="l23.1204">               ? calloc(nelem, elsize)</span>
<a href="#l23.1205"></a><span id="l23.1205">               : nslberi_memalloc_fns.lbermem_calloc(nelem, elsize));</span>
<a href="#l23.1206"></a><span id="l23.1206"> }</span>
<a href="#l23.1207"></a><span id="l23.1207"> </span>
<a href="#l23.1208"></a><span id="l23.1208" class="difflineminus">-void *nslberi_realloc(void *ptr, size_t size) {</span>
<a href="#l23.1209"></a><span id="l23.1209" class="difflineplus">+void* nslberi_realloc(void* ptr, size_t size) {</span>
<a href="#l23.1210"></a><span id="l23.1210">   return (nslberi_memalloc_fns.lbermem_realloc == NULL</span>
<a href="#l23.1211"></a><span id="l23.1211">               ? realloc(ptr, size)</span>
<a href="#l23.1212"></a><span id="l23.1212">               : nslberi_memalloc_fns.lbermem_realloc(ptr, size));</span>
<a href="#l23.1213"></a><span id="l23.1213"> }</span>
<a href="#l23.1214"></a><span id="l23.1214"> </span>
<a href="#l23.1215"></a><span id="l23.1215" class="difflineminus">-void nslberi_free(void *ptr) {</span>
<a href="#l23.1216"></a><span id="l23.1216" class="difflineplus">+void nslberi_free(void* ptr) {</span>
<a href="#l23.1217"></a><span id="l23.1217">   if (nslberi_memalloc_fns.lbermem_free == NULL) {</span>
<a href="#l23.1218"></a><span id="l23.1218">     free(ptr);</span>
<a href="#l23.1219"></a><span id="l23.1219">   } else {</span>
<a href="#l23.1220"></a><span id="l23.1220">     nslberi_memalloc_fns.lbermem_free(ptr);</span>
<a href="#l23.1221"></a><span id="l23.1221">   }</span>
<a href="#l23.1222"></a><span id="l23.1222"> }</span>
<a href="#l23.1223"></a><span id="l23.1223"> </span>
<a href="#l23.1224"></a><span id="l23.1224"> /*</span>
<a href="#l23.1225"></a><span id="l23.1225" class="difflineat">@@ -1559,36 +1559,36 @@ void nslberi_free(void *ptr) {</span>
<a href="#l23.1226"></a><span id="l23.1226">  *    installed using ber_sockbuf_set_option( ..., LBER_SOCKBUF_OPT_EXT_IO_FNS,</span>
<a href="#l23.1227"></a><span id="l23.1227">  *    ... ).</span>
<a href="#l23.1228"></a><span id="l23.1228">  *</span>
<a href="#l23.1229"></a><span id="l23.1229">  * the basic strategy is to use the new extended arg to hold a pointer to the</span>
<a href="#l23.1230"></a><span id="l23.1230">  *    Sockbuf itself so we can find the old functions and call them.</span>
<a href="#l23.1231"></a><span id="l23.1231">  * note that the integer socket s passed in is not used.  we use the sb_sd</span>
<a href="#l23.1232"></a><span id="l23.1232">  *    from the Sockbuf itself because it is the correct type.</span>
<a href="#l23.1233"></a><span id="l23.1233">  */</span>
<a href="#l23.1234"></a><span id="l23.1234" class="difflineminus">-static int nslberi_extread_compat(int s, void *buf, int len,</span>
<a href="#l23.1235"></a><span id="l23.1235" class="difflineminus">-                                  struct lextiof_socket_private *arg) {</span>
<a href="#l23.1236"></a><span id="l23.1236" class="difflineminus">-  Sockbuf *sb = (Sockbuf *)arg;</span>
<a href="#l23.1237"></a><span id="l23.1237" class="difflineplus">+static int nslberi_extread_compat(int s, void* buf, int len,</span>
<a href="#l23.1238"></a><span id="l23.1238" class="difflineplus">+                                  struct lextiof_socket_private* arg) {</span>
<a href="#l23.1239"></a><span id="l23.1239" class="difflineplus">+  Sockbuf* sb = (Sockbuf*)arg;</span>
<a href="#l23.1240"></a><span id="l23.1240"> </span>
<a href="#l23.1241"></a><span id="l23.1241">   return (sb-&gt;sb_io_fns.lbiof_read(sb-&gt;sb_sd, buf, len));</span>
<a href="#l23.1242"></a><span id="l23.1242"> }</span>
<a href="#l23.1243"></a><span id="l23.1243"> </span>
<a href="#l23.1244"></a><span id="l23.1244" class="difflineminus">-static int nslberi_extwrite_compat(int s, const void *buf, int len,</span>
<a href="#l23.1245"></a><span id="l23.1245" class="difflineminus">-                                   struct lextiof_socket_private *arg) {</span>
<a href="#l23.1246"></a><span id="l23.1246" class="difflineminus">-  Sockbuf *sb = (Sockbuf *)arg;</span>
<a href="#l23.1247"></a><span id="l23.1247" class="difflineplus">+static int nslberi_extwrite_compat(int s, const void* buf, int len,</span>
<a href="#l23.1248"></a><span id="l23.1248" class="difflineplus">+                                   struct lextiof_socket_private* arg) {</span>
<a href="#l23.1249"></a><span id="l23.1249" class="difflineplus">+  Sockbuf* sb = (Sockbuf*)arg;</span>
<a href="#l23.1250"></a><span id="l23.1250"> </span>
<a href="#l23.1251"></a><span id="l23.1251">   return (sb-&gt;sb_io_fns.lbiof_write(sb-&gt;sb_sd, buf, len));</span>
<a href="#l23.1252"></a><span id="l23.1252"> }</span>
<a href="#l23.1253"></a><span id="l23.1253"> </span>
<a href="#l23.1254"></a><span id="l23.1254"> /*</span>
<a href="#l23.1255"></a><span id="l23.1255">  * Install I/O compatibility functions.  This can't fail.</span>
<a href="#l23.1256"></a><span id="l23.1256">  */</span>
<a href="#l23.1257"></a><span id="l23.1257" class="difflineminus">-static void nslberi_install_compat_io_fns(Sockbuf *sb) {</span>
<a href="#l23.1258"></a><span id="l23.1258" class="difflineplus">+static void nslberi_install_compat_io_fns(Sockbuf* sb) {</span>
<a href="#l23.1259"></a><span id="l23.1259">   sb-&gt;sb_ext_io_fns.lbextiofn_size = LBER_X_EXTIO_FNS_SIZE;</span>
<a href="#l23.1260"></a><span id="l23.1260">   sb-&gt;sb_ext_io_fns.lbextiofn_read = nslberi_extread_compat;</span>
<a href="#l23.1261"></a><span id="l23.1261">   sb-&gt;sb_ext_io_fns.lbextiofn_write = nslberi_extwrite_compat;</span>
<a href="#l23.1262"></a><span id="l23.1262">   sb-&gt;sb_ext_io_fns.lbextiofn_writev = NULL;</span>
<a href="#l23.1263"></a><span id="l23.1263" class="difflineminus">-  sb-&gt;sb_ext_io_fns.lbextiofn_socket_arg = (void *)sb;</span>
<a href="#l23.1264"></a><span id="l23.1264" class="difflineplus">+  sb-&gt;sb_ext_io_fns.lbextiofn_socket_arg = (void*)sb;</span>
<a href="#l23.1265"></a><span id="l23.1265"> }</span>
<a href="#l23.1266"></a><span id="l23.1266"> /*</span>
<a href="#l23.1267"></a><span id="l23.1267">  * end of compat I/O functions</span>
<a href="#l23.1268"></a><span id="l23.1268">  ******************************************************************************</span>
<a href="#l23.1269"></a><span id="l23.1269">  */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/lber-int.h</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/lber-int.h</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -122,27 +122,27 @@ extern &quot;C&quot; {</span>
<a href="#l24.4"></a><span id="l24.4"> #  define NSLDAPI_LBER_SOCKET_IS_PTR</span>
<a href="#l24.5"></a><span id="l24.5"> #endif</span>
<a href="#l24.6"></a><span id="l24.6"> </span>
<a href="#l24.7"></a><span id="l24.7"> #define OLD_LBER_SEQUENCE 0x10 /* w/o constructed bit - broken */</span>
<a href="#l24.8"></a><span id="l24.8"> #define OLD_LBER_SET 0x11      /* w/o constructed bit - broken */</span>
<a href="#l24.9"></a><span id="l24.9"> </span>
<a href="#l24.10"></a><span id="l24.10"> #ifndef _IFP</span>
<a href="#l24.11"></a><span id="l24.11"> #  define _IFP</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK *IFP)();</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK* IFP)();</span>
<a href="#l24.14"></a><span id="l24.14"> #endif</span>
<a href="#l24.15"></a><span id="l24.15"> </span>
<a href="#l24.16"></a><span id="l24.16"> typedef struct seqorset {</span>
<a href="#l24.17"></a><span id="l24.17">   ber_len_t sos_clen;</span>
<a href="#l24.18"></a><span id="l24.18">   ber_tag_t sos_tag;</span>
<a href="#l24.19"></a><span id="l24.19" class="difflineminus">-  char *sos_first;</span>
<a href="#l24.20"></a><span id="l24.20" class="difflineminus">-  char *sos_ptr;</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineminus">-  struct seqorset *sos_next;</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineplus">+  char* sos_first;</span>
<a href="#l24.23"></a><span id="l24.23" class="difflineplus">+  char* sos_ptr;</span>
<a href="#l24.24"></a><span id="l24.24" class="difflineplus">+  struct seqorset* sos_next;</span>
<a href="#l24.25"></a><span id="l24.25"> } Seqorset;</span>
<a href="#l24.26"></a><span id="l24.26" class="difflineminus">-#define NULLSEQORSET ((Seqorset *)0)</span>
<a href="#l24.27"></a><span id="l24.27" class="difflineplus">+#define NULLSEQORSET ((Seqorset*)0)</span>
<a href="#l24.28"></a><span id="l24.28"> </span>
<a href="#l24.29"></a><span id="l24.29"> #define SOS_STACK_SIZE 8 /* depth of the pre-allocated sos structure stack */</span>
<a href="#l24.30"></a><span id="l24.30"> </span>
<a href="#l24.31"></a><span id="l24.31"> #define MAX_TAG_SIZE \</span>
<a href="#l24.32"></a><span id="l24.32">   (1 + sizeof(ber_int_t)) /* One byte for the length of the tag */</span>
<a href="#l24.33"></a><span id="l24.33"> #define MAX_LEN_SIZE \</span>
<a href="#l24.34"></a><span id="l24.34">   (1 + sizeof(ber_int_t)) /* One byte for the length of the length */</span>
<a href="#l24.35"></a><span id="l24.35"> #define MAX_VALUE_PREFIX_SIZE \</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineat">@@ -160,85 +160,85 @@ typedef struct seqorset {</span>
<a href="#l24.37"></a><span id="l24.37"> struct berelement {</span>
<a href="#l24.38"></a><span id="l24.38">   ldap_x_iovec ber_struct[BER_ARRAY_QUANTITY]; /* See above */</span>
<a href="#l24.39"></a><span id="l24.39"> </span>
<a href="#l24.40"></a><span id="l24.40">   char ber_tag_contents[MAX_TAG_SIZE];</span>
<a href="#l24.41"></a><span id="l24.41">   char ber_len_contents[MAX_LEN_SIZE];</span>
<a href="#l24.42"></a><span id="l24.42">   char ber_pre_contents[MAX_VALUE_PREFIX_SIZE];</span>
<a href="#l24.43"></a><span id="l24.43">   char ber_suf_contents[MAX_LEN_SIZE + 1];</span>
<a href="#l24.44"></a><span id="l24.44"> </span>
<a href="#l24.45"></a><span id="l24.45" class="difflineminus">-  char *ber_buf; /* update the value value when writing in case realloc is</span>
<a href="#l24.46"></a><span id="l24.46" class="difflineplus">+  char* ber_buf; /* update the value value when writing in case realloc is</span>
<a href="#l24.47"></a><span id="l24.47">                     called */</span>
<a href="#l24.48"></a><span id="l24.48" class="difflineminus">-  char *ber_ptr;</span>
<a href="#l24.49"></a><span id="l24.49" class="difflineminus">-  char *ber_end;</span>
<a href="#l24.50"></a><span id="l24.50" class="difflineminus">-  struct seqorset *ber_sos;</span>
<a href="#l24.51"></a><span id="l24.51" class="difflineplus">+  char* ber_ptr;</span>
<a href="#l24.52"></a><span id="l24.52" class="difflineplus">+  char* ber_end;</span>
<a href="#l24.53"></a><span id="l24.53" class="difflineplus">+  struct seqorset* ber_sos;</span>
<a href="#l24.54"></a><span id="l24.54">   ber_len_t ber_tag_len_read;</span>
<a href="#l24.55"></a><span id="l24.55">   ber_tag_t ber_tag; /* Remove me someday */</span>
<a href="#l24.56"></a><span id="l24.56">   ber_len_t ber_len; /* Remove me someday */</span>
<a href="#l24.57"></a><span id="l24.57">   int ber_usertag;</span>
<a href="#l24.58"></a><span id="l24.58">   char ber_options;</span>
<a href="#l24.59"></a><span id="l24.59" class="difflineminus">-  char *ber_rwptr;</span>
<a href="#l24.60"></a><span id="l24.60" class="difflineplus">+  char* ber_rwptr;</span>
<a href="#l24.61"></a><span id="l24.61">   BERTranslateProc ber_encode_translate_proc;</span>
<a href="#l24.62"></a><span id="l24.62">   BERTranslateProc ber_decode_translate_proc;</span>
<a href="#l24.63"></a><span id="l24.63">   int ber_flags;</span>
<a href="#l24.64"></a><span id="l24.64"> #define LBER_FLAG_NO_FREE_BUFFER 1 /* don't free ber_buf */</span>
<a href="#l24.65"></a><span id="l24.65">   unsigned int ber_buf_reallocs;   /* realloc counter */</span>
<a href="#l24.66"></a><span id="l24.66">   int ber_sos_stack_posn;</span>
<a href="#l24.67"></a><span id="l24.67">   Seqorset ber_sos_stack[SOS_STACK_SIZE];</span>
<a href="#l24.68"></a><span id="l24.68"> };</span>
<a href="#l24.69"></a><span id="l24.69"> </span>
<a href="#l24.70"></a><span id="l24.70"> #define BER_CONTENTS_STRUCT_SIZE (sizeof(ldap_x_iovec) * BER_ARRAY_QUANTITY)</span>
<a href="#l24.71"></a><span id="l24.71"> </span>
<a href="#l24.72"></a><span id="l24.72" class="difflineminus">-#define NULLBER ((BerElement *)NULL)</span>
<a href="#l24.73"></a><span id="l24.73" class="difflineplus">+#define NULLBER ((BerElement*)NULL)</span>
<a href="#l24.74"></a><span id="l24.74"> </span>
<a href="#l24.75"></a><span id="l24.75"> #ifdef LDAP_DEBUG</span>
<a href="#l24.76"></a><span id="l24.76" class="difflineminus">-void ber_dump(BerElement *ber, int inout);</span>
<a href="#l24.77"></a><span id="l24.77" class="difflineplus">+void ber_dump(BerElement* ber, int inout);</span>
<a href="#l24.78"></a><span id="l24.78"> #endif</span>
<a href="#l24.79"></a><span id="l24.79"> </span>
<a href="#l24.80"></a><span id="l24.80"> /*</span>
<a href="#l24.81"></a><span id="l24.81">  * structure for read/write I/O callback functions.</span>
<a href="#l24.82"></a><span id="l24.82">  */</span>
<a href="#l24.83"></a><span id="l24.83"> struct nslberi_io_fns {</span>
<a href="#l24.84"></a><span id="l24.84" class="difflineminus">-  LDAP_IOF_READ_CALLBACK *lbiof_read;</span>
<a href="#l24.85"></a><span id="l24.85" class="difflineminus">-  LDAP_IOF_WRITE_CALLBACK *lbiof_write;</span>
<a href="#l24.86"></a><span id="l24.86" class="difflineplus">+  LDAP_IOF_READ_CALLBACK* lbiof_read;</span>
<a href="#l24.87"></a><span id="l24.87" class="difflineplus">+  LDAP_IOF_WRITE_CALLBACK* lbiof_write;</span>
<a href="#l24.88"></a><span id="l24.88"> };</span>
<a href="#l24.89"></a><span id="l24.89"> </span>
<a href="#l24.90"></a><span id="l24.90"> /*</span>
<a href="#l24.91"></a><span id="l24.91">  * Old  structure for use with LBER_SOCKBUF_OPT_EXT_IO_FNS:</span>
<a href="#l24.92"></a><span id="l24.92">  */</span>
<a href="#l24.93"></a><span id="l24.93"> struct lber_x_ext_io_fns_rev0 {</span>
<a href="#l24.94"></a><span id="l24.94">   /* lbextiofn_size should always be set to LBER_X_EXTIO_FNS_SIZE */</span>
<a href="#l24.95"></a><span id="l24.95">   int lbextiofn_size;</span>
<a href="#l24.96"></a><span id="l24.96" class="difflineminus">-  LDAP_X_EXTIOF_READ_CALLBACK *lbextiofn_read;</span>
<a href="#l24.97"></a><span id="l24.97" class="difflineminus">-  LDAP_X_EXTIOF_WRITE_CALLBACK *lbextiofn_write;</span>
<a href="#l24.98"></a><span id="l24.98" class="difflineminus">-  struct lextiof_socket_private *lbextiofn_socket_arg;</span>
<a href="#l24.99"></a><span id="l24.99" class="difflineplus">+  LDAP_X_EXTIOF_READ_CALLBACK* lbextiofn_read;</span>
<a href="#l24.100"></a><span id="l24.100" class="difflineplus">+  LDAP_X_EXTIOF_WRITE_CALLBACK* lbextiofn_write;</span>
<a href="#l24.101"></a><span id="l24.101" class="difflineplus">+  struct lextiof_socket_private* lbextiofn_socket_arg;</span>
<a href="#l24.102"></a><span id="l24.102"> };</span>
<a href="#l24.103"></a><span id="l24.103"> #define LBER_X_EXTIO_FNS_SIZE_REV0 sizeof(struct lber_x_ext_io_fns_rev0)</span>
<a href="#l24.104"></a><span id="l24.104"> </span>
<a href="#l24.105"></a><span id="l24.105"> struct sockbuf {</span>
<a href="#l24.106"></a><span id="l24.106">   LBER_SOCKET sb_sd;</span>
<a href="#l24.107"></a><span id="l24.107">   BerElement sb_ber;</span>
<a href="#l24.108"></a><span id="l24.108">   int sb_naddr;      /* &gt; 0 implies using CLDAP (UDP) */</span>
<a href="#l24.109"></a><span id="l24.109" class="difflineminus">-  void *sb_useaddr;  /* pointer to sockaddr to use next */</span>
<a href="#l24.110"></a><span id="l24.110" class="difflineminus">-  void *sb_fromaddr; /* pointer to message source sockaddr */</span>
<a href="#l24.111"></a><span id="l24.111" class="difflineminus">-  void **sb_addrs;   /* actually an array of pointers to</span>
<a href="#l24.112"></a><span id="l24.112" class="difflineplus">+  void* sb_useaddr;  /* pointer to sockaddr to use next */</span>
<a href="#l24.113"></a><span id="l24.113" class="difflineplus">+  void* sb_fromaddr; /* pointer to message source sockaddr */</span>
<a href="#l24.114"></a><span id="l24.114" class="difflineplus">+  void** sb_addrs;   /* actually an array of pointers to</span>
<a href="#l24.115"></a><span id="l24.115">                         sockaddrs */</span>
<a href="#l24.116"></a><span id="l24.116"> </span>
<a href="#l24.117"></a><span id="l24.117">   int sb_options;        /* to support copying ber elements */</span>
<a href="#l24.118"></a><span id="l24.118">   LBER_SOCKET sb_copyfd; /* for LBER_SOCKBUF_OPT_TO_FILE* opts */</span>
<a href="#l24.119"></a><span id="l24.119">   ber_len_t sb_max_incoming;</span>
<a href="#l24.120"></a><span id="l24.120">   ber_tag_t sb_valid_tag;          /* valid tag to accept */</span>
<a href="#l24.121"></a><span id="l24.121">   struct nslberi_io_fns sb_io_fns; /* classic I/O callback functions */</span>
<a href="#l24.122"></a><span id="l24.122"> </span>
<a href="#l24.123"></a><span id="l24.123">   struct lber_x_ext_io_fns sb_ext_io_fns; /* extended I/O callback functions */</span>
<a href="#l24.124"></a><span id="l24.124"> };</span>
<a href="#l24.125"></a><span id="l24.125" class="difflineminus">-#define NULLSOCKBUF ((Sockbuf *)NULL)</span>
<a href="#l24.126"></a><span id="l24.126" class="difflineplus">+#define NULLSOCKBUF ((Sockbuf*)NULL)</span>
<a href="#l24.127"></a><span id="l24.127"> </span>
<a href="#l24.128"></a><span id="l24.128"> /* needed by libldap, even in non-DEBUG builds */</span>
<a href="#l24.129"></a><span id="l24.129" class="difflineminus">-void ber_err_print(char *data);</span>
<a href="#l24.130"></a><span id="l24.130" class="difflineplus">+void ber_err_print(char* data);</span>
<a href="#l24.131"></a><span id="l24.131"> </span>
<a href="#l24.132"></a><span id="l24.132"> #ifndef NSLBERI_LBER_INT_FRIEND</span>
<a href="#l24.133"></a><span id="l24.133"> /*</span>
<a href="#l24.134"></a><span id="l24.134">  * Everything from this point on is excluded if NSLBERI_LBER_INT_FRIEND is</span>
<a href="#l24.135"></a><span id="l24.135">  * defined.  The code under ../libraries/libldap defines this.</span>
<a href="#l24.136"></a><span id="l24.136">  */</span>
<a href="#l24.137"></a><span id="l24.137"> </span>
<a href="#l24.138"></a><span id="l24.138"> #  define READBUFSIZ 8192</span>
<a href="#l24.139"></a><span id="l24.139" class="difflineat">@@ -250,43 +250,43 @@ void ber_err_print(char *data);</span>
<a href="#l24.140"></a><span id="l24.140"> </span>
<a href="#l24.141"></a><span id="l24.141"> #  define NSLBERI_VALID_SOCKBUF_POINTER(sb) ((sb) != NULLSOCKBUF)</span>
<a href="#l24.142"></a><span id="l24.142"> </span>
<a href="#l24.143"></a><span id="l24.143"> #  define LBER_HTONL(l) htonl(l)</span>
<a href="#l24.144"></a><span id="l24.144"> #  define LBER_NTOHL(l) ntohl(l)</span>
<a href="#l24.145"></a><span id="l24.145"> </span>
<a href="#l24.146"></a><span id="l24.146"> /* function prototypes */</span>
<a href="#l24.147"></a><span id="l24.147"> #  ifdef LDAP_DEBUG</span>
<a href="#l24.148"></a><span id="l24.148" class="difflineminus">-void lber_bprint(char *data, int len);</span>
<a href="#l24.149"></a><span id="l24.149" class="difflineplus">+void lber_bprint(char* data, int len);</span>
<a href="#l24.150"></a><span id="l24.150"> #  endif</span>
<a href="#l24.151"></a><span id="l24.151" class="difflineminus">-void ber_err_print(char *data);</span>
<a href="#l24.152"></a><span id="l24.152" class="difflineminus">-void *nslberi_malloc(size_t size);</span>
<a href="#l24.153"></a><span id="l24.153" class="difflineminus">-void *nslberi_calloc(size_t nelem, size_t elsize);</span>
<a href="#l24.154"></a><span id="l24.154" class="difflineminus">-void *nslberi_realloc(void *ptr, size_t size);</span>
<a href="#l24.155"></a><span id="l24.155" class="difflineminus">-void nslberi_free(void *ptr);</span>
<a href="#l24.156"></a><span id="l24.156" class="difflineminus">-int nslberi_ber_realloc(BerElement *ber, ber_len_t len);</span>
<a href="#l24.157"></a><span id="l24.157" class="difflineplus">+void ber_err_print(char* data);</span>
<a href="#l24.158"></a><span id="l24.158" class="difflineplus">+void* nslberi_malloc(size_t size);</span>
<a href="#l24.159"></a><span id="l24.159" class="difflineplus">+void* nslberi_calloc(size_t nelem, size_t elsize);</span>
<a href="#l24.160"></a><span id="l24.160" class="difflineplus">+void* nslberi_realloc(void* ptr, size_t size);</span>
<a href="#l24.161"></a><span id="l24.161" class="difflineplus">+void nslberi_free(void* ptr);</span>
<a href="#l24.162"></a><span id="l24.162" class="difflineplus">+int nslberi_ber_realloc(BerElement* ber, ber_len_t len);</span>
<a href="#l24.163"></a><span id="l24.163"> </span>
<a href="#l24.164"></a><span id="l24.164"> /* blame: dboreham</span>
<a href="#l24.165"></a><span id="l24.165">  * slapd spends much of its time doing memcpy's for the ber code.</span>
<a href="#l24.166"></a><span id="l24.166">  * Most of these are single-byte, so we special-case those and speed</span>
<a href="#l24.167"></a><span id="l24.167">  * things up considerably.</span>
<a href="#l24.168"></a><span id="l24.168">  */</span>
<a href="#l24.169"></a><span id="l24.169"> </span>
<a href="#l24.170"></a><span id="l24.170"> #  ifdef sunos4</span>
<a href="#l24.171"></a><span id="l24.171"> #    define THEMEMCPY(d, s, n) bcopy(s, d, n)</span>
<a href="#l24.172"></a><span id="l24.172"> #  else /* sunos4 */</span>
<a href="#l24.173"></a><span id="l24.173"> #    define THEMEMCPY(d, s, n) memmove(d, s, n)</span>
<a href="#l24.174"></a><span id="l24.174"> #  endif /* sunos4 */</span>
<a href="#l24.175"></a><span id="l24.175"> </span>
<a href="#l24.176"></a><span id="l24.176"> #  ifdef SAFEMEMCPY</span>
<a href="#l24.177"></a><span id="l24.177"> #    undef SAFEMEMCPY</span>
<a href="#l24.178"></a><span id="l24.178" class="difflineminus">-#    define SAFEMEMCPY(d, s, n)      \</span>
<a href="#l24.179"></a><span id="l24.179" class="difflineminus">-      if (1 == n)                    \</span>
<a href="#l24.180"></a><span id="l24.180" class="difflineminus">-        *((char *)d) = *((char *)s); \</span>
<a href="#l24.181"></a><span id="l24.181" class="difflineminus">-      else                           \</span>
<a href="#l24.182"></a><span id="l24.182" class="difflineplus">+#    define SAFEMEMCPY(d, s, n)    \</span>
<a href="#l24.183"></a><span id="l24.183" class="difflineplus">+      if (1 == n)                  \</span>
<a href="#l24.184"></a><span id="l24.184" class="difflineplus">+        *((char*)d) = *((char*)s); \</span>
<a href="#l24.185"></a><span id="l24.185" class="difflineplus">+      else                         \</span>
<a href="#l24.186"></a><span id="l24.186">         THEMEMCPY(d, s, n);</span>
<a href="#l24.187"></a><span id="l24.187"> #  endif</span>
<a href="#l24.188"></a><span id="l24.188"> </span>
<a href="#l24.189"></a><span id="l24.189"> /*</span>
<a href="#l24.190"></a><span id="l24.190">  * Memory allocation done in liblber should all go through one of the</span>
<a href="#l24.191"></a><span id="l24.191">  * following macros. This is so we can plug-in alternative memory</span>
<a href="#l24.192"></a><span id="l24.192">  * allocators, etc. as the need arises.</span>
<a href="#l24.193"></a><span id="l24.193">  */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/abandon.c</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/abandon.c</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -46,50 +46,50 @@</span>
<a href="#l25.4"></a><span id="l25.4"> #if 0</span>
<a href="#l25.5"></a><span id="l25.5"> #  ifndef lint</span>
<a href="#l25.6"></a><span id="l25.6"> static char copyright[] = &quot;@(#) Copyright (c) 1990 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l25.7"></a><span id="l25.7"> #  endif</span>
<a href="#l25.8"></a><span id="l25.8"> #endif</span>
<a href="#l25.9"></a><span id="l25.9"> </span>
<a href="#l25.10"></a><span id="l25.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l25.11"></a><span id="l25.11"> </span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-static int do_abandon(LDAP *ld, int origid, int msgid,</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineminus">-                      LDAPControl **serverctrls, LDAPControl **clientctrls);</span>
<a href="#l25.14"></a><span id="l25.14" class="difflineminus">-static int nsldapi_send_abandon_message(LDAP *ld, LDAPConn *lc, BerElement *ber,</span>
<a href="#l25.15"></a><span id="l25.15" class="difflineplus">+static int do_abandon(LDAP* ld, int origid, int msgid,</span>
<a href="#l25.16"></a><span id="l25.16" class="difflineplus">+                      LDAPControl** serverctrls, LDAPControl** clientctrls);</span>
<a href="#l25.17"></a><span id="l25.17" class="difflineplus">+static int nsldapi_send_abandon_message(LDAP* ld, LDAPConn* lc, BerElement* ber,</span>
<a href="#l25.18"></a><span id="l25.18">                                         int abandon_msgid);</span>
<a href="#l25.19"></a><span id="l25.19"> </span>
<a href="#l25.20"></a><span id="l25.20"> /*</span>
<a href="#l25.21"></a><span id="l25.21">  * ldap_abandon - perform an ldap abandon operation. Parameters:</span>
<a href="#l25.22"></a><span id="l25.22">  *</span>
<a href="#l25.23"></a><span id="l25.23">  * ld     LDAP descriptor</span>
<a href="#l25.24"></a><span id="l25.24">  * msgid  The message id of the operation to abandon</span>
<a href="#l25.25"></a><span id="l25.25">  *</span>
<a href="#l25.26"></a><span id="l25.26">  * ldap_abandon returns 0 if everything went ok, -1 otherwise.</span>
<a href="#l25.27"></a><span id="l25.27">  *</span>
<a href="#l25.28"></a><span id="l25.28">  * Example:</span>
<a href="#l25.29"></a><span id="l25.29">  * ldap_abandon(ld, msgid);</span>
<a href="#l25.30"></a><span id="l25.30">  */</span>
<a href="#l25.31"></a><span id="l25.31" class="difflineminus">-int LDAP_CALL ldap_abandon(LDAP *ld, int msgid) {</span>
<a href="#l25.32"></a><span id="l25.32" class="difflineplus">+int LDAP_CALL ldap_abandon(LDAP* ld, int msgid) {</span>
<a href="#l25.33"></a><span id="l25.33">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_abandon %d\n&quot;, msgid, 0, 0);</span>
<a href="#l25.34"></a><span id="l25.34">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;4e65747363617065\n&quot;, msgid, 0, 0);</span>
<a href="#l25.35"></a><span id="l25.35">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;466f726576657221\n&quot;, msgid, 0, 0);</span>
<a href="#l25.36"></a><span id="l25.36"> </span>
<a href="#l25.37"></a><span id="l25.37">   if (ldap_abandon_ext(ld, msgid, NULL, NULL) == LDAP_SUCCESS) {</span>
<a href="#l25.38"></a><span id="l25.38">     return (0);</span>
<a href="#l25.39"></a><span id="l25.39">   }</span>
<a href="#l25.40"></a><span id="l25.40"> </span>
<a href="#l25.41"></a><span id="l25.41">   return (-1);</span>
<a href="#l25.42"></a><span id="l25.42"> }</span>
<a href="#l25.43"></a><span id="l25.43"> </span>
<a href="#l25.44"></a><span id="l25.44"> /*</span>
<a href="#l25.45"></a><span id="l25.45">  * LDAPv3 extended abandon.</span>
<a href="#l25.46"></a><span id="l25.46">  * Returns an LDAP error code.</span>
<a href="#l25.47"></a><span id="l25.47">  */</span>
<a href="#l25.48"></a><span id="l25.48" class="difflineminus">-int LDAP_CALL ldap_abandon_ext(LDAP *ld, int msgid, LDAPControl **serverctrls,</span>
<a href="#l25.49"></a><span id="l25.49" class="difflineminus">-                               LDAPControl **clientctrls) {</span>
<a href="#l25.50"></a><span id="l25.50" class="difflineplus">+int LDAP_CALL ldap_abandon_ext(LDAP* ld, int msgid, LDAPControl** serverctrls,</span>
<a href="#l25.51"></a><span id="l25.51" class="difflineplus">+                               LDAPControl** clientctrls) {</span>
<a href="#l25.52"></a><span id="l25.52">   int rc;</span>
<a href="#l25.53"></a><span id="l25.53"> </span>
<a href="#l25.54"></a><span id="l25.54">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_abandon_ext %d\n&quot;, msgid, 0, 0);</span>
<a href="#l25.55"></a><span id="l25.55"> </span>
<a href="#l25.56"></a><span id="l25.56">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l25.57"></a><span id="l25.57">     return (LDAP_PARAM_ERROR);</span>
<a href="#l25.58"></a><span id="l25.58">   }</span>
<a href="#l25.59"></a><span id="l25.59"> </span>
<a href="#l25.60"></a><span id="l25.60" class="difflineat">@@ -109,21 +109,21 @@ int LDAP_CALL ldap_abandon_ext(LDAP *ld,</span>
<a href="#l25.61"></a><span id="l25.61"> }</span>
<a href="#l25.62"></a><span id="l25.62"> </span>
<a href="#l25.63"></a><span id="l25.63"> /*</span>
<a href="#l25.64"></a><span id="l25.64">  * Abandon all outstanding requests for msgid (included child requests</span>
<a href="#l25.65"></a><span id="l25.65">  * spawned when chasing referrals).  This function calls itself recursively.</span>
<a href="#l25.66"></a><span id="l25.66">  * No locking is done is this function so it must be done by the caller.</span>
<a href="#l25.67"></a><span id="l25.67">  * Returns an LDAP error code and sets it in LDAP *ld as well</span>
<a href="#l25.68"></a><span id="l25.68">  */</span>
<a href="#l25.69"></a><span id="l25.69" class="difflineminus">-static int do_abandon(LDAP *ld, int origid, int msgid,</span>
<a href="#l25.70"></a><span id="l25.70" class="difflineminus">-                      LDAPControl **serverctrls, LDAPControl **clientctrls) {</span>
<a href="#l25.71"></a><span id="l25.71" class="difflineminus">-  BerElement *ber;</span>
<a href="#l25.72"></a><span id="l25.72" class="difflineplus">+static int do_abandon(LDAP* ld, int origid, int msgid,</span>
<a href="#l25.73"></a><span id="l25.73" class="difflineplus">+                      LDAPControl** serverctrls, LDAPControl** clientctrls) {</span>
<a href="#l25.74"></a><span id="l25.74" class="difflineplus">+  BerElement* ber;</span>
<a href="#l25.75"></a><span id="l25.75">   int i, bererr, lderr, sendabandon;</span>
<a href="#l25.76"></a><span id="l25.76" class="difflineminus">-  LDAPRequest *lr = NULL;</span>
<a href="#l25.77"></a><span id="l25.77" class="difflineplus">+  LDAPRequest* lr = NULL;</span>
<a href="#l25.78"></a><span id="l25.78"> </span>
<a href="#l25.79"></a><span id="l25.79">   /*</span>
<a href="#l25.80"></a><span id="l25.80">    * An abandon request looks like this:</span>
<a href="#l25.81"></a><span id="l25.81">    * AbandonRequest ::= MessageID</span>
<a href="#l25.82"></a><span id="l25.82">    */</span>
<a href="#l25.83"></a><span id="l25.83">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;do_abandon origid %d, msgid %d\n&quot;, origid, msgid,</span>
<a href="#l25.84"></a><span id="l25.84">             0);</span>
<a href="#l25.85"></a><span id="l25.85"> </span>
<a href="#l25.86"></a><span id="l25.86" class="difflineat">@@ -214,27 +214,27 @@ static int do_abandon(LDAP *ld, int orig</span>
<a href="#l25.87"></a><span id="l25.87">   }</span>
<a href="#l25.88"></a><span id="l25.88"> </span>
<a href="#l25.89"></a><span id="l25.89">   /*</span>
<a href="#l25.90"></a><span id="l25.90">    * Record the abandoned message ID (used to discard any server responses</span>
<a href="#l25.91"></a><span id="l25.91">    * that arrive later).</span>
<a href="#l25.92"></a><span id="l25.92">    */</span>
<a href="#l25.93"></a><span id="l25.93">   LDAP_MUTEX_LOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l25.94"></a><span id="l25.94">   if (ld-&gt;ld_abandoned == NULL) {</span>
<a href="#l25.95"></a><span id="l25.95" class="difflineminus">-    if ((ld-&gt;ld_abandoned = (int *)NSLDAPI_MALLOC(2 * sizeof(int))) == NULL) {</span>
<a href="#l25.96"></a><span id="l25.96" class="difflineplus">+    if ((ld-&gt;ld_abandoned = (int*)NSLDAPI_MALLOC(2 * sizeof(int))) == NULL) {</span>
<a href="#l25.97"></a><span id="l25.97">       lderr = LDAP_NO_MEMORY;</span>
<a href="#l25.98"></a><span id="l25.98">       LDAP_MUTEX_UNLOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l25.99"></a><span id="l25.99">       goto set_errorcode_and_return;</span>
<a href="#l25.100"></a><span id="l25.100">     }</span>
<a href="#l25.101"></a><span id="l25.101">     i = 0;</span>
<a href="#l25.102"></a><span id="l25.102">   } else {</span>
<a href="#l25.103"></a><span id="l25.103">     for (i = 0; ld-&gt;ld_abandoned[i] != -1; i++)</span>
<a href="#l25.104"></a><span id="l25.104">       ; /* NULL */</span>
<a href="#l25.105"></a><span id="l25.105" class="difflineminus">-    if ((ld-&gt;ld_abandoned = (int *)NSLDAPI_REALLOC(</span>
<a href="#l25.106"></a><span id="l25.106" class="difflineminus">-             (char *)ld-&gt;ld_abandoned, (i + 2) * sizeof(int))) == NULL) {</span>
<a href="#l25.107"></a><span id="l25.107" class="difflineplus">+    if ((ld-&gt;ld_abandoned = (int*)NSLDAPI_REALLOC(</span>
<a href="#l25.108"></a><span id="l25.108" class="difflineplus">+             (char*)ld-&gt;ld_abandoned, (i + 2) * sizeof(int))) == NULL) {</span>
<a href="#l25.109"></a><span id="l25.109">       lderr = LDAP_NO_MEMORY;</span>
<a href="#l25.110"></a><span id="l25.110">       LDAP_MUTEX_UNLOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l25.111"></a><span id="l25.111">       goto set_errorcode_and_return;</span>
<a href="#l25.112"></a><span id="l25.112">     }</span>
<a href="#l25.113"></a><span id="l25.113">   }</span>
<a href="#l25.114"></a><span id="l25.114">   ld-&gt;ld_abandoned[i] = msgid;</span>
<a href="#l25.115"></a><span id="l25.115">   ld-&gt;ld_abandoned[i + 1] = -1;</span>
<a href="#l25.116"></a><span id="l25.116">   LDAP_MUTEX_UNLOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l25.117"></a><span id="l25.117" class="difflineat">@@ -243,29 +243,29 @@ set_errorcode_and_return:</span>
<a href="#l25.118"></a><span id="l25.118">   LDAP_SET_LDERRNO(ld, lderr, NULL, NULL);</span>
<a href="#l25.119"></a><span id="l25.119">   return (lderr);</span>
<a href="#l25.120"></a><span id="l25.120"> }</span>
<a href="#l25.121"></a><span id="l25.121"> </span>
<a href="#l25.122"></a><span id="l25.122"> /*</span>
<a href="#l25.123"></a><span id="l25.123">  * Try to send the abandon message that is encoded in ber.  Returns an</span>
<a href="#l25.124"></a><span id="l25.124">  * LDAP result code.</span>
<a href="#l25.125"></a><span id="l25.125">  */</span>
<a href="#l25.126"></a><span id="l25.126" class="difflineminus">-static int nsldapi_send_abandon_message(LDAP *ld, LDAPConn *lc, BerElement *ber,</span>
<a href="#l25.127"></a><span id="l25.127" class="difflineplus">+static int nsldapi_send_abandon_message(LDAP* ld, LDAPConn* lc, BerElement* ber,</span>
<a href="#l25.128"></a><span id="l25.128">                                         int abandon_msgid) {</span>
<a href="#l25.129"></a><span id="l25.129">   int lderr = LDAP_SUCCESS;</span>
<a href="#l25.130"></a><span id="l25.130">   int err = 0;</span>
<a href="#l25.131"></a><span id="l25.131"> </span>
<a href="#l25.132"></a><span id="l25.132">   err = nsldapi_send_ber_message(ld, lc-&gt;lconn_sb, ber, 1 /* free ber */,</span>
<a href="#l25.133"></a><span id="l25.133">                                  0 /* will not handle EPIPE */);</span>
<a href="#l25.134"></a><span id="l25.134">   if (err == -2) {</span>
<a href="#l25.135"></a><span id="l25.135">     /*</span>
<a href="#l25.136"></a><span id="l25.136">      * &quot;Would block&quot; error.  Queue the abandon as</span>
<a href="#l25.137"></a><span id="l25.137">      * a pending request.</span>
<a href="#l25.138"></a><span id="l25.138">      */</span>
<a href="#l25.139"></a><span id="l25.139" class="difflineminus">-    LDAPRequest *lr;</span>
<a href="#l25.140"></a><span id="l25.140" class="difflineplus">+    LDAPRequest* lr;</span>
<a href="#l25.141"></a><span id="l25.141"> </span>
<a href="#l25.142"></a><span id="l25.142">     lr = nsldapi_new_request(lc, ber, abandon_msgid,</span>
<a href="#l25.143"></a><span id="l25.143">                              0 /* no response expected */);</span>
<a href="#l25.144"></a><span id="l25.144">     if (lr == NULL) {</span>
<a href="#l25.145"></a><span id="l25.145">       lderr = LDAP_NO_MEMORY;</span>
<a href="#l25.146"></a><span id="l25.146">       ber_free(ber, 1);</span>
<a href="#l25.147"></a><span id="l25.147">     } else {</span>
<a href="#l25.148"></a><span id="l25.148">       lr-&gt;lr_status = LDAP_REQST_WRITING;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/add.c</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/add.c</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -64,36 +64,36 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l26.4"></a><span id="l26.4">  * LDAPMod  *attrs[] = {</span>
<a href="#l26.5"></a><span id="l26.5">  *     { 0, &quot;cn&quot;, { &quot;babs jensen&quot;, &quot;babs&quot;, 0 } },</span>
<a href="#l26.6"></a><span id="l26.6">  *     { 0, &quot;sn&quot;, { &quot;jensen&quot;, 0 } },</span>
<a href="#l26.7"></a><span id="l26.7">  *     { 0, &quot;objectClass&quot;, { &quot;person&quot;, 0 } },</span>
<a href="#l26.8"></a><span id="l26.8">  *     0</span>
<a href="#l26.9"></a><span id="l26.9">  *   }</span>
<a href="#l26.10"></a><span id="l26.10">  * msgid = ldap_add(ld, dn, attrs);</span>
<a href="#l26.11"></a><span id="l26.11">  */</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-int LDAP_CALL ldap_add(LDAP *ld, const char *dn, LDAPMod **attrs) {</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+int LDAP_CALL ldap_add(LDAP* ld, const char* dn, LDAPMod** attrs) {</span>
<a href="#l26.14"></a><span id="l26.14">   int msgid;</span>
<a href="#l26.15"></a><span id="l26.15"> </span>
<a href="#l26.16"></a><span id="l26.16">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_add\n&quot;, 0, 0, 0);</span>
<a href="#l26.17"></a><span id="l26.17"> </span>
<a href="#l26.18"></a><span id="l26.18">   if (ldap_add_ext(ld, dn, attrs, NULL, NULL, &amp;msgid) == LDAP_SUCCESS) {</span>
<a href="#l26.19"></a><span id="l26.19">     return (msgid);</span>
<a href="#l26.20"></a><span id="l26.20">   } else {</span>
<a href="#l26.21"></a><span id="l26.21">     return (-1); /* error is in ld handle */</span>
<a href="#l26.22"></a><span id="l26.22">   }</span>
<a href="#l26.23"></a><span id="l26.23"> }</span>
<a href="#l26.24"></a><span id="l26.24"> </span>
<a href="#l26.25"></a><span id="l26.25"> /*</span>
<a href="#l26.26"></a><span id="l26.26">  * LDAPv3 extended add.</span>
<a href="#l26.27"></a><span id="l26.27">  * Returns an LDAP error code.</span>
<a href="#l26.28"></a><span id="l26.28">  */</span>
<a href="#l26.29"></a><span id="l26.29" class="difflineminus">-int LDAP_CALL ldap_add_ext(LDAP *ld, const char *dn, LDAPMod **attrs,</span>
<a href="#l26.30"></a><span id="l26.30" class="difflineminus">-                           LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l26.31"></a><span id="l26.31" class="difflineminus">-                           int *msgidp) {</span>
<a href="#l26.32"></a><span id="l26.32" class="difflineminus">-  BerElement *ber;</span>
<a href="#l26.33"></a><span id="l26.33" class="difflineplus">+int LDAP_CALL ldap_add_ext(LDAP* ld, const char* dn, LDAPMod** attrs,</span>
<a href="#l26.34"></a><span id="l26.34" class="difflineplus">+                           LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineplus">+                           int* msgidp) {</span>
<a href="#l26.36"></a><span id="l26.36" class="difflineplus">+  BerElement* ber;</span>
<a href="#l26.37"></a><span id="l26.37">   int i, rc, lderr;</span>
<a href="#l26.38"></a><span id="l26.38"> </span>
<a href="#l26.39"></a><span id="l26.39">   /*</span>
<a href="#l26.40"></a><span id="l26.40">    * An add request looks like this:</span>
<a href="#l26.41"></a><span id="l26.41">    * AddRequest ::= SEQUENCE {</span>
<a href="#l26.42"></a><span id="l26.42">    *   entry DistinguishedName,</span>
<a href="#l26.43"></a><span id="l26.43">    *   attrs SEQUENCE OF SEQUENCE {</span>
<a href="#l26.44"></a><span id="l26.44">    *     type AttributeType,</span>
<a href="#l26.45"></a><span id="l26.45" class="difflineat">@@ -172,34 +172,34 @@ int LDAP_CALL ldap_add_ext(LDAP *ld, con</span>
<a href="#l26.46"></a><span id="l26.46">   }</span>
<a href="#l26.47"></a><span id="l26.47"> </span>
<a href="#l26.48"></a><span id="l26.48">   if ((lderr = nsldapi_put_controls(ld, serverctrls, 1, ber)) != LDAP_SUCCESS) {</span>
<a href="#l26.49"></a><span id="l26.49">     ber_free(ber, 1);</span>
<a href="#l26.50"></a><span id="l26.50">     return (lderr);</span>
<a href="#l26.51"></a><span id="l26.51">   }</span>
<a href="#l26.52"></a><span id="l26.52"> </span>
<a href="#l26.53"></a><span id="l26.53">   /* send the message */</span>
<a href="#l26.54"></a><span id="l26.54" class="difflineminus">-  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_ADD, (char *)dn, ber);</span>
<a href="#l26.55"></a><span id="l26.55" class="difflineplus">+  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_ADD, (char*)dn, ber);</span>
<a href="#l26.56"></a><span id="l26.56">   *msgidp = rc;</span>
<a href="#l26.57"></a><span id="l26.57">   return (rc &lt; 0 ? LDAP_GET_LDERRNO(ld, NULL, NULL) : LDAP_SUCCESS);</span>
<a href="#l26.58"></a><span id="l26.58"> }</span>
<a href="#l26.59"></a><span id="l26.59"> </span>
<a href="#l26.60"></a><span id="l26.60" class="difflineminus">-int LDAP_CALL ldap_add_s(LDAP *ld, const char *dn, LDAPMod **attrs) {</span>
<a href="#l26.61"></a><span id="l26.61" class="difflineplus">+int LDAP_CALL ldap_add_s(LDAP* ld, const char* dn, LDAPMod** attrs) {</span>
<a href="#l26.62"></a><span id="l26.62">   return (ldap_add_ext_s(ld, dn, attrs, NULL, NULL));</span>
<a href="#l26.63"></a><span id="l26.63"> }</span>
<a href="#l26.64"></a><span id="l26.64"> </span>
<a href="#l26.65"></a><span id="l26.65" class="difflineminus">-int LDAP_CALL ldap_add_ext_s(LDAP *ld, const char *dn, LDAPMod **attrs,</span>
<a href="#l26.66"></a><span id="l26.66" class="difflineminus">-                             LDAPControl **serverctrls,</span>
<a href="#l26.67"></a><span id="l26.67" class="difflineminus">-                             LDAPControl **clientctrls) {</span>
<a href="#l26.68"></a><span id="l26.68" class="difflineplus">+int LDAP_CALL ldap_add_ext_s(LDAP* ld, const char* dn, LDAPMod** attrs,</span>
<a href="#l26.69"></a><span id="l26.69" class="difflineplus">+                             LDAPControl** serverctrls,</span>
<a href="#l26.70"></a><span id="l26.70" class="difflineplus">+                             LDAPControl** clientctrls) {</span>
<a href="#l26.71"></a><span id="l26.71">   int err, msgid;</span>
<a href="#l26.72"></a><span id="l26.72" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l26.73"></a><span id="l26.73" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l26.74"></a><span id="l26.74"> </span>
<a href="#l26.75"></a><span id="l26.75">   if ((err = ldap_add_ext(ld, dn, attrs, serverctrls, clientctrls, &amp;msgid)) !=</span>
<a href="#l26.76"></a><span id="l26.76">       LDAP_SUCCESS) {</span>
<a href="#l26.77"></a><span id="l26.77">     return (err);</span>
<a href="#l26.78"></a><span id="l26.78">   }</span>
<a href="#l26.79"></a><span id="l26.79"> </span>
<a href="#l26.80"></a><span id="l26.80" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)NULL, &amp;res) == -1) {</span>
<a href="#l26.81"></a><span id="l26.81" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)NULL, &amp;res) == -1) {</span>
<a href="#l26.82"></a><span id="l26.82">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l26.83"></a><span id="l26.83">   }</span>
<a href="#l26.84"></a><span id="l26.84"> </span>
<a href="#l26.85"></a><span id="l26.85">   return (ldap_result2error(ld, res, 1));</span>
<a href="#l26.86"></a><span id="l26.86"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/authzidctrl.c</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/authzidctrl.c</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -45,18 +45,18 @@ ld              LDAP pointer to the desi</span>
<a href="#l27.4"></a><span id="l27.4"> ctl_iscritical  Indicates whether the control is critical of not.</span>
<a href="#l27.5"></a><span id="l27.5">                 If this field is non-zero, the operation will only be</span>
<a href="#l27.6"></a><span id="l27.6">                 carried out if the control is recognized by the server</span>
<a href="#l27.7"></a><span id="l27.7">                 and/or client</span>
<a href="#l27.8"></a><span id="l27.8"> </span>
<a href="#l27.9"></a><span id="l27.9"> ctrlp           the address of a place to put the constructed control</span>
<a href="#l27.10"></a><span id="l27.10"> */</span>
<a href="#l27.11"></a><span id="l27.11"> </span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-int LDAP_CALL ldap_create_authzid_control(LDAP *ld, const char ctl_iscritical,</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineminus">-                                          LDAPControl **ctrlp) {</span>
<a href="#l27.14"></a><span id="l27.14" class="difflineplus">+int LDAP_CALL ldap_create_authzid_control(LDAP* ld, const char ctl_iscritical,</span>
<a href="#l27.15"></a><span id="l27.15" class="difflineplus">+                                          LDAPControl** ctrlp) {</span>
<a href="#l27.16"></a><span id="l27.16">   int rc;</span>
<a href="#l27.17"></a><span id="l27.17"> </span>
<a href="#l27.18"></a><span id="l27.18">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l27.19"></a><span id="l27.19">     return (LDAP_PARAM_ERROR);</span>
<a href="#l27.20"></a><span id="l27.20">   }</span>
<a href="#l27.21"></a><span id="l27.21"> </span>
<a href="#l27.22"></a><span id="l27.22">   if (ctrlp == NULL) {</span>
<a href="#l27.23"></a><span id="l27.23">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l27.24"></a><span id="l27.24" class="difflineat">@@ -79,21 +79,21 @@ ld              LDAP pointer to the desi</span>
<a href="#l27.25"></a><span id="l27.25"> ctrlp           An array of controls obtained from calling</span>
<a href="#l27.26"></a><span id="l27.26">                 ldap_parse_result on the set of results</span>
<a href="#l27.27"></a><span id="l27.27">                 returned by the server</span>
<a href="#l27.28"></a><span id="l27.28"> </span>
<a href="#l27.29"></a><span id="l27.29"> authzid         authorization identity, as defined in</span>
<a href="#l27.30"></a><span id="l27.30">                 RFC 2829, section 9.</span>
<a href="#l27.31"></a><span id="l27.31"> */</span>
<a href="#l27.32"></a><span id="l27.32"> </span>
<a href="#l27.33"></a><span id="l27.33" class="difflineminus">-int LDAP_CALL ldap_parse_authzid_control(LDAP *ld, LDAPControl **ctrlp,</span>
<a href="#l27.34"></a><span id="l27.34" class="difflineminus">-                                         char **authzid) {</span>
<a href="#l27.35"></a><span id="l27.35" class="difflineplus">+int LDAP_CALL ldap_parse_authzid_control(LDAP* ld, LDAPControl** ctrlp,</span>
<a href="#l27.36"></a><span id="l27.36" class="difflineplus">+                                         char** authzid) {</span>
<a href="#l27.37"></a><span id="l27.37">   int i, foundAUTHZIDControl;</span>
<a href="#l27.38"></a><span id="l27.38" class="difflineminus">-  char *authzidp = NULL;</span>
<a href="#l27.39"></a><span id="l27.39" class="difflineminus">-  LDAPControl *AUTHZIDCtrlp = NULL;</span>
<a href="#l27.40"></a><span id="l27.40" class="difflineplus">+  char* authzidp = NULL;</span>
<a href="#l27.41"></a><span id="l27.41" class="difflineplus">+  LDAPControl* AUTHZIDCtrlp = NULL;</span>
<a href="#l27.42"></a><span id="l27.42"> </span>
<a href="#l27.43"></a><span id="l27.43">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l27.44"></a><span id="l27.44">     return (LDAP_PARAM_ERROR);</span>
<a href="#l27.45"></a><span id="l27.45">   }</span>
<a href="#l27.46"></a><span id="l27.46"> </span>
<a href="#l27.47"></a><span id="l27.47">   /* find the control in the list of controls if it exists */</span>
<a href="#l27.48"></a><span id="l27.48">   if (ctrlp == NULL) {</span>
<a href="#l27.49"></a><span id="l27.49">     LDAP_SET_LDERRNO(ld, LDAP_CONTROL_NOT_FOUND, NULL, NULL);</span>
<a href="#l27.50"></a><span id="l27.50" class="difflineat">@@ -123,17 +123,17 @@ int LDAP_CALL ldap_parse_authzid_control</span>
<a href="#l27.51"></a><span id="l27.51">    * defined in [AUTH] section 9, granted to the requestor.  If the bind</span>
<a href="#l27.52"></a><span id="l27.52">    * request resulted in an anonymous association, the controlValue field</span>
<a href="#l27.53"></a><span id="l27.53">    * is a string of zero length.  If the bind request resulted in more</span>
<a href="#l27.54"></a><span id="l27.54">    * than one authzid, the primary authzid is returned in the controlValue</span>
<a href="#l27.55"></a><span id="l27.55">    * field.</span>
<a href="#l27.56"></a><span id="l27.56">    */</span>
<a href="#l27.57"></a><span id="l27.57">   if (AUTHZIDCtrlp &amp;&amp; AUTHZIDCtrlp-&gt;ldctl_value.bv_val &amp;&amp;</span>
<a href="#l27.58"></a><span id="l27.58">       AUTHZIDCtrlp-&gt;ldctl_value.bv_len) {</span>
<a href="#l27.59"></a><span id="l27.59" class="difflineminus">-    authzidp = ((char *)NSLDAPI_MALLOC((AUTHZIDCtrlp-&gt;ldctl_value.bv_len + 1)));</span>
<a href="#l27.60"></a><span id="l27.60" class="difflineplus">+    authzidp = ((char*)NSLDAPI_MALLOC((AUTHZIDCtrlp-&gt;ldctl_value.bv_len + 1)));</span>
<a href="#l27.61"></a><span id="l27.61">     if (authzidp == NULL) {</span>
<a href="#l27.62"></a><span id="l27.62">       LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l27.63"></a><span id="l27.63">       return (LDAP_NO_MEMORY);</span>
<a href="#l27.64"></a><span id="l27.64">     }</span>
<a href="#l27.65"></a><span id="l27.65">     STRLCPY(authzidp, AUTHZIDCtrlp-&gt;ldctl_value.bv_val,</span>
<a href="#l27.66"></a><span id="l27.66">             (AUTHZIDCtrlp-&gt;ldctl_value.bv_len + 1));</span>
<a href="#l27.67"></a><span id="l27.67">     *authzid = authzidp;</span>
<a href="#l27.68"></a><span id="l27.68">   } else {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/bind.c</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/bind.c</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -54,17 +54,17 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l28.4"></a><span id="l28.4">  * has a valid tgt for now.  ldap_result() should be called to find out the</span>
<a href="#l28.5"></a><span id="l28.5">  * outcome of the bind request.</span>
<a href="#l28.6"></a><span id="l28.6">  *</span>
<a href="#l28.7"></a><span id="l28.7">  * Example:</span>
<a href="#l28.8"></a><span id="l28.8">  * ldap_bind(ld, &quot;cn=manager, o=university of michigan, c=us&quot;, &quot;secret&quot;,</span>
<a href="#l28.9"></a><span id="l28.9">  *           LDAP_AUTH_SIMPLE)</span>
<a href="#l28.10"></a><span id="l28.10">  */</span>
<a href="#l28.11"></a><span id="l28.11"> </span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-int LDAP_CALL ldap_bind(LDAP *ld, const char *dn, const char *passwd,</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+int LDAP_CALL ldap_bind(LDAP* ld, const char* dn, const char* passwd,</span>
<a href="#l28.14"></a><span id="l28.14">                         int authmethod) {</span>
<a href="#l28.15"></a><span id="l28.15">   /*</span>
<a href="#l28.16"></a><span id="l28.16">    * The bind request looks like this:</span>
<a href="#l28.17"></a><span id="l28.17">    * BindRequest ::= SEQUENCE {</span>
<a href="#l28.18"></a><span id="l28.18">    *   version INTEGER,</span>
<a href="#l28.19"></a><span id="l28.19">    *   name DistinguishedName,   -- who</span>
<a href="#l28.20"></a><span id="l28.20">    *   authentication CHOICE {</span>
<a href="#l28.21"></a><span id="l28.21">    *     simple [0] OCTET STRING -- passwd</span>
<a href="#l28.22"></a><span id="l28.22" class="difflineat">@@ -98,36 +98,36 @@ int LDAP_CALL ldap_bind(LDAP *ld, const </span>
<a href="#l28.23"></a><span id="l28.23">  * user already has a valid tgt for now.</span>
<a href="#l28.24"></a><span id="l28.24">  *</span>
<a href="#l28.25"></a><span id="l28.25">  * Examples:</span>
<a href="#l28.26"></a><span id="l28.26">  * ldap_bind_s(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l28.27"></a><span id="l28.27">  *             &quot;secret&quot;, LDAP_AUTH_SIMPLE)</span>
<a href="#l28.28"></a><span id="l28.28">  * ldap_bind_s(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l28.29"></a><span id="l28.29">  *             NULL, LDAP_AUTH_KRBV4)</span>
<a href="#l28.30"></a><span id="l28.30">  */</span>
<a href="#l28.31"></a><span id="l28.31" class="difflineminus">-int LDAP_CALL ldap_bind_s(LDAP *ld, const char *dn, const char *passwd,</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+int LDAP_CALL ldap_bind_s(LDAP* ld, const char* dn, const char* passwd,</span>
<a href="#l28.33"></a><span id="l28.33">                           int authmethod) {</span>
<a href="#l28.34"></a><span id="l28.34">   int err;</span>
<a href="#l28.35"></a><span id="l28.35"> </span>
<a href="#l28.36"></a><span id="l28.36">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_bind_s\n&quot;, 0, 0, 0);</span>
<a href="#l28.37"></a><span id="l28.37"> </span>
<a href="#l28.38"></a><span id="l28.38">   switch (authmethod) {</span>
<a href="#l28.39"></a><span id="l28.39">     case LDAP_AUTH_SIMPLE:</span>
<a href="#l28.40"></a><span id="l28.40">       return (ldap_simple_bind_s(ld, dn, passwd));</span>
<a href="#l28.41"></a><span id="l28.41"> </span>
<a href="#l28.42"></a><span id="l28.42">     default:</span>
<a href="#l28.43"></a><span id="l28.43">       err = LDAP_AUTH_UNKNOWN;</span>
<a href="#l28.44"></a><span id="l28.44">       LDAP_SET_LDERRNO(ld, err, NULL, NULL);</span>
<a href="#l28.45"></a><span id="l28.45">       return (err);</span>
<a href="#l28.46"></a><span id="l28.46">   }</span>
<a href="#l28.47"></a><span id="l28.47"> }</span>
<a href="#l28.48"></a><span id="l28.48"> </span>
<a href="#l28.49"></a><span id="l28.49" class="difflineminus">-void LDAP_CALL ldap_set_rebind_proc(LDAP *ld,</span>
<a href="#l28.50"></a><span id="l28.50" class="difflineminus">-                                    LDAP_REBINDPROC_CALLBACK *rebindproc,</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineminus">-                                    void *arg) {</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineplus">+void LDAP_CALL ldap_set_rebind_proc(LDAP* ld,</span>
<a href="#l28.53"></a><span id="l28.53" class="difflineplus">+                                    LDAP_REBINDPROC_CALLBACK* rebindproc,</span>
<a href="#l28.54"></a><span id="l28.54" class="difflineplus">+                                    void* arg) {</span>
<a href="#l28.55"></a><span id="l28.55">   if (ld == NULL) {</span>
<a href="#l28.56"></a><span id="l28.56">     if (!nsldapi_initialized) {</span>
<a href="#l28.57"></a><span id="l28.57">       nsldapi_initialize_defaults();</span>
<a href="#l28.58"></a><span id="l28.58">     }</span>
<a href="#l28.59"></a><span id="l28.59">     ld = &amp;nsldapi_ld_defaults;</span>
<a href="#l28.60"></a><span id="l28.60">   }</span>
<a href="#l28.61"></a><span id="l28.61"> </span>
<a href="#l28.62"></a><span id="l28.62">   if (NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l28.63"></a><span id="l28.63" class="difflineat">@@ -137,18 +137,18 @@ void LDAP_CALL ldap_set_rebind_proc(LDAP</span>
<a href="#l28.64"></a><span id="l28.64">     LDAP_MUTEX_UNLOCK(ld, LDAP_OPTION_LOCK);</span>
<a href="#l28.65"></a><span id="l28.65">   }</span>
<a href="#l28.66"></a><span id="l28.66"> }</span>
<a href="#l28.67"></a><span id="l28.67"> </span>
<a href="#l28.68"></a><span id="l28.68"> /*</span>
<a href="#l28.69"></a><span id="l28.69">  * return a pointer to the bind DN for the default connection (a copy is</span>
<a href="#l28.70"></a><span id="l28.70">  * not made).  If there is no bind DN available, NULL is returned.</span>
<a href="#l28.71"></a><span id="l28.71">  */</span>
<a href="#l28.72"></a><span id="l28.72" class="difflineminus">-char *nsldapi_get_binddn(LDAP *ld) {</span>
<a href="#l28.73"></a><span id="l28.73" class="difflineminus">-  char *binddn;</span>
<a href="#l28.74"></a><span id="l28.74" class="difflineplus">+char* nsldapi_get_binddn(LDAP* ld) {</span>
<a href="#l28.75"></a><span id="l28.75" class="difflineplus">+  char* binddn;</span>
<a href="#l28.76"></a><span id="l28.76"> </span>
<a href="#l28.77"></a><span id="l28.77">   binddn = NULL; /* default -- assume they are not bound */</span>
<a href="#l28.78"></a><span id="l28.78"> </span>
<a href="#l28.79"></a><span id="l28.79">   LDAP_MUTEX_LOCK(ld, LDAP_CONN_LOCK);</span>
<a href="#l28.80"></a><span id="l28.80">   if (NULL != ld-&gt;ld_defconn &amp;&amp;</span>
<a href="#l28.81"></a><span id="l28.81">       LDAP_CONNST_CONNECTED == ld-&gt;ld_defconn-&gt;lconn_status &amp;&amp;</span>
<a href="#l28.82"></a><span id="l28.82">       ld-&gt;ld_defconn-&gt;lconn_bound) {</span>
<a href="#l28.83"></a><span id="l28.83">     if ((binddn = ld-&gt;ld_defconn-&gt;lconn_binddn) == NULL) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/cache.c</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/cache.c</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -44,17 +44,17 @@</span>
<a href="#l29.4"></a><span id="l29.4"> </span>
<a href="#l29.5"></a><span id="l29.5"> #include &quot;ldap-int.h&quot;</span>
<a href="#l29.6"></a><span id="l29.6"> </span>
<a href="#l29.7"></a><span id="l29.7"> /*</span>
<a href="#l29.8"></a><span id="l29.8">  * ldap_cache_flush - flush part of the LDAP cache. returns an</span>
<a href="#l29.9"></a><span id="l29.9">  * ldap error code (LDAP_SUCCESS, LDAP_NO_SUCH_OBJECT, etc.).</span>
<a href="#l29.10"></a><span id="l29.10">  */</span>
<a href="#l29.11"></a><span id="l29.11"> </span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-int LDAP_CALL ldap_cache_flush(LDAP *ld, const char *dn, const char *filter) {</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+int LDAP_CALL ldap_cache_flush(LDAP* ld, const char* dn, const char* filter) {</span>
<a href="#l29.14"></a><span id="l29.14">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l29.15"></a><span id="l29.15">     return (LDAP_PARAM_ERROR);</span>
<a href="#l29.16"></a><span id="l29.16">   }</span>
<a href="#l29.17"></a><span id="l29.17"> </span>
<a href="#l29.18"></a><span id="l29.18">   if (dn == NULL) {</span>
<a href="#l29.19"></a><span id="l29.19">     dn = &quot;&quot;;</span>
<a href="#l29.20"></a><span id="l29.20">   }</span>
<a href="#l29.21"></a><span id="l29.21"> </span>
<a href="#l29.22"></a><span id="l29.22" class="difflineat">@@ -63,47 +63,47 @@ int LDAP_CALL ldap_cache_flush(LDAP *ld,</span>
<a href="#l29.23"></a><span id="l29.23"> </span>
<a href="#l29.24"></a><span id="l29.24"> /*</span>
<a href="#l29.25"></a><span id="l29.25">  * nsldapi_add_result_to_cache - add an ldap entry we just read off the network</span>
<a href="#l29.26"></a><span id="l29.26">  * to the ldap cache. this routine parses the ber for the entry and</span>
<a href="#l29.27"></a><span id="l29.27">  * constructs the appropriate add request. this routine calls the</span>
<a href="#l29.28"></a><span id="l29.28">  * cache add routine to actually add the entry.</span>
<a href="#l29.29"></a><span id="l29.29">  */</span>
<a href="#l29.30"></a><span id="l29.30"> </span>
<a href="#l29.31"></a><span id="l29.31" class="difflineminus">-void nsldapi_add_result_to_cache(LDAP *ld, LDAPMessage *m) {</span>
<a href="#l29.32"></a><span id="l29.32" class="difflineminus">-  char *dn;</span>
<a href="#l29.33"></a><span id="l29.33" class="difflineminus">-  LDAPMod **mods;</span>
<a href="#l29.34"></a><span id="l29.34" class="difflineplus">+void nsldapi_add_result_to_cache(LDAP* ld, LDAPMessage* m) {</span>
<a href="#l29.35"></a><span id="l29.35" class="difflineplus">+  char* dn;</span>
<a href="#l29.36"></a><span id="l29.36" class="difflineplus">+  LDAPMod** mods;</span>
<a href="#l29.37"></a><span id="l29.37">   int i, max, rc;</span>
<a href="#l29.38"></a><span id="l29.38" class="difflineminus">-  char *a;</span>
<a href="#l29.39"></a><span id="l29.39" class="difflineminus">-  BerElement *ber;</span>
<a href="#l29.40"></a><span id="l29.40" class="difflineplus">+  char* a;</span>
<a href="#l29.41"></a><span id="l29.41" class="difflineplus">+  BerElement* ber;</span>
<a href="#l29.42"></a><span id="l29.42">   char buf[50];</span>
<a href="#l29.43"></a><span id="l29.43">   struct berval bv;</span>
<a href="#l29.44"></a><span id="l29.44" class="difflineminus">-  struct berval *bvp[2];</span>
<a href="#l29.45"></a><span id="l29.45" class="difflineplus">+  struct berval* bvp[2];</span>
<a href="#l29.46"></a><span id="l29.46"> </span>
<a href="#l29.47"></a><span id="l29.47">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;=&gt; nsldapi_add_result_to_cache id %d type %d\n&quot;,</span>
<a href="#l29.48"></a><span id="l29.48">             m-&gt;lm_msgid, m-&gt;lm_msgtype, 0);</span>
<a href="#l29.49"></a><span id="l29.49">   if (m-&gt;lm_msgtype != LDAP_RES_SEARCH_ENTRY || ld-&gt;ld_cache_add == NULL) {</span>
<a href="#l29.50"></a><span id="l29.50">     LDAPDebug(LDAP_DEBUG_TRACE, &quot;&lt;= nsldapi_add_result_to_cache not added\n&quot;, 0,</span>
<a href="#l29.51"></a><span id="l29.51">               0, 0);</span>
<a href="#l29.52"></a><span id="l29.52">     return;</span>
<a href="#l29.53"></a><span id="l29.53">   }</span>
<a href="#l29.54"></a><span id="l29.54"> </span>
<a href="#l29.55"></a><span id="l29.55"> #define GRABSIZE 5</span>
<a href="#l29.56"></a><span id="l29.56"> </span>
<a href="#l29.57"></a><span id="l29.57">   dn = ldap_get_dn(ld, m);</span>
<a href="#l29.58"></a><span id="l29.58" class="difflineminus">-  mods = (LDAPMod **)NSLDAPI_MALLOC(GRABSIZE * sizeof(LDAPMod *));</span>
<a href="#l29.59"></a><span id="l29.59" class="difflineplus">+  mods = (LDAPMod**)NSLDAPI_MALLOC(GRABSIZE * sizeof(LDAPMod*));</span>
<a href="#l29.60"></a><span id="l29.60">   max = GRABSIZE;</span>
<a href="#l29.61"></a><span id="l29.61">   for (i = 0, a = ldap_first_attribute(ld, m, &amp;ber); a != NULL;</span>
<a href="#l29.62"></a><span id="l29.62">        a = ldap_next_attribute(ld, m, ber), i++) {</span>
<a href="#l29.63"></a><span id="l29.63">     if (i == (max - 1)) {</span>
<a href="#l29.64"></a><span id="l29.64">       max += GRABSIZE;</span>
<a href="#l29.65"></a><span id="l29.65" class="difflineminus">-      mods = (LDAPMod **)NSLDAPI_REALLOC(mods, sizeof(LDAPMod *) * max);</span>
<a href="#l29.66"></a><span id="l29.66" class="difflineplus">+      mods = (LDAPMod**)NSLDAPI_REALLOC(mods, sizeof(LDAPMod*) * max);</span>
<a href="#l29.67"></a><span id="l29.67">     }</span>
<a href="#l29.68"></a><span id="l29.68"> </span>
<a href="#l29.69"></a><span id="l29.69" class="difflineminus">-    mods[i] = (LDAPMod *)NSLDAPI_CALLOC(1, sizeof(LDAPMod));</span>
<a href="#l29.70"></a><span id="l29.70" class="difflineplus">+    mods[i] = (LDAPMod*)NSLDAPI_CALLOC(1, sizeof(LDAPMod));</span>
<a href="#l29.71"></a><span id="l29.71">     mods[i]-&gt;mod_op = LDAP_MOD_BVALUES;</span>
<a href="#l29.72"></a><span id="l29.72">     mods[i]-&gt;mod_type = a;</span>
<a href="#l29.73"></a><span id="l29.73">     mods[i]-&gt;mod_bvalues = ldap_get_values_len(ld, m, a);</span>
<a href="#l29.74"></a><span id="l29.74">   }</span>
<a href="#l29.75"></a><span id="l29.75">   if (ber != NULL) {</span>
<a href="#l29.76"></a><span id="l29.76">     ber_free(ber, 0);</span>
<a href="#l29.77"></a><span id="l29.77">   }</span>
<a href="#l29.78"></a><span id="l29.78">   if ((rc = LDAP_GET_LDERRNO(ld, NULL, NULL)) != LDAP_SUCCESS) {</span>
<a href="#l29.79"></a><span id="l29.79" class="difflineat">@@ -113,19 +113,19 @@ void nsldapi_add_result_to_cache(LDAP *l</span>
<a href="#l29.80"></a><span id="l29.80">               ldap_err2string(rc), 0, 0);</span>
<a href="#l29.81"></a><span id="l29.81">     ldap_mods_free(mods, 1);</span>
<a href="#l29.82"></a><span id="l29.82">     return;</span>
<a href="#l29.83"></a><span id="l29.83">   }</span>
<a href="#l29.84"></a><span id="l29.84"> </span>
<a href="#l29.85"></a><span id="l29.85">   /* update special cachedtime attribute */</span>
<a href="#l29.86"></a><span id="l29.86">   if (i == (max - 1)) {</span>
<a href="#l29.87"></a><span id="l29.87">     max++;</span>
<a href="#l29.88"></a><span id="l29.88" class="difflineminus">-    mods = (LDAPMod **)NSLDAPI_REALLOC(mods, sizeof(LDAPMod *) * max);</span>
<a href="#l29.89"></a><span id="l29.89" class="difflineplus">+    mods = (LDAPMod**)NSLDAPI_REALLOC(mods, sizeof(LDAPMod*) * max);</span>
<a href="#l29.90"></a><span id="l29.90">   }</span>
<a href="#l29.91"></a><span id="l29.91" class="difflineminus">-  mods[i] = (LDAPMod *)NSLDAPI_CALLOC(1, sizeof(LDAPMod));</span>
<a href="#l29.92"></a><span id="l29.92" class="difflineplus">+  mods[i] = (LDAPMod*)NSLDAPI_CALLOC(1, sizeof(LDAPMod));</span>
<a href="#l29.93"></a><span id="l29.93">   mods[i]-&gt;mod_op = LDAP_MOD_BVALUES;</span>
<a href="#l29.94"></a><span id="l29.94">   mods[i]-&gt;mod_type = &quot;cachedtime&quot;;</span>
<a href="#l29.95"></a><span id="l29.95">   sprintf(buf, &quot;%ld&quot;, time(NULL));</span>
<a href="#l29.96"></a><span id="l29.96">   bv.bv_val = buf;</span>
<a href="#l29.97"></a><span id="l29.97">   bv.bv_len = strlen(buf);</span>
<a href="#l29.98"></a><span id="l29.98">   bvp[0] = &amp;bv;</span>
<a href="#l29.99"></a><span id="l29.99">   bvp[1] = NULL;</span>
<a href="#l29.100"></a><span id="l29.100">   mods[i]-&gt;mod_bvalues = bvp;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/charray.c</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/charray.c</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -37,109 +37,109 @@</span>
<a href="#l30.4"></a><span id="l30.4"> /* charray.c - routines for dealing with char * arrays */</span>
<a href="#l30.5"></a><span id="l30.5"> </span>
<a href="#l30.6"></a><span id="l30.6"> #include &quot;ldap-int.h&quot;</span>
<a href="#l30.7"></a><span id="l30.7"> </span>
<a href="#l30.8"></a><span id="l30.8"> /*</span>
<a href="#l30.9"></a><span id="l30.9">  * Add s at the end of the array of strings *a.</span>
<a href="#l30.10"></a><span id="l30.10">  * Return 0 for success, -1 for failure.</span>
<a href="#l30.11"></a><span id="l30.11">  */</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineminus">-int LDAP_CALL ldap_charray_add(char ***a, char *s) {</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineplus">+int LDAP_CALL ldap_charray_add(char*** a, char* s) {</span>
<a href="#l30.14"></a><span id="l30.14">   int n;</span>
<a href="#l30.15"></a><span id="l30.15"> </span>
<a href="#l30.16"></a><span id="l30.16">   if (*a == NULL) {</span>
<a href="#l30.17"></a><span id="l30.17" class="difflineminus">-    *a = (char **)NSLDAPI_MALLOC(2 * sizeof(char *));</span>
<a href="#l30.18"></a><span id="l30.18" class="difflineplus">+    *a = (char**)NSLDAPI_MALLOC(2 * sizeof(char*));</span>
<a href="#l30.19"></a><span id="l30.19">     if (*a == NULL) {</span>
<a href="#l30.20"></a><span id="l30.20">       return -1;</span>
<a href="#l30.21"></a><span id="l30.21">     }</span>
<a href="#l30.22"></a><span id="l30.22">     n = 0;</span>
<a href="#l30.23"></a><span id="l30.23">   } else {</span>
<a href="#l30.24"></a><span id="l30.24">     for (n = 0; *a != NULL &amp;&amp; (*a)[n] != NULL; n++) {</span>
<a href="#l30.25"></a><span id="l30.25">       ; /* NULL */</span>
<a href="#l30.26"></a><span id="l30.26">     }</span>
<a href="#l30.27"></a><span id="l30.27"> </span>
<a href="#l30.28"></a><span id="l30.28" class="difflineminus">-    *a = (char **)NSLDAPI_REALLOC((char *)*a, (n + 2) * sizeof(char *));</span>
<a href="#l30.29"></a><span id="l30.29" class="difflineplus">+    *a = (char**)NSLDAPI_REALLOC((char*)*a, (n + 2) * sizeof(char*));</span>
<a href="#l30.30"></a><span id="l30.30">     if (*a == NULL) {</span>
<a href="#l30.31"></a><span id="l30.31">       return -1;</span>
<a href="#l30.32"></a><span id="l30.32">     }</span>
<a href="#l30.33"></a><span id="l30.33">   }</span>
<a href="#l30.34"></a><span id="l30.34"> </span>
<a href="#l30.35"></a><span id="l30.35">   (*a)[n++] = s;</span>
<a href="#l30.36"></a><span id="l30.36">   (*a)[n] = NULL;</span>
<a href="#l30.37"></a><span id="l30.37">   return 0;</span>
<a href="#l30.38"></a><span id="l30.38"> }</span>
<a href="#l30.39"></a><span id="l30.39"> </span>
<a href="#l30.40"></a><span id="l30.40"> /*</span>
<a href="#l30.41"></a><span id="l30.41">  * Add array of strings s at the end of the array of strings *a.</span>
<a href="#l30.42"></a><span id="l30.42">  * Return 0 for success, -1 for failure.</span>
<a href="#l30.43"></a><span id="l30.43">  */</span>
<a href="#l30.44"></a><span id="l30.44" class="difflineminus">-int LDAP_CALL ldap_charray_merge(char ***a, char **s) {</span>
<a href="#l30.45"></a><span id="l30.45" class="difflineplus">+int LDAP_CALL ldap_charray_merge(char*** a, char** s) {</span>
<a href="#l30.46"></a><span id="l30.46">   int i, n, nn;</span>
<a href="#l30.47"></a><span id="l30.47"> </span>
<a href="#l30.48"></a><span id="l30.48">   if ((s == NULL) || (s[0] == NULL)) return 0;</span>
<a href="#l30.49"></a><span id="l30.49"> </span>
<a href="#l30.50"></a><span id="l30.50">   for (n = 0; *a != NULL &amp;&amp; (*a)[n] != NULL; n++) {</span>
<a href="#l30.51"></a><span id="l30.51">     ; /* NULL */</span>
<a href="#l30.52"></a><span id="l30.52">   }</span>
<a href="#l30.53"></a><span id="l30.53">   for (nn = 0; s[nn] != NULL; nn++) {</span>
<a href="#l30.54"></a><span id="l30.54">     ; /* NULL */</span>
<a href="#l30.55"></a><span id="l30.55">   }</span>
<a href="#l30.56"></a><span id="l30.56"> </span>
<a href="#l30.57"></a><span id="l30.57" class="difflineminus">-  *a = (char **)NSLDAPI_REALLOC((char *)*a, (n + nn + 1) * sizeof(char *));</span>
<a href="#l30.58"></a><span id="l30.58" class="difflineplus">+  *a = (char**)NSLDAPI_REALLOC((char*)*a, (n + nn + 1) * sizeof(char*));</span>
<a href="#l30.59"></a><span id="l30.59">   if (*a == NULL) {</span>
<a href="#l30.60"></a><span id="l30.60">     return -1;</span>
<a href="#l30.61"></a><span id="l30.61">   }</span>
<a href="#l30.62"></a><span id="l30.62"> </span>
<a href="#l30.63"></a><span id="l30.63">   for (i = 0; i &lt; nn; i++) {</span>
<a href="#l30.64"></a><span id="l30.64">     (*a)[n + i] = s[i];</span>
<a href="#l30.65"></a><span id="l30.65">   }</span>
<a href="#l30.66"></a><span id="l30.66">   (*a)[n + nn] = NULL;</span>
<a href="#l30.67"></a><span id="l30.67">   return 0;</span>
<a href="#l30.68"></a><span id="l30.68"> }</span>
<a href="#l30.69"></a><span id="l30.69"> </span>
<a href="#l30.70"></a><span id="l30.70" class="difflineminus">-void LDAP_CALL ldap_charray_free(char **array) {</span>
<a href="#l30.71"></a><span id="l30.71" class="difflineminus">-  char **a;</span>
<a href="#l30.72"></a><span id="l30.72" class="difflineplus">+void LDAP_CALL ldap_charray_free(char** array) {</span>
<a href="#l30.73"></a><span id="l30.73" class="difflineplus">+  char** a;</span>
<a href="#l30.74"></a><span id="l30.74"> </span>
<a href="#l30.75"></a><span id="l30.75">   if (array == NULL) {</span>
<a href="#l30.76"></a><span id="l30.76">     return;</span>
<a href="#l30.77"></a><span id="l30.77">   }</span>
<a href="#l30.78"></a><span id="l30.78"> </span>
<a href="#l30.79"></a><span id="l30.79">   for (a = array; *a != NULL; a++) {</span>
<a href="#l30.80"></a><span id="l30.80">     if (*a != NULL) {</span>
<a href="#l30.81"></a><span id="l30.81">       NSLDAPI_FREE(*a);</span>
<a href="#l30.82"></a><span id="l30.82">     }</span>
<a href="#l30.83"></a><span id="l30.83">   }</span>
<a href="#l30.84"></a><span id="l30.84" class="difflineminus">-  NSLDAPI_FREE((char *)array);</span>
<a href="#l30.85"></a><span id="l30.85" class="difflineplus">+  NSLDAPI_FREE((char*)array);</span>
<a href="#l30.86"></a><span id="l30.86"> }</span>
<a href="#l30.87"></a><span id="l30.87"> </span>
<a href="#l30.88"></a><span id="l30.88" class="difflineminus">-int LDAP_CALL ldap_charray_inlist(char **a, char *s) {</span>
<a href="#l30.89"></a><span id="l30.89" class="difflineplus">+int LDAP_CALL ldap_charray_inlist(char** a, char* s) {</span>
<a href="#l30.90"></a><span id="l30.90">   int i;</span>
<a href="#l30.91"></a><span id="l30.91"> </span>
<a href="#l30.92"></a><span id="l30.92">   if (a == NULL) return (0);</span>
<a href="#l30.93"></a><span id="l30.93"> </span>
<a href="#l30.94"></a><span id="l30.94">   for (i = 0; a[i] != NULL; i++) {</span>
<a href="#l30.95"></a><span id="l30.95">     if (strcasecmp(s, a[i]) == 0) {</span>
<a href="#l30.96"></a><span id="l30.96">       return (1);</span>
<a href="#l30.97"></a><span id="l30.97">     }</span>
<a href="#l30.98"></a><span id="l30.98">   }</span>
<a href="#l30.99"></a><span id="l30.99"> </span>
<a href="#l30.100"></a><span id="l30.100">   return (0);</span>
<a href="#l30.101"></a><span id="l30.101"> }</span>
<a href="#l30.102"></a><span id="l30.102"> </span>
<a href="#l30.103"></a><span id="l30.103"> /*</span>
<a href="#l30.104"></a><span id="l30.104">  * Duplicate the array of strings a, return NULL upon any memory failure.</span>
<a href="#l30.105"></a><span id="l30.105">  */</span>
<a href="#l30.106"></a><span id="l30.106" class="difflineminus">-char **LDAP_CALL ldap_charray_dup(char **a) {</span>
<a href="#l30.107"></a><span id="l30.107" class="difflineplus">+char** LDAP_CALL ldap_charray_dup(char** a) {</span>
<a href="#l30.108"></a><span id="l30.108">   int i;</span>
<a href="#l30.109"></a><span id="l30.109" class="difflineminus">-  char **new;</span>
<a href="#l30.110"></a><span id="l30.110" class="difflineplus">+  char** new;</span>
<a href="#l30.111"></a><span id="l30.111"> </span>
<a href="#l30.112"></a><span id="l30.112">   for (i = 0; a[i] != NULL; i++)</span>
<a href="#l30.113"></a><span id="l30.113">     ; /* NULL */</span>
<a href="#l30.114"></a><span id="l30.114"> </span>
<a href="#l30.115"></a><span id="l30.115" class="difflineminus">-  new = (char **)NSLDAPI_MALLOC((i + 1) * sizeof(char *));</span>
<a href="#l30.116"></a><span id="l30.116" class="difflineplus">+  new = (char**)NSLDAPI_MALLOC((i + 1) * sizeof(char*));</span>
<a href="#l30.117"></a><span id="l30.117">   if (new == NULL) {</span>
<a href="#l30.118"></a><span id="l30.118">     return NULL;</span>
<a href="#l30.119"></a><span id="l30.119">   }</span>
<a href="#l30.120"></a><span id="l30.120"> </span>
<a href="#l30.121"></a><span id="l30.121">   for (i = 0; a[i] != NULL; i++) {</span>
<a href="#l30.122"></a><span id="l30.122">     new[i] = nsldapi_strdup(a[i]);</span>
<a href="#l30.123"></a><span id="l30.123">     if (new[i] == NULL) {</span>
<a href="#l30.124"></a><span id="l30.124">       int j;</span>
<a href="#l30.125"></a><span id="l30.125" class="difflineat">@@ -154,36 +154,36 @@ char **LDAP_CALL ldap_charray_dup(char *</span>
<a href="#l30.126"></a><span id="l30.126">   return (new);</span>
<a href="#l30.127"></a><span id="l30.127"> }</span>
<a href="#l30.128"></a><span id="l30.128"> </span>
<a href="#l30.129"></a><span id="l30.129"> /*</span>
<a href="#l30.130"></a><span id="l30.130">  * Tokenize the string str, return NULL upon any memory failure.</span>
<a href="#l30.131"></a><span id="l30.131">  * XXX: on many platforms this function is not thread safe because it</span>
<a href="#l30.132"></a><span id="l30.132">  * uses strtok().</span>
<a href="#l30.133"></a><span id="l30.133">  */</span>
<a href="#l30.134"></a><span id="l30.134" class="difflineminus">-char **LDAP_CALL ldap_str2charray(char *str, char *brkstr)</span>
<a href="#l30.135"></a><span id="l30.135" class="difflineplus">+char** LDAP_CALL ldap_str2charray(char* str, char* brkstr)</span>
<a href="#l30.136"></a><span id="l30.136"> /* This implementation fails if brkstr contains multibyte characters.</span>
<a href="#l30.137"></a><span id="l30.137">    But it works OK if str is UTF-8 and brkstr is 7-bit ASCII.</span>
<a href="#l30.138"></a><span id="l30.138">  */</span>
<a href="#l30.139"></a><span id="l30.139"> {</span>
<a href="#l30.140"></a><span id="l30.140" class="difflineminus">-  char **res;</span>
<a href="#l30.141"></a><span id="l30.141" class="difflineminus">-  char *s;</span>
<a href="#l30.142"></a><span id="l30.142" class="difflineplus">+  char** res;</span>
<a href="#l30.143"></a><span id="l30.143" class="difflineplus">+  char* s;</span>
<a href="#l30.144"></a><span id="l30.144">   int i;</span>
<a href="#l30.145"></a><span id="l30.145"> #ifdef HAVE_STRTOK_R /* defined in portable.h */</span>
<a href="#l30.146"></a><span id="l30.146" class="difflineminus">-  char *lasts;</span>
<a href="#l30.147"></a><span id="l30.147" class="difflineplus">+  char* lasts;</span>
<a href="#l30.148"></a><span id="l30.148"> #endif</span>
<a href="#l30.149"></a><span id="l30.149"> </span>
<a href="#l30.150"></a><span id="l30.150">   i = 1;</span>
<a href="#l30.151"></a><span id="l30.151">   for (s = str; *s; s++) {</span>
<a href="#l30.152"></a><span id="l30.152">     if (strchr(brkstr, *s) != NULL) {</span>
<a href="#l30.153"></a><span id="l30.153">       i++;</span>
<a href="#l30.154"></a><span id="l30.154">     }</span>
<a href="#l30.155"></a><span id="l30.155">   }</span>
<a href="#l30.156"></a><span id="l30.156"> </span>
<a href="#l30.157"></a><span id="l30.157" class="difflineminus">-  res = (char **)NSLDAPI_MALLOC((i + 1) * sizeof(char *));</span>
<a href="#l30.158"></a><span id="l30.158" class="difflineplus">+  res = (char**)NSLDAPI_MALLOC((i + 1) * sizeof(char*));</span>
<a href="#l30.159"></a><span id="l30.159">   if (res == NULL) {</span>
<a href="#l30.160"></a><span id="l30.160">     return NULL;</span>
<a href="#l30.161"></a><span id="l30.161">   }</span>
<a href="#l30.162"></a><span id="l30.162">   i = 0;</span>
<a href="#l30.163"></a><span id="l30.163">   for (s = STRTOK(str, brkstr, &amp;lasts); s != NULL;</span>
<a href="#l30.164"></a><span id="l30.164">        s = STRTOK(NULL, brkstr, &amp;lasts)) {</span>
<a href="#l30.165"></a><span id="l30.165">     res[i++] = nsldapi_strdup(s);</span>
<a href="#l30.166"></a><span id="l30.166">     if (res[i - 1] == NULL) {</span>
<a href="#l30.167"></a><span id="l30.167" class="difflineat">@@ -194,17 +194,17 @@ char **LDAP_CALL ldap_str2charray(char *</span>
<a href="#l30.168"></a><span id="l30.168">       return NULL;</span>
<a href="#l30.169"></a><span id="l30.169">     }</span>
<a href="#l30.170"></a><span id="l30.170">   }</span>
<a href="#l30.171"></a><span id="l30.171">   res[i] = NULL;</span>
<a href="#l30.172"></a><span id="l30.172"> </span>
<a href="#l30.173"></a><span id="l30.173">   return (res);</span>
<a href="#l30.174"></a><span id="l30.174"> }</span>
<a href="#l30.175"></a><span id="l30.175"> </span>
<a href="#l30.176"></a><span id="l30.176" class="difflineminus">-int LDAP_CALL ldap_charray_position(char **a, char *s) {</span>
<a href="#l30.177"></a><span id="l30.177" class="difflineplus">+int LDAP_CALL ldap_charray_position(char** a, char* s) {</span>
<a href="#l30.178"></a><span id="l30.178">   int i;</span>
<a href="#l30.179"></a><span id="l30.179"> </span>
<a href="#l30.180"></a><span id="l30.180">   for (i = 0; a[i] != NULL; i++) {</span>
<a href="#l30.181"></a><span id="l30.181">     if (strcasecmp(s, a[i]) == 0) {</span>
<a href="#l30.182"></a><span id="l30.182">       return (i);</span>
<a href="#l30.183"></a><span id="l30.183">     }</span>
<a href="#l30.184"></a><span id="l30.184">   }</span>
<a href="#l30.185"></a><span id="l30.185"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/charset.c</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/charset.c</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -41,33 +41,33 @@</span>
<a href="#l31.4"></a><span id="l31.4"> /*</span>
<a href="#l31.5"></a><span id="l31.5">  *  charset.c</span>
<a href="#l31.6"></a><span id="l31.6">  */</span>
<a href="#l31.7"></a><span id="l31.7"> </span>
<a href="#l31.8"></a><span id="l31.8"> #include &quot;ldap-int.h&quot;</span>
<a href="#l31.9"></a><span id="l31.9"> </span>
<a href="#l31.10"></a><span id="l31.10"> #ifdef STR_TRANSLATION</span>
<a href="#l31.11"></a><span id="l31.11"> </span>
<a href="#l31.12"></a><span id="l31.12" class="difflineminus">-void ldap_set_string_translators(LDAP *ld, BERTranslateProc encode_proc,</span>
<a href="#l31.13"></a><span id="l31.13" class="difflineplus">+void ldap_set_string_translators(LDAP* ld, BERTranslateProc encode_proc,</span>
<a href="#l31.14"></a><span id="l31.14">                                  BERTranslateProc decode_proc) {</span>
<a href="#l31.15"></a><span id="l31.15">   if (ld == NULL) {</span>
<a href="#l31.16"></a><span id="l31.16">     if (!nsldapi_initialized) {</span>
<a href="#l31.17"></a><span id="l31.17">       nsldapi_initialize_defaults();</span>
<a href="#l31.18"></a><span id="l31.18">     }</span>
<a href="#l31.19"></a><span id="l31.19">     ld = &amp;nsldapi_ld_defaults;</span>
<a href="#l31.20"></a><span id="l31.20">   }</span>
<a href="#l31.21"></a><span id="l31.21"> </span>
<a href="#l31.22"></a><span id="l31.22">   if (NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l31.23"></a><span id="l31.23">     ld-&gt;ld_lber_encode_translate_proc = encode_proc;</span>
<a href="#l31.24"></a><span id="l31.24">     ld-&gt;ld_lber_decode_translate_proc = decode_proc;</span>
<a href="#l31.25"></a><span id="l31.25">   }</span>
<a href="#l31.26"></a><span id="l31.26"> }</span>
<a href="#l31.27"></a><span id="l31.27"> </span>
<a href="#l31.28"></a><span id="l31.28" class="difflineminus">-void ldap_enable_translation(LDAP *ld, LDAPMessage *entry, int enable) {</span>
<a href="#l31.29"></a><span id="l31.29" class="difflineminus">-  char *optionsp;</span>
<a href="#l31.30"></a><span id="l31.30" class="difflineplus">+void ldap_enable_translation(LDAP* ld, LDAPMessage* entry, int enable) {</span>
<a href="#l31.31"></a><span id="l31.31" class="difflineplus">+  char* optionsp;</span>
<a href="#l31.32"></a><span id="l31.32"> </span>
<a href="#l31.33"></a><span id="l31.33">   if (ld == NULL) {</span>
<a href="#l31.34"></a><span id="l31.34">     if (!nsldapi_initialized) {</span>
<a href="#l31.35"></a><span id="l31.35">       nsldapi_initialize_defaults();</span>
<a href="#l31.36"></a><span id="l31.36">     }</span>
<a href="#l31.37"></a><span id="l31.37">     ld = &amp;nsldapi_ld_defaults;</span>
<a href="#l31.38"></a><span id="l31.38">   }</span>
<a href="#l31.39"></a><span id="l31.39"> </span>
<a href="#l31.40"></a><span id="l31.40" class="difflineat">@@ -76,26 +76,26 @@ void ldap_enable_translation(LDAP *ld, L</span>
<a href="#l31.41"></a><span id="l31.41"> </span>
<a href="#l31.42"></a><span id="l31.42">   if (enable) {</span>
<a href="#l31.43"></a><span id="l31.43">     *optionsp |= LBER_OPT_TRANSLATE_STRINGS;</span>
<a href="#l31.44"></a><span id="l31.44">   } else {</span>
<a href="#l31.45"></a><span id="l31.45">     *optionsp &amp;= ~LBER_OPT_TRANSLATE_STRINGS;</span>
<a href="#l31.46"></a><span id="l31.46">   }</span>
<a href="#l31.47"></a><span id="l31.47"> }</span>
<a href="#l31.48"></a><span id="l31.48"> </span>
<a href="#l31.49"></a><span id="l31.49" class="difflineminus">-int ldap_translate_from_t61(LDAP *ld, char **bufp, unsigned long *lenp,</span>
<a href="#l31.50"></a><span id="l31.50" class="difflineplus">+int ldap_translate_from_t61(LDAP* ld, char** bufp, unsigned long* lenp,</span>
<a href="#l31.51"></a><span id="l31.51">                             int free_input) {</span>
<a href="#l31.52"></a><span id="l31.52">   if (ld-&gt;ld_lber_decode_translate_proc == NULL) {</span>
<a href="#l31.53"></a><span id="l31.53">     return (LDAP_SUCCESS);</span>
<a href="#l31.54"></a><span id="l31.54">   }</span>
<a href="#l31.55"></a><span id="l31.55"> </span>
<a href="#l31.56"></a><span id="l31.56">   return ((*ld-&gt;ld_lber_decode_translate_proc)(bufp, lenp, free_input));</span>
<a href="#l31.57"></a><span id="l31.57"> }</span>
<a href="#l31.58"></a><span id="l31.58"> </span>
<a href="#l31.59"></a><span id="l31.59" class="difflineminus">-int ldap_translate_to_t61(LDAP *ld, char **bufp, unsigned long *lenp,</span>
<a href="#l31.60"></a><span id="l31.60" class="difflineplus">+int ldap_translate_to_t61(LDAP* ld, char** bufp, unsigned long* lenp,</span>
<a href="#l31.61"></a><span id="l31.61">                           int free_input) {</span>
<a href="#l31.62"></a><span id="l31.62">   if (ld-&gt;ld_lber_encode_translate_proc == NULL) {</span>
<a href="#l31.63"></a><span id="l31.63">     return (LDAP_SUCCESS);</span>
<a href="#l31.64"></a><span id="l31.64">   }</span>
<a href="#l31.65"></a><span id="l31.65"> </span>
<a href="#l31.66"></a><span id="l31.66">   return ((*ld-&gt;ld_lber_encode_translate_proc)(bufp, lenp, free_input));</span>
<a href="#l31.67"></a><span id="l31.67"> }</span>
<a href="#l31.68"></a><span id="l31.68"> </span>
<a href="#l31.69"></a><span id="l31.69" class="difflineat">@@ -179,25 +179,25 @@ int ldap_translate_to_t61(LDAP *ld, char</span>
<a href="#l31.70"></a><span id="l31.70"> #    endif</span>
<a href="#l31.71"></a><span id="l31.71"> </span>
<a href="#l31.72"></a><span id="l31.72"> typedef unsigned char Byte;</span>
<a href="#l31.73"></a><span id="l31.73"> typedef struct {</span>
<a href="#l31.74"></a><span id="l31.74">   Byte a, b;</span>
<a href="#l31.75"></a><span id="l31.75"> } Couple;</span>
<a href="#l31.76"></a><span id="l31.76"> </span>
<a href="#l31.77"></a><span id="l31.77"> #    ifdef NEEDPROTOS</span>
<a href="#l31.78"></a><span id="l31.78" class="difflineminus">-static Byte *c_to_hh(Byte *o, Byte c);</span>
<a href="#l31.79"></a><span id="l31.79" class="difflineminus">-static Byte *c_to_cc(Byte *o, Couple *cc, Byte c);</span>
<a href="#l31.80"></a><span id="l31.80" class="difflineminus">-static int hh_to_c(Byte *h);</span>
<a href="#l31.81"></a><span id="l31.81" class="difflineminus">-static Byte *cc_to_t61(Byte *o, Byte *s);</span>
<a href="#l31.82"></a><span id="l31.82" class="difflineplus">+static Byte* c_to_hh(Byte* o, Byte c);</span>
<a href="#l31.83"></a><span id="l31.83" class="difflineplus">+static Byte* c_to_cc(Byte* o, Couple* cc, Byte c);</span>
<a href="#l31.84"></a><span id="l31.84" class="difflineplus">+static int hh_to_c(Byte* h);</span>
<a href="#l31.85"></a><span id="l31.85" class="difflineplus">+static Byte* cc_to_t61(Byte* o, Byte* s);</span>
<a href="#l31.86"></a><span id="l31.86"> #    else  /* NEEDPROTOS */</span>
<a href="#l31.87"></a><span id="l31.87" class="difflineminus">-static Byte *c_to_hh();</span>
<a href="#l31.88"></a><span id="l31.88" class="difflineminus">-static Byte *c_to_cc();</span>
<a href="#l31.89"></a><span id="l31.89" class="difflineplus">+static Byte* c_to_hh();</span>
<a href="#l31.90"></a><span id="l31.90" class="difflineplus">+static Byte* c_to_cc();</span>
<a href="#l31.91"></a><span id="l31.91"> static int hh_to_c();</span>
<a href="#l31.92"></a><span id="l31.92" class="difflineminus">-static Byte *cc_to_t61();</span>
<a href="#l31.93"></a><span id="l31.93" class="difflineplus">+static Byte* cc_to_t61();</span>
<a href="#l31.94"></a><span id="l31.94"> #    endif /* NEEDPROTOS */</span>
<a href="#l31.95"></a><span id="l31.95"> </span>
<a href="#l31.96"></a><span id="l31.96"> /*</span>
<a href="#l31.97"></a><span id="l31.97">    Character chosen as base in diacritics alone: NO-BREAK SPACE.</span>
<a href="#l31.98"></a><span id="l31.98">    (The standard say it must be a blank space, 0x20.)</span>
<a href="#l31.99"></a><span id="l31.99"> */</span>
<a href="#l31.100"></a><span id="l31.100"> #    define ALONE 0xA0</span>
<a href="#l31.101"></a><span id="l31.101"> </span>
<a href="#l31.102"></a><span id="l31.102" class="difflineat">@@ -843,64 +843,64 @@ static Couple trans_iso8859_t61[96] = {</span>
<a href="#l31.103"></a><span id="l31.103">     {0xf1, 0},   {0xce, 'i'}, {0xcf, 'c'}, {0xc2, 'e'}, {0xce, 'e'},</span>
<a href="#l31.104"></a><span id="l31.104">     {0xc8, 'e'}, {0xc7, 'e'}, {0xc2, 'i'}, {0xc3, 'i'}, {0xc8, 'i'},</span>
<a href="#l31.105"></a><span id="l31.105">     {0xf3, 0},   {0xcb, 'n'}, {0xc5, 'o'}, {0xc2, 'o'}, {0xc3, 'o'},</span>
<a href="#l31.106"></a><span id="l31.106">     {0xc4, 'o'}, {0xc8, 'o'}, {0xc4, 'u'}, {0xf9, 0},   {0xce, 'u'},</span>
<a href="#l31.107"></a><span id="l31.107">     {0xc2, 'u'}, {0xc3, 'u'}, {0xc8, 'u'}, {0xc2, 'y'}, {0xfc, 0},</span>
<a href="#l31.108"></a><span id="l31.108">     {0xf0, 0}};</span>
<a href="#l31.109"></a><span id="l31.109"> #    endif</span>
<a href="#l31.110"></a><span id="l31.110"> </span>
<a href="#l31.111"></a><span id="l31.111" class="difflineminus">-static Byte *c_to_hh(Byte *o, Byte c) {</span>
<a href="#l31.112"></a><span id="l31.112" class="difflineplus">+static Byte* c_to_hh(Byte* o, Byte c) {</span>
<a href="#l31.113"></a><span id="l31.113">   Byte n;</span>
<a href="#l31.114"></a><span id="l31.114"> </span>
<a href="#l31.115"></a><span id="l31.115">   *o++ = '{';</span>
<a href="#l31.116"></a><span id="l31.116">   *o++ = 'x';</span>
<a href="#l31.117"></a><span id="l31.117">   n = c &gt;&gt; 4;</span>
<a href="#l31.118"></a><span id="l31.118">   *o++ = ((n &lt; 0xA) ? '0' : 'A' - 0xA) + n;</span>
<a href="#l31.119"></a><span id="l31.119">   n = c &amp; 0x0F;</span>
<a href="#l31.120"></a><span id="l31.120">   *o++ = ((n &lt; 0xA) ? '0' : 'A' - 0xA) + n;</span>
<a href="#l31.121"></a><span id="l31.121">   *o++ = '}';</span>
<a href="#l31.122"></a><span id="l31.122">   return o;</span>
<a href="#l31.123"></a><span id="l31.123"> }</span>
<a href="#l31.124"></a><span id="l31.124"> </span>
<a href="#l31.125"></a><span id="l31.125" class="difflineminus">-static Byte *c_to_cc(Byte *o, Couple *cc, Byte c) {</span>
<a href="#l31.126"></a><span id="l31.126" class="difflineplus">+static Byte* c_to_cc(Byte* o, Couple* cc, Byte c) {</span>
<a href="#l31.127"></a><span id="l31.127">   if ((*cc).a != 0) {</span>
<a href="#l31.128"></a><span id="l31.128">     if ((*cc).b == 0)</span>
<a href="#l31.129"></a><span id="l31.129">       *o++ = (*cc).a;</span>
<a href="#l31.130"></a><span id="l31.130">     else {</span>
<a href="#l31.131"></a><span id="l31.131">       *o++ = '{';</span>
<a href="#l31.132"></a><span id="l31.132">       *o++ = (*cc).a;</span>
<a href="#l31.133"></a><span id="l31.133">       *o++ = (*cc).b;</span>
<a href="#l31.134"></a><span id="l31.134">       *o++ = '}';</span>
<a href="#l31.135"></a><span id="l31.135">     }</span>
<a href="#l31.136"></a><span id="l31.136">     return o;</span>
<a href="#l31.137"></a><span id="l31.137">   } else</span>
<a href="#l31.138"></a><span id="l31.138">     return c_to_hh(o, c);</span>
<a href="#l31.139"></a><span id="l31.139"> }</span>
<a href="#l31.140"></a><span id="l31.140"> </span>
<a href="#l31.141"></a><span id="l31.141"> /* --- routine to convert from T.61 to ISO 8859-n --- */</span>
<a href="#l31.142"></a><span id="l31.142"> </span>
<a href="#l31.143"></a><span id="l31.143" class="difflineminus">-int ldap_t61_to_8859(char **bufp, unsigned long *buflenp, int free_input) {</span>
<a href="#l31.144"></a><span id="l31.144" class="difflineplus">+int ldap_t61_to_8859(char** bufp, unsigned long* buflenp, int free_input) {</span>
<a href="#l31.145"></a><span id="l31.145">   Byte *s, *oo, *o;</span>
<a href="#l31.146"></a><span id="l31.146">   unsigned int n;</span>
<a href="#l31.147"></a><span id="l31.147">   int c;</span>
<a href="#l31.148"></a><span id="l31.148">   unsigned long len;</span>
<a href="#l31.149"></a><span id="l31.149" class="difflineminus">-  Couple *cc;</span>
<a href="#l31.150"></a><span id="l31.150" class="difflineplus">+  Couple* cc;</span>
<a href="#l31.151"></a><span id="l31.151"> </span>
<a href="#l31.152"></a><span id="l31.152">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_t61_to_8859 input length: %ld\n&quot;, *buflenp,</span>
<a href="#l31.153"></a><span id="l31.153">             0, 0);</span>
<a href="#l31.154"></a><span id="l31.154"> </span>
<a href="#l31.155"></a><span id="l31.155">   len = *buflenp;</span>
<a href="#l31.156"></a><span id="l31.156" class="difflineminus">-  s = (Byte *)*bufp;</span>
<a href="#l31.157"></a><span id="l31.157" class="difflineplus">+  s = (Byte*)*bufp;</span>
<a href="#l31.158"></a><span id="l31.158"> </span>
<a href="#l31.159"></a><span id="l31.159" class="difflineminus">-  if ((o = oo = (Byte *)NSLDAPI_MALLOC(2 * len + 64)) == NULL) {</span>
<a href="#l31.160"></a><span id="l31.160" class="difflineplus">+  if ((o = oo = (Byte*)NSLDAPI_MALLOC(2 * len + 64)) == NULL) {</span>
<a href="#l31.161"></a><span id="l31.161">     return (1);</span>
<a href="#l31.162"></a><span id="l31.162">   }</span>
<a href="#l31.163"></a><span id="l31.163"> </span>
<a href="#l31.164"></a><span id="l31.164" class="difflineminus">-  while ((char *)s - *(char **)bufp &lt; len) {</span>
<a href="#l31.165"></a><span id="l31.165" class="difflineplus">+  while ((char*)s - *(char**)bufp &lt; len) {</span>
<a href="#l31.166"></a><span id="l31.166">     switch (*s &gt;&gt; 4) {</span>
<a href="#l31.167"></a><span id="l31.167">       case 0xA:</span>
<a href="#l31.168"></a><span id="l31.168">       case 0xB:</span>
<a href="#l31.169"></a><span id="l31.169">         o = c_to_cc(o, &amp;trans_t61a_iso8859[*s - 0xA0], *s);</span>
<a href="#l31.170"></a><span id="l31.170">         s++;</span>
<a href="#l31.171"></a><span id="l31.171">         break;</span>
<a href="#l31.172"></a><span id="l31.172"> </span>
<a href="#l31.173"></a><span id="l31.173">       case 0xD:</span>
<a href="#l31.174"></a><span id="l31.174" class="difflineat">@@ -1069,30 +1069,30 @@ int ldap_t61_to_8859(char **bufp, unsign</span>
<a href="#l31.175"></a><span id="l31.175">       default:</span>
<a href="#l31.176"></a><span id="l31.176">         *o++ = *s++;</span>
<a href="#l31.177"></a><span id="l31.177">     }</span>
<a href="#l31.178"></a><span id="l31.178">   }</span>
<a href="#l31.179"></a><span id="l31.179"> </span>
<a href="#l31.180"></a><span id="l31.180">   len = o - oo;</span>
<a href="#l31.181"></a><span id="l31.181">   o = oo;</span>
<a href="#l31.182"></a><span id="l31.182"> </span>
<a href="#l31.183"></a><span id="l31.183" class="difflineminus">-  if ((oo = (Byte *)NSLDAPI_REALLOC(o, len)) == NULL) {</span>
<a href="#l31.184"></a><span id="l31.184" class="difflineplus">+  if ((oo = (Byte*)NSLDAPI_REALLOC(o, len)) == NULL) {</span>
<a href="#l31.185"></a><span id="l31.185">     NSLDAPI_FREE(o);</span>
<a href="#l31.186"></a><span id="l31.186">     return (1);</span>
<a href="#l31.187"></a><span id="l31.187">   }</span>
<a href="#l31.188"></a><span id="l31.188"> </span>
<a href="#l31.189"></a><span id="l31.189">   if (free_input) {</span>
<a href="#l31.190"></a><span id="l31.190">     NSLDAPI_FREE(*bufp);</span>
<a href="#l31.191"></a><span id="l31.191">   }</span>
<a href="#l31.192"></a><span id="l31.192" class="difflineminus">-  *bufp = (char *)oo;</span>
<a href="#l31.193"></a><span id="l31.193" class="difflineplus">+  *bufp = (char*)oo;</span>
<a href="#l31.194"></a><span id="l31.194">   *buflenp = len;</span>
<a href="#l31.195"></a><span id="l31.195">   return (0);</span>
<a href="#l31.196"></a><span id="l31.196"> }</span>
<a href="#l31.197"></a><span id="l31.197"> </span>
<a href="#l31.198"></a><span id="l31.198" class="difflineminus">-static int hh_to_c(Byte *h) {</span>
<a href="#l31.199"></a><span id="l31.199" class="difflineplus">+static int hh_to_c(Byte* h) {</span>
<a href="#l31.200"></a><span id="l31.200">   Byte c;</span>
<a href="#l31.201"></a><span id="l31.201"> </span>
<a href="#l31.202"></a><span id="l31.202">   if ((*h &gt;= '0') &amp;&amp; (*h &lt;= '9'))</span>
<a href="#l31.203"></a><span id="l31.203">     c = *h++ - '0';</span>
<a href="#l31.204"></a><span id="l31.204">   else if ((*h &gt;= 'A') &amp;&amp; (*h &lt;= 'F'))</span>
<a href="#l31.205"></a><span id="l31.205">     c = *h++ - 'A' + 10;</span>
<a href="#l31.206"></a><span id="l31.206">   else if ((*h &gt;= 'a') &amp;&amp; (*h &lt;= 'f'))</span>
<a href="#l31.207"></a><span id="l31.207">     c = *h++ - 'a' + 10;</span>
<a href="#l31.208"></a><span id="l31.208" class="difflineat">@@ -1108,17 +1108,17 @@ static int hh_to_c(Byte *h) {</span>
<a href="#l31.209"></a><span id="l31.209">   else if ((*h &gt;= 'a') &amp;&amp; (*h &lt;= 'f'))</span>
<a href="#l31.210"></a><span id="l31.210">     c |= *h - 'a' + 10;</span>
<a href="#l31.211"></a><span id="l31.211">   else</span>
<a href="#l31.212"></a><span id="l31.212">     return -1;</span>
<a href="#l31.213"></a><span id="l31.213"> </span>
<a href="#l31.214"></a><span id="l31.214">   return c;</span>
<a href="#l31.215"></a><span id="l31.215"> }</span>
<a href="#l31.216"></a><span id="l31.216"> </span>
<a href="#l31.217"></a><span id="l31.217" class="difflineminus">-static Byte *cc_to_t61(Byte *o, Byte *s) {</span>
<a href="#l31.218"></a><span id="l31.218" class="difflineplus">+static Byte* cc_to_t61(Byte* o, Byte* s) {</span>
<a href="#l31.219"></a><span id="l31.219">   int n, c = 0;</span>
<a href="#l31.220"></a><span id="l31.220"> </span>
<a href="#l31.221"></a><span id="l31.221">   switch (*(s + 1)) {</span>
<a href="#l31.222"></a><span id="l31.222">     case '`':</span>
<a href="#l31.223"></a><span id="l31.223">       c = -1;</span>
<a href="#l31.224"></a><span id="l31.224">       break; /* &lt;grave-accent&gt; */</span>
<a href="#l31.225"></a><span id="l31.225"> </span>
<a href="#l31.226"></a><span id="l31.226">     case '!':</span>
<a href="#l31.227"></a><span id="l31.227" class="difflineat">@@ -1729,33 +1729,33 @@ static Byte *cc_to_t61(Byte *o, Byte *s)</span>
<a href="#l31.228"></a><span id="l31.228"> </span>
<a href="#l31.229"></a><span id="l31.229">   *o++ = n + 0xC0;</span>
<a href="#l31.230"></a><span id="l31.230">   *o++ = (((*s == ' ') || (*s == '\'')) ? ALONE : *s);</span>
<a href="#l31.231"></a><span id="l31.231">   return o;</span>
<a href="#l31.232"></a><span id="l31.232"> }</span>
<a href="#l31.233"></a><span id="l31.233"> </span>
<a href="#l31.234"></a><span id="l31.234"> /* --- routine to convert from ISO 8859-n to T.61 --- */</span>
<a href="#l31.235"></a><span id="l31.235"> </span>
<a href="#l31.236"></a><span id="l31.236" class="difflineminus">-int ldap_8859_to_t61(char **bufp, unsigned long *buflenp, int free_input) {</span>
<a href="#l31.237"></a><span id="l31.237" class="difflineplus">+int ldap_8859_to_t61(char** bufp, unsigned long* buflenp, int free_input) {</span>
<a href="#l31.238"></a><span id="l31.238">   Byte *s, *oo, *o, *aux;</span>
<a href="#l31.239"></a><span id="l31.239">   int c;</span>
<a href="#l31.240"></a><span id="l31.240">   unsigned long len;</span>
<a href="#l31.241"></a><span id="l31.241" class="difflineminus">-  Couple *cc;</span>
<a href="#l31.242"></a><span id="l31.242" class="difflineplus">+  Couple* cc;</span>
<a href="#l31.243"></a><span id="l31.243"> </span>
<a href="#l31.244"></a><span id="l31.244">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_8859_to_t61 input length: %ld\n&quot;, *buflenp,</span>
<a href="#l31.245"></a><span id="l31.245">             0, 0);</span>
<a href="#l31.246"></a><span id="l31.246"> </span>
<a href="#l31.247"></a><span id="l31.247">   len = *buflenp;</span>
<a href="#l31.248"></a><span id="l31.248" class="difflineminus">-  s = (Byte *)*bufp;</span>
<a href="#l31.249"></a><span id="l31.249" class="difflineplus">+  s = (Byte*)*bufp;</span>
<a href="#l31.250"></a><span id="l31.250"> </span>
<a href="#l31.251"></a><span id="l31.251" class="difflineminus">-  if ((o = oo = (Byte *)NSLDAPI_MALLOC(2 * len + 64)) == NULL) {</span>
<a href="#l31.252"></a><span id="l31.252" class="difflineplus">+  if ((o = oo = (Byte*)NSLDAPI_MALLOC(2 * len + 64)) == NULL) {</span>
<a href="#l31.253"></a><span id="l31.253">     return (1);</span>
<a href="#l31.254"></a><span id="l31.254">   }</span>
<a href="#l31.255"></a><span id="l31.255"> </span>
<a href="#l31.256"></a><span id="l31.256" class="difflineminus">-  while ((char *)s - *(char **)bufp &lt; len) {</span>
<a href="#l31.257"></a><span id="l31.257" class="difflineplus">+  while ((char*)s - *(char**)bufp &lt; len) {</span>
<a href="#l31.258"></a><span id="l31.258">     switch (*s &gt;&gt; 5) {</span>
<a href="#l31.259"></a><span id="l31.259">       case 2:</span>
<a href="#l31.260"></a><span id="l31.260">         switch (*s) {</span>
<a href="#l31.261"></a><span id="l31.261">           case '^':</span>
<a href="#l31.262"></a><span id="l31.262">             *o++ = 0xC3;</span>
<a href="#l31.263"></a><span id="l31.263">             *o++ = ALONE;</span>
<a href="#l31.264"></a><span id="l31.264">             s++;</span>
<a href="#l31.265"></a><span id="l31.265">             break;</span>
<a href="#l31.266"></a><span id="l31.266" class="difflineat">@@ -1835,35 +1835,35 @@ int ldap_8859_to_t61(char **bufp, unsign</span>
<a href="#l31.267"></a><span id="l31.267">       default:</span>
<a href="#l31.268"></a><span id="l31.268">         *o++ = *s++;</span>
<a href="#l31.269"></a><span id="l31.269">     }</span>
<a href="#l31.270"></a><span id="l31.270">   }</span>
<a href="#l31.271"></a><span id="l31.271"> </span>
<a href="#l31.272"></a><span id="l31.272">   len = o - oo;</span>
<a href="#l31.273"></a><span id="l31.273">   o = oo;</span>
<a href="#l31.274"></a><span id="l31.274"> </span>
<a href="#l31.275"></a><span id="l31.275" class="difflineminus">-  if ((oo = (Byte *)NSLDAPI_REALLOC(o, len)) == NULL) {</span>
<a href="#l31.276"></a><span id="l31.276" class="difflineplus">+  if ((oo = (Byte*)NSLDAPI_REALLOC(o, len)) == NULL) {</span>
<a href="#l31.277"></a><span id="l31.277">     NSLDAPI_FREE(o);</span>
<a href="#l31.278"></a><span id="l31.278">     return (1);</span>
<a href="#l31.279"></a><span id="l31.279">   }</span>
<a href="#l31.280"></a><span id="l31.280"> </span>
<a href="#l31.281"></a><span id="l31.281">   if (free_input) {</span>
<a href="#l31.282"></a><span id="l31.282">     NSLDAPI_FREE(*bufp);</span>
<a href="#l31.283"></a><span id="l31.283">   }</span>
<a href="#l31.284"></a><span id="l31.284" class="difflineminus">-  *bufp = (char *)oo;</span>
<a href="#l31.285"></a><span id="l31.285" class="difflineplus">+  *bufp = (char*)oo;</span>
<a href="#l31.286"></a><span id="l31.286">   *buflenp = len;</span>
<a href="#l31.287"></a><span id="l31.287">   return (0);</span>
<a href="#l31.288"></a><span id="l31.288"> }</span>
<a href="#l31.289"></a><span id="l31.289"> </span>
<a href="#l31.290"></a><span id="l31.290"> #    ifdef NOT_NEEDED_IN_LIBLDAP /* mcs@umich.edu 12 Oct 1995 */</span>
<a href="#l31.291"></a><span id="l31.291"> /* --- routine to convert &quot;escaped&quot; (\hh) characters to 8bits --- */</span>
<a href="#l31.292"></a><span id="l31.292"> </span>
<a href="#l31.293"></a><span id="l31.293" class="difflineminus">-void convert_escaped_to_8bit(s) char *s;</span>
<a href="#l31.294"></a><span id="l31.294" class="difflineplus">+void convert_escaped_to_8bit(s) char* s;</span>
<a href="#l31.295"></a><span id="l31.295"> {</span>
<a href="#l31.296"></a><span id="l31.296" class="difflineminus">-  char *o = s;</span>
<a href="#l31.297"></a><span id="l31.297" class="difflineplus">+  char* o = s;</span>
<a href="#l31.298"></a><span id="l31.298">   int c;</span>
<a href="#l31.299"></a><span id="l31.299"> </span>
<a href="#l31.300"></a><span id="l31.300">   while (*s) {</span>
<a href="#l31.301"></a><span id="l31.301">     if (*s == '\\') {</span>
<a href="#l31.302"></a><span id="l31.302">       if ((c = hh_to_c(++s)) != -1) {</span>
<a href="#l31.303"></a><span id="l31.303">         *o++ = c;</span>
<a href="#l31.304"></a><span id="l31.304">         s += 2;</span>
<a href="#l31.305"></a><span id="l31.305">       } else</span>
<a href="#l31.306"></a><span id="l31.306" class="difflineat">@@ -1871,22 +1871,22 @@ void convert_escaped_to_8bit(s) char *s;</span>
<a href="#l31.307"></a><span id="l31.307">     } else</span>
<a href="#l31.308"></a><span id="l31.308">       *o++ = *s++;</span>
<a href="#l31.309"></a><span id="l31.309">   }</span>
<a href="#l31.310"></a><span id="l31.310">   *o = '\0';</span>
<a href="#l31.311"></a><span id="l31.311"> }</span>
<a href="#l31.312"></a><span id="l31.312"> </span>
<a href="#l31.313"></a><span id="l31.313"> /* --- routine to convert 8bits characters to the &quot;escaped&quot; (\hh) form --- */</span>
<a href="#l31.314"></a><span id="l31.314"> </span>
<a href="#l31.315"></a><span id="l31.315" class="difflineminus">-char *convert_8bit_to_escaped(s) Byte *s;</span>
<a href="#l31.316"></a><span id="l31.316" class="difflineplus">+char* convert_8bit_to_escaped(s) Byte* s;</span>
<a href="#l31.317"></a><span id="l31.317"> {</span>
<a href="#l31.318"></a><span id="l31.318">   Byte *o, *oo;</span>
<a href="#l31.319"></a><span id="l31.319">   Byte n;</span>
<a href="#l31.320"></a><span id="l31.320"> </span>
<a href="#l31.321"></a><span id="l31.321" class="difflineminus">-  if ((o = oo = (Byte *)NSLDAPI_MALLOC(2 * strlen(s) + 64)) == NULL) {</span>
<a href="#l31.322"></a><span id="l31.322" class="difflineplus">+  if ((o = oo = (Byte*)NSLDAPI_MALLOC(2 * strlen(s) + 64)) == NULL) {</span>
<a href="#l31.323"></a><span id="l31.323">     return (NULL);</span>
<a href="#l31.324"></a><span id="l31.324">   }</span>
<a href="#l31.325"></a><span id="l31.325"> </span>
<a href="#l31.326"></a><span id="l31.326">   while (*s) {</span>
<a href="#l31.327"></a><span id="l31.327">     if (*s &lt; 0x80)</span>
<a href="#l31.328"></a><span id="l31.328">       *o++ = *s++;</span>
<a href="#l31.329"></a><span id="l31.329">     else {</span>
<a href="#l31.330"></a><span id="l31.330">       *o++ = '\\';</span>
<a href="#l31.331"></a><span id="l31.331" class="difflineat">@@ -1895,22 +1895,22 @@ char *convert_8bit_to_escaped(s) Byte *s</span>
<a href="#l31.332"></a><span id="l31.332">       n = *s++ &amp; 0x0F;</span>
<a href="#l31.333"></a><span id="l31.333">       *o++ = ((n &lt; 0xA) ? '0' : 'A' - 0xA) + n;</span>
<a href="#l31.334"></a><span id="l31.334">     }</span>
<a href="#l31.335"></a><span id="l31.335">   }</span>
<a href="#l31.336"></a><span id="l31.336">   *o = '\0';</span>
<a href="#l31.337"></a><span id="l31.337"> </span>
<a href="#l31.338"></a><span id="l31.338">   o = oo;</span>
<a href="#l31.339"></a><span id="l31.339"> </span>
<a href="#l31.340"></a><span id="l31.340" class="difflineminus">-  if ((oo = (Byte *)NSLDAPI_REALLOC(o, strlen(o) + 1)) == NULL) {</span>
<a href="#l31.341"></a><span id="l31.341" class="difflineplus">+  if ((oo = (Byte*)NSLDAPI_REALLOC(o, strlen(o) + 1)) == NULL) {</span>
<a href="#l31.342"></a><span id="l31.342">     NSLDAPI_FREE(o);</span>
<a href="#l31.343"></a><span id="l31.343">     return (NULL);</span>
<a href="#l31.344"></a><span id="l31.344">   }</span>
<a href="#l31.345"></a><span id="l31.345"> </span>
<a href="#l31.346"></a><span id="l31.346" class="difflineminus">-  return ((char *)oo);</span>
<a href="#l31.347"></a><span id="l31.347" class="difflineplus">+  return ((char*)oo);</span>
<a href="#l31.348"></a><span id="l31.348"> }</span>
<a href="#l31.349"></a><span id="l31.349"> </span>
<a href="#l31.350"></a><span id="l31.350"> /* --- routine to convert from T.61 to printable characters --- */</span>
<a href="#l31.351"></a><span id="l31.351"> </span>
<a href="#l31.352"></a><span id="l31.352"> /*</span>
<a href="#l31.353"></a><span id="l31.353">    printable characters [RFC 1488]: 'A'..'Z', 'a'..'z', '0'..'9',</span>
<a href="#l31.354"></a><span id="l31.354">        '\'', '(', ')', '+', ',', '-', '.', '/', ':', '?, ' '.</span>
<a href="#l31.355"></a><span id="l31.355"> </span>
<a href="#l31.356"></a><span id="l31.356" class="difflineat">@@ -1920,23 +1920,23 @@ char *convert_8bit_to_escaped(s) Byte *s</span>
<a href="#l31.357"></a><span id="l31.357"> static Couple last_t61_printabled[32] = {</span>
<a href="#l31.358"></a><span id="l31.358">     {0, 0},     {'A', 'E'}, {'D', 0},   {0, 0},     {'H', 0},   {0, 0},</span>
<a href="#l31.359"></a><span id="l31.359">     {'I', 'J'}, {'L', 0},   {'L', 0},   {'O', 0},   {'O', 'E'}, {0, 0},</span>
<a href="#l31.360"></a><span id="l31.360">     {'T', 'H'}, {'T', 0},   {'N', 'G'}, {'n', 0},   {'k', 0},   {'a', 'e'},</span>
<a href="#l31.361"></a><span id="l31.361">     {'d', 0},   {'d', 0},   {'h', 0},   {'i', 0},   {'i', 'j'}, {'l', 0},</span>
<a href="#l31.362"></a><span id="l31.362">     {'l', 0},   {'o', 0},   {'o', 'e'}, {'s', 's'}, {'t', 'h'}, {'t', 0},</span>
<a href="#l31.363"></a><span id="l31.363">     {'n', 'g'}, {0, 0}};</span>
<a href="#l31.364"></a><span id="l31.364"> </span>
<a href="#l31.365"></a><span id="l31.365" class="difflineminus">-char *t61_printable(s) Byte *s;</span>
<a href="#l31.366"></a><span id="l31.366" class="difflineplus">+char* t61_printable(s) Byte* s;</span>
<a href="#l31.367"></a><span id="l31.367"> {</span>
<a href="#l31.368"></a><span id="l31.368">   Byte *o, *oo;</span>
<a href="#l31.369"></a><span id="l31.369">   Byte n;</span>
<a href="#l31.370"></a><span id="l31.370" class="difflineminus">-  Couple *cc;</span>
<a href="#l31.371"></a><span id="l31.371" class="difflineplus">+  Couple* cc;</span>
<a href="#l31.372"></a><span id="l31.372"> </span>
<a href="#l31.373"></a><span id="l31.373" class="difflineminus">-  if ((o = oo = (Byte *)NSLDAPI_MALLOC(2 * strlen(s) + 64)) == NULL) {</span>
<a href="#l31.374"></a><span id="l31.374" class="difflineplus">+  if ((o = oo = (Byte*)NSLDAPI_MALLOC(2 * strlen(s) + 64)) == NULL) {</span>
<a href="#l31.375"></a><span id="l31.375">     return (NULL);</span>
<a href="#l31.376"></a><span id="l31.376">   }</span>
<a href="#l31.377"></a><span id="l31.377"> </span>
<a href="#l31.378"></a><span id="l31.378">   while (*s) {</span>
<a href="#l31.379"></a><span id="l31.379">     if (((*s &gt;= 'A') &amp;&amp; (*s &lt;= 'Z')) || ((*s &gt;= 'a') &amp;&amp; (*s &lt;= 'z')) ||</span>
<a href="#l31.380"></a><span id="l31.380">         ((*s &gt;= '0') &amp;&amp; (*s &lt;= '9')) || ((*s &gt;= '\'') &amp;&amp; (*s &lt;= ')')) ||</span>
<a href="#l31.381"></a><span id="l31.381">         ((*s &gt;= '+') &amp;&amp; (*s &lt;= '/')) || (*s == '?') || (*s == ' '))</span>
<a href="#l31.382"></a><span id="l31.382">       *o++ = *s++;</span>
<a href="#l31.383"></a><span id="l31.383" class="difflineat">@@ -1981,19 +1981,19 @@ char *t61_printable(s) Byte *s;</span>
<a href="#l31.384"></a><span id="l31.384">       }</span>
<a href="#l31.385"></a><span id="l31.385">       s++;</span>
<a href="#l31.386"></a><span id="l31.386">     }</span>
<a href="#l31.387"></a><span id="l31.387">   }</span>
<a href="#l31.388"></a><span id="l31.388">   *o = '\0';</span>
<a href="#l31.389"></a><span id="l31.389"> </span>
<a href="#l31.390"></a><span id="l31.390">   o = oo;</span>
<a href="#l31.391"></a><span id="l31.391"> </span>
<a href="#l31.392"></a><span id="l31.392" class="difflineminus">-  if ((oo = (Byte *)NSLDAPI_REALLOC(o, strlen(o) + 1)) == NULL) {</span>
<a href="#l31.393"></a><span id="l31.393" class="difflineplus">+  if ((oo = (Byte*)NSLDAPI_REALLOC(o, strlen(o) + 1)) == NULL) {</span>
<a href="#l31.394"></a><span id="l31.394">     NSLDAPI_FREE(o);</span>
<a href="#l31.395"></a><span id="l31.395">     return (NULL);</span>
<a href="#l31.396"></a><span id="l31.396">   }</span>
<a href="#l31.397"></a><span id="l31.397"> </span>
<a href="#l31.398"></a><span id="l31.398" class="difflineminus">-  return ((char *)oo);</span>
<a href="#l31.399"></a><span id="l31.399" class="difflineplus">+  return ((char*)oo);</span>
<a href="#l31.400"></a><span id="l31.400"> }</span>
<a href="#l31.401"></a><span id="l31.401"> #    endif /* NOT_NEEDED_IN_LIBLDAP */ /* mcs@umich.edu 12 Oct 1995 */</span>
<a href="#l31.402"></a><span id="l31.402"> </span>
<a href="#l31.403"></a><span id="l31.403"> #  endif /* LDAP_CHARSET_8859 */</span>
<a href="#l31.404"></a><span id="l31.404"> #endif   /* STR_TRANSLATION */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/cldap.c</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/cldap.c</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -86,69 +86,69 @@ XXX not MT - safe XXX</span>
<a href="#l32.4"></a><span id="l32.4"> struct cldap_retinfo {</span>
<a href="#l32.5"></a><span id="l32.5">   int cri_maxtries;</span>
<a href="#l32.6"></a><span id="l32.6">   int cri_try;</span>
<a href="#l32.7"></a><span id="l32.7">   int cri_useaddr;</span>
<a href="#l32.8"></a><span id="l32.8">   long cri_timeout;</span>
<a href="#l32.9"></a><span id="l32.9"> };</span>
<a href="#l32.10"></a><span id="l32.10"> </span>
<a href="#l32.11"></a><span id="l32.11"> #  ifdef NEEDPROTOS</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-static int add_addr(LDAP *ld, struct sockaddr *sap);</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineminus">-static int cldap_result(LDAP *ld, int msgid, LDAPMessage **res,</span>
<a href="#l32.14"></a><span id="l32.14" class="difflineminus">-                        struct cldap_retinfo *crip, char *base);</span>
<a href="#l32.15"></a><span id="l32.15" class="difflineminus">-static int cldap_parsemsg(LDAP *ld, int msgid, BerElement *ber,</span>
<a href="#l32.16"></a><span id="l32.16" class="difflineminus">-                          LDAPMessage **res, char *base);</span>
<a href="#l32.17"></a><span id="l32.17" class="difflineplus">+static int add_addr(LDAP* ld, struct sockaddr* sap);</span>
<a href="#l32.18"></a><span id="l32.18" class="difflineplus">+static int cldap_result(LDAP* ld, int msgid, LDAPMessage** res,</span>
<a href="#l32.19"></a><span id="l32.19" class="difflineplus">+                        struct cldap_retinfo* crip, char* base);</span>
<a href="#l32.20"></a><span id="l32.20" class="difflineplus">+static int cldap_parsemsg(LDAP* ld, int msgid, BerElement* ber,</span>
<a href="#l32.21"></a><span id="l32.21" class="difflineplus">+                          LDAPMessage** res, char* base);</span>
<a href="#l32.22"></a><span id="l32.22"> #  else  /* NEEDPROTOS */</span>
<a href="#l32.23"></a><span id="l32.23"> static int add_addr();</span>
<a href="#l32.24"></a><span id="l32.24"> static int cldap_result();</span>
<a href="#l32.25"></a><span id="l32.25"> static int cldap_parsemsg();</span>
<a href="#l32.26"></a><span id="l32.26"> #  endif /* NEEDPROTOS */</span>
<a href="#l32.27"></a><span id="l32.27"> </span>
<a href="#l32.28"></a><span id="l32.28"> /*</span>
<a href="#l32.29"></a><span id="l32.29">  * cldap_open - initialize and connect to an ldap server.  A magic cookie to</span>
<a href="#l32.30"></a><span id="l32.30">  * be used for future communication is returned on success, NULL on failure.</span>
<a href="#l32.31"></a><span id="l32.31">  *</span>
<a href="#l32.32"></a><span id="l32.32">  * Example:</span>
<a href="#l32.33"></a><span id="l32.33">  * LDAP  *ld;</span>
<a href="#l32.34"></a><span id="l32.34">  * ld = cldap_open(hostname, port);</span>
<a href="#l32.35"></a><span id="l32.35">  */</span>
<a href="#l32.36"></a><span id="l32.36"> </span>
<a href="#l32.37"></a><span id="l32.37" class="difflineminus">-LDAP *cldap_open(char *host, int port) {</span>
<a href="#l32.38"></a><span id="l32.38" class="difflineplus">+LDAP* cldap_open(char* host, int port) {</span>
<a href="#l32.39"></a><span id="l32.39">   int s;</span>
<a href="#l32.40"></a><span id="l32.40">   ldap_x_in_addr_t address;</span>
<a href="#l32.41"></a><span id="l32.41">   struct sockaddr_in sock;</span>
<a href="#l32.42"></a><span id="l32.42" class="difflineminus">-  struct hostent *hp;</span>
<a href="#l32.43"></a><span id="l32.43" class="difflineminus">-  LDAP *ld;</span>
<a href="#l32.44"></a><span id="l32.44" class="difflineminus">-  char *p;</span>
<a href="#l32.45"></a><span id="l32.45" class="difflineplus">+  struct hostent* hp;</span>
<a href="#l32.46"></a><span id="l32.46" class="difflineplus">+  LDAP* ld;</span>
<a href="#l32.47"></a><span id="l32.47" class="difflineplus">+  char* p;</span>
<a href="#l32.48"></a><span id="l32.48">   int i;</span>
<a href="#l32.49"></a><span id="l32.49"> </span>
<a href="#l32.50"></a><span id="l32.50">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;cldap_open\n&quot;, 0, 0, 0);</span>
<a href="#l32.51"></a><span id="l32.51"> </span>
<a href="#l32.52"></a><span id="l32.52">   if (port == 0) {</span>
<a href="#l32.53"></a><span id="l32.53">     port = LDAP_PORT;</span>
<a href="#l32.54"></a><span id="l32.54">   }</span>
<a href="#l32.55"></a><span id="l32.55"> </span>
<a href="#l32.56"></a><span id="l32.56">   if ((s = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {</span>
<a href="#l32.57"></a><span id="l32.57">     return (NULL);</span>
<a href="#l32.58"></a><span id="l32.58">   }</span>
<a href="#l32.59"></a><span id="l32.59"> </span>
<a href="#l32.60"></a><span id="l32.60">   sock.sin_addr.s_addr = 0;</span>
<a href="#l32.61"></a><span id="l32.61">   sock.sin_family = AF_INET;</span>
<a href="#l32.62"></a><span id="l32.62">   sock.sin_port = 0;</span>
<a href="#l32.63"></a><span id="l32.63" class="difflineminus">-  if (bind(s, (struct sockaddr *)&amp;sock, sizeof(sock)) &lt; 0) {</span>
<a href="#l32.64"></a><span id="l32.64" class="difflineplus">+  if (bind(s, (struct sockaddr*)&amp;sock, sizeof(sock)) &lt; 0) {</span>
<a href="#l32.65"></a><span id="l32.65">     close(s);</span>
<a href="#l32.66"></a><span id="l32.66">     return (NULL);</span>
<a href="#l32.67"></a><span id="l32.67">   }</span>
<a href="#l32.68"></a><span id="l32.68"> </span>
<a href="#l32.69"></a><span id="l32.69">   if ((ld = ldap_init(host, port)) == NULL) {</span>
<a href="#l32.70"></a><span id="l32.70">     close(s);</span>
<a href="#l32.71"></a><span id="l32.71">     return (NULL);</span>
<a href="#l32.72"></a><span id="l32.72">   }</span>
<a href="#l32.73"></a><span id="l32.73">   if ((ld-&gt;ld_sbp-&gt;sb_fromaddr =</span>
<a href="#l32.74"></a><span id="l32.74" class="difflineminus">-           (void *)NSLDAPI_CALLOC(1, sizeof(struct sockaddr))) == NULL) {</span>
<a href="#l32.75"></a><span id="l32.75" class="difflineplus">+           (void*)NSLDAPI_CALLOC(1, sizeof(struct sockaddr))) == NULL) {</span>
<a href="#l32.76"></a><span id="l32.76">     NSLDAPI_FREE(ld);</span>
<a href="#l32.77"></a><span id="l32.77">     close(s);</span>
<a href="#l32.78"></a><span id="l32.78">     return (NULL);</span>
<a href="#l32.79"></a><span id="l32.79">   }</span>
<a href="#l32.80"></a><span id="l32.80">   ld-&gt;ld_sbp-&gt;sb_sd = s;</span>
<a href="#l32.81"></a><span id="l32.81">   ld-&gt;ld_sbp-&gt;sb_naddr = 0;</span>
<a href="#l32.82"></a><span id="l32.82">   ld-&gt;ld_version = LDAP_VERSION2;</span>
<a href="#l32.83"></a><span id="l32.83"> </span>
<a href="#l32.84"></a><span id="l32.84" class="difflineat">@@ -169,43 +169,43 @@ LDAP *cldap_open(char *host, int port) {</span>
<a href="#l32.85"></a><span id="l32.85">       if ((address = inet_addr(host)) == -1) {</span>
<a href="#l32.86"></a><span id="l32.86">         /* XXXmcs: need to use DNS callbacks here XXX */</span>
<a href="#l32.87"></a><span id="l32.87">         XXX if ((hp = gethostbyname(host)) == NULL) {</span>
<a href="#l32.88"></a><span id="l32.88">           LDAP_SET_ERRNO(ld, EHOSTUNREACH);</span>
<a href="#l32.89"></a><span id="l32.89">           continue;</span>
<a href="#l32.90"></a><span id="l32.90">         }</span>
<a href="#l32.91"></a><span id="l32.91"> </span>
<a href="#l32.92"></a><span id="l32.92">         for (i = 0; hp-&gt;h_addr_list[i] != 0; ++i) {</span>
<a href="#l32.93"></a><span id="l32.93" class="difflineminus">-          SAFEMEMCPY((char *)&amp;sock.sin_addr.s_addr, (char *)hp-&gt;h_addr_list[i],</span>
<a href="#l32.94"></a><span id="l32.94" class="difflineplus">+          SAFEMEMCPY((char*)&amp;sock.sin_addr.s_addr, (char*)hp-&gt;h_addr_list[i],</span>
<a href="#l32.95"></a><span id="l32.95">                      sizeof(sock.sin_addr.s_addr));</span>
<a href="#l32.96"></a><span id="l32.96" class="difflineminus">-          if (add_addr(ld, (struct sockaddr *)&amp;sock) &lt; 0) {</span>
<a href="#l32.97"></a><span id="l32.97" class="difflineplus">+          if (add_addr(ld, (struct sockaddr*)&amp;sock) &lt; 0) {</span>
<a href="#l32.98"></a><span id="l32.98">             close(s);</span>
<a href="#l32.99"></a><span id="l32.99">             NSLDAPI_FREE(ld);</span>
<a href="#l32.100"></a><span id="l32.100">             return (NULL);</span>
<a href="#l32.101"></a><span id="l32.101">           }</span>
<a href="#l32.102"></a><span id="l32.102">         }</span>
<a href="#l32.103"></a><span id="l32.103"> </span>
<a href="#l32.104"></a><span id="l32.104">       } else {</span>
<a href="#l32.105"></a><span id="l32.105">         sock.sin_addr.s_addr = address;</span>
<a href="#l32.106"></a><span id="l32.106" class="difflineminus">-        if (add_addr(ld, (struct sockaddr *)&amp;sock) &lt; 0) {</span>
<a href="#l32.107"></a><span id="l32.107" class="difflineplus">+        if (add_addr(ld, (struct sockaddr*)&amp;sock) &lt; 0) {</span>
<a href="#l32.108"></a><span id="l32.108">           close(s);</span>
<a href="#l32.109"></a><span id="l32.109">           NSLDAPI_FREE(ld);</span>
<a href="#l32.110"></a><span id="l32.110">           return (NULL);</span>
<a href="#l32.111"></a><span id="l32.111">         }</span>
<a href="#l32.112"></a><span id="l32.112">       }</span>
<a href="#l32.113"></a><span id="l32.113"> </span>
<a href="#l32.114"></a><span id="l32.114">       if (ld-&gt;ld_host == NULL) {</span>
<a href="#l32.115"></a><span id="l32.115">         ld-&gt;ld_host = nsldapi_strdup(host);</span>
<a href="#l32.116"></a><span id="l32.116">       }</span>
<a href="#l32.117"></a><span id="l32.117">     }</span>
<a href="#l32.118"></a><span id="l32.118"> </span>
<a href="#l32.119"></a><span id="l32.119">   } else {</span>
<a href="#l32.120"></a><span id="l32.120">     address = INADDR_LOOPBACK;</span>
<a href="#l32.121"></a><span id="l32.121">     sock.sin_addr.s_addr = htonl(address);</span>
<a href="#l32.122"></a><span id="l32.122" class="difflineminus">-    if (add_addr(ld, (struct sockaddr *)&amp;sock) &lt; 0) {</span>
<a href="#l32.123"></a><span id="l32.123" class="difflineplus">+    if (add_addr(ld, (struct sockaddr*)&amp;sock) &lt; 0) {</span>
<a href="#l32.124"></a><span id="l32.124">       close(s);</span>
<a href="#l32.125"></a><span id="l32.125">       NSLDAPI_FREE(ld);</span>
<a href="#l32.126"></a><span id="l32.126">       return (NULL);</span>
<a href="#l32.127"></a><span id="l32.127">     }</span>
<a href="#l32.128"></a><span id="l32.128">   }</span>
<a href="#l32.129"></a><span id="l32.129"> </span>
<a href="#l32.130"></a><span id="l32.130">   if (ld-&gt;ld_sbp-&gt;sb_addrs == NULL ||</span>
<a href="#l32.131"></a><span id="l32.131">       (ld-&gt;ld_defconn = nsldapi_new_connection(ld, NULL, 1, 0, 0)) == NULL) {</span>
<a href="#l32.132"></a><span id="l32.132" class="difflineat">@@ -216,33 +216,32 @@ LDAP *cldap_open(char *host, int port) {</span>
<a href="#l32.133"></a><span id="l32.133">   ld-&gt;ld_sbp-&gt;sb_useaddr = ld-&gt;ld_sbp-&gt;sb_addrs[0];</span>
<a href="#l32.134"></a><span id="l32.134">   cldap_setretryinfo(ld, 0, 0);</span>
<a href="#l32.135"></a><span id="l32.135"> </span>
<a href="#l32.136"></a><span id="l32.136"> #  ifdef LDAP_DEBUG</span>
<a href="#l32.137"></a><span id="l32.137">   putchar('\n');</span>
<a href="#l32.138"></a><span id="l32.138">   for (i = 0; i &lt; ld-&gt;ld_sbp-&gt;sb_naddr; ++i) {</span>
<a href="#l32.139"></a><span id="l32.139">     LDAPDebug(</span>
<a href="#l32.140"></a><span id="l32.140">         LDAP_DEBUG_TRACE, &quot;end of cldap_open address %d is %s\n&quot;, i,</span>
<a href="#l32.141"></a><span id="l32.141" class="difflineminus">-        inet_ntoa(((struct sockaddr_in *)ld-&gt;ld_sbp-&gt;sb_addrs[i])-&gt;sin_addr),</span>
<a href="#l32.142"></a><span id="l32.142" class="difflineminus">-        0);</span>
<a href="#l32.143"></a><span id="l32.143" class="difflineplus">+        inet_ntoa(((struct sockaddr_in*)ld-&gt;ld_sbp-&gt;sb_addrs[i])-&gt;sin_addr), 0);</span>
<a href="#l32.144"></a><span id="l32.144">   }</span>
<a href="#l32.145"></a><span id="l32.145"> #  endif</span>
<a href="#l32.146"></a><span id="l32.146"> </span>
<a href="#l32.147"></a><span id="l32.147">   return (ld);</span>
<a href="#l32.148"></a><span id="l32.148"> }</span>
<a href="#l32.149"></a><span id="l32.149"> </span>
<a href="#l32.150"></a><span id="l32.150" class="difflineminus">-void cldap_close(LDAP *ld) { ldap_ld_free(ld, NULL, NULL, 0); }</span>
<a href="#l32.151"></a><span id="l32.151" class="difflineplus">+void cldap_close(LDAP* ld) { ldap_ld_free(ld, NULL, NULL, 0); }</span>
<a href="#l32.152"></a><span id="l32.152"> </span>
<a href="#l32.153"></a><span id="l32.153" class="difflineminus">-void cldap_setretryinfo(LDAP *ld, int tries, int timeout) {</span>
<a href="#l32.154"></a><span id="l32.154" class="difflineplus">+void cldap_setretryinfo(LDAP* ld, int tries, int timeout) {</span>
<a href="#l32.155"></a><span id="l32.155">   ld-&gt;ld_cldaptries = (tries &lt;= 0) ? DEF_CLDAP_TRIES : tries;</span>
<a href="#l32.156"></a><span id="l32.156">   ld-&gt;ld_cldaptimeout = (timeout &lt;= 0) ? DEF_CLDAP_TIMEOUT : timeout;</span>
<a href="#l32.157"></a><span id="l32.157"> }</span>
<a href="#l32.158"></a><span id="l32.158"> </span>
<a href="#l32.159"></a><span id="l32.159" class="difflineminus">-int cldap_search_s(LDAP *ld, char *base, int scope, char *filter, char **attrs,</span>
<a href="#l32.160"></a><span id="l32.160" class="difflineminus">-                   int attrsonly, LDAPMessage **res, char *logdn) {</span>
<a href="#l32.161"></a><span id="l32.161" class="difflineplus">+int cldap_search_s(LDAP* ld, char* base, int scope, char* filter, char** attrs,</span>
<a href="#l32.162"></a><span id="l32.162" class="difflineplus">+                   int attrsonly, LDAPMessage** res, char* logdn) {</span>
<a href="#l32.163"></a><span id="l32.163">   int ret, msgid;</span>
<a href="#l32.164"></a><span id="l32.164">   struct cldap_retinfo cri;</span>
<a href="#l32.165"></a><span id="l32.165"> </span>
<a href="#l32.166"></a><span id="l32.166">   *res = NULLMSG;</span>
<a href="#l32.167"></a><span id="l32.167"> </span>
<a href="#l32.168"></a><span id="l32.168">   (void)memset(&amp;cri, 0, sizeof(cri));</span>
<a href="#l32.169"></a><span id="l32.169"> </span>
<a href="#l32.170"></a><span id="l32.170">   if (logdn != NULL) {</span>
<a href="#l32.171"></a><span id="l32.171" class="difflineat">@@ -254,17 +253,17 @@ int cldap_search_s(LDAP *ld, char *base,</span>
<a href="#l32.172"></a><span id="l32.172">   do {</span>
<a href="#l32.173"></a><span id="l32.173">     if (cri.cri_try != 0) {</span>
<a href="#l32.174"></a><span id="l32.174">       --ld-&gt;ld_msgid; /* use same id as before */</span>
<a href="#l32.175"></a><span id="l32.175">     }</span>
<a href="#l32.176"></a><span id="l32.176">     ld-&gt;ld_sbp-&gt;sb_useaddr = ld-&gt;ld_sbp-&gt;sb_addrs[cri.cri_useaddr];</span>
<a href="#l32.177"></a><span id="l32.177"> </span>
<a href="#l32.178"></a><span id="l32.178">     LDAPDebug(</span>
<a href="#l32.179"></a><span id="l32.179">         LDAP_DEBUG_TRACE, &quot;cldap_search_s try %d (to %s)\n&quot;, cri.cri_try,</span>
<a href="#l32.180"></a><span id="l32.180" class="difflineminus">-        inet_ntoa(((struct sockaddr_in *)ld-&gt;ld_sbp-&gt;sb_useaddr)-&gt;sin_addr), 0);</span>
<a href="#l32.181"></a><span id="l32.181" class="difflineplus">+        inet_ntoa(((struct sockaddr_in*)ld-&gt;ld_sbp-&gt;sb_useaddr)-&gt;sin_addr), 0);</span>
<a href="#l32.182"></a><span id="l32.182"> </span>
<a href="#l32.183"></a><span id="l32.183">     if ((msgid = ldap_search(ld, base, scope, filter, attrs, attrsonly)) ==</span>
<a href="#l32.184"></a><span id="l32.184">         -1) {</span>
<a href="#l32.185"></a><span id="l32.185">       return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l32.186"></a><span id="l32.186">     }</span>
<a href="#l32.187"></a><span id="l32.187"> #  ifndef NO_CACHE</span>
<a href="#l32.188"></a><span id="l32.188">     if (ld-&gt;ld_cache != NULL &amp;&amp; ld-&gt;ld_responses != NULL) {</span>
<a href="#l32.189"></a><span id="l32.189">       LDAPDebug(LDAP_DEBUG_TRACE, &quot;cldap_search_s res from cache\n&quot;, 0, 0, 0);</span>
<a href="#l32.190"></a><span id="l32.190" class="difflineat">@@ -274,50 +273,50 @@ int cldap_search_s(LDAP *ld, char *base,</span>
<a href="#l32.191"></a><span id="l32.191">     }</span>
<a href="#l32.192"></a><span id="l32.192"> #  endif /* NO_CACHE */</span>
<a href="#l32.193"></a><span id="l32.193">     ret = cldap_result(ld, msgid, res, &amp;cri, base);</span>
<a href="#l32.194"></a><span id="l32.194">   } while (ret == -1);</span>
<a href="#l32.195"></a><span id="l32.195"> </span>
<a href="#l32.196"></a><span id="l32.196">   return (ret);</span>
<a href="#l32.197"></a><span id="l32.197"> }</span>
<a href="#l32.198"></a><span id="l32.198"> </span>
<a href="#l32.199"></a><span id="l32.199" class="difflineminus">-static int add_addr(LDAP *ld, struct sockaddr *sap) {</span>
<a href="#l32.200"></a><span id="l32.200" class="difflineplus">+static int add_addr(LDAP* ld, struct sockaddr* sap) {</span>
<a href="#l32.201"></a><span id="l32.201">   struct sockaddr *newsap, **addrs;</span>
<a href="#l32.202"></a><span id="l32.202"> </span>
<a href="#l32.203"></a><span id="l32.203" class="difflineminus">-  if ((newsap = (struct sockaddr *)NSLDAPI_MALLOC(sizeof(struct sockaddr))) ==</span>
<a href="#l32.204"></a><span id="l32.204" class="difflineplus">+  if ((newsap = (struct sockaddr*)NSLDAPI_MALLOC(sizeof(struct sockaddr))) ==</span>
<a href="#l32.205"></a><span id="l32.205">       NULL) {</span>
<a href="#l32.206"></a><span id="l32.206">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l32.207"></a><span id="l32.207">     return (-1);</span>
<a href="#l32.208"></a><span id="l32.208">   }</span>
<a href="#l32.209"></a><span id="l32.209"> </span>
<a href="#l32.210"></a><span id="l32.210">   if (ld-&gt;ld_sbp-&gt;sb_naddr == 0) {</span>
<a href="#l32.211"></a><span id="l32.211" class="difflineminus">-    addrs = (struct sockaddr **)NSLDAPI_MALLOC(sizeof(struct sockaddr *));</span>
<a href="#l32.212"></a><span id="l32.212" class="difflineplus">+    addrs = (struct sockaddr**)NSLDAPI_MALLOC(sizeof(struct sockaddr*));</span>
<a href="#l32.213"></a><span id="l32.213">   } else {</span>
<a href="#l32.214"></a><span id="l32.214" class="difflineminus">-    addrs = (struct sockaddr **)NSLDAPI_REALLOC(</span>
<a href="#l32.215"></a><span id="l32.215" class="difflineplus">+    addrs = (struct sockaddr**)NSLDAPI_REALLOC(</span>
<a href="#l32.216"></a><span id="l32.216">         ld-&gt;ld_sbp-&gt;sb_addrs,</span>
<a href="#l32.217"></a><span id="l32.217" class="difflineminus">-        (ld-&gt;ld_sbp-&gt;sb_naddr + 1) * sizeof(struct sockaddr *));</span>
<a href="#l32.218"></a><span id="l32.218" class="difflineplus">+        (ld-&gt;ld_sbp-&gt;sb_naddr + 1) * sizeof(struct sockaddr*));</span>
<a href="#l32.219"></a><span id="l32.219">   }</span>
<a href="#l32.220"></a><span id="l32.220"> </span>
<a href="#l32.221"></a><span id="l32.221">   if (addrs == NULL) {</span>
<a href="#l32.222"></a><span id="l32.222">     NSLDAPI_FREE(newsap);</span>
<a href="#l32.223"></a><span id="l32.223">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l32.224"></a><span id="l32.224">     return (-1);</span>
<a href="#l32.225"></a><span id="l32.225">   }</span>
<a href="#l32.226"></a><span id="l32.226"> </span>
<a href="#l32.227"></a><span id="l32.227" class="difflineminus">-  SAFEMEMCPY((char *)newsap, (char *)sap, sizeof(struct sockaddr));</span>
<a href="#l32.228"></a><span id="l32.228" class="difflineplus">+  SAFEMEMCPY((char*)newsap, (char*)sap, sizeof(struct sockaddr));</span>
<a href="#l32.229"></a><span id="l32.229">   addrs[ld-&gt;ld_sbp-&gt;sb_naddr++] = newsap;</span>
<a href="#l32.230"></a><span id="l32.230" class="difflineminus">-  ld-&gt;ld_sbp-&gt;sb_addrs = (void **)addrs;</span>
<a href="#l32.231"></a><span id="l32.231" class="difflineplus">+  ld-&gt;ld_sbp-&gt;sb_addrs = (void**)addrs;</span>
<a href="#l32.232"></a><span id="l32.232">   return (0);</span>
<a href="#l32.233"></a><span id="l32.233"> }</span>
<a href="#l32.234"></a><span id="l32.234"> </span>
<a href="#l32.235"></a><span id="l32.235" class="difflineminus">-static int cldap_result(LDAP *ld, int msgid, LDAPMessage **res,</span>
<a href="#l32.236"></a><span id="l32.236" class="difflineminus">-                        struct cldap_retinfo *crip, char *base) {</span>
<a href="#l32.237"></a><span id="l32.237" class="difflineminus">-  Sockbuf *sb = ld-&gt;ld_sbp;</span>
<a href="#l32.238"></a><span id="l32.238" class="difflineplus">+static int cldap_result(LDAP* ld, int msgid, LDAPMessage** res,</span>
<a href="#l32.239"></a><span id="l32.239" class="difflineplus">+                        struct cldap_retinfo* crip, char* base) {</span>
<a href="#l32.240"></a><span id="l32.240" class="difflineplus">+  Sockbuf* sb = ld-&gt;ld_sbp;</span>
<a href="#l32.241"></a><span id="l32.241">   BerElement ber;</span>
<a href="#l32.242"></a><span id="l32.242" class="difflineminus">-  char *logdn;</span>
<a href="#l32.243"></a><span id="l32.243" class="difflineplus">+  char* logdn;</span>
<a href="#l32.244"></a><span id="l32.244">   int ret, fromaddr, i;</span>
<a href="#l32.245"></a><span id="l32.245">   ber_int_t id;</span>
<a href="#l32.246"></a><span id="l32.246">   struct timeval tv;</span>
<a href="#l32.247"></a><span id="l32.247"> </span>
<a href="#l32.248"></a><span id="l32.248">   fromaddr = -1;</span>
<a href="#l32.249"></a><span id="l32.249"> </span>
<a href="#l32.250"></a><span id="l32.250">   if (crip-&gt;cri_try == 0) {</span>
<a href="#l32.251"></a><span id="l32.251">     crip-&gt;cri_maxtries = ld-&gt;ld_cldaptries * sb-&gt;sb_naddr;</span>
<a href="#l32.252"></a><span id="l32.252" class="difflineat">@@ -380,18 +379,18 @@ static int cldap_result(LDAP *ld, int ms</span>
<a href="#l32.253"></a><span id="l32.253">                 &quot;cldap_result: looking for msgid %d; got %ld\n&quot;, msgid, id, 0);</span>
<a href="#l32.254"></a><span id="l32.254">       ret = -1; /* ignore and keep looking */</span>
<a href="#l32.255"></a><span id="l32.255">     } else {</span>
<a href="#l32.256"></a><span id="l32.256">       /*</span>
<a href="#l32.257"></a><span id="l32.257">        * got a result: determine which server it came from</span>
<a href="#l32.258"></a><span id="l32.258">        * decode into ldap message chain</span>
<a href="#l32.259"></a><span id="l32.259">        */</span>
<a href="#l32.260"></a><span id="l32.260">       for (fromaddr = 0; fromaddr &lt; sb-&gt;sb_naddr; ++fromaddr) {</span>
<a href="#l32.261"></a><span id="l32.261" class="difflineminus">-        if (memcmp(&amp;((struct sockaddr_in *)sb-&gt;sb_addrs[fromaddr])-&gt;sin_addr,</span>
<a href="#l32.262"></a><span id="l32.262" class="difflineminus">-                   &amp;((struct sockaddr_in *)sb-&gt;sb_fromaddr)-&gt;sin_addr,</span>
<a href="#l32.263"></a><span id="l32.263" class="difflineplus">+        if (memcmp(&amp;((struct sockaddr_in*)sb-&gt;sb_addrs[fromaddr])-&gt;sin_addr,</span>
<a href="#l32.264"></a><span id="l32.264" class="difflineplus">+                   &amp;((struct sockaddr_in*)sb-&gt;sb_fromaddr)-&gt;sin_addr,</span>
<a href="#l32.265"></a><span id="l32.265">                    sizeof(struct in_addr)) == 0) {</span>
<a href="#l32.266"></a><span id="l32.266">           break;</span>
<a href="#l32.267"></a><span id="l32.267">         }</span>
<a href="#l32.268"></a><span id="l32.268">       }</span>
<a href="#l32.269"></a><span id="l32.269">       ret = cldap_parsemsg(ld, msgid, &amp;ber, res, base);</span>
<a href="#l32.270"></a><span id="l32.270">       NSLDAPI_FREE(ber.ber_buf); /* gack! */</span>
<a href="#l32.271"></a><span id="l32.271">       LDAPDebug(LDAP_DEBUG_TRACE, &quot;cldap_result got result (%d)\n&quot;, ret, 0, 0);</span>
<a href="#l32.272"></a><span id="l32.272">     }</span>
<a href="#l32.273"></a><span id="l32.273" class="difflineat">@@ -413,43 +412,43 @@ static int cldap_result(LDAP *ld, int ms</span>
<a href="#l32.274"></a><span id="l32.274"> </span>
<a href="#l32.275"></a><span id="l32.275">     for (; i &gt;= 0; --i) {</span>
<a href="#l32.276"></a><span id="l32.276">       if (i == fromaddr) {</span>
<a href="#l32.277"></a><span id="l32.277">         continue;</span>
<a href="#l32.278"></a><span id="l32.278">       }</span>
<a href="#l32.279"></a><span id="l32.279">       sb-&gt;sb_useaddr = sb-&gt;sb_addrs[i];</span>
<a href="#l32.280"></a><span id="l32.280">       LDAPDebug(LDAP_DEBUG_TRACE, &quot;cldap_result abandoning id %d (to %s)\n&quot;,</span>
<a href="#l32.281"></a><span id="l32.281">                 msgid,</span>
<a href="#l32.282"></a><span id="l32.282" class="difflineminus">-                inet_ntoa(((struct sockaddr_in *)sb-&gt;sb_useaddr)-&gt;sin_addr), 0);</span>
<a href="#l32.283"></a><span id="l32.283" class="difflineplus">+                inet_ntoa(((struct sockaddr_in*)sb-&gt;sb_useaddr)-&gt;sin_addr), 0);</span>
<a href="#l32.284"></a><span id="l32.284">       (void)ldap_abandon(ld, msgid);</span>
<a href="#l32.285"></a><span id="l32.285">     }</span>
<a href="#l32.286"></a><span id="l32.286">   }</span>
<a href="#l32.287"></a><span id="l32.287"> </span>
<a href="#l32.288"></a><span id="l32.288">   LDAP_SET_LDERRNO(ld, ret, NULL, NULL);</span>
<a href="#l32.289"></a><span id="l32.289">   return (ret);</span>
<a href="#l32.290"></a><span id="l32.290"> }</span>
<a href="#l32.291"></a><span id="l32.291"> </span>
<a href="#l32.292"></a><span id="l32.292" class="difflineminus">-static int cldap_parsemsg(LDAP *ld, int msgid, BerElement *ber,</span>
<a href="#l32.293"></a><span id="l32.293" class="difflineminus">-                          LDAPMessage **res, char *base) {</span>
<a href="#l32.294"></a><span id="l32.294" class="difflineplus">+static int cldap_parsemsg(LDAP* ld, int msgid, BerElement* ber,</span>
<a href="#l32.295"></a><span id="l32.295" class="difflineplus">+                          LDAPMessage** res, char* base) {</span>
<a href="#l32.296"></a><span id="l32.296">   ber_tag_t tag;</span>
<a href="#l32.297"></a><span id="l32.297">   ber_len_t len;</span>
<a href="#l32.298"></a><span id="l32.298">   int baselen, slen, rc;</span>
<a href="#l32.299"></a><span id="l32.299">   char *dn, *p, *cookie;</span>
<a href="#l32.300"></a><span id="l32.300">   LDAPMessage *chain, *prev, *ldm;</span>
<a href="#l32.301"></a><span id="l32.301" class="difflineminus">-  struct berval *bv;</span>
<a href="#l32.302"></a><span id="l32.302" class="difflineplus">+  struct berval* bv;</span>
<a href="#l32.303"></a><span id="l32.303"> </span>
<a href="#l32.304"></a><span id="l32.304">   rc = LDAP_DECODING_ERROR; /* pessimistic */</span>
<a href="#l32.305"></a><span id="l32.305">   ldm = chain = prev = NULLMSG;</span>
<a href="#l32.306"></a><span id="l32.306">   baselen = (base == NULL) ? 0 : strlen(base);</span>
<a href="#l32.307"></a><span id="l32.307">   bv = NULL;</span>
<a href="#l32.308"></a><span id="l32.308"> </span>
<a href="#l32.309"></a><span id="l32.309">   for (tag = ber_first_element(ber, &amp;len, &amp;cookie);</span>
<a href="#l32.310"></a><span id="l32.310">        tag != LBER_ERROR &amp;&amp; tag != LBER_END_OF_SEQOFSET &amp;&amp; rc != LDAP_SUCCESS;</span>
<a href="#l32.311"></a><span id="l32.311">        tag = ber_next_element(ber, &amp;len, cookie)) {</span>
<a href="#l32.312"></a><span id="l32.312" class="difflineminus">-    if ((ldm = (LDAPMessage *)NSLDAPI_CALLOC(1, sizeof(LDAPMessage))) == NULL) {</span>
<a href="#l32.313"></a><span id="l32.313" class="difflineplus">+    if ((ldm = (LDAPMessage*)NSLDAPI_CALLOC(1, sizeof(LDAPMessage))) == NULL) {</span>
<a href="#l32.314"></a><span id="l32.314">       rc = LDAP_NO_MEMORY;</span>
<a href="#l32.315"></a><span id="l32.315">       break; /* return with error */</span>
<a href="#l32.316"></a><span id="l32.316">     } else if ((rc = nsldapi_alloc_ber_with_options(ld, &amp;ldm-&gt;lm_ber)) !=</span>
<a href="#l32.317"></a><span id="l32.317">                LDAP_SUCCESS) {</span>
<a href="#l32.318"></a><span id="l32.318">       break; /* return with error*/</span>
<a href="#l32.319"></a><span id="l32.319">     }</span>
<a href="#l32.320"></a><span id="l32.320">     ldm-&gt;lm_msgid = msgid;</span>
<a href="#l32.321"></a><span id="l32.321">     ldm-&gt;lm_msgtype = tag;</span>
<a href="#l32.322"></a><span id="l32.322" class="difflineat">@@ -473,17 +472,17 @@ static int cldap_parsemsg(LDAP *ld, int </span>
<a href="#l32.323"></a><span id="l32.323">       if (ber_scanf(ber, &quot;{aO&quot;, &amp;dn, &amp;bv) == LBER_ERROR) {</span>
<a href="#l32.324"></a><span id="l32.324">         break; /* return w/error */</span>
<a href="#l32.325"></a><span id="l32.325">       }</span>
<a href="#l32.326"></a><span id="l32.326">       LDAPDebug(LDAP_DEBUG_TRACE, &quot;cldap_parsemsg entry %s\n&quot;, dn, 0, 0);</span>
<a href="#l32.327"></a><span id="l32.327">       if (dn != NULL &amp;&amp; *(dn + (slen = strlen(dn)) - 1) == '*' &amp;&amp; baselen &gt; 0) {</span>
<a href="#l32.328"></a><span id="l32.328">         /*</span>
<a href="#l32.329"></a><span id="l32.329">          * substitute original searchbase for trailing '*'</span>
<a href="#l32.330"></a><span id="l32.330">          */</span>
<a href="#l32.331"></a><span id="l32.331" class="difflineminus">-        if ((p = (char *)NSLDAPI_MALLOC(slen + baselen)) == NULL) {</span>
<a href="#l32.332"></a><span id="l32.332" class="difflineplus">+        if ((p = (char*)NSLDAPI_MALLOC(slen + baselen)) == NULL) {</span>
<a href="#l32.333"></a><span id="l32.333">           rc = LDAP_NO_MEMORY;</span>
<a href="#l32.334"></a><span id="l32.334">           NSLDAPI_FREE(dn);</span>
<a href="#l32.335"></a><span id="l32.335">           break; /* return w/error */</span>
<a href="#l32.336"></a><span id="l32.336">         }</span>
<a href="#l32.337"></a><span id="l32.337">         strcpy(p, dn);</span>
<a href="#l32.338"></a><span id="l32.338">         strcpy(p + slen - 1, base);</span>
<a href="#l32.339"></a><span id="l32.339">         NSLDAPI_FREE(dn);</span>
<a href="#l32.340"></a><span id="l32.340">         dn = p;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/compare.c</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/compare.c</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -53,38 +53,38 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l33.4"></a><span id="l33.4"> /*</span>
<a href="#l33.5"></a><span id="l33.5">  * ldap_compare - perform an ldap compare operation.  The dn</span>
<a href="#l33.6"></a><span id="l33.6">  * of the entry to compare to and the attribute and value to compare (in</span>
<a href="#l33.7"></a><span id="l33.7">  * attr and value) are supplied.  The msgid of the response is returned.</span>
<a href="#l33.8"></a><span id="l33.8">  *</span>
<a href="#l33.9"></a><span id="l33.9">  * Example:</span>
<a href="#l33.10"></a><span id="l33.10">  * ldap_compare(ld, &quot;c=us@cn=bob&quot;, &quot;userPassword&quot;, &quot;secret&quot;)</span>
<a href="#l33.11"></a><span id="l33.11">  */</span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">-int LDAP_CALL ldap_compare(LDAP *ld, const char *dn, const char *attr,</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineminus">-                           const char *value) {</span>
<a href="#l33.14"></a><span id="l33.14" class="difflineplus">+int LDAP_CALL ldap_compare(LDAP* ld, const char* dn, const char* attr,</span>
<a href="#l33.15"></a><span id="l33.15" class="difflineplus">+                           const char* value) {</span>
<a href="#l33.16"></a><span id="l33.16">   int msgid;</span>
<a href="#l33.17"></a><span id="l33.17">   struct berval bv;</span>
<a href="#l33.18"></a><span id="l33.18"> </span>
<a href="#l33.19"></a><span id="l33.19">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_compare\n&quot;, 0, 0, 0);</span>
<a href="#l33.20"></a><span id="l33.20"> </span>
<a href="#l33.21"></a><span id="l33.21" class="difflineminus">-  bv.bv_val = (char *)value;</span>
<a href="#l33.22"></a><span id="l33.22" class="difflineplus">+  bv.bv_val = (char*)value;</span>
<a href="#l33.23"></a><span id="l33.23">   bv.bv_len = (value == NULL) ? 0 : strlen(value);</span>
<a href="#l33.24"></a><span id="l33.24"> </span>
<a href="#l33.25"></a><span id="l33.25">   if (ldap_compare_ext(ld, dn, attr, &amp;bv, NULL, NULL, &amp;msgid) == LDAP_SUCCESS) {</span>
<a href="#l33.26"></a><span id="l33.26">     return (msgid);</span>
<a href="#l33.27"></a><span id="l33.27">   } else {</span>
<a href="#l33.28"></a><span id="l33.28">     return (-1); /* error is in ld handle */</span>
<a href="#l33.29"></a><span id="l33.29">   }</span>
<a href="#l33.30"></a><span id="l33.30"> }</span>
<a href="#l33.31"></a><span id="l33.31"> </span>
<a href="#l33.32"></a><span id="l33.32" class="difflineminus">-int LDAP_CALL ldap_compare_ext(LDAP *ld, const char *dn, const char *attr,</span>
<a href="#l33.33"></a><span id="l33.33" class="difflineminus">-                               const struct berval *bvalue,</span>
<a href="#l33.34"></a><span id="l33.34" class="difflineminus">-                               LDAPControl **serverctrls,</span>
<a href="#l33.35"></a><span id="l33.35" class="difflineminus">-                               LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l33.36"></a><span id="l33.36" class="difflineminus">-  BerElement *ber;</span>
<a href="#l33.37"></a><span id="l33.37" class="difflineplus">+int LDAP_CALL ldap_compare_ext(LDAP* ld, const char* dn, const char* attr,</span>
<a href="#l33.38"></a><span id="l33.38" class="difflineplus">+                               const struct berval* bvalue,</span>
<a href="#l33.39"></a><span id="l33.39" class="difflineplus">+                               LDAPControl** serverctrls,</span>
<a href="#l33.40"></a><span id="l33.40" class="difflineplus">+                               LDAPControl** clientctrls, int* msgidp) {</span>
<a href="#l33.41"></a><span id="l33.41" class="difflineplus">+  BerElement* ber;</span>
<a href="#l33.42"></a><span id="l33.42">   int rc, lderr;</span>
<a href="#l33.43"></a><span id="l33.43"> </span>
<a href="#l33.44"></a><span id="l33.44">   /* The compare request looks like this:</span>
<a href="#l33.45"></a><span id="l33.45">    * CompareRequest ::= SEQUENCE {</span>
<a href="#l33.46"></a><span id="l33.46">    *   entry DistinguishedName,</span>
<a href="#l33.47"></a><span id="l33.47">    *   ava SEQUENCE {</span>
<a href="#l33.48"></a><span id="l33.48">    *     type AttributeType,</span>
<a href="#l33.49"></a><span id="l33.49">    *     value AttributeValue</span>
<a href="#l33.50"></a><span id="l33.50" class="difflineat">@@ -138,42 +138,42 @@ int LDAP_CALL ldap_compare_ext(LDAP *ld,</span>
<a href="#l33.51"></a><span id="l33.51">   }</span>
<a href="#l33.52"></a><span id="l33.52"> </span>
<a href="#l33.53"></a><span id="l33.53">   if ((lderr = nsldapi_put_controls(ld, serverctrls, 1, ber)) != LDAP_SUCCESS) {</span>
<a href="#l33.54"></a><span id="l33.54">     ber_free(ber, 1);</span>
<a href="#l33.55"></a><span id="l33.55">     return (lderr);</span>
<a href="#l33.56"></a><span id="l33.56">   }</span>
<a href="#l33.57"></a><span id="l33.57"> </span>
<a href="#l33.58"></a><span id="l33.58">   /* send the message */</span>
<a href="#l33.59"></a><span id="l33.59" class="difflineminus">-  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_COMPARE, (char *)dn,</span>
<a href="#l33.60"></a><span id="l33.60" class="difflineplus">+  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_COMPARE, (char*)dn,</span>
<a href="#l33.61"></a><span id="l33.61">                                     ber);</span>
<a href="#l33.62"></a><span id="l33.62">   *msgidp = rc;</span>
<a href="#l33.63"></a><span id="l33.63">   return (rc &lt; 0 ? LDAP_GET_LDERRNO(ld, NULL, NULL) : LDAP_SUCCESS);</span>
<a href="#l33.64"></a><span id="l33.64"> }</span>
<a href="#l33.65"></a><span id="l33.65"> </span>
<a href="#l33.66"></a><span id="l33.66" class="difflineminus">-int LDAP_CALL ldap_compare_s(LDAP *ld, const char *dn, const char *attr,</span>
<a href="#l33.67"></a><span id="l33.67" class="difflineminus">-                             const char *value) {</span>
<a href="#l33.68"></a><span id="l33.68" class="difflineplus">+int LDAP_CALL ldap_compare_s(LDAP* ld, const char* dn, const char* attr,</span>
<a href="#l33.69"></a><span id="l33.69" class="difflineplus">+                             const char* value) {</span>
<a href="#l33.70"></a><span id="l33.70">   struct berval bv;</span>
<a href="#l33.71"></a><span id="l33.71"> </span>
<a href="#l33.72"></a><span id="l33.72" class="difflineminus">-  bv.bv_val = (char *)value;</span>
<a href="#l33.73"></a><span id="l33.73" class="difflineplus">+  bv.bv_val = (char*)value;</span>
<a href="#l33.74"></a><span id="l33.74">   bv.bv_len = (value == NULL) ? 0 : strlen(value);</span>
<a href="#l33.75"></a><span id="l33.75"> </span>
<a href="#l33.76"></a><span id="l33.76">   return (ldap_compare_ext_s(ld, dn, attr, &amp;bv, NULL, NULL));</span>
<a href="#l33.77"></a><span id="l33.77"> }</span>
<a href="#l33.78"></a><span id="l33.78"> </span>
<a href="#l33.79"></a><span id="l33.79" class="difflineminus">-int LDAP_CALL ldap_compare_ext_s(LDAP *ld, const char *dn, const char *attr,</span>
<a href="#l33.80"></a><span id="l33.80" class="difflineminus">-                                 const struct berval *bvalue,</span>
<a href="#l33.81"></a><span id="l33.81" class="difflineminus">-                                 LDAPControl **serverctrls,</span>
<a href="#l33.82"></a><span id="l33.82" class="difflineminus">-                                 LDAPControl **clientctrls) {</span>
<a href="#l33.83"></a><span id="l33.83" class="difflineplus">+int LDAP_CALL ldap_compare_ext_s(LDAP* ld, const char* dn, const char* attr,</span>
<a href="#l33.84"></a><span id="l33.84" class="difflineplus">+                                 const struct berval* bvalue,</span>
<a href="#l33.85"></a><span id="l33.85" class="difflineplus">+                                 LDAPControl** serverctrls,</span>
<a href="#l33.86"></a><span id="l33.86" class="difflineplus">+                                 LDAPControl** clientctrls) {</span>
<a href="#l33.87"></a><span id="l33.87">   int err, msgid;</span>
<a href="#l33.88"></a><span id="l33.88" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l33.89"></a><span id="l33.89" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l33.90"></a><span id="l33.90"> </span>
<a href="#l33.91"></a><span id="l33.91">   if ((err = ldap_compare_ext(ld, dn, attr, bvalue, serverctrls, clientctrls,</span>
<a href="#l33.92"></a><span id="l33.92">                               &amp;msgid)) != LDAP_SUCCESS) {</span>
<a href="#l33.93"></a><span id="l33.93">     return (err);</span>
<a href="#l33.94"></a><span id="l33.94">   }</span>
<a href="#l33.95"></a><span id="l33.95"> </span>
<a href="#l33.96"></a><span id="l33.96" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)NULL, &amp;res) == -1) {</span>
<a href="#l33.97"></a><span id="l33.97" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)NULL, &amp;res) == -1) {</span>
<a href="#l33.98"></a><span id="l33.98">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l33.99"></a><span id="l33.99">   }</span>
<a href="#l33.100"></a><span id="l33.100"> </span>
<a href="#l33.101"></a><span id="l33.101">   return (ldap_result2error(ld, res, 1));</span>
<a href="#l33.102"></a><span id="l33.102"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/compat.c</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/compat.c</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -49,50 +49,50 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l34.4"></a><span id="l34.4"> #  endif</span>
<a href="#l34.5"></a><span id="l34.5"> #endif</span>
<a href="#l34.6"></a><span id="l34.6"> </span>
<a href="#l34.7"></a><span id="l34.7"> #include &quot;ldap-int.h&quot;</span>
<a href="#l34.8"></a><span id="l34.8"> </span>
<a href="#l34.9"></a><span id="l34.9"> #if defined(HPUX10) &amp;&amp; defined(_REENTRANT) &amp;&amp; !defined(HPUX11)</span>
<a href="#l34.10"></a><span id="l34.10"> extern int h_errno;</span>
<a href="#l34.11"></a><span id="l34.11"> </span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-struct hostent *nsldapi_compat_gethostbyname_r(const char *name,</span>
<a href="#l34.13"></a><span id="l34.13" class="difflineminus">-                                               struct hostent *result,</span>
<a href="#l34.14"></a><span id="l34.14" class="difflineminus">-                                               char *buffer, int buflen,</span>
<a href="#l34.15"></a><span id="l34.15" class="difflineminus">-                                               int *h_errnop) {</span>
<a href="#l34.16"></a><span id="l34.16" class="difflineminus">-  struct hostent_data *hep;</span>
<a href="#l34.17"></a><span id="l34.17" class="difflineplus">+struct hostent* nsldapi_compat_gethostbyname_r(const char* name,</span>
<a href="#l34.18"></a><span id="l34.18" class="difflineplus">+                                               struct hostent* result,</span>
<a href="#l34.19"></a><span id="l34.19" class="difflineplus">+                                               char* buffer, int buflen,</span>
<a href="#l34.20"></a><span id="l34.20" class="difflineplus">+                                               int* h_errnop) {</span>
<a href="#l34.21"></a><span id="l34.21" class="difflineplus">+  struct hostent_data* hep;</span>
<a href="#l34.22"></a><span id="l34.22"> </span>
<a href="#l34.23"></a><span id="l34.23">   if (buflen &lt; sizeof(struct hostent_data)) { /* sanity check */</span>
<a href="#l34.24"></a><span id="l34.24">     *h_errnop = NO_RECOVERY;                  /* XXX best error code to use? */</span>
<a href="#l34.25"></a><span id="l34.25">     return (NULL);</span>
<a href="#l34.26"></a><span id="l34.26">   }</span>
<a href="#l34.27"></a><span id="l34.27"> </span>
<a href="#l34.28"></a><span id="l34.28" class="difflineminus">-  hep = (struct hostent_data *)buffer;</span>
<a href="#l34.29"></a><span id="l34.29" class="difflineplus">+  hep = (struct hostent_data*)buffer;</span>
<a href="#l34.30"></a><span id="l34.30">   hep-&gt;current = NULL;</span>
<a href="#l34.31"></a><span id="l34.31"> </span>
<a href="#l34.32"></a><span id="l34.32">   if (gethostbyname_r(name, result, hep) == -1) {</span>
<a href="#l34.33"></a><span id="l34.33">     *h_errnop = h_errno; /* XXX don't see anywhere else to get this */</span>
<a href="#l34.34"></a><span id="l34.34">     return NULL;</span>
<a href="#l34.35"></a><span id="l34.35">   }</span>
<a href="#l34.36"></a><span id="l34.36">   return result;</span>
<a href="#l34.37"></a><span id="l34.37"> }</span>
<a href="#l34.38"></a><span id="l34.38"> </span>
<a href="#l34.39"></a><span id="l34.39" class="difflineminus">-char *nsldapi_compat_ctime_r(const time_t *clock, char *buf, int buflen) {</span>
<a href="#l34.40"></a><span id="l34.40" class="difflineplus">+char* nsldapi_compat_ctime_r(const time_t* clock, char* buf, int buflen) {</span>
<a href="#l34.41"></a><span id="l34.41">   NSLDAPI_CTIME1(clock, buf, buflen);</span>
<a href="#l34.42"></a><span id="l34.42">   return buf;</span>
<a href="#l34.43"></a><span id="l34.43"> }</span>
<a href="#l34.44"></a><span id="l34.44"> #endif /* HPUX10 &amp;&amp; _REENTRANT &amp;&amp; !HPUX11 */</span>
<a href="#l34.45"></a><span id="l34.45"> </span>
<a href="#l34.46"></a><span id="l34.46"> #if defined(LINUX) || defined(AIX) || defined(HPUX) || defined(_WINDOWS)</span>
<a href="#l34.47"></a><span id="l34.47"> /*</span>
<a href="#l34.48"></a><span id="l34.48">  * Copies src to the dstsize buffer at dst. The copy will never</span>
<a href="#l34.49"></a><span id="l34.49">  * overflow the destination buffer and the buffer will always be null</span>
<a href="#l34.50"></a><span id="l34.50">  * terminated.</span>
<a href="#l34.51"></a><span id="l34.51">  */</span>
<a href="#l34.52"></a><span id="l34.52" class="difflineminus">-size_t nsldapi_compat_strlcpy(char *dst, const char *src, size_t len) {</span>
<a href="#l34.53"></a><span id="l34.53" class="difflineplus">+size_t nsldapi_compat_strlcpy(char* dst, const char* src, size_t len) {</span>
<a href="#l34.54"></a><span id="l34.54">   size_t slen = strlen(src);</span>
<a href="#l34.55"></a><span id="l34.55">   size_t copied;</span>
<a href="#l34.56"></a><span id="l34.56"> </span>
<a href="#l34.57"></a><span id="l34.57">   if (len == 0) return (slen);</span>
<a href="#l34.58"></a><span id="l34.58"> </span>
<a href="#l34.59"></a><span id="l34.59">   if (slen &gt;= len)</span>
<a href="#l34.60"></a><span id="l34.60">     copied = len - 1;</span>
<a href="#l34.61"></a><span id="l34.61">   else</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/control.c</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/control.c</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -33,29 +33,29 @@</span>
<a href="#l35.4"></a><span id="l35.4">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l35.5"></a><span id="l35.5">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l35.6"></a><span id="l35.6">  *</span>
<a href="#l35.7"></a><span id="l35.7">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l35.8"></a><span id="l35.8"> /* control.c - routines to handle ldapv3 controls */</span>
<a href="#l35.9"></a><span id="l35.9"> </span>
<a href="#l35.10"></a><span id="l35.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l35.11"></a><span id="l35.11"> </span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-static LDAPControl *ldap_control_dup(LDAPControl *ctrl);</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineminus">-static int ldap_control_copy_contents(LDAPControl *ctrl_dst,</span>
<a href="#l35.14"></a><span id="l35.14" class="difflineminus">-                                      LDAPControl *ctrl_src);</span>
<a href="#l35.15"></a><span id="l35.15" class="difflineplus">+static LDAPControl* ldap_control_dup(LDAPControl* ctrl);</span>
<a href="#l35.16"></a><span id="l35.16" class="difflineplus">+static int ldap_control_copy_contents(LDAPControl* ctrl_dst,</span>
<a href="#l35.17"></a><span id="l35.17" class="difflineplus">+                                      LDAPControl* ctrl_src);</span>
<a href="#l35.18"></a><span id="l35.18"> </span>
<a href="#l35.19"></a><span id="l35.19"> /*</span>
<a href="#l35.20"></a><span id="l35.20">  * Append a list of LDAPv3 controls to ber.  If ctrls is NULL, use default</span>
<a href="#l35.21"></a><span id="l35.21">  * set of controls from ld.</span>
<a href="#l35.22"></a><span id="l35.22">  * Return an LDAP error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l35.23"></a><span id="l35.23">  * If closeseq is non-zero, we do an extra ber_put_seq() as well.</span>
<a href="#l35.24"></a><span id="l35.24">  */</span>
<a href="#l35.25"></a><span id="l35.25" class="difflineminus">-int nsldapi_put_controls(LDAP *ld, LDAPControl **ctrls, int closeseq,</span>
<a href="#l35.26"></a><span id="l35.26" class="difflineminus">-                         BerElement *ber) {</span>
<a href="#l35.27"></a><span id="l35.27" class="difflineminus">-  LDAPControl *c;</span>
<a href="#l35.28"></a><span id="l35.28" class="difflineplus">+int nsldapi_put_controls(LDAP* ld, LDAPControl** ctrls, int closeseq,</span>
<a href="#l35.29"></a><span id="l35.29" class="difflineplus">+                         BerElement* ber) {</span>
<a href="#l35.30"></a><span id="l35.30" class="difflineplus">+  LDAPControl* c;</span>
<a href="#l35.31"></a><span id="l35.31">   int rc, i;</span>
<a href="#l35.32"></a><span id="l35.32"> </span>
<a href="#l35.33"></a><span id="l35.33">   rc = LDAP_ENCODING_ERROR; /* the most popular error */</span>
<a href="#l35.34"></a><span id="l35.34"> </span>
<a href="#l35.35"></a><span id="l35.35">   /* if no controls were passed in, use global list from LDAP * */</span>
<a href="#l35.36"></a><span id="l35.36">   LDAP_MUTEX_LOCK(ld, LDAP_CTRL_LOCK);</span>
<a href="#l35.37"></a><span id="l35.37">   if (ctrls == NULL) {</span>
<a href="#l35.38"></a><span id="l35.38">     ctrls = ld-&gt;ld_servercontrols;</span>
<a href="#l35.39"></a><span id="l35.39" class="difflineat">@@ -131,22 +131,22 @@ error_exit:</span>
<a href="#l35.40"></a><span id="l35.40">   LDAP_SET_LDERRNO(ld, rc, NULL, NULL);</span>
<a href="#l35.41"></a><span id="l35.41">   return (rc);</span>
<a href="#l35.42"></a><span id="l35.42"> }</span>
<a href="#l35.43"></a><span id="l35.43"> </span>
<a href="#l35.44"></a><span id="l35.44"> /*</span>
<a href="#l35.45"></a><span id="l35.45">  * Pull controls out of &quot;ber&quot; (if any present) and return them in &quot;controlsp.&quot;</span>
<a href="#l35.46"></a><span id="l35.46">  * Returns an LDAP error code.</span>
<a href="#l35.47"></a><span id="l35.47">  */</span>
<a href="#l35.48"></a><span id="l35.48" class="difflineminus">-int nsldapi_get_controls(BerElement *ber, LDAPControl ***controlsp) {</span>
<a href="#l35.49"></a><span id="l35.49" class="difflineminus">-  LDAPControl *newctrl;</span>
<a href="#l35.50"></a><span id="l35.50" class="difflineplus">+int nsldapi_get_controls(BerElement* ber, LDAPControl*** controlsp) {</span>
<a href="#l35.51"></a><span id="l35.51" class="difflineplus">+  LDAPControl* newctrl;</span>
<a href="#l35.52"></a><span id="l35.52">   ber_tag_t tag;</span>
<a href="#l35.53"></a><span id="l35.53">   ber_len_t len;</span>
<a href="#l35.54"></a><span id="l35.54">   int rc, maxcontrols, curcontrols;</span>
<a href="#l35.55"></a><span id="l35.55" class="difflineminus">-  char *last;</span>
<a href="#l35.56"></a><span id="l35.56" class="difflineplus">+  char* last;</span>
<a href="#l35.57"></a><span id="l35.57"> </span>
<a href="#l35.58"></a><span id="l35.58">   /*</span>
<a href="#l35.59"></a><span id="l35.59">    * Each LDAPMessage can have a set of controls appended</span>
<a href="#l35.60"></a><span id="l35.60">    * to it. Controls are used to extend the functionality</span>
<a href="#l35.61"></a><span id="l35.61">    * of an LDAP operation (e.g., add an attribute size limit</span>
<a href="#l35.62"></a><span id="l35.62">    * to the search operation). These controls look like this:</span>
<a href="#l35.63"></a><span id="l35.63">    *</span>
<a href="#l35.64"></a><span id="l35.64">    * Controls ::= SEQUENCE OF Control</span>
<a href="#l35.65"></a><span id="l35.65" class="difflineat">@@ -192,24 +192,24 @@ int nsldapi_get_controls(BerElement *ber</span>
<a href="#l35.66"></a><span id="l35.66"> </span>
<a href="#l35.67"></a><span id="l35.67">   maxcontrols = curcontrols = 0;</span>
<a href="#l35.68"></a><span id="l35.68">   for (tag = ber_first_element(ber, &amp;len, &amp;last);</span>
<a href="#l35.69"></a><span id="l35.69">        tag != LBER_ERROR &amp;&amp; tag != LBER_END_OF_SEQORSET;</span>
<a href="#l35.70"></a><span id="l35.70">        tag = ber_next_element(ber, &amp;len, last)) {</span>
<a href="#l35.71"></a><span id="l35.71">     if (curcontrols &gt;= maxcontrols - 1) {</span>
<a href="#l35.72"></a><span id="l35.72"> #define CONTROL_GRABSIZE 5</span>
<a href="#l35.73"></a><span id="l35.73">       maxcontrols += CONTROL_GRABSIZE;</span>
<a href="#l35.74"></a><span id="l35.74" class="difflineminus">-      *controlsp = (struct ldapcontrol **)NSLDAPI_REALLOC(</span>
<a href="#l35.75"></a><span id="l35.75" class="difflineminus">-          (char *)*controlsp, maxcontrols * sizeof(struct ldapcontrol *));</span>
<a href="#l35.76"></a><span id="l35.76" class="difflineplus">+      *controlsp = (struct ldapcontrol**)NSLDAPI_REALLOC(</span>
<a href="#l35.77"></a><span id="l35.77" class="difflineplus">+          (char*)*controlsp, maxcontrols * sizeof(struct ldapcontrol*));</span>
<a href="#l35.78"></a><span id="l35.78">       if (*controlsp == NULL) {</span>
<a href="#l35.79"></a><span id="l35.79">         rc = LDAP_NO_MEMORY;</span>
<a href="#l35.80"></a><span id="l35.80">         goto free_and_return;</span>
<a href="#l35.81"></a><span id="l35.81">       }</span>
<a href="#l35.82"></a><span id="l35.82">     }</span>
<a href="#l35.83"></a><span id="l35.83" class="difflineminus">-    if ((newctrl = (struct ldapcontrol *)NSLDAPI_CALLOC(</span>
<a href="#l35.84"></a><span id="l35.84" class="difflineplus">+    if ((newctrl = (struct ldapcontrol*)NSLDAPI_CALLOC(</span>
<a href="#l35.85"></a><span id="l35.85">              1, sizeof(LDAPControl))) == NULL) {</span>
<a href="#l35.86"></a><span id="l35.86">       rc = LDAP_NO_MEMORY;</span>
<a href="#l35.87"></a><span id="l35.87">       goto free_and_return;</span>
<a href="#l35.88"></a><span id="l35.88">     }</span>
<a href="#l35.89"></a><span id="l35.89"> </span>
<a href="#l35.90"></a><span id="l35.90">     (*controlsp)[curcontrols++] = newctrl;</span>
<a href="#l35.91"></a><span id="l35.91">     (*controlsp)[curcontrols] = NULL;</span>
<a href="#l35.92"></a><span id="l35.92"> </span>
<a href="#l35.93"></a><span id="l35.93" class="difflineat">@@ -260,17 +260,17 @@ free_and_return:;</span>
<a href="#l35.94"></a><span id="l35.94">   return (rc);</span>
<a href="#l35.95"></a><span id="l35.95"> }</span>
<a href="#l35.96"></a><span id="l35.96"> </span>
<a href="#l35.97"></a><span id="l35.97"> /*</span>
<a href="#l35.98"></a><span id="l35.98">  * Skips forward in a ber to find a control tag, then calls on</span>
<a href="#l35.99"></a><span id="l35.99">  * nsldapi_get_controls() to parse them into an LDAPControl list.</span>
<a href="#l35.100"></a><span id="l35.100">  * Returns an LDAP error code.</span>
<a href="#l35.101"></a><span id="l35.101">  */</span>
<a href="#l35.102"></a><span id="l35.102" class="difflineminus">-int nsldapi_find_controls(BerElement *ber, LDAPControl ***controlsp) {</span>
<a href="#l35.103"></a><span id="l35.103" class="difflineplus">+int nsldapi_find_controls(BerElement* ber, LDAPControl*** controlsp) {</span>
<a href="#l35.104"></a><span id="l35.104">   ber_tag_t tag;</span>
<a href="#l35.105"></a><span id="l35.105">   ber_len_t len;</span>
<a href="#l35.106"></a><span id="l35.106"> </span>
<a href="#l35.107"></a><span id="l35.107">   if (ber == NULLBER) {</span>
<a href="#l35.108"></a><span id="l35.108">     return (LDAP_DECODING_ERROR);</span>
<a href="#l35.109"></a><span id="l35.109">   }</span>
<a href="#l35.110"></a><span id="l35.110"> </span>
<a href="#l35.111"></a><span id="l35.111">   tag = ber_peek_tag(ber, &amp;len);</span>
<a href="#l35.112"></a><span id="l35.112" class="difflineat">@@ -280,42 +280,42 @@ int nsldapi_find_controls(BerElement *be</span>
<a href="#l35.113"></a><span id="l35.113">     /* Skip ahead to the next sequence */</span>
<a href="#l35.114"></a><span id="l35.114">     ber-&gt;ber_ptr += len;</span>
<a href="#l35.115"></a><span id="l35.115">     tag = ber_peek_tag(ber, &amp;len);</span>
<a href="#l35.116"></a><span id="l35.116">   }</span>
<a href="#l35.117"></a><span id="l35.117"> </span>
<a href="#l35.118"></a><span id="l35.118">   return (nsldapi_get_controls(ber, controlsp));</span>
<a href="#l35.119"></a><span id="l35.119"> }</span>
<a href="#l35.120"></a><span id="l35.120"> </span>
<a href="#l35.121"></a><span id="l35.121" class="difflineminus">-void LDAP_CALL ldap_control_free(LDAPControl *ctrl) {</span>
<a href="#l35.122"></a><span id="l35.122" class="difflineplus">+void LDAP_CALL ldap_control_free(LDAPControl* ctrl) {</span>
<a href="#l35.123"></a><span id="l35.123">   if (ctrl != NULL) {</span>
<a href="#l35.124"></a><span id="l35.124">     if (ctrl-&gt;ldctl_oid != NULL) {</span>
<a href="#l35.125"></a><span id="l35.125">       NSLDAPI_FREE(ctrl-&gt;ldctl_oid);</span>
<a href="#l35.126"></a><span id="l35.126">     }</span>
<a href="#l35.127"></a><span id="l35.127">     if (ctrl-&gt;ldctl_value.bv_val != NULL) {</span>
<a href="#l35.128"></a><span id="l35.128">       NSLDAPI_FREE(ctrl-&gt;ldctl_value.bv_val);</span>
<a href="#l35.129"></a><span id="l35.129">     }</span>
<a href="#l35.130"></a><span id="l35.130" class="difflineminus">-    NSLDAPI_FREE((char *)ctrl);</span>
<a href="#l35.131"></a><span id="l35.131" class="difflineplus">+    NSLDAPI_FREE((char*)ctrl);</span>
<a href="#l35.132"></a><span id="l35.132">   }</span>
<a href="#l35.133"></a><span id="l35.133"> }</span>
<a href="#l35.134"></a><span id="l35.134"> </span>
<a href="#l35.135"></a><span id="l35.135" class="difflineminus">-void LDAP_CALL ldap_controls_free(LDAPControl **ctrls) {</span>
<a href="#l35.136"></a><span id="l35.136" class="difflineplus">+void LDAP_CALL ldap_controls_free(LDAPControl** ctrls) {</span>
<a href="#l35.137"></a><span id="l35.137">   int i;</span>
<a href="#l35.138"></a><span id="l35.138"> </span>
<a href="#l35.139"></a><span id="l35.139">   if (ctrls != NULL) {</span>
<a href="#l35.140"></a><span id="l35.140">     for (i = 0; ctrls[i] != NULL; i++) {</span>
<a href="#l35.141"></a><span id="l35.141">       ldap_control_free(ctrls[i]);</span>
<a href="#l35.142"></a><span id="l35.142">     }</span>
<a href="#l35.143"></a><span id="l35.143" class="difflineminus">-    NSLDAPI_FREE((char *)ctrls);</span>
<a href="#l35.144"></a><span id="l35.144" class="difflineplus">+    NSLDAPI_FREE((char*)ctrls);</span>
<a href="#l35.145"></a><span id="l35.145">   }</span>
<a href="#l35.146"></a><span id="l35.146"> }</span>
<a href="#l35.147"></a><span id="l35.147"> </span>
<a href="#l35.148"></a><span id="l35.148" class="difflineminus">-LDAPControl *LDAP_CALL ldap_find_control(const char *oid, LDAPControl **ctrls) {</span>
<a href="#l35.149"></a><span id="l35.149" class="difflineplus">+LDAPControl* LDAP_CALL ldap_find_control(const char* oid, LDAPControl** ctrls) {</span>
<a href="#l35.150"></a><span id="l35.150">   int i, foundControl;</span>
<a href="#l35.151"></a><span id="l35.151" class="difflineminus">-  LDAPControl *Ctrlp = NULL;</span>
<a href="#l35.152"></a><span id="l35.152" class="difflineplus">+  LDAPControl* Ctrlp = NULL;</span>
<a href="#l35.153"></a><span id="l35.153"> </span>
<a href="#l35.154"></a><span id="l35.154">   /* find the control in the list of controls if it exists */</span>
<a href="#l35.155"></a><span id="l35.155">   if (ctrls == NULL) {</span>
<a href="#l35.156"></a><span id="l35.156">     return (NULL);</span>
<a href="#l35.157"></a><span id="l35.157">   }</span>
<a href="#l35.158"></a><span id="l35.158">   foundControl = 0;</span>
<a href="#l35.159"></a><span id="l35.159">   for (i = 0; ((ctrls[i] != NULL) &amp;&amp; (!foundControl)); i++) {</span>
<a href="#l35.160"></a><span id="l35.160">     foundControl = !strcmp(ctrls[i]-&gt;ldctl_oid, oid);</span>
<a href="#l35.161"></a><span id="l35.161" class="difflineat">@@ -371,35 +371,35 @@ ldap_control_append( LDAPControl **ctrl_</span>
<a href="#l35.162"></a><span id="l35.162"> }</span>
<a href="#l35.163"></a><span id="l35.163"> #endif /* 0 */</span>
<a href="#l35.164"></a><span id="l35.164"> </span>
<a href="#l35.165"></a><span id="l35.165"> /*</span>
<a href="#l35.166"></a><span id="l35.166">  * Replace *ldctrls with a copy of newctrls.</span>
<a href="#l35.167"></a><span id="l35.167">  * returns 0 if successful.</span>
<a href="#l35.168"></a><span id="l35.168">  * return -1 if not and set error code inside LDAP *ld.</span>
<a href="#l35.169"></a><span id="l35.169">  */</span>
<a href="#l35.170"></a><span id="l35.170" class="difflineminus">-int nsldapi_dup_controls(LDAP *ld, LDAPControl ***ldctrls,</span>
<a href="#l35.171"></a><span id="l35.171" class="difflineminus">-                         LDAPControl **newctrls) {</span>
<a href="#l35.172"></a><span id="l35.172" class="difflineplus">+int nsldapi_dup_controls(LDAP* ld, LDAPControl*** ldctrls,</span>
<a href="#l35.173"></a><span id="l35.173" class="difflineplus">+                         LDAPControl** newctrls) {</span>
<a href="#l35.174"></a><span id="l35.174">   int count;</span>
<a href="#l35.175"></a><span id="l35.175"> </span>
<a href="#l35.176"></a><span id="l35.176">   if (*ldctrls != NULL) {</span>
<a href="#l35.177"></a><span id="l35.177">     ldap_controls_free(*ldctrls);</span>
<a href="#l35.178"></a><span id="l35.178">   }</span>
<a href="#l35.179"></a><span id="l35.179"> </span>
<a href="#l35.180"></a><span id="l35.180">   if (newctrls == NULL || newctrls[0] == NULL) {</span>
<a href="#l35.181"></a><span id="l35.181">     *ldctrls = NULL;</span>
<a href="#l35.182"></a><span id="l35.182">     return (0);</span>
<a href="#l35.183"></a><span id="l35.183">   }</span>
<a href="#l35.184"></a><span id="l35.184"> </span>
<a href="#l35.185"></a><span id="l35.185">   for (count = 0; newctrls[count] != NULL; ++count) {</span>
<a href="#l35.186"></a><span id="l35.186">     ;</span>
<a href="#l35.187"></a><span id="l35.187">   }</span>
<a href="#l35.188"></a><span id="l35.188"> </span>
<a href="#l35.189"></a><span id="l35.189" class="difflineminus">-  if ((*ldctrls = (LDAPControl **)NSLDAPI_MALLOC(</span>
<a href="#l35.190"></a><span id="l35.190" class="difflineminus">-           (count + 1) * sizeof(LDAPControl *))) == NULL) {</span>
<a href="#l35.191"></a><span id="l35.191" class="difflineplus">+  if ((*ldctrls = (LDAPControl**)NSLDAPI_MALLOC(</span>
<a href="#l35.192"></a><span id="l35.192" class="difflineplus">+           (count + 1) * sizeof(LDAPControl*))) == NULL) {</span>
<a href="#l35.193"></a><span id="l35.193">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l35.194"></a><span id="l35.194">     return (-1);</span>
<a href="#l35.195"></a><span id="l35.195">   }</span>
<a href="#l35.196"></a><span id="l35.196">   (*ldctrls)[count] = NULL;</span>
<a href="#l35.197"></a><span id="l35.197"> </span>
<a href="#l35.198"></a><span id="l35.198">   for (count = 0; newctrls[count] != NULL; ++count) {</span>
<a href="#l35.199"></a><span id="l35.199">     if (((*ldctrls)[count] = ldap_control_dup(newctrls[count])) == NULL) {</span>
<a href="#l35.200"></a><span id="l35.200">       ldap_controls_free(*ldctrls);</span>
<a href="#l35.201"></a><span id="l35.201" class="difflineat">@@ -410,39 +410,39 @@ int nsldapi_dup_controls(LDAP *ld, LDAPC</span>
<a href="#l35.202"></a><span id="l35.202">   }</span>
<a href="#l35.203"></a><span id="l35.203"> </span>
<a href="#l35.204"></a><span id="l35.204">   return (0);</span>
<a href="#l35.205"></a><span id="l35.205"> }</span>
<a href="#l35.206"></a><span id="l35.206"> </span>
<a href="#l35.207"></a><span id="l35.207"> /*</span>
<a href="#l35.208"></a><span id="l35.208">  * return a malloc'd copy of &quot;ctrl&quot; (NULL if memory allocation fails)</span>
<a href="#l35.209"></a><span id="l35.209">  */</span>
<a href="#l35.210"></a><span id="l35.210" class="difflineminus">-static LDAPControl *</span>
<a href="#l35.211"></a><span id="l35.211" class="difflineplus">+static LDAPControl*</span>
<a href="#l35.212"></a><span id="l35.212"> /* LDAP_CALL */ /* keep this routine internal for now */</span>
<a href="#l35.213"></a><span id="l35.213" class="difflineminus">-ldap_control_dup(LDAPControl *ctrl) {</span>
<a href="#l35.214"></a><span id="l35.214" class="difflineminus">-  LDAPControl *rctrl;</span>
<a href="#l35.215"></a><span id="l35.215" class="difflineplus">+ldap_control_dup(LDAPControl* ctrl) {</span>
<a href="#l35.216"></a><span id="l35.216" class="difflineplus">+  LDAPControl* rctrl;</span>
<a href="#l35.217"></a><span id="l35.217"> </span>
<a href="#l35.218"></a><span id="l35.218" class="difflineminus">-  if ((rctrl = (LDAPControl *)NSLDAPI_MALLOC(sizeof(LDAPControl))) == NULL) {</span>
<a href="#l35.219"></a><span id="l35.219" class="difflineplus">+  if ((rctrl = (LDAPControl*)NSLDAPI_MALLOC(sizeof(LDAPControl))) == NULL) {</span>
<a href="#l35.220"></a><span id="l35.220">     return (NULL);</span>
<a href="#l35.221"></a><span id="l35.221">   }</span>
<a href="#l35.222"></a><span id="l35.222"> </span>
<a href="#l35.223"></a><span id="l35.223">   if (ldap_control_copy_contents(rctrl, ctrl) != LDAP_SUCCESS) {</span>
<a href="#l35.224"></a><span id="l35.224">     NSLDAPI_FREE(rctrl);</span>
<a href="#l35.225"></a><span id="l35.225">     return (NULL);</span>
<a href="#l35.226"></a><span id="l35.226">   }</span>
<a href="#l35.227"></a><span id="l35.227"> </span>
<a href="#l35.228"></a><span id="l35.228">   return (rctrl);</span>
<a href="#l35.229"></a><span id="l35.229"> }</span>
<a href="#l35.230"></a><span id="l35.230"> </span>
<a href="#l35.231"></a><span id="l35.231"> /*</span>
<a href="#l35.232"></a><span id="l35.232">  * duplicate the contents of &quot;ctrl_src&quot; and place in &quot;ctrl_dst&quot;</span>
<a href="#l35.233"></a><span id="l35.233">  */</span>
<a href="#l35.234"></a><span id="l35.234"> static int</span>
<a href="#l35.235"></a><span id="l35.235"> /* LDAP_CALL */ /* keep this routine internal for now */</span>
<a href="#l35.236"></a><span id="l35.236" class="difflineminus">-ldap_control_copy_contents(LDAPControl *ctrl_dst, LDAPControl *ctrl_src) {</span>
<a href="#l35.237"></a><span id="l35.237" class="difflineplus">+ldap_control_copy_contents(LDAPControl* ctrl_dst, LDAPControl* ctrl_src) {</span>
<a href="#l35.238"></a><span id="l35.238">   size_t len;</span>
<a href="#l35.239"></a><span id="l35.239"> </span>
<a href="#l35.240"></a><span id="l35.240">   if (NULL == ctrl_dst || NULL == ctrl_src) {</span>
<a href="#l35.241"></a><span id="l35.241">     return (LDAP_PARAM_ERROR);</span>
<a href="#l35.242"></a><span id="l35.242">   }</span>
<a href="#l35.243"></a><span id="l35.243"> </span>
<a href="#l35.244"></a><span id="l35.244">   ctrl_dst-&gt;ldctl_iscritical = ctrl_src-&gt;ldctl_iscritical;</span>
<a href="#l35.245"></a><span id="l35.245"> </span>
<a href="#l35.246"></a><span id="l35.246" class="difflineat">@@ -465,36 +465,36 @@ ldap_control_copy_contents(LDAPControl *</span>
<a href="#l35.247"></a><span id="l35.247">   }</span>
<a href="#l35.248"></a><span id="l35.248"> </span>
<a href="#l35.249"></a><span id="l35.249">   return (LDAP_SUCCESS);</span>
<a href="#l35.250"></a><span id="l35.250"> }</span>
<a href="#l35.251"></a><span id="l35.251"> </span>
<a href="#l35.252"></a><span id="l35.252"> /*</span>
<a href="#l35.253"></a><span id="l35.253">  * build an allocated LDAPv3 control.  Returns an LDAP error code.</span>
<a href="#l35.254"></a><span id="l35.254">  */</span>
<a href="#l35.255"></a><span id="l35.255" class="difflineminus">-int nsldapi_build_control(char *oid, BerElement *ber, int freeber,</span>
<a href="#l35.256"></a><span id="l35.256" class="difflineminus">-                          char iscritical, LDAPControl **ctrlp) {</span>
<a href="#l35.257"></a><span id="l35.257" class="difflineplus">+int nsldapi_build_control(char* oid, BerElement* ber, int freeber,</span>
<a href="#l35.258"></a><span id="l35.258" class="difflineplus">+                          char iscritical, LDAPControl** ctrlp) {</span>
<a href="#l35.259"></a><span id="l35.259">   int rc;</span>
<a href="#l35.260"></a><span id="l35.260" class="difflineminus">-  struct berval *bvp;</span>
<a href="#l35.261"></a><span id="l35.261" class="difflineplus">+  struct berval* bvp;</span>
<a href="#l35.262"></a><span id="l35.262"> </span>
<a href="#l35.263"></a><span id="l35.263">   if (ber == NULL) {</span>
<a href="#l35.264"></a><span id="l35.264">     bvp = NULL;</span>
<a href="#l35.265"></a><span id="l35.265">   } else {</span>
<a href="#l35.266"></a><span id="l35.266">     /* allocate struct berval with contents of the BER encoding */</span>
<a href="#l35.267"></a><span id="l35.267">     rc = ber_flatten(ber, &amp;bvp);</span>
<a href="#l35.268"></a><span id="l35.268">     if (freeber) {</span>
<a href="#l35.269"></a><span id="l35.269">       ber_free(ber, 1);</span>
<a href="#l35.270"></a><span id="l35.270">     }</span>
<a href="#l35.271"></a><span id="l35.271">     if (rc == -1) {</span>
<a href="#l35.272"></a><span id="l35.272">       return (LDAP_NO_MEMORY);</span>
<a href="#l35.273"></a><span id="l35.273">     }</span>
<a href="#l35.274"></a><span id="l35.274">   }</span>
<a href="#l35.275"></a><span id="l35.275"> </span>
<a href="#l35.276"></a><span id="l35.276">   /* allocate the new control structure */</span>
<a href="#l35.277"></a><span id="l35.277" class="difflineminus">-  if ((*ctrlp = (LDAPControl *)NSLDAPI_MALLOC(sizeof(LDAPControl))) == NULL) {</span>
<a href="#l35.278"></a><span id="l35.278" class="difflineplus">+  if ((*ctrlp = (LDAPControl*)NSLDAPI_MALLOC(sizeof(LDAPControl))) == NULL) {</span>
<a href="#l35.279"></a><span id="l35.279">     if (bvp != NULL) {</span>
<a href="#l35.280"></a><span id="l35.280">       ber_bvfree(bvp);</span>
<a href="#l35.281"></a><span id="l35.281">     }</span>
<a href="#l35.282"></a><span id="l35.282">     return (LDAP_NO_MEMORY);</span>
<a href="#l35.283"></a><span id="l35.283">   }</span>
<a href="#l35.284"></a><span id="l35.284"> </span>
<a href="#l35.285"></a><span id="l35.285">   /* fill in the fields of this new control */</span>
<a href="#l35.286"></a><span id="l35.286">   (*ctrlp)-&gt;ldctl_iscritical = iscritical;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/countvalues.c</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/countvalues.c</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -39,22 +39,22 @@</span>
<a href="#l36.4"></a><span id="l36.4">  *  All rights reserved.</span>
<a href="#l36.5"></a><span id="l36.5">  */</span>
<a href="#l36.6"></a><span id="l36.6"> /*</span>
<a href="#l36.7"></a><span id="l36.7">  *  countvalues.c</span>
<a href="#l36.8"></a><span id="l36.8">  */</span>
<a href="#l36.9"></a><span id="l36.9"> </span>
<a href="#l36.10"></a><span id="l36.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l36.11"></a><span id="l36.11"> </span>
<a href="#l36.12"></a><span id="l36.12" class="difflineminus">-int LDAP_CALL ldap_count_values(char **vals) {</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+int LDAP_CALL ldap_count_values(char** vals) {</span>
<a href="#l36.14"></a><span id="l36.14">   int i;</span>
<a href="#l36.15"></a><span id="l36.15"> </span>
<a href="#l36.16"></a><span id="l36.16">   if (vals == NULL) return (0);</span>
<a href="#l36.17"></a><span id="l36.17"> </span>
<a href="#l36.18"></a><span id="l36.18">   for (i = 0; vals[i] != NULL; i++)</span>
<a href="#l36.19"></a><span id="l36.19">     ; /* NULL */</span>
<a href="#l36.20"></a><span id="l36.20"> </span>
<a href="#l36.21"></a><span id="l36.21">   return (i);</span>
<a href="#l36.22"></a><span id="l36.22"> }</span>
<a href="#l36.23"></a><span id="l36.23"> </span>
<a href="#l36.24"></a><span id="l36.24" class="difflineminus">-int LDAP_CALL ldap_count_values_len(struct berval **vals) {</span>
<a href="#l36.25"></a><span id="l36.25" class="difflineminus">-  return (ldap_count_values((char **)vals));</span>
<a href="#l36.26"></a><span id="l36.26" class="difflineplus">+int LDAP_CALL ldap_count_values_len(struct berval** vals) {</span>
<a href="#l36.27"></a><span id="l36.27" class="difflineplus">+  return (ldap_count_values((char**)vals));</span>
<a href="#l36.28"></a><span id="l36.28"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/delete.c</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/delete.c</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -50,32 +50,32 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l37.4"></a><span id="l37.4">  * ldap_delete - initiate an ldap delete operation. Parameters:</span>
<a href="#l37.5"></a><span id="l37.5">  *</span>
<a href="#l37.6"></a><span id="l37.6">  * ld    LDAP descriptor</span>
<a href="#l37.7"></a><span id="l37.7">  * dn    DN of the object to delete</span>
<a href="#l37.8"></a><span id="l37.8">  *</span>
<a href="#l37.9"></a><span id="l37.9">  * Example:</span>
<a href="#l37.10"></a><span id="l37.10">  * msgid = ldap_delete(ld, dn);</span>
<a href="#l37.11"></a><span id="l37.11">  */</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineminus">-int LDAP_CALL ldap_delete(LDAP *ld, const char *dn) {</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+int LDAP_CALL ldap_delete(LDAP* ld, const char* dn) {</span>
<a href="#l37.14"></a><span id="l37.14">   int msgid;</span>
<a href="#l37.15"></a><span id="l37.15"> </span>
<a href="#l37.16"></a><span id="l37.16">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_delete\n&quot;, 0, 0, 0);</span>
<a href="#l37.17"></a><span id="l37.17"> </span>
<a href="#l37.18"></a><span id="l37.18">   if (ldap_delete_ext(ld, dn, NULL, NULL, &amp;msgid) == LDAP_SUCCESS) {</span>
<a href="#l37.19"></a><span id="l37.19">     return (msgid);</span>
<a href="#l37.20"></a><span id="l37.20">   } else {</span>
<a href="#l37.21"></a><span id="l37.21">     return (-1); /* error is in ld handle */</span>
<a href="#l37.22"></a><span id="l37.22">   }</span>
<a href="#l37.23"></a><span id="l37.23"> }</span>
<a href="#l37.24"></a><span id="l37.24"> </span>
<a href="#l37.25"></a><span id="l37.25" class="difflineminus">-int LDAP_CALL ldap_delete_ext(LDAP *ld, const char *dn,</span>
<a href="#l37.26"></a><span id="l37.26" class="difflineminus">-                              LDAPControl **serverctrls,</span>
<a href="#l37.27"></a><span id="l37.27" class="difflineminus">-                              LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l37.28"></a><span id="l37.28" class="difflineminus">-  BerElement *ber;</span>
<a href="#l37.29"></a><span id="l37.29" class="difflineplus">+int LDAP_CALL ldap_delete_ext(LDAP* ld, const char* dn,</span>
<a href="#l37.30"></a><span id="l37.30" class="difflineplus">+                              LDAPControl** serverctrls,</span>
<a href="#l37.31"></a><span id="l37.31" class="difflineplus">+                              LDAPControl** clientctrls, int* msgidp) {</span>
<a href="#l37.32"></a><span id="l37.32" class="difflineplus">+  BerElement* ber;</span>
<a href="#l37.33"></a><span id="l37.33">   int rc, lderr;</span>
<a href="#l37.34"></a><span id="l37.34"> </span>
<a href="#l37.35"></a><span id="l37.35">   /*</span>
<a href="#l37.36"></a><span id="l37.36">    * A delete request looks like this:</span>
<a href="#l37.37"></a><span id="l37.37">    * DelRequet ::= DistinguishedName,</span>
<a href="#l37.38"></a><span id="l37.38">    */</span>
<a href="#l37.39"></a><span id="l37.39"> </span>
<a href="#l37.40"></a><span id="l37.40">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_delete_ext\n&quot;, 0, 0, 0);</span>
<a href="#l37.41"></a><span id="l37.41" class="difflineat">@@ -120,35 +120,35 @@ int LDAP_CALL ldap_delete_ext(LDAP *ld, </span>
<a href="#l37.42"></a><span id="l37.42">   }</span>
<a href="#l37.43"></a><span id="l37.43"> </span>
<a href="#l37.44"></a><span id="l37.44">   if ((lderr = nsldapi_put_controls(ld, serverctrls, 1, ber)) != LDAP_SUCCESS) {</span>
<a href="#l37.45"></a><span id="l37.45">     ber_free(ber, 1);</span>
<a href="#l37.46"></a><span id="l37.46">     return (lderr);</span>
<a href="#l37.47"></a><span id="l37.47">   }</span>
<a href="#l37.48"></a><span id="l37.48"> </span>
<a href="#l37.49"></a><span id="l37.49">   /* send the message */</span>
<a href="#l37.50"></a><span id="l37.50" class="difflineminus">-  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_DELETE, (char *)dn,</span>
<a href="#l37.51"></a><span id="l37.51" class="difflineplus">+  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_DELETE, (char*)dn,</span>
<a href="#l37.52"></a><span id="l37.52">                                     ber);</span>
<a href="#l37.53"></a><span id="l37.53">   *msgidp = rc;</span>
<a href="#l37.54"></a><span id="l37.54">   return (rc &lt; 0 ? LDAP_GET_LDERRNO(ld, NULL, NULL) : LDAP_SUCCESS);</span>
<a href="#l37.55"></a><span id="l37.55"> }</span>
<a href="#l37.56"></a><span id="l37.56"> </span>
<a href="#l37.57"></a><span id="l37.57" class="difflineminus">-int LDAP_CALL ldap_delete_s(LDAP *ld, const char *dn) {</span>
<a href="#l37.58"></a><span id="l37.58" class="difflineplus">+int LDAP_CALL ldap_delete_s(LDAP* ld, const char* dn) {</span>
<a href="#l37.59"></a><span id="l37.59">   return (ldap_delete_ext_s(ld, dn, NULL, NULL));</span>
<a href="#l37.60"></a><span id="l37.60"> }</span>
<a href="#l37.61"></a><span id="l37.61"> </span>
<a href="#l37.62"></a><span id="l37.62" class="difflineminus">-int LDAP_CALL ldap_delete_ext_s(LDAP *ld, const char *dn,</span>
<a href="#l37.63"></a><span id="l37.63" class="difflineminus">-                                LDAPControl **serverctrls,</span>
<a href="#l37.64"></a><span id="l37.64" class="difflineminus">-                                LDAPControl **clientctrls) {</span>
<a href="#l37.65"></a><span id="l37.65" class="difflineplus">+int LDAP_CALL ldap_delete_ext_s(LDAP* ld, const char* dn,</span>
<a href="#l37.66"></a><span id="l37.66" class="difflineplus">+                                LDAPControl** serverctrls,</span>
<a href="#l37.67"></a><span id="l37.67" class="difflineplus">+                                LDAPControl** clientctrls) {</span>
<a href="#l37.68"></a><span id="l37.68">   int err, msgid;</span>
<a href="#l37.69"></a><span id="l37.69" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l37.70"></a><span id="l37.70" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l37.71"></a><span id="l37.71"> </span>
<a href="#l37.72"></a><span id="l37.72">   if ((err = ldap_delete_ext(ld, dn, serverctrls, clientctrls, &amp;msgid)) !=</span>
<a href="#l37.73"></a><span id="l37.73">       LDAP_SUCCESS) {</span>
<a href="#l37.74"></a><span id="l37.74">     return (err);</span>
<a href="#l37.75"></a><span id="l37.75">   }</span>
<a href="#l37.76"></a><span id="l37.76"> </span>
<a href="#l37.77"></a><span id="l37.77" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)NULL, &amp;res) == -1) {</span>
<a href="#l37.78"></a><span id="l37.78" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)NULL, &amp;res) == -1) {</span>
<a href="#l37.79"></a><span id="l37.79">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l37.80"></a><span id="l37.80">   }</span>
<a href="#l37.81"></a><span id="l37.81"> </span>
<a href="#l37.82"></a><span id="l37.82">   return (ldap_result2error(ld, res, 1));</span>
<a href="#l37.83"></a><span id="l37.83"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/disptmpl.c</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/disptmpl.c</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineat">@@ -47,58 +47,58 @@</span>
<a href="#l38.4"></a><span id="l38.4">  */</span>
<a href="#l38.5"></a><span id="l38.5"> /*</span>
<a href="#l38.6"></a><span id="l38.6">  * disptmpl.c:  display template library routines for LDAP clients</span>
<a href="#l38.7"></a><span id="l38.7">  */</span>
<a href="#l38.8"></a><span id="l38.8"> </span>
<a href="#l38.9"></a><span id="l38.9"> #include &quot;ldap-int.h&quot;</span>
<a href="#l38.10"></a><span id="l38.10"> #include &quot;disptmpl.h&quot;</span>
<a href="#l38.11"></a><span id="l38.11"> </span>
<a href="#l38.12"></a><span id="l38.12" class="difflineminus">-static void free_disptmpl(struct ldap_disptmpl *tmpl);</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineminus">-static int read_next_tmpl(char **bufp, long *blenp,</span>
<a href="#l38.14"></a><span id="l38.14" class="difflineminus">-                          struct ldap_disptmpl **tmplp, int dtversion);</span>
<a href="#l38.15"></a><span id="l38.15" class="difflineplus">+static void free_disptmpl(struct ldap_disptmpl* tmpl);</span>
<a href="#l38.16"></a><span id="l38.16" class="difflineplus">+static int read_next_tmpl(char** bufp, long* blenp,</span>
<a href="#l38.17"></a><span id="l38.17" class="difflineplus">+                          struct ldap_disptmpl** tmplp, int dtversion);</span>
<a href="#l38.18"></a><span id="l38.18"> </span>
<a href="#l38.19"></a><span id="l38.19" class="difflineminus">-static char *tmploptions[] = {&quot;addable&quot;, &quot;modrdn&quot;, &quot;altview&quot;, NULL};</span>
<a href="#l38.20"></a><span id="l38.20" class="difflineplus">+static char* tmploptions[] = {&quot;addable&quot;, &quot;modrdn&quot;, &quot;altview&quot;, NULL};</span>
<a href="#l38.21"></a><span id="l38.21"> </span>
<a href="#l38.22"></a><span id="l38.22"> static unsigned long tmploptvals[] = {</span>
<a href="#l38.23"></a><span id="l38.23">     LDAP_DTMPL_OPT_ADDABLE,</span>
<a href="#l38.24"></a><span id="l38.24">     LDAP_DTMPL_OPT_ALLOWMODRDN,</span>
<a href="#l38.25"></a><span id="l38.25">     LDAP_DTMPL_OPT_ALTVIEW,</span>
<a href="#l38.26"></a><span id="l38.26"> };</span>
<a href="#l38.27"></a><span id="l38.27"> </span>
<a href="#l38.28"></a><span id="l38.28" class="difflineminus">-static char *itemtypes[] = {</span>
<a href="#l38.29"></a><span id="l38.29" class="difflineplus">+static char* itemtypes[] = {</span>
<a href="#l38.30"></a><span id="l38.30">     &quot;cis&quot;,      &quot;mls&quot;,      &quot;dn&quot;,        &quot;bool&quot;, &quot;jpeg&quot;, &quot;jpegbtn&quot;,   &quot;fax&quot;,</span>
<a href="#l38.31"></a><span id="l38.31">     &quot;faxbtn&quot;,   &quot;audiobtn&quot;, &quot;time&quot;,      &quot;date&quot;, &quot;url&quot;,  &quot;searchact&quot;, &quot;linkact&quot;,</span>
<a href="#l38.32"></a><span id="l38.32">     &quot;adddnact&quot;, &quot;addact&quot;,   &quot;verifyact&quot;, &quot;mail&quot;, NULL};</span>
<a href="#l38.33"></a><span id="l38.33"> </span>
<a href="#l38.34"></a><span id="l38.34"> static unsigned long itemsynids[] = {</span>
<a href="#l38.35"></a><span id="l38.35">     LDAP_SYN_CASEIGNORESTR, LDAP_SYN_MULTILINESTR,   LDAP_SYN_DN,</span>
<a href="#l38.36"></a><span id="l38.36">     LDAP_SYN_BOOLEAN,       LDAP_SYN_JPEGIMAGE,      LDAP_SYN_JPEGBUTTON,</span>
<a href="#l38.37"></a><span id="l38.37">     LDAP_SYN_FAXIMAGE,      LDAP_SYN_FAXBUTTON,      LDAP_SYN_AUDIOBUTTON,</span>
<a href="#l38.38"></a><span id="l38.38">     LDAP_SYN_TIME,          LDAP_SYN_DATE,           LDAP_SYN_LABELEDURL,</span>
<a href="#l38.39"></a><span id="l38.39">     LDAP_SYN_SEARCHACTION,  LDAP_SYN_LINKACTION,     LDAP_SYN_ADDDNACTION,</span>
<a href="#l38.40"></a><span id="l38.40">     LDAP_SYN_ADDDNACTION,   LDAP_SYN_VERIFYDNACTION, LDAP_SYN_RFC822ADDR,</span>
<a href="#l38.41"></a><span id="l38.41"> };</span>
<a href="#l38.42"></a><span id="l38.42"> </span>
<a href="#l38.43"></a><span id="l38.43" class="difflineminus">-static char *itemoptions[] = {&quot;ro&quot;,       &quot;sort&quot;,        &quot;1val&quot;, &quot;hide&quot;,</span>
<a href="#l38.44"></a><span id="l38.44" class="difflineplus">+static char* itemoptions[] = {&quot;ro&quot;,       &quot;sort&quot;,        &quot;1val&quot;, &quot;hide&quot;,</span>
<a href="#l38.45"></a><span id="l38.45">                               &quot;required&quot;, &quot;hideiffalse&quot;, NULL};</span>
<a href="#l38.46"></a><span id="l38.46"> </span>
<a href="#l38.47"></a><span id="l38.47"> static unsigned long itemoptvals[] = {</span>
<a href="#l38.48"></a><span id="l38.48">     LDAP_DITEM_OPT_READONLY,      LDAP_DITEM_OPT_SORTVALUES,</span>
<a href="#l38.49"></a><span id="l38.49">     LDAP_DITEM_OPT_SINGLEVALUED,  LDAP_DITEM_OPT_HIDEIFEMPTY,</span>
<a href="#l38.50"></a><span id="l38.50">     LDAP_DITEM_OPT_VALUEREQUIRED, LDAP_DITEM_OPT_HIDEIFFALSE,</span>
<a href="#l38.51"></a><span id="l38.51"> };</span>
<a href="#l38.52"></a><span id="l38.52"> </span>
<a href="#l38.53"></a><span id="l38.53"> #define ADDEF_CONSTANT &quot;constant&quot;</span>
<a href="#l38.54"></a><span id="l38.54"> #define ADDEF_ADDERSDN &quot;addersdn&quot;</span>
<a href="#l38.55"></a><span id="l38.55"> </span>
<a href="#l38.56"></a><span id="l38.56" class="difflineminus">-int LDAP_CALL ldap_init_templates(char *file,</span>
<a href="#l38.57"></a><span id="l38.57" class="difflineminus">-                                  struct ldap_disptmpl **tmpllistp) {</span>
<a href="#l38.58"></a><span id="l38.58" class="difflineminus">-  FILE *fp;</span>
<a href="#l38.59"></a><span id="l38.59" class="difflineminus">-  char *buf;</span>
<a href="#l38.60"></a><span id="l38.60" class="difflineplus">+int LDAP_CALL ldap_init_templates(char* file,</span>
<a href="#l38.61"></a><span id="l38.61" class="difflineplus">+                                  struct ldap_disptmpl** tmpllistp) {</span>
<a href="#l38.62"></a><span id="l38.62" class="difflineplus">+  FILE* fp;</span>
<a href="#l38.63"></a><span id="l38.63" class="difflineplus">+  char* buf;</span>
<a href="#l38.64"></a><span id="l38.64">   long rlen, len;</span>
<a href="#l38.65"></a><span id="l38.65">   int rc, eof;</span>
<a href="#l38.66"></a><span id="l38.66"> </span>
<a href="#l38.67"></a><span id="l38.67">   *tmpllistp = NULLDISPTMPL;</span>
<a href="#l38.68"></a><span id="l38.68"> </span>
<a href="#l38.69"></a><span id="l38.69">   if ((fp = NSLDAPI_FOPEN(file, &quot;r&quot;)) == NULL) {</span>
<a href="#l38.70"></a><span id="l38.70">     return (LDAP_TMPL_ERR_FILE);</span>
<a href="#l38.71"></a><span id="l38.71">   }</span>
<a href="#l38.72"></a><span id="l38.72" class="difflineat">@@ -130,20 +130,20 @@ int LDAP_CALL ldap_init_templates(char *</span>
<a href="#l38.73"></a><span id="l38.73">   }</span>
<a href="#l38.74"></a><span id="l38.74"> </span>
<a href="#l38.75"></a><span id="l38.75">   rc = ldap_init_templates_buf(buf, rlen, tmpllistp);</span>
<a href="#l38.76"></a><span id="l38.76">   NSLDAPI_FREE(buf);</span>
<a href="#l38.77"></a><span id="l38.77"> </span>
<a href="#l38.78"></a><span id="l38.78">   return (rc);</span>
<a href="#l38.79"></a><span id="l38.79"> }</span>
<a href="#l38.80"></a><span id="l38.80"> </span>
<a href="#l38.81"></a><span id="l38.81" class="difflineminus">-int LDAP_CALL ldap_init_templates_buf(char *buf, long buflen,</span>
<a href="#l38.82"></a><span id="l38.82" class="difflineminus">-                                      struct ldap_disptmpl **tmpllistp) {</span>
<a href="#l38.83"></a><span id="l38.83" class="difflineplus">+int LDAP_CALL ldap_init_templates_buf(char* buf, long buflen,</span>
<a href="#l38.84"></a><span id="l38.84" class="difflineplus">+                                      struct ldap_disptmpl** tmpllistp) {</span>
<a href="#l38.85"></a><span id="l38.85">   int rc = 0, version;</span>
<a href="#l38.86"></a><span id="l38.86" class="difflineminus">-  char **toks;</span>
<a href="#l38.87"></a><span id="l38.87" class="difflineplus">+  char** toks;</span>
<a href="#l38.88"></a><span id="l38.88">   struct ldap_disptmpl *prevtmpl, *tmpl;</span>
<a href="#l38.89"></a><span id="l38.89"> </span>
<a href="#l38.90"></a><span id="l38.90">   *tmpllistp = prevtmpl = NULLDISPTMPL;</span>
<a href="#l38.91"></a><span id="l38.91"> </span>
<a href="#l38.92"></a><span id="l38.92">   if (nsldapi_next_line_tokens(&amp;buf, &amp;buflen, &amp;toks) != 2 ||</span>
<a href="#l38.93"></a><span id="l38.93">       strcasecmp(toks[0], &quot;version&quot;) != 0) {</span>
<a href="#l38.94"></a><span id="l38.94">     nsldapi_free_strarray(toks);</span>
<a href="#l38.95"></a><span id="l38.95">     return (LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.96"></a><span id="l38.96" class="difflineat">@@ -167,28 +167,28 @@ int LDAP_CALL ldap_init_templates_buf(ch</span>
<a href="#l38.97"></a><span id="l38.97"> </span>
<a href="#l38.98"></a><span id="l38.98">   if (rc != 0) {</span>
<a href="#l38.99"></a><span id="l38.99">     ldap_free_templates(*tmpllistp);</span>
<a href="#l38.100"></a><span id="l38.100">   }</span>
<a href="#l38.101"></a><span id="l38.101"> </span>
<a href="#l38.102"></a><span id="l38.102">   return (rc);</span>
<a href="#l38.103"></a><span id="l38.103"> }</span>
<a href="#l38.104"></a><span id="l38.104"> </span>
<a href="#l38.105"></a><span id="l38.105" class="difflineminus">-void LDAP_CALL ldap_free_templates(struct ldap_disptmpl *tmpllist) {</span>
<a href="#l38.106"></a><span id="l38.106" class="difflineplus">+void LDAP_CALL ldap_free_templates(struct ldap_disptmpl* tmpllist) {</span>
<a href="#l38.107"></a><span id="l38.107">   struct ldap_disptmpl *tp, *nexttp;</span>
<a href="#l38.108"></a><span id="l38.108"> </span>
<a href="#l38.109"></a><span id="l38.109">   if (tmpllist != NULL) {</span>
<a href="#l38.110"></a><span id="l38.110">     for (tp = tmpllist; tp != NULL; tp = nexttp) {</span>
<a href="#l38.111"></a><span id="l38.111">       nexttp = tp-&gt;dt_next;</span>
<a href="#l38.112"></a><span id="l38.112">       free_disptmpl(tp);</span>
<a href="#l38.113"></a><span id="l38.113">     }</span>
<a href="#l38.114"></a><span id="l38.114">   }</span>
<a href="#l38.115"></a><span id="l38.115"> }</span>
<a href="#l38.116"></a><span id="l38.116"> </span>
<a href="#l38.117"></a><span id="l38.117" class="difflineminus">-static void free_disptmpl(struct ldap_disptmpl *tmpl) {</span>
<a href="#l38.118"></a><span id="l38.118" class="difflineplus">+static void free_disptmpl(struct ldap_disptmpl* tmpl) {</span>
<a href="#l38.119"></a><span id="l38.119">   if (tmpl != NULL) {</span>
<a href="#l38.120"></a><span id="l38.120">     if (tmpl-&gt;dt_name != NULL) {</span>
<a href="#l38.121"></a><span id="l38.121">       NSLDAPI_FREE(tmpl-&gt;dt_name);</span>
<a href="#l38.122"></a><span id="l38.122">     }</span>
<a href="#l38.123"></a><span id="l38.123"> </span>
<a href="#l38.124"></a><span id="l38.124">     if (tmpl-&gt;dt_pluralname != NULL) {</span>
<a href="#l38.125"></a><span id="l38.125">       NSLDAPI_FREE(tmpl-&gt;dt_pluralname);</span>
<a href="#l38.126"></a><span id="l38.126">     }</span>
<a href="#l38.127"></a><span id="l38.127" class="difflineat">@@ -254,44 +254,44 @@ static void free_disptmpl(struct ldap_di</span>
<a href="#l38.128"></a><span id="l38.128">         }</span>
<a href="#l38.129"></a><span id="l38.129">       }</span>
<a href="#l38.130"></a><span id="l38.130">     }</span>
<a href="#l38.131"></a><span id="l38.131"> </span>
<a href="#l38.132"></a><span id="l38.132">     NSLDAPI_FREE(tmpl);</span>
<a href="#l38.133"></a><span id="l38.133">   }</span>
<a href="#l38.134"></a><span id="l38.134"> }</span>
<a href="#l38.135"></a><span id="l38.135"> </span>
<a href="#l38.136"></a><span id="l38.136" class="difflineminus">-struct ldap_disptmpl *LDAP_CALL</span>
<a href="#l38.137"></a><span id="l38.137" class="difflineminus">-ldap_first_disptmpl(struct ldap_disptmpl *tmpllist) {</span>
<a href="#l38.138"></a><span id="l38.138" class="difflineplus">+struct ldap_disptmpl* LDAP_CALL</span>
<a href="#l38.139"></a><span id="l38.139" class="difflineplus">+ldap_first_disptmpl(struct ldap_disptmpl* tmpllist) {</span>
<a href="#l38.140"></a><span id="l38.140">   return (tmpllist);</span>
<a href="#l38.141"></a><span id="l38.141"> }</span>
<a href="#l38.142"></a><span id="l38.142"> </span>
<a href="#l38.143"></a><span id="l38.143" class="difflineminus">-struct ldap_disptmpl *LDAP_CALL</span>
<a href="#l38.144"></a><span id="l38.144" class="difflineminus">-ldap_next_disptmpl(struct ldap_disptmpl *tmpllist, struct ldap_disptmpl *tmpl) {</span>
<a href="#l38.145"></a><span id="l38.145" class="difflineplus">+struct ldap_disptmpl* LDAP_CALL</span>
<a href="#l38.146"></a><span id="l38.146" class="difflineplus">+ldap_next_disptmpl(struct ldap_disptmpl* tmpllist, struct ldap_disptmpl* tmpl) {</span>
<a href="#l38.147"></a><span id="l38.147">   return (tmpl == NULLDISPTMPL ? tmpl : tmpl-&gt;dt_next);</span>
<a href="#l38.148"></a><span id="l38.148"> }</span>
<a href="#l38.149"></a><span id="l38.149"> </span>
<a href="#l38.150"></a><span id="l38.150" class="difflineminus">-struct ldap_disptmpl *LDAP_CALL</span>
<a href="#l38.151"></a><span id="l38.151" class="difflineminus">-ldap_name2template(char *name, struct ldap_disptmpl *tmpllist) {</span>
<a href="#l38.152"></a><span id="l38.152" class="difflineminus">-  struct ldap_disptmpl *dtp;</span>
<a href="#l38.153"></a><span id="l38.153" class="difflineplus">+struct ldap_disptmpl* LDAP_CALL</span>
<a href="#l38.154"></a><span id="l38.154" class="difflineplus">+ldap_name2template(char* name, struct ldap_disptmpl* tmpllist) {</span>
<a href="#l38.155"></a><span id="l38.155" class="difflineplus">+  struct ldap_disptmpl* dtp;</span>
<a href="#l38.156"></a><span id="l38.156"> </span>
<a href="#l38.157"></a><span id="l38.157">   for (dtp = ldap_first_disptmpl(tmpllist); dtp != NULLDISPTMPL;</span>
<a href="#l38.158"></a><span id="l38.158">        dtp = ldap_next_disptmpl(tmpllist, dtp)) {</span>
<a href="#l38.159"></a><span id="l38.159">     if (strcasecmp(name, dtp-&gt;dt_name) == 0) {</span>
<a href="#l38.160"></a><span id="l38.160">       return (dtp);</span>
<a href="#l38.161"></a><span id="l38.161">     }</span>
<a href="#l38.162"></a><span id="l38.162">   }</span>
<a href="#l38.163"></a><span id="l38.163"> </span>
<a href="#l38.164"></a><span id="l38.164">   return (NULLDISPTMPL);</span>
<a href="#l38.165"></a><span id="l38.165"> }</span>
<a href="#l38.166"></a><span id="l38.166"> </span>
<a href="#l38.167"></a><span id="l38.167" class="difflineminus">-struct ldap_disptmpl *LDAP_CALL</span>
<a href="#l38.168"></a><span id="l38.168" class="difflineminus">-ldap_oc2template(char **oclist, struct ldap_disptmpl *tmpllist) {</span>
<a href="#l38.169"></a><span id="l38.169" class="difflineminus">-  struct ldap_disptmpl *dtp;</span>
<a href="#l38.170"></a><span id="l38.170" class="difflineminus">-  struct ldap_oclist *oclp;</span>
<a href="#l38.171"></a><span id="l38.171" class="difflineplus">+struct ldap_disptmpl* LDAP_CALL</span>
<a href="#l38.172"></a><span id="l38.172" class="difflineplus">+ldap_oc2template(char** oclist, struct ldap_disptmpl* tmpllist) {</span>
<a href="#l38.173"></a><span id="l38.173" class="difflineplus">+  struct ldap_disptmpl* dtp;</span>
<a href="#l38.174"></a><span id="l38.174" class="difflineplus">+  struct ldap_oclist* oclp;</span>
<a href="#l38.175"></a><span id="l38.175">   int i, j, needcnt, matchcnt;</span>
<a href="#l38.176"></a><span id="l38.176"> </span>
<a href="#l38.177"></a><span id="l38.177">   if (tmpllist == NULL || oclist == NULL || oclist[0] == NULL) {</span>
<a href="#l38.178"></a><span id="l38.178">     return (NULLDISPTMPL);</span>
<a href="#l38.179"></a><span id="l38.179">   }</span>
<a href="#l38.180"></a><span id="l38.180"> </span>
<a href="#l38.181"></a><span id="l38.181">   for (dtp = ldap_first_disptmpl(tmpllist); dtp != NULLDISPTMPL;</span>
<a href="#l38.182"></a><span id="l38.182">        dtp = ldap_next_disptmpl(tmpllist, dtp)) {</span>
<a href="#l38.183"></a><span id="l38.183" class="difflineat">@@ -310,56 +310,56 @@ ldap_oc2template(char **oclist, struct l</span>
<a href="#l38.184"></a><span id="l38.184">         return (dtp);</span>
<a href="#l38.185"></a><span id="l38.185">       }</span>
<a href="#l38.186"></a><span id="l38.186">     }</span>
<a href="#l38.187"></a><span id="l38.187">   }</span>
<a href="#l38.188"></a><span id="l38.188"> </span>
<a href="#l38.189"></a><span id="l38.189">   return (NULLDISPTMPL);</span>
<a href="#l38.190"></a><span id="l38.190"> }</span>
<a href="#l38.191"></a><span id="l38.191"> </span>
<a href="#l38.192"></a><span id="l38.192" class="difflineminus">-struct ldap_tmplitem *LDAP_CALL ldap_first_tmplrow(struct ldap_disptmpl *tmpl) {</span>
<a href="#l38.193"></a><span id="l38.193" class="difflineplus">+struct ldap_tmplitem* LDAP_CALL ldap_first_tmplrow(struct ldap_disptmpl* tmpl) {</span>
<a href="#l38.194"></a><span id="l38.194">   return (tmpl-&gt;dt_items);</span>
<a href="#l38.195"></a><span id="l38.195"> }</span>
<a href="#l38.196"></a><span id="l38.196"> </span>
<a href="#l38.197"></a><span id="l38.197" class="difflineminus">-struct ldap_tmplitem *LDAP_CALL ldap_next_tmplrow(struct ldap_disptmpl *tmpl,</span>
<a href="#l38.198"></a><span id="l38.198" class="difflineminus">-                                                  struct ldap_tmplitem *row) {</span>
<a href="#l38.199"></a><span id="l38.199" class="difflineplus">+struct ldap_tmplitem* LDAP_CALL ldap_next_tmplrow(struct ldap_disptmpl* tmpl,</span>
<a href="#l38.200"></a><span id="l38.200" class="difflineplus">+                                                  struct ldap_tmplitem* row) {</span>
<a href="#l38.201"></a><span id="l38.201">   return (row == NULLTMPLITEM ? row : row-&gt;ti_next_in_col);</span>
<a href="#l38.202"></a><span id="l38.202"> }</span>
<a href="#l38.203"></a><span id="l38.203"> </span>
<a href="#l38.204"></a><span id="l38.204" class="difflineminus">-struct ldap_tmplitem *LDAP_CALL ldap_first_tmplcol(struct ldap_disptmpl *tmpl,</span>
<a href="#l38.205"></a><span id="l38.205" class="difflineminus">-                                                   struct ldap_tmplitem *row) {</span>
<a href="#l38.206"></a><span id="l38.206" class="difflineplus">+struct ldap_tmplitem* LDAP_CALL ldap_first_tmplcol(struct ldap_disptmpl* tmpl,</span>
<a href="#l38.207"></a><span id="l38.207" class="difflineplus">+                                                   struct ldap_tmplitem* row) {</span>
<a href="#l38.208"></a><span id="l38.208">   return (row);</span>
<a href="#l38.209"></a><span id="l38.209"> }</span>
<a href="#l38.210"></a><span id="l38.210"> </span>
<a href="#l38.211"></a><span id="l38.211" class="difflineminus">-struct ldap_tmplitem *LDAP_CALL ldap_next_tmplcol(struct ldap_disptmpl *tmpl,</span>
<a href="#l38.212"></a><span id="l38.212" class="difflineminus">-                                                  struct ldap_tmplitem *row,</span>
<a href="#l38.213"></a><span id="l38.213" class="difflineminus">-                                                  struct ldap_tmplitem *col) {</span>
<a href="#l38.214"></a><span id="l38.214" class="difflineplus">+struct ldap_tmplitem* LDAP_CALL ldap_next_tmplcol(struct ldap_disptmpl* tmpl,</span>
<a href="#l38.215"></a><span id="l38.215" class="difflineplus">+                                                  struct ldap_tmplitem* row,</span>
<a href="#l38.216"></a><span id="l38.216" class="difflineplus">+                                                  struct ldap_tmplitem* col) {</span>
<a href="#l38.217"></a><span id="l38.217">   return (col == NULLTMPLITEM ? col : col-&gt;ti_next_in_row);</span>
<a href="#l38.218"></a><span id="l38.218"> }</span>
<a href="#l38.219"></a><span id="l38.219"> </span>
<a href="#l38.220"></a><span id="l38.220" class="difflineminus">-char **LDAP_CALL ldap_tmplattrs(struct ldap_disptmpl *tmpl, char **includeattrs,</span>
<a href="#l38.221"></a><span id="l38.221" class="difflineplus">+char** LDAP_CALL ldap_tmplattrs(struct ldap_disptmpl* tmpl, char** includeattrs,</span>
<a href="#l38.222"></a><span id="l38.222">                                 int exclude, unsigned long syntaxmask) {</span>
<a href="#l38.223"></a><span id="l38.223">   /*</span>
<a href="#l38.224"></a><span id="l38.224">    * this routine should filter out duplicate attributes...</span>
<a href="#l38.225"></a><span id="l38.225">    */</span>
<a href="#l38.226"></a><span id="l38.226">   struct ldap_tmplitem *tirowp, *ticolp;</span>
<a href="#l38.227"></a><span id="l38.227">   int i, attrcnt, memerr;</span>
<a href="#l38.228"></a><span id="l38.228" class="difflineminus">-  char **attrs;</span>
<a href="#l38.229"></a><span id="l38.229" class="difflineplus">+  char** attrs;</span>
<a href="#l38.230"></a><span id="l38.230"> </span>
<a href="#l38.231"></a><span id="l38.231">   attrcnt = 0;</span>
<a href="#l38.232"></a><span id="l38.232">   memerr = 0;</span>
<a href="#l38.233"></a><span id="l38.233"> </span>
<a href="#l38.234"></a><span id="l38.234" class="difflineminus">-  if ((attrs = (char **)NSLDAPI_MALLOC(sizeof(char *))) == NULL) {</span>
<a href="#l38.235"></a><span id="l38.235" class="difflineplus">+  if ((attrs = (char**)NSLDAPI_MALLOC(sizeof(char*))) == NULL) {</span>
<a href="#l38.236"></a><span id="l38.236">     return (NULL);</span>
<a href="#l38.237"></a><span id="l38.237">   }</span>
<a href="#l38.238"></a><span id="l38.238"> </span>
<a href="#l38.239"></a><span id="l38.239">   if (includeattrs != NULL) {</span>
<a href="#l38.240"></a><span id="l38.240">     for (i = 0; !memerr &amp;&amp; includeattrs[i] != NULL; ++i) {</span>
<a href="#l38.241"></a><span id="l38.241" class="difflineminus">-      if ((attrs = (char **)NSLDAPI_REALLOC(</span>
<a href="#l38.242"></a><span id="l38.242" class="difflineminus">-               attrs, (attrcnt + 2) * sizeof(char *))) == NULL ||</span>
<a href="#l38.243"></a><span id="l38.243" class="difflineplus">+      if ((attrs = (char**)NSLDAPI_REALLOC(</span>
<a href="#l38.244"></a><span id="l38.244" class="difflineplus">+               attrs, (attrcnt + 2) * sizeof(char*))) == NULL ||</span>
<a href="#l38.245"></a><span id="l38.245">           (attrs[attrcnt++] = nsldapi_strdup(includeattrs[i])) == NULL) {</span>
<a href="#l38.246"></a><span id="l38.246">         memerr = 1;</span>
<a href="#l38.247"></a><span id="l38.247">       } else {</span>
<a href="#l38.248"></a><span id="l38.248">         attrs[attrcnt] = NULL;</span>
<a href="#l38.249"></a><span id="l38.249">       }</span>
<a href="#l38.250"></a><span id="l38.250">     }</span>
<a href="#l38.251"></a><span id="l38.251">   }</span>
<a href="#l38.252"></a><span id="l38.252"> </span>
<a href="#l38.253"></a><span id="l38.253" class="difflineat">@@ -370,87 +370,87 @@ char **LDAP_CALL ldap_tmplattrs(struct l</span>
<a href="#l38.254"></a><span id="l38.254">       if (syntaxmask != 0) {</span>
<a href="#l38.255"></a><span id="l38.255">         if ((exclude &amp;&amp; (syntaxmask &amp; ticolp-&gt;ti_syntaxid) != 0) ||</span>
<a href="#l38.256"></a><span id="l38.256">             (!exclude &amp;&amp; (syntaxmask &amp; ticolp-&gt;ti_syntaxid) == 0)) {</span>
<a href="#l38.257"></a><span id="l38.257">           continue;</span>
<a href="#l38.258"></a><span id="l38.258">         }</span>
<a href="#l38.259"></a><span id="l38.259">       }</span>
<a href="#l38.260"></a><span id="l38.260"> </span>
<a href="#l38.261"></a><span id="l38.261">       if (ticolp-&gt;ti_attrname != NULL) {</span>
<a href="#l38.262"></a><span id="l38.262" class="difflineminus">-        if ((attrs = (char **)NSLDAPI_REALLOC(</span>
<a href="#l38.263"></a><span id="l38.263" class="difflineminus">-                 attrs, (attrcnt + 2) * sizeof(char *))) == NULL ||</span>
<a href="#l38.264"></a><span id="l38.264" class="difflineplus">+        if ((attrs = (char**)NSLDAPI_REALLOC(</span>
<a href="#l38.265"></a><span id="l38.265" class="difflineplus">+                 attrs, (attrcnt + 2) * sizeof(char*))) == NULL ||</span>
<a href="#l38.266"></a><span id="l38.266">             (attrs[attrcnt++] = nsldapi_strdup(ticolp-&gt;ti_attrname)) == NULL) {</span>
<a href="#l38.267"></a><span id="l38.267">           memerr = 1;</span>
<a href="#l38.268"></a><span id="l38.268">         } else {</span>
<a href="#l38.269"></a><span id="l38.269">           attrs[attrcnt] = NULL;</span>
<a href="#l38.270"></a><span id="l38.270">         }</span>
<a href="#l38.271"></a><span id="l38.271">       }</span>
<a href="#l38.272"></a><span id="l38.272">     }</span>
<a href="#l38.273"></a><span id="l38.273">   }</span>
<a href="#l38.274"></a><span id="l38.274"> </span>
<a href="#l38.275"></a><span id="l38.275">   if (memerr || attrcnt == 0) {</span>
<a href="#l38.276"></a><span id="l38.276">     for (i = 0; i &lt; attrcnt; ++i) {</span>
<a href="#l38.277"></a><span id="l38.277">       if (attrs[i] != NULL) {</span>
<a href="#l38.278"></a><span id="l38.278">         NSLDAPI_FREE(attrs[i]);</span>
<a href="#l38.279"></a><span id="l38.279">       }</span>
<a href="#l38.280"></a><span id="l38.280">     }</span>
<a href="#l38.281"></a><span id="l38.281"> </span>
<a href="#l38.282"></a><span id="l38.282" class="difflineminus">-    NSLDAPI_FREE((char *)attrs);</span>
<a href="#l38.283"></a><span id="l38.283" class="difflineplus">+    NSLDAPI_FREE((char*)attrs);</span>
<a href="#l38.284"></a><span id="l38.284">     return (NULL);</span>
<a href="#l38.285"></a><span id="l38.285">   }</span>
<a href="#l38.286"></a><span id="l38.286"> </span>
<a href="#l38.287"></a><span id="l38.287">   return (attrs);</span>
<a href="#l38.288"></a><span id="l38.288"> }</span>
<a href="#l38.289"></a><span id="l38.289"> </span>
<a href="#l38.290"></a><span id="l38.290" class="difflineminus">-static int read_next_tmpl(char **bufp, long *blenp,</span>
<a href="#l38.291"></a><span id="l38.291" class="difflineminus">-                          struct ldap_disptmpl **tmplp, int dtversion) {</span>
<a href="#l38.292"></a><span id="l38.292" class="difflineplus">+static int read_next_tmpl(char** bufp, long* blenp,</span>
<a href="#l38.293"></a><span id="l38.293" class="difflineplus">+                          struct ldap_disptmpl** tmplp, int dtversion) {</span>
<a href="#l38.294"></a><span id="l38.294">   int i, j, tokcnt, samerow, adsource;</span>
<a href="#l38.295"></a><span id="l38.295">   char **toks, *itemopts;</span>
<a href="#l38.296"></a><span id="l38.296" class="difflineminus">-  struct ldap_disptmpl *tmpl = NULL;</span>
<a href="#l38.297"></a><span id="l38.297" class="difflineplus">+  struct ldap_disptmpl* tmpl = NULL;</span>
<a href="#l38.298"></a><span id="l38.298">   struct ldap_oclist *ocp = NULL, *prevocp = NULL;</span>
<a href="#l38.299"></a><span id="l38.299">   struct ldap_adddeflist *adp = NULL, *prevadp = NULL;</span>
<a href="#l38.300"></a><span id="l38.300">   struct ldap_tmplitem *rowp = NULL, *ip = NULL, *previp = NULL;</span>
<a href="#l38.301"></a><span id="l38.301"> </span>
<a href="#l38.302"></a><span id="l38.302">   /*</span>
<a href="#l38.303"></a><span id="l38.303">    * template name comes first</span>
<a href="#l38.304"></a><span id="l38.304">    */</span>
<a href="#l38.305"></a><span id="l38.305">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l38.306"></a><span id="l38.306">     nsldapi_free_strarray(toks);</span>
<a href="#l38.307"></a><span id="l38.307">     return (tokcnt == 0 ? 0 : LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.308"></a><span id="l38.308">   }</span>
<a href="#l38.309"></a><span id="l38.309"> </span>
<a href="#l38.310"></a><span id="l38.310" class="difflineminus">-  if ((tmpl = (struct ldap_disptmpl *)NSLDAPI_CALLOC(</span>
<a href="#l38.311"></a><span id="l38.311" class="difflineplus">+  if ((tmpl = (struct ldap_disptmpl*)NSLDAPI_CALLOC(</span>
<a href="#l38.312"></a><span id="l38.312">            1, sizeof(struct ldap_disptmpl))) == NULL) {</span>
<a href="#l38.313"></a><span id="l38.313">     nsldapi_free_strarray(toks);</span>
<a href="#l38.314"></a><span id="l38.314">     return (LDAP_TMPL_ERR_MEM);</span>
<a href="#l38.315"></a><span id="l38.315">   }</span>
<a href="#l38.316"></a><span id="l38.316">   tmpl-&gt;dt_name = toks[0];</span>
<a href="#l38.317"></a><span id="l38.317" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l38.318"></a><span id="l38.318" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l38.319"></a><span id="l38.319"> </span>
<a href="#l38.320"></a><span id="l38.320">   /*</span>
<a href="#l38.321"></a><span id="l38.321">    * template plural name comes next</span>
<a href="#l38.322"></a><span id="l38.322">    */</span>
<a href="#l38.323"></a><span id="l38.323">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l38.324"></a><span id="l38.324">     nsldapi_free_strarray(toks);</span>
<a href="#l38.325"></a><span id="l38.325">     free_disptmpl(tmpl);</span>
<a href="#l38.326"></a><span id="l38.326">     return (LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.327"></a><span id="l38.327">   }</span>
<a href="#l38.328"></a><span id="l38.328">   tmpl-&gt;dt_pluralname = toks[0];</span>
<a href="#l38.329"></a><span id="l38.329" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l38.330"></a><span id="l38.330" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l38.331"></a><span id="l38.331"> </span>
<a href="#l38.332"></a><span id="l38.332">   /*</span>
<a href="#l38.333"></a><span id="l38.333">    * template icon name is next</span>
<a href="#l38.334"></a><span id="l38.334">    */</span>
<a href="#l38.335"></a><span id="l38.335">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l38.336"></a><span id="l38.336">     nsldapi_free_strarray(toks);</span>
<a href="#l38.337"></a><span id="l38.337">     free_disptmpl(tmpl);</span>
<a href="#l38.338"></a><span id="l38.338">     return (LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.339"></a><span id="l38.339">   }</span>
<a href="#l38.340"></a><span id="l38.340">   tmpl-&gt;dt_iconname = toks[0];</span>
<a href="#l38.341"></a><span id="l38.341" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l38.342"></a><span id="l38.342" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l38.343"></a><span id="l38.343"> </span>
<a href="#l38.344"></a><span id="l38.344">   /*</span>
<a href="#l38.345"></a><span id="l38.345">    * template options come next</span>
<a href="#l38.346"></a><span id="l38.346">    */</span>
<a href="#l38.347"></a><span id="l38.347">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) &lt; 1) {</span>
<a href="#l38.348"></a><span id="l38.348">     nsldapi_free_strarray(toks);</span>
<a href="#l38.349"></a><span id="l38.349">     free_disptmpl(tmpl);</span>
<a href="#l38.350"></a><span id="l38.350">     return (LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.351"></a><span id="l38.351" class="difflineat">@@ -463,17 +463,17 @@ static int read_next_tmpl(char **bufp, l</span>
<a href="#l38.352"></a><span id="l38.352">     }</span>
<a href="#l38.353"></a><span id="l38.353">   }</span>
<a href="#l38.354"></a><span id="l38.354">   nsldapi_free_strarray(toks);</span>
<a href="#l38.355"></a><span id="l38.355"> </span>
<a href="#l38.356"></a><span id="l38.356">   /*</span>
<a href="#l38.357"></a><span id="l38.357">    * object class list is next</span>
<a href="#l38.358"></a><span id="l38.358">    */</span>
<a href="#l38.359"></a><span id="l38.359">   while ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) &gt; 0) {</span>
<a href="#l38.360"></a><span id="l38.360" class="difflineminus">-    if ((ocp = (struct ldap_oclist *)NSLDAPI_CALLOC(</span>
<a href="#l38.361"></a><span id="l38.361" class="difflineplus">+    if ((ocp = (struct ldap_oclist*)NSLDAPI_CALLOC(</span>
<a href="#l38.362"></a><span id="l38.362">              1, sizeof(struct ldap_oclist))) == NULL) {</span>
<a href="#l38.363"></a><span id="l38.363">       nsldapi_free_strarray(toks);</span>
<a href="#l38.364"></a><span id="l38.364">       free_disptmpl(tmpl);</span>
<a href="#l38.365"></a><span id="l38.365">       return (LDAP_TMPL_ERR_MEM);</span>
<a href="#l38.366"></a><span id="l38.366">     }</span>
<a href="#l38.367"></a><span id="l38.367">     ocp-&gt;oc_objclasses = toks;</span>
<a href="#l38.368"></a><span id="l38.368">     if (tmpl-&gt;dt_oclist == NULL) {</span>
<a href="#l38.369"></a><span id="l38.369">       tmpl-&gt;dt_oclist = ocp;</span>
<a href="#l38.370"></a><span id="l38.370" class="difflineat">@@ -495,43 +495,43 @@ static int read_next_tmpl(char **bufp, l</span>
<a href="#l38.371"></a><span id="l38.371">     free_disptmpl(tmpl);</span>
<a href="#l38.372"></a><span id="l38.372">     return (LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.373"></a><span id="l38.373">   }</span>
<a href="#l38.374"></a><span id="l38.374">   if (toks[0][0] != '\0') {</span>
<a href="#l38.375"></a><span id="l38.375">     tmpl-&gt;dt_authattrname = toks[0];</span>
<a href="#l38.376"></a><span id="l38.376">   } else {</span>
<a href="#l38.377"></a><span id="l38.377">     NSLDAPI_FREE(toks[0]);</span>
<a href="#l38.378"></a><span id="l38.378">   }</span>
<a href="#l38.379"></a><span id="l38.379" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l38.380"></a><span id="l38.380" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l38.381"></a><span id="l38.381"> </span>
<a href="#l38.382"></a><span id="l38.382">   /*</span>
<a href="#l38.383"></a><span id="l38.383">    * read default attribute to use for RDN</span>
<a href="#l38.384"></a><span id="l38.384">    */</span>
<a href="#l38.385"></a><span id="l38.385">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l38.386"></a><span id="l38.386">     nsldapi_free_strarray(toks);</span>
<a href="#l38.387"></a><span id="l38.387">     free_disptmpl(tmpl);</span>
<a href="#l38.388"></a><span id="l38.388">     return (LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.389"></a><span id="l38.389">   }</span>
<a href="#l38.390"></a><span id="l38.390">   tmpl-&gt;dt_defrdnattrname = toks[0];</span>
<a href="#l38.391"></a><span id="l38.391" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l38.392"></a><span id="l38.392" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l38.393"></a><span id="l38.393"> </span>
<a href="#l38.394"></a><span id="l38.394">   /*</span>
<a href="#l38.395"></a><span id="l38.395">    * read default location for new entries</span>
<a href="#l38.396"></a><span id="l38.396">    */</span>
<a href="#l38.397"></a><span id="l38.397">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l38.398"></a><span id="l38.398">     nsldapi_free_strarray(toks);</span>
<a href="#l38.399"></a><span id="l38.399">     free_disptmpl(tmpl);</span>
<a href="#l38.400"></a><span id="l38.400">     return (LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.401"></a><span id="l38.401">   }</span>
<a href="#l38.402"></a><span id="l38.402">   if (toks[0][0] != '\0') {</span>
<a href="#l38.403"></a><span id="l38.403">     tmpl-&gt;dt_defaddlocation = toks[0];</span>
<a href="#l38.404"></a><span id="l38.404">   } else {</span>
<a href="#l38.405"></a><span id="l38.405">     NSLDAPI_FREE(toks[0]);</span>
<a href="#l38.406"></a><span id="l38.406">   }</span>
<a href="#l38.407"></a><span id="l38.407" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l38.408"></a><span id="l38.408" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l38.409"></a><span id="l38.409"> </span>
<a href="#l38.410"></a><span id="l38.410">   /*</span>
<a href="#l38.411"></a><span id="l38.411">    * read list of rules used to define default values for new entries</span>
<a href="#l38.412"></a><span id="l38.412">    */</span>
<a href="#l38.413"></a><span id="l38.413">   while ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) &gt; 0) {</span>
<a href="#l38.414"></a><span id="l38.414">     if (strcasecmp(ADDEF_CONSTANT, toks[0]) == 0) {</span>
<a href="#l38.415"></a><span id="l38.415">       adsource = LDAP_ADSRC_CONSTANTVALUE;</span>
<a href="#l38.416"></a><span id="l38.416">     } else if (strcasecmp(ADDEF_ADDERSDN, toks[0]) == 0) {</span>
<a href="#l38.417"></a><span id="l38.417" class="difflineat">@@ -542,29 +542,29 @@ static int read_next_tmpl(char **bufp, l</span>
<a href="#l38.418"></a><span id="l38.418">     if (adsource == 0 || tokcnt &lt; 2 ||</span>
<a href="#l38.419"></a><span id="l38.419">         (adsource == LDAP_ADSRC_CONSTANTVALUE &amp;&amp; tokcnt != 3) ||</span>
<a href="#l38.420"></a><span id="l38.420">         (adsource == LDAP_ADSRC_ADDERSDN &amp;&amp; tokcnt != 2)) {</span>
<a href="#l38.421"></a><span id="l38.421">       nsldapi_free_strarray(toks);</span>
<a href="#l38.422"></a><span id="l38.422">       free_disptmpl(tmpl);</span>
<a href="#l38.423"></a><span id="l38.423">       return (LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.424"></a><span id="l38.424">     }</span>
<a href="#l38.425"></a><span id="l38.425"> </span>
<a href="#l38.426"></a><span id="l38.426" class="difflineminus">-    if ((adp = (struct ldap_adddeflist *)NSLDAPI_CALLOC(</span>
<a href="#l38.427"></a><span id="l38.427" class="difflineplus">+    if ((adp = (struct ldap_adddeflist*)NSLDAPI_CALLOC(</span>
<a href="#l38.428"></a><span id="l38.428">              1, sizeof(struct ldap_adddeflist))) == NULL) {</span>
<a href="#l38.429"></a><span id="l38.429">       nsldapi_free_strarray(toks);</span>
<a href="#l38.430"></a><span id="l38.430">       free_disptmpl(tmpl);</span>
<a href="#l38.431"></a><span id="l38.431">       return (LDAP_TMPL_ERR_MEM);</span>
<a href="#l38.432"></a><span id="l38.432">     }</span>
<a href="#l38.433"></a><span id="l38.433">     adp-&gt;ad_source = adsource;</span>
<a href="#l38.434"></a><span id="l38.434">     adp-&gt;ad_attrname = toks[1];</span>
<a href="#l38.435"></a><span id="l38.435">     if (adsource == LDAP_ADSRC_CONSTANTVALUE) {</span>
<a href="#l38.436"></a><span id="l38.436">       adp-&gt;ad_value = toks[2];</span>
<a href="#l38.437"></a><span id="l38.437">     }</span>
<a href="#l38.438"></a><span id="l38.438">     NSLDAPI_FREE(toks[0]);</span>
<a href="#l38.439"></a><span id="l38.439" class="difflineminus">-    NSLDAPI_FREE((char *)toks);</span>
<a href="#l38.440"></a><span id="l38.440" class="difflineplus">+    NSLDAPI_FREE((char*)toks);</span>
<a href="#l38.441"></a><span id="l38.441"> </span>
<a href="#l38.442"></a><span id="l38.442">     if (tmpl-&gt;dt_adddeflist == NULL) {</span>
<a href="#l38.443"></a><span id="l38.443">       tmpl-&gt;dt_adddeflist = adp;</span>
<a href="#l38.444"></a><span id="l38.444">     } else {</span>
<a href="#l38.445"></a><span id="l38.445">       prevadp-&gt;ad_next = adp;</span>
<a href="#l38.446"></a><span id="l38.446">     }</span>
<a href="#l38.447"></a><span id="l38.447">     prevadp = adp;</span>
<a href="#l38.448"></a><span id="l38.448">   }</span>
<a href="#l38.449"></a><span id="l38.449" class="difflineat">@@ -576,17 +576,17 @@ static int read_next_tmpl(char **bufp, l</span>
<a href="#l38.450"></a><span id="l38.450">   while ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) &gt; 0) {</span>
<a href="#l38.451"></a><span id="l38.451">     if (strcasecmp(toks[0], &quot;item&quot;) == 0) {</span>
<a href="#l38.452"></a><span id="l38.452">       if (tokcnt &lt; 4) {</span>
<a href="#l38.453"></a><span id="l38.453">         nsldapi_free_strarray(toks);</span>
<a href="#l38.454"></a><span id="l38.454">         free_disptmpl(tmpl);</span>
<a href="#l38.455"></a><span id="l38.455">         return (LDAP_TMPL_ERR_SYNTAX);</span>
<a href="#l38.456"></a><span id="l38.456">       }</span>
<a href="#l38.457"></a><span id="l38.457"> </span>
<a href="#l38.458"></a><span id="l38.458" class="difflineminus">-      if ((ip = (struct ldap_tmplitem *)NSLDAPI_CALLOC(</span>
<a href="#l38.459"></a><span id="l38.459" class="difflineplus">+      if ((ip = (struct ldap_tmplitem*)NSLDAPI_CALLOC(</span>
<a href="#l38.460"></a><span id="l38.460">                1, sizeof(struct ldap_tmplitem))) == NULL) {</span>
<a href="#l38.461"></a><span id="l38.461">         nsldapi_free_strarray(toks);</span>
<a href="#l38.462"></a><span id="l38.462">         free_disptmpl(tmpl);</span>
<a href="#l38.463"></a><span id="l38.463">         return (LDAP_TMPL_ERR_MEM);</span>
<a href="#l38.464"></a><span id="l38.464">       }</span>
<a href="#l38.465"></a><span id="l38.465"> </span>
<a href="#l38.466"></a><span id="l38.466">       /*</span>
<a href="#l38.467"></a><span id="l38.467">        * find syntaxid from config file string</span>
<a href="#l38.468"></a><span id="l38.468" class="difflineat">@@ -626,26 +626,26 @@ static int read_next_tmpl(char **bufp, l</span>
<a href="#l38.469"></a><span id="l38.469">         NSLDAPI_FREE(toks[3]);</span>
<a href="#l38.470"></a><span id="l38.470">       } else {</span>
<a href="#l38.471"></a><span id="l38.471">         ip-&gt;ti_attrname = toks[3];</span>
<a href="#l38.472"></a><span id="l38.472">       }</span>
<a href="#l38.473"></a><span id="l38.473">       if (toks[4] != NULL) { /* extra args. */</span>
<a href="#l38.474"></a><span id="l38.474">         for (i = 0; toks[i + 4] != NULL; ++i) {</span>
<a href="#l38.475"></a><span id="l38.475">           ;</span>
<a href="#l38.476"></a><span id="l38.476">         }</span>
<a href="#l38.477"></a><span id="l38.477" class="difflineminus">-        if ((ip-&gt;ti_args = (char **)NSLDAPI_CALLOC(i + 1, sizeof(char *))) ==</span>
<a href="#l38.478"></a><span id="l38.478" class="difflineplus">+        if ((ip-&gt;ti_args = (char**)NSLDAPI_CALLOC(i + 1, sizeof(char*))) ==</span>
<a href="#l38.479"></a><span id="l38.479">             NULL) {</span>
<a href="#l38.480"></a><span id="l38.480">           free_disptmpl(tmpl);</span>
<a href="#l38.481"></a><span id="l38.481">           return (LDAP_TMPL_ERR_MEM);</span>
<a href="#l38.482"></a><span id="l38.482">         }</span>
<a href="#l38.483"></a><span id="l38.483">         for (i = 0; toks[i + 4] != NULL; ++i) {</span>
<a href="#l38.484"></a><span id="l38.484">           ip-&gt;ti_args[i] = toks[i + 4];</span>
<a href="#l38.485"></a><span id="l38.485">         }</span>
<a href="#l38.486"></a><span id="l38.486">       }</span>
<a href="#l38.487"></a><span id="l38.487" class="difflineminus">-      NSLDAPI_FREE((char *)toks);</span>
<a href="#l38.488"></a><span id="l38.488" class="difflineplus">+      NSLDAPI_FREE((char*)toks);</span>
<a href="#l38.489"></a><span id="l38.489"> </span>
<a href="#l38.490"></a><span id="l38.490">       if (tmpl-&gt;dt_items == NULL) {</span>
<a href="#l38.491"></a><span id="l38.491">         tmpl-&gt;dt_items = rowp = ip;</span>
<a href="#l38.492"></a><span id="l38.492">       } else if (samerow) {</span>
<a href="#l38.493"></a><span id="l38.493">         previp-&gt;ti_next_in_row = ip;</span>
<a href="#l38.494"></a><span id="l38.494">       } else {</span>
<a href="#l38.495"></a><span id="l38.495">         rowp-&gt;ti_next_in_col = ip;</span>
<a href="#l38.496"></a><span id="l38.496">         rowp = ip;</span>
<a href="#l38.497"></a><span id="l38.497" class="difflineat">@@ -667,27 +667,27 @@ static int read_next_tmpl(char **bufp, l</span>
<a href="#l38.498"></a><span id="l38.498">   }</span>
<a href="#l38.499"></a><span id="l38.499"> </span>
<a href="#l38.500"></a><span id="l38.500">   *tmplp = tmpl;</span>
<a href="#l38.501"></a><span id="l38.501">   return (0);</span>
<a href="#l38.502"></a><span id="l38.502"> }</span>
<a href="#l38.503"></a><span id="l38.503"> </span>
<a href="#l38.504"></a><span id="l38.504"> struct tmplerror {</span>
<a href="#l38.505"></a><span id="l38.505">   int e_code;</span>
<a href="#l38.506"></a><span id="l38.506" class="difflineminus">-  char *e_reason;</span>
<a href="#l38.507"></a><span id="l38.507" class="difflineplus">+  char* e_reason;</span>
<a href="#l38.508"></a><span id="l38.508"> };</span>
<a href="#l38.509"></a><span id="l38.509"> </span>
<a href="#l38.510"></a><span id="l38.510"> static struct tmplerror ldap_tmplerrlist[] = {</span>
<a href="#l38.511"></a><span id="l38.511">     {LDAP_TMPL_ERR_VERSION, &quot;Bad template version&quot;},</span>
<a href="#l38.512"></a><span id="l38.512">     {LDAP_TMPL_ERR_MEM, &quot;Out of memory&quot;},</span>
<a href="#l38.513"></a><span id="l38.513">     {LDAP_TMPL_ERR_SYNTAX, &quot;Bad template syntax&quot;},</span>
<a href="#l38.514"></a><span id="l38.514">     {LDAP_TMPL_ERR_FILE, &quot;File error reading template&quot;},</span>
<a href="#l38.515"></a><span id="l38.515">     {-1, 0}};</span>
<a href="#l38.516"></a><span id="l38.516"> </span>
<a href="#l38.517"></a><span id="l38.517" class="difflineminus">-char *LDAP_CALL ldap_tmplerr2string(int err) {</span>
<a href="#l38.518"></a><span id="l38.518" class="difflineplus">+char* LDAP_CALL ldap_tmplerr2string(int err) {</span>
<a href="#l38.519"></a><span id="l38.519">   int i;</span>
<a href="#l38.520"></a><span id="l38.520"> </span>
<a href="#l38.521"></a><span id="l38.521">   for (i = 0; ldap_tmplerrlist[i].e_code != -1; i++) {</span>
<a href="#l38.522"></a><span id="l38.522">     if (err == ldap_tmplerrlist[i].e_code)</span>
<a href="#l38.523"></a><span id="l38.523">       return (ldap_tmplerrlist[i].e_reason);</span>
<a href="#l38.524"></a><span id="l38.524">   }</span>
<a href="#l38.525"></a><span id="l38.525"> </span>
<a href="#l38.526"></a><span id="l38.526">   return (&quot;Unknown error&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/dsparse.c</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/dsparse.c</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineat">@@ -48,40 +48,40 @@</span>
<a href="#l39.4"></a><span id="l39.4"> /*</span>
<a href="#l39.5"></a><span id="l39.5">  * dsparse.c:  parsing routines used by display template and search</span>
<a href="#l39.6"></a><span id="l39.6">  * preference file library routines for LDAP clients.</span>
<a href="#l39.7"></a><span id="l39.7">  *</span>
<a href="#l39.8"></a><span id="l39.8">  */</span>
<a href="#l39.9"></a><span id="l39.9"> </span>
<a href="#l39.10"></a><span id="l39.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l39.11"></a><span id="l39.11"> </span>
<a href="#l39.12"></a><span id="l39.12" class="difflineminus">-static int next_line(char **bufp, long *blenp, char **linep);</span>
<a href="#l39.13"></a><span id="l39.13" class="difflineminus">-static char *next_token(char **sp);</span>
<a href="#l39.14"></a><span id="l39.14" class="difflineplus">+static int next_line(char** bufp, long* blenp, char** linep);</span>
<a href="#l39.15"></a><span id="l39.15" class="difflineplus">+static char* next_token(char** sp);</span>
<a href="#l39.16"></a><span id="l39.16"> </span>
<a href="#l39.17"></a><span id="l39.17" class="difflineminus">-int nsldapi_next_line_tokens(char **bufp, long *blenp, char ***toksp) {</span>
<a href="#l39.18"></a><span id="l39.18" class="difflineplus">+int nsldapi_next_line_tokens(char** bufp, long* blenp, char*** toksp) {</span>
<a href="#l39.19"></a><span id="l39.19">   char *p, *line, *token, **toks;</span>
<a href="#l39.20"></a><span id="l39.20">   int rc, tokcnt;</span>
<a href="#l39.21"></a><span id="l39.21"> </span>
<a href="#l39.22"></a><span id="l39.22">   *toksp = NULL;</span>
<a href="#l39.23"></a><span id="l39.23"> </span>
<a href="#l39.24"></a><span id="l39.24">   if ((rc = next_line(bufp, blenp, &amp;line)) &lt;= 0) {</span>
<a href="#l39.25"></a><span id="l39.25">     return (rc);</span>
<a href="#l39.26"></a><span id="l39.26">   }</span>
<a href="#l39.27"></a><span id="l39.27"> </span>
<a href="#l39.28"></a><span id="l39.28" class="difflineminus">-  if ((toks = (char **)NSLDAPI_CALLOC(1, sizeof(char *))) == NULL) {</span>
<a href="#l39.29"></a><span id="l39.29" class="difflineplus">+  if ((toks = (char**)NSLDAPI_CALLOC(1, sizeof(char*))) == NULL) {</span>
<a href="#l39.30"></a><span id="l39.30">     NSLDAPI_FREE(line);</span>
<a href="#l39.31"></a><span id="l39.31">     return (-1);</span>
<a href="#l39.32"></a><span id="l39.32">   }</span>
<a href="#l39.33"></a><span id="l39.33">   tokcnt = 0;</span>
<a href="#l39.34"></a><span id="l39.34"> </span>
<a href="#l39.35"></a><span id="l39.35">   p = line;</span>
<a href="#l39.36"></a><span id="l39.36">   while ((token = next_token(&amp;p)) != NULL) {</span>
<a href="#l39.37"></a><span id="l39.37" class="difflineminus">-    if ((toks = (char **)NSLDAPI_REALLOC(</span>
<a href="#l39.38"></a><span id="l39.38" class="difflineminus">-             toks, (tokcnt + 2) * sizeof(char *))) == NULL) {</span>
<a href="#l39.39"></a><span id="l39.39" class="difflineminus">-      NSLDAPI_FREE((char *)toks);</span>
<a href="#l39.40"></a><span id="l39.40" class="difflineplus">+    if ((toks = (char**)NSLDAPI_REALLOC(toks, (tokcnt + 2) * sizeof(char*))) ==</span>
<a href="#l39.41"></a><span id="l39.41" class="difflineplus">+        NULL) {</span>
<a href="#l39.42"></a><span id="l39.42" class="difflineplus">+      NSLDAPI_FREE((char*)toks);</span>
<a href="#l39.43"></a><span id="l39.43">       NSLDAPI_FREE(line);</span>
<a href="#l39.44"></a><span id="l39.44">       return (-1);</span>
<a href="#l39.45"></a><span id="l39.45">     }</span>
<a href="#l39.46"></a><span id="l39.46">     toks[tokcnt] = token;</span>
<a href="#l39.47"></a><span id="l39.47">     toks[++tokcnt] = NULL;</span>
<a href="#l39.48"></a><span id="l39.48">   }</span>
<a href="#l39.49"></a><span id="l39.49"> </span>
<a href="#l39.50"></a><span id="l39.50">   if (tokcnt == 1 &amp;&amp; strcasecmp(toks[0], &quot;END&quot;) == 0) {</span>
<a href="#l39.51"></a><span id="l39.51" class="difflineat">@@ -89,26 +89,26 @@ int nsldapi_next_line_tokens(char **bufp</span>
<a href="#l39.52"></a><span id="l39.52">     nsldapi_free_strarray(toks);</span>
<a href="#l39.53"></a><span id="l39.53">     toks = NULL;</span>
<a href="#l39.54"></a><span id="l39.54">   }</span>
<a href="#l39.55"></a><span id="l39.55"> </span>
<a href="#l39.56"></a><span id="l39.56">   NSLDAPI_FREE(line);</span>
<a href="#l39.57"></a><span id="l39.57"> </span>
<a href="#l39.58"></a><span id="l39.58">   if (tokcnt == 0) {</span>
<a href="#l39.59"></a><span id="l39.59">     if (toks != NULL) {</span>
<a href="#l39.60"></a><span id="l39.60" class="difflineminus">-      NSLDAPI_FREE((char *)toks);</span>
<a href="#l39.61"></a><span id="l39.61" class="difflineplus">+      NSLDAPI_FREE((char*)toks);</span>
<a href="#l39.62"></a><span id="l39.62">     }</span>
<a href="#l39.63"></a><span id="l39.63">   } else {</span>
<a href="#l39.64"></a><span id="l39.64">     *toksp = toks;</span>
<a href="#l39.65"></a><span id="l39.65">   }</span>
<a href="#l39.66"></a><span id="l39.66"> </span>
<a href="#l39.67"></a><span id="l39.67">   return (tokcnt);</span>
<a href="#l39.68"></a><span id="l39.68"> }</span>
<a href="#l39.69"></a><span id="l39.69"> </span>
<a href="#l39.70"></a><span id="l39.70" class="difflineminus">-static int next_line(char **bufp, long *blenp, char **linep) {</span>
<a href="#l39.71"></a><span id="l39.71" class="difflineplus">+static int next_line(char** bufp, long* blenp, char** linep) {</span>
<a href="#l39.72"></a><span id="l39.72">   char *linestart, *line, *p;</span>
<a href="#l39.73"></a><span id="l39.73">   long plen;</span>
<a href="#l39.74"></a><span id="l39.74"> </span>
<a href="#l39.75"></a><span id="l39.75">   linestart = *bufp;</span>
<a href="#l39.76"></a><span id="l39.76">   p = *bufp;</span>
<a href="#l39.77"></a><span id="l39.77">   plen = *blenp;</span>
<a href="#l39.78"></a><span id="l39.78"> </span>
<a href="#l39.79"></a><span id="l39.79">   do {</span>
<a href="#l39.80"></a><span id="l39.80" class="difflineat">@@ -147,17 +147,17 @@ static int next_line(char **bufp, long *</span>
<a href="#l39.81"></a><span id="l39.81">   }</span>
<a href="#l39.82"></a><span id="l39.82"> </span>
<a href="#l39.83"></a><span id="l39.83">   SAFEMEMCPY(line, linestart, p - linestart);</span>
<a href="#l39.84"></a><span id="l39.84">   line[p - linestart - 1] = '\0';</span>
<a href="#l39.85"></a><span id="l39.85">   *linep = line;</span>
<a href="#l39.86"></a><span id="l39.86">   return (strlen(line));</span>
<a href="#l39.87"></a><span id="l39.87"> }</span>
<a href="#l39.88"></a><span id="l39.88"> </span>
<a href="#l39.89"></a><span id="l39.89" class="difflineminus">-static char *next_token(char **sp) {</span>
<a href="#l39.90"></a><span id="l39.90" class="difflineplus">+static char* next_token(char** sp) {</span>
<a href="#l39.91"></a><span id="l39.91">   int in_quote = 0;</span>
<a href="#l39.92"></a><span id="l39.92">   char *p, *tokstart, *t;</span>
<a href="#l39.93"></a><span id="l39.93"> </span>
<a href="#l39.94"></a><span id="l39.94">   if (**sp == '\0') {</span>
<a href="#l39.95"></a><span id="l39.95">     return (NULL);</span>
<a href="#l39.96"></a><span id="l39.96">   }</span>
<a href="#l39.97"></a><span id="l39.97"> </span>
<a href="#l39.98"></a><span id="l39.98">   p = *sp;</span>
<a href="#l39.99"></a><span id="l39.99" class="difflineat">@@ -197,18 +197,18 @@ static char *next_token(char **sp) {</span>
<a href="#l39.100"></a><span id="l39.100"> </span>
<a href="#l39.101"></a><span id="l39.101">   if (t == tokstart) {</span>
<a href="#l39.102"></a><span id="l39.102">     return (NULL);</span>
<a href="#l39.103"></a><span id="l39.103">   }</span>
<a href="#l39.104"></a><span id="l39.104"> </span>
<a href="#l39.105"></a><span id="l39.105">   return (nsldapi_strdup(tokstart));</span>
<a href="#l39.106"></a><span id="l39.106"> }</span>
<a href="#l39.107"></a><span id="l39.107"> </span>
<a href="#l39.108"></a><span id="l39.108" class="difflineminus">-void nsldapi_free_strarray(char **sap) {</span>
<a href="#l39.109"></a><span id="l39.109" class="difflineplus">+void nsldapi_free_strarray(char** sap) {</span>
<a href="#l39.110"></a><span id="l39.110">   int i;</span>
<a href="#l39.111"></a><span id="l39.111"> </span>
<a href="#l39.112"></a><span id="l39.112">   if (sap != NULL) {</span>
<a href="#l39.113"></a><span id="l39.113">     for (i = 0; sap[i] != NULL; ++i) {</span>
<a href="#l39.114"></a><span id="l39.114">       NSLDAPI_FREE(sap[i]);</span>
<a href="#l39.115"></a><span id="l39.115">     }</span>
<a href="#l39.116"></a><span id="l39.116" class="difflineminus">-    NSLDAPI_FREE((char *)sap);</span>
<a href="#l39.117"></a><span id="l39.117" class="difflineplus">+    NSLDAPI_FREE((char*)sap);</span>
<a href="#l39.118"></a><span id="l39.118">   }</span>
<a href="#l39.119"></a><span id="l39.119"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/error.c</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/error.c</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineat">@@ -33,17 +33,17 @@</span>
<a href="#l40.4"></a><span id="l40.4">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l40.5"></a><span id="l40.5">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l40.6"></a><span id="l40.6">  *</span>
<a href="#l40.7"></a><span id="l40.7">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l40.8"></a><span id="l40.8"> #include &quot;ldap-int.h&quot;</span>
<a href="#l40.9"></a><span id="l40.9"> </span>
<a href="#l40.10"></a><span id="l40.10"> struct ldaperror {</span>
<a href="#l40.11"></a><span id="l40.11">   int e_code;</span>
<a href="#l40.12"></a><span id="l40.12" class="difflineminus">-  char *e_reason;</span>
<a href="#l40.13"></a><span id="l40.13" class="difflineplus">+  char* e_reason;</span>
<a href="#l40.14"></a><span id="l40.14"> };</span>
<a href="#l40.15"></a><span id="l40.15"> </span>
<a href="#l40.16"></a><span id="l40.16"> static struct ldaperror ldap_errlist[] = {</span>
<a href="#l40.17"></a><span id="l40.17">     {LDAP_SUCCESS, &quot;Success&quot;},</span>
<a href="#l40.18"></a><span id="l40.18">     {LDAP_OPERATIONS_ERROR, &quot;Operations error&quot;},</span>
<a href="#l40.19"></a><span id="l40.19">     {LDAP_PROTOCOL_ERROR, &quot;Protocol error&quot;},</span>
<a href="#l40.20"></a><span id="l40.20">     {LDAP_TIMELIMIT_EXCEEDED, &quot;Timelimit exceeded&quot;},</span>
<a href="#l40.21"></a><span id="l40.21">     {LDAP_SIZELIMIT_EXCEEDED, &quot;Sizelimit exceeded&quot;},</span>
<a href="#l40.22"></a><span id="l40.22" class="difflineat">@@ -106,43 +106,43 @@ static struct ldaperror ldap_errlist[] =</span>
<a href="#l40.23"></a><span id="l40.23">     {LDAP_NOT_SUPPORTED, &quot;Not supported by this version of the LDAP protocol&quot;},</span>
<a href="#l40.24"></a><span id="l40.24">     {LDAP_CONTROL_NOT_FOUND, &quot;Requested LDAP control not found&quot;},</span>
<a href="#l40.25"></a><span id="l40.25">     {LDAP_NO_RESULTS_RETURNED, &quot;No results returned&quot;},</span>
<a href="#l40.26"></a><span id="l40.26">     {LDAP_MORE_RESULTS_TO_RETURN, &quot;More results to return&quot;},</span>
<a href="#l40.27"></a><span id="l40.27">     {LDAP_CLIENT_LOOP, &quot;Client detected loop&quot;},</span>
<a href="#l40.28"></a><span id="l40.28">     {LDAP_REFERRAL_LIMIT_EXCEEDED, &quot;Referral hop limit exceeded&quot;},</span>
<a href="#l40.29"></a><span id="l40.29">     {-1, 0}};</span>
<a href="#l40.30"></a><span id="l40.30"> </span>
<a href="#l40.31"></a><span id="l40.31" class="difflineminus">-char *LDAP_CALL ldap_err2string(int err) {</span>
<a href="#l40.32"></a><span id="l40.32" class="difflineplus">+char* LDAP_CALL ldap_err2string(int err) {</span>
<a href="#l40.33"></a><span id="l40.33">   int i;</span>
<a href="#l40.34"></a><span id="l40.34"> </span>
<a href="#l40.35"></a><span id="l40.35">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_err2string\n&quot;, 0, 0, 0);</span>
<a href="#l40.36"></a><span id="l40.36"> </span>
<a href="#l40.37"></a><span id="l40.37">   for (i = 0; ldap_errlist[i].e_code != -1; i++) {</span>
<a href="#l40.38"></a><span id="l40.38">     if (err == ldap_errlist[i].e_code) return (ldap_errlist[i].e_reason);</span>
<a href="#l40.39"></a><span id="l40.39">   }</span>
<a href="#l40.40"></a><span id="l40.40"> </span>
<a href="#l40.41"></a><span id="l40.41">   return (&quot;Unknown error&quot;);</span>
<a href="#l40.42"></a><span id="l40.42"> }</span>
<a href="#l40.43"></a><span id="l40.43"> </span>
<a href="#l40.44"></a><span id="l40.44" class="difflineminus">-static char *nsldapi_safe_strerror(int e) {</span>
<a href="#l40.45"></a><span id="l40.45" class="difflineminus">-  char *s;</span>
<a href="#l40.46"></a><span id="l40.46" class="difflineplus">+static char* nsldapi_safe_strerror(int e) {</span>
<a href="#l40.47"></a><span id="l40.47" class="difflineplus">+  char* s;</span>
<a href="#l40.48"></a><span id="l40.48"> </span>
<a href="#l40.49"></a><span id="l40.49">   if ((s = strerror(e)) == NULL) {</span>
<a href="#l40.50"></a><span id="l40.50">     s = &quot;unknown error&quot;;</span>
<a href="#l40.51"></a><span id="l40.51">   }</span>
<a href="#l40.52"></a><span id="l40.52"> </span>
<a href="#l40.53"></a><span id="l40.53">   return (s);</span>
<a href="#l40.54"></a><span id="l40.54"> }</span>
<a href="#l40.55"></a><span id="l40.55"> </span>
<a href="#l40.56"></a><span id="l40.56" class="difflineminus">-void LDAP_CALL ldap_perror(LDAP *ld, const char *s) {</span>
<a href="#l40.57"></a><span id="l40.57" class="difflineplus">+void LDAP_CALL ldap_perror(LDAP* ld, const char* s) {</span>
<a href="#l40.58"></a><span id="l40.58">   int i, err;</span>
<a href="#l40.59"></a><span id="l40.59" class="difflineminus">-  char *matched = NULL;</span>
<a href="#l40.60"></a><span id="l40.60" class="difflineminus">-  char *errmsg = NULL;</span>
<a href="#l40.61"></a><span id="l40.61" class="difflineminus">-  char *separator;</span>
<a href="#l40.62"></a><span id="l40.62" class="difflineplus">+  char* matched = NULL;</span>
<a href="#l40.63"></a><span id="l40.63" class="difflineplus">+  char* errmsg = NULL;</span>
<a href="#l40.64"></a><span id="l40.64" class="difflineplus">+  char* separator;</span>
<a href="#l40.65"></a><span id="l40.65">   char msg[1024];</span>
<a href="#l40.66"></a><span id="l40.66"> </span>
<a href="#l40.67"></a><span id="l40.67">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_perror\n&quot;, 0, 0, 0);</span>
<a href="#l40.68"></a><span id="l40.68"> </span>
<a href="#l40.69"></a><span id="l40.69">   if (s == NULL) {</span>
<a href="#l40.70"></a><span id="l40.70">     s = separator = &quot;&quot;;</span>
<a href="#l40.71"></a><span id="l40.71">   } else {</span>
<a href="#l40.72"></a><span id="l40.72">     separator = &quot;: &quot;;</span>
<a href="#l40.73"></a><span id="l40.73" class="difflineat">@@ -180,30 +180,30 @@ void LDAP_CALL ldap_perror(LDAP *ld, con</span>
<a href="#l40.74"></a><span id="l40.74">       return;</span>
<a href="#l40.75"></a><span id="l40.75">     }</span>
<a href="#l40.76"></a><span id="l40.76">   }</span>
<a href="#l40.77"></a><span id="l40.77">   snprintf(msg, sizeof(msg), &quot;%s%sNot an LDAP errno %d\n&quot;, s, separator, err);</span>
<a href="#l40.78"></a><span id="l40.78">   ber_err_print(msg);</span>
<a href="#l40.79"></a><span id="l40.79">   LDAP_MUTEX_UNLOCK(ld, LDAP_ERR_LOCK);</span>
<a href="#l40.80"></a><span id="l40.80"> }</span>
<a href="#l40.81"></a><span id="l40.81"> </span>
<a href="#l40.82"></a><span id="l40.82" class="difflineminus">-int LDAP_CALL ldap_result2error(LDAP *ld, LDAPMessage *r, int freeit) {</span>
<a href="#l40.83"></a><span id="l40.83" class="difflineplus">+int LDAP_CALL ldap_result2error(LDAP* ld, LDAPMessage* r, int freeit) {</span>
<a href="#l40.84"></a><span id="l40.84">   int lderr_parse, lderr;</span>
<a href="#l40.85"></a><span id="l40.85"> </span>
<a href="#l40.86"></a><span id="l40.86">   lderr_parse =</span>
<a href="#l40.87"></a><span id="l40.87">       ldap_parse_result(ld, r, &amp;lderr, NULL, NULL, NULL, NULL, freeit);</span>
<a href="#l40.88"></a><span id="l40.88"> </span>
<a href="#l40.89"></a><span id="l40.89">   if (lderr_parse != LDAP_SUCCESS) {</span>
<a href="#l40.90"></a><span id="l40.90">     return (lderr_parse);</span>
<a href="#l40.91"></a><span id="l40.91">   }</span>
<a href="#l40.92"></a><span id="l40.92"> </span>
<a href="#l40.93"></a><span id="l40.93">   return (lderr);</span>
<a href="#l40.94"></a><span id="l40.94"> }</span>
<a href="#l40.95"></a><span id="l40.95"> </span>
<a href="#l40.96"></a><span id="l40.96" class="difflineminus">-int LDAP_CALL ldap_get_lderrno(LDAP *ld, char **m, char **s) {</span>
<a href="#l40.97"></a><span id="l40.97" class="difflineplus">+int LDAP_CALL ldap_get_lderrno(LDAP* ld, char** m, char** s) {</span>
<a href="#l40.98"></a><span id="l40.98">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l40.99"></a><span id="l40.99">     return (LDAP_PARAM_ERROR); /* punt */</span>
<a href="#l40.100"></a><span id="l40.100">   }</span>
<a href="#l40.101"></a><span id="l40.101"> </span>
<a href="#l40.102"></a><span id="l40.102">   if (ld-&gt;ld_get_lderrno_fn == NULL) {</span>
<a href="#l40.103"></a><span id="l40.103">     if (m != NULL) {</span>
<a href="#l40.104"></a><span id="l40.104">       *m = ld-&gt;ld_matched;</span>
<a href="#l40.105"></a><span id="l40.105">     }</span>
<a href="#l40.106"></a><span id="l40.106" class="difflineat">@@ -219,17 +219,17 @@ int LDAP_CALL ldap_get_lderrno(LDAP *ld,</span>
<a href="#l40.107"></a><span id="l40.107"> /*</span>
<a href="#l40.108"></a><span id="l40.108">  * Note: there is no need for callers of ldap_set_lderrno() to lock the</span>
<a href="#l40.109"></a><span id="l40.109">  * ld mutex.  If applications intend to share an LDAP session handle</span>
<a href="#l40.110"></a><span id="l40.110">  * between threads they *must* perform their own locking around the</span>
<a href="#l40.111"></a><span id="l40.111">  * session handle or they must install a &quot;set lderrno&quot; thread callback</span>
<a href="#l40.112"></a><span id="l40.112">  * function.</span>
<a href="#l40.113"></a><span id="l40.113">  *</span>
<a href="#l40.114"></a><span id="l40.114">  */</span>
<a href="#l40.115"></a><span id="l40.115" class="difflineminus">-int LDAP_CALL ldap_set_lderrno(LDAP *ld, int e, char *m, char *s) {</span>
<a href="#l40.116"></a><span id="l40.116" class="difflineplus">+int LDAP_CALL ldap_set_lderrno(LDAP* ld, int e, char* m, char* s) {</span>
<a href="#l40.117"></a><span id="l40.117">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l40.118"></a><span id="l40.118">     return (LDAP_PARAM_ERROR);</span>
<a href="#l40.119"></a><span id="l40.119">   }</span>
<a href="#l40.120"></a><span id="l40.120"> </span>
<a href="#l40.121"></a><span id="l40.121">   if (ld-&gt;ld_set_lderrno_fn != NULL) {</span>
<a href="#l40.122"></a><span id="l40.122">     ld-&gt;ld_set_lderrno_fn(e, m, s, ld-&gt;ld_lderrno_arg);</span>
<a href="#l40.123"></a><span id="l40.123">   } else {</span>
<a href="#l40.124"></a><span id="l40.124">     LDAP_MUTEX_LOCK(ld, LDAP_ERR_LOCK);</span>
<a href="#l40.125"></a><span id="l40.125" class="difflineat">@@ -249,21 +249,21 @@ int LDAP_CALL ldap_set_lderrno(LDAP *ld,</span>
<a href="#l40.126"></a><span id="l40.126"> }</span>
<a href="#l40.127"></a><span id="l40.127"> </span>
<a href="#l40.128"></a><span id="l40.128"> /*</span>
<a href="#l40.129"></a><span id="l40.129">  * Returns an LDAP error that says whether parse succeeded.  The error code</span>
<a href="#l40.130"></a><span id="l40.130">  * from the LDAP result itself is returned in the errcodep result parameter.</span>
<a href="#l40.131"></a><span id="l40.131">  * If any of the result params. (errcodep, matchednp, errmsgp, referralsp,</span>
<a href="#l40.132"></a><span id="l40.132">  * or serverctrlsp) are NULL we don't return that info.</span>
<a href="#l40.133"></a><span id="l40.133">  */</span>
<a href="#l40.134"></a><span id="l40.134" class="difflineminus">-int LDAP_CALL ldap_parse_result(LDAP *ld, LDAPMessage *res, int *errcodep,</span>
<a href="#l40.135"></a><span id="l40.135" class="difflineminus">-                                char **matchednp, char **errmsgp,</span>
<a href="#l40.136"></a><span id="l40.136" class="difflineminus">-                                char ***referralsp, LDAPControl ***serverctrlsp,</span>
<a href="#l40.137"></a><span id="l40.137" class="difflineplus">+int LDAP_CALL ldap_parse_result(LDAP* ld, LDAPMessage* res, int* errcodep,</span>
<a href="#l40.138"></a><span id="l40.138" class="difflineplus">+                                char** matchednp, char** errmsgp,</span>
<a href="#l40.139"></a><span id="l40.139" class="difflineplus">+                                char*** referralsp, LDAPControl*** serverctrlsp,</span>
<a href="#l40.140"></a><span id="l40.140">                                 int freeit) {</span>
<a href="#l40.141"></a><span id="l40.141" class="difflineminus">-  LDAPMessage *lm;</span>
<a href="#l40.142"></a><span id="l40.142" class="difflineplus">+  LDAPMessage* lm;</span>
<a href="#l40.143"></a><span id="l40.143">   int err, errcode;</span>
<a href="#l40.144"></a><span id="l40.144">   char *m, *e;</span>
<a href="#l40.145"></a><span id="l40.145">   m = e = NULL;</span>
<a href="#l40.146"></a><span id="l40.146"> </span>
<a href="#l40.147"></a><span id="l40.147">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_parse_result\n&quot;, 0, 0, 0);</span>
<a href="#l40.148"></a><span id="l40.148"> </span>
<a href="#l40.149"></a><span id="l40.149">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) ||</span>
<a href="#l40.150"></a><span id="l40.150">       !NSLDAPI_VALID_LDAPMESSAGE_POINTER(res)) {</span>
<a href="#l40.151"></a><span id="l40.151" class="difflineat">@@ -333,19 +333,19 @@ int LDAP_CALL ldap_parse_result(LDAP *ld</span>
<a href="#l40.152"></a><span id="l40.152"> </span>
<a href="#l40.153"></a><span id="l40.153">   return (err);</span>
<a href="#l40.154"></a><span id="l40.154"> }</span>
<a href="#l40.155"></a><span id="l40.155"> </span>
<a href="#l40.156"></a><span id="l40.156"> /*</span>
<a href="#l40.157"></a><span id="l40.157">  * returns an LDAP error code indicating success or failure of parsing</span>
<a href="#l40.158"></a><span id="l40.158">  * does NOT set any error information inside &quot;ld&quot;</span>
<a href="#l40.159"></a><span id="l40.159">  */</span>
<a href="#l40.160"></a><span id="l40.160" class="difflineminus">-int nsldapi_parse_result(LDAP *ld, int msgtype, BerElement *rber, int *errcodep,</span>
<a href="#l40.161"></a><span id="l40.161" class="difflineminus">-                         char **matchednp, char **errmsgp, char ***referralsp,</span>
<a href="#l40.162"></a><span id="l40.162" class="difflineminus">-                         LDAPControl ***serverctrlsp) {</span>
<a href="#l40.163"></a><span id="l40.163" class="difflineplus">+int nsldapi_parse_result(LDAP* ld, int msgtype, BerElement* rber, int* errcodep,</span>
<a href="#l40.164"></a><span id="l40.164" class="difflineplus">+                         char** matchednp, char** errmsgp, char*** referralsp,</span>
<a href="#l40.165"></a><span id="l40.165" class="difflineplus">+                         LDAPControl*** serverctrlsp) {</span>
<a href="#l40.166"></a><span id="l40.166">   BerElement ber;</span>
<a href="#l40.167"></a><span id="l40.167">   ber_len_t len;</span>
<a href="#l40.168"></a><span id="l40.168">   ber_int_t errcode;</span>
<a href="#l40.169"></a><span id="l40.169">   int berrc, err;</span>
<a href="#l40.170"></a><span id="l40.170">   char *m, *e;</span>
<a href="#l40.171"></a><span id="l40.171"> </span>
<a href="#l40.172"></a><span id="l40.172">   /*</span>
<a href="#l40.173"></a><span id="l40.173">    * Parse the result message.  LDAPv3 result messages look like this:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/extendop.c</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/extendop.c</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineat">@@ -44,21 +44,21 @@</span>
<a href="#l41.4"></a><span id="l41.4">  * Example:</span>
<a href="#l41.5"></a><span id="l41.5">  * struct berval exdata;</span>
<a href="#l41.6"></a><span id="l41.6">  * char *exoid;</span>
<a href="#l41.7"></a><span id="l41.7">  * int err, msgid;</span>
<a href="#l41.8"></a><span id="l41.8">  * ... fill in oid and data ...</span>
<a href="#l41.9"></a><span id="l41.9">  * err = ldap_extended_operation(ld, exoid, &amp;exdata, NULL, NULL, &amp;msgid);</span>
<a href="#l41.10"></a><span id="l41.10">  */</span>
<a href="#l41.11"></a><span id="l41.11"> </span>
<a href="#l41.12"></a><span id="l41.12" class="difflineminus">-int LDAP_CALL ldap_extended_operation(LDAP *ld, const char *exoid,</span>
<a href="#l41.13"></a><span id="l41.13" class="difflineminus">-                                      const struct berval *exdata,</span>
<a href="#l41.14"></a><span id="l41.14" class="difflineminus">-                                      LDAPControl **serverctrls,</span>
<a href="#l41.15"></a><span id="l41.15" class="difflineminus">-                                      LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l41.16"></a><span id="l41.16" class="difflineminus">-  BerElement *ber;</span>
<a href="#l41.17"></a><span id="l41.17" class="difflineplus">+int LDAP_CALL ldap_extended_operation(LDAP* ld, const char* exoid,</span>
<a href="#l41.18"></a><span id="l41.18" class="difflineplus">+                                      const struct berval* exdata,</span>
<a href="#l41.19"></a><span id="l41.19" class="difflineplus">+                                      LDAPControl** serverctrls,</span>
<a href="#l41.20"></a><span id="l41.20" class="difflineplus">+                                      LDAPControl** clientctrls, int* msgidp) {</span>
<a href="#l41.21"></a><span id="l41.21" class="difflineplus">+  BerElement* ber;</span>
<a href="#l41.22"></a><span id="l41.22">   int rc, msgid;</span>
<a href="#l41.23"></a><span id="l41.23"> </span>
<a href="#l41.24"></a><span id="l41.24">   /*</span>
<a href="#l41.25"></a><span id="l41.25">    * the ldapv3 extended operation request looks like this:</span>
<a href="#l41.26"></a><span id="l41.26">    *</span>
<a href="#l41.27"></a><span id="l41.27">    * ExtendedRequest ::= [APPLICATION 23] SEQUENCE {</span>
<a href="#l41.28"></a><span id="l41.28">    *   requestName  LDAPOID,</span>
<a href="#l41.29"></a><span id="l41.29">    *   requestValue  OCTET STRING</span>
<a href="#l41.30"></a><span id="l41.30" class="difflineat">@@ -145,31 +145,31 @@ int LDAP_CALL ldap_extended_operation(LD</span>
<a href="#l41.31"></a><span id="l41.31">  *</span>
<a href="#l41.32"></a><span id="l41.32">  * Example:</span>
<a href="#l41.33"></a><span id="l41.33">  * struct berval exdata, exretval;</span>
<a href="#l41.34"></a><span id="l41.34">  * char *exoid;</span>
<a href="#l41.35"></a><span id="l41.35">  * int rc;</span>
<a href="#l41.36"></a><span id="l41.36">  * ... fill in oid and data ...</span>
<a href="#l41.37"></a><span id="l41.37">  * rc = ldap_extended_operation_s(ld, exoid, &amp;exdata, &amp;exretval);</span>
<a href="#l41.38"></a><span id="l41.38">  */</span>
<a href="#l41.39"></a><span id="l41.39" class="difflineminus">-int LDAP_CALL ldap_extended_operation_s(LDAP *ld, const char *requestoid,</span>
<a href="#l41.40"></a><span id="l41.40" class="difflineminus">-                                        const struct berval *requestdata,</span>
<a href="#l41.41"></a><span id="l41.41" class="difflineminus">-                                        LDAPControl **serverctrls,</span>
<a href="#l41.42"></a><span id="l41.42" class="difflineminus">-                                        LDAPControl **clientctrls,</span>
<a href="#l41.43"></a><span id="l41.43" class="difflineminus">-                                        char **retoidp,</span>
<a href="#l41.44"></a><span id="l41.44" class="difflineminus">-                                        struct berval **retdatap) {</span>
<a href="#l41.45"></a><span id="l41.45" class="difflineplus">+int LDAP_CALL ldap_extended_operation_s(LDAP* ld, const char* requestoid,</span>
<a href="#l41.46"></a><span id="l41.46" class="difflineplus">+                                        const struct berval* requestdata,</span>
<a href="#l41.47"></a><span id="l41.47" class="difflineplus">+                                        LDAPControl** serverctrls,</span>
<a href="#l41.48"></a><span id="l41.48" class="difflineplus">+                                        LDAPControl** clientctrls,</span>
<a href="#l41.49"></a><span id="l41.49" class="difflineplus">+                                        char** retoidp,</span>
<a href="#l41.50"></a><span id="l41.50" class="difflineplus">+                                        struct berval** retdatap) {</span>
<a href="#l41.51"></a><span id="l41.51">   int err, msgid;</span>
<a href="#l41.52"></a><span id="l41.52" class="difflineminus">-  LDAPMessage *result;</span>
<a href="#l41.53"></a><span id="l41.53" class="difflineplus">+  LDAPMessage* result;</span>
<a href="#l41.54"></a><span id="l41.54"> </span>
<a href="#l41.55"></a><span id="l41.55">   if ((err = ldap_extended_operation(ld, requestoid, requestdata, serverctrls,</span>
<a href="#l41.56"></a><span id="l41.56">                                      clientctrls, &amp;msgid)) != LDAP_SUCCESS) {</span>
<a href="#l41.57"></a><span id="l41.57">     return (err);</span>
<a href="#l41.58"></a><span id="l41.58">   }</span>
<a href="#l41.59"></a><span id="l41.59"> </span>
<a href="#l41.60"></a><span id="l41.60" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)0, &amp;result) == -1) {</span>
<a href="#l41.61"></a><span id="l41.61" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)0, &amp;result) == -1) {</span>
<a href="#l41.62"></a><span id="l41.62">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l41.63"></a><span id="l41.63">   }</span>
<a href="#l41.64"></a><span id="l41.64"> </span>
<a href="#l41.65"></a><span id="l41.65">   if ((err = ldap_parse_extended_result(ld, result, retoidp, retdatap, 0)) !=</span>
<a href="#l41.66"></a><span id="l41.66">       LDAP_SUCCESS) {</span>
<a href="#l41.67"></a><span id="l41.67">     ldap_msgfree(result);</span>
<a href="#l41.68"></a><span id="l41.68">     return (err);</span>
<a href="#l41.69"></a><span id="l41.69">   }</span>
<a href="#l41.70"></a><span id="l41.70" class="difflineat">@@ -177,24 +177,24 @@ int LDAP_CALL ldap_extended_operation_s(</span>
<a href="#l41.71"></a><span id="l41.71">   return (ldap_result2error(ld, result, 1));</span>
<a href="#l41.72"></a><span id="l41.72"> }</span>
<a href="#l41.73"></a><span id="l41.73"> </span>
<a href="#l41.74"></a><span id="l41.74"> /*</span>
<a href="#l41.75"></a><span id="l41.75">  * Pull the oid returned by the server and the data out of an extended</span>
<a href="#l41.76"></a><span id="l41.76">  * operation result.  Return an LDAP error code.</span>
<a href="#l41.77"></a><span id="l41.77">  */</span>
<a href="#l41.78"></a><span id="l41.78"> int LDAP_CALL ldap_parse_extended_result(</span>
<a href="#l41.79"></a><span id="l41.79" class="difflineminus">-    LDAP *ld, LDAPMessage *res, char **retoidp, /* may be NULL */</span>
<a href="#l41.80"></a><span id="l41.80" class="difflineminus">-    struct berval **retdatap,                   /* may be NULL */</span>
<a href="#l41.81"></a><span id="l41.81" class="difflineplus">+    LDAP* ld, LDAPMessage* res, char** retoidp, /* may be NULL */</span>
<a href="#l41.82"></a><span id="l41.82" class="difflineplus">+    struct berval** retdatap,                   /* may be NULL */</span>
<a href="#l41.83"></a><span id="l41.83">     int freeit) {</span>
<a href="#l41.84"></a><span id="l41.84">   struct berelement ber;</span>
<a href="#l41.85"></a><span id="l41.85">   ber_len_t len;</span>
<a href="#l41.86"></a><span id="l41.86">   ber_int_t err;</span>
<a href="#l41.87"></a><span id="l41.87">   char *m, *e, *roid;</span>
<a href="#l41.88"></a><span id="l41.88" class="difflineminus">-  struct berval *rdata;</span>
<a href="#l41.89"></a><span id="l41.89" class="difflineplus">+  struct berval* rdata;</span>
<a href="#l41.90"></a><span id="l41.90"> </span>
<a href="#l41.91"></a><span id="l41.91">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_parse_extended_result\n&quot;, 0, 0, 0);</span>
<a href="#l41.92"></a><span id="l41.92"> </span>
<a href="#l41.93"></a><span id="l41.93">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l41.94"></a><span id="l41.94">     return (LDAP_PARAM_ERROR);</span>
<a href="#l41.95"></a><span id="l41.95">   }</span>
<a href="#l41.96"></a><span id="l41.96"> </span>
<a href="#l41.97"></a><span id="l41.97">   if (!NSLDAPI_VALID_LDAPMESSAGE_EXRESULT_POINTER(res)) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l42.1"></a><span id="l42.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/free.c</span>
<a href="#l42.2"></a><span id="l42.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/free.c</span>
<a href="#l42.3"></a><span id="l42.3" class="difflineat">@@ -46,17 +46,17 @@</span>
<a href="#l42.4"></a><span id="l42.4"> #if 0</span>
<a href="#l42.5"></a><span id="l42.5"> #  ifndef lint</span>
<a href="#l42.6"></a><span id="l42.6"> static char copyright[] = &quot;@(#) Copyright (c) 1994 The Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l42.7"></a><span id="l42.7"> #  endif</span>
<a href="#l42.8"></a><span id="l42.8"> #endif</span>
<a href="#l42.9"></a><span id="l42.9"> </span>
<a href="#l42.10"></a><span id="l42.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l42.11"></a><span id="l42.11"> </span>
<a href="#l42.12"></a><span id="l42.12" class="difflineminus">-void LDAP_CALL ldap_getfilter_free(LDAPFiltDesc *lfdp) {</span>
<a href="#l42.13"></a><span id="l42.13" class="difflineplus">+void LDAP_CALL ldap_getfilter_free(LDAPFiltDesc* lfdp) {</span>
<a href="#l42.14"></a><span id="l42.14">   LDAPFiltList *flp, *nextflp;</span>
<a href="#l42.15"></a><span id="l42.15">   LDAPFiltInfo *fip, *nextfip;</span>
<a href="#l42.16"></a><span id="l42.16"> </span>
<a href="#l42.17"></a><span id="l42.17">   if (lfdp == NULL) {</span>
<a href="#l42.18"></a><span id="l42.18">     return;</span>
<a href="#l42.19"></a><span id="l42.19">   }</span>
<a href="#l42.20"></a><span id="l42.20"> </span>
<a href="#l42.21"></a><span id="l42.21">   for (flp = lfdp-&gt;lfd_filtlist; flp != NULL; flp = nextflp) {</span>
<a href="#l42.22"></a><span id="l42.22" class="difflineat">@@ -92,17 +92,17 @@ void LDAP_CALL ldap_getfilter_free(LDAPF</span>
<a href="#l42.23"></a><span id="l42.23">   NSLDAPI_FREE(lfdp);</span>
<a href="#l42.24"></a><span id="l42.24"> }</span>
<a href="#l42.25"></a><span id="l42.25"> </span>
<a href="#l42.26"></a><span id="l42.26"> /*</span>
<a href="#l42.27"></a><span id="l42.27">  * free a null-terminated array of pointers to mod structures. the</span>
<a href="#l42.28"></a><span id="l42.28">  * structures are freed, not the array itself, unless the freemods</span>
<a href="#l42.29"></a><span id="l42.29">  * flag is set.</span>
<a href="#l42.30"></a><span id="l42.30">  */</span>
<a href="#l42.31"></a><span id="l42.31" class="difflineminus">-void LDAP_CALL ldap_mods_free(LDAPMod **mods, int freemods) {</span>
<a href="#l42.32"></a><span id="l42.32" class="difflineplus">+void LDAP_CALL ldap_mods_free(LDAPMod** mods, int freemods) {</span>
<a href="#l42.33"></a><span id="l42.33">   int i;</span>
<a href="#l42.34"></a><span id="l42.34"> </span>
<a href="#l42.35"></a><span id="l42.35">   if (!NSLDAPI_VALID_LDAPMOD_ARRAY(mods)) {</span>
<a href="#l42.36"></a><span id="l42.36">     return;</span>
<a href="#l42.37"></a><span id="l42.37">   }</span>
<a href="#l42.38"></a><span id="l42.38"> </span>
<a href="#l42.39"></a><span id="l42.39">   for (i = 0; mods[i] != NULL; i++) {</span>
<a href="#l42.40"></a><span id="l42.40">     if (mods[i]-&gt;mod_op &amp; LDAP_MOD_BVALUES) {</span>
<a href="#l42.41"></a><span id="l42.41" class="difflineat">@@ -110,31 +110,31 @@ void LDAP_CALL ldap_mods_free(LDAPMod **</span>
<a href="#l42.42"></a><span id="l42.42">         ber_bvecfree(mods[i]-&gt;mod_bvalues);</span>
<a href="#l42.43"></a><span id="l42.43">       }</span>
<a href="#l42.44"></a><span id="l42.44">     } else if (mods[i]-&gt;mod_values != NULL) {</span>
<a href="#l42.45"></a><span id="l42.45">       ldap_value_free(mods[i]-&gt;mod_values);</span>
<a href="#l42.46"></a><span id="l42.46">     }</span>
<a href="#l42.47"></a><span id="l42.47">     if (mods[i]-&gt;mod_type != NULL) {</span>
<a href="#l42.48"></a><span id="l42.48">       NSLDAPI_FREE(mods[i]-&gt;mod_type);</span>
<a href="#l42.49"></a><span id="l42.49">     }</span>
<a href="#l42.50"></a><span id="l42.50" class="difflineminus">-    NSLDAPI_FREE((char *)mods[i]);</span>
<a href="#l42.51"></a><span id="l42.51" class="difflineplus">+    NSLDAPI_FREE((char*)mods[i]);</span>
<a href="#l42.52"></a><span id="l42.52">   }</span>
<a href="#l42.53"></a><span id="l42.53"> </span>
<a href="#l42.54"></a><span id="l42.54" class="difflineminus">-  if (freemods) NSLDAPI_FREE((char *)mods);</span>
<a href="#l42.55"></a><span id="l42.55" class="difflineplus">+  if (freemods) NSLDAPI_FREE((char*)mods);</span>
<a href="#l42.56"></a><span id="l42.56"> }</span>
<a href="#l42.57"></a><span id="l42.57"> </span>
<a href="#l42.58"></a><span id="l42.58"> /*</span>
<a href="#l42.59"></a><span id="l42.59">  * ldap_memfree() is needed to ensure that memory allocated by the C runtime</span>
<a href="#l42.60"></a><span id="l42.60">  * associated with libldap is freed by the same runtime code.</span>
<a href="#l42.61"></a><span id="l42.61">  */</span>
<a href="#l42.62"></a><span id="l42.62" class="difflineminus">-void LDAP_CALL ldap_memfree(void *s) {</span>
<a href="#l42.63"></a><span id="l42.63" class="difflineplus">+void LDAP_CALL ldap_memfree(void* s) {</span>
<a href="#l42.64"></a><span id="l42.64">   if (s != NULL) {</span>
<a href="#l42.65"></a><span id="l42.65">     NSLDAPI_FREE(s);</span>
<a href="#l42.66"></a><span id="l42.66">   }</span>
<a href="#l42.67"></a><span id="l42.67"> }</span>
<a href="#l42.68"></a><span id="l42.68"> </span>
<a href="#l42.69"></a><span id="l42.69"> /*</span>
<a href="#l42.70"></a><span id="l42.70">  * ldap_ber_free() is just a cover for ber_free()</span>
<a href="#l42.71"></a><span id="l42.71">  * ber_free() checks for ber == NULL, so we don't bother.</span>
<a href="#l42.72"></a><span id="l42.72">  */</span>
<a href="#l42.73"></a><span id="l42.73" class="difflineminus">-void LDAP_CALL ldap_ber_free(BerElement *ber, int freebuf) {</span>
<a href="#l42.74"></a><span id="l42.74" class="difflineplus">+void LDAP_CALL ldap_ber_free(BerElement* ber, int freebuf) {</span>
<a href="#l42.75"></a><span id="l42.75">   ber_free(ber, freebuf);</span>
<a href="#l42.76"></a><span id="l42.76"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l43.1"></a><span id="l43.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/freevalues.c</span>
<a href="#l43.2"></a><span id="l43.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/freevalues.c</span>
<a href="#l43.3"></a><span id="l43.3" class="difflineat">@@ -39,26 +39,26 @@</span>
<a href="#l43.4"></a><span id="l43.4">  *  All rights reserved.</span>
<a href="#l43.5"></a><span id="l43.5">  */</span>
<a href="#l43.6"></a><span id="l43.6"> /*</span>
<a href="#l43.7"></a><span id="l43.7">  *  freevalues.c</span>
<a href="#l43.8"></a><span id="l43.8">  */</span>
<a href="#l43.9"></a><span id="l43.9"> </span>
<a href="#l43.10"></a><span id="l43.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l43.11"></a><span id="l43.11"> </span>
<a href="#l43.12"></a><span id="l43.12" class="difflineminus">-void LDAP_CALL ldap_value_free(char **vals) {</span>
<a href="#l43.13"></a><span id="l43.13" class="difflineplus">+void LDAP_CALL ldap_value_free(char** vals) {</span>
<a href="#l43.14"></a><span id="l43.14">   int i;</span>
<a href="#l43.15"></a><span id="l43.15"> </span>
<a href="#l43.16"></a><span id="l43.16">   if (vals == NULL) return;</span>
<a href="#l43.17"></a><span id="l43.17">   for (i = 0; vals[i] != NULL; i++) NSLDAPI_FREE(vals[i]);</span>
<a href="#l43.18"></a><span id="l43.18" class="difflineminus">-  NSLDAPI_FREE((char *)vals);</span>
<a href="#l43.19"></a><span id="l43.19" class="difflineplus">+  NSLDAPI_FREE((char*)vals);</span>
<a href="#l43.20"></a><span id="l43.20"> }</span>
<a href="#l43.21"></a><span id="l43.21"> </span>
<a href="#l43.22"></a><span id="l43.22" class="difflineminus">-void LDAP_CALL ldap_value_free_len(struct berval **vals) {</span>
<a href="#l43.23"></a><span id="l43.23" class="difflineplus">+void LDAP_CALL ldap_value_free_len(struct berval** vals) {</span>
<a href="#l43.24"></a><span id="l43.24">   int i;</span>
<a href="#l43.25"></a><span id="l43.25"> </span>
<a href="#l43.26"></a><span id="l43.26">   if (vals == NULL) return;</span>
<a href="#l43.27"></a><span id="l43.27">   for (i = 0; vals[i] != NULL; i++) {</span>
<a href="#l43.28"></a><span id="l43.28">     NSLDAPI_FREE(vals[i]-&gt;bv_val);</span>
<a href="#l43.29"></a><span id="l43.29">     NSLDAPI_FREE(vals[i]);</span>
<a href="#l43.30"></a><span id="l43.30">   }</span>
<a href="#l43.31"></a><span id="l43.31" class="difflineminus">-  NSLDAPI_FREE((char *)vals);</span>
<a href="#l43.32"></a><span id="l43.32" class="difflineplus">+  NSLDAPI_FREE((char*)vals);</span>
<a href="#l43.33"></a><span id="l43.33"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l44.1"></a><span id="l44.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/friendly.c</span>
<a href="#l44.2"></a><span id="l44.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/friendly.c</span>
<a href="#l44.3"></a><span id="l44.3" class="difflineat">@@ -45,21 +45,21 @@</span>
<a href="#l44.4"></a><span id="l44.4"> #if 0</span>
<a href="#l44.5"></a><span id="l44.5"> #  ifndef lint</span>
<a href="#l44.6"></a><span id="l44.6"> static char copyright[] = &quot;@(#) Copyright (c) 1993 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l44.7"></a><span id="l44.7"> #  endif</span>
<a href="#l44.8"></a><span id="l44.8"> #endif</span>
<a href="#l44.9"></a><span id="l44.9"> </span>
<a href="#l44.10"></a><span id="l44.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l44.11"></a><span id="l44.11"> </span>
<a href="#l44.12"></a><span id="l44.12" class="difflineminus">-char *LDAP_CALL ldap_friendly_name(char *filename, char *name,</span>
<a href="#l44.13"></a><span id="l44.13" class="difflineminus">-                                   FriendlyMap *map) {</span>
<a href="#l44.14"></a><span id="l44.14" class="difflineplus">+char* LDAP_CALL ldap_friendly_name(char* filename, char* name,</span>
<a href="#l44.15"></a><span id="l44.15" class="difflineplus">+                                   FriendlyMap* map) {</span>
<a href="#l44.16"></a><span id="l44.16">   int i, entries;</span>
<a href="#l44.17"></a><span id="l44.17" class="difflineminus">-  FILE *fp;</span>
<a href="#l44.18"></a><span id="l44.18" class="difflineminus">-  char *s;</span>
<a href="#l44.19"></a><span id="l44.19" class="difflineplus">+  FILE* fp;</span>
<a href="#l44.20"></a><span id="l44.20" class="difflineplus">+  char* s;</span>
<a href="#l44.21"></a><span id="l44.21">   char buf[BUFSIZ];</span>
<a href="#l44.22"></a><span id="l44.22"> </span>
<a href="#l44.23"></a><span id="l44.23">   if (map == NULL) {</span>
<a href="#l44.24"></a><span id="l44.24">     return (name);</span>
<a href="#l44.25"></a><span id="l44.25">   }</span>
<a href="#l44.26"></a><span id="l44.26">   if (NULL == name) {</span>
<a href="#l44.27"></a><span id="l44.27">     return (name);</span>
<a href="#l44.28"></a><span id="l44.28">   }</span>
<a href="#l44.29"></a><span id="l44.29" class="difflineat">@@ -117,18 +117,18 @@ char *LDAP_CALL ldap_friendly_name(char </span>
<a href="#l44.30"></a><span id="l44.30"> </span>
<a href="#l44.31"></a><span id="l44.31">   for (i = 0; (*map)[i].f_unfriendly != NULL; i++) {</span>
<a href="#l44.32"></a><span id="l44.32">     if (strcasecmp(name, (*map)[i].f_unfriendly) == 0)</span>
<a href="#l44.33"></a><span id="l44.33">       return ((*map)[i].f_friendly);</span>
<a href="#l44.34"></a><span id="l44.34">   }</span>
<a href="#l44.35"></a><span id="l44.35">   return (name);</span>
<a href="#l44.36"></a><span id="l44.36"> }</span>
<a href="#l44.37"></a><span id="l44.37"> </span>
<a href="#l44.38"></a><span id="l44.38" class="difflineminus">-void LDAP_CALL ldap_free_friendlymap(FriendlyMap *map) {</span>
<a href="#l44.39"></a><span id="l44.39" class="difflineminus">-  struct friendly *pF;</span>
<a href="#l44.40"></a><span id="l44.40" class="difflineplus">+void LDAP_CALL ldap_free_friendlymap(FriendlyMap* map) {</span>
<a href="#l44.41"></a><span id="l44.41" class="difflineplus">+  struct friendly* pF;</span>
<a href="#l44.42"></a><span id="l44.42"> </span>
<a href="#l44.43"></a><span id="l44.43">   if (map == NULL || *map == NULL) {</span>
<a href="#l44.44"></a><span id="l44.44">     return;</span>
<a href="#l44.45"></a><span id="l44.45">   }</span>
<a href="#l44.46"></a><span id="l44.46"> </span>
<a href="#l44.47"></a><span id="l44.47">   for (pF = *map; pF-&gt;f_unfriendly; pF++) {</span>
<a href="#l44.48"></a><span id="l44.48">     NSLDAPI_FREE(pF-&gt;f_unfriendly);</span>
<a href="#l44.49"></a><span id="l44.49">     NSLDAPI_FREE(pF-&gt;f_friendly);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l45.1"></a><span id="l45.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/getattr.c</span>
<a href="#l45.2"></a><span id="l45.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/getattr.c</span>
<a href="#l45.3"></a><span id="l45.3" class="difflineat">@@ -45,28 +45,28 @@</span>
<a href="#l45.4"></a><span id="l45.4"> #if 0</span>
<a href="#l45.5"></a><span id="l45.5"> #  ifndef lint</span>
<a href="#l45.6"></a><span id="l45.6"> static char copyright[] = &quot;@(#) Copyright (c) 1990 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l45.7"></a><span id="l45.7"> #  endif</span>
<a href="#l45.8"></a><span id="l45.8"> #endif</span>
<a href="#l45.9"></a><span id="l45.9"> </span>
<a href="#l45.10"></a><span id="l45.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l45.11"></a><span id="l45.11"> </span>
<a href="#l45.12"></a><span id="l45.12" class="difflineminus">-static unsigned long bytes_remaining(BerElement *ber) {</span>
<a href="#l45.13"></a><span id="l45.13" class="difflineplus">+static unsigned long bytes_remaining(BerElement* ber) {</span>
<a href="#l45.14"></a><span id="l45.14">   ber_len_t len;</span>
<a href="#l45.15"></a><span id="l45.15"> </span>
<a href="#l45.16"></a><span id="l45.16">   if (ber_get_option(ber, LBER_OPT_REMAINING_BYTES, &amp;len) != 0) {</span>
<a href="#l45.17"></a><span id="l45.17">     return (0); /* not sure what else to do.... */</span>
<a href="#l45.18"></a><span id="l45.18">   }</span>
<a href="#l45.19"></a><span id="l45.19">   return (len);</span>
<a href="#l45.20"></a><span id="l45.20"> }</span>
<a href="#l45.21"></a><span id="l45.21"> </span>
<a href="#l45.22"></a><span id="l45.22" class="difflineminus">-char *LDAP_CALL ldap_first_attribute(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l45.23"></a><span id="l45.23" class="difflineminus">-                                     BerElement **ber) {</span>
<a href="#l45.24"></a><span id="l45.24" class="difflineminus">-  char *attr;</span>
<a href="#l45.25"></a><span id="l45.25" class="difflineplus">+char* LDAP_CALL ldap_first_attribute(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l45.26"></a><span id="l45.26" class="difflineplus">+                                     BerElement** ber) {</span>
<a href="#l45.27"></a><span id="l45.27" class="difflineplus">+  char* attr;</span>
<a href="#l45.28"></a><span id="l45.28">   int err;</span>
<a href="#l45.29"></a><span id="l45.29">   ber_len_t seqlength;</span>
<a href="#l45.30"></a><span id="l45.30"> </span>
<a href="#l45.31"></a><span id="l45.31">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_first_attribute\n&quot;, 0, 0, 0);</span>
<a href="#l45.32"></a><span id="l45.32"> </span>
<a href="#l45.33"></a><span id="l45.33">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l45.34"></a><span id="l45.34">     return (NULL); /* punt */</span>
<a href="#l45.35"></a><span id="l45.35">   }</span>
<a href="#l45.36"></a><span id="l45.36" class="difflineat">@@ -106,19 +106,19 @@ char *LDAP_CALL ldap_first_attribute(LDA</span>
<a href="#l45.37"></a><span id="l45.37">   if (attr == NULL || err != LDAP_SUCCESS) {</span>
<a href="#l45.38"></a><span id="l45.38">     ber_free(*ber, 0);</span>
<a href="#l45.39"></a><span id="l45.39">     *ber = NULL;</span>
<a href="#l45.40"></a><span id="l45.40">   }</span>
<a href="#l45.41"></a><span id="l45.41">   return (attr);</span>
<a href="#l45.42"></a><span id="l45.42"> }</span>
<a href="#l45.43"></a><span id="l45.43"> </span>
<a href="#l45.44"></a><span id="l45.44"> /* ARGSUSED */</span>
<a href="#l45.45"></a><span id="l45.45" class="difflineminus">-char *LDAP_CALL ldap_next_attribute(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l45.46"></a><span id="l45.46" class="difflineminus">-                                    BerElement *ber) {</span>
<a href="#l45.47"></a><span id="l45.47" class="difflineminus">-  char *attr;</span>
<a href="#l45.48"></a><span id="l45.48" class="difflineplus">+char* LDAP_CALL ldap_next_attribute(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l45.49"></a><span id="l45.49" class="difflineplus">+                                    BerElement* ber) {</span>
<a href="#l45.50"></a><span id="l45.50" class="difflineplus">+  char* attr;</span>
<a href="#l45.51"></a><span id="l45.51">   int err;</span>
<a href="#l45.52"></a><span id="l45.52"> </span>
<a href="#l45.53"></a><span id="l45.53">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_next_attribute\n&quot;, 0, 0, 0);</span>
<a href="#l45.54"></a><span id="l45.54"> </span>
<a href="#l45.55"></a><span id="l45.55">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l45.56"></a><span id="l45.56">     return (NULL); /* punt */</span>
<a href="#l45.57"></a><span id="l45.57">   }</span>
<a href="#l45.58"></a><span id="l45.58"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l46.1"></a><span id="l46.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/getdn.c</span>
<a href="#l46.2"></a><span id="l46.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/getdn.c</span>
<a href="#l46.3"></a><span id="l46.3" class="difflineat">@@ -45,18 +45,18 @@</span>
<a href="#l46.4"></a><span id="l46.4"> #if 0</span>
<a href="#l46.5"></a><span id="l46.5"> #  ifndef lint</span>
<a href="#l46.6"></a><span id="l46.6"> static char copyright[] = &quot;@(#) Copyright (c) 1990 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l46.7"></a><span id="l46.7"> #  endif</span>
<a href="#l46.8"></a><span id="l46.8"> #endif</span>
<a href="#l46.9"></a><span id="l46.9"> </span>
<a href="#l46.10"></a><span id="l46.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l46.11"></a><span id="l46.11"> </span>
<a href="#l46.12"></a><span id="l46.12" class="difflineminus">-char *LDAP_CALL ldap_get_dn(LDAP *ld, LDAPMessage *entry) {</span>
<a href="#l46.13"></a><span id="l46.13" class="difflineminus">-  char *dn;</span>
<a href="#l46.14"></a><span id="l46.14" class="difflineplus">+char* LDAP_CALL ldap_get_dn(LDAP* ld, LDAPMessage* entry) {</span>
<a href="#l46.15"></a><span id="l46.15" class="difflineplus">+  char* dn;</span>
<a href="#l46.16"></a><span id="l46.16">   struct berelement tmp;</span>
<a href="#l46.17"></a><span id="l46.17"> </span>
<a href="#l46.18"></a><span id="l46.18">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_get_dn\n&quot;, 0, 0, 0);</span>
<a href="#l46.19"></a><span id="l46.19"> </span>
<a href="#l46.20"></a><span id="l46.20">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l46.21"></a><span id="l46.21">     return (NULL); /* punt */</span>
<a href="#l46.22"></a><span id="l46.22">   }</span>
<a href="#l46.23"></a><span id="l46.23"> </span>
<a href="#l46.24"></a><span id="l46.24" class="difflineat">@@ -69,29 +69,29 @@ char *LDAP_CALL ldap_get_dn(LDAP *ld, LD</span>
<a href="#l46.25"></a><span id="l46.25">   if (ber_scanf(&amp;tmp, &quot;{a&quot;, &amp;dn) == LBER_ERROR) {</span>
<a href="#l46.26"></a><span id="l46.26">     LDAP_SET_LDERRNO(ld, LDAP_DECODING_ERROR, NULL, NULL);</span>
<a href="#l46.27"></a><span id="l46.27">     return (NULL);</span>
<a href="#l46.28"></a><span id="l46.28">   }</span>
<a href="#l46.29"></a><span id="l46.29"> </span>
<a href="#l46.30"></a><span id="l46.30">   return (dn);</span>
<a href="#l46.31"></a><span id="l46.31"> }</span>
<a href="#l46.32"></a><span id="l46.32"> </span>
<a href="#l46.33"></a><span id="l46.33" class="difflineminus">-char *LDAP_CALL ldap_dn2ufn(const char *dn) {</span>
<a href="#l46.34"></a><span id="l46.34" class="difflineplus">+char* LDAP_CALL ldap_dn2ufn(const char* dn) {</span>
<a href="#l46.35"></a><span id="l46.35">   char *p, *ufn, *r;</span>
<a href="#l46.36"></a><span id="l46.36">   size_t plen;</span>
<a href="#l46.37"></a><span id="l46.37">   int state;</span>
<a href="#l46.38"></a><span id="l46.38"> </span>
<a href="#l46.39"></a><span id="l46.39">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_dn2ufn\n&quot;, 0, 0, 0);</span>
<a href="#l46.40"></a><span id="l46.40"> </span>
<a href="#l46.41"></a><span id="l46.41">   if (dn == NULL) {</span>
<a href="#l46.42"></a><span id="l46.42">     dn = &quot;&quot;;</span>
<a href="#l46.43"></a><span id="l46.43">   }</span>
<a href="#l46.44"></a><span id="l46.44"> </span>
<a href="#l46.45"></a><span id="l46.45">   if (ldap_is_dns_dn(dn) || (p = strchr(dn, '=')) == NULL)</span>
<a href="#l46.46"></a><span id="l46.46" class="difflineminus">-    return (nsldapi_strdup((char *)dn));</span>
<a href="#l46.47"></a><span id="l46.47" class="difflineplus">+    return (nsldapi_strdup((char*)dn));</span>
<a href="#l46.48"></a><span id="l46.48"> </span>
<a href="#l46.49"></a><span id="l46.49">   ufn = nsldapi_strdup(++p);</span>
<a href="#l46.50"></a><span id="l46.50"> </span>
<a href="#l46.51"></a><span id="l46.51"> #define INQUOTE 1</span>
<a href="#l46.52"></a><span id="l46.52"> #define OUTQUOTE 2</span>
<a href="#l46.53"></a><span id="l46.53">   state = OUTQUOTE;</span>
<a href="#l46.54"></a><span id="l46.54">   for (p = ufn, r = ufn; *p; p += plen) {</span>
<a href="#l46.55"></a><span id="l46.55">     plen = 1;</span>
<a href="#l46.56"></a><span id="l46.56" class="difflineat">@@ -117,17 +117,17 @@ char *LDAP_CALL ldap_dn2ufn(const char *</span>
<a href="#l46.57"></a><span id="l46.57">           *r++ = ',';</span>
<a href="#l46.58"></a><span id="l46.58">         else</span>
<a href="#l46.59"></a><span id="l46.59">           *r++ = *p;</span>
<a href="#l46.60"></a><span id="l46.60">         break;</span>
<a href="#l46.61"></a><span id="l46.61">       case '=':</span>
<a href="#l46.62"></a><span id="l46.62">         if (state == INQUOTE)</span>
<a href="#l46.63"></a><span id="l46.63">           *r++ = *p;</span>
<a href="#l46.64"></a><span id="l46.64">         else {</span>
<a href="#l46.65"></a><span id="l46.65" class="difflineminus">-          char *rsave = r;</span>
<a href="#l46.66"></a><span id="l46.66" class="difflineplus">+          char* rsave = r;</span>
<a href="#l46.67"></a><span id="l46.67">           LDAP_UTF8DEC(r);</span>
<a href="#l46.68"></a><span id="l46.68">           *rsave = '\0';</span>
<a href="#l46.69"></a><span id="l46.69">           while (!ldap_utf8isspace(r) &amp;&amp; *r != ';' &amp;&amp; *r != ',' &amp;&amp; r &gt; ufn)</span>
<a href="#l46.70"></a><span id="l46.70">             LDAP_UTF8DEC(r);</span>
<a href="#l46.71"></a><span id="l46.71">           LDAP_UTF8INC(r);</span>
<a href="#l46.72"></a><span id="l46.72"> </span>
<a href="#l46.73"></a><span id="l46.73">           if (strcasecmp(r, &quot;c&quot;) &amp;&amp; strcasecmp(r, &quot;o&quot;) &amp;&amp; strcasecmp(r, &quot;ou&quot;) &amp;&amp;</span>
<a href="#l46.74"></a><span id="l46.74">               strcasecmp(r, &quot;st&quot;) &amp;&amp; strcasecmp(r, &quot;l&quot;) &amp;&amp;</span>
<a href="#l46.75"></a><span id="l46.75" class="difflineat">@@ -143,57 +143,57 @@ char *LDAP_CALL ldap_dn2ufn(const char *</span>
<a href="#l46.76"></a><span id="l46.76">         break;</span>
<a href="#l46.77"></a><span id="l46.77">     }</span>
<a href="#l46.78"></a><span id="l46.78">   }</span>
<a href="#l46.79"></a><span id="l46.79">   *r = '\0';</span>
<a href="#l46.80"></a><span id="l46.80"> </span>
<a href="#l46.81"></a><span id="l46.81">   return (ufn);</span>
<a href="#l46.82"></a><span id="l46.82"> }</span>
<a href="#l46.83"></a><span id="l46.83"> </span>
<a href="#l46.84"></a><span id="l46.84" class="difflineminus">-char **LDAP_CALL ldap_explode_dns(const char *dn) {</span>
<a href="#l46.85"></a><span id="l46.85" class="difflineplus">+char** LDAP_CALL ldap_explode_dns(const char* dn) {</span>
<a href="#l46.86"></a><span id="l46.86">   int ncomps, maxcomps;</span>
<a href="#l46.87"></a><span id="l46.87">   char *s, *cpydn;</span>
<a href="#l46.88"></a><span id="l46.88" class="difflineminus">-  char **rdns;</span>
<a href="#l46.89"></a><span id="l46.89" class="difflineplus">+  char** rdns;</span>
<a href="#l46.90"></a><span id="l46.90"> #ifdef HAVE_STRTOK_R /* defined in portable.h */</span>
<a href="#l46.91"></a><span id="l46.91" class="difflineminus">-  char *lasts;</span>
<a href="#l46.92"></a><span id="l46.92" class="difflineplus">+  char* lasts;</span>
<a href="#l46.93"></a><span id="l46.93"> #endif</span>
<a href="#l46.94"></a><span id="l46.94"> </span>
<a href="#l46.95"></a><span id="l46.95">   if (dn == NULL) {</span>
<a href="#l46.96"></a><span id="l46.96">     dn = &quot;&quot;;</span>
<a href="#l46.97"></a><span id="l46.97">   }</span>
<a href="#l46.98"></a><span id="l46.98"> </span>
<a href="#l46.99"></a><span id="l46.99" class="difflineminus">-  if ((rdns = (char **)NSLDAPI_MALLOC(8 * sizeof(char *))) == NULL) {</span>
<a href="#l46.100"></a><span id="l46.100" class="difflineplus">+  if ((rdns = (char**)NSLDAPI_MALLOC(8 * sizeof(char*))) == NULL) {</span>
<a href="#l46.101"></a><span id="l46.101">     return (NULL);</span>
<a href="#l46.102"></a><span id="l46.102">   }</span>
<a href="#l46.103"></a><span id="l46.103"> </span>
<a href="#l46.104"></a><span id="l46.104">   maxcomps = 8;</span>
<a href="#l46.105"></a><span id="l46.105">   ncomps = 0;</span>
<a href="#l46.106"></a><span id="l46.106" class="difflineminus">-  cpydn = nsldapi_strdup((char *)dn);</span>
<a href="#l46.107"></a><span id="l46.107" class="difflineplus">+  cpydn = nsldapi_strdup((char*)dn);</span>
<a href="#l46.108"></a><span id="l46.108">   for (s = STRTOK(cpydn, &quot;@.&quot;, &amp;lasts); s != NULL;</span>
<a href="#l46.109"></a><span id="l46.109">        s = STRTOK(NULL, &quot;@.&quot;, &amp;lasts)) {</span>
<a href="#l46.110"></a><span id="l46.110">     if (ncomps == maxcomps) {</span>
<a href="#l46.111"></a><span id="l46.111">       maxcomps *= 2;</span>
<a href="#l46.112"></a><span id="l46.112" class="difflineminus">-      if ((rdns = (char **)NSLDAPI_REALLOC(rdns, maxcomps * sizeof(char *))) ==</span>
<a href="#l46.113"></a><span id="l46.113" class="difflineplus">+      if ((rdns = (char**)NSLDAPI_REALLOC(rdns, maxcomps * sizeof(char*))) ==</span>
<a href="#l46.114"></a><span id="l46.114">           NULL) {</span>
<a href="#l46.115"></a><span id="l46.115">         NSLDAPI_FREE(cpydn);</span>
<a href="#l46.116"></a><span id="l46.116">         return (NULL);</span>
<a href="#l46.117"></a><span id="l46.117">       }</span>
<a href="#l46.118"></a><span id="l46.118">     }</span>
<a href="#l46.119"></a><span id="l46.119">     rdns[ncomps++] = nsldapi_strdup(s);</span>
<a href="#l46.120"></a><span id="l46.120">   }</span>
<a href="#l46.121"></a><span id="l46.121">   rdns[ncomps] = NULL;</span>
<a href="#l46.122"></a><span id="l46.122">   NSLDAPI_FREE(cpydn);</span>
<a href="#l46.123"></a><span id="l46.123"> </span>
<a href="#l46.124"></a><span id="l46.124">   return (rdns);</span>
<a href="#l46.125"></a><span id="l46.125"> }</span>
<a href="#l46.126"></a><span id="l46.126"> </span>
<a href="#l46.127"></a><span id="l46.127"> #define LDAP_DN 1</span>
<a href="#l46.128"></a><span id="l46.128"> #define LDAP_RDN 2</span>
<a href="#l46.129"></a><span id="l46.129"> </span>
<a href="#l46.130"></a><span id="l46.130" class="difflineminus">-static char **ldap_explode(const char *dn, const int notypes,</span>
<a href="#l46.131"></a><span id="l46.131" class="difflineplus">+static char** ldap_explode(const char* dn, const int notypes,</span>
<a href="#l46.132"></a><span id="l46.132">                            const int nametype) {</span>
<a href="#l46.133"></a><span id="l46.133">   char *p, *q, *rdnstart, **rdns = NULL;</span>
<a href="#l46.134"></a><span id="l46.134">   size_t plen = 0;</span>
<a href="#l46.135"></a><span id="l46.135">   int state = 0;</span>
<a href="#l46.136"></a><span id="l46.136">   int count = 0;</span>
<a href="#l46.137"></a><span id="l46.137">   int startquote = 0;</span>
<a href="#l46.138"></a><span id="l46.138">   int endquote = 0;</span>
<a href="#l46.139"></a><span id="l46.139">   int len = 0;</span>
<a href="#l46.140"></a><span id="l46.140" class="difflineat">@@ -206,21 +206,21 @@ static char **ldap_explode(const char *d</span>
<a href="#l46.141"></a><span id="l46.141">   }</span>
<a href="#l46.142"></a><span id="l46.142"> </span>
<a href="#l46.143"></a><span id="l46.143"> #if 0</span>
<a href="#l46.144"></a><span id="l46.144">   if (ldap_is_dns_dn(dn)) {</span>
<a href="#l46.145"></a><span id="l46.145">     return(ldap_explode_dns(dn));</span>
<a href="#l46.146"></a><span id="l46.146">   }</span>
<a href="#l46.147"></a><span id="l46.147"> #endif</span>
<a href="#l46.148"></a><span id="l46.148"> </span>
<a href="#l46.149"></a><span id="l46.149" class="difflineminus">-  while (ldap_utf8isspace((char *)dn)) { /* ignore leading spaces */</span>
<a href="#l46.150"></a><span id="l46.150" class="difflineplus">+  while (ldap_utf8isspace((char*)dn)) { /* ignore leading spaces */</span>
<a href="#l46.151"></a><span id="l46.151">     ++dn;</span>
<a href="#l46.152"></a><span id="l46.152">   }</span>
<a href="#l46.153"></a><span id="l46.153"> </span>
<a href="#l46.154"></a><span id="l46.154" class="difflineminus">-  p = rdnstart = (char *)dn;</span>
<a href="#l46.155"></a><span id="l46.155" class="difflineplus">+  p = rdnstart = (char*)dn;</span>
<a href="#l46.156"></a><span id="l46.156">   state = OUTQUOTE;</span>
<a href="#l46.157"></a><span id="l46.157"> </span>
<a href="#l46.158"></a><span id="l46.158">   do {</span>
<a href="#l46.159"></a><span id="l46.159">     p += plen;</span>
<a href="#l46.160"></a><span id="l46.160">     plen = 1;</span>
<a href="#l46.161"></a><span id="l46.161">     switch (*p) {</span>
<a href="#l46.162"></a><span id="l46.162">       case '\\':</span>
<a href="#l46.163"></a><span id="l46.163">         if (*++p == '\0')</span>
<a href="#l46.164"></a><span id="l46.164" class="difflineat">@@ -253,21 +253,21 @@ static char **ldap_explode(const char *d</span>
<a href="#l46.165"></a><span id="l46.165">              * to &lt;attr&gt;=&lt;value&gt;,&lt;string&gt;,&lt;attr&gt;=&lt;value&gt;</span>
<a href="#l46.166"></a><span id="l46.166">              * This is not a valid dn */</span>
<a href="#l46.167"></a><span id="l46.167">             ldap_charray_free(rdns);</span>
<a href="#l46.168"></a><span id="l46.168">             return NULL;</span>
<a href="#l46.169"></a><span id="l46.169">           }</span>
<a href="#l46.170"></a><span id="l46.170">           goteq = 0;</span>
<a href="#l46.171"></a><span id="l46.171">           ++count;</span>
<a href="#l46.172"></a><span id="l46.172">           if (rdns == NULL) {</span>
<a href="#l46.173"></a><span id="l46.173" class="difflineminus">-            if ((rdns = (char **)NSLDAPI_MALLOC(8 * sizeof(char *))) == NULL)</span>
<a href="#l46.174"></a><span id="l46.174" class="difflineplus">+            if ((rdns = (char**)NSLDAPI_MALLOC(8 * sizeof(char*))) == NULL)</span>
<a href="#l46.175"></a><span id="l46.175">               return (NULL);</span>
<a href="#l46.176"></a><span id="l46.176">           } else if (count &gt;= 8) {</span>
<a href="#l46.177"></a><span id="l46.177" class="difflineminus">-            if ((rdns = (char **)NSLDAPI_REALLOC(</span>
<a href="#l46.178"></a><span id="l46.178" class="difflineminus">-                     rdns, (count + 1) * sizeof(char *))) == NULL)</span>
<a href="#l46.179"></a><span id="l46.179" class="difflineplus">+            if ((rdns = (char**)NSLDAPI_REALLOC(</span>
<a href="#l46.180"></a><span id="l46.180" class="difflineplus">+                     rdns, (count + 1) * sizeof(char*))) == NULL)</span>
<a href="#l46.181"></a><span id="l46.181">               return (NULL);</span>
<a href="#l46.182"></a><span id="l46.182">           }</span>
<a href="#l46.183"></a><span id="l46.183">           rdns[count] = NULL;</span>
<a href="#l46.184"></a><span id="l46.184">           endquote = 0;</span>
<a href="#l46.185"></a><span id="l46.185">           if (notypes) {</span>
<a href="#l46.186"></a><span id="l46.186">             for (q = rdnstart; q &lt; p &amp;&amp; *q != '='; ++q) {</span>
<a href="#l46.187"></a><span id="l46.187">               ;</span>
<a href="#l46.188"></a><span id="l46.188">             }</span>
<a href="#l46.189"></a><span id="l46.189" class="difflineat">@@ -281,17 +281,17 @@ static char **ldap_explode(const char *d</span>
<a href="#l46.190"></a><span id="l46.190"> </span>
<a href="#l46.191"></a><span id="l46.191">             if ((*(p - 1) == '&quot;') &amp;&amp; startquote) {</span>
<a href="#l46.192"></a><span id="l46.192">               endquote = 1;</span>
<a href="#l46.193"></a><span id="l46.193">               --p;</span>
<a href="#l46.194"></a><span id="l46.194">             }</span>
<a href="#l46.195"></a><span id="l46.195">           }</span>
<a href="#l46.196"></a><span id="l46.196"> </span>
<a href="#l46.197"></a><span id="l46.197">           len = p - rdnstart;</span>
<a href="#l46.198"></a><span id="l46.198" class="difflineminus">-          if ((rdns[count - 1] = (char *)NSLDAPI_CALLOC(1, len + 1)) != NULL) {</span>
<a href="#l46.199"></a><span id="l46.199" class="difflineplus">+          if ((rdns[count - 1] = (char*)NSLDAPI_CALLOC(1, len + 1)) != NULL) {</span>
<a href="#l46.200"></a><span id="l46.200">             SAFEMEMCPY(rdns[count - 1], rdnstart, len);</span>
<a href="#l46.201"></a><span id="l46.201">             if (!endquote) {</span>
<a href="#l46.202"></a><span id="l46.202">               /* trim trailing spaces unless</span>
<a href="#l46.203"></a><span id="l46.203">                * they are properly escaped */</span>
<a href="#l46.204"></a><span id="l46.204">               while (len &gt; 0 &amp;&amp; ldap_utf8isspace(&amp;rdns[count - 1][len - 1]) &amp;&amp;</span>
<a href="#l46.205"></a><span id="l46.205">                      ((len == 1) || (rdns[count - 1][len - 2] != '\\'))) {</span>
<a href="#l46.206"></a><span id="l46.206">                 --len;</span>
<a href="#l46.207"></a><span id="l46.207">               }</span>
<a href="#l46.208"></a><span id="l46.208" class="difflineat">@@ -319,20 +319,20 @@ static char **ldap_explode(const char *d</span>
<a href="#l46.209"></a><span id="l46.209">         plen = LDAP_UTF8LEN(p);</span>
<a href="#l46.210"></a><span id="l46.210">         break;</span>
<a href="#l46.211"></a><span id="l46.211">     }</span>
<a href="#l46.212"></a><span id="l46.212">   } while (*p);</span>
<a href="#l46.213"></a><span id="l46.213"> </span>
<a href="#l46.214"></a><span id="l46.214">   return (rdns);</span>
<a href="#l46.215"></a><span id="l46.215"> }</span>
<a href="#l46.216"></a><span id="l46.216"> </span>
<a href="#l46.217"></a><span id="l46.217" class="difflineminus">-char **LDAP_CALL ldap_explode_dn(const char *dn, const int notypes) {</span>
<a href="#l46.218"></a><span id="l46.218" class="difflineplus">+char** LDAP_CALL ldap_explode_dn(const char* dn, const int notypes) {</span>
<a href="#l46.219"></a><span id="l46.219">   return (ldap_explode(dn, notypes, LDAP_DN));</span>
<a href="#l46.220"></a><span id="l46.220"> }</span>
<a href="#l46.221"></a><span id="l46.221"> </span>
<a href="#l46.222"></a><span id="l46.222" class="difflineminus">-char **LDAP_CALL ldap_explode_rdn(const char *rdn, const int notypes) {</span>
<a href="#l46.223"></a><span id="l46.223" class="difflineplus">+char** LDAP_CALL ldap_explode_rdn(const char* rdn, const int notypes) {</span>
<a href="#l46.224"></a><span id="l46.224">   return (ldap_explode(rdn, notypes, LDAP_RDN));</span>
<a href="#l46.225"></a><span id="l46.225"> }</span>
<a href="#l46.226"></a><span id="l46.226"> </span>
<a href="#l46.227"></a><span id="l46.227" class="difflineminus">-int LDAP_CALL ldap_is_dns_dn(const char *dn) {</span>
<a href="#l46.228"></a><span id="l46.228" class="difflineplus">+int LDAP_CALL ldap_is_dns_dn(const char* dn) {</span>
<a href="#l46.229"></a><span id="l46.229">   return (dn != NULL &amp;&amp; dn[0] != '\0' &amp;&amp; strchr(dn, '=') == NULL &amp;&amp;</span>
<a href="#l46.230"></a><span id="l46.230">           strchr(dn, ',') == NULL);</span>
<a href="#l46.231"></a><span id="l46.231"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l47.1"></a><span id="l47.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/getdxbyname.c</span>
<a href="#l47.2"></a><span id="l47.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/getdxbyname.c</span>
<a href="#l47.3"></a><span id="l47.3" class="difflineat">@@ -74,75 +74,75 @@ XXX not MT - safe XXX</span>
<a href="#l47.4"></a><span id="l47.4"> #  include &quot;ldap-int.h&quot;</span>
<a href="#l47.5"></a><span id="l47.5"> </span>
<a href="#l47.6"></a><span id="l47.6"> #  if defined(DOS)</span>
<a href="#l47.7"></a><span id="l47.7"> #    include &quot;msdos.h&quot;</span>
<a href="#l47.8"></a><span id="l47.8"> #  endif /* DOS */</span>
<a href="#l47.9"></a><span id="l47.9"> </span>
<a href="#l47.10"></a><span id="l47.10"> #  ifdef NEEDPROTOS</span>
<a href="#l47.11"></a><span id="l47.11">                  static char *</span>
<a href="#l47.12"></a><span id="l47.12" class="difflineminus">-                 *decode_answer(unsigned char *answer, int len);</span>
<a href="#l47.13"></a><span id="l47.13" class="difflineplus">+                 *decode_answer(unsigned char* answer, int len);</span>
<a href="#l47.14"></a><span id="l47.14"> #  else  /* NEEDPROTOS */</span>
<a href="#l47.15"></a><span id="l47.15">                  static char *</span>
<a href="#l47.16"></a><span id="l47.16">                  *decode_answer();</span>
<a href="#l47.17"></a><span id="l47.17"> #  endif /* NEEDPROTOS */</span>
<a href="#l47.18"></a><span id="l47.18"> </span>
<a href="#l47.19"></a><span id="l47.19"> extern int h_errno;</span>
<a href="#l47.20"></a><span id="l47.20" class="difflineminus">-extern char *h_errlist[];</span>
<a href="#l47.21"></a><span id="l47.21" class="difflineplus">+extern char* h_errlist[];</span>
<a href="#l47.22"></a><span id="l47.22"> </span>
<a href="#l47.23"></a><span id="l47.23"> #  define MAX_TO_SORT 32</span>
<a href="#l47.24"></a><span id="l47.24"> </span>
<a href="#l47.25"></a><span id="l47.25"> /*</span>
<a href="#l47.26"></a><span id="l47.26">  * nsldapi_getdxbyname - lookup DNS DX records for domain and return an ordered</span>
<a href="#l47.27"></a><span id="l47.27">  * array.</span>
<a href="#l47.28"></a><span id="l47.28">  */</span>
<a href="#l47.29"></a><span id="l47.29" class="difflineminus">-char **nsldapi_getdxbyname(char *domain) {</span>
<a href="#l47.30"></a><span id="l47.30" class="difflineplus">+char** nsldapi_getdxbyname(char* domain) {</span>
<a href="#l47.31"></a><span id="l47.31">   unsigned char buf[PACKETSZ];</span>
<a href="#l47.32"></a><span id="l47.32" class="difflineminus">-  char **dxs;</span>
<a href="#l47.33"></a><span id="l47.33" class="difflineplus">+  char** dxs;</span>
<a href="#l47.34"></a><span id="l47.34">   int rc;</span>
<a href="#l47.35"></a><span id="l47.35"> </span>
<a href="#l47.36"></a><span id="l47.36">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_getdxbyname( %s )\n&quot;, domain, 0, 0);</span>
<a href="#l47.37"></a><span id="l47.37"> </span>
<a href="#l47.38"></a><span id="l47.38">   memset(buf, 0, sizeof(buf));</span>
<a href="#l47.39"></a><span id="l47.39"> </span>
<a href="#l47.40"></a><span id="l47.40">   /* XXX not MT safe XXX */</span>
<a href="#l47.41"></a><span id="l47.41">   if ((rc = res_search(domain, C_IN, T_TXT, buf, sizeof(buf))) &lt; 0 ||</span>
<a href="#l47.42"></a><span id="l47.42">       (rc &gt; sizeof(buf)) || (dxs = decode_answer(buf, rc)) == NULL) {</span>
<a href="#l47.43"></a><span id="l47.43">     /*</span>
<a href="#l47.44"></a><span id="l47.44">      * punt:  return list consisting of the original domain name only</span>
<a href="#l47.45"></a><span id="l47.45">      */</span>
<a href="#l47.46"></a><span id="l47.46" class="difflineminus">-    if ((dxs = (char **)NSLDAPI_MALLOC(2 * sizeof(char *))) == NULL ||</span>
<a href="#l47.47"></a><span id="l47.47" class="difflineplus">+    if ((dxs = (char**)NSLDAPI_MALLOC(2 * sizeof(char*))) == NULL ||</span>
<a href="#l47.48"></a><span id="l47.48">         (dxs[0] = nsldapi_strdup(domain)) == NULL) {</span>
<a href="#l47.49"></a><span id="l47.49">       if (dxs != NULL) {</span>
<a href="#l47.50"></a><span id="l47.50">         NSLDAPI_FREE(dxs);</span>
<a href="#l47.51"></a><span id="l47.51">       }</span>
<a href="#l47.52"></a><span id="l47.52">       dxs = NULL;</span>
<a href="#l47.53"></a><span id="l47.53">     } else {</span>
<a href="#l47.54"></a><span id="l47.54">       dxs[1] = NULL;</span>
<a href="#l47.55"></a><span id="l47.55">     }</span>
<a href="#l47.56"></a><span id="l47.56">   }</span>
<a href="#l47.57"></a><span id="l47.57"> </span>
<a href="#l47.58"></a><span id="l47.58">   return (dxs);</span>
<a href="#l47.59"></a><span id="l47.59"> }</span>
<a href="#l47.60"></a><span id="l47.60"> </span>
<a href="#l47.61"></a><span id="l47.61" class="difflineminus">-static char **decode_answer(unsigned char *answer, int len) {</span>
<a href="#l47.62"></a><span id="l47.62" class="difflineminus">-  HEADER *hp;</span>
<a href="#l47.63"></a><span id="l47.63" class="difflineplus">+static char** decode_answer(unsigned char* answer, int len) {</span>
<a href="#l47.64"></a><span id="l47.64" class="difflineplus">+  HEADER* hp;</span>
<a href="#l47.65"></a><span id="l47.65">   char buf[256], **dxs;</span>
<a href="#l47.66"></a><span id="l47.66">   unsigned char *eom, *p;</span>
<a href="#l47.67"></a><span id="l47.67">   int ancount, err, rc, type, class, dx_count, rr_len;</span>
<a href="#l47.68"></a><span id="l47.68">   int dx_pref[MAX_TO_SORT];</span>
<a href="#l47.69"></a><span id="l47.69"> </span>
<a href="#l47.70"></a><span id="l47.70"> #  ifdef LDAP_DEBUG</span>
<a href="#l47.71"></a><span id="l47.71">   if (ldap_debug &amp; LDAP_DEBUG_PACKETS) {</span>
<a href="#l47.72"></a><span id="l47.72">     /* __p_query(answer);  */</span>
<a href="#l47.73"></a><span id="l47.73">   }</span>
<a href="#l47.74"></a><span id="l47.74"> #  endif /* LDAP_DEBUG */</span>
<a href="#l47.75"></a><span id="l47.75"> </span>
<a href="#l47.76"></a><span id="l47.76">   dxs = NULL;</span>
<a href="#l47.77"></a><span id="l47.77" class="difflineminus">-  hp = (HEADER *)answer;</span>
<a href="#l47.78"></a><span id="l47.78" class="difflineplus">+  hp = (HEADER*)answer;</span>
<a href="#l47.79"></a><span id="l47.79">   eom = answer + len;</span>
<a href="#l47.80"></a><span id="l47.80"> </span>
<a href="#l47.81"></a><span id="l47.81">   if (len &lt; sizeof(*hp)) {</span>
<a href="#l47.82"></a><span id="l47.82">     h_errno = NO_RECOVERY;</span>
<a href="#l47.83"></a><span id="l47.83">     return (NULL);</span>
<a href="#l47.84"></a><span id="l47.84">   }</span>
<a href="#l47.85"></a><span id="l47.85"> </span>
<a href="#l47.86"></a><span id="l47.86">   if (ntohs(hp-&gt;qdcount) != 1) {</span>
<a href="#l47.87"></a><span id="l47.87" class="difflineat">@@ -190,18 +190,18 @@ static char **decode_answer(unsigned cha</span>
<a href="#l47.88"></a><span id="l47.88">     if (p + rr_len &gt; eom) {</span>
<a href="#l47.89"></a><span id="l47.89">       err = NO_RECOVERY;</span>
<a href="#l47.90"></a><span id="l47.90">       continue;</span>
<a href="#l47.91"></a><span id="l47.91">     }</span>
<a href="#l47.92"></a><span id="l47.92">     if (class == C_IN &amp;&amp; type == T_TXT) {</span>
<a href="#l47.93"></a><span id="l47.93">       int i, n, pref, txt_len;</span>
<a href="#l47.94"></a><span id="l47.94">       char *q, *r;</span>
<a href="#l47.95"></a><span id="l47.95"> </span>
<a href="#l47.96"></a><span id="l47.96" class="difflineminus">-      q = (char *)p;</span>
<a href="#l47.97"></a><span id="l47.97" class="difflineminus">-      while (q &lt; (char *)p + rr_len &amp;&amp; err == 0) {</span>
<a href="#l47.98"></a><span id="l47.98" class="difflineplus">+      q = (char*)p;</span>
<a href="#l47.99"></a><span id="l47.99" class="difflineplus">+      while (q &lt; (char*)p + rr_len &amp;&amp; err == 0) {</span>
<a href="#l47.100"></a><span id="l47.100">         if (*q &gt;= 3 &amp;&amp; strncasecmp(q + 1, &quot;dx:&quot;, 3) == 0) {</span>
<a href="#l47.101"></a><span id="l47.101">           txt_len = *q - 3;</span>
<a href="#l47.102"></a><span id="l47.102">           r = q + 4;</span>
<a href="#l47.103"></a><span id="l47.103">           while (isspace(*r)) {</span>
<a href="#l47.104"></a><span id="l47.104">             ++r;</span>
<a href="#l47.105"></a><span id="l47.105">             --txt_len;</span>
<a href="#l47.106"></a><span id="l47.106">           }</span>
<a href="#l47.107"></a><span id="l47.107">           pref = 0;</span>
<a href="#l47.108"></a><span id="l47.108" class="difflineat">@@ -214,23 +214,22 @@ static char **decode_answer(unsigned cha</span>
<a href="#l47.109"></a><span id="l47.109">           if (dx_count &lt; MAX_TO_SORT - 1) {</span>
<a href="#l47.110"></a><span id="l47.110">             dx_pref[dx_count] = pref;</span>
<a href="#l47.111"></a><span id="l47.111">           }</span>
<a href="#l47.112"></a><span id="l47.112">           while (isspace(*r)) {</span>
<a href="#l47.113"></a><span id="l47.113">             ++r;</span>
<a href="#l47.114"></a><span id="l47.114">             --txt_len;</span>
<a href="#l47.115"></a><span id="l47.115">           }</span>
<a href="#l47.116"></a><span id="l47.116">           if (dx_count == 0) {</span>
<a href="#l47.117"></a><span id="l47.117" class="difflineminus">-            dxs = (char **)NSLDAPI_MALLOC(2 * sizeof(char *));</span>
<a href="#l47.118"></a><span id="l47.118" class="difflineplus">+            dxs = (char**)NSLDAPI_MALLOC(2 * sizeof(char*));</span>
<a href="#l47.119"></a><span id="l47.119">           } else {</span>
<a href="#l47.120"></a><span id="l47.120" class="difflineminus">-            dxs =</span>
<a href="#l47.121"></a><span id="l47.121" class="difflineminus">-                (char **)NSLDAPI_REALLOC(dxs, (dx_count + 2) * sizeof(char *));</span>
<a href="#l47.122"></a><span id="l47.122" class="difflineplus">+            dxs = (char**)NSLDAPI_REALLOC(dxs, (dx_count + 2) * sizeof(char*));</span>
<a href="#l47.123"></a><span id="l47.123">           }</span>
<a href="#l47.124"></a><span id="l47.124" class="difflineminus">-          if (dxs == NULL || (dxs[dx_count] = (char *)NSLDAPI_CALLOC(</span>
<a href="#l47.125"></a><span id="l47.125" class="difflineminus">-                                  1, txt_len + 1)) == NULL) {</span>
<a href="#l47.126"></a><span id="l47.126" class="difflineplus">+          if (dxs == NULL ||</span>
<a href="#l47.127"></a><span id="l47.127" class="difflineplus">+              (dxs[dx_count] = (char*)NSLDAPI_CALLOC(1, txt_len + 1)) == NULL) {</span>
<a href="#l47.128"></a><span id="l47.128">             err = NO_RECOVERY;</span>
<a href="#l47.129"></a><span id="l47.129">             continue;</span>
<a href="#l47.130"></a><span id="l47.130">           }</span>
<a href="#l47.131"></a><span id="l47.131">           SAFEMEMCPY(dxs[dx_count], r, txt_len);</span>
<a href="#l47.132"></a><span id="l47.132">           dxs[++dx_count] = NULL;</span>
<a href="#l47.133"></a><span id="l47.133">         }</span>
<a href="#l47.134"></a><span id="l47.134">         q += (*q + 1); /* move past last TXT record */</span>
<a href="#l47.135"></a><span id="l47.135">       }</span>
<a href="#l47.136"></a><span id="l47.136" class="difflineat">@@ -241,17 +240,17 @@ static char **decode_answer(unsigned cha</span>
<a href="#l47.137"></a><span id="l47.137">   if (err == 0) {</span>
<a href="#l47.138"></a><span id="l47.138">     if (dx_count == 0) {</span>
<a href="#l47.139"></a><span id="l47.139">       err = NO_DATA;</span>
<a href="#l47.140"></a><span id="l47.140">     } else {</span>
<a href="#l47.141"></a><span id="l47.141">       /*</span>
<a href="#l47.142"></a><span id="l47.142">        * sort records based on associated preference value</span>
<a href="#l47.143"></a><span id="l47.143">        */</span>
<a href="#l47.144"></a><span id="l47.144">       int i, j, sort_count, tmp_pref;</span>
<a href="#l47.145"></a><span id="l47.145" class="difflineminus">-      char *tmp_dx;</span>
<a href="#l47.146"></a><span id="l47.146" class="difflineplus">+      char* tmp_dx;</span>
<a href="#l47.147"></a><span id="l47.147"> </span>
<a href="#l47.148"></a><span id="l47.148">       sort_count = (dx_count &lt; MAX_TO_SORT) ? dx_count : MAX_TO_SORT;</span>
<a href="#l47.149"></a><span id="l47.149">       for (i = 0; i &lt; sort_count; ++i) {</span>
<a href="#l47.150"></a><span id="l47.150">         for (j = i + 1; j &lt; sort_count; ++j) {</span>
<a href="#l47.151"></a><span id="l47.151">           if (dx_pref[i] &gt; dx_pref[j]) {</span>
<a href="#l47.152"></a><span id="l47.152">             tmp_pref = dx_pref[i];</span>
<a href="#l47.153"></a><span id="l47.153">             dx_pref[i] = dx_pref[j];</span>
<a href="#l47.154"></a><span id="l47.154">             dx_pref[j] = tmp_pref;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l48.1"></a><span id="l48.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c</span>
<a href="#l48.2"></a><span id="l48.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c</span>
<a href="#l48.3"></a><span id="l48.3" class="difflineat">@@ -55,22 +55,22 @@</span>
<a href="#l48.4"></a><span id="l48.4">    ctl_iscritical  Indicates whether the control is critical of not. If</span>
<a href="#l48.5"></a><span id="l48.5">                    this field is non-zero, the operation will only be car-</span>
<a href="#l48.6"></a><span id="l48.6">                    ried out if the control is recognized by the server</span>
<a href="#l48.7"></a><span id="l48.7">                    and/or client</span>
<a href="#l48.8"></a><span id="l48.8"> </span>
<a href="#l48.9"></a><span id="l48.9">    ctrlp           the address of a place to put the constructed control</span>
<a href="#l48.10"></a><span id="l48.10"> */</span>
<a href="#l48.11"></a><span id="l48.11"> </span>
<a href="#l48.12"></a><span id="l48.12" class="difflineminus">-int LDAP_CALL ldap_create_geteffectiveRights_control(LDAP *ld,</span>
<a href="#l48.13"></a><span id="l48.13" class="difflineminus">-                                                     const char *authzid,</span>
<a href="#l48.14"></a><span id="l48.14" class="difflineminus">-                                                     const char **attrlist,</span>
<a href="#l48.15"></a><span id="l48.15" class="difflineplus">+int LDAP_CALL ldap_create_geteffectiveRights_control(LDAP* ld,</span>
<a href="#l48.16"></a><span id="l48.16" class="difflineplus">+                                                     const char* authzid,</span>
<a href="#l48.17"></a><span id="l48.17" class="difflineplus">+                                                     const char** attrlist,</span>
<a href="#l48.18"></a><span id="l48.18">                                                      const char ctl_iscritical,</span>
<a href="#l48.19"></a><span id="l48.19" class="difflineminus">-                                                     LDAPControl **ctrlp) {</span>
<a href="#l48.20"></a><span id="l48.20" class="difflineminus">-  BerElement *ber;</span>
<a href="#l48.21"></a><span id="l48.21" class="difflineplus">+                                                     LDAPControl** ctrlp) {</span>
<a href="#l48.22"></a><span id="l48.22" class="difflineplus">+  BerElement* ber;</span>
<a href="#l48.23"></a><span id="l48.23">   int rc;</span>
<a href="#l48.24"></a><span id="l48.24"> </span>
<a href="#l48.25"></a><span id="l48.25">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l48.26"></a><span id="l48.26">     return (LDAP_PARAM_ERROR);</span>
<a href="#l48.27"></a><span id="l48.27">   }</span>
<a href="#l48.28"></a><span id="l48.28"> </span>
<a href="#l48.29"></a><span id="l48.29">   if (ctrlp == NULL) {</span>
<a href="#l48.30"></a><span id="l48.30">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l49.1"></a><span id="l49.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/getentry.c</span>
<a href="#l49.2"></a><span id="l49.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/getentry.c</span>
<a href="#l49.3"></a><span id="l49.3" class="difflineat">@@ -45,60 +45,60 @@</span>
<a href="#l49.4"></a><span id="l49.4"> #if 0</span>
<a href="#l49.5"></a><span id="l49.5"> #  ifndef lint</span>
<a href="#l49.6"></a><span id="l49.6"> static char copyright[] = &quot;@(#) Copyright (c) 1990 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l49.7"></a><span id="l49.7"> #  endif</span>
<a href="#l49.8"></a><span id="l49.8"> #endif</span>
<a href="#l49.9"></a><span id="l49.9"> </span>
<a href="#l49.10"></a><span id="l49.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l49.11"></a><span id="l49.11"> </span>
<a href="#l49.12"></a><span id="l49.12" class="difflineminus">-LDAPMessage *LDAP_CALL ldap_first_entry(LDAP *ld, LDAPMessage *chain) {</span>
<a href="#l49.13"></a><span id="l49.13" class="difflineplus">+LDAPMessage* LDAP_CALL ldap_first_entry(LDAP* ld, LDAPMessage* chain) {</span>
<a href="#l49.14"></a><span id="l49.14">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || chain == NULLMSG) {</span>
<a href="#l49.15"></a><span id="l49.15">     return (NULLMSG);</span>
<a href="#l49.16"></a><span id="l49.16">   }</span>
<a href="#l49.17"></a><span id="l49.17"> </span>
<a href="#l49.18"></a><span id="l49.18">   if (chain-&gt;lm_msgtype == LDAP_RES_SEARCH_ENTRY) {</span>
<a href="#l49.19"></a><span id="l49.19">     return (chain);</span>
<a href="#l49.20"></a><span id="l49.20">   }</span>
<a href="#l49.21"></a><span id="l49.21"> </span>
<a href="#l49.22"></a><span id="l49.22">   return (ldap_next_entry(ld, chain));</span>
<a href="#l49.23"></a><span id="l49.23"> }</span>
<a href="#l49.24"></a><span id="l49.24"> </span>
<a href="#l49.25"></a><span id="l49.25" class="difflineminus">-LDAPMessage *LDAP_CALL ldap_next_entry(LDAP *ld, LDAPMessage *entry) {</span>
<a href="#l49.26"></a><span id="l49.26" class="difflineplus">+LDAPMessage* LDAP_CALL ldap_next_entry(LDAP* ld, LDAPMessage* entry) {</span>
<a href="#l49.27"></a><span id="l49.27">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || entry == NULLMSG) {</span>
<a href="#l49.28"></a><span id="l49.28">     return (NULLMSG);</span>
<a href="#l49.29"></a><span id="l49.29">   }</span>
<a href="#l49.30"></a><span id="l49.30"> </span>
<a href="#l49.31"></a><span id="l49.31">   for (entry = entry-&gt;lm_chain; entry != NULLMSG; entry = entry-&gt;lm_chain) {</span>
<a href="#l49.32"></a><span id="l49.32">     if (entry-&gt;lm_msgtype == LDAP_RES_SEARCH_ENTRY) {</span>
<a href="#l49.33"></a><span id="l49.33">       return (entry);</span>
<a href="#l49.34"></a><span id="l49.34">     }</span>
<a href="#l49.35"></a><span id="l49.35">   }</span>
<a href="#l49.36"></a><span id="l49.36"> </span>
<a href="#l49.37"></a><span id="l49.37">   return (NULLMSG);</span>
<a href="#l49.38"></a><span id="l49.38"> }</span>
<a href="#l49.39"></a><span id="l49.39"> </span>
<a href="#l49.40"></a><span id="l49.40" class="difflineminus">-int LDAP_CALL ldap_count_entries(LDAP *ld, LDAPMessage *chain) {</span>
<a href="#l49.41"></a><span id="l49.41" class="difflineplus">+int LDAP_CALL ldap_count_entries(LDAP* ld, LDAPMessage* chain) {</span>
<a href="#l49.42"></a><span id="l49.42">   int i;</span>
<a href="#l49.43"></a><span id="l49.43"> </span>
<a href="#l49.44"></a><span id="l49.44">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l49.45"></a><span id="l49.45">     return (-1);</span>
<a href="#l49.46"></a><span id="l49.46">   }</span>
<a href="#l49.47"></a><span id="l49.47"> </span>
<a href="#l49.48"></a><span id="l49.48">   for (i = 0; chain != NULL; chain = chain-&gt;lm_chain) {</span>
<a href="#l49.49"></a><span id="l49.49">     if (chain-&gt;lm_msgtype == LDAP_RES_SEARCH_ENTRY) {</span>
<a href="#l49.50"></a><span id="l49.50">       ++i;</span>
<a href="#l49.51"></a><span id="l49.51">     }</span>
<a href="#l49.52"></a><span id="l49.52">   }</span>
<a href="#l49.53"></a><span id="l49.53"> </span>
<a href="#l49.54"></a><span id="l49.54">   return (i);</span>
<a href="#l49.55"></a><span id="l49.55"> }</span>
<a href="#l49.56"></a><span id="l49.56"> </span>
<a href="#l49.57"></a><span id="l49.57" class="difflineminus">-int LDAP_CALL ldap_get_entry_controls(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l49.58"></a><span id="l49.58" class="difflineminus">-                                      LDAPControl ***serverctrlsp) {</span>
<a href="#l49.59"></a><span id="l49.59" class="difflineplus">+int LDAP_CALL ldap_get_entry_controls(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l49.60"></a><span id="l49.60" class="difflineplus">+                                      LDAPControl*** serverctrlsp) {</span>
<a href="#l49.61"></a><span id="l49.61">   int rc;</span>
<a href="#l49.62"></a><span id="l49.62">   BerElement tmpber;</span>
<a href="#l49.63"></a><span id="l49.63"> </span>
<a href="#l49.64"></a><span id="l49.64">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_get_entry_controls\n&quot;, 0, 0, 0);</span>
<a href="#l49.65"></a><span id="l49.65"> </span>
<a href="#l49.66"></a><span id="l49.66">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l49.67"></a><span id="l49.67">     return (LDAP_PARAM_ERROR);</span>
<a href="#l49.68"></a><span id="l49.68">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l50.1"></a><span id="l50.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/getfilter.c</span>
<a href="#l50.2"></a><span id="l50.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/getfilter.c</span>
<a href="#l50.3"></a><span id="l50.3" class="difflineat">@@ -46,30 +46,30 @@</span>
<a href="#l50.4"></a><span id="l50.4"> #  ifndef lint</span>
<a href="#l50.5"></a><span id="l50.5"> static char copyright[] = &quot;@(#) Copyright (c) 1993 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l50.6"></a><span id="l50.6"> #  endif</span>
<a href="#l50.7"></a><span id="l50.7"> #endif</span>
<a href="#l50.8"></a><span id="l50.8"> </span>
<a href="#l50.9"></a><span id="l50.9"> #include &quot;ldap-int.h&quot;</span>
<a href="#l50.10"></a><span id="l50.10"> #include &quot;regex.h&quot;</span>
<a href="#l50.11"></a><span id="l50.11"> </span>
<a href="#l50.12"></a><span id="l50.12" class="difflineminus">-static int break_into_words(char *str, char *delims, char ***wordsp);</span>
<a href="#l50.13"></a><span id="l50.13" class="difflineplus">+static int break_into_words(char* str, char* delims, char*** wordsp);</span>
<a href="#l50.14"></a><span id="l50.14"> </span>
<a href="#l50.15"></a><span id="l50.15"> #if !defined(macintosh) &amp;&amp; !defined(DOS)</span>
<a href="#l50.16"></a><span id="l50.16" class="difflineminus">-extern char *LDAP_CALL re_comp();</span>
<a href="#l50.17"></a><span id="l50.17" class="difflineplus">+extern char* LDAP_CALL re_comp();</span>
<a href="#l50.18"></a><span id="l50.18"> #endif</span>
<a href="#l50.19"></a><span id="l50.19"> </span>
<a href="#l50.20"></a><span id="l50.20"> #define FILT_MAX_LINE_LEN 1024</span>
<a href="#l50.21"></a><span id="l50.21"> </span>
<a href="#l50.22"></a><span id="l50.22" class="difflineminus">-LDAPFiltDesc *LDAP_CALL ldap_init_getfilter(char *fname) {</span>
<a href="#l50.23"></a><span id="l50.23" class="difflineminus">-  FILE *fp;</span>
<a href="#l50.24"></a><span id="l50.24" class="difflineminus">-  char *buf;</span>
<a href="#l50.25"></a><span id="l50.25" class="difflineplus">+LDAPFiltDesc* LDAP_CALL ldap_init_getfilter(char* fname) {</span>
<a href="#l50.26"></a><span id="l50.26" class="difflineplus">+  FILE* fp;</span>
<a href="#l50.27"></a><span id="l50.27" class="difflineplus">+  char* buf;</span>
<a href="#l50.28"></a><span id="l50.28">   long rlen, len;</span>
<a href="#l50.29"></a><span id="l50.29">   int eof;</span>
<a href="#l50.30"></a><span id="l50.30" class="difflineminus">-  LDAPFiltDesc *lfdp;</span>
<a href="#l50.31"></a><span id="l50.31" class="difflineplus">+  LDAPFiltDesc* lfdp;</span>
<a href="#l50.32"></a><span id="l50.32"> </span>
<a href="#l50.33"></a><span id="l50.33">   if ((fp = NSLDAPI_FOPEN(fname, &quot;r&quot;)) == NULL) {</span>
<a href="#l50.34"></a><span id="l50.34">     return (NULL);</span>
<a href="#l50.35"></a><span id="l50.35">   }</span>
<a href="#l50.36"></a><span id="l50.36"> </span>
<a href="#l50.37"></a><span id="l50.37">   if (fseek(fp, 0L, SEEK_END) != 0) { /* move to end to get len */</span>
<a href="#l50.38"></a><span id="l50.38">     fclose(fp);</span>
<a href="#l50.39"></a><span id="l50.39">     return (NULL);</span>
<a href="#l50.40"></a><span id="l50.40" class="difflineat">@@ -97,26 +97,25 @@ LDAPFiltDesc *LDAP_CALL ldap_init_getfil</span>
<a href="#l50.41"></a><span id="l50.41">   }</span>
<a href="#l50.42"></a><span id="l50.42"> </span>
<a href="#l50.43"></a><span id="l50.43">   lfdp = ldap_init_getfilter_buf(buf, rlen);</span>
<a href="#l50.44"></a><span id="l50.44">   NSLDAPI_FREE(buf);</span>
<a href="#l50.45"></a><span id="l50.45"> </span>
<a href="#l50.46"></a><span id="l50.46">   return (lfdp);</span>
<a href="#l50.47"></a><span id="l50.47"> }</span>
<a href="#l50.48"></a><span id="l50.48"> </span>
<a href="#l50.49"></a><span id="l50.49" class="difflineminus">-LDAPFiltDesc *LDAP_CALL ldap_init_getfilter_buf(char *buf, long buflen) {</span>
<a href="#l50.50"></a><span id="l50.50" class="difflineminus">-  LDAPFiltDesc *lfdp;</span>
<a href="#l50.51"></a><span id="l50.51" class="difflineplus">+LDAPFiltDesc* LDAP_CALL ldap_init_getfilter_buf(char* buf, long buflen) {</span>
<a href="#l50.52"></a><span id="l50.52" class="difflineplus">+  LDAPFiltDesc* lfdp;</span>
<a href="#l50.53"></a><span id="l50.53">   LDAPFiltList *flp, *nextflp;</span>
<a href="#l50.54"></a><span id="l50.54">   LDAPFiltInfo *fip, *nextfip;</span>
<a href="#l50.55"></a><span id="l50.55">   char *errmsg, *tag, **tok;</span>
<a href="#l50.56"></a><span id="l50.56">   int tokcnt, i;</span>
<a href="#l50.57"></a><span id="l50.57"> </span>
<a href="#l50.58"></a><span id="l50.58">   if ((buf == NULL) || (buflen &lt; 0) ||</span>
<a href="#l50.59"></a><span id="l50.59" class="difflineminus">-      (lfdp = (LDAPFiltDesc *)NSLDAPI_CALLOC(1, sizeof(LDAPFiltDesc))) ==</span>
<a href="#l50.60"></a><span id="l50.60" class="difflineminus">-          NULL) {</span>
<a href="#l50.61"></a><span id="l50.61" class="difflineplus">+      (lfdp = (LDAPFiltDesc*)NSLDAPI_CALLOC(1, sizeof(LDAPFiltDesc))) == NULL) {</span>
<a href="#l50.62"></a><span id="l50.62">     return (NULL);</span>
<a href="#l50.63"></a><span id="l50.63">   }</span>
<a href="#l50.64"></a><span id="l50.64"> </span>
<a href="#l50.65"></a><span id="l50.65">   flp = nextflp = NULL;</span>
<a href="#l50.66"></a><span id="l50.66">   fip = NULL;</span>
<a href="#l50.67"></a><span id="l50.67">   tag = NULL;</span>
<a href="#l50.68"></a><span id="l50.68"> </span>
<a href="#l50.69"></a><span id="l50.69">   while (buflen &gt; 0 &amp;&amp;</span>
<a href="#l50.70"></a><span id="l50.70" class="difflineat">@@ -126,17 +125,17 @@ LDAPFiltDesc *LDAP_CALL ldap_init_getfil</span>
<a href="#l50.71"></a><span id="l50.71">         if (tag != NULL) {</span>
<a href="#l50.72"></a><span id="l50.72">           NSLDAPI_FREE(tag);</span>
<a href="#l50.73"></a><span id="l50.73">         }</span>
<a href="#l50.74"></a><span id="l50.74">         tag = tok[0];</span>
<a href="#l50.75"></a><span id="l50.75">         NSLDAPI_FREE(tok);</span>
<a href="#l50.76"></a><span id="l50.76">         break;</span>
<a href="#l50.77"></a><span id="l50.77">       case 4:</span>
<a href="#l50.78"></a><span id="l50.78">       case 5: /* start of filter info. list */</span>
<a href="#l50.79"></a><span id="l50.79" class="difflineminus">-        if ((nextflp = (LDAPFiltList *)NSLDAPI_CALLOC(</span>
<a href="#l50.80"></a><span id="l50.80" class="difflineplus">+        if ((nextflp = (LDAPFiltList*)NSLDAPI_CALLOC(</span>
<a href="#l50.81"></a><span id="l50.81">                  1, sizeof(LDAPFiltList))) == NULL) {</span>
<a href="#l50.82"></a><span id="l50.82">           ldap_getfilter_free(lfdp);</span>
<a href="#l50.83"></a><span id="l50.83">           return (NULL);</span>
<a href="#l50.84"></a><span id="l50.84">         }</span>
<a href="#l50.85"></a><span id="l50.85">         nextflp-&gt;lfl_tag = nsldapi_strdup(tag);</span>
<a href="#l50.86"></a><span id="l50.86">         nextflp-&gt;lfl_pattern = tok[0];</span>
<a href="#l50.87"></a><span id="l50.87">         if ((errmsg = re_comp(nextflp-&gt;lfl_pattern)) != NULL) {</span>
<a href="#l50.88"></a><span id="l50.88">           char msg[512];</span>
<a href="#l50.89"></a><span id="l50.89" class="difflineat">@@ -161,17 +160,17 @@ LDAPFiltDesc *LDAP_CALL ldap_init_getfil</span>
<a href="#l50.90"></a><span id="l50.90">         for (i = 2; i &lt; 5; ++i) {</span>
<a href="#l50.91"></a><span id="l50.91">           tok[i - 2] = tok[i];</span>
<a href="#l50.92"></a><span id="l50.92">         }</span>
<a href="#l50.93"></a><span id="l50.93">         /* fall through */</span>
<a href="#l50.94"></a><span id="l50.94"> </span>
<a href="#l50.95"></a><span id="l50.95">       case 2:</span>
<a href="#l50.96"></a><span id="l50.96">       case 3:                  /* filter, desc, and optional search scope */</span>
<a href="#l50.97"></a><span id="l50.97">         if (nextflp != NULL) { /* add to info list */</span>
<a href="#l50.98"></a><span id="l50.98" class="difflineminus">-          if ((nextfip = (LDAPFiltInfo *)NSLDAPI_CALLOC(</span>
<a href="#l50.99"></a><span id="l50.99" class="difflineplus">+          if ((nextfip = (LDAPFiltInfo*)NSLDAPI_CALLOC(</span>
<a href="#l50.100"></a><span id="l50.100">                    1, sizeof(LDAPFiltInfo))) == NULL) {</span>
<a href="#l50.101"></a><span id="l50.101">             ldap_getfilter_free(lfdp);</span>
<a href="#l50.102"></a><span id="l50.102">             nsldapi_free_strarray(tok);</span>
<a href="#l50.103"></a><span id="l50.103">             return (NULL);</span>
<a href="#l50.104"></a><span id="l50.104">           }</span>
<a href="#l50.105"></a><span id="l50.105">           if (fip == NULL) { /* first one */</span>
<a href="#l50.106"></a><span id="l50.106">             nextflp-&gt;lfl_ilist = nextfip;</span>
<a href="#l50.107"></a><span id="l50.107">           } else {</span>
<a href="#l50.108"></a><span id="l50.108" class="difflineat">@@ -213,18 +212,18 @@ LDAPFiltDesc *LDAP_CALL ldap_init_getfil</span>
<a href="#l50.109"></a><span id="l50.109"> </span>
<a href="#l50.110"></a><span id="l50.110">   if (tag != NULL) {</span>
<a href="#l50.111"></a><span id="l50.111">     NSLDAPI_FREE(tag);</span>
<a href="#l50.112"></a><span id="l50.112">   }</span>
<a href="#l50.113"></a><span id="l50.113"> </span>
<a href="#l50.114"></a><span id="l50.114">   return (lfdp);</span>
<a href="#l50.115"></a><span id="l50.115"> }</span>
<a href="#l50.116"></a><span id="l50.116"> </span>
<a href="#l50.117"></a><span id="l50.117" class="difflineminus">-int LDAP_CALL ldap_set_filter_additions(LDAPFiltDesc *lfdp, char *prefix,</span>
<a href="#l50.118"></a><span id="l50.118" class="difflineminus">-                                        char *suffix) {</span>
<a href="#l50.119"></a><span id="l50.119" class="difflineplus">+int LDAP_CALL ldap_set_filter_additions(LDAPFiltDesc* lfdp, char* prefix,</span>
<a href="#l50.120"></a><span id="l50.120" class="difflineplus">+                                        char* suffix) {</span>
<a href="#l50.121"></a><span id="l50.121">   if (lfdp == NULL) {</span>
<a href="#l50.122"></a><span id="l50.122">     return (LDAP_PARAM_ERROR);</span>
<a href="#l50.123"></a><span id="l50.123">   }</span>
<a href="#l50.124"></a><span id="l50.124"> </span>
<a href="#l50.125"></a><span id="l50.125">   if (lfdp-&gt;lfd_filtprefix != NULL) {</span>
<a href="#l50.126"></a><span id="l50.126">     NSLDAPI_FREE(lfdp-&gt;lfd_filtprefix);</span>
<a href="#l50.127"></a><span id="l50.127">   }</span>
<a href="#l50.128"></a><span id="l50.128">   lfdp-&gt;lfd_filtprefix = (prefix == NULL) ? NULL : nsldapi_strdup(prefix);</span>
<a href="#l50.129"></a><span id="l50.129" class="difflineat">@@ -235,24 +234,24 @@ int LDAP_CALL ldap_set_filter_additions(</span>
<a href="#l50.130"></a><span id="l50.130">   lfdp-&gt;lfd_filtsuffix = (suffix == NULL) ? NULL : nsldapi_strdup(suffix);</span>
<a href="#l50.131"></a><span id="l50.131"> </span>
<a href="#l50.132"></a><span id="l50.132">   return (LDAP_SUCCESS);</span>
<a href="#l50.133"></a><span id="l50.133"> }</span>
<a href="#l50.134"></a><span id="l50.134"> </span>
<a href="#l50.135"></a><span id="l50.135"> /*</span>
<a href="#l50.136"></a><span id="l50.136">  * ldap_setfilteraffixes() is deprecated -- use ldap_set_filter_additions()</span>
<a href="#l50.137"></a><span id="l50.137">  */</span>
<a href="#l50.138"></a><span id="l50.138" class="difflineminus">-void LDAP_CALL ldap_setfilteraffixes(LDAPFiltDesc *lfdp, char *prefix,</span>
<a href="#l50.139"></a><span id="l50.139" class="difflineminus">-                                     char *suffix) {</span>
<a href="#l50.140"></a><span id="l50.140" class="difflineplus">+void LDAP_CALL ldap_setfilteraffixes(LDAPFiltDesc* lfdp, char* prefix,</span>
<a href="#l50.141"></a><span id="l50.141" class="difflineplus">+                                     char* suffix) {</span>
<a href="#l50.142"></a><span id="l50.142">   (void)ldap_set_filter_additions(lfdp, prefix, suffix);</span>
<a href="#l50.143"></a><span id="l50.143"> }</span>
<a href="#l50.144"></a><span id="l50.144"> </span>
<a href="#l50.145"></a><span id="l50.145" class="difflineminus">-LDAPFiltInfo *LDAP_CALL ldap_getfirstfilter(LDAPFiltDesc *lfdp, char *tagpat,</span>
<a href="#l50.146"></a><span id="l50.146" class="difflineminus">-                                            char *value) {</span>
<a href="#l50.147"></a><span id="l50.147" class="difflineminus">-  LDAPFiltList *flp;</span>
<a href="#l50.148"></a><span id="l50.148" class="difflineplus">+LDAPFiltInfo* LDAP_CALL ldap_getfirstfilter(LDAPFiltDesc* lfdp, char* tagpat,</span>
<a href="#l50.149"></a><span id="l50.149" class="difflineplus">+                                            char* value) {</span>
<a href="#l50.150"></a><span id="l50.150" class="difflineplus">+  LDAPFiltList* flp;</span>
<a href="#l50.151"></a><span id="l50.151"> </span>
<a href="#l50.152"></a><span id="l50.152">   if (lfdp == NULL || tagpat == NULL || value == NULL) {</span>
<a href="#l50.153"></a><span id="l50.153">     return (NULL); /* punt */</span>
<a href="#l50.154"></a><span id="l50.154">   }</span>
<a href="#l50.155"></a><span id="l50.155"> </span>
<a href="#l50.156"></a><span id="l50.156">   if (lfdp-&gt;lfd_curvalcopy != NULL) {</span>
<a href="#l50.157"></a><span id="l50.157">     NSLDAPI_FREE(lfdp-&gt;lfd_curvalcopy);</span>
<a href="#l50.158"></a><span id="l50.158">     NSLDAPI_FREE(lfdp-&gt;lfd_curvalwords);</span>
<a href="#l50.159"></a><span id="l50.159" class="difflineat">@@ -286,18 +285,18 @@ LDAPFiltInfo *LDAP_CALL ldap_getfirstfil</span>
<a href="#l50.160"></a><span id="l50.160">     NSLDAPI_FREE(lfdp-&gt;lfd_curvalcopy);</span>
<a href="#l50.161"></a><span id="l50.161">     lfdp-&gt;lfd_curvalcopy = NULL;</span>
<a href="#l50.162"></a><span id="l50.162">     return (NULL);</span>
<a href="#l50.163"></a><span id="l50.163">   }</span>
<a href="#l50.164"></a><span id="l50.164"> </span>
<a href="#l50.165"></a><span id="l50.165">   return (ldap_getnextfilter(lfdp));</span>
<a href="#l50.166"></a><span id="l50.166"> }</span>
<a href="#l50.167"></a><span id="l50.167"> </span>
<a href="#l50.168"></a><span id="l50.168" class="difflineminus">-LDAPFiltInfo *LDAP_CALL ldap_getnextfilter(LDAPFiltDesc *lfdp) {</span>
<a href="#l50.169"></a><span id="l50.169" class="difflineminus">-  LDAPFiltInfo *fip;</span>
<a href="#l50.170"></a><span id="l50.170" class="difflineplus">+LDAPFiltInfo* LDAP_CALL ldap_getnextfilter(LDAPFiltDesc* lfdp) {</span>
<a href="#l50.171"></a><span id="l50.171" class="difflineplus">+  LDAPFiltInfo* fip;</span>
<a href="#l50.172"></a><span id="l50.172"> </span>
<a href="#l50.173"></a><span id="l50.173">   if (lfdp == NULL || (fip = lfdp-&gt;lfd_curfip) == NULL) {</span>
<a href="#l50.174"></a><span id="l50.174">     return (NULL);</span>
<a href="#l50.175"></a><span id="l50.175">   }</span>
<a href="#l50.176"></a><span id="l50.176"> </span>
<a href="#l50.177"></a><span id="l50.177">   lfdp-&gt;lfd_curfip = fip-&gt;lfi_next;</span>
<a href="#l50.178"></a><span id="l50.178"> </span>
<a href="#l50.179"></a><span id="l50.179">   ldap_build_filter(lfdp-&gt;lfd_filter, LDAP_FILT_MAXSIZ, fip-&gt;lfi_filter,</span>
<a href="#l50.180"></a><span id="l50.180" class="difflineat">@@ -306,31 +305,31 @@ LDAPFiltInfo *LDAP_CALL ldap_getnextfilt</span>
<a href="#l50.181"></a><span id="l50.181">   lfdp-&gt;lfd_retfi.lfi_filter = lfdp-&gt;lfd_filter;</span>
<a href="#l50.182"></a><span id="l50.182">   lfdp-&gt;lfd_retfi.lfi_desc = fip-&gt;lfi_desc;</span>
<a href="#l50.183"></a><span id="l50.183">   lfdp-&gt;lfd_retfi.lfi_scope = fip-&gt;lfi_scope;</span>
<a href="#l50.184"></a><span id="l50.184">   lfdp-&gt;lfd_retfi.lfi_isexact = fip-&gt;lfi_isexact;</span>
<a href="#l50.185"></a><span id="l50.185"> </span>
<a href="#l50.186"></a><span id="l50.186">   return (&amp;lfdp-&gt;lfd_retfi);</span>
<a href="#l50.187"></a><span id="l50.187"> }</span>
<a href="#l50.188"></a><span id="l50.188"> </span>
<a href="#l50.189"></a><span id="l50.189" class="difflineminus">-static char *filter_add_strn(char *f, char *flimit, char *v, size_t vlen)</span>
<a href="#l50.190"></a><span id="l50.190" class="difflineplus">+static char* filter_add_strn(char* f, char* flimit, char* v, size_t vlen)</span>
<a href="#l50.191"></a><span id="l50.191"> /* Copy v into f.  If flimit is too small, return NULL;</span>
<a href="#l50.192"></a><span id="l50.192">  * otherwise return (f + vlen).</span>
<a href="#l50.193"></a><span id="l50.193">  */</span>
<a href="#l50.194"></a><span id="l50.194"> {</span>
<a href="#l50.195"></a><span id="l50.195">   auto size_t flen = flimit - f;</span>
<a href="#l50.196"></a><span id="l50.196">   if (vlen &gt; flen) { /* flimit is too small */</span>
<a href="#l50.197"></a><span id="l50.197">     if (flen &gt; 0) SAFEMEMCPY(f, v, flen);</span>
<a href="#l50.198"></a><span id="l50.198">     return NULL;</span>
<a href="#l50.199"></a><span id="l50.199">   }</span>
<a href="#l50.200"></a><span id="l50.200">   if (vlen &gt; 0) SAFEMEMCPY(f, v, vlen);</span>
<a href="#l50.201"></a><span id="l50.201">   return f + vlen;</span>
<a href="#l50.202"></a><span id="l50.202"> }</span>
<a href="#l50.203"></a><span id="l50.203"> </span>
<a href="#l50.204"></a><span id="l50.204" class="difflineminus">-static char *filter_add_value(char *f, char *flimit, char *v, int escape_all)</span>
<a href="#l50.205"></a><span id="l50.205" class="difflineplus">+static char* filter_add_value(char* f, char* flimit, char* v, int escape_all)</span>
<a href="#l50.206"></a><span id="l50.206"> /* Copy v into f, but with parentheses escaped.  But only escape * and \</span>
<a href="#l50.207"></a><span id="l50.207">  * if escape_all is non-zero so that either &quot;*&quot; or &quot;\2a&quot; can be used in</span>
<a href="#l50.208"></a><span id="l50.208">  * v, with different meanings.</span>
<a href="#l50.209"></a><span id="l50.209">  * If flimit is too small, return NULL; otherwise</span>
<a href="#l50.210"></a><span id="l50.210">  * return (f + the number of bytes copied).</span>
<a href="#l50.211"></a><span id="l50.211">  */</span>
<a href="#l50.212"></a><span id="l50.212"> {</span>
<a href="#l50.213"></a><span id="l50.213">   auto char x[4];</span>
<a href="#l50.214"></a><span id="l50.214" class="difflineat">@@ -377,19 +376,19 @@ static char *filter_add_value(char *f, c</span>
<a href="#l50.215"></a><span id="l50.215">           f = NULL; /* overflow */</span>
<a href="#l50.216"></a><span id="l50.216">         }</span>
<a href="#l50.217"></a><span id="l50.217">         break;</span>
<a href="#l50.218"></a><span id="l50.218">     }</span>
<a href="#l50.219"></a><span id="l50.219">   }</span>
<a href="#l50.220"></a><span id="l50.220">   return f;</span>
<a href="#l50.221"></a><span id="l50.221"> }</span>
<a href="#l50.222"></a><span id="l50.222"> </span>
<a href="#l50.223"></a><span id="l50.223" class="difflineminus">-int LDAP_CALL ldap_create_filter(char *filtbuf, unsigned long buflen,</span>
<a href="#l50.224"></a><span id="l50.224" class="difflineminus">-                                 char *pattern, char *prefix, char *suffix,</span>
<a href="#l50.225"></a><span id="l50.225" class="difflineminus">-                                 char *attr, char *value, char **valwords) {</span>
<a href="#l50.226"></a><span id="l50.226" class="difflineplus">+int LDAP_CALL ldap_create_filter(char* filtbuf, unsigned long buflen,</span>
<a href="#l50.227"></a><span id="l50.227" class="difflineplus">+                                 char* pattern, char* prefix, char* suffix,</span>
<a href="#l50.228"></a><span id="l50.228" class="difflineplus">+                                 char* attr, char* value, char** valwords) {</span>
<a href="#l50.229"></a><span id="l50.229">   char *p, *f, *flimit;</span>
<a href="#l50.230"></a><span id="l50.230">   int i, wordcount, wordnum, endwordnum, escape_all;</span>
<a href="#l50.231"></a><span id="l50.231"> </span>
<a href="#l50.232"></a><span id="l50.232">   /*</span>
<a href="#l50.233"></a><span id="l50.233">    * there is some confusion on what to create for a filter if</span>
<a href="#l50.234"></a><span id="l50.234">    * attr or value are null pointers.  For now we just leave them</span>
<a href="#l50.235"></a><span id="l50.235">    * as TO BE DEALT with</span>
<a href="#l50.236"></a><span id="l50.236">    */</span>
<a href="#l50.237"></a><span id="l50.237" class="difflineat">@@ -478,38 +477,38 @@ int LDAP_CALL ldap_create_filter(char *f</span>
<a href="#l50.238"></a><span id="l50.238">   }</span>
<a href="#l50.239"></a><span id="l50.239">   *f = '\0';</span>
<a href="#l50.240"></a><span id="l50.240">   return (LDAP_SUCCESS);</span>
<a href="#l50.241"></a><span id="l50.241"> }</span>
<a href="#l50.242"></a><span id="l50.242"> </span>
<a href="#l50.243"></a><span id="l50.243"> /*</span>
<a href="#l50.244"></a><span id="l50.244">  * ldap_build_filter() is deprecated -- use ldap_create_filter() instead</span>
<a href="#l50.245"></a><span id="l50.245">  */</span>
<a href="#l50.246"></a><span id="l50.246" class="difflineminus">-void LDAP_CALL ldap_build_filter(char *filtbuf, unsigned long buflen,</span>
<a href="#l50.247"></a><span id="l50.247" class="difflineminus">-                                 char *pattern, char *prefix, char *suffix,</span>
<a href="#l50.248"></a><span id="l50.248" class="difflineminus">-                                 char *attr, char *value, char **valwords) {</span>
<a href="#l50.249"></a><span id="l50.249" class="difflineplus">+void LDAP_CALL ldap_build_filter(char* filtbuf, unsigned long buflen,</span>
<a href="#l50.250"></a><span id="l50.250" class="difflineplus">+                                 char* pattern, char* prefix, char* suffix,</span>
<a href="#l50.251"></a><span id="l50.251" class="difflineplus">+                                 char* attr, char* value, char** valwords) {</span>
<a href="#l50.252"></a><span id="l50.252">   (void)ldap_create_filter(filtbuf, buflen, pattern, prefix, suffix, attr,</span>
<a href="#l50.253"></a><span id="l50.253">                            value, valwords);</span>
<a href="#l50.254"></a><span id="l50.254"> }</span>
<a href="#l50.255"></a><span id="l50.255"> </span>
<a href="#l50.256"></a><span id="l50.256" class="difflineminus">-static int break_into_words(char *str, char *delims, char ***wordsp) {</span>
<a href="#l50.257"></a><span id="l50.257" class="difflineplus">+static int break_into_words(char* str, char* delims, char*** wordsp) {</span>
<a href="#l50.258"></a><span id="l50.258">   char *word, **words;</span>
<a href="#l50.259"></a><span id="l50.259">   int count;</span>
<a href="#l50.260"></a><span id="l50.260" class="difflineminus">-  char *lasts;</span>
<a href="#l50.261"></a><span id="l50.261" class="difflineplus">+  char* lasts;</span>
<a href="#l50.262"></a><span id="l50.262"> </span>
<a href="#l50.263"></a><span id="l50.263" class="difflineminus">-  if ((words = (char **)NSLDAPI_CALLOC(1, sizeof(char *))) == NULL) {</span>
<a href="#l50.264"></a><span id="l50.264" class="difflineplus">+  if ((words = (char**)NSLDAPI_CALLOC(1, sizeof(char*))) == NULL) {</span>
<a href="#l50.265"></a><span id="l50.265">     return (-1);</span>
<a href="#l50.266"></a><span id="l50.266">   }</span>
<a href="#l50.267"></a><span id="l50.267">   count = 0;</span>
<a href="#l50.268"></a><span id="l50.268">   words[count] = NULL;</span>
<a href="#l50.269"></a><span id="l50.269"> </span>
<a href="#l50.270"></a><span id="l50.270">   word = ldap_utf8strtok_r(str, delims, &amp;lasts);</span>
<a href="#l50.271"></a><span id="l50.271">   while (word != NULL) {</span>
<a href="#l50.272"></a><span id="l50.272" class="difflineminus">-    if ((words = (char **)NSLDAPI_REALLOC(</span>
<a href="#l50.273"></a><span id="l50.273" class="difflineminus">-             words, (count + 2) * sizeof(char *))) == NULL) {</span>
<a href="#l50.274"></a><span id="l50.274" class="difflineplus">+    if ((words = (char**)NSLDAPI_REALLOC(words, (count + 2) * sizeof(char*))) ==</span>
<a href="#l50.275"></a><span id="l50.275" class="difflineplus">+        NULL) {</span>
<a href="#l50.276"></a><span id="l50.276">       return (-1);</span>
<a href="#l50.277"></a><span id="l50.277">     }</span>
<a href="#l50.278"></a><span id="l50.278"> </span>
<a href="#l50.279"></a><span id="l50.279">     words[count] = word;</span>
<a href="#l50.280"></a><span id="l50.280">     words[++count] = NULL;</span>
<a href="#l50.281"></a><span id="l50.281">     word = ldap_utf8strtok_r(NULL, delims, &amp;lasts);</span>
<a href="#l50.282"></a><span id="l50.282">   }</span>
<a href="#l50.283"></a><span id="l50.283"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l51.1"></a><span id="l51.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/getoption.c</span>
<a href="#l51.2"></a><span id="l51.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/getoption.c</span>
<a href="#l51.3"></a><span id="l51.3" class="difflineat">@@ -33,20 +33,20 @@</span>
<a href="#l51.4"></a><span id="l51.4">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l51.5"></a><span id="l51.5">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l51.6"></a><span id="l51.6">  *</span>
<a href="#l51.7"></a><span id="l51.7">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l51.8"></a><span id="l51.8"> #include &quot;ldap-int.h&quot;</span>
<a href="#l51.9"></a><span id="l51.9"> </span>
<a href="#l51.10"></a><span id="l51.10"> #define LDAP_GET_BITOPT(ld, bit) ((ld)-&gt;ld_options &amp; bit) != 0 ? 1 : 0</span>
<a href="#l51.11"></a><span id="l51.11"> </span>
<a href="#l51.12"></a><span id="l51.12" class="difflineminus">-static int nsldapi_get_api_info(LDAPAPIInfo *aip);</span>
<a href="#l51.13"></a><span id="l51.13" class="difflineminus">-static int nsldapi_get_feature_info(LDAPAPIFeatureInfo *fip);</span>
<a href="#l51.14"></a><span id="l51.14" class="difflineplus">+static int nsldapi_get_api_info(LDAPAPIInfo* aip);</span>
<a href="#l51.15"></a><span id="l51.15" class="difflineplus">+static int nsldapi_get_feature_info(LDAPAPIFeatureInfo* fip);</span>
<a href="#l51.16"></a><span id="l51.16"> </span>
<a href="#l51.17"></a><span id="l51.17" class="difflineminus">-int LDAP_CALL ldap_get_option(LDAP *ld, int option, void *optdata) {</span>
<a href="#l51.18"></a><span id="l51.18" class="difflineplus">+int LDAP_CALL ldap_get_option(LDAP* ld, int option, void* optdata) {</span>
<a href="#l51.19"></a><span id="l51.19">   int rc = 0;</span>
<a href="#l51.20"></a><span id="l51.20"> </span>
<a href="#l51.21"></a><span id="l51.21">   if (!nsldapi_initialized) {</span>
<a href="#l51.22"></a><span id="l51.22">     nsldapi_initialize_defaults();</span>
<a href="#l51.23"></a><span id="l51.23">   }</span>
<a href="#l51.24"></a><span id="l51.24"> </span>
<a href="#l51.25"></a><span id="l51.25">   /*</span>
<a href="#l51.26"></a><span id="l51.26">    * optdata MUST be a valid pointer...</span>
<a href="#l51.27"></a><span id="l51.27" class="difflineat">@@ -54,36 +54,36 @@ int LDAP_CALL ldap_get_option(LDAP *ld, </span>
<a href="#l51.28"></a><span id="l51.28">   if (NULL == optdata) {</span>
<a href="#l51.29"></a><span id="l51.29">     return (LDAP_PARAM_ERROR);</span>
<a href="#l51.30"></a><span id="l51.30">   }</span>
<a href="#l51.31"></a><span id="l51.31">   /*</span>
<a href="#l51.32"></a><span id="l51.32">    * process global options (not associated with an LDAP session handle)</span>
<a href="#l51.33"></a><span id="l51.33">    */</span>
<a href="#l51.34"></a><span id="l51.34">   if (option == LDAP_OPT_MEMALLOC_FN_PTRS) {</span>
<a href="#l51.35"></a><span id="l51.35">     /* struct copy */</span>
<a href="#l51.36"></a><span id="l51.36" class="difflineminus">-    *((struct ldap_memalloc_fns *)optdata) = nsldapi_memalloc_fns;</span>
<a href="#l51.37"></a><span id="l51.37" class="difflineplus">+    *((struct ldap_memalloc_fns*)optdata) = nsldapi_memalloc_fns;</span>
<a href="#l51.38"></a><span id="l51.38">     return (0);</span>
<a href="#l51.39"></a><span id="l51.39">   }</span>
<a href="#l51.40"></a><span id="l51.40"> </span>
<a href="#l51.41"></a><span id="l51.41">   if (option == LDAP_OPT_API_INFO) {</span>
<a href="#l51.42"></a><span id="l51.42" class="difflineminus">-    rc = nsldapi_get_api_info((LDAPAPIInfo *)optdata);</span>
<a href="#l51.43"></a><span id="l51.43" class="difflineplus">+    rc = nsldapi_get_api_info((LDAPAPIInfo*)optdata);</span>
<a href="#l51.44"></a><span id="l51.44">     if (rc != LDAP_SUCCESS) {</span>
<a href="#l51.45"></a><span id="l51.45">       if (ld != NULL) {</span>
<a href="#l51.46"></a><span id="l51.46">         LDAP_SET_LDERRNO(ld, rc, NULL, NULL);</span>
<a href="#l51.47"></a><span id="l51.47">       }</span>
<a href="#l51.48"></a><span id="l51.48">       return (-1);</span>
<a href="#l51.49"></a><span id="l51.49">     }</span>
<a href="#l51.50"></a><span id="l51.50">     return (0);</span>
<a href="#l51.51"></a><span id="l51.51">   }</span>
<a href="#l51.52"></a><span id="l51.52">   /*</span>
<a href="#l51.53"></a><span id="l51.53">    * LDAP_OPT_DEBUG_LEVEL is global</span>
<a href="#l51.54"></a><span id="l51.54">    */</span>
<a href="#l51.55"></a><span id="l51.55">   if (LDAP_OPT_DEBUG_LEVEL == option) {</span>
<a href="#l51.56"></a><span id="l51.56"> #ifdef LDAP_DEBUG</span>
<a href="#l51.57"></a><span id="l51.57" class="difflineminus">-    *((int *)optdata) = ldap_debug;</span>
<a href="#l51.58"></a><span id="l51.58" class="difflineplus">+    *((int*)optdata) = ldap_debug;</span>
<a href="#l51.59"></a><span id="l51.59"> #endif /* LDAP_DEBUG */</span>
<a href="#l51.60"></a><span id="l51.60">     return (0);</span>
<a href="#l51.61"></a><span id="l51.61">   }</span>
<a href="#l51.62"></a><span id="l51.62"> </span>
<a href="#l51.63"></a><span id="l51.63">   /*</span>
<a href="#l51.64"></a><span id="l51.64">    * if ld is NULL, arrange to return options from our default settings</span>
<a href="#l51.65"></a><span id="l51.65">    */</span>
<a href="#l51.66"></a><span id="l51.66">   if (ld == NULL) {</span>
<a href="#l51.67"></a><span id="l51.67" class="difflineat">@@ -93,128 +93,128 @@ int LDAP_CALL ldap_get_option(LDAP *ld, </span>
<a href="#l51.68"></a><span id="l51.68">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l51.69"></a><span id="l51.69">     return (-1); /* punt */</span>
<a href="#l51.70"></a><span id="l51.70">   }</span>
<a href="#l51.71"></a><span id="l51.71"> </span>
<a href="#l51.72"></a><span id="l51.72">   if (ld != &amp;nsldapi_ld_defaults) LDAP_MUTEX_LOCK(ld, LDAP_OPTION_LOCK);</span>
<a href="#l51.73"></a><span id="l51.73">   switch (option) {</span>
<a href="#l51.74"></a><span id="l51.74"> #ifdef LDAP_DNS</span>
<a href="#l51.75"></a><span id="l51.75">     case LDAP_OPT_DNS:</span>
<a href="#l51.76"></a><span id="l51.76" class="difflineminus">-      *((int *)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_DNS);</span>
<a href="#l51.77"></a><span id="l51.77" class="difflineplus">+      *((int*)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_DNS);</span>
<a href="#l51.78"></a><span id="l51.78">       break;</span>
<a href="#l51.79"></a><span id="l51.79"> #endif</span>
<a href="#l51.80"></a><span id="l51.80"> </span>
<a href="#l51.81"></a><span id="l51.81">     case LDAP_OPT_REFERRALS:</span>
<a href="#l51.82"></a><span id="l51.82" class="difflineminus">-      *((int *)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_REFERRALS);</span>
<a href="#l51.83"></a><span id="l51.83" class="difflineplus">+      *((int*)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_REFERRALS);</span>
<a href="#l51.84"></a><span id="l51.84">       break;</span>
<a href="#l51.85"></a><span id="l51.85"> </span>
<a href="#l51.86"></a><span id="l51.86">     case LDAP_OPT_SSL:</span>
<a href="#l51.87"></a><span id="l51.87" class="difflineminus">-      *((int *)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_SSL);</span>
<a href="#l51.88"></a><span id="l51.88" class="difflineplus">+      *((int*)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_SSL);</span>
<a href="#l51.89"></a><span id="l51.89">       break;</span>
<a href="#l51.90"></a><span id="l51.90"> </span>
<a href="#l51.91"></a><span id="l51.91">     case LDAP_OPT_RESTART:</span>
<a href="#l51.92"></a><span id="l51.92" class="difflineminus">-      *((int *)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_RESTART);</span>
<a href="#l51.93"></a><span id="l51.93" class="difflineplus">+      *((int*)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_RESTART);</span>
<a href="#l51.94"></a><span id="l51.94">       break;</span>
<a href="#l51.95"></a><span id="l51.95"> </span>
<a href="#l51.96"></a><span id="l51.96">     case LDAP_OPT_RECONNECT:</span>
<a href="#l51.97"></a><span id="l51.97" class="difflineminus">-      *((int *)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_RECONNECT);</span>
<a href="#l51.98"></a><span id="l51.98" class="difflineplus">+      *((int*)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_RECONNECT);</span>
<a href="#l51.99"></a><span id="l51.99">       break;</span>
<a href="#l51.100"></a><span id="l51.100"> </span>
<a href="#l51.101"></a><span id="l51.101">     case LDAP_OPT_NOREBIND:</span>
<a href="#l51.102"></a><span id="l51.102" class="difflineminus">-      *((int *)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_NOREBIND);</span>
<a href="#l51.103"></a><span id="l51.103" class="difflineplus">+      *((int*)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_NOREBIND);</span>
<a href="#l51.104"></a><span id="l51.104">       break;</span>
<a href="#l51.105"></a><span id="l51.105"> </span>
<a href="#l51.106"></a><span id="l51.106"> #ifdef LDAP_ASYNC_IO</span>
<a href="#l51.107"></a><span id="l51.107">     case LDAP_OPT_ASYNC_CONNECT:</span>
<a href="#l51.108"></a><span id="l51.108" class="difflineminus">-      *((int *)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_ASYNC);</span>
<a href="#l51.109"></a><span id="l51.109" class="difflineplus">+      *((int*)optdata) = LDAP_GET_BITOPT(ld, LDAP_BITOPT_ASYNC);</span>
<a href="#l51.110"></a><span id="l51.110">       break;</span>
<a href="#l51.111"></a><span id="l51.111"> #endif /* LDAP_ASYNC_IO */</span>
<a href="#l51.112"></a><span id="l51.112"> </span>
<a href="#l51.113"></a><span id="l51.113">     /* stuff in the sockbuf */</span>
<a href="#l51.114"></a><span id="l51.114">     case LDAP_X_OPT_SOCKBUF:</span>
<a href="#l51.115"></a><span id="l51.115" class="difflineminus">-      *((Sockbuf **)optdata) = ld-&gt;ld_sbp;</span>
<a href="#l51.116"></a><span id="l51.116" class="difflineplus">+      *((Sockbuf**)optdata) = ld-&gt;ld_sbp;</span>
<a href="#l51.117"></a><span id="l51.117">       break;</span>
<a href="#l51.118"></a><span id="l51.118"> </span>
<a href="#l51.119"></a><span id="l51.119">     case LDAP_OPT_DESC:</span>
<a href="#l51.120"></a><span id="l51.120">       if (ber_sockbuf_get_option(ld-&gt;ld_sbp, LBER_SOCKBUF_OPT_DESC, optdata) !=</span>
<a href="#l51.121"></a><span id="l51.121">           0) {</span>
<a href="#l51.122"></a><span id="l51.122">         LDAP_SET_LDERRNO(ld, LDAP_LOCAL_ERROR, NULL, NULL);</span>
<a href="#l51.123"></a><span id="l51.123">         rc = -1;</span>
<a href="#l51.124"></a><span id="l51.124">       }</span>
<a href="#l51.125"></a><span id="l51.125">       break;</span>
<a href="#l51.126"></a><span id="l51.126"> </span>
<a href="#l51.127"></a><span id="l51.127">     /* fields in the LDAP structure */</span>
<a href="#l51.128"></a><span id="l51.128">     case LDAP_OPT_DEREF:</span>
<a href="#l51.129"></a><span id="l51.129" class="difflineminus">-      *((int *)optdata) = ld-&gt;ld_deref;</span>
<a href="#l51.130"></a><span id="l51.130" class="difflineplus">+      *((int*)optdata) = ld-&gt;ld_deref;</span>
<a href="#l51.131"></a><span id="l51.131">       break;</span>
<a href="#l51.132"></a><span id="l51.132">     case LDAP_OPT_SIZELIMIT:</span>
<a href="#l51.133"></a><span id="l51.133" class="difflineminus">-      *((int *)optdata) = ld-&gt;ld_sizelimit;</span>
<a href="#l51.134"></a><span id="l51.134" class="difflineplus">+      *((int*)optdata) = ld-&gt;ld_sizelimit;</span>
<a href="#l51.135"></a><span id="l51.135">       break;</span>
<a href="#l51.136"></a><span id="l51.136">     case LDAP_OPT_TIMELIMIT:</span>
<a href="#l51.137"></a><span id="l51.137" class="difflineminus">-      *((int *)optdata) = ld-&gt;ld_timelimit;</span>
<a href="#l51.138"></a><span id="l51.138" class="difflineplus">+      *((int*)optdata) = ld-&gt;ld_timelimit;</span>
<a href="#l51.139"></a><span id="l51.139">       break;</span>
<a href="#l51.140"></a><span id="l51.140">     case LDAP_OPT_REFERRAL_HOP_LIMIT:</span>
<a href="#l51.141"></a><span id="l51.141" class="difflineminus">-      *((int *)optdata) = ld-&gt;ld_refhoplimit;</span>
<a href="#l51.142"></a><span id="l51.142" class="difflineplus">+      *((int*)optdata) = ld-&gt;ld_refhoplimit;</span>
<a href="#l51.143"></a><span id="l51.143">       break;</span>
<a href="#l51.144"></a><span id="l51.144">     case LDAP_OPT_PROTOCOL_VERSION:</span>
<a href="#l51.145"></a><span id="l51.145" class="difflineminus">-      *((int *)optdata) = ld-&gt;ld_version;</span>
<a href="#l51.146"></a><span id="l51.146" class="difflineplus">+      *((int*)optdata) = ld-&gt;ld_version;</span>
<a href="#l51.147"></a><span id="l51.147">       break;</span>
<a href="#l51.148"></a><span id="l51.148">     case LDAP_OPT_SERVER_CONTROLS:</span>
<a href="#l51.149"></a><span id="l51.149">       /* fall through */</span>
<a href="#l51.150"></a><span id="l51.150">     case LDAP_OPT_CLIENT_CONTROLS:</span>
<a href="#l51.151"></a><span id="l51.151" class="difflineminus">-      *((LDAPControl ***)optdata) = NULL;</span>
<a href="#l51.152"></a><span id="l51.152" class="difflineplus">+      *((LDAPControl***)optdata) = NULL;</span>
<a href="#l51.153"></a><span id="l51.153">       /* nsldapi_dup_controls returns -1 and sets lderrno on error */</span>
<a href="#l51.154"></a><span id="l51.154" class="difflineminus">-      rc = nsldapi_dup_controls(ld, (LDAPControl ***)optdata,</span>
<a href="#l51.155"></a><span id="l51.155" class="difflineplus">+      rc = nsldapi_dup_controls(ld, (LDAPControl***)optdata,</span>
<a href="#l51.156"></a><span id="l51.156">                                 (option == LDAP_OPT_SERVER_CONTROLS)</span>
<a href="#l51.157"></a><span id="l51.157">                                     ? ld-&gt;ld_servercontrols</span>
<a href="#l51.158"></a><span id="l51.158">                                     : ld-&gt;ld_clientcontrols);</span>
<a href="#l51.159"></a><span id="l51.159">       break;</span>
<a href="#l51.160"></a><span id="l51.160"> </span>
<a href="#l51.161"></a><span id="l51.161">     /* rebind proc */</span>
<a href="#l51.162"></a><span id="l51.162">     case LDAP_OPT_REBIND_FN:</span>
<a href="#l51.163"></a><span id="l51.163" class="difflineminus">-      *((LDAP_REBINDPROC_CALLBACK **)optdata) = ld-&gt;ld_rebind_fn;</span>
<a href="#l51.164"></a><span id="l51.164" class="difflineplus">+      *((LDAP_REBINDPROC_CALLBACK**)optdata) = ld-&gt;ld_rebind_fn;</span>
<a href="#l51.165"></a><span id="l51.165">       break;</span>
<a href="#l51.166"></a><span id="l51.166">     case LDAP_OPT_REBIND_ARG:</span>
<a href="#l51.167"></a><span id="l51.167" class="difflineminus">-      *((void **)optdata) = ld-&gt;ld_rebind_arg;</span>
<a href="#l51.168"></a><span id="l51.168" class="difflineplus">+      *((void**)optdata) = ld-&gt;ld_rebind_arg;</span>
<a href="#l51.169"></a><span id="l51.169">       break;</span>
<a href="#l51.170"></a><span id="l51.170"> </span>
<a href="#l51.171"></a><span id="l51.171">     /* i/o function pointers */</span>
<a href="#l51.172"></a><span id="l51.172">     case LDAP_OPT_IO_FN_PTRS:</span>
<a href="#l51.173"></a><span id="l51.173">       if (ld-&gt;ld_io_fns_ptr == NULL) {</span>
<a href="#l51.174"></a><span id="l51.174">         memset(optdata, 0, sizeof(struct ldap_io_fns));</span>
<a href="#l51.175"></a><span id="l51.175">       } else {</span>
<a href="#l51.176"></a><span id="l51.176">         /* struct copy */</span>
<a href="#l51.177"></a><span id="l51.177" class="difflineminus">-        *((struct ldap_io_fns *)optdata) = *(ld-&gt;ld_io_fns_ptr);</span>
<a href="#l51.178"></a><span id="l51.178" class="difflineplus">+        *((struct ldap_io_fns*)optdata) = *(ld-&gt;ld_io_fns_ptr);</span>
<a href="#l51.179"></a><span id="l51.179">       }</span>
<a href="#l51.180"></a><span id="l51.180">       break;</span>
<a href="#l51.181"></a><span id="l51.181"> </span>
<a href="#l51.182"></a><span id="l51.182">     /* extended i/o function pointers */</span>
<a href="#l51.183"></a><span id="l51.183">     case LDAP_X_OPT_EXTIO_FN_PTRS:</span>
<a href="#l51.184"></a><span id="l51.184" class="difflineminus">-      if (((struct ldap_x_ext_io_fns *)optdata)-&gt;lextiof_size ==</span>
<a href="#l51.185"></a><span id="l51.185" class="difflineplus">+      if (((struct ldap_x_ext_io_fns*)optdata)-&gt;lextiof_size ==</span>
<a href="#l51.186"></a><span id="l51.186">           LDAP_X_EXTIO_FNS_SIZE_REV0) {</span>
<a href="#l51.187"></a><span id="l51.187" class="difflineminus">-        ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_close =</span>
<a href="#l51.188"></a><span id="l51.188" class="difflineplus">+        ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_close =</span>
<a href="#l51.189"></a><span id="l51.189">             ld-&gt;ld_extclose_fn;</span>
<a href="#l51.190"></a><span id="l51.190" class="difflineminus">-        ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_connect =</span>
<a href="#l51.191"></a><span id="l51.191" class="difflineplus">+        ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_connect =</span>
<a href="#l51.192"></a><span id="l51.192">             ld-&gt;ld_extconnect_fn;</span>
<a href="#l51.193"></a><span id="l51.193" class="difflineminus">-        ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_read =</span>
<a href="#l51.194"></a><span id="l51.194" class="difflineplus">+        ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_read =</span>
<a href="#l51.195"></a><span id="l51.195">             ld-&gt;ld_extread_fn;</span>
<a href="#l51.196"></a><span id="l51.196" class="difflineminus">-        ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_write =</span>
<a href="#l51.197"></a><span id="l51.197" class="difflineplus">+        ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_write =</span>
<a href="#l51.198"></a><span id="l51.198">             ld-&gt;ld_extwrite_fn;</span>
<a href="#l51.199"></a><span id="l51.199" class="difflineminus">-        ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_poll =</span>
<a href="#l51.200"></a><span id="l51.200" class="difflineplus">+        ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_poll =</span>
<a href="#l51.201"></a><span id="l51.201">             ld-&gt;ld_extpoll_fn;</span>
<a href="#l51.202"></a><span id="l51.202" class="difflineminus">-        ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_newhandle =</span>
<a href="#l51.203"></a><span id="l51.203" class="difflineplus">+        ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_newhandle =</span>
<a href="#l51.204"></a><span id="l51.204">             ld-&gt;ld_extnewhandle_fn;</span>
<a href="#l51.205"></a><span id="l51.205" class="difflineminus">-        ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_disposehandle =</span>
<a href="#l51.206"></a><span id="l51.206" class="difflineplus">+        ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_disposehandle =</span>
<a href="#l51.207"></a><span id="l51.207">             ld-&gt;ld_extdisposehandle_fn;</span>
<a href="#l51.208"></a><span id="l51.208" class="difflineminus">-        ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_session_arg =</span>
<a href="#l51.209"></a><span id="l51.209" class="difflineplus">+        ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_session_arg =</span>
<a href="#l51.210"></a><span id="l51.210">             ld-&gt;ld_ext_session_arg;</span>
<a href="#l51.211"></a><span id="l51.211" class="difflineminus">-      } else if (((struct ldap_x_ext_io_fns *)optdata)-&gt;lextiof_size ==</span>
<a href="#l51.212"></a><span id="l51.212" class="difflineplus">+      } else if (((struct ldap_x_ext_io_fns*)optdata)-&gt;lextiof_size ==</span>
<a href="#l51.213"></a><span id="l51.213">                  LDAP_X_EXTIO_FNS_SIZE) {</span>
<a href="#l51.214"></a><span id="l51.214">         /* struct copy */</span>
<a href="#l51.215"></a><span id="l51.215" class="difflineminus">-        *((struct ldap_x_ext_io_fns *)optdata) = ld-&gt;ld_ext_io_fns;</span>
<a href="#l51.216"></a><span id="l51.216" class="difflineplus">+        *((struct ldap_x_ext_io_fns*)optdata) = ld-&gt;ld_ext_io_fns;</span>
<a href="#l51.217"></a><span id="l51.217">       } else {</span>
<a href="#l51.218"></a><span id="l51.218">         LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l51.219"></a><span id="l51.219">         rc = -1;</span>
<a href="#l51.220"></a><span id="l51.220">       }</span>
<a href="#l51.221"></a><span id="l51.221">       break;</span>
<a href="#l51.222"></a><span id="l51.222"> </span>
<a href="#l51.223"></a><span id="l51.223">     /* get socketargp in extended i/o function */</span>
<a href="#l51.224"></a><span id="l51.224">     case LDAP_X_OPT_SOCKETARG:</span>
<a href="#l51.225"></a><span id="l51.225" class="difflineat">@@ -223,120 +223,120 @@ int LDAP_CALL ldap_get_option(LDAP *ld, </span>
<a href="#l51.226"></a><span id="l51.226">         LDAP_SET_LDERRNO(ld, LDAP_LOCAL_ERROR, NULL, NULL);</span>
<a href="#l51.227"></a><span id="l51.227">         rc = -1;</span>
<a href="#l51.228"></a><span id="l51.228">       }</span>
<a href="#l51.229"></a><span id="l51.229">       break;</span>
<a href="#l51.230"></a><span id="l51.230"> </span>
<a href="#l51.231"></a><span id="l51.231">     /* thread function pointers */</span>
<a href="#l51.232"></a><span id="l51.232">     case LDAP_OPT_THREAD_FN_PTRS:</span>
<a href="#l51.233"></a><span id="l51.233">       /* struct copy */</span>
<a href="#l51.234"></a><span id="l51.234" class="difflineminus">-      *((struct ldap_thread_fns *)optdata) = ld-&gt;ld_thread;</span>
<a href="#l51.235"></a><span id="l51.235" class="difflineplus">+      *((struct ldap_thread_fns*)optdata) = ld-&gt;ld_thread;</span>
<a href="#l51.236"></a><span id="l51.236">       break;</span>
<a href="#l51.237"></a><span id="l51.237"> </span>
<a href="#l51.238"></a><span id="l51.238">     /* extra thread function pointers */</span>
<a href="#l51.239"></a><span id="l51.239">     case LDAP_OPT_EXTRA_THREAD_FN_PTRS:</span>
<a href="#l51.240"></a><span id="l51.240">       /* struct copy */</span>
<a href="#l51.241"></a><span id="l51.241" class="difflineminus">-      *((struct ldap_extra_thread_fns *)optdata) = ld-&gt;ld_thread2;</span>
<a href="#l51.242"></a><span id="l51.242" class="difflineplus">+      *((struct ldap_extra_thread_fns*)optdata) = ld-&gt;ld_thread2;</span>
<a href="#l51.243"></a><span id="l51.243">       break;</span>
<a href="#l51.244"></a><span id="l51.244"> </span>
<a href="#l51.245"></a><span id="l51.245">     /* DNS function pointers */</span>
<a href="#l51.246"></a><span id="l51.246">     case LDAP_OPT_DNS_FN_PTRS:</span>
<a href="#l51.247"></a><span id="l51.247">       /* struct copy */</span>
<a href="#l51.248"></a><span id="l51.248" class="difflineminus">-      *((struct ldap_dns_fns *)optdata) = ld-&gt;ld_dnsfn;</span>
<a href="#l51.249"></a><span id="l51.249" class="difflineplus">+      *((struct ldap_dns_fns*)optdata) = ld-&gt;ld_dnsfn;</span>
<a href="#l51.250"></a><span id="l51.250">       break;</span>
<a href="#l51.251"></a><span id="l51.251"> </span>
<a href="#l51.252"></a><span id="l51.252">     /* cache function pointers */</span>
<a href="#l51.253"></a><span id="l51.253">     case LDAP_OPT_CACHE_FN_PTRS:</span>
<a href="#l51.254"></a><span id="l51.254">       /* struct copy */</span>
<a href="#l51.255"></a><span id="l51.255" class="difflineminus">-      *((struct ldap_cache_fns *)optdata) = ld-&gt;ld_cache;</span>
<a href="#l51.256"></a><span id="l51.256" class="difflineplus">+      *((struct ldap_cache_fns*)optdata) = ld-&gt;ld_cache;</span>
<a href="#l51.257"></a><span id="l51.257">       break;</span>
<a href="#l51.258"></a><span id="l51.258">     case LDAP_OPT_CACHE_STRATEGY:</span>
<a href="#l51.259"></a><span id="l51.259" class="difflineminus">-      *((int *)optdata) = ld-&gt;ld_cache_strategy;</span>
<a href="#l51.260"></a><span id="l51.260" class="difflineplus">+      *((int*)optdata) = ld-&gt;ld_cache_strategy;</span>
<a href="#l51.261"></a><span id="l51.261">       break;</span>
<a href="#l51.262"></a><span id="l51.262">     case LDAP_OPT_CACHE_ENABLE:</span>
<a href="#l51.263"></a><span id="l51.263" class="difflineminus">-      *((int *)optdata) = ld-&gt;ld_cache_on;</span>
<a href="#l51.264"></a><span id="l51.264" class="difflineplus">+      *((int*)optdata) = ld-&gt;ld_cache_on;</span>
<a href="#l51.265"></a><span id="l51.265">       break;</span>
<a href="#l51.266"></a><span id="l51.266"> </span>
<a href="#l51.267"></a><span id="l51.267">     case LDAP_OPT_ERROR_NUMBER:</span>
<a href="#l51.268"></a><span id="l51.268" class="difflineminus">-      *((int *)optdata) = LDAP_GET_LDERRNO(ld, NULL, NULL);</span>
<a href="#l51.269"></a><span id="l51.269" class="difflineplus">+      *((int*)optdata) = LDAP_GET_LDERRNO(ld, NULL, NULL);</span>
<a href="#l51.270"></a><span id="l51.270">       break;</span>
<a href="#l51.271"></a><span id="l51.271"> </span>
<a href="#l51.272"></a><span id="l51.272">     case LDAP_OPT_ERROR_STRING:</span>
<a href="#l51.273"></a><span id="l51.273" class="difflineminus">-      (void)LDAP_GET_LDERRNO(ld, NULL, (char **)optdata);</span>
<a href="#l51.274"></a><span id="l51.274" class="difflineminus">-      *((char **)optdata) = nsldapi_strdup(*((char **)optdata));</span>
<a href="#l51.275"></a><span id="l51.275" class="difflineplus">+      (void)LDAP_GET_LDERRNO(ld, NULL, (char**)optdata);</span>
<a href="#l51.276"></a><span id="l51.276" class="difflineplus">+      *((char**)optdata) = nsldapi_strdup(*((char**)optdata));</span>
<a href="#l51.277"></a><span id="l51.277">       break;</span>
<a href="#l51.278"></a><span id="l51.278"> </span>
<a href="#l51.279"></a><span id="l51.279">     case LDAP_OPT_MATCHED_DN:</span>
<a href="#l51.280"></a><span id="l51.280" class="difflineminus">-      (void)LDAP_GET_LDERRNO(ld, (char **)optdata, NULL);</span>
<a href="#l51.281"></a><span id="l51.281" class="difflineminus">-      *((char **)optdata) = nsldapi_strdup(*((char **)optdata));</span>
<a href="#l51.282"></a><span id="l51.282" class="difflineplus">+      (void)LDAP_GET_LDERRNO(ld, (char**)optdata, NULL);</span>
<a href="#l51.283"></a><span id="l51.283" class="difflineplus">+      *((char**)optdata) = nsldapi_strdup(*((char**)optdata));</span>
<a href="#l51.284"></a><span id="l51.284">       break;</span>
<a href="#l51.285"></a><span id="l51.285"> </span>
<a href="#l51.286"></a><span id="l51.286">     case LDAP_OPT_PREFERRED_LANGUAGE:</span>
<a href="#l51.287"></a><span id="l51.287">       if (NULL != ld-&gt;ld_preferred_language) {</span>
<a href="#l51.288"></a><span id="l51.288" class="difflineminus">-        *((char **)optdata) = nsldapi_strdup(ld-&gt;ld_preferred_language);</span>
<a href="#l51.289"></a><span id="l51.289" class="difflineplus">+        *((char**)optdata) = nsldapi_strdup(ld-&gt;ld_preferred_language);</span>
<a href="#l51.290"></a><span id="l51.290">       } else {</span>
<a href="#l51.291"></a><span id="l51.291" class="difflineminus">-        *((char **)optdata) = NULL;</span>
<a href="#l51.292"></a><span id="l51.292" class="difflineplus">+        *((char**)optdata) = NULL;</span>
<a href="#l51.293"></a><span id="l51.293">       }</span>
<a href="#l51.294"></a><span id="l51.294">       break;</span>
<a href="#l51.295"></a><span id="l51.295"> </span>
<a href="#l51.296"></a><span id="l51.296">     case LDAP_OPT_API_FEATURE_INFO:</span>
<a href="#l51.297"></a><span id="l51.297" class="difflineminus">-      rc = nsldapi_get_feature_info((LDAPAPIFeatureInfo *)optdata);</span>
<a href="#l51.298"></a><span id="l51.298" class="difflineplus">+      rc = nsldapi_get_feature_info((LDAPAPIFeatureInfo*)optdata);</span>
<a href="#l51.299"></a><span id="l51.299">       if (rc != LDAP_SUCCESS) {</span>
<a href="#l51.300"></a><span id="l51.300">         LDAP_SET_LDERRNO(ld, rc, NULL, NULL);</span>
<a href="#l51.301"></a><span id="l51.301">         rc = -1;</span>
<a href="#l51.302"></a><span id="l51.302">       }</span>
<a href="#l51.303"></a><span id="l51.303">       break;</span>
<a href="#l51.304"></a><span id="l51.304"> </span>
<a href="#l51.305"></a><span id="l51.305">     case LDAP_OPT_HOST_NAME:</span>
<a href="#l51.306"></a><span id="l51.306" class="difflineminus">-      *((char **)optdata) = nsldapi_strdup(ld-&gt;ld_defhost);</span>
<a href="#l51.307"></a><span id="l51.307" class="difflineplus">+      *((char**)optdata) = nsldapi_strdup(ld-&gt;ld_defhost);</span>
<a href="#l51.308"></a><span id="l51.308">       break;</span>
<a href="#l51.309"></a><span id="l51.309"> </span>
<a href="#l51.310"></a><span id="l51.310">     case LDAP_X_OPT_CONNECT_TIMEOUT:</span>
<a href="#l51.311"></a><span id="l51.311" class="difflineminus">-      *((int *)optdata) = ld-&gt;ld_connect_timeout;</span>
<a href="#l51.312"></a><span id="l51.312" class="difflineplus">+      *((int*)optdata) = ld-&gt;ld_connect_timeout;</span>
<a href="#l51.313"></a><span id="l51.313">       break;</span>
<a href="#l51.314"></a><span id="l51.314"> </span>
<a href="#l51.315"></a><span id="l51.315"> #ifdef LDAP_SASLIO_HOOKS</span>
<a href="#l51.316"></a><span id="l51.316">     /* SASL options */</span>
<a href="#l51.317"></a><span id="l51.317">     case LDAP_OPT_X_SASL_MECH:</span>
<a href="#l51.318"></a><span id="l51.318" class="difflineminus">-      *((char **)optdata) = nsldapi_strdup(ld-&gt;ld_def_sasl_mech);</span>
<a href="#l51.319"></a><span id="l51.319" class="difflineplus">+      *((char**)optdata) = nsldapi_strdup(ld-&gt;ld_def_sasl_mech);</span>
<a href="#l51.320"></a><span id="l51.320">       break;</span>
<a href="#l51.321"></a><span id="l51.321">     case LDAP_OPT_X_SASL_REALM:</span>
<a href="#l51.322"></a><span id="l51.322" class="difflineminus">-      *((char **)optdata) = nsldapi_strdup(ld-&gt;ld_def_sasl_realm);</span>
<a href="#l51.323"></a><span id="l51.323" class="difflineplus">+      *((char**)optdata) = nsldapi_strdup(ld-&gt;ld_def_sasl_realm);</span>
<a href="#l51.324"></a><span id="l51.324">       break;</span>
<a href="#l51.325"></a><span id="l51.325">     case LDAP_OPT_X_SASL_AUTHCID:</span>
<a href="#l51.326"></a><span id="l51.326" class="difflineminus">-      *((char **)optdata) = nsldapi_strdup(ld-&gt;ld_def_sasl_authcid);</span>
<a href="#l51.327"></a><span id="l51.327" class="difflineplus">+      *((char**)optdata) = nsldapi_strdup(ld-&gt;ld_def_sasl_authcid);</span>
<a href="#l51.328"></a><span id="l51.328">       break;</span>
<a href="#l51.329"></a><span id="l51.329">     case LDAP_OPT_X_SASL_AUTHZID:</span>
<a href="#l51.330"></a><span id="l51.330" class="difflineminus">-      *((char **)optdata) = nsldapi_strdup(ld-&gt;ld_def_sasl_authzid);</span>
<a href="#l51.331"></a><span id="l51.331" class="difflineplus">+      *((char**)optdata) = nsldapi_strdup(ld-&gt;ld_def_sasl_authzid);</span>
<a href="#l51.332"></a><span id="l51.332">       break;</span>
<a href="#l51.333"></a><span id="l51.333">     case LDAP_OPT_X_SASL_SSF: {</span>
<a href="#l51.334"></a><span id="l51.334">       int sc;</span>
<a href="#l51.335"></a><span id="l51.335" class="difflineminus">-      sasl_ssf_t *ssf;</span>
<a href="#l51.336"></a><span id="l51.336" class="difflineminus">-      sasl_conn_t *ctx;</span>
<a href="#l51.337"></a><span id="l51.337" class="difflineplus">+      sasl_ssf_t* ssf;</span>
<a href="#l51.338"></a><span id="l51.338" class="difflineplus">+      sasl_conn_t* ctx;</span>
<a href="#l51.339"></a><span id="l51.339">       if (ld-&gt;ld_defconn == NULL) {</span>
<a href="#l51.340"></a><span id="l51.340">         return -1;</span>
<a href="#l51.341"></a><span id="l51.341">       }</span>
<a href="#l51.342"></a><span id="l51.342" class="difflineminus">-      ctx = (sasl_conn_t *)(ld-&gt;ld_defconn-&gt;lconn_sasl_ctx);</span>
<a href="#l51.343"></a><span id="l51.343" class="difflineplus">+      ctx = (sasl_conn_t*)(ld-&gt;ld_defconn-&gt;lconn_sasl_ctx);</span>
<a href="#l51.344"></a><span id="l51.344">       if (ctx == NULL) {</span>
<a href="#l51.345"></a><span id="l51.345">         return -1;</span>
<a href="#l51.346"></a><span id="l51.346">       }</span>
<a href="#l51.347"></a><span id="l51.347" class="difflineminus">-      sc = sasl_getprop(ctx, SASL_SSF, (const void **)&amp;ssf);</span>
<a href="#l51.348"></a><span id="l51.348" class="difflineplus">+      sc = sasl_getprop(ctx, SASL_SSF, (const void**)&amp;ssf);</span>
<a href="#l51.349"></a><span id="l51.349">       if (sc != SASL_OK) {</span>
<a href="#l51.350"></a><span id="l51.350">         return -1;</span>
<a href="#l51.351"></a><span id="l51.351">       }</span>
<a href="#l51.352"></a><span id="l51.352" class="difflineminus">-      *((sasl_ssf_t *)optdata) = *ssf;</span>
<a href="#l51.353"></a><span id="l51.353" class="difflineplus">+      *((sasl_ssf_t*)optdata) = *ssf;</span>
<a href="#l51.354"></a><span id="l51.354">     } break;</span>
<a href="#l51.355"></a><span id="l51.355">     case LDAP_OPT_X_SASL_SSF_MIN:</span>
<a href="#l51.356"></a><span id="l51.356" class="difflineminus">-      *((sasl_ssf_t *)optdata) = ld-&gt;ld_sasl_secprops.min_ssf;</span>
<a href="#l51.357"></a><span id="l51.357" class="difflineplus">+      *((sasl_ssf_t*)optdata) = ld-&gt;ld_sasl_secprops.min_ssf;</span>
<a href="#l51.358"></a><span id="l51.358">       break;</span>
<a href="#l51.359"></a><span id="l51.359">     case LDAP_OPT_X_SASL_SSF_MAX:</span>
<a href="#l51.360"></a><span id="l51.360" class="difflineminus">-      *((sasl_ssf_t *)optdata) = ld-&gt;ld_sasl_secprops.max_ssf;</span>
<a href="#l51.361"></a><span id="l51.361" class="difflineplus">+      *((sasl_ssf_t*)optdata) = ld-&gt;ld_sasl_secprops.max_ssf;</span>
<a href="#l51.362"></a><span id="l51.362">       break;</span>
<a href="#l51.363"></a><span id="l51.363">     case LDAP_OPT_X_SASL_MAXBUFSIZE:</span>
<a href="#l51.364"></a><span id="l51.364" class="difflineminus">-      *((sasl_ssf_t *)optdata) = ld-&gt;ld_sasl_secprops.maxbufsize;</span>
<a href="#l51.365"></a><span id="l51.365" class="difflineplus">+      *((sasl_ssf_t*)optdata) = ld-&gt;ld_sasl_secprops.maxbufsize;</span>
<a href="#l51.366"></a><span id="l51.366">       break;</span>
<a href="#l51.367"></a><span id="l51.367">     case LDAP_OPT_X_SASL_SSF_EXTERNAL:</span>
<a href="#l51.368"></a><span id="l51.368">     case LDAP_OPT_X_SASL_SECPROPS:</span>
<a href="#l51.369"></a><span id="l51.369">       /*</span>
<a href="#l51.370"></a><span id="l51.370">        * These options are write only.  Making these options</span>
<a href="#l51.371"></a><span id="l51.371">        * read/write would expose semi-private interfaces of libsasl</span>
<a href="#l51.372"></a><span id="l51.372">        * for which there are no cross platform/standardized</span>
<a href="#l51.373"></a><span id="l51.373">        * definitions.</span>
<a href="#l51.374"></a><span id="l51.374" class="difflineat">@@ -380,17 +380,17 @@ static LDAPAPIFeatureInfo nsldapi_extens</span>
<a href="#l51.375"></a><span id="l51.375"> </span>
<a href="#l51.376"></a><span id="l51.376"> #define NSLDAPI_EXTENSIONS_COUNT \</span>
<a href="#l51.377"></a><span id="l51.377">   (sizeof(nsldapi_extensions) / sizeof(LDAPAPIFeatureInfo))</span>
<a href="#l51.378"></a><span id="l51.378"> </span>
<a href="#l51.379"></a><span id="l51.379"> /*</span>
<a href="#l51.380"></a><span id="l51.380">  * Retrieve information about this implementation of the LDAP API.</span>
<a href="#l51.381"></a><span id="l51.381">  * Returns an LDAP error code.</span>
<a href="#l51.382"></a><span id="l51.382">  */</span>
<a href="#l51.383"></a><span id="l51.383" class="difflineminus">-static int nsldapi_get_api_info(LDAPAPIInfo *aip) {</span>
<a href="#l51.384"></a><span id="l51.384" class="difflineplus">+static int nsldapi_get_api_info(LDAPAPIInfo* aip) {</span>
<a href="#l51.385"></a><span id="l51.385">   int i;</span>
<a href="#l51.386"></a><span id="l51.386"> </span>
<a href="#l51.387"></a><span id="l51.387">   if (aip == NULL) {</span>
<a href="#l51.388"></a><span id="l51.388">     return (LDAP_PARAM_ERROR);</span>
<a href="#l51.389"></a><span id="l51.389">   }</span>
<a href="#l51.390"></a><span id="l51.390"> </span>
<a href="#l51.391"></a><span id="l51.391">   aip-&gt;ldapai_api_version = LDAP_API_VERSION;</span>
<a href="#l51.392"></a><span id="l51.392"> </span>
<a href="#l51.393"></a><span id="l51.393" class="difflineat">@@ -405,17 +405,17 @@ static int nsldapi_get_api_info(LDAPAPII</span>
<a href="#l51.394"></a><span id="l51.394">   if ((aip-&gt;ldapai_vendor_name = nsldapi_strdup(LDAP_VENDOR_NAME)) == NULL) {</span>
<a href="#l51.395"></a><span id="l51.395">     return (LDAP_NO_MEMORY);</span>
<a href="#l51.396"></a><span id="l51.396">   }</span>
<a href="#l51.397"></a><span id="l51.397"> </span>
<a href="#l51.398"></a><span id="l51.398">   if (NSLDAPI_EXTENSIONS_COUNT &lt; 1) {</span>
<a href="#l51.399"></a><span id="l51.399">     aip-&gt;ldapai_extensions = NULL;</span>
<a href="#l51.400"></a><span id="l51.400">   } else {</span>
<a href="#l51.401"></a><span id="l51.401">     if ((aip-&gt;ldapai_extensions = NSLDAPI_CALLOC(NSLDAPI_EXTENSIONS_COUNT + 1,</span>
<a href="#l51.402"></a><span id="l51.402" class="difflineminus">-                                                 sizeof(char *))) == NULL) {</span>
<a href="#l51.403"></a><span id="l51.403" class="difflineplus">+                                                 sizeof(char*))) == NULL) {</span>
<a href="#l51.404"></a><span id="l51.404">       NSLDAPI_FREE(aip-&gt;ldapai_vendor_name);</span>
<a href="#l51.405"></a><span id="l51.405">       aip-&gt;ldapai_vendor_name = NULL;</span>
<a href="#l51.406"></a><span id="l51.406">       return (LDAP_NO_MEMORY);</span>
<a href="#l51.407"></a><span id="l51.407">     }</span>
<a href="#l51.408"></a><span id="l51.408"> </span>
<a href="#l51.409"></a><span id="l51.409">     for (i = 0; i &lt; NSLDAPI_EXTENSIONS_COUNT; ++i) {</span>
<a href="#l51.410"></a><span id="l51.410">       if ((aip-&gt;ldapai_extensions[i] =</span>
<a href="#l51.411"></a><span id="l51.411">                nsldapi_strdup(nsldapi_extensions[i].ldapaif_name)) == NULL) {</span>
<a href="#l51.412"></a><span id="l51.412" class="difflineat">@@ -430,17 +430,17 @@ static int nsldapi_get_api_info(LDAPAPII</span>
<a href="#l51.413"></a><span id="l51.413"> </span>
<a href="#l51.414"></a><span id="l51.414">   return (LDAP_SUCCESS);</span>
<a href="#l51.415"></a><span id="l51.415"> }</span>
<a href="#l51.416"></a><span id="l51.416"> </span>
<a href="#l51.417"></a><span id="l51.417"> /*</span>
<a href="#l51.418"></a><span id="l51.418">  * Retrieves information about a specific extended feature of the LDAP API/</span>
<a href="#l51.419"></a><span id="l51.419">  * Returns an LDAP error code.</span>
<a href="#l51.420"></a><span id="l51.420">  */</span>
<a href="#l51.421"></a><span id="l51.421" class="difflineminus">-static int nsldapi_get_feature_info(LDAPAPIFeatureInfo *fip) {</span>
<a href="#l51.422"></a><span id="l51.422" class="difflineplus">+static int nsldapi_get_feature_info(LDAPAPIFeatureInfo* fip) {</span>
<a href="#l51.423"></a><span id="l51.423">   int i;</span>
<a href="#l51.424"></a><span id="l51.424"> </span>
<a href="#l51.425"></a><span id="l51.425">   if (fip == NULL || fip-&gt;ldapaif_name == NULL) {</span>
<a href="#l51.426"></a><span id="l51.426">     return (LDAP_PARAM_ERROR);</span>
<a href="#l51.427"></a><span id="l51.427">   }</span>
<a href="#l51.428"></a><span id="l51.428"> </span>
<a href="#l51.429"></a><span id="l51.429">   if (fip-&gt;ldapaif_info_version != LDAP_FEATURE_INFO_VERSION) {</span>
<a href="#l51.430"></a><span id="l51.430">     fip-&gt;ldapaif_info_version = LDAP_FEATURE_INFO_VERSION;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l52.1"></a><span id="l52.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/getvalues.c</span>
<a href="#l52.2"></a><span id="l52.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/getvalues.c</span>
<a href="#l52.3"></a><span id="l52.3" class="difflineat">@@ -45,22 +45,22 @@</span>
<a href="#l52.4"></a><span id="l52.4"> #if 0</span>
<a href="#l52.5"></a><span id="l52.5"> #  ifndef lint</span>
<a href="#l52.6"></a><span id="l52.6"> static char copyright[] = &quot;@(#) Copyright (c) 1990 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l52.7"></a><span id="l52.7"> #  endif</span>
<a href="#l52.8"></a><span id="l52.8"> #endif</span>
<a href="#l52.9"></a><span id="l52.9"> </span>
<a href="#l52.10"></a><span id="l52.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l52.11"></a><span id="l52.11"> </span>
<a href="#l52.12"></a><span id="l52.12" class="difflineminus">-static void **internal_ldap_get_values(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l52.13"></a><span id="l52.13" class="difflineminus">-                                       const char *target, int lencall) {</span>
<a href="#l52.14"></a><span id="l52.14" class="difflineplus">+static void** internal_ldap_get_values(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l52.15"></a><span id="l52.15" class="difflineplus">+                                       const char* target, int lencall) {</span>
<a href="#l52.16"></a><span id="l52.16">   struct berelement ber;</span>
<a href="#l52.17"></a><span id="l52.17" class="difflineminus">-  char *attr;</span>
<a href="#l52.18"></a><span id="l52.18" class="difflineplus">+  char* attr;</span>
<a href="#l52.19"></a><span id="l52.19">   int rc;</span>
<a href="#l52.20"></a><span id="l52.20" class="difflineminus">-  void **vals;</span>
<a href="#l52.21"></a><span id="l52.21" class="difflineplus">+  void** vals;</span>
<a href="#l52.22"></a><span id="l52.22"> </span>
<a href="#l52.23"></a><span id="l52.23">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_get_values\n&quot;, 0, 0, 0);</span>
<a href="#l52.24"></a><span id="l52.24"> </span>
<a href="#l52.25"></a><span id="l52.25">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l52.26"></a><span id="l52.26">     return (NULL); /* punt */</span>
<a href="#l52.27"></a><span id="l52.27">   }</span>
<a href="#l52.28"></a><span id="l52.28">   if (target == NULL || !NSLDAPI_VALID_LDAPMESSAGE_ENTRY_POINTER(entry)) {</span>
<a href="#l52.29"></a><span id="l52.29">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l52.30"></a><span id="l52.30" class="difflineat">@@ -70,26 +70,26 @@ static void **internal_ldap_get_values(L</span>
<a href="#l52.31"></a><span id="l52.31">   ber = *entry-&gt;lm_ber;</span>
<a href="#l52.32"></a><span id="l52.32"> </span>
<a href="#l52.33"></a><span id="l52.33">   /* skip sequence, dn, sequence of, and snag the first attr */</span>
<a href="#l52.34"></a><span id="l52.34">   if (ber_scanf(&amp;ber, &quot;{x{{a&quot;, &amp;attr) == LBER_ERROR) {</span>
<a href="#l52.35"></a><span id="l52.35">     LDAP_SET_LDERRNO(ld, LDAP_DECODING_ERROR, NULL, NULL);</span>
<a href="#l52.36"></a><span id="l52.36">     return (NULL);</span>
<a href="#l52.37"></a><span id="l52.37">   }</span>
<a href="#l52.38"></a><span id="l52.38"> </span>
<a href="#l52.39"></a><span id="l52.39" class="difflineminus">-  rc = strcasecmp((char *)target, attr);</span>
<a href="#l52.40"></a><span id="l52.40" class="difflineplus">+  rc = strcasecmp((char*)target, attr);</span>
<a href="#l52.41"></a><span id="l52.41">   NSLDAPI_FREE(attr);</span>
<a href="#l52.42"></a><span id="l52.42">   if (rc != 0) {</span>
<a href="#l52.43"></a><span id="l52.43">     while (1) {</span>
<a href="#l52.44"></a><span id="l52.44">       if (ber_scanf(&amp;ber, &quot;x}{a&quot;, &amp;attr) == LBER_ERROR) {</span>
<a href="#l52.45"></a><span id="l52.45">         LDAP_SET_LDERRNO(ld, LDAP_DECODING_ERROR, NULL, NULL);</span>
<a href="#l52.46"></a><span id="l52.46">         return (NULL);</span>
<a href="#l52.47"></a><span id="l52.47">       }</span>
<a href="#l52.48"></a><span id="l52.48"> </span>
<a href="#l52.49"></a><span id="l52.49" class="difflineminus">-      rc = strcasecmp((char *)target, attr);</span>
<a href="#l52.50"></a><span id="l52.50" class="difflineplus">+      rc = strcasecmp((char*)target, attr);</span>
<a href="#l52.51"></a><span id="l52.51">       if (rc == 0) {</span>
<a href="#l52.52"></a><span id="l52.52">         NSLDAPI_FREE(attr);</span>
<a href="#l52.53"></a><span id="l52.53">         break;</span>
<a href="#l52.54"></a><span id="l52.54">       }</span>
<a href="#l52.55"></a><span id="l52.55">       NSLDAPI_FREE(attr);</span>
<a href="#l52.56"></a><span id="l52.56">     }</span>
<a href="#l52.57"></a><span id="l52.57">   }</span>
<a href="#l52.58"></a><span id="l52.58"> </span>
<a href="#l52.59"></a><span id="l52.59" class="difflineat">@@ -144,22 +144,22 @@ static void **internal_ldap_get_values(L</span>
<a href="#l52.60"></a><span id="l52.60"> #define LANG_SUBTYPE_INDEX_NONE -1</span>
<a href="#l52.61"></a><span id="l52.61"> #define LANG_SUBTYPE_INDEX_DUPLICATE -2</span>
<a href="#l52.62"></a><span id="l52.62"> </span>
<a href="#l52.63"></a><span id="l52.63"> typedef struct {</span>
<a href="#l52.64"></a><span id="l52.64">   int start;</span>
<a href="#l52.65"></a><span id="l52.65">   int length;</span>
<a href="#l52.66"></a><span id="l52.66"> } _SubStringIndex;</span>
<a href="#l52.67"></a><span id="l52.67"> </span>
<a href="#l52.68"></a><span id="l52.68" class="difflineminus">-static int parse_subtypes(const char *target, int *baseLenp, char **langp,</span>
<a href="#l52.69"></a><span id="l52.69" class="difflineminus">-                          _SubStringIndex **subs, int *nsubtypes) {</span>
<a href="#l52.70"></a><span id="l52.70" class="difflineplus">+static int parse_subtypes(const char* target, int* baseLenp, char** langp,</span>
<a href="#l52.71"></a><span id="l52.71" class="difflineplus">+                          _SubStringIndex** subs, int* nsubtypes) {</span>
<a href="#l52.72"></a><span id="l52.72">   int nSubtypes = 0;</span>
<a href="#l52.73"></a><span id="l52.73">   int ind = 0;</span>
<a href="#l52.74"></a><span id="l52.74" class="difflineminus">-  char *nextToken;</span>
<a href="#l52.75"></a><span id="l52.75" class="difflineminus">-  _SubStringIndex *result = NULL;</span>
<a href="#l52.76"></a><span id="l52.76" class="difflineplus">+  char* nextToken;</span>
<a href="#l52.77"></a><span id="l52.77" class="difflineplus">+  _SubStringIndex* result = NULL;</span>
<a href="#l52.78"></a><span id="l52.78">   int langIndex;</span>
<a href="#l52.79"></a><span id="l52.79">   int targetLen;</span>
<a href="#l52.80"></a><span id="l52.80">   int subtypeStart;</span>
<a href="#l52.81"></a><span id="l52.81"> </span>
<a href="#l52.82"></a><span id="l52.82">   langIndex = LANG_SUBTYPE_INDEX_NONE;</span>
<a href="#l52.83"></a><span id="l52.83">   *subs = NULL;</span>
<a href="#l52.84"></a><span id="l52.84">   *langp = NULL;</span>
<a href="#l52.85"></a><span id="l52.85">   *baseLenp = 0;</span>
<a href="#l52.86"></a><span id="l52.86" class="difflineat">@@ -173,19 +173,19 @@ static int parse_subtypes(const char *ta</span>
<a href="#l52.87"></a><span id="l52.87">     *baseLenp = subtypeStart - 1;</span>
<a href="#l52.88"></a><span id="l52.88">   } else {</span>
<a href="#l52.89"></a><span id="l52.89">     subtypeStart = targetLen;</span>
<a href="#l52.90"></a><span id="l52.90">     *baseLenp = subtypeStart;</span>
<a href="#l52.91"></a><span id="l52.91">   }</span>
<a href="#l52.92"></a><span id="l52.92">   ind = subtypeStart;</span>
<a href="#l52.93"></a><span id="l52.93"> </span>
<a href="#l52.94"></a><span id="l52.94">   /* How many subtypes? */</span>
<a href="#l52.95"></a><span id="l52.95" class="difflineminus">-  nextToken = (char *)target + subtypeStart;</span>
<a href="#l52.96"></a><span id="l52.96" class="difflineplus">+  nextToken = (char*)target + subtypeStart;</span>
<a href="#l52.97"></a><span id="l52.97">   while (nextToken &amp;&amp; *nextToken) {</span>
<a href="#l52.98"></a><span id="l52.98" class="difflineminus">-    char *thisToken = nextToken;</span>
<a href="#l52.99"></a><span id="l52.99" class="difflineplus">+    char* thisToken = nextToken;</span>
<a href="#l52.100"></a><span id="l52.100">     nextToken = strchr(thisToken, ';');</span>
<a href="#l52.101"></a><span id="l52.101">     if (NULL != nextToken) nextToken++;</span>
<a href="#l52.102"></a><span id="l52.102">     if (0 == strncasecmp(thisToken, &quot;lang-&quot;, 5)) {</span>
<a href="#l52.103"></a><span id="l52.103">       /* If there was a previous lang tag, this is illegal! */</span>
<a href="#l52.104"></a><span id="l52.104">       if (langIndex != LANG_SUBTYPE_INDEX_NONE) {</span>
<a href="#l52.105"></a><span id="l52.105">         langIndex = LANG_SUBTYPE_INDEX_DUPLICATE;</span>
<a href="#l52.106"></a><span id="l52.106">         return langIndex;</span>
<a href="#l52.107"></a><span id="l52.107">       } else {</span>
<a href="#l52.108"></a><span id="l52.108" class="difflineat">@@ -195,73 +195,73 @@ static int parse_subtypes(const char *ta</span>
<a href="#l52.109"></a><span id="l52.109">       nSubtypes++;</span>
<a href="#l52.110"></a><span id="l52.110">     }</span>
<a href="#l52.111"></a><span id="l52.111">   }</span>
<a href="#l52.112"></a><span id="l52.112">   /* No language subtype? */</span>
<a href="#l52.113"></a><span id="l52.113">   if (langIndex &lt; 0) return langIndex;</span>
<a href="#l52.114"></a><span id="l52.114"> </span>
<a href="#l52.115"></a><span id="l52.115">   /* Allocate array of non-language subtypes */</span>
<a href="#l52.116"></a><span id="l52.116">   if (nSubtypes &gt; 0) {</span>
<a href="#l52.117"></a><span id="l52.117" class="difflineminus">-    result = (_SubStringIndex *)NSLDAPI_MALLOC(sizeof(*result) * nSubtypes);</span>
<a href="#l52.118"></a><span id="l52.118" class="difflineplus">+    result = (_SubStringIndex*)NSLDAPI_MALLOC(sizeof(*result) * nSubtypes);</span>
<a href="#l52.119"></a><span id="l52.119">     memset(result, 0, sizeof(*result) * nSubtypes);</span>
<a href="#l52.120"></a><span id="l52.120">   }</span>
<a href="#l52.121"></a><span id="l52.121">   ind = 0;</span>
<a href="#l52.122"></a><span id="l52.122">   nSubtypes = 0;</span>
<a href="#l52.123"></a><span id="l52.123">   ind = subtypeStart;</span>
<a href="#l52.124"></a><span id="l52.124" class="difflineminus">-  nextToken = (char *)target + subtypeStart;</span>
<a href="#l52.125"></a><span id="l52.125" class="difflineplus">+  nextToken = (char*)target + subtypeStart;</span>
<a href="#l52.126"></a><span id="l52.126">   while (nextToken &amp;&amp; *nextToken) {</span>
<a href="#l52.127"></a><span id="l52.127" class="difflineminus">-    char *thisToken = nextToken;</span>
<a href="#l52.128"></a><span id="l52.128" class="difflineplus">+    char* thisToken = nextToken;</span>
<a href="#l52.129"></a><span id="l52.129">     int len;</span>
<a href="#l52.130"></a><span id="l52.130">     nextToken = strchr(thisToken, ';');</span>
<a href="#l52.131"></a><span id="l52.131">     if (NULL != nextToken) {</span>
<a href="#l52.132"></a><span id="l52.132">       len = nextToken - thisToken;</span>
<a href="#l52.133"></a><span id="l52.133">       nextToken++;</span>
<a href="#l52.134"></a><span id="l52.134">     } else {</span>
<a href="#l52.135"></a><span id="l52.135" class="difflineminus">-      nextToken = (char *)target + targetLen;</span>
<a href="#l52.136"></a><span id="l52.136" class="difflineplus">+      nextToken = (char*)target + targetLen;</span>
<a href="#l52.137"></a><span id="l52.137">       len = nextToken - thisToken;</span>
<a href="#l52.138"></a><span id="l52.138">     }</span>
<a href="#l52.139"></a><span id="l52.139">     if (0 == strncasecmp(thisToken, &quot;lang-&quot;, 5)) {</span>
<a href="#l52.140"></a><span id="l52.140">       int i;</span>
<a href="#l52.141"></a><span id="l52.141" class="difflineminus">-      *langp = (char *)NSLDAPI_MALLOC(len + 1);</span>
<a href="#l52.142"></a><span id="l52.142" class="difflineplus">+      *langp = (char*)NSLDAPI_MALLOC(len + 1);</span>
<a href="#l52.143"></a><span id="l52.143">       for (i = 0; i &lt; len; i++) (*langp)[i] = toupper(target[ind + i]);</span>
<a href="#l52.144"></a><span id="l52.144">       (*langp)[len] = 0;</span>
<a href="#l52.145"></a><span id="l52.145">     } else {</span>
<a href="#l52.146"></a><span id="l52.146">       result[nSubtypes].start = thisToken - target;</span>
<a href="#l52.147"></a><span id="l52.147">       result[nSubtypes].length = len;</span>
<a href="#l52.148"></a><span id="l52.148">       nSubtypes++;</span>
<a href="#l52.149"></a><span id="l52.149">     }</span>
<a href="#l52.150"></a><span id="l52.150">   }</span>
<a href="#l52.151"></a><span id="l52.151">   *subs = result;</span>
<a href="#l52.152"></a><span id="l52.152">   *nsubtypes = nSubtypes;</span>
<a href="#l52.153"></a><span id="l52.153">   return langIndex;</span>
<a href="#l52.154"></a><span id="l52.154"> }</span>
<a href="#l52.155"></a><span id="l52.155"> </span>
<a href="#l52.156"></a><span id="l52.156" class="difflineminus">-static int check_lang_match(const char *target, const char *baseTarget,</span>
<a href="#l52.157"></a><span id="l52.157" class="difflineminus">-                            _SubStringIndex *targetTypes, int ntargetTypes,</span>
<a href="#l52.158"></a><span id="l52.158" class="difflineminus">-                            char *targetLang, char *attr) {</span>
<a href="#l52.159"></a><span id="l52.159" class="difflineplus">+static int check_lang_match(const char* target, const char* baseTarget,</span>
<a href="#l52.160"></a><span id="l52.160" class="difflineplus">+                            _SubStringIndex* targetTypes, int ntargetTypes,</span>
<a href="#l52.161"></a><span id="l52.161" class="difflineplus">+                            char* targetLang, char* attr) {</span>
<a href="#l52.162"></a><span id="l52.162">   int langIndex;</span>
<a href="#l52.163"></a><span id="l52.163" class="difflineminus">-  _SubStringIndex *subtypes;</span>
<a href="#l52.164"></a><span id="l52.164" class="difflineplus">+  _SubStringIndex* subtypes;</span>
<a href="#l52.165"></a><span id="l52.165">   int baseLen;</span>
<a href="#l52.166"></a><span id="l52.166" class="difflineminus">-  char *lang;</span>
<a href="#l52.167"></a><span id="l52.167" class="difflineplus">+  char* lang;</span>
<a href="#l52.168"></a><span id="l52.168">   int nsubtypes;</span>
<a href="#l52.169"></a><span id="l52.169">   int mismatch = 0;</span>
<a href="#l52.170"></a><span id="l52.170">   int match = -1;</span>
<a href="#l52.171"></a><span id="l52.171">   int i;</span>
<a href="#l52.172"></a><span id="l52.172"> </span>
<a href="#l52.173"></a><span id="l52.173">   /* Get all subtypes in the attribute name */</span>
<a href="#l52.174"></a><span id="l52.174">   langIndex = parse_subtypes(attr, &amp;baseLen, &amp;lang, &amp;subtypes, &amp;nsubtypes);</span>
<a href="#l52.175"></a><span id="l52.175"> </span>
<a href="#l52.176"></a><span id="l52.176">   /* Check if there any required non-language subtypes which are</span>
<a href="#l52.177"></a><span id="l52.177">      not in this attribute */</span>
<a href="#l52.178"></a><span id="l52.178">   for (i = 0; i &lt; ntargetTypes; i++) {</span>
<a href="#l52.179"></a><span id="l52.179" class="difflineminus">-    char *t = (char *)target + targetTypes[i].start;</span>
<a href="#l52.180"></a><span id="l52.180" class="difflineplus">+    char* t = (char*)target + targetTypes[i].start;</span>
<a href="#l52.181"></a><span id="l52.181">     int tlen = targetTypes[i].length;</span>
<a href="#l52.182"></a><span id="l52.182">     int j;</span>
<a href="#l52.183"></a><span id="l52.183">     for (j = 0; j &lt; nsubtypes; j++) {</span>
<a href="#l52.184"></a><span id="l52.184" class="difflineminus">-      char *a = attr + subtypes[j].start;</span>
<a href="#l52.185"></a><span id="l52.185" class="difflineplus">+      char* a = attr + subtypes[j].start;</span>
<a href="#l52.186"></a><span id="l52.186">       int alen = subtypes[j].length;</span>
<a href="#l52.187"></a><span id="l52.187">       if ((tlen == alen) &amp;&amp; !strncasecmp(t, a, tlen)) break;</span>
<a href="#l52.188"></a><span id="l52.188">     }</span>
<a href="#l52.189"></a><span id="l52.189">     if (j &gt;= nsubtypes) {</span>
<a href="#l52.190"></a><span id="l52.190">       mismatch = 1;</span>
<a href="#l52.191"></a><span id="l52.191">       break;</span>
<a href="#l52.192"></a><span id="l52.192">     }</span>
<a href="#l52.193"></a><span id="l52.193">   }</span>
<a href="#l52.194"></a><span id="l52.194" class="difflineat">@@ -291,40 +291,40 @@ static int check_lang_match(const char *</span>
<a href="#l52.195"></a><span id="l52.195">   if (!lang[i] || (lang[i] == ';')) {</span>
<a href="#l52.196"></a><span id="l52.196">     /* If the found subtype is shorter than the requested one, the next</span>
<a href="#l52.197"></a><span id="l52.197">        character in the requested one should be &quot;-&quot; */</span>
<a href="#l52.198"></a><span id="l52.198">     if (!targetLang[i] || (targetLang[i] == '-')) match = i;</span>
<a href="#l52.199"></a><span id="l52.199">   }</span>
<a href="#l52.200"></a><span id="l52.200">   return match;</span>
<a href="#l52.201"></a><span id="l52.201"> }</span>
<a href="#l52.202"></a><span id="l52.202"> </span>
<a href="#l52.203"></a><span id="l52.203" class="difflineminus">-static int check_base_match(const char *target, char *attr) {</span>
<a href="#l52.204"></a><span id="l52.204" class="difflineplus">+static int check_base_match(const char* target, char* attr) {</span>
<a href="#l52.205"></a><span id="l52.205">   int i = 0;</span>
<a href="#l52.206"></a><span id="l52.206">   int rc;</span>
<a href="#l52.207"></a><span id="l52.207">   while (target[i] &amp;&amp; attr[i] &amp;&amp; (toupper(target[i]) == toupper(attr[i]))) i++;</span>
<a href="#l52.208"></a><span id="l52.208">   rc = (!target[i] &amp;&amp; (!attr[i] || (';' == attr[i])));</span>
<a href="#l52.209"></a><span id="l52.209">   return rc;</span>
<a href="#l52.210"></a><span id="l52.210"> }</span>
<a href="#l52.211"></a><span id="l52.211"> </span>
<a href="#l52.212"></a><span id="l52.212" class="difflineminus">-static void **internal_ldap_get_lang_values(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l52.213"></a><span id="l52.213" class="difflineminus">-                                            const char *target, char **type,</span>
<a href="#l52.214"></a><span id="l52.214" class="difflineplus">+static void** internal_ldap_get_lang_values(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l52.215"></a><span id="l52.215" class="difflineplus">+                                            const char* target, char** type,</span>
<a href="#l52.216"></a><span id="l52.216">                                             int lencall) {</span>
<a href="#l52.217"></a><span id="l52.217">   struct berelement ber;</span>
<a href="#l52.218"></a><span id="l52.218" class="difflineminus">-  char *attr = NULL;</span>
<a href="#l52.219"></a><span id="l52.219" class="difflineplus">+  char* attr = NULL;</span>
<a href="#l52.220"></a><span id="l52.220">   int rc;</span>
<a href="#l52.221"></a><span id="l52.221" class="difflineminus">-  void **vals = NULL;</span>
<a href="#l52.222"></a><span id="l52.222" class="difflineplus">+  void** vals = NULL;</span>
<a href="#l52.223"></a><span id="l52.223">   int langIndex;</span>
<a href="#l52.224"></a><span id="l52.224" class="difflineminus">-  _SubStringIndex *subtypes;</span>
<a href="#l52.225"></a><span id="l52.225" class="difflineplus">+  _SubStringIndex* subtypes;</span>
<a href="#l52.226"></a><span id="l52.226">   int nsubtypes;</span>
<a href="#l52.227"></a><span id="l52.227" class="difflineminus">-  char *baseTarget = NULL;</span>
<a href="#l52.228"></a><span id="l52.228" class="difflineplus">+  char* baseTarget = NULL;</span>
<a href="#l52.229"></a><span id="l52.229">   int bestMatch = 0;</span>
<a href="#l52.230"></a><span id="l52.230" class="difflineminus">-  char *lang = NULL;</span>
<a href="#l52.231"></a><span id="l52.231" class="difflineplus">+  char* lang = NULL;</span>
<a href="#l52.232"></a><span id="l52.232">   int len;</span>
<a href="#l52.233"></a><span id="l52.233">   int firstAttr = 1;</span>
<a href="#l52.234"></a><span id="l52.234" class="difflineminus">-  char *bestType = NULL;</span>
<a href="#l52.235"></a><span id="l52.235" class="difflineplus">+  char* bestType = NULL;</span>
<a href="#l52.236"></a><span id="l52.236"> </span>
<a href="#l52.237"></a><span id="l52.237">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_get_values\n&quot;, 0, 0, 0);</span>
<a href="#l52.238"></a><span id="l52.238"> </span>
<a href="#l52.239"></a><span id="l52.239">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l52.240"></a><span id="l52.240">     return (NULL);</span>
<a href="#l52.241"></a><span id="l52.241">   }</span>
<a href="#l52.242"></a><span id="l52.242">   if ((target == NULL) || !NSLDAPI_VALID_LDAPMESSAGE_ENTRY_POINTER(entry)) {</span>
<a href="#l52.243"></a><span id="l52.243">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l52.244"></a><span id="l52.244" class="difflineat">@@ -339,17 +339,17 @@ static void **internal_ldap_get_lang_val</span>
<a href="#l52.245"></a><span id="l52.245">       NSLDAPI_FREE(subtypes);</span>
<a href="#l52.246"></a><span id="l52.246">       subtypes = NULL;</span>
<a href="#l52.247"></a><span id="l52.247">     }</span>
<a href="#l52.248"></a><span id="l52.248">     vals = internal_ldap_get_values(ld, entry, target, lencall);</span>
<a href="#l52.249"></a><span id="l52.249">     if (NULL != type) *type = nsldapi_strdup(target);</span>
<a href="#l52.250"></a><span id="l52.250">     return vals;</span>
<a href="#l52.251"></a><span id="l52.251">   } else {</span>
<a href="#l52.252"></a><span id="l52.252">     /* Get just the base attribute name */</span>
<a href="#l52.253"></a><span id="l52.253" class="difflineminus">-    baseTarget = (char *)NSLDAPI_MALLOC(len + 1);</span>
<a href="#l52.254"></a><span id="l52.254" class="difflineplus">+    baseTarget = (char*)NSLDAPI_MALLOC(len + 1);</span>
<a href="#l52.255"></a><span id="l52.255">     memcpy(baseTarget, target, len);</span>
<a href="#l52.256"></a><span id="l52.256">     baseTarget[len] = 0;</span>
<a href="#l52.257"></a><span id="l52.257">   }</span>
<a href="#l52.258"></a><span id="l52.258"> </span>
<a href="#l52.259"></a><span id="l52.259">   ber = *entry-&gt;lm_ber;</span>
<a href="#l52.260"></a><span id="l52.260"> </span>
<a href="#l52.261"></a><span id="l52.261">   /* Process all attributes in the entry */</span>
<a href="#l52.262"></a><span id="l52.262">   while (1) {</span>
<a href="#l52.263"></a><span id="l52.263" class="difflineat">@@ -362,17 +362,17 @@ static void **internal_ldap_get_lang_val</span>
<a href="#l52.264"></a><span id="l52.264">         break;</span>
<a href="#l52.265"></a><span id="l52.265">       }</span>
<a href="#l52.266"></a><span id="l52.266">     } else {</span>
<a href="#l52.267"></a><span id="l52.267">       if (ber_scanf(&amp;ber, &quot;{a&quot;, &amp;attr) == LBER_ERROR) {</span>
<a href="#l52.268"></a><span id="l52.268">         break;</span>
<a href="#l52.269"></a><span id="l52.269">       }</span>
<a href="#l52.270"></a><span id="l52.270">     }</span>
<a href="#l52.271"></a><span id="l52.271"> </span>
<a href="#l52.272"></a><span id="l52.272" class="difflineminus">-    if (check_base_match((const char *)baseTarget, attr)) {</span>
<a href="#l52.273"></a><span id="l52.273" class="difflineplus">+    if (check_base_match((const char*)baseTarget, attr)) {</span>
<a href="#l52.274"></a><span id="l52.274">       int thisMatch =</span>
<a href="#l52.275"></a><span id="l52.275">           check_lang_match(target, baseTarget, subtypes, nsubtypes, lang, attr);</span>
<a href="#l52.276"></a><span id="l52.276">       if (thisMatch &gt; bestMatch) {</span>
<a href="#l52.277"></a><span id="l52.277">         if (vals) NSLDAPI_FREE(vals);</span>
<a href="#l52.278"></a><span id="l52.278">         foundMatch = 1;</span>
<a href="#l52.279"></a><span id="l52.279">         bestMatch = thisMatch;</span>
<a href="#l52.280"></a><span id="l52.280">         if (NULL != bestType) NSLDAPI_FREE(bestType);</span>
<a href="#l52.281"></a><span id="l52.281">         bestType = attr;</span>
<a href="#l52.282"></a><span id="l52.282" class="difflineat">@@ -405,29 +405,29 @@ static void **internal_ldap_get_lang_val</span>
<a href="#l52.283"></a><span id="l52.283">     rc = LDAP_SUCCESS;</span>
<a href="#l52.284"></a><span id="l52.284">   }</span>
<a href="#l52.285"></a><span id="l52.285"> </span>
<a href="#l52.286"></a><span id="l52.286">   LDAP_SET_LDERRNO(ld, rc, NULL, NULL);</span>
<a href="#l52.287"></a><span id="l52.287"> </span>
<a href="#l52.288"></a><span id="l52.288">   return (vals);</span>
<a href="#l52.289"></a><span id="l52.289"> }</span>
<a href="#l52.290"></a><span id="l52.290"> </span>
<a href="#l52.291"></a><span id="l52.291" class="difflineminus">-char **LDAP_CALL ldap_get_values(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l52.292"></a><span id="l52.292" class="difflineminus">-                                 const char *target) {</span>
<a href="#l52.293"></a><span id="l52.293" class="difflineminus">-  return ((char **)internal_ldap_get_values(ld, entry, target, 0));</span>
<a href="#l52.294"></a><span id="l52.294" class="difflineplus">+char** LDAP_CALL ldap_get_values(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l52.295"></a><span id="l52.295" class="difflineplus">+                                 const char* target) {</span>
<a href="#l52.296"></a><span id="l52.296" class="difflineplus">+  return ((char**)internal_ldap_get_values(ld, entry, target, 0));</span>
<a href="#l52.297"></a><span id="l52.297"> }</span>
<a href="#l52.298"></a><span id="l52.298"> </span>
<a href="#l52.299"></a><span id="l52.299" class="difflineminus">-struct berval **LDAP_CALL ldap_get_values_len(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l52.300"></a><span id="l52.300" class="difflineminus">-                                              const char *target) {</span>
<a href="#l52.301"></a><span id="l52.301" class="difflineminus">-  return ((struct berval **)internal_ldap_get_values(ld, entry, target, 1));</span>
<a href="#l52.302"></a><span id="l52.302" class="difflineplus">+struct berval** LDAP_CALL ldap_get_values_len(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l52.303"></a><span id="l52.303" class="difflineplus">+                                              const char* target) {</span>
<a href="#l52.304"></a><span id="l52.304" class="difflineplus">+  return ((struct berval**)internal_ldap_get_values(ld, entry, target, 1));</span>
<a href="#l52.305"></a><span id="l52.305"> }</span>
<a href="#l52.306"></a><span id="l52.306"> </span>
<a href="#l52.307"></a><span id="l52.307" class="difflineminus">-char **LDAP_CALL ldap_get_lang_values(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l52.308"></a><span id="l52.308" class="difflineminus">-                                      const char *target, char **type) {</span>
<a href="#l52.309"></a><span id="l52.309" class="difflineminus">-  return ((char **)internal_ldap_get_lang_values(ld, entry, target, type, 0));</span>
<a href="#l52.310"></a><span id="l52.310" class="difflineplus">+char** LDAP_CALL ldap_get_lang_values(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l52.311"></a><span id="l52.311" class="difflineplus">+                                      const char* target, char** type) {</span>
<a href="#l52.312"></a><span id="l52.312" class="difflineplus">+  return ((char**)internal_ldap_get_lang_values(ld, entry, target, type, 0));</span>
<a href="#l52.313"></a><span id="l52.313"> }</span>
<a href="#l52.314"></a><span id="l52.314"> </span>
<a href="#l52.315"></a><span id="l52.315" class="difflineminus">-struct berval **LDAP_CALL ldap_get_lang_values_len(LDAP *ld, LDAPMessage *entry,</span>
<a href="#l52.316"></a><span id="l52.316" class="difflineminus">-                                                   const char *target,</span>
<a href="#l52.317"></a><span id="l52.317" class="difflineminus">-                                                   char **type) {</span>
<a href="#l52.318"></a><span id="l52.318" class="difflineminus">-  return ((struct berval **)internal_ldap_get_lang_values(ld, entry, target,</span>
<a href="#l52.319"></a><span id="l52.319" class="difflineminus">-                                                          type, 1));</span>
<a href="#l52.320"></a><span id="l52.320" class="difflineplus">+struct berval** LDAP_CALL ldap_get_lang_values_len(LDAP* ld, LDAPMessage* entry,</span>
<a href="#l52.321"></a><span id="l52.321" class="difflineplus">+                                                   const char* target,</span>
<a href="#l52.322"></a><span id="l52.322" class="difflineplus">+                                                   char** type) {</span>
<a href="#l52.323"></a><span id="l52.323" class="difflineplus">+  return ((struct berval**)internal_ldap_get_lang_values(ld, entry, target,</span>
<a href="#l52.324"></a><span id="l52.324" class="difflineplus">+                                                         type, 1));</span>
<a href="#l52.325"></a><span id="l52.325"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l53.1"></a><span id="l53.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/ldap-int.h</span>
<a href="#l53.2"></a><span id="l53.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/ldap-int.h</span>
<a href="#l53.3"></a><span id="l53.3" class="difflineat">@@ -161,56 +161,56 @@ typedef enum {</span>
<a href="#l53.4"></a><span id="l53.4">  * This structure represents both ldap messages and ldap responses.</span>
<a href="#l53.5"></a><span id="l53.5">  * These are really the same, except in the case of search responses,</span>
<a href="#l53.6"></a><span id="l53.6">  * where a response has multiple messages.</span>
<a href="#l53.7"></a><span id="l53.7">  */</span>
<a href="#l53.8"></a><span id="l53.8"> </span>
<a href="#l53.9"></a><span id="l53.9"> struct ldapmsg {</span>
<a href="#l53.10"></a><span id="l53.10">   int lm_msgid;             /* the message id */</span>
<a href="#l53.11"></a><span id="l53.11">   ber_tag_t lm_msgtype;     /* the message type */</span>
<a href="#l53.12"></a><span id="l53.12" class="difflineminus">-  BerElement *lm_ber;       /* the ber encoded message contents */</span>
<a href="#l53.13"></a><span id="l53.13" class="difflineminus">-  struct ldapmsg *lm_chain; /* for search - next msg in the resp */</span>
<a href="#l53.14"></a><span id="l53.14" class="difflineminus">-  struct ldapmsg *lm_next;  /* next response */</span>
<a href="#l53.15"></a><span id="l53.15" class="difflineplus">+  BerElement* lm_ber;       /* the ber encoded message contents */</span>
<a href="#l53.16"></a><span id="l53.16" class="difflineplus">+  struct ldapmsg* lm_chain; /* for search - next msg in the resp */</span>
<a href="#l53.17"></a><span id="l53.17" class="difflineplus">+  struct ldapmsg* lm_next;  /* next response */</span>
<a href="#l53.18"></a><span id="l53.18">   int lm_fromcache;         /* memcache: origin of message */</span>
<a href="#l53.19"></a><span id="l53.19"> };</span>
<a href="#l53.20"></a><span id="l53.20"> </span>
<a href="#l53.21"></a><span id="l53.21"> /*</span>
<a href="#l53.22"></a><span id="l53.22">  * structure for tracking LDAP server host, ports, DNs, etc.</span>
<a href="#l53.23"></a><span id="l53.23">  */</span>
<a href="#l53.24"></a><span id="l53.24"> typedef struct ldap_server {</span>
<a href="#l53.25"></a><span id="l53.25" class="difflineminus">-  char *lsrv_host;</span>
<a href="#l53.26"></a><span id="l53.26" class="difflineminus">-  char *lsrv_dn; /* if NULL, use default */</span>
<a href="#l53.27"></a><span id="l53.27" class="difflineplus">+  char* lsrv_host;</span>
<a href="#l53.28"></a><span id="l53.28" class="difflineplus">+  char* lsrv_dn; /* if NULL, use default */</span>
<a href="#l53.29"></a><span id="l53.29">   int lsrv_port;</span>
<a href="#l53.30"></a><span id="l53.30">   unsigned long lsrv_options; /* boolean options */</span>
<a href="#l53.31"></a><span id="l53.31"> #define LDAP_SRV_OPT_SECURE 0x01</span>
<a href="#l53.32"></a><span id="l53.32" class="difflineminus">-  struct ldap_server *lsrv_next;</span>
<a href="#l53.33"></a><span id="l53.33" class="difflineplus">+  struct ldap_server* lsrv_next;</span>
<a href="#l53.34"></a><span id="l53.34"> } LDAPServer;</span>
<a href="#l53.35"></a><span id="l53.35"> </span>
<a href="#l53.36"></a><span id="l53.36"> /*</span>
<a href="#l53.37"></a><span id="l53.37">  * structure for representing an LDAP server connection</span>
<a href="#l53.38"></a><span id="l53.38">  */</span>
<a href="#l53.39"></a><span id="l53.39"> typedef struct ldap_conn {</span>
<a href="#l53.40"></a><span id="l53.40" class="difflineminus">-  Sockbuf *lconn_sb;</span>
<a href="#l53.41"></a><span id="l53.41" class="difflineminus">-  BerElement *lconn_ber; /* non-NULL if in midst of msg. */</span>
<a href="#l53.42"></a><span id="l53.42" class="difflineplus">+  Sockbuf* lconn_sb;</span>
<a href="#l53.43"></a><span id="l53.43" class="difflineplus">+  BerElement* lconn_ber; /* non-NULL if in midst of msg. */</span>
<a href="#l53.44"></a><span id="l53.44">   int lconn_version;     /* LDAP protocol version */</span>
<a href="#l53.45"></a><span id="l53.45">   int lconn_refcnt;</span>
<a href="#l53.46"></a><span id="l53.46">   unsigned long lconn_lastused; /* time */</span>
<a href="#l53.47"></a><span id="l53.47">   int lconn_status;</span>
<a href="#l53.48"></a><span id="l53.48"> #define LDAP_CONNST_CONNECTING 2</span>
<a href="#l53.49"></a><span id="l53.49"> #define LDAP_CONNST_CONNECTED 3</span>
<a href="#l53.50"></a><span id="l53.50"> #define LDAP_CONNST_DEAD 4</span>
<a href="#l53.51"></a><span id="l53.51" class="difflineminus">-  LDAPServer *lconn_server;</span>
<a href="#l53.52"></a><span id="l53.52" class="difflineminus">-  char *lconn_binddn;         /* DN of last successful bind */</span>
<a href="#l53.53"></a><span id="l53.53" class="difflineplus">+  LDAPServer* lconn_server;</span>
<a href="#l53.54"></a><span id="l53.54" class="difflineplus">+  char* lconn_binddn;         /* DN of last successful bind */</span>
<a href="#l53.55"></a><span id="l53.55">   int lconn_bound;            /* has a bind been done? */</span>
<a href="#l53.56"></a><span id="l53.56">   int lconn_pending_requests; /* count of unsent req*/</span>
<a href="#l53.57"></a><span id="l53.57" class="difflineminus">-  char *lconn_krbinstance;</span>
<a href="#l53.58"></a><span id="l53.58" class="difflineplus">+  char* lconn_krbinstance;</span>
<a href="#l53.59"></a><span id="l53.59"> #ifdef LDAP_SASLIO_HOOKS</span>
<a href="#l53.60"></a><span id="l53.60" class="difflineminus">-  sasl_conn_t *lconn_sasl_ctx; /* the sasl connection context */</span>
<a href="#l53.61"></a><span id="l53.61" class="difflineplus">+  sasl_conn_t* lconn_sasl_ctx; /* the sasl connection context */</span>
<a href="#l53.62"></a><span id="l53.62"> #endif                         /* LDAP_SASLIO_HOOKS */</span>
<a href="#l53.63"></a><span id="l53.63" class="difflineminus">-  struct ldap_conn *lconn_next;</span>
<a href="#l53.64"></a><span id="l53.64" class="difflineplus">+  struct ldap_conn* lconn_next;</span>
<a href="#l53.65"></a><span id="l53.65"> } LDAPConn;</span>
<a href="#l53.66"></a><span id="l53.66"> </span>
<a href="#l53.67"></a><span id="l53.67"> /*</span>
<a href="#l53.68"></a><span id="l53.68">  * structure used to track outstanding requests</span>
<a href="#l53.69"></a><span id="l53.69">  */</span>
<a href="#l53.70"></a><span id="l53.70"> typedef struct ldapreq {</span>
<a href="#l53.71"></a><span id="l53.71">   int lr_msgid;  /* the message id */</span>
<a href="#l53.72"></a><span id="l53.72">   int lr_status; /* status of request */</span>
<a href="#l53.73"></a><span id="l53.73" class="difflineat">@@ -219,126 +219,126 @@ typedef struct ldapreq {</span>
<a href="#l53.74"></a><span id="l53.74"> #define LDAP_REQST_WRITING 4</span>
<a href="#l53.75"></a><span id="l53.75"> #define LDAP_REQST_CONNDEAD 5 /* associated conn. has failed */</span>
<a href="#l53.76"></a><span id="l53.76">   int lr_outrefcnt;           /* count of outstanding referrals */</span>
<a href="#l53.77"></a><span id="l53.77">   int lr_origid;              /* original request's message id */</span>
<a href="#l53.78"></a><span id="l53.78">   int lr_parentcnt;           /* count of parent requests */</span>
<a href="#l53.79"></a><span id="l53.79">   ber_tag_t lr_res_msgtype;   /* result message type */</span>
<a href="#l53.80"></a><span id="l53.80">   int lr_expect_resp;         /* if non-zero, expect a response */</span>
<a href="#l53.81"></a><span id="l53.81">   int lr_res_errno;           /* result LDAP errno */</span>
<a href="#l53.82"></a><span id="l53.82" class="difflineminus">-  char *lr_res_error;         /* result error string */</span>
<a href="#l53.83"></a><span id="l53.83" class="difflineminus">-  char *lr_res_matched;       /* result matched DN string */</span>
<a href="#l53.84"></a><span id="l53.84" class="difflineminus">-  BerElement *lr_ber;         /* ber encoded request contents */</span>
<a href="#l53.85"></a><span id="l53.85" class="difflineminus">-  LDAPConn *lr_conn;          /* connection used to send request */</span>
<a href="#l53.86"></a><span id="l53.86" class="difflineminus">-  char *lr_binddn;            /* request is a bind for this DN */</span>
<a href="#l53.87"></a><span id="l53.87" class="difflineminus">-  struct ldapreq *lr_parent;  /* request that spawned this referral */</span>
<a href="#l53.88"></a><span id="l53.88" class="difflineminus">-  struct ldapreq *lr_child;   /* list of requests we spawned */</span>
<a href="#l53.89"></a><span id="l53.89" class="difflineminus">-  struct ldapreq *lr_sibling; /* next referral spawned */</span>
<a href="#l53.90"></a><span id="l53.90" class="difflineminus">-  struct ldapreq *lr_prev;    /* ld-&gt;ld_requests previous request */</span>
<a href="#l53.91"></a><span id="l53.91" class="difflineminus">-  struct ldapreq *lr_next;    /* ld-&gt;ld_requests next request */</span>
<a href="#l53.92"></a><span id="l53.92" class="difflineminus">-  LDAPControl **lr_res_ctrls; /* result controls */</span>
<a href="#l53.93"></a><span id="l53.93" class="difflineplus">+  char* lr_res_error;         /* result error string */</span>
<a href="#l53.94"></a><span id="l53.94" class="difflineplus">+  char* lr_res_matched;       /* result matched DN string */</span>
<a href="#l53.95"></a><span id="l53.95" class="difflineplus">+  BerElement* lr_ber;         /* ber encoded request contents */</span>
<a href="#l53.96"></a><span id="l53.96" class="difflineplus">+  LDAPConn* lr_conn;          /* connection used to send request */</span>
<a href="#l53.97"></a><span id="l53.97" class="difflineplus">+  char* lr_binddn;            /* request is a bind for this DN */</span>
<a href="#l53.98"></a><span id="l53.98" class="difflineplus">+  struct ldapreq* lr_parent;  /* request that spawned this referral */</span>
<a href="#l53.99"></a><span id="l53.99" class="difflineplus">+  struct ldapreq* lr_child;   /* list of requests we spawned */</span>
<a href="#l53.100"></a><span id="l53.100" class="difflineplus">+  struct ldapreq* lr_sibling; /* next referral spawned */</span>
<a href="#l53.101"></a><span id="l53.101" class="difflineplus">+  struct ldapreq* lr_prev;    /* ld-&gt;ld_requests previous request */</span>
<a href="#l53.102"></a><span id="l53.102" class="difflineplus">+  struct ldapreq* lr_next;    /* ld-&gt;ld_requests next request */</span>
<a href="#l53.103"></a><span id="l53.103" class="difflineplus">+  LDAPControl** lr_res_ctrls; /* result controls */</span>
<a href="#l53.104"></a><span id="l53.104"> } LDAPRequest;</span>
<a href="#l53.105"></a><span id="l53.105"> </span>
<a href="#l53.106"></a><span id="l53.106"> typedef struct ldappend {</span>
<a href="#l53.107"></a><span id="l53.107" class="difflineminus">-  void *lp_sema;            /* semaphore to post */</span>
<a href="#l53.108"></a><span id="l53.108" class="difflineplus">+  void* lp_sema;            /* semaphore to post */</span>
<a href="#l53.109"></a><span id="l53.109">   int lp_msgid;             /* message id */</span>
<a href="#l53.110"></a><span id="l53.110" class="difflineminus">-  LDAPMessage *lp_result;   /* result storage */</span>
<a href="#l53.111"></a><span id="l53.111" class="difflineminus">-  struct ldappend *lp_prev; /* previous pending */</span>
<a href="#l53.112"></a><span id="l53.112" class="difflineminus">-  struct ldappend *lp_next; /* next pending */</span>
<a href="#l53.113"></a><span id="l53.113" class="difflineplus">+  LDAPMessage* lp_result;   /* result storage */</span>
<a href="#l53.114"></a><span id="l53.114" class="difflineplus">+  struct ldappend* lp_prev; /* previous pending */</span>
<a href="#l53.115"></a><span id="l53.115" class="difflineplus">+  struct ldappend* lp_next; /* next pending */</span>
<a href="#l53.116"></a><span id="l53.116"> } LDAPPend;</span>
<a href="#l53.117"></a><span id="l53.117"> </span>
<a href="#l53.118"></a><span id="l53.118"> /*</span>
<a href="#l53.119"></a><span id="l53.119">  * forward declaration for I/O status structure (defined in os-ip.c)</span>
<a href="#l53.120"></a><span id="l53.120">  */</span>
<a href="#l53.121"></a><span id="l53.121"> typedef struct nsldapi_iostatus_info NSLDAPIIOStatus;</span>
<a href="#l53.122"></a><span id="l53.122"> </span>
<a href="#l53.123"></a><span id="l53.123"> /*</span>
<a href="#l53.124"></a><span id="l53.124">  * old extended IO structure (before writev callback was added)</span>
<a href="#l53.125"></a><span id="l53.125">  */</span>
<a href="#l53.126"></a><span id="l53.126"> struct ldap_x_ext_io_fns_rev0 {</span>
<a href="#l53.127"></a><span id="l53.127">   int lextiof_size;</span>
<a href="#l53.128"></a><span id="l53.128" class="difflineminus">-  LDAP_X_EXTIOF_CONNECT_CALLBACK *lextiof_connect;</span>
<a href="#l53.129"></a><span id="l53.129" class="difflineminus">-  LDAP_X_EXTIOF_CLOSE_CALLBACK *lextiof_close;</span>
<a href="#l53.130"></a><span id="l53.130" class="difflineminus">-  LDAP_X_EXTIOF_READ_CALLBACK *lextiof_read;</span>
<a href="#l53.131"></a><span id="l53.131" class="difflineminus">-  LDAP_X_EXTIOF_WRITE_CALLBACK *lextiof_write;</span>
<a href="#l53.132"></a><span id="l53.132" class="difflineminus">-  LDAP_X_EXTIOF_POLL_CALLBACK *lextiof_poll;</span>
<a href="#l53.133"></a><span id="l53.133" class="difflineminus">-  LDAP_X_EXTIOF_NEWHANDLE_CALLBACK *lextiof_newhandle;</span>
<a href="#l53.134"></a><span id="l53.134" class="difflineminus">-  LDAP_X_EXTIOF_DISPOSEHANDLE_CALLBACK *lextiof_disposehandle;</span>
<a href="#l53.135"></a><span id="l53.135" class="difflineminus">-  void *lextiof_session_arg;</span>
<a href="#l53.136"></a><span id="l53.136" class="difflineplus">+  LDAP_X_EXTIOF_CONNECT_CALLBACK* lextiof_connect;</span>
<a href="#l53.137"></a><span id="l53.137" class="difflineplus">+  LDAP_X_EXTIOF_CLOSE_CALLBACK* lextiof_close;</span>
<a href="#l53.138"></a><span id="l53.138" class="difflineplus">+  LDAP_X_EXTIOF_READ_CALLBACK* lextiof_read;</span>
<a href="#l53.139"></a><span id="l53.139" class="difflineplus">+  LDAP_X_EXTIOF_WRITE_CALLBACK* lextiof_write;</span>
<a href="#l53.140"></a><span id="l53.140" class="difflineplus">+  LDAP_X_EXTIOF_POLL_CALLBACK* lextiof_poll;</span>
<a href="#l53.141"></a><span id="l53.141" class="difflineplus">+  LDAP_X_EXTIOF_NEWHANDLE_CALLBACK* lextiof_newhandle;</span>
<a href="#l53.142"></a><span id="l53.142" class="difflineplus">+  LDAP_X_EXTIOF_DISPOSEHANDLE_CALLBACK* lextiof_disposehandle;</span>
<a href="#l53.143"></a><span id="l53.143" class="difflineplus">+  void* lextiof_session_arg;</span>
<a href="#l53.144"></a><span id="l53.144"> };</span>
<a href="#l53.145"></a><span id="l53.145"> #define LDAP_X_EXTIO_FNS_SIZE_REV0 sizeof(struct ldap_x_ext_io_fns_rev0)</span>
<a href="#l53.146"></a><span id="l53.146"> </span>
<a href="#l53.147"></a><span id="l53.147"> /*</span>
<a href="#l53.148"></a><span id="l53.148">  * Structure representing an ldap connection.</span>
<a href="#l53.149"></a><span id="l53.149">  *</span>
<a href="#l53.150"></a><span id="l53.150">  * This is an opaque struct; the fields are not visible to</span>
<a href="#l53.151"></a><span id="l53.151">  * applications that use the LDAP API.</span>
<a href="#l53.152"></a><span id="l53.152">  */</span>
<a href="#l53.153"></a><span id="l53.153"> struct ldap {</span>
<a href="#l53.154"></a><span id="l53.154" class="difflineminus">-  struct sockbuf *ld_sbp; /* pointer to socket desc. &amp; buffer */</span>
<a href="#l53.155"></a><span id="l53.155" class="difflineminus">-  char *ld_host;</span>
<a href="#l53.156"></a><span id="l53.156" class="difflineplus">+  struct sockbuf* ld_sbp; /* pointer to socket desc. &amp; buffer */</span>
<a href="#l53.157"></a><span id="l53.157" class="difflineplus">+  char* ld_host;</span>
<a href="#l53.158"></a><span id="l53.158">   int ld_version; /* LDAP protocol version */</span>
<a href="#l53.159"></a><span id="l53.159">   char ld_lberoptions;</span>
<a href="#l53.160"></a><span id="l53.160">   int ld_deref;</span>
<a href="#l53.161"></a><span id="l53.161"> </span>
<a href="#l53.162"></a><span id="l53.162">   int ld_timelimit;</span>
<a href="#l53.163"></a><span id="l53.163">   int ld_sizelimit;</span>
<a href="#l53.164"></a><span id="l53.164"> </span>
<a href="#l53.165"></a><span id="l53.165" class="difflineminus">-  struct ldap_filt_desc *ld_filtd; /* from getfilter for ufn searches */</span>
<a href="#l53.166"></a><span id="l53.166" class="difflineminus">-  char *ld_ufnprefix;              /* for incomplete ufn's */</span>
<a href="#l53.167"></a><span id="l53.167" class="difflineplus">+  struct ldap_filt_desc* ld_filtd; /* from getfilter for ufn searches */</span>
<a href="#l53.168"></a><span id="l53.168" class="difflineplus">+  char* ld_ufnprefix;              /* for incomplete ufn's */</span>
<a href="#l53.169"></a><span id="l53.169"> </span>
<a href="#l53.170"></a><span id="l53.170">   int ld_errno;</span>
<a href="#l53.171"></a><span id="l53.171" class="difflineminus">-  char *ld_error;</span>
<a href="#l53.172"></a><span id="l53.172" class="difflineminus">-  char *ld_matched;</span>
<a href="#l53.173"></a><span id="l53.173" class="difflineplus">+  char* ld_error;</span>
<a href="#l53.174"></a><span id="l53.174" class="difflineplus">+  char* ld_matched;</span>
<a href="#l53.175"></a><span id="l53.175">   int ld_msgid;</span>
<a href="#l53.176"></a><span id="l53.176"> </span>
<a href="#l53.177"></a><span id="l53.177">   /* Note: the ld_requests list is ordered old to new */</span>
<a href="#l53.178"></a><span id="l53.178" class="difflineminus">-  LDAPRequest *ld_requests;  /* list of outstanding requests */</span>
<a href="#l53.179"></a><span id="l53.179" class="difflineminus">-  LDAPMessage *ld_responses; /* list of outstanding responses */</span>
<a href="#l53.180"></a><span id="l53.180" class="difflineminus">-  int *ld_abandoned;         /* array of abandoned requests */</span>
<a href="#l53.181"></a><span id="l53.181" class="difflineminus">-  char *ld_cldapdn;          /* DN used in connectionless search */</span>
<a href="#l53.182"></a><span id="l53.182" class="difflineplus">+  LDAPRequest* ld_requests;  /* list of outstanding requests */</span>
<a href="#l53.183"></a><span id="l53.183" class="difflineplus">+  LDAPMessage* ld_responses; /* list of outstanding responses */</span>
<a href="#l53.184"></a><span id="l53.184" class="difflineplus">+  int* ld_abandoned;         /* array of abandoned requests */</span>
<a href="#l53.185"></a><span id="l53.185" class="difflineplus">+  char* ld_cldapdn;          /* DN used in connectionless search */</span>
<a href="#l53.186"></a><span id="l53.186"> </span>
<a href="#l53.187"></a><span id="l53.187">   int ld_cldaptries;        /* connectionless search retry count */</span>
<a href="#l53.188"></a><span id="l53.188">   int ld_cldaptimeout;      /* time between retries */</span>
<a href="#l53.189"></a><span id="l53.189">   int ld_refhoplimit;       /* limit on referral nesting */</span>
<a href="#l53.190"></a><span id="l53.190">   unsigned long ld_options; /* boolean options */</span>
<a href="#l53.191"></a><span id="l53.191"> </span>
<a href="#l53.192"></a><span id="l53.192"> #define LDAP_BITOPT_REFERRALS 0x80000000</span>
<a href="#l53.193"></a><span id="l53.193"> #define LDAP_BITOPT_SSL 0x40000000</span>
<a href="#l53.194"></a><span id="l53.194"> #define LDAP_BITOPT_DNS 0x20000000</span>
<a href="#l53.195"></a><span id="l53.195"> #define LDAP_BITOPT_RESTART 0x10000000</span>
<a href="#l53.196"></a><span id="l53.196"> #define LDAP_BITOPT_RECONNECT 0x08000000</span>
<a href="#l53.197"></a><span id="l53.197"> #define LDAP_BITOPT_ASYNC 0x04000000</span>
<a href="#l53.198"></a><span id="l53.198"> #define LDAP_BITOPT_NOREBIND 0x02000000</span>
<a href="#l53.199"></a><span id="l53.199"> </span>
<a href="#l53.200"></a><span id="l53.200" class="difflineminus">-  char *ld_defhost; /* full name of default server */</span>
<a href="#l53.201"></a><span id="l53.201" class="difflineplus">+  char* ld_defhost; /* full name of default server */</span>
<a href="#l53.202"></a><span id="l53.202">   int ld_defport;   /* port of default server */</span>
<a href="#l53.203"></a><span id="l53.203">   BERTranslateProc ld_lber_encode_translate_proc;</span>
<a href="#l53.204"></a><span id="l53.204">   BERTranslateProc ld_lber_decode_translate_proc;</span>
<a href="#l53.205"></a><span id="l53.205" class="difflineminus">-  LDAPConn *ld_defconn;         /* default connection */</span>
<a href="#l53.206"></a><span id="l53.206" class="difflineminus">-  LDAPConn *ld_conns;           /* list of all server connections */</span>
<a href="#l53.207"></a><span id="l53.207" class="difflineminus">-  NSLDAPIIOStatus *ld_iostatus; /* status info. about network sockets */</span>
<a href="#l53.208"></a><span id="l53.208" class="difflineminus">-  LDAP_REBINDPROC_CALLBACK *ld_rebind_fn;</span>
<a href="#l53.209"></a><span id="l53.209" class="difflineminus">-  void *ld_rebind_arg;</span>
<a href="#l53.210"></a><span id="l53.210" class="difflineplus">+  LDAPConn* ld_defconn;         /* default connection */</span>
<a href="#l53.211"></a><span id="l53.211" class="difflineplus">+  LDAPConn* ld_conns;           /* list of all server connections */</span>
<a href="#l53.212"></a><span id="l53.212" class="difflineplus">+  NSLDAPIIOStatus* ld_iostatus; /* status info. about network sockets */</span>
<a href="#l53.213"></a><span id="l53.213" class="difflineplus">+  LDAP_REBINDPROC_CALLBACK* ld_rebind_fn;</span>
<a href="#l53.214"></a><span id="l53.214" class="difflineplus">+  void* ld_rebind_arg;</span>
<a href="#l53.215"></a><span id="l53.215"> </span>
<a href="#l53.216"></a><span id="l53.216">   /* function pointers, etc. for extended I/O */</span>
<a href="#l53.217"></a><span id="l53.217">   struct ldap_x_ext_io_fns ld_ext_io_fns;</span>
<a href="#l53.218"></a><span id="l53.218"> #define ld_extio_size ld_ext_io_fns.lextiof_size</span>
<a href="#l53.219"></a><span id="l53.219"> #define ld_extclose_fn ld_ext_io_fns.lextiof_close</span>
<a href="#l53.220"></a><span id="l53.220"> #define ld_extconnect_fn ld_ext_io_fns.lextiof_connect</span>
<a href="#l53.221"></a><span id="l53.221"> #define ld_extread_fn ld_ext_io_fns.lextiof_read</span>
<a href="#l53.222"></a><span id="l53.222"> #define ld_extwrite_fn ld_ext_io_fns.lextiof_write</span>
<a href="#l53.223"></a><span id="l53.223"> #define ld_extwritev_fn ld_ext_io_fns.lextiof_writev</span>
<a href="#l53.224"></a><span id="l53.224"> #define ld_extpoll_fn ld_ext_io_fns.lextiof_poll</span>
<a href="#l53.225"></a><span id="l53.225"> #define ld_extnewhandle_fn ld_ext_io_fns.lextiof_newhandle</span>
<a href="#l53.226"></a><span id="l53.226"> #define ld_extdisposehandle_fn ld_ext_io_fns.lextiof_disposehandle</span>
<a href="#l53.227"></a><span id="l53.227"> #define ld_ext_session_arg ld_ext_io_fns.lextiof_session_arg</span>
<a href="#l53.228"></a><span id="l53.228"> </span>
<a href="#l53.229"></a><span id="l53.229">   /* allocated pointer for older I/O functions */</span>
<a href="#l53.230"></a><span id="l53.230" class="difflineminus">-  struct ldap_io_fns *ld_io_fns_ptr;</span>
<a href="#l53.231"></a><span id="l53.231" class="difflineplus">+  struct ldap_io_fns* ld_io_fns_ptr;</span>
<a href="#l53.232"></a><span id="l53.232"> #define NSLDAPI_USING_CLASSIC_IO_FUNCTIONS(ld) ((ld)-&gt;ld_io_fns_ptr != NULL)</span>
<a href="#l53.233"></a><span id="l53.233"> </span>
<a href="#l53.234"></a><span id="l53.234">   /* function pointers, etc. for DNS */</span>
<a href="#l53.235"></a><span id="l53.235">   struct ldap_dns_fns ld_dnsfn;</span>
<a href="#l53.236"></a><span id="l53.236"> #define ld_dns_extradata ld_dnsfn.lddnsfn_extradata</span>
<a href="#l53.237"></a><span id="l53.237"> #define ld_dns_bufsize ld_dnsfn.lddnsfn_bufsize</span>
<a href="#l53.238"></a><span id="l53.238"> #define ld_dns_gethostbyname_fn ld_dnsfn.lddnsfn_gethostbyname</span>
<a href="#l53.239"></a><span id="l53.239"> #define ld_dns_gethostbyaddr_fn ld_dnsfn.lddnsfn_gethostbyaddr</span>
<a href="#l53.240"></a><span id="l53.240" class="difflineat">@@ -350,17 +350,17 @@ struct ldap {</span>
<a href="#l53.241"></a><span id="l53.241"> #define ld_mutex_free_fn ld_thread.ltf_mutex_free</span>
<a href="#l53.242"></a><span id="l53.242"> #define ld_mutex_lock_fn ld_thread.ltf_mutex_lock</span>
<a href="#l53.243"></a><span id="l53.243"> #define ld_mutex_unlock_fn ld_thread.ltf_mutex_unlock</span>
<a href="#l53.244"></a><span id="l53.244"> #define ld_get_errno_fn ld_thread.ltf_get_errno</span>
<a href="#l53.245"></a><span id="l53.245"> #define ld_set_errno_fn ld_thread.ltf_set_errno</span>
<a href="#l53.246"></a><span id="l53.246"> #define ld_get_lderrno_fn ld_thread.ltf_get_lderrno</span>
<a href="#l53.247"></a><span id="l53.247"> #define ld_set_lderrno_fn ld_thread.ltf_set_lderrno</span>
<a href="#l53.248"></a><span id="l53.248"> #define ld_lderrno_arg ld_thread.ltf_lderrno_arg</span>
<a href="#l53.249"></a><span id="l53.249" class="difflineminus">-  void **ld_mutex;</span>
<a href="#l53.250"></a><span id="l53.250" class="difflineplus">+  void** ld_mutex;</span>
<a href="#l53.251"></a><span id="l53.251"> </span>
<a href="#l53.252"></a><span id="l53.252">   /* function pointers, etc. for caching */</span>
<a href="#l53.253"></a><span id="l53.253">   int ld_cache_on;</span>
<a href="#l53.254"></a><span id="l53.254">   int ld_cache_strategy;</span>
<a href="#l53.255"></a><span id="l53.255">   struct ldap_cache_fns ld_cache;</span>
<a href="#l53.256"></a><span id="l53.256"> #define ld_cache_config ld_cache.lcf_config</span>
<a href="#l53.257"></a><span id="l53.257"> #define ld_cache_bind ld_cache.lcf_bind</span>
<a href="#l53.258"></a><span id="l53.258"> #define ld_cache_unbind ld_cache.lcf_unbind</span>
<a href="#l53.259"></a><span id="l53.259" class="difflineat">@@ -374,27 +374,27 @@ struct ldap {</span>
<a href="#l53.260"></a><span id="l53.260"> #define ld_cache_modify ld_cache.lcf_modify</span>
<a href="#l53.261"></a><span id="l53.261"> #define ld_cache_modrdn ld_cache.lcf_modrdn</span>
<a href="#l53.262"></a><span id="l53.262"> #define ld_cache_abandon ld_cache.lcf_abandon</span>
<a href="#l53.263"></a><span id="l53.263"> #define ld_cache_result ld_cache.lcf_result</span>
<a href="#l53.264"></a><span id="l53.264"> #define ld_cache_flush ld_cache.lcf_flush</span>
<a href="#l53.265"></a><span id="l53.265"> #define ld_cache_arg ld_cache.lcf_arg</span>
<a href="#l53.266"></a><span id="l53.266"> </span>
<a href="#l53.267"></a><span id="l53.267">   /* ldapv3 controls */</span>
<a href="#l53.268"></a><span id="l53.268" class="difflineminus">-  LDAPControl **ld_servercontrols;</span>
<a href="#l53.269"></a><span id="l53.269" class="difflineminus">-  LDAPControl **ld_clientcontrols;</span>
<a href="#l53.270"></a><span id="l53.270" class="difflineplus">+  LDAPControl** ld_servercontrols;</span>
<a href="#l53.271"></a><span id="l53.271" class="difflineplus">+  LDAPControl** ld_clientcontrols;</span>
<a href="#l53.272"></a><span id="l53.272"> </span>
<a href="#l53.273"></a><span id="l53.273">   /* Preferred language */</span>
<a href="#l53.274"></a><span id="l53.274" class="difflineminus">-  char *ld_preferred_language;</span>
<a href="#l53.275"></a><span id="l53.275" class="difflineplus">+  char* ld_preferred_language;</span>
<a href="#l53.276"></a><span id="l53.276"> </span>
<a href="#l53.277"></a><span id="l53.277">   /* MemCache */</span>
<a href="#l53.278"></a><span id="l53.278" class="difflineminus">-  LDAPMemCache *ld_memcache;</span>
<a href="#l53.279"></a><span id="l53.279" class="difflineplus">+  LDAPMemCache* ld_memcache;</span>
<a href="#l53.280"></a><span id="l53.280"> </span>
<a href="#l53.281"></a><span id="l53.281">   /* Pending results */</span>
<a href="#l53.282"></a><span id="l53.282" class="difflineminus">-  LDAPPend *ld_pend; /* list of pending results */</span>
<a href="#l53.283"></a><span id="l53.283" class="difflineplus">+  LDAPPend* ld_pend; /* list of pending results */</span>
<a href="#l53.284"></a><span id="l53.284"> </span>
<a href="#l53.285"></a><span id="l53.285">   /* extra thread function pointers */</span>
<a href="#l53.286"></a><span id="l53.286">   struct ldap_extra_thread_fns ld_thread2;</span>
<a href="#l53.287"></a><span id="l53.287"> </span>
<a href="#l53.288"></a><span id="l53.288">   /*</span>
<a href="#l53.289"></a><span id="l53.289">    * With the 4.0 and later versions of the LDAP SDK, the extra thread</span>
<a href="#l53.290"></a><span id="l53.290">    * functions except for the ld_threadid_fn have been disabled.</span>
<a href="#l53.291"></a><span id="l53.291">    * Look at the release notes for the full explanation.</span>
<a href="#l53.292"></a><span id="l53.292" class="difflineat">@@ -402,28 +402,28 @@ struct ldap {</span>
<a href="#l53.293"></a><span id="l53.293"> #define ld_mutex_trylock_fn ld_thread2.ltf_mutex_trylock</span>
<a href="#l53.294"></a><span id="l53.294"> #define ld_sema_alloc_fn ld_thread2.ltf_sema_alloc</span>
<a href="#l53.295"></a><span id="l53.295"> #define ld_sema_free_fn ld_thread2.ltf_sema_free</span>
<a href="#l53.296"></a><span id="l53.296"> #define ld_sema_wait_fn ld_thread2.ltf_sema_wait</span>
<a href="#l53.297"></a><span id="l53.297"> #define ld_sema_post_fn ld_thread2.ltf_sema_post</span>
<a href="#l53.298"></a><span id="l53.298"> #define ld_threadid_fn ld_thread2.ltf_threadid_fn</span>
<a href="#l53.299"></a><span id="l53.299"> </span>
<a href="#l53.300"></a><span id="l53.300">   /* extra data for mutex handling in referrals */</span>
<a href="#l53.301"></a><span id="l53.301" class="difflineminus">-  void *ld_mutex_threadid[LDAP_MAX_LOCK];</span>
<a href="#l53.302"></a><span id="l53.302" class="difflineplus">+  void* ld_mutex_threadid[LDAP_MAX_LOCK];</span>
<a href="#l53.303"></a><span id="l53.303">   unsigned long ld_mutex_refcnt[LDAP_MAX_LOCK];</span>
<a href="#l53.304"></a><span id="l53.304"> </span>
<a href="#l53.305"></a><span id="l53.305">   /* connect timeout value (milliseconds) */</span>
<a href="#l53.306"></a><span id="l53.306">   int ld_connect_timeout;</span>
<a href="#l53.307"></a><span id="l53.307"> </span>
<a href="#l53.308"></a><span id="l53.308"> #ifdef LDAP_SASLIO_HOOKS</span>
<a href="#l53.309"></a><span id="l53.309">   /* SASL default option settings */</span>
<a href="#l53.310"></a><span id="l53.310" class="difflineminus">-  char *ld_def_sasl_mech;</span>
<a href="#l53.311"></a><span id="l53.311" class="difflineminus">-  char *ld_def_sasl_realm;</span>
<a href="#l53.312"></a><span id="l53.312" class="difflineminus">-  char *ld_def_sasl_authcid;</span>
<a href="#l53.313"></a><span id="l53.313" class="difflineminus">-  char *ld_def_sasl_authzid;</span>
<a href="#l53.314"></a><span id="l53.314" class="difflineplus">+  char* ld_def_sasl_mech;</span>
<a href="#l53.315"></a><span id="l53.315" class="difflineplus">+  char* ld_def_sasl_realm;</span>
<a href="#l53.316"></a><span id="l53.316" class="difflineplus">+  char* ld_def_sasl_authcid;</span>
<a href="#l53.317"></a><span id="l53.317" class="difflineplus">+  char* ld_def_sasl_authzid;</span>
<a href="#l53.318"></a><span id="l53.318">   /* SASL Security properties */</span>
<a href="#l53.319"></a><span id="l53.319">   struct sasl_security_properties ld_sasl_secprops;</span>
<a href="#l53.320"></a><span id="l53.320"> #endif</span>
<a href="#l53.321"></a><span id="l53.321"> };</span>
<a href="#l53.322"></a><span id="l53.322"> </span>
<a href="#l53.323"></a><span id="l53.323"> /* allocate/free mutex */</span>
<a href="#l53.324"></a><span id="l53.324"> #define LDAP_MUTEX_ALLOC(ld) \</span>
<a href="#l53.325"></a><span id="l53.325">   (((ld)-&gt;ld_mutex_alloc_fn != NULL) ? (ld)-&gt;ld_mutex_alloc_fn() : NULL)</span>
<a href="#l53.326"></a><span id="l53.326" class="difflineat">@@ -462,17 +462,17 @@ struct ldap {</span>
<a href="#l53.327"></a><span id="l53.327">   }</span>
<a href="#l53.328"></a><span id="l53.328"> </span>
<a href="#l53.329"></a><span id="l53.329"> #define LDAP_MUTEX_UNLOCK(ld, lock)                                  \</span>
<a href="#l53.330"></a><span id="l53.330">   if ((ld)-&gt;ld_mutex_lock_fn != NULL &amp;&amp; ld-&gt;ld_mutex != NULL) {      \</span>
<a href="#l53.331"></a><span id="l53.331">     if ((ld)-&gt;ld_threadid_fn != NULL) {                              \</span>
<a href="#l53.332"></a><span id="l53.332">       if ((ld)-&gt;ld_mutex_threadid[lock] == (ld)-&gt;ld_threadid_fn()) { \</span>
<a href="#l53.333"></a><span id="l53.333">         (ld)-&gt;ld_mutex_refcnt[lock]--;                               \</span>
<a href="#l53.334"></a><span id="l53.334">         if ((ld)-&gt;ld_mutex_refcnt[lock] &lt;= 0) {                      \</span>
<a href="#l53.335"></a><span id="l53.335" class="difflineminus">-          (ld)-&gt;ld_mutex_threadid[lock] = (void *)-1;                \</span>
<a href="#l53.336"></a><span id="l53.336" class="difflineplus">+          (ld)-&gt;ld_mutex_threadid[lock] = (void*)-1;                 \</span>
<a href="#l53.337"></a><span id="l53.337">           (ld)-&gt;ld_mutex_refcnt[lock] = 0;                           \</span>
<a href="#l53.338"></a><span id="l53.338">           (ld)-&gt;ld_mutex_unlock_fn(ld-&gt;ld_mutex[lock]);              \</span>
<a href="#l53.339"></a><span id="l53.339">         }                                                            \</span>
<a href="#l53.340"></a><span id="l53.340">       }                                                              \</span>
<a href="#l53.341"></a><span id="l53.341">     } else {                                                         \</span>
<a href="#l53.342"></a><span id="l53.342">       ld-&gt;ld_mutex_unlock_fn(ld-&gt;ld_mutex[lock]);                    \</span>
<a href="#l53.343"></a><span id="l53.343">     }                                                                \</span>
<a href="#l53.344"></a><span id="l53.344">   }</span>
<a href="#l53.345"></a><span id="l53.345" class="difflineat">@@ -588,33 +588,33 @@ struct ldap {</span>
<a href="#l53.346"></a><span id="l53.346">                             : (ld)-&gt;ld_defconn-&gt;lconn_version)</span>
<a href="#l53.347"></a><span id="l53.347"> </span>
<a href="#l53.348"></a><span id="l53.348"> /*</span>
<a href="#l53.349"></a><span id="l53.349">  * Structures used for handling client filter lists.</span>
<a href="#l53.350"></a><span id="l53.350">  */</span>
<a href="#l53.351"></a><span id="l53.351"> #define LDAP_FILT_MAXSIZ 1024</span>
<a href="#l53.352"></a><span id="l53.352"> </span>
<a href="#l53.353"></a><span id="l53.353"> struct ldap_filt_list {</span>
<a href="#l53.354"></a><span id="l53.354" class="difflineminus">-  char *lfl_tag;</span>
<a href="#l53.355"></a><span id="l53.355" class="difflineminus">-  char *lfl_pattern;</span>
<a href="#l53.356"></a><span id="l53.356" class="difflineminus">-  char *lfl_delims;</span>
<a href="#l53.357"></a><span id="l53.357" class="difflineminus">-  struct ldap_filt_info *lfl_ilist;</span>
<a href="#l53.358"></a><span id="l53.358" class="difflineminus">-  struct ldap_filt_list *lfl_next;</span>
<a href="#l53.359"></a><span id="l53.359" class="difflineplus">+  char* lfl_tag;</span>
<a href="#l53.360"></a><span id="l53.360" class="difflineplus">+  char* lfl_pattern;</span>
<a href="#l53.361"></a><span id="l53.361" class="difflineplus">+  char* lfl_delims;</span>
<a href="#l53.362"></a><span id="l53.362" class="difflineplus">+  struct ldap_filt_info* lfl_ilist;</span>
<a href="#l53.363"></a><span id="l53.363" class="difflineplus">+  struct ldap_filt_list* lfl_next;</span>
<a href="#l53.364"></a><span id="l53.364"> };</span>
<a href="#l53.365"></a><span id="l53.365"> </span>
<a href="#l53.366"></a><span id="l53.366"> struct ldap_filt_desc {</span>
<a href="#l53.367"></a><span id="l53.367" class="difflineminus">-  LDAPFiltList *lfd_filtlist;</span>
<a href="#l53.368"></a><span id="l53.368" class="difflineminus">-  LDAPFiltInfo *lfd_curfip;</span>
<a href="#l53.369"></a><span id="l53.369" class="difflineplus">+  LDAPFiltList* lfd_filtlist;</span>
<a href="#l53.370"></a><span id="l53.370" class="difflineplus">+  LDAPFiltInfo* lfd_curfip;</span>
<a href="#l53.371"></a><span id="l53.371">   LDAPFiltInfo lfd_retfi;</span>
<a href="#l53.372"></a><span id="l53.372">   char lfd_filter[LDAP_FILT_MAXSIZ];</span>
<a href="#l53.373"></a><span id="l53.373" class="difflineminus">-  char *lfd_curval;</span>
<a href="#l53.374"></a><span id="l53.374" class="difflineminus">-  char *lfd_curvalcopy;</span>
<a href="#l53.375"></a><span id="l53.375" class="difflineminus">-  char **lfd_curvalwords;</span>
<a href="#l53.376"></a><span id="l53.376" class="difflineminus">-  char *lfd_filtprefix;</span>
<a href="#l53.377"></a><span id="l53.377" class="difflineminus">-  char *lfd_filtsuffix;</span>
<a href="#l53.378"></a><span id="l53.378" class="difflineplus">+  char* lfd_curval;</span>
<a href="#l53.379"></a><span id="l53.379" class="difflineplus">+  char* lfd_curvalcopy;</span>
<a href="#l53.380"></a><span id="l53.380" class="difflineplus">+  char** lfd_curvalwords;</span>
<a href="#l53.381"></a><span id="l53.381" class="difflineplus">+  char* lfd_filtprefix;</span>
<a href="#l53.382"></a><span id="l53.382" class="difflineplus">+  char* lfd_filtsuffix;</span>
<a href="#l53.383"></a><span id="l53.383"> };</span>
<a href="#l53.384"></a><span id="l53.384"> </span>
<a href="#l53.385"></a><span id="l53.385"> /*</span>
<a href="#l53.386"></a><span id="l53.386">  * &quot;internal&quot; globals used to track defaults and memory allocation callbacks:</span>
<a href="#l53.387"></a><span id="l53.387">  *    (the actual definitions are in open.c)</span>
<a href="#l53.388"></a><span id="l53.388">  */</span>
<a href="#l53.389"></a><span id="l53.389"> extern struct ldap nsldapi_ld_defaults;</span>
<a href="#l53.390"></a><span id="l53.390"> extern struct ldap_memalloc_fns nsldapi_memalloc_fns;</span>
<a href="#l53.391"></a><span id="l53.391" class="difflineat">@@ -659,216 +659,216 @@ extern int nsldapi_initialized;</span>
<a href="#l53.392"></a><span id="l53.392"> #define NSLDAPI_IS_SEARCH_RESULT(code) ((code) == LDAP_RES_SEARCH_RESULT)</span>
<a href="#l53.393"></a><span id="l53.393"> </span>
<a href="#l53.394"></a><span id="l53.394"> #define NSLDAPI_SEARCH_RELATED_RESULT(code) \</span>
<a href="#l53.395"></a><span id="l53.395">   (NSLDAPI_IS_SEARCH_RESULT(code) || NSLDAPI_IS_SEARCH_ENTRY(code))</span>
<a href="#l53.396"></a><span id="l53.396"> </span>
<a href="#l53.397"></a><span id="l53.397"> /*</span>
<a href="#l53.398"></a><span id="l53.398">  * in bind.c</span>
<a href="#l53.399"></a><span id="l53.399">  */</span>
<a href="#l53.400"></a><span id="l53.400" class="difflineminus">-char *nsldapi_get_binddn(LDAP *ld);</span>
<a href="#l53.401"></a><span id="l53.401" class="difflineplus">+char* nsldapi_get_binddn(LDAP* ld);</span>
<a href="#l53.402"></a><span id="l53.402"> </span>
<a href="#l53.403"></a><span id="l53.403"> /*</span>
<a href="#l53.404"></a><span id="l53.404">  * in cache.c</span>
<a href="#l53.405"></a><span id="l53.405">  */</span>
<a href="#l53.406"></a><span id="l53.406" class="difflineminus">-void nsldapi_add_result_to_cache(LDAP *ld, LDAPMessage *result);</span>
<a href="#l53.407"></a><span id="l53.407" class="difflineplus">+void nsldapi_add_result_to_cache(LDAP* ld, LDAPMessage* result);</span>
<a href="#l53.408"></a><span id="l53.408"> </span>
<a href="#l53.409"></a><span id="l53.409"> /*</span>
<a href="#l53.410"></a><span id="l53.410">  * in dsparse.c</span>
<a href="#l53.411"></a><span id="l53.411">  */</span>
<a href="#l53.412"></a><span id="l53.412" class="difflineminus">-int nsldapi_next_line_tokens(char **bufp, long *blenp, char ***toksp);</span>
<a href="#l53.413"></a><span id="l53.413" class="difflineminus">-void nsldapi_free_strarray(char **sap);</span>
<a href="#l53.414"></a><span id="l53.414" class="difflineplus">+int nsldapi_next_line_tokens(char** bufp, long* blenp, char*** toksp);</span>
<a href="#l53.415"></a><span id="l53.415" class="difflineplus">+void nsldapi_free_strarray(char** sap);</span>
<a href="#l53.416"></a><span id="l53.416"> </span>
<a href="#l53.417"></a><span id="l53.417"> /*</span>
<a href="#l53.418"></a><span id="l53.418">  * in error.c</span>
<a href="#l53.419"></a><span id="l53.419">  */</span>
<a href="#l53.420"></a><span id="l53.420" class="difflineminus">-int nsldapi_parse_result(LDAP *ld, int msgtype, BerElement *rber, int *errcodep,</span>
<a href="#l53.421"></a><span id="l53.421" class="difflineminus">-                         char **matchednp, char **errmsgp, char ***referralsp,</span>
<a href="#l53.422"></a><span id="l53.422" class="difflineminus">-                         LDAPControl ***serverctrlsp);</span>
<a href="#l53.423"></a><span id="l53.423" class="difflineplus">+int nsldapi_parse_result(LDAP* ld, int msgtype, BerElement* rber, int* errcodep,</span>
<a href="#l53.424"></a><span id="l53.424" class="difflineplus">+                         char** matchednp, char** errmsgp, char*** referralsp,</span>
<a href="#l53.425"></a><span id="l53.425" class="difflineplus">+                         LDAPControl*** serverctrlsp);</span>
<a href="#l53.426"></a><span id="l53.426"> </span>
<a href="#l53.427"></a><span id="l53.427"> /*</span>
<a href="#l53.428"></a><span id="l53.428">  * in open.c</span>
<a href="#l53.429"></a><span id="l53.429">  */</span>
<a href="#l53.430"></a><span id="l53.430"> void nsldapi_initialize_defaults(void);</span>
<a href="#l53.431"></a><span id="l53.431" class="difflineminus">-void nsldapi_mutex_alloc_all(LDAP *ld);</span>
<a href="#l53.432"></a><span id="l53.432" class="difflineminus">-void nsldapi_mutex_free_all(LDAP *ld);</span>
<a href="#l53.433"></a><span id="l53.433" class="difflineminus">-int nsldapi_open_ldap_defconn(LDAP *ld);</span>
<a href="#l53.434"></a><span id="l53.434" class="difflineminus">-char *nsldapi_strdup(const char *s); /* if s is NULL, returns NULL */</span>
<a href="#l53.435"></a><span id="l53.435" class="difflineplus">+void nsldapi_mutex_alloc_all(LDAP* ld);</span>
<a href="#l53.436"></a><span id="l53.436" class="difflineplus">+void nsldapi_mutex_free_all(LDAP* ld);</span>
<a href="#l53.437"></a><span id="l53.437" class="difflineplus">+int nsldapi_open_ldap_defconn(LDAP* ld);</span>
<a href="#l53.438"></a><span id="l53.438" class="difflineplus">+char* nsldapi_strdup(const char* s); /* if s is NULL, returns NULL */</span>
<a href="#l53.439"></a><span id="l53.439"> </span>
<a href="#l53.440"></a><span id="l53.440"> /*</span>
<a href="#l53.441"></a><span id="l53.441">  * in os-ip.c</span>
<a href="#l53.442"></a><span id="l53.442">  */</span>
<a href="#l53.443"></a><span id="l53.443" class="difflineminus">-int nsldapi_connect_to_host(LDAP *ld, Sockbuf *sb, const char *host, int port,</span>
<a href="#l53.444"></a><span id="l53.444" class="difflineminus">-                            int secure, char **krbinstancep);</span>
<a href="#l53.445"></a><span id="l53.445" class="difflineminus">-void nsldapi_close_connection(LDAP *ld, Sockbuf *sb);</span>
<a href="#l53.446"></a><span id="l53.446" class="difflineplus">+int nsldapi_connect_to_host(LDAP* ld, Sockbuf* sb, const char* host, int port,</span>
<a href="#l53.447"></a><span id="l53.447" class="difflineplus">+                            int secure, char** krbinstancep);</span>
<a href="#l53.448"></a><span id="l53.448" class="difflineplus">+void nsldapi_close_connection(LDAP* ld, Sockbuf* sb);</span>
<a href="#l53.449"></a><span id="l53.449"> </span>
<a href="#l53.450"></a><span id="l53.450" class="difflineminus">-int nsldapi_iostatus_poll(LDAP *ld, struct timeval *timeout);</span>
<a href="#l53.451"></a><span id="l53.451" class="difflineminus">-void nsldapi_iostatus_free(LDAP *ld);</span>
<a href="#l53.452"></a><span id="l53.452" class="difflineminus">-int nsldapi_iostatus_interest_write(LDAP *ld, Sockbuf *sb);</span>
<a href="#l53.453"></a><span id="l53.453" class="difflineminus">-int nsldapi_iostatus_interest_read(LDAP *ld, Sockbuf *sb);</span>
<a href="#l53.454"></a><span id="l53.454" class="difflineminus">-int nsldapi_iostatus_interest_clear(LDAP *ld, Sockbuf *sb);</span>
<a href="#l53.455"></a><span id="l53.455" class="difflineminus">-int nsldapi_iostatus_is_read_ready(LDAP *ld, Sockbuf *sb);</span>
<a href="#l53.456"></a><span id="l53.456" class="difflineminus">-int nsldapi_iostatus_is_write_ready(LDAP *ld, Sockbuf *sb);</span>
<a href="#l53.457"></a><span id="l53.457" class="difflineminus">-int nsldapi_install_lber_extiofns(LDAP *ld, Sockbuf *sb);</span>
<a href="#l53.458"></a><span id="l53.458" class="difflineminus">-int nsldapi_install_compat_io_fns(LDAP *ld, struct ldap_io_fns *iofns);</span>
<a href="#l53.459"></a><span id="l53.459" class="difflineplus">+int nsldapi_iostatus_poll(LDAP* ld, struct timeval* timeout);</span>
<a href="#l53.460"></a><span id="l53.460" class="difflineplus">+void nsldapi_iostatus_free(LDAP* ld);</span>
<a href="#l53.461"></a><span id="l53.461" class="difflineplus">+int nsldapi_iostatus_interest_write(LDAP* ld, Sockbuf* sb);</span>
<a href="#l53.462"></a><span id="l53.462" class="difflineplus">+int nsldapi_iostatus_interest_read(LDAP* ld, Sockbuf* sb);</span>
<a href="#l53.463"></a><span id="l53.463" class="difflineplus">+int nsldapi_iostatus_interest_clear(LDAP* ld, Sockbuf* sb);</span>
<a href="#l53.464"></a><span id="l53.464" class="difflineplus">+int nsldapi_iostatus_is_read_ready(LDAP* ld, Sockbuf* sb);</span>
<a href="#l53.465"></a><span id="l53.465" class="difflineplus">+int nsldapi_iostatus_is_write_ready(LDAP* ld, Sockbuf* sb);</span>
<a href="#l53.466"></a><span id="l53.466" class="difflineplus">+int nsldapi_install_lber_extiofns(LDAP* ld, Sockbuf* sb);</span>
<a href="#l53.467"></a><span id="l53.467" class="difflineplus">+int nsldapi_install_compat_io_fns(LDAP* ld, struct ldap_io_fns* iofns);</span>
<a href="#l53.468"></a><span id="l53.468"> </span>
<a href="#l53.469"></a><span id="l53.469"> /*</span>
<a href="#l53.470"></a><span id="l53.470">  * if referral.c</span>
<a href="#l53.471"></a><span id="l53.471">  */</span>
<a href="#l53.472"></a><span id="l53.472" class="difflineminus">-int nsldapi_parse_reference(LDAP *ld, BerElement *rber, char ***referralsp,</span>
<a href="#l53.473"></a><span id="l53.473" class="difflineminus">-                            LDAPControl ***serverctrlsp);</span>
<a href="#l53.474"></a><span id="l53.474" class="difflineplus">+int nsldapi_parse_reference(LDAP* ld, BerElement* rber, char*** referralsp,</span>
<a href="#l53.475"></a><span id="l53.475" class="difflineplus">+                            LDAPControl*** serverctrlsp);</span>
<a href="#l53.476"></a><span id="l53.476"> </span>
<a href="#l53.477"></a><span id="l53.477"> /*</span>
<a href="#l53.478"></a><span id="l53.478">  * in result.c</span>
<a href="#l53.479"></a><span id="l53.479">  */</span>
<a href="#l53.480"></a><span id="l53.480" class="difflineminus">-int ldap_msgdelete(LDAP *ld, int msgid);</span>
<a href="#l53.481"></a><span id="l53.481" class="difflineminus">-int nsldapi_result_nolock(LDAP *ld, int msgid, int all, int unlock_permitted,</span>
<a href="#l53.482"></a><span id="l53.482" class="difflineminus">-                          struct timeval *timeout, LDAPMessage **result);</span>
<a href="#l53.483"></a><span id="l53.483" class="difflineminus">-int nsldapi_wait_result(LDAP *ld, int msgid, int all, struct timeval *timeout,</span>
<a href="#l53.484"></a><span id="l53.484" class="difflineminus">-                        LDAPMessage **result);</span>
<a href="#l53.485"></a><span id="l53.485" class="difflineminus">-int nsldapi_post_result(LDAP *ld, int msgid, LDAPMessage *result);</span>
<a href="#l53.486"></a><span id="l53.486" class="difflineplus">+int ldap_msgdelete(LDAP* ld, int msgid);</span>
<a href="#l53.487"></a><span id="l53.487" class="difflineplus">+int nsldapi_result_nolock(LDAP* ld, int msgid, int all, int unlock_permitted,</span>
<a href="#l53.488"></a><span id="l53.488" class="difflineplus">+                          struct timeval* timeout, LDAPMessage** result);</span>
<a href="#l53.489"></a><span id="l53.489" class="difflineplus">+int nsldapi_wait_result(LDAP* ld, int msgid, int all, struct timeval* timeout,</span>
<a href="#l53.490"></a><span id="l53.490" class="difflineplus">+                        LDAPMessage** result);</span>
<a href="#l53.491"></a><span id="l53.491" class="difflineplus">+int nsldapi_post_result(LDAP* ld, int msgid, LDAPMessage* result);</span>
<a href="#l53.492"></a><span id="l53.492"> </span>
<a href="#l53.493"></a><span id="l53.493"> /*</span>
<a href="#l53.494"></a><span id="l53.494">  * in request.c</span>
<a href="#l53.495"></a><span id="l53.495">  */</span>
<a href="#l53.496"></a><span id="l53.496" class="difflineminus">-int nsldapi_send_initial_request(LDAP *ld, int msgid, unsigned long msgtype,</span>
<a href="#l53.497"></a><span id="l53.497" class="difflineminus">-                                 char *dn, BerElement *ber);</span>
<a href="#l53.498"></a><span id="l53.498" class="difflineminus">-int nsldapi_send_pending_requests_nolock(LDAP *ld, LDAPConn *lc);</span>
<a href="#l53.499"></a><span id="l53.499" class="difflineminus">-int nsldapi_alloc_ber_with_options(LDAP *ld, BerElement **berp);</span>
<a href="#l53.500"></a><span id="l53.500" class="difflineminus">-void nsldapi_set_ber_options(LDAP *ld, BerElement *ber);</span>
<a href="#l53.501"></a><span id="l53.501" class="difflineminus">-int nsldapi_send_ber_message(LDAP *ld, Sockbuf *sb, BerElement *ber, int freeit,</span>
<a href="#l53.502"></a><span id="l53.502" class="difflineplus">+int nsldapi_send_initial_request(LDAP* ld, int msgid, unsigned long msgtype,</span>
<a href="#l53.503"></a><span id="l53.503" class="difflineplus">+                                 char* dn, BerElement* ber);</span>
<a href="#l53.504"></a><span id="l53.504" class="difflineplus">+int nsldapi_send_pending_requests_nolock(LDAP* ld, LDAPConn* lc);</span>
<a href="#l53.505"></a><span id="l53.505" class="difflineplus">+int nsldapi_alloc_ber_with_options(LDAP* ld, BerElement** berp);</span>
<a href="#l53.506"></a><span id="l53.506" class="difflineplus">+void nsldapi_set_ber_options(LDAP* ld, BerElement* ber);</span>
<a href="#l53.507"></a><span id="l53.507" class="difflineplus">+int nsldapi_send_ber_message(LDAP* ld, Sockbuf* sb, BerElement* ber, int freeit,</span>
<a href="#l53.508"></a><span id="l53.508">                              int epipe_handler);</span>
<a href="#l53.509"></a><span id="l53.509" class="difflineminus">-int nsldapi_send_server_request(LDAP *ld, BerElement *ber, int msgid,</span>
<a href="#l53.510"></a><span id="l53.510" class="difflineminus">-                                LDAPRequest *parentreq, LDAPServer *srvlist,</span>
<a href="#l53.511"></a><span id="l53.511" class="difflineminus">-                                LDAPConn *lc, char *bindreqdn, int bind);</span>
<a href="#l53.512"></a><span id="l53.512" class="difflineminus">-LDAPConn *nsldapi_new_connection(LDAP *ld, LDAPServer **srvlistp, int use_ldsb,</span>
<a href="#l53.513"></a><span id="l53.513" class="difflineplus">+int nsldapi_send_server_request(LDAP* ld, BerElement* ber, int msgid,</span>
<a href="#l53.514"></a><span id="l53.514" class="difflineplus">+                                LDAPRequest* parentreq, LDAPServer* srvlist,</span>
<a href="#l53.515"></a><span id="l53.515" class="difflineplus">+                                LDAPConn* lc, char* bindreqdn, int bind);</span>
<a href="#l53.516"></a><span id="l53.516" class="difflineplus">+LDAPConn* nsldapi_new_connection(LDAP* ld, LDAPServer** srvlistp, int use_ldsb,</span>
<a href="#l53.517"></a><span id="l53.517">                                  int connect, int bind);</span>
<a href="#l53.518"></a><span id="l53.518" class="difflineminus">-LDAPRequest *nsldapi_find_request_by_msgid(LDAP *ld, int msgid);</span>
<a href="#l53.519"></a><span id="l53.519" class="difflineminus">-LDAPRequest *nsldapi_new_request(LDAPConn *lc, BerElement *ber, int msgid,</span>
<a href="#l53.520"></a><span id="l53.520" class="difflineplus">+LDAPRequest* nsldapi_find_request_by_msgid(LDAP* ld, int msgid);</span>
<a href="#l53.521"></a><span id="l53.521" class="difflineplus">+LDAPRequest* nsldapi_new_request(LDAPConn* lc, BerElement* ber, int msgid,</span>
<a href="#l53.522"></a><span id="l53.522">                                  int expect_resp);</span>
<a href="#l53.523"></a><span id="l53.523" class="difflineminus">-void nsldapi_free_request(LDAP *ld, LDAPRequest *lr, int free_conn);</span>
<a href="#l53.524"></a><span id="l53.524" class="difflineminus">-void nsldapi_queue_request_nolock(LDAP *ld, LDAPRequest *lr);</span>
<a href="#l53.525"></a><span id="l53.525" class="difflineminus">-void nsldapi_free_connection(LDAP *ld, LDAPConn *lc, LDAPControl **serverctrls,</span>
<a href="#l53.526"></a><span id="l53.526" class="difflineminus">-                             LDAPControl **clientctrls, int force, int unbind);</span>
<a href="#l53.527"></a><span id="l53.527" class="difflineminus">-void nsldapi_dump_connection(LDAP *ld, LDAPConn *lconns, int all);</span>
<a href="#l53.528"></a><span id="l53.528" class="difflineminus">-void nsldapi_dump_requests_and_responses(LDAP *ld);</span>
<a href="#l53.529"></a><span id="l53.529" class="difflineminus">-int nsldapi_chase_v2_referrals(LDAP *ld, LDAPRequest *lr, char **errstrp,</span>
<a href="#l53.530"></a><span id="l53.530" class="difflineminus">-                               int *totalcountp, int *chasingcountp);</span>
<a href="#l53.531"></a><span id="l53.531" class="difflineminus">-int nsldapi_chase_v3_refs(LDAP *ld, LDAPRequest *lr, char **refs,</span>
<a href="#l53.532"></a><span id="l53.532" class="difflineminus">-                          int is_reference, int *totalcountp,</span>
<a href="#l53.533"></a><span id="l53.533" class="difflineminus">-                          int *chasingcountp);</span>
<a href="#l53.534"></a><span id="l53.534" class="difflineminus">-int nsldapi_append_referral(LDAP *ld, char **referralsp, char *s);</span>
<a href="#l53.535"></a><span id="l53.535" class="difflineminus">-void nsldapi_connection_lost_nolock(LDAP *ld, Sockbuf *sb);</span>
<a href="#l53.536"></a><span id="l53.536" class="difflineplus">+void nsldapi_free_request(LDAP* ld, LDAPRequest* lr, int free_conn);</span>
<a href="#l53.537"></a><span id="l53.537" class="difflineplus">+void nsldapi_queue_request_nolock(LDAP* ld, LDAPRequest* lr);</span>
<a href="#l53.538"></a><span id="l53.538" class="difflineplus">+void nsldapi_free_connection(LDAP* ld, LDAPConn* lc, LDAPControl** serverctrls,</span>
<a href="#l53.539"></a><span id="l53.539" class="difflineplus">+                             LDAPControl** clientctrls, int force, int unbind);</span>
<a href="#l53.540"></a><span id="l53.540" class="difflineplus">+void nsldapi_dump_connection(LDAP* ld, LDAPConn* lconns, int all);</span>
<a href="#l53.541"></a><span id="l53.541" class="difflineplus">+void nsldapi_dump_requests_and_responses(LDAP* ld);</span>
<a href="#l53.542"></a><span id="l53.542" class="difflineplus">+int nsldapi_chase_v2_referrals(LDAP* ld, LDAPRequest* lr, char** errstrp,</span>
<a href="#l53.543"></a><span id="l53.543" class="difflineplus">+                               int* totalcountp, int* chasingcountp);</span>
<a href="#l53.544"></a><span id="l53.544" class="difflineplus">+int nsldapi_chase_v3_refs(LDAP* ld, LDAPRequest* lr, char** refs,</span>
<a href="#l53.545"></a><span id="l53.545" class="difflineplus">+                          int is_reference, int* totalcountp,</span>
<a href="#l53.546"></a><span id="l53.546" class="difflineplus">+                          int* chasingcountp);</span>
<a href="#l53.547"></a><span id="l53.547" class="difflineplus">+int nsldapi_append_referral(LDAP* ld, char** referralsp, char* s);</span>
<a href="#l53.548"></a><span id="l53.548" class="difflineplus">+void nsldapi_connection_lost_nolock(LDAP* ld, Sockbuf* sb);</span>
<a href="#l53.549"></a><span id="l53.549"> </span>
<a href="#l53.550"></a><span id="l53.550"> #ifdef LDAP_SASLIO_HOOKS</span>
<a href="#l53.551"></a><span id="l53.551"> /*</span>
<a href="#l53.552"></a><span id="l53.552">  * in saslbind.c</span>
<a href="#l53.553"></a><span id="l53.553">  */</span>
<a href="#l53.554"></a><span id="l53.554"> int nsldapi_sasl_is_inited();</span>
<a href="#l53.555"></a><span id="l53.555" class="difflineminus">-int nsldapi_sasl_cvterrno(LDAP *ld, int err, char *msg);</span>
<a href="#l53.556"></a><span id="l53.556" class="difflineminus">-int nsldapi_sasl_secprops(const char *in, sasl_security_properties_t *secprops);</span>
<a href="#l53.557"></a><span id="l53.557" class="difflineplus">+int nsldapi_sasl_cvterrno(LDAP* ld, int err, char* msg);</span>
<a href="#l53.558"></a><span id="l53.558" class="difflineplus">+int nsldapi_sasl_secprops(const char* in, sasl_security_properties_t* secprops);</span>
<a href="#l53.559"></a><span id="l53.559"> </span>
<a href="#l53.560"></a><span id="l53.560"> /*</span>
<a href="#l53.561"></a><span id="l53.561">  * in saslio.c</span>
<a href="#l53.562"></a><span id="l53.562">  */</span>
<a href="#l53.563"></a><span id="l53.563" class="difflineminus">-int nsldapi_sasl_install(LDAP *ld, LDAPConn *lconn);</span>
<a href="#l53.564"></a><span id="l53.564" class="difflineminus">-int nsldapi_sasl_open(LDAP *ld, LDAPConn *lconn, sasl_conn_t **ctx,</span>
<a href="#l53.565"></a><span id="l53.565" class="difflineplus">+int nsldapi_sasl_install(LDAP* ld, LDAPConn* lconn);</span>
<a href="#l53.566"></a><span id="l53.566" class="difflineplus">+int nsldapi_sasl_open(LDAP* ld, LDAPConn* lconn, sasl_conn_t** ctx,</span>
<a href="#l53.567"></a><span id="l53.567">                       sasl_ssf_t ssf);</span>
<a href="#l53.568"></a><span id="l53.568"> </span>
<a href="#l53.569"></a><span id="l53.569"> #endif /* LDAP_SASLIO_HOOKS */</span>
<a href="#l53.570"></a><span id="l53.570"> </span>
<a href="#l53.571"></a><span id="l53.571"> /*</span>
<a href="#l53.572"></a><span id="l53.572">  * in search.c</span>
<a href="#l53.573"></a><span id="l53.573">  */</span>
<a href="#l53.574"></a><span id="l53.574" class="difflineminus">-int nsldapi_build_search_req(LDAP *ld, const char *base, int scope,</span>
<a href="#l53.575"></a><span id="l53.575" class="difflineminus">-                             const char *filter, char **attrs, int attrsonly,</span>
<a href="#l53.576"></a><span id="l53.576" class="difflineminus">-                             LDAPControl **serverctrls,</span>
<a href="#l53.577"></a><span id="l53.577" class="difflineminus">-                             LDAPControl **clientctrls, int timelimit,</span>
<a href="#l53.578"></a><span id="l53.578" class="difflineminus">-                             int sizelimit, int msgid, BerElement **berp);</span>
<a href="#l53.579"></a><span id="l53.579" class="difflineplus">+int nsldapi_build_search_req(LDAP* ld, const char* base, int scope,</span>
<a href="#l53.580"></a><span id="l53.580" class="difflineplus">+                             const char* filter, char** attrs, int attrsonly,</span>
<a href="#l53.581"></a><span id="l53.581" class="difflineplus">+                             LDAPControl** serverctrls,</span>
<a href="#l53.582"></a><span id="l53.582" class="difflineplus">+                             LDAPControl** clientctrls, int timelimit,</span>
<a href="#l53.583"></a><span id="l53.583" class="difflineplus">+                             int sizelimit, int msgid, BerElement** berp);</span>
<a href="#l53.584"></a><span id="l53.584"> </span>
<a href="#l53.585"></a><span id="l53.585"> /*</span>
<a href="#l53.586"></a><span id="l53.586">  * in unbind.c</span>
<a href="#l53.587"></a><span id="l53.587">  */</span>
<a href="#l53.588"></a><span id="l53.588" class="difflineminus">-int ldap_ld_free(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l53.589"></a><span id="l53.589" class="difflineplus">+int ldap_ld_free(LDAP* ld, LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l53.590"></a><span id="l53.590">                  int close);</span>
<a href="#l53.591"></a><span id="l53.591" class="difflineminus">-int nsldapi_send_unbind(LDAP *ld, Sockbuf *sb, LDAPControl **serverctrls,</span>
<a href="#l53.592"></a><span id="l53.592" class="difflineminus">-                        LDAPControl **clientctrls);</span>
<a href="#l53.593"></a><span id="l53.593" class="difflineplus">+int nsldapi_send_unbind(LDAP* ld, Sockbuf* sb, LDAPControl** serverctrls,</span>
<a href="#l53.594"></a><span id="l53.594" class="difflineplus">+                        LDAPControl** clientctrls);</span>
<a href="#l53.595"></a><span id="l53.595"> </span>
<a href="#l53.596"></a><span id="l53.596"> #ifdef LDAP_DNS</span>
<a href="#l53.597"></a><span id="l53.597"> /*</span>
<a href="#l53.598"></a><span id="l53.598">  * in getdxbyname.c</span>
<a href="#l53.599"></a><span id="l53.599">  */</span>
<a href="#l53.600"></a><span id="l53.600" class="difflineminus">-char **nsldapi_getdxbyname(char *domain);</span>
<a href="#l53.601"></a><span id="l53.601" class="difflineplus">+char** nsldapi_getdxbyname(char* domain);</span>
<a href="#l53.602"></a><span id="l53.602"> </span>
<a href="#l53.603"></a><span id="l53.603"> #endif /* LDAP_DNS */</span>
<a href="#l53.604"></a><span id="l53.604"> </span>
<a href="#l53.605"></a><span id="l53.605"> /*</span>
<a href="#l53.606"></a><span id="l53.606">  * in unescape.c</span>
<a href="#l53.607"></a><span id="l53.607">  */</span>
<a href="#l53.608"></a><span id="l53.608" class="difflineminus">-void nsldapi_hex_unescape(char *s);</span>
<a href="#l53.609"></a><span id="l53.609" class="difflineplus">+void nsldapi_hex_unescape(char* s);</span>
<a href="#l53.610"></a><span id="l53.610"> </span>
<a href="#l53.611"></a><span id="l53.611"> /*</span>
<a href="#l53.612"></a><span id="l53.612">  * in compat.c</span>
<a href="#l53.613"></a><span id="l53.613">  */</span>
<a href="#l53.614"></a><span id="l53.614"> #ifdef hpux</span>
<a href="#l53.615"></a><span id="l53.615" class="difflineminus">-char *nsldapi_compat_ctime_r(const time_t *clock, char *buf, int buflen);</span>
<a href="#l53.616"></a><span id="l53.616" class="difflineminus">-struct hostent *nsldapi_compat_gethostbyname_r(const char *name,</span>
<a href="#l53.617"></a><span id="l53.617" class="difflineminus">-                                               struct hostent *result,</span>
<a href="#l53.618"></a><span id="l53.618" class="difflineminus">-                                               char *buffer, int buflen,</span>
<a href="#l53.619"></a><span id="l53.619" class="difflineminus">-                                               int *h_errnop);</span>
<a href="#l53.620"></a><span id="l53.620" class="difflineplus">+char* nsldapi_compat_ctime_r(const time_t* clock, char* buf, int buflen);</span>
<a href="#l53.621"></a><span id="l53.621" class="difflineplus">+struct hostent* nsldapi_compat_gethostbyname_r(const char* name,</span>
<a href="#l53.622"></a><span id="l53.622" class="difflineplus">+                                               struct hostent* result,</span>
<a href="#l53.623"></a><span id="l53.623" class="difflineplus">+                                               char* buffer, int buflen,</span>
<a href="#l53.624"></a><span id="l53.624" class="difflineplus">+                                               int* h_errnop);</span>
<a href="#l53.625"></a><span id="l53.625"> #endif /* hpux */</span>
<a href="#l53.626"></a><span id="l53.626"> </span>
<a href="#l53.627"></a><span id="l53.627"> /*</span>
<a href="#l53.628"></a><span id="l53.628">  * in control.c</span>
<a href="#l53.629"></a><span id="l53.629">  */</span>
<a href="#l53.630"></a><span id="l53.630" class="difflineminus">-int nsldapi_put_controls(LDAP *ld, LDAPControl **ctrls, int closeseq,</span>
<a href="#l53.631"></a><span id="l53.631" class="difflineminus">-                         BerElement *ber);</span>
<a href="#l53.632"></a><span id="l53.632" class="difflineminus">-int nsldapi_get_controls(BerElement *ber, LDAPControl ***controlsp);</span>
<a href="#l53.633"></a><span id="l53.633" class="difflineminus">-int nsldapi_find_controls(BerElement *ber, LDAPControl ***controlsp);</span>
<a href="#l53.634"></a><span id="l53.634" class="difflineminus">-int nsldapi_dup_controls(LDAP *ld, LDAPControl ***ldctrls,</span>
<a href="#l53.635"></a><span id="l53.635" class="difflineminus">-                         LDAPControl **newctrls);</span>
<a href="#l53.636"></a><span id="l53.636" class="difflineminus">-int nsldapi_build_control(char *oid, BerElement *ber, int freeber,</span>
<a href="#l53.637"></a><span id="l53.637" class="difflineminus">-                          char iscritical, LDAPControl **ctrlp);</span>
<a href="#l53.638"></a><span id="l53.638" class="difflineplus">+int nsldapi_put_controls(LDAP* ld, LDAPControl** ctrls, int closeseq,</span>
<a href="#l53.639"></a><span id="l53.639" class="difflineplus">+                         BerElement* ber);</span>
<a href="#l53.640"></a><span id="l53.640" class="difflineplus">+int nsldapi_get_controls(BerElement* ber, LDAPControl*** controlsp);</span>
<a href="#l53.641"></a><span id="l53.641" class="difflineplus">+int nsldapi_find_controls(BerElement* ber, LDAPControl*** controlsp);</span>
<a href="#l53.642"></a><span id="l53.642" class="difflineplus">+int nsldapi_dup_controls(LDAP* ld, LDAPControl*** ldctrls,</span>
<a href="#l53.643"></a><span id="l53.643" class="difflineplus">+                         LDAPControl** newctrls);</span>
<a href="#l53.644"></a><span id="l53.644" class="difflineplus">+int nsldapi_build_control(char* oid, BerElement* ber, int freeber,</span>
<a href="#l53.645"></a><span id="l53.645" class="difflineplus">+                          char iscritical, LDAPControl** ctrlp);</span>
<a href="#l53.646"></a><span id="l53.646"> </span>
<a href="#l53.647"></a><span id="l53.647"> /*</span>
<a href="#l53.648"></a><span id="l53.648">  * in url.c</span>
<a href="#l53.649"></a><span id="l53.649">  */</span>
<a href="#l53.650"></a><span id="l53.650" class="difflineminus">-int nsldapi_url_parse(const char *inurl, LDAPURLDesc **ludpp, int dn_required);</span>
<a href="#l53.651"></a><span id="l53.651" class="difflineplus">+int nsldapi_url_parse(const char* inurl, LDAPURLDesc** ludpp, int dn_required);</span>
<a href="#l53.652"></a><span id="l53.652"> </span>
<a href="#l53.653"></a><span id="l53.653"> /*</span>
<a href="#l53.654"></a><span id="l53.654">  * in charset.c</span>
<a href="#l53.655"></a><span id="l53.655">  *</span>
<a href="#l53.656"></a><span id="l53.656">  * If we ever want to expose character set translation functionality to</span>
<a href="#l53.657"></a><span id="l53.657">  * users of libldap, all of these prototypes will need to be moved to ldap.h</span>
<a href="#l53.658"></a><span id="l53.658">  */</span>
<a href="#l53.659"></a><span id="l53.659"> #ifdef STR_TRANSLATION</span>
<a href="#l53.660"></a><span id="l53.660" class="difflineminus">-void ldap_set_string_translators(LDAP *ld, BERTranslateProc encode_proc,</span>
<a href="#l53.661"></a><span id="l53.661" class="difflineplus">+void ldap_set_string_translators(LDAP* ld, BERTranslateProc encode_proc,</span>
<a href="#l53.662"></a><span id="l53.662">                                  BERTranslateProc decode_proc);</span>
<a href="#l53.663"></a><span id="l53.663" class="difflineminus">-int ldap_translate_from_t61(LDAP *ld, char **bufp, unsigned long *lenp,</span>
<a href="#l53.664"></a><span id="l53.664" class="difflineplus">+int ldap_translate_from_t61(LDAP* ld, char** bufp, unsigned long* lenp,</span>
<a href="#l53.665"></a><span id="l53.665">                             int free_input);</span>
<a href="#l53.666"></a><span id="l53.666" class="difflineminus">-int ldap_translate_to_t61(LDAP *ld, char **bufp, unsigned long *lenp,</span>
<a href="#l53.667"></a><span id="l53.667" class="difflineplus">+int ldap_translate_to_t61(LDAP* ld, char** bufp, unsigned long* lenp,</span>
<a href="#l53.668"></a><span id="l53.668">                           int free_input);</span>
<a href="#l53.669"></a><span id="l53.669" class="difflineminus">-void ldap_enable_translation(LDAP *ld, LDAPMessage *entry, int enable);</span>
<a href="#l53.670"></a><span id="l53.670" class="difflineplus">+void ldap_enable_translation(LDAP* ld, LDAPMessage* entry, int enable);</span>
<a href="#l53.671"></a><span id="l53.671"> #  ifdef LDAP_CHARSET_8859</span>
<a href="#l53.672"></a><span id="l53.672" class="difflineminus">-int ldap_t61_to_8859(char **bufp, unsigned long *buflenp, int free_input);</span>
<a href="#l53.673"></a><span id="l53.673" class="difflineminus">-int ldap_8859_to_t61(char **bufp, unsigned long *buflenp, int free_input);</span>
<a href="#l53.674"></a><span id="l53.674" class="difflineplus">+int ldap_t61_to_8859(char** bufp, unsigned long* buflenp, int free_input);</span>
<a href="#l53.675"></a><span id="l53.675" class="difflineplus">+int ldap_8859_to_t61(char** bufp, unsigned long* buflenp, int free_input);</span>
<a href="#l53.676"></a><span id="l53.676"> #  endif /* LDAP_CHARSET_8859 */</span>
<a href="#l53.677"></a><span id="l53.677"> #endif   /* STR_TRANSLATION */</span>
<a href="#l53.678"></a><span id="l53.678"> </span>
<a href="#l53.679"></a><span id="l53.679"> /*</span>
<a href="#l53.680"></a><span id="l53.680">  * in memcache.h</span>
<a href="#l53.681"></a><span id="l53.681">  */</span>
<a href="#l53.682"></a><span id="l53.682" class="difflineminus">-int ldap_memcache_createkey(LDAP *ld, const char *base, int scope,</span>
<a href="#l53.683"></a><span id="l53.683" class="difflineminus">-                            const char *filter, char **attrs, int attrsonly,</span>
<a href="#l53.684"></a><span id="l53.684" class="difflineminus">-                            LDAPControl **serverctrls,</span>
<a href="#l53.685"></a><span id="l53.685" class="difflineminus">-                            LDAPControl **clientctrls, unsigned long *keyp);</span>
<a href="#l53.686"></a><span id="l53.686" class="difflineminus">-int ldap_memcache_result(LDAP *ld, int msgid, unsigned long key);</span>
<a href="#l53.687"></a><span id="l53.687" class="difflineminus">-int ldap_memcache_new(LDAP *ld, int msgid, unsigned long key,</span>
<a href="#l53.688"></a><span id="l53.688" class="difflineminus">-                      const char *basedn);</span>
<a href="#l53.689"></a><span id="l53.689" class="difflineminus">-int ldap_memcache_append(LDAP *ld, int msgid, int bLast, LDAPMessage *result);</span>
<a href="#l53.690"></a><span id="l53.690" class="difflineminus">-int ldap_memcache_abandon(LDAP *ld, int msgid);</span>
<a href="#l53.691"></a><span id="l53.691" class="difflineplus">+int ldap_memcache_createkey(LDAP* ld, const char* base, int scope,</span>
<a href="#l53.692"></a><span id="l53.692" class="difflineplus">+                            const char* filter, char** attrs, int attrsonly,</span>
<a href="#l53.693"></a><span id="l53.693" class="difflineplus">+                            LDAPControl** serverctrls,</span>
<a href="#l53.694"></a><span id="l53.694" class="difflineplus">+                            LDAPControl** clientctrls, unsigned long* keyp);</span>
<a href="#l53.695"></a><span id="l53.695" class="difflineplus">+int ldap_memcache_result(LDAP* ld, int msgid, unsigned long key);</span>
<a href="#l53.696"></a><span id="l53.696" class="difflineplus">+int ldap_memcache_new(LDAP* ld, int msgid, unsigned long key,</span>
<a href="#l53.697"></a><span id="l53.697" class="difflineplus">+                      const char* basedn);</span>
<a href="#l53.698"></a><span id="l53.698" class="difflineplus">+int ldap_memcache_append(LDAP* ld, int msgid, int bLast, LDAPMessage* result);</span>
<a href="#l53.699"></a><span id="l53.699" class="difflineplus">+int ldap_memcache_abandon(LDAP* ld, int msgid);</span>
<a href="#l53.700"></a><span id="l53.700"> </span>
<a href="#l53.701"></a><span id="l53.701"> /*</span>
<a href="#l53.702"></a><span id="l53.702">  * in sbind.c</span>
<a href="#l53.703"></a><span id="l53.703">  */</span>
<a href="#l53.704"></a><span id="l53.704" class="difflineminus">-void nsldapi_handle_reconnect(LDAP *ld);</span>
<a href="#l53.705"></a><span id="l53.705" class="difflineplus">+void nsldapi_handle_reconnect(LDAP* ld);</span>
<a href="#l53.706"></a><span id="l53.706"> </span>
<a href="#l53.707"></a><span id="l53.707"> #endif /* _LDAPINT_H */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l54.1"></a><span id="l54.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/memcache.c</span>
<a href="#l54.2"></a><span id="l54.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/memcache.c</span>
<a href="#l54.3"></a><span id="l54.3" class="difflineat">@@ -107,173 +107,173 @@</span>
<a href="#l54.4"></a><span id="l54.4">   }</span>
<a href="#l54.5"></a><span id="l54.5"> </span>
<a href="#l54.6"></a><span id="l54.6"> /* Macros used for trimming unnecessary spaces in a basedn */</span>
<a href="#l54.7"></a><span id="l54.7"> #define NSLDAPI_IS_SPACE(c) (((c) == ' ') || ((c) == '\t') || ((c) == '\n'))</span>
<a href="#l54.8"></a><span id="l54.8"> </span>
<a href="#l54.9"></a><span id="l54.9"> #define NSLDAPI_IS_SEPARATER(c) ((c) == ',')</span>
<a href="#l54.10"></a><span id="l54.10"> </span>
<a href="#l54.11"></a><span id="l54.11"> /* Hash table callback function pointer definition */</span>
<a href="#l54.12"></a><span id="l54.12" class="difflineminus">-typedef int (*HashFuncPtr)(int table_size, void *key);</span>
<a href="#l54.13"></a><span id="l54.13" class="difflineminus">-typedef int (*PutDataPtr)(void **ppTableData, void *key, void *pData);</span>
<a href="#l54.14"></a><span id="l54.14" class="difflineminus">-typedef int (*GetDataPtr)(void *pTableData, void *key, void **ppData);</span>
<a href="#l54.15"></a><span id="l54.15" class="difflineminus">-typedef int (*RemoveDataPtr)(void **ppTableData, void *key, void **ppData);</span>
<a href="#l54.16"></a><span id="l54.16" class="difflineminus">-typedef int (*MiscFuncPtr)(void **ppTableData, void *key, void *pData);</span>
<a href="#l54.17"></a><span id="l54.17" class="difflineminus">-typedef void (*ClrTableNodePtr)(void **ppTableData, void *pData);</span>
<a href="#l54.18"></a><span id="l54.18" class="difflineplus">+typedef int (*HashFuncPtr)(int table_size, void* key);</span>
<a href="#l54.19"></a><span id="l54.19" class="difflineplus">+typedef int (*PutDataPtr)(void** ppTableData, void* key, void* pData);</span>
<a href="#l54.20"></a><span id="l54.20" class="difflineplus">+typedef int (*GetDataPtr)(void* pTableData, void* key, void** ppData);</span>
<a href="#l54.21"></a><span id="l54.21" class="difflineplus">+typedef int (*RemoveDataPtr)(void** ppTableData, void* key, void** ppData);</span>
<a href="#l54.22"></a><span id="l54.22" class="difflineplus">+typedef int (*MiscFuncPtr)(void** ppTableData, void* key, void* pData);</span>
<a href="#l54.23"></a><span id="l54.23" class="difflineplus">+typedef void (*ClrTableNodePtr)(void** ppTableData, void* pData);</span>
<a href="#l54.24"></a><span id="l54.24"> </span>
<a href="#l54.25"></a><span id="l54.25"> /* Structure of a node in a hash table */</span>
<a href="#l54.26"></a><span id="l54.26"> typedef struct HashTableNode_struct {</span>
<a href="#l54.27"></a><span id="l54.27" class="difflineminus">-  void *pData;</span>
<a href="#l54.28"></a><span id="l54.28" class="difflineplus">+  void* pData;</span>
<a href="#l54.29"></a><span id="l54.29"> } HashTableNode;</span>
<a href="#l54.30"></a><span id="l54.30"> </span>
<a href="#l54.31"></a><span id="l54.31"> /* Structure of a hash table */</span>
<a href="#l54.32"></a><span id="l54.32"> typedef struct HashTable_struct {</span>
<a href="#l54.33"></a><span id="l54.33" class="difflineminus">-  HashTableNode *table;</span>
<a href="#l54.34"></a><span id="l54.34" class="difflineplus">+  HashTableNode* table;</span>
<a href="#l54.35"></a><span id="l54.35">   int size;</span>
<a href="#l54.36"></a><span id="l54.36">   HashFuncPtr hashfunc;</span>
<a href="#l54.37"></a><span id="l54.37">   PutDataPtr putdata;</span>
<a href="#l54.38"></a><span id="l54.38">   GetDataPtr getdata;</span>
<a href="#l54.39"></a><span id="l54.39">   MiscFuncPtr miscfunc;</span>
<a href="#l54.40"></a><span id="l54.40">   RemoveDataPtr removedata;</span>
<a href="#l54.41"></a><span id="l54.41">   ClrTableNodePtr clrtablenode;</span>
<a href="#l54.42"></a><span id="l54.42"> } HashTable;</span>
<a href="#l54.43"></a><span id="l54.43"> </span>
<a href="#l54.44"></a><span id="l54.44"> /* Structure uniquely identifies a search request */</span>
<a href="#l54.45"></a><span id="l54.45"> typedef struct ldapmemcacheReqId_struct {</span>
<a href="#l54.46"></a><span id="l54.46" class="difflineminus">-  LDAP *ldmemcrid_ld;</span>
<a href="#l54.47"></a><span id="l54.47" class="difflineplus">+  LDAP* ldmemcrid_ld;</span>
<a href="#l54.48"></a><span id="l54.48">   int ldmemcrid_msgid;</span>
<a href="#l54.49"></a><span id="l54.49"> } ldapmemcacheReqId;</span>
<a href="#l54.50"></a><span id="l54.50"> </span>
<a href="#l54.51"></a><span id="l54.51"> /* Structure representing a ldap handle associated to memcache */</span>
<a href="#l54.52"></a><span id="l54.52"> typedef struct ldapmemcacheld_struct {</span>
<a href="#l54.53"></a><span id="l54.53" class="difflineminus">-  LDAP *ldmemcl_ld;</span>
<a href="#l54.54"></a><span id="l54.54" class="difflineminus">-  struct ldapmemcacheld_struct *ldmemcl_next;</span>
<a href="#l54.55"></a><span id="l54.55" class="difflineplus">+  LDAP* ldmemcl_ld;</span>
<a href="#l54.56"></a><span id="l54.56" class="difflineplus">+  struct ldapmemcacheld_struct* ldmemcl_next;</span>
<a href="#l54.57"></a><span id="l54.57"> } ldapmemcacheld;</span>
<a href="#l54.58"></a><span id="l54.58"> </span>
<a href="#l54.59"></a><span id="l54.59"> /* Structure representing header of a search result */</span>
<a href="#l54.60"></a><span id="l54.60"> typedef struct ldapmemcacheRes_struct {</span>
<a href="#l54.61"></a><span id="l54.61" class="difflineminus">-  char *ldmemcr_basedn;</span>
<a href="#l54.62"></a><span id="l54.62" class="difflineplus">+  char* ldmemcr_basedn;</span>
<a href="#l54.63"></a><span id="l54.63">   unsigned long ldmemcr_crc_key;</span>
<a href="#l54.64"></a><span id="l54.64">   unsigned long ldmemcr_resSize;</span>
<a href="#l54.65"></a><span id="l54.65">   unsigned long ldmemcr_timestamp;</span>
<a href="#l54.66"></a><span id="l54.66" class="difflineminus">-  LDAPMessage *ldmemcr_resHead;</span>
<a href="#l54.67"></a><span id="l54.67" class="difflineminus">-  LDAPMessage *ldmemcr_resTail;</span>
<a href="#l54.68"></a><span id="l54.68" class="difflineplus">+  LDAPMessage* ldmemcr_resHead;</span>
<a href="#l54.69"></a><span id="l54.69" class="difflineplus">+  LDAPMessage* ldmemcr_resTail;</span>
<a href="#l54.70"></a><span id="l54.70">   ldapmemcacheReqId ldmemcr_req_id;</span>
<a href="#l54.71"></a><span id="l54.71" class="difflineminus">-  struct ldapmemcacheRes_struct *ldmemcr_next[LIST_TOTAL];</span>
<a href="#l54.72"></a><span id="l54.72" class="difflineminus">-  struct ldapmemcacheRes_struct *ldmemcr_prev[LIST_TOTAL];</span>
<a href="#l54.73"></a><span id="l54.73" class="difflineminus">-  struct ldapmemcacheRes_struct *ldmemcr_htable_next;</span>
<a href="#l54.74"></a><span id="l54.74" class="difflineplus">+  struct ldapmemcacheRes_struct* ldmemcr_next[LIST_TOTAL];</span>
<a href="#l54.75"></a><span id="l54.75" class="difflineplus">+  struct ldapmemcacheRes_struct* ldmemcr_prev[LIST_TOTAL];</span>
<a href="#l54.76"></a><span id="l54.76" class="difflineplus">+  struct ldapmemcacheRes_struct* ldmemcr_htable_next;</span>
<a href="#l54.77"></a><span id="l54.77"> } ldapmemcacheRes;</span>
<a href="#l54.78"></a><span id="l54.78"> </span>
<a href="#l54.79"></a><span id="l54.79"> /* Structure for memcache statistics */</span>
<a href="#l54.80"></a><span id="l54.80"> typedef struct ldapmemcacheStats_struct {</span>
<a href="#l54.81"></a><span id="l54.81">   unsigned long ldmemcstat_tries;</span>
<a href="#l54.82"></a><span id="l54.82">   unsigned long ldmemcstat_hits;</span>
<a href="#l54.83"></a><span id="l54.83"> } ldapmemcacheStats;</span>
<a href="#l54.84"></a><span id="l54.84"> </span>
<a href="#l54.85"></a><span id="l54.85"> /* Structure of a memcache object */</span>
<a href="#l54.86"></a><span id="l54.86"> struct ldapmemcache {</span>
<a href="#l54.87"></a><span id="l54.87">   unsigned long ldmemc_ttl;</span>
<a href="#l54.88"></a><span id="l54.88">   unsigned long ldmemc_size;</span>
<a href="#l54.89"></a><span id="l54.89">   unsigned long ldmemc_size_used;</span>
<a href="#l54.90"></a><span id="l54.90">   unsigned long ldmemc_size_entries;</span>
<a href="#l54.91"></a><span id="l54.91" class="difflineminus">-  char **ldmemc_basedns;</span>
<a href="#l54.92"></a><span id="l54.92" class="difflineminus">-  void *ldmemc_lock;</span>
<a href="#l54.93"></a><span id="l54.93" class="difflineminus">-  ldapmemcacheld *ldmemc_lds;</span>
<a href="#l54.94"></a><span id="l54.94" class="difflineminus">-  HashTable *ldmemc_resTmp;</span>
<a href="#l54.95"></a><span id="l54.95" class="difflineminus">-  HashTable *ldmemc_resLookup;</span>
<a href="#l54.96"></a><span id="l54.96" class="difflineminus">-  ldapmemcacheRes *ldmemc_resHead[LIST_TOTAL];</span>
<a href="#l54.97"></a><span id="l54.97" class="difflineminus">-  ldapmemcacheRes *ldmemc_resTail[LIST_TOTAL];</span>
<a href="#l54.98"></a><span id="l54.98" class="difflineplus">+  char** ldmemc_basedns;</span>
<a href="#l54.99"></a><span id="l54.99" class="difflineplus">+  void* ldmemc_lock;</span>
<a href="#l54.100"></a><span id="l54.100" class="difflineplus">+  ldapmemcacheld* ldmemc_lds;</span>
<a href="#l54.101"></a><span id="l54.101" class="difflineplus">+  HashTable* ldmemc_resTmp;</span>
<a href="#l54.102"></a><span id="l54.102" class="difflineplus">+  HashTable* ldmemc_resLookup;</span>
<a href="#l54.103"></a><span id="l54.103" class="difflineplus">+  ldapmemcacheRes* ldmemc_resHead[LIST_TOTAL];</span>
<a href="#l54.104"></a><span id="l54.104" class="difflineplus">+  ldapmemcacheRes* ldmemc_resTail[LIST_TOTAL];</span>
<a href="#l54.105"></a><span id="l54.105">   struct ldap_thread_fns ldmemc_lock_fns;</span>
<a href="#l54.106"></a><span id="l54.106">   ldapmemcacheStats ldmemc_stats;</span>
<a href="#l54.107"></a><span id="l54.107"> };</span>
<a href="#l54.108"></a><span id="l54.108"> </span>
<a href="#l54.109"></a><span id="l54.109"> /* Function prototypes */</span>
<a href="#l54.110"></a><span id="l54.110" class="difflineminus">-static int memcache_exist(LDAP *ld);</span>
<a href="#l54.111"></a><span id="l54.111" class="difflineminus">-static int memcache_add_to_ld(LDAP *ld, int msgid, LDAPMessage *pMsg);</span>
<a href="#l54.112"></a><span id="l54.112" class="difflineminus">-static int memcache_compare_dn(const char *main_dn, const char *dn, int scope);</span>
<a href="#l54.113"></a><span id="l54.113" class="difflineminus">-static int memcache_dup_message(LDAPMessage *res, int msgid, int fromcache,</span>
<a href="#l54.114"></a><span id="l54.114" class="difflineminus">-                                LDAPMessage **ppResCopy, unsigned long *pSize);</span>
<a href="#l54.115"></a><span id="l54.115" class="difflineminus">-static BerElement *memcache_ber_dup(BerElement *pBer, unsigned long *pSize);</span>
<a href="#l54.116"></a><span id="l54.116" class="difflineplus">+static int memcache_exist(LDAP* ld);</span>
<a href="#l54.117"></a><span id="l54.117" class="difflineplus">+static int memcache_add_to_ld(LDAP* ld, int msgid, LDAPMessage* pMsg);</span>
<a href="#l54.118"></a><span id="l54.118" class="difflineplus">+static int memcache_compare_dn(const char* main_dn, const char* dn, int scope);</span>
<a href="#l54.119"></a><span id="l54.119" class="difflineplus">+static int memcache_dup_message(LDAPMessage* res, int msgid, int fromcache,</span>
<a href="#l54.120"></a><span id="l54.120" class="difflineplus">+                                LDAPMessage** ppResCopy, unsigned long* pSize);</span>
<a href="#l54.121"></a><span id="l54.121" class="difflineplus">+static BerElement* memcache_ber_dup(BerElement* pBer, unsigned long* pSize);</span>
<a href="#l54.122"></a><span id="l54.122"> </span>
<a href="#l54.123"></a><span id="l54.123" class="difflineminus">-static void memcache_trim_basedn_spaces(char *basedn);</span>
<a href="#l54.124"></a><span id="l54.124" class="difflineminus">-static int memcache_validate_basedn(LDAPMemCache *cache, const char *basedn);</span>
<a href="#l54.125"></a><span id="l54.125" class="difflineminus">-static int memcache_get_ctrls_len(LDAPControl **ctrls);</span>
<a href="#l54.126"></a><span id="l54.126" class="difflineminus">-static void memcache_append_ctrls(char *buf, LDAPControl **serverCtrls,</span>
<a href="#l54.127"></a><span id="l54.127" class="difflineminus">-                                  LDAPControl **clientCtrls);</span>
<a href="#l54.128"></a><span id="l54.128" class="difflineminus">-static int memcache_adj_size(LDAPMemCache *cache, unsigned long size,</span>
<a href="#l54.129"></a><span id="l54.129" class="difflineplus">+static void memcache_trim_basedn_spaces(char* basedn);</span>
<a href="#l54.130"></a><span id="l54.130" class="difflineplus">+static int memcache_validate_basedn(LDAPMemCache* cache, const char* basedn);</span>
<a href="#l54.131"></a><span id="l54.131" class="difflineplus">+static int memcache_get_ctrls_len(LDAPControl** ctrls);</span>
<a href="#l54.132"></a><span id="l54.132" class="difflineplus">+static void memcache_append_ctrls(char* buf, LDAPControl** serverCtrls,</span>
<a href="#l54.133"></a><span id="l54.133" class="difflineplus">+                                  LDAPControl** clientCtrls);</span>
<a href="#l54.134"></a><span id="l54.134" class="difflineplus">+static int memcache_adj_size(LDAPMemCache* cache, unsigned long size,</span>
<a href="#l54.135"></a><span id="l54.135">                              int usageFlags, int bAdd);</span>
<a href="#l54.136"></a><span id="l54.136" class="difflineminus">-static int memcache_free_entry(LDAPMemCache *cache, ldapmemcacheRes *pRes);</span>
<a href="#l54.137"></a><span id="l54.137" class="difflineminus">-static int memcache_expired(LDAPMemCache *cache, ldapmemcacheRes *pRes,</span>
<a href="#l54.138"></a><span id="l54.138" class="difflineplus">+static int memcache_free_entry(LDAPMemCache* cache, ldapmemcacheRes* pRes);</span>
<a href="#l54.139"></a><span id="l54.139" class="difflineplus">+static int memcache_expired(LDAPMemCache* cache, ldapmemcacheRes* pRes,</span>
<a href="#l54.140"></a><span id="l54.140">                             unsigned long curTime);</span>
<a href="#l54.141"></a><span id="l54.141" class="difflineminus">-static int memcache_add_to_list(LDAPMemCache *cache, ldapmemcacheRes *pRes,</span>
<a href="#l54.142"></a><span id="l54.142" class="difflineplus">+static int memcache_add_to_list(LDAPMemCache* cache, ldapmemcacheRes* pRes,</span>
<a href="#l54.143"></a><span id="l54.143">                                 int index);</span>
<a href="#l54.144"></a><span id="l54.144" class="difflineminus">-static int memcache_add_res_to_list(ldapmemcacheRes *pRes, LDAPMessage *pMsg,</span>
<a href="#l54.145"></a><span id="l54.145" class="difflineplus">+static int memcache_add_res_to_list(ldapmemcacheRes* pRes, LDAPMessage* pMsg,</span>
<a href="#l54.146"></a><span id="l54.146">                                     unsigned long size);</span>
<a href="#l54.147"></a><span id="l54.147" class="difflineminus">-static int memcache_free_from_list(LDAPMemCache *cache, ldapmemcacheRes *pRes,</span>
<a href="#l54.148"></a><span id="l54.148" class="difflineplus">+static int memcache_free_from_list(LDAPMemCache* cache, ldapmemcacheRes* pRes,</span>
<a href="#l54.149"></a><span id="l54.149">                                    int index);</span>
<a href="#l54.150"></a><span id="l54.150" class="difflineminus">-static int memcache_search(LDAP *ld, unsigned long key, LDAPMessage **ppRes);</span>
<a href="#l54.151"></a><span id="l54.151" class="difflineminus">-static int memcache_add(LDAP *ld, unsigned long key, int msgid,</span>
<a href="#l54.152"></a><span id="l54.152" class="difflineminus">-                        const char *basedn);</span>
<a href="#l54.153"></a><span id="l54.153" class="difflineminus">-static int memcache_append(LDAP *ld, int msgid, LDAPMessage *pRes);</span>
<a href="#l54.154"></a><span id="l54.154" class="difflineminus">-static int memcache_append_last(LDAP *ld, int msgid, LDAPMessage *pRes);</span>
<a href="#l54.155"></a><span id="l54.155" class="difflineminus">-static int memcache_remove(LDAP *ld, int msgid);</span>
<a href="#l54.156"></a><span id="l54.156" class="difflineplus">+static int memcache_search(LDAP* ld, unsigned long key, LDAPMessage** ppRes);</span>
<a href="#l54.157"></a><span id="l54.157" class="difflineplus">+static int memcache_add(LDAP* ld, unsigned long key, int msgid,</span>
<a href="#l54.158"></a><span id="l54.158" class="difflineplus">+                        const char* basedn);</span>
<a href="#l54.159"></a><span id="l54.159" class="difflineplus">+static int memcache_append(LDAP* ld, int msgid, LDAPMessage* pRes);</span>
<a href="#l54.160"></a><span id="l54.160" class="difflineplus">+static int memcache_append_last(LDAP* ld, int msgid, LDAPMessage* pRes);</span>
<a href="#l54.161"></a><span id="l54.161" class="difflineplus">+static int memcache_remove(LDAP* ld, int msgid);</span>
<a href="#l54.162"></a><span id="l54.162"> #if 0  /* function not used */</span>
<a href="#l54.163"></a><span id="l54.163"> static int memcache_remove_all(LDAP *ld);</span>
<a href="#l54.164"></a><span id="l54.164"> #endif /* 0 */</span>
<a href="#l54.165"></a><span id="l54.165" class="difflineminus">-static int memcache_access(LDAPMemCache *cache, int mode, void *pData1,</span>
<a href="#l54.166"></a><span id="l54.166" class="difflineminus">-                           void *pData2, void *pData3);</span>
<a href="#l54.167"></a><span id="l54.167" class="difflineminus">-static void memcache_flush(LDAPMemCache *cache, char *dn, int scope,</span>
<a href="#l54.168"></a><span id="l54.168" class="difflineplus">+static int memcache_access(LDAPMemCache* cache, int mode, void* pData1,</span>
<a href="#l54.169"></a><span id="l54.169" class="difflineplus">+                           void* pData2, void* pData3);</span>
<a href="#l54.170"></a><span id="l54.170" class="difflineplus">+static void memcache_flush(LDAPMemCache* cache, char* dn, int scope,</span>
<a href="#l54.171"></a><span id="l54.171">                            int flushresults);</span>
<a href="#l54.172"></a><span id="l54.172"> #ifdef LDAP_DEBUG</span>
<a href="#l54.173"></a><span id="l54.173" class="difflineminus">-static void memcache_print_list(LDAPMemCache *cache, int index);</span>
<a href="#l54.174"></a><span id="l54.174" class="difflineminus">-static void memcache_report_statistics(LDAPMemCache *cache);</span>
<a href="#l54.175"></a><span id="l54.175" class="difflineplus">+static void memcache_print_list(LDAPMemCache* cache, int index);</span>
<a href="#l54.176"></a><span id="l54.176" class="difflineplus">+static void memcache_report_statistics(LDAPMemCache* cache);</span>
<a href="#l54.177"></a><span id="l54.177"> #endif /* LDAP_DEBUG */</span>
<a href="#l54.178"></a><span id="l54.178"> </span>
<a href="#l54.179"></a><span id="l54.179"> static int htable_calculate_size(int sizelimit);</span>
<a href="#l54.180"></a><span id="l54.180" class="difflineminus">-static int htable_sizeinbytes(HashTable *pTable);</span>
<a href="#l54.181"></a><span id="l54.181" class="difflineminus">-static int htable_put(HashTable *pTable, void *key, void *pData);</span>
<a href="#l54.182"></a><span id="l54.182" class="difflineminus">-static int htable_get(HashTable *pTable, void *key, void **ppData);</span>
<a href="#l54.183"></a><span id="l54.183" class="difflineminus">-static int htable_misc(HashTable *pTable, void *key, void *pData);</span>
<a href="#l54.184"></a><span id="l54.184" class="difflineminus">-static int htable_remove(HashTable *pTable, void *key, void **ppData);</span>
<a href="#l54.185"></a><span id="l54.185" class="difflineminus">-static int htable_removeall(HashTable *pTable, void *pData);</span>
<a href="#l54.186"></a><span id="l54.186" class="difflineplus">+static int htable_sizeinbytes(HashTable* pTable);</span>
<a href="#l54.187"></a><span id="l54.187" class="difflineplus">+static int htable_put(HashTable* pTable, void* key, void* pData);</span>
<a href="#l54.188"></a><span id="l54.188" class="difflineplus">+static int htable_get(HashTable* pTable, void* key, void** ppData);</span>
<a href="#l54.189"></a><span id="l54.189" class="difflineplus">+static int htable_misc(HashTable* pTable, void* key, void* pData);</span>
<a href="#l54.190"></a><span id="l54.190" class="difflineplus">+static int htable_remove(HashTable* pTable, void* key, void** ppData);</span>
<a href="#l54.191"></a><span id="l54.191" class="difflineplus">+static int htable_removeall(HashTable* pTable, void* pData);</span>
<a href="#l54.192"></a><span id="l54.192"> static int htable_create(int size_limit, HashFuncPtr hashf, PutDataPtr putDataf,</span>
<a href="#l54.193"></a><span id="l54.193">                          GetDataPtr getDataf, RemoveDataPtr removeDataf,</span>
<a href="#l54.194"></a><span id="l54.194">                          ClrTableNodePtr clrNodef, MiscFuncPtr miscOpf,</span>
<a href="#l54.195"></a><span id="l54.195" class="difflineminus">-                         HashTable **ppTable);</span>
<a href="#l54.196"></a><span id="l54.196" class="difflineminus">-static int htable_free(HashTable *pTable);</span>
<a href="#l54.197"></a><span id="l54.197" class="difflineplus">+                         HashTable** ppTable);</span>
<a href="#l54.198"></a><span id="l54.198" class="difflineplus">+static int htable_free(HashTable* pTable);</span>
<a href="#l54.199"></a><span id="l54.199"> </span>
<a href="#l54.200"></a><span id="l54.200" class="difflineminus">-static int msgid_hashf(int table_size, void *key);</span>
<a href="#l54.201"></a><span id="l54.201" class="difflineminus">-static int msgid_putdata(void **ppTableData, void *key, void *pData);</span>
<a href="#l54.202"></a><span id="l54.202" class="difflineminus">-static int msgid_getdata(void *pTableData, void *key, void **ppData);</span>
<a href="#l54.203"></a><span id="l54.203" class="difflineminus">-static int msgid_removedata(void **ppTableData, void *key, void **ppData);</span>
<a href="#l54.204"></a><span id="l54.204" class="difflineminus">-static int msgid_clear_ld_items(void **ppTableData, void *key, void *pData);</span>
<a href="#l54.205"></a><span id="l54.205" class="difflineminus">-static void msgid_clearnode(void **ppTableData, void *pData);</span>
<a href="#l54.206"></a><span id="l54.206" class="difflineplus">+static int msgid_hashf(int table_size, void* key);</span>
<a href="#l54.207"></a><span id="l54.207" class="difflineplus">+static int msgid_putdata(void** ppTableData, void* key, void* pData);</span>
<a href="#l54.208"></a><span id="l54.208" class="difflineplus">+static int msgid_getdata(void* pTableData, void* key, void** ppData);</span>
<a href="#l54.209"></a><span id="l54.209" class="difflineplus">+static int msgid_removedata(void** ppTableData, void* key, void** ppData);</span>
<a href="#l54.210"></a><span id="l54.210" class="difflineplus">+static int msgid_clear_ld_items(void** ppTableData, void* key, void* pData);</span>
<a href="#l54.211"></a><span id="l54.211" class="difflineplus">+static void msgid_clearnode(void** ppTableData, void* pData);</span>
<a href="#l54.212"></a><span id="l54.212"> </span>
<a href="#l54.213"></a><span id="l54.213" class="difflineminus">-static int attrkey_hashf(int table_size, void *key);</span>
<a href="#l54.214"></a><span id="l54.214" class="difflineminus">-static int attrkey_putdata(void **ppTableData, void *key, void *pData);</span>
<a href="#l54.215"></a><span id="l54.215" class="difflineminus">-static int attrkey_getdata(void *pTableData, void *key, void **ppData);</span>
<a href="#l54.216"></a><span id="l54.216" class="difflineminus">-static int attrkey_removedata(void **ppTableData, void *key, void **ppData);</span>
<a href="#l54.217"></a><span id="l54.217" class="difflineminus">-static void attrkey_clearnode(void **ppTableData, void *pData);</span>
<a href="#l54.218"></a><span id="l54.218" class="difflineplus">+static int attrkey_hashf(int table_size, void* key);</span>
<a href="#l54.219"></a><span id="l54.219" class="difflineplus">+static int attrkey_putdata(void** ppTableData, void* key, void* pData);</span>
<a href="#l54.220"></a><span id="l54.220" class="difflineplus">+static int attrkey_getdata(void* pTableData, void* key, void** ppData);</span>
<a href="#l54.221"></a><span id="l54.221" class="difflineplus">+static int attrkey_removedata(void** ppTableData, void* key, void** ppData);</span>
<a href="#l54.222"></a><span id="l54.222" class="difflineplus">+static void attrkey_clearnode(void** ppTableData, void* pData);</span>
<a href="#l54.223"></a><span id="l54.223"> </span>
<a href="#l54.224"></a><span id="l54.224" class="difflineminus">-static unsigned long crc32_convert(char *buf, int len);</span>
<a href="#l54.225"></a><span id="l54.225" class="difflineplus">+static unsigned long crc32_convert(char* buf, int len);</span>
<a href="#l54.226"></a><span id="l54.226"> </span>
<a href="#l54.227"></a><span id="l54.227"> /* Create a memcache object. */</span>
<a href="#l54.228"></a><span id="l54.228"> int LDAP_CALL ldap_memcache_init(unsigned long ttl, unsigned long size,</span>
<a href="#l54.229"></a><span id="l54.229" class="difflineminus">-                                 char **baseDNs,</span>
<a href="#l54.230"></a><span id="l54.230" class="difflineminus">-                                 struct ldap_thread_fns *thread_fns,</span>
<a href="#l54.231"></a><span id="l54.231" class="difflineminus">-                                 LDAPMemCache **cachep) {</span>
<a href="#l54.232"></a><span id="l54.232" class="difflineplus">+                                 char** baseDNs,</span>
<a href="#l54.233"></a><span id="l54.233" class="difflineplus">+                                 struct ldap_thread_fns* thread_fns,</span>
<a href="#l54.234"></a><span id="l54.234" class="difflineplus">+                                 LDAPMemCache** cachep) {</span>
<a href="#l54.235"></a><span id="l54.235">   unsigned long total_size = 0;</span>
<a href="#l54.236"></a><span id="l54.236"> </span>
<a href="#l54.237"></a><span id="l54.237">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_memcache_init\n&quot;, 0, 0, 0);</span>
<a href="#l54.238"></a><span id="l54.238"> </span>
<a href="#l54.239"></a><span id="l54.239">   if (cachep == NULL) {</span>
<a href="#l54.240"></a><span id="l54.240">     return (LDAP_PARAM_ERROR);</span>
<a href="#l54.241"></a><span id="l54.241">   }</span>
<a href="#l54.242"></a><span id="l54.242"> </span>
<a href="#l54.243"></a><span id="l54.243" class="difflineminus">-  if ((*cachep = (LDAPMemCache *)NSLDAPI_CALLOC(1, sizeof(LDAPMemCache))) ==</span>
<a href="#l54.244"></a><span id="l54.244" class="difflineplus">+  if ((*cachep = (LDAPMemCache*)NSLDAPI_CALLOC(1, sizeof(LDAPMemCache))) ==</span>
<a href="#l54.245"></a><span id="l54.245">       NULL) {</span>
<a href="#l54.246"></a><span id="l54.246">     return (LDAP_NO_MEMORY);</span>
<a href="#l54.247"></a><span id="l54.247">   }</span>
<a href="#l54.248"></a><span id="l54.248"> </span>
<a href="#l54.249"></a><span id="l54.249">   total_size += sizeof(LDAPMemCache);</span>
<a href="#l54.250"></a><span id="l54.250"> </span>
<a href="#l54.251"></a><span id="l54.251">   (*cachep)-&gt;ldmemc_ttl = ttl;</span>
<a href="#l54.252"></a><span id="l54.252">   (*cachep)-&gt;ldmemc_size = size;</span>
<a href="#l54.253"></a><span id="l54.253" class="difflineat">@@ -294,25 +294,25 @@ int LDAP_CALL ldap_memcache_init(unsigne</span>
<a href="#l54.254"></a><span id="l54.254">   /* Cache basedns */</span>
<a href="#l54.255"></a><span id="l54.255">   if (baseDNs != NULL) {</span>
<a href="#l54.256"></a><span id="l54.256">     int i;</span>
<a href="#l54.257"></a><span id="l54.257"> </span>
<a href="#l54.258"></a><span id="l54.258">     for (i = 0; baseDNs[i]; i++) {</span>
<a href="#l54.259"></a><span id="l54.259">       ;</span>
<a href="#l54.260"></a><span id="l54.260">     }</span>
<a href="#l54.261"></a><span id="l54.261"> </span>
<a href="#l54.262"></a><span id="l54.262" class="difflineminus">-    (*cachep)-&gt;ldmemc_basedns = (char **)NSLDAPI_CALLOC(i + 1, sizeof(char *));</span>
<a href="#l54.263"></a><span id="l54.263" class="difflineplus">+    (*cachep)-&gt;ldmemc_basedns = (char**)NSLDAPI_CALLOC(i + 1, sizeof(char*));</span>
<a href="#l54.264"></a><span id="l54.264"> </span>
<a href="#l54.265"></a><span id="l54.265">     if ((*cachep)-&gt;ldmemc_basedns == NULL) {</span>
<a href="#l54.266"></a><span id="l54.266">       ldap_memcache_destroy(*cachep);</span>
<a href="#l54.267"></a><span id="l54.267">       *cachep = NULL;</span>
<a href="#l54.268"></a><span id="l54.268">       return (LDAP_NO_MEMORY);</span>
<a href="#l54.269"></a><span id="l54.269">     }</span>
<a href="#l54.270"></a><span id="l54.270"> </span>
<a href="#l54.271"></a><span id="l54.271" class="difflineminus">-    total_size += (i + 1) * sizeof(char *);</span>
<a href="#l54.272"></a><span id="l54.272" class="difflineplus">+    total_size += (i + 1) * sizeof(char*);</span>
<a href="#l54.273"></a><span id="l54.273"> </span>
<a href="#l54.274"></a><span id="l54.274">     for (i = 0; baseDNs[i]; i++) {</span>
<a href="#l54.275"></a><span id="l54.275">       (*cachep)-&gt;ldmemc_basedns[i] = nsldapi_strdup(baseDNs[i]);</span>
<a href="#l54.276"></a><span id="l54.276">       total_size += strlen(baseDNs[i]) + 1;</span>
<a href="#l54.277"></a><span id="l54.277">     }</span>
<a href="#l54.278"></a><span id="l54.278"> </span>
<a href="#l54.279"></a><span id="l54.279">     (*cachep)-&gt;ldmemc_basedns[i] = NULL;</span>
<a href="#l54.280"></a><span id="l54.280">   }</span>
<a href="#l54.281"></a><span id="l54.281" class="difflineat">@@ -349,46 +349,46 @@ int LDAP_CALL ldap_memcache_init(unsigne</span>
<a href="#l54.282"></a><span id="l54.282"> </span>
<a href="#l54.283"></a><span id="l54.283">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_memcache_init new cache 0x%p\n&quot;, *cachep, 0,</span>
<a href="#l54.284"></a><span id="l54.284">             0);</span>
<a href="#l54.285"></a><span id="l54.285"> </span>
<a href="#l54.286"></a><span id="l54.286">   return (LDAP_SUCCESS);</span>
<a href="#l54.287"></a><span id="l54.287"> }</span>
<a href="#l54.288"></a><span id="l54.288"> </span>
<a href="#l54.289"></a><span id="l54.289"> /* Associates a ldap handle to a memcache object. */</span>
<a href="#l54.290"></a><span id="l54.290" class="difflineminus">-int LDAP_CALL ldap_memcache_set(LDAP *ld, LDAPMemCache *cache) {</span>
<a href="#l54.291"></a><span id="l54.291" class="difflineplus">+int LDAP_CALL ldap_memcache_set(LDAP* ld, LDAPMemCache* cache) {</span>
<a href="#l54.292"></a><span id="l54.292">   int nRes = LDAP_SUCCESS;</span>
<a href="#l54.293"></a><span id="l54.293"> </span>
<a href="#l54.294"></a><span id="l54.294">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_memcache_set\n&quot;, 0, 0, 0);</span>
<a href="#l54.295"></a><span id="l54.295"> </span>
<a href="#l54.296"></a><span id="l54.296">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) return (LDAP_PARAM_ERROR);</span>
<a href="#l54.297"></a><span id="l54.297"> </span>
<a href="#l54.298"></a><span id="l54.298">   LDAP_MUTEX_LOCK(ld, LDAP_MEMCACHE_LOCK);</span>
<a href="#l54.299"></a><span id="l54.299"> </span>
<a href="#l54.300"></a><span id="l54.300">   if (ld-&gt;ld_memcache != cache) {</span>
<a href="#l54.301"></a><span id="l54.301" class="difflineminus">-    LDAPMemCache *c = ld-&gt;ld_memcache;</span>
<a href="#l54.302"></a><span id="l54.302" class="difflineminus">-    ldapmemcacheld *pCur = NULL;</span>
<a href="#l54.303"></a><span id="l54.303" class="difflineminus">-    ldapmemcacheld *pPrev = NULL;</span>
<a href="#l54.304"></a><span id="l54.304" class="difflineplus">+    LDAPMemCache* c = ld-&gt;ld_memcache;</span>
<a href="#l54.305"></a><span id="l54.305" class="difflineplus">+    ldapmemcacheld* pCur = NULL;</span>
<a href="#l54.306"></a><span id="l54.306" class="difflineplus">+    ldapmemcacheld* pPrev = NULL;</span>
<a href="#l54.307"></a><span id="l54.307"> </span>
<a href="#l54.308"></a><span id="l54.308">     /* First dissociate handle from old cache */</span>
<a href="#l54.309"></a><span id="l54.309"> </span>
<a href="#l54.310"></a><span id="l54.310">     LDAP_MEMCACHE_MUTEX_LOCK(c);</span>
<a href="#l54.311"></a><span id="l54.311"> </span>
<a href="#l54.312"></a><span id="l54.312">     pCur = (c ? c-&gt;ldmemc_lds : NULL);</span>
<a href="#l54.313"></a><span id="l54.313">     for (; pCur; pCur = pCur-&gt;ldmemcl_next) {</span>
<a href="#l54.314"></a><span id="l54.314">       if (pCur-&gt;ldmemcl_ld == ld) break;</span>
<a href="#l54.315"></a><span id="l54.315">       pPrev = pCur;</span>
<a href="#l54.316"></a><span id="l54.316">     }</span>
<a href="#l54.317"></a><span id="l54.317"> </span>
<a href="#l54.318"></a><span id="l54.318">     if (pCur) {</span>
<a href="#l54.319"></a><span id="l54.319">       ldapmemcacheReqId reqid;</span>
<a href="#l54.320"></a><span id="l54.320"> </span>
<a href="#l54.321"></a><span id="l54.321">       reqid.ldmemcrid_ld = ld;</span>
<a href="#l54.322"></a><span id="l54.322">       reqid.ldmemcrid_msgid = -1;</span>
<a href="#l54.323"></a><span id="l54.323" class="difflineminus">-      htable_misc(c-&gt;ldmemc_resTmp, (void *)&amp;reqid, (void *)c);</span>
<a href="#l54.324"></a><span id="l54.324" class="difflineplus">+      htable_misc(c-&gt;ldmemc_resTmp, (void*)&amp;reqid, (void*)c);</span>
<a href="#l54.325"></a><span id="l54.325"> </span>
<a href="#l54.326"></a><span id="l54.326">       if (pPrev)</span>
<a href="#l54.327"></a><span id="l54.327">         pPrev-&gt;ldmemcl_next = pCur-&gt;ldmemcl_next;</span>
<a href="#l54.328"></a><span id="l54.328">       else</span>
<a href="#l54.329"></a><span id="l54.329">         c-&gt;ldmemc_lds = pCur-&gt;ldmemcl_next;</span>
<a href="#l54.330"></a><span id="l54.330">       NSLDAPI_FREE(pCur);</span>
<a href="#l54.331"></a><span id="l54.331">       pCur = NULL;</span>
<a href="#l54.332"></a><span id="l54.332"> </span>
<a href="#l54.333"></a><span id="l54.333" class="difflineat">@@ -413,17 +413,17 @@ int LDAP_CALL ldap_memcache_set(LDAP *ld</span>
<a href="#l54.334"></a><span id="l54.334">     if ((nRes = memcache_adj_size(cache, sizeof(ldapmemcacheld),</span>
<a href="#l54.335"></a><span id="l54.335">                                   MEMCACHE_SIZE_NON_ENTRIES,</span>
<a href="#l54.336"></a><span id="l54.336">                                   MEMCACHE_SIZE_ADD)) != LDAP_SUCCESS) {</span>
<a href="#l54.337"></a><span id="l54.337">       LDAP_MEMCACHE_MUTEX_UNLOCK(cache);</span>
<a href="#l54.338"></a><span id="l54.338">       LDAP_MUTEX_UNLOCK(ld, LDAP_MEMCACHE_LOCK);</span>
<a href="#l54.339"></a><span id="l54.339">       return nRes;</span>
<a href="#l54.340"></a><span id="l54.340">     }</span>
<a href="#l54.341"></a><span id="l54.341"> </span>
<a href="#l54.342"></a><span id="l54.342" class="difflineminus">-    pCur = (ldapmemcacheld *)NSLDAPI_CALLOC(1, sizeof(ldapmemcacheld));</span>
<a href="#l54.343"></a><span id="l54.343" class="difflineplus">+    pCur = (ldapmemcacheld*)NSLDAPI_CALLOC(1, sizeof(ldapmemcacheld));</span>
<a href="#l54.344"></a><span id="l54.344">     if (pCur == NULL) {</span>
<a href="#l54.345"></a><span id="l54.345">       memcache_adj_size(cache, sizeof(ldapmemcacheld),</span>
<a href="#l54.346"></a><span id="l54.346">                         MEMCACHE_SIZE_NON_ENTRIES, MEMCACHE_SIZE_DEDUCT);</span>
<a href="#l54.347"></a><span id="l54.347">       nRes = LDAP_NO_MEMORY;</span>
<a href="#l54.348"></a><span id="l54.348">     } else {</span>
<a href="#l54.349"></a><span id="l54.349">       pCur-&gt;ldmemcl_ld = ld;</span>
<a href="#l54.350"></a><span id="l54.350">       pCur-&gt;ldmemcl_next = cache-&gt;ldmemc_lds;</span>
<a href="#l54.351"></a><span id="l54.351">       cache-&gt;ldmemc_lds = pCur;</span>
<a href="#l54.352"></a><span id="l54.352" class="difflineat">@@ -434,17 +434,17 @@ int LDAP_CALL ldap_memcache_set(LDAP *ld</span>
<a href="#l54.353"></a><span id="l54.353">   }</span>
<a href="#l54.354"></a><span id="l54.354"> </span>
<a href="#l54.355"></a><span id="l54.355">   LDAP_MUTEX_UNLOCK(ld, LDAP_MEMCACHE_LOCK);</span>
<a href="#l54.356"></a><span id="l54.356"> </span>
<a href="#l54.357"></a><span id="l54.357">   return nRes;</span>
<a href="#l54.358"></a><span id="l54.358"> }</span>
<a href="#l54.359"></a><span id="l54.359"> </span>
<a href="#l54.360"></a><span id="l54.360"> /* Retrieves memcache with which the ldap handle has been associated. */</span>
<a href="#l54.361"></a><span id="l54.361" class="difflineminus">-int LDAP_CALL ldap_memcache_get(LDAP *ld, LDAPMemCache **cachep) {</span>
<a href="#l54.362"></a><span id="l54.362" class="difflineplus">+int LDAP_CALL ldap_memcache_get(LDAP* ld, LDAPMemCache** cachep) {</span>
<a href="#l54.363"></a><span id="l54.363">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_memcache_get ld: 0x%p\n&quot;, ld, 0, 0);</span>
<a href="#l54.364"></a><span id="l54.364"> </span>
<a href="#l54.365"></a><span id="l54.365">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || cachep == NULL) {</span>
<a href="#l54.366"></a><span id="l54.366">     return (LDAP_PARAM_ERROR);</span>
<a href="#l54.367"></a><span id="l54.367">   }</span>
<a href="#l54.368"></a><span id="l54.368"> </span>
<a href="#l54.369"></a><span id="l54.369">   LDAP_MUTEX_LOCK(ld, LDAP_MEMCACHE_LOCK);</span>
<a href="#l54.370"></a><span id="l54.370">   *cachep = ld-&gt;ld_memcache;</span>
<a href="#l54.371"></a><span id="l54.371" class="difflineat">@@ -453,50 +453,50 @@ int LDAP_CALL ldap_memcache_get(LDAP *ld</span>
<a href="#l54.372"></a><span id="l54.372">   return (LDAP_SUCCESS);</span>
<a href="#l54.373"></a><span id="l54.373"> }</span>
<a href="#l54.374"></a><span id="l54.374"> </span>
<a href="#l54.375"></a><span id="l54.375"> /*</span>
<a href="#l54.376"></a><span id="l54.376">  * Function that stays inside libldap and proactively expires items from</span>
<a href="#l54.377"></a><span id="l54.377">  * the given cache.  This should be called from a newly created thread since</span>
<a href="#l54.378"></a><span id="l54.378">  * it will not return until after ldap_memcache_destroy() is called.</span>
<a href="#l54.379"></a><span id="l54.379">  */</span>
<a href="#l54.380"></a><span id="l54.380" class="difflineminus">-void LDAP_CALL ldap_memcache_update(LDAPMemCache *cache) {</span>
<a href="#l54.381"></a><span id="l54.381" class="difflineplus">+void LDAP_CALL ldap_memcache_update(LDAPMemCache* cache) {</span>
<a href="#l54.382"></a><span id="l54.382">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_memcache_update: cache 0x%p\n&quot;, cache, 0,</span>
<a href="#l54.383"></a><span id="l54.383">             0);</span>
<a href="#l54.384"></a><span id="l54.384"> </span>
<a href="#l54.385"></a><span id="l54.385">   if (!NSLDAPI_VALID_MEMCACHE_POINTER(cache)) {</span>
<a href="#l54.386"></a><span id="l54.386">     return;</span>
<a href="#l54.387"></a><span id="l54.387">   }</span>
<a href="#l54.388"></a><span id="l54.388"> </span>
<a href="#l54.389"></a><span id="l54.389">   LDAP_MEMCACHE_MUTEX_LOCK(cache);</span>
<a href="#l54.390"></a><span id="l54.390">   memcache_access(cache, MEMCACHE_ACCESS_UPDATE, NULL, NULL, NULL);</span>
<a href="#l54.391"></a><span id="l54.391">   LDAP_MEMCACHE_MUTEX_UNLOCK(cache);</span>
<a href="#l54.392"></a><span id="l54.392"> }</span>
<a href="#l54.393"></a><span id="l54.393"> </span>
<a href="#l54.394"></a><span id="l54.394"> /* Removes specified entries from given memcache. Only clears out search</span>
<a href="#l54.395"></a><span id="l54.395">    results that included search entries. */</span>
<a href="#l54.396"></a><span id="l54.396" class="difflineminus">-void LDAP_CALL ldap_memcache_flush(LDAPMemCache *cache, char *dn, int scope) {</span>
<a href="#l54.397"></a><span id="l54.397" class="difflineplus">+void LDAP_CALL ldap_memcache_flush(LDAPMemCache* cache, char* dn, int scope) {</span>
<a href="#l54.398"></a><span id="l54.398">   LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l54.399"></a><span id="l54.399">             &quot;ldap_memcache_flush( cache: 0x%p, dn: %s, scope: %d)\n&quot;, cache,</span>
<a href="#l54.400"></a><span id="l54.400">             (dn == NULL) ? &quot;(null)&quot; : dn, scope);</span>
<a href="#l54.401"></a><span id="l54.401">   memcache_flush(cache, dn, scope, 0 /* Don't use result flush mode */);</span>
<a href="#l54.402"></a><span id="l54.402"> }</span>
<a href="#l54.403"></a><span id="l54.403"> </span>
<a href="#l54.404"></a><span id="l54.404"> /* Removes specified entries from given memcache, including search</span>
<a href="#l54.405"></a><span id="l54.405">    results that returned no entries. */</span>
<a href="#l54.406"></a><span id="l54.406" class="difflineminus">-void LDAP_CALL ldap_memcache_flush_results(LDAPMemCache *cache, char *dn,</span>
<a href="#l54.407"></a><span id="l54.407" class="difflineplus">+void LDAP_CALL ldap_memcache_flush_results(LDAPMemCache* cache, char* dn,</span>
<a href="#l54.408"></a><span id="l54.408">                                            int scope) {</span>
<a href="#l54.409"></a><span id="l54.409">   LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l54.410"></a><span id="l54.410">             &quot;ldap_memcache_flush_results( cache: 0x%p, dn: %s, scope: %d)\n&quot;,</span>
<a href="#l54.411"></a><span id="l54.411">             cache, (dn == NULL) ? &quot;(null)&quot; : dn, scope);</span>
<a href="#l54.412"></a><span id="l54.412">   memcache_flush(cache, dn, scope, 1 /* Use result flush mode */);</span>
<a href="#l54.413"></a><span id="l54.413"> }</span>
<a href="#l54.414"></a><span id="l54.414"> </span>
<a href="#l54.415"></a><span id="l54.415"> /* Destroys the given memcache. */</span>
<a href="#l54.416"></a><span id="l54.416" class="difflineminus">-void LDAP_CALL ldap_memcache_destroy(LDAPMemCache *cache) {</span>
<a href="#l54.417"></a><span id="l54.417" class="difflineplus">+void LDAP_CALL ldap_memcache_destroy(LDAPMemCache* cache) {</span>
<a href="#l54.418"></a><span id="l54.418">   int i = 0;</span>
<a href="#l54.419"></a><span id="l54.419">   unsigned long size = sizeof(LDAPMemCache);</span>
<a href="#l54.420"></a><span id="l54.420">   ldapmemcacheld *pNode = NULL, *pNextNode = NULL;</span>
<a href="#l54.421"></a><span id="l54.421"> </span>
<a href="#l54.422"></a><span id="l54.422">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_memcache_destroy( 0x%p )\n&quot;, cache, 0, 0);</span>
<a href="#l54.423"></a><span id="l54.423"> </span>
<a href="#l54.424"></a><span id="l54.424">   if (!NSLDAPI_VALID_MEMCACHE_POINTER(cache)) {</span>
<a href="#l54.425"></a><span id="l54.425">     return;</span>
<a href="#l54.426"></a><span id="l54.426" class="difflineat">@@ -519,17 +519,17 @@ void LDAP_CALL ldap_memcache_destroy(LDA</span>
<a href="#l54.427"></a><span id="l54.427">   LDAP_MEMCACHE_MUTEX_UNLOCK(cache);</span>
<a href="#l54.428"></a><span id="l54.428"> </span>
<a href="#l54.429"></a><span id="l54.429">   /* Free array of basedns */</span>
<a href="#l54.430"></a><span id="l54.430">   if (cache-&gt;ldmemc_basedns) {</span>
<a href="#l54.431"></a><span id="l54.431">     for (i = 0; cache-&gt;ldmemc_basedns[i]; i++) {</span>
<a href="#l54.432"></a><span id="l54.432">       size += strlen(cache-&gt;ldmemc_basedns[i]) + 1;</span>
<a href="#l54.433"></a><span id="l54.433">       NSLDAPI_FREE(cache-&gt;ldmemc_basedns[i]);</span>
<a href="#l54.434"></a><span id="l54.434">     }</span>
<a href="#l54.435"></a><span id="l54.435" class="difflineminus">-    size += (i + 1) * sizeof(char *);</span>
<a href="#l54.436"></a><span id="l54.436" class="difflineplus">+    size += (i + 1) * sizeof(char*);</span>
<a href="#l54.437"></a><span id="l54.437">     NSLDAPI_FREE(cache-&gt;ldmemc_basedns);</span>
<a href="#l54.438"></a><span id="l54.438">   }</span>
<a href="#l54.439"></a><span id="l54.439"> </span>
<a href="#l54.440"></a><span id="l54.440">   /* Free hash table used for temporary cache */</span>
<a href="#l54.441"></a><span id="l54.441">   if (cache-&gt;ldmemc_resTmp) {</span>
<a href="#l54.442"></a><span id="l54.442">     size += htable_sizeinbytes(cache-&gt;ldmemc_resTmp);</span>
<a href="#l54.443"></a><span id="l54.443">     memcache_access(cache, MEMCACHE_ACCESS_DELETE_ALL, NULL, NULL, NULL);</span>
<a href="#l54.444"></a><span id="l54.444">     htable_free(cache-&gt;ldmemc_resTmp);</span>
<a href="#l54.445"></a><span id="l54.445" class="difflineat">@@ -552,20 +552,20 @@ void LDAP_CALL ldap_memcache_destroy(LDA</span>
<a href="#l54.446"></a><span id="l54.446"> </span>
<a href="#l54.447"></a><span id="l54.447"> /************************* Internal API Functions ****************************/</span>
<a href="#l54.448"></a><span id="l54.448"> </span>
<a href="#l54.449"></a><span id="l54.449"> /* Creates an integer key by applying the Cyclic Reduntency Check algorithm on</span>
<a href="#l54.450"></a><span id="l54.450">    a long string formed by concatenating all the search parameters plus the</span>
<a href="#l54.451"></a><span id="l54.451">    current bind DN.  The key is used in the cache for looking up cached</span>
<a href="#l54.452"></a><span id="l54.452">    entries.  It is assumed that the CRC algorithm will generate</span>
<a href="#l54.453"></a><span id="l54.453">    different integers from different byte strings. */</span>
<a href="#l54.454"></a><span id="l54.454" class="difflineminus">-int ldap_memcache_createkey(LDAP *ld, const char *base, int scope,</span>
<a href="#l54.455"></a><span id="l54.455" class="difflineminus">-                            const char *filter, char **attrs, int attrsonly,</span>
<a href="#l54.456"></a><span id="l54.456" class="difflineminus">-                            LDAPControl **serverctrls,</span>
<a href="#l54.457"></a><span id="l54.457" class="difflineminus">-                            LDAPControl **clientctrls, unsigned long *keyp) {</span>
<a href="#l54.458"></a><span id="l54.458" class="difflineplus">+int ldap_memcache_createkey(LDAP* ld, const char* base, int scope,</span>
<a href="#l54.459"></a><span id="l54.459" class="difflineplus">+                            const char* filter, char** attrs, int attrsonly,</span>
<a href="#l54.460"></a><span id="l54.460" class="difflineplus">+                            LDAPControl** serverctrls,</span>
<a href="#l54.461"></a><span id="l54.461" class="difflineplus">+                            LDAPControl** clientctrls, unsigned long* keyp) {</span>
<a href="#l54.462"></a><span id="l54.462">   int nRes, i, j, i_smallest;</span>
<a href="#l54.463"></a><span id="l54.463">   int len;</span>
<a href="#l54.464"></a><span id="l54.464">   int defport;</span>
<a href="#l54.465"></a><span id="l54.465">   char buf[50];</span>
<a href="#l54.466"></a><span id="l54.466">   char *tmp, *defhost, *binddn, *keystr, *tmpbase;</span>
<a href="#l54.467"></a><span id="l54.467"> </span>
<a href="#l54.468"></a><span id="l54.468">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || (keyp == NULL))</span>
<a href="#l54.469"></a><span id="l54.469">     return (LDAP_PARAM_ERROR);</span>
<a href="#l54.470"></a><span id="l54.470" class="difflineat">@@ -610,17 +610,17 @@ int ldap_memcache_createkey(LDAP *ld, co</span>
<a href="#l54.471"></a><span id="l54.471">     }</span>
<a href="#l54.472"></a><span id="l54.472">   } else {</span>
<a href="#l54.473"></a><span id="l54.473">     len += 1;</span>
<a href="#l54.474"></a><span id="l54.474">   }</span>
<a href="#l54.475"></a><span id="l54.475"> </span>
<a href="#l54.476"></a><span id="l54.476">   len += memcache_get_ctrls_len(serverctrls) +</span>
<a href="#l54.477"></a><span id="l54.477">          memcache_get_ctrls_len(clientctrls) + 1;</span>
<a href="#l54.478"></a><span id="l54.478"> </span>
<a href="#l54.479"></a><span id="l54.479" class="difflineminus">-  if ((keystr = (char *)NSLDAPI_CALLOC(len, sizeof(char))) == NULL) {</span>
<a href="#l54.480"></a><span id="l54.480" class="difflineplus">+  if ((keystr = (char*)NSLDAPI_CALLOC(len, sizeof(char))) == NULL) {</span>
<a href="#l54.481"></a><span id="l54.481">     NSLDAPI_FREE(defhost);</span>
<a href="#l54.482"></a><span id="l54.482">     return (LDAP_NO_MEMORY);</span>
<a href="#l54.483"></a><span id="l54.483">   }</span>
<a href="#l54.484"></a><span id="l54.484"> </span>
<a href="#l54.485"></a><span id="l54.485">   sprintf(keystr, &quot;%s\n%s\n%s\n%s\n%s\n&quot;, binddn, tmpbase,</span>
<a href="#l54.486"></a><span id="l54.486">           NSLDAPI_STR_NONNULL(defhost), NSLDAPI_STR_NONNULL(filter),</span>
<a href="#l54.487"></a><span id="l54.487">           NSLDAPI_STR_NONNULL(buf));</span>
<a href="#l54.488"></a><span id="l54.488"> </span>
<a href="#l54.489"></a><span id="l54.489" class="difflineat">@@ -647,19 +647,19 @@ int ldap_memcache_createkey(LDAP *ld, co</span>
<a href="#l54.490"></a><span id="l54.490">   NSLDAPI_FREE(tmpbase);</span>
<a href="#l54.491"></a><span id="l54.491"> </span>
<a href="#l54.492"></a><span id="l54.492">   return LDAP_SUCCESS;</span>
<a href="#l54.493"></a><span id="l54.493"> }</span>
<a href="#l54.494"></a><span id="l54.494"> </span>
<a href="#l54.495"></a><span id="l54.495"> /* Searches the cache for the right cached entries, and if found, attaches</span>
<a href="#l54.496"></a><span id="l54.496">    them to the given ldap handle.  This function relies on locking by the</span>
<a href="#l54.497"></a><span id="l54.497">    caller. */</span>
<a href="#l54.498"></a><span id="l54.498" class="difflineminus">-int ldap_memcache_result(LDAP *ld, int msgid, unsigned long key) {</span>
<a href="#l54.499"></a><span id="l54.499" class="difflineplus">+int ldap_memcache_result(LDAP* ld, int msgid, unsigned long key) {</span>
<a href="#l54.500"></a><span id="l54.500">   int nRes;</span>
<a href="#l54.501"></a><span id="l54.501" class="difflineminus">-  LDAPMessage *pMsg = NULL;</span>
<a href="#l54.502"></a><span id="l54.502" class="difflineplus">+  LDAPMessage* pMsg = NULL;</span>
<a href="#l54.503"></a><span id="l54.503"> </span>
<a href="#l54.504"></a><span id="l54.504">   LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l54.505"></a><span id="l54.505">             &quot;ldap_memcache_result( ld: 0x%p, msgid: %d, key: 0x%8.8lx)\n&quot;, ld,</span>
<a href="#l54.506"></a><span id="l54.506">             msgid, key);</span>
<a href="#l54.507"></a><span id="l54.507"> </span>
<a href="#l54.508"></a><span id="l54.508">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || (msgid &lt; 0)) {</span>
<a href="#l54.509"></a><span id="l54.509">     return (LDAP_PARAM_ERROR);</span>
<a href="#l54.510"></a><span id="l54.510">   }</span>
<a href="#l54.511"></a><span id="l54.511" class="difflineat">@@ -692,18 +692,18 @@ int ldap_memcache_result(LDAP *ld, int m</span>
<a href="#l54.512"></a><span id="l54.512">   LDAP_MEMCACHE_MUTEX_UNLOCK(ld-&gt;ld_memcache);</span>
<a href="#l54.513"></a><span id="l54.513">   LDAP_MUTEX_UNLOCK(ld, LDAP_MEMCACHE_LOCK);</span>
<a href="#l54.514"></a><span id="l54.514"> </span>
<a href="#l54.515"></a><span id="l54.515">   return nRes;</span>
<a href="#l54.516"></a><span id="l54.516"> }</span>
<a href="#l54.517"></a><span id="l54.517"> </span>
<a href="#l54.518"></a><span id="l54.518"> /* Creates a new header in the cache so that entries arriving from the</span>
<a href="#l54.519"></a><span id="l54.519">    directory server can later be cached under the header. */</span>
<a href="#l54.520"></a><span id="l54.520" class="difflineminus">-int ldap_memcache_new(LDAP *ld, int msgid, unsigned long key,</span>
<a href="#l54.521"></a><span id="l54.521" class="difflineminus">-                      const char *basedn) {</span>
<a href="#l54.522"></a><span id="l54.522" class="difflineplus">+int ldap_memcache_new(LDAP* ld, int msgid, unsigned long key,</span>
<a href="#l54.523"></a><span id="l54.523" class="difflineplus">+                      const char* basedn) {</span>
<a href="#l54.524"></a><span id="l54.524">   int nRes;</span>
<a href="#l54.525"></a><span id="l54.525"> </span>
<a href="#l54.526"></a><span id="l54.526">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l54.527"></a><span id="l54.527">     return (LDAP_PARAM_ERROR);</span>
<a href="#l54.528"></a><span id="l54.528">   }</span>
<a href="#l54.529"></a><span id="l54.529"> </span>
<a href="#l54.530"></a><span id="l54.530">   LDAP_MUTEX_LOCK(ld, LDAP_MEMCACHE_LOCK);</span>
<a href="#l54.531"></a><span id="l54.531"> </span>
<a href="#l54.532"></a><span id="l54.532" class="difflineat">@@ -718,17 +718,17 @@ int ldap_memcache_new(LDAP *ld, int msgi</span>
<a href="#l54.533"></a><span id="l54.533">   LDAP_MUTEX_UNLOCK(ld, LDAP_MEMCACHE_LOCK);</span>
<a href="#l54.534"></a><span id="l54.534"> </span>
<a href="#l54.535"></a><span id="l54.535">   return nRes;</span>
<a href="#l54.536"></a><span id="l54.536"> }</span>
<a href="#l54.537"></a><span id="l54.537"> </span>
<a href="#l54.538"></a><span id="l54.538"> /* Appends a chain of entries to an existing cache header.  Parameter &quot;bLast&quot;</span>
<a href="#l54.539"></a><span id="l54.539">    indicates whether there will be more entries arriving for the search in</span>
<a href="#l54.540"></a><span id="l54.540">    question. */</span>
<a href="#l54.541"></a><span id="l54.541" class="difflineminus">-int ldap_memcache_append(LDAP *ld, int msgid, int bLast, LDAPMessage *result) {</span>
<a href="#l54.542"></a><span id="l54.542" class="difflineplus">+int ldap_memcache_append(LDAP* ld, int msgid, int bLast, LDAPMessage* result) {</span>
<a href="#l54.543"></a><span id="l54.543">   int nRes = LDAP_SUCCESS;</span>
<a href="#l54.544"></a><span id="l54.544"> </span>
<a href="#l54.545"></a><span id="l54.545">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_memcache_append( ld: 0x%p, &quot;, ld, 0, 0);</span>
<a href="#l54.546"></a><span id="l54.546">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;msgid %d, bLast: %d, result: 0x%p)\n&quot;, msgid,</span>
<a href="#l54.547"></a><span id="l54.547">             bLast, result);</span>
<a href="#l54.548"></a><span id="l54.548"> </span>
<a href="#l54.549"></a><span id="l54.549">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || !result) {</span>
<a href="#l54.550"></a><span id="l54.550">     return (LDAP_PARAM_ERROR);</span>
<a href="#l54.551"></a><span id="l54.551" class="difflineat">@@ -754,17 +754,17 @@ int ldap_memcache_append(LDAP *ld, int m</span>
<a href="#l54.552"></a><span id="l54.552">   LDAP_MEMCACHE_MUTEX_UNLOCK(ld-&gt;ld_memcache);</span>
<a href="#l54.553"></a><span id="l54.553">   LDAP_MUTEX_UNLOCK(ld, LDAP_MEMCACHE_LOCK);</span>
<a href="#l54.554"></a><span id="l54.554"> </span>
<a href="#l54.555"></a><span id="l54.555">   return nRes;</span>
<a href="#l54.556"></a><span id="l54.556"> }</span>
<a href="#l54.557"></a><span id="l54.557"> </span>
<a href="#l54.558"></a><span id="l54.558"> /* Removes partially cached results for a search as a result of calling</span>
<a href="#l54.559"></a><span id="l54.559">    ldap_abandon() by the client. */</span>
<a href="#l54.560"></a><span id="l54.560" class="difflineminus">-int ldap_memcache_abandon(LDAP *ld, int msgid) {</span>
<a href="#l54.561"></a><span id="l54.561" class="difflineplus">+int ldap_memcache_abandon(LDAP* ld, int msgid) {</span>
<a href="#l54.562"></a><span id="l54.562">   int nRes;</span>
<a href="#l54.563"></a><span id="l54.563"> </span>
<a href="#l54.564"></a><span id="l54.564">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || (msgid &lt; 0)) {</span>
<a href="#l54.565"></a><span id="l54.565">     return (LDAP_PARAM_ERROR);</span>
<a href="#l54.566"></a><span id="l54.566">   }</span>
<a href="#l54.567"></a><span id="l54.567"> </span>
<a href="#l54.568"></a><span id="l54.568">   LDAP_MUTEX_LOCK(ld, LDAP_MEMCACHE_LOCK);</span>
<a href="#l54.569"></a><span id="l54.569"> </span>
<a href="#l54.570"></a><span id="l54.570" class="difflineat">@@ -785,17 +785,17 @@ int ldap_memcache_abandon(LDAP *ld, int </span>
<a href="#l54.571"></a><span id="l54.571"> </span>
<a href="#l54.572"></a><span id="l54.572"> /* Removes extraneous spaces in a basedn so that basedns differ by only those</span>
<a href="#l54.573"></a><span id="l54.573">    spaces will be treated as equal.  Extraneous spaces are those that</span>
<a href="#l54.574"></a><span id="l54.574">    precedes the basedn and those that follow a comma. */</span>
<a href="#l54.575"></a><span id="l54.575"> /*</span>
<a href="#l54.576"></a><span id="l54.576">  * XXXmcs: this is a bit too aggressive... we need to deal with the fact that</span>
<a href="#l54.577"></a><span id="l54.577">  * commas and spaces may be quoted, in which case it is wrong to remove them.</span>
<a href="#l54.578"></a><span id="l54.578">  */</span>
<a href="#l54.579"></a><span id="l54.579" class="difflineminus">-static void memcache_trim_basedn_spaces(char *basedn) {</span>
<a href="#l54.580"></a><span id="l54.580" class="difflineplus">+static void memcache_trim_basedn_spaces(char* basedn) {</span>
<a href="#l54.581"></a><span id="l54.581">   char *pRead, *pWrite;</span>
<a href="#l54.582"></a><span id="l54.582"> </span>
<a href="#l54.583"></a><span id="l54.583">   if (!basedn) return;</span>
<a href="#l54.584"></a><span id="l54.584"> </span>
<a href="#l54.585"></a><span id="l54.585">   for (pWrite = pRead = basedn; *pRead;) {</span>
<a href="#l54.586"></a><span id="l54.586">     for (; *pRead &amp;&amp; NSLDAPI_IS_SPACE(*pRead); pRead++) {</span>
<a href="#l54.587"></a><span id="l54.587">       ;</span>
<a href="#l54.588"></a><span id="l54.588">     }</span>
<a href="#l54.589"></a><span id="l54.589" class="difflineat">@@ -804,17 +804,17 @@ static void memcache_trim_basedn_spaces(</span>
<a href="#l54.590"></a><span id="l54.590">     }</span>
<a href="#l54.591"></a><span id="l54.591">     *(pWrite++) = (*pRead ? *(pRead++) : *pRead);</span>
<a href="#l54.592"></a><span id="l54.592">   }</span>
<a href="#l54.593"></a><span id="l54.593"> }</span>
<a href="#l54.594"></a><span id="l54.594"> </span>
<a href="#l54.595"></a><span id="l54.595"> /* Verifies whether the results of a search should be cached or not by</span>
<a href="#l54.596"></a><span id="l54.596">    checking if the search's basedn falls under any of the basedns for which</span>
<a href="#l54.597"></a><span id="l54.597">    the memcache is responsible. */</span>
<a href="#l54.598"></a><span id="l54.598" class="difflineminus">-static int memcache_validate_basedn(LDAPMemCache *cache, const char *basedn) {</span>
<a href="#l54.599"></a><span id="l54.599" class="difflineplus">+static int memcache_validate_basedn(LDAPMemCache* cache, const char* basedn) {</span>
<a href="#l54.600"></a><span id="l54.600">   int i;</span>
<a href="#l54.601"></a><span id="l54.601"> </span>
<a href="#l54.602"></a><span id="l54.602">   if (cache-&gt;ldmemc_basedns == NULL) {</span>
<a href="#l54.603"></a><span id="l54.603">     return (LDAP_SUCCESS);</span>
<a href="#l54.604"></a><span id="l54.604">   }</span>
<a href="#l54.605"></a><span id="l54.605"> </span>
<a href="#l54.606"></a><span id="l54.606"> #if 1</span>
<a href="#l54.607"></a><span id="l54.607">   if (basedn == NULL) {</span>
<a href="#l54.608"></a><span id="l54.608" class="difflineat">@@ -836,35 +836,35 @@ static int memcache_validate_basedn(LDAP</span>
<a href="#l54.609"></a><span id="l54.609">     }</span>
<a href="#l54.610"></a><span id="l54.610">   }</span>
<a href="#l54.611"></a><span id="l54.611"> </span>
<a href="#l54.612"></a><span id="l54.612">   return (LDAP_OPERATIONS_ERROR);</span>
<a href="#l54.613"></a><span id="l54.613"> }</span>
<a href="#l54.614"></a><span id="l54.614"> </span>
<a href="#l54.615"></a><span id="l54.615"> /* Calculates the length of the buffer needed to concatenate the contents of</span>
<a href="#l54.616"></a><span id="l54.616">    a ldap control. */</span>
<a href="#l54.617"></a><span id="l54.617" class="difflineminus">-static int memcache_get_ctrls_len(LDAPControl **ctrls) {</span>
<a href="#l54.618"></a><span id="l54.618" class="difflineplus">+static int memcache_get_ctrls_len(LDAPControl** ctrls) {</span>
<a href="#l54.619"></a><span id="l54.619">   int len = 0, i;</span>
<a href="#l54.620"></a><span id="l54.620"> </span>
<a href="#l54.621"></a><span id="l54.621">   if (ctrls) {</span>
<a href="#l54.622"></a><span id="l54.622">     for (i = 0; ctrls[i]; i++) {</span>
<a href="#l54.623"></a><span id="l54.623">       len += strlen(NSLDAPI_STR_NONNULL(ctrls[i]-&gt;ldctl_oid)) +</span>
<a href="#l54.624"></a><span id="l54.624">              (ctrls[i]-&gt;ldctl_value).bv_len + 4;</span>
<a href="#l54.625"></a><span id="l54.625">     }</span>
<a href="#l54.626"></a><span id="l54.626">   }</span>
<a href="#l54.627"></a><span id="l54.627"> </span>
<a href="#l54.628"></a><span id="l54.628">   return len;</span>
<a href="#l54.629"></a><span id="l54.629"> }</span>
<a href="#l54.630"></a><span id="l54.630"> </span>
<a href="#l54.631"></a><span id="l54.631"> /* Contenates the contents of client and server controls to a buffer. */</span>
<a href="#l54.632"></a><span id="l54.632" class="difflineminus">-static void memcache_append_ctrls(char *buf, LDAPControl **serverCtrls,</span>
<a href="#l54.633"></a><span id="l54.633" class="difflineminus">-                                  LDAPControl **clientCtrls) {</span>
<a href="#l54.634"></a><span id="l54.634" class="difflineplus">+static void memcache_append_ctrls(char* buf, LDAPControl** serverCtrls,</span>
<a href="#l54.635"></a><span id="l54.635" class="difflineplus">+                                  LDAPControl** clientCtrls) {</span>
<a href="#l54.636"></a><span id="l54.636">   int i, j;</span>
<a href="#l54.637"></a><span id="l54.637" class="difflineminus">-  char *pCh = buf + strlen(buf);</span>
<a href="#l54.638"></a><span id="l54.638" class="difflineminus">-  LDAPControl **ctrls;</span>
<a href="#l54.639"></a><span id="l54.639" class="difflineplus">+  char* pCh = buf + strlen(buf);</span>
<a href="#l54.640"></a><span id="l54.640" class="difflineplus">+  LDAPControl** ctrls;</span>
<a href="#l54.641"></a><span id="l54.641"> </span>
<a href="#l54.642"></a><span id="l54.642">   for (j = 0; j &lt; 2; j++) {</span>
<a href="#l54.643"></a><span id="l54.643">     if ((ctrls = (j ? clientCtrls : serverCtrls)) == NULL) continue;</span>
<a href="#l54.644"></a><span id="l54.644"> </span>
<a href="#l54.645"></a><span id="l54.645">     for (i = 0; ctrls[i]; i++) {</span>
<a href="#l54.646"></a><span id="l54.646">       sprintf(pCh, &quot;%s\n&quot;, NSLDAPI_STR_NONNULL(ctrls[i]-&gt;ldctl_oid));</span>
<a href="#l54.647"></a><span id="l54.647">       pCh += strlen(NSLDAPI_STR_NONNULL(ctrls[i]-&gt;ldctl_oid)) + 1;</span>
<a href="#l54.648"></a><span id="l54.648">       if ((ctrls[i]-&gt;ldctl_value).bv_len &gt; 0) {</span>
<a href="#l54.649"></a><span id="l54.649" class="difflineat">@@ -875,17 +875,17 @@ static void memcache_append_ctrls(char *</span>
<a href="#l54.650"></a><span id="l54.650">       sprintf(pCh, &quot;\n%i\n&quot;, (ctrls[i]-&gt;ldctl_iscritical ? 1 : 0));</span>
<a href="#l54.651"></a><span id="l54.651">       pCh += 3;</span>
<a href="#l54.652"></a><span id="l54.652">     }</span>
<a href="#l54.653"></a><span id="l54.653">   }</span>
<a href="#l54.654"></a><span id="l54.654"> }</span>
<a href="#l54.655"></a><span id="l54.655"> </span>
<a href="#l54.656"></a><span id="l54.656"> /* Increases or decreases the size (in bytes) the given memcache currently</span>
<a href="#l54.657"></a><span id="l54.657">    uses.  If the size goes over the limit, the function returns an error. */</span>
<a href="#l54.658"></a><span id="l54.658" class="difflineminus">-static int memcache_adj_size(LDAPMemCache *cache, unsigned long size,</span>
<a href="#l54.659"></a><span id="l54.659" class="difflineplus">+static int memcache_adj_size(LDAPMemCache* cache, unsigned long size,</span>
<a href="#l54.660"></a><span id="l54.660">                              int usageFlags, int bAdd) {</span>
<a href="#l54.661"></a><span id="l54.661">   LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l54.662"></a><span id="l54.662">             &quot;memcache_adj_size: attempting to %s %ld %s bytes...\n&quot;,</span>
<a href="#l54.663"></a><span id="l54.663">             bAdd ? &quot;add&quot; : &quot;remove&quot;, size,</span>
<a href="#l54.664"></a><span id="l54.664">             (usageFlags &amp; MEMCACHE_SIZE_ENTRIES) ? &quot;entry&quot; : &quot;non-entry&quot;);</span>
<a href="#l54.665"></a><span id="l54.665"> </span>
<a href="#l54.666"></a><span id="l54.666">   if (bAdd) {</span>
<a href="#l54.667"></a><span id="l54.667">     cache-&gt;ldmemc_size_used += size;</span>
<a href="#l54.668"></a><span id="l54.668" class="difflineat">@@ -930,113 +930,113 @@ static int memcache_adj_size(LDAPMemCach</span>
<a href="#l54.669"></a><span id="l54.669">   }</span>
<a href="#l54.670"></a><span id="l54.670"> #endif /* LDAP_DEBUG */</span>
<a href="#l54.671"></a><span id="l54.671"> </span>
<a href="#l54.672"></a><span id="l54.672">   return (LDAP_SUCCESS);</span>
<a href="#l54.673"></a><span id="l54.673"> }</span>
<a href="#l54.674"></a><span id="l54.674"> </span>
<a href="#l54.675"></a><span id="l54.675"> /* Searches the cache for results for a particular search identified by</span>
<a href="#l54.676"></a><span id="l54.676">    parameter &quot;key&quot;, which was generated ldap_memcache_createkey(). */</span>
<a href="#l54.677"></a><span id="l54.677" class="difflineminus">-static int memcache_search(LDAP *ld, unsigned long key, LDAPMessage **ppRes) {</span>
<a href="#l54.678"></a><span id="l54.678" class="difflineplus">+static int memcache_search(LDAP* ld, unsigned long key, LDAPMessage** ppRes) {</span>
<a href="#l54.679"></a><span id="l54.679">   int nRes;</span>
<a href="#l54.680"></a><span id="l54.680" class="difflineminus">-  ldapmemcacheRes *pRes;</span>
<a href="#l54.681"></a><span id="l54.681" class="difflineplus">+  ldapmemcacheRes* pRes;</span>
<a href="#l54.682"></a><span id="l54.682"> </span>
<a href="#l54.683"></a><span id="l54.683">   *ppRes = NULL;</span>
<a href="#l54.684"></a><span id="l54.684"> </span>
<a href="#l54.685"></a><span id="l54.685">   if (!memcache_exist(ld)) return LDAP_LOCAL_ERROR;</span>
<a href="#l54.686"></a><span id="l54.686"> </span>
<a href="#l54.687"></a><span id="l54.687" class="difflineminus">-  nRes = memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_FIND, (void *)&amp;key,</span>
<a href="#l54.688"></a><span id="l54.688" class="difflineminus">-                         (void *)(&amp;pRes), NULL);</span>
<a href="#l54.689"></a><span id="l54.689" class="difflineplus">+  nRes = memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_FIND, (void*)&amp;key,</span>
<a href="#l54.690"></a><span id="l54.690" class="difflineplus">+                         (void*)(&amp;pRes), NULL);</span>
<a href="#l54.691"></a><span id="l54.691"> </span>
<a href="#l54.692"></a><span id="l54.692">   if (nRes != LDAP_SUCCESS) return nRes;</span>
<a href="#l54.693"></a><span id="l54.693"> </span>
<a href="#l54.694"></a><span id="l54.694">   *ppRes = pRes-&gt;ldmemcr_resHead;</span>
<a href="#l54.695"></a><span id="l54.695">   assert((pRes-&gt;ldmemcr_req_id).ldmemcrid_msgid == -1);</span>
<a href="#l54.696"></a><span id="l54.696"> </span>
<a href="#l54.697"></a><span id="l54.697">   return (LDAP_SUCCESS);</span>
<a href="#l54.698"></a><span id="l54.698"> }</span>
<a href="#l54.699"></a><span id="l54.699"> </span>
<a href="#l54.700"></a><span id="l54.700"> /* Adds a new header into the cache as a place holder for entries</span>
<a href="#l54.701"></a><span id="l54.701">    arriving later. */</span>
<a href="#l54.702"></a><span id="l54.702" class="difflineminus">-static int memcache_add(LDAP *ld, unsigned long key, int msgid,</span>
<a href="#l54.703"></a><span id="l54.703" class="difflineminus">-                        const char *basedn) {</span>
<a href="#l54.704"></a><span id="l54.704" class="difflineplus">+static int memcache_add(LDAP* ld, unsigned long key, int msgid,</span>
<a href="#l54.705"></a><span id="l54.705" class="difflineplus">+                        const char* basedn) {</span>
<a href="#l54.706"></a><span id="l54.706">   ldapmemcacheReqId reqid;</span>
<a href="#l54.707"></a><span id="l54.707"> </span>
<a href="#l54.708"></a><span id="l54.708">   if (!memcache_exist(ld)) return LDAP_LOCAL_ERROR;</span>
<a href="#l54.709"></a><span id="l54.709"> </span>
<a href="#l54.710"></a><span id="l54.710">   reqid.ldmemcrid_msgid = msgid;</span>
<a href="#l54.711"></a><span id="l54.711">   reqid.ldmemcrid_ld = ld;</span>
<a href="#l54.712"></a><span id="l54.712"> </span>
<a href="#l54.713"></a><span id="l54.713" class="difflineminus">-  return memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_ADD, (void *)&amp;key,</span>
<a href="#l54.714"></a><span id="l54.714" class="difflineminus">-                         (void *)&amp;reqid, (void *)basedn);</span>
<a href="#l54.715"></a><span id="l54.715" class="difflineplus">+  return memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_ADD, (void*)&amp;key,</span>
<a href="#l54.716"></a><span id="l54.716" class="difflineplus">+                         (void*)&amp;reqid, (void*)basedn);</span>
<a href="#l54.717"></a><span id="l54.717"> }</span>
<a href="#l54.718"></a><span id="l54.718"> </span>
<a href="#l54.719"></a><span id="l54.719"> /* Appends search entries arriving from the dir server to the cache. */</span>
<a href="#l54.720"></a><span id="l54.720" class="difflineminus">-static int memcache_append(LDAP *ld, int msgid, LDAPMessage *pRes) {</span>
<a href="#l54.721"></a><span id="l54.721" class="difflineplus">+static int memcache_append(LDAP* ld, int msgid, LDAPMessage* pRes) {</span>
<a href="#l54.722"></a><span id="l54.722">   ldapmemcacheReqId reqid;</span>
<a href="#l54.723"></a><span id="l54.723"> </span>
<a href="#l54.724"></a><span id="l54.724">   if (!memcache_exist(ld)) return LDAP_LOCAL_ERROR;</span>
<a href="#l54.725"></a><span id="l54.725"> </span>
<a href="#l54.726"></a><span id="l54.726">   reqid.ldmemcrid_msgid = msgid;</span>
<a href="#l54.727"></a><span id="l54.727">   reqid.ldmemcrid_ld = ld;</span>
<a href="#l54.728"></a><span id="l54.728"> </span>
<a href="#l54.729"></a><span id="l54.729" class="difflineminus">-  return memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_APPEND,</span>
<a href="#l54.730"></a><span id="l54.730" class="difflineminus">-                         (void *)&amp;reqid, (void *)pRes, NULL);</span>
<a href="#l54.731"></a><span id="l54.731" class="difflineplus">+  return memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_APPEND, (void*)&amp;reqid,</span>
<a href="#l54.732"></a><span id="l54.732" class="difflineplus">+                         (void*)pRes, NULL);</span>
<a href="#l54.733"></a><span id="l54.733"> }</span>
<a href="#l54.734"></a><span id="l54.734"> </span>
<a href="#l54.735"></a><span id="l54.735"> /* Same as memcache_append(), but the entries being appended are the</span>
<a href="#l54.736"></a><span id="l54.736">    last from the dir server.  Once all entries for a search have arrived,</span>
<a href="#l54.737"></a><span id="l54.737">    the entries are moved from secondary to primary cache, and a time</span>
<a href="#l54.738"></a><span id="l54.738">    stamp is given to the entries. */</span>
<a href="#l54.739"></a><span id="l54.739" class="difflineminus">-static int memcache_append_last(LDAP *ld, int msgid, LDAPMessage *pRes) {</span>
<a href="#l54.740"></a><span id="l54.740" class="difflineplus">+static int memcache_append_last(LDAP* ld, int msgid, LDAPMessage* pRes) {</span>
<a href="#l54.741"></a><span id="l54.741">   ldapmemcacheReqId reqid;</span>
<a href="#l54.742"></a><span id="l54.742"> </span>
<a href="#l54.743"></a><span id="l54.743">   if (!memcache_exist(ld)) return LDAP_LOCAL_ERROR;</span>
<a href="#l54.744"></a><span id="l54.744"> </span>
<a href="#l54.745"></a><span id="l54.745">   reqid.ldmemcrid_msgid = msgid;</span>
<a href="#l54.746"></a><span id="l54.746">   reqid.ldmemcrid_ld = ld;</span>
<a href="#l54.747"></a><span id="l54.747"> </span>
<a href="#l54.748"></a><span id="l54.748">   return memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_APPEND_LAST,</span>
<a href="#l54.749"></a><span id="l54.749" class="difflineminus">-                         (void *)&amp;reqid, (void *)pRes, NULL);</span>
<a href="#l54.750"></a><span id="l54.750" class="difflineplus">+                         (void*)&amp;reqid, (void*)pRes, NULL);</span>
<a href="#l54.751"></a><span id="l54.751"> }</span>
<a href="#l54.752"></a><span id="l54.752"> </span>
<a href="#l54.753"></a><span id="l54.753"> /* Removes entries from the temporary cache. */</span>
<a href="#l54.754"></a><span id="l54.754" class="difflineminus">-static int memcache_remove(LDAP *ld, int msgid) {</span>
<a href="#l54.755"></a><span id="l54.755" class="difflineplus">+static int memcache_remove(LDAP* ld, int msgid) {</span>
<a href="#l54.756"></a><span id="l54.756">   ldapmemcacheReqId reqid;</span>
<a href="#l54.757"></a><span id="l54.757"> </span>
<a href="#l54.758"></a><span id="l54.758">   if (!memcache_exist(ld)) return LDAP_LOCAL_ERROR;</span>
<a href="#l54.759"></a><span id="l54.759"> </span>
<a href="#l54.760"></a><span id="l54.760">   reqid.ldmemcrid_msgid = msgid;</span>
<a href="#l54.761"></a><span id="l54.761">   reqid.ldmemcrid_ld = ld;</span>
<a href="#l54.762"></a><span id="l54.762"> </span>
<a href="#l54.763"></a><span id="l54.763" class="difflineminus">-  return memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_DELETE,</span>
<a href="#l54.764"></a><span id="l54.764" class="difflineminus">-                         (void *)&amp;reqid, NULL, NULL);</span>
<a href="#l54.765"></a><span id="l54.765" class="difflineplus">+  return memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_DELETE, (void*)&amp;reqid,</span>
<a href="#l54.766"></a><span id="l54.766" class="difflineplus">+                         NULL, NULL);</span>
<a href="#l54.767"></a><span id="l54.767"> }</span>
<a href="#l54.768"></a><span id="l54.768"> </span>
<a href="#l54.769"></a><span id="l54.769"> #if 0  /* this function is not used */</span>
<a href="#l54.770"></a><span id="l54.770"> /* Wipes out everything in the temporary cache directory. */</span>
<a href="#l54.771"></a><span id="l54.771"> static int</span>
<a href="#l54.772"></a><span id="l54.772"> memcache_remove_all(LDAP *ld)</span>
<a href="#l54.773"></a><span id="l54.773"> {</span>
<a href="#l54.774"></a><span id="l54.774">     if (!memcache_exist(ld))</span>
<a href="#l54.775"></a><span id="l54.775">         return LDAP_LOCAL_ERROR;</span>
<a href="#l54.776"></a><span id="l54.776"> </span>
<a href="#l54.777"></a><span id="l54.777">     return memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_DELETE_ALL,</span>
<a href="#l54.778"></a><span id="l54.778">                            NULL, NULL, NULL);</span>
<a href="#l54.779"></a><span id="l54.779"> }</span>
<a href="#l54.780"></a><span id="l54.780"> #endif /* 0 */</span>
<a href="#l54.781"></a><span id="l54.781"> </span>
<a href="#l54.782"></a><span id="l54.782"> /* Returns TRUE or FALSE */</span>
<a href="#l54.783"></a><span id="l54.783" class="difflineminus">-static int memcache_exist(LDAP *ld) { return (ld-&gt;ld_memcache != NULL); }</span>
<a href="#l54.784"></a><span id="l54.784" class="difflineplus">+static int memcache_exist(LDAP* ld) { return (ld-&gt;ld_memcache != NULL); }</span>
<a href="#l54.785"></a><span id="l54.785"> </span>
<a href="#l54.786"></a><span id="l54.786"> /* Attaches cached entries to an ldap handle. */</span>
<a href="#l54.787"></a><span id="l54.787" class="difflineminus">-static int memcache_add_to_ld(LDAP *ld, int msgid, LDAPMessage *pMsg) {</span>
<a href="#l54.788"></a><span id="l54.788" class="difflineplus">+static int memcache_add_to_ld(LDAP* ld, int msgid, LDAPMessage* pMsg) {</span>
<a href="#l54.789"></a><span id="l54.789">   int nRes = LDAP_SUCCESS;</span>
<a href="#l54.790"></a><span id="l54.790" class="difflineminus">-  LDAPMessage **r;</span>
<a href="#l54.791"></a><span id="l54.791" class="difflineminus">-  LDAPMessage *pCopy;</span>
<a href="#l54.792"></a><span id="l54.792" class="difflineplus">+  LDAPMessage** r;</span>
<a href="#l54.793"></a><span id="l54.793" class="difflineplus">+  LDAPMessage* pCopy;</span>
<a href="#l54.794"></a><span id="l54.794"> </span>
<a href="#l54.795"></a><span id="l54.795">   nRes = memcache_dup_message(pMsg, msgid, 1, &amp;pCopy, NULL);</span>
<a href="#l54.796"></a><span id="l54.796">   if (nRes != LDAP_SUCCESS) return nRes;</span>
<a href="#l54.797"></a><span id="l54.797"> </span>
<a href="#l54.798"></a><span id="l54.798">   LDAP_MUTEX_LOCK(ld, LDAP_RESP_LOCK);</span>
<a href="#l54.799"></a><span id="l54.799"> </span>
<a href="#l54.800"></a><span id="l54.800">   for (r = &amp;(ld-&gt;ld_responses); *r; r = &amp;((*r)-&gt;lm_next))</span>
<a href="#l54.801"></a><span id="l54.801">     if ((*r)-&gt;lm_msgid == msgid) break;</span>
<a href="#l54.802"></a><span id="l54.802" class="difflineat">@@ -1049,20 +1049,20 @@ static int memcache_add_to_ld(LDAP *ld, </span>
<a href="#l54.803"></a><span id="l54.803">   *r = pCopy;</span>
<a href="#l54.804"></a><span id="l54.804"> </span>
<a href="#l54.805"></a><span id="l54.805">   LDAP_MUTEX_UNLOCK(ld, LDAP_RESP_LOCK);</span>
<a href="#l54.806"></a><span id="l54.806"> </span>
<a href="#l54.807"></a><span id="l54.807">   return nRes;</span>
<a href="#l54.808"></a><span id="l54.808"> }</span>
<a href="#l54.809"></a><span id="l54.809"> </span>
<a href="#l54.810"></a><span id="l54.810"> /* Check if main_dn is included in {dn, scope} */</span>
<a href="#l54.811"></a><span id="l54.811" class="difflineminus">-static int memcache_compare_dn(const char *main_dn, const char *dn, int scope) {</span>
<a href="#l54.812"></a><span id="l54.812" class="difflineplus">+static int memcache_compare_dn(const char* main_dn, const char* dn, int scope) {</span>
<a href="#l54.813"></a><span id="l54.813">   int nRes;</span>
<a href="#l54.814"></a><span id="l54.814" class="difflineminus">-  char **components = NULL;</span>
<a href="#l54.815"></a><span id="l54.815" class="difflineminus">-  char **main_components = NULL;</span>
<a href="#l54.816"></a><span id="l54.816" class="difflineplus">+  char** components = NULL;</span>
<a href="#l54.817"></a><span id="l54.817" class="difflineplus">+  char** main_components = NULL;</span>
<a href="#l54.818"></a><span id="l54.818"> </span>
<a href="#l54.819"></a><span id="l54.819">   components = ldap_explode_dn(dn, 0);</span>
<a href="#l54.820"></a><span id="l54.820">   main_components = ldap_explode_dn(main_dn, 0);</span>
<a href="#l54.821"></a><span id="l54.821"> </span>
<a href="#l54.822"></a><span id="l54.822">   if (!components || !main_components) {</span>
<a href="#l54.823"></a><span id="l54.823">     nRes = LDAP_COMPARE_TRUE;</span>
<a href="#l54.824"></a><span id="l54.824">   } else {</span>
<a href="#l54.825"></a><span id="l54.825">     int i, main_i;</span>
<a href="#l54.826"></a><span id="l54.826" class="difflineat">@@ -1099,30 +1099,30 @@ static int memcache_compare_dn(const cha</span>
<a href="#l54.827"></a><span id="l54.827"> </span>
<a href="#l54.828"></a><span id="l54.828">   if (main_components) ldap_value_free(main_components);</span>
<a href="#l54.829"></a><span id="l54.829"> </span>
<a href="#l54.830"></a><span id="l54.830">   return nRes;</span>
<a href="#l54.831"></a><span id="l54.831"> }</span>
<a href="#l54.832"></a><span id="l54.832"> </span>
<a href="#l54.833"></a><span id="l54.833"> /* Dup a complete separate copy of a berelement, including the buffers</span>
<a href="#l54.834"></a><span id="l54.834">    the berelement points to. */</span>
<a href="#l54.835"></a><span id="l54.835" class="difflineminus">-static BerElement *memcache_ber_dup(BerElement *pBer, unsigned long *pSize) {</span>
<a href="#l54.836"></a><span id="l54.836" class="difflineminus">-  BerElement *p = ber_dup(pBer);</span>
<a href="#l54.837"></a><span id="l54.837" class="difflineplus">+static BerElement* memcache_ber_dup(BerElement* pBer, unsigned long* pSize) {</span>
<a href="#l54.838"></a><span id="l54.838" class="difflineplus">+  BerElement* p = ber_dup(pBer);</span>
<a href="#l54.839"></a><span id="l54.839"> </span>
<a href="#l54.840"></a><span id="l54.840">   *pSize = 0;</span>
<a href="#l54.841"></a><span id="l54.841"> </span>
<a href="#l54.842"></a><span id="l54.842">   if (p) {</span>
<a href="#l54.843"></a><span id="l54.843">     *pSize += sizeof(BerElement) + EXTRA_SIZE;</span>
<a href="#l54.844"></a><span id="l54.844"> </span>
<a href="#l54.845"></a><span id="l54.845">     if (p-&gt;ber_len &lt;= EXTRA_SIZE) {</span>
<a href="#l54.846"></a><span id="l54.846">       p-&gt;ber_flags |= LBER_FLAG_NO_FREE_BUFFER;</span>
<a href="#l54.847"></a><span id="l54.847" class="difflineminus">-      p-&gt;ber_buf = (char *)p + sizeof(BerElement);</span>
<a href="#l54.848"></a><span id="l54.848" class="difflineplus">+      p-&gt;ber_buf = (char*)p + sizeof(BerElement);</span>
<a href="#l54.849"></a><span id="l54.849">     } else {</span>
<a href="#l54.850"></a><span id="l54.850">       p-&gt;ber_flags &amp;= ~LBER_FLAG_NO_FREE_BUFFER;</span>
<a href="#l54.851"></a><span id="l54.851" class="difflineminus">-      p-&gt;ber_buf = (char *)NSLDAPI_CALLOC(1, p-&gt;ber_len);</span>
<a href="#l54.852"></a><span id="l54.852" class="difflineplus">+      p-&gt;ber_buf = (char*)NSLDAPI_CALLOC(1, p-&gt;ber_len);</span>
<a href="#l54.853"></a><span id="l54.853">       *pSize += (p-&gt;ber_buf ? p-&gt;ber_len : 0);</span>
<a href="#l54.854"></a><span id="l54.854">     }</span>
<a href="#l54.855"></a><span id="l54.855"> </span>
<a href="#l54.856"></a><span id="l54.856">     if (p-&gt;ber_buf) {</span>
<a href="#l54.857"></a><span id="l54.857">       p-&gt;ber_ptr = p-&gt;ber_buf + (pBer-&gt;ber_ptr - pBer-&gt;ber_buf);</span>
<a href="#l54.858"></a><span id="l54.858">       p-&gt;ber_end = p-&gt;ber_buf + p-&gt;ber_len;</span>
<a href="#l54.859"></a><span id="l54.859">       memcpy(p-&gt;ber_buf, pBer-&gt;ber_buf, p-&gt;ber_len);</span>
<a href="#l54.860"></a><span id="l54.860">     } else {</span>
<a href="#l54.861"></a><span id="l54.861" class="difflineat">@@ -1131,31 +1131,31 @@ static BerElement *memcache_ber_dup(BerE</span>
<a href="#l54.862"></a><span id="l54.862">       *pSize = 0;</span>
<a href="#l54.863"></a><span id="l54.863">     }</span>
<a href="#l54.864"></a><span id="l54.864">   }</span>
<a href="#l54.865"></a><span id="l54.865"> </span>
<a href="#l54.866"></a><span id="l54.866">   return p;</span>
<a href="#l54.867"></a><span id="l54.867"> }</span>
<a href="#l54.868"></a><span id="l54.868"> </span>
<a href="#l54.869"></a><span id="l54.869"> /* Dup a entry or a chain of entries. */</span>
<a href="#l54.870"></a><span id="l54.870" class="difflineminus">-static int memcache_dup_message(LDAPMessage *res, int msgid, int fromcache,</span>
<a href="#l54.871"></a><span id="l54.871" class="difflineminus">-                                LDAPMessage **ppResCopy, unsigned long *pSize) {</span>
<a href="#l54.872"></a><span id="l54.872" class="difflineplus">+static int memcache_dup_message(LDAPMessage* res, int msgid, int fromcache,</span>
<a href="#l54.873"></a><span id="l54.873" class="difflineplus">+                                LDAPMessage** ppResCopy, unsigned long* pSize) {</span>
<a href="#l54.874"></a><span id="l54.874">   int nRes = LDAP_SUCCESS;</span>
<a href="#l54.875"></a><span id="l54.875">   unsigned long ber_size;</span>
<a href="#l54.876"></a><span id="l54.876" class="difflineminus">-  LDAPMessage *pCur;</span>
<a href="#l54.877"></a><span id="l54.877" class="difflineminus">-  LDAPMessage **ppCurNew;</span>
<a href="#l54.878"></a><span id="l54.878" class="difflineplus">+  LDAPMessage* pCur;</span>
<a href="#l54.879"></a><span id="l54.879" class="difflineplus">+  LDAPMessage** ppCurNew;</span>
<a href="#l54.880"></a><span id="l54.880"> </span>
<a href="#l54.881"></a><span id="l54.881">   *ppResCopy = NULL;</span>
<a href="#l54.882"></a><span id="l54.882"> </span>
<a href="#l54.883"></a><span id="l54.883">   if (pSize) *pSize = 0;</span>
<a href="#l54.884"></a><span id="l54.884"> </span>
<a href="#l54.885"></a><span id="l54.885">   /* Make a copy of res */</span>
<a href="#l54.886"></a><span id="l54.886">   for (pCur = res, ppCurNew = ppResCopy; pCur;</span>
<a href="#l54.887"></a><span id="l54.887">        pCur = pCur-&gt;lm_chain, ppCurNew = &amp;((*ppCurNew)-&gt;lm_chain)) {</span>
<a href="#l54.888"></a><span id="l54.888" class="difflineminus">-    if ((*ppCurNew = (LDAPMessage *)NSLDAPI_CALLOC(1, sizeof(LDAPMessage))) ==</span>
<a href="#l54.889"></a><span id="l54.889" class="difflineplus">+    if ((*ppCurNew = (LDAPMessage*)NSLDAPI_CALLOC(1, sizeof(LDAPMessage))) ==</span>
<a href="#l54.890"></a><span id="l54.890">         NULL) {</span>
<a href="#l54.891"></a><span id="l54.891">       nRes = LDAP_NO_MEMORY;</span>
<a href="#l54.892"></a><span id="l54.892">       break;</span>
<a href="#l54.893"></a><span id="l54.893">     }</span>
<a href="#l54.894"></a><span id="l54.894"> </span>
<a href="#l54.895"></a><span id="l54.895">     memcpy(*ppCurNew, pCur, sizeof(LDAPMessage));</span>
<a href="#l54.896"></a><span id="l54.896">     (*ppCurNew)-&gt;lm_next = NULL;</span>
<a href="#l54.897"></a><span id="l54.897">     (*ppCurNew)-&gt;lm_ber = memcache_ber_dup(pCur-&gt;lm_ber, &amp;ber_size);</span>
<a href="#l54.898"></a><span id="l54.898" class="difflineat">@@ -1172,17 +1172,17 @@ static int memcache_dup_message(LDAPMess</span>
<a href="#l54.899"></a><span id="l54.899">   }</span>
<a href="#l54.900"></a><span id="l54.900"> </span>
<a href="#l54.901"></a><span id="l54.901">   return nRes;</span>
<a href="#l54.902"></a><span id="l54.902"> }</span>
<a href="#l54.903"></a><span id="l54.903"> </span>
<a href="#l54.904"></a><span id="l54.904"> /************************* Cache Functions ***********************/</span>
<a href="#l54.905"></a><span id="l54.905"> </span>
<a href="#l54.906"></a><span id="l54.906"> /* Frees a cache header. */</span>
<a href="#l54.907"></a><span id="l54.907" class="difflineminus">-static int memcache_free_entry(LDAPMemCache *cache, ldapmemcacheRes *pRes) {</span>
<a href="#l54.908"></a><span id="l54.908" class="difflineplus">+static int memcache_free_entry(LDAPMemCache* cache, ldapmemcacheRes* pRes) {</span>
<a href="#l54.909"></a><span id="l54.909">   if (pRes) {</span>
<a href="#l54.910"></a><span id="l54.910">     unsigned long size = sizeof(ldapmemcacheRes);</span>
<a href="#l54.911"></a><span id="l54.911"> </span>
<a href="#l54.912"></a><span id="l54.912">     if (pRes-&gt;ldmemcr_basedn) {</span>
<a href="#l54.913"></a><span id="l54.913">       size += strlen(pRes-&gt;ldmemcr_basedn) + 1;</span>
<a href="#l54.914"></a><span id="l54.914">       NSLDAPI_FREE(pRes-&gt;ldmemcr_basedn);</span>
<a href="#l54.915"></a><span id="l54.915">     }</span>
<a href="#l54.916"></a><span id="l54.916"> </span>
<a href="#l54.917"></a><span id="l54.917" class="difflineat">@@ -1195,17 +1195,17 @@ static int memcache_free_entry(LDAPMemCa</span>
<a href="#l54.918"></a><span id="l54.918"> </span>
<a href="#l54.919"></a><span id="l54.919">     memcache_adj_size(cache, size, MEMCACHE_SIZE_ENTRIES, MEMCACHE_SIZE_DEDUCT);</span>
<a href="#l54.920"></a><span id="l54.920">   }</span>
<a href="#l54.921"></a><span id="l54.921"> </span>
<a href="#l54.922"></a><span id="l54.922">   return (LDAP_SUCCESS);</span>
<a href="#l54.923"></a><span id="l54.923"> }</span>
<a href="#l54.924"></a><span id="l54.924"> </span>
<a href="#l54.925"></a><span id="l54.925"> /* Detaches a cache header from the list of headers. */</span>
<a href="#l54.926"></a><span id="l54.926" class="difflineminus">-static int memcache_free_from_list(LDAPMemCache *cache, ldapmemcacheRes *pRes,</span>
<a href="#l54.927"></a><span id="l54.927" class="difflineplus">+static int memcache_free_from_list(LDAPMemCache* cache, ldapmemcacheRes* pRes,</span>
<a href="#l54.928"></a><span id="l54.928">                                    int index) {</span>
<a href="#l54.929"></a><span id="l54.929">   if (pRes-&gt;ldmemcr_prev[index])</span>
<a href="#l54.930"></a><span id="l54.930">     pRes-&gt;ldmemcr_prev[index]-&gt;ldmemcr_next[index] = pRes-&gt;ldmemcr_next[index];</span>
<a href="#l54.931"></a><span id="l54.931"> </span>
<a href="#l54.932"></a><span id="l54.932">   if (pRes-&gt;ldmemcr_next[index])</span>
<a href="#l54.933"></a><span id="l54.933">     pRes-&gt;ldmemcr_next[index]-&gt;ldmemcr_prev[index] = pRes-&gt;ldmemcr_prev[index];</span>
<a href="#l54.934"></a><span id="l54.934"> </span>
<a href="#l54.935"></a><span id="l54.935">   if (cache-&gt;ldmemc_resHead[index] == pRes)</span>
<a href="#l54.936"></a><span id="l54.936" class="difflineat">@@ -1216,32 +1216,32 @@ static int memcache_free_from_list(LDAPM</span>
<a href="#l54.937"></a><span id="l54.937"> </span>
<a href="#l54.938"></a><span id="l54.938">   pRes-&gt;ldmemcr_prev[index] = NULL;</span>
<a href="#l54.939"></a><span id="l54.939">   pRes-&gt;ldmemcr_next[index] = NULL;</span>
<a href="#l54.940"></a><span id="l54.940"> </span>
<a href="#l54.941"></a><span id="l54.941">   return (LDAP_SUCCESS);</span>
<a href="#l54.942"></a><span id="l54.942"> }</span>
<a href="#l54.943"></a><span id="l54.943"> </span>
<a href="#l54.944"></a><span id="l54.944"> /* Inserts a new cache header to a list of headers. */</span>
<a href="#l54.945"></a><span id="l54.945" class="difflineminus">-static int memcache_add_to_list(LDAPMemCache *cache, ldapmemcacheRes *pRes,</span>
<a href="#l54.946"></a><span id="l54.946" class="difflineplus">+static int memcache_add_to_list(LDAPMemCache* cache, ldapmemcacheRes* pRes,</span>
<a href="#l54.947"></a><span id="l54.947">                                 int index) {</span>
<a href="#l54.948"></a><span id="l54.948">   if (cache-&gt;ldmemc_resHead[index])</span>
<a href="#l54.949"></a><span id="l54.949">     cache-&gt;ldmemc_resHead[index]-&gt;ldmemcr_prev[index] = pRes;</span>
<a href="#l54.950"></a><span id="l54.950">   else</span>
<a href="#l54.951"></a><span id="l54.951">     cache-&gt;ldmemc_resTail[index] = pRes;</span>
<a href="#l54.952"></a><span id="l54.952"> </span>
<a href="#l54.953"></a><span id="l54.953">   pRes-&gt;ldmemcr_prev[index] = NULL;</span>
<a href="#l54.954"></a><span id="l54.954">   pRes-&gt;ldmemcr_next[index] = cache-&gt;ldmemc_resHead[index];</span>
<a href="#l54.955"></a><span id="l54.955">   cache-&gt;ldmemc_resHead[index] = pRes;</span>
<a href="#l54.956"></a><span id="l54.956"> </span>
<a href="#l54.957"></a><span id="l54.957">   return (LDAP_SUCCESS);</span>
<a href="#l54.958"></a><span id="l54.958"> }</span>
<a href="#l54.959"></a><span id="l54.959"> </span>
<a href="#l54.960"></a><span id="l54.960"> /* Appends a chain of entries to the given cache header. */</span>
<a href="#l54.961"></a><span id="l54.961" class="difflineminus">-static int memcache_add_res_to_list(ldapmemcacheRes *pRes, LDAPMessage *pMsg,</span>
<a href="#l54.962"></a><span id="l54.962" class="difflineplus">+static int memcache_add_res_to_list(ldapmemcacheRes* pRes, LDAPMessage* pMsg,</span>
<a href="#l54.963"></a><span id="l54.963">                                     unsigned long size) {</span>
<a href="#l54.964"></a><span id="l54.964">   if (pRes-&gt;ldmemcr_resTail)</span>
<a href="#l54.965"></a><span id="l54.965">     pRes-&gt;ldmemcr_resTail-&gt;lm_chain = pMsg;</span>
<a href="#l54.966"></a><span id="l54.966">   else</span>
<a href="#l54.967"></a><span id="l54.967">     pRes-&gt;ldmemcr_resHead = pMsg;</span>
<a href="#l54.968"></a><span id="l54.968"> </span>
<a href="#l54.969"></a><span id="l54.969">   for (pRes-&gt;ldmemcr_resTail = pMsg; pRes-&gt;ldmemcr_resTail-&gt;lm_chain;</span>
<a href="#l54.970"></a><span id="l54.970">        pRes-&gt;ldmemcr_resTail = pRes-&gt;ldmemcr_resTail-&gt;lm_chain) {</span>
<a href="#l54.971"></a><span id="l54.971" class="difflineat">@@ -1249,19 +1249,19 @@ static int memcache_add_res_to_list(ldap</span>
<a href="#l54.972"></a><span id="l54.972">   }</span>
<a href="#l54.973"></a><span id="l54.973"> </span>
<a href="#l54.974"></a><span id="l54.974">   pRes-&gt;ldmemcr_resSize += size;</span>
<a href="#l54.975"></a><span id="l54.975"> </span>
<a href="#l54.976"></a><span id="l54.976">   return (LDAP_SUCCESS);</span>
<a href="#l54.977"></a><span id="l54.977"> }</span>
<a href="#l54.978"></a><span id="l54.978"> </span>
<a href="#l54.979"></a><span id="l54.979"> #ifdef LDAP_DEBUG</span>
<a href="#l54.980"></a><span id="l54.980" class="difflineminus">-static void memcache_print_list(LDAPMemCache *cache, int index) {</span>
<a href="#l54.981"></a><span id="l54.981" class="difflineminus">-  char *name;</span>
<a href="#l54.982"></a><span id="l54.982" class="difflineminus">-  ldapmemcacheRes *restmp;</span>
<a href="#l54.983"></a><span id="l54.983" class="difflineplus">+static void memcache_print_list(LDAPMemCache* cache, int index) {</span>
<a href="#l54.984"></a><span id="l54.984" class="difflineplus">+  char* name;</span>
<a href="#l54.985"></a><span id="l54.985" class="difflineplus">+  ldapmemcacheRes* restmp;</span>
<a href="#l54.986"></a><span id="l54.986"> </span>
<a href="#l54.987"></a><span id="l54.987">   switch (index) {</span>
<a href="#l54.988"></a><span id="l54.988">     case LIST_TTL:</span>
<a href="#l54.989"></a><span id="l54.989">       name = &quot;TTL&quot;;</span>
<a href="#l54.990"></a><span id="l54.990">       break;</span>
<a href="#l54.991"></a><span id="l54.991">     case LIST_LRU:</span>
<a href="#l54.992"></a><span id="l54.992">       name = &quot;LRU&quot;;</span>
<a href="#l54.993"></a><span id="l54.993">       break;</span>
<a href="#l54.994"></a><span id="l54.994" class="difflineat">@@ -1283,70 +1283,70 @@ static void memcache_print_list(LDAPMemC</span>
<a href="#l54.995"></a><span id="l54.995">               restmp-&gt;ldmemcr_req_id.ldmemcrid_msgid);</span>
<a href="#l54.996"></a><span id="l54.996">   }</span>
<a href="#l54.997"></a><span id="l54.997">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;memcache 0x%p end of %s list.\n&quot;, cache, name,</span>
<a href="#l54.998"></a><span id="l54.998">             0);</span>
<a href="#l54.999"></a><span id="l54.999"> }</span>
<a href="#l54.1000"></a><span id="l54.1000"> #endif /* LDAP_DEBUG */</span>
<a href="#l54.1001"></a><span id="l54.1001"> </span>
<a href="#l54.1002"></a><span id="l54.1002"> /* Tells whether a cached result has expired. */</span>
<a href="#l54.1003"></a><span id="l54.1003" class="difflineminus">-static int memcache_expired(LDAPMemCache *cache, ldapmemcacheRes *pRes,</span>
<a href="#l54.1004"></a><span id="l54.1004" class="difflineplus">+static int memcache_expired(LDAPMemCache* cache, ldapmemcacheRes* pRes,</span>
<a href="#l54.1005"></a><span id="l54.1005">                             unsigned long curTime) {</span>
<a href="#l54.1006"></a><span id="l54.1006">   if (!cache-&gt;ldmemc_ttl) return 0;</span>
<a href="#l54.1007"></a><span id="l54.1007"> </span>
<a href="#l54.1008"></a><span id="l54.1008">   return ((unsigned long)difftime((time_t)curTime,</span>
<a href="#l54.1009"></a><span id="l54.1009">                                   (time_t)(pRes-&gt;ldmemcr_timestamp)) &gt;=</span>
<a href="#l54.1010"></a><span id="l54.1010">           cache-&gt;ldmemc_ttl);</span>
<a href="#l54.1011"></a><span id="l54.1011"> }</span>
<a href="#l54.1012"></a><span id="l54.1012"> </span>
<a href="#l54.1013"></a><span id="l54.1013"> /* Operates the cache in a central place. */</span>
<a href="#l54.1014"></a><span id="l54.1014" class="difflineminus">-static int memcache_access(LDAPMemCache *cache, int mode, void *pData1,</span>
<a href="#l54.1015"></a><span id="l54.1015" class="difflineminus">-                           void *pData2, void *pData3) {</span>
<a href="#l54.1016"></a><span id="l54.1016" class="difflineplus">+static int memcache_access(LDAPMemCache* cache, int mode, void* pData1,</span>
<a href="#l54.1017"></a><span id="l54.1017" class="difflineplus">+                           void* pData2, void* pData3) {</span>
<a href="#l54.1018"></a><span id="l54.1018">   int nRes = LDAP_SUCCESS;</span>
<a href="#l54.1019"></a><span id="l54.1019">   unsigned long size = 0;</span>
<a href="#l54.1020"></a><span id="l54.1020"> </span>
<a href="#l54.1021"></a><span id="l54.1021">   /* Add a new cache header to the cache. */</span>
<a href="#l54.1022"></a><span id="l54.1022">   if (mode == MEMCACHE_ACCESS_ADD) {</span>
<a href="#l54.1023"></a><span id="l54.1023" class="difflineminus">-    unsigned long key = *((unsigned long *)pData1);</span>
<a href="#l54.1024"></a><span id="l54.1024" class="difflineminus">-    char *basedn = (char *)pData3;</span>
<a href="#l54.1025"></a><span id="l54.1025" class="difflineminus">-    ldapmemcacheRes *pRes = NULL;</span>
<a href="#l54.1026"></a><span id="l54.1026" class="difflineminus">-    void *hashResult = NULL;</span>
<a href="#l54.1027"></a><span id="l54.1027" class="difflineplus">+    unsigned long key = *((unsigned long*)pData1);</span>
<a href="#l54.1028"></a><span id="l54.1028" class="difflineplus">+    char* basedn = (char*)pData3;</span>
<a href="#l54.1029"></a><span id="l54.1029" class="difflineplus">+    ldapmemcacheRes* pRes = NULL;</span>
<a href="#l54.1030"></a><span id="l54.1030" class="difflineplus">+    void* hashResult = NULL;</span>
<a href="#l54.1031"></a><span id="l54.1031"> </span>
<a href="#l54.1032"></a><span id="l54.1032">     nRes = htable_get(cache-&gt;ldmemc_resTmp, pData2, &amp;hashResult);</span>
<a href="#l54.1033"></a><span id="l54.1033">     if (nRes == LDAP_SUCCESS) return (LDAP_ALREADY_EXISTS);</span>
<a href="#l54.1034"></a><span id="l54.1034"> </span>
<a href="#l54.1035"></a><span id="l54.1035" class="difflineminus">-    pRes = (ldapmemcacheRes *)NSLDAPI_CALLOC(1, sizeof(ldapmemcacheRes));</span>
<a href="#l54.1036"></a><span id="l54.1036" class="difflineplus">+    pRes = (ldapmemcacheRes*)NSLDAPI_CALLOC(1, sizeof(ldapmemcacheRes));</span>
<a href="#l54.1037"></a><span id="l54.1037">     if (pRes == NULL) return (LDAP_NO_MEMORY);</span>
<a href="#l54.1038"></a><span id="l54.1038"> </span>
<a href="#l54.1039"></a><span id="l54.1039">     pRes-&gt;ldmemcr_crc_key = key;</span>
<a href="#l54.1040"></a><span id="l54.1040" class="difflineminus">-    pRes-&gt;ldmemcr_req_id = *((ldapmemcacheReqId *)pData2);</span>
<a href="#l54.1041"></a><span id="l54.1041" class="difflineplus">+    pRes-&gt;ldmemcr_req_id = *((ldapmemcacheReqId*)pData2);</span>
<a href="#l54.1042"></a><span id="l54.1042">     pRes-&gt;ldmemcr_basedn = (basedn ? nsldapi_strdup(basedn) : NULL);</span>
<a href="#l54.1043"></a><span id="l54.1043"> </span>
<a href="#l54.1044"></a><span id="l54.1044">     size += sizeof(ldapmemcacheRes) + strlen(basedn) + 1;</span>
<a href="#l54.1045"></a><span id="l54.1045">     nRes = memcache_adj_size(cache, size, MEMCACHE_SIZE_ENTRIES,</span>
<a href="#l54.1046"></a><span id="l54.1046">                              MEMCACHE_SIZE_ADD);</span>
<a href="#l54.1047"></a><span id="l54.1047">     if (nRes == LDAP_SUCCESS)</span>
<a href="#l54.1048"></a><span id="l54.1048" class="difflineminus">-      nRes = htable_put(cache-&gt;ldmemc_resTmp, pData2, (void *)pRes);</span>
<a href="#l54.1049"></a><span id="l54.1049" class="difflineplus">+      nRes = htable_put(cache-&gt;ldmemc_resTmp, pData2, (void*)pRes);</span>
<a href="#l54.1050"></a><span id="l54.1050">     if (nRes == LDAP_SUCCESS)</span>
<a href="#l54.1051"></a><span id="l54.1051">       memcache_add_to_list(cache, pRes, LIST_TMP);</span>
<a href="#l54.1052"></a><span id="l54.1052">     else</span>
<a href="#l54.1053"></a><span id="l54.1053">       memcache_free_entry(cache, pRes);</span>
<a href="#l54.1054"></a><span id="l54.1054">   }</span>
<a href="#l54.1055"></a><span id="l54.1055">   /* Append entries to an existing cache header. */</span>
<a href="#l54.1056"></a><span id="l54.1056">   else if ((mode == MEMCACHE_ACCESS_APPEND) ||</span>
<a href="#l54.1057"></a><span id="l54.1057">            (mode == MEMCACHE_ACCESS_APPEND_LAST)) {</span>
<a href="#l54.1058"></a><span id="l54.1058" class="difflineminus">-    LDAPMessage *pMsg = (LDAPMessage *)pData2;</span>
<a href="#l54.1059"></a><span id="l54.1059" class="difflineminus">-    LDAPMessage *pCopy = NULL;</span>
<a href="#l54.1060"></a><span id="l54.1060" class="difflineminus">-    ldapmemcacheRes *pRes = NULL;</span>
<a href="#l54.1061"></a><span id="l54.1061" class="difflineminus">-    void *hashResult = NULL;</span>
<a href="#l54.1062"></a><span id="l54.1062" class="difflineplus">+    LDAPMessage* pMsg = (LDAPMessage*)pData2;</span>
<a href="#l54.1063"></a><span id="l54.1063" class="difflineplus">+    LDAPMessage* pCopy = NULL;</span>
<a href="#l54.1064"></a><span id="l54.1064" class="difflineplus">+    ldapmemcacheRes* pRes = NULL;</span>
<a href="#l54.1065"></a><span id="l54.1065" class="difflineplus">+    void* hashResult = NULL;</span>
<a href="#l54.1066"></a><span id="l54.1066"> </span>
<a href="#l54.1067"></a><span id="l54.1067">     nRes = htable_get(cache-&gt;ldmemc_resTmp, pData1, &amp;hashResult);</span>
<a href="#l54.1068"></a><span id="l54.1068">     if (nRes != LDAP_SUCCESS) return nRes;</span>
<a href="#l54.1069"></a><span id="l54.1069"> </span>
<a href="#l54.1070"></a><span id="l54.1070" class="difflineminus">-    pRes = (ldapmemcacheRes *)hashResult;</span>
<a href="#l54.1071"></a><span id="l54.1071" class="difflineplus">+    pRes = (ldapmemcacheRes*)hashResult;</span>
<a href="#l54.1072"></a><span id="l54.1072">     nRes = memcache_dup_message(pMsg, pMsg-&gt;lm_msgid, 0, &amp;pCopy, &amp;size);</span>
<a href="#l54.1073"></a><span id="l54.1073">     if (nRes != LDAP_SUCCESS) {</span>
<a href="#l54.1074"></a><span id="l54.1074">       nRes = htable_remove(cache-&gt;ldmemc_resTmp, pData1, NULL);</span>
<a href="#l54.1075"></a><span id="l54.1075">       assert(nRes == LDAP_SUCCESS);</span>
<a href="#l54.1076"></a><span id="l54.1076">       memcache_free_from_list(cache, pRes, LIST_TMP);</span>
<a href="#l54.1077"></a><span id="l54.1077">       memcache_free_entry(cache, pRes);</span>
<a href="#l54.1078"></a><span id="l54.1078">       return nRes;</span>
<a href="#l54.1079"></a><span id="l54.1079">     }</span>
<a href="#l54.1080"></a><span id="l54.1080" class="difflineat">@@ -1369,29 +1369,29 @@ static int memcache_access(LDAPMemCache </span>
<a href="#l54.1081"></a><span id="l54.1081">     nRes = htable_remove(cache-&gt;ldmemc_resTmp, pData1, NULL);</span>
<a href="#l54.1082"></a><span id="l54.1082">     assert(nRes == LDAP_SUCCESS);</span>
<a href="#l54.1083"></a><span id="l54.1083">     memcache_free_from_list(cache, pRes, LIST_TMP);</span>
<a href="#l54.1084"></a><span id="l54.1084">     (pRes-&gt;ldmemcr_req_id).ldmemcrid_ld = NULL;</span>
<a href="#l54.1085"></a><span id="l54.1085">     (pRes-&gt;ldmemcr_req_id).ldmemcrid_msgid = -1;</span>
<a href="#l54.1086"></a><span id="l54.1086">     pRes-&gt;ldmemcr_timestamp = (unsigned long)time(NULL);</span>
<a href="#l54.1087"></a><span id="l54.1087"> </span>
<a href="#l54.1088"></a><span id="l54.1088">     if ((nRes = htable_put(cache-&gt;ldmemc_resLookup,</span>
<a href="#l54.1089"></a><span id="l54.1089" class="difflineminus">-                           (void *)&amp;(pRes-&gt;ldmemcr_crc_key), (void *)pRes)) ==</span>
<a href="#l54.1090"></a><span id="l54.1090" class="difflineplus">+                           (void*)&amp;(pRes-&gt;ldmemcr_crc_key), (void*)pRes)) ==</span>
<a href="#l54.1091"></a><span id="l54.1091">         LDAP_SUCCESS) {</span>
<a href="#l54.1092"></a><span id="l54.1092">       memcache_add_to_list(cache, pRes, LIST_TTL);</span>
<a href="#l54.1093"></a><span id="l54.1093">       memcache_add_to_list(cache, pRes, LIST_LRU);</span>
<a href="#l54.1094"></a><span id="l54.1094">     } else {</span>
<a href="#l54.1095"></a><span id="l54.1095">       memcache_free_entry(cache, pRes);</span>
<a href="#l54.1096"></a><span id="l54.1096">     }</span>
<a href="#l54.1097"></a><span id="l54.1097">   }</span>
<a href="#l54.1098"></a><span id="l54.1098">   /* Search for cached entries for a particular search. */</span>
<a href="#l54.1099"></a><span id="l54.1099">   else if (mode == MEMCACHE_ACCESS_FIND) {</span>
<a href="#l54.1100"></a><span id="l54.1100" class="difflineminus">-    ldapmemcacheRes **ppRes = (ldapmemcacheRes **)pData2;</span>
<a href="#l54.1101"></a><span id="l54.1101" class="difflineplus">+    ldapmemcacheRes** ppRes = (ldapmemcacheRes**)pData2;</span>
<a href="#l54.1102"></a><span id="l54.1102"> </span>
<a href="#l54.1103"></a><span id="l54.1103" class="difflineminus">-    nRes = htable_get(cache-&gt;ldmemc_resLookup, pData1, (void **)ppRes);</span>
<a href="#l54.1104"></a><span id="l54.1104" class="difflineplus">+    nRes = htable_get(cache-&gt;ldmemc_resLookup, pData1, (void**)ppRes);</span>
<a href="#l54.1105"></a><span id="l54.1105">     if (nRes != LDAP_SUCCESS) return nRes;</span>
<a href="#l54.1106"></a><span id="l54.1106"> </span>
<a href="#l54.1107"></a><span id="l54.1107">     if (!memcache_expired(cache, *ppRes, (unsigned long)time(0))) {</span>
<a href="#l54.1108"></a><span id="l54.1108">       memcache_free_from_list(cache, *ppRes, LIST_LRU);</span>
<a href="#l54.1109"></a><span id="l54.1109">       memcache_add_to_list(cache, *ppRes, LIST_LRU);</span>
<a href="#l54.1110"></a><span id="l54.1110">       return (LDAP_SUCCESS);</span>
<a href="#l54.1111"></a><span id="l54.1111">     }</span>
<a href="#l54.1112"></a><span id="l54.1112"> </span>
<a href="#l54.1113"></a><span id="l54.1113" class="difflineat">@@ -1400,69 +1400,69 @@ static int memcache_access(LDAPMemCache </span>
<a href="#l54.1114"></a><span id="l54.1114">     memcache_free_from_list(cache, *ppRes, LIST_TTL);</span>
<a href="#l54.1115"></a><span id="l54.1115">     memcache_free_from_list(cache, *ppRes, LIST_LRU);</span>
<a href="#l54.1116"></a><span id="l54.1116">     memcache_free_entry(cache, *ppRes);</span>
<a href="#l54.1117"></a><span id="l54.1117">     nRes = LDAP_NO_SUCH_OBJECT;</span>
<a href="#l54.1118"></a><span id="l54.1118">     *ppRes = NULL;</span>
<a href="#l54.1119"></a><span id="l54.1119">   }</span>
<a href="#l54.1120"></a><span id="l54.1120">   /* Remove cached entries in the temporary cache. */</span>
<a href="#l54.1121"></a><span id="l54.1121">   else if (mode == MEMCACHE_ACCESS_DELETE) {</span>
<a href="#l54.1122"></a><span id="l54.1122" class="difflineminus">-    void *hashResult = NULL;</span>
<a href="#l54.1123"></a><span id="l54.1123" class="difflineplus">+    void* hashResult = NULL;</span>
<a href="#l54.1124"></a><span id="l54.1124"> </span>
<a href="#l54.1125"></a><span id="l54.1125">     if ((nRes = htable_remove(cache-&gt;ldmemc_resTmp, pData1, &amp;hashResult)) ==</span>
<a href="#l54.1126"></a><span id="l54.1126">         LDAP_SUCCESS) {</span>
<a href="#l54.1127"></a><span id="l54.1127" class="difflineminus">-      ldapmemcacheRes *pCurRes = (ldapmemcacheRes *)hashResult;</span>
<a href="#l54.1128"></a><span id="l54.1128" class="difflineplus">+      ldapmemcacheRes* pCurRes = (ldapmemcacheRes*)hashResult;</span>
<a href="#l54.1129"></a><span id="l54.1129">       memcache_free_from_list(cache, pCurRes, LIST_TMP);</span>
<a href="#l54.1130"></a><span id="l54.1130">       memcache_free_entry(cache, pCurRes);</span>
<a href="#l54.1131"></a><span id="l54.1131">     }</span>
<a href="#l54.1132"></a><span id="l54.1132">   }</span>
<a href="#l54.1133"></a><span id="l54.1133">   /* Wipe out the temporary cache. */</span>
<a href="#l54.1134"></a><span id="l54.1134">   else if (mode == MEMCACHE_ACCESS_DELETE_ALL) {</span>
<a href="#l54.1135"></a><span id="l54.1135" class="difflineminus">-    nRes = htable_removeall(cache-&gt;ldmemc_resTmp, (void *)cache);</span>
<a href="#l54.1136"></a><span id="l54.1136" class="difflineplus">+    nRes = htable_removeall(cache-&gt;ldmemc_resTmp, (void*)cache);</span>
<a href="#l54.1137"></a><span id="l54.1137">   }</span>
<a href="#l54.1138"></a><span id="l54.1138">   /* Remove expired entries from primary cache. */</span>
<a href="#l54.1139"></a><span id="l54.1139">   else if (mode == MEMCACHE_ACCESS_UPDATE) {</span>
<a href="#l54.1140"></a><span id="l54.1140" class="difflineminus">-    ldapmemcacheRes *pCurRes = cache-&gt;ldmemc_resTail[LIST_TTL];</span>
<a href="#l54.1141"></a><span id="l54.1141" class="difflineplus">+    ldapmemcacheRes* pCurRes = cache-&gt;ldmemc_resTail[LIST_TTL];</span>
<a href="#l54.1142"></a><span id="l54.1142">     unsigned long curTime = (unsigned long)time(NULL);</span>
<a href="#l54.1143"></a><span id="l54.1143"> </span>
<a href="#l54.1144"></a><span id="l54.1144">     for (; pCurRes; pCurRes = cache-&gt;ldmemc_resTail[LIST_TTL]) {</span>
<a href="#l54.1145"></a><span id="l54.1145">       if (!memcache_expired(cache, pCurRes, curTime)) break;</span>
<a href="#l54.1146"></a><span id="l54.1146"> </span>
<a href="#l54.1147"></a><span id="l54.1147">       nRes = htable_remove(cache-&gt;ldmemc_resLookup,</span>
<a href="#l54.1148"></a><span id="l54.1148" class="difflineminus">-                           (void *)&amp;(pCurRes-&gt;ldmemcr_crc_key), NULL);</span>
<a href="#l54.1149"></a><span id="l54.1149" class="difflineplus">+                           (void*)&amp;(pCurRes-&gt;ldmemcr_crc_key), NULL);</span>
<a href="#l54.1150"></a><span id="l54.1150">       assert(nRes == LDAP_SUCCESS);</span>
<a href="#l54.1151"></a><span id="l54.1151">       memcache_free_from_list(cache, pCurRes, LIST_TTL);</span>
<a href="#l54.1152"></a><span id="l54.1152">       memcache_free_from_list(cache, pCurRes, LIST_LRU);</span>
<a href="#l54.1153"></a><span id="l54.1153">       memcache_free_entry(cache, pCurRes);</span>
<a href="#l54.1154"></a><span id="l54.1154">     }</span>
<a href="#l54.1155"></a><span id="l54.1155">   }</span>
<a href="#l54.1156"></a><span id="l54.1156">   /* Wipe out the primary cache. */</span>
<a href="#l54.1157"></a><span id="l54.1157">   else if (mode == MEMCACHE_ACCESS_FLUSH_ALL) {</span>
<a href="#l54.1158"></a><span id="l54.1158" class="difflineminus">-    ldapmemcacheRes *pCurRes = cache-&gt;ldmemc_resHead[LIST_TTL];</span>
<a href="#l54.1159"></a><span id="l54.1159" class="difflineplus">+    ldapmemcacheRes* pCurRes = cache-&gt;ldmemc_resHead[LIST_TTL];</span>
<a href="#l54.1160"></a><span id="l54.1160"> </span>
<a href="#l54.1161"></a><span id="l54.1161" class="difflineminus">-    nRes = htable_removeall(cache-&gt;ldmemc_resLookup, (void *)cache);</span>
<a href="#l54.1162"></a><span id="l54.1162" class="difflineplus">+    nRes = htable_removeall(cache-&gt;ldmemc_resLookup, (void*)cache);</span>
<a href="#l54.1163"></a><span id="l54.1163"> </span>
<a href="#l54.1164"></a><span id="l54.1164">     for (; pCurRes; pCurRes = cache-&gt;ldmemc_resHead[LIST_TTL]) {</span>
<a href="#l54.1165"></a><span id="l54.1165">       memcache_free_from_list(cache, pCurRes, LIST_LRU);</span>
<a href="#l54.1166"></a><span id="l54.1166">       cache-&gt;ldmemc_resHead[LIST_TTL] =</span>
<a href="#l54.1167"></a><span id="l54.1167">           cache-&gt;ldmemc_resHead[LIST_TTL]-&gt;ldmemcr_next[LIST_TTL];</span>
<a href="#l54.1168"></a><span id="l54.1168">       memcache_free_entry(cache, pCurRes);</span>
<a href="#l54.1169"></a><span id="l54.1169">     }</span>
<a href="#l54.1170"></a><span id="l54.1170">     cache-&gt;ldmemc_resTail[LIST_TTL] = NULL;</span>
<a href="#l54.1171"></a><span id="l54.1171">   }</span>
<a href="#l54.1172"></a><span id="l54.1172">   /* Remove cached entries in both primary and temporary cache. */</span>
<a href="#l54.1173"></a><span id="l54.1173">   else if ((mode == MEMCACHE_ACCESS_FLUSH) ||</span>
<a href="#l54.1174"></a><span id="l54.1174">            (mode == MEMCACHE_ACCESS_FLUSH_RESULTS)) {</span>
<a href="#l54.1175"></a><span id="l54.1175">     int i, list_id, bDone;</span>
<a href="#l54.1176"></a><span id="l54.1176">     int scope = (int)pData2;</span>
<a href="#l54.1177"></a><span id="l54.1177" class="difflineminus">-    char *dn = (char *)pData1;</span>
<a href="#l54.1178"></a><span id="l54.1178" class="difflineminus">-    char *dnTmp;</span>
<a href="#l54.1179"></a><span id="l54.1179" class="difflineplus">+    char* dn = (char*)pData1;</span>
<a href="#l54.1180"></a><span id="l54.1180" class="difflineplus">+    char* dnTmp;</span>
<a href="#l54.1181"></a><span id="l54.1181">     BerElement ber;</span>
<a href="#l54.1182"></a><span id="l54.1182" class="difflineminus">-    LDAPMessage *pMsg;</span>
<a href="#l54.1183"></a><span id="l54.1183" class="difflineminus">-    ldapmemcacheRes *pRes;</span>
<a href="#l54.1184"></a><span id="l54.1184" class="difflineplus">+    LDAPMessage* pMsg;</span>
<a href="#l54.1185"></a><span id="l54.1185" class="difflineplus">+    ldapmemcacheRes* pRes;</span>
<a href="#l54.1186"></a><span id="l54.1186"> </span>
<a href="#l54.1187"></a><span id="l54.1187">     if (cache-&gt;ldmemc_basedns) {</span>
<a href="#l54.1188"></a><span id="l54.1188">       for (i = 0; cache-&gt;ldmemc_basedns[i]; i++) {</span>
<a href="#l54.1189"></a><span id="l54.1189">         if ((memcache_compare_dn(cache-&gt;ldmemc_basedns[i], dn,</span>
<a href="#l54.1190"></a><span id="l54.1190">                                  LDAP_SCOPE_SUBTREE) == LDAP_COMPARE_TRUE) ||</span>
<a href="#l54.1191"></a><span id="l54.1191">             (memcache_compare_dn(dn, cache-&gt;ldmemc_basedns[i],</span>
<a href="#l54.1192"></a><span id="l54.1192">                                  LDAP_SCOPE_SUBTREE) == LDAP_COMPARE_TRUE))</span>
<a href="#l54.1193"></a><span id="l54.1193">           break;</span>
<a href="#l54.1194"></a><span id="l54.1194" class="difflineat">@@ -1502,79 +1502,79 @@ static int memcache_access(LDAPMemCache </span>
<a href="#l54.1195"></a><span id="l54.1195">         if ((mode == MEMCACHE_ACCESS_FLUSH_RESULTS) &amp;&amp; !foundentries) {</span>
<a href="#l54.1196"></a><span id="l54.1196">           bDone = 1;</span>
<a href="#l54.1197"></a><span id="l54.1197">         }</span>
<a href="#l54.1198"></a><span id="l54.1198"> </span>
<a href="#l54.1199"></a><span id="l54.1199">         if (!bDone) continue;</span>
<a href="#l54.1200"></a><span id="l54.1200"> </span>
<a href="#l54.1201"></a><span id="l54.1201">         if (list_id == LIST_TTL) {</span>
<a href="#l54.1202"></a><span id="l54.1202">           nRes = htable_remove(cache-&gt;ldmemc_resLookup,</span>
<a href="#l54.1203"></a><span id="l54.1203" class="difflineminus">-                               (void *)&amp;(pRes-&gt;ldmemcr_crc_key), NULL);</span>
<a href="#l54.1204"></a><span id="l54.1204" class="difflineplus">+                               (void*)&amp;(pRes-&gt;ldmemcr_crc_key), NULL);</span>
<a href="#l54.1205"></a><span id="l54.1205">           assert(nRes == LDAP_SUCCESS);</span>
<a href="#l54.1206"></a><span id="l54.1206">           memcache_free_from_list(cache, pRes, LIST_TTL);</span>
<a href="#l54.1207"></a><span id="l54.1207">           memcache_free_from_list(cache, pRes, LIST_LRU);</span>
<a href="#l54.1208"></a><span id="l54.1208">         } else {</span>
<a href="#l54.1209"></a><span id="l54.1209">           nRes = htable_remove(cache-&gt;ldmemc_resTmp,</span>
<a href="#l54.1210"></a><span id="l54.1210" class="difflineminus">-                               (void *)&amp;(pRes-&gt;ldmemcr_req_id), NULL);</span>
<a href="#l54.1211"></a><span id="l54.1211" class="difflineplus">+                               (void*)&amp;(pRes-&gt;ldmemcr_req_id), NULL);</span>
<a href="#l54.1212"></a><span id="l54.1212">           assert(nRes == LDAP_SUCCESS);</span>
<a href="#l54.1213"></a><span id="l54.1213">           memcache_free_from_list(cache, pRes, LIST_TMP);</span>
<a href="#l54.1214"></a><span id="l54.1214">         }</span>
<a href="#l54.1215"></a><span id="l54.1215">         memcache_free_entry(cache, pRes);</span>
<a href="#l54.1216"></a><span id="l54.1216">       }</span>
<a href="#l54.1217"></a><span id="l54.1217">     }</span>
<a href="#l54.1218"></a><span id="l54.1218">   }</span>
<a href="#l54.1219"></a><span id="l54.1219">   /* Flush least recently used entries from cache */</span>
<a href="#l54.1220"></a><span id="l54.1220">   else if (mode == MEMCACHE_ACCESS_FLUSH_LRU) {</span>
<a href="#l54.1221"></a><span id="l54.1221" class="difflineminus">-    ldapmemcacheRes *pRes = cache-&gt;ldmemc_resTail[LIST_LRU];</span>
<a href="#l54.1222"></a><span id="l54.1222" class="difflineplus">+    ldapmemcacheRes* pRes = cache-&gt;ldmemc_resTail[LIST_LRU];</span>
<a href="#l54.1223"></a><span id="l54.1223"> </span>
<a href="#l54.1224"></a><span id="l54.1224">     if (pRes == NULL) return LDAP_NO_SUCH_OBJECT;</span>
<a href="#l54.1225"></a><span id="l54.1225"> </span>
<a href="#l54.1226"></a><span id="l54.1226">     LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l54.1227"></a><span id="l54.1227">               &quot;memcache_access FLUSH_LRU: removing key 0x%8.8lx\n&quot;,</span>
<a href="#l54.1228"></a><span id="l54.1228">               pRes-&gt;ldmemcr_crc_key, 0, 0);</span>
<a href="#l54.1229"></a><span id="l54.1229">     nRes = htable_remove(cache-&gt;ldmemc_resLookup,</span>
<a href="#l54.1230"></a><span id="l54.1230" class="difflineminus">-                         (void *)&amp;(pRes-&gt;ldmemcr_crc_key), NULL);</span>
<a href="#l54.1231"></a><span id="l54.1231" class="difflineplus">+                         (void*)&amp;(pRes-&gt;ldmemcr_crc_key), NULL);</span>
<a href="#l54.1232"></a><span id="l54.1232">     assert(nRes == LDAP_SUCCESS);</span>
<a href="#l54.1233"></a><span id="l54.1233">     memcache_free_from_list(cache, pRes, LIST_TTL);</span>
<a href="#l54.1234"></a><span id="l54.1234">     memcache_free_from_list(cache, pRes, LIST_LRU);</span>
<a href="#l54.1235"></a><span id="l54.1235">     memcache_free_entry(cache, pRes);</span>
<a href="#l54.1236"></a><span id="l54.1236">   }</span>
<a href="#l54.1237"></a><span id="l54.1237">   /* Unknown command */</span>
<a href="#l54.1238"></a><span id="l54.1238">   else {</span>
<a href="#l54.1239"></a><span id="l54.1239">     nRes = LDAP_PARAM_ERROR;</span>
<a href="#l54.1240"></a><span id="l54.1240">   }</span>
<a href="#l54.1241"></a><span id="l54.1241"> </span>
<a href="#l54.1242"></a><span id="l54.1242">   return nRes;</span>
<a href="#l54.1243"></a><span id="l54.1243"> }</span>
<a href="#l54.1244"></a><span id="l54.1244"> </span>
<a href="#l54.1245"></a><span id="l54.1245" class="difflineminus">-static void memcache_flush(LDAPMemCache *cache, char *dn, int scope,</span>
<a href="#l54.1246"></a><span id="l54.1246" class="difflineplus">+static void memcache_flush(LDAPMemCache* cache, char* dn, int scope,</span>
<a href="#l54.1247"></a><span id="l54.1247">                            int flushresults) {</span>
<a href="#l54.1248"></a><span id="l54.1248">   if (!NSLDAPI_VALID_MEMCACHE_POINTER(cache)) {</span>
<a href="#l54.1249"></a><span id="l54.1249">     return;</span>
<a href="#l54.1250"></a><span id="l54.1250">   }</span>
<a href="#l54.1251"></a><span id="l54.1251"> </span>
<a href="#l54.1252"></a><span id="l54.1252">   LDAP_MEMCACHE_MUTEX_LOCK(cache);</span>
<a href="#l54.1253"></a><span id="l54.1253"> </span>
<a href="#l54.1254"></a><span id="l54.1254">   if (!dn) {</span>
<a href="#l54.1255"></a><span id="l54.1255">     memcache_access(cache, MEMCACHE_ACCESS_FLUSH_ALL, NULL, NULL, NULL);</span>
<a href="#l54.1256"></a><span id="l54.1256">   } else {</span>
<a href="#l54.1257"></a><span id="l54.1257">     if (flushresults) {</span>
<a href="#l54.1258"></a><span id="l54.1258" class="difflineminus">-      memcache_access(cache, MEMCACHE_ACCESS_FLUSH_RESULTS, (void *)dn,</span>
<a href="#l54.1259"></a><span id="l54.1259" class="difflineminus">-                      (void *)scope, NULL);</span>
<a href="#l54.1260"></a><span id="l54.1260" class="difflineplus">+      memcache_access(cache, MEMCACHE_ACCESS_FLUSH_RESULTS, (void*)dn,</span>
<a href="#l54.1261"></a><span id="l54.1261" class="difflineplus">+                      (void*)scope, NULL);</span>
<a href="#l54.1262"></a><span id="l54.1262">     } else {</span>
<a href="#l54.1263"></a><span id="l54.1263" class="difflineminus">-      memcache_access(cache, MEMCACHE_ACCESS_FLUSH, (void *)dn, (void *)scope,</span>
<a href="#l54.1264"></a><span id="l54.1264" class="difflineplus">+      memcache_access(cache, MEMCACHE_ACCESS_FLUSH, (void*)dn, (void*)scope,</span>
<a href="#l54.1265"></a><span id="l54.1265">                       NULL);</span>
<a href="#l54.1266"></a><span id="l54.1266">     }</span>
<a href="#l54.1267"></a><span id="l54.1267">   }</span>
<a href="#l54.1268"></a><span id="l54.1268"> </span>
<a href="#l54.1269"></a><span id="l54.1269">   LDAP_MEMCACHE_MUTEX_UNLOCK(cache);</span>
<a href="#l54.1270"></a><span id="l54.1270"> }</span>
<a href="#l54.1271"></a><span id="l54.1271"> </span>
<a href="#l54.1272"></a><span id="l54.1272"> #ifdef LDAP_DEBUG</span>
<a href="#l54.1273"></a><span id="l54.1273" class="difflineminus">-static void memcache_report_statistics(LDAPMemCache *cache) {</span>
<a href="#l54.1274"></a><span id="l54.1274" class="difflineplus">+static void memcache_report_statistics(LDAPMemCache* cache) {</span>
<a href="#l54.1275"></a><span id="l54.1275">   unsigned long hitrate;</span>
<a href="#l54.1276"></a><span id="l54.1276"> </span>
<a href="#l54.1277"></a><span id="l54.1277">   if (cache-&gt;ldmemc_stats.ldmemcstat_tries == 0) {</span>
<a href="#l54.1278"></a><span id="l54.1278">     hitrate = 0;</span>
<a href="#l54.1279"></a><span id="l54.1279">   } else {</span>
<a href="#l54.1280"></a><span id="l54.1280">     hitrate = (100L * cache-&gt;ldmemc_stats.ldmemcstat_hits) /</span>
<a href="#l54.1281"></a><span id="l54.1281">               cache-&gt;ldmemc_stats.ldmemcstat_tries;</span>
<a href="#l54.1282"></a><span id="l54.1282">   }</span>
<a href="#l54.1283"></a><span id="l54.1283" class="difflineat">@@ -1612,89 +1612,89 @@ static int htable_calculate_size(int siz</span>
<a href="#l54.1284"></a><span id="l54.1284">       j = size / 2;</span>
<a href="#l54.1285"></a><span id="l54.1285">     }</span>
<a href="#l54.1286"></a><span id="l54.1286">   }</span>
<a href="#l54.1287"></a><span id="l54.1287"> </span>
<a href="#l54.1288"></a><span id="l54.1288">   return size;</span>
<a href="#l54.1289"></a><span id="l54.1289"> }</span>
<a href="#l54.1290"></a><span id="l54.1290"> </span>
<a href="#l54.1291"></a><span id="l54.1291"> /* Returns the size in bytes of the given hash table. */</span>
<a href="#l54.1292"></a><span id="l54.1292" class="difflineminus">-static int htable_sizeinbytes(HashTable *pTable) {</span>
<a href="#l54.1293"></a><span id="l54.1293" class="difflineplus">+static int htable_sizeinbytes(HashTable* pTable) {</span>
<a href="#l54.1294"></a><span id="l54.1294">   if (!pTable) return 0;</span>
<a href="#l54.1295"></a><span id="l54.1295"> </span>
<a href="#l54.1296"></a><span id="l54.1296">   return (pTable-&gt;size * sizeof(HashTableNode));</span>
<a href="#l54.1297"></a><span id="l54.1297"> }</span>
<a href="#l54.1298"></a><span id="l54.1298"> </span>
<a href="#l54.1299"></a><span id="l54.1299"> /* Inserts an item into the hash table. */</span>
<a href="#l54.1300"></a><span id="l54.1300" class="difflineminus">-static int htable_put(HashTable *pTable, void *key, void *pData) {</span>
<a href="#l54.1301"></a><span id="l54.1301" class="difflineplus">+static int htable_put(HashTable* pTable, void* key, void* pData) {</span>
<a href="#l54.1302"></a><span id="l54.1302">   int index = pTable-&gt;hashfunc(pTable-&gt;size, key);</span>
<a href="#l54.1303"></a><span id="l54.1303"> </span>
<a href="#l54.1304"></a><span id="l54.1304">   if (index &gt;= 0 &amp;&amp; index &lt; pTable-&gt;size)</span>
<a href="#l54.1305"></a><span id="l54.1305">     return pTable-&gt;putdata(&amp;(pTable-&gt;table[index].pData), key, pData);</span>
<a href="#l54.1306"></a><span id="l54.1306"> </span>
<a href="#l54.1307"></a><span id="l54.1307">   return (LDAP_OPERATIONS_ERROR);</span>
<a href="#l54.1308"></a><span id="l54.1308"> }</span>
<a href="#l54.1309"></a><span id="l54.1309"> </span>
<a href="#l54.1310"></a><span id="l54.1310"> /* Retrieves an item from the hash table. */</span>
<a href="#l54.1311"></a><span id="l54.1311" class="difflineminus">-static int htable_get(HashTable *pTable, void *key, void **ppData) {</span>
<a href="#l54.1312"></a><span id="l54.1312" class="difflineplus">+static int htable_get(HashTable* pTable, void* key, void** ppData) {</span>
<a href="#l54.1313"></a><span id="l54.1313">   int index = pTable-&gt;hashfunc(pTable-&gt;size, key);</span>
<a href="#l54.1314"></a><span id="l54.1314"> </span>
<a href="#l54.1315"></a><span id="l54.1315">   *ppData = NULL;</span>
<a href="#l54.1316"></a><span id="l54.1316"> </span>
<a href="#l54.1317"></a><span id="l54.1317">   if (index &gt;= 0 &amp;&amp; index &lt; pTable-&gt;size)</span>
<a href="#l54.1318"></a><span id="l54.1318">     return pTable-&gt;getdata(pTable-&gt;table[index].pData, key, ppData);</span>
<a href="#l54.1319"></a><span id="l54.1319"> </span>
<a href="#l54.1320"></a><span id="l54.1320">   return (LDAP_OPERATIONS_ERROR);</span>
<a href="#l54.1321"></a><span id="l54.1321"> }</span>
<a href="#l54.1322"></a><span id="l54.1322"> </span>
<a href="#l54.1323"></a><span id="l54.1323"> /* Performs a miscellaneous operation on a hash table entry. */</span>
<a href="#l54.1324"></a><span id="l54.1324" class="difflineminus">-static int htable_misc(HashTable *pTable, void *key, void *pData) {</span>
<a href="#l54.1325"></a><span id="l54.1325" class="difflineplus">+static int htable_misc(HashTable* pTable, void* key, void* pData) {</span>
<a href="#l54.1326"></a><span id="l54.1326">   if (pTable-&gt;miscfunc) {</span>
<a href="#l54.1327"></a><span id="l54.1327">     int index = pTable-&gt;hashfunc(pTable-&gt;size, key);</span>
<a href="#l54.1328"></a><span id="l54.1328">     if (index &gt;= 0 &amp;&amp; index &lt; pTable-&gt;size)</span>
<a href="#l54.1329"></a><span id="l54.1329">       return pTable-&gt;miscfunc(&amp;(pTable-&gt;table[index].pData), key, pData);</span>
<a href="#l54.1330"></a><span id="l54.1330">   }</span>
<a href="#l54.1331"></a><span id="l54.1331"> </span>
<a href="#l54.1332"></a><span id="l54.1332">   return (LDAP_OPERATIONS_ERROR);</span>
<a href="#l54.1333"></a><span id="l54.1333"> }</span>
<a href="#l54.1334"></a><span id="l54.1334"> </span>
<a href="#l54.1335"></a><span id="l54.1335"> /* Removes an item from the hash table. */</span>
<a href="#l54.1336"></a><span id="l54.1336" class="difflineminus">-static int htable_remove(HashTable *pTable, void *key, void **ppData) {</span>
<a href="#l54.1337"></a><span id="l54.1337" class="difflineplus">+static int htable_remove(HashTable* pTable, void* key, void** ppData) {</span>
<a href="#l54.1338"></a><span id="l54.1338">   int index = pTable-&gt;hashfunc(pTable-&gt;size, key);</span>
<a href="#l54.1339"></a><span id="l54.1339"> </span>
<a href="#l54.1340"></a><span id="l54.1340">   if (ppData) *ppData = NULL;</span>
<a href="#l54.1341"></a><span id="l54.1341"> </span>
<a href="#l54.1342"></a><span id="l54.1342">   if (index &gt;= 0 &amp;&amp; index &lt; pTable-&gt;size)</span>
<a href="#l54.1343"></a><span id="l54.1343">     return pTable-&gt;removedata(&amp;(pTable-&gt;table[index].pData), key, ppData);</span>
<a href="#l54.1344"></a><span id="l54.1344"> </span>
<a href="#l54.1345"></a><span id="l54.1345">   return (LDAP_OPERATIONS_ERROR);</span>
<a href="#l54.1346"></a><span id="l54.1346"> }</span>
<a href="#l54.1347"></a><span id="l54.1347"> </span>
<a href="#l54.1348"></a><span id="l54.1348"> /* Removes everything in the hash table. */</span>
<a href="#l54.1349"></a><span id="l54.1349" class="difflineminus">-static int htable_removeall(HashTable *pTable, void *pData) {</span>
<a href="#l54.1350"></a><span id="l54.1350" class="difflineplus">+static int htable_removeall(HashTable* pTable, void* pData) {</span>
<a href="#l54.1351"></a><span id="l54.1351">   int i;</span>
<a href="#l54.1352"></a><span id="l54.1352"> </span>
<a href="#l54.1353"></a><span id="l54.1353">   for (i = 0; i &lt; pTable-&gt;size; i++)</span>
<a href="#l54.1354"></a><span id="l54.1354">     pTable-&gt;clrtablenode(&amp;(pTable-&gt;table[i].pData), pData);</span>
<a href="#l54.1355"></a><span id="l54.1355"> </span>
<a href="#l54.1356"></a><span id="l54.1356">   return (LDAP_SUCCESS);</span>
<a href="#l54.1357"></a><span id="l54.1357"> }</span>
<a href="#l54.1358"></a><span id="l54.1358"> </span>
<a href="#l54.1359"></a><span id="l54.1359"> /* Creates a new hash table. */</span>
<a href="#l54.1360"></a><span id="l54.1360"> static int htable_create(int size_limit, HashFuncPtr hashf, PutDataPtr putDataf,</span>
<a href="#l54.1361"></a><span id="l54.1361">                          GetDataPtr getDataf, RemoveDataPtr removeDataf,</span>
<a href="#l54.1362"></a><span id="l54.1362">                          ClrTableNodePtr clrNodef, MiscFuncPtr miscOpf,</span>
<a href="#l54.1363"></a><span id="l54.1363" class="difflineminus">-                         HashTable **ppTable) {</span>
<a href="#l54.1364"></a><span id="l54.1364" class="difflineplus">+                         HashTable** ppTable) {</span>
<a href="#l54.1365"></a><span id="l54.1365">   size_limit = htable_calculate_size(size_limit);</span>
<a href="#l54.1366"></a><span id="l54.1366"> </span>
<a href="#l54.1367"></a><span id="l54.1367" class="difflineminus">-  if ((*ppTable = (HashTable *)NSLDAPI_CALLOC(1, sizeof(HashTable))) == NULL)</span>
<a href="#l54.1368"></a><span id="l54.1368" class="difflineplus">+  if ((*ppTable = (HashTable*)NSLDAPI_CALLOC(1, sizeof(HashTable))) == NULL)</span>
<a href="#l54.1369"></a><span id="l54.1369">     return (LDAP_NO_MEMORY);</span>
<a href="#l54.1370"></a><span id="l54.1370"> </span>
<a href="#l54.1371"></a><span id="l54.1371">   (*ppTable)-&gt;table =</span>
<a href="#l54.1372"></a><span id="l54.1372" class="difflineminus">-      (HashTableNode *)NSLDAPI_CALLOC(size_limit, sizeof(HashTableNode));</span>
<a href="#l54.1373"></a><span id="l54.1373" class="difflineplus">+      (HashTableNode*)NSLDAPI_CALLOC(size_limit, sizeof(HashTableNode));</span>
<a href="#l54.1374"></a><span id="l54.1374">   if ((*ppTable)-&gt;table == NULL) {</span>
<a href="#l54.1375"></a><span id="l54.1375">     NSLDAPI_FREE(*ppTable);</span>
<a href="#l54.1376"></a><span id="l54.1376">     *ppTable = NULL;</span>
<a href="#l54.1377"></a><span id="l54.1377">     return (LDAP_NO_MEMORY);</span>
<a href="#l54.1378"></a><span id="l54.1378">   }</span>
<a href="#l54.1379"></a><span id="l54.1379"> </span>
<a href="#l54.1380"></a><span id="l54.1380">   (*ppTable)-&gt;size = size_limit;</span>
<a href="#l54.1381"></a><span id="l54.1381">   (*ppTable)-&gt;hashfunc = hashf;</span>
<a href="#l54.1382"></a><span id="l54.1382" class="difflineat">@@ -1703,37 +1703,37 @@ static int htable_create(int size_limit,</span>
<a href="#l54.1383"></a><span id="l54.1383">   (*ppTable)-&gt;miscfunc = miscOpf;</span>
<a href="#l54.1384"></a><span id="l54.1384">   (*ppTable)-&gt;removedata = removeDataf;</span>
<a href="#l54.1385"></a><span id="l54.1385">   (*ppTable)-&gt;clrtablenode = clrNodef;</span>
<a href="#l54.1386"></a><span id="l54.1386"> </span>
<a href="#l54.1387"></a><span id="l54.1387">   return (LDAP_SUCCESS);</span>
<a href="#l54.1388"></a><span id="l54.1388"> }</span>
<a href="#l54.1389"></a><span id="l54.1389"> </span>
<a href="#l54.1390"></a><span id="l54.1390"> /* Destroys a hash table. */</span>
<a href="#l54.1391"></a><span id="l54.1391" class="difflineminus">-static int htable_free(HashTable *pTable) {</span>
<a href="#l54.1392"></a><span id="l54.1392" class="difflineplus">+static int htable_free(HashTable* pTable) {</span>
<a href="#l54.1393"></a><span id="l54.1393">   NSLDAPI_FREE(pTable-&gt;table);</span>
<a href="#l54.1394"></a><span id="l54.1394">   NSLDAPI_FREE(pTable);</span>
<a href="#l54.1395"></a><span id="l54.1395">   return (LDAP_SUCCESS);</span>
<a href="#l54.1396"></a><span id="l54.1396"> }</span>
<a href="#l54.1397"></a><span id="l54.1397"> </span>
<a href="#l54.1398"></a><span id="l54.1398"> /**************** Hash table callbacks for temporary cache ****************/</span>
<a href="#l54.1399"></a><span id="l54.1399"> </span>
<a href="#l54.1400"></a><span id="l54.1400"> /* Hash function */</span>
<a href="#l54.1401"></a><span id="l54.1401" class="difflineminus">-static int msgid_hashf(int table_size, void *key) {</span>
<a href="#l54.1402"></a><span id="l54.1402" class="difflineminus">-  unsigned code = (unsigned)((ldapmemcacheReqId *)key)-&gt;ldmemcrid_ld;</span>
<a href="#l54.1403"></a><span id="l54.1403" class="difflineplus">+static int msgid_hashf(int table_size, void* key) {</span>
<a href="#l54.1404"></a><span id="l54.1404" class="difflineplus">+  unsigned code = (unsigned)((ldapmemcacheReqId*)key)-&gt;ldmemcrid_ld;</span>
<a href="#l54.1405"></a><span id="l54.1405">   return (((code &lt;&lt; 20) + (code &gt;&gt; 12)) % table_size);</span>
<a href="#l54.1406"></a><span id="l54.1406"> }</span>
<a href="#l54.1407"></a><span id="l54.1407"> </span>
<a href="#l54.1408"></a><span id="l54.1408"> /* Called by hash table to insert an item. */</span>
<a href="#l54.1409"></a><span id="l54.1409" class="difflineminus">-static int msgid_putdata(void **ppTableData, void *key, void *pData) {</span>
<a href="#l54.1410"></a><span id="l54.1410" class="difflineminus">-  ldapmemcacheReqId *pReqId = (ldapmemcacheReqId *)key;</span>
<a href="#l54.1411"></a><span id="l54.1411" class="difflineminus">-  ldapmemcacheRes *pRes = (ldapmemcacheRes *)pData;</span>
<a href="#l54.1412"></a><span id="l54.1412" class="difflineminus">-  ldapmemcacheRes **ppHead = (ldapmemcacheRes **)ppTableData;</span>
<a href="#l54.1413"></a><span id="l54.1413" class="difflineminus">-  ldapmemcacheRes *pCurRes = *ppHead;</span>
<a href="#l54.1414"></a><span id="l54.1414" class="difflineminus">-  ldapmemcacheRes *pPrev = NULL;</span>
<a href="#l54.1415"></a><span id="l54.1415" class="difflineplus">+static int msgid_putdata(void** ppTableData, void* key, void* pData) {</span>
<a href="#l54.1416"></a><span id="l54.1416" class="difflineplus">+  ldapmemcacheReqId* pReqId = (ldapmemcacheReqId*)key;</span>
<a href="#l54.1417"></a><span id="l54.1417" class="difflineplus">+  ldapmemcacheRes* pRes = (ldapmemcacheRes*)pData;</span>
<a href="#l54.1418"></a><span id="l54.1418" class="difflineplus">+  ldapmemcacheRes** ppHead = (ldapmemcacheRes**)ppTableData;</span>
<a href="#l54.1419"></a><span id="l54.1419" class="difflineplus">+  ldapmemcacheRes* pCurRes = *ppHead;</span>
<a href="#l54.1420"></a><span id="l54.1420" class="difflineplus">+  ldapmemcacheRes* pPrev = NULL;</span>
<a href="#l54.1421"></a><span id="l54.1421"> </span>
<a href="#l54.1422"></a><span id="l54.1422">   for (; pCurRes; pCurRes = pCurRes-&gt;ldmemcr_htable_next) {</span>
<a href="#l54.1423"></a><span id="l54.1423">     if ((pCurRes-&gt;ldmemcr_req_id).ldmemcrid_ld == pReqId-&gt;ldmemcrid_ld) break;</span>
<a href="#l54.1424"></a><span id="l54.1424">     pPrev = pCurRes;</span>
<a href="#l54.1425"></a><span id="l54.1425">   }</span>
<a href="#l54.1426"></a><span id="l54.1426"> </span>
<a href="#l54.1427"></a><span id="l54.1427">   if (pCurRes) {</span>
<a href="#l54.1428"></a><span id="l54.1428">     for (; pCurRes; pCurRes = pCurRes-&gt;ldmemcr_next[LIST_TTL]) {</span>
<a href="#l54.1429"></a><span id="l54.1429" class="difflineat">@@ -1751,44 +1751,44 @@ static int msgid_putdata(void **ppTableD</span>
<a href="#l54.1430"></a><span id="l54.1430">       *ppHead = pRes;</span>
<a href="#l54.1431"></a><span id="l54.1431">     pRes-&gt;ldmemcr_htable_next = NULL;</span>
<a href="#l54.1432"></a><span id="l54.1432">   }</span>
<a href="#l54.1433"></a><span id="l54.1433"> </span>
<a href="#l54.1434"></a><span id="l54.1434">   return (LDAP_SUCCESS);</span>
<a href="#l54.1435"></a><span id="l54.1435"> }</span>
<a href="#l54.1436"></a><span id="l54.1436"> </span>
<a href="#l54.1437"></a><span id="l54.1437"> /* Called by hash table to retrieve an item. */</span>
<a href="#l54.1438"></a><span id="l54.1438" class="difflineminus">-static int msgid_getdata(void *pTableData, void *key, void **ppData) {</span>
<a href="#l54.1439"></a><span id="l54.1439" class="difflineminus">-  ldapmemcacheReqId *pReqId = (ldapmemcacheReqId *)key;</span>
<a href="#l54.1440"></a><span id="l54.1440" class="difflineminus">-  ldapmemcacheRes *pCurRes = (ldapmemcacheRes *)pTableData;</span>
<a href="#l54.1441"></a><span id="l54.1441" class="difflineplus">+static int msgid_getdata(void* pTableData, void* key, void** ppData) {</span>
<a href="#l54.1442"></a><span id="l54.1442" class="difflineplus">+  ldapmemcacheReqId* pReqId = (ldapmemcacheReqId*)key;</span>
<a href="#l54.1443"></a><span id="l54.1443" class="difflineplus">+  ldapmemcacheRes* pCurRes = (ldapmemcacheRes*)pTableData;</span>
<a href="#l54.1444"></a><span id="l54.1444"> </span>
<a href="#l54.1445"></a><span id="l54.1445">   *ppData = NULL;</span>
<a href="#l54.1446"></a><span id="l54.1446"> </span>
<a href="#l54.1447"></a><span id="l54.1447">   for (; pCurRes; pCurRes = pCurRes-&gt;ldmemcr_htable_next) {</span>
<a href="#l54.1448"></a><span id="l54.1448">     if ((pCurRes-&gt;ldmemcr_req_id).ldmemcrid_ld == pReqId-&gt;ldmemcrid_ld) break;</span>
<a href="#l54.1449"></a><span id="l54.1449">   }</span>
<a href="#l54.1450"></a><span id="l54.1450"> </span>
<a href="#l54.1451"></a><span id="l54.1451">   if (!pCurRes) return (LDAP_NO_SUCH_OBJECT);</span>
<a href="#l54.1452"></a><span id="l54.1452"> </span>
<a href="#l54.1453"></a><span id="l54.1453">   for (; pCurRes; pCurRes = pCurRes-&gt;ldmemcr_next[LIST_TTL]) {</span>
<a href="#l54.1454"></a><span id="l54.1454">     if ((pCurRes-&gt;ldmemcr_req_id).ldmemcrid_msgid == pReqId-&gt;ldmemcrid_msgid) {</span>
<a href="#l54.1455"></a><span id="l54.1455" class="difflineminus">-      *ppData = (void *)pCurRes;</span>
<a href="#l54.1456"></a><span id="l54.1456" class="difflineplus">+      *ppData = (void*)pCurRes;</span>
<a href="#l54.1457"></a><span id="l54.1457">       return (LDAP_SUCCESS);</span>
<a href="#l54.1458"></a><span id="l54.1458">     }</span>
<a href="#l54.1459"></a><span id="l54.1459">   }</span>
<a href="#l54.1460"></a><span id="l54.1460"> </span>
<a href="#l54.1461"></a><span id="l54.1461">   return (LDAP_NO_SUCH_OBJECT);</span>
<a href="#l54.1462"></a><span id="l54.1462"> }</span>
<a href="#l54.1463"></a><span id="l54.1463"> </span>
<a href="#l54.1464"></a><span id="l54.1464"> /* Called by hash table to remove an item. */</span>
<a href="#l54.1465"></a><span id="l54.1465" class="difflineminus">-static int msgid_removedata(void **ppTableData, void *key, void **ppData) {</span>
<a href="#l54.1466"></a><span id="l54.1466" class="difflineminus">-  ldapmemcacheRes *pHead = *((ldapmemcacheRes **)ppTableData);</span>
<a href="#l54.1467"></a><span id="l54.1467" class="difflineminus">-  ldapmemcacheRes *pCurRes = NULL;</span>
<a href="#l54.1468"></a><span id="l54.1468" class="difflineminus">-  ldapmemcacheRes *pPrev = NULL;</span>
<a href="#l54.1469"></a><span id="l54.1469" class="difflineminus">-  ldapmemcacheReqId *pReqId = (ldapmemcacheReqId *)key;</span>
<a href="#l54.1470"></a><span id="l54.1470" class="difflineplus">+static int msgid_removedata(void** ppTableData, void* key, void** ppData) {</span>
<a href="#l54.1471"></a><span id="l54.1471" class="difflineplus">+  ldapmemcacheRes* pHead = *((ldapmemcacheRes**)ppTableData);</span>
<a href="#l54.1472"></a><span id="l54.1472" class="difflineplus">+  ldapmemcacheRes* pCurRes = NULL;</span>
<a href="#l54.1473"></a><span id="l54.1473" class="difflineplus">+  ldapmemcacheRes* pPrev = NULL;</span>
<a href="#l54.1474"></a><span id="l54.1474" class="difflineplus">+  ldapmemcacheReqId* pReqId = (ldapmemcacheReqId*)key;</span>
<a href="#l54.1475"></a><span id="l54.1475"> </span>
<a href="#l54.1476"></a><span id="l54.1476">   if (ppData) *ppData = NULL;</span>
<a href="#l54.1477"></a><span id="l54.1477"> </span>
<a href="#l54.1478"></a><span id="l54.1478">   for (; pHead; pHead = pHead-&gt;ldmemcr_htable_next) {</span>
<a href="#l54.1479"></a><span id="l54.1479">     if ((pHead-&gt;ldmemcr_req_id).ldmemcrid_ld == pReqId-&gt;ldmemcrid_ld) break;</span>
<a href="#l54.1480"></a><span id="l54.1480">     pPrev = pHead;</span>
<a href="#l54.1481"></a><span id="l54.1481">   }</span>
<a href="#l54.1482"></a><span id="l54.1482"> </span>
<a href="#l54.1483"></a><span id="l54.1483" class="difflineat">@@ -1800,17 +1800,17 @@ static int msgid_removedata(void **ppTab</span>
<a href="#l54.1484"></a><span id="l54.1484">   }</span>
<a href="#l54.1485"></a><span id="l54.1485"> </span>
<a href="#l54.1486"></a><span id="l54.1486">   if (!pCurRes) return (LDAP_NO_SUCH_OBJECT);</span>
<a href="#l54.1487"></a><span id="l54.1487"> </span>
<a href="#l54.1488"></a><span id="l54.1488">   if (ppData) {</span>
<a href="#l54.1489"></a><span id="l54.1489">     pCurRes-&gt;ldmemcr_next[LIST_TTL] = NULL;</span>
<a href="#l54.1490"></a><span id="l54.1490">     pCurRes-&gt;ldmemcr_prev[LIST_TTL] = NULL;</span>
<a href="#l54.1491"></a><span id="l54.1491">     pCurRes-&gt;ldmemcr_htable_next = NULL;</span>
<a href="#l54.1492"></a><span id="l54.1492" class="difflineminus">-    *ppData = (void *)pCurRes;</span>
<a href="#l54.1493"></a><span id="l54.1493" class="difflineplus">+    *ppData = (void*)pCurRes;</span>
<a href="#l54.1494"></a><span id="l54.1494">   }</span>
<a href="#l54.1495"></a><span id="l54.1495"> </span>
<a href="#l54.1496"></a><span id="l54.1496">   if (pCurRes != pHead) {</span>
<a href="#l54.1497"></a><span id="l54.1497">     if (pCurRes-&gt;ldmemcr_prev[LIST_TTL])</span>
<a href="#l54.1498"></a><span id="l54.1498">       pCurRes-&gt;ldmemcr_prev[LIST_TTL]-&gt;ldmemcr_next[LIST_TTL] =</span>
<a href="#l54.1499"></a><span id="l54.1499">           pCurRes-&gt;ldmemcr_next[LIST_TTL];</span>
<a href="#l54.1500"></a><span id="l54.1500">     if (pCurRes-&gt;ldmemcr_next[LIST_TTL])</span>
<a href="#l54.1501"></a><span id="l54.1501">       pCurRes-&gt;ldmemcr_next[LIST_TTL]-&gt;ldmemcr_prev[LIST_TTL] =</span>
<a href="#l54.1502"></a><span id="l54.1502" class="difflineat">@@ -1823,144 +1823,144 @@ static int msgid_removedata(void **ppTab</span>
<a href="#l54.1503"></a><span id="l54.1503">       pPrev-&gt;ldmemcr_htable_next = pHead-&gt;ldmemcr_next[LIST_TTL];</span>
<a href="#l54.1504"></a><span id="l54.1504">       pHead-&gt;ldmemcr_next[LIST_TTL]-&gt;ldmemcr_htable_next =</span>
<a href="#l54.1505"></a><span id="l54.1505">           pHead-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1506"></a><span id="l54.1506">     } else {</span>
<a href="#l54.1507"></a><span id="l54.1507">       pPrev-&gt;ldmemcr_htable_next = pHead-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1508"></a><span id="l54.1508">     }</span>
<a href="#l54.1509"></a><span id="l54.1509">   } else {</span>
<a href="#l54.1510"></a><span id="l54.1510">     if (pHead-&gt;ldmemcr_next[LIST_TTL]) {</span>
<a href="#l54.1511"></a><span id="l54.1511" class="difflineminus">-      *((ldapmemcacheRes **)ppTableData) = pHead-&gt;ldmemcr_next[LIST_TTL];</span>
<a href="#l54.1512"></a><span id="l54.1512" class="difflineplus">+      *((ldapmemcacheRes**)ppTableData) = pHead-&gt;ldmemcr_next[LIST_TTL];</span>
<a href="#l54.1513"></a><span id="l54.1513">       pHead-&gt;ldmemcr_next[LIST_TTL]-&gt;ldmemcr_htable_next =</span>
<a href="#l54.1514"></a><span id="l54.1514">           pHead-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1515"></a><span id="l54.1515">     } else {</span>
<a href="#l54.1516"></a><span id="l54.1516" class="difflineminus">-      *((ldapmemcacheRes **)ppTableData) = pHead-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1517"></a><span id="l54.1517" class="difflineplus">+      *((ldapmemcacheRes**)ppTableData) = pHead-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1518"></a><span id="l54.1518">     }</span>
<a href="#l54.1519"></a><span id="l54.1519">   }</span>
<a href="#l54.1520"></a><span id="l54.1520"> </span>
<a href="#l54.1521"></a><span id="l54.1521">   return (LDAP_SUCCESS);</span>
<a href="#l54.1522"></a><span id="l54.1522"> }</span>
<a href="#l54.1523"></a><span id="l54.1523"> </span>
<a href="#l54.1524"></a><span id="l54.1524"> /* Called by hash table to remove all cached entries associated to searches</span>
<a href="#l54.1525"></a><span id="l54.1525">    being performed using the given ldap handle. */</span>
<a href="#l54.1526"></a><span id="l54.1526" class="difflineminus">-static int msgid_clear_ld_items(void **ppTableData, void *key, void *pData) {</span>
<a href="#l54.1527"></a><span id="l54.1527" class="difflineminus">-  LDAPMemCache *cache = (LDAPMemCache *)pData;</span>
<a href="#l54.1528"></a><span id="l54.1528" class="difflineminus">-  ldapmemcacheRes *pHead = *((ldapmemcacheRes **)ppTableData);</span>
<a href="#l54.1529"></a><span id="l54.1529" class="difflineminus">-  ldapmemcacheRes *pPrev = NULL;</span>
<a href="#l54.1530"></a><span id="l54.1530" class="difflineminus">-  ldapmemcacheRes *pCurRes = NULL;</span>
<a href="#l54.1531"></a><span id="l54.1531" class="difflineminus">-  ldapmemcacheReqId *pReqId = (ldapmemcacheReqId *)key;</span>
<a href="#l54.1532"></a><span id="l54.1532" class="difflineplus">+static int msgid_clear_ld_items(void** ppTableData, void* key, void* pData) {</span>
<a href="#l54.1533"></a><span id="l54.1533" class="difflineplus">+  LDAPMemCache* cache = (LDAPMemCache*)pData;</span>
<a href="#l54.1534"></a><span id="l54.1534" class="difflineplus">+  ldapmemcacheRes* pHead = *((ldapmemcacheRes**)ppTableData);</span>
<a href="#l54.1535"></a><span id="l54.1535" class="difflineplus">+  ldapmemcacheRes* pPrev = NULL;</span>
<a href="#l54.1536"></a><span id="l54.1536" class="difflineplus">+  ldapmemcacheRes* pCurRes = NULL;</span>
<a href="#l54.1537"></a><span id="l54.1537" class="difflineplus">+  ldapmemcacheReqId* pReqId = (ldapmemcacheReqId*)key;</span>
<a href="#l54.1538"></a><span id="l54.1538"> </span>
<a href="#l54.1539"></a><span id="l54.1539">   for (; pHead; pHead = pHead-&gt;ldmemcr_htable_next) {</span>
<a href="#l54.1540"></a><span id="l54.1540">     if ((pHead-&gt;ldmemcr_req_id).ldmemcrid_ld == pReqId-&gt;ldmemcrid_ld) break;</span>
<a href="#l54.1541"></a><span id="l54.1541">     pPrev = pHead;</span>
<a href="#l54.1542"></a><span id="l54.1542">   }</span>
<a href="#l54.1543"></a><span id="l54.1543"> </span>
<a href="#l54.1544"></a><span id="l54.1544">   if (!pHead) return (LDAP_NO_SUCH_OBJECT);</span>
<a href="#l54.1545"></a><span id="l54.1545"> </span>
<a href="#l54.1546"></a><span id="l54.1546">   if (pPrev)</span>
<a href="#l54.1547"></a><span id="l54.1547">     pPrev-&gt;ldmemcr_htable_next = pHead-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1548"></a><span id="l54.1548">   else</span>
<a href="#l54.1549"></a><span id="l54.1549" class="difflineminus">-    *((ldapmemcacheRes **)ppTableData) = pHead-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1550"></a><span id="l54.1550" class="difflineplus">+    *((ldapmemcacheRes**)ppTableData) = pHead-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1551"></a><span id="l54.1551"> </span>
<a href="#l54.1552"></a><span id="l54.1552">   for (pCurRes = pHead; pHead; pCurRes = pHead) {</span>
<a href="#l54.1553"></a><span id="l54.1553">     pHead = pHead-&gt;ldmemcr_next[LIST_TTL];</span>
<a href="#l54.1554"></a><span id="l54.1554">     memcache_free_from_list(cache, pCurRes, LIST_TMP);</span>
<a href="#l54.1555"></a><span id="l54.1555">     memcache_free_entry(cache, pCurRes);</span>
<a href="#l54.1556"></a><span id="l54.1556">   }</span>
<a href="#l54.1557"></a><span id="l54.1557"> </span>
<a href="#l54.1558"></a><span id="l54.1558">   return (LDAP_SUCCESS);</span>
<a href="#l54.1559"></a><span id="l54.1559"> }</span>
<a href="#l54.1560"></a><span id="l54.1560"> </span>
<a href="#l54.1561"></a><span id="l54.1561"> /* Called by hash table for removing all items in the table. */</span>
<a href="#l54.1562"></a><span id="l54.1562" class="difflineminus">-static void msgid_clearnode(void **ppTableData, void *pData) {</span>
<a href="#l54.1563"></a><span id="l54.1563" class="difflineminus">-  LDAPMemCache *cache = (LDAPMemCache *)pData;</span>
<a href="#l54.1564"></a><span id="l54.1564" class="difflineminus">-  ldapmemcacheRes **ppHead = (ldapmemcacheRes **)ppTableData;</span>
<a href="#l54.1565"></a><span id="l54.1565" class="difflineminus">-  ldapmemcacheRes *pSubHead = *ppHead;</span>
<a href="#l54.1566"></a><span id="l54.1566" class="difflineminus">-  ldapmemcacheRes *pCurRes = NULL;</span>
<a href="#l54.1567"></a><span id="l54.1567" class="difflineplus">+static void msgid_clearnode(void** ppTableData, void* pData) {</span>
<a href="#l54.1568"></a><span id="l54.1568" class="difflineplus">+  LDAPMemCache* cache = (LDAPMemCache*)pData;</span>
<a href="#l54.1569"></a><span id="l54.1569" class="difflineplus">+  ldapmemcacheRes** ppHead = (ldapmemcacheRes**)ppTableData;</span>
<a href="#l54.1570"></a><span id="l54.1570" class="difflineplus">+  ldapmemcacheRes* pSubHead = *ppHead;</span>
<a href="#l54.1571"></a><span id="l54.1571" class="difflineplus">+  ldapmemcacheRes* pCurRes = NULL;</span>
<a href="#l54.1572"></a><span id="l54.1572"> </span>
<a href="#l54.1573"></a><span id="l54.1573">   for (; *ppHead; pSubHead = *ppHead) {</span>
<a href="#l54.1574"></a><span id="l54.1574">     ppHead = &amp;((*ppHead)-&gt;ldmemcr_htable_next);</span>
<a href="#l54.1575"></a><span id="l54.1575">     for (pCurRes = pSubHead; pSubHead; pCurRes = pSubHead) {</span>
<a href="#l54.1576"></a><span id="l54.1576">       pSubHead = pSubHead-&gt;ldmemcr_next[LIST_TTL];</span>
<a href="#l54.1577"></a><span id="l54.1577">       memcache_free_from_list(cache, pCurRes, LIST_TMP);</span>
<a href="#l54.1578"></a><span id="l54.1578">       memcache_free_entry(cache, pCurRes);</span>
<a href="#l54.1579"></a><span id="l54.1579">     }</span>
<a href="#l54.1580"></a><span id="l54.1580">   }</span>
<a href="#l54.1581"></a><span id="l54.1581"> }</span>
<a href="#l54.1582"></a><span id="l54.1582"> </span>
<a href="#l54.1583"></a><span id="l54.1583"> /********************* Hash table for primary cache ************************/</span>
<a href="#l54.1584"></a><span id="l54.1584"> </span>
<a href="#l54.1585"></a><span id="l54.1585"> /* Hash function */</span>
<a href="#l54.1586"></a><span id="l54.1586" class="difflineminus">-static int attrkey_hashf(int table_size, void *key) {</span>
<a href="#l54.1587"></a><span id="l54.1587" class="difflineminus">-  return ((*((unsigned long *)key)) % table_size);</span>
<a href="#l54.1588"></a><span id="l54.1588" class="difflineplus">+static int attrkey_hashf(int table_size, void* key) {</span>
<a href="#l54.1589"></a><span id="l54.1589" class="difflineplus">+  return ((*((unsigned long*)key)) % table_size);</span>
<a href="#l54.1590"></a><span id="l54.1590"> }</span>
<a href="#l54.1591"></a><span id="l54.1591"> </span>
<a href="#l54.1592"></a><span id="l54.1592"> /* Called by hash table to insert an item. */</span>
<a href="#l54.1593"></a><span id="l54.1593" class="difflineminus">-static int attrkey_putdata(void **ppTableData, void *key, void *pData) {</span>
<a href="#l54.1594"></a><span id="l54.1594" class="difflineminus">-  unsigned long attrkey = *((unsigned long *)key);</span>
<a href="#l54.1595"></a><span id="l54.1595" class="difflineminus">-  ldapmemcacheRes **ppHead = (ldapmemcacheRes **)ppTableData;</span>
<a href="#l54.1596"></a><span id="l54.1596" class="difflineminus">-  ldapmemcacheRes *pRes = *ppHead;</span>
<a href="#l54.1597"></a><span id="l54.1597" class="difflineplus">+static int attrkey_putdata(void** ppTableData, void* key, void* pData) {</span>
<a href="#l54.1598"></a><span id="l54.1598" class="difflineplus">+  unsigned long attrkey = *((unsigned long*)key);</span>
<a href="#l54.1599"></a><span id="l54.1599" class="difflineplus">+  ldapmemcacheRes** ppHead = (ldapmemcacheRes**)ppTableData;</span>
<a href="#l54.1600"></a><span id="l54.1600" class="difflineplus">+  ldapmemcacheRes* pRes = *ppHead;</span>
<a href="#l54.1601"></a><span id="l54.1601"> </span>
<a href="#l54.1602"></a><span id="l54.1602">   for (; pRes; pRes = pRes-&gt;ldmemcr_htable_next) {</span>
<a href="#l54.1603"></a><span id="l54.1603">     if (pRes-&gt;ldmemcr_crc_key == attrkey) return (LDAP_ALREADY_EXISTS);</span>
<a href="#l54.1604"></a><span id="l54.1604">   }</span>
<a href="#l54.1605"></a><span id="l54.1605"> </span>
<a href="#l54.1606"></a><span id="l54.1606" class="difflineminus">-  pRes = (ldapmemcacheRes *)pData;</span>
<a href="#l54.1607"></a><span id="l54.1607" class="difflineplus">+  pRes = (ldapmemcacheRes*)pData;</span>
<a href="#l54.1608"></a><span id="l54.1608">   pRes-&gt;ldmemcr_htable_next = *ppHead;</span>
<a href="#l54.1609"></a><span id="l54.1609">   *ppHead = pRes;</span>
<a href="#l54.1610"></a><span id="l54.1610"> </span>
<a href="#l54.1611"></a><span id="l54.1611">   return (LDAP_SUCCESS);</span>
<a href="#l54.1612"></a><span id="l54.1612"> }</span>
<a href="#l54.1613"></a><span id="l54.1613"> </span>
<a href="#l54.1614"></a><span id="l54.1614"> /* Called by hash table to retrieve an item. */</span>
<a href="#l54.1615"></a><span id="l54.1615" class="difflineminus">-static int attrkey_getdata(void *pTableData, void *key, void **ppData) {</span>
<a href="#l54.1616"></a><span id="l54.1616" class="difflineminus">-  unsigned long attrkey = *((unsigned long *)key);</span>
<a href="#l54.1617"></a><span id="l54.1617" class="difflineminus">-  ldapmemcacheRes *pRes = (ldapmemcacheRes *)pTableData;</span>
<a href="#l54.1618"></a><span id="l54.1618" class="difflineplus">+static int attrkey_getdata(void* pTableData, void* key, void** ppData) {</span>
<a href="#l54.1619"></a><span id="l54.1619" class="difflineplus">+  unsigned long attrkey = *((unsigned long*)key);</span>
<a href="#l54.1620"></a><span id="l54.1620" class="difflineplus">+  ldapmemcacheRes* pRes = (ldapmemcacheRes*)pTableData;</span>
<a href="#l54.1621"></a><span id="l54.1621"> </span>
<a href="#l54.1622"></a><span id="l54.1622">   for (; pRes; pRes = pRes-&gt;ldmemcr_htable_next) {</span>
<a href="#l54.1623"></a><span id="l54.1623">     if (pRes-&gt;ldmemcr_crc_key == attrkey) {</span>
<a href="#l54.1624"></a><span id="l54.1624" class="difflineminus">-      *ppData = (void *)pRes;</span>
<a href="#l54.1625"></a><span id="l54.1625" class="difflineplus">+      *ppData = (void*)pRes;</span>
<a href="#l54.1626"></a><span id="l54.1626">       return (LDAP_SUCCESS);</span>
<a href="#l54.1627"></a><span id="l54.1627">     }</span>
<a href="#l54.1628"></a><span id="l54.1628">   }</span>
<a href="#l54.1629"></a><span id="l54.1629"> </span>
<a href="#l54.1630"></a><span id="l54.1630">   *ppData = NULL;</span>
<a href="#l54.1631"></a><span id="l54.1631"> </span>
<a href="#l54.1632"></a><span id="l54.1632">   return (LDAP_NO_SUCH_OBJECT);</span>
<a href="#l54.1633"></a><span id="l54.1633"> }</span>
<a href="#l54.1634"></a><span id="l54.1634"> </span>
<a href="#l54.1635"></a><span id="l54.1635"> /* Called by hash table to remove an item. */</span>
<a href="#l54.1636"></a><span id="l54.1636" class="difflineminus">-static int attrkey_removedata(void **ppTableData, void *key, void **ppData) {</span>
<a href="#l54.1637"></a><span id="l54.1637" class="difflineminus">-  unsigned long attrkey = *((unsigned long *)key);</span>
<a href="#l54.1638"></a><span id="l54.1638" class="difflineminus">-  ldapmemcacheRes **ppHead = (ldapmemcacheRes **)ppTableData;</span>
<a href="#l54.1639"></a><span id="l54.1639" class="difflineminus">-  ldapmemcacheRes *pRes = *ppHead;</span>
<a href="#l54.1640"></a><span id="l54.1640" class="difflineminus">-  ldapmemcacheRes *pPrev = NULL;</span>
<a href="#l54.1641"></a><span id="l54.1641" class="difflineplus">+static int attrkey_removedata(void** ppTableData, void* key, void** ppData) {</span>
<a href="#l54.1642"></a><span id="l54.1642" class="difflineplus">+  unsigned long attrkey = *((unsigned long*)key);</span>
<a href="#l54.1643"></a><span id="l54.1643" class="difflineplus">+  ldapmemcacheRes** ppHead = (ldapmemcacheRes**)ppTableData;</span>
<a href="#l54.1644"></a><span id="l54.1644" class="difflineplus">+  ldapmemcacheRes* pRes = *ppHead;</span>
<a href="#l54.1645"></a><span id="l54.1645" class="difflineplus">+  ldapmemcacheRes* pPrev = NULL;</span>
<a href="#l54.1646"></a><span id="l54.1646"> </span>
<a href="#l54.1647"></a><span id="l54.1647">   for (; pRes; pRes = pRes-&gt;ldmemcr_htable_next) {</span>
<a href="#l54.1648"></a><span id="l54.1648">     if (pRes-&gt;ldmemcr_crc_key == attrkey) {</span>
<a href="#l54.1649"></a><span id="l54.1649" class="difflineminus">-      if (ppData) *ppData = (void *)pRes;</span>
<a href="#l54.1650"></a><span id="l54.1650" class="difflineplus">+      if (ppData) *ppData = (void*)pRes;</span>
<a href="#l54.1651"></a><span id="l54.1651">       if (pPrev)</span>
<a href="#l54.1652"></a><span id="l54.1652">         pPrev-&gt;ldmemcr_htable_next = pRes-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1653"></a><span id="l54.1653">       else</span>
<a href="#l54.1654"></a><span id="l54.1654">         *ppHead = pRes-&gt;ldmemcr_htable_next;</span>
<a href="#l54.1655"></a><span id="l54.1655">       pRes-&gt;ldmemcr_htable_next = NULL;</span>
<a href="#l54.1656"></a><span id="l54.1656">       return (LDAP_SUCCESS);</span>
<a href="#l54.1657"></a><span id="l54.1657">     }</span>
<a href="#l54.1658"></a><span id="l54.1658">     pPrev = pRes;</span>
<a href="#l54.1659"></a><span id="l54.1659">   }</span>
<a href="#l54.1660"></a><span id="l54.1660"> </span>
<a href="#l54.1661"></a><span id="l54.1661">   if (ppData) *ppData = NULL;</span>
<a href="#l54.1662"></a><span id="l54.1662"> </span>
<a href="#l54.1663"></a><span id="l54.1663">   return (LDAP_NO_SUCH_OBJECT);</span>
<a href="#l54.1664"></a><span id="l54.1664"> }</span>
<a href="#l54.1665"></a><span id="l54.1665"> </span>
<a href="#l54.1666"></a><span id="l54.1666"> /* Called by hash table for removing all items in the table. */</span>
<a href="#l54.1667"></a><span id="l54.1667" class="difflineminus">-static void attrkey_clearnode(void **ppTableData, void *pData) {</span>
<a href="#l54.1668"></a><span id="l54.1668" class="difflineminus">-  ldapmemcacheRes **ppHead = (ldapmemcacheRes **)ppTableData;</span>
<a href="#l54.1669"></a><span id="l54.1669" class="difflineminus">-  ldapmemcacheRes *pRes = *ppHead;</span>
<a href="#l54.1670"></a><span id="l54.1670" class="difflineplus">+static void attrkey_clearnode(void** ppTableData, void* pData) {</span>
<a href="#l54.1671"></a><span id="l54.1671" class="difflineplus">+  ldapmemcacheRes** ppHead = (ldapmemcacheRes**)ppTableData;</span>
<a href="#l54.1672"></a><span id="l54.1672" class="difflineplus">+  ldapmemcacheRes* pRes = *ppHead;</span>
<a href="#l54.1673"></a><span id="l54.1673"> </span>
<a href="#l54.1674"></a><span id="l54.1674">   (void)pData;</span>
<a href="#l54.1675"></a><span id="l54.1675"> </span>
<a href="#l54.1676"></a><span id="l54.1676">   for (; *ppHead; pRes = *ppHead) {</span>
<a href="#l54.1677"></a><span id="l54.1677">     ppHead = &amp;((*ppHead)-&gt;ldmemcr_htable_next);</span>
<a href="#l54.1678"></a><span id="l54.1678">     pRes-&gt;ldmemcr_htable_next = NULL;</span>
<a href="#l54.1679"></a><span id="l54.1679">   }</span>
<a href="#l54.1680"></a><span id="l54.1680"> }</span>
<a href="#l54.1681"></a><span id="l54.1681" class="difflineat">@@ -2018,18 +2018,18 @@ static nsldapi_uint_32 crc32_table[256] </span>
<a href="#l54.1682"></a><span id="l54.1682">     0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,</span>
<a href="#l54.1683"></a><span id="l54.1683">     0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,</span>
<a href="#l54.1684"></a><span id="l54.1684">     0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4};</span>
<a href="#l54.1685"></a><span id="l54.1685"> </span>
<a href="#l54.1686"></a><span id="l54.1686"> /* Initialized first time &quot;crc32()&quot; is called. If you prefer, you can</span>
<a href="#l54.1687"></a><span id="l54.1687">  * statically initialize it at compile time. [Another exercise.]</span>
<a href="#l54.1688"></a><span id="l54.1688">  */</span>
<a href="#l54.1689"></a><span id="l54.1689"> </span>
<a href="#l54.1690"></a><span id="l54.1690" class="difflineminus">-static unsigned long crc32_convert(char *buf, int len) {</span>
<a href="#l54.1691"></a><span id="l54.1691" class="difflineminus">-  unsigned char *p;</span>
<a href="#l54.1692"></a><span id="l54.1692" class="difflineplus">+static unsigned long crc32_convert(char* buf, int len) {</span>
<a href="#l54.1693"></a><span id="l54.1693" class="difflineplus">+  unsigned char* p;</span>
<a href="#l54.1694"></a><span id="l54.1694">   nsldapi_uint_32 crc;</span>
<a href="#l54.1695"></a><span id="l54.1695"> </span>
<a href="#l54.1696"></a><span id="l54.1696">   crc = 0xffffffff; /* preload shift register, per CRC-32 spec */</span>
<a href="#l54.1697"></a><span id="l54.1697" class="difflineminus">-  for (p = (unsigned char *)buf; len &gt; 0; ++p, --len)</span>
<a href="#l54.1698"></a><span id="l54.1698" class="difflineplus">+  for (p = (unsigned char*)buf; len &gt; 0; ++p, --len)</span>
<a href="#l54.1699"></a><span id="l54.1699">     crc = ((crc &lt;&lt; 8) ^ crc32_table[(crc &gt;&gt; 24) ^ *p]) &amp; 0xffffffff;</span>
<a href="#l54.1700"></a><span id="l54.1700"> </span>
<a href="#l54.1701"></a><span id="l54.1701">   return (unsigned long)~crc; /* transmit complement, per CRC-32 spec */</span>
<a href="#l54.1702"></a><span id="l54.1702"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l55.1"></a><span id="l55.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/message.c</span>
<a href="#l55.2"></a><span id="l55.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/message.c</span>
<a href="#l55.3"></a><span id="l55.3" class="difflineat">@@ -31,53 +31,53 @@</span>
<a href="#l55.4"></a><span id="l55.4">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l55.5"></a><span id="l55.5">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l55.6"></a><span id="l55.6">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l55.7"></a><span id="l55.7">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l55.8"></a><span id="l55.8">  *</span>
<a href="#l55.9"></a><span id="l55.9">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l55.10"></a><span id="l55.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l55.11"></a><span id="l55.11"> </span>
<a href="#l55.12"></a><span id="l55.12" class="difflineminus">-int LDAP_CALL ldap_msgid(LDAPMessage *lm) {</span>
<a href="#l55.13"></a><span id="l55.13" class="difflineplus">+int LDAP_CALL ldap_msgid(LDAPMessage* lm) {</span>
<a href="#l55.14"></a><span id="l55.14">   if (!NSLDAPI_VALID_LDAPMESSAGE_POINTER(lm)) {</span>
<a href="#l55.15"></a><span id="l55.15">     return (-1);</span>
<a href="#l55.16"></a><span id="l55.16">   }</span>
<a href="#l55.17"></a><span id="l55.17"> </span>
<a href="#l55.18"></a><span id="l55.18">   return (lm-&gt;lm_msgid);</span>
<a href="#l55.19"></a><span id="l55.19"> }</span>
<a href="#l55.20"></a><span id="l55.20"> </span>
<a href="#l55.21"></a><span id="l55.21" class="difflineminus">-int LDAP_CALL ldap_msgtype(LDAPMessage *lm) {</span>
<a href="#l55.22"></a><span id="l55.22" class="difflineplus">+int LDAP_CALL ldap_msgtype(LDAPMessage* lm) {</span>
<a href="#l55.23"></a><span id="l55.23">   if (!NSLDAPI_VALID_LDAPMESSAGE_POINTER(lm)) {</span>
<a href="#l55.24"></a><span id="l55.24">     return (-1);</span>
<a href="#l55.25"></a><span id="l55.25">   }</span>
<a href="#l55.26"></a><span id="l55.26"> </span>
<a href="#l55.27"></a><span id="l55.27">   return (lm-&gt;lm_msgtype);</span>
<a href="#l55.28"></a><span id="l55.28"> }</span>
<a href="#l55.29"></a><span id="l55.29"> </span>
<a href="#l55.30"></a><span id="l55.30" class="difflineminus">-LDAPMessage *LDAP_CALL ldap_first_message(LDAP *ld, LDAPMessage *chain) {</span>
<a href="#l55.31"></a><span id="l55.31" class="difflineplus">+LDAPMessage* LDAP_CALL ldap_first_message(LDAP* ld, LDAPMessage* chain) {</span>
<a href="#l55.32"></a><span id="l55.32">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l55.33"></a><span id="l55.33">     return (NULLMSG); /* punt */</span>
<a href="#l55.34"></a><span id="l55.34">   }</span>
<a href="#l55.35"></a><span id="l55.35"> </span>
<a href="#l55.36"></a><span id="l55.36">   return (chain);</span>
<a href="#l55.37"></a><span id="l55.37"> }</span>
<a href="#l55.38"></a><span id="l55.38"> </span>
<a href="#l55.39"></a><span id="l55.39" class="difflineminus">-LDAPMessage *LDAP_CALL ldap_next_message(LDAP *ld, LDAPMessage *msg) {</span>
<a href="#l55.40"></a><span id="l55.40" class="difflineplus">+LDAPMessage* LDAP_CALL ldap_next_message(LDAP* ld, LDAPMessage* msg) {</span>
<a href="#l55.41"></a><span id="l55.41">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l55.42"></a><span id="l55.42">     return (NULLMSG); /* punt */</span>
<a href="#l55.43"></a><span id="l55.43">   }</span>
<a href="#l55.44"></a><span id="l55.44"> </span>
<a href="#l55.45"></a><span id="l55.45">   if (msg == NULLMSG || msg-&gt;lm_chain == NULLMSG) {</span>
<a href="#l55.46"></a><span id="l55.46">     return (NULLMSG);</span>
<a href="#l55.47"></a><span id="l55.47">   }</span>
<a href="#l55.48"></a><span id="l55.48"> </span>
<a href="#l55.49"></a><span id="l55.49">   return (msg-&gt;lm_chain);</span>
<a href="#l55.50"></a><span id="l55.50"> }</span>
<a href="#l55.51"></a><span id="l55.51"> </span>
<a href="#l55.52"></a><span id="l55.52" class="difflineminus">-int LDAP_CALL ldap_count_messages(LDAP *ld, LDAPMessage *chain) {</span>
<a href="#l55.53"></a><span id="l55.53" class="difflineplus">+int LDAP_CALL ldap_count_messages(LDAP* ld, LDAPMessage* chain) {</span>
<a href="#l55.54"></a><span id="l55.54">   int i;</span>
<a href="#l55.55"></a><span id="l55.55"> </span>
<a href="#l55.56"></a><span id="l55.56">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l55.57"></a><span id="l55.57">     return (-1);</span>
<a href="#l55.58"></a><span id="l55.58">   }</span>
<a href="#l55.59"></a><span id="l55.59"> </span>
<a href="#l55.60"></a><span id="l55.60">   for (i = 0; chain != NULL; chain = chain-&gt;lm_chain) {</span>
<a href="#l55.61"></a><span id="l55.61">     i++;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l56.1"></a><span id="l56.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/modify.c</span>
<a href="#l56.2"></a><span id="l56.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/modify.c</span>
<a href="#l56.3"></a><span id="l56.3" class="difflineat">@@ -62,32 +62,32 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l56.4"></a><span id="l56.4">  * Example:</span>
<a href="#l56.5"></a><span id="l56.5">  * LDAPMod  *mods[] = {</span>
<a href="#l56.6"></a><span id="l56.6">  *     { LDAP_MOD_ADD, &quot;cn&quot;, { &quot;babs jensen&quot;, &quot;babs&quot;, 0 } },</span>
<a href="#l56.7"></a><span id="l56.7">  *     { LDAP_MOD_REPLACE, &quot;sn&quot;, { &quot;jensen&quot;, 0 } },</span>
<a href="#l56.8"></a><span id="l56.8">  *     0</span>
<a href="#l56.9"></a><span id="l56.9">  *   }</span>
<a href="#l56.10"></a><span id="l56.10">  * msgid = ldap_modify(ld, dn, mods);</span>
<a href="#l56.11"></a><span id="l56.11">  */</span>
<a href="#l56.12"></a><span id="l56.12" class="difflineminus">-int LDAP_CALL ldap_modify(LDAP *ld, const char *dn, LDAPMod **mods) {</span>
<a href="#l56.13"></a><span id="l56.13" class="difflineplus">+int LDAP_CALL ldap_modify(LDAP* ld, const char* dn, LDAPMod** mods) {</span>
<a href="#l56.14"></a><span id="l56.14">   int msgid;</span>
<a href="#l56.15"></a><span id="l56.15"> </span>
<a href="#l56.16"></a><span id="l56.16">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_modify\n&quot;, 0, 0, 0);</span>
<a href="#l56.17"></a><span id="l56.17"> </span>
<a href="#l56.18"></a><span id="l56.18">   if (ldap_modify_ext(ld, dn, mods, NULL, NULL, &amp;msgid) == LDAP_SUCCESS) {</span>
<a href="#l56.19"></a><span id="l56.19">     return (msgid);</span>
<a href="#l56.20"></a><span id="l56.20">   } else {</span>
<a href="#l56.21"></a><span id="l56.21">     return (-1); /* error is in ld handle */</span>
<a href="#l56.22"></a><span id="l56.22">   }</span>
<a href="#l56.23"></a><span id="l56.23"> }</span>
<a href="#l56.24"></a><span id="l56.24"> </span>
<a href="#l56.25"></a><span id="l56.25" class="difflineminus">-int LDAP_CALL ldap_modify_ext(LDAP *ld, const char *dn, LDAPMod **mods,</span>
<a href="#l56.26"></a><span id="l56.26" class="difflineminus">-                              LDAPControl **serverctrls,</span>
<a href="#l56.27"></a><span id="l56.27" class="difflineminus">-                              LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l56.28"></a><span id="l56.28" class="difflineminus">-  BerElement *ber;</span>
<a href="#l56.29"></a><span id="l56.29" class="difflineplus">+int LDAP_CALL ldap_modify_ext(LDAP* ld, const char* dn, LDAPMod** mods,</span>
<a href="#l56.30"></a><span id="l56.30" class="difflineplus">+                              LDAPControl** serverctrls,</span>
<a href="#l56.31"></a><span id="l56.31" class="difflineplus">+                              LDAPControl** clientctrls, int* msgidp) {</span>
<a href="#l56.32"></a><span id="l56.32" class="difflineplus">+  BerElement* ber;</span>
<a href="#l56.33"></a><span id="l56.33">   int i, rc, lderr;</span>
<a href="#l56.34"></a><span id="l56.34"> </span>
<a href="#l56.35"></a><span id="l56.35">   /*</span>
<a href="#l56.36"></a><span id="l56.36">    * A modify request looks like this:</span>
<a href="#l56.37"></a><span id="l56.37">    * ModifyRequet ::= SEQUENCE {</span>
<a href="#l56.38"></a><span id="l56.38">    *   object DistinguishedName,</span>
<a href="#l56.39"></a><span id="l56.39">    *   modifications SEQUENCE OF SEQUENCE {</span>
<a href="#l56.40"></a><span id="l56.40">    *     operation ENUMERATED {</span>
<a href="#l56.41"></a><span id="l56.41" class="difflineat">@@ -176,35 +176,35 @@ int LDAP_CALL ldap_modify_ext(LDAP *ld, </span>
<a href="#l56.42"></a><span id="l56.42">   }</span>
<a href="#l56.43"></a><span id="l56.43"> </span>
<a href="#l56.44"></a><span id="l56.44">   if ((lderr = nsldapi_put_controls(ld, serverctrls, 1, ber)) != LDAP_SUCCESS) {</span>
<a href="#l56.45"></a><span id="l56.45">     ber_free(ber, 1);</span>
<a href="#l56.46"></a><span id="l56.46">     return (lderr);</span>
<a href="#l56.47"></a><span id="l56.47">   }</span>
<a href="#l56.48"></a><span id="l56.48"> </span>
<a href="#l56.49"></a><span id="l56.49">   /* send the message */</span>
<a href="#l56.50"></a><span id="l56.50" class="difflineminus">-  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_MODIFY, (char *)dn,</span>
<a href="#l56.51"></a><span id="l56.51" class="difflineplus">+  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_MODIFY, (char*)dn,</span>
<a href="#l56.52"></a><span id="l56.52">                                     ber);</span>
<a href="#l56.53"></a><span id="l56.53">   *msgidp = rc;</span>
<a href="#l56.54"></a><span id="l56.54">   return (rc &lt; 0 ? LDAP_GET_LDERRNO(ld, NULL, NULL) : LDAP_SUCCESS);</span>
<a href="#l56.55"></a><span id="l56.55"> }</span>
<a href="#l56.56"></a><span id="l56.56"> </span>
<a href="#l56.57"></a><span id="l56.57" class="difflineminus">-int LDAP_CALL ldap_modify_s(LDAP *ld, const char *dn, LDAPMod **mods) {</span>
<a href="#l56.58"></a><span id="l56.58" class="difflineplus">+int LDAP_CALL ldap_modify_s(LDAP* ld, const char* dn, LDAPMod** mods) {</span>
<a href="#l56.59"></a><span id="l56.59">   return (ldap_modify_ext_s(ld, dn, mods, NULL, NULL));</span>
<a href="#l56.60"></a><span id="l56.60"> }</span>
<a href="#l56.61"></a><span id="l56.61"> </span>
<a href="#l56.62"></a><span id="l56.62" class="difflineminus">-int LDAP_CALL ldap_modify_ext_s(LDAP *ld, const char *dn, LDAPMod **mods,</span>
<a href="#l56.63"></a><span id="l56.63" class="difflineminus">-                                LDAPControl **serverctrls,</span>
<a href="#l56.64"></a><span id="l56.64" class="difflineminus">-                                LDAPControl **clientctrls) {</span>
<a href="#l56.65"></a><span id="l56.65" class="difflineplus">+int LDAP_CALL ldap_modify_ext_s(LDAP* ld, const char* dn, LDAPMod** mods,</span>
<a href="#l56.66"></a><span id="l56.66" class="difflineplus">+                                LDAPControl** serverctrls,</span>
<a href="#l56.67"></a><span id="l56.67" class="difflineplus">+                                LDAPControl** clientctrls) {</span>
<a href="#l56.68"></a><span id="l56.68">   int msgid, err;</span>
<a href="#l56.69"></a><span id="l56.69" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l56.70"></a><span id="l56.70" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l56.71"></a><span id="l56.71"> </span>
<a href="#l56.72"></a><span id="l56.72">   if ((err = ldap_modify_ext(ld, dn, mods, serverctrls, clientctrls, &amp;msgid)) !=</span>
<a href="#l56.73"></a><span id="l56.73">       LDAP_SUCCESS) {</span>
<a href="#l56.74"></a><span id="l56.74">     return (err);</span>
<a href="#l56.75"></a><span id="l56.75">   }</span>
<a href="#l56.76"></a><span id="l56.76"> </span>
<a href="#l56.77"></a><span id="l56.77" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)NULL, &amp;res) == -1) {</span>
<a href="#l56.78"></a><span id="l56.78" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)NULL, &amp;res) == -1) {</span>
<a href="#l56.79"></a><span id="l56.79">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l56.80"></a><span id="l56.80">   }</span>
<a href="#l56.81"></a><span id="l56.81"> </span>
<a href="#l56.82"></a><span id="l56.82">   return (ldap_result2error(ld, res, 1));</span>
<a href="#l56.83"></a><span id="l56.83"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l57.1"></a><span id="l57.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/mozock.c</span>
<a href="#l57.2"></a><span id="l57.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/mozock.c</span>
<a href="#l57.3"></a><span id="l57.3" class="difflineat">@@ -98,17 +98,17 @@ enum SockProc {</span>
<a href="#l57.4"></a><span id="l57.4">   sp_inet_ntoa,</span>
<a href="#l57.5"></a><span id="l57.5"> </span>
<a href="#l57.6"></a><span id="l57.6">   sp_MaxProcs  // Total count.</span>
<a href="#l57.7"></a><span id="l57.7"> };</span>
<a href="#l57.8"></a><span id="l57.8"> </span>
<a href="#l57.9"></a><span id="l57.9"> // Array of function names used in GetProcAddress to fill in our</span>
<a href="#l57.10"></a><span id="l57.10"> // proc array when needed.</span>
<a href="#l57.11"></a><span id="l57.11"> // This array must match the enumerations exactly.</span>
<a href="#l57.12"></a><span id="l57.12" class="difflineminus">-char *spName[(int)sp_MaxProcs] = {&quot;WSAAsyncGetHostByName&quot;,</span>
<a href="#l57.13"></a><span id="l57.13" class="difflineplus">+char* spName[(int)sp_MaxProcs] = {&quot;WSAAsyncGetHostByName&quot;,</span>
<a href="#l57.14"></a><span id="l57.14">                                   &quot;WSAAsyncSelect&quot;,</span>
<a href="#l57.15"></a><span id="l57.15">                                   &quot;WSACleanup&quot;,</span>
<a href="#l57.16"></a><span id="l57.16">                                   &quot;WSAGetLastError&quot;,</span>
<a href="#l57.17"></a><span id="l57.17">                                   &quot;WSASetLastError&quot;,</span>
<a href="#l57.18"></a><span id="l57.18">                                   &quot;WSAStartup&quot;,</span>
<a href="#l57.19"></a><span id="l57.19">                                   &quot;__WSAFDIsSet&quot;,</span>
<a href="#l57.20"></a><span id="l57.20">                                   &quot;accept&quot;,</span>
<a href="#l57.21"></a><span id="l57.21">                                   &quot;bind&quot;,</span>
<a href="#l57.22"></a><span id="l57.22" class="difflineat">@@ -142,59 +142,58 @@ char *spName[(int)sp_MaxProcs] = {&quot;WSAAs</span>
<a href="#l57.23"></a><span id="l57.23"> // The procs assigned in must corellate with the enumerations exactly.</span>
<a href="#l57.24"></a><span id="l57.24"> FARPROC spArray[(int)sp_MaxProcs];</span>
<a href="#l57.25"></a><span id="l57.25"> </span>
<a href="#l57.26"></a><span id="l57.26"> // Typedef all the different types of functions that we must cast the</span>
<a href="#l57.27"></a><span id="l57.27"> // procs to in order to call without the compiler barfing.</span>
<a href="#l57.28"></a><span id="l57.28"> // Prefix is always sp.</span>
<a href="#l57.29"></a><span id="l57.29"> // Retval is next, spelled out.</span>
<a href="#l57.30"></a><span id="l57.30"> // Parameters in their order are next, spelled out.</span>
<a href="#l57.31"></a><span id="l57.31" class="difflineminus">-typedef int(PASCAL FAR *sp_int_WORD_LPWSADATA)(WORD, LPWSADATA);</span>
<a href="#l57.32"></a><span id="l57.32" class="difflineminus">-typedef int(PASCAL FAR *sp_int_void)(void);</span>
<a href="#l57.33"></a><span id="l57.33" class="difflineminus">-typedef HANDLE(PASCAL FAR *sp_HANDLE_HWND_uint_ccharFARp_charFARp_int)(</span>
<a href="#l57.34"></a><span id="l57.34" class="difflineminus">-    HWND, unsigned int, const char FAR *, char FAR *, int);</span>
<a href="#l57.35"></a><span id="l57.35" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_HWND_uint_long)(SOCKET, HWND,</span>
<a href="#l57.36"></a><span id="l57.36" class="difflineplus">+typedef int(PASCAL FAR* sp_int_WORD_LPWSADATA)(WORD, LPWSADATA);</span>
<a href="#l57.37"></a><span id="l57.37" class="difflineplus">+typedef int(PASCAL FAR* sp_int_void)(void);</span>
<a href="#l57.38"></a><span id="l57.38" class="difflineplus">+typedef HANDLE(PASCAL FAR* sp_HANDLE_HWND_uint_ccharFARp_charFARp_int)(</span>
<a href="#l57.39"></a><span id="l57.39" class="difflineplus">+    HWND, unsigned int, const char FAR*, char FAR*, int);</span>
<a href="#l57.40"></a><span id="l57.40" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_HWND_uint_long)(SOCKET, HWND,</span>
<a href="#l57.41"></a><span id="l57.41">                                                       unsigned int, long);</span>
<a href="#l57.42"></a><span id="l57.42" class="difflineminus">-typedef void(PASCAL FAR *sp_void_int)(int);</span>
<a href="#l57.43"></a><span id="l57.43" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_fdsetFARp)(SOCKET, fd_set FAR *);</span>
<a href="#l57.44"></a><span id="l57.44" class="difflineminus">-typedef SOCKET(PASCAL FAR *sp_SOCKET_SOCKET_sockaddrFARp_intFARp)(</span>
<a href="#l57.45"></a><span id="l57.45" class="difflineminus">-    SOCKET, struct sockaddr FAR *, int FAR *);</span>
<a href="#l57.46"></a><span id="l57.46" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_csockaddrFARp_int)(</span>
<a href="#l57.47"></a><span id="l57.47" class="difflineminus">-    SOCKET, const struct sockaddr FAR *, int);</span>
<a href="#l57.48"></a><span id="l57.48" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET)(SOCKET);</span>
<a href="#l57.49"></a><span id="l57.49" class="difflineminus">-typedef struct hostent FAR *(PASCAL FAR *sp_hostentFARp_ccharFARp)(</span>
<a href="#l57.50"></a><span id="l57.50" class="difflineminus">-    const char FAR *);</span>
<a href="#l57.51"></a><span id="l57.51" class="difflineminus">-typedef struct hostent FAR *(PASCAL FAR *sp_hostentFARp_ccharFARp_int_int)(</span>
<a href="#l57.52"></a><span id="l57.52" class="difflineminus">-    const char FAR *, int, int);</span>
<a href="#l57.53"></a><span id="l57.53" class="difflineminus">-typedef int(PASCAL FAR *sp_int_charFARp_int)(char FAR *, int);</span>
<a href="#l57.54"></a><span id="l57.54" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_sockaddrFARp_intFARp)(</span>
<a href="#l57.55"></a><span id="l57.55" class="difflineminus">-    SOCKET, struct sockaddr FAR *, int FAR *);</span>
<a href="#l57.56"></a><span id="l57.56" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_int_int_charFARp_intFARp)(SOCKET, int,</span>
<a href="#l57.57"></a><span id="l57.57" class="difflineminus">-                                                                int, char FAR *,</span>
<a href="#l57.58"></a><span id="l57.58" class="difflineminus">-                                                                int FAR *);</span>
<a href="#l57.59"></a><span id="l57.59" class="difflineminus">-typedef u_long(PASCAL FAR *sp_ulong_ulong)(u_long);</span>
<a href="#l57.60"></a><span id="l57.60" class="difflineminus">-typedef u_short(PASCAL FAR *sp_ushort_ushort)(u_short);</span>
<a href="#l57.61"></a><span id="l57.61" class="difflineminus">-typedef unsigned long(PASCAL FAR *sp_ulong_ccharFARp)(const char FAR *);</span>
<a href="#l57.62"></a><span id="l57.62" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_long_ulongFARp)(SOCKET, long,</span>
<a href="#l57.63"></a><span id="l57.63" class="difflineminus">-                                                      u_long FAR *);</span>
<a href="#l57.64"></a><span id="l57.64" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_int)(SOCKET, int);</span>
<a href="#l57.65"></a><span id="l57.65" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_charFARp_int_int)(SOCKET, char FAR *, int,</span>
<a href="#l57.66"></a><span id="l57.66" class="difflineplus">+typedef void(PASCAL FAR* sp_void_int)(int);</span>
<a href="#l57.67"></a><span id="l57.67" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_fdsetFARp)(SOCKET, fd_set FAR*);</span>
<a href="#l57.68"></a><span id="l57.68" class="difflineplus">+typedef SOCKET(PASCAL FAR* sp_SOCKET_SOCKET_sockaddrFARp_intFARp)(</span>
<a href="#l57.69"></a><span id="l57.69" class="difflineplus">+    SOCKET, struct sockaddr FAR*, int FAR*);</span>
<a href="#l57.70"></a><span id="l57.70" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_csockaddrFARp_int)(</span>
<a href="#l57.71"></a><span id="l57.71" class="difflineplus">+    SOCKET, const struct sockaddr FAR*, int);</span>
<a href="#l57.72"></a><span id="l57.72" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET)(SOCKET);</span>
<a href="#l57.73"></a><span id="l57.73" class="difflineplus">+typedef struct hostent FAR*(PASCAL FAR* sp_hostentFARp_ccharFARp)(</span>
<a href="#l57.74"></a><span id="l57.74" class="difflineplus">+    const char FAR*);</span>
<a href="#l57.75"></a><span id="l57.75" class="difflineplus">+typedef struct hostent FAR*(PASCAL FAR* sp_hostentFARp_ccharFARp_int_int)(</span>
<a href="#l57.76"></a><span id="l57.76" class="difflineplus">+    const char FAR*, int, int);</span>
<a href="#l57.77"></a><span id="l57.77" class="difflineplus">+typedef int(PASCAL FAR* sp_int_charFARp_int)(char FAR*, int);</span>
<a href="#l57.78"></a><span id="l57.78" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_sockaddrFARp_intFARp)(</span>
<a href="#l57.79"></a><span id="l57.79" class="difflineplus">+    SOCKET, struct sockaddr FAR*, int FAR*);</span>
<a href="#l57.80"></a><span id="l57.80" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_int_int_charFARp_intFARp)(SOCKET, int,</span>
<a href="#l57.81"></a><span id="l57.81" class="difflineplus">+                                                                int, char FAR*,</span>
<a href="#l57.82"></a><span id="l57.82" class="difflineplus">+                                                                int FAR*);</span>
<a href="#l57.83"></a><span id="l57.83" class="difflineplus">+typedef u_long(PASCAL FAR* sp_ulong_ulong)(u_long);</span>
<a href="#l57.84"></a><span id="l57.84" class="difflineplus">+typedef u_short(PASCAL FAR* sp_ushort_ushort)(u_short);</span>
<a href="#l57.85"></a><span id="l57.85" class="difflineplus">+typedef unsigned long(PASCAL FAR* sp_ulong_ccharFARp)(const char FAR*);</span>
<a href="#l57.86"></a><span id="l57.86" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_long_ulongFARp)(SOCKET, long,</span>
<a href="#l57.87"></a><span id="l57.87" class="difflineplus">+                                                      u_long FAR*);</span>
<a href="#l57.88"></a><span id="l57.88" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_int)(SOCKET, int);</span>
<a href="#l57.89"></a><span id="l57.89" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_charFARp_int_int)(SOCKET, char FAR*, int,</span>
<a href="#l57.90"></a><span id="l57.90">                                                         int);</span>
<a href="#l57.91"></a><span id="l57.91" class="difflineminus">-typedef int(PASCAL FAR *sp_int_int_fdsetFARp_fdsetFARp_fdsetFARp_ctimevalFARp)(</span>
<a href="#l57.92"></a><span id="l57.92" class="difflineminus">-    int, fd_set FAR *, fd_set FAR *, fd_set FAR *, const struct timeval FAR *);</span>
<a href="#l57.93"></a><span id="l57.93" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_ccharFARp_int_int)(SOCKET,</span>
<a href="#l57.94"></a><span id="l57.94" class="difflineminus">-                                                         const char FAR *, int,</span>
<a href="#l57.95"></a><span id="l57.95" class="difflineplus">+typedef int(PASCAL FAR* sp_int_int_fdsetFARp_fdsetFARp_fdsetFARp_ctimevalFARp)(</span>
<a href="#l57.96"></a><span id="l57.96" class="difflineplus">+    int, fd_set FAR*, fd_set FAR*, fd_set FAR*, const struct timeval FAR*);</span>
<a href="#l57.97"></a><span id="l57.97" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_ccharFARp_int_int)(SOCKET,</span>
<a href="#l57.98"></a><span id="l57.98" class="difflineplus">+                                                         const char FAR*, int,</span>
<a href="#l57.99"></a><span id="l57.99">                                                          int);</span>
<a href="#l57.100"></a><span id="l57.100" class="difflineminus">-typedef int(PASCAL FAR *sp_int_SOCKET_int_int_ccharFARp_int)(SOCKET, int, int,</span>
<a href="#l57.101"></a><span id="l57.101" class="difflineminus">-                                                             const char FAR *,</span>
<a href="#l57.102"></a><span id="l57.102" class="difflineplus">+typedef int(PASCAL FAR* sp_int_SOCKET_int_int_ccharFARp_int)(SOCKET, int, int,</span>
<a href="#l57.103"></a><span id="l57.103" class="difflineplus">+                                                             const char FAR*,</span>
<a href="#l57.104"></a><span id="l57.104">                                                              int);</span>
<a href="#l57.105"></a><span id="l57.105" class="difflineminus">-typedef SOCKET(PASCAL FAR *sp_SOCKET_int_int_int)(int, int, int);</span>
<a href="#l57.106"></a><span id="l57.106" class="difflineminus">-typedef char FAR *(PASCAL FAR *sp_charFARp_in_addr)(struct in_addr in);</span>
<a href="#l57.107"></a><span id="l57.107" class="difflineminus">-typedef struct protoent FAR *(PASCAL FAR *sp_protoentFARcchar)(</span>
<a href="#l57.108"></a><span id="l57.108" class="difflineminus">-    const char FAR *);</span>
<a href="#l57.109"></a><span id="l57.109" class="difflineplus">+typedef SOCKET(PASCAL FAR* sp_SOCKET_int_int_int)(int, int, int);</span>
<a href="#l57.110"></a><span id="l57.110" class="difflineplus">+typedef char FAR*(PASCAL FAR* sp_charFARp_in_addr)(struct in_addr in);</span>
<a href="#l57.111"></a><span id="l57.111" class="difflineplus">+typedef struct protoent FAR*(PASCAL FAR* sp_protoentFARcchar)(const char FAR*);</span>
<a href="#l57.112"></a><span id="l57.112"> </span>
<a href="#l57.113"></a><span id="l57.113"> // Handle to the winsock, if loaded.</span>
<a href="#l57.114"></a><span id="l57.114"> HINSTANCE hWinsock = NULL;</span>
<a href="#l57.115"></a><span id="l57.115"> </span>
<a href="#l57.116"></a><span id="l57.116"> #ifndef _WIN32</span>
<a href="#l57.117"></a><span id="l57.117"> // Last error code for the winsock.</span>
<a href="#l57.118"></a><span id="l57.118"> int ispError = 0;</span>
<a href="#l57.119"></a><span id="l57.119"> #endif</span>
<a href="#l57.120"></a><span id="l57.120" class="difflineat">@@ -376,17 +375,17 @@ int PASCAL FAR WSACleanup(void) {</span>
<a href="#l57.121"></a><span id="l57.121">     FreeLibrary(hWinsock);</span>
<a href="#l57.122"></a><span id="l57.122">     hWinsock = NULL;</span>
<a href="#l57.123"></a><span id="l57.123">   }</span>
<a href="#l57.124"></a><span id="l57.124"> </span>
<a href="#l57.125"></a><span id="l57.125">   return (iRetval);</span>
<a href="#l57.126"></a><span id="l57.126"> }</span>
<a href="#l57.127"></a><span id="l57.127"> </span>
<a href="#l57.128"></a><span id="l57.128"> HANDLE PASCAL FAR WSAAsyncGetHostByName(HWND hWnd, unsigned int wMsg,</span>
<a href="#l57.129"></a><span id="l57.129" class="difflineminus">-                                        const char FAR *name, char FAR *buf,</span>
<a href="#l57.130"></a><span id="l57.130" class="difflineplus">+                                        const char FAR* name, char FAR* buf,</span>
<a href="#l57.131"></a><span id="l57.131">                                         int buflen) {</span>
<a href="#l57.132"></a><span id="l57.132">   // Normal or shim.</span>
<a href="#l57.133"></a><span id="l57.133">   if (IsWinsockLoaded(sp_WSAAsyncGetHostByName)) {</span>
<a href="#l57.134"></a><span id="l57.134">     return (</span>
<a href="#l57.135"></a><span id="l57.135">         ((sp_HANDLE_HWND_uint_ccharFARp_charFARp_int)</span>
<a href="#l57.136"></a><span id="l57.136">              spArray[sp_WSAAsyncGetHostByName])(hWnd, wMsg, name, buf, buflen));</span>
<a href="#l57.137"></a><span id="l57.137">   }</span>
<a href="#l57.138"></a><span id="l57.138"> </span>
<a href="#l57.139"></a><span id="l57.139" class="difflineat">@@ -441,17 +440,17 @@ void PASCAL FAR WSASetLastError(int iErr</span>
<a href="#l57.140"></a><span id="l57.140">   return;</span>
<a href="#l57.141"></a><span id="l57.141"> #else</span>
<a href="#l57.142"></a><span id="l57.142">   // Use default OS handler.</span>
<a href="#l57.143"></a><span id="l57.143">   SetLastError(iError);</span>
<a href="#l57.144"></a><span id="l57.144">   return;</span>
<a href="#l57.145"></a><span id="l57.145"> #endif</span>
<a href="#l57.146"></a><span id="l57.146"> }</span>
<a href="#l57.147"></a><span id="l57.147"> </span>
<a href="#l57.148"></a><span id="l57.148" class="difflineminus">-int PASCAL FAR __WSAFDIsSet(SOCKET fd, fd_set FAR *set) {</span>
<a href="#l57.149"></a><span id="l57.149" class="difflineplus">+int PASCAL FAR __WSAFDIsSet(SOCKET fd, fd_set FAR* set) {</span>
<a href="#l57.150"></a><span id="l57.150">   int i;</span>
<a href="#l57.151"></a><span id="l57.151"> </span>
<a href="#l57.152"></a><span id="l57.152">   // See if someone else will handle.</span>
<a href="#l57.153"></a><span id="l57.153">   if (IsWinsockLoaded(sp___WSAFDIsSet)) {</span>
<a href="#l57.154"></a><span id="l57.154">     return (((sp_int_SOCKET_fdsetFARp)spArray[sp___WSAFDIsSet])(fd, set));</span>
<a href="#l57.155"></a><span id="l57.155">   }</span>
<a href="#l57.156"></a><span id="l57.156"> </span>
<a href="#l57.157"></a><span id="l57.157">   // Default implementation.</span>
<a href="#l57.158"></a><span id="l57.158" class="difflineat">@@ -459,29 +458,29 @@ int PASCAL FAR __WSAFDIsSet(SOCKET fd, f</span>
<a href="#l57.159"></a><span id="l57.159">   while (i--) {</span>
<a href="#l57.160"></a><span id="l57.160">     if (set-&gt;fd_array[i] == fd) {</span>
<a href="#l57.161"></a><span id="l57.161">       return 1;</span>
<a href="#l57.162"></a><span id="l57.162">     }</span>
<a href="#l57.163"></a><span id="l57.163">   }</span>
<a href="#l57.164"></a><span id="l57.164">   return 0;</span>
<a href="#l57.165"></a><span id="l57.165"> }</span>
<a href="#l57.166"></a><span id="l57.166"> </span>
<a href="#l57.167"></a><span id="l57.167" class="difflineminus">-SOCKET PASCAL FAR accept(SOCKET s, struct sockaddr FAR *addr,</span>
<a href="#l57.168"></a><span id="l57.168" class="difflineminus">-                         int FAR *addrlen) {</span>
<a href="#l57.169"></a><span id="l57.169" class="difflineplus">+SOCKET PASCAL FAR accept(SOCKET s, struct sockaddr FAR* addr,</span>
<a href="#l57.170"></a><span id="l57.170" class="difflineplus">+                         int FAR* addrlen) {</span>
<a href="#l57.171"></a><span id="l57.171">   // Internally or shim</span>
<a href="#l57.172"></a><span id="l57.172">   NON_BLOCKING((((sp_SOCKET_SOCKET_sockaddrFARp_intFARp)spArray[sp_accept])(</span>
<a href="#l57.173"></a><span id="l57.173">                    s, addr, addrlen)),</span>
<a href="#l57.174"></a><span id="l57.174">                FD_ACCEPT, sp_accept, SOCKET);</span>
<a href="#l57.175"></a><span id="l57.175"> </span>
<a href="#l57.176"></a><span id="l57.176">   // Fail.</span>
<a href="#l57.177"></a><span id="l57.177">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.178"></a><span id="l57.178">   return (INVALID_SOCKET);</span>
<a href="#l57.179"></a><span id="l57.179"> }</span>
<a href="#l57.180"></a><span id="l57.180"> </span>
<a href="#l57.181"></a><span id="l57.181" class="difflineminus">-int PASCAL FAR bind(SOCKET s, const struct sockaddr FAR *name, int namelen) {</span>
<a href="#l57.182"></a><span id="l57.182" class="difflineplus">+int PASCAL FAR bind(SOCKET s, const struct sockaddr FAR* name, int namelen) {</span>
<a href="#l57.183"></a><span id="l57.183">   // Internally or shim</span>
<a href="#l57.184"></a><span id="l57.184">   if (IsWinsockLoaded(sp_bind)) {</span>
<a href="#l57.185"></a><span id="l57.185">     return (</span>
<a href="#l57.186"></a><span id="l57.186">         ((sp_int_SOCKET_csockaddrFARp_int)spArray[sp_bind])(s, name, namelen));</span>
<a href="#l57.187"></a><span id="l57.187">   }</span>
<a href="#l57.188"></a><span id="l57.188"> </span>
<a href="#l57.189"></a><span id="l57.189">   // Fail.</span>
<a href="#l57.190"></a><span id="l57.190">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.191"></a><span id="l57.191" class="difflineat">@@ -493,95 +492,95 @@ int PASCAL FAR closesocket(SOCKET s) {</span>
<a href="#l57.192"></a><span id="l57.192">   NON_BLOCKING((((sp_int_SOCKET)spArray[sp_closesocket])(s)), FD_CLOSE,</span>
<a href="#l57.193"></a><span id="l57.193">                sp_closesocket, int);</span>
<a href="#l57.194"></a><span id="l57.194"> </span>
<a href="#l57.195"></a><span id="l57.195">   // Error.</span>
<a href="#l57.196"></a><span id="l57.196">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.197"></a><span id="l57.197">   return (SOCKET_ERROR);</span>
<a href="#l57.198"></a><span id="l57.198"> }</span>
<a href="#l57.199"></a><span id="l57.199"> </span>
<a href="#l57.200"></a><span id="l57.200" class="difflineminus">-int PASCAL FAR connect(SOCKET s, const struct sockaddr FAR *name, int namelen) {</span>
<a href="#l57.201"></a><span id="l57.201" class="difflineplus">+int PASCAL FAR connect(SOCKET s, const struct sockaddr FAR* name, int namelen) {</span>
<a href="#l57.202"></a><span id="l57.202">   // Internally or shim.</span>
<a href="#l57.203"></a><span id="l57.203">   if (IsWinsockLoaded(sp_connect)) {</span>
<a href="#l57.204"></a><span id="l57.204">     /* This could block and so it would seem that the NON_BLOCK</span>
<a href="#l57.205"></a><span id="l57.205">      * macro should be used here.  However it was causing a crash</span>
<a href="#l57.206"></a><span id="l57.206">      * and so it was decided to allow blocking here instead</span>
<a href="#l57.207"></a><span id="l57.207">      */</span>
<a href="#l57.208"></a><span id="l57.208">     return (((sp_int_SOCKET_csockaddrFARp_int)spArray[sp_connect])(s, name,</span>
<a href="#l57.209"></a><span id="l57.209">                                                                    namelen));</span>
<a href="#l57.210"></a><span id="l57.210">   }</span>
<a href="#l57.211"></a><span id="l57.211"> </span>
<a href="#l57.212"></a><span id="l57.212">   // Err.</span>
<a href="#l57.213"></a><span id="l57.213">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.214"></a><span id="l57.214">   return (SOCKET_ERROR);</span>
<a href="#l57.215"></a><span id="l57.215"> }</span>
<a href="#l57.216"></a><span id="l57.216"> </span>
<a href="#l57.217"></a><span id="l57.217" class="difflineminus">-struct hostent FAR *PASCAL FAR gethostbyname(const char FAR *name) {</span>
<a href="#l57.218"></a><span id="l57.218" class="difflineplus">+struct hostent FAR* PASCAL FAR gethostbyname(const char FAR* name) {</span>
<a href="#l57.219"></a><span id="l57.219">   if (IsWinsockLoaded(sp_gethostbyname)) {</span>
<a href="#l57.220"></a><span id="l57.220">     return (((sp_hostentFARp_ccharFARp)spArray[sp_gethostbyname])(name));</span>
<a href="#l57.221"></a><span id="l57.221">   }</span>
<a href="#l57.222"></a><span id="l57.222"> </span>
<a href="#l57.223"></a><span id="l57.223">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.224"></a><span id="l57.224">   return (NULL);</span>
<a href="#l57.225"></a><span id="l57.225"> }</span>
<a href="#l57.226"></a><span id="l57.226"> </span>
<a href="#l57.227"></a><span id="l57.227" class="difflineminus">-struct hostent FAR *PASCAL FAR gethostbyaddr(const char FAR *addr, int len,</span>
<a href="#l57.228"></a><span id="l57.228" class="difflineplus">+struct hostent FAR* PASCAL FAR gethostbyaddr(const char FAR* addr, int len,</span>
<a href="#l57.229"></a><span id="l57.229">                                              int type) {</span>
<a href="#l57.230"></a><span id="l57.230">   if (IsWinsockLoaded(sp_gethostbyaddr)) {</span>
<a href="#l57.231"></a><span id="l57.231">     return (((sp_hostentFARp_ccharFARp_int_int)spArray[sp_gethostbyaddr])(</span>
<a href="#l57.232"></a><span id="l57.232">         addr, len, type));</span>
<a href="#l57.233"></a><span id="l57.233">   }</span>
<a href="#l57.234"></a><span id="l57.234"> </span>
<a href="#l57.235"></a><span id="l57.235">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.236"></a><span id="l57.236">   return (NULL);</span>
<a href="#l57.237"></a><span id="l57.237"> }</span>
<a href="#l57.238"></a><span id="l57.238"> </span>
<a href="#l57.239"></a><span id="l57.239" class="difflineminus">-int PASCAL FAR gethostname(char FAR *name, int namelen) {</span>
<a href="#l57.240"></a><span id="l57.240" class="difflineplus">+int PASCAL FAR gethostname(char FAR* name, int namelen) {</span>
<a href="#l57.241"></a><span id="l57.241">   if (IsWinsockLoaded(sp_gethostname)) {</span>
<a href="#l57.242"></a><span id="l57.242">     return (((sp_int_charFARp_int)spArray[sp_gethostname])(name, namelen));</span>
<a href="#l57.243"></a><span id="l57.243">   }</span>
<a href="#l57.244"></a><span id="l57.244"> </span>
<a href="#l57.245"></a><span id="l57.245">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.246"></a><span id="l57.246">   return (SOCKET_ERROR);</span>
<a href="#l57.247"></a><span id="l57.247"> }</span>
<a href="#l57.248"></a><span id="l57.248"> </span>
<a href="#l57.249"></a><span id="l57.249" class="difflineminus">-int PASCAL FAR getpeername(SOCKET s, struct sockaddr FAR *name,</span>
<a href="#l57.250"></a><span id="l57.250" class="difflineminus">-                           int FAR *namelen) {</span>
<a href="#l57.251"></a><span id="l57.251" class="difflineplus">+int PASCAL FAR getpeername(SOCKET s, struct sockaddr FAR* name,</span>
<a href="#l57.252"></a><span id="l57.252" class="difflineplus">+                           int FAR* namelen) {</span>
<a href="#l57.253"></a><span id="l57.253">   if (IsWinsockLoaded(sp_getpeername)) {</span>
<a href="#l57.254"></a><span id="l57.254">     return (((sp_int_SOCKET_sockaddrFARp_intFARp)spArray[sp_getpeername])(</span>
<a href="#l57.255"></a><span id="l57.255">         s, name, namelen));</span>
<a href="#l57.256"></a><span id="l57.256">   }</span>
<a href="#l57.257"></a><span id="l57.257"> </span>
<a href="#l57.258"></a><span id="l57.258">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.259"></a><span id="l57.259">   return (SOCKET_ERROR);</span>
<a href="#l57.260"></a><span id="l57.260"> }</span>
<a href="#l57.261"></a><span id="l57.261"> </span>
<a href="#l57.262"></a><span id="l57.262" class="difflineminus">-int PASCAL FAR getsockname(SOCKET s, struct sockaddr FAR *name,</span>
<a href="#l57.263"></a><span id="l57.263" class="difflineminus">-                           int FAR *namelen) {</span>
<a href="#l57.264"></a><span id="l57.264" class="difflineplus">+int PASCAL FAR getsockname(SOCKET s, struct sockaddr FAR* name,</span>
<a href="#l57.265"></a><span id="l57.265" class="difflineplus">+                           int FAR* namelen) {</span>
<a href="#l57.266"></a><span id="l57.266">   if (IsWinsockLoaded(sp_getsockname)) {</span>
<a href="#l57.267"></a><span id="l57.267">     return (((sp_int_SOCKET_sockaddrFARp_intFARp)spArray[sp_getsockname])(</span>
<a href="#l57.268"></a><span id="l57.268">         s, name, namelen));</span>
<a href="#l57.269"></a><span id="l57.269">   }</span>
<a href="#l57.270"></a><span id="l57.270"> </span>
<a href="#l57.271"></a><span id="l57.271">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.272"></a><span id="l57.272">   return (SOCKET_ERROR);</span>
<a href="#l57.273"></a><span id="l57.273"> }</span>
<a href="#l57.274"></a><span id="l57.274"> </span>
<a href="#l57.275"></a><span id="l57.275" class="difflineminus">-int PASCAL FAR getsockopt(SOCKET s, int level, int optname, char FAR *optval,</span>
<a href="#l57.276"></a><span id="l57.276" class="difflineminus">-                          int FAR *optlen) {</span>
<a href="#l57.277"></a><span id="l57.277" class="difflineplus">+int PASCAL FAR getsockopt(SOCKET s, int level, int optname, char FAR* optval,</span>
<a href="#l57.278"></a><span id="l57.278" class="difflineplus">+                          int FAR* optlen) {</span>
<a href="#l57.279"></a><span id="l57.279">   if (IsWinsockLoaded(sp_getsockopt)) {</span>
<a href="#l57.280"></a><span id="l57.280">     return (((sp_int_SOCKET_int_int_charFARp_intFARp)spArray[sp_getsockopt])(</span>
<a href="#l57.281"></a><span id="l57.281">         s, level, optname, optval, optlen));</span>
<a href="#l57.282"></a><span id="l57.282">   }</span>
<a href="#l57.283"></a><span id="l57.283"> </span>
<a href="#l57.284"></a><span id="l57.284">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.285"></a><span id="l57.285">   return (SOCKET_ERROR);</span>
<a href="#l57.286"></a><span id="l57.286"> }</span>
<a href="#l57.287"></a><span id="l57.287"> </span>
<a href="#l57.288"></a><span id="l57.288" class="difflineminus">-struct protoent FAR *PASCAL getprotobyname(const char FAR *name) {</span>
<a href="#l57.289"></a><span id="l57.289" class="difflineplus">+struct protoent FAR* PASCAL getprotobyname(const char FAR* name) {</span>
<a href="#l57.290"></a><span id="l57.290">   if (IsWinsockLoaded(sp_getprotobyname)) {</span>
<a href="#l57.291"></a><span id="l57.291">     return (((sp_protoentFARcchar)spArray[sp_getprotobyname])(name));</span>
<a href="#l57.292"></a><span id="l57.292">   }</span>
<a href="#l57.293"></a><span id="l57.293"> </span>
<a href="#l57.294"></a><span id="l57.294">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.295"></a><span id="l57.295">   return NULL;</span>
<a href="#l57.296"></a><span id="l57.296"> }</span>
<a href="#l57.297"></a><span id="l57.297"> </span>
<a href="#l57.298"></a><span id="l57.298" class="difflineat">@@ -638,25 +637,25 @@ u_short PASCAL FAR ntohs(u_short hostsho</span>
<a href="#l57.299"></a><span id="l57.299">   return (((hostshort &amp; 0xff) &lt;&lt; 8) + ((hostshort &amp; 0xff00) &gt;&gt; 8));</span>
<a href="#l57.300"></a><span id="l57.300"> </span>
<a href="#l57.301"></a><span id="l57.301"> #else</span>
<a href="#l57.302"></a><span id="l57.302">   // Just return what was passed in.</span>
<a href="#l57.303"></a><span id="l57.303">   return (hostshort);</span>
<a href="#l57.304"></a><span id="l57.304"> #endif</span>
<a href="#l57.305"></a><span id="l57.305"> }</span>
<a href="#l57.306"></a><span id="l57.306"> </span>
<a href="#l57.307"></a><span id="l57.307" class="difflineminus">-unsigned long PASCAL FAR inet_addr(const char FAR *cp) {</span>
<a href="#l57.308"></a><span id="l57.308" class="difflineplus">+unsigned long PASCAL FAR inet_addr(const char FAR* cp) {</span>
<a href="#l57.309"></a><span id="l57.309">   if (IsWinsockLoaded(sp_inet_addr)) {</span>
<a href="#l57.310"></a><span id="l57.310">     return (((sp_ulong_ccharFARp)spArray[sp_inet_addr])(cp));</span>
<a href="#l57.311"></a><span id="l57.311">   }</span>
<a href="#l57.312"></a><span id="l57.312"> </span>
<a href="#l57.313"></a><span id="l57.313">   return (INADDR_NONE);</span>
<a href="#l57.314"></a><span id="l57.314"> }</span>
<a href="#l57.315"></a><span id="l57.315"> </span>
<a href="#l57.316"></a><span id="l57.316" class="difflineminus">-int PASCAL FAR ioctlsocket(SOCKET s, long cmd, u_long FAR *argp) {</span>
<a href="#l57.317"></a><span id="l57.317" class="difflineplus">+int PASCAL FAR ioctlsocket(SOCKET s, long cmd, u_long FAR* argp) {</span>
<a href="#l57.318"></a><span id="l57.318">   if (IsWinsockLoaded(sp_ioctlsocket)) {</span>
<a href="#l57.319"></a><span id="l57.319">     return (</span>
<a href="#l57.320"></a><span id="l57.320">         ((sp_int_SOCKET_long_ulongFARp)spArray[sp_ioctlsocket])(s, cmd, argp));</span>
<a href="#l57.321"></a><span id="l57.321">   }</span>
<a href="#l57.322"></a><span id="l57.322"> </span>
<a href="#l57.323"></a><span id="l57.323">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.324"></a><span id="l57.324">   return (SOCKET_ERROR);</span>
<a href="#l57.325"></a><span id="l57.325"> }</span>
<a href="#l57.326"></a><span id="l57.326" class="difflineat">@@ -665,28 +664,28 @@ int PASCAL FAR listen(SOCKET s, int back</span>
<a href="#l57.327"></a><span id="l57.327">   if (IsWinsockLoaded(sp_listen)) {</span>
<a href="#l57.328"></a><span id="l57.328">     return (((sp_int_SOCKET_int)spArray[sp_listen])(s, backlog));</span>
<a href="#l57.329"></a><span id="l57.329">   }</span>
<a href="#l57.330"></a><span id="l57.330"> </span>
<a href="#l57.331"></a><span id="l57.331">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.332"></a><span id="l57.332">   return (SOCKET_ERROR);</span>
<a href="#l57.333"></a><span id="l57.333"> }</span>
<a href="#l57.334"></a><span id="l57.334"> </span>
<a href="#l57.335"></a><span id="l57.335" class="difflineminus">-int PASCAL FAR recv(SOCKET s, char FAR *buf, int len, int flags) {</span>
<a href="#l57.336"></a><span id="l57.336" class="difflineplus">+int PASCAL FAR recv(SOCKET s, char FAR* buf, int len, int flags) {</span>
<a href="#l57.337"></a><span id="l57.337">   NON_BLOCKING(</span>
<a href="#l57.338"></a><span id="l57.338">       (((sp_int_SOCKET_charFARp_int_int)spArray[sp_recv])(s, buf, len, flags)),</span>
<a href="#l57.339"></a><span id="l57.339">       FD_READ, sp_recv, int);</span>
<a href="#l57.340"></a><span id="l57.340"> </span>
<a href="#l57.341"></a><span id="l57.341">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.342"></a><span id="l57.342">   return (SOCKET_ERROR);</span>
<a href="#l57.343"></a><span id="l57.343"> }</span>
<a href="#l57.344"></a><span id="l57.344"> </span>
<a href="#l57.345"></a><span id="l57.345" class="difflineminus">-int PASCAL FAR select(int nfds, fd_set FAR *readfds, fd_set FAR *writefds,</span>
<a href="#l57.346"></a><span id="l57.346" class="difflineminus">-                      fd_set FAR *exceptfds,</span>
<a href="#l57.347"></a><span id="l57.347" class="difflineminus">-                      const struct timeval FAR *timeout) {</span>
<a href="#l57.348"></a><span id="l57.348" class="difflineplus">+int PASCAL FAR select(int nfds, fd_set FAR* readfds, fd_set FAR* writefds,</span>
<a href="#l57.349"></a><span id="l57.349" class="difflineplus">+                      fd_set FAR* exceptfds,</span>
<a href="#l57.350"></a><span id="l57.350" class="difflineplus">+                      const struct timeval FAR* timeout) {</span>
<a href="#l57.351"></a><span id="l57.351">   // If there's nothing to do, stop now before we go off into dll land.</span>
<a href="#l57.352"></a><span id="l57.352">   // Optimization, boyz.</span>
<a href="#l57.353"></a><span id="l57.353">   if ((readfds &amp;&amp; readfds-&gt;fd_count) || (writefds &amp;&amp; writefds-&gt;fd_count) ||</span>
<a href="#l57.354"></a><span id="l57.354">       (exceptfds &amp;&amp; exceptfds-&gt;fd_count)) {</span>
<a href="#l57.355"></a><span id="l57.355">     if (IsWinsockLoaded(sp_select)) {</span>
<a href="#l57.356"></a><span id="l57.356">       return (((sp_int_int_fdsetFARp_fdsetFARp_fdsetFARp_ctimevalFARp)</span>
<a href="#l57.357"></a><span id="l57.357">                    spArray[sp_select])(nfds, readfds, writefds, exceptfds,</span>
<a href="#l57.358"></a><span id="l57.358">                                        timeout));</span>
<a href="#l57.359"></a><span id="l57.359" class="difflineat">@@ -695,28 +694,28 @@ int PASCAL FAR select(int nfds, fd_set F</span>
<a href="#l57.360"></a><span id="l57.360">     WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.361"></a><span id="l57.361">     return (SOCKET_ERROR);</span>
<a href="#l57.362"></a><span id="l57.362">   }</span>
<a href="#l57.363"></a><span id="l57.363"> </span>
<a href="#l57.364"></a><span id="l57.364">   // No need to go to the DLL, there is nothing to do.</span>
<a href="#l57.365"></a><span id="l57.365">   return (0);</span>
<a href="#l57.366"></a><span id="l57.366"> }</span>
<a href="#l57.367"></a><span id="l57.367"> </span>
<a href="#l57.368"></a><span id="l57.368" class="difflineminus">-int PASCAL FAR send(SOCKET s, const char FAR *buf, int len, int flags) {</span>
<a href="#l57.369"></a><span id="l57.369" class="difflineplus">+int PASCAL FAR send(SOCKET s, const char FAR* buf, int len, int flags) {</span>
<a href="#l57.370"></a><span id="l57.370">   NON_BLOCKING(</span>
<a href="#l57.371"></a><span id="l57.371"> </span>
<a href="#l57.372"></a><span id="l57.372">       (((sp_int_SOCKET_ccharFARp_int_int)spArray[sp_send])(s, buf, len, flags)),</span>
<a href="#l57.373"></a><span id="l57.373">       FD_WRITE, sp_send, int);</span>
<a href="#l57.374"></a><span id="l57.374"> </span>
<a href="#l57.375"></a><span id="l57.375">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.376"></a><span id="l57.376">   return (SOCKET_ERROR);</span>
<a href="#l57.377"></a><span id="l57.377"> }</span>
<a href="#l57.378"></a><span id="l57.378"> </span>
<a href="#l57.379"></a><span id="l57.379"> int PASCAL FAR setsockopt(SOCKET s, int level, int optname,</span>
<a href="#l57.380"></a><span id="l57.380" class="difflineminus">-                          const char FAR *optval, int optlen) {</span>
<a href="#l57.381"></a><span id="l57.381" class="difflineplus">+                          const char FAR* optval, int optlen) {</span>
<a href="#l57.382"></a><span id="l57.382">   if (IsWinsockLoaded(sp_setsockopt)) {</span>
<a href="#l57.383"></a><span id="l57.383">     return (((sp_int_SOCKET_int_int_ccharFARp_int)spArray[sp_setsockopt])(</span>
<a href="#l57.384"></a><span id="l57.384">         s, level, optname, optval, optlen));</span>
<a href="#l57.385"></a><span id="l57.385">   }</span>
<a href="#l57.386"></a><span id="l57.386"> </span>
<a href="#l57.387"></a><span id="l57.387">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.388"></a><span id="l57.388">   return (SOCKET_ERROR);</span>
<a href="#l57.389"></a><span id="l57.389"> }</span>
<a href="#l57.390"></a><span id="l57.390" class="difflineat">@@ -734,16 +733,16 @@ SOCKET PASCAL FAR socket(int af, int typ</span>
<a href="#l57.391"></a><span id="l57.391">   if (IsWinsockLoaded(sp_socket)) {</span>
<a href="#l57.392"></a><span id="l57.392">     return (((sp_SOCKET_int_int_int)spArray[sp_socket])(af, type, protocol));</span>
<a href="#l57.393"></a><span id="l57.393">   }</span>
<a href="#l57.394"></a><span id="l57.394"> </span>
<a href="#l57.395"></a><span id="l57.395">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.396"></a><span id="l57.396">   return (INVALID_SOCKET);</span>
<a href="#l57.397"></a><span id="l57.397"> }</span>
<a href="#l57.398"></a><span id="l57.398"> </span>
<a href="#l57.399"></a><span id="l57.399" class="difflineminus">-char FAR *PASCAL FAR inet_ntoa(struct in_addr in) {</span>
<a href="#l57.400"></a><span id="l57.400" class="difflineplus">+char FAR* PASCAL FAR inet_ntoa(struct in_addr in) {</span>
<a href="#l57.401"></a><span id="l57.401">   if (IsWinsockLoaded(sp_inet_ntoa)) {</span>
<a href="#l57.402"></a><span id="l57.402">     return ((sp_charFARp_in_addr)spArray[sp_inet_ntoa])(in);</span>
<a href="#l57.403"></a><span id="l57.403">   }</span>
<a href="#l57.404"></a><span id="l57.404"> </span>
<a href="#l57.405"></a><span id="l57.405">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l57.406"></a><span id="l57.406">   return NULL;</span>
<a href="#l57.407"></a><span id="l57.407"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l58.1"></a><span id="l58.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/nsprthreadtest.c</span>
<a href="#l58.2"></a><span id="l58.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/nsprthreadtest.c</span>
<a href="#l58.3"></a><span id="l58.3" class="difflineat">@@ -37,59 +37,59 @@</span>
<a href="#l58.4"></a><span id="l58.4"> #include &lt;nspr.h&gt;</span>
<a href="#l58.5"></a><span id="l58.5"> #include &lt;stdio.h&gt;</span>
<a href="#l58.6"></a><span id="l58.6"> #include &lt;ldap.h&gt;</span>
<a href="#l58.7"></a><span id="l58.7"> </span>
<a href="#l58.8"></a><span id="l58.8"> #define NAME &quot;cn=Directory Manager&quot;</span>
<a href="#l58.9"></a><span id="l58.9"> #define PASSWORD &quot;secret99&quot;</span>
<a href="#l58.10"></a><span id="l58.10"> #define BASE &quot;dc=example,dc=com&quot;</span>
<a href="#l58.11"></a><span id="l58.11"> </span>
<a href="#l58.12"></a><span id="l58.12" class="difflineminus">-static int simplebind(LDAP *ld, char *msg, int tries);</span>
<a href="#l58.13"></a><span id="l58.13" class="difflineminus">-static void search_thread(void *);</span>
<a href="#l58.14"></a><span id="l58.14" class="difflineminus">-static void modify_thread(void *);</span>
<a href="#l58.15"></a><span id="l58.15" class="difflineminus">-static void add_thread(void *);</span>
<a href="#l58.16"></a><span id="l58.16" class="difflineminus">-static void delete_thread(void *);</span>
<a href="#l58.17"></a><span id="l58.17" class="difflineplus">+static int simplebind(LDAP* ld, char* msg, int tries);</span>
<a href="#l58.18"></a><span id="l58.18" class="difflineplus">+static void search_thread(void*);</span>
<a href="#l58.19"></a><span id="l58.19" class="difflineplus">+static void modify_thread(void*);</span>
<a href="#l58.20"></a><span id="l58.20" class="difflineplus">+static void add_thread(void*);</span>
<a href="#l58.21"></a><span id="l58.21" class="difflineplus">+static void delete_thread(void*);</span>
<a href="#l58.22"></a><span id="l58.22"> static void set_ld_error();</span>
<a href="#l58.23"></a><span id="l58.23"> static int get_ld_error();</span>
<a href="#l58.24"></a><span id="l58.24"> static void set_errno();</span>
<a href="#l58.25"></a><span id="l58.25"> static int get_errno();</span>
<a href="#l58.26"></a><span id="l58.26"> static void tsd_setup();</span>
<a href="#l58.27"></a><span id="l58.27" class="difflineminus">-static void *my_mutex_alloc(void);</span>
<a href="#l58.28"></a><span id="l58.28" class="difflineminus">-static void my_mutex_free(void *);</span>
<a href="#l58.29"></a><span id="l58.29" class="difflineminus">-static int my_mutex_lock(void *);</span>
<a href="#l58.30"></a><span id="l58.30" class="difflineminus">-static int my_mutex_unlock(void *);</span>
<a href="#l58.31"></a><span id="l58.31" class="difflineminus">-static LDAPHostEnt *my_gethostbyname(const char *name, LDAPHostEnt *result,</span>
<a href="#l58.32"></a><span id="l58.32" class="difflineminus">-                                     char *buffer, int buflen, int *statusp,</span>
<a href="#l58.33"></a><span id="l58.33" class="difflineminus">-                                     void *extradata);</span>
<a href="#l58.34"></a><span id="l58.34" class="difflineminus">-static LDAPHostEnt *my_gethostbyaddr(const char *addr, int length, int type,</span>
<a href="#l58.35"></a><span id="l58.35" class="difflineminus">-                                     LDAPHostEnt *result, char *buffer,</span>
<a href="#l58.36"></a><span id="l58.36" class="difflineminus">-                                     int buflen, int *statusp, void *extradata);</span>
<a href="#l58.37"></a><span id="l58.37" class="difflineminus">-static LDAPHostEnt *copyPRHostEnt2LDAPHostEnt(LDAPHostEnt *ldhp,</span>
<a href="#l58.38"></a><span id="l58.38" class="difflineminus">-                                              PRHostEnt *prhp);</span>
<a href="#l58.39"></a><span id="l58.39" class="difflineplus">+static void* my_mutex_alloc(void);</span>
<a href="#l58.40"></a><span id="l58.40" class="difflineplus">+static void my_mutex_free(void*);</span>
<a href="#l58.41"></a><span id="l58.41" class="difflineplus">+static int my_mutex_lock(void*);</span>
<a href="#l58.42"></a><span id="l58.42" class="difflineplus">+static int my_mutex_unlock(void*);</span>
<a href="#l58.43"></a><span id="l58.43" class="difflineplus">+static LDAPHostEnt* my_gethostbyname(const char* name, LDAPHostEnt* result,</span>
<a href="#l58.44"></a><span id="l58.44" class="difflineplus">+                                     char* buffer, int buflen, int* statusp,</span>
<a href="#l58.45"></a><span id="l58.45" class="difflineplus">+                                     void* extradata);</span>
<a href="#l58.46"></a><span id="l58.46" class="difflineplus">+static LDAPHostEnt* my_gethostbyaddr(const char* addr, int length, int type,</span>
<a href="#l58.47"></a><span id="l58.47" class="difflineplus">+                                     LDAPHostEnt* result, char* buffer,</span>
<a href="#l58.48"></a><span id="l58.48" class="difflineplus">+                                     int buflen, int* statusp, void* extradata);</span>
<a href="#l58.49"></a><span id="l58.49" class="difflineplus">+static LDAPHostEnt* copyPRHostEnt2LDAPHostEnt(LDAPHostEnt* ldhp,</span>
<a href="#l58.50"></a><span id="l58.50" class="difflineplus">+                                              PRHostEnt* prhp);</span>
<a href="#l58.51"></a><span id="l58.51"> </span>
<a href="#l58.52"></a><span id="l58.52"> typedef struct ldapmsgwrapper {</span>
<a href="#l58.53"></a><span id="l58.53" class="difflineminus">-  LDAPMessage *lmw_messagep;</span>
<a href="#l58.54"></a><span id="l58.54" class="difflineminus">-  struct ldapmsgwrapper *lmw_next;</span>
<a href="#l58.55"></a><span id="l58.55" class="difflineplus">+  LDAPMessage* lmw_messagep;</span>
<a href="#l58.56"></a><span id="l58.56" class="difflineplus">+  struct ldapmsgwrapper* lmw_next;</span>
<a href="#l58.57"></a><span id="l58.57"> } ldapmsgwrapper;</span>
<a href="#l58.58"></a><span id="l58.58"> </span>
<a href="#l58.59"></a><span id="l58.59"> #define CONNECTION_ERROR(lderr) \</span>
<a href="#l58.60"></a><span id="l58.60">   ((lderr) == LDAP_SERVER_DOWN || (lderr) == LDAP_CONNECT_ERROR)</span>
<a href="#l58.61"></a><span id="l58.61"> </span>
<a href="#l58.62"></a><span id="l58.62" class="difflineminus">-LDAP *ld;</span>
<a href="#l58.63"></a><span id="l58.63" class="difflineplus">+LDAP* ld;</span>
<a href="#l58.64"></a><span id="l58.64"> PRUintn tsdindex;</span>
<a href="#l58.65"></a><span id="l58.65"> #ifdef LDAP_MEMCACHE</span>
<a href="#l58.66"></a><span id="l58.66" class="difflineminus">-LDAPMemCache *memcache = NULL;</span>
<a href="#l58.67"></a><span id="l58.67" class="difflineplus">+LDAPMemCache* memcache = NULL;</span>
<a href="#l58.68"></a><span id="l58.68"> #  define MEMCACHE_SIZE (256 * 1024) /* 256K bytes */</span>
<a href="#l58.69"></a><span id="l58.69"> #  define MEMCACHE_TTL (15 * 60)     /* 15 minutes */</span>
<a href="#l58.70"></a><span id="l58.70"> #endif</span>
<a href="#l58.71"></a><span id="l58.71"> </span>
<a href="#l58.72"></a><span id="l58.72" class="difflineminus">-main(int argc, char **argv) {</span>
<a href="#l58.73"></a><span id="l58.73" class="difflineplus">+main(int argc, char** argv) {</span>
<a href="#l58.74"></a><span id="l58.74">   PRThread *search_tid, *search_tid2, *search_tid3;</span>
<a href="#l58.75"></a><span id="l58.75">   PRThread *search_tid4, *modify_tid, *add_tid;</span>
<a href="#l58.76"></a><span id="l58.76" class="difflineminus">-  PRThread *delete_tid;</span>
<a href="#l58.77"></a><span id="l58.77" class="difflineplus">+  PRThread* delete_tid;</span>
<a href="#l58.78"></a><span id="l58.78">   struct ldap_thread_fns tfns;</span>
<a href="#l58.79"></a><span id="l58.79">   struct ldap_dns_fns dnsfns;</span>
<a href="#l58.80"></a><span id="l58.80">   int rc;</span>
<a href="#l58.81"></a><span id="l58.81"> </span>
<a href="#l58.82"></a><span id="l58.82">   if (argc != 3) {</span>
<a href="#l58.83"></a><span id="l58.83">     fprintf(stderr, &quot;usage: %s host port\n&quot;, argv[0]);</span>
<a href="#l58.84"></a><span id="l58.84">     exit(1);</span>
<a href="#l58.85"></a><span id="l58.85">   }</span>
<a href="#l58.86"></a><span id="l58.86" class="difflineat">@@ -112,27 +112,27 @@ main(int argc, char **argv) {</span>
<a href="#l58.87"></a><span id="l58.87">   tfns.ltf_mutex_free = my_mutex_free;</span>
<a href="#l58.88"></a><span id="l58.88">   tfns.ltf_mutex_lock = my_mutex_lock;</span>
<a href="#l58.89"></a><span id="l58.89">   tfns.ltf_mutex_unlock = my_mutex_unlock;</span>
<a href="#l58.90"></a><span id="l58.90">   tfns.ltf_get_errno = get_errno;</span>
<a href="#l58.91"></a><span id="l58.91">   tfns.ltf_set_errno = set_errno;</span>
<a href="#l58.92"></a><span id="l58.92">   tfns.ltf_get_lderrno = get_ld_error;</span>
<a href="#l58.93"></a><span id="l58.93">   tfns.ltf_set_lderrno = set_ld_error;</span>
<a href="#l58.94"></a><span id="l58.94">   tfns.ltf_lderrno_arg = NULL;</span>
<a href="#l58.95"></a><span id="l58.95" class="difflineminus">-  if (ldap_set_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void *)&amp;tfns) != 0) {</span>
<a href="#l58.96"></a><span id="l58.96" class="difflineplus">+  if (ldap_set_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void*)&amp;tfns) != 0) {</span>
<a href="#l58.97"></a><span id="l58.97">     ldap_perror(ld, &quot;ldap_set_option: thread functions&quot;);</span>
<a href="#l58.98"></a><span id="l58.98">     exit(1);</span>
<a href="#l58.99"></a><span id="l58.99">   }</span>
<a href="#l58.100"></a><span id="l58.100"> </span>
<a href="#l58.101"></a><span id="l58.101">   /* set DNS function pointers */</span>
<a href="#l58.102"></a><span id="l58.102">   memset(&amp;dnsfns, '\0', sizeof(struct ldap_dns_fns));</span>
<a href="#l58.103"></a><span id="l58.103">   dnsfns.lddnsfn_bufsize = PR_NETDB_BUF_SIZE;</span>
<a href="#l58.104"></a><span id="l58.104">   dnsfns.lddnsfn_gethostbyname = my_gethostbyname;</span>
<a href="#l58.105"></a><span id="l58.105">   dnsfns.lddnsfn_gethostbyaddr = my_gethostbyaddr;</span>
<a href="#l58.106"></a><span id="l58.106" class="difflineminus">-  if (ldap_set_option(ld, LDAP_OPT_DNS_FN_PTRS, (void *)&amp;dnsfns) != 0) {</span>
<a href="#l58.107"></a><span id="l58.107" class="difflineplus">+  if (ldap_set_option(ld, LDAP_OPT_DNS_FN_PTRS, (void*)&amp;dnsfns) != 0) {</span>
<a href="#l58.108"></a><span id="l58.108">     ldap_perror(ld, &quot;ldap_set_option: DNS functions&quot;);</span>
<a href="#l58.109"></a><span id="l58.109">     exit(1);</span>
<a href="#l58.110"></a><span id="l58.110">   }</span>
<a href="#l58.111"></a><span id="l58.111"> </span>
<a href="#l58.112"></a><span id="l58.112"> #ifdef LDAP_MEMCACHE</span>
<a href="#l58.113"></a><span id="l58.113">   /* create the in-memory cache */</span>
<a href="#l58.114"></a><span id="l58.114">   if ((rc = ldap_memcache_init(MEMCACHE_TTL, MEMCACHE_SIZE, NULL, &amp;tfns,</span>
<a href="#l58.115"></a><span id="l58.115">                                &amp;memcache)) != LDAP_SUCCESS) {</span>
<a href="#l58.116"></a><span id="l58.116" class="difflineat">@@ -202,17 +202,17 @@ main(int argc, char **argv) {</span>
<a href="#l58.117"></a><span id="l58.117">     perror(&quot;PR_CreateThread search_thread 4&quot;);</span>
<a href="#l58.118"></a><span id="l58.118">     exit(1);</span>
<a href="#l58.119"></a><span id="l58.119">   }</span>
<a href="#l58.120"></a><span id="l58.120"> </span>
<a href="#l58.121"></a><span id="l58.121">   PR_Cleanup();</span>
<a href="#l58.122"></a><span id="l58.122">   return (0);</span>
<a href="#l58.123"></a><span id="l58.123"> }</span>
<a href="#l58.124"></a><span id="l58.124"> </span>
<a href="#l58.125"></a><span id="l58.125" class="difflineminus">-static int simplebind(LDAP *ld, char *msg, int tries) {</span>
<a href="#l58.126"></a><span id="l58.126" class="difflineplus">+static int simplebind(LDAP* ld, char* msg, int tries) {</span>
<a href="#l58.127"></a><span id="l58.127">   int rc;</span>
<a href="#l58.128"></a><span id="l58.128"> </span>
<a href="#l58.129"></a><span id="l58.129">   while (tries-- &gt; 0) {</span>
<a href="#l58.130"></a><span id="l58.130">     rc = ldap_simple_bind_s(ld, NAME, PASSWORD);</span>
<a href="#l58.131"></a><span id="l58.131">     if (rc != LDAP_SUCCESS) {</span>
<a href="#l58.132"></a><span id="l58.132">       ldap_perror(ld, msg);</span>
<a href="#l58.133"></a><span id="l58.133">     }</span>
<a href="#l58.134"></a><span id="l58.134">     if (tries == 0 || !CONNECTION_ERROR(rc)) {</span>
<a href="#l58.135"></a><span id="l58.135" class="difflineat">@@ -221,26 +221,26 @@ static int simplebind(LDAP *ld, char *ms</span>
<a href="#l58.136"></a><span id="l58.136">     fprintf(stderr, &quot;%s: sleeping for 5 secs - will try %d more time(s)...\n&quot;,</span>
<a href="#l58.137"></a><span id="l58.137">             msg, tries);</span>
<a href="#l58.138"></a><span id="l58.138">     sleep(5);</span>
<a href="#l58.139"></a><span id="l58.139">   }</span>
<a href="#l58.140"></a><span id="l58.140"> </span>
<a href="#l58.141"></a><span id="l58.141">   return (rc);</span>
<a href="#l58.142"></a><span id="l58.142"> }</span>
<a href="#l58.143"></a><span id="l58.143"> </span>
<a href="#l58.144"></a><span id="l58.144" class="difflineminus">-static void search_thread(void *arg1) {</span>
<a href="#l58.145"></a><span id="l58.145" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l58.146"></a><span id="l58.146" class="difflineminus">-  LDAPMessage *e;</span>
<a href="#l58.147"></a><span id="l58.147" class="difflineminus">-  char *a;</span>
<a href="#l58.148"></a><span id="l58.148" class="difflineminus">-  char **v;</span>
<a href="#l58.149"></a><span id="l58.149" class="difflineminus">-  char *dn;</span>
<a href="#l58.150"></a><span id="l58.150" class="difflineminus">-  BerElement *ber;</span>
<a href="#l58.151"></a><span id="l58.151" class="difflineplus">+static void search_thread(void* arg1) {</span>
<a href="#l58.152"></a><span id="l58.152" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l58.153"></a><span id="l58.153" class="difflineplus">+  LDAPMessage* e;</span>
<a href="#l58.154"></a><span id="l58.154" class="difflineplus">+  char* a;</span>
<a href="#l58.155"></a><span id="l58.155" class="difflineplus">+  char** v;</span>
<a href="#l58.156"></a><span id="l58.156" class="difflineplus">+  char* dn;</span>
<a href="#l58.157"></a><span id="l58.157" class="difflineplus">+  BerElement* ber;</span>
<a href="#l58.158"></a><span id="l58.158">   int i, rc, msgid;</span>
<a href="#l58.159"></a><span id="l58.159" class="difflineminus">-  void *tsd;</span>
<a href="#l58.160"></a><span id="l58.160" class="difflineminus">-  char *id = arg1;</span>
<a href="#l58.161"></a><span id="l58.161" class="difflineplus">+  void* tsd;</span>
<a href="#l58.162"></a><span id="l58.162" class="difflineplus">+  char* id = arg1;</span>
<a href="#l58.163"></a><span id="l58.163"> </span>
<a href="#l58.164"></a><span id="l58.164">   printf(&quot;search_thread\n&quot;);</span>
<a href="#l58.165"></a><span id="l58.165">   tsd_setup();</span>
<a href="#l58.166"></a><span id="l58.166">   for (;;) {</span>
<a href="#l58.167"></a><span id="l58.167">     printf(&quot;%sSearching...\n&quot;, id);</span>
<a href="#l58.168"></a><span id="l58.168">     if ((msgid = ldap_search(ld, BASE, LDAP_SCOPE_SUBTREE, &quot;(objectclass=*)&quot;,</span>
<a href="#l58.169"></a><span id="l58.169">                              NULL, 0)) == -1) {</span>
<a href="#l58.170"></a><span id="l58.170">       ldap_perror(ld, &quot;ldap_search_s&quot;);</span>
<a href="#l58.171"></a><span id="l58.171" class="difflineat">@@ -289,40 +289,40 @@ static void search_thread(void *arg1) {</span>
<a href="#l58.172"></a><span id="l58.172">       if (CONNECTION_ERROR(rc) &amp;&amp;</span>
<a href="#l58.173"></a><span id="l58.173">           simplebind(ld, &quot;bind-search_thread&quot;, 5) != LDAP_SUCCESS) {</span>
<a href="#l58.174"></a><span id="l58.174">         return;</span>
<a href="#l58.175"></a><span id="l58.175">       }</span>
<a href="#l58.176"></a><span id="l58.176">     }</span>
<a href="#l58.177"></a><span id="l58.177">   }</span>
<a href="#l58.178"></a><span id="l58.178"> }</span>
<a href="#l58.179"></a><span id="l58.179"> </span>
<a href="#l58.180"></a><span id="l58.180" class="difflineminus">-static void modify_thread(void *arg1) {</span>
<a href="#l58.181"></a><span id="l58.181" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l58.182"></a><span id="l58.182" class="difflineminus">-  LDAPMessage *e;</span>
<a href="#l58.183"></a><span id="l58.183" class="difflineplus">+static void modify_thread(void* arg1) {</span>
<a href="#l58.184"></a><span id="l58.184" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l58.185"></a><span id="l58.185" class="difflineplus">+  LDAPMessage* e;</span>
<a href="#l58.186"></a><span id="l58.186">   int i, modentry, entries, msgid, rc;</span>
<a href="#l58.187"></a><span id="l58.187">   LDAPMod mod;</span>
<a href="#l58.188"></a><span id="l58.188" class="difflineminus">-  LDAPMod *mods[2];</span>
<a href="#l58.189"></a><span id="l58.189" class="difflineminus">-  char *vals[2];</span>
<a href="#l58.190"></a><span id="l58.190" class="difflineminus">-  char *dn;</span>
<a href="#l58.191"></a><span id="l58.191" class="difflineminus">-  char *id = arg1;</span>
<a href="#l58.192"></a><span id="l58.192" class="difflineplus">+  LDAPMod* mods[2];</span>
<a href="#l58.193"></a><span id="l58.193" class="difflineplus">+  char* vals[2];</span>
<a href="#l58.194"></a><span id="l58.194" class="difflineplus">+  char* dn;</span>
<a href="#l58.195"></a><span id="l58.195" class="difflineplus">+  char* id = arg1;</span>
<a href="#l58.196"></a><span id="l58.196">   ldapmsgwrapper *list, *lmwp, *lastlmwp;</span>
<a href="#l58.197"></a><span id="l58.197"> </span>
<a href="#l58.198"></a><span id="l58.198">   printf(&quot;modify_thread\n&quot;);</span>
<a href="#l58.199"></a><span id="l58.199">   tsd_setup();</span>
<a href="#l58.200"></a><span id="l58.200">   if ((msgid = ldap_search(ld, BASE, LDAP_SCOPE_SUBTREE, &quot;(objectclass=*)&quot;,</span>
<a href="#l58.201"></a><span id="l58.201">                            NULL, 0)) == -1) {</span>
<a href="#l58.202"></a><span id="l58.202">     ldap_perror(ld, &quot;ldap_search_s&quot;);</span>
<a href="#l58.203"></a><span id="l58.203">     exit(1);</span>
<a href="#l58.204"></a><span id="l58.204">   }</span>
<a href="#l58.205"></a><span id="l58.205">   entries = 0;</span>
<a href="#l58.206"></a><span id="l58.206">   list = lastlmwp = NULL;</span>
<a href="#l58.207"></a><span id="l58.207">   while ((rc = ldap_result(ld, msgid, 0, NULL, &amp;res)) ==</span>
<a href="#l58.208"></a><span id="l58.208">          LDAP_RES_SEARCH_ENTRY) {</span>
<a href="#l58.209"></a><span id="l58.209">     entries++;</span>
<a href="#l58.210"></a><span id="l58.210" class="difflineminus">-    if ((lmwp = (ldapmsgwrapper *)malloc(sizeof(ldapmsgwrapper))) == NULL) {</span>
<a href="#l58.211"></a><span id="l58.211" class="difflineplus">+    if ((lmwp = (ldapmsgwrapper*)malloc(sizeof(ldapmsgwrapper))) == NULL) {</span>
<a href="#l58.212"></a><span id="l58.212">       perror(&quot;modify_thread: malloc&quot;);</span>
<a href="#l58.213"></a><span id="l58.213">       exit(1);</span>
<a href="#l58.214"></a><span id="l58.214">     }</span>
<a href="#l58.215"></a><span id="l58.215">     lmwp-&gt;lmw_messagep = res;</span>
<a href="#l58.216"></a><span id="l58.216">     lmwp-&gt;lmw_next = NULL;</span>
<a href="#l58.217"></a><span id="l58.217">     if (lastlmwp == NULL) {</span>
<a href="#l58.218"></a><span id="l58.218">       list = lastlmwp = lmwp;</span>
<a href="#l58.219"></a><span id="l58.219">     } else {</span>
<a href="#l58.220"></a><span id="l58.220" class="difflineat">@@ -367,23 +367,23 @@ static void modify_thread(void *arg1) {</span>
<a href="#l58.221"></a><span id="l58.221">           simplebind(ld, &quot;bind-modify_thread&quot;, 5) != LDAP_SUCCESS) {</span>
<a href="#l58.222"></a><span id="l58.222">         return;</span>
<a href="#l58.223"></a><span id="l58.223">       }</span>
<a href="#l58.224"></a><span id="l58.224">     }</span>
<a href="#l58.225"></a><span id="l58.225">     free(dn);</span>
<a href="#l58.226"></a><span id="l58.226">   }</span>
<a href="#l58.227"></a><span id="l58.227"> }</span>
<a href="#l58.228"></a><span id="l58.228"> </span>
<a href="#l58.229"></a><span id="l58.229" class="difflineminus">-static void add_thread(void *arg1) {</span>
<a href="#l58.230"></a><span id="l58.230" class="difflineplus">+static void add_thread(void* arg1) {</span>
<a href="#l58.231"></a><span id="l58.231">   LDAPMod mod[5];</span>
<a href="#l58.232"></a><span id="l58.232" class="difflineminus">-  LDAPMod *mods[6];</span>
<a href="#l58.233"></a><span id="l58.233" class="difflineplus">+  LDAPMod* mods[6];</span>
<a href="#l58.234"></a><span id="l58.234">   char dn[BUFSIZ], name[40];</span>
<a href="#l58.235"></a><span id="l58.235">   char *cnvals[2], *snvals[2], *ocvals[2];</span>
<a href="#l58.236"></a><span id="l58.236">   int i, rc;</span>
<a href="#l58.237"></a><span id="l58.237" class="difflineminus">-  char *id = arg1;</span>
<a href="#l58.238"></a><span id="l58.238" class="difflineplus">+  char* id = arg1;</span>
<a href="#l58.239"></a><span id="l58.239"> </span>
<a href="#l58.240"></a><span id="l58.240">   printf(&quot;add_thread\n&quot;);</span>
<a href="#l58.241"></a><span id="l58.241">   tsd_setup();</span>
<a href="#l58.242"></a><span id="l58.242">   for (i = 0; i &lt; 5; i++) {</span>
<a href="#l58.243"></a><span id="l58.243">     mods[i] = &amp;mod[i];</span>
<a href="#l58.244"></a><span id="l58.244">   }</span>
<a href="#l58.245"></a><span id="l58.245">   mods[5] = NULL;</span>
<a href="#l58.246"></a><span id="l58.246">   mod[0].mod_op = 0;</span>
<a href="#l58.247"></a><span id="l58.247" class="difflineat">@@ -413,21 +413,21 @@ static void add_thread(void *arg1) {</span>
<a href="#l58.248"></a><span id="l58.248">       if (CONNECTION_ERROR(rc) &amp;&amp;</span>
<a href="#l58.249"></a><span id="l58.249">           simplebind(ld, &quot;bind-add_thread&quot;, 5) != LDAP_SUCCESS) {</span>
<a href="#l58.250"></a><span id="l58.250">         return;</span>
<a href="#l58.251"></a><span id="l58.251">       }</span>
<a href="#l58.252"></a><span id="l58.252">     }</span>
<a href="#l58.253"></a><span id="l58.253">   }</span>
<a href="#l58.254"></a><span id="l58.254"> }</span>
<a href="#l58.255"></a><span id="l58.255"> </span>
<a href="#l58.256"></a><span id="l58.256" class="difflineminus">-static void delete_thread(void *arg1) {</span>
<a href="#l58.257"></a><span id="l58.257" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l58.258"></a><span id="l58.258" class="difflineplus">+static void delete_thread(void* arg1) {</span>
<a href="#l58.259"></a><span id="l58.259" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l58.260"></a><span id="l58.260">   char dn[BUFSIZ], name[40];</span>
<a href="#l58.261"></a><span id="l58.261">   int entries, msgid, rc;</span>
<a href="#l58.262"></a><span id="l58.262" class="difflineminus">-  char *id = arg1;</span>
<a href="#l58.263"></a><span id="l58.263" class="difflineplus">+  char* id = arg1;</span>
<a href="#l58.264"></a><span id="l58.264"> </span>
<a href="#l58.265"></a><span id="l58.265">   printf(&quot;delete_thread\n&quot;);</span>
<a href="#l58.266"></a><span id="l58.266">   tsd_setup();</span>
<a href="#l58.267"></a><span id="l58.267">   if ((msgid = ldap_search(ld, BASE, LDAP_SCOPE_SUBTREE, &quot;(objectclass=*)&quot;,</span>
<a href="#l58.268"></a><span id="l58.268">                            NULL, 0)) == -1) {</span>
<a href="#l58.269"></a><span id="l58.269">     ldap_perror(ld, &quot;delete_thread: ldap_search_s&quot;);</span>
<a href="#l58.270"></a><span id="l58.270">     exit(1);</span>
<a href="#l58.271"></a><span id="l58.271">   }</span>
<a href="#l58.272"></a><span id="l58.272" class="difflineat">@@ -456,52 +456,52 @@ static void delete_thread(void *arg1) {</span>
<a href="#l58.273"></a><span id="l58.273">         return;</span>
<a href="#l58.274"></a><span id="l58.274">       }</span>
<a href="#l58.275"></a><span id="l58.275">     }</span>
<a href="#l58.276"></a><span id="l58.276">   }</span>
<a href="#l58.277"></a><span id="l58.277"> }</span>
<a href="#l58.278"></a><span id="l58.278"> </span>
<a href="#l58.279"></a><span id="l58.279"> struct ldap_error {</span>
<a href="#l58.280"></a><span id="l58.280">   int le_errno;</span>
<a href="#l58.281"></a><span id="l58.281" class="difflineminus">-  char *le_matched;</span>
<a href="#l58.282"></a><span id="l58.282" class="difflineminus">-  char *le_errmsg;</span>
<a href="#l58.283"></a><span id="l58.283" class="difflineplus">+  char* le_matched;</span>
<a href="#l58.284"></a><span id="l58.284" class="difflineplus">+  char* le_errmsg;</span>
<a href="#l58.285"></a><span id="l58.285"> };</span>
<a href="#l58.286"></a><span id="l58.286"> </span>
<a href="#l58.287"></a><span id="l58.287"> static void tsd_setup() {</span>
<a href="#l58.288"></a><span id="l58.288" class="difflineminus">-  void *tsd;</span>
<a href="#l58.289"></a><span id="l58.289" class="difflineplus">+  void* tsd;</span>
<a href="#l58.290"></a><span id="l58.290"> </span>
<a href="#l58.291"></a><span id="l58.291" class="difflineminus">-  tsd = (void *)PR_GetThreadPrivate(tsdindex);</span>
<a href="#l58.292"></a><span id="l58.292" class="difflineplus">+  tsd = (void*)PR_GetThreadPrivate(tsdindex);</span>
<a href="#l58.293"></a><span id="l58.293">   if (tsd != NULL) {</span>
<a href="#l58.294"></a><span id="l58.294">     fprintf(stderr, &quot;tsd non-null!\n&quot;);</span>
<a href="#l58.295"></a><span id="l58.295">     exit(1);</span>
<a href="#l58.296"></a><span id="l58.296">   }</span>
<a href="#l58.297"></a><span id="l58.297" class="difflineminus">-  tsd = (void *)calloc(1, sizeof(struct ldap_error));</span>
<a href="#l58.298"></a><span id="l58.298" class="difflineplus">+  tsd = (void*)calloc(1, sizeof(struct ldap_error));</span>
<a href="#l58.299"></a><span id="l58.299">   if (PR_SetThreadPrivate(tsdindex, tsd) != 0) {</span>
<a href="#l58.300"></a><span id="l58.300">     perror(&quot;PR_SetThreadPrivate&quot;);</span>
<a href="#l58.301"></a><span id="l58.301">     exit(1);</span>
<a href="#l58.302"></a><span id="l58.302">   }</span>
<a href="#l58.303"></a><span id="l58.303"> }</span>
<a href="#l58.304"></a><span id="l58.304"> </span>
<a href="#l58.305"></a><span id="l58.305" class="difflineminus">-static void set_ld_error(int err, char *matched, char *errmsg, void *dummy) {</span>
<a href="#l58.306"></a><span id="l58.306" class="difflineminus">-  struct ldap_error *le;</span>
<a href="#l58.307"></a><span id="l58.307" class="difflineplus">+static void set_ld_error(int err, char* matched, char* errmsg, void* dummy) {</span>
<a href="#l58.308"></a><span id="l58.308" class="difflineplus">+  struct ldap_error* le;</span>
<a href="#l58.309"></a><span id="l58.309"> </span>
<a href="#l58.310"></a><span id="l58.310" class="difflineminus">-  le = (void *)PR_GetThreadPrivate(tsdindex);</span>
<a href="#l58.311"></a><span id="l58.311" class="difflineplus">+  le = (void*)PR_GetThreadPrivate(tsdindex);</span>
<a href="#l58.312"></a><span id="l58.312">   le-&gt;le_errno = err;</span>
<a href="#l58.313"></a><span id="l58.313">   if (le-&gt;le_matched != NULL) {</span>
<a href="#l58.314"></a><span id="l58.314">     ldap_memfree(le-&gt;le_matched);</span>
<a href="#l58.315"></a><span id="l58.315">   }</span>
<a href="#l58.316"></a><span id="l58.316">   le-&gt;le_matched = matched;</span>
<a href="#l58.317"></a><span id="l58.317">   if (le-&gt;le_errmsg != NULL) {</span>
<a href="#l58.318"></a><span id="l58.318">     ldap_memfree(le-&gt;le_errmsg);</span>
<a href="#l58.319"></a><span id="l58.319">   }</span>
<a href="#l58.320"></a><span id="l58.320">   le-&gt;le_errmsg = errmsg;</span>
<a href="#l58.321"></a><span id="l58.321"> }</span>
<a href="#l58.322"></a><span id="l58.322"> </span>
<a href="#l58.323"></a><span id="l58.323" class="difflineminus">-static int get_ld_error(char **matchedp, char **errmsgp, void *dummy) {</span>
<a href="#l58.324"></a><span id="l58.324" class="difflineminus">-  struct ldap_error *le;</span>
<a href="#l58.325"></a><span id="l58.325" class="difflineplus">+static int get_ld_error(char** matchedp, char** errmsgp, void* dummy) {</span>
<a href="#l58.326"></a><span id="l58.326" class="difflineplus">+  struct ldap_error* le;</span>
<a href="#l58.327"></a><span id="l58.327"> </span>
<a href="#l58.328"></a><span id="l58.328">   le = PR_GetThreadPrivate(tsdindex);</span>
<a href="#l58.329"></a><span id="l58.329">   if (matchedp != NULL) {</span>
<a href="#l58.330"></a><span id="l58.330">     *matchedp = le-&gt;le_matched;</span>
<a href="#l58.331"></a><span id="l58.331">   }</span>
<a href="#l58.332"></a><span id="l58.332">   if (errmsgp != NULL) {</span>
<a href="#l58.333"></a><span id="l58.333">     *errmsgp = le-&gt;le_errmsg;</span>
<a href="#l58.334"></a><span id="l58.334">   }</span>
<a href="#l58.335"></a><span id="l58.335" class="difflineat">@@ -513,60 +513,60 @@ static void set_errno(int oserrno) {</span>
<a href="#l58.336"></a><span id="l58.336">   PR_SetError(PR_UNKNOWN_ERROR, oserrno);</span>
<a href="#l58.337"></a><span id="l58.337"> }</span>
<a href="#l58.338"></a><span id="l58.338"> </span>
<a href="#l58.339"></a><span id="l58.339"> static int get_errno(void) {</span>
<a href="#l58.340"></a><span id="l58.340">   /* XXXmcs: should this be PR_GetError()? */</span>
<a href="#l58.341"></a><span id="l58.341">   return (PR_GetOSError());</span>
<a href="#l58.342"></a><span id="l58.342"> }</span>
<a href="#l58.343"></a><span id="l58.343"> </span>
<a href="#l58.344"></a><span id="l58.344" class="difflineminus">-static void *my_mutex_alloc(void) { return ((void *)PR_NewLock()); }</span>
<a href="#l58.345"></a><span id="l58.345" class="difflineplus">+static void* my_mutex_alloc(void) { return ((void*)PR_NewLock()); }</span>
<a href="#l58.346"></a><span id="l58.346"> </span>
<a href="#l58.347"></a><span id="l58.347" class="difflineminus">-static void my_mutex_free(void *mutex) { PR_DestroyLock((PRLock *)mutex); }</span>
<a href="#l58.348"></a><span id="l58.348" class="difflineplus">+static void my_mutex_free(void* mutex) { PR_DestroyLock((PRLock*)mutex); }</span>
<a href="#l58.349"></a><span id="l58.349"> </span>
<a href="#l58.350"></a><span id="l58.350" class="difflineminus">-static int my_mutex_lock(void *mutex) {</span>
<a href="#l58.351"></a><span id="l58.351" class="difflineminus">-  PR_Lock((PRLock *)mutex);</span>
<a href="#l58.352"></a><span id="l58.352" class="difflineplus">+static int my_mutex_lock(void* mutex) {</span>
<a href="#l58.353"></a><span id="l58.353" class="difflineplus">+  PR_Lock((PRLock*)mutex);</span>
<a href="#l58.354"></a><span id="l58.354">   return (0);</span>
<a href="#l58.355"></a><span id="l58.355"> }</span>
<a href="#l58.356"></a><span id="l58.356"> </span>
<a href="#l58.357"></a><span id="l58.357" class="difflineminus">-static int my_mutex_unlock(void *mutex) {</span>
<a href="#l58.358"></a><span id="l58.358" class="difflineminus">-  if (PR_Unlock((PRLock *)mutex) == PR_FAILURE) {</span>
<a href="#l58.359"></a><span id="l58.359" class="difflineplus">+static int my_mutex_unlock(void* mutex) {</span>
<a href="#l58.360"></a><span id="l58.360" class="difflineplus">+  if (PR_Unlock((PRLock*)mutex) == PR_FAILURE) {</span>
<a href="#l58.361"></a><span id="l58.361">     return (-1);</span>
<a href="#l58.362"></a><span id="l58.362">   }</span>
<a href="#l58.363"></a><span id="l58.363"> </span>
<a href="#l58.364"></a><span id="l58.364">   return (0);</span>
<a href="#l58.365"></a><span id="l58.365"> }</span>
<a href="#l58.366"></a><span id="l58.366"> </span>
<a href="#l58.367"></a><span id="l58.367" class="difflineminus">-static LDAPHostEnt *my_gethostbyname(const char *name, LDAPHostEnt *result,</span>
<a href="#l58.368"></a><span id="l58.368" class="difflineminus">-                                     char *buffer, int buflen, int *statusp,</span>
<a href="#l58.369"></a><span id="l58.369" class="difflineminus">-                                     void *extradata) {</span>
<a href="#l58.370"></a><span id="l58.370" class="difflineplus">+static LDAPHostEnt* my_gethostbyname(const char* name, LDAPHostEnt* result,</span>
<a href="#l58.371"></a><span id="l58.371" class="difflineplus">+                                     char* buffer, int buflen, int* statusp,</span>
<a href="#l58.372"></a><span id="l58.372" class="difflineplus">+                                     void* extradata) {</span>
<a href="#l58.373"></a><span id="l58.373">   PRHostEnt prhent;</span>
<a href="#l58.374"></a><span id="l58.374"> </span>
<a href="#l58.375"></a><span id="l58.375">   if (PR_GetHostByName(name, buffer, buflen, &amp;prhent) != PR_SUCCESS) {</span>
<a href="#l58.376"></a><span id="l58.376">     return (NULL);</span>
<a href="#l58.377"></a><span id="l58.377">   }</span>
<a href="#l58.378"></a><span id="l58.378"> </span>
<a href="#l58.379"></a><span id="l58.379">   return (copyPRHostEnt2LDAPHostEnt(result, &amp;prhent));</span>
<a href="#l58.380"></a><span id="l58.380"> }</span>
<a href="#l58.381"></a><span id="l58.381"> </span>
<a href="#l58.382"></a><span id="l58.382" class="difflineminus">-static LDAPHostEnt *my_gethostbyaddr(const char *addr, int length, int type,</span>
<a href="#l58.383"></a><span id="l58.383" class="difflineminus">-                                     LDAPHostEnt *result, char *buffer,</span>
<a href="#l58.384"></a><span id="l58.384" class="difflineminus">-                                     int buflen, int *statusp,</span>
<a href="#l58.385"></a><span id="l58.385" class="difflineminus">-                                     void *extradata) {</span>
<a href="#l58.386"></a><span id="l58.386" class="difflineplus">+static LDAPHostEnt* my_gethostbyaddr(const char* addr, int length, int type,</span>
<a href="#l58.387"></a><span id="l58.387" class="difflineplus">+                                     LDAPHostEnt* result, char* buffer,</span>
<a href="#l58.388"></a><span id="l58.388" class="difflineplus">+                                     int buflen, int* statusp,</span>
<a href="#l58.389"></a><span id="l58.389" class="difflineplus">+                                     void* extradata) {</span>
<a href="#l58.390"></a><span id="l58.390">   PRHostEnt prhent;</span>
<a href="#l58.391"></a><span id="l58.391"> </span>
<a href="#l58.392"></a><span id="l58.392" class="difflineminus">-  if (PR_GetHostByAddr((PRNetAddr *)addr, buffer, buflen, &amp;prhent) !=</span>
<a href="#l58.393"></a><span id="l58.393" class="difflineplus">+  if (PR_GetHostByAddr((PRNetAddr*)addr, buffer, buflen, &amp;prhent) !=</span>
<a href="#l58.394"></a><span id="l58.394">       PR_SUCCESS) {</span>
<a href="#l58.395"></a><span id="l58.395">     return (NULL);</span>
<a href="#l58.396"></a><span id="l58.396">   }</span>
<a href="#l58.397"></a><span id="l58.397"> </span>
<a href="#l58.398"></a><span id="l58.398">   return (copyPRHostEnt2LDAPHostEnt(result, &amp;prhent));</span>
<a href="#l58.399"></a><span id="l58.399"> }</span>
<a href="#l58.400"></a><span id="l58.400"> </span>
<a href="#l58.401"></a><span id="l58.401" class="difflineminus">-static LDAPHostEnt *copyPRHostEnt2LDAPHostEnt(LDAPHostEnt *ldhp,</span>
<a href="#l58.402"></a><span id="l58.402" class="difflineminus">-                                              PRHostEnt *prhp) {</span>
<a href="#l58.403"></a><span id="l58.403" class="difflineplus">+static LDAPHostEnt* copyPRHostEnt2LDAPHostEnt(LDAPHostEnt* ldhp,</span>
<a href="#l58.404"></a><span id="l58.404" class="difflineplus">+                                              PRHostEnt* prhp) {</span>
<a href="#l58.405"></a><span id="l58.405">   ldhp-&gt;ldaphe_name = prhp-&gt;h_name;</span>
<a href="#l58.406"></a><span id="l58.406">   ldhp-&gt;ldaphe_aliases = prhp-&gt;h_aliases;</span>
<a href="#l58.407"></a><span id="l58.407">   ldhp-&gt;ldaphe_addrtype = prhp-&gt;h_addrtype;</span>
<a href="#l58.408"></a><span id="l58.408">   ldhp-&gt;ldaphe_length = prhp-&gt;h_length;</span>
<a href="#l58.409"></a><span id="l58.409">   ldhp-&gt;ldaphe_addr_list = prhp-&gt;h_addr_list;</span>
<a href="#l58.410"></a><span id="l58.410">   return (ldhp);</span>
<a href="#l58.411"></a><span id="l58.411"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l59.1"></a><span id="l59.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/open.c</span>
<a href="#l59.2"></a><span id="l59.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/open.c</span>
<a href="#l59.3"></a><span id="l59.3" class="difflineat">@@ -92,91 +92,91 @@ int nsldapi_initialized = 0;</span>
<a href="#l59.4"></a><span id="l59.4"> #    define pthread_self PTHREAD_SELF</span>
<a href="#l59.5"></a><span id="l59.5"> extern pthread_t pthread_self(void);</span>
<a href="#l59.6"></a><span id="l59.6"> #  endif</span>
<a href="#l59.7"></a><span id="l59.7"> static pthread_key_t nsldapi_key;</span>
<a href="#l59.8"></a><span id="l59.8"> static pthread_mutex_t nsldapi_init_mutex = PTHREAD_MUTEX_INITIALIZER;</span>
<a href="#l59.9"></a><span id="l59.9"> </span>
<a href="#l59.10"></a><span id="l59.10"> struct nsldapi_ldap_error {</span>
<a href="#l59.11"></a><span id="l59.11">   int le_errno;</span>
<a href="#l59.12"></a><span id="l59.12" class="difflineminus">-  char *le_matched;</span>
<a href="#l59.13"></a><span id="l59.13" class="difflineminus">-  char *le_errmsg;</span>
<a href="#l59.14"></a><span id="l59.14" class="difflineplus">+  char* le_matched;</span>
<a href="#l59.15"></a><span id="l59.15" class="difflineplus">+  char* le_errmsg;</span>
<a href="#l59.16"></a><span id="l59.16"> };</span>
<a href="#l59.17"></a><span id="l59.17"> #elif defined(USE_WINDOWS_TLS)</span>
<a href="#l59.18"></a><span id="l59.18"> static DWORD dwTlsIndex;</span>
<a href="#l59.19"></a><span id="l59.19"> struct nsldapi_ldap_error {</span>
<a href="#l59.20"></a><span id="l59.20">   int le_errno;</span>
<a href="#l59.21"></a><span id="l59.21" class="difflineminus">-  char *le_matched;</span>
<a href="#l59.22"></a><span id="l59.22" class="difflineminus">-  char *le_errmsg;</span>
<a href="#l59.23"></a><span id="l59.23" class="difflineplus">+  char* le_matched;</span>
<a href="#l59.24"></a><span id="l59.24" class="difflineplus">+  char* le_errmsg;</span>
<a href="#l59.25"></a><span id="l59.25"> };</span>
<a href="#l59.26"></a><span id="l59.26"> #elif defined(_WINDOWS) /* use static tls */</span>
<a href="#l59.27"></a><span id="l59.27"> __declspec(thread) int nsldapi_gldaperrno;</span>
<a href="#l59.28"></a><span id="l59.28" class="difflineminus">-__declspec(thread) char *nsldapi_gmatched = NULL;</span>
<a href="#l59.29"></a><span id="l59.29" class="difflineminus">-__declspec(thread) char *nsldapi_gldaperror = NULL;</span>
<a href="#l59.30"></a><span id="l59.30" class="difflineplus">+__declspec(thread) char* nsldapi_gmatched = NULL;</span>
<a href="#l59.31"></a><span id="l59.31" class="difflineplus">+__declspec(thread) char* nsldapi_gldaperror = NULL;</span>
<a href="#l59.32"></a><span id="l59.32"> #endif                  /* USE_WINDOWS_TLS */</span>
<a href="#l59.33"></a><span id="l59.33"> </span>
<a href="#l59.34"></a><span id="l59.34"> #ifdef _WINDOWS</span>
<a href="#l59.35"></a><span id="l59.35"> #  define LDAP_MUTEX_T HANDLE</span>
<a href="#l59.36"></a><span id="l59.36"> static LDAP_MUTEX_T nsldapi_init_mutex;</span>
<a href="#l59.37"></a><span id="l59.37"> </span>
<a href="#l59.38"></a><span id="l59.38" class="difflineminus">-int pthread_mutex_init(LDAP_MUTEX_T *mp, void *attr) {</span>
<a href="#l59.39"></a><span id="l59.39" class="difflineplus">+int pthread_mutex_init(LDAP_MUTEX_T* mp, void* attr) {</span>
<a href="#l59.40"></a><span id="l59.40">   if ((*mp = CreateMutex(NULL, FALSE, NULL)) == NULL)</span>
<a href="#l59.41"></a><span id="l59.41">     return (1);</span>
<a href="#l59.42"></a><span id="l59.42">   else</span>
<a href="#l59.43"></a><span id="l59.43">     return (0);</span>
<a href="#l59.44"></a><span id="l59.44"> }</span>
<a href="#l59.45"></a><span id="l59.45"> </span>
<a href="#l59.46"></a><span id="l59.46" class="difflineminus">-static void *pthread_mutex_alloc(void) {</span>
<a href="#l59.47"></a><span id="l59.47" class="difflineminus">-  LDAP_MUTEX_T *mutexp;</span>
<a href="#l59.48"></a><span id="l59.48" class="difflineplus">+static void* pthread_mutex_alloc(void) {</span>
<a href="#l59.49"></a><span id="l59.49" class="difflineplus">+  LDAP_MUTEX_T* mutexp;</span>
<a href="#l59.50"></a><span id="l59.50"> </span>
<a href="#l59.51"></a><span id="l59.51">   if ((mutexp = malloc(sizeof(LDAP_MUTEX_T))) != NULL) {</span>
<a href="#l59.52"></a><span id="l59.52">     pthread_mutex_init(mutexp, NULL);</span>
<a href="#l59.53"></a><span id="l59.53">   }</span>
<a href="#l59.54"></a><span id="l59.54">   return (mutexp);</span>
<a href="#l59.55"></a><span id="l59.55"> }</span>
<a href="#l59.56"></a><span id="l59.56"> </span>
<a href="#l59.57"></a><span id="l59.57" class="difflineminus">-int pthread_mutex_destroy(LDAP_MUTEX_T *mp) {</span>
<a href="#l59.58"></a><span id="l59.58" class="difflineplus">+int pthread_mutex_destroy(LDAP_MUTEX_T* mp) {</span>
<a href="#l59.59"></a><span id="l59.59">   if (!(CloseHandle(*mp)))</span>
<a href="#l59.60"></a><span id="l59.60">     return (1);</span>
<a href="#l59.61"></a><span id="l59.61">   else</span>
<a href="#l59.62"></a><span id="l59.62">     return (0);</span>
<a href="#l59.63"></a><span id="l59.63"> }</span>
<a href="#l59.64"></a><span id="l59.64"> </span>
<a href="#l59.65"></a><span id="l59.65" class="difflineminus">-static void pthread_mutex_free(void *mutexp) {</span>
<a href="#l59.66"></a><span id="l59.66" class="difflineminus">-  pthread_mutex_destroy((LDAP_MUTEX_T *)mutexp);</span>
<a href="#l59.67"></a><span id="l59.67" class="difflineplus">+static void pthread_mutex_free(void* mutexp) {</span>
<a href="#l59.68"></a><span id="l59.68" class="difflineplus">+  pthread_mutex_destroy((LDAP_MUTEX_T*)mutexp);</span>
<a href="#l59.69"></a><span id="l59.69">   free(mutexp);</span>
<a href="#l59.70"></a><span id="l59.70"> }</span>
<a href="#l59.71"></a><span id="l59.71"> </span>
<a href="#l59.72"></a><span id="l59.72" class="difflineminus">-int pthread_mutex_lock(LDAP_MUTEX_T *mp) {</span>
<a href="#l59.73"></a><span id="l59.73" class="difflineplus">+int pthread_mutex_lock(LDAP_MUTEX_T* mp) {</span>
<a href="#l59.74"></a><span id="l59.74">   if ((WaitForSingleObject(*mp, INFINITE) != WAIT_OBJECT_0))</span>
<a href="#l59.75"></a><span id="l59.75">     return (1);</span>
<a href="#l59.76"></a><span id="l59.76">   else</span>
<a href="#l59.77"></a><span id="l59.77">     return (0);</span>
<a href="#l59.78"></a><span id="l59.78"> }</span>
<a href="#l59.79"></a><span id="l59.79"> </span>
<a href="#l59.80"></a><span id="l59.80" class="difflineminus">-int pthread_mutex_unlock(LDAP_MUTEX_T *mp) {</span>
<a href="#l59.81"></a><span id="l59.81" class="difflineplus">+int pthread_mutex_unlock(LDAP_MUTEX_T* mp) {</span>
<a href="#l59.82"></a><span id="l59.82">   if (!(ReleaseMutex(*mp)))</span>
<a href="#l59.83"></a><span id="l59.83">     return (1);</span>
<a href="#l59.84"></a><span id="l59.84">   else</span>
<a href="#l59.85"></a><span id="l59.85">     return (0);</span>
<a href="#l59.86"></a><span id="l59.86"> }</span>
<a href="#l59.87"></a><span id="l59.87"> </span>
<a href="#l59.88"></a><span id="l59.88"> static int get_errno(void) { return errno; }</span>
<a href="#l59.89"></a><span id="l59.89"> </span>
<a href="#l59.90"></a><span id="l59.90"> static void set_errno(int Errno) { errno = Errno; }</span>
<a href="#l59.91"></a><span id="l59.91"> </span>
<a href="#l59.92"></a><span id="l59.92"> #  ifdef USE_WINDOWS_TLS</span>
<a href="#l59.93"></a><span id="l59.93" class="difflineminus">-static void set_ld_error(int err, char *matched, char *errmsg, void *dummy) {</span>
<a href="#l59.94"></a><span id="l59.94" class="difflineminus">-  struct nsldapi_ldap_error *le;</span>
<a href="#l59.95"></a><span id="l59.95" class="difflineminus">-  void *tsd;</span>
<a href="#l59.96"></a><span id="l59.96" class="difflineplus">+static void set_ld_error(int err, char* matched, char* errmsg, void* dummy) {</span>
<a href="#l59.97"></a><span id="l59.97" class="difflineplus">+  struct nsldapi_ldap_error* le;</span>
<a href="#l59.98"></a><span id="l59.98" class="difflineplus">+  void* tsd;</span>
<a href="#l59.99"></a><span id="l59.99"> </span>
<a href="#l59.100"></a><span id="l59.100">   le = TlsGetValue(dwTlsIndex);</span>
<a href="#l59.101"></a><span id="l59.101"> </span>
<a href="#l59.102"></a><span id="l59.102">   if (le == NULL) {</span>
<a href="#l59.103"></a><span id="l59.103" class="difflineminus">-    tsd = (void *)calloc(1, sizeof(struct nsldapi_ldap_error));</span>
<a href="#l59.104"></a><span id="l59.104" class="difflineplus">+    tsd = (void*)calloc(1, sizeof(struct nsldapi_ldap_error));</span>
<a href="#l59.105"></a><span id="l59.105">     TlsSetValue(dwTlsIndex, tsd);</span>
<a href="#l59.106"></a><span id="l59.106">   }</span>
<a href="#l59.107"></a><span id="l59.107"> </span>
<a href="#l59.108"></a><span id="l59.108">   le = TlsGetValue(dwTlsIndex);</span>
<a href="#l59.109"></a><span id="l59.109"> </span>
<a href="#l59.110"></a><span id="l59.110">   if (le == NULL) return;</span>
<a href="#l59.111"></a><span id="l59.111"> </span>
<a href="#l59.112"></a><span id="l59.112">   le-&gt;le_errno = err;</span>
<a href="#l59.113"></a><span id="l59.113" class="difflineat">@@ -187,81 +187,81 @@ static void set_ld_error(int err, char *</span>
<a href="#l59.114"></a><span id="l59.114">   le-&gt;le_matched = matched;</span>
<a href="#l59.115"></a><span id="l59.115"> </span>
<a href="#l59.116"></a><span id="l59.116">   if (le-&gt;le_errmsg != NULL) {</span>
<a href="#l59.117"></a><span id="l59.117">     ldap_memfree(le-&gt;le_errmsg);</span>
<a href="#l59.118"></a><span id="l59.118">   }</span>
<a href="#l59.119"></a><span id="l59.119">   le-&gt;le_errmsg = errmsg;</span>
<a href="#l59.120"></a><span id="l59.120"> }</span>
<a href="#l59.121"></a><span id="l59.121"> </span>
<a href="#l59.122"></a><span id="l59.122" class="difflineminus">-static int get_ld_error(char **matched, char **errmsg, void *dummy) {</span>
<a href="#l59.123"></a><span id="l59.123" class="difflineminus">-  struct nsldapi_ldap_error *le;</span>
<a href="#l59.124"></a><span id="l59.124" class="difflineplus">+static int get_ld_error(char** matched, char** errmsg, void* dummy) {</span>
<a href="#l59.125"></a><span id="l59.125" class="difflineplus">+  struct nsldapi_ldap_error* le;</span>
<a href="#l59.126"></a><span id="l59.126"> </span>
<a href="#l59.127"></a><span id="l59.127">   le = TlsGetValue(dwTlsIndex);</span>
<a href="#l59.128"></a><span id="l59.128">   if (matched != NULL) {</span>
<a href="#l59.129"></a><span id="l59.129">     *matched = le-&gt;le_matched;</span>
<a href="#l59.130"></a><span id="l59.130">   }</span>
<a href="#l59.131"></a><span id="l59.131"> </span>
<a href="#l59.132"></a><span id="l59.132">   if (errmsg != NULL) {</span>
<a href="#l59.133"></a><span id="l59.133">     *errmsg = le-&gt;le_errmsg;</span>
<a href="#l59.134"></a><span id="l59.134">   }</span>
<a href="#l59.135"></a><span id="l59.135"> </span>
<a href="#l59.136"></a><span id="l59.136">   return (le-&gt;le_errno);</span>
<a href="#l59.137"></a><span id="l59.137"> }</span>
<a href="#l59.138"></a><span id="l59.138"> #  else</span>
<a href="#l59.139"></a><span id="l59.139" class="difflineminus">-static int get_ld_error(char **LDMatched, char **LDError, void *Args) {</span>
<a href="#l59.140"></a><span id="l59.140" class="difflineplus">+static int get_ld_error(char** LDMatched, char** LDError, void* Args) {</span>
<a href="#l59.141"></a><span id="l59.141">   if (LDMatched != NULL) {</span>
<a href="#l59.142"></a><span id="l59.142">     *LDMatched = nsldapi_gmatched;</span>
<a href="#l59.143"></a><span id="l59.143">   }</span>
<a href="#l59.144"></a><span id="l59.144">   if (LDError != NULL) {</span>
<a href="#l59.145"></a><span id="l59.145">     *LDError = nsldapi_gldaperror;</span>
<a href="#l59.146"></a><span id="l59.146">   }</span>
<a href="#l59.147"></a><span id="l59.147">   return nsldapi_gldaperrno;</span>
<a href="#l59.148"></a><span id="l59.148"> }</span>
<a href="#l59.149"></a><span id="l59.149"> </span>
<a href="#l59.150"></a><span id="l59.150" class="difflineminus">-static void set_ld_error(int LDErrno, char *LDMatched, char *LDError,</span>
<a href="#l59.151"></a><span id="l59.151" class="difflineminus">-                         void *Args) {</span>
<a href="#l59.152"></a><span id="l59.152" class="difflineplus">+static void set_ld_error(int LDErrno, char* LDMatched, char* LDError,</span>
<a href="#l59.153"></a><span id="l59.153" class="difflineplus">+                         void* Args) {</span>
<a href="#l59.154"></a><span id="l59.154">   /* Clean up any previous string storage. */</span>
<a href="#l59.155"></a><span id="l59.155">   if (nsldapi_gmatched != NULL) {</span>
<a href="#l59.156"></a><span id="l59.156">     ldap_memfree(nsldapi_gmatched);</span>
<a href="#l59.157"></a><span id="l59.157">   }</span>
<a href="#l59.158"></a><span id="l59.158">   if (nsldapi_gldaperror != NULL) {</span>
<a href="#l59.159"></a><span id="l59.159">     ldap_memfree(nsldapi_gldaperror);</span>
<a href="#l59.160"></a><span id="l59.160">   }</span>
<a href="#l59.161"></a><span id="l59.161"> </span>
<a href="#l59.162"></a><span id="l59.162">   nsldapi_gldaperrno = LDErrno;</span>
<a href="#l59.163"></a><span id="l59.163">   nsldapi_gmatched = LDMatched;</span>
<a href="#l59.164"></a><span id="l59.164">   nsldapi_gldaperror = LDError;</span>
<a href="#l59.165"></a><span id="l59.165"> }</span>
<a href="#l59.166"></a><span id="l59.166"> #  endif /* USE_WINDOWS_TLS */</span>
<a href="#l59.167"></a><span id="l59.167"> #endif   /* ! _WINDOWS */</span>
<a href="#l59.168"></a><span id="l59.168"> </span>
<a href="#l59.169"></a><span id="l59.169"> #ifdef USE_PTHREADS</span>
<a href="#l59.170"></a><span id="l59.170" class="difflineminus">-static void *pthread_mutex_alloc(void) {</span>
<a href="#l59.171"></a><span id="l59.171" class="difflineminus">-  pthread_mutex_t *mutexp;</span>
<a href="#l59.172"></a><span id="l59.172" class="difflineplus">+static void* pthread_mutex_alloc(void) {</span>
<a href="#l59.173"></a><span id="l59.173" class="difflineplus">+  pthread_mutex_t* mutexp;</span>
<a href="#l59.174"></a><span id="l59.174"> </span>
<a href="#l59.175"></a><span id="l59.175">   if ((mutexp = malloc(sizeof(pthread_mutex_t))) != NULL) {</span>
<a href="#l59.176"></a><span id="l59.176">     pthread_mutex_init(mutexp, NULL);</span>
<a href="#l59.177"></a><span id="l59.177">   }</span>
<a href="#l59.178"></a><span id="l59.178">   return (mutexp);</span>
<a href="#l59.179"></a><span id="l59.179"> }</span>
<a href="#l59.180"></a><span id="l59.180"> </span>
<a href="#l59.181"></a><span id="l59.181" class="difflineminus">-static void pthread_mutex_free(void *mutexp) {</span>
<a href="#l59.182"></a><span id="l59.182" class="difflineminus">-  pthread_mutex_destroy((pthread_mutex_t *)mutexp);</span>
<a href="#l59.183"></a><span id="l59.183" class="difflineplus">+static void pthread_mutex_free(void* mutexp) {</span>
<a href="#l59.184"></a><span id="l59.184" class="difflineplus">+  pthread_mutex_destroy((pthread_mutex_t*)mutexp);</span>
<a href="#l59.185"></a><span id="l59.185">   free(mutexp);</span>
<a href="#l59.186"></a><span id="l59.186"> }</span>
<a href="#l59.187"></a><span id="l59.187"> </span>
<a href="#l59.188"></a><span id="l59.188" class="difflineminus">-static void set_ld_error(int err, char *matched, char *errmsg, void *dummy) {</span>
<a href="#l59.189"></a><span id="l59.189" class="difflineminus">-  struct nsldapi_ldap_error *le;</span>
<a href="#l59.190"></a><span id="l59.190" class="difflineminus">-  void *tsd;</span>
<a href="#l59.191"></a><span id="l59.191" class="difflineplus">+static void set_ld_error(int err, char* matched, char* errmsg, void* dummy) {</span>
<a href="#l59.192"></a><span id="l59.192" class="difflineplus">+  struct nsldapi_ldap_error* le;</span>
<a href="#l59.193"></a><span id="l59.193" class="difflineplus">+  void* tsd;</span>
<a href="#l59.194"></a><span id="l59.194"> </span>
<a href="#l59.195"></a><span id="l59.195">   le = pthread_getspecific(nsldapi_key);</span>
<a href="#l59.196"></a><span id="l59.196"> </span>
<a href="#l59.197"></a><span id="l59.197">   if (le == NULL) {</span>
<a href="#l59.198"></a><span id="l59.198" class="difflineminus">-    tsd = (void *)calloc(1, sizeof(struct nsldapi_ldap_error));</span>
<a href="#l59.199"></a><span id="l59.199" class="difflineplus">+    tsd = (void*)calloc(1, sizeof(struct nsldapi_ldap_error));</span>
<a href="#l59.200"></a><span id="l59.200">     pthread_setspecific(nsldapi_key, tsd);</span>
<a href="#l59.201"></a><span id="l59.201">   }</span>
<a href="#l59.202"></a><span id="l59.202"> </span>
<a href="#l59.203"></a><span id="l59.203">   le = pthread_getspecific(nsldapi_key);</span>
<a href="#l59.204"></a><span id="l59.204"> </span>
<a href="#l59.205"></a><span id="l59.205">   if (le == NULL) return;</span>
<a href="#l59.206"></a><span id="l59.206"> </span>
<a href="#l59.207"></a><span id="l59.207">   le-&gt;le_errno = err;</span>
<a href="#l59.208"></a><span id="l59.208" class="difflineat">@@ -272,18 +272,18 @@ static void set_ld_error(int err, char *</span>
<a href="#l59.209"></a><span id="l59.209">   le-&gt;le_matched = matched;</span>
<a href="#l59.210"></a><span id="l59.210"> </span>
<a href="#l59.211"></a><span id="l59.211">   if (le-&gt;le_errmsg != NULL) {</span>
<a href="#l59.212"></a><span id="l59.212">     ldap_memfree(le-&gt;le_errmsg);</span>
<a href="#l59.213"></a><span id="l59.213">   }</span>
<a href="#l59.214"></a><span id="l59.214">   le-&gt;le_errmsg = errmsg;</span>
<a href="#l59.215"></a><span id="l59.215"> }</span>
<a href="#l59.216"></a><span id="l59.216"> </span>
<a href="#l59.217"></a><span id="l59.217" class="difflineminus">-static int get_ld_error(char **matched, char **errmsg, void *dummy) {</span>
<a href="#l59.218"></a><span id="l59.218" class="difflineminus">-  struct nsldapi_ldap_error *le;</span>
<a href="#l59.219"></a><span id="l59.219" class="difflineplus">+static int get_ld_error(char** matched, char** errmsg, void* dummy) {</span>
<a href="#l59.220"></a><span id="l59.220" class="difflineplus">+  struct nsldapi_ldap_error* le;</span>
<a href="#l59.221"></a><span id="l59.221"> </span>
<a href="#l59.222"></a><span id="l59.222">   le = pthread_getspecific(nsldapi_key);</span>
<a href="#l59.223"></a><span id="l59.223"> </span>
<a href="#l59.224"></a><span id="l59.224">   if (le == NULL) return (LDAP_SUCCESS);</span>
<a href="#l59.225"></a><span id="l59.225"> </span>
<a href="#l59.226"></a><span id="l59.226">   if (matched != NULL) {</span>
<a href="#l59.227"></a><span id="l59.227">     *matched = le-&gt;le_matched;</span>
<a href="#l59.228"></a><span id="l59.228">   }</span>
<a href="#l59.229"></a><span id="l59.229" class="difflineat">@@ -295,24 +295,24 @@ static int get_ld_error(char **matched, </span>
<a href="#l59.230"></a><span id="l59.230"> </span>
<a href="#l59.231"></a><span id="l59.231"> static void set_errno(int err) { errno = err; }</span>
<a href="#l59.232"></a><span id="l59.232"> </span>
<a href="#l59.233"></a><span id="l59.233"> static int get_errno(void) { return (errno); }</span>
<a href="#l59.234"></a><span id="l59.234"> #endif /* use_pthreads */</span>
<a href="#l59.235"></a><span id="l59.235"> </span>
<a href="#l59.236"></a><span id="l59.236"> #if defined(USE_PTHREADS) || defined(_WINDOWS)</span>
<a href="#l59.237"></a><span id="l59.237"> static struct ldap_thread_fns nsldapi_default_thread_fns = {</span>
<a href="#l59.238"></a><span id="l59.238" class="difflineminus">-    (void *(*)(void))pthread_mutex_alloc,</span>
<a href="#l59.239"></a><span id="l59.239" class="difflineminus">-    (void (*)(void *))pthread_mutex_free,</span>
<a href="#l59.240"></a><span id="l59.240" class="difflineminus">-    (int (*)(void *))pthread_mutex_lock,</span>
<a href="#l59.241"></a><span id="l59.241" class="difflineminus">-    (int (*)(void *))pthread_mutex_unlock,</span>
<a href="#l59.242"></a><span id="l59.242" class="difflineplus">+    (void* (*)(void))pthread_mutex_alloc,</span>
<a href="#l59.243"></a><span id="l59.243" class="difflineplus">+    (void (*)(void*))pthread_mutex_free,</span>
<a href="#l59.244"></a><span id="l59.244" class="difflineplus">+    (int (*)(void*))pthread_mutex_lock,</span>
<a href="#l59.245"></a><span id="l59.245" class="difflineplus">+    (int (*)(void*))pthread_mutex_unlock,</span>
<a href="#l59.246"></a><span id="l59.246">     (int (*)(void))get_errno,</span>
<a href="#l59.247"></a><span id="l59.247">     (void (*)(int))set_errno,</span>
<a href="#l59.248"></a><span id="l59.248" class="difflineminus">-    (int (*)(char **, char **, void *))get_ld_error,</span>
<a href="#l59.249"></a><span id="l59.249" class="difflineminus">-    (void (*)(int, char *, char *, void *))set_ld_error,</span>
<a href="#l59.250"></a><span id="l59.250" class="difflineplus">+    (int (*)(char**, char**, void*))get_ld_error,</span>
<a href="#l59.251"></a><span id="l59.251" class="difflineplus">+    (void (*)(int, char*, char*, void*))set_ld_error,</span>
<a href="#l59.252"></a><span id="l59.252">     0};</span>
<a href="#l59.253"></a><span id="l59.253"> </span>
<a href="#l59.254"></a><span id="l59.254"> static struct ldap_extra_thread_fns nsldapi_default_extra_thread_fns = {0, 0, 0,</span>
<a href="#l59.255"></a><span id="l59.255">                                                                         0, 0,</span>
<a href="#l59.256"></a><span id="l59.256"> #  ifdef _WINDOWS</span>
<a href="#l59.257"></a><span id="l59.257">                                                                         0</span>
<a href="#l59.258"></a><span id="l59.258"> #  else</span>
<a href="#l59.259"></a><span id="l59.259">    (void *(*)(void))pthread_self</span>
<a href="#l59.260"></a><span id="l59.260" class="difflineat">@@ -362,24 +362,24 @@ void nsldapi_initialize_defaults(void) {</span>
<a href="#l59.261"></a><span id="l59.261">   /* SASL Security properties */</span>
<a href="#l59.262"></a><span id="l59.262">   nsldapi_ld_defaults.ld_sasl_secprops.max_ssf = UINT_MAX;</span>
<a href="#l59.263"></a><span id="l59.263">   nsldapi_ld_defaults.ld_sasl_secprops.maxbufsize = SASL_MAX_BUFF_SIZE;</span>
<a href="#l59.264"></a><span id="l59.264">   nsldapi_ld_defaults.ld_sasl_secprops.security_flags =</span>
<a href="#l59.265"></a><span id="l59.265">       SASL_SEC_NOPLAINTEXT | SASL_SEC_NOANONYMOUS;</span>
<a href="#l59.266"></a><span id="l59.266"> </span>
<a href="#l59.267"></a><span id="l59.267">   /* SASL mutex function callbacks */</span>
<a href="#l59.268"></a><span id="l59.268">   sasl_set_mutex(</span>
<a href="#l59.269"></a><span id="l59.269" class="difflineminus">-      (sasl_mutex_alloc_t *)nsldapi_default_thread_fns.ltf_mutex_alloc,</span>
<a href="#l59.270"></a><span id="l59.270" class="difflineminus">-      (sasl_mutex_lock_t *)nsldapi_default_thread_fns.ltf_mutex_lock,</span>
<a href="#l59.271"></a><span id="l59.271" class="difflineminus">-      (sasl_mutex_unlock_t *)nsldapi_default_thread_fns.ltf_mutex_unlock,</span>
<a href="#l59.272"></a><span id="l59.272" class="difflineminus">-      (sasl_mutex_free_t *)nsldapi_default_thread_fns.ltf_mutex_free);</span>
<a href="#l59.273"></a><span id="l59.273" class="difflineplus">+      (sasl_mutex_alloc_t*)nsldapi_default_thread_fns.ltf_mutex_alloc,</span>
<a href="#l59.274"></a><span id="l59.274" class="difflineplus">+      (sasl_mutex_lock_t*)nsldapi_default_thread_fns.ltf_mutex_lock,</span>
<a href="#l59.275"></a><span id="l59.275" class="difflineplus">+      (sasl_mutex_unlock_t*)nsldapi_default_thread_fns.ltf_mutex_unlock,</span>
<a href="#l59.276"></a><span id="l59.276" class="difflineplus">+      (sasl_mutex_free_t*)nsldapi_default_thread_fns.ltf_mutex_free);</span>
<a href="#l59.277"></a><span id="l59.277"> </span>
<a href="#l59.278"></a><span id="l59.278">   /* SASL memory allocation function callbacks */</span>
<a href="#l59.279"></a><span id="l59.279" class="difflineminus">-  sasl_set_alloc((sasl_malloc_t *)ldap_x_malloc, (sasl_calloc_t *)ldap_x_calloc,</span>
<a href="#l59.280"></a><span id="l59.280" class="difflineminus">-                 (sasl_realloc_t *)ldap_x_realloc, (sasl_free_t *)ldap_x_free);</span>
<a href="#l59.281"></a><span id="l59.281" class="difflineplus">+  sasl_set_alloc((sasl_malloc_t*)ldap_x_malloc, (sasl_calloc_t*)ldap_x_calloc,</span>
<a href="#l59.282"></a><span id="l59.282" class="difflineplus">+                 (sasl_realloc_t*)ldap_x_realloc, (sasl_free_t*)ldap_x_free);</span>
<a href="#l59.283"></a><span id="l59.283"> </span>
<a href="#l59.284"></a><span id="l59.284">   /* SASL library initialization */</span>
<a href="#l59.285"></a><span id="l59.285">   if (sasl_client_init(client_callbacks) != SASL_OK) {</span>
<a href="#l59.286"></a><span id="l59.286">     nsldapi_initialized = 0;</span>
<a href="#l59.287"></a><span id="l59.287">     pthread_mutex_unlock(&amp;nsldapi_init_mutex);</span>
<a href="#l59.288"></a><span id="l59.288">     return;</span>
<a href="#l59.289"></a><span id="l59.289">   }</span>
<a href="#l59.290"></a><span id="l59.290"> #endif</span>
<a href="#l59.291"></a><span id="l59.291" class="difflineat">@@ -394,26 +394,26 @@ void nsldapi_initialize_defaults(void) {</span>
<a href="#l59.292"></a><span id="l59.292"> </span>
<a href="#l59.293"></a><span id="l59.293">   /* set default connect timeout (in milliseconds) */</span>
<a href="#l59.294"></a><span id="l59.294">   /* this was picked as it is the standard tcp timeout as well */</span>
<a href="#l59.295"></a><span id="l59.295">   nsldapi_ld_defaults.ld_connect_timeout = LDAP_X_IO_TIMEOUT_NO_TIMEOUT;</span>
<a href="#l59.296"></a><span id="l59.296"> </span>
<a href="#l59.297"></a><span id="l59.297"> #if defined(USE_PTHREADS) || defined(_WINDOWS)</span>
<a href="#l59.298"></a><span id="l59.298">   /* load up default platform specific locking routines */</span>
<a href="#l59.299"></a><span id="l59.299">   if (ldap_set_option(&amp;nsldapi_ld_defaults, LDAP_OPT_THREAD_FN_PTRS,</span>
<a href="#l59.300"></a><span id="l59.300" class="difflineminus">-                      (void *)&amp;nsldapi_default_thread_fns) != LDAP_SUCCESS) {</span>
<a href="#l59.301"></a><span id="l59.301" class="difflineplus">+                      (void*)&amp;nsldapi_default_thread_fns) != LDAP_SUCCESS) {</span>
<a href="#l59.302"></a><span id="l59.302">     nsldapi_initialized = 0;</span>
<a href="#l59.303"></a><span id="l59.303">     pthread_mutex_unlock(&amp;nsldapi_init_mutex);</span>
<a href="#l59.304"></a><span id="l59.304">     return;</span>
<a href="#l59.305"></a><span id="l59.305">   }</span>
<a href="#l59.306"></a><span id="l59.306"> </span>
<a href="#l59.307"></a><span id="l59.307"> #  ifndef _WINDOWS</span>
<a href="#l59.308"></a><span id="l59.308">   /* load up default threadid function */</span>
<a href="#l59.309"></a><span id="l59.309">   if (ldap_set_option(&amp;nsldapi_ld_defaults, LDAP_OPT_EXTRA_THREAD_FN_PTRS,</span>
<a href="#l59.310"></a><span id="l59.310" class="difflineminus">-                      (void *)&amp;nsldapi_default_extra_thread_fns) !=</span>
<a href="#l59.311"></a><span id="l59.311" class="difflineplus">+                      (void*)&amp;nsldapi_default_extra_thread_fns) !=</span>
<a href="#l59.312"></a><span id="l59.312">       LDAP_SUCCESS) {</span>
<a href="#l59.313"></a><span id="l59.313">     nsldapi_initialized = 0;</span>
<a href="#l59.314"></a><span id="l59.314">     pthread_mutex_unlock(&amp;nsldapi_init_mutex);</span>
<a href="#l59.315"></a><span id="l59.315">     return;</span>
<a href="#l59.316"></a><span id="l59.316">   }</span>
<a href="#l59.317"></a><span id="l59.317"> #  endif /* _WINDOWS */</span>
<a href="#l59.318"></a><span id="l59.318">   nsldapi_initialized = 1;</span>
<a href="#l59.319"></a><span id="l59.319">   pthread_mutex_unlock(&amp;nsldapi_init_mutex);</span>
<a href="#l59.320"></a><span id="l59.320" class="difflineat">@@ -433,17 +433,17 @@ void nsldapi_initialize_defaults(void) {</span>
<a href="#l59.321"></a><span id="l59.321">  * if ((ver.sdk_version &lt; 100) || (ver.SSL_version &lt; 300))</span>
<a href="#l59.322"></a><span id="l59.322">  *   fprintf(stderr, &quot;LDAP SDK level insufficient\n&quot;);</span>
<a href="#l59.323"></a><span id="l59.323">  *</span>
<a href="#l59.324"></a><span id="l59.324">  * or:</span>
<a href="#l59.325"></a><span id="l59.325">  * if (ldap_version(NULL) &lt; 100)</span>
<a href="#l59.326"></a><span id="l59.326">  *   fprintf(stderr, &quot;LDAP SDK level insufficient\n&quot;);</span>
<a href="#l59.327"></a><span id="l59.327">  */</span>
<a href="#l59.328"></a><span id="l59.328"> </span>
<a href="#l59.329"></a><span id="l59.329" class="difflineminus">-int LDAP_CALL ldap_version(LDAPVersion *ver) {</span>
<a href="#l59.330"></a><span id="l59.330" class="difflineplus">+int LDAP_CALL ldap_version(LDAPVersion* ver) {</span>
<a href="#l59.331"></a><span id="l59.331">   if (NULL != ver) {</span>
<a href="#l59.332"></a><span id="l59.332">     memset(ver, 0, sizeof(*ver));</span>
<a href="#l59.333"></a><span id="l59.333">     ver-&gt;sdk_version = (int)(VI_PRODUCTVERSION * 100);</span>
<a href="#l59.334"></a><span id="l59.334">     ver-&gt;protocol_version = LDAP_VERSION_MAX * 100;</span>
<a href="#l59.335"></a><span id="l59.335">     ver-&gt;SSL_version = SSL_VERSION * 100;</span>
<a href="#l59.336"></a><span id="l59.336">     /*</span>
<a href="#l59.337"></a><span id="l59.337">      * set security to none by default</span>
<a href="#l59.338"></a><span id="l59.338">      */</span>
<a href="#l59.339"></a><span id="l59.339" class="difflineat">@@ -465,18 +465,18 @@ int LDAP_CALL ldap_version(LDAPVersion *</span>
<a href="#l59.340"></a><span id="l59.340">  * be used for future communication is returned on success, NULL on failure.</span>
<a href="#l59.341"></a><span id="l59.341">  * &quot;host&quot; may be a space-separated list of hosts or IP addresses</span>
<a href="#l59.342"></a><span id="l59.342">  *</span>
<a href="#l59.343"></a><span id="l59.343">  * Example:</span>
<a href="#l59.344"></a><span id="l59.344">  * LDAP  *ld;</span>
<a href="#l59.345"></a><span id="l59.345">  * ld = ldap_open(hostname, port);</span>
<a href="#l59.346"></a><span id="l59.346">  */</span>
<a href="#l59.347"></a><span id="l59.347"> </span>
<a href="#l59.348"></a><span id="l59.348" class="difflineminus">-LDAP *LDAP_CALL ldap_open(const char *host, int port) {</span>
<a href="#l59.349"></a><span id="l59.349" class="difflineminus">-  LDAP *ld;</span>
<a href="#l59.350"></a><span id="l59.350" class="difflineplus">+LDAP* LDAP_CALL ldap_open(const char* host, int port) {</span>
<a href="#l59.351"></a><span id="l59.351" class="difflineplus">+  LDAP* ld;</span>
<a href="#l59.352"></a><span id="l59.352"> </span>
<a href="#l59.353"></a><span id="l59.353">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_open\n&quot;, 0, 0, 0);</span>
<a href="#l59.354"></a><span id="l59.354"> </span>
<a href="#l59.355"></a><span id="l59.355">   if ((ld = ldap_init(host, port)) == NULL) {</span>
<a href="#l59.356"></a><span id="l59.356">     return (NULL);</span>
<a href="#l59.357"></a><span id="l59.357">   }</span>
<a href="#l59.358"></a><span id="l59.358"> </span>
<a href="#l59.359"></a><span id="l59.359">   LDAP_MUTEX_LOCK(ld, LDAP_CONN_LOCK);</span>
<a href="#l59.360"></a><span id="l59.360" class="difflineat">@@ -501,18 +501,18 @@ LDAP *LDAP_CALL ldap_open(const char *ho</span>
<a href="#l59.361"></a><span id="l59.361">  * NOTE: If you want to use IPv6, you must use prldap creating a LDAP handle</span>
<a href="#l59.362"></a><span id="l59.362">  * with prldap_init instead of ldap_init. Or install the NSPR functions</span>
<a href="#l59.363"></a><span id="l59.363">  * by calling prldap_install_routines. (See the nspr samples in examples)</span>
<a href="#l59.364"></a><span id="l59.364">  *</span>
<a href="#l59.365"></a><span id="l59.365">  * Example:</span>
<a href="#l59.366"></a><span id="l59.366">  * LDAP  *ld;</span>
<a href="#l59.367"></a><span id="l59.367">  * ld = ldap_init(default_hostname, default_port);</span>
<a href="#l59.368"></a><span id="l59.368">  */</span>
<a href="#l59.369"></a><span id="l59.369" class="difflineminus">-LDAP *LDAP_CALL ldap_init(const char *defhost, int defport) {</span>
<a href="#l59.370"></a><span id="l59.370" class="difflineminus">-  LDAP *ld;</span>
<a href="#l59.371"></a><span id="l59.371" class="difflineplus">+LDAP* LDAP_CALL ldap_init(const char* defhost, int defport) {</span>
<a href="#l59.372"></a><span id="l59.372" class="difflineplus">+  LDAP* ld;</span>
<a href="#l59.373"></a><span id="l59.373"> </span>
<a href="#l59.374"></a><span id="l59.374">   if (!nsldapi_initialized) {</span>
<a href="#l59.375"></a><span id="l59.375">     nsldapi_initialize_defaults();</span>
<a href="#l59.376"></a><span id="l59.376">   }</span>
<a href="#l59.377"></a><span id="l59.377"> </span>
<a href="#l59.378"></a><span id="l59.378">   if (defport &lt; 0 || defport &gt; LDAP_PORT_MAX) {</span>
<a href="#l59.379"></a><span id="l59.379">     LDAPDebug(LDAP_DEBUG_ANY,</span>
<a href="#l59.380"></a><span id="l59.380">               &quot;ldap_init: port %d is invalid (port numbers must range from 1 &quot;</span>
<a href="#l59.381"></a><span id="l59.381" class="difflineat">@@ -521,148 +521,148 @@ LDAP *LDAP_CALL ldap_init(const char *de</span>
<a href="#l59.382"></a><span id="l59.382"> #if !defined(macintosh) &amp;&amp; !defined(DOS) &amp;&amp; !defined(BEOS)</span>
<a href="#l59.383"></a><span id="l59.383">     errno = EINVAL;</span>
<a href="#l59.384"></a><span id="l59.384"> #endif</span>
<a href="#l59.385"></a><span id="l59.385">     return (NULL);</span>
<a href="#l59.386"></a><span id="l59.386">   }</span>
<a href="#l59.387"></a><span id="l59.387"> </span>
<a href="#l59.388"></a><span id="l59.388">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_init\n&quot;, 0, 0, 0);</span>
<a href="#l59.389"></a><span id="l59.389"> </span>
<a href="#l59.390"></a><span id="l59.390" class="difflineminus">-  if ((ld = (LDAP *)NSLDAPI_MALLOC(sizeof(struct ldap))) == NULL) {</span>
<a href="#l59.391"></a><span id="l59.391" class="difflineplus">+  if ((ld = (LDAP*)NSLDAPI_MALLOC(sizeof(struct ldap))) == NULL) {</span>
<a href="#l59.392"></a><span id="l59.392">     return (NULL);</span>
<a href="#l59.393"></a><span id="l59.393">   }</span>
<a href="#l59.394"></a><span id="l59.394"> </span>
<a href="#l59.395"></a><span id="l59.395">   /* copy defaults */</span>
<a href="#l59.396"></a><span id="l59.396">   SAFEMEMCPY(ld, &amp;nsldapi_ld_defaults, sizeof(struct ldap));</span>
<a href="#l59.397"></a><span id="l59.397">   if (nsldapi_ld_defaults.ld_io_fns_ptr != NULL) {</span>
<a href="#l59.398"></a><span id="l59.398" class="difflineminus">-    if ((ld-&gt;ld_io_fns_ptr = (struct ldap_io_fns *)NSLDAPI_MALLOC(</span>
<a href="#l59.399"></a><span id="l59.399" class="difflineplus">+    if ((ld-&gt;ld_io_fns_ptr = (struct ldap_io_fns*)NSLDAPI_MALLOC(</span>
<a href="#l59.400"></a><span id="l59.400">              sizeof(struct ldap_io_fns))) == NULL) {</span>
<a href="#l59.401"></a><span id="l59.401" class="difflineminus">-      NSLDAPI_FREE((char *)ld);</span>
<a href="#l59.402"></a><span id="l59.402" class="difflineplus">+      NSLDAPI_FREE((char*)ld);</span>
<a href="#l59.403"></a><span id="l59.403">       return (NULL);</span>
<a href="#l59.404"></a><span id="l59.404">     }</span>
<a href="#l59.405"></a><span id="l59.405">     /* struct copy */</span>
<a href="#l59.406"></a><span id="l59.406">     *(ld-&gt;ld_io_fns_ptr) = *(nsldapi_ld_defaults.ld_io_fns_ptr);</span>
<a href="#l59.407"></a><span id="l59.407">   }</span>
<a href="#l59.408"></a><span id="l59.408"> </span>
<a href="#l59.409"></a><span id="l59.409">   /* call the new handle I/O callback if one is defined */</span>
<a href="#l59.410"></a><span id="l59.410">   if (ld-&gt;ld_extnewhandle_fn != NULL) {</span>
<a href="#l59.411"></a><span id="l59.411">     /*</span>
<a href="#l59.412"></a><span id="l59.412">      * We always pass the session extended I/O argument to</span>
<a href="#l59.413"></a><span id="l59.413">      * the new handle callback.</span>
<a href="#l59.414"></a><span id="l59.414">      */</span>
<a href="#l59.415"></a><span id="l59.415">     if (ld-&gt;ld_extnewhandle_fn(ld, ld-&gt;ld_ext_session_arg) != LDAP_SUCCESS) {</span>
<a href="#l59.416"></a><span id="l59.416" class="difflineminus">-      NSLDAPI_FREE((char *)ld);</span>
<a href="#l59.417"></a><span id="l59.417" class="difflineplus">+      NSLDAPI_FREE((char*)ld);</span>
<a href="#l59.418"></a><span id="l59.418">       return (NULL);</span>
<a href="#l59.419"></a><span id="l59.419">     }</span>
<a href="#l59.420"></a><span id="l59.420">   }</span>
<a href="#l59.421"></a><span id="l59.421"> </span>
<a href="#l59.422"></a><span id="l59.422">   /* allocate session-specific resources */</span>
<a href="#l59.423"></a><span id="l59.423">   if ((ld-&gt;ld_sbp = ber_sockbuf_alloc()) == NULL ||</span>
<a href="#l59.424"></a><span id="l59.424">       (defhost != NULL &amp;&amp; (ld-&gt;ld_defhost = nsldapi_strdup(defhost)) == NULL) ||</span>
<a href="#l59.425"></a><span id="l59.425" class="difflineminus">-      ((ld-&gt;ld_mutex =</span>
<a href="#l59.426"></a><span id="l59.426" class="difflineminus">-            (void **)NSLDAPI_CALLOC(LDAP_MAX_LOCK, sizeof(void *))) == NULL)) {</span>
<a href="#l59.427"></a><span id="l59.427" class="difflineplus">+      ((ld-&gt;ld_mutex = (void**)NSLDAPI_CALLOC(LDAP_MAX_LOCK, sizeof(void*))) ==</span>
<a href="#l59.428"></a><span id="l59.428" class="difflineplus">+       NULL)) {</span>
<a href="#l59.429"></a><span id="l59.429">     if (ld-&gt;ld_sbp != NULL) {</span>
<a href="#l59.430"></a><span id="l59.430">       ber_sockbuf_free(ld-&gt;ld_sbp);</span>
<a href="#l59.431"></a><span id="l59.431">     }</span>
<a href="#l59.432"></a><span id="l59.432">     if (ld-&gt;ld_mutex != NULL) {</span>
<a href="#l59.433"></a><span id="l59.433">       NSLDAPI_FREE(ld-&gt;ld_mutex);</span>
<a href="#l59.434"></a><span id="l59.434">     }</span>
<a href="#l59.435"></a><span id="l59.435" class="difflineminus">-    NSLDAPI_FREE((char *)ld);</span>
<a href="#l59.436"></a><span id="l59.436" class="difflineplus">+    NSLDAPI_FREE((char*)ld);</span>
<a href="#l59.437"></a><span id="l59.437">     return (NULL);</span>
<a href="#l59.438"></a><span id="l59.438">   }</span>
<a href="#l59.439"></a><span id="l59.439"> </span>
<a href="#l59.440"></a><span id="l59.440">   /* install Sockbuf I/O functions if set in LDAP * */</span>
<a href="#l59.441"></a><span id="l59.441">   if (ld-&gt;ld_extread_fn != NULL || ld-&gt;ld_extwrite_fn != NULL) {</span>
<a href="#l59.442"></a><span id="l59.442">     struct lber_x_ext_io_fns lberiofns;</span>
<a href="#l59.443"></a><span id="l59.443"> </span>
<a href="#l59.444"></a><span id="l59.444">     memset(&amp;lberiofns, 0, sizeof(lberiofns));</span>
<a href="#l59.445"></a><span id="l59.445"> </span>
<a href="#l59.446"></a><span id="l59.446">     lberiofns.lbextiofn_size = LBER_X_EXTIO_FNS_SIZE;</span>
<a href="#l59.447"></a><span id="l59.447">     lberiofns.lbextiofn_read = ld-&gt;ld_extread_fn;</span>
<a href="#l59.448"></a><span id="l59.448">     lberiofns.lbextiofn_write = ld-&gt;ld_extwrite_fn;</span>
<a href="#l59.449"></a><span id="l59.449">     lberiofns.lbextiofn_writev = ld-&gt;ld_extwritev_fn;</span>
<a href="#l59.450"></a><span id="l59.450">     lberiofns.lbextiofn_socket_arg = NULL;</span>
<a href="#l59.451"></a><span id="l59.451">     ber_sockbuf_set_option(ld-&gt;ld_sbp, LBER_SOCKBUF_OPT_EXT_IO_FNS,</span>
<a href="#l59.452"></a><span id="l59.452" class="difflineminus">-                           (void *)&amp;lberiofns);</span>
<a href="#l59.453"></a><span id="l59.453" class="difflineplus">+                           (void*)&amp;lberiofns);</span>
<a href="#l59.454"></a><span id="l59.454">   }</span>
<a href="#l59.455"></a><span id="l59.455"> </span>
<a href="#l59.456"></a><span id="l59.456">   /* allocate mutexes */</span>
<a href="#l59.457"></a><span id="l59.457">   nsldapi_mutex_alloc_all(ld);</span>
<a href="#l59.458"></a><span id="l59.458"> </span>
<a href="#l59.459"></a><span id="l59.459">   /* set default port */</span>
<a href="#l59.460"></a><span id="l59.460">   ld-&gt;ld_defport = (defport == 0) ? LDAP_PORT : defport;</span>
<a href="#l59.461"></a><span id="l59.461"> </span>
<a href="#l59.462"></a><span id="l59.462">   return (ld);</span>
<a href="#l59.463"></a><span id="l59.463"> }</span>
<a href="#l59.464"></a><span id="l59.464"> </span>
<a href="#l59.465"></a><span id="l59.465" class="difflineminus">-void nsldapi_mutex_alloc_all(LDAP *ld) {</span>
<a href="#l59.466"></a><span id="l59.466" class="difflineplus">+void nsldapi_mutex_alloc_all(LDAP* ld) {</span>
<a href="#l59.467"></a><span id="l59.467">   int i;</span>
<a href="#l59.468"></a><span id="l59.468"> </span>
<a href="#l59.469"></a><span id="l59.469">   if (ld != &amp;nsldapi_ld_defaults &amp;&amp; ld-&gt;ld_mutex != NULL) {</span>
<a href="#l59.470"></a><span id="l59.470">     for (i = 0; i &lt; LDAP_MAX_LOCK; i++) {</span>
<a href="#l59.471"></a><span id="l59.471">       ld-&gt;ld_mutex[i] = LDAP_MUTEX_ALLOC(ld);</span>
<a href="#l59.472"></a><span id="l59.472" class="difflineminus">-      ld-&gt;ld_mutex_threadid[i] = (void *)-1;</span>
<a href="#l59.473"></a><span id="l59.473" class="difflineplus">+      ld-&gt;ld_mutex_threadid[i] = (void*)-1;</span>
<a href="#l59.474"></a><span id="l59.474">       ld-&gt;ld_mutex_refcnt[i] = 0;</span>
<a href="#l59.475"></a><span id="l59.475">     }</span>
<a href="#l59.476"></a><span id="l59.476">   }</span>
<a href="#l59.477"></a><span id="l59.477"> }</span>
<a href="#l59.478"></a><span id="l59.478"> </span>
<a href="#l59.479"></a><span id="l59.479" class="difflineminus">-void nsldapi_mutex_free_all(LDAP *ld) {</span>
<a href="#l59.480"></a><span id="l59.480" class="difflineplus">+void nsldapi_mutex_free_all(LDAP* ld) {</span>
<a href="#l59.481"></a><span id="l59.481">   int i;</span>
<a href="#l59.482"></a><span id="l59.482"> </span>
<a href="#l59.483"></a><span id="l59.483">   if (ld != &amp;nsldapi_ld_defaults &amp;&amp; ld-&gt;ld_mutex != NULL) {</span>
<a href="#l59.484"></a><span id="l59.484">     for (i = 0; i &lt; LDAP_MAX_LOCK; i++) {</span>
<a href="#l59.485"></a><span id="l59.485">       LDAP_MUTEX_FREE(ld, ld-&gt;ld_mutex[i]);</span>
<a href="#l59.486"></a><span id="l59.486">     }</span>
<a href="#l59.487"></a><span id="l59.487">   }</span>
<a href="#l59.488"></a><span id="l59.488"> }</span>
<a href="#l59.489"></a><span id="l59.489"> </span>
<a href="#l59.490"></a><span id="l59.490"> /* returns 0 if connection opened and -1 if an error occurs */</span>
<a href="#l59.491"></a><span id="l59.491" class="difflineminus">-int nsldapi_open_ldap_defconn(LDAP *ld) {</span>
<a href="#l59.492"></a><span id="l59.492" class="difflineminus">-  LDAPServer *srv;</span>
<a href="#l59.493"></a><span id="l59.493" class="difflineplus">+int nsldapi_open_ldap_defconn(LDAP* ld) {</span>
<a href="#l59.494"></a><span id="l59.494" class="difflineplus">+  LDAPServer* srv;</span>
<a href="#l59.495"></a><span id="l59.495"> </span>
<a href="#l59.496"></a><span id="l59.496" class="difflineminus">-  if ((srv = (LDAPServer *)NSLDAPI_CALLOC(1, sizeof(LDAPServer))) == NULL ||</span>
<a href="#l59.497"></a><span id="l59.497" class="difflineplus">+  if ((srv = (LDAPServer*)NSLDAPI_CALLOC(1, sizeof(LDAPServer))) == NULL ||</span>
<a href="#l59.498"></a><span id="l59.498">       (ld-&gt;ld_defhost != NULL &amp;&amp;</span>
<a href="#l59.499"></a><span id="l59.499">        (srv-&gt;lsrv_host = nsldapi_strdup(ld-&gt;ld_defhost)) == NULL)) {</span>
<a href="#l59.500"></a><span id="l59.500">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l59.501"></a><span id="l59.501">     return (-1);</span>
<a href="#l59.502"></a><span id="l59.502">   }</span>
<a href="#l59.503"></a><span id="l59.503">   srv-&gt;lsrv_port = ld-&gt;ld_defport;</span>
<a href="#l59.504"></a><span id="l59.504"> </span>
<a href="#l59.505"></a><span id="l59.505">   if ((ld-&gt;ld_options &amp; LDAP_BITOPT_SSL) != 0) {</span>
<a href="#l59.506"></a><span id="l59.506">     srv-&gt;lsrv_options |= LDAP_SRV_OPT_SECURE;</span>
<a href="#l59.507"></a><span id="l59.507">   }</span>
<a href="#l59.508"></a><span id="l59.508"> </span>
<a href="#l59.509"></a><span id="l59.509">   if ((ld-&gt;ld_defconn = nsldapi_new_connection(ld, &amp;srv, 1, 1, 0)) == NULL) {</span>
<a href="#l59.510"></a><span id="l59.510">     if (ld-&gt;ld_defhost != NULL) {</span>
<a href="#l59.511"></a><span id="l59.511">       NSLDAPI_FREE(srv-&gt;lsrv_host);</span>
<a href="#l59.512"></a><span id="l59.512">     }</span>
<a href="#l59.513"></a><span id="l59.513" class="difflineminus">-    NSLDAPI_FREE((char *)srv);</span>
<a href="#l59.514"></a><span id="l59.514" class="difflineplus">+    NSLDAPI_FREE((char*)srv);</span>
<a href="#l59.515"></a><span id="l59.515">     return (-1);</span>
<a href="#l59.516"></a><span id="l59.516">   }</span>
<a href="#l59.517"></a><span id="l59.517">   ++ld-&gt;ld_defconn-&gt;lconn_refcnt; /* so it never gets closed/freed */</span>
<a href="#l59.518"></a><span id="l59.518"> </span>
<a href="#l59.519"></a><span id="l59.519">   return (0);</span>
<a href="#l59.520"></a><span id="l59.520"> }</span>
<a href="#l59.521"></a><span id="l59.521"> </span>
<a href="#l59.522"></a><span id="l59.522"> struct ldap_x_hostlist_status {</span>
<a href="#l59.523"></a><span id="l59.523" class="difflineminus">-  char *lhs_hostlist;</span>
<a href="#l59.524"></a><span id="l59.524" class="difflineminus">-  char *lhs_nexthost;</span>
<a href="#l59.525"></a><span id="l59.525" class="difflineplus">+  char* lhs_hostlist;</span>
<a href="#l59.526"></a><span id="l59.526" class="difflineplus">+  char* lhs_nexthost;</span>
<a href="#l59.527"></a><span id="l59.527">   int lhs_defport;</span>
<a href="#l59.528"></a><span id="l59.528"> };</span>
<a href="#l59.529"></a><span id="l59.529"> </span>
<a href="#l59.530"></a><span id="l59.530"> /*</span>
<a href="#l59.531"></a><span id="l59.531">  * Return the first host and port in hostlist (setting *hostp and *portp).</span>
<a href="#l59.532"></a><span id="l59.532">  * Return value is an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l59.533"></a><span id="l59.533">  * Note that a NULL or zero-length hostlist causes the host &quot;127.0.0.1&quot; to</span>
<a href="#l59.534"></a><span id="l59.534">  * be returned.</span>
<a href="#l59.535"></a><span id="l59.535">  */</span>
<a href="#l59.536"></a><span id="l59.536" class="difflineminus">-int LDAP_CALL ldap_x_hostlist_first(const char *hostlist, int defport,</span>
<a href="#l59.537"></a><span id="l59.537" class="difflineminus">-                                    char **hostp, int *portp,</span>
<a href="#l59.538"></a><span id="l59.538" class="difflineminus">-                                    struct ldap_x_hostlist_status **statusp) {</span>
<a href="#l59.539"></a><span id="l59.539" class="difflineplus">+int LDAP_CALL ldap_x_hostlist_first(const char* hostlist, int defport,</span>
<a href="#l59.540"></a><span id="l59.540" class="difflineplus">+                                    char** hostp, int* portp,</span>
<a href="#l59.541"></a><span id="l59.541" class="difflineplus">+                                    struct ldap_x_hostlist_status** statusp) {</span>
<a href="#l59.542"></a><span id="l59.542">   if (NULL == hostp || NULL == portp || NULL == statusp) {</span>
<a href="#l59.543"></a><span id="l59.543">     return (LDAP_PARAM_ERROR);</span>
<a href="#l59.544"></a><span id="l59.544">   }</span>
<a href="#l59.545"></a><span id="l59.545"> </span>
<a href="#l59.546"></a><span id="l59.546">   if (NULL == hostlist || *hostlist == '\0') {</span>
<a href="#l59.547"></a><span id="l59.547">     *hostp = nsldapi_strdup(&quot;127.0.0.1&quot;);</span>
<a href="#l59.548"></a><span id="l59.548">     if (NULL == *hostp) {</span>
<a href="#l59.549"></a><span id="l59.549">       return (LDAP_NO_MEMORY);</span>
<a href="#l59.550"></a><span id="l59.550" class="difflineat">@@ -686,19 +686,19 @@ int LDAP_CALL ldap_x_hostlist_first(cons</span>
<a href="#l59.551"></a><span id="l59.551"> }</span>
<a href="#l59.552"></a><span id="l59.552"> </span>
<a href="#l59.553"></a><span id="l59.553"> /*</span>
<a href="#l59.554"></a><span id="l59.554">  * Return the next host and port in hostlist (setting *hostp and *portp).</span>
<a href="#l59.555"></a><span id="l59.555">  * Return value is an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l59.556"></a><span id="l59.556">  * If no more hosts are available, LDAP_SUCCESS is returned but *hostp is set</span>
<a href="#l59.557"></a><span id="l59.557">  * to NULL.</span>
<a href="#l59.558"></a><span id="l59.558">  */</span>
<a href="#l59.559"></a><span id="l59.559" class="difflineminus">-int LDAP_CALL ldap_x_hostlist_next(char **hostp, int *portp,</span>
<a href="#l59.560"></a><span id="l59.560" class="difflineminus">-                                   struct ldap_x_hostlist_status *status) {</span>
<a href="#l59.561"></a><span id="l59.561" class="difflineminus">-  char *q;</span>
<a href="#l59.562"></a><span id="l59.562" class="difflineplus">+int LDAP_CALL ldap_x_hostlist_next(char** hostp, int* portp,</span>
<a href="#l59.563"></a><span id="l59.563" class="difflineplus">+                                   struct ldap_x_hostlist_status* status) {</span>
<a href="#l59.564"></a><span id="l59.564" class="difflineplus">+  char* q;</span>
<a href="#l59.565"></a><span id="l59.565">   int squarebrackets = 0;</span>
<a href="#l59.566"></a><span id="l59.566"> </span>
<a href="#l59.567"></a><span id="l59.567">   if (NULL == hostp || NULL == portp) {</span>
<a href="#l59.568"></a><span id="l59.568">     return (LDAP_PARAM_ERROR);</span>
<a href="#l59.569"></a><span id="l59.569">   }</span>
<a href="#l59.570"></a><span id="l59.570"> </span>
<a href="#l59.571"></a><span id="l59.571">   if (NULL == status || NULL == status-&gt;lhs_nexthost) {</span>
<a href="#l59.572"></a><span id="l59.572">     *hostp = NULL;</span>
<a href="#l59.573"></a><span id="l59.573" class="difflineat">@@ -748,59 +748,59 @@ int LDAP_CALL ldap_x_hostlist_next(char </span>
<a href="#l59.574"></a><span id="l59.574">   } else {</span>
<a href="#l59.575"></a><span id="l59.575">     *portp = status-&gt;lhs_defport;</span>
<a href="#l59.576"></a><span id="l59.576">   }</span>
<a href="#l59.577"></a><span id="l59.577"> </span>
<a href="#l59.578"></a><span id="l59.578">   return (LDAP_SUCCESS);</span>
<a href="#l59.579"></a><span id="l59.579"> }</span>
<a href="#l59.580"></a><span id="l59.580"> </span>
<a href="#l59.581"></a><span id="l59.581"> void LDAP_CALL</span>
<a href="#l59.582"></a><span id="l59.582" class="difflineminus">-ldap_x_hostlist_statusfree(struct ldap_x_hostlist_status *status) {</span>
<a href="#l59.583"></a><span id="l59.583" class="difflineplus">+ldap_x_hostlist_statusfree(struct ldap_x_hostlist_status* status) {</span>
<a href="#l59.584"></a><span id="l59.584">   if (NULL != status) {</span>
<a href="#l59.585"></a><span id="l59.585">     if (NULL != status-&gt;lhs_hostlist) {</span>
<a href="#l59.586"></a><span id="l59.586">       NSLDAPI_FREE(status-&gt;lhs_hostlist);</span>
<a href="#l59.587"></a><span id="l59.587">     }</span>
<a href="#l59.588"></a><span id="l59.588">     NSLDAPI_FREE(status);</span>
<a href="#l59.589"></a><span id="l59.589">   }</span>
<a href="#l59.590"></a><span id="l59.590"> }</span>
<a href="#l59.591"></a><span id="l59.591"> </span>
<a href="#l59.592"></a><span id="l59.592"> /*</span>
<a href="#l59.593"></a><span id="l59.593">  * memory allocation functions.  we include these in open.c since every</span>
<a href="#l59.594"></a><span id="l59.594">  *    LDAP application is likely to pull the rest of the code in this file</span>
<a href="#l59.595"></a><span id="l59.595">  *    in anyways.</span>
<a href="#l59.596"></a><span id="l59.596">  */</span>
<a href="#l59.597"></a><span id="l59.597" class="difflineminus">-void *ldap_x_malloc(size_t size) {</span>
<a href="#l59.598"></a><span id="l59.598" class="difflineplus">+void* ldap_x_malloc(size_t size) {</span>
<a href="#l59.599"></a><span id="l59.599">   return (nsldapi_memalloc_fns.ldapmem_malloc == NULL</span>
<a href="#l59.600"></a><span id="l59.600">               ? malloc(size)</span>
<a href="#l59.601"></a><span id="l59.601">               : nsldapi_memalloc_fns.ldapmem_malloc(size));</span>
<a href="#l59.602"></a><span id="l59.602"> }</span>
<a href="#l59.603"></a><span id="l59.603"> </span>
<a href="#l59.604"></a><span id="l59.604" class="difflineminus">-void *ldap_x_calloc(size_t nelem, size_t elsize) {</span>
<a href="#l59.605"></a><span id="l59.605" class="difflineplus">+void* ldap_x_calloc(size_t nelem, size_t elsize) {</span>
<a href="#l59.606"></a><span id="l59.606">   return (nsldapi_memalloc_fns.ldapmem_calloc == NULL</span>
<a href="#l59.607"></a><span id="l59.607">               ? calloc(nelem, elsize)</span>
<a href="#l59.608"></a><span id="l59.608">               : nsldapi_memalloc_fns.ldapmem_calloc(nelem, elsize));</span>
<a href="#l59.609"></a><span id="l59.609"> }</span>
<a href="#l59.610"></a><span id="l59.610"> </span>
<a href="#l59.611"></a><span id="l59.611" class="difflineminus">-void *ldap_x_realloc(void *ptr, size_t size) {</span>
<a href="#l59.612"></a><span id="l59.612" class="difflineplus">+void* ldap_x_realloc(void* ptr, size_t size) {</span>
<a href="#l59.613"></a><span id="l59.613">   return (nsldapi_memalloc_fns.ldapmem_realloc == NULL</span>
<a href="#l59.614"></a><span id="l59.614">               ? realloc(ptr, size)</span>
<a href="#l59.615"></a><span id="l59.615">               : nsldapi_memalloc_fns.ldapmem_realloc(ptr, size));</span>
<a href="#l59.616"></a><span id="l59.616"> }</span>
<a href="#l59.617"></a><span id="l59.617"> </span>
<a href="#l59.618"></a><span id="l59.618" class="difflineminus">-void ldap_x_free(void *ptr) {</span>
<a href="#l59.619"></a><span id="l59.619" class="difflineplus">+void ldap_x_free(void* ptr) {</span>
<a href="#l59.620"></a><span id="l59.620">   if (nsldapi_memalloc_fns.ldapmem_free == NULL) {</span>
<a href="#l59.621"></a><span id="l59.621">     free(ptr);</span>
<a href="#l59.622"></a><span id="l59.622">   } else {</span>
<a href="#l59.623"></a><span id="l59.623">     nsldapi_memalloc_fns.ldapmem_free(ptr);</span>
<a href="#l59.624"></a><span id="l59.624">   }</span>
<a href="#l59.625"></a><span id="l59.625"> }</span>
<a href="#l59.626"></a><span id="l59.626"> </span>
<a href="#l59.627"></a><span id="l59.627"> /* if s is NULL, returns NULL */</span>
<a href="#l59.628"></a><span id="l59.628" class="difflineminus">-char *nsldapi_strdup(const char *s) {</span>
<a href="#l59.629"></a><span id="l59.629" class="difflineminus">-  char *p;</span>
<a href="#l59.630"></a><span id="l59.630" class="difflineplus">+char* nsldapi_strdup(const char* s) {</span>
<a href="#l59.631"></a><span id="l59.631" class="difflineplus">+  char* p;</span>
<a href="#l59.632"></a><span id="l59.632"> </span>
<a href="#l59.633"></a><span id="l59.633" class="difflineminus">-  if (s == NULL || (p = (char *)NSLDAPI_MALLOC(strlen(s) + 1)) == NULL)</span>
<a href="#l59.634"></a><span id="l59.634" class="difflineplus">+  if (s == NULL || (p = (char*)NSLDAPI_MALLOC(strlen(s) + 1)) == NULL)</span>
<a href="#l59.635"></a><span id="l59.635">     return (NULL);</span>
<a href="#l59.636"></a><span id="l59.636"> </span>
<a href="#l59.637"></a><span id="l59.637">   strcpy(p, s);</span>
<a href="#l59.638"></a><span id="l59.638"> </span>
<a href="#l59.639"></a><span id="l59.639">   return (p);</span>
<a href="#l59.640"></a><span id="l59.640"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l60.1"></a><span id="l60.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/os-ip.c</span>
<a href="#l60.2"></a><span id="l60.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/os-ip.c</span>
<a href="#l60.3"></a><span id="l60.3" class="difflineat">@@ -81,30 +81,30 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l60.4"></a><span id="l60.4"> </span>
<a href="#l60.5"></a><span id="l60.5"> #define NSLDAPI_POLL_ARRAY_GROWTH 5 /* grow arrays 5 elements at a time */</span>
<a href="#l60.6"></a><span id="l60.6"> </span>
<a href="#l60.7"></a><span id="l60.7"> /*</span>
<a href="#l60.8"></a><span id="l60.8">  * Structures and union for tracking status of network sockets</span>
<a href="#l60.9"></a><span id="l60.9">  */</span>
<a href="#l60.10"></a><span id="l60.10"> #ifdef NSLDAPI_HAVE_POLL</span>
<a href="#l60.11"></a><span id="l60.11"> struct nsldapi_os_statusinfo { /* used with native OS poll() */</span>
<a href="#l60.12"></a><span id="l60.12" class="difflineminus">-  struct pollfd *ossi_pollfds;</span>
<a href="#l60.13"></a><span id="l60.13" class="difflineplus">+  struct pollfd* ossi_pollfds;</span>
<a href="#l60.14"></a><span id="l60.14">   int ossi_pollfds_size;</span>
<a href="#l60.15"></a><span id="l60.15"> };</span>
<a href="#l60.16"></a><span id="l60.16"> #else  /* NSLDAPI_HAVE_POLL */</span>
<a href="#l60.17"></a><span id="l60.17"> struct nsldapi_os_statusinfo { /* used with native OS select() */</span>
<a href="#l60.18"></a><span id="l60.18">   fd_set ossi_readfds;</span>
<a href="#l60.19"></a><span id="l60.19">   fd_set ossi_writefds;</span>
<a href="#l60.20"></a><span id="l60.20">   fd_set ossi_use_readfds;</span>
<a href="#l60.21"></a><span id="l60.21">   fd_set ossi_use_writefds;</span>
<a href="#l60.22"></a><span id="l60.22"> };</span>
<a href="#l60.23"></a><span id="l60.23"> #endif /* else NSLDAPI_HAVE_POLL */</span>
<a href="#l60.24"></a><span id="l60.24"> </span>
<a href="#l60.25"></a><span id="l60.25"> struct nsldapi_cb_statusinfo { /* used with ext. I/O poll() callback */</span>
<a href="#l60.26"></a><span id="l60.26" class="difflineminus">-  LDAP_X_PollFD *cbsi_pollfds;</span>
<a href="#l60.27"></a><span id="l60.27" class="difflineplus">+  LDAP_X_PollFD* cbsi_pollfds;</span>
<a href="#l60.28"></a><span id="l60.28">   int cbsi_pollfds_size;</span>
<a href="#l60.29"></a><span id="l60.29"> };</span>
<a href="#l60.30"></a><span id="l60.30"> </span>
<a href="#l60.31"></a><span id="l60.31"> /*</span>
<a href="#l60.32"></a><span id="l60.32">  * NSLDAPI_CB_POLL_MATCH() evaluates to non-zero (true) if the Sockbuf *sdp</span>
<a href="#l60.33"></a><span id="l60.33">  * matches the LDAP_X_PollFD pollfd.</span>
<a href="#l60.34"></a><span id="l60.34">  */</span>
<a href="#l60.35"></a><span id="l60.35"> #ifdef _WINDOWS</span>
<a href="#l60.36"></a><span id="l60.36" class="difflineat">@@ -125,108 +125,108 @@ struct nsldapi_iostatus_info {</span>
<a href="#l60.37"></a><span id="l60.37">   union {</span>
<a href="#l60.38"></a><span id="l60.38">     struct nsldapi_os_statusinfo ios_osinfo;</span>
<a href="#l60.39"></a><span id="l60.39">     struct nsldapi_cb_statusinfo ios_cbinfo;</span>
<a href="#l60.40"></a><span id="l60.40">   } ios_status;</span>
<a href="#l60.41"></a><span id="l60.41"> };</span>
<a href="#l60.42"></a><span id="l60.42"> </span>
<a href="#l60.43"></a><span id="l60.43"> #ifndef NSLDAPI_AVOID_OS_SOCKETS</span>
<a href="#l60.44"></a><span id="l60.44"> #  ifdef NSLDAPI_HAVE_POLL</span>
<a href="#l60.45"></a><span id="l60.45" class="difflineminus">-static int nsldapi_add_to_os_pollfds(int fd, struct nsldapi_os_statusinfo *pip,</span>
<a href="#l60.46"></a><span id="l60.46" class="difflineplus">+static int nsldapi_add_to_os_pollfds(int fd, struct nsldapi_os_statusinfo* pip,</span>
<a href="#l60.47"></a><span id="l60.47">                                      short events);</span>
<a href="#l60.48"></a><span id="l60.48"> static int nsldapi_clear_from_os_pollfds(int fd,</span>
<a href="#l60.49"></a><span id="l60.49" class="difflineminus">-                                         struct nsldapi_os_statusinfo *pip,</span>
<a href="#l60.50"></a><span id="l60.50" class="difflineplus">+                                         struct nsldapi_os_statusinfo* pip,</span>
<a href="#l60.51"></a><span id="l60.51">                                          short events);</span>
<a href="#l60.52"></a><span id="l60.52" class="difflineminus">-static int nsldapi_find_in_os_pollfds(int fd, struct nsldapi_os_statusinfo *pip,</span>
<a href="#l60.53"></a><span id="l60.53" class="difflineplus">+static int nsldapi_find_in_os_pollfds(int fd, struct nsldapi_os_statusinfo* pip,</span>
<a href="#l60.54"></a><span id="l60.54">                                       short revents);</span>
<a href="#l60.55"></a><span id="l60.55"> #  endif /* NSLDAPI_HAVE_POLL */</span>
<a href="#l60.56"></a><span id="l60.56"> #endif   /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.57"></a><span id="l60.57"> </span>
<a href="#l60.58"></a><span id="l60.58" class="difflineminus">-static int nsldapi_iostatus_init_nolock(LDAP *ld);</span>
<a href="#l60.59"></a><span id="l60.59" class="difflineminus">-static int nsldapi_add_to_cb_pollfds(Sockbuf *sb,</span>
<a href="#l60.60"></a><span id="l60.60" class="difflineminus">-                                     struct nsldapi_cb_statusinfo *pip,</span>
<a href="#l60.61"></a><span id="l60.61" class="difflineplus">+static int nsldapi_iostatus_init_nolock(LDAP* ld);</span>
<a href="#l60.62"></a><span id="l60.62" class="difflineplus">+static int nsldapi_add_to_cb_pollfds(Sockbuf* sb,</span>
<a href="#l60.63"></a><span id="l60.63" class="difflineplus">+                                     struct nsldapi_cb_statusinfo* pip,</span>
<a href="#l60.64"></a><span id="l60.64">                                      short events);</span>
<a href="#l60.65"></a><span id="l60.65" class="difflineminus">-static int nsldapi_clear_from_cb_pollfds(Sockbuf *sb,</span>
<a href="#l60.66"></a><span id="l60.66" class="difflineminus">-                                         struct nsldapi_cb_statusinfo *pip,</span>
<a href="#l60.67"></a><span id="l60.67" class="difflineplus">+static int nsldapi_clear_from_cb_pollfds(Sockbuf* sb,</span>
<a href="#l60.68"></a><span id="l60.68" class="difflineplus">+                                         struct nsldapi_cb_statusinfo* pip,</span>
<a href="#l60.69"></a><span id="l60.69">                                          short events);</span>
<a href="#l60.70"></a><span id="l60.70" class="difflineminus">-static int nsldapi_find_in_cb_pollfds(Sockbuf *sb,</span>
<a href="#l60.71"></a><span id="l60.71" class="difflineminus">-                                      struct nsldapi_cb_statusinfo *pip,</span>
<a href="#l60.72"></a><span id="l60.72" class="difflineplus">+static int nsldapi_find_in_cb_pollfds(Sockbuf* sb,</span>
<a href="#l60.73"></a><span id="l60.73" class="difflineplus">+                                      struct nsldapi_cb_statusinfo* pip,</span>
<a href="#l60.74"></a><span id="l60.74">                                       short revents);</span>
<a href="#l60.75"></a><span id="l60.75"> </span>
<a href="#l60.76"></a><span id="l60.76"> #ifdef irix</span>
<a href="#l60.77"></a><span id="l60.77"> #  ifndef _PR_THREADS</span>
<a href="#l60.78"></a><span id="l60.78"> /*</span>
<a href="#l60.79"></a><span id="l60.79">  * XXXmcs: on IRIX NSPR's poll() and select() wrappers will crash if NSPR</span>
<a href="#l60.80"></a><span id="l60.80">  * has not been initialized.  We work around the problem by bypassing</span>
<a href="#l60.81"></a><span id="l60.81">  * the NSPR wrapper functions and going directly to the OS' functions.</span>
<a href="#l60.82"></a><span id="l60.82">  */</span>
<a href="#l60.83"></a><span id="l60.83"> #    define NSLDAPI_POLL _poll</span>
<a href="#l60.84"></a><span id="l60.84"> #    define NSLDAPI_SELECT _select</span>
<a href="#l60.85"></a><span id="l60.85" class="difflineminus">-extern int _poll(struct pollfd *fds, unsigned long nfds, int timeout);</span>
<a href="#l60.86"></a><span id="l60.86" class="difflineminus">-extern int _select(int nfds, fd_set *readfds, fd_set *writefds,</span>
<a href="#l60.87"></a><span id="l60.87" class="difflineminus">-                   fd_set *exceptfds, struct timeval *timeout);</span>
<a href="#l60.88"></a><span id="l60.88" class="difflineplus">+extern int _poll(struct pollfd* fds, unsigned long nfds, int timeout);</span>
<a href="#l60.89"></a><span id="l60.89" class="difflineplus">+extern int _select(int nfds, fd_set* readfds, fd_set* writefds,</span>
<a href="#l60.90"></a><span id="l60.90" class="difflineplus">+                   fd_set* exceptfds, struct timeval* timeout);</span>
<a href="#l60.91"></a><span id="l60.91"> #  else /* _PR_THREADS */</span>
<a href="#l60.92"></a><span id="l60.92"> #    define NSLDAPI_POLL poll</span>
<a href="#l60.93"></a><span id="l60.93"> #    define NSLDAPI_SELECT select</span>
<a href="#l60.94"></a><span id="l60.94"> #  endif /* else _PR_THREADS */</span>
<a href="#l60.95"></a><span id="l60.95"> #else    /* irix */</span>
<a href="#l60.96"></a><span id="l60.96"> #  define NSLDAPI_POLL poll</span>
<a href="#l60.97"></a><span id="l60.97"> #  define NSLDAPI_SELECT select</span>
<a href="#l60.98"></a><span id="l60.98"> #endif /* else irix */</span>
<a href="#l60.99"></a><span id="l60.99"> </span>
<a href="#l60.100"></a><span id="l60.100" class="difflineminus">-static LBER_SOCKET nsldapi_os_socket(LDAP *ld, int secure, int domain, int type,</span>
<a href="#l60.101"></a><span id="l60.101" class="difflineplus">+static LBER_SOCKET nsldapi_os_socket(LDAP* ld, int secure, int domain, int type,</span>
<a href="#l60.102"></a><span id="l60.102">                                      int protocol);</span>
<a href="#l60.103"></a><span id="l60.103" class="difflineminus">-static int nsldapi_os_ioctl(LBER_SOCKET s, int option, int *statusp);</span>
<a href="#l60.104"></a><span id="l60.104" class="difflineminus">-static int nsldapi_os_connect_with_to(LBER_SOCKET s, struct sockaddr *name,</span>
<a href="#l60.105"></a><span id="l60.105" class="difflineplus">+static int nsldapi_os_ioctl(LBER_SOCKET s, int option, int* statusp);</span>
<a href="#l60.106"></a><span id="l60.106" class="difflineplus">+static int nsldapi_os_connect_with_to(LBER_SOCKET s, struct sockaddr* name,</span>
<a href="#l60.107"></a><span id="l60.107">                                       int namelen, int msec_timeout);</span>
<a href="#l60.108"></a><span id="l60.108"> #if defined(KERBEROS)</span>
<a href="#l60.109"></a><span id="l60.109" class="difflineminus">-char *nsldapi_host_connected_to(LDAP *ld, Sockbuf *sb);</span>
<a href="#l60.110"></a><span id="l60.110" class="difflineplus">+char* nsldapi_host_connected_to(LDAP* ld, Sockbuf* sb);</span>
<a href="#l60.111"></a><span id="l60.111"> #endif</span>
<a href="#l60.112"></a><span id="l60.112"> </span>
<a href="#l60.113"></a><span id="l60.113"> /*</span>
<a href="#l60.114"></a><span id="l60.114">  * Function typedefs used by nsldapi_try_each_host()</span>
<a href="#l60.115"></a><span id="l60.115">  */</span>
<a href="#l60.116"></a><span id="l60.116" class="difflineminus">-typedef LBER_SOCKET(NSLDAPI_SOCKET_FN)(LDAP *ld, int secure, int domain,</span>
<a href="#l60.117"></a><span id="l60.117" class="difflineplus">+typedef LBER_SOCKET(NSLDAPI_SOCKET_FN)(LDAP* ld, int secure, int domain,</span>
<a href="#l60.118"></a><span id="l60.118">                                        int type, int protocol);</span>
<a href="#l60.119"></a><span id="l60.119" class="difflineminus">-typedef int(NSLDAPI_IOCTL_FN)(LBER_SOCKET s, int option, int *statusp);</span>
<a href="#l60.120"></a><span id="l60.120" class="difflineminus">-typedef int(NSLDAPI_CONNECT_WITH_TO_FN)(LBER_SOCKET s, struct sockaddr *name,</span>
<a href="#l60.121"></a><span id="l60.121" class="difflineplus">+typedef int(NSLDAPI_IOCTL_FN)(LBER_SOCKET s, int option, int* statusp);</span>
<a href="#l60.122"></a><span id="l60.122" class="difflineplus">+typedef int(NSLDAPI_CONNECT_WITH_TO_FN)(LBER_SOCKET s, struct sockaddr* name,</span>
<a href="#l60.123"></a><span id="l60.123">                                         int namelen, int msec_timeout);</span>
<a href="#l60.124"></a><span id="l60.124" class="difflineminus">-typedef int(NSLDAPI_CONNECT_FN)(LBER_SOCKET s, struct sockaddr *name,</span>
<a href="#l60.125"></a><span id="l60.125" class="difflineplus">+typedef int(NSLDAPI_CONNECT_FN)(LBER_SOCKET s, struct sockaddr* name,</span>
<a href="#l60.126"></a><span id="l60.126">                                 int namelen);</span>
<a href="#l60.127"></a><span id="l60.127"> typedef int(NSLDAPI_CLOSE_FN)(LBER_SOCKET s);</span>
<a href="#l60.128"></a><span id="l60.128"> </span>
<a href="#l60.129"></a><span id="l60.129" class="difflineminus">-static int nsldapi_try_each_host(LDAP *ld, const char *hostlist, int defport,</span>
<a href="#l60.130"></a><span id="l60.130" class="difflineminus">-                                 int secure, NSLDAPI_SOCKET_FN *socketfn,</span>
<a href="#l60.131"></a><span id="l60.131" class="difflineminus">-                                 NSLDAPI_IOCTL_FN *ioctlfn,</span>
<a href="#l60.132"></a><span id="l60.132" class="difflineminus">-                                 NSLDAPI_CONNECT_WITH_TO_FN *connectwithtofn,</span>
<a href="#l60.133"></a><span id="l60.133" class="difflineminus">-                                 NSLDAPI_CONNECT_FN *connectfn,</span>
<a href="#l60.134"></a><span id="l60.134" class="difflineminus">-                                 NSLDAPI_CLOSE_FN *closefn);</span>
<a href="#l60.135"></a><span id="l60.135" class="difflineplus">+static int nsldapi_try_each_host(LDAP* ld, const char* hostlist, int defport,</span>
<a href="#l60.136"></a><span id="l60.136" class="difflineplus">+                                 int secure, NSLDAPI_SOCKET_FN* socketfn,</span>
<a href="#l60.137"></a><span id="l60.137" class="difflineplus">+                                 NSLDAPI_IOCTL_FN* ioctlfn,</span>
<a href="#l60.138"></a><span id="l60.138" class="difflineplus">+                                 NSLDAPI_CONNECT_WITH_TO_FN* connectwithtofn,</span>
<a href="#l60.139"></a><span id="l60.139" class="difflineplus">+                                 NSLDAPI_CONNECT_FN* connectfn,</span>
<a href="#l60.140"></a><span id="l60.140" class="difflineplus">+                                 NSLDAPI_CLOSE_FN* closefn);</span>
<a href="#l60.141"></a><span id="l60.141"> </span>
<a href="#l60.142"></a><span id="l60.142"> static int nsldapi_os_closesocket(LBER_SOCKET s) {</span>
<a href="#l60.143"></a><span id="l60.143">   int rc;</span>
<a href="#l60.144"></a><span id="l60.144"> </span>
<a href="#l60.145"></a><span id="l60.145"> #ifdef NSLDAPI_AVOID_OS_SOCKETS</span>
<a href="#l60.146"></a><span id="l60.146">   rc = -1;</span>
<a href="#l60.147"></a><span id="l60.147"> #else /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.148"></a><span id="l60.148"> #  ifdef _WINDOWS</span>
<a href="#l60.149"></a><span id="l60.149">   rc = closesocket(s);</span>
<a href="#l60.150"></a><span id="l60.150"> #  else  /* _WINDOWS */</span>
<a href="#l60.151"></a><span id="l60.151">   rc = close(s);</span>
<a href="#l60.152"></a><span id="l60.152"> #  endif /* _WINDOWS */</span>
<a href="#l60.153"></a><span id="l60.153"> #endif   /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.154"></a><span id="l60.154">   return (rc);</span>
<a href="#l60.155"></a><span id="l60.155"> }</span>
<a href="#l60.156"></a><span id="l60.156"> </span>
<a href="#l60.157"></a><span id="l60.157" class="difflineminus">-static LBER_SOCKET nsldapi_os_socket(LDAP *ld, int secure, int domain, int type,</span>
<a href="#l60.158"></a><span id="l60.158" class="difflineplus">+static LBER_SOCKET nsldapi_os_socket(LDAP* ld, int secure, int domain, int type,</span>
<a href="#l60.159"></a><span id="l60.159">                                      int protocol) {</span>
<a href="#l60.160"></a><span id="l60.160"> #ifdef NSLDAPI_AVOID_OS_SOCKETS</span>
<a href="#l60.161"></a><span id="l60.161">   return -1;</span>
<a href="#l60.162"></a><span id="l60.162"> #else /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.163"></a><span id="l60.163">   int s, invalid_socket;</span>
<a href="#l60.164"></a><span id="l60.164" class="difflineminus">-  char *errmsg = NULL;</span>
<a href="#l60.165"></a><span id="l60.165" class="difflineplus">+  char* errmsg = NULL;</span>
<a href="#l60.166"></a><span id="l60.166"> </span>
<a href="#l60.167"></a><span id="l60.167">   if (secure) {</span>
<a href="#l60.168"></a><span id="l60.168">     LDAP_SET_LDERRNO(ld, LDAP_LOCAL_ERROR, NULL,</span>
<a href="#l60.169"></a><span id="l60.169">                      nsldapi_strdup(&quot;secure mode not supported&quot;));</span>
<a href="#l60.170"></a><span id="l60.170">     return (-1);</span>
<a href="#l60.171"></a><span id="l60.171">   }</span>
<a href="#l60.172"></a><span id="l60.172"> </span>
<a href="#l60.173"></a><span id="l60.173">   s = socket(domain, type, protocol);</span>
<a href="#l60.174"></a><span id="l60.174" class="difflineat">@@ -260,17 +260,17 @@ static LBER_SOCKET nsldapi_os_socket(LDA</span>
<a href="#l60.175"></a><span id="l60.175">   return (s);</span>
<a href="#l60.176"></a><span id="l60.176"> #endif /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.177"></a><span id="l60.177"> }</span>
<a href="#l60.178"></a><span id="l60.178"> </span>
<a href="#l60.179"></a><span id="l60.179"> /*</span>
<a href="#l60.180"></a><span id="l60.180">  * Non-blocking connect call function</span>
<a href="#l60.181"></a><span id="l60.181">  */</span>
<a href="#l60.182"></a><span id="l60.182"> static int nsldapi_os_connect_with_to(LBER_SOCKET sockfd,</span>
<a href="#l60.183"></a><span id="l60.183" class="difflineminus">-                                      struct sockaddr *saptr, int salen,</span>
<a href="#l60.184"></a><span id="l60.184" class="difflineplus">+                                      struct sockaddr* saptr, int salen,</span>
<a href="#l60.185"></a><span id="l60.185">                                       int msec) {</span>
<a href="#l60.186"></a><span id="l60.186"> #ifdef NSLDAPI_AVOID_OS_SOCKETS</span>
<a href="#l60.187"></a><span id="l60.187">   return -1;</span>
<a href="#l60.188"></a><span id="l60.188"> #else /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.189"></a><span id="l60.189">   int n, error;</span>
<a href="#l60.190"></a><span id="l60.190">   int len;</span>
<a href="#l60.191"></a><span id="l60.191"> #  if defined(_WINDOWS) || defined(XP_OS2)</span>
<a href="#l60.192"></a><span id="l60.192">   int nonblock = 1;</span>
<a href="#l60.193"></a><span id="l60.193" class="difflineat">@@ -353,17 +353,17 @@ static int nsldapi_os_connect_with_to(LB</span>
<a href="#l60.194"></a><span id="l60.194"> #  ifdef NSLDAPI_HAVE_POLL</span>
<a href="#l60.195"></a><span id="l60.195">   if ((n = poll(&amp;pfd, 1, (msec != LDAP_X_IO_TIMEOUT_NO_TIMEOUT) ? msec : -1)) ==</span>
<a href="#l60.196"></a><span id="l60.196">       0) {</span>
<a href="#l60.197"></a><span id="l60.197">     errno = ETIMEDOUT;</span>
<a href="#l60.198"></a><span id="l60.198">     return (-1);</span>
<a href="#l60.199"></a><span id="l60.199">   }</span>
<a href="#l60.200"></a><span id="l60.200">   if (pfd.revents &amp; (POLLOUT | POLLERR | POLLHUP | POLLNVAL)) {</span>
<a href="#l60.201"></a><span id="l60.201">     len = sizeof(error);</span>
<a href="#l60.202"></a><span id="l60.202" class="difflineminus">-    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (char *)&amp;error, &amp;len) &lt; 0)</span>
<a href="#l60.203"></a><span id="l60.203" class="difflineplus">+    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (char*)&amp;error, &amp;len) &lt; 0)</span>
<a href="#l60.204"></a><span id="l60.204">       return (-1);</span>
<a href="#l60.205"></a><span id="l60.205"> #    ifdef LDAP_DEBUG</span>
<a href="#l60.206"></a><span id="l60.206">   } else if (ldap_debug &amp; LDAP_DEBUG_TRACE) {</span>
<a href="#l60.207"></a><span id="l60.207">     perror(&quot;poll error: sockfd not set&quot;);</span>
<a href="#l60.208"></a><span id="l60.208"> #    endif</span>
<a href="#l60.209"></a><span id="l60.209">   }</span>
<a href="#l60.210"></a><span id="l60.210"> </span>
<a href="#l60.211"></a><span id="l60.211"> #  else /* NSLDAPI_HAVE_POLL */</span>
<a href="#l60.212"></a><span id="l60.212" class="difflineat">@@ -380,17 +380,17 @@ static int nsldapi_os_connect_with_to(LB</span>
<a href="#l60.213"></a><span id="l60.213">                   (msec != LDAP_X_IO_TIMEOUT_NO_TIMEOUT) ? &amp;tval : NULL)) ==</span>
<a href="#l60.214"></a><span id="l60.214">       0) {</span>
<a href="#l60.215"></a><span id="l60.215">     errno = WSAETIMEDOUT;</span>
<a href="#l60.216"></a><span id="l60.216">     return (-1);</span>
<a href="#l60.217"></a><span id="l60.217">   }</span>
<a href="#l60.218"></a><span id="l60.218">   /* if wset is set, the connect worked */</span>
<a href="#l60.219"></a><span id="l60.219">   if (FD_ISSET(sockfd, &amp;wset) || FD_ISSET(sockfd, &amp;rset)) {</span>
<a href="#l60.220"></a><span id="l60.220">     len = sizeof(error);</span>
<a href="#l60.221"></a><span id="l60.221" class="difflineminus">-    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (char *)&amp;error, &amp;len) &lt; 0)</span>
<a href="#l60.222"></a><span id="l60.222" class="difflineplus">+    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (char*)&amp;error, &amp;len) &lt; 0)</span>
<a href="#l60.223"></a><span id="l60.223">       return (-1);</span>
<a href="#l60.224"></a><span id="l60.224">     goto done;</span>
<a href="#l60.225"></a><span id="l60.225">   }</span>
<a href="#l60.226"></a><span id="l60.226"> </span>
<a href="#l60.227"></a><span id="l60.227">   /* if eset is set, the connect failed */</span>
<a href="#l60.228"></a><span id="l60.228">   if (FD_ISSET(sockfd, &amp;eset)) {</span>
<a href="#l60.229"></a><span id="l60.229">     return (-1);</span>
<a href="#l60.230"></a><span id="l60.230">   }</span>
<a href="#l60.231"></a><span id="l60.231" class="difflineat">@@ -404,17 +404,17 @@ static int nsldapi_os_connect_with_to(LB</span>
<a href="#l60.232"></a><span id="l60.232">   if ((n = select(sockfd + 1, &amp;rset, &amp;wset, NULL,</span>
<a href="#l60.233"></a><span id="l60.233">                   (msec != LDAP_X_IO_TIMEOUT_NO_TIMEOUT) ? &amp;tval : NULL)) ==</span>
<a href="#l60.234"></a><span id="l60.234">       0) {</span>
<a href="#l60.235"></a><span id="l60.235">     errno = ETIMEDOUT;</span>
<a href="#l60.236"></a><span id="l60.236">     return (-1);</span>
<a href="#l60.237"></a><span id="l60.237">   }</span>
<a href="#l60.238"></a><span id="l60.238">   if (FD_ISSET(sockfd, &amp;rset) || FD_ISSET(sockfd, &amp;wset)) {</span>
<a href="#l60.239"></a><span id="l60.239">     len = sizeof(error);</span>
<a href="#l60.240"></a><span id="l60.240" class="difflineminus">-    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (char *)&amp;error, &amp;len) &lt; 0)</span>
<a href="#l60.241"></a><span id="l60.241" class="difflineplus">+    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (char*)&amp;error, &amp;len) &lt; 0)</span>
<a href="#l60.242"></a><span id="l60.242">       return (-1);</span>
<a href="#l60.243"></a><span id="l60.243"> #      ifdef LDAP_DEBUG</span>
<a href="#l60.244"></a><span id="l60.244">   } else if (ldap_debug &amp; LDAP_DEBUG_TRACE) {</span>
<a href="#l60.245"></a><span id="l60.245">     perror(&quot;select error: sockfd not set&quot;);</span>
<a href="#l60.246"></a><span id="l60.246"> #      endif</span>
<a href="#l60.247"></a><span id="l60.247">   }</span>
<a href="#l60.248"></a><span id="l60.248"> #    endif /* _WINDOWS */</span>
<a href="#l60.249"></a><span id="l60.249"> #  endif   /* NSLDAPI_HAVE_POLL */</span>
<a href="#l60.250"></a><span id="l60.250" class="difflineat">@@ -432,46 +432,46 @@ done:</span>
<a href="#l60.251"></a><span id="l60.251">     errno = error;</span>
<a href="#l60.252"></a><span id="l60.252">     return (-1);</span>
<a href="#l60.253"></a><span id="l60.253">   }</span>
<a href="#l60.254"></a><span id="l60.254"> </span>
<a href="#l60.255"></a><span id="l60.255">   return (0);</span>
<a href="#l60.256"></a><span id="l60.256"> #endif   /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.257"></a><span id="l60.257"> }</span>
<a href="#l60.258"></a><span id="l60.258"> </span>
<a href="#l60.259"></a><span id="l60.259" class="difflineminus">-static int nsldapi_os_ioctl(LBER_SOCKET s, int option, int *statusp) {</span>
<a href="#l60.260"></a><span id="l60.260" class="difflineplus">+static int nsldapi_os_ioctl(LBER_SOCKET s, int option, int* statusp) {</span>
<a href="#l60.261"></a><span id="l60.261"> #ifdef NSLDAPI_AVOID_OS_SOCKETS</span>
<a href="#l60.262"></a><span id="l60.262">   return -1;</span>
<a href="#l60.263"></a><span id="l60.263"> #else /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.264"></a><span id="l60.264">   int err;</span>
<a href="#l60.265"></a><span id="l60.265"> #  if defined(_WINDOWS) || defined(XP_OS2)</span>
<a href="#l60.266"></a><span id="l60.266">   u_long iostatus;</span>
<a href="#l60.267"></a><span id="l60.267"> #  endif</span>
<a href="#l60.268"></a><span id="l60.268"> </span>
<a href="#l60.269"></a><span id="l60.269">   if (FIONBIO != option) {</span>
<a href="#l60.270"></a><span id="l60.270">     return (-1);</span>
<a href="#l60.271"></a><span id="l60.271">   }</span>
<a href="#l60.272"></a><span id="l60.272"> </span>
<a href="#l60.273"></a><span id="l60.273"> #  ifdef _WINDOWS</span>
<a href="#l60.274"></a><span id="l60.274" class="difflineminus">-  iostatus = *(u_long *)statusp;</span>
<a href="#l60.275"></a><span id="l60.275" class="difflineplus">+  iostatus = *(u_long*)statusp;</span>
<a href="#l60.276"></a><span id="l60.276">   err = ioctlsocket(s, FIONBIO, &amp;iostatus);</span>
<a href="#l60.277"></a><span id="l60.277"> #  else</span>
<a href="#l60.278"></a><span id="l60.278"> #    ifdef XP_OS2</span>
<a href="#l60.279"></a><span id="l60.279">   err = ioctl(s, FIONBIO, (caddr_t)&amp;iostatus, sizeof(iostatus));</span>
<a href="#l60.280"></a><span id="l60.280"> #    else</span>
<a href="#l60.281"></a><span id="l60.281">   err = ioctl(s, FIONBIO, (caddr_t)statusp);</span>
<a href="#l60.282"></a><span id="l60.282"> #    endif</span>
<a href="#l60.283"></a><span id="l60.283"> #  endif</span>
<a href="#l60.284"></a><span id="l60.284"> </span>
<a href="#l60.285"></a><span id="l60.285">   return (err);</span>
<a href="#l60.286"></a><span id="l60.286"> #endif /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.287"></a><span id="l60.287"> }</span>
<a href="#l60.288"></a><span id="l60.288"> </span>
<a href="#l60.289"></a><span id="l60.289" class="difflineminus">-int nsldapi_connect_to_host(LDAP *ld, Sockbuf *sb, const char *hostlist,</span>
<a href="#l60.290"></a><span id="l60.290" class="difflineminus">-                            int defport, int secure, char **krbinstancep)</span>
<a href="#l60.291"></a><span id="l60.291" class="difflineplus">+int nsldapi_connect_to_host(LDAP* ld, Sockbuf* sb, const char* hostlist,</span>
<a href="#l60.292"></a><span id="l60.292" class="difflineplus">+                            int defport, int secure, char** krbinstancep)</span>
<a href="#l60.293"></a><span id="l60.293"> /*</span>
<a href="#l60.294"></a><span id="l60.294">  * &quot;defport&quot; must be in host byte order</span>
<a href="#l60.295"></a><span id="l60.295">  * zero is returned upon success, -1 if fatal error, -2 EINPROGRESS</span>
<a href="#l60.296"></a><span id="l60.296">  * if -1 is returned, ld_errno is set</span>
<a href="#l60.297"></a><span id="l60.297">  */</span>
<a href="#l60.298"></a><span id="l60.298"> {</span>
<a href="#l60.299"></a><span id="l60.299">   int s;</span>
<a href="#l60.300"></a><span id="l60.300"> </span>
<a href="#l60.301"></a><span id="l60.301" class="difflineat">@@ -510,52 +510,52 @@ int nsldapi_connect_to_host(LDAP *ld, So</span>
<a href="#l60.302"></a><span id="l60.302">   }</span>
<a href="#l60.303"></a><span id="l60.303"> </span>
<a href="#l60.304"></a><span id="l60.304">   sb-&gt;sb_sd = s;</span>
<a href="#l60.305"></a><span id="l60.305"> </span>
<a href="#l60.306"></a><span id="l60.306">   /*</span>
<a href="#l60.307"></a><span id="l60.307">    * Set krbinstancep (canonical name of host for use by Kerberos).</span>
<a href="#l60.308"></a><span id="l60.308">    */</span>
<a href="#l60.309"></a><span id="l60.309"> #ifdef KERBEROS</span>
<a href="#l60.310"></a><span id="l60.310" class="difflineminus">-  char *p;</span>
<a href="#l60.311"></a><span id="l60.311" class="difflineplus">+  char* p;</span>
<a href="#l60.312"></a><span id="l60.312"> </span>
<a href="#l60.313"></a><span id="l60.313">   if ((*krbinstancep = nsldapi_host_connected_to(sb)) != NULL &amp;&amp;</span>
<a href="#l60.314"></a><span id="l60.314">       (p = strchr(*krbinstancep, '.')) != NULL) {</span>
<a href="#l60.315"></a><span id="l60.315">     *p = '\0';</span>
<a href="#l60.316"></a><span id="l60.316">   }</span>
<a href="#l60.317"></a><span id="l60.317"> #else  /* KERBEROS */</span>
<a href="#l60.318"></a><span id="l60.318">   *krbinstancep = NULL;</span>
<a href="#l60.319"></a><span id="l60.319"> #endif /* KERBEROS */</span>
<a href="#l60.320"></a><span id="l60.320"> </span>
<a href="#l60.321"></a><span id="l60.321">   return (0);</span>
<a href="#l60.322"></a><span id="l60.322"> }</span>
<a href="#l60.323"></a><span id="l60.323"> </span>
<a href="#l60.324"></a><span id="l60.324"> /*</span>
<a href="#l60.325"></a><span id="l60.325">  * Returns a socket number if successful and -1 if an error occurs.</span>
<a href="#l60.326"></a><span id="l60.326">  */</span>
<a href="#l60.327"></a><span id="l60.327" class="difflineminus">-static int nsldapi_try_each_host(LDAP *ld, const char *hostlist, int defport,</span>
<a href="#l60.328"></a><span id="l60.328" class="difflineminus">-                                 int secure, NSLDAPI_SOCKET_FN *socketfn,</span>
<a href="#l60.329"></a><span id="l60.329" class="difflineminus">-                                 NSLDAPI_IOCTL_FN *ioctlfn,</span>
<a href="#l60.330"></a><span id="l60.330" class="difflineminus">-                                 NSLDAPI_CONNECT_WITH_TO_FN *connectwithtofn,</span>
<a href="#l60.331"></a><span id="l60.331" class="difflineminus">-                                 NSLDAPI_CONNECT_FN *connectfn,</span>
<a href="#l60.332"></a><span id="l60.332" class="difflineminus">-                                 NSLDAPI_CLOSE_FN *closefn) {</span>
<a href="#l60.333"></a><span id="l60.333" class="difflineplus">+static int nsldapi_try_each_host(LDAP* ld, const char* hostlist, int defport,</span>
<a href="#l60.334"></a><span id="l60.334" class="difflineplus">+                                 int secure, NSLDAPI_SOCKET_FN* socketfn,</span>
<a href="#l60.335"></a><span id="l60.335" class="difflineplus">+                                 NSLDAPI_IOCTL_FN* ioctlfn,</span>
<a href="#l60.336"></a><span id="l60.336" class="difflineplus">+                                 NSLDAPI_CONNECT_WITH_TO_FN* connectwithtofn,</span>
<a href="#l60.337"></a><span id="l60.337" class="difflineplus">+                                 NSLDAPI_CONNECT_FN* connectfn,</span>
<a href="#l60.338"></a><span id="l60.338" class="difflineplus">+                                 NSLDAPI_CLOSE_FN* closefn) {</span>
<a href="#l60.339"></a><span id="l60.339"> #ifdef NSLDAPI_AVOID_OS_SOCKETS</span>
<a href="#l60.340"></a><span id="l60.340">   return -1;</span>
<a href="#l60.341"></a><span id="l60.341"> #else /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.342"></a><span id="l60.342">   int rc = -1;</span>
<a href="#l60.343"></a><span id="l60.343">   int s = 0;</span>
<a href="#l60.344"></a><span id="l60.344">   int i, err, connected, use_hp;</span>
<a href="#l60.345"></a><span id="l60.345">   int parse_err, port;</span>
<a href="#l60.346"></a><span id="l60.346">   struct sockaddr_in sin;</span>
<a href="#l60.347"></a><span id="l60.347">   nsldapi_in_addr_t address;</span>
<a href="#l60.348"></a><span id="l60.348">   char **addrlist, *ldhpbuf, *ldhpbuf_allocd = NULL;</span>
<a href="#l60.349"></a><span id="l60.349" class="difflineminus">-  char *host;</span>
<a href="#l60.350"></a><span id="l60.350" class="difflineplus">+  char* host;</span>
<a href="#l60.351"></a><span id="l60.351">   LDAPHostEnt ldhent, *ldhp;</span>
<a href="#l60.352"></a><span id="l60.352" class="difflineminus">-  struct hostent *hp;</span>
<a href="#l60.353"></a><span id="l60.353" class="difflineminus">-  struct ldap_x_hostlist_status *status;</span>
<a href="#l60.354"></a><span id="l60.354" class="difflineplus">+  struct hostent* hp;</span>
<a href="#l60.355"></a><span id="l60.355" class="difflineplus">+  struct ldap_x_hostlist_status* status;</span>
<a href="#l60.356"></a><span id="l60.356"> #  ifdef GETHOSTBYNAME_BUF_T</span>
<a href="#l60.357"></a><span id="l60.357">   GETHOSTBYNAME_BUF_T hbuf;</span>
<a href="#l60.358"></a><span id="l60.358">   struct hostent hent;</span>
<a href="#l60.359"></a><span id="l60.359"> #  endif /* GETHOSTBYNAME_BUF_T */</span>
<a href="#l60.360"></a><span id="l60.360"> </span>
<a href="#l60.361"></a><span id="l60.361">   connected = 0;</span>
<a href="#l60.362"></a><span id="l60.362">   parse_err = ldap_x_hostlist_first(hostlist, defport, &amp;host, &amp;port, &amp;status);</span>
<a href="#l60.363"></a><span id="l60.363">   while (!connected &amp;&amp; LDAP_SUCCESS == parse_err &amp;&amp; host != NULL) {</span>
<a href="#l60.364"></a><span id="l60.364" class="difflineat">@@ -580,17 +580,17 @@ static int nsldapi_try_each_host(LDAP *l</span>
<a href="#l60.365"></a><span id="l60.365">         /*</span>
<a href="#l60.366"></a><span id="l60.366">          * DNS callback installed... use it.</span>
<a href="#l60.367"></a><span id="l60.367">          */</span>
<a href="#l60.368"></a><span id="l60.368"> #  ifdef GETHOSTBYNAME_buf_t</span>
<a href="#l60.369"></a><span id="l60.369">         /* avoid allocation by using hbuf if large enough */</span>
<a href="#l60.370"></a><span id="l60.370">         if (sizeof(hbuf) &lt; ld-&gt;ld_dns_bufsize) {</span>
<a href="#l60.371"></a><span id="l60.371">           ldhpbuf = ldhpbuf_allocd = NSLDAPI_MALLOC(ld-&gt;ld_dns_bufsize);</span>
<a href="#l60.372"></a><span id="l60.372">         } else {</span>
<a href="#l60.373"></a><span id="l60.373" class="difflineminus">-          ldhpbuf = (char *)hbuf;</span>
<a href="#l60.374"></a><span id="l60.374" class="difflineplus">+          ldhpbuf = (char*)hbuf;</span>
<a href="#l60.375"></a><span id="l60.375">         }</span>
<a href="#l60.376"></a><span id="l60.376"> #  else  /* GETHOSTBYNAME_buf_t */</span>
<a href="#l60.377"></a><span id="l60.377">         ldhpbuf = ldhpbuf_allocd = NSLDAPI_MALLOC(ld-&gt;ld_dns_bufsize);</span>
<a href="#l60.378"></a><span id="l60.378"> #  endif /* else GETHOSTBYNAME_buf_t */</span>
<a href="#l60.379"></a><span id="l60.379"> </span>
<a href="#l60.380"></a><span id="l60.380">         if (ldhpbuf == NULL) {</span>
<a href="#l60.381"></a><span id="l60.381">           LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l60.382"></a><span id="l60.382">           ldap_memfree(host);</span>
<a href="#l60.383"></a><span id="l60.383" class="difflineat">@@ -633,22 +633,22 @@ static int nsldapi_try_each_host(LDAP *l</span>
<a href="#l60.384"></a><span id="l60.384">         int iostatus = 1;</span>
<a href="#l60.385"></a><span id="l60.385"> </span>
<a href="#l60.386"></a><span id="l60.386">         err = (*ioctlfn)(s, FIONBIO, &amp;iostatus);</span>
<a href="#l60.387"></a><span id="l60.387">         if (err == -1) {</span>
<a href="#l60.388"></a><span id="l60.388">           LDAPDebug(LDAP_DEBUG_ANY, &quot;FIONBIO ioctl failed on %d\n&quot;, s, 0, 0);</span>
<a href="#l60.389"></a><span id="l60.389">         }</span>
<a href="#l60.390"></a><span id="l60.390">       }</span>
<a href="#l60.391"></a><span id="l60.391"> </span>
<a href="#l60.392"></a><span id="l60.392" class="difflineminus">-      (void)memset((char *)&amp;sin, 0, sizeof(struct sockaddr_in));</span>
<a href="#l60.393"></a><span id="l60.393" class="difflineplus">+      (void)memset((char*)&amp;sin, 0, sizeof(struct sockaddr_in));</span>
<a href="#l60.394"></a><span id="l60.394">       sin.sin_family = AF_INET;</span>
<a href="#l60.395"></a><span id="l60.395">       sin.sin_port = htons((unsigned short)port);</span>
<a href="#l60.396"></a><span id="l60.396"> </span>
<a href="#l60.397"></a><span id="l60.397" class="difflineminus">-      SAFEMEMCPY((char *)&amp;sin.sin_addr.s_addr,</span>
<a href="#l60.398"></a><span id="l60.398" class="difflineminus">-                 (use_hp ? (char *)addrlist[i] : (char *)&amp;address),</span>
<a href="#l60.399"></a><span id="l60.399" class="difflineplus">+      SAFEMEMCPY((char*)&amp;sin.sin_addr.s_addr,</span>
<a href="#l60.400"></a><span id="l60.400" class="difflineplus">+                 (use_hp ? (char*)addrlist[i] : (char*)&amp;address),</span>
<a href="#l60.401"></a><span id="l60.401">                  sizeof(sin.sin_addr.s_addr));</span>
<a href="#l60.402"></a><span id="l60.402"> </span>
<a href="#l60.403"></a><span id="l60.403">       {</span>
<a href="#l60.404"></a><span id="l60.404"> #  ifdef NSLDAPI_CONNECT_MUST_NOT_BE_INTERRUPTED</span>
<a href="#l60.405"></a><span id="l60.405">         /*</span>
<a href="#l60.406"></a><span id="l60.406">          * Block all of the signals that might interrupt connect() since</span>
<a href="#l60.407"></a><span id="l60.407">          * there is an OS bug that causes connect() to fail if it is restarted.</span>
<a href="#l60.408"></a><span id="l60.408">          * Look in ../../include/portable.h for the definition of</span>
<a href="#l60.409"></a><span id="l60.409" class="difflineat">@@ -660,21 +660,21 @@ static int nsldapi_try_each_host(LDAP *l</span>
<a href="#l60.410"></a><span id="l60.410">         sigaddset(&amp;ints_off, SIGALRM);</span>
<a href="#l60.411"></a><span id="l60.411">         sigaddset(&amp;ints_off, SIGIO);</span>
<a href="#l60.412"></a><span id="l60.412">         sigaddset(&amp;ints_off, SIGCLD);</span>
<a href="#l60.413"></a><span id="l60.413"> </span>
<a href="#l60.414"></a><span id="l60.414">         NSLDAPI_MT_SAFE_SIGPROCMASK(SIG_BLOCK, &amp;ints_off, &amp;oldset);</span>
<a href="#l60.415"></a><span id="l60.415"> #  endif /* NSLDAPI_CONNECT_MUST_NOT_BE_INTERRUPTED */</span>
<a href="#l60.416"></a><span id="l60.416"> </span>
<a href="#l60.417"></a><span id="l60.417">         if (NULL != connectwithtofn) {</span>
<a href="#l60.418"></a><span id="l60.418" class="difflineminus">-          err = (*connectwithtofn)(s, (struct sockaddr *)&amp;sin,</span>
<a href="#l60.419"></a><span id="l60.419" class="difflineplus">+          err = (*connectwithtofn)(s, (struct sockaddr*)&amp;sin,</span>
<a href="#l60.420"></a><span id="l60.420">                                    sizeof(struct sockaddr_in),</span>
<a href="#l60.421"></a><span id="l60.421">                                    ld-&gt;ld_connect_timeout);</span>
<a href="#l60.422"></a><span id="l60.422">         } else {</span>
<a href="#l60.423"></a><span id="l60.423" class="difflineminus">-          err = (*connectfn)(s, (struct sockaddr *)&amp;sin,</span>
<a href="#l60.424"></a><span id="l60.424" class="difflineplus">+          err = (*connectfn)(s, (struct sockaddr*)&amp;sin,</span>
<a href="#l60.425"></a><span id="l60.425">                              sizeof(struct sockaddr_in));</span>
<a href="#l60.426"></a><span id="l60.426">         }</span>
<a href="#l60.427"></a><span id="l60.427"> #  ifdef NSLDAPI_CONNECT_MUST_NOT_BE_INTERRUPTED</span>
<a href="#l60.428"></a><span id="l60.428">         /*</span>
<a href="#l60.429"></a><span id="l60.429">          * restore original signal mask</span>
<a href="#l60.430"></a><span id="l60.430">          */</span>
<a href="#l60.431"></a><span id="l60.431">         NSLDAPI_MT_SAFE_SIGPROCMASK(SIG_SETMASK, &amp;oldset, 0);</span>
<a href="#l60.432"></a><span id="l60.432"> #  endif /* NSLDAPI_CONNECT_MUST_NOT_BE_INTERRUPTED */</span>
<a href="#l60.433"></a><span id="l60.433" class="difflineat">@@ -694,17 +694,17 @@ static int nsldapi_try_each_host(LDAP *l</span>
<a href="#l60.434"></a><span id="l60.434">             LDAPDebug(LDAP_DEBUG_TRACE, &quot;connect would block...\n&quot;, 0, 0, 0);</span>
<a href="#l60.435"></a><span id="l60.435">             rc = -2;</span>
<a href="#l60.436"></a><span id="l60.436">             break;</span>
<a href="#l60.437"></a><span id="l60.437">           }</span>
<a href="#l60.438"></a><span id="l60.438">         }</span>
<a href="#l60.439"></a><span id="l60.439"> </span>
<a href="#l60.440"></a><span id="l60.440"> #  ifdef LDAP_DEBUG</span>
<a href="#l60.441"></a><span id="l60.441">         if (ldap_debug &amp; LDAP_DEBUG_TRACE) {</span>
<a href="#l60.442"></a><span id="l60.442" class="difflineminus">-          perror((char *)inet_ntoa(sin.sin_addr));</span>
<a href="#l60.443"></a><span id="l60.443" class="difflineplus">+          perror((char*)inet_ntoa(sin.sin_addr));</span>
<a href="#l60.444"></a><span id="l60.444">         }</span>
<a href="#l60.445"></a><span id="l60.445"> #  endif</span>
<a href="#l60.446"></a><span id="l60.446">         (*closefn)(s);</span>
<a href="#l60.447"></a><span id="l60.447">         if (!use_hp) {</span>
<a href="#l60.448"></a><span id="l60.448">           break;</span>
<a href="#l60.449"></a><span id="l60.449">         }</span>
<a href="#l60.450"></a><span id="l60.450">       }</span>
<a href="#l60.451"></a><span id="l60.451">     }</span>
<a href="#l60.452"></a><span id="l60.452" class="difflineat">@@ -723,63 +723,63 @@ static int nsldapi_try_each_host(LDAP *l</span>
<a href="#l60.453"></a><span id="l60.453">     LDAPDebug(LDAP_DEBUG_TRACE, &quot;sd %d connected to: %s\n&quot;, s,</span>
<a href="#l60.454"></a><span id="l60.454">               inet_ntoa(sin.sin_addr), 0);</span>
<a href="#l60.455"></a><span id="l60.455">   }</span>
<a href="#l60.456"></a><span id="l60.456"> </span>
<a href="#l60.457"></a><span id="l60.457">   return (rc == 0 ? s : -1);</span>
<a href="#l60.458"></a><span id="l60.458"> #endif /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.459"></a><span id="l60.459"> }</span>
<a href="#l60.460"></a><span id="l60.460"> </span>
<a href="#l60.461"></a><span id="l60.461" class="difflineminus">-void nsldapi_close_connection(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l60.462"></a><span id="l60.462" class="difflineplus">+void nsldapi_close_connection(LDAP* ld, Sockbuf* sb) {</span>
<a href="#l60.463"></a><span id="l60.463">   if (ld-&gt;ld_extclose_fn == NULL) {</span>
<a href="#l60.464"></a><span id="l60.464"> #ifndef NSLDAPI_AVOID_OS_SOCKETS</span>
<a href="#l60.465"></a><span id="l60.465">     nsldapi_os_closesocket(sb-&gt;sb_sd);</span>
<a href="#l60.466"></a><span id="l60.466"> #endif /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l60.467"></a><span id="l60.467">   } else {</span>
<a href="#l60.468"></a><span id="l60.468">     ld-&gt;ld_extclose_fn(sb-&gt;sb_sd, sb-&gt;sb_ext_io_fns.lbextiofn_socket_arg);</span>
<a href="#l60.469"></a><span id="l60.469">   }</span>
<a href="#l60.470"></a><span id="l60.470"> }</span>
<a href="#l60.471"></a><span id="l60.471"> </span>
<a href="#l60.472"></a><span id="l60.472"> #ifdef KERBEROS</span>
<a href="#l60.473"></a><span id="l60.473" class="difflineminus">-char *nsldapi_host_connected_to(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l60.474"></a><span id="l60.474" class="difflineminus">-  struct hostent *hp;</span>
<a href="#l60.475"></a><span id="l60.475" class="difflineminus">-  char *p;</span>
<a href="#l60.476"></a><span id="l60.476" class="difflineplus">+char* nsldapi_host_connected_to(LDAP* ld, Sockbuf* sb) {</span>
<a href="#l60.477"></a><span id="l60.477" class="difflineplus">+  struct hostent* hp;</span>
<a href="#l60.478"></a><span id="l60.478" class="difflineplus">+  char* p;</span>
<a href="#l60.479"></a><span id="l60.479">   int len;</span>
<a href="#l60.480"></a><span id="l60.480">   struct sockaddr_in sin;</span>
<a href="#l60.481"></a><span id="l60.481"> </span>
<a href="#l60.482"></a><span id="l60.482" class="difflineminus">-  (void)memset((char *)&amp;sin, 0, sizeof(struct sockaddr_in));</span>
<a href="#l60.483"></a><span id="l60.483" class="difflineplus">+  (void)memset((char*)&amp;sin, 0, sizeof(struct sockaddr_in));</span>
<a href="#l60.484"></a><span id="l60.484">   len = sizeof(sin);</span>
<a href="#l60.485"></a><span id="l60.485" class="difflineminus">-  if (getpeername(sb-&gt;sb_sd, (struct sockaddr *)&amp;sin, &amp;len) == -1) {</span>
<a href="#l60.486"></a><span id="l60.486" class="difflineplus">+  if (getpeername(sb-&gt;sb_sd, (struct sockaddr*)&amp;sin, &amp;len) == -1) {</span>
<a href="#l60.487"></a><span id="l60.487">     return (NULL);</span>
<a href="#l60.488"></a><span id="l60.488">   }</span>
<a href="#l60.489"></a><span id="l60.489"> </span>
<a href="#l60.490"></a><span id="l60.490">   /*</span>
<a href="#l60.491"></a><span id="l60.491">    * do a reverse lookup on the addr to get the official hostname.</span>
<a href="#l60.492"></a><span id="l60.492">    * this is necessary for kerberos to work right, since the official</span>
<a href="#l60.493"></a><span id="l60.493">    * hostname is used as the kerberos instance.</span>
<a href="#l60.494"></a><span id="l60.494">    */</span>
<a href="#l60.495"></a><span id="l60.495"> #  error XXXmcs: need to use DNS callbacks here</span>
<a href="#l60.496"></a><span id="l60.496" class="difflineminus">-  if ((hp = (struct hostent *)gethostbyaddr(</span>
<a href="#l60.497"></a><span id="l60.497" class="difflineminus">-           (char *)&amp;sin.sin_addr, sizeof(sin.sin_addr), AF_INET)) != NULL) {</span>
<a href="#l60.498"></a><span id="l60.498" class="difflineplus">+  if ((hp = (struct hostent*)gethostbyaddr(</span>
<a href="#l60.499"></a><span id="l60.499" class="difflineplus">+           (char*)&amp;sin.sin_addr, sizeof(sin.sin_addr), AF_INET)) != NULL) {</span>
<a href="#l60.500"></a><span id="l60.500">     if (hp-&gt;h_name != NULL) {</span>
<a href="#l60.501"></a><span id="l60.501">       return (nsldapi_strdup(hp-&gt;h_name));</span>
<a href="#l60.502"></a><span id="l60.502">     }</span>
<a href="#l60.503"></a><span id="l60.503">   }</span>
<a href="#l60.504"></a><span id="l60.504"> </span>
<a href="#l60.505"></a><span id="l60.505">   return (NULL);</span>
<a href="#l60.506"></a><span id="l60.506"> }</span>
<a href="#l60.507"></a><span id="l60.507"> #endif /* KERBEROS */</span>
<a href="#l60.508"></a><span id="l60.508"> </span>
<a href="#l60.509"></a><span id="l60.509"> /*</span>
<a href="#l60.510"></a><span id="l60.510">  * Returns 0 if all goes well and -1 if an error occurs (error code set in ld)</span>
<a href="#l60.511"></a><span id="l60.511">  * Also allocates initializes ld-&gt;ld_iostatus if needed..</span>
<a href="#l60.512"></a><span id="l60.512">  */</span>
<a href="#l60.513"></a><span id="l60.513" class="difflineminus">-int nsldapi_iostatus_interest_write(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l60.514"></a><span id="l60.514" class="difflineplus">+int nsldapi_iostatus_interest_write(LDAP* ld, Sockbuf* sb) {</span>
<a href="#l60.515"></a><span id="l60.515">   int rc = 0;</span>
<a href="#l60.516"></a><span id="l60.516" class="difflineminus">-  NSLDAPIIOStatus *iosp;</span>
<a href="#l60.517"></a><span id="l60.517" class="difflineplus">+  NSLDAPIIOStatus* iosp;</span>
<a href="#l60.518"></a><span id="l60.518"> </span>
<a href="#l60.519"></a><span id="l60.519">   LDAP_MUTEX_LOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.520"></a><span id="l60.520"> </span>
<a href="#l60.521"></a><span id="l60.521">   if (ld-&gt;ld_iostatus == NULL &amp;&amp; nsldapi_iostatus_init_nolock(ld) &lt; 0) {</span>
<a href="#l60.522"></a><span id="l60.522">     rc = -1;</span>
<a href="#l60.523"></a><span id="l60.523">     goto unlock_and_return;</span>
<a href="#l60.524"></a><span id="l60.524">   }</span>
<a href="#l60.525"></a><span id="l60.525"> </span>
<a href="#l60.526"></a><span id="l60.526" class="difflineat">@@ -819,19 +819,19 @@ unlock_and_return:</span>
<a href="#l60.527"></a><span id="l60.527">   LDAP_MUTEX_UNLOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.528"></a><span id="l60.528">   return (rc);</span>
<a href="#l60.529"></a><span id="l60.529"> }</span>
<a href="#l60.530"></a><span id="l60.530"> </span>
<a href="#l60.531"></a><span id="l60.531"> /*</span>
<a href="#l60.532"></a><span id="l60.532">  * Returns 0 if all goes well and -1 if an error occurs (error code set in ld)</span>
<a href="#l60.533"></a><span id="l60.533">  * Also allocates initializes ld-&gt;ld_iostatus if needed..</span>
<a href="#l60.534"></a><span id="l60.534">  */</span>
<a href="#l60.535"></a><span id="l60.535" class="difflineminus">-int nsldapi_iostatus_interest_read(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l60.536"></a><span id="l60.536" class="difflineplus">+int nsldapi_iostatus_interest_read(LDAP* ld, Sockbuf* sb) {</span>
<a href="#l60.537"></a><span id="l60.537">   int rc = 0;</span>
<a href="#l60.538"></a><span id="l60.538" class="difflineminus">-  NSLDAPIIOStatus *iosp;</span>
<a href="#l60.539"></a><span id="l60.539" class="difflineplus">+  NSLDAPIIOStatus* iosp;</span>
<a href="#l60.540"></a><span id="l60.540"> </span>
<a href="#l60.541"></a><span id="l60.541">   LDAP_MUTEX_LOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.542"></a><span id="l60.542"> </span>
<a href="#l60.543"></a><span id="l60.543">   if (ld-&gt;ld_iostatus == NULL &amp;&amp; nsldapi_iostatus_init_nolock(ld) &lt; 0) {</span>
<a href="#l60.544"></a><span id="l60.544">     rc = -1;</span>
<a href="#l60.545"></a><span id="l60.545">     goto unlock_and_return;</span>
<a href="#l60.546"></a><span id="l60.546">   }</span>
<a href="#l60.547"></a><span id="l60.547"> </span>
<a href="#l60.548"></a><span id="l60.548" class="difflineat">@@ -870,19 +870,19 @@ unlock_and_return:</span>
<a href="#l60.549"></a><span id="l60.549">   LDAP_MUTEX_UNLOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.550"></a><span id="l60.550">   return (rc);</span>
<a href="#l60.551"></a><span id="l60.551"> }</span>
<a href="#l60.552"></a><span id="l60.552"> </span>
<a href="#l60.553"></a><span id="l60.553"> /*</span>
<a href="#l60.554"></a><span id="l60.554">  * Returns 0 if all goes well and -1 if an error occurs (error code set in ld)</span>
<a href="#l60.555"></a><span id="l60.555">  * Also allocates initializes ld-&gt;ld_iostatus if needed..</span>
<a href="#l60.556"></a><span id="l60.556">  */</span>
<a href="#l60.557"></a><span id="l60.557" class="difflineminus">-int nsldapi_iostatus_interest_clear(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l60.558"></a><span id="l60.558" class="difflineplus">+int nsldapi_iostatus_interest_clear(LDAP* ld, Sockbuf* sb) {</span>
<a href="#l60.559"></a><span id="l60.559">   int rc = 0;</span>
<a href="#l60.560"></a><span id="l60.560" class="difflineminus">-  NSLDAPIIOStatus *iosp;</span>
<a href="#l60.561"></a><span id="l60.561" class="difflineplus">+  NSLDAPIIOStatus* iosp;</span>
<a href="#l60.562"></a><span id="l60.562"> </span>
<a href="#l60.563"></a><span id="l60.563">   LDAP_MUTEX_LOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.564"></a><span id="l60.564"> </span>
<a href="#l60.565"></a><span id="l60.565">   if (ld-&gt;ld_iostatus == NULL &amp;&amp; nsldapi_iostatus_init_nolock(ld) &lt; 0) {</span>
<a href="#l60.566"></a><span id="l60.566">     rc = -1;</span>
<a href="#l60.567"></a><span id="l60.567">     goto unlock_and_return;</span>
<a href="#l60.568"></a><span id="l60.568">   }</span>
<a href="#l60.569"></a><span id="l60.569"> </span>
<a href="#l60.570"></a><span id="l60.570" class="difflineat">@@ -932,19 +932,19 @@ int nsldapi_iostatus_interest_clear(LDAP</span>
<a href="#l60.571"></a><span id="l60.571"> unlock_and_return:</span>
<a href="#l60.572"></a><span id="l60.572">   LDAP_MUTEX_UNLOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.573"></a><span id="l60.573">   return (rc);</span>
<a href="#l60.574"></a><span id="l60.574"> }</span>
<a href="#l60.575"></a><span id="l60.575"> </span>
<a href="#l60.576"></a><span id="l60.576"> /*</span>
<a href="#l60.577"></a><span id="l60.577">  * Return a non-zero value if sb is ready for write.</span>
<a href="#l60.578"></a><span id="l60.578">  */</span>
<a href="#l60.579"></a><span id="l60.579" class="difflineminus">-int nsldapi_iostatus_is_write_ready(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l60.580"></a><span id="l60.580" class="difflineplus">+int nsldapi_iostatus_is_write_ready(LDAP* ld, Sockbuf* sb) {</span>
<a href="#l60.581"></a><span id="l60.581">   int rc = 0;</span>
<a href="#l60.582"></a><span id="l60.582" class="difflineminus">-  NSLDAPIIOStatus *iosp;</span>
<a href="#l60.583"></a><span id="l60.583" class="difflineplus">+  NSLDAPIIOStatus* iosp;</span>
<a href="#l60.584"></a><span id="l60.584"> </span>
<a href="#l60.585"></a><span id="l60.585">   LDAP_MUTEX_LOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.586"></a><span id="l60.586">   iosp = ld-&gt;ld_iostatus;</span>
<a href="#l60.587"></a><span id="l60.587">   if (iosp == NULL) {</span>
<a href="#l60.588"></a><span id="l60.588">     goto unlock_and_return;</span>
<a href="#l60.589"></a><span id="l60.589">   }</span>
<a href="#l60.590"></a><span id="l60.590"> </span>
<a href="#l60.591"></a><span id="l60.591">   if (iosp-&gt;ios_type == NSLDAPI_IOSTATUS_TYPE_OSNATIVE) {</span>
<a href="#l60.592"></a><span id="l60.592" class="difflineat">@@ -982,19 +982,19 @@ int nsldapi_iostatus_is_write_ready(LDAP</span>
<a href="#l60.593"></a><span id="l60.593"> unlock_and_return:</span>
<a href="#l60.594"></a><span id="l60.594">   LDAP_MUTEX_UNLOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.595"></a><span id="l60.595">   return (rc);</span>
<a href="#l60.596"></a><span id="l60.596"> }</span>
<a href="#l60.597"></a><span id="l60.597"> </span>
<a href="#l60.598"></a><span id="l60.598"> /*</span>
<a href="#l60.599"></a><span id="l60.599">  * Return a non-zero value if sb is ready for read.</span>
<a href="#l60.600"></a><span id="l60.600">  */</span>
<a href="#l60.601"></a><span id="l60.601" class="difflineminus">-int nsldapi_iostatus_is_read_ready(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l60.602"></a><span id="l60.602" class="difflineplus">+int nsldapi_iostatus_is_read_ready(LDAP* ld, Sockbuf* sb) {</span>
<a href="#l60.603"></a><span id="l60.603">   int rc = 0;</span>
<a href="#l60.604"></a><span id="l60.604" class="difflineminus">-  NSLDAPIIOStatus *iosp;</span>
<a href="#l60.605"></a><span id="l60.605" class="difflineplus">+  NSLDAPIIOStatus* iosp;</span>
<a href="#l60.606"></a><span id="l60.606"> </span>
<a href="#l60.607"></a><span id="l60.607">   LDAP_MUTEX_LOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.608"></a><span id="l60.608">   iosp = ld-&gt;ld_iostatus;</span>
<a href="#l60.609"></a><span id="l60.609">   if (iosp == NULL) {</span>
<a href="#l60.610"></a><span id="l60.610">     goto unlock_and_return;</span>
<a href="#l60.611"></a><span id="l60.611">   }</span>
<a href="#l60.612"></a><span id="l60.612"> </span>
<a href="#l60.613"></a><span id="l60.613">   if (iosp-&gt;ios_type == NSLDAPI_IOSTATUS_TYPE_OSNATIVE) {</span>
<a href="#l60.614"></a><span id="l60.614" class="difflineat">@@ -1034,24 +1034,24 @@ unlock_and_return:</span>
<a href="#l60.615"></a><span id="l60.615">   return (rc);</span>
<a href="#l60.616"></a><span id="l60.616"> }</span>
<a href="#l60.617"></a><span id="l60.617"> </span>
<a href="#l60.618"></a><span id="l60.618"> /*</span>
<a href="#l60.619"></a><span id="l60.619">  * Allocate and initialize ld-&gt;ld_iostatus if not already done.</span>
<a href="#l60.620"></a><span id="l60.620">  * Should be called with LDAP_IOSTATUS_LOCK locked.</span>
<a href="#l60.621"></a><span id="l60.621">  * Returns 0 if all goes well and -1 if not (sets error in ld)</span>
<a href="#l60.622"></a><span id="l60.622">  */</span>
<a href="#l60.623"></a><span id="l60.623" class="difflineminus">-static int nsldapi_iostatus_init_nolock(LDAP *ld) {</span>
<a href="#l60.624"></a><span id="l60.624" class="difflineminus">-  NSLDAPIIOStatus *iosp;</span>
<a href="#l60.625"></a><span id="l60.625" class="difflineplus">+static int nsldapi_iostatus_init_nolock(LDAP* ld) {</span>
<a href="#l60.626"></a><span id="l60.626" class="difflineplus">+  NSLDAPIIOStatus* iosp;</span>
<a href="#l60.627"></a><span id="l60.627"> </span>
<a href="#l60.628"></a><span id="l60.628">   if (ld-&gt;ld_iostatus != NULL) {</span>
<a href="#l60.629"></a><span id="l60.629">     return (0);</span>
<a href="#l60.630"></a><span id="l60.630">   }</span>
<a href="#l60.631"></a><span id="l60.631"> </span>
<a href="#l60.632"></a><span id="l60.632" class="difflineminus">-  if ((iosp = (NSLDAPIIOStatus *)NSLDAPI_CALLOC(1, sizeof(NSLDAPIIOStatus))) ==</span>
<a href="#l60.633"></a><span id="l60.633" class="difflineplus">+  if ((iosp = (NSLDAPIIOStatus*)NSLDAPI_CALLOC(1, sizeof(NSLDAPIIOStatus))) ==</span>
<a href="#l60.634"></a><span id="l60.634">       NULL) {</span>
<a href="#l60.635"></a><span id="l60.635">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l60.636"></a><span id="l60.636">     return (-1);</span>
<a href="#l60.637"></a><span id="l60.637">   }</span>
<a href="#l60.638"></a><span id="l60.638"> </span>
<a href="#l60.639"></a><span id="l60.639">   if (ld-&gt;ld_extpoll_fn == NULL) {</span>
<a href="#l60.640"></a><span id="l60.640">     iosp-&gt;ios_type = NSLDAPI_IOSTATUS_TYPE_OSNATIVE;</span>
<a href="#l60.641"></a><span id="l60.641"> #ifdef NSLDAPI_AVOID_OS_SOCKETS</span>
<a href="#l60.642"></a><span id="l60.642" class="difflineat">@@ -1066,32 +1066,32 @@ static int nsldapi_iostatus_init_nolock(</span>
<a href="#l60.643"></a><span id="l60.643">   } else {</span>
<a href="#l60.644"></a><span id="l60.644">     iosp-&gt;ios_type = NSLDAPI_IOSTATUS_TYPE_CALLBACK;</span>
<a href="#l60.645"></a><span id="l60.645">   }</span>
<a href="#l60.646"></a><span id="l60.646"> </span>
<a href="#l60.647"></a><span id="l60.647">   ld-&gt;ld_iostatus = iosp;</span>
<a href="#l60.648"></a><span id="l60.648">   return (0);</span>
<a href="#l60.649"></a><span id="l60.649"> }</span>
<a href="#l60.650"></a><span id="l60.650"> </span>
<a href="#l60.651"></a><span id="l60.651" class="difflineminus">-void nsldapi_iostatus_free(LDAP *ld) {</span>
<a href="#l60.652"></a><span id="l60.652" class="difflineplus">+void nsldapi_iostatus_free(LDAP* ld) {</span>
<a href="#l60.653"></a><span id="l60.653">   if (ld == NULL) {</span>
<a href="#l60.654"></a><span id="l60.654">     return;</span>
<a href="#l60.655"></a><span id="l60.655">   }</span>
<a href="#l60.656"></a><span id="l60.656"> </span>
<a href="#l60.657"></a><span id="l60.657">   /* clean up classic I/O compatibility glue */</span>
<a href="#l60.658"></a><span id="l60.658">   if (ld-&gt;ld_io_fns_ptr != NULL) {</span>
<a href="#l60.659"></a><span id="l60.659">     if (ld-&gt;ld_ext_session_arg != NULL) {</span>
<a href="#l60.660"></a><span id="l60.660">       NSLDAPI_FREE(ld-&gt;ld_ext_session_arg);</span>
<a href="#l60.661"></a><span id="l60.661">     }</span>
<a href="#l60.662"></a><span id="l60.662">     NSLDAPI_FREE(ld-&gt;ld_io_fns_ptr);</span>
<a href="#l60.663"></a><span id="l60.663">   }</span>
<a href="#l60.664"></a><span id="l60.664"> </span>
<a href="#l60.665"></a><span id="l60.665">   /* clean up I/O status tracking info. */</span>
<a href="#l60.666"></a><span id="l60.666">   if (ld-&gt;ld_iostatus != NULL) {</span>
<a href="#l60.667"></a><span id="l60.667" class="difflineminus">-    NSLDAPIIOStatus *iosp = ld-&gt;ld_iostatus;</span>
<a href="#l60.668"></a><span id="l60.668" class="difflineplus">+    NSLDAPIIOStatus* iosp = ld-&gt;ld_iostatus;</span>
<a href="#l60.669"></a><span id="l60.669"> </span>
<a href="#l60.670"></a><span id="l60.670">     if (iosp-&gt;ios_type == NSLDAPI_IOSTATUS_TYPE_OSNATIVE) {</span>
<a href="#l60.671"></a><span id="l60.671"> #ifdef NSLDAPI_HAVE_POLL</span>
<a href="#l60.672"></a><span id="l60.672">       if (iosp-&gt;ios_status.ios_osinfo.ossi_pollfds != NULL) {</span>
<a href="#l60.673"></a><span id="l60.673">         NSLDAPI_FREE(iosp-&gt;ios_status.ios_osinfo.ossi_pollfds);</span>
<a href="#l60.674"></a><span id="l60.674">       }</span>
<a href="#l60.675"></a><span id="l60.675"> #endif /* NSLDAPI_HAVE_POLL */</span>
<a href="#l60.676"></a><span id="l60.676"> </span>
<a href="#l60.677"></a><span id="l60.677" class="difflineat">@@ -1130,27 +1130,27 @@ static int nsldapi_get_select_table_size</span>
<a href="#l60.678"></a><span id="l60.678">       tblsize = FD_SETSIZE - 1;</span>
<a href="#l60.679"></a><span id="l60.679">     }</span>
<a href="#l60.680"></a><span id="l60.680">   }</span>
<a href="#l60.681"></a><span id="l60.681"> </span>
<a href="#l60.682"></a><span id="l60.682">   return (tblsize);</span>
<a href="#l60.683"></a><span id="l60.683"> }</span>
<a href="#l60.684"></a><span id="l60.684"> #endif /* !defined(NSLDAPI_HAVE_POLL) &amp;&amp; !defined(NSLDAPI_AVOID_OS_SOCKETS) */</span>
<a href="#l60.685"></a><span id="l60.685"> </span>
<a href="#l60.686"></a><span id="l60.686" class="difflineminus">-static int nsldapi_tv2ms(struct timeval *tv) {</span>
<a href="#l60.687"></a><span id="l60.687" class="difflineplus">+static int nsldapi_tv2ms(struct timeval* tv) {</span>
<a href="#l60.688"></a><span id="l60.688">   if (tv == NULL) {</span>
<a href="#l60.689"></a><span id="l60.689">     return (-1); /* infinite timeout for poll() */</span>
<a href="#l60.690"></a><span id="l60.690">   }</span>
<a href="#l60.691"></a><span id="l60.691"> </span>
<a href="#l60.692"></a><span id="l60.692">   return (tv-&gt;tv_sec * 1000 + tv-&gt;tv_usec / 1000);</span>
<a href="#l60.693"></a><span id="l60.693"> }</span>
<a href="#l60.694"></a><span id="l60.694"> </span>
<a href="#l60.695"></a><span id="l60.695" class="difflineminus">-int nsldapi_iostatus_poll(LDAP *ld, struct timeval *timeout) {</span>
<a href="#l60.696"></a><span id="l60.696" class="difflineplus">+int nsldapi_iostatus_poll(LDAP* ld, struct timeval* timeout) {</span>
<a href="#l60.697"></a><span id="l60.697">   int rc;</span>
<a href="#l60.698"></a><span id="l60.698" class="difflineminus">-  NSLDAPIIOStatus *iosp;</span>
<a href="#l60.699"></a><span id="l60.699" class="difflineplus">+  NSLDAPIIOStatus* iosp;</span>
<a href="#l60.700"></a><span id="l60.700"> </span>
<a href="#l60.701"></a><span id="l60.701">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_iostatus_poll\n&quot;, 0, 0, 0);</span>
<a href="#l60.702"></a><span id="l60.702"> </span>
<a href="#l60.703"></a><span id="l60.703">   LDAP_MUTEX_LOCK(ld, LDAP_IOSTATUS_LOCK);</span>
<a href="#l60.704"></a><span id="l60.704">   iosp = ld-&gt;ld_iostatus;</span>
<a href="#l60.705"></a><span id="l60.705"> </span>
<a href="#l60.706"></a><span id="l60.706">   if (iosp == NULL ||</span>
<a href="#l60.707"></a><span id="l60.707">       (iosp-&gt;ios_read_count &lt;= 0 &amp;&amp; iosp-&gt;ios_write_count &lt;= 0)) {</span>
<a href="#l60.708"></a><span id="l60.708" class="difflineat">@@ -1170,17 +1170,17 @@ int nsldapi_iostatus_poll(LDAP *ld, stru</span>
<a href="#l60.709"></a><span id="l60.709">     iosp-&gt;ios_status.ios_osinfo.ossi_use_readfds =</span>
<a href="#l60.710"></a><span id="l60.710">         iosp-&gt;ios_status.ios_osinfo.ossi_readfds;</span>
<a href="#l60.711"></a><span id="l60.711">     iosp-&gt;ios_status.ios_osinfo.ossi_use_writefds =</span>
<a href="#l60.712"></a><span id="l60.712">         iosp-&gt;ios_status.ios_osinfo.ossi_writefds;</span>
<a href="#l60.713"></a><span id="l60.713"> </span>
<a href="#l60.714"></a><span id="l60.714"> #    ifdef HPUX9</span>
<a href="#l60.715"></a><span id="l60.715">     rc = NSLDAPI_SELECT(</span>
<a href="#l60.716"></a><span id="l60.716">         nsldapi_get_select_table_size(),</span>
<a href="#l60.717"></a><span id="l60.717" class="difflineminus">-        (int *)&amp;iosp-&gt;ios_status.ios_osinfo.ossi_use_readfds(int *) &amp;</span>
<a href="#l60.718"></a><span id="l60.718" class="difflineplus">+        (int*)&amp;iosp-&gt;ios_status.ios_osinfo.ossi_use_readfds(int*) &amp;</span>
<a href="#l60.719"></a><span id="l60.719">             iosp-&gt;ios_status.ios_osinfo.ossi_use_writefds,</span>
<a href="#l60.720"></a><span id="l60.720">         NULL, timeout);</span>
<a href="#l60.721"></a><span id="l60.721"> #    else</span>
<a href="#l60.722"></a><span id="l60.722">     rc = NSLDAPI_SELECT(nsldapi_get_select_table_size(),</span>
<a href="#l60.723"></a><span id="l60.723">                         &amp;iosp-&gt;ios_status.ios_osinfo.ossi_use_readfds,</span>
<a href="#l60.724"></a><span id="l60.724">                         &amp;iosp-&gt;ios_status.ios_osinfo.ossi_use_writefds, NULL,</span>
<a href="#l60.725"></a><span id="l60.725">                         timeout);</span>
<a href="#l60.726"></a><span id="l60.726"> #    endif /* else HPUX9 */</span>
<a href="#l60.727"></a><span id="l60.727" class="difflineat">@@ -1207,17 +1207,17 @@ int nsldapi_iostatus_poll(LDAP *ld, stru</span>
<a href="#l60.728"></a><span id="l60.728"> }</span>
<a href="#l60.729"></a><span id="l60.729"> </span>
<a href="#l60.730"></a><span id="l60.730"> #if defined(NSLDAPI_HAVE_POLL) &amp;&amp; !defined(NSLDAPI_AVOID_OS_SOCKETS)</span>
<a href="#l60.731"></a><span id="l60.731"> /*</span>
<a href="#l60.732"></a><span id="l60.732">  * returns 1 if &quot;fd&quot; was added to pollfds.</span>
<a href="#l60.733"></a><span id="l60.733">  * returns 1 if some of the bits in &quot;events&quot; were added to pollfds.</span>
<a href="#l60.734"></a><span id="l60.734">  * returns 0 if no changes were made.</span>
<a href="#l60.735"></a><span id="l60.735">  */</span>
<a href="#l60.736"></a><span id="l60.736" class="difflineminus">-static int nsldapi_add_to_os_pollfds(int fd, struct nsldapi_os_statusinfo *pip,</span>
<a href="#l60.737"></a><span id="l60.737" class="difflineplus">+static int nsldapi_add_to_os_pollfds(int fd, struct nsldapi_os_statusinfo* pip,</span>
<a href="#l60.738"></a><span id="l60.738">                                      short events) {</span>
<a href="#l60.739"></a><span id="l60.739">   int i, openslot;</span>
<a href="#l60.740"></a><span id="l60.740"> </span>
<a href="#l60.741"></a><span id="l60.741">   /* first we check to see if &quot;fd&quot; is already in our pollfds */</span>
<a href="#l60.742"></a><span id="l60.742">   openslot = -1;</span>
<a href="#l60.743"></a><span id="l60.743">   for (i = 0; i &lt; pip-&gt;ossi_pollfds_size; ++i) {</span>
<a href="#l60.744"></a><span id="l60.744">     if (pip-&gt;ossi_pollfds[i].fd == fd) {</span>
<a href="#l60.745"></a><span id="l60.745">       if ((pip-&gt;ossi_pollfds[i].events &amp; events) != events) {</span>
<a href="#l60.746"></a><span id="l60.746" class="difflineat">@@ -1233,23 +1233,23 @@ static int nsldapi_add_to_os_pollfds(int</span>
<a href="#l60.747"></a><span id="l60.747">   }</span>
<a href="#l60.748"></a><span id="l60.748"> </span>
<a href="#l60.749"></a><span id="l60.749">   /*</span>
<a href="#l60.750"></a><span id="l60.750">    * &quot;fd&quot; is not currently being poll'd on -- add to array.</span>
<a href="#l60.751"></a><span id="l60.751">    * if we need to expand the pollfds array, we do it in increments of</span>
<a href="#l60.752"></a><span id="l60.752">    * NSLDAPI_POLL_ARRAY_GROWTH (#define near the top of this file).</span>
<a href="#l60.753"></a><span id="l60.753">    */</span>
<a href="#l60.754"></a><span id="l60.754">   if (openslot == -1) {</span>
<a href="#l60.755"></a><span id="l60.755" class="difflineminus">-    struct pollfd *newpollfds;</span>
<a href="#l60.756"></a><span id="l60.756" class="difflineplus">+    struct pollfd* newpollfds;</span>
<a href="#l60.757"></a><span id="l60.757"> </span>
<a href="#l60.758"></a><span id="l60.758">     if (pip-&gt;ossi_pollfds_size == 0) {</span>
<a href="#l60.759"></a><span id="l60.759" class="difflineminus">-      newpollfds = (struct pollfd *)NSLDAPI_MALLOC(NSLDAPI_POLL_ARRAY_GROWTH *</span>
<a href="#l60.760"></a><span id="l60.760" class="difflineminus">-                                                   sizeof(struct pollfd));</span>
<a href="#l60.761"></a><span id="l60.761" class="difflineplus">+      newpollfds = (struct pollfd*)NSLDAPI_MALLOC(NSLDAPI_POLL_ARRAY_GROWTH *</span>
<a href="#l60.762"></a><span id="l60.762" class="difflineplus">+                                                  sizeof(struct pollfd));</span>
<a href="#l60.763"></a><span id="l60.763">     } else {</span>
<a href="#l60.764"></a><span id="l60.764" class="difflineminus">-      newpollfds = (struct pollfd *)NSLDAPI_REALLOC(</span>
<a href="#l60.765"></a><span id="l60.765" class="difflineplus">+      newpollfds = (struct pollfd*)NSLDAPI_REALLOC(</span>
<a href="#l60.766"></a><span id="l60.766">           pip-&gt;ossi_pollfds,</span>
<a href="#l60.767"></a><span id="l60.767">           (NSLDAPI_POLL_ARRAY_GROWTH + pip-&gt;ossi_pollfds_size) *</span>
<a href="#l60.768"></a><span id="l60.768">               sizeof(struct pollfd));</span>
<a href="#l60.769"></a><span id="l60.769">     }</span>
<a href="#l60.770"></a><span id="l60.770">     if (newpollfds == NULL) { /* XXXmcs: no way to return err! */</span>
<a href="#l60.771"></a><span id="l60.771">       return (0);</span>
<a href="#l60.772"></a><span id="l60.772">     }</span>
<a href="#l60.773"></a><span id="l60.773">     pip-&gt;ossi_pollfds = newpollfds;</span>
<a href="#l60.774"></a><span id="l60.774" class="difflineat">@@ -1266,17 +1266,17 @@ static int nsldapi_add_to_os_pollfds(int</span>
<a href="#l60.775"></a><span id="l60.775">   return (1);</span>
<a href="#l60.776"></a><span id="l60.776"> }</span>
<a href="#l60.777"></a><span id="l60.777"> </span>
<a href="#l60.778"></a><span id="l60.778"> /*</span>
<a href="#l60.779"></a><span id="l60.779">  * returns 1 if any &quot;events&quot; from &quot;fd&quot; were removed from pollfds</span>
<a href="#l60.780"></a><span id="l60.780">  * returns 0 of &quot;fd&quot; wasn't in pollfds or if events did not overlap.</span>
<a href="#l60.781"></a><span id="l60.781">  */</span>
<a href="#l60.782"></a><span id="l60.782"> static int nsldapi_clear_from_os_pollfds(int fd,</span>
<a href="#l60.783"></a><span id="l60.783" class="difflineminus">-                                         struct nsldapi_os_statusinfo *pip,</span>
<a href="#l60.784"></a><span id="l60.784" class="difflineplus">+                                         struct nsldapi_os_statusinfo* pip,</span>
<a href="#l60.785"></a><span id="l60.785">                                          short events) {</span>
<a href="#l60.786"></a><span id="l60.786">   int i;</span>
<a href="#l60.787"></a><span id="l60.787"> </span>
<a href="#l60.788"></a><span id="l60.788">   for (i = 0; i &lt; pip-&gt;ossi_pollfds_size; ++i) {</span>
<a href="#l60.789"></a><span id="l60.789">     if (pip-&gt;ossi_pollfds[i].fd == fd) {</span>
<a href="#l60.790"></a><span id="l60.790">       if ((pip-&gt;ossi_pollfds[i].events &amp; events) != 0) {</span>
<a href="#l60.791"></a><span id="l60.791">         pip-&gt;ossi_pollfds[i].events &amp;= ~events;</span>
<a href="#l60.792"></a><span id="l60.792">         if (pip-&gt;ossi_pollfds[i].events == 0) {</span>
<a href="#l60.793"></a><span id="l60.793" class="difflineat">@@ -1291,17 +1291,17 @@ static int nsldapi_clear_from_os_pollfds</span>
<a href="#l60.794"></a><span id="l60.794"> </span>
<a href="#l60.795"></a><span id="l60.795">   return (0); /* &quot;fd&quot; was not found */</span>
<a href="#l60.796"></a><span id="l60.796"> }</span>
<a href="#l60.797"></a><span id="l60.797"> </span>
<a href="#l60.798"></a><span id="l60.798"> /*</span>
<a href="#l60.799"></a><span id="l60.799">  * returns 1 if any &quot;revents&quot; from &quot;fd&quot; were set in pollfds revents field.</span>
<a href="#l60.800"></a><span id="l60.800">  * returns 0 if not.</span>
<a href="#l60.801"></a><span id="l60.801">  */</span>
<a href="#l60.802"></a><span id="l60.802" class="difflineminus">-static int nsldapi_find_in_os_pollfds(int fd, struct nsldapi_os_statusinfo *pip,</span>
<a href="#l60.803"></a><span id="l60.803" class="difflineplus">+static int nsldapi_find_in_os_pollfds(int fd, struct nsldapi_os_statusinfo* pip,</span>
<a href="#l60.804"></a><span id="l60.804">                                       short revents) {</span>
<a href="#l60.805"></a><span id="l60.805">   int i;</span>
<a href="#l60.806"></a><span id="l60.806"> </span>
<a href="#l60.807"></a><span id="l60.807">   for (i = 0; i &lt; pip-&gt;ossi_pollfds_size; ++i) {</span>
<a href="#l60.808"></a><span id="l60.808">     if (pip-&gt;ossi_pollfds[i].fd == fd) {</span>
<a href="#l60.809"></a><span id="l60.809">       if ((pip-&gt;ossi_pollfds[i].revents &amp; revents) != 0) {</span>
<a href="#l60.810"></a><span id="l60.810">         return (1); /* revents overlap */</span>
<a href="#l60.811"></a><span id="l60.811">       } else {</span>
<a href="#l60.812"></a><span id="l60.812" class="difflineat">@@ -1314,18 +1314,18 @@ static int nsldapi_find_in_os_pollfds(in</span>
<a href="#l60.813"></a><span id="l60.813"> }</span>
<a href="#l60.814"></a><span id="l60.814"> #endif /* !defined(NSLDAPI_HAVE_POLL) &amp;&amp; !defined(NSLDAPI_AVOID_OS_SOCKETS) */</span>
<a href="#l60.815"></a><span id="l60.815"> </span>
<a href="#l60.816"></a><span id="l60.816"> /*</span>
<a href="#l60.817"></a><span id="l60.817">  * returns 1 if &quot;sb&quot; was added to pollfds.</span>
<a href="#l60.818"></a><span id="l60.818">  * returns 1 if some of the bits in &quot;events&quot; were added to pollfds.</span>
<a href="#l60.819"></a><span id="l60.819">  * returns 0 if no changes were made.</span>
<a href="#l60.820"></a><span id="l60.820">  */</span>
<a href="#l60.821"></a><span id="l60.821" class="difflineminus">-static int nsldapi_add_to_cb_pollfds(Sockbuf *sb,</span>
<a href="#l60.822"></a><span id="l60.822" class="difflineminus">-                                     struct nsldapi_cb_statusinfo *pip,</span>
<a href="#l60.823"></a><span id="l60.823" class="difflineplus">+static int nsldapi_add_to_cb_pollfds(Sockbuf* sb,</span>
<a href="#l60.824"></a><span id="l60.824" class="difflineplus">+                                     struct nsldapi_cb_statusinfo* pip,</span>
<a href="#l60.825"></a><span id="l60.825">                                      short events) {</span>
<a href="#l60.826"></a><span id="l60.826">   int i, openslot;</span>
<a href="#l60.827"></a><span id="l60.827"> </span>
<a href="#l60.828"></a><span id="l60.828">   /* first we check to see if &quot;sb&quot; is already in our pollfds */</span>
<a href="#l60.829"></a><span id="l60.829">   openslot = -1;</span>
<a href="#l60.830"></a><span id="l60.830">   for (i = 0; i &lt; pip-&gt;cbsi_pollfds_size; ++i) {</span>
<a href="#l60.831"></a><span id="l60.831">     if (NSLDAPI_CB_POLL_MATCH(sb, pip-&gt;cbsi_pollfds[i])) {</span>
<a href="#l60.832"></a><span id="l60.832">       if ((pip-&gt;cbsi_pollfds[i].lpoll_events &amp; events) != events) {</span>
<a href="#l60.833"></a><span id="l60.833" class="difflineat">@@ -1341,23 +1341,23 @@ static int nsldapi_add_to_cb_pollfds(Soc</span>
<a href="#l60.834"></a><span id="l60.834">   }</span>
<a href="#l60.835"></a><span id="l60.835"> </span>
<a href="#l60.836"></a><span id="l60.836">   /*</span>
<a href="#l60.837"></a><span id="l60.837">    * &quot;sb&quot; is not currently being poll'd on -- add to array.</span>
<a href="#l60.838"></a><span id="l60.838">    * if we need to expand the pollfds array, we do it in increments of</span>
<a href="#l60.839"></a><span id="l60.839">    * NSLDAPI_POLL_ARRAY_GROWTH (#define near the top of this file).</span>
<a href="#l60.840"></a><span id="l60.840">    */</span>
<a href="#l60.841"></a><span id="l60.841">   if (openslot == -1) {</span>
<a href="#l60.842"></a><span id="l60.842" class="difflineminus">-    LDAP_X_PollFD *newpollfds;</span>
<a href="#l60.843"></a><span id="l60.843" class="difflineplus">+    LDAP_X_PollFD* newpollfds;</span>
<a href="#l60.844"></a><span id="l60.844"> </span>
<a href="#l60.845"></a><span id="l60.845">     if (pip-&gt;cbsi_pollfds_size == 0) {</span>
<a href="#l60.846"></a><span id="l60.846" class="difflineminus">-      newpollfds = (LDAP_X_PollFD *)NSLDAPI_MALLOC(NSLDAPI_POLL_ARRAY_GROWTH *</span>
<a href="#l60.847"></a><span id="l60.847" class="difflineminus">-                                                   sizeof(LDAP_X_PollFD));</span>
<a href="#l60.848"></a><span id="l60.848" class="difflineplus">+      newpollfds = (LDAP_X_PollFD*)NSLDAPI_MALLOC(NSLDAPI_POLL_ARRAY_GROWTH *</span>
<a href="#l60.849"></a><span id="l60.849" class="difflineplus">+                                                  sizeof(LDAP_X_PollFD));</span>
<a href="#l60.850"></a><span id="l60.850">     } else {</span>
<a href="#l60.851"></a><span id="l60.851" class="difflineminus">-      newpollfds = (LDAP_X_PollFD *)NSLDAPI_REALLOC(</span>
<a href="#l60.852"></a><span id="l60.852" class="difflineplus">+      newpollfds = (LDAP_X_PollFD*)NSLDAPI_REALLOC(</span>
<a href="#l60.853"></a><span id="l60.853">           pip-&gt;cbsi_pollfds,</span>
<a href="#l60.854"></a><span id="l60.854">           (NSLDAPI_POLL_ARRAY_GROWTH + pip-&gt;cbsi_pollfds_size) *</span>
<a href="#l60.855"></a><span id="l60.855">               sizeof(LDAP_X_PollFD));</span>
<a href="#l60.856"></a><span id="l60.856">     }</span>
<a href="#l60.857"></a><span id="l60.857">     if (newpollfds == NULL) { /* XXXmcs: no way to return err! */</span>
<a href="#l60.858"></a><span id="l60.858">       return (0);</span>
<a href="#l60.859"></a><span id="l60.859">     }</span>
<a href="#l60.860"></a><span id="l60.860">     pip-&gt;cbsi_pollfds = newpollfds;</span>
<a href="#l60.861"></a><span id="l60.861" class="difflineat">@@ -1377,18 +1377,18 @@ static int nsldapi_add_to_cb_pollfds(Soc</span>
<a href="#l60.862"></a><span id="l60.862">   pip-&gt;cbsi_pollfds[openslot].lpoll_revents = 0;</span>
<a href="#l60.863"></a><span id="l60.863">   return (1);</span>
<a href="#l60.864"></a><span id="l60.864"> }</span>
<a href="#l60.865"></a><span id="l60.865"> </span>
<a href="#l60.866"></a><span id="l60.866"> /*</span>
<a href="#l60.867"></a><span id="l60.867">  * returns 1 if any &quot;events&quot; from &quot;sb&quot; were removed from pollfds</span>
<a href="#l60.868"></a><span id="l60.868">  * returns 0 of &quot;sb&quot; wasn't in pollfds or if events did not overlap.</span>
<a href="#l60.869"></a><span id="l60.869">  */</span>
<a href="#l60.870"></a><span id="l60.870" class="difflineminus">-static int nsldapi_clear_from_cb_pollfds(Sockbuf *sb,</span>
<a href="#l60.871"></a><span id="l60.871" class="difflineminus">-                                         struct nsldapi_cb_statusinfo *pip,</span>
<a href="#l60.872"></a><span id="l60.872" class="difflineplus">+static int nsldapi_clear_from_cb_pollfds(Sockbuf* sb,</span>
<a href="#l60.873"></a><span id="l60.873" class="difflineplus">+                                         struct nsldapi_cb_statusinfo* pip,</span>
<a href="#l60.874"></a><span id="l60.874">                                          short events) {</span>
<a href="#l60.875"></a><span id="l60.875">   int i;</span>
<a href="#l60.876"></a><span id="l60.876"> </span>
<a href="#l60.877"></a><span id="l60.877">   for (i = 0; i &lt; pip-&gt;cbsi_pollfds_size; ++i) {</span>
<a href="#l60.878"></a><span id="l60.878">     if (NSLDAPI_CB_POLL_MATCH(sb, pip-&gt;cbsi_pollfds[i])) {</span>
<a href="#l60.879"></a><span id="l60.879">       if ((pip-&gt;cbsi_pollfds[i].lpoll_events &amp; events) != 0) {</span>
<a href="#l60.880"></a><span id="l60.880">         pip-&gt;cbsi_pollfds[i].lpoll_events &amp;= ~events;</span>
<a href="#l60.881"></a><span id="l60.881">         if (pip-&gt;cbsi_pollfds[i].lpoll_events == 0) {</span>
<a href="#l60.882"></a><span id="l60.882" class="difflineat">@@ -1403,18 +1403,18 @@ static int nsldapi_clear_from_cb_pollfds</span>
<a href="#l60.883"></a><span id="l60.883"> </span>
<a href="#l60.884"></a><span id="l60.884">   return (0); /* &quot;sb&quot; was not found */</span>
<a href="#l60.885"></a><span id="l60.885"> }</span>
<a href="#l60.886"></a><span id="l60.886"> </span>
<a href="#l60.887"></a><span id="l60.887"> /*</span>
<a href="#l60.888"></a><span id="l60.888">  * returns 1 if any &quot;revents&quot; from &quot;sb&quot; were set in pollfds revents field.</span>
<a href="#l60.889"></a><span id="l60.889">  * returns 0 if not.</span>
<a href="#l60.890"></a><span id="l60.890">  */</span>
<a href="#l60.891"></a><span id="l60.891" class="difflineminus">-static int nsldapi_find_in_cb_pollfds(Sockbuf *sb,</span>
<a href="#l60.892"></a><span id="l60.892" class="difflineminus">-                                      struct nsldapi_cb_statusinfo *pip,</span>
<a href="#l60.893"></a><span id="l60.893" class="difflineplus">+static int nsldapi_find_in_cb_pollfds(Sockbuf* sb,</span>
<a href="#l60.894"></a><span id="l60.894" class="difflineplus">+                                      struct nsldapi_cb_statusinfo* pip,</span>
<a href="#l60.895"></a><span id="l60.895">                                       short revents) {</span>
<a href="#l60.896"></a><span id="l60.896">   int i;</span>
<a href="#l60.897"></a><span id="l60.897"> </span>
<a href="#l60.898"></a><span id="l60.898">   for (i = 0; i &lt; pip-&gt;cbsi_pollfds_size; ++i) {</span>
<a href="#l60.899"></a><span id="l60.899">     if (NSLDAPI_CB_POLL_MATCH(sb, pip-&gt;cbsi_pollfds[i])) {</span>
<a href="#l60.900"></a><span id="l60.900">       if ((pip-&gt;cbsi_pollfds[i].lpoll_revents &amp; revents) != 0) {</span>
<a href="#l60.901"></a><span id="l60.901">         return (1); /* revents overlap */</span>
<a href="#l60.902"></a><span id="l60.902">       } else {</span>
<a href="#l60.903"></a><span id="l60.903" class="difflineat">@@ -1424,17 +1424,17 @@ static int nsldapi_find_in_cb_pollfds(So</span>
<a href="#l60.904"></a><span id="l60.904">   }</span>
<a href="#l60.905"></a><span id="l60.905"> </span>
<a href="#l60.906"></a><span id="l60.906">   return (0); /* &quot;sb&quot; was not found */</span>
<a href="#l60.907"></a><span id="l60.907"> }</span>
<a href="#l60.908"></a><span id="l60.908"> </span>
<a href="#l60.909"></a><span id="l60.909"> /*</span>
<a href="#l60.910"></a><span id="l60.910">  * Install read and write functions into lber layer / sb</span>
<a href="#l60.911"></a><span id="l60.911">  */</span>
<a href="#l60.912"></a><span id="l60.912" class="difflineminus">-int nsldapi_install_lber_extiofns(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l60.913"></a><span id="l60.913" class="difflineplus">+int nsldapi_install_lber_extiofns(LDAP* ld, Sockbuf* sb) {</span>
<a href="#l60.914"></a><span id="l60.914">   struct lber_x_ext_io_fns lberiofns;</span>
<a href="#l60.915"></a><span id="l60.915"> </span>
<a href="#l60.916"></a><span id="l60.916">   if (NULL != sb) {</span>
<a href="#l60.917"></a><span id="l60.917">     lberiofns.lbextiofn_size = LBER_X_EXTIO_FNS_SIZE;</span>
<a href="#l60.918"></a><span id="l60.918">     lberiofns.lbextiofn_read = ld-&gt;ld_extread_fn;</span>
<a href="#l60.919"></a><span id="l60.919">     lberiofns.lbextiofn_write = ld-&gt;ld_extwrite_fn;</span>
<a href="#l60.920"></a><span id="l60.920">     lberiofns.lbextiofn_writev = ld-&gt;ld_extwritev_fn;</span>
<a href="#l60.921"></a><span id="l60.921">     lberiofns.lbextiofn_socket_arg = ld-&gt;ld_ext_session_arg;</span>
<a href="#l60.922"></a><span id="l60.922" class="difflineat">@@ -1458,40 +1458,40 @@ int nsldapi_install_lber_extiofns(LDAP *</span>
<a href="#l60.923"></a><span id="l60.923">  * Our basic strategy is to use the new extended arg to hold a pointer to a</span>
<a href="#l60.924"></a><span id="l60.924">  *    structure that contains a pointer to the LDAP * (which contains pointers</span>
<a href="#l60.925"></a><span id="l60.925">  *    to the old functions so we can call them) as well as a pointer to an</span>
<a href="#l60.926"></a><span id="l60.926">  *    LBER_SOCKET to hold the socket used by the classic functions (the new</span>
<a href="#l60.927"></a><span id="l60.927">  *    functions use a simple int for the socket).</span>
<a href="#l60.928"></a><span id="l60.928">  */</span>
<a href="#l60.929"></a><span id="l60.929"> typedef struct nsldapi_compat_socket_info {</span>
<a href="#l60.930"></a><span id="l60.930">   LBER_SOCKET csi_socket;</span>
<a href="#l60.931"></a><span id="l60.931" class="difflineminus">-  LDAP *csi_ld;</span>
<a href="#l60.932"></a><span id="l60.932" class="difflineplus">+  LDAP* csi_ld;</span>
<a href="#l60.933"></a><span id="l60.933"> } NSLDAPICompatSocketInfo;</span>
<a href="#l60.934"></a><span id="l60.934"> </span>
<a href="#l60.935"></a><span id="l60.935"> static int LDAP_CALLBACK nsldapi_ext_compat_read(</span>
<a href="#l60.936"></a><span id="l60.936" class="difflineminus">-    int s, void *buf, int len, struct lextiof_socket_private *arg) {</span>
<a href="#l60.937"></a><span id="l60.937" class="difflineminus">-  NSLDAPICompatSocketInfo *csip = (NSLDAPICompatSocketInfo *)arg;</span>
<a href="#l60.938"></a><span id="l60.938" class="difflineminus">-  struct ldap_io_fns *iofns = csip-&gt;csi_ld-&gt;ld_io_fns_ptr;</span>
<a href="#l60.939"></a><span id="l60.939" class="difflineplus">+    int s, void* buf, int len, struct lextiof_socket_private* arg) {</span>
<a href="#l60.940"></a><span id="l60.940" class="difflineplus">+  NSLDAPICompatSocketInfo* csip = (NSLDAPICompatSocketInfo*)arg;</span>
<a href="#l60.941"></a><span id="l60.941" class="difflineplus">+  struct ldap_io_fns* iofns = csip-&gt;csi_ld-&gt;ld_io_fns_ptr;</span>
<a href="#l60.942"></a><span id="l60.942"> </span>
<a href="#l60.943"></a><span id="l60.943">   return (iofns-&gt;liof_read(csip-&gt;csi_socket, buf, len));</span>
<a href="#l60.944"></a><span id="l60.944"> }</span>
<a href="#l60.945"></a><span id="l60.945"> </span>
<a href="#l60.946"></a><span id="l60.946"> static int LDAP_CALLBACK nsldapi_ext_compat_write(</span>
<a href="#l60.947"></a><span id="l60.947" class="difflineminus">-    int s, const void *buf, int len, struct lextiof_socket_private *arg) {</span>
<a href="#l60.948"></a><span id="l60.948" class="difflineminus">-  NSLDAPICompatSocketInfo *csip = (NSLDAPICompatSocketInfo *)arg;</span>
<a href="#l60.949"></a><span id="l60.949" class="difflineminus">-  struct ldap_io_fns *iofns = csip-&gt;csi_ld-&gt;ld_io_fns_ptr;</span>
<a href="#l60.950"></a><span id="l60.950" class="difflineplus">+    int s, const void* buf, int len, struct lextiof_socket_private* arg) {</span>
<a href="#l60.951"></a><span id="l60.951" class="difflineplus">+  NSLDAPICompatSocketInfo* csip = (NSLDAPICompatSocketInfo*)arg;</span>
<a href="#l60.952"></a><span id="l60.952" class="difflineplus">+  struct ldap_io_fns* iofns = csip-&gt;csi_ld-&gt;ld_io_fns_ptr;</span>
<a href="#l60.953"></a><span id="l60.953"> </span>
<a href="#l60.954"></a><span id="l60.954">   return (iofns-&gt;liof_write(csip-&gt;csi_socket, buf, len));</span>
<a href="#l60.955"></a><span id="l60.955"> }</span>
<a href="#l60.956"></a><span id="l60.956"> </span>
<a href="#l60.957"></a><span id="l60.957"> static int LDAP_CALLBACK</span>
<a href="#l60.958"></a><span id="l60.958"> nsldapi_ext_compat_poll(LDAP_X_PollFD fds[], int nfds, int timeout,</span>
<a href="#l60.959"></a><span id="l60.959" class="difflineminus">-                        struct lextiof_session_private *arg) {</span>
<a href="#l60.960"></a><span id="l60.960" class="difflineminus">-  NSLDAPICompatSocketInfo *csip = (NSLDAPICompatSocketInfo *)arg;</span>
<a href="#l60.961"></a><span id="l60.961" class="difflineminus">-  struct ldap_io_fns *iofns = csip-&gt;csi_ld-&gt;ld_io_fns_ptr;</span>
<a href="#l60.962"></a><span id="l60.962" class="difflineplus">+                        struct lextiof_session_private* arg) {</span>
<a href="#l60.963"></a><span id="l60.963" class="difflineplus">+  NSLDAPICompatSocketInfo* csip = (NSLDAPICompatSocketInfo*)arg;</span>
<a href="#l60.964"></a><span id="l60.964" class="difflineplus">+  struct ldap_io_fns* iofns = csip-&gt;csi_ld-&gt;ld_io_fns_ptr;</span>
<a href="#l60.965"></a><span id="l60.965">   fd_set readfds, writefds;</span>
<a href="#l60.966"></a><span id="l60.966">   int i, rc, maxfd = 0;</span>
<a href="#l60.967"></a><span id="l60.967">   struct timeval tv, *tvp;</span>
<a href="#l60.968"></a><span id="l60.968"> </span>
<a href="#l60.969"></a><span id="l60.969">   /*</span>
<a href="#l60.970"></a><span id="l60.970">    * Prepare fd_sets for select()</span>
<a href="#l60.971"></a><span id="l60.971">    */</span>
<a href="#l60.972"></a><span id="l60.972">   FD_ZERO(&amp;readfds);</span>
<a href="#l60.973"></a><span id="l60.973" class="difflineat">@@ -1556,24 +1556,24 @@ nsldapi_ext_compat_poll(LDAP_X_PollFD fd</span>
<a href="#l60.974"></a><span id="l60.974">     }</span>
<a href="#l60.975"></a><span id="l60.975"> </span>
<a href="#l60.976"></a><span id="l60.976">     /* XXXmcs: any other cases to deal with?  LDAP_X_POLLERR? */</span>
<a href="#l60.977"></a><span id="l60.977">   }</span>
<a href="#l60.978"></a><span id="l60.978"> </span>
<a href="#l60.979"></a><span id="l60.979">   return (rc);</span>
<a href="#l60.980"></a><span id="l60.980"> }</span>
<a href="#l60.981"></a><span id="l60.981"> </span>
<a href="#l60.982"></a><span id="l60.982" class="difflineminus">-static LBER_SOCKET nsldapi_compat_socket(LDAP *ld, int secure, int domain,</span>
<a href="#l60.983"></a><span id="l60.983" class="difflineplus">+static LBER_SOCKET nsldapi_compat_socket(LDAP* ld, int secure, int domain,</span>
<a href="#l60.984"></a><span id="l60.984">                                          int type, int protocol) {</span>
<a href="#l60.985"></a><span id="l60.985">   int s;</span>
<a href="#l60.986"></a><span id="l60.986"> </span>
<a href="#l60.987"></a><span id="l60.987">   s = ld-&gt;ld_io_fns_ptr-&gt;liof_socket(domain, type, protocol);</span>
<a href="#l60.988"></a><span id="l60.988"> </span>
<a href="#l60.989"></a><span id="l60.989">   if (s &gt;= 0) {</span>
<a href="#l60.990"></a><span id="l60.990" class="difflineminus">-    char *errmsg = NULL;</span>
<a href="#l60.991"></a><span id="l60.991" class="difflineplus">+    char* errmsg = NULL;</span>
<a href="#l60.992"></a><span id="l60.992"> </span>
<a href="#l60.993"></a><span id="l60.993"> #ifdef NSLDAPI_HAVE_POLL</span>
<a href="#l60.994"></a><span id="l60.994">     if (ld-&gt;ld_io_fns_ptr-&gt;liof_select != NULL &amp;&amp; s &gt;= FD_SETSIZE) {</span>
<a href="#l60.995"></a><span id="l60.995">       errmsg = &quot;can't use socket &gt;= FD_SETSIZE&quot;;</span>
<a href="#l60.996"></a><span id="l60.996">     }</span>
<a href="#l60.997"></a><span id="l60.997"> #elif !defined(_WINDOWS) /* not on Windows and do not have poll() */</span>
<a href="#l60.998"></a><span id="l60.998">     if (s &gt;= FD_SETSIZE) {</span>
<a href="#l60.999"></a><span id="l60.999">       errmsg = &quot;can't use socket &gt;= FD_SETSIZE&quot;;</span>
<a href="#l60.1000"></a><span id="l60.1000" class="difflineat">@@ -1598,119 +1598,119 @@ static LBER_SOCKET nsldapi_compat_socket</span>
<a href="#l60.1001"></a><span id="l60.1001">   return (s);</span>
<a href="#l60.1002"></a><span id="l60.1002"> }</span>
<a href="#l60.1003"></a><span id="l60.1003"> </span>
<a href="#l60.1004"></a><span id="l60.1004"> /*</span>
<a href="#l60.1005"></a><span id="l60.1005">  * Note: timeout is ignored because we have no way to pass it via</span>
<a href="#l60.1006"></a><span id="l60.1006">  * the old I/O callback interface.</span>
<a href="#l60.1007"></a><span id="l60.1007">  */</span>
<a href="#l60.1008"></a><span id="l60.1008"> static int LDAP_CALLBACK nsldapi_ext_compat_connect(</span>
<a href="#l60.1009"></a><span id="l60.1009" class="difflineminus">-    const char *hostlist, int defport, int timeout, unsigned long options,</span>
<a href="#l60.1010"></a><span id="l60.1010" class="difflineminus">-    struct lextiof_session_private *sessionarg,</span>
<a href="#l60.1011"></a><span id="l60.1011" class="difflineminus">-    struct lextiof_socket_private **socketargp) {</span>
<a href="#l60.1012"></a><span id="l60.1012" class="difflineminus">-  NSLDAPICompatSocketInfo *defcsip;</span>
<a href="#l60.1013"></a><span id="l60.1013" class="difflineminus">-  struct ldap_io_fns *iofns;</span>
<a href="#l60.1014"></a><span id="l60.1014" class="difflineplus">+    const char* hostlist, int defport, int timeout, unsigned long options,</span>
<a href="#l60.1015"></a><span id="l60.1015" class="difflineplus">+    struct lextiof_session_private* sessionarg,</span>
<a href="#l60.1016"></a><span id="l60.1016" class="difflineplus">+    struct lextiof_socket_private** socketargp) {</span>
<a href="#l60.1017"></a><span id="l60.1017" class="difflineplus">+  NSLDAPICompatSocketInfo* defcsip;</span>
<a href="#l60.1018"></a><span id="l60.1018" class="difflineplus">+  struct ldap_io_fns* iofns;</span>
<a href="#l60.1019"></a><span id="l60.1019">   int s, secure;</span>
<a href="#l60.1020"></a><span id="l60.1020" class="difflineminus">-  NSLDAPI_SOCKET_FN *socketfn;</span>
<a href="#l60.1021"></a><span id="l60.1021" class="difflineminus">-  NSLDAPI_IOCTL_FN *ioctlfn;</span>
<a href="#l60.1022"></a><span id="l60.1022" class="difflineminus">-  NSLDAPI_CONNECT_WITH_TO_FN *connectwithtofn;</span>
<a href="#l60.1023"></a><span id="l60.1023" class="difflineminus">-  NSLDAPI_CONNECT_FN *connectfn;</span>
<a href="#l60.1024"></a><span id="l60.1024" class="difflineminus">-  NSLDAPI_CLOSE_FN *closefn;</span>
<a href="#l60.1025"></a><span id="l60.1025" class="difflineplus">+  NSLDAPI_SOCKET_FN* socketfn;</span>
<a href="#l60.1026"></a><span id="l60.1026" class="difflineplus">+  NSLDAPI_IOCTL_FN* ioctlfn;</span>
<a href="#l60.1027"></a><span id="l60.1027" class="difflineplus">+  NSLDAPI_CONNECT_WITH_TO_FN* connectwithtofn;</span>
<a href="#l60.1028"></a><span id="l60.1028" class="difflineplus">+  NSLDAPI_CONNECT_FN* connectfn;</span>
<a href="#l60.1029"></a><span id="l60.1029" class="difflineplus">+  NSLDAPI_CLOSE_FN* closefn;</span>
<a href="#l60.1030"></a><span id="l60.1030"> </span>
<a href="#l60.1031"></a><span id="l60.1031" class="difflineminus">-  defcsip = (NSLDAPICompatSocketInfo *)sessionarg;</span>
<a href="#l60.1032"></a><span id="l60.1032" class="difflineplus">+  defcsip = (NSLDAPICompatSocketInfo*)sessionarg;</span>
<a href="#l60.1033"></a><span id="l60.1033">   iofns = defcsip-&gt;csi_ld-&gt;ld_io_fns_ptr;</span>
<a href="#l60.1034"></a><span id="l60.1034"> </span>
<a href="#l60.1035"></a><span id="l60.1035">   if (0 != (options &amp; LDAP_X_EXTIOF_OPT_SECURE)) {</span>
<a href="#l60.1036"></a><span id="l60.1036">     if (NULL == iofns-&gt;liof_ssl_enable) {</span>
<a href="#l60.1037"></a><span id="l60.1037">       LDAP_SET_ERRNO(defcsip-&gt;csi_ld, EINVAL);</span>
<a href="#l60.1038"></a><span id="l60.1038">       return (-1);</span>
<a href="#l60.1039"></a><span id="l60.1039">     }</span>
<a href="#l60.1040"></a><span id="l60.1040">     secure = 1;</span>
<a href="#l60.1041"></a><span id="l60.1041">   } else {</span>
<a href="#l60.1042"></a><span id="l60.1042">     secure = 0;</span>
<a href="#l60.1043"></a><span id="l60.1043">   }</span>
<a href="#l60.1044"></a><span id="l60.1044"> </span>
<a href="#l60.1045"></a><span id="l60.1045">   socketfn =</span>
<a href="#l60.1046"></a><span id="l60.1046">       (iofns-&gt;liof_socket == NULL) ? nsldapi_os_socket : nsldapi_compat_socket;</span>
<a href="#l60.1047"></a><span id="l60.1047">   ioctlfn = (iofns-&gt;liof_ioctl == NULL)</span>
<a href="#l60.1048"></a><span id="l60.1048">                 ? nsldapi_os_ioctl</span>
<a href="#l60.1049"></a><span id="l60.1049" class="difflineminus">-                : (NSLDAPI_IOCTL_FN *)(iofns-&gt;liof_ioctl);</span>
<a href="#l60.1050"></a><span id="l60.1050" class="difflineplus">+                : (NSLDAPI_IOCTL_FN*)(iofns-&gt;liof_ioctl);</span>
<a href="#l60.1051"></a><span id="l60.1051">   if (NULL == iofns-&gt;liof_connect) {</span>
<a href="#l60.1052"></a><span id="l60.1052">     connectwithtofn = nsldapi_os_connect_with_to;</span>
<a href="#l60.1053"></a><span id="l60.1053">     connectfn = NULL;</span>
<a href="#l60.1054"></a><span id="l60.1054">   } else {</span>
<a href="#l60.1055"></a><span id="l60.1055">     connectwithtofn = NULL;</span>
<a href="#l60.1056"></a><span id="l60.1056">     connectfn = iofns-&gt;liof_connect;</span>
<a href="#l60.1057"></a><span id="l60.1057">   }</span>
<a href="#l60.1058"></a><span id="l60.1058">   closefn =</span>
<a href="#l60.1059"></a><span id="l60.1059">       (iofns-&gt;liof_close == NULL) ? nsldapi_os_closesocket : iofns-&gt;liof_close;</span>
<a href="#l60.1060"></a><span id="l60.1060"> </span>
<a href="#l60.1061"></a><span id="l60.1061">   s = nsldapi_try_each_host(defcsip-&gt;csi_ld, hostlist, defport, secure,</span>
<a href="#l60.1062"></a><span id="l60.1062">                             socketfn, ioctlfn, connectwithtofn, connectfn,</span>
<a href="#l60.1063"></a><span id="l60.1063">                             closefn);</span>
<a href="#l60.1064"></a><span id="l60.1064"> </span>
<a href="#l60.1065"></a><span id="l60.1065">   if (s &gt;= 0) {</span>
<a href="#l60.1066"></a><span id="l60.1066" class="difflineminus">-    NSLDAPICompatSocketInfo *csip;</span>
<a href="#l60.1067"></a><span id="l60.1067" class="difflineplus">+    NSLDAPICompatSocketInfo* csip;</span>
<a href="#l60.1068"></a><span id="l60.1068"> </span>
<a href="#l60.1069"></a><span id="l60.1069" class="difflineminus">-    if ((csip = (NSLDAPICompatSocketInfo *)NSLDAPI_CALLOC(</span>
<a href="#l60.1070"></a><span id="l60.1070" class="difflineplus">+    if ((csip = (NSLDAPICompatSocketInfo*)NSLDAPI_CALLOC(</span>
<a href="#l60.1071"></a><span id="l60.1071">              1, sizeof(NSLDAPICompatSocketInfo))) == NULL) {</span>
<a href="#l60.1072"></a><span id="l60.1072">       (*closefn)(s);</span>
<a href="#l60.1073"></a><span id="l60.1073">       LDAP_SET_LDERRNO(defcsip-&gt;csi_ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l60.1074"></a><span id="l60.1074">       return (-1);</span>
<a href="#l60.1075"></a><span id="l60.1075">     }</span>
<a href="#l60.1076"></a><span id="l60.1076"> </span>
<a href="#l60.1077"></a><span id="l60.1077">     csip-&gt;csi_socket = s;</span>
<a href="#l60.1078"></a><span id="l60.1078">     csip-&gt;csi_ld = defcsip-&gt;csi_ld;</span>
<a href="#l60.1079"></a><span id="l60.1079" class="difflineminus">-    *socketargp = (void *)csip;</span>
<a href="#l60.1080"></a><span id="l60.1080" class="difflineplus">+    *socketargp = (void*)csip;</span>
<a href="#l60.1081"></a><span id="l60.1081"> </span>
<a href="#l60.1082"></a><span id="l60.1082">     /*</span>
<a href="#l60.1083"></a><span id="l60.1083">      * We always return 1, which is a valid but not unique socket</span>
<a href="#l60.1084"></a><span id="l60.1084">      * (file descriptor) number.  The extended I/O functions only</span>
<a href="#l60.1085"></a><span id="l60.1085">      * require that the combination of the void *arg and the int</span>
<a href="#l60.1086"></a><span id="l60.1086">      * socket be unique.  Since we allocate the</span>
<a href="#l60.1087"></a><span id="l60.1087">      * NSLDAPICompatSocketInfo that we assign to arg, we meet</span>
<a href="#l60.1088"></a><span id="l60.1088">      * that requirement.</span>
<a href="#l60.1089"></a><span id="l60.1089">      */</span>
<a href="#l60.1090"></a><span id="l60.1090">     s = 1;</span>
<a href="#l60.1091"></a><span id="l60.1091">   }</span>
<a href="#l60.1092"></a><span id="l60.1092"> </span>
<a href="#l60.1093"></a><span id="l60.1093">   return (s);</span>
<a href="#l60.1094"></a><span id="l60.1094"> }</span>
<a href="#l60.1095"></a><span id="l60.1095"> </span>
<a href="#l60.1096"></a><span id="l60.1096"> static int LDAP_CALLBACK</span>
<a href="#l60.1097"></a><span id="l60.1097" class="difflineminus">-nsldapi_ext_compat_close(int s, struct lextiof_socket_private *arg) {</span>
<a href="#l60.1098"></a><span id="l60.1098" class="difflineminus">-  NSLDAPICompatSocketInfo *csip = (NSLDAPICompatSocketInfo *)arg;</span>
<a href="#l60.1099"></a><span id="l60.1099" class="difflineminus">-  struct ldap_io_fns *iofns = csip-&gt;csi_ld-&gt;ld_io_fns_ptr;</span>
<a href="#l60.1100"></a><span id="l60.1100" class="difflineplus">+nsldapi_ext_compat_close(int s, struct lextiof_socket_private* arg) {</span>
<a href="#l60.1101"></a><span id="l60.1101" class="difflineplus">+  NSLDAPICompatSocketInfo* csip = (NSLDAPICompatSocketInfo*)arg;</span>
<a href="#l60.1102"></a><span id="l60.1102" class="difflineplus">+  struct ldap_io_fns* iofns = csip-&gt;csi_ld-&gt;ld_io_fns_ptr;</span>
<a href="#l60.1103"></a><span id="l60.1103">   int rc;</span>
<a href="#l60.1104"></a><span id="l60.1104"> </span>
<a href="#l60.1105"></a><span id="l60.1105">   rc = iofns-&gt;liof_close(csip-&gt;csi_socket);</span>
<a href="#l60.1106"></a><span id="l60.1106"> </span>
<a href="#l60.1107"></a><span id="l60.1107">   NSLDAPI_FREE(csip);</span>
<a href="#l60.1108"></a><span id="l60.1108"> </span>
<a href="#l60.1109"></a><span id="l60.1109">   return (rc);</span>
<a href="#l60.1110"></a><span id="l60.1110"> }</span>
<a href="#l60.1111"></a><span id="l60.1111"> </span>
<a href="#l60.1112"></a><span id="l60.1112"> /*</span>
<a href="#l60.1113"></a><span id="l60.1113">  * Install the I/O functions.</span>
<a href="#l60.1114"></a><span id="l60.1114">  * Return an LDAP error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l60.1115"></a><span id="l60.1115">  */</span>
<a href="#l60.1116"></a><span id="l60.1116" class="difflineminus">-int nsldapi_install_compat_io_fns(LDAP *ld, struct ldap_io_fns *iofns) {</span>
<a href="#l60.1117"></a><span id="l60.1117" class="difflineminus">-  NSLDAPICompatSocketInfo *defcsip;</span>
<a href="#l60.1118"></a><span id="l60.1118" class="difflineplus">+int nsldapi_install_compat_io_fns(LDAP* ld, struct ldap_io_fns* iofns) {</span>
<a href="#l60.1119"></a><span id="l60.1119" class="difflineplus">+  NSLDAPICompatSocketInfo* defcsip;</span>
<a href="#l60.1120"></a><span id="l60.1120"> </span>
<a href="#l60.1121"></a><span id="l60.1121" class="difflineminus">-  if ((defcsip = (NSLDAPICompatSocketInfo *)NSLDAPI_CALLOC(</span>
<a href="#l60.1122"></a><span id="l60.1122" class="difflineplus">+  if ((defcsip = (NSLDAPICompatSocketInfo*)NSLDAPI_CALLOC(</span>
<a href="#l60.1123"></a><span id="l60.1123">            1, sizeof(NSLDAPICompatSocketInfo))) == NULL) {</span>
<a href="#l60.1124"></a><span id="l60.1124">     return (LDAP_NO_MEMORY);</span>
<a href="#l60.1125"></a><span id="l60.1125">   }</span>
<a href="#l60.1126"></a><span id="l60.1126"> </span>
<a href="#l60.1127"></a><span id="l60.1127">   defcsip-&gt;csi_socket = -1;</span>
<a href="#l60.1128"></a><span id="l60.1128">   defcsip-&gt;csi_ld = ld;</span>
<a href="#l60.1129"></a><span id="l60.1129"> </span>
<a href="#l60.1130"></a><span id="l60.1130">   if (ld-&gt;ld_io_fns_ptr != NULL) {</span>
<a href="#l60.1131"></a><span id="l60.1131" class="difflineminus">-    (void)memset((char *)ld-&gt;ld_io_fns_ptr, 0, sizeof(struct ldap_io_fns));</span>
<a href="#l60.1132"></a><span id="l60.1132" class="difflineminus">-  } else if ((ld-&gt;ld_io_fns_ptr = (struct ldap_io_fns *)NSLDAPI_CALLOC(</span>
<a href="#l60.1133"></a><span id="l60.1133" class="difflineplus">+    (void)memset((char*)ld-&gt;ld_io_fns_ptr, 0, sizeof(struct ldap_io_fns));</span>
<a href="#l60.1134"></a><span id="l60.1134" class="difflineplus">+  } else if ((ld-&gt;ld_io_fns_ptr = (struct ldap_io_fns*)NSLDAPI_CALLOC(</span>
<a href="#l60.1135"></a><span id="l60.1135">                   1, sizeof(struct ldap_io_fns))) == NULL) {</span>
<a href="#l60.1136"></a><span id="l60.1136">     NSLDAPI_FREE(defcsip);</span>
<a href="#l60.1137"></a><span id="l60.1137">     return (LDAP_NO_MEMORY);</span>
<a href="#l60.1138"></a><span id="l60.1138">   }</span>
<a href="#l60.1139"></a><span id="l60.1139"> </span>
<a href="#l60.1140"></a><span id="l60.1140">   /* struct copy */</span>
<a href="#l60.1141"></a><span id="l60.1141">   *(ld-&gt;ld_io_fns_ptr) = *iofns;</span>
<a href="#l60.1142"></a><span id="l60.1142"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l61.1"></a><span id="l61.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/proxyauthctrl.c</span>
<a href="#l61.2"></a><span id="l61.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/proxyauthctrl.c</span>
<a href="#l61.3"></a><span id="l61.3" class="difflineat">@@ -49,20 +49,20 @@</span>
<a href="#l61.4"></a><span id="l61.4">    ctl_iscritical  Indicates whether the control is critical of not. If</span>
<a href="#l61.5"></a><span id="l61.5">                    this field is non-zero, the operation will only be car-</span>
<a href="#l61.6"></a><span id="l61.6">                    ried out if the control is recognized by the server</span>
<a href="#l61.7"></a><span id="l61.7">                    and/or client</span>
<a href="#l61.8"></a><span id="l61.8"> </span>
<a href="#l61.9"></a><span id="l61.9">    ctrlp           the address of a place to put the constructed control</span>
<a href="#l61.10"></a><span id="l61.10"> */</span>
<a href="#l61.11"></a><span id="l61.11"> </span>
<a href="#l61.12"></a><span id="l61.12" class="difflineminus">-int LDAP_CALL ldap_create_proxyauth_control(LDAP *ld, const char *dn,</span>
<a href="#l61.13"></a><span id="l61.13" class="difflineplus">+int LDAP_CALL ldap_create_proxyauth_control(LDAP* ld, const char* dn,</span>
<a href="#l61.14"></a><span id="l61.14">                                             const char ctl_iscritical,</span>
<a href="#l61.15"></a><span id="l61.15" class="difflineminus">-                                            LDAPControl **ctrlp) {</span>
<a href="#l61.16"></a><span id="l61.16" class="difflineminus">-  BerElement *ber;</span>
<a href="#l61.17"></a><span id="l61.17" class="difflineplus">+                                            LDAPControl** ctrlp) {</span>
<a href="#l61.18"></a><span id="l61.18" class="difflineplus">+  BerElement* ber;</span>
<a href="#l61.19"></a><span id="l61.19">   int rc;</span>
<a href="#l61.20"></a><span id="l61.20"> </span>
<a href="#l61.21"></a><span id="l61.21">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l61.22"></a><span id="l61.22">     return (LDAP_PARAM_ERROR);</span>
<a href="#l61.23"></a><span id="l61.23">   }</span>
<a href="#l61.24"></a><span id="l61.24"> </span>
<a href="#l61.25"></a><span id="l61.25">   if (ctrlp == NULL) {</span>
<a href="#l61.26"></a><span id="l61.26">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l61.27"></a><span id="l61.27" class="difflineat">@@ -100,19 +100,19 @@ int LDAP_CALL ldap_create_proxyauth_cont</span>
<a href="#l61.28"></a><span id="l61.28">    ld              LDAP pointer to the desired connection</span>
<a href="#l61.29"></a><span id="l61.29"> </span>
<a href="#l61.30"></a><span id="l61.30">    authzid         The authorization identity used in the proxy auth,</span>
<a href="#l61.31"></a><span id="l61.31">                    e.g., dn:uid=bjensen,dc=example,dc=com</span>
<a href="#l61.32"></a><span id="l61.32"> </span>
<a href="#l61.33"></a><span id="l61.33">    ctrlp           the address of a place to put the constructed control</span>
<a href="#l61.34"></a><span id="l61.34"> */</span>
<a href="#l61.35"></a><span id="l61.35"> </span>
<a href="#l61.36"></a><span id="l61.36" class="difflineminus">-int LDAP_CALL ldap_create_proxiedauth_control(LDAP *ld, const char *authzid,</span>
<a href="#l61.37"></a><span id="l61.37" class="difflineminus">-                                              LDAPControl **ctrlp) {</span>
<a href="#l61.38"></a><span id="l61.38" class="difflineminus">-  BerElement *ber;</span>
<a href="#l61.39"></a><span id="l61.39" class="difflineplus">+int LDAP_CALL ldap_create_proxiedauth_control(LDAP* ld, const char* authzid,</span>
<a href="#l61.40"></a><span id="l61.40" class="difflineplus">+                                              LDAPControl** ctrlp) {</span>
<a href="#l61.41"></a><span id="l61.41" class="difflineplus">+  BerElement* ber;</span>
<a href="#l61.42"></a><span id="l61.42">   int rc;</span>
<a href="#l61.43"></a><span id="l61.43"> </span>
<a href="#l61.44"></a><span id="l61.44">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l61.45"></a><span id="l61.45">     return (LDAP_PARAM_ERROR);</span>
<a href="#l61.46"></a><span id="l61.46">   }</span>
<a href="#l61.47"></a><span id="l61.47"> </span>
<a href="#l61.48"></a><span id="l61.48">   if (ctrlp == NULL || authzid == NULL) {</span>
<a href="#l61.49"></a><span id="l61.49">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l62.1"></a><span id="l62.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/psearch.c</span>
<a href="#l62.2"></a><span id="l62.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/psearch.c</span>
<a href="#l62.3"></a><span id="l62.3" class="difflineat">@@ -34,22 +34,22 @@</span>
<a href="#l62.4"></a><span id="l62.4">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l62.5"></a><span id="l62.5">  *</span>
<a href="#l62.6"></a><span id="l62.6">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l62.7"></a><span id="l62.7"> /*</span>
<a href="#l62.8"></a><span id="l62.8">  * psearch.c - Persistent search and &quot;Entry Change Notification&quot; support.</span>
<a href="#l62.9"></a><span id="l62.9">  */</span>
<a href="#l62.10"></a><span id="l62.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l62.11"></a><span id="l62.11"> </span>
<a href="#l62.12"></a><span id="l62.12" class="difflineminus">-int LDAP_CALL ldap_create_persistentsearch_control(LDAP *ld, int changetypes,</span>
<a href="#l62.13"></a><span id="l62.13" class="difflineplus">+int LDAP_CALL ldap_create_persistentsearch_control(LDAP* ld, int changetypes,</span>
<a href="#l62.14"></a><span id="l62.14">                                                    int changesonly,</span>
<a href="#l62.15"></a><span id="l62.15">                                                    int return_echg_ctls,</span>
<a href="#l62.16"></a><span id="l62.16">                                                    char ctl_iscritical,</span>
<a href="#l62.17"></a><span id="l62.17" class="difflineminus">-                                                   LDAPControl **ctrlp) {</span>
<a href="#l62.18"></a><span id="l62.18" class="difflineminus">-  BerElement *ber;</span>
<a href="#l62.19"></a><span id="l62.19" class="difflineplus">+                                                   LDAPControl** ctrlp) {</span>
<a href="#l62.20"></a><span id="l62.20" class="difflineplus">+  BerElement* ber;</span>
<a href="#l62.21"></a><span id="l62.21">   int rc;</span>
<a href="#l62.22"></a><span id="l62.22"> </span>
<a href="#l62.23"></a><span id="l62.23">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l62.24"></a><span id="l62.24">     return (LDAP_PARAM_ERROR);</span>
<a href="#l62.25"></a><span id="l62.25">   }</span>
<a href="#l62.26"></a><span id="l62.26"> </span>
<a href="#l62.27"></a><span id="l62.27">   if (ctrlp == NULL || (changetypes &amp; ~LDAP_CHANGETYPE_ANY) != 0) {</span>
<a href="#l62.28"></a><span id="l62.28">     rc = LDAP_PARAM_ERROR;</span>
<a href="#l62.29"></a><span id="l62.29" class="difflineat">@@ -84,27 +84,27 @@ int LDAP_CALL ldap_create_persistentsear</span>
<a href="#l62.30"></a><span id="l62.30">   rc = nsldapi_build_control(LDAP_CONTROL_PERSISTENTSEARCH, ber, 1,</span>
<a href="#l62.31"></a><span id="l62.31">                              ctl_iscritical, ctrlp);</span>
<a href="#l62.32"></a><span id="l62.32"> </span>
<a href="#l62.33"></a><span id="l62.33"> report_error_and_return:</span>
<a href="#l62.34"></a><span id="l62.34">   LDAP_SET_LDERRNO(ld, rc, NULL, NULL);</span>
<a href="#l62.35"></a><span id="l62.35">   return (rc);</span>
<a href="#l62.36"></a><span id="l62.36"> }</span>
<a href="#l62.37"></a><span id="l62.37"> </span>
<a href="#l62.38"></a><span id="l62.38" class="difflineminus">-int LDAP_CALL ldap_parse_entrychange_control(LDAP *ld, LDAPControl **ctrls,</span>
<a href="#l62.39"></a><span id="l62.39" class="difflineminus">-                                             ber_int_t *chgtypep,</span>
<a href="#l62.40"></a><span id="l62.40" class="difflineminus">-                                             char **prevdnp,</span>
<a href="#l62.41"></a><span id="l62.41" class="difflineminus">-                                             int *chgnumpresentp,</span>
<a href="#l62.42"></a><span id="l62.42" class="difflineminus">-                                             ber_int_t *chgnump) {</span>
<a href="#l62.43"></a><span id="l62.43" class="difflineminus">-  BerElement *ber;</span>
<a href="#l62.44"></a><span id="l62.44" class="difflineplus">+int LDAP_CALL ldap_parse_entrychange_control(LDAP* ld, LDAPControl** ctrls,</span>
<a href="#l62.45"></a><span id="l62.45" class="difflineplus">+                                             ber_int_t* chgtypep,</span>
<a href="#l62.46"></a><span id="l62.46" class="difflineplus">+                                             char** prevdnp,</span>
<a href="#l62.47"></a><span id="l62.47" class="difflineplus">+                                             int* chgnumpresentp,</span>
<a href="#l62.48"></a><span id="l62.48" class="difflineplus">+                                             ber_int_t* chgnump) {</span>
<a href="#l62.49"></a><span id="l62.49" class="difflineplus">+  BerElement* ber;</span>
<a href="#l62.50"></a><span id="l62.50">   int rc, i;</span>
<a href="#l62.51"></a><span id="l62.51">   ber_int_t changetype;</span>
<a href="#l62.52"></a><span id="l62.52">   ber_len_t len;</span>
<a href="#l62.53"></a><span id="l62.53">   ber_int_t along;</span>
<a href="#l62.54"></a><span id="l62.54" class="difflineminus">-  char *previousdn;</span>
<a href="#l62.55"></a><span id="l62.55" class="difflineplus">+  char* previousdn;</span>
<a href="#l62.56"></a><span id="l62.56"> </span>
<a href="#l62.57"></a><span id="l62.57">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l62.58"></a><span id="l62.58">     return (LDAP_PARAM_ERROR);</span>
<a href="#l62.59"></a><span id="l62.59">   }</span>
<a href="#l62.60"></a><span id="l62.60"> </span>
<a href="#l62.61"></a><span id="l62.61">   /*</span>
<a href="#l62.62"></a><span id="l62.62">    * find the entry change notification in the list of controls</span>
<a href="#l62.63"></a><span id="l62.63">    */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l63.1"></a><span id="l63.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/pthreadtest.c</span>
<a href="#l63.2"></a><span id="l63.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/pthreadtest.c</span>
<a href="#l63.3"></a><span id="l63.3" class="difflineat">@@ -47,63 +47,63 @@</span>
<a href="#l63.4"></a><span id="l63.4"> #include &lt;ldap.h&gt;</span>
<a href="#l63.5"></a><span id="l63.5"> </span>
<a href="#l63.6"></a><span id="l63.6"> /* Authentication and search information. */</span>
<a href="#l63.7"></a><span id="l63.7"> #define NAME &quot;cn=Directory Manager&quot;</span>
<a href="#l63.8"></a><span id="l63.8"> #define PASSWORD &quot;rtfm11111&quot;</span>
<a href="#l63.9"></a><span id="l63.9"> #define BASE &quot;dc=example,dc=com&quot;</span>
<a href="#l63.10"></a><span id="l63.10"> #define SCOPE LDAP_SCOPE_SUBTREE</span>
<a href="#l63.11"></a><span id="l63.11"> </span>
<a href="#l63.12"></a><span id="l63.12" class="difflineminus">-static void *modify_thread();</span>
<a href="#l63.13"></a><span id="l63.13" class="difflineminus">-static void *add_thread();</span>
<a href="#l63.14"></a><span id="l63.14" class="difflineminus">-static void *delete_thread();</span>
<a href="#l63.15"></a><span id="l63.15" class="difflineminus">-static void *bind_thread();</span>
<a href="#l63.16"></a><span id="l63.16" class="difflineminus">-static void *compare_thread();</span>
<a href="#l63.17"></a><span id="l63.17" class="difflineminus">-static void *search_thread();</span>
<a href="#l63.18"></a><span id="l63.18" class="difflineminus">-static void *my_mutex_alloc();</span>
<a href="#l63.19"></a><span id="l63.19" class="difflineplus">+static void* modify_thread();</span>
<a href="#l63.20"></a><span id="l63.20" class="difflineplus">+static void* add_thread();</span>
<a href="#l63.21"></a><span id="l63.21" class="difflineplus">+static void* delete_thread();</span>
<a href="#l63.22"></a><span id="l63.22" class="difflineplus">+static void* bind_thread();</span>
<a href="#l63.23"></a><span id="l63.23" class="difflineplus">+static void* compare_thread();</span>
<a href="#l63.24"></a><span id="l63.24" class="difflineplus">+static void* search_thread();</span>
<a href="#l63.25"></a><span id="l63.25" class="difflineplus">+static void* my_mutex_alloc();</span>
<a href="#l63.26"></a><span id="l63.26"> static void my_mutex_free();</span>
<a href="#l63.27"></a><span id="l63.27" class="difflineminus">-void *my_sema_alloc(void);</span>
<a href="#l63.28"></a><span id="l63.28" class="difflineminus">-void my_sema_free(void *);</span>
<a href="#l63.29"></a><span id="l63.29" class="difflineminus">-int my_sema_wait(void *);</span>
<a href="#l63.30"></a><span id="l63.30" class="difflineminus">-int my_sema_post(void *);</span>
<a href="#l63.31"></a><span id="l63.31" class="difflineplus">+void* my_sema_alloc(void);</span>
<a href="#l63.32"></a><span id="l63.32" class="difflineplus">+void my_sema_free(void*);</span>
<a href="#l63.33"></a><span id="l63.33" class="difflineplus">+int my_sema_wait(void*);</span>
<a href="#l63.34"></a><span id="l63.34" class="difflineplus">+int my_sema_post(void*);</span>
<a href="#l63.35"></a><span id="l63.35"> static void set_ld_error();</span>
<a href="#l63.36"></a><span id="l63.36"> static int get_ld_error();</span>
<a href="#l63.37"></a><span id="l63.37"> static void set_errno();</span>
<a href="#l63.38"></a><span id="l63.38"> static int get_errno();</span>
<a href="#l63.39"></a><span id="l63.39"> static void tsd_setup();</span>
<a href="#l63.40"></a><span id="l63.40"> static void tsd_cleanup();</span>
<a href="#l63.41"></a><span id="l63.41"> static int get_random_id(void);</span>
<a href="#l63.42"></a><span id="l63.42" class="difflineminus">-static char *get_id_str(int id);</span>
<a href="#l63.43"></a><span id="l63.43" class="difflineplus">+static char* get_id_str(int id);</span>
<a href="#l63.44"></a><span id="l63.44"> </span>
<a href="#l63.45"></a><span id="l63.45"> /* Linked list of LDAPMessage structs for search results. */</span>
<a href="#l63.46"></a><span id="l63.46"> typedef struct ldapmsgwrapper {</span>
<a href="#l63.47"></a><span id="l63.47" class="difflineminus">-  LDAPMessage *lmw_messagep;</span>
<a href="#l63.48"></a><span id="l63.48" class="difflineminus">-  struct ldapmsgwrapper *lmw_next;</span>
<a href="#l63.49"></a><span id="l63.49" class="difflineplus">+  LDAPMessage* lmw_messagep;</span>
<a href="#l63.50"></a><span id="l63.50" class="difflineplus">+  struct ldapmsgwrapper* lmw_next;</span>
<a href="#l63.51"></a><span id="l63.51"> } ldapmsgwrapper;</span>
<a href="#l63.52"></a><span id="l63.52"> </span>
<a href="#l63.53"></a><span id="l63.53" class="difflineminus">-LDAP *ld;</span>
<a href="#l63.54"></a><span id="l63.54" class="difflineplus">+LDAP* ld;</span>
<a href="#l63.55"></a><span id="l63.55"> pthread_key_t key;</span>
<a href="#l63.56"></a><span id="l63.56"> int maxid = MAXINT;</span>
<a href="#l63.57"></a><span id="l63.57"> int maxops = 0;        /* zero means no limit */</span>
<a href="#l63.58"></a><span id="l63.58"> int range_filters = 0; /* if non-zero use &gt;= and &gt;= filters */</span>
<a href="#l63.59"></a><span id="l63.59"> </span>
<a href="#l63.60"></a><span id="l63.60" class="difflineminus">-main(int argc, char **argv)</span>
<a href="#l63.61"></a><span id="l63.61" class="difflineplus">+main(int argc, char** argv)</span>
<a href="#l63.62"></a><span id="l63.62"> </span>
<a href="#l63.63"></a><span id="l63.63"> {</span>
<a href="#l63.64"></a><span id="l63.64">   pthread_attr_t attr;</span>
<a href="#l63.65"></a><span id="l63.65" class="difflineminus">-  pthread_t *threadids;</span>
<a href="#l63.66"></a><span id="l63.66" class="difflineminus">-  void *status;</span>
<a href="#l63.67"></a><span id="l63.67" class="difflineplus">+  pthread_t* threadids;</span>
<a href="#l63.68"></a><span id="l63.68" class="difflineplus">+  void* status;</span>
<a href="#l63.69"></a><span id="l63.69">   struct ldap_thread_fns tfns;</span>
<a href="#l63.70"></a><span id="l63.70">   struct ldap_extra_thread_fns extrafns;</span>
<a href="#l63.71"></a><span id="l63.71">   int rc, c, errflg, i, inited_attr;</span>
<a href="#l63.72"></a><span id="l63.72">   int doadd, dodelete, domodify, docompare, dosearch, dobind;</span>
<a href="#l63.73"></a><span id="l63.73">   int option_extthreads, option_restart;</span>
<a href="#l63.74"></a><span id="l63.74">   int each_thread_count, thread_count;</span>
<a href="#l63.75"></a><span id="l63.75">   extern int optind;</span>
<a href="#l63.76"></a><span id="l63.76" class="difflineminus">-  extern char *optarg;</span>
<a href="#l63.77"></a><span id="l63.77" class="difflineplus">+  extern char* optarg;</span>
<a href="#l63.78"></a><span id="l63.78"> </span>
<a href="#l63.79"></a><span id="l63.79">   doadd = dodelete = domodify = docompare = dobind = dosearch = 0;</span>
<a href="#l63.80"></a><span id="l63.80">   option_extthreads = option_restart = 0;</span>
<a href="#l63.81"></a><span id="l63.81">   inited_attr = 0;</span>
<a href="#l63.82"></a><span id="l63.82">   errflg = 0;</span>
<a href="#l63.83"></a><span id="l63.83">   each_thread_count = 1; /* how many of each type of thread? */</span>
<a href="#l63.84"></a><span id="l63.84">   rc = LDAP_SUCCESS;     /* optimistic */</span>
<a href="#l63.85"></a><span id="l63.85"> </span>
<a href="#l63.86"></a><span id="l63.86" class="difflineat">@@ -148,17 +148,17 @@ main(int argc, char **argv)</span>
<a href="#l63.87"></a><span id="l63.87">       case 'o': /* operations to perform per thread */</span>
<a href="#l63.88"></a><span id="l63.88">         if ((maxops = atoi(optarg)) &lt; 0) {</span>
<a href="#l63.89"></a><span id="l63.89">           fprintf(stderr, &quot;operation limit must be &gt;= 0\n&quot;);</span>
<a href="#l63.90"></a><span id="l63.90">           ++errflg;</span>
<a href="#l63.91"></a><span id="l63.91">         }</span>
<a href="#l63.92"></a><span id="l63.92">         break;</span>
<a href="#l63.93"></a><span id="l63.93">       case 'S': /* random number seed */</span>
<a href="#l63.94"></a><span id="l63.94">         if (*optarg == 'r') {</span>
<a href="#l63.95"></a><span id="l63.95" class="difflineminus">-          int seed = (int)time((time_t *)0);</span>
<a href="#l63.96"></a><span id="l63.96" class="difflineplus">+          int seed = (int)time((time_t*)0);</span>
<a href="#l63.97"></a><span id="l63.97">           srandom(seed);</span>
<a href="#l63.98"></a><span id="l63.98">           printf(&quot;Random seed: %d\n&quot;, seed);</span>
<a href="#l63.99"></a><span id="l63.99">         } else {</span>
<a href="#l63.100"></a><span id="l63.100">           srandom(atoi(optarg));</span>
<a href="#l63.101"></a><span id="l63.101">         }</span>
<a href="#l63.102"></a><span id="l63.102">         break;</span>
<a href="#l63.103"></a><span id="l63.103">       default:</span>
<a href="#l63.104"></a><span id="l63.104">         ++errflg;</span>
<a href="#l63.105"></a><span id="l63.105" class="difflineat">@@ -211,65 +211,65 @@ main(int argc, char **argv)</span>
<a href="#l63.106"></a><span id="l63.106"> </span>
<a href="#l63.107"></a><span id="l63.107">   /* Create a key. */</span>
<a href="#l63.108"></a><span id="l63.108">   if (pthread_key_create(&amp;key, free) != 0) {</span>
<a href="#l63.109"></a><span id="l63.109">     perror(&quot;pthread_key_create&quot;);</span>
<a href="#l63.110"></a><span id="l63.110">   }</span>
<a href="#l63.111"></a><span id="l63.111">   tsd_setup();</span>
<a href="#l63.112"></a><span id="l63.112"> </span>
<a href="#l63.113"></a><span id="l63.113">   /* Allocate space for thread ids */</span>
<a href="#l63.114"></a><span id="l63.114" class="difflineminus">-  if ((threadids = (pthread_t *)calloc(thread_count, sizeof(pthread_t))) ==</span>
<a href="#l63.115"></a><span id="l63.115" class="difflineplus">+  if ((threadids = (pthread_t*)calloc(thread_count, sizeof(pthread_t))) ==</span>
<a href="#l63.116"></a><span id="l63.116">       NULL) {</span>
<a href="#l63.117"></a><span id="l63.117">     rc = LDAP_LOCAL_ERROR;</span>
<a href="#l63.118"></a><span id="l63.118">     goto clean_up_and_return;</span>
<a href="#l63.119"></a><span id="l63.119">   }</span>
<a href="#l63.120"></a><span id="l63.120"> </span>
<a href="#l63.121"></a><span id="l63.121">   /* Initialize the LDAP session. */</span>
<a href="#l63.122"></a><span id="l63.122">   if ((ld = ldap_init(argv[optind], atoi(argv[optind + 1]))) == NULL) {</span>
<a href="#l63.123"></a><span id="l63.123">     perror(&quot;ldap_init&quot;);</span>
<a href="#l63.124"></a><span id="l63.124">     rc = LDAP_LOCAL_ERROR;</span>
<a href="#l63.125"></a><span id="l63.125">     goto clean_up_and_return;</span>
<a href="#l63.126"></a><span id="l63.126">   }</span>
<a href="#l63.127"></a><span id="l63.127"> </span>
<a href="#l63.128"></a><span id="l63.128">   /* Set the function pointers for dealing with mutexes</span>
<a href="#l63.129"></a><span id="l63.129">      and error information. */</span>
<a href="#l63.130"></a><span id="l63.130">   memset(&amp;tfns, '\0', sizeof(struct ldap_thread_fns));</span>
<a href="#l63.131"></a><span id="l63.131" class="difflineminus">-  tfns.ltf_mutex_alloc = (void *(*)(void))my_mutex_alloc;</span>
<a href="#l63.132"></a><span id="l63.132" class="difflineminus">-  tfns.ltf_mutex_free = (void (*)(void *))my_mutex_free;</span>
<a href="#l63.133"></a><span id="l63.133" class="difflineminus">-  tfns.ltf_mutex_lock = (int (*)(void *))pthread_mutex_lock;</span>
<a href="#l63.134"></a><span id="l63.134" class="difflineminus">-  tfns.ltf_mutex_unlock = (int (*)(void *))pthread_mutex_unlock;</span>
<a href="#l63.135"></a><span id="l63.135" class="difflineplus">+  tfns.ltf_mutex_alloc = (void* (*)(void))my_mutex_alloc;</span>
<a href="#l63.136"></a><span id="l63.136" class="difflineplus">+  tfns.ltf_mutex_free = (void (*)(void*))my_mutex_free;</span>
<a href="#l63.137"></a><span id="l63.137" class="difflineplus">+  tfns.ltf_mutex_lock = (int (*)(void*))pthread_mutex_lock;</span>
<a href="#l63.138"></a><span id="l63.138" class="difflineplus">+  tfns.ltf_mutex_unlock = (int (*)(void*))pthread_mutex_unlock;</span>
<a href="#l63.139"></a><span id="l63.139">   tfns.ltf_get_errno = get_errno;</span>
<a href="#l63.140"></a><span id="l63.140">   tfns.ltf_set_errno = set_errno;</span>
<a href="#l63.141"></a><span id="l63.141">   tfns.ltf_get_lderrno = get_ld_error;</span>
<a href="#l63.142"></a><span id="l63.142">   tfns.ltf_set_lderrno = set_ld_error;</span>
<a href="#l63.143"></a><span id="l63.143">   tfns.ltf_lderrno_arg = NULL;</span>
<a href="#l63.144"></a><span id="l63.144"> </span>
<a href="#l63.145"></a><span id="l63.145">   /* Set up this session to use those function pointers. */</span>
<a href="#l63.146"></a><span id="l63.146"> </span>
<a href="#l63.147"></a><span id="l63.147" class="difflineminus">-  rc = ldap_set_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void *)&amp;tfns);</span>
<a href="#l63.148"></a><span id="l63.148" class="difflineplus">+  rc = ldap_set_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void*)&amp;tfns);</span>
<a href="#l63.149"></a><span id="l63.149">   if (rc &lt; 0) {</span>
<a href="#l63.150"></a><span id="l63.150">     rc = ldap_get_lderrno(ld, NULL, NULL);</span>
<a href="#l63.151"></a><span id="l63.151">     fprintf(stderr, &quot;ldap_set_option (LDAP_OPT_THREAD_FN_PTRS): %s\n&quot;,</span>
<a href="#l63.152"></a><span id="l63.152">             ldap_err2string(rc));</span>
<a href="#l63.153"></a><span id="l63.153">     goto clean_up_and_return;</span>
<a href="#l63.154"></a><span id="l63.154">   }</span>
<a href="#l63.155"></a><span id="l63.155"> </span>
<a href="#l63.156"></a><span id="l63.156">   if (option_extthreads) {</span>
<a href="#l63.157"></a><span id="l63.157">     /* Set the function pointers for working with semaphores. */</span>
<a href="#l63.158"></a><span id="l63.158"> </span>
<a href="#l63.159"></a><span id="l63.159">     memset(&amp;extrafns, '\0', sizeof(struct ldap_extra_thread_fns));</span>
<a href="#l63.160"></a><span id="l63.160" class="difflineminus">-    extrafns.ltf_mutex_trylock = (int (*)(void *))pthread_mutex_trylock;</span>
<a href="#l63.161"></a><span id="l63.161" class="difflineminus">-    extrafns.ltf_sema_alloc = (void *(*)(void))my_sema_alloc;</span>
<a href="#l63.162"></a><span id="l63.162" class="difflineminus">-    extrafns.ltf_sema_free = (void (*)(void *))my_sema_free;</span>
<a href="#l63.163"></a><span id="l63.163" class="difflineminus">-    extrafns.ltf_sema_wait = (int (*)(void *))my_sema_wait;</span>
<a href="#l63.164"></a><span id="l63.164" class="difflineminus">-    extrafns.ltf_sema_post = (int (*)(void *))my_sema_post;</span>
<a href="#l63.165"></a><span id="l63.165" class="difflineplus">+    extrafns.ltf_mutex_trylock = (int (*)(void*))pthread_mutex_trylock;</span>
<a href="#l63.166"></a><span id="l63.166" class="difflineplus">+    extrafns.ltf_sema_alloc = (void* (*)(void))my_sema_alloc;</span>
<a href="#l63.167"></a><span id="l63.167" class="difflineplus">+    extrafns.ltf_sema_free = (void (*)(void*))my_sema_free;</span>
<a href="#l63.168"></a><span id="l63.168" class="difflineplus">+    extrafns.ltf_sema_wait = (int (*)(void*))my_sema_wait;</span>
<a href="#l63.169"></a><span id="l63.169" class="difflineplus">+    extrafns.ltf_sema_post = (int (*)(void*))my_sema_post;</span>
<a href="#l63.170"></a><span id="l63.170"> </span>
<a href="#l63.171"></a><span id="l63.171">     /* Set up this session to use those function pointers. */</span>
<a href="#l63.172"></a><span id="l63.172"> </span>
<a href="#l63.173"></a><span id="l63.173" class="difflineminus">-    if (ldap_set_option(ld, LDAP_OPT_EXTRA_THREAD_FN_PTRS, (void *)&amp;extrafns) !=</span>
<a href="#l63.174"></a><span id="l63.174" class="difflineplus">+    if (ldap_set_option(ld, LDAP_OPT_EXTRA_THREAD_FN_PTRS, (void*)&amp;extrafns) !=</span>
<a href="#l63.175"></a><span id="l63.175">         0) {</span>
<a href="#l63.176"></a><span id="l63.176">       rc = ldap_get_lderrno(ld, NULL, NULL);</span>
<a href="#l63.177"></a><span id="l63.177">       ldap_perror(ld,</span>
<a href="#l63.178"></a><span id="l63.178">                   &quot;ldap_set_option&quot;</span>
<a href="#l63.179"></a><span id="l63.179">                   &quot; (LDAP_OPT_EXTRA_THREAD_FN_PTRS)&quot;);</span>
<a href="#l63.180"></a><span id="l63.180">       goto clean_up_and_return;</span>
<a href="#l63.181"></a><span id="l63.181">     }</span>
<a href="#l63.182"></a><span id="l63.182">   }</span>
<a href="#l63.183"></a><span id="l63.183" class="difflineat">@@ -389,28 +389,28 @@ clean_up_and_return:</span>
<a href="#l63.184"></a><span id="l63.184">   if (inited_attr) {</span>
<a href="#l63.185"></a><span id="l63.185">     pthread_attr_destroy(&amp;attr);</span>
<a href="#l63.186"></a><span id="l63.186">   }</span>
<a href="#l63.187"></a><span id="l63.187">   tsd_cleanup();</span>
<a href="#l63.188"></a><span id="l63.188"> </span>
<a href="#l63.189"></a><span id="l63.189">   return (rc);</span>
<a href="#l63.190"></a><span id="l63.190"> }</span>
<a href="#l63.191"></a><span id="l63.191"> </span>
<a href="#l63.192"></a><span id="l63.192" class="difflineminus">-static void *modify_thread(char *id) {</span>
<a href="#l63.193"></a><span id="l63.193" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l63.194"></a><span id="l63.194" class="difflineminus">-  LDAPMessage *e;</span>
<a href="#l63.195"></a><span id="l63.195" class="difflineplus">+static void* modify_thread(char* id) {</span>
<a href="#l63.196"></a><span id="l63.196" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l63.197"></a><span id="l63.197" class="difflineplus">+  LDAPMessage* e;</span>
<a href="#l63.198"></a><span id="l63.198">   int i, modentry, num_entries, msgid, parse_rc, finished;</span>
<a href="#l63.199"></a><span id="l63.199">   int rc, opcount;</span>
<a href="#l63.200"></a><span id="l63.200">   LDAPMod mod;</span>
<a href="#l63.201"></a><span id="l63.201" class="difflineminus">-  LDAPMod *mods[2];</span>
<a href="#l63.202"></a><span id="l63.202" class="difflineminus">-  char *vals[2];</span>
<a href="#l63.203"></a><span id="l63.203" class="difflineminus">-  char *dn;</span>
<a href="#l63.204"></a><span id="l63.204" class="difflineplus">+  LDAPMod* mods[2];</span>
<a href="#l63.205"></a><span id="l63.205" class="difflineplus">+  char* vals[2];</span>
<a href="#l63.206"></a><span id="l63.206" class="difflineplus">+  char* dn;</span>
<a href="#l63.207"></a><span id="l63.207">   ldapmsgwrapper *list, *lmwp, *lastlmwp;</span>
<a href="#l63.208"></a><span id="l63.208">   struct timeval zerotime;</span>
<a href="#l63.209"></a><span id="l63.209" class="difflineminus">-  void *voidrc = (void *)0;</span>
<a href="#l63.210"></a><span id="l63.210" class="difflineplus">+  void* voidrc = (void*)0;</span>
<a href="#l63.211"></a><span id="l63.211"> </span>
<a href="#l63.212"></a><span id="l63.212">   zerotime.tv_sec = zerotime.tv_usec = 0L;</span>
<a href="#l63.213"></a><span id="l63.213"> </span>
<a href="#l63.214"></a><span id="l63.214">   printf(&quot;Starting modify_thread %s.\n&quot;, id);</span>
<a href="#l63.215"></a><span id="l63.215">   opcount = 0;</span>
<a href="#l63.216"></a><span id="l63.216">   tsd_setup();</span>
<a href="#l63.217"></a><span id="l63.217"> </span>
<a href="#l63.218"></a><span id="l63.218">   rc = ldap_search_ext(ld, BASE, SCOPE, &quot;(objectclass=*)&quot;, NULL, 0, NULL, NULL,</span>
<a href="#l63.219"></a><span id="l63.219" class="difflineat">@@ -433,17 +433,17 @@ static void *modify_thread(char *id) {</span>
<a href="#l63.220"></a><span id="l63.220">         fprintf(stderr, &quot;ldap_result: %s\n&quot;, ldap_err2string(rc));</span>
<a href="#l63.221"></a><span id="l63.221">         exit(1);</span>
<a href="#l63.222"></a><span id="l63.222">         break;</span>
<a href="#l63.223"></a><span id="l63.223">       case 0:</span>
<a href="#l63.224"></a><span id="l63.224">         break;</span>
<a href="#l63.225"></a><span id="l63.225">       /* Keep track of the number of entries found. */</span>
<a href="#l63.226"></a><span id="l63.226">       case LDAP_RES_SEARCH_ENTRY:</span>
<a href="#l63.227"></a><span id="l63.227">         num_entries++;</span>
<a href="#l63.228"></a><span id="l63.228" class="difflineminus">-        if ((lmwp = (ldapmsgwrapper *)malloc(sizeof(ldapmsgwrapper))) == NULL) {</span>
<a href="#l63.229"></a><span id="l63.229" class="difflineplus">+        if ((lmwp = (ldapmsgwrapper*)malloc(sizeof(ldapmsgwrapper))) == NULL) {</span>
<a href="#l63.230"></a><span id="l63.230">           fprintf(stderr, &quot;Thread %s: Modify thread: Cannot malloc\n&quot;, id);</span>
<a href="#l63.231"></a><span id="l63.231">           exit(1);</span>
<a href="#l63.232"></a><span id="l63.232">         }</span>
<a href="#l63.233"></a><span id="l63.233">         lmwp-&gt;lmw_messagep = res;</span>
<a href="#l63.234"></a><span id="l63.234">         lmwp-&gt;lmw_next = NULL;</span>
<a href="#l63.235"></a><span id="l63.235">         if (lastlmwp == NULL) {</span>
<a href="#l63.236"></a><span id="l63.236">           list = lastlmwp = lmwp;</span>
<a href="#l63.237"></a><span id="l63.237">         } else {</span>
<a href="#l63.238"></a><span id="l63.238" class="difflineat">@@ -502,17 +502,17 @@ static void *modify_thread(char *id) {</span>
<a href="#l63.239"></a><span id="l63.239">     mod.mod_values = vals;</span>
<a href="#l63.240"></a><span id="l63.240">     printf(&quot;Thread %s: Modifying (%s)\n&quot;, id, dn);</span>
<a href="#l63.241"></a><span id="l63.241"> </span>
<a href="#l63.242"></a><span id="l63.242">     rc = ldap_modify_ext_s(ld, dn, mods, NULL, NULL);</span>
<a href="#l63.243"></a><span id="l63.243">     if (rc != LDAP_SUCCESS) {</span>
<a href="#l63.244"></a><span id="l63.244">       fprintf(stderr, &quot;ldap_modify_ext_s: %s\n&quot;, ldap_err2string(rc));</span>
<a href="#l63.245"></a><span id="l63.245">       if (rc == LDAP_SERVER_DOWN) {</span>
<a href="#l63.246"></a><span id="l63.246">         perror(&quot;ldap_modify_ext_s&quot;);</span>
<a href="#l63.247"></a><span id="l63.247" class="difflineminus">-        voidrc = (void *)1;</span>
<a href="#l63.248"></a><span id="l63.248" class="difflineplus">+        voidrc = (void*)1;</span>
<a href="#l63.249"></a><span id="l63.249">         goto modify_cleanup_and_return;</span>
<a href="#l63.250"></a><span id="l63.250">       }</span>
<a href="#l63.251"></a><span id="l63.251">     }</span>
<a href="#l63.252"></a><span id="l63.252">     free(dn);</span>
<a href="#l63.253"></a><span id="l63.253"> </span>
<a href="#l63.254"></a><span id="l63.254">     ++opcount;</span>
<a href="#l63.255"></a><span id="l63.255">     if (maxops != 0 &amp;&amp; opcount &gt;= maxops) {</span>
<a href="#l63.256"></a><span id="l63.256">       break;</span>
<a href="#l63.257"></a><span id="l63.257" class="difflineat">@@ -522,23 +522,23 @@ static void *modify_thread(char *id) {</span>
<a href="#l63.258"></a><span id="l63.258"> modify_cleanup_and_return:</span>
<a href="#l63.259"></a><span id="l63.259">   printf(&quot;Thread %s: attempted %d modify operations\n&quot;, id, opcount);</span>
<a href="#l63.260"></a><span id="l63.260">   set_ld_error(0, NULL, NULL, NULL); /* disposes of memory */</span>
<a href="#l63.261"></a><span id="l63.261">   tsd_cleanup();</span>
<a href="#l63.262"></a><span id="l63.262">   free(id);</span>
<a href="#l63.263"></a><span id="l63.263">   return voidrc;</span>
<a href="#l63.264"></a><span id="l63.264"> }</span>
<a href="#l63.265"></a><span id="l63.265"> </span>
<a href="#l63.266"></a><span id="l63.266" class="difflineminus">-static void *add_thread(char *id) {</span>
<a href="#l63.267"></a><span id="l63.267" class="difflineplus">+static void* add_thread(char* id) {</span>
<a href="#l63.268"></a><span id="l63.268">   LDAPMod mod[4];</span>
<a href="#l63.269"></a><span id="l63.269" class="difflineminus">-  LDAPMod *mods[5];</span>
<a href="#l63.270"></a><span id="l63.270" class="difflineplus">+  LDAPMod* mods[5];</span>
<a href="#l63.271"></a><span id="l63.271">   char dn[BUFSIZ], name[40];</span>
<a href="#l63.272"></a><span id="l63.272">   char *cnvals[2], *snvals[2], *pwdvals[2], *ocvals[3];</span>
<a href="#l63.273"></a><span id="l63.273">   int i, rc, opcount;</span>
<a href="#l63.274"></a><span id="l63.274" class="difflineminus">-  void *voidrc = (void *)0;</span>
<a href="#l63.275"></a><span id="l63.275" class="difflineplus">+  void* voidrc = (void*)0;</span>
<a href="#l63.276"></a><span id="l63.276"> </span>
<a href="#l63.277"></a><span id="l63.277">   printf(&quot;Starting add_thread %s.\n&quot;, id);</span>
<a href="#l63.278"></a><span id="l63.278">   opcount = 0;</span>
<a href="#l63.279"></a><span id="l63.279">   tsd_setup();</span>
<a href="#l63.280"></a><span id="l63.280"> </span>
<a href="#l63.281"></a><span id="l63.281">   for (i = 0; i &lt; 4; i++) {</span>
<a href="#l63.282"></a><span id="l63.282">     mods[i] = &amp;mod[i];</span>
<a href="#l63.283"></a><span id="l63.283">   }</span>
<a href="#l63.284"></a><span id="l63.284" class="difflineat">@@ -573,17 +573,17 @@ static void *add_thread(char *id) {</span>
<a href="#l63.285"></a><span id="l63.285">     pwdvals[0] = name;</span>
<a href="#l63.286"></a><span id="l63.286"> </span>
<a href="#l63.287"></a><span id="l63.287">     printf(&quot;Thread %s: Adding entry (%s)\n&quot;, id, dn);</span>
<a href="#l63.288"></a><span id="l63.288">     rc = ldap_add_ext_s(ld, dn, mods, NULL, NULL);</span>
<a href="#l63.289"></a><span id="l63.289">     if (rc != LDAP_SUCCESS) {</span>
<a href="#l63.290"></a><span id="l63.290">       fprintf(stderr, &quot;ldap_add_ext_s: %s\n&quot;, ldap_err2string(rc));</span>
<a href="#l63.291"></a><span id="l63.291">       if (rc == LDAP_SERVER_DOWN) {</span>
<a href="#l63.292"></a><span id="l63.292">         perror(&quot;ldap_add_ext_s&quot;);</span>
<a href="#l63.293"></a><span id="l63.293" class="difflineminus">-        voidrc = (void *)1;</span>
<a href="#l63.294"></a><span id="l63.294" class="difflineplus">+        voidrc = (void*)1;</span>
<a href="#l63.295"></a><span id="l63.295">         goto add_cleanup_and_return;</span>
<a href="#l63.296"></a><span id="l63.296">       }</span>
<a href="#l63.297"></a><span id="l63.297">     }</span>
<a href="#l63.298"></a><span id="l63.298"> </span>
<a href="#l63.299"></a><span id="l63.299">     ++opcount;</span>
<a href="#l63.300"></a><span id="l63.300">     if (maxops != 0 &amp;&amp; opcount &gt;= maxops) {</span>
<a href="#l63.301"></a><span id="l63.301">       break;</span>
<a href="#l63.302"></a><span id="l63.302">     }</span>
<a href="#l63.303"></a><span id="l63.303" class="difflineat">@@ -592,22 +592,22 @@ static void *add_thread(char *id) {</span>
<a href="#l63.304"></a><span id="l63.304"> add_cleanup_and_return:</span>
<a href="#l63.305"></a><span id="l63.305">   printf(&quot;Thread %s: attempted %d add operations\n&quot;, id, opcount);</span>
<a href="#l63.306"></a><span id="l63.306">   set_ld_error(0, NULL, NULL, NULL); /* disposes of memory */</span>
<a href="#l63.307"></a><span id="l63.307">   tsd_cleanup();</span>
<a href="#l63.308"></a><span id="l63.308">   free(id);</span>
<a href="#l63.309"></a><span id="l63.309">   return voidrc;</span>
<a href="#l63.310"></a><span id="l63.310"> }</span>
<a href="#l63.311"></a><span id="l63.311"> </span>
<a href="#l63.312"></a><span id="l63.312" class="difflineminus">-static void *delete_thread(char *id) {</span>
<a href="#l63.313"></a><span id="l63.313" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l63.314"></a><span id="l63.314" class="difflineplus">+static void* delete_thread(char* id) {</span>
<a href="#l63.315"></a><span id="l63.315" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l63.316"></a><span id="l63.316">   char dn[BUFSIZ], name[40];</span>
<a href="#l63.317"></a><span id="l63.317">   int num_entries, msgid, rc, parse_rc, finished, opcount;</span>
<a href="#l63.318"></a><span id="l63.318">   struct timeval zerotime;</span>
<a href="#l63.319"></a><span id="l63.319" class="difflineminus">-  void *voidrc = (void *)0;</span>
<a href="#l63.320"></a><span id="l63.320" class="difflineplus">+  void* voidrc = (void*)0;</span>
<a href="#l63.321"></a><span id="l63.321"> </span>
<a href="#l63.322"></a><span id="l63.322">   zerotime.tv_sec = zerotime.tv_usec = 0L;</span>
<a href="#l63.323"></a><span id="l63.323"> </span>
<a href="#l63.324"></a><span id="l63.324">   printf(&quot;Starting delete_thread %s.\n&quot;, id);</span>
<a href="#l63.325"></a><span id="l63.325">   opcount = 0;</span>
<a href="#l63.326"></a><span id="l63.326">   tsd_setup();</span>
<a href="#l63.327"></a><span id="l63.327"> </span>
<a href="#l63.328"></a><span id="l63.328">   rc = ldap_search_ext(ld, BASE, SCOPE, &quot;(objectclass=*)&quot;, NULL, 0, NULL, NULL,</span>
<a href="#l63.329"></a><span id="l63.329" class="difflineat">@@ -662,17 +662,17 @@ static void *delete_thread(char *id) {</span>
<a href="#l63.330"></a><span id="l63.330">     sprintf(name, &quot;%d&quot;, get_random_id());</span>
<a href="#l63.331"></a><span id="l63.331">     sprintf(dn, &quot;cn=%s, &quot; BASE, name);</span>
<a href="#l63.332"></a><span id="l63.332">     printf(&quot;Thread %s: Deleting entry (%s)\n&quot;, id, dn);</span>
<a href="#l63.333"></a><span id="l63.333"> </span>
<a href="#l63.334"></a><span id="l63.334">     if ((rc = ldap_delete_ext_s(ld, dn, NULL, NULL)) != LDAP_SUCCESS) {</span>
<a href="#l63.335"></a><span id="l63.335">       ldap_perror(ld, &quot;ldap_delete_ext_s&quot;);</span>
<a href="#l63.336"></a><span id="l63.336">       if (rc == LDAP_SERVER_DOWN) {</span>
<a href="#l63.337"></a><span id="l63.337">         perror(&quot;ldap_delete_ext_s&quot;);</span>
<a href="#l63.338"></a><span id="l63.338" class="difflineminus">-        voidrc = (void *)1;</span>
<a href="#l63.339"></a><span id="l63.339" class="difflineplus">+        voidrc = (void*)1;</span>
<a href="#l63.340"></a><span id="l63.340">         goto delete_cleanup_and_return;</span>
<a href="#l63.341"></a><span id="l63.341">       }</span>
<a href="#l63.342"></a><span id="l63.342">     }</span>
<a href="#l63.343"></a><span id="l63.343"> </span>
<a href="#l63.344"></a><span id="l63.344">     ++opcount;</span>
<a href="#l63.345"></a><span id="l63.345">     if (maxops != 0 &amp;&amp; opcount &gt;= maxops) {</span>
<a href="#l63.346"></a><span id="l63.346">       break;</span>
<a href="#l63.347"></a><span id="l63.347">     }</span>
<a href="#l63.348"></a><span id="l63.348" class="difflineat">@@ -681,35 +681,35 @@ static void *delete_thread(char *id) {</span>
<a href="#l63.349"></a><span id="l63.349"> delete_cleanup_and_return:</span>
<a href="#l63.350"></a><span id="l63.350">   printf(&quot;Thread %s: attempted %d delete operations\n&quot;, id, opcount);</span>
<a href="#l63.351"></a><span id="l63.351">   set_ld_error(0, NULL, NULL, NULL); /* disposes of memory */</span>
<a href="#l63.352"></a><span id="l63.352">   tsd_cleanup();</span>
<a href="#l63.353"></a><span id="l63.353">   free(id);</span>
<a href="#l63.354"></a><span id="l63.354">   return voidrc;</span>
<a href="#l63.355"></a><span id="l63.355"> }</span>
<a href="#l63.356"></a><span id="l63.356"> </span>
<a href="#l63.357"></a><span id="l63.357" class="difflineminus">-static void *bind_thread(char *id) {</span>
<a href="#l63.358"></a><span id="l63.358" class="difflineplus">+static void* bind_thread(char* id) {</span>
<a href="#l63.359"></a><span id="l63.359">   char dn[BUFSIZ], name[40];</span>
<a href="#l63.360"></a><span id="l63.360">   int rc, opcount;</span>
<a href="#l63.361"></a><span id="l63.361" class="difflineminus">-  void *voidrc = (void *)0;</span>
<a href="#l63.362"></a><span id="l63.362" class="difflineplus">+  void* voidrc = (void*)0;</span>
<a href="#l63.363"></a><span id="l63.363"> </span>
<a href="#l63.364"></a><span id="l63.364">   printf(&quot;Starting bind_thread %s.\n&quot;, id);</span>
<a href="#l63.365"></a><span id="l63.365">   opcount = 0;</span>
<a href="#l63.366"></a><span id="l63.366">   tsd_setup();</span>
<a href="#l63.367"></a><span id="l63.367"> </span>
<a href="#l63.368"></a><span id="l63.368">   for (;;) {</span>
<a href="#l63.369"></a><span id="l63.369">     sprintf(name, &quot;%d&quot;, get_random_id());</span>
<a href="#l63.370"></a><span id="l63.370">     sprintf(dn, &quot;cn=%s, &quot; BASE, name);</span>
<a href="#l63.371"></a><span id="l63.371">     printf(&quot;Thread %s: Binding as entry (%s)\n&quot;, id, dn);</span>
<a href="#l63.372"></a><span id="l63.372"> </span>
<a href="#l63.373"></a><span id="l63.373">     if ((rc = ldap_simple_bind_s(ld, dn, name)) != LDAP_SUCCESS) {</span>
<a href="#l63.374"></a><span id="l63.374">       ldap_perror(ld, &quot;ldap_simple_bind_s&quot;);</span>
<a href="#l63.375"></a><span id="l63.375">       if (rc == LDAP_SERVER_DOWN) {</span>
<a href="#l63.376"></a><span id="l63.376">         perror(&quot;ldap_simple_bind_s&quot;);</span>
<a href="#l63.377"></a><span id="l63.377" class="difflineminus">-        voidrc = (void *)1;</span>
<a href="#l63.378"></a><span id="l63.378" class="difflineplus">+        voidrc = (void*)1;</span>
<a href="#l63.379"></a><span id="l63.379">         goto bind_cleanup_and_return;</span>
<a href="#l63.380"></a><span id="l63.380">       }</span>
<a href="#l63.381"></a><span id="l63.381">     } else {</span>
<a href="#l63.382"></a><span id="l63.382">       printf(&quot;Thread %s: bound as entry (%s)\n&quot;, id, dn);</span>
<a href="#l63.383"></a><span id="l63.383">     }</span>
<a href="#l63.384"></a><span id="l63.384"> </span>
<a href="#l63.385"></a><span id="l63.385">     ++opcount;</span>
<a href="#l63.386"></a><span id="l63.386">     if (maxops != 0 &amp;&amp; opcount &gt;= maxops) {</span>
<a href="#l63.387"></a><span id="l63.387" class="difflineat">@@ -720,21 +720,21 @@ static void *bind_thread(char *id) {</span>
<a href="#l63.388"></a><span id="l63.388"> bind_cleanup_and_return:</span>
<a href="#l63.389"></a><span id="l63.389">   printf(&quot;Thread %s: attempted %d bind operations\n&quot;, id, opcount);</span>
<a href="#l63.390"></a><span id="l63.390">   set_ld_error(0, NULL, NULL, NULL); /* disposes of memory */</span>
<a href="#l63.391"></a><span id="l63.391">   tsd_cleanup();</span>
<a href="#l63.392"></a><span id="l63.392">   free(id);</span>
<a href="#l63.393"></a><span id="l63.393">   return voidrc;</span>
<a href="#l63.394"></a><span id="l63.394"> }</span>
<a href="#l63.395"></a><span id="l63.395"> </span>
<a href="#l63.396"></a><span id="l63.396" class="difflineminus">-static void *compare_thread(char *id) {</span>
<a href="#l63.397"></a><span id="l63.397" class="difflineplus">+static void* compare_thread(char* id) {</span>
<a href="#l63.398"></a><span id="l63.398">   char dn[BUFSIZ], name[40], cmpval[40];</span>
<a href="#l63.399"></a><span id="l63.399">   int rc, randval, opcount;</span>
<a href="#l63.400"></a><span id="l63.400">   struct berval bv;</span>
<a href="#l63.401"></a><span id="l63.401" class="difflineminus">-  void *voidrc = (void *)0;</span>
<a href="#l63.402"></a><span id="l63.402" class="difflineplus">+  void* voidrc = (void*)0;</span>
<a href="#l63.403"></a><span id="l63.403"> </span>
<a href="#l63.404"></a><span id="l63.404">   printf(&quot;Starting compare_thread %s.\n&quot;, id);</span>
<a href="#l63.405"></a><span id="l63.405">   opcount = 0;</span>
<a href="#l63.406"></a><span id="l63.406">   tsd_setup();</span>
<a href="#l63.407"></a><span id="l63.407"> </span>
<a href="#l63.408"></a><span id="l63.408">   for (;;) {</span>
<a href="#l63.409"></a><span id="l63.409">     randval = get_random_id();</span>
<a href="#l63.410"></a><span id="l63.410">     sprintf(name, &quot;%d&quot;, randval);</span>
<a href="#l63.411"></a><span id="l63.411" class="difflineat">@@ -752,17 +752,17 @@ static void *compare_thread(char *id) {</span>
<a href="#l63.412"></a><span id="l63.412">         break;</span>
<a href="#l63.413"></a><span id="l63.413">       case LDAP_COMPARE_FALSE:</span>
<a href="#l63.414"></a><span id="l63.414">         printf(&quot;Thread %s: entry (%s) doesn't contain cn %s\n&quot;, id, dn, cmpval);</span>
<a href="#l63.415"></a><span id="l63.415">         break;</span>
<a href="#l63.416"></a><span id="l63.416">       default:</span>
<a href="#l63.417"></a><span id="l63.417">         ldap_perror(ld, &quot;ldap_compare_ext_s&quot;);</span>
<a href="#l63.418"></a><span id="l63.418">         if (rc == LDAP_SERVER_DOWN) {</span>
<a href="#l63.419"></a><span id="l63.419">           perror(&quot;ldap_compare_ext_s&quot;);</span>
<a href="#l63.420"></a><span id="l63.420" class="difflineminus">-          voidrc = (void *)1;</span>
<a href="#l63.421"></a><span id="l63.421" class="difflineplus">+          voidrc = (void*)1;</span>
<a href="#l63.422"></a><span id="l63.422">           goto compare_cleanup_and_return;</span>
<a href="#l63.423"></a><span id="l63.423">         }</span>
<a href="#l63.424"></a><span id="l63.424">     }</span>
<a href="#l63.425"></a><span id="l63.425"> </span>
<a href="#l63.426"></a><span id="l63.426">     ++opcount;</span>
<a href="#l63.427"></a><span id="l63.427">     if (maxops != 0 &amp;&amp; opcount &gt;= maxops) {</span>
<a href="#l63.428"></a><span id="l63.428">       break;</span>
<a href="#l63.429"></a><span id="l63.429">     }</span>
<a href="#l63.430"></a><span id="l63.430" class="difflineat">@@ -771,21 +771,21 @@ static void *compare_thread(char *id) {</span>
<a href="#l63.431"></a><span id="l63.431"> compare_cleanup_and_return:</span>
<a href="#l63.432"></a><span id="l63.432">   printf(&quot;Thread %s: attempted %d compare operations\n&quot;, id, opcount);</span>
<a href="#l63.433"></a><span id="l63.433">   set_ld_error(0, NULL, NULL, NULL); /* disposes of memory */</span>
<a href="#l63.434"></a><span id="l63.434">   tsd_cleanup();</span>
<a href="#l63.435"></a><span id="l63.435">   free(id);</span>
<a href="#l63.436"></a><span id="l63.436">   return voidrc;</span>
<a href="#l63.437"></a><span id="l63.437"> }</span>
<a href="#l63.438"></a><span id="l63.438"> </span>
<a href="#l63.439"></a><span id="l63.439" class="difflineminus">-static void *search_thread(char *id) {</span>
<a href="#l63.440"></a><span id="l63.440" class="difflineplus">+static void* search_thread(char* id) {</span>
<a href="#l63.441"></a><span id="l63.441">   LDAPMessage *res, *entry;</span>
<a href="#l63.442"></a><span id="l63.442">   char *dn, filter[40];</span>
<a href="#l63.443"></a><span id="l63.443">   int rc, opcount;</span>
<a href="#l63.444"></a><span id="l63.444" class="difflineminus">-  void *voidrc = (void *)0;</span>
<a href="#l63.445"></a><span id="l63.445" class="difflineplus">+  void* voidrc = (void*)0;</span>
<a href="#l63.446"></a><span id="l63.446"> </span>
<a href="#l63.447"></a><span id="l63.447">   printf(&quot;Starting search_thread %s.\n&quot;, id);</span>
<a href="#l63.448"></a><span id="l63.448">   opcount = 0;</span>
<a href="#l63.449"></a><span id="l63.449">   tsd_setup();</span>
<a href="#l63.450"></a><span id="l63.450"> </span>
<a href="#l63.451"></a><span id="l63.451">   for (;;) {</span>
<a href="#l63.452"></a><span id="l63.452">     if (range_filters) {</span>
<a href="#l63.453"></a><span id="l63.453">       switch (get_random_id() % 3) {</span>
<a href="#l63.454"></a><span id="l63.454" class="difflineat">@@ -807,17 +807,17 @@ static void *search_thread(char *id) {</span>
<a href="#l63.455"></a><span id="l63.455">     printf(&quot;Thread %s: Searching for entry (%s)\n&quot;, id, filter);</span>
<a href="#l63.456"></a><span id="l63.456"> </span>
<a href="#l63.457"></a><span id="l63.457">     res = NULL;</span>
<a href="#l63.458"></a><span id="l63.458">     if ((rc = ldap_search_ext_s(ld, BASE, SCOPE, filter, NULL, 0, NULL, NULL,</span>
<a href="#l63.459"></a><span id="l63.459">                                 NULL, 0, &amp;res)) != LDAP_SUCCESS) {</span>
<a href="#l63.460"></a><span id="l63.460">       ldap_perror(ld, &quot;ldap_search_ext_s&quot;);</span>
<a href="#l63.461"></a><span id="l63.461">       if (rc == LDAP_SERVER_DOWN) {</span>
<a href="#l63.462"></a><span id="l63.462">         perror(&quot;ldap_search_ext_s&quot;);</span>
<a href="#l63.463"></a><span id="l63.463" class="difflineminus">-        voidrc = (void *)1;</span>
<a href="#l63.464"></a><span id="l63.464" class="difflineplus">+        voidrc = (void*)1;</span>
<a href="#l63.465"></a><span id="l63.465">         goto search_cleanup_and_return;</span>
<a href="#l63.466"></a><span id="l63.466">       }</span>
<a href="#l63.467"></a><span id="l63.467">     }</span>
<a href="#l63.468"></a><span id="l63.468">     if (res != NULL) {</span>
<a href="#l63.469"></a><span id="l63.469">       entry = ldap_first_entry(ld, res);</span>
<a href="#l63.470"></a><span id="l63.470">       if (entry == NULL) {</span>
<a href="#l63.471"></a><span id="l63.471">         printf(&quot;Thread %s: found no entries\n&quot;, id);</span>
<a href="#l63.472"></a><span id="l63.472">       } else {</span>
<a href="#l63.473"></a><span id="l63.473" class="difflineat">@@ -838,105 +838,105 @@ static void *search_thread(char *id) {</span>
<a href="#l63.474"></a><span id="l63.474"> search_cleanup_and_return:</span>
<a href="#l63.475"></a><span id="l63.475">   printf(&quot;Thread %s: attempted %d search operations\n&quot;, id, opcount);</span>
<a href="#l63.476"></a><span id="l63.476">   set_ld_error(0, NULL, NULL, NULL); /* disposes of memory */</span>
<a href="#l63.477"></a><span id="l63.477">   tsd_cleanup();</span>
<a href="#l63.478"></a><span id="l63.478">   free(id);</span>
<a href="#l63.479"></a><span id="l63.479">   return voidrc;</span>
<a href="#l63.480"></a><span id="l63.480"> }</span>
<a href="#l63.481"></a><span id="l63.481"> </span>
<a href="#l63.482"></a><span id="l63.482" class="difflineminus">-static void *my_mutex_alloc(void) {</span>
<a href="#l63.483"></a><span id="l63.483" class="difflineminus">-  pthread_mutex_t *mutexp;</span>
<a href="#l63.484"></a><span id="l63.484" class="difflineplus">+static void* my_mutex_alloc(void) {</span>
<a href="#l63.485"></a><span id="l63.485" class="difflineplus">+  pthread_mutex_t* mutexp;</span>
<a href="#l63.486"></a><span id="l63.486"> </span>
<a href="#l63.487"></a><span id="l63.487">   if ((mutexp = malloc(sizeof(pthread_mutex_t))) != NULL) {</span>
<a href="#l63.488"></a><span id="l63.488">     pthread_mutex_init(mutexp, NULL);</span>
<a href="#l63.489"></a><span id="l63.489">   }</span>
<a href="#l63.490"></a><span id="l63.490">   return (mutexp);</span>
<a href="#l63.491"></a><span id="l63.491"> }</span>
<a href="#l63.492"></a><span id="l63.492"> </span>
<a href="#l63.493"></a><span id="l63.493" class="difflineminus">-void *my_sema_alloc(void) {</span>
<a href="#l63.494"></a><span id="l63.494" class="difflineminus">-  sema_t *semptr;</span>
<a href="#l63.495"></a><span id="l63.495" class="difflineplus">+void* my_sema_alloc(void) {</span>
<a href="#l63.496"></a><span id="l63.496" class="difflineplus">+  sema_t* semptr;</span>
<a href="#l63.497"></a><span id="l63.497"> </span>
<a href="#l63.498"></a><span id="l63.498">   if ((semptr = malloc(sizeof(sema_t))) != NULL) {</span>
<a href="#l63.499"></a><span id="l63.499">     sema_init(semptr, 0, USYNC_THREAD, NULL);</span>
<a href="#l63.500"></a><span id="l63.500">   }</span>
<a href="#l63.501"></a><span id="l63.501">   return (semptr);</span>
<a href="#l63.502"></a><span id="l63.502"> }</span>
<a href="#l63.503"></a><span id="l63.503"> </span>
<a href="#l63.504"></a><span id="l63.504" class="difflineminus">-static void my_mutex_free(void *mutexp) {</span>
<a href="#l63.505"></a><span id="l63.505" class="difflineminus">-  pthread_mutex_destroy((pthread_mutex_t *)mutexp);</span>
<a href="#l63.506"></a><span id="l63.506" class="difflineplus">+static void my_mutex_free(void* mutexp) {</span>
<a href="#l63.507"></a><span id="l63.507" class="difflineplus">+  pthread_mutex_destroy((pthread_mutex_t*)mutexp);</span>
<a href="#l63.508"></a><span id="l63.508">   free(mutexp);</span>
<a href="#l63.509"></a><span id="l63.509"> }</span>
<a href="#l63.510"></a><span id="l63.510"> </span>
<a href="#l63.511"></a><span id="l63.511" class="difflineminus">-void my_sema_free(void *semptr) {</span>
<a href="#l63.512"></a><span id="l63.512" class="difflineminus">-  sema_destroy((sema_t *)semptr);</span>
<a href="#l63.513"></a><span id="l63.513" class="difflineplus">+void my_sema_free(void* semptr) {</span>
<a href="#l63.514"></a><span id="l63.514" class="difflineplus">+  sema_destroy((sema_t*)semptr);</span>
<a href="#l63.515"></a><span id="l63.515">   free(semptr);</span>
<a href="#l63.516"></a><span id="l63.516"> }</span>
<a href="#l63.517"></a><span id="l63.517"> </span>
<a href="#l63.518"></a><span id="l63.518" class="difflineminus">-int my_sema_wait(void *semptr) {</span>
<a href="#l63.519"></a><span id="l63.519" class="difflineplus">+int my_sema_wait(void* semptr) {</span>
<a href="#l63.520"></a><span id="l63.520">   if (semptr != NULL)</span>
<a href="#l63.521"></a><span id="l63.521" class="difflineminus">-    return (sema_wait((sema_t *)semptr));</span>
<a href="#l63.522"></a><span id="l63.522" class="difflineplus">+    return (sema_wait((sema_t*)semptr));</span>
<a href="#l63.523"></a><span id="l63.523">   else</span>
<a href="#l63.524"></a><span id="l63.524">     return (-1);</span>
<a href="#l63.525"></a><span id="l63.525"> }</span>
<a href="#l63.526"></a><span id="l63.526"> </span>
<a href="#l63.527"></a><span id="l63.527" class="difflineminus">-int my_sema_post(void *semptr) {</span>
<a href="#l63.528"></a><span id="l63.528" class="difflineplus">+int my_sema_post(void* semptr) {</span>
<a href="#l63.529"></a><span id="l63.529">   if (semptr != NULL)</span>
<a href="#l63.530"></a><span id="l63.530" class="difflineminus">-    return (sema_post((sema_t *)semptr));</span>
<a href="#l63.531"></a><span id="l63.531" class="difflineplus">+    return (sema_post((sema_t*)semptr));</span>
<a href="#l63.532"></a><span id="l63.532">   else</span>
<a href="#l63.533"></a><span id="l63.533">     return (-1);</span>
<a href="#l63.534"></a><span id="l63.534"> }</span>
<a href="#l63.535"></a><span id="l63.535"> </span>
<a href="#l63.536"></a><span id="l63.536"> struct ldap_error {</span>
<a href="#l63.537"></a><span id="l63.537">   int le_errno;</span>
<a href="#l63.538"></a><span id="l63.538" class="difflineminus">-  char *le_matched;</span>
<a href="#l63.539"></a><span id="l63.539" class="difflineminus">-  char *le_errmsg;</span>
<a href="#l63.540"></a><span id="l63.540" class="difflineplus">+  char* le_matched;</span>
<a href="#l63.541"></a><span id="l63.541" class="difflineplus">+  char* le_errmsg;</span>
<a href="#l63.542"></a><span id="l63.542"> };</span>
<a href="#l63.543"></a><span id="l63.543"> </span>
<a href="#l63.544"></a><span id="l63.544"> static void tsd_setup() {</span>
<a href="#l63.545"></a><span id="l63.545" class="difflineminus">-  void *tsd;</span>
<a href="#l63.546"></a><span id="l63.546" class="difflineplus">+  void* tsd;</span>
<a href="#l63.547"></a><span id="l63.547">   tsd = pthread_getspecific(key);</span>
<a href="#l63.548"></a><span id="l63.548">   if (tsd != NULL) {</span>
<a href="#l63.549"></a><span id="l63.549">     fprintf(stderr, &quot;tsd non-null!\n&quot;);</span>
<a href="#l63.550"></a><span id="l63.550">     pthread_exit(NULL);</span>
<a href="#l63.551"></a><span id="l63.551">   }</span>
<a href="#l63.552"></a><span id="l63.552"> </span>
<a href="#l63.553"></a><span id="l63.553" class="difflineminus">-  tsd = (void *)calloc(1, sizeof(struct ldap_error));</span>
<a href="#l63.554"></a><span id="l63.554" class="difflineplus">+  tsd = (void*)calloc(1, sizeof(struct ldap_error));</span>
<a href="#l63.555"></a><span id="l63.555">   pthread_setspecific(key, tsd);</span>
<a href="#l63.556"></a><span id="l63.556"> }</span>
<a href="#l63.557"></a><span id="l63.557"> </span>
<a href="#l63.558"></a><span id="l63.558"> static void tsd_cleanup() {</span>
<a href="#l63.559"></a><span id="l63.559" class="difflineminus">-  void *tsd;</span>
<a href="#l63.560"></a><span id="l63.560" class="difflineplus">+  void* tsd;</span>
<a href="#l63.561"></a><span id="l63.561"> </span>
<a href="#l63.562"></a><span id="l63.562">   if ((tsd = pthread_getspecific(key)) != NULL) {</span>
<a href="#l63.563"></a><span id="l63.563">     pthread_setspecific(key, NULL);</span>
<a href="#l63.564"></a><span id="l63.564">     free(tsd);</span>
<a href="#l63.565"></a><span id="l63.565">   }</span>
<a href="#l63.566"></a><span id="l63.566"> }</span>
<a href="#l63.567"></a><span id="l63.567"> </span>
<a href="#l63.568"></a><span id="l63.568" class="difflineminus">-static void set_ld_error(int err, char *matched, char *errmsg, void *dummy) {</span>
<a href="#l63.569"></a><span id="l63.569" class="difflineminus">-  struct ldap_error *le;</span>
<a href="#l63.570"></a><span id="l63.570" class="difflineplus">+static void set_ld_error(int err, char* matched, char* errmsg, void* dummy) {</span>
<a href="#l63.571"></a><span id="l63.571" class="difflineplus">+  struct ldap_error* le;</span>
<a href="#l63.572"></a><span id="l63.572"> </span>
<a href="#l63.573"></a><span id="l63.573">   le = pthread_getspecific(key);</span>
<a href="#l63.574"></a><span id="l63.574"> </span>
<a href="#l63.575"></a><span id="l63.575">   le-&gt;le_errno = err;</span>
<a href="#l63.576"></a><span id="l63.576"> </span>
<a href="#l63.577"></a><span id="l63.577">   if (le-&gt;le_matched != NULL) {</span>
<a href="#l63.578"></a><span id="l63.578">     ldap_memfree(le-&gt;le_matched);</span>
<a href="#l63.579"></a><span id="l63.579">   }</span>
<a href="#l63.580"></a><span id="l63.580">   le-&gt;le_matched = matched;</span>
<a href="#l63.581"></a><span id="l63.581"> </span>
<a href="#l63.582"></a><span id="l63.582">   if (le-&gt;le_errmsg != NULL) {</span>
<a href="#l63.583"></a><span id="l63.583">     ldap_memfree(le-&gt;le_errmsg);</span>
<a href="#l63.584"></a><span id="l63.584">   }</span>
<a href="#l63.585"></a><span id="l63.585">   le-&gt;le_errmsg = errmsg;</span>
<a href="#l63.586"></a><span id="l63.586"> }</span>
<a href="#l63.587"></a><span id="l63.587"> </span>
<a href="#l63.588"></a><span id="l63.588" class="difflineminus">-static int get_ld_error(char **matchedp, char **errmsgp, void *dummy) {</span>
<a href="#l63.589"></a><span id="l63.589" class="difflineminus">-  struct ldap_error *le;</span>
<a href="#l63.590"></a><span id="l63.590" class="difflineplus">+static int get_ld_error(char** matchedp, char** errmsgp, void* dummy) {</span>
<a href="#l63.591"></a><span id="l63.591" class="difflineplus">+  struct ldap_error* le;</span>
<a href="#l63.592"></a><span id="l63.592"> </span>
<a href="#l63.593"></a><span id="l63.593">   le = pthread_getspecific(key);</span>
<a href="#l63.594"></a><span id="l63.594">   if (matchedp != NULL) {</span>
<a href="#l63.595"></a><span id="l63.595">     *matchedp = le-&gt;le_matched;</span>
<a href="#l63.596"></a><span id="l63.596">   }</span>
<a href="#l63.597"></a><span id="l63.597">   if (errmsgp != NULL) {</span>
<a href="#l63.598"></a><span id="l63.598">     *errmsgp = le-&gt;le_errmsg;</span>
<a href="#l63.599"></a><span id="l63.599">   }</span>
<a href="#l63.600"></a><span id="l63.600" class="difflineat">@@ -944,14 +944,14 @@ static int get_ld_error(char **matchedp,</span>
<a href="#l63.601"></a><span id="l63.601"> }</span>
<a href="#l63.602"></a><span id="l63.602"> </span>
<a href="#l63.603"></a><span id="l63.603"> static void set_errno(int err) { errno = err; }</span>
<a href="#l63.604"></a><span id="l63.604"> </span>
<a href="#l63.605"></a><span id="l63.605"> static int get_errno(void) { return (errno); }</span>
<a href="#l63.606"></a><span id="l63.606"> </span>
<a href="#l63.607"></a><span id="l63.607"> static int get_random_id() { return (random() % maxid); }</span>
<a href="#l63.608"></a><span id="l63.608"> </span>
<a href="#l63.609"></a><span id="l63.609" class="difflineminus">-static char *get_id_str(int id) {</span>
<a href="#l63.610"></a><span id="l63.610" class="difflineplus">+static char* get_id_str(int id) {</span>
<a href="#l63.611"></a><span id="l63.611">   char idstr[10];</span>
<a href="#l63.612"></a><span id="l63.612"> </span>
<a href="#l63.613"></a><span id="l63.613">   sprintf(idstr, &quot;%d&quot;, id);</span>
<a href="#l63.614"></a><span id="l63.614">   return (strdup(idstr));</span>
<a href="#l63.615"></a><span id="l63.615"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l64.1"></a><span id="l64.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/pwmodext.c</span>
<a href="#l64.2"></a><span id="l64.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/pwmodext.c</span>
<a href="#l64.3"></a><span id="l64.3" class="difflineat">@@ -32,23 +32,23 @@</span>
<a href="#l64.4"></a><span id="l64.4">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l64.5"></a><span id="l64.5">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l64.6"></a><span id="l64.6">  *</span>
<a href="#l64.7"></a><span id="l64.7">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l64.8"></a><span id="l64.8"> </span>
<a href="#l64.9"></a><span id="l64.9"> #include &quot;ldap-int.h&quot;</span>
<a href="#l64.10"></a><span id="l64.10"> </span>
<a href="#l64.11"></a><span id="l64.11"> /* ldap_passwd */</span>
<a href="#l64.12"></a><span id="l64.12" class="difflineminus">-int LDAP_CALL ldap_passwd(LDAP *ld, struct berval *userid,</span>
<a href="#l64.13"></a><span id="l64.13" class="difflineminus">-                          struct berval *oldpasswd, struct berval *newpasswd,</span>
<a href="#l64.14"></a><span id="l64.14" class="difflineminus">-                          LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l64.15"></a><span id="l64.15" class="difflineminus">-                          int *msgidp) {</span>
<a href="#l64.16"></a><span id="l64.16" class="difflineplus">+int LDAP_CALL ldap_passwd(LDAP* ld, struct berval* userid,</span>
<a href="#l64.17"></a><span id="l64.17" class="difflineplus">+                          struct berval* oldpasswd, struct berval* newpasswd,</span>
<a href="#l64.18"></a><span id="l64.18" class="difflineplus">+                          LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l64.19"></a><span id="l64.19" class="difflineplus">+                          int* msgidp) {</span>
<a href="#l64.20"></a><span id="l64.20">   int rc;</span>
<a href="#l64.21"></a><span id="l64.21" class="difflineminus">-  BerElement *ber = NULL;</span>
<a href="#l64.22"></a><span id="l64.22" class="difflineminus">-  struct berval *requestdata = NULL;</span>
<a href="#l64.23"></a><span id="l64.23" class="difflineplus">+  BerElement* ber = NULL;</span>
<a href="#l64.24"></a><span id="l64.24" class="difflineplus">+  struct berval* requestdata = NULL;</span>
<a href="#l64.25"></a><span id="l64.25"> </span>
<a href="#l64.26"></a><span id="l64.26">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l64.27"></a><span id="l64.27">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l64.28"></a><span id="l64.28">     return (LDAP_PARAM_ERROR);</span>
<a href="#l64.29"></a><span id="l64.29">   }</span>
<a href="#l64.30"></a><span id="l64.30"> </span>
<a href="#l64.31"></a><span id="l64.31">   requestdata = NSLDAPI_MALLOC(sizeof(struct berval));</span>
<a href="#l64.32"></a><span id="l64.32">   if (requestdata == NULL) {</span>
<a href="#l64.33"></a><span id="l64.33" class="difflineat">@@ -133,22 +133,22 @@ int LDAP_CALL ldap_passwd(LDAP *ld, stru</span>
<a href="#l64.34"></a><span id="l64.34">     ber_free(ber, 1);</span>
<a href="#l64.35"></a><span id="l64.35">   }</span>
<a href="#l64.36"></a><span id="l64.36"> </span>
<a href="#l64.37"></a><span id="l64.37">   LDAP_SET_LDERRNO(ld, rc, NULL, NULL);</span>
<a href="#l64.38"></a><span id="l64.38">   return (rc);</span>
<a href="#l64.39"></a><span id="l64.39"> }</span>
<a href="#l64.40"></a><span id="l64.40"> </span>
<a href="#l64.41"></a><span id="l64.41"> /* ldap_parse_passwd */</span>
<a href="#l64.42"></a><span id="l64.42" class="difflineminus">-int LDAP_CALL ldap_parse_passwd(LDAP *ld, LDAPMessage *result,</span>
<a href="#l64.43"></a><span id="l64.43" class="difflineminus">-                                struct berval *genpasswd) {</span>
<a href="#l64.44"></a><span id="l64.44" class="difflineplus">+int LDAP_CALL ldap_parse_passwd(LDAP* ld, LDAPMessage* result,</span>
<a href="#l64.45"></a><span id="l64.45" class="difflineplus">+                                struct berval* genpasswd) {</span>
<a href="#l64.46"></a><span id="l64.46">   int rc;</span>
<a href="#l64.47"></a><span id="l64.47" class="difflineminus">-  char *retoidp = NULL;</span>
<a href="#l64.48"></a><span id="l64.48" class="difflineminus">-  struct berval *retdatap = NULL;</span>
<a href="#l64.49"></a><span id="l64.49" class="difflineminus">-  BerElement *ber = NULL;</span>
<a href="#l64.50"></a><span id="l64.50" class="difflineplus">+  char* retoidp = NULL;</span>
<a href="#l64.51"></a><span id="l64.51" class="difflineplus">+  struct berval* retdatap = NULL;</span>
<a href="#l64.52"></a><span id="l64.52" class="difflineplus">+  BerElement* ber = NULL;</span>
<a href="#l64.53"></a><span id="l64.53">   ber_len_t len;</span>
<a href="#l64.54"></a><span id="l64.54">   ber_tag_t tag;</span>
<a href="#l64.55"></a><span id="l64.55"> </span>
<a href="#l64.56"></a><span id="l64.56">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l64.57"></a><span id="l64.57">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l64.58"></a><span id="l64.58">     return (LDAP_PARAM_ERROR);</span>
<a href="#l64.59"></a><span id="l64.59">   }</span>
<a href="#l64.60"></a><span id="l64.60"> </span>
<a href="#l64.61"></a><span id="l64.61" class="difflineat">@@ -207,22 +207,22 @@ int LDAP_CALL ldap_parse_passwd(LDAP *ld</span>
<a href="#l64.62"></a><span id="l64.62">     ber_free(ber, 1);</span>
<a href="#l64.63"></a><span id="l64.63">   }</span>
<a href="#l64.64"></a><span id="l64.64"> </span>
<a href="#l64.65"></a><span id="l64.65">   ldap_memfree(retoidp);</span>
<a href="#l64.66"></a><span id="l64.66">   return (LDAP_SUCCESS);</span>
<a href="#l64.67"></a><span id="l64.67"> }</span>
<a href="#l64.68"></a><span id="l64.68"> </span>
<a href="#l64.69"></a><span id="l64.69"> /* ldap_passwd_s */</span>
<a href="#l64.70"></a><span id="l64.70" class="difflineminus">-int LDAP_CALL ldap_passwd_s(LDAP *ld, struct berval *userid,</span>
<a href="#l64.71"></a><span id="l64.71" class="difflineminus">-                            struct berval *oldpasswd, struct berval *newpasswd,</span>
<a href="#l64.72"></a><span id="l64.72" class="difflineminus">-                            struct berval *genpasswd, LDAPControl **serverctrls,</span>
<a href="#l64.73"></a><span id="l64.73" class="difflineminus">-                            LDAPControl **clientctrls) {</span>
<a href="#l64.74"></a><span id="l64.74" class="difflineplus">+int LDAP_CALL ldap_passwd_s(LDAP* ld, struct berval* userid,</span>
<a href="#l64.75"></a><span id="l64.75" class="difflineplus">+                            struct berval* oldpasswd, struct berval* newpasswd,</span>
<a href="#l64.76"></a><span id="l64.76" class="difflineplus">+                            struct berval* genpasswd, LDAPControl** serverctrls,</span>
<a href="#l64.77"></a><span id="l64.77" class="difflineplus">+                            LDAPControl** clientctrls) {</span>
<a href="#l64.78"></a><span id="l64.78">   int rc, msgid;</span>
<a href="#l64.79"></a><span id="l64.79" class="difflineminus">-  LDAPMessage *result = NULL;</span>
<a href="#l64.80"></a><span id="l64.80" class="difflineplus">+  LDAPMessage* result = NULL;</span>
<a href="#l64.81"></a><span id="l64.81"> </span>
<a href="#l64.82"></a><span id="l64.82">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l64.83"></a><span id="l64.83">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l64.84"></a><span id="l64.84">     return (LDAP_PARAM_ERROR);</span>
<a href="#l64.85"></a><span id="l64.85">   }</span>
<a href="#l64.86"></a><span id="l64.86"> </span>
<a href="#l64.87"></a><span id="l64.87">   rc = ldap_passwd(ld, userid, oldpasswd, newpasswd, serverctrls, clientctrls,</span>
<a href="#l64.88"></a><span id="l64.88">                    &amp;msgid);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l65.1"></a><span id="l65.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/pwpctrl.c</span>
<a href="#l65.2"></a><span id="l65.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/pwpctrl.c</span>
<a href="#l65.3"></a><span id="l65.3" class="difflineat">@@ -40,18 +40,18 @@</span>
<a href="#l65.4"></a><span id="l65.4"> </span>
<a href="#l65.5"></a><span id="l65.5"> Parameters are</span>
<a href="#l65.6"></a><span id="l65.6"> </span>
<a href="#l65.7"></a><span id="l65.7"> ld              LDAP pointer to the desired connection</span>
<a href="#l65.8"></a><span id="l65.8"> </span>
<a href="#l65.9"></a><span id="l65.9"> ctrlp           the address of a place to put the constructed control</span>
<a href="#l65.10"></a><span id="l65.10"> */</span>
<a href="#l65.11"></a><span id="l65.11"> </span>
<a href="#l65.12"></a><span id="l65.12" class="difflineminus">-int LDAP_CALL ldap_create_passwordpolicy_control(LDAP *ld,</span>
<a href="#l65.13"></a><span id="l65.13" class="difflineminus">-                                                 LDAPControl **ctrlp) {</span>
<a href="#l65.14"></a><span id="l65.14" class="difflineplus">+int LDAP_CALL ldap_create_passwordpolicy_control(LDAP* ld,</span>
<a href="#l65.15"></a><span id="l65.15" class="difflineplus">+                                                 LDAPControl** ctrlp) {</span>
<a href="#l65.16"></a><span id="l65.16">   int rc;</span>
<a href="#l65.17"></a><span id="l65.17"> </span>
<a href="#l65.18"></a><span id="l65.18">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l65.19"></a><span id="l65.19">     return (LDAP_PARAM_ERROR);</span>
<a href="#l65.20"></a><span id="l65.20">   }</span>
<a href="#l65.21"></a><span id="l65.21"> </span>
<a href="#l65.22"></a><span id="l65.22">   if (ctrlp == NULL) {</span>
<a href="#l65.23"></a><span id="l65.23">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l65.24"></a><span id="l65.24" class="difflineat">@@ -73,19 +73,19 @@ ld              LDAP pointer to the desi</span>
<a href="#l65.25"></a><span id="l65.25"> ctl_iscritical  Indicates whether the control is critical of not. If</span>
<a href="#l65.26"></a><span id="l65.26">                 this field is non-zero, the operation will only be car-</span>
<a href="#l65.27"></a><span id="l65.27">                 ried out if the control is recognized by the server</span>
<a href="#l65.28"></a><span id="l65.28">                 and/or client</span>
<a href="#l65.29"></a><span id="l65.29"> </span>
<a href="#l65.30"></a><span id="l65.30"> ctrlp           the address of a place to put the constructed control</span>
<a href="#l65.31"></a><span id="l65.31"> */</span>
<a href="#l65.32"></a><span id="l65.32"> </span>
<a href="#l65.33"></a><span id="l65.33" class="difflineminus">-int LDAP_CALL ldap_create_passwordpolicy_control_ext(LDAP *ld,</span>
<a href="#l65.34"></a><span id="l65.34" class="difflineplus">+int LDAP_CALL ldap_create_passwordpolicy_control_ext(LDAP* ld,</span>
<a href="#l65.35"></a><span id="l65.35">                                                      const char ctl_iscritical,</span>
<a href="#l65.36"></a><span id="l65.36" class="difflineminus">-                                                     LDAPControl **ctrlp) {</span>
<a href="#l65.37"></a><span id="l65.37" class="difflineplus">+                                                     LDAPControl** ctrlp) {</span>
<a href="#l65.38"></a><span id="l65.38">   int rc;</span>
<a href="#l65.39"></a><span id="l65.39"> </span>
<a href="#l65.40"></a><span id="l65.40">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l65.41"></a><span id="l65.41">     return (LDAP_PARAM_ERROR);</span>
<a href="#l65.42"></a><span id="l65.42">   }</span>
<a href="#l65.43"></a><span id="l65.43"> </span>
<a href="#l65.44"></a><span id="l65.44">   if (ctrlp == NULL) {</span>
<a href="#l65.45"></a><span id="l65.45">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l65.46"></a><span id="l65.46" class="difflineat">@@ -114,25 +114,25 @@ exptimep        result parameter is fill</span>
<a href="#l65.47"></a><span id="l65.47"> gracep          result parameter is filled in with the number of grace logins</span>
<a href="#l65.48"></a><span id="l65.48">                 after the password has expired.</span>
<a href="#l65.49"></a><span id="l65.49"> </span>
<a href="#l65.50"></a><span id="l65.50"> errorcodep      result parameter is filled in with the error code of the</span>
<a href="#l65.51"></a><span id="l65.51">                 password operation.</span>
<a href="#l65.52"></a><span id="l65.52"> */</span>
<a href="#l65.53"></a><span id="l65.53"> </span>
<a href="#l65.54"></a><span id="l65.54"> int LDAP_CALL ldap_parse_passwordpolicy_control(</span>
<a href="#l65.55"></a><span id="l65.55" class="difflineminus">-    LDAP *ld, LDAPControl *ctrlp, ber_int_t *expirep, ber_int_t *gracep,</span>
<a href="#l65.56"></a><span id="l65.56" class="difflineminus">-    LDAPPasswordPolicyError *errorp) {</span>
<a href="#l65.57"></a><span id="l65.57" class="difflineplus">+    LDAP* ld, LDAPControl* ctrlp, ber_int_t* expirep, ber_int_t* gracep,</span>
<a href="#l65.58"></a><span id="l65.58" class="difflineplus">+    LDAPPasswordPolicyError* errorp) {</span>
<a href="#l65.59"></a><span id="l65.59">   ber_len_t len;</span>
<a href="#l65.60"></a><span id="l65.60">   ber_tag_t tag;</span>
<a href="#l65.61"></a><span id="l65.61">   ber_int_t pp_exp = -1;</span>
<a href="#l65.62"></a><span id="l65.62">   ber_int_t pp_grace = -1;</span>
<a href="#l65.63"></a><span id="l65.63">   ber_int_t pp_warning = -1;</span>
<a href="#l65.64"></a><span id="l65.64">   ber_int_t pp_err = PP_noError;</span>
<a href="#l65.65"></a><span id="l65.65" class="difflineminus">-  BerElement *ber = NULL;</span>
<a href="#l65.66"></a><span id="l65.66" class="difflineplus">+  BerElement* ber = NULL;</span>
<a href="#l65.67"></a><span id="l65.67"> </span>
<a href="#l65.68"></a><span id="l65.68">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l65.69"></a><span id="l65.69">     return (LDAP_PARAM_ERROR);</span>
<a href="#l65.70"></a><span id="l65.70">   }</span>
<a href="#l65.71"></a><span id="l65.71"> </span>
<a href="#l65.72"></a><span id="l65.72">   if (ctrlp == NULL) {</span>
<a href="#l65.73"></a><span id="l65.73">     LDAP_SET_LDERRNO(ld, LDAP_CONTROL_NOT_FOUND, NULL, NULL);</span>
<a href="#l65.74"></a><span id="l65.74">     return (LDAP_CONTROL_NOT_FOUND);</span>
<a href="#l65.75"></a><span id="l65.75" class="difflineat">@@ -224,20 +224,20 @@ exptimep        result parameter is fill</span>
<a href="#l65.76"></a><span id="l65.76"> gracep          result parameter is filled in with the number of grace logins</span>
<a href="#l65.77"></a><span id="l65.77">                 after the password has expired.</span>
<a href="#l65.78"></a><span id="l65.78"> </span>
<a href="#l65.79"></a><span id="l65.79"> errorcodep      result parameter is filled in with the error code of the</span>
<a href="#l65.80"></a><span id="l65.80">                 password operation.</span>
<a href="#l65.81"></a><span id="l65.81"> */</span>
<a href="#l65.82"></a><span id="l65.82"> </span>
<a href="#l65.83"></a><span id="l65.83"> int LDAP_CALL ldap_parse_passwordpolicy_control_ext(</span>
<a href="#l65.84"></a><span id="l65.84" class="difflineminus">-    LDAP *ld, LDAPControl **ctrlp, ber_int_t *expirep, ber_int_t *gracep,</span>
<a href="#l65.85"></a><span id="l65.85" class="difflineminus">-    LDAPPasswordPolicyError *errorp) {</span>
<a href="#l65.86"></a><span id="l65.86" class="difflineplus">+    LDAP* ld, LDAPControl** ctrlp, ber_int_t* expirep, ber_int_t* gracep,</span>
<a href="#l65.87"></a><span id="l65.87" class="difflineplus">+    LDAPPasswordPolicyError* errorp) {</span>
<a href="#l65.88"></a><span id="l65.88">   int i, foundPPControl;</span>
<a href="#l65.89"></a><span id="l65.89" class="difflineminus">-  LDAPControl *PPCtrlp = NULL;</span>
<a href="#l65.90"></a><span id="l65.90" class="difflineplus">+  LDAPControl* PPCtrlp = NULL;</span>
<a href="#l65.91"></a><span id="l65.91"> </span>
<a href="#l65.92"></a><span id="l65.92">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l65.93"></a><span id="l65.93">     return (LDAP_PARAM_ERROR);</span>
<a href="#l65.94"></a><span id="l65.94">   }</span>
<a href="#l65.95"></a><span id="l65.95"> </span>
<a href="#l65.96"></a><span id="l65.96">   /* find the control in the list of controls if it exists */</span>
<a href="#l65.97"></a><span id="l65.97">   if (ctrlp == NULL) {</span>
<a href="#l65.98"></a><span id="l65.98">     LDAP_SET_LDERRNO(ld, LDAP_CONTROL_NOT_FOUND, NULL, NULL);</span>
<a href="#l65.99"></a><span id="l65.99" class="difflineat">@@ -254,17 +254,17 @@ int LDAP_CALL ldap_parse_passwordpolicy_</span>
<a href="#l65.100"></a><span id="l65.100">     /* let local var point to the control */</span>
<a href="#l65.101"></a><span id="l65.101">     PPCtrlp = ctrlp[i - 1];</span>
<a href="#l65.102"></a><span id="l65.102">   }</span>
<a href="#l65.103"></a><span id="l65.103"> </span>
<a href="#l65.104"></a><span id="l65.104">   return (</span>
<a href="#l65.105"></a><span id="l65.105">       ldap_parse_passwordpolicy_control(ld, PPCtrlp, expirep, gracep, errorp));</span>
<a href="#l65.106"></a><span id="l65.106"> }</span>
<a href="#l65.107"></a><span id="l65.107"> </span>
<a href="#l65.108"></a><span id="l65.108" class="difflineminus">-const char *LDAP_CALL ldap_passwordpolicy_err2txt(LDAPPasswordPolicyError err) {</span>
<a href="#l65.109"></a><span id="l65.109" class="difflineplus">+const char* LDAP_CALL ldap_passwordpolicy_err2txt(LDAPPasswordPolicyError err) {</span>
<a href="#l65.110"></a><span id="l65.110">   switch (err) {</span>
<a href="#l65.111"></a><span id="l65.111">     case PP_passwordExpired:</span>
<a href="#l65.112"></a><span id="l65.112">       return &quot;Password expired&quot;;</span>
<a href="#l65.113"></a><span id="l65.113">     case PP_accountLocked:</span>
<a href="#l65.114"></a><span id="l65.114">       return &quot;Account locked&quot;;</span>
<a href="#l65.115"></a><span id="l65.115">     case PP_changeAfterReset:</span>
<a href="#l65.116"></a><span id="l65.116">       return &quot;Password must be changed&quot;;</span>
<a href="#l65.117"></a><span id="l65.117">     case PP_passwordModNotAllowed:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l66.1"></a><span id="l66.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/referral.c</span>
<a href="#l66.2"></a><span id="l66.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/referral.c</span>
<a href="#l66.3"></a><span id="l66.3" class="difflineat">@@ -35,43 +35,43 @@</span>
<a href="#l66.4"></a><span id="l66.4">  *</span>
<a href="#l66.5"></a><span id="l66.5">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l66.6"></a><span id="l66.6"> /*</span>
<a href="#l66.7"></a><span id="l66.7">  *  referral.c - routines for handling LDAPv3 referrals and references.</span>
<a href="#l66.8"></a><span id="l66.8">  */</span>
<a href="#l66.9"></a><span id="l66.9"> </span>
<a href="#l66.10"></a><span id="l66.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l66.11"></a><span id="l66.11"> </span>
<a href="#l66.12"></a><span id="l66.12" class="difflineminus">-LDAPMessage *LDAP_CALL ldap_first_reference(LDAP *ld, LDAPMessage *res) {</span>
<a href="#l66.13"></a><span id="l66.13" class="difflineplus">+LDAPMessage* LDAP_CALL ldap_first_reference(LDAP* ld, LDAPMessage* res) {</span>
<a href="#l66.14"></a><span id="l66.14">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || res == NULLMSG) {</span>
<a href="#l66.15"></a><span id="l66.15">     return (NULLMSG);</span>
<a href="#l66.16"></a><span id="l66.16">   }</span>
<a href="#l66.17"></a><span id="l66.17"> </span>
<a href="#l66.18"></a><span id="l66.18">   if (res-&gt;lm_msgtype == LDAP_RES_SEARCH_REFERENCE) {</span>
<a href="#l66.19"></a><span id="l66.19">     return (res);</span>
<a href="#l66.20"></a><span id="l66.20">   }</span>
<a href="#l66.21"></a><span id="l66.21"> </span>
<a href="#l66.22"></a><span id="l66.22">   return (ldap_next_reference(ld, res));</span>
<a href="#l66.23"></a><span id="l66.23"> }</span>
<a href="#l66.24"></a><span id="l66.24"> </span>
<a href="#l66.25"></a><span id="l66.25" class="difflineminus">-LDAPMessage *LDAP_CALL ldap_next_reference(LDAP *ld, LDAPMessage *ref) {</span>
<a href="#l66.26"></a><span id="l66.26" class="difflineplus">+LDAPMessage* LDAP_CALL ldap_next_reference(LDAP* ld, LDAPMessage* ref) {</span>
<a href="#l66.27"></a><span id="l66.27">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || ref == NULLMSG) {</span>
<a href="#l66.28"></a><span id="l66.28">     return (NULLMSG); /* punt */</span>
<a href="#l66.29"></a><span id="l66.29">   }</span>
<a href="#l66.30"></a><span id="l66.30"> </span>
<a href="#l66.31"></a><span id="l66.31">   for (ref = ref-&gt;lm_chain; ref != NULLMSG; ref = ref-&gt;lm_chain) {</span>
<a href="#l66.32"></a><span id="l66.32">     if (ref-&gt;lm_msgtype == LDAP_RES_SEARCH_REFERENCE) {</span>
<a href="#l66.33"></a><span id="l66.33">       return (ref);</span>
<a href="#l66.34"></a><span id="l66.34">     }</span>
<a href="#l66.35"></a><span id="l66.35">   }</span>
<a href="#l66.36"></a><span id="l66.36"> </span>
<a href="#l66.37"></a><span id="l66.37">   return (NULLMSG);</span>
<a href="#l66.38"></a><span id="l66.38"> }</span>
<a href="#l66.39"></a><span id="l66.39"> </span>
<a href="#l66.40"></a><span id="l66.40" class="difflineminus">-int LDAP_CALL ldap_count_references(LDAP *ld, LDAPMessage *res) {</span>
<a href="#l66.41"></a><span id="l66.41" class="difflineplus">+int LDAP_CALL ldap_count_references(LDAP* ld, LDAPMessage* res) {</span>
<a href="#l66.42"></a><span id="l66.42">   int i;</span>
<a href="#l66.43"></a><span id="l66.43"> </span>
<a href="#l66.44"></a><span id="l66.44">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l66.45"></a><span id="l66.45">     return (-1);</span>
<a href="#l66.46"></a><span id="l66.46">   }</span>
<a href="#l66.47"></a><span id="l66.47"> </span>
<a href="#l66.48"></a><span id="l66.48">   for (i = 0; res != NULL; res = res-&gt;lm_chain) {</span>
<a href="#l66.49"></a><span id="l66.49">     if (res-&gt;lm_msgtype == LDAP_RES_SEARCH_REFERENCE) {</span>
<a href="#l66.50"></a><span id="l66.50" class="difflineat">@@ -80,19 +80,19 @@ int LDAP_CALL ldap_count_references(LDAP</span>
<a href="#l66.51"></a><span id="l66.51">   }</span>
<a href="#l66.52"></a><span id="l66.52"> </span>
<a href="#l66.53"></a><span id="l66.53">   return (i);</span>
<a href="#l66.54"></a><span id="l66.54"> }</span>
<a href="#l66.55"></a><span id="l66.55"> </span>
<a href="#l66.56"></a><span id="l66.56"> /*</span>
<a href="#l66.57"></a><span id="l66.57">  * returns an LDAP error code.</span>
<a href="#l66.58"></a><span id="l66.58">  */</span>
<a href="#l66.59"></a><span id="l66.59" class="difflineminus">-int LDAP_CALL ldap_parse_reference(LDAP *ld, LDAPMessage *ref,</span>
<a href="#l66.60"></a><span id="l66.60" class="difflineminus">-                                   char ***referralsp,</span>
<a href="#l66.61"></a><span id="l66.61" class="difflineminus">-                                   LDAPControl ***serverctrlsp, int freeit) {</span>
<a href="#l66.62"></a><span id="l66.62" class="difflineplus">+int LDAP_CALL ldap_parse_reference(LDAP* ld, LDAPMessage* ref,</span>
<a href="#l66.63"></a><span id="l66.63" class="difflineplus">+                                   char*** referralsp,</span>
<a href="#l66.64"></a><span id="l66.64" class="difflineplus">+                                   LDAPControl*** serverctrlsp, int freeit) {</span>
<a href="#l66.65"></a><span id="l66.65">   int err;</span>
<a href="#l66.66"></a><span id="l66.66"> </span>
<a href="#l66.67"></a><span id="l66.67">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) ||</span>
<a href="#l66.68"></a><span id="l66.68">       !NSLDAPI_VALID_LDAPMESSAGE_REFERENCE_POINTER(ref)) {</span>
<a href="#l66.69"></a><span id="l66.69">     return (LDAP_PARAM_ERROR);</span>
<a href="#l66.70"></a><span id="l66.70">   }</span>
<a href="#l66.71"></a><span id="l66.71"> </span>
<a href="#l66.72"></a><span id="l66.72">   err = nsldapi_parse_reference(ld, ref-&gt;lm_ber, referralsp, serverctrlsp);</span>
<a href="#l66.73"></a><span id="l66.73" class="difflineat">@@ -105,21 +105,21 @@ int LDAP_CALL ldap_parse_reference(LDAP </span>
<a href="#l66.74"></a><span id="l66.74"> </span>
<a href="#l66.75"></a><span id="l66.75">   return (err);</span>
<a href="#l66.76"></a><span id="l66.76"> }</span>
<a href="#l66.77"></a><span id="l66.77"> </span>
<a href="#l66.78"></a><span id="l66.78"> /*</span>
<a href="#l66.79"></a><span id="l66.79">  * returns an LDAP error code indicating success or failure of parsing</span>
<a href="#l66.80"></a><span id="l66.80">  * does NOT set any error information inside &quot;ld&quot;</span>
<a href="#l66.81"></a><span id="l66.81">  */</span>
<a href="#l66.82"></a><span id="l66.82" class="difflineminus">-int nsldapi_parse_reference(LDAP *ld, BerElement *rber, char ***referralsp,</span>
<a href="#l66.83"></a><span id="l66.83" class="difflineminus">-                            LDAPControl ***serverctrlsp) {</span>
<a href="#l66.84"></a><span id="l66.84" class="difflineplus">+int nsldapi_parse_reference(LDAP* ld, BerElement* rber, char*** referralsp,</span>
<a href="#l66.85"></a><span id="l66.85" class="difflineplus">+                            LDAPControl*** serverctrlsp) {</span>
<a href="#l66.86"></a><span id="l66.86">   int err;</span>
<a href="#l66.87"></a><span id="l66.87">   BerElement ber;</span>
<a href="#l66.88"></a><span id="l66.88" class="difflineminus">-  char **refs;</span>
<a href="#l66.89"></a><span id="l66.89" class="difflineplus">+  char** refs;</span>
<a href="#l66.90"></a><span id="l66.90"> </span>
<a href="#l66.91"></a><span id="l66.91">   /*</span>
<a href="#l66.92"></a><span id="l66.92">    * Parse a searchResultReference message.  These are used in LDAPv3</span>
<a href="#l66.93"></a><span id="l66.93">    * and beyond and look like this:</span>
<a href="#l66.94"></a><span id="l66.94">    *</span>
<a href="#l66.95"></a><span id="l66.95">    * SearchResultReference ::= [APPLICATION 19] SEQUENCE OF LDAPURL</span>
<a href="#l66.96"></a><span id="l66.96">    *</span>
<a href="#l66.97"></a><span id="l66.97">    * all wrapped up in an LDAPMessage sequence which looks like this:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l67.1"></a><span id="l67.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/regex.c</span>
<a href="#l67.2"></a><span id="l67.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/regex.c</span>
<a href="#l67.3"></a><span id="l67.3" class="difflineat">@@ -259,21 +259,21 @@ static REGEXCHAR bitarr[] = {1, 2, 4, 8,</span>
<a href="#l67.4"></a><span id="l67.4"> </span>
<a href="#l67.5"></a><span id="l67.5"> static void chset(REGEXCHAR c) {</span>
<a href="#l67.6"></a><span id="l67.6">   bittab[((c) &amp; (unsigned)BLKIND) &gt;&gt; 3] |= bitarr[(c)&amp;BITIND];</span>
<a href="#l67.7"></a><span id="l67.7"> }</span>
<a href="#l67.8"></a><span id="l67.8"> </span>
<a href="#l67.9"></a><span id="l67.9"> #  define badpat(x) (*nfa = END, x)</span>
<a href="#l67.10"></a><span id="l67.10"> #  define store(x) *mp++ = x</span>
<a href="#l67.11"></a><span id="l67.11"> </span>
<a href="#l67.12"></a><span id="l67.12" class="difflineminus">-char *LDAP_CALL re_comp(const char *pat) {</span>
<a href="#l67.13"></a><span id="l67.13" class="difflineminus">-  register REGEXCHAR *p;        /* pattern pointer   */</span>
<a href="#l67.14"></a><span id="l67.14" class="difflineminus">-  register REGEXCHAR *mp = nfa; /* nfa pointer       */</span>
<a href="#l67.15"></a><span id="l67.15" class="difflineminus">-  register REGEXCHAR *lp;       /* saved pointer..   */</span>
<a href="#l67.16"></a><span id="l67.16" class="difflineminus">-  register REGEXCHAR *sp = nfa; /* another one..     */</span>
<a href="#l67.17"></a><span id="l67.17" class="difflineplus">+char* LDAP_CALL re_comp(const char* pat) {</span>
<a href="#l67.18"></a><span id="l67.18" class="difflineplus">+  register REGEXCHAR* p;        /* pattern pointer   */</span>
<a href="#l67.19"></a><span id="l67.19" class="difflineplus">+  register REGEXCHAR* mp = nfa; /* nfa pointer       */</span>
<a href="#l67.20"></a><span id="l67.20" class="difflineplus">+  register REGEXCHAR* lp;       /* saved pointer..   */</span>
<a href="#l67.21"></a><span id="l67.21" class="difflineplus">+  register REGEXCHAR* sp = nfa; /* another one..     */</span>
<a href="#l67.22"></a><span id="l67.22"> </span>
<a href="#l67.23"></a><span id="l67.23">   register int tagi = 0; /* tag stack index   */</span>
<a href="#l67.24"></a><span id="l67.24">   register int tagc = 1; /* actual tag count  */</span>
<a href="#l67.25"></a><span id="l67.25"> </span>
<a href="#l67.26"></a><span id="l67.26">   register int n;</span>
<a href="#l67.27"></a><span id="l67.27">   register REGEXCHAR mask; /* xor mask -CCL/NCL */</span>
<a href="#l67.28"></a><span id="l67.28">   int c1, c2;</span>
<a href="#l67.29"></a><span id="l67.29"> </span>
<a href="#l67.30"></a><span id="l67.30" class="difflineat">@@ -281,25 +281,25 @@ char *LDAP_CALL re_comp(const char *pat)</span>
<a href="#l67.31"></a><span id="l67.31">     if (sta) {</span>
<a href="#l67.32"></a><span id="l67.32">       return 0;</span>
<a href="#l67.33"></a><span id="l67.33">     } else {</span>
<a href="#l67.34"></a><span id="l67.34">       return badpat(&quot;No previous regular expression&quot;);</span>
<a href="#l67.35"></a><span id="l67.35">     }</span>
<a href="#l67.36"></a><span id="l67.36">   }</span>
<a href="#l67.37"></a><span id="l67.37">   sta = NOP;</span>
<a href="#l67.38"></a><span id="l67.38"> </span>
<a href="#l67.39"></a><span id="l67.39" class="difflineminus">-  for (p = (REGEXCHAR *)pat; *p; p++) {</span>
<a href="#l67.40"></a><span id="l67.40" class="difflineplus">+  for (p = (REGEXCHAR*)pat; *p; p++) {</span>
<a href="#l67.41"></a><span id="l67.41">     lp = mp;</span>
<a href="#l67.42"></a><span id="l67.42">     switch (*p) {</span>
<a href="#l67.43"></a><span id="l67.43">       case '.': /* match any char..  */</span>
<a href="#l67.44"></a><span id="l67.44">         store(ANY);</span>
<a href="#l67.45"></a><span id="l67.45">         break;</span>
<a href="#l67.46"></a><span id="l67.46"> </span>
<a href="#l67.47"></a><span id="l67.47">       case '^': /* match beginning.. */</span>
<a href="#l67.48"></a><span id="l67.48" class="difflineminus">-        if (p == (REGEXCHAR *)pat)</span>
<a href="#l67.49"></a><span id="l67.49" class="difflineplus">+        if (p == (REGEXCHAR*)pat)</span>
<a href="#l67.50"></a><span id="l67.50">           store(BOL);</span>
<a href="#l67.51"></a><span id="l67.51">         else {</span>
<a href="#l67.52"></a><span id="l67.52">           store(CHR);</span>
<a href="#l67.53"></a><span id="l67.53">           store(*p);</span>
<a href="#l67.54"></a><span id="l67.54">         }</span>
<a href="#l67.55"></a><span id="l67.55">         break;</span>
<a href="#l67.56"></a><span id="l67.56"> </span>
<a href="#l67.57"></a><span id="l67.57">       case '$': /* match endofline.. */</span>
<a href="#l67.58"></a><span id="l67.58" class="difflineat">@@ -344,17 +344,17 @@ char *LDAP_CALL re_comp(const char *pat)</span>
<a href="#l67.59"></a><span id="l67.59"> </span>
<a href="#l67.60"></a><span id="l67.60">         for (n = 0; n &lt; BITBLK; bittab[n++] = (REGEXCHAR)0)</span>
<a href="#l67.61"></a><span id="l67.61">           store(mask ^ bittab[n]);</span>
<a href="#l67.62"></a><span id="l67.62"> </span>
<a href="#l67.63"></a><span id="l67.63">         break;</span>
<a href="#l67.64"></a><span id="l67.64"> </span>
<a href="#l67.65"></a><span id="l67.65">       case '*': /* match 0 or more.. */</span>
<a href="#l67.66"></a><span id="l67.66">       case '+': /* match 1 or more.. */</span>
<a href="#l67.67"></a><span id="l67.67" class="difflineminus">-        if (p == (REGEXCHAR *)pat) return badpat(&quot;Empty closure&quot;);</span>
<a href="#l67.68"></a><span id="l67.68" class="difflineplus">+        if (p == (REGEXCHAR*)pat) return badpat(&quot;Empty closure&quot;);</span>
<a href="#l67.69"></a><span id="l67.69">         lp = sp;        /* previous opcode */</span>
<a href="#l67.70"></a><span id="l67.70">         if (*lp == CLO) /* equivalence..   */</span>
<a href="#l67.71"></a><span id="l67.71">           break;</span>
<a href="#l67.72"></a><span id="l67.72">         switch (*lp) {</span>
<a href="#l67.73"></a><span id="l67.73">           case BOL:</span>
<a href="#l67.74"></a><span id="l67.74">           case BOT:</span>
<a href="#l67.75"></a><span id="l67.75">           case EOT:</span>
<a href="#l67.76"></a><span id="l67.76">           case BOW:</span>
<a href="#l67.77"></a><span id="l67.77" class="difflineat">@@ -455,23 +455,23 @@ char *LDAP_CALL re_comp(const char *pat)</span>
<a href="#l67.78"></a><span id="l67.78">     sp = lp;</span>
<a href="#l67.79"></a><span id="l67.79">   }</span>
<a href="#l67.80"></a><span id="l67.80">   if (tagi &gt; 0) return badpat(&quot;Unmatched \\(&quot;);</span>
<a href="#l67.81"></a><span id="l67.81">   store(END);</span>
<a href="#l67.82"></a><span id="l67.82">   sta = OKP;</span>
<a href="#l67.83"></a><span id="l67.83">   return 0;</span>
<a href="#l67.84"></a><span id="l67.84"> }</span>
<a href="#l67.85"></a><span id="l67.85"> </span>
<a href="#l67.86"></a><span id="l67.86" class="difflineminus">-static REGEXCHAR *bol;</span>
<a href="#l67.87"></a><span id="l67.87" class="difflineminus">-static REGEXCHAR *bopat[MAXTAG];</span>
<a href="#l67.88"></a><span id="l67.88" class="difflineminus">-static REGEXCHAR *eopat[MAXTAG];</span>
<a href="#l67.89"></a><span id="l67.89" class="difflineplus">+static REGEXCHAR* bol;</span>
<a href="#l67.90"></a><span id="l67.90" class="difflineplus">+static REGEXCHAR* bopat[MAXTAG];</span>
<a href="#l67.91"></a><span id="l67.91" class="difflineplus">+static REGEXCHAR* eopat[MAXTAG];</span>
<a href="#l67.92"></a><span id="l67.92"> #  ifdef NEEDPROTOS</span>
<a href="#l67.93"></a><span id="l67.93" class="difflineminus">-static REGEXCHAR *pmatch(REGEXCHAR *lp, REGEXCHAR *ap);</span>
<a href="#l67.94"></a><span id="l67.94" class="difflineplus">+static REGEXCHAR* pmatch(REGEXCHAR* lp, REGEXCHAR* ap);</span>
<a href="#l67.95"></a><span id="l67.95"> #  else  /* NEEDPROTOS */</span>
<a href="#l67.96"></a><span id="l67.96" class="difflineminus">-static REGEXCHAR *pmatch();</span>
<a href="#l67.97"></a><span id="l67.97" class="difflineplus">+static REGEXCHAR* pmatch();</span>
<a href="#l67.98"></a><span id="l67.98"> #  endif /* NEEDPROTOS */</span>
<a href="#l67.99"></a><span id="l67.99"> </span>
<a href="#l67.100"></a><span id="l67.100"> /*</span>
<a href="#l67.101"></a><span id="l67.101">  * re_exec:</span>
<a href="#l67.102"></a><span id="l67.102">  *   execute nfa to find a match.</span>
<a href="#l67.103"></a><span id="l67.103">  *</span>
<a href="#l67.104"></a><span id="l67.104">  * special cases: (nfa[0])</span>
<a href="#l67.105"></a><span id="l67.105">  *   BOL</span>
<a href="#l67.106"></a><span id="l67.106" class="difflineat">@@ -486,56 +486,56 @@ static REGEXCHAR *pmatch();</span>
<a href="#l67.107"></a><span id="l67.107">  *     check for it. Fail fast.</span>
<a href="#l67.108"></a><span id="l67.108">  *</span>
<a href="#l67.109"></a><span id="l67.109">  * If a match is found, bopat[0] and eopat[0] are set</span>
<a href="#l67.110"></a><span id="l67.110">  * to the beginning and the end of the matched fragment,</span>
<a href="#l67.111"></a><span id="l67.111">  * respectively.</span>
<a href="#l67.112"></a><span id="l67.112">  *</span>
<a href="#l67.113"></a><span id="l67.113">  */</span>
<a href="#l67.114"></a><span id="l67.114"> </span>
<a href="#l67.115"></a><span id="l67.115" class="difflineminus">-int LDAP_CALL re_exec(const char *lp) {</span>
<a href="#l67.116"></a><span id="l67.116" class="difflineplus">+int LDAP_CALL re_exec(const char* lp) {</span>
<a href="#l67.117"></a><span id="l67.117">   register REGEXCHAR c;</span>
<a href="#l67.118"></a><span id="l67.118" class="difflineminus">-  register REGEXCHAR *ep = 0;</span>
<a href="#l67.119"></a><span id="l67.119" class="difflineminus">-  register REGEXCHAR *ap = nfa;</span>
<a href="#l67.120"></a><span id="l67.120" class="difflineplus">+  register REGEXCHAR* ep = 0;</span>
<a href="#l67.121"></a><span id="l67.121" class="difflineplus">+  register REGEXCHAR* ap = nfa;</span>
<a href="#l67.122"></a><span id="l67.122"> </span>
<a href="#l67.123"></a><span id="l67.123" class="difflineminus">-  bol = (REGEXCHAR *)lp;</span>
<a href="#l67.124"></a><span id="l67.124" class="difflineplus">+  bol = (REGEXCHAR*)lp;</span>
<a href="#l67.125"></a><span id="l67.125"> </span>
<a href="#l67.126"></a><span id="l67.126">   bopat[0] = 0;</span>
<a href="#l67.127"></a><span id="l67.127">   bopat[1] = 0;</span>
<a href="#l67.128"></a><span id="l67.128">   bopat[2] = 0;</span>
<a href="#l67.129"></a><span id="l67.129">   bopat[3] = 0;</span>
<a href="#l67.130"></a><span id="l67.130">   bopat[4] = 0;</span>
<a href="#l67.131"></a><span id="l67.131">   bopat[5] = 0;</span>
<a href="#l67.132"></a><span id="l67.132">   bopat[6] = 0;</span>
<a href="#l67.133"></a><span id="l67.133">   bopat[7] = 0;</span>
<a href="#l67.134"></a><span id="l67.134">   bopat[8] = 0;</span>
<a href="#l67.135"></a><span id="l67.135">   bopat[9] = 0;</span>
<a href="#l67.136"></a><span id="l67.136"> </span>
<a href="#l67.137"></a><span id="l67.137">   switch (*ap) {</span>
<a href="#l67.138"></a><span id="l67.138">     case BOL: /* anchored: match from BOL only */</span>
<a href="#l67.139"></a><span id="l67.139" class="difflineminus">-      ep = pmatch((REGEXCHAR *)lp, ap);</span>
<a href="#l67.140"></a><span id="l67.140" class="difflineplus">+      ep = pmatch((REGEXCHAR*)lp, ap);</span>
<a href="#l67.141"></a><span id="l67.141">       break;</span>
<a href="#l67.142"></a><span id="l67.142">     case CHR: /* ordinary char: locate it fast */</span>
<a href="#l67.143"></a><span id="l67.143">       c = *(ap + 1);</span>
<a href="#l67.144"></a><span id="l67.144" class="difflineminus">-      while (*lp &amp;&amp; *(REGEXCHAR *)lp != c) lp++;</span>
<a href="#l67.145"></a><span id="l67.145" class="difflineplus">+      while (*lp &amp;&amp; *(REGEXCHAR*)lp != c) lp++;</span>
<a href="#l67.146"></a><span id="l67.146">       if (!*lp) /* if EOS, fail, else fall through. */</span>
<a href="#l67.147"></a><span id="l67.147">         return 0;</span>
<a href="#l67.148"></a><span id="l67.148">     default: /* regular matching all the way. */</span>
<a href="#l67.149"></a><span id="l67.149">       do {</span>
<a href="#l67.150"></a><span id="l67.150" class="difflineminus">-        if ((ep = pmatch((REGEXCHAR *)lp, ap))) break;</span>
<a href="#l67.151"></a><span id="l67.151" class="difflineplus">+        if ((ep = pmatch((REGEXCHAR*)lp, ap))) break;</span>
<a href="#l67.152"></a><span id="l67.152">         lp++;</span>
<a href="#l67.153"></a><span id="l67.153">       } while (*lp);</span>
<a href="#l67.154"></a><span id="l67.154"> </span>
<a href="#l67.155"></a><span id="l67.155">       break;</span>
<a href="#l67.156"></a><span id="l67.156">     case END: /* munged automaton. fail always */</span>
<a href="#l67.157"></a><span id="l67.157">       return 0;</span>
<a href="#l67.158"></a><span id="l67.158">   }</span>
<a href="#l67.159"></a><span id="l67.159">   if (!ep) return 0;</span>
<a href="#l67.160"></a><span id="l67.160"> </span>
<a href="#l67.161"></a><span id="l67.161" class="difflineminus">-  bopat[0] = (REGEXCHAR *)lp;</span>
<a href="#l67.162"></a><span id="l67.162" class="difflineplus">+  bopat[0] = (REGEXCHAR*)lp;</span>
<a href="#l67.163"></a><span id="l67.163">   eopat[0] = ep;</span>
<a href="#l67.164"></a><span id="l67.164">   return 1;</span>
<a href="#l67.165"></a><span id="l67.165"> }</span>
<a href="#l67.166"></a><span id="l67.166"> </span>
<a href="#l67.167"></a><span id="l67.167"> /*</span>
<a href="#l67.168"></a><span id="l67.168">  * pmatch: internal routine for the hard part</span>
<a href="#l67.169"></a><span id="l67.169">  *</span>
<a href="#l67.170"></a><span id="l67.170">  * This code is partly snarfed from an early grep written by</span>
<a href="#l67.171"></a><span id="l67.171" class="difflineat">@@ -595,22 +595,22 @@ static char chrtyp[MAXCHR] = {</span>
<a href="#l67.172"></a><span id="l67.172"> /*</span>
<a href="#l67.173"></a><span id="l67.173">  * skip values for CLO XXX to skip past the closure</span>
<a href="#l67.174"></a><span id="l67.174">  */</span>
<a href="#l67.175"></a><span id="l67.175"> </span>
<a href="#l67.176"></a><span id="l67.176"> #  define ANYSKIP 2  /* [CLO] ANY END ...       */</span>
<a href="#l67.177"></a><span id="l67.177"> #  define CHRSKIP 3  /* [CLO] CHR chr END ...     */</span>
<a href="#l67.178"></a><span id="l67.178"> #  define CCLSKIP 18 /* [CLO] CCL 16bytes END ... */</span>
<a href="#l67.179"></a><span id="l67.179"> </span>
<a href="#l67.180"></a><span id="l67.180" class="difflineminus">-static REGEXCHAR *pmatch(REGEXCHAR *lp, REGEXCHAR *ap) {</span>
<a href="#l67.181"></a><span id="l67.181" class="difflineplus">+static REGEXCHAR* pmatch(REGEXCHAR* lp, REGEXCHAR* ap) {</span>
<a href="#l67.182"></a><span id="l67.182">   register int op, c, n;</span>
<a href="#l67.183"></a><span id="l67.183" class="difflineminus">-  register REGEXCHAR *e;  /* extra pointer for CLO */</span>
<a href="#l67.184"></a><span id="l67.184" class="difflineminus">-  register REGEXCHAR *bp; /* beginning of subpat.. */</span>
<a href="#l67.185"></a><span id="l67.185" class="difflineminus">-  register REGEXCHAR *ep; /* ending of subpat..   */</span>
<a href="#l67.186"></a><span id="l67.186" class="difflineminus">-  REGEXCHAR *are;         /* to save the line ptr. */</span>
<a href="#l67.187"></a><span id="l67.187" class="difflineplus">+  register REGEXCHAR* e;  /* extra pointer for CLO */</span>
<a href="#l67.188"></a><span id="l67.188" class="difflineplus">+  register REGEXCHAR* bp; /* beginning of subpat.. */</span>
<a href="#l67.189"></a><span id="l67.189" class="difflineplus">+  register REGEXCHAR* ep; /* ending of subpat..   */</span>
<a href="#l67.190"></a><span id="l67.190" class="difflineplus">+  REGEXCHAR* are;         /* to save the line ptr. */</span>
<a href="#l67.191"></a><span id="l67.191"> </span>
<a href="#l67.192"></a><span id="l67.192">   while ((op = *ap++) != END) switch (op) {</span>
<a href="#l67.193"></a><span id="l67.193">       case CHR:</span>
<a href="#l67.194"></a><span id="l67.194">         if (*lp++ != *ap++) return 0;</span>
<a href="#l67.195"></a><span id="l67.195">         break;</span>
<a href="#l67.196"></a><span id="l67.196">       case ANY:</span>
<a href="#l67.197"></a><span id="l67.197">         if (!*lp++) return 0;</span>
<a href="#l67.198"></a><span id="l67.198">         break;</span>
<a href="#l67.199"></a><span id="l67.199" class="difflineat">@@ -688,17 +688,17 @@ static REGEXCHAR *pmatch(REGEXCHAR *lp, </span>
<a href="#l67.200"></a><span id="l67.200">  * If the string parameter is 0 or null string, the table is</span>
<a href="#l67.201"></a><span id="l67.201">  * reset back to the default containing A-Z a-z 0-9 _. [We use</span>
<a href="#l67.202"></a><span id="l67.202">  * the compact bitset representation for the default table]</span>
<a href="#l67.203"></a><span id="l67.203">  */</span>
<a href="#l67.204"></a><span id="l67.204"> </span>
<a href="#l67.205"></a><span id="l67.205"> static REGEXCHAR deftab[16] = {0,    0,    0,    0,    0,    0,    0377, 003,</span>
<a href="#l67.206"></a><span id="l67.206">                                0376, 0377, 0377, 0207, 0376, 0377, 0377, 007};</span>
<a href="#l67.207"></a><span id="l67.207"> </span>
<a href="#l67.208"></a><span id="l67.208" class="difflineminus">-void LDAP_CALL re_modw(char *s) {</span>
<a href="#l67.209"></a><span id="l67.209" class="difflineplus">+void LDAP_CALL re_modw(char* s) {</span>
<a href="#l67.210"></a><span id="l67.210">   register int i;</span>
<a href="#l67.211"></a><span id="l67.211"> </span>
<a href="#l67.212"></a><span id="l67.212">   if (!s || !*s) {</span>
<a href="#l67.213"></a><span id="l67.213">     for (i = 0; i &lt; MAXCHR; i++)</span>
<a href="#l67.214"></a><span id="l67.214">       if (!isinset(deftab, i)) iswordc(i) = 0;</span>
<a href="#l67.215"></a><span id="l67.215">   } else</span>
<a href="#l67.216"></a><span id="l67.216">     while (*s) iswordc(*s++) = 1;</span>
<a href="#l67.217"></a><span id="l67.217"> }</span>
<a href="#l67.218"></a><span id="l67.218" class="difflineat">@@ -708,21 +708,21 @@ void LDAP_CALL re_modw(char *s) {</span>
<a href="#l67.219"></a><span id="l67.219">  * substitute the matched portions of the src in dst.</span>
<a href="#l67.220"></a><span id="l67.220">  *</span>
<a href="#l67.221"></a><span id="l67.221">  * &amp;  substitute the entire matched pattern.</span>
<a href="#l67.222"></a><span id="l67.222">  *</span>
<a href="#l67.223"></a><span id="l67.223">  * \digit  substitute a subpattern, with the given  tag number.</span>
<a href="#l67.224"></a><span id="l67.224">  *   Tags are numbered from 1 to 9. If the particular</span>
<a href="#l67.225"></a><span id="l67.225">  *   tagged subpattern does not exist, null is substituted.</span>
<a href="#l67.226"></a><span id="l67.226">  */</span>
<a href="#l67.227"></a><span id="l67.227" class="difflineminus">-int LDAP_CALL re_subs(char *src, char *dst) {</span>
<a href="#l67.228"></a><span id="l67.228" class="difflineplus">+int LDAP_CALL re_subs(char* src, char* dst) {</span>
<a href="#l67.229"></a><span id="l67.229">   register char c;</span>
<a href="#l67.230"></a><span id="l67.230">   register int pin;</span>
<a href="#l67.231"></a><span id="l67.231" class="difflineminus">-  register REGEXCHAR *bp;</span>
<a href="#l67.232"></a><span id="l67.232" class="difflineminus">-  register REGEXCHAR *ep;</span>
<a href="#l67.233"></a><span id="l67.233" class="difflineplus">+  register REGEXCHAR* bp;</span>
<a href="#l67.234"></a><span id="l67.234" class="difflineplus">+  register REGEXCHAR* ep;</span>
<a href="#l67.235"></a><span id="l67.235"> </span>
<a href="#l67.236"></a><span id="l67.236">   if (!*src || !bopat[0]) return 0;</span>
<a href="#l67.237"></a><span id="l67.237"> </span>
<a href="#l67.238"></a><span id="l67.238">   while ((c = *src++)) {</span>
<a href="#l67.239"></a><span id="l67.239">     switch (c) {</span>
<a href="#l67.240"></a><span id="l67.240">       case '&amp;':</span>
<a href="#l67.241"></a><span id="l67.241">         pin = 0;</span>
<a href="#l67.242"></a><span id="l67.242">         break;</span>
<a href="#l67.243"></a><span id="l67.243" class="difflineat">@@ -735,54 +735,54 @@ int LDAP_CALL re_subs(char *src, char *d</span>
<a href="#l67.244"></a><span id="l67.244">         }</span>
<a href="#l67.245"></a><span id="l67.245"> </span>
<a href="#l67.246"></a><span id="l67.246">       default:</span>
<a href="#l67.247"></a><span id="l67.247">         *dst++ = c;</span>
<a href="#l67.248"></a><span id="l67.248">         continue;</span>
<a href="#l67.249"></a><span id="l67.249">     }</span>
<a href="#l67.250"></a><span id="l67.250"> </span>
<a href="#l67.251"></a><span id="l67.251">     if ((bp = bopat[pin]) &amp;&amp; (ep = eopat[pin])) {</span>
<a href="#l67.252"></a><span id="l67.252" class="difflineminus">-      while (*bp &amp;&amp; bp &lt; ep) *dst++ = *(char *)bp++;</span>
<a href="#l67.253"></a><span id="l67.253" class="difflineplus">+      while (*bp &amp;&amp; bp &lt; ep) *dst++ = *(char*)bp++;</span>
<a href="#l67.254"></a><span id="l67.254">       if (bp &lt; ep) return 0;</span>
<a href="#l67.255"></a><span id="l67.255">     }</span>
<a href="#l67.256"></a><span id="l67.256">   }</span>
<a href="#l67.257"></a><span id="l67.257">   *dst = (char)0;</span>
<a href="#l67.258"></a><span id="l67.258">   return 1;</span>
<a href="#l67.259"></a><span id="l67.259"> }</span>
<a href="#l67.260"></a><span id="l67.260"> </span>
<a href="#l67.261"></a><span id="l67.261"> #  ifdef DEBUG</span>
<a href="#l67.262"></a><span id="l67.262"> </span>
<a href="#l67.263"></a><span id="l67.263"> /* No printf or exit in 16-bit Windows */</span>
<a href="#l67.264"></a><span id="l67.264"> #    if defined(_WINDOWS) &amp;&amp; !defined(_WIN32)</span>
<a href="#l67.265"></a><span id="l67.265" class="difflineminus">-static int LDAP_C printf(const char *pszFormat, ...) {</span>
<a href="#l67.266"></a><span id="l67.266" class="difflineplus">+static int LDAP_C printf(const char* pszFormat, ...) {</span>
<a href="#l67.267"></a><span id="l67.267">   char buf[1024];</span>
<a href="#l67.268"></a><span id="l67.268">   va_list arglist;</span>
<a href="#l67.269"></a><span id="l67.269">   va_start(arglist, pszFormat);</span>
<a href="#l67.270"></a><span id="l67.270">   vsprintf(buf, pszFormat, arglist);</span>
<a href="#l67.271"></a><span id="l67.271">   va_end(arglist);</span>
<a href="#l67.272"></a><span id="l67.272">   OutputDebugString(buf);</span>
<a href="#l67.273"></a><span id="l67.273">   return 0;</span>
<a href="#l67.274"></a><span id="l67.274"> }</span>
<a href="#l67.275"></a><span id="l67.275"> #      define exit(v) return</span>
<a href="#l67.276"></a><span id="l67.276"> #    endif /* 16-bit Windows */</span>
<a href="#l67.277"></a><span id="l67.277"> </span>
<a href="#l67.278"></a><span id="l67.278"> #    ifdef REGEX_DEBUG</span>
<a href="#l67.279"></a><span id="l67.279"> </span>
<a href="#l67.280"></a><span id="l67.280" class="difflineminus">-static void nfadump(REGEXCHAR *ap);</span>
<a href="#l67.281"></a><span id="l67.281" class="difflineplus">+static void nfadump(REGEXCHAR* ap);</span>
<a href="#l67.282"></a><span id="l67.282"> </span>
<a href="#l67.283"></a><span id="l67.283"> /*</span>
<a href="#l67.284"></a><span id="l67.284">  * symbolic - produce a symbolic dump of the nfa</span>
<a href="#l67.285"></a><span id="l67.285">  */</span>
<a href="#l67.286"></a><span id="l67.286" class="difflineminus">-void symbolic(char *s) {</span>
<a href="#l67.287"></a><span id="l67.287" class="difflineplus">+void symbolic(char* s) {</span>
<a href="#l67.288"></a><span id="l67.288">   printf(&quot;pattern: %s\n&quot;, s);</span>
<a href="#l67.289"></a><span id="l67.289">   printf(&quot;nfacode:\n&quot;);</span>
<a href="#l67.290"></a><span id="l67.290">   nfadump(nfa);</span>
<a href="#l67.291"></a><span id="l67.291"> }</span>
<a href="#l67.292"></a><span id="l67.292"> </span>
<a href="#l67.293"></a><span id="l67.293" class="difflineminus">-static void nfadump(REGEXCHAR *ap) {</span>
<a href="#l67.294"></a><span id="l67.294" class="difflineplus">+static void nfadump(REGEXCHAR* ap) {</span>
<a href="#l67.295"></a><span id="l67.295">   register int n;</span>
<a href="#l67.296"></a><span id="l67.296"> </span>
<a href="#l67.297"></a><span id="l67.297">   while (*ap != END) switch (*ap++) {</span>
<a href="#l67.298"></a><span id="l67.298">       case CLO:</span>
<a href="#l67.299"></a><span id="l67.299">         printf(&quot;CLOSURE&quot;);</span>
<a href="#l67.300"></a><span id="l67.300">         nfadump(ap);</span>
<a href="#l67.301"></a><span id="l67.301">         switch (*ap) {</span>
<a href="#l67.302"></a><span id="l67.302">           case CHR:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l68.1"></a><span id="l68.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/rename.c</span>
<a href="#l68.2"></a><span id="l68.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/rename.c</span>
<a href="#l68.3"></a><span id="l68.3" class="difflineat">@@ -66,21 +66,21 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l68.4"></a><span id="l68.4">  *                request if the ldap_rename() call succeeds</span>
<a href="#l68.5"></a><span id="l68.5">  *</span>
<a href="#l68.6"></a><span id="l68.6">  * Example:</span>
<a href="#l68.7"></a><span id="l68.7">  * int rc;</span>
<a href="#l68.8"></a><span id="l68.8">  * rc = ldap_rename(ld, dn, newrdn, newparent, deleteoldrdn, serverctrls,</span>
<a href="#l68.9"></a><span id="l68.9">  *                  clientctrls, &amp;msgid);</span>
<a href="#l68.10"></a><span id="l68.10">  */</span>
<a href="#l68.11"></a><span id="l68.11"> int LDAP_CALL</span>
<a href="#l68.12"></a><span id="l68.12" class="difflineminus">-ldap_rename(LDAP *ld, const char *dn, const char *newrdn, const char *newparent,</span>
<a href="#l68.13"></a><span id="l68.13" class="difflineminus">-            int deleteoldrdn, LDAPControl **serverctrls,</span>
<a href="#l68.14"></a><span id="l68.14" class="difflineminus">-            LDAPControl **clientctrls, /* not used for anything yet */</span>
<a href="#l68.15"></a><span id="l68.15" class="difflineminus">-            int *msgidp) {</span>
<a href="#l68.16"></a><span id="l68.16" class="difflineminus">-  BerElement *ber;</span>
<a href="#l68.17"></a><span id="l68.17" class="difflineplus">+ldap_rename(LDAP* ld, const char* dn, const char* newrdn, const char* newparent,</span>
<a href="#l68.18"></a><span id="l68.18" class="difflineplus">+            int deleteoldrdn, LDAPControl** serverctrls,</span>
<a href="#l68.19"></a><span id="l68.19" class="difflineplus">+            LDAPControl** clientctrls, /* not used for anything yet */</span>
<a href="#l68.20"></a><span id="l68.20" class="difflineplus">+            int* msgidp) {</span>
<a href="#l68.21"></a><span id="l68.21" class="difflineplus">+  BerElement* ber;</span>
<a href="#l68.22"></a><span id="l68.22">   int rc, err;</span>
<a href="#l68.23"></a><span id="l68.23"> </span>
<a href="#l68.24"></a><span id="l68.24">   /*</span>
<a href="#l68.25"></a><span id="l68.25">    * A modify dn request looks like this:</span>
<a href="#l68.26"></a><span id="l68.26">    * ModifyDNRequest ::= SEQUENCE {</span>
<a href="#l68.27"></a><span id="l68.27">    *   entry  LDAPDN,</span>
<a href="#l68.28"></a><span id="l68.28">    *   newrdn  RelativeLDAPDN,</span>
<a href="#l68.29"></a><span id="l68.29">    *   newparent [0] LDAPDN OPTIONAL,</span>
<a href="#l68.30"></a><span id="l68.30" class="difflineat">@@ -170,68 +170,68 @@ ldap_rename(LDAP *ld, const char *dn, co</span>
<a href="#l68.31"></a><span id="l68.31">   }</span>
<a href="#l68.32"></a><span id="l68.32"> </span>
<a href="#l68.33"></a><span id="l68.33">   if ((rc = nsldapi_put_controls(ld, serverctrls, 1, ber)) != LDAP_SUCCESS) {</span>
<a href="#l68.34"></a><span id="l68.34">     ber_free(ber, 1);</span>
<a href="#l68.35"></a><span id="l68.35">     return (rc);</span>
<a href="#l68.36"></a><span id="l68.36">   }</span>
<a href="#l68.37"></a><span id="l68.37"> </span>
<a href="#l68.38"></a><span id="l68.38">   /* send the message */</span>
<a href="#l68.39"></a><span id="l68.39" class="difflineminus">-  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_MODDN, (char *)dn,</span>
<a href="#l68.40"></a><span id="l68.40" class="difflineminus">-                                    ber);</span>
<a href="#l68.41"></a><span id="l68.41" class="difflineplus">+  rc =</span>
<a href="#l68.42"></a><span id="l68.42" class="difflineplus">+      nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_MODDN, (char*)dn, ber);</span>
<a href="#l68.43"></a><span id="l68.43">   *msgidp = rc;</span>
<a href="#l68.44"></a><span id="l68.44">   return (rc &lt; 0 ? LDAP_GET_LDERRNO(ld, NULL, NULL) : LDAP_SUCCESS);</span>
<a href="#l68.45"></a><span id="l68.45"> }</span>
<a href="#l68.46"></a><span id="l68.46"> </span>
<a href="#l68.47"></a><span id="l68.47" class="difflineminus">-int LDAP_CALL ldap_modrdn2(LDAP *ld, const char *dn, const char *newrdn,</span>
<a href="#l68.48"></a><span id="l68.48" class="difflineplus">+int LDAP_CALL ldap_modrdn2(LDAP* ld, const char* dn, const char* newrdn,</span>
<a href="#l68.49"></a><span id="l68.49">                            int deleteoldrdn) {</span>
<a href="#l68.50"></a><span id="l68.50">   int msgid;</span>
<a href="#l68.51"></a><span id="l68.51"> </span>
<a href="#l68.52"></a><span id="l68.52">   if (ldap_rename(ld, dn, newrdn, NULL, deleteoldrdn, NULL, NULL, &amp;msgid) ==</span>
<a href="#l68.53"></a><span id="l68.53">       LDAP_SUCCESS) {</span>
<a href="#l68.54"></a><span id="l68.54">     return (msgid);</span>
<a href="#l68.55"></a><span id="l68.55">   } else {</span>
<a href="#l68.56"></a><span id="l68.56">     return (-1); /* error is in ld handle */</span>
<a href="#l68.57"></a><span id="l68.57">   }</span>
<a href="#l68.58"></a><span id="l68.58"> }</span>
<a href="#l68.59"></a><span id="l68.59"> </span>
<a href="#l68.60"></a><span id="l68.60" class="difflineminus">-int LDAP_CALL ldap_modrdn(LDAP *ld, const char *dn, const char *newrdn) {</span>
<a href="#l68.61"></a><span id="l68.61" class="difflineplus">+int LDAP_CALL ldap_modrdn(LDAP* ld, const char* dn, const char* newrdn) {</span>
<a href="#l68.62"></a><span id="l68.62">   return (ldap_modrdn2(ld, dn, newrdn, 1));</span>
<a href="#l68.63"></a><span id="l68.63"> }</span>
<a href="#l68.64"></a><span id="l68.64"> </span>
<a href="#l68.65"></a><span id="l68.65"> int LDAP_CALL ldap_rename_s(</span>
<a href="#l68.66"></a><span id="l68.66" class="difflineminus">-    LDAP *ld, const char *dn, const char *newrdn, const char *newparent,</span>
<a href="#l68.67"></a><span id="l68.67" class="difflineminus">-    int deleteoldrdn, LDAPControl **serverctrls,</span>
<a href="#l68.68"></a><span id="l68.68" class="difflineminus">-    LDAPControl **clientctrls /* not used for anything yet */</span>
<a href="#l68.69"></a><span id="l68.69" class="difflineplus">+    LDAP* ld, const char* dn, const char* newrdn, const char* newparent,</span>
<a href="#l68.70"></a><span id="l68.70" class="difflineplus">+    int deleteoldrdn, LDAPControl** serverctrls,</span>
<a href="#l68.71"></a><span id="l68.71" class="difflineplus">+    LDAPControl** clientctrls /* not used for anything yet */</span>
<a href="#l68.72"></a><span id="l68.72"> ) {</span>
<a href="#l68.73"></a><span id="l68.73">   int msgid;</span>
<a href="#l68.74"></a><span id="l68.74" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l68.75"></a><span id="l68.75" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l68.76"></a><span id="l68.76"> </span>
<a href="#l68.77"></a><span id="l68.77">   if (ldap_rename(ld, dn, newrdn, newparent, deleteoldrdn, serverctrls,</span>
<a href="#l68.78"></a><span id="l68.78">                   clientctrls, &amp;msgid) != LDAP_SUCCESS) {</span>
<a href="#l68.79"></a><span id="l68.79">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l68.80"></a><span id="l68.80">   }</span>
<a href="#l68.81"></a><span id="l68.81"> </span>
<a href="#l68.82"></a><span id="l68.82">   if (msgid == -1) return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l68.83"></a><span id="l68.83"> </span>
<a href="#l68.84"></a><span id="l68.84" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)NULL, &amp;res) == -1)</span>
<a href="#l68.85"></a><span id="l68.85" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)NULL, &amp;res) == -1)</span>
<a href="#l68.86"></a><span id="l68.86">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l68.87"></a><span id="l68.87"> </span>
<a href="#l68.88"></a><span id="l68.88">   return (ldap_result2error(ld, res, 1));</span>
<a href="#l68.89"></a><span id="l68.89"> }</span>
<a href="#l68.90"></a><span id="l68.90"> </span>
<a href="#l68.91"></a><span id="l68.91" class="difflineminus">-int LDAP_CALL ldap_modrdn2_s(LDAP *ld, const char *dn, const char *newrdn,</span>
<a href="#l68.92"></a><span id="l68.92" class="difflineplus">+int LDAP_CALL ldap_modrdn2_s(LDAP* ld, const char* dn, const char* newrdn,</span>
<a href="#l68.93"></a><span id="l68.93">                              int deleteoldrdn) {</span>
<a href="#l68.94"></a><span id="l68.94">   int msgid;</span>
<a href="#l68.95"></a><span id="l68.95" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l68.96"></a><span id="l68.96" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l68.97"></a><span id="l68.97"> </span>
<a href="#l68.98"></a><span id="l68.98">   if ((msgid = ldap_modrdn2(ld, dn, newrdn, deleteoldrdn)) == -1)</span>
<a href="#l68.99"></a><span id="l68.99">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l68.100"></a><span id="l68.100"> </span>
<a href="#l68.101"></a><span id="l68.101" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)NULL, &amp;res) == -1)</span>
<a href="#l68.102"></a><span id="l68.102" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)NULL, &amp;res) == -1)</span>
<a href="#l68.103"></a><span id="l68.103">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l68.104"></a><span id="l68.104"> </span>
<a href="#l68.105"></a><span id="l68.105">   return (ldap_result2error(ld, res, 1));</span>
<a href="#l68.106"></a><span id="l68.106"> }</span>
<a href="#l68.107"></a><span id="l68.107"> </span>
<a href="#l68.108"></a><span id="l68.108" class="difflineminus">-int LDAP_CALL ldap_modrdn_s(LDAP *ld, const char *dn, const char *newrdn) {</span>
<a href="#l68.109"></a><span id="l68.109" class="difflineplus">+int LDAP_CALL ldap_modrdn_s(LDAP* ld, const char* dn, const char* newrdn) {</span>
<a href="#l68.110"></a><span id="l68.110">   return (ldap_modrdn2_s(ld, dn, newrdn, 1));</span>
<a href="#l68.111"></a><span id="l68.111"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l69.1"></a><span id="l69.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/request.c</span>
<a href="#l69.2"></a><span id="l69.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/request.c</span>
<a href="#l69.3"></a><span id="l69.3" class="difflineat">@@ -45,31 +45,31 @@</span>
<a href="#l69.4"></a><span id="l69.4"> #if 0</span>
<a href="#l69.5"></a><span id="l69.5"> #  ifndef lint</span>
<a href="#l69.6"></a><span id="l69.6"> static char copyright[] = &quot;@(#) Copyright (c) 1995 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l69.7"></a><span id="l69.7"> #  endif</span>
<a href="#l69.8"></a><span id="l69.8"> #endif</span>
<a href="#l69.9"></a><span id="l69.9"> </span>
<a href="#l69.10"></a><span id="l69.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l69.11"></a><span id="l69.11"> </span>
<a href="#l69.12"></a><span id="l69.12" class="difflineminus">-static LDAPConn *find_connection(LDAP *ld, LDAPServer *srv, int any);</span>
<a href="#l69.13"></a><span id="l69.13" class="difflineminus">-static void free_servers(LDAPServer *srvlist);</span>
<a href="#l69.14"></a><span id="l69.14" class="difflineminus">-static int chase_one_referral(LDAP *ld, LDAPRequest *lr, LDAPRequest *origreq,</span>
<a href="#l69.15"></a><span id="l69.15" class="difflineminus">-                              char *refurl, char *desc, int *unknownp,</span>
<a href="#l69.16"></a><span id="l69.16" class="difflineplus">+static LDAPConn* find_connection(LDAP* ld, LDAPServer* srv, int any);</span>
<a href="#l69.17"></a><span id="l69.17" class="difflineplus">+static void free_servers(LDAPServer* srvlist);</span>
<a href="#l69.18"></a><span id="l69.18" class="difflineplus">+static int chase_one_referral(LDAP* ld, LDAPRequest* lr, LDAPRequest* origreq,</span>
<a href="#l69.19"></a><span id="l69.19" class="difflineplus">+                              char* refurl, char* desc, int* unknownp,</span>
<a href="#l69.20"></a><span id="l69.20">                               int is_reference);</span>
<a href="#l69.21"></a><span id="l69.21" class="difflineminus">-static int re_encode_request(LDAP *ld, BerElement *origber, int msgid,</span>
<a href="#l69.22"></a><span id="l69.22" class="difflineminus">-                             LDAPURLDesc *ludp, BerElement **berp,</span>
<a href="#l69.23"></a><span id="l69.23" class="difflineplus">+static int re_encode_request(LDAP* ld, BerElement* origber, int msgid,</span>
<a href="#l69.24"></a><span id="l69.24" class="difflineplus">+                             LDAPURLDesc* ludp, BerElement** berp,</span>
<a href="#l69.25"></a><span id="l69.25">                              int is_reference);</span>
<a href="#l69.26"></a><span id="l69.26"> </span>
<a href="#l69.27"></a><span id="l69.27"> #ifdef LDAP_DNS</span>
<a href="#l69.28"></a><span id="l69.28" class="difflineminus">-static LDAPServer *dn2servers(LDAP *ld, char *dn);</span>
<a href="#l69.29"></a><span id="l69.29" class="difflineplus">+static LDAPServer* dn2servers(LDAP* ld, char* dn);</span>
<a href="#l69.30"></a><span id="l69.30"> #endif /* LDAP_DNS */</span>
<a href="#l69.31"></a><span id="l69.31"> </span>
<a href="#l69.32"></a><span id="l69.32"> /* returns an LDAP error code and also sets error inside LDAP * */</span>
<a href="#l69.33"></a><span id="l69.33" class="difflineminus">-int nsldapi_alloc_ber_with_options(LDAP *ld, BerElement **berp) {</span>
<a href="#l69.34"></a><span id="l69.34" class="difflineplus">+int nsldapi_alloc_ber_with_options(LDAP* ld, BerElement** berp) {</span>
<a href="#l69.35"></a><span id="l69.35">   int err;</span>
<a href="#l69.36"></a><span id="l69.36"> </span>
<a href="#l69.37"></a><span id="l69.37">   LDAP_MUTEX_LOCK(ld, LDAP_OPTION_LOCK);</span>
<a href="#l69.38"></a><span id="l69.38">   if ((*berp = ber_alloc_t(ld-&gt;ld_lberoptions)) == NULLBER) {</span>
<a href="#l69.39"></a><span id="l69.39">     err = LDAP_NO_MEMORY;</span>
<a href="#l69.40"></a><span id="l69.40">     LDAP_SET_LDERRNO(ld, err, NULL, NULL);</span>
<a href="#l69.41"></a><span id="l69.41">   } else {</span>
<a href="#l69.42"></a><span id="l69.42">     err = LDAP_SUCCESS;</span>
<a href="#l69.43"></a><span id="l69.43" class="difflineat">@@ -77,45 +77,45 @@ int nsldapi_alloc_ber_with_options(LDAP </span>
<a href="#l69.44"></a><span id="l69.44">     nsldapi_set_ber_options(ld, *berp);</span>
<a href="#l69.45"></a><span id="l69.45"> #endif /* STR_TRANSLATION */</span>
<a href="#l69.46"></a><span id="l69.46">   }</span>
<a href="#l69.47"></a><span id="l69.47">   LDAP_MUTEX_UNLOCK(ld, LDAP_OPTION_LOCK);</span>
<a href="#l69.48"></a><span id="l69.48"> </span>
<a href="#l69.49"></a><span id="l69.49">   return (err);</span>
<a href="#l69.50"></a><span id="l69.50"> }</span>
<a href="#l69.51"></a><span id="l69.51"> </span>
<a href="#l69.52"></a><span id="l69.52" class="difflineminus">-void nsldapi_set_ber_options(LDAP *ld, BerElement *ber) {</span>
<a href="#l69.53"></a><span id="l69.53" class="difflineplus">+void nsldapi_set_ber_options(LDAP* ld, BerElement* ber) {</span>
<a href="#l69.54"></a><span id="l69.54">   ber-&gt;ber_options = ld-&gt;ld_lberoptions;</span>
<a href="#l69.55"></a><span id="l69.55"> #ifdef STR_TRANSLATION</span>
<a href="#l69.56"></a><span id="l69.56">   if ((ld-&gt;ld_lberoptions &amp; LBER_OPT_TRANSLATE_STRINGS) != 0) {</span>
<a href="#l69.57"></a><span id="l69.57">     ber_set_string_translators(ber, ld-&gt;ld_lber_encode_translate_proc,</span>
<a href="#l69.58"></a><span id="l69.58">                                ld-&gt;ld_lber_decode_translate_proc);</span>
<a href="#l69.59"></a><span id="l69.59">   }</span>
<a href="#l69.60"></a><span id="l69.60"> #endif /* STR_TRANSLATION */</span>
<a href="#l69.61"></a><span id="l69.61"> }</span>
<a href="#l69.62"></a><span id="l69.62"> </span>
<a href="#l69.63"></a><span id="l69.63"> /* returns the message id of the request or -1 if an error occurs */</span>
<a href="#l69.64"></a><span id="l69.64" class="difflineminus">-int nsldapi_send_initial_request(LDAP *ld, int msgid, unsigned long msgtype,</span>
<a href="#l69.65"></a><span id="l69.65" class="difflineminus">-                                 char *dn, BerElement *ber) {</span>
<a href="#l69.66"></a><span id="l69.66" class="difflineminus">-  LDAPServer *servers;</span>
<a href="#l69.67"></a><span id="l69.67" class="difflineplus">+int nsldapi_send_initial_request(LDAP* ld, int msgid, unsigned long msgtype,</span>
<a href="#l69.68"></a><span id="l69.68" class="difflineplus">+                                 char* dn, BerElement* ber) {</span>
<a href="#l69.69"></a><span id="l69.69" class="difflineplus">+  LDAPServer* servers;</span>
<a href="#l69.70"></a><span id="l69.70"> </span>
<a href="#l69.71"></a><span id="l69.71">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_send_initial_request\n&quot;, 0, 0, 0);</span>
<a href="#l69.72"></a><span id="l69.72"> </span>
<a href="#l69.73"></a><span id="l69.73"> #ifdef LDAP_DNS</span>
<a href="#l69.74"></a><span id="l69.74">   LDAP_MUTEX_LOCK(ld, LDAP_OPTION_LOCK);</span>
<a href="#l69.75"></a><span id="l69.75">   if ((ld-&gt;ld_options &amp; LDAP_BITOPT_DNS) != 0 &amp;&amp; ldap_is_dns_dn(dn)) {</span>
<a href="#l69.76"></a><span id="l69.76">     if ((servers = dn2servers(ld, dn)) == NULL) {</span>
<a href="#l69.77"></a><span id="l69.77">       ber_free(ber, 1);</span>
<a href="#l69.78"></a><span id="l69.78">       LDAP_MUTEX_UNLOCK(ld, LDAP_OPTION_LOCK);</span>
<a href="#l69.79"></a><span id="l69.79">       return (-1);</span>
<a href="#l69.80"></a><span id="l69.80">     }</span>
<a href="#l69.81"></a><span id="l69.81"> </span>
<a href="#l69.82"></a><span id="l69.82"> #  ifdef LDAP_DEBUG</span>
<a href="#l69.83"></a><span id="l69.83">     if (ldap_debug &amp; LDAP_DEBUG_TRACE) {</span>
<a href="#l69.84"></a><span id="l69.84" class="difflineminus">-      LDAPServer *srv;</span>
<a href="#l69.85"></a><span id="l69.85" class="difflineplus">+      LDAPServer* srv;</span>
<a href="#l69.86"></a><span id="l69.86">       char msg[256];</span>
<a href="#l69.87"></a><span id="l69.87"> </span>
<a href="#l69.88"></a><span id="l69.88">       for (srv = servers; srv != NULL; srv = srv-&gt;lsrv_next) {</span>
<a href="#l69.89"></a><span id="l69.89">         sprintf(msg, &quot;LDAP server %s:  dn %s, port %d\n&quot;, srv-&gt;lsrv_host,</span>
<a href="#l69.90"></a><span id="l69.90">                 (srv-&gt;lsrv_dn == NULL) ? &quot;(default)&quot; : srv-&gt;lsrv_dn,</span>
<a href="#l69.91"></a><span id="l69.91">                 srv-&gt;lsrv_port);</span>
<a href="#l69.92"></a><span id="l69.92">         ber_err_print(msg);</span>
<a href="#l69.93"></a><span id="l69.93">       }</span>
<a href="#l69.94"></a><span id="l69.94" class="difflineat">@@ -135,35 +135,35 @@ int nsldapi_send_initial_request(LDAP *l</span>
<a href="#l69.95"></a><span id="l69.95"> </span>
<a href="#l69.96"></a><span id="l69.96">   return (nsldapi_send_server_request(ld, ber, msgid, NULL, servers, NULL,</span>
<a href="#l69.97"></a><span id="l69.97">                                       (msgtype == LDAP_REQ_BIND) ? dn : NULL,</span>
<a href="#l69.98"></a><span id="l69.98">                                       0));</span>
<a href="#l69.99"></a><span id="l69.99"> }</span>
<a href="#l69.100"></a><span id="l69.100"> </span>
<a href="#l69.101"></a><span id="l69.101"> /* returns the message id of the request or -1 if an error occurs */</span>
<a href="#l69.102"></a><span id="l69.102"> int nsldapi_send_server_request(</span>
<a href="#l69.103"></a><span id="l69.103" class="difflineminus">-    LDAP *ld,               /* session handle */</span>
<a href="#l69.104"></a><span id="l69.104" class="difflineminus">-    BerElement *ber,        /* message to send */</span>
<a href="#l69.105"></a><span id="l69.105" class="difflineplus">+    LDAP* ld,               /* session handle */</span>
<a href="#l69.106"></a><span id="l69.106" class="difflineplus">+    BerElement* ber,        /* message to send */</span>
<a href="#l69.107"></a><span id="l69.107">     int msgid,              /* ID of message to send */</span>
<a href="#l69.108"></a><span id="l69.108" class="difflineminus">-    LDAPRequest *parentreq, /* non-NULL for referred requests */</span>
<a href="#l69.109"></a><span id="l69.109" class="difflineminus">-    LDAPServer *srvlist,    /* servers to connect to (NULL for default) */</span>
<a href="#l69.110"></a><span id="l69.110" class="difflineminus">-    LDAPConn *lc,           /* connection to use (NULL for default) */</span>
<a href="#l69.111"></a><span id="l69.111" class="difflineminus">-    char *bindreqdn,        /* non-NULL for bind requests */</span>
<a href="#l69.112"></a><span id="l69.112" class="difflineplus">+    LDAPRequest* parentreq, /* non-NULL for referred requests */</span>
<a href="#l69.113"></a><span id="l69.113" class="difflineplus">+    LDAPServer* srvlist,    /* servers to connect to (NULL for default) */</span>
<a href="#l69.114"></a><span id="l69.114" class="difflineplus">+    LDAPConn* lc,           /* connection to use (NULL for default) */</span>
<a href="#l69.115"></a><span id="l69.115" class="difflineplus">+    char* bindreqdn,        /* non-NULL for bind requests */</span>
<a href="#l69.116"></a><span id="l69.116">     int bind                /* perform a bind after opening new conn.? */</span>
<a href="#l69.117"></a><span id="l69.117"> ) {</span>
<a href="#l69.118"></a><span id="l69.118" class="difflineminus">-  LDAPRequest *lr;</span>
<a href="#l69.119"></a><span id="l69.119" class="difflineplus">+  LDAPRequest* lr;</span>
<a href="#l69.120"></a><span id="l69.120">   int err;</span>
<a href="#l69.121"></a><span id="l69.121">   int incparent; /* did we bump parent's ref count? */</span>
<a href="#l69.122"></a><span id="l69.122">   /* EPIPE and Unsolicited Response handling variables */</span>
<a href="#l69.123"></a><span id="l69.123">   int res_rc = 0;</span>
<a href="#l69.124"></a><span id="l69.124">   int epipe_err = 0;</span>
<a href="#l69.125"></a><span id="l69.125">   int ext_res_rc = 0;</span>
<a href="#l69.126"></a><span id="l69.126" class="difflineminus">-  char *ext_oid = NULL;</span>
<a href="#l69.127"></a><span id="l69.127" class="difflineminus">-  struct berval *ext_data = NULL;</span>
<a href="#l69.128"></a><span id="l69.128" class="difflineminus">-  LDAPMessage *ext_res = NULL;</span>
<a href="#l69.129"></a><span id="l69.129" class="difflineplus">+  char* ext_oid = NULL;</span>
<a href="#l69.130"></a><span id="l69.130" class="difflineplus">+  struct berval* ext_data = NULL;</span>
<a href="#l69.131"></a><span id="l69.131" class="difflineplus">+  LDAPMessage* ext_res = NULL;</span>
<a href="#l69.132"></a><span id="l69.132"> </span>
<a href="#l69.133"></a><span id="l69.133">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_send_server_request\n&quot;, 0, 0, 0);</span>
<a href="#l69.134"></a><span id="l69.134"> </span>
<a href="#l69.135"></a><span id="l69.135">   incparent = 0;</span>
<a href="#l69.136"></a><span id="l69.136">   LDAP_MUTEX_LOCK(ld, LDAP_CONN_LOCK);</span>
<a href="#l69.137"></a><span id="l69.137">   if (lc == NULL) {</span>
<a href="#l69.138"></a><span id="l69.138">     if (srvlist == NULL) {</span>
<a href="#l69.139"></a><span id="l69.139">       if (ld-&gt;ld_defconn == NULL) {</span>
<a href="#l69.140"></a><span id="l69.140" class="difflineat">@@ -317,17 +317,17 @@ int nsldapi_send_server_request(</span>
<a href="#l69.141"></a><span id="l69.141"> </span>
<a href="#l69.142"></a><span id="l69.142">   } else {</span>
<a href="#l69.143"></a><span id="l69.143">     if ((err = nsldapi_send_ber_message(ld, lc-&gt;lconn_sb, ber,</span>
<a href="#l69.144"></a><span id="l69.144">                                         0 /* do not free ber */,</span>
<a href="#l69.145"></a><span id="l69.145">                                         1 /* will handle EPIPE */)) != 0) {</span>
<a href="#l69.146"></a><span id="l69.146">       epipe_err = LDAP_GET_ERRNO(ld);</span>
<a href="#l69.147"></a><span id="l69.147">       if (epipe_err == EPIPE) {</span>
<a href="#l69.148"></a><span id="l69.148">         res_rc = nsldapi_result_nolock(ld, LDAP_RES_UNSOLICITED, 1, 1,</span>
<a href="#l69.149"></a><span id="l69.149" class="difflineminus">-                                       (struct timeval *)NULL, &amp;ext_res);</span>
<a href="#l69.150"></a><span id="l69.150" class="difflineplus">+                                       (struct timeval*)NULL, &amp;ext_res);</span>
<a href="#l69.151"></a><span id="l69.151">         if ((res_rc == LDAP_RES_EXTENDED) &amp;&amp; ext_res) {</span>
<a href="#l69.152"></a><span id="l69.152">           ext_res_rc =</span>
<a href="#l69.153"></a><span id="l69.153">               ldap_parse_extended_result(ld, ext_res, &amp;ext_oid, &amp;ext_data, 0);</span>
<a href="#l69.154"></a><span id="l69.154">           if (ext_res_rc != LDAP_SUCCESS) {</span>
<a href="#l69.155"></a><span id="l69.155">             if (ext_res) {</span>
<a href="#l69.156"></a><span id="l69.156">               ldap_msgfree(ext_res);</span>
<a href="#l69.157"></a><span id="l69.157">             }</span>
<a href="#l69.158"></a><span id="l69.158">             nsldapi_connection_lost_nolock(ld, lc-&gt;lconn_sb);</span>
<a href="#l69.159"></a><span id="l69.159" class="difflineat">@@ -429,17 +429,17 @@ int nsldapi_send_server_request(</span>
<a href="#l69.160"></a><span id="l69.160">  * deal with EPIPE and dont call lost_nolock here but the caller</span>
<a href="#l69.161"></a><span id="l69.161">  * should call lost_nolock itself when done with handling EPIPE.</span>
<a href="#l69.162"></a><span id="l69.162">  *</span>
<a href="#l69.163"></a><span id="l69.163">  * Return values:</span>
<a href="#l69.164"></a><span id="l69.164">  *    0: message sent successfully.</span>
<a href="#l69.165"></a><span id="l69.165">  *   -1: a fatal error occurred while trying to send.</span>
<a href="#l69.166"></a><span id="l69.166">  *   -2: async. I/O is enabled and the send would block.</span>
<a href="#l69.167"></a><span id="l69.167">  */</span>
<a href="#l69.168"></a><span id="l69.168" class="difflineminus">-int nsldapi_send_ber_message(LDAP *ld, Sockbuf *sb, BerElement *ber, int freeit,</span>
<a href="#l69.169"></a><span id="l69.169" class="difflineplus">+int nsldapi_send_ber_message(LDAP* ld, Sockbuf* sb, BerElement* ber, int freeit,</span>
<a href="#l69.170"></a><span id="l69.170">                              int epipe_handler) {</span>
<a href="#l69.171"></a><span id="l69.171">   int rc = 0; /* optimistic */</span>
<a href="#l69.172"></a><span id="l69.172">   int async = (0 != (ld-&gt;ld_options &amp; LDAP_BITOPT_ASYNC));</span>
<a href="#l69.173"></a><span id="l69.173">   int more_to_send = 1;</span>
<a href="#l69.174"></a><span id="l69.174"> </span>
<a href="#l69.175"></a><span id="l69.175">   while (more_to_send) {</span>
<a href="#l69.176"></a><span id="l69.176">     /*</span>
<a href="#l69.177"></a><span id="l69.177">      * ber_flush() doesn't set errno on EOF, so we pre-set it to</span>
<a href="#l69.178"></a><span id="l69.178" class="difflineat">@@ -475,22 +475,22 @@ int nsldapi_send_ber_message(LDAP *ld, S</span>
<a href="#l69.179"></a><span id="l69.179">  *</span>
<a href="#l69.180"></a><span id="l69.180">  * Return values:  0 -- success.</span>
<a href="#l69.181"></a><span id="l69.181">  *                -1 -- fatal error; connection closed.</span>
<a href="#l69.182"></a><span id="l69.182">  *</span>
<a href="#l69.183"></a><span id="l69.183">  * Must be called with these two mutexes locked, in this order:</span>
<a href="#l69.184"></a><span id="l69.184">  * LDAP_CONN_LOCK</span>
<a href="#l69.185"></a><span id="l69.185">  * LDAP_REQ_LOCK</span>
<a href="#l69.186"></a><span id="l69.186">  */</span>
<a href="#l69.187"></a><span id="l69.187" class="difflineminus">-int nsldapi_send_pending_requests_nolock(LDAP *ld, LDAPConn *lc) {</span>
<a href="#l69.188"></a><span id="l69.188" class="difflineplus">+int nsldapi_send_pending_requests_nolock(LDAP* ld, LDAPConn* lc) {</span>
<a href="#l69.189"></a><span id="l69.189">   int err;</span>
<a href="#l69.190"></a><span id="l69.190">   int waiting_for_a_response = 0;</span>
<a href="#l69.191"></a><span id="l69.191">   int rc = 0;</span>
<a href="#l69.192"></a><span id="l69.192" class="difflineminus">-  LDAPRequest *lr;</span>
<a href="#l69.193"></a><span id="l69.193" class="difflineminus">-  char *logname = &quot;nsldapi_send_pending_requests_nolock&quot;;</span>
<a href="#l69.194"></a><span id="l69.194" class="difflineplus">+  LDAPRequest* lr;</span>
<a href="#l69.195"></a><span id="l69.195" class="difflineplus">+  char* logname = &quot;nsldapi_send_pending_requests_nolock&quot;;</span>
<a href="#l69.196"></a><span id="l69.196"> </span>
<a href="#l69.197"></a><span id="l69.197">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;%s\n&quot;, logname, 0, 0);</span>
<a href="#l69.198"></a><span id="l69.198"> </span>
<a href="#l69.199"></a><span id="l69.199">   for (lr = ld-&gt;ld_requests; lr != NULL; lr = lr-&gt;lr_next) {</span>
<a href="#l69.200"></a><span id="l69.200">     /*</span>
<a href="#l69.201"></a><span id="l69.201">      * This code relies on the fact that the ld_requests list</span>
<a href="#l69.202"></a><span id="l69.202">      * is in order from oldest to newest request (the oldest</span>
<a href="#l69.203"></a><span id="l69.203">      * requests that have not yet been sent to the server are</span>
<a href="#l69.204"></a><span id="l69.204" class="difflineat">@@ -547,30 +547,30 @@ int nsldapi_send_pending_requests_nolock</span>
<a href="#l69.205"></a><span id="l69.205">       nsldapi_iostatus_interest_read(ld, lc-&gt;lconn_sb);</span>
<a href="#l69.206"></a><span id="l69.206">     }</span>
<a href="#l69.207"></a><span id="l69.207">   }</span>
<a href="#l69.208"></a><span id="l69.208"> </span>
<a href="#l69.209"></a><span id="l69.209">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;%s &lt;- %d\n&quot;, logname, rc, 0);</span>
<a href="#l69.210"></a><span id="l69.210">   return (rc);</span>
<a href="#l69.211"></a><span id="l69.211"> }</span>
<a href="#l69.212"></a><span id="l69.212"> </span>
<a href="#l69.213"></a><span id="l69.213" class="difflineminus">-LDAPConn *nsldapi_new_connection(LDAP *ld, LDAPServer **srvlistp, int use_ldsb,</span>
<a href="#l69.214"></a><span id="l69.214" class="difflineplus">+LDAPConn* nsldapi_new_connection(LDAP* ld, LDAPServer** srvlistp, int use_ldsb,</span>
<a href="#l69.215"></a><span id="l69.215">                                  int connect, int bind) {</span>
<a href="#l69.216"></a><span id="l69.216">   int rc = -1;</span>
<a href="#l69.217"></a><span id="l69.217" class="difflineminus">-  LDAPConn *lc;</span>
<a href="#l69.218"></a><span id="l69.218" class="difflineplus">+  LDAPConn* lc;</span>
<a href="#l69.219"></a><span id="l69.219">   LDAPServer *prevsrv, *srv;</span>
<a href="#l69.220"></a><span id="l69.220" class="difflineminus">-  Sockbuf *sb = NULL;</span>
<a href="#l69.221"></a><span id="l69.221" class="difflineplus">+  Sockbuf* sb = NULL;</span>
<a href="#l69.222"></a><span id="l69.222"> </span>
<a href="#l69.223"></a><span id="l69.223">   /*</span>
<a href="#l69.224"></a><span id="l69.224">    * make a new LDAP server connection</span>
<a href="#l69.225"></a><span id="l69.225">    */</span>
<a href="#l69.226"></a><span id="l69.226" class="difflineminus">-  if ((lc = (LDAPConn *)NSLDAPI_CALLOC(1, sizeof(LDAPConn))) == NULL ||</span>
<a href="#l69.227"></a><span id="l69.227" class="difflineplus">+  if ((lc = (LDAPConn*)NSLDAPI_CALLOC(1, sizeof(LDAPConn))) == NULL ||</span>
<a href="#l69.228"></a><span id="l69.228">       (!use_ldsb &amp;&amp; (sb = ber_sockbuf_alloc()) == NULL)) {</span>
<a href="#l69.229"></a><span id="l69.229">     if (lc != NULL) {</span>
<a href="#l69.230"></a><span id="l69.230" class="difflineminus">-      NSLDAPI_FREE((char *)lc);</span>
<a href="#l69.231"></a><span id="l69.231" class="difflineplus">+      NSLDAPI_FREE((char*)lc);</span>
<a href="#l69.232"></a><span id="l69.232">     }</span>
<a href="#l69.233"></a><span id="l69.233">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l69.234"></a><span id="l69.234">     return (NULL);</span>
<a href="#l69.235"></a><span id="l69.235">   }</span>
<a href="#l69.236"></a><span id="l69.236"> </span>
<a href="#l69.237"></a><span id="l69.237">   LDAP_MUTEX_LOCK(ld, LDAP_OPTION_LOCK);</span>
<a href="#l69.238"></a><span id="l69.238">   if (!use_ldsb) {</span>
<a href="#l69.239"></a><span id="l69.239">     /*</span>
<a href="#l69.240"></a><span id="l69.240" class="difflineat">@@ -582,24 +582,24 @@ LDAPConn *nsldapi_new_connection(LDAP *l</span>
<a href="#l69.241"></a><span id="l69.241"> </span>
<a href="#l69.242"></a><span id="l69.242">     extiofns.lbextiofn_size = LBER_X_EXTIO_FNS_SIZE;</span>
<a href="#l69.243"></a><span id="l69.243"> </span>
<a href="#l69.244"></a><span id="l69.244">     if (ber_sockbuf_get_option(ld-&gt;ld_sbp, LBER_SOCKBUF_OPT_EXT_IO_FNS,</span>
<a href="#l69.245"></a><span id="l69.245">                                &amp;extiofns) == 0) {</span>
<a href="#l69.246"></a><span id="l69.246">       ber_sockbuf_set_option(sb, LBER_SOCKBUF_OPT_EXT_IO_FNS, &amp;extiofns);</span>
<a href="#l69.247"></a><span id="l69.247">     }</span>
<a href="#l69.248"></a><span id="l69.248">     if (ber_sockbuf_get_option(ld-&gt;ld_sbp, LBER_SOCKBUF_OPT_READ_FN,</span>
<a href="#l69.249"></a><span id="l69.249" class="difflineminus">-                               (void *)&amp;sb_fn) == 0 &amp;&amp;</span>
<a href="#l69.250"></a><span id="l69.250" class="difflineplus">+                               (void*)&amp;sb_fn) == 0 &amp;&amp;</span>
<a href="#l69.251"></a><span id="l69.251">         sb_fn != NULL) {</span>
<a href="#l69.252"></a><span id="l69.252" class="difflineminus">-      ber_sockbuf_set_option(sb, LBER_SOCKBUF_OPT_READ_FN, (void *)sb_fn);</span>
<a href="#l69.253"></a><span id="l69.253" class="difflineplus">+      ber_sockbuf_set_option(sb, LBER_SOCKBUF_OPT_READ_FN, (void*)sb_fn);</span>
<a href="#l69.254"></a><span id="l69.254">     }</span>
<a href="#l69.255"></a><span id="l69.255">     if (ber_sockbuf_get_option(ld-&gt;ld_sbp, LBER_SOCKBUF_OPT_WRITE_FN,</span>
<a href="#l69.256"></a><span id="l69.256" class="difflineminus">-                               (void *)&amp;sb_fn) == 0 &amp;&amp;</span>
<a href="#l69.257"></a><span id="l69.257" class="difflineplus">+                               (void*)&amp;sb_fn) == 0 &amp;&amp;</span>
<a href="#l69.258"></a><span id="l69.258">         sb_fn != NULL) {</span>
<a href="#l69.259"></a><span id="l69.259" class="difflineminus">-      ber_sockbuf_set_option(sb, LBER_SOCKBUF_OPT_WRITE_FN, (void *)sb_fn);</span>
<a href="#l69.260"></a><span id="l69.260" class="difflineplus">+      ber_sockbuf_set_option(sb, LBER_SOCKBUF_OPT_WRITE_FN, (void*)sb_fn);</span>
<a href="#l69.261"></a><span id="l69.261">     }</span>
<a href="#l69.262"></a><span id="l69.262">   }</span>
<a href="#l69.263"></a><span id="l69.263"> </span>
<a href="#l69.264"></a><span id="l69.264">   lc-&gt;lconn_sb = (use_ldsb) ? ld-&gt;ld_sbp : sb;</span>
<a href="#l69.265"></a><span id="l69.265">   lc-&gt;lconn_version = ld-&gt;ld_version; /* inherited */</span>
<a href="#l69.266"></a><span id="l69.266">   LDAP_MUTEX_UNLOCK(ld, LDAP_OPTION_LOCK);</span>
<a href="#l69.267"></a><span id="l69.267"> </span>
<a href="#l69.268"></a><span id="l69.268">   if (connect) {</span>
<a href="#l69.269"></a><span id="l69.269" class="difflineat">@@ -615,19 +615,19 @@ LDAPConn *nsldapi_new_connection(LDAP *l</span>
<a href="#l69.270"></a><span id="l69.270">       if (rc != -1) {</span>
<a href="#l69.271"></a><span id="l69.271">         break;</span>
<a href="#l69.272"></a><span id="l69.272">       }</span>
<a href="#l69.273"></a><span id="l69.273">       prevsrv = srv;</span>
<a href="#l69.274"></a><span id="l69.274">     }</span>
<a href="#l69.275"></a><span id="l69.275"> </span>
<a href="#l69.276"></a><span id="l69.276">     if (srv == NULL) {</span>
<a href="#l69.277"></a><span id="l69.277">       if (!use_ldsb) {</span>
<a href="#l69.278"></a><span id="l69.278" class="difflineminus">-        NSLDAPI_FREE((char *)lc-&gt;lconn_sb);</span>
<a href="#l69.279"></a><span id="l69.279" class="difflineplus">+        NSLDAPI_FREE((char*)lc-&gt;lconn_sb);</span>
<a href="#l69.280"></a><span id="l69.280">       }</span>
<a href="#l69.281"></a><span id="l69.281" class="difflineminus">-      NSLDAPI_FREE((char *)lc);</span>
<a href="#l69.282"></a><span id="l69.282" class="difflineplus">+      NSLDAPI_FREE((char*)lc);</span>
<a href="#l69.283"></a><span id="l69.283">       /* nsldapi_open_ldap_connection has already set ld_errno */</span>
<a href="#l69.284"></a><span id="l69.284">       return (NULL);</span>
<a href="#l69.285"></a><span id="l69.285">     }</span>
<a href="#l69.286"></a><span id="l69.286"> </span>
<a href="#l69.287"></a><span id="l69.287">     if (prevsrv == NULL) {</span>
<a href="#l69.288"></a><span id="l69.288">       *srvlistp = srv-&gt;lsrv_next;</span>
<a href="#l69.289"></a><span id="l69.289">     } else {</span>
<a href="#l69.290"></a><span id="l69.290">       prevsrv-&gt;lsrv_next = srv-&gt;lsrv_next;</span>
<a href="#l69.291"></a><span id="l69.291" class="difflineat">@@ -652,17 +652,17 @@ LDAPConn *nsldapi_new_connection(LDAP *l</span>
<a href="#l69.292"></a><span id="l69.292"> </span>
<a href="#l69.293"></a><span id="l69.293">   /*</span>
<a href="#l69.294"></a><span id="l69.294">    * XXX for now, we always do a synchronous bind.  This will have</span>
<a href="#l69.295"></a><span id="l69.295">    * to change in the long run...</span>
<a href="#l69.296"></a><span id="l69.296">    */</span>
<a href="#l69.297"></a><span id="l69.297">   if (bind) {</span>
<a href="#l69.298"></a><span id="l69.298">     int err, lderr, freepasswd, authmethod;</span>
<a href="#l69.299"></a><span id="l69.299">     char *binddn, *passwd;</span>
<a href="#l69.300"></a><span id="l69.300" class="difflineminus">-    LDAPConn *savedefconn;</span>
<a href="#l69.301"></a><span id="l69.301" class="difflineplus">+    LDAPConn* savedefconn;</span>
<a href="#l69.302"></a><span id="l69.302"> </span>
<a href="#l69.303"></a><span id="l69.303">     freepasswd = err = 0;</span>
<a href="#l69.304"></a><span id="l69.304"> </span>
<a href="#l69.305"></a><span id="l69.305">     if (ld-&gt;ld_rebind_fn == NULL) {</span>
<a href="#l69.306"></a><span id="l69.306">       binddn = passwd = &quot;&quot;;</span>
<a href="#l69.307"></a><span id="l69.307">       authmethod = LDAP_AUTH_SIMPLE;</span>
<a href="#l69.308"></a><span id="l69.308">     } else {</span>
<a href="#l69.309"></a><span id="l69.309">       if ((lderr = (*ld-&gt;ld_rebind_fn)(ld, &amp;binddn, &amp;passwd, &amp;authmethod, 0,</span>
<a href="#l69.310"></a><span id="l69.310" class="difflineat">@@ -715,24 +715,24 @@ LDAPConn *nsldapi_new_connection(LDAP *l</span>
<a href="#l69.311"></a><span id="l69.311"> </span>
<a href="#l69.312"></a><span id="l69.312">   return (lc);</span>
<a href="#l69.313"></a><span id="l69.313"> }</span>
<a href="#l69.314"></a><span id="l69.314"> </span>
<a href="#l69.315"></a><span id="l69.315"> #define LDAP_CONN_SAMEHOST(h1, h2)   \</span>
<a href="#l69.316"></a><span id="l69.316">   (((h1) == NULL &amp;&amp; (h2) == NULL) || \</span>
<a href="#l69.317"></a><span id="l69.317">    ((h1) != NULL &amp;&amp; (h2) != NULL &amp;&amp; strcasecmp((h1), (h2)) == 0))</span>
<a href="#l69.318"></a><span id="l69.318"> </span>
<a href="#l69.319"></a><span id="l69.319" class="difflineminus">-static LDAPConn *find_connection(LDAP *ld, LDAPServer *srv, int any)</span>
<a href="#l69.320"></a><span id="l69.320" class="difflineplus">+static LDAPConn* find_connection(LDAP* ld, LDAPServer* srv, int any)</span>
<a href="#l69.321"></a><span id="l69.321"> /*</span>
<a href="#l69.322"></a><span id="l69.322">  * return an existing connection (if any) to the server srv</span>
<a href="#l69.323"></a><span id="l69.323">  * if &quot;any&quot; is non-zero, check for any server in the &quot;srv&quot; chain</span>
<a href="#l69.324"></a><span id="l69.324">  */</span>
<a href="#l69.325"></a><span id="l69.325"> {</span>
<a href="#l69.326"></a><span id="l69.326" class="difflineminus">-  LDAPConn *lc;</span>
<a href="#l69.327"></a><span id="l69.327" class="difflineminus">-  LDAPServer *ls;</span>
<a href="#l69.328"></a><span id="l69.328" class="difflineplus">+  LDAPConn* lc;</span>
<a href="#l69.329"></a><span id="l69.329" class="difflineplus">+  LDAPServer* ls;</span>
<a href="#l69.330"></a><span id="l69.330"> </span>
<a href="#l69.331"></a><span id="l69.331">   for (lc = ld-&gt;ld_conns; lc != NULL; lc = lc-&gt;lconn_next) {</span>
<a href="#l69.332"></a><span id="l69.332">     for (ls = srv; ls != NULL; ls = ls-&gt;lsrv_next) {</span>
<a href="#l69.333"></a><span id="l69.333">       if (LDAP_CONN_SAMEHOST(ls-&gt;lsrv_host, lc-&gt;lconn_server-&gt;lsrv_host) &amp;&amp;</span>
<a href="#l69.334"></a><span id="l69.334">           ls-&gt;lsrv_port == lc-&gt;lconn_server-&gt;lsrv_port &amp;&amp;</span>
<a href="#l69.335"></a><span id="l69.335">           ls-&gt;lsrv_options == lc-&gt;lconn_server-&gt;lsrv_options) {</span>
<a href="#l69.336"></a><span id="l69.336">         return (lc);</span>
<a href="#l69.337"></a><span id="l69.337">       }</span>
<a href="#l69.338"></a><span id="l69.338" class="difflineat">@@ -740,18 +740,18 @@ static LDAPConn *find_connection(LDAP *l</span>
<a href="#l69.339"></a><span id="l69.339">         break;</span>
<a href="#l69.340"></a><span id="l69.340">       }</span>
<a href="#l69.341"></a><span id="l69.341">     }</span>
<a href="#l69.342"></a><span id="l69.342">   }</span>
<a href="#l69.343"></a><span id="l69.343"> </span>
<a href="#l69.344"></a><span id="l69.344">   return (NULL);</span>
<a href="#l69.345"></a><span id="l69.345"> }</span>
<a href="#l69.346"></a><span id="l69.346"> </span>
<a href="#l69.347"></a><span id="l69.347" class="difflineminus">-void nsldapi_free_connection(LDAP *ld, LDAPConn *lc, LDAPControl **serverctrls,</span>
<a href="#l69.348"></a><span id="l69.348" class="difflineminus">-                             LDAPControl **clientctrls, int force, int unbind) {</span>
<a href="#l69.349"></a><span id="l69.349" class="difflineplus">+void nsldapi_free_connection(LDAP* ld, LDAPConn* lc, LDAPControl** serverctrls,</span>
<a href="#l69.350"></a><span id="l69.350" class="difflineplus">+                             LDAPControl** clientctrls, int force, int unbind) {</span>
<a href="#l69.351"></a><span id="l69.351">   LDAPConn *tmplc, *prevlc;</span>
<a href="#l69.352"></a><span id="l69.352"> </span>
<a href="#l69.353"></a><span id="l69.353">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_free_connection\n&quot;, 0, 0, 0);</span>
<a href="#l69.354"></a><span id="l69.354"> </span>
<a href="#l69.355"></a><span id="l69.355">   if (force || --lc-&gt;lconn_refcnt &lt;= 0) {</span>
<a href="#l69.356"></a><span id="l69.356">     nsldapi_iostatus_interest_clear(ld, lc-&gt;lconn_sb);</span>
<a href="#l69.357"></a><span id="l69.357">     if (lc-&gt;lconn_status == LDAP_CONNST_CONNECTED) {</span>
<a href="#l69.358"></a><span id="l69.358">       if (unbind) {</span>
<a href="#l69.359"></a><span id="l69.359" class="difflineat">@@ -802,18 +802,18 @@ void nsldapi_free_connection(LDAP *ld, L</span>
<a href="#l69.360"></a><span id="l69.360">   } else {</span>
<a href="#l69.361"></a><span id="l69.361">     lc-&gt;lconn_lastused = time(0);</span>
<a href="#l69.362"></a><span id="l69.362">     LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_free_connection: refcnt %d\n&quot;,</span>
<a href="#l69.363"></a><span id="l69.363">               lc-&gt;lconn_refcnt, 0, 0);</span>
<a href="#l69.364"></a><span id="l69.364">   }</span>
<a href="#l69.365"></a><span id="l69.365"> }</span>
<a href="#l69.366"></a><span id="l69.366"> </span>
<a href="#l69.367"></a><span id="l69.367"> #ifdef LDAP_DEBUG</span>
<a href="#l69.368"></a><span id="l69.368" class="difflineminus">-void nsldapi_dump_connection(LDAP *ld, LDAPConn *lconns, int all) {</span>
<a href="#l69.369"></a><span id="l69.369" class="difflineminus">-  LDAPConn *lc;</span>
<a href="#l69.370"></a><span id="l69.370" class="difflineplus">+void nsldapi_dump_connection(LDAP* ld, LDAPConn* lconns, int all) {</span>
<a href="#l69.371"></a><span id="l69.371" class="difflineplus">+  LDAPConn* lc;</span>
<a href="#l69.372"></a><span id="l69.372">   char msg[256];</span>
<a href="#l69.373"></a><span id="l69.373"> /* CTIME for this platform doesn't use this. */</span>
<a href="#l69.374"></a><span id="l69.374"> #  if !defined(SUNOS4) &amp;&amp; !defined(_WIN32) &amp;&amp; !defined(LINUX) &amp;&amp; \</span>
<a href="#l69.375"></a><span id="l69.375">       !defined(macintosh)</span>
<a href="#l69.376"></a><span id="l69.376">   char buf[26];</span>
<a href="#l69.377"></a><span id="l69.377"> #  endif</span>
<a href="#l69.378"></a><span id="l69.378"> </span>
<a href="#l69.379"></a><span id="l69.379">   sprintf(msg, &quot;** Connection%s:\n&quot;, all ? &quot;s&quot; : &quot;&quot;);</span>
<a href="#l69.380"></a><span id="l69.380" class="difflineat">@@ -832,32 +832,32 @@ void nsldapi_dump_connection(LDAP *ld, L</span>
<a href="#l69.381"></a><span id="l69.381">     sprintf(</span>
<a href="#l69.382"></a><span id="l69.382">         msg, &quot;  refcnt: %d  pending: %d  status: %s\n&quot;, lc-&gt;lconn_refcnt,</span>
<a href="#l69.383"></a><span id="l69.383">         lc-&gt;lconn_pending_requests,</span>
<a href="#l69.384"></a><span id="l69.384">         (lc-&gt;lconn_status == LDAP_CONNST_CONNECTING)</span>
<a href="#l69.385"></a><span id="l69.385">             ? &quot;Connecting&quot;</span>
<a href="#l69.386"></a><span id="l69.386">             : (lc-&gt;lconn_status == LDAP_CONNST_DEAD) ? &quot;Dead&quot; : &quot;Connected&quot;);</span>
<a href="#l69.387"></a><span id="l69.387">     ber_err_print(msg);</span>
<a href="#l69.388"></a><span id="l69.388">     sprintf(msg, &quot;  last used: %s&quot;,</span>
<a href="#l69.389"></a><span id="l69.389" class="difflineminus">-            NSLDAPI_CTIME((time_t *)&amp;lc-&gt;lconn_lastused, buf, sizeof(buf)));</span>
<a href="#l69.390"></a><span id="l69.390" class="difflineplus">+            NSLDAPI_CTIME((time_t*)&amp;lc-&gt;lconn_lastused, buf, sizeof(buf)));</span>
<a href="#l69.391"></a><span id="l69.391">     ber_err_print(msg);</span>
<a href="#l69.392"></a><span id="l69.392">     if (lc-&gt;lconn_ber != NULLBER) {</span>
<a href="#l69.393"></a><span id="l69.393">       ber_err_print(&quot;  partial response has been received:\n&quot;);</span>
<a href="#l69.394"></a><span id="l69.394">       ber_dump(lc-&gt;lconn_ber, 1);</span>
<a href="#l69.395"></a><span id="l69.395">     }</span>
<a href="#l69.396"></a><span id="l69.396">     ber_err_print(&quot;\n&quot;);</span>
<a href="#l69.397"></a><span id="l69.397"> </span>
<a href="#l69.398"></a><span id="l69.398">     if (!all) {</span>
<a href="#l69.399"></a><span id="l69.399">       break;</span>
<a href="#l69.400"></a><span id="l69.400">     }</span>
<a href="#l69.401"></a><span id="l69.401">   }</span>
<a href="#l69.402"></a><span id="l69.402"> }</span>
<a href="#l69.403"></a><span id="l69.403"> </span>
<a href="#l69.404"></a><span id="l69.404" class="difflineminus">-void nsldapi_dump_requests_and_responses(LDAP *ld) {</span>
<a href="#l69.405"></a><span id="l69.405" class="difflineminus">-  LDAPRequest *lr;</span>
<a href="#l69.406"></a><span id="l69.406" class="difflineplus">+void nsldapi_dump_requests_and_responses(LDAP* ld) {</span>
<a href="#l69.407"></a><span id="l69.407" class="difflineplus">+  LDAPRequest* lr;</span>
<a href="#l69.408"></a><span id="l69.408">   LDAPMessage *lm, *l;</span>
<a href="#l69.409"></a><span id="l69.409">   char msg[256];</span>
<a href="#l69.410"></a><span id="l69.410"> </span>
<a href="#l69.411"></a><span id="l69.411">   ber_err_print(&quot;** Outstanding Requests:\n&quot;);</span>
<a href="#l69.412"></a><span id="l69.412">   LDAP_MUTEX_LOCK(ld, LDAP_REQ_LOCK);</span>
<a href="#l69.413"></a><span id="l69.413">   if ((lr = ld-&gt;ld_requests) == NULL) {</span>
<a href="#l69.414"></a><span id="l69.414">     ber_err_print(&quot;   Empty\n&quot;);</span>
<a href="#l69.415"></a><span id="l69.415">   }</span>
<a href="#l69.416"></a><span id="l69.416" class="difflineat">@@ -898,21 +898,21 @@ void nsldapi_dump_requests_and_responses</span>
<a href="#l69.417"></a><span id="l69.417">         ber_err_print(msg);</span>
<a href="#l69.418"></a><span id="l69.418">       }</span>
<a href="#l69.419"></a><span id="l69.419">     }</span>
<a href="#l69.420"></a><span id="l69.420">   }</span>
<a href="#l69.421"></a><span id="l69.421">   LDAP_MUTEX_UNLOCK(ld, LDAP_RESP_LOCK);</span>
<a href="#l69.422"></a><span id="l69.422"> }</span>
<a href="#l69.423"></a><span id="l69.423"> #endif /* LDAP_DEBUG */</span>
<a href="#l69.424"></a><span id="l69.424"> </span>
<a href="#l69.425"></a><span id="l69.425" class="difflineminus">-LDAPRequest *nsldapi_new_request(LDAPConn *lc, BerElement *ber, int msgid,</span>
<a href="#l69.426"></a><span id="l69.426" class="difflineplus">+LDAPRequest* nsldapi_new_request(LDAPConn* lc, BerElement* ber, int msgid,</span>
<a href="#l69.427"></a><span id="l69.427">                                  int expect_resp) {</span>
<a href="#l69.428"></a><span id="l69.428" class="difflineminus">-  LDAPRequest *lr;</span>
<a href="#l69.429"></a><span id="l69.429" class="difflineplus">+  LDAPRequest* lr;</span>
<a href="#l69.430"></a><span id="l69.430"> </span>
<a href="#l69.431"></a><span id="l69.431" class="difflineminus">-  lr = (LDAPRequest *)NSLDAPI_CALLOC(1, sizeof(LDAPRequest));</span>
<a href="#l69.432"></a><span id="l69.432" class="difflineplus">+  lr = (LDAPRequest*)NSLDAPI_CALLOC(1, sizeof(LDAPRequest));</span>
<a href="#l69.433"></a><span id="l69.433"> </span>
<a href="#l69.434"></a><span id="l69.434">   if (lr != NULL) {</span>
<a href="#l69.435"></a><span id="l69.435">     lr-&gt;lr_conn = lc;</span>
<a href="#l69.436"></a><span id="l69.436">     lr-&gt;lr_ber = ber;</span>
<a href="#l69.437"></a><span id="l69.437">     lr-&gt;lr_msgid = lr-&gt;lr_origid = msgid;</span>
<a href="#l69.438"></a><span id="l69.438">     lr-&gt;lr_expect_resp = expect_resp;</span>
<a href="#l69.439"></a><span id="l69.439">     lr-&gt;lr_status = LDAP_REQST_INPROGRESS;</span>
<a href="#l69.440"></a><span id="l69.440">     lr-&gt;lr_res_errno = LDAP_SUCCESS; /* optimistic */</span>
<a href="#l69.441"></a><span id="l69.441" class="difflineat">@@ -921,17 +921,17 @@ LDAPRequest *nsldapi_new_request(LDAPCon</span>
<a href="#l69.442"></a><span id="l69.442">       ++lc-&gt;lconn_refcnt;</span>
<a href="#l69.443"></a><span id="l69.443">       lc-&gt;lconn_lastused = time(0);</span>
<a href="#l69.444"></a><span id="l69.444">     }</span>
<a href="#l69.445"></a><span id="l69.445">   }</span>
<a href="#l69.446"></a><span id="l69.446"> </span>
<a href="#l69.447"></a><span id="l69.447">   return (lr);</span>
<a href="#l69.448"></a><span id="l69.448"> }</span>
<a href="#l69.449"></a><span id="l69.449"> </span>
<a href="#l69.450"></a><span id="l69.450" class="difflineminus">-void nsldapi_free_request(LDAP *ld, LDAPRequest *lr, int free_conn) {</span>
<a href="#l69.451"></a><span id="l69.451" class="difflineplus">+void nsldapi_free_request(LDAP* ld, LDAPRequest* lr, int free_conn) {</span>
<a href="#l69.452"></a><span id="l69.452">   LDAPRequest *tmplr, *nextlr;</span>
<a href="#l69.453"></a><span id="l69.453"> </span>
<a href="#l69.454"></a><span id="l69.454">   LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l69.455"></a><span id="l69.455">             &quot;nsldapi_free_request 0x%p (origid %d, msgid %d)\n&quot;, lr,</span>
<a href="#l69.456"></a><span id="l69.456">             lr-&gt;lr_origid, lr-&gt;lr_msgid);</span>
<a href="#l69.457"></a><span id="l69.457"> </span>
<a href="#l69.458"></a><span id="l69.458">   if (lr-&gt;lr_parent != NULL) {</span>
<a href="#l69.459"></a><span id="l69.459">     /* unlink child from parent */</span>
<a href="#l69.460"></a><span id="l69.460" class="difflineat">@@ -987,33 +987,33 @@ void nsldapi_free_request(LDAP *ld, LDAP</span>
<a href="#l69.461"></a><span id="l69.461"> </span>
<a href="#l69.462"></a><span id="l69.462"> /*</span>
<a href="#l69.463"></a><span id="l69.463">  * Add a request to the end of the list of outstanding requests.</span>
<a href="#l69.464"></a><span id="l69.464">  * This function must be called with these two locks in hand, acquired in</span>
<a href="#l69.465"></a><span id="l69.465">  * this order:</span>
<a href="#l69.466"></a><span id="l69.466">  * LDAP_CONN_LOCK</span>
<a href="#l69.467"></a><span id="l69.467">  * LDAP_REQ_LOCK</span>
<a href="#l69.468"></a><span id="l69.468">  */</span>
<a href="#l69.469"></a><span id="l69.469" class="difflineminus">-void nsldapi_queue_request_nolock(LDAP *ld, LDAPRequest *lr) {</span>
<a href="#l69.470"></a><span id="l69.470" class="difflineplus">+void nsldapi_queue_request_nolock(LDAP* ld, LDAPRequest* lr) {</span>
<a href="#l69.471"></a><span id="l69.471">   if (NULL == ld-&gt;ld_requests) {</span>
<a href="#l69.472"></a><span id="l69.472">     ld-&gt;ld_requests = lr;</span>
<a href="#l69.473"></a><span id="l69.473">   } else {</span>
<a href="#l69.474"></a><span id="l69.474" class="difflineminus">-    LDAPRequest *tmplr;</span>
<a href="#l69.475"></a><span id="l69.475" class="difflineplus">+    LDAPRequest* tmplr;</span>
<a href="#l69.476"></a><span id="l69.476"> </span>
<a href="#l69.477"></a><span id="l69.477">     for (tmplr = ld-&gt;ld_requests; tmplr-&gt;lr_next != NULL;</span>
<a href="#l69.478"></a><span id="l69.478">          tmplr = tmplr-&gt;lr_next) {</span>
<a href="#l69.479"></a><span id="l69.479">       ;</span>
<a href="#l69.480"></a><span id="l69.480">     }</span>
<a href="#l69.481"></a><span id="l69.481">     tmplr-&gt;lr_next = lr;</span>
<a href="#l69.482"></a><span id="l69.482">     lr-&gt;lr_prev = tmplr;</span>
<a href="#l69.483"></a><span id="l69.483">   }</span>
<a href="#l69.484"></a><span id="l69.484"> }</span>
<a href="#l69.485"></a><span id="l69.485"> </span>
<a href="#l69.486"></a><span id="l69.486" class="difflineminus">-static void free_servers(LDAPServer *srvlist) {</span>
<a href="#l69.487"></a><span id="l69.487" class="difflineminus">-  LDAPServer *nextsrv;</span>
<a href="#l69.488"></a><span id="l69.488" class="difflineplus">+static void free_servers(LDAPServer* srvlist) {</span>
<a href="#l69.489"></a><span id="l69.489" class="difflineplus">+  LDAPServer* nextsrv;</span>
<a href="#l69.490"></a><span id="l69.490"> </span>
<a href="#l69.491"></a><span id="l69.491">   while (srvlist != NULL) {</span>
<a href="#l69.492"></a><span id="l69.492">     nextsrv = srvlist-&gt;lsrv_next;</span>
<a href="#l69.493"></a><span id="l69.493">     if (srvlist-&gt;lsrv_dn != NULL) {</span>
<a href="#l69.494"></a><span id="l69.494">       NSLDAPI_FREE(srvlist-&gt;lsrv_dn);</span>
<a href="#l69.495"></a><span id="l69.495">     }</span>
<a href="#l69.496"></a><span id="l69.496">     if (srvlist-&gt;lsrv_host != NULL) {</span>
<a href="#l69.497"></a><span id="l69.497">       NSLDAPI_FREE(srvlist-&gt;lsrv_host);</span>
<a href="#l69.498"></a><span id="l69.498" class="difflineat">@@ -1028,20 +1028,20 @@ static void free_servers(LDAPServer *srv</span>
<a href="#l69.499"></a><span id="l69.499">  *</span>
<a href="#l69.500"></a><span id="l69.500">  * Returns an LDAP error code.</span>
<a href="#l69.501"></a><span id="l69.501">  *</span>
<a href="#l69.502"></a><span id="l69.502">  * Note that *hadrefp will be set to 1 if one or more referrals were found in</span>
<a href="#l69.503"></a><span id="l69.503">  * &quot;*errstrp&quot; (even if we can't chase them) and zero if none were found.</span>
<a href="#l69.504"></a><span id="l69.504">  *</span>
<a href="#l69.505"></a><span id="l69.505">  * XXX merging of errors in this routine needs to be improved.</span>
<a href="#l69.506"></a><span id="l69.506">  */</span>
<a href="#l69.507"></a><span id="l69.507" class="difflineminus">-int nsldapi_chase_v2_referrals(LDAP *ld, LDAPRequest *lr, char **errstrp,</span>
<a href="#l69.508"></a><span id="l69.508" class="difflineminus">-                               int *totalcountp, int *chasingcountp) {</span>
<a href="#l69.509"></a><span id="l69.509" class="difflineplus">+int nsldapi_chase_v2_referrals(LDAP* ld, LDAPRequest* lr, char** errstrp,</span>
<a href="#l69.510"></a><span id="l69.510" class="difflineplus">+                               int* totalcountp, int* chasingcountp) {</span>
<a href="#l69.511"></a><span id="l69.511">   char *p, *ref, *unfollowed;</span>
<a href="#l69.512"></a><span id="l69.512" class="difflineminus">-  LDAPRequest *origreq;</span>
<a href="#l69.513"></a><span id="l69.513" class="difflineplus">+  LDAPRequest* origreq;</span>
<a href="#l69.514"></a><span id="l69.514">   int rc, tmprc, len, unknown;</span>
<a href="#l69.515"></a><span id="l69.515"> </span>
<a href="#l69.516"></a><span id="l69.516">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_chase_v2_referrals\n&quot;, 0, 0, 0);</span>
<a href="#l69.517"></a><span id="l69.517"> </span>
<a href="#l69.518"></a><span id="l69.518">   *totalcountp = *chasingcountp = 0;</span>
<a href="#l69.519"></a><span id="l69.519"> </span>
<a href="#l69.520"></a><span id="l69.520">   if (*errstrp == NULL) {</span>
<a href="#l69.521"></a><span id="l69.521">     return (LDAP_SUCCESS);</span>
<a href="#l69.522"></a><span id="l69.522" class="difflineat">@@ -1100,22 +1100,22 @@ int nsldapi_chase_v2_referrals(LDAP *ld,</span>
<a href="#l69.523"></a><span id="l69.523"> </span>
<a href="#l69.524"></a><span id="l69.524">   NSLDAPI_FREE(*errstrp);</span>
<a href="#l69.525"></a><span id="l69.525">   *errstrp = unfollowed;</span>
<a href="#l69.526"></a><span id="l69.526"> </span>
<a href="#l69.527"></a><span id="l69.527">   return (rc);</span>
<a href="#l69.528"></a><span id="l69.528"> }</span>
<a href="#l69.529"></a><span id="l69.529"> </span>
<a href="#l69.530"></a><span id="l69.530"> /* returns an LDAP error code */</span>
<a href="#l69.531"></a><span id="l69.531" class="difflineminus">-int nsldapi_chase_v3_refs(LDAP *ld, LDAPRequest *lr, char **v3refs,</span>
<a href="#l69.532"></a><span id="l69.532" class="difflineminus">-                          int is_reference, int *totalcountp,</span>
<a href="#l69.533"></a><span id="l69.533" class="difflineminus">-                          int *chasingcountp) {</span>
<a href="#l69.534"></a><span id="l69.534" class="difflineplus">+int nsldapi_chase_v3_refs(LDAP* ld, LDAPRequest* lr, char** v3refs,</span>
<a href="#l69.535"></a><span id="l69.535" class="difflineplus">+                          int is_reference, int* totalcountp,</span>
<a href="#l69.536"></a><span id="l69.536" class="difflineplus">+                          int* chasingcountp) {</span>
<a href="#l69.537"></a><span id="l69.537">   int rc = LDAP_SUCCESS;</span>
<a href="#l69.538"></a><span id="l69.538">   int i, unknown;</span>
<a href="#l69.539"></a><span id="l69.539" class="difflineminus">-  LDAPRequest *origreq;</span>
<a href="#l69.540"></a><span id="l69.540" class="difflineplus">+  LDAPRequest* origreq;</span>
<a href="#l69.541"></a><span id="l69.541"> </span>
<a href="#l69.542"></a><span id="l69.542">   *totalcountp = *chasingcountp = 0;</span>
<a href="#l69.543"></a><span id="l69.543"> </span>
<a href="#l69.544"></a><span id="l69.544">   if (v3refs == NULL || v3refs[0] == NULL) {</span>
<a href="#l69.545"></a><span id="l69.545">     return (LDAP_SUCCESS);</span>
<a href="#l69.546"></a><span id="l69.546">   }</span>
<a href="#l69.547"></a><span id="l69.547"> </span>
<a href="#l69.548"></a><span id="l69.548">   *totalcountp = 1;</span>
<a href="#l69.549"></a><span id="l69.549" class="difflineat">@@ -1154,23 +1154,23 @@ int nsldapi_chase_v3_refs(LDAP *ld, LDAP</span>
<a href="#l69.550"></a><span id="l69.550"> </span>
<a href="#l69.551"></a><span id="l69.551"> /*</span>
<a href="#l69.552"></a><span id="l69.552">  * returns an LDAP error code</span>
<a href="#l69.553"></a><span id="l69.553">  *</span>
<a href="#l69.554"></a><span id="l69.554">  * XXXmcs: this function used to have #ifdef LDAP_DNS code in it but I</span>
<a href="#l69.555"></a><span id="l69.555">  * removed it when I improved the parsing (we don't define LDAP_DNS</span>
<a href="#l69.556"></a><span id="l69.556">  * here at Netscape).</span>
<a href="#l69.557"></a><span id="l69.557">  */</span>
<a href="#l69.558"></a><span id="l69.558" class="difflineminus">-static int chase_one_referral(LDAP *ld, LDAPRequest *lr, LDAPRequest *origreq,</span>
<a href="#l69.559"></a><span id="l69.559" class="difflineminus">-                              char *refurl, char *desc, int *unknownp,</span>
<a href="#l69.560"></a><span id="l69.560" class="difflineplus">+static int chase_one_referral(LDAP* ld, LDAPRequest* lr, LDAPRequest* origreq,</span>
<a href="#l69.561"></a><span id="l69.561" class="difflineplus">+                              char* refurl, char* desc, int* unknownp,</span>
<a href="#l69.562"></a><span id="l69.562">                               int is_reference) {</span>
<a href="#l69.563"></a><span id="l69.563">   int rc, tmprc, secure, msgid;</span>
<a href="#l69.564"></a><span id="l69.564" class="difflineminus">-  LDAPServer *srv;</span>
<a href="#l69.565"></a><span id="l69.565" class="difflineminus">-  BerElement *ber;</span>
<a href="#l69.566"></a><span id="l69.566" class="difflineminus">-  LDAPURLDesc *ludp;</span>
<a href="#l69.567"></a><span id="l69.567" class="difflineplus">+  LDAPServer* srv;</span>
<a href="#l69.568"></a><span id="l69.568" class="difflineplus">+  BerElement* ber;</span>
<a href="#l69.569"></a><span id="l69.569" class="difflineplus">+  LDAPURLDesc* ludp;</span>
<a href="#l69.570"></a><span id="l69.570"> </span>
<a href="#l69.571"></a><span id="l69.571">   *unknownp = 0;</span>
<a href="#l69.572"></a><span id="l69.572">   ludp = NULLLDAPURLDESC;</span>
<a href="#l69.573"></a><span id="l69.573"> </span>
<a href="#l69.574"></a><span id="l69.574">   if (nsldapi_url_parse(refurl, &amp;ludp, 0) != 0) {</span>
<a href="#l69.575"></a><span id="l69.575">     LDAPDebug(LDAP_DEBUG_TRACE, &quot;ignoring unknown %s &lt;%s&gt;\n&quot;, desc, refurl, 0);</span>
<a href="#l69.576"></a><span id="l69.576">     *unknownp = 1;</span>
<a href="#l69.577"></a><span id="l69.577">     rc = LDAP_SUCCESS;</span>
<a href="#l69.578"></a><span id="l69.578" class="difflineat">@@ -1195,17 +1195,17 @@ static int chase_one_referral(LDAP *ld, </span>
<a href="#l69.579"></a><span id="l69.579">   LDAP_MUTEX_UNLOCK(ld, LDAP_MSGID_LOCK);</span>
<a href="#l69.580"></a><span id="l69.580"> </span>
<a href="#l69.581"></a><span id="l69.581">   if ((tmprc = re_encode_request(ld, origreq-&gt;lr_ber, msgid, ludp, &amp;ber,</span>
<a href="#l69.582"></a><span id="l69.582">                                  is_reference)) != LDAP_SUCCESS) {</span>
<a href="#l69.583"></a><span id="l69.583">     rc = tmprc;</span>
<a href="#l69.584"></a><span id="l69.584">     goto cleanup_and_return;</span>
<a href="#l69.585"></a><span id="l69.585">   }</span>
<a href="#l69.586"></a><span id="l69.586"> </span>
<a href="#l69.587"></a><span id="l69.587" class="difflineminus">-  if ((srv = (LDAPServer *)NSLDAPI_CALLOC(1, sizeof(LDAPServer))) == NULL) {</span>
<a href="#l69.588"></a><span id="l69.588" class="difflineplus">+  if ((srv = (LDAPServer*)NSLDAPI_CALLOC(1, sizeof(LDAPServer))) == NULL) {</span>
<a href="#l69.589"></a><span id="l69.589">     ber_free(ber, 1);</span>
<a href="#l69.590"></a><span id="l69.590">     rc = LDAP_NO_MEMORY;</span>
<a href="#l69.591"></a><span id="l69.591">     goto cleanup_and_return;</span>
<a href="#l69.592"></a><span id="l69.592">   }</span>
<a href="#l69.593"></a><span id="l69.593"> </span>
<a href="#l69.594"></a><span id="l69.594">   if (ludp-&gt;lud_host == NULL &amp;&amp; ld-&gt;ld_defhost == NULL) {</span>
<a href="#l69.595"></a><span id="l69.595">     srv-&gt;lsrv_host = NULL;</span>
<a href="#l69.596"></a><span id="l69.596">   } else {</span>
<a href="#l69.597"></a><span id="l69.597" class="difflineat">@@ -1220,17 +1220,17 @@ static int chase_one_referral(LDAP *ld, </span>
<a href="#l69.598"></a><span id="l69.598">       srv-&gt;lsrv_host = nsldapi_strdup(ludp-&gt;lud_host);</span>
<a href="#l69.599"></a><span id="l69.599">       LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l69.600"></a><span id="l69.600">                 &quot;chase_one_referral: using hostname '%s' as specified &quot;</span>
<a href="#l69.601"></a><span id="l69.601">                 &quot;on new request\n&quot;,</span>
<a href="#l69.602"></a><span id="l69.602">                 srv-&gt;lsrv_host, 0, 0);</span>
<a href="#l69.603"></a><span id="l69.603">     }</span>
<a href="#l69.604"></a><span id="l69.604"> </span>
<a href="#l69.605"></a><span id="l69.605">     if (srv-&gt;lsrv_host == NULL) {</span>
<a href="#l69.606"></a><span id="l69.606" class="difflineminus">-      NSLDAPI_FREE((char *)srv);</span>
<a href="#l69.607"></a><span id="l69.607" class="difflineplus">+      NSLDAPI_FREE((char*)srv);</span>
<a href="#l69.608"></a><span id="l69.608">       ber_free(ber, 1);</span>
<a href="#l69.609"></a><span id="l69.609">       rc = LDAP_NO_MEMORY;</span>
<a href="#l69.610"></a><span id="l69.610">       goto cleanup_and_return;</span>
<a href="#l69.611"></a><span id="l69.611">     }</span>
<a href="#l69.612"></a><span id="l69.612">   }</span>
<a href="#l69.613"></a><span id="l69.613"> </span>
<a href="#l69.614"></a><span id="l69.614">   if (ludp-&gt;lud_port == 0 &amp;&amp; ludp-&gt;lud_host == NULL) {</span>
<a href="#l69.615"></a><span id="l69.615">     srv-&gt;lsrv_port = origreq-&gt;lr_conn-&gt;lconn_server-&gt;lsrv_port;</span>
<a href="#l69.616"></a><span id="l69.616" class="difflineat">@@ -1266,26 +1266,26 @@ cleanup_and_return:</span>
<a href="#l69.617"></a><span id="l69.617">   if (ludp != NULLLDAPURLDESC) {</span>
<a href="#l69.618"></a><span id="l69.618">     ldap_free_urldesc(ludp);</span>
<a href="#l69.619"></a><span id="l69.619">   }</span>
<a href="#l69.620"></a><span id="l69.620"> </span>
<a href="#l69.621"></a><span id="l69.621">   return (rc);</span>
<a href="#l69.622"></a><span id="l69.622"> }</span>
<a href="#l69.623"></a><span id="l69.623"> </span>
<a href="#l69.624"></a><span id="l69.624"> /* returns an LDAP error code */</span>
<a href="#l69.625"></a><span id="l69.625" class="difflineminus">-int nsldapi_append_referral(LDAP *ld, char **referralsp, char *s) {</span>
<a href="#l69.626"></a><span id="l69.626" class="difflineplus">+int nsldapi_append_referral(LDAP* ld, char** referralsp, char* s) {</span>
<a href="#l69.627"></a><span id="l69.627">   int first;</span>
<a href="#l69.628"></a><span id="l69.628"> </span>
<a href="#l69.629"></a><span id="l69.629">   if (*referralsp == NULL) {</span>
<a href="#l69.630"></a><span id="l69.630">     first = 1;</span>
<a href="#l69.631"></a><span id="l69.631" class="difflineminus">-    *referralsp = (char *)NSLDAPI_MALLOC(strlen(s) + LDAP_REF_STR_LEN + 1);</span>
<a href="#l69.632"></a><span id="l69.632" class="difflineplus">+    *referralsp = (char*)NSLDAPI_MALLOC(strlen(s) + LDAP_REF_STR_LEN + 1);</span>
<a href="#l69.633"></a><span id="l69.633">   } else {</span>
<a href="#l69.634"></a><span id="l69.634">     first = 0;</span>
<a href="#l69.635"></a><span id="l69.635" class="difflineminus">-    *referralsp = (char *)NSLDAPI_REALLOC(*referralsp,</span>
<a href="#l69.636"></a><span id="l69.636" class="difflineminus">-                                          strlen(*referralsp) + strlen(s) + 2);</span>
<a href="#l69.637"></a><span id="l69.637" class="difflineplus">+    *referralsp = (char*)NSLDAPI_REALLOC(*referralsp,</span>
<a href="#l69.638"></a><span id="l69.638" class="difflineplus">+                                         strlen(*referralsp) + strlen(s) + 2);</span>
<a href="#l69.639"></a><span id="l69.639">   }</span>
<a href="#l69.640"></a><span id="l69.640"> </span>
<a href="#l69.641"></a><span id="l69.641">   if (*referralsp == NULL) {</span>
<a href="#l69.642"></a><span id="l69.642">     return (LDAP_NO_MEMORY);</span>
<a href="#l69.643"></a><span id="l69.643">   }</span>
<a href="#l69.644"></a><span id="l69.644"> </span>
<a href="#l69.645"></a><span id="l69.645">   if (first) {</span>
<a href="#l69.646"></a><span id="l69.646">     strcpy(*referralsp, LDAP_REF_STR);</span>
<a href="#l69.647"></a><span id="l69.647" class="difflineat">@@ -1293,27 +1293,27 @@ int nsldapi_append_referral(LDAP *ld, ch</span>
<a href="#l69.648"></a><span id="l69.648">     strcat(*referralsp, &quot;\n&quot;);</span>
<a href="#l69.649"></a><span id="l69.649">   }</span>
<a href="#l69.650"></a><span id="l69.650">   strcat(*referralsp, s);</span>
<a href="#l69.651"></a><span id="l69.651"> </span>
<a href="#l69.652"></a><span id="l69.652">   return (LDAP_SUCCESS);</span>
<a href="#l69.653"></a><span id="l69.653"> }</span>
<a href="#l69.654"></a><span id="l69.654"> </span>
<a href="#l69.655"></a><span id="l69.655"> /* returns an LDAP error code */</span>
<a href="#l69.656"></a><span id="l69.656" class="difflineminus">-static int re_encode_request(LDAP *ld, BerElement *origber, int msgid,</span>
<a href="#l69.657"></a><span id="l69.657" class="difflineminus">-                             LDAPURLDesc *ludp, BerElement **berp,</span>
<a href="#l69.658"></a><span id="l69.658" class="difflineplus">+static int re_encode_request(LDAP* ld, BerElement* origber, int msgid,</span>
<a href="#l69.659"></a><span id="l69.659" class="difflineplus">+                             LDAPURLDesc* ludp, BerElement** berp,</span>
<a href="#l69.660"></a><span id="l69.660">                              int is_reference) {</span>
<a href="#l69.661"></a><span id="l69.661">   /*</span>
<a href="#l69.662"></a><span id="l69.662">    * XXX this routine knows way too much about how the lber library works!</span>
<a href="#l69.663"></a><span id="l69.663">    */</span>
<a href="#l69.664"></a><span id="l69.664">   ber_int_t origmsgid;</span>
<a href="#l69.665"></a><span id="l69.665">   ber_tag_t tag;</span>
<a href="#l69.666"></a><span id="l69.666">   ber_int_t ver;</span>
<a href="#l69.667"></a><span id="l69.667">   int rc;</span>
<a href="#l69.668"></a><span id="l69.668" class="difflineminus">-  BerElement *ber;</span>
<a href="#l69.669"></a><span id="l69.669" class="difflineplus">+  BerElement* ber;</span>
<a href="#l69.670"></a><span id="l69.670">   struct berelement tmpber;</span>
<a href="#l69.671"></a><span id="l69.671">   char *dn, *orig_dn;</span>
<a href="#l69.672"></a><span id="l69.672">   /* extra stuff for search request */</span>
<a href="#l69.673"></a><span id="l69.673">   ber_int_t scope = -1;</span>
<a href="#l69.674"></a><span id="l69.674"> </span>
<a href="#l69.675"></a><span id="l69.675">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;re_encode_request: new msgid %d, new dn &lt;%s&gt;\n&quot;,</span>
<a href="#l69.676"></a><span id="l69.676">             msgid, (ludp-&gt;lud_dn == NULL) ? &quot;NONE&quot; : ludp-&gt;lud_dn, 0);</span>
<a href="#l69.677"></a><span id="l69.677"> </span>
<a href="#l69.678"></a><span id="l69.678" class="difflineat">@@ -1432,36 +1432,36 @@ static int re_encode_request(LDAP *ld, B</span>
<a href="#l69.679"></a><span id="l69.679">     ber_dump(ber, 0);</span>
<a href="#l69.680"></a><span id="l69.680">   }</span>
<a href="#l69.681"></a><span id="l69.681"> #endif /* LDAP_DEBUG */</span>
<a href="#l69.682"></a><span id="l69.682"> </span>
<a href="#l69.683"></a><span id="l69.683">   *berp = ber;</span>
<a href="#l69.684"></a><span id="l69.684">   return (LDAP_SUCCESS);</span>
<a href="#l69.685"></a><span id="l69.685"> }</span>
<a href="#l69.686"></a><span id="l69.686"> </span>
<a href="#l69.687"></a><span id="l69.687" class="difflineminus">-LDAPRequest *nsldapi_find_request_by_msgid(LDAP *ld, int msgid) {</span>
<a href="#l69.688"></a><span id="l69.688" class="difflineminus">-  LDAPRequest *lr;</span>
<a href="#l69.689"></a><span id="l69.689" class="difflineplus">+LDAPRequest* nsldapi_find_request_by_msgid(LDAP* ld, int msgid) {</span>
<a href="#l69.690"></a><span id="l69.690" class="difflineplus">+  LDAPRequest* lr;</span>
<a href="#l69.691"></a><span id="l69.691"> </span>
<a href="#l69.692"></a><span id="l69.692">   for (lr = ld-&gt;ld_requests; lr != NULL; lr = lr-&gt;lr_next) {</span>
<a href="#l69.693"></a><span id="l69.693">     if (msgid == lr-&gt;lr_msgid) {</span>
<a href="#l69.694"></a><span id="l69.694">       break;</span>
<a href="#l69.695"></a><span id="l69.695">     }</span>
<a href="#l69.696"></a><span id="l69.696">   }</span>
<a href="#l69.697"></a><span id="l69.697"> </span>
<a href="#l69.698"></a><span id="l69.698">   return (lr);</span>
<a href="#l69.699"></a><span id="l69.699"> }</span>
<a href="#l69.700"></a><span id="l69.700"> </span>
<a href="#l69.701"></a><span id="l69.701"> /*</span>
<a href="#l69.702"></a><span id="l69.702">  * nsldapi_connection_lost_nolock() resets &quot;ld&quot; to a non-connected, known</span>
<a href="#l69.703"></a><span id="l69.703">  * state.  It should be called whenever a fatal error occurs on the</span>
<a href="#l69.704"></a><span id="l69.704">  * Sockbuf &quot;sb.&quot;  sb == NULL means we don't know specifically where</span>
<a href="#l69.705"></a><span id="l69.705">  * the problem was so we assume all connections are bad.</span>
<a href="#l69.706"></a><span id="l69.706">  */</span>
<a href="#l69.707"></a><span id="l69.707" class="difflineminus">-void nsldapi_connection_lost_nolock(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l69.708"></a><span id="l69.708" class="difflineminus">-  LDAPRequest *lr;</span>
<a href="#l69.709"></a><span id="l69.709" class="difflineplus">+void nsldapi_connection_lost_nolock(LDAP* ld, Sockbuf* sb) {</span>
<a href="#l69.710"></a><span id="l69.710" class="difflineplus">+  LDAPRequest* lr;</span>
<a href="#l69.711"></a><span id="l69.711"> </span>
<a href="#l69.712"></a><span id="l69.712">   /*</span>
<a href="#l69.713"></a><span id="l69.713">    * change status of all pending requests that are associated with &quot;sb</span>
<a href="#l69.714"></a><span id="l69.714">    * to &quot;connection dead.&quot;</span>
<a href="#l69.715"></a><span id="l69.715">    * also change the connection status to &quot;dead&quot; and remove it from</span>
<a href="#l69.716"></a><span id="l69.716">    * the list of sockets we are interested in.</span>
<a href="#l69.717"></a><span id="l69.717">    */</span>
<a href="#l69.718"></a><span id="l69.718">   for (lr = ld-&gt;ld_requests; lr != NULL; lr = lr-&gt;lr_next) {</span>
<a href="#l69.719"></a><span id="l69.719" class="difflineat">@@ -1471,18 +1471,18 @@ void nsldapi_connection_lost_nolock(LDAP</span>
<a href="#l69.720"></a><span id="l69.720">         lr-&gt;lr_conn-&gt;lconn_status = LDAP_CONNST_DEAD;</span>
<a href="#l69.721"></a><span id="l69.721">         nsldapi_iostatus_interest_clear(ld, lr-&gt;lr_conn-&gt;lconn_sb);</span>
<a href="#l69.722"></a><span id="l69.722">       }</span>
<a href="#l69.723"></a><span id="l69.723">     }</span>
<a href="#l69.724"></a><span id="l69.724">   }</span>
<a href="#l69.725"></a><span id="l69.725"> }</span>
<a href="#l69.726"></a><span id="l69.726"> </span>
<a href="#l69.727"></a><span id="l69.727"> #ifdef LDAP_DNS</span>
<a href="#l69.728"></a><span id="l69.728" class="difflineminus">-static LDAPServer *dn2servers(LDAP *ld,</span>
<a href="#l69.729"></a><span id="l69.729" class="difflineminus">-                              char *dn) /* dn can also be a domain.... */</span>
<a href="#l69.730"></a><span id="l69.730" class="difflineplus">+static LDAPServer* dn2servers(LDAP* ld,</span>
<a href="#l69.731"></a><span id="l69.731" class="difflineplus">+                              char* dn) /* dn can also be a domain.... */</span>
<a href="#l69.732"></a><span id="l69.732"> {</span>
<a href="#l69.733"></a><span id="l69.733">   char *p, *domain, *host, *server_dn, **dxs;</span>
<a href="#l69.734"></a><span id="l69.734">   int i, port;</span>
<a href="#l69.735"></a><span id="l69.735">   LDAPServer *srvlist, *prevsrv, *srv;</span>
<a href="#l69.736"></a><span id="l69.736"> </span>
<a href="#l69.737"></a><span id="l69.737">   if ((domain = strrchr(dn, '@')) != NULL) {</span>
<a href="#l69.738"></a><span id="l69.738">     ++domain;</span>
<a href="#l69.739"></a><span id="l69.739">   } else {</span>
<a href="#l69.740"></a><span id="l69.740" class="difflineat">@@ -1515,17 +1515,17 @@ static LDAPServer *dn2servers(LDAP *ld,</span>
<a href="#l69.741"></a><span id="l69.741">           server_dn = NULL;</span>
<a href="#l69.742"></a><span id="l69.742">         }</span>
<a href="#l69.743"></a><span id="l69.743">       }</span>
<a href="#l69.744"></a><span id="l69.744">     } else {</span>
<a href="#l69.745"></a><span id="l69.745">       host = NULL;</span>
<a href="#l69.746"></a><span id="l69.746">     }</span>
<a href="#l69.747"></a><span id="l69.747"> </span>
<a href="#l69.748"></a><span id="l69.748">     if (host != NULL) { /* found a server we can use */</span>
<a href="#l69.749"></a><span id="l69.749" class="difflineminus">-      if ((srv = (LDAPServer *)NSLDAPI_CALLOC(1, sizeof(LDAPServer))) == NULL) {</span>
<a href="#l69.750"></a><span id="l69.750" class="difflineplus">+      if ((srv = (LDAPServer*)NSLDAPI_CALLOC(1, sizeof(LDAPServer))) == NULL) {</span>
<a href="#l69.751"></a><span id="l69.751">         free_servers(srvlist);</span>
<a href="#l69.752"></a><span id="l69.752">         srvlist = NULL;</span>
<a href="#l69.753"></a><span id="l69.753">         break; /* exit loop &amp; return */</span>
<a href="#l69.754"></a><span id="l69.754">       }</span>
<a href="#l69.755"></a><span id="l69.755"> </span>
<a href="#l69.756"></a><span id="l69.756">       /* add to end of list of servers */</span>
<a href="#l69.757"></a><span id="l69.757">       if (srvlist == NULL) {</span>
<a href="#l69.758"></a><span id="l69.758">         srvlist = srv;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l70.1"></a><span id="l70.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/reslist.c</span>
<a href="#l70.2"></a><span id="l70.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/reslist.c</span>
<a href="#l70.3"></a><span id="l70.3" class="difflineat">@@ -45,18 +45,18 @@</span>
<a href="#l70.4"></a><span id="l70.4"> #if 0</span>
<a href="#l70.5"></a><span id="l70.5"> #  ifndef lint</span>
<a href="#l70.6"></a><span id="l70.6"> static char copyright[] = &quot;@(#) Copyright (c) 1990 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l70.7"></a><span id="l70.7"> #  endif</span>
<a href="#l70.8"></a><span id="l70.8"> #endif</span>
<a href="#l70.9"></a><span id="l70.9"> </span>
<a href="#l70.10"></a><span id="l70.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l70.11"></a><span id="l70.11"> </span>
<a href="#l70.12"></a><span id="l70.12" class="difflineminus">-LDAPMessage *LDAP_CALL ldap_delete_result_entry(LDAPMessage **list,</span>
<a href="#l70.13"></a><span id="l70.13" class="difflineminus">-                                                LDAPMessage *e) {</span>
<a href="#l70.14"></a><span id="l70.14" class="difflineplus">+LDAPMessage* LDAP_CALL ldap_delete_result_entry(LDAPMessage** list,</span>
<a href="#l70.15"></a><span id="l70.15" class="difflineplus">+                                                LDAPMessage* e) {</span>
<a href="#l70.16"></a><span id="l70.16">   LDAPMessage *tmp, *prev = NULL;</span>
<a href="#l70.17"></a><span id="l70.17"> </span>
<a href="#l70.18"></a><span id="l70.18">   if (list == NULL || e == NULL) {</span>
<a href="#l70.19"></a><span id="l70.19">     return (NULL);</span>
<a href="#l70.20"></a><span id="l70.20">   }</span>
<a href="#l70.21"></a><span id="l70.21"> </span>
<a href="#l70.22"></a><span id="l70.22">   for (tmp = *list; tmp != NULL &amp;&amp; tmp != e; tmp = tmp-&gt;lm_chain) prev = tmp;</span>
<a href="#l70.23"></a><span id="l70.23"> </span>
<a href="#l70.24"></a><span id="l70.24" class="difflineat">@@ -66,14 +66,14 @@ LDAPMessage *LDAP_CALL ldap_delete_resul</span>
<a href="#l70.25"></a><span id="l70.25">     *list = tmp-&gt;lm_chain;</span>
<a href="#l70.26"></a><span id="l70.26">   else</span>
<a href="#l70.27"></a><span id="l70.27">     prev-&gt;lm_chain = tmp-&gt;lm_chain;</span>
<a href="#l70.28"></a><span id="l70.28">   tmp-&gt;lm_chain = NULL;</span>
<a href="#l70.29"></a><span id="l70.29"> </span>
<a href="#l70.30"></a><span id="l70.30">   return (tmp);</span>
<a href="#l70.31"></a><span id="l70.31"> }</span>
<a href="#l70.32"></a><span id="l70.32"> </span>
<a href="#l70.33"></a><span id="l70.33" class="difflineminus">-void LDAP_CALL ldap_add_result_entry(LDAPMessage **list, LDAPMessage *e) {</span>
<a href="#l70.34"></a><span id="l70.34" class="difflineplus">+void LDAP_CALL ldap_add_result_entry(LDAPMessage** list, LDAPMessage* e) {</span>
<a href="#l70.35"></a><span id="l70.35">   if (list != NULL &amp;&amp; e != NULL) {</span>
<a href="#l70.36"></a><span id="l70.36">     e-&gt;lm_chain = *list;</span>
<a href="#l70.37"></a><span id="l70.37">     *list = e;</span>
<a href="#l70.38"></a><span id="l70.38">   }</span>
<a href="#l70.39"></a><span id="l70.39"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l71.1"></a><span id="l71.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/result.c</span>
<a href="#l71.2"></a><span id="l71.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/result.c</span>
<a href="#l71.3"></a><span id="l71.3" class="difflineat">@@ -52,50 +52,50 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l71.4"></a><span id="l71.4"> </span>
<a href="#l71.5"></a><span id="l71.5"> /*</span>
<a href="#l71.6"></a><span id="l71.6">  * Special return values used by some functions (wait4msg() and read1msg()).</span>
<a href="#l71.7"></a><span id="l71.7">  */</span>
<a href="#l71.8"></a><span id="l71.8"> #define NSLDAPI_RESULT_TIMEOUT 0</span>
<a href="#l71.9"></a><span id="l71.9"> #define NSLDAPI_RESULT_ERROR (-1)</span>
<a href="#l71.10"></a><span id="l71.10"> #define NSLDAPI_RESULT_NOT_FOUND (-2)</span>
<a href="#l71.11"></a><span id="l71.11"> </span>
<a href="#l71.12"></a><span id="l71.12" class="difflineminus">-static int check_response_queue(LDAP *ld, int msgid, int all,</span>
<a href="#l71.13"></a><span id="l71.13" class="difflineminus">-                                int do_abandon_check, LDAPMessage **result);</span>
<a href="#l71.14"></a><span id="l71.14" class="difflineminus">-static int ldap_abandoned(LDAP *ld, int msgid);</span>
<a href="#l71.15"></a><span id="l71.15" class="difflineminus">-static int ldap_mark_abandoned(LDAP *ld, int msgid);</span>
<a href="#l71.16"></a><span id="l71.16" class="difflineminus">-static int wait4msg(LDAP *ld, int msgid, int all, int unlock_permitted,</span>
<a href="#l71.17"></a><span id="l71.17" class="difflineminus">-                    struct timeval *timeout, LDAPMessage **result);</span>
<a href="#l71.18"></a><span id="l71.18" class="difflineminus">-static int read1msg(LDAP *ld, int msgid, int all, Sockbuf *sb, LDAPConn **lcp,</span>
<a href="#l71.19"></a><span id="l71.19" class="difflineminus">-                    LDAPMessage **result);</span>
<a href="#l71.20"></a><span id="l71.20" class="difflineminus">-static void check_for_refs(LDAP *ld, LDAPRequest *lr, BerElement *ber,</span>
<a href="#l71.21"></a><span id="l71.21" class="difflineminus">-                           int ldapversion, int *totalcountp,</span>
<a href="#l71.22"></a><span id="l71.22" class="difflineminus">-                           int *chasingcountp);</span>
<a href="#l71.23"></a><span id="l71.23" class="difflineminus">-static int build_result_ber(LDAP *ld, BerElement **berp, LDAPRequest *lr);</span>
<a href="#l71.24"></a><span id="l71.24" class="difflineminus">-static void merge_error_info(LDAP *ld, LDAPRequest *parentr, LDAPRequest *lr);</span>
<a href="#l71.25"></a><span id="l71.25" class="difflineplus">+static int check_response_queue(LDAP* ld, int msgid, int all,</span>
<a href="#l71.26"></a><span id="l71.26" class="difflineplus">+                                int do_abandon_check, LDAPMessage** result);</span>
<a href="#l71.27"></a><span id="l71.27" class="difflineplus">+static int ldap_abandoned(LDAP* ld, int msgid);</span>
<a href="#l71.28"></a><span id="l71.28" class="difflineplus">+static int ldap_mark_abandoned(LDAP* ld, int msgid);</span>
<a href="#l71.29"></a><span id="l71.29" class="difflineplus">+static int wait4msg(LDAP* ld, int msgid, int all, int unlock_permitted,</span>
<a href="#l71.30"></a><span id="l71.30" class="difflineplus">+                    struct timeval* timeout, LDAPMessage** result);</span>
<a href="#l71.31"></a><span id="l71.31" class="difflineplus">+static int read1msg(LDAP* ld, int msgid, int all, Sockbuf* sb, LDAPConn** lcp,</span>
<a href="#l71.32"></a><span id="l71.32" class="difflineplus">+                    LDAPMessage** result);</span>
<a href="#l71.33"></a><span id="l71.33" class="difflineplus">+static void check_for_refs(LDAP* ld, LDAPRequest* lr, BerElement* ber,</span>
<a href="#l71.34"></a><span id="l71.34" class="difflineplus">+                           int ldapversion, int* totalcountp,</span>
<a href="#l71.35"></a><span id="l71.35" class="difflineplus">+                           int* chasingcountp);</span>
<a href="#l71.36"></a><span id="l71.36" class="difflineplus">+static int build_result_ber(LDAP* ld, BerElement** berp, LDAPRequest* lr);</span>
<a href="#l71.37"></a><span id="l71.37" class="difflineplus">+static void merge_error_info(LDAP* ld, LDAPRequest* parentr, LDAPRequest* lr);</span>
<a href="#l71.38"></a><span id="l71.38"> #if defined(CLDAP)</span>
<a href="#l71.39"></a><span id="l71.39" class="difflineminus">-static int cldap_select1(LDAP *ld, struct timeval *timeout);</span>
<a href="#l71.40"></a><span id="l71.40" class="difflineplus">+static int cldap_select1(LDAP* ld, struct timeval* timeout);</span>
<a href="#l71.41"></a><span id="l71.41"> #endif</span>
<a href="#l71.42"></a><span id="l71.42" class="difflineminus">-static void link_pend(LDAP *ld, LDAPPend *lp);</span>
<a href="#l71.43"></a><span id="l71.43" class="difflineplus">+static void link_pend(LDAP* ld, LDAPPend* lp);</span>
<a href="#l71.44"></a><span id="l71.44"> </span>
<a href="#l71.45"></a><span id="l71.45"> /*</span>
<a href="#l71.46"></a><span id="l71.46">  * ldap_result - wait for an ldap result response to a message from the</span>
<a href="#l71.47"></a><span id="l71.47">  * ldap server. If msgid is -1, any message will be accepted, otherwise</span>
<a href="#l71.48"></a><span id="l71.48">  * ldap_result will wait for a response with msgid. If all is 0 the</span>
<a href="#l71.49"></a><span id="l71.49">  * first message with id msgid will be accepted, otherwise, ldap_result</span>
<a href="#l71.50"></a><span id="l71.50">  * will wait for all responses with id msgid and then return a pointer to</span>
<a href="#l71.51"></a><span id="l71.51">  * the entire list of messages. This is only useful for search responses,</span>
<a href="#l71.52"></a><span id="l71.52">  * which can be of two message types (zero or more entries, followed by an</span>
<a href="#l71.53"></a><span id="l71.53">  * ldap result). The type of the first message received is returned.</span>
<a href="#l71.54"></a><span id="l71.54">  * When waiting, any messages that have been abandoned are discarded.</span>
<a href="#l71.55"></a><span id="l71.55">  *</span>
<a href="#l71.56"></a><span id="l71.56">  * Example:</span>
<a href="#l71.57"></a><span id="l71.57">  * ldap_result(s, msgid, all, timeout, result)</span>
<a href="#l71.58"></a><span id="l71.58">  */</span>
<a href="#l71.59"></a><span id="l71.59" class="difflineminus">-int LDAP_CALL ldap_result(LDAP *ld, int msgid, int all, struct timeval *timeout,</span>
<a href="#l71.60"></a><span id="l71.60" class="difflineminus">-                          LDAPMessage **result) {</span>
<a href="#l71.61"></a><span id="l71.61" class="difflineplus">+int LDAP_CALL ldap_result(LDAP* ld, int msgid, int all, struct timeval* timeout,</span>
<a href="#l71.62"></a><span id="l71.62" class="difflineplus">+                          LDAPMessage** result) {</span>
<a href="#l71.63"></a><span id="l71.63">   int rc;</span>
<a href="#l71.64"></a><span id="l71.64"> </span>
<a href="#l71.65"></a><span id="l71.65">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_result\n&quot;, 0, 0, 0);</span>
<a href="#l71.66"></a><span id="l71.66"> </span>
<a href="#l71.67"></a><span id="l71.67">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l71.68"></a><span id="l71.68">     return (-1); /* punt */</span>
<a href="#l71.69"></a><span id="l71.69">   }</span>
<a href="#l71.70"></a><span id="l71.70"> </span>
<a href="#l71.71"></a><span id="l71.71" class="difflineat">@@ -103,18 +103,18 @@ int LDAP_CALL ldap_result(LDAP *ld, int </span>
<a href="#l71.72"></a><span id="l71.72"> </span>
<a href="#l71.73"></a><span id="l71.73">   rc = nsldapi_result_nolock(ld, msgid, all, 1, timeout, result);</span>
<a href="#l71.74"></a><span id="l71.74"> </span>
<a href="#l71.75"></a><span id="l71.75">   LDAP_MUTEX_UNLOCK(ld, LDAP_RESULT_LOCK);</span>
<a href="#l71.76"></a><span id="l71.76"> </span>
<a href="#l71.77"></a><span id="l71.77">   return (rc);</span>
<a href="#l71.78"></a><span id="l71.78"> }</span>
<a href="#l71.79"></a><span id="l71.79"> </span>
<a href="#l71.80"></a><span id="l71.80" class="difflineminus">-int nsldapi_result_nolock(LDAP *ld, int msgid, int all, int unlock_permitted,</span>
<a href="#l71.81"></a><span id="l71.81" class="difflineminus">-                          struct timeval *timeout, LDAPMessage **result) {</span>
<a href="#l71.82"></a><span id="l71.82" class="difflineplus">+int nsldapi_result_nolock(LDAP* ld, int msgid, int all, int unlock_permitted,</span>
<a href="#l71.83"></a><span id="l71.83" class="difflineplus">+                          struct timeval* timeout, LDAPMessage** result) {</span>
<a href="#l71.84"></a><span id="l71.84">   int rc;</span>
<a href="#l71.85"></a><span id="l71.85"> </span>
<a href="#l71.86"></a><span id="l71.86">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_result_nolock (msgid=%d, all=%d)\n&quot;,</span>
<a href="#l71.87"></a><span id="l71.87">             msgid, all, 0);</span>
<a href="#l71.88"></a><span id="l71.88"> </span>
<a href="#l71.89"></a><span id="l71.89">   /*</span>
<a href="#l71.90"></a><span id="l71.90">    * First, look through the list of responses we have received on</span>
<a href="#l71.91"></a><span id="l71.91">    * this association and see if the response we're interested in</span>
<a href="#l71.92"></a><span id="l71.92" class="difflineat">@@ -151,20 +151,20 @@ int nsldapi_result_nolock(LDAP *ld, int </span>
<a href="#l71.93"></a><span id="l71.93">  * criteria in the msgid and all parameters. msgid == LDAP_RES_ANY matches</span>
<a href="#l71.94"></a><span id="l71.94">  * all ids.</span>
<a href="#l71.95"></a><span id="l71.95">  *</span>
<a href="#l71.96"></a><span id="l71.96">  * If an appropriate message is found, a non-zero value is returned and the</span>
<a href="#l71.97"></a><span id="l71.97">  * message is dequeued and assigned to *result.</span>
<a href="#l71.98"></a><span id="l71.98">  *</span>
<a href="#l71.99"></a><span id="l71.99">  * If not, *result is set to NULL and this function returns 0.</span>
<a href="#l71.100"></a><span id="l71.100">  */</span>
<a href="#l71.101"></a><span id="l71.101" class="difflineminus">-static int check_response_queue(LDAP *ld, int msgid, int all,</span>
<a href="#l71.102"></a><span id="l71.102" class="difflineminus">-                                int do_abandon_check, LDAPMessage **result) {</span>
<a href="#l71.103"></a><span id="l71.103" class="difflineplus">+static int check_response_queue(LDAP* ld, int msgid, int all,</span>
<a href="#l71.104"></a><span id="l71.104" class="difflineplus">+                                int do_abandon_check, LDAPMessage** result) {</span>
<a href="#l71.105"></a><span id="l71.105">   LDAPMessage *lm, *lastlm, *nextlm;</span>
<a href="#l71.106"></a><span id="l71.106" class="difflineminus">-  LDAPRequest *lr;</span>
<a href="#l71.107"></a><span id="l71.107" class="difflineplus">+  LDAPRequest* lr;</span>
<a href="#l71.108"></a><span id="l71.108"> </span>
<a href="#l71.109"></a><span id="l71.109">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;=&gt; check_response_queue (msgid=%d, all=%d)\n&quot;,</span>
<a href="#l71.110"></a><span id="l71.110">             msgid, all, 0);</span>
<a href="#l71.111"></a><span id="l71.111"> </span>
<a href="#l71.112"></a><span id="l71.112">   *result = NULL;</span>
<a href="#l71.113"></a><span id="l71.113">   lastlm = NULL;</span>
<a href="#l71.114"></a><span id="l71.114">   LDAP_MUTEX_LOCK(ld, LDAP_RESP_LOCK);</span>
<a href="#l71.115"></a><span id="l71.115">   for (lm = ld-&gt;ld_responses; lm != NULL; lm = nextlm) {</span>
<a href="#l71.116"></a><span id="l71.116" class="difflineat">@@ -180,17 +180,17 @@ static int check_response_queue(LDAP *ld</span>
<a href="#l71.117"></a><span id="l71.117">       }</span>
<a href="#l71.118"></a><span id="l71.118"> </span>
<a href="#l71.119"></a><span id="l71.119">       ldap_msgfree(lm);</span>
<a href="#l71.120"></a><span id="l71.120"> </span>
<a href="#l71.121"></a><span id="l71.121">       continue;</span>
<a href="#l71.122"></a><span id="l71.122">     }</span>
<a href="#l71.123"></a><span id="l71.123"> </span>
<a href="#l71.124"></a><span id="l71.124">     if (msgid == LDAP_RES_ANY || lm-&gt;lm_msgid == msgid) {</span>
<a href="#l71.125"></a><span id="l71.125" class="difflineminus">-      LDAPMessage *tmp;</span>
<a href="#l71.126"></a><span id="l71.126" class="difflineplus">+      LDAPMessage* tmp;</span>
<a href="#l71.127"></a><span id="l71.127"> </span>
<a href="#l71.128"></a><span id="l71.128">       if (all == 0 || (lm-&gt;lm_msgtype != LDAP_RES_SEARCH_RESULT &amp;&amp;</span>
<a href="#l71.129"></a><span id="l71.129">                        lm-&gt;lm_msgtype != LDAP_RES_SEARCH_REFERENCE &amp;&amp;</span>
<a href="#l71.130"></a><span id="l71.130">                        lm-&gt;lm_msgtype != LDAP_RES_SEARCH_ENTRY))</span>
<a href="#l71.131"></a><span id="l71.131">         break;</span>
<a href="#l71.132"></a><span id="l71.132"> </span>
<a href="#l71.133"></a><span id="l71.133">       for (tmp = lm; tmp != NULL; tmp = tmp-&gt;lm_chain) {</span>
<a href="#l71.134"></a><span id="l71.134">         if (tmp-&gt;lm_msgtype == LDAP_RES_SEARCH_RESULT) break;</span>
<a href="#l71.135"></a><span id="l71.135" class="difflineat">@@ -260,24 +260,24 @@ static int check_response_queue(LDAP *ld</span>
<a href="#l71.136"></a><span id="l71.136"> /*</span>
<a href="#l71.137"></a><span id="l71.137">  * wait4msg(): Poll for incoming LDAP messages, respecting the timeout.</span>
<a href="#l71.138"></a><span id="l71.138">  *</span>
<a href="#l71.139"></a><span id="l71.139">  * Return values:</span>
<a href="#l71.140"></a><span id="l71.140">  *  &gt; 0:                      message received; value is the tag of the message.</span>
<a href="#l71.141"></a><span id="l71.141">  *  NSLDAPI_RESULT_TIMEOUT    timeout exceeded.</span>
<a href="#l71.142"></a><span id="l71.142">  *  NSLDAPI_RESULT_ERROR      fatal error occurred such as connection closed.</span>
<a href="#l71.143"></a><span id="l71.143">  */</span>
<a href="#l71.144"></a><span id="l71.144" class="difflineminus">-static int wait4msg(LDAP *ld, int msgid, int all, int unlock_permitted,</span>
<a href="#l71.145"></a><span id="l71.145" class="difflineminus">-                    struct timeval *timeout, LDAPMessage **result) {</span>
<a href="#l71.146"></a><span id="l71.146" class="difflineplus">+static int wait4msg(LDAP* ld, int msgid, int all, int unlock_permitted,</span>
<a href="#l71.147"></a><span id="l71.147" class="difflineplus">+                    struct timeval* timeout, LDAPMessage** result) {</span>
<a href="#l71.148"></a><span id="l71.148">   int err, rc = NSLDAPI_RESULT_NOT_FOUND, msgfound;</span>
<a href="#l71.149"></a><span id="l71.149">   struct timeval tv, *tvp;</span>
<a href="#l71.150"></a><span id="l71.150">   long start_time = 0, tmp_time;</span>
<a href="#l71.151"></a><span id="l71.151">   LDAPConn *lc, *nextlc;</span>
<a href="#l71.152"></a><span id="l71.152">   /* lr points to the specific request we are waiting for, if any */</span>
<a href="#l71.153"></a><span id="l71.153" class="difflineminus">-  LDAPRequest *lr = NULL;</span>
<a href="#l71.154"></a><span id="l71.154" class="difflineplus">+  LDAPRequest* lr = NULL;</span>
<a href="#l71.155"></a><span id="l71.155"> </span>
<a href="#l71.156"></a><span id="l71.156"> #ifdef LDAP_DEBUG</span>
<a href="#l71.157"></a><span id="l71.157">   if (timeout == NULL) {</span>
<a href="#l71.158"></a><span id="l71.158">     LDAPDebug(LDAP_DEBUG_TRACE, &quot;wait4msg (infinite timeout)\n&quot;, 0, 0, 0);</span>
<a href="#l71.159"></a><span id="l71.159">   } else {</span>
<a href="#l71.160"></a><span id="l71.160">     LDAPDebug(LDAP_DEBUG_TRACE, &quot;wait4msg (timeout %ld sec, %ld usec)\n&quot;,</span>
<a href="#l71.161"></a><span id="l71.161">               timeout-&gt;tv_sec, (long)timeout-&gt;tv_usec, 0);</span>
<a href="#l71.162"></a><span id="l71.162">   }</span>
<a href="#l71.163"></a><span id="l71.163" class="difflineat">@@ -504,28 +504,28 @@ static int wait4msg(LDAP *ld, int msgid,</span>
<a href="#l71.164"></a><span id="l71.164">  *  &gt; 0:                      message received; value is the tag of the message.</span>
<a href="#l71.165"></a><span id="l71.165">  *  NSLDAPI_RESULT_TIMEOUT    timeout exceeded.</span>
<a href="#l71.166"></a><span id="l71.166">  *  NSLDAPI_RESULT_ERROR      fatal error occurred such as connection closed.</span>
<a href="#l71.167"></a><span id="l71.167">  *  NSLDAPI_RESULT_NOT_FOUND  message not yet complete; keep waiting.</span>
<a href="#l71.168"></a><span id="l71.168">  *</span>
<a href="#l71.169"></a><span id="l71.169">  *  The LDAPConn passed in my be freed by read1msg() if the reference count</span>
<a href="#l71.170"></a><span id="l71.170">  *  shows that it's no longer needed.</span>
<a href="#l71.171"></a><span id="l71.171">  */</span>
<a href="#l71.172"></a><span id="l71.172" class="difflineminus">-static int read1msg(LDAP *ld, int msgid, int all, Sockbuf *sb, LDAPConn **lcp,</span>
<a href="#l71.173"></a><span id="l71.173" class="difflineminus">-                    LDAPMessage **result) {</span>
<a href="#l71.174"></a><span id="l71.174" class="difflineminus">-  BerElement *ber;</span>
<a href="#l71.175"></a><span id="l71.175" class="difflineminus">-  LDAPMessage *new, *l, *prev, *chainprev, *tmp;</span>
<a href="#l71.176"></a><span id="l71.176" class="difflineplus">+static int read1msg(LDAP* ld, int msgid, int all, Sockbuf* sb, LDAPConn** lcp,</span>
<a href="#l71.177"></a><span id="l71.177" class="difflineplus">+                    LDAPMessage** result) {</span>
<a href="#l71.178"></a><span id="l71.178" class="difflineplus">+  BerElement* ber;</span>
<a href="#l71.179"></a><span id="l71.179" class="difflineplus">+  LDAPMessage* new, *l, *prev, *chainprev, *tmp;</span>
<a href="#l71.180"></a><span id="l71.180">   ber_int_t id;</span>
<a href="#l71.181"></a><span id="l71.181">   ber_tag_t tag;</span>
<a href="#l71.182"></a><span id="l71.182">   ber_len_t len;</span>
<a href="#l71.183"></a><span id="l71.183">   int terrno, lderr, foundit = 0;</span>
<a href="#l71.184"></a><span id="l71.184" class="difflineminus">-  LDAPRequest *lr;</span>
<a href="#l71.185"></a><span id="l71.185" class="difflineplus">+  LDAPRequest* lr;</span>
<a href="#l71.186"></a><span id="l71.186">   int rc, has_parent, message_can_be_returned;</span>
<a href="#l71.187"></a><span id="l71.187">   int manufactured_result = 0;</span>
<a href="#l71.188"></a><span id="l71.188" class="difflineminus">-  LDAPConn *lc = *lcp;</span>
<a href="#l71.189"></a><span id="l71.189" class="difflineplus">+  LDAPConn* lc = *lcp;</span>
<a href="#l71.190"></a><span id="l71.190"> </span>
<a href="#l71.191"></a><span id="l71.191">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;read1msg\n&quot;, 0, 0, 0);</span>
<a href="#l71.192"></a><span id="l71.192"> </span>
<a href="#l71.193"></a><span id="l71.193">   message_can_be_returned = 1; /* the usual case... */</span>
<a href="#l71.194"></a><span id="l71.194"> </span>
<a href="#l71.195"></a><span id="l71.195">   /*</span>
<a href="#l71.196"></a><span id="l71.196">    * if we are not already in the midst of reading a message, allocate</span>
<a href="#l71.197"></a><span id="l71.197">    * a ber that is associated with this connection</span>
<a href="#l71.198"></a><span id="l71.198" class="difflineat">@@ -602,17 +602,17 @@ static int read1msg(LDAP *ld, int msgid,</span>
<a href="#l71.199"></a><span id="l71.199">     lr-&gt;lr_res_msgtype = tag;</span>
<a href="#l71.200"></a><span id="l71.200">   }</span>
<a href="#l71.201"></a><span id="l71.201">   rc = NSLDAPI_RESULT_NOT_FOUND; /* default is to keep looking (no response</span>
<a href="#l71.202"></a><span id="l71.202">                                     found) */</span>
<a href="#l71.203"></a><span id="l71.203"> </span>
<a href="#l71.204"></a><span id="l71.204">   if (id != LDAP_RES_UNSOLICITED &amp;&amp;</span>
<a href="#l71.205"></a><span id="l71.205">       (tag == LDAP_RES_SEARCH_REFERENCE || tag != LDAP_RES_SEARCH_ENTRY)) {</span>
<a href="#l71.206"></a><span id="l71.206">     int refchasing, reftotal, simple_request = 0;</span>
<a href="#l71.207"></a><span id="l71.207" class="difflineminus">-    LDAPControl **ctrls = NULL;</span>
<a href="#l71.208"></a><span id="l71.208" class="difflineplus">+    LDAPControl** ctrls = NULL;</span>
<a href="#l71.209"></a><span id="l71.209"> </span>
<a href="#l71.210"></a><span id="l71.210">     check_for_refs(ld, lr, ber, lc-&gt;lconn_version, &amp;reftotal, &amp;refchasing);</span>
<a href="#l71.211"></a><span id="l71.211"> </span>
<a href="#l71.212"></a><span id="l71.212">     if (refchasing &gt; 0 || lr-&gt;lr_outrefcnt &gt; 0) {</span>
<a href="#l71.213"></a><span id="l71.213">       /*</span>
<a href="#l71.214"></a><span id="l71.214">        * we're chasing one or more new refs...</span>
<a href="#l71.215"></a><span id="l71.215">        */</span>
<a href="#l71.216"></a><span id="l71.216">       ber_free(ber, 1);</span>
<a href="#l71.217"></a><span id="l71.217" class="difflineat">@@ -730,18 +730,17 @@ static int read1msg(LDAP *ld, int msgid,</span>
<a href="#l71.218"></a><span id="l71.218">     }</span>
<a href="#l71.219"></a><span id="l71.219">   }</span>
<a href="#l71.220"></a><span id="l71.220"> </span>
<a href="#l71.221"></a><span id="l71.221">   if (ber == NULLBER) {</span>
<a href="#l71.222"></a><span id="l71.222">     return (rc);</span>
<a href="#l71.223"></a><span id="l71.223">   }</span>
<a href="#l71.224"></a><span id="l71.224"> </span>
<a href="#l71.225"></a><span id="l71.225">   /* make a new ldap message */</span>
<a href="#l71.226"></a><span id="l71.226" class="difflineminus">-  if ((new = (LDAPMessage *)NSLDAPI_CALLOC(1, sizeof(struct ldapmsg))) ==</span>
<a href="#l71.227"></a><span id="l71.227" class="difflineminus">-      NULL) {</span>
<a href="#l71.228"></a><span id="l71.228" class="difflineplus">+  if ((new = (LDAPMessage*)NSLDAPI_CALLOC(1, sizeof(struct ldapmsg))) == NULL) {</span>
<a href="#l71.229"></a><span id="l71.229">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l71.230"></a><span id="l71.230">     return (NSLDAPI_RESULT_ERROR);</span>
<a href="#l71.231"></a><span id="l71.231">   }</span>
<a href="#l71.232"></a><span id="l71.232">   new-&gt;lm_msgid = (int)id;</span>
<a href="#l71.233"></a><span id="l71.233">   new-&gt;lm_msgtype = tag;</span>
<a href="#l71.234"></a><span id="l71.234">   new-&gt;lm_ber = ber;</span>
<a href="#l71.235"></a><span id="l71.235"> </span>
<a href="#l71.236"></a><span id="l71.236">   /*</span>
<a href="#l71.237"></a><span id="l71.237" class="difflineat">@@ -921,19 +920,19 @@ static int read1msg(LDAP *ld, int msgid,</span>
<a href="#l71.238"></a><span id="l71.238">   LDAP_MUTEX_UNLOCK(ld, LDAP_RESP_LOCK);</span>
<a href="#l71.239"></a><span id="l71.239">   return (NSLDAPI_RESULT_NOT_FOUND); /* continue looking */</span>
<a href="#l71.240"></a><span id="l71.240"> }</span>
<a href="#l71.241"></a><span id="l71.241"> </span>
<a href="#l71.242"></a><span id="l71.242"> /*</span>
<a href="#l71.243"></a><span id="l71.243">  * check for LDAPv2+ (UMich extension) or LDAPv3 referrals or references</span>
<a href="#l71.244"></a><span id="l71.244">  * errors are merged in &quot;lr&quot;.</span>
<a href="#l71.245"></a><span id="l71.245">  */</span>
<a href="#l71.246"></a><span id="l71.246" class="difflineminus">-static void check_for_refs(LDAP *ld, LDAPRequest *lr, BerElement *ber,</span>
<a href="#l71.247"></a><span id="l71.247" class="difflineminus">-                           int ldapversion, int *totalcountp,</span>
<a href="#l71.248"></a><span id="l71.248" class="difflineminus">-                           int *chasingcountp) {</span>
<a href="#l71.249"></a><span id="l71.249" class="difflineplus">+static void check_for_refs(LDAP* ld, LDAPRequest* lr, BerElement* ber,</span>
<a href="#l71.250"></a><span id="l71.250" class="difflineplus">+                           int ldapversion, int* totalcountp,</span>
<a href="#l71.251"></a><span id="l71.251" class="difflineplus">+                           int* chasingcountp) {</span>
<a href="#l71.252"></a><span id="l71.252">   int err, origerr;</span>
<a href="#l71.253"></a><span id="l71.253">   char *errstr, *matcheddn, **v3refs;</span>
<a href="#l71.254"></a><span id="l71.254"> </span>
<a href="#l71.255"></a><span id="l71.255">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;check_for_refs\n&quot;, 0, 0, 0);</span>
<a href="#l71.256"></a><span id="l71.256"> </span>
<a href="#l71.257"></a><span id="l71.257">   *chasingcountp = *totalcountp = 0;</span>
<a href="#l71.258"></a><span id="l71.258"> </span>
<a href="#l71.259"></a><span id="l71.259">   if (ldapversion &lt; LDAP_VERSION2 ||</span>
<a href="#l71.260"></a><span id="l71.260" class="difflineat">@@ -1006,20 +1005,20 @@ static void check_for_refs(LDAP *ld, LDA</span>
<a href="#l71.261"></a><span id="l71.261">             lr-&gt;lr_res_error ? lr-&gt;lr_res_error : &quot;&quot;,</span>
<a href="#l71.262"></a><span id="l71.262">             lr-&gt;lr_res_matched ? lr-&gt;lr_res_matched : &quot;&quot;, 0);</span>
<a href="#l71.263"></a><span id="l71.263">   LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l71.264"></a><span id="l71.264">             &quot;check_for_refs: %d new refs(s); chasing %d of them\n&quot;,</span>
<a href="#l71.265"></a><span id="l71.265">             *totalcountp, *chasingcountp, 0);</span>
<a href="#l71.266"></a><span id="l71.266"> }</span>
<a href="#l71.267"></a><span id="l71.267"> </span>
<a href="#l71.268"></a><span id="l71.268"> /* returns an LDAP error code and also sets it in LDAP * */</span>
<a href="#l71.269"></a><span id="l71.269" class="difflineminus">-static int build_result_ber(LDAP *ld, BerElement **berp, LDAPRequest *lr) {</span>
<a href="#l71.270"></a><span id="l71.270" class="difflineplus">+static int build_result_ber(LDAP* ld, BerElement** berp, LDAPRequest* lr) {</span>
<a href="#l71.271"></a><span id="l71.271">   ber_len_t len;</span>
<a href="#l71.272"></a><span id="l71.272">   ber_int_t along;</span>
<a href="#l71.273"></a><span id="l71.273" class="difflineminus">-  BerElement *ber;</span>
<a href="#l71.274"></a><span id="l71.274" class="difflineplus">+  BerElement* ber;</span>
<a href="#l71.275"></a><span id="l71.275">   int err;</span>
<a href="#l71.276"></a><span id="l71.276"> </span>
<a href="#l71.277"></a><span id="l71.277">   if ((err = nsldapi_alloc_ber_with_options(ld, &amp;ber)) != LDAP_SUCCESS) {</span>
<a href="#l71.278"></a><span id="l71.278">     return (err);</span>
<a href="#l71.279"></a><span id="l71.279">   }</span>
<a href="#l71.280"></a><span id="l71.280">   *berp = ber;</span>
<a href="#l71.281"></a><span id="l71.281">   if (ber_printf(ber, lr-&gt;lr_res_ctrls ? &quot;{it{ess}&quot; : &quot;{it{ess}}&quot;, lr-&gt;lr_msgid,</span>
<a href="#l71.282"></a><span id="l71.282">                  (long)lr-&gt;lr_res_msgtype, lr-&gt;lr_res_errno,</span>
<a href="#l71.283"></a><span id="l71.283" class="difflineat">@@ -1039,17 +1038,17 @@ static int build_result_ber(LDAP *ld, Be</span>
<a href="#l71.284"></a><span id="l71.284">       ber_get_int(ber, &amp;along) == LBER_ERROR ||</span>
<a href="#l71.285"></a><span id="l71.285">       ber_peek_tag(ber, &amp;len) == LBER_ERROR) {</span>
<a href="#l71.286"></a><span id="l71.286">     return (LDAP_DECODING_ERROR);</span>
<a href="#l71.287"></a><span id="l71.287">   }</span>
<a href="#l71.288"></a><span id="l71.288"> </span>
<a href="#l71.289"></a><span id="l71.289">   return (LDAP_SUCCESS);</span>
<a href="#l71.290"></a><span id="l71.290"> }</span>
<a href="#l71.291"></a><span id="l71.291"> </span>
<a href="#l71.292"></a><span id="l71.292" class="difflineminus">-static void merge_error_info(LDAP *ld, LDAPRequest *parentr, LDAPRequest *lr) {</span>
<a href="#l71.293"></a><span id="l71.293" class="difflineplus">+static void merge_error_info(LDAP* ld, LDAPRequest* parentr, LDAPRequest* lr) {</span>
<a href="#l71.294"></a><span id="l71.294">   /*</span>
<a href="#l71.295"></a><span id="l71.295">    * Merge error information in &quot;lr&quot; with &quot;parentr&quot; error code and string.</span>
<a href="#l71.296"></a><span id="l71.296">    */</span>
<a href="#l71.297"></a><span id="l71.297">   if (lr-&gt;lr_res_errno == LDAP_PARTIAL_RESULTS) {</span>
<a href="#l71.298"></a><span id="l71.298">     parentr-&gt;lr_res_errno = lr-&gt;lr_res_errno;</span>
<a href="#l71.299"></a><span id="l71.299">     if (lr-&gt;lr_res_error != NULL) {</span>
<a href="#l71.300"></a><span id="l71.300">       (void)nsldapi_append_referral(ld, &amp;parentr-&gt;lr_res_error,</span>
<a href="#l71.301"></a><span id="l71.301">                                     lr-&gt;lr_res_error);</span>
<a href="#l71.302"></a><span id="l71.302" class="difflineat">@@ -1078,20 +1077,20 @@ static void merge_error_info(LDAP *ld, L</span>
<a href="#l71.303"></a><span id="l71.303">             parentr-&gt;lr_res_error ? parentr-&gt;lr_res_error : &quot;&quot;,</span>
<a href="#l71.304"></a><span id="l71.304">             parentr-&gt;lr_res_matched ? parentr-&gt;lr_res_matched : &quot;&quot;);</span>
<a href="#l71.305"></a><span id="l71.305"> }</span>
<a href="#l71.306"></a><span id="l71.306"> </span>
<a href="#l71.307"></a><span id="l71.307"> #if defined(CLDAP)</span>
<a href="#l71.308"></a><span id="l71.308"> #  if !defined(macintosh) &amp;&amp; !defined(DOS) &amp;&amp; !defined(_WINDOWS) &amp;&amp; \</span>
<a href="#l71.309"></a><span id="l71.309">       !defined(XP_OS2)</span>
<a href="#l71.310"></a><span id="l71.310"> /* XXXmcs: was revised to support extended I/O callbacks but never compiled! */</span>
<a href="#l71.311"></a><span id="l71.311" class="difflineminus">-static int cldap_select1(LDAP *ld, struct timeval *timeout) {</span>
<a href="#l71.312"></a><span id="l71.312" class="difflineplus">+static int cldap_select1(LDAP* ld, struct timeval* timeout) {</span>
<a href="#l71.313"></a><span id="l71.313">   int rc;</span>
<a href="#l71.314"></a><span id="l71.314">   static int tblsize = 0;</span>
<a href="#l71.315"></a><span id="l71.315" class="difflineminus">-  NSLDAPIIOStatus *iosp = ld-&gt;ld_iostatus;</span>
<a href="#l71.316"></a><span id="l71.316" class="difflineplus">+  NSLDAPIIOStatus* iosp = ld-&gt;ld_iostatus;</span>
<a href="#l71.317"></a><span id="l71.317"> </span>
<a href="#l71.318"></a><span id="l71.318">   if (tblsize == 0) {</span>
<a href="#l71.319"></a><span id="l71.319"> #    ifdef USE_SYSCONF</span>
<a href="#l71.320"></a><span id="l71.320">     tblsize = sysconf(_SC_OPEN_MAX);</span>
<a href="#l71.321"></a><span id="l71.321"> #    else  /* USE_SYSCONF */</span>
<a href="#l71.322"></a><span id="l71.322">     tblsize = getdtablesize();</span>
<a href="#l71.323"></a><span id="l71.323"> #    endif /* USE_SYSCONF */</span>
<a href="#l71.324"></a><span id="l71.324">   }</span>
<a href="#l71.325"></a><span id="l71.325" class="difflineat">@@ -1127,25 +1126,25 @@ static int cldap_select1(LDAP *ld, struc</span>
<a href="#l71.326"></a><span id="l71.326">      rc = 0; /* simulate a timeout (what else to do?) */</span>
<a href="#l71.327"></a><span id="l71.327">   }</span>
<a href="#l71.328"></a><span id="l71.328"> </span>
<a href="#l71.329"></a><span id="l71.329">   return (rc);</span>
<a href="#l71.330"></a><span id="l71.330"> }</span>
<a href="#l71.331"></a><span id="l71.331"> #  endif /* !macintosh */</span>
<a href="#l71.332"></a><span id="l71.332"> </span>
<a href="#l71.333"></a><span id="l71.333"> #  ifdef macintosh</span>
<a href="#l71.334"></a><span id="l71.334" class="difflineminus">-static int cldap_select1(LDAP *ld, struct timeval *timeout) {</span>
<a href="#l71.335"></a><span id="l71.335" class="difflineplus">+static int cldap_select1(LDAP* ld, struct timeval* timeout) {</span>
<a href="#l71.336"></a><span id="l71.336">   /* XXXmcs: needs to be revised to support I/O callbacks */</span>
<a href="#l71.337"></a><span id="l71.337">   return (tcpselect(ld-&gt;ld_sbp-&gt;sb_sd, timeout));</span>
<a href="#l71.338"></a><span id="l71.338"> }</span>
<a href="#l71.339"></a><span id="l71.339"> #  endif /* macintosh */</span>
<a href="#l71.340"></a><span id="l71.340"> </span>
<a href="#l71.341"></a><span id="l71.341"> #  if (defined(DOS) &amp;&amp; defined(WINSOCK)) || defined(_WINDOWS) || defined(XP_OS2)</span>
<a href="#l71.342"></a><span id="l71.342"> /* XXXmcs: needs to be revised to support extended I/O callbacks */</span>
<a href="#l71.343"></a><span id="l71.343" class="difflineminus">-static int cldap_select1(LDAP *ld, struct timeval *timeout) {</span>
<a href="#l71.344"></a><span id="l71.344" class="difflineplus">+static int cldap_select1(LDAP* ld, struct timeval* timeout) {</span>
<a href="#l71.345"></a><span id="l71.345">   fd_set readfds;</span>
<a href="#l71.346"></a><span id="l71.346">   int rc;</span>
<a href="#l71.347"></a><span id="l71.347"> </span>
<a href="#l71.348"></a><span id="l71.348">   FD_ZERO(&amp;readfds);</span>
<a href="#l71.349"></a><span id="l71.349">   FD_SET(ld-&gt;ld_sbp-&gt;sb_sd, &amp;readfds);</span>
<a href="#l71.350"></a><span id="l71.350"> </span>
<a href="#l71.351"></a><span id="l71.351">   if (NSLDAPI_IO_TYPE_STANDARD == ld-&gt;ldiou_type &amp;&amp; NULL != ld-&gt;ld_select_fn) {</span>
<a href="#l71.352"></a><span id="l71.352">     rc = ld-&gt;ld_select_fn(1, &amp;readfds, 0, 0, timeout);</span>
<a href="#l71.353"></a><span id="l71.353" class="difflineat">@@ -1158,38 +1157,38 @@ static int cldap_select1(LDAP *ld, struc</span>
<a href="#l71.354"></a><span id="l71.354">             rc = select(1, &amp;readfds, 0, 0, timeout));</span>
<a href="#l71.355"></a><span id="l71.355">   }</span>
<a href="#l71.356"></a><span id="l71.356"> </span>
<a href="#l71.357"></a><span id="l71.357">   return (rc == SOCKET_ERROR ? -1 : rc);</span>
<a href="#l71.358"></a><span id="l71.358"> }</span>
<a href="#l71.359"></a><span id="l71.359"> #  endif /* WINSOCK || _WINDOWS */</span>
<a href="#l71.360"></a><span id="l71.360"> #endif   /* CLDAP */</span>
<a href="#l71.361"></a><span id="l71.361"> </span>
<a href="#l71.362"></a><span id="l71.362" class="difflineminus">-int LDAP_CALL ldap_msgfree(LDAPMessage *lm) {</span>
<a href="#l71.363"></a><span id="l71.363" class="difflineminus">-  LDAPMessage *next;</span>
<a href="#l71.364"></a><span id="l71.364" class="difflineplus">+int LDAP_CALL ldap_msgfree(LDAPMessage* lm) {</span>
<a href="#l71.365"></a><span id="l71.365" class="difflineplus">+  LDAPMessage* next;</span>
<a href="#l71.366"></a><span id="l71.366">   int type = 0;</span>
<a href="#l71.367"></a><span id="l71.367"> </span>
<a href="#l71.368"></a><span id="l71.368">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_msgfree\n&quot;, 0, 0, 0);</span>
<a href="#l71.369"></a><span id="l71.369"> </span>
<a href="#l71.370"></a><span id="l71.370">   for (; lm != NULL; lm = next) {</span>
<a href="#l71.371"></a><span id="l71.371">     next = lm-&gt;lm_chain;</span>
<a href="#l71.372"></a><span id="l71.372">     type = lm-&gt;lm_msgtype;</span>
<a href="#l71.373"></a><span id="l71.373">     ber_free(lm-&gt;lm_ber, 1);</span>
<a href="#l71.374"></a><span id="l71.374" class="difflineminus">-    NSLDAPI_FREE((char *)lm);</span>
<a href="#l71.375"></a><span id="l71.375" class="difflineplus">+    NSLDAPI_FREE((char*)lm);</span>
<a href="#l71.376"></a><span id="l71.376">   }</span>
<a href="#l71.377"></a><span id="l71.377"> </span>
<a href="#l71.378"></a><span id="l71.378">   return (type);</span>
<a href="#l71.379"></a><span id="l71.379"> }</span>
<a href="#l71.380"></a><span id="l71.380"> </span>
<a href="#l71.381"></a><span id="l71.381"> /*</span>
<a href="#l71.382"></a><span id="l71.382">  * ldap_msgdelete - delete a message.  It returns:</span>
<a href="#l71.383"></a><span id="l71.383">  *   0  if the entire message was deleted</span>
<a href="#l71.384"></a><span id="l71.384">  *  -1  if the message was not found, or only part of it was found</span>
<a href="#l71.385"></a><span id="l71.385">  */</span>
<a href="#l71.386"></a><span id="l71.386" class="difflineminus">-int ldap_msgdelete(LDAP *ld, int msgid) {</span>
<a href="#l71.387"></a><span id="l71.387" class="difflineplus">+int ldap_msgdelete(LDAP* ld, int msgid) {</span>
<a href="#l71.388"></a><span id="l71.388">   LDAPMessage *lm, *prev;</span>
<a href="#l71.389"></a><span id="l71.389">   int msgtype;</span>
<a href="#l71.390"></a><span id="l71.390"> </span>
<a href="#l71.391"></a><span id="l71.391">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_msgdelete\n&quot;, 0, 0, 0);</span>
<a href="#l71.392"></a><span id="l71.392"> </span>
<a href="#l71.393"></a><span id="l71.393">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l71.394"></a><span id="l71.394">     return (-1); /* punt */</span>
<a href="#l71.395"></a><span id="l71.395">   }</span>
<a href="#l71.396"></a><span id="l71.396" class="difflineat">@@ -1219,17 +1218,17 @@ int ldap_msgdelete(LDAP *ld, int msgid) </span>
<a href="#l71.397"></a><span id="l71.397">   }</span>
<a href="#l71.398"></a><span id="l71.398"> </span>
<a href="#l71.399"></a><span id="l71.399">   return (0);</span>
<a href="#l71.400"></a><span id="l71.400"> }</span>
<a href="#l71.401"></a><span id="l71.401"> </span>
<a href="#l71.402"></a><span id="l71.402"> /*</span>
<a href="#l71.403"></a><span id="l71.403">  * return 1 if message msgid is waiting to be abandoned, 0 otherwise</span>
<a href="#l71.404"></a><span id="l71.404">  */</span>
<a href="#l71.405"></a><span id="l71.405" class="difflineminus">-static int ldap_abandoned(LDAP *ld, int msgid) {</span>
<a href="#l71.406"></a><span id="l71.406" class="difflineplus">+static int ldap_abandoned(LDAP* ld, int msgid) {</span>
<a href="#l71.407"></a><span id="l71.407">   int i;</span>
<a href="#l71.408"></a><span id="l71.408"> </span>
<a href="#l71.409"></a><span id="l71.409">   LDAP_MUTEX_LOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l71.410"></a><span id="l71.410">   if (ld-&gt;ld_abandoned == NULL) {</span>
<a href="#l71.411"></a><span id="l71.411">     LDAP_MUTEX_UNLOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l71.412"></a><span id="l71.412">     return (0);</span>
<a href="#l71.413"></a><span id="l71.413">   }</span>
<a href="#l71.414"></a><span id="l71.414"> </span>
<a href="#l71.415"></a><span id="l71.415" class="difflineat">@@ -1238,17 +1237,17 @@ static int ldap_abandoned(LDAP *ld, int </span>
<a href="#l71.416"></a><span id="l71.416">       LDAP_MUTEX_UNLOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l71.417"></a><span id="l71.417">       return (1);</span>
<a href="#l71.418"></a><span id="l71.418">     }</span>
<a href="#l71.419"></a><span id="l71.419"> </span>
<a href="#l71.420"></a><span id="l71.420">   LDAP_MUTEX_UNLOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l71.421"></a><span id="l71.421">   return (0);</span>
<a href="#l71.422"></a><span id="l71.422"> }</span>
<a href="#l71.423"></a><span id="l71.423"> </span>
<a href="#l71.424"></a><span id="l71.424" class="difflineminus">-static int ldap_mark_abandoned(LDAP *ld, int msgid) {</span>
<a href="#l71.425"></a><span id="l71.425" class="difflineplus">+static int ldap_mark_abandoned(LDAP* ld, int msgid) {</span>
<a href="#l71.426"></a><span id="l71.426">   int i;</span>
<a href="#l71.427"></a><span id="l71.427"> </span>
<a href="#l71.428"></a><span id="l71.428">   LDAP_MUTEX_LOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l71.429"></a><span id="l71.429">   if (ld-&gt;ld_abandoned == NULL) {</span>
<a href="#l71.430"></a><span id="l71.430">     LDAP_MUTEX_UNLOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l71.431"></a><span id="l71.431">     return (-1);</span>
<a href="#l71.432"></a><span id="l71.432">   }</span>
<a href="#l71.433"></a><span id="l71.433"> </span>
<a href="#l71.434"></a><span id="l71.434" class="difflineat">@@ -1264,17 +1263,17 @@ static int ldap_mark_abandoned(LDAP *ld,</span>
<a href="#l71.435"></a><span id="l71.435">     ld-&gt;ld_abandoned[i] = ld-&gt;ld_abandoned[i + 1];</span>
<a href="#l71.436"></a><span id="l71.436">   }</span>
<a href="#l71.437"></a><span id="l71.437"> </span>
<a href="#l71.438"></a><span id="l71.438">   LDAP_MUTEX_UNLOCK(ld, LDAP_ABANDON_LOCK);</span>
<a href="#l71.439"></a><span id="l71.439">   return (0);</span>
<a href="#l71.440"></a><span id="l71.440"> }</span>
<a href="#l71.441"></a><span id="l71.441"> </span>
<a href="#l71.442"></a><span id="l71.442"> #ifdef CLDAP</span>
<a href="#l71.443"></a><span id="l71.443" class="difflineminus">-int cldap_getmsg(LDAP *ld, struct timeval *timeout, BerElement **ber) {</span>
<a href="#l71.444"></a><span id="l71.444" class="difflineplus">+int cldap_getmsg(LDAP* ld, struct timeval* timeout, BerElement** ber) {</span>
<a href="#l71.445"></a><span id="l71.445">   int rc;</span>
<a href="#l71.446"></a><span id="l71.446">   ber_tag_t tag;</span>
<a href="#l71.447"></a><span id="l71.447">   ber_len_t len;</span>
<a href="#l71.448"></a><span id="l71.448"> </span>
<a href="#l71.449"></a><span id="l71.449">   if (ld-&gt;ld_sbp-&gt;sb_ber.ber_ptr &gt;= ld-&gt;ld_sbp-&gt;sb_ber.ber_end) {</span>
<a href="#l71.450"></a><span id="l71.450">     rc = cldap_select1(ld, timeout);</span>
<a href="#l71.451"></a><span id="l71.451">     if (rc == -1 || rc == 0) {</span>
<a href="#l71.452"></a><span id="l71.452">       LDAP_SET_LDERRNO(ld, (rc == -1 ? LDAP_SERVER_DOWN : LDAP_TIMEOUT), NULL,</span>
<a href="#l71.453"></a><span id="l71.453" class="difflineat">@@ -1290,18 +1289,18 @@ int cldap_getmsg(LDAP *ld, struct timeva</span>
<a href="#l71.454"></a><span id="l71.454">         NULL);</span>
<a href="#l71.455"></a><span id="l71.455">     return (-1);</span>
<a href="#l71.456"></a><span id="l71.456">   }</span>
<a href="#l71.457"></a><span id="l71.457"> </span>
<a href="#l71.458"></a><span id="l71.458">   return (tag);</span>
<a href="#l71.459"></a><span id="l71.459"> }</span>
<a href="#l71.460"></a><span id="l71.460"> #endif /* CLDAP */</span>
<a href="#l71.461"></a><span id="l71.461"> </span>
<a href="#l71.462"></a><span id="l71.462" class="difflineminus">-int nsldapi_post_result(LDAP *ld, int msgid, LDAPMessage *result) {</span>
<a href="#l71.463"></a><span id="l71.463" class="difflineminus">-  LDAPPend *lp;</span>
<a href="#l71.464"></a><span id="l71.464" class="difflineplus">+int nsldapi_post_result(LDAP* ld, int msgid, LDAPMessage* result) {</span>
<a href="#l71.465"></a><span id="l71.465" class="difflineplus">+  LDAPPend* lp;</span>
<a href="#l71.466"></a><span id="l71.466"> </span>
<a href="#l71.467"></a><span id="l71.467">   LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l71.468"></a><span id="l71.468">             &quot;nsldapi_post_result(ld=0x%p, msgid=%d, result=0x%p)\n&quot;, ld, msgid,</span>
<a href="#l71.469"></a><span id="l71.469">             result);</span>
<a href="#l71.470"></a><span id="l71.470">   LDAP_MUTEX_LOCK(ld, LDAP_PEND_LOCK);</span>
<a href="#l71.471"></a><span id="l71.471">   if (msgid == LDAP_RES_ANY) {</span>
<a href="#l71.472"></a><span id="l71.472">     /*</span>
<a href="#l71.473"></a><span id="l71.473">      * Look for any pending request for which someone is waiting.</span>
<a href="#l71.474"></a><span id="l71.474" class="difflineat">@@ -1324,18 +1323,18 @@ int nsldapi_post_result(LDAP *ld, int ms</span>
<a href="#l71.475"></a><span id="l71.475">       if (lp-&gt;lp_msgid == msgid) break;</span>
<a href="#l71.476"></a><span id="l71.476">     }</span>
<a href="#l71.477"></a><span id="l71.477"> </span>
<a href="#l71.478"></a><span id="l71.478">     if (lp == NULL) {</span>
<a href="#l71.479"></a><span id="l71.479">       /*</span>
<a href="#l71.480"></a><span id="l71.480">        * No pending requests for this response... append to</span>
<a href="#l71.481"></a><span id="l71.481">        * our pending result list.</span>
<a href="#l71.482"></a><span id="l71.482">        */</span>
<a href="#l71.483"></a><span id="l71.483" class="difflineminus">-      LDAPPend *newlp;</span>
<a href="#l71.484"></a><span id="l71.484" class="difflineminus">-      newlp = (LDAPPend *)NSLDAPI_CALLOC(1, sizeof(LDAPPend));</span>
<a href="#l71.485"></a><span id="l71.485" class="difflineplus">+      LDAPPend* newlp;</span>
<a href="#l71.486"></a><span id="l71.486" class="difflineplus">+      newlp = (LDAPPend*)NSLDAPI_CALLOC(1, sizeof(LDAPPend));</span>
<a href="#l71.487"></a><span id="l71.487">       if (newlp == NULL) {</span>
<a href="#l71.488"></a><span id="l71.488">         LDAP_MUTEX_UNLOCK(ld, LDAP_PEND_LOCK);</span>
<a href="#l71.489"></a><span id="l71.489">         LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l71.490"></a><span id="l71.490">         return (-1);</span>
<a href="#l71.491"></a><span id="l71.491">       }</span>
<a href="#l71.492"></a><span id="l71.492">       newlp-&gt;lp_msgid = msgid;</span>
<a href="#l71.493"></a><span id="l71.493">       newlp-&gt;lp_result = result;</span>
<a href="#l71.494"></a><span id="l71.494">       link_pend(ld, newlp);</span>
<a href="#l71.495"></a><span id="l71.495" class="difflineat">@@ -1350,15 +1349,15 @@ int nsldapi_post_result(LDAP *ld, int ms</span>
<a href="#l71.496"></a><span id="l71.496">     lp-&gt;lp_result = result;</span>
<a href="#l71.497"></a><span id="l71.497">     LDAP_SEMA_POST(ld, lp);</span>
<a href="#l71.498"></a><span id="l71.498">   }</span>
<a href="#l71.499"></a><span id="l71.499"> </span>
<a href="#l71.500"></a><span id="l71.500">   LDAP_MUTEX_UNLOCK(ld, LDAP_PEND_LOCK);</span>
<a href="#l71.501"></a><span id="l71.501">   return (0);</span>
<a href="#l71.502"></a><span id="l71.502"> }</span>
<a href="#l71.503"></a><span id="l71.503"> </span>
<a href="#l71.504"></a><span id="l71.504" class="difflineminus">-static void link_pend(LDAP *ld, LDAPPend *lp) {</span>
<a href="#l71.505"></a><span id="l71.505" class="difflineplus">+static void link_pend(LDAP* ld, LDAPPend* lp) {</span>
<a href="#l71.506"></a><span id="l71.506">   if ((lp-&gt;lp_next = ld-&gt;ld_pend) != NULL) {</span>
<a href="#l71.507"></a><span id="l71.507">     lp-&gt;lp_next-&gt;lp_prev = lp;</span>
<a href="#l71.508"></a><span id="l71.508">   }</span>
<a href="#l71.509"></a><span id="l71.509">   ld-&gt;ld_pend = lp;</span>
<a href="#l71.510"></a><span id="l71.510">   lp-&gt;lp_prev = NULL;</span>
<a href="#l71.511"></a><span id="l71.511"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l72.1"></a><span id="l72.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/saslbind.c</span>
<a href="#l72.2"></a><span id="l72.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/saslbind.c</span>
<a href="#l72.3"></a><span id="l72.3" class="difflineat">@@ -48,17 +48,17 @@ sasl_callback_t client_callbacks[] = {{S</span>
<a href="#l72.4"></a><span id="l72.4">                                       {SASL_CB_USER, NULL, NULL},</span>
<a href="#l72.5"></a><span id="l72.5">                                       {SASL_CB_CANON_USER, NULL, NULL},</span>
<a href="#l72.6"></a><span id="l72.6">                                       {SASL_CB_AUTHNAME, NULL, NULL},</span>
<a href="#l72.7"></a><span id="l72.7">                                       {SASL_CB_PASS, NULL, NULL},</span>
<a href="#l72.8"></a><span id="l72.8">                                       {SASL_CB_ECHOPROMPT, NULL, NULL},</span>
<a href="#l72.9"></a><span id="l72.9">                                       {SASL_CB_NOECHOPROMPT, NULL, NULL},</span>
<a href="#l72.10"></a><span id="l72.10">                                       {SASL_CB_LIST_END, NULL, NULL}};</span>
<a href="#l72.11"></a><span id="l72.11"> </span>
<a href="#l72.12"></a><span id="l72.12" class="difflineminus">-int nsldapi_sasl_cvterrno(LDAP *ld, int err, char *msg) {</span>
<a href="#l72.13"></a><span id="l72.13" class="difflineplus">+int nsldapi_sasl_cvterrno(LDAP* ld, int err, char* msg) {</span>
<a href="#l72.14"></a><span id="l72.14">   int rc = LDAP_LOCAL_ERROR;</span>
<a href="#l72.15"></a><span id="l72.15"> </span>
<a href="#l72.16"></a><span id="l72.16">   switch (err) {</span>
<a href="#l72.17"></a><span id="l72.17">     case SASL_OK:</span>
<a href="#l72.18"></a><span id="l72.18">       rc = LDAP_SUCCESS;</span>
<a href="#l72.19"></a><span id="l72.19">       break;</span>
<a href="#l72.20"></a><span id="l72.20">     case SASL_NOMECH:</span>
<a href="#l72.21"></a><span id="l72.21">       rc = LDAP_AUTH_UNKNOWN;</span>
<a href="#l72.22"></a><span id="l72.22" class="difflineat">@@ -99,18 +99,18 @@ int nsldapi_sasl_cvterrno(LDAP *ld, int </span>
<a href="#l72.23"></a><span id="l72.23">   return (rc);</span>
<a href="#l72.24"></a><span id="l72.24"> }</span>
<a href="#l72.25"></a><span id="l72.25"> </span>
<a href="#l72.26"></a><span id="l72.26"> #  ifdef LDAP_SASLIO_GET_MECHS_FROM_SERVER</span>
<a href="#l72.27"></a><span id="l72.27"> /*</span>
<a href="#l72.28"></a><span id="l72.28">  * Get available SASL Mechanisms supported by the server</span>
<a href="#l72.29"></a><span id="l72.29">  */</span>
<a href="#l72.30"></a><span id="l72.30"> </span>
<a href="#l72.31"></a><span id="l72.31" class="difflineminus">-static int nsldapi_get_sasl_mechs(LDAP *ld, char **pmech) {</span>
<a href="#l72.32"></a><span id="l72.32" class="difflineminus">-  char *attr[] = {&quot;supportedSASLMechanisms&quot;, NULL};</span>
<a href="#l72.33"></a><span id="l72.33" class="difflineplus">+static int nsldapi_get_sasl_mechs(LDAP* ld, char** pmech) {</span>
<a href="#l72.34"></a><span id="l72.34" class="difflineplus">+  char* attr[] = {&quot;supportedSASLMechanisms&quot;, NULL};</span>
<a href="#l72.35"></a><span id="l72.35">   char **values, **v, *mech, *m;</span>
<a href="#l72.36"></a><span id="l72.36">   LDAPMessage *res, *e;</span>
<a href="#l72.37"></a><span id="l72.37">   struct timeval timeout;</span>
<a href="#l72.38"></a><span id="l72.38">   int slen, rc;</span>
<a href="#l72.39"></a><span id="l72.39"> </span>
<a href="#l72.40"></a><span id="l72.40">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l72.41"></a><span id="l72.41">     return (LDAP_PARAM_ERROR);</span>
<a href="#l72.42"></a><span id="l72.42">   }</span>
<a href="#l72.43"></a><span id="l72.43" class="difflineat">@@ -166,21 +166,21 @@ static int nsldapi_get_sasl_mechs(LDAP *</span>
<a href="#l72.44"></a><span id="l72.44">   ldap_msgfree(res);</span>
<a href="#l72.45"></a><span id="l72.45"> </span>
<a href="#l72.46"></a><span id="l72.46">   *pmech = mech;</span>
<a href="#l72.47"></a><span id="l72.47"> </span>
<a href="#l72.48"></a><span id="l72.48">   return (LDAP_SUCCESS);</span>
<a href="#l72.49"></a><span id="l72.49"> }</span>
<a href="#l72.50"></a><span id="l72.50"> #  endif /* LDAP_SASLIO_GET_MECHS_FROM_SERVER */</span>
<a href="#l72.51"></a><span id="l72.51"> </span>
<a href="#l72.52"></a><span id="l72.52" class="difflineminus">-int nsldapi_sasl_secprops(const char *in,</span>
<a href="#l72.53"></a><span id="l72.53" class="difflineminus">-                          sasl_security_properties_t *secprops) {</span>
<a href="#l72.54"></a><span id="l72.54" class="difflineplus">+int nsldapi_sasl_secprops(const char* in,</span>
<a href="#l72.55"></a><span id="l72.55" class="difflineplus">+                          sasl_security_properties_t* secprops) {</span>
<a href="#l72.56"></a><span id="l72.56">   int i;</span>
<a href="#l72.57"></a><span id="l72.57" class="difflineminus">-  char **props = NULL;</span>
<a href="#l72.58"></a><span id="l72.58" class="difflineminus">-  char *inp;</span>
<a href="#l72.59"></a><span id="l72.59" class="difflineplus">+  char** props = NULL;</span>
<a href="#l72.60"></a><span id="l72.60" class="difflineplus">+  char* inp;</span>
<a href="#l72.61"></a><span id="l72.61">   unsigned sflags = 0;</span>
<a href="#l72.62"></a><span id="l72.62">   sasl_ssf_t max_ssf = 0;</span>
<a href="#l72.63"></a><span id="l72.63">   sasl_ssf_t min_ssf = 0;</span>
<a href="#l72.64"></a><span id="l72.64">   unsigned maxbufsize = 0;</span>
<a href="#l72.65"></a><span id="l72.65">   int got_sflags = 0;</span>
<a href="#l72.66"></a><span id="l72.66">   int got_max_ssf = 0;</span>
<a href="#l72.67"></a><span id="l72.67">   int got_min_ssf = 0;</span>
<a href="#l72.68"></a><span id="l72.68">   int got_maxbufsize = 0;</span>
<a href="#l72.69"></a><span id="l72.69" class="difflineat">@@ -273,41 +273,41 @@ int nsldapi_sasl_secprops(const char *in</span>
<a href="#l72.70"></a><span id="l72.70">     secprops-&gt;maxbufsize = maxbufsize;</span>
<a href="#l72.71"></a><span id="l72.71">   }</span>
<a href="#l72.72"></a><span id="l72.72"> </span>
<a href="#l72.73"></a><span id="l72.73">   ldap_charray_free(props);</span>
<a href="#l72.74"></a><span id="l72.74">   return (LDAP_SUCCESS);</span>
<a href="#l72.75"></a><span id="l72.75"> }</span>
<a href="#l72.76"></a><span id="l72.76"> #endif /* LDAP_SASLIO_HOOKS */</span>
<a href="#l72.77"></a><span id="l72.77"> </span>
<a href="#l72.78"></a><span id="l72.78" class="difflineminus">-static int nsldapi_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,</span>
<a href="#l72.79"></a><span id="l72.79" class="difflineminus">-                               const struct berval *cred,</span>
<a href="#l72.80"></a><span id="l72.80" class="difflineminus">-                               LDAPControl **serverctrls,</span>
<a href="#l72.81"></a><span id="l72.81" class="difflineminus">-                               LDAPControl **clientctrls,</span>
<a href="#l72.82"></a><span id="l72.82" class="difflineminus">-                               struct berval **servercredp,</span>
<a href="#l72.83"></a><span id="l72.83" class="difflineminus">-                               LDAPControl ***responsectrls) {</span>
<a href="#l72.84"></a><span id="l72.84" class="difflineplus">+static int nsldapi_sasl_bind_s(LDAP* ld, const char* dn, const char* mechanism,</span>
<a href="#l72.85"></a><span id="l72.85" class="difflineplus">+                               const struct berval* cred,</span>
<a href="#l72.86"></a><span id="l72.86" class="difflineplus">+                               LDAPControl** serverctrls,</span>
<a href="#l72.87"></a><span id="l72.87" class="difflineplus">+                               LDAPControl** clientctrls,</span>
<a href="#l72.88"></a><span id="l72.88" class="difflineplus">+                               struct berval** servercredp,</span>
<a href="#l72.89"></a><span id="l72.89" class="difflineplus">+                               LDAPControl*** responsectrls) {</span>
<a href="#l72.90"></a><span id="l72.90">   int err, msgid;</span>
<a href="#l72.91"></a><span id="l72.91" class="difflineminus">-  LDAPMessage *result;</span>
<a href="#l72.92"></a><span id="l72.92" class="difflineplus">+  LDAPMessage* result;</span>
<a href="#l72.93"></a><span id="l72.93"> </span>
<a href="#l72.94"></a><span id="l72.94">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_sasl_bind_s\n&quot;, 0, 0, 0);</span>
<a href="#l72.95"></a><span id="l72.95"> </span>
<a href="#l72.96"></a><span id="l72.96">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l72.97"></a><span id="l72.97">     return (LDAP_PARAM_ERROR);</span>
<a href="#l72.98"></a><span id="l72.98">   }</span>
<a href="#l72.99"></a><span id="l72.99"> </span>
<a href="#l72.100"></a><span id="l72.100">   if (NSLDAPI_LDAP_VERSION(ld) &lt; LDAP_VERSION3) {</span>
<a href="#l72.101"></a><span id="l72.101">     LDAP_SET_LDERRNO(ld, LDAP_NOT_SUPPORTED, NULL, NULL);</span>
<a href="#l72.102"></a><span id="l72.102">     return (LDAP_NOT_SUPPORTED);</span>
<a href="#l72.103"></a><span id="l72.103">   }</span>
<a href="#l72.104"></a><span id="l72.104"> </span>
<a href="#l72.105"></a><span id="l72.105">   if ((err = ldap_sasl_bind(ld, dn, mechanism, cred, serverctrls, clientctrls,</span>
<a href="#l72.106"></a><span id="l72.106">                             &amp;msgid)) != LDAP_SUCCESS)</span>
<a href="#l72.107"></a><span id="l72.107">     return (err);</span>
<a href="#l72.108"></a><span id="l72.108"> </span>
<a href="#l72.109"></a><span id="l72.109" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)0, &amp;result) == -1)</span>
<a href="#l72.110"></a><span id="l72.110" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)0, &amp;result) == -1)</span>
<a href="#l72.111"></a><span id="l72.111">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l72.112"></a><span id="l72.112"> </span>
<a href="#l72.113"></a><span id="l72.113">   /* Get the controls sent by the server if requested */</span>
<a href="#l72.114"></a><span id="l72.114">   if (responsectrls) {</span>
<a href="#l72.115"></a><span id="l72.115">     if ((err = ldap_parse_result(ld, result, &amp;err, NULL, NULL, NULL,</span>
<a href="#l72.116"></a><span id="l72.116">                                  responsectrls, 0)) != LDAP_SUCCESS)</span>
<a href="#l72.117"></a><span id="l72.117">       return (err);</span>
<a href="#l72.118"></a><span id="l72.118">   }</span>
<a href="#l72.119"></a><span id="l72.119" class="difflineat">@@ -317,30 +317,30 @@ static int nsldapi_sasl_bind_s(LDAP *ld,</span>
<a href="#l72.120"></a><span id="l72.120">     ldap_msgfree(result);</span>
<a href="#l72.121"></a><span id="l72.121">     return (err);</span>
<a href="#l72.122"></a><span id="l72.122">   }</span>
<a href="#l72.123"></a><span id="l72.123"> </span>
<a href="#l72.124"></a><span id="l72.124">   return (ldap_result2error(ld, result, 1));</span>
<a href="#l72.125"></a><span id="l72.125"> }</span>
<a href="#l72.126"></a><span id="l72.126"> </span>
<a href="#l72.127"></a><span id="l72.127"> #ifdef LDAP_SASLIO_HOOKS</span>
<a href="#l72.128"></a><span id="l72.128" class="difflineminus">-static int nsldapi_sasl_do_bind(LDAP *ld, const char *dn, const char *mechs,</span>
<a href="#l72.129"></a><span id="l72.129" class="difflineplus">+static int nsldapi_sasl_do_bind(LDAP* ld, const char* dn, const char* mechs,</span>
<a href="#l72.130"></a><span id="l72.130">                                 unsigned flags,</span>
<a href="#l72.131"></a><span id="l72.131" class="difflineminus">-                                LDAP_SASL_INTERACT_PROC *callback,</span>
<a href="#l72.132"></a><span id="l72.132" class="difflineminus">-                                void *defaults, LDAPControl **sctrl,</span>
<a href="#l72.133"></a><span id="l72.133" class="difflineminus">-                                LDAPControl **cctrl, LDAPControl ***rctrl) {</span>
<a href="#l72.134"></a><span id="l72.134" class="difflineminus">-  sasl_interact_t *prompts = NULL;</span>
<a href="#l72.135"></a><span id="l72.135" class="difflineminus">-  sasl_conn_t *ctx = NULL;</span>
<a href="#l72.136"></a><span id="l72.136" class="difflineminus">-  sasl_ssf_t *ssf = NULL;</span>
<a href="#l72.137"></a><span id="l72.137" class="difflineminus">-  const char *mech = NULL;</span>
<a href="#l72.138"></a><span id="l72.138" class="difflineplus">+                                LDAP_SASL_INTERACT_PROC* callback,</span>
<a href="#l72.139"></a><span id="l72.139" class="difflineplus">+                                void* defaults, LDAPControl** sctrl,</span>
<a href="#l72.140"></a><span id="l72.140" class="difflineplus">+                                LDAPControl** cctrl, LDAPControl*** rctrl) {</span>
<a href="#l72.141"></a><span id="l72.141" class="difflineplus">+  sasl_interact_t* prompts = NULL;</span>
<a href="#l72.142"></a><span id="l72.142" class="difflineplus">+  sasl_conn_t* ctx = NULL;</span>
<a href="#l72.143"></a><span id="l72.143" class="difflineplus">+  sasl_ssf_t* ssf = NULL;</span>
<a href="#l72.144"></a><span id="l72.144" class="difflineplus">+  const char* mech = NULL;</span>
<a href="#l72.145"></a><span id="l72.145">   int saslrc, rc;</span>
<a href="#l72.146"></a><span id="l72.146">   struct berval ccred;</span>
<a href="#l72.147"></a><span id="l72.147">   unsigned credlen;</span>
<a href="#l72.148"></a><span id="l72.148">   int stepnum = 1;</span>
<a href="#l72.149"></a><span id="l72.149" class="difflineminus">-  char *sasl_username = NULL;</span>
<a href="#l72.150"></a><span id="l72.150" class="difflineplus">+  char* sasl_username = NULL;</span>
<a href="#l72.151"></a><span id="l72.151"> </span>
<a href="#l72.152"></a><span id="l72.152">   if (rctrl) {</span>
<a href="#l72.153"></a><span id="l72.153">     /* init to NULL so we can call ldap_controls_free below */</span>
<a href="#l72.154"></a><span id="l72.154">     *rctrl = NULL;</span>
<a href="#l72.155"></a><span id="l72.155">   }</span>
<a href="#l72.156"></a><span id="l72.156"> </span>
<a href="#l72.157"></a><span id="l72.157">   if (NSLDAPI_LDAP_VERSION(ld) &lt; LDAP_VERSION3) {</span>
<a href="#l72.158"></a><span id="l72.158">     LDAP_SET_LDERRNO(ld, LDAP_NOT_SUPPORTED, NULL, NULL);</span>
<a href="#l72.159"></a><span id="l72.159" class="difflineat">@@ -359,17 +359,17 @@ static int nsldapi_sasl_do_bind(LDAP *ld</span>
<a href="#l72.160"></a><span id="l72.160">   ccred.bv_val = NULL;</span>
<a href="#l72.161"></a><span id="l72.161">   ccred.bv_len = 0;</span>
<a href="#l72.162"></a><span id="l72.162"> </span>
<a href="#l72.163"></a><span id="l72.163">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;Starting SASL/%s authentication\n&quot;,</span>
<a href="#l72.164"></a><span id="l72.164">             (mechs ? mechs : &quot;&quot;), 0, 0);</span>
<a href="#l72.165"></a><span id="l72.165"> </span>
<a href="#l72.166"></a><span id="l72.166">   do {</span>
<a href="#l72.167"></a><span id="l72.167">     saslrc = sasl_client_start(ctx, mechs, &amp;prompts,</span>
<a href="#l72.168"></a><span id="l72.168" class="difflineminus">-                               (const char **)&amp;ccred.bv_val, &amp;credlen, &amp;mech);</span>
<a href="#l72.169"></a><span id="l72.169" class="difflineplus">+                               (const char**)&amp;ccred.bv_val, &amp;credlen, &amp;mech);</span>
<a href="#l72.170"></a><span id="l72.170"> </span>
<a href="#l72.171"></a><span id="l72.171">     LDAPDebug(LDAP_DEBUG_TRACE,</span>
<a href="#l72.172"></a><span id="l72.172">               &quot;Doing step %d of client start for SASL/%s authentication\n&quot;,</span>
<a href="#l72.173"></a><span id="l72.173">               stepnum, (mech ? mech : &quot;&quot;), 0);</span>
<a href="#l72.174"></a><span id="l72.174">     stepnum++;</span>
<a href="#l72.175"></a><span id="l72.175"> </span>
<a href="#l72.176"></a><span id="l72.176">     if (saslrc == SASL_INTERACT &amp;&amp;</span>
<a href="#l72.177"></a><span id="l72.177">         (callback)(ld, flags, defaults, prompts) != LDAP_SUCCESS) {</span>
<a href="#l72.178"></a><span id="l72.178" class="difflineat">@@ -382,17 +382,17 @@ static int nsldapi_sasl_do_bind(LDAP *ld</span>
<a href="#l72.179"></a><span id="l72.179">   if ((saslrc != SASL_OK) &amp;&amp; (saslrc != SASL_CONTINUE)) {</span>
<a href="#l72.180"></a><span id="l72.180">     return (</span>
<a href="#l72.181"></a><span id="l72.181">         nsldapi_sasl_cvterrno(ld, saslrc, nsldapi_strdup(sasl_errdetail(ctx))));</span>
<a href="#l72.182"></a><span id="l72.182">   }</span>
<a href="#l72.183"></a><span id="l72.183"> </span>
<a href="#l72.184"></a><span id="l72.184">   stepnum = 1;</span>
<a href="#l72.185"></a><span id="l72.185"> </span>
<a href="#l72.186"></a><span id="l72.186">   do {</span>
<a href="#l72.187"></a><span id="l72.187" class="difflineminus">-    struct berval *scred;</span>
<a href="#l72.188"></a><span id="l72.188" class="difflineplus">+    struct berval* scred;</span>
<a href="#l72.189"></a><span id="l72.189">     int clientstepnum = 1;</span>
<a href="#l72.190"></a><span id="l72.190"> </span>
<a href="#l72.191"></a><span id="l72.191">     scred = NULL;</span>
<a href="#l72.192"></a><span id="l72.192"> </span>
<a href="#l72.193"></a><span id="l72.193">     if (rctrl) {</span>
<a href="#l72.194"></a><span id="l72.194">       /* if we're looping again, we need to free any controls set</span>
<a href="#l72.195"></a><span id="l72.195">          during the previous loop */</span>
<a href="#l72.196"></a><span id="l72.196">       /* NOTE that this assumes we only care about the controls</span>
<a href="#l72.197"></a><span id="l72.197" class="difflineat">@@ -448,17 +448,17 @@ static int nsldapi_sasl_do_bind(LDAP *ld</span>
<a href="#l72.198"></a><span id="l72.198">     do {</span>
<a href="#l72.199"></a><span id="l72.199">       LDAPDebug(</span>
<a href="#l72.200"></a><span id="l72.200">           LDAP_DEBUG_TRACE,</span>
<a href="#l72.201"></a><span id="l72.201">           &quot;Doing client step %d of bind step %d for SASL/%s authentication\n&quot;,</span>
<a href="#l72.202"></a><span id="l72.202">           clientstepnum, stepnum, (mech ? mech : &quot;&quot;));</span>
<a href="#l72.203"></a><span id="l72.203">       clientstepnum++;</span>
<a href="#l72.204"></a><span id="l72.204">       saslrc = sasl_client_step(ctx, (scred == NULL) ? NULL : scred-&gt;bv_val,</span>
<a href="#l72.205"></a><span id="l72.205">                                 (scred == NULL) ? 0 : scred-&gt;bv_len, &amp;prompts,</span>
<a href="#l72.206"></a><span id="l72.206" class="difflineminus">-                                (const char **)&amp;ccred.bv_val, &amp;credlen);</span>
<a href="#l72.207"></a><span id="l72.207" class="difflineplus">+                                (const char**)&amp;ccred.bv_val, &amp;credlen);</span>
<a href="#l72.208"></a><span id="l72.208"> </span>
<a href="#l72.209"></a><span id="l72.209">       if (saslrc == SASL_INTERACT &amp;&amp;</span>
<a href="#l72.210"></a><span id="l72.210">           (callback)(ld, flags, defaults, prompts) != LDAP_SUCCESS) {</span>
<a href="#l72.211"></a><span id="l72.211">         break;</span>
<a href="#l72.212"></a><span id="l72.212">       }</span>
<a href="#l72.213"></a><span id="l72.213">     } while (saslrc == SASL_INTERACT);</span>
<a href="#l72.214"></a><span id="l72.214"> </span>
<a href="#l72.215"></a><span id="l72.215">     ccred.bv_len = credlen;</span>
<a href="#l72.216"></a><span id="l72.216" class="difflineat">@@ -474,22 +474,22 @@ static int nsldapi_sasl_do_bind(LDAP *ld</span>
<a href="#l72.217"></a><span id="l72.217">     return (rc);</span>
<a href="#l72.218"></a><span id="l72.218">   }</span>
<a href="#l72.219"></a><span id="l72.219"> </span>
<a href="#l72.220"></a><span id="l72.220">   if (saslrc != SASL_OK) {</span>
<a href="#l72.221"></a><span id="l72.221">     return (</span>
<a href="#l72.222"></a><span id="l72.222">         nsldapi_sasl_cvterrno(ld, saslrc, nsldapi_strdup(sasl_errdetail(ctx))));</span>
<a href="#l72.223"></a><span id="l72.223">   }</span>
<a href="#l72.224"></a><span id="l72.224"> </span>
<a href="#l72.225"></a><span id="l72.225" class="difflineminus">-  saslrc = sasl_getprop(ctx, SASL_USERNAME, (const void **)&amp;sasl_username);</span>
<a href="#l72.226"></a><span id="l72.226" class="difflineplus">+  saslrc = sasl_getprop(ctx, SASL_USERNAME, (const void**)&amp;sasl_username);</span>
<a href="#l72.227"></a><span id="l72.227">   if ((saslrc == SASL_OK) &amp;&amp; sasl_username) {</span>
<a href="#l72.228"></a><span id="l72.228">     LDAPDebug(LDAP_DEBUG_TRACE, &quot;SASL identity: %s\n&quot;, sasl_username, 0, 0);</span>
<a href="#l72.229"></a><span id="l72.229">   }</span>
<a href="#l72.230"></a><span id="l72.230"> </span>
<a href="#l72.231"></a><span id="l72.231" class="difflineminus">-  saslrc = sasl_getprop(ctx, SASL_SSF, (const void **)&amp;ssf);</span>
<a href="#l72.232"></a><span id="l72.232" class="difflineplus">+  saslrc = sasl_getprop(ctx, SASL_SSF, (const void**)&amp;ssf);</span>
<a href="#l72.233"></a><span id="l72.233">   if (saslrc == SASL_OK) {</span>
<a href="#l72.234"></a><span id="l72.234">     if (ssf &amp;&amp; *ssf) {</span>
<a href="#l72.235"></a><span id="l72.235">       LDAPDebug(LDAP_DEBUG_TRACE, &quot;SASL install encryption, for SSF: %lu\n&quot;,</span>
<a href="#l72.236"></a><span id="l72.236">                 (unsigned long)*ssf, 0, 0);</span>
<a href="#l72.237"></a><span id="l72.237">       nsldapi_sasl_install(ld, NULL);</span>
<a href="#l72.238"></a><span id="l72.238">     }</span>
<a href="#l72.239"></a><span id="l72.239">   }</span>
<a href="#l72.240"></a><span id="l72.240"> </span>
<a href="#l72.241"></a><span id="l72.241" class="difflineat">@@ -507,21 +507,21 @@ static int nsldapi_sasl_do_bind(LDAP *ld</span>
<a href="#l72.242"></a><span id="l72.242">  * struct berval  creds;</span>
<a href="#l72.243"></a><span id="l72.243">  * LDAPControl  **ctrls;</span>
<a href="#l72.244"></a><span id="l72.244">  * int    err, msgid;</span>
<a href="#l72.245"></a><span id="l72.245">  * ... fill in creds with credentials ...</span>
<a href="#l72.246"></a><span id="l72.246">  * ... fill in ctrls with server controls ...</span>
<a href="#l72.247"></a><span id="l72.247">  * err = ldap_sasl_bind(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l72.248"></a><span id="l72.248">  *                      &quot;mechanismname&quot;, &amp;creds, ctrls, NULL, &amp;msgid);</span>
<a href="#l72.249"></a><span id="l72.249">  */</span>
<a href="#l72.250"></a><span id="l72.250" class="difflineminus">-int LDAP_CALL ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,</span>
<a href="#l72.251"></a><span id="l72.251" class="difflineminus">-                             const struct berval *cred,</span>
<a href="#l72.252"></a><span id="l72.252" class="difflineminus">-                             LDAPControl **serverctrls,</span>
<a href="#l72.253"></a><span id="l72.253" class="difflineminus">-                             LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l72.254"></a><span id="l72.254" class="difflineminus">-  BerElement *ber;</span>
<a href="#l72.255"></a><span id="l72.255" class="difflineplus">+int LDAP_CALL ldap_sasl_bind(LDAP* ld, const char* dn, const char* mechanism,</span>
<a href="#l72.256"></a><span id="l72.256" class="difflineplus">+                             const struct berval* cred,</span>
<a href="#l72.257"></a><span id="l72.257" class="difflineplus">+                             LDAPControl** serverctrls,</span>
<a href="#l72.258"></a><span id="l72.258" class="difflineplus">+                             LDAPControl** clientctrls, int* msgidp) {</span>
<a href="#l72.259"></a><span id="l72.259" class="difflineplus">+  BerElement* ber;</span>
<a href="#l72.260"></a><span id="l72.260">   int rc, simple, msgid, ldapversion;</span>
<a href="#l72.261"></a><span id="l72.261"> </span>
<a href="#l72.262"></a><span id="l72.262">   /*</span>
<a href="#l72.263"></a><span id="l72.263">    * The ldapv3 bind request looks like this:</span>
<a href="#l72.264"></a><span id="l72.264">    * BindRequest ::= SEQUENCE {</span>
<a href="#l72.265"></a><span id="l72.265">    *   version INTEGER,</span>
<a href="#l72.266"></a><span id="l72.266">    *   name DistinguishedName,      -- who</span>
<a href="#l72.267"></a><span id="l72.267">    *   authentication CHOICE {</span>
<a href="#l72.268"></a><span id="l72.268" class="difflineat">@@ -612,38 +612,38 @@ int LDAP_CALL ldap_sasl_bind(LDAP *ld, c</span>
<a href="#l72.269"></a><span id="l72.269">   }</span>
<a href="#l72.270"></a><span id="l72.270"> </span>
<a href="#l72.271"></a><span id="l72.271">   if ((rc = nsldapi_put_controls(ld, serverctrls, 1, ber)) != LDAP_SUCCESS) {</span>
<a href="#l72.272"></a><span id="l72.272">     ber_free(ber, 1);</span>
<a href="#l72.273"></a><span id="l72.273">     return (rc);</span>
<a href="#l72.274"></a><span id="l72.274">   }</span>
<a href="#l72.275"></a><span id="l72.275"> </span>
<a href="#l72.276"></a><span id="l72.276">   /* send the message */</span>
<a href="#l72.277"></a><span id="l72.277" class="difflineminus">-  rc = nsldapi_send_initial_request(ld, msgid, LDAP_REQ_BIND, (char *)dn, ber);</span>
<a href="#l72.278"></a><span id="l72.278" class="difflineplus">+  rc = nsldapi_send_initial_request(ld, msgid, LDAP_REQ_BIND, (char*)dn, ber);</span>
<a href="#l72.279"></a><span id="l72.279">   *msgidp = rc;</span>
<a href="#l72.280"></a><span id="l72.280">   return (rc &lt; 0 ? LDAP_GET_LDERRNO(ld, NULL, NULL) : LDAP_SUCCESS);</span>
<a href="#l72.281"></a><span id="l72.281"> }</span>
<a href="#l72.282"></a><span id="l72.282"> </span>
<a href="#l72.283"></a><span id="l72.283"> /*</span>
<a href="#l72.284"></a><span id="l72.284">  * ldap_sasl_bind_s - bind to the ldap server using sasl authentication</span>
<a href="#l72.285"></a><span id="l72.285">  * The dn, mechanism, and credentials of the entry to which to bind are</span>
<a href="#l72.286"></a><span id="l72.286">  * supplied.  LDAP_SUCCESS is returned upon success, the ldap error code</span>
<a href="#l72.287"></a><span id="l72.287">  * otherwise.</span>
<a href="#l72.288"></a><span id="l72.288">  *</span>
<a href="#l72.289"></a><span id="l72.289">  * Example:</span>
<a href="#l72.290"></a><span id="l72.290">  * struct berval  creds;</span>
<a href="#l72.291"></a><span id="l72.291">  * ... fill in creds with credentials ...</span>
<a href="#l72.292"></a><span id="l72.292">  * ldap_sasl_bind_s(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l72.293"></a><span id="l72.293">  *                  &quot;mechanismname&quot;, &amp;creds)</span>
<a href="#l72.294"></a><span id="l72.294">  */</span>
<a href="#l72.295"></a><span id="l72.295" class="difflineminus">-int LDAP_CALL ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,</span>
<a href="#l72.296"></a><span id="l72.296" class="difflineminus">-                               const struct berval *cred,</span>
<a href="#l72.297"></a><span id="l72.297" class="difflineminus">-                               LDAPControl **serverctrls,</span>
<a href="#l72.298"></a><span id="l72.298" class="difflineminus">-                               LDAPControl **clientctrls,</span>
<a href="#l72.299"></a><span id="l72.299" class="difflineminus">-                               struct berval **servercredp) {</span>
<a href="#l72.300"></a><span id="l72.300" class="difflineplus">+int LDAP_CALL ldap_sasl_bind_s(LDAP* ld, const char* dn, const char* mechanism,</span>
<a href="#l72.301"></a><span id="l72.301" class="difflineplus">+                               const struct berval* cred,</span>
<a href="#l72.302"></a><span id="l72.302" class="difflineplus">+                               LDAPControl** serverctrls,</span>
<a href="#l72.303"></a><span id="l72.303" class="difflineplus">+                               LDAPControl** clientctrls,</span>
<a href="#l72.304"></a><span id="l72.304" class="difflineplus">+                               struct berval** servercredp) {</span>
<a href="#l72.305"></a><span id="l72.305">   return (nsldapi_sasl_bind_s(ld, dn, mechanism, cred, serverctrls, clientctrls,</span>
<a href="#l72.306"></a><span id="l72.306">                               servercredp, NULL));</span>
<a href="#l72.307"></a><span id="l72.307"> }</span>
<a href="#l72.308"></a><span id="l72.308"> </span>
<a href="#l72.309"></a><span id="l72.309"> #ifdef LDAP_SASLIO_HOOKS</span>
<a href="#l72.310"></a><span id="l72.310"> /*</span>
<a href="#l72.311"></a><span id="l72.311">  * SASL Authentication Interface: ldap_sasl_interactive_bind_s</span>
<a href="#l72.312"></a><span id="l72.312">  *</span>
<a href="#l72.313"></a><span id="l72.313" class="difflineat">@@ -652,22 +652,22 @@ int LDAP_CALL ldap_sasl_bind_s(LDAP *ld,</span>
<a href="#l72.314"></a><span id="l72.314">  * to the LDAP connection ld.  The user provided callback can</span>
<a href="#l72.315"></a><span id="l72.315">  * use an optionally provided set of default values to complete</span>
<a href="#l72.316"></a><span id="l72.316">  * any necessary interactions.</span>
<a href="#l72.317"></a><span id="l72.317">  *</span>
<a href="#l72.318"></a><span id="l72.318">  * Currently imposes the following restrictions:</span>
<a href="#l72.319"></a><span id="l72.319">  *   A mech list must be provided</span>
<a href="#l72.320"></a><span id="l72.320">  *   LDAP_SASL_INTERACTIVE mode requires a callback</span>
<a href="#l72.321"></a><span id="l72.321">  */</span>
<a href="#l72.322"></a><span id="l72.322" class="difflineminus">-int LDAP_CALL ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,</span>
<a href="#l72.323"></a><span id="l72.323" class="difflineminus">-                                           const char *saslMechanism,</span>
<a href="#l72.324"></a><span id="l72.324" class="difflineminus">-                                           LDAPControl **sctrl,</span>
<a href="#l72.325"></a><span id="l72.325" class="difflineminus">-                                           LDAPControl **cctrl, unsigned flags,</span>
<a href="#l72.326"></a><span id="l72.326" class="difflineminus">-                                           LDAP_SASL_INTERACT_PROC *callback,</span>
<a href="#l72.327"></a><span id="l72.327" class="difflineminus">-                                           void *defaults) {</span>
<a href="#l72.328"></a><span id="l72.328" class="difflineplus">+int LDAP_CALL ldap_sasl_interactive_bind_s(LDAP* ld, const char* dn,</span>
<a href="#l72.329"></a><span id="l72.329" class="difflineplus">+                                           const char* saslMechanism,</span>
<a href="#l72.330"></a><span id="l72.330" class="difflineplus">+                                           LDAPControl** sctrl,</span>
<a href="#l72.331"></a><span id="l72.331" class="difflineplus">+                                           LDAPControl** cctrl, unsigned flags,</span>
<a href="#l72.332"></a><span id="l72.332" class="difflineplus">+                                           LDAP_SASL_INTERACT_PROC* callback,</span>
<a href="#l72.333"></a><span id="l72.333" class="difflineplus">+                                           void* defaults) {</span>
<a href="#l72.334"></a><span id="l72.334">   return ldap_sasl_interactive_bind_ext_s(ld, dn, saslMechanism, sctrl, cctrl,</span>
<a href="#l72.335"></a><span id="l72.335">                                           flags, callback, defaults, NULL);</span>
<a href="#l72.336"></a><span id="l72.336"> }</span>
<a href="#l72.337"></a><span id="l72.337"> </span>
<a href="#l72.338"></a><span id="l72.338"> /*</span>
<a href="#l72.339"></a><span id="l72.339">  * ldap_sasl_interactive_bind_ext_s</span>
<a href="#l72.340"></a><span id="l72.340">  *</span>
<a href="#l72.341"></a><span id="l72.341">  * This function extends ldap_sasl_interactive_bind_s by allowing</span>
<a href="#l72.342"></a><span id="l72.342" class="difflineat">@@ -678,21 +678,21 @@ int LDAP_CALL ldap_sasl_interactive_bind</span>
<a href="#l72.343"></a><span id="l72.343">  * ...</span>
<a href="#l72.344"></a><span id="l72.344">  * ldap_sasl_interactive_bind_ext_s(ld, ...., &amp;retctrls);</span>
<a href="#l72.345"></a><span id="l72.345">  * ...</span>
<a href="#l72.346"></a><span id="l72.346">  * ldap_controls_free(retctrls);</span>
<a href="#l72.347"></a><span id="l72.347">  * Only the controls from the server during the last bind step are returned -</span>
<a href="#l72.348"></a><span id="l72.348">  * intermediate controls (if any, usually not) are discarded.</span>
<a href="#l72.349"></a><span id="l72.349">  */</span>
<a href="#l72.350"></a><span id="l72.350"> int LDAP_CALL ldap_sasl_interactive_bind_ext_s(</span>
<a href="#l72.351"></a><span id="l72.351" class="difflineminus">-    LDAP *ld, const char *dn, const char *saslMechanism, LDAPControl **sctrl,</span>
<a href="#l72.352"></a><span id="l72.352" class="difflineminus">-    LDAPControl **cctrl, unsigned flags, LDAP_SASL_INTERACT_PROC *callback,</span>
<a href="#l72.353"></a><span id="l72.353" class="difflineminus">-    void *defaults, LDAPControl ***rctrl) {</span>
<a href="#l72.354"></a><span id="l72.354" class="difflineplus">+    LDAP* ld, const char* dn, const char* saslMechanism, LDAPControl** sctrl,</span>
<a href="#l72.355"></a><span id="l72.355" class="difflineplus">+    LDAPControl** cctrl, unsigned flags, LDAP_SASL_INTERACT_PROC* callback,</span>
<a href="#l72.356"></a><span id="l72.356" class="difflineplus">+    void* defaults, LDAPControl*** rctrl) {</span>
<a href="#l72.357"></a><span id="l72.357"> #  ifdef LDAP_SASLIO_GET_MECHS_FROM_SERVER</span>
<a href="#l72.358"></a><span id="l72.358" class="difflineminus">-  char *smechs;</span>
<a href="#l72.359"></a><span id="l72.359" class="difflineplus">+  char* smechs;</span>
<a href="#l72.360"></a><span id="l72.360"> #  endif</span>
<a href="#l72.361"></a><span id="l72.361">   int rc;</span>
<a href="#l72.362"></a><span id="l72.362"> </span>
<a href="#l72.363"></a><span id="l72.363">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_sasl_interactive_bind_s\n&quot;, 0, 0, 0);</span>
<a href="#l72.364"></a><span id="l72.364"> </span>
<a href="#l72.365"></a><span id="l72.365">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l72.366"></a><span id="l72.366">     return (LDAP_PARAM_ERROR);</span>
<a href="#l72.367"></a><span id="l72.367">   }</span>
<a href="#l72.368"></a><span id="l72.368" class="difflineat">@@ -720,36 +720,36 @@ int LDAP_CALL ldap_sasl_interactive_bind</span>
<a href="#l72.369"></a><span id="l72.369">   rc = nsldapi_sasl_do_bind(ld, dn, saslMechanism, flags, callback, defaults,</span>
<a href="#l72.370"></a><span id="l72.370">                             sctrl, cctrl, rctrl);</span>
<a href="#l72.371"></a><span id="l72.371"> </span>
<a href="#l72.372"></a><span id="l72.372">   LDAP_MUTEX_UNLOCK(ld, LDAP_SASL_LOCK);</span>
<a href="#l72.373"></a><span id="l72.373">   return (rc);</span>
<a href="#l72.374"></a><span id="l72.374"> }</span>
<a href="#l72.375"></a><span id="l72.375"> #else  /* LDAP_SASLIO_HOOKS */</span>
<a href="#l72.376"></a><span id="l72.376"> /* stubs for platforms that do not support SASL */</span>
<a href="#l72.377"></a><span id="l72.377" class="difflineminus">-int LDAP_CALL ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,</span>
<a href="#l72.378"></a><span id="l72.378" class="difflineminus">-                                           const char *saslMechanism,</span>
<a href="#l72.379"></a><span id="l72.379" class="difflineminus">-                                           LDAPControl **sctrl,</span>
<a href="#l72.380"></a><span id="l72.380" class="difflineminus">-                                           LDAPControl **cctrl, unsigned flags,</span>
<a href="#l72.381"></a><span id="l72.381" class="difflineminus">-                                           LDAP_SASL_INTERACT_PROC *callback,</span>
<a href="#l72.382"></a><span id="l72.382" class="difflineminus">-                                           void *defaults) {</span>
<a href="#l72.383"></a><span id="l72.383" class="difflineplus">+int LDAP_CALL ldap_sasl_interactive_bind_s(LDAP* ld, const char* dn,</span>
<a href="#l72.384"></a><span id="l72.384" class="difflineplus">+                                           const char* saslMechanism,</span>
<a href="#l72.385"></a><span id="l72.385" class="difflineplus">+                                           LDAPControl** sctrl,</span>
<a href="#l72.386"></a><span id="l72.386" class="difflineplus">+                                           LDAPControl** cctrl, unsigned flags,</span>
<a href="#l72.387"></a><span id="l72.387" class="difflineplus">+                                           LDAP_SASL_INTERACT_PROC* callback,</span>
<a href="#l72.388"></a><span id="l72.388" class="difflineplus">+                                           void* defaults) {</span>
<a href="#l72.389"></a><span id="l72.389">   return LDAP_SUCCESS;</span>
<a href="#l72.390"></a><span id="l72.390"> }</span>
<a href="#l72.391"></a><span id="l72.391"> </span>
<a href="#l72.392"></a><span id="l72.392"> int LDAP_CALL ldap_sasl_interactive_bind_ext_s(</span>
<a href="#l72.393"></a><span id="l72.393" class="difflineminus">-    LDAP *ld, const char *dn, const char *saslMechanism, LDAPControl **sctrl,</span>
<a href="#l72.394"></a><span id="l72.394" class="difflineminus">-    LDAPControl **cctrl, unsigned flags, LDAP_SASL_INTERACT_PROC *callback,</span>
<a href="#l72.395"></a><span id="l72.395" class="difflineminus">-    void *defaults, LDAPControl ***rctrl) {</span>
<a href="#l72.396"></a><span id="l72.396" class="difflineplus">+    LDAP* ld, const char* dn, const char* saslMechanism, LDAPControl** sctrl,</span>
<a href="#l72.397"></a><span id="l72.397" class="difflineplus">+    LDAPControl** cctrl, unsigned flags, LDAP_SASL_INTERACT_PROC* callback,</span>
<a href="#l72.398"></a><span id="l72.398" class="difflineplus">+    void* defaults, LDAPControl*** rctrl) {</span>
<a href="#l72.399"></a><span id="l72.399">   return LDAP_SUCCESS;</span>
<a href="#l72.400"></a><span id="l72.400"> }</span>
<a href="#l72.401"></a><span id="l72.401"> #endif /* LDAP_SASLIO_HOOKS */</span>
<a href="#l72.402"></a><span id="l72.402"> </span>
<a href="#l72.403"></a><span id="l72.403"> /* returns an LDAP error code that indicates if parse succeeded or not */</span>
<a href="#l72.404"></a><span id="l72.404" class="difflineminus">-int LDAP_CALL ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,</span>
<a href="#l72.405"></a><span id="l72.405" class="difflineminus">-                                          struct berval **servercredp,</span>
<a href="#l72.406"></a><span id="l72.406" class="difflineplus">+int LDAP_CALL ldap_parse_sasl_bind_result(LDAP* ld, LDAPMessage* res,</span>
<a href="#l72.407"></a><span id="l72.407" class="difflineplus">+                                          struct berval** servercredp,</span>
<a href="#l72.408"></a><span id="l72.408">                                           int freeit) {</span>
<a href="#l72.409"></a><span id="l72.409">   BerElement ber;</span>
<a href="#l72.410"></a><span id="l72.410">   int rc, err;</span>
<a href="#l72.411"></a><span id="l72.411">   ber_int_t along;</span>
<a href="#l72.412"></a><span id="l72.412">   ber_len_t len;</span>
<a href="#l72.413"></a><span id="l72.413">   char *m, *e;</span>
<a href="#l72.414"></a><span id="l72.414"> </span>
<a href="#l72.415"></a><span id="l72.415">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_parse_sasl_bind_result\n&quot;, 0, 0, 0);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l73.1"></a><span id="l73.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/saslio.c</span>
<a href="#l73.2"></a><span id="l73.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/saslio.c</span>
<a href="#l73.3"></a><span id="l73.3" class="difflineat">@@ -50,43 +50,43 @@</span>
<a href="#l73.4"></a><span id="l73.4">  */</span>
<a href="#l73.5"></a><span id="l73.5"> </span>
<a href="#l73.6"></a><span id="l73.6"> /* data structure that populates the I/O callback socket-specific arg. */</span>
<a href="#l73.7"></a><span id="l73.7"> typedef struct lextiof_socket_private {</span>
<a href="#l73.8"></a><span id="l73.8">   struct ldap_x_ext_io_fns sess_io_fns; /* the saved layered ld fns from the</span>
<a href="#l73.9"></a><span id="l73.9">                                            layer we are &quot;pushing&quot; */</span>
<a href="#l73.10"></a><span id="l73.10">   struct lber_x_ext_io_fns sock_io_fns; /* the saved layered ber fns from the</span>
<a href="#l73.11"></a><span id="l73.11">                                            layer we are &quot;pushing&quot; */</span>
<a href="#l73.12"></a><span id="l73.12" class="difflineminus">-  sasl_conn_t</span>
<a href="#l73.13"></a><span id="l73.13" class="difflineminus">-      *sasl_ctx; /* the sasl context - pointer to the one from the connection */</span>
<a href="#l73.14"></a><span id="l73.14" class="difflineminus">-  char *sb_sasl_ibuf; /* sasl decrypted input buffer */</span>
<a href="#l73.15"></a><span id="l73.15" class="difflineminus">-  char *sb_sasl_iptr; /* current location in buffer */</span>
<a href="#l73.16"></a><span id="l73.16" class="difflineplus">+  sasl_conn_t*</span>
<a href="#l73.17"></a><span id="l73.17" class="difflineplus">+      sasl_ctx; /* the sasl context - pointer to the one from the connection */</span>
<a href="#l73.18"></a><span id="l73.18" class="difflineplus">+  char* sb_sasl_ibuf; /* sasl decrypted input buffer */</span>
<a href="#l73.19"></a><span id="l73.19" class="difflineplus">+  char* sb_sasl_iptr; /* current location in buffer */</span>
<a href="#l73.20"></a><span id="l73.20">   int sb_sasl_bfsz;   /* Alloc'd size of input buffer */</span>
<a href="#l73.21"></a><span id="l73.21">   int sb_sasl_ilen;   /* remaining length to process */</span>
<a href="#l73.22"></a><span id="l73.22" class="difflineminus">-  LDAP *ld;           /* used to set errno */</span>
<a href="#l73.23"></a><span id="l73.23" class="difflineminus">-  Sockbuf *sb;        /* pointer to our associated sockbuf */</span>
<a href="#l73.24"></a><span id="l73.24" class="difflineplus">+  LDAP* ld;           /* used to set errno */</span>
<a href="#l73.25"></a><span id="l73.25" class="difflineplus">+  Sockbuf* sb;        /* pointer to our associated sockbuf */</span>
<a href="#l73.26"></a><span id="l73.26"> } SASLIOSocketArg;</span>
<a href="#l73.27"></a><span id="l73.27"> </span>
<a href="#l73.28"></a><span id="l73.28" class="difflineminus">-static void destroy_SASLIOSocketArg(SASLIOSocketArg **sockarg) {</span>
<a href="#l73.29"></a><span id="l73.29" class="difflineplus">+static void destroy_SASLIOSocketArg(SASLIOSocketArg** sockarg) {</span>
<a href="#l73.30"></a><span id="l73.30">   if (sockarg &amp;&amp; *sockarg) {</span>
<a href="#l73.31"></a><span id="l73.31">     NSLDAPI_FREE((*sockarg)-&gt;sb_sasl_ibuf);</span>
<a href="#l73.32"></a><span id="l73.32">     NSLDAPI_FREE((*sockarg));</span>
<a href="#l73.33"></a><span id="l73.33">     *sockarg = NULL;</span>
<a href="#l73.34"></a><span id="l73.34">   }</span>
<a href="#l73.35"></a><span id="l73.35"> }</span>
<a href="#l73.36"></a><span id="l73.36"> </span>
<a href="#l73.37"></a><span id="l73.37" class="difflineminus">-static SASLIOSocketArg *new_SASLIOSocketArg(sasl_conn_t *ctx, int bufsiz,</span>
<a href="#l73.38"></a><span id="l73.38" class="difflineminus">-                                            LDAP *ld, Sockbuf *sb) {</span>
<a href="#l73.39"></a><span id="l73.39" class="difflineminus">-  SASLIOSocketArg *sockarg = NULL;</span>
<a href="#l73.40"></a><span id="l73.40" class="difflineplus">+static SASLIOSocketArg* new_SASLIOSocketArg(sasl_conn_t* ctx, int bufsiz,</span>
<a href="#l73.41"></a><span id="l73.41" class="difflineplus">+                                            LDAP* ld, Sockbuf* sb) {</span>
<a href="#l73.42"></a><span id="l73.42" class="difflineplus">+  SASLIOSocketArg* sockarg = NULL;</span>
<a href="#l73.43"></a><span id="l73.43"> </span>
<a href="#l73.44"></a><span id="l73.44">   if (bufsiz &lt;= 0) {</span>
<a href="#l73.45"></a><span id="l73.45">     return sockarg;</span>
<a href="#l73.46"></a><span id="l73.46">   }</span>
<a href="#l73.47"></a><span id="l73.47"> </span>
<a href="#l73.48"></a><span id="l73.48" class="difflineminus">-  sockarg = (SASLIOSocketArg *)NSLDAPI_CALLOC(1, sizeof(SASLIOSocketArg));</span>
<a href="#l73.49"></a><span id="l73.49" class="difflineplus">+  sockarg = (SASLIOSocketArg*)NSLDAPI_CALLOC(1, sizeof(SASLIOSocketArg));</span>
<a href="#l73.50"></a><span id="l73.50">   if (sockarg) {</span>
<a href="#l73.51"></a><span id="l73.51">     sockarg-&gt;sasl_ctx = ctx;</span>
<a href="#l73.52"></a><span id="l73.52">     sockarg-&gt;sb_sasl_ibuf = NSLDAPI_MALLOC(bufsiz);</span>
<a href="#l73.53"></a><span id="l73.53">     if (!sockarg-&gt;sb_sasl_ibuf) {</span>
<a href="#l73.54"></a><span id="l73.54">       destroy_SASLIOSocketArg(&amp;sockarg);</span>
<a href="#l73.55"></a><span id="l73.55">       return sockarg;</span>
<a href="#l73.56"></a><span id="l73.56">     }</span>
<a href="#l73.57"></a><span id="l73.57">     sockarg-&gt;sb_sasl_iptr = NULL;</span>
<a href="#l73.58"></a><span id="l73.58" class="difflineat">@@ -115,44 +115,44 @@ static SASLIOSocketArg *new_SASLIOSocket</span>
<a href="#l73.59"></a><span id="l73.59">  * SASL cannot decrypt a stream so full packaets must be read</span>
<a href="#l73.60"></a><span id="l73.60">  * before proceeding.</span>
<a href="#l73.61"></a><span id="l73.61">  */</span>
<a href="#l73.62"></a><span id="l73.62"> </span>
<a href="#l73.63"></a><span id="l73.63"> /*</span>
<a href="#l73.64"></a><span id="l73.64">  * Get the 4 octet header [size] for a sasl encrypted buffer.</span>
<a href="#l73.65"></a><span id="l73.65">  * See RFC222 [section 3].</span>
<a href="#l73.66"></a><span id="l73.66">  */</span>
<a href="#l73.67"></a><span id="l73.67" class="difflineminus">-static int nsldapi_sasl_pktlen(char *buf, int maxbufsize) {</span>
<a href="#l73.68"></a><span id="l73.68" class="difflineplus">+static int nsldapi_sasl_pktlen(char* buf, int maxbufsize) {</span>
<a href="#l73.69"></a><span id="l73.69">   int size;</span>
<a href="#l73.70"></a><span id="l73.70"> </span>
<a href="#l73.71"></a><span id="l73.71"> #  if defined(_WINDOWS) || defined(_WIN32)</span>
<a href="#l73.72"></a><span id="l73.72" class="difflineminus">-  size = ntohl(*(u_long *)buf);</span>
<a href="#l73.73"></a><span id="l73.73" class="difflineplus">+  size = ntohl(*(u_long*)buf);</span>
<a href="#l73.74"></a><span id="l73.74"> #  else</span>
<a href="#l73.75"></a><span id="l73.75" class="difflineminus">-  size = ntohl(*(uint32_t *)buf);</span>
<a href="#l73.76"></a><span id="l73.76" class="difflineplus">+  size = ntohl(*(uint32_t*)buf);</span>
<a href="#l73.77"></a><span id="l73.77"> #  endif</span>
<a href="#l73.78"></a><span id="l73.78">   if (size &lt; 0 || size &gt; maxbufsize) {</span>
<a href="#l73.79"></a><span id="l73.79">     return (-1);</span>
<a href="#l73.80"></a><span id="l73.80">   }</span>
<a href="#l73.81"></a><span id="l73.81"> </span>
<a href="#l73.82"></a><span id="l73.82">   return (size + 4); /* include the first 4 bytes */</span>
<a href="#l73.83"></a><span id="l73.83"> }</span>
<a href="#l73.84"></a><span id="l73.84"> </span>
<a href="#l73.85"></a><span id="l73.85"> /*</span>
<a href="#l73.86"></a><span id="l73.86">  * SASL encryption routines</span>
<a href="#l73.87"></a><span id="l73.87">  */</span>
<a href="#l73.88"></a><span id="l73.88"> </span>
<a href="#l73.89"></a><span id="l73.89" class="difflineminus">-static int nsldapi_sasl_read(int s, void *buf, int len,</span>
<a href="#l73.90"></a><span id="l73.90" class="difflineminus">-                             struct lextiof_socket_private *arg) {</span>
<a href="#l73.91"></a><span id="l73.91" class="difflineminus">-  LDAP *ld;</span>
<a href="#l73.92"></a><span id="l73.92" class="difflineminus">-  const char *dbuf;</span>
<a href="#l73.93"></a><span id="l73.93" class="difflineminus">-  char *cp;</span>
<a href="#l73.94"></a><span id="l73.94" class="difflineplus">+static int nsldapi_sasl_read(int s, void* buf, int len,</span>
<a href="#l73.95"></a><span id="l73.95" class="difflineplus">+                             struct lextiof_socket_private* arg) {</span>
<a href="#l73.96"></a><span id="l73.96" class="difflineplus">+  LDAP* ld;</span>
<a href="#l73.97"></a><span id="l73.97" class="difflineplus">+  const char* dbuf;</span>
<a href="#l73.98"></a><span id="l73.98" class="difflineplus">+  char* cp;</span>
<a href="#l73.99"></a><span id="l73.99">   int ret;</span>
<a href="#l73.100"></a><span id="l73.100">   unsigned dlen, blen;</span>
<a href="#l73.101"></a><span id="l73.101"> </span>
<a href="#l73.102"></a><span id="l73.102" class="difflineminus">-  ld = (LDAP *)arg-&gt;ld;</span>
<a href="#l73.103"></a><span id="l73.103" class="difflineplus">+  ld = (LDAP*)arg-&gt;ld;</span>
<a href="#l73.104"></a><span id="l73.104"> </span>
<a href="#l73.105"></a><span id="l73.105">   /* Is there anything left in the existing buffer? */</span>
<a href="#l73.106"></a><span id="l73.106">   if ((ret = arg-&gt;sb_sasl_ilen) &gt; 0) {</span>
<a href="#l73.107"></a><span id="l73.107">     ret = (ret &gt; len ? len : ret);</span>
<a href="#l73.108"></a><span id="l73.108">     SAFEMEMCPY(buf, arg-&gt;sb_sasl_iptr, ret);</span>
<a href="#l73.109"></a><span id="l73.109">     if (ret == arg-&gt;sb_sasl_ilen) {</span>
<a href="#l73.110"></a><span id="l73.110">       arg-&gt;sb_sasl_ilen = 0;</span>
<a href="#l73.111"></a><span id="l73.111">       arg-&gt;sb_sasl_iptr = NULL;</span>
<a href="#l73.112"></a><span id="l73.112" class="difflineat">@@ -234,24 +234,24 @@ static int nsldapi_sasl_read(int s, void</span>
<a href="#l73.113"></a><span id="l73.113">     arg-&gt;sb_sasl_iptr = NULL;</span>
<a href="#l73.114"></a><span id="l73.114">   } else {</span>
<a href="#l73.115"></a><span id="l73.115">     arg-&gt;sb_sasl_ilen -= ret;</span>
<a href="#l73.116"></a><span id="l73.116">     arg-&gt;sb_sasl_iptr += ret;</span>
<a href="#l73.117"></a><span id="l73.117">   }</span>
<a href="#l73.118"></a><span id="l73.118">   return (ret);</span>
<a href="#l73.119"></a><span id="l73.119"> }</span>
<a href="#l73.120"></a><span id="l73.120"> </span>
<a href="#l73.121"></a><span id="l73.121" class="difflineminus">-static int nsldapi_sasl_write(int s, const void *buf, int len,</span>
<a href="#l73.122"></a><span id="l73.122" class="difflineminus">-                              struct lextiof_socket_private *arg) {</span>
<a href="#l73.123"></a><span id="l73.123" class="difflineplus">+static int nsldapi_sasl_write(int s, const void* buf, int len,</span>
<a href="#l73.124"></a><span id="l73.124" class="difflineplus">+                              struct lextiof_socket_private* arg) {</span>
<a href="#l73.125"></a><span id="l73.125">   int ret = 0;</span>
<a href="#l73.126"></a><span id="l73.126" class="difflineminus">-  const char *obuf, *optr, *cbuf = (const char *)buf;</span>
<a href="#l73.127"></a><span id="l73.127" class="difflineplus">+  const char *obuf, *optr, *cbuf = (const char*)buf;</span>
<a href="#l73.128"></a><span id="l73.128">   unsigned olen, clen, tlen = 0;</span>
<a href="#l73.129"></a><span id="l73.129" class="difflineminus">-  unsigned *maxbuf;</span>
<a href="#l73.130"></a><span id="l73.130" class="difflineplus">+  unsigned* maxbuf;</span>
<a href="#l73.131"></a><span id="l73.131"> </span>
<a href="#l73.132"></a><span id="l73.132" class="difflineminus">-  ret = sasl_getprop(arg-&gt;sasl_ctx, SASL_MAXOUTBUF, (const void **)&amp;maxbuf);</span>
<a href="#l73.133"></a><span id="l73.133" class="difflineplus">+  ret = sasl_getprop(arg-&gt;sasl_ctx, SASL_MAXOUTBUF, (const void**)&amp;maxbuf);</span>
<a href="#l73.134"></a><span id="l73.134">   if (ret != SASL_OK) {</span>
<a href="#l73.135"></a><span id="l73.135">     /* just a sanity check, should never happen */</span>
<a href="#l73.136"></a><span id="l73.136">     return (-1);</span>
<a href="#l73.137"></a><span id="l73.137">   }</span>
<a href="#l73.138"></a><span id="l73.138"> </span>
<a href="#l73.139"></a><span id="l73.139">   while (len &gt; 0) {</span>
<a href="#l73.140"></a><span id="l73.140">     clen = (len &gt; *maxbuf) ? *maxbuf : len;</span>
<a href="#l73.141"></a><span id="l73.141">     /* encode the next packet. */</span>
<a href="#l73.142"></a><span id="l73.142" class="difflineat">@@ -309,45 +309,45 @@ static int nsldapi_sasl_write(int s, con</span>
<a href="#l73.143"></a><span id="l73.143">  * the lpoll_socketarg with the original one. Why have origarg and</span>
<a href="#l73.144"></a><span id="l73.144">  * staticorigarg? To avoid malloc.  The sizeof staticorigarg should be large</span>
<a href="#l73.145"></a><span id="l73.145">  * enough to accommodate almost all clients without incurring too much</span>
<a href="#l73.146"></a><span id="l73.146">  * additional overhead.  However, if we need more room, origarg will grow to</span>
<a href="#l73.147"></a><span id="l73.147">  * nfds.  If this proves to be inadequate, the size of the staticorigarg is a</span>
<a href="#l73.148"></a><span id="l73.148">  * good candidate for a #define set by configure.</span>
<a href="#l73.149"></a><span id="l73.149">  */</span>
<a href="#l73.150"></a><span id="l73.150"> static int nsldapi_sasl_poll(LDAP_X_PollFD fds[], int nfds, int timeout,</span>
<a href="#l73.151"></a><span id="l73.151" class="difflineminus">-                             struct lextiof_session_private *arg) {</span>
<a href="#l73.152"></a><span id="l73.152" class="difflineminus">-  LDAP_X_EXTIOF_POLL_CALLBACK *origpoll; /* poll fn from the pushed layer */</span>
<a href="#l73.153"></a><span id="l73.153" class="difflineminus">-  struct lextiof_session_private *origsess =</span>
<a href="#l73.154"></a><span id="l73.154" class="difflineplus">+                             struct lextiof_session_private* arg) {</span>
<a href="#l73.155"></a><span id="l73.155" class="difflineplus">+  LDAP_X_EXTIOF_POLL_CALLBACK* origpoll; /* poll fn from the pushed layer */</span>
<a href="#l73.156"></a><span id="l73.156" class="difflineplus">+  struct lextiof_session_private* origsess =</span>
<a href="#l73.157"></a><span id="l73.157">       NULL;                             /* session arg from the pushed layer */</span>
<a href="#l73.158"></a><span id="l73.158" class="difflineminus">-  SASLIOSocketArg **origarg = NULL;     /* list of saved original socket args */</span>
<a href="#l73.159"></a><span id="l73.159" class="difflineminus">-  SASLIOSocketArg *staticorigarg[1024]; /* default list to avoid malloc */</span>
<a href="#l73.160"></a><span id="l73.160" class="difflineplus">+  SASLIOSocketArg** origarg = NULL;     /* list of saved original socket args */</span>
<a href="#l73.161"></a><span id="l73.161" class="difflineplus">+  SASLIOSocketArg* staticorigarg[1024]; /* default list to avoid malloc */</span>
<a href="#l73.162"></a><span id="l73.162">   int origargsize = sizeof(staticorigarg) / sizeof(staticorigarg[0]);</span>
<a href="#l73.163"></a><span id="l73.163">   int rc = -1; /* the return code - -1 means failure */</span>
<a href="#l73.164"></a><span id="l73.164"> </span>
<a href="#l73.165"></a><span id="l73.165">   if (arg == NULL) { /* should not happen */</span>
<a href="#l73.166"></a><span id="l73.166">     return (rc);</span>
<a href="#l73.167"></a><span id="l73.167">   }</span>
<a href="#l73.168"></a><span id="l73.168"> </span>
<a href="#l73.169"></a><span id="l73.169">   origarg = staticorigarg;</span>
<a href="#l73.170"></a><span id="l73.170">   /* if the static array is not large enough, alloc a dynamic one */</span>
<a href="#l73.171"></a><span id="l73.171">   if (origargsize &lt; nfds) {</span>
<a href="#l73.172"></a><span id="l73.172">     origarg =</span>
<a href="#l73.173"></a><span id="l73.173" class="difflineminus">-        (SASLIOSocketArg **)NSLDAPI_MALLOC(nfds * sizeof(SASLIOSocketArg *));</span>
<a href="#l73.174"></a><span id="l73.174" class="difflineplus">+        (SASLIOSocketArg**)NSLDAPI_MALLOC(nfds * sizeof(SASLIOSocketArg*));</span>
<a href="#l73.175"></a><span id="l73.175">   }</span>
<a href="#l73.176"></a><span id="l73.176"> </span>
<a href="#l73.177"></a><span id="l73.177">   if (fds &amp;&amp; nfds &gt; 0) {</span>
<a href="#l73.178"></a><span id="l73.178">     int i;</span>
<a href="#l73.179"></a><span id="l73.179">     for (i = 0; i &lt; nfds; i++) {</span>
<a href="#l73.180"></a><span id="l73.180">       /* save the original socket arg */</span>
<a href="#l73.181"></a><span id="l73.181">       origarg[i] = fds[i].lpoll_socketarg;</span>
<a href="#l73.182"></a><span id="l73.182" class="difflineminus">-      if (arg == (struct lextiof_session_private *)fds[i].lpoll_socketarg) {</span>
<a href="#l73.183"></a><span id="l73.183" class="difflineplus">+      if (arg == (struct lextiof_session_private*)fds[i].lpoll_socketarg) {</span>
<a href="#l73.184"></a><span id="l73.184">         /* lpoll_socketarg is a sasl socket arg - we need to replace it</span>
<a href="#l73.185"></a><span id="l73.185">            with the one from the layer we pushed (i.e. prldap) */</span>
<a href="#l73.186"></a><span id="l73.186" class="difflineminus">-        SASLIOSocketArg *sockarg = (SASLIOSocketArg *)fds[i].lpoll_socketarg;</span>
<a href="#l73.187"></a><span id="l73.187" class="difflineplus">+        SASLIOSocketArg* sockarg = (SASLIOSocketArg*)fds[i].lpoll_socketarg;</span>
<a href="#l73.188"></a><span id="l73.188">         /* reset to pushed layer's socket arg */</span>
<a href="#l73.189"></a><span id="l73.189">         fds[i].lpoll_socketarg = sockarg-&gt;sock_io_fns.lbextiofn_socket_arg;</span>
<a href="#l73.190"></a><span id="l73.190">         /* grab the pushed layers' poll fn and its session arg */</span>
<a href="#l73.191"></a><span id="l73.191">         if (!origsess) {</span>
<a href="#l73.192"></a><span id="l73.192">           origpoll = sockarg-&gt;sess_io_fns.lextiof_poll;</span>
<a href="#l73.193"></a><span id="l73.193">           origsess = sockarg-&gt;sess_io_fns.lextiof_session_arg;</span>
<a href="#l73.194"></a><span id="l73.194">         }</span>
<a href="#l73.195"></a><span id="l73.195">       }</span>
<a href="#l73.196"></a><span id="l73.196" class="difflineat">@@ -362,35 +362,35 @@ static int nsldapi_sasl_poll(LDAP_X_Poll</span>
<a href="#l73.197"></a><span id="l73.197">   rc = origpoll(fds, nfds, timeout, origsess);</span>
<a href="#l73.198"></a><span id="l73.198"> </span>
<a href="#l73.199"></a><span id="l73.199">   /* reset the lpoll_socketarg values to their original values because</span>
<a href="#l73.200"></a><span id="l73.200">      they must match what's in sb-&gt;iofns-&gt;lbextiofn_socket_arg in order</span>
<a href="#l73.201"></a><span id="l73.201">      for NSLDAPI_CB_POLL_MATCH to work - see os-ip.c */</span>
<a href="#l73.202"></a><span id="l73.202">   if (fds &amp;&amp; nfds &gt; 0) {</span>
<a href="#l73.203"></a><span id="l73.203">     int i;</span>
<a href="#l73.204"></a><span id="l73.204">     for (i = 0; i &lt; nfds; i++) {</span>
<a href="#l73.205"></a><span id="l73.205" class="difflineminus">-      if ((SASLIOSocketArg *)arg == origarg[i]) {</span>
<a href="#l73.206"></a><span id="l73.206" class="difflineplus">+      if ((SASLIOSocketArg*)arg == origarg[i]) {</span>
<a href="#l73.207"></a><span id="l73.207">         fds[i].lpoll_socketarg = origarg[i];</span>
<a href="#l73.208"></a><span id="l73.208">       }</span>
<a href="#l73.209"></a><span id="l73.209">     }</span>
<a href="#l73.210"></a><span id="l73.210">   }</span>
<a href="#l73.211"></a><span id="l73.211"> </span>
<a href="#l73.212"></a><span id="l73.212"> done:</span>
<a href="#l73.213"></a><span id="l73.213">   /* if we had to use a dynamic array, free it */</span>
<a href="#l73.214"></a><span id="l73.214">   if (origarg != staticorigarg) {</span>
<a href="#l73.215"></a><span id="l73.215">     NSLDAPI_FREE(origarg);</span>
<a href="#l73.216"></a><span id="l73.216">   }</span>
<a href="#l73.217"></a><span id="l73.217"> </span>
<a href="#l73.218"></a><span id="l73.218">   return rc;</span>
<a href="#l73.219"></a><span id="l73.219"> }</span>
<a href="#l73.220"></a><span id="l73.220"> </span>
<a href="#l73.221"></a><span id="l73.221" class="difflineminus">-int nsldapi_sasl_open(LDAP *ld, LDAPConn *lconn, sasl_conn_t **ctx,</span>
<a href="#l73.222"></a><span id="l73.222" class="difflineplus">+int nsldapi_sasl_open(LDAP* ld, LDAPConn* lconn, sasl_conn_t** ctx,</span>
<a href="#l73.223"></a><span id="l73.223">                       sasl_ssf_t ssf) {</span>
<a href="#l73.224"></a><span id="l73.224">   int saslrc;</span>
<a href="#l73.225"></a><span id="l73.225" class="difflineminus">-  char *host = NULL;</span>
<a href="#l73.226"></a><span id="l73.226" class="difflineplus">+  char* host = NULL;</span>
<a href="#l73.227"></a><span id="l73.227"> </span>
<a href="#l73.228"></a><span id="l73.228">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l73.229"></a><span id="l73.229">     LDAP_SET_LDERRNO(ld, LDAP_LOCAL_ERROR, NULL, NULL);</span>
<a href="#l73.230"></a><span id="l73.230">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l73.231"></a><span id="l73.231">   }</span>
<a href="#l73.232"></a><span id="l73.232"> </span>
<a href="#l73.233"></a><span id="l73.233">   if (lconn == NULL) {</span>
<a href="#l73.234"></a><span id="l73.234">     if (ld-&gt;ld_defconn == NULL ||</span>
<a href="#l73.235"></a><span id="l73.235" class="difflineat">@@ -424,43 +424,43 @@ int nsldapi_sasl_open(LDAP *ld, LDAPConn</span>
<a href="#l73.236"></a><span id="l73.236">     return (nsldapi_sasl_cvterrno(ld, saslrc, NULL));</span>
<a href="#l73.237"></a><span id="l73.237">   }</span>
<a href="#l73.238"></a><span id="l73.238"> </span>
<a href="#l73.239"></a><span id="l73.239">   if (ssf) {</span>
<a href="#l73.240"></a><span id="l73.240">     sasl_ssf_t extprops;</span>
<a href="#l73.241"></a><span id="l73.241">     memset(&amp;extprops, 0L, sizeof(extprops));</span>
<a href="#l73.242"></a><span id="l73.242">     extprops = ssf;</span>
<a href="#l73.243"></a><span id="l73.243"> </span>
<a href="#l73.244"></a><span id="l73.244" class="difflineminus">-    (void)sasl_setprop(*ctx, SASL_SSF_EXTERNAL, (void *)&amp;extprops);</span>
<a href="#l73.245"></a><span id="l73.245" class="difflineplus">+    (void)sasl_setprop(*ctx, SASL_SSF_EXTERNAL, (void*)&amp;extprops);</span>
<a href="#l73.246"></a><span id="l73.246">   }</span>
<a href="#l73.247"></a><span id="l73.247"> </span>
<a href="#l73.248"></a><span id="l73.248">   /* (re)set security properties */</span>
<a href="#l73.249"></a><span id="l73.249">   sasl_setprop(*ctx, SASL_SEC_PROPS, &amp;ld-&gt;ld_sasl_secprops);</span>
<a href="#l73.250"></a><span id="l73.250"> </span>
<a href="#l73.251"></a><span id="l73.251">   /* set the connection context */</span>
<a href="#l73.252"></a><span id="l73.252">   lconn-&gt;lconn_sasl_ctx = *ctx;</span>
<a href="#l73.253"></a><span id="l73.253"> </span>
<a href="#l73.254"></a><span id="l73.254">   return (LDAP_SUCCESS);</span>
<a href="#l73.255"></a><span id="l73.255"> }</span>
<a href="#l73.256"></a><span id="l73.256"> </span>
<a href="#l73.257"></a><span id="l73.257" class="difflineminus">-static int nsldapi_sasl_close(struct lextiof_socket_private *arg) {</span>
<a href="#l73.258"></a><span id="l73.258" class="difflineplus">+static int nsldapi_sasl_close(struct lextiof_socket_private* arg) {</span>
<a href="#l73.259"></a><span id="l73.259">   /* undo function pointer interposing */</span>
<a href="#l73.260"></a><span id="l73.260">   ldap_set_option(arg-&gt;ld, LDAP_X_OPT_EXTIO_FN_PTRS, &amp;arg-&gt;sess_io_fns);</span>
<a href="#l73.261"></a><span id="l73.261">   /* have to do this separately to make sure the socketarg is set correctly */</span>
<a href="#l73.262"></a><span id="l73.262">   ber_sockbuf_set_option(arg-&gt;sb, LBER_SOCKBUF_OPT_EXT_IO_FNS,</span>
<a href="#l73.263"></a><span id="l73.263" class="difflineminus">-                         (void *)&amp;arg-&gt;sock_io_fns);</span>
<a href="#l73.264"></a><span id="l73.264" class="difflineplus">+                         (void*)&amp;arg-&gt;sock_io_fns);</span>
<a href="#l73.265"></a><span id="l73.265"> </span>
<a href="#l73.266"></a><span id="l73.266">   destroy_SASLIOSocketArg(&amp;arg);</span>
<a href="#l73.267"></a><span id="l73.267">   return (LDAP_SUCCESS);</span>
<a href="#l73.268"></a><span id="l73.268"> }</span>
<a href="#l73.269"></a><span id="l73.269"> </span>
<a href="#l73.270"></a><span id="l73.270"> static int nsldapi_sasl_close_socket(int s,</span>
<a href="#l73.271"></a><span id="l73.271" class="difflineminus">-                                     struct lextiof_socket_private *arg) {</span>
<a href="#l73.272"></a><span id="l73.272" class="difflineminus">-  LDAP_X_EXTIOF_CLOSE_CALLBACK *origclose;</span>
<a href="#l73.273"></a><span id="l73.273" class="difflineminus">-  struct lextiof_socket_private *origsock;</span>
<a href="#l73.274"></a><span id="l73.274" class="difflineplus">+                                     struct lextiof_socket_private* arg) {</span>
<a href="#l73.275"></a><span id="l73.275" class="difflineplus">+  LDAP_X_EXTIOF_CLOSE_CALLBACK* origclose;</span>
<a href="#l73.276"></a><span id="l73.276" class="difflineplus">+  struct lextiof_socket_private* origsock;</span>
<a href="#l73.277"></a><span id="l73.277"> </span>
<a href="#l73.278"></a><span id="l73.278">   if (arg == NULL) {</span>
<a href="#l73.279"></a><span id="l73.279">     return (-1);</span>
<a href="#l73.280"></a><span id="l73.280">   }</span>
<a href="#l73.281"></a><span id="l73.281"> </span>
<a href="#l73.282"></a><span id="l73.282">   origclose = arg-&gt;sess_io_fns.lextiof_close;</span>
<a href="#l73.283"></a><span id="l73.283">   origsock = arg-&gt;sock_io_fns.lbextiofn_socket_arg;</span>
<a href="#l73.284"></a><span id="l73.284"> </span>
<a href="#l73.285"></a><span id="l73.285" class="difflineat">@@ -489,44 +489,43 @@ static int nsldapi_sasl_close_socket(int</span>
<a href="#l73.286"></a><span id="l73.286"> #  endif   /* NSLDAPI_AVOID_OS_SOCKETS */</span>
<a href="#l73.287"></a><span id="l73.287">     return (rc);</span>
<a href="#l73.288"></a><span id="l73.288">   }</span>
<a href="#l73.289"></a><span id="l73.289"> }</span>
<a href="#l73.290"></a><span id="l73.290"> </span>
<a href="#l73.291"></a><span id="l73.291"> /*</span>
<a href="#l73.292"></a><span id="l73.292">  * install encryption routines if security has been negotiated</span>
<a href="#l73.293"></a><span id="l73.293">  */</span>
<a href="#l73.294"></a><span id="l73.294" class="difflineminus">-int nsldapi_sasl_install(LDAP *ld, LDAPConn *lconn) {</span>
<a href="#l73.295"></a><span id="l73.295" class="difflineplus">+int nsldapi_sasl_install(LDAP* ld, LDAPConn* lconn) {</span>
<a href="#l73.296"></a><span id="l73.296">   struct lber_x_ext_io_fns fns;</span>
<a href="#l73.297"></a><span id="l73.297">   struct ldap_x_ext_io_fns iofns;</span>
<a href="#l73.298"></a><span id="l73.298" class="difflineminus">-  sasl_security_properties_t *secprops;</span>
<a href="#l73.299"></a><span id="l73.299" class="difflineplus">+  sasl_security_properties_t* secprops;</span>
<a href="#l73.300"></a><span id="l73.300">   int rc, value;</span>
<a href="#l73.301"></a><span id="l73.301">   int bufsiz;</span>
<a href="#l73.302"></a><span id="l73.302" class="difflineminus">-  Sockbuf *sb = NULL;</span>
<a href="#l73.303"></a><span id="l73.303" class="difflineminus">-  sasl_conn_t *ctx = NULL;</span>
<a href="#l73.304"></a><span id="l73.304" class="difflineminus">-  SASLIOSocketArg *sockarg = NULL;</span>
<a href="#l73.305"></a><span id="l73.305" class="difflineplus">+  Sockbuf* sb = NULL;</span>
<a href="#l73.306"></a><span id="l73.306" class="difflineplus">+  sasl_conn_t* ctx = NULL;</span>
<a href="#l73.307"></a><span id="l73.307" class="difflineplus">+  SASLIOSocketArg* sockarg = NULL;</span>
<a href="#l73.308"></a><span id="l73.308"> </span>
<a href="#l73.309"></a><span id="l73.309">   if (lconn == NULL) {</span>
<a href="#l73.310"></a><span id="l73.310">     lconn = ld-&gt;ld_defconn;</span>
<a href="#l73.311"></a><span id="l73.311">     if (lconn == NULL) {</span>
<a href="#l73.312"></a><span id="l73.312">       return (LDAP_LOCAL_ERROR);</span>
<a href="#l73.313"></a><span id="l73.313">     }</span>
<a href="#l73.314"></a><span id="l73.314">   }</span>
<a href="#l73.315"></a><span id="l73.315">   if ((sb = lconn-&gt;lconn_sb) == NULL) {</span>
<a href="#l73.316"></a><span id="l73.316">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l73.317"></a><span id="l73.317">   }</span>
<a href="#l73.318"></a><span id="l73.318" class="difflineminus">-  rc =</span>
<a href="#l73.319"></a><span id="l73.319" class="difflineminus">-      ber_sockbuf_get_option(sb, LBER_SOCKBUF_OPT_TO_FILE_ONLY, (void *)&amp;value);</span>
<a href="#l73.320"></a><span id="l73.320" class="difflineplus">+  rc = ber_sockbuf_get_option(sb, LBER_SOCKBUF_OPT_TO_FILE_ONLY, (void*)&amp;value);</span>
<a href="#l73.321"></a><span id="l73.321">   if (rc != 0 || value != 0) {</span>
<a href="#l73.322"></a><span id="l73.322">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l73.323"></a><span id="l73.323">   }</span>
<a href="#l73.324"></a><span id="l73.324"> </span>
<a href="#l73.325"></a><span id="l73.325">   /* the sasl context in the lconn must have been set prior to this */</span>
<a href="#l73.326"></a><span id="l73.326">   ctx = lconn-&gt;lconn_sasl_ctx;</span>
<a href="#l73.327"></a><span id="l73.327" class="difflineminus">-  rc = sasl_getprop(ctx, SASL_SEC_PROPS, (const void **)&amp;secprops);</span>
<a href="#l73.328"></a><span id="l73.328" class="difflineplus">+  rc = sasl_getprop(ctx, SASL_SEC_PROPS, (const void**)&amp;secprops);</span>
<a href="#l73.329"></a><span id="l73.329">   if (rc != SASL_OK) return (LDAP_LOCAL_ERROR);</span>
<a href="#l73.330"></a><span id="l73.330">   bufsiz = secprops-&gt;maxbufsize;</span>
<a href="#l73.331"></a><span id="l73.331">   if (bufsiz &lt;= 0) {</span>
<a href="#l73.332"></a><span id="l73.332">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l73.333"></a><span id="l73.333">   }</span>
<a href="#l73.334"></a><span id="l73.334"> </span>
<a href="#l73.335"></a><span id="l73.335">   /* create our socket specific context */</span>
<a href="#l73.336"></a><span id="l73.336">   sockarg = new_SASLIOSocketArg(ctx, bufsiz, ld, sb);</span>
<a href="#l73.337"></a><span id="l73.337" class="difflineat">@@ -542,17 +541,17 @@ int nsldapi_sasl_install(LDAP *ld, LDAPC</span>
<a href="#l73.338"></a><span id="l73.338">     destroy_SASLIOSocketArg(&amp;sockarg);</span>
<a href="#l73.339"></a><span id="l73.339">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l73.340"></a><span id="l73.340">   }</span>
<a href="#l73.341"></a><span id="l73.341"> </span>
<a href="#l73.342"></a><span id="l73.342">   /* save a copy of the existing ber io fns and the socket arg */</span>
<a href="#l73.343"></a><span id="l73.343">   memset(&amp;sockarg-&gt;sock_io_fns, 0, LBER_X_EXTIO_FNS_SIZE);</span>
<a href="#l73.344"></a><span id="l73.344">   sockarg-&gt;sock_io_fns.lbextiofn_size = LBER_X_EXTIO_FNS_SIZE;</span>
<a href="#l73.345"></a><span id="l73.345">   rc = ber_sockbuf_get_option(sb, LBER_SOCKBUF_OPT_EXT_IO_FNS,</span>
<a href="#l73.346"></a><span id="l73.346" class="difflineminus">-                              (void *)&amp;sockarg-&gt;sock_io_fns);</span>
<a href="#l73.347"></a><span id="l73.347" class="difflineplus">+                              (void*)&amp;sockarg-&gt;sock_io_fns);</span>
<a href="#l73.348"></a><span id="l73.348">   if (rc != 0) {</span>
<a href="#l73.349"></a><span id="l73.349">     destroy_SASLIOSocketArg(&amp;sockarg);</span>
<a href="#l73.350"></a><span id="l73.350">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l73.351"></a><span id="l73.351">   }</span>
<a href="#l73.352"></a><span id="l73.352"> </span>
<a href="#l73.353"></a><span id="l73.353">   /* Always set the ext io close fn pointer to ensure we</span>
<a href="#l73.354"></a><span id="l73.354">    * clean up our sockarg context */</span>
<a href="#l73.355"></a><span id="l73.355">   memset(&amp;iofns, 0, sizeof(iofns));</span>
<a href="#l73.356"></a><span id="l73.356" class="difflineat">@@ -583,17 +582,17 @@ int nsldapi_sasl_install(LDAP *ld, LDAPC</span>
<a href="#l73.357"></a><span id="l73.357">   }</span>
<a href="#l73.358"></a><span id="l73.358"> </span>
<a href="#l73.359"></a><span id="l73.359">   /* set the new ber io funcs and socket arg */</span>
<a href="#l73.360"></a><span id="l73.360">   (void)memset(&amp;fns, 0, LBER_X_EXTIO_FNS_SIZE);</span>
<a href="#l73.361"></a><span id="l73.361">   fns.lbextiofn_size = LBER_X_EXTIO_FNS_SIZE;</span>
<a href="#l73.362"></a><span id="l73.362">   fns.lbextiofn_read = nsldapi_sasl_read;</span>
<a href="#l73.363"></a><span id="l73.363">   fns.lbextiofn_write = nsldapi_sasl_write;</span>
<a href="#l73.364"></a><span id="l73.364">   fns.lbextiofn_socket_arg = sockarg;</span>
<a href="#l73.365"></a><span id="l73.365" class="difflineminus">-  rc = ber_sockbuf_set_option(sb, LBER_SOCKBUF_OPT_EXT_IO_FNS, (void *)&amp;fns);</span>
<a href="#l73.366"></a><span id="l73.366" class="difflineplus">+  rc = ber_sockbuf_set_option(sb, LBER_SOCKBUF_OPT_EXT_IO_FNS, (void*)&amp;fns);</span>
<a href="#l73.367"></a><span id="l73.367">   if (rc != 0) {</span>
<a href="#l73.368"></a><span id="l73.368">     /* frees everything and resets fns above */</span>
<a href="#l73.369"></a><span id="l73.369">     nsldapi_sasl_close(sockarg);</span>
<a href="#l73.370"></a><span id="l73.370">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l73.371"></a><span id="l73.371">   }</span>
<a href="#l73.372"></a><span id="l73.372"> </span>
<a href="#l73.373"></a><span id="l73.373">   return (LDAP_SUCCESS);</span>
<a href="#l73.374"></a><span id="l73.374"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l74.1"></a><span id="l74.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/sbind.c</span>
<a href="#l74.2"></a><span id="l74.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/sbind.c</span>
<a href="#l74.3"></a><span id="l74.3" class="difflineat">@@ -45,30 +45,30 @@</span>
<a href="#l74.4"></a><span id="l74.4"> #if 0</span>
<a href="#l74.5"></a><span id="l74.5"> #  ifndef lint</span>
<a href="#l74.6"></a><span id="l74.6"> static char copyright[] = &quot;@(#) Copyright (c) 1993 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l74.7"></a><span id="l74.7"> #  endif</span>
<a href="#l74.8"></a><span id="l74.8"> #endif</span>
<a href="#l74.9"></a><span id="l74.9"> </span>
<a href="#l74.10"></a><span id="l74.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l74.11"></a><span id="l74.11"> </span>
<a href="#l74.12"></a><span id="l74.12" class="difflineminus">-static int simple_bind_nolock(LDAP *ld, const char *dn, const char *passwd,</span>
<a href="#l74.13"></a><span id="l74.13" class="difflineplus">+static int simple_bind_nolock(LDAP* ld, const char* dn, const char* passwd,</span>
<a href="#l74.14"></a><span id="l74.14">                               int unlock_permitted);</span>
<a href="#l74.15"></a><span id="l74.15"> </span>
<a href="#l74.16"></a><span id="l74.16"> /*</span>
<a href="#l74.17"></a><span id="l74.17">  * ldap_simple_bind - bind to the ldap server.  The dn and</span>
<a href="#l74.18"></a><span id="l74.18">  * password of the entry to which to bind are supplied.  The message id</span>
<a href="#l74.19"></a><span id="l74.19">  * of the request initiated is returned.</span>
<a href="#l74.20"></a><span id="l74.20">  *</span>
<a href="#l74.21"></a><span id="l74.21">  * Example:</span>
<a href="#l74.22"></a><span id="l74.22">  * ldap_simple_bind(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l74.23"></a><span id="l74.23">  *                  &quot;secret&quot;)</span>
<a href="#l74.24"></a><span id="l74.24">  */</span>
<a href="#l74.25"></a><span id="l74.25"> </span>
<a href="#l74.26"></a><span id="l74.26" class="difflineminus">-int LDAP_CALL ldap_simple_bind(LDAP *ld, const char *dn, const char *passwd) {</span>
<a href="#l74.27"></a><span id="l74.27" class="difflineplus">+int LDAP_CALL ldap_simple_bind(LDAP* ld, const char* dn, const char* passwd) {</span>
<a href="#l74.28"></a><span id="l74.28">   int rc;</span>
<a href="#l74.29"></a><span id="l74.29"> </span>
<a href="#l74.30"></a><span id="l74.30">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_simple_bind\n&quot;, 0, 0, 0);</span>
<a href="#l74.31"></a><span id="l74.31"> </span>
<a href="#l74.32"></a><span id="l74.32">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l74.33"></a><span id="l74.33">     return (LDAP_PARAM_ERROR);</span>
<a href="#l74.34"></a><span id="l74.34">   }</span>
<a href="#l74.35"></a><span id="l74.35"> </span>
<a href="#l74.36"></a><span id="l74.36" class="difflineat">@@ -76,19 +76,19 @@ int LDAP_CALL ldap_simple_bind(LDAP *ld,</span>
<a href="#l74.37"></a><span id="l74.37">     nsldapi_handle_reconnect(ld);</span>
<a href="#l74.38"></a><span id="l74.38">   }</span>
<a href="#l74.39"></a><span id="l74.39"> </span>
<a href="#l74.40"></a><span id="l74.40">   rc = simple_bind_nolock(ld, dn, passwd, 1);</span>
<a href="#l74.41"></a><span id="l74.41"> </span>
<a href="#l74.42"></a><span id="l74.42">   return (rc);</span>
<a href="#l74.43"></a><span id="l74.43"> }</span>
<a href="#l74.44"></a><span id="l74.44"> </span>
<a href="#l74.45"></a><span id="l74.45" class="difflineminus">-static int simple_bind_nolock(LDAP *ld, const char *dn, const char *passwd,</span>
<a href="#l74.46"></a><span id="l74.46" class="difflineplus">+static int simple_bind_nolock(LDAP* ld, const char* dn, const char* passwd,</span>
<a href="#l74.47"></a><span id="l74.47">                               int unlock_permitted) {</span>
<a href="#l74.48"></a><span id="l74.48" class="difflineminus">-  BerElement *ber;</span>
<a href="#l74.49"></a><span id="l74.49" class="difflineplus">+  BerElement* ber;</span>
<a href="#l74.50"></a><span id="l74.50">   int rc, msgid;</span>
<a href="#l74.51"></a><span id="l74.51"> </span>
<a href="#l74.52"></a><span id="l74.52">   /*</span>
<a href="#l74.53"></a><span id="l74.53">    * The bind request looks like this:</span>
<a href="#l74.54"></a><span id="l74.54">    * BindRequest ::= SEQUENCE {</span>
<a href="#l74.55"></a><span id="l74.55">    *   version INTEGER,</span>
<a href="#l74.56"></a><span id="l74.56">    *   name DistinguishedName,   -- who</span>
<a href="#l74.57"></a><span id="l74.57">    *   authentication CHOICE {</span>
<a href="#l74.58"></a><span id="l74.58" class="difflineat">@@ -103,17 +103,17 @@ static int simple_bind_nolock(LDAP *ld, </span>
<a href="#l74.59"></a><span id="l74.59">   LDAP_MUTEX_UNLOCK(ld, LDAP_MSGID_LOCK);</span>
<a href="#l74.60"></a><span id="l74.60"> </span>
<a href="#l74.61"></a><span id="l74.61">   if (dn == NULL) dn = &quot;&quot;;</span>
<a href="#l74.62"></a><span id="l74.62">   if (passwd == NULL) passwd = &quot;&quot;;</span>
<a href="#l74.63"></a><span id="l74.63"> </span>
<a href="#l74.64"></a><span id="l74.64">   if (ld-&gt;ld_cache_on &amp;&amp; ld-&gt;ld_cache_bind != NULL) {</span>
<a href="#l74.65"></a><span id="l74.65">     struct berval bv;</span>
<a href="#l74.66"></a><span id="l74.66"> </span>
<a href="#l74.67"></a><span id="l74.67" class="difflineminus">-    bv.bv_val = (char *)passwd;</span>
<a href="#l74.68"></a><span id="l74.68" class="difflineplus">+    bv.bv_val = (char*)passwd;</span>
<a href="#l74.69"></a><span id="l74.69">     bv.bv_len = strlen(passwd);</span>
<a href="#l74.70"></a><span id="l74.70">     /* if ( unlock_permitted ) LDAP_MUTEX_UNLOCK( ld ); */</span>
<a href="#l74.71"></a><span id="l74.71">     LDAP_MUTEX_LOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l74.72"></a><span id="l74.72">     rc = (ld-&gt;ld_cache_bind)(ld, msgid, LDAP_REQ_BIND, dn, &amp;bv,</span>
<a href="#l74.73"></a><span id="l74.73">                              LDAP_AUTH_SIMPLE);</span>
<a href="#l74.74"></a><span id="l74.74">     LDAP_MUTEX_UNLOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l74.75"></a><span id="l74.75">     /* if ( unlock_permitted ) LDAP_MUTEX_LOCK( ld ); */</span>
<a href="#l74.76"></a><span id="l74.76">     if (rc != 0) {</span>
<a href="#l74.77"></a><span id="l74.77" class="difflineat">@@ -137,49 +137,49 @@ static int simple_bind_nolock(LDAP *ld, </span>
<a href="#l74.78"></a><span id="l74.78"> </span>
<a href="#l74.79"></a><span id="l74.79">   if (nsldapi_put_controls(ld, NULL, 1, ber) != LDAP_SUCCESS) {</span>
<a href="#l74.80"></a><span id="l74.80">     ber_free(ber, 1);</span>
<a href="#l74.81"></a><span id="l74.81">     return (-1);</span>
<a href="#l74.82"></a><span id="l74.82">   }</span>
<a href="#l74.83"></a><span id="l74.83"> </span>
<a href="#l74.84"></a><span id="l74.84">   /* send the message */</span>
<a href="#l74.85"></a><span id="l74.85">   return (</span>
<a href="#l74.86"></a><span id="l74.86" class="difflineminus">-      nsldapi_send_initial_request(ld, msgid, LDAP_REQ_BIND, (char *)dn, ber));</span>
<a href="#l74.87"></a><span id="l74.87" class="difflineplus">+      nsldapi_send_initial_request(ld, msgid, LDAP_REQ_BIND, (char*)dn, ber));</span>
<a href="#l74.88"></a><span id="l74.88"> }</span>
<a href="#l74.89"></a><span id="l74.89"> </span>
<a href="#l74.90"></a><span id="l74.90"> /*</span>
<a href="#l74.91"></a><span id="l74.91">  * ldap_simple_bind - bind to the ldap server using simple</span>
<a href="#l74.92"></a><span id="l74.92">  * authentication.  The dn and password of the entry to which to bind are</span>
<a href="#l74.93"></a><span id="l74.93">  * supplied.  LDAP_SUCCESS is returned upon success, the ldap error code</span>
<a href="#l74.94"></a><span id="l74.94">  * otherwise.</span>
<a href="#l74.95"></a><span id="l74.95">  *</span>
<a href="#l74.96"></a><span id="l74.96">  * Example:</span>
<a href="#l74.97"></a><span id="l74.97">  * ldap_simple_bind_s(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l74.98"></a><span id="l74.98">  *                    &quot;secret&quot;)</span>
<a href="#l74.99"></a><span id="l74.99">  */</span>
<a href="#l74.100"></a><span id="l74.100" class="difflineminus">-int LDAP_CALL ldap_simple_bind_s(LDAP *ld, const char *dn, const char *passwd) {</span>
<a href="#l74.101"></a><span id="l74.101" class="difflineplus">+int LDAP_CALL ldap_simple_bind_s(LDAP* ld, const char* dn, const char* passwd) {</span>
<a href="#l74.102"></a><span id="l74.102">   int msgid;</span>
<a href="#l74.103"></a><span id="l74.103" class="difflineminus">-  LDAPMessage *result;</span>
<a href="#l74.104"></a><span id="l74.104" class="difflineplus">+  LDAPMessage* result;</span>
<a href="#l74.105"></a><span id="l74.105"> </span>
<a href="#l74.106"></a><span id="l74.106">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_simple_bind_s\n&quot;, 0, 0, 0);</span>
<a href="#l74.107"></a><span id="l74.107"> </span>
<a href="#l74.108"></a><span id="l74.108">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l74.109"></a><span id="l74.109">     return (LDAP_PARAM_ERROR);</span>
<a href="#l74.110"></a><span id="l74.110">   }</span>
<a href="#l74.111"></a><span id="l74.111"> </span>
<a href="#l74.112"></a><span id="l74.112">   if ((msgid = ldap_simple_bind(ld, dn, passwd)) == -1)</span>
<a href="#l74.113"></a><span id="l74.113">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l74.114"></a><span id="l74.114"> </span>
<a href="#l74.115"></a><span id="l74.115" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)0, &amp;result) == -1)</span>
<a href="#l74.116"></a><span id="l74.116" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)0, &amp;result) == -1)</span>
<a href="#l74.117"></a><span id="l74.117">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l74.118"></a><span id="l74.118"> </span>
<a href="#l74.119"></a><span id="l74.119">   return (ldap_result2error(ld, result, 1));</span>
<a href="#l74.120"></a><span id="l74.120"> }</span>
<a href="#l74.121"></a><span id="l74.121"> </span>
<a href="#l74.122"></a><span id="l74.122" class="difflineminus">-void nsldapi_handle_reconnect(LDAP *ld) {</span>
<a href="#l74.123"></a><span id="l74.123" class="difflineplus">+void nsldapi_handle_reconnect(LDAP* ld) {</span>
<a href="#l74.124"></a><span id="l74.124">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_handle_reconnect\n&quot;, 0, 0, 0);</span>
<a href="#l74.125"></a><span id="l74.125"> </span>
<a href="#l74.126"></a><span id="l74.126">   /*</span>
<a href="#l74.127"></a><span id="l74.127">    * if the default connection has been lost and is now marked dead,</span>
<a href="#l74.128"></a><span id="l74.128">    * dispose of the default connection so it will get re-established.</span>
<a href="#l74.129"></a><span id="l74.129">    *</span>
<a href="#l74.130"></a><span id="l74.130">    * if not, clear the bind DN and status to ensure that we don't</span>
<a href="#l74.131"></a><span id="l74.131">    * report the wrong bind DN to a different thread while waiting</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l75.1"></a><span id="l75.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/search.c</span>
<a href="#l75.2"></a><span id="l75.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/search.c</span>
<a href="#l75.3"></a><span id="l75.3" class="difflineat">@@ -45,38 +45,38 @@</span>
<a href="#l75.4"></a><span id="l75.4"> #if 0</span>
<a href="#l75.5"></a><span id="l75.5"> #  ifndef lint</span>
<a href="#l75.6"></a><span id="l75.6"> static char copyright[] = &quot;@(#) Copyright (c) 1990 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l75.7"></a><span id="l75.7"> #  endif</span>
<a href="#l75.8"></a><span id="l75.8"> #endif</span>
<a href="#l75.9"></a><span id="l75.9"> </span>
<a href="#l75.10"></a><span id="l75.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l75.11"></a><span id="l75.11"> </span>
<a href="#l75.12"></a><span id="l75.12" class="difflineminus">-static int nsldapi_timeval2ldaplimit(struct timeval *timeoutp,</span>
<a href="#l75.13"></a><span id="l75.13" class="difflineplus">+static int nsldapi_timeval2ldaplimit(struct timeval* timeoutp,</span>
<a href="#l75.14"></a><span id="l75.14">                                      int defaultvalue);</span>
<a href="#l75.15"></a><span id="l75.15" class="difflineminus">-static int nsldapi_search(LDAP *ld, const char *base, int scope,</span>
<a href="#l75.16"></a><span id="l75.16" class="difflineminus">-                          const char *filter, char **attrs, int attrsonly,</span>
<a href="#l75.17"></a><span id="l75.17" class="difflineminus">-                          LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l75.18"></a><span id="l75.18" class="difflineminus">-                          int timelimit, int sizelimit, int *msgidp);</span>
<a href="#l75.19"></a><span id="l75.19" class="difflineminus">-static char *find_right_paren(char *s);</span>
<a href="#l75.20"></a><span id="l75.20" class="difflineminus">-static char *put_complex_filter(BerElement *ber, char *str, unsigned long tag,</span>
<a href="#l75.21"></a><span id="l75.21" class="difflineminus">-                                int not);</span>
<a href="#l75.22"></a><span id="l75.22" class="difflineminus">-static int put_filter(BerElement *ber, char *str);</span>
<a href="#l75.23"></a><span id="l75.23" class="difflineminus">-static int unescape_filterval(char *str);</span>
<a href="#l75.24"></a><span id="l75.24" class="difflineplus">+static int nsldapi_search(LDAP* ld, const char* base, int scope,</span>
<a href="#l75.25"></a><span id="l75.25" class="difflineplus">+                          const char* filter, char** attrs, int attrsonly,</span>
<a href="#l75.26"></a><span id="l75.26" class="difflineplus">+                          LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l75.27"></a><span id="l75.27" class="difflineplus">+                          int timelimit, int sizelimit, int* msgidp);</span>
<a href="#l75.28"></a><span id="l75.28" class="difflineplus">+static char* find_right_paren(char* s);</span>
<a href="#l75.29"></a><span id="l75.29" class="difflineplus">+static char* put_complex_filter(BerElement* ber, char* str, unsigned long tag,</span>
<a href="#l75.30"></a><span id="l75.30" class="difflineplus">+                                int not );</span>
<a href="#l75.31"></a><span id="l75.31" class="difflineplus">+static int put_filter(BerElement* ber, char* str);</span>
<a href="#l75.32"></a><span id="l75.32" class="difflineplus">+static int unescape_filterval(char* str);</span>
<a href="#l75.33"></a><span id="l75.33"> static int hexchar2int(char c);</span>
<a href="#l75.34"></a><span id="l75.34" class="difflineminus">-static int is_valid_attr(char *a);</span>
<a href="#l75.35"></a><span id="l75.35" class="difflineminus">-static int put_simple_filter(BerElement *ber, char *str);</span>
<a href="#l75.36"></a><span id="l75.36" class="difflineminus">-static int put_substring_filter(BerElement *ber, char *type, char *str);</span>
<a href="#l75.37"></a><span id="l75.37" class="difflineminus">-static int put_filter_list(BerElement *ber, char *str);</span>
<a href="#l75.38"></a><span id="l75.38" class="difflineminus">-static int nsldapi_search_s(LDAP *ld, const char *base, int scope,</span>
<a href="#l75.39"></a><span id="l75.39" class="difflineminus">-                            const char *filter, char **attrs, int attrsonly,</span>
<a href="#l75.40"></a><span id="l75.40" class="difflineminus">-                            LDAPControl **serverctrls,</span>
<a href="#l75.41"></a><span id="l75.41" class="difflineminus">-                            LDAPControl **clientctrls,</span>
<a href="#l75.42"></a><span id="l75.42" class="difflineminus">-                            struct timeval *localtimeoutp, int timelimit,</span>
<a href="#l75.43"></a><span id="l75.43" class="difflineminus">-                            int sizelimit, LDAPMessage **res);</span>
<a href="#l75.44"></a><span id="l75.44" class="difflineplus">+static int is_valid_attr(char* a);</span>
<a href="#l75.45"></a><span id="l75.45" class="difflineplus">+static int put_simple_filter(BerElement* ber, char* str);</span>
<a href="#l75.46"></a><span id="l75.46" class="difflineplus">+static int put_substring_filter(BerElement* ber, char* type, char* str);</span>
<a href="#l75.47"></a><span id="l75.47" class="difflineplus">+static int put_filter_list(BerElement* ber, char* str);</span>
<a href="#l75.48"></a><span id="l75.48" class="difflineplus">+static int nsldapi_search_s(LDAP* ld, const char* base, int scope,</span>
<a href="#l75.49"></a><span id="l75.49" class="difflineplus">+                            const char* filter, char** attrs, int attrsonly,</span>
<a href="#l75.50"></a><span id="l75.50" class="difflineplus">+                            LDAPControl** serverctrls,</span>
<a href="#l75.51"></a><span id="l75.51" class="difflineplus">+                            LDAPControl** clientctrls,</span>
<a href="#l75.52"></a><span id="l75.52" class="difflineplus">+                            struct timeval* localtimeoutp, int timelimit,</span>
<a href="#l75.53"></a><span id="l75.53" class="difflineplus">+                            int sizelimit, LDAPMessage** res);</span>
<a href="#l75.54"></a><span id="l75.54"> </span>
<a href="#l75.55"></a><span id="l75.55"> /*</span>
<a href="#l75.56"></a><span id="l75.56">  * ldap_search - initiate an ldap search operation.  Parameters:</span>
<a href="#l75.57"></a><span id="l75.57">  *</span>
<a href="#l75.58"></a><span id="l75.58">  * ld         LDAP descriptor</span>
<a href="#l75.59"></a><span id="l75.59">  * base       DN of the base object</span>
<a href="#l75.60"></a><span id="l75.60">  * scope      the search scope - one of LDAP_SCOPE_BASE,</span>
<a href="#l75.61"></a><span id="l75.61">  *            LDAP_SCOPE_ONELEVEL, LDAP_SCOPE_SUBTREE</span>
<a href="#l75.62"></a><span id="l75.62" class="difflineat">@@ -85,18 +85,18 @@ static int nsldapi_search_s(LDAP *ld, co</span>
<a href="#l75.63"></a><span id="l75.63">  * attrs      list of attribute types to return for matches</span>
<a href="#l75.64"></a><span id="l75.64">  * attrsonly  1 =&gt; attributes only 0 =&gt; attributes and values</span>
<a href="#l75.65"></a><span id="l75.65">  *</span>
<a href="#l75.66"></a><span id="l75.66">  * Example:</span>
<a href="#l75.67"></a><span id="l75.67">  * char  *attrs[] = { &quot;mail&quot;, &quot;title&quot;, 0 };</span>
<a href="#l75.68"></a><span id="l75.68">  * msgid = ldap_search(ld, &quot;c=us@o=UM&quot;, LDAP_SCOPE_SUBTREE, &quot;cn~=bob&quot;,</span>
<a href="#l75.69"></a><span id="l75.69">  *                     attrs, attrsonly);</span>
<a href="#l75.70"></a><span id="l75.70">  */</span>
<a href="#l75.71"></a><span id="l75.71" class="difflineminus">-int LDAP_CALL ldap_search(LDAP *ld, const char *base, int scope,</span>
<a href="#l75.72"></a><span id="l75.72" class="difflineminus">-                          const char *filter, char **attrs, int attrsonly) {</span>
<a href="#l75.73"></a><span id="l75.73" class="difflineplus">+int LDAP_CALL ldap_search(LDAP* ld, const char* base, int scope,</span>
<a href="#l75.74"></a><span id="l75.74" class="difflineplus">+                          const char* filter, char** attrs, int attrsonly) {</span>
<a href="#l75.75"></a><span id="l75.75">   int msgid;</span>
<a href="#l75.76"></a><span id="l75.76"> </span>
<a href="#l75.77"></a><span id="l75.77">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_search\n&quot;, 0, 0, 0);</span>
<a href="#l75.78"></a><span id="l75.78"> </span>
<a href="#l75.79"></a><span id="l75.79">   if (ldap_search_ext(ld, base, scope, filter, attrs, attrsonly, NULL, NULL,</span>
<a href="#l75.80"></a><span id="l75.80">                       NULL, -1, &amp;msgid) == LDAP_SUCCESS) {</span>
<a href="#l75.81"></a><span id="l75.81">     return (msgid);</span>
<a href="#l75.82"></a><span id="l75.82">   } else {</span>
<a href="#l75.83"></a><span id="l75.83" class="difflineat">@@ -104,20 +104,20 @@ int LDAP_CALL ldap_search(LDAP *ld, cons</span>
<a href="#l75.84"></a><span id="l75.84">   }</span>
<a href="#l75.85"></a><span id="l75.85"> }</span>
<a href="#l75.86"></a><span id="l75.86"> </span>
<a href="#l75.87"></a><span id="l75.87"> /*</span>
<a href="#l75.88"></a><span id="l75.88">  * LDAPv3 extended search.</span>
<a href="#l75.89"></a><span id="l75.89">  * Returns an LDAP error code.</span>
<a href="#l75.90"></a><span id="l75.90">  */</span>
<a href="#l75.91"></a><span id="l75.91"> int LDAP_CALL ldap_search_ext(</span>
<a href="#l75.92"></a><span id="l75.92" class="difflineminus">-    LDAP *ld, const char *base, int scope, const char *filter, char **attrs,</span>
<a href="#l75.93"></a><span id="l75.93" class="difflineminus">-    int attrsonly, LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l75.94"></a><span id="l75.94" class="difflineminus">-    struct timeval *timeoutp, /* NULL means use ld-&gt;ld_timelimit */</span>
<a href="#l75.95"></a><span id="l75.95" class="difflineminus">-    int sizelimit, int *msgidp) {</span>
<a href="#l75.96"></a><span id="l75.96" class="difflineplus">+    LDAP* ld, const char* base, int scope, const char* filter, char** attrs,</span>
<a href="#l75.97"></a><span id="l75.97" class="difflineplus">+    int attrsonly, LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l75.98"></a><span id="l75.98" class="difflineplus">+    struct timeval* timeoutp, /* NULL means use ld-&gt;ld_timelimit */</span>
<a href="#l75.99"></a><span id="l75.99" class="difflineplus">+    int sizelimit, int* msgidp) {</span>
<a href="#l75.100"></a><span id="l75.100">   /*</span>
<a href="#l75.101"></a><span id="l75.101">    * It is an error to pass in a zero'd timeval.</span>
<a href="#l75.102"></a><span id="l75.102">    */</span>
<a href="#l75.103"></a><span id="l75.103">   if (timeoutp != NULL &amp;&amp; timeoutp-&gt;tv_sec == 0 &amp;&amp; timeoutp-&gt;tv_usec == 0) {</span>
<a href="#l75.104"></a><span id="l75.104">     if (ld != NULL) {</span>
<a href="#l75.105"></a><span id="l75.105">       LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l75.106"></a><span id="l75.106">     }</span>
<a href="#l75.107"></a><span id="l75.107">     return (LDAP_PARAM_ERROR);</span>
<a href="#l75.108"></a><span id="l75.108" class="difflineat">@@ -127,23 +127,23 @@ int LDAP_CALL ldap_search_ext(</span>
<a href="#l75.109"></a><span id="l75.109">                          clientctrls, nsldapi_timeval2ldaplimit(timeoutp, -1),</span>
<a href="#l75.110"></a><span id="l75.110">                          sizelimit, msgidp));</span>
<a href="#l75.111"></a><span id="l75.111"> }</span>
<a href="#l75.112"></a><span id="l75.112"> </span>
<a href="#l75.113"></a><span id="l75.113"> /*</span>
<a href="#l75.114"></a><span id="l75.114">  * Like ldap_search_ext() except an integer timelimit is passed instead of</span>
<a href="#l75.115"></a><span id="l75.115">  * using the overloaded struct timeval *timeoutp.</span>
<a href="#l75.116"></a><span id="l75.116">  */</span>
<a href="#l75.117"></a><span id="l75.117" class="difflineminus">-static int nsldapi_search(LDAP *ld, const char *base, int scope,</span>
<a href="#l75.118"></a><span id="l75.118" class="difflineminus">-                          const char *filter, char **attrs, int attrsonly,</span>
<a href="#l75.119"></a><span id="l75.119" class="difflineminus">-                          LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l75.120"></a><span id="l75.120" class="difflineplus">+static int nsldapi_search(LDAP* ld, const char* base, int scope,</span>
<a href="#l75.121"></a><span id="l75.121" class="difflineplus">+                          const char* filter, char** attrs, int attrsonly,</span>
<a href="#l75.122"></a><span id="l75.122" class="difflineplus">+                          LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l75.123"></a><span id="l75.123">                           int timelimit, /* -1 means use ld-&gt;ld_timelimit */</span>
<a href="#l75.124"></a><span id="l75.124">                           int sizelimit, /* -1 means use ld-&gt;ld_sizelimit */</span>
<a href="#l75.125"></a><span id="l75.125" class="difflineminus">-                          int *msgidp) {</span>
<a href="#l75.126"></a><span id="l75.126" class="difflineminus">-  BerElement *ber;</span>
<a href="#l75.127"></a><span id="l75.127" class="difflineplus">+                          int* msgidp) {</span>
<a href="#l75.128"></a><span id="l75.128" class="difflineplus">+  BerElement* ber;</span>
<a href="#l75.129"></a><span id="l75.129">   int rc, rc_key;</span>
<a href="#l75.130"></a><span id="l75.130">   unsigned long key; /* XXXmcs: memcache */</span>
<a href="#l75.131"></a><span id="l75.131"> </span>
<a href="#l75.132"></a><span id="l75.132">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_search_ext\n&quot;, 0, 0, 0);</span>
<a href="#l75.133"></a><span id="l75.133"> </span>
<a href="#l75.134"></a><span id="l75.134">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l75.135"></a><span id="l75.135">     return (LDAP_PARAM_ERROR);</span>
<a href="#l75.136"></a><span id="l75.136">   }</span>
<a href="#l75.137"></a><span id="l75.137" class="difflineat">@@ -194,17 +194,17 @@ static int nsldapi_search(LDAP *ld, cons</span>
<a href="#l75.138"></a><span id="l75.138">   /* caching off or did not find it in the cache - check the net */</span>
<a href="#l75.139"></a><span id="l75.139">   if ((rc = nsldapi_build_search_req(</span>
<a href="#l75.140"></a><span id="l75.140">            ld, base, scope, filter, attrs, attrsonly, serverctrls, clientctrls,</span>
<a href="#l75.141"></a><span id="l75.141">            timelimit, sizelimit, *msgidp, &amp;ber)) != LDAP_SUCCESS) {</span>
<a href="#l75.142"></a><span id="l75.142">     return (rc);</span>
<a href="#l75.143"></a><span id="l75.143">   }</span>
<a href="#l75.144"></a><span id="l75.144"> </span>
<a href="#l75.145"></a><span id="l75.145">   /* send the message */</span>
<a href="#l75.146"></a><span id="l75.146" class="difflineminus">-  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_SEARCH, (char *)base,</span>
<a href="#l75.147"></a><span id="l75.147" class="difflineplus">+  rc = nsldapi_send_initial_request(ld, *msgidp, LDAP_REQ_SEARCH, (char*)base,</span>
<a href="#l75.148"></a><span id="l75.148">                                     ber);</span>
<a href="#l75.149"></a><span id="l75.149"> </span>
<a href="#l75.150"></a><span id="l75.150">   /*</span>
<a href="#l75.151"></a><span id="l75.151">    * XXXmcs: should use cache function pointers to hook in memcache</span>
<a href="#l75.152"></a><span id="l75.152">    */</span>
<a href="#l75.153"></a><span id="l75.153">   if ((rc_key == LDAP_SUCCESS) &amp;&amp; (rc &gt;= 0)) {</span>
<a href="#l75.154"></a><span id="l75.154">     ldap_memcache_new(ld, rc, key, base);</span>
<a href="#l75.155"></a><span id="l75.155">   }</span>
<a href="#l75.156"></a><span id="l75.156" class="difflineat">@@ -212,17 +212,17 @@ static int nsldapi_search(LDAP *ld, cons</span>
<a href="#l75.157"></a><span id="l75.157">   *msgidp = rc;</span>
<a href="#l75.158"></a><span id="l75.158">   return (rc &lt; 0 ? LDAP_GET_LDERRNO(ld, NULL, NULL) : LDAP_SUCCESS);</span>
<a href="#l75.159"></a><span id="l75.159"> }</span>
<a href="#l75.160"></a><span id="l75.160"> </span>
<a href="#l75.161"></a><span id="l75.161"> /*</span>
<a href="#l75.162"></a><span id="l75.162">  * Convert a non-NULL timeoutp to a value in seconds that is appropriate to</span>
<a href="#l75.163"></a><span id="l75.163">  * send in an LDAP search request.  If timeoutp is NULL, return defaultvalue.</span>
<a href="#l75.164"></a><span id="l75.164">  */</span>
<a href="#l75.165"></a><span id="l75.165" class="difflineminus">-static int nsldapi_timeval2ldaplimit(struct timeval *timeoutp,</span>
<a href="#l75.166"></a><span id="l75.166" class="difflineplus">+static int nsldapi_timeval2ldaplimit(struct timeval* timeoutp,</span>
<a href="#l75.167"></a><span id="l75.167">                                      int defaultvalue) {</span>
<a href="#l75.168"></a><span id="l75.168">   int timelimit;</span>
<a href="#l75.169"></a><span id="l75.169"> </span>
<a href="#l75.170"></a><span id="l75.170">   if (NULL == timeoutp) {</span>
<a href="#l75.171"></a><span id="l75.171">     timelimit = defaultvalue;</span>
<a href="#l75.172"></a><span id="l75.172">   } else if (timeoutp-&gt;tv_sec &gt; 0) {</span>
<a href="#l75.173"></a><span id="l75.173">     timelimit = timeoutp-&gt;tv_sec;</span>
<a href="#l75.174"></a><span id="l75.174">   } else if (timeoutp-&gt;tv_usec &gt; 0) {</span>
<a href="#l75.175"></a><span id="l75.175" class="difflineat">@@ -236,25 +236,25 @@ static int nsldapi_timeval2ldaplimit(str</span>
<a href="#l75.176"></a><span id="l75.176">     timelimit = 0; /* no limit */</span>
<a href="#l75.177"></a><span id="l75.177">   }</span>
<a href="#l75.178"></a><span id="l75.178"> </span>
<a href="#l75.179"></a><span id="l75.179">   return (timelimit);</span>
<a href="#l75.180"></a><span id="l75.180"> }</span>
<a href="#l75.181"></a><span id="l75.181"> </span>
<a href="#l75.182"></a><span id="l75.182"> /* returns an LDAP error code and also sets it in ld */</span>
<a href="#l75.183"></a><span id="l75.183"> int nsldapi_build_search_req(</span>
<a href="#l75.184"></a><span id="l75.184" class="difflineminus">-    LDAP *ld, const char *base, int scope, const char *filter, char **attrs,</span>
<a href="#l75.185"></a><span id="l75.185" class="difflineminus">-    int attrsonly, LDAPControl **serverctrls,</span>
<a href="#l75.186"></a><span id="l75.186" class="difflineminus">-    LDAPControl **clientctrls, /* not used for anything yet */</span>
<a href="#l75.187"></a><span id="l75.187" class="difflineplus">+    LDAP* ld, const char* base, int scope, const char* filter, char** attrs,</span>
<a href="#l75.188"></a><span id="l75.188" class="difflineplus">+    int attrsonly, LDAPControl** serverctrls,</span>
<a href="#l75.189"></a><span id="l75.189" class="difflineplus">+    LDAPControl** clientctrls, /* not used for anything yet */</span>
<a href="#l75.190"></a><span id="l75.190">     int timelimit,             /* if -1, ld-&gt;ld_timelimit is used */</span>
<a href="#l75.191"></a><span id="l75.191">     int sizelimit,             /* if -1, ld-&gt;ld_sizelimit is used */</span>
<a href="#l75.192"></a><span id="l75.192" class="difflineminus">-    int msgid, BerElement **berp) {</span>
<a href="#l75.193"></a><span id="l75.193" class="difflineminus">-  BerElement *ber;</span>
<a href="#l75.194"></a><span id="l75.194" class="difflineplus">+    int msgid, BerElement** berp) {</span>
<a href="#l75.195"></a><span id="l75.195" class="difflineplus">+  BerElement* ber;</span>
<a href="#l75.196"></a><span id="l75.196">   int err;</span>
<a href="#l75.197"></a><span id="l75.197" class="difflineminus">-  char *fdup;</span>
<a href="#l75.198"></a><span id="l75.198" class="difflineplus">+  char* fdup;</span>
<a href="#l75.199"></a><span id="l75.199"> </span>
<a href="#l75.200"></a><span id="l75.200">   /*</span>
<a href="#l75.201"></a><span id="l75.201">    * Create the search request.  It looks like this:</span>
<a href="#l75.202"></a><span id="l75.202">    * SearchRequest := [APPLICATION 3] SEQUENCE {</span>
<a href="#l75.203"></a><span id="l75.203">    *   baseObject DistinguishedName,</span>
<a href="#l75.204"></a><span id="l75.204">    *   scope ENUMERATED {</span>
<a href="#l75.205"></a><span id="l75.205">    *     baseObject   (0),</span>
<a href="#l75.206"></a><span id="l75.206">    *     singleLevel  (1),</span>
<a href="#l75.207"></a><span id="l75.207" class="difflineat">@@ -331,17 +331,17 @@ int nsldapi_build_search_req(</span>
<a href="#l75.208"></a><span id="l75.208">     ber_free(ber, 1);</span>
<a href="#l75.209"></a><span id="l75.209">     return (err);</span>
<a href="#l75.210"></a><span id="l75.210">   }</span>
<a href="#l75.211"></a><span id="l75.211"> </span>
<a href="#l75.212"></a><span id="l75.212">   *berp = ber;</span>
<a href="#l75.213"></a><span id="l75.213">   return (LDAP_SUCCESS);</span>
<a href="#l75.214"></a><span id="l75.214"> }</span>
<a href="#l75.215"></a><span id="l75.215"> </span>
<a href="#l75.216"></a><span id="l75.216" class="difflineminus">-static char *find_right_paren(char *s) {</span>
<a href="#l75.217"></a><span id="l75.217" class="difflineplus">+static char* find_right_paren(char* s) {</span>
<a href="#l75.218"></a><span id="l75.218">   int balance, escape;</span>
<a href="#l75.219"></a><span id="l75.219"> </span>
<a href="#l75.220"></a><span id="l75.220">   balance = 1;</span>
<a href="#l75.221"></a><span id="l75.221">   escape = 0;</span>
<a href="#l75.222"></a><span id="l75.222">   while (*s &amp;&amp; balance) {</span>
<a href="#l75.223"></a><span id="l75.223">     if (escape == 0) {</span>
<a href="#l75.224"></a><span id="l75.224">       if (*s == '(')</span>
<a href="#l75.225"></a><span id="l75.225">         balance++;</span>
<a href="#l75.226"></a><span id="l75.226" class="difflineat">@@ -353,19 +353,19 @@ static char *find_right_paren(char *s) {</span>
<a href="#l75.227"></a><span id="l75.227">     else</span>
<a href="#l75.228"></a><span id="l75.228">       escape = 0;</span>
<a href="#l75.229"></a><span id="l75.229">     if (balance) s++;</span>
<a href="#l75.230"></a><span id="l75.230">   }</span>
<a href="#l75.231"></a><span id="l75.231"> </span>
<a href="#l75.232"></a><span id="l75.232">   return (*s ? s : NULL);</span>
<a href="#l75.233"></a><span id="l75.233"> }</span>
<a href="#l75.234"></a><span id="l75.234"> </span>
<a href="#l75.235"></a><span id="l75.235" class="difflineminus">-static char *put_complex_filter(BerElement *ber, char *str, unsigned long tag,</span>
<a href="#l75.236"></a><span id="l75.236" class="difflineminus">-                                int not) {</span>
<a href="#l75.237"></a><span id="l75.237" class="difflineminus">-  char *next;</span>
<a href="#l75.238"></a><span id="l75.238" class="difflineplus">+static char* put_complex_filter(BerElement* ber, char* str, unsigned long tag,</span>
<a href="#l75.239"></a><span id="l75.239" class="difflineplus">+                                int not ) {</span>
<a href="#l75.240"></a><span id="l75.240" class="difflineplus">+  char* next;</span>
<a href="#l75.241"></a><span id="l75.241"> </span>
<a href="#l75.242"></a><span id="l75.242">   /*</span>
<a href="#l75.243"></a><span id="l75.243">    * We have (x(filter)...) with str sitting on</span>
<a href="#l75.244"></a><span id="l75.244">    * the x.  We have to find the paren matching</span>
<a href="#l75.245"></a><span id="l75.245">    * the one before the x and put the intervening</span>
<a href="#l75.246"></a><span id="l75.246">    * filters by calling put_filter_list().</span>
<a href="#l75.247"></a><span id="l75.247">    */</span>
<a href="#l75.248"></a><span id="l75.248"> </span>
<a href="#l75.249"></a><span id="l75.249" class="difflineat">@@ -380,18 +380,18 @@ static char *put_complex_filter(BerEleme</span>
<a href="#l75.250"></a><span id="l75.250">   *next++ = ')';</span>
<a href="#l75.251"></a><span id="l75.251"> </span>
<a href="#l75.252"></a><span id="l75.252">   /* flush explicit tagged thang */</span>
<a href="#l75.253"></a><span id="l75.253">   if (ber_printf(ber, &quot;}&quot;) == -1) return (NULL);</span>
<a href="#l75.254"></a><span id="l75.254"> </span>
<a href="#l75.255"></a><span id="l75.255">   return (next);</span>
<a href="#l75.256"></a><span id="l75.256"> }</span>
<a href="#l75.257"></a><span id="l75.257"> </span>
<a href="#l75.258"></a><span id="l75.258" class="difflineminus">-static int put_filter(BerElement *ber, char *str) {</span>
<a href="#l75.259"></a><span id="l75.259" class="difflineminus">-  char *next;</span>
<a href="#l75.260"></a><span id="l75.260" class="difflineplus">+static int put_filter(BerElement* ber, char* str) {</span>
<a href="#l75.261"></a><span id="l75.261" class="difflineplus">+  char* next;</span>
<a href="#l75.262"></a><span id="l75.262">   int parens, balance, escape;</span>
<a href="#l75.263"></a><span id="l75.263"> </span>
<a href="#l75.264"></a><span id="l75.264">   /*</span>
<a href="#l75.265"></a><span id="l75.265">    * A Filter looks like this:</span>
<a href="#l75.266"></a><span id="l75.266">    *      Filter ::= CHOICE {</span>
<a href="#l75.267"></a><span id="l75.267">    *              and             [0]     SET OF Filter,</span>
<a href="#l75.268"></a><span id="l75.268">    *              or              [1]     SET OF Filter,</span>
<a href="#l75.269"></a><span id="l75.269">    *              not             [2]     Filter,</span>
<a href="#l75.270"></a><span id="l75.270" class="difflineat">@@ -508,18 +508,18 @@ static int put_filter(BerElement *ber, c</span>
<a href="#l75.271"></a><span id="l75.271"> </span>
<a href="#l75.272"></a><span id="l75.272">   return (parens ? -1 : 0);</span>
<a href="#l75.273"></a><span id="l75.273"> }</span>
<a href="#l75.274"></a><span id="l75.274"> </span>
<a href="#l75.275"></a><span id="l75.275"> /*</span>
<a href="#l75.276"></a><span id="l75.276">  * Put a list of filters like this &quot;(filter1)(filter2)...&quot;</span>
<a href="#l75.277"></a><span id="l75.277">  */</span>
<a href="#l75.278"></a><span id="l75.278"> </span>
<a href="#l75.279"></a><span id="l75.279" class="difflineminus">-static int put_filter_list(BerElement *ber, char *str) {</span>
<a href="#l75.280"></a><span id="l75.280" class="difflineminus">-  char *next;</span>
<a href="#l75.281"></a><span id="l75.281" class="difflineplus">+static int put_filter_list(BerElement* ber, char* str) {</span>
<a href="#l75.282"></a><span id="l75.282" class="difflineplus">+  char* next;</span>
<a href="#l75.283"></a><span id="l75.283">   char save;</span>
<a href="#l75.284"></a><span id="l75.284"> </span>
<a href="#l75.285"></a><span id="l75.285">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;put_filter_list \&quot;%s\&quot;\n&quot;, str, 0, 0);</span>
<a href="#l75.286"></a><span id="l75.286"> </span>
<a href="#l75.287"></a><span id="l75.287">   while (*str) {</span>
<a href="#l75.288"></a><span id="l75.288">     while (*str &amp;&amp; isspace(*str)) str++;</span>
<a href="#l75.289"></a><span id="l75.289">     if (*str == '\0') break;</span>
<a href="#l75.290"></a><span id="l75.290"> </span>
<a href="#l75.291"></a><span id="l75.291" class="difflineat">@@ -545,17 +545,17 @@ static int put_filter_list(BerElement *b</span>
<a href="#l75.292"></a><span id="l75.292">  * cn;lang-fr</span>
<a href="#l75.293"></a><span id="l75.293">  * 1.2.3.4;binary;dynamic</span>
<a href="#l75.294"></a><span id="l75.294">  * mail;dynamic</span>
<a href="#l75.295"></a><span id="l75.295">  * cn:dn:1.2.3.4</span>
<a href="#l75.296"></a><span id="l75.296">  *</span>
<a href="#l75.297"></a><span id="l75.297">  * For compatibility with older servers, we also allow underscores in</span>
<a href="#l75.298"></a><span id="l75.298">  * attribute types, even through they are not allowed by the LDAPv3 RFCs.</span>
<a href="#l75.299"></a><span id="l75.299">  */</span>
<a href="#l75.300"></a><span id="l75.300" class="difflineminus">-static int is_valid_attr(char *a) {</span>
<a href="#l75.301"></a><span id="l75.301" class="difflineplus">+static int is_valid_attr(char* a) {</span>
<a href="#l75.302"></a><span id="l75.302">   for (; *a; a++) {</span>
<a href="#l75.303"></a><span id="l75.303">     if (!isascii(*a)) {</span>
<a href="#l75.304"></a><span id="l75.304">       return (0);</span>
<a href="#l75.305"></a><span id="l75.305">     } else if (!isalnum(*a)) {</span>
<a href="#l75.306"></a><span id="l75.306">       switch (*a) {</span>
<a href="#l75.307"></a><span id="l75.307">         case '-':</span>
<a href="#l75.308"></a><span id="l75.308">         case '.':</span>
<a href="#l75.309"></a><span id="l75.309">         case ';':</span>
<a href="#l75.310"></a><span id="l75.310" class="difflineat">@@ -566,37 +566,37 @@ static int is_valid_attr(char *a) {</span>
<a href="#l75.311"></a><span id="l75.311">           return (0);</span>
<a href="#l75.312"></a><span id="l75.312">       }</span>
<a href="#l75.313"></a><span id="l75.313">     }</span>
<a href="#l75.314"></a><span id="l75.314">   }</span>
<a href="#l75.315"></a><span id="l75.315"> </span>
<a href="#l75.316"></a><span id="l75.316">   return (1);</span>
<a href="#l75.317"></a><span id="l75.317"> }</span>
<a href="#l75.318"></a><span id="l75.318"> </span>
<a href="#l75.319"></a><span id="l75.319" class="difflineminus">-static char *find_star(char *s) {</span>
<a href="#l75.320"></a><span id="l75.320" class="difflineplus">+static char* find_star(char* s) {</span>
<a href="#l75.321"></a><span id="l75.321">   for (; *s; ++s) {</span>
<a href="#l75.322"></a><span id="l75.322">     switch (*s) {</span>
<a href="#l75.323"></a><span id="l75.323">       case '*':</span>
<a href="#l75.324"></a><span id="l75.324">         return s;</span>
<a href="#l75.325"></a><span id="l75.325">       case '\\':</span>
<a href="#l75.326"></a><span id="l75.326">         ++s;</span>
<a href="#l75.327"></a><span id="l75.327">         if (hexchar2int(s[0]) &gt;= 0 &amp;&amp; hexchar2int(s[1]) &gt;= 0) ++s;</span>
<a href="#l75.328"></a><span id="l75.328">       default:</span>
<a href="#l75.329"></a><span id="l75.329">         break;</span>
<a href="#l75.330"></a><span id="l75.330">     }</span>
<a href="#l75.331"></a><span id="l75.331">   }</span>
<a href="#l75.332"></a><span id="l75.332">   return NULL;</span>
<a href="#l75.333"></a><span id="l75.333"> }</span>
<a href="#l75.334"></a><span id="l75.334"> </span>
<a href="#l75.335"></a><span id="l75.335" class="difflineminus">-static int put_simple_filter(BerElement *ber, char *str) {</span>
<a href="#l75.336"></a><span id="l75.336" class="difflineplus">+static int put_simple_filter(BerElement* ber, char* str) {</span>
<a href="#l75.337"></a><span id="l75.337">   char *s, *s2, *s3, filterop;</span>
<a href="#l75.338"></a><span id="l75.338" class="difflineminus">-  char *value;</span>
<a href="#l75.339"></a><span id="l75.339" class="difflineplus">+  char* value;</span>
<a href="#l75.340"></a><span id="l75.340">   unsigned long ftype;</span>
<a href="#l75.341"></a><span id="l75.341">   int rc, len;</span>
<a href="#l75.342"></a><span id="l75.342" class="difflineminus">-  char *oid;  /* for v3 extended filter */</span>
<a href="#l75.343"></a><span id="l75.343" class="difflineplus">+  char* oid;  /* for v3 extended filter */</span>
<a href="#l75.344"></a><span id="l75.344">   int dnattr; /* for v3 extended filter */</span>
<a href="#l75.345"></a><span id="l75.345"> </span>
<a href="#l75.346"></a><span id="l75.346">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;put_simple_filter \&quot;%s\&quot;\n&quot;, str, 0, 0);</span>
<a href="#l75.347"></a><span id="l75.347"> </span>
<a href="#l75.348"></a><span id="l75.348">   rc = -1; /* pessimistic */</span>
<a href="#l75.349"></a><span id="l75.349"> </span>
<a href="#l75.350"></a><span id="l75.350">   if ((str = nsldapi_strdup(str)) == NULL) {</span>
<a href="#l75.351"></a><span id="l75.351">     return (rc);</span>
<a href="#l75.352"></a><span id="l75.352" class="difflineat">@@ -708,17 +708,17 @@ free_and_return:</span>
<a href="#l75.353"></a><span id="l75.353"> /*</span>
<a href="#l75.354"></a><span id="l75.354">  * Undo in place both LDAPv2 (RFC-1960) and LDAPv3 (hexadecimal) escape</span>
<a href="#l75.355"></a><span id="l75.355">  * sequences within the null-terminated string 'val'.  The resulting value</span>
<a href="#l75.356"></a><span id="l75.356">  * may contain null characters.</span>
<a href="#l75.357"></a><span id="l75.357">  *</span>
<a href="#l75.358"></a><span id="l75.358">  * If 'val' contains invalid escape sequences we return -1.</span>
<a href="#l75.359"></a><span id="l75.359">  * Otherwise the length of the unescaped value is returned.</span>
<a href="#l75.360"></a><span id="l75.360">  */</span>
<a href="#l75.361"></a><span id="l75.361" class="difflineminus">-static int unescape_filterval(char *val) {</span>
<a href="#l75.362"></a><span id="l75.362" class="difflineplus">+static int unescape_filterval(char* val) {</span>
<a href="#l75.363"></a><span id="l75.363">   int escape, firstdigit, ival;</span>
<a href="#l75.364"></a><span id="l75.364">   char *s, *d;</span>
<a href="#l75.365"></a><span id="l75.365"> </span>
<a href="#l75.366"></a><span id="l75.366">   escape = firstdigit = 0;</span>
<a href="#l75.367"></a><span id="l75.367">   for (s = d = val; *s; s++) {</span>
<a href="#l75.368"></a><span id="l75.368">     if (escape) {</span>
<a href="#l75.369"></a><span id="l75.369">       /*</span>
<a href="#l75.370"></a><span id="l75.370">        * first try LDAPv3 escape (hexadecimal) sequence</span>
<a href="#l75.371"></a><span id="l75.371" class="difflineat">@@ -768,17 +768,17 @@ static int hexchar2int(char c) {</span>
<a href="#l75.372"></a><span id="l75.372">     return (c - 'A' + 10);</span>
<a href="#l75.373"></a><span id="l75.373">   }</span>
<a href="#l75.374"></a><span id="l75.374">   if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') {</span>
<a href="#l75.375"></a><span id="l75.375">     return (c - 'a' + 10);</span>
<a href="#l75.376"></a><span id="l75.376">   }</span>
<a href="#l75.377"></a><span id="l75.377">   return (-1);</span>
<a href="#l75.378"></a><span id="l75.378"> }</span>
<a href="#l75.379"></a><span id="l75.379"> </span>
<a href="#l75.380"></a><span id="l75.380" class="difflineminus">-static int put_substring_filter(BerElement *ber, char *type, char *val) {</span>
<a href="#l75.381"></a><span id="l75.381" class="difflineplus">+static int put_substring_filter(BerElement* ber, char* type, char* val) {</span>
<a href="#l75.382"></a><span id="l75.382">   char *nextstar, gotstar = 0;</span>
<a href="#l75.383"></a><span id="l75.383">   unsigned long ftype;</span>
<a href="#l75.384"></a><span id="l75.384">   int len;</span>
<a href="#l75.385"></a><span id="l75.385"> </span>
<a href="#l75.386"></a><span id="l75.386">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;put_substring_filter \&quot;%s=%s\&quot;\n&quot;, type, val, 0);</span>
<a href="#l75.387"></a><span id="l75.387"> </span>
<a href="#l75.388"></a><span id="l75.388">   if (ber_printf(ber, &quot;t{s{&quot;, LDAP_FILTER_SUBSTRINGS, type) == -1) {</span>
<a href="#l75.389"></a><span id="l75.389">     return (-1);</span>
<a href="#l75.390"></a><span id="l75.390" class="difflineat">@@ -808,49 +808,49 @@ static int put_substring_filter(BerEleme</span>
<a href="#l75.391"></a><span id="l75.391"> </span>
<a href="#l75.392"></a><span id="l75.392">   if (ber_printf(ber, &quot;}}&quot;) == -1) {</span>
<a href="#l75.393"></a><span id="l75.393">     return (-1);</span>
<a href="#l75.394"></a><span id="l75.394">   }</span>
<a href="#l75.395"></a><span id="l75.395"> </span>
<a href="#l75.396"></a><span id="l75.396">   return (0);</span>
<a href="#l75.397"></a><span id="l75.397"> }</span>
<a href="#l75.398"></a><span id="l75.398"> </span>
<a href="#l75.399"></a><span id="l75.399" class="difflineminus">-int LDAP_CALL ldap_search_st(LDAP *ld, const char *base, int scope,</span>
<a href="#l75.400"></a><span id="l75.400" class="difflineminus">-                             const char *filter, char **attrs, int attrsonly,</span>
<a href="#l75.401"></a><span id="l75.401" class="difflineminus">-                             struct timeval *timeout, LDAPMessage **res) {</span>
<a href="#l75.402"></a><span id="l75.402" class="difflineplus">+int LDAP_CALL ldap_search_st(LDAP* ld, const char* base, int scope,</span>
<a href="#l75.403"></a><span id="l75.403" class="difflineplus">+                             const char* filter, char** attrs, int attrsonly,</span>
<a href="#l75.404"></a><span id="l75.404" class="difflineplus">+                             struct timeval* timeout, LDAPMessage** res) {</span>
<a href="#l75.405"></a><span id="l75.405">   return (nsldapi_search_s(ld, base, scope, filter, attrs, attrsonly, NULL,</span>
<a href="#l75.406"></a><span id="l75.406">                            NULL, timeout, -1, -1, res));</span>
<a href="#l75.407"></a><span id="l75.407"> }</span>
<a href="#l75.408"></a><span id="l75.408"> </span>
<a href="#l75.409"></a><span id="l75.409" class="difflineminus">-int LDAP_CALL ldap_search_s(LDAP *ld, const char *base, int scope,</span>
<a href="#l75.410"></a><span id="l75.410" class="difflineminus">-                            const char *filter, char **attrs, int attrsonly,</span>
<a href="#l75.411"></a><span id="l75.411" class="difflineminus">-                            LDAPMessage **res) {</span>
<a href="#l75.412"></a><span id="l75.412" class="difflineplus">+int LDAP_CALL ldap_search_s(LDAP* ld, const char* base, int scope,</span>
<a href="#l75.413"></a><span id="l75.413" class="difflineplus">+                            const char* filter, char** attrs, int attrsonly,</span>
<a href="#l75.414"></a><span id="l75.414" class="difflineplus">+                            LDAPMessage** res) {</span>
<a href="#l75.415"></a><span id="l75.415">   return (nsldapi_search_s(ld, base, scope, filter, attrs, attrsonly, NULL,</span>
<a href="#l75.416"></a><span id="l75.416">                            NULL, NULL, -1, -1, res));</span>
<a href="#l75.417"></a><span id="l75.417"> }</span>
<a href="#l75.418"></a><span id="l75.418"> </span>
<a href="#l75.419"></a><span id="l75.419" class="difflineminus">-int LDAP_CALL ldap_search_ext_s(LDAP *ld, const char *base, int scope,</span>
<a href="#l75.420"></a><span id="l75.420" class="difflineminus">-                                const char *filter, char **attrs, int attrsonly,</span>
<a href="#l75.421"></a><span id="l75.421" class="difflineminus">-                                LDAPControl **serverctrls,</span>
<a href="#l75.422"></a><span id="l75.422" class="difflineminus">-                                LDAPControl **clientctrls,</span>
<a href="#l75.423"></a><span id="l75.423" class="difflineminus">-                                struct timeval *timeoutp, int sizelimit,</span>
<a href="#l75.424"></a><span id="l75.424" class="difflineminus">-                                LDAPMessage **res) {</span>
<a href="#l75.425"></a><span id="l75.425" class="difflineplus">+int LDAP_CALL ldap_search_ext_s(LDAP* ld, const char* base, int scope,</span>
<a href="#l75.426"></a><span id="l75.426" class="difflineplus">+                                const char* filter, char** attrs, int attrsonly,</span>
<a href="#l75.427"></a><span id="l75.427" class="difflineplus">+                                LDAPControl** serverctrls,</span>
<a href="#l75.428"></a><span id="l75.428" class="difflineplus">+                                LDAPControl** clientctrls,</span>
<a href="#l75.429"></a><span id="l75.429" class="difflineplus">+                                struct timeval* timeoutp, int sizelimit,</span>
<a href="#l75.430"></a><span id="l75.430" class="difflineplus">+                                LDAPMessage** res) {</span>
<a href="#l75.431"></a><span id="l75.431">   return (nsldapi_search_s(</span>
<a href="#l75.432"></a><span id="l75.432">       ld, base, scope, filter, attrs, attrsonly, serverctrls, clientctrls,</span>
<a href="#l75.433"></a><span id="l75.433">       timeoutp, nsldapi_timeval2ldaplimit(timeoutp, -1), sizelimit, res));</span>
<a href="#l75.434"></a><span id="l75.434"> }</span>
<a href="#l75.435"></a><span id="l75.435"> </span>
<a href="#l75.436"></a><span id="l75.436" class="difflineminus">-static int nsldapi_search_s(LDAP *ld, const char *base, int scope,</span>
<a href="#l75.437"></a><span id="l75.437" class="difflineminus">-                            const char *filter, char **attrs, int attrsonly,</span>
<a href="#l75.438"></a><span id="l75.438" class="difflineminus">-                            LDAPControl **serverctrls,</span>
<a href="#l75.439"></a><span id="l75.439" class="difflineminus">-                            LDAPControl **clientctrls,</span>
<a href="#l75.440"></a><span id="l75.440" class="difflineminus">-                            struct timeval *localtimeoutp,</span>
<a href="#l75.441"></a><span id="l75.441" class="difflineplus">+static int nsldapi_search_s(LDAP* ld, const char* base, int scope,</span>
<a href="#l75.442"></a><span id="l75.442" class="difflineplus">+                            const char* filter, char** attrs, int attrsonly,</span>
<a href="#l75.443"></a><span id="l75.443" class="difflineplus">+                            LDAPControl** serverctrls,</span>
<a href="#l75.444"></a><span id="l75.444" class="difflineplus">+                            LDAPControl** clientctrls,</span>
<a href="#l75.445"></a><span id="l75.445" class="difflineplus">+                            struct timeval* localtimeoutp,</span>
<a href="#l75.446"></a><span id="l75.446">                             int timelimit, /* -1 means use ld-&gt;ld_timelimit */</span>
<a href="#l75.447"></a><span id="l75.447">                             int sizelimit, /* -1 means use ld-&gt;ld_sizelimit */</span>
<a href="#l75.448"></a><span id="l75.448" class="difflineminus">-                            LDAPMessage **res) {</span>
<a href="#l75.449"></a><span id="l75.449" class="difflineplus">+                            LDAPMessage** res) {</span>
<a href="#l75.450"></a><span id="l75.450">   int err, msgid;</span>
<a href="#l75.451"></a><span id="l75.451"> </span>
<a href="#l75.452"></a><span id="l75.452">   /*</span>
<a href="#l75.453"></a><span id="l75.453">    * It is an error to pass in a zero'd timeval.</span>
<a href="#l75.454"></a><span id="l75.454">    */</span>
<a href="#l75.455"></a><span id="l75.455">   if (localtimeoutp != NULL &amp;&amp; localtimeoutp-&gt;tv_sec == 0 &amp;&amp;</span>
<a href="#l75.456"></a><span id="l75.456">       localtimeoutp-&gt;tv_usec == 0) {</span>
<a href="#l75.457"></a><span id="l75.457">     if (ld != NULL) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l76.1"></a><span id="l76.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/setoption.c</span>
<a href="#l76.2"></a><span id="l76.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/setoption.c</span>
<a href="#l76.3"></a><span id="l76.3" class="difflineat">@@ -42,17 +42,17 @@</span>
<a href="#l76.4"></a><span id="l76.4"> </span>
<a href="#l76.5"></a><span id="l76.5"> #define LDAP_SETCLR_BITOPT(ld, bit, optdata) \</span>
<a href="#l76.6"></a><span id="l76.6">   if (optdata != NULL) {                     \</span>
<a href="#l76.7"></a><span id="l76.7">     (ld)-&gt;ld_options |= bit;                 \</span>
<a href="#l76.8"></a><span id="l76.8">   } else {                                   \</span>
<a href="#l76.9"></a><span id="l76.9">     (ld)-&gt;ld_options &amp;= ~bit;                \</span>
<a href="#l76.10"></a><span id="l76.10">   }</span>
<a href="#l76.11"></a><span id="l76.11"> </span>
<a href="#l76.12"></a><span id="l76.12" class="difflineminus">-int LDAP_CALL ldap_set_option(LDAP *ld, int option, const void *optdata) {</span>
<a href="#l76.13"></a><span id="l76.13" class="difflineplus">+int LDAP_CALL ldap_set_option(LDAP* ld, int option, const void* optdata) {</span>
<a href="#l76.14"></a><span id="l76.14">   int rc, i;</span>
<a href="#l76.15"></a><span id="l76.15">   char *matched, *errstr;</span>
<a href="#l76.16"></a><span id="l76.16"> </span>
<a href="#l76.17"></a><span id="l76.17">   /*</span>
<a href="#l76.18"></a><span id="l76.18">    * if ld is NULL, arrange to modify our default settings</span>
<a href="#l76.19"></a><span id="l76.19">    */</span>
<a href="#l76.20"></a><span id="l76.20">   if (ld == NULL) {</span>
<a href="#l76.21"></a><span id="l76.21">     if (!nsldapi_initialized) {</span>
<a href="#l76.22"></a><span id="l76.22" class="difflineat">@@ -63,17 +63,17 @@ int LDAP_CALL ldap_set_option(LDAP *ld, </span>
<a href="#l76.23"></a><span id="l76.23"> </span>
<a href="#l76.24"></a><span id="l76.24">   /*</span>
<a href="#l76.25"></a><span id="l76.25">    * process global options (not associated with an LDAP session handle)</span>
<a href="#l76.26"></a><span id="l76.26">    */</span>
<a href="#l76.27"></a><span id="l76.27">   if (option == LDAP_OPT_MEMALLOC_FN_PTRS) {</span>
<a href="#l76.28"></a><span id="l76.28">     struct lber_memalloc_fns memalloc_fns;</span>
<a href="#l76.29"></a><span id="l76.29"> </span>
<a href="#l76.30"></a><span id="l76.30">     /* set libldap ones via a struct copy */</span>
<a href="#l76.31"></a><span id="l76.31" class="difflineminus">-    nsldapi_memalloc_fns = *((struct ldap_memalloc_fns *)optdata);</span>
<a href="#l76.32"></a><span id="l76.32" class="difflineplus">+    nsldapi_memalloc_fns = *((struct ldap_memalloc_fns*)optdata);</span>
<a href="#l76.33"></a><span id="l76.33"> </span>
<a href="#l76.34"></a><span id="l76.34">     /* also set liblber memory allocation callbacks */</span>
<a href="#l76.35"></a><span id="l76.35">     memalloc_fns.lbermem_malloc = nsldapi_memalloc_fns.ldapmem_malloc;</span>
<a href="#l76.36"></a><span id="l76.36">     memalloc_fns.lbermem_calloc = nsldapi_memalloc_fns.ldapmem_calloc;</span>
<a href="#l76.37"></a><span id="l76.37">     memalloc_fns.lbermem_realloc = nsldapi_memalloc_fns.ldapmem_realloc;</span>
<a href="#l76.38"></a><span id="l76.38">     memalloc_fns.lbermem_free = nsldapi_memalloc_fns.ldapmem_free;</span>
<a href="#l76.39"></a><span id="l76.39">     if (ber_set_option(NULL, LBER_OPT_MEMALLOC_FN_PTRS, &amp;memalloc_fns) != 0) {</span>
<a href="#l76.40"></a><span id="l76.40">       return (-1);</span>
<a href="#l76.41"></a><span id="l76.41" class="difflineat">@@ -81,17 +81,17 @@ int LDAP_CALL ldap_set_option(LDAP *ld, </span>
<a href="#l76.42"></a><span id="l76.42"> </span>
<a href="#l76.43"></a><span id="l76.43">     return (0);</span>
<a href="#l76.44"></a><span id="l76.44">   }</span>
<a href="#l76.45"></a><span id="l76.45">   /*</span>
<a href="#l76.46"></a><span id="l76.46">    * LDAP_OPT_DEBUG_LEVEL is global</span>
<a href="#l76.47"></a><span id="l76.47">    */</span>
<a href="#l76.48"></a><span id="l76.48">   if (LDAP_OPT_DEBUG_LEVEL == option) {</span>
<a href="#l76.49"></a><span id="l76.49"> #ifdef LDAP_DEBUG</span>
<a href="#l76.50"></a><span id="l76.50" class="difflineminus">-    ldap_debug = *((int *)optdata);</span>
<a href="#l76.51"></a><span id="l76.51" class="difflineplus">+    ldap_debug = *((int*)optdata);</span>
<a href="#l76.52"></a><span id="l76.52"> #endif</span>
<a href="#l76.53"></a><span id="l76.53">     return 0;</span>
<a href="#l76.54"></a><span id="l76.54">   }</span>
<a href="#l76.55"></a><span id="l76.55"> </span>
<a href="#l76.56"></a><span id="l76.56">   /*</span>
<a href="#l76.57"></a><span id="l76.57">    * process options that are associated with an LDAP session handle</span>
<a href="#l76.58"></a><span id="l76.58">    */</span>
<a href="#l76.59"></a><span id="l76.59">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l76.60"></a><span id="l76.60" class="difflineat">@@ -134,258 +134,258 @@ int LDAP_CALL ldap_set_option(LDAP *ld, </span>
<a href="#l76.61"></a><span id="l76.61"> #ifdef LDAP_ASYNC_IO</span>
<a href="#l76.62"></a><span id="l76.62">     case LDAP_OPT_ASYNC_CONNECT:</span>
<a href="#l76.63"></a><span id="l76.63">       LDAP_SETCLR_BITOPT(ld, LDAP_BITOPT_ASYNC, optdata);</span>
<a href="#l76.64"></a><span id="l76.64">       break;</span>
<a href="#l76.65"></a><span id="l76.65"> #endif /* LDAP_ASYNC_IO */</span>
<a href="#l76.66"></a><span id="l76.66"> </span>
<a href="#l76.67"></a><span id="l76.67">     /* fields in the LDAP structure */</span>
<a href="#l76.68"></a><span id="l76.68">     case LDAP_OPT_DEREF:</span>
<a href="#l76.69"></a><span id="l76.69" class="difflineminus">-      ld-&gt;ld_deref = *((int *)optdata);</span>
<a href="#l76.70"></a><span id="l76.70" class="difflineplus">+      ld-&gt;ld_deref = *((int*)optdata);</span>
<a href="#l76.71"></a><span id="l76.71">       break;</span>
<a href="#l76.72"></a><span id="l76.72">     case LDAP_OPT_SIZELIMIT:</span>
<a href="#l76.73"></a><span id="l76.73" class="difflineminus">-      ld-&gt;ld_sizelimit = *((int *)optdata);</span>
<a href="#l76.74"></a><span id="l76.74" class="difflineplus">+      ld-&gt;ld_sizelimit = *((int*)optdata);</span>
<a href="#l76.75"></a><span id="l76.75">       break;</span>
<a href="#l76.76"></a><span id="l76.76">     case LDAP_OPT_TIMELIMIT:</span>
<a href="#l76.77"></a><span id="l76.77" class="difflineminus">-      ld-&gt;ld_timelimit = *((int *)optdata);</span>
<a href="#l76.78"></a><span id="l76.78" class="difflineplus">+      ld-&gt;ld_timelimit = *((int*)optdata);</span>
<a href="#l76.79"></a><span id="l76.79">       break;</span>
<a href="#l76.80"></a><span id="l76.80">     case LDAP_OPT_REFERRAL_HOP_LIMIT:</span>
<a href="#l76.81"></a><span id="l76.81" class="difflineminus">-      ld-&gt;ld_refhoplimit = *((int *)optdata);</span>
<a href="#l76.82"></a><span id="l76.82" class="difflineplus">+      ld-&gt;ld_refhoplimit = *((int*)optdata);</span>
<a href="#l76.83"></a><span id="l76.83">       break;</span>
<a href="#l76.84"></a><span id="l76.84">     case LDAP_OPT_PROTOCOL_VERSION:</span>
<a href="#l76.85"></a><span id="l76.85" class="difflineminus">-      ld-&gt;ld_version = *((int *)optdata);</span>
<a href="#l76.86"></a><span id="l76.86" class="difflineplus">+      ld-&gt;ld_version = *((int*)optdata);</span>
<a href="#l76.87"></a><span id="l76.87">       if (ld-&gt;ld_defconn != NULL) { /* also set in default conn. */</span>
<a href="#l76.88"></a><span id="l76.88">         ld-&gt;ld_defconn-&gt;lconn_version = ld-&gt;ld_version;</span>
<a href="#l76.89"></a><span id="l76.89">       }</span>
<a href="#l76.90"></a><span id="l76.90">       break;</span>
<a href="#l76.91"></a><span id="l76.91">     case LDAP_OPT_SERVER_CONTROLS:</span>
<a href="#l76.92"></a><span id="l76.92">       /* nsldapi_dup_controls returns -1 and sets lderrno on error */</span>
<a href="#l76.93"></a><span id="l76.93">       rc = nsldapi_dup_controls(ld, &amp;ld-&gt;ld_servercontrols,</span>
<a href="#l76.94"></a><span id="l76.94" class="difflineminus">-                                (LDAPControl **)optdata);</span>
<a href="#l76.95"></a><span id="l76.95" class="difflineplus">+                                (LDAPControl**)optdata);</span>
<a href="#l76.96"></a><span id="l76.96">       break;</span>
<a href="#l76.97"></a><span id="l76.97">     case LDAP_OPT_CLIENT_CONTROLS:</span>
<a href="#l76.98"></a><span id="l76.98">       /* nsldapi_dup_controls returns -1 and sets lderrno on error */</span>
<a href="#l76.99"></a><span id="l76.99">       rc = nsldapi_dup_controls(ld, &amp;ld-&gt;ld_clientcontrols,</span>
<a href="#l76.100"></a><span id="l76.100" class="difflineminus">-                                (LDAPControl **)optdata);</span>
<a href="#l76.101"></a><span id="l76.101" class="difflineplus">+                                (LDAPControl**)optdata);</span>
<a href="#l76.102"></a><span id="l76.102">       break;</span>
<a href="#l76.103"></a><span id="l76.103"> </span>
<a href="#l76.104"></a><span id="l76.104">     /* rebind proc */</span>
<a href="#l76.105"></a><span id="l76.105">     case LDAP_OPT_REBIND_FN:</span>
<a href="#l76.106"></a><span id="l76.106" class="difflineminus">-      ld-&gt;ld_rebind_fn = (LDAP_REBINDPROC_CALLBACK *)optdata;</span>
<a href="#l76.107"></a><span id="l76.107" class="difflineplus">+      ld-&gt;ld_rebind_fn = (LDAP_REBINDPROC_CALLBACK*)optdata;</span>
<a href="#l76.108"></a><span id="l76.108">       break;</span>
<a href="#l76.109"></a><span id="l76.109">     case LDAP_OPT_REBIND_ARG:</span>
<a href="#l76.110"></a><span id="l76.110" class="difflineminus">-      ld-&gt;ld_rebind_arg = (void *)optdata;</span>
<a href="#l76.111"></a><span id="l76.111" class="difflineplus">+      ld-&gt;ld_rebind_arg = (void*)optdata;</span>
<a href="#l76.112"></a><span id="l76.112">       break;</span>
<a href="#l76.113"></a><span id="l76.113"> </span>
<a href="#l76.114"></a><span id="l76.114">     /* i/o function pointers */</span>
<a href="#l76.115"></a><span id="l76.115">     case LDAP_OPT_IO_FN_PTRS:</span>
<a href="#l76.116"></a><span id="l76.116">       if ((rc = nsldapi_install_compat_io_fns(</span>
<a href="#l76.117"></a><span id="l76.117" class="difflineminus">-               ld, (struct ldap_io_fns *)optdata)) != LDAP_SUCCESS) {</span>
<a href="#l76.118"></a><span id="l76.118" class="difflineplus">+               ld, (struct ldap_io_fns*)optdata)) != LDAP_SUCCESS) {</span>
<a href="#l76.119"></a><span id="l76.119">         LDAP_SET_LDERRNO(ld, rc, NULL, NULL);</span>
<a href="#l76.120"></a><span id="l76.120">         rc = -1;</span>
<a href="#l76.121"></a><span id="l76.121">       }</span>
<a href="#l76.122"></a><span id="l76.122">       break;</span>
<a href="#l76.123"></a><span id="l76.123"> </span>
<a href="#l76.124"></a><span id="l76.124">     /* extended i/o function pointers */</span>
<a href="#l76.125"></a><span id="l76.125">     case LDAP_X_OPT_EXTIO_FN_PTRS:</span>
<a href="#l76.126"></a><span id="l76.126">       /* denotes use of old iofns struct (no writev) */</span>
<a href="#l76.127"></a><span id="l76.127" class="difflineminus">-      if (((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_size ==</span>
<a href="#l76.128"></a><span id="l76.128" class="difflineplus">+      if (((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_size ==</span>
<a href="#l76.129"></a><span id="l76.129">           LDAP_X_EXTIO_FNS_SIZE_REV0) {</span>
<a href="#l76.130"></a><span id="l76.130">         ld-&gt;ld_extio_size = LDAP_X_EXTIO_FNS_SIZE;</span>
<a href="#l76.131"></a><span id="l76.131">         ld-&gt;ld_extclose_fn =</span>
<a href="#l76.132"></a><span id="l76.132" class="difflineminus">-            ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_close;</span>
<a href="#l76.133"></a><span id="l76.133" class="difflineplus">+            ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_close;</span>
<a href="#l76.134"></a><span id="l76.134">         ld-&gt;ld_extconnect_fn =</span>
<a href="#l76.135"></a><span id="l76.135" class="difflineminus">-            ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_connect;</span>
<a href="#l76.136"></a><span id="l76.136" class="difflineplus">+            ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_connect;</span>
<a href="#l76.137"></a><span id="l76.137">         ld-&gt;ld_extread_fn =</span>
<a href="#l76.138"></a><span id="l76.138" class="difflineminus">-            ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_read;</span>
<a href="#l76.139"></a><span id="l76.139" class="difflineplus">+            ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_read;</span>
<a href="#l76.140"></a><span id="l76.140">         ld-&gt;ld_extwrite_fn =</span>
<a href="#l76.141"></a><span id="l76.141" class="difflineminus">-            ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_write;</span>
<a href="#l76.142"></a><span id="l76.142" class="difflineplus">+            ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_write;</span>
<a href="#l76.143"></a><span id="l76.143">         ld-&gt;ld_extpoll_fn =</span>
<a href="#l76.144"></a><span id="l76.144" class="difflineminus">-            ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_poll;</span>
<a href="#l76.145"></a><span id="l76.145" class="difflineplus">+            ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_poll;</span>
<a href="#l76.146"></a><span id="l76.146">         ld-&gt;ld_extnewhandle_fn =</span>
<a href="#l76.147"></a><span id="l76.147" class="difflineminus">-            ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_newhandle;</span>
<a href="#l76.148"></a><span id="l76.148" class="difflineplus">+            ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_newhandle;</span>
<a href="#l76.149"></a><span id="l76.149">         ld-&gt;ld_extdisposehandle_fn =</span>
<a href="#l76.150"></a><span id="l76.150" class="difflineminus">-            ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_disposehandle;</span>
<a href="#l76.151"></a><span id="l76.151" class="difflineplus">+            ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_disposehandle;</span>
<a href="#l76.152"></a><span id="l76.152">         ld-&gt;ld_ext_session_arg =</span>
<a href="#l76.153"></a><span id="l76.153" class="difflineminus">-            ((struct ldap_x_ext_io_fns_rev0 *)optdata)-&gt;lextiof_session_arg;</span>
<a href="#l76.154"></a><span id="l76.154" class="difflineplus">+            ((struct ldap_x_ext_io_fns_rev0*)optdata)-&gt;lextiof_session_arg;</span>
<a href="#l76.155"></a><span id="l76.155">         ld-&gt;ld_extwritev_fn = NULL;</span>
<a href="#l76.156"></a><span id="l76.156">         if (ber_sockbuf_set_option(ld-&gt;ld_sbp, LBER_SOCKBUF_OPT_EXT_IO_FNS,</span>
<a href="#l76.157"></a><span id="l76.157">                                    &amp;(ld-&gt;ld_ext_io_fns)) != 0) {</span>
<a href="#l76.158"></a><span id="l76.158">           LDAP_SET_LDERRNO(ld, LDAP_LOCAL_ERROR, NULL, NULL);</span>
<a href="#l76.159"></a><span id="l76.159">           rc = -1;</span>
<a href="#l76.160"></a><span id="l76.160">           break;</span>
<a href="#l76.161"></a><span id="l76.161">         }</span>
<a href="#l76.162"></a><span id="l76.162">       } else {</span>
<a href="#l76.163"></a><span id="l76.163">         /* struct copy */</span>
<a href="#l76.164"></a><span id="l76.164" class="difflineminus">-        ld-&gt;ld_ext_io_fns = *((struct ldap_x_ext_io_fns *)optdata);</span>
<a href="#l76.165"></a><span id="l76.165" class="difflineplus">+        ld-&gt;ld_ext_io_fns = *((struct ldap_x_ext_io_fns*)optdata);</span>
<a href="#l76.166"></a><span id="l76.166">       }</span>
<a href="#l76.167"></a><span id="l76.167">       if ((rc = nsldapi_install_lber_extiofns(ld, ld-&gt;ld_sbp)) !=</span>
<a href="#l76.168"></a><span id="l76.168">           LDAP_SUCCESS) {</span>
<a href="#l76.169"></a><span id="l76.169">         LDAP_SET_LDERRNO(ld, rc, NULL, NULL);</span>
<a href="#l76.170"></a><span id="l76.170">         rc = -1;</span>
<a href="#l76.171"></a><span id="l76.171">       }</span>
<a href="#l76.172"></a><span id="l76.172">       break;</span>
<a href="#l76.173"></a><span id="l76.173"> </span>
<a href="#l76.174"></a><span id="l76.174">       /* set Socket Arg in extended socket i/o functions*/</span>
<a href="#l76.175"></a><span id="l76.175">     case LDAP_X_OPT_SOCKETARG:</span>
<a href="#l76.176"></a><span id="l76.176">       if (ber_sockbuf_set_option(ld-&gt;ld_sbp, LBER_SOCKBUF_OPT_SOCK_ARG,</span>
<a href="#l76.177"></a><span id="l76.177" class="difflineminus">-                                 (void *)optdata) != 0) {</span>
<a href="#l76.178"></a><span id="l76.178" class="difflineplus">+                                 (void*)optdata) != 0) {</span>
<a href="#l76.179"></a><span id="l76.179">         LDAP_SET_LDERRNO(ld, LDAP_LOCAL_ERROR, NULL, NULL);</span>
<a href="#l76.180"></a><span id="l76.180">         rc = -1;</span>
<a href="#l76.181"></a><span id="l76.181">       }</span>
<a href="#l76.182"></a><span id="l76.182"> </span>
<a href="#l76.183"></a><span id="l76.183">       break;</span>
<a href="#l76.184"></a><span id="l76.184"> </span>
<a href="#l76.185"></a><span id="l76.185">     /* thread function pointers */</span>
<a href="#l76.186"></a><span id="l76.186">     case LDAP_OPT_THREAD_FN_PTRS:</span>
<a href="#l76.187"></a><span id="l76.187">       /*</span>
<a href="#l76.188"></a><span id="l76.188">        * It is only safe to set the thread function pointers</span>
<a href="#l76.189"></a><span id="l76.189">        * when one thread is using the LDAP session handle.</span>
<a href="#l76.190"></a><span id="l76.190">        */</span>
<a href="#l76.191"></a><span id="l76.191">       /* free existing mutexes (some are allocated by ldap_init()) */</span>
<a href="#l76.192"></a><span id="l76.192">       nsldapi_mutex_free_all(ld);</span>
<a href="#l76.193"></a><span id="l76.193"> </span>
<a href="#l76.194"></a><span id="l76.194">       /* struct copy */</span>
<a href="#l76.195"></a><span id="l76.195" class="difflineminus">-      ld-&gt;ld_thread = *((struct ldap_thread_fns *)optdata);</span>
<a href="#l76.196"></a><span id="l76.196" class="difflineplus">+      ld-&gt;ld_thread = *((struct ldap_thread_fns*)optdata);</span>
<a href="#l76.197"></a><span id="l76.197"> </span>
<a href="#l76.198"></a><span id="l76.198">       /* allocate new mutexes */</span>
<a href="#l76.199"></a><span id="l76.199">       nsldapi_mutex_alloc_all(ld);</span>
<a href="#l76.200"></a><span id="l76.200"> </span>
<a href="#l76.201"></a><span id="l76.201">       /* LDAP_OPTION_LOCK was never locked... so just return */</span>
<a href="#l76.202"></a><span id="l76.202">       return (rc);</span>
<a href="#l76.203"></a><span id="l76.203"> </span>
<a href="#l76.204"></a><span id="l76.204">     /* extra thread function pointers */</span>
<a href="#l76.205"></a><span id="l76.205">     case LDAP_OPT_EXTRA_THREAD_FN_PTRS:</span>
<a href="#l76.206"></a><span id="l76.206">       /* The extra thread funcs will only pick up the threadid */</span>
<a href="#l76.207"></a><span id="l76.207" class="difflineminus">-      ld-&gt;ld_thread2 = *((struct ldap_extra_thread_fns *)optdata);</span>
<a href="#l76.208"></a><span id="l76.208" class="difflineplus">+      ld-&gt;ld_thread2 = *((struct ldap_extra_thread_fns*)optdata);</span>
<a href="#l76.209"></a><span id="l76.209"> </span>
<a href="#l76.210"></a><span id="l76.210">       /* Reset the rest of the structure preserving the threadid fn */</span>
<a href="#l76.211"></a><span id="l76.211" class="difflineminus">-      ld-&gt;ld_mutex_trylock_fn = (LDAP_TF_MUTEX_TRYLOCK_CALLBACK *)NULL;</span>
<a href="#l76.212"></a><span id="l76.212" class="difflineminus">-      ld-&gt;ld_sema_alloc_fn = (LDAP_TF_SEMA_ALLOC_CALLBACK *)NULL;</span>
<a href="#l76.213"></a><span id="l76.213" class="difflineminus">-      ld-&gt;ld_sema_free_fn = (LDAP_TF_SEMA_FREE_CALLBACK *)NULL;</span>
<a href="#l76.214"></a><span id="l76.214" class="difflineminus">-      ld-&gt;ld_sema_wait_fn = (LDAP_TF_SEMA_WAIT_CALLBACK *)NULL;</span>
<a href="#l76.215"></a><span id="l76.215" class="difflineminus">-      ld-&gt;ld_sema_post_fn = (LDAP_TF_SEMA_POST_CALLBACK *)NULL;</span>
<a href="#l76.216"></a><span id="l76.216" class="difflineplus">+      ld-&gt;ld_mutex_trylock_fn = (LDAP_TF_MUTEX_TRYLOCK_CALLBACK*)NULL;</span>
<a href="#l76.217"></a><span id="l76.217" class="difflineplus">+      ld-&gt;ld_sema_alloc_fn = (LDAP_TF_SEMA_ALLOC_CALLBACK*)NULL;</span>
<a href="#l76.218"></a><span id="l76.218" class="difflineplus">+      ld-&gt;ld_sema_free_fn = (LDAP_TF_SEMA_FREE_CALLBACK*)NULL;</span>
<a href="#l76.219"></a><span id="l76.219" class="difflineplus">+      ld-&gt;ld_sema_wait_fn = (LDAP_TF_SEMA_WAIT_CALLBACK*)NULL;</span>
<a href="#l76.220"></a><span id="l76.220" class="difflineplus">+      ld-&gt;ld_sema_post_fn = (LDAP_TF_SEMA_POST_CALLBACK*)NULL;</span>
<a href="#l76.221"></a><span id="l76.221"> </span>
<a href="#l76.222"></a><span id="l76.222">       /* We assume that only one thread is active when replacing */</span>
<a href="#l76.223"></a><span id="l76.223">       /* the threadid function.  We will now proceed and reset all */</span>
<a href="#l76.224"></a><span id="l76.224">       /* of the threadid/refcounts */</span>
<a href="#l76.225"></a><span id="l76.225">       for (i = 0; i &lt; LDAP_MAX_LOCK; i++) {</span>
<a href="#l76.226"></a><span id="l76.226" class="difflineminus">-        ld-&gt;ld_mutex_threadid[i] = (void *)-1;</span>
<a href="#l76.227"></a><span id="l76.227" class="difflineplus">+        ld-&gt;ld_mutex_threadid[i] = (void*)-1;</span>
<a href="#l76.228"></a><span id="l76.228">         ld-&gt;ld_mutex_refcnt[i] = 0;</span>
<a href="#l76.229"></a><span id="l76.229">       }</span>
<a href="#l76.230"></a><span id="l76.230"> </span>
<a href="#l76.231"></a><span id="l76.231">       /* LDAP_OPTION_LOCK was never locked... so just return */</span>
<a href="#l76.232"></a><span id="l76.232">       return (rc);</span>
<a href="#l76.233"></a><span id="l76.233"> </span>
<a href="#l76.234"></a><span id="l76.234">     /* DNS function pointers */</span>
<a href="#l76.235"></a><span id="l76.235">     case LDAP_OPT_DNS_FN_PTRS:</span>
<a href="#l76.236"></a><span id="l76.236">       /* struct copy */</span>
<a href="#l76.237"></a><span id="l76.237" class="difflineminus">-      ld-&gt;ld_dnsfn = *((struct ldap_dns_fns *)optdata);</span>
<a href="#l76.238"></a><span id="l76.238" class="difflineplus">+      ld-&gt;ld_dnsfn = *((struct ldap_dns_fns*)optdata);</span>
<a href="#l76.239"></a><span id="l76.239">       break;</span>
<a href="#l76.240"></a><span id="l76.240"> </span>
<a href="#l76.241"></a><span id="l76.241">     /* cache function pointers */</span>
<a href="#l76.242"></a><span id="l76.242">     case LDAP_OPT_CACHE_FN_PTRS:</span>
<a href="#l76.243"></a><span id="l76.243">       /* struct copy */</span>
<a href="#l76.244"></a><span id="l76.244" class="difflineminus">-      ld-&gt;ld_cache = *((struct ldap_cache_fns *)optdata);</span>
<a href="#l76.245"></a><span id="l76.245" class="difflineplus">+      ld-&gt;ld_cache = *((struct ldap_cache_fns*)optdata);</span>
<a href="#l76.246"></a><span id="l76.246">       break;</span>
<a href="#l76.247"></a><span id="l76.247">     case LDAP_OPT_CACHE_STRATEGY:</span>
<a href="#l76.248"></a><span id="l76.248" class="difflineminus">-      ld-&gt;ld_cache_strategy = *((int *)optdata);</span>
<a href="#l76.249"></a><span id="l76.249" class="difflineplus">+      ld-&gt;ld_cache_strategy = *((int*)optdata);</span>
<a href="#l76.250"></a><span id="l76.250">       break;</span>
<a href="#l76.251"></a><span id="l76.251">     case LDAP_OPT_CACHE_ENABLE:</span>
<a href="#l76.252"></a><span id="l76.252" class="difflineminus">-      ld-&gt;ld_cache_on = *((int *)optdata);</span>
<a href="#l76.253"></a><span id="l76.253" class="difflineplus">+      ld-&gt;ld_cache_on = *((int*)optdata);</span>
<a href="#l76.254"></a><span id="l76.254">       break;</span>
<a href="#l76.255"></a><span id="l76.255"> </span>
<a href="#l76.256"></a><span id="l76.256">     case LDAP_OPT_ERROR_NUMBER:</span>
<a href="#l76.257"></a><span id="l76.257">       LDAP_GET_LDERRNO(ld, &amp;matched, &amp;errstr);</span>
<a href="#l76.258"></a><span id="l76.258">       matched = nsldapi_strdup(matched);</span>
<a href="#l76.259"></a><span id="l76.259">       errstr = nsldapi_strdup(errstr);</span>
<a href="#l76.260"></a><span id="l76.260" class="difflineminus">-      LDAP_SET_LDERRNO(ld, *((int *)optdata), matched, errstr);</span>
<a href="#l76.261"></a><span id="l76.261" class="difflineplus">+      LDAP_SET_LDERRNO(ld, *((int*)optdata), matched, errstr);</span>
<a href="#l76.262"></a><span id="l76.262">       break;</span>
<a href="#l76.263"></a><span id="l76.263"> </span>
<a href="#l76.264"></a><span id="l76.264">     case LDAP_OPT_ERROR_STRING:</span>
<a href="#l76.265"></a><span id="l76.265">       rc = LDAP_GET_LDERRNO(ld, &amp;matched, NULL);</span>
<a href="#l76.266"></a><span id="l76.266">       matched = nsldapi_strdup(matched);</span>
<a href="#l76.267"></a><span id="l76.267" class="difflineminus">-      LDAP_SET_LDERRNO(ld, rc, matched, nsldapi_strdup((char *)optdata));</span>
<a href="#l76.268"></a><span id="l76.268" class="difflineplus">+      LDAP_SET_LDERRNO(ld, rc, matched, nsldapi_strdup((char*)optdata));</span>
<a href="#l76.269"></a><span id="l76.269">       rc = LDAP_SUCCESS;</span>
<a href="#l76.270"></a><span id="l76.270">       break;</span>
<a href="#l76.271"></a><span id="l76.271"> </span>
<a href="#l76.272"></a><span id="l76.272">     case LDAP_OPT_MATCHED_DN:</span>
<a href="#l76.273"></a><span id="l76.273">       rc = LDAP_GET_LDERRNO(ld, NULL, &amp;errstr);</span>
<a href="#l76.274"></a><span id="l76.274">       errstr = nsldapi_strdup(errstr);</span>
<a href="#l76.275"></a><span id="l76.275" class="difflineminus">-      LDAP_SET_LDERRNO(ld, rc, nsldapi_strdup((char *)optdata), errstr);</span>
<a href="#l76.276"></a><span id="l76.276" class="difflineplus">+      LDAP_SET_LDERRNO(ld, rc, nsldapi_strdup((char*)optdata), errstr);</span>
<a href="#l76.277"></a><span id="l76.277">       rc = LDAP_SUCCESS;</span>
<a href="#l76.278"></a><span id="l76.278">       break;</span>
<a href="#l76.279"></a><span id="l76.279"> </span>
<a href="#l76.280"></a><span id="l76.280">     case LDAP_OPT_PREFERRED_LANGUAGE:</span>
<a href="#l76.281"></a><span id="l76.281">       if (NULL != ld-&gt;ld_preferred_language) {</span>
<a href="#l76.282"></a><span id="l76.282">         NSLDAPI_FREE(ld-&gt;ld_preferred_language);</span>
<a href="#l76.283"></a><span id="l76.283">       }</span>
<a href="#l76.284"></a><span id="l76.284" class="difflineminus">-      ld-&gt;ld_preferred_language = nsldapi_strdup((char *)optdata);</span>
<a href="#l76.285"></a><span id="l76.285" class="difflineplus">+      ld-&gt;ld_preferred_language = nsldapi_strdup((char*)optdata);</span>
<a href="#l76.286"></a><span id="l76.286">       break;</span>
<a href="#l76.287"></a><span id="l76.287"> </span>
<a href="#l76.288"></a><span id="l76.288">     case LDAP_OPT_HOST_NAME:</span>
<a href="#l76.289"></a><span id="l76.289">       if (NULL != ld-&gt;ld_defhost) {</span>
<a href="#l76.290"></a><span id="l76.290">         NSLDAPI_FREE(ld-&gt;ld_defhost);</span>
<a href="#l76.291"></a><span id="l76.291">       }</span>
<a href="#l76.292"></a><span id="l76.292" class="difflineminus">-      ld-&gt;ld_defhost = nsldapi_strdup((char *)optdata);</span>
<a href="#l76.293"></a><span id="l76.293" class="difflineplus">+      ld-&gt;ld_defhost = nsldapi_strdup((char*)optdata);</span>
<a href="#l76.294"></a><span id="l76.294">       break;</span>
<a href="#l76.295"></a><span id="l76.295"> </span>
<a href="#l76.296"></a><span id="l76.296">     case LDAP_X_OPT_CONNECT_TIMEOUT:</span>
<a href="#l76.297"></a><span id="l76.297" class="difflineminus">-      ld-&gt;ld_connect_timeout = *((int *)optdata);</span>
<a href="#l76.298"></a><span id="l76.298" class="difflineplus">+      ld-&gt;ld_connect_timeout = *((int*)optdata);</span>
<a href="#l76.299"></a><span id="l76.299">       break;</span>
<a href="#l76.300"></a><span id="l76.300"> </span>
<a href="#l76.301"></a><span id="l76.301"> #ifdef LDAP_SASLIO_HOOKS</span>
<a href="#l76.302"></a><span id="l76.302">     /* SASL options */</span>
<a href="#l76.303"></a><span id="l76.303">     case LDAP_OPT_X_SASL_MECH:</span>
<a href="#l76.304"></a><span id="l76.304">       NSLDAPI_FREE(ld-&gt;ld_def_sasl_mech);</span>
<a href="#l76.305"></a><span id="l76.305" class="difflineminus">-      ld-&gt;ld_def_sasl_mech = nsldapi_strdup((char *)optdata);</span>
<a href="#l76.306"></a><span id="l76.306" class="difflineplus">+      ld-&gt;ld_def_sasl_mech = nsldapi_strdup((char*)optdata);</span>
<a href="#l76.307"></a><span id="l76.307">       break;</span>
<a href="#l76.308"></a><span id="l76.308">     case LDAP_OPT_X_SASL_REALM:</span>
<a href="#l76.309"></a><span id="l76.309">       NSLDAPI_FREE(ld-&gt;ld_def_sasl_realm);</span>
<a href="#l76.310"></a><span id="l76.310" class="difflineminus">-      ld-&gt;ld_def_sasl_realm = nsldapi_strdup((char *)optdata);</span>
<a href="#l76.311"></a><span id="l76.311" class="difflineplus">+      ld-&gt;ld_def_sasl_realm = nsldapi_strdup((char*)optdata);</span>
<a href="#l76.312"></a><span id="l76.312">       break;</span>
<a href="#l76.313"></a><span id="l76.313">     case LDAP_OPT_X_SASL_AUTHCID:</span>
<a href="#l76.314"></a><span id="l76.314">       NSLDAPI_FREE(ld-&gt;ld_def_sasl_authcid);</span>
<a href="#l76.315"></a><span id="l76.315" class="difflineminus">-      ld-&gt;ld_def_sasl_authcid = nsldapi_strdup((char *)optdata);</span>
<a href="#l76.316"></a><span id="l76.316" class="difflineplus">+      ld-&gt;ld_def_sasl_authcid = nsldapi_strdup((char*)optdata);</span>
<a href="#l76.317"></a><span id="l76.317">       break;</span>
<a href="#l76.318"></a><span id="l76.318">     case LDAP_OPT_X_SASL_AUTHZID:</span>
<a href="#l76.319"></a><span id="l76.319">       NSLDAPI_FREE(ld-&gt;ld_def_sasl_authzid);</span>
<a href="#l76.320"></a><span id="l76.320" class="difflineminus">-      ld-&gt;ld_def_sasl_authzid = nsldapi_strdup((char *)optdata);</span>
<a href="#l76.321"></a><span id="l76.321" class="difflineplus">+      ld-&gt;ld_def_sasl_authzid = nsldapi_strdup((char*)optdata);</span>
<a href="#l76.322"></a><span id="l76.322">       break;</span>
<a href="#l76.323"></a><span id="l76.323">     case LDAP_OPT_X_SASL_SSF_EXTERNAL: {</span>
<a href="#l76.324"></a><span id="l76.324">       int sc;</span>
<a href="#l76.325"></a><span id="l76.325">       sasl_ssf_t extprops;</span>
<a href="#l76.326"></a><span id="l76.326" class="difflineminus">-      sasl_conn_t *ctx;</span>
<a href="#l76.327"></a><span id="l76.327" class="difflineplus">+      sasl_conn_t* ctx;</span>
<a href="#l76.328"></a><span id="l76.328">       if (ld-&gt;ld_defconn == NULL) {</span>
<a href="#l76.329"></a><span id="l76.329">         return -1;</span>
<a href="#l76.330"></a><span id="l76.330">       }</span>
<a href="#l76.331"></a><span id="l76.331" class="difflineminus">-      ctx = (sasl_conn_t *)(ld-&gt;ld_defconn-&gt;lconn_sasl_ctx);</span>
<a href="#l76.332"></a><span id="l76.332" class="difflineplus">+      ctx = (sasl_conn_t*)(ld-&gt;ld_defconn-&gt;lconn_sasl_ctx);</span>
<a href="#l76.333"></a><span id="l76.333">       if (ctx == NULL) {</span>
<a href="#l76.334"></a><span id="l76.334">         return -1;</span>
<a href="#l76.335"></a><span id="l76.335">       }</span>
<a href="#l76.336"></a><span id="l76.336">       memset(&amp;extprops, 0L, sizeof(extprops));</span>
<a href="#l76.337"></a><span id="l76.337" class="difflineminus">-      extprops = *((sasl_ssf_t *)optdata);</span>
<a href="#l76.338"></a><span id="l76.338" class="difflineminus">-      sc = sasl_setprop(ctx, SASL_SSF_EXTERNAL, (void *)&amp;extprops);</span>
<a href="#l76.339"></a><span id="l76.339" class="difflineplus">+      extprops = *((sasl_ssf_t*)optdata);</span>
<a href="#l76.340"></a><span id="l76.340" class="difflineplus">+      sc = sasl_setprop(ctx, SASL_SSF_EXTERNAL, (void*)&amp;extprops);</span>
<a href="#l76.341"></a><span id="l76.341">       if (sc != SASL_OK) {</span>
<a href="#l76.342"></a><span id="l76.342">         return -1;</span>
<a href="#l76.343"></a><span id="l76.343">       }</span>
<a href="#l76.344"></a><span id="l76.344">     } break;</span>
<a href="#l76.345"></a><span id="l76.345">     case LDAP_OPT_X_SASL_SECPROPS: {</span>
<a href="#l76.346"></a><span id="l76.346">       int sc;</span>
<a href="#l76.347"></a><span id="l76.347" class="difflineminus">-      sc = nsldapi_sasl_secprops((char *)optdata, &amp;ld-&gt;ld_sasl_secprops);</span>
<a href="#l76.348"></a><span id="l76.348" class="difflineplus">+      sc = nsldapi_sasl_secprops((char*)optdata, &amp;ld-&gt;ld_sasl_secprops);</span>
<a href="#l76.349"></a><span id="l76.349">       return sc == LDAP_SUCCESS ? 0 : -1;</span>
<a href="#l76.350"></a><span id="l76.350">     } break;</span>
<a href="#l76.351"></a><span id="l76.351">     case LDAP_OPT_X_SASL_SSF_MIN:</span>
<a href="#l76.352"></a><span id="l76.352" class="difflineminus">-      ld-&gt;ld_sasl_secprops.min_ssf = *((sasl_ssf_t *)optdata);</span>
<a href="#l76.353"></a><span id="l76.353" class="difflineplus">+      ld-&gt;ld_sasl_secprops.min_ssf = *((sasl_ssf_t*)optdata);</span>
<a href="#l76.354"></a><span id="l76.354">       break;</span>
<a href="#l76.355"></a><span id="l76.355">     case LDAP_OPT_X_SASL_SSF_MAX:</span>
<a href="#l76.356"></a><span id="l76.356" class="difflineminus">-      ld-&gt;ld_sasl_secprops.max_ssf = *((sasl_ssf_t *)optdata);</span>
<a href="#l76.357"></a><span id="l76.357" class="difflineplus">+      ld-&gt;ld_sasl_secprops.max_ssf = *((sasl_ssf_t*)optdata);</span>
<a href="#l76.358"></a><span id="l76.358">       break;</span>
<a href="#l76.359"></a><span id="l76.359">     case LDAP_OPT_X_SASL_MAXBUFSIZE:</span>
<a href="#l76.360"></a><span id="l76.360" class="difflineminus">-      ld-&gt;ld_sasl_secprops.maxbufsize = *((sasl_ssf_t *)optdata);</span>
<a href="#l76.361"></a><span id="l76.361" class="difflineplus">+      ld-&gt;ld_sasl_secprops.maxbufsize = *((sasl_ssf_t*)optdata);</span>
<a href="#l76.362"></a><span id="l76.362">       break;</span>
<a href="#l76.363"></a><span id="l76.363">     case LDAP_OPT_X_SASL_SSF: /* read only */</span>
<a href="#l76.364"></a><span id="l76.364">       LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l76.365"></a><span id="l76.365">       rc = -1;</span>
<a href="#l76.366"></a><span id="l76.366">       break;</span>
<a href="#l76.367"></a><span id="l76.367"> #endif</span>
<a href="#l76.368"></a><span id="l76.368"> </span>
<a href="#l76.369"></a><span id="l76.369">     default:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l77.1"></a><span id="l77.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/sort.c</span>
<a href="#l77.2"></a><span id="l77.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/sort.c</span>
<a href="#l77.3"></a><span id="l77.3" class="difflineat">@@ -47,42 +47,42 @@</span>
<a href="#l77.4"></a><span id="l77.4">  */</span>
<a href="#l77.5"></a><span id="l77.5"> /*</span>
<a href="#l77.6"></a><span id="l77.6">  * sort.c:  LDAP library entry and value sort routines</span>
<a href="#l77.7"></a><span id="l77.7">  */</span>
<a href="#l77.8"></a><span id="l77.8"> </span>
<a href="#l77.9"></a><span id="l77.9"> #include &quot;ldap-int.h&quot;</span>
<a href="#l77.10"></a><span id="l77.10"> </span>
<a href="#l77.11"></a><span id="l77.11"> typedef struct keycmp {</span>
<a href="#l77.12"></a><span id="l77.12" class="difflineminus">-  void *kc_arg;</span>
<a href="#l77.13"></a><span id="l77.13" class="difflineminus">-  LDAP_KEYCMP_CALLBACK *kc_cmp;</span>
<a href="#l77.14"></a><span id="l77.14" class="difflineplus">+  void* kc_arg;</span>
<a href="#l77.15"></a><span id="l77.15" class="difflineplus">+  LDAP_KEYCMP_CALLBACK* kc_cmp;</span>
<a href="#l77.16"></a><span id="l77.16"> } keycmp_t;</span>
<a href="#l77.17"></a><span id="l77.17"> </span>
<a href="#l77.18"></a><span id="l77.18"> typedef struct keything {</span>
<a href="#l77.19"></a><span id="l77.19" class="difflineminus">-  keycmp_t *kt_cmp;</span>
<a href="#l77.20"></a><span id="l77.20" class="difflineminus">-  const struct berval *kt_key;</span>
<a href="#l77.21"></a><span id="l77.21" class="difflineminus">-  LDAPMessage *kt_msg;</span>
<a href="#l77.22"></a><span id="l77.22" class="difflineplus">+  keycmp_t* kt_cmp;</span>
<a href="#l77.23"></a><span id="l77.23" class="difflineplus">+  const struct berval* kt_key;</span>
<a href="#l77.24"></a><span id="l77.24" class="difflineplus">+  LDAPMessage* kt_msg;</span>
<a href="#l77.25"></a><span id="l77.25"> } keything_t;</span>
<a href="#l77.26"></a><span id="l77.26"> </span>
<a href="#l77.27"></a><span id="l77.27" class="difflineminus">-static int LDAP_C LDAP_CALLBACK ldapi_keycmp(const void *Lv, const void *Rv) {</span>
<a href="#l77.28"></a><span id="l77.28" class="difflineminus">-  auto keything_t **L = (keything_t **)Lv;</span>
<a href="#l77.29"></a><span id="l77.29" class="difflineminus">-  auto keything_t **R = (keything_t **)Rv;</span>
<a href="#l77.30"></a><span id="l77.30" class="difflineminus">-  auto keycmp_t *cmp = (*L)-&gt;kt_cmp;</span>
<a href="#l77.31"></a><span id="l77.31" class="difflineplus">+static int LDAP_C LDAP_CALLBACK ldapi_keycmp(const void* Lv, const void* Rv) {</span>
<a href="#l77.32"></a><span id="l77.32" class="difflineplus">+  auto keything_t** L = (keything_t**)Lv;</span>
<a href="#l77.33"></a><span id="l77.33" class="difflineplus">+  auto keything_t** R = (keything_t**)Rv;</span>
<a href="#l77.34"></a><span id="l77.34" class="difflineplus">+  auto keycmp_t* cmp = (*L)-&gt;kt_cmp;</span>
<a href="#l77.35"></a><span id="l77.35">   return cmp-&gt;kc_cmp(cmp-&gt;kc_arg, (*L)-&gt;kt_key, (*R)-&gt;kt_key);</span>
<a href="#l77.36"></a><span id="l77.36"> }</span>
<a href="#l77.37"></a><span id="l77.37"> </span>
<a href="#l77.38"></a><span id="l77.38" class="difflineminus">-int LDAP_CALL ldap_keysort_entries(LDAP *ld, LDAPMessage **chain, void *arg,</span>
<a href="#l77.39"></a><span id="l77.39" class="difflineminus">-                                   LDAP_KEYGEN_CALLBACK *gen,</span>
<a href="#l77.40"></a><span id="l77.40" class="difflineminus">-                                   LDAP_KEYCMP_CALLBACK *cmp,</span>
<a href="#l77.41"></a><span id="l77.41" class="difflineminus">-                                   LDAP_KEYFREE_CALLBACK *fre) {</span>
<a href="#l77.42"></a><span id="l77.42" class="difflineplus">+int LDAP_CALL ldap_keysort_entries(LDAP* ld, LDAPMessage** chain, void* arg,</span>
<a href="#l77.43"></a><span id="l77.43" class="difflineplus">+                                   LDAP_KEYGEN_CALLBACK* gen,</span>
<a href="#l77.44"></a><span id="l77.44" class="difflineplus">+                                   LDAP_KEYCMP_CALLBACK* cmp,</span>
<a href="#l77.45"></a><span id="l77.45" class="difflineplus">+                                   LDAP_KEYFREE_CALLBACK* fre) {</span>
<a href="#l77.46"></a><span id="l77.46">   size_t count, i;</span>
<a href="#l77.47"></a><span id="l77.47">   keycmp_t kc = {0};</span>
<a href="#l77.48"></a><span id="l77.48" class="difflineminus">-  keything_t **kt;</span>
<a href="#l77.49"></a><span id="l77.49" class="difflineplus">+  keything_t** kt;</span>
<a href="#l77.50"></a><span id="l77.50">   LDAPMessage *e, *last;</span>
<a href="#l77.51"></a><span id="l77.51" class="difflineminus">-  LDAPMessage **ep;</span>
<a href="#l77.52"></a><span id="l77.52" class="difflineplus">+  LDAPMessage** ep;</span>
<a href="#l77.53"></a><span id="l77.53">   int scount;</span>
<a href="#l77.54"></a><span id="l77.54"> </span>
<a href="#l77.55"></a><span id="l77.55">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || chain == NULL || cmp == NULL) {</span>
<a href="#l77.56"></a><span id="l77.56">     return (LDAP_PARAM_ERROR);</span>
<a href="#l77.57"></a><span id="l77.57">   }</span>
<a href="#l77.58"></a><span id="l77.58"> </span>
<a href="#l77.59"></a><span id="l77.59">   scount = ldap_count_entries(ld, *chain);</span>
<a href="#l77.60"></a><span id="l77.60"> </span>
<a href="#l77.61"></a><span id="l77.61" class="difflineat">@@ -91,103 +91,103 @@ int LDAP_CALL ldap_keysort_entries(LDAP </span>
<a href="#l77.62"></a><span id="l77.62">   }</span>
<a href="#l77.63"></a><span id="l77.63"> </span>
<a href="#l77.64"></a><span id="l77.64">   count = scount;</span>
<a href="#l77.65"></a><span id="l77.65"> </span>
<a href="#l77.66"></a><span id="l77.66">   if (count &lt; 2) { /* nothing to sort */</span>
<a href="#l77.67"></a><span id="l77.67">     return (0);</span>
<a href="#l77.68"></a><span id="l77.68">   }</span>
<a href="#l77.69"></a><span id="l77.69"> </span>
<a href="#l77.70"></a><span id="l77.70" class="difflineminus">-  kt = (keything_t **)NSLDAPI_MALLOC(</span>
<a href="#l77.71"></a><span id="l77.71" class="difflineminus">-      count * (sizeof(keything_t *) + sizeof(keything_t)));</span>
<a href="#l77.72"></a><span id="l77.72" class="difflineplus">+  kt = (keything_t**)NSLDAPI_MALLOC(count *</span>
<a href="#l77.73"></a><span id="l77.73" class="difflineplus">+                                    (sizeof(keything_t*) + sizeof(keything_t)));</span>
<a href="#l77.74"></a><span id="l77.74">   if (kt == NULL) {</span>
<a href="#l77.75"></a><span id="l77.75">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l77.76"></a><span id="l77.76">     return (-1);</span>
<a href="#l77.77"></a><span id="l77.77">   }</span>
<a href="#l77.78"></a><span id="l77.78">   for (i = 0; i &lt; count; i++) {</span>
<a href="#l77.79"></a><span id="l77.79" class="difflineminus">-    kt[i] = i + (keything_t *)(kt + count);</span>
<a href="#l77.80"></a><span id="l77.80" class="difflineplus">+    kt[i] = i + (keything_t*)(kt + count);</span>
<a href="#l77.81"></a><span id="l77.81">   }</span>
<a href="#l77.82"></a><span id="l77.82">   kc.kc_arg = arg;</span>
<a href="#l77.83"></a><span id="l77.83">   kc.kc_cmp = cmp;</span>
<a href="#l77.84"></a><span id="l77.84"> </span>
<a href="#l77.85"></a><span id="l77.85">   for (e = *chain, i = 0; i &lt; count; i++, e = e-&gt;lm_chain) {</span>
<a href="#l77.86"></a><span id="l77.86">     kt[i]-&gt;kt_msg = e;</span>
<a href="#l77.87"></a><span id="l77.87">     kt[i]-&gt;kt_cmp = &amp;kc;</span>
<a href="#l77.88"></a><span id="l77.88">     kt[i]-&gt;kt_key = gen(arg, ld, e);</span>
<a href="#l77.89"></a><span id="l77.89">     if (kt[i]-&gt;kt_key == NULL) {</span>
<a href="#l77.90"></a><span id="l77.90">       if (fre)</span>
<a href="#l77.91"></a><span id="l77.91">         while (i-- &gt; 0) fre(arg, kt[i]-&gt;kt_key);</span>
<a href="#l77.92"></a><span id="l77.92" class="difflineminus">-      NSLDAPI_FREE((char *)kt);</span>
<a href="#l77.93"></a><span id="l77.93" class="difflineplus">+      NSLDAPI_FREE((char*)kt);</span>
<a href="#l77.94"></a><span id="l77.94">       LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l77.95"></a><span id="l77.95">       return (-1);</span>
<a href="#l77.96"></a><span id="l77.96">     }</span>
<a href="#l77.97"></a><span id="l77.97">   }</span>
<a href="#l77.98"></a><span id="l77.98">   last = e;</span>
<a href="#l77.99"></a><span id="l77.99"> </span>
<a href="#l77.100"></a><span id="l77.100" class="difflineminus">-  qsort((void *)kt, count, (size_t)sizeof(keything_t *), ldapi_keycmp);</span>
<a href="#l77.101"></a><span id="l77.101" class="difflineplus">+  qsort((void*)kt, count, (size_t)sizeof(keything_t*), ldapi_keycmp);</span>
<a href="#l77.102"></a><span id="l77.102"> </span>
<a href="#l77.103"></a><span id="l77.103">   ep = chain;</span>
<a href="#l77.104"></a><span id="l77.104">   for (i = 0; i &lt; count; i++) {</span>
<a href="#l77.105"></a><span id="l77.105">     *ep = kt[i]-&gt;kt_msg;</span>
<a href="#l77.106"></a><span id="l77.106">     ep = &amp;(*ep)-&gt;lm_chain;</span>
<a href="#l77.107"></a><span id="l77.107">     if (fre) fre(arg, kt[i]-&gt;kt_key);</span>
<a href="#l77.108"></a><span id="l77.108">   }</span>
<a href="#l77.109"></a><span id="l77.109">   *ep = last;</span>
<a href="#l77.110"></a><span id="l77.110" class="difflineminus">-  NSLDAPI_FREE((char *)kt);</span>
<a href="#l77.111"></a><span id="l77.111" class="difflineplus">+  NSLDAPI_FREE((char*)kt);</span>
<a href="#l77.112"></a><span id="l77.112">   return (0);</span>
<a href="#l77.113"></a><span id="l77.113"> }</span>
<a href="#l77.114"></a><span id="l77.114"> </span>
<a href="#l77.115"></a><span id="l77.115"> struct entrything {</span>
<a href="#l77.116"></a><span id="l77.116" class="difflineminus">-  char **et_vals;</span>
<a href="#l77.117"></a><span id="l77.117" class="difflineminus">-  LDAPMessage *et_msg;</span>
<a href="#l77.118"></a><span id="l77.118" class="difflineplus">+  char** et_vals;</span>
<a href="#l77.119"></a><span id="l77.119" class="difflineplus">+  LDAPMessage* et_msg;</span>
<a href="#l77.120"></a><span id="l77.120"> };</span>
<a href="#l77.121"></a><span id="l77.121"> </span>
<a href="#l77.122"></a><span id="l77.122" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_CHARCMP_CALLBACK)(char *, char *);</span>
<a href="#l77.123"></a><span id="l77.123" class="difflineminus">-typedef int(LDAP_C LDAP_CALLBACK LDAP_VOIDCMP_CALLBACK)(const void *,</span>
<a href="#l77.124"></a><span id="l77.124" class="difflineminus">-                                                        const void *);</span>
<a href="#l77.125"></a><span id="l77.125" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_CHARCMP_CALLBACK)(char*, char*);</span>
<a href="#l77.126"></a><span id="l77.126" class="difflineplus">+typedef int(LDAP_C LDAP_CALLBACK LDAP_VOIDCMP_CALLBACK)(const void*,</span>
<a href="#l77.127"></a><span id="l77.127" class="difflineplus">+                                                        const void*);</span>
<a href="#l77.128"></a><span id="l77.128"> </span>
<a href="#l77.129"></a><span id="l77.129" class="difflineminus">-static LDAP_CHARCMP_CALLBACK *et_cmp_fn;</span>
<a href="#l77.130"></a><span id="l77.130" class="difflineplus">+static LDAP_CHARCMP_CALLBACK* et_cmp_fn;</span>
<a href="#l77.131"></a><span id="l77.131"> static LDAP_VOIDCMP_CALLBACK et_cmp;</span>
<a href="#l77.132"></a><span id="l77.132"> </span>
<a href="#l77.133"></a><span id="l77.133" class="difflineminus">-int LDAP_C LDAP_CALLBACK ldap_sort_strcasecmp(const char **a, const char **b) {</span>
<a href="#l77.134"></a><span id="l77.134" class="difflineplus">+int LDAP_C LDAP_CALLBACK ldap_sort_strcasecmp(const char** a, const char** b) {</span>
<a href="#l77.135"></a><span id="l77.135">   /* XXXceb</span>
<a href="#l77.136"></a><span id="l77.136">    * I am not 100% sure this is the way this should be handled.</span>
<a href="#l77.137"></a><span id="l77.137">    * For now we will return a 0 on invalid.</span>
<a href="#l77.138"></a><span id="l77.138">    */</span>
<a href="#l77.139"></a><span id="l77.139">   if (NULL == a || NULL == b) return (0);</span>
<a href="#l77.140"></a><span id="l77.140" class="difflineminus">-  return (strcasecmp((char *)*a, (char *)*b));</span>
<a href="#l77.141"></a><span id="l77.141" class="difflineplus">+  return (strcasecmp((char*)*a, (char*)*b));</span>
<a href="#l77.142"></a><span id="l77.142"> }</span>
<a href="#l77.143"></a><span id="l77.143"> </span>
<a href="#l77.144"></a><span id="l77.144" class="difflineminus">-static int LDAP_C LDAP_CALLBACK et_cmp(const void *aa, const void *bb) {</span>
<a href="#l77.145"></a><span id="l77.145" class="difflineplus">+static int LDAP_C LDAP_CALLBACK et_cmp(const void* aa, const void* bb) {</span>
<a href="#l77.146"></a><span id="l77.146">   int i, rc;</span>
<a href="#l77.147"></a><span id="l77.147" class="difflineminus">-  struct entrything *a = (struct entrything *)aa;</span>
<a href="#l77.148"></a><span id="l77.148" class="difflineminus">-  struct entrything *b = (struct entrything *)bb;</span>
<a href="#l77.149"></a><span id="l77.149" class="difflineplus">+  struct entrything* a = (struct entrything*)aa;</span>
<a href="#l77.150"></a><span id="l77.150" class="difflineplus">+  struct entrything* b = (struct entrything*)bb;</span>
<a href="#l77.151"></a><span id="l77.151"> </span>
<a href="#l77.152"></a><span id="l77.152">   if (a-&gt;et_vals == NULL &amp;&amp; b-&gt;et_vals == NULL) return (0);</span>
<a href="#l77.153"></a><span id="l77.153">   if (a-&gt;et_vals == NULL) return (-1);</span>
<a href="#l77.154"></a><span id="l77.154">   if (b-&gt;et_vals == NULL) return (1);</span>
<a href="#l77.155"></a><span id="l77.155"> </span>
<a href="#l77.156"></a><span id="l77.156">   for (i = 0; a-&gt;et_vals[i] &amp;&amp; b-&gt;et_vals[i]; i++) {</span>
<a href="#l77.157"></a><span id="l77.157">     if ((rc = (*et_cmp_fn)(a-&gt;et_vals[i], b-&gt;et_vals[i])) != 0) {</span>
<a href="#l77.158"></a><span id="l77.158">       return (rc);</span>
<a href="#l77.159"></a><span id="l77.159">     }</span>
<a href="#l77.160"></a><span id="l77.160">   }</span>
<a href="#l77.161"></a><span id="l77.161"> </span>
<a href="#l77.162"></a><span id="l77.162">   if (a-&gt;et_vals[i] == NULL &amp;&amp; b-&gt;et_vals[i] == NULL) return (0);</span>
<a href="#l77.163"></a><span id="l77.163">   if (a-&gt;et_vals[i] == NULL) return (-1);</span>
<a href="#l77.164"></a><span id="l77.164">   return (1);</span>
<a href="#l77.165"></a><span id="l77.165"> }</span>
<a href="#l77.166"></a><span id="l77.166"> </span>
<a href="#l77.167"></a><span id="l77.167" class="difflineminus">-int LDAP_CALL ldap_multisort_entries(LDAP *ld, LDAPMessage **chain,</span>
<a href="#l77.168"></a><span id="l77.168" class="difflineminus">-                                     char **attr, /* NULL =&gt; sort by DN */</span>
<a href="#l77.169"></a><span id="l77.169" class="difflineminus">-                                     LDAP_CMP_CALLBACK *cmp) {</span>
<a href="#l77.170"></a><span id="l77.170" class="difflineplus">+int LDAP_CALL ldap_multisort_entries(LDAP* ld, LDAPMessage** chain,</span>
<a href="#l77.171"></a><span id="l77.171" class="difflineplus">+                                     char** attr, /* NULL =&gt; sort by DN */</span>
<a href="#l77.172"></a><span id="l77.172" class="difflineplus">+                                     LDAP_CMP_CALLBACK* cmp) {</span>
<a href="#l77.173"></a><span id="l77.173">   int i, count;</span>
<a href="#l77.174"></a><span id="l77.174" class="difflineminus">-  struct entrything *et;</span>
<a href="#l77.175"></a><span id="l77.175" class="difflineplus">+  struct entrything* et;</span>
<a href="#l77.176"></a><span id="l77.176">   LDAPMessage *e, *last;</span>
<a href="#l77.177"></a><span id="l77.177" class="difflineminus">-  LDAPMessage **ep;</span>
<a href="#l77.178"></a><span id="l77.178" class="difflineplus">+  LDAPMessage** ep;</span>
<a href="#l77.179"></a><span id="l77.179">   int scount;</span>
<a href="#l77.180"></a><span id="l77.180"> </span>
<a href="#l77.181"></a><span id="l77.181">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || chain == NULL || cmp == NULL) {</span>
<a href="#l77.182"></a><span id="l77.182">     return (LDAP_PARAM_ERROR);</span>
<a href="#l77.183"></a><span id="l77.183">   }</span>
<a href="#l77.184"></a><span id="l77.184"> </span>
<a href="#l77.185"></a><span id="l77.185">   scount = ldap_count_entries(ld, *chain);</span>
<a href="#l77.186"></a><span id="l77.186"> </span>
<a href="#l77.187"></a><span id="l77.187" class="difflineat">@@ -196,94 +196,94 @@ int LDAP_CALL ldap_multisort_entries(LDA</span>
<a href="#l77.188"></a><span id="l77.188">   }</span>
<a href="#l77.189"></a><span id="l77.189"> </span>
<a href="#l77.190"></a><span id="l77.190">   count = scount;</span>
<a href="#l77.191"></a><span id="l77.191"> </span>
<a href="#l77.192"></a><span id="l77.192">   if (count &lt; 2) { /* nothing to sort */</span>
<a href="#l77.193"></a><span id="l77.193">     return (0);</span>
<a href="#l77.194"></a><span id="l77.194">   }</span>
<a href="#l77.195"></a><span id="l77.195"> </span>
<a href="#l77.196"></a><span id="l77.196" class="difflineminus">-  if ((et = (struct entrything *)NSLDAPI_MALLOC(</span>
<a href="#l77.197"></a><span id="l77.197" class="difflineplus">+  if ((et = (struct entrything*)NSLDAPI_MALLOC(</span>
<a href="#l77.198"></a><span id="l77.198">            count * sizeof(struct entrything))) == NULL) {</span>
<a href="#l77.199"></a><span id="l77.199">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l77.200"></a><span id="l77.200">     return (-1);</span>
<a href="#l77.201"></a><span id="l77.201">   }</span>
<a href="#l77.202"></a><span id="l77.202"> </span>
<a href="#l77.203"></a><span id="l77.203">   e = *chain;</span>
<a href="#l77.204"></a><span id="l77.204">   for (i = 0; i &lt; count; i++) {</span>
<a href="#l77.205"></a><span id="l77.205">     et[i].et_msg = e;</span>
<a href="#l77.206"></a><span id="l77.206">     et[i].et_vals = NULL;</span>
<a href="#l77.207"></a><span id="l77.207">     if (attr == NULL) {</span>
<a href="#l77.208"></a><span id="l77.208" class="difflineminus">-      char *dn;</span>
<a href="#l77.209"></a><span id="l77.209" class="difflineplus">+      char* dn;</span>
<a href="#l77.210"></a><span id="l77.210"> </span>
<a href="#l77.211"></a><span id="l77.211">       dn = ldap_get_dn(ld, e);</span>
<a href="#l77.212"></a><span id="l77.212">       et[i].et_vals = ldap_explode_dn(dn, 1);</span>
<a href="#l77.213"></a><span id="l77.213">       NSLDAPI_FREE(dn);</span>
<a href="#l77.214"></a><span id="l77.214">     } else {</span>
<a href="#l77.215"></a><span id="l77.215">       int attrcnt;</span>
<a href="#l77.216"></a><span id="l77.216" class="difflineminus">-      char **vals;</span>
<a href="#l77.217"></a><span id="l77.217" class="difflineplus">+      char** vals;</span>
<a href="#l77.218"></a><span id="l77.218"> </span>
<a href="#l77.219"></a><span id="l77.219">       for (attrcnt = 0; attr[attrcnt] != NULL; attrcnt++) {</span>
<a href="#l77.220"></a><span id="l77.220">         vals = ldap_get_values(ld, e, attr[attrcnt]);</span>
<a href="#l77.221"></a><span id="l77.221">         if (ldap_charray_merge(&amp;(et[i].et_vals), vals) != 0) {</span>
<a href="#l77.222"></a><span id="l77.222">           int j;</span>
<a href="#l77.223"></a><span id="l77.223"> </span>
<a href="#l77.224"></a><span id="l77.224">           /* XXX risky: ldap_value_free( vals ); */</span>
<a href="#l77.225"></a><span id="l77.225">           for (j = 0; j &lt;= i; j++) ldap_value_free(et[j].et_vals);</span>
<a href="#l77.226"></a><span id="l77.226" class="difflineminus">-          NSLDAPI_FREE((char *)et);</span>
<a href="#l77.227"></a><span id="l77.227" class="difflineplus">+          NSLDAPI_FREE((char*)et);</span>
<a href="#l77.228"></a><span id="l77.228">           LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l77.229"></a><span id="l77.229">           return (-1);</span>
<a href="#l77.230"></a><span id="l77.230">         }</span>
<a href="#l77.231"></a><span id="l77.231">         if (vals != NULL) {</span>
<a href="#l77.232"></a><span id="l77.232" class="difflineminus">-          NSLDAPI_FREE((char *)vals);</span>
<a href="#l77.233"></a><span id="l77.233" class="difflineplus">+          NSLDAPI_FREE((char*)vals);</span>
<a href="#l77.234"></a><span id="l77.234">         }</span>
<a href="#l77.235"></a><span id="l77.235">       }</span>
<a href="#l77.236"></a><span id="l77.236">     }</span>
<a href="#l77.237"></a><span id="l77.237"> </span>
<a href="#l77.238"></a><span id="l77.238">     e = e-&gt;lm_chain;</span>
<a href="#l77.239"></a><span id="l77.239">   }</span>
<a href="#l77.240"></a><span id="l77.240">   last = e;</span>
<a href="#l77.241"></a><span id="l77.241"> </span>
<a href="#l77.242"></a><span id="l77.242" class="difflineminus">-  et_cmp_fn = (LDAP_CHARCMP_CALLBACK *)cmp;</span>
<a href="#l77.243"></a><span id="l77.243" class="difflineminus">-  qsort((void *)et, (size_t)count, (size_t)sizeof(struct entrything), et_cmp);</span>
<a href="#l77.244"></a><span id="l77.244" class="difflineplus">+  et_cmp_fn = (LDAP_CHARCMP_CALLBACK*)cmp;</span>
<a href="#l77.245"></a><span id="l77.245" class="difflineplus">+  qsort((void*)et, (size_t)count, (size_t)sizeof(struct entrything), et_cmp);</span>
<a href="#l77.246"></a><span id="l77.246"> </span>
<a href="#l77.247"></a><span id="l77.247">   ep = chain;</span>
<a href="#l77.248"></a><span id="l77.248">   for (i = 0; i &lt; count; i++) {</span>
<a href="#l77.249"></a><span id="l77.249">     *ep = et[i].et_msg;</span>
<a href="#l77.250"></a><span id="l77.250">     ep = &amp;(*ep)-&gt;lm_chain;</span>
<a href="#l77.251"></a><span id="l77.251"> </span>
<a href="#l77.252"></a><span id="l77.252">     ldap_value_free(et[i].et_vals);</span>
<a href="#l77.253"></a><span id="l77.253">   }</span>
<a href="#l77.254"></a><span id="l77.254">   *ep = last;</span>
<a href="#l77.255"></a><span id="l77.255" class="difflineminus">-  NSLDAPI_FREE((char *)et);</span>
<a href="#l77.256"></a><span id="l77.256" class="difflineplus">+  NSLDAPI_FREE((char*)et);</span>
<a href="#l77.257"></a><span id="l77.257"> </span>
<a href="#l77.258"></a><span id="l77.258">   return (0);</span>
<a href="#l77.259"></a><span id="l77.259"> }</span>
<a href="#l77.260"></a><span id="l77.260"> </span>
<a href="#l77.261"></a><span id="l77.261" class="difflineminus">-int LDAP_CALL ldap_sort_entries(LDAP *ld, LDAPMessage **chain,</span>
<a href="#l77.262"></a><span id="l77.262" class="difflineminus">-                                char *attr, /* NULL =&gt; sort by DN */</span>
<a href="#l77.263"></a><span id="l77.263" class="difflineminus">-                                LDAP_CMP_CALLBACK *cmp) {</span>
<a href="#l77.264"></a><span id="l77.264" class="difflineminus">-  char *attrs[2];</span>
<a href="#l77.265"></a><span id="l77.265" class="difflineplus">+int LDAP_CALL ldap_sort_entries(LDAP* ld, LDAPMessage** chain,</span>
<a href="#l77.266"></a><span id="l77.266" class="difflineplus">+                                char* attr, /* NULL =&gt; sort by DN */</span>
<a href="#l77.267"></a><span id="l77.267" class="difflineplus">+                                LDAP_CMP_CALLBACK* cmp) {</span>
<a href="#l77.268"></a><span id="l77.268" class="difflineplus">+  char* attrs[2];</span>
<a href="#l77.269"></a><span id="l77.269"> </span>
<a href="#l77.270"></a><span id="l77.270">   attrs[0] = attr;</span>
<a href="#l77.271"></a><span id="l77.271">   attrs[1] = NULL;</span>
<a href="#l77.272"></a><span id="l77.272">   return (ldap_multisort_entries(ld, chain, attr ? attrs : NULL, cmp));</span>
<a href="#l77.273"></a><span id="l77.273"> }</span>
<a href="#l77.274"></a><span id="l77.274"> </span>
<a href="#l77.275"></a><span id="l77.275" class="difflineminus">-int LDAP_CALL ldap_sort_values(LDAP *ld, char **vals,</span>
<a href="#l77.276"></a><span id="l77.276" class="difflineminus">-                               LDAP_VALCMP_CALLBACK *cmp) {</span>
<a href="#l77.277"></a><span id="l77.277" class="difflineplus">+int LDAP_CALL ldap_sort_values(LDAP* ld, char** vals,</span>
<a href="#l77.278"></a><span id="l77.278" class="difflineplus">+                               LDAP_VALCMP_CALLBACK* cmp) {</span>
<a href="#l77.279"></a><span id="l77.279">   int nel;</span>
<a href="#l77.280"></a><span id="l77.280"> </span>
<a href="#l77.281"></a><span id="l77.281">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || cmp == NULL) {</span>
<a href="#l77.282"></a><span id="l77.282">     return (LDAP_PARAM_ERROR);</span>
<a href="#l77.283"></a><span id="l77.283">   }</span>
<a href="#l77.284"></a><span id="l77.284"> </span>
<a href="#l77.285"></a><span id="l77.285">   if (NULL == vals) {</span>
<a href="#l77.286"></a><span id="l77.286">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l77.287"></a><span id="l77.287">     return (LDAP_PARAM_ERROR);</span>
<a href="#l77.288"></a><span id="l77.288">   }</span>
<a href="#l77.289"></a><span id="l77.289">   for (nel = 0; vals[nel] != NULL; nel++)</span>
<a href="#l77.290"></a><span id="l77.290">     ; /* NULL */</span>
<a href="#l77.291"></a><span id="l77.291"> </span>
<a href="#l77.292"></a><span id="l77.292" class="difflineminus">-  qsort(vals, nel, sizeof(char *), (LDAP_VOIDCMP_CALLBACK *)cmp);</span>
<a href="#l77.293"></a><span id="l77.293" class="difflineplus">+  qsort(vals, nel, sizeof(char*), (LDAP_VOIDCMP_CALLBACK*)cmp);</span>
<a href="#l77.294"></a><span id="l77.294"> </span>
<a href="#l77.295"></a><span id="l77.295">   return (LDAP_SUCCESS);</span>
<a href="#l77.296"></a><span id="l77.296"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l78.1"></a><span id="l78.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/sortctrl.c</span>
<a href="#l78.2"></a><span id="l78.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/sortctrl.c</span>
<a href="#l78.3"></a><span id="l78.3" class="difflineat">@@ -47,20 +47,20 @@</span>
<a href="#l78.4"></a><span id="l78.4">    ctl_iscritical  Indicates whether the control is critical of not. If</span>
<a href="#l78.5"></a><span id="l78.5">                    this field is non-zero, the operation will only be car-</span>
<a href="#l78.6"></a><span id="l78.6">                    ried out if the control is recognized by the server</span>
<a href="#l78.7"></a><span id="l78.7">                    and/or client</span>
<a href="#l78.8"></a><span id="l78.8"> </span>
<a href="#l78.9"></a><span id="l78.9">    ctrlp           the address of a place to put the constructed control</span>
<a href="#l78.10"></a><span id="l78.10"> */</span>
<a href="#l78.11"></a><span id="l78.11"> </span>
<a href="#l78.12"></a><span id="l78.12" class="difflineminus">-int LDAP_CALL ldap_create_sort_control(LDAP *ld, LDAPsortkey **sortKeyList,</span>
<a href="#l78.13"></a><span id="l78.13" class="difflineplus">+int LDAP_CALL ldap_create_sort_control(LDAP* ld, LDAPsortkey** sortKeyList,</span>
<a href="#l78.14"></a><span id="l78.14">                                        const char ctl_iscritical,</span>
<a href="#l78.15"></a><span id="l78.15" class="difflineminus">-                                       LDAPControl **ctrlp) {</span>
<a href="#l78.16"></a><span id="l78.16" class="difflineminus">-  BerElement *ber;</span>
<a href="#l78.17"></a><span id="l78.17" class="difflineplus">+                                       LDAPControl** ctrlp) {</span>
<a href="#l78.18"></a><span id="l78.18" class="difflineplus">+  BerElement* ber;</span>
<a href="#l78.19"></a><span id="l78.19">   int i, rc;</span>
<a href="#l78.20"></a><span id="l78.20"> </span>
<a href="#l78.21"></a><span id="l78.21">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l78.22"></a><span id="l78.22">     return (LDAP_PARAM_ERROR);</span>
<a href="#l78.23"></a><span id="l78.23">   }</span>
<a href="#l78.24"></a><span id="l78.24"> </span>
<a href="#l78.25"></a><span id="l78.25">   if (sortKeyList == NULL || ctrlp == NULL) {</span>
<a href="#l78.26"></a><span id="l78.26">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l78.27"></a><span id="l78.27" class="difflineat">@@ -137,24 +137,24 @@ encoding_error_exit:</span>
<a href="#l78.28"></a><span id="l78.28">                    the server</span>
<a href="#l78.29"></a><span id="l78.29"> </span>
<a href="#l78.30"></a><span id="l78.30">    result          the address of a place to put the result code</span>
<a href="#l78.31"></a><span id="l78.31"> </span>
<a href="#l78.32"></a><span id="l78.32">    attribute       the address of a place to put the name of the</span>
<a href="#l78.33"></a><span id="l78.33">                    attribute which cause the operation to fail, optionally</span>
<a href="#l78.34"></a><span id="l78.34">                    returned by the server */</span>
<a href="#l78.35"></a><span id="l78.35"> </span>
<a href="#l78.36"></a><span id="l78.36" class="difflineminus">-int LDAP_CALL ldap_parse_sort_control(LDAP *ld, LDAPControl **ctrlp,</span>
<a href="#l78.37"></a><span id="l78.37" class="difflineminus">-                                      ber_int_t *result, char **attribute) {</span>
<a href="#l78.38"></a><span id="l78.38" class="difflineminus">-  BerElement *ber;</span>
<a href="#l78.39"></a><span id="l78.39" class="difflineplus">+int LDAP_CALL ldap_parse_sort_control(LDAP* ld, LDAPControl** ctrlp,</span>
<a href="#l78.40"></a><span id="l78.40" class="difflineplus">+                                      ber_int_t* result, char** attribute) {</span>
<a href="#l78.41"></a><span id="l78.41" class="difflineplus">+  BerElement* ber;</span>
<a href="#l78.42"></a><span id="l78.42">   int i, foundSortControl;</span>
<a href="#l78.43"></a><span id="l78.43" class="difflineminus">-  LDAPControl *sortCtrlp;</span>
<a href="#l78.44"></a><span id="l78.44" class="difflineplus">+  LDAPControl* sortCtrlp;</span>
<a href="#l78.45"></a><span id="l78.45">   ber_len_t len;</span>
<a href="#l78.46"></a><span id="l78.46">   ber_tag_t tag;</span>
<a href="#l78.47"></a><span id="l78.47" class="difflineminus">-  char *attr;</span>
<a href="#l78.48"></a><span id="l78.48" class="difflineplus">+  char* attr;</span>
<a href="#l78.49"></a><span id="l78.49"> </span>
<a href="#l78.50"></a><span id="l78.50">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || result == NULL || attribute == NULL) {</span>
<a href="#l78.51"></a><span id="l78.51">     return (LDAP_PARAM_ERROR);</span>
<a href="#l78.52"></a><span id="l78.52">   }</span>
<a href="#l78.53"></a><span id="l78.53"> </span>
<a href="#l78.54"></a><span id="l78.54">   /* find the sortControl in the list of controls if it exists */</span>
<a href="#l78.55"></a><span id="l78.55">   if (ctrlp == NULL) {</span>
<a href="#l78.56"></a><span id="l78.56">     LDAP_SET_LDERRNO(ld, LDAP_CONTROL_NOT_FOUND, NULL, NULL);</span>
<a href="#l78.57"></a><span id="l78.57" class="difflineat">@@ -208,19 +208,19 @@ int LDAP_CALL ldap_parse_sort_control(LD</span>
<a href="#l78.58"></a><span id="l78.58">   ber_free(ber, 1);</span>
<a href="#l78.59"></a><span id="l78.59"> </span>
<a href="#l78.60"></a><span id="l78.60">   return (LDAP_SUCCESS);</span>
<a href="#l78.61"></a><span id="l78.61"> }</span>
<a href="#l78.62"></a><span id="l78.62"> </span>
<a href="#l78.63"></a><span id="l78.63"> /* Routines for the manipulation of string-representations of sort control</span>
<a href="#l78.64"></a><span id="l78.64">  * keylists */</span>
<a href="#l78.65"></a><span id="l78.65"> </span>
<a href="#l78.66"></a><span id="l78.66" class="difflineminus">-static int count_tokens(const char *s) {</span>
<a href="#l78.67"></a><span id="l78.67" class="difflineplus">+static int count_tokens(const char* s) {</span>
<a href="#l78.68"></a><span id="l78.68">   int count = 0;</span>
<a href="#l78.69"></a><span id="l78.69" class="difflineminus">-  const char *p = s;</span>
<a href="#l78.70"></a><span id="l78.70" class="difflineplus">+  const char* p = s;</span>
<a href="#l78.71"></a><span id="l78.71">   int whitespace = 1;</span>
<a href="#l78.72"></a><span id="l78.72">   /* Loop along the string counting the number of times we see the</span>
<a href="#l78.73"></a><span id="l78.73">    * beginning of non-whitespace. This tells us</span>
<a href="#l78.74"></a><span id="l78.74">    * the number of tokens in the string</span>
<a href="#l78.75"></a><span id="l78.75">    */</span>
<a href="#l78.76"></a><span id="l78.76">   while (*p != '\0') {</span>
<a href="#l78.77"></a><span id="l78.77">     if (whitespace) {</span>
<a href="#l78.78"></a><span id="l78.78">       if (!isspace(*p)) {</span>
<a href="#l78.79"></a><span id="l78.79" class="difflineat">@@ -232,25 +232,25 @@ static int count_tokens(const char *s) {</span>
<a href="#l78.80"></a><span id="l78.80">         whitespace = 1;</span>
<a href="#l78.81"></a><span id="l78.81">       }</span>
<a href="#l78.82"></a><span id="l78.82">     }</span>
<a href="#l78.83"></a><span id="l78.83">     p++;</span>
<a href="#l78.84"></a><span id="l78.84">   }</span>
<a href="#l78.85"></a><span id="l78.85">   return count;</span>
<a href="#l78.86"></a><span id="l78.86"> }</span>
<a href="#l78.87"></a><span id="l78.87"> </span>
<a href="#l78.88"></a><span id="l78.88" class="difflineminus">-static int read_next_token(const char **s, LDAPsortkey **key) {</span>
<a href="#l78.89"></a><span id="l78.89" class="difflineplus">+static int read_next_token(const char** s, LDAPsortkey** key) {</span>
<a href="#l78.90"></a><span id="l78.90">   char c = 0;</span>
<a href="#l78.91"></a><span id="l78.91" class="difflineminus">-  const char *pos = *s;</span>
<a href="#l78.92"></a><span id="l78.92" class="difflineplus">+  const char* pos = *s;</span>
<a href="#l78.93"></a><span id="l78.93">   int retval = 0;</span>
<a href="#l78.94"></a><span id="l78.94" class="difflineminus">-  LDAPsortkey *new_key = NULL;</span>
<a href="#l78.95"></a><span id="l78.95" class="difflineplus">+  LDAPsortkey* new_key = NULL;</span>
<a href="#l78.96"></a><span id="l78.96"> </span>
<a href="#l78.97"></a><span id="l78.97" class="difflineminus">-  const char *matchrule_source = NULL;</span>
<a href="#l78.98"></a><span id="l78.98" class="difflineplus">+  const char* matchrule_source = NULL;</span>
<a href="#l78.99"></a><span id="l78.99">   int matchrule_size = 0;</span>
<a href="#l78.100"></a><span id="l78.100" class="difflineminus">-  const char *attrdesc_source = NULL;</span>
<a href="#l78.101"></a><span id="l78.101" class="difflineplus">+  const char* attrdesc_source = NULL;</span>
<a href="#l78.102"></a><span id="l78.102">   int attrdesc_size = 0;</span>
<a href="#l78.103"></a><span id="l78.103">   int reverse = 0;</span>
<a href="#l78.104"></a><span id="l78.104"> </span>
<a href="#l78.105"></a><span id="l78.105">   int state = 0;</span>
<a href="#l78.106"></a><span id="l78.106"> </span>
<a href="#l78.107"></a><span id="l78.107">   while (((c = *pos++) != '\0') &amp;&amp; (state != 4)) {</span>
<a href="#l78.108"></a><span id="l78.108">     switch (state) {</span>
<a href="#l78.109"></a><span id="l78.109">       case 0:</span>
<a href="#l78.110"></a><span id="l78.110" class="difflineat">@@ -314,25 +314,25 @@ static int read_next_token(const char **</span>
<a href="#l78.111"></a><span id="l78.111">     attrdesc_size = (pos - attrdesc_source) - 1;</span>
<a href="#l78.112"></a><span id="l78.112">   }</span>
<a href="#l78.113"></a><span id="l78.113"> </span>
<a href="#l78.114"></a><span id="l78.114">   if (NULL == attrdesc_source) {</span>
<a href="#l78.115"></a><span id="l78.115">     /* Didn't find anything */</span>
<a href="#l78.116"></a><span id="l78.116">     return -1;</span>
<a href="#l78.117"></a><span id="l78.117">   }</span>
<a href="#l78.118"></a><span id="l78.118"> </span>
<a href="#l78.119"></a><span id="l78.119" class="difflineminus">-  new_key = (LDAPsortkey *)NSLDAPI_MALLOC(sizeof(LDAPsortkey));</span>
<a href="#l78.120"></a><span id="l78.120" class="difflineplus">+  new_key = (LDAPsortkey*)NSLDAPI_MALLOC(sizeof(LDAPsortkey));</span>
<a href="#l78.121"></a><span id="l78.121">   if (0 == new_key) {</span>
<a href="#l78.122"></a><span id="l78.122">     return LDAP_NO_MEMORY;</span>
<a href="#l78.123"></a><span id="l78.123">   }</span>
<a href="#l78.124"></a><span id="l78.124"> </span>
<a href="#l78.125"></a><span id="l78.125">   /* Allocate the strings */</span>
<a href="#l78.126"></a><span id="l78.126" class="difflineminus">-  new_key-&gt;sk_attrtype = (char *)NSLDAPI_MALLOC(attrdesc_size + 1);</span>
<a href="#l78.127"></a><span id="l78.127" class="difflineplus">+  new_key-&gt;sk_attrtype = (char*)NSLDAPI_MALLOC(attrdesc_size + 1);</span>
<a href="#l78.128"></a><span id="l78.128">   if (NULL != matchrule_source) {</span>
<a href="#l78.129"></a><span id="l78.129" class="difflineminus">-    new_key-&gt;sk_matchruleoid = (char *)NSLDAPI_MALLOC(matchrule_size + 1);</span>
<a href="#l78.130"></a><span id="l78.130" class="difflineplus">+    new_key-&gt;sk_matchruleoid = (char*)NSLDAPI_MALLOC(matchrule_size + 1);</span>
<a href="#l78.131"></a><span id="l78.131">   } else {</span>
<a href="#l78.132"></a><span id="l78.132">     new_key-&gt;sk_matchruleoid = NULL;</span>
<a href="#l78.133"></a><span id="l78.133">   }</span>
<a href="#l78.134"></a><span id="l78.134">   /* Copy over the strings */</span>
<a href="#l78.135"></a><span id="l78.135">   memcpy(new_key-&gt;sk_attrtype, attrdesc_source, attrdesc_size);</span>
<a href="#l78.136"></a><span id="l78.136">   *(new_key-&gt;sk_attrtype + attrdesc_size) = '\0';</span>
<a href="#l78.137"></a><span id="l78.137">   if (NULL != matchrule_source) {</span>
<a href="#l78.138"></a><span id="l78.138">     memcpy(new_key-&gt;sk_matchruleoid, matchrule_source, matchrule_size);</span>
<a href="#l78.139"></a><span id="l78.139" class="difflineat">@@ -341,21 +341,21 @@ static int read_next_token(const char **</span>
<a href="#l78.140"></a><span id="l78.140"> </span>
<a href="#l78.141"></a><span id="l78.141">   new_key-&gt;sk_reverseorder = reverse;</span>
<a href="#l78.142"></a><span id="l78.142"> </span>
<a href="#l78.143"></a><span id="l78.143">   *s = pos - 1;</span>
<a href="#l78.144"></a><span id="l78.144">   *key = new_key;</span>
<a href="#l78.145"></a><span id="l78.145">   return retval;</span>
<a href="#l78.146"></a><span id="l78.146"> }</span>
<a href="#l78.147"></a><span id="l78.147"> </span>
<a href="#l78.148"></a><span id="l78.148" class="difflineminus">-int LDAP_CALL ldap_create_sort_keylist(LDAPsortkey ***sortKeyList,</span>
<a href="#l78.149"></a><span id="l78.149" class="difflineminus">-                                       const char *string_rep) {</span>
<a href="#l78.150"></a><span id="l78.150" class="difflineplus">+int LDAP_CALL ldap_create_sort_keylist(LDAPsortkey*** sortKeyList,</span>
<a href="#l78.151"></a><span id="l78.151" class="difflineplus">+                                       const char* string_rep) {</span>
<a href="#l78.152"></a><span id="l78.152">   int count = 0;</span>
<a href="#l78.153"></a><span id="l78.153" class="difflineminus">-  LDAPsortkey **pointer_array = NULL;</span>
<a href="#l78.154"></a><span id="l78.154" class="difflineminus">-  const char *current_position = NULL;</span>
<a href="#l78.155"></a><span id="l78.155" class="difflineplus">+  LDAPsortkey** pointer_array = NULL;</span>
<a href="#l78.156"></a><span id="l78.156" class="difflineplus">+  const char* current_position = NULL;</span>
<a href="#l78.157"></a><span id="l78.157">   int retval = 0;</span>
<a href="#l78.158"></a><span id="l78.158">   int i = 0;</span>
<a href="#l78.159"></a><span id="l78.159"> </span>
<a href="#l78.160"></a><span id="l78.160">   /* Figure out how many there are */</span>
<a href="#l78.161"></a><span id="l78.161">   if (NULL == string_rep) {</span>
<a href="#l78.162"></a><span id="l78.162">     return LDAP_PARAM_ERROR;</span>
<a href="#l78.163"></a><span id="l78.163">   }</span>
<a href="#l78.164"></a><span id="l78.164">   if (NULL == sortKeyList) {</span>
<a href="#l78.165"></a><span id="l78.165" class="difflineat">@@ -363,17 +363,17 @@ int LDAP_CALL ldap_create_sort_keylist(L</span>
<a href="#l78.166"></a><span id="l78.166">   }</span>
<a href="#l78.167"></a><span id="l78.167">   count = count_tokens(string_rep);</span>
<a href="#l78.168"></a><span id="l78.168">   if (0 == count) {</span>
<a href="#l78.169"></a><span id="l78.169">     *sortKeyList = NULL;</span>
<a href="#l78.170"></a><span id="l78.170">     return LDAP_PARAM_ERROR;</span>
<a href="#l78.171"></a><span id="l78.171">   }</span>
<a href="#l78.172"></a><span id="l78.172">   /* Allocate enough memory for the pointers */</span>
<a href="#l78.173"></a><span id="l78.173">   pointer_array =</span>
<a href="#l78.174"></a><span id="l78.174" class="difflineminus">-      (LDAPsortkey **)NSLDAPI_MALLOC(sizeof(LDAPsortkey *) * (count + 1));</span>
<a href="#l78.175"></a><span id="l78.175" class="difflineplus">+      (LDAPsortkey**)NSLDAPI_MALLOC(sizeof(LDAPsortkey*) * (count + 1));</span>
<a href="#l78.176"></a><span id="l78.176">   if (NULL == pointer_array) {</span>
<a href="#l78.177"></a><span id="l78.177">     return LDAP_NO_MEMORY;</span>
<a href="#l78.178"></a><span id="l78.178">   }</span>
<a href="#l78.179"></a><span id="l78.179">   /* Now walk along the string, allocating and filling in the LDAPsearchkey</span>
<a href="#l78.180"></a><span id="l78.180">    * structure */</span>
<a href="#l78.181"></a><span id="l78.181">   current_position = string_rep;</span>
<a href="#l78.182"></a><span id="l78.182"> </span>
<a href="#l78.183"></a><span id="l78.183">   for (i = 0; i &lt; count; i++) {</span>
<a href="#l78.184"></a><span id="l78.184" class="difflineat">@@ -385,18 +385,18 @@ int LDAP_CALL ldap_create_sort_keylist(L</span>
<a href="#l78.185"></a><span id="l78.185">       return retval;</span>
<a href="#l78.186"></a><span id="l78.186">     }</span>
<a href="#l78.187"></a><span id="l78.187">   }</span>
<a href="#l78.188"></a><span id="l78.188">   pointer_array[count] = NULL;</span>
<a href="#l78.189"></a><span id="l78.189">   *sortKeyList = pointer_array;</span>
<a href="#l78.190"></a><span id="l78.190">   return LDAP_SUCCESS;</span>
<a href="#l78.191"></a><span id="l78.191"> }</span>
<a href="#l78.192"></a><span id="l78.192"> </span>
<a href="#l78.193"></a><span id="l78.193" class="difflineminus">-void LDAP_CALL ldap_free_sort_keylist(LDAPsortkey **sortKeyList) {</span>
<a href="#l78.194"></a><span id="l78.194" class="difflineminus">-  LDAPsortkey *this_one = NULL;</span>
<a href="#l78.195"></a><span id="l78.195" class="difflineplus">+void LDAP_CALL ldap_free_sort_keylist(LDAPsortkey** sortKeyList) {</span>
<a href="#l78.196"></a><span id="l78.196" class="difflineplus">+  LDAPsortkey* this_one = NULL;</span>
<a href="#l78.197"></a><span id="l78.197">   int i = 0;</span>
<a href="#l78.198"></a><span id="l78.198"> </span>
<a href="#l78.199"></a><span id="l78.199">   if (NULL == sortKeyList) {</span>
<a href="#l78.200"></a><span id="l78.200">     return;</span>
<a href="#l78.201"></a><span id="l78.201">   }</span>
<a href="#l78.202"></a><span id="l78.202"> </span>
<a href="#l78.203"></a><span id="l78.203">   /* Walk down the list freeing the LDAPsortkey structures */</span>
<a href="#l78.204"></a><span id="l78.204">   for (this_one = sortKeyList[0]; this_one; this_one = sortKeyList[++i]) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l79.1"></a><span id="l79.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/srchpref.c</span>
<a href="#l79.2"></a><span id="l79.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/srchpref.c</span>
<a href="#l79.3"></a><span id="l79.3" class="difflineat">@@ -48,30 +48,30 @@</span>
<a href="#l79.4"></a><span id="l79.4">  */</span>
<a href="#l79.5"></a><span id="l79.5"> /*</span>
<a href="#l79.6"></a><span id="l79.6">  * searchpref.c:  search preferences library routines for LDAP clients</span>
<a href="#l79.7"></a><span id="l79.7">  */</span>
<a href="#l79.8"></a><span id="l79.8"> </span>
<a href="#l79.9"></a><span id="l79.9"> #include &quot;ldap-int.h&quot;</span>
<a href="#l79.10"></a><span id="l79.10"> #include &quot;srchpref.h&quot;</span>
<a href="#l79.11"></a><span id="l79.11"> </span>
<a href="#l79.12"></a><span id="l79.12" class="difflineminus">-static void free_searchobj(struct ldap_searchobj *so);</span>
<a href="#l79.13"></a><span id="l79.13" class="difflineminus">-static int read_next_searchobj(char **bufp, long *blenp,</span>
<a href="#l79.14"></a><span id="l79.14" class="difflineminus">-                               struct ldap_searchobj **sop, int soversion);</span>
<a href="#l79.15"></a><span id="l79.15" class="difflineplus">+static void free_searchobj(struct ldap_searchobj* so);</span>
<a href="#l79.16"></a><span id="l79.16" class="difflineplus">+static int read_next_searchobj(char** bufp, long* blenp,</span>
<a href="#l79.17"></a><span id="l79.17" class="difflineplus">+                               struct ldap_searchobj** sop, int soversion);</span>
<a href="#l79.18"></a><span id="l79.18"> </span>
<a href="#l79.19"></a><span id="l79.19" class="difflineminus">-static char *sobjoptions[] = {&quot;internal&quot;, NULL};</span>
<a href="#l79.20"></a><span id="l79.20" class="difflineplus">+static char* sobjoptions[] = {&quot;internal&quot;, NULL};</span>
<a href="#l79.21"></a><span id="l79.21"> </span>
<a href="#l79.22"></a><span id="l79.22"> static unsigned long sobjoptvals[] = {</span>
<a href="#l79.23"></a><span id="l79.23">     LDAP_SEARCHOBJ_OPT_INTERNAL,</span>
<a href="#l79.24"></a><span id="l79.24"> };</span>
<a href="#l79.25"></a><span id="l79.25"> </span>
<a href="#l79.26"></a><span id="l79.26" class="difflineminus">-int LDAP_CALL ldap_init_searchprefs(char *file,</span>
<a href="#l79.27"></a><span id="l79.27" class="difflineminus">-                                    struct ldap_searchobj **solistp) {</span>
<a href="#l79.28"></a><span id="l79.28" class="difflineminus">-  FILE *fp;</span>
<a href="#l79.29"></a><span id="l79.29" class="difflineminus">-  char *buf;</span>
<a href="#l79.30"></a><span id="l79.30" class="difflineplus">+int LDAP_CALL ldap_init_searchprefs(char* file,</span>
<a href="#l79.31"></a><span id="l79.31" class="difflineplus">+                                    struct ldap_searchobj** solistp) {</span>
<a href="#l79.32"></a><span id="l79.32" class="difflineplus">+  FILE* fp;</span>
<a href="#l79.33"></a><span id="l79.33" class="difflineplus">+  char* buf;</span>
<a href="#l79.34"></a><span id="l79.34">   long rlen, len;</span>
<a href="#l79.35"></a><span id="l79.35">   int rc, eof;</span>
<a href="#l79.36"></a><span id="l79.36"> </span>
<a href="#l79.37"></a><span id="l79.37">   if ((fp = NSLDAPI_FOPEN(file, &quot;r&quot;)) == NULL) {</span>
<a href="#l79.38"></a><span id="l79.38">     return (LDAP_SEARCHPREF_ERR_FILE);</span>
<a href="#l79.39"></a><span id="l79.39">   }</span>
<a href="#l79.40"></a><span id="l79.40"> </span>
<a href="#l79.41"></a><span id="l79.41">   if (fseek(fp, 0L, SEEK_END) != 0) { /* move to end to get len */</span>
<a href="#l79.42"></a><span id="l79.42" class="difflineat">@@ -101,20 +101,20 @@ int LDAP_CALL ldap_init_searchprefs(char</span>
<a href="#l79.43"></a><span id="l79.43">   }</span>
<a href="#l79.44"></a><span id="l79.44"> </span>
<a href="#l79.45"></a><span id="l79.45">   rc = ldap_init_searchprefs_buf(buf, rlen, solistp);</span>
<a href="#l79.46"></a><span id="l79.46">   NSLDAPI_FREE(buf);</span>
<a href="#l79.47"></a><span id="l79.47"> </span>
<a href="#l79.48"></a><span id="l79.48">   return (rc);</span>
<a href="#l79.49"></a><span id="l79.49"> }</span>
<a href="#l79.50"></a><span id="l79.50"> </span>
<a href="#l79.51"></a><span id="l79.51" class="difflineminus">-int LDAP_CALL ldap_init_searchprefs_buf(char *buf, long buflen,</span>
<a href="#l79.52"></a><span id="l79.52" class="difflineminus">-                                        struct ldap_searchobj **solistp) {</span>
<a href="#l79.53"></a><span id="l79.53" class="difflineplus">+int LDAP_CALL ldap_init_searchprefs_buf(char* buf, long buflen,</span>
<a href="#l79.54"></a><span id="l79.54" class="difflineplus">+                                        struct ldap_searchobj** solistp) {</span>
<a href="#l79.55"></a><span id="l79.55">   int rc = 0, version;</span>
<a href="#l79.56"></a><span id="l79.56" class="difflineminus">-  char **toks;</span>
<a href="#l79.57"></a><span id="l79.57" class="difflineplus">+  char** toks;</span>
<a href="#l79.58"></a><span id="l79.58">   struct ldap_searchobj *prevso, *so;</span>
<a href="#l79.59"></a><span id="l79.59"> </span>
<a href="#l79.60"></a><span id="l79.60">   *solistp = prevso = NULLSEARCHOBJ;</span>
<a href="#l79.61"></a><span id="l79.61"> </span>
<a href="#l79.62"></a><span id="l79.62">   if (nsldapi_next_line_tokens(&amp;buf, &amp;buflen, &amp;toks) != 2 ||</span>
<a href="#l79.63"></a><span id="l79.63">       strcasecmp(toks[0], &quot;version&quot;) != 0) {</span>
<a href="#l79.64"></a><span id="l79.64">     nsldapi_free_strarray(toks);</span>
<a href="#l79.65"></a><span id="l79.65">     return (LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.66"></a><span id="l79.66" class="difflineat">@@ -139,29 +139,29 @@ int LDAP_CALL ldap_init_searchprefs_buf(</span>
<a href="#l79.67"></a><span id="l79.67"> </span>
<a href="#l79.68"></a><span id="l79.68">   if (rc != 0) {</span>
<a href="#l79.69"></a><span id="l79.69">     ldap_free_searchprefs(*solistp);</span>
<a href="#l79.70"></a><span id="l79.70">   }</span>
<a href="#l79.71"></a><span id="l79.71"> </span>
<a href="#l79.72"></a><span id="l79.72">   return (rc);</span>
<a href="#l79.73"></a><span id="l79.73"> }</span>
<a href="#l79.74"></a><span id="l79.74"> </span>
<a href="#l79.75"></a><span id="l79.75" class="difflineminus">-void LDAP_CALL ldap_free_searchprefs(struct ldap_searchobj *solist) {</span>
<a href="#l79.76"></a><span id="l79.76" class="difflineplus">+void LDAP_CALL ldap_free_searchprefs(struct ldap_searchobj* solist) {</span>
<a href="#l79.77"></a><span id="l79.77">   struct ldap_searchobj *so, *nextso;</span>
<a href="#l79.78"></a><span id="l79.78"> </span>
<a href="#l79.79"></a><span id="l79.79">   if (solist != NULL) {</span>
<a href="#l79.80"></a><span id="l79.80">     for (so = solist; so != NULL; so = nextso) {</span>
<a href="#l79.81"></a><span id="l79.81">       nextso = so-&gt;so_next;</span>
<a href="#l79.82"></a><span id="l79.82">       free_searchobj(so);</span>
<a href="#l79.83"></a><span id="l79.83">     }</span>
<a href="#l79.84"></a><span id="l79.84">   }</span>
<a href="#l79.85"></a><span id="l79.85">   /* XXX XXX need to do some work here */</span>
<a href="#l79.86"></a><span id="l79.86"> }</span>
<a href="#l79.87"></a><span id="l79.87"> </span>
<a href="#l79.88"></a><span id="l79.88" class="difflineminus">-static void free_searchobj(struct ldap_searchobj *so) {</span>
<a href="#l79.89"></a><span id="l79.89" class="difflineplus">+static void free_searchobj(struct ldap_searchobj* so) {</span>
<a href="#l79.90"></a><span id="l79.90">   if (so != NULL) {</span>
<a href="#l79.91"></a><span id="l79.91">     if (so-&gt;so_objtypeprompt != NULL) {</span>
<a href="#l79.92"></a><span id="l79.92">       NSLDAPI_FREE(so-&gt;so_objtypeprompt);</span>
<a href="#l79.93"></a><span id="l79.93">     }</span>
<a href="#l79.94"></a><span id="l79.94">     if (so-&gt;so_prompt != NULL) {</span>
<a href="#l79.95"></a><span id="l79.95">       NSLDAPI_FREE(so-&gt;so_prompt);</span>
<a href="#l79.96"></a><span id="l79.96">     }</span>
<a href="#l79.97"></a><span id="l79.97">     if (so-&gt;so_filterprefix != NULL) {</span>
<a href="#l79.98"></a><span id="l79.98" class="difflineat">@@ -207,51 +207,51 @@ static void free_searchobj(struct ldap_s</span>
<a href="#l79.99"></a><span id="l79.99">         }</span>
<a href="#l79.100"></a><span id="l79.100">         NSLDAPI_FREE(sm);</span>
<a href="#l79.101"></a><span id="l79.101">       }</span>
<a href="#l79.102"></a><span id="l79.102">     }</span>
<a href="#l79.103"></a><span id="l79.103">     NSLDAPI_FREE(so);</span>
<a href="#l79.104"></a><span id="l79.104">   }</span>
<a href="#l79.105"></a><span id="l79.105"> }</span>
<a href="#l79.106"></a><span id="l79.106"> </span>
<a href="#l79.107"></a><span id="l79.107" class="difflineminus">-struct ldap_searchobj *LDAP_CALL</span>
<a href="#l79.108"></a><span id="l79.108" class="difflineminus">-ldap_first_searchobj(struct ldap_searchobj *solist) {</span>
<a href="#l79.109"></a><span id="l79.109" class="difflineplus">+struct ldap_searchobj* LDAP_CALL</span>
<a href="#l79.110"></a><span id="l79.110" class="difflineplus">+ldap_first_searchobj(struct ldap_searchobj* solist) {</span>
<a href="#l79.111"></a><span id="l79.111">   return (solist);</span>
<a href="#l79.112"></a><span id="l79.112"> }</span>
<a href="#l79.113"></a><span id="l79.113"> </span>
<a href="#l79.114"></a><span id="l79.114" class="difflineminus">-struct ldap_searchobj *LDAP_CALL</span>
<a href="#l79.115"></a><span id="l79.115" class="difflineminus">-ldap_next_searchobj(struct ldap_searchobj *solist, struct ldap_searchobj *so) {</span>
<a href="#l79.116"></a><span id="l79.116" class="difflineplus">+struct ldap_searchobj* LDAP_CALL</span>
<a href="#l79.117"></a><span id="l79.117" class="difflineplus">+ldap_next_searchobj(struct ldap_searchobj* solist, struct ldap_searchobj* so) {</span>
<a href="#l79.118"></a><span id="l79.118">   return (so == NULLSEARCHOBJ ? so : so-&gt;so_next);</span>
<a href="#l79.119"></a><span id="l79.119"> }</span>
<a href="#l79.120"></a><span id="l79.120"> </span>
<a href="#l79.121"></a><span id="l79.121" class="difflineminus">-static int read_next_searchobj(char **bufp, long *blenp,</span>
<a href="#l79.122"></a><span id="l79.122" class="difflineminus">-                               struct ldap_searchobj **sop, int soversion) {</span>
<a href="#l79.123"></a><span id="l79.123" class="difflineplus">+static int read_next_searchobj(char** bufp, long* blenp,</span>
<a href="#l79.124"></a><span id="l79.124" class="difflineplus">+                               struct ldap_searchobj** sop, int soversion) {</span>
<a href="#l79.125"></a><span id="l79.125">   int i, j, tokcnt;</span>
<a href="#l79.126"></a><span id="l79.126" class="difflineminus">-  char **toks;</span>
<a href="#l79.127"></a><span id="l79.127" class="difflineminus">-  struct ldap_searchobj *so;</span>
<a href="#l79.128"></a><span id="l79.128" class="difflineminus">-  struct ldap_searchattr **sa;</span>
<a href="#l79.129"></a><span id="l79.129" class="difflineminus">-  struct ldap_searchmatch **sm;</span>
<a href="#l79.130"></a><span id="l79.130" class="difflineplus">+  char** toks;</span>
<a href="#l79.131"></a><span id="l79.131" class="difflineplus">+  struct ldap_searchobj* so;</span>
<a href="#l79.132"></a><span id="l79.132" class="difflineplus">+  struct ldap_searchattr** sa;</span>
<a href="#l79.133"></a><span id="l79.133" class="difflineplus">+  struct ldap_searchmatch** sm;</span>
<a href="#l79.134"></a><span id="l79.134"> </span>
<a href="#l79.135"></a><span id="l79.135">   *sop = NULL;</span>
<a href="#l79.136"></a><span id="l79.136"> </span>
<a href="#l79.137"></a><span id="l79.137">   /*</span>
<a href="#l79.138"></a><span id="l79.138">    * Object type prompt comes first</span>
<a href="#l79.139"></a><span id="l79.139">    */</span>
<a href="#l79.140"></a><span id="l79.140">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l79.141"></a><span id="l79.141">     nsldapi_free_strarray(toks);</span>
<a href="#l79.142"></a><span id="l79.142">     return (tokcnt == 0 ? 0 : LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.143"></a><span id="l79.143">   }</span>
<a href="#l79.144"></a><span id="l79.144"> </span>
<a href="#l79.145"></a><span id="l79.145" class="difflineminus">-  if ((so = (struct ldap_searchobj *)NSLDAPI_CALLOC(</span>
<a href="#l79.146"></a><span id="l79.146" class="difflineplus">+  if ((so = (struct ldap_searchobj*)NSLDAPI_CALLOC(</span>
<a href="#l79.147"></a><span id="l79.147">            1, sizeof(struct ldap_searchobj))) == NULL) {</span>
<a href="#l79.148"></a><span id="l79.148">     nsldapi_free_strarray(toks);</span>
<a href="#l79.149"></a><span id="l79.149">     return (LDAP_SEARCHPREF_ERR_MEM);</span>
<a href="#l79.150"></a><span id="l79.150">   }</span>
<a href="#l79.151"></a><span id="l79.151">   so-&gt;so_objtypeprompt = toks[0];</span>
<a href="#l79.152"></a><span id="l79.152" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l79.153"></a><span id="l79.153" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l79.154"></a><span id="l79.154"> </span>
<a href="#l79.155"></a><span id="l79.155">   /*</span>
<a href="#l79.156"></a><span id="l79.156">    * if this is post-version zero, options come next</span>
<a href="#l79.157"></a><span id="l79.157">    */</span>
<a href="#l79.158"></a><span id="l79.158">   if (soversion &gt; LDAP_SEARCHPREF_VERSION_ZERO) {</span>
<a href="#l79.159"></a><span id="l79.159">     if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) &lt; 1) {</span>
<a href="#l79.160"></a><span id="l79.160">       nsldapi_free_strarray(toks);</span>
<a href="#l79.161"></a><span id="l79.161">       ldap_free_searchprefs(so);</span>
<a href="#l79.162"></a><span id="l79.162" class="difflineat">@@ -271,61 +271,61 @@ static int read_next_searchobj(char **bu</span>
<a href="#l79.163"></a><span id="l79.163">    * &quot;Fewer choices&quot; prompt is next</span>
<a href="#l79.164"></a><span id="l79.164">    */</span>
<a href="#l79.165"></a><span id="l79.165">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l79.166"></a><span id="l79.166">     nsldapi_free_strarray(toks);</span>
<a href="#l79.167"></a><span id="l79.167">     ldap_free_searchprefs(so);</span>
<a href="#l79.168"></a><span id="l79.168">     return (LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.169"></a><span id="l79.169">   }</span>
<a href="#l79.170"></a><span id="l79.170">   so-&gt;so_prompt = toks[0];</span>
<a href="#l79.171"></a><span id="l79.171" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l79.172"></a><span id="l79.172" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l79.173"></a><span id="l79.173"> </span>
<a href="#l79.174"></a><span id="l79.174">   /*</span>
<a href="#l79.175"></a><span id="l79.175">    * Filter prefix for &quot;More Choices&quot; searching is next</span>
<a href="#l79.176"></a><span id="l79.176">    */</span>
<a href="#l79.177"></a><span id="l79.177">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l79.178"></a><span id="l79.178">     nsldapi_free_strarray(toks);</span>
<a href="#l79.179"></a><span id="l79.179">     ldap_free_searchprefs(so);</span>
<a href="#l79.180"></a><span id="l79.180">     return (LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.181"></a><span id="l79.181">   }</span>
<a href="#l79.182"></a><span id="l79.182">   so-&gt;so_filterprefix = toks[0];</span>
<a href="#l79.183"></a><span id="l79.183" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l79.184"></a><span id="l79.184" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l79.185"></a><span id="l79.185"> </span>
<a href="#l79.186"></a><span id="l79.186">   /*</span>
<a href="#l79.187"></a><span id="l79.187">    * &quot;Fewer Choices&quot; filter tag comes next</span>
<a href="#l79.188"></a><span id="l79.188">    */</span>
<a href="#l79.189"></a><span id="l79.189">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l79.190"></a><span id="l79.190">     nsldapi_free_strarray(toks);</span>
<a href="#l79.191"></a><span id="l79.191">     ldap_free_searchprefs(so);</span>
<a href="#l79.192"></a><span id="l79.192">     return (LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.193"></a><span id="l79.193">   }</span>
<a href="#l79.194"></a><span id="l79.194">   so-&gt;so_filtertag = toks[0];</span>
<a href="#l79.195"></a><span id="l79.195" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l79.196"></a><span id="l79.196" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l79.197"></a><span id="l79.197"> </span>
<a href="#l79.198"></a><span id="l79.198">   /*</span>
<a href="#l79.199"></a><span id="l79.199">    * Selection (disambiguation) attribute comes next</span>
<a href="#l79.200"></a><span id="l79.200">    */</span>
<a href="#l79.201"></a><span id="l79.201">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l79.202"></a><span id="l79.202">     nsldapi_free_strarray(toks);</span>
<a href="#l79.203"></a><span id="l79.203">     ldap_free_searchprefs(so);</span>
<a href="#l79.204"></a><span id="l79.204">     return (LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.205"></a><span id="l79.205">   }</span>
<a href="#l79.206"></a><span id="l79.206">   so-&gt;so_defaultselectattr = toks[0];</span>
<a href="#l79.207"></a><span id="l79.207" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l79.208"></a><span id="l79.208" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l79.209"></a><span id="l79.209"> </span>
<a href="#l79.210"></a><span id="l79.210">   /*</span>
<a href="#l79.211"></a><span id="l79.211">    * Label for selection (disambiguation) attribute</span>
<a href="#l79.212"></a><span id="l79.212">    */</span>
<a href="#l79.213"></a><span id="l79.213">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l79.214"></a><span id="l79.214">     nsldapi_free_strarray(toks);</span>
<a href="#l79.215"></a><span id="l79.215">     ldap_free_searchprefs(so);</span>
<a href="#l79.216"></a><span id="l79.216">     return (LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.217"></a><span id="l79.217">   }</span>
<a href="#l79.218"></a><span id="l79.218">   so-&gt;so_defaultselecttext = toks[0];</span>
<a href="#l79.219"></a><span id="l79.219" class="difflineminus">-  NSLDAPI_FREE((char *)toks);</span>
<a href="#l79.220"></a><span id="l79.220" class="difflineplus">+  NSLDAPI_FREE((char*)toks);</span>
<a href="#l79.221"></a><span id="l79.221"> </span>
<a href="#l79.222"></a><span id="l79.222">   /*</span>
<a href="#l79.223"></a><span id="l79.223">    * Search scope is next</span>
<a href="#l79.224"></a><span id="l79.224">    */</span>
<a href="#l79.225"></a><span id="l79.225">   if ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) != 1) {</span>
<a href="#l79.226"></a><span id="l79.226">     nsldapi_free_strarray(toks);</span>
<a href="#l79.227"></a><span id="l79.227">     ldap_free_searchprefs(so);</span>
<a href="#l79.228"></a><span id="l79.228">     return (LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.229"></a><span id="l79.229" class="difflineat">@@ -347,17 +347,17 @@ static int read_next_searchobj(char **bu</span>
<a href="#l79.230"></a><span id="l79.230">    */</span>
<a href="#l79.231"></a><span id="l79.231">   sa = &amp;(so-&gt;so_salist);</span>
<a href="#l79.232"></a><span id="l79.232">   while ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) &gt; 0) {</span>
<a href="#l79.233"></a><span id="l79.233">     if (tokcnt &lt; 5) {</span>
<a href="#l79.234"></a><span id="l79.234">       nsldapi_free_strarray(toks);</span>
<a href="#l79.235"></a><span id="l79.235">       ldap_free_searchprefs(so);</span>
<a href="#l79.236"></a><span id="l79.236">       return (LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.237"></a><span id="l79.237">     }</span>
<a href="#l79.238"></a><span id="l79.238" class="difflineminus">-    if ((*sa = (struct ldap_searchattr *)NSLDAPI_CALLOC(</span>
<a href="#l79.239"></a><span id="l79.239" class="difflineplus">+    if ((*sa = (struct ldap_searchattr*)NSLDAPI_CALLOC(</span>
<a href="#l79.240"></a><span id="l79.240">              1, sizeof(struct ldap_searchattr))) == NULL) {</span>
<a href="#l79.241"></a><span id="l79.241">       nsldapi_free_strarray(toks);</span>
<a href="#l79.242"></a><span id="l79.242">       ldap_free_searchprefs(so);</span>
<a href="#l79.243"></a><span id="l79.243">       return (LDAP_SEARCHPREF_ERR_MEM);</span>
<a href="#l79.244"></a><span id="l79.244">     }</span>
<a href="#l79.245"></a><span id="l79.245">     (*sa)-&gt;sa_attrlabel = toks[0];</span>
<a href="#l79.246"></a><span id="l79.246">     (*sa)-&gt;sa_attr = toks[1];</span>
<a href="#l79.247"></a><span id="l79.247">     (*sa)-&gt;sa_selectattr = toks[3];</span>
<a href="#l79.248"></a><span id="l79.248" class="difflineat">@@ -365,39 +365,39 @@ static int read_next_searchobj(char **bu</span>
<a href="#l79.249"></a><span id="l79.249">     /* Deal with bitmap */</span>
<a href="#l79.250"></a><span id="l79.250">     (*sa)-&gt;sa_matchtypebitmap = 0;</span>
<a href="#l79.251"></a><span id="l79.251">     for (i = strlen(toks[2]) - 1, j = 0; i &gt;= 0; i--, j++) {</span>
<a href="#l79.252"></a><span id="l79.252">       if (toks[2][i] == '1') {</span>
<a href="#l79.253"></a><span id="l79.253">         (*sa)-&gt;sa_matchtypebitmap |= (1 &lt;&lt; j);</span>
<a href="#l79.254"></a><span id="l79.254">       }</span>
<a href="#l79.255"></a><span id="l79.255">     }</span>
<a href="#l79.256"></a><span id="l79.256">     NSLDAPI_FREE(toks[2]);</span>
<a href="#l79.257"></a><span id="l79.257" class="difflineminus">-    NSLDAPI_FREE((char *)toks);</span>
<a href="#l79.258"></a><span id="l79.258" class="difflineplus">+    NSLDAPI_FREE((char*)toks);</span>
<a href="#l79.259"></a><span id="l79.259">     sa = &amp;((*sa)-&gt;sa_next);</span>
<a href="#l79.260"></a><span id="l79.260">   }</span>
<a href="#l79.261"></a><span id="l79.261">   *sa = NULL;</span>
<a href="#l79.262"></a><span id="l79.262"> </span>
<a href="#l79.263"></a><span id="l79.263">   /*</span>
<a href="#l79.264"></a><span id="l79.264">    * Match types are last</span>
<a href="#l79.265"></a><span id="l79.265">    */</span>
<a href="#l79.266"></a><span id="l79.266">   sm = &amp;(so-&gt;so_smlist);</span>
<a href="#l79.267"></a><span id="l79.267">   while ((tokcnt = nsldapi_next_line_tokens(bufp, blenp, &amp;toks)) &gt; 0) {</span>
<a href="#l79.268"></a><span id="l79.268">     if (tokcnt &lt; 2) {</span>
<a href="#l79.269"></a><span id="l79.269">       nsldapi_free_strarray(toks);</span>
<a href="#l79.270"></a><span id="l79.270">       ldap_free_searchprefs(so);</span>
<a href="#l79.271"></a><span id="l79.271">       return (LDAP_SEARCHPREF_ERR_SYNTAX);</span>
<a href="#l79.272"></a><span id="l79.272">     }</span>
<a href="#l79.273"></a><span id="l79.273" class="difflineminus">-    if ((*sm = (struct ldap_searchmatch *)NSLDAPI_CALLOC(</span>
<a href="#l79.274"></a><span id="l79.274" class="difflineplus">+    if ((*sm = (struct ldap_searchmatch*)NSLDAPI_CALLOC(</span>
<a href="#l79.275"></a><span id="l79.275">              1, sizeof(struct ldap_searchmatch))) == NULL) {</span>
<a href="#l79.276"></a><span id="l79.276">       nsldapi_free_strarray(toks);</span>
<a href="#l79.277"></a><span id="l79.277">       ldap_free_searchprefs(so);</span>
<a href="#l79.278"></a><span id="l79.278">       return (LDAP_SEARCHPREF_ERR_MEM);</span>
<a href="#l79.279"></a><span id="l79.279">     }</span>
<a href="#l79.280"></a><span id="l79.280">     (*sm)-&gt;sm_matchprompt = toks[0];</span>
<a href="#l79.281"></a><span id="l79.281">     (*sm)-&gt;sm_filter = toks[1];</span>
<a href="#l79.282"></a><span id="l79.282" class="difflineminus">-    NSLDAPI_FREE((char *)toks);</span>
<a href="#l79.283"></a><span id="l79.283" class="difflineplus">+    NSLDAPI_FREE((char*)toks);</span>
<a href="#l79.284"></a><span id="l79.284">     sm = &amp;((*sm)-&gt;sm_next);</span>
<a href="#l79.285"></a><span id="l79.285">   }</span>
<a href="#l79.286"></a><span id="l79.286">   *sm = NULL;</span>
<a href="#l79.287"></a><span id="l79.287"> </span>
<a href="#l79.288"></a><span id="l79.288">   *sop = so;</span>
<a href="#l79.289"></a><span id="l79.289">   return (0);</span>
<a href="#l79.290"></a><span id="l79.290"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l80.1"></a><span id="l80.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/test.c</span>
<a href="#l80.2"></a><span id="l80.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/test.c</span>
<a href="#l80.3"></a><span id="l80.3" class="difflineat">@@ -87,100 +87,100 @@</span>
<a href="#l80.4"></a><span id="l80.4"> #  include &lt;nss.h&gt;</span>
<a href="#l80.5"></a><span id="l80.5"> #  include &lt;ldap_ssl.h&gt;</span>
<a href="#l80.6"></a><span id="l80.6"> #endif</span>
<a href="#l80.7"></a><span id="l80.7"> </span>
<a href="#l80.8"></a><span id="l80.8"> #if !defined(PCNFS) &amp;&amp; !defined(WINSOCK) &amp;&amp; !defined(MACOS)</span>
<a href="#l80.9"></a><span id="l80.9"> #  define MOD_USE_BVALS</span>
<a href="#l80.10"></a><span id="l80.10"> #endif /* !PCNFS &amp;&amp; !WINSOCK &amp;&amp; !MACOS */</span>
<a href="#l80.11"></a><span id="l80.11"> </span>
<a href="#l80.12"></a><span id="l80.12" class="difflineminus">-static void handle_result(LDAP *ld, LDAPMessage *lm, int onlyone);</span>
<a href="#l80.13"></a><span id="l80.13" class="difflineminus">-static void print_ldap_result(LDAP *ld, LDAPMessage *lm, char *s);</span>
<a href="#l80.14"></a><span id="l80.14" class="difflineminus">-static void print_controls(LDAPControl **ctrls, int freeit);</span>
<a href="#l80.15"></a><span id="l80.15" class="difflineminus">-static void print_referrals(char **refs, int freeit);</span>
<a href="#l80.16"></a><span id="l80.16" class="difflineminus">-static void print_search_entry(LDAP *ld, LDAPMessage *res, int onlyone);</span>
<a href="#l80.17"></a><span id="l80.17" class="difflineminus">-static char *changetype_num2string(ber_int_t chgtype);</span>
<a href="#l80.18"></a><span id="l80.18" class="difflineminus">-static void print_search_reference(LDAP *ld, LDAPMessage *res, int onlyone);</span>
<a href="#l80.19"></a><span id="l80.19" class="difflineminus">-static void free_list(char **list);</span>
<a href="#l80.20"></a><span id="l80.20" class="difflineminus">-static int entry2textwrite(void *fp, char *buf, int len);</span>
<a href="#l80.21"></a><span id="l80.21" class="difflineminus">-static void bprint(char *data, int len);</span>
<a href="#l80.22"></a><span id="l80.22" class="difflineminus">-static char **string2words(char *str, char *delims);</span>
<a href="#l80.23"></a><span id="l80.23" class="difflineminus">-static const char *url_parse_err2string(int e);</span>
<a href="#l80.24"></a><span id="l80.24" class="difflineplus">+static void handle_result(LDAP* ld, LDAPMessage* lm, int onlyone);</span>
<a href="#l80.25"></a><span id="l80.25" class="difflineplus">+static void print_ldap_result(LDAP* ld, LDAPMessage* lm, char* s);</span>
<a href="#l80.26"></a><span id="l80.26" class="difflineplus">+static void print_controls(LDAPControl** ctrls, int freeit);</span>
<a href="#l80.27"></a><span id="l80.27" class="difflineplus">+static void print_referrals(char** refs, int freeit);</span>
<a href="#l80.28"></a><span id="l80.28" class="difflineplus">+static void print_search_entry(LDAP* ld, LDAPMessage* res, int onlyone);</span>
<a href="#l80.29"></a><span id="l80.29" class="difflineplus">+static char* changetype_num2string(ber_int_t chgtype);</span>
<a href="#l80.30"></a><span id="l80.30" class="difflineplus">+static void print_search_reference(LDAP* ld, LDAPMessage* res, int onlyone);</span>
<a href="#l80.31"></a><span id="l80.31" class="difflineplus">+static void free_list(char** list);</span>
<a href="#l80.32"></a><span id="l80.32" class="difflineplus">+static int entry2textwrite(void* fp, char* buf, int len);</span>
<a href="#l80.33"></a><span id="l80.33" class="difflineplus">+static void bprint(char* data, int len);</span>
<a href="#l80.34"></a><span id="l80.34" class="difflineplus">+static char** string2words(char* str, char* delims);</span>
<a href="#l80.35"></a><span id="l80.35" class="difflineplus">+static const char* url_parse_err2string(int e);</span>
<a href="#l80.36"></a><span id="l80.36"> </span>
<a href="#l80.37"></a><span id="l80.37" class="difflineminus">-char *dnsuffix;</span>
<a href="#l80.38"></a><span id="l80.38" class="difflineplus">+char* dnsuffix;</span>
<a href="#l80.39"></a><span id="l80.39"> </span>
<a href="#l80.40"></a><span id="l80.40"> #ifndef WINSOCK</span>
<a href="#l80.41"></a><span id="l80.41" class="difflineminus">-static char *getline(char *line, int len, FILE *fp, char *prompt) {</span>
<a href="#l80.42"></a><span id="l80.42" class="difflineplus">+static char* getline(char* line, int len, FILE* fp, char* prompt) {</span>
<a href="#l80.43"></a><span id="l80.43">   printf(prompt);</span>
<a href="#l80.44"></a><span id="l80.44"> </span>
<a href="#l80.45"></a><span id="l80.45">   if (fgets(line, len, fp) == NULL) return (NULL);</span>
<a href="#l80.46"></a><span id="l80.46"> </span>
<a href="#l80.47"></a><span id="l80.47">   line[strlen(line) - 1] = '\0';</span>
<a href="#l80.48"></a><span id="l80.48"> </span>
<a href="#l80.49"></a><span id="l80.49">   return (line);</span>
<a href="#l80.50"></a><span id="l80.50"> }</span>
<a href="#l80.51"></a><span id="l80.51"> #endif /* WINSOCK */</span>
<a href="#l80.52"></a><span id="l80.52"> </span>
<a href="#l80.53"></a><span id="l80.53" class="difflineminus">-static char **get_list(char *prompt) {</span>
<a href="#l80.54"></a><span id="l80.54" class="difflineplus">+static char** get_list(char* prompt) {</span>
<a href="#l80.55"></a><span id="l80.55">   static char buf[256];</span>
<a href="#l80.56"></a><span id="l80.56">   int num;</span>
<a href="#l80.57"></a><span id="l80.57" class="difflineminus">-  char **result;</span>
<a href="#l80.58"></a><span id="l80.58" class="difflineplus">+  char** result;</span>
<a href="#l80.59"></a><span id="l80.59"> </span>
<a href="#l80.60"></a><span id="l80.60">   num = 0;</span>
<a href="#l80.61"></a><span id="l80.61" class="difflineminus">-  result = (char **)0;</span>
<a href="#l80.62"></a><span id="l80.62" class="difflineplus">+  result = (char**)0;</span>
<a href="#l80.63"></a><span id="l80.63">   while (1) {</span>
<a href="#l80.64"></a><span id="l80.64">     getline(buf, sizeof(buf), stdin, prompt);</span>
<a href="#l80.65"></a><span id="l80.65"> </span>
<a href="#l80.66"></a><span id="l80.66">     if (*buf == '\0') break;</span>
<a href="#l80.67"></a><span id="l80.67"> </span>
<a href="#l80.68"></a><span id="l80.68" class="difflineminus">-    if (result == (char **)0)</span>
<a href="#l80.69"></a><span id="l80.69" class="difflineminus">-      result = (char **)malloc(sizeof(char *));</span>
<a href="#l80.70"></a><span id="l80.70" class="difflineplus">+    if (result == (char**)0)</span>
<a href="#l80.71"></a><span id="l80.71" class="difflineplus">+      result = (char**)malloc(sizeof(char*));</span>
<a href="#l80.72"></a><span id="l80.72">     else</span>
<a href="#l80.73"></a><span id="l80.73" class="difflineminus">-      result = (char **)realloc(result, sizeof(char *) * (num + 1));</span>
<a href="#l80.74"></a><span id="l80.74" class="difflineplus">+      result = (char**)realloc(result, sizeof(char*) * (num + 1));</span>
<a href="#l80.75"></a><span id="l80.75"> </span>
<a href="#l80.76"></a><span id="l80.76" class="difflineminus">-    result[num++] = (char *)strdup(buf);</span>
<a href="#l80.77"></a><span id="l80.77" class="difflineplus">+    result[num++] = (char*)strdup(buf);</span>
<a href="#l80.78"></a><span id="l80.78">   }</span>
<a href="#l80.79"></a><span id="l80.79" class="difflineminus">-  if (result == (char **)0) return (NULL);</span>
<a href="#l80.80"></a><span id="l80.80" class="difflineminus">-  result = (char **)realloc(result, sizeof(char *) * (num + 1));</span>
<a href="#l80.81"></a><span id="l80.81" class="difflineplus">+  if (result == (char**)0) return (NULL);</span>
<a href="#l80.82"></a><span id="l80.82" class="difflineplus">+  result = (char**)realloc(result, sizeof(char*) * (num + 1));</span>
<a href="#l80.83"></a><span id="l80.83">   result[num] = NULL;</span>
<a href="#l80.84"></a><span id="l80.84"> </span>
<a href="#l80.85"></a><span id="l80.85">   return (result);</span>
<a href="#l80.86"></a><span id="l80.86"> }</span>
<a href="#l80.87"></a><span id="l80.87"> </span>
<a href="#l80.88"></a><span id="l80.88" class="difflineminus">-static void free_list(char **list) {</span>
<a href="#l80.89"></a><span id="l80.89" class="difflineplus">+static void free_list(char** list) {</span>
<a href="#l80.90"></a><span id="l80.90">   int i;</span>
<a href="#l80.91"></a><span id="l80.91"> </span>
<a href="#l80.92"></a><span id="l80.92">   if (list != NULL) {</span>
<a href="#l80.93"></a><span id="l80.93">     for (i = 0; list[i] != NULL; ++i) {</span>
<a href="#l80.94"></a><span id="l80.94">       free(list[i]);</span>
<a href="#l80.95"></a><span id="l80.95">     }</span>
<a href="#l80.96"></a><span id="l80.96" class="difflineminus">-    free((char *)list);</span>
<a href="#l80.97"></a><span id="l80.97" class="difflineplus">+    free((char*)list);</span>
<a href="#l80.98"></a><span id="l80.98">   }</span>
<a href="#l80.99"></a><span id="l80.99"> }</span>
<a href="#l80.100"></a><span id="l80.100"> </span>
<a href="#l80.101"></a><span id="l80.101"> #ifdef MOD_USE_BVALS</span>
<a href="#l80.102"></a><span id="l80.102" class="difflineminus">-static int file_read(char *path, struct berval *bv) {</span>
<a href="#l80.103"></a><span id="l80.103" class="difflineminus">-  FILE *fp;</span>
<a href="#l80.104"></a><span id="l80.104" class="difflineplus">+static int file_read(char* path, struct berval* bv) {</span>
<a href="#l80.105"></a><span id="l80.105" class="difflineplus">+  FILE* fp;</span>
<a href="#l80.106"></a><span id="l80.106">   long rlen;</span>
<a href="#l80.107"></a><span id="l80.107">   int eof;</span>
<a href="#l80.108"></a><span id="l80.108"> </span>
<a href="#l80.109"></a><span id="l80.109">   if ((fp = NSLDAPI_FOPEN(path, &quot;r&quot;)) == NULL) {</span>
<a href="#l80.110"></a><span id="l80.110">     perror(path);</span>
<a href="#l80.111"></a><span id="l80.111">     return (-1);</span>
<a href="#l80.112"></a><span id="l80.112">   }</span>
<a href="#l80.113"></a><span id="l80.113"> </span>
<a href="#l80.114"></a><span id="l80.114">   if (fseek(fp, 0L, SEEK_END) != 0) {</span>
<a href="#l80.115"></a><span id="l80.115">     perror(path);</span>
<a href="#l80.116"></a><span id="l80.116">     fclose(fp);</span>
<a href="#l80.117"></a><span id="l80.117">     return (-1);</span>
<a href="#l80.118"></a><span id="l80.118">   }</span>
<a href="#l80.119"></a><span id="l80.119"> </span>
<a href="#l80.120"></a><span id="l80.120">   bv-&gt;bv_len = ftell(fp);</span>
<a href="#l80.121"></a><span id="l80.121"> </span>
<a href="#l80.122"></a><span id="l80.122" class="difflineminus">-  if ((bv-&gt;bv_val = (char *)malloc(bv-&gt;bv_len)) == NULL) {</span>
<a href="#l80.123"></a><span id="l80.123" class="difflineplus">+  if ((bv-&gt;bv_val = (char*)malloc(bv-&gt;bv_len)) == NULL) {</span>
<a href="#l80.124"></a><span id="l80.124">     perror(&quot;malloc&quot;);</span>
<a href="#l80.125"></a><span id="l80.125">     fclose(fp);</span>
<a href="#l80.126"></a><span id="l80.126">     return (-1);</span>
<a href="#l80.127"></a><span id="l80.127">   }</span>
<a href="#l80.128"></a><span id="l80.128"> </span>
<a href="#l80.129"></a><span id="l80.129">   if (fseek(fp, 0L, SEEK_SET) != 0) {</span>
<a href="#l80.130"></a><span id="l80.130">     perror(path);</span>
<a href="#l80.131"></a><span id="l80.131">     fclose(fp);</span>
<a href="#l80.132"></a><span id="l80.132" class="difflineat">@@ -196,23 +196,23 @@ static int file_read(char *path, struct </span>
<a href="#l80.133"></a><span id="l80.133">     free(bv-&gt;bv_val);</span>
<a href="#l80.134"></a><span id="l80.134">     return (-1);</span>
<a href="#l80.135"></a><span id="l80.135">   }</span>
<a href="#l80.136"></a><span id="l80.136"> </span>
<a href="#l80.137"></a><span id="l80.137">   return (bv-&gt;bv_len);</span>
<a href="#l80.138"></a><span id="l80.138"> }</span>
<a href="#l80.139"></a><span id="l80.139"> #endif /* MOD_USE_BVALS */</span>
<a href="#l80.140"></a><span id="l80.140"> </span>
<a href="#l80.141"></a><span id="l80.141" class="difflineminus">-static LDAPMod **get_modlist(char *prompt1, char *prompt2, char *prompt3) {</span>
<a href="#l80.142"></a><span id="l80.142" class="difflineplus">+static LDAPMod** get_modlist(char* prompt1, char* prompt2, char* prompt3) {</span>
<a href="#l80.143"></a><span id="l80.143">   static char buf[256];</span>
<a href="#l80.144"></a><span id="l80.144">   int num;</span>
<a href="#l80.145"></a><span id="l80.145">   LDAPMod tmp;</span>
<a href="#l80.146"></a><span id="l80.146" class="difflineminus">-  LDAPMod **result;</span>
<a href="#l80.147"></a><span id="l80.147" class="difflineplus">+  LDAPMod** result;</span>
<a href="#l80.148"></a><span id="l80.148"> #ifdef MOD_USE_BVALS</span>
<a href="#l80.149"></a><span id="l80.149" class="difflineminus">-  struct berval **bvals;</span>
<a href="#l80.150"></a><span id="l80.150" class="difflineplus">+  struct berval** bvals;</span>
<a href="#l80.151"></a><span id="l80.151"> #endif /* MOD_USE_BVALS */</span>
<a href="#l80.152"></a><span id="l80.152"> </span>
<a href="#l80.153"></a><span id="l80.153">   num = 0;</span>
<a href="#l80.154"></a><span id="l80.154">   result = NULL;</span>
<a href="#l80.155"></a><span id="l80.155">   while (1) {</span>
<a href="#l80.156"></a><span id="l80.156">     if (prompt1) {</span>
<a href="#l80.157"></a><span id="l80.157">       getline(buf, sizeof(buf), stdin, prompt1);</span>
<a href="#l80.158"></a><span id="l80.158">       tmp.mod_op = atoi(buf);</span>
<a href="#l80.159"></a><span id="l80.159" class="difflineat">@@ -228,52 +228,52 @@ static LDAPMod **get_modlist(char *promp</span>
<a href="#l80.160"></a><span id="l80.160"> </span>
<a href="#l80.161"></a><span id="l80.161">     tmp.mod_values = get_list(prompt3);</span>
<a href="#l80.162"></a><span id="l80.162"> #ifdef MOD_USE_BVALS</span>
<a href="#l80.163"></a><span id="l80.163">     if (tmp.mod_values != NULL) {</span>
<a href="#l80.164"></a><span id="l80.164">       int i;</span>
<a href="#l80.165"></a><span id="l80.165"> </span>
<a href="#l80.166"></a><span id="l80.166">       for (i = 0; tmp.mod_values[i] != NULL; ++i)</span>
<a href="#l80.167"></a><span id="l80.167">         ;</span>
<a href="#l80.168"></a><span id="l80.168" class="difflineminus">-      bvals = (struct berval **)calloc(i + 1, sizeof(struct berval *));</span>
<a href="#l80.169"></a><span id="l80.169" class="difflineplus">+      bvals = (struct berval**)calloc(i + 1, sizeof(struct berval*));</span>
<a href="#l80.170"></a><span id="l80.170">       for (i = 0; tmp.mod_values[i] != NULL; ++i) {</span>
<a href="#l80.171"></a><span id="l80.171" class="difflineminus">-        bvals[i] = (struct berval *)malloc(sizeof(struct berval));</span>
<a href="#l80.172"></a><span id="l80.172" class="difflineplus">+        bvals[i] = (struct berval*)malloc(sizeof(struct berval));</span>
<a href="#l80.173"></a><span id="l80.173">         if (strncmp(tmp.mod_values[i], &quot;{FILE}&quot;, 6) == 0) {</span>
<a href="#l80.174"></a><span id="l80.174">           if (file_read(tmp.mod_values[i] + 6, bvals[i]) &lt; 0) {</span>
<a href="#l80.175"></a><span id="l80.175">             return (NULL);</span>
<a href="#l80.176"></a><span id="l80.176">           }</span>
<a href="#l80.177"></a><span id="l80.177">         } else {</span>
<a href="#l80.178"></a><span id="l80.178">           bvals[i]-&gt;bv_val = tmp.mod_values[i];</span>
<a href="#l80.179"></a><span id="l80.179">           bvals[i]-&gt;bv_len = strlen(tmp.mod_values[i]);</span>
<a href="#l80.180"></a><span id="l80.180">         }</span>
<a href="#l80.181"></a><span id="l80.181">       }</span>
<a href="#l80.182"></a><span id="l80.182">       tmp.mod_bvalues = bvals;</span>
<a href="#l80.183"></a><span id="l80.183">       tmp.mod_op |= LDAP_MOD_BVALUES;</span>
<a href="#l80.184"></a><span id="l80.184">     }</span>
<a href="#l80.185"></a><span id="l80.185"> #endif /* MOD_USE_BVALS */</span>
<a href="#l80.186"></a><span id="l80.186"> </span>
<a href="#l80.187"></a><span id="l80.187">     if (result == NULL)</span>
<a href="#l80.188"></a><span id="l80.188" class="difflineminus">-      result = (LDAPMod **)malloc(sizeof(LDAPMod *));</span>
<a href="#l80.189"></a><span id="l80.189" class="difflineplus">+      result = (LDAPMod**)malloc(sizeof(LDAPMod*));</span>
<a href="#l80.190"></a><span id="l80.190">     else</span>
<a href="#l80.191"></a><span id="l80.191" class="difflineminus">-      result = (LDAPMod **)realloc(result, sizeof(LDAPMod *) * (num + 1));</span>
<a href="#l80.192"></a><span id="l80.192" class="difflineplus">+      result = (LDAPMod**)realloc(result, sizeof(LDAPMod*) * (num + 1));</span>
<a href="#l80.193"></a><span id="l80.193"> </span>
<a href="#l80.194"></a><span id="l80.194" class="difflineminus">-    result[num] = (LDAPMod *)malloc(sizeof(LDAPMod));</span>
<a href="#l80.195"></a><span id="l80.195" class="difflineplus">+    result[num] = (LDAPMod*)malloc(sizeof(LDAPMod));</span>
<a href="#l80.196"></a><span id="l80.196">     *(result[num]) = tmp; /* struct copy */</span>
<a href="#l80.197"></a><span id="l80.197">     num++;</span>
<a href="#l80.198"></a><span id="l80.198">   }</span>
<a href="#l80.199"></a><span id="l80.199">   if (result == NULL) return (NULL);</span>
<a href="#l80.200"></a><span id="l80.200" class="difflineminus">-  result = (LDAPMod **)realloc(result, sizeof(LDAPMod *) * (num + 1));</span>
<a href="#l80.201"></a><span id="l80.201" class="difflineplus">+  result = (LDAPMod**)realloc(result, sizeof(LDAPMod*) * (num + 1));</span>
<a href="#l80.202"></a><span id="l80.202">   result[num] = NULL;</span>
<a href="#l80.203"></a><span id="l80.203"> </span>
<a href="#l80.204"></a><span id="l80.204">   return (result);</span>
<a href="#l80.205"></a><span id="l80.205"> }</span>
<a href="#l80.206"></a><span id="l80.206"> </span>
<a href="#l80.207"></a><span id="l80.207" class="difflineminus">-int LDAP_CALL LDAP_CALLBACK bind_prompt(LDAP *ld, char **dnp, char **passwdp,</span>
<a href="#l80.208"></a><span id="l80.208" class="difflineminus">-                                        int *authmethodp, int freeit,</span>
<a href="#l80.209"></a><span id="l80.209" class="difflineminus">-                                        void *dummy) {</span>
<a href="#l80.210"></a><span id="l80.210" class="difflineplus">+int LDAP_CALL LDAP_CALLBACK bind_prompt(LDAP* ld, char** dnp, char** passwdp,</span>
<a href="#l80.211"></a><span id="l80.211" class="difflineplus">+                                        int* authmethodp, int freeit,</span>
<a href="#l80.212"></a><span id="l80.212" class="difflineplus">+                                        void* dummy) {</span>
<a href="#l80.213"></a><span id="l80.213">   static char dn[256], passwd[256];</span>
<a href="#l80.214"></a><span id="l80.214"> </span>
<a href="#l80.215"></a><span id="l80.215">   if (!freeit) {</span>
<a href="#l80.216"></a><span id="l80.216"> #ifdef KERBEROS</span>
<a href="#l80.217"></a><span id="l80.217">     getline(dn, sizeof(dn), stdin,</span>
<a href="#l80.218"></a><span id="l80.218">             &quot;re-bind method (0-&gt;simple, 1-&gt;krbv41, 2-&gt;krbv42, 3-&gt;krbv41&amp;2)? &quot;);</span>
<a href="#l80.219"></a><span id="l80.219">     if ((*authmethodp = atoi(dn)) == 3) {</span>
<a href="#l80.220"></a><span id="l80.220">       *authmethodp = LDAP_AUTH_KRBV4;</span>
<a href="#l80.221"></a><span id="l80.221" class="difflineat">@@ -296,17 +296,17 @@ int LDAP_CALL LDAP_CALLBACK bind_prompt(</span>
<a href="#l80.222"></a><span id="l80.222">     *passwdp = passwd;</span>
<a href="#l80.223"></a><span id="l80.223">   }</span>
<a href="#l80.224"></a><span id="l80.224"> </span>
<a href="#l80.225"></a><span id="l80.225">   return (LDAP_SUCCESS);</span>
<a href="#l80.226"></a><span id="l80.226"> }</span>
<a href="#l80.227"></a><span id="l80.227"> </span>
<a href="#l80.228"></a><span id="l80.228"> #define HEX2BIN(h) ((h) &gt;= '0' &amp;&amp; (h) &lt;= '9' ? (h) - '0' : (h) - 'A' + 10)</span>
<a href="#l80.229"></a><span id="l80.229"> </span>
<a href="#l80.230"></a><span id="l80.230" class="difflineminus">-void berval_from_hex(struct berval *bvp, char *hexstr) {</span>
<a href="#l80.231"></a><span id="l80.231" class="difflineplus">+void berval_from_hex(struct berval* bvp, char* hexstr) {</span>
<a href="#l80.232"></a><span id="l80.232">   char *src, *dst, c;</span>
<a href="#l80.233"></a><span id="l80.233">   unsigned char abyte;</span>
<a href="#l80.234"></a><span id="l80.234"> </span>
<a href="#l80.235"></a><span id="l80.235">   dst = bvp-&gt;bv_val;</span>
<a href="#l80.236"></a><span id="l80.236">   bvp-&gt;bv_len = 0;</span>
<a href="#l80.237"></a><span id="l80.237">   src = hexstr;</span>
<a href="#l80.238"></a><span id="l80.238">   while (*src != '\0') {</span>
<a href="#l80.239"></a><span id="l80.239">     c = *src;</span>
<a href="#l80.240"></a><span id="l80.240" class="difflineat">@@ -323,94 +323,94 @@ void berval_from_hex(struct berval *bvp,</span>
<a href="#l80.241"></a><span id="l80.241">     abyte |= HEX2BIN(c);</span>
<a href="#l80.242"></a><span id="l80.242">     ++src;</span>
<a href="#l80.243"></a><span id="l80.243"> </span>
<a href="#l80.244"></a><span id="l80.244">     *dst++ = abyte;</span>
<a href="#l80.245"></a><span id="l80.245">     ++bvp-&gt;bv_len;</span>
<a href="#l80.246"></a><span id="l80.246">   }</span>
<a href="#l80.247"></a><span id="l80.247"> }</span>
<a href="#l80.248"></a><span id="l80.248"> </span>
<a href="#l80.249"></a><span id="l80.249" class="difflineminus">-static void add_control(LDAPControl ***ctrlsp, LDAPControl *newctrl) {</span>
<a href="#l80.250"></a><span id="l80.250" class="difflineplus">+static void add_control(LDAPControl*** ctrlsp, LDAPControl* newctrl) {</span>
<a href="#l80.251"></a><span id="l80.251">   int i;</span>
<a href="#l80.252"></a><span id="l80.252"> </span>
<a href="#l80.253"></a><span id="l80.253">   if (*ctrlsp == NULL) {</span>
<a href="#l80.254"></a><span id="l80.254" class="difflineminus">-    *ctrlsp = (LDAPControl **)calloc(2, sizeof(LDAPControl *));</span>
<a href="#l80.255"></a><span id="l80.255" class="difflineplus">+    *ctrlsp = (LDAPControl**)calloc(2, sizeof(LDAPControl*));</span>
<a href="#l80.256"></a><span id="l80.256">     i = 0;</span>
<a href="#l80.257"></a><span id="l80.257">   } else {</span>
<a href="#l80.258"></a><span id="l80.258">     for (i = 0; (*ctrlsp)[i] != NULL; i++) {</span>
<a href="#l80.259"></a><span id="l80.259">       ; /* NULL */</span>
<a href="#l80.260"></a><span id="l80.260">     }</span>
<a href="#l80.261"></a><span id="l80.261" class="difflineminus">-    *ctrlsp = (LDAPControl **)realloc(*ctrlsp, (i + 2) * sizeof(LDAPControl *));</span>
<a href="#l80.262"></a><span id="l80.262" class="difflineplus">+    *ctrlsp = (LDAPControl**)realloc(*ctrlsp, (i + 2) * sizeof(LDAPControl*));</span>
<a href="#l80.263"></a><span id="l80.263">   }</span>
<a href="#l80.264"></a><span id="l80.264">   (*ctrlsp)[i] = newctrl;</span>
<a href="#l80.265"></a><span id="l80.265">   (*ctrlsp)[i + 1] = NULL;</span>
<a href="#l80.266"></a><span id="l80.266"> }</span>
<a href="#l80.267"></a><span id="l80.267"> </span>
<a href="#l80.268"></a><span id="l80.268"> #ifdef TEST_CUSTOM_MALLOC</span>
<a href="#l80.269"></a><span id="l80.269"> </span>
<a href="#l80.270"></a><span id="l80.270"> typedef struct my_malloc_info {</span>
<a href="#l80.271"></a><span id="l80.271">   long mmi_magic;</span>
<a href="#l80.272"></a><span id="l80.272">   size_t mmi_actualsize;</span>
<a href="#l80.273"></a><span id="l80.273"> } MyMallocInfo;</span>
<a href="#l80.274"></a><span id="l80.274"> #  define MY_MALLOC_MAGIC_NUMBER 0x19940618</span>
<a href="#l80.275"></a><span id="l80.275"> </span>
<a href="#l80.276"></a><span id="l80.276" class="difflineminus">-void *my_malloc(size_t size) {</span>
<a href="#l80.277"></a><span id="l80.277" class="difflineminus">-  void *p;</span>
<a href="#l80.278"></a><span id="l80.278" class="difflineminus">-  MyMallocInfo *mmip;</span>
<a href="#l80.279"></a><span id="l80.279" class="difflineplus">+void* my_malloc(size_t size) {</span>
<a href="#l80.280"></a><span id="l80.280" class="difflineplus">+  void* p;</span>
<a href="#l80.281"></a><span id="l80.281" class="difflineplus">+  MyMallocInfo* mmip;</span>
<a href="#l80.282"></a><span id="l80.282"> </span>
<a href="#l80.283"></a><span id="l80.283">   if ((p = malloc(size + sizeof(struct my_malloc_info))) != NULL) {</span>
<a href="#l80.284"></a><span id="l80.284" class="difflineminus">-    mmip = (MyMallocInfo *)p;</span>
<a href="#l80.285"></a><span id="l80.285" class="difflineplus">+    mmip = (MyMallocInfo*)p;</span>
<a href="#l80.286"></a><span id="l80.286">     mmip-&gt;mmi_magic = MY_MALLOC_MAGIC_NUMBER;</span>
<a href="#l80.287"></a><span id="l80.287">     mmip-&gt;mmi_actualsize = size;</span>
<a href="#l80.288"></a><span id="l80.288">   }</span>
<a href="#l80.289"></a><span id="l80.289"> </span>
<a href="#l80.290"></a><span id="l80.290">   fprintf(stderr, &quot;my_malloc: allocated ptr 0x%x, size %ld\n&quot;, p,</span>
<a href="#l80.291"></a><span id="l80.291">           mmip-&gt;mmi_actualsize);</span>
<a href="#l80.292"></a><span id="l80.292"> </span>
<a href="#l80.293"></a><span id="l80.293" class="difflineminus">-  return ((char *)p + sizeof(MyMallocInfo));</span>
<a href="#l80.294"></a><span id="l80.294" class="difflineplus">+  return ((char*)p + sizeof(MyMallocInfo));</span>
<a href="#l80.295"></a><span id="l80.295"> }</span>
<a href="#l80.296"></a><span id="l80.296"> </span>
<a href="#l80.297"></a><span id="l80.297" class="difflineminus">-void *my_calloc(size_t nelem, size_t elsize) {</span>
<a href="#l80.298"></a><span id="l80.298" class="difflineminus">-  void *p;</span>
<a href="#l80.299"></a><span id="l80.299" class="difflineplus">+void* my_calloc(size_t nelem, size_t elsize) {</span>
<a href="#l80.300"></a><span id="l80.300" class="difflineplus">+  void* p;</span>
<a href="#l80.301"></a><span id="l80.301"> </span>
<a href="#l80.302"></a><span id="l80.302">   if ((p = my_malloc(nelem * elsize)) != NULL) {</span>
<a href="#l80.303"></a><span id="l80.303">     memset(p, 0, nelem * elsize);</span>
<a href="#l80.304"></a><span id="l80.304">   }</span>
<a href="#l80.305"></a><span id="l80.305"> </span>
<a href="#l80.306"></a><span id="l80.306">   return (p);</span>
<a href="#l80.307"></a><span id="l80.307"> }</span>
<a href="#l80.308"></a><span id="l80.308"> </span>
<a href="#l80.309"></a><span id="l80.309" class="difflineminus">-void my_free(void *ptr) {</span>
<a href="#l80.310"></a><span id="l80.310" class="difflineminus">-  char *p;</span>
<a href="#l80.311"></a><span id="l80.311" class="difflineminus">-  MyMallocInfo *mmip;</span>
<a href="#l80.312"></a><span id="l80.312" class="difflineplus">+void my_free(void* ptr) {</span>
<a href="#l80.313"></a><span id="l80.313" class="difflineplus">+  char* p;</span>
<a href="#l80.314"></a><span id="l80.314" class="difflineplus">+  MyMallocInfo* mmip;</span>
<a href="#l80.315"></a><span id="l80.315"> </span>
<a href="#l80.316"></a><span id="l80.316" class="difflineminus">-  p = (char *)ptr;</span>
<a href="#l80.317"></a><span id="l80.317" class="difflineplus">+  p = (char*)ptr;</span>
<a href="#l80.318"></a><span id="l80.318">   p -= sizeof(MyMallocInfo);</span>
<a href="#l80.319"></a><span id="l80.319" class="difflineminus">-  mmip = (MyMallocInfo *)p;</span>
<a href="#l80.320"></a><span id="l80.320" class="difflineplus">+  mmip = (MyMallocInfo*)p;</span>
<a href="#l80.321"></a><span id="l80.321">   if (mmip-&gt;mmi_magic != MY_MALLOC_MAGIC_NUMBER) {</span>
<a href="#l80.322"></a><span id="l80.322">     fprintf(stderr, &quot;my_malloc_check_magic: ptr 0x%x bad magic number\n&quot;, ptr);</span>
<a href="#l80.323"></a><span id="l80.323">     exit(1);</span>
<a href="#l80.324"></a><span id="l80.324">   }</span>
<a href="#l80.325"></a><span id="l80.325"> </span>
<a href="#l80.326"></a><span id="l80.326">   fprintf(stderr, &quot;my_free: freeing ptr 0x%x, size %ld\n&quot;, p,</span>
<a href="#l80.327"></a><span id="l80.327">           mmip-&gt;mmi_actualsize);</span>
<a href="#l80.328"></a><span id="l80.328"> </span>
<a href="#l80.329"></a><span id="l80.329">   memset(p, 0, mmip-&gt;mmi_actualsize + sizeof(MyMallocInfo));</span>
<a href="#l80.330"></a><span id="l80.330">   free(p);</span>
<a href="#l80.331"></a><span id="l80.331"> }</span>
<a href="#l80.332"></a><span id="l80.332"> </span>
<a href="#l80.333"></a><span id="l80.333" class="difflineminus">-void *my_realloc(void *ptr, size_t size) {</span>
<a href="#l80.334"></a><span id="l80.334" class="difflineminus">-  void *p;</span>
<a href="#l80.335"></a><span id="l80.335" class="difflineminus">-  MyMallocInfo *mmip;</span>
<a href="#l80.336"></a><span id="l80.336" class="difflineplus">+void* my_realloc(void* ptr, size_t size) {</span>
<a href="#l80.337"></a><span id="l80.337" class="difflineplus">+  void* p;</span>
<a href="#l80.338"></a><span id="l80.338" class="difflineplus">+  MyMallocInfo* mmip;</span>
<a href="#l80.339"></a><span id="l80.339"> </span>
<a href="#l80.340"></a><span id="l80.340">   if (ptr == NULL) {</span>
<a href="#l80.341"></a><span id="l80.341">     return (my_malloc(size));</span>
<a href="#l80.342"></a><span id="l80.342">   }</span>
<a href="#l80.343"></a><span id="l80.343"> </span>
<a href="#l80.344"></a><span id="l80.344" class="difflineminus">-  mmip = (MyMallocInfo *)((char *)ptr - sizeof(MyMallocInfo));</span>
<a href="#l80.345"></a><span id="l80.345" class="difflineplus">+  mmip = (MyMallocInfo*)((char*)ptr - sizeof(MyMallocInfo));</span>
<a href="#l80.346"></a><span id="l80.346">   if (mmip-&gt;mmi_magic != MY_MALLOC_MAGIC_NUMBER) {</span>
<a href="#l80.347"></a><span id="l80.347">     fprintf(stderr, &quot;my_malloc_check_magic: ptr 0x%x bad magic number\n&quot;, ptr);</span>
<a href="#l80.348"></a><span id="l80.348">     exit(1);</span>
<a href="#l80.349"></a><span id="l80.349">   }</span>
<a href="#l80.350"></a><span id="l80.350"> </span>
<a href="#l80.351"></a><span id="l80.351">   if (size &lt;= mmip-&gt;mmi_actualsize) { /* current block big enough? */</span>
<a href="#l80.352"></a><span id="l80.352">     return (ptr);</span>
<a href="#l80.353"></a><span id="l80.353">   }</span>
<a href="#l80.354"></a><span id="l80.354" class="difflineat">@@ -427,38 +427,38 @@ void *my_realloc(void *ptr, size_t size)</span>
<a href="#l80.355"></a><span id="l80.355"> int</span>
<a href="#l80.356"></a><span id="l80.356"> #ifdef WINSOCK</span>
<a href="#l80.357"></a><span id="l80.357"> ldapmain(</span>
<a href="#l80.358"></a><span id="l80.358"> #else  /* WINSOCK */</span>
<a href="#l80.359"></a><span id="l80.359"> main(</span>
<a href="#l80.360"></a><span id="l80.360"> #endif /* WINSOCK */</span>
<a href="#l80.361"></a><span id="l80.361">  int argc, char **argv )</span>
<a href="#l80.362"></a><span id="l80.362"> {</span>
<a href="#l80.363"></a><span id="l80.363" class="difflineminus">-  LDAP *ld;</span>
<a href="#l80.364"></a><span id="l80.364" class="difflineplus">+  LDAP* ld;</span>
<a href="#l80.365"></a><span id="l80.365">   int rc, i, c, port, cldapflg, errflg, method, id, msgtype;</span>
<a href="#l80.366"></a><span id="l80.366">   int version;</span>
<a href="#l80.367"></a><span id="l80.367">   char line[256], command1, command2, command3;</span>
<a href="#l80.368"></a><span id="l80.368">   char passwd[64], dn[256], rdn[64], attr[64], value[256];</span>
<a href="#l80.369"></a><span id="l80.369">   char filter[256], *host, **types;</span>
<a href="#l80.370"></a><span id="l80.370">   char **exdn, *fnname;</span>
<a href="#l80.371"></a><span id="l80.371">   int bound, all, scope, attrsonly, optval, ldapversion;</span>
<a href="#l80.372"></a><span id="l80.372" class="difflineminus">-  LDAPMessage *res;</span>
<a href="#l80.373"></a><span id="l80.373" class="difflineplus">+  LDAPMessage* res;</span>
<a href="#l80.374"></a><span id="l80.374">   LDAPMod **mods, **attrs;</span>
<a href="#l80.375"></a><span id="l80.375">   struct timeval timeout, *tvp;</span>
<a href="#l80.376"></a><span id="l80.376" class="difflineminus">-  char *copyfname = NULL;</span>
<a href="#l80.377"></a><span id="l80.377" class="difflineplus">+  char* copyfname = NULL;</span>
<a href="#l80.378"></a><span id="l80.378">   int copyoptions = 0;</span>
<a href="#l80.379"></a><span id="l80.379" class="difflineminus">-  LDAPURLDesc *ludp;</span>
<a href="#l80.380"></a><span id="l80.380" class="difflineminus">-  struct ldap_disptmpl *tmpllist = NULL;</span>
<a href="#l80.381"></a><span id="l80.381" class="difflineplus">+  LDAPURLDesc* ludp;</span>
<a href="#l80.382"></a><span id="l80.382" class="difflineplus">+  struct ldap_disptmpl* tmpllist = NULL;</span>
<a href="#l80.383"></a><span id="l80.383">   int changetypes, changesonly, return_echg_ctls;</span>
<a href="#l80.384"></a><span id="l80.384">   LDAPControl **tmpctrls, *newctrl, **controls = NULL;</span>
<a href="#l80.385"></a><span id="l80.385" class="difflineminus">-  char *usage =</span>
<a href="#l80.386"></a><span id="l80.386" class="difflineplus">+  char* usage =</span>
<a href="#l80.387"></a><span id="l80.387">       &quot;usage: %s [-u] [-h host] [-d level] [-s dnsuffix] [-p port] [-t file] &quot;</span>
<a href="#l80.388"></a><span id="l80.388">       &quot;[-T file] [-V protocolversion]\n&quot;;</span>
<a href="#l80.389"></a><span id="l80.389"> </span>
<a href="#l80.390"></a><span id="l80.390" class="difflineminus">-  extern char *optarg;</span>
<a href="#l80.391"></a><span id="l80.391" class="difflineplus">+  extern char* optarg;</span>
<a href="#l80.392"></a><span id="l80.392">   extern int optind;</span>
<a href="#l80.393"></a><span id="l80.393"> </span>
<a href="#l80.394"></a><span id="l80.394"> #ifdef MACOS</span>
<a href="#l80.395"></a><span id="l80.395">   if ((argv = get_list(&quot;cmd line arg?&quot;)) == NULL) {</span>
<a href="#l80.396"></a><span id="l80.396">     exit(1);</span>
<a href="#l80.397"></a><span id="l80.397">   }</span>
<a href="#l80.398"></a><span id="l80.398">   for (argc = 0; argv[argc] != NULL; ++argc) {</span>
<a href="#l80.399"></a><span id="l80.399">     ;</span>
<a href="#l80.400"></a><span id="l80.400" class="difflineat">@@ -570,33 +570,33 @@ main(</span>
<a href="#l80.401"></a><span id="l80.401">   }</span>
<a href="#l80.402"></a><span id="l80.402"> </span>
<a href="#l80.403"></a><span id="l80.403">   if (ld == NULL) {</span>
<a href="#l80.404"></a><span id="l80.404">     perror(&quot;ldap_init&quot;);</span>
<a href="#l80.405"></a><span id="l80.405">     exit(1);</span>
<a href="#l80.406"></a><span id="l80.406">   }</span>
<a href="#l80.407"></a><span id="l80.407"> </span>
<a href="#l80.408"></a><span id="l80.408">   if (ldapversion != 0 &amp;&amp; ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION,</span>
<a href="#l80.409"></a><span id="l80.409" class="difflineminus">-                                          (void *)&amp;ldapversion) != 0) {</span>
<a href="#l80.410"></a><span id="l80.410" class="difflineplus">+                                          (void*)&amp;ldapversion) != 0) {</span>
<a href="#l80.411"></a><span id="l80.411">     ldap_perror(ld, &quot;ldap_set_option (protocol version)&quot;);</span>
<a href="#l80.412"></a><span id="l80.412">     exit(1);</span>
<a href="#l80.413"></a><span id="l80.413">   }</span>
<a href="#l80.414"></a><span id="l80.414"> </span>
<a href="#l80.415"></a><span id="l80.415"> #ifdef notdef</span>
<a href="#l80.416"></a><span id="l80.416"> #  if !defined(MACOS) &amp;&amp; !defined(DOS)</span>
<a href="#l80.417"></a><span id="l80.417">   if (copyfname != NULL) {</span>
<a href="#l80.418"></a><span id="l80.418">     int fd;</span>
<a href="#l80.419"></a><span id="l80.419" class="difflineminus">-    Sockbuf *sb;</span>
<a href="#l80.420"></a><span id="l80.420" class="difflineplus">+    Sockbuf* sb;</span>
<a href="#l80.421"></a><span id="l80.421"> </span>
<a href="#l80.422"></a><span id="l80.422">     if ((fd = open(copyfname, O_WRONLY | O_CREAT, 0600)) == -1) {</span>
<a href="#l80.423"></a><span id="l80.423">       perror(copyfname);</span>
<a href="#l80.424"></a><span id="l80.424">       exit(1);</span>
<a href="#l80.425"></a><span id="l80.425">     }</span>
<a href="#l80.426"></a><span id="l80.426">     ldap_get_option(ld, LDAP_OPT_SOCKBUF, &amp;sb);</span>
<a href="#l80.427"></a><span id="l80.427" class="difflineminus">-    ber_sockbuf_set_option(sb, LBER_SOCKBUF_OPT_COPYDESC, (void *)&amp;fd);</span>
<a href="#l80.428"></a><span id="l80.428" class="difflineplus">+    ber_sockbuf_set_option(sb, LBER_SOCKBUF_OPT_COPYDESC, (void*)&amp;fd);</span>
<a href="#l80.429"></a><span id="l80.429">     ber_sockbuf_set_option(sb, copyoptions, LBER_OPT_ON);</span>
<a href="#l80.430"></a><span id="l80.430">   }</span>
<a href="#l80.431"></a><span id="l80.431"> #  endif</span>
<a href="#l80.432"></a><span id="l80.432"> #endif</span>
<a href="#l80.433"></a><span id="l80.433"> </span>
<a href="#l80.434"></a><span id="l80.434">   bound = 0;</span>
<a href="#l80.435"></a><span id="l80.435">   timeout.tv_sec = 0;</span>
<a href="#l80.436"></a><span id="l80.436">   timeout.tv_usec = 0;</span>
<a href="#l80.437"></a><span id="l80.437" class="difflineat">@@ -632,17 +632,17 @@ main(</span>
<a href="#l80.438"></a><span id="l80.438">           default:</span>
<a href="#l80.439"></a><span id="l80.439">             printf(&quot;Possibilities: [ad]d, [ab]ort\n&quot;);</span>
<a href="#l80.440"></a><span id="l80.440">         }</span>
<a href="#l80.441"></a><span id="l80.441">         break;</span>
<a href="#l80.442"></a><span id="l80.442"> </span>
<a href="#l80.443"></a><span id="l80.443">       case 'v': /* ldap protocol version */</span>
<a href="#l80.444"></a><span id="l80.444">         getline(line, sizeof(line), stdin, &quot;ldap version? &quot;);</span>
<a href="#l80.445"></a><span id="l80.445">         version = atoi(line);</span>
<a href="#l80.446"></a><span id="l80.446" class="difflineminus">-        if (ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, (void *)&amp;version) !=</span>
<a href="#l80.447"></a><span id="l80.447" class="difflineplus">+        if (ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, (void*)&amp;version) !=</span>
<a href="#l80.448"></a><span id="l80.448">             0) {</span>
<a href="#l80.449"></a><span id="l80.449">           ldap_perror(ld, &quot;ldap_set_option&quot;);</span>
<a href="#l80.450"></a><span id="l80.450">         }</span>
<a href="#l80.451"></a><span id="l80.451">         break;</span>
<a href="#l80.452"></a><span id="l80.452"> </span>
<a href="#l80.453"></a><span id="l80.453">       case 'b': /* asynch bind */</span>
<a href="#l80.454"></a><span id="l80.454">         getline(line, sizeof(line), stdin, &quot;method 0-&gt;simple 3-&gt;sasl? &quot;);</span>
<a href="#l80.455"></a><span id="l80.455">         method = atoi(line);</span>
<a href="#l80.456"></a><span id="l80.456" class="difflineat">@@ -747,17 +747,17 @@ main(</span>
<a href="#l80.457"></a><span id="l80.457">       case 'x': /* extended operation */</span>
<a href="#l80.458"></a><span id="l80.458">       {</span>
<a href="#l80.459"></a><span id="l80.459">         char oid[100];</span>
<a href="#l80.460"></a><span id="l80.460">         struct berval val;</span>
<a href="#l80.461"></a><span id="l80.461"> </span>
<a href="#l80.462"></a><span id="l80.462">         getline(oid, sizeof(oid), stdin, &quot;oid? &quot;);</span>
<a href="#l80.463"></a><span id="l80.463">         getline(value, sizeof(value), stdin, &quot;value? &quot;);</span>
<a href="#l80.464"></a><span id="l80.464">         if (strncmp(value, &quot;0x&quot;, 2) == 0) {</span>
<a href="#l80.465"></a><span id="l80.465" class="difflineminus">-          val.bv_val = (char *)malloc(strlen(value) / 2);</span>
<a href="#l80.466"></a><span id="l80.466" class="difflineplus">+          val.bv_val = (char*)malloc(strlen(value) / 2);</span>
<a href="#l80.467"></a><span id="l80.467">           berval_from_hex(&amp;val, value + 2);</span>
<a href="#l80.468"></a><span id="l80.468">         } else {</span>
<a href="#l80.469"></a><span id="l80.469">           val.bv_val = strdup(value);</span>
<a href="#l80.470"></a><span id="l80.470">           val.bv_len = strlen(value);</span>
<a href="#l80.471"></a><span id="l80.471">         }</span>
<a href="#l80.472"></a><span id="l80.472">         if (ldap_extended_operation(ld, oid, &amp;val, NULL, NULL, &amp;id) !=</span>
<a href="#l80.473"></a><span id="l80.473">             LDAP_SUCCESS) {</span>
<a href="#l80.474"></a><span id="l80.474">           ldap_perror(ld, &quot;ldap_extended_operation&quot;);</span>
<a href="#l80.475"></a><span id="l80.475" class="difflineat">@@ -773,17 +773,17 @@ main(</span>
<a href="#l80.476"></a><span id="l80.476"> #else</span>
<a href="#l80.477"></a><span id="l80.477">         getline(line, sizeof(line), stdin,</span>
<a href="#l80.478"></a><span id="l80.478">                 &quot;cache init (memcache 0, lcache 1)? &quot;);</span>
<a href="#l80.479"></a><span id="l80.479"> #endif</span>
<a href="#l80.480"></a><span id="l80.480">         i = atoi(line);</span>
<a href="#l80.481"></a><span id="l80.481">         if (i == 0) { /* memcache */</span>
<a href="#l80.482"></a><span id="l80.482">           unsigned long ttl, size;</span>
<a href="#l80.483"></a><span id="l80.483">           char **basedns, *dnarray[2];</span>
<a href="#l80.484"></a><span id="l80.484" class="difflineminus">-          LDAPMemCache *mc;</span>
<a href="#l80.485"></a><span id="l80.485" class="difflineplus">+          LDAPMemCache* mc;</span>
<a href="#l80.486"></a><span id="l80.486"> </span>
<a href="#l80.487"></a><span id="l80.487">           getline(line, sizeof(line), stdin, &quot;memcache ttl? &quot;);</span>
<a href="#l80.488"></a><span id="l80.488">           ttl = atoi(line);</span>
<a href="#l80.489"></a><span id="l80.489">           getline(line, sizeof(line), stdin, &quot;memcache size? &quot;);</span>
<a href="#l80.490"></a><span id="l80.490">           size = atoi(line);</span>
<a href="#l80.491"></a><span id="l80.491">           getline(line, sizeof(line), stdin, &quot;memcache baseDN? &quot;);</span>
<a href="#l80.492"></a><span id="l80.492">           if (*line == '\0') {</span>
<a href="#l80.493"></a><span id="l80.493">             basedns = NULL;</span>
<a href="#l80.494"></a><span id="l80.494" class="difflineat">@@ -1072,21 +1072,21 @@ main(</span>
<a href="#l80.495"></a><span id="l80.495">         strcpy(dnsuffix, line);</span>
<a href="#l80.496"></a><span id="l80.496">         break;</span>
<a href="#l80.497"></a><span id="l80.497"> </span>
<a href="#l80.498"></a><span id="l80.498">       case 'N': /* add an LDAPv3 control */</span>
<a href="#l80.499"></a><span id="l80.499">         getline(line, sizeof(line), stdin, &quot;Control oid (. to clear list)? &quot;);</span>
<a href="#l80.500"></a><span id="l80.500">         if (*line == '.' &amp;&amp; *(line + 1) == '\0') {</span>
<a href="#l80.501"></a><span id="l80.501">           controls = NULL;</span>
<a href="#l80.502"></a><span id="l80.502">         } else {</span>
<a href="#l80.503"></a><span id="l80.503" class="difflineminus">-          newctrl = (LDAPControl *)malloc(sizeof(LDAPControl));</span>
<a href="#l80.504"></a><span id="l80.504" class="difflineplus">+          newctrl = (LDAPControl*)malloc(sizeof(LDAPControl));</span>
<a href="#l80.505"></a><span id="l80.505">           newctrl-&gt;ldctl_oid = strdup(line);</span>
<a href="#l80.506"></a><span id="l80.506">           getline(line, sizeof(line), stdin, &quot;Control value? &quot;);</span>
<a href="#l80.507"></a><span id="l80.507">           if (strncmp(line, &quot;0x&quot;, 2) == 0) {</span>
<a href="#l80.508"></a><span id="l80.508" class="difflineminus">-            newctrl-&gt;ldctl_value.bv_val = (char *)malloc(strlen(line) / 2);</span>
<a href="#l80.509"></a><span id="l80.509" class="difflineplus">+            newctrl-&gt;ldctl_value.bv_val = (char*)malloc(strlen(line) / 2);</span>
<a href="#l80.510"></a><span id="l80.510">             berval_from_hex(&amp;(newctrl-&gt;ldctl_value), line + 2);</span>
<a href="#l80.511"></a><span id="l80.511">           } else {</span>
<a href="#l80.512"></a><span id="l80.512">             newctrl-&gt;ldctl_value.bv_val = strdup(line);</span>
<a href="#l80.513"></a><span id="l80.513">           }</span>
<a href="#l80.514"></a><span id="l80.514">           newctrl-&gt;ldctl_value.bv_len = strlen(line);</span>
<a href="#l80.515"></a><span id="l80.515">           getline(line, sizeof(line), stdin, &quot;Critical (0=no, 1=yes)? &quot;);</span>
<a href="#l80.516"></a><span id="l80.516">           newctrl-&gt;ldctl_iscritical = atoi(line);</span>
<a href="#l80.517"></a><span id="l80.517">           add_control(&amp;controls, newctrl);</span>
<a href="#l80.518"></a><span id="l80.518" class="difflineat">@@ -1153,23 +1153,23 @@ main(</span>
<a href="#l80.519"></a><span id="l80.519">         }</span>
<a href="#l80.520"></a><span id="l80.520"> #endif /* STR_TRANSLATION */</span>
<a href="#l80.521"></a><span id="l80.521"> </span>
<a href="#l80.522"></a><span id="l80.522"> #ifdef LDAP_DNS</span>
<a href="#l80.523"></a><span id="l80.523">         getline(</span>
<a href="#l80.524"></a><span id="l80.524">             line, sizeof(line), stdin,</span>
<a href="#l80.525"></a><span id="l80.525">             &quot;Use DN &amp; DNS to determine where to send requests (0=no, 1=yes)?&quot;);</span>
<a href="#l80.526"></a><span id="l80.526">         optval = (atoi(line) != 0);</span>
<a href="#l80.527"></a><span id="l80.527" class="difflineminus">-        ldap_set_option(ld, LDAP_OPT_DNS, (void *)optval);</span>
<a href="#l80.528"></a><span id="l80.528" class="difflineplus">+        ldap_set_option(ld, LDAP_OPT_DNS, (void*)optval);</span>
<a href="#l80.529"></a><span id="l80.529"> #endif /* LDAP_DNS */</span>
<a href="#l80.530"></a><span id="l80.530"> </span>
<a href="#l80.531"></a><span id="l80.531">         getline(line, sizeof(line), stdin,</span>
<a href="#l80.532"></a><span id="l80.532">                 &quot;Recognize and chase referrals (0=no, 1=yes)?&quot;);</span>
<a href="#l80.533"></a><span id="l80.533">         optval = (atoi(line) != 0);</span>
<a href="#l80.534"></a><span id="l80.534" class="difflineminus">-        ldap_set_option(ld, LDAP_OPT_REFERRALS, (void *)optval);</span>
<a href="#l80.535"></a><span id="l80.535" class="difflineplus">+        ldap_set_option(ld, LDAP_OPT_REFERRALS, (void*)optval);</span>
<a href="#l80.536"></a><span id="l80.536">         if (optval) {</span>
<a href="#l80.537"></a><span id="l80.537">           getline(line, sizeof(line), stdin,</span>
<a href="#l80.538"></a><span id="l80.538">                   &quot;Prompt for bind credentials when chasing referrals (0=no, &quot;</span>
<a href="#l80.539"></a><span id="l80.539">                   &quot;1=yes)?&quot;);</span>
<a href="#l80.540"></a><span id="l80.540">           if (atoi(line) != 0) {</span>
<a href="#l80.541"></a><span id="l80.541">             ldap_set_rebind_proc(ld, bind_prompt, NULL);</span>
<a href="#l80.542"></a><span id="l80.542">           }</span>
<a href="#l80.543"></a><span id="l80.543">         }</span>
<a href="#l80.544"></a><span id="l80.544" class="difflineat">@@ -1299,17 +1299,17 @@ main(</span>
<a href="#l80.545"></a><span id="l80.545">     }</span>
<a href="#l80.546"></a><span id="l80.546"> </span>
<a href="#l80.547"></a><span id="l80.547">     (void)memset(line, '\0', sizeof(line));</span>
<a href="#l80.548"></a><span id="l80.548">   }</span>
<a href="#l80.549"></a><span id="l80.549"> </span>
<a href="#l80.550"></a><span id="l80.550">   return (0);</span>
<a href="#l80.551"></a><span id="l80.551"> }</span>
<a href="#l80.552"></a><span id="l80.552"> </span>
<a href="#l80.553"></a><span id="l80.553" class="difflineminus">-static void handle_result(LDAP *ld, LDAPMessage *lm, int onlyone) {</span>
<a href="#l80.554"></a><span id="l80.554" class="difflineplus">+static void handle_result(LDAP* ld, LDAPMessage* lm, int onlyone) {</span>
<a href="#l80.555"></a><span id="l80.555">   int msgtype;</span>
<a href="#l80.556"></a><span id="l80.556"> </span>
<a href="#l80.557"></a><span id="l80.557">   switch ((msgtype = ldap_msgtype(lm))) {</span>
<a href="#l80.558"></a><span id="l80.558">     case LDAP_RES_COMPARE:</span>
<a href="#l80.559"></a><span id="l80.559">       printf(&quot;Compare result\n&quot;);</span>
<a href="#l80.560"></a><span id="l80.560">       print_ldap_result(ld, lm, &quot;compare&quot;);</span>
<a href="#l80.561"></a><span id="l80.561">       break;</span>
<a href="#l80.562"></a><span id="l80.562"> </span>
<a href="#l80.563"></a><span id="l80.563" class="difflineat">@@ -1367,20 +1367,20 @@ static void handle_result(LDAP *ld, LDAP</span>
<a href="#l80.564"></a><span id="l80.564">       print_ldap_result(ld, lm, &quot;unknown&quot;);</span>
<a href="#l80.565"></a><span id="l80.565">   }</span>
<a href="#l80.566"></a><span id="l80.566"> </span>
<a href="#l80.567"></a><span id="l80.567">   if (!onlyone) {</span>
<a href="#l80.568"></a><span id="l80.568">     ldap_msgfree(lm);</span>
<a href="#l80.569"></a><span id="l80.569">   }</span>
<a href="#l80.570"></a><span id="l80.570"> }</span>
<a href="#l80.571"></a><span id="l80.571"> </span>
<a href="#l80.572"></a><span id="l80.572" class="difflineminus">-static void print_ldap_result(LDAP *ld, LDAPMessage *lm, char *s) {</span>
<a href="#l80.573"></a><span id="l80.573" class="difflineplus">+static void print_ldap_result(LDAP* ld, LDAPMessage* lm, char* s) {</span>
<a href="#l80.574"></a><span id="l80.574">   int lderr;</span>
<a href="#l80.575"></a><span id="l80.575">   char *matcheddn, *errmsg, *oid, **refs;</span>
<a href="#l80.576"></a><span id="l80.576" class="difflineminus">-  LDAPControl **ctrls;</span>
<a href="#l80.577"></a><span id="l80.577" class="difflineplus">+  LDAPControl** ctrls;</span>
<a href="#l80.578"></a><span id="l80.578">   struct berval *servercred, *data;</span>
<a href="#l80.579"></a><span id="l80.579"> </span>
<a href="#l80.580"></a><span id="l80.580">   if (ldap_parse_result(ld, lm, &amp;lderr, &amp;matcheddn, &amp;errmsg, &amp;refs, &amp;ctrls,</span>
<a href="#l80.581"></a><span id="l80.581">                         0) != LDAP_SUCCESS) {</span>
<a href="#l80.582"></a><span id="l80.582">     ldap_perror(ld, &quot;ldap_parse_result&quot;);</span>
<a href="#l80.583"></a><span id="l80.583">   } else {</span>
<a href="#l80.584"></a><span id="l80.584">     fprintf(stderr, &quot;%s: %s&quot;, s, ldap_err2string(lderr));</span>
<a href="#l80.585"></a><span id="l80.585">     if (lderr == LDAP_CONNECT_ERROR) {</span>
<a href="#l80.586"></a><span id="l80.586" class="difflineat">@@ -1427,23 +1427,23 @@ static void print_ldap_result(LDAP *ld, </span>
<a href="#l80.587"></a><span id="l80.587">     if (data != NULL) {</span>
<a href="#l80.588"></a><span id="l80.588">       printf(&quot;\t%s data:\n&quot;, s);</span>
<a href="#l80.589"></a><span id="l80.589">       bprint(data-&gt;bv_val, data-&gt;bv_len);</span>
<a href="#l80.590"></a><span id="l80.590">       ber_bvfree(data);</span>
<a href="#l80.591"></a><span id="l80.591">     }</span>
<a href="#l80.592"></a><span id="l80.592">   }</span>
<a href="#l80.593"></a><span id="l80.593"> }</span>
<a href="#l80.594"></a><span id="l80.594"> </span>
<a href="#l80.595"></a><span id="l80.595" class="difflineminus">-static void print_search_entry(LDAP *ld, LDAPMessage *res, int onlyone) {</span>
<a href="#l80.596"></a><span id="l80.596" class="difflineminus">-  BerElement *ber;</span>
<a href="#l80.597"></a><span id="l80.597" class="difflineplus">+static void print_search_entry(LDAP* ld, LDAPMessage* res, int onlyone) {</span>
<a href="#l80.598"></a><span id="l80.598" class="difflineplus">+  BerElement* ber;</span>
<a href="#l80.599"></a><span id="l80.599">   char *a, *dn, *ufn;</span>
<a href="#l80.600"></a><span id="l80.600" class="difflineminus">-  struct berval **vals;</span>
<a href="#l80.601"></a><span id="l80.601" class="difflineplus">+  struct berval** vals;</span>
<a href="#l80.602"></a><span id="l80.602">   int i, count;</span>
<a href="#l80.603"></a><span id="l80.603">   LDAPMessage *e, *msg;</span>
<a href="#l80.604"></a><span id="l80.604" class="difflineminus">-  LDAPControl **ectrls;</span>
<a href="#l80.605"></a><span id="l80.605" class="difflineplus">+  LDAPControl** ectrls;</span>
<a href="#l80.606"></a><span id="l80.606"> </span>
<a href="#l80.607"></a><span id="l80.607">   count = 0;</span>
<a href="#l80.608"></a><span id="l80.608">   for (msg = ldap_first_message(ld, res);</span>
<a href="#l80.609"></a><span id="l80.609">        msg != NULL &amp;&amp; (!onlyone || count == 0);</span>
<a href="#l80.610"></a><span id="l80.610">        msg = ldap_next_message(ld, msg), ++count) {</span>
<a href="#l80.611"></a><span id="l80.611">     if (ldap_msgtype(msg) != LDAP_RES_SEARCH_ENTRY) {</span>
<a href="#l80.612"></a><span id="l80.612">       handle_result(ld, msg, 1); /* something else */</span>
<a href="#l80.613"></a><span id="l80.613">       continue;</span>
<a href="#l80.614"></a><span id="l80.614" class="difflineat">@@ -1499,17 +1499,17 @@ static void print_search_entry(LDAP *ld,</span>
<a href="#l80.615"></a><span id="l80.615">       ber_free(ber, 0);</span>
<a href="#l80.616"></a><span id="l80.616">     }</span>
<a href="#l80.617"></a><span id="l80.617"> </span>
<a href="#l80.618"></a><span id="l80.618">     if (ldap_get_entry_controls(ld, e, &amp;ectrls) != LDAP_SUCCESS) {</span>
<a href="#l80.619"></a><span id="l80.619">       ldap_perror(ld, &quot;ldap_get_entry_controls&quot;);</span>
<a href="#l80.620"></a><span id="l80.620">     } else {</span>
<a href="#l80.621"></a><span id="l80.621">       int changenumpresent;</span>
<a href="#l80.622"></a><span id="l80.622">       ber_int_t changetype;</span>
<a href="#l80.623"></a><span id="l80.623" class="difflineminus">-      char *prevdn;</span>
<a href="#l80.624"></a><span id="l80.624" class="difflineplus">+      char* prevdn;</span>
<a href="#l80.625"></a><span id="l80.625">       ber_int_t changenum;</span>
<a href="#l80.626"></a><span id="l80.626"> </span>
<a href="#l80.627"></a><span id="l80.627">       if (ldap_parse_entrychange_control(ld, ectrls, &amp;changetype, &amp;prevdn,</span>
<a href="#l80.628"></a><span id="l80.628">                                          &amp;changenumpresent,</span>
<a href="#l80.629"></a><span id="l80.629">                                          &amp;changenum) == LDAP_SUCCESS) {</span>
<a href="#l80.630"></a><span id="l80.630">         fprintf(stderr,</span>
<a href="#l80.631"></a><span id="l80.631">                 &quot;EntryChangeNotification\n&quot;</span>
<a href="#l80.632"></a><span id="l80.632">                 &quot;\tchangeType:   %s\n&quot;,</span>
<a href="#l80.633"></a><span id="l80.633" class="difflineat">@@ -1524,19 +1524,19 @@ static void print_search_entry(LDAP *ld,</span>
<a href="#l80.634"></a><span id="l80.634">           free(prevdn);</span>
<a href="#l80.635"></a><span id="l80.635">         }</span>
<a href="#l80.636"></a><span id="l80.636">       }</span>
<a href="#l80.637"></a><span id="l80.637">       print_controls(ectrls, 1);</span>
<a href="#l80.638"></a><span id="l80.638">     }</span>
<a href="#l80.639"></a><span id="l80.639">   }</span>
<a href="#l80.640"></a><span id="l80.640"> }</span>
<a href="#l80.641"></a><span id="l80.641"> </span>
<a href="#l80.642"></a><span id="l80.642" class="difflineminus">-static char *changetype_num2string(ber_int_t chgtype) {</span>
<a href="#l80.643"></a><span id="l80.643" class="difflineplus">+static char* changetype_num2string(ber_int_t chgtype) {</span>
<a href="#l80.644"></a><span id="l80.644">   static char buf[25];</span>
<a href="#l80.645"></a><span id="l80.645" class="difflineminus">-  char *s;</span>
<a href="#l80.646"></a><span id="l80.646" class="difflineplus">+  char* s;</span>
<a href="#l80.647"></a><span id="l80.647"> </span>
<a href="#l80.648"></a><span id="l80.648">   switch (chgtype) {</span>
<a href="#l80.649"></a><span id="l80.649">     case LDAP_CHANGETYPE_ADD:</span>
<a href="#l80.650"></a><span id="l80.650">       s = &quot;add&quot;;</span>
<a href="#l80.651"></a><span id="l80.651">       break;</span>
<a href="#l80.652"></a><span id="l80.652">     case LDAP_CHANGETYPE_DELETE:</span>
<a href="#l80.653"></a><span id="l80.653">       s = &quot;delete&quot;;</span>
<a href="#l80.654"></a><span id="l80.654">       break;</span>
<a href="#l80.655"></a><span id="l80.655" class="difflineat">@@ -1549,20 +1549,20 @@ static char *changetype_num2string(ber_i</span>
<a href="#l80.656"></a><span id="l80.656">     default:</span>
<a href="#l80.657"></a><span id="l80.657">       s = buf;</span>
<a href="#l80.658"></a><span id="l80.658">       sprintf(s, &quot;unknown (%d)&quot;, chgtype);</span>
<a href="#l80.659"></a><span id="l80.659">   }</span>
<a href="#l80.660"></a><span id="l80.660"> </span>
<a href="#l80.661"></a><span id="l80.661">   return (s);</span>
<a href="#l80.662"></a><span id="l80.662"> }</span>
<a href="#l80.663"></a><span id="l80.663"> </span>
<a href="#l80.664"></a><span id="l80.664" class="difflineminus">-static void print_search_reference(LDAP *ld, LDAPMessage *res, int onlyone) {</span>
<a href="#l80.665"></a><span id="l80.665" class="difflineminus">-  LDAPMessage *msg;</span>
<a href="#l80.666"></a><span id="l80.666" class="difflineminus">-  LDAPControl **ctrls;</span>
<a href="#l80.667"></a><span id="l80.667" class="difflineminus">-  char **refs;</span>
<a href="#l80.668"></a><span id="l80.668" class="difflineplus">+static void print_search_reference(LDAP* ld, LDAPMessage* res, int onlyone) {</span>
<a href="#l80.669"></a><span id="l80.669" class="difflineplus">+  LDAPMessage* msg;</span>
<a href="#l80.670"></a><span id="l80.670" class="difflineplus">+  LDAPControl** ctrls;</span>
<a href="#l80.671"></a><span id="l80.671" class="difflineplus">+  char** refs;</span>
<a href="#l80.672"></a><span id="l80.672">   int count;</span>
<a href="#l80.673"></a><span id="l80.673"> </span>
<a href="#l80.674"></a><span id="l80.674">   count = 0;</span>
<a href="#l80.675"></a><span id="l80.675">   for (msg = ldap_first_message(ld, res);</span>
<a href="#l80.676"></a><span id="l80.676">        msg != NULL &amp;&amp; (!onlyone || count == 0);</span>
<a href="#l80.677"></a><span id="l80.677">        msg = ldap_next_message(ld, msg), ++count) {</span>
<a href="#l80.678"></a><span id="l80.678">     if (ldap_msgtype(msg) != LDAP_RES_SEARCH_REFERENCE) {</span>
<a href="#l80.679"></a><span id="l80.679">       handle_result(ld, msg, 1); /* something else */</span>
<a href="#l80.680"></a><span id="l80.680" class="difflineat">@@ -1573,34 +1573,34 @@ static void print_search_reference(LDAP </span>
<a href="#l80.681"></a><span id="l80.681">       ldap_perror(ld, &quot;ldap_parse_reference&quot;);</span>
<a href="#l80.682"></a><span id="l80.682">     } else {</span>
<a href="#l80.683"></a><span id="l80.683">       print_referrals(refs, 1);</span>
<a href="#l80.684"></a><span id="l80.684">       print_controls(ctrls, 1);</span>
<a href="#l80.685"></a><span id="l80.685">     }</span>
<a href="#l80.686"></a><span id="l80.686">   }</span>
<a href="#l80.687"></a><span id="l80.687"> }</span>
<a href="#l80.688"></a><span id="l80.688"> </span>
<a href="#l80.689"></a><span id="l80.689" class="difflineminus">-static void print_referrals(char **refs, int freeit) {</span>
<a href="#l80.690"></a><span id="l80.690" class="difflineplus">+static void print_referrals(char** refs, int freeit) {</span>
<a href="#l80.691"></a><span id="l80.691">   int i;</span>
<a href="#l80.692"></a><span id="l80.692"> </span>
<a href="#l80.693"></a><span id="l80.693">   if (refs == NULL) {</span>
<a href="#l80.694"></a><span id="l80.694">     return;</span>
<a href="#l80.695"></a><span id="l80.695">   }</span>
<a href="#l80.696"></a><span id="l80.696"> </span>
<a href="#l80.697"></a><span id="l80.697">   fprintf(stderr, &quot;Referrals:\n&quot;);</span>
<a href="#l80.698"></a><span id="l80.698">   for (i = 0; refs[i] != NULL; ++i) {</span>
<a href="#l80.699"></a><span id="l80.699">     fprintf(stderr, &quot;\t%s\n&quot;, refs[i]);</span>
<a href="#l80.700"></a><span id="l80.700">   }</span>
<a href="#l80.701"></a><span id="l80.701"> </span>
<a href="#l80.702"></a><span id="l80.702">   if (freeit) {</span>
<a href="#l80.703"></a><span id="l80.703">     ldap_value_free(refs);</span>
<a href="#l80.704"></a><span id="l80.704">   }</span>
<a href="#l80.705"></a><span id="l80.705"> }</span>
<a href="#l80.706"></a><span id="l80.706"> </span>
<a href="#l80.707"></a><span id="l80.707" class="difflineminus">-static void print_controls(LDAPControl **ctrls, int freeit) {</span>
<a href="#l80.708"></a><span id="l80.708" class="difflineplus">+static void print_controls(LDAPControl** ctrls, int freeit) {</span>
<a href="#l80.709"></a><span id="l80.709">   int i;</span>
<a href="#l80.710"></a><span id="l80.710"> </span>
<a href="#l80.711"></a><span id="l80.711">   if (ctrls == NULL) {</span>
<a href="#l80.712"></a><span id="l80.712">     return;</span>
<a href="#l80.713"></a><span id="l80.713">   }</span>
<a href="#l80.714"></a><span id="l80.714"> </span>
<a href="#l80.715"></a><span id="l80.715">   fprintf(stderr, &quot;Controls:\n&quot;);</span>
<a href="#l80.716"></a><span id="l80.716">   for (i = 0; ctrls[i] != NULL; ++i) {</span>
<a href="#l80.717"></a><span id="l80.717" class="difflineat">@@ -1614,50 +1614,49 @@ static void print_controls(LDAPControl *</span>
<a href="#l80.718"></a><span id="l80.718">     bprint(ctrls[i]-&gt;ldctl_value.bv_val, ctrls[i]-&gt;ldctl_value.bv_len);</span>
<a href="#l80.719"></a><span id="l80.719">   }</span>
<a href="#l80.720"></a><span id="l80.720"> </span>
<a href="#l80.721"></a><span id="l80.721">   if (freeit) {</span>
<a href="#l80.722"></a><span id="l80.722">     ldap_controls_free(ctrls);</span>
<a href="#l80.723"></a><span id="l80.723">   }</span>
<a href="#l80.724"></a><span id="l80.724"> }</span>
<a href="#l80.725"></a><span id="l80.725"> </span>
<a href="#l80.726"></a><span id="l80.726" class="difflineminus">-static int entry2textwrite(void *fp, char *buf, int len) {</span>
<a href="#l80.727"></a><span id="l80.727" class="difflineminus">-  return (fwrite(buf, len, 1, (FILE *)fp) == 0 ? -1 : len);</span>
<a href="#l80.728"></a><span id="l80.728" class="difflineplus">+static int entry2textwrite(void* fp, char* buf, int len) {</span>
<a href="#l80.729"></a><span id="l80.729" class="difflineplus">+  return (fwrite(buf, len, 1, (FILE*)fp) == 0 ? -1 : len);</span>
<a href="#l80.730"></a><span id="l80.730"> }</span>
<a href="#l80.731"></a><span id="l80.731"> </span>
<a href="#l80.732"></a><span id="l80.732"> /* similar to getfilter.c:break_into_words() */</span>
<a href="#l80.733"></a><span id="l80.733" class="difflineminus">-static char **string2words(char *str, char *delims) {</span>
<a href="#l80.734"></a><span id="l80.734" class="difflineplus">+static char** string2words(char* str, char* delims) {</span>
<a href="#l80.735"></a><span id="l80.735">   char *word, **words;</span>
<a href="#l80.736"></a><span id="l80.736">   int count;</span>
<a href="#l80.737"></a><span id="l80.737" class="difflineminus">-  char *lasts;</span>
<a href="#l80.738"></a><span id="l80.738" class="difflineplus">+  char* lasts;</span>
<a href="#l80.739"></a><span id="l80.739"> </span>
<a href="#l80.740"></a><span id="l80.740" class="difflineminus">-  if ((words = (char **)calloc(1, sizeof(char *))) == NULL) {</span>
<a href="#l80.741"></a><span id="l80.741" class="difflineplus">+  if ((words = (char**)calloc(1, sizeof(char*))) == NULL) {</span>
<a href="#l80.742"></a><span id="l80.742">     return (NULL);</span>
<a href="#l80.743"></a><span id="l80.743">   }</span>
<a href="#l80.744"></a><span id="l80.744">   count = 0;</span>
<a href="#l80.745"></a><span id="l80.745">   words[count] = NULL;</span>
<a href="#l80.746"></a><span id="l80.746"> </span>
<a href="#l80.747"></a><span id="l80.747">   word = ldap_utf8strtok_r(str, delims, &amp;lasts);</span>
<a href="#l80.748"></a><span id="l80.748">   while (word != NULL) {</span>
<a href="#l80.749"></a><span id="l80.749" class="difflineminus">-    if ((words = (char **)realloc(words, (count + 2) * sizeof(char *))) ==</span>
<a href="#l80.750"></a><span id="l80.750" class="difflineminus">-        NULL) {</span>
<a href="#l80.751"></a><span id="l80.751" class="difflineplus">+    if ((words = (char**)realloc(words, (count + 2) * sizeof(char*))) == NULL) {</span>
<a href="#l80.752"></a><span id="l80.752">       free(words);</span>
<a href="#l80.753"></a><span id="l80.753">       return (NULL);</span>
<a href="#l80.754"></a><span id="l80.754">     }</span>
<a href="#l80.755"></a><span id="l80.755"> </span>
<a href="#l80.756"></a><span id="l80.756">     words[count] = word;</span>
<a href="#l80.757"></a><span id="l80.757">     words[++count] = NULL;</span>
<a href="#l80.758"></a><span id="l80.758">     word = ldap_utf8strtok_r(NULL, delims, &amp;lasts);</span>
<a href="#l80.759"></a><span id="l80.759">   }</span>
<a href="#l80.760"></a><span id="l80.760"> </span>
<a href="#l80.761"></a><span id="l80.761">   return (words);</span>
<a href="#l80.762"></a><span id="l80.762"> }</span>
<a href="#l80.763"></a><span id="l80.763"> </span>
<a href="#l80.764"></a><span id="l80.764" class="difflineminus">-static const char *url_parse_err2string(int e) {</span>
<a href="#l80.765"></a><span id="l80.765" class="difflineminus">-  const char *s = &quot;unknown&quot;;</span>
<a href="#l80.766"></a><span id="l80.766" class="difflineplus">+static const char* url_parse_err2string(int e) {</span>
<a href="#l80.767"></a><span id="l80.767" class="difflineplus">+  const char* s = &quot;unknown&quot;;</span>
<a href="#l80.768"></a><span id="l80.768"> </span>
<a href="#l80.769"></a><span id="l80.769">   switch (e) {</span>
<a href="#l80.770"></a><span id="l80.770">     case LDAP_URL_ERR_NOTLDAP:</span>
<a href="#l80.771"></a><span id="l80.771">       s = &quot;URL doesn't begin with \&quot;ldap://\&quot;&quot;;</span>
<a href="#l80.772"></a><span id="l80.772">       break;</span>
<a href="#l80.773"></a><span id="l80.773">     case LDAP_URL_ERR_NODN:</span>
<a href="#l80.774"></a><span id="l80.774">       s = &quot;URL has no DN (required)&quot;;</span>
<a href="#l80.775"></a><span id="l80.775">       break;</span>
<a href="#l80.776"></a><span id="l80.776" class="difflineat">@@ -1678,17 +1677,17 @@ static const char *url_parse_err2string(</span>
<a href="#l80.777"></a><span id="l80.777">   return (s);</span>
<a href="#l80.778"></a><span id="l80.778"> }</span>
<a href="#l80.779"></a><span id="l80.779"> </span>
<a href="#l80.780"></a><span id="l80.780"> /*</span>
<a href="#l80.781"></a><span id="l80.781">  * Print arbitrary stuff, for debugging.</span>
<a href="#l80.782"></a><span id="l80.782">  */</span>
<a href="#l80.783"></a><span id="l80.783"> </span>
<a href="#l80.784"></a><span id="l80.784"> #define BPLEN 48</span>
<a href="#l80.785"></a><span id="l80.785" class="difflineminus">-static void bprint(char *data, int len) {</span>
<a href="#l80.786"></a><span id="l80.786" class="difflineplus">+static void bprint(char* data, int len) {</span>
<a href="#l80.787"></a><span id="l80.787">   static char hexdig[] = &quot;0123456789abcdef&quot;;</span>
<a href="#l80.788"></a><span id="l80.788">   char out[BPLEN];</span>
<a href="#l80.789"></a><span id="l80.789">   int i = 0;</span>
<a href="#l80.790"></a><span id="l80.790"> </span>
<a href="#l80.791"></a><span id="l80.791">   memset(out, 0, BPLEN);</span>
<a href="#l80.792"></a><span id="l80.792">   for (;;) {</span>
<a href="#l80.793"></a><span id="l80.793">     if (len &lt; 1) {</span>
<a href="#l80.794"></a><span id="l80.794">       fprintf(stderr, &quot;\t%s\n&quot;, (i == 0) ? &quot;(end)&quot; : out);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l81.1"></a><span id="l81.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/tmplout.c</span>
<a href="#l81.2"></a><span id="l81.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/tmplout.c</span>
<a href="#l81.3"></a><span id="l81.3" class="difflineat">@@ -45,92 +45,92 @@</span>
<a href="#l81.4"></a><span id="l81.4"> </span>
<a href="#l81.5"></a><span id="l81.5"> #if defined(_WINDOWS) || defined(aix) || defined(SCOOS) || defined(OSF1) || \</span>
<a href="#l81.6"></a><span id="l81.6">     defined(SOLARIS)</span>
<a href="#l81.7"></a><span id="l81.7"> #  include &lt;time.h&gt; /* for struct tm and ctime */</span>
<a href="#l81.8"></a><span id="l81.8"> #endif</span>
<a href="#l81.9"></a><span id="l81.9"> </span>
<a href="#l81.10"></a><span id="l81.10"> /* This is totally lame, since it should be coming from time.h, but isn't. */</span>
<a href="#l81.11"></a><span id="l81.11"> #if defined(SOLARIS)</span>
<a href="#l81.12"></a><span id="l81.12" class="difflineminus">-char *ctime_r(const time_t *, char *, int);</span>
<a href="#l81.13"></a><span id="l81.13" class="difflineplus">+char* ctime_r(const time_t*, char*, int);</span>
<a href="#l81.14"></a><span id="l81.14"> #endif</span>
<a href="#l81.15"></a><span id="l81.15"> </span>
<a href="#l81.16"></a><span id="l81.16" class="difflineminus">-static int do_entry2text(LDAP *ld, char *buf, char *base, LDAPMessage *entry,</span>
<a href="#l81.17"></a><span id="l81.17" class="difflineminus">-                         struct ldap_disptmpl *tmpl, char **defattrs,</span>
<a href="#l81.18"></a><span id="l81.18" class="difflineminus">-                         char ***defvals, writeptype writeproc, void *writeparm,</span>
<a href="#l81.19"></a><span id="l81.19" class="difflineminus">-                         char *eol, int rdncount, unsigned long opts,</span>
<a href="#l81.20"></a><span id="l81.20" class="difflineminus">-                         char *urlprefix);</span>
<a href="#l81.21"></a><span id="l81.21" class="difflineminus">-static int do_entry2text_search(LDAP *ld, char *dn, char *base,</span>
<a href="#l81.22"></a><span id="l81.22" class="difflineminus">-                                LDAPMessage *entry,</span>
<a href="#l81.23"></a><span id="l81.23" class="difflineminus">-                                struct ldap_disptmpl *tmpllist, char **defattrs,</span>
<a href="#l81.24"></a><span id="l81.24" class="difflineminus">-                                char ***defvals, writeptype writeproc,</span>
<a href="#l81.25"></a><span id="l81.25" class="difflineminus">-                                void *writeparm, char *eol, int rdncount,</span>
<a href="#l81.26"></a><span id="l81.26" class="difflineminus">-                                unsigned long opts, char *urlprefix);</span>
<a href="#l81.27"></a><span id="l81.27" class="difflineminus">-static int do_vals2text(LDAP *ld, char *buf, char **vals, char *label,</span>
<a href="#l81.28"></a><span id="l81.28" class="difflineplus">+static int do_entry2text(LDAP* ld, char* buf, char* base, LDAPMessage* entry,</span>
<a href="#l81.29"></a><span id="l81.29" class="difflineplus">+                         struct ldap_disptmpl* tmpl, char** defattrs,</span>
<a href="#l81.30"></a><span id="l81.30" class="difflineplus">+                         char*** defvals, writeptype writeproc, void* writeparm,</span>
<a href="#l81.31"></a><span id="l81.31" class="difflineplus">+                         char* eol, int rdncount, unsigned long opts,</span>
<a href="#l81.32"></a><span id="l81.32" class="difflineplus">+                         char* urlprefix);</span>
<a href="#l81.33"></a><span id="l81.33" class="difflineplus">+static int do_entry2text_search(LDAP* ld, char* dn, char* base,</span>
<a href="#l81.34"></a><span id="l81.34" class="difflineplus">+                                LDAPMessage* entry,</span>
<a href="#l81.35"></a><span id="l81.35" class="difflineplus">+                                struct ldap_disptmpl* tmpllist, char** defattrs,</span>
<a href="#l81.36"></a><span id="l81.36" class="difflineplus">+                                char*** defvals, writeptype writeproc,</span>
<a href="#l81.37"></a><span id="l81.37" class="difflineplus">+                                void* writeparm, char* eol, int rdncount,</span>
<a href="#l81.38"></a><span id="l81.38" class="difflineplus">+                                unsigned long opts, char* urlprefix);</span>
<a href="#l81.39"></a><span id="l81.39" class="difflineplus">+static int do_vals2text(LDAP* ld, char* buf, char** vals, char* label,</span>
<a href="#l81.40"></a><span id="l81.40">                         int labelwidth, unsigned long syntaxid,</span>
<a href="#l81.41"></a><span id="l81.41" class="difflineminus">-                        writeptype writeproc, void *writeparm, char *eol,</span>
<a href="#l81.42"></a><span id="l81.42" class="difflineminus">-                        int rdncount, char *urlprefix);</span>
<a href="#l81.43"></a><span id="l81.43" class="difflineminus">-static int max_label_len(struct ldap_disptmpl *tmpl);</span>
<a href="#l81.44"></a><span id="l81.44" class="difflineminus">-static int output_label(char *buf, char *label, int width, writeptype writeproc,</span>
<a href="#l81.45"></a><span id="l81.45" class="difflineminus">-                        void *writeparm, char *eol, int html);</span>
<a href="#l81.46"></a><span id="l81.46" class="difflineminus">-static int output_dn(char *buf, char *dn, int width, int rdncount,</span>
<a href="#l81.47"></a><span id="l81.47" class="difflineminus">-                     writeptype writeproc, void *writeparm, char *eol,</span>
<a href="#l81.48"></a><span id="l81.48" class="difflineminus">-                     char *urlprefix);</span>
<a href="#l81.49"></a><span id="l81.49" class="difflineminus">-static void strcat_escaped(char *s1, char *s2);</span>
<a href="#l81.50"></a><span id="l81.50" class="difflineminus">-static char *time2text(char *ldtimestr, int dateonly);</span>
<a href="#l81.51"></a><span id="l81.51" class="difflineminus">-static long gtime(struct tm *tm);</span>
<a href="#l81.52"></a><span id="l81.52" class="difflineminus">-static int searchaction(LDAP *ld, char *buf, char *base, LDAPMessage *entry,</span>
<a href="#l81.53"></a><span id="l81.53" class="difflineminus">-                        char *dn, struct ldap_tmplitem *tip, int labelwidth,</span>
<a href="#l81.54"></a><span id="l81.54" class="difflineminus">-                        int rdncount, writeptype writeproc, void *writeparm,</span>
<a href="#l81.55"></a><span id="l81.55" class="difflineminus">-                        char *eol, char *urlprefix);</span>
<a href="#l81.56"></a><span id="l81.56" class="difflineplus">+                        writeptype writeproc, void* writeparm, char* eol,</span>
<a href="#l81.57"></a><span id="l81.57" class="difflineplus">+                        int rdncount, char* urlprefix);</span>
<a href="#l81.58"></a><span id="l81.58" class="difflineplus">+static int max_label_len(struct ldap_disptmpl* tmpl);</span>
<a href="#l81.59"></a><span id="l81.59" class="difflineplus">+static int output_label(char* buf, char* label, int width, writeptype writeproc,</span>
<a href="#l81.60"></a><span id="l81.60" class="difflineplus">+                        void* writeparm, char* eol, int html);</span>
<a href="#l81.61"></a><span id="l81.61" class="difflineplus">+static int output_dn(char* buf, char* dn, int width, int rdncount,</span>
<a href="#l81.62"></a><span id="l81.62" class="difflineplus">+                     writeptype writeproc, void* writeparm, char* eol,</span>
<a href="#l81.63"></a><span id="l81.63" class="difflineplus">+                     char* urlprefix);</span>
<a href="#l81.64"></a><span id="l81.64" class="difflineplus">+static void strcat_escaped(char* s1, char* s2);</span>
<a href="#l81.65"></a><span id="l81.65" class="difflineplus">+static char* time2text(char* ldtimestr, int dateonly);</span>
<a href="#l81.66"></a><span id="l81.66" class="difflineplus">+static long gtime(struct tm* tm);</span>
<a href="#l81.67"></a><span id="l81.67" class="difflineplus">+static int searchaction(LDAP* ld, char* buf, char* base, LDAPMessage* entry,</span>
<a href="#l81.68"></a><span id="l81.68" class="difflineplus">+                        char* dn, struct ldap_tmplitem* tip, int labelwidth,</span>
<a href="#l81.69"></a><span id="l81.69" class="difflineplus">+                        int rdncount, writeptype writeproc, void* writeparm,</span>
<a href="#l81.70"></a><span id="l81.70" class="difflineplus">+                        char* eol, char* urlprefix);</span>
<a href="#l81.71"></a><span id="l81.71"> </span>
<a href="#l81.72"></a><span id="l81.72"> #define DEF_LABEL_WIDTH 15</span>
<a href="#l81.73"></a><span id="l81.73"> #define SEARCH_TIMEOUT_SECS 120</span>
<a href="#l81.74"></a><span id="l81.74"> #define OCATTRNAME &quot;objectClass&quot;</span>
<a href="#l81.75"></a><span id="l81.75"> </span>
<a href="#l81.76"></a><span id="l81.76"> #define NONFATAL_LDAP_ERR(err)                              \</span>
<a href="#l81.77"></a><span id="l81.77">   (err == LDAP_SUCCESS || err == LDAP_TIMELIMIT_EXCEEDED || \</span>
<a href="#l81.78"></a><span id="l81.78">    err == LDAP_SIZELIMIT_EXCEEDED)</span>
<a href="#l81.79"></a><span id="l81.79"> </span>
<a href="#l81.80"></a><span id="l81.80"> #define DEF_LDAP_URL_PREFIX &quot;ldap:///&quot;</span>
<a href="#l81.81"></a><span id="l81.81"> </span>
<a href="#l81.82"></a><span id="l81.82" class="difflineminus">-int LDAP_CALL ldap_entry2text(LDAP *ld, char *buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.83"></a><span id="l81.83" class="difflineminus">-                              LDAPMessage *entry, struct ldap_disptmpl *tmpl,</span>
<a href="#l81.84"></a><span id="l81.84" class="difflineminus">-                              char **defattrs, char ***defvals,</span>
<a href="#l81.85"></a><span id="l81.85" class="difflineminus">-                              writeptype writeproc, void *writeparm, char *eol,</span>
<a href="#l81.86"></a><span id="l81.86" class="difflineplus">+int LDAP_CALL ldap_entry2text(LDAP* ld, char* buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.87"></a><span id="l81.87" class="difflineplus">+                              LDAPMessage* entry, struct ldap_disptmpl* tmpl,</span>
<a href="#l81.88"></a><span id="l81.88" class="difflineplus">+                              char** defattrs, char*** defvals,</span>
<a href="#l81.89"></a><span id="l81.89" class="difflineplus">+                              writeptype writeproc, void* writeparm, char* eol,</span>
<a href="#l81.90"></a><span id="l81.90">                               int rdncount, unsigned long opts) {</span>
<a href="#l81.91"></a><span id="l81.91">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_entry2text\n&quot;, 0, 0, 0);</span>
<a href="#l81.92"></a><span id="l81.92"> </span>
<a href="#l81.93"></a><span id="l81.93">   return (do_entry2text(ld, buf, NULL, entry, tmpl, defattrs, defvals,</span>
<a href="#l81.94"></a><span id="l81.94">                         writeproc, writeparm, eol, rdncount, opts, NULL));</span>
<a href="#l81.95"></a><span id="l81.95"> }</span>
<a href="#l81.96"></a><span id="l81.96"> </span>
<a href="#l81.97"></a><span id="l81.97" class="difflineminus">-int LDAP_CALL ldap_entry2html(LDAP *ld, char *buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.98"></a><span id="l81.98" class="difflineminus">-                              LDAPMessage *entry, struct ldap_disptmpl *tmpl,</span>
<a href="#l81.99"></a><span id="l81.99" class="difflineminus">-                              char **defattrs, char ***defvals,</span>
<a href="#l81.100"></a><span id="l81.100" class="difflineminus">-                              writeptype writeproc, void *writeparm, char *eol,</span>
<a href="#l81.101"></a><span id="l81.101" class="difflineminus">-                              int rdncount, unsigned long opts, char *base,</span>
<a href="#l81.102"></a><span id="l81.102" class="difflineminus">-                              char *urlprefix) {</span>
<a href="#l81.103"></a><span id="l81.103" class="difflineplus">+int LDAP_CALL ldap_entry2html(LDAP* ld, char* buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.104"></a><span id="l81.104" class="difflineplus">+                              LDAPMessage* entry, struct ldap_disptmpl* tmpl,</span>
<a href="#l81.105"></a><span id="l81.105" class="difflineplus">+                              char** defattrs, char*** defvals,</span>
<a href="#l81.106"></a><span id="l81.106" class="difflineplus">+                              writeptype writeproc, void* writeparm, char* eol,</span>
<a href="#l81.107"></a><span id="l81.107" class="difflineplus">+                              int rdncount, unsigned long opts, char* base,</span>
<a href="#l81.108"></a><span id="l81.108" class="difflineplus">+                              char* urlprefix) {</span>
<a href="#l81.109"></a><span id="l81.109">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_entry2html\n&quot;, 0, 0, 0);</span>
<a href="#l81.110"></a><span id="l81.110"> </span>
<a href="#l81.111"></a><span id="l81.111">   if (urlprefix == NULL) {</span>
<a href="#l81.112"></a><span id="l81.112">     urlprefix = DEF_LDAP_URL_PREFIX;</span>
<a href="#l81.113"></a><span id="l81.113">   }</span>
<a href="#l81.114"></a><span id="l81.114"> </span>
<a href="#l81.115"></a><span id="l81.115">   return (do_entry2text(ld, buf, base, entry, tmpl, defattrs, defvals,</span>
<a href="#l81.116"></a><span id="l81.116">                         writeproc, writeparm, eol, rdncount, opts, urlprefix));</span>
<a href="#l81.117"></a><span id="l81.117"> }</span>
<a href="#l81.118"></a><span id="l81.118"> </span>
<a href="#l81.119"></a><span id="l81.119" class="difflineminus">-static int do_entry2text(LDAP *ld, char *buf, /* NULL for use-internal */</span>
<a href="#l81.120"></a><span id="l81.120" class="difflineminus">-                         char *base,          /* used for search actions */</span>
<a href="#l81.121"></a><span id="l81.121" class="difflineminus">-                         LDAPMessage *entry, struct ldap_disptmpl *tmpl,</span>
<a href="#l81.122"></a><span id="l81.122" class="difflineminus">-                         char **defattrs, char ***defvals, writeptype writeproc,</span>
<a href="#l81.123"></a><span id="l81.123" class="difflineminus">-                         void *writeparm, char *eol, int rdncount,</span>
<a href="#l81.124"></a><span id="l81.124" class="difflineplus">+static int do_entry2text(LDAP* ld, char* buf, /* NULL for use-internal */</span>
<a href="#l81.125"></a><span id="l81.125" class="difflineplus">+                         char* base,          /* used for search actions */</span>
<a href="#l81.126"></a><span id="l81.126" class="difflineplus">+                         LDAPMessage* entry, struct ldap_disptmpl* tmpl,</span>
<a href="#l81.127"></a><span id="l81.127" class="difflineplus">+                         char** defattrs, char*** defvals, writeptype writeproc,</span>
<a href="#l81.128"></a><span id="l81.128" class="difflineplus">+                         void* writeparm, char* eol, int rdncount,</span>
<a href="#l81.129"></a><span id="l81.129">                          unsigned long opts,</span>
<a href="#l81.130"></a><span id="l81.130" class="difflineminus">-                         char *urlprefix /* if non-NULL, do HTML */</span>
<a href="#l81.131"></a><span id="l81.131" class="difflineplus">+                         char* urlprefix /* if non-NULL, do HTML */</span>
<a href="#l81.132"></a><span id="l81.132"> ) {</span>
<a href="#l81.133"></a><span id="l81.133">   int i, err, html, show, labelwidth;</span>
<a href="#l81.134"></a><span id="l81.134">   int freebuf, freevals;</span>
<a href="#l81.135"></a><span id="l81.135">   char *dn, **vals;</span>
<a href="#l81.136"></a><span id="l81.136">   struct ldap_tmplitem *rowp, *colp;</span>
<a href="#l81.137"></a><span id="l81.137"> </span>
<a href="#l81.138"></a><span id="l81.138">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l81.139"></a><span id="l81.139">     return (LDAP_PARAM_ERROR);</span>
<a href="#l81.140"></a><span id="l81.140" class="difflineat">@@ -174,17 +174,17 @@ static int do_entry2text(LDAP *ld, char </span>
<a href="#l81.141"></a><span id="l81.141">       (*writeproc)(writeparm, buf, strlen(buf));</span>
<a href="#l81.142"></a><span id="l81.142">       output_dn(buf, dn, 0, rdncount, writeproc, writeparm, &quot;&quot;, NULL);</span>
<a href="#l81.143"></a><span id="l81.143">       sprintf(buf, &quot;&lt;/H3&gt;%s&quot;, eol);</span>
<a href="#l81.144"></a><span id="l81.144">       (*writeproc)(writeparm, buf, strlen(buf));</span>
<a href="#l81.145"></a><span id="l81.145">     }</span>
<a href="#l81.146"></a><span id="l81.146"> </span>
<a href="#l81.147"></a><span id="l81.147">     if ((opts &amp; LDAP_DISP_OPT_NONLEAF) != 0 &amp;&amp;</span>
<a href="#l81.148"></a><span id="l81.148">         (vals = ldap_explode_dn(dn, 0)) != NULL) {</span>
<a href="#l81.149"></a><span id="l81.149" class="difflineminus">-      char *untagged;</span>
<a href="#l81.150"></a><span id="l81.150" class="difflineplus">+      char* untagged;</span>
<a href="#l81.151"></a><span id="l81.151"> </span>
<a href="#l81.152"></a><span id="l81.152">       /*</span>
<a href="#l81.153"></a><span id="l81.153">        * add &quot;Move Up&quot; link</span>
<a href="#l81.154"></a><span id="l81.154">        */</span>
<a href="#l81.155"></a><span id="l81.155">       sprintf(buf, &quot;&lt;A HREF=\&quot;%s&quot;, urlprefix);</span>
<a href="#l81.156"></a><span id="l81.156">       for (i = 1; vals[i] != NULL; ++i) {</span>
<a href="#l81.157"></a><span id="l81.157">         if (i &gt; 1) {</span>
<a href="#l81.158"></a><span id="l81.158">           strcat_escaped(buf, &quot;, &quot;);</span>
<a href="#l81.159"></a><span id="l81.159" class="difflineat">@@ -228,18 +228,18 @@ static int do_entry2text(LDAP *ld, char </span>
<a href="#l81.160"></a><span id="l81.160">   } else {</span>
<a href="#l81.161"></a><span id="l81.161">     labelwidth = DEF_LABEL_WIDTH;</span>
<a href="#l81.162"></a><span id="l81.162">     ;</span>
<a href="#l81.163"></a><span id="l81.163">   }</span>
<a href="#l81.164"></a><span id="l81.164"> </span>
<a href="#l81.165"></a><span id="l81.165">   err = LDAP_SUCCESS;</span>
<a href="#l81.166"></a><span id="l81.166"> </span>
<a href="#l81.167"></a><span id="l81.167">   if (tmpl == NULL) {</span>
<a href="#l81.168"></a><span id="l81.168" class="difflineminus">-    BerElement *ber;</span>
<a href="#l81.169"></a><span id="l81.169" class="difflineminus">-    char *attr;</span>
<a href="#l81.170"></a><span id="l81.170" class="difflineplus">+    BerElement* ber;</span>
<a href="#l81.171"></a><span id="l81.171" class="difflineplus">+    char* attr;</span>
<a href="#l81.172"></a><span id="l81.172"> </span>
<a href="#l81.173"></a><span id="l81.173">     ber = NULL;</span>
<a href="#l81.174"></a><span id="l81.174">     for (attr = ldap_first_attribute(ld, entry, &amp;ber);</span>
<a href="#l81.175"></a><span id="l81.175">          NONFATAL_LDAP_ERR(err) &amp;&amp; attr != NULL;</span>
<a href="#l81.176"></a><span id="l81.176">          attr = ldap_next_attribute(ld, entry, ber)) {</span>
<a href="#l81.177"></a><span id="l81.177">       if ((vals = ldap_get_values(ld, entry, attr)) == NULL) {</span>
<a href="#l81.178"></a><span id="l81.178">         freevals = 0;</span>
<a href="#l81.179"></a><span id="l81.179">         if (defattrs != NULL) {</span>
<a href="#l81.180"></a><span id="l81.180" class="difflineat">@@ -350,57 +350,57 @@ static int do_entry2text(LDAP *ld, char </span>
<a href="#l81.181"></a><span id="l81.181">   if (freebuf) {</span>
<a href="#l81.182"></a><span id="l81.182">     NSLDAPI_FREE(buf);</span>
<a href="#l81.183"></a><span id="l81.183">   }</span>
<a href="#l81.184"></a><span id="l81.184"> </span>
<a href="#l81.185"></a><span id="l81.185">   return (err);</span>
<a href="#l81.186"></a><span id="l81.186"> }</span>
<a href="#l81.187"></a><span id="l81.187"> </span>
<a href="#l81.188"></a><span id="l81.188"> int LDAP_CALL ldap_entry2text_search(</span>
<a href="#l81.189"></a><span id="l81.189" class="difflineminus">-    LDAP *ld, char *dn,             /* if NULL, use entry */</span>
<a href="#l81.190"></a><span id="l81.190" class="difflineminus">-    char *base,                     /* if NULL, no search actions */</span>
<a href="#l81.191"></a><span id="l81.191" class="difflineminus">-    LDAPMessage *entry,             /* if NULL, use dn */</span>
<a href="#l81.192"></a><span id="l81.192" class="difflineminus">-    struct ldap_disptmpl *tmpllist, /* if NULL, load default file */</span>
<a href="#l81.193"></a><span id="l81.193" class="difflineminus">-    char **defattrs, char ***defvals, writeptype writeproc, void *writeparm,</span>
<a href="#l81.194"></a><span id="l81.194" class="difflineminus">-    char *eol, int rdncount, /* if 0, display full DN */</span>
<a href="#l81.195"></a><span id="l81.195" class="difflineplus">+    LDAP* ld, char* dn,             /* if NULL, use entry */</span>
<a href="#l81.196"></a><span id="l81.196" class="difflineplus">+    char* base,                     /* if NULL, no search actions */</span>
<a href="#l81.197"></a><span id="l81.197" class="difflineplus">+    LDAPMessage* entry,             /* if NULL, use dn */</span>
<a href="#l81.198"></a><span id="l81.198" class="difflineplus">+    struct ldap_disptmpl* tmpllist, /* if NULL, load default file */</span>
<a href="#l81.199"></a><span id="l81.199" class="difflineplus">+    char** defattrs, char*** defvals, writeptype writeproc, void* writeparm,</span>
<a href="#l81.200"></a><span id="l81.200" class="difflineplus">+    char* eol, int rdncount, /* if 0, display full DN */</span>
<a href="#l81.201"></a><span id="l81.201">     unsigned long opts) {</span>
<a href="#l81.202"></a><span id="l81.202">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_entry2text_search\n&quot;, 0, 0, 0);</span>
<a href="#l81.203"></a><span id="l81.203"> </span>
<a href="#l81.204"></a><span id="l81.204">   return (do_entry2text_search(ld, dn, base, entry, tmpllist, defattrs, defvals,</span>
<a href="#l81.205"></a><span id="l81.205">                                writeproc, writeparm, eol, rdncount, opts,</span>
<a href="#l81.206"></a><span id="l81.206">                                NULL));</span>
<a href="#l81.207"></a><span id="l81.207"> }</span>
<a href="#l81.208"></a><span id="l81.208"> </span>
<a href="#l81.209"></a><span id="l81.209"> int LDAP_CALL ldap_entry2html_search(</span>
<a href="#l81.210"></a><span id="l81.210" class="difflineminus">-    LDAP *ld, char *dn,             /* if NULL, use entry */</span>
<a href="#l81.211"></a><span id="l81.211" class="difflineminus">-    char *base,                     /* if NULL, no search actions */</span>
<a href="#l81.212"></a><span id="l81.212" class="difflineminus">-    LDAPMessage *entry,             /* if NULL, use dn */</span>
<a href="#l81.213"></a><span id="l81.213" class="difflineminus">-    struct ldap_disptmpl *tmpllist, /* if NULL, load default file */</span>
<a href="#l81.214"></a><span id="l81.214" class="difflineminus">-    char **defattrs, char ***defvals, writeptype writeproc, void *writeparm,</span>
<a href="#l81.215"></a><span id="l81.215" class="difflineminus">-    char *eol, int rdncount, /* if 0, display full DN */</span>
<a href="#l81.216"></a><span id="l81.216" class="difflineminus">-    unsigned long opts, char *urlprefix) {</span>
<a href="#l81.217"></a><span id="l81.217" class="difflineplus">+    LDAP* ld, char* dn,             /* if NULL, use entry */</span>
<a href="#l81.218"></a><span id="l81.218" class="difflineplus">+    char* base,                     /* if NULL, no search actions */</span>
<a href="#l81.219"></a><span id="l81.219" class="difflineplus">+    LDAPMessage* entry,             /* if NULL, use dn */</span>
<a href="#l81.220"></a><span id="l81.220" class="difflineplus">+    struct ldap_disptmpl* tmpllist, /* if NULL, load default file */</span>
<a href="#l81.221"></a><span id="l81.221" class="difflineplus">+    char** defattrs, char*** defvals, writeptype writeproc, void* writeparm,</span>
<a href="#l81.222"></a><span id="l81.222" class="difflineplus">+    char* eol, int rdncount, /* if 0, display full DN */</span>
<a href="#l81.223"></a><span id="l81.223" class="difflineplus">+    unsigned long opts, char* urlprefix) {</span>
<a href="#l81.224"></a><span id="l81.224">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_entry2html_search\n&quot;, 0, 0, 0);</span>
<a href="#l81.225"></a><span id="l81.225"> </span>
<a href="#l81.226"></a><span id="l81.226">   return (do_entry2text_search(ld, dn, base, entry, tmpllist, defattrs, defvals,</span>
<a href="#l81.227"></a><span id="l81.227">                                writeproc, writeparm, eol, rdncount, opts,</span>
<a href="#l81.228"></a><span id="l81.228">                                urlprefix));</span>
<a href="#l81.229"></a><span id="l81.229"> }</span>
<a href="#l81.230"></a><span id="l81.230"> </span>
<a href="#l81.231"></a><span id="l81.231"> static int do_entry2text_search(</span>
<a href="#l81.232"></a><span id="l81.232" class="difflineminus">-    LDAP *ld, char *dn,             /* if NULL, use entry */</span>
<a href="#l81.233"></a><span id="l81.233" class="difflineminus">-    char *base,                     /* if NULL, no search actions */</span>
<a href="#l81.234"></a><span id="l81.234" class="difflineminus">-    LDAPMessage *entry,             /* if NULL, use dn */</span>
<a href="#l81.235"></a><span id="l81.235" class="difflineminus">-    struct ldap_disptmpl *tmpllist, /* if NULL, no template used */</span>
<a href="#l81.236"></a><span id="l81.236" class="difflineminus">-    char **defattrs, char ***defvals, writeptype writeproc, void *writeparm,</span>
<a href="#l81.237"></a><span id="l81.237" class="difflineminus">-    char *eol, int rdncount, /* if 0, display full DN */</span>
<a href="#l81.238"></a><span id="l81.238" class="difflineminus">-    unsigned long opts, char *urlprefix) {</span>
<a href="#l81.239"></a><span id="l81.239" class="difflineplus">+    LDAP* ld, char* dn,             /* if NULL, use entry */</span>
<a href="#l81.240"></a><span id="l81.240" class="difflineplus">+    char* base,                     /* if NULL, no search actions */</span>
<a href="#l81.241"></a><span id="l81.241" class="difflineplus">+    LDAPMessage* entry,             /* if NULL, use dn */</span>
<a href="#l81.242"></a><span id="l81.242" class="difflineplus">+    struct ldap_disptmpl* tmpllist, /* if NULL, no template used */</span>
<a href="#l81.243"></a><span id="l81.243" class="difflineplus">+    char** defattrs, char*** defvals, writeptype writeproc, void* writeparm,</span>
<a href="#l81.244"></a><span id="l81.244" class="difflineplus">+    char* eol, int rdncount, /* if 0, display full DN */</span>
<a href="#l81.245"></a><span id="l81.245" class="difflineplus">+    unsigned long opts, char* urlprefix) {</span>
<a href="#l81.246"></a><span id="l81.246">   int err, freedn, html;</span>
<a href="#l81.247"></a><span id="l81.247">   char *buf, **fetchattrs, **vals;</span>
<a href="#l81.248"></a><span id="l81.248" class="difflineminus">-  LDAPMessage *ldmp;</span>
<a href="#l81.249"></a><span id="l81.249" class="difflineminus">-  struct ldap_disptmpl *tmpl;</span>
<a href="#l81.250"></a><span id="l81.250" class="difflineplus">+  LDAPMessage* ldmp;</span>
<a href="#l81.251"></a><span id="l81.251" class="difflineplus">+  struct ldap_disptmpl* tmpl;</span>
<a href="#l81.252"></a><span id="l81.252">   struct timeval timeout;</span>
<a href="#l81.253"></a><span id="l81.253"> </span>
<a href="#l81.254"></a><span id="l81.254">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l81.255"></a><span id="l81.255">     return (LDAP_PARAM_ERROR);</span>
<a href="#l81.256"></a><span id="l81.256">   }</span>
<a href="#l81.257"></a><span id="l81.257"> </span>
<a href="#l81.258"></a><span id="l81.258">   if (dn == NULL &amp;&amp; entry == NULLMSG) {</span>
<a href="#l81.259"></a><span id="l81.259">     err = LDAP_PARAM_ERROR;</span>
<a href="#l81.260"></a><span id="l81.260" class="difflineat">@@ -429,17 +429,17 @@ static int do_entry2text_search(</span>
<a href="#l81.261"></a><span id="l81.261">     }</span>
<a href="#l81.262"></a><span id="l81.262">     freedn = 1;</span>
<a href="#l81.263"></a><span id="l81.263">   }</span>
<a href="#l81.264"></a><span id="l81.264"> </span>
<a href="#l81.265"></a><span id="l81.265">   if (tmpllist != NULL) {</span>
<a href="#l81.266"></a><span id="l81.266">     ldmp = NULLMSG;</span>
<a href="#l81.267"></a><span id="l81.267"> </span>
<a href="#l81.268"></a><span id="l81.268">     if (entry == NULL) {</span>
<a href="#l81.269"></a><span id="l81.269" class="difflineminus">-      char *ocattrs[2];</span>
<a href="#l81.270"></a><span id="l81.270" class="difflineplus">+      char* ocattrs[2];</span>
<a href="#l81.271"></a><span id="l81.271"> </span>
<a href="#l81.272"></a><span id="l81.272">       ocattrs[0] = OCATTRNAME;</span>
<a href="#l81.273"></a><span id="l81.273">       ocattrs[1] = NULL;</span>
<a href="#l81.274"></a><span id="l81.274"> #ifdef CLDAP</span>
<a href="#l81.275"></a><span id="l81.275">       if (LDAP_IS_CLDAP(ld))</span>
<a href="#l81.276"></a><span id="l81.276">         err = cldap_search_s(ld, dn, LDAP_SCOPE_BASE, &quot;objectClass=*&quot;, ocattrs,</span>
<a href="#l81.277"></a><span id="l81.277">                              0, &amp;ldmp, NULL);</span>
<a href="#l81.278"></a><span id="l81.278">       else</span>
<a href="#l81.279"></a><span id="l81.279" class="difflineat">@@ -496,49 +496,49 @@ static int do_entry2text_search(</span>
<a href="#l81.280"></a><span id="l81.280">   err = do_entry2text(ld, buf, base, entry, tmpl, defattrs, defvals, writeproc,</span>
<a href="#l81.281"></a><span id="l81.281">                       writeparm, eol, rdncount, opts, urlprefix);</span>
<a href="#l81.282"></a><span id="l81.282"> </span>
<a href="#l81.283"></a><span id="l81.283">   NSLDAPI_FREE(buf);</span>
<a href="#l81.284"></a><span id="l81.284">   ldap_msgfree(ldmp);</span>
<a href="#l81.285"></a><span id="l81.285">   return (err);</span>
<a href="#l81.286"></a><span id="l81.286"> }</span>
<a href="#l81.287"></a><span id="l81.287"> </span>
<a href="#l81.288"></a><span id="l81.288" class="difflineminus">-int LDAP_CALL ldap_vals2text(LDAP *ld, char *buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.289"></a><span id="l81.289" class="difflineminus">-                             char **vals, char *label,</span>
<a href="#l81.290"></a><span id="l81.290" class="difflineplus">+int LDAP_CALL ldap_vals2text(LDAP* ld, char* buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.291"></a><span id="l81.291" class="difflineplus">+                             char** vals, char* label,</span>
<a href="#l81.292"></a><span id="l81.292">                              int labelwidth, /* 0 means use default */</span>
<a href="#l81.293"></a><span id="l81.293">                              unsigned long syntaxid, writeptype writeproc,</span>
<a href="#l81.294"></a><span id="l81.294" class="difflineminus">-                             void *writeparm, char *eol, int rdncount) {</span>
<a href="#l81.295"></a><span id="l81.295" class="difflineplus">+                             void* writeparm, char* eol, int rdncount) {</span>
<a href="#l81.296"></a><span id="l81.296">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_vals2text\n&quot;, 0, 0, 0);</span>
<a href="#l81.297"></a><span id="l81.297"> </span>
<a href="#l81.298"></a><span id="l81.298">   return (do_vals2text(ld, buf, vals, label, labelwidth, syntaxid, writeproc,</span>
<a href="#l81.299"></a><span id="l81.299">                        writeparm, eol, rdncount, NULL));</span>
<a href="#l81.300"></a><span id="l81.300"> }</span>
<a href="#l81.301"></a><span id="l81.301"> </span>
<a href="#l81.302"></a><span id="l81.302" class="difflineminus">-int LDAP_CALL ldap_vals2html(LDAP *ld, char *buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.303"></a><span id="l81.303" class="difflineminus">-                             char **vals, char *label,</span>
<a href="#l81.304"></a><span id="l81.304" class="difflineplus">+int LDAP_CALL ldap_vals2html(LDAP* ld, char* buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.305"></a><span id="l81.305" class="difflineplus">+                             char** vals, char* label,</span>
<a href="#l81.306"></a><span id="l81.306">                              int labelwidth, /* 0 means use default */</span>
<a href="#l81.307"></a><span id="l81.307">                              unsigned long syntaxid, writeptype writeproc,</span>
<a href="#l81.308"></a><span id="l81.308" class="difflineminus">-                             void *writeparm, char *eol, int rdncount,</span>
<a href="#l81.309"></a><span id="l81.309" class="difflineminus">-                             char *urlprefix) {</span>
<a href="#l81.310"></a><span id="l81.310" class="difflineplus">+                             void* writeparm, char* eol, int rdncount,</span>
<a href="#l81.311"></a><span id="l81.311" class="difflineplus">+                             char* urlprefix) {</span>
<a href="#l81.312"></a><span id="l81.312">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_vals2html\n&quot;, 0, 0, 0);</span>
<a href="#l81.313"></a><span id="l81.313"> </span>
<a href="#l81.314"></a><span id="l81.314">   if (urlprefix == NULL) {</span>
<a href="#l81.315"></a><span id="l81.315">     urlprefix = DEF_LDAP_URL_PREFIX;</span>
<a href="#l81.316"></a><span id="l81.316">   }</span>
<a href="#l81.317"></a><span id="l81.317"> </span>
<a href="#l81.318"></a><span id="l81.318">   return (do_vals2text(ld, buf, vals, label, labelwidth, syntaxid, writeproc,</span>
<a href="#l81.319"></a><span id="l81.319">                        writeparm, eol, rdncount, urlprefix));</span>
<a href="#l81.320"></a><span id="l81.320"> }</span>
<a href="#l81.321"></a><span id="l81.321"> </span>
<a href="#l81.322"></a><span id="l81.322" class="difflineminus">-static int do_vals2text(LDAP *ld, char *buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.323"></a><span id="l81.323" class="difflineminus">-                        char **vals, char *label,</span>
<a href="#l81.324"></a><span id="l81.324" class="difflineplus">+static int do_vals2text(LDAP* ld, char* buf, /* NULL for &quot;use internal&quot; */</span>
<a href="#l81.325"></a><span id="l81.325" class="difflineplus">+                        char** vals, char* label,</span>
<a href="#l81.326"></a><span id="l81.326">                         int labelwidth, /* 0 means use default */</span>
<a href="#l81.327"></a><span id="l81.327">                         unsigned long syntaxid, writeptype writeproc,</span>
<a href="#l81.328"></a><span id="l81.328" class="difflineminus">-                        void *writeparm, char *eol, int rdncount,</span>
<a href="#l81.329"></a><span id="l81.329" class="difflineminus">-                        char *urlprefix) {</span>
<a href="#l81.330"></a><span id="l81.330" class="difflineplus">+                        void* writeparm, char* eol, int rdncount,</span>
<a href="#l81.331"></a><span id="l81.331" class="difflineplus">+                        char* urlprefix) {</span>
<a href="#l81.332"></a><span id="l81.332">   int err, i, html, writeoutval, freebuf, notascii;</span>
<a href="#l81.333"></a><span id="l81.333">   char *p, *s, *outval;</span>
<a href="#l81.334"></a><span id="l81.334"> </span>
<a href="#l81.335"></a><span id="l81.335">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || writeproc == NULL) {</span>
<a href="#l81.336"></a><span id="l81.336">     return (LDAP_PARAM_ERROR);</span>
<a href="#l81.337"></a><span id="l81.337">   }</span>
<a href="#l81.338"></a><span id="l81.338"> </span>
<a href="#l81.339"></a><span id="l81.339">   if (vals == NULL) {</span>
<a href="#l81.340"></a><span id="l81.340" class="difflineat">@@ -685,17 +685,17 @@ static int do_vals2text(LDAP *ld, char *</span>
<a href="#l81.341"></a><span id="l81.341"> </span>
<a href="#l81.342"></a><span id="l81.342">   if (freebuf) {</span>
<a href="#l81.343"></a><span id="l81.343">     NSLDAPI_FREE(buf);</span>
<a href="#l81.344"></a><span id="l81.344">   }</span>
<a href="#l81.345"></a><span id="l81.345"> </span>
<a href="#l81.346"></a><span id="l81.346">   return (LDAP_SUCCESS);</span>
<a href="#l81.347"></a><span id="l81.347"> }</span>
<a href="#l81.348"></a><span id="l81.348"> </span>
<a href="#l81.349"></a><span id="l81.349" class="difflineminus">-static int max_label_len(struct ldap_disptmpl *tmpl) {</span>
<a href="#l81.350"></a><span id="l81.350" class="difflineplus">+static int max_label_len(struct ldap_disptmpl* tmpl) {</span>
<a href="#l81.351"></a><span id="l81.351">   struct ldap_tmplitem *rowp, *colp;</span>
<a href="#l81.352"></a><span id="l81.352">   int len, maxlen;</span>
<a href="#l81.353"></a><span id="l81.353"> </span>
<a href="#l81.354"></a><span id="l81.354">   maxlen = 0;</span>
<a href="#l81.355"></a><span id="l81.355"> </span>
<a href="#l81.356"></a><span id="l81.356">   for (rowp = ldap_first_tmplrow(tmpl); rowp != NULLTMPLITEM;</span>
<a href="#l81.357"></a><span id="l81.357">        rowp = ldap_next_tmplrow(tmpl, rowp)) {</span>
<a href="#l81.358"></a><span id="l81.358">     for (colp = ldap_first_tmplcol(tmpl, rowp); colp != NULLTMPLITEM;</span>
<a href="#l81.359"></a><span id="l81.359" class="difflineat">@@ -704,19 +704,19 @@ static int max_label_len(struct ldap_dis</span>
<a href="#l81.360"></a><span id="l81.360">         maxlen = len;</span>
<a href="#l81.361"></a><span id="l81.361">       }</span>
<a href="#l81.362"></a><span id="l81.362">     }</span>
<a href="#l81.363"></a><span id="l81.363">   }</span>
<a href="#l81.364"></a><span id="l81.364"> </span>
<a href="#l81.365"></a><span id="l81.365">   return (maxlen);</span>
<a href="#l81.366"></a><span id="l81.366"> }</span>
<a href="#l81.367"></a><span id="l81.367"> </span>
<a href="#l81.368"></a><span id="l81.368" class="difflineminus">-static int output_label(char *buf, char *label, int width, writeptype writeproc,</span>
<a href="#l81.369"></a><span id="l81.369" class="difflineminus">-                        void *writeparm, char *eol, int html) {</span>
<a href="#l81.370"></a><span id="l81.370" class="difflineminus">-  char *p;</span>
<a href="#l81.371"></a><span id="l81.371" class="difflineplus">+static int output_label(char* buf, char* label, int width, writeptype writeproc,</span>
<a href="#l81.372"></a><span id="l81.372" class="difflineplus">+                        void* writeparm, char* eol, int html) {</span>
<a href="#l81.373"></a><span id="l81.373" class="difflineplus">+  char* p;</span>
<a href="#l81.374"></a><span id="l81.374"> </span>
<a href="#l81.375"></a><span id="l81.375">   if (html) {</span>
<a href="#l81.376"></a><span id="l81.376">     sprintf(buf, &quot;&lt;DT&gt;&lt;B&gt;%s&lt;/B&gt;&quot;, label);</span>
<a href="#l81.377"></a><span id="l81.377">   } else {</span>
<a href="#l81.378"></a><span id="l81.378">     auto size_t w;</span>
<a href="#l81.379"></a><span id="l81.379">     sprintf(buf, &quot; %s:&quot;, label);</span>
<a href="#l81.380"></a><span id="l81.380">     p = buf + strlen(buf);</span>
<a href="#l81.381"></a><span id="l81.381"> </span>
<a href="#l81.382"></a><span id="l81.382" class="difflineat">@@ -726,20 +726,20 @@ static int output_label(char *buf, char </span>
<a href="#l81.383"></a><span id="l81.383"> </span>
<a href="#l81.384"></a><span id="l81.384">     *p = '\0';</span>
<a href="#l81.385"></a><span id="l81.385">     strcat(buf, eol);</span>
<a href="#l81.386"></a><span id="l81.386">   }</span>
<a href="#l81.387"></a><span id="l81.387"> </span>
<a href="#l81.388"></a><span id="l81.388">   return ((*writeproc)(writeparm, buf, strlen(buf)));</span>
<a href="#l81.389"></a><span id="l81.389"> }</span>
<a href="#l81.390"></a><span id="l81.390"> </span>
<a href="#l81.391"></a><span id="l81.391" class="difflineminus">-static int output_dn(char *buf, char *dn, int width, int rdncount,</span>
<a href="#l81.392"></a><span id="l81.392" class="difflineminus">-                     writeptype writeproc, void *writeparm, char *eol,</span>
<a href="#l81.393"></a><span id="l81.393" class="difflineminus">-                     char *urlprefix) {</span>
<a href="#l81.394"></a><span id="l81.394" class="difflineminus">-  char **dnrdns;</span>
<a href="#l81.395"></a><span id="l81.395" class="difflineplus">+static int output_dn(char* buf, char* dn, int width, int rdncount,</span>
<a href="#l81.396"></a><span id="l81.396" class="difflineplus">+                     writeptype writeproc, void* writeparm, char* eol,</span>
<a href="#l81.397"></a><span id="l81.397" class="difflineplus">+                     char* urlprefix) {</span>
<a href="#l81.398"></a><span id="l81.398" class="difflineplus">+  char** dnrdns;</span>
<a href="#l81.399"></a><span id="l81.399">   int i;</span>
<a href="#l81.400"></a><span id="l81.400"> </span>
<a href="#l81.401"></a><span id="l81.401">   if ((dnrdns = ldap_explode_dn(dn, 1)) == NULL) {</span>
<a href="#l81.402"></a><span id="l81.402">     return (-1);</span>
<a href="#l81.403"></a><span id="l81.403">   }</span>
<a href="#l81.404"></a><span id="l81.404"> </span>
<a href="#l81.405"></a><span id="l81.405">   if (urlprefix != NULL) {</span>
<a href="#l81.406"></a><span id="l81.406">     sprintf(buf, &quot;&lt;DD&gt;&lt;A HREF=\&quot;%s&quot;, urlprefix);</span>
<a href="#l81.407"></a><span id="l81.407" class="difflineat">@@ -768,49 +768,49 @@ static int output_dn(char *buf, char *dn</span>
<a href="#l81.408"></a><span id="l81.408"> </span>
<a href="#l81.409"></a><span id="l81.409">   return ((*writeproc)(writeparm, buf, strlen(buf)));</span>
<a href="#l81.410"></a><span id="l81.410"> }</span>
<a href="#l81.411"></a><span id="l81.411"> </span>
<a href="#l81.412"></a><span id="l81.412"> #define HREF_CHAR_ACCEPTABLE(c)                                      \</span>
<a href="#l81.413"></a><span id="l81.413">   ((c &gt;= '-' &amp;&amp; c &lt;= '9') || (c &gt;= '@' &amp;&amp; c &lt;= 'Z') || (c == '_') || \</span>
<a href="#l81.414"></a><span id="l81.414">    (c &gt;= 'a' &amp;&amp; c &lt;= 'z'))</span>
<a href="#l81.415"></a><span id="l81.415"> </span>
<a href="#l81.416"></a><span id="l81.416" class="difflineminus">-static void strcat_escaped(char *s1, char *s2) {</span>
<a href="#l81.417"></a><span id="l81.417" class="difflineplus">+static void strcat_escaped(char* s1, char* s2) {</span>
<a href="#l81.418"></a><span id="l81.418">   char *p, *q;</span>
<a href="#l81.419"></a><span id="l81.419" class="difflineminus">-  char *hexdig = &quot;0123456789ABCDEF&quot;;</span>
<a href="#l81.420"></a><span id="l81.420" class="difflineplus">+  char* hexdig = &quot;0123456789ABCDEF&quot;;</span>
<a href="#l81.421"></a><span id="l81.421"> </span>
<a href="#l81.422"></a><span id="l81.422">   p = s1 + strlen(s1);</span>
<a href="#l81.423"></a><span id="l81.423">   for (q = s2; *q != '\0'; ++q) {</span>
<a href="#l81.424"></a><span id="l81.424">     if (HREF_CHAR_ACCEPTABLE(*q)) {</span>
<a href="#l81.425"></a><span id="l81.425">       *p++ = *q;</span>
<a href="#l81.426"></a><span id="l81.426">     } else {</span>
<a href="#l81.427"></a><span id="l81.427">       *p++ = '%';</span>
<a href="#l81.428"></a><span id="l81.428" class="difflineminus">-      *p++ = hexdig[0x0F &amp; ((*(unsigned char *)q) &gt;&gt; 4)];</span>
<a href="#l81.429"></a><span id="l81.429" class="difflineplus">+      *p++ = hexdig[0x0F &amp; ((*(unsigned char*)q) &gt;&gt; 4)];</span>
<a href="#l81.430"></a><span id="l81.430">       *p++ = hexdig[0x0F &amp; *q];</span>
<a href="#l81.431"></a><span id="l81.431">     }</span>
<a href="#l81.432"></a><span id="l81.432">   }</span>
<a href="#l81.433"></a><span id="l81.433"> </span>
<a href="#l81.434"></a><span id="l81.434">   *p = '\0';</span>
<a href="#l81.435"></a><span id="l81.435"> }</span>
<a href="#l81.436"></a><span id="l81.436"> </span>
<a href="#l81.437"></a><span id="l81.437"> #define GET2BYTENUM(p) ((*p - '0') * 10 + (*(p + 1) - '0'))</span>
<a href="#l81.438"></a><span id="l81.438"> </span>
<a href="#l81.439"></a><span id="l81.439" class="difflineminus">-static char *time2text(char *ldtimestr, int dateonly) {</span>
<a href="#l81.440"></a><span id="l81.440" class="difflineplus">+static char* time2text(char* ldtimestr, int dateonly) {</span>
<a href="#l81.441"></a><span id="l81.441">   int len;</span>
<a href="#l81.442"></a><span id="l81.442">   struct tm t;</span>
<a href="#l81.443"></a><span id="l81.443">   char *p, *timestr, zone, *fmterr = &quot;badly formatted time&quot;;</span>
<a href="#l81.444"></a><span id="l81.444">   time_t gmttime;</span>
<a href="#l81.445"></a><span id="l81.445"> /* CTIME for this platform doesn't use this. */</span>
<a href="#l81.446"></a><span id="l81.446"> #if !defined(SUNOS4) &amp;&amp; !defined(BSDI) &amp;&amp; !defined(LINUX1_2) &amp;&amp; \</span>
<a href="#l81.447"></a><span id="l81.447">     !defined(SNI) &amp;&amp; !defined(_WIN32) &amp;&amp; !defined(macintosh) &amp;&amp; \</span>
<a href="#l81.448"></a><span id="l81.448">     !defined(LINUX)</span>
<a href="#l81.449"></a><span id="l81.449">   char buf[26];</span>
<a href="#l81.450"></a><span id="l81.450"> #endif</span>
<a href="#l81.451"></a><span id="l81.451"> </span>
<a href="#l81.452"></a><span id="l81.452" class="difflineminus">-  memset((char *)&amp;t, 0, sizeof(struct tm));</span>
<a href="#l81.453"></a><span id="l81.453" class="difflineplus">+  memset((char*)&amp;t, 0, sizeof(struct tm));</span>
<a href="#l81.454"></a><span id="l81.454">   if ((len = (int)strlen(ldtimestr)) &lt; 13) {</span>
<a href="#l81.455"></a><span id="l81.455">     return (fmterr);</span>
<a href="#l81.456"></a><span id="l81.456">   }</span>
<a href="#l81.457"></a><span id="l81.457">   if (len &gt; 15) { /* throw away excess from 4-digit year time string */</span>
<a href="#l81.458"></a><span id="l81.458">     len = 15;</span>
<a href="#l81.459"></a><span id="l81.459">   } else if (len == 14) {</span>
<a href="#l81.460"></a><span id="l81.460">     len = 13; /* assume we have a time w/2-digit year (len=13) */</span>
<a href="#l81.461"></a><span id="l81.461">   }</span>
<a href="#l81.462"></a><span id="l81.462" class="difflineat">@@ -879,17 +879,17 @@ static int dmsize[] = {31, 28, 31, 30, 3</span>
<a href="#l81.463"></a><span id="l81.463"> </span>
<a href="#l81.464"></a><span id="l81.464"> /*</span>
<a href="#l81.465"></a><span id="l81.465"> #define  YEAR(y) ((y) &gt;= 100 ? (y) : (y) + 1900)</span>
<a href="#l81.466"></a><span id="l81.466"> */</span>
<a href="#l81.467"></a><span id="l81.467"> #define YEAR(y) (((y) &lt; 1900) ? ((y) + 1900) : (y))</span>
<a href="#l81.468"></a><span id="l81.468"> </span>
<a href="#l81.469"></a><span id="l81.469"> /*  */</span>
<a href="#l81.470"></a><span id="l81.470"> </span>
<a href="#l81.471"></a><span id="l81.471" class="difflineminus">-static long gtime(struct tm *tm) {</span>
<a href="#l81.472"></a><span id="l81.472" class="difflineplus">+static long gtime(struct tm* tm) {</span>
<a href="#l81.473"></a><span id="l81.473">   register int i, sec, mins, hour, mday, mon, year;</span>
<a href="#l81.474"></a><span id="l81.474">   register long result;</span>
<a href="#l81.475"></a><span id="l81.475"> </span>
<a href="#l81.476"></a><span id="l81.476">   if ((sec = tm-&gt;tm_sec) &lt; 0 || sec &gt; 59 || (mins = tm-&gt;tm_min) &lt; 0 ||</span>
<a href="#l81.477"></a><span id="l81.477">       mins &gt; 59 || (hour = tm-&gt;tm_hour) &lt; 0 || hour &gt; 24 ||</span>
<a href="#l81.478"></a><span id="l81.478">       (mday = tm-&gt;tm_mday) &lt; 1 || mday &gt; 31 || (mon = tm-&gt;tm_mon + 1) &lt; 1 ||</span>
<a href="#l81.479"></a><span id="l81.479">       mon &gt; 12)</span>
<a href="#l81.480"></a><span id="l81.480">     return ((long)-1);</span>
<a href="#l81.481"></a><span id="l81.481" class="difflineat">@@ -906,25 +906,25 @@ static long gtime(struct tm *tm) {</span>
<a href="#l81.482"></a><span id="l81.482">   result += mday - 1;</span>
<a href="#l81.483"></a><span id="l81.483">   result = 24 * result + hour;</span>
<a href="#l81.484"></a><span id="l81.484">   result = 60 * result + mins;</span>
<a href="#l81.485"></a><span id="l81.485">   result = 60 * result + sec;</span>
<a href="#l81.486"></a><span id="l81.486"> </span>
<a href="#l81.487"></a><span id="l81.487">   return result;</span>
<a href="#l81.488"></a><span id="l81.488"> }</span>
<a href="#l81.489"></a><span id="l81.489"> </span>
<a href="#l81.490"></a><span id="l81.490" class="difflineminus">-static int searchaction(LDAP *ld, char *buf, char *base, LDAPMessage *entry,</span>
<a href="#l81.491"></a><span id="l81.491" class="difflineminus">-                        char *dn, struct ldap_tmplitem *tip, int labelwidth,</span>
<a href="#l81.492"></a><span id="l81.492" class="difflineminus">-                        int rdncount, writeptype writeproc, void *writeparm,</span>
<a href="#l81.493"></a><span id="l81.493" class="difflineminus">-                        char *eol, char *urlprefix) {</span>
<a href="#l81.494"></a><span id="l81.494" class="difflineplus">+static int searchaction(LDAP* ld, char* buf, char* base, LDAPMessage* entry,</span>
<a href="#l81.495"></a><span id="l81.495" class="difflineplus">+                        char* dn, struct ldap_tmplitem* tip, int labelwidth,</span>
<a href="#l81.496"></a><span id="l81.496" class="difflineplus">+                        int rdncount, writeptype writeproc, void* writeparm,</span>
<a href="#l81.497"></a><span id="l81.497" class="difflineplus">+                        char* eol, char* urlprefix) {</span>
<a href="#l81.498"></a><span id="l81.498">   int err = LDAP_SUCCESS, lderr, i, count, html;</span>
<a href="#l81.499"></a><span id="l81.499">   char **vals, **members;</span>
<a href="#l81.500"></a><span id="l81.500">   char *value, *filtpattern, *attr, *selectname;</span>
<a href="#l81.501"></a><span id="l81.501">   char *retattrs[2], filter[256];</span>
<a href="#l81.502"></a><span id="l81.502" class="difflineminus">-  LDAPMessage *ldmp;</span>
<a href="#l81.503"></a><span id="l81.503" class="difflineplus">+  LDAPMessage* ldmp;</span>
<a href="#l81.504"></a><span id="l81.504">   struct timeval timeout;</span>
<a href="#l81.505"></a><span id="l81.505"> </span>
<a href="#l81.506"></a><span id="l81.506">   html = (urlprefix != NULL);</span>
<a href="#l81.507"></a><span id="l81.507"> </span>
<a href="#l81.508"></a><span id="l81.508">   for (i = 0; tip-&gt;ti_args != NULL &amp;&amp; tip-&gt;ti_args[i] != NULL; ++i) {</span>
<a href="#l81.509"></a><span id="l81.509">     ;</span>
<a href="#l81.510"></a><span id="l81.510">   }</span>
<a href="#l81.511"></a><span id="l81.511">   if (i &lt; 3) {</span>
<a href="#l81.512"></a><span id="l81.512" class="difflineat">@@ -981,17 +981,17 @@ static int searchaction(LDAP *ld, char *</span>
<a href="#l81.513"></a><span id="l81.513">                            &amp;ldmp, NULL);</span>
<a href="#l81.514"></a><span id="l81.514">   else</span>
<a href="#l81.515"></a><span id="l81.515"> #endif /* CLDAP */</span>
<a href="#l81.516"></a><span id="l81.516">     lderr = ldap_search_st(ld, base, LDAP_SCOPE_SUBTREE, filter, retattrs, 0,</span>
<a href="#l81.517"></a><span id="l81.517">                            &amp;timeout, &amp;ldmp);</span>
<a href="#l81.518"></a><span id="l81.518"> </span>
<a href="#l81.519"></a><span id="l81.519">   if (lderr == LDAP_SUCCESS || NONFATAL_LDAP_ERR(lderr)) {</span>
<a href="#l81.520"></a><span id="l81.520">     if ((count = ldap_count_entries(ld, ldmp)) &gt; 0) {</span>
<a href="#l81.521"></a><span id="l81.521" class="difflineminus">-      if ((members = (char **)NSLDAPI_MALLOC((count + 1) * sizeof(char *))) ==</span>
<a href="#l81.522"></a><span id="l81.522" class="difflineplus">+      if ((members = (char**)NSLDAPI_MALLOC((count + 1) * sizeof(char*))) ==</span>
<a href="#l81.523"></a><span id="l81.523">           NULL) {</span>
<a href="#l81.524"></a><span id="l81.524">         err = LDAP_NO_MEMORY;</span>
<a href="#l81.525"></a><span id="l81.525">       } else {</span>
<a href="#l81.526"></a><span id="l81.526">         for (i = 0, entry = ldap_first_entry(ld, ldmp); entry != NULL;</span>
<a href="#l81.527"></a><span id="l81.527">              entry = ldap_next_entry(ld, entry), ++i) {</span>
<a href="#l81.528"></a><span id="l81.528">           members[i] = ldap_get_dn(ld, entry);</span>
<a href="#l81.529"></a><span id="l81.529">         }</span>
<a href="#l81.530"></a><span id="l81.530">         members[i] = NULL;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l82.1"></a><span id="l82.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/tmpltest.c</span>
<a href="#l82.2"></a><span id="l82.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/tmpltest.c</span>
<a href="#l82.3"></a><span id="l82.3" class="difflineat">@@ -48,26 +48,26 @@</span>
<a href="#l82.4"></a><span id="l82.4"> #include &quot;srchpref.h&quot;</span>
<a href="#l82.5"></a><span id="l82.5"> </span>
<a href="#l82.6"></a><span id="l82.6"> #ifdef MACOS</span>
<a href="#l82.7"></a><span id="l82.7"> #  include &lt;stdlib.h&gt;</span>
<a href="#l82.8"></a><span id="l82.8"> #  include &lt;console.h&gt;</span>
<a href="#l82.9"></a><span id="l82.9"> #endif /* MACOS */</span>
<a href="#l82.10"></a><span id="l82.10"> </span>
<a href="#l82.11"></a><span id="l82.11"> #ifdef NEEDPROTOS</span>
<a href="#l82.12"></a><span id="l82.12" class="difflineminus">-void dump_tmpl(struct ldap_disptmpl *tmpl);</span>
<a href="#l82.13"></a><span id="l82.13" class="difflineminus">-void dump_srchpref(struct ldap_searchobj *sp);</span>
<a href="#l82.14"></a><span id="l82.14" class="difflineplus">+void dump_tmpl(struct ldap_disptmpl* tmpl);</span>
<a href="#l82.15"></a><span id="l82.15" class="difflineplus">+void dump_srchpref(struct ldap_searchobj* sp);</span>
<a href="#l82.16"></a><span id="l82.16"> #else  /* NEEDPROTOS */</span>
<a href="#l82.17"></a><span id="l82.17"> void dump_tmpl();</span>
<a href="#l82.18"></a><span id="l82.18"> void dump_srchpref();</span>
<a href="#l82.19"></a><span id="l82.19"> #endif /* NEEDPROTOS */</span>
<a href="#l82.20"></a><span id="l82.20"> </span>
<a href="#l82.21"></a><span id="l82.21"> #define NULLSTRINGIFNULL(s) (s == NULL ? &quot;(null)&quot; : s)</span>
<a href="#l82.22"></a><span id="l82.22"> </span>
<a href="#l82.23"></a><span id="l82.23" class="difflineminus">-int main(int argc, char **argv) {</span>
<a href="#l82.24"></a><span id="l82.24" class="difflineplus">+int main(int argc, char** argv) {</span>
<a href="#l82.25"></a><span id="l82.25">   struct ldap_disptmpl *templates, *dtp;</span>
<a href="#l82.26"></a><span id="l82.26">   struct ldap_searchobj *so, *sop;</span>
<a href="#l82.27"></a><span id="l82.27">   int err;</span>
<a href="#l82.28"></a><span id="l82.28"> </span>
<a href="#l82.29"></a><span id="l82.29"> #ifdef MACOS</span>
<a href="#l82.30"></a><span id="l82.30">   ccommand(&amp;argv);</span>
<a href="#l82.31"></a><span id="l82.31">   for (argc = 0; argv[argc] != NULL; ++argc) {</span>
<a href="#l82.32"></a><span id="l82.32">     ;</span>
<a href="#l82.33"></a><span id="l82.33" class="difflineat">@@ -109,43 +109,43 @@ int main(int argc, char **argv) {</span>
<a href="#l82.34"></a><span id="l82.34">   }</span>
<a href="#l82.35"></a><span id="l82.35"> </span>
<a href="#l82.36"></a><span id="l82.36">   ldap_free_templates(templates);</span>
<a href="#l82.37"></a><span id="l82.37">   ldap_free_searchprefs(so);</span>
<a href="#l82.38"></a><span id="l82.38"> </span>
<a href="#l82.39"></a><span id="l82.39">   exit(0);</span>
<a href="#l82.40"></a><span id="l82.40"> }</span>
<a href="#l82.41"></a><span id="l82.41"> </span>
<a href="#l82.42"></a><span id="l82.42" class="difflineminus">-static char *syn_name[] = {</span>
<a href="#l82.43"></a><span id="l82.43" class="difflineplus">+static char* syn_name[] = {</span>
<a href="#l82.44"></a><span id="l82.44">     &quot;?&quot;,       &quot;CIS&quot;,       &quot;MLS&quot;,     &quot;DN&quot;,       &quot;BOOL&quot;,      &quot;JPEG&quot;,</span>
<a href="#l82.45"></a><span id="l82.45">     &quot;JPEGBTN&quot;, &quot;FAX&quot;,       &quot;FAXBTN&quot;,  &quot;AUDIOBTN&quot;, &quot;TIME&quot;,      &quot;DATE&quot;,</span>
<a href="#l82.46"></a><span id="l82.46">     &quot;URL&quot;,     &quot;SEARCHACT&quot;, &quot;LINKACT&quot;, &quot;ADDDNACT&quot;, &quot;VERIFYACT&quot;,</span>
<a href="#l82.47"></a><span id="l82.47"> };</span>
<a href="#l82.48"></a><span id="l82.48"> </span>
<a href="#l82.49"></a><span id="l82.49" class="difflineminus">-static char *syn_type[] = {&quot;?&quot;, &quot;txt&quot;, &quot;img&quot;, &quot;?&quot;, &quot;bool&quot;,   &quot;?&quot;,</span>
<a href="#l82.50"></a><span id="l82.50" class="difflineplus">+static char* syn_type[] = {&quot;?&quot;, &quot;txt&quot;, &quot;img&quot;, &quot;?&quot;, &quot;bool&quot;,   &quot;?&quot;,</span>
<a href="#l82.51"></a><span id="l82.51">                            &quot;?&quot;, &quot;?&quot;,   &quot;btn&quot;, &quot;?&quot;, &quot;?&quot;,      &quot;?&quot;,</span>
<a href="#l82.52"></a><span id="l82.52">                            &quot;?&quot;, &quot;?&quot;,   &quot;?&quot;,   &quot;?&quot;, &quot;action&quot;, &quot;?&quot;};</span>
<a href="#l82.53"></a><span id="l82.53"> </span>
<a href="#l82.54"></a><span id="l82.54" class="difflineminus">-static char *includeattrs[] = {&quot;objectClass&quot;, &quot;sn&quot;, NULL};</span>
<a href="#l82.55"></a><span id="l82.55" class="difflineplus">+static char* includeattrs[] = {&quot;objectClass&quot;, &quot;sn&quot;, NULL};</span>
<a href="#l82.56"></a><span id="l82.56"> </span>
<a href="#l82.57"></a><span id="l82.57" class="difflineminus">-static char *item_opts[] = {&quot;ro&quot;,       &quot;sort&quot;,        &quot;1val&quot;, &quot;hide&quot;,</span>
<a href="#l82.58"></a><span id="l82.58" class="difflineplus">+static char* item_opts[] = {&quot;ro&quot;,       &quot;sort&quot;,        &quot;1val&quot;, &quot;hide&quot;,</span>
<a href="#l82.59"></a><span id="l82.59">                             &quot;required&quot;, &quot;hideiffalse&quot;, NULL};</span>
<a href="#l82.60"></a><span id="l82.60"> </span>
<a href="#l82.61"></a><span id="l82.61"> static unsigned long item_opt_vals[] = {</span>
<a href="#l82.62"></a><span id="l82.62">     LDAP_DITEM_OPT_READONLY,      LDAP_DITEM_OPT_SORTVALUES,</span>
<a href="#l82.63"></a><span id="l82.63">     LDAP_DITEM_OPT_SINGLEVALUED,  LDAP_DITEM_OPT_HIDEIFEMPTY,</span>
<a href="#l82.64"></a><span id="l82.64">     LDAP_DITEM_OPT_VALUEREQUIRED, LDAP_DITEM_OPT_HIDEIFFALSE,</span>
<a href="#l82.65"></a><span id="l82.65"> };</span>
<a href="#l82.66"></a><span id="l82.66"> </span>
<a href="#l82.67"></a><span id="l82.67" class="difflineminus">-void dump_tmpl(struct ldap_disptmpl *tmpl) {</span>
<a href="#l82.68"></a><span id="l82.68" class="difflineplus">+void dump_tmpl(struct ldap_disptmpl* tmpl) {</span>
<a href="#l82.69"></a><span id="l82.69">   struct ldap_tmplitem *rowp, *colp;</span>
<a href="#l82.70"></a><span id="l82.70">   int i, rowcnt, colcnt;</span>
<a href="#l82.71"></a><span id="l82.71" class="difflineminus">-  char **fetchattrs;</span>
<a href="#l82.72"></a><span id="l82.72" class="difflineminus">-  struct ldap_oclist *ocp;</span>
<a href="#l82.73"></a><span id="l82.73" class="difflineminus">-  struct ldap_adddeflist *adp;</span>
<a href="#l82.74"></a><span id="l82.74" class="difflineplus">+  char** fetchattrs;</span>
<a href="#l82.75"></a><span id="l82.75" class="difflineplus">+  struct ldap_oclist* ocp;</span>
<a href="#l82.76"></a><span id="l82.76" class="difflineplus">+  struct ldap_adddeflist* adp;</span>
<a href="#l82.77"></a><span id="l82.77"> </span>
<a href="#l82.78"></a><span id="l82.78">   printf(&quot;** Template \&quot;%s\&quot; (plural \&quot;%s\&quot;, icon \&quot;%s\&quot;)\n&quot;,</span>
<a href="#l82.79"></a><span id="l82.79">          NULLSTRINGIFNULL(tmpl-&gt;dt_name), NULLSTRINGIFNULL(tmpl-&gt;dt_pluralname),</span>
<a href="#l82.80"></a><span id="l82.80">          NULLSTRINGIFNULL(tmpl-&gt;dt_iconname));</span>
<a href="#l82.81"></a><span id="l82.81"> </span>
<a href="#l82.82"></a><span id="l82.82">   printf(&quot;object class list:\n&quot;);</span>
<a href="#l82.83"></a><span id="l82.83">   for (ocp = tmpl-&gt;dt_oclist; ocp != NULL; ocp = ocp-&gt;oc_next) {</span>
<a href="#l82.84"></a><span id="l82.84">     for (i = 0; ocp-&gt;oc_objclasses[i] != NULL; ++i) {</span>
<a href="#l82.85"></a><span id="l82.85" class="difflineat">@@ -196,29 +196,29 @@ void dump_tmpl(struct ldap_disptmpl *tmp</span>
<a href="#l82.86"></a><span id="l82.86">   if ((fetchattrs =</span>
<a href="#l82.87"></a><span id="l82.87">            ldap_tmplattrs(tmpl, includeattrs, 1, LDAP_SYN_OPT_DEFER)) == NULL) {</span>
<a href="#l82.88"></a><span id="l82.88">     printf(&quot;  &lt;none&gt;\n&quot;);</span>
<a href="#l82.89"></a><span id="l82.89">   } else {</span>
<a href="#l82.90"></a><span id="l82.90">     for (i = 0; fetchattrs[i] != NULL; ++i) {</span>
<a href="#l82.91"></a><span id="l82.91">       printf(&quot;  %s\n&quot;, fetchattrs[i]);</span>
<a href="#l82.92"></a><span id="l82.92">       free(fetchattrs[i]);</span>
<a href="#l82.93"></a><span id="l82.93">     }</span>
<a href="#l82.94"></a><span id="l82.94" class="difflineminus">-    free((char *)fetchattrs);</span>
<a href="#l82.95"></a><span id="l82.95" class="difflineplus">+    free((char*)fetchattrs);</span>
<a href="#l82.96"></a><span id="l82.96">   }</span>
<a href="#l82.97"></a><span id="l82.97"> </span>
<a href="#l82.98"></a><span id="l82.98">   printf(&quot;\nfetch attributes only:\n&quot;);</span>
<a href="#l82.99"></a><span id="l82.99">   if ((fetchattrs = ldap_tmplattrs(tmpl, NULL, 0, LDAP_SYN_OPT_DEFER)) ==</span>
<a href="#l82.100"></a><span id="l82.100">       NULL) {</span>
<a href="#l82.101"></a><span id="l82.101">     printf(&quot;  &lt;none&gt;\n&quot;);</span>
<a href="#l82.102"></a><span id="l82.102">   } else {</span>
<a href="#l82.103"></a><span id="l82.103">     for (i = 0; fetchattrs[i] != NULL; ++i) {</span>
<a href="#l82.104"></a><span id="l82.104">       printf(&quot;  %s\n&quot;, fetchattrs[i]);</span>
<a href="#l82.105"></a><span id="l82.105">       free(fetchattrs[i]);</span>
<a href="#l82.106"></a><span id="l82.106">     }</span>
<a href="#l82.107"></a><span id="l82.107" class="difflineminus">-    free((char *)fetchattrs);</span>
<a href="#l82.108"></a><span id="l82.108" class="difflineplus">+    free((char*)fetchattrs);</span>
<a href="#l82.109"></a><span id="l82.109">   }</span>
<a href="#l82.110"></a><span id="l82.110"> </span>
<a href="#l82.111"></a><span id="l82.111">   printf(&quot;\ntemplate items:\n&quot;);</span>
<a href="#l82.112"></a><span id="l82.112">   rowcnt = 0;</span>
<a href="#l82.113"></a><span id="l82.113">   for (rowp = ldap_first_tmplrow(tmpl); rowp != NULLTMPLITEM;</span>
<a href="#l82.114"></a><span id="l82.114">        rowp = ldap_next_tmplrow(tmpl, rowp)) {</span>
<a href="#l82.115"></a><span id="l82.115">     ++rowcnt;</span>
<a href="#l82.116"></a><span id="l82.116">     colcnt = 0;</span>
<a href="#l82.117"></a><span id="l82.117" class="difflineat">@@ -248,20 +248,20 @@ void dump_tmpl(struct ldap_disptmpl *tmp</span>
<a href="#l82.118"></a><span id="l82.118">         }</span>
<a href="#l82.119"></a><span id="l82.119">       }</span>
<a href="#l82.120"></a><span id="l82.120"> </span>
<a href="#l82.121"></a><span id="l82.121">       putchar('\n');</span>
<a href="#l82.122"></a><span id="l82.122">     }</span>
<a href="#l82.123"></a><span id="l82.123">   }</span>
<a href="#l82.124"></a><span id="l82.124"> }</span>
<a href="#l82.125"></a><span id="l82.125"> </span>
<a href="#l82.126"></a><span id="l82.126" class="difflineminus">-void dump_srchpref(struct ldap_searchobj *so) {</span>
<a href="#l82.127"></a><span id="l82.127" class="difflineplus">+void dump_srchpref(struct ldap_searchobj* so) {</span>
<a href="#l82.128"></a><span id="l82.128">   int i;</span>
<a href="#l82.129"></a><span id="l82.129" class="difflineminus">-  struct ldap_searchattr *sa;</span>
<a href="#l82.130"></a><span id="l82.130" class="difflineminus">-  struct ldap_searchmatch *sm;</span>
<a href="#l82.131"></a><span id="l82.131" class="difflineplus">+  struct ldap_searchattr* sa;</span>
<a href="#l82.132"></a><span id="l82.132" class="difflineplus">+  struct ldap_searchmatch* sm;</span>
<a href="#l82.133"></a><span id="l82.133"> </span>
<a href="#l82.134"></a><span id="l82.134">   printf(&quot;Object type prompt:  %s\n&quot;, NULLSTRINGIFNULL(so-&gt;so_objtypeprompt));</span>
<a href="#l82.135"></a><span id="l82.135">   printf(&quot;Options:             %s\n&quot;,</span>
<a href="#l82.136"></a><span id="l82.136">          LDAP_IS_SEARCHOBJ_OPTION_SET(so, LDAP_SEARCHOBJ_OPT_INTERNAL)</span>
<a href="#l82.137"></a><span id="l82.137">              ? &quot;internal&quot;</span>
<a href="#l82.138"></a><span id="l82.138">              : &quot;NONE&quot;);</span>
<a href="#l82.139"></a><span id="l82.139">   printf(&quot;Prompt:              %s\n&quot;, NULLSTRINGIFNULL(so-&gt;so_prompt));</span>
<a href="#l82.140"></a><span id="l82.140">   printf(&quot;Scope:               &quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l83.1"></a><span id="l83.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/ufn.c</span>
<a href="#l83.2"></a><span id="l83.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/ufn.c</span>
<a href="#l83.3"></a><span id="l83.3" class="difflineat">@@ -45,30 +45,30 @@</span>
<a href="#l83.4"></a><span id="l83.4"> #if 0</span>
<a href="#l83.5"></a><span id="l83.5"> #  ifndef lint</span>
<a href="#l83.6"></a><span id="l83.6"> static char copyright[] = &quot;@(#) Copyright (c) 1993 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l83.7"></a><span id="l83.7"> #  endif</span>
<a href="#l83.8"></a><span id="l83.8"> #endif</span>
<a href="#l83.9"></a><span id="l83.9"> </span>
<a href="#l83.10"></a><span id="l83.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l83.11"></a><span id="l83.11"> </span>
<a href="#l83.12"></a><span id="l83.12" class="difflineminus">-typedef int(LDAP_CALL *cancelptype)(void *cancelparm);</span>
<a href="#l83.13"></a><span id="l83.13" class="difflineplus">+typedef int(LDAP_CALL* cancelptype)(void* cancelparm);</span>
<a href="#l83.14"></a><span id="l83.14"> </span>
<a href="#l83.15"></a><span id="l83.15" class="difflineminus">-static int ldap_ufn_search_ctx(LDAP *ld, char **ufncomp, int ncomp,</span>
<a href="#l83.16"></a><span id="l83.16" class="difflineminus">-                               char *prefix, char **attrs, int attrsonly,</span>
<a href="#l83.17"></a><span id="l83.17" class="difflineminus">-                               LDAPMessage **res,</span>
<a href="#l83.18"></a><span id="l83.18" class="difflineminus">-                               LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l83.19"></a><span id="l83.19" class="difflineminus">-                               void *cancelparm, char *tag1, char *tag2,</span>
<a href="#l83.20"></a><span id="l83.20" class="difflineminus">-                               char *tag3);</span>
<a href="#l83.21"></a><span id="l83.21" class="difflineminus">-static LDAPMessage *ldap_msg_merge(LDAP *ld, LDAPMessage *a, LDAPMessage *b);</span>
<a href="#l83.22"></a><span id="l83.22" class="difflineminus">-static LDAPMessage *ldap_ufn_expand(LDAP *ld,</span>
<a href="#l83.23"></a><span id="l83.23" class="difflineminus">-                                    LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l83.24"></a><span id="l83.24" class="difflineminus">-                                    void *cancelparm, char **dns, char *filter,</span>
<a href="#l83.25"></a><span id="l83.25" class="difflineminus">-                                    int scope, char **attrs, int aonly,</span>
<a href="#l83.26"></a><span id="l83.26" class="difflineminus">-                                    int *err);</span>
<a href="#l83.27"></a><span id="l83.27" class="difflineplus">+static int ldap_ufn_search_ctx(LDAP* ld, char** ufncomp, int ncomp,</span>
<a href="#l83.28"></a><span id="l83.28" class="difflineplus">+                               char* prefix, char** attrs, int attrsonly,</span>
<a href="#l83.29"></a><span id="l83.29" class="difflineplus">+                               LDAPMessage** res,</span>
<a href="#l83.30"></a><span id="l83.30" class="difflineplus">+                               LDAP_CANCELPROC_CALLBACK* cancelproc,</span>
<a href="#l83.31"></a><span id="l83.31" class="difflineplus">+                               void* cancelparm, char* tag1, char* tag2,</span>
<a href="#l83.32"></a><span id="l83.32" class="difflineplus">+                               char* tag3);</span>
<a href="#l83.33"></a><span id="l83.33" class="difflineplus">+static LDAPMessage* ldap_msg_merge(LDAP* ld, LDAPMessage* a, LDAPMessage* b);</span>
<a href="#l83.34"></a><span id="l83.34" class="difflineplus">+static LDAPMessage* ldap_ufn_expand(LDAP* ld,</span>
<a href="#l83.35"></a><span id="l83.35" class="difflineplus">+                                    LDAP_CANCELPROC_CALLBACK* cancelproc,</span>
<a href="#l83.36"></a><span id="l83.36" class="difflineplus">+                                    void* cancelparm, char** dns, char* filter,</span>
<a href="#l83.37"></a><span id="l83.37" class="difflineplus">+                                    int scope, char** attrs, int aonly,</span>
<a href="#l83.38"></a><span id="l83.38" class="difflineplus">+                                    int* err);</span>
<a href="#l83.39"></a><span id="l83.39"> </span>
<a href="#l83.40"></a><span id="l83.40"> /*</span>
<a href="#l83.41"></a><span id="l83.41">  * ldap_ufn_search_ctx - do user friendly searching; provide cancel feature;</span>
<a href="#l83.42"></a><span id="l83.42">  *     specify ldapfilter.conf tags for each phase of search</span>
<a href="#l83.43"></a><span id="l83.43">  *</span>
<a href="#l83.44"></a><span id="l83.44">  * ld          LDAP descriptor</span>
<a href="#l83.45"></a><span id="l83.45">  * ufncomp     the exploded user friendly name to look for</span>
<a href="#l83.46"></a><span id="l83.46">  * ncomp       number of elements in ufncomp</span>
<a href="#l83.47"></a><span id="l83.47" class="difflineat">@@ -87,29 +87,29 @@ static LDAPMessage *ldap_ufn_expand(LDAP</span>
<a href="#l83.48"></a><span id="l83.48">  * char *attrs[] = { &quot;mail&quot;, &quot;title&quot;, 0 };</span>
<a href="#l83.49"></a><span id="l83.49">  * char *ufncomp[] = { &quot;howes&quot;, &quot;umich&quot;, &quot;us&quot;, 0 }</span>
<a href="#l83.50"></a><span id="l83.50">  * LDAPMessage *res;</span>
<a href="#l83.51"></a><span id="l83.51">  * error = ldap_ufn_search_ctx(ld, ufncomp, 3, NULL, attrs, attrsonly,</span>
<a href="#l83.52"></a><span id="l83.52">  *                             &amp;res, acancelproc, along, &quot;ufn first&quot;,</span>
<a href="#l83.53"></a><span id="l83.53">  *                             &quot;ufn intermediate&quot;, &quot;ufn last&quot;);</span>
<a href="#l83.54"></a><span id="l83.54">  */</span>
<a href="#l83.55"></a><span id="l83.55"> </span>
<a href="#l83.56"></a><span id="l83.56" class="difflineminus">-static int ldap_ufn_search_ctx(LDAP *ld, char **ufncomp, int ncomp,</span>
<a href="#l83.57"></a><span id="l83.57" class="difflineminus">-                               char *prefix, char **attrs, int attrsonly,</span>
<a href="#l83.58"></a><span id="l83.58" class="difflineminus">-                               LDAPMessage **res,</span>
<a href="#l83.59"></a><span id="l83.59" class="difflineminus">-                               LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l83.60"></a><span id="l83.60" class="difflineminus">-                               void *cancelparm, char *tag1, char *tag2,</span>
<a href="#l83.61"></a><span id="l83.61" class="difflineminus">-                               char *tag3) {</span>
<a href="#l83.62"></a><span id="l83.62" class="difflineplus">+static int ldap_ufn_search_ctx(LDAP* ld, char** ufncomp, int ncomp,</span>
<a href="#l83.63"></a><span id="l83.63" class="difflineplus">+                               char* prefix, char** attrs, int attrsonly,</span>
<a href="#l83.64"></a><span id="l83.64" class="difflineplus">+                               LDAPMessage** res,</span>
<a href="#l83.65"></a><span id="l83.65" class="difflineplus">+                               LDAP_CANCELPROC_CALLBACK* cancelproc,</span>
<a href="#l83.66"></a><span id="l83.66" class="difflineplus">+                               void* cancelparm, char* tag1, char* tag2,</span>
<a href="#l83.67"></a><span id="l83.67" class="difflineplus">+                               char* tag3) {</span>
<a href="#l83.68"></a><span id="l83.68">   char *dn, *ftag = NULL;</span>
<a href="#l83.69"></a><span id="l83.69" class="difflineminus">-  char **dns = NULL;</span>
<a href="#l83.70"></a><span id="l83.70" class="difflineplus">+  char** dns = NULL;</span>
<a href="#l83.71"></a><span id="l83.71">   int max, i, err, scope = 0, phase, tries;</span>
<a href="#l83.72"></a><span id="l83.72" class="difflineminus">-  LDAPFiltInfo *fi;</span>
<a href="#l83.73"></a><span id="l83.73" class="difflineminus">-  LDAPMessage *tmpcand;</span>
<a href="#l83.74"></a><span id="l83.74" class="difflineminus">-  LDAPMessage *candidates;</span>
<a href="#l83.75"></a><span id="l83.75" class="difflineminus">-  static char *objattrs[] = {&quot;objectClass&quot;, NULL};</span>
<a href="#l83.76"></a><span id="l83.76" class="difflineplus">+  LDAPFiltInfo* fi;</span>
<a href="#l83.77"></a><span id="l83.77" class="difflineplus">+  LDAPMessage* tmpcand;</span>
<a href="#l83.78"></a><span id="l83.78" class="difflineplus">+  LDAPMessage* candidates;</span>
<a href="#l83.79"></a><span id="l83.79" class="difflineplus">+  static char* objattrs[] = {&quot;objectClass&quot;, NULL};</span>
<a href="#l83.80"></a><span id="l83.80"> </span>
<a href="#l83.81"></a><span id="l83.81">   /*</span>
<a href="#l83.82"></a><span id="l83.82">    * look up ufn components from most to least significant.</span>
<a href="#l83.83"></a><span id="l83.83">    * there are 3 phases.</span>
<a href="#l83.84"></a><span id="l83.84">    *   phase 1  search the root for orgs or countries</span>
<a href="#l83.85"></a><span id="l83.85">    *   phase 2  search for orgs</span>
<a href="#l83.86"></a><span id="l83.86">    *   phase 3  search for a person</span>
<a href="#l83.87"></a><span id="l83.87">    * in phases 1 and 2, we are building a list of candidate DNs,</span>
<a href="#l83.88"></a><span id="l83.88" class="difflineat">@@ -120,17 +120,17 @@ static int ldap_ufn_search_ctx(LDAP *ld,</span>
<a href="#l83.89"></a><span id="l83.89">    * the next component.</span>
<a href="#l83.90"></a><span id="l83.90">    */</span>
<a href="#l83.91"></a><span id="l83.91"> </span>
<a href="#l83.92"></a><span id="l83.92">   *res = NULL;</span>
<a href="#l83.93"></a><span id="l83.93">   candidates = NULL;</span>
<a href="#l83.94"></a><span id="l83.94">   phase = 1;</span>
<a href="#l83.95"></a><span id="l83.95">   for (ncomp--; ncomp != -1; ncomp--) {</span>
<a href="#l83.96"></a><span id="l83.96">     if (*ufncomp[ncomp] == '&quot;') {</span>
<a href="#l83.97"></a><span id="l83.97" class="difflineminus">-      char *quote;</span>
<a href="#l83.98"></a><span id="l83.98" class="difflineplus">+      char* quote;</span>
<a href="#l83.99"></a><span id="l83.99"> </span>
<a href="#l83.100"></a><span id="l83.100">       if ((quote = strrchr(ufncomp[ncomp], '&quot;')) != NULL) *quote = '\0';</span>
<a href="#l83.101"></a><span id="l83.101">       strcpy(ufncomp[ncomp], ufncomp[ncomp] + 1);</span>
<a href="#l83.102"></a><span id="l83.102">     }</span>
<a href="#l83.103"></a><span id="l83.103">     if (ncomp == 0) phase = 3;</span>
<a href="#l83.104"></a><span id="l83.104"> </span>
<a href="#l83.105"></a><span id="l83.105">     switch (phase) {</span>
<a href="#l83.106"></a><span id="l83.106">       case 1:</span>
<a href="#l83.107"></a><span id="l83.107" class="difflineat">@@ -149,17 +149,17 @@ static int ldap_ufn_search_ctx(LDAP *ld,</span>
<a href="#l83.108"></a><span id="l83.108"> </span>
<a href="#l83.109"></a><span id="l83.109">     /*</span>
<a href="#l83.110"></a><span id="l83.110">      * construct an array of DN's to search below from the</span>
<a href="#l83.111"></a><span id="l83.111">      * list of candidates.</span>
<a href="#l83.112"></a><span id="l83.112">      */</span>
<a href="#l83.113"></a><span id="l83.113"> </span>
<a href="#l83.114"></a><span id="l83.114">     if (candidates == NULL) {</span>
<a href="#l83.115"></a><span id="l83.115">       if (prefix != NULL) {</span>
<a href="#l83.116"></a><span id="l83.116" class="difflineminus">-        if ((dns = (char **)NSLDAPI_MALLOC(sizeof(char *) * 2)) == NULL) {</span>
<a href="#l83.117"></a><span id="l83.117" class="difflineplus">+        if ((dns = (char**)NSLDAPI_MALLOC(sizeof(char*) * 2)) == NULL) {</span>
<a href="#l83.118"></a><span id="l83.118">           err = LDAP_NO_MEMORY;</span>
<a href="#l83.119"></a><span id="l83.119">           LDAP_SET_LDERRNO(ld, err, NULL, NULL);</span>
<a href="#l83.120"></a><span id="l83.120">           return (err);</span>
<a href="#l83.121"></a><span id="l83.121">         }</span>
<a href="#l83.122"></a><span id="l83.122">         dns[0] = nsldapi_strdup(prefix);</span>
<a href="#l83.123"></a><span id="l83.123">         dns[1] = NULL;</span>
<a href="#l83.124"></a><span id="l83.124">       } else {</span>
<a href="#l83.125"></a><span id="l83.125">         dns = NULL;</span>
<a href="#l83.126"></a><span id="l83.126" class="difflineat">@@ -167,24 +167,24 @@ static int ldap_ufn_search_ctx(LDAP *ld,</span>
<a href="#l83.127"></a><span id="l83.127">     } else {</span>
<a href="#l83.128"></a><span id="l83.128">       i = 0, max = 0;</span>
<a href="#l83.129"></a><span id="l83.129">       for (tmpcand = candidates;</span>
<a href="#l83.130"></a><span id="l83.130">            tmpcand != NULL &amp;&amp; tmpcand-&gt;lm_msgtype != LDAP_RES_SEARCH_RESULT;</span>
<a href="#l83.131"></a><span id="l83.131">            tmpcand = tmpcand-&gt;lm_chain) {</span>
<a href="#l83.132"></a><span id="l83.132">         if ((dn = ldap_get_dn(ld, tmpcand)) == NULL) continue;</span>
<a href="#l83.133"></a><span id="l83.133"> </span>
<a href="#l83.134"></a><span id="l83.134">         if (dns == NULL) {</span>
<a href="#l83.135"></a><span id="l83.135" class="difflineminus">-          if ((dns = (char **)NSLDAPI_MALLOC(sizeof(char *) * 8)) == NULL) {</span>
<a href="#l83.136"></a><span id="l83.136" class="difflineplus">+          if ((dns = (char**)NSLDAPI_MALLOC(sizeof(char*) * 8)) == NULL) {</span>
<a href="#l83.137"></a><span id="l83.137">             err = LDAP_NO_MEMORY;</span>
<a href="#l83.138"></a><span id="l83.138">             LDAP_SET_LDERRNO(ld, err, NULL, NULL);</span>
<a href="#l83.139"></a><span id="l83.139">             return (err);</span>
<a href="#l83.140"></a><span id="l83.140">           }</span>
<a href="#l83.141"></a><span id="l83.141">           max = 8;</span>
<a href="#l83.142"></a><span id="l83.142">         } else if (i &gt;= max) {</span>
<a href="#l83.143"></a><span id="l83.143" class="difflineminus">-          if ((dns = (char **)NSLDAPI_REALLOC(dns, sizeof(char *) * 2 * max)) ==</span>
<a href="#l83.144"></a><span id="l83.144" class="difflineplus">+          if ((dns = (char**)NSLDAPI_REALLOC(dns, sizeof(char*) * 2 * max)) ==</span>
<a href="#l83.145"></a><span id="l83.145">               NULL) {</span>
<a href="#l83.146"></a><span id="l83.146">             err = LDAP_NO_MEMORY;</span>
<a href="#l83.147"></a><span id="l83.147">             LDAP_SET_LDERRNO(ld, err, NULL, NULL);</span>
<a href="#l83.148"></a><span id="l83.148">             return (err);</span>
<a href="#l83.149"></a><span id="l83.149">           }</span>
<a href="#l83.150"></a><span id="l83.150">           max *= 2;</span>
<a href="#l83.151"></a><span id="l83.151">         }</span>
<a href="#l83.152"></a><span id="l83.152">         dns[i++] = dn;</span>
<a href="#l83.153"></a><span id="l83.153" class="difflineat">@@ -234,23 +234,23 @@ static int ldap_ufn_search_ctx(LDAP *ld,</span>
<a href="#l83.154"></a><span id="l83.154">       dns = NULL;</span>
<a href="#l83.155"></a><span id="l83.155">     }</span>
<a href="#l83.156"></a><span id="l83.156">   }</span>
<a href="#l83.157"></a><span id="l83.157">   *res = candidates;</span>
<a href="#l83.158"></a><span id="l83.158"> </span>
<a href="#l83.159"></a><span id="l83.159">   return (err);</span>
<a href="#l83.160"></a><span id="l83.160"> }</span>
<a href="#l83.161"></a><span id="l83.161"> </span>
<a href="#l83.162"></a><span id="l83.162" class="difflineminus">-int LDAP_CALL ldap_ufn_search_ct(LDAP *ld, char *ufn, char **attrs,</span>
<a href="#l83.163"></a><span id="l83.163" class="difflineminus">-                                 int attrsonly, LDAPMessage **res,</span>
<a href="#l83.164"></a><span id="l83.164" class="difflineminus">-                                 LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l83.165"></a><span id="l83.165" class="difflineminus">-                                 void *cancelparm, char *tag1, char *tag2,</span>
<a href="#l83.166"></a><span id="l83.166" class="difflineminus">-                                 char *tag3) {</span>
<a href="#l83.167"></a><span id="l83.167" class="difflineplus">+int LDAP_CALL ldap_ufn_search_ct(LDAP* ld, char* ufn, char** attrs,</span>
<a href="#l83.168"></a><span id="l83.168" class="difflineplus">+                                 int attrsonly, LDAPMessage** res,</span>
<a href="#l83.169"></a><span id="l83.169" class="difflineplus">+                                 LDAP_CANCELPROC_CALLBACK* cancelproc,</span>
<a href="#l83.170"></a><span id="l83.170" class="difflineplus">+                                 void* cancelparm, char* tag1, char* tag2,</span>
<a href="#l83.171"></a><span id="l83.171" class="difflineplus">+                                 char* tag3) {</span>
<a href="#l83.172"></a><span id="l83.172">   char **ufncomp, **prefixcomp;</span>
<a href="#l83.173"></a><span id="l83.173" class="difflineminus">-  char *pbuf;</span>
<a href="#l83.174"></a><span id="l83.174" class="difflineplus">+  char* pbuf;</span>
<a href="#l83.175"></a><span id="l83.175">   int ncomp, pcomp, i, err = 0;</span>
<a href="#l83.176"></a><span id="l83.176"> </span>
<a href="#l83.177"></a><span id="l83.177">   /* getfilter stuff must be inited before we are called */</span>
<a href="#l83.178"></a><span id="l83.178">   if (ld-&gt;ld_filtd == NULL) {</span>
<a href="#l83.179"></a><span id="l83.179">     err = LDAP_PARAM_ERROR;</span>
<a href="#l83.180"></a><span id="l83.180">     LDAP_SET_LDERRNO(ld, err, NULL, NULL);</span>
<a href="#l83.181"></a><span id="l83.181">     return (err);</span>
<a href="#l83.182"></a><span id="l83.182">   }</span>
<a href="#l83.183"></a><span id="l83.183" class="difflineat">@@ -287,17 +287,17 @@ int LDAP_CALL ldap_ufn_search_ct(LDAP *l</span>
<a href="#l83.184"></a><span id="l83.184">   if ((prefixcomp = ldap_explode_dn(ld-&gt;ld_ufnprefix, 0)) == NULL) {</span>
<a href="#l83.185"></a><span id="l83.185">     ldap_value_free(ufncomp);</span>
<a href="#l83.186"></a><span id="l83.186">     err = LDAP_LOCAL_ERROR;</span>
<a href="#l83.187"></a><span id="l83.187">     LDAP_SET_LDERRNO(ld, err, NULL, NULL);</span>
<a href="#l83.188"></a><span id="l83.188">     return (err);</span>
<a href="#l83.189"></a><span id="l83.189">   }</span>
<a href="#l83.190"></a><span id="l83.190">   for (pcomp = 0; prefixcomp[pcomp] != NULL; pcomp++)</span>
<a href="#l83.191"></a><span id="l83.191">     ; /* NULL */</span>
<a href="#l83.192"></a><span id="l83.192" class="difflineminus">-  if ((pbuf = (char *)NSLDAPI_MALLOC(strlen(ld-&gt;ld_ufnprefix) + 1)) == NULL) {</span>
<a href="#l83.193"></a><span id="l83.193" class="difflineplus">+  if ((pbuf = (char*)NSLDAPI_MALLOC(strlen(ld-&gt;ld_ufnprefix) + 1)) == NULL) {</span>
<a href="#l83.194"></a><span id="l83.194">     ldap_value_free(ufncomp);</span>
<a href="#l83.195"></a><span id="l83.195">     ldap_value_free(prefixcomp);</span>
<a href="#l83.196"></a><span id="l83.196">     err = LDAP_NO_MEMORY;</span>
<a href="#l83.197"></a><span id="l83.197">     LDAP_SET_LDERRNO(ld, err, NULL, NULL);</span>
<a href="#l83.198"></a><span id="l83.198">     return (err);</span>
<a href="#l83.199"></a><span id="l83.199">   }</span>
<a href="#l83.200"></a><span id="l83.200"> </span>
<a href="#l83.201"></a><span id="l83.201">   for (i = 0; i &lt; pcomp; i++) {</span>
<a href="#l83.202"></a><span id="l83.202" class="difflineat">@@ -325,46 +325,46 @@ int LDAP_CALL ldap_ufn_search_ct(LDAP *l</span>
<a href="#l83.203"></a><span id="l83.203"> </span>
<a href="#l83.204"></a><span id="l83.204">   return (err);</span>
<a href="#l83.205"></a><span id="l83.205"> }</span>
<a href="#l83.206"></a><span id="l83.206"> </span>
<a href="#l83.207"></a><span id="l83.207"> /*</span>
<a href="#l83.208"></a><span id="l83.208">  * same as ldap_ufn_search_ct, except without the ability to specify</span>
<a href="#l83.209"></a><span id="l83.209">  * ldapfilter.conf tags.</span>
<a href="#l83.210"></a><span id="l83.210">  */</span>
<a href="#l83.211"></a><span id="l83.211" class="difflineminus">-int LDAP_CALL ldap_ufn_search_c(LDAP *ld, char *ufn, char **attrs,</span>
<a href="#l83.212"></a><span id="l83.212" class="difflineminus">-                                int attrsonly, LDAPMessage **res,</span>
<a href="#l83.213"></a><span id="l83.213" class="difflineminus">-                                LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l83.214"></a><span id="l83.214" class="difflineminus">-                                void *cancelparm) {</span>
<a href="#l83.215"></a><span id="l83.215" class="difflineplus">+int LDAP_CALL ldap_ufn_search_c(LDAP* ld, char* ufn, char** attrs,</span>
<a href="#l83.216"></a><span id="l83.216" class="difflineplus">+                                int attrsonly, LDAPMessage** res,</span>
<a href="#l83.217"></a><span id="l83.217" class="difflineplus">+                                LDAP_CANCELPROC_CALLBACK* cancelproc,</span>
<a href="#l83.218"></a><span id="l83.218" class="difflineplus">+                                void* cancelparm) {</span>
<a href="#l83.219"></a><span id="l83.219">   return (ldap_ufn_search_ct(ld, ufn, attrs, attrsonly, res, cancelproc,</span>
<a href="#l83.220"></a><span id="l83.220">                              cancelparm, &quot;ufn first&quot;, &quot;ufn intermediate&quot;,</span>
<a href="#l83.221"></a><span id="l83.221">                              &quot;ufn last&quot;));</span>
<a href="#l83.222"></a><span id="l83.222"> }</span>
<a href="#l83.223"></a><span id="l83.223"> </span>
<a href="#l83.224"></a><span id="l83.224"> /*</span>
<a href="#l83.225"></a><span id="l83.225">  * same as ldap_ufn_search_c without the cancel function</span>
<a href="#l83.226"></a><span id="l83.226">  */</span>
<a href="#l83.227"></a><span id="l83.227" class="difflineminus">-int LDAP_CALL ldap_ufn_search_s(LDAP *ld, char *ufn, char **attrs,</span>
<a href="#l83.228"></a><span id="l83.228" class="difflineminus">-                                int attrsonly, LDAPMessage **res) {</span>
<a href="#l83.229"></a><span id="l83.229" class="difflineplus">+int LDAP_CALL ldap_ufn_search_s(LDAP* ld, char* ufn, char** attrs,</span>
<a href="#l83.230"></a><span id="l83.230" class="difflineplus">+                                int attrsonly, LDAPMessage** res) {</span>
<a href="#l83.231"></a><span id="l83.231">   struct timeval tv;</span>
<a href="#l83.232"></a><span id="l83.232"> </span>
<a href="#l83.233"></a><span id="l83.233">   tv.tv_sec = ld-&gt;ld_timelimit;</span>
<a href="#l83.234"></a><span id="l83.234"> </span>
<a href="#l83.235"></a><span id="l83.235">   return (ldap_ufn_search_ct(ld, ufn, attrs, attrsonly, res,</span>
<a href="#l83.236"></a><span id="l83.236">                              ld-&gt;ld_timelimit ? ldap_ufn_timeout : NULL,</span>
<a href="#l83.237"></a><span id="l83.237" class="difflineminus">-                             ld-&gt;ld_timelimit ? (void *)&amp;tv : NULL, &quot;ufn first&quot;,</span>
<a href="#l83.238"></a><span id="l83.238" class="difflineplus">+                             ld-&gt;ld_timelimit ? (void*)&amp;tv : NULL, &quot;ufn first&quot;,</span>
<a href="#l83.239"></a><span id="l83.239">                              &quot;ufn intermediate&quot;, &quot;ufn last&quot;));</span>
<a href="#l83.240"></a><span id="l83.240"> }</span>
<a href="#l83.241"></a><span id="l83.241"> </span>
<a href="#l83.242"></a><span id="l83.242"> /*</span>
<a href="#l83.243"></a><span id="l83.243">  * ldap_msg_merge - merge two ldap search result chains.  the more</span>
<a href="#l83.244"></a><span id="l83.244">  * serious of the two error result codes is kept.</span>
<a href="#l83.245"></a><span id="l83.245">  */</span>
<a href="#l83.246"></a><span id="l83.246"> </span>
<a href="#l83.247"></a><span id="l83.247" class="difflineminus">-static LDAPMessage *ldap_msg_merge(LDAP *ld, LDAPMessage *a, LDAPMessage *b) {</span>
<a href="#l83.248"></a><span id="l83.248" class="difflineplus">+static LDAPMessage* ldap_msg_merge(LDAP* ld, LDAPMessage* a, LDAPMessage* b) {</span>
<a href="#l83.249"></a><span id="l83.249">   LDAPMessage *end, *aprev, *aend, *bprev, *bend;</span>
<a href="#l83.250"></a><span id="l83.250"> </span>
<a href="#l83.251"></a><span id="l83.251">   if (a == NULL) return (b);</span>
<a href="#l83.252"></a><span id="l83.252"> </span>
<a href="#l83.253"></a><span id="l83.253">   if (b == NULL) return (a);</span>
<a href="#l83.254"></a><span id="l83.254"> </span>
<a href="#l83.255"></a><span id="l83.255">   /* find the ends of the a and b chains */</span>
<a href="#l83.256"></a><span id="l83.256">   aprev = NULL;</span>
<a href="#l83.257"></a><span id="l83.257" class="difflineat">@@ -412,23 +412,23 @@ static LDAPMessage *ldap_msg_merge(LDAP </span>
<a href="#l83.258"></a><span id="l83.258">     return (a);</span>
<a href="#l83.259"></a><span id="l83.259">   } else {</span>
<a href="#l83.260"></a><span id="l83.260">     bprev-&gt;lm_chain = end;</span>
<a href="#l83.261"></a><span id="l83.261">     aprev-&gt;lm_chain = b;</span>
<a href="#l83.262"></a><span id="l83.262">     return (a);</span>
<a href="#l83.263"></a><span id="l83.263">   }</span>
<a href="#l83.264"></a><span id="l83.264"> }</span>
<a href="#l83.265"></a><span id="l83.265"> </span>
<a href="#l83.266"></a><span id="l83.266" class="difflineminus">-static LDAPMessage *ldap_ufn_expand(LDAP *ld,</span>
<a href="#l83.267"></a><span id="l83.267" class="difflineminus">-                                    LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l83.268"></a><span id="l83.268" class="difflineminus">-                                    void *cancelparm, char **dns, char *filter,</span>
<a href="#l83.269"></a><span id="l83.269" class="difflineminus">-                                    int scope, char **attrs, int aonly,</span>
<a href="#l83.270"></a><span id="l83.270" class="difflineminus">-                                    int *err) {</span>
<a href="#l83.271"></a><span id="l83.271" class="difflineplus">+static LDAPMessage* ldap_ufn_expand(LDAP* ld,</span>
<a href="#l83.272"></a><span id="l83.272" class="difflineplus">+                                    LDAP_CANCELPROC_CALLBACK* cancelproc,</span>
<a href="#l83.273"></a><span id="l83.273" class="difflineplus">+                                    void* cancelparm, char** dns, char* filter,</span>
<a href="#l83.274"></a><span id="l83.274" class="difflineplus">+                                    int scope, char** attrs, int aonly,</span>
<a href="#l83.275"></a><span id="l83.275" class="difflineplus">+                                    int* err) {</span>
<a href="#l83.276"></a><span id="l83.276">   LDAPMessage *tmpcand, *tmpres;</span>
<a href="#l83.277"></a><span id="l83.277" class="difflineminus">-  char *dn;</span>
<a href="#l83.278"></a><span id="l83.278" class="difflineplus">+  char* dn;</span>
<a href="#l83.279"></a><span id="l83.279">   int i, msgid;</span>
<a href="#l83.280"></a><span id="l83.280">   struct timeval tv;</span>
<a href="#l83.281"></a><span id="l83.281"> </span>
<a href="#l83.282"></a><span id="l83.282">   /* search for this component below the current candidates */</span>
<a href="#l83.283"></a><span id="l83.283">   tmpcand = NULL;</span>
<a href="#l83.284"></a><span id="l83.284">   i = 0;</span>
<a href="#l83.285"></a><span id="l83.285">   do {</span>
<a href="#l83.286"></a><span id="l83.286">     if (dns != NULL)</span>
<a href="#l83.287"></a><span id="l83.287" class="difflineat">@@ -485,32 +485,32 @@ static LDAPMessage *ldap_ufn_expand(LDAP</span>
<a href="#l83.288"></a><span id="l83.288">     return (NULL);</span>
<a href="#l83.289"></a><span id="l83.289">   }</span>
<a href="#l83.290"></a><span id="l83.290"> }</span>
<a href="#l83.291"></a><span id="l83.291"> </span>
<a href="#l83.292"></a><span id="l83.292"> /*</span>
<a href="#l83.293"></a><span id="l83.293">  * ldap_ufn_setfilter - set the filter config file used in ufn searching</span>
<a href="#l83.294"></a><span id="l83.294">  */</span>
<a href="#l83.295"></a><span id="l83.295"> </span>
<a href="#l83.296"></a><span id="l83.296" class="difflineminus">-LDAPFiltDesc *LDAP_CALL ldap_ufn_setfilter(LDAP *ld, char *fname) {</span>
<a href="#l83.297"></a><span id="l83.297" class="difflineplus">+LDAPFiltDesc* LDAP_CALL ldap_ufn_setfilter(LDAP* ld, char* fname) {</span>
<a href="#l83.298"></a><span id="l83.298">   if (ld-&gt;ld_filtd != NULL) ldap_getfilter_free(ld-&gt;ld_filtd);</span>
<a href="#l83.299"></a><span id="l83.299"> </span>
<a href="#l83.300"></a><span id="l83.300">   return (ld-&gt;ld_filtd = ldap_init_getfilter(fname));</span>
<a href="#l83.301"></a><span id="l83.301"> }</span>
<a href="#l83.302"></a><span id="l83.302"> </span>
<a href="#l83.303"></a><span id="l83.303" class="difflineminus">-void LDAP_CALL ldap_ufn_setprefix(LDAP *ld, char *prefix) {</span>
<a href="#l83.304"></a><span id="l83.304" class="difflineplus">+void LDAP_CALL ldap_ufn_setprefix(LDAP* ld, char* prefix) {</span>
<a href="#l83.305"></a><span id="l83.305">   if (ld-&gt;ld_ufnprefix != NULL) NSLDAPI_FREE(ld-&gt;ld_ufnprefix);</span>
<a href="#l83.306"></a><span id="l83.306"> </span>
<a href="#l83.307"></a><span id="l83.307">   ld-&gt;ld_ufnprefix = nsldapi_strdup(prefix);</span>
<a href="#l83.308"></a><span id="l83.308"> }</span>
<a href="#l83.309"></a><span id="l83.309"> </span>
<a href="#l83.310"></a><span id="l83.310" class="difflineminus">-int LDAP_C ldap_ufn_timeout(void *tvparam) {</span>
<a href="#l83.311"></a><span id="l83.311" class="difflineminus">-  struct timeval *tv;</span>
<a href="#l83.312"></a><span id="l83.312" class="difflineplus">+int LDAP_C ldap_ufn_timeout(void* tvparam) {</span>
<a href="#l83.313"></a><span id="l83.313" class="difflineplus">+  struct timeval* tv;</span>
<a href="#l83.314"></a><span id="l83.314"> </span>
<a href="#l83.315"></a><span id="l83.315" class="difflineminus">-  tv = (struct timeval *)tvparam;</span>
<a href="#l83.316"></a><span id="l83.316" class="difflineplus">+  tv = (struct timeval*)tvparam;</span>
<a href="#l83.317"></a><span id="l83.317"> </span>
<a href="#l83.318"></a><span id="l83.318">   if (tv-&gt;tv_sec != 0) {</span>
<a href="#l83.319"></a><span id="l83.319">     tv-&gt;tv_usec = tv-&gt;tv_sec * 1000000; /* sec =&gt; micro sec */</span>
<a href="#l83.320"></a><span id="l83.320">     tv-&gt;tv_sec = 0;</span>
<a href="#l83.321"></a><span id="l83.321">   }</span>
<a href="#l83.322"></a><span id="l83.322">   tv-&gt;tv_usec -= 100000; /* 1/10 of a second */</span>
<a href="#l83.323"></a><span id="l83.323"> </span>
<a href="#l83.324"></a><span id="l83.324">   return (tv-&gt;tv_usec &lt;= 0 ? 1 : 0);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l84.1"></a><span id="l84.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/unbind.c</span>
<a href="#l84.2"></a><span id="l84.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/unbind.c</span>
<a href="#l84.3"></a><span id="l84.3" class="difflineat">@@ -46,36 +46,36 @@</span>
<a href="#l84.4"></a><span id="l84.4"> #if 0</span>
<a href="#l84.5"></a><span id="l84.5"> #  ifndef lint</span>
<a href="#l84.6"></a><span id="l84.6"> static char copyright[] = &quot;@(#) Copyright (c) 1990 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l84.7"></a><span id="l84.7"> #  endif</span>
<a href="#l84.8"></a><span id="l84.8"> #endif</span>
<a href="#l84.9"></a><span id="l84.9"> </span>
<a href="#l84.10"></a><span id="l84.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l84.11"></a><span id="l84.11"> </span>
<a href="#l84.12"></a><span id="l84.12" class="difflineminus">-int LDAP_CALL ldap_unbind(LDAP *ld) {</span>
<a href="#l84.13"></a><span id="l84.13" class="difflineplus">+int LDAP_CALL ldap_unbind(LDAP* ld) {</span>
<a href="#l84.14"></a><span id="l84.14">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_unbind\n&quot;, 0, 0, 0);</span>
<a href="#l84.15"></a><span id="l84.15"> </span>
<a href="#l84.16"></a><span id="l84.16">   return (ldap_ld_free(ld, NULL, NULL, 1));</span>
<a href="#l84.17"></a><span id="l84.17"> }</span>
<a href="#l84.18"></a><span id="l84.18"> </span>
<a href="#l84.19"></a><span id="l84.19" class="difflineminus">-int LDAP_CALL ldap_unbind_s(LDAP *ld) {</span>
<a href="#l84.20"></a><span id="l84.20" class="difflineplus">+int LDAP_CALL ldap_unbind_s(LDAP* ld) {</span>
<a href="#l84.21"></a><span id="l84.21">   return (ldap_ld_free(ld, NULL, NULL, 1));</span>
<a href="#l84.22"></a><span id="l84.22"> }</span>
<a href="#l84.23"></a><span id="l84.23"> </span>
<a href="#l84.24"></a><span id="l84.24" class="difflineminus">-int LDAP_CALL ldap_unbind_ext(LDAP *ld, LDAPControl **serverctrls,</span>
<a href="#l84.25"></a><span id="l84.25" class="difflineminus">-                              LDAPControl **clientctrls) {</span>
<a href="#l84.26"></a><span id="l84.26" class="difflineplus">+int LDAP_CALL ldap_unbind_ext(LDAP* ld, LDAPControl** serverctrls,</span>
<a href="#l84.27"></a><span id="l84.27" class="difflineplus">+                              LDAPControl** clientctrls) {</span>
<a href="#l84.28"></a><span id="l84.28">   return (ldap_ld_free(ld, serverctrls, clientctrls, 1));</span>
<a href="#l84.29"></a><span id="l84.29"> }</span>
<a href="#l84.30"></a><span id="l84.30"> </span>
<a href="#l84.31"></a><span id="l84.31"> /*</span>
<a href="#l84.32"></a><span id="l84.32">  * Dispose of the LDAP session ld, including all associated connections</span>
<a href="#l84.33"></a><span id="l84.33">  * and resources.  If close is non-zero, an unbind() request is sent as well.</span>
<a href="#l84.34"></a><span id="l84.34">  */</span>
<a href="#l84.35"></a><span id="l84.35" class="difflineminus">-int ldap_ld_free(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l84.36"></a><span id="l84.36" class="difflineplus">+int ldap_ld_free(LDAP* ld, LDAPControl** serverctrls, LDAPControl** clientctrls,</span>
<a href="#l84.37"></a><span id="l84.37">                  int close) {</span>
<a href="#l84.38"></a><span id="l84.38">   LDAPMessage *lm, *next;</span>
<a href="#l84.39"></a><span id="l84.39">   int err = LDAP_SUCCESS;</span>
<a href="#l84.40"></a><span id="l84.40">   LDAPRequest *lr, *nextlr;</span>
<a href="#l84.41"></a><span id="l84.41"> </span>
<a href="#l84.42"></a><span id="l84.42">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l84.43"></a><span id="l84.43">     return (LDAP_PARAM_ERROR);</span>
<a href="#l84.44"></a><span id="l84.44">   }</span>
<a href="#l84.45"></a><span id="l84.45" class="difflineat">@@ -156,24 +156,24 @@ int ldap_ld_free(LDAP *ld, LDAPControl *</span>
<a href="#l84.46"></a><span id="l84.46">   if (ld-&gt;ld_memcache != NULL) {</span>
<a href="#l84.47"></a><span id="l84.47">     ldap_memcache_set(ld, NULL);</span>
<a href="#l84.48"></a><span id="l84.48">   }</span>
<a href="#l84.49"></a><span id="l84.49"> </span>
<a href="#l84.50"></a><span id="l84.50">   /* free all mutexes we have allocated */</span>
<a href="#l84.51"></a><span id="l84.51">   nsldapi_mutex_free_all(ld);</span>
<a href="#l84.52"></a><span id="l84.52">   NSLDAPI_FREE(ld-&gt;ld_mutex);</span>
<a href="#l84.53"></a><span id="l84.53"> </span>
<a href="#l84.54"></a><span id="l84.54" class="difflineminus">-  NSLDAPI_FREE((char *)ld);</span>
<a href="#l84.55"></a><span id="l84.55" class="difflineplus">+  NSLDAPI_FREE((char*)ld);</span>
<a href="#l84.56"></a><span id="l84.56"> </span>
<a href="#l84.57"></a><span id="l84.57">   return (err);</span>
<a href="#l84.58"></a><span id="l84.58"> }</span>
<a href="#l84.59"></a><span id="l84.59"> </span>
<a href="#l84.60"></a><span id="l84.60" class="difflineminus">-int nsldapi_send_unbind(LDAP *ld, Sockbuf *sb, LDAPControl **serverctrls,</span>
<a href="#l84.61"></a><span id="l84.61" class="difflineminus">-                        LDAPControl **clientctrls) {</span>
<a href="#l84.62"></a><span id="l84.62" class="difflineminus">-  BerElement *ber;</span>
<a href="#l84.63"></a><span id="l84.63" class="difflineplus">+int nsldapi_send_unbind(LDAP* ld, Sockbuf* sb, LDAPControl** serverctrls,</span>
<a href="#l84.64"></a><span id="l84.64" class="difflineplus">+                        LDAPControl** clientctrls) {</span>
<a href="#l84.65"></a><span id="l84.65" class="difflineplus">+  BerElement* ber;</span>
<a href="#l84.66"></a><span id="l84.66">   int err, msgid;</span>
<a href="#l84.67"></a><span id="l84.67"> </span>
<a href="#l84.68"></a><span id="l84.68">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_send_unbind\n&quot;, 0, 0, 0);</span>
<a href="#l84.69"></a><span id="l84.69"> </span>
<a href="#l84.70"></a><span id="l84.70">   /* create a message to send */</span>
<a href="#l84.71"></a><span id="l84.71">   if ((err = nsldapi_alloc_ber_with_options(ld, &amp;ber)) != LDAP_SUCCESS) {</span>
<a href="#l84.72"></a><span id="l84.72">     return (err);</span>
<a href="#l84.73"></a><span id="l84.73">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l85.1"></a><span id="l85.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/unescape.c</span>
<a href="#l85.2"></a><span id="l85.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/unescape.c</span>
<a href="#l85.3"></a><span id="l85.3" class="difflineat">@@ -39,22 +39,22 @@</span>
<a href="#l85.4"></a><span id="l85.4">  *  LIBLDAP unescape.c -- LDAP URL un-escape routines</span>
<a href="#l85.5"></a><span id="l85.5">  *  We also tolerate URLs that look like: &lt;ldapurl&gt; and &lt;URL:ldapurl&gt;</span>
<a href="#l85.6"></a><span id="l85.6">  */</span>
<a href="#l85.7"></a><span id="l85.7"> </span>
<a href="#l85.8"></a><span id="l85.8"> #include &quot;ldap-int.h&quot;</span>
<a href="#l85.9"></a><span id="l85.9"> </span>
<a href="#l85.10"></a><span id="l85.10"> static int unhex(char c);</span>
<a href="#l85.11"></a><span id="l85.11"> </span>
<a href="#l85.12"></a><span id="l85.12" class="difflineminus">-void nsldapi_hex_unescape(char *s) {</span>
<a href="#l85.13"></a><span id="l85.13" class="difflineplus">+void nsldapi_hex_unescape(char* s) {</span>
<a href="#l85.14"></a><span id="l85.14">   /*</span>
<a href="#l85.15"></a><span id="l85.15">    * Remove URL hex escapes from s... done in place.  The basic concept for</span>
<a href="#l85.16"></a><span id="l85.16">    * this routine is borrowed from the WWW library HTUnEscape() routine.</span>
<a href="#l85.17"></a><span id="l85.17">    */</span>
<a href="#l85.18"></a><span id="l85.18" class="difflineminus">-  char *p;</span>
<a href="#l85.19"></a><span id="l85.19" class="difflineplus">+  char* p;</span>
<a href="#l85.20"></a><span id="l85.20"> </span>
<a href="#l85.21"></a><span id="l85.21">   for (p = s; *s != '\0'; ++s) {</span>
<a href="#l85.22"></a><span id="l85.22">     if (*s == '%') {</span>
<a href="#l85.23"></a><span id="l85.23">       if (*++s == '\0') {</span>
<a href="#l85.24"></a><span id="l85.24">         break;</span>
<a href="#l85.25"></a><span id="l85.25">       }</span>
<a href="#l85.26"></a><span id="l85.26">       *p = unhex(*s) &lt;&lt; 4;</span>
<a href="#l85.27"></a><span id="l85.27">       if (*++s == '\0') {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l86.1"></a><span id="l86.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/url.c</span>
<a href="#l86.2"></a><span id="l86.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/url.c</span>
<a href="#l86.3"></a><span id="l86.3" class="difflineat">@@ -65,25 +65,25 @@</span>
<a href="#l86.4"></a><span id="l86.4"> #if 0</span>
<a href="#l86.5"></a><span id="l86.5"> #  ifndef lint</span>
<a href="#l86.6"></a><span id="l86.6"> static char copyright[] = &quot;@(#) Copyright (c) 1996 Regents of the University of Michigan.\nAll rights reserved.\n&quot;;</span>
<a href="#l86.7"></a><span id="l86.7"> #  endif</span>
<a href="#l86.8"></a><span id="l86.8"> #endif</span>
<a href="#l86.9"></a><span id="l86.9"> </span>
<a href="#l86.10"></a><span id="l86.10"> #include &quot;ldap-int.h&quot;</span>
<a href="#l86.11"></a><span id="l86.11"> </span>
<a href="#l86.12"></a><span id="l86.12" class="difflineminus">-static int skip_url_prefix(const char **urlp, int *enclosedp, int *securep);</span>
<a href="#l86.13"></a><span id="l86.13" class="difflineplus">+static int skip_url_prefix(const char** urlp, int* enclosedp, int* securep);</span>
<a href="#l86.14"></a><span id="l86.14"> </span>
<a href="#l86.15"></a><span id="l86.15" class="difflineminus">-int LDAP_CALL ldap_is_ldap_url(const char *url) {</span>
<a href="#l86.16"></a><span id="l86.16" class="difflineplus">+int LDAP_CALL ldap_is_ldap_url(const char* url) {</span>
<a href="#l86.17"></a><span id="l86.17">   int enclosed, secure;</span>
<a href="#l86.18"></a><span id="l86.18"> </span>
<a href="#l86.19"></a><span id="l86.19">   return (url != NULL &amp;&amp; skip_url_prefix(&amp;url, &amp;enclosed, &amp;secure));</span>
<a href="#l86.20"></a><span id="l86.20"> }</span>
<a href="#l86.21"></a><span id="l86.21"> </span>
<a href="#l86.22"></a><span id="l86.22" class="difflineminus">-static int skip_url_prefix(const char **urlp, int *enclosedp, int *securep) {</span>
<a href="#l86.23"></a><span id="l86.23" class="difflineplus">+static int skip_url_prefix(const char** urlp, int* enclosedp, int* securep) {</span>
<a href="#l86.24"></a><span id="l86.24">   /*</span>
<a href="#l86.25"></a><span id="l86.25">    * return non-zero if this looks like a LDAP URL; zero if not</span>
<a href="#l86.26"></a><span id="l86.26">    * if non-zero returned, *urlp will be moved past &quot;ldap://&quot; part of URL</span>
<a href="#l86.27"></a><span id="l86.27">    * The data that *urlp points to is not changed by this function.</span>
<a href="#l86.28"></a><span id="l86.28">    */</span>
<a href="#l86.29"></a><span id="l86.29">   if (*urlp == NULL) {</span>
<a href="#l86.30"></a><span id="l86.30">     return (0);</span>
<a href="#l86.31"></a><span id="l86.31">   }</span>
<a href="#l86.32"></a><span id="l86.32" class="difflineat">@@ -118,22 +118,22 @@ static int skip_url_prefix(const char **</span>
<a href="#l86.33"></a><span id="l86.33">     *urlp += LDAPS_URL_PREFIX_LEN;</span>
<a href="#l86.34"></a><span id="l86.34">     *securep = 1;</span>
<a href="#l86.35"></a><span id="l86.35">     return (1);</span>
<a href="#l86.36"></a><span id="l86.36">   }</span>
<a href="#l86.37"></a><span id="l86.37"> </span>
<a href="#l86.38"></a><span id="l86.38">   return (0); /* not an LDAP URL */</span>
<a href="#l86.39"></a><span id="l86.39"> }</span>
<a href="#l86.40"></a><span id="l86.40"> </span>
<a href="#l86.41"></a><span id="l86.41" class="difflineminus">-int LDAP_CALL ldap_url_parse_no_defaults(const char *url, LDAPURLDesc **ludpp,</span>
<a href="#l86.42"></a><span id="l86.42" class="difflineplus">+int LDAP_CALL ldap_url_parse_no_defaults(const char* url, LDAPURLDesc** ludpp,</span>
<a href="#l86.43"></a><span id="l86.43">                                          int dn_required) {</span>
<a href="#l86.44"></a><span id="l86.44">   return (nsldapi_url_parse(url, ludpp, dn_required));</span>
<a href="#l86.45"></a><span id="l86.45"> }</span>
<a href="#l86.46"></a><span id="l86.46"> </span>
<a href="#l86.47"></a><span id="l86.47" class="difflineminus">-int LDAP_CALL ldap_url_parse(const char *url, LDAPURLDesc **ludpp) {</span>
<a href="#l86.48"></a><span id="l86.48" class="difflineplus">+int LDAP_CALL ldap_url_parse(const char* url, LDAPURLDesc** ludpp) {</span>
<a href="#l86.49"></a><span id="l86.49">   /*</span>
<a href="#l86.50"></a><span id="l86.50">    *  Pick apart the pieces of an LDAP URL.</span>
<a href="#l86.51"></a><span id="l86.51">    */</span>
<a href="#l86.52"></a><span id="l86.52">   int rc;</span>
<a href="#l86.53"></a><span id="l86.53"> </span>
<a href="#l86.54"></a><span id="l86.54">   if ((rc = nsldapi_url_parse(url, ludpp, 1)) == 0) {</span>
<a href="#l86.55"></a><span id="l86.55">     if ((*ludpp)-&gt;lud_scope == -1) {</span>
<a href="#l86.56"></a><span id="l86.56">       (*ludpp)-&gt;lud_scope = LDAP_SCOPE_BASE;</span>
<a href="#l86.57"></a><span id="l86.57" class="difflineat">@@ -158,35 +158,35 @@ int LDAP_CALL ldap_url_parse(const char </span>
<a href="#l86.58"></a><span id="l86.58">  *   2) no defaults are set for lud_scope and lud_filter (they are set to -1</span>
<a href="#l86.59"></a><span id="l86.59">  *      and NULL respectively if no SCOPE or FILTER are present in the URL).</span>
<a href="#l86.60"></a><span id="l86.60">  *   3) when there is a zero-length DN in a URL we do not set lud_dn to NULL.</span>
<a href="#l86.61"></a><span id="l86.61">  *</span>
<a href="#l86.62"></a><span id="l86.62">  * note that LDAPv3 URL extensions are ignored unless they are marked</span>
<a href="#l86.63"></a><span id="l86.63">  * critical, in which case an LDAP_URL_UNRECOGNIZED_CRITICAL_EXTENSION error</span>
<a href="#l86.64"></a><span id="l86.64">  * is returned.</span>
<a href="#l86.65"></a><span id="l86.65">  */</span>
<a href="#l86.66"></a><span id="l86.66" class="difflineminus">-int nsldapi_url_parse(const char *url, LDAPURLDesc **ludpp, int dn_required) {</span>
<a href="#l86.67"></a><span id="l86.67" class="difflineminus">-  LDAPURLDesc *ludp;</span>
<a href="#l86.68"></a><span id="l86.68" class="difflineplus">+int nsldapi_url_parse(const char* url, LDAPURLDesc** ludpp, int dn_required) {</span>
<a href="#l86.69"></a><span id="l86.69" class="difflineplus">+  LDAPURLDesc* ludp;</span>
<a href="#l86.70"></a><span id="l86.70">   char *urlcopy, *attrs, *scope, *extensions = NULL, *p, *q;</span>
<a href="#l86.71"></a><span id="l86.71">   int enclosed, secure, i, nattrs, at_start;</span>
<a href="#l86.72"></a><span id="l86.72"> </span>
<a href="#l86.73"></a><span id="l86.73">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_url_parse(%s)\n&quot;, url, 0, 0);</span>
<a href="#l86.74"></a><span id="l86.74"> </span>
<a href="#l86.75"></a><span id="l86.75">   if (url == NULL || ludpp == NULL) {</span>
<a href="#l86.76"></a><span id="l86.76">     return (LDAP_URL_ERR_PARAM);</span>
<a href="#l86.77"></a><span id="l86.77">   }</span>
<a href="#l86.78"></a><span id="l86.78"> </span>
<a href="#l86.79"></a><span id="l86.79">   *ludpp = NULL; /* pessimistic */</span>
<a href="#l86.80"></a><span id="l86.80"> </span>
<a href="#l86.81"></a><span id="l86.81">   if (!skip_url_prefix(&amp;url, &amp;enclosed, &amp;secure)) {</span>
<a href="#l86.82"></a><span id="l86.82">     return (LDAP_URL_ERR_NOTLDAP);</span>
<a href="#l86.83"></a><span id="l86.83">   }</span>
<a href="#l86.84"></a><span id="l86.84"> </span>
<a href="#l86.85"></a><span id="l86.85">   /* allocate return struct */</span>
<a href="#l86.86"></a><span id="l86.86" class="difflineminus">-  if ((ludp = (LDAPURLDesc *)NSLDAPI_CALLOC(1, sizeof(LDAPURLDesc))) ==</span>
<a href="#l86.87"></a><span id="l86.87" class="difflineplus">+  if ((ludp = (LDAPURLDesc*)NSLDAPI_CALLOC(1, sizeof(LDAPURLDesc))) ==</span>
<a href="#l86.88"></a><span id="l86.88">       NULLLDAPURLDESC) {</span>
<a href="#l86.89"></a><span id="l86.89">     return (LDAP_URL_ERR_MEM);</span>
<a href="#l86.90"></a><span id="l86.90">   }</span>
<a href="#l86.91"></a><span id="l86.91"> </span>
<a href="#l86.92"></a><span id="l86.92">   if (secure) {</span>
<a href="#l86.93"></a><span id="l86.93">     ludp-&gt;lud_options |= LDAP_URL_OPT_SECURE;</span>
<a href="#l86.94"></a><span id="l86.94">   }</span>
<a href="#l86.95"></a><span id="l86.95"> </span>
<a href="#l86.96"></a><span id="l86.96" class="difflineat">@@ -311,18 +311,18 @@ int nsldapi_url_parse(const char *url, L</span>
<a href="#l86.97"></a><span id="l86.97">   if (attrs != NULL &amp;&amp; *attrs != '\0') {</span>
<a href="#l86.98"></a><span id="l86.98">     nsldapi_hex_unescape(attrs);</span>
<a href="#l86.99"></a><span id="l86.99">     for (nattrs = 1, p = attrs; *p != '\0'; ++p) {</span>
<a href="#l86.100"></a><span id="l86.100">       if (*p == ',') {</span>
<a href="#l86.101"></a><span id="l86.101">         ++nattrs;</span>
<a href="#l86.102"></a><span id="l86.102">       }</span>
<a href="#l86.103"></a><span id="l86.103">     }</span>
<a href="#l86.104"></a><span id="l86.104"> </span>
<a href="#l86.105"></a><span id="l86.105" class="difflineminus">-    if ((ludp-&gt;lud_attrs =</span>
<a href="#l86.106"></a><span id="l86.106" class="difflineminus">-             (char **)NSLDAPI_CALLOC(nattrs + 1, sizeof(char *))) == NULL) {</span>
<a href="#l86.107"></a><span id="l86.107" class="difflineplus">+    if ((ludp-&gt;lud_attrs = (char**)NSLDAPI_CALLOC(nattrs + 1, sizeof(char*))) ==</span>
<a href="#l86.108"></a><span id="l86.108" class="difflineplus">+        NULL) {</span>
<a href="#l86.109"></a><span id="l86.109">       ldap_free_urldesc(ludp);</span>
<a href="#l86.110"></a><span id="l86.110">       return (LDAP_URL_ERR_MEM);</span>
<a href="#l86.111"></a><span id="l86.111">     }</span>
<a href="#l86.112"></a><span id="l86.112"> </span>
<a href="#l86.113"></a><span id="l86.113">     for (i = 0, p = attrs; i &lt; nattrs; ++i) {</span>
<a href="#l86.114"></a><span id="l86.114">       ludp-&gt;lud_attrs[i] = p;</span>
<a href="#l86.115"></a><span id="l86.115">       if ((p = strchr(p, ',')) != NULL) {</span>
<a href="#l86.116"></a><span id="l86.116">         *p++ = '\0';</span>
<a href="#l86.117"></a><span id="l86.117" class="difflineat">@@ -348,34 +348,34 @@ int nsldapi_url_parse(const char *url, L</span>
<a href="#l86.118"></a><span id="l86.118">     }</span>
<a href="#l86.119"></a><span id="l86.119">   }</span>
<a href="#l86.120"></a><span id="l86.120"> </span>
<a href="#l86.121"></a><span id="l86.121">   *ludpp = ludp;</span>
<a href="#l86.122"></a><span id="l86.122"> </span>
<a href="#l86.123"></a><span id="l86.123">   return (0);</span>
<a href="#l86.124"></a><span id="l86.124"> }</span>
<a href="#l86.125"></a><span id="l86.125"> </span>
<a href="#l86.126"></a><span id="l86.126" class="difflineminus">-void LDAP_CALL ldap_free_urldesc(LDAPURLDesc *ludp) {</span>
<a href="#l86.127"></a><span id="l86.127" class="difflineplus">+void LDAP_CALL ldap_free_urldesc(LDAPURLDesc* ludp) {</span>
<a href="#l86.128"></a><span id="l86.128">   if (ludp != NULLLDAPURLDESC) {</span>
<a href="#l86.129"></a><span id="l86.129">     if (ludp-&gt;lud_string != NULL) {</span>
<a href="#l86.130"></a><span id="l86.130">       NSLDAPI_FREE(ludp-&gt;lud_string);</span>
<a href="#l86.131"></a><span id="l86.131">     }</span>
<a href="#l86.132"></a><span id="l86.132">     if (ludp-&gt;lud_attrs != NULL) {</span>
<a href="#l86.133"></a><span id="l86.133">       NSLDAPI_FREE(ludp-&gt;lud_attrs);</span>
<a href="#l86.134"></a><span id="l86.134">     }</span>
<a href="#l86.135"></a><span id="l86.135">     NSLDAPI_FREE(ludp);</span>
<a href="#l86.136"></a><span id="l86.136">   }</span>
<a href="#l86.137"></a><span id="l86.137"> }</span>
<a href="#l86.138"></a><span id="l86.138"> </span>
<a href="#l86.139"></a><span id="l86.139" class="difflineminus">-int LDAP_CALL ldap_url_search(LDAP *ld, const char *url, int attrsonly) {</span>
<a href="#l86.140"></a><span id="l86.140" class="difflineplus">+int LDAP_CALL ldap_url_search(LDAP* ld, const char* url, int attrsonly) {</span>
<a href="#l86.141"></a><span id="l86.141">   int err, msgid;</span>
<a href="#l86.142"></a><span id="l86.142" class="difflineminus">-  LDAPURLDesc *ludp;</span>
<a href="#l86.143"></a><span id="l86.143" class="difflineminus">-  BerElement *ber;</span>
<a href="#l86.144"></a><span id="l86.144" class="difflineminus">-  LDAPServer *srv;</span>
<a href="#l86.145"></a><span id="l86.145" class="difflineminus">-  char *host;</span>
<a href="#l86.146"></a><span id="l86.146" class="difflineplus">+  LDAPURLDesc* ludp;</span>
<a href="#l86.147"></a><span id="l86.147" class="difflineplus">+  BerElement* ber;</span>
<a href="#l86.148"></a><span id="l86.148" class="difflineplus">+  LDAPServer* srv;</span>
<a href="#l86.149"></a><span id="l86.149" class="difflineplus">+  char* host;</span>
<a href="#l86.150"></a><span id="l86.150"> </span>
<a href="#l86.151"></a><span id="l86.151">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l86.152"></a><span id="l86.152">     return (-1); /* punt */</span>
<a href="#l86.153"></a><span id="l86.153">   }</span>
<a href="#l86.154"></a><span id="l86.154"> </span>
<a href="#l86.155"></a><span id="l86.155">   if (ldap_url_parse(url, &amp;ludp) != 0) {</span>
<a href="#l86.156"></a><span id="l86.156">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l86.157"></a><span id="l86.157">     return (-1);</span>
<a href="#l86.158"></a><span id="l86.158" class="difflineat">@@ -394,17 +394,17 @@ int LDAP_CALL ldap_url_search(LDAP *ld, </span>
<a href="#l86.159"></a><span id="l86.159">   err = 0;</span>
<a href="#l86.160"></a><span id="l86.160"> </span>
<a href="#l86.161"></a><span id="l86.161">   if (ludp-&gt;lud_host == NULL) {</span>
<a href="#l86.162"></a><span id="l86.162">     host = ld-&gt;ld_defhost;</span>
<a href="#l86.163"></a><span id="l86.163">   } else {</span>
<a href="#l86.164"></a><span id="l86.164">     host = ludp-&gt;lud_host;</span>
<a href="#l86.165"></a><span id="l86.165">   }</span>
<a href="#l86.166"></a><span id="l86.166"> </span>
<a href="#l86.167"></a><span id="l86.167" class="difflineminus">-  if ((srv = (LDAPServer *)NSLDAPI_CALLOC(1, sizeof(LDAPServer))) == NULL ||</span>
<a href="#l86.168"></a><span id="l86.168" class="difflineplus">+  if ((srv = (LDAPServer*)NSLDAPI_CALLOC(1, sizeof(LDAPServer))) == NULL ||</span>
<a href="#l86.169"></a><span id="l86.169">       (host != NULL &amp;&amp; (srv-&gt;lsrv_host = nsldapi_strdup(host)) == NULL)) {</span>
<a href="#l86.170"></a><span id="l86.170">     if (srv != NULL) {</span>
<a href="#l86.171"></a><span id="l86.171">       NSLDAPI_FREE(srv);</span>
<a href="#l86.172"></a><span id="l86.172">     }</span>
<a href="#l86.173"></a><span id="l86.173">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l86.174"></a><span id="l86.174">     err = -1;</span>
<a href="#l86.175"></a><span id="l86.175">   } else {</span>
<a href="#l86.176"></a><span id="l86.176">     if (ludp-&gt;lud_port != 0) {</span>
<a href="#l86.177"></a><span id="l86.177" class="difflineat">@@ -431,18 +431,18 @@ int LDAP_CALL ldap_url_search(LDAP *ld, </span>
<a href="#l86.178"></a><span id="l86.178">   } else {</span>
<a href="#l86.179"></a><span id="l86.179">     err = nsldapi_send_server_request(ld, ber, msgid, NULL, srv, NULL, NULL, 1);</span>
<a href="#l86.180"></a><span id="l86.180">   }</span>
<a href="#l86.181"></a><span id="l86.181"> </span>
<a href="#l86.182"></a><span id="l86.182">   ldap_free_urldesc(ludp);</span>
<a href="#l86.183"></a><span id="l86.183">   return (err);</span>
<a href="#l86.184"></a><span id="l86.184"> }</span>
<a href="#l86.185"></a><span id="l86.185"> </span>
<a href="#l86.186"></a><span id="l86.186" class="difflineminus">-int LDAP_CALL ldap_url_search_st(LDAP *ld, const char *url, int attrsonly,</span>
<a href="#l86.187"></a><span id="l86.187" class="difflineminus">-                                 struct timeval *timeout, LDAPMessage **res) {</span>
<a href="#l86.188"></a><span id="l86.188" class="difflineplus">+int LDAP_CALL ldap_url_search_st(LDAP* ld, const char* url, int attrsonly,</span>
<a href="#l86.189"></a><span id="l86.189" class="difflineplus">+                                 struct timeval* timeout, LDAPMessage** res) {</span>
<a href="#l86.190"></a><span id="l86.190">   int msgid;</span>
<a href="#l86.191"></a><span id="l86.191"> </span>
<a href="#l86.192"></a><span id="l86.192">   /*</span>
<a href="#l86.193"></a><span id="l86.193">    * It is an error to pass in a zero'd timeval.</span>
<a href="#l86.194"></a><span id="l86.194">    */</span>
<a href="#l86.195"></a><span id="l86.195">   if (timeout != NULL &amp;&amp; timeout-&gt;tv_sec == 0 &amp;&amp; timeout-&gt;tv_usec == 0) {</span>
<a href="#l86.196"></a><span id="l86.196">     if (ld != NULL) {</span>
<a href="#l86.197"></a><span id="l86.197">       LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l86.198"></a><span id="l86.198" class="difflineat">@@ -465,22 +465,22 @@ int LDAP_CALL ldap_url_search_st(LDAP *l</span>
<a href="#l86.199"></a><span id="l86.199">     (void)ldap_abandon(ld, msgid);</span>
<a href="#l86.200"></a><span id="l86.200">     LDAP_SET_LDERRNO(ld, LDAP_TIMEOUT, NULL, NULL);</span>
<a href="#l86.201"></a><span id="l86.201">     return (LDAP_TIMEOUT);</span>
<a href="#l86.202"></a><span id="l86.202">   }</span>
<a href="#l86.203"></a><span id="l86.203"> </span>
<a href="#l86.204"></a><span id="l86.204">   return (ldap_result2error(ld, *res, 0));</span>
<a href="#l86.205"></a><span id="l86.205"> }</span>
<a href="#l86.206"></a><span id="l86.206"> </span>
<a href="#l86.207"></a><span id="l86.207" class="difflineminus">-int LDAP_CALL ldap_url_search_s(LDAP *ld, const char *url, int attrsonly,</span>
<a href="#l86.208"></a><span id="l86.208" class="difflineminus">-                                LDAPMessage **res) {</span>
<a href="#l86.209"></a><span id="l86.209" class="difflineplus">+int LDAP_CALL ldap_url_search_s(LDAP* ld, const char* url, int attrsonly,</span>
<a href="#l86.210"></a><span id="l86.210" class="difflineplus">+                                LDAPMessage** res) {</span>
<a href="#l86.211"></a><span id="l86.211">   int msgid;</span>
<a href="#l86.212"></a><span id="l86.212"> </span>
<a href="#l86.213"></a><span id="l86.213">   if ((msgid = ldap_url_search(ld, url, attrsonly)) == -1) {</span>
<a href="#l86.214"></a><span id="l86.214">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l86.215"></a><span id="l86.215">   }</span>
<a href="#l86.216"></a><span id="l86.216"> </span>
<a href="#l86.217"></a><span id="l86.217" class="difflineminus">-  if (ldap_result(ld, msgid, 1, (struct timeval *)NULL, res) == -1) {</span>
<a href="#l86.218"></a><span id="l86.218" class="difflineplus">+  if (ldap_result(ld, msgid, 1, (struct timeval*)NULL, res) == -1) {</span>
<a href="#l86.219"></a><span id="l86.219">     return (LDAP_GET_LDERRNO(ld, NULL, NULL));</span>
<a href="#l86.220"></a><span id="l86.220">   }</span>
<a href="#l86.221"></a><span id="l86.221"> </span>
<a href="#l86.222"></a><span id="l86.222">   return (ldap_result2error(ld, *res, 0));</span>
<a href="#l86.223"></a><span id="l86.223"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l87.1"></a><span id="l87.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/userstatusctrl.c</span>
<a href="#l87.2"></a><span id="l87.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/userstatusctrl.c</span>
<a href="#l87.3"></a><span id="l87.3" class="difflineat">@@ -45,19 +45,19 @@</span>
<a href="#l87.4"></a><span id="l87.4">    ctl_iscritical  Indicates whether the control is critical of not. If</span>
<a href="#l87.5"></a><span id="l87.5">                    this field is non-zero, the operation will only be car-</span>
<a href="#l87.6"></a><span id="l87.6">                    ried out if the control is recognized by the server</span>
<a href="#l87.7"></a><span id="l87.7">                    and/or client</span>
<a href="#l87.8"></a><span id="l87.8"> </span>
<a href="#l87.9"></a><span id="l87.9">    ctrlp           the address of a place to put the constructed control</span>
<a href="#l87.10"></a><span id="l87.10"> */</span>
<a href="#l87.11"></a><span id="l87.11"> </span>
<a href="#l87.12"></a><span id="l87.12" class="difflineminus">-int LDAP_CALL ldap_create_userstatus_control(LDAP *ld,</span>
<a href="#l87.13"></a><span id="l87.13" class="difflineplus">+int LDAP_CALL ldap_create_userstatus_control(LDAP* ld,</span>
<a href="#l87.14"></a><span id="l87.14">                                              const char ctl_iscritical,</span>
<a href="#l87.15"></a><span id="l87.15" class="difflineminus">-                                             LDAPControl **ctrlp) {</span>
<a href="#l87.16"></a><span id="l87.16" class="difflineplus">+                                             LDAPControl** ctrlp) {</span>
<a href="#l87.17"></a><span id="l87.17">   int rc;</span>
<a href="#l87.18"></a><span id="l87.18"> </span>
<a href="#l87.19"></a><span id="l87.19">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l87.20"></a><span id="l87.20">     return (LDAP_PARAM_ERROR);</span>
<a href="#l87.21"></a><span id="l87.21">   }</span>
<a href="#l87.22"></a><span id="l87.22"> </span>
<a href="#l87.23"></a><span id="l87.23">   if (ctrlp == NULL) {</span>
<a href="#l87.24"></a><span id="l87.24">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l87.25"></a><span id="l87.25" class="difflineat">@@ -80,21 +80,21 @@ int LDAP_CALL ldap_create_userstatus_con</span>
<a href="#l87.26"></a><span id="l87.26">    ctrlp           An array of controls obtained from calling</span>
<a href="#l87.27"></a><span id="l87.27">                    ldap_parse_result on the set of results</span>
<a href="#l87.28"></a><span id="l87.28">                    returned by the server</span>
<a href="#l87.29"></a><span id="l87.29"> </span>
<a href="#l87.30"></a><span id="l87.30">    us              the address of struct LDAPuserstatus</span>
<a href="#l87.31"></a><span id="l87.31">                    to parse control results to</span>
<a href="#l87.32"></a><span id="l87.32"> */</span>
<a href="#l87.33"></a><span id="l87.33"> </span>
<a href="#l87.34"></a><span id="l87.34" class="difflineminus">-int LDAP_CALL ldap_parse_userstatus_control(LDAP *ld, LDAPControl **ctrlp,</span>
<a href="#l87.35"></a><span id="l87.35" class="difflineminus">-                                            LDAPuserstatus *us) {</span>
<a href="#l87.36"></a><span id="l87.36" class="difflineminus">-  BerElement *ber = NULL;</span>
<a href="#l87.37"></a><span id="l87.37" class="difflineplus">+int LDAP_CALL ldap_parse_userstatus_control(LDAP* ld, LDAPControl** ctrlp,</span>
<a href="#l87.38"></a><span id="l87.38" class="difflineplus">+                                            LDAPuserstatus* us) {</span>
<a href="#l87.39"></a><span id="l87.39" class="difflineplus">+  BerElement* ber = NULL;</span>
<a href="#l87.40"></a><span id="l87.40">   int i, foundUSControl;</span>
<a href="#l87.41"></a><span id="l87.41" class="difflineminus">-  LDAPControl *USCtrlp = NULL;</span>
<a href="#l87.42"></a><span id="l87.42" class="difflineplus">+  LDAPControl* USCtrlp = NULL;</span>
<a href="#l87.43"></a><span id="l87.43">   ber_tag_t tag;</span>
<a href="#l87.44"></a><span id="l87.44"> </span>
<a href="#l87.45"></a><span id="l87.45">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) || us == NULL) {</span>
<a href="#l87.46"></a><span id="l87.46">     return (LDAP_PARAM_ERROR);</span>
<a href="#l87.47"></a><span id="l87.47">   }</span>
<a href="#l87.48"></a><span id="l87.48"> </span>
<a href="#l87.49"></a><span id="l87.49">   /* find the control in the list of controls if it exists */</span>
<a href="#l87.50"></a><span id="l87.50">   if (ctrlp == NULL) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l88.1"></a><span id="l88.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/vlistctrl.c</span>
<a href="#l88.2"></a><span id="l88.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/vlistctrl.c</span>
<a href="#l88.3"></a><span id="l88.3" class="difflineat">@@ -70,20 +70,20 @@</span>
<a href="#l88.4"></a><span id="l88.4">   greaterThanOrEqual  is  an  attribute  assertion  value  defined  in</span>
<a href="#l88.5"></a><span id="l88.5">   [LDAPv3].  If  present, the value supplied in greaterThanOrEqual is used</span>
<a href="#l88.6"></a><span id="l88.6">   to determine the target entry by  comparison  with  the  values  of  the</span>
<a href="#l88.7"></a><span id="l88.7">   attribute  specified as the primary sort key. The first list entry who's</span>
<a href="#l88.8"></a><span id="l88.8">   value is no less than the supplied value is the target entry.</span>
<a href="#l88.9"></a><span id="l88.9"> </span>
<a href="#l88.10"></a><span id="l88.10">  */</span>
<a href="#l88.11"></a><span id="l88.11"> </span>
<a href="#l88.12"></a><span id="l88.12" class="difflineminus">-int LDAP_CALL ldap_create_virtuallist_control(LDAP *ld,</span>
<a href="#l88.13"></a><span id="l88.13" class="difflineminus">-                                              LDAPVirtualList *ldvlistp,</span>
<a href="#l88.14"></a><span id="l88.14" class="difflineminus">-                                              LDAPControl **ctrlp) {</span>
<a href="#l88.15"></a><span id="l88.15" class="difflineminus">-  BerElement *ber;</span>
<a href="#l88.16"></a><span id="l88.16" class="difflineplus">+int LDAP_CALL ldap_create_virtuallist_control(LDAP* ld,</span>
<a href="#l88.17"></a><span id="l88.17" class="difflineplus">+                                              LDAPVirtualList* ldvlistp,</span>
<a href="#l88.18"></a><span id="l88.18" class="difflineplus">+                                              LDAPControl** ctrlp) {</span>
<a href="#l88.19"></a><span id="l88.19" class="difflineplus">+  BerElement* ber;</span>
<a href="#l88.20"></a><span id="l88.20">   int rc;</span>
<a href="#l88.21"></a><span id="l88.21"> </span>
<a href="#l88.22"></a><span id="l88.22">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l88.23"></a><span id="l88.23">     return (LDAP_PARAM_ERROR);</span>
<a href="#l88.24"></a><span id="l88.24">   }</span>
<a href="#l88.25"></a><span id="l88.25"> </span>
<a href="#l88.26"></a><span id="l88.26">   if (NULL == ctrlp || NULL == ldvlistp) {</span>
<a href="#l88.27"></a><span id="l88.27">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l88.28"></a><span id="l88.28" class="difflineat">@@ -151,24 +151,24 @@ int LDAP_CALL ldap_create_virtuallist_co</span>
<a href="#l88.29"></a><span id="l88.29">                        busy (51),</span>
<a href="#l88.30"></a><span id="l88.30">                        timeLimitExceeded (3),</span>
<a href="#l88.31"></a><span id="l88.31">                        adminLimitExceeded (11),</span>
<a href="#l88.32"></a><span id="l88.32">                        sortControlMissing (60),</span>
<a href="#l88.33"></a><span id="l88.33">                        indexRangeError (61),</span>
<a href="#l88.34"></a><span id="l88.34">                        other (80) }  }</span>
<a href="#l88.35"></a><span id="l88.35"> </span>
<a href="#l88.36"></a><span id="l88.36">  */</span>
<a href="#l88.37"></a><span id="l88.37" class="difflineminus">-int LDAP_CALL ldap_parse_virtuallist_control(LDAP *ld, LDAPControl **ctrls,</span>
<a href="#l88.38"></a><span id="l88.38" class="difflineminus">-                                             ber_int_t *target_posp,</span>
<a href="#l88.39"></a><span id="l88.39" class="difflineminus">-                                             ber_int_t *list_sizep,</span>
<a href="#l88.40"></a><span id="l88.40" class="difflineminus">-                                             int *errcodep) {</span>
<a href="#l88.41"></a><span id="l88.41" class="difflineminus">-  BerElement *ber;</span>
<a href="#l88.42"></a><span id="l88.42" class="difflineplus">+int LDAP_CALL ldap_parse_virtuallist_control(LDAP* ld, LDAPControl** ctrls,</span>
<a href="#l88.43"></a><span id="l88.43" class="difflineplus">+                                             ber_int_t* target_posp,</span>
<a href="#l88.44"></a><span id="l88.44" class="difflineplus">+                                             ber_int_t* list_sizep,</span>
<a href="#l88.45"></a><span id="l88.45" class="difflineplus">+                                             int* errcodep) {</span>
<a href="#l88.46"></a><span id="l88.46" class="difflineplus">+  BerElement* ber;</span>
<a href="#l88.47"></a><span id="l88.47">   int i, foundListControl;</span>
<a href="#l88.48"></a><span id="l88.48">   ber_int_t errcode;</span>
<a href="#l88.49"></a><span id="l88.49" class="difflineminus">-  LDAPControl *listCtrlp;</span>
<a href="#l88.50"></a><span id="l88.50" class="difflineplus">+  LDAPControl* listCtrlp;</span>
<a href="#l88.51"></a><span id="l88.51">   ber_int_t target_pos, list_size;</span>
<a href="#l88.52"></a><span id="l88.52"> </span>
<a href="#l88.53"></a><span id="l88.53">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l88.54"></a><span id="l88.54">     return (LDAP_PARAM_ERROR);</span>
<a href="#l88.55"></a><span id="l88.55">   }</span>
<a href="#l88.56"></a><span id="l88.56"> </span>
<a href="#l88.57"></a><span id="l88.57">   /* only ldapv3 or higher can do virtual lists. */</span>
<a href="#l88.58"></a><span id="l88.58">   if (NSLDAPI_LDAP_VERSION(ld) &lt; LDAP_VERSION3) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l89.1"></a><span id="l89.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/whoami.c</span>
<a href="#l89.2"></a><span id="l89.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/whoami.c</span>
<a href="#l89.3"></a><span id="l89.3" class="difflineat">@@ -32,37 +32,37 @@</span>
<a href="#l89.4"></a><span id="l89.4">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l89.5"></a><span id="l89.5">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l89.6"></a><span id="l89.6">  *</span>
<a href="#l89.7"></a><span id="l89.7">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l89.8"></a><span id="l89.8"> </span>
<a href="#l89.9"></a><span id="l89.9"> #include &quot;ldap-int.h&quot;</span>
<a href="#l89.10"></a><span id="l89.10"> </span>
<a href="#l89.11"></a><span id="l89.11"> /* ldap_whoami */</span>
<a href="#l89.12"></a><span id="l89.12" class="difflineminus">-int LDAP_CALL ldap_whoami(LDAP *ld, LDAPControl **serverctrls,</span>
<a href="#l89.13"></a><span id="l89.13" class="difflineminus">-                          LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l89.14"></a><span id="l89.14" class="difflineplus">+int LDAP_CALL ldap_whoami(LDAP* ld, LDAPControl** serverctrls,</span>
<a href="#l89.15"></a><span id="l89.15" class="difflineplus">+                          LDAPControl** clientctrls, int* msgidp) {</span>
<a href="#l89.16"></a><span id="l89.16">   int rc;</span>
<a href="#l89.17"></a><span id="l89.17" class="difflineminus">-  struct berval *requestdata = NULL;</span>
<a href="#l89.18"></a><span id="l89.18" class="difflineplus">+  struct berval* requestdata = NULL;</span>
<a href="#l89.19"></a><span id="l89.19"> </span>
<a href="#l89.20"></a><span id="l89.20">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l89.21"></a><span id="l89.21">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l89.22"></a><span id="l89.22">     return (LDAP_PARAM_ERROR);</span>
<a href="#l89.23"></a><span id="l89.23">   }</span>
<a href="#l89.24"></a><span id="l89.24"> </span>
<a href="#l89.25"></a><span id="l89.25">   rc = ldap_extended_operation(ld, LDAP_EXOP_WHO_AM_I, requestdata, serverctrls,</span>
<a href="#l89.26"></a><span id="l89.26">                                clientctrls, msgidp);</span>
<a href="#l89.27"></a><span id="l89.27"> </span>
<a href="#l89.28"></a><span id="l89.28">   return (rc);</span>
<a href="#l89.29"></a><span id="l89.29"> }</span>
<a href="#l89.30"></a><span id="l89.30"> </span>
<a href="#l89.31"></a><span id="l89.31"> /* ldap_parse_whoami */</span>
<a href="#l89.32"></a><span id="l89.32" class="difflineminus">-int LDAP_CALL ldap_parse_whoami(LDAP *ld, LDAPMessage *result,</span>
<a href="#l89.33"></a><span id="l89.33" class="difflineminus">-                                struct berval **authzid) {</span>
<a href="#l89.34"></a><span id="l89.34" class="difflineplus">+int LDAP_CALL ldap_parse_whoami(LDAP* ld, LDAPMessage* result,</span>
<a href="#l89.35"></a><span id="l89.35" class="difflineplus">+                                struct berval** authzid) {</span>
<a href="#l89.36"></a><span id="l89.36">   int rc;</span>
<a href="#l89.37"></a><span id="l89.37" class="difflineminus">-  char *retoidp = NULL;</span>
<a href="#l89.38"></a><span id="l89.38" class="difflineplus">+  char* retoidp = NULL;</span>
<a href="#l89.39"></a><span id="l89.39"> </span>
<a href="#l89.40"></a><span id="l89.40">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l89.41"></a><span id="l89.41">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l89.42"></a><span id="l89.42">     return (LDAP_PARAM_ERROR);</span>
<a href="#l89.43"></a><span id="l89.43">   }</span>
<a href="#l89.44"></a><span id="l89.44">   if (!result) {</span>
<a href="#l89.45"></a><span id="l89.45">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l89.46"></a><span id="l89.46">     return (LDAP_PARAM_ERROR);</span>
<a href="#l89.47"></a><span id="l89.47" class="difflineat">@@ -76,22 +76,22 @@ int LDAP_CALL ldap_parse_whoami(LDAP *ld</span>
<a href="#l89.48"></a><span id="l89.48">     return (rc);</span>
<a href="#l89.49"></a><span id="l89.49">   }</span>
<a href="#l89.50"></a><span id="l89.50"> </span>
<a href="#l89.51"></a><span id="l89.51">   ldap_memfree(retoidp);</span>
<a href="#l89.52"></a><span id="l89.52">   return (LDAP_SUCCESS);</span>
<a href="#l89.53"></a><span id="l89.53"> }</span>
<a href="#l89.54"></a><span id="l89.54"> </span>
<a href="#l89.55"></a><span id="l89.55"> /* ldap_whoami_s */</span>
<a href="#l89.56"></a><span id="l89.56" class="difflineminus">-int LDAP_CALL ldap_whoami_s(LDAP *ld, struct berval **authzid,</span>
<a href="#l89.57"></a><span id="l89.57" class="difflineminus">-                            LDAPControl **serverctrls,</span>
<a href="#l89.58"></a><span id="l89.58" class="difflineminus">-                            LDAPControl **clientctrls) {</span>
<a href="#l89.59"></a><span id="l89.59" class="difflineplus">+int LDAP_CALL ldap_whoami_s(LDAP* ld, struct berval** authzid,</span>
<a href="#l89.60"></a><span id="l89.60" class="difflineplus">+                            LDAPControl** serverctrls,</span>
<a href="#l89.61"></a><span id="l89.61" class="difflineplus">+                            LDAPControl** clientctrls) {</span>
<a href="#l89.62"></a><span id="l89.62">   int rc;</span>
<a href="#l89.63"></a><span id="l89.63">   int msgid;</span>
<a href="#l89.64"></a><span id="l89.64" class="difflineminus">-  LDAPMessage *result = NULL;</span>
<a href="#l89.65"></a><span id="l89.65" class="difflineplus">+  LDAPMessage* result = NULL;</span>
<a href="#l89.66"></a><span id="l89.66"> </span>
<a href="#l89.67"></a><span id="l89.67">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l89.68"></a><span id="l89.68">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l89.69"></a><span id="l89.69">     return (LDAP_PARAM_ERROR);</span>
<a href="#l89.70"></a><span id="l89.70">   }</span>
<a href="#l89.71"></a><span id="l89.71"> </span>
<a href="#l89.72"></a><span id="l89.72">   rc = ldap_whoami(ld, serverctrls, clientctrls, &amp;msgid);</span>
<a href="#l89.73"></a><span id="l89.73">   if (rc != LDAP_SUCCESS) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l90.1"></a><span id="l90.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldif/line64.c</span>
<a href="#l90.2"></a><span id="l90.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldif/line64.c</span>
<a href="#l90.3"></a><span id="l90.3" class="difflineat">@@ -75,27 +75,27 @@ static unsigned char b642nib[0x80] = {</span>
<a href="#l90.4"></a><span id="l90.4">     0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff, 0xff,</span>
<a href="#l90.5"></a><span id="l90.5">     0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,</span>
<a href="#l90.6"></a><span id="l90.6">     0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,</span>
<a href="#l90.7"></a><span id="l90.7">     0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,</span>
<a href="#l90.8"></a><span id="l90.8">     0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,</span>
<a href="#l90.9"></a><span id="l90.9">     0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,</span>
<a href="#l90.10"></a><span id="l90.10">     0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff};</span>
<a href="#l90.11"></a><span id="l90.11"> </span>
<a href="#l90.12"></a><span id="l90.12" class="difflineminus">-static int ldif_base64_encode_internal(unsigned char *src, char *dst,</span>
<a href="#l90.13"></a><span id="l90.13" class="difflineplus">+static int ldif_base64_encode_internal(unsigned char* src, char* dst,</span>
<a href="#l90.14"></a><span id="l90.14">                                        int srclen, int lenused, int wraplen);</span>
<a href="#l90.15"></a><span id="l90.15"> </span>
<a href="#l90.16"></a><span id="l90.16"> /*</span>
<a href="#l90.17"></a><span id="l90.17">  * ldif_parse_line - takes a line of the form &quot;type:[:] value&quot; and splits it</span>
<a href="#l90.18"></a><span id="l90.18">  * into components &quot;type&quot; and &quot;value&quot;.  if a double colon separates type from</span>
<a href="#l90.19"></a><span id="l90.19">  * value, then value is encoded in base 64, and parse_line un-decodes it</span>
<a href="#l90.20"></a><span id="l90.20">  * (in place) before returning.</span>
<a href="#l90.21"></a><span id="l90.21">  */</span>
<a href="#l90.22"></a><span id="l90.22"> </span>
<a href="#l90.23"></a><span id="l90.23" class="difflineminus">-int ldif_parse_line(char *line, char **type, char **value, int *vlen) {</span>
<a href="#l90.24"></a><span id="l90.24" class="difflineplus">+int ldif_parse_line(char* line, char** type, char** value, int* vlen) {</span>
<a href="#l90.25"></a><span id="l90.25">   char *p, *s, *d;</span>
<a href="#l90.26"></a><span id="l90.26">   int b64;</span>
<a href="#l90.27"></a><span id="l90.27"> </span>
<a href="#l90.28"></a><span id="l90.28">   /* skip any leading space */</span>
<a href="#l90.29"></a><span id="l90.29">   while (ISBLANK(*line)) {</span>
<a href="#l90.30"></a><span id="l90.30">     line++;</span>
<a href="#l90.31"></a><span id="l90.31">   }</span>
<a href="#l90.32"></a><span id="l90.32">   *type = line;</span>
<a href="#l90.33"></a><span id="l90.33" class="difflineat">@@ -150,17 +150,17 @@ int ldif_parse_line(char *line, char **t</span>
<a href="#l90.34"></a><span id="l90.34">   /* check for continued line markers that should be deleted */</span>
<a href="#l90.35"></a><span id="l90.35">   for (p = s, d = s; *p; p++) {</span>
<a href="#l90.36"></a><span id="l90.36">     if (*p != CONTINUED_LINE_MARKER) *d++ = *p;</span>
<a href="#l90.37"></a><span id="l90.37">   }</span>
<a href="#l90.38"></a><span id="l90.38">   *d = '\0';</span>
<a href="#l90.39"></a><span id="l90.39"> </span>
<a href="#l90.40"></a><span id="l90.40">   *value = s;</span>
<a href="#l90.41"></a><span id="l90.41">   if (b64) {</span>
<a href="#l90.42"></a><span id="l90.42" class="difflineminus">-    if ((*vlen = ldif_base64_decode(s, (unsigned char *)s)) &lt; 0) {</span>
<a href="#l90.43"></a><span id="l90.43" class="difflineplus">+    if ((*vlen = ldif_base64_decode(s, (unsigned char*)s)) &lt; 0) {</span>
<a href="#l90.44"></a><span id="l90.44">       /* Comment-out while we address calling libldif from ns-back-ldbm</span>
<a href="#l90.45"></a><span id="l90.45">               on NT. 3 of 3 */</span>
<a href="#l90.46"></a><span id="l90.46"> #if defined(_WIN32)</span>
<a href="#l90.47"></a><span id="l90.47">       /*</span>
<a href="#l90.48"></a><span id="l90.48"> #endif</span>
<a href="#l90.49"></a><span id="l90.49">                LDAPDebug( LDAP_DEBUG_ANY,</span>
<a href="#l90.50"></a><span id="l90.50">                   &quot;ldif_parse_line: invalid base 64 char on line \&quot;%s\&quot;\n&quot;,</span>
<a href="#l90.51"></a><span id="l90.51">                   line, 0, 0 );</span>
<a href="#l90.52"></a><span id="l90.52" class="difflineat">@@ -185,17 +185,17 @@ int ldif_parse_line(char *line, char **t</span>
<a href="#l90.53"></a><span id="l90.53">  * 3 * strlen(src) / 4 bytes will be produced.</span>
<a href="#l90.54"></a><span id="l90.54">  * &quot;dst&quot; may contain zero octets anywhere within it, but it is not</span>
<a href="#l90.55"></a><span id="l90.55">  * zero-terminated by this function.</span>
<a href="#l90.56"></a><span id="l90.56">  *</span>
<a href="#l90.57"></a><span id="l90.57">  * The number of bytes copied to &quot;dst&quot; is returned if all goes well.</span>
<a href="#l90.58"></a><span id="l90.58">  * -1 is returned if the BASE64 encoding in &quot;src&quot; is invalid.</span>
<a href="#l90.59"></a><span id="l90.59">  */</span>
<a href="#l90.60"></a><span id="l90.60"> </span>
<a href="#l90.61"></a><span id="l90.61" class="difflineminus">-int ldif_base64_decode(char *src, unsigned char *dst) {</span>
<a href="#l90.62"></a><span id="l90.62" class="difflineplus">+int ldif_base64_decode(char* src, unsigned char* dst) {</span>
<a href="#l90.63"></a><span id="l90.63">   char *p, *stop;</span>
<a href="#l90.64"></a><span id="l90.64">   unsigned char nib, *byte;</span>
<a href="#l90.65"></a><span id="l90.65">   int i, len;</span>
<a href="#l90.66"></a><span id="l90.66"> </span>
<a href="#l90.67"></a><span id="l90.67">   stop = strchr(src, '\0');</span>
<a href="#l90.68"></a><span id="l90.68">   byte = dst;</span>
<a href="#l90.69"></a><span id="l90.69">   for (p = src, len = 0; p &lt; stop; p += 4, len += 3) {</span>
<a href="#l90.70"></a><span id="l90.70">     for (i = 0; i &lt; 4; i++) {</span>
<a href="#l90.71"></a><span id="l90.71" class="difflineat">@@ -248,20 +248,20 @@ int ldif_base64_decode(char *src, unsign</span>
<a href="#l90.72"></a><span id="l90.72">  *</span>
<a href="#l90.73"></a><span id="l90.73">  * it takes a pointer to a pointer to the buffer on the first call,</span>
<a href="#l90.74"></a><span id="l90.74">  * which it updates and must be supplied on subsequent calls.</span>
<a href="#l90.75"></a><span id="l90.75">  *</span>
<a href="#l90.76"></a><span id="l90.76">  * XXX need to update this function to also support &lt;CR&gt;&lt;LF&gt; as EOL.</span>
<a href="#l90.77"></a><span id="l90.77">  * XXX supports &lt;CR&gt;&lt;LF&gt; as of 07/29/1998 (richm)</span>
<a href="#l90.78"></a><span id="l90.78">  */</span>
<a href="#l90.79"></a><span id="l90.79"> </span>
<a href="#l90.80"></a><span id="l90.80" class="difflineminus">-char *ldif_getline(char **next) {</span>
<a href="#l90.81"></a><span id="l90.81" class="difflineminus">-  char *l;</span>
<a href="#l90.82"></a><span id="l90.82" class="difflineplus">+char* ldif_getline(char** next) {</span>
<a href="#l90.83"></a><span id="l90.83" class="difflineplus">+  char* l;</span>
<a href="#l90.84"></a><span id="l90.84">   char c;</span>
<a href="#l90.85"></a><span id="l90.85" class="difflineminus">-  char *p;</span>
<a href="#l90.86"></a><span id="l90.86" class="difflineplus">+  char* p;</span>
<a href="#l90.87"></a><span id="l90.87"> </span>
<a href="#l90.88"></a><span id="l90.88">   if (*next == NULL || **next == '\n' || **next == '\0') {</span>
<a href="#l90.89"></a><span id="l90.89">     return (NULL);</span>
<a href="#l90.90"></a><span id="l90.90">   }</span>
<a href="#l90.91"></a><span id="l90.91"> </span>
<a href="#l90.92"></a><span id="l90.92">   while (**next == '#') { /* skip comment lines */</span>
<a href="#l90.93"></a><span id="l90.93">     if ((*next = strchr(*next, '\n')) == NULL) {</span>
<a href="#l90.94"></a><span id="l90.94">       return (NULL);</span>
<a href="#l90.95"></a><span id="l90.95" class="difflineat">@@ -296,61 +296,61 @@ char *ldif_getline(char **next) {</span>
<a href="#l90.96"></a><span id="l90.96"> #define LDIF_CONSERVATIVE_CHAR(c) \</span>
<a href="#l90.97"></a><span id="l90.97">   (LDIF_SAFE_CHAR(c) &amp;&amp; isascii((c)) &amp;&amp; (isprint((c)) || (c) == '\t'))</span>
<a href="#l90.98"></a><span id="l90.98"> #define LDIF_SAFE_INITCHAR(c) \</span>
<a href="#l90.99"></a><span id="l90.99">   (LDIF_SAFE_CHAR(c) &amp;&amp; (c) != ':' &amp;&amp; (c) != ' ' &amp;&amp; (c) != '&lt;')</span>
<a href="#l90.100"></a><span id="l90.100"> #define LDIF_CONSERVATIVE_INITCHAR(c) \</span>
<a href="#l90.101"></a><span id="l90.101">   (LDIF_SAFE_INITCHAR(c) &amp;&amp; !(isascii((c)) &amp;&amp; isspace((c))))</span>
<a href="#l90.102"></a><span id="l90.102"> #define LDIF_CONSERVATIVE_FINALCHAR(c) ((c) != ' ')</span>
<a href="#l90.103"></a><span id="l90.103"> </span>
<a href="#l90.104"></a><span id="l90.104" class="difflineminus">-void ldif_put_type_and_value_with_options(char **out, char *t, char *val,</span>
<a href="#l90.105"></a><span id="l90.105" class="difflineplus">+void ldif_put_type_and_value_with_options(char** out, char* t, char* val,</span>
<a href="#l90.106"></a><span id="l90.106">                                           int vlen, unsigned long options) {</span>
<a href="#l90.107"></a><span id="l90.107">   unsigned char *p, *byte, *stop;</span>
<a href="#l90.108"></a><span id="l90.108" class="difflineminus">-  char *save;</span>
<a href="#l90.109"></a><span id="l90.109" class="difflineplus">+  char* save;</span>
<a href="#l90.110"></a><span id="l90.110">   int b64, len, savelen, wraplen;</span>
<a href="#l90.111"></a><span id="l90.111">   len = 0;</span>
<a href="#l90.112"></a><span id="l90.112"> </span>
<a href="#l90.113"></a><span id="l90.113">   if (LDIF_OPT_ISSET(options, LDIF_OPT_NOWRAP)) {</span>
<a href="#l90.114"></a><span id="l90.114">     wraplen = -1;</span>
<a href="#l90.115"></a><span id="l90.115">   } else {</span>
<a href="#l90.116"></a><span id="l90.116">     wraplen = LDIF_MAX_LINE_WIDTH;</span>
<a href="#l90.117"></a><span id="l90.117">   }</span>
<a href="#l90.118"></a><span id="l90.118"> </span>
<a href="#l90.119"></a><span id="l90.119">   /* put the type + &quot;: &quot; */</span>
<a href="#l90.120"></a><span id="l90.120" class="difflineminus">-  for (p = (unsigned char *)t; *p; p++, len++) {</span>
<a href="#l90.121"></a><span id="l90.121" class="difflineplus">+  for (p = (unsigned char*)t; *p; p++, len++) {</span>
<a href="#l90.122"></a><span id="l90.122">     *(*out)++ = *p;</span>
<a href="#l90.123"></a><span id="l90.123">   }</span>
<a href="#l90.124"></a><span id="l90.124">   *(*out)++ = ':';</span>
<a href="#l90.125"></a><span id="l90.125">   len++;</span>
<a href="#l90.126"></a><span id="l90.126">   if (LDIF_OPT_ISSET(options, LDIF_OPT_VALUE_IS_URL)) {</span>
<a href="#l90.127"></a><span id="l90.127">     *(*out)++ = '&lt;'; /* add '&lt;' for URLs */</span>
<a href="#l90.128"></a><span id="l90.128">     len++;</span>
<a href="#l90.129"></a><span id="l90.129">   }</span>
<a href="#l90.130"></a><span id="l90.130">   save = *out;</span>
<a href="#l90.131"></a><span id="l90.131">   savelen = len;</span>
<a href="#l90.132"></a><span id="l90.132">   b64 = 0;</span>
<a href="#l90.133"></a><span id="l90.133"> </span>
<a href="#l90.134"></a><span id="l90.134" class="difflineminus">-  stop = (unsigned char *)val;</span>
<a href="#l90.135"></a><span id="l90.135" class="difflineplus">+  stop = (unsigned char*)val;</span>
<a href="#l90.136"></a><span id="l90.136">   if (val &amp;&amp; vlen &gt; 0) {</span>
<a href="#l90.137"></a><span id="l90.137">     *(*out)++ = ' ';</span>
<a href="#l90.138"></a><span id="l90.138" class="difflineminus">-    stop = (unsigned char *)(val + vlen);</span>
<a href="#l90.139"></a><span id="l90.139" class="difflineplus">+    stop = (unsigned char*)(val + vlen);</span>
<a href="#l90.140"></a><span id="l90.140">     if (LDIF_OPT_ISSET(options, LDIF_OPT_MINIMAL_ENCODING)) {</span>
<a href="#l90.141"></a><span id="l90.141">       if (!LDIF_SAFE_INITCHAR(val[0])) {</span>
<a href="#l90.142"></a><span id="l90.142">         b64 = 1;</span>
<a href="#l90.143"></a><span id="l90.143">       }</span>
<a href="#l90.144"></a><span id="l90.144">     } else {</span>
<a href="#l90.145"></a><span id="l90.145">       if (!LDIF_CONSERVATIVE_INITCHAR(val[0]) ||</span>
<a href="#l90.146"></a><span id="l90.146">           !LDIF_CONSERVATIVE_FINALCHAR(val[vlen - 1])) {</span>
<a href="#l90.147"></a><span id="l90.147">         b64 = 1;</span>
<a href="#l90.148"></a><span id="l90.148">       }</span>
<a href="#l90.149"></a><span id="l90.149">     }</span>
<a href="#l90.150"></a><span id="l90.150">   }</span>
<a href="#l90.151"></a><span id="l90.151"> </span>
<a href="#l90.152"></a><span id="l90.152">   if (!b64) {</span>
<a href="#l90.153"></a><span id="l90.153" class="difflineminus">-    for (byte = (unsigned char *)val; byte &lt; stop; byte++, len++) {</span>
<a href="#l90.154"></a><span id="l90.154" class="difflineplus">+    for (byte = (unsigned char*)val; byte &lt; stop; byte++, len++) {</span>
<a href="#l90.155"></a><span id="l90.155">       if (LDIF_OPT_ISSET(options, LDIF_OPT_MINIMAL_ENCODING)) {</span>
<a href="#l90.156"></a><span id="l90.156">         if (!LDIF_SAFE_CHAR(*byte)) {</span>
<a href="#l90.157"></a><span id="l90.157">           b64 = 1;</span>
<a href="#l90.158"></a><span id="l90.158">           break;</span>
<a href="#l90.159"></a><span id="l90.159">         }</span>
<a href="#l90.160"></a><span id="l90.160">       } else if (!LDIF_CONSERVATIVE_CHAR(*byte)) {</span>
<a href="#l90.161"></a><span id="l90.161">         b64 = 1;</span>
<a href="#l90.162"></a><span id="l90.162">         break;</span>
<a href="#l90.163"></a><span id="l90.163" class="difflineat">@@ -364,29 +364,29 @@ void ldif_put_type_and_value_with_option</span>
<a href="#l90.164"></a><span id="l90.164">       *(*out)++ = *byte;</span>
<a href="#l90.165"></a><span id="l90.165">     }</span>
<a href="#l90.166"></a><span id="l90.166">   }</span>
<a href="#l90.167"></a><span id="l90.167"> </span>
<a href="#l90.168"></a><span id="l90.168">   if (b64) {</span>
<a href="#l90.169"></a><span id="l90.169">     *out = save;</span>
<a href="#l90.170"></a><span id="l90.170">     *(*out)++ = ':';</span>
<a href="#l90.171"></a><span id="l90.171">     *(*out)++ = ' ';</span>
<a href="#l90.172"></a><span id="l90.172" class="difflineminus">-    len = ldif_base64_encode_internal((unsigned char *)val, *out, vlen,</span>
<a href="#l90.173"></a><span id="l90.173" class="difflineplus">+    len = ldif_base64_encode_internal((unsigned char*)val, *out, vlen,</span>
<a href="#l90.174"></a><span id="l90.174">                                       savelen + 2, wraplen);</span>
<a href="#l90.175"></a><span id="l90.175">     *out += len;</span>
<a href="#l90.176"></a><span id="l90.176">   }</span>
<a href="#l90.177"></a><span id="l90.177"> </span>
<a href="#l90.178"></a><span id="l90.178">   *(*out)++ = '\n';</span>
<a href="#l90.179"></a><span id="l90.179"> }</span>
<a href="#l90.180"></a><span id="l90.180"> </span>
<a href="#l90.181"></a><span id="l90.181" class="difflineminus">-void ldif_put_type_and_value(char **out, char *t, char *val, int vlen) {</span>
<a href="#l90.182"></a><span id="l90.182" class="difflineplus">+void ldif_put_type_and_value(char** out, char* t, char* val, int vlen) {</span>
<a href="#l90.183"></a><span id="l90.183">   ldif_put_type_and_value_with_options(out, t, val, vlen, 0);</span>
<a href="#l90.184"></a><span id="l90.184"> }</span>
<a href="#l90.185"></a><span id="l90.185"> </span>
<a href="#l90.186"></a><span id="l90.186" class="difflineminus">-void ldif_put_type_and_value_nowrap(char **out, char *t, char *val, int vlen) {</span>
<a href="#l90.187"></a><span id="l90.187" class="difflineplus">+void ldif_put_type_and_value_nowrap(char** out, char* t, char* val, int vlen) {</span>
<a href="#l90.188"></a><span id="l90.188">   ldif_put_type_and_value_with_options(out, t, val, vlen, LDIF_OPT_NOWRAP);</span>
<a href="#l90.189"></a><span id="l90.189"> }</span>
<a href="#l90.190"></a><span id="l90.190"> </span>
<a href="#l90.191"></a><span id="l90.191"> /*</span>
<a href="#l90.192"></a><span id="l90.192">  * ldif_base64_encode_internal - encode &quot;srclen&quot; bytes in &quot;src&quot;, place BASE64</span>
<a href="#l90.193"></a><span id="l90.193">  * encoded bytes in &quot;dst&quot; and return the length of the BASE64</span>
<a href="#l90.194"></a><span id="l90.194">  * encoded string.  &quot;dst&quot; is also zero-terminated by this function.</span>
<a href="#l90.195"></a><span id="l90.195">  *</span>
<a href="#l90.196"></a><span id="l90.196" class="difflineat">@@ -395,21 +395,21 @@ void ldif_put_type_and_value_nowrap(char</span>
<a href="#l90.197"></a><span id="l90.197">  * on the current line.  The LDIF lines we create will contain at most</span>
<a href="#l90.198"></a><span id="l90.198">  * &quot;wraplen&quot; characters on each line, unless &quot;wraplen&quot; is -1, in which</span>
<a href="#l90.199"></a><span id="l90.199">  * case output line length is unlimited.</span>
<a href="#l90.200"></a><span id="l90.200">  *</span>
<a href="#l90.201"></a><span id="l90.201">  * If &quot;lenused&quot; &lt; 0, no newlines will be included, and the LDIF_BASE64_LEN()</span>
<a href="#l90.202"></a><span id="l90.202">  * macro can be used to determine how many bytes will be placed in &quot;dst.&quot;</span>
<a href="#l90.203"></a><span id="l90.203">  */</span>
<a href="#l90.204"></a><span id="l90.204"> </span>
<a href="#l90.205"></a><span id="l90.205" class="difflineminus">-static int ldif_base64_encode_internal(unsigned char *src, char *dst,</span>
<a href="#l90.206"></a><span id="l90.206" class="difflineplus">+static int ldif_base64_encode_internal(unsigned char* src, char* dst,</span>
<a href="#l90.207"></a><span id="l90.207">                                        int srclen, int lenused, int wraplen) {</span>
<a href="#l90.208"></a><span id="l90.208">   unsigned char *byte, *stop;</span>
<a href="#l90.209"></a><span id="l90.209">   unsigned char buf[3];</span>
<a href="#l90.210"></a><span id="l90.210" class="difflineminus">-  char *out;</span>
<a href="#l90.211"></a><span id="l90.211" class="difflineplus">+  char* out;</span>
<a href="#l90.212"></a><span id="l90.212">   unsigned long bits;</span>
<a href="#l90.213"></a><span id="l90.213">   int i, pad, len;</span>
<a href="#l90.214"></a><span id="l90.214"> </span>
<a href="#l90.215"></a><span id="l90.215">   len = 0;</span>
<a href="#l90.216"></a><span id="l90.216">   out = dst;</span>
<a href="#l90.217"></a><span id="l90.217">   stop = src + srclen;</span>
<a href="#l90.218"></a><span id="l90.218"> </span>
<a href="#l90.219"></a><span id="l90.219">   /* convert to base 64 (3 bytes =&gt; 4 base 64 digits) */</span>
<a href="#l90.220"></a><span id="l90.220" class="difflineat">@@ -460,60 +460,60 @@ static int ldif_base64_encode_internal(u</span>
<a href="#l90.221"></a><span id="l90.221">     }</span>
<a href="#l90.222"></a><span id="l90.222">   }</span>
<a href="#l90.223"></a><span id="l90.223"> </span>
<a href="#l90.224"></a><span id="l90.224">   *out = '\0';</span>
<a href="#l90.225"></a><span id="l90.225"> </span>
<a href="#l90.226"></a><span id="l90.226">   return (out - dst);</span>
<a href="#l90.227"></a><span id="l90.227"> }</span>
<a href="#l90.228"></a><span id="l90.228"> </span>
<a href="#l90.229"></a><span id="l90.229" class="difflineminus">-int ldif_base64_encode(unsigned char *src, char *dst, int srclen, int lenused) {</span>
<a href="#l90.230"></a><span id="l90.230" class="difflineplus">+int ldif_base64_encode(unsigned char* src, char* dst, int srclen, int lenused) {</span>
<a href="#l90.231"></a><span id="l90.231">   return ldif_base64_encode_internal(src, dst, srclen, lenused,</span>
<a href="#l90.232"></a><span id="l90.232">                                      LDIF_MAX_LINE_WIDTH);</span>
<a href="#l90.233"></a><span id="l90.233"> }</span>
<a href="#l90.234"></a><span id="l90.234"> </span>
<a href="#l90.235"></a><span id="l90.235" class="difflineminus">-int ldif_base64_encode_nowrap(unsigned char *src, char *dst, int srclen,</span>
<a href="#l90.236"></a><span id="l90.236" class="difflineplus">+int ldif_base64_encode_nowrap(unsigned char* src, char* dst, int srclen,</span>
<a href="#l90.237"></a><span id="l90.237">                               int lenused) {</span>
<a href="#l90.238"></a><span id="l90.238">   return ldif_base64_encode_internal(src, dst, srclen, lenused, -1);</span>
<a href="#l90.239"></a><span id="l90.239"> }</span>
<a href="#l90.240"></a><span id="l90.240"> </span>
<a href="#l90.241"></a><span id="l90.241"> /*</span>
<a href="#l90.242"></a><span id="l90.242">  * return malloc'd, zero-terminated LDIF line</span>
<a href="#l90.243"></a><span id="l90.243">  */</span>
<a href="#l90.244"></a><span id="l90.244" class="difflineminus">-char *ldif_type_and_value_with_options(char *type, char *val, int vlen,</span>
<a href="#l90.245"></a><span id="l90.245" class="difflineplus">+char* ldif_type_and_value_with_options(char* type, char* val, int vlen,</span>
<a href="#l90.246"></a><span id="l90.246">                                        unsigned long options) {</span>
<a href="#l90.247"></a><span id="l90.247">   char *buf, *p;</span>
<a href="#l90.248"></a><span id="l90.248">   int tlen;</span>
<a href="#l90.249"></a><span id="l90.249"> </span>
<a href="#l90.250"></a><span id="l90.250">   tlen = strlen(type);</span>
<a href="#l90.251"></a><span id="l90.251" class="difflineminus">-  if ((buf = (char *)malloc(LDIF_SIZE_NEEDED(tlen, vlen) + 1)) != NULL) {</span>
<a href="#l90.252"></a><span id="l90.252" class="difflineplus">+  if ((buf = (char*)malloc(LDIF_SIZE_NEEDED(tlen, vlen) + 1)) != NULL) {</span>
<a href="#l90.253"></a><span id="l90.253">     p = buf;</span>
<a href="#l90.254"></a><span id="l90.254">     ldif_put_type_and_value_with_options(&amp;p, type, val, vlen, options);</span>
<a href="#l90.255"></a><span id="l90.255">     *p = '\0';</span>
<a href="#l90.256"></a><span id="l90.256">   }</span>
<a href="#l90.257"></a><span id="l90.257"> </span>
<a href="#l90.258"></a><span id="l90.258">   return (buf);</span>
<a href="#l90.259"></a><span id="l90.259"> }</span>
<a href="#l90.260"></a><span id="l90.260"> </span>
<a href="#l90.261"></a><span id="l90.261" class="difflineminus">-char *ldif_type_and_value(char *type, char *val, int vlen) {</span>
<a href="#l90.262"></a><span id="l90.262" class="difflineplus">+char* ldif_type_and_value(char* type, char* val, int vlen) {</span>
<a href="#l90.263"></a><span id="l90.263">   return ldif_type_and_value_with_options(type, val, vlen, 0);</span>
<a href="#l90.264"></a><span id="l90.264"> }</span>
<a href="#l90.265"></a><span id="l90.265"> </span>
<a href="#l90.266"></a><span id="l90.266" class="difflineminus">-char *ldif_type_and_value_nowrap(char *type, char *val, int vlen) {</span>
<a href="#l90.267"></a><span id="l90.267" class="difflineplus">+char* ldif_type_and_value_nowrap(char* type, char* val, int vlen) {</span>
<a href="#l90.268"></a><span id="l90.268">   return ldif_type_and_value_with_options(type, val, vlen, LDIF_OPT_NOWRAP);</span>
<a href="#l90.269"></a><span id="l90.269"> }</span>
<a href="#l90.270"></a><span id="l90.270"> </span>
<a href="#l90.271"></a><span id="l90.271"> /*</span>
<a href="#l90.272"></a><span id="l90.272">  * ldif_get_entry - read the next ldif entry from the FILE referenced</span>
<a href="#l90.273"></a><span id="l90.273">  * by fp. return a pointer to a malloc'd, null-terminated buffer. also</span>
<a href="#l90.274"></a><span id="l90.274">  * returned is the last line number read, in *lineno.</span>
<a href="#l90.275"></a><span id="l90.275">  */</span>
<a href="#l90.276"></a><span id="l90.276" class="difflineminus">-char *ldif_get_entry(FILE *fp, int *lineno) {</span>
<a href="#l90.277"></a><span id="l90.277" class="difflineplus">+char* ldif_get_entry(FILE* fp, int* lineno) {</span>
<a href="#l90.278"></a><span id="l90.278">   char line[BUFSIZ];</span>
<a href="#l90.279"></a><span id="l90.279" class="difflineminus">-  char *buf;</span>
<a href="#l90.280"></a><span id="l90.280" class="difflineplus">+  char* buf;</span>
<a href="#l90.281"></a><span id="l90.281">   int max, cur, len, gotsome;</span>
<a href="#l90.282"></a><span id="l90.282"> </span>
<a href="#l90.283"></a><span id="l90.283">   buf = NULL;</span>
<a href="#l90.284"></a><span id="l90.284">   max = cur = gotsome = 0;</span>
<a href="#l90.285"></a><span id="l90.285">   while (fgets(line, sizeof(line), fp) != NULL) {</span>
<a href="#l90.286"></a><span id="l90.286">     if (lineno != NULL) {</span>
<a href="#l90.287"></a><span id="l90.287">       (*lineno)++;</span>
<a href="#l90.288"></a><span id="l90.288">     }</span>
<a href="#l90.289"></a><span id="l90.289" class="difflineat">@@ -542,20 +542,20 @@ char *ldif_get_entry(FILE *fp, int *line</span>
<a href="#l90.290"></a><span id="l90.290">       --len;</span>
<a href="#l90.291"></a><span id="l90.291">       line[len - 1] = line[len];</span>
<a href="#l90.292"></a><span id="l90.292">       line[len] = '\0';</span>
<a href="#l90.293"></a><span id="l90.293">     }</span>
<a href="#l90.294"></a><span id="l90.294"> #endif</span>
<a href="#l90.295"></a><span id="l90.295">     while (cur + (len + 1) &gt; max) {</span>
<a href="#l90.296"></a><span id="l90.296">       if (buf == NULL) {</span>
<a href="#l90.297"></a><span id="l90.297">         max += BUFSIZ;</span>
<a href="#l90.298"></a><span id="l90.298" class="difflineminus">-        buf = (char *)malloc(max);</span>
<a href="#l90.299"></a><span id="l90.299" class="difflineplus">+        buf = (char*)malloc(max);</span>
<a href="#l90.300"></a><span id="l90.300">       } else {</span>
<a href="#l90.301"></a><span id="l90.301">         max *= 2;</span>
<a href="#l90.302"></a><span id="l90.302" class="difflineminus">-        buf = (char *)realloc(buf, max);</span>
<a href="#l90.303"></a><span id="l90.303" class="difflineplus">+        buf = (char*)realloc(buf, max);</span>
<a href="#l90.304"></a><span id="l90.304">       }</span>
<a href="#l90.305"></a><span id="l90.305">       if (buf == NULL) {</span>
<a href="#l90.306"></a><span id="l90.306">         return (NULL);</span>
<a href="#l90.307"></a><span id="l90.307">       }</span>
<a href="#l90.308"></a><span id="l90.308">     }</span>
<a href="#l90.309"></a><span id="l90.309"> </span>
<a href="#l90.310"></a><span id="l90.310">     memcpy(buf + cur, line, len + 1);</span>
<a href="#l90.311"></a><span id="l90.311">     cur += len;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l91.1"></a><span id="l91.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libprldap/ldappr-dns.c</span>
<a href="#l91.2"></a><span id="l91.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libprldap/ldappr-dns.c</span>
<a href="#l91.3"></a><span id="l91.3" class="difflineat">@@ -38,66 +38,66 @@</span>
<a href="#l91.4"></a><span id="l91.4"> /*</span>
<a href="#l91.5"></a><span id="l91.5">  * DNS callback functions for libldap that use the NSPR (Netscape</span>
<a href="#l91.6"></a><span id="l91.6">  * Portable Runtime) thread API.</span>
<a href="#l91.7"></a><span id="l91.7">  *</span>
<a href="#l91.8"></a><span id="l91.8">  */</span>
<a href="#l91.9"></a><span id="l91.9"> </span>
<a href="#l91.10"></a><span id="l91.10"> #include &quot;ldappr-int.h&quot;</span>
<a href="#l91.11"></a><span id="l91.11"> </span>
<a href="#l91.12"></a><span id="l91.12" class="difflineminus">-static LDAPHostEnt *prldap_gethostbyname(const char *name, LDAPHostEnt *result,</span>
<a href="#l91.13"></a><span id="l91.13" class="difflineminus">-                                         char *buffer, int buflen, int *statusp,</span>
<a href="#l91.14"></a><span id="l91.14" class="difflineminus">-                                         void *extradata);</span>
<a href="#l91.15"></a><span id="l91.15" class="difflineminus">-static LDAPHostEnt *prldap_gethostbyaddr(const char *addr, int length, int type,</span>
<a href="#l91.16"></a><span id="l91.16" class="difflineminus">-                                         LDAPHostEnt *result, char *buffer,</span>
<a href="#l91.17"></a><span id="l91.17" class="difflineminus">-                                         int buflen, int *statusp,</span>
<a href="#l91.18"></a><span id="l91.18" class="difflineminus">-                                         void *extradata);</span>
<a href="#l91.19"></a><span id="l91.19" class="difflineminus">-static int prldap_getpeername(LDAP *ld, struct sockaddr *addr, char *buffer,</span>
<a href="#l91.20"></a><span id="l91.20" class="difflineplus">+static LDAPHostEnt* prldap_gethostbyname(const char* name, LDAPHostEnt* result,</span>
<a href="#l91.21"></a><span id="l91.21" class="difflineplus">+                                         char* buffer, int buflen, int* statusp,</span>
<a href="#l91.22"></a><span id="l91.22" class="difflineplus">+                                         void* extradata);</span>
<a href="#l91.23"></a><span id="l91.23" class="difflineplus">+static LDAPHostEnt* prldap_gethostbyaddr(const char* addr, int length, int type,</span>
<a href="#l91.24"></a><span id="l91.24" class="difflineplus">+                                         LDAPHostEnt* result, char* buffer,</span>
<a href="#l91.25"></a><span id="l91.25" class="difflineplus">+                                         int buflen, int* statusp,</span>
<a href="#l91.26"></a><span id="l91.26" class="difflineplus">+                                         void* extradata);</span>
<a href="#l91.27"></a><span id="l91.27" class="difflineplus">+static int prldap_getpeername(LDAP* ld, struct sockaddr* addr, char* buffer,</span>
<a href="#l91.28"></a><span id="l91.28">                               int buflen);</span>
<a href="#l91.29"></a><span id="l91.29" class="difflineminus">-static LDAPHostEnt *prldap_convert_hostent(LDAPHostEnt *ldhp, PRHostEnt *prhp);</span>
<a href="#l91.30"></a><span id="l91.30" class="difflineplus">+static LDAPHostEnt* prldap_convert_hostent(LDAPHostEnt* ldhp, PRHostEnt* prhp);</span>
<a href="#l91.31"></a><span id="l91.31"> </span>
<a href="#l91.32"></a><span id="l91.32"> /*</span>
<a href="#l91.33"></a><span id="l91.33">  * Install NSPR DNS functions into ld (if ld is NULL, they are installed</span>
<a href="#l91.34"></a><span id="l91.34">  * as the default functions for new LDAP * handles).</span>
<a href="#l91.35"></a><span id="l91.35">  *</span>
<a href="#l91.36"></a><span id="l91.36">  * Returns 0 if all goes well and -1 if not.</span>
<a href="#l91.37"></a><span id="l91.37">  */</span>
<a href="#l91.38"></a><span id="l91.38" class="difflineminus">-int prldap_install_dns_functions(LDAP *ld) {</span>
<a href="#l91.39"></a><span id="l91.39" class="difflineplus">+int prldap_install_dns_functions(LDAP* ld) {</span>
<a href="#l91.40"></a><span id="l91.40">   struct ldap_dns_fns dnsfns;</span>
<a href="#l91.41"></a><span id="l91.41"> </span>
<a href="#l91.42"></a><span id="l91.42">   memset(&amp;dnsfns, '\0', sizeof(struct ldap_dns_fns));</span>
<a href="#l91.43"></a><span id="l91.43">   dnsfns.lddnsfn_bufsize = PR_NETDB_BUF_SIZE;</span>
<a href="#l91.44"></a><span id="l91.44">   dnsfns.lddnsfn_gethostbyname = prldap_gethostbyname;</span>
<a href="#l91.45"></a><span id="l91.45">   dnsfns.lddnsfn_gethostbyaddr = prldap_gethostbyaddr;</span>
<a href="#l91.46"></a><span id="l91.46">   dnsfns.lddnsfn_getpeername = prldap_getpeername;</span>
<a href="#l91.47"></a><span id="l91.47" class="difflineminus">-  if (ldap_set_option(ld, LDAP_OPT_DNS_FN_PTRS, (void *)&amp;dnsfns) != 0) {</span>
<a href="#l91.48"></a><span id="l91.48" class="difflineplus">+  if (ldap_set_option(ld, LDAP_OPT_DNS_FN_PTRS, (void*)&amp;dnsfns) != 0) {</span>
<a href="#l91.49"></a><span id="l91.49">     return (-1);</span>
<a href="#l91.50"></a><span id="l91.50">   }</span>
<a href="#l91.51"></a><span id="l91.51"> </span>
<a href="#l91.52"></a><span id="l91.52">   return (0);</span>
<a href="#l91.53"></a><span id="l91.53"> }</span>
<a href="#l91.54"></a><span id="l91.54"> </span>
<a href="#l91.55"></a><span id="l91.55" class="difflineminus">-static LDAPHostEnt *prldap_gethostbyname(const char *name, LDAPHostEnt *result,</span>
<a href="#l91.56"></a><span id="l91.56" class="difflineminus">-                                         char *buffer, int buflen, int *statusp,</span>
<a href="#l91.57"></a><span id="l91.57" class="difflineminus">-                                         void *extradata) {</span>
<a href="#l91.58"></a><span id="l91.58" class="difflineplus">+static LDAPHostEnt* prldap_gethostbyname(const char* name, LDAPHostEnt* result,</span>
<a href="#l91.59"></a><span id="l91.59" class="difflineplus">+                                         char* buffer, int buflen, int* statusp,</span>
<a href="#l91.60"></a><span id="l91.60" class="difflineplus">+                                         void* extradata) {</span>
<a href="#l91.61"></a><span id="l91.61">   PRHostEnt prhent;</span>
<a href="#l91.62"></a><span id="l91.62"> </span>
<a href="#l91.63"></a><span id="l91.63">   if (!statusp || (*statusp = (int)PR_GetIPNodeByName(</span>
<a href="#l91.64"></a><span id="l91.64">                        name, PRLDAP_DEFAULT_ADDRESS_FAMILY, PR_AI_DEFAULT,</span>
<a href="#l91.65"></a><span id="l91.65">                        buffer, buflen, &amp;prhent)) == PR_FAILURE) {</span>
<a href="#l91.66"></a><span id="l91.66">     return (NULL);</span>
<a href="#l91.67"></a><span id="l91.67">   }</span>
<a href="#l91.68"></a><span id="l91.68"> </span>
<a href="#l91.69"></a><span id="l91.69">   return (prldap_convert_hostent(result, &amp;prhent));</span>
<a href="#l91.70"></a><span id="l91.70"> }</span>
<a href="#l91.71"></a><span id="l91.71"> </span>
<a href="#l91.72"></a><span id="l91.72" class="difflineminus">-static LDAPHostEnt *prldap_gethostbyaddr(const char *addr, int length, int type,</span>
<a href="#l91.73"></a><span id="l91.73" class="difflineminus">-                                         LDAPHostEnt *result, char *buffer,</span>
<a href="#l91.74"></a><span id="l91.74" class="difflineminus">-                                         int buflen, int *statusp,</span>
<a href="#l91.75"></a><span id="l91.75" class="difflineminus">-                                         void *extradata) {</span>
<a href="#l91.76"></a><span id="l91.76" class="difflineplus">+static LDAPHostEnt* prldap_gethostbyaddr(const char* addr, int length, int type,</span>
<a href="#l91.77"></a><span id="l91.77" class="difflineplus">+                                         LDAPHostEnt* result, char* buffer,</span>
<a href="#l91.78"></a><span id="l91.78" class="difflineplus">+                                         int buflen, int* statusp,</span>
<a href="#l91.79"></a><span id="l91.79" class="difflineplus">+                                         void* extradata) {</span>
<a href="#l91.80"></a><span id="l91.80">   PRHostEnt prhent;</span>
<a href="#l91.81"></a><span id="l91.81">   PRNetAddr iaddr;</span>
<a href="#l91.82"></a><span id="l91.82"> </span>
<a href="#l91.83"></a><span id="l91.83">   if (NULL == statusp) {</span>
<a href="#l91.84"></a><span id="l91.84">     return (NULL);</span>
<a href="#l91.85"></a><span id="l91.85">   }</span>
<a href="#l91.86"></a><span id="l91.86"> </span>
<a href="#l91.87"></a><span id="l91.87">   memset(&amp;iaddr, 0, sizeof(iaddr));</span>
<a href="#l91.88"></a><span id="l91.88" class="difflineat">@@ -109,46 +109,46 @@ static LDAPHostEnt *prldap_gethostbyaddr</span>
<a href="#l91.89"></a><span id="l91.89">   if (PR_FAILURE ==</span>
<a href="#l91.90"></a><span id="l91.90">       (*statusp = PR_GetHostByAddr(&amp;iaddr, buffer, buflen, &amp;prhent))) {</span>
<a href="#l91.91"></a><span id="l91.91">     return (NULL);</span>
<a href="#l91.92"></a><span id="l91.92">   }</span>
<a href="#l91.93"></a><span id="l91.93"> </span>
<a href="#l91.94"></a><span id="l91.94">   return (prldap_convert_hostent(result, &amp;prhent));</span>
<a href="#l91.95"></a><span id="l91.95"> }</span>
<a href="#l91.96"></a><span id="l91.96"> </span>
<a href="#l91.97"></a><span id="l91.97" class="difflineminus">-static int prldap_getpeername(LDAP *ld, struct sockaddr *addr, char *buffer,</span>
<a href="#l91.98"></a><span id="l91.98" class="difflineplus">+static int prldap_getpeername(LDAP* ld, struct sockaddr* addr, char* buffer,</span>
<a href="#l91.99"></a><span id="l91.99">                               int buflen) {</span>
<a href="#l91.100"></a><span id="l91.100" class="difflineminus">-  PRLDAPIOSocketArg *sa;</span>
<a href="#l91.101"></a><span id="l91.101" class="difflineplus">+  PRLDAPIOSocketArg* sa;</span>
<a href="#l91.102"></a><span id="l91.102">   PRNetAddr iaddr;</span>
<a href="#l91.103"></a><span id="l91.103">   int ret;</span>
<a href="#l91.104"></a><span id="l91.104"> </span>
<a href="#l91.105"></a><span id="l91.105">   if (NULL != ld) {</span>
<a href="#l91.106"></a><span id="l91.106">     ret = prldap_socket_arg_from_ld(ld, &amp;sa);</span>
<a href="#l91.107"></a><span id="l91.107">     if (ret != LDAP_SUCCESS) {</span>
<a href="#l91.108"></a><span id="l91.108">       return (-1);</span>
<a href="#l91.109"></a><span id="l91.109">     }</span>
<a href="#l91.110"></a><span id="l91.110">     ret = PR_GetPeerName(sa-&gt;prsock_prfd, &amp;iaddr);</span>
<a href="#l91.111"></a><span id="l91.111">     if (ret == PR_FAILURE) {</span>
<a href="#l91.112"></a><span id="l91.112">       return (-1);</span>
<a href="#l91.113"></a><span id="l91.113">     }</span>
<a href="#l91.114"></a><span id="l91.114" class="difflineminus">-    *addr = *((struct sockaddr *)&amp;iaddr.raw);</span>
<a href="#l91.115"></a><span id="l91.115" class="difflineplus">+    *addr = *((struct sockaddr*)&amp;iaddr.raw);</span>
<a href="#l91.116"></a><span id="l91.116">     ret = PR_NetAddrToString(&amp;iaddr, buffer, buflen);</span>
<a href="#l91.117"></a><span id="l91.117">     if (ret == PR_FAILURE) {</span>
<a href="#l91.118"></a><span id="l91.118">       return (-1);</span>
<a href="#l91.119"></a><span id="l91.119">     }</span>
<a href="#l91.120"></a><span id="l91.120">     return (0);</span>
<a href="#l91.121"></a><span id="l91.121">   }</span>
<a href="#l91.122"></a><span id="l91.122">   return (-1);</span>
<a href="#l91.123"></a><span id="l91.123"> }</span>
<a href="#l91.124"></a><span id="l91.124"> </span>
<a href="#l91.125"></a><span id="l91.125"> /*</span>
<a href="#l91.126"></a><span id="l91.126">  * Function: prldap_convert_hostent()</span>
<a href="#l91.127"></a><span id="l91.127">  * Description: copy the fields of a PRHostEnt struct to an LDAPHostEnt</span>
<a href="#l91.128"></a><span id="l91.128">  * Returns: the LDAPHostEnt pointer passed in.</span>
<a href="#l91.129"></a><span id="l91.129">  */</span>
<a href="#l91.130"></a><span id="l91.130" class="difflineminus">-static LDAPHostEnt *prldap_convert_hostent(LDAPHostEnt *ldhp, PRHostEnt *prhp) {</span>
<a href="#l91.131"></a><span id="l91.131" class="difflineplus">+static LDAPHostEnt* prldap_convert_hostent(LDAPHostEnt* ldhp, PRHostEnt* prhp) {</span>
<a href="#l91.132"></a><span id="l91.132">   ldhp-&gt;ldaphe_name = prhp-&gt;h_name;</span>
<a href="#l91.133"></a><span id="l91.133">   ldhp-&gt;ldaphe_aliases = prhp-&gt;h_aliases;</span>
<a href="#l91.134"></a><span id="l91.134">   ldhp-&gt;ldaphe_addrtype = prhp-&gt;h_addrtype;</span>
<a href="#l91.135"></a><span id="l91.135">   ldhp-&gt;ldaphe_length = prhp-&gt;h_length;</span>
<a href="#l91.136"></a><span id="l91.136">   ldhp-&gt;ldaphe_addr_list = prhp-&gt;h_addr_list;</span>
<a href="#l91.137"></a><span id="l91.137">   return (ldhp);</span>
<a href="#l91.138"></a><span id="l91.138"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l92.1"></a><span id="l92.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libprldap/ldappr-int.h</span>
<a href="#l92.2"></a><span id="l92.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libprldap/ldappr-int.h</span>
<a href="#l92.3"></a><span id="l92.3" class="difflineat">@@ -83,53 +83,53 @@</span>
<a href="#l92.4"></a><span id="l92.4">        : ((myaddr)-&gt;inet.port = PR_htons(myport)))</span>
<a href="#l92.5"></a><span id="l92.5"> </span>
<a href="#l92.6"></a><span id="l92.6"> /*</span>
<a href="#l92.7"></a><span id="l92.7">  * Data structures:</span>
<a href="#l92.8"></a><span id="l92.8">  */</span>
<a href="#l92.9"></a><span id="l92.9"> </span>
<a href="#l92.10"></a><span id="l92.10"> /* data structure that populates the I/O callback session arg. */</span>
<a href="#l92.11"></a><span id="l92.11"> typedef struct lextiof_session_private {</span>
<a href="#l92.12"></a><span id="l92.12" class="difflineminus">-  PRPollDesc *prsess_pollds; /* for poll callback */</span>
<a href="#l92.13"></a><span id="l92.13" class="difflineplus">+  PRPollDesc* prsess_pollds; /* for poll callback */</span>
<a href="#l92.14"></a><span id="l92.14">   int prsess_pollds_count;   /* # of elements in pollds */</span>
<a href="#l92.15"></a><span id="l92.15">   int prsess_io_max_timeout; /* in milliseconds */</span>
<a href="#l92.16"></a><span id="l92.16" class="difflineminus">-  void *prsess_appdata;      /* application specific data */</span>
<a href="#l92.17"></a><span id="l92.17" class="difflineplus">+  void* prsess_appdata;      /* application specific data */</span>
<a href="#l92.18"></a><span id="l92.18"> } PRLDAPIOSessionArg;</span>
<a href="#l92.19"></a><span id="l92.19"> </span>
<a href="#l92.20"></a><span id="l92.20"> /* data structure that populates the I/O callback socket-specific arg. */</span>
<a href="#l92.21"></a><span id="l92.21"> typedef struct lextiof_socket_private {</span>
<a href="#l92.22"></a><span id="l92.22" class="difflineminus">-  PRFileDesc *prsock_prfd;   /* associated NSPR file desc. */</span>
<a href="#l92.23"></a><span id="l92.23" class="difflineplus">+  PRFileDesc* prsock_prfd;   /* associated NSPR file desc. */</span>
<a href="#l92.24"></a><span id="l92.24">   int prsock_io_max_timeout; /* in milliseconds */</span>
<a href="#l92.25"></a><span id="l92.25" class="difflineminus">-  void *prsock_appdata;      /* application specific data */</span>
<a href="#l92.26"></a><span id="l92.26" class="difflineplus">+  void* prsock_appdata;      /* application specific data */</span>
<a href="#l92.27"></a><span id="l92.27"> } PRLDAPIOSocketArg;</span>
<a href="#l92.28"></a><span id="l92.28"> </span>
<a href="#l92.29"></a><span id="l92.29"> /*</span>
<a href="#l92.30"></a><span id="l92.30">  * Function prototypes:</span>
<a href="#l92.31"></a><span id="l92.31">  */</span>
<a href="#l92.32"></a><span id="l92.32"> </span>
<a href="#l92.33"></a><span id="l92.33"> /*</span>
<a href="#l92.34"></a><span id="l92.34">  * From ldapprio.c:</span>
<a href="#l92.35"></a><span id="l92.35">  */</span>
<a href="#l92.36"></a><span id="l92.36" class="difflineminus">-int prldap_install_io_functions(LDAP *ld, int shared);</span>
<a href="#l92.37"></a><span id="l92.37" class="difflineminus">-int prldap_session_arg_from_ld(LDAP *ld, PRLDAPIOSessionArg **sessargpp);</span>
<a href="#l92.38"></a><span id="l92.38" class="difflineminus">-int prldap_set_io_max_timeout(PRLDAPIOSessionArg *prsessp, int io_max_timeout);</span>
<a href="#l92.39"></a><span id="l92.39" class="difflineminus">-int prldap_get_io_max_timeout(PRLDAPIOSessionArg *prsessp,</span>
<a href="#l92.40"></a><span id="l92.40" class="difflineminus">-                              int *io_max_timeoutp);</span>
<a href="#l92.41"></a><span id="l92.41" class="difflineminus">-int prldap_socket_arg_from_ld(LDAP *ld, PRLDAPIOSocketArg **sockargpp);</span>
<a href="#l92.42"></a><span id="l92.42" class="difflineminus">-PRLDAPIOSocketArg *prldap_socket_arg_alloc(PRLDAPIOSessionArg *sessionarg);</span>
<a href="#l92.43"></a><span id="l92.43" class="difflineplus">+int prldap_install_io_functions(LDAP* ld, int shared);</span>
<a href="#l92.44"></a><span id="l92.44" class="difflineplus">+int prldap_session_arg_from_ld(LDAP* ld, PRLDAPIOSessionArg** sessargpp);</span>
<a href="#l92.45"></a><span id="l92.45" class="difflineplus">+int prldap_set_io_max_timeout(PRLDAPIOSessionArg* prsessp, int io_max_timeout);</span>
<a href="#l92.46"></a><span id="l92.46" class="difflineplus">+int prldap_get_io_max_timeout(PRLDAPIOSessionArg* prsessp,</span>
<a href="#l92.47"></a><span id="l92.47" class="difflineplus">+                              int* io_max_timeoutp);</span>
<a href="#l92.48"></a><span id="l92.48" class="difflineplus">+int prldap_socket_arg_from_ld(LDAP* ld, PRLDAPIOSocketArg** sockargpp);</span>
<a href="#l92.49"></a><span id="l92.49" class="difflineplus">+PRLDAPIOSocketArg* prldap_socket_arg_alloc(PRLDAPIOSessionArg* sessionarg);</span>
<a href="#l92.50"></a><span id="l92.50"> </span>
<a href="#l92.51"></a><span id="l92.51"> /*</span>
<a href="#l92.52"></a><span id="l92.52">  * From ldapprthreads.c:</span>
<a href="#l92.53"></a><span id="l92.53">  */</span>
<a href="#l92.54"></a><span id="l92.54" class="difflineminus">-int prldap_install_thread_functions(LDAP *ld, int shared);</span>
<a href="#l92.55"></a><span id="l92.55" class="difflineminus">-int prldap_thread_new_handle(LDAP *ld, void *sessionarg);</span>
<a href="#l92.56"></a><span id="l92.56" class="difflineminus">-void prldap_thread_dispose_handle(LDAP *ld, void *sessionarg);</span>
<a href="#l92.57"></a><span id="l92.57" class="difflineplus">+int prldap_install_thread_functions(LDAP* ld, int shared);</span>
<a href="#l92.58"></a><span id="l92.58" class="difflineplus">+int prldap_thread_new_handle(LDAP* ld, void* sessionarg);</span>
<a href="#l92.59"></a><span id="l92.59" class="difflineplus">+void prldap_thread_dispose_handle(LDAP* ld, void* sessionarg);</span>
<a href="#l92.60"></a><span id="l92.60"> </span>
<a href="#l92.61"></a><span id="l92.61"> /*</span>
<a href="#l92.62"></a><span id="l92.62">  * From ldapprdns.c:</span>
<a href="#l92.63"></a><span id="l92.63">  */</span>
<a href="#l92.64"></a><span id="l92.64" class="difflineminus">-int prldap_install_dns_functions(LDAP *ld);</span>
<a href="#l92.65"></a><span id="l92.65" class="difflineplus">+int prldap_install_dns_functions(LDAP* ld);</span>
<a href="#l92.66"></a><span id="l92.66"> </span>
<a href="#l92.67"></a><span id="l92.67"> /*</span>
<a href="#l92.68"></a><span id="l92.68">  * From ldapprerror.c:</span>
<a href="#l92.69"></a><span id="l92.69">  */</span>
<a href="#l92.70"></a><span id="l92.70"> void prldap_set_errno(int e);</span>
<a href="#l92.71"></a><span id="l92.71"> int prldap_get_errno(void);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l93.1"></a><span id="l93.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libprldap/ldappr-io.c</span>
<a href="#l93.2"></a><span id="l93.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libprldap/ldappr-io.c</span>
<a href="#l93.3"></a><span id="l93.3" class="difflineat">@@ -48,61 +48,61 @@</span>
<a href="#l93.4"></a><span id="l93.4"> #include &quot;ldappr-int.h&quot;</span>
<a href="#l93.5"></a><span id="l93.5"> </span>
<a href="#l93.6"></a><span id="l93.6"> #define PRLDAP_POLL_ARRAY_GROWTH 5 /* grow arrays 5 elements at a time */</span>
<a href="#l93.7"></a><span id="l93.7"> </span>
<a href="#l93.8"></a><span id="l93.8"> /*</span>
<a href="#l93.9"></a><span id="l93.9">  * Local function prototypes:</span>
<a href="#l93.10"></a><span id="l93.10">  */</span>
<a href="#l93.11"></a><span id="l93.11"> static PRIntervalTime prldap_timeout2it(int ms_timeout, int ms_maxtimeout);</span>
<a href="#l93.12"></a><span id="l93.12" class="difflineminus">-static int LDAP_CALLBACK prldap_read(int s, void *buf, int bufsize,</span>
<a href="#l93.13"></a><span id="l93.13" class="difflineminus">-                                     struct lextiof_socket_private *socketarg);</span>
<a href="#l93.14"></a><span id="l93.14" class="difflineminus">-static int LDAP_CALLBACK prldap_write(int s, const void *buf, int len,</span>
<a href="#l93.15"></a><span id="l93.15" class="difflineminus">-                                      struct lextiof_socket_private *socketarg);</span>
<a href="#l93.16"></a><span id="l93.16" class="difflineplus">+static int LDAP_CALLBACK prldap_read(int s, void* buf, int bufsize,</span>
<a href="#l93.17"></a><span id="l93.17" class="difflineplus">+                                     struct lextiof_socket_private* socketarg);</span>
<a href="#l93.18"></a><span id="l93.18" class="difflineplus">+static int LDAP_CALLBACK prldap_write(int s, const void* buf, int len,</span>
<a href="#l93.19"></a><span id="l93.19" class="difflineplus">+                                      struct lextiof_socket_private* socketarg);</span>
<a href="#l93.20"></a><span id="l93.20"> static int LDAP_CALLBACK</span>
<a href="#l93.21"></a><span id="l93.21"> prldap_poll(LDAP_X_PollFD fds[], int nfds, int timeout,</span>
<a href="#l93.22"></a><span id="l93.22" class="difflineminus">-            struct lextiof_session_private *sessionarg);</span>
<a href="#l93.23"></a><span id="l93.23" class="difflineplus">+            struct lextiof_session_private* sessionarg);</span>
<a href="#l93.24"></a><span id="l93.24"> static int LDAP_CALLBACK prldap_connect(</span>
<a href="#l93.25"></a><span id="l93.25" class="difflineminus">-    const char *hostlist, int defport, int timeout, unsigned long options,</span>
<a href="#l93.26"></a><span id="l93.26" class="difflineminus">-    struct lextiof_session_private *sessionarg,</span>
<a href="#l93.27"></a><span id="l93.27" class="difflineminus">-    struct lextiof_socket_private **socketargp);</span>
<a href="#l93.28"></a><span id="l93.28" class="difflineplus">+    const char* hostlist, int defport, int timeout, unsigned long options,</span>
<a href="#l93.29"></a><span id="l93.29" class="difflineplus">+    struct lextiof_session_private* sessionarg,</span>
<a href="#l93.30"></a><span id="l93.30" class="difflineplus">+    struct lextiof_socket_private** socketargp);</span>
<a href="#l93.31"></a><span id="l93.31"> static int LDAP_CALLBACK prldap_close(int s,</span>
<a href="#l93.32"></a><span id="l93.32" class="difflineminus">-                                      struct lextiof_socket_private *socketarg);</span>
<a href="#l93.33"></a><span id="l93.33" class="difflineplus">+                                      struct lextiof_socket_private* socketarg);</span>
<a href="#l93.34"></a><span id="l93.34"> static int LDAP_CALLBACK</span>
<a href="#l93.35"></a><span id="l93.35" class="difflineminus">-prldap_newhandle(LDAP *ld, struct lextiof_session_private *sessionarg);</span>
<a href="#l93.36"></a><span id="l93.36" class="difflineplus">+prldap_newhandle(LDAP* ld, struct lextiof_session_private* sessionarg);</span>
<a href="#l93.37"></a><span id="l93.37"> static void LDAP_CALLBACK</span>
<a href="#l93.38"></a><span id="l93.38" class="difflineminus">-prldap_disposehandle(LDAP *ld, struct lextiof_session_private *sessionarg);</span>
<a href="#l93.39"></a><span id="l93.39" class="difflineplus">+prldap_disposehandle(LDAP* ld, struct lextiof_session_private* sessionarg);</span>
<a href="#l93.40"></a><span id="l93.40"> static int LDAP_CALLBACK</span>
<a href="#l93.41"></a><span id="l93.41" class="difflineminus">-prldap_shared_newhandle(LDAP *ld, struct lextiof_session_private *sessionarg);</span>
<a href="#l93.42"></a><span id="l93.42" class="difflineplus">+prldap_shared_newhandle(LDAP* ld, struct lextiof_session_private* sessionarg);</span>
<a href="#l93.43"></a><span id="l93.43"> static void LDAP_CALLBACK prldap_shared_disposehandle(</span>
<a href="#l93.44"></a><span id="l93.44" class="difflineminus">-    LDAP *ld, struct lextiof_session_private *sessionarg);</span>
<a href="#l93.45"></a><span id="l93.45" class="difflineminus">-static PRLDAPIOSessionArg *prldap_session_arg_alloc(void);</span>
<a href="#l93.46"></a><span id="l93.46" class="difflineminus">-static void prldap_session_arg_free(PRLDAPIOSessionArg **prsesspp);</span>
<a href="#l93.47"></a><span id="l93.47" class="difflineminus">-static void prldap_socket_arg_free(PRLDAPIOSocketArg **prsockpp);</span>
<a href="#l93.48"></a><span id="l93.48" class="difflineminus">-static void *prldap_safe_realloc(void *ptr, PRUint32 size);</span>
<a href="#l93.49"></a><span id="l93.49" class="difflineplus">+    LDAP* ld, struct lextiof_session_private* sessionarg);</span>
<a href="#l93.50"></a><span id="l93.50" class="difflineplus">+static PRLDAPIOSessionArg* prldap_session_arg_alloc(void);</span>
<a href="#l93.51"></a><span id="l93.51" class="difflineplus">+static void prldap_session_arg_free(PRLDAPIOSessionArg** prsesspp);</span>
<a href="#l93.52"></a><span id="l93.52" class="difflineplus">+static void prldap_socket_arg_free(PRLDAPIOSocketArg** prsockpp);</span>
<a href="#l93.53"></a><span id="l93.53" class="difflineplus">+static void* prldap_safe_realloc(void* ptr, PRUint32 size);</span>
<a href="#l93.54"></a><span id="l93.54"> </span>
<a href="#l93.55"></a><span id="l93.55"> /*</span>
<a href="#l93.56"></a><span id="l93.56">  * Local macros:</span>
<a href="#l93.57"></a><span id="l93.57">  */</span>
<a href="#l93.58"></a><span id="l93.58"> /* given a socket-specific arg, return the corresponding PRFileDesc * */</span>
<a href="#l93.59"></a><span id="l93.59"> #define PRLDAP_GET_PRFD(socketarg) \</span>
<a href="#l93.60"></a><span id="l93.60" class="difflineminus">-  (((PRLDAPIOSocketArg *)(socketarg))-&gt;prsock_prfd)</span>
<a href="#l93.61"></a><span id="l93.61" class="difflineplus">+  (((PRLDAPIOSocketArg*)(socketarg))-&gt;prsock_prfd)</span>
<a href="#l93.62"></a><span id="l93.62"> </span>
<a href="#l93.63"></a><span id="l93.63"> /*</span>
<a href="#l93.64"></a><span id="l93.64">  * Static variables.</span>
<a href="#l93.65"></a><span id="l93.65">  */</span>
<a href="#l93.66"></a><span id="l93.66"> static int prldap_default_io_max_timeout = LDAP_X_IO_TIMEOUT_NO_TIMEOUT;</span>
<a href="#l93.67"></a><span id="l93.67"> </span>
<a href="#l93.68"></a><span id="l93.68"> /*</span>
<a href="#l93.69"></a><span id="l93.69">  * Install NSPR I/O functions into ld (if ld is NULL, they are installed</span>
<a href="#l93.70"></a><span id="l93.70">  * as the default functions for new LDAP * handles).</span>
<a href="#l93.71"></a><span id="l93.71">  *</span>
<a href="#l93.72"></a><span id="l93.72">  * Returns 0 if all goes well and -1 if not.</span>
<a href="#l93.73"></a><span id="l93.73">  */</span>
<a href="#l93.74"></a><span id="l93.74" class="difflineminus">-int prldap_install_io_functions(LDAP *ld, int shared) {</span>
<a href="#l93.75"></a><span id="l93.75" class="difflineplus">+int prldap_install_io_functions(LDAP* ld, int shared) {</span>
<a href="#l93.76"></a><span id="l93.76">   struct ldap_x_ext_io_fns iofns;</span>
<a href="#l93.77"></a><span id="l93.77"> </span>
<a href="#l93.78"></a><span id="l93.78">   memset(&amp;iofns, 0, sizeof(iofns));</span>
<a href="#l93.79"></a><span id="l93.79">   iofns.lextiof_size = LDAP_X_EXTIO_FNS_SIZE;</span>
<a href="#l93.80"></a><span id="l93.80">   iofns.lextiof_read = prldap_read;</span>
<a href="#l93.81"></a><span id="l93.81">   iofns.lextiof_write = prldap_write;</span>
<a href="#l93.82"></a><span id="l93.82">   iofns.lextiof_poll = prldap_poll;</span>
<a href="#l93.83"></a><span id="l93.83">   iofns.lextiof_connect = prldap_connect;</span>
<a href="#l93.84"></a><span id="l93.84" class="difflineat">@@ -124,17 +124,17 @@ int prldap_install_io_functions(LDAP *ld</span>
<a href="#l93.85"></a><span id="l93.85">       ldap_set_lderrno(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l93.86"></a><span id="l93.86">       return (-1);</span>
<a href="#l93.87"></a><span id="l93.87">     }</span>
<a href="#l93.88"></a><span id="l93.88">   } else {</span>
<a href="#l93.89"></a><span id="l93.89">     iofns.lextiof_session_arg = NULL;</span>
<a href="#l93.90"></a><span id="l93.90">   }</span>
<a href="#l93.91"></a><span id="l93.91"> </span>
<a href="#l93.92"></a><span id="l93.92">   if (ldap_set_option(ld, LDAP_X_OPT_EXTIO_FN_PTRS, &amp;iofns) != 0) {</span>
<a href="#l93.93"></a><span id="l93.93" class="difflineminus">-    prldap_session_arg_free((PRLDAPIOSessionArg **)&amp;iofns.lextiof_session_arg);</span>
<a href="#l93.94"></a><span id="l93.94" class="difflineplus">+    prldap_session_arg_free((PRLDAPIOSessionArg**)&amp;iofns.lextiof_session_arg);</span>
<a href="#l93.95"></a><span id="l93.95">     return (-1);</span>
<a href="#l93.96"></a><span id="l93.96">   }</span>
<a href="#l93.97"></a><span id="l93.97"> </span>
<a href="#l93.98"></a><span id="l93.98">   return (0);</span>
<a href="#l93.99"></a><span id="l93.99"> }</span>
<a href="#l93.100"></a><span id="l93.100"> </span>
<a href="#l93.101"></a><span id="l93.101"> static PRIntervalTime prldap_timeout2it(int ms_timeout, int ms_maxtimeout) {</span>
<a href="#l93.102"></a><span id="l93.102">   PRIntervalTime prit;</span>
<a href="#l93.103"></a><span id="l93.103" class="difflineat">@@ -166,29 +166,29 @@ static PRIntervalTime prldap_timeout2it(</span>
<a href="#l93.104"></a><span id="l93.104">     fprintf(stderr, &quot;prldap_timeout2it: %dms\n&quot;,</span>
<a href="#l93.105"></a><span id="l93.105">             PR_IntervalToMilliseconds(prit));</span>
<a href="#l93.106"></a><span id="l93.106">   }</span>
<a href="#l93.107"></a><span id="l93.107"> #endif /* PRLDAP_DEBUG */</span>
<a href="#l93.108"></a><span id="l93.108"> </span>
<a href="#l93.109"></a><span id="l93.109">   return (prit);</span>
<a href="#l93.110"></a><span id="l93.110"> }</span>
<a href="#l93.111"></a><span id="l93.111"> </span>
<a href="#l93.112"></a><span id="l93.112" class="difflineminus">-static int LDAP_CALLBACK prldap_read(int s, void *buf, int bufsize,</span>
<a href="#l93.113"></a><span id="l93.113" class="difflineminus">-                                     struct lextiof_socket_private *socketarg) {</span>
<a href="#l93.114"></a><span id="l93.114" class="difflineplus">+static int LDAP_CALLBACK prldap_read(int s, void* buf, int bufsize,</span>
<a href="#l93.115"></a><span id="l93.115" class="difflineplus">+                                     struct lextiof_socket_private* socketarg) {</span>
<a href="#l93.116"></a><span id="l93.116">   PRIntervalTime prit;</span>
<a href="#l93.117"></a><span id="l93.117"> </span>
<a href="#l93.118"></a><span id="l93.118">   prit = prldap_timeout2it(LDAP_X_IO_TIMEOUT_NO_TIMEOUT,</span>
<a href="#l93.119"></a><span id="l93.119">                            socketarg-&gt;prsock_io_max_timeout);</span>
<a href="#l93.120"></a><span id="l93.120">   return (PR_Recv(PRLDAP_GET_PRFD(socketarg), buf, bufsize, 0, prit));</span>
<a href="#l93.121"></a><span id="l93.121"> }</span>
<a href="#l93.122"></a><span id="l93.122"> </span>
<a href="#l93.123"></a><span id="l93.123"> static int LDAP_CALLBACK prldap_write(</span>
<a href="#l93.124"></a><span id="l93.124" class="difflineminus">-    int s, const void *buf, int len, struct lextiof_socket_private *socketarg) {</span>
<a href="#l93.125"></a><span id="l93.125" class="difflineplus">+    int s, const void* buf, int len, struct lextiof_socket_private* socketarg) {</span>
<a href="#l93.126"></a><span id="l93.126">   PRIntervalTime prit;</span>
<a href="#l93.127"></a><span id="l93.127" class="difflineminus">-  char *ptr = (char *)buf;</span>
<a href="#l93.128"></a><span id="l93.128" class="difflineplus">+  char* ptr = (char*)buf;</span>
<a href="#l93.129"></a><span id="l93.129">   int rest = len;</span>
<a href="#l93.130"></a><span id="l93.130"> </span>
<a href="#l93.131"></a><span id="l93.131">   prit = prldap_timeout2it(LDAP_X_IO_TIMEOUT_NO_TIMEOUT,</span>
<a href="#l93.132"></a><span id="l93.132">                            socketarg-&gt;prsock_io_max_timeout);</span>
<a href="#l93.133"></a><span id="l93.133"> </span>
<a href="#l93.134"></a><span id="l93.134">   while (rest &gt; 0) {</span>
<a href="#l93.135"></a><span id="l93.135">     int rval;</span>
<a href="#l93.136"></a><span id="l93.136">     if (rest &gt; PRLDAP_MAX_SEND_SIZE) {</span>
<a href="#l93.137"></a><span id="l93.137" class="difflineat">@@ -208,17 +208,17 @@ static int LDAP_CALLBACK prldap_write(</span>
<a href="#l93.138"></a><span id="l93.138">     if (0 == rval) {</span>
<a href="#l93.139"></a><span id="l93.139">       break;</span>
<a href="#l93.140"></a><span id="l93.140">     }</span>
<a href="#l93.141"></a><span id="l93.141"> </span>
<a href="#l93.142"></a><span id="l93.142">     ptr += rval;</span>
<a href="#l93.143"></a><span id="l93.143">     rest -= rval;</span>
<a href="#l93.144"></a><span id="l93.144">   }</span>
<a href="#l93.145"></a><span id="l93.145"> </span>
<a href="#l93.146"></a><span id="l93.146" class="difflineminus">-  return (int)(ptr - (char *)buf);</span>
<a href="#l93.147"></a><span id="l93.147" class="difflineplus">+  return (int)(ptr - (char*)buf);</span>
<a href="#l93.148"></a><span id="l93.148"> }</span>
<a href="#l93.149"></a><span id="l93.149"> </span>
<a href="#l93.150"></a><span id="l93.150"> struct prldap_eventmap_entry {</span>
<a href="#l93.151"></a><span id="l93.151">   PRInt16 evm_nspr; /* corresponding NSPR PR_Poll() event */</span>
<a href="#l93.152"></a><span id="l93.152">   int evm_ldap;     /* LDAP poll event */</span>
<a href="#l93.153"></a><span id="l93.153"> };</span>
<a href="#l93.154"></a><span id="l93.154"> </span>
<a href="#l93.155"></a><span id="l93.155"> static struct prldap_eventmap_entry prldap_eventmap[] = {</span>
<a href="#l93.156"></a><span id="l93.156" class="difflineat">@@ -227,19 +227,19 @@ static struct prldap_eventmap_entry prld</span>
<a href="#l93.157"></a><span id="l93.157">     {PR_POLL_HUP, LDAP_X_POLLHUP},   {PR_POLL_NVAL, LDAP_X_POLLNVAL},</span>
<a href="#l93.158"></a><span id="l93.158"> };</span>
<a href="#l93.159"></a><span id="l93.159"> </span>
<a href="#l93.160"></a><span id="l93.160"> #define PRLDAP_EVENTMAP_ENTRIES \</span>
<a href="#l93.161"></a><span id="l93.161">   sizeof(prldap_eventmap) / sizeof(struct prldap_eventmap_entry)</span>
<a href="#l93.162"></a><span id="l93.162"> </span>
<a href="#l93.163"></a><span id="l93.163"> static int LDAP_CALLBACK</span>
<a href="#l93.164"></a><span id="l93.164"> prldap_poll(LDAP_X_PollFD fds[], int nfds, int timeout,</span>
<a href="#l93.165"></a><span id="l93.165" class="difflineminus">-            struct lextiof_session_private *sessionarg) {</span>
<a href="#l93.166"></a><span id="l93.166" class="difflineminus">-  PRLDAPIOSessionArg *prsessp = sessionarg;</span>
<a href="#l93.167"></a><span id="l93.167" class="difflineminus">-  PRPollDesc *pds;</span>
<a href="#l93.168"></a><span id="l93.168" class="difflineplus">+            struct lextiof_session_private* sessionarg) {</span>
<a href="#l93.169"></a><span id="l93.169" class="difflineplus">+  PRLDAPIOSessionArg* prsessp = sessionarg;</span>
<a href="#l93.170"></a><span id="l93.170" class="difflineplus">+  PRPollDesc* pds;</span>
<a href="#l93.171"></a><span id="l93.171">   int i, j, rc;</span>
<a href="#l93.172"></a><span id="l93.172"> </span>
<a href="#l93.173"></a><span id="l93.173">   if (NULL == prsessp) {</span>
<a href="#l93.174"></a><span id="l93.174">     // Make sure prldap_get_errno() returns an error.</span>
<a href="#l93.175"></a><span id="l93.175">     PR_SetError(PR_INVALID_ARGUMENT_ERROR, EINVAL);</span>
<a href="#l93.176"></a><span id="l93.176">     return (-1);</span>
<a href="#l93.177"></a><span id="l93.177">   }</span>
<a href="#l93.178"></a><span id="l93.178"> </span>
<a href="#l93.179"></a><span id="l93.179" class="difflineat">@@ -292,18 +292,18 @@ prldap_poll(LDAP_X_PollFD fds[], int nfd</span>
<a href="#l93.180"></a><span id="l93.180"> </span>
<a href="#l93.181"></a><span id="l93.181">   return (rc);</span>
<a href="#l93.182"></a><span id="l93.182"> }</span>
<a href="#l93.183"></a><span id="l93.183"> </span>
<a href="#l93.184"></a><span id="l93.184"> /*</span>
<a href="#l93.185"></a><span id="l93.185">  * Utility function to try one TCP connect()</span>
<a href="#l93.186"></a><span id="l93.186">  * Returns 1 if successful and -1 if not.  Sets the NSPR fd inside prsockp.</span>
<a href="#l93.187"></a><span id="l93.187">  */</span>
<a href="#l93.188"></a><span id="l93.188" class="difflineminus">-static int prldap_try_one_address(struct lextiof_socket_private *prsockp,</span>
<a href="#l93.189"></a><span id="l93.189" class="difflineminus">-                                  PRNetAddr *addrp, int timeout,</span>
<a href="#l93.190"></a><span id="l93.190" class="difflineplus">+static int prldap_try_one_address(struct lextiof_socket_private* prsockp,</span>
<a href="#l93.191"></a><span id="l93.191" class="difflineplus">+                                  PRNetAddr* addrp, int timeout,</span>
<a href="#l93.192"></a><span id="l93.192">                                   unsigned long options) {</span>
<a href="#l93.193"></a><span id="l93.193">   /*</span>
<a href="#l93.194"></a><span id="l93.194">    * Open a TCP socket:</span>
<a href="#l93.195"></a><span id="l93.195">    */</span>
<a href="#l93.196"></a><span id="l93.196">   if ((prsockp-&gt;prsock_prfd = PR_OpenTCPSocket(PR_NetAddrFamily(addrp))) ==</span>
<a href="#l93.197"></a><span id="l93.197">       NULL) {</span>
<a href="#l93.198"></a><span id="l93.198">     return (-1);</span>
<a href="#l93.199"></a><span id="l93.199">   }</span>
<a href="#l93.200"></a><span id="l93.200" class="difflineat">@@ -362,25 +362,25 @@ static int prldap_try_one_address(struct</span>
<a href="#l93.201"></a><span id="l93.201">    */</span>
<a href="#l93.202"></a><span id="l93.202">   return (1);</span>
<a href="#l93.203"></a><span id="l93.203"> }</span>
<a href="#l93.204"></a><span id="l93.204"> </span>
<a href="#l93.205"></a><span id="l93.205"> /*</span>
<a href="#l93.206"></a><span id="l93.206">  * XXXmcs: At present, this code ignores the timeout when doing DNS lookups.</span>
<a href="#l93.207"></a><span id="l93.207">  */</span>
<a href="#l93.208"></a><span id="l93.208"> static int LDAP_CALLBACK prldap_connect(</span>
<a href="#l93.209"></a><span id="l93.209" class="difflineminus">-    const char *hostlist, int defport, int timeout, unsigned long options,</span>
<a href="#l93.210"></a><span id="l93.210" class="difflineminus">-    struct lextiof_session_private *sessionarg,</span>
<a href="#l93.211"></a><span id="l93.211" class="difflineminus">-    struct lextiof_socket_private **socketargp) {</span>
<a href="#l93.212"></a><span id="l93.212" class="difflineplus">+    const char* hostlist, int defport, int timeout, unsigned long options,</span>
<a href="#l93.213"></a><span id="l93.213" class="difflineplus">+    struct lextiof_session_private* sessionarg,</span>
<a href="#l93.214"></a><span id="l93.214" class="difflineplus">+    struct lextiof_socket_private** socketargp) {</span>
<a href="#l93.215"></a><span id="l93.215">   int rc, parse_err, port;</span>
<a href="#l93.216"></a><span id="l93.216" class="difflineminus">-  char *host;</span>
<a href="#l93.217"></a><span id="l93.217" class="difflineminus">-  struct ldap_x_hostlist_status *status;</span>
<a href="#l93.218"></a><span id="l93.218" class="difflineminus">-  struct lextiof_socket_private *prsockp;</span>
<a href="#l93.219"></a><span id="l93.219" class="difflineplus">+  char* host;</span>
<a href="#l93.220"></a><span id="l93.220" class="difflineplus">+  struct ldap_x_hostlist_status* status;</span>
<a href="#l93.221"></a><span id="l93.221" class="difflineplus">+  struct lextiof_socket_private* prsockp;</span>
<a href="#l93.222"></a><span id="l93.222">   PRNetAddr addr;</span>
<a href="#l93.223"></a><span id="l93.223" class="difflineminus">-  PRAddrInfo *infop = NULL;</span>
<a href="#l93.224"></a><span id="l93.224" class="difflineplus">+  PRAddrInfo* infop = NULL;</span>
<a href="#l93.225"></a><span id="l93.225"> </span>
<a href="#l93.226"></a><span id="l93.226">   if (0 != (options &amp; LDAP_X_EXTIOF_OPT_SECURE)) {</span>
<a href="#l93.227"></a><span id="l93.227">     // Make sure prldap_get_errno() returns an error.</span>
<a href="#l93.228"></a><span id="l93.228">     PR_SetError(PR_INVALID_ARGUMENT_ERROR, EINVAL);</span>
<a href="#l93.229"></a><span id="l93.229">     return (-1);</span>
<a href="#l93.230"></a><span id="l93.230">   }</span>
<a href="#l93.231"></a><span id="l93.231"> </span>
<a href="#l93.232"></a><span id="l93.232">   if (NULL == (prsockp = prldap_socket_arg_alloc(sessionarg))) {</span>
<a href="#l93.233"></a><span id="l93.233" class="difflineat">@@ -398,17 +398,17 @@ static int LDAP_CALLBACK prldap_connect(</span>
<a href="#l93.234"></a><span id="l93.234">      * configuration.  All available addresses are returned and each of</span>
<a href="#l93.235"></a><span id="l93.235">      * them is examined in prldap_try_one_address till it succeeds.</span>
<a href="#l93.236"></a><span id="l93.236">      * Then, try converting the string address, in case the string</span>
<a href="#l93.237"></a><span id="l93.237">      * address was not successfully handled in PR_GetAddrInfoByName.</span>
<a href="#l93.238"></a><span id="l93.238">      */</span>
<a href="#l93.239"></a><span id="l93.239">     if (NULL !=</span>
<a href="#l93.240"></a><span id="l93.240">         (infop = PR_GetAddrInfoByName(</span>
<a href="#l93.241"></a><span id="l93.241">              host, PR_AF_UNSPEC, (PR_AI_ADDRCONFIG | PR_AI_NOCANONNAME)))) {</span>
<a href="#l93.242"></a><span id="l93.242" class="difflineminus">-      void *enump = NULL;</span>
<a href="#l93.243"></a><span id="l93.243" class="difflineplus">+      void* enump = NULL;</span>
<a href="#l93.244"></a><span id="l93.244">       do {</span>
<a href="#l93.245"></a><span id="l93.245">         memset(&amp;addr, 0, sizeof(addr));</span>
<a href="#l93.246"></a><span id="l93.246">         enump = PR_EnumerateAddrInfo(enump, infop, port, &amp;addr);</span>
<a href="#l93.247"></a><span id="l93.247">         if (NULL == enump) {</span>
<a href="#l93.248"></a><span id="l93.248">           break;</span>
<a href="#l93.249"></a><span id="l93.249">         }</span>
<a href="#l93.250"></a><span id="l93.250">         rc = prldap_try_one_address(prsockp, &amp;addr, timeout, options);</span>
<a href="#l93.251"></a><span id="l93.251">       } while (rc &lt; 0);</span>
<a href="#l93.252"></a><span id="l93.252" class="difflineat">@@ -430,17 +430,17 @@ static int LDAP_CALLBACK prldap_connect(</span>
<a href="#l93.253"></a><span id="l93.253">   } else {</span>
<a href="#l93.254"></a><span id="l93.254">     *socketargp = prsockp;</span>
<a href="#l93.255"></a><span id="l93.255">   }</span>
<a href="#l93.256"></a><span id="l93.256"> </span>
<a href="#l93.257"></a><span id="l93.257">   return (rc);</span>
<a href="#l93.258"></a><span id="l93.258"> }</span>
<a href="#l93.259"></a><span id="l93.259"> </span>
<a href="#l93.260"></a><span id="l93.260"> static int LDAP_CALLBACK</span>
<a href="#l93.261"></a><span id="l93.261" class="difflineminus">-prldap_close(int s, struct lextiof_socket_private *socketarg) {</span>
<a href="#l93.262"></a><span id="l93.262" class="difflineplus">+prldap_close(int s, struct lextiof_socket_private* socketarg) {</span>
<a href="#l93.263"></a><span id="l93.263">   int rc;</span>
<a href="#l93.264"></a><span id="l93.264"> </span>
<a href="#l93.265"></a><span id="l93.265">   rc = 0;</span>
<a href="#l93.266"></a><span id="l93.266">   if (PR_Close(PRLDAP_GET_PRFD(socketarg)) != PR_SUCCESS) {</span>
<a href="#l93.267"></a><span id="l93.267">     rc = -1;</span>
<a href="#l93.268"></a><span id="l93.268">   }</span>
<a href="#l93.269"></a><span id="l93.269">   prldap_socket_arg_free(&amp;socketarg);</span>
<a href="#l93.270"></a><span id="l93.270"> </span>
<a href="#l93.271"></a><span id="l93.271" class="difflineat">@@ -449,222 +449,222 @@ prldap_close(int s, struct lextiof_socke</span>
<a href="#l93.272"></a><span id="l93.272"> </span>
<a href="#l93.273"></a><span id="l93.273"> /*</span>
<a href="#l93.274"></a><span id="l93.274">  * LDAP session handle creation callback.</span>
<a href="#l93.275"></a><span id="l93.275">  *</span>
<a href="#l93.276"></a><span id="l93.276">  * Allocate a session argument if not already done, and then call the</span>
<a href="#l93.277"></a><span id="l93.277">  * thread's new handle function.</span>
<a href="#l93.278"></a><span id="l93.278">  */</span>
<a href="#l93.279"></a><span id="l93.279"> static int LDAP_CALLBACK</span>
<a href="#l93.280"></a><span id="l93.280" class="difflineminus">-prldap_newhandle(LDAP *ld, struct lextiof_session_private *sessionarg) {</span>
<a href="#l93.281"></a><span id="l93.281" class="difflineplus">+prldap_newhandle(LDAP* ld, struct lextiof_session_private* sessionarg) {</span>
<a href="#l93.282"></a><span id="l93.282">   if (NULL == sessionarg) {</span>
<a href="#l93.283"></a><span id="l93.283">     struct ldap_x_ext_io_fns iofns;</span>
<a href="#l93.284"></a><span id="l93.284"> </span>
<a href="#l93.285"></a><span id="l93.285">     memset(&amp;iofns, 0, sizeof(iofns));</span>
<a href="#l93.286"></a><span id="l93.286">     iofns.lextiof_size = LDAP_X_EXTIO_FNS_SIZE;</span>
<a href="#l93.287"></a><span id="l93.287" class="difflineminus">-    if (ldap_get_option(ld, LDAP_X_OPT_EXTIO_FN_PTRS, (void *)&amp;iofns) &lt; 0) {</span>
<a href="#l93.288"></a><span id="l93.288" class="difflineplus">+    if (ldap_get_option(ld, LDAP_X_OPT_EXTIO_FN_PTRS, (void*)&amp;iofns) &lt; 0) {</span>
<a href="#l93.289"></a><span id="l93.289">       return (ldap_get_lderrno(ld, NULL, NULL));</span>
<a href="#l93.290"></a><span id="l93.290">     }</span>
<a href="#l93.291"></a><span id="l93.291">     if (NULL == (iofns.lextiof_session_arg = prldap_session_arg_alloc())) {</span>
<a href="#l93.292"></a><span id="l93.292">       return (LDAP_NO_MEMORY);</span>
<a href="#l93.293"></a><span id="l93.293">     }</span>
<a href="#l93.294"></a><span id="l93.294" class="difflineminus">-    if (ldap_set_option(ld, LDAP_X_OPT_EXTIO_FN_PTRS, (void *)&amp;iofns) &lt; 0) {</span>
<a href="#l93.295"></a><span id="l93.295" class="difflineplus">+    if (ldap_set_option(ld, LDAP_X_OPT_EXTIO_FN_PTRS, (void*)&amp;iofns) &lt; 0) {</span>
<a href="#l93.296"></a><span id="l93.296">       return (ldap_get_lderrno(ld, NULL, NULL));</span>
<a href="#l93.297"></a><span id="l93.297">     }</span>
<a href="#l93.298"></a><span id="l93.298">   }</span>
<a href="#l93.299"></a><span id="l93.299"> </span>
<a href="#l93.300"></a><span id="l93.300">   return (LDAP_SUCCESS);</span>
<a href="#l93.301"></a><span id="l93.301"> }</span>
<a href="#l93.302"></a><span id="l93.302"> </span>
<a href="#l93.303"></a><span id="l93.303"> /* only called/installed if shared is non-zero. */</span>
<a href="#l93.304"></a><span id="l93.304"> static int LDAP_CALLBACK</span>
<a href="#l93.305"></a><span id="l93.305" class="difflineminus">-prldap_shared_newhandle(LDAP *ld, struct lextiof_session_private *sessionarg) {</span>
<a href="#l93.306"></a><span id="l93.306" class="difflineplus">+prldap_shared_newhandle(LDAP* ld, struct lextiof_session_private* sessionarg) {</span>
<a href="#l93.307"></a><span id="l93.307">   int rc;</span>
<a href="#l93.308"></a><span id="l93.308"> </span>
<a href="#l93.309"></a><span id="l93.309">   if ((rc = prldap_newhandle(ld, sessionarg)) == LDAP_SUCCESS) {</span>
<a href="#l93.310"></a><span id="l93.310">     rc = prldap_thread_new_handle(ld, sessionarg);</span>
<a href="#l93.311"></a><span id="l93.311">   }</span>
<a href="#l93.312"></a><span id="l93.312"> </span>
<a href="#l93.313"></a><span id="l93.313">   return (rc);</span>
<a href="#l93.314"></a><span id="l93.314"> }</span>
<a href="#l93.315"></a><span id="l93.315"> </span>
<a href="#l93.316"></a><span id="l93.316"> static void LDAP_CALLBACK</span>
<a href="#l93.317"></a><span id="l93.317" class="difflineminus">-prldap_disposehandle(LDAP *ld, struct lextiof_session_private *sessionarg) {</span>
<a href="#l93.318"></a><span id="l93.318" class="difflineplus">+prldap_disposehandle(LDAP* ld, struct lextiof_session_private* sessionarg) {</span>
<a href="#l93.319"></a><span id="l93.319">   prldap_session_arg_free(&amp;sessionarg);</span>
<a href="#l93.320"></a><span id="l93.320"> }</span>
<a href="#l93.321"></a><span id="l93.321"> </span>
<a href="#l93.322"></a><span id="l93.322"> /* only called/installed if shared is non-zero */</span>
<a href="#l93.323"></a><span id="l93.323"> static void LDAP_CALLBACK prldap_shared_disposehandle(</span>
<a href="#l93.324"></a><span id="l93.324" class="difflineminus">-    LDAP *ld, struct lextiof_session_private *sessionarg) {</span>
<a href="#l93.325"></a><span id="l93.325" class="difflineplus">+    LDAP* ld, struct lextiof_session_private* sessionarg) {</span>
<a href="#l93.326"></a><span id="l93.326">   prldap_thread_dispose_handle(ld, sessionarg);</span>
<a href="#l93.327"></a><span id="l93.327">   prldap_disposehandle(ld, sessionarg);</span>
<a href="#l93.328"></a><span id="l93.328"> }</span>
<a href="#l93.329"></a><span id="l93.329"> </span>
<a href="#l93.330"></a><span id="l93.330"> /*</span>
<a href="#l93.331"></a><span id="l93.331">  * Allocate a session argument.</span>
<a href="#l93.332"></a><span id="l93.332">  */</span>
<a href="#l93.333"></a><span id="l93.333" class="difflineminus">-static PRLDAPIOSessionArg *prldap_session_arg_alloc(void) {</span>
<a href="#l93.334"></a><span id="l93.334" class="difflineminus">-  PRLDAPIOSessionArg *prsessp;</span>
<a href="#l93.335"></a><span id="l93.335" class="difflineplus">+static PRLDAPIOSessionArg* prldap_session_arg_alloc(void) {</span>
<a href="#l93.336"></a><span id="l93.336" class="difflineplus">+  PRLDAPIOSessionArg* prsessp;</span>
<a href="#l93.337"></a><span id="l93.337"> </span>
<a href="#l93.338"></a><span id="l93.338">   prsessp = PR_Calloc(1, sizeof(PRLDAPIOSessionArg));</span>
<a href="#l93.339"></a><span id="l93.339"> </span>
<a href="#l93.340"></a><span id="l93.340">   if (NULL != prsessp) {</span>
<a href="#l93.341"></a><span id="l93.341">     /* copy global defaults to the new session handle */</span>
<a href="#l93.342"></a><span id="l93.342">     prsessp-&gt;prsess_io_max_timeout = prldap_default_io_max_timeout;</span>
<a href="#l93.343"></a><span id="l93.343">   }</span>
<a href="#l93.344"></a><span id="l93.344"> </span>
<a href="#l93.345"></a><span id="l93.345">   return (prsessp);</span>
<a href="#l93.346"></a><span id="l93.346"> }</span>
<a href="#l93.347"></a><span id="l93.347"> </span>
<a href="#l93.348"></a><span id="l93.348" class="difflineminus">-static void prldap_session_arg_free(PRLDAPIOSessionArg **prsesspp) {</span>
<a href="#l93.349"></a><span id="l93.349" class="difflineplus">+static void prldap_session_arg_free(PRLDAPIOSessionArg** prsesspp) {</span>
<a href="#l93.350"></a><span id="l93.350">   if (NULL != prsesspp &amp;&amp; NULL != *prsesspp) {</span>
<a href="#l93.351"></a><span id="l93.351">     if (NULL != (*prsesspp)-&gt;prsess_pollds) {</span>
<a href="#l93.352"></a><span id="l93.352">       PR_Free((*prsesspp)-&gt;prsess_pollds);</span>
<a href="#l93.353"></a><span id="l93.353">       (*prsesspp)-&gt;prsess_pollds = NULL;</span>
<a href="#l93.354"></a><span id="l93.354">     }</span>
<a href="#l93.355"></a><span id="l93.355">     PR_Free(*prsesspp);</span>
<a href="#l93.356"></a><span id="l93.356">     *prsesspp = NULL;</span>
<a href="#l93.357"></a><span id="l93.357">   }</span>
<a href="#l93.358"></a><span id="l93.358"> }</span>
<a href="#l93.359"></a><span id="l93.359"> </span>
<a href="#l93.360"></a><span id="l93.360"> /*</span>
<a href="#l93.361"></a><span id="l93.361">  * Given an LDAP session handle, retrieve a session argument.</span>
<a href="#l93.362"></a><span id="l93.362">  * Returns an LDAP error code.</span>
<a href="#l93.363"></a><span id="l93.363">  */</span>
<a href="#l93.364"></a><span id="l93.364" class="difflineminus">-int prldap_session_arg_from_ld(LDAP *ld, PRLDAPIOSessionArg **sessargpp) {</span>
<a href="#l93.365"></a><span id="l93.365" class="difflineplus">+int prldap_session_arg_from_ld(LDAP* ld, PRLDAPIOSessionArg** sessargpp) {</span>
<a href="#l93.366"></a><span id="l93.366">   struct ldap_x_ext_io_fns iofns;</span>
<a href="#l93.367"></a><span id="l93.367"> </span>
<a href="#l93.368"></a><span id="l93.368">   if (NULL == ld || NULL == sessargpp) {</span>
<a href="#l93.369"></a><span id="l93.369">     /* XXXmcs: NULL ld's are not supported */</span>
<a href="#l93.370"></a><span id="l93.370">     ldap_set_lderrno(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l93.371"></a><span id="l93.371">     return (LDAP_PARAM_ERROR);</span>
<a href="#l93.372"></a><span id="l93.372">   }</span>
<a href="#l93.373"></a><span id="l93.373"> </span>
<a href="#l93.374"></a><span id="l93.374">   memset(&amp;iofns, 0, sizeof(iofns));</span>
<a href="#l93.375"></a><span id="l93.375">   iofns.lextiof_size = LDAP_X_EXTIO_FNS_SIZE;</span>
<a href="#l93.376"></a><span id="l93.376" class="difflineminus">-  if (ldap_get_option(ld, LDAP_X_OPT_EXTIO_FN_PTRS, (void *)&amp;iofns) &lt; 0) {</span>
<a href="#l93.377"></a><span id="l93.377" class="difflineplus">+  if (ldap_get_option(ld, LDAP_X_OPT_EXTIO_FN_PTRS, (void*)&amp;iofns) &lt; 0) {</span>
<a href="#l93.378"></a><span id="l93.378">     return (ldap_get_lderrno(ld, NULL, NULL));</span>
<a href="#l93.379"></a><span id="l93.379">   }</span>
<a href="#l93.380"></a><span id="l93.380"> </span>
<a href="#l93.381"></a><span id="l93.381">   if (NULL == iofns.lextiof_session_arg) {</span>
<a href="#l93.382"></a><span id="l93.382">     ldap_set_lderrno(ld, LDAP_LOCAL_ERROR, NULL, NULL);</span>
<a href="#l93.383"></a><span id="l93.383">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l93.384"></a><span id="l93.384">   }</span>
<a href="#l93.385"></a><span id="l93.385"> </span>
<a href="#l93.386"></a><span id="l93.386">   *sessargpp = iofns.lextiof_session_arg;</span>
<a href="#l93.387"></a><span id="l93.387">   return (LDAP_SUCCESS);</span>
<a href="#l93.388"></a><span id="l93.388"> }</span>
<a href="#l93.389"></a><span id="l93.389"> </span>
<a href="#l93.390"></a><span id="l93.390"> /*</span>
<a href="#l93.391"></a><span id="l93.391">  * Given an LDAP session handle, retrieve a socket argument.</span>
<a href="#l93.392"></a><span id="l93.392">  * Returns an LDAP error code.</span>
<a href="#l93.393"></a><span id="l93.393">  */</span>
<a href="#l93.394"></a><span id="l93.394" class="difflineminus">-int prldap_socket_arg_from_ld(LDAP *ld, PRLDAPIOSocketArg **sockargpp) {</span>
<a href="#l93.395"></a><span id="l93.395" class="difflineminus">-  Sockbuf *sbp;</span>
<a href="#l93.396"></a><span id="l93.396" class="difflineplus">+int prldap_socket_arg_from_ld(LDAP* ld, PRLDAPIOSocketArg** sockargpp) {</span>
<a href="#l93.397"></a><span id="l93.397" class="difflineplus">+  Sockbuf* sbp;</span>
<a href="#l93.398"></a><span id="l93.398">   struct lber_x_ext_io_fns extiofns;</span>
<a href="#l93.399"></a><span id="l93.399"> </span>
<a href="#l93.400"></a><span id="l93.400">   if (NULL == ld || NULL == sockargpp) {</span>
<a href="#l93.401"></a><span id="l93.401">     /* XXXmcs: NULL ld's are not supported */</span>
<a href="#l93.402"></a><span id="l93.402">     ldap_set_lderrno(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l93.403"></a><span id="l93.403">     return (LDAP_PARAM_ERROR);</span>
<a href="#l93.404"></a><span id="l93.404">   }</span>
<a href="#l93.405"></a><span id="l93.405"> </span>
<a href="#l93.406"></a><span id="l93.406" class="difflineminus">-  if (ldap_get_option(ld, LDAP_X_OPT_SOCKBUF, (void *)&amp;sbp) &lt; 0) {</span>
<a href="#l93.407"></a><span id="l93.407" class="difflineplus">+  if (ldap_get_option(ld, LDAP_X_OPT_SOCKBUF, (void*)&amp;sbp) &lt; 0) {</span>
<a href="#l93.408"></a><span id="l93.408">     return (ldap_get_lderrno(ld, NULL, NULL));</span>
<a href="#l93.409"></a><span id="l93.409">   }</span>
<a href="#l93.410"></a><span id="l93.410"> </span>
<a href="#l93.411"></a><span id="l93.411">   memset(&amp;extiofns, 0, sizeof(extiofns));</span>
<a href="#l93.412"></a><span id="l93.412">   extiofns.lbextiofn_size = LBER_X_EXTIO_FNS_SIZE;</span>
<a href="#l93.413"></a><span id="l93.413">   if (ber_sockbuf_get_option(sbp, LBER_SOCKBUF_OPT_EXT_IO_FNS,</span>
<a href="#l93.414"></a><span id="l93.414" class="difflineminus">-                             (void *)&amp;extiofns) &lt; 0) {</span>
<a href="#l93.415"></a><span id="l93.415" class="difflineplus">+                             (void*)&amp;extiofns) &lt; 0) {</span>
<a href="#l93.416"></a><span id="l93.416">     return (ldap_get_lderrno(ld, NULL, NULL));</span>
<a href="#l93.417"></a><span id="l93.417">   }</span>
<a href="#l93.418"></a><span id="l93.418"> </span>
<a href="#l93.419"></a><span id="l93.419">   if (NULL == extiofns.lbextiofn_socket_arg) {</span>
<a href="#l93.420"></a><span id="l93.420">     ldap_set_lderrno(ld, LDAP_LOCAL_ERROR, NULL, NULL);</span>
<a href="#l93.421"></a><span id="l93.421">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l93.422"></a><span id="l93.422">   }</span>
<a href="#l93.423"></a><span id="l93.423"> </span>
<a href="#l93.424"></a><span id="l93.424">   *sockargpp = extiofns.lbextiofn_socket_arg;</span>
<a href="#l93.425"></a><span id="l93.425">   return (LDAP_SUCCESS);</span>
<a href="#l93.426"></a><span id="l93.426"> }</span>
<a href="#l93.427"></a><span id="l93.427"> </span>
<a href="#l93.428"></a><span id="l93.428"> /*</span>
<a href="#l93.429"></a><span id="l93.429">  * Allocate a socket argument.</span>
<a href="#l93.430"></a><span id="l93.430">  */</span>
<a href="#l93.431"></a><span id="l93.431" class="difflineminus">-PRLDAPIOSocketArg *prldap_socket_arg_alloc(PRLDAPIOSessionArg *sessionarg) {</span>
<a href="#l93.432"></a><span id="l93.432" class="difflineminus">-  PRLDAPIOSocketArg *prsockp;</span>
<a href="#l93.433"></a><span id="l93.433" class="difflineplus">+PRLDAPIOSocketArg* prldap_socket_arg_alloc(PRLDAPIOSessionArg* sessionarg) {</span>
<a href="#l93.434"></a><span id="l93.434" class="difflineplus">+  PRLDAPIOSocketArg* prsockp;</span>
<a href="#l93.435"></a><span id="l93.435"> </span>
<a href="#l93.436"></a><span id="l93.436">   prsockp = PR_Calloc(1, sizeof(PRLDAPIOSocketArg));</span>
<a href="#l93.437"></a><span id="l93.437"> </span>
<a href="#l93.438"></a><span id="l93.438">   if (NULL != prsockp &amp;&amp; NULL != sessionarg) {</span>
<a href="#l93.439"></a><span id="l93.439">     /* copy socket defaults from the session */</span>
<a href="#l93.440"></a><span id="l93.440">     prsockp-&gt;prsock_io_max_timeout = sessionarg-&gt;prsess_io_max_timeout;</span>
<a href="#l93.441"></a><span id="l93.441">   }</span>
<a href="#l93.442"></a><span id="l93.442"> </span>
<a href="#l93.443"></a><span id="l93.443">   return (prsockp);</span>
<a href="#l93.444"></a><span id="l93.444"> }</span>
<a href="#l93.445"></a><span id="l93.445"> </span>
<a href="#l93.446"></a><span id="l93.446" class="difflineminus">-static void prldap_socket_arg_free(PRLDAPIOSocketArg **prsockpp) {</span>
<a href="#l93.447"></a><span id="l93.447" class="difflineplus">+static void prldap_socket_arg_free(PRLDAPIOSocketArg** prsockpp) {</span>
<a href="#l93.448"></a><span id="l93.448">   if (NULL != prsockpp &amp;&amp; NULL != *prsockpp) {</span>
<a href="#l93.449"></a><span id="l93.449">     PR_Free(*prsockpp);</span>
<a href="#l93.450"></a><span id="l93.450">     *prsockpp = NULL;</span>
<a href="#l93.451"></a><span id="l93.451">   }</span>
<a href="#l93.452"></a><span id="l93.452"> }</span>
<a href="#l93.453"></a><span id="l93.453"> </span>
<a href="#l93.454"></a><span id="l93.454" class="difflineminus">-static void *prldap_safe_realloc(void *ptr, PRUint32 size) {</span>
<a href="#l93.455"></a><span id="l93.455" class="difflineminus">-  void *p;</span>
<a href="#l93.456"></a><span id="l93.456" class="difflineplus">+static void* prldap_safe_realloc(void* ptr, PRUint32 size) {</span>
<a href="#l93.457"></a><span id="l93.457" class="difflineplus">+  void* p;</span>
<a href="#l93.458"></a><span id="l93.458"> </span>
<a href="#l93.459"></a><span id="l93.459">   if (NULL == ptr) {</span>
<a href="#l93.460"></a><span id="l93.460">     p = PR_Malloc(size);</span>
<a href="#l93.461"></a><span id="l93.461">   } else {</span>
<a href="#l93.462"></a><span id="l93.462">     p = PR_Realloc(ptr, size);</span>
<a href="#l93.463"></a><span id="l93.463">   }</span>
<a href="#l93.464"></a><span id="l93.464"> </span>
<a href="#l93.465"></a><span id="l93.465">   return (p);</span>
<a href="#l93.466"></a><span id="l93.466"> }</span>
<a href="#l93.467"></a><span id="l93.467"> </span>
<a href="#l93.468"></a><span id="l93.468"> /* returns an LDAP result code */</span>
<a href="#l93.469"></a><span id="l93.469" class="difflineminus">-int prldap_set_io_max_timeout(PRLDAPIOSessionArg *prsessp, int io_max_timeout) {</span>
<a href="#l93.470"></a><span id="l93.470" class="difflineplus">+int prldap_set_io_max_timeout(PRLDAPIOSessionArg* prsessp, int io_max_timeout) {</span>
<a href="#l93.471"></a><span id="l93.471">   int rc = LDAP_SUCCESS; /* optimistic */</span>
<a href="#l93.472"></a><span id="l93.472"> </span>
<a href="#l93.473"></a><span id="l93.473">   if (NULL == prsessp) {</span>
<a href="#l93.474"></a><span id="l93.474">     prldap_default_io_max_timeout = io_max_timeout;</span>
<a href="#l93.475"></a><span id="l93.475">   } else {</span>
<a href="#l93.476"></a><span id="l93.476">     prsessp-&gt;prsess_io_max_timeout = io_max_timeout;</span>
<a href="#l93.477"></a><span id="l93.477">   }</span>
<a href="#l93.478"></a><span id="l93.478"> </span>
<a href="#l93.479"></a><span id="l93.479">   return (rc);</span>
<a href="#l93.480"></a><span id="l93.480"> }</span>
<a href="#l93.481"></a><span id="l93.481"> </span>
<a href="#l93.482"></a><span id="l93.482"> /* returns an LDAP result code */</span>
<a href="#l93.483"></a><span id="l93.483" class="difflineminus">-int prldap_get_io_max_timeout(PRLDAPIOSessionArg *prsessp,</span>
<a href="#l93.484"></a><span id="l93.484" class="difflineminus">-                              int *io_max_timeoutp) {</span>
<a href="#l93.485"></a><span id="l93.485" class="difflineplus">+int prldap_get_io_max_timeout(PRLDAPIOSessionArg* prsessp,</span>
<a href="#l93.486"></a><span id="l93.486" class="difflineplus">+                              int* io_max_timeoutp) {</span>
<a href="#l93.487"></a><span id="l93.487">   int rc = LDAP_SUCCESS; /* optimistic */</span>
<a href="#l93.488"></a><span id="l93.488"> </span>
<a href="#l93.489"></a><span id="l93.489">   if (NULL == io_max_timeoutp) {</span>
<a href="#l93.490"></a><span id="l93.490">     rc = LDAP_PARAM_ERROR;</span>
<a href="#l93.491"></a><span id="l93.491">   } else if (NULL == prsessp) {</span>
<a href="#l93.492"></a><span id="l93.492">     *io_max_timeoutp = prldap_default_io_max_timeout;</span>
<a href="#l93.493"></a><span id="l93.493">   } else {</span>
<a href="#l93.494"></a><span id="l93.494">     *io_max_timeoutp = prsessp-&gt;prsess_io_max_timeout;</span>
<a href="#l93.495"></a><span id="l93.495">   }</span>
<a href="#l93.496"></a><span id="l93.496"> </span>
<a href="#l93.497"></a><span id="l93.497">   return (rc);</span>
<a href="#l93.498"></a><span id="l93.498"> }</span>
<a href="#l93.499"></a><span id="l93.499"> </span>
<a href="#l93.500"></a><span id="l93.500"> /* Check if NSPR layer has been installed for a LDAP session.</span>
<a href="#l93.501"></a><span id="l93.501">  * Simply check whether prldap_connect() I/O function is installed</span>
<a href="#l93.502"></a><span id="l93.502">  */</span>
<a href="#l93.503"></a><span id="l93.503" class="difflineminus">-PRBool prldap_is_installed(LDAP *ld) {</span>
<a href="#l93.504"></a><span id="l93.504" class="difflineplus">+PRBool prldap_is_installed(LDAP* ld) {</span>
<a href="#l93.505"></a><span id="l93.505">   struct ldap_x_ext_io_fns iofns;</span>
<a href="#l93.506"></a><span id="l93.506"> </span>
<a href="#l93.507"></a><span id="l93.507">   /* Retrieve current I/O functions */</span>
<a href="#l93.508"></a><span id="l93.508">   memset(&amp;iofns, 0, sizeof(iofns));</span>
<a href="#l93.509"></a><span id="l93.509">   iofns.lextiof_size = LDAP_X_EXTIO_FNS_SIZE;</span>
<a href="#l93.510"></a><span id="l93.510">   if (ld == NULL ||</span>
<a href="#l93.511"></a><span id="l93.511" class="difflineminus">-      ldap_get_option(ld, LDAP_X_OPT_EXTIO_FN_PTRS, (void *)&amp;iofns) != 0 ||</span>
<a href="#l93.512"></a><span id="l93.512" class="difflineplus">+      ldap_get_option(ld, LDAP_X_OPT_EXTIO_FN_PTRS, (void*)&amp;iofns) != 0 ||</span>
<a href="#l93.513"></a><span id="l93.513">       iofns.lextiof_connect != prldap_connect) {</span>
<a href="#l93.514"></a><span id="l93.514">     return (PR_FALSE);</span>
<a href="#l93.515"></a><span id="l93.515">   }</span>
<a href="#l93.516"></a><span id="l93.516"> </span>
<a href="#l93.517"></a><span id="l93.517">   return (PR_TRUE);</span>
<a href="#l93.518"></a><span id="l93.518"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l94.1"></a><span id="l94.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libprldap/ldappr-public.c</span>
<a href="#l94.2"></a><span id="l94.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libprldap/ldappr-public.c</span>
<a href="#l94.3"></a><span id="l94.3" class="difflineat">@@ -50,18 +50,18 @@</span>
<a href="#l94.4"></a><span id="l94.4">  * Create a new LDAP session handle, but with NSPR I/O, threading, and DNS</span>
<a href="#l94.5"></a><span id="l94.5">  * functions installed.</span>
<a href="#l94.6"></a><span id="l94.6">  *</span>
<a href="#l94.7"></a><span id="l94.7">  * Pass a non-zero value for the 'shared' parameter if you plan to use</span>
<a href="#l94.8"></a><span id="l94.8">  * this LDAP * handle from more than one thread.</span>
<a href="#l94.9"></a><span id="l94.9">  *</span>
<a href="#l94.10"></a><span id="l94.10">  * prldap_init() returns an LDAP session handle (or NULL if an error occurs).</span>
<a href="#l94.11"></a><span id="l94.11">  */</span>
<a href="#l94.12"></a><span id="l94.12" class="difflineminus">-LDAP *LDAP_CALL prldap_init(const char *defhost, int defport, int shared) {</span>
<a href="#l94.13"></a><span id="l94.13" class="difflineminus">-  LDAP *ld;</span>
<a href="#l94.14"></a><span id="l94.14" class="difflineplus">+LDAP* LDAP_CALL prldap_init(const char* defhost, int defport, int shared) {</span>
<a href="#l94.15"></a><span id="l94.15" class="difflineplus">+  LDAP* ld;</span>
<a href="#l94.16"></a><span id="l94.16"> </span>
<a href="#l94.17"></a><span id="l94.17">   if ((ld = ldap_init(defhost, defport)) != NULL) {</span>
<a href="#l94.18"></a><span id="l94.18">     if (prldap_install_routines(ld, shared) != LDAP_SUCCESS) {</span>
<a href="#l94.19"></a><span id="l94.19">       // Make sure prldap_get_errno() returns an error.</span>
<a href="#l94.20"></a><span id="l94.20">       PR_SetError(PR_UNKNOWN_ERROR, EINVAL);</span>
<a href="#l94.21"></a><span id="l94.21">       ldap_unbind(ld);</span>
<a href="#l94.22"></a><span id="l94.22">       ld = NULL;</span>
<a href="#l94.23"></a><span id="l94.23">     }</span>
<a href="#l94.24"></a><span id="l94.24" class="difflineat">@@ -80,17 +80,17 @@ LDAP *LDAP_CALL prldap_init(const char *</span>
<a href="#l94.25"></a><span id="l94.25">  * for all new LDAP * handles).</span>
<a href="#l94.26"></a><span id="l94.26">  *</span>
<a href="#l94.27"></a><span id="l94.27">  * Pass a non-zero value for the 'shared' parameter if you plan to use</span>
<a href="#l94.28"></a><span id="l94.28">  * this LDAP * handle from more than one thread.</span>
<a href="#l94.29"></a><span id="l94.29">  *</span>
<a href="#l94.30"></a><span id="l94.30">  * prldap_install_routines() returns an LDAP API error code (LDAP_SUCCESS</span>
<a href="#l94.31"></a><span id="l94.31">  * if all goes well).</span>
<a href="#l94.32"></a><span id="l94.32">  */</span>
<a href="#l94.33"></a><span id="l94.33" class="difflineminus">-int LDAP_CALL prldap_install_routines(LDAP *ld, int shared) {</span>
<a href="#l94.34"></a><span id="l94.34" class="difflineplus">+int LDAP_CALL prldap_install_routines(LDAP* ld, int shared) {</span>
<a href="#l94.35"></a><span id="l94.35">   if (prldap_install_io_functions(ld, shared) != 0 ||</span>
<a href="#l94.36"></a><span id="l94.36">       prldap_install_thread_functions(ld, shared) != 0 ||</span>
<a href="#l94.37"></a><span id="l94.37">       prldap_install_dns_functions(ld) != 0) {</span>
<a href="#l94.38"></a><span id="l94.38">     return (ldap_get_lderrno(ld, NULL, NULL));</span>
<a href="#l94.39"></a><span id="l94.39">   }</span>
<a href="#l94.40"></a><span id="l94.40"> </span>
<a href="#l94.41"></a><span id="l94.41">   return (LDAP_SUCCESS);</span>
<a href="#l94.42"></a><span id="l94.42"> }</span>
<a href="#l94.43"></a><span id="l94.43" class="difflineat">@@ -102,28 +102,28 @@ int LDAP_CALL prldap_install_routines(LD</span>
<a href="#l94.44"></a><span id="l94.44">  * SOCKET, POLL, NEWHANDLE, or DISPOSEHANDLE extended I/O callbacks, set</span>
<a href="#l94.45"></a><span id="l94.45">  * an option that affects the prldap layer.</span>
<a href="#l94.46"></a><span id="l94.46">  *</span>
<a href="#l94.47"></a><span id="l94.47">  * If 'ld' and 'session&quot; are both NULL, the option is set as the default</span>
<a href="#l94.48"></a><span id="l94.48">  * for all new prldap sessions.</span>
<a href="#l94.49"></a><span id="l94.49">  *</span>
<a href="#l94.50"></a><span id="l94.50">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l94.51"></a><span id="l94.51">  */</span>
<a href="#l94.52"></a><span id="l94.52" class="difflineminus">-int LDAP_CALL prldap_set_session_option(LDAP *ld, void *sessionarg, int option,</span>
<a href="#l94.53"></a><span id="l94.53" class="difflineplus">+int LDAP_CALL prldap_set_session_option(LDAP* ld, void* sessionarg, int option,</span>
<a href="#l94.54"></a><span id="l94.54">                                         ...) {</span>
<a href="#l94.55"></a><span id="l94.55">   int rc = LDAP_SUCCESS; /* optimistic */</span>
<a href="#l94.56"></a><span id="l94.56" class="difflineminus">-  PRLDAPIOSessionArg *prsessp = NULL;</span>
<a href="#l94.57"></a><span id="l94.57" class="difflineplus">+  PRLDAPIOSessionArg* prsessp = NULL;</span>
<a href="#l94.58"></a><span id="l94.58">   va_list ap;</span>
<a href="#l94.59"></a><span id="l94.59"> </span>
<a href="#l94.60"></a><span id="l94.60">   if (NULL != ld) {</span>
<a href="#l94.61"></a><span id="l94.61">     if (LDAP_SUCCESS != (rc = prldap_session_arg_from_ld(ld, &amp;prsessp))) {</span>
<a href="#l94.62"></a><span id="l94.62">       return (rc);</span>
<a href="#l94.63"></a><span id="l94.63">     }</span>
<a href="#l94.64"></a><span id="l94.64">   } else if (NULL != sessionarg) {</span>
<a href="#l94.65"></a><span id="l94.65" class="difflineminus">-    prsessp = (PRLDAPIOSessionArg *)sessionarg;</span>
<a href="#l94.66"></a><span id="l94.66" class="difflineplus">+    prsessp = (PRLDAPIOSessionArg*)sessionarg;</span>
<a href="#l94.67"></a><span id="l94.67">   }</span>
<a href="#l94.68"></a><span id="l94.68"> </span>
<a href="#l94.69"></a><span id="l94.69">   va_start(ap, option);</span>
<a href="#l94.70"></a><span id="l94.70">   switch (option) {</span>
<a href="#l94.71"></a><span id="l94.71">     case PRLDAP_OPT_IO_MAX_TIMEOUT:</span>
<a href="#l94.72"></a><span id="l94.72">       rc = prldap_set_io_max_timeout(prsessp, va_arg(ap, int));</span>
<a href="#l94.73"></a><span id="l94.73">       break;</span>
<a href="#l94.74"></a><span id="l94.74">     default:</span>
<a href="#l94.75"></a><span id="l94.75" class="difflineat">@@ -141,66 +141,66 @@ int LDAP_CALL prldap_set_session_option(</span>
<a href="#l94.76"></a><span id="l94.76">  * SOCKET, POLL, NEWHANDLE, or DISPOSEHANDLE extended I/O callbacks, retrieve</span>
<a href="#l94.77"></a><span id="l94.77">  * the setting for an option that affects the prldap layer.</span>
<a href="#l94.78"></a><span id="l94.78">  *</span>
<a href="#l94.79"></a><span id="l94.79">  * If 'ld' and 'session&quot; are both NULL, the default option value for all new</span>
<a href="#l94.80"></a><span id="l94.80">  * new prldap sessions is retrieved.</span>
<a href="#l94.81"></a><span id="l94.81">  *</span>
<a href="#l94.82"></a><span id="l94.82">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l94.83"></a><span id="l94.83">  */</span>
<a href="#l94.84"></a><span id="l94.84" class="difflineminus">-int LDAP_CALL prldap_get_session_option(LDAP *ld, void *sessionarg, int option,</span>
<a href="#l94.85"></a><span id="l94.85" class="difflineplus">+int LDAP_CALL prldap_get_session_option(LDAP* ld, void* sessionarg, int option,</span>
<a href="#l94.86"></a><span id="l94.86">                                         ...) {</span>
<a href="#l94.87"></a><span id="l94.87">   int rc = LDAP_SUCCESS; /* optimistic */</span>
<a href="#l94.88"></a><span id="l94.88" class="difflineminus">-  PRLDAPIOSessionArg *prsessp = NULL;</span>
<a href="#l94.89"></a><span id="l94.89" class="difflineplus">+  PRLDAPIOSessionArg* prsessp = NULL;</span>
<a href="#l94.90"></a><span id="l94.90">   va_list ap;</span>
<a href="#l94.91"></a><span id="l94.91"> </span>
<a href="#l94.92"></a><span id="l94.92">   if (NULL != ld) {</span>
<a href="#l94.93"></a><span id="l94.93">     if (LDAP_SUCCESS != (rc = prldap_session_arg_from_ld(ld, &amp;prsessp))) {</span>
<a href="#l94.94"></a><span id="l94.94">       return (rc);</span>
<a href="#l94.95"></a><span id="l94.95">     }</span>
<a href="#l94.96"></a><span id="l94.96">   } else if (NULL != sessionarg) {</span>
<a href="#l94.97"></a><span id="l94.97" class="difflineminus">-    prsessp = (PRLDAPIOSessionArg *)sessionarg;</span>
<a href="#l94.98"></a><span id="l94.98" class="difflineplus">+    prsessp = (PRLDAPIOSessionArg*)sessionarg;</span>
<a href="#l94.99"></a><span id="l94.99">   }</span>
<a href="#l94.100"></a><span id="l94.100"> </span>
<a href="#l94.101"></a><span id="l94.101">   va_start(ap, option);</span>
<a href="#l94.102"></a><span id="l94.102">   switch (option) {</span>
<a href="#l94.103"></a><span id="l94.103">     case PRLDAP_OPT_IO_MAX_TIMEOUT:</span>
<a href="#l94.104"></a><span id="l94.104" class="difflineminus">-      rc = prldap_get_io_max_timeout(prsessp, va_arg(ap, int *));</span>
<a href="#l94.105"></a><span id="l94.105" class="difflineplus">+      rc = prldap_get_io_max_timeout(prsessp, va_arg(ap, int*));</span>
<a href="#l94.106"></a><span id="l94.106">       break;</span>
<a href="#l94.107"></a><span id="l94.107">     default:</span>
<a href="#l94.108"></a><span id="l94.108">       rc = LDAP_PARAM_ERROR;</span>
<a href="#l94.109"></a><span id="l94.109">   }</span>
<a href="#l94.110"></a><span id="l94.110">   va_end(ap);</span>
<a href="#l94.111"></a><span id="l94.111"> </span>
<a href="#l94.112"></a><span id="l94.112">   return (rc);</span>
<a href="#l94.113"></a><span id="l94.113"> }</span>
<a href="#l94.114"></a><span id="l94.114"> </span>
<a href="#l94.115"></a><span id="l94.115"> /*</span>
<a href="#l94.116"></a><span id="l94.116">  * Function: prldap_set_session_info().</span>
<a href="#l94.117"></a><span id="l94.117">  *</span>
<a href="#l94.118"></a><span id="l94.118">  * Given an LDAP session handle, set some application-specific data.</span>
<a href="#l94.119"></a><span id="l94.119">  *</span>
<a href="#l94.120"></a><span id="l94.120">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l94.121"></a><span id="l94.121">  */</span>
<a href="#l94.122"></a><span id="l94.122" class="difflineminus">-int LDAP_CALL prldap_set_session_info(LDAP *ld, void *sessionarg,</span>
<a href="#l94.123"></a><span id="l94.123" class="difflineminus">-                                      PRLDAPSessionInfo *seip) {</span>
<a href="#l94.124"></a><span id="l94.124" class="difflineplus">+int LDAP_CALL prldap_set_session_info(LDAP* ld, void* sessionarg,</span>
<a href="#l94.125"></a><span id="l94.125" class="difflineplus">+                                      PRLDAPSessionInfo* seip) {</span>
<a href="#l94.126"></a><span id="l94.126">   int rc;</span>
<a href="#l94.127"></a><span id="l94.127" class="difflineminus">-  PRLDAPIOSessionArg *prsessp;</span>
<a href="#l94.128"></a><span id="l94.128" class="difflineplus">+  PRLDAPIOSessionArg* prsessp;</span>
<a href="#l94.129"></a><span id="l94.129"> </span>
<a href="#l94.130"></a><span id="l94.130">   if (seip == NULL || PRLDAP_SESSIONINFO_SIZE != seip-&gt;seinfo_size) {</span>
<a href="#l94.131"></a><span id="l94.131">     ldap_set_lderrno(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l94.132"></a><span id="l94.132">     return (LDAP_PARAM_ERROR);</span>
<a href="#l94.133"></a><span id="l94.133">   }</span>
<a href="#l94.134"></a><span id="l94.134"> </span>
<a href="#l94.135"></a><span id="l94.135">   if (NULL != ld) {</span>
<a href="#l94.136"></a><span id="l94.136">     if (LDAP_SUCCESS != (rc = prldap_session_arg_from_ld(ld, &amp;prsessp))) {</span>
<a href="#l94.137"></a><span id="l94.137">       return (rc);</span>
<a href="#l94.138"></a><span id="l94.138">     }</span>
<a href="#l94.139"></a><span id="l94.139">   } else if (NULL != sessionarg) {</span>
<a href="#l94.140"></a><span id="l94.140" class="difflineminus">-    prsessp = (PRLDAPIOSessionArg *)sessionarg;</span>
<a href="#l94.141"></a><span id="l94.141" class="difflineplus">+    prsessp = (PRLDAPIOSessionArg*)sessionarg;</span>
<a href="#l94.142"></a><span id="l94.142">   } else {</span>
<a href="#l94.143"></a><span id="l94.143">     ldap_set_lderrno(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l94.144"></a><span id="l94.144">     return (LDAP_PARAM_ERROR);</span>
<a href="#l94.145"></a><span id="l94.145">   }</span>
<a href="#l94.146"></a><span id="l94.146"> </span>
<a href="#l94.147"></a><span id="l94.147">   prsessp-&gt;prsess_appdata = seip-&gt;seinfo_appdata;</span>
<a href="#l94.148"></a><span id="l94.148">   return (LDAP_SUCCESS);</span>
<a href="#l94.149"></a><span id="l94.149"> }</span>
<a href="#l94.150"></a><span id="l94.150" class="difflineat">@@ -208,32 +208,32 @@ int LDAP_CALL prldap_set_session_info(LD</span>
<a href="#l94.151"></a><span id="l94.151"> /*</span>
<a href="#l94.152"></a><span id="l94.152">  * Function: prldap_get_session_info().</span>
<a href="#l94.153"></a><span id="l94.153">  *</span>
<a href="#l94.154"></a><span id="l94.154">  * Given an LDAP session handle, retrieve some application-specific data.</span>
<a href="#l94.155"></a><span id="l94.155">  *</span>
<a href="#l94.156"></a><span id="l94.156">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well, in</span>
<a href="#l94.157"></a><span id="l94.157">  * which case the fields in the structure that seip points to are filled in).</span>
<a href="#l94.158"></a><span id="l94.158">  */</span>
<a href="#l94.159"></a><span id="l94.159" class="difflineminus">-int LDAP_CALL prldap_get_session_info(LDAP *ld, void *sessionarg,</span>
<a href="#l94.160"></a><span id="l94.160" class="difflineminus">-                                      PRLDAPSessionInfo *seip) {</span>
<a href="#l94.161"></a><span id="l94.161" class="difflineplus">+int LDAP_CALL prldap_get_session_info(LDAP* ld, void* sessionarg,</span>
<a href="#l94.162"></a><span id="l94.162" class="difflineplus">+                                      PRLDAPSessionInfo* seip) {</span>
<a href="#l94.163"></a><span id="l94.163">   int rc;</span>
<a href="#l94.164"></a><span id="l94.164" class="difflineminus">-  PRLDAPIOSessionArg *prsessp;</span>
<a href="#l94.165"></a><span id="l94.165" class="difflineplus">+  PRLDAPIOSessionArg* prsessp;</span>
<a href="#l94.166"></a><span id="l94.166"> </span>
<a href="#l94.167"></a><span id="l94.167">   if (seip == NULL || PRLDAP_SESSIONINFO_SIZE != seip-&gt;seinfo_size) {</span>
<a href="#l94.168"></a><span id="l94.168">     ldap_set_lderrno(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l94.169"></a><span id="l94.169">     return (LDAP_PARAM_ERROR);</span>
<a href="#l94.170"></a><span id="l94.170">   }</span>
<a href="#l94.171"></a><span id="l94.171"> </span>
<a href="#l94.172"></a><span id="l94.172">   if (NULL != ld) {</span>
<a href="#l94.173"></a><span id="l94.173">     if (LDAP_SUCCESS != (rc = prldap_session_arg_from_ld(ld, &amp;prsessp))) {</span>
<a href="#l94.174"></a><span id="l94.174">       return (rc);</span>
<a href="#l94.175"></a><span id="l94.175">     }</span>
<a href="#l94.176"></a><span id="l94.176">   } else if (NULL != sessionarg) {</span>
<a href="#l94.177"></a><span id="l94.177" class="difflineminus">-    prsessp = (PRLDAPIOSessionArg *)sessionarg;</span>
<a href="#l94.178"></a><span id="l94.178" class="difflineplus">+    prsessp = (PRLDAPIOSessionArg*)sessionarg;</span>
<a href="#l94.179"></a><span id="l94.179">   } else {</span>
<a href="#l94.180"></a><span id="l94.180">     ldap_set_lderrno(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l94.181"></a><span id="l94.181">     return (LDAP_PARAM_ERROR);</span>
<a href="#l94.182"></a><span id="l94.182">   }</span>
<a href="#l94.183"></a><span id="l94.183"> </span>
<a href="#l94.184"></a><span id="l94.184">   seip-&gt;seinfo_appdata = prsessp-&gt;prsess_appdata;</span>
<a href="#l94.185"></a><span id="l94.185">   return (LDAP_SUCCESS);</span>
<a href="#l94.186"></a><span id="l94.186"> }</span>
<a href="#l94.187"></a><span id="l94.187" class="difflineat">@@ -244,69 +244,69 @@ int LDAP_CALL prldap_get_session_info(LD</span>
<a href="#l94.188"></a><span id="l94.188">  * Given an integer fd and a void * argument such as those passed to the</span>
<a href="#l94.189"></a><span id="l94.189">  * extended I/O callback functions, set socket specific information.</span>
<a href="#l94.190"></a><span id="l94.190">  *</span>
<a href="#l94.191"></a><span id="l94.191">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well).</span>
<a href="#l94.192"></a><span id="l94.192">  *</span>
<a href="#l94.193"></a><span id="l94.193">  * Note: it is only safe to change soinfo_prfd from within the SOCKET</span>
<a href="#l94.194"></a><span id="l94.194">  * extended I/O callback function.</span>
<a href="#l94.195"></a><span id="l94.195">  */</span>
<a href="#l94.196"></a><span id="l94.196" class="difflineminus">-int LDAP_CALL prldap_set_socket_info(int fd, void *socketarg,</span>
<a href="#l94.197"></a><span id="l94.197" class="difflineminus">-                                     PRLDAPSocketInfo *soip) {</span>
<a href="#l94.198"></a><span id="l94.198" class="difflineminus">-  PRLDAPIOSocketArg *prsockp;</span>
<a href="#l94.199"></a><span id="l94.199" class="difflineplus">+int LDAP_CALL prldap_set_socket_info(int fd, void* socketarg,</span>
<a href="#l94.200"></a><span id="l94.200" class="difflineplus">+                                     PRLDAPSocketInfo* soip) {</span>
<a href="#l94.201"></a><span id="l94.201" class="difflineplus">+  PRLDAPIOSocketArg* prsockp;</span>
<a href="#l94.202"></a><span id="l94.202"> </span>
<a href="#l94.203"></a><span id="l94.203">   if (NULL == socketarg || NULL == soip ||</span>
<a href="#l94.204"></a><span id="l94.204">       PRLDAP_SOCKETINFO_SIZE != soip-&gt;soinfo_size) {</span>
<a href="#l94.205"></a><span id="l94.205">     return (LDAP_PARAM_ERROR);</span>
<a href="#l94.206"></a><span id="l94.206">   }</span>
<a href="#l94.207"></a><span id="l94.207"> </span>
<a href="#l94.208"></a><span id="l94.208" class="difflineminus">-  prsockp = (PRLDAPIOSocketArg *)socketarg;</span>
<a href="#l94.209"></a><span id="l94.209" class="difflineplus">+  prsockp = (PRLDAPIOSocketArg*)socketarg;</span>
<a href="#l94.210"></a><span id="l94.210">   prsockp-&gt;prsock_prfd = soip-&gt;soinfo_prfd;</span>
<a href="#l94.211"></a><span id="l94.211">   prsockp-&gt;prsock_appdata = soip-&gt;soinfo_appdata;</span>
<a href="#l94.212"></a><span id="l94.212"> </span>
<a href="#l94.213"></a><span id="l94.213">   return (LDAP_SUCCESS);</span>
<a href="#l94.214"></a><span id="l94.214"> }</span>
<a href="#l94.215"></a><span id="l94.215"> </span>
<a href="#l94.216"></a><span id="l94.216"> /*</span>
<a href="#l94.217"></a><span id="l94.217">  * Function: prldap_get_socket_info().</span>
<a href="#l94.218"></a><span id="l94.218">  *</span>
<a href="#l94.219"></a><span id="l94.219">  * Given an integer fd and a void * argument such as those passed to the</span>
<a href="#l94.220"></a><span id="l94.220">  * extended I/O callback functions, retrieve socket specific information.</span>
<a href="#l94.221"></a><span id="l94.221">  *</span>
<a href="#l94.222"></a><span id="l94.222">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well, in</span>
<a href="#l94.223"></a><span id="l94.223">  * which case the fields in the structure that soip points to are filled in).</span>
<a href="#l94.224"></a><span id="l94.224">  */</span>
<a href="#l94.225"></a><span id="l94.225" class="difflineminus">-int LDAP_CALL prldap_get_socket_info(int fd, void *socketarg,</span>
<a href="#l94.226"></a><span id="l94.226" class="difflineminus">-                                     PRLDAPSocketInfo *soip) {</span>
<a href="#l94.227"></a><span id="l94.227" class="difflineminus">-  PRLDAPIOSocketArg *prsockp;</span>
<a href="#l94.228"></a><span id="l94.228" class="difflineplus">+int LDAP_CALL prldap_get_socket_info(int fd, void* socketarg,</span>
<a href="#l94.229"></a><span id="l94.229" class="difflineplus">+                                     PRLDAPSocketInfo* soip) {</span>
<a href="#l94.230"></a><span id="l94.230" class="difflineplus">+  PRLDAPIOSocketArg* prsockp;</span>
<a href="#l94.231"></a><span id="l94.231"> </span>
<a href="#l94.232"></a><span id="l94.232">   if (NULL == socketarg || NULL == soip ||</span>
<a href="#l94.233"></a><span id="l94.233">       PRLDAP_SOCKETINFO_SIZE != soip-&gt;soinfo_size) {</span>
<a href="#l94.234"></a><span id="l94.234">     return (LDAP_PARAM_ERROR);</span>
<a href="#l94.235"></a><span id="l94.235">   }</span>
<a href="#l94.236"></a><span id="l94.236"> </span>
<a href="#l94.237"></a><span id="l94.237" class="difflineminus">-  prsockp = (PRLDAPIOSocketArg *)socketarg;</span>
<a href="#l94.238"></a><span id="l94.238" class="difflineplus">+  prsockp = (PRLDAPIOSocketArg*)socketarg;</span>
<a href="#l94.239"></a><span id="l94.239">   soip-&gt;soinfo_prfd = prsockp-&gt;prsock_prfd;</span>
<a href="#l94.240"></a><span id="l94.240">   soip-&gt;soinfo_appdata = prsockp-&gt;prsock_appdata;</span>
<a href="#l94.241"></a><span id="l94.241"> </span>
<a href="#l94.242"></a><span id="l94.242">   return (LDAP_SUCCESS);</span>
<a href="#l94.243"></a><span id="l94.243"> }</span>
<a href="#l94.244"></a><span id="l94.244"> </span>
<a href="#l94.245"></a><span id="l94.245"> /*</span>
<a href="#l94.246"></a><span id="l94.246">  * Function: prldap_get_default_socket_info().</span>
<a href="#l94.247"></a><span id="l94.247">  *</span>
<a href="#l94.248"></a><span id="l94.248">  * Given an LDAP session handle, retrieve socket specific information.</span>
<a href="#l94.249"></a><span id="l94.249">  * If ld is NULL, LDAP_PARAM_ERROR is returned.</span>
<a href="#l94.250"></a><span id="l94.250">  *</span>
<a href="#l94.251"></a><span id="l94.251">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well, in</span>
<a href="#l94.252"></a><span id="l94.252">  * which case the fields in the structure that soip points to are filled in).</span>
<a href="#l94.253"></a><span id="l94.253">  */</span>
<a href="#l94.254"></a><span id="l94.254" class="difflineminus">-int LDAP_CALL prldap_get_default_socket_info(LDAP *ld, PRLDAPSocketInfo *soip) {</span>
<a href="#l94.255"></a><span id="l94.255" class="difflineplus">+int LDAP_CALL prldap_get_default_socket_info(LDAP* ld, PRLDAPSocketInfo* soip) {</span>
<a href="#l94.256"></a><span id="l94.256">   int rc;</span>
<a href="#l94.257"></a><span id="l94.257" class="difflineminus">-  PRLDAPIOSocketArg *prsockp;</span>
<a href="#l94.258"></a><span id="l94.258" class="difflineplus">+  PRLDAPIOSocketArg* prsockp;</span>
<a href="#l94.259"></a><span id="l94.259"> </span>
<a href="#l94.260"></a><span id="l94.260">   if (NULL == soip || PRLDAP_SOCKETINFO_SIZE != soip-&gt;soinfo_size) {</span>
<a href="#l94.261"></a><span id="l94.261">     ldap_set_lderrno(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l94.262"></a><span id="l94.262">     return (LDAP_PARAM_ERROR);</span>
<a href="#l94.263"></a><span id="l94.263">   }</span>
<a href="#l94.264"></a><span id="l94.264"> </span>
<a href="#l94.265"></a><span id="l94.265">   if (NULL != ld) {</span>
<a href="#l94.266"></a><span id="l94.266">     if (LDAP_SUCCESS != (rc = prldap_socket_arg_from_ld(ld, &amp;prsockp))) {</span>
<a href="#l94.267"></a><span id="l94.267" class="difflineat">@@ -327,19 +327,19 @@ int LDAP_CALL prldap_get_default_socket_</span>
<a href="#l94.268"></a><span id="l94.268">  * Function: prldap_set_default_socket_info().</span>
<a href="#l94.269"></a><span id="l94.269">  *</span>
<a href="#l94.270"></a><span id="l94.270">  * Given an LDAP session handle, set socket specific information.</span>
<a href="#l94.271"></a><span id="l94.271">  * If ld is NULL, LDAP_PARAM_ERROR is returned.</span>
<a href="#l94.272"></a><span id="l94.272">  *</span>
<a href="#l94.273"></a><span id="l94.273">  * Returns an LDAP API error code (LDAP_SUCCESS if all goes well, in</span>
<a href="#l94.274"></a><span id="l94.274">  * which case the fields in the structure that soip points to are filled in).</span>
<a href="#l94.275"></a><span id="l94.275">  */</span>
<a href="#l94.276"></a><span id="l94.276" class="difflineminus">-int LDAP_CALL prldap_set_default_socket_info(LDAP *ld, PRLDAPSocketInfo *soip) {</span>
<a href="#l94.277"></a><span id="l94.277" class="difflineplus">+int LDAP_CALL prldap_set_default_socket_info(LDAP* ld, PRLDAPSocketInfo* soip) {</span>
<a href="#l94.278"></a><span id="l94.278">   int rc;</span>
<a href="#l94.279"></a><span id="l94.279" class="difflineminus">-  PRLDAPIOSocketArg *prsockp;</span>
<a href="#l94.280"></a><span id="l94.280" class="difflineplus">+  PRLDAPIOSocketArg* prsockp;</span>
<a href="#l94.281"></a><span id="l94.281"> </span>
<a href="#l94.282"></a><span id="l94.282">   if (NULL == soip || PRLDAP_SOCKETINFO_SIZE != soip-&gt;soinfo_size) {</span>
<a href="#l94.283"></a><span id="l94.283">     ldap_set_lderrno(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l94.284"></a><span id="l94.284">     return (LDAP_PARAM_ERROR);</span>
<a href="#l94.285"></a><span id="l94.285">   }</span>
<a href="#l94.286"></a><span id="l94.286"> </span>
<a href="#l94.287"></a><span id="l94.287">   if (NULL != ld) {</span>
<a href="#l94.288"></a><span id="l94.288">     if (LDAP_SUCCESS != (rc = prldap_socket_arg_from_ld(ld, &amp;prsockp))) {</span>
<a href="#l94.289"></a><span id="l94.289" class="difflineat">@@ -359,23 +359,23 @@ int LDAP_CALL prldap_set_default_socket_</span>
<a href="#l94.290"></a><span id="l94.290"> /*</span>
<a href="#l94.291"></a><span id="l94.291">  * Function: prldap_import_connection().</span>
<a href="#l94.292"></a><span id="l94.292">  *</span>
<a href="#l94.293"></a><span id="l94.293">  * Given the LDAP handle the connection parameters for the</span>
<a href="#l94.294"></a><span id="l94.294">  * file descriptor are imported into NSPR layer.</span>
<a href="#l94.295"></a><span id="l94.295">  *</span>
<a href="#l94.296"></a><span id="l94.296">  * Returns an LDAP API code (LDAP_SUCCESS) if all goes well.</span>
<a href="#l94.297"></a><span id="l94.297">  */</span>
<a href="#l94.298"></a><span id="l94.298" class="difflineminus">-int LDAP_CALL prldap_import_connection(LDAP *ld) {</span>
<a href="#l94.299"></a><span id="l94.299" class="difflineplus">+int LDAP_CALL prldap_import_connection(LDAP* ld) {</span>
<a href="#l94.300"></a><span id="l94.300">   int rc = LDAP_SUCCESS; /* optimistic */</span>
<a href="#l94.301"></a><span id="l94.301">   int shared = 1;        /* Assume shared init */</span>
<a href="#l94.302"></a><span id="l94.302">   LBER_SOCKET orig_socket = -1;</span>
<a href="#l94.303"></a><span id="l94.303" class="difflineminus">-  PRLDAPIOSessionArg *prsessp = NULL;</span>
<a href="#l94.304"></a><span id="l94.304" class="difflineminus">-  PRLDAPIOSocketArg *prsockp = NULL;</span>
<a href="#l94.305"></a><span id="l94.305" class="difflineminus">-  PRFileDesc *pr_socket = NULL;</span>
<a href="#l94.306"></a><span id="l94.306" class="difflineplus">+  PRLDAPIOSessionArg* prsessp = NULL;</span>
<a href="#l94.307"></a><span id="l94.307" class="difflineplus">+  PRLDAPIOSocketArg* prsockp = NULL;</span>
<a href="#l94.308"></a><span id="l94.308" class="difflineplus">+  PRFileDesc* pr_socket = NULL;</span>
<a href="#l94.309"></a><span id="l94.309"> </span>
<a href="#l94.310"></a><span id="l94.310">   /* Check for invalid ld handle */</span>
<a href="#l94.311"></a><span id="l94.311">   if (ld == NULL) {</span>
<a href="#l94.312"></a><span id="l94.312">     ldap_set_lderrno(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l94.313"></a><span id="l94.313">     return (LDAP_PARAM_ERROR);</span>
<a href="#l94.314"></a><span id="l94.314">   }</span>
<a href="#l94.315"></a><span id="l94.315"> </span>
<a href="#l94.316"></a><span id="l94.316">   /* Retrieve TCP socket's integer file descriptor */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l95.1"></a><span id="l95.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libprldap/ldappr-threads.c</span>
<a href="#l95.2"></a><span id="l95.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libprldap/ldappr-threads.c</span>
<a href="#l95.3"></a><span id="l95.3" class="difflineat">@@ -55,57 +55,57 @@</span>
<a href="#l95.4"></a><span id="l95.4">  * Structures and types:</span>
<a href="#l95.5"></a><span id="l95.5">  */</span>
<a href="#l95.6"></a><span id="l95.6"> /*</span>
<a href="#l95.7"></a><span id="l95.7">  * Structure used by libldap thread callbacks to maintain error information.</span>
<a href="#l95.8"></a><span id="l95.8">  */</span>
<a href="#l95.9"></a><span id="l95.9"> typedef struct prldap_errorinfo {</span>
<a href="#l95.10"></a><span id="l95.10">   int plei_magic; /* must be first in the structure */</span>
<a href="#l95.11"></a><span id="l95.11">   int plei_lderrno;</span>
<a href="#l95.12"></a><span id="l95.12" class="difflineminus">-  char *plei_matched;</span>
<a href="#l95.13"></a><span id="l95.13" class="difflineminus">-  char *plei_errmsg;</span>
<a href="#l95.14"></a><span id="l95.14" class="difflineplus">+  char* plei_matched;</span>
<a href="#l95.15"></a><span id="l95.15" class="difflineplus">+  char* plei_errmsg;</span>
<a href="#l95.16"></a><span id="l95.16"> } PRLDAP_ErrorInfo;</span>
<a href="#l95.17"></a><span id="l95.17"> </span>
<a href="#l95.18"></a><span id="l95.18"> #define PRLDAP_ERRORINFO_MAGIC 0x4D4F5A45 /* 'MOZE' */</span>
<a href="#l95.19"></a><span id="l95.19"> </span>
<a href="#l95.20"></a><span id="l95.20"> /*</span>
<a href="#l95.21"></a><span id="l95.21">  * Structure used to maintain thread-private data. At the present time,</span>
<a href="#l95.22"></a><span id="l95.22">  * only error info. is thread-private.  One of these structures is allocated</span>
<a href="#l95.23"></a><span id="l95.23">  * for each thread.</span>
<a href="#l95.24"></a><span id="l95.24">  */</span>
<a href="#l95.25"></a><span id="l95.25"> typedef struct prldap_tpd_header {</span>
<a href="#l95.26"></a><span id="l95.26">   int ptpdh_tpd_count;    /* # of data items allocated */</span>
<a href="#l95.27"></a><span id="l95.27" class="difflineminus">-  void **ptpdh_dataitems; /* array of data items */</span>
<a href="#l95.28"></a><span id="l95.28" class="difflineplus">+  void** ptpdh_dataitems; /* array of data items */</span>
<a href="#l95.29"></a><span id="l95.29"> } PRLDAP_TPDHeader;</span>
<a href="#l95.30"></a><span id="l95.30"> </span>
<a href="#l95.31"></a><span id="l95.31"> /*</span>
<a href="#l95.32"></a><span id="l95.32">  * Structure used by associate a PRLDAP thread-private data index with an</span>
<a href="#l95.33"></a><span id="l95.33">  * LDAP session handle. One of these exists for each active LDAP session</span>
<a href="#l95.34"></a><span id="l95.34">  * handle.</span>
<a href="#l95.35"></a><span id="l95.35">  */</span>
<a href="#l95.36"></a><span id="l95.36"> typedef struct prldap_tpd_map {</span>
<a href="#l95.37"></a><span id="l95.37" class="difflineminus">-  LDAP *prtm_ld;      /* non-NULL if in use */</span>
<a href="#l95.38"></a><span id="l95.38" class="difflineplus">+  LDAP* prtm_ld;      /* non-NULL if in use */</span>
<a href="#l95.39"></a><span id="l95.39">   PRUintn prtm_index; /* index into TPD array */</span>
<a href="#l95.40"></a><span id="l95.40" class="difflineminus">-  struct prldap_tpd_map *prtm_next;</span>
<a href="#l95.41"></a><span id="l95.41" class="difflineplus">+  struct prldap_tpd_map* prtm_next;</span>
<a href="#l95.42"></a><span id="l95.42"> } PRLDAP_TPDMap;</span>
<a href="#l95.43"></a><span id="l95.43"> </span>
<a href="#l95.44"></a><span id="l95.44"> /*</span>
<a href="#l95.45"></a><span id="l95.45">  * Static Variables:</span>
<a href="#l95.46"></a><span id="l95.46">  */</span>
<a href="#l95.47"></a><span id="l95.47"> /*</span>
<a href="#l95.48"></a><span id="l95.48">  * prldap_map_list points to all of the PRLDAP_TPDMap structures</span>
<a href="#l95.49"></a><span id="l95.49">  * we have ever allocated.  We recycle them as we open and close LDAP</span>
<a href="#l95.50"></a><span id="l95.50">  * sessions.</span>
<a href="#l95.51"></a><span id="l95.51">  */</span>
<a href="#l95.52"></a><span id="l95.52" class="difflineminus">-static PRLDAP_TPDMap *prldap_map_list = NULL;</span>
<a href="#l95.53"></a><span id="l95.53" class="difflineplus">+static PRLDAP_TPDMap* prldap_map_list = NULL;</span>
<a href="#l95.54"></a><span id="l95.54"> </span>
<a href="#l95.55"></a><span id="l95.55"> /*</span>
<a href="#l95.56"></a><span id="l95.56">  * The prldap_map_mutex is used to protect access to the prldap_map_list.</span>
<a href="#l95.57"></a><span id="l95.57">  */</span>
<a href="#l95.58"></a><span id="l95.58" class="difflineminus">-static PRLock *prldap_map_mutex = NULL;</span>
<a href="#l95.59"></a><span id="l95.59" class="difflineplus">+static PRLock* prldap_map_mutex = NULL;</span>
<a href="#l95.60"></a><span id="l95.60"> </span>
<a href="#l95.61"></a><span id="l95.61"> /*</span>
<a href="#l95.62"></a><span id="l95.62">  * The prldap_tpd_maxindex value is used to track the largest TPD array</span>
<a href="#l95.63"></a><span id="l95.63">  * index we have used.</span>
<a href="#l95.64"></a><span id="l95.64">  */</span>
<a href="#l95.65"></a><span id="l95.65"> static PRInt32 prldap_tpd_maxindex = -1;</span>
<a href="#l95.66"></a><span id="l95.66"> </span>
<a href="#l95.67"></a><span id="l95.67"> /*</span>
<a href="#l95.68"></a><span id="l95.68" class="difflineat">@@ -119,41 +119,41 @@ static PRUintn prldap_tpdindex = 0;</span>
<a href="#l95.69"></a><span id="l95.69">  * The prldap_callonce_init_tpd structure is used by NSPR to ensure</span>
<a href="#l95.70"></a><span id="l95.70">  * that prldap_init_tpd() is called at most once.</span>
<a href="#l95.71"></a><span id="l95.71">  */</span>
<a href="#l95.72"></a><span id="l95.72"> static PRCallOnceType prldap_callonce_init_tpd = {0, 0, 0};</span>
<a href="#l95.73"></a><span id="l95.73"> </span>
<a href="#l95.74"></a><span id="l95.74"> /*</span>
<a href="#l95.75"></a><span id="l95.75">  * Private function prototypes:</span>
<a href="#l95.76"></a><span id="l95.76">  */</span>
<a href="#l95.77"></a><span id="l95.77" class="difflineminus">-static void prldap_set_ld_error(int err, char *matched, char *errmsg,</span>
<a href="#l95.78"></a><span id="l95.78" class="difflineminus">-                                void *errorarg);</span>
<a href="#l95.79"></a><span id="l95.79" class="difflineminus">-static int prldap_get_ld_error(char **matchedp, char **errmsgp, void *errorarg);</span>
<a href="#l95.80"></a><span id="l95.80" class="difflineminus">-static void *prldap_mutex_alloc(void);</span>
<a href="#l95.81"></a><span id="l95.81" class="difflineminus">-static void prldap_mutex_free(void *mutex);</span>
<a href="#l95.82"></a><span id="l95.82" class="difflineminus">-static int prldap_mutex_lock(void *mutex);</span>
<a href="#l95.83"></a><span id="l95.83" class="difflineminus">-static int prldap_mutex_unlock(void *mutex);</span>
<a href="#l95.84"></a><span id="l95.84" class="difflineminus">-static void *prldap_get_thread_id(void);</span>
<a href="#l95.85"></a><span id="l95.85" class="difflineplus">+static void prldap_set_ld_error(int err, char* matched, char* errmsg,</span>
<a href="#l95.86"></a><span id="l95.86" class="difflineplus">+                                void* errorarg);</span>
<a href="#l95.87"></a><span id="l95.87" class="difflineplus">+static int prldap_get_ld_error(char** matchedp, char** errmsgp, void* errorarg);</span>
<a href="#l95.88"></a><span id="l95.88" class="difflineplus">+static void* prldap_mutex_alloc(void);</span>
<a href="#l95.89"></a><span id="l95.89" class="difflineplus">+static void prldap_mutex_free(void* mutex);</span>
<a href="#l95.90"></a><span id="l95.90" class="difflineplus">+static int prldap_mutex_lock(void* mutex);</span>
<a href="#l95.91"></a><span id="l95.91" class="difflineplus">+static int prldap_mutex_unlock(void* mutex);</span>
<a href="#l95.92"></a><span id="l95.92" class="difflineplus">+static void* prldap_get_thread_id(void);</span>
<a href="#l95.93"></a><span id="l95.93"> static PRStatus prldap_init_tpd(void);</span>
<a href="#l95.94"></a><span id="l95.94" class="difflineminus">-static PRLDAP_TPDMap *prldap_allocate_map(LDAP *ld);</span>
<a href="#l95.95"></a><span id="l95.95" class="difflineminus">-static void prldap_return_map(PRLDAP_TPDMap *map);</span>
<a href="#l95.96"></a><span id="l95.96" class="difflineplus">+static PRLDAP_TPDMap* prldap_allocate_map(LDAP* ld);</span>
<a href="#l95.97"></a><span id="l95.97" class="difflineplus">+static void prldap_return_map(PRLDAP_TPDMap* map);</span>
<a href="#l95.98"></a><span id="l95.98"> static PRUintn prldap_new_tpdindex(void);</span>
<a href="#l95.99"></a><span id="l95.99" class="difflineminus">-static int prldap_set_thread_private(PRInt32 tpdindex, void *priv);</span>
<a href="#l95.100"></a><span id="l95.100" class="difflineminus">-static void *prldap_get_thread_private(PRInt32 tpdindex);</span>
<a href="#l95.101"></a><span id="l95.101" class="difflineminus">-static PRLDAP_TPDHeader *prldap_tsd_realloc(PRLDAP_TPDHeader *tsdhdr,</span>
<a href="#l95.102"></a><span id="l95.102" class="difflineplus">+static int prldap_set_thread_private(PRInt32 tpdindex, void* priv);</span>
<a href="#l95.103"></a><span id="l95.103" class="difflineplus">+static void* prldap_get_thread_private(PRInt32 tpdindex);</span>
<a href="#l95.104"></a><span id="l95.104" class="difflineplus">+static PRLDAP_TPDHeader* prldap_tsd_realloc(PRLDAP_TPDHeader* tsdhdr,</span>
<a href="#l95.105"></a><span id="l95.105">                                             int maxindex);</span>
<a href="#l95.106"></a><span id="l95.106" class="difflineminus">-static void prldap_tsd_destroy(void *priv);</span>
<a href="#l95.107"></a><span id="l95.107" class="difflineplus">+static void prldap_tsd_destroy(void* priv);</span>
<a href="#l95.108"></a><span id="l95.108"> </span>
<a href="#l95.109"></a><span id="l95.109"> /*</span>
<a href="#l95.110"></a><span id="l95.110">  * Install NSPR thread functions into ld (if ld is NULL, they are installed</span>
<a href="#l95.111"></a><span id="l95.111">  * as the default functions for new LDAP * handles).</span>
<a href="#l95.112"></a><span id="l95.112">  *</span>
<a href="#l95.113"></a><span id="l95.113">  * Returns 0 if all goes well and -1 if not.</span>
<a href="#l95.114"></a><span id="l95.114">  */</span>
<a href="#l95.115"></a><span id="l95.115" class="difflineminus">-int prldap_install_thread_functions(LDAP *ld, int shared) {</span>
<a href="#l95.116"></a><span id="l95.116" class="difflineplus">+int prldap_install_thread_functions(LDAP* ld, int shared) {</span>
<a href="#l95.117"></a><span id="l95.117">   struct ldap_thread_fns tfns;</span>
<a href="#l95.118"></a><span id="l95.118">   struct ldap_extra_thread_fns xtfns;</span>
<a href="#l95.119"></a><span id="l95.119"> </span>
<a href="#l95.120"></a><span id="l95.120">   if (PR_CallOnce(&amp;prldap_callonce_init_tpd, prldap_init_tpd) != PR_SUCCESS) {</span>
<a href="#l95.121"></a><span id="l95.121">     ldap_set_lderrno(ld, LDAP_LOCAL_ERROR, NULL, NULL);</span>
<a href="#l95.122"></a><span id="l95.122">     return (-1);</span>
<a href="#l95.123"></a><span id="l95.123">   }</span>
<a href="#l95.124"></a><span id="l95.124"> </span>
<a href="#l95.125"></a><span id="l95.125" class="difflineat">@@ -170,65 +170,65 @@ int prldap_install_thread_functions(LDAP</span>
<a href="#l95.126"></a><span id="l95.126">     tfns.ltf_set_lderrno = prldap_set_ld_error;</span>
<a href="#l95.127"></a><span id="l95.127">     if (ld != NULL) {</span>
<a href="#l95.128"></a><span id="l95.128">       /*</span>
<a href="#l95.129"></a><span id="l95.129">        * If this is a real ld (i.e., we are not setting the global</span>
<a href="#l95.130"></a><span id="l95.130">        * defaults) allocate thread private data for error information.</span>
<a href="#l95.131"></a><span id="l95.131">        * If ld is NULL we do not do this here but it is done in</span>
<a href="#l95.132"></a><span id="l95.132">        * prldap_thread_new_handle().</span>
<a href="#l95.133"></a><span id="l95.133">        */</span>
<a href="#l95.134"></a><span id="l95.134" class="difflineminus">-      if ((tfns.ltf_lderrno_arg = (void *)prldap_allocate_map(ld)) == NULL) {</span>
<a href="#l95.135"></a><span id="l95.135" class="difflineplus">+      if ((tfns.ltf_lderrno_arg = (void*)prldap_allocate_map(ld)) == NULL) {</span>
<a href="#l95.136"></a><span id="l95.136">         return (-1);</span>
<a href="#l95.137"></a><span id="l95.137">       }</span>
<a href="#l95.138"></a><span id="l95.138">     }</span>
<a href="#l95.139"></a><span id="l95.139">   }</span>
<a href="#l95.140"></a><span id="l95.140"> </span>
<a href="#l95.141"></a><span id="l95.141" class="difflineminus">-  if (ldap_set_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void *)&amp;tfns) != 0) {</span>
<a href="#l95.142"></a><span id="l95.142" class="difflineminus">-    prldap_return_map((PRLDAP_TPDMap *)tfns.ltf_lderrno_arg);</span>
<a href="#l95.143"></a><span id="l95.143" class="difflineplus">+  if (ldap_set_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void*)&amp;tfns) != 0) {</span>
<a href="#l95.144"></a><span id="l95.144" class="difflineplus">+    prldap_return_map((PRLDAP_TPDMap*)tfns.ltf_lderrno_arg);</span>
<a href="#l95.145"></a><span id="l95.145">     return (-1);</span>
<a href="#l95.146"></a><span id="l95.146">   }</span>
<a href="#l95.147"></a><span id="l95.147"> </span>
<a href="#l95.148"></a><span id="l95.148">   /* set extended thread function pointers */</span>
<a href="#l95.149"></a><span id="l95.149">   memset(&amp;xtfns, '\0', sizeof(struct ldap_extra_thread_fns));</span>
<a href="#l95.150"></a><span id="l95.150">   xtfns.ltf_threadid_fn = prldap_get_thread_id;</span>
<a href="#l95.151"></a><span id="l95.151" class="difflineminus">-  if (ldap_set_option(ld, LDAP_OPT_EXTRA_THREAD_FN_PTRS, (void *)&amp;xtfns) != 0) {</span>
<a href="#l95.152"></a><span id="l95.152" class="difflineplus">+  if (ldap_set_option(ld, LDAP_OPT_EXTRA_THREAD_FN_PTRS, (void*)&amp;xtfns) != 0) {</span>
<a href="#l95.153"></a><span id="l95.153">     return (-1);</span>
<a href="#l95.154"></a><span id="l95.154">   }</span>
<a href="#l95.155"></a><span id="l95.155"> </span>
<a href="#l95.156"></a><span id="l95.156">   return (0);</span>
<a href="#l95.157"></a><span id="l95.157"> }</span>
<a href="#l95.158"></a><span id="l95.158"> </span>
<a href="#l95.159"></a><span id="l95.159" class="difflineminus">-static void *prldap_mutex_alloc(void) { return ((void *)PR_NewLock()); }</span>
<a href="#l95.160"></a><span id="l95.160" class="difflineplus">+static void* prldap_mutex_alloc(void) { return ((void*)PR_NewLock()); }</span>
<a href="#l95.161"></a><span id="l95.161"> </span>
<a href="#l95.162"></a><span id="l95.162" class="difflineminus">-static void prldap_mutex_free(void *mutex) { PR_DestroyLock((PRLock *)mutex); }</span>
<a href="#l95.163"></a><span id="l95.163" class="difflineplus">+static void prldap_mutex_free(void* mutex) { PR_DestroyLock((PRLock*)mutex); }</span>
<a href="#l95.164"></a><span id="l95.164"> </span>
<a href="#l95.165"></a><span id="l95.165" class="difflineminus">-static int prldap_mutex_lock(void *mutex) {</span>
<a href="#l95.166"></a><span id="l95.166" class="difflineminus">-  PR_Lock((PRLock *)mutex);</span>
<a href="#l95.167"></a><span id="l95.167" class="difflineplus">+static int prldap_mutex_lock(void* mutex) {</span>
<a href="#l95.168"></a><span id="l95.168" class="difflineplus">+  PR_Lock((PRLock*)mutex);</span>
<a href="#l95.169"></a><span id="l95.169">   return (0);</span>
<a href="#l95.170"></a><span id="l95.170"> }</span>
<a href="#l95.171"></a><span id="l95.171"> </span>
<a href="#l95.172"></a><span id="l95.172" class="difflineminus">-static int prldap_mutex_unlock(void *mutex) {</span>
<a href="#l95.173"></a><span id="l95.173" class="difflineminus">-  if (PR_Unlock((PRLock *)mutex) == PR_FAILURE) {</span>
<a href="#l95.174"></a><span id="l95.174" class="difflineplus">+static int prldap_mutex_unlock(void* mutex) {</span>
<a href="#l95.175"></a><span id="l95.175" class="difflineplus">+  if (PR_Unlock((PRLock*)mutex) == PR_FAILURE) {</span>
<a href="#l95.176"></a><span id="l95.176">     return (-1);</span>
<a href="#l95.177"></a><span id="l95.177">   }</span>
<a href="#l95.178"></a><span id="l95.178"> </span>
<a href="#l95.179"></a><span id="l95.179">   return (0);</span>
<a href="#l95.180"></a><span id="l95.180"> }</span>
<a href="#l95.181"></a><span id="l95.181"> </span>
<a href="#l95.182"></a><span id="l95.182" class="difflineminus">-static void *prldap_get_thread_id(void) {</span>
<a href="#l95.183"></a><span id="l95.183" class="difflineminus">-  return ((void *)PR_GetCurrentThread());</span>
<a href="#l95.184"></a><span id="l95.184" class="difflineplus">+static void* prldap_get_thread_id(void) {</span>
<a href="#l95.185"></a><span id="l95.185" class="difflineplus">+  return ((void*)PR_GetCurrentThread());</span>
<a href="#l95.186"></a><span id="l95.186"> }</span>
<a href="#l95.187"></a><span id="l95.187"> </span>
<a href="#l95.188"></a><span id="l95.188" class="difflineminus">-static int prldap_get_ld_error(char **matchedp, char **errmsgp,</span>
<a href="#l95.189"></a><span id="l95.189" class="difflineminus">-                               void *errorarg) {</span>
<a href="#l95.190"></a><span id="l95.190" class="difflineminus">-  PRLDAP_TPDMap *map;</span>
<a href="#l95.191"></a><span id="l95.191" class="difflineminus">-  PRLDAP_ErrorInfo *eip;</span>
<a href="#l95.192"></a><span id="l95.192" class="difflineplus">+static int prldap_get_ld_error(char** matchedp, char** errmsgp,</span>
<a href="#l95.193"></a><span id="l95.193" class="difflineplus">+                               void* errorarg) {</span>
<a href="#l95.194"></a><span id="l95.194" class="difflineplus">+  PRLDAP_TPDMap* map;</span>
<a href="#l95.195"></a><span id="l95.195" class="difflineplus">+  PRLDAP_ErrorInfo* eip;</span>
<a href="#l95.196"></a><span id="l95.196"> </span>
<a href="#l95.197"></a><span id="l95.197" class="difflineminus">-  if ((map = (PRLDAP_TPDMap *)errorarg) != NULL &amp;&amp;</span>
<a href="#l95.198"></a><span id="l95.198" class="difflineminus">-      (eip = (PRLDAP_ErrorInfo *)prldap_get_thread_private(map-&gt;prtm_index)) !=</span>
<a href="#l95.199"></a><span id="l95.199" class="difflineplus">+  if ((map = (PRLDAP_TPDMap*)errorarg) != NULL &amp;&amp;</span>
<a href="#l95.200"></a><span id="l95.200" class="difflineplus">+      (eip = (PRLDAP_ErrorInfo*)prldap_get_thread_private(map-&gt;prtm_index)) !=</span>
<a href="#l95.201"></a><span id="l95.201">           NULL) {</span>
<a href="#l95.202"></a><span id="l95.202">     if (matchedp != NULL) {</span>
<a href="#l95.203"></a><span id="l95.203">       *matchedp = eip-&gt;plei_matched;</span>
<a href="#l95.204"></a><span id="l95.204">     }</span>
<a href="#l95.205"></a><span id="l95.205">     if (errmsgp != NULL) {</span>
<a href="#l95.206"></a><span id="l95.206">       *errmsgp = eip-&gt;plei_errmsg;</span>
<a href="#l95.207"></a><span id="l95.207">     }</span>
<a href="#l95.208"></a><span id="l95.208">     return (eip-&gt;plei_lderrno);</span>
<a href="#l95.209"></a><span id="l95.209" class="difflineat">@@ -238,36 +238,36 @@ static int prldap_get_ld_error(char **ma</span>
<a href="#l95.210"></a><span id="l95.210">     }</span>
<a href="#l95.211"></a><span id="l95.211">     if (errmsgp != NULL) {</span>
<a href="#l95.212"></a><span id="l95.212">       *errmsgp = NULL;</span>
<a href="#l95.213"></a><span id="l95.213">     }</span>
<a href="#l95.214"></a><span id="l95.214">     return (LDAP_LOCAL_ERROR); /* punt */</span>
<a href="#l95.215"></a><span id="l95.215">   }</span>
<a href="#l95.216"></a><span id="l95.216"> }</span>
<a href="#l95.217"></a><span id="l95.217"> </span>
<a href="#l95.218"></a><span id="l95.218" class="difflineminus">-static void prldap_set_ld_error(int err, char *matched, char *errmsg,</span>
<a href="#l95.219"></a><span id="l95.219" class="difflineminus">-                                void *errorarg) {</span>
<a href="#l95.220"></a><span id="l95.220" class="difflineminus">-  PRLDAP_TPDMap *map;</span>
<a href="#l95.221"></a><span id="l95.221" class="difflineminus">-  PRLDAP_ErrorInfo *eip;</span>
<a href="#l95.222"></a><span id="l95.222" class="difflineplus">+static void prldap_set_ld_error(int err, char* matched, char* errmsg,</span>
<a href="#l95.223"></a><span id="l95.223" class="difflineplus">+                                void* errorarg) {</span>
<a href="#l95.224"></a><span id="l95.224" class="difflineplus">+  PRLDAP_TPDMap* map;</span>
<a href="#l95.225"></a><span id="l95.225" class="difflineplus">+  PRLDAP_ErrorInfo* eip;</span>
<a href="#l95.226"></a><span id="l95.226"> </span>
<a href="#l95.227"></a><span id="l95.227" class="difflineminus">-  if ((map = (PRLDAP_TPDMap *)errorarg) != NULL) {</span>
<a href="#l95.228"></a><span id="l95.228" class="difflineminus">-    if ((eip = (PRLDAP_ErrorInfo *)prldap_get_thread_private(</span>
<a href="#l95.229"></a><span id="l95.229" class="difflineminus">-             map-&gt;prtm_index)) == NULL) {</span>
<a href="#l95.230"></a><span id="l95.230" class="difflineplus">+  if ((map = (PRLDAP_TPDMap*)errorarg) != NULL) {</span>
<a href="#l95.231"></a><span id="l95.231" class="difflineplus">+    if ((eip = (PRLDAP_ErrorInfo*)prldap_get_thread_private(map-&gt;prtm_index)) ==</span>
<a href="#l95.232"></a><span id="l95.232" class="difflineplus">+        NULL) {</span>
<a href="#l95.233"></a><span id="l95.233">       /*</span>
<a href="#l95.234"></a><span id="l95.234">        * Error info. has not yet been allocated for this thread.</span>
<a href="#l95.235"></a><span id="l95.235">        * Do so now.  Note that we free this memory only for the</span>
<a href="#l95.236"></a><span id="l95.236">        * thread that calls prldap_thread_dispose_handle(), which</span>
<a href="#l95.237"></a><span id="l95.237">        * should be the one that called ldap_unbind() -- see</span>
<a href="#l95.238"></a><span id="l95.238">        * prldap_return_map().  Not freeing the memory used by</span>
<a href="#l95.239"></a><span id="l95.239">        * other threads is deemed acceptable since it will be</span>
<a href="#l95.240"></a><span id="l95.240">        * recycled and used by other LDAP sessions.  All of the</span>
<a href="#l95.241"></a><span id="l95.241">        * thread-private memory is freed when a thread exits</span>
<a href="#l95.242"></a><span id="l95.242">        * (inside the prldap_tsd_destroy() function).</span>
<a href="#l95.243"></a><span id="l95.243">        */</span>
<a href="#l95.244"></a><span id="l95.244" class="difflineminus">-      eip = (PRLDAP_ErrorInfo *)PR_Calloc(1, sizeof(PRLDAP_ErrorInfo));</span>
<a href="#l95.245"></a><span id="l95.245" class="difflineplus">+      eip = (PRLDAP_ErrorInfo*)PR_Calloc(1, sizeof(PRLDAP_ErrorInfo));</span>
<a href="#l95.246"></a><span id="l95.246">       if (eip == NULL) {</span>
<a href="#l95.247"></a><span id="l95.247">         return; /* punt */</span>
<a href="#l95.248"></a><span id="l95.248">       }</span>
<a href="#l95.249"></a><span id="l95.249">       eip-&gt;plei_magic = PRLDAP_ERRORINFO_MAGIC;</span>
<a href="#l95.250"></a><span id="l95.250">       (void)prldap_set_thread_private(map-&gt;prtm_index, eip);</span>
<a href="#l95.251"></a><span id="l95.251">     }</span>
<a href="#l95.252"></a><span id="l95.252"> </span>
<a href="#l95.253"></a><span id="l95.253">     eip-&gt;plei_lderrno = err;</span>
<a href="#l95.254"></a><span id="l95.254" class="difflineat">@@ -283,17 +283,17 @@ static void prldap_set_ld_error(int err,</span>
<a href="#l95.255"></a><span id="l95.255">     eip-&gt;plei_errmsg = errmsg;</span>
<a href="#l95.256"></a><span id="l95.256">   }</span>
<a href="#l95.257"></a><span id="l95.257"> }</span>
<a href="#l95.258"></a><span id="l95.258"> </span>
<a href="#l95.259"></a><span id="l95.259"> /*</span>
<a href="#l95.260"></a><span id="l95.260">  * Utility function to free a PRLDAP_ErrorInfo structure and everything</span>
<a href="#l95.261"></a><span id="l95.261">  * it contains.</span>
<a href="#l95.262"></a><span id="l95.262">  */</span>
<a href="#l95.263"></a><span id="l95.263" class="difflineminus">-static void prldap_free_errorinfo(PRLDAP_ErrorInfo *eip) {</span>
<a href="#l95.264"></a><span id="l95.264" class="difflineplus">+static void prldap_free_errorinfo(PRLDAP_ErrorInfo* eip) {</span>
<a href="#l95.265"></a><span id="l95.265">   if (NULL != eip &amp;&amp; PRLDAP_ERRORINFO_MAGIC == eip-&gt;plei_magic) {</span>
<a href="#l95.266"></a><span id="l95.266">     if (eip-&gt;plei_matched != NULL) {</span>
<a href="#l95.267"></a><span id="l95.267">       ldap_memfree(eip-&gt;plei_matched);</span>
<a href="#l95.268"></a><span id="l95.268">     }</span>
<a href="#l95.269"></a><span id="l95.269">     if (eip-&gt;plei_errmsg != NULL) {</span>
<a href="#l95.270"></a><span id="l95.270">       ldap_memfree(eip-&gt;plei_errmsg);</span>
<a href="#l95.271"></a><span id="l95.271">     }</span>
<a href="#l95.272"></a><span id="l95.272"> </span>
<a href="#l95.273"></a><span id="l95.273" class="difflineat">@@ -303,43 +303,43 @@ static void prldap_free_errorinfo(PRLDAP</span>
<a href="#l95.274"></a><span id="l95.274"> </span>
<a href="#l95.275"></a><span id="l95.275"> /*</span>
<a href="#l95.276"></a><span id="l95.276">  * Called when a new LDAP * session handle is allocated.</span>
<a href="#l95.277"></a><span id="l95.277">  * Allocate thread-private data for error information, but only if</span>
<a href="#l95.278"></a><span id="l95.278">  * it has not already been allocated and the get_ld_error callback has</span>
<a href="#l95.279"></a><span id="l95.279">  * been installed.  If ld is not NULL when prldap_install_thread_functions()</span>
<a href="#l95.280"></a><span id="l95.280">  * is called, we will have already allocated the thread-private data there.</span>
<a href="#l95.281"></a><span id="l95.281">  */</span>
<a href="#l95.282"></a><span id="l95.282" class="difflineminus">-int prldap_thread_new_handle(LDAP *ld, void *sessionarg) {</span>
<a href="#l95.283"></a><span id="l95.283" class="difflineplus">+int prldap_thread_new_handle(LDAP* ld, void* sessionarg) {</span>
<a href="#l95.284"></a><span id="l95.284">   struct ldap_thread_fns tfns;</span>
<a href="#l95.285"></a><span id="l95.285"> </span>
<a href="#l95.286"></a><span id="l95.286" class="difflineminus">-  if (ldap_get_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void *)&amp;tfns) != 0) {</span>
<a href="#l95.287"></a><span id="l95.287" class="difflineplus">+  if (ldap_get_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void*)&amp;tfns) != 0) {</span>
<a href="#l95.288"></a><span id="l95.288">     return (LDAP_LOCAL_ERROR);</span>
<a href="#l95.289"></a><span id="l95.289">   }</span>
<a href="#l95.290"></a><span id="l95.290"> </span>
<a href="#l95.291"></a><span id="l95.291">   if (tfns.ltf_lderrno_arg == NULL &amp;&amp; tfns.ltf_get_lderrno != NULL) {</span>
<a href="#l95.292"></a><span id="l95.292" class="difflineminus">-    if ((tfns.ltf_lderrno_arg = (void *)prldap_allocate_map(ld)) == NULL ||</span>
<a href="#l95.293"></a><span id="l95.293" class="difflineminus">-        ldap_set_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void *)&amp;tfns) != 0) {</span>
<a href="#l95.294"></a><span id="l95.294" class="difflineplus">+    if ((tfns.ltf_lderrno_arg = (void*)prldap_allocate_map(ld)) == NULL ||</span>
<a href="#l95.295"></a><span id="l95.295" class="difflineplus">+        ldap_set_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void*)&amp;tfns) != 0) {</span>
<a href="#l95.296"></a><span id="l95.296">       return (LDAP_LOCAL_ERROR);</span>
<a href="#l95.297"></a><span id="l95.297">     }</span>
<a href="#l95.298"></a><span id="l95.298">   }</span>
<a href="#l95.299"></a><span id="l95.299"> </span>
<a href="#l95.300"></a><span id="l95.300">   return (LDAP_SUCCESS);</span>
<a href="#l95.301"></a><span id="l95.301"> }</span>
<a href="#l95.302"></a><span id="l95.302"> </span>
<a href="#l95.303"></a><span id="l95.303"> /*</span>
<a href="#l95.304"></a><span id="l95.304">  * Called when an LDAP * session handle is being destroyed.</span>
<a href="#l95.305"></a><span id="l95.305">  * Clean up our thread private data map.</span>
<a href="#l95.306"></a><span id="l95.306">  */</span>
<a href="#l95.307"></a><span id="l95.307" class="difflineminus">-void prldap_thread_dispose_handle(LDAP *ld, void *sessionarg) {</span>
<a href="#l95.308"></a><span id="l95.308" class="difflineplus">+void prldap_thread_dispose_handle(LDAP* ld, void* sessionarg) {</span>
<a href="#l95.309"></a><span id="l95.309">   struct ldap_thread_fns tfns;</span>
<a href="#l95.310"></a><span id="l95.310"> </span>
<a href="#l95.311"></a><span id="l95.311" class="difflineminus">-  if (ldap_get_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void *)&amp;tfns) == 0 &amp;&amp;</span>
<a href="#l95.312"></a><span id="l95.312" class="difflineplus">+  if (ldap_get_option(ld, LDAP_OPT_THREAD_FN_PTRS, (void*)&amp;tfns) == 0 &amp;&amp;</span>
<a href="#l95.313"></a><span id="l95.313">       tfns.ltf_lderrno_arg != NULL) {</span>
<a href="#l95.314"></a><span id="l95.314" class="difflineminus">-    prldap_return_map((PRLDAP_TPDMap *)tfns.ltf_lderrno_arg);</span>
<a href="#l95.315"></a><span id="l95.315" class="difflineplus">+    prldap_return_map((PRLDAP_TPDMap*)tfns.ltf_lderrno_arg);</span>
<a href="#l95.316"></a><span id="l95.316">   }</span>
<a href="#l95.317"></a><span id="l95.317"> }</span>
<a href="#l95.318"></a><span id="l95.318"> </span>
<a href="#l95.319"></a><span id="l95.319"> static PRStatus prldap_init_tpd(void) {</span>
<a href="#l95.320"></a><span id="l95.320">   if ((prldap_map_mutex = PR_NewLock()) == NULL ||</span>
<a href="#l95.321"></a><span id="l95.321">       PR_NewThreadPrivateIndex(&amp;prldap_tpdindex, prldap_tsd_destroy) !=</span>
<a href="#l95.322"></a><span id="l95.322">           PR_SUCCESS) {</span>
<a href="#l95.323"></a><span id="l95.323">     return (PR_FAILURE);</span>
<a href="#l95.324"></a><span id="l95.324" class="difflineat">@@ -351,17 +351,17 @@ static PRStatus prldap_init_tpd(void) {</span>
<a href="#l95.325"></a><span id="l95.325"> }</span>
<a href="#l95.326"></a><span id="l95.326"> </span>
<a href="#l95.327"></a><span id="l95.327"> /*</span>
<a href="#l95.328"></a><span id="l95.328">  * Function: prldap_allocate_map()</span>
<a href="#l95.329"></a><span id="l95.329">  * Description: allocate a thread-private data map to use for a new</span>
<a href="#l95.330"></a><span id="l95.330">  * LDAP session handle.</span>
<a href="#l95.331"></a><span id="l95.331">  * Returns: a pointer to the TPD map or NULL if none available.</span>
<a href="#l95.332"></a><span id="l95.332">  */</span>
<a href="#l95.333"></a><span id="l95.333" class="difflineminus">-static PRLDAP_TPDMap *prldap_allocate_map(LDAP *ld) {</span>
<a href="#l95.334"></a><span id="l95.334" class="difflineplus">+static PRLDAP_TPDMap* prldap_allocate_map(LDAP* ld) {</span>
<a href="#l95.335"></a><span id="l95.335">   PRLDAP_TPDMap *map, *prevmap;</span>
<a href="#l95.336"></a><span id="l95.336"> </span>
<a href="#l95.337"></a><span id="l95.337">   PR_Lock(prldap_map_mutex);</span>
<a href="#l95.338"></a><span id="l95.338"> </span>
<a href="#l95.339"></a><span id="l95.339">   /*</span>
<a href="#l95.340"></a><span id="l95.340">    * first look for a map that is already allocated but free to be re-used</span>
<a href="#l95.341"></a><span id="l95.341">    */</span>
<a href="#l95.342"></a><span id="l95.342">   prevmap = NULL;</span>
<a href="#l95.343"></a><span id="l95.343" class="difflineat">@@ -375,17 +375,17 @@ static PRLDAP_TPDMap *prldap_allocate_ma</span>
<a href="#l95.344"></a><span id="l95.344">   /*</span>
<a href="#l95.345"></a><span id="l95.345">    * if none was found (map == NULL), try to allocate a new one and add it</span>
<a href="#l95.346"></a><span id="l95.346">    * to the end of our global list.</span>
<a href="#l95.347"></a><span id="l95.347">    */</span>
<a href="#l95.348"></a><span id="l95.348">   if (map == NULL) {</span>
<a href="#l95.349"></a><span id="l95.349">     PRUintn tpdindex;</span>
<a href="#l95.350"></a><span id="l95.350"> </span>
<a href="#l95.351"></a><span id="l95.351">     tpdindex = prldap_new_tpdindex();</span>
<a href="#l95.352"></a><span id="l95.352" class="difflineminus">-    map = (PRLDAP_TPDMap *)PR_Malloc(sizeof(PRLDAP_TPDMap));</span>
<a href="#l95.353"></a><span id="l95.353" class="difflineplus">+    map = (PRLDAP_TPDMap*)PR_Malloc(sizeof(PRLDAP_TPDMap));</span>
<a href="#l95.354"></a><span id="l95.354">     if (map != NULL) {</span>
<a href="#l95.355"></a><span id="l95.355">       map-&gt;prtm_index = tpdindex;</span>
<a href="#l95.356"></a><span id="l95.356">       map-&gt;prtm_next = NULL;</span>
<a href="#l95.357"></a><span id="l95.357">       if (prevmap == NULL) {</span>
<a href="#l95.358"></a><span id="l95.358">         prldap_map_list = map;</span>
<a href="#l95.359"></a><span id="l95.359">       } else {</span>
<a href="#l95.360"></a><span id="l95.360">         prevmap-&gt;prtm_next = map;</span>
<a href="#l95.361"></a><span id="l95.361">       }</span>
<a href="#l95.362"></a><span id="l95.362" class="difflineat">@@ -410,27 +410,27 @@ static PRLDAP_TPDMap *prldap_allocate_ma</span>
<a href="#l95.363"></a><span id="l95.363">   return (map);</span>
<a href="#l95.364"></a><span id="l95.364"> }</span>
<a href="#l95.365"></a><span id="l95.365"> </span>
<a href="#l95.366"></a><span id="l95.366"> /*</span>
<a href="#l95.367"></a><span id="l95.367">  * Function: prldap_return_map()</span>
<a href="#l95.368"></a><span id="l95.368">  * Description: return a thread-private data map to the pool of ones</span>
<a href="#l95.369"></a><span id="l95.369">  * available for re-use.</span>
<a href="#l95.370"></a><span id="l95.370">  */</span>
<a href="#l95.371"></a><span id="l95.371" class="difflineminus">-static void prldap_return_map(PRLDAP_TPDMap *map) {</span>
<a href="#l95.372"></a><span id="l95.372" class="difflineminus">-  PRLDAP_ErrorInfo *eip;</span>
<a href="#l95.373"></a><span id="l95.373" class="difflineplus">+static void prldap_return_map(PRLDAP_TPDMap* map) {</span>
<a href="#l95.374"></a><span id="l95.374" class="difflineplus">+  PRLDAP_ErrorInfo* eip;</span>
<a href="#l95.375"></a><span id="l95.375"> </span>
<a href="#l95.376"></a><span id="l95.376">   PR_Lock(prldap_map_mutex);</span>
<a href="#l95.377"></a><span id="l95.377"> </span>
<a href="#l95.378"></a><span id="l95.378">   /*</span>
<a href="#l95.379"></a><span id="l95.379">    * Dispose of thread-private LDAP error information.  Note that this</span>
<a href="#l95.380"></a><span id="l95.380">    * only disposes of the memory consumed on THIS thread, but that is</span>
<a href="#l95.381"></a><span id="l95.381">    * okay.  See the comment in prldap_set_ld_error() for the reason why.</span>
<a href="#l95.382"></a><span id="l95.382">    */</span>
<a href="#l95.383"></a><span id="l95.383" class="difflineminus">-  if ((eip = (PRLDAP_ErrorInfo *)prldap_get_thread_private(map-&gt;prtm_index)) !=</span>
<a href="#l95.384"></a><span id="l95.384" class="difflineplus">+  if ((eip = (PRLDAP_ErrorInfo*)prldap_get_thread_private(map-&gt;prtm_index)) !=</span>
<a href="#l95.385"></a><span id="l95.385">           NULL &amp;&amp;</span>
<a href="#l95.386"></a><span id="l95.386">       prldap_set_thread_private(map-&gt;prtm_index, NULL) == 0) {</span>
<a href="#l95.387"></a><span id="l95.387">     prldap_free_errorinfo(eip);</span>
<a href="#l95.388"></a><span id="l95.388">   }</span>
<a href="#l95.389"></a><span id="l95.389"> </span>
<a href="#l95.390"></a><span id="l95.390">   /* mark map as available for re-use */</span>
<a href="#l95.391"></a><span id="l95.391">   map-&gt;prtm_ld = NULL;</span>
<a href="#l95.392"></a><span id="l95.392"> </span>
<a href="#l95.393"></a><span id="l95.393" class="difflineat">@@ -449,24 +449,24 @@ static PRUintn prldap_new_tpdindex(void)</span>
<a href="#l95.394"></a><span id="l95.394">   return (tpdindex);</span>
<a href="#l95.395"></a><span id="l95.395"> }</span>
<a href="#l95.396"></a><span id="l95.396"> </span>
<a href="#l95.397"></a><span id="l95.397"> /*</span>
<a href="#l95.398"></a><span id="l95.398">  * Function: prldap_set_thread_private()</span>
<a href="#l95.399"></a><span id="l95.399">  * Description: store a piece of thread-private data.</span>
<a href="#l95.400"></a><span id="l95.400">  * Returns: 0 if successful and -1 if not.</span>
<a href="#l95.401"></a><span id="l95.401">  */</span>
<a href="#l95.402"></a><span id="l95.402" class="difflineminus">-static int prldap_set_thread_private(PRInt32 tpdindex, void *priv) {</span>
<a href="#l95.403"></a><span id="l95.403" class="difflineminus">-  PRLDAP_TPDHeader *tsdhdr;</span>
<a href="#l95.404"></a><span id="l95.404" class="difflineplus">+static int prldap_set_thread_private(PRInt32 tpdindex, void* priv) {</span>
<a href="#l95.405"></a><span id="l95.405" class="difflineplus">+  PRLDAP_TPDHeader* tsdhdr;</span>
<a href="#l95.406"></a><span id="l95.406"> </span>
<a href="#l95.407"></a><span id="l95.407">   if (tpdindex &gt; prldap_tpd_maxindex) {</span>
<a href="#l95.408"></a><span id="l95.408">     return (-1); /* bad index */</span>
<a href="#l95.409"></a><span id="l95.409">   }</span>
<a href="#l95.410"></a><span id="l95.410"> </span>
<a href="#l95.411"></a><span id="l95.411" class="difflineminus">-  tsdhdr = (PRLDAP_TPDHeader *)PR_GetThreadPrivate(prldap_tpdindex);</span>
<a href="#l95.412"></a><span id="l95.412" class="difflineplus">+  tsdhdr = (PRLDAP_TPDHeader*)PR_GetThreadPrivate(prldap_tpdindex);</span>
<a href="#l95.413"></a><span id="l95.413">   if (tsdhdr == NULL || tpdindex &gt;= tsdhdr-&gt;ptpdh_tpd_count) {</span>
<a href="#l95.414"></a><span id="l95.414">     tsdhdr = prldap_tsd_realloc(tsdhdr, tpdindex);</span>
<a href="#l95.415"></a><span id="l95.415">     if (tsdhdr == NULL) {</span>
<a href="#l95.416"></a><span id="l95.416">       return (-1); /* realloc failed */</span>
<a href="#l95.417"></a><span id="l95.417">     }</span>
<a href="#l95.418"></a><span id="l95.418">   }</span>
<a href="#l95.419"></a><span id="l95.419"> </span>
<a href="#l95.420"></a><span id="l95.420">   tsdhdr-&gt;ptpdh_dataitems[tpdindex] = priv;</span>
<a href="#l95.421"></a><span id="l95.421" class="difflineat">@@ -474,20 +474,20 @@ static int prldap_set_thread_private(PRI</span>
<a href="#l95.422"></a><span id="l95.422"> }</span>
<a href="#l95.423"></a><span id="l95.423"> </span>
<a href="#l95.424"></a><span id="l95.424"> /*</span>
<a href="#l95.425"></a><span id="l95.425">  * Function: prldap_get_thread_private()</span>
<a href="#l95.426"></a><span id="l95.426">  * Description: retrieve a piece of thread-private data.  If not set,</span>
<a href="#l95.427"></a><span id="l95.427">  * NULL is returned.</span>
<a href="#l95.428"></a><span id="l95.428">  * Returns: 0 if successful and -1 if not.</span>
<a href="#l95.429"></a><span id="l95.429">  */</span>
<a href="#l95.430"></a><span id="l95.430" class="difflineminus">-static void *prldap_get_thread_private(PRInt32 tpdindex) {</span>
<a href="#l95.431"></a><span id="l95.431" class="difflineminus">-  PRLDAP_TPDHeader *tsdhdr;</span>
<a href="#l95.432"></a><span id="l95.432" class="difflineplus">+static void* prldap_get_thread_private(PRInt32 tpdindex) {</span>
<a href="#l95.433"></a><span id="l95.433" class="difflineplus">+  PRLDAP_TPDHeader* tsdhdr;</span>
<a href="#l95.434"></a><span id="l95.434"> </span>
<a href="#l95.435"></a><span id="l95.435" class="difflineminus">-  tsdhdr = (PRLDAP_TPDHeader *)PR_GetThreadPrivate(prldap_tpdindex);</span>
<a href="#l95.436"></a><span id="l95.436" class="difflineplus">+  tsdhdr = (PRLDAP_TPDHeader*)PR_GetThreadPrivate(prldap_tpdindex);</span>
<a href="#l95.437"></a><span id="l95.437">   if (tsdhdr == NULL) {</span>
<a href="#l95.438"></a><span id="l95.438">     return (NULL); /* no thread private data */</span>
<a href="#l95.439"></a><span id="l95.439">   }</span>
<a href="#l95.440"></a><span id="l95.440"> </span>
<a href="#l95.441"></a><span id="l95.441">   if (tpdindex &gt;= tsdhdr-&gt;ptpdh_tpd_count || tsdhdr-&gt;ptpdh_dataitems == NULL) {</span>
<a href="#l95.442"></a><span id="l95.442">     return (NULL); /* fewer data items than requested index */</span>
<a href="#l95.443"></a><span id="l95.443">   }</span>
<a href="#l95.444"></a><span id="l95.444"> </span>
<a href="#l95.445"></a><span id="l95.445" class="difflineat">@@ -495,19 +495,19 @@ static void *prldap_get_thread_private(P</span>
<a href="#l95.446"></a><span id="l95.446"> }</span>
<a href="#l95.447"></a><span id="l95.447"> </span>
<a href="#l95.448"></a><span id="l95.448"> /*</span>
<a href="#l95.449"></a><span id="l95.449">  * Function: prldap_tsd_realloc()</span>
<a href="#l95.450"></a><span id="l95.450">  * Description: enlarge the thread-private data array.</span>
<a href="#l95.451"></a><span id="l95.451">  * Returns: the new PRLDAP_TPDHeader value (non-NULL if successful).</span>
<a href="#l95.452"></a><span id="l95.452">  * Note: tsdhdr can be NULL (allocates a new PRLDAP_TPDHeader).</span>
<a href="#l95.453"></a><span id="l95.453">  */</span>
<a href="#l95.454"></a><span id="l95.454" class="difflineminus">-static PRLDAP_TPDHeader *prldap_tsd_realloc(PRLDAP_TPDHeader *tsdhdr,</span>
<a href="#l95.455"></a><span id="l95.455" class="difflineplus">+static PRLDAP_TPDHeader* prldap_tsd_realloc(PRLDAP_TPDHeader* tsdhdr,</span>
<a href="#l95.456"></a><span id="l95.456">                                             int maxindex) {</span>
<a href="#l95.457"></a><span id="l95.457" class="difflineminus">-  void *newdataitems = NULL;</span>
<a href="#l95.458"></a><span id="l95.458" class="difflineplus">+  void* newdataitems = NULL;</span>
<a href="#l95.459"></a><span id="l95.459">   int count;</span>
<a href="#l95.460"></a><span id="l95.460"> </span>
<a href="#l95.461"></a><span id="l95.461">   if (tsdhdr == NULL) {</span>
<a href="#l95.462"></a><span id="l95.462">     /* allocate a new thread private data header */</span>
<a href="#l95.463"></a><span id="l95.463">     if ((tsdhdr = PR_Calloc(1, sizeof(PRLDAP_TPDHeader))) == NULL) {</span>
<a href="#l95.464"></a><span id="l95.464">       return (NULL);</span>
<a href="#l95.465"></a><span id="l95.465">     }</span>
<a href="#l95.466"></a><span id="l95.466">     (void)PR_SetThreadPrivate(prldap_tpdindex, tsdhdr);</span>
<a href="#l95.467"></a><span id="l95.467" class="difflineat">@@ -517,50 +517,50 @@ static PRLDAP_TPDHeader *prldap_tsd_real</span>
<a href="#l95.468"></a><span id="l95.468">    * Make the size of the new array the next highest multiple of</span>
<a href="#l95.469"></a><span id="l95.469">    * the array increment value that is greater than maxindex.</span>
<a href="#l95.470"></a><span id="l95.470">    */</span>
<a href="#l95.471"></a><span id="l95.471">   count = PRLDAP_TPD_ARRAY_INCREMENT *</span>
<a href="#l95.472"></a><span id="l95.472">           (1 + (maxindex / PRLDAP_TPD_ARRAY_INCREMENT));</span>
<a href="#l95.473"></a><span id="l95.473"> </span>
<a href="#l95.474"></a><span id="l95.474">   /* increase the size of the data item array if necessary */</span>
<a href="#l95.475"></a><span id="l95.475">   if (count &gt; tsdhdr-&gt;ptpdh_tpd_count) {</span>
<a href="#l95.476"></a><span id="l95.476" class="difflineminus">-    newdataitems = (PRLDAP_ErrorInfo *)PR_Calloc(count, sizeof(void *));</span>
<a href="#l95.477"></a><span id="l95.477" class="difflineplus">+    newdataitems = (PRLDAP_ErrorInfo*)PR_Calloc(count, sizeof(void*));</span>
<a href="#l95.478"></a><span id="l95.478">     if (newdataitems == NULL) {</span>
<a href="#l95.479"></a><span id="l95.479">       return (NULL);</span>
<a href="#l95.480"></a><span id="l95.480">     }</span>
<a href="#l95.481"></a><span id="l95.481">     if (tsdhdr-&gt;ptpdh_dataitems != NULL) { /* preserve old data */</span>
<a href="#l95.482"></a><span id="l95.482">       memcpy(newdataitems, tsdhdr-&gt;ptpdh_dataitems,</span>
<a href="#l95.483"></a><span id="l95.483" class="difflineminus">-             tsdhdr-&gt;ptpdh_tpd_count * sizeof(void *));</span>
<a href="#l95.484"></a><span id="l95.484" class="difflineplus">+             tsdhdr-&gt;ptpdh_tpd_count * sizeof(void*));</span>
<a href="#l95.485"></a><span id="l95.485">       PR_Free(tsdhdr-&gt;ptpdh_dataitems);</span>
<a href="#l95.486"></a><span id="l95.486">     }</span>
<a href="#l95.487"></a><span id="l95.487"> </span>
<a href="#l95.488"></a><span id="l95.488">     tsdhdr-&gt;ptpdh_tpd_count = count;</span>
<a href="#l95.489"></a><span id="l95.489">     tsdhdr-&gt;ptpdh_dataitems = newdataitems;</span>
<a href="#l95.490"></a><span id="l95.490">   }</span>
<a href="#l95.491"></a><span id="l95.491"> </span>
<a href="#l95.492"></a><span id="l95.492">   return (tsdhdr);</span>
<a href="#l95.493"></a><span id="l95.493"> }</span>
<a href="#l95.494"></a><span id="l95.494"> </span>
<a href="#l95.495"></a><span id="l95.495"> /*</span>
<a href="#l95.496"></a><span id="l95.496">  * Function: prldap_tsd_destroy()</span>
<a href="#l95.497"></a><span id="l95.497">  * Description: Free a thread-private data array. Installed as an NSPR TPD</span>
<a href="#l95.498"></a><span id="l95.498">  * destructor function</span>
<a href="#l95.499"></a><span id="l95.499">  * Returns: nothing.</span>
<a href="#l95.500"></a><span id="l95.500">  */</span>
<a href="#l95.501"></a><span id="l95.501" class="difflineminus">-static void prldap_tsd_destroy(void *priv) {</span>
<a href="#l95.502"></a><span id="l95.502" class="difflineminus">-  PRLDAP_TPDHeader *tsdhdr;</span>
<a href="#l95.503"></a><span id="l95.503" class="difflineminus">-  PRLDAP_ErrorInfo *eip;</span>
<a href="#l95.504"></a><span id="l95.504" class="difflineplus">+static void prldap_tsd_destroy(void* priv) {</span>
<a href="#l95.505"></a><span id="l95.505" class="difflineplus">+  PRLDAP_TPDHeader* tsdhdr;</span>
<a href="#l95.506"></a><span id="l95.506" class="difflineplus">+  PRLDAP_ErrorInfo* eip;</span>
<a href="#l95.507"></a><span id="l95.507">   int i;</span>
<a href="#l95.508"></a><span id="l95.508"> </span>
<a href="#l95.509"></a><span id="l95.509" class="difflineminus">-  tsdhdr = (PRLDAP_TPDHeader *)priv;</span>
<a href="#l95.510"></a><span id="l95.510" class="difflineplus">+  tsdhdr = (PRLDAP_TPDHeader*)priv;</span>
<a href="#l95.511"></a><span id="l95.511">   if (tsdhdr != NULL) {</span>
<a href="#l95.512"></a><span id="l95.512">     if (tsdhdr-&gt;ptpdh_dataitems != NULL) {</span>
<a href="#l95.513"></a><span id="l95.513">       for (i = 0; i &lt; tsdhdr-&gt;ptpdh_tpd_count; ++i) {</span>
<a href="#l95.514"></a><span id="l95.514">         if (tsdhdr-&gt;ptpdh_dataitems[i] != NULL) {</span>
<a href="#l95.515"></a><span id="l95.515" class="difflineminus">-          eip = (PRLDAP_ErrorInfo *)tsdhdr-&gt;ptpdh_dataitems[i];</span>
<a href="#l95.516"></a><span id="l95.516" class="difflineplus">+          eip = (PRLDAP_ErrorInfo*)tsdhdr-&gt;ptpdh_dataitems[i];</span>
<a href="#l95.517"></a><span id="l95.517">           if (PRLDAP_ERRORINFO_MAGIC == eip-&gt;plei_magic) {</span>
<a href="#l95.518"></a><span id="l95.518">             prldap_free_errorinfo(eip);</span>
<a href="#l95.519"></a><span id="l95.519">           } else {</span>
<a href="#l95.520"></a><span id="l95.520">             PR_Free(tsdhdr-&gt;ptpdh_dataitems[i]);</span>
<a href="#l95.521"></a><span id="l95.521">           }</span>
<a href="#l95.522"></a><span id="l95.522">           tsdhdr-&gt;ptpdh_dataitems[i] = NULL;</span>
<a href="#l95.523"></a><span id="l95.523">         }</span>
<a href="#l95.524"></a><span id="l95.524">       }</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:33Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

