<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 17723:76d3068017576925b331610a016ad39b85a2c147</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 76d3068017576925b331610a016ad39b85a2c147" />
<meta property="og:url" content="/comm-central/rev/76d3068017576925b331610a016ad39b85a2c147" />
<meta property="og:description" content="Bug 1150176: Remove now-dead allocators from comm-central to help reopen a CLOSED TREE, r=rkent" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 76d3068017576925b331610a016ad39b85a2c147 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/76d3068017576925b331610a016ad39b85a2c147">shortlog</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/76d3068017576925b331610a016ad39b85a2c147">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147">files</a> |
changeset |
<a href="/comm-central/raw-rev/76d3068017576925b331610a016ad39b85a2c147">raw</a>  | <a href="/comm-central/archive/76d3068017576925b331610a016ad39b85a2c147.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1150176">Bug 1150176</a>: Remove now-dead allocators from comm-central to help reopen a CLOSED TREE, r=rkent
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#115;&#104;&#117;&#97;&#32;&#67;&#114;&#97;&#110;&#109;&#101;&#114;&#32;&#60;&#80;&#105;&#100;&#103;&#101;&#111;&#116;&#49;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Thu, 02 Apr 2015 12:18:38 -0500</td></tr>

<tr>
 <td>changeset 17723</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/76d3068017576925b331610a016ad39b85a2c147">76d3068017576925b331610a016ad39b85a2c147</a></td>
</tr>



<tr>
<td>parent 17722</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/ce064c0d550b56f501ad16dd7d1109a04e8ea30d">ce064c0d550b56f501ad16dd7d1109a04e8ea30d</a>
</td>
</tr>

<tr>
<td>child 17724</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/1cc7a71a04355c949421c3789386c48af37f5f3b">1cc7a71a04355c949421c3789386c48af37f5f3b</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=76d3068017576925b331610a016ad39b85a2c147">10918</a></td></tr>
<tr><td>push user</td><td>Pidgeot18@gmail.com</td></tr>
<tr><td>push date</td><td class="date age">Thu, 02 Apr 2015 17:19:55 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@76d306801757 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=76d3068017576925b331610a016ad39b85a2c147">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=76d3068017576925b331610a016ad39b85a2c147&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=76d3068017576925b331610a016ad39b85a2c147&newProject=comm-central&newRevision=76d3068017576925b331610a016ad39b85a2c147&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=76d3068017576925b331610a016ad39b85a2c147&newProject=comm-central&newRevision=76d3068017576925b331610a016ad39b85a2c147&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=76d3068017576925b331610a016ad39b85a2c147&newProject=comm-central&newRevision=76d3068017576925b331610a016ad39b85a2c147&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28rkent%29&revcount=50">rkent</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1150176">1150176</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1150176">Bug 1150176</a>: Remove now-dead allocators from comm-central to help reopen a CLOSED TREE, r=rkent</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calICSService.cpp">calendar/base/backend/libical/calICSService.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calICSService.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calICSService.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calICSService.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calICSService.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calICSService.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calRecurrenceRule.cpp">calendar/base/backend/libical/calRecurrenceRule.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calRecurrenceRule.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calRecurrenceRule.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calRecurrenceRule.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calRecurrenceRule.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/calendar/base/backend/libical/calRecurrenceRule.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPBERValue.cpp">ldap/xpcom/src/nsLDAPBERValue.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPBERValue.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPBERValue.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPBERValue.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPBERValue.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPBERValue.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPMessage.cpp">ldap/xpcom/src/nsLDAPMessage.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPMessage.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPMessage.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPMessage.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPMessage.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPMessage.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPOperation.cpp">ldap/xpcom/src/nsLDAPOperation.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPOperation.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPOperation.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPOperation.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPOperation.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPOperation.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPSecurityGlue.cpp">ldap/xpcom/src/nsLDAPSecurityGlue.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPSecurityGlue.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPSecurityGlue.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPSecurityGlue.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPSecurityGlue.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPSecurityGlue.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPService.cpp">ldap/xpcom/src/nsLDAPService.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPService.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPService.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPService.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPService.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/ldap/xpcom/src/nsLDAPService.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDAPDirectory.cpp">mailnews/addrbook/src/nsAbLDAPDirectory.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDAPDirectory.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDAPDirectory.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDAPDirectory.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDAPDirectory.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDAPDirectory.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDIFService.cpp">mailnews/addrbook/src/nsAbLDIFService.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDIFService.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDIFService.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDIFService.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDIFService.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbLDIFService.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbUtils.h">mailnews/addrbook/src/nsAbUtils.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbUtils.h">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbUtils.h">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbUtils.h">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbUtils.h">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbUtils.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbView.cpp">mailnews/addrbook/src/nsAbView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbView.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbView.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbView.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbView.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsAbView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsDirPrefs.cpp">mailnews/addrbook/src/nsDirPrefs.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsDirPrefs.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsDirPrefs.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsDirPrefs.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsDirPrefs.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/addrbook/src/nsDirPrefs.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgFilterList.cpp">mailnews/base/search/src/nsMsgFilterList.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgFilterList.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgFilterList.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgFilterList.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgFilterList.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgFilterList.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchAdapter.cpp">mailnews/base/search/src/nsMsgSearchAdapter.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchAdapter.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchAdapter.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchAdapter.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchAdapter.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchAdapter.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchNews.cpp">mailnews/base/search/src/nsMsgSearchNews.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchNews.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchNews.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchNews.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchNews.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/search/src/nsMsgSearchNews.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMessenger.cpp">mailnews/base/src/nsMessenger.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMessenger.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMessenger.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMessenger.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMessenger.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMessenger.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMsgDBView.cpp">mailnews/base/src/nsMsgDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMsgDBView.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMsgDBView.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMsgDBView.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMsgDBView.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/src/nsMsgDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgDBFolder.cpp">mailnews/base/util/nsMsgDBFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgDBFolder.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgDBFolder.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgDBFolder.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgDBFolder.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgDBFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgKeySet.cpp">mailnews/base/util/nsMsgKeySet.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgKeySet.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgKeySet.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgKeySet.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgKeySet.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgKeySet.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgProtocol.cpp">mailnews/base/util/nsMsgProtocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgProtocol.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgProtocol.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgProtocol.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgProtocol.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgProtocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgUtils.cpp">mailnews/base/util/nsMsgUtils.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgUtils.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgUtils.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgUtils.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgUtils.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/base/util/nsMsgUtils.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgCompose.cpp">mailnews/compose/src/nsMsgCompose.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgCompose.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgCompose.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgCompose.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgCompose.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgCompose.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgComposeService.cpp">mailnews/compose/src/nsMsgComposeService.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgComposeService.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgComposeService.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgComposeService.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgComposeService.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgComposeService.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgSend.cpp">mailnews/compose/src/nsMsgSend.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgSend.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgSend.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgSend.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgSend.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/compose/src/nsMsgSend.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/public/nsIMsgDatabase.idl">mailnews/db/msgdb/public/nsIMsgDatabase.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/public/nsIMsgDatabase.idl">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/public/nsIMsgDatabase.idl">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/public/nsIMsgDatabase.idl">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/public/nsIMsgDatabase.idl">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/public/nsIMsgDatabase.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/src/nsMsgDatabase.cpp">mailnews/db/msgdb/src/nsMsgDatabase.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/src/nsMsgDatabase.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/src/nsMsgDatabase.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/src/nsMsgDatabase.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/src/nsMsgDatabase.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/db/msgdb/src/nsMsgDatabase.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/bayesian-spam-filter/src/nsBayesianFilter.cpp">mailnews/extensions/bayesian-spam-filter/src/nsBayesianFilter.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/bayesian-spam-filter/src/nsBayesianFilter.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/bayesian-spam-filter/src/nsBayesianFilter.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/bayesian-spam-filter/src/nsBayesianFilter.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/bayesian-spam-filter/src/nsBayesianFilter.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/bayesian-spam-filter/src/nsBayesianFilter.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/smime/src/nsSMimeJSHelper.cpp">mailnews/extensions/smime/src/nsSMimeJSHelper.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/smime/src/nsSMimeJSHelper.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/smime/src/nsSMimeJSHelper.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/smime/src/nsSMimeJSHelper.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/smime/src/nsSMimeJSHelper.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/extensions/smime/src/nsSMimeJSHelper.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapMailFolder.cpp">mailnews/imap/src/nsImapMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapProtocol.cpp">mailnews/imap/src/nsImapProtocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapProtocol.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapProtocol.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapProtocol.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapProtocol.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapProtocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapUrl.cpp">mailnews/imap/src/nsImapUrl.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapUrl.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapUrl.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapUrl.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapUrl.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/imap/src/nsImapUrl.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/import/outlook/src/MapiApi.cpp">mailnews/import/outlook/src/MapiApi.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/import/outlook/src/MapiApi.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/import/outlook/src/MapiApi.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/import/outlook/src/MapiApi.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/import/outlook/src/MapiApi.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/import/outlook/src/MapiApi.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/local/src/nsLocalMailFolder.cpp">mailnews/local/src/nsLocalMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/local/src/nsLocalMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/local/src/nsLocalMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/local/src/nsLocalMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/local/src/nsLocalMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/local/src/nsLocalMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">mailnews/mime/emitters/nsMimeHtmlEmitter.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimehdrs.cpp">mailnews/mime/src/mimehdrs.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimehdrs.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimehdrs.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimehdrs.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimehdrs.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimehdrs.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimemoz2.cpp">mailnews/mime/src/mimemoz2.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimemoz2.cpp">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimemoz2.cpp">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimemoz2.cpp">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimemoz2.cpp">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/mimemoz2.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/modlmime.h">mailnews/mime/src/modlmime.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/modlmime.h">file</a> |
<a href="/comm-central/annotate/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/modlmime.h">annotate</a> |
<a href="/comm-central/diff/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/modlmime.h">diff</a> |
<a href="/comm-central/comparison/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/modlmime.h">comparison</a> |
<a href="/comm-central/log/76d3068017576925b331610a016ad39b85a2c147/mailnews/mime/src/modlmime.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/calendar/base/backend/libical/calICSService.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/calendar/base/backend/libical/calICSService.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -524,17 +524,17 @@ calIcalComponent::GetReferencedTimezones</span>
<a href="#l1.4"></a><span id="l1.4">     uint32_t const count = mReferencedTimezones.Count();</span>
<a href="#l1.5"></a><span id="l1.5">     if (count == 0) {</span>
<a href="#l1.6"></a><span id="l1.6">         *aCount = 0;</span>
<a href="#l1.7"></a><span id="l1.7">         *aTimezones = nullptr;</span>
<a href="#l1.8"></a><span id="l1.8">         return NS_OK;</span>
<a href="#l1.9"></a><span id="l1.9">     }</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11">     calITimezone ** const timezones = static_cast&lt;calITimezone **&gt;(</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-        nsMemory::Alloc(sizeof(calITimezone *) * count));</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+        moz_xmalloc(sizeof(calITimezone *) * count));</span>
<a href="#l1.14"></a><span id="l1.14">     CAL_ENSURE_MEMORY(timezones);</span>
<a href="#l1.15"></a><span id="l1.15">     // tzptr will get used as an iterator by the enumerator function</span>
<a href="#l1.16"></a><span id="l1.16">     calITimezone ** tzptr = timezones;</span>
<a href="#l1.17"></a><span id="l1.17">     mReferencedTimezones.EnumerateRead(TimezoneHashToTimezoneArray, &amp;tzptr);</span>
<a href="#l1.18"></a><span id="l1.18"> </span>
<a href="#l1.19"></a><span id="l1.19">     *aTimezones = timezones;</span>
<a href="#l1.20"></a><span id="l1.20">     *aCount = count;</span>
<a href="#l1.21"></a><span id="l1.21">     return NS_OK;</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -1104,17 +1104,17 @@ calIcalComponent::AddSubcomponent(calIIc</span>
<a href="#l1.23"></a><span id="l1.23">             rv = vcal-&gt;AddTimezoneReference(timezones[i]);</span>
<a href="#l1.24"></a><span id="l1.24">             if (NS_FAILED(rv))</span>
<a href="#l1.25"></a><span id="l1.25">                 failed = true;</span>
<a href="#l1.26"></a><span id="l1.26">         }</span>
<a href="#l1.27"></a><span id="l1.27"> </span>
<a href="#l1.28"></a><span id="l1.28">         NS_RELEASE(timezones[i]);</span>
<a href="#l1.29"></a><span id="l1.29">     }</span>
<a href="#l1.30"></a><span id="l1.30"> </span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-    nsMemory::Free(timezones);</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+    free(timezones);</span>
<a href="#l1.33"></a><span id="l1.33"> </span>
<a href="#l1.34"></a><span id="l1.34">     if (failed)</span>
<a href="#l1.35"></a><span id="l1.35">         return rv;</span>
<a href="#l1.36"></a><span id="l1.36"> </span>
<a href="#l1.37"></a><span id="l1.37">     if (ical-&gt;mParent) {</span>
<a href="#l1.38"></a><span id="l1.38">         ical-&gt;mComponent = icalcomponent_new_clone(ical-&gt;mComponent);</span>
<a href="#l1.39"></a><span id="l1.39">     }</span>
<a href="#l1.40"></a><span id="l1.40">     ical-&gt;mParent = this;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/calendar/base/backend/libical/calRecurrenceRule.cpp</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/calendar/base/backend/libical/calRecurrenceRule.cpp</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -496,17 +496,17 @@ calRecurrenceRule::GetOccurrences(calIDa</span>
<a href="#l2.4"></a><span id="l2.4">         if (aMaxCount &amp;&amp; aMaxCount &lt;= count)</span>
<a href="#l2.5"></a><span id="l2.5">             break;</span>
<a href="#l2.6"></a><span id="l2.6">     }</span>
<a href="#l2.7"></a><span id="l2.7"> </span>
<a href="#l2.8"></a><span id="l2.8">     icalrecur_iterator_free(recur_iter);</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10">     if (count) {</span>
<a href="#l2.11"></a><span id="l2.11">         calIDateTime ** const dateArray =</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-            static_cast&lt;calIDateTime **&gt;(nsMemory::Alloc(sizeof(calIDateTime*) * count));</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+            static_cast&lt;calIDateTime **&gt;(moz_xmalloc(sizeof(calIDateTime*) * count));</span>
<a href="#l2.14"></a><span id="l2.14">         CAL_ENSURE_MEMORY(dateArray);</span>
<a href="#l2.15"></a><span id="l2.15">         for (uint32_t i = 0; i &lt; count; ++i) {</span>
<a href="#l2.16"></a><span id="l2.16">             NS_ADDREF(dateArray[i] = dates[i]);</span>
<a href="#l2.17"></a><span id="l2.17">         }</span>
<a href="#l2.18"></a><span id="l2.18">         *aDates = dateArray;</span>
<a href="#l2.19"></a><span id="l2.19">     } else {</span>
<a href="#l2.20"></a><span id="l2.20">         *aDates = nullptr;</span>
<a href="#l2.21"></a><span id="l2.21">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/ldap/xpcom/src/nsLDAPBERValue.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/ldap/xpcom/src/nsLDAPBERValue.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -12,31 +12,31 @@ NS_IMPL_ISUPPORTS(nsLDAPBERValue, nsILDA</span>
<a href="#l3.4"></a><span id="l3.4"> </span>
<a href="#l3.5"></a><span id="l3.5"> nsLDAPBERValue::nsLDAPBERValue() : mValue(0), mSize(0)</span>
<a href="#l3.6"></a><span id="l3.6"> {</span>
<a href="#l3.7"></a><span id="l3.7"> }</span>
<a href="#l3.8"></a><span id="l3.8"> </span>
<a href="#l3.9"></a><span id="l3.9"> nsLDAPBERValue::~nsLDAPBERValue()</span>
<a href="#l3.10"></a><span id="l3.10"> {</span>
<a href="#l3.11"></a><span id="l3.11">     if (mValue) {</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-        nsMemory::Free(mValue);</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+        free(mValue);</span>
<a href="#l3.14"></a><span id="l3.14">     }</span>
<a href="#l3.15"></a><span id="l3.15"> }</span>
<a href="#l3.16"></a><span id="l3.16"> </span>
<a href="#l3.17"></a><span id="l3.17"> // void get (out unsigned long aCount, </span>
<a href="#l3.18"></a><span id="l3.18"> //           [array, size_is (aCount), retval] out octet aRetVal); */</span>
<a href="#l3.19"></a><span id="l3.19"> NS_IMETHODIMP </span>
<a href="#l3.20"></a><span id="l3.20"> nsLDAPBERValue::Get(uint32_t *aCount, uint8_t **aRetVal)</span>
<a href="#l3.21"></a><span id="l3.21"> {</span>
<a href="#l3.22"></a><span id="l3.22">     // if mSize = 0, return a count of a 0 and a null pointer</span>
<a href="#l3.23"></a><span id="l3.23"> </span>
<a href="#l3.24"></a><span id="l3.24">     if (mSize) {</span>
<a href="#l3.25"></a><span id="l3.25">         // get a buffer to hold a copy of the data</span>
<a href="#l3.26"></a><span id="l3.26">         //</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineminus">-        uint8_t *array = static_cast&lt;uint8_t *&gt;(nsMemory::Alloc(mSize));</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+        uint8_t *array = static_cast&lt;uint8_t *&gt;(moz_xmalloc(mSize));</span>
<a href="#l3.29"></a><span id="l3.29"> </span>
<a href="#l3.30"></a><span id="l3.30">         if (!array) {</span>
<a href="#l3.31"></a><span id="l3.31">             return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.32"></a><span id="l3.32">         }</span>
<a href="#l3.33"></a><span id="l3.33">     </span>
<a href="#l3.34"></a><span id="l3.34">         // copy and return</span>
<a href="#l3.35"></a><span id="l3.35">         //</span>
<a href="#l3.36"></a><span id="l3.36">         memcpy(array, mValue, mSize);</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineat">@@ -52,25 +52,25 @@ nsLDAPBERValue::Get(uint32_t *aCount, ui</span>
<a href="#l3.38"></a><span id="l3.38"> // void set(in unsigned long aCount, </span>
<a href="#l3.39"></a><span id="l3.39"> //          [array, size_is(aCount)] in octet aValue);</span>
<a href="#l3.40"></a><span id="l3.40"> NS_IMETHODIMP</span>
<a href="#l3.41"></a><span id="l3.41"> nsLDAPBERValue::Set(uint32_t aCount, uint8_t *aValue)</span>
<a href="#l3.42"></a><span id="l3.42"> {</span>
<a href="#l3.43"></a><span id="l3.43">     // get rid of any old value being held here</span>
<a href="#l3.44"></a><span id="l3.44">     //</span>
<a href="#l3.45"></a><span id="l3.45">     if (mValue) {</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineminus">-        nsMemory::Free(mValue);</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+        free(mValue);</span>
<a href="#l3.48"></a><span id="l3.48">     }</span>
<a href="#l3.49"></a><span id="l3.49"> </span>
<a href="#l3.50"></a><span id="l3.50">     // if this is a non-zero value, allocate a buffer and copy</span>
<a href="#l3.51"></a><span id="l3.51">     //</span>
<a href="#l3.52"></a><span id="l3.52">     if (aCount) { </span>
<a href="#l3.53"></a><span id="l3.53">         // get a buffer to hold a copy of this data</span>
<a href="#l3.54"></a><span id="l3.54">         //</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineminus">-        mValue = static_cast&lt;uint8_t *&gt;(nsMemory::Alloc(aCount));</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+        mValue = static_cast&lt;uint8_t *&gt;(moz_xmalloc(aCount));</span>
<a href="#l3.57"></a><span id="l3.57">         if (!mValue) {</span>
<a href="#l3.58"></a><span id="l3.58">             return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.59"></a><span id="l3.59">         }</span>
<a href="#l3.60"></a><span id="l3.60"> </span>
<a href="#l3.61"></a><span id="l3.61">         // copy the data and return</span>
<a href="#l3.62"></a><span id="l3.62">         //</span>
<a href="#l3.63"></a><span id="l3.63">         memcpy(mValue, aValue, aCount);</span>
<a href="#l3.64"></a><span id="l3.64">     } else {</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineat">@@ -86,17 +86,17 @@ nsLDAPBERValue::Set(uint32_t aCount, uin</span>
<a href="#l3.66"></a><span id="l3.66"> // void setFromUTF8(in AUTF8String aValue);</span>
<a href="#l3.67"></a><span id="l3.67"> //</span>
<a href="#l3.68"></a><span id="l3.68"> NS_IMETHODIMP</span>
<a href="#l3.69"></a><span id="l3.69"> nsLDAPBERValue::SetFromUTF8(const nsACString &amp; aValue)</span>
<a href="#l3.70"></a><span id="l3.70"> {</span>
<a href="#l3.71"></a><span id="l3.71">     // get rid of any old value being held here</span>
<a href="#l3.72"></a><span id="l3.72">     //</span>
<a href="#l3.73"></a><span id="l3.73">     if (mValue) {</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineminus">-        nsMemory::Free(mValue);</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+        free(mValue);</span>
<a href="#l3.76"></a><span id="l3.76">     }</span>
<a href="#l3.77"></a><span id="l3.77"> </span>
<a href="#l3.78"></a><span id="l3.78">     // copy the data and return</span>
<a href="#l3.79"></a><span id="l3.79">     //</span>
<a href="#l3.80"></a><span id="l3.80">     mSize = aValue.Length();</span>
<a href="#l3.81"></a><span id="l3.81">     if (mSize) {</span>
<a href="#l3.82"></a><span id="l3.82">         mValue = reinterpret_cast&lt;uint8_t *&gt;(ToNewCString(aValue));</span>
<a href="#l3.83"></a><span id="l3.83">     } else {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/ldap/xpcom/src/nsLDAPMessage.cpp</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/ldap/xpcom/src/nsLDAPMessage.cpp</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -317,17 +317,17 @@ nsLDAPMessage::IterateAttributes(uint32_</span>
<a href="#l4.4"></a><span id="l4.4">         *aAttrCount = 0;</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6">         rv = IterateAttributes(aAttrCount, aAttributes, false);</span>
<a href="#l4.7"></a><span id="l4.7">         if (NS_FAILED(rv))</span>
<a href="#l4.8"></a><span id="l4.8">             return rv;</span>
<a href="#l4.9"></a><span id="l4.9"> </span>
<a href="#l4.10"></a><span id="l4.10">         // create an array of the appropriate size</span>
<a href="#l4.11"></a><span id="l4.11">         //</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-        *aAttributes = static_cast&lt;char **&gt;(nsMemory::Alloc(*aAttrCount *</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+        *aAttributes = static_cast&lt;char **&gt;(moz_xmalloc(*aAttrCount *</span>
<a href="#l4.14"></a><span id="l4.14">                                                       sizeof(char *)));</span>
<a href="#l4.15"></a><span id="l4.15">         if (!*aAttributes) {</span>
<a href="#l4.16"></a><span id="l4.16">             return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l4.17"></a><span id="l4.17">         }</span>
<a href="#l4.18"></a><span id="l4.18">     } </span>
<a href="#l4.19"></a><span id="l4.19"> </span>
<a href="#l4.20"></a><span id="l4.20">     // get the first attribute</span>
<a href="#l4.21"></a><span id="l4.21">     //</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineat">@@ -340,17 +340,17 @@ nsLDAPMessage::IterateAttributes(uint32_</span>
<a href="#l4.23"></a><span id="l4.23">     }</span>
<a href="#l4.24"></a><span id="l4.24"> </span>
<a href="#l4.25"></a><span id="l4.25">     // if we're getting attributes, try and fill in the first field</span>
<a href="#l4.26"></a><span id="l4.26">     //</span>
<a href="#l4.27"></a><span id="l4.27">     if (getP) {</span>
<a href="#l4.28"></a><span id="l4.28">         (*aAttributes)[0] = NS_strdup(attr);</span>
<a href="#l4.29"></a><span id="l4.29">         if (!(*aAttributes)[0]) {</span>
<a href="#l4.30"></a><span id="l4.30">             ldap_memfree(attr);</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">-            nsMemory::Free(*aAttributes);</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+            free(*aAttributes);</span>
<a href="#l4.33"></a><span id="l4.33">             return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l4.34"></a><span id="l4.34">         }</span>
<a href="#l4.35"></a><span id="l4.35"> </span>
<a href="#l4.36"></a><span id="l4.36">         // note that we start counting again, in order to keep our place in </span>
<a href="#l4.37"></a><span id="l4.37">         // the array so that we can unwind gracefully and avoid leakage if</span>
<a href="#l4.38"></a><span id="l4.38">         // we hit an error as we're filling in the array</span>
<a href="#l4.39"></a><span id="l4.39">         //</span>
<a href="#l4.40"></a><span id="l4.40">         *aAttrCount = 1;</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineat">@@ -486,17 +486,17 @@ nsLDAPMessage::GetValues(const char *aAt</span>
<a href="#l4.42"></a><span id="l4.42">     }</span>
<a href="#l4.43"></a><span id="l4.43"> </span>
<a href="#l4.44"></a><span id="l4.44">     // count the values</span>
<a href="#l4.45"></a><span id="l4.45">     //</span>
<a href="#l4.46"></a><span id="l4.46">     uint32_t numVals = ldap_count_values(values);</span>
<a href="#l4.47"></a><span id="l4.47"> </span>
<a href="#l4.48"></a><span id="l4.48">     // create an array of the appropriate size</span>
<a href="#l4.49"></a><span id="l4.49">     //</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineminus">-    *aValues = static_cast&lt;char16_t **&gt;(nsMemory::Alloc(numVals * sizeof(char16_t *)));</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+    *aValues = static_cast&lt;char16_t **&gt;(moz_xmalloc(numVals * sizeof(char16_t *)));</span>
<a href="#l4.52"></a><span id="l4.52">     if (!*aValues) {</span>
<a href="#l4.53"></a><span id="l4.53">         ldap_value_free(values);</span>
<a href="#l4.54"></a><span id="l4.54">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l4.55"></a><span id="l4.55">     }</span>
<a href="#l4.56"></a><span id="l4.56"> </span>
<a href="#l4.57"></a><span id="l4.57">     // clone the array (except for the trailing NULL entry) using the </span>
<a href="#l4.58"></a><span id="l4.58">     // shared allocator for XPCOM correctness</span>
<a href="#l4.59"></a><span id="l4.59">     //</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineat">@@ -565,17 +565,17 @@ nsLDAPMessage::GetBinaryValues(const cha</span>
<a href="#l4.61"></a><span id="l4.61"> </span>
<a href="#l4.62"></a><span id="l4.62">     // count the values</span>
<a href="#l4.63"></a><span id="l4.63">     //</span>
<a href="#l4.64"></a><span id="l4.64">     uint32_t numVals = ldap_count_values_len(values);</span>
<a href="#l4.65"></a><span id="l4.65"> </span>
<a href="#l4.66"></a><span id="l4.66">     // create the out array</span>
<a href="#l4.67"></a><span id="l4.67">     //</span>
<a href="#l4.68"></a><span id="l4.68">     *aValues = </span>
<a href="#l4.69"></a><span id="l4.69" class="difflineminus">-        static_cast&lt;nsILDAPBERValue **&gt;(nsMemory::Alloc(numVals * sizeof(nsILDAPBERValue)));</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+        static_cast&lt;nsILDAPBERValue **&gt;(moz_xmalloc(numVals * sizeof(nsILDAPBERValue)));</span>
<a href="#l4.71"></a><span id="l4.71">     if (!aValues) {</span>
<a href="#l4.72"></a><span id="l4.72">         ldap_value_free_len(values);</span>
<a href="#l4.73"></a><span id="l4.73">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l4.74"></a><span id="l4.74">     }</span>
<a href="#l4.75"></a><span id="l4.75"> </span>
<a href="#l4.76"></a><span id="l4.76">     // clone the array (except for the trailing NULL entry) using the </span>
<a href="#l4.77"></a><span id="l4.77">     // shared allocator for XPCOM correctness</span>
<a href="#l4.78"></a><span id="l4.78">     //</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/ldap/xpcom/src/nsLDAPOperation.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/ldap/xpcom/src/nsLDAPOperation.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -188,17 +188,17 @@ nsLDAPOperation::SaslBind(const nsACStri</span>
<a href="#l5.4"></a><span id="l5.4">                                  &amp;credlen);</span>
<a href="#l5.5"></a><span id="l5.5">   if (NS_FAILED(rv) || !creds.bv_val)</span>
<a href="#l5.6"></a><span id="l5.6">     return rv;</span>
<a href="#l5.7"></a><span id="l5.7"> </span>
<a href="#l5.8"></a><span id="l5.8">   creds.bv_len = credlen;</span>
<a href="#l5.9"></a><span id="l5.9">   const int lderrno = ldap_sasl_bind(mConnectionHandle, bindName.get(),</span>
<a href="#l5.10"></a><span id="l5.10">                                      mMechanism.get(), &amp;creds, NULL, NULL,</span>
<a href="#l5.11"></a><span id="l5.11">                                      &amp;mMsgID);</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-  nsMemory::Free(creds.bv_val);</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+  free(creds.bv_val);</span>
<a href="#l5.14"></a><span id="l5.14"> </span>
<a href="#l5.15"></a><span id="l5.15">   if (lderrno != LDAP_SUCCESS)</span>
<a href="#l5.16"></a><span id="l5.16">     return TranslateLDAPErrorToNSError(lderrno);</span>
<a href="#l5.17"></a><span id="l5.17"> </span>
<a href="#l5.18"></a><span id="l5.18">   // make sure the connection knows where to call back once the messages</span>
<a href="#l5.19"></a><span id="l5.19">   // for this operation start coming in</span>
<a href="#l5.20"></a><span id="l5.20">   rv = mConnection-&gt;AddPendingOperation(mMsgID, this);</span>
<a href="#l5.21"></a><span id="l5.21"> </span>
<a href="#l5.22"></a><span id="l5.22" class="difflineat">@@ -231,17 +231,17 @@ nsLDAPOperation::SaslStep(const char *to</span>
<a href="#l5.23"></a><span id="l5.23">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.24"></a><span id="l5.24"> </span>
<a href="#l5.25"></a><span id="l5.25">   clientCreds.bv_len = credlen;</span>
<a href="#l5.26"></a><span id="l5.26"> </span>
<a href="#l5.27"></a><span id="l5.27">   const int lderrno = ldap_sasl_bind(mConnectionHandle, bindName.get(),</span>
<a href="#l5.28"></a><span id="l5.28">                                      mMechanism.get(), &amp;clientCreds, NULL,</span>
<a href="#l5.29"></a><span id="l5.29">                                      NULL, &amp;mMsgID);</span>
<a href="#l5.30"></a><span id="l5.30"> </span>
<a href="#l5.31"></a><span id="l5.31" class="difflineminus">-  nsMemory::Free(clientCreds.bv_val);</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+  free(clientCreds.bv_val);</span>
<a href="#l5.33"></a><span id="l5.33"> </span>
<a href="#l5.34"></a><span id="l5.34">   if (lderrno != LDAP_SUCCESS)</span>
<a href="#l5.35"></a><span id="l5.35">     return TranslateLDAPErrorToNSError(lderrno);</span>
<a href="#l5.36"></a><span id="l5.36"> </span>
<a href="#l5.37"></a><span id="l5.37">   // make sure the connection knows where to call back once the messages</span>
<a href="#l5.38"></a><span id="l5.38">   // for this operation start coming in</span>
<a href="#l5.39"></a><span id="l5.39">   rv = mConnection-&gt;AddPendingOperation(mMsgID, this);</span>
<a href="#l5.40"></a><span id="l5.40">   if (NS_FAILED(rv))</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineat">@@ -602,17 +602,17 @@ nsLDAPOperation::AddExt(const char *base</span>
<a href="#l5.42"></a><span id="l5.42"> </span>
<a href="#l5.43"></a><span id="l5.43">   LDAPMod **attrs = 0;</span>
<a href="#l5.44"></a><span id="l5.44">   int retVal = LDAP_SUCCESS;</span>
<a href="#l5.45"></a><span id="l5.45">   uint32_t modCount = 0;</span>
<a href="#l5.46"></a><span id="l5.46">   nsresult rv = mods-&gt;GetLength(&amp;modCount);</span>
<a href="#l5.47"></a><span id="l5.47">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.48"></a><span id="l5.48"> </span>
<a href="#l5.49"></a><span id="l5.49">   if (mods &amp;&amp; modCount) {</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineminus">-    attrs = static_cast&lt;LDAPMod **&gt;(nsMemory::Alloc((modCount + 1) *</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineplus">+    attrs = static_cast&lt;LDAPMod **&gt;(moz_xmalloc((modCount + 1) *</span>
<a href="#l5.52"></a><span id="l5.52">                                                        sizeof(LDAPMod *)));</span>
<a href="#l5.53"></a><span id="l5.53">     if (!attrs) {</span>
<a href="#l5.54"></a><span id="l5.54">       NS_ERROR(&quot;nsLDAPOperation::AddExt: out of memory &quot;);</span>
<a href="#l5.55"></a><span id="l5.55">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l5.56"></a><span id="l5.56">     }</span>
<a href="#l5.57"></a><span id="l5.57"> </span>
<a href="#l5.58"></a><span id="l5.58">     nsAutoCString type;</span>
<a href="#l5.59"></a><span id="l5.59">     uint32_t index;</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineat">@@ -655,17 +655,17 @@ nsLDAPOperation::AddExt(const char *base</span>
<a href="#l5.61"></a><span id="l5.61">     else</span>
<a href="#l5.62"></a><span id="l5.62">       // reset the modCount so we correctly free the array.</span>
<a href="#l5.63"></a><span id="l5.63">       modCount = index;</span>
<a href="#l5.64"></a><span id="l5.64">   }</span>
<a href="#l5.65"></a><span id="l5.65"> </span>
<a href="#l5.66"></a><span id="l5.66">   for (uint32_t counter = 0; counter &lt; modCount; ++counter)</span>
<a href="#l5.67"></a><span id="l5.67">     delete attrs[counter];</span>
<a href="#l5.68"></a><span id="l5.68"> </span>
<a href="#l5.69"></a><span id="l5.69" class="difflineminus">-  nsMemory::Free(attrs);</span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+  free(attrs);</span>
<a href="#l5.71"></a><span id="l5.71"> </span>
<a href="#l5.72"></a><span id="l5.72">   return NS_FAILED(rv) ? rv : TranslateLDAPErrorToNSError(retVal);</span>
<a href="#l5.73"></a><span id="l5.73"> }</span>
<a href="#l5.74"></a><span id="l5.74"> </span>
<a href="#l5.75"></a><span id="l5.75"> /**</span>
<a href="#l5.76"></a><span id="l5.76">  * wrapper for ldap_add_ext(): kicks off an async add request.</span>
<a href="#l5.77"></a><span id="l5.77">  *</span>
<a href="#l5.78"></a><span id="l5.78">  * @param aBaseDn           Base DN to search</span>
<a href="#l5.79"></a><span id="l5.79" class="difflineat">@@ -766,17 +766,17 @@ nsLDAPOperation::ModifyExt(const char *b</span>
<a href="#l5.80"></a><span id="l5.80">   }</span>
<a href="#l5.81"></a><span id="l5.81"> </span>
<a href="#l5.82"></a><span id="l5.82">   LDAPMod **attrs = 0;</span>
<a href="#l5.83"></a><span id="l5.83">   int retVal = 0;</span>
<a href="#l5.84"></a><span id="l5.84">   uint32_t modCount = 0;</span>
<a href="#l5.85"></a><span id="l5.85">   nsresult rv = mods-&gt;GetLength(&amp;modCount);</span>
<a href="#l5.86"></a><span id="l5.86">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.87"></a><span id="l5.87">   if (modCount &amp;&amp; mods) {</span>
<a href="#l5.88"></a><span id="l5.88" class="difflineminus">-    attrs = static_cast&lt;LDAPMod **&gt;(nsMemory::Alloc((modCount + 1) *</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineplus">+    attrs = static_cast&lt;LDAPMod **&gt;(moz_xmalloc((modCount + 1) *</span>
<a href="#l5.90"></a><span id="l5.90">                                                        sizeof(LDAPMod *)));</span>
<a href="#l5.91"></a><span id="l5.91">     if (!attrs) {</span>
<a href="#l5.92"></a><span id="l5.92">       NS_ERROR(&quot;nsLDAPOperation::ModifyExt: out of memory &quot;);</span>
<a href="#l5.93"></a><span id="l5.93">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l5.94"></a><span id="l5.94">     }</span>
<a href="#l5.95"></a><span id="l5.95"> </span>
<a href="#l5.96"></a><span id="l5.96">     nsAutoCString type;</span>
<a href="#l5.97"></a><span id="l5.97">     uint32_t index;</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineat">@@ -817,17 +817,17 @@ nsLDAPOperation::ModifyExt(const char *b</span>
<a href="#l5.99"></a><span id="l5.99">       // reset the modCount so we correctly free the array.</span>
<a href="#l5.100"></a><span id="l5.100">       modCount = index;</span>
<a href="#l5.101"></a><span id="l5.101"> </span>
<a href="#l5.102"></a><span id="l5.102">   }</span>
<a href="#l5.103"></a><span id="l5.103"> </span>
<a href="#l5.104"></a><span id="l5.104">   for (uint32_t counter = 0; counter &lt; modCount; ++counter)</span>
<a href="#l5.105"></a><span id="l5.105">     delete attrs[counter];</span>
<a href="#l5.106"></a><span id="l5.106"> </span>
<a href="#l5.107"></a><span id="l5.107" class="difflineminus">-  nsMemory::Free(attrs);</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+  free(attrs);</span>
<a href="#l5.109"></a><span id="l5.109"> </span>
<a href="#l5.110"></a><span id="l5.110">   return NS_FAILED(rv) ? rv : TranslateLDAPErrorToNSError(retVal);</span>
<a href="#l5.111"></a><span id="l5.111"> }</span>
<a href="#l5.112"></a><span id="l5.112"> </span>
<a href="#l5.113"></a><span id="l5.113"> /**</span>
<a href="#l5.114"></a><span id="l5.114">  * wrapper for ldap_modify_ext(): kicks off an async modify request.</span>
<a href="#l5.115"></a><span id="l5.115">  *</span>
<a href="#l5.116"></a><span id="l5.116">  * @param aBaseDn           Base DN to modify</span>
<a href="#l5.117"></a><span id="l5.117" class="difflineat">@@ -939,33 +939,33 @@ nsLDAPOperation::CopyValues(nsILDAPModif</span>
<a href="#l5.118"></a><span id="l5.118">   nsresult rv = aMod-&gt;GetValues(getter_AddRefs(values));</span>
<a href="#l5.119"></a><span id="l5.119">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.120"></a><span id="l5.120"> </span>
<a href="#l5.121"></a><span id="l5.121">   uint32_t valuesCount;</span>
<a href="#l5.122"></a><span id="l5.122">   rv = values-&gt;GetLength(&amp;valuesCount);</span>
<a href="#l5.123"></a><span id="l5.123">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.124"></a><span id="l5.124"> </span>
<a href="#l5.125"></a><span id="l5.125">   *aBValues = static_cast&lt;berval **&gt;</span>
<a href="#l5.126"></a><span id="l5.126" class="difflineminus">-                         (nsMemory::Alloc((valuesCount + 1) *</span>
<a href="#l5.127"></a><span id="l5.127" class="difflineplus">+                         (moz_xmalloc((valuesCount + 1) *</span>
<a href="#l5.128"></a><span id="l5.128">                                              sizeof(berval *)));</span>
<a href="#l5.129"></a><span id="l5.129">   if (!*aBValues)</span>
<a href="#l5.130"></a><span id="l5.130">     return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l5.131"></a><span id="l5.131"> </span>
<a href="#l5.132"></a><span id="l5.132">   uint32_t valueIndex;</span>
<a href="#l5.133"></a><span id="l5.133">   for (valueIndex = 0; valueIndex &lt; valuesCount; ++valueIndex) {</span>
<a href="#l5.134"></a><span id="l5.134">     nsCOMPtr&lt;nsILDAPBERValue&gt; value(do_QueryElementAt(values, valueIndex, &amp;rv));</span>
<a href="#l5.135"></a><span id="l5.135"> </span>
<a href="#l5.136"></a><span id="l5.136">     berval* bval = new berval;</span>
<a href="#l5.137"></a><span id="l5.137">     if (NS_FAILED(rv) || !bval) {</span>
<a href="#l5.138"></a><span id="l5.138">       for (uint32_t counter = 0;</span>
<a href="#l5.139"></a><span id="l5.139">            counter &lt; valueIndex &amp;&amp; counter &lt; valuesCount;</span>
<a href="#l5.140"></a><span id="l5.140">            ++counter)</span>
<a href="#l5.141"></a><span id="l5.141">         delete (*aBValues)[valueIndex];</span>
<a href="#l5.142"></a><span id="l5.142"> </span>
<a href="#l5.143"></a><span id="l5.143" class="difflineminus">-      nsMemory::Free(*aBValues);</span>
<a href="#l5.144"></a><span id="l5.144" class="difflineplus">+      free(*aBValues);</span>
<a href="#l5.145"></a><span id="l5.145">       delete bval;</span>
<a href="#l5.146"></a><span id="l5.146">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l5.147"></a><span id="l5.147">     }</span>
<a href="#l5.148"></a><span id="l5.148">     value-&gt;Get((uint32_t*)&amp;bval-&gt;bv_len,</span>
<a href="#l5.149"></a><span id="l5.149">                (uint8_t**)&amp;bval-&gt;bv_val);</span>
<a href="#l5.150"></a><span id="l5.150">     (*aBValues)[valueIndex] = bval;</span>
<a href="#l5.151"></a><span id="l5.151">   }</span>
<a href="#l5.152"></a><span id="l5.152"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/ldap/xpcom/src/nsLDAPSecurityGlue.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/ldap/xpcom/src/nsLDAPSecurityGlue.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -34,17 +34,17 @@ typedef struct {</span>
<a href="#l6.4"></a><span id="l6.4"> } nsLDAPSSLSocketClosure;</span>
<a href="#l6.5"></a><span id="l6.5"> </span>
<a href="#l6.6"></a><span id="l6.6"> // free the per-socket data structure as necessary</span>
<a href="#l6.7"></a><span id="l6.7"> //</span>
<a href="#l6.8"></a><span id="l6.8"> static void</span>
<a href="#l6.9"></a><span id="l6.9"> nsLDAPSSLFreeSocketClosure(nsLDAPSSLSocketClosure **aClosure)</span>
<a href="#l6.10"></a><span id="l6.10"> {</span>
<a href="#l6.11"></a><span id="l6.11">     if (aClosure &amp;&amp; *aClosure) {</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-	nsMemory::Free(*aClosure);</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+	free(*aClosure);</span>
<a href="#l6.14"></a><span id="l6.14"> 	*aClosure = nullptr;</span>
<a href="#l6.15"></a><span id="l6.15">     }</span>
<a href="#l6.16"></a><span id="l6.16"> }</span>
<a href="#l6.17"></a><span id="l6.17"> </span>
<a href="#l6.18"></a><span id="l6.18"> // Replacement close() function, which cleans up local stuff associated</span>
<a href="#l6.19"></a><span id="l6.19"> // with this socket, and then calls the real close function.</span>
<a href="#l6.20"></a><span id="l6.20"> //</span>
<a href="#l6.21"></a><span id="l6.21"> extern &quot;C&quot; int LDAP_CALLBACK</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineat">@@ -140,17 +140,17 @@ nsLDAPSSLConnect(const char *hostlist, i</span>
<a href="#l6.23"></a><span id="l6.23">     if (prldap_get_socket_info(intfd, *socketargp, &amp;socketInfo)</span>
<a href="#l6.24"></a><span id="l6.24"> 	!= LDAP_SUCCESS)  {</span>
<a href="#l6.25"></a><span id="l6.25"> 	NS_ERROR(&quot;nsLDAPSSLConnect(): unable to get socket info&quot;);</span>
<a href="#l6.26"></a><span id="l6.26">         goto close_socket_and_exit_with_error;</span>
<a href="#l6.27"></a><span id="l6.27">     }</span>
<a href="#l6.28"></a><span id="l6.28"> </span>
<a href="#l6.29"></a><span id="l6.29">     // Allocate a structure to hold our socket-specific data.</span>
<a href="#l6.30"></a><span id="l6.30">     //</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-    socketClosure = static_cast&lt;nsLDAPSSLSocketClosure *&gt;(nsMemory::Alloc(</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+    socketClosure = static_cast&lt;nsLDAPSSLSocketClosure *&gt;(moz_xmalloc(</span>
<a href="#l6.33"></a><span id="l6.33"> 				       sizeof(nsLDAPSSLSocketClosure)));</span>
<a href="#l6.34"></a><span id="l6.34">     if (!socketClosure) {</span>
<a href="#l6.35"></a><span id="l6.35"> 	NS_WARNING(&quot;nsLDAPSSLConnect(): unable to allocate socket closure&quot;);</span>
<a href="#l6.36"></a><span id="l6.36"> 	goto close_socket_and_exit_with_error;</span>
<a href="#l6.37"></a><span id="l6.37">     }</span>
<a href="#l6.38"></a><span id="l6.38">     memset(socketClosure, 0, sizeof(nsLDAPSSLSocketClosure));</span>
<a href="#l6.39"></a><span id="l6.39">     socketClosure-&gt;sessionClosure = sessionClosure;</span>
<a href="#l6.40"></a><span id="l6.40"> </span>
<a href="#l6.41"></a><span id="l6.41" class="difflineat">@@ -233,17 +233,17 @@ nsLDAPSSLFreeSessionClosure(nsLDAPSSLSes</span>
<a href="#l6.42"></a><span id="l6.42"> 	//</span>
<a href="#l6.43"></a><span id="l6.43"> 	if ( (*aSessionClosure)-&gt;hostname ) {</span>
<a href="#l6.44"></a><span id="l6.44"> 	    PL_strfree((*aSessionClosure)-&gt;hostname);</span>
<a href="#l6.45"></a><span id="l6.45"> 	    (*aSessionClosure)-&gt;hostname = nullptr;</span>
<a href="#l6.46"></a><span id="l6.46"> 	}</span>
<a href="#l6.47"></a><span id="l6.47"> </span>
<a href="#l6.48"></a><span id="l6.48"> 	// free the structure itself</span>
<a href="#l6.49"></a><span id="l6.49"> 	//</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineminus">-	nsMemory::Free(*aSessionClosure);</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineplus">+	free(*aSessionClosure);</span>
<a href="#l6.52"></a><span id="l6.52"> 	*aSessionClosure = nullptr;</span>
<a href="#l6.53"></a><span id="l6.53">     }</span>
<a href="#l6.54"></a><span id="l6.54"> }</span>
<a href="#l6.55"></a><span id="l6.55"> </span>
<a href="#l6.56"></a><span id="l6.56"> // Replacement session handle disposal code.  First cleans up our local</span>
<a href="#l6.57"></a><span id="l6.57"> // stuff, then calls the original session handle disposal function.</span>
<a href="#l6.58"></a><span id="l6.58"> //</span>
<a href="#l6.59"></a><span id="l6.59"> extern &quot;C&quot; void LDAP_CALLBACK</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineat">@@ -272,17 +272,17 @@ nsresult</span>
<a href="#l6.61"></a><span id="l6.61"> nsLDAPInstallSSL( LDAP *ld, const char *aHostName)</span>
<a href="#l6.62"></a><span id="l6.62"> {</span>
<a href="#l6.63"></a><span id="l6.63">     struct ldap_x_ext_io_fns iofns;</span>
<a href="#l6.64"></a><span id="l6.64">     nsLDAPSSLSessionClosure *sessionClosure;</span>
<a href="#l6.65"></a><span id="l6.65">     PRLDAPSessionInfo sessionInfo;</span>
<a href="#l6.66"></a><span id="l6.66"> </span>
<a href="#l6.67"></a><span id="l6.67">     // Allocate our own session information.</span>
<a href="#l6.68"></a><span id="l6.68">     //</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineminus">-    sessionClosure = static_cast&lt;nsLDAPSSLSessionClosure *&gt;(nsMemory::Alloc(</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineplus">+    sessionClosure = static_cast&lt;nsLDAPSSLSessionClosure *&gt;(moz_xmalloc(</span>
<a href="#l6.71"></a><span id="l6.71"> 					sizeof(nsLDAPSSLSessionClosure)));</span>
<a href="#l6.72"></a><span id="l6.72">     if (!sessionClosure) {</span>
<a href="#l6.73"></a><span id="l6.73"> 	return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l6.74"></a><span id="l6.74">     }</span>
<a href="#l6.75"></a><span id="l6.75">     memset(sessionClosure, 0, sizeof(nsLDAPSSLSessionClosure));</span>
<a href="#l6.76"></a><span id="l6.76"> </span>
<a href="#l6.77"></a><span id="l6.77">     // Override a few functions, saving a pointer to the original function</span>
<a href="#l6.78"></a><span id="l6.78">     // in each case so we can call it from our SSL savvy functions.</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineat">@@ -324,14 +324,14 @@ nsLDAPInstallSSL( LDAP *ld, const char *</span>
<a href="#l6.80"></a><span id="l6.80"> </span>
<a href="#l6.81"></a><span id="l6.81">     // Store session info. for later retrieval.</span>
<a href="#l6.82"></a><span id="l6.82">     //</span>
<a href="#l6.83"></a><span id="l6.83">     sessionInfo.seinfo_size = PRLDAP_SESSIONINFO_SIZE;</span>
<a href="#l6.84"></a><span id="l6.84">     sessionInfo.seinfo_appdata = reinterpret_cast&lt;prldap_session_private *&gt;</span>
<a href="#l6.85"></a><span id="l6.85">                                                  (sessionClosure);</span>
<a href="#l6.86"></a><span id="l6.86">     if (prldap_set_session_info(ld, nullptr, &amp;sessionInfo) != LDAP_SUCCESS) {</span>
<a href="#l6.87"></a><span id="l6.87"> 	NS_ERROR(&quot;nsLDAPInstallSSL(): error setting prldap session info&quot;);</span>
<a href="#l6.88"></a><span id="l6.88" class="difflineminus">-	nsMemory::Free(sessionClosure);</span>
<a href="#l6.89"></a><span id="l6.89" class="difflineplus">+	free(sessionClosure);</span>
<a href="#l6.90"></a><span id="l6.90"> 	return NS_ERROR_UNEXPECTED;</span>
<a href="#l6.91"></a><span id="l6.91">     }</span>
<a href="#l6.92"></a><span id="l6.92"> </span>
<a href="#l6.93"></a><span id="l6.93">     return NS_OK;</span>
<a href="#l6.94"></a><span id="l6.94"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/ldap/xpcom/src/nsLDAPService.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/ldap/xpcom/src/nsLDAPService.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -750,17 +750,17 @@ NS_IMETHODIMP nsLDAPService::CreateFilte</span>
<a href="#l7.4"></a><span id="l7.4"> </span>
<a href="#l7.5"></a><span id="l7.5">     // figure out how big of an array we're going to need for the tokens,</span>
<a href="#l7.6"></a><span id="l7.6">     // including a trailing NULL, and allocate space for it.</span>
<a href="#l7.7"></a><span id="l7.7">     //</span>
<a href="#l7.8"></a><span id="l7.8">     const char *iter = aValue.BeginReading();</span>
<a href="#l7.9"></a><span id="l7.9">     const char *iterEnd = aValue.EndReading();</span>
<a href="#l7.10"></a><span id="l7.10">     uint32_t numTokens = CountTokens(iter, iterEnd); </span>
<a href="#l7.11"></a><span id="l7.11">     char **valueWords;</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-    valueWords = static_cast&lt;char **&gt;(nsMemory::Alloc((numTokens + 1) *</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+    valueWords = static_cast&lt;char **&gt;(moz_xmalloc((numTokens + 1) *</span>
<a href="#l7.14"></a><span id="l7.14">                                                 sizeof(char *)));</span>
<a href="#l7.15"></a><span id="l7.15">     if (!valueWords) {</span>
<a href="#l7.16"></a><span id="l7.16">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l7.17"></a><span id="l7.17">     }</span>
<a href="#l7.18"></a><span id="l7.18"> </span>
<a href="#l7.19"></a><span id="l7.19">     // build the array of values</span>
<a href="#l7.20"></a><span id="l7.20">     //</span>
<a href="#l7.21"></a><span id="l7.21">     uint32_t curToken = 0;</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineat">@@ -771,17 +771,17 @@ NS_IMETHODIMP nsLDAPService::CreateFilte</span>
<a href="#l7.23"></a><span id="l7.23">             return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l7.24"></a><span id="l7.24">         }</span>
<a href="#l7.25"></a><span id="l7.25">         curToken++;</span>
<a href="#l7.26"></a><span id="l7.26">     }</span>
<a href="#l7.27"></a><span id="l7.27">     valueWords[numTokens] = 0;  // end of array signal to LDAP C SDK</span>
<a href="#l7.28"></a><span id="l7.28"> </span>
<a href="#l7.29"></a><span id="l7.29">     // make buffer to be used for construction </span>
<a href="#l7.30"></a><span id="l7.30">     //</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-    char *buffer = static_cast&lt;char *&gt;(nsMemory::Alloc(aMaxSize * sizeof(char)));</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+    char *buffer = static_cast&lt;char *&gt;(moz_xmalloc(aMaxSize * sizeof(char)));</span>
<a href="#l7.33"></a><span id="l7.33">     if (!buffer) {</span>
<a href="#l7.34"></a><span id="l7.34">         NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(numTokens, valueWords);</span>
<a href="#l7.35"></a><span id="l7.35">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l7.36"></a><span id="l7.36">     }</span>
<a href="#l7.37"></a><span id="l7.37"> </span>
<a href="#l7.38"></a><span id="l7.38">     // create the filter itself</span>
<a href="#l7.39"></a><span id="l7.39">     //</span>
<a href="#l7.40"></a><span id="l7.40">     nsresult rv;</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineat">@@ -816,17 +816,17 @@ NS_IMETHODIMP nsLDAPService::CreateFilte</span>
<a href="#l7.42"></a><span id="l7.42">         break;</span>
<a href="#l7.43"></a><span id="l7.43">     }</span>
<a href="#l7.44"></a><span id="l7.44"> </span>
<a href="#l7.45"></a><span id="l7.45">     _retval.Assign(buffer);</span>
<a href="#l7.46"></a><span id="l7.46"> </span>
<a href="#l7.47"></a><span id="l7.47">     // done with the array and the buffer</span>
<a href="#l7.48"></a><span id="l7.48">     //</span>
<a href="#l7.49"></a><span id="l7.49">     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(numTokens, valueWords);</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineminus">-    nsMemory::Free(buffer);</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+    free(buffer);</span>
<a href="#l7.52"></a><span id="l7.52"> </span>
<a href="#l7.53"></a><span id="l7.53">     return rv;</span>
<a href="#l7.54"></a><span id="l7.54"> }</span>
<a href="#l7.55"></a><span id="l7.55"> </span>
<a href="#l7.56"></a><span id="l7.56"> // Parse a distinguished name (DN) and returns the relative DN,</span>
<a href="#l7.57"></a><span id="l7.57"> // base DN and the list of attributes that make up the relative DN.</span>
<a href="#l7.58"></a><span id="l7.58"> NS_IMETHODIMP nsLDAPService::ParseDn(const char *aDn,</span>
<a href="#l7.59"></a><span id="l7.59">                                    nsACString &amp;aRdn,</span>
<a href="#l7.60"></a><span id="l7.60" class="difflineat">@@ -874,17 +874,17 @@ NS_IMETHODIMP nsLDAPService::ParseDn(con</span>
<a href="#l7.61"></a><span id="l7.61">         NS_ERROR(&quot;nsLDAPService::ParseDn: RDN has too few components&quot;);</span>
<a href="#l7.62"></a><span id="l7.62">         ldap_value_free(dnComponents);</span>
<a href="#l7.63"></a><span id="l7.63">         ldap_value_free(rdnComponents);</span>
<a href="#l7.64"></a><span id="l7.64">         return NS_ERROR_UNEXPECTED;</span>
<a href="#l7.65"></a><span id="l7.65">     }</span>
<a href="#l7.66"></a><span id="l7.66">   </span>
<a href="#l7.67"></a><span id="l7.67">     // get the RDN attribute names</span>
<a href="#l7.68"></a><span id="l7.68">     char **attrNameArray = static_cast&lt;char **&gt;(</span>
<a href="#l7.69"></a><span id="l7.69" class="difflineminus">-        nsMemory::Alloc(rdnCount * sizeof(char *)));</span>
<a href="#l7.70"></a><span id="l7.70" class="difflineplus">+        moz_xmalloc(rdnCount * sizeof(char *)));</span>
<a href="#l7.71"></a><span id="l7.71">     if (!attrNameArray) {</span>
<a href="#l7.72"></a><span id="l7.72">         NS_ERROR(&quot;nsLDAPService::ParseDn: out of memory &quot;);</span>
<a href="#l7.73"></a><span id="l7.73">         ldap_value_free(dnComponents);</span>
<a href="#l7.74"></a><span id="l7.74">         ldap_value_free(rdnComponents);</span>
<a href="#l7.75"></a><span id="l7.75">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l7.76"></a><span id="l7.76">     }</span>
<a href="#l7.77"></a><span id="l7.77">     uint32_t index = 0;</span>
<a href="#l7.78"></a><span id="l7.78">     for (char **component = rdnComponents; *component; ++component) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbLDAPDirectory.cpp</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbLDAPDirectory.cpp</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -923,17 +923,17 @@ nsresult nsAbLDAPDirectory::SplitStringL</span>
<a href="#l8.4"></a><span id="l8.4"> {</span>
<a href="#l8.5"></a><span id="l8.5">   NS_ENSURE_ARG_POINTER(aCount);</span>
<a href="#l8.6"></a><span id="l8.6">   NS_ENSURE_ARG_POINTER(aValues);</span>
<a href="#l8.7"></a><span id="l8.7"> </span>
<a href="#l8.8"></a><span id="l8.8">   nsTArray&lt;nsCString&gt; strarr;</span>
<a href="#l8.9"></a><span id="l8.9">   ParseString(aString, ',', strarr);</span>
<a href="#l8.10"></a><span id="l8.10"> </span>
<a href="#l8.11"></a><span id="l8.11">   char **cArray = nullptr;</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  if (!(cArray = static_cast&lt;char **&gt;(nsMemory::Alloc(</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+  if (!(cArray = static_cast&lt;char **&gt;(moz_xmalloc(</span>
<a href="#l8.14"></a><span id="l8.14">       strarr.Length() * sizeof(char *)))))</span>
<a href="#l8.15"></a><span id="l8.15">     return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l8.16"></a><span id="l8.16"> </span>
<a href="#l8.17"></a><span id="l8.17">   for (uint32_t i = 0; i &lt; strarr.Length(); ++i)</span>
<a href="#l8.18"></a><span id="l8.18">   {</span>
<a href="#l8.19"></a><span id="l8.19">     if (!(cArray[i] = ToNewCString(strarr[i])))</span>
<a href="#l8.20"></a><span id="l8.20">     {</span>
<a href="#l8.21"></a><span id="l8.21">       NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(strarr.Length(), cArray);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbLDIFService.cpp</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbLDIFService.cpp</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -370,17 +370,17 @@ void nsAbLDIFService::AddLdifRowToDataba</span>
<a href="#l9.4"></a><span id="l9.4">   while ( (line = str_getline(&amp;cursor)) != nullptr)</span>
<a href="#l9.5"></a><span id="l9.5">   {</span>
<a href="#l9.6"></a><span id="l9.6">     if (NS_SUCCEEDED(str_parse_line(line, &amp;typeSlot, &amp;valueSlot, &amp;length))) {</span>
<a href="#l9.7"></a><span id="l9.7">       AddLdifColToDatabase(aDatabase, newRow, typeSlot, valueSlot, bIsList);</span>
<a href="#l9.8"></a><span id="l9.8">     }</span>
<a href="#l9.9"></a><span id="l9.9">     else</span>
<a href="#l9.10"></a><span id="l9.10">       continue; // parse error: continue with next loop iteration</span>
<a href="#l9.11"></a><span id="l9.11">   }</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-  nsMemory::Free(saveCursor);</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+  free(saveCursor);</span>
<a href="#l9.14"></a><span id="l9.14">   aDatabase-&gt;AddCardRowToDB(newRow);    </span>
<a href="#l9.15"></a><span id="l9.15"> </span>
<a href="#l9.16"></a><span id="l9.16">   if (bIsList)</span>
<a href="#l9.17"></a><span id="l9.17">     aDatabase-&gt;AddListDirNode(newRow);</span>
<a href="#l9.18"></a><span id="l9.18">         </span>
<a href="#l9.19"></a><span id="l9.19">   // Clear buffer for next record</span>
<a href="#l9.20"></a><span id="l9.20">   ClearLdifRecordBuffer();</span>
<a href="#l9.21"></a><span id="l9.21"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbUtils.h</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbUtils.h</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -63,17 +63,17 @@ private:</span>
<a href="#l10.4"></a><span id="l10.4">     {</span>
<a href="#l10.5"></a><span id="l10.5">         if (!mArray)</span>
<a href="#l10.6"></a><span id="l10.6">             return;</span>
<a href="#l10.7"></a><span id="l10.7"> </span>
<a href="#l10.8"></a><span id="l10.8">         if (mFreeElements)</span>
<a href="#l10.9"></a><span id="l10.9">             NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(mSize, mArray);</span>
<a href="#l10.10"></a><span id="l10.10">         else</span>
<a href="#l10.11"></a><span id="l10.11">         {</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-          nsMemory::Free(mArray);</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+          free(mArray);</span>
<a href="#l10.14"></a><span id="l10.14">         }</span>
<a href="#l10.15"></a><span id="l10.15">     }</span>
<a href="#l10.16"></a><span id="l10.16"> };</span>
<a href="#l10.17"></a><span id="l10.17"> </span>
<a href="#l10.18"></a><span id="l10.18"> /*</span>
<a href="#l10.19"></a><span id="l10.19">  * Wrapper class to automatically free an array of</span>
<a href="#l10.20"></a><span id="l10.20">  * char16_t* when class goes out of scope</span>
<a href="#l10.21"></a><span id="l10.21">  */</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineat">@@ -127,14 +127,14 @@ private:</span>
<a href="#l10.23"></a><span id="l10.23">     {</span>
<a href="#l10.24"></a><span id="l10.24">         if (!mArray)</span>
<a href="#l10.25"></a><span id="l10.25">             return;</span>
<a href="#l10.26"></a><span id="l10.26"> </span>
<a href="#l10.27"></a><span id="l10.27">         if (mFreeElements)</span>
<a href="#l10.28"></a><span id="l10.28">           NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(mSize, mArray);</span>
<a href="#l10.29"></a><span id="l10.29">         else</span>
<a href="#l10.30"></a><span id="l10.30">         {</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineminus">-          nsMemory::Free(mArray);</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+          free(mArray);</span>
<a href="#l10.33"></a><span id="l10.33">         }</span>
<a href="#l10.34"></a><span id="l10.34">     }</span>
<a href="#l10.35"></a><span id="l10.35"> };</span>
<a href="#l10.36"></a><span id="l10.36"> </span>
<a href="#l10.37"></a><span id="l10.37"> #endif  /* nsAbUtils_h__ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbView.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbView.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -1073,19 +1073,19 @@ NS_IMETHODIMP nsAbView::OnItemPropertyCh</span>
<a href="#l11.4"></a><span id="l11.4">   </span>
<a href="#l11.5"></a><span id="l11.5">   if (!CompareCollationKeys(newCard-&gt;primaryCollationKey,newCard-&gt;primaryCollationKeyLen,oldCard-&gt;primaryCollationKey,oldCard-&gt;primaryCollationKeyLen)</span>
<a href="#l11.6"></a><span id="l11.6">     &amp;&amp; CompareCollationKeys(newCard-&gt;secondaryCollationKey,newCard-&gt;secondaryCollationKeyLen,oldCard-&gt;secondaryCollationKey,oldCard-&gt;secondaryCollationKeyLen)) {</span>
<a href="#l11.7"></a><span id="l11.7">     // No need to remove and add, since the collation keys haven't changed.</span>
<a href="#l11.8"></a><span id="l11.8">     // Since they haven't changed, the card will sort to the same place.</span>
<a href="#l11.9"></a><span id="l11.9">     // We just need to clean up what we allocated.</span>
<a href="#l11.10"></a><span id="l11.10">     NS_IF_RELEASE(newCard-&gt;card);</span>
<a href="#l11.11"></a><span id="l11.11">     if (newCard-&gt;primaryCollationKey)</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-      nsMemory::Free(newCard-&gt;primaryCollationKey);</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+      free(newCard-&gt;primaryCollationKey);</span>
<a href="#l11.14"></a><span id="l11.14">     if (newCard-&gt;secondaryCollationKey)</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineminus">-      nsMemory::Free(newCard-&gt;secondaryCollationKey);</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineplus">+      free(newCard-&gt;secondaryCollationKey);</span>
<a href="#l11.17"></a><span id="l11.17">     PR_FREEIF(newCard);</span>
<a href="#l11.18"></a><span id="l11.18"> </span>
<a href="#l11.19"></a><span id="l11.19">     // Still need to invalidate, as the other columns may have changed.</span>
<a href="#l11.20"></a><span id="l11.20">     rv = InvalidateTree(index);</span>
<a href="#l11.21"></a><span id="l11.21">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l11.22"></a><span id="l11.22">   }</span>
<a href="#l11.23"></a><span id="l11.23">   else {</span>
<a href="#l11.24"></a><span id="l11.24">     mSuppressSelectionChange = true;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/addrbook/src/nsDirPrefs.cpp</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsDirPrefs.cpp</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -743,17 +743,17 @@ static nsresult dir_GetChildList(const n</span>
<a href="#l12.4"></a><span id="l12.4">         // elements in the list here, so we just init the two counters sensibly</span>
<a href="#l12.5"></a><span id="l12.5">         // to begin with.</span>
<a href="#l12.6"></a><span id="l12.6">         uint32_t cur = 0;</span>
<a href="#l12.7"></a><span id="l12.7">         for (uint32_t next = 1; next &lt; *aCount; ++next) {</span>
<a href="#l12.8"></a><span id="l12.8">             // check if the elements are equal or unique</span>
<a href="#l12.9"></a><span id="l12.9">             if (!comparePrefArrayMembers(&amp;((*aChildList)[cur]), &amp;((*aChildList)[next]), &amp;branchLen)) {</span>
<a href="#l12.10"></a><span id="l12.10">                 // equal - just free &amp; increment the next element ptr</span>
<a href="#l12.11"></a><span id="l12.11"> </span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-                nsMemory::Free((*aChildList)[next]);</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+                free((*aChildList)[next]);</span>
<a href="#l12.14"></a><span id="l12.14">             } else {</span>
<a href="#l12.15"></a><span id="l12.15">                 // cur &amp; next are unique, so we need to shift the element.</span>
<a href="#l12.16"></a><span id="l12.16">                 // ++cur will point to the next free location in the</span>
<a href="#l12.17"></a><span id="l12.17">                 // reduced array (it's okay if that's == next)</span>
<a href="#l12.18"></a><span id="l12.18">                 (*aChildList)[++cur] = (*aChildList)[next];</span>
<a href="#l12.19"></a><span id="l12.19">             }</span>
<a href="#l12.20"></a><span id="l12.20">         }</span>
<a href="#l12.21"></a><span id="l12.21"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/base/search/src/nsMsgFilterList.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/base/search/src/nsMsgFilterList.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -679,17 +679,17 @@ nsresult nsMsgFilterList::LoadTextFilter</span>
<a href="#l13.4"></a><span id="l13.4">           nsAutoString unicodeStr;</span>
<a href="#l13.5"></a><span id="l13.5">           err = nsMsgI18NConvertToUnicode(nsMsgI18NFileSystemCharset(),</span>
<a href="#l13.6"></a><span id="l13.6">                                           value, unicodeStr);</span>
<a href="#l13.7"></a><span id="l13.7">           if (NS_FAILED(err))</span>
<a href="#l13.8"></a><span id="l13.8">               break;</span>
<a href="#l13.9"></a><span id="l13.9"> </span>
<a href="#l13.10"></a><span id="l13.10">           char *utf8 = ToNewUTF8String(unicodeStr);</span>
<a href="#l13.11"></a><span id="l13.11">           value.Assign(utf8);</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-          nsMemory::Free(utf8);</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+          free(utf8);</span>
<a href="#l13.14"></a><span id="l13.14">         }</span>
<a href="#l13.15"></a><span id="l13.15">         err = ParseCondition(m_curFilter, value.get());</span>
<a href="#l13.16"></a><span id="l13.16">         if (err == NS_ERROR_INVALID_ARG)</span>
<a href="#l13.17"></a><span id="l13.17">           err = m_curFilter-&gt;SetUnparseable(true);</span>
<a href="#l13.18"></a><span id="l13.18">         NS_ENSURE_SUCCESS(err, err);</span>
<a href="#l13.19"></a><span id="l13.19">       }</span>
<a href="#l13.20"></a><span id="l13.20">       break;</span>
<a href="#l13.21"></a><span id="l13.21">     case nsIMsgFilterList::attribCustomId:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/base/search/src/nsMsgSearchAdapter.cpp</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/base/search/src/nsMsgSearchAdapter.cpp</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -863,17 +863,17 @@ nsMsgSearchValidityTable::GetAvailableAt</span>
<a href="#l14.4"></a><span id="l14.4">             if (m_table[i][j].bitAvailable) {</span>
<a href="#l14.5"></a><span id="l14.5">                 totalAttributes++;</span>
<a href="#l14.6"></a><span id="l14.6">                 break;</span>
<a href="#l14.7"></a><span id="l14.7">             }</span>
<a href="#l14.8"></a><span id="l14.8">         }</span>
<a href="#l14.9"></a><span id="l14.9">     }</span>
<a href="#l14.10"></a><span id="l14.10"> </span>
<a href="#l14.11"></a><span id="l14.11">     nsMsgSearchAttribValue *array = (nsMsgSearchAttribValue*)</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-        nsMemory::Alloc(sizeof(nsMsgSearchAttribValue) * totalAttributes);</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+        moz_xmalloc(sizeof(nsMsgSearchAttribValue) * totalAttributes);</span>
<a href="#l14.14"></a><span id="l14.14">     NS_ENSURE_TRUE(array, NS_ERROR_OUT_OF_MEMORY);</span>
<a href="#l14.15"></a><span id="l14.15"> </span>
<a href="#l14.16"></a><span id="l14.16">     uint32_t numStored=0;</span>
<a href="#l14.17"></a><span id="l14.17">     for (i = 0; i&lt; nsMsgSearchAttrib::kNumMsgSearchAttributes; i++) {</span>
<a href="#l14.18"></a><span id="l14.18">         for (j=0; j&lt; nsMsgSearchOp::kNumMsgSearchOperators; j++) {</span>
<a href="#l14.19"></a><span id="l14.19">             if (m_table[i][j].bitAvailable) {</span>
<a href="#l14.20"></a><span id="l14.20">                 array[numStored++] = i;</span>
<a href="#l14.21"></a><span id="l14.21">                 break;</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineat">@@ -906,17 +906,17 @@ nsMsgSearchValidityTable::GetAvailableOp</span>
<a href="#l14.23"></a><span id="l14.23">     uint32_t totalOperators=0;</span>
<a href="#l14.24"></a><span id="l14.24">     int32_t i;</span>
<a href="#l14.25"></a><span id="l14.25">     for (i=0; i&lt;nsMsgSearchOp::kNumMsgSearchOperators; i++) {</span>
<a href="#l14.26"></a><span id="l14.26">         if (m_table[attr][i].bitAvailable)</span>
<a href="#l14.27"></a><span id="l14.27">             totalOperators++;</span>
<a href="#l14.28"></a><span id="l14.28">     }</span>
<a href="#l14.29"></a><span id="l14.29"> </span>
<a href="#l14.30"></a><span id="l14.30">     nsMsgSearchOpValue *array = (nsMsgSearchOpValue*)</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineminus">-        nsMemory::Alloc(sizeof(nsMsgSearchOpValue) * totalOperators);</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+        moz_xmalloc(sizeof(nsMsgSearchOpValue) * totalOperators);</span>
<a href="#l14.33"></a><span id="l14.33">     NS_ENSURE_TRUE(array, NS_ERROR_OUT_OF_MEMORY);</span>
<a href="#l14.34"></a><span id="l14.34"> </span>
<a href="#l14.35"></a><span id="l14.35">     uint32_t numStored = 0;</span>
<a href="#l14.36"></a><span id="l14.36">     for (i=0; i&lt;nsMsgSearchOp::kNumMsgSearchOperators;i++) {</span>
<a href="#l14.37"></a><span id="l14.37">         if (m_table[attr][i].bitAvailable)</span>
<a href="#l14.38"></a><span id="l14.38">             array[numStored++] = i;</span>
<a href="#l14.39"></a><span id="l14.39">     }</span>
<a href="#l14.40"></a><span id="l14.40"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/base/search/src/nsMsgSearchNews.cpp</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/base/search/src/nsMsgSearchNews.cpp</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -63,17 +63,17 @@ nsresult nsMsgSearchNews::Search (bool *</span>
<a href="#l15.4"></a><span id="l15.4"> }</span>
<a href="#l15.5"></a><span id="l15.5"> </span>
<a href="#l15.6"></a><span id="l15.6"> char16_t *nsMsgSearchNews::EncodeToWildmat (const char16_t *value)</span>
<a href="#l15.7"></a><span id="l15.7"> {</span>
<a href="#l15.8"></a><span id="l15.8">   // Here we take advantage of XPAT's use of the wildmat format, which allows</span>
<a href="#l15.9"></a><span id="l15.9">   // a case-insensitive match by specifying each case possibility for each character</span>
<a href="#l15.10"></a><span id="l15.10">   // So, &quot;FooBar&quot; is encoded as &quot;[Ff][Oo][Bb][Aa][Rr]&quot;</span>
<a href="#l15.11"></a><span id="l15.11"> </span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-  char16_t *caseInsensitiveValue = (char16_t*) nsMemory::Alloc(sizeof(char16_t) * ((4 * NS_strlen(value)) + 1));</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+  char16_t *caseInsensitiveValue = (char16_t*) moz_xmalloc(sizeof(char16_t) * ((4 * NS_strlen(value)) + 1));</span>
<a href="#l15.14"></a><span id="l15.14">   if (caseInsensitiveValue)</span>
<a href="#l15.15"></a><span id="l15.15">   {</span>
<a href="#l15.16"></a><span id="l15.16">     char16_t *walkValue = caseInsensitiveValue;</span>
<a href="#l15.17"></a><span id="l15.17">     while (*value)</span>
<a href="#l15.18"></a><span id="l15.18">     {</span>
<a href="#l15.19"></a><span id="l15.19">       if (isalpha(*value))</span>
<a href="#l15.20"></a><span id="l15.20">       {</span>
<a href="#l15.21"></a><span id="l15.21">         *walkValue++ = (char16_t)'[';</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineat">@@ -171,17 +171,17 @@ char *nsMsgSearchNews::EncodeTerm (nsIMs</span>
<a href="#l15.23"></a><span id="l15.23">     return nullptr;</span>
<a href="#l15.24"></a><span id="l15.24"> </span>
<a href="#l15.25"></a><span id="l15.25">   // TO DO: Do INTL_FormatNNTPXPATInRFC1522Format trick for non-ASCII string</span>
<a href="#l15.26"></a><span id="l15.26">   // Unfortunately, we currently do not handle xxx or xxx search in XPAT</span>
<a href="#l15.27"></a><span id="l15.27">   // Need to add the INTL_FormatNNTPXPATInRFC1522Format call after we can do that</span>
<a href="#l15.28"></a><span id="l15.28">   // so we should search a string in either RFC1522 format and non-RFC1522 format</span>
<a href="#l15.29"></a><span id="l15.29"> </span>
<a href="#l15.30"></a><span id="l15.30">   char16_t *escapedValue = EscapeSearchUrl (caseInsensitiveValue);</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineminus">-  nsMemory::Free(caseInsensitiveValue);</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+  free(caseInsensitiveValue);</span>
<a href="#l15.33"></a><span id="l15.33">   if (!escapedValue)</span>
<a href="#l15.34"></a><span id="l15.34">     return nullptr;</span>
<a href="#l15.35"></a><span id="l15.35"> </span>
<a href="#l15.36"></a><span id="l15.36">   nsAutoCString pattern;</span>
<a href="#l15.37"></a><span id="l15.37"> </span>
<a href="#l15.38"></a><span id="l15.38">   if (leadingStar)</span>
<a href="#l15.39"></a><span id="l15.39">       pattern.Append('*');</span>
<a href="#l15.40"></a><span id="l15.40">     pattern.Append(NS_ConvertUTF16toUTF8(escapedValue));</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/base/src/nsMessenger.cpp</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/base/src/nsMessenger.cpp</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -2174,17 +2174,17 @@ NS_IMETHODIMP nsMessenger::GetNavigateHi</span>
<a href="#l16.4"></a><span id="l16.4"> </span>
<a href="#l16.5"></a><span id="l16.5">   *aCurPos = mCurHistoryPos &gt;&gt; 1;</span>
<a href="#l16.6"></a><span id="l16.6">   *aCount = mLoadedMsgHistory.Length();</span>
<a href="#l16.7"></a><span id="l16.7">   // for just enabling commands, we don't need the history uris.</span>
<a href="#l16.8"></a><span id="l16.8">   if (!aHistoryUris)</span>
<a href="#l16.9"></a><span id="l16.9">     return NS_OK;</span>
<a href="#l16.10"></a><span id="l16.10"> </span>
<a href="#l16.11"></a><span id="l16.11">   char **outArray, **next;</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-  next = outArray = (char **)nsMemory::Alloc(*aCount * sizeof(char *));</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+  next = outArray = (char **)moz_xmalloc(*aCount * sizeof(char *));</span>
<a href="#l16.14"></a><span id="l16.14">   if (!outArray) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.15"></a><span id="l16.15">   for (uint32_t i = 0; i &lt; *aCount; i++)</span>
<a href="#l16.16"></a><span id="l16.16">   {</span>
<a href="#l16.17"></a><span id="l16.17">     *next = ToNewCString(mLoadedMsgHistory[i]);</span>
<a href="#l16.18"></a><span id="l16.18">     if (!*next)</span>
<a href="#l16.19"></a><span id="l16.19">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.20"></a><span id="l16.20">     next++;</span>
<a href="#l16.21"></a><span id="l16.21">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -2463,17 +2463,17 @@ NS_IMETHODIMP nsMsgDBView::GetURIsForSel</span>
<a href="#l17.4"></a><span id="l17.4">   nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l17.5"></a><span id="l17.5">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.6"></a><span id="l17.6">   rv = GetHeadersFromSelection(selection.Elements(), numIndices, messages);</span>
<a href="#l17.7"></a><span id="l17.7">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.8"></a><span id="l17.8">   messages-&gt;GetLength(length);</span>
<a href="#l17.9"></a><span id="l17.9">   uint32_t numMsgsSelected = *length;</span>
<a href="#l17.10"></a><span id="l17.10"> </span>
<a href="#l17.11"></a><span id="l17.11">   char **outArray, **next;</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-  next = outArray = (char **)nsMemory::Alloc(numMsgsSelected * sizeof(char *));</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+  next = outArray = (char **)moz_xmalloc(numMsgsSelected * sizeof(char *));</span>
<a href="#l17.14"></a><span id="l17.14">   if (!outArray) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l17.15"></a><span id="l17.15">   for (uint32_t i = 0; i &lt; numMsgsSelected; i++)</span>
<a href="#l17.16"></a><span id="l17.16">   {</span>
<a href="#l17.17"></a><span id="l17.17">     nsCString tmpUri;</span>
<a href="#l17.18"></a><span id="l17.18">     nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr = do_QueryElementAt(messages, i, &amp;rv);</span>
<a href="#l17.19"></a><span id="l17.19">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.20"></a><span id="l17.20">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l17.21"></a><span id="l17.21">     nsMsgKey msgKey;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -1480,32 +1480,32 @@ nsMsgDBFolder::MarkAllMessagesRead(nsIMs</span>
<a href="#l18.4"></a><span id="l18.4">     uint32_t numMarked;</span>
<a href="#l18.5"></a><span id="l18.5">     rv = mDatabase-&gt;MarkAllRead(&amp;numMarked, &amp;thoseMarked);</span>
<a href="#l18.6"></a><span id="l18.6">     EnableNotifications(allMessageCountNotifications, true, true /*dbBatching*/);</span>
<a href="#l18.7"></a><span id="l18.7">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.8"></a><span id="l18.8"> </span>
<a href="#l18.9"></a><span id="l18.9">     // Setup a undo-state</span>
<a href="#l18.10"></a><span id="l18.10">     if (aMsgWindow &amp;&amp; numMarked)</span>
<a href="#l18.11"></a><span id="l18.11">       rv = AddMarkAllReadUndoAction(aMsgWindow, thoseMarked, numMarked);</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-    nsMemory::Free(thoseMarked);</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+    free(thoseMarked);</span>
<a href="#l18.14"></a><span id="l18.14">   }</span>
<a href="#l18.15"></a><span id="l18.15"> </span>
<a href="#l18.16"></a><span id="l18.16">   SetHasNewMessages(false);</span>
<a href="#l18.17"></a><span id="l18.17">   return rv;</span>
<a href="#l18.18"></a><span id="l18.18"> }</span>
<a href="#l18.19"></a><span id="l18.19"> </span>
<a href="#l18.20"></a><span id="l18.20"> NS_IMETHODIMP nsMsgDBFolder::MarkThreadRead(nsIMsgThread *thread)</span>
<a href="#l18.21"></a><span id="l18.21"> {</span>
<a href="#l18.22"></a><span id="l18.22">   nsresult rv = GetDatabase();</span>
<a href="#l18.23"></a><span id="l18.23">   if(NS_SUCCEEDED(rv))</span>
<a href="#l18.24"></a><span id="l18.24">   {</span>
<a href="#l18.25"></a><span id="l18.25">     nsMsgKey *keys;</span>
<a href="#l18.26"></a><span id="l18.26">     uint32_t numKeys;</span>
<a href="#l18.27"></a><span id="l18.27">     rv = mDatabase-&gt;MarkThreadRead(thread, nullptr, &amp;numKeys, &amp;keys);</span>
<a href="#l18.28"></a><span id="l18.28" class="difflineminus">-    nsMemory::Free(keys);</span>
<a href="#l18.29"></a><span id="l18.29" class="difflineplus">+    free(keys);</span>
<a href="#l18.30"></a><span id="l18.30">   }</span>
<a href="#l18.31"></a><span id="l18.31">   return rv;</span>
<a href="#l18.32"></a><span id="l18.32"> }</span>
<a href="#l18.33"></a><span id="l18.33"> </span>
<a href="#l18.34"></a><span id="l18.34"> NS_IMETHODIMP</span>
<a href="#l18.35"></a><span id="l18.35"> nsMsgDBFolder::OnStartRunningUrl(nsIURI *aUrl)</span>
<a href="#l18.36"></a><span id="l18.36"> {</span>
<a href="#l18.37"></a><span id="l18.37">   return NS_OK;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/base/util/nsMsgKeySet.cpp</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgKeySet.cpp</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -281,35 +281,35 @@ nsMsgKeySet::Output(char **outputStr)</span>
<a href="#l19.4"></a><span id="l19.4">   *outputStr = nullptr;</span>
<a href="#l19.5"></a><span id="l19.5"> </span>
<a href="#l19.6"></a><span id="l19.6">   size = m_length;</span>
<a href="#l19.7"></a><span id="l19.7">   head = m_data;</span>
<a href="#l19.8"></a><span id="l19.8">   tail = head;</span>
<a href="#l19.9"></a><span id="l19.9">   end = head + size;</span>
<a href="#l19.10"></a><span id="l19.10"> </span>
<a href="#l19.11"></a><span id="l19.11">   s_size = (size * 12) + 10;  // dmb - try to make this allocation get used at least once.</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-  s_head = (char *) nsMemory::Alloc(s_size);</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+  s_head = (char *) moz_xmalloc(s_size);</span>
<a href="#l19.14"></a><span id="l19.14">   if (! s_head) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l19.15"></a><span id="l19.15"> </span>
<a href="#l19.16"></a><span id="l19.16">   s_head[0] = '\0';      // otherwise, s_head will contain garbage.</span>
<a href="#l19.17"></a><span id="l19.17">   s = s_head;</span>
<a href="#l19.18"></a><span id="l19.18">   s_end = s + s_size;</span>
<a href="#l19.19"></a><span id="l19.19"> </span>
<a href="#l19.20"></a><span id="l19.20">   while (tail &lt; end) {</span>
<a href="#l19.21"></a><span id="l19.21">     int32_t from;</span>
<a href="#l19.22"></a><span id="l19.22">     int32_t to;</span>
<a href="#l19.23"></a><span id="l19.23"> </span>
<a href="#l19.24"></a><span id="l19.24">     if (s &gt; (s_end - (12 * 2 + 10))) { /* 12 bytes for each number (enough</span>
<a href="#l19.25"></a><span id="l19.25">                         for &quot;2147483647&quot; aka 2^31-1),</span>
<a href="#l19.26"></a><span id="l19.26">                         plus 10 bytes of slop. */</span>
<a href="#l19.27"></a><span id="l19.27">       int32_t so = s - s_head;</span>
<a href="#l19.28"></a><span id="l19.28">       s_size += 200;</span>
<a href="#l19.29"></a><span id="l19.29" class="difflineminus">-      char* tmp = (char *) nsMemory::Alloc(s_size);</span>
<a href="#l19.30"></a><span id="l19.30" class="difflineplus">+      char* tmp = (char *) moz_xmalloc(s_size);</span>
<a href="#l19.31"></a><span id="l19.31">       if (tmp) PL_strcpy(tmp, s_head);</span>
<a href="#l19.32"></a><span id="l19.32" class="difflineminus">-      nsMemory::Free(s_head);</span>
<a href="#l19.33"></a><span id="l19.33" class="difflineplus">+      free(s_head);</span>
<a href="#l19.34"></a><span id="l19.34">       s_head = tmp;</span>
<a href="#l19.35"></a><span id="l19.35">       if (!s_head) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l19.36"></a><span id="l19.36">       s = s_head + so;</span>
<a href="#l19.37"></a><span id="l19.37">       s_end = s_head + s_size;</span>
<a href="#l19.38"></a><span id="l19.38">     }</span>
<a href="#l19.39"></a><span id="l19.39"> </span>
<a href="#l19.40"></a><span id="l19.40">     if (*tail &lt; 0) {</span>
<a href="#l19.41"></a><span id="l19.41">       /* it's a range */</span>
<a href="#l19.42"></a><span id="l19.42" class="difflineat">@@ -1206,42 +1206,42 @@ nsMsgKeySet::ToMsgKeyArray(nsTArray&lt;nsMs</span>
<a href="#l19.43"></a><span id="l19.43"> </span>
<a href="#l19.44"></a><span id="l19.44"> void</span>
<a href="#l19.45"></a><span id="l19.45"> nsMsgKeySet::test_decoder (const char *string)</span>
<a href="#l19.46"></a><span id="l19.46"> {</span>
<a href="#l19.47"></a><span id="l19.47">   nsMsgKeySet set(string /* , NULL */);</span>
<a href="#l19.48"></a><span id="l19.48">   char* tmp;</span>
<a href="#l19.49"></a><span id="l19.49">   set.Output(&amp;tmp);</span>
<a href="#l19.50"></a><span id="l19.50">   printf (&quot;\t\&quot;%s\&quot;\t--&gt; \&quot;%s\&quot;\n&quot;, string, tmp);</span>
<a href="#l19.51"></a><span id="l19.51" class="difflineminus">-  nsMemory::Free(tmp);</span>
<a href="#l19.52"></a><span id="l19.52" class="difflineplus">+  free(tmp);</span>
<a href="#l19.53"></a><span id="l19.53"> }</span>
<a href="#l19.54"></a><span id="l19.54"> </span>
<a href="#l19.55"></a><span id="l19.55"> </span>
<a href="#l19.56"></a><span id="l19.56"> #define START(STRING) \</span>
<a href="#l19.57"></a><span id="l19.57">   string = STRING;    \</span>
<a href="#l19.58"></a><span id="l19.58">   if (!(set = nsMsgKeySet::Create(string))) abort ()</span>
<a href="#l19.59"></a><span id="l19.59"> </span>
<a href="#l19.60"></a><span id="l19.60"> #define FROB(N,PUSHP)                  \</span>
<a href="#l19.61"></a><span id="l19.61">   i = N;                        \</span>
<a href="#l19.62"></a><span id="l19.62">   if (!(NS_SUCCEEDED(set-&gt;Output(&amp;s)))) abort ();          \</span>
<a href="#l19.63"></a><span id="l19.63">   printf (&quot;%3lu: %-58s %c %3lu =\n&quot;, (unsigned long)set-&gt;m_length, s,  \</span>
<a href="#l19.64"></a><span id="l19.64">       (PUSHP ? '+' : '-'), (unsigned long)i);            \</span>
<a href="#l19.65"></a><span id="l19.65" class="difflineminus">-  nsMemory::Free(s);                      \</span>
<a href="#l19.66"></a><span id="l19.66" class="difflineplus">+  free(s);                      \</span>
<a href="#l19.67"></a><span id="l19.67">   if (PUSHP                        \</span>
<a href="#l19.68"></a><span id="l19.68">     ? set-&gt;Add(i) &lt; 0                  \</span>
<a href="#l19.69"></a><span id="l19.69">     : set-&gt;Remove(i) &lt; 0)                \</span>
<a href="#l19.70"></a><span id="l19.70">   abort ();                      \</span>
<a href="#l19.71"></a><span id="l19.71">   if (!(NS_SUCCEEDED(set-&gt;Output(&amp;s)))) abort ();          \</span>
<a href="#l19.72"></a><span id="l19.72">   printf (&quot;%3lu: %-58s optimized =\n&quot;, (unsigned long)set-&gt;m_length, s);  \</span>
<a href="#l19.73"></a><span id="l19.73" class="difflineminus">-  nsMemory::Free(s);                      \</span>
<a href="#l19.74"></a><span id="l19.74" class="difflineplus">+  free(s);                      \</span>
<a href="#l19.75"></a><span id="l19.75"> </span>
<a href="#l19.76"></a><span id="l19.76"> #define END()                 \</span>
<a href="#l19.77"></a><span id="l19.77">   if (!(NS_SUCCEEDED(set-&gt;Output(&amp;s)))) abort ();          \</span>
<a href="#l19.78"></a><span id="l19.78">   printf (&quot;%3lu: %s\n\n&quot;, (unsigned long)set-&gt;m_length, s); \</span>
<a href="#l19.79"></a><span id="l19.79" class="difflineminus">-  nsMemory::Free(s);                      \</span>
<a href="#l19.80"></a><span id="l19.80" class="difflineplus">+  free(s);                      \</span>
<a href="#l19.81"></a><span id="l19.81">   delete set;                 \</span>
<a href="#l19.82"></a><span id="l19.82"> </span>
<a href="#l19.83"></a><span id="l19.83"> </span>
<a href="#l19.84"></a><span id="l19.84"> </span>
<a href="#l19.85"></a><span id="l19.85"> void</span>
<a href="#l19.86"></a><span id="l19.86"> nsMsgKeySet::test_adder (void)</span>
<a href="#l19.87"></a><span id="l19.87"> {</span>
<a href="#l19.88"></a><span id="l19.88">   const char *string;</span>
<a href="#l19.89"></a><span id="l19.89" class="difflineat">@@ -1327,35 +1327,35 @@ nsMsgKeySet::test_adder (void)</span>
<a href="#l19.90"></a><span id="l19.90">   string = STRING;    \</span>
<a href="#l19.91"></a><span id="l19.91">   if (!(set = nsMsgKeySet::Create(string))) abort ()</span>
<a href="#l19.92"></a><span id="l19.92"> </span>
<a href="#l19.93"></a><span id="l19.93"> #define FROB(N,M)                        \</span>
<a href="#l19.94"></a><span id="l19.94">   i = N;                            \</span>
<a href="#l19.95"></a><span id="l19.95">   j = M;                            \</span>
<a href="#l19.96"></a><span id="l19.96">   if (!(NS_SUCCEEDED(set-&gt;Output(&amp;s)))) abort ();          \</span>
<a href="#l19.97"></a><span id="l19.97">   printf (&quot;%3lu: %-58s + %3lu-%3lu =\n&quot;, (unsigned long)set-&gt;m_length, s, (unsigned long)i, (unsigned long)j);  \</span>
<a href="#l19.98"></a><span id="l19.98" class="difflineminus">-  nsMemory::Free(s);                      \</span>
<a href="#l19.99"></a><span id="l19.99" class="difflineplus">+  free(s);                      \</span>
<a href="#l19.100"></a><span id="l19.100">   switch (set-&gt;AddRange(i, j)) {                \</span>
<a href="#l19.101"></a><span id="l19.101">   case 0:                            \</span>
<a href="#l19.102"></a><span id="l19.102">   printf(&quot;(no-op)\n&quot;);                    \</span>
<a href="#l19.103"></a><span id="l19.103">   break;                            \</span>
<a href="#l19.104"></a><span id="l19.104">   case 1:                            \</span>
<a href="#l19.105"></a><span id="l19.105">   break;                            \</span>
<a href="#l19.106"></a><span id="l19.106">   default:                            \</span>
<a href="#l19.107"></a><span id="l19.107">   abort();                          \</span>
<a href="#l19.108"></a><span id="l19.108">   }                                \</span>
<a href="#l19.109"></a><span id="l19.109">   if (!(NS_SUCCEEDED(set-&gt;Output(&amp;s)))) abort ();          \</span>
<a href="#l19.110"></a><span id="l19.110">   printf (&quot;%3lu: %-58s\n&quot;, (unsigned long)set-&gt;m_length, s);            \</span>
<a href="#l19.111"></a><span id="l19.111" class="difflineminus">-  nsMemory::Free(s);                      \</span>
<a href="#l19.112"></a><span id="l19.112" class="difflineplus">+  free(s);                      \</span>
<a href="#l19.113"></a><span id="l19.113"> </span>
<a href="#l19.114"></a><span id="l19.114"> </span>
<a href="#l19.115"></a><span id="l19.115"> #define END()                 \</span>
<a href="#l19.116"></a><span id="l19.116">   if (!(NS_SUCCEEDED(set-&gt;Output(&amp;s)))) abort ();          \</span>
<a href="#l19.117"></a><span id="l19.117">   printf (&quot;%3lu: %s\n\n&quot;, (unsigned long)set-&gt;m_length, s); \</span>
<a href="#l19.118"></a><span id="l19.118" class="difflineminus">-  nsMemory::Free(s);                      \</span>
<a href="#l19.119"></a><span id="l19.119" class="difflineplus">+  free(s);                      \</span>
<a href="#l19.120"></a><span id="l19.120">   delete set;</span>
<a href="#l19.121"></a><span id="l19.121"> </span>
<a href="#l19.122"></a><span id="l19.122"> </span>
<a href="#l19.123"></a><span id="l19.123"> void</span>
<a href="#l19.124"></a><span id="l19.124"> nsMsgKeySet::test_ranges(void)</span>
<a href="#l19.125"></a><span id="l19.125"> {</span>
<a href="#l19.126"></a><span id="l19.126">   const char *string;</span>
<a href="#l19.127"></a><span id="l19.127">   nsMsgKeySet *set;</span>
<a href="#l19.128"></a><span id="l19.128" class="difflineat">@@ -1386,17 +1386,17 @@ nsMsgKeySet::test_ranges(void)</span>
<a href="#l19.129"></a><span id="l19.129"> </span>
<a href="#l19.130"></a><span id="l19.130"> </span>
<a href="#l19.131"></a><span id="l19.131"> </span>
<a href="#l19.132"></a><span id="l19.132"> #define TEST(N)                    \</span>
<a href="#l19.133"></a><span id="l19.133">   if (! with_cache) set-&gt;m_cached_value = -1;    \</span>
<a href="#l19.134"></a><span id="l19.134">   if (!(NS_SUCCEEDED(set-&gt;Output(&amp;s)))) abort ();          \</span>
<a href="#l19.135"></a><span id="l19.135">   printf (&quot; %3d = %s\n&quot;, N,              \</span>
<a href="#l19.136"></a><span id="l19.136">       (set-&gt;IsMember(N) ? &quot;true&quot; : &quot;false&quot;)); \</span>
<a href="#l19.137"></a><span id="l19.137" class="difflineminus">-  nsMemory::Free(s);</span>
<a href="#l19.138"></a><span id="l19.138" class="difflineplus">+  free(s);</span>
<a href="#l19.139"></a><span id="l19.139"> </span>
<a href="#l19.140"></a><span id="l19.140"> void</span>
<a href="#l19.141"></a><span id="l19.141"> nsMsgKeySet::test_member(bool with_cache)</span>
<a href="#l19.142"></a><span id="l19.142"> {</span>
<a href="#l19.143"></a><span id="l19.143">   nsMsgKeySet *set;</span>
<a href="#l19.144"></a><span id="l19.144">   char *s;</span>
<a href="#l19.145"></a><span id="l19.145"> </span>
<a href="#l19.146"></a><span id="l19.146">   s = &quot;1-70,72-99,105,107,110-111,117-200&quot;;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/base/util/nsMsgProtocol.cpp</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgProtocol.cpp</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -829,17 +829,17 @@ nsresult nsMsgProtocol::DoGSSAPIStep1(co</span>
<a href="#l20.4"></a><span id="l20.4">     rv = m_authModule-&gt;GetNextToken((void *)nullptr, 0, &amp;outBuf, &amp;outBufLen);</span>
<a href="#l20.5"></a><span id="l20.5">     if (NS_SUCCEEDED(rv) &amp;&amp; outBuf)</span>
<a href="#l20.6"></a><span id="l20.6">     {</span>
<a href="#l20.7"></a><span id="l20.7">         char *base64Str = PL_Base64Encode((char *)outBuf, outBufLen, nullptr);</span>
<a href="#l20.8"></a><span id="l20.8">         if (base64Str)</span>
<a href="#l20.9"></a><span id="l20.9">             response.Adopt(base64Str);</span>
<a href="#l20.10"></a><span id="l20.10">         else</span>
<a href="#l20.11"></a><span id="l20.11">             rv = NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-        nsMemory::Free(outBuf);</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+        free(outBuf);</span>
<a href="#l20.14"></a><span id="l20.14">     }</span>
<a href="#l20.15"></a><span id="l20.15"> </span>
<a href="#l20.16"></a><span id="l20.16"> #ifdef DEBUG_BenB</span>
<a href="#l20.17"></a><span id="l20.17">     printf(&quot;GSSAPI step 1 succeeded\n&quot;);</span>
<a href="#l20.18"></a><span id="l20.18"> #endif</span>
<a href="#l20.19"></a><span id="l20.19">     return rv;</span>
<a href="#l20.20"></a><span id="l20.20"> }</span>
<a href="#l20.21"></a><span id="l20.21"> </span>
<a href="#l20.22"></a><span id="l20.22" class="difflineat">@@ -852,17 +852,17 @@ nsresult nsMsgProtocol::DoGSSAPIStep2(ns</span>
<a href="#l20.23"></a><span id="l20.23">     void *inBuf, *outBuf;</span>
<a href="#l20.24"></a><span id="l20.24">     uint32_t inBufLen, outBufLen;</span>
<a href="#l20.25"></a><span id="l20.25">     uint32_t len = commandResponse.Length();</span>
<a href="#l20.26"></a><span id="l20.26"> </span>
<a href="#l20.27"></a><span id="l20.27">     // Cyrus SASL may send us zero length tokens (grrrr)</span>
<a href="#l20.28"></a><span id="l20.28">     if (len &gt; 0) {</span>
<a href="#l20.29"></a><span id="l20.29">         // decode into the input secbuffer</span>
<a href="#l20.30"></a><span id="l20.30">         inBufLen = (len * 3)/4;      // sufficient size (see plbase64.h)</span>
<a href="#l20.31"></a><span id="l20.31" class="difflineminus">-        inBuf = nsMemory::Alloc(inBufLen);</span>
<a href="#l20.32"></a><span id="l20.32" class="difflineplus">+        inBuf = moz_xmalloc(inBufLen);</span>
<a href="#l20.33"></a><span id="l20.33">         if (!inBuf)</span>
<a href="#l20.34"></a><span id="l20.34">             return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.35"></a><span id="l20.35"> </span>
<a href="#l20.36"></a><span id="l20.36">         // strip off any padding (see bug 230351)</span>
<a href="#l20.37"></a><span id="l20.37">         const char *challenge = commandResponse.get();</span>
<a href="#l20.38"></a><span id="l20.38">         while (challenge[len - 1] == '=')</span>
<a href="#l20.39"></a><span id="l20.39">             len--;</span>
<a href="#l20.40"></a><span id="l20.40"> </span>
<a href="#l20.41"></a><span id="l20.41" class="difflineat">@@ -875,17 +875,17 @@ nsresult nsMsgProtocol::DoGSSAPIStep2(ns</span>
<a href="#l20.42"></a><span id="l20.42">         // If there are 2 remaining, add 1</span>
<a href="#l20.43"></a><span id="l20.43">         // 1 remaining is an error</span>
<a href="#l20.44"></a><span id="l20.44">         inBufLen = (len / 4)*3 + ((len % 4 == 3)?2:0) + ((len % 4 == 2)?1:0);</span>
<a href="#l20.45"></a><span id="l20.45"> </span>
<a href="#l20.46"></a><span id="l20.46">         rv = (PL_Base64Decode(challenge, len, (char *)inBuf))</span>
<a href="#l20.47"></a><span id="l20.47">              ? m_authModule-&gt;GetNextToken(inBuf, inBufLen, &amp;outBuf, &amp;outBufLen)</span>
<a href="#l20.48"></a><span id="l20.48">              : NS_ERROR_FAILURE;</span>
<a href="#l20.49"></a><span id="l20.49"> </span>
<a href="#l20.50"></a><span id="l20.50" class="difflineminus">-        nsMemory::Free(inBuf);</span>
<a href="#l20.51"></a><span id="l20.51" class="difflineplus">+        free(inBuf);</span>
<a href="#l20.52"></a><span id="l20.52">     }</span>
<a href="#l20.53"></a><span id="l20.53">     else</span>
<a href="#l20.54"></a><span id="l20.54">     {</span>
<a href="#l20.55"></a><span id="l20.55">         rv = m_authModule-&gt;GetNextToken(NULL, 0, &amp;outBuf, &amp;outBufLen);</span>
<a href="#l20.56"></a><span id="l20.56">     }</span>
<a href="#l20.57"></a><span id="l20.57">     if (NS_SUCCEEDED(rv))</span>
<a href="#l20.58"></a><span id="l20.58">     {</span>
<a href="#l20.59"></a><span id="l20.59">         // And in return, we may need to send Cyrus zero length tokens back</span>
<a href="#l20.60"></a><span id="l20.60" class="difflineat">@@ -924,45 +924,45 @@ nsresult nsMsgProtocol::DoNtlmStep1(cons</span>
<a href="#l20.61"></a><span id="l20.61">     rv = m_authModule-&gt;GetNextToken((void *)nullptr, 0, &amp;outBuf, &amp;outBufLen);</span>
<a href="#l20.62"></a><span id="l20.62">     if (NS_SUCCEEDED(rv) &amp;&amp; outBuf)</span>
<a href="#l20.63"></a><span id="l20.63">     {</span>
<a href="#l20.64"></a><span id="l20.64">         char *base64Str = PL_Base64Encode((char *)outBuf, outBufLen, nullptr);</span>
<a href="#l20.65"></a><span id="l20.65">         if (base64Str)</span>
<a href="#l20.66"></a><span id="l20.66">           response.Adopt(base64Str);</span>
<a href="#l20.67"></a><span id="l20.67">         else</span>
<a href="#l20.68"></a><span id="l20.68">           rv = NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.69"></a><span id="l20.69" class="difflineminus">-        nsMemory::Free(outBuf);</span>
<a href="#l20.70"></a><span id="l20.70" class="difflineplus">+        free(outBuf);</span>
<a href="#l20.71"></a><span id="l20.71">     }</span>
<a href="#l20.72"></a><span id="l20.72"> </span>
<a href="#l20.73"></a><span id="l20.73">     return rv;</span>
<a href="#l20.74"></a><span id="l20.74"> }</span>
<a href="#l20.75"></a><span id="l20.75"> </span>
<a href="#l20.76"></a><span id="l20.76"> nsresult nsMsgProtocol::DoNtlmStep2(nsCString &amp;commandResponse, nsCString &amp;response)</span>
<a href="#l20.77"></a><span id="l20.77"> {</span>
<a href="#l20.78"></a><span id="l20.78">     nsresult rv;</span>
<a href="#l20.79"></a><span id="l20.79">     void *inBuf, *outBuf;</span>
<a href="#l20.80"></a><span id="l20.80">     uint32_t inBufLen, outBufLen;</span>
<a href="#l20.81"></a><span id="l20.81">     uint32_t len = commandResponse.Length();</span>
<a href="#l20.82"></a><span id="l20.82"> </span>
<a href="#l20.83"></a><span id="l20.83">     // decode into the input secbuffer</span>
<a href="#l20.84"></a><span id="l20.84">     inBufLen = (len * 3)/4;      // sufficient size (see plbase64.h)</span>
<a href="#l20.85"></a><span id="l20.85" class="difflineminus">-    inBuf = nsMemory::Alloc(inBufLen);</span>
<a href="#l20.86"></a><span id="l20.86" class="difflineplus">+    inBuf = moz_xmalloc(inBufLen);</span>
<a href="#l20.87"></a><span id="l20.87">     if (!inBuf)</span>
<a href="#l20.88"></a><span id="l20.88">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.89"></a><span id="l20.89"> </span>
<a href="#l20.90"></a><span id="l20.90">     // strip off any padding (see bug 230351)</span>
<a href="#l20.91"></a><span id="l20.91">     const char *challenge = commandResponse.get();</span>
<a href="#l20.92"></a><span id="l20.92">     while (challenge[len - 1] == '=')</span>
<a href="#l20.93"></a><span id="l20.93">         len--;</span>
<a href="#l20.94"></a><span id="l20.94"> </span>
<a href="#l20.95"></a><span id="l20.95">     rv = (PL_Base64Decode(challenge, len, (char *)inBuf))</span>
<a href="#l20.96"></a><span id="l20.96">          ? m_authModule-&gt;GetNextToken(inBuf, inBufLen, &amp;outBuf, &amp;outBufLen)</span>
<a href="#l20.97"></a><span id="l20.97">          : NS_ERROR_FAILURE;</span>
<a href="#l20.98"></a><span id="l20.98"> </span>
<a href="#l20.99"></a><span id="l20.99" class="difflineminus">-    nsMemory::Free(inBuf);</span>
<a href="#l20.100"></a><span id="l20.100" class="difflineplus">+    free(inBuf);</span>
<a href="#l20.101"></a><span id="l20.101">     if (NS_SUCCEEDED(rv) &amp;&amp; outBuf)</span>
<a href="#l20.102"></a><span id="l20.102">     {</span>
<a href="#l20.103"></a><span id="l20.103">         char *base64Str = PL_Base64Encode((char *)outBuf, outBufLen, nullptr);</span>
<a href="#l20.104"></a><span id="l20.104">         if (base64Str)</span>
<a href="#l20.105"></a><span id="l20.105">           response.Adopt(base64Str);</span>
<a href="#l20.106"></a><span id="l20.106">         else</span>
<a href="#l20.107"></a><span id="l20.107">           rv = NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l20.108"></a><span id="l20.108">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/base/util/nsMsgUtils.cpp</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgUtils.cpp</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -1794,17 +1794,17 @@ NS_MSG_BASE char16_t *MsgEscapeHTML2(con</span>
<a href="#l21.4"></a><span id="l21.4">     aSourceBufferLen = NS_strlen(aSourceBuffer); // ...then I will</span>
<a href="#l21.5"></a><span id="l21.5">   }</span>
<a href="#l21.6"></a><span id="l21.6"> </span>
<a href="#l21.7"></a><span id="l21.7">   /* XXX Hardcoded max entity len. */</span>
<a href="#l21.8"></a><span id="l21.8">   if (aSourceBufferLen &gt;=</span>
<a href="#l21.9"></a><span id="l21.9">     ((PR_UINT32_MAX - sizeof(char16_t)) / (6 * sizeof(char16_t))) )</span>
<a href="#l21.10"></a><span id="l21.10">       return nullptr;</span>
<a href="#l21.11"></a><span id="l21.11"> </span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-  char16_t *resultBuffer = (char16_t *)nsMemory::Alloc(aSourceBufferLen *</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+  char16_t *resultBuffer = (char16_t *)moz_xmalloc(aSourceBufferLen *</span>
<a href="#l21.14"></a><span id="l21.14">                             6 * sizeof(char16_t) + sizeof(char16_t('\0')));</span>
<a href="#l21.15"></a><span id="l21.15"> </span>
<a href="#l21.16"></a><span id="l21.16">   char16_t *ptr = resultBuffer;</span>
<a href="#l21.17"></a><span id="l21.17"> </span>
<a href="#l21.18"></a><span id="l21.18">   if (resultBuffer) {</span>
<a href="#l21.19"></a><span id="l21.19">     int32_t i;</span>
<a href="#l21.20"></a><span id="l21.20"> </span>
<a href="#l21.21"></a><span id="l21.21">     for(i = 0; i &lt; aSourceBufferLen; i++) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/compose/src/nsMsgCompose.cpp</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/compose/src/nsMsgCompose.cpp</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -2143,17 +2143,17 @@ NS_IMETHODIMP nsMsgCompose::GetOriginalM</span>
<a href="#l22.4"></a><span id="l22.4"> </span>
<a href="#l22.5"></a><span id="l22.5"> ////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l22.6"></a><span id="l22.6"> // THIS IS THE CLASS THAT IS THE STREAM CONSUMER OF THE HTML OUPUT</span>
<a href="#l22.7"></a><span id="l22.7"> // FROM LIBMIME. THIS IS FOR QUOTING</span>
<a href="#l22.8"></a><span id="l22.8"> ////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l22.9"></a><span id="l22.9"> QuotingOutputStreamListener::~QuotingOutputStreamListener()</span>
<a href="#l22.10"></a><span id="l22.10"> {</span>
<a href="#l22.11"></a><span id="l22.11">   if (mUnicodeConversionBuffer)</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-    nsMemory::Free(mUnicodeConversionBuffer);</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+    free(mUnicodeConversionBuffer);</span>
<a href="#l22.14"></a><span id="l22.14"> }</span>
<a href="#l22.15"></a><span id="l22.15"> </span>
<a href="#l22.16"></a><span id="l22.16"> QuotingOutputStreamListener::QuotingOutputStreamListener(const char * originalMsgURI,</span>
<a href="#l22.17"></a><span id="l22.17">                                                          nsIMsgDBHdr *originalMsgHdr,</span>
<a href="#l22.18"></a><span id="l22.18">                                                          bool quoteHeaders,</span>
<a href="#l22.19"></a><span id="l22.19">                                                          bool headersOnly,</span>
<a href="#l22.20"></a><span id="l22.20">                                                          nsIMsgIdentity *identity,</span>
<a href="#l22.21"></a><span id="l22.21">                                                          const char *charset,</span>
<a href="#l22.22"></a><span id="l22.22" class="difflineat">@@ -2878,18 +2878,18 @@ NS_IMETHODIMP QuotingOutputStreamListene</span>
<a href="#l22.23"></a><span id="l22.23"> </span>
<a href="#l22.24"></a><span id="l22.24">         if (unicharLength &gt; kLocalBufSize)</span>
<a href="#l22.25"></a><span id="l22.25">         {</span>
<a href="#l22.26"></a><span id="l22.26">           // Otherwise, use the buffer of the class.</span>
<a href="#l22.27"></a><span id="l22.27">           if (!mUnicodeConversionBuffer ||</span>
<a href="#l22.28"></a><span id="l22.28">               unicharLength &gt; mUnicodeBufferCharacterLength)</span>
<a href="#l22.29"></a><span id="l22.29">           {</span>
<a href="#l22.30"></a><span id="l22.30">             if (mUnicodeConversionBuffer)</span>
<a href="#l22.31"></a><span id="l22.31" class="difflineminus">-              nsMemory::Free(mUnicodeConversionBuffer);</span>
<a href="#l22.32"></a><span id="l22.32" class="difflineminus">-            mUnicodeConversionBuffer = (char16_t *) nsMemory::Alloc(unicharLength * sizeof(char16_t));</span>
<a href="#l22.33"></a><span id="l22.33" class="difflineplus">+              free(mUnicodeConversionBuffer);</span>
<a href="#l22.34"></a><span id="l22.34" class="difflineplus">+            mUnicodeConversionBuffer = (char16_t *) moz_xmalloc(unicharLength * sizeof(char16_t));</span>
<a href="#l22.35"></a><span id="l22.35">             if (!mUnicodeConversionBuffer)</span>
<a href="#l22.36"></a><span id="l22.36">             {</span>
<a href="#l22.37"></a><span id="l22.37">               mUnicodeBufferCharacterLength = 0;</span>
<a href="#l22.38"></a><span id="l22.38">               return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l22.39"></a><span id="l22.39">             }</span>
<a href="#l22.40"></a><span id="l22.40">             mUnicodeBufferCharacterLength = unicharLength;</span>
<a href="#l22.41"></a><span id="l22.41">           }</span>
<a href="#l22.42"></a><span id="l22.42">           unichars = mUnicodeConversionBuffer;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mailnews/compose/src/nsMsgComposeService.cpp</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mailnews/compose/src/nsMsgComposeService.cpp</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -636,17 +636,17 @@ NS_IMETHODIMP nsMsgComposeService::GetPa</span>
<a href="#l23.4"></a><span id="l23.4">       {</span>
<a href="#l23.5"></a><span id="l23.5">         if (composeHTMLFormat)</span>
<a href="#l23.6"></a><span id="l23.6">         {</span>
<a href="#l23.7"></a><span id="l23.7">           char *escaped = MsgEscapeHTML(bodyPart.get());</span>
<a href="#l23.8"></a><span id="l23.8">           if (!escaped)</span>
<a href="#l23.9"></a><span id="l23.9">             return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l23.10"></a><span id="l23.10"> </span>
<a href="#l23.11"></a><span id="l23.11">           CopyUTF8toUTF16(nsDependentCString(escaped), sanitizedBody);</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-          nsMemory::Free(escaped);</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+          free(escaped);</span>
<a href="#l23.14"></a><span id="l23.14">         }</span>
<a href="#l23.15"></a><span id="l23.15">         else</span>
<a href="#l23.16"></a><span id="l23.16">           CopyUTF8toUTF16(bodyPart, rawBody);</span>
<a href="#l23.17"></a><span id="l23.17">       }</span>
<a href="#l23.18"></a><span id="l23.18">       else</span>
<a href="#l23.19"></a><span id="l23.19">         CopyUTF8toUTF16(HTMLBodyPart, rawBody);</span>
<a href="#l23.20"></a><span id="l23.20"> </span>
<a href="#l23.21"></a><span id="l23.21">       if (!rawBody.IsEmpty() &amp;&amp; composeHTMLFormat)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mailnews/compose/src/nsMsgSend.cpp</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mailnews/compose/src/nsMsgSend.cpp</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -1958,17 +1958,17 @@ nsMsgComposeAndSend::ProcessMultipartRel</span>
<a href="#l24.4"></a><span id="l24.4">       anchor-&gt;SetHref(NS_ConvertASCIItoUTF16(domSaveArray[i].url));</span>
<a href="#l24.5"></a><span id="l24.5">     else if (link)</span>
<a href="#l24.6"></a><span id="l24.6">       link-&gt;SetHref(NS_ConvertASCIItoUTF16(domSaveArray[i].url));</span>
<a href="#l24.7"></a><span id="l24.7">     else if (image)</span>
<a href="#l24.8"></a><span id="l24.8">       image-&gt;SetSrc(NS_ConvertASCIItoUTF16(domSaveArray[i].url));</span>
<a href="#l24.9"></a><span id="l24.9">     else if (body)</span>
<a href="#l24.10"></a><span id="l24.10">       body-&gt;SetBackground(NS_ConvertASCIItoUTF16(domSaveArray[i].url));</span>
<a href="#l24.11"></a><span id="l24.11"> </span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-    nsMemory::Free(domSaveArray[i].url);</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+    free(domSaveArray[i].url);</span>
<a href="#l24.14"></a><span id="l24.14">   }</span>
<a href="#l24.15"></a><span id="l24.15"> </span>
<a href="#l24.16"></a><span id="l24.16">   PR_FREEIF(domSaveArray);</span>
<a href="#l24.17"></a><span id="l24.17"> </span>
<a href="#l24.18"></a><span id="l24.18">   //</span>
<a href="#l24.19"></a><span id="l24.19">   // Now, we have to create that first child node for the multipart</span>
<a href="#l24.20"></a><span id="l24.20">   // message that holds the body as well as the attachment handler</span>
<a href="#l24.21"></a><span id="l24.21">   // for this body part.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/db/msgdb/public/nsIMsgDatabase.idl</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/db/msgdb/public/nsIMsgDatabase.idl</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -554,17 +554,17 @@ interface nsIMsgDatabase : nsIDBChangeAn</span>
<a href="#l25.4"></a><span id="l25.4"> </span>
<a href="#l25.5"></a><span id="l25.5">   // for msg hdr hash table allocation. controllable by caller to improve folder loading preformance.</span>
<a href="#l25.6"></a><span id="l25.6">   attribute unsigned long msgHdrCacheSize;</span>
<a href="#l25.7"></a><span id="l25.7"> </span>
<a href="#l25.8"></a><span id="l25.8">   /**</span>
<a href="#l25.9"></a><span id="l25.9">    * The list of messages currently in the NEW state.</span>
<a href="#l25.10"></a><span id="l25.10">    * </span>
<a href="#l25.11"></a><span id="l25.11">    * If there are no such messages, a null pointer may be returned.</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-   * the caller should free when done using nsMemory::Free.</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+   * the caller should free when done using free.</span>
<a href="#l25.14"></a><span id="l25.14">    */</span>
<a href="#l25.15"></a><span id="l25.15">   void getNewList(out unsigned long count, [array, size_is(count)] out nsMsgKey newKeys);</span>
<a href="#l25.16"></a><span id="l25.16">   </span>
<a href="#l25.17"></a><span id="l25.17">   // These are used for caching search hits in a db, to speed up saved search folders.</span>
<a href="#l25.18"></a><span id="l25.18">   nsISimpleEnumerator getCachedHits(in string aSearchFolderUri);</span>
<a href="#l25.19"></a><span id="l25.19">   void refreshCache(in string aSearchFolderUri, in unsigned long aNumKeys, [array, size_is (aNumKeys)] in nsMsgKey aNewHits,</span>
<a href="#l25.20"></a><span id="l25.20">      out unsigned long aNumBadHits, [array, size_is(aNumBadHits)] out nsMsgKey aStaleHits);</span>
<a href="#l25.21"></a><span id="l25.21">   void updateHdrInCache(in string aSearchFolderUri, in nsIMsgDBHdr aHdr, in boolean aAdd);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -4031,17 +4031,17 @@ nsresult nsMsgDatabase::SetBooleanProper</span>
<a href="#l26.4"></a><span id="l26.4"> </span>
<a href="#l26.5"></a><span id="l26.5"> nsresult nsMsgDatabase::SetNSStringPropertyWithToken(nsIMdbRow *row, mdb_token aProperty, const nsAString &amp;propertyStr)</span>
<a href="#l26.6"></a><span id="l26.6"> {</span>
<a href="#l26.7"></a><span id="l26.7">   NS_ENSURE_ARG(row);</span>
<a href="#l26.8"></a><span id="l26.8">   struct mdbYarn yarn;</span>
<a href="#l26.9"></a><span id="l26.9"> </span>
<a href="#l26.10"></a><span id="l26.10">   yarn.mYarn_Grow = NULL;</span>
<a href="#l26.11"></a><span id="l26.11">   nsresult err = row-&gt;AddColumn(GetEnv(), aProperty, nsStringToYarn(&amp;yarn, propertyStr));</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-  nsMemory::Free((char *)yarn.mYarn_Buf);  // won't need this when we have nsCString</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+  free((char *)yarn.mYarn_Buf);  // won't need this when we have nsCString</span>
<a href="#l26.14"></a><span id="l26.14">   return err;</span>
<a href="#l26.15"></a><span id="l26.15"> }</span>
<a href="#l26.16"></a><span id="l26.16"> </span>
<a href="#l26.17"></a><span id="l26.17"> </span>
<a href="#l26.18"></a><span id="l26.18"> uint32_t nsMsgDatabase::GetCurVersion()</span>
<a href="#l26.19"></a><span id="l26.19"> {</span>
<a href="#l26.20"></a><span id="l26.20">   return kMsgDBVersion;</span>
<a href="#l26.21"></a><span id="l26.21"> }</span>
<a href="#l26.22"></a><span id="l26.22" class="difflineat">@@ -5672,17 +5672,17 @@ NS_IMETHODIMP</span>
<a href="#l26.23"></a><span id="l26.23"> nsMsgDatabase::GetNewList(uint32_t *aCount, nsMsgKey **aNewKeys)</span>
<a href="#l26.24"></a><span id="l26.24"> {</span>
<a href="#l26.25"></a><span id="l26.25">     NS_ENSURE_ARG_POINTER(aCount);</span>
<a href="#l26.26"></a><span id="l26.26">     NS_ENSURE_ARG_POINTER(aNewKeys);</span>
<a href="#l26.27"></a><span id="l26.27"> </span>
<a href="#l26.28"></a><span id="l26.28">     *aCount = m_newSet.Length();</span>
<a href="#l26.29"></a><span id="l26.29">     if (*aCount &gt; 0)</span>
<a href="#l26.30"></a><span id="l26.30">     {</span>
<a href="#l26.31"></a><span id="l26.31" class="difflineminus">-      *aNewKeys = static_cast&lt;nsMsgKey *&gt;(nsMemory::Alloc(*aCount * sizeof(nsMsgKey)));</span>
<a href="#l26.32"></a><span id="l26.32" class="difflineplus">+      *aNewKeys = static_cast&lt;nsMsgKey *&gt;(moz_xmalloc(*aCount * sizeof(nsMsgKey)));</span>
<a href="#l26.33"></a><span id="l26.33">       if (!*aNewKeys)</span>
<a href="#l26.34"></a><span id="l26.34">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l26.35"></a><span id="l26.35">       memcpy(*aNewKeys, m_newSet.Elements(), *aCount * sizeof(nsMsgKey));</span>
<a href="#l26.36"></a><span id="l26.36">       return NS_OK;</span>
<a href="#l26.37"></a><span id="l26.37">     }</span>
<a href="#l26.38"></a><span id="l26.38">     // if there were no new messages, signal this by returning a null pointer</span>
<a href="#l26.39"></a><span id="l26.39">     //</span>
<a href="#l26.40"></a><span id="l26.40">     *aNewKeys = nullptr;</span>
<a href="#l26.41"></a><span id="l26.41" class="difflineat">@@ -5780,17 +5780,17 @@ NS_IMETHODIMP nsMsgDatabase::RefreshCach</span>
<a href="#l26.42"></a><span id="l26.42">       table-&gt;CutOid(GetEnv(), &amp;oid);</span>
<a href="#l26.43"></a><span id="l26.43">       rowCount--;</span>
<a href="#l26.44"></a><span id="l26.44">       continue; // don't increment tableRowIndex since we removed that row.</span>
<a href="#l26.45"></a><span id="l26.45">     }</span>
<a href="#l26.46"></a><span id="l26.46">    }</span>
<a href="#l26.47"></a><span id="l26.47">    *aNumBadHits = staleHits.Length();</span>
<a href="#l26.48"></a><span id="l26.48">    if (*aNumBadHits)</span>
<a href="#l26.49"></a><span id="l26.49">    {</span>
<a href="#l26.50"></a><span id="l26.50" class="difflineminus">-     *aStaleHits = static_cast&lt;nsMsgKey *&gt;(nsMemory::Alloc(*aNumBadHits * sizeof(nsMsgKey)));</span>
<a href="#l26.51"></a><span id="l26.51" class="difflineplus">+     *aStaleHits = static_cast&lt;nsMsgKey *&gt;(moz_xmalloc(*aNumBadHits * sizeof(nsMsgKey)));</span>
<a href="#l26.52"></a><span id="l26.52">      if (!*aStaleHits)</span>
<a href="#l26.53"></a><span id="l26.53">        return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l26.54"></a><span id="l26.54">      memcpy(*aStaleHits, staleHits.Elements(), *aNumBadHits * sizeof(nsMsgKey));</span>
<a href="#l26.55"></a><span id="l26.55">    }</span>
<a href="#l26.56"></a><span id="l26.56">    else</span>
<a href="#l26.57"></a><span id="l26.57">      *aStaleHits = nullptr;</span>
<a href="#l26.58"></a><span id="l26.58"> </span>
<a href="#l26.59"></a><span id="l26.59"> #ifdef DEBUG_David_Bienvenu</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/mailnews/extensions/bayesian-spam-filter/src/nsBayesianFilter.cpp</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/mailnews/extensions/bayesian-spam-filter/src/nsBayesianFilter.cpp</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -1253,17 +1253,17 @@ public:</span>
<a href="#l27.4"></a><span id="l27.4">         mTraitListener(aTraitListener),</span>
<a href="#l27.5"></a><span id="l27.5">         mDetailListener(aDetailListener),</span>
<a href="#l27.6"></a><span id="l27.6">         mProTraits(aProTraits),</span>
<a href="#l27.7"></a><span id="l27.7">         mAntiTraits(aAntiTraits),</span>
<a href="#l27.8"></a><span id="l27.8">         mMsgWindow(aMsgWindow)</span>
<a href="#l27.9"></a><span id="l27.9">     {</span>
<a href="#l27.10"></a><span id="l27.10">       mCurMessageToClassify = 0;</span>
<a href="#l27.11"></a><span id="l27.11">       mNumMessagesToClassify = aNumMessagesToClassify;</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-      mMessageURIs = (char **) nsMemory::Alloc(sizeof(char *) * aNumMessagesToClassify);</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+      mMessageURIs = (char **) moz_xmalloc(sizeof(char *) * aNumMessagesToClassify);</span>
<a href="#l27.14"></a><span id="l27.14">       for (uint32_t i = 0; i &lt; aNumMessagesToClassify; i++)</span>
<a href="#l27.15"></a><span id="l27.15">         mMessageURIs[i] = PL_strdup(aMessageURIs[i]);</span>
<a href="#l27.16"></a><span id="l27.16"> </span>
<a href="#l27.17"></a><span id="l27.17">     }</span>
<a href="#l27.18"></a><span id="l27.18"> </span>
<a href="#l27.19"></a><span id="l27.19">     // junk-only classifier</span>
<a href="#l27.20"></a><span id="l27.20">     MessageClassifier(nsBayesianFilter* aFilter,</span>
<a href="#l27.21"></a><span id="l27.21">                       nsIJunkMailClassificationListener* aJunkListener,</span>
<a href="#l27.22"></a><span id="l27.22" class="difflineat">@@ -1274,17 +1274,17 @@ public:</span>
<a href="#l27.23"></a><span id="l27.23">         mJunkMailPlugin(aFilter),</span>
<a href="#l27.24"></a><span id="l27.24">         mJunkListener(aJunkListener),</span>
<a href="#l27.25"></a><span id="l27.25">         mTraitListener(nullptr),</span>
<a href="#l27.26"></a><span id="l27.26">         mDetailListener(nullptr),</span>
<a href="#l27.27"></a><span id="l27.27">         mMsgWindow(aMsgWindow)</span>
<a href="#l27.28"></a><span id="l27.28">     {</span>
<a href="#l27.29"></a><span id="l27.29">       mCurMessageToClassify = 0;</span>
<a href="#l27.30"></a><span id="l27.30">       mNumMessagesToClassify = aNumMessagesToClassify;</span>
<a href="#l27.31"></a><span id="l27.31" class="difflineminus">-      mMessageURIs = (char **) nsMemory::Alloc(sizeof(char *) * aNumMessagesToClassify);</span>
<a href="#l27.32"></a><span id="l27.32" class="difflineplus">+      mMessageURIs = (char **) moz_xmalloc(sizeof(char *) * aNumMessagesToClassify);</span>
<a href="#l27.33"></a><span id="l27.33">       for (uint32_t i = 0; i &lt; aNumMessagesToClassify; i++)</span>
<a href="#l27.34"></a><span id="l27.34">         mMessageURIs[i] = PL_strdup(aMessageURIs[i]);</span>
<a href="#l27.35"></a><span id="l27.35">       mProTraits.AppendElement(kJunkTrait);</span>
<a href="#l27.36"></a><span id="l27.36">       mAntiTraits.AppendElement(kGoodTrait);</span>
<a href="#l27.37"></a><span id="l27.37"> </span>
<a href="#l27.38"></a><span id="l27.38">     }</span>
<a href="#l27.39"></a><span id="l27.39"> </span>
<a href="#l27.40"></a><span id="l27.40">     virtual ~MessageClassifier()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/mailnews/extensions/smime/src/nsSMimeJSHelper.cpp</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/mailnews/extensions/smime/src/nsSMimeJSHelper.cpp</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -58,29 +58,29 @@ NS_IMETHODIMP nsSMimeJSHelper::GetRecipi</span>
<a href="#l28.4"></a><span id="l28.4">   nsCOMPtr&lt;nsIX509CertDB&gt; certdb = do_GetService(NS_X509CERTDB_CONTRACTID);</span>
<a href="#l28.5"></a><span id="l28.5"> </span>
<a href="#l28.6"></a><span id="l28.6">   *count = mailbox_count;</span>
<a href="#l28.7"></a><span id="l28.7">   *canEncrypt = false;</span>
<a href="#l28.8"></a><span id="l28.8">   rv = NS_OK;</span>
<a href="#l28.9"></a><span id="l28.9"> </span>
<a href="#l28.10"></a><span id="l28.10">   if (mailbox_count)</span>
<a href="#l28.11"></a><span id="l28.11">   {</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-    char16_t **outEA = static_cast&lt;char16_t **&gt;(nsMemory::Alloc(mailbox_count * sizeof(char16_t *)));</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineminus">-    int32_t *outCV = static_cast&lt;int32_t *&gt;(nsMemory::Alloc(mailbox_count * sizeof(int32_t)));</span>
<a href="#l28.14"></a><span id="l28.14" class="difflineminus">-    char16_t **outCII = static_cast&lt;char16_t **&gt;(nsMemory::Alloc(mailbox_count * sizeof(char16_t *)));</span>
<a href="#l28.15"></a><span id="l28.15" class="difflineminus">-    char16_t **outCEI = static_cast&lt;char16_t **&gt;(nsMemory::Alloc(mailbox_count * sizeof(char16_t *)));</span>
<a href="#l28.16"></a><span id="l28.16" class="difflineminus">-    nsIX509Cert **outCerts = static_cast&lt;nsIX509Cert **&gt;(nsMemory::Alloc(mailbox_count * sizeof(nsIX509Cert *)));</span>
<a href="#l28.17"></a><span id="l28.17" class="difflineplus">+    char16_t **outEA = static_cast&lt;char16_t **&gt;(moz_xmalloc(mailbox_count * sizeof(char16_t *)));</span>
<a href="#l28.18"></a><span id="l28.18" class="difflineplus">+    int32_t *outCV = static_cast&lt;int32_t *&gt;(moz_xmalloc(mailbox_count * sizeof(int32_t)));</span>
<a href="#l28.19"></a><span id="l28.19" class="difflineplus">+    char16_t **outCII = static_cast&lt;char16_t **&gt;(moz_xmalloc(mailbox_count * sizeof(char16_t *)));</span>
<a href="#l28.20"></a><span id="l28.20" class="difflineplus">+    char16_t **outCEI = static_cast&lt;char16_t **&gt;(moz_xmalloc(mailbox_count * sizeof(char16_t *)));</span>
<a href="#l28.21"></a><span id="l28.21" class="difflineplus">+    nsIX509Cert **outCerts = static_cast&lt;nsIX509Cert **&gt;(moz_xmalloc(mailbox_count * sizeof(nsIX509Cert *)));</span>
<a href="#l28.22"></a><span id="l28.22"> </span>
<a href="#l28.23"></a><span id="l28.23">     if (!outEA || !outCV || !outCII || !outCEI || !outCerts)</span>
<a href="#l28.24"></a><span id="l28.24">     {</span>
<a href="#l28.25"></a><span id="l28.25" class="difflineminus">-      nsMemory::Free(outEA);</span>
<a href="#l28.26"></a><span id="l28.26" class="difflineminus">-      nsMemory::Free(outCV);</span>
<a href="#l28.27"></a><span id="l28.27" class="difflineminus">-      nsMemory::Free(outCII);</span>
<a href="#l28.28"></a><span id="l28.28" class="difflineminus">-      nsMemory::Free(outCEI);</span>
<a href="#l28.29"></a><span id="l28.29" class="difflineminus">-      nsMemory::Free(outCerts);</span>
<a href="#l28.30"></a><span id="l28.30" class="difflineplus">+      free(outEA);</span>
<a href="#l28.31"></a><span id="l28.31" class="difflineplus">+      free(outCV);</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+      free(outCII);</span>
<a href="#l28.33"></a><span id="l28.33" class="difflineplus">+      free(outCEI);</span>
<a href="#l28.34"></a><span id="l28.34" class="difflineplus">+      free(outCerts);</span>
<a href="#l28.35"></a><span id="l28.35">       rv = NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l28.36"></a><span id="l28.36">     }</span>
<a href="#l28.37"></a><span id="l28.37">     else</span>
<a href="#l28.38"></a><span id="l28.38">     {</span>
<a href="#l28.39"></a><span id="l28.39">       char16_t **iEA = outEA;</span>
<a href="#l28.40"></a><span id="l28.40">       int32_t *iCV = outCV;</span>
<a href="#l28.41"></a><span id="l28.41">       char16_t **iCII = outCII;</span>
<a href="#l28.42"></a><span id="l28.42">       char16_t **iCEI = outCEI;</span>
<a href="#l28.43"></a><span id="l28.43" class="difflineat">@@ -151,17 +151,17 @@ NS_IMETHODIMP nsSMimeJSHelper::GetRecipi</span>
<a href="#l28.44"></a><span id="l28.44">         }</span>
<a href="#l28.45"></a><span id="l28.45">       }</span>
<a href="#l28.46"></a><span id="l28.46"> </span>
<a href="#l28.47"></a><span id="l28.47">       if (memory_failure) {</span>
<a href="#l28.48"></a><span id="l28.48">         NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(mailbox_count, outEA);</span>
<a href="#l28.49"></a><span id="l28.49">         NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(mailbox_count, outCII);</span>
<a href="#l28.50"></a><span id="l28.50">         NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(mailbox_count, outCEI);</span>
<a href="#l28.51"></a><span id="l28.51">         NS_FREE_XPCOM_ISUPPORTS_POINTER_ARRAY(mailbox_count, outCerts);</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineminus">-        nsMemory::Free(outCV);</span>
<a href="#l28.53"></a><span id="l28.53" class="difflineplus">+        free(outCV);</span>
<a href="#l28.54"></a><span id="l28.54">         rv = NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l28.55"></a><span id="l28.55">       }</span>
<a href="#l28.56"></a><span id="l28.56">       else {</span>
<a href="#l28.57"></a><span id="l28.57">         if (mailbox_count &gt; 0 &amp;&amp; !found_blocker)</span>
<a href="#l28.58"></a><span id="l28.58">         {</span>
<a href="#l28.59"></a><span id="l28.59">           *canEncrypt = true;</span>
<a href="#l28.60"></a><span id="l28.60">         }</span>
<a href="#l28.61"></a><span id="l28.61"> </span>
<a href="#l28.62"></a><span id="l28.62" class="difflineat">@@ -230,17 +230,17 @@ NS_IMETHODIMP nsSMimeJSHelper::GetNoCert</span>
<a href="#l28.63"></a><span id="l28.63">         ++missing_count;</span>
<a href="#l28.64"></a><span id="l28.64">     }</span>
<a href="#l28.65"></a><span id="l28.65">   }</span>
<a href="#l28.66"></a><span id="l28.66"> </span>
<a href="#l28.67"></a><span id="l28.67">   *count = missing_count;</span>
<a href="#l28.68"></a><span id="l28.68"> </span>
<a href="#l28.69"></a><span id="l28.69">   if (missing_count)</span>
<a href="#l28.70"></a><span id="l28.70">   {</span>
<a href="#l28.71"></a><span id="l28.71" class="difflineminus">-    char16_t **outEA = static_cast&lt;char16_t **&gt;(nsMemory::Alloc(missing_count * sizeof(char16_t *)));</span>
<a href="#l28.72"></a><span id="l28.72" class="difflineplus">+    char16_t **outEA = static_cast&lt;char16_t **&gt;(moz_xmalloc(missing_count * sizeof(char16_t *)));</span>
<a href="#l28.73"></a><span id="l28.73">     if (!outEA )</span>
<a href="#l28.74"></a><span id="l28.74">     {</span>
<a href="#l28.75"></a><span id="l28.75">       rv = NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l28.76"></a><span id="l28.76">     }</span>
<a href="#l28.77"></a><span id="l28.77">     else</span>
<a href="#l28.78"></a><span id="l28.78">     {</span>
<a href="#l28.79"></a><span id="l28.79">       char16_t **iEA = outEA;</span>
<a href="#l28.80"></a><span id="l28.80"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -1910,17 +1910,17 @@ nsImapMailFolder::MarkAllMessagesRead(ns</span>
<a href="#l29.4"></a><span id="l29.4">     {</span>
<a href="#l29.5"></a><span id="l29.5">       rv = StoreImapFlags(kImapMsgSeenFlag, true, thoseMarked,</span>
<a href="#l29.6"></a><span id="l29.6">                           numMarked, nullptr);</span>
<a href="#l29.7"></a><span id="l29.7">       mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l29.8"></a><span id="l29.8"> </span>
<a href="#l29.9"></a><span id="l29.9">       // Setup a undo-state</span>
<a href="#l29.10"></a><span id="l29.10">       if (aMsgWindow)</span>
<a href="#l29.11"></a><span id="l29.11">         rv = AddMarkAllReadUndoAction(aMsgWindow, thoseMarked, numMarked);</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-      nsMemory::Free(thoseMarked);</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+      free(thoseMarked);</span>
<a href="#l29.14"></a><span id="l29.14">     }</span>
<a href="#l29.15"></a><span id="l29.15">   }</span>
<a href="#l29.16"></a><span id="l29.16">   return rv;</span>
<a href="#l29.17"></a><span id="l29.17"> }</span>
<a href="#l29.18"></a><span id="l29.18"> </span>
<a href="#l29.19"></a><span id="l29.19"> NS_IMETHODIMP nsImapMailFolder::MarkThreadRead(nsIMsgThread *thread)</span>
<a href="#l29.20"></a><span id="l29.20"> {</span>
<a href="#l29.21"></a><span id="l29.21">   nsresult rv = GetDatabase();</span>
<a href="#l29.22"></a><span id="l29.22" class="difflineat">@@ -1928,17 +1928,17 @@ NS_IMETHODIMP nsImapMailFolder::MarkThre</span>
<a href="#l29.23"></a><span id="l29.23">   {</span>
<a href="#l29.24"></a><span id="l29.24">     nsMsgKey *keys;</span>
<a href="#l29.25"></a><span id="l29.25">     uint32_t numKeys;</span>
<a href="#l29.26"></a><span id="l29.26">     rv = mDatabase-&gt;MarkThreadRead(thread, nullptr, &amp;numKeys, &amp;keys);</span>
<a href="#l29.27"></a><span id="l29.27">     if (NS_SUCCEEDED(rv) &amp;&amp; numKeys)</span>
<a href="#l29.28"></a><span id="l29.28">     {</span>
<a href="#l29.29"></a><span id="l29.29">       rv = StoreImapFlags(kImapMsgSeenFlag, true, keys, numKeys, nullptr);</span>
<a href="#l29.30"></a><span id="l29.30">       mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineminus">-      nsMemory::Free(keys);</span>
<a href="#l29.32"></a><span id="l29.32" class="difflineplus">+      free(keys);</span>
<a href="#l29.33"></a><span id="l29.33">     }</span>
<a href="#l29.34"></a><span id="l29.34">   }</span>
<a href="#l29.35"></a><span id="l29.35">   return rv;</span>
<a href="#l29.36"></a><span id="l29.36"> }</span>
<a href="#l29.37"></a><span id="l29.37"> </span>
<a href="#l29.38"></a><span id="l29.38"> </span>
<a href="#l29.39"></a><span id="l29.39"> NS_IMETHODIMP nsImapMailFolder::ReadFromFolderCacheElem(nsIMsgFolderCacheElement *element)</span>
<a href="#l29.40"></a><span id="l29.40"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -3558,17 +3558,17 @@ nsImapProtocol::FetchMessage(const nsCSt</span>
<a href="#l30.4"></a><span id="l30.4">         protocolStringSize,                                      // max size</span>
<a href="#l30.5"></a><span id="l30.5">         cCommandStr,                                   // format string</span>
<a href="#l30.6"></a><span id="l30.6">         commandTag,                          // command tag</span>
<a href="#l30.7"></a><span id="l30.7">         messageIds.get());</span>
<a href="#l30.8"></a><span id="l30.8">     }</span>
<a href="#l30.9"></a><span id="l30.9"> </span>
<a href="#l30.10"></a><span id="l30.10">     nsresult rv = SendData(protocolString);</span>
<a href="#l30.11"></a><span id="l30.11"> </span>
<a href="#l30.12"></a><span id="l30.12" class="difflineminus">-    nsMemory::Free(cCommandStr);</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineplus">+    free(cCommandStr);</span>
<a href="#l30.14"></a><span id="l30.14">     if (NS_SUCCEEDED(rv))</span>
<a href="#l30.15"></a><span id="l30.15">       ParseIMAPandCheckForNewMail(protocolString);</span>
<a href="#l30.16"></a><span id="l30.16">     PR_Free(protocolString);</span>
<a href="#l30.17"></a><span id="l30.17">     GetServerStateParser().SetFetchingFlags(false);</span>
<a href="#l30.18"></a><span id="l30.18">     // Always clear this flag after every fetch.</span>
<a href="#l30.19"></a><span id="l30.19">     m_fetchingWholeMessage = false;</span>
<a href="#l30.20"></a><span id="l30.20">     if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; CheckNeeded())</span>
<a href="#l30.21"></a><span id="l30.21">       Check();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/mailnews/imap/src/nsImapUrl.cpp</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapUrl.cpp</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -856,17 +856,17 @@ NS_IMETHODIMP nsImapUrl::AllocateServerP</span>
<a href="#l31.4"></a><span id="l31.4">   const char *src = sourcePath;</span>
<a href="#l31.5"></a><span id="l31.5">   int32_t i;</span>
<a href="#l31.6"></a><span id="l31.6">   for ( i = 0; i &lt; len; i++)</span>
<a href="#l31.7"></a><span id="l31.7">   {</span>
<a href="#l31.8"></a><span id="l31.8">     if (*src == '^')</span>
<a href="#l31.9"></a><span id="l31.9">       extra += 1; /* ^ -&gt; ^^ */</span>
<a href="#l31.10"></a><span id="l31.10">     src++;</span>
<a href="#l31.11"></a><span id="l31.11">   }</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineminus">-  char* result = (char *)nsMemory::Alloc(len + extra + 1);</span>
<a href="#l31.13"></a><span id="l31.13" class="difflineplus">+  char* result = (char *)moz_xmalloc(len + extra + 1);</span>
<a href="#l31.14"></a><span id="l31.14">   if (!result)</span>
<a href="#l31.15"></a><span id="l31.15">     return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l31.16"></a><span id="l31.16"> </span>
<a href="#l31.17"></a><span id="l31.17">   register unsigned char* dst = (unsigned char *) result;</span>
<a href="#l31.18"></a><span id="l31.18">   src = sourcePath;</span>
<a href="#l31.19"></a><span id="l31.19">   for (i = 0; i &lt; len; i++)</span>
<a href="#l31.20"></a><span id="l31.20">   {</span>
<a href="#l31.21"></a><span id="l31.21">     unsigned char c = *src++;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/mailnews/import/outlook/src/MapiApi.cpp</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/mailnews/import/outlook/src/MapiApi.cpp</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -982,26 +982,26 @@ BOOL CMapiApi::IterateStores(CMapiFolder</span>
<a href="#l32.4"></a><span id="l32.4">         // does not exist, then szContents will be zero.  We'll</span>
<a href="#l32.5"></a><span id="l32.5">         // assume that any store that doesn't have anything in</span>
<a href="#l32.6"></a><span id="l32.6">         // it's hierarchy tree is not a store we want to import -</span>
<a href="#l32.7"></a><span id="l32.7">         // there would be nothing to import from anyway!</span>
<a href="#l32.8"></a><span id="l32.8">         // Currently, this does exclude IMAP server accounts</span>
<a href="#l32.9"></a><span id="l32.9">         // which is the desired behaviour.</span>
<a href="#l32.10"></a><span id="l32.10"> </span>
<a href="#l32.11"></a><span id="l32.11">         int         strLen = strlen(lpStr);</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-        char16_t * pwszStr = (char16_t *) nsMemory::Alloc((strLen + 1) * sizeof(WCHAR));</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineplus">+        char16_t * pwszStr = (char16_t *) moz_xmalloc((strLen + 1) * sizeof(WCHAR));</span>
<a href="#l32.14"></a><span id="l32.14">         if (!pwszStr) {</span>
<a href="#l32.15"></a><span id="l32.15">           // out of memory</span>
<a href="#l32.16"></a><span id="l32.16">           FreeProws(lpRow);</span>
<a href="#l32.17"></a><span id="l32.17">           lpTable-&gt;Release();</span>
<a href="#l32.18"></a><span id="l32.18">           return FALSE;</span>
<a href="#l32.19"></a><span id="l32.19">         }</span>
<a href="#l32.20"></a><span id="l32.20">         ::MultiByteToWideChar(CP_ACP, 0, lpStr, strlen(lpStr) + 1, pwszStr, (strLen + 1) * sizeof(WCHAR));</span>
<a href="#l32.21"></a><span id="l32.21">         CMapiFolder *pFolder = new CMapiFolder(pwszStr, cbEID, lpEID, 0, MAPI_STORE);</span>
<a href="#l32.22"></a><span id="l32.22" class="difflineminus">-        nsMemory::Free(pwszStr);</span>
<a href="#l32.23"></a><span id="l32.23" class="difflineplus">+        free(pwszStr);</span>
<a href="#l32.24"></a><span id="l32.24"> </span>
<a href="#l32.25"></a><span id="l32.25">         long szContents = 1;</span>
<a href="#l32.26"></a><span id="l32.26">         GetStoreInfo(pFolder, &amp;szContents);</span>
<a href="#l32.27"></a><span id="l32.27"> </span>
<a href="#l32.28"></a><span id="l32.28">         MAPI_TRACE1(&quot;    DisplayName: %s\n&quot;, lpStr);</span>
<a href="#l32.29"></a><span id="l32.29">         if (szContents)</span>
<a href="#l32.30"></a><span id="l32.30">           stores.AddItem(pFolder);</span>
<a href="#l32.31"></a><span id="l32.31">         else {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/mailnews/local/src/nsLocalMailFolder.cpp</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/mailnews/local/src/nsLocalMailFolder.cpp</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -1328,17 +1328,17 @@ nsMsgLocalMailFolder::MarkAllMessagesRea</span>
<a href="#l33.4"></a><span id="l33.4"> </span>
<a href="#l33.5"></a><span id="l33.5">     mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l33.6"></a><span id="l33.6"> </span>
<a href="#l33.7"></a><span id="l33.7">     // Setup a undo-state</span>
<a href="#l33.8"></a><span id="l33.8">     if (aMsgWindow)</span>
<a href="#l33.9"></a><span id="l33.9">       rv = AddMarkAllReadUndoAction(aMsgWindow, thoseMarked, numMarked);</span>
<a href="#l33.10"></a><span id="l33.10">   } while (false);</span>
<a href="#l33.11"></a><span id="l33.11"> </span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">-  nsMemory::Free(thoseMarked);</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineplus">+  free(thoseMarked);</span>
<a href="#l33.14"></a><span id="l33.14">   return rv;</span>
<a href="#l33.15"></a><span id="l33.15"> }</span>
<a href="#l33.16"></a><span id="l33.16"> </span>
<a href="#l33.17"></a><span id="l33.17"> NS_IMETHODIMP nsMsgLocalMailFolder::MarkThreadRead(nsIMsgThread *thread)</span>
<a href="#l33.18"></a><span id="l33.18"> {</span>
<a href="#l33.19"></a><span id="l33.19">   nsresult rv = GetDatabase();</span>
<a href="#l33.20"></a><span id="l33.20">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l33.21"></a><span id="l33.21"> </span>
<a href="#l33.22"></a><span id="l33.22" class="difflineat">@@ -1361,17 +1361,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::Mark</span>
<a href="#l33.23"></a><span id="l33.23"> </span>
<a href="#l33.24"></a><span id="l33.24">     rv = msgStore-&gt;ChangeFlags(messages, nsMsgMessageFlags::Read, true);</span>
<a href="#l33.25"></a><span id="l33.25">     if (NS_FAILED(rv))</span>
<a href="#l33.26"></a><span id="l33.26">       break;</span>
<a href="#l33.27"></a><span id="l33.27"> </span>
<a href="#l33.28"></a><span id="l33.28">     mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l33.29"></a><span id="l33.29">   } while (false);</span>
<a href="#l33.30"></a><span id="l33.30"> </span>
<a href="#l33.31"></a><span id="l33.31" class="difflineminus">-  nsMemory::Free(thoseMarked);</span>
<a href="#l33.32"></a><span id="l33.32" class="difflineplus">+  free(thoseMarked);</span>
<a href="#l33.33"></a><span id="l33.33">   return rv;</span>
<a href="#l33.34"></a><span id="l33.34"> }</span>
<a href="#l33.35"></a><span id="l33.35"> </span>
<a href="#l33.36"></a><span id="l33.36"> nsresult</span>
<a href="#l33.37"></a><span id="l33.37"> nsMsgLocalMailFolder::InitCopyState(nsISupports* aSupport,</span>
<a href="#l33.38"></a><span id="l33.38">                                     nsIArray* messages,</span>
<a href="#l33.39"></a><span id="l33.39">                                     bool isMove,</span>
<a href="#l33.40"></a><span id="l33.40">                                     nsIMsgCopyServiceListener* listener,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -297,17 +297,17 @@ nsMimeHtmlDisplayEmitter::EndHeader(cons</span>
<a href="#l34.4"></a><span id="l34.4">       {</span>
<a href="#l34.5"></a><span id="l34.5">         int32_t bufLen = strlen(subject) + 16;</span>
<a href="#l34.6"></a><span id="l34.6">         char *buf = new char[bufLen];</span>
<a href="#l34.7"></a><span id="l34.7">         if (!buf)</span>
<a href="#l34.8"></a><span id="l34.8">           return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l34.9"></a><span id="l34.9">         PR_snprintf(buf, bufLen, &quot;&lt;title&gt;%s&lt;/title&gt;&quot;, subject);</span>
<a href="#l34.10"></a><span id="l34.10">         UtilityWriteCRLF(buf);</span>
<a href="#l34.11"></a><span id="l34.11">         delete [] buf;</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-        nsMemory::Free(subject);</span>
<a href="#l34.13"></a><span id="l34.13" class="difflineplus">+        free(subject);</span>
<a href="#l34.14"></a><span id="l34.14">       }</span>
<a href="#l34.15"></a><span id="l34.15">     }</span>
<a href="#l34.16"></a><span id="l34.16"> </span>
<a href="#l34.17"></a><span id="l34.17">     // Stylesheet info!</span>
<a href="#l34.18"></a><span id="l34.18">     UtilityWriteCRLF(&quot;&lt;link rel=\&quot;important stylesheet\&quot; href=\&quot;chrome://messagebody/skin/messageBody.css\&quot;&gt;&quot;);</span>
<a href="#l34.19"></a><span id="l34.19"> </span>
<a href="#l34.20"></a><span id="l34.20">     UtilityWriteCRLF(&quot;&lt;/head&gt;&quot;);</span>
<a href="#l34.21"></a><span id="l34.21">     UtilityWriteCRLF(&quot;&lt;body&gt;&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/mailnews/mime/src/mimehdrs.cpp</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/mailnews/mime/src/mimehdrs.cpp</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -703,17 +703,17 @@ MimeHeaders_get_name(MimeHeaders *hdrs, </span>
<a href="#l35.4"></a><span id="l35.4">     PR_Free(s);</span>
<a href="#l35.5"></a><span id="l35.5">   }</span>
<a href="#l35.6"></a><span id="l35.6"> </span>
<a href="#l35.7"></a><span id="l35.7">   if (! name)</span>
<a href="#l35.8"></a><span id="l35.8">   {</span>
<a href="#l35.9"></a><span id="l35.9">     s = MimeHeaders_get(hdrs, HEADER_CONTENT_TYPE, false, false);</span>
<a href="#l35.10"></a><span id="l35.10">     if (s)</span>
<a href="#l35.11"></a><span id="l35.11">     {</span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-      nsMemory::Free(charset);</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+      free(charset);</span>
<a href="#l35.14"></a><span id="l35.14"> </span>
<a href="#l35.15"></a><span id="l35.15">       name = MimeHeaders_get_parameter(s, HEADER_PARM_NAME, &amp;charset, NULL);</span>
<a href="#l35.16"></a><span id="l35.16">       PR_Free(s);</span>
<a href="#l35.17"></a><span id="l35.17">     }</span>
<a href="#l35.18"></a><span id="l35.18">   }</span>
<a href="#l35.19"></a><span id="l35.19"> </span>
<a href="#l35.20"></a><span id="l35.20">   if (! name)</span>
<a href="#l35.21"></a><span id="l35.21">     name = MimeHeaders_get (hdrs, HEADER_CONTENT_NAME, false, false);</span>
<a href="#l35.22"></a><span id="l35.22" class="difflineat">@@ -730,17 +730,17 @@ MimeHeaders_get_name(MimeHeaders *hdrs, </span>
<a href="#l35.23"></a><span id="l35.23">     */</span>
<a href="#l35.24"></a><span id="l35.24">     MIME_StripContinuations(name);</span>
<a href="#l35.25"></a><span id="l35.25"> </span>
<a href="#l35.26"></a><span id="l35.26">     /* Argh. What we should do if we want to be robust is to decode qtext</span>
<a href="#l35.27"></a><span id="l35.27">        in all appropriate headers. Unfortunately, that would be too scary</span>
<a href="#l35.28"></a><span id="l35.28">        at this juncture. So just decode qtext/mime2 here. */</span>
<a href="#l35.29"></a><span id="l35.29">     cvt = mime_decode_filename(name, charset, opt);</span>
<a href="#l35.30"></a><span id="l35.30"> </span>
<a href="#l35.31"></a><span id="l35.31" class="difflineminus">-    nsMemory::Free(charset);</span>
<a href="#l35.32"></a><span id="l35.32" class="difflineplus">+    free(charset);</span>
<a href="#l35.33"></a><span id="l35.33"> </span>
<a href="#l35.34"></a><span id="l35.34">     if (cvt &amp;&amp; cvt != name)</span>
<a href="#l35.35"></a><span id="l35.35">     {</span>
<a href="#l35.36"></a><span id="l35.36">       PR_Free(name);</span>
<a href="#l35.37"></a><span id="l35.37">       name = cvt;</span>
<a href="#l35.38"></a><span id="l35.38">     }</span>
<a href="#l35.39"></a><span id="l35.39">   }</span>
<a href="#l35.40"></a><span id="l35.40"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/mailnews/mime/src/mimemoz2.cpp</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/mailnews/mime/src/mimemoz2.cpp</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -120,17 +120,17 @@ ProcessBodyAsAttachment(MimeObject *obj,</span>
<a href="#l36.4"></a><span id="l36.4">   tmp-&gt;m_realType = child-&gt;content_type;</span>
<a href="#l36.5"></a><span id="l36.5">   tmp-&gt;m_realEncoding = child-&gt;encoding;</span>
<a href="#l36.6"></a><span id="l36.6">   disp = MimeHeaders_get(child-&gt;headers, HEADER_CONTENT_DISPOSITION, false, false);</span>
<a href="#l36.7"></a><span id="l36.7">   tmp-&gt;m_realName.Adopt(MimeHeaders_get_parameter(disp, &quot;name&quot;, &amp;charset, NULL));</span>
<a href="#l36.8"></a><span id="l36.8">   if (!tmp-&gt;m_realName.IsEmpty())</span>
<a href="#l36.9"></a><span id="l36.9">   {</span>
<a href="#l36.10"></a><span id="l36.10">     char *fname = NULL;</span>
<a href="#l36.11"></a><span id="l36.11">     fname = mime_decode_filename(tmp-&gt;m_realName.get(), charset, obj-&gt;options);</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineminus">-    nsMemory::Free(charset);</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+    free(charset);</span>
<a href="#l36.14"></a><span id="l36.14">     if (fname)</span>
<a href="#l36.15"></a><span id="l36.15">       tmp-&gt;m_realName.Adopt(fname);</span>
<a href="#l36.16"></a><span id="l36.16">   }</span>
<a href="#l36.17"></a><span id="l36.17">   else</span>
<a href="#l36.18"></a><span id="l36.18">   {</span>
<a href="#l36.19"></a><span id="l36.19">     tmp-&gt;m_realName.Adopt(MimeHeaders_get_name(child-&gt;headers, obj-&gt;options));</span>
<a href="#l36.20"></a><span id="l36.20"> </span>
<a href="#l36.21"></a><span id="l36.21">     if (tmp-&gt;m_realName.IsEmpty() &amp;&amp;</span>
<a href="#l36.22"></a><span id="l36.22" class="difflineat">@@ -340,32 +340,32 @@ GenerateAttachmentData(MimeObject *objec</span>
<a href="#l36.23"></a><span id="l36.23">   char *disp = MimeHeaders_get(object-&gt;headers, HEADER_CONTENT_DISPOSITION, false, false);</span>
<a href="#l36.24"></a><span id="l36.24">   if (disp)</span>
<a href="#l36.25"></a><span id="l36.25">   {</span>
<a href="#l36.26"></a><span id="l36.26">     tmp-&gt;m_realName.Adopt(MimeHeaders_get_parameter(disp, &quot;filename&quot;, &amp;charset, nullptr));</span>
<a href="#l36.27"></a><span id="l36.27">     if (isAnAppleDoublePart)</span>
<a href="#l36.28"></a><span id="l36.28">       for (i = 0; i &lt; 2 &amp;&amp; tmp-&gt;m_realName.IsEmpty(); i ++)</span>
<a href="#l36.29"></a><span id="l36.29">       {</span>
<a href="#l36.30"></a><span id="l36.30">         PR_FREEIF(disp);</span>
<a href="#l36.31"></a><span id="l36.31" class="difflineminus">-        nsMemory::Free(charset);</span>
<a href="#l36.32"></a><span id="l36.32" class="difflineplus">+        free(charset);</span>
<a href="#l36.33"></a><span id="l36.33">         disp = MimeHeaders_get(((MimeContainer *)object)-&gt;children[i]-&gt;headers, HEADER_CONTENT_DISPOSITION, false, false);</span>
<a href="#l36.34"></a><span id="l36.34">         tmp-&gt;m_realName.Adopt(MimeHeaders_get_parameter(disp, &quot;filename&quot;, &amp;charset, nullptr));</span>
<a href="#l36.35"></a><span id="l36.35">       }</span>
<a href="#l36.36"></a><span id="l36.36"> </span>
<a href="#l36.37"></a><span id="l36.37">     if (!tmp-&gt;m_realName.IsEmpty())</span>
<a href="#l36.38"></a><span id="l36.38">     {</span>
<a href="#l36.39"></a><span id="l36.39">       // check encoded type</span>
<a href="#l36.40"></a><span id="l36.40">       //</span>
<a href="#l36.41"></a><span id="l36.41">       // The parameter of Content-Disposition must use RFC 2231.</span>
<a href="#l36.42"></a><span id="l36.42">       // But old Netscape 4.x and Outlook Express etc. use RFC2047.</span>
<a href="#l36.43"></a><span id="l36.43">       // So we should parse both types.</span>
<a href="#l36.44"></a><span id="l36.44"> </span>
<a href="#l36.45"></a><span id="l36.45">       char *fname = nullptr;</span>
<a href="#l36.46"></a><span id="l36.46">       fname = mime_decode_filename(tmp-&gt;m_realName.get(), charset, options);</span>
<a href="#l36.47"></a><span id="l36.47" class="difflineminus">-      nsMemory::Free(charset);</span>
<a href="#l36.48"></a><span id="l36.48" class="difflineplus">+      free(charset);</span>
<a href="#l36.49"></a><span id="l36.49"> </span>
<a href="#l36.50"></a><span id="l36.50">       if (fname)</span>
<a href="#l36.51"></a><span id="l36.51">         tmp-&gt;m_realName.Adopt(fname);</span>
<a href="#l36.52"></a><span id="l36.52">     }</span>
<a href="#l36.53"></a><span id="l36.53"> </span>
<a href="#l36.54"></a><span id="l36.54">     PR_FREEIF(disp);</span>
<a href="#l36.55"></a><span id="l36.55">   }</span>
<a href="#l36.56"></a><span id="l36.56"> </span>
<a href="#l36.57"></a><span id="l36.57" class="difflineat">@@ -378,17 +378,17 @@ GenerateAttachmentData(MimeObject *objec</span>
<a href="#l36.58"></a><span id="l36.58">     if (tmp-&gt;m_realName.IsEmpty())</span>
<a href="#l36.59"></a><span id="l36.59">     {</span>
<a href="#l36.60"></a><span id="l36.60">       tmp-&gt;m_realName.Adopt(MimeHeaders_get_parameter(disp, &quot;name&quot;, &amp;charset, nullptr));</span>
<a href="#l36.61"></a><span id="l36.61">       if (isAnAppleDoublePart)</span>
<a href="#l36.62"></a><span id="l36.62">         // the data fork is the 2nd part, and we should ALWAYS look there first for the file name</span>
<a href="#l36.63"></a><span id="l36.63">         for (i = 1; i &gt;= 0 &amp;&amp; tmp-&gt;m_realName.IsEmpty(); i --)</span>
<a href="#l36.64"></a><span id="l36.64">         {</span>
<a href="#l36.65"></a><span id="l36.65">           PR_FREEIF(disp);</span>
<a href="#l36.66"></a><span id="l36.66" class="difflineminus">-          nsMemory::Free(charset);</span>
<a href="#l36.67"></a><span id="l36.67" class="difflineplus">+          free(charset);</span>
<a href="#l36.68"></a><span id="l36.68">           disp = MimeHeaders_get(((MimeContainer *)object)-&gt;children[i]-&gt;headers, HEADER_CONTENT_TYPE, false, false);</span>
<a href="#l36.69"></a><span id="l36.69">           tmp-&gt;m_realName.Adopt(MimeHeaders_get_parameter(disp, &quot;name&quot;, &amp;charset, nullptr));</span>
<a href="#l36.70"></a><span id="l36.70">           tmp-&gt;m_realType.Adopt(</span>
<a href="#l36.71"></a><span id="l36.71">             MimeHeaders_get(((MimeContainer *)object)-&gt;children[i]-&gt;headers,</span>
<a href="#l36.72"></a><span id="l36.72">                             HEADER_CONTENT_TYPE, true, false));</span>
<a href="#l36.73"></a><span id="l36.73">         }</span>
<a href="#l36.74"></a><span id="l36.74"> </span>
<a href="#l36.75"></a><span id="l36.75">       if (!tmp-&gt;m_realName.IsEmpty())</span>
<a href="#l36.76"></a><span id="l36.76" class="difflineat">@@ -396,17 +396,17 @@ GenerateAttachmentData(MimeObject *objec</span>
<a href="#l36.77"></a><span id="l36.77">         // check encoded type</span>
<a href="#l36.78"></a><span id="l36.78">         //</span>
<a href="#l36.79"></a><span id="l36.79">         // The parameter of Content-Disposition must use RFC 2231.</span>
<a href="#l36.80"></a><span id="l36.80">         // But old Netscape 4.x and Outlook Express etc. use RFC2047.</span>
<a href="#l36.81"></a><span id="l36.81">         // So we should parse both types.</span>
<a href="#l36.82"></a><span id="l36.82"> </span>
<a href="#l36.83"></a><span id="l36.83">         char *fname = nullptr;</span>
<a href="#l36.84"></a><span id="l36.84">         fname = mime_decode_filename(tmp-&gt;m_realName.get(), charset, options);</span>
<a href="#l36.85"></a><span id="l36.85" class="difflineminus">-        nsMemory::Free(charset);</span>
<a href="#l36.86"></a><span id="l36.86" class="difflineplus">+        free(charset);</span>
<a href="#l36.87"></a><span id="l36.87"> </span>
<a href="#l36.88"></a><span id="l36.88">         if (fname)</span>
<a href="#l36.89"></a><span id="l36.89">           tmp-&gt;m_realName.Adopt(fname);</span>
<a href="#l36.90"></a><span id="l36.90">       }</span>
<a href="#l36.91"></a><span id="l36.91">     }</span>
<a href="#l36.92"></a><span id="l36.92">     PR_FREEIF(disp);</span>
<a href="#l36.93"></a><span id="l36.93">   }</span>
<a href="#l36.94"></a><span id="l36.94"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/mailnews/mime/src/modlmime.h</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/mailnews/mime/src/modlmime.h</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -87,17 +87,17 @@ extern char *MimeHeaders_get(MimeHeaders</span>
<a href="#l37.4"></a><span id="l37.4"> </span>
<a href="#l37.5"></a><span id="l37.5">    Returns NULL if there is no match, or if there is an allocation failure.</span>
<a href="#l37.6"></a><span id="l37.6"> </span>
<a href="#l37.7"></a><span id="l37.7">    RFC2231 - MIME Parameter Value and Encoded Word Extensions: Character Sets,</span>
<a href="#l37.8"></a><span id="l37.8">    Languages, and Continuations</span>
<a href="#l37.9"></a><span id="l37.9"> </span>
<a href="#l37.10"></a><span id="l37.10">    RFC2231 has added the character sets, languages, and continuations mechanism.</span>
<a href="#l37.11"></a><span id="l37.11">    charset, and language information may also be returned to the caller.</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineminus">-   Note that charset and language should be nsMemory::Free()'d while</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+   Note that charset and language should be free()'d while</span>
<a href="#l37.14"></a><span id="l37.14">    the return value (parameter) has to be PR_FREE'd.</span>
<a href="#l37.15"></a><span id="l37.15"> </span>
<a href="#l37.16"></a><span id="l37.16">    For example,</span>
<a href="#l37.17"></a><span id="l37.17">    MimeHeaders_get_parameter(&quot;text/plain; name*=us-ascii'en-us'This%20is%20%2A%2A%2Afun%2A%2A%2A&quot;, &quot;name&quot;)</span>
<a href="#l37.18"></a><span id="l37.18">    MimeHeaders_get_parameter(&quot;text/plain; name*0*=us-ascii'en-us'This%20is%20; CRLFLWSPname*1*=%2A%2A%2Afun%2A%2A%2A&quot;, &quot;name&quot;)</span>
<a href="#l37.19"></a><span id="l37.19">    would return &quot;This is ***fun***&quot; and *charset = &quot;us-ascii&quot;, *language = &quot;en-us&quot;</span>
<a href="#l37.20"></a><span id="l37.20">  */</span>
<a href="#l37.21"></a><span id="l37.21"> extern char *MimeHeaders_get_parameter (const char *header_value,</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

