<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 29735:4f509afebd6f6b0ab9f8994773c44d7b5624691d</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 4f509afebd6f6b0ab9f8994773c44d7b5624691d" />
<meta property="og:url" content="/comm-central/rev/4f509afebd6f6b0ab9f8994773c44d7b5624691d" />
<meta property="og:description" content="Bug 1641612 - Update RNP to snapshot from 2020-05-30. r=rjl,mkmelin" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 4f509afebd6f6b0ab9f8994773c44d7b5624691d 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/4f509afebd6f6b0ab9f8994773c44d7b5624691d">shortlog</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/4f509afebd6f6b0ab9f8994773c44d7b5624691d">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d">files</a> |
changeset |
<a href="/comm-central/raw-rev/4f509afebd6f6b0ab9f8994773c44d7b5624691d">raw</a>  | <a href="/comm-central/archive/4f509afebd6f6b0ab9f8994773c44d7b5624691d.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1641612">Bug 1641612</a> - Update RNP to snapshot from 2020-05-30. r=rjl,mkmelin
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#75;&#97;&#105;&#32;&#69;&#110;&#103;&#101;&#114;&#116;&#32;&#60;&#107;&#97;&#105;&#101;&#64;&#107;&#117;&#105;&#120;&#46;&#100;&#101;&#62;</td></tr>
<tr><td></td><td class="date age">Mon, 25 May 2020 18:32:50 +0200</td></tr>

<tr>
 <td>changeset 29735</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/4f509afebd6f6b0ab9f8994773c44d7b5624691d">4f509afebd6f6b0ab9f8994773c44d7b5624691d</a></td>
</tr>



<tr>
<td>parent 29734</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/a1b05e170dd6c640ddf149e111ce17213860d54b">a1b05e170dd6c640ddf149e111ce17213860d54b</a>
</td>
</tr>

<tr>
<td>child 29736</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/5cefc4c791654b07bd821daf75496ca05a2ff96d">5cefc4c791654b07bd821daf75496ca05a2ff96d</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=4f509afebd6f6b0ab9f8994773c44d7b5624691d">17506</a></td></tr>
<tr><td>push user</td><td>kaie@kuix.de</td></tr>
<tr><td>push date</td><td class="date age">Mon, 01 Jun 2020 16:30:04 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@4f509afebd6f [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=4f509afebd6f6b0ab9f8994773c44d7b5624691d">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=4f509afebd6f6b0ab9f8994773c44d7b5624691d&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4f509afebd6f6b0ab9f8994773c44d7b5624691d&newProject=comm-central&newRevision=4f509afebd6f6b0ab9f8994773c44d7b5624691d&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4f509afebd6f6b0ab9f8994773c44d7b5624691d&newProject=comm-central&newRevision=4f509afebd6f6b0ab9f8994773c44d7b5624691d&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4f509afebd6f6b0ab9f8994773c44d7b5624691d&newProject=comm-central&newRevision=4f509afebd6f6b0ab9f8994773c44d7b5624691d&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28rjl%29&revcount=50">rjl</a>, <a href="/comm-central/log?rev=reviewer%28mkmelin%29&revcount=50">mkmelin</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1641612">1641612</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1641612">Bug 1641612</a> - Update RNP to snapshot from 2020-05-30. r=rjl,mkmelin

Differential Revision: <a href="https://phabricator.services.mozilla.com/D77300">https://phabricator.services.mozilla.com/D77300</a></div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/README.rnp">third_party/README.rnp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/README.rnp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/README.rnp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/README.rnp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/README.rnp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/README.rnp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/README.adoc">third_party/rnp/README.adoc</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/README.adoc">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/README.adoc">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/README.adoc">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/README.adoc">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/README.adoc">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/rekey/rnp_key_store.h">third_party/rnp/include/rekey/rnp_key_store.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/rekey/rnp_key_store.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/rekey/rnp_key_store.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/rekey/rnp_key_store.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/rekey/rnp_key_store.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/rekey/rnp_key_store.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/repgp/repgp_def.h">third_party/rnp/include/repgp/repgp_def.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/repgp/repgp_def.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/repgp/repgp_def.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/repgp/repgp_def.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/repgp/repgp_def.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/include/repgp/repgp_def.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/fuzzing/fuzz_keys.c">third_party/rnp/src/fuzzing/fuzz_keys.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/fuzzing/fuzz_keys.c">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/fuzzing/fuzz_keys.c">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/fuzzing/fuzz_keys.c">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/fuzzing/fuzz_keys.c">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/fuzzing/fuzz_keys.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/CMakeLists.txt">third_party/rnp/src/lib/CMakeLists.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/CMakeLists.txt">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/CMakeLists.txt">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/CMakeLists.txt">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/CMakeLists.txt">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/CMakeLists.txt">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/config.h.in">third_party/rnp/src/lib/config.h.in</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/config.h.in">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/config.h.in">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/config.h.in">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/config.h.in">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/config.h.in">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto.cpp">third_party/rnp/src/lib/crypto.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/ec.cpp">third_party/rnp/src/lib/crypto/ec.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/ec.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/ec.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/ec.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/ec.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/ec.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/signatures.cpp">third_party/rnp/src/lib/crypto/signatures.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/signatures.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/signatures.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/signatures.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/signatures.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/crypto/signatures.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/ffi-priv-types.h">third_party/rnp/src/lib/ffi-priv-types.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/ffi-priv-types.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/ffi-priv-types.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/ffi-priv-types.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/ffi-priv-types.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/ffi-priv-types.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/generate-key.cpp">third_party/rnp/src/lib/generate-key.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/generate-key.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/generate-key.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/generate-key.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/generate-key.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/generate-key.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.cpp">third_party/rnp/src/lib/key-provider.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.h">third_party/rnp/src/lib/key-provider.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/key-provider.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/misc.cpp">third_party/rnp/src/lib/misc.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/misc.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/misc.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/misc.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/misc.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/misc.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.cpp">third_party/rnp/src/lib/pgp-key.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.h">third_party/rnp/src/lib/pgp-key.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/pgp-key.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/rnp.cpp">third_party/rnp/src/lib/rnp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/rnp.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/rnp.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/rnp.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/rnp.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/rnp.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/types.h">third_party/rnp/src/lib/types.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/types.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/types.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/types.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/types.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/types.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/utils.h">third_party/rnp/src/lib/utils.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/utils.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/utils.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/utils.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/utils.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/utils.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/version.h">third_party/rnp/src/lib/version.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/version.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/version.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/version.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/version.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/lib/version.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_g10.cpp">third_party/rnp/src/librekey/key_store_g10.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_g10.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_g10.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_g10.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_g10.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_g10.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_kbx.cpp">third_party/rnp/src/librekey/key_store_kbx.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_kbx.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_kbx.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_kbx.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_kbx.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_kbx.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.cpp">third_party/rnp/src/librekey/key_store_pgp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.h">third_party/rnp/src/librekey/key_store_pgp.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/key_store_pgp.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/rnp_key_store.cpp">third_party/rnp/src/librekey/rnp_key_store.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/rnp_key_store.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/rnp_key_store.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/rnp_key_store.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/rnp_key_store.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librekey/rnp_key_store.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-common.cpp">third_party/rnp/src/librepgp/stream-common.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-common.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-common.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-common.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-common.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-common.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-dump.cpp">third_party/rnp/src/librepgp/stream-dump.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-dump.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-dump.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-dump.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-dump.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-dump.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-key.cpp">third_party/rnp/src/librepgp/stream-key.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-key.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-key.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-key.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-key.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-key.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-packet.cpp">third_party/rnp/src/librepgp/stream-packet.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-packet.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-packet.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-packet.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-packet.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-packet.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-parse.cpp">third_party/rnp/src/librepgp/stream-parse.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-parse.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-parse.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-parse.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-parse.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-parse.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.cpp">third_party/rnp/src/librepgp/stream-sig.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.h">third_party/rnp/src/librepgp/stream-sig.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/librepgp/stream-sig.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/fficli.cpp">third_party/rnp/src/rnp/fficli.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/fficli.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/fficli.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/fficli.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/fficli.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/fficli.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/rnpcfg.cpp">third_party/rnp/src/rnp/rnpcfg.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/rnpcfg.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/rnpcfg.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/rnpcfg.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/rnpcfg.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/rnp/rnpcfg.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/CMakeLists.txt">third_party/rnp/src/tests/CMakeLists.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/CMakeLists.txt">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/CMakeLists.txt">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/CMakeLists.txt">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/CMakeLists.txt">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/CMakeLists.txt">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/cli_tests.py">third_party/rnp/src/tests/cli_tests.py</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/cli_tests.py">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/cli_tests.py">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/cli_tests.py">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/cli_tests.py">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/cli_tests.py">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-rev-no-reason.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/alice-rev-no-reason.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-rev-no-reason.pgp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-rev-no-reason.pgp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-rev-no-reason.pgp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-rev-no-reason.pgp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-rev-no-reason.pgp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-sub-rev-no-reason.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/alice-sub-rev-no-reason.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-sub-rev-no-reason.pgp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-sub-rev-no-reason.pgp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-sub-rev-no-reason.pgp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-sub-rev-no-reason.pgp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/alice-sub-rev-no-reason.pgp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.pgp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.pgp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.pgp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.pgp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.pgp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.txt">third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.txt">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.txt">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.txt">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.txt">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.txt">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid-raw.txt">third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid-raw.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid-raw.txt">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid-raw.txt">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid-raw.txt">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid-raw.txt">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid-raw.txt">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.json">third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.json</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.json">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.json">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.json">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.json">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.json">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.pgp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.pgp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.pgp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.pgp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.pgp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.txt">third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.txt">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.txt">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.txt">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.txt">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.txt">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.json">third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.json</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.json">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.json">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.json">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.json">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.json">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.pgp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.pgp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.pgp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.pgp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.pgp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.txt">third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.txt">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.txt">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.txt">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.txt">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.txt">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-sec.asc">third_party/rnp/src/tests/data/test_key_edge_cases/key-sec.asc</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-sec.asc">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-sec.asc">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-sec.asc">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-sec.asc">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-sec.asc">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.json">third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.json</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.json">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.json">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.json">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.json">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.json">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.pgp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.pgp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.pgp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.pgp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.pgp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.txt">third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.txt">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.txt">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.txt">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.txt">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.txt">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-1">third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-1</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-1">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-1">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-1">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-1">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-1">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-2">third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-2</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-2">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-2">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-2">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-2">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-2">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-3">third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-3</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-3">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-3">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-3">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-3">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-3">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-4">third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-4</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-4">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-4">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-4">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-4">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-4">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-5">third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-5</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-5">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-5">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-5">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-5">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/data/test_messages/message.txt.enc-malf-5">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/ffi.cpp">third_party/rnp/src/tests/ffi.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/ffi.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/ffi.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/ffi.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/ffi.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/ffi.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/generatekey.cpp">third_party/rnp/src/tests/generatekey.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/generatekey.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/generatekey.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/generatekey.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/generatekey.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/generatekey.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-add-userid.cpp">third_party/rnp/src/tests/key-add-userid.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-add-userid.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-add-userid.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-add-userid.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-add-userid.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-add-userid.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-grip.cpp">third_party/rnp/src/tests/key-grip.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-grip.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-grip.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-grip.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-grip.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-grip.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-protect.cpp">third_party/rnp/src/tests/key-protect.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-protect.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-protect.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-protect.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-protect.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-protect.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-store-search.cpp">third_party/rnp/src/tests/key-store-search.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-store-search.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-store-search.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-store-search.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-store-search.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-store-search.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-validate.cpp">third_party/rnp/src/tests/key-validate.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-validate.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-validate.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-validate.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-validate.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/key-validate.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-g10.cpp">third_party/rnp/src/tests/load-g10.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-g10.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-g10.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-g10.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-g10.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-g10.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-pgp.cpp">third_party/rnp/src/tests/load-pgp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-pgp.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-pgp.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-pgp.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-pgp.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/load-pgp.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/log-switch.cpp">third_party/rnp/src/tests/log-switch.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/log-switch.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/log-switch.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/log-switch.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/log-switch.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/log-switch.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/rnp_tests.h">third_party/rnp/src/tests/rnp_tests.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/rnp_tests.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/rnp_tests.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/rnp_tests.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/rnp_tests.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/rnp_tests.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/streams.cpp">third_party/rnp/src/tests/streams.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/streams.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/streams.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/streams.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/streams.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/streams.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.cpp">third_party/rnp/src/tests/support.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.h">third_party/rnp/src/tests/support.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.h">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.h">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.h">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.h">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/support.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/user-prefs.cpp">third_party/rnp/src/tests/user-prefs.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/user-prefs.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/user-prefs.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/user-prefs.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/user-prefs.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/user-prefs.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/utils-hex2bin.cpp">third_party/rnp/src/tests/utils-hex2bin.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/utils-hex2bin.cpp">file</a> |
<a href="/comm-central/annotate/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/utils-hex2bin.cpp">annotate</a> |
<a href="/comm-central/diff/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/utils-hex2bin.cpp">diff</a> |
<a href="/comm-central/comparison/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/utils-hex2bin.cpp">comparison</a> |
<a href="/comm-central/log/4f509afebd6f6b0ab9f8994773c44d7b5624691d/third_party/rnp/src/tests/utils-hex2bin.cpp">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/third_party/README.rnp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/third_party/README.rnp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -1,12 +1,12 @@</span>
<a href="#l1.4"></a><span id="l1.4"> Directory ./rnp contains a copy of rnp which has been obtained from:</span>
<a href="#l1.5"></a><span id="l1.5"> https://github.com/rnpgp/rnp</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7" class="difflineminus">-[commit eabaa5d07ae453c44dfa272f25ad7b5e41c8e5fb]</span>
<a href="#l1.8"></a><span id="l1.8" class="difflineplus">+[commit 6e74b75242e093ee12f0d630840b7a3fc1cd43ed]</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10"> For licensing information, please refer to the included documentation.</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12"> To update this copy, run &quot;update_rnp.sh&quot; in this directory from this directory</span>
<a href="#l1.13"></a><span id="l1.13"> within a complete build tree (including mozilla-central) as &quot;mach python&quot; is</span>
<a href="#l1.14"></a><span id="l1.14"> used.</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16"> update_rnp.sh will generate rnp/src/lib/version.h from rnp/src/lib/version.h.in</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/third_party/rnp/README.adoc</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/third_party/rnp/README.adoc</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -1,13 +1,14 @@</span>
<a href="#l2.4"></a><span id="l2.4"> = RNP</span>
<a href="#l2.5"></a><span id="l2.5"> </span>
<a href="#l2.6"></a><span id="l2.6"> image:https://github.com/rnpgp/rnp/workflows/macos/badge.svg[&quot;macOS Build Status&quot;, link=&quot;https://github.com/rnpgp/rnp/actions?workflow=macos&quot;]</span>
<a href="#l2.7"></a><span id="l2.7"> image:https://github.com/rnpgp/rnp/workflows/ubuntu/badge.svg[&quot;Ubuntu Build Status&quot;, link=&quot;https://github.com/rnpgp/rnp/actions?workflow=ubuntu&quot;]</span>
<a href="#l2.8"></a><span id="l2.8"> image:https://github.com/rnpgp/rnp/workflows/centos7/badge.svg[&quot;CentOS 7 Build Status&quot;, link=&quot;https://github.com/rnpgp/rnp/actions?workflow=centos7&quot;]</span>
<a href="#l2.9"></a><span id="l2.9" class="difflineplus">+image:https://github.com/rnpgp/rnp/workflows/windows/badge.svg[&quot;Windows Build Status&quot;, link=&quot;https://github.com/rnpgp/rnp/actions?workflow=windows&quot;]</span>
<a href="#l2.10"></a><span id="l2.10"> </span>
<a href="#l2.11"></a><span id="l2.11"> image:https://img.shields.io/coverity/scan/12616.svg[&quot;Coverity Scan Build Status&quot;, link=&quot;https://scan.coverity.com/projects/rnpgp-rnp&quot;]</span>
<a href="#l2.12"></a><span id="l2.12"> image:https://codecov.io/gh/rnpgp/rnp/branch/master/graph/badge.svg[&quot;Code coverage&quot;, link=&quot;https://codecov.io/gh/rnpgp/rnp&quot;]</span>
<a href="#l2.13"></a><span id="l2.13"> </span>
<a href="#l2.14"></a><span id="l2.14"> == Introduction</span>
<a href="#l2.15"></a><span id="l2.15"> </span>
<a href="#l2.16"></a><span id="l2.16"> RNP is a set of OpenPGP (RFC4880) tools that works on Linux, macOS, Windows and</span>
<a href="#l2.17"></a><span id="l2.17"> *BSD built with C++.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/third_party/rnp/include/rekey/rnp_key_store.h</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/third_party/rnp/include/rekey/rnp_key_store.h</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -30,16 +30,19 @@</span>
<a href="#l3.4"></a><span id="l3.4"> </span>
<a href="#l3.5"></a><span id="l3.5"> #ifndef KEY_STORE_H_</span>
<a href="#l3.6"></a><span id="l3.6"> #define KEY_STORE_H_</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8"> #include &lt;stdint.h&gt;</span>
<a href="#l3.9"></a><span id="l3.9"> #include &lt;stdbool.h&gt;</span>
<a href="#l3.10"></a><span id="l3.10"> #include &quot;rnp.h&quot;</span>
<a href="#l3.11"></a><span id="l3.11"> #include &quot;librepgp/stream-common.h&quot;</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+#include &lt;string&gt;</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+#include &lt;list&gt;</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+#include &lt;map&gt;</span>
<a href="#l3.15"></a><span id="l3.15"> </span>
<a href="#l3.16"></a><span id="l3.16"> typedef struct pgp_key_t pgp_key_t;</span>
<a href="#l3.17"></a><span id="l3.17"> </span>
<a href="#l3.18"></a><span id="l3.18"> typedef enum {</span>
<a href="#l3.19"></a><span id="l3.19">     KBX_EMPTY_BLOB = 0,</span>
<a href="#l3.20"></a><span id="l3.20">     KBX_HEADER_BLOB = 1,</span>
<a href="#l3.21"></a><span id="l3.21">     KBX_PGP_BLOB = 2,</span>
<a href="#l3.22"></a><span id="l3.22">     KBX_X509_BLOB = 3</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineat">@@ -124,41 +127,49 @@ typedef enum pgp_key_import_status_t {</span>
<a href="#l3.24"></a><span id="l3.24"> </span>
<a href="#l3.25"></a><span id="l3.25"> typedef enum pgp_sig_import_status_t {</span>
<a href="#l3.26"></a><span id="l3.26">     PGP_SIG_IMPORT_STATUS_UNKNOWN = 0,</span>
<a href="#l3.27"></a><span id="l3.27">     PGP_SIG_IMPORT_STATUS_UNKNOWN_KEY,</span>
<a href="#l3.28"></a><span id="l3.28">     PGP_SIG_IMPORT_STATUS_UNCHANGED,</span>
<a href="#l3.29"></a><span id="l3.29">     PGP_SIG_IMPORT_STATUS_NEW</span>
<a href="#l3.30"></a><span id="l3.30"> } pgp_sig_import_status_t;</span>
<a href="#l3.31"></a><span id="l3.31"> </span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+typedef std::map&lt;pgp_key_grip_t, std::list&lt;pgp_key_t&gt;::iterator&gt; pgp_key_grip_map_t;</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+</span>
<a href="#l3.34"></a><span id="l3.34"> typedef struct rnp_key_store_t {</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineminus">-    const char *           path;</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+    std::string            path;</span>
<a href="#l3.37"></a><span id="l3.37">     pgp_key_store_format_t format;</span>
<a href="#l3.38"></a><span id="l3.38">     bool disable_validation; /* do not automatically validate keys, added to this key store */</span>
<a href="#l3.39"></a><span id="l3.39"> </span>
<a href="#l3.40"></a><span id="l3.40" class="difflineminus">-    list keys;  // list of pgp_key_t</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+    std::list&lt;pgp_key_t&gt; keys;</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+    pgp_key_grip_map_t   keybygrip;</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+</span>
<a href="#l3.44"></a><span id="l3.44">     list blobs; // list of kbx_blob_t</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+    ~rnp_key_store_t();</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+    rnp_key_store_t() = default;</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+    rnp_key_store_t(pgp_key_store_format_t format, const std::string &amp;path);</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+    /* make sure we use only empty constructor */</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+    rnp_key_store_t(rnp_key_store_t &amp;&amp;src) = delete;</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+    rnp_key_store_t &amp;operator=(rnp_key_store_t &amp;&amp;) = delete;</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+    rnp_key_store_t(const rnp_key_store_t &amp;src) = delete;</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+    rnp_key_store_t &amp;operator=(const rnp_key_store_t &amp;) = delete;</span>
<a href="#l3.54"></a><span id="l3.54"> } rnp_key_store_t;</span>
<a href="#l3.55"></a><span id="l3.55"> </span>
<a href="#l3.56"></a><span id="l3.56" class="difflineminus">-rnp_key_store_t *rnp_key_store_new(pgp_key_store_format_t format, const char *path);</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineminus">-</span>
<a href="#l3.58"></a><span id="l3.58"> bool rnp_key_store_load_from_path(rnp_key_store_t *, const pgp_key_provider_t *key_provider);</span>
<a href="#l3.59"></a><span id="l3.59"> bool rnp_key_store_load_from_src(rnp_key_store_t *,</span>
<a href="#l3.60"></a><span id="l3.60">                                  pgp_source_t *,</span>
<a href="#l3.61"></a><span id="l3.61">                                  const pgp_key_provider_t *key_provider);</span>
<a href="#l3.62"></a><span id="l3.62"> </span>
<a href="#l3.63"></a><span id="l3.63"> bool rnp_key_store_write_to_path(rnp_key_store_t *);</span>
<a href="#l3.64"></a><span id="l3.64"> bool rnp_key_store_write_to_dst(rnp_key_store_t *, pgp_dest_t *);</span>
<a href="#l3.65"></a><span id="l3.65"> </span>
<a href="#l3.66"></a><span id="l3.66"> void rnp_key_store_clear(rnp_key_store_t *);</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineminus">-void rnp_key_store_free(rnp_key_store_t *);</span>
<a href="#l3.68"></a><span id="l3.68"> </span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-size_t     rnp_key_store_get_key_count(const rnp_key_store_t *);</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-pgp_key_t *rnp_key_store_get_key(const rnp_key_store_t *, size_t);</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-list       rnp_key_store_get_keys(const rnp_key_store_t *);</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+size_t rnp_key_store_get_key_count(const rnp_key_store_t *);</span>
<a href="#l3.73"></a><span id="l3.73"> </span>
<a href="#l3.74"></a><span id="l3.74"> /**</span>
<a href="#l3.75"></a><span id="l3.75">  * @brief Add key to the keystore, copying it.</span>
<a href="#l3.76"></a><span id="l3.76">  *</span>
<a href="#l3.77"></a><span id="l3.77">  * @param keyring allocated keyring, cannot be NULL.</span>
<a href="#l3.78"></a><span id="l3.78">  * @param key key to be added, cannot be NULL.</span>
<a href="#l3.79"></a><span id="l3.79">  * @return pointer to the added key or NULL if failed.</span>
<a href="#l3.80"></a><span id="l3.80">  */</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineat">@@ -191,22 +202,20 @@ pgp_sig_import_status_t rnp_key_store_im</span>
<a href="#l3.82"></a><span id="l3.82">  * @return pointer to the key to which this signature belongs (or NULL if key was not found)</span>
<a href="#l3.83"></a><span id="l3.83">  */</span>
<a href="#l3.84"></a><span id="l3.84"> pgp_key_t *rnp_key_store_import_signature(rnp_key_store_t *        keyring,</span>
<a href="#l3.85"></a><span id="l3.85">                                           const pgp_signature_t *  sig,</span>
<a href="#l3.86"></a><span id="l3.86">                                           pgp_sig_import_status_t *status);</span>
<a href="#l3.87"></a><span id="l3.87"> </span>
<a href="#l3.88"></a><span id="l3.88"> bool rnp_key_store_remove_key(rnp_key_store_t *, const pgp_key_t *);</span>
<a href="#l3.89"></a><span id="l3.89"> </span>
<a href="#l3.90"></a><span id="l3.90" class="difflineminus">-pgp_key_t *rnp_key_store_get_key_by_id(const rnp_key_store_t *,</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineminus">-                                       const unsigned char *,</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineminus">-                                       pgp_key_t *);</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+pgp_key_t *rnp_key_store_get_key_by_id(rnp_key_store_t *, const unsigned char *, pgp_key_t *);</span>
<a href="#l3.94"></a><span id="l3.94"> </span>
<a href="#l3.95"></a><span id="l3.95" class="difflineminus">-bool rnp_key_store_get_key_grip(const pgp_key_material_t *, uint8_t *);</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+bool rnp_key_store_get_key_grip(const pgp_key_material_t *, pgp_key_grip_t &amp;grip);</span>
<a href="#l3.97"></a><span id="l3.97"> </span>
<a href="#l3.98"></a><span id="l3.98" class="difflineminus">-pgp_key_t *rnp_key_store_get_key_by_grip(const rnp_key_store_t *, const uint8_t *);</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineminus">-pgp_key_t *rnp_key_store_get_key_by_fpr(const rnp_key_store_t *, const pgp_fingerprint_t *fpr);</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineminus">-pgp_key_t *rnp_key_store_get_primary_key(const rnp_key_store_t *, const pgp_key_t *);</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineminus">-pgp_key_t *rnp_key_store_search(const rnp_key_store_t *,</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineminus">-                                const pgp_key_search_t *,</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineminus">-                                pgp_key_t *);</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+const pgp_key_t *rnp_key_store_get_key_by_grip(const rnp_key_store_t *,</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+                                               const pgp_key_grip_t &amp;);</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+pgp_key_t *      rnp_key_store_get_key_by_grip(rnp_key_store_t *, const pgp_key_grip_t &amp;);</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+pgp_key_t *      rnp_key_store_get_key_by_fpr(rnp_key_store_t *, const pgp_fingerprint_t *fpr);</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+pgp_key_t *      rnp_key_store_get_primary_key(rnp_key_store_t *, const pgp_key_t *);</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+pgp_key_t *rnp_key_store_search(rnp_key_store_t *, const pgp_key_search_t *, pgp_key_t *);</span>
<a href="#l3.110"></a><span id="l3.110"> </span>
<a href="#l3.111"></a><span id="l3.111"> #endif /* KEY_STORE_H_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/third_party/rnp/include/repgp/repgp_def.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/third_party/rnp/include/repgp/repgp_def.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -336,42 +336,52 @@ typedef enum {</span>
<a href="#l4.4"></a><span id="l4.4"> /** Signature Subpacket Type</span>
<a href="#l4.5"></a><span id="l4.5">  * Signature subpackets contains additional information about the signature</span>
<a href="#l4.6"></a><span id="l4.6">  *</span>
<a href="#l4.7"></a><span id="l4.7">  * \see RFC4880 5.2.3.1-5.2.3.26</span>
<a href="#l4.8"></a><span id="l4.8">  */</span>
<a href="#l4.9"></a><span id="l4.9"> </span>
<a href="#l4.10"></a><span id="l4.10"> typedef enum {</span>
<a href="#l4.11"></a><span id="l4.11">     PGP_SIG_SUBPKT_UNKNOWN = 0,</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-    PGP_SIG_SUBPKT_CREATION_TIME = 2,       /* signature creation time */</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">-    PGP_SIG_SUBPKT_EXPIRATION_TIME = 3,     /* signature expiration time */</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineminus">-    PGP_SIG_SUBPKT_EXPORT_CERT = 4,         /* exportable certification */</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineminus">-    PGP_SIG_SUBPKT_TRUST = 5,               /* trust signature */</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">-    PGP_SIG_SUBPKT_REGEXP = 6,              /* regular expression */</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineminus">-    PGP_SIG_SUBPKT_REVOCABLE = 7,           /* revocable */</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineminus">-    PGP_SIG_SUBPKT_KEY_EXPIRY = 9,          /* key expiration time */</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineminus">-    PGP_SIG_SUBPKT_RESERVED = 10,           /* reserved */</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineminus">-    PGP_SIG_SUBPKT_PREFERRED_SKA = 11,      /* preferred symmetric algs */</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineminus">-    PGP_SIG_SUBPKT_REVOCATION_KEY = 12,     /* revocation key */</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineminus">-    PGP_SIG_SUBPKT_ISSUER_KEY_ID = 16,      /* issuer key ID */</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+    PGP_SIG_SUBPKT_RESERVED_1 = 1,</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+    PGP_SIG_SUBPKT_CREATION_TIME = 2,   /* signature creation time */</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+    PGP_SIG_SUBPKT_EXPIRATION_TIME = 3, /* signature expiration time */</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+    PGP_SIG_SUBPKT_EXPORT_CERT = 4,     /* exportable certification */</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+    PGP_SIG_SUBPKT_TRUST = 5,           /* trust signature */</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+    PGP_SIG_SUBPKT_REGEXP = 6,          /* regular expression */</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+    PGP_SIG_SUBPKT_REVOCABLE = 7,       /* revocable */</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+    PGP_SIG_SUBPKT_RESERVED_8 = 8,</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+    PGP_SIG_SUBPKT_KEY_EXPIRY = 9,      /* key expiration time */</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+    PGP_SIG_SUBPKT_PLACEHOLDER = 10,    /* placeholder for backward compatibility */</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+    PGP_SIG_SUBPKT_PREFERRED_SKA = 11,  /* preferred symmetric algs */</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+    PGP_SIG_SUBPKT_REVOCATION_KEY = 12, /* revocation key */</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+    PGP_SIG_SUBPKT_RESERVED_13 = 13,</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+    PGP_SIG_SUBPKT_RESERVED_14 = 14,</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+    PGP_SIG_SUBPKT_RESERVED_15 = 15,</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+    PGP_SIG_SUBPKT_ISSUER_KEY_ID = 16, /* issuer key ID */</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+    PGP_SIG_SUBPKT_RESERVED_17 = 17,</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+    PGP_SIG_SUBPKT_RESERVED_18 = 18,</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+    PGP_SIG_SUBPKT_RESERVED_19 = 19,</span>
<a href="#l4.42"></a><span id="l4.42">     PGP_SIG_SUBPKT_NOTATION_DATA = 20,      /* notation data */</span>
<a href="#l4.43"></a><span id="l4.43">     PGP_SIG_SUBPKT_PREFERRED_HASH = 21,     /* preferred hash algs */</span>
<a href="#l4.44"></a><span id="l4.44">     PGP_SIG_SUBPKT_PREF_COMPRESS = 22,      /* preferred compression algorithms */</span>
<a href="#l4.45"></a><span id="l4.45">     PGP_SIG_SUBPKT_KEYSERV_PREFS = 23,      /* key server preferences */</span>
<a href="#l4.46"></a><span id="l4.46">     PGP_SIG_SUBPKT_PREF_KEYSERV = 24,       /* preferred key Server */</span>
<a href="#l4.47"></a><span id="l4.47">     PGP_SIG_SUBPKT_PRIMARY_USER_ID = 25,    /* primary user ID */</span>
<a href="#l4.48"></a><span id="l4.48">     PGP_SIG_SUBPKT_POLICY_URI = 26,         /* policy URI */</span>
<a href="#l4.49"></a><span id="l4.49">     PGP_SIG_SUBPKT_KEY_FLAGS = 27,          /* key flags */</span>
<a href="#l4.50"></a><span id="l4.50">     PGP_SIG_SUBPKT_SIGNERS_USER_ID = 28,    /* signer's user ID */</span>
<a href="#l4.51"></a><span id="l4.51">     PGP_SIG_SUBPKT_REVOCATION_REASON = 29,  /* reason for revocation */</span>
<a href="#l4.52"></a><span id="l4.52">     PGP_SIG_SUBPKT_FEATURES = 30,           /* features */</span>
<a href="#l4.53"></a><span id="l4.53">     PGP_SIG_SUBPKT_SIGNATURE_TARGET = 31,   /* signature target */</span>
<a href="#l4.54"></a><span id="l4.54">     PGP_SIG_SUBPKT_EMBEDDED_SIGNATURE = 32, /* embedded signature */</span>
<a href="#l4.55"></a><span id="l4.55">     PGP_SIG_SUBPKT_ISSUER_FPR = 33,         /* issuer fingerprint */</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineminus">-    PGP_SIG_SUBPKT_PREFERRED_AEAD = 34      /* preferred AEAD algorithms */</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+    PGP_SIG_SUBPKT_PREFERRED_AEAD = 34,     /* preferred AEAD algorithms */</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineplus">+    PGP_SIG_SUBPKT_PRIVATE_FIRST = 100,     /* private/experimental subpackets */</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineplus">+    PGP_SIG_SUBPKT_PRIVATE_LAST = 110</span>
<a href="#l4.60"></a><span id="l4.60"> } pgp_sig_subpacket_type_t;</span>
<a href="#l4.61"></a><span id="l4.61"> </span>
<a href="#l4.62"></a><span id="l4.62"> /** Key Flags</span>
<a href="#l4.63"></a><span id="l4.63">  *</span>
<a href="#l4.64"></a><span id="l4.64">  * \see RFC4880 5.2.3.21</span>
<a href="#l4.65"></a><span id="l4.65">  */</span>
<a href="#l4.66"></a><span id="l4.66"> typedef enum {</span>
<a href="#l4.67"></a><span id="l4.67">     PGP_KF_CERTIFY = 0x01,         /* This key may be used to certify other keys. */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/third_party/rnp/src/fuzzing/fuzz_keys.c</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/third_party/rnp/src/fuzzing/fuzz_keys.c</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -1,14 +1,17 @@</span>
<a href="#l5.4"></a><span id="l5.4"> #include &lt;rnp/rnp.h&gt;</span>
<a href="#l5.5"></a><span id="l5.5"> #include &lt;rekey/rnp_key_store.h&gt;</span>
<a href="#l5.6"></a><span id="l5.6"> </span>
<a href="#l5.7"></a><span id="l5.7"> int</span>
<a href="#l5.8"></a><span id="l5.8"> main(int argc, char *argv[])</span>
<a href="#l5.9"></a><span id="l5.9"> {</span>
<a href="#l5.10"></a><span id="l5.10" class="difflineminus">-    rnp_key_store_t *key_store = rnp_key_store_new(RNP_KEYSTORE_GPG, argv[1]);</span>
<a href="#l5.11"></a><span id="l5.11" class="difflineminus">-    if (key_store == NULL) {</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+    rnp_key_store_t *key_store = NULL;</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+    try {</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+        key_store = new rnp_key_store_t(RNP_KEYSTORE_GPG, argv[1]);</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l5.17"></a><span id="l5.17">         return 1;</span>
<a href="#l5.18"></a><span id="l5.18">     }</span>
<a href="#l5.19"></a><span id="l5.19">     rnp_key_store_load_from_path(key_store, NULL);</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+    delete key_store;</span>
<a href="#l5.22"></a><span id="l5.22">     return 0;</span>
<a href="#l5.23"></a><span id="l5.23"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/third_party/rnp/src/lib/CMakeLists.txt</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/third_party/rnp/src/lib/CMakeLists.txt</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -46,16 +46,17 @@ check_include_file_cxx(sys/resource.h HA</span>
<a href="#l6.4"></a><span id="l6.4"> check_include_file_cxx(sys/stat.h HAVE_SYS_STAT_H)</span>
<a href="#l6.5"></a><span id="l6.5"> check_include_file_cxx(sys/types.h HAVE_SYS_TYPES_H)</span>
<a href="#l6.6"></a><span id="l6.6"> check_include_file_cxx(unistd.h HAVE_UNISTD_H)</span>
<a href="#l6.7"></a><span id="l6.7"> check_include_file_cxx(sys/wait.h HAVE_SYS_WAIT_H)</span>
<a href="#l6.8"></a><span id="l6.8"> check_cxx_symbol_exists(mkdtemp &quot;stdlib.h;unistd.h&quot; HAVE_MKDTEMP)</span>
<a href="#l6.9"></a><span id="l6.9"> check_cxx_symbol_exists(realpath stdlib.h HAVE_REALPATH)</span>
<a href="#l6.10"></a><span id="l6.10"> check_cxx_symbol_exists(O_BINARY fcntl.h HAVE_O_BINARY)</span>
<a href="#l6.11"></a><span id="l6.11"> check_cxx_symbol_exists(_O_BINARY fcntl.h HAVE__O_BINARY)</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+check_cxx_symbol_exists(_tempnam stdio.h HAVE__TEMPNAM)</span>
<a href="#l6.13"></a><span id="l6.13"> set(HAVE_ZLIB_H &quot;${ZLIB_FOUND}&quot;)</span>
<a href="#l6.14"></a><span id="l6.14"> set(HAVE_BZLIB_H &quot;${BZIP2_FOUND}&quot;)</span>
<a href="#l6.15"></a><span id="l6.15"> configure_file(config.h.in config.h)</span>
<a href="#l6.16"></a><span id="l6.16"> # generate a version.h</span>
<a href="#l6.17"></a><span id="l6.17"> configure_file(version.h.in version.h)</span>
<a href="#l6.18"></a><span id="l6.18"> </span>
<a href="#l6.19"></a><span id="l6.19"> # check botan's enabled features</span>
<a href="#l6.20"></a><span id="l6.20"> set(CMAKE_REQUIRED_INCLUDES &quot;${BOTAN2_INCLUDE_DIRS}&quot;)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/third_party/rnp/src/lib/config.h.in</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/third_party/rnp/src/lib/config.h.in</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -19,17 +19,17 @@</span>
<a href="#l7.4"></a><span id="l7.4">  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a href="#l7.5"></a><span id="l7.5">  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a href="#l7.6"></a><span id="l7.6">  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a href="#l7.7"></a><span id="l7.7">  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a href="#l7.8"></a><span id="l7.8">  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a href="#l7.9"></a><span id="l7.9">  * POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l7.10"></a><span id="l7.10">  */</span>
<a href="#l7.11"></a><span id="l7.11"> </span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-#define PACKAGE_STRING    &quot;rnp 0.13.1+git20200506.eabaa5d0.MZLA&quot;</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+#define PACKAGE_STRING    &quot;rnp 0.13.1+git20200530.6e74b752.MZLA&quot;</span>
<a href="#l7.14"></a><span id="l7.14"> #define PACKAGE_BUGREPORT &quot;https://bugzilla.mozilla.org/enter_bug.cgi?product=Thunderbird&quot;</span>
<a href="#l7.15"></a><span id="l7.15"> </span>
<a href="#l7.16"></a><span id="l7.16"> #undef HAVE_BZLIB_H</span>
<a href="#l7.17"></a><span id="l7.17"> #undef HAVE_ZLIB_H</span>
<a href="#l7.18"></a><span id="l7.18"> </span>
<a href="#l7.19"></a><span id="l7.19"> #undef HAVE_FCNTL_H</span>
<a href="#l7.20"></a><span id="l7.20"> #undef HAVE_INTTYPES_H</span>
<a href="#l7.21"></a><span id="l7.21"> #undef HAVE_LIMITS_H</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineat">@@ -41,8 +41,10 @@</span>
<a href="#l7.23"></a><span id="l7.23"> #undef HAVE_SYS_STAT_H</span>
<a href="#l7.24"></a><span id="l7.24"> #undef HAVE_SYS_TYPES_H</span>
<a href="#l7.25"></a><span id="l7.25"> #undef HAVE_UNISTD_H</span>
<a href="#l7.26"></a><span id="l7.26"> #undef HAVE_SYS_WAIT_H</span>
<a href="#l7.27"></a><span id="l7.27"> #undef HAVE_MKDTEMP</span>
<a href="#l7.28"></a><span id="l7.28"> #undef HAVE_REALPATH</span>
<a href="#l7.29"></a><span id="l7.29"> #undef HAVE_O_BINARY</span>
<a href="#l7.30"></a><span id="l7.30"> #undef HAVE__O_BINARY</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+#undef HAVE__TEMPNAM</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto.cpp</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto.cpp</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -174,22 +174,25 @@ bool</span>
<a href="#l8.4"></a><span id="l8.4"> key_material_equal(const pgp_key_material_t *key1, const pgp_key_material_t *key2)</span>
<a href="#l8.5"></a><span id="l8.5"> {</span>
<a href="#l8.6"></a><span id="l8.6">     if (key1-&gt;alg != key2-&gt;alg) {</span>
<a href="#l8.7"></a><span id="l8.7">         return false;</span>
<a href="#l8.8"></a><span id="l8.8">     }</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10">     switch (key1-&gt;alg) {</span>
<a href="#l8.11"></a><span id="l8.11">     case PGP_PKA_RSA:</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l8.14"></a><span id="l8.14">         return mpi_equal(&amp;key1-&gt;rsa.n, &amp;key2-&gt;rsa.n) &amp;&amp; mpi_equal(&amp;key1-&gt;rsa.e, &amp;key2-&gt;rsa.e);</span>
<a href="#l8.15"></a><span id="l8.15">     case PGP_PKA_DSA:</span>
<a href="#l8.16"></a><span id="l8.16">         return mpi_equal(&amp;key1-&gt;dsa.p, &amp;key2-&gt;dsa.p) &amp;&amp;</span>
<a href="#l8.17"></a><span id="l8.17">                mpi_equal(&amp;key1-&gt;dsa.q, &amp;key2-&gt;dsa.q) &amp;&amp;</span>
<a href="#l8.18"></a><span id="l8.18">                mpi_equal(&amp;key1-&gt;dsa.g, &amp;key2-&gt;dsa.g) &amp;&amp; mpi_equal(&amp;key1-&gt;dsa.y, &amp;key2-&gt;dsa.y);</span>
<a href="#l8.19"></a><span id="l8.19">     case PGP_PKA_ELGAMAL:</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l8.21"></a><span id="l8.21">         return mpi_equal(&amp;key1-&gt;eg.p, &amp;key2-&gt;eg.p) &amp;&amp; mpi_equal(&amp;key1-&gt;eg.g, &amp;key2-&gt;eg.g) &amp;&amp;</span>
<a href="#l8.22"></a><span id="l8.22">                mpi_equal(&amp;key1-&gt;eg.y, &amp;key2-&gt;eg.y);</span>
<a href="#l8.23"></a><span id="l8.23">     case PGP_PKA_EDDSA:</span>
<a href="#l8.24"></a><span id="l8.24">     case PGP_PKA_ECDH:</span>
<a href="#l8.25"></a><span id="l8.25">     case PGP_PKA_ECDSA:</span>
<a href="#l8.26"></a><span id="l8.26">     case PGP_PKA_SM2:</span>
<a href="#l8.27"></a><span id="l8.27">         return (key1-&gt;ec.curve == key2-&gt;ec.curve) &amp;&amp; mpi_equal(&amp;key1-&gt;ec.p, &amp;key2-&gt;ec.p);</span>
<a href="#l8.28"></a><span id="l8.28">     default:</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineat">@@ -198,28 +201,31 @@ key_material_equal(const pgp_key_materia</span>
<a href="#l8.30"></a><span id="l8.30">     }</span>
<a href="#l8.31"></a><span id="l8.31"> }</span>
<a href="#l8.32"></a><span id="l8.32"> </span>
<a href="#l8.33"></a><span id="l8.33"> rnp_result_t</span>
<a href="#l8.34"></a><span id="l8.34"> validate_pgp_key_material(const pgp_key_material_t *material, rng_t *rng)</span>
<a href="#l8.35"></a><span id="l8.35"> {</span>
<a href="#l8.36"></a><span id="l8.36">     switch (material-&gt;alg) {</span>
<a href="#l8.37"></a><span id="l8.37">     case PGP_PKA_RSA:</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l8.40"></a><span id="l8.40">         return rsa_validate_key(rng, &amp;material-&gt;rsa, material-&gt;secret);</span>
<a href="#l8.41"></a><span id="l8.41">     case PGP_PKA_DSA:</span>
<a href="#l8.42"></a><span id="l8.42">         return dsa_validate_key(rng, &amp;material-&gt;dsa, material-&gt;secret);</span>
<a href="#l8.43"></a><span id="l8.43">     case PGP_PKA_EDDSA:</span>
<a href="#l8.44"></a><span id="l8.44">         return eddsa_validate_key(rng, &amp;material-&gt;ec, material-&gt;secret);</span>
<a href="#l8.45"></a><span id="l8.45">     case PGP_PKA_ECDH:</span>
<a href="#l8.46"></a><span id="l8.46">         return ecdh_validate_key(rng, &amp;material-&gt;ec, material-&gt;secret);</span>
<a href="#l8.47"></a><span id="l8.47">     case PGP_PKA_ECDSA:</span>
<a href="#l8.48"></a><span id="l8.48">         return ecdsa_validate_key(rng, &amp;material-&gt;ec, material-&gt;secret);</span>
<a href="#l8.49"></a><span id="l8.49">     case PGP_PKA_SM2:</span>
<a href="#l8.50"></a><span id="l8.50">         return sm2_validate_key(rng, &amp;material-&gt;ec, material-&gt;secret);</span>
<a href="#l8.51"></a><span id="l8.51">     case PGP_PKA_ELGAMAL:</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l8.53"></a><span id="l8.53">         return elgamal_validate_key(rng, &amp;material-&gt;eg, material-&gt;secret);</span>
<a href="#l8.54"></a><span id="l8.54">     default:</span>
<a href="#l8.55"></a><span id="l8.55">         RNP_LOG(&quot;unknown public key algorithm: %d&quot;, (int) material-&gt;alg);</span>
<a href="#l8.56"></a><span id="l8.56">     }</span>
<a href="#l8.57"></a><span id="l8.57"> </span>
<a href="#l8.58"></a><span id="l8.58">     return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l8.59"></a><span id="l8.59"> }</span>
<a href="#l8.60"></a><span id="l8.60"> </span>
<a href="#l8.61"></a><span id="l8.61" class="difflineat">@@ -229,16 +235,17 @@ key_bitlength(const pgp_key_material_t *</span>
<a href="#l8.62"></a><span id="l8.62">     switch (key-&gt;alg) {</span>
<a href="#l8.63"></a><span id="l8.63">     case PGP_PKA_RSA:</span>
<a href="#l8.64"></a><span id="l8.64">     case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l8.65"></a><span id="l8.65">     case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l8.66"></a><span id="l8.66">         return 8 * mpi_bytes(&amp;key-&gt;rsa.n);</span>
<a href="#l8.67"></a><span id="l8.67">     case PGP_PKA_DSA:</span>
<a href="#l8.68"></a><span id="l8.68">         return 8 * mpi_bytes(&amp;key-&gt;dsa.p);</span>
<a href="#l8.69"></a><span id="l8.69">     case PGP_PKA_ELGAMAL:</span>
<a href="#l8.70"></a><span id="l8.70" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l8.71"></a><span id="l8.71">         return 8 * mpi_bytes(&amp;key-&gt;eg.y);</span>
<a href="#l8.72"></a><span id="l8.72">     case PGP_PKA_ECDH:</span>
<a href="#l8.73"></a><span id="l8.73">     case PGP_PKA_ECDSA:</span>
<a href="#l8.74"></a><span id="l8.74">     case PGP_PKA_EDDSA:</span>
<a href="#l8.75"></a><span id="l8.75">     case PGP_PKA_SM2: {</span>
<a href="#l8.76"></a><span id="l8.76">         // bn_num_bytes returns value &lt;= curve order</span>
<a href="#l8.77"></a><span id="l8.77">         const ec_curve_desc_t *curve = get_curve_desc(key-&gt;ec.curve);</span>
<a href="#l8.78"></a><span id="l8.78">         return curve ? curve-&gt;bitlen : 0;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto/ec.cpp</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto/ec.cpp</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -78,20 +78,20 @@ static const ec_curve_desc_t ec_curves[]</span>
<a href="#l9.4"></a><span id="l9.4">    {0x2B, 0x81, 0x04, 0x00, 0x23},</span>
<a href="#l9.5"></a><span id="l9.5">    5,</span>
<a href="#l9.6"></a><span id="l9.6">    &quot;secp521r1&quot;,</span>
<a href="#l9.7"></a><span id="l9.7">    &quot;NIST P-521&quot;,</span>
<a href="#l9.8"></a><span id="l9.8">    &quot;0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot;</span>
<a href="#l9.9"></a><span id="l9.9">    &quot;ffffffffffffffffffffffffffffffffffffffffffff&quot;,</span>
<a href="#l9.10"></a><span id="l9.10">    &quot;0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot;</span>
<a href="#l9.11"></a><span id="l9.11">    &quot;fffffffffffffffffffffffffffffffffffffffffffc&quot;,</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-   &quot;0x051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c&quot;</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineminus">-   &quot;0bd3bb1bf073573df883d2c34f1ef451fd46b503f00&quot;,</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineminus">-   &quot;0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0&quot;</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineminus">-   &quot;148f709a5d03bb5c9b8899c47aebb6fb71e91386409&quot;,</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+   &quot;0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652&quot;</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineplus">+   &quot;c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00&quot;,</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+   &quot;0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc&quot;</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+   &quot;0148f709a5d03bb5c9b8899c47aebb6fb71e91386409&quot;,</span>
<a href="#l9.20"></a><span id="l9.20">    &quot;0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1d&quot;</span>
<a href="#l9.21"></a><span id="l9.21">    &quot;c127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66&quot;,</span>
<a href="#l9.22"></a><span id="l9.22">    &quot;0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550&quot;</span>
<a href="#l9.23"></a><span id="l9.23">    &quot;b9013fad0761353c7086a272c24088be94769fd16650&quot;,</span>
<a href="#l9.24"></a><span id="l9.24">    &quot;0x01&quot;},</span>
<a href="#l9.25"></a><span id="l9.25">   {PGP_CURVE_ED25519,</span>
<a href="#l9.26"></a><span id="l9.26">    255,</span>
<a href="#l9.27"></a><span id="l9.27">    {0x2b, 0x06, 0x01, 0x04, 0x01, 0xda, 0x47, 0x0f, 0x01},</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto/signatures.cpp</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto/signatures.cpp</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -221,20 +221,30 @@ signature_validate(const pgp_signature_t</span>
<a href="#l10.4"></a><span id="l10.4">         break;</span>
<a href="#l10.5"></a><span id="l10.5">     case PGP_PKA_EDDSA:</span>
<a href="#l10.6"></a><span id="l10.6">         ret = eddsa_verify(&amp;sig-&gt;material.ecc, hval, hlen, &amp;key-&gt;ec);</span>
<a href="#l10.7"></a><span id="l10.7">         break;</span>
<a href="#l10.8"></a><span id="l10.8">     case PGP_PKA_SM2:</span>
<a href="#l10.9"></a><span id="l10.9">         ret = sm2_verify(&amp;sig-&gt;material.ecc, hash_alg, hval, hlen, &amp;key-&gt;ec);</span>
<a href="#l10.10"></a><span id="l10.10">         break;</span>
<a href="#l10.11"></a><span id="l10.11">     case PGP_PKA_RSA:</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l10.13"></a><span id="l10.13">         ret = rsa_verify_pkcs1(&amp;sig-&gt;material.rsa, sig-&gt;halg, hval, hlen, &amp;key-&gt;rsa);</span>
<a href="#l10.14"></a><span id="l10.14">         break;</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+        RNP_LOG(&quot;RSA encrypt-only signature considered as invalid.&quot;);</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+        ret = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+        break;</span>
<a href="#l10.19"></a><span id="l10.19">     case PGP_PKA_ECDSA:</span>
<a href="#l10.20"></a><span id="l10.20">         ret = ecdsa_verify(&amp;sig-&gt;material.ecc, hash_alg, hval, hlen, &amp;key-&gt;ec);</span>
<a href="#l10.21"></a><span id="l10.21">         break;</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineplus">+    case PGP_PKA_ELGAMAL:</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+        RNP_LOG(&quot;ElGamal are considered as invalid.&quot;);</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineplus">+        ret = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineplus">+        break;</span>
<a href="#l10.27"></a><span id="l10.27">     default:</span>
<a href="#l10.28"></a><span id="l10.28">         RNP_LOG(&quot;Unknown algorithm&quot;);</span>
<a href="#l10.29"></a><span id="l10.29">         ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l10.30"></a><span id="l10.30">     }</span>
<a href="#l10.31"></a><span id="l10.31"> </span>
<a href="#l10.32"></a><span id="l10.32">     return ret;</span>
<a href="#l10.33"></a><span id="l10.33"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/third_party/rnp/src/lib/ffi-priv-types.h</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/third_party/rnp/src/lib/ffi-priv-types.h</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -138,22 +138,22 @@ struct rnp_op_encrypt_st {</span>
<a href="#l11.4"></a><span id="l11.4">     rnp_ffi_t    ffi;</span>
<a href="#l11.5"></a><span id="l11.5">     rnp_input_t  input;</span>
<a href="#l11.6"></a><span id="l11.6">     rnp_output_t output;</span>
<a href="#l11.7"></a><span id="l11.7">     rnp_ctx_t    rnpctx;</span>
<a href="#l11.8"></a><span id="l11.8">     list         signatures;</span>
<a href="#l11.9"></a><span id="l11.9"> };</span>
<a href="#l11.10"></a><span id="l11.10"> </span>
<a href="#l11.11"></a><span id="l11.11"> struct rnp_identifier_iterator_st {</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-    rnp_ffi_t             ffi;</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineminus">-    pgp_key_search_type_t type;</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineminus">-    rnp_key_store_t *     store;</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineminus">-    pgp_key_t *           keyp;</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineminus">-    unsigned              uididx;</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineminus">-    json_object *         tbl;</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineplus">+    rnp_ffi_t                      ffi;</span>
<a href="#l11.19"></a><span id="l11.19" class="difflineplus">+    pgp_key_search_type_t          type;</span>
<a href="#l11.20"></a><span id="l11.20" class="difflineplus">+    rnp_key_store_t *              store;</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineplus">+    std::list&lt;pgp_key_t&gt;::iterator keyp;</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+    unsigned                       uididx;</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineplus">+    json_object *                  tbl;</span>
<a href="#l11.24"></a><span id="l11.24">     char</span>
<a href="#l11.25"></a><span id="l11.25">       buf[1 + MAX(MAX(MAX(PGP_KEY_ID_SIZE * 2, PGP_KEY_GRIP_SIZE), PGP_FINGERPRINT_SIZE * 2),</span>
<a href="#l11.26"></a><span id="l11.26">                   MAX_ID_LENGTH)];</span>
<a href="#l11.27"></a><span id="l11.27"> };</span>
<a href="#l11.28"></a><span id="l11.28"> </span>
<a href="#l11.29"></a><span id="l11.29"> /* This is just for readability at the call site and will hopefully reduce mistakes.</span>
<a href="#l11.30"></a><span id="l11.30">  *</span>
<a href="#l11.31"></a><span id="l11.31">  * Instead of:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/third_party/rnp/src/lib/generate-key.cpp</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/third_party/rnp/src/lib/generate-key.cpp</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -96,18 +96,20 @@ load_generated_g10_key(pgp_key_t *    ds</span>
<a href="#l12.4"></a><span id="l12.4">     }</span>
<a href="#l12.5"></a><span id="l12.5"> </span>
<a href="#l12.6"></a><span id="l12.6">     if (!g10_write_seckey(&amp;memdst, newkey, NULL)) {</span>
<a href="#l12.7"></a><span id="l12.7">         RNP_LOG(&quot;failed to write generated seckey&quot;);</span>
<a href="#l12.8"></a><span id="l12.8">         goto end;</span>
<a href="#l12.9"></a><span id="l12.9">     }</span>
<a href="#l12.10"></a><span id="l12.10"> </span>
<a href="#l12.11"></a><span id="l12.11">     // this would be better on the stack but the key store does not allow it</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-    key_store = (rnp_key_store_t *) calloc(1, sizeof(*key_store));</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineminus">-    if (!key_store) {</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineplus">+    try {</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineplus">+        key_store = new rnp_key_store_t();</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l12.17"></a><span id="l12.17" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l12.18"></a><span id="l12.18">         goto end;</span>
<a href="#l12.19"></a><span id="l12.19">     }</span>
<a href="#l12.20"></a><span id="l12.20"> </span>
<a href="#l12.21"></a><span id="l12.21">     // if this is a subkey, add the primary in first</span>
<a href="#l12.22"></a><span id="l12.22">     if (primary_key &amp;&amp; !list_append(&amp;key_ptrs, &amp;primary_key, sizeof(primary_key))) {</span>
<a href="#l12.23"></a><span id="l12.23">         goto end;</span>
<a href="#l12.24"></a><span id="l12.24">     }</span>
<a href="#l12.25"></a><span id="l12.25">     // G10 needs the pubkey for copying some attributes (key version, creation time, etc)</span>
<a href="#l12.26"></a><span id="l12.26" class="difflineat">@@ -120,26 +122,25 @@ load_generated_g10_key(pgp_key_t *    ds</span>
<a href="#l12.27"></a><span id="l12.27"> </span>
<a href="#l12.28"></a><span id="l12.28">     if (init_mem_src(&amp;memsrc, mem_dest_get_memory(&amp;memdst), memdst.writeb, false)) {</span>
<a href="#l12.29"></a><span id="l12.29">         goto end;</span>
<a href="#l12.30"></a><span id="l12.30">     }</span>
<a href="#l12.31"></a><span id="l12.31"> </span>
<a href="#l12.32"></a><span id="l12.32">     if (!rnp_key_store_g10_from_src(key_store, &amp;memsrc, &amp;prov)) {</span>
<a href="#l12.33"></a><span id="l12.33">         goto end;</span>
<a href="#l12.34"></a><span id="l12.34">     }</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineminus">-    // if a primary key is provided, it should match the sub with regards to type</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineminus">-    assert(!primary_key ||</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineminus">-           (pgp_key_is_secret(primary_key) ==</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineminus">-            pgp_key_is_secret((pgp_key_t *) list_back(rnp_key_store_get_keys(key_store)))));</span>
<a href="#l12.39"></a><span id="l12.39">     if (rnp_key_store_get_key_count(key_store) != 1) {</span>
<a href="#l12.40"></a><span id="l12.40">         goto end;</span>
<a href="#l12.41"></a><span id="l12.41">     }</span>
<a href="#l12.42"></a><span id="l12.42" class="difflineminus">-    ok = !pgp_key_copy(dst, rnp_key_store_get_key(key_store, 0), false);</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineplus">+    // if a primary key is provided, it should match the sub with regards to type</span>
<a href="#l12.44"></a><span id="l12.44" class="difflineplus">+    assert(!primary_key ||</span>
<a href="#l12.45"></a><span id="l12.45" class="difflineplus">+           (pgp_key_is_secret(primary_key) == pgp_key_is_secret(&amp;key_store-&gt;keys.front())));</span>
<a href="#l12.46"></a><span id="l12.46" class="difflineplus">+    ok = !pgp_key_copy(dst, &amp;key_store-&gt;keys.front(), false);</span>
<a href="#l12.47"></a><span id="l12.47"> end:</span>
<a href="#l12.48"></a><span id="l12.48" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l12.49"></a><span id="l12.49" class="difflineplus">+    delete key_store;</span>
<a href="#l12.50"></a><span id="l12.50">     src_close(&amp;memsrc);</span>
<a href="#l12.51"></a><span id="l12.51">     dst_close(&amp;memdst, true);</span>
<a href="#l12.52"></a><span id="l12.52">     list_destroy(&amp;key_ptrs);</span>
<a href="#l12.53"></a><span id="l12.53">     return ok;</span>
<a href="#l12.54"></a><span id="l12.54"> }</span>
<a href="#l12.55"></a><span id="l12.55"> </span>
<a href="#l12.56"></a><span id="l12.56"> static uint8_t</span>
<a href="#l12.57"></a><span id="l12.57"> pk_alg_default_flags(pgp_pubkey_alg_t alg)</span>
<a href="#l12.58"></a><span id="l12.58" class="difflineat">@@ -271,16 +272,17 @@ get_numbits(const rnp_keygen_crypto_para</span>
<a href="#l12.59"></a><span id="l12.59">             return curve-&gt;bitlen;</span>
<a href="#l12.60"></a><span id="l12.60">         } else {</span>
<a href="#l12.61"></a><span id="l12.61">             return 0;</span>
<a href="#l12.62"></a><span id="l12.62">         }</span>
<a href="#l12.63"></a><span id="l12.63">     }</span>
<a href="#l12.64"></a><span id="l12.64">     case PGP_PKA_DSA:</span>
<a href="#l12.65"></a><span id="l12.65">         return crypto-&gt;dsa.p_bitlen;</span>
<a href="#l12.66"></a><span id="l12.66">     case PGP_PKA_ELGAMAL:</span>
<a href="#l12.67"></a><span id="l12.67" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l12.68"></a><span id="l12.68">         return crypto-&gt;elgamal.key_bitlen;</span>
<a href="#l12.69"></a><span id="l12.69">     default:</span>
<a href="#l12.70"></a><span id="l12.70">         return 0;</span>
<a href="#l12.71"></a><span id="l12.71">     }</span>
<a href="#l12.72"></a><span id="l12.72"> }</span>
<a href="#l12.73"></a><span id="l12.73"> </span>
<a href="#l12.74"></a><span id="l12.74"> static bool</span>
<a href="#l12.75"></a><span id="l12.75"> set_default_user_prefs(pgp_user_prefs_t *prefs)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/third_party/rnp/src/lib/key-provider.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/third_party/rnp/src/lib/key-provider.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -40,17 +40,17 @@ rnp_key_matches_search(const pgp_key_t *</span>
<a href="#l13.4"></a><span id="l13.4">         return false;</span>
<a href="#l13.5"></a><span id="l13.5">     }</span>
<a href="#l13.6"></a><span id="l13.6">     switch (search-&gt;type) {</span>
<a href="#l13.7"></a><span id="l13.7">     case PGP_KEY_SEARCH_KEYID:</span>
<a href="#l13.8"></a><span id="l13.8">         return memcmp(pgp_key_get_keyid(key), search-&gt;by.keyid, PGP_KEY_ID_SIZE) == 0;</span>
<a href="#l13.9"></a><span id="l13.9">     case PGP_KEY_SEARCH_FINGERPRINT:</span>
<a href="#l13.10"></a><span id="l13.10">         return fingerprint_equal(pgp_key_get_fp(key), &amp;search-&gt;by.fingerprint);</span>
<a href="#l13.11"></a><span id="l13.11">     case PGP_KEY_SEARCH_GRIP:</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-        return !memcmp(pgp_key_get_grip(key), search-&gt;by.grip, PGP_KEY_GRIP_SIZE);</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+        return pgp_key_get_grip(key) == search-&gt;by.grip;</span>
<a href="#l13.14"></a><span id="l13.14">     case PGP_KEY_SEARCH_USERID:</span>
<a href="#l13.15"></a><span id="l13.15">         if (pgp_key_has_userid(key, search-&gt;by.userid)) {</span>
<a href="#l13.16"></a><span id="l13.16">             return true;</span>
<a href="#l13.17"></a><span id="l13.17">         }</span>
<a href="#l13.18"></a><span id="l13.18">         break;</span>
<a href="#l13.19"></a><span id="l13.19">     default:</span>
<a href="#l13.20"></a><span id="l13.20">         assert(false);</span>
<a href="#l13.21"></a><span id="l13.21">         break;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/third_party/rnp/src/lib/key-provider.h</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/third_party/rnp/src/lib/key-provider.h</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -38,17 +38,17 @@ typedef enum {</span>
<a href="#l14.4"></a><span id="l14.4">     PGP_KEY_SEARCH_GRIP,</span>
<a href="#l14.5"></a><span id="l14.5">     PGP_KEY_SEARCH_USERID</span>
<a href="#l14.6"></a><span id="l14.6"> } pgp_key_search_type_t;</span>
<a href="#l14.7"></a><span id="l14.7"> </span>
<a href="#l14.8"></a><span id="l14.8"> typedef struct pgp_key_search_t {</span>
<a href="#l14.9"></a><span id="l14.9">     pgp_key_search_type_t type;</span>
<a href="#l14.10"></a><span id="l14.10">     union {</span>
<a href="#l14.11"></a><span id="l14.11">         uint8_t           keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-        uint8_t           grip[PGP_KEY_GRIP_SIZE];</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+        pgp_key_grip_t    grip;</span>
<a href="#l14.14"></a><span id="l14.14">         pgp_fingerprint_t fingerprint;</span>
<a href="#l14.15"></a><span id="l14.15">         char              userid[MAX_ID_LENGTH + 1];</span>
<a href="#l14.16"></a><span id="l14.16">     } by;</span>
<a href="#l14.17"></a><span id="l14.17"> } pgp_key_search_t;</span>
<a href="#l14.18"></a><span id="l14.18"> </span>
<a href="#l14.19"></a><span id="l14.19"> typedef struct pgp_key_request_ctx_t {</span>
<a href="#l14.20"></a><span id="l14.20">     pgp_op_t         op;</span>
<a href="#l14.21"></a><span id="l14.21">     bool             secret;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/third_party/rnp/src/lib/misc.cpp</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/third_party/rnp/src/lib/misc.cpp</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -229,24 +229,51 @@ rnp_clear_debug()</span>
<a href="#l15.4"></a><span id="l15.4"> {</span>
<a href="#l15.5"></a><span id="l15.5">     for (int i = 0; i &lt; debugc; i++) {</span>
<a href="#l15.6"></a><span id="l15.6">         free(debugv[i]);</span>
<a href="#l15.7"></a><span id="l15.7">         debugv[i] = NULL;</span>
<a href="#l15.8"></a><span id="l15.8">     }</span>
<a href="#l15.9"></a><span id="l15.9">     debugc = 0;</span>
<a href="#l15.10"></a><span id="l15.10"> }</span>
<a href="#l15.11"></a><span id="l15.11"> </span>
<a href="#l15.12"></a><span id="l15.12" class="difflineplus">+/* -1 -- not initialized</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+    0 -- logging is off</span>
<a href="#l15.14"></a><span id="l15.14" class="difflineplus">+    1 -- logging is on</span>
<a href="#l15.15"></a><span id="l15.15" class="difflineplus">+*/</span>
<a href="#l15.16"></a><span id="l15.16" class="difflineplus">+int8_t _rnp_log_switch =</span>
<a href="#l15.17"></a><span id="l15.17" class="difflineplus">+#ifdef NDEBUG</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineplus">+  -1 // lazy-initialize later</span>
<a href="#l15.19"></a><span id="l15.19" class="difflineplus">+#else</span>
<a href="#l15.20"></a><span id="l15.20" class="difflineplus">+  1 // always on in debug build</span>
<a href="#l15.21"></a><span id="l15.21" class="difflineplus">+#endif</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineplus">+  ;</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineplus">+</span>
<a href="#l15.24"></a><span id="l15.24" class="difflineplus">+void</span>
<a href="#l15.25"></a><span id="l15.25" class="difflineplus">+set_rnp_log_switch(int8_t value)</span>
<a href="#l15.26"></a><span id="l15.26" class="difflineplus">+{</span>
<a href="#l15.27"></a><span id="l15.27" class="difflineplus">+    _rnp_log_switch = value;</span>
<a href="#l15.28"></a><span id="l15.28" class="difflineplus">+}</span>
<a href="#l15.29"></a><span id="l15.29" class="difflineplus">+</span>
<a href="#l15.30"></a><span id="l15.30" class="difflineplus">+bool</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineplus">+rnp_log_switch()</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+{</span>
<a href="#l15.33"></a><span id="l15.33" class="difflineplus">+    if (_rnp_log_switch &lt; 0) {</span>
<a href="#l15.34"></a><span id="l15.34" class="difflineplus">+        const char *var = getenv(RNP_LOG_CONSOLE);</span>
<a href="#l15.35"></a><span id="l15.35" class="difflineplus">+        _rnp_log_switch = (var &amp;&amp; strcmp(var, &quot;0&quot;)) ? 1 : 0;</span>
<a href="#l15.36"></a><span id="l15.36" class="difflineplus">+    }</span>
<a href="#l15.37"></a><span id="l15.37" class="difflineplus">+    return !!_rnp_log_switch;</span>
<a href="#l15.38"></a><span id="l15.38" class="difflineplus">+}</span>
<a href="#l15.39"></a><span id="l15.39" class="difflineplus">+</span>
<a href="#l15.40"></a><span id="l15.40"> /* portable replacement for strcasecmp(3) */</span>
<a href="#l15.41"></a><span id="l15.41"> int</span>
<a href="#l15.42"></a><span id="l15.42"> rnp_strcasecmp(const char *s1, const char *s2)</span>
<a href="#l15.43"></a><span id="l15.43"> {</span>
<a href="#l15.44"></a><span id="l15.44">     int n;</span>
<a href="#l15.45"></a><span id="l15.45"> </span>
<a href="#l15.46"></a><span id="l15.46" class="difflineminus">-    for (n = 0; (n = tolower((uint8_t) *s1) - tolower((uint8_t) *s2)) == 0 &amp;&amp; *s1;</span>
<a href="#l15.47"></a><span id="l15.47" class="difflineminus">-         s1++, s2++) {</span>
<a href="#l15.48"></a><span id="l15.48" class="difflineplus">+    for (; (n = tolower((uint8_t) *s1) - tolower((uint8_t) *s2)) == 0 &amp;&amp; *s1; s1++, s2++) {</span>
<a href="#l15.49"></a><span id="l15.49">     }</span>
<a href="#l15.50"></a><span id="l15.50">     return n;</span>
<a href="#l15.51"></a><span id="l15.51"> }</span>
<a href="#l15.52"></a><span id="l15.52"> </span>
<a href="#l15.53"></a><span id="l15.53"> /* return the hexdump as a string */</span>
<a href="#l15.54"></a><span id="l15.54"> char *</span>
<a href="#l15.55"></a><span id="l15.55"> rnp_strhexdump_upper(char *dest, const uint8_t *src, size_t length, const char *sep)</span>
<a href="#l15.56"></a><span id="l15.56"> {</span>
<a href="#l15.57"></a><span id="l15.57" class="difflineat">@@ -418,17 +445,24 @@ rnp_hex_encode(</span>
<a href="#l15.58"></a><span id="l15.58">     }</span>
<a href="#l15.59"></a><span id="l15.59">     hex[buf_len * 2] = '\0';</span>
<a href="#l15.60"></a><span id="l15.60">     return botan_hex_encode(buf, buf_len, hex, flags) == 0;</span>
<a href="#l15.61"></a><span id="l15.61"> }</span>
<a href="#l15.62"></a><span id="l15.62"> </span>
<a href="#l15.63"></a><span id="l15.63"> size_t</span>
<a href="#l15.64"></a><span id="l15.64"> rnp_hex_decode(const char *hex, uint8_t *buf, size_t buf_len)</span>
<a href="#l15.65"></a><span id="l15.65"> {</span>
<a href="#l15.66"></a><span id="l15.66" class="difflineminus">-    if (botan_hex_decode(hex, strlen(hex), buf, &amp;buf_len) != 0) {</span>
<a href="#l15.67"></a><span id="l15.67" class="difflineplus">+    size_t hexlen = strlen(hex);</span>
<a href="#l15.68"></a><span id="l15.68" class="difflineplus">+</span>
<a href="#l15.69"></a><span id="l15.69" class="difflineplus">+    /* check for 0x prefix */</span>
<a href="#l15.70"></a><span id="l15.70" class="difflineplus">+    if ((hexlen &gt;= 2) &amp;&amp; (hex[0] == '0') &amp;&amp; ((hex[1] == 'x') || (hex[1] == 'X'))) {</span>
<a href="#l15.71"></a><span id="l15.71" class="difflineplus">+        hex += 2;</span>
<a href="#l15.72"></a><span id="l15.72" class="difflineplus">+        hexlen -= 2;</span>
<a href="#l15.73"></a><span id="l15.73" class="difflineplus">+    }</span>
<a href="#l15.74"></a><span id="l15.74" class="difflineplus">+    if (botan_hex_decode(hex, hexlen, buf, &amp;buf_len) != 0) {</span>
<a href="#l15.75"></a><span id="l15.75">         RNP_LOG(&quot;Hex decode failed on string: %s&quot;, hex);</span>
<a href="#l15.76"></a><span id="l15.76">         return 0;</span>
<a href="#l15.77"></a><span id="l15.77">     }</span>
<a href="#l15.78"></a><span id="l15.78">     return buf_len;</span>
<a href="#l15.79"></a><span id="l15.79"> }</span>
<a href="#l15.80"></a><span id="l15.80"> </span>
<a href="#l15.81"></a><span id="l15.81"> char *</span>
<a href="#l15.82"></a><span id="l15.82"> rnp_strlwr(char *s)</span>
<a href="#l15.83"></a><span id="l15.83" class="difflineat">@@ -452,60 +486,18 @@ rnp_strip_eol(char *s)</span>
<a href="#l15.84"></a><span id="l15.84"> </span>
<a href="#l15.85"></a><span id="l15.85">     return s;</span>
<a href="#l15.86"></a><span id="l15.86"> }</span>
<a href="#l15.87"></a><span id="l15.87"> </span>
<a href="#l15.88"></a><span id="l15.88"> /* convert hex string, probably prefixes with 0x, to binary form */</span>
<a href="#l15.89"></a><span id="l15.89"> bool</span>
<a href="#l15.90"></a><span id="l15.90"> hex2bin(const char *hex, size_t hexlen, uint8_t *bin, size_t len, size_t *out)</span>
<a href="#l15.91"></a><span id="l15.91"> {</span>
<a href="#l15.92"></a><span id="l15.92" class="difflineminus">-    bool    haslow = false;</span>
<a href="#l15.93"></a><span id="l15.93" class="difflineminus">-    uint8_t low = 0;</span>
<a href="#l15.94"></a><span id="l15.94" class="difflineminus">-    size_t  binlen = 0;</span>
<a href="#l15.95"></a><span id="l15.95" class="difflineminus">-</span>
<a href="#l15.96"></a><span id="l15.96" class="difflineminus">-    *out = 0;</span>
<a href="#l15.97"></a><span id="l15.97" class="difflineminus">-    if (hexlen &lt; 1) {</span>
<a href="#l15.98"></a><span id="l15.98" class="difflineminus">-        return false;</span>
<a href="#l15.99"></a><span id="l15.99" class="difflineminus">-    }</span>
<a href="#l15.100"></a><span id="l15.100" class="difflineminus">-</span>
<a href="#l15.101"></a><span id="l15.101" class="difflineminus">-    /* check for 0x prefix */</span>
<a href="#l15.102"></a><span id="l15.102" class="difflineminus">-    if ((hexlen &gt;= 2) &amp;&amp; (hex[0] == '0') &amp;&amp; ((hex[1] == 'x') || (hex[1] == 'X'))) {</span>
<a href="#l15.103"></a><span id="l15.103" class="difflineminus">-        hex += 2;</span>
<a href="#l15.104"></a><span id="l15.104" class="difflineminus">-        hexlen -= 2;</span>
<a href="#l15.105"></a><span id="l15.105" class="difflineminus">-    }</span>
<a href="#l15.106"></a><span id="l15.106" class="difflineminus">-</span>
<a href="#l15.107"></a><span id="l15.107" class="difflineminus">-    haslow = hexlen % 2;</span>
<a href="#l15.108"></a><span id="l15.108" class="difflineminus">-    for (size_t i = 0; i &lt; hexlen; i++) {</span>
<a href="#l15.109"></a><span id="l15.109" class="difflineminus">-        if ((hex[i] == ' ') || (hex[i] == '\t')) {</span>
<a href="#l15.110"></a><span id="l15.110" class="difflineminus">-            continue;</span>
<a href="#l15.111"></a><span id="l15.111" class="difflineminus">-        }</span>
<a href="#l15.112"></a><span id="l15.112" class="difflineminus">-</span>
<a href="#l15.113"></a><span id="l15.113" class="difflineminus">-        if ((hex[i] &gt;= '0') &amp;&amp; (hex[i] &lt;= '9')) {</span>
<a href="#l15.114"></a><span id="l15.114" class="difflineminus">-            low = (low &lt;&lt; 4) | (hex[i] - '0');</span>
<a href="#l15.115"></a><span id="l15.115" class="difflineminus">-        } else if ((hex[i] &gt;= 'a') &amp;&amp; (hex[i] &lt;= 'f')) {</span>
<a href="#l15.116"></a><span id="l15.116" class="difflineminus">-            low = (low &lt;&lt; 4) | (hex[i] - ('a' - 10));</span>
<a href="#l15.117"></a><span id="l15.117" class="difflineminus">-        } else if ((hex[i] &gt;= 'A') &amp;&amp; (hex[i] &lt;= 'F')) {</span>
<a href="#l15.118"></a><span id="l15.118" class="difflineminus">-            low = (low &lt;&lt; 4) | (hex[i] - ('A' - 10));</span>
<a href="#l15.119"></a><span id="l15.119" class="difflineminus">-        } else {</span>
<a href="#l15.120"></a><span id="l15.120" class="difflineminus">-            return false;</span>
<a href="#l15.121"></a><span id="l15.121" class="difflineminus">-        }</span>
<a href="#l15.122"></a><span id="l15.122" class="difflineminus">-</span>
<a href="#l15.123"></a><span id="l15.123" class="difflineminus">-        /* we had low bits before - so have the whole byte now */</span>
<a href="#l15.124"></a><span id="l15.124" class="difflineminus">-        if (haslow) {</span>
<a href="#l15.125"></a><span id="l15.125" class="difflineminus">-            if (binlen &lt; len) {</span>
<a href="#l15.126"></a><span id="l15.126" class="difflineminus">-                bin[binlen] = low;</span>
<a href="#l15.127"></a><span id="l15.127" class="difflineminus">-            }</span>
<a href="#l15.128"></a><span id="l15.128" class="difflineminus">-            binlen++;</span>
<a href="#l15.129"></a><span id="l15.129" class="difflineminus">-            low = 0;</span>
<a href="#l15.130"></a><span id="l15.130" class="difflineminus">-        }</span>
<a href="#l15.131"></a><span id="l15.131" class="difflineminus">-        haslow = !haslow;</span>
<a href="#l15.132"></a><span id="l15.132" class="difflineminus">-    }</span>
<a href="#l15.133"></a><span id="l15.133" class="difflineminus">-</span>
<a href="#l15.134"></a><span id="l15.134" class="difflineminus">-    *out = binlen;</span>
<a href="#l15.135"></a><span id="l15.135" class="difflineminus">-    return true;</span>
<a href="#l15.136"></a><span id="l15.136" class="difflineplus">+    *out = rnp_hex_decode(hex, bin, len);</span>
<a href="#l15.137"></a><span id="l15.137" class="difflineplus">+    return *out != 0;</span>
<a href="#l15.138"></a><span id="l15.138"> }</span>
<a href="#l15.139"></a><span id="l15.139"> </span>
<a href="#l15.140"></a><span id="l15.140"> /* Shortcut function to add field checking it for null to avoid allocation failure.</span>
<a href="#l15.141"></a><span id="l15.141">    Please note that it deallocates val on failure. */</span>
<a href="#l15.142"></a><span id="l15.142"> bool</span>
<a href="#l15.143"></a><span id="l15.143"> obj_add_field_json(json_object *obj, const char *name, json_object *val)</span>
<a href="#l15.144"></a><span id="l15.144"> {</span>
<a href="#l15.145"></a><span id="l15.145">     if (!val) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/third_party/rnp/src/lib/pgp-key.cpp</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/third_party/rnp/src/lib/pgp-key.cpp</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -63,16 +63,17 @@</span>
<a href="#l16.4"></a><span id="l16.4"> #include &lt;librepgp/stream-sig.h&gt;</span>
<a href="#l16.5"></a><span id="l16.5"> #include &lt;librepgp/stream-armor.h&gt;</span>
<a href="#l16.6"></a><span id="l16.6"> </span>
<a href="#l16.7"></a><span id="l16.7"> #include &lt;stdio.h&gt;</span>
<a href="#l16.8"></a><span id="l16.8"> #include &lt;string.h&gt;</span>
<a href="#l16.9"></a><span id="l16.9"> #include &lt;stdlib.h&gt;</span>
<a href="#l16.10"></a><span id="l16.10"> #include &lt;assert.h&gt;</span>
<a href="#l16.11"></a><span id="l16.11"> #include &lt;time.h&gt;</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineplus">+#include &lt;algorithm&gt;</span>
<a href="#l16.13"></a><span id="l16.13"> #include &quot;defaults.h&quot;</span>
<a href="#l16.14"></a><span id="l16.14"> </span>
<a href="#l16.15"></a><span id="l16.15"> static bool</span>
<a href="#l16.16"></a><span id="l16.16"> pgp_user_prefs_set_arr(uint8_t **arr, size_t *arrlen, const uint8_t *val, size_t len)</span>
<a href="#l16.17"></a><span id="l16.17"> {</span>
<a href="#l16.18"></a><span id="l16.18">     uint8_t *newarr = (uint8_t *) malloc(len);</span>
<a href="#l16.19"></a><span id="l16.19"> </span>
<a href="#l16.20"></a><span id="l16.20">     if (len &amp;&amp; !newarr) {</span>
<a href="#l16.21"></a><span id="l16.21" class="difflineat">@@ -164,50 +165,16 @@ pgp_free_user_prefs(pgp_user_prefs_t *pr</span>
<a href="#l16.22"></a><span id="l16.22">     free(prefs-&gt;symm_algs);</span>
<a href="#l16.23"></a><span id="l16.23">     free(prefs-&gt;hash_algs);</span>
<a href="#l16.24"></a><span id="l16.24">     free(prefs-&gt;z_algs);</span>
<a href="#l16.25"></a><span id="l16.25">     free(prefs-&gt;ks_prefs);</span>
<a href="#l16.26"></a><span id="l16.26">     free(prefs-&gt;key_server);</span>
<a href="#l16.27"></a><span id="l16.27">     memset(prefs, 0, sizeof(*prefs));</span>
<a href="#l16.28"></a><span id="l16.28"> }</span>
<a href="#l16.29"></a><span id="l16.29"> </span>
<a href="#l16.30"></a><span id="l16.30" class="difflineminus">-void</span>
<a href="#l16.31"></a><span id="l16.31" class="difflineminus">-pgp_subsig_free(pgp_subsig_t *subsig)</span>
<a href="#l16.32"></a><span id="l16.32" class="difflineminus">-{</span>
<a href="#l16.33"></a><span id="l16.33" class="difflineminus">-    if (!subsig) {</span>
<a href="#l16.34"></a><span id="l16.34" class="difflineminus">-        return;</span>
<a href="#l16.35"></a><span id="l16.35" class="difflineminus">-    }</span>
<a href="#l16.36"></a><span id="l16.36" class="difflineminus">-    pgp_free_user_prefs(&amp;subsig-&gt;prefs);</span>
<a href="#l16.37"></a><span id="l16.37" class="difflineminus">-    free_signature(&amp;subsig-&gt;sig);</span>
<a href="#l16.38"></a><span id="l16.38" class="difflineminus">-}</span>
<a href="#l16.39"></a><span id="l16.39" class="difflineminus">-</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineminus">-void</span>
<a href="#l16.41"></a><span id="l16.41" class="difflineminus">-revoke_free(pgp_revoke_t *revoke)</span>
<a href="#l16.42"></a><span id="l16.42" class="difflineminus">-{</span>
<a href="#l16.43"></a><span id="l16.43" class="difflineminus">-    if (!revoke) {</span>
<a href="#l16.44"></a><span id="l16.44" class="difflineminus">-        return;</span>
<a href="#l16.45"></a><span id="l16.45" class="difflineminus">-    }</span>
<a href="#l16.46"></a><span id="l16.46" class="difflineminus">-    free(revoke-&gt;reason);</span>
<a href="#l16.47"></a><span id="l16.47" class="difflineminus">-    revoke-&gt;reason = NULL;</span>
<a href="#l16.48"></a><span id="l16.48" class="difflineminus">-}</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineminus">-</span>
<a href="#l16.50"></a><span id="l16.50" class="difflineminus">-static void</span>
<a href="#l16.51"></a><span id="l16.51" class="difflineminus">-pgp_userid_free(pgp_userid_t *uid)</span>
<a href="#l16.52"></a><span id="l16.52" class="difflineminus">-{</span>
<a href="#l16.53"></a><span id="l16.53" class="difflineminus">-    free_userid_pkt(&amp;uid-&gt;pkt);</span>
<a href="#l16.54"></a><span id="l16.54" class="difflineminus">-    free(uid-&gt;str);</span>
<a href="#l16.55"></a><span id="l16.55" class="difflineminus">-}</span>
<a href="#l16.56"></a><span id="l16.56" class="difflineminus">-</span>
<a href="#l16.57"></a><span id="l16.57" class="difflineminus">-static void</span>
<a href="#l16.58"></a><span id="l16.58" class="difflineminus">-pgp_rawpacket_free(pgp_rawpacket_t *packet)</span>
<a href="#l16.59"></a><span id="l16.59" class="difflineminus">-{</span>
<a href="#l16.60"></a><span id="l16.60" class="difflineminus">-    free(packet-&gt;raw);</span>
<a href="#l16.61"></a><span id="l16.61" class="difflineminus">-    packet-&gt;raw = NULL;</span>
<a href="#l16.62"></a><span id="l16.62" class="difflineminus">-}</span>
<a href="#l16.63"></a><span id="l16.63" class="difflineminus">-</span>
<a href="#l16.64"></a><span id="l16.64"> static bool</span>
<a href="#l16.65"></a><span id="l16.65"> pgp_key_init_with_pkt(pgp_key_t *key, const pgp_key_pkt_t *pkt)</span>
<a href="#l16.66"></a><span id="l16.66"> {</span>
<a href="#l16.67"></a><span id="l16.67">     assert(!key-&gt;pkt.version);</span>
<a href="#l16.68"></a><span id="l16.68">     assert(is_key_pkt(pkt-&gt;tag));</span>
<a href="#l16.69"></a><span id="l16.69">     assert(pkt-&gt;material.alg);</span>
<a href="#l16.70"></a><span id="l16.70">     if (pgp_keyid(key-&gt;keyid, PGP_KEY_ID_SIZE, pkt) ||</span>
<a href="#l16.71"></a><span id="l16.71">         pgp_fingerprint(&amp;key-&gt;fingerprint, pkt) ||</span>
<a href="#l16.72"></a><span id="l16.72" class="difflineat">@@ -243,60 +210,33 @@ pgp_key_from_pkt(pgp_key_t *key, const p</span>
<a href="#l16.73"></a><span id="l16.73">     /* this call transfers ownership */</span>
<a href="#l16.74"></a><span id="l16.74">     if (!pgp_key_init_with_pkt(key, &amp;keypkt)) {</span>
<a href="#l16.75"></a><span id="l16.75">         RNP_LOG(&quot;failed to setup key fields&quot;);</span>
<a href="#l16.76"></a><span id="l16.76">         free_key_pkt(&amp;keypkt);</span>
<a href="#l16.77"></a><span id="l16.77">         return false;</span>
<a href="#l16.78"></a><span id="l16.78">     }</span>
<a href="#l16.79"></a><span id="l16.79"> </span>
<a href="#l16.80"></a><span id="l16.80">     /* add key rawpacket */</span>
<a href="#l16.81"></a><span id="l16.81" class="difflineminus">-    if (!pgp_key_add_key_rawpacket(key, &amp;key-&gt;pkt)) {</span>
<a href="#l16.82"></a><span id="l16.82" class="difflineplus">+    try {</span>
<a href="#l16.83"></a><span id="l16.83" class="difflineplus">+        key-&gt;rawpkt = pgp_rawpacket_t(key-&gt;pkt);</span>
<a href="#l16.84"></a><span id="l16.84" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.85"></a><span id="l16.85" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.86"></a><span id="l16.86">         free_key_pkt(&amp;keypkt);</span>
<a href="#l16.87"></a><span id="l16.87">         return false;</span>
<a href="#l16.88"></a><span id="l16.88">     }</span>
<a href="#l16.89"></a><span id="l16.89" class="difflineminus">-</span>
<a href="#l16.90"></a><span id="l16.90">     key-&gt;format = PGP_KEY_STORE_GPG;</span>
<a href="#l16.91"></a><span id="l16.91">     return true;</span>
<a href="#l16.92"></a><span id="l16.92"> }</span>
<a href="#l16.93"></a><span id="l16.93"> </span>
<a href="#l16.94"></a><span id="l16.94"> static void</span>
<a href="#l16.95"></a><span id="l16.95"> pgp_key_clear_revokes(pgp_key_t *key)</span>
<a href="#l16.96"></a><span id="l16.96"> {</span>
<a href="#l16.97"></a><span id="l16.97">     key-&gt;revoked = false;</span>
<a href="#l16.98"></a><span id="l16.98" class="difflineminus">-    for (size_t i = 0; i &lt; pgp_key_get_revoke_count(key); i++) {</span>
<a href="#l16.99"></a><span id="l16.99" class="difflineminus">-        revoke_free(pgp_key_get_revoke(key, i));</span>
<a href="#l16.100"></a><span id="l16.100" class="difflineminus">-    }</span>
<a href="#l16.101"></a><span id="l16.101">     key-&gt;revokes.clear();</span>
<a href="#l16.102"></a><span id="l16.102" class="difflineminus">-    revoke_free(&amp;key-&gt;revocation);</span>
<a href="#l16.103"></a><span id="l16.103" class="difflineminus">-    memset(&amp;key-&gt;revocation, 0, sizeof(key-&gt;revocation));</span>
<a href="#l16.104"></a><span id="l16.104" class="difflineminus">-}</span>
<a href="#l16.105"></a><span id="l16.105" class="difflineminus">-</span>
<a href="#l16.106"></a><span id="l16.106" class="difflineminus">-/**</span>
<a href="#l16.107"></a><span id="l16.107" class="difflineminus">- * @brief Copy key's raw packets. If pubonly is true then dst-&gt;pkt must be populated</span>
<a href="#l16.108"></a><span id="l16.108" class="difflineminus">- */</span>
<a href="#l16.109"></a><span id="l16.109" class="difflineminus">-static rnp_result_t</span>
<a href="#l16.110"></a><span id="l16.110" class="difflineminus">-pgp_key_copy_raw_packets(pgp_key_t *dst, const pgp_key_t *src, bool pubonly)</span>
<a href="#l16.111"></a><span id="l16.111" class="difflineminus">-{</span>
<a href="#l16.112"></a><span id="l16.112" class="difflineminus">-    size_t start = 0;</span>
<a href="#l16.113"></a><span id="l16.113" class="difflineminus">-</span>
<a href="#l16.114"></a><span id="l16.114" class="difflineminus">-    if (pubonly) {</span>
<a href="#l16.115"></a><span id="l16.115" class="difflineminus">-        if (!pgp_key_add_key_rawpacket(dst, &amp;dst-&gt;pkt)) {</span>
<a href="#l16.116"></a><span id="l16.116" class="difflineminus">-            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.117"></a><span id="l16.117" class="difflineminus">-        }</span>
<a href="#l16.118"></a><span id="l16.118" class="difflineminus">-        start = 1;</span>
<a href="#l16.119"></a><span id="l16.119" class="difflineminus">-    }</span>
<a href="#l16.120"></a><span id="l16.120" class="difflineminus">-</span>
<a href="#l16.121"></a><span id="l16.121" class="difflineminus">-    for (size_t i = start; i &lt; pgp_key_get_rawpacket_count(src); i++) {</span>
<a href="#l16.122"></a><span id="l16.122" class="difflineminus">-        const pgp_rawpacket_t *pkt = pgp_key_get_rawpacket(src, i);</span>
<a href="#l16.123"></a><span id="l16.123" class="difflineminus">-        if (!pgp_key_add_rawpacket(dst, pkt-&gt;raw, pkt-&gt;length, pkt-&gt;tag)) {</span>
<a href="#l16.124"></a><span id="l16.124" class="difflineminus">-            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.125"></a><span id="l16.125" class="difflineminus">-        }</span>
<a href="#l16.126"></a><span id="l16.126" class="difflineminus">-    }</span>
<a href="#l16.127"></a><span id="l16.127" class="difflineminus">-</span>
<a href="#l16.128"></a><span id="l16.128" class="difflineminus">-    return RNP_SUCCESS;</span>
<a href="#l16.129"></a><span id="l16.129" class="difflineplus">+    key-&gt;revocation = {};</span>
<a href="#l16.130"></a><span id="l16.130"> }</span>
<a href="#l16.131"></a><span id="l16.131"> </span>
<a href="#l16.132"></a><span id="l16.132"> static rnp_result_t</span>
<a href="#l16.133"></a><span id="l16.133"> pgp_key_copy_g10(pgp_key_t *dst, const pgp_key_t *src, bool pubonly)</span>
<a href="#l16.134"></a><span id="l16.134"> {</span>
<a href="#l16.135"></a><span id="l16.135">     if (pubonly) {</span>
<a href="#l16.136"></a><span id="l16.136">         RNP_LOG(&quot;attempt to copy public part from g10 key&quot;);</span>
<a href="#l16.137"></a><span id="l16.137">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l16.138"></a><span id="l16.138" class="difflineat">@@ -313,18 +253,20 @@ pgp_key_copy_g10(pgp_key_t *dst, const p</span>
<a href="#l16.139"></a><span id="l16.139">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l16.140"></a><span id="l16.140">     }</span>
<a href="#l16.141"></a><span id="l16.141"> </span>
<a href="#l16.142"></a><span id="l16.142">     if (pgp_key_copy_fields(dst, src)) {</span>
<a href="#l16.143"></a><span id="l16.143">         RNP_LOG(&quot;failed to copy key fields&quot;);</span>
<a href="#l16.144"></a><span id="l16.144">         return RNP_ERROR_GENERIC;</span>
<a href="#l16.145"></a><span id="l16.145">     }</span>
<a href="#l16.146"></a><span id="l16.146"> </span>
<a href="#l16.147"></a><span id="l16.147" class="difflineminus">-    if (pgp_key_copy_raw_packets(dst, src, false)) {</span>
<a href="#l16.148"></a><span id="l16.148" class="difflineminus">-        RNP_LOG(&quot;failed to copy raw packets&quot;);</span>
<a href="#l16.149"></a><span id="l16.149" class="difflineplus">+    try {</span>
<a href="#l16.150"></a><span id="l16.150" class="difflineplus">+        dst-&gt;rawpkt = src-&gt;rawpkt;</span>
<a href="#l16.151"></a><span id="l16.151" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.152"></a><span id="l16.152" class="difflineplus">+        RNP_LOG(&quot;failed to copy raw packet: %s&quot;, e.what());</span>
<a href="#l16.153"></a><span id="l16.153">         return RNP_ERROR_GENERIC;</span>
<a href="#l16.154"></a><span id="l16.154">     }</span>
<a href="#l16.155"></a><span id="l16.155"> </span>
<a href="#l16.156"></a><span id="l16.156">     dst-&gt;format = PGP_KEY_STORE_G10;</span>
<a href="#l16.157"></a><span id="l16.157">     return RNP_SUCCESS;</span>
<a href="#l16.158"></a><span id="l16.158"> }</span>
<a href="#l16.159"></a><span id="l16.159"> </span>
<a href="#l16.160"></a><span id="l16.160"> rnp_result_t</span>
<a href="#l16.161"></a><span id="l16.161" class="difflineat">@@ -334,25 +276,24 @@ pgp_key_copy(pgp_key_t *dst, const pgp_k</span>
<a href="#l16.162"></a><span id="l16.162">         return pgp_key_copy_g10(dst, src, pubonly);</span>
<a href="#l16.163"></a><span id="l16.163">     }</span>
<a href="#l16.164"></a><span id="l16.164"> </span>
<a href="#l16.165"></a><span id="l16.165">     *dst = {};</span>
<a href="#l16.166"></a><span id="l16.166">     if (!copy_key_pkt(&amp;dst-&gt;pkt, &amp;src-&gt;pkt, pubonly)) {</span>
<a href="#l16.167"></a><span id="l16.167">         RNP_LOG(&quot;failed to copy key pkt&quot;);</span>
<a href="#l16.168"></a><span id="l16.168">         return RNP_ERROR_GENERIC;</span>
<a href="#l16.169"></a><span id="l16.169">     }</span>
<a href="#l16.170"></a><span id="l16.170" class="difflineminus">-</span>
<a href="#l16.171"></a><span id="l16.171" class="difflineminus">-    rnp_result_t ret;</span>
<a href="#l16.172"></a><span id="l16.172" class="difflineminus">-    if ((ret = pgp_key_copy_fields(dst, src))) {</span>
<a href="#l16.173"></a><span id="l16.173" class="difflineminus">-        return ret;</span>
<a href="#l16.174"></a><span id="l16.174" class="difflineplus">+    try {</span>
<a href="#l16.175"></a><span id="l16.175" class="difflineplus">+        dst-&gt;rawpkt = pubonly ? pgp_rawpacket_t(dst-&gt;pkt) : src-&gt;rawpkt;</span>
<a href="#l16.176"></a><span id="l16.176" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.177"></a><span id="l16.177" class="difflineplus">+        RNP_LOG(&quot;failed to copy key rawpkt: %s&quot;, e.what());</span>
<a href="#l16.178"></a><span id="l16.178" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.179"></a><span id="l16.179">     }</span>
<a href="#l16.180"></a><span id="l16.180" class="difflineminus">-    if ((ret = pgp_key_copy_raw_packets(dst, src, pubonly))) {</span>
<a href="#l16.181"></a><span id="l16.181" class="difflineminus">-        return ret;</span>
<a href="#l16.182"></a><span id="l16.182" class="difflineminus">-    }</span>
<a href="#l16.183"></a><span id="l16.183" class="difflineminus">-    return RNP_SUCCESS;</span>
<a href="#l16.184"></a><span id="l16.184" class="difflineplus">+</span>
<a href="#l16.185"></a><span id="l16.185" class="difflineplus">+    return pgp_key_copy_fields(dst, src);</span>
<a href="#l16.186"></a><span id="l16.186"> }</span>
<a href="#l16.187"></a><span id="l16.187"> </span>
<a href="#l16.188"></a><span id="l16.188"> static rnp_result_t</span>
<a href="#l16.189"></a><span id="l16.189"> pgp_userprefs_copy(pgp_user_prefs_t *dst, const pgp_user_prefs_t *src)</span>
<a href="#l16.190"></a><span id="l16.190"> {</span>
<a href="#l16.191"></a><span id="l16.191">     rnp_result_t ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.192"></a><span id="l16.192"> </span>
<a href="#l16.193"></a><span id="l16.193">     memset(dst, 0, sizeof(*dst));</span>
<a href="#l16.194"></a><span id="l16.194" class="difflineat">@@ -385,139 +326,95 @@ pgp_userprefs_copy(pgp_user_prefs_t *dst</span>
<a href="#l16.195"></a><span id="l16.195">     }</span>
<a href="#l16.196"></a><span id="l16.196"> </span>
<a href="#l16.197"></a><span id="l16.197">     return RNP_SUCCESS;</span>
<a href="#l16.198"></a><span id="l16.198"> error:</span>
<a href="#l16.199"></a><span id="l16.199">     pgp_free_user_prefs(dst);</span>
<a href="#l16.200"></a><span id="l16.200">     return ret;</span>
<a href="#l16.201"></a><span id="l16.201"> }</span>
<a href="#l16.202"></a><span id="l16.202"> </span>
<a href="#l16.203"></a><span id="l16.203" class="difflineminus">-static rnp_result_t</span>
<a href="#l16.204"></a><span id="l16.204" class="difflineminus">-pgp_subsig_copy(pgp_subsig_t *dst, const pgp_subsig_t *src)</span>
<a href="#l16.205"></a><span id="l16.205" class="difflineminus">-{</span>
<a href="#l16.206"></a><span id="l16.206" class="difflineminus">-    memcpy(dst, src, sizeof(*dst));</span>
<a href="#l16.207"></a><span id="l16.207" class="difflineminus">-    /* signature packet */</span>
<a href="#l16.208"></a><span id="l16.208" class="difflineminus">-    if (!copy_signature_packet(&amp;dst-&gt;sig, &amp;src-&gt;sig)) {</span>
<a href="#l16.209"></a><span id="l16.209" class="difflineminus">-        memset(dst, 0, sizeof(*dst));</span>
<a href="#l16.210"></a><span id="l16.210" class="difflineminus">-        return RNP_ERROR_GENERIC;</span>
<a href="#l16.211"></a><span id="l16.211" class="difflineminus">-    }</span>
<a href="#l16.212"></a><span id="l16.212" class="difflineminus">-    /* user prefs */</span>
<a href="#l16.213"></a><span id="l16.213" class="difflineminus">-    if (pgp_userprefs_copy(&amp;dst-&gt;prefs, &amp;src-&gt;prefs)) {</span>
<a href="#l16.214"></a><span id="l16.214" class="difflineminus">-        free_signature(&amp;dst-&gt;sig);</span>
<a href="#l16.215"></a><span id="l16.215" class="difflineminus">-        memset(dst, 0, sizeof(*dst));</span>
<a href="#l16.216"></a><span id="l16.216" class="difflineminus">-        return RNP_ERROR_GENERIC;</span>
<a href="#l16.217"></a><span id="l16.217" class="difflineminus">-    }</span>
<a href="#l16.218"></a><span id="l16.218" class="difflineminus">-</span>
<a href="#l16.219"></a><span id="l16.219" class="difflineminus">-    return RNP_SUCCESS;</span>
<a href="#l16.220"></a><span id="l16.220" class="difflineminus">-}</span>
<a href="#l16.221"></a><span id="l16.221" class="difflineminus">-</span>
<a href="#l16.222"></a><span id="l16.222" class="difflineminus">-static rnp_result_t</span>
<a href="#l16.223"></a><span id="l16.223" class="difflineminus">-pgp_revoke_copy(pgp_revoke_t *dst, const pgp_revoke_t *src)</span>
<a href="#l16.224"></a><span id="l16.224" class="difflineminus">-{</span>
<a href="#l16.225"></a><span id="l16.225" class="difflineminus">-    memcpy(dst, src, sizeof(*dst));</span>
<a href="#l16.226"></a><span id="l16.226" class="difflineminus">-    if (src-&gt;reason) {</span>
<a href="#l16.227"></a><span id="l16.227" class="difflineminus">-        size_t len = strlen(src-&gt;reason) + 1;</span>
<a href="#l16.228"></a><span id="l16.228" class="difflineminus">-        dst-&gt;reason = (char *) malloc(len);</span>
<a href="#l16.229"></a><span id="l16.229" class="difflineminus">-        if (!dst-&gt;reason) {</span>
<a href="#l16.230"></a><span id="l16.230" class="difflineminus">-            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.231"></a><span id="l16.231" class="difflineminus">-        }</span>
<a href="#l16.232"></a><span id="l16.232" class="difflineminus">-        memcpy(dst-&gt;reason, src-&gt;reason, len);</span>
<a href="#l16.233"></a><span id="l16.233" class="difflineminus">-    }</span>
<a href="#l16.234"></a><span id="l16.234" class="difflineminus">-    return RNP_SUCCESS;</span>
<a href="#l16.235"></a><span id="l16.235" class="difflineminus">-}</span>
<a href="#l16.236"></a><span id="l16.236" class="difflineminus">-</span>
<a href="#l16.237"></a><span id="l16.237" class="difflineminus">-static rnp_result_t</span>
<a href="#l16.238"></a><span id="l16.238" class="difflineminus">-pgp_userid_copy(pgp_userid_t *dst, const pgp_userid_t *src)</span>
<a href="#l16.239"></a><span id="l16.239" class="difflineminus">-{</span>
<a href="#l16.240"></a><span id="l16.240" class="difflineminus">-    memset(dst, 0, sizeof(*dst));</span>
<a href="#l16.241"></a><span id="l16.241" class="difflineminus">-    if (src-&gt;str) {</span>
<a href="#l16.242"></a><span id="l16.242" class="difflineminus">-        dst-&gt;str = strdup(src-&gt;str);</span>
<a href="#l16.243"></a><span id="l16.243" class="difflineminus">-        if (!dst-&gt;str) {</span>
<a href="#l16.244"></a><span id="l16.244" class="difflineminus">-            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.245"></a><span id="l16.245" class="difflineminus">-        }</span>
<a href="#l16.246"></a><span id="l16.246" class="difflineminus">-    }</span>
<a href="#l16.247"></a><span id="l16.247" class="difflineminus">-    if (!copy_userid_pkt(&amp;dst-&gt;pkt, &amp;src-&gt;pkt)) {</span>
<a href="#l16.248"></a><span id="l16.248" class="difflineminus">-        free(dst-&gt;str);</span>
<a href="#l16.249"></a><span id="l16.249" class="difflineminus">-        dst-&gt;str = NULL;</span>
<a href="#l16.250"></a><span id="l16.250" class="difflineminus">-        return RNP_ERROR_GENERIC;</span>
<a href="#l16.251"></a><span id="l16.251" class="difflineminus">-    }</span>
<a href="#l16.252"></a><span id="l16.252" class="difflineminus">-    return RNP_SUCCESS;</span>
<a href="#l16.253"></a><span id="l16.253" class="difflineminus">-}</span>
<a href="#l16.254"></a><span id="l16.254" class="difflineminus">-</span>
<a href="#l16.255"></a><span id="l16.255"> rnp_result_t</span>
<a href="#l16.256"></a><span id="l16.256"> pgp_key_copy_fields(pgp_key_t *dst, const pgp_key_t *src)</span>
<a href="#l16.257"></a><span id="l16.257"> {</span>
<a href="#l16.258"></a><span id="l16.258" class="difflineminus">-    rnp_result_t ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.259"></a><span id="l16.259" class="difflineminus">-</span>
<a href="#l16.260"></a><span id="l16.260">     /* uids */</span>
<a href="#l16.261"></a><span id="l16.261">     for (size_t i = 0; i &lt; pgp_key_get_userid_count(src); i++) {</span>
<a href="#l16.262"></a><span id="l16.262">         pgp_userid_t *uid = pgp_key_add_userid(dst);</span>
<a href="#l16.263"></a><span id="l16.263">         if (!uid) {</span>
<a href="#l16.264"></a><span id="l16.264">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.265"></a><span id="l16.265">         }</span>
<a href="#l16.266"></a><span id="l16.266" class="difflineminus">-        if ((ret = pgp_userid_copy(uid, pgp_key_get_userid(src, i)))) {</span>
<a href="#l16.267"></a><span id="l16.267" class="difflineminus">-            return ret;</span>
<a href="#l16.268"></a><span id="l16.268" class="difflineplus">+        try {</span>
<a href="#l16.269"></a><span id="l16.269" class="difflineplus">+            *uid = *pgp_key_get_userid(src, i);</span>
<a href="#l16.270"></a><span id="l16.270" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l16.271"></a><span id="l16.271" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.272"></a><span id="l16.272" class="difflineplus">+            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.273"></a><span id="l16.273">         }</span>
<a href="#l16.274"></a><span id="l16.274">     }</span>
<a href="#l16.275"></a><span id="l16.275"> </span>
<a href="#l16.276"></a><span id="l16.276">     /* signatures */</span>
<a href="#l16.277"></a><span id="l16.277">     for (size_t i = 0; i &lt; pgp_key_get_subsig_count(src); i++) {</span>
<a href="#l16.278"></a><span id="l16.278">         pgp_subsig_t *subsig = pgp_key_add_subsig(dst);</span>
<a href="#l16.279"></a><span id="l16.279">         if (!subsig) {</span>
<a href="#l16.280"></a><span id="l16.280">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.281"></a><span id="l16.281">         }</span>
<a href="#l16.282"></a><span id="l16.282" class="difflineminus">-        if ((ret = pgp_subsig_copy(subsig, pgp_key_get_subsig(src, i)))) {</span>
<a href="#l16.283"></a><span id="l16.283" class="difflineminus">-            return ret;</span>
<a href="#l16.284"></a><span id="l16.284" class="difflineplus">+        try {</span>
<a href="#l16.285"></a><span id="l16.285" class="difflineplus">+            *subsig = *pgp_key_get_subsig(src, i);</span>
<a href="#l16.286"></a><span id="l16.286" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l16.287"></a><span id="l16.287" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.288"></a><span id="l16.288" class="difflineplus">+            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.289"></a><span id="l16.289">         }</span>
<a href="#l16.290"></a><span id="l16.290">     }</span>
<a href="#l16.291"></a><span id="l16.291"> </span>
<a href="#l16.292"></a><span id="l16.292">     /* revocations */</span>
<a href="#l16.293"></a><span id="l16.293">     for (size_t i = 0; i &lt; pgp_key_get_revoke_count(src); i++) {</span>
<a href="#l16.294"></a><span id="l16.294">         pgp_revoke_t *revoke = pgp_key_add_revoke(dst);</span>
<a href="#l16.295"></a><span id="l16.295">         if (!revoke) {</span>
<a href="#l16.296"></a><span id="l16.296">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.297"></a><span id="l16.297">         }</span>
<a href="#l16.298"></a><span id="l16.298" class="difflineminus">-        if ((ret = pgp_revoke_copy(revoke, pgp_key_get_revoke(src, i)))) {</span>
<a href="#l16.299"></a><span id="l16.299" class="difflineminus">-            return ret;</span>
<a href="#l16.300"></a><span id="l16.300" class="difflineplus">+        try {</span>
<a href="#l16.301"></a><span id="l16.301" class="difflineplus">+            *revoke = *pgp_key_get_revoke(src, i);</span>
<a href="#l16.302"></a><span id="l16.302" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l16.303"></a><span id="l16.303" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.304"></a><span id="l16.304" class="difflineplus">+            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.305"></a><span id="l16.305">         }</span>
<a href="#l16.306"></a><span id="l16.306">     }</span>
<a href="#l16.307"></a><span id="l16.307"> </span>
<a href="#l16.308"></a><span id="l16.308">     /* subkey grips */</span>
<a href="#l16.309"></a><span id="l16.309" class="difflineminus">-    for (list_item *grip = list_front(src-&gt;subkey_grips); grip; grip = list_next(grip)) {</span>
<a href="#l16.310"></a><span id="l16.310" class="difflineminus">-        if (!list_append(&amp;dst-&gt;subkey_grips, grip, PGP_KEY_GRIP_SIZE)) {</span>
<a href="#l16.311"></a><span id="l16.311" class="difflineminus">-            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.312"></a><span id="l16.312" class="difflineminus">-        }</span>
<a href="#l16.313"></a><span id="l16.313" class="difflineplus">+    try {</span>
<a href="#l16.314"></a><span id="l16.314" class="difflineplus">+        dst-&gt;subkey_grips = src-&gt;subkey_grips;</span>
<a href="#l16.315"></a><span id="l16.315" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.316"></a><span id="l16.316" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.317"></a><span id="l16.317" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.318"></a><span id="l16.318">     }</span>
<a href="#l16.319"></a><span id="l16.319"> </span>
<a href="#l16.320"></a><span id="l16.320">     /* primary grip */</span>
<a href="#l16.321"></a><span id="l16.321">     dst-&gt;primary_grip_set = src-&gt;primary_grip_set;</span>
<a href="#l16.322"></a><span id="l16.322" class="difflineminus">-    if (src-&gt;primary_grip_set) {</span>
<a href="#l16.323"></a><span id="l16.323" class="difflineminus">-        pgp_key_set_primary_grip(dst, pgp_key_get_primary_grip(src));</span>
<a href="#l16.324"></a><span id="l16.324" class="difflineminus">-    }</span>
<a href="#l16.325"></a><span id="l16.325" class="difflineplus">+    dst-&gt;primary_grip = src-&gt;primary_grip;</span>
<a href="#l16.326"></a><span id="l16.326"> </span>
<a href="#l16.327"></a><span id="l16.327">     /* expiration */</span>
<a href="#l16.328"></a><span id="l16.328">     dst-&gt;expiration = src-&gt;expiration;</span>
<a href="#l16.329"></a><span id="l16.329"> </span>
<a href="#l16.330"></a><span id="l16.330">     /* key_flags */</span>
<a href="#l16.331"></a><span id="l16.331">     dst-&gt;key_flags = src-&gt;key_flags;</span>
<a href="#l16.332"></a><span id="l16.332"> </span>
<a href="#l16.333"></a><span id="l16.333">     /* key id / fingerprint / grip */</span>
<a href="#l16.334"></a><span id="l16.334">     memcpy(dst-&gt;keyid, src-&gt;keyid, sizeof(dst-&gt;keyid));</span>
<a href="#l16.335"></a><span id="l16.335">     memcpy(&amp;dst-&gt;fingerprint, &amp;src-&gt;fingerprint, sizeof(dst-&gt;fingerprint));</span>
<a href="#l16.336"></a><span id="l16.336" class="difflineminus">-    memcpy(&amp;dst-&gt;grip, &amp;src-&gt;grip, sizeof(dst-&gt;grip));</span>
<a href="#l16.337"></a><span id="l16.337" class="difflineplus">+    dst-&gt;grip = src-&gt;grip;</span>
<a href="#l16.338"></a><span id="l16.338"> </span>
<a href="#l16.339"></a><span id="l16.339">     /* primary uid */</span>
<a href="#l16.340"></a><span id="l16.340">     dst-&gt;uid0 = src-&gt;uid0;</span>
<a href="#l16.341"></a><span id="l16.341">     dst-&gt;uid0_set = src-&gt;uid0_set;</span>
<a href="#l16.342"></a><span id="l16.342"> </span>
<a href="#l16.343"></a><span id="l16.343">     /* revocation */</span>
<a href="#l16.344"></a><span id="l16.344">     dst-&gt;revoked = src-&gt;revoked;</span>
<a href="#l16.345"></a><span id="l16.345" class="difflineminus">-    ret = pgp_revoke_copy(&amp;dst-&gt;revocation, &amp;src-&gt;revocation);</span>
<a href="#l16.346"></a><span id="l16.346" class="difflineminus">-    if (ret) {</span>
<a href="#l16.347"></a><span id="l16.347" class="difflineminus">-        return ret;</span>
<a href="#l16.348"></a><span id="l16.348" class="difflineplus">+    try {</span>
<a href="#l16.349"></a><span id="l16.349" class="difflineplus">+        dst-&gt;revocation = src-&gt;revocation;</span>
<a href="#l16.350"></a><span id="l16.350" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.351"></a><span id="l16.351" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.352"></a><span id="l16.352" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l16.353"></a><span id="l16.353">     }</span>
<a href="#l16.354"></a><span id="l16.354"> </span>
<a href="#l16.355"></a><span id="l16.355">     /* key store format */</span>
<a href="#l16.356"></a><span id="l16.356">     dst-&gt;format = src-&gt;format;</span>
<a href="#l16.357"></a><span id="l16.357"> </span>
<a href="#l16.358"></a><span id="l16.358">     /* key validity */</span>
<a href="#l16.359"></a><span id="l16.359">     dst-&gt;valid = src-&gt;valid;</span>
<a href="#l16.360"></a><span id="l16.360">     dst-&gt;validated = src-&gt;validated;</span>
<a href="#l16.361"></a><span id="l16.361" class="difflineat">@@ -707,89 +604,86 @@ error:</span>
<a href="#l16.362"></a><span id="l16.362">  * - In the case of an unprotected key, it simply re-loads</span>
<a href="#l16.363"></a><span id="l16.363">  *   key-&gt;key.seckey by parsing the key data in packets[0].</span>
<a href="#l16.364"></a><span id="l16.364">  */</span>
<a href="#l16.365"></a><span id="l16.365"> pgp_key_pkt_t *</span>
<a href="#l16.366"></a><span id="l16.366"> pgp_decrypt_seckey(const pgp_key_t *              key,</span>
<a href="#l16.367"></a><span id="l16.367">                    const pgp_password_provider_t *provider,</span>
<a href="#l16.368"></a><span id="l16.368">                    const pgp_password_ctx_t *     ctx)</span>
<a href="#l16.369"></a><span id="l16.369"> {</span>
<a href="#l16.370"></a><span id="l16.370" class="difflineminus">-    pgp_key_pkt_t *               decrypted_seckey = NULL;</span>
<a href="#l16.371"></a><span id="l16.371">     typedef struct pgp_key_pkt_t *pgp_seckey_decrypt_t(</span>
<a href="#l16.372"></a><span id="l16.372">       const uint8_t *data, size_t data_len, const pgp_key_pkt_t *pubkey, const char *password);</span>
<a href="#l16.373"></a><span id="l16.373" class="difflineminus">-    pgp_seckey_decrypt_t * decryptor = NULL;</span>
<a href="#l16.374"></a><span id="l16.374" class="difflineminus">-    const pgp_rawpacket_t *packet = NULL;</span>
<a href="#l16.375"></a><span id="l16.375" class="difflineminus">-    char                   password[MAX_PASSWORD_LENGTH] = {0};</span>
<a href="#l16.376"></a><span id="l16.376" class="difflineplus">+    pgp_seckey_decrypt_t *decryptor = NULL;</span>
<a href="#l16.377"></a><span id="l16.377"> </span>
<a href="#l16.378"></a><span id="l16.378">     // sanity checks</span>
<a href="#l16.379"></a><span id="l16.379">     if (!key || !pgp_key_is_secret(key) || !provider) {</span>
<a href="#l16.380"></a><span id="l16.380">         RNP_LOG(&quot;invalid args&quot;);</span>
<a href="#l16.381"></a><span id="l16.381" class="difflineminus">-        goto done;</span>
<a href="#l16.382"></a><span id="l16.382" class="difflineplus">+        return NULL;</span>
<a href="#l16.383"></a><span id="l16.383">     }</span>
<a href="#l16.384"></a><span id="l16.384">     switch (key-&gt;format) {</span>
<a href="#l16.385"></a><span id="l16.385">     case PGP_KEY_STORE_GPG:</span>
<a href="#l16.386"></a><span id="l16.386">     case PGP_KEY_STORE_KBX:</span>
<a href="#l16.387"></a><span id="l16.387">         decryptor = pgp_decrypt_seckey_pgp;</span>
<a href="#l16.388"></a><span id="l16.388">         break;</span>
<a href="#l16.389"></a><span id="l16.389">     case PGP_KEY_STORE_G10:</span>
<a href="#l16.390"></a><span id="l16.390">         decryptor = g10_decrypt_seckey;</span>
<a href="#l16.391"></a><span id="l16.391">         break;</span>
<a href="#l16.392"></a><span id="l16.392">     default:</span>
<a href="#l16.393"></a><span id="l16.393">         RNP_LOG(&quot;unexpected format: %d&quot;, key-&gt;format);</span>
<a href="#l16.394"></a><span id="l16.394" class="difflineminus">-        goto done;</span>
<a href="#l16.395"></a><span id="l16.395" class="difflineminus">-        break;</span>
<a href="#l16.396"></a><span id="l16.396" class="difflineminus">-    }</span>
<a href="#l16.397"></a><span id="l16.397" class="difflineminus">-    if (!decryptor) {</span>
<a href="#l16.398"></a><span id="l16.398" class="difflineminus">-        RNP_LOG(&quot;missing decrypt callback&quot;);</span>
<a href="#l16.399"></a><span id="l16.399" class="difflineminus">-        goto done;</span>
<a href="#l16.400"></a><span id="l16.400" class="difflineplus">+        return NULL;</span>
<a href="#l16.401"></a><span id="l16.401">     }</span>
<a href="#l16.402"></a><span id="l16.402"> </span>
<a href="#l16.403"></a><span id="l16.403" class="difflineminus">-    if (pgp_key_is_protected(key)) {</span>
<a href="#l16.404"></a><span id="l16.404" class="difflineminus">-        // ask the provider for a password</span>
<a href="#l16.405"></a><span id="l16.405" class="difflineminus">-        if (!pgp_request_password(provider, ctx, password, sizeof(password))) {</span>
<a href="#l16.406"></a><span id="l16.406" class="difflineminus">-            goto done;</span>
<a href="#l16.407"></a><span id="l16.407" class="difflineminus">-        }</span>
<a href="#l16.408"></a><span id="l16.408" class="difflineplus">+    // ask the provider for a password</span>
<a href="#l16.409"></a><span id="l16.409" class="difflineplus">+    char password[MAX_PASSWORD_LENGTH] = {0};</span>
<a href="#l16.410"></a><span id="l16.410" class="difflineplus">+    if (pgp_key_is_protected(key) &amp;&amp;</span>
<a href="#l16.411"></a><span id="l16.411" class="difflineplus">+        !pgp_request_password(provider, ctx, password, sizeof(password))) {</span>
<a href="#l16.412"></a><span id="l16.412" class="difflineplus">+        return NULL;</span>
<a href="#l16.413"></a><span id="l16.413">     }</span>
<a href="#l16.414"></a><span id="l16.414">     // attempt to decrypt with the provided password</span>
<a href="#l16.415"></a><span id="l16.415" class="difflineminus">-    packet = pgp_key_get_rawpacket(key, 0);</span>
<a href="#l16.416"></a><span id="l16.416" class="difflineminus">-    decrypted_seckey = decryptor(packet-&gt;raw, packet-&gt;length, pgp_key_get_pkt(key), password);</span>
<a href="#l16.417"></a><span id="l16.417" class="difflineminus">-</span>
<a href="#l16.418"></a><span id="l16.418" class="difflineminus">-done:</span>
<a href="#l16.419"></a><span id="l16.419" class="difflineplus">+    const pgp_rawpacket_t &amp;pkt = pgp_key_get_rawpacket(key);</span>
<a href="#l16.420"></a><span id="l16.420" class="difflineplus">+    pgp_key_pkt_t *        decrypted_seckey =</span>
<a href="#l16.421"></a><span id="l16.421" class="difflineplus">+      decryptor(pkt.raw.data(), pkt.raw.size(), pgp_key_get_pkt(key), password);</span>
<a href="#l16.422"></a><span id="l16.422">     pgp_forget(password, sizeof(password));</span>
<a href="#l16.423"></a><span id="l16.423">     return decrypted_seckey;</span>
<a href="#l16.424"></a><span id="l16.424"> }</span>
<a href="#l16.425"></a><span id="l16.425"> </span>
<a href="#l16.426"></a><span id="l16.426"> const uint8_t *</span>
<a href="#l16.427"></a><span id="l16.427"> pgp_key_get_keyid(const pgp_key_t *key)</span>
<a href="#l16.428"></a><span id="l16.428"> {</span>
<a href="#l16.429"></a><span id="l16.429">     return key-&gt;keyid;</span>
<a href="#l16.430"></a><span id="l16.430"> }</span>
<a href="#l16.431"></a><span id="l16.431"> </span>
<a href="#l16.432"></a><span id="l16.432"> const pgp_fingerprint_t *</span>
<a href="#l16.433"></a><span id="l16.433"> pgp_key_get_fp(const pgp_key_t *key)</span>
<a href="#l16.434"></a><span id="l16.434"> {</span>
<a href="#l16.435"></a><span id="l16.435">     return &amp;key-&gt;fingerprint;</span>
<a href="#l16.436"></a><span id="l16.436"> }</span>
<a href="#l16.437"></a><span id="l16.437"> </span>
<a href="#l16.438"></a><span id="l16.438" class="difflineminus">-const uint8_t *</span>
<a href="#l16.439"></a><span id="l16.439" class="difflineplus">+const pgp_key_grip_t &amp;</span>
<a href="#l16.440"></a><span id="l16.440"> pgp_key_get_grip(const pgp_key_t *key)</span>
<a href="#l16.441"></a><span id="l16.441"> {</span>
<a href="#l16.442"></a><span id="l16.442">     return key-&gt;grip;</span>
<a href="#l16.443"></a><span id="l16.443"> }</span>
<a href="#l16.444"></a><span id="l16.444"> </span>
<a href="#l16.445"></a><span id="l16.445" class="difflineminus">-const uint8_t *</span>
<a href="#l16.446"></a><span id="l16.446" class="difflineplus">+const pgp_key_grip_t &amp;</span>
<a href="#l16.447"></a><span id="l16.447"> pgp_key_get_primary_grip(const pgp_key_t *key)</span>
<a href="#l16.448"></a><span id="l16.448"> {</span>
<a href="#l16.449"></a><span id="l16.449" class="difflineminus">-    return key-&gt;primary_grip_set ? key-&gt;primary_grip : NULL;</span>
<a href="#l16.450"></a><span id="l16.450" class="difflineplus">+    return key-&gt;primary_grip;</span>
<a href="#l16.451"></a><span id="l16.451" class="difflineplus">+}</span>
<a href="#l16.452"></a><span id="l16.452" class="difflineplus">+</span>
<a href="#l16.453"></a><span id="l16.453" class="difflineplus">+bool</span>
<a href="#l16.454"></a><span id="l16.454" class="difflineplus">+pgp_key_has_primary_grip(const pgp_key_t *key)</span>
<a href="#l16.455"></a><span id="l16.455" class="difflineplus">+{</span>
<a href="#l16.456"></a><span id="l16.456" class="difflineplus">+    return key-&gt;primary_grip_set;</span>
<a href="#l16.457"></a><span id="l16.457"> }</span>
<a href="#l16.458"></a><span id="l16.458"> </span>
<a href="#l16.459"></a><span id="l16.459"> void</span>
<a href="#l16.460"></a><span id="l16.460" class="difflineminus">-pgp_key_set_primary_grip(pgp_key_t *key, const uint8_t *grip)</span>
<a href="#l16.461"></a><span id="l16.461" class="difflineplus">+pgp_key_set_primary_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip)</span>
<a href="#l16.462"></a><span id="l16.462"> {</span>
<a href="#l16.463"></a><span id="l16.463" class="difflineminus">-    memcpy(key-&gt;primary_grip, grip, PGP_KEY_GRIP_SIZE);</span>
<a href="#l16.464"></a><span id="l16.464" class="difflineplus">+    key-&gt;primary_grip = grip;</span>
<a href="#l16.465"></a><span id="l16.465">     key-&gt;primary_grip_set = true;</span>
<a href="#l16.466"></a><span id="l16.466"> }</span>
<a href="#l16.467"></a><span id="l16.467"> </span>
<a href="#l16.468"></a><span id="l16.468"> bool</span>
<a href="#l16.469"></a><span id="l16.469"> pgp_key_link_subkey_grip(pgp_key_t *key, pgp_key_t *subkey)</span>
<a href="#l16.470"></a><span id="l16.470"> {</span>
<a href="#l16.471"></a><span id="l16.471">     pgp_key_set_primary_grip(subkey, pgp_key_get_grip(key));</span>
<a href="#l16.472"></a><span id="l16.472">     if (!pgp_key_add_subkey_grip(key, pgp_key_get_grip(subkey))) {</span>
<a href="#l16.473"></a><span id="l16.473" class="difflineat">@@ -828,40 +722,42 @@ pgp_key_get_userid_revoke(const pgp_key_</span>
<a href="#l16.474"></a><span id="l16.474">     }</span>
<a href="#l16.475"></a><span id="l16.475">     return NULL;</span>
<a href="#l16.476"></a><span id="l16.476"> }</span>
<a href="#l16.477"></a><span id="l16.477"> </span>
<a href="#l16.478"></a><span id="l16.478"> bool</span>
<a href="#l16.479"></a><span id="l16.479"> pgp_key_has_userid(const pgp_key_t *key, const char *uid)</span>
<a href="#l16.480"></a><span id="l16.480"> {</span>
<a href="#l16.481"></a><span id="l16.481">     for (auto &amp;userid : key-&gt;uids) {</span>
<a href="#l16.482"></a><span id="l16.482" class="difflineminus">-        if (!strcmp(uid, userid.str)) {</span>
<a href="#l16.483"></a><span id="l16.483" class="difflineplus">+        if (userid.str == uid) {</span>
<a href="#l16.484"></a><span id="l16.484">             return true;</span>
<a href="#l16.485"></a><span id="l16.485">         }</span>
<a href="#l16.486"></a><span id="l16.486">     }</span>
<a href="#l16.487"></a><span id="l16.487">     return false;</span>
<a href="#l16.488"></a><span id="l16.488"> }</span>
<a href="#l16.489"></a><span id="l16.489"> </span>
<a href="#l16.490"></a><span id="l16.490"> pgp_userid_t *</span>
<a href="#l16.491"></a><span id="l16.491"> pgp_key_add_userid(pgp_key_t *key)</span>
<a href="#l16.492"></a><span id="l16.492"> {</span>
<a href="#l16.493"></a><span id="l16.493">     try {</span>
<a href="#l16.494"></a><span id="l16.494">         key-&gt;uids.push_back({});</span>
<a href="#l16.495"></a><span id="l16.495" class="difflineminus">-    } catch (...) {</span>
<a href="#l16.496"></a><span id="l16.496" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.497"></a><span id="l16.497" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.498"></a><span id="l16.498">         return NULL;</span>
<a href="#l16.499"></a><span id="l16.499">     }</span>
<a href="#l16.500"></a><span id="l16.500">     return &amp;key-&gt;uids.back();</span>
<a href="#l16.501"></a><span id="l16.501"> }</span>
<a href="#l16.502"></a><span id="l16.502"> </span>
<a href="#l16.503"></a><span id="l16.503"> pgp_revoke_t *</span>
<a href="#l16.504"></a><span id="l16.504"> pgp_key_add_revoke(pgp_key_t *key)</span>
<a href="#l16.505"></a><span id="l16.505"> {</span>
<a href="#l16.506"></a><span id="l16.506">     try {</span>
<a href="#l16.507"></a><span id="l16.507">         key-&gt;revokes.push_back({});</span>
<a href="#l16.508"></a><span id="l16.508" class="difflineminus">-    } catch (...) {</span>
<a href="#l16.509"></a><span id="l16.509" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.510"></a><span id="l16.510" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.511"></a><span id="l16.511">         return NULL;</span>
<a href="#l16.512"></a><span id="l16.512">     }</span>
<a href="#l16.513"></a><span id="l16.513">     return &amp;key-&gt;revokes.back();</span>
<a href="#l16.514"></a><span id="l16.514"> }</span>
<a href="#l16.515"></a><span id="l16.515"> </span>
<a href="#l16.516"></a><span id="l16.516"> size_t</span>
<a href="#l16.517"></a><span id="l16.517"> pgp_key_get_revoke_count(const pgp_key_t *key)</span>
<a href="#l16.518"></a><span id="l16.518"> {</span>
<a href="#l16.519"></a><span id="l16.519" class="difflineat">@@ -880,17 +776,18 @@ pgp_key_get_revoke(pgp_key_t *key, size_</span>
<a href="#l16.520"></a><span id="l16.520">     return (idx &lt; key-&gt;revokes.size()) ? &amp;key-&gt;revokes[idx] : NULL;</span>
<a href="#l16.521"></a><span id="l16.521"> }</span>
<a href="#l16.522"></a><span id="l16.522"> </span>
<a href="#l16.523"></a><span id="l16.523"> pgp_subsig_t *</span>
<a href="#l16.524"></a><span id="l16.524"> pgp_key_add_subsig(pgp_key_t *key)</span>
<a href="#l16.525"></a><span id="l16.525"> {</span>
<a href="#l16.526"></a><span id="l16.526">     try {</span>
<a href="#l16.527"></a><span id="l16.527">         key-&gt;subsigs.push_back({});</span>
<a href="#l16.528"></a><span id="l16.528" class="difflineminus">-    } catch (...) {</span>
<a href="#l16.529"></a><span id="l16.529" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.530"></a><span id="l16.530" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.531"></a><span id="l16.531">         return NULL;</span>
<a href="#l16.532"></a><span id="l16.532">     }</span>
<a href="#l16.533"></a><span id="l16.533">     return &amp;key-&gt;subsigs.back();</span>
<a href="#l16.534"></a><span id="l16.534"> }</span>
<a href="#l16.535"></a><span id="l16.535"> </span>
<a href="#l16.536"></a><span id="l16.536"> size_t</span>
<a href="#l16.537"></a><span id="l16.537"> pgp_key_get_subsig_count(const pgp_key_t *key)</span>
<a href="#l16.538"></a><span id="l16.538"> {</span>
<a href="#l16.539"></a><span id="l16.539" class="difflineat">@@ -904,176 +801,127 @@ pgp_key_get_subsig(const pgp_key_t *key,</span>
<a href="#l16.540"></a><span id="l16.540"> }</span>
<a href="#l16.541"></a><span id="l16.541"> </span>
<a href="#l16.542"></a><span id="l16.542"> pgp_subsig_t *</span>
<a href="#l16.543"></a><span id="l16.543"> pgp_key_get_subsig(pgp_key_t *key, size_t idx)</span>
<a href="#l16.544"></a><span id="l16.544"> {</span>
<a href="#l16.545"></a><span id="l16.545">     return (idx &lt; key-&gt;subsigs.size()) ? &amp;key-&gt;subsigs[idx] : NULL;</span>
<a href="#l16.546"></a><span id="l16.546"> }</span>
<a href="#l16.547"></a><span id="l16.547"> </span>
<a href="#l16.548"></a><span id="l16.548" class="difflineminus">-static bool</span>
<a href="#l16.549"></a><span id="l16.549" class="difflineminus">-pgp_signature_to_rawpacket(pgp_rawpacket_t *pkt, const pgp_signature_t *sig)</span>
<a href="#l16.550"></a><span id="l16.550" class="difflineplus">+bool</span>
<a href="#l16.551"></a><span id="l16.551" class="difflineplus">+pgp_subsig_from_signature(pgp_subsig_t *dst, const pgp_signature_t *sig)</span>
<a href="#l16.552"></a><span id="l16.552"> {</span>
<a href="#l16.553"></a><span id="l16.553" class="difflineminus">-    pgp_dest_t dst = {};</span>
<a href="#l16.554"></a><span id="l16.554" class="difflineminus">-</span>
<a href="#l16.555"></a><span id="l16.555" class="difflineminus">-    if (init_mem_dest(&amp;dst, NULL, 0)) {</span>
<a href="#l16.556"></a><span id="l16.556" class="difflineplus">+    pgp_subsig_t subsig = {};</span>
<a href="#l16.557"></a><span id="l16.557" class="difflineplus">+    if (!copy_signature_packet(&amp;subsig.sig, sig)) {</span>
<a href="#l16.558"></a><span id="l16.558" class="difflineplus">+        return false;</span>
<a href="#l16.559"></a><span id="l16.559" class="difflineplus">+    }</span>
<a href="#l16.560"></a><span id="l16.560" class="difflineplus">+    if (signature_has_trust(&amp;subsig.sig)) {</span>
<a href="#l16.561"></a><span id="l16.561" class="difflineplus">+        signature_get_trust(&amp;subsig.sig, &amp;subsig.trustlevel, &amp;subsig.trustamount);</span>
<a href="#l16.562"></a><span id="l16.562" class="difflineplus">+    }</span>
<a href="#l16.563"></a><span id="l16.563" class="difflineplus">+    uint8_t *algs = NULL;</span>
<a href="#l16.564"></a><span id="l16.564" class="difflineplus">+    size_t   count = 0;</span>
<a href="#l16.565"></a><span id="l16.565" class="difflineplus">+    if (signature_get_preferred_symm_algs(&amp;subsig.sig, &amp;algs, &amp;count) &amp;&amp;</span>
<a href="#l16.566"></a><span id="l16.566" class="difflineplus">+        !pgp_user_prefs_set_symm_algs(&amp;subsig.prefs, algs, count)) {</span>
<a href="#l16.567"></a><span id="l16.567" class="difflineplus">+        RNP_LOG(&quot;failed to alloc symm algs&quot;);</span>
<a href="#l16.568"></a><span id="l16.568" class="difflineplus">+        return false;</span>
<a href="#l16.569"></a><span id="l16.569" class="difflineplus">+    }</span>
<a href="#l16.570"></a><span id="l16.570" class="difflineplus">+    if (signature_get_preferred_hash_algs(&amp;subsig.sig, &amp;algs, &amp;count) &amp;&amp;</span>
<a href="#l16.571"></a><span id="l16.571" class="difflineplus">+        !pgp_user_prefs_set_hash_algs(&amp;subsig.prefs, algs, count)) {</span>
<a href="#l16.572"></a><span id="l16.572" class="difflineplus">+        RNP_LOG(&quot;failed to alloc hash algs&quot;);</span>
<a href="#l16.573"></a><span id="l16.573">         return false;</span>
<a href="#l16.574"></a><span id="l16.574">     }</span>
<a href="#l16.575"></a><span id="l16.575" class="difflineminus">-    if (!stream_write_signature(sig, &amp;dst)) {</span>
<a href="#l16.576"></a><span id="l16.576" class="difflineminus">-        dst_close(&amp;dst, true);</span>
<a href="#l16.577"></a><span id="l16.577" class="difflineplus">+    if (signature_get_preferred_z_algs(&amp;subsig.sig, &amp;algs, &amp;count) &amp;&amp;</span>
<a href="#l16.578"></a><span id="l16.578" class="difflineplus">+        !pgp_user_prefs_set_z_algs(&amp;subsig.prefs, algs, count)) {</span>
<a href="#l16.579"></a><span id="l16.579" class="difflineplus">+        RNP_LOG(&quot;failed to alloc z algs&quot;);</span>
<a href="#l16.580"></a><span id="l16.580" class="difflineplus">+        return false;</span>
<a href="#l16.581"></a><span id="l16.581" class="difflineplus">+    }</span>
<a href="#l16.582"></a><span id="l16.582" class="difflineplus">+    if (signature_has_key_flags(&amp;subsig.sig)) {</span>
<a href="#l16.583"></a><span id="l16.583" class="difflineplus">+        subsig.key_flags = signature_get_key_flags(&amp;subsig.sig);</span>
<a href="#l16.584"></a><span id="l16.584" class="difflineplus">+    }</span>
<a href="#l16.585"></a><span id="l16.585" class="difflineplus">+    if (signature_has_key_server_prefs(&amp;subsig.sig)) {</span>
<a href="#l16.586"></a><span id="l16.586" class="difflineplus">+        uint8_t ks_pref = signature_get_key_server_prefs(&amp;subsig.sig);</span>
<a href="#l16.587"></a><span id="l16.587" class="difflineplus">+        if (!pgp_user_prefs_set_ks_prefs(&amp;subsig.prefs, &amp;ks_pref, 1)) {</span>
<a href="#l16.588"></a><span id="l16.588" class="difflineplus">+            RNP_LOG(&quot;failed to alloc ks prefs&quot;);</span>
<a href="#l16.589"></a><span id="l16.589" class="difflineplus">+            return false;</span>
<a href="#l16.590"></a><span id="l16.590" class="difflineplus">+        }</span>
<a href="#l16.591"></a><span id="l16.591" class="difflineplus">+    }</span>
<a href="#l16.592"></a><span id="l16.592" class="difflineplus">+    if (signature_has_key_server(&amp;subsig.sig)) {</span>
<a href="#l16.593"></a><span id="l16.593" class="difflineplus">+        subsig.prefs.key_server = (uint8_t *) signature_get_key_server(&amp;subsig.sig);</span>
<a href="#l16.594"></a><span id="l16.594" class="difflineplus">+        if (!subsig.prefs.key_server) {</span>
<a href="#l16.595"></a><span id="l16.595" class="difflineplus">+            RNP_LOG(&quot;failed to alloc ks&quot;);</span>
<a href="#l16.596"></a><span id="l16.596" class="difflineplus">+            return false;</span>
<a href="#l16.597"></a><span id="l16.597" class="difflineplus">+        }</span>
<a href="#l16.598"></a><span id="l16.598" class="difflineplus">+    }</span>
<a href="#l16.599"></a><span id="l16.599" class="difflineplus">+    /* add signature rawpacket */</span>
<a href="#l16.600"></a><span id="l16.600" class="difflineplus">+    try {</span>
<a href="#l16.601"></a><span id="l16.601" class="difflineplus">+        subsig.rawpkt = pgp_rawpacket_t(*sig);</span>
<a href="#l16.602"></a><span id="l16.602" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.603"></a><span id="l16.603" class="difflineplus">+        RNP_LOG(&quot;failed to build sig rawpacket: %s&quot;, e.what());</span>
<a href="#l16.604"></a><span id="l16.604">         return false;</span>
<a href="#l16.605"></a><span id="l16.605">     }</span>
<a href="#l16.606"></a><span id="l16.606"> </span>
<a href="#l16.607"></a><span id="l16.607" class="difflineminus">-    pkt-&gt;tag = PGP_PKT_SIGNATURE;</span>
<a href="#l16.608"></a><span id="l16.608" class="difflineminus">-    pkt-&gt;length = dst.writeb;</span>
<a href="#l16.609"></a><span id="l16.609" class="difflineminus">-    pkt-&gt;raw = (uint8_t *) mem_dest_own_memory(&amp;dst);</span>
<a href="#l16.610"></a><span id="l16.610" class="difflineminus">-    dst_close(&amp;dst, true);</span>
<a href="#l16.611"></a><span id="l16.611" class="difflineplus">+    *dst = std::move(subsig);</span>
<a href="#l16.612"></a><span id="l16.612">     return true;</span>
<a href="#l16.613"></a><span id="l16.613"> }</span>
<a href="#l16.614"></a><span id="l16.614"> </span>
<a href="#l16.615"></a><span id="l16.615"> bool</span>
<a href="#l16.616"></a><span id="l16.616" class="difflineminus">-pgp_subsig_from_signature(pgp_subsig_t *subsig, const pgp_signature_t *sig)</span>
<a href="#l16.617"></a><span id="l16.617" class="difflineminus">-{</span>
<a href="#l16.618"></a><span id="l16.618" class="difflineminus">-    uint8_t *algs = NULL;</span>
<a href="#l16.619"></a><span id="l16.619" class="difflineminus">-    size_t   count = 0;</span>
<a href="#l16.620"></a><span id="l16.620" class="difflineminus">-</span>
<a href="#l16.621"></a><span id="l16.621" class="difflineminus">-    memset(subsig, 0, sizeof(*subsig));</span>
<a href="#l16.622"></a><span id="l16.622" class="difflineminus">-</span>
<a href="#l16.623"></a><span id="l16.623" class="difflineminus">-    if (!copy_signature_packet(&amp;subsig-&gt;sig, sig)) {</span>
<a href="#l16.624"></a><span id="l16.624" class="difflineminus">-        return false;</span>
<a href="#l16.625"></a><span id="l16.625" class="difflineminus">-    }</span>
<a href="#l16.626"></a><span id="l16.626" class="difflineminus">-    if (signature_has_trust(&amp;subsig-&gt;sig)) {</span>
<a href="#l16.627"></a><span id="l16.627" class="difflineminus">-        signature_get_trust(&amp;subsig-&gt;sig, &amp;subsig-&gt;trustlevel, &amp;subsig-&gt;trustamount);</span>
<a href="#l16.628"></a><span id="l16.628" class="difflineminus">-    }</span>
<a href="#l16.629"></a><span id="l16.629" class="difflineminus">-    if (signature_get_preferred_symm_algs(&amp;subsig-&gt;sig, &amp;algs, &amp;count) &amp;&amp;</span>
<a href="#l16.630"></a><span id="l16.630" class="difflineminus">-        !pgp_user_prefs_set_symm_algs(&amp;subsig-&gt;prefs, algs, count)) {</span>
<a href="#l16.631"></a><span id="l16.631" class="difflineminus">-        RNP_LOG(&quot;failed to alloc symm algs&quot;);</span>
<a href="#l16.632"></a><span id="l16.632" class="difflineminus">-        goto error;</span>
<a href="#l16.633"></a><span id="l16.633" class="difflineminus">-    }</span>
<a href="#l16.634"></a><span id="l16.634" class="difflineminus">-    if (signature_get_preferred_hash_algs(&amp;subsig-&gt;sig, &amp;algs, &amp;count) &amp;&amp;</span>
<a href="#l16.635"></a><span id="l16.635" class="difflineminus">-        !pgp_user_prefs_set_hash_algs(&amp;subsig-&gt;prefs, algs, count)) {</span>
<a href="#l16.636"></a><span id="l16.636" class="difflineminus">-        RNP_LOG(&quot;failed to alloc hash algs&quot;);</span>
<a href="#l16.637"></a><span id="l16.637" class="difflineminus">-        goto error;</span>
<a href="#l16.638"></a><span id="l16.638" class="difflineminus">-    }</span>
<a href="#l16.639"></a><span id="l16.639" class="difflineminus">-    if (signature_get_preferred_z_algs(&amp;subsig-&gt;sig, &amp;algs, &amp;count) &amp;&amp;</span>
<a href="#l16.640"></a><span id="l16.640" class="difflineminus">-        !pgp_user_prefs_set_z_algs(&amp;subsig-&gt;prefs, algs, count)) {</span>
<a href="#l16.641"></a><span id="l16.641" class="difflineminus">-        RNP_LOG(&quot;failed to alloc z algs&quot;);</span>
<a href="#l16.642"></a><span id="l16.642" class="difflineminus">-        goto error;</span>
<a href="#l16.643"></a><span id="l16.643" class="difflineminus">-    }</span>
<a href="#l16.644"></a><span id="l16.644" class="difflineminus">-    if (signature_has_key_flags(&amp;subsig-&gt;sig)) {</span>
<a href="#l16.645"></a><span id="l16.645" class="difflineminus">-        subsig-&gt;key_flags = signature_get_key_flags(&amp;subsig-&gt;sig);</span>
<a href="#l16.646"></a><span id="l16.646" class="difflineminus">-    }</span>
<a href="#l16.647"></a><span id="l16.647" class="difflineminus">-    if (signature_has_key_server_prefs(&amp;subsig-&gt;sig)) {</span>
<a href="#l16.648"></a><span id="l16.648" class="difflineminus">-        uint8_t ks_pref = signature_get_key_server_prefs(&amp;subsig-&gt;sig);</span>
<a href="#l16.649"></a><span id="l16.649" class="difflineminus">-        if (!pgp_user_prefs_set_ks_prefs(&amp;subsig-&gt;prefs, &amp;ks_pref, 1)) {</span>
<a href="#l16.650"></a><span id="l16.650" class="difflineminus">-            RNP_LOG(&quot;failed to alloc ks prefs&quot;);</span>
<a href="#l16.651"></a><span id="l16.651" class="difflineminus">-            goto error;</span>
<a href="#l16.652"></a><span id="l16.652" class="difflineminus">-        }</span>
<a href="#l16.653"></a><span id="l16.653" class="difflineminus">-    }</span>
<a href="#l16.654"></a><span id="l16.654" class="difflineminus">-    if (signature_has_key_server(&amp;subsig-&gt;sig)) {</span>
<a href="#l16.655"></a><span id="l16.655" class="difflineminus">-        subsig-&gt;prefs.key_server = (uint8_t *) signature_get_key_server(&amp;subsig-&gt;sig);</span>
<a href="#l16.656"></a><span id="l16.656" class="difflineminus">-        if (!subsig-&gt;prefs.key_server) {</span>
<a href="#l16.657"></a><span id="l16.657" class="difflineminus">-            RNP_LOG(&quot;failed to alloc ks&quot;);</span>
<a href="#l16.658"></a><span id="l16.658" class="difflineminus">-            goto error;</span>
<a href="#l16.659"></a><span id="l16.659" class="difflineminus">-        }</span>
<a href="#l16.660"></a><span id="l16.660" class="difflineminus">-    }</span>
<a href="#l16.661"></a><span id="l16.661" class="difflineminus">-</span>
<a href="#l16.662"></a><span id="l16.662" class="difflineminus">-    return true;</span>
<a href="#l16.663"></a><span id="l16.663" class="difflineminus">-error:</span>
<a href="#l16.664"></a><span id="l16.664" class="difflineminus">-    pgp_subsig_free(subsig);</span>
<a href="#l16.665"></a><span id="l16.665" class="difflineminus">-    memset(subsig, 0, sizeof(*subsig));</span>
<a href="#l16.666"></a><span id="l16.666" class="difflineminus">-    return false;</span>
<a href="#l16.667"></a><span id="l16.667" class="difflineminus">-}</span>
<a href="#l16.668"></a><span id="l16.668" class="difflineminus">-</span>
<a href="#l16.669"></a><span id="l16.669" class="difflineminus">-bool</span>
<a href="#l16.670"></a><span id="l16.670"> pgp_key_has_signature(const pgp_key_t *key, const pgp_signature_t *sig)</span>
<a href="#l16.671"></a><span id="l16.671"> {</span>
<a href="#l16.672"></a><span id="l16.672">     for (size_t i = 0; i &lt; pgp_key_get_subsig_count(key); i++) {</span>
<a href="#l16.673"></a><span id="l16.673">         const pgp_subsig_t *subsig = pgp_key_get_subsig(key, i);</span>
<a href="#l16.674"></a><span id="l16.674">         if (signature_pkt_equal(&amp;subsig-&gt;sig, sig)) {</span>
<a href="#l16.675"></a><span id="l16.675">             return true;</span>
<a href="#l16.676"></a><span id="l16.676">         }</span>
<a href="#l16.677"></a><span id="l16.677">     }</span>
<a href="#l16.678"></a><span id="l16.678"> </span>
<a href="#l16.679"></a><span id="l16.679">     return false;</span>
<a href="#l16.680"></a><span id="l16.680"> }</span>
<a href="#l16.681"></a><span id="l16.681"> </span>
<a href="#l16.682"></a><span id="l16.682" class="difflineminus">-static bool</span>
<a href="#l16.683"></a><span id="l16.683" class="difflineminus">-pgp_key_replace_rawpacket(pgp_key_t *key, pgp_rawpacket_t *oldpkt, pgp_rawpacket_t *newpkt)</span>
<a href="#l16.684"></a><span id="l16.684" class="difflineminus">-{</span>
<a href="#l16.685"></a><span id="l16.685" class="difflineminus">-    for (size_t i = 0; i &lt; pgp_key_get_rawpacket_count(key); i++) {</span>
<a href="#l16.686"></a><span id="l16.686" class="difflineminus">-        pgp_rawpacket_t *curpkt = pgp_key_get_rawpacket(key, i);</span>
<a href="#l16.687"></a><span id="l16.687" class="difflineminus">-        if ((curpkt-&gt;length != oldpkt-&gt;length) || (curpkt-&gt;tag != oldpkt-&gt;tag)) {</span>
<a href="#l16.688"></a><span id="l16.688" class="difflineminus">-            continue;</span>
<a href="#l16.689"></a><span id="l16.689" class="difflineminus">-        }</span>
<a href="#l16.690"></a><span id="l16.690" class="difflineminus">-        if (memcmp(curpkt-&gt;raw, oldpkt-&gt;raw, curpkt-&gt;length)) {</span>
<a href="#l16.691"></a><span id="l16.691" class="difflineminus">-            continue;</span>
<a href="#l16.692"></a><span id="l16.692" class="difflineminus">-        }</span>
<a href="#l16.693"></a><span id="l16.693" class="difflineminus">-        pgp_rawpacket_t pktcp = {};</span>
<a href="#l16.694"></a><span id="l16.694" class="difflineminus">-        pktcp = *newpkt;</span>
<a href="#l16.695"></a><span id="l16.695" class="difflineminus">-        pktcp.raw = (uint8_t *) malloc(newpkt-&gt;length);</span>
<a href="#l16.696"></a><span id="l16.696" class="difflineminus">-        if (!pktcp.raw) {</span>
<a href="#l16.697"></a><span id="l16.697" class="difflineminus">-            RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l16.698"></a><span id="l16.698" class="difflineminus">-            return false;</span>
<a href="#l16.699"></a><span id="l16.699" class="difflineminus">-        }</span>
<a href="#l16.700"></a><span id="l16.700" class="difflineminus">-        memcpy(pktcp.raw, newpkt-&gt;raw, newpkt-&gt;length);</span>
<a href="#l16.701"></a><span id="l16.701" class="difflineminus">-        pgp_rawpacket_free(curpkt);</span>
<a href="#l16.702"></a><span id="l16.702" class="difflineminus">-        *curpkt = pktcp;</span>
<a href="#l16.703"></a><span id="l16.703" class="difflineminus">-        return true;</span>
<a href="#l16.704"></a><span id="l16.704" class="difflineminus">-    }</span>
<a href="#l16.705"></a><span id="l16.705" class="difflineminus">-    return false;</span>
<a href="#l16.706"></a><span id="l16.706" class="difflineminus">-}</span>
<a href="#l16.707"></a><span id="l16.707" class="difflineminus">-</span>
<a href="#l16.708"></a><span id="l16.708"> pgp_subsig_t *</span>
<a href="#l16.709"></a><span id="l16.709"> pgp_key_replace_signature(pgp_key_t *key, pgp_signature_t *oldsig, pgp_signature_t *newsig)</span>
<a href="#l16.710"></a><span id="l16.710"> {</span>
<a href="#l16.711"></a><span id="l16.711">     pgp_subsig_t *subsig = NULL;</span>
<a href="#l16.712"></a><span id="l16.712">     for (size_t i = 0; i &lt; pgp_key_get_subsig_count(key); i++) {</span>
<a href="#l16.713"></a><span id="l16.713">         subsig = pgp_key_get_subsig(key, i);</span>
<a href="#l16.714"></a><span id="l16.714">         if (signature_pkt_equal(&amp;subsig-&gt;sig, oldsig)) {</span>
<a href="#l16.715"></a><span id="l16.715">             break;</span>
<a href="#l16.716"></a><span id="l16.716">         }</span>
<a href="#l16.717"></a><span id="l16.717">         subsig = NULL;</span>
<a href="#l16.718"></a><span id="l16.718">     }</span>
<a href="#l16.719"></a><span id="l16.719">     if (!subsig) {</span>
<a href="#l16.720"></a><span id="l16.720">         return NULL;</span>
<a href="#l16.721"></a><span id="l16.721">     }</span>
<a href="#l16.722"></a><span id="l16.722"> </span>
<a href="#l16.723"></a><span id="l16.723">     /* create rawpackets here since oldsig may be equal to subsig */</span>
<a href="#l16.724"></a><span id="l16.724" class="difflineminus">-    pgp_rawpacket_t oldraw = {};</span>
<a href="#l16.725"></a><span id="l16.725" class="difflineminus">-    if (!pgp_signature_to_rawpacket(&amp;oldraw, oldsig)) {</span>
<a href="#l16.726"></a><span id="l16.726" class="difflineminus">-        RNP_LOG(&quot;failed to create old rawpacket&quot;);</span>
<a href="#l16.727"></a><span id="l16.727" class="difflineminus">-        return NULL;</span>
<a href="#l16.728"></a><span id="l16.728" class="difflineminus">-    }</span>
<a href="#l16.729"></a><span id="l16.729" class="difflineminus">-    pgp_rawpacket_t newraw = {};</span>
<a href="#l16.730"></a><span id="l16.730" class="difflineminus">-    if (!pgp_signature_to_rawpacket(&amp;newraw, newsig)) {</span>
<a href="#l16.731"></a><span id="l16.731" class="difflineminus">-        RNP_LOG(&quot;failed to create new rawpacket&quot;);</span>
<a href="#l16.732"></a><span id="l16.732" class="difflineminus">-        pgp_rawpacket_free(&amp;oldraw);</span>
<a href="#l16.733"></a><span id="l16.733" class="difflineplus">+    pgp_rawpacket_t oldraw;</span>
<a href="#l16.734"></a><span id="l16.734" class="difflineplus">+    pgp_rawpacket_t newraw;</span>
<a href="#l16.735"></a><span id="l16.735" class="difflineplus">+    try {</span>
<a href="#l16.736"></a><span id="l16.736" class="difflineplus">+        oldraw = *oldsig;</span>
<a href="#l16.737"></a><span id="l16.737" class="difflineplus">+        newraw = *newsig;</span>
<a href="#l16.738"></a><span id="l16.738" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.739"></a><span id="l16.739" class="difflineplus">+        RNP_LOG(&quot;failed to create rawpacket: %s&quot;, e.what());</span>
<a href="#l16.740"></a><span id="l16.740">         return NULL;</span>
<a href="#l16.741"></a><span id="l16.741">     }</span>
<a href="#l16.742"></a><span id="l16.742"> </span>
<a href="#l16.743"></a><span id="l16.743" class="difflineminus">-    /* replace subsig itself */</span>
<a href="#l16.744"></a><span id="l16.744" class="difflineplus">+    /* fill new subsig */</span>
<a href="#l16.745"></a><span id="l16.745">     pgp_subsig_t newsubsig = {};</span>
<a href="#l16.746"></a><span id="l16.746">     if (!pgp_subsig_from_signature(&amp;newsubsig, newsig)) {</span>
<a href="#l16.747"></a><span id="l16.747">         RNP_LOG(&quot;failed to fill subsig&quot;);</span>
<a href="#l16.748"></a><span id="l16.748" class="difflineminus">-        subsig = NULL;</span>
<a href="#l16.749"></a><span id="l16.749" class="difflineminus">-        goto done;</span>
<a href="#l16.750"></a><span id="l16.750" class="difflineplus">+        return NULL;</span>
<a href="#l16.751"></a><span id="l16.751">     }</span>
<a href="#l16.752"></a><span id="l16.752">     newsubsig.uid = subsig-&gt;uid;</span>
<a href="#l16.753"></a><span id="l16.753" class="difflineminus">-    pgp_subsig_free(subsig);</span>
<a href="#l16.754"></a><span id="l16.754" class="difflineminus">-    *subsig = newsubsig;</span>
<a href="#l16.755"></a><span id="l16.755" class="difflineplus">+    /* replace rawpacket */</span>
<a href="#l16.756"></a><span id="l16.756" class="difflineplus">+    try {</span>
<a href="#l16.757"></a><span id="l16.757" class="difflineplus">+        newsubsig.rawpkt = pgp_rawpacket_t(*newsig);</span>
<a href="#l16.758"></a><span id="l16.758" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.759"></a><span id="l16.759" class="difflineplus">+        RNP_LOG(&quot;failed to replace rawpacket: %s&quot;, e.what());</span>
<a href="#l16.760"></a><span id="l16.760" class="difflineplus">+        return NULL;</span>
<a href="#l16.761"></a><span id="l16.761" class="difflineplus">+    }</span>
<a href="#l16.762"></a><span id="l16.762"> </span>
<a href="#l16.763"></a><span id="l16.763" class="difflineminus">-    /* replace rawpacket */</span>
<a href="#l16.764"></a><span id="l16.764" class="difflineminus">-    if (!pgp_key_replace_rawpacket(key, &amp;oldraw, &amp;newraw)) {</span>
<a href="#l16.765"></a><span id="l16.765" class="difflineminus">-        RNP_LOG(&quot;failed to replace rawpacket&quot;);</span>
<a href="#l16.766"></a><span id="l16.766" class="difflineminus">-        subsig = NULL;</span>
<a href="#l16.767"></a><span id="l16.767" class="difflineminus">-    }</span>
<a href="#l16.768"></a><span id="l16.768" class="difflineminus">-done:</span>
<a href="#l16.769"></a><span id="l16.769" class="difflineminus">-    pgp_rawpacket_free(&amp;oldraw);</span>
<a href="#l16.770"></a><span id="l16.770" class="difflineminus">-    pgp_rawpacket_free(&amp;newraw);</span>
<a href="#l16.771"></a><span id="l16.771" class="difflineplus">+    *subsig = std::move(newsubsig);</span>
<a href="#l16.772"></a><span id="l16.772">     return subsig;</span>
<a href="#l16.773"></a><span id="l16.773"> }</span>
<a href="#l16.774"></a><span id="l16.774"> </span>
<a href="#l16.775"></a><span id="l16.775"> static bool</span>
<a href="#l16.776"></a><span id="l16.776"> pgp_sig_is_certification(const pgp_subsig_t *sig)</span>
<a href="#l16.777"></a><span id="l16.777"> {</span>
<a href="#l16.778"></a><span id="l16.778">     pgp_sig_type_t type = signature_get_type(&amp;sig-&gt;sig);</span>
<a href="#l16.779"></a><span id="l16.779">     return (type == PGP_CERT_CASUAL) || (type == PGP_CERT_GENERIC) ||</span>
<a href="#l16.780"></a><span id="l16.780" class="difflineat">@@ -1309,22 +1157,34 @@ pgp_subkey_refresh_data(pgp_key_t *sub, </span>
<a href="#l16.781"></a><span id="l16.781">     /* revocation */</span>
<a href="#l16.782"></a><span id="l16.782">     pgp_key_clear_revokes(sub);</span>
<a href="#l16.783"></a><span id="l16.783">     for (size_t i = 0; i &lt; pgp_key_get_subsig_count(sub); i++) {</span>
<a href="#l16.784"></a><span id="l16.784">         sig = pgp_key_get_subsig(sub, i);</span>
<a href="#l16.785"></a><span id="l16.785">         if (!sig-&gt;valid || !pgp_sig_is_subkey_revocation(sub, sig)) {</span>
<a href="#l16.786"></a><span id="l16.786">             continue;</span>
<a href="#l16.787"></a><span id="l16.787">         }</span>
<a href="#l16.788"></a><span id="l16.788">         sub-&gt;revoked = true;</span>
<a href="#l16.789"></a><span id="l16.789" class="difflineminus">-        signature_get_revocation_reason(</span>
<a href="#l16.790"></a><span id="l16.790" class="difflineminus">-          &amp;sig-&gt;sig, &amp;sub-&gt;revocation.code, &amp;sub-&gt;revocation.reason);</span>
<a href="#l16.791"></a><span id="l16.791" class="difflineminus">-        if (!strlen(sub-&gt;revocation.reason)) {</span>
<a href="#l16.792"></a><span id="l16.792" class="difflineminus">-            free(sub-&gt;revocation.reason);</span>
<a href="#l16.793"></a><span id="l16.793" class="difflineminus">-            sub-&gt;revocation.reason =</span>
<a href="#l16.794"></a><span id="l16.794" class="difflineminus">-              strdup(pgp_str_from_map(sub-&gt;revocation.code, ss_rr_code_map));</span>
<a href="#l16.795"></a><span id="l16.795" class="difflineplus">+        char *reason = NULL;</span>
<a href="#l16.796"></a><span id="l16.796" class="difflineplus">+        if (!signature_has_revocation_reason(&amp;sig-&gt;sig)) {</span>
<a href="#l16.797"></a><span id="l16.797" class="difflineplus">+            RNP_LOG(&quot;Warning: no revocation reason in subkey revocation&quot;);</span>
<a href="#l16.798"></a><span id="l16.798" class="difflineplus">+            sub-&gt;revocation.code = PGP_REVOCATION_NO_REASON;</span>
<a href="#l16.799"></a><span id="l16.799" class="difflineplus">+        } else if (!signature_get_revocation_reason(</span>
<a href="#l16.800"></a><span id="l16.800" class="difflineplus">+                     &amp;sig-&gt;sig, &amp;sub-&gt;revocation.code, &amp;reason)) {</span>
<a href="#l16.801"></a><span id="l16.801" class="difflineplus">+            return false;</span>
<a href="#l16.802"></a><span id="l16.802" class="difflineplus">+        }</span>
<a href="#l16.803"></a><span id="l16.803" class="difflineplus">+</span>
<a href="#l16.804"></a><span id="l16.804" class="difflineplus">+        try {</span>
<a href="#l16.805"></a><span id="l16.805" class="difflineplus">+            sub-&gt;revocation.reason = (reason &amp;&amp; strlen(reason)) ?</span>
<a href="#l16.806"></a><span id="l16.806" class="difflineplus">+                                       reason :</span>
<a href="#l16.807"></a><span id="l16.807" class="difflineplus">+                                       pgp_str_from_map(sub-&gt;revocation.code, ss_rr_code_map);</span>
<a href="#l16.808"></a><span id="l16.808" class="difflineplus">+            free(reason);</span>
<a href="#l16.809"></a><span id="l16.809" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l16.810"></a><span id="l16.810" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.811"></a><span id="l16.811" class="difflineplus">+            free(reason);</span>
<a href="#l16.812"></a><span id="l16.812" class="difflineplus">+            return false;</span>
<a href="#l16.813"></a><span id="l16.813">         }</span>
<a href="#l16.814"></a><span id="l16.814">         break;</span>
<a href="#l16.815"></a><span id="l16.815">     }</span>
<a href="#l16.816"></a><span id="l16.816">     return true;</span>
<a href="#l16.817"></a><span id="l16.817"> }</span>
<a href="#l16.818"></a><span id="l16.818"> </span>
<a href="#l16.819"></a><span id="l16.819"> bool</span>
<a href="#l16.820"></a><span id="l16.820"> pgp_key_refresh_data(pgp_key_t *key)</span>
<a href="#l16.821"></a><span id="l16.821" class="difflineat">@@ -1379,158 +1239,98 @@ pgp_key_refresh_data(pgp_key_t *key)</span>
<a href="#l16.822"></a><span id="l16.822">             }</span>
<a href="#l16.823"></a><span id="l16.823">             revocation-&gt;uid = sig-&gt;uid;</span>
<a href="#l16.824"></a><span id="l16.824">         }</span>
<a href="#l16.825"></a><span id="l16.825"> </span>
<a href="#l16.826"></a><span id="l16.826">         if (!revocation) {</span>
<a href="#l16.827"></a><span id="l16.827">             continue;</span>
<a href="#l16.828"></a><span id="l16.828">         }</span>
<a href="#l16.829"></a><span id="l16.829"> </span>
<a href="#l16.830"></a><span id="l16.830" class="difflineminus">-        signature_get_revocation_reason(&amp;sig-&gt;sig, &amp;revocation-&gt;code, &amp;revocation-&gt;reason);</span>
<a href="#l16.831"></a><span id="l16.831" class="difflineminus">-        if (!strlen(revocation-&gt;reason)) {</span>
<a href="#l16.832"></a><span id="l16.832" class="difflineminus">-            free(revocation-&gt;reason);</span>
<a href="#l16.833"></a><span id="l16.833" class="difflineminus">-            revocation-&gt;reason = strdup(pgp_str_from_map(revocation-&gt;code, ss_rr_code_map));</span>
<a href="#l16.834"></a><span id="l16.834" class="difflineplus">+        char *reason = NULL;</span>
<a href="#l16.835"></a><span id="l16.835" class="difflineplus">+        if (!signature_has_revocation_reason(&amp;sig-&gt;sig)) {</span>
<a href="#l16.836"></a><span id="l16.836" class="difflineplus">+            RNP_LOG(&quot;Warning: no revocation reason in key/userid revocation&quot;);</span>
<a href="#l16.837"></a><span id="l16.837" class="difflineplus">+            revocation-&gt;code = PGP_REVOCATION_NO_REASON;</span>
<a href="#l16.838"></a><span id="l16.838" class="difflineplus">+        } else if (!signature_get_revocation_reason(&amp;sig-&gt;sig, &amp;revocation-&gt;code, &amp;reason)) {</span>
<a href="#l16.839"></a><span id="l16.839" class="difflineplus">+            return false;</span>
<a href="#l16.840"></a><span id="l16.840" class="difflineplus">+        }</span>
<a href="#l16.841"></a><span id="l16.841" class="difflineplus">+</span>
<a href="#l16.842"></a><span id="l16.842" class="difflineplus">+        try {</span>
<a href="#l16.843"></a><span id="l16.843" class="difflineplus">+            revocation-&gt;reason = (reason &amp;&amp; strlen(reason)) ?</span>
<a href="#l16.844"></a><span id="l16.844" class="difflineplus">+                                   reason :</span>
<a href="#l16.845"></a><span id="l16.845" class="difflineplus">+                                   pgp_str_from_map(revocation-&gt;code, ss_rr_code_map);</span>
<a href="#l16.846"></a><span id="l16.846" class="difflineplus">+            free(reason);</span>
<a href="#l16.847"></a><span id="l16.847" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l16.848"></a><span id="l16.848" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.849"></a><span id="l16.849" class="difflineplus">+            free(reason);</span>
<a href="#l16.850"></a><span id="l16.850" class="difflineplus">+            return false;</span>
<a href="#l16.851"></a><span id="l16.851">         }</span>
<a href="#l16.852"></a><span id="l16.852">     }</span>
<a href="#l16.853"></a><span id="l16.853"> </span>
<a href="#l16.854"></a><span id="l16.854">     return true;</span>
<a href="#l16.855"></a><span id="l16.855"> }</span>
<a href="#l16.856"></a><span id="l16.856"> </span>
<a href="#l16.857"></a><span id="l16.857" class="difflineminus">-pgp_rawpacket_t *</span>
<a href="#l16.858"></a><span id="l16.858" class="difflineminus">-pgp_key_add_rawpacket(pgp_key_t *key, void *data, size_t len, pgp_pkt_type_t tag)</span>
<a href="#l16.859"></a><span id="l16.859" class="difflineminus">-{</span>
<a href="#l16.860"></a><span id="l16.860" class="difflineminus">-    pgp_rawpacket_t *packet;</span>
<a href="#l16.861"></a><span id="l16.861" class="difflineminus">-</span>
<a href="#l16.862"></a><span id="l16.862" class="difflineminus">-    try {</span>
<a href="#l16.863"></a><span id="l16.863" class="difflineminus">-        key-&gt;packets.push_back({});</span>
<a href="#l16.864"></a><span id="l16.864" class="difflineminus">-        packet = &amp;key-&gt;packets.back();</span>
<a href="#l16.865"></a><span id="l16.865" class="difflineminus">-    } catch (...) {</span>
<a href="#l16.866"></a><span id="l16.866" class="difflineminus">-        return NULL;</span>
<a href="#l16.867"></a><span id="l16.867" class="difflineminus">-    }</span>
<a href="#l16.868"></a><span id="l16.868" class="difflineminus">-</span>
<a href="#l16.869"></a><span id="l16.869" class="difflineminus">-    if (data) {</span>
<a href="#l16.870"></a><span id="l16.870" class="difflineminus">-        if (!(packet-&gt;raw = (uint8_t *) malloc(len))) {</span>
<a href="#l16.871"></a><span id="l16.871" class="difflineminus">-            key-&gt;packets.pop_back();</span>
<a href="#l16.872"></a><span id="l16.872" class="difflineminus">-            return NULL;</span>
<a href="#l16.873"></a><span id="l16.873" class="difflineminus">-        }</span>
<a href="#l16.874"></a><span id="l16.874" class="difflineminus">-        memcpy(packet-&gt;raw, data, len);</span>
<a href="#l16.875"></a><span id="l16.875" class="difflineminus">-    }</span>
<a href="#l16.876"></a><span id="l16.876" class="difflineminus">-    packet-&gt;length = len;</span>
<a href="#l16.877"></a><span id="l16.877" class="difflineminus">-    packet-&gt;tag = tag;</span>
<a href="#l16.878"></a><span id="l16.878" class="difflineminus">-    return packet;</span>
<a href="#l16.879"></a><span id="l16.879" class="difflineminus">-}</span>
<a href="#l16.880"></a><span id="l16.880" class="difflineminus">-</span>
<a href="#l16.881"></a><span id="l16.881" class="difflineminus">-static pgp_rawpacket_t *</span>
<a href="#l16.882"></a><span id="l16.882" class="difflineminus">-pgp_key_add_stream_rawpacket(pgp_key_t *key, pgp_pkt_type_t tag, pgp_dest_t *memdst)</span>
<a href="#l16.883"></a><span id="l16.883" class="difflineminus">-{</span>
<a href="#l16.884"></a><span id="l16.884" class="difflineminus">-    pgp_rawpacket_t *res =</span>
<a href="#l16.885"></a><span id="l16.885" class="difflineminus">-      pgp_key_add_rawpacket(key, mem_dest_get_memory(memdst), memdst-&gt;writeb, tag);</span>
<a href="#l16.886"></a><span id="l16.886" class="difflineminus">-    if (!res) {</span>
<a href="#l16.887"></a><span id="l16.887" class="difflineminus">-        RNP_LOG(&quot;Failed to add packet&quot;);</span>
<a href="#l16.888"></a><span id="l16.888" class="difflineminus">-    }</span>
<a href="#l16.889"></a><span id="l16.889" class="difflineminus">-    dst_close(memdst, true);</span>
<a href="#l16.890"></a><span id="l16.890" class="difflineminus">-    return res;</span>
<a href="#l16.891"></a><span id="l16.891" class="difflineminus">-}</span>
<a href="#l16.892"></a><span id="l16.892" class="difflineminus">-</span>
<a href="#l16.893"></a><span id="l16.893" class="difflineminus">-pgp_rawpacket_t *</span>
<a href="#l16.894"></a><span id="l16.894" class="difflineminus">-pgp_key_add_key_rawpacket(pgp_key_t *key, pgp_key_pkt_t *pkt)</span>
<a href="#l16.895"></a><span id="l16.895" class="difflineminus">-{</span>
<a href="#l16.896"></a><span id="l16.896" class="difflineminus">-    pgp_dest_t dst = {};</span>
<a href="#l16.897"></a><span id="l16.897" class="difflineminus">-</span>
<a href="#l16.898"></a><span id="l16.898" class="difflineminus">-    if (init_mem_dest(&amp;dst, NULL, 0)) {</span>
<a href="#l16.899"></a><span id="l16.899" class="difflineminus">-        return NULL;</span>
<a href="#l16.900"></a><span id="l16.900" class="difflineminus">-    }</span>
<a href="#l16.901"></a><span id="l16.901" class="difflineminus">-    if (!stream_write_key(pkt, &amp;dst)) {</span>
<a href="#l16.902"></a><span id="l16.902" class="difflineminus">-        dst_close(&amp;dst, true);</span>
<a href="#l16.903"></a><span id="l16.903" class="difflineminus">-        return NULL;</span>
<a href="#l16.904"></a><span id="l16.904" class="difflineminus">-    }</span>
<a href="#l16.905"></a><span id="l16.905" class="difflineminus">-    return pgp_key_add_stream_rawpacket(key, (pgp_pkt_type_t) pkt-&gt;tag, &amp;dst);</span>
<a href="#l16.906"></a><span id="l16.906" class="difflineminus">-}</span>
<a href="#l16.907"></a><span id="l16.907" class="difflineminus">-</span>
<a href="#l16.908"></a><span id="l16.908" class="difflineminus">-pgp_rawpacket_t *</span>
<a href="#l16.909"></a><span id="l16.909" class="difflineminus">-pgp_key_add_sig_rawpacket(pgp_key_t *key, const pgp_signature_t *pkt)</span>
<a href="#l16.910"></a><span id="l16.910" class="difflineminus">-{</span>
<a href="#l16.911"></a><span id="l16.911" class="difflineminus">-    pgp_rawpacket_t rawpkt = {};</span>
<a href="#l16.912"></a><span id="l16.912" class="difflineminus">-    if (!pgp_signature_to_rawpacket(&amp;rawpkt, pkt)) {</span>
<a href="#l16.913"></a><span id="l16.913" class="difflineminus">-        return NULL;</span>
<a href="#l16.914"></a><span id="l16.914" class="difflineminus">-    }</span>
<a href="#l16.915"></a><span id="l16.915" class="difflineminus">-    try {</span>
<a href="#l16.916"></a><span id="l16.916" class="difflineminus">-        key-&gt;packets.push_back(rawpkt);</span>
<a href="#l16.917"></a><span id="l16.917" class="difflineminus">-        return &amp;key-&gt;packets.back();</span>
<a href="#l16.918"></a><span id="l16.918" class="difflineminus">-    } catch (...) {</span>
<a href="#l16.919"></a><span id="l16.919" class="difflineminus">-        pgp_rawpacket_free(&amp;rawpkt);</span>
<a href="#l16.920"></a><span id="l16.920" class="difflineminus">-        return NULL;</span>
<a href="#l16.921"></a><span id="l16.921" class="difflineminus">-    }</span>
<a href="#l16.922"></a><span id="l16.922" class="difflineminus">-}</span>
<a href="#l16.923"></a><span id="l16.923" class="difflineminus">-</span>
<a href="#l16.924"></a><span id="l16.924" class="difflineminus">-pgp_rawpacket_t *</span>
<a href="#l16.925"></a><span id="l16.925" class="difflineminus">-pgp_key_add_uid_rawpacket(pgp_key_t *key, const pgp_userid_pkt_t *pkt)</span>
<a href="#l16.926"></a><span id="l16.926" class="difflineminus">-{</span>
<a href="#l16.927"></a><span id="l16.927" class="difflineminus">-    pgp_dest_t dst = {};</span>
<a href="#l16.928"></a><span id="l16.928" class="difflineminus">-</span>
<a href="#l16.929"></a><span id="l16.929" class="difflineminus">-    if (init_mem_dest(&amp;dst, NULL, 0)) {</span>
<a href="#l16.930"></a><span id="l16.930" class="difflineminus">-        return NULL;</span>
<a href="#l16.931"></a><span id="l16.931" class="difflineminus">-    }</span>
<a href="#l16.932"></a><span id="l16.932" class="difflineminus">-    if (!stream_write_userid(pkt, &amp;dst)) {</span>
<a href="#l16.933"></a><span id="l16.933" class="difflineminus">-        dst_close(&amp;dst, true);</span>
<a href="#l16.934"></a><span id="l16.934" class="difflineminus">-        return NULL;</span>
<a href="#l16.935"></a><span id="l16.935" class="difflineminus">-    }</span>
<a href="#l16.936"></a><span id="l16.936" class="difflineminus">-    return pgp_key_add_stream_rawpacket(key, (pgp_pkt_type_t) pkt-&gt;tag, &amp;dst);</span>
<a href="#l16.937"></a><span id="l16.937" class="difflineminus">-}</span>
<a href="#l16.938"></a><span id="l16.938" class="difflineminus">-</span>
<a href="#l16.939"></a><span id="l16.939"> size_t</span>
<a href="#l16.940"></a><span id="l16.940"> pgp_key_get_rawpacket_count(const pgp_key_t *key)</span>
<a href="#l16.941"></a><span id="l16.941"> {</span>
<a href="#l16.942"></a><span id="l16.942" class="difflineminus">-    return key-&gt;packets.size();</span>
<a href="#l16.943"></a><span id="l16.943" class="difflineplus">+    if (key-&gt;format == PGP_KEY_STORE_G10) {</span>
<a href="#l16.944"></a><span id="l16.944" class="difflineplus">+        return 1;</span>
<a href="#l16.945"></a><span id="l16.945" class="difflineplus">+    }</span>
<a href="#l16.946"></a><span id="l16.946" class="difflineplus">+    return 1 + key-&gt;uids.size() + key-&gt;subsigs.size();</span>
<a href="#l16.947"></a><span id="l16.947"> }</span>
<a href="#l16.948"></a><span id="l16.948"> </span>
<a href="#l16.949"></a><span id="l16.949" class="difflineminus">-const pgp_rawpacket_t *</span>
<a href="#l16.950"></a><span id="l16.950" class="difflineminus">-pgp_key_get_rawpacket(const pgp_key_t *key, size_t idx)</span>
<a href="#l16.951"></a><span id="l16.951" class="difflineplus">+pgp_rawpacket_t &amp;</span>
<a href="#l16.952"></a><span id="l16.952" class="difflineplus">+pgp_key_get_rawpacket(pgp_key_t *key)</span>
<a href="#l16.953"></a><span id="l16.953"> {</span>
<a href="#l16.954"></a><span id="l16.954" class="difflineminus">-    return (idx &lt; key-&gt;packets.size()) ? &amp;key-&gt;packets[idx] : NULL;</span>
<a href="#l16.955"></a><span id="l16.955" class="difflineplus">+    return key-&gt;rawpkt;</span>
<a href="#l16.956"></a><span id="l16.956"> }</span>
<a href="#l16.957"></a><span id="l16.957" class="difflineminus">-</span>
<a href="#l16.958"></a><span id="l16.958" class="difflineminus">-pgp_rawpacket_t *</span>
<a href="#l16.959"></a><span id="l16.959" class="difflineminus">-pgp_key_get_rawpacket(pgp_key_t *key, size_t idx)</span>
<a href="#l16.960"></a><span id="l16.960" class="difflineplus">+const pgp_rawpacket_t &amp;</span>
<a href="#l16.961"></a><span id="l16.961" class="difflineplus">+pgp_key_get_rawpacket(const pgp_key_t *key)</span>
<a href="#l16.962"></a><span id="l16.962"> {</span>
<a href="#l16.963"></a><span id="l16.963" class="difflineminus">-    return (idx &lt; key-&gt;packets.size()) ? &amp;key-&gt;packets[idx] : NULL;</span>
<a href="#l16.964"></a><span id="l16.964" class="difflineplus">+    return key-&gt;rawpkt;</span>
<a href="#l16.965"></a><span id="l16.965"> }</span>
<a href="#l16.966"></a><span id="l16.966"> </span>
<a href="#l16.967"></a><span id="l16.967"> size_t</span>
<a href="#l16.968"></a><span id="l16.968"> pgp_key_get_subkey_count(const pgp_key_t *key)</span>
<a href="#l16.969"></a><span id="l16.969"> {</span>
<a href="#l16.970"></a><span id="l16.970" class="difflineminus">-    return list_length(key-&gt;subkey_grips);</span>
<a href="#l16.971"></a><span id="l16.971" class="difflineplus">+    return key-&gt;subkey_grips.size();</span>
<a href="#l16.972"></a><span id="l16.972"> }</span>
<a href="#l16.973"></a><span id="l16.973"> </span>
<a href="#l16.974"></a><span id="l16.974"> bool</span>
<a href="#l16.975"></a><span id="l16.975" class="difflineminus">-pgp_key_add_subkey_grip(pgp_key_t *key, const uint8_t *grip)</span>
<a href="#l16.976"></a><span id="l16.976" class="difflineplus">+pgp_key_add_subkey_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip)</span>
<a href="#l16.977"></a><span id="l16.977"> {</span>
<a href="#l16.978"></a><span id="l16.978" class="difflineminus">-    for (list_item *li = list_front(key-&gt;subkey_grips); li; li = list_next(li)) {</span>
<a href="#l16.979"></a><span id="l16.979" class="difflineminus">-        if (!memcmp(grip, (uint8_t *) li, PGP_KEY_GRIP_SIZE)) {</span>
<a href="#l16.980"></a><span id="l16.980" class="difflineminus">-            return true;</span>
<a href="#l16.981"></a><span id="l16.981" class="difflineminus">-        }</span>
<a href="#l16.982"></a><span id="l16.982" class="difflineplus">+    if (std::find(key-&gt;subkey_grips.begin(), key-&gt;subkey_grips.end(), grip) !=</span>
<a href="#l16.983"></a><span id="l16.983" class="difflineplus">+        key-&gt;subkey_grips.end()) {</span>
<a href="#l16.984"></a><span id="l16.984" class="difflineplus">+        return true;</span>
<a href="#l16.985"></a><span id="l16.985">     }</span>
<a href="#l16.986"></a><span id="l16.986"> </span>
<a href="#l16.987"></a><span id="l16.987" class="difflineminus">-    return list_append(&amp;key-&gt;subkey_grips, grip, PGP_KEY_GRIP_SIZE);</span>
<a href="#l16.988"></a><span id="l16.988" class="difflineplus">+    try {</span>
<a href="#l16.989"></a><span id="l16.989" class="difflineplus">+        key-&gt;subkey_grips.push_back(grip);</span>
<a href="#l16.990"></a><span id="l16.990" class="difflineplus">+        return true;</span>
<a href="#l16.991"></a><span id="l16.991" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.992"></a><span id="l16.992" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.993"></a><span id="l16.993" class="difflineplus">+        return false;</span>
<a href="#l16.994"></a><span id="l16.994" class="difflineplus">+    }</span>
<a href="#l16.995"></a><span id="l16.995"> }</span>
<a href="#l16.996"></a><span id="l16.996"> </span>
<a href="#l16.997"></a><span id="l16.997" class="difflineminus">-const uint8_t *</span>
<a href="#l16.998"></a><span id="l16.998" class="difflineplus">+const pgp_key_grip_t &amp;</span>
<a href="#l16.999"></a><span id="l16.999"> pgp_key_get_subkey_grip(const pgp_key_t *key, size_t idx)</span>
<a href="#l16.1000"></a><span id="l16.1000"> {</span>
<a href="#l16.1001"></a><span id="l16.1001" class="difflineminus">-    return (uint8_t *) list_at(key-&gt;subkey_grips, idx);</span>
<a href="#l16.1002"></a><span id="l16.1002" class="difflineplus">+    return key-&gt;subkey_grips[idx];</span>
<a href="#l16.1003"></a><span id="l16.1003"> }</span>
<a href="#l16.1004"></a><span id="l16.1004"> </span>
<a href="#l16.1005"></a><span id="l16.1005"> pgp_key_t *</span>
<a href="#l16.1006"></a><span id="l16.1006" class="difflineminus">-pgp_key_get_subkey(const pgp_key_t *key, const rnp_key_store_t *store, size_t idx)</span>
<a href="#l16.1007"></a><span id="l16.1007" class="difflineplus">+pgp_key_get_subkey(const pgp_key_t *key, rnp_key_store_t *store, size_t idx)</span>
<a href="#l16.1008"></a><span id="l16.1008"> {</span>
<a href="#l16.1009"></a><span id="l16.1009" class="difflineminus">-    uint8_t *grip = (uint8_t *) list_at(key-&gt;subkey_grips, idx);</span>
<a href="#l16.1010"></a><span id="l16.1010" class="difflineminus">-    if (!grip) {</span>
<a href="#l16.1011"></a><span id="l16.1011" class="difflineplus">+    try {</span>
<a href="#l16.1012"></a><span id="l16.1012" class="difflineplus">+        const pgp_key_grip_t &amp;grip = pgp_key_get_subkey_grip(key, idx);</span>
<a href="#l16.1013"></a><span id="l16.1013" class="difflineplus">+        return rnp_key_store_get_key_by_grip(store, grip);</span>
<a href="#l16.1014"></a><span id="l16.1014" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.1015"></a><span id="l16.1015" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.1016"></a><span id="l16.1016">         return NULL;</span>
<a href="#l16.1017"></a><span id="l16.1017">     }</span>
<a href="#l16.1018"></a><span id="l16.1018" class="difflineminus">-    return rnp_key_store_get_key_by_grip(store, grip);</span>
<a href="#l16.1019"></a><span id="l16.1019"> }</span>
<a href="#l16.1020"></a><span id="l16.1020"> </span>
<a href="#l16.1021"></a><span id="l16.1021"> pgp_key_flags_t</span>
<a href="#l16.1022"></a><span id="l16.1022"> pgp_pk_alg_capabilities(pgp_pubkey_alg_t alg)</span>
<a href="#l16.1023"></a><span id="l16.1023"> {</span>
<a href="#l16.1024"></a><span id="l16.1024">     switch (alg) {</span>
<a href="#l16.1025"></a><span id="l16.1025">     case PGP_PKA_RSA:</span>
<a href="#l16.1026"></a><span id="l16.1026">         return pgp_key_flags_t(PGP_KF_SIGN | PGP_KF_CERTIFY | PGP_KF_AUTH | PGP_KF_ENCRYPT);</span>
<a href="#l16.1027"></a><span id="l16.1027" class="difflineat">@@ -1646,17 +1446,17 @@ pgp_write_seckey(pgp_dest_t *   dst,</span>
<a href="#l16.1028"></a><span id="l16.1028">     res = stream_write_key(seckey, dst);</span>
<a href="#l16.1029"></a><span id="l16.1029"> done:</span>
<a href="#l16.1030"></a><span id="l16.1030">     seckey-&gt;tag = oldtag;</span>
<a href="#l16.1031"></a><span id="l16.1031">     return res;</span>
<a href="#l16.1032"></a><span id="l16.1032"> }</span>
<a href="#l16.1033"></a><span id="l16.1033"> </span>
<a href="#l16.1034"></a><span id="l16.1034"> static bool</span>
<a href="#l16.1035"></a><span id="l16.1035"> write_key_to_rawpacket(pgp_key_pkt_t *        seckey,</span>
<a href="#l16.1036"></a><span id="l16.1036" class="difflineminus">-                       pgp_rawpacket_t *      packet,</span>
<a href="#l16.1037"></a><span id="l16.1037" class="difflineplus">+                       pgp_rawpacket_t &amp;      packet,</span>
<a href="#l16.1038"></a><span id="l16.1038">                        pgp_pkt_type_t         type,</span>
<a href="#l16.1039"></a><span id="l16.1039">                        pgp_key_store_format_t format,</span>
<a href="#l16.1040"></a><span id="l16.1040">                        const char *           password)</span>
<a href="#l16.1041"></a><span id="l16.1041"> {</span>
<a href="#l16.1042"></a><span id="l16.1042">     pgp_dest_t memdst = {};</span>
<a href="#l16.1043"></a><span id="l16.1043">     bool       ret = false;</span>
<a href="#l16.1044"></a><span id="l16.1044"> </span>
<a href="#l16.1045"></a><span id="l16.1045">     if (init_mem_dest(&amp;memdst, NULL, 0)) {</span>
<a href="#l16.1046"></a><span id="l16.1046" class="difflineat">@@ -1676,23 +1476,25 @@ write_key_to_rawpacket(pgp_key_pkt_t *  </span>
<a href="#l16.1047"></a><span id="l16.1047">         if (!g10_write_seckey(&amp;memdst, seckey, password)) {</span>
<a href="#l16.1048"></a><span id="l16.1048">             RNP_LOG(&quot;failed to write g10 seckey&quot;);</span>
<a href="#l16.1049"></a><span id="l16.1049">             goto done;</span>
<a href="#l16.1050"></a><span id="l16.1050">         }</span>
<a href="#l16.1051"></a><span id="l16.1051">         break;</span>
<a href="#l16.1052"></a><span id="l16.1052">     default:</span>
<a href="#l16.1053"></a><span id="l16.1053">         RNP_LOG(&quot;invalid format&quot;);</span>
<a href="#l16.1054"></a><span id="l16.1054">         goto done;</span>
<a href="#l16.1055"></a><span id="l16.1055" class="difflineminus">-        break;</span>
<a href="#l16.1056"></a><span id="l16.1056">     }</span>
<a href="#l16.1057"></a><span id="l16.1057" class="difflineminus">-    // free the existing data if needed</span>
<a href="#l16.1058"></a><span id="l16.1058" class="difflineminus">-    pgp_rawpacket_free(packet);</span>
<a href="#l16.1059"></a><span id="l16.1059" class="difflineminus">-    // take ownership of this memory</span>
<a href="#l16.1060"></a><span id="l16.1060" class="difflineminus">-    packet-&gt;raw = (uint8_t *) mem_dest_own_memory(&amp;memdst);</span>
<a href="#l16.1061"></a><span id="l16.1061" class="difflineminus">-    packet-&gt;length = memdst.writeb;</span>
<a href="#l16.1062"></a><span id="l16.1062" class="difflineplus">+</span>
<a href="#l16.1063"></a><span id="l16.1063" class="difflineplus">+    try {</span>
<a href="#l16.1064"></a><span id="l16.1064" class="difflineplus">+        uint8_t *mem = (uint8_t *) mem_dest_get_memory(&amp;memdst);</span>
<a href="#l16.1065"></a><span id="l16.1065" class="difflineplus">+        packet = pgp_rawpacket_t(mem, memdst.writeb, type);</span>
<a href="#l16.1066"></a><span id="l16.1066" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.1067"></a><span id="l16.1067" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.1068"></a><span id="l16.1068" class="difflineplus">+        goto done;</span>
<a href="#l16.1069"></a><span id="l16.1069" class="difflineplus">+    }</span>
<a href="#l16.1070"></a><span id="l16.1070">     ret = true;</span>
<a href="#l16.1071"></a><span id="l16.1071"> done:</span>
<a href="#l16.1072"></a><span id="l16.1072">     dst_close(&amp;memdst, true);</span>
<a href="#l16.1073"></a><span id="l16.1073">     return ret;</span>
<a href="#l16.1074"></a><span id="l16.1074"> }</span>
<a href="#l16.1075"></a><span id="l16.1075"> </span>
<a href="#l16.1076"></a><span id="l16.1076"> bool</span>
<a href="#l16.1077"></a><span id="l16.1077"> rnp_key_add_protection(pgp_key_t *                    key,</span>
<a href="#l16.1078"></a><span id="l16.1078" class="difflineat">@@ -1772,19 +1574,19 @@ pgp_key_protect(pgp_key_t *             </span>
<a href="#l16.1079"></a><span id="l16.1079">           pgp_s2k_compute_iters(protection-&gt;hash_alg, DEFAULT_S2K_MSEC, DEFAULT_S2K_TUNE_MSEC);</span>
<a href="#l16.1080"></a><span id="l16.1080">     }</span>
<a href="#l16.1081"></a><span id="l16.1081"> </span>
<a href="#l16.1082"></a><span id="l16.1082">     seckey-&gt;sec_protection.symm_alg = protection-&gt;symm_alg;</span>
<a href="#l16.1083"></a><span id="l16.1083">     seckey-&gt;sec_protection.cipher_mode = protection-&gt;cipher_mode;</span>
<a href="#l16.1084"></a><span id="l16.1084">     seckey-&gt;sec_protection.s2k.iterations = pgp_s2k_round_iterations(protection-&gt;iterations);</span>
<a href="#l16.1085"></a><span id="l16.1085">     seckey-&gt;sec_protection.s2k.hash_alg = protection-&gt;hash_alg;</span>
<a href="#l16.1086"></a><span id="l16.1086"> </span>
<a href="#l16.1087"></a><span id="l16.1087" class="difflineminus">-    // write the protected key to packets[0]</span>
<a href="#l16.1088"></a><span id="l16.1088" class="difflineplus">+    // write the protected key to raw packet</span>
<a href="#l16.1089"></a><span id="l16.1089">     if (!write_key_to_rawpacket(decrypted_seckey,</span>
<a href="#l16.1090"></a><span id="l16.1090" class="difflineminus">-                                pgp_key_get_rawpacket(key, 0),</span>
<a href="#l16.1091"></a><span id="l16.1091" class="difflineplus">+                                pgp_key_get_rawpacket(key),</span>
<a href="#l16.1092"></a><span id="l16.1092">                                 pgp_key_get_type(key),</span>
<a href="#l16.1093"></a><span id="l16.1093">                                 format,</span>
<a href="#l16.1094"></a><span id="l16.1094">                                 new_password)) {</span>
<a href="#l16.1095"></a><span id="l16.1095">         goto done;</span>
<a href="#l16.1096"></a><span id="l16.1096">     }</span>
<a href="#l16.1097"></a><span id="l16.1097">     key-&gt;format = format;</span>
<a href="#l16.1098"></a><span id="l16.1098">     ret = true;</span>
<a href="#l16.1099"></a><span id="l16.1099"> </span>
<a href="#l16.1100"></a><span id="l16.1100" class="difflineat">@@ -1821,17 +1623,17 @@ pgp_key_unprotect(pgp_key_t *key, const </span>
<a href="#l16.1101"></a><span id="l16.1101">         decrypted_seckey = pgp_decrypt_seckey(key, password_provider, &amp;ctx);</span>
<a href="#l16.1102"></a><span id="l16.1102">         if (!decrypted_seckey) {</span>
<a href="#l16.1103"></a><span id="l16.1103">             goto done;</span>
<a href="#l16.1104"></a><span id="l16.1104">         }</span>
<a href="#l16.1105"></a><span id="l16.1105">         seckey = decrypted_seckey;</span>
<a href="#l16.1106"></a><span id="l16.1106">     }</span>
<a href="#l16.1107"></a><span id="l16.1107">     seckey-&gt;sec_protection.s2k.usage = PGP_S2KU_NONE;</span>
<a href="#l16.1108"></a><span id="l16.1108">     if (!write_key_to_rawpacket(</span>
<a href="#l16.1109"></a><span id="l16.1109" class="difflineminus">-          seckey, pgp_key_get_rawpacket(key, 0), pgp_key_get_type(key), key-&gt;format, NULL)) {</span>
<a href="#l16.1110"></a><span id="l16.1110" class="difflineplus">+          seckey, pgp_key_get_rawpacket(key), pgp_key_get_type(key), key-&gt;format, NULL)) {</span>
<a href="#l16.1111"></a><span id="l16.1111">         goto done;</span>
<a href="#l16.1112"></a><span id="l16.1112">     }</span>
<a href="#l16.1113"></a><span id="l16.1113">     if (decrypted_seckey) {</span>
<a href="#l16.1114"></a><span id="l16.1114">         free_key_pkt(&amp;key-&gt;pkt);</span>
<a href="#l16.1115"></a><span id="l16.1115">         copy_key_pkt(&amp;key-&gt;pkt, decrypted_seckey, false);</span>
<a href="#l16.1116"></a><span id="l16.1116">         /* current logic is that unprotected key should be additionally unlocked */</span>
<a href="#l16.1117"></a><span id="l16.1117">         forget_secret_key_fields(&amp;key-&gt;pkt.material);</span>
<a href="#l16.1118"></a><span id="l16.1118">     }</span>
<a href="#l16.1119"></a><span id="l16.1119" class="difflineat">@@ -2031,119 +1833,107 @@ pgp_subkey_set_expiration(pgp_key_t *sub</span>
<a href="#l16.1120"></a><span id="l16.1120">     }</span>
<a href="#l16.1121"></a><span id="l16.1121">     res = res &amp;&amp; pgp_key_replace_signature(sub, &amp;subsig-&gt;sig, &amp;newsig) &amp;&amp;</span>
<a href="#l16.1122"></a><span id="l16.1122">           pgp_subkey_refresh_data(sub, primsec);</span>
<a href="#l16.1123"></a><span id="l16.1123"> done:</span>
<a href="#l16.1124"></a><span id="l16.1124">     free_signature(&amp;newsig);</span>
<a href="#l16.1125"></a><span id="l16.1125">     return res;</span>
<a href="#l16.1126"></a><span id="l16.1126"> }</span>
<a href="#l16.1127"></a><span id="l16.1127"> </span>
<a href="#l16.1128"></a><span id="l16.1128" class="difflineplus">+static size_t</span>
<a href="#l16.1129"></a><span id="l16.1129" class="difflineplus">+pgp_key_write_signatures(pgp_dest_t *dst, const pgp_key_t *key, uint32_t uid, size_t start)</span>
<a href="#l16.1130"></a><span id="l16.1130" class="difflineplus">+{</span>
<a href="#l16.1131"></a><span id="l16.1131" class="difflineplus">+    for (size_t i = start; i &lt; pgp_key_get_subsig_count(key); i++) {</span>
<a href="#l16.1132"></a><span id="l16.1132" class="difflineplus">+        const pgp_subsig_t *sig = pgp_key_get_subsig(key, i);</span>
<a href="#l16.1133"></a><span id="l16.1133" class="difflineplus">+        if (sig-&gt;uid != uid) {</span>
<a href="#l16.1134"></a><span id="l16.1134" class="difflineplus">+            return i;</span>
<a href="#l16.1135"></a><span id="l16.1135" class="difflineplus">+        }</span>
<a href="#l16.1136"></a><span id="l16.1136" class="difflineplus">+        dst_write(dst, sig-&gt;rawpkt.raw.data(), sig-&gt;rawpkt.raw.size());</span>
<a href="#l16.1137"></a><span id="l16.1137" class="difflineplus">+    }</span>
<a href="#l16.1138"></a><span id="l16.1138" class="difflineplus">+    return pgp_key_get_subsig_count(key);</span>
<a href="#l16.1139"></a><span id="l16.1139" class="difflineplus">+}</span>
<a href="#l16.1140"></a><span id="l16.1140" class="difflineplus">+</span>
<a href="#l16.1141"></a><span id="l16.1141"> bool</span>
<a href="#l16.1142"></a><span id="l16.1142"> pgp_key_write_packets(const pgp_key_t *key, pgp_dest_t *dst)</span>
<a href="#l16.1143"></a><span id="l16.1143"> {</span>
<a href="#l16.1144"></a><span id="l16.1144">     if (!pgp_key_get_rawpacket_count(key)) {</span>
<a href="#l16.1145"></a><span id="l16.1145">         return false;</span>
<a href="#l16.1146"></a><span id="l16.1146">     }</span>
<a href="#l16.1147"></a><span id="l16.1147" class="difflineminus">-    for (size_t i = 0; i &lt; pgp_key_get_rawpacket_count(key); i++) {</span>
<a href="#l16.1148"></a><span id="l16.1148" class="difflineminus">-        const pgp_rawpacket_t *pkt = pgp_key_get_rawpacket(key, i);</span>
<a href="#l16.1149"></a><span id="l16.1149" class="difflineminus">-        if (!pkt-&gt;raw || !pkt-&gt;length) {</span>
<a href="#l16.1150"></a><span id="l16.1150" class="difflineminus">-            return false;</span>
<a href="#l16.1151"></a><span id="l16.1151" class="difflineminus">-        }</span>
<a href="#l16.1152"></a><span id="l16.1152" class="difflineminus">-        dst_write(dst, pkt-&gt;raw, pkt-&gt;length);</span>
<a href="#l16.1153"></a><span id="l16.1153" class="difflineminus">-        if (dst-&gt;werr) {</span>
<a href="#l16.1154"></a><span id="l16.1154" class="difflineminus">-            return false;</span>
<a href="#l16.1155"></a><span id="l16.1155" class="difflineminus">-        }</span>
<a href="#l16.1156"></a><span id="l16.1156" class="difflineplus">+    /* write key rawpacket */</span>
<a href="#l16.1157"></a><span id="l16.1157" class="difflineplus">+    const pgp_rawpacket_t &amp;pkt = pgp_key_get_rawpacket(key);</span>
<a href="#l16.1158"></a><span id="l16.1158" class="difflineplus">+    dst_write(dst, pkt.raw.data(), pkt.raw.size());</span>
<a href="#l16.1159"></a><span id="l16.1159" class="difflineplus">+</span>
<a href="#l16.1160"></a><span id="l16.1160" class="difflineplus">+    if (key-&gt;format == PGP_KEY_STORE_G10) {</span>
<a href="#l16.1161"></a><span id="l16.1161" class="difflineplus">+        return !dst-&gt;werr;</span>
<a href="#l16.1162"></a><span id="l16.1162">     }</span>
<a href="#l16.1163"></a><span id="l16.1163" class="difflineminus">-    return true;</span>
<a href="#l16.1164"></a><span id="l16.1164" class="difflineplus">+</span>
<a href="#l16.1165"></a><span id="l16.1165" class="difflineplus">+    /* write signatures on key */</span>
<a href="#l16.1166"></a><span id="l16.1166" class="difflineplus">+    size_t idx = pgp_key_write_signatures(dst, key, (uint32_t) -1, 0);</span>
<a href="#l16.1167"></a><span id="l16.1167" class="difflineplus">+</span>
<a href="#l16.1168"></a><span id="l16.1168" class="difflineplus">+    /* write uids and their signatures */</span>
<a href="#l16.1169"></a><span id="l16.1169" class="difflineplus">+    for (size_t i = 0; i &lt; pgp_key_get_userid_count(key); i++) {</span>
<a href="#l16.1170"></a><span id="l16.1170" class="difflineplus">+        const pgp_userid_t *uid = pgp_key_get_userid(key, i);</span>
<a href="#l16.1171"></a><span id="l16.1171" class="difflineplus">+        dst_write(dst, uid-&gt;rawpkt.raw.data(), uid-&gt;rawpkt.raw.size());</span>
<a href="#l16.1172"></a><span id="l16.1172" class="difflineplus">+        idx = pgp_key_write_signatures(dst, key, i, idx);</span>
<a href="#l16.1173"></a><span id="l16.1173" class="difflineplus">+    }</span>
<a href="#l16.1174"></a><span id="l16.1174" class="difflineplus">+    return !dst-&gt;werr;</span>
<a href="#l16.1175"></a><span id="l16.1175"> }</span>
<a href="#l16.1176"></a><span id="l16.1176"> </span>
<a href="#l16.1177"></a><span id="l16.1177" class="difflineminus">-static bool</span>
<a href="#l16.1178"></a><span id="l16.1178" class="difflineminus">-packet_matches(pgp_pkt_type_t tag, bool secret)</span>
<a href="#l16.1179"></a><span id="l16.1179" class="difflineplus">+bool</span>
<a href="#l16.1180"></a><span id="l16.1180" class="difflineplus">+pgp_key_write_xfer(pgp_dest_t *dst, const pgp_key_t *key, const rnp_key_store_t *keyring)</span>
<a href="#l16.1181"></a><span id="l16.1181"> {</span>
<a href="#l16.1182"></a><span id="l16.1182" class="difflineminus">-    switch (tag) {</span>
<a href="#l16.1183"></a><span id="l16.1183" class="difflineminus">-    case PGP_PKT_SIGNATURE:</span>
<a href="#l16.1184"></a><span id="l16.1184" class="difflineminus">-    case PGP_PKT_USER_ID:</span>
<a href="#l16.1185"></a><span id="l16.1185" class="difflineminus">-    case PGP_PKT_USER_ATTR:</span>
<a href="#l16.1186"></a><span id="l16.1186" class="difflineminus">-        return true;</span>
<a href="#l16.1187"></a><span id="l16.1187" class="difflineminus">-    case PGP_PKT_PUBLIC_KEY:</span>
<a href="#l16.1188"></a><span id="l16.1188" class="difflineminus">-    case PGP_PKT_PUBLIC_SUBKEY:</span>
<a href="#l16.1189"></a><span id="l16.1189" class="difflineminus">-        return !secret;</span>
<a href="#l16.1190"></a><span id="l16.1190" class="difflineminus">-    case PGP_PKT_SECRET_KEY:</span>
<a href="#l16.1191"></a><span id="l16.1191" class="difflineminus">-    case PGP_PKT_SECRET_SUBKEY:</span>
<a href="#l16.1192"></a><span id="l16.1192" class="difflineminus">-        return secret;</span>
<a href="#l16.1193"></a><span id="l16.1193" class="difflineminus">-    default:</span>
<a href="#l16.1194"></a><span id="l16.1194" class="difflineplus">+    if (!pgp_key_write_packets(key, dst)) {</span>
<a href="#l16.1195"></a><span id="l16.1195" class="difflineplus">+        RNP_LOG(&quot;Failed to export primary key&quot;);</span>
<a href="#l16.1196"></a><span id="l16.1196">         return false;</span>
<a href="#l16.1197"></a><span id="l16.1197">     }</span>
<a href="#l16.1198"></a><span id="l16.1198" class="difflineminus">-}</span>
<a href="#l16.1199"></a><span id="l16.1199" class="difflineminus">-</span>
<a href="#l16.1200"></a><span id="l16.1200" class="difflineminus">-static bool</span>
<a href="#l16.1201"></a><span id="l16.1201" class="difflineminus">-write_xfer_packets(pgp_dest_t *           dst,</span>
<a href="#l16.1202"></a><span id="l16.1202" class="difflineminus">-                   const pgp_key_t *      key,</span>
<a href="#l16.1203"></a><span id="l16.1203" class="difflineminus">-                   const rnp_key_store_t *keyring,</span>
<a href="#l16.1204"></a><span id="l16.1204" class="difflineminus">-                   bool                   secret)</span>
<a href="#l16.1205"></a><span id="l16.1205" class="difflineminus">-{</span>
<a href="#l16.1206"></a><span id="l16.1206" class="difflineminus">-    for (size_t i = 0; i &lt; pgp_key_get_rawpacket_count(key); i++) {</span>
<a href="#l16.1207"></a><span id="l16.1207" class="difflineminus">-        const pgp_rawpacket_t *pkt = pgp_key_get_rawpacket(key, i);</span>
<a href="#l16.1208"></a><span id="l16.1208" class="difflineminus">-</span>
<a href="#l16.1209"></a><span id="l16.1209" class="difflineminus">-        if (!packet_matches(pkt-&gt;tag, secret)) {</span>
<a href="#l16.1210"></a><span id="l16.1210" class="difflineminus">-            RNP_LOG(&quot;skipping packet with tag: %d&quot;, pkt-&gt;tag);</span>
<a href="#l16.1211"></a><span id="l16.1211" class="difflineminus">-            continue;</span>
<a href="#l16.1212"></a><span id="l16.1212" class="difflineminus">-        }</span>
<a href="#l16.1213"></a><span id="l16.1213" class="difflineminus">-        dst_write(dst, pkt-&gt;raw, (size_t) pkt-&gt;length);</span>
<a href="#l16.1214"></a><span id="l16.1214" class="difflineminus">-    }</span>
<a href="#l16.1215"></a><span id="l16.1215"> </span>
<a href="#l16.1216"></a><span id="l16.1216">     if (!keyring) {</span>
<a href="#l16.1217"></a><span id="l16.1217">         return !dst-&gt;werr;</span>
<a href="#l16.1218"></a><span id="l16.1218">     }</span>
<a href="#l16.1219"></a><span id="l16.1219"> </span>
<a href="#l16.1220"></a><span id="l16.1220">     // Export subkeys</span>
<a href="#l16.1221"></a><span id="l16.1221" class="difflineminus">-    for (list_item *grip = list_front(key-&gt;subkey_grips); grip; grip = list_next(grip)) {</span>
<a href="#l16.1222"></a><span id="l16.1222" class="difflineminus">-        const pgp_key_t *subkey = rnp_key_store_get_key_by_grip(keyring, (uint8_t *) grip);</span>
<a href="#l16.1223"></a><span id="l16.1223" class="difflineminus">-        if (!write_xfer_packets(dst, subkey, NULL, secret)) {</span>
<a href="#l16.1224"></a><span id="l16.1224" class="difflineplus">+    for (auto &amp;grip : key-&gt;subkey_grips) {</span>
<a href="#l16.1225"></a><span id="l16.1225" class="difflineplus">+        const pgp_key_t *subkey = rnp_key_store_get_key_by_grip(keyring, grip);</span>
<a href="#l16.1226"></a><span id="l16.1226" class="difflineplus">+        if (!subkey) {</span>
<a href="#l16.1227"></a><span id="l16.1227" class="difflineplus">+            char griphex[PGP_KEY_GRIP_SIZE * 2 + 1] = {0};</span>
<a href="#l16.1228"></a><span id="l16.1228" class="difflineplus">+            rnp_hex_encode(</span>
<a href="#l16.1229"></a><span id="l16.1229" class="difflineplus">+              grip.data(), grip.size(), griphex, sizeof(griphex), RNP_HEX_LOWERCASE);</span>
<a href="#l16.1230"></a><span id="l16.1230" class="difflineplus">+            RNP_LOG(&quot;Warning! Subkey %s not found.&quot;, griphex);</span>
<a href="#l16.1231"></a><span id="l16.1231" class="difflineplus">+            continue;</span>
<a href="#l16.1232"></a><span id="l16.1232" class="difflineplus">+        }</span>
<a href="#l16.1233"></a><span id="l16.1233" class="difflineplus">+        if (!pgp_key_write_packets(subkey, dst)) {</span>
<a href="#l16.1234"></a><span id="l16.1234">             RNP_LOG(&quot;Error occured when exporting a subkey&quot;);</span>
<a href="#l16.1235"></a><span id="l16.1235">             return false;</span>
<a href="#l16.1236"></a><span id="l16.1236">         }</span>
<a href="#l16.1237"></a><span id="l16.1237">     }</span>
<a href="#l16.1238"></a><span id="l16.1238" class="difflineminus">-</span>
<a href="#l16.1239"></a><span id="l16.1239">     return !dst-&gt;werr;</span>
<a href="#l16.1240"></a><span id="l16.1240"> }</span>
<a href="#l16.1241"></a><span id="l16.1241"> </span>
<a href="#l16.1242"></a><span id="l16.1242" class="difflineminus">-bool</span>
<a href="#l16.1243"></a><span id="l16.1243" class="difflineminus">-pgp_key_write_xfer(pgp_dest_t *dst, const pgp_key_t *key, const rnp_key_store_t *keyring)</span>
<a href="#l16.1244"></a><span id="l16.1244" class="difflineminus">-{</span>
<a href="#l16.1245"></a><span id="l16.1245" class="difflineminus">-    if (!pgp_key_get_rawpacket_count(key)) {</span>
<a href="#l16.1246"></a><span id="l16.1246" class="difflineminus">-        return false;</span>
<a href="#l16.1247"></a><span id="l16.1247" class="difflineminus">-    }</span>
<a href="#l16.1248"></a><span id="l16.1248" class="difflineminus">-    return write_xfer_packets(dst, key, keyring, pgp_key_is_secret(key));</span>
<a href="#l16.1249"></a><span id="l16.1249" class="difflineminus">-}</span>
<a href="#l16.1250"></a><span id="l16.1250" class="difflineminus">-</span>
<a href="#l16.1251"></a><span id="l16.1251"> pgp_key_t *</span>
<a href="#l16.1252"></a><span id="l16.1252"> find_suitable_key(pgp_op_t            op,</span>
<a href="#l16.1253"></a><span id="l16.1253">                   pgp_key_t *         key,</span>
<a href="#l16.1254"></a><span id="l16.1254">                   pgp_key_provider_t *key_provider,</span>
<a href="#l16.1255"></a><span id="l16.1255">                   uint8_t             desired_usage)</span>
<a href="#l16.1256"></a><span id="l16.1256"> {</span>
<a href="#l16.1257"></a><span id="l16.1257">     assert(desired_usage);</span>
<a href="#l16.1258"></a><span id="l16.1258">     if (!key) {</span>
<a href="#l16.1259"></a><span id="l16.1259">         return NULL;</span>
<a href="#l16.1260"></a><span id="l16.1260">     }</span>
<a href="#l16.1261"></a><span id="l16.1261">     if (pgp_key_get_flags(key) &amp; desired_usage) {</span>
<a href="#l16.1262"></a><span id="l16.1262">         return key;</span>
<a href="#l16.1263"></a><span id="l16.1263">     }</span>
<a href="#l16.1264"></a><span id="l16.1264" class="difflineminus">-    list_item *           subkey_grip = list_front(key-&gt;subkey_grips);</span>
<a href="#l16.1265"></a><span id="l16.1265">     pgp_key_request_ctx_t ctx{.op = op, .secret = pgp_key_is_secret(key)};</span>
<a href="#l16.1266"></a><span id="l16.1266">     ctx.search.type = PGP_KEY_SEARCH_GRIP;</span>
<a href="#l16.1267"></a><span id="l16.1267"> </span>
<a href="#l16.1268"></a><span id="l16.1268" class="difflineminus">-    while (subkey_grip) {</span>
<a href="#l16.1269"></a><span id="l16.1269" class="difflineminus">-        memcpy(ctx.search.by.grip, subkey_grip, PGP_KEY_GRIP_SIZE);</span>
<a href="#l16.1270"></a><span id="l16.1270" class="difflineplus">+    for (auto &amp;grip : key-&gt;subkey_grips) {</span>
<a href="#l16.1271"></a><span id="l16.1271" class="difflineplus">+        ctx.search.by.grip = grip;</span>
<a href="#l16.1272"></a><span id="l16.1272">         pgp_key_t *subkey = pgp_request_key(key_provider, &amp;ctx);</span>
<a href="#l16.1273"></a><span id="l16.1273">         if (subkey &amp;&amp; (pgp_key_get_flags(subkey) &amp; desired_usage)) {</span>
<a href="#l16.1274"></a><span id="l16.1274">             return subkey;</span>
<a href="#l16.1275"></a><span id="l16.1275">         }</span>
<a href="#l16.1276"></a><span id="l16.1276" class="difflineminus">-        subkey_grip = list_next(subkey_grip);</span>
<a href="#l16.1277"></a><span id="l16.1277">     }</span>
<a href="#l16.1278"></a><span id="l16.1278">     return NULL;</span>
<a href="#l16.1279"></a><span id="l16.1279"> }</span>
<a href="#l16.1280"></a><span id="l16.1280"> </span>
<a href="#l16.1281"></a><span id="l16.1281"> pgp_hash_alg_t</span>
<a href="#l16.1282"></a><span id="l16.1282"> pgp_hash_adjust_alg_to_key(pgp_hash_alg_t hash, const pgp_key_pkt_t *pubkey)</span>
<a href="#l16.1283"></a><span id="l16.1283"> {</span>
<a href="#l16.1284"></a><span id="l16.1284">     if ((pubkey-&gt;alg != PGP_PKA_DSA) &amp;&amp; (pubkey-&gt;alg != PGP_PKA_ECDSA)) {</span>
<a href="#l16.1285"></a><span id="l16.1285" class="difflineat">@@ -2288,89 +2078,225 @@ pgp_key_revalidate_updated(pgp_key_t *ke</span>
<a href="#l16.1286"></a><span id="l16.1286">         if (primary) {</span>
<a href="#l16.1287"></a><span id="l16.1287">             pgp_key_revalidate_updated(primary, keyring);</span>
<a href="#l16.1288"></a><span id="l16.1288">         }</span>
<a href="#l16.1289"></a><span id="l16.1289">         return;</span>
<a href="#l16.1290"></a><span id="l16.1290">     }</span>
<a href="#l16.1291"></a><span id="l16.1291"> </span>
<a href="#l16.1292"></a><span id="l16.1292">     pgp_key_validate(key, keyring);</span>
<a href="#l16.1293"></a><span id="l16.1293">     /* validate/re-validate all subkeys as well */</span>
<a href="#l16.1294"></a><span id="l16.1294" class="difflineminus">-    for (list_item *grip = list_front(key-&gt;subkey_grips); grip; grip = list_next(grip)) {</span>
<a href="#l16.1295"></a><span id="l16.1295" class="difflineminus">-        pgp_key_t *subkey = rnp_key_store_get_key_by_grip(keyring, (uint8_t *) grip);</span>
<a href="#l16.1296"></a><span id="l16.1296" class="difflineplus">+    for (auto &amp;grip : key-&gt;subkey_grips) {</span>
<a href="#l16.1297"></a><span id="l16.1297" class="difflineplus">+        pgp_key_t *subkey = rnp_key_store_get_key_by_grip(keyring, grip);</span>
<a href="#l16.1298"></a><span id="l16.1298">         if (subkey) {</span>
<a href="#l16.1299"></a><span id="l16.1299">             pgp_key_validate_subkey(subkey, key);</span>
<a href="#l16.1300"></a><span id="l16.1300">             pgp_subkey_refresh_data(subkey, key);</span>
<a href="#l16.1301"></a><span id="l16.1301">         }</span>
<a href="#l16.1302"></a><span id="l16.1302">     }</span>
<a href="#l16.1303"></a><span id="l16.1303"> </span>
<a href="#l16.1304"></a><span id="l16.1304">     if (!pgp_key_refresh_data(key)) {</span>
<a href="#l16.1305"></a><span id="l16.1305">         RNP_LOG(&quot;Failed to refresh key data&quot;);</span>
<a href="#l16.1306"></a><span id="l16.1306">     }</span>
<a href="#l16.1307"></a><span id="l16.1307"> }</span>
<a href="#l16.1308"></a><span id="l16.1308"> </span>
<a href="#l16.1309"></a><span id="l16.1309" class="difflineplus">+static void</span>
<a href="#l16.1310"></a><span id="l16.1310" class="difflineplus">+mem_dest_to_vector(pgp_dest_t *dst, std::vector&lt;uint8_t&gt; &amp;vec)</span>
<a href="#l16.1311"></a><span id="l16.1311" class="difflineplus">+{</span>
<a href="#l16.1312"></a><span id="l16.1312" class="difflineplus">+    uint8_t *mem = (uint8_t *) mem_dest_get_memory(dst);</span>
<a href="#l16.1313"></a><span id="l16.1313" class="difflineplus">+    try {</span>
<a href="#l16.1314"></a><span id="l16.1314" class="difflineplus">+        vec = std::vector&lt;uint8_t&gt;(mem, mem + dst-&gt;writeb);</span>
<a href="#l16.1315"></a><span id="l16.1315" class="difflineplus">+        dst_close(dst, true);</span>
<a href="#l16.1316"></a><span id="l16.1316" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l16.1317"></a><span id="l16.1317" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l16.1318"></a><span id="l16.1318" class="difflineplus">+        dst_close(dst, true);</span>
<a href="#l16.1319"></a><span id="l16.1319" class="difflineplus">+        throw;</span>
<a href="#l16.1320"></a><span id="l16.1320" class="difflineplus">+    }</span>
<a href="#l16.1321"></a><span id="l16.1321" class="difflineplus">+}</span>
<a href="#l16.1322"></a><span id="l16.1322" class="difflineplus">+</span>
<a href="#l16.1323"></a><span id="l16.1323" class="difflineplus">+pgp_rawpacket_t::pgp_rawpacket_t(const pgp_signature_t &amp;sig)</span>
<a href="#l16.1324"></a><span id="l16.1324" class="difflineplus">+{</span>
<a href="#l16.1325"></a><span id="l16.1325" class="difflineplus">+    pgp_dest_t dst = {};</span>
<a href="#l16.1326"></a><span id="l16.1326" class="difflineplus">+</span>
<a href="#l16.1327"></a><span id="l16.1327" class="difflineplus">+    if (init_mem_dest(&amp;dst, NULL, 0)) {</span>
<a href="#l16.1328"></a><span id="l16.1328" class="difflineplus">+        throw std::bad_alloc();</span>
<a href="#l16.1329"></a><span id="l16.1329" class="difflineplus">+    }</span>
<a href="#l16.1330"></a><span id="l16.1330" class="difflineplus">+</span>
<a href="#l16.1331"></a><span id="l16.1331" class="difflineplus">+    if (!stream_write_signature(&amp;sig, &amp;dst)) {</span>
<a href="#l16.1332"></a><span id="l16.1332" class="difflineplus">+        dst_close(&amp;dst, true);</span>
<a href="#l16.1333"></a><span id="l16.1333" class="difflineplus">+        throw std::bad_alloc();</span>
<a href="#l16.1334"></a><span id="l16.1334" class="difflineplus">+    }</span>
<a href="#l16.1335"></a><span id="l16.1335" class="difflineplus">+</span>
<a href="#l16.1336"></a><span id="l16.1336" class="difflineplus">+    mem_dest_to_vector(&amp;dst, raw);</span>
<a href="#l16.1337"></a><span id="l16.1337" class="difflineplus">+    tag = PGP_PKT_SIGNATURE;</span>
<a href="#l16.1338"></a><span id="l16.1338" class="difflineplus">+}</span>
<a href="#l16.1339"></a><span id="l16.1339" class="difflineplus">+</span>
<a href="#l16.1340"></a><span id="l16.1340" class="difflineplus">+pgp_rawpacket_t::pgp_rawpacket_t(pgp_key_pkt_t &amp;key)</span>
<a href="#l16.1341"></a><span id="l16.1341" class="difflineplus">+{</span>
<a href="#l16.1342"></a><span id="l16.1342" class="difflineplus">+    pgp_dest_t dst = {};</span>
<a href="#l16.1343"></a><span id="l16.1343" class="difflineplus">+</span>
<a href="#l16.1344"></a><span id="l16.1344" class="difflineplus">+    if (init_mem_dest(&amp;dst, NULL, 0)) {</span>
<a href="#l16.1345"></a><span id="l16.1345" class="difflineplus">+        throw std::bad_alloc();</span>
<a href="#l16.1346"></a><span id="l16.1346" class="difflineplus">+    }</span>
<a href="#l16.1347"></a><span id="l16.1347" class="difflineplus">+</span>
<a href="#l16.1348"></a><span id="l16.1348" class="difflineplus">+    if (!stream_write_key(&amp;key, &amp;dst)) {</span>
<a href="#l16.1349"></a><span id="l16.1349" class="difflineplus">+        dst_close(&amp;dst, true);</span>
<a href="#l16.1350"></a><span id="l16.1350" class="difflineplus">+        throw std::bad_alloc();</span>
<a href="#l16.1351"></a><span id="l16.1351" class="difflineplus">+    }</span>
<a href="#l16.1352"></a><span id="l16.1352" class="difflineplus">+</span>
<a href="#l16.1353"></a><span id="l16.1353" class="difflineplus">+    mem_dest_to_vector(&amp;dst, raw);</span>
<a href="#l16.1354"></a><span id="l16.1354" class="difflineplus">+    tag = key.tag;</span>
<a href="#l16.1355"></a><span id="l16.1355" class="difflineplus">+}</span>
<a href="#l16.1356"></a><span id="l16.1356" class="difflineplus">+</span>
<a href="#l16.1357"></a><span id="l16.1357" class="difflineplus">+pgp_rawpacket_t::pgp_rawpacket_t(const pgp_userid_pkt_t &amp;uid)</span>
<a href="#l16.1358"></a><span id="l16.1358" class="difflineplus">+{</span>
<a href="#l16.1359"></a><span id="l16.1359" class="difflineplus">+    pgp_dest_t dst = {};</span>
<a href="#l16.1360"></a><span id="l16.1360" class="difflineplus">+</span>
<a href="#l16.1361"></a><span id="l16.1361" class="difflineplus">+    if (init_mem_dest(&amp;dst, NULL, 0)) {</span>
<a href="#l16.1362"></a><span id="l16.1362" class="difflineplus">+        throw std::bad_alloc();</span>
<a href="#l16.1363"></a><span id="l16.1363" class="difflineplus">+    }</span>
<a href="#l16.1364"></a><span id="l16.1364" class="difflineplus">+</span>
<a href="#l16.1365"></a><span id="l16.1365" class="difflineplus">+    if (!stream_write_userid(&amp;uid, &amp;dst)) {</span>
<a href="#l16.1366"></a><span id="l16.1366" class="difflineplus">+        dst_close(&amp;dst, true);</span>
<a href="#l16.1367"></a><span id="l16.1367" class="difflineplus">+        throw std::bad_alloc();</span>
<a href="#l16.1368"></a><span id="l16.1368" class="difflineplus">+    }</span>
<a href="#l16.1369"></a><span id="l16.1369" class="difflineplus">+</span>
<a href="#l16.1370"></a><span id="l16.1370" class="difflineplus">+    mem_dest_to_vector(&amp;dst, raw);</span>
<a href="#l16.1371"></a><span id="l16.1371" class="difflineplus">+    tag = uid.tag;</span>
<a href="#l16.1372"></a><span id="l16.1372" class="difflineplus">+}</span>
<a href="#l16.1373"></a><span id="l16.1373" class="difflineplus">+</span>
<a href="#l16.1374"></a><span id="l16.1374" class="difflineplus">+pgp_rawpacket_t::~pgp_rawpacket_t()</span>
<a href="#l16.1375"></a><span id="l16.1375" class="difflineplus">+{</span>
<a href="#l16.1376"></a><span id="l16.1376" class="difflineplus">+}</span>
<a href="#l16.1377"></a><span id="l16.1377" class="difflineplus">+</span>
<a href="#l16.1378"></a><span id="l16.1378" class="difflineplus">+pgp_subsig_t::pgp_subsig_t(pgp_subsig_t &amp;&amp;src)</span>
<a href="#l16.1379"></a><span id="l16.1379" class="difflineplus">+{</span>
<a href="#l16.1380"></a><span id="l16.1380" class="difflineplus">+    uid = src.uid;</span>
<a href="#l16.1381"></a><span id="l16.1381" class="difflineplus">+    sig = src.sig;</span>
<a href="#l16.1382"></a><span id="l16.1382" class="difflineplus">+    src.sig = {};</span>
<a href="#l16.1383"></a><span id="l16.1383" class="difflineplus">+    rawpkt = std::move(src.rawpkt);</span>
<a href="#l16.1384"></a><span id="l16.1384" class="difflineplus">+    trustlevel = src.trustlevel;</span>
<a href="#l16.1385"></a><span id="l16.1385" class="difflineplus">+    trustamount = src.trustamount;</span>
<a href="#l16.1386"></a><span id="l16.1386" class="difflineplus">+    key_flags = src.key_flags;</span>
<a href="#l16.1387"></a><span id="l16.1387" class="difflineplus">+    prefs = src.prefs;</span>
<a href="#l16.1388"></a><span id="l16.1388" class="difflineplus">+    src.prefs = {};</span>
<a href="#l16.1389"></a><span id="l16.1389" class="difflineplus">+    validated = src.validated;</span>
<a href="#l16.1390"></a><span id="l16.1390" class="difflineplus">+    valid = src.valid;</span>
<a href="#l16.1391"></a><span id="l16.1391" class="difflineplus">+}</span>
<a href="#l16.1392"></a><span id="l16.1392" class="difflineplus">+</span>
<a href="#l16.1393"></a><span id="l16.1393" class="difflineplus">+pgp_subsig_t &amp;</span>
<a href="#l16.1394"></a><span id="l16.1394" class="difflineplus">+pgp_subsig_t::operator=(pgp_subsig_t &amp;&amp;src)</span>
<a href="#l16.1395"></a><span id="l16.1395" class="difflineplus">+{</span>
<a href="#l16.1396"></a><span id="l16.1396" class="difflineplus">+    if (&amp;src == this) {</span>
<a href="#l16.1397"></a><span id="l16.1397" class="difflineplus">+        return *this;</span>
<a href="#l16.1398"></a><span id="l16.1398" class="difflineplus">+    }</span>
<a href="#l16.1399"></a><span id="l16.1399" class="difflineplus">+</span>
<a href="#l16.1400"></a><span id="l16.1400" class="difflineplus">+    pgp_free_user_prefs(&amp;prefs);</span>
<a href="#l16.1401"></a><span id="l16.1401" class="difflineplus">+    free_signature(&amp;sig);</span>
<a href="#l16.1402"></a><span id="l16.1402" class="difflineplus">+    uid = src.uid;</span>
<a href="#l16.1403"></a><span id="l16.1403" class="difflineplus">+    sig = src.sig;</span>
<a href="#l16.1404"></a><span id="l16.1404" class="difflineplus">+    src.sig = {};</span>
<a href="#l16.1405"></a><span id="l16.1405" class="difflineplus">+    rawpkt = std::move(src.rawpkt);</span>
<a href="#l16.1406"></a><span id="l16.1406" class="difflineplus">+    trustlevel = src.trustlevel;</span>
<a href="#l16.1407"></a><span id="l16.1407" class="difflineplus">+    trustamount = src.trustamount;</span>
<a href="#l16.1408"></a><span id="l16.1408" class="difflineplus">+    key_flags = src.key_flags;</span>
<a href="#l16.1409"></a><span id="l16.1409" class="difflineplus">+    prefs = src.prefs;</span>
<a href="#l16.1410"></a><span id="l16.1410" class="difflineplus">+    src.prefs = {};</span>
<a href="#l16.1411"></a><span id="l16.1411" class="difflineplus">+    validated = src.validated;</span>
<a href="#l16.1412"></a><span id="l16.1412" class="difflineplus">+    valid = src.valid;</span>
<a href="#l16.1413"></a><span id="l16.1413" class="difflineplus">+    return *this;</span>
<a href="#l16.1414"></a><span id="l16.1414" class="difflineplus">+}</span>
<a href="#l16.1415"></a><span id="l16.1415" class="difflineplus">+</span>
<a href="#l16.1416"></a><span id="l16.1416" class="difflineplus">+pgp_subsig_t &amp;</span>
<a href="#l16.1417"></a><span id="l16.1417" class="difflineplus">+pgp_subsig_t::operator=(const pgp_subsig_t &amp;src)</span>
<a href="#l16.1418"></a><span id="l16.1418" class="difflineplus">+{</span>
<a href="#l16.1419"></a><span id="l16.1419" class="difflineplus">+    if (&amp;src == this) {</span>
<a href="#l16.1420"></a><span id="l16.1420" class="difflineplus">+        return *this;</span>
<a href="#l16.1421"></a><span id="l16.1421" class="difflineplus">+    }</span>
<a href="#l16.1422"></a><span id="l16.1422" class="difflineplus">+</span>
<a href="#l16.1423"></a><span id="l16.1423" class="difflineplus">+    pgp_free_user_prefs(&amp;prefs);</span>
<a href="#l16.1424"></a><span id="l16.1424" class="difflineplus">+    free_signature(&amp;sig);</span>
<a href="#l16.1425"></a><span id="l16.1425" class="difflineplus">+    uid = src.uid;</span>
<a href="#l16.1426"></a><span id="l16.1426" class="difflineplus">+    if (!copy_signature_packet(&amp;sig, &amp;src.sig)) {</span>
<a href="#l16.1427"></a><span id="l16.1427" class="difflineplus">+        throw std::bad_alloc();</span>
<a href="#l16.1428"></a><span id="l16.1428" class="difflineplus">+    }</span>
<a href="#l16.1429"></a><span id="l16.1429" class="difflineplus">+    rawpkt = src.rawpkt;</span>
<a href="#l16.1430"></a><span id="l16.1430" class="difflineplus">+    trustlevel = src.trustlevel;</span>
<a href="#l16.1431"></a><span id="l16.1431" class="difflineplus">+    trustamount = src.trustamount;</span>
<a href="#l16.1432"></a><span id="l16.1432" class="difflineplus">+    key_flags = src.key_flags;</span>
<a href="#l16.1433"></a><span id="l16.1433" class="difflineplus">+    if (pgp_userprefs_copy(&amp;prefs, &amp;src.prefs)) {</span>
<a href="#l16.1434"></a><span id="l16.1434" class="difflineplus">+        throw std::bad_alloc();</span>
<a href="#l16.1435"></a><span id="l16.1435" class="difflineplus">+    }</span>
<a href="#l16.1436"></a><span id="l16.1436" class="difflineplus">+    validated = src.validated;</span>
<a href="#l16.1437"></a><span id="l16.1437" class="difflineplus">+    valid = src.valid;</span>
<a href="#l16.1438"></a><span id="l16.1438" class="difflineplus">+    return *this;</span>
<a href="#l16.1439"></a><span id="l16.1439" class="difflineplus">+}</span>
<a href="#l16.1440"></a><span id="l16.1440" class="difflineplus">+</span>
<a href="#l16.1441"></a><span id="l16.1441" class="difflineplus">+pgp_subsig_t::~pgp_subsig_t()</span>
<a href="#l16.1442"></a><span id="l16.1442" class="difflineplus">+{</span>
<a href="#l16.1443"></a><span id="l16.1443" class="difflineplus">+    pgp_free_user_prefs(&amp;prefs);</span>
<a href="#l16.1444"></a><span id="l16.1444" class="difflineplus">+    free_signature(&amp;sig);</span>
<a href="#l16.1445"></a><span id="l16.1445" class="difflineplus">+}</span>
<a href="#l16.1446"></a><span id="l16.1446" class="difflineplus">+</span>
<a href="#l16.1447"></a><span id="l16.1447" class="difflineplus">+pgp_userid_t::pgp_userid_t(pgp_userid_t &amp;&amp;src)</span>
<a href="#l16.1448"></a><span id="l16.1448" class="difflineplus">+{</span>
<a href="#l16.1449"></a><span id="l16.1449" class="difflineplus">+    str = std::move(src.str);</span>
<a href="#l16.1450"></a><span id="l16.1450" class="difflineplus">+    pkt = src.pkt;</span>
<a href="#l16.1451"></a><span id="l16.1451" class="difflineplus">+    src.pkt = {};</span>
<a href="#l16.1452"></a><span id="l16.1452" class="difflineplus">+    rawpkt = std::move(src.rawpkt);</span>
<a href="#l16.1453"></a><span id="l16.1453" class="difflineplus">+}</span>
<a href="#l16.1454"></a><span id="l16.1454" class="difflineplus">+</span>
<a href="#l16.1455"></a><span id="l16.1455" class="difflineplus">+pgp_userid_t &amp;</span>
<a href="#l16.1456"></a><span id="l16.1456" class="difflineplus">+pgp_userid_t::operator=(const pgp_userid_t &amp;src)</span>
<a href="#l16.1457"></a><span id="l16.1457" class="difflineplus">+{</span>
<a href="#l16.1458"></a><span id="l16.1458" class="difflineplus">+    if (&amp;src == this) {</span>
<a href="#l16.1459"></a><span id="l16.1459" class="difflineplus">+        return *this;</span>
<a href="#l16.1460"></a><span id="l16.1460" class="difflineplus">+    }</span>
<a href="#l16.1461"></a><span id="l16.1461" class="difflineplus">+</span>
<a href="#l16.1462"></a><span id="l16.1462" class="difflineplus">+    free_userid_pkt(&amp;pkt);</span>
<a href="#l16.1463"></a><span id="l16.1463" class="difflineplus">+    if (!copy_userid_pkt(&amp;pkt, &amp;src.pkt)) {</span>
<a href="#l16.1464"></a><span id="l16.1464" class="difflineplus">+        throw std::bad_alloc();</span>
<a href="#l16.1465"></a><span id="l16.1465" class="difflineplus">+    }</span>
<a href="#l16.1466"></a><span id="l16.1466" class="difflineplus">+    rawpkt = src.rawpkt;</span>
<a href="#l16.1467"></a><span id="l16.1467" class="difflineplus">+    str = src.str;</span>
<a href="#l16.1468"></a><span id="l16.1468" class="difflineplus">+    return *this;</span>
<a href="#l16.1469"></a><span id="l16.1469" class="difflineplus">+}</span>
<a href="#l16.1470"></a><span id="l16.1470" class="difflineplus">+</span>
<a href="#l16.1471"></a><span id="l16.1471" class="difflineplus">+pgp_userid_t::~pgp_userid_t()</span>
<a href="#l16.1472"></a><span id="l16.1472" class="difflineplus">+{</span>
<a href="#l16.1473"></a><span id="l16.1473" class="difflineplus">+    free_userid_pkt(&amp;pkt);</span>
<a href="#l16.1474"></a><span id="l16.1474" class="difflineplus">+}</span>
<a href="#l16.1475"></a><span id="l16.1475" class="difflineplus">+</span>
<a href="#l16.1476"></a><span id="l16.1476"> pgp_key_t::~pgp_key_t()</span>
<a href="#l16.1477"></a><span id="l16.1477"> {</span>
<a href="#l16.1478"></a><span id="l16.1478" class="difflineminus">-    for (size_t n = 0; n &lt; pgp_key_get_userid_count(this); ++n) {</span>
<a href="#l16.1479"></a><span id="l16.1479" class="difflineminus">-        pgp_userid_free(pgp_key_get_userid(this, n));</span>
<a href="#l16.1480"></a><span id="l16.1480" class="difflineminus">-    }</span>
<a href="#l16.1481"></a><span id="l16.1481" class="difflineminus">-    this-&gt;uids.clear();</span>
<a href="#l16.1482"></a><span id="l16.1482" class="difflineminus">-</span>
<a href="#l16.1483"></a><span id="l16.1483" class="difflineminus">-    for (size_t n = 0; n &lt; pgp_key_get_rawpacket_count(this); ++n) {</span>
<a href="#l16.1484"></a><span id="l16.1484" class="difflineminus">-        pgp_rawpacket_free(pgp_key_get_rawpacket(this, n));</span>
<a href="#l16.1485"></a><span id="l16.1485" class="difflineminus">-    }</span>
<a href="#l16.1486"></a><span id="l16.1486" class="difflineminus">-    this-&gt;packets.clear();</span>
<a href="#l16.1487"></a><span id="l16.1487" class="difflineminus">-</span>
<a href="#l16.1488"></a><span id="l16.1488" class="difflineminus">-    for (size_t n = 0; n &lt; pgp_key_get_subsig_count(this); n++) {</span>
<a href="#l16.1489"></a><span id="l16.1489" class="difflineminus">-        pgp_subsig_free(pgp_key_get_subsig(this, n));</span>
<a href="#l16.1490"></a><span id="l16.1490" class="difflineminus">-    }</span>
<a href="#l16.1491"></a><span id="l16.1491" class="difflineminus">-    this-&gt;subsigs.clear();</span>
<a href="#l16.1492"></a><span id="l16.1492" class="difflineminus">-</span>
<a href="#l16.1493"></a><span id="l16.1493">     pgp_key_clear_revokes(this);</span>
<a href="#l16.1494"></a><span id="l16.1494" class="difflineminus">-    list_destroy(&amp;this-&gt;subkey_grips);</span>
<a href="#l16.1495"></a><span id="l16.1495">     free_key_pkt(&amp;this-&gt;pkt);</span>
<a href="#l16.1496"></a><span id="l16.1496"> }</span>
<a href="#l16.1497"></a><span id="l16.1497"> </span>
<a href="#l16.1498"></a><span id="l16.1498"> pgp_key_t &amp;</span>
<a href="#l16.1499"></a><span id="l16.1499"> pgp_key_t::operator=(pgp_key_t &amp;&amp;src)</span>
<a href="#l16.1500"></a><span id="l16.1500"> {</span>
<a href="#l16.1501"></a><span id="l16.1501">     if (&amp;src == this) {</span>
<a href="#l16.1502"></a><span id="l16.1502">         return *this;</span>
<a href="#l16.1503"></a><span id="l16.1503">     }</span>
<a href="#l16.1504"></a><span id="l16.1504" class="difflineminus">-    /* need to manually free elements until destructor provided */</span>
<a href="#l16.1505"></a><span id="l16.1505" class="difflineminus">-    for (auto uid : uids) {</span>
<a href="#l16.1506"></a><span id="l16.1506" class="difflineminus">-        pgp_userid_free(&amp;uid);</span>
<a href="#l16.1507"></a><span id="l16.1507" class="difflineminus">-    }</span>
<a href="#l16.1508"></a><span id="l16.1508" class="difflineminus">-    uids.clear();</span>
<a href="#l16.1509"></a><span id="l16.1509">     uids = std::move(src.uids);</span>
<a href="#l16.1510"></a><span id="l16.1510" class="difflineminus">-    for (auto packet : packets) {</span>
<a href="#l16.1511"></a><span id="l16.1511" class="difflineminus">-        pgp_rawpacket_free(&amp;packet);</span>
<a href="#l16.1512"></a><span id="l16.1512" class="difflineminus">-    }</span>
<a href="#l16.1513"></a><span id="l16.1513" class="difflineminus">-    packets.clear();</span>
<a href="#l16.1514"></a><span id="l16.1514" class="difflineminus">-    packets = std::move(src.packets);</span>
<a href="#l16.1515"></a><span id="l16.1515" class="difflineminus">-    for (auto subsig : subsigs) {</span>
<a href="#l16.1516"></a><span id="l16.1516" class="difflineminus">-        pgp_subsig_free(&amp;subsig);</span>
<a href="#l16.1517"></a><span id="l16.1517" class="difflineminus">-    }</span>
<a href="#l16.1518"></a><span id="l16.1518" class="difflineminus">-    subsigs.clear();</span>
<a href="#l16.1519"></a><span id="l16.1519">     subsigs = std::move(src.subsigs);</span>
<a href="#l16.1520"></a><span id="l16.1520">     pgp_key_clear_revokes(this);</span>
<a href="#l16.1521"></a><span id="l16.1521">     revokes = std::move(src.revokes);</span>
<a href="#l16.1522"></a><span id="l16.1522"> </span>
<a href="#l16.1523"></a><span id="l16.1523" class="difflineminus">-    list_destroy(&amp;subkey_grips);</span>
<a href="#l16.1524"></a><span id="l16.1524" class="difflineminus">-    subkey_grips = src.subkey_grips;</span>
<a href="#l16.1525"></a><span id="l16.1525" class="difflineminus">-    src.subkey_grips = NULL;</span>
<a href="#l16.1526"></a><span id="l16.1526" class="difflineminus">-    memcpy(primary_grip, src.primary_grip, sizeof(primary_grip));</span>
<a href="#l16.1527"></a><span id="l16.1527" class="difflineplus">+    subkey_grips = std::move(src.subkey_grips);</span>
<a href="#l16.1528"></a><span id="l16.1528" class="difflineplus">+    primary_grip = std::move(src.primary_grip);</span>
<a href="#l16.1529"></a><span id="l16.1529">     primary_grip_set = src.primary_grip_set;</span>
<a href="#l16.1530"></a><span id="l16.1530">     expiration = src.expiration;</span>
<a href="#l16.1531"></a><span id="l16.1531">     free_key_pkt(&amp;pkt);</span>
<a href="#l16.1532"></a><span id="l16.1532">     pkt = src.pkt;</span>
<a href="#l16.1533"></a><span id="l16.1533">     src.pkt = {};</span>
<a href="#l16.1534"></a><span id="l16.1534" class="difflineplus">+    rawpkt = std::move(src.rawpkt);</span>
<a href="#l16.1535"></a><span id="l16.1535">     key_flags = src.key_flags;</span>
<a href="#l16.1536"></a><span id="l16.1536">     memcpy(keyid, src.keyid, sizeof(keyid));</span>
<a href="#l16.1537"></a><span id="l16.1537">     fingerprint = src.fingerprint;</span>
<a href="#l16.1538"></a><span id="l16.1538" class="difflineminus">-    memcpy(grip, src.grip, sizeof(grip));</span>
<a href="#l16.1539"></a><span id="l16.1539" class="difflineplus">+    grip = std::move(src.grip);</span>
<a href="#l16.1540"></a><span id="l16.1540">     uid0 = src.uid0;</span>
<a href="#l16.1541"></a><span id="l16.1541">     uid0_set = src.uid0_set;</span>
<a href="#l16.1542"></a><span id="l16.1542">     revoked = src.revoked;</span>
<a href="#l16.1543"></a><span id="l16.1543">     revocation = src.revocation;</span>
<a href="#l16.1544"></a><span id="l16.1544">     src.revocation = {};</span>
<a href="#l16.1545"></a><span id="l16.1545">     format = src.format;</span>
<a href="#l16.1546"></a><span id="l16.1546">     valid = src.valid;</span>
<a href="#l16.1547"></a><span id="l16.1547">     validated = src.validated;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/third_party/rnp/src/lib/pgp-key.h</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/third_party/rnp/src/lib/pgp-key.h</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -57,36 +57,36 @@</span>
<a href="#l17.4"></a><span id="l17.4"> #include &lt;vector&gt;</span>
<a href="#l17.5"></a><span id="l17.5"> #include &quot;pass-provider.h&quot;</span>
<a href="#l17.6"></a><span id="l17.6"> #include &lt;rekey/rnp_key_store.h&gt;</span>
<a href="#l17.7"></a><span id="l17.7"> #include &quot;crypto/symmetric.h&quot;</span>
<a href="#l17.8"></a><span id="l17.8"> #include &quot;types.h&quot;</span>
<a href="#l17.9"></a><span id="l17.9"> </span>
<a href="#l17.10"></a><span id="l17.10"> /* describes a user's key */</span>
<a href="#l17.11"></a><span id="l17.11"> struct pgp_key_t {</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-    std::vector&lt;pgp_userid_t&gt;    uids;    /* array of user ids */</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineminus">-    std::vector&lt;pgp_rawpacket_t&gt; packets; /* array of key packets */</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineminus">-    std::vector&lt;pgp_subsig_t&gt;    subsigs; /* array of key signatures */</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineminus">-    std::vector&lt;pgp_revoke_t&gt;    revokes; /* array of revocations */</span>
<a href="#l17.16"></a><span id="l17.16" class="difflineminus">-    list          subkey_grips; /* list of subkey grips (for primary keys) as uint8_t[20] */</span>
<a href="#l17.17"></a><span id="l17.17" class="difflineminus">-    uint8_t       primary_grip[PGP_KEY_GRIP_SIZE]; /* grip of primary key (for subkeys) */</span>
<a href="#l17.18"></a><span id="l17.18" class="difflineminus">-    bool          primary_grip_set;</span>
<a href="#l17.19"></a><span id="l17.19" class="difflineminus">-    time_t        expiration; /* key expiration time, if available */</span>
<a href="#l17.20"></a><span id="l17.20" class="difflineminus">-    pgp_key_pkt_t pkt;        /* pubkey/seckey data packet */</span>
<a href="#l17.21"></a><span id="l17.21" class="difflineminus">-    uint8_t       key_flags;  /* key flags */</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineminus">-    uint8_t       keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineminus">-    pgp_fingerprint_t      fingerprint;</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineminus">-    uint8_t                grip[PGP_KEY_GRIP_SIZE];</span>
<a href="#l17.25"></a><span id="l17.25" class="difflineminus">-    uint32_t               uid0;         /* primary uid index in uids array */</span>
<a href="#l17.26"></a><span id="l17.26" class="difflineminus">-    unsigned               uid0_set : 1; /* flag for the above */</span>
<a href="#l17.27"></a><span id="l17.27" class="difflineminus">-    uint8_t                revoked;      /* key has been revoked */</span>
<a href="#l17.28"></a><span id="l17.28" class="difflineminus">-    pgp_revoke_t           revocation;   /* revocation reason */</span>
<a href="#l17.29"></a><span id="l17.29" class="difflineminus">-    pgp_key_store_format_t format;       /* the format of the key in packets[0] */</span>
<a href="#l17.30"></a><span id="l17.30" class="difflineminus">-    bool                   valid;        /* this key is valid and usable */</span>
<a href="#l17.31"></a><span id="l17.31" class="difflineminus">-    bool                   validated;    /* this key was validated */</span>
<a href="#l17.32"></a><span id="l17.32" class="difflineplus">+    std::vector&lt;pgp_userid_t&gt;   uids;         /* array of user ids */</span>
<a href="#l17.33"></a><span id="l17.33" class="difflineplus">+    std::vector&lt;pgp_subsig_t&gt;   subsigs;      /* array of key signatures */</span>
<a href="#l17.34"></a><span id="l17.34" class="difflineplus">+    std::vector&lt;pgp_revoke_t&gt;   revokes;      /* array of revocations */</span>
<a href="#l17.35"></a><span id="l17.35" class="difflineplus">+    std::vector&lt;pgp_key_grip_t&gt; subkey_grips; /* array of subkey grips (for primary keys) */</span>
<a href="#l17.36"></a><span id="l17.36" class="difflineplus">+    pgp_key_grip_t              primary_grip; /* grip of primary key (for subkeys) */</span>
<a href="#l17.37"></a><span id="l17.37" class="difflineplus">+    bool                        primary_grip_set;</span>
<a href="#l17.38"></a><span id="l17.38" class="difflineplus">+    time_t                      expiration; /* key expiration time, if available */</span>
<a href="#l17.39"></a><span id="l17.39" class="difflineplus">+    pgp_key_pkt_t               pkt;        /* pubkey/seckey data packet */</span>
<a href="#l17.40"></a><span id="l17.40" class="difflineplus">+    pgp_rawpacket_t             rawpkt;     /* key raw packet */</span>
<a href="#l17.41"></a><span id="l17.41" class="difflineplus">+    uint8_t                     key_flags;  /* key flags */</span>
<a href="#l17.42"></a><span id="l17.42" class="difflineplus">+    uint8_t                     keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l17.43"></a><span id="l17.43" class="difflineplus">+    pgp_fingerprint_t           fingerprint;</span>
<a href="#l17.44"></a><span id="l17.44" class="difflineplus">+    pgp_key_grip_t              grip;</span>
<a href="#l17.45"></a><span id="l17.45" class="difflineplus">+    uint32_t                    uid0;         /* primary uid index in uids array */</span>
<a href="#l17.46"></a><span id="l17.46" class="difflineplus">+    unsigned                    uid0_set : 1; /* flag for the above */</span>
<a href="#l17.47"></a><span id="l17.47" class="difflineplus">+    uint8_t                     revoked;      /* key has been revoked */</span>
<a href="#l17.48"></a><span id="l17.48" class="difflineplus">+    pgp_revoke_t                revocation;   /* revocation reason */</span>
<a href="#l17.49"></a><span id="l17.49" class="difflineplus">+    pgp_key_store_format_t      format;       /* the format of the key in packets[0] */</span>
<a href="#l17.50"></a><span id="l17.50" class="difflineplus">+    bool                        valid;        /* this key is valid and usable */</span>
<a href="#l17.51"></a><span id="l17.51" class="difflineplus">+    bool                        validated;    /* this key was validated */</span>
<a href="#l17.52"></a><span id="l17.52"> </span>
<a href="#l17.53"></a><span id="l17.53">     ~pgp_key_t();</span>
<a href="#l17.54"></a><span id="l17.54">     pgp_key_t() = default;</span>
<a href="#l17.55"></a><span id="l17.55">     pgp_key_t &amp;operator=(pgp_key_t &amp;&amp;);</span>
<a href="#l17.56"></a><span id="l17.56">     /* make sure we use only empty constructor/move operator */</span>
<a href="#l17.57"></a><span id="l17.57">     pgp_key_t(const pgp_key_t &amp;src) = delete;</span>
<a href="#l17.58"></a><span id="l17.58">     pgp_key_t(pgp_key_t &amp;&amp;src) = delete;</span>
<a href="#l17.59"></a><span id="l17.59">     pgp_key_t &amp;operator=(const pgp_key_t &amp;) = delete;</span>
<a href="#l17.60"></a><span id="l17.60" class="difflineat">@@ -208,36 +208,38 @@ const uint8_t *pgp_key_get_keyid(const p</span>
<a href="#l17.61"></a><span id="l17.61">  * @return pointer to the fingerprint structure</span>
<a href="#l17.62"></a><span id="l17.62">  */</span>
<a href="#l17.63"></a><span id="l17.63"> const pgp_fingerprint_t *pgp_key_get_fp(const pgp_key_t *key);</span>
<a href="#l17.64"></a><span id="l17.64"> </span>
<a href="#l17.65"></a><span id="l17.65"> /**</span>
<a href="#l17.66"></a><span id="l17.66">  * @brief Get key's grip</span>
<a href="#l17.67"></a><span id="l17.67">  *</span>
<a href="#l17.68"></a><span id="l17.68">  * @param key populated key, should not be NULL</span>
<a href="#l17.69"></a><span id="l17.69" class="difflineminus">- * @return pointer to buffer with the grip</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineplus">+ * @return key's grip</span>
<a href="#l17.71"></a><span id="l17.71">  */</span>
<a href="#l17.72"></a><span id="l17.72" class="difflineminus">-const uint8_t *pgp_key_get_grip(const pgp_key_t *key);</span>
<a href="#l17.73"></a><span id="l17.73" class="difflineplus">+const pgp_key_grip_t &amp;pgp_key_get_grip(const pgp_key_t *key);</span>
<a href="#l17.74"></a><span id="l17.74"> </span>
<a href="#l17.75"></a><span id="l17.75"> /**</span>
<a href="#l17.76"></a><span id="l17.76">  * @brief Get primary key's grip for the subkey, if available.</span>
<a href="#l17.77"></a><span id="l17.77">  *</span>
<a href="#l17.78"></a><span id="l17.78">  * @param key subkey, which primary key's grip should be returned</span>
<a href="#l17.79"></a><span id="l17.79">  * @return pointer to the array with grip or NULL if it is not available</span>
<a href="#l17.80"></a><span id="l17.80">  */</span>
<a href="#l17.81"></a><span id="l17.81" class="difflineminus">-const uint8_t *pgp_key_get_primary_grip(const pgp_key_t *key);</span>
<a href="#l17.82"></a><span id="l17.82" class="difflineplus">+const pgp_key_grip_t &amp;pgp_key_get_primary_grip(const pgp_key_t *key);</span>
<a href="#l17.83"></a><span id="l17.83" class="difflineplus">+</span>
<a href="#l17.84"></a><span id="l17.84" class="difflineplus">+bool pgp_key_has_primary_grip(const pgp_key_t *key);</span>
<a href="#l17.85"></a><span id="l17.85"> </span>
<a href="#l17.86"></a><span id="l17.86"> /**</span>
<a href="#l17.87"></a><span id="l17.87">  * @brief Set primary key's grip for the subkey</span>
<a href="#l17.88"></a><span id="l17.88">  *</span>
<a href="#l17.89"></a><span id="l17.89">  * @param key subkey</span>
<a href="#l17.90"></a><span id="l17.90" class="difflineminus">- * @param grip buffer with grip, should not be NULL</span>
<a href="#l17.91"></a><span id="l17.91" class="difflineplus">+ * @param grip buffer with grip</span>
<a href="#l17.92"></a><span id="l17.92">  * @return void</span>
<a href="#l17.93"></a><span id="l17.93">  */</span>
<a href="#l17.94"></a><span id="l17.94" class="difflineminus">-void pgp_key_set_primary_grip(pgp_key_t *key, const uint8_t *grip);</span>
<a href="#l17.95"></a><span id="l17.95" class="difflineplus">+void pgp_key_set_primary_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip);</span>
<a href="#l17.96"></a><span id="l17.96"> </span>
<a href="#l17.97"></a><span id="l17.97"> /**</span>
<a href="#l17.98"></a><span id="l17.98">  * @brief Link key with subkey via primary_grip and subkey_grips list</span>
<a href="#l17.99"></a><span id="l17.99">  *</span>
<a href="#l17.100"></a><span id="l17.100">  * @param key primary key</span>
<a href="#l17.101"></a><span id="l17.101">  * @param subkey subkey of the primary key</span>
<a href="#l17.102"></a><span id="l17.102">  * @return true on success or false otherwise (allocation failed, wrong key types)</span>
<a href="#l17.103"></a><span id="l17.103">  */</span>
<a href="#l17.104"></a><span id="l17.104" class="difflineat">@@ -258,18 +260,16 @@ pgp_userid_t *pgp_key_add_userid(pgp_key</span>
<a href="#l17.105"></a><span id="l17.105"> pgp_revoke_t *pgp_key_add_revoke(pgp_key_t *);</span>
<a href="#l17.106"></a><span id="l17.106"> </span>
<a href="#l17.107"></a><span id="l17.107"> size_t pgp_key_get_revoke_count(const pgp_key_t *);</span>
<a href="#l17.108"></a><span id="l17.108"> </span>
<a href="#l17.109"></a><span id="l17.109"> const pgp_revoke_t *pgp_key_get_revoke(const pgp_key_t *, size_t);</span>
<a href="#l17.110"></a><span id="l17.110"> </span>
<a href="#l17.111"></a><span id="l17.111"> pgp_revoke_t *pgp_key_get_revoke(pgp_key_t *key, size_t idx);</span>
<a href="#l17.112"></a><span id="l17.112"> </span>
<a href="#l17.113"></a><span id="l17.113" class="difflineminus">-void revoke_free(pgp_revoke_t *revoke);</span>
<a href="#l17.114"></a><span id="l17.114" class="difflineminus">-</span>
<a href="#l17.115"></a><span id="l17.115"> pgp_subsig_t *pgp_key_add_subsig(pgp_key_t *);</span>
<a href="#l17.116"></a><span id="l17.116"> </span>
<a href="#l17.117"></a><span id="l17.117"> size_t pgp_key_get_subsig_count(const pgp_key_t *);</span>
<a href="#l17.118"></a><span id="l17.118"> </span>
<a href="#l17.119"></a><span id="l17.119"> const pgp_subsig_t *pgp_key_get_subsig(const pgp_key_t *, size_t);</span>
<a href="#l17.120"></a><span id="l17.120"> pgp_subsig_t *      pgp_key_get_subsig(pgp_key_t *, size_t);</span>
<a href="#l17.121"></a><span id="l17.121"> </span>
<a href="#l17.122"></a><span id="l17.122"> bool pgp_subsig_from_signature(pgp_subsig_t *subsig, const pgp_signature_t *sig);</span>
<a href="#l17.123"></a><span id="l17.123" class="difflineat">@@ -299,30 +299,20 @@ pgp_subsig_t *pgp_key_latest_selfsig(pgp</span>
<a href="#l17.124"></a><span id="l17.124">  * @return pointer to signature object or NULL if failed/not found.</span>
<a href="#l17.125"></a><span id="l17.125">  */</span>
<a href="#l17.126"></a><span id="l17.126"> pgp_subsig_t *pgp_key_latest_binding(pgp_key_t *subkey, bool validated);</span>
<a href="#l17.127"></a><span id="l17.127"> </span>
<a href="#l17.128"></a><span id="l17.128"> bool pgp_key_refresh_data(pgp_key_t *key);</span>
<a href="#l17.129"></a><span id="l17.129"> </span>
<a href="#l17.130"></a><span id="l17.130"> bool pgp_subkey_refresh_data(pgp_key_t *sub, pgp_key_t *key);</span>
<a href="#l17.131"></a><span id="l17.131"> </span>
<a href="#l17.132"></a><span id="l17.132" class="difflineminus">-void pgp_subsig_free(pgp_subsig_t *subsig);</span>
<a href="#l17.133"></a><span id="l17.133" class="difflineminus">-</span>
<a href="#l17.134"></a><span id="l17.134" class="difflineminus">-pgp_rawpacket_t *pgp_key_add_rawpacket(pgp_key_t *, void *, size_t, pgp_pkt_type_t);</span>
<a href="#l17.135"></a><span id="l17.135" class="difflineminus">-</span>
<a href="#l17.136"></a><span id="l17.136" class="difflineminus">-pgp_rawpacket_t *pgp_key_add_key_rawpacket(pgp_key_t *key, pgp_key_pkt_t *pkt);</span>
<a href="#l17.137"></a><span id="l17.137" class="difflineminus">-</span>
<a href="#l17.138"></a><span id="l17.138" class="difflineminus">-pgp_rawpacket_t *pgp_key_add_sig_rawpacket(pgp_key_t *key, const pgp_signature_t *pkt);</span>
<a href="#l17.139"></a><span id="l17.139" class="difflineminus">-</span>
<a href="#l17.140"></a><span id="l17.140" class="difflineminus">-pgp_rawpacket_t *pgp_key_add_uid_rawpacket(pgp_key_t *key, const pgp_userid_pkt_t *pkt);</span>
<a href="#l17.141"></a><span id="l17.141" class="difflineminus">-</span>
<a href="#l17.142"></a><span id="l17.142"> size_t pgp_key_get_rawpacket_count(const pgp_key_t *);</span>
<a href="#l17.143"></a><span id="l17.143"> </span>
<a href="#l17.144"></a><span id="l17.144" class="difflineminus">-pgp_rawpacket_t *      pgp_key_get_rawpacket(pgp_key_t *, size_t);</span>
<a href="#l17.145"></a><span id="l17.145" class="difflineminus">-const pgp_rawpacket_t *pgp_key_get_rawpacket(const pgp_key_t *, size_t);</span>
<a href="#l17.146"></a><span id="l17.146" class="difflineplus">+pgp_rawpacket_t &amp;      pgp_key_get_rawpacket(pgp_key_t *);</span>
<a href="#l17.147"></a><span id="l17.147" class="difflineplus">+const pgp_rawpacket_t &amp;pgp_key_get_rawpacket(const pgp_key_t *);</span>
<a href="#l17.148"></a><span id="l17.148"> </span>
<a href="#l17.149"></a><span id="l17.149"> /**</span>
<a href="#l17.150"></a><span id="l17.150">  * @brief Get the number of pgp key's subkeys.</span>
<a href="#l17.151"></a><span id="l17.151">  *</span>
<a href="#l17.152"></a><span id="l17.152">  * @param key pointer to the primary key</span>
<a href="#l17.153"></a><span id="l17.153">  * @return number of the subkeys</span>
<a href="#l17.154"></a><span id="l17.154">  */</span>
<a href="#l17.155"></a><span id="l17.155"> size_t pgp_key_get_subkey_count(const pgp_key_t *key);</span>
<a href="#l17.156"></a><span id="l17.156" class="difflineat">@@ -330,36 +320,36 @@ size_t pgp_key_get_subkey_count(const pg</span>
<a href="#l17.157"></a><span id="l17.157"> /**</span>
<a href="#l17.158"></a><span id="l17.158">  * @brief Add subkey grip to key's list.</span>
<a href="#l17.159"></a><span id="l17.159">  *        Note: this function will check for duplicates.</span>
<a href="#l17.160"></a><span id="l17.160">  *</span>
<a href="#l17.161"></a><span id="l17.161">  * @param key key pointer to the primary key</span>
<a href="#l17.162"></a><span id="l17.162">  * @param grip subkey's grip.</span>
<a href="#l17.163"></a><span id="l17.163">  * @return true if succeeded (grip already exists in list or added), or false otherwise.</span>
<a href="#l17.164"></a><span id="l17.164">  */</span>
<a href="#l17.165"></a><span id="l17.165" class="difflineminus">-bool pgp_key_add_subkey_grip(pgp_key_t *key, const uint8_t *grip);</span>
<a href="#l17.166"></a><span id="l17.166" class="difflineplus">+bool pgp_key_add_subkey_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip);</span>
<a href="#l17.167"></a><span id="l17.167"> </span>
<a href="#l17.168"></a><span id="l17.168"> /**</span>
<a href="#l17.169"></a><span id="l17.169">  * @brief Get the pgp key's subkey grip</span>
<a href="#l17.170"></a><span id="l17.170">  *</span>
<a href="#l17.171"></a><span id="l17.171">  * @param key key pointer to the primary key</span>
<a href="#l17.172"></a><span id="l17.172">  * @param idx index of the subkey</span>
<a href="#l17.173"></a><span id="l17.173" class="difflineminus">- * @return pointer to the grip data or NULL if subkey not found</span>
<a href="#l17.174"></a><span id="l17.174" class="difflineplus">+ * @return grip or throws std::out_of_range exception</span>
<a href="#l17.175"></a><span id="l17.175">  */</span>
<a href="#l17.176"></a><span id="l17.176" class="difflineminus">-const uint8_t *pgp_key_get_subkey_grip(const pgp_key_t *key, size_t idx);</span>
<a href="#l17.177"></a><span id="l17.177" class="difflineplus">+const pgp_key_grip_t &amp;pgp_key_get_subkey_grip(const pgp_key_t *key, size_t idx);</span>
<a href="#l17.178"></a><span id="l17.178"> </span>
<a href="#l17.179"></a><span id="l17.179"> /**</span>
<a href="#l17.180"></a><span id="l17.180">  * @brief Get the key's subkey by it's index</span>
<a href="#l17.181"></a><span id="l17.181">  *</span>
<a href="#l17.182"></a><span id="l17.182">  * @param key primary key</span>
<a href="#l17.183"></a><span id="l17.183">  * @param store key store wich will be searched for subkeys</span>
<a href="#l17.184"></a><span id="l17.184">  * @param idx index of the subkey</span>
<a href="#l17.185"></a><span id="l17.185">  * @return pointer to the subkey or NULL if subkey not found</span>
<a href="#l17.186"></a><span id="l17.186">  */</span>
<a href="#l17.187"></a><span id="l17.187" class="difflineminus">-pgp_key_t *pgp_key_get_subkey(const pgp_key_t *key, const rnp_key_store_t *store, size_t idx);</span>
<a href="#l17.188"></a><span id="l17.188" class="difflineplus">+pgp_key_t *pgp_key_get_subkey(const pgp_key_t *key, rnp_key_store_t *store, size_t idx);</span>
<a href="#l17.189"></a><span id="l17.189"> </span>
<a href="#l17.190"></a><span id="l17.190"> pgp_key_flags_t pgp_pk_alg_capabilities(pgp_pubkey_alg_t alg);</span>
<a href="#l17.191"></a><span id="l17.191"> </span>
<a href="#l17.192"></a><span id="l17.192"> /** check if a key is currently locked</span>
<a href="#l17.193"></a><span id="l17.193">  *</span>
<a href="#l17.194"></a><span id="l17.194">  *  Note: Key locking does not apply to unprotected keys.</span>
<a href="#l17.195"></a><span id="l17.195">  *</span>
<a href="#l17.196"></a><span id="l17.196">  *  @param key the key</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/third_party/rnp/src/lib/rnp.cpp</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/third_party/rnp/src/lib/rnp.cpp</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -43,16 +43,17 @@</span>
<a href="#l18.4"></a><span id="l18.4"> #include &lt;librepgp/stream-key.h&gt;</span>
<a href="#l18.5"></a><span id="l18.5"> #include &lt;librepgp/stream-dump.h&gt;</span>
<a href="#l18.6"></a><span id="l18.6"> #include &lt;rnp/rnp.h&gt;</span>
<a href="#l18.7"></a><span id="l18.7"> #include &lt;stdarg.h&gt;</span>
<a href="#l18.8"></a><span id="l18.8"> #include &lt;stdlib.h&gt;</span>
<a href="#l18.9"></a><span id="l18.9"> #include &lt;unistd.h&gt;</span>
<a href="#l18.10"></a><span id="l18.10"> #include &lt;string.h&gt;</span>
<a href="#l18.11"></a><span id="l18.11"> #include &lt;sys/stat.h&gt;</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineplus">+#include &lt;stdexcept&gt;</span>
<a href="#l18.13"></a><span id="l18.13"> #include &quot;utils.h&quot;</span>
<a href="#l18.14"></a><span id="l18.14"> #include &quot;json_utils.h&quot;</span>
<a href="#l18.15"></a><span id="l18.15"> #include &quot;version.h&quot;</span>
<a href="#l18.16"></a><span id="l18.16"> #include &lt;botan/secmem.h&gt;</span>
<a href="#l18.17"></a><span id="l18.17"> #include &quot;ffi-priv-types.h&quot;</span>
<a href="#l18.18"></a><span id="l18.18"> </span>
<a href="#l18.19"></a><span id="l18.19"> #define FFI_LOG(ffi, ...)            \</span>
<a href="#l18.20"></a><span id="l18.20">     do {                             \</span>
<a href="#l18.21"></a><span id="l18.21" class="difflineat">@@ -389,26 +390,25 @@ rnp_ffi_create(rnp_ffi_t *ffi, const cha</span>
<a href="#l18.22"></a><span id="l18.22">     }</span>
<a href="#l18.23"></a><span id="l18.23"> </span>
<a href="#l18.24"></a><span id="l18.24">     ob = (rnp_ffi_st *) calloc(1, sizeof(struct rnp_ffi_st));</span>
<a href="#l18.25"></a><span id="l18.25">     if (!ob) {</span>
<a href="#l18.26"></a><span id="l18.26">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.27"></a><span id="l18.27">     }</span>
<a href="#l18.28"></a><span id="l18.28">     // default to all stderr</span>
<a href="#l18.29"></a><span id="l18.29">     ob-&gt;errs = stderr;</span>
<a href="#l18.30"></a><span id="l18.30" class="difflineminus">-    ob-&gt;pubring = rnp_key_store_new(pub_ks_format, &quot;&quot;);</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineminus">-    if (!ob-&gt;pubring) {</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+    try {</span>
<a href="#l18.33"></a><span id="l18.33" class="difflineplus">+        ob-&gt;pubring = new rnp_key_store_t(pub_ks_format, &quot;&quot;);</span>
<a href="#l18.34"></a><span id="l18.34" class="difflineplus">+        ob-&gt;secring = new rnp_key_store_t(sec_ks_format, &quot;&quot;);</span>
<a href="#l18.35"></a><span id="l18.35" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l18.36"></a><span id="l18.36" class="difflineplus">+        FFI_LOG(ob, &quot;%s&quot;, e.what());</span>
<a href="#l18.37"></a><span id="l18.37">         ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.38"></a><span id="l18.38">         goto done;</span>
<a href="#l18.39"></a><span id="l18.39">     }</span>
<a href="#l18.40"></a><span id="l18.40" class="difflineminus">-    ob-&gt;secring = rnp_key_store_new(sec_ks_format, &quot;&quot;);</span>
<a href="#l18.41"></a><span id="l18.41" class="difflineminus">-    if (!ob-&gt;secring) {</span>
<a href="#l18.42"></a><span id="l18.42" class="difflineminus">-        ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.43"></a><span id="l18.43" class="difflineminus">-        goto done;</span>
<a href="#l18.44"></a><span id="l18.44" class="difflineminus">-    }</span>
<a href="#l18.45"></a><span id="l18.45" class="difflineplus">+</span>
<a href="#l18.46"></a><span id="l18.46">     ob-&gt;key_provider = (pgp_key_provider_t){.callback = ffi_key_provider, .userdata = ob};</span>
<a href="#l18.47"></a><span id="l18.47">     ob-&gt;pass_provider =</span>
<a href="#l18.48"></a><span id="l18.48">       (pgp_password_provider_t){.callback = rnp_password_cb_bounce, .userdata = ob};</span>
<a href="#l18.49"></a><span id="l18.49">     if (!rng_init(&amp;ob-&gt;rng, RNG_DRBG)) {</span>
<a href="#l18.50"></a><span id="l18.50">         ret = RNP_ERROR_RNG;</span>
<a href="#l18.51"></a><span id="l18.51">         goto done;</span>
<a href="#l18.52"></a><span id="l18.52">     }</span>
<a href="#l18.53"></a><span id="l18.53"> </span>
<a href="#l18.54"></a><span id="l18.54" class="difflineat">@@ -437,18 +437,18 @@ close_io_file(FILE **fp)</span>
<a href="#l18.55"></a><span id="l18.55">     *fp = NULL;</span>
<a href="#l18.56"></a><span id="l18.56"> }</span>
<a href="#l18.57"></a><span id="l18.57"> </span>
<a href="#l18.58"></a><span id="l18.58"> rnp_result_t</span>
<a href="#l18.59"></a><span id="l18.59"> rnp_ffi_destroy(rnp_ffi_t ffi)</span>
<a href="#l18.60"></a><span id="l18.60"> {</span>
<a href="#l18.61"></a><span id="l18.61">     if (ffi) {</span>
<a href="#l18.62"></a><span id="l18.62">         close_io_file(&amp;ffi-&gt;errs);</span>
<a href="#l18.63"></a><span id="l18.63" class="difflineminus">-        rnp_key_store_free(ffi-&gt;pubring);</span>
<a href="#l18.64"></a><span id="l18.64" class="difflineminus">-        rnp_key_store_free(ffi-&gt;secring);</span>
<a href="#l18.65"></a><span id="l18.65" class="difflineplus">+        delete ffi-&gt;pubring;</span>
<a href="#l18.66"></a><span id="l18.66" class="difflineplus">+        delete ffi-&gt;secring;</span>
<a href="#l18.67"></a><span id="l18.67">         rng_destroy(&amp;ffi-&gt;rng);</span>
<a href="#l18.68"></a><span id="l18.68">         free(ffi);</span>
<a href="#l18.69"></a><span id="l18.69">     }</span>
<a href="#l18.70"></a><span id="l18.70">     return RNP_SUCCESS;</span>
<a href="#l18.71"></a><span id="l18.71"> }</span>
<a href="#l18.72"></a><span id="l18.72"> </span>
<a href="#l18.73"></a><span id="l18.73"> rnp_result_t</span>
<a href="#l18.74"></a><span id="l18.74"> rnp_ffi_set_log_fd(rnp_ffi_t ffi, int fd)</span>
<a href="#l18.75"></a><span id="l18.75" class="difflineat">@@ -997,19 +997,20 @@ load_keys_from_input(rnp_ffi_t ffi, rnp_</span>
<a href="#l18.76"></a><span id="l18.76"> </span>
<a href="#l18.77"></a><span id="l18.77">     const pgp_key_provider_t *key_providers[] = {&amp;chained, &amp;ffi-&gt;key_provider, NULL};</span>
<a href="#l18.78"></a><span id="l18.78"> </span>
<a href="#l18.79"></a><span id="l18.79">     const pgp_key_provider_t key_provider = {.callback = rnp_key_provider_chained,</span>
<a href="#l18.80"></a><span id="l18.80">                                              .userdata = key_providers};</span>
<a href="#l18.81"></a><span id="l18.81"> </span>
<a href="#l18.82"></a><span id="l18.82">     if (input-&gt;src_directory) {</span>
<a href="#l18.83"></a><span id="l18.83">         // load the keys</span>
<a href="#l18.84"></a><span id="l18.84" class="difflineminus">-        free((void *) store-&gt;path);</span>
<a href="#l18.85"></a><span id="l18.85" class="difflineminus">-        store-&gt;path = strdup(input-&gt;src_directory);</span>
<a href="#l18.86"></a><span id="l18.86" class="difflineminus">-        if (!store-&gt;path) {</span>
<a href="#l18.87"></a><span id="l18.87" class="difflineplus">+        try {</span>
<a href="#l18.88"></a><span id="l18.88" class="difflineplus">+            store-&gt;path = input-&gt;src_directory;</span>
<a href="#l18.89"></a><span id="l18.89" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l18.90"></a><span id="l18.90" class="difflineplus">+            FFI_LOG(ffi, &quot;%s&quot;, e.what());</span>
<a href="#l18.91"></a><span id="l18.91">             ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.92"></a><span id="l18.92">             goto done;</span>
<a href="#l18.93"></a><span id="l18.93">         }</span>
<a href="#l18.94"></a><span id="l18.94">         if (!rnp_key_store_load_from_path(store, &amp;key_provider)) {</span>
<a href="#l18.95"></a><span id="l18.95">             ret = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l18.96"></a><span id="l18.96">             goto done;</span>
<a href="#l18.97"></a><span id="l18.97">         }</span>
<a href="#l18.98"></a><span id="l18.98">     } else {</span>
<a href="#l18.99"></a><span id="l18.99" class="difflineat">@@ -1053,84 +1054,85 @@ do_load_keys(rnp_ffi_t              ffi,</span>
<a href="#l18.100"></a><span id="l18.100">              key_type_t             key_type)</span>
<a href="#l18.101"></a><span id="l18.101"> {</span>
<a href="#l18.102"></a><span id="l18.102">     rnp_result_t     ret = RNP_ERROR_GENERIC;</span>
<a href="#l18.103"></a><span id="l18.103">     rnp_key_store_t *tmp_store = NULL;</span>
<a href="#l18.104"></a><span id="l18.104">     pgp_key_t        keycp = {};</span>
<a href="#l18.105"></a><span id="l18.105">     rnp_result_t     tmpret;</span>
<a href="#l18.106"></a><span id="l18.106"> </span>
<a href="#l18.107"></a><span id="l18.107">     // create a temporary key store to hold the keys</span>
<a href="#l18.108"></a><span id="l18.108" class="difflineminus">-    tmp_store = rnp_key_store_new(format, &quot;&quot;);</span>
<a href="#l18.109"></a><span id="l18.109" class="difflineminus">-    if (!tmp_store) {</span>
<a href="#l18.110"></a><span id="l18.110" class="difflineminus">-        // TODO: could also be out of mem</span>
<a href="#l18.111"></a><span id="l18.111" class="difflineplus">+    try {</span>
<a href="#l18.112"></a><span id="l18.112" class="difflineplus">+        tmp_store = new rnp_key_store_t(format, &quot;&quot;);</span>
<a href="#l18.113"></a><span id="l18.113" class="difflineplus">+    } catch (const std::invalid_argument &amp;e) {</span>
<a href="#l18.114"></a><span id="l18.114">         FFI_LOG(ffi, &quot;Failed to create key store of format: %d&quot;, (int) format);</span>
<a href="#l18.115"></a><span id="l18.115">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.116"></a><span id="l18.116" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l18.117"></a><span id="l18.117" class="difflineplus">+        FFI_LOG(ffi, &quot;%s&quot;, e.what());</span>
<a href="#l18.118"></a><span id="l18.118" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.119"></a><span id="l18.119">     }</span>
<a href="#l18.120"></a><span id="l18.120"> </span>
<a href="#l18.121"></a><span id="l18.121">     // load keys into our temporary store</span>
<a href="#l18.122"></a><span id="l18.122">     tmpret = load_keys_from_input(ffi, input, tmp_store);</span>
<a href="#l18.123"></a><span id="l18.123">     if (tmpret) {</span>
<a href="#l18.124"></a><span id="l18.124">         ret = tmpret;</span>
<a href="#l18.125"></a><span id="l18.125">         goto done;</span>
<a href="#l18.126"></a><span id="l18.126">     }</span>
<a href="#l18.127"></a><span id="l18.127">     // go through all the loaded keys</span>
<a href="#l18.128"></a><span id="l18.128" class="difflineminus">-    for (list_item *key_item = list_front(rnp_key_store_get_keys(tmp_store)); key_item;</span>
<a href="#l18.129"></a><span id="l18.129" class="difflineminus">-         key_item = list_next(key_item)) {</span>
<a href="#l18.130"></a><span id="l18.130" class="difflineminus">-        pgp_key_t *key = (pgp_key_t *) key_item;</span>
<a href="#l18.131"></a><span id="l18.131" class="difflineplus">+    for (auto &amp;key : tmp_store-&gt;keys) {</span>
<a href="#l18.132"></a><span id="l18.132">         // check that the key is the correct type and has not already been loaded</span>
<a href="#l18.133"></a><span id="l18.133">         // add secret key part if it is and we need it</span>
<a href="#l18.134"></a><span id="l18.134" class="difflineminus">-        if (pgp_key_is_secret(key) &amp;&amp;</span>
<a href="#l18.135"></a><span id="l18.135" class="difflineplus">+        if (pgp_key_is_secret(&amp;key) &amp;&amp;</span>
<a href="#l18.136"></a><span id="l18.136">             ((key_type == KEY_TYPE_SECRET) || (key_type == KEY_TYPE_ANY))) {</span>
<a href="#l18.137"></a><span id="l18.137" class="difflineminus">-            if (key_needs_conversion(key, ffi-&gt;secring)) {</span>
<a href="#l18.138"></a><span id="l18.138" class="difflineplus">+            if (key_needs_conversion(&amp;key, ffi-&gt;secring)) {</span>
<a href="#l18.139"></a><span id="l18.139">                 FFI_LOG(ffi, &quot;This key format conversion is not yet supported&quot;);</span>
<a href="#l18.140"></a><span id="l18.140">                 ret = RNP_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l18.141"></a><span id="l18.141">                 goto done;</span>
<a href="#l18.142"></a><span id="l18.142">             }</span>
<a href="#l18.143"></a><span id="l18.143"> </span>
<a href="#l18.144"></a><span id="l18.144" class="difflineminus">-            if (!rnp_key_store_add_key(ffi-&gt;secring, key)) {</span>
<a href="#l18.145"></a><span id="l18.145" class="difflineplus">+            if (!rnp_key_store_add_key(ffi-&gt;secring, &amp;key)) {</span>
<a href="#l18.146"></a><span id="l18.146">                 FFI_LOG(ffi, &quot;Failed to add secret key&quot;);</span>
<a href="#l18.147"></a><span id="l18.147">                 ret = RNP_ERROR_GENERIC;</span>
<a href="#l18.148"></a><span id="l18.148">                 goto done;</span>
<a href="#l18.149"></a><span id="l18.149">             }</span>
<a href="#l18.150"></a><span id="l18.150">         }</span>
<a href="#l18.151"></a><span id="l18.151"> </span>
<a href="#l18.152"></a><span id="l18.152">         // add public key part if needed</span>
<a href="#l18.153"></a><span id="l18.153" class="difflineminus">-        if ((key-&gt;format == PGP_KEY_STORE_G10) ||</span>
<a href="#l18.154"></a><span id="l18.154" class="difflineplus">+        if ((key.format == PGP_KEY_STORE_G10) ||</span>
<a href="#l18.155"></a><span id="l18.155">             ((key_type != KEY_TYPE_ANY) &amp;&amp; (key_type != KEY_TYPE_PUBLIC))) {</span>
<a href="#l18.156"></a><span id="l18.156">             continue;</span>
<a href="#l18.157"></a><span id="l18.157">         }</span>
<a href="#l18.158"></a><span id="l18.158"> </span>
<a href="#l18.159"></a><span id="l18.159" class="difflineminus">-        if ((tmpret = pgp_key_copy(&amp;keycp, key, true))) {</span>
<a href="#l18.160"></a><span id="l18.160" class="difflineplus">+        if ((tmpret = pgp_key_copy(&amp;keycp, &amp;key, true))) {</span>
<a href="#l18.161"></a><span id="l18.161">             ret = tmpret;</span>
<a href="#l18.162"></a><span id="l18.162">             goto done;</span>
<a href="#l18.163"></a><span id="l18.163">         }</span>
<a href="#l18.164"></a><span id="l18.164"> </span>
<a href="#l18.165"></a><span id="l18.165">         /* TODO: We could do this a few different ways. There isn't an obvious reason</span>
<a href="#l18.166"></a><span id="l18.166">          * to restrict what formats we load, so we don't necessarily need to require a</span>
<a href="#l18.167"></a><span id="l18.167">          * conversion just to load and use a G10 key when using GPG keyrings, for</span>
<a href="#l18.168"></a><span id="l18.168">          * example. We could just convert when saving.</span>
<a href="#l18.169"></a><span id="l18.169">          */</span>
<a href="#l18.170"></a><span id="l18.170"> </span>
<a href="#l18.171"></a><span id="l18.171" class="difflineminus">-        if (key_needs_conversion(key, ffi-&gt;pubring)) {</span>
<a href="#l18.172"></a><span id="l18.172" class="difflineplus">+        if (key_needs_conversion(&amp;key, ffi-&gt;pubring)) {</span>
<a href="#l18.173"></a><span id="l18.173">             FFI_LOG(ffi, &quot;This key format conversion is not yet supported&quot;);</span>
<a href="#l18.174"></a><span id="l18.174">             ret = RNP_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l18.175"></a><span id="l18.175">             goto done;</span>
<a href="#l18.176"></a><span id="l18.176">         }</span>
<a href="#l18.177"></a><span id="l18.177"> </span>
<a href="#l18.178"></a><span id="l18.178">         if (!rnp_key_store_add_key(ffi-&gt;pubring, &amp;keycp)) {</span>
<a href="#l18.179"></a><span id="l18.179">             FFI_LOG(ffi, &quot;Failed to add public key&quot;);</span>
<a href="#l18.180"></a><span id="l18.180">             ret = RNP_ERROR_GENERIC;</span>
<a href="#l18.181"></a><span id="l18.181">             goto done;</span>
<a href="#l18.182"></a><span id="l18.182">         }</span>
<a href="#l18.183"></a><span id="l18.183">     }</span>
<a href="#l18.184"></a><span id="l18.184"> </span>
<a href="#l18.185"></a><span id="l18.185">     // success, even if we didn't actually load any</span>
<a href="#l18.186"></a><span id="l18.186">     ret = RNP_SUCCESS;</span>
<a href="#l18.187"></a><span id="l18.187"> done:</span>
<a href="#l18.188"></a><span id="l18.188" class="difflineminus">-    rnp_key_store_free(tmp_store);</span>
<a href="#l18.189"></a><span id="l18.189" class="difflineplus">+    delete tmp_store;</span>
<a href="#l18.190"></a><span id="l18.190">     return ret;</span>
<a href="#l18.191"></a><span id="l18.191"> }</span>
<a href="#l18.192"></a><span id="l18.192"> </span>
<a href="#l18.193"></a><span id="l18.193"> static key_type_t</span>
<a href="#l18.194"></a><span id="l18.194"> flags_to_key_type(uint32_t *flags)</span>
<a href="#l18.195"></a><span id="l18.195"> {</span>
<a href="#l18.196"></a><span id="l18.196">     key_type_t type = KEY_TYPE_NONE;</span>
<a href="#l18.197"></a><span id="l18.197">     // figure out what type of keys to operate on, based on flags</span>
<a href="#l18.198"></a><span id="l18.198" class="difflineat">@@ -1258,19 +1260,20 @@ rnp_import_keys(rnp_ffi_t ffi, rnp_input</span>
<a href="#l18.199"></a><span id="l18.199"> </span>
<a href="#l18.200"></a><span id="l18.200">     rnp_result_t     ret = RNP_ERROR_GENERIC;</span>
<a href="#l18.201"></a><span id="l18.201">     rnp_key_store_t *tmp_store = NULL;</span>
<a href="#l18.202"></a><span id="l18.202">     rnp_result_t     tmpret;</span>
<a href="#l18.203"></a><span id="l18.203">     json_object *    jsores = NULL;</span>
<a href="#l18.204"></a><span id="l18.204">     json_object *    jsokeys = NULL;</span>
<a href="#l18.205"></a><span id="l18.205"> </span>
<a href="#l18.206"></a><span id="l18.206">     // load keys to temporary keystore.</span>
<a href="#l18.207"></a><span id="l18.207" class="difflineminus">-    tmp_store = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l18.208"></a><span id="l18.208" class="difflineminus">-    if (!tmp_store) {</span>
<a href="#l18.209"></a><span id="l18.209" class="difflineminus">-        FFI_LOG(ffi, &quot;Failed to create key store.&quot;);</span>
<a href="#l18.210"></a><span id="l18.210" class="difflineplus">+    try {</span>
<a href="#l18.211"></a><span id="l18.211" class="difflineplus">+        tmp_store = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l18.212"></a><span id="l18.212" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l18.213"></a><span id="l18.213" class="difflineplus">+        FFI_LOG(ffi, &quot;Failed to create key store: %s.&quot;, e.what());</span>
<a href="#l18.214"></a><span id="l18.214">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.215"></a><span id="l18.215">     }</span>
<a href="#l18.216"></a><span id="l18.216"> </span>
<a href="#l18.217"></a><span id="l18.217">     tmpret = load_keys_from_input(ffi, input, tmp_store);</span>
<a href="#l18.218"></a><span id="l18.218">     if (tmpret) {</span>
<a href="#l18.219"></a><span id="l18.219">         ret = tmpret;</span>
<a href="#l18.220"></a><span id="l18.220">         goto done;</span>
<a href="#l18.221"></a><span id="l18.221">     }</span>
<a href="#l18.222"></a><span id="l18.222" class="difflineat">@@ -1281,50 +1284,48 @@ rnp_import_keys(rnp_ffi_t ffi, rnp_input</span>
<a href="#l18.223"></a><span id="l18.223">     }</span>
<a href="#l18.224"></a><span id="l18.224">     jsokeys = json_object_new_array();</span>
<a href="#l18.225"></a><span id="l18.225">     if (!obj_add_field_json(jsores, &quot;keys&quot;, jsokeys)) {</span>
<a href="#l18.226"></a><span id="l18.226">         ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.227"></a><span id="l18.227">         goto done;</span>
<a href="#l18.228"></a><span id="l18.228">     }</span>
<a href="#l18.229"></a><span id="l18.229"> </span>
<a href="#l18.230"></a><span id="l18.230">     // import keys to the main keystore.</span>
<a href="#l18.231"></a><span id="l18.231" class="difflineminus">-    for (list_item *ki = list_front(rnp_key_store_get_keys(tmp_store)); ki;</span>
<a href="#l18.232"></a><span id="l18.232" class="difflineminus">-         ki = list_next(ki)) {</span>
<a href="#l18.233"></a><span id="l18.233" class="difflineminus">-        pgp_key_t *             key = (pgp_key_t *) ki;</span>
<a href="#l18.234"></a><span id="l18.234" class="difflineplus">+    for (auto &amp;key : tmp_store-&gt;keys) {</span>
<a href="#l18.235"></a><span id="l18.235">         pgp_key_import_status_t pub_status = PGP_KEY_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l18.236"></a><span id="l18.236">         pgp_key_import_status_t sec_status = PGP_KEY_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l18.237"></a><span id="l18.237" class="difflineminus">-        if (pgp_key_is_public(key) &amp;&amp; !pub) {</span>
<a href="#l18.238"></a><span id="l18.238" class="difflineplus">+        if (!pub &amp;&amp; pgp_key_is_public(&amp;key)) {</span>
<a href="#l18.239"></a><span id="l18.239">             continue;</span>
<a href="#l18.240"></a><span id="l18.240">         }</span>
<a href="#l18.241"></a><span id="l18.241" class="difflineminus">-        if (validate_pgp_key_material(pgp_key_get_material(key), &amp;ffi-&gt;rng)) {</span>
<a href="#l18.242"></a><span id="l18.242" class="difflineplus">+        if (validate_pgp_key_material(pgp_key_get_material(&amp;key), &amp;ffi-&gt;rng)) {</span>
<a href="#l18.243"></a><span id="l18.243">             FFI_LOG(ffi, &quot;attempt to import key with invalid material&quot;);</span>
<a href="#l18.244"></a><span id="l18.244">             ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.245"></a><span id="l18.245">             goto done;</span>
<a href="#l18.246"></a><span id="l18.246">         }</span>
<a href="#l18.247"></a><span id="l18.247">         // if we got here then we add public key itself or public part of the secret key</span>
<a href="#l18.248"></a><span id="l18.248" class="difflineminus">-        if (!rnp_key_store_import_key(ffi-&gt;pubring, key, true, &amp;pub_status)) {</span>
<a href="#l18.249"></a><span id="l18.249" class="difflineplus">+        if (!rnp_key_store_import_key(ffi-&gt;pubring, &amp;key, true, &amp;pub_status)) {</span>
<a href="#l18.250"></a><span id="l18.250">             ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.251"></a><span id="l18.251">             goto done;</span>
<a href="#l18.252"></a><span id="l18.252">         }</span>
<a href="#l18.253"></a><span id="l18.253">         // import secret key part if available and requested</span>
<a href="#l18.254"></a><span id="l18.254" class="difflineminus">-        if (sec &amp;&amp; pgp_key_is_secret(key)) {</span>
<a href="#l18.255"></a><span id="l18.255" class="difflineminus">-            if (!rnp_key_store_import_key(ffi-&gt;secring, key, false, &amp;sec_status)) {</span>
<a href="#l18.256"></a><span id="l18.256" class="difflineplus">+        if (sec &amp;&amp; pgp_key_is_secret(&amp;key)) {</span>
<a href="#l18.257"></a><span id="l18.257" class="difflineplus">+            if (!rnp_key_store_import_key(ffi-&gt;secring, &amp;key, false, &amp;sec_status)) {</span>
<a href="#l18.258"></a><span id="l18.258">                 ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.259"></a><span id="l18.259">                 goto done;</span>
<a href="#l18.260"></a><span id="l18.260">             }</span>
<a href="#l18.261"></a><span id="l18.261">             // add uids, certifications and other stuff from the public key if any</span>
<a href="#l18.262"></a><span id="l18.262">             pgp_key_t *expub =</span>
<a href="#l18.263"></a><span id="l18.263" class="difflineminus">-              rnp_key_store_get_key_by_grip(ffi-&gt;pubring, pgp_key_get_grip(key));</span>
<a href="#l18.264"></a><span id="l18.264" class="difflineplus">+              rnp_key_store_get_key_by_grip(ffi-&gt;pubring, pgp_key_get_grip(&amp;key));</span>
<a href="#l18.265"></a><span id="l18.265">             if (expub &amp;&amp; !rnp_key_store_import_key(ffi-&gt;secring, expub, true, NULL)) {</span>
<a href="#l18.266"></a><span id="l18.266">                 ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.267"></a><span id="l18.267">                 goto done;</span>
<a href="#l18.268"></a><span id="l18.268">             }</span>
<a href="#l18.269"></a><span id="l18.269">         }</span>
<a href="#l18.270"></a><span id="l18.270">         // now add key fingerprint to json based on statuses</span>
<a href="#l18.271"></a><span id="l18.271" class="difflineminus">-        if ((tmpret = add_key_status(jsokeys, key, pub_status, sec_status))) {</span>
<a href="#l18.272"></a><span id="l18.272" class="difflineplus">+        if ((tmpret = add_key_status(jsokeys, &amp;key, pub_status, sec_status))) {</span>
<a href="#l18.273"></a><span id="l18.273">             ret = tmpret;</span>
<a href="#l18.274"></a><span id="l18.274">             goto done;</span>
<a href="#l18.275"></a><span id="l18.275">         }</span>
<a href="#l18.276"></a><span id="l18.276">     }</span>
<a href="#l18.277"></a><span id="l18.277"> </span>
<a href="#l18.278"></a><span id="l18.278">     if (results) {</span>
<a href="#l18.279"></a><span id="l18.279">         *results = (char *) json_object_to_json_string_ext(jsores, JSON_C_TO_STRING_PRETTY);</span>
<a href="#l18.280"></a><span id="l18.280">         if (!*results) {</span>
<a href="#l18.281"></a><span id="l18.281" class="difflineat">@@ -1334,17 +1335,17 @@ rnp_import_keys(rnp_ffi_t ffi, rnp_input</span>
<a href="#l18.282"></a><span id="l18.282">         if (!*results) {</span>
<a href="#l18.283"></a><span id="l18.283">             ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.284"></a><span id="l18.284">             goto done;</span>
<a href="#l18.285"></a><span id="l18.285">         }</span>
<a href="#l18.286"></a><span id="l18.286">     }</span>
<a href="#l18.287"></a><span id="l18.287"> </span>
<a href="#l18.288"></a><span id="l18.288">     ret = RNP_SUCCESS;</span>
<a href="#l18.289"></a><span id="l18.289"> done:</span>
<a href="#l18.290"></a><span id="l18.290" class="difflineminus">-    rnp_key_store_free(tmp_store);</span>
<a href="#l18.291"></a><span id="l18.291" class="difflineplus">+    delete tmp_store;</span>
<a href="#l18.292"></a><span id="l18.292">     json_object_put(jsores);</span>
<a href="#l18.293"></a><span id="l18.293">     return ret;</span>
<a href="#l18.294"></a><span id="l18.294"> }</span>
<a href="#l18.295"></a><span id="l18.295"> </span>
<a href="#l18.296"></a><span id="l18.296"> static const char *</span>
<a href="#l18.297"></a><span id="l18.297"> sig_status_to_str(pgp_sig_import_status_t status)</span>
<a href="#l18.298"></a><span id="l18.298"> {</span>
<a href="#l18.299"></a><span id="l18.299">     if (status == PGP_SIG_IMPORT_STATUS_UNKNOWN) {</span>
<a href="#l18.300"></a><span id="l18.300" class="difflineat">@@ -1453,68 +1454,72 @@ done:</span>
<a href="#l18.301"></a><span id="l18.301">     signature_list_destroy(&amp;sigs);</span>
<a href="#l18.302"></a><span id="l18.302">     json_object_put(jsores);</span>
<a href="#l18.303"></a><span id="l18.303">     return ret;</span>
<a href="#l18.304"></a><span id="l18.304"> }</span>
<a href="#l18.305"></a><span id="l18.305"> </span>
<a href="#l18.306"></a><span id="l18.306"> static bool</span>
<a href="#l18.307"></a><span id="l18.307"> copy_store_keys(rnp_ffi_t ffi, rnp_key_store_t *dest, rnp_key_store_t *src)</span>
<a href="#l18.308"></a><span id="l18.308"> {</span>
<a href="#l18.309"></a><span id="l18.309" class="difflineminus">-    for (list_item *key = list_front(rnp_key_store_get_keys(src)); key; key = list_next(key)) {</span>
<a href="#l18.310"></a><span id="l18.310" class="difflineminus">-        if (!rnp_key_store_add_key(dest, (pgp_key_t *) key)) {</span>
<a href="#l18.311"></a><span id="l18.311" class="difflineplus">+    for (auto &amp;key : src-&gt;keys) {</span>
<a href="#l18.312"></a><span id="l18.312" class="difflineplus">+        if (!rnp_key_store_add_key(dest, &amp;key)) {</span>
<a href="#l18.313"></a><span id="l18.313">             FFI_LOG(ffi, &quot;failed to add key to the store&quot;);</span>
<a href="#l18.314"></a><span id="l18.314">             return false;</span>
<a href="#l18.315"></a><span id="l18.315">         }</span>
<a href="#l18.316"></a><span id="l18.316">     }</span>
<a href="#l18.317"></a><span id="l18.317">     return true;</span>
<a href="#l18.318"></a><span id="l18.318"> }</span>
<a href="#l18.319"></a><span id="l18.319"> </span>
<a href="#l18.320"></a><span id="l18.320"> static rnp_result_t</span>
<a href="#l18.321"></a><span id="l18.321"> do_save_keys(rnp_ffi_t              ffi,</span>
<a href="#l18.322"></a><span id="l18.322">              rnp_output_t           output,</span>
<a href="#l18.323"></a><span id="l18.323">              pgp_key_store_format_t format,</span>
<a href="#l18.324"></a><span id="l18.324">              key_type_t             key_type)</span>
<a href="#l18.325"></a><span id="l18.325"> {</span>
<a href="#l18.326"></a><span id="l18.326">     rnp_result_t ret = RNP_ERROR_GENERIC;</span>
<a href="#l18.327"></a><span id="l18.327"> </span>
<a href="#l18.328"></a><span id="l18.328">     // create a temporary key store to hold the keys</span>
<a href="#l18.329"></a><span id="l18.329" class="difflineminus">-    rnp_key_store_t *tmp_store = rnp_key_store_new(format, &quot;&quot;);</span>
<a href="#l18.330"></a><span id="l18.330" class="difflineminus">-    if (!tmp_store) {</span>
<a href="#l18.331"></a><span id="l18.331" class="difflineminus">-        // TODO: could also be out of mem</span>
<a href="#l18.332"></a><span id="l18.332" class="difflineplus">+    rnp_key_store_t *tmp_store = NULL;</span>
<a href="#l18.333"></a><span id="l18.333" class="difflineplus">+    try {</span>
<a href="#l18.334"></a><span id="l18.334" class="difflineplus">+        tmp_store = new rnp_key_store_t(format, &quot;&quot;);</span>
<a href="#l18.335"></a><span id="l18.335" class="difflineplus">+    } catch (const std::invalid_argument &amp;e) {</span>
<a href="#l18.336"></a><span id="l18.336">         FFI_LOG(ffi, &quot;Failed to create key store of format: %d&quot;, (int) format);</span>
<a href="#l18.337"></a><span id="l18.337">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.338"></a><span id="l18.338" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l18.339"></a><span id="l18.339" class="difflineplus">+        FFI_LOG(ffi, &quot;%s&quot;, e.what());</span>
<a href="#l18.340"></a><span id="l18.340" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.341"></a><span id="l18.341">     }</span>
<a href="#l18.342"></a><span id="l18.342">     // include the public keys, if desired</span>
<a href="#l18.343"></a><span id="l18.343">     if (key_type == KEY_TYPE_PUBLIC || key_type == KEY_TYPE_ANY) {</span>
<a href="#l18.344"></a><span id="l18.344">         if (!copy_store_keys(ffi, tmp_store, ffi-&gt;pubring)) {</span>
<a href="#l18.345"></a><span id="l18.345">             ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.346"></a><span id="l18.346">             goto done;</span>
<a href="#l18.347"></a><span id="l18.347">         }</span>
<a href="#l18.348"></a><span id="l18.348">     }</span>
<a href="#l18.349"></a><span id="l18.349">     // include the secret keys, if desired</span>
<a href="#l18.350"></a><span id="l18.350">     if (key_type == KEY_TYPE_SECRET || key_type == KEY_TYPE_ANY) {</span>
<a href="#l18.351"></a><span id="l18.351">         if (!copy_store_keys(ffi, tmp_store, ffi-&gt;secring)) {</span>
<a href="#l18.352"></a><span id="l18.352">             ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.353"></a><span id="l18.353">             goto done;</span>
<a href="#l18.354"></a><span id="l18.354">         }</span>
<a href="#l18.355"></a><span id="l18.355">     }</span>
<a href="#l18.356"></a><span id="l18.356">     // preliminary check on the format</span>
<a href="#l18.357"></a><span id="l18.357" class="difflineminus">-    for (list_item *key_item = list_front(rnp_key_store_get_keys(tmp_store)); key_item;</span>
<a href="#l18.358"></a><span id="l18.358" class="difflineminus">-         key_item = list_next(key_item)) {</span>
<a href="#l18.359"></a><span id="l18.359" class="difflineminus">-        if (key_needs_conversion((pgp_key_t *) key_item, tmp_store)) {</span>
<a href="#l18.360"></a><span id="l18.360" class="difflineplus">+    for (auto &amp;key : tmp_store-&gt;keys) {</span>
<a href="#l18.361"></a><span id="l18.361" class="difflineplus">+        if (key_needs_conversion(&amp;key, tmp_store)) {</span>
<a href="#l18.362"></a><span id="l18.362">             FFI_LOG(ffi, &quot;This key format conversion is not yet supported&quot;);</span>
<a href="#l18.363"></a><span id="l18.363">             ret = RNP_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l18.364"></a><span id="l18.364">             goto done;</span>
<a href="#l18.365"></a><span id="l18.365">         }</span>
<a href="#l18.366"></a><span id="l18.366">     }</span>
<a href="#l18.367"></a><span id="l18.367">     // write</span>
<a href="#l18.368"></a><span id="l18.368">     if (output-&gt;dst_directory) {</span>
<a href="#l18.369"></a><span id="l18.369" class="difflineminus">-        free((void *) tmp_store-&gt;path);</span>
<a href="#l18.370"></a><span id="l18.370" class="difflineminus">-        tmp_store-&gt;path = strdup(output-&gt;dst_directory);</span>
<a href="#l18.371"></a><span id="l18.371" class="difflineminus">-        if (!tmp_store-&gt;path) {</span>
<a href="#l18.372"></a><span id="l18.372" class="difflineplus">+        try {</span>
<a href="#l18.373"></a><span id="l18.373" class="difflineplus">+            tmp_store-&gt;path = output-&gt;dst_directory;</span>
<a href="#l18.374"></a><span id="l18.374" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l18.375"></a><span id="l18.375" class="difflineplus">+            FFI_LOG(ffi, &quot;%s&quot;, e.what());</span>
<a href="#l18.376"></a><span id="l18.376">             ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.377"></a><span id="l18.377">             goto done;</span>
<a href="#l18.378"></a><span id="l18.378">         }</span>
<a href="#l18.379"></a><span id="l18.379">         if (!rnp_key_store_write_to_path(tmp_store)) {</span>
<a href="#l18.380"></a><span id="l18.380">             ret = RNP_ERROR_WRITE;</span>
<a href="#l18.381"></a><span id="l18.381">             goto done;</span>
<a href="#l18.382"></a><span id="l18.382">         }</span>
<a href="#l18.383"></a><span id="l18.383">         ret = RNP_SUCCESS;</span>
<a href="#l18.384"></a><span id="l18.384" class="difflineat">@@ -1524,19 +1529,17 @@ do_save_keys(rnp_ffi_t              ffi,</span>
<a href="#l18.385"></a><span id="l18.385">             goto done;</span>
<a href="#l18.386"></a><span id="l18.386">         }</span>
<a href="#l18.387"></a><span id="l18.387">         dst_flush(&amp;output-&gt;dst);</span>
<a href="#l18.388"></a><span id="l18.388">         output-&gt;keep = (output-&gt;dst.werr == RNP_SUCCESS);</span>
<a href="#l18.389"></a><span id="l18.389">         ret = output-&gt;dst.werr;</span>
<a href="#l18.390"></a><span id="l18.390">     }</span>
<a href="#l18.391"></a><span id="l18.391"> </span>
<a href="#l18.392"></a><span id="l18.392"> done:</span>
<a href="#l18.393"></a><span id="l18.393" class="difflineminus">-    if (tmp_store) {</span>
<a href="#l18.394"></a><span id="l18.394" class="difflineminus">-        rnp_key_store_free(tmp_store);</span>
<a href="#l18.395"></a><span id="l18.395" class="difflineminus">-    }</span>
<a href="#l18.396"></a><span id="l18.396" class="difflineplus">+    delete tmp_store;</span>
<a href="#l18.397"></a><span id="l18.397">     return ret;</span>
<a href="#l18.398"></a><span id="l18.398"> }</span>
<a href="#l18.399"></a><span id="l18.399"> </span>
<a href="#l18.400"></a><span id="l18.400"> rnp_result_t</span>
<a href="#l18.401"></a><span id="l18.401"> rnp_save_keys(rnp_ffi_t ffi, const char *format, rnp_output_t output, uint32_t flags)</span>
<a href="#l18.402"></a><span id="l18.402"> {</span>
<a href="#l18.403"></a><span id="l18.403">     // checks</span>
<a href="#l18.404"></a><span id="l18.404">     if (!ffi || !format || !output) {</span>
<a href="#l18.405"></a><span id="l18.405" class="difflineat">@@ -1983,17 +1986,17 @@ rnp_op_add_signature(rnp_ffi_t          </span>
<a href="#l18.406"></a><span id="l18.406">     if (!newsig) {</span>
<a href="#l18.407"></a><span id="l18.407">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.408"></a><span id="l18.408">     }</span>
<a href="#l18.409"></a><span id="l18.409">     newsig-&gt;signer.key = find_suitable_key(</span>
<a href="#l18.410"></a><span id="l18.410">       PGP_OP_SIGN, get_key_prefer_public(key), &amp;key-&gt;ffi-&gt;key_provider, PGP_KF_SIGN);</span>
<a href="#l18.411"></a><span id="l18.411">     if (newsig-&gt;signer.key &amp;&amp; !pgp_key_is_secret(newsig-&gt;signer.key)) {</span>
<a href="#l18.412"></a><span id="l18.412">         pgp_key_request_ctx_t ctx = {.op = PGP_OP_SIGN, .secret = true};</span>
<a href="#l18.413"></a><span id="l18.413">         ctx.search.type = PGP_KEY_SEARCH_GRIP;</span>
<a href="#l18.414"></a><span id="l18.414" class="difflineminus">-        memcpy(ctx.search.by.grip, pgp_key_get_grip(newsig-&gt;signer.key), PGP_KEY_GRIP_SIZE);</span>
<a href="#l18.415"></a><span id="l18.415" class="difflineplus">+        ctx.search.by.grip = pgp_key_get_grip(newsig-&gt;signer.key);</span>
<a href="#l18.416"></a><span id="l18.416">         newsig-&gt;signer.key = pgp_request_key(&amp;key-&gt;ffi-&gt;key_provider, &amp;ctx);</span>
<a href="#l18.417"></a><span id="l18.417">     }</span>
<a href="#l18.418"></a><span id="l18.418">     if (!newsig-&gt;signer.key) {</span>
<a href="#l18.419"></a><span id="l18.419">         list_remove((list_item *) newsig);</span>
<a href="#l18.420"></a><span id="l18.420">         return RNP_ERROR_NO_SUITABLE_KEY;</span>
<a href="#l18.421"></a><span id="l18.421">     }</span>
<a href="#l18.422"></a><span id="l18.422"> </span>
<a href="#l18.423"></a><span id="l18.423">     /* set default create/expire times */</span>
<a href="#l18.424"></a><span id="l18.424" class="difflineat">@@ -2223,17 +2226,18 @@ rnp_op_encrypt_add_password(rnp_op_encry</span>
<a href="#l18.425"></a><span id="l18.425">             if (!pgp_request_password(</span>
<a href="#l18.426"></a><span id="l18.426">                   &amp;op-&gt;ffi-&gt;pass_provider, &amp;pswdctx, &amp;ask_pass[0], ask_pass.size())) {</span>
<a href="#l18.427"></a><span id="l18.427">                 return RNP_ERROR_BAD_PASSWORD;</span>
<a href="#l18.428"></a><span id="l18.428">             }</span>
<a href="#l18.429"></a><span id="l18.429">             password = ask_pass.data();</span>
<a href="#l18.430"></a><span id="l18.430">         }</span>
<a href="#l18.431"></a><span id="l18.431">         return rnp_ctx_add_encryption_password(</span>
<a href="#l18.432"></a><span id="l18.432">           &amp;op-&gt;rnpctx, password, hash_alg, symm_alg, iterations);</span>
<a href="#l18.433"></a><span id="l18.433" class="difflineminus">-    } catch (...) {</span>
<a href="#l18.434"></a><span id="l18.434" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l18.435"></a><span id="l18.435" class="difflineplus">+        FFI_LOG(op-&gt;ffi, &quot;%s&quot;, e.what());</span>
<a href="#l18.436"></a><span id="l18.436">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.437"></a><span id="l18.437">     }</span>
<a href="#l18.438"></a><span id="l18.438"> }</span>
<a href="#l18.439"></a><span id="l18.439"> </span>
<a href="#l18.440"></a><span id="l18.440"> rnp_result_t</span>
<a href="#l18.441"></a><span id="l18.441"> rnp_op_encrypt_set_armor(rnp_op_encrypt_t op, bool armored)</span>
<a href="#l18.442"></a><span id="l18.442"> {</span>
<a href="#l18.443"></a><span id="l18.443">     // checks</span>
<a href="#l18.444"></a><span id="l18.444" class="difflineat">@@ -2794,19 +2798,26 @@ rnp_op_verify_signature_get_handle(rnp_o</span>
<a href="#l18.445"></a><span id="l18.445">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l18.446"></a><span id="l18.446">     }</span>
<a href="#l18.447"></a><span id="l18.447"> </span>
<a href="#l18.448"></a><span id="l18.448">     *handle = (rnp_signature_handle_t) calloc(1, sizeof(**handle));</span>
<a href="#l18.449"></a><span id="l18.449">     if (!*handle) {</span>
<a href="#l18.450"></a><span id="l18.450">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.451"></a><span id="l18.451">     }</span>
<a href="#l18.452"></a><span id="l18.452"> </span>
<a href="#l18.453"></a><span id="l18.453" class="difflineminus">-    pgp_subsig_t *subsig = (pgp_subsig_t *) calloc(1, sizeof(*subsig));</span>
<a href="#l18.454"></a><span id="l18.454" class="difflineplus">+    pgp_subsig_t *subsig = NULL;</span>
<a href="#l18.455"></a><span id="l18.455" class="difflineplus">+    try {</span>
<a href="#l18.456"></a><span id="l18.456" class="difflineplus">+        subsig = new pgp_subsig_t();</span>
<a href="#l18.457"></a><span id="l18.457" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l18.458"></a><span id="l18.458" class="difflineplus">+        FFI_LOG(sig-&gt;ffi, &quot;%s&quot;, e.what());</span>
<a href="#l18.459"></a><span id="l18.459" class="difflineplus">+        free(*handle);</span>
<a href="#l18.460"></a><span id="l18.460" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.461"></a><span id="l18.461" class="difflineplus">+    }</span>
<a href="#l18.462"></a><span id="l18.462">     if (!copy_signature_packet(&amp;subsig-&gt;sig, &amp;sig-&gt;sig_pkt)) {</span>
<a href="#l18.463"></a><span id="l18.463" class="difflineminus">-        free(subsig);</span>
<a href="#l18.464"></a><span id="l18.464" class="difflineplus">+        delete subsig;</span>
<a href="#l18.465"></a><span id="l18.465">         free(*handle);</span>
<a href="#l18.466"></a><span id="l18.466">         *handle = NULL;</span>
<a href="#l18.467"></a><span id="l18.467">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.468"></a><span id="l18.468">     }</span>
<a href="#l18.469"></a><span id="l18.469">     (*handle)-&gt;sig = subsig;</span>
<a href="#l18.470"></a><span id="l18.470">     (*handle)-&gt;ffi = sig-&gt;ffi;</span>
<a href="#l18.471"></a><span id="l18.471">     (*handle)-&gt;key = NULL;</span>
<a href="#l18.472"></a><span id="l18.472">     (*handle)-&gt;own_sig = true;</span>
<a href="#l18.473"></a><span id="l18.473" class="difflineat">@@ -2952,17 +2963,17 @@ str_to_locator(rnp_ffi_t         ffi,</span>
<a href="#l18.474"></a><span id="l18.474">           identifier, locator-&gt;by.fingerprint.fingerprint, PGP_FINGERPRINT_SIZE);</span>
<a href="#l18.475"></a><span id="l18.475">         if (!locator-&gt;by.fingerprint.length) {</span>
<a href="#l18.476"></a><span id="l18.476">             FFI_LOG(ffi, &quot;Invalid fingerprint: %s&quot;, identifier);</span>
<a href="#l18.477"></a><span id="l18.477">             return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.478"></a><span id="l18.478">         }</span>
<a href="#l18.479"></a><span id="l18.479">     } break;</span>
<a href="#l18.480"></a><span id="l18.480">     case PGP_KEY_SEARCH_GRIP: {</span>
<a href="#l18.481"></a><span id="l18.481">         if (strlen(identifier) != (PGP_KEY_GRIP_SIZE * 2) ||</span>
<a href="#l18.482"></a><span id="l18.482" class="difflineminus">-            !rnp_hex_decode(identifier, locator-&gt;by.grip, sizeof(locator-&gt;by.grip))) {</span>
<a href="#l18.483"></a><span id="l18.483" class="difflineplus">+            !rnp_hex_decode(identifier, locator-&gt;by.grip.data(), locator-&gt;by.grip.size())) {</span>
<a href="#l18.484"></a><span id="l18.484">             FFI_LOG(ffi, &quot;Invalid grip: %s&quot;, identifier);</span>
<a href="#l18.485"></a><span id="l18.485">             return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.486"></a><span id="l18.486">         }</span>
<a href="#l18.487"></a><span id="l18.487">     } break;</span>
<a href="#l18.488"></a><span id="l18.488">     default:</span>
<a href="#l18.489"></a><span id="l18.489">         // should never happen</span>
<a href="#l18.490"></a><span id="l18.490">         assert(false);</span>
<a href="#l18.491"></a><span id="l18.491">         return RNP_ERROR_BAD_STATE;</span>
<a href="#l18.492"></a><span id="l18.492" class="difflineat">@@ -3004,18 +3015,18 @@ locator_to_str(const pgp_key_search_t *l</span>
<a href="#l18.493"></a><span id="l18.493">                             locator-&gt;by.fingerprint.length,</span>
<a href="#l18.494"></a><span id="l18.494">                             identifier,</span>
<a href="#l18.495"></a><span id="l18.495">                             identifier_size,</span>
<a href="#l18.496"></a><span id="l18.496">                             RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.497"></a><span id="l18.497">             return false;</span>
<a href="#l18.498"></a><span id="l18.498">         }</span>
<a href="#l18.499"></a><span id="l18.499">         break;</span>
<a href="#l18.500"></a><span id="l18.500">     case PGP_KEY_SEARCH_GRIP:</span>
<a href="#l18.501"></a><span id="l18.501" class="difflineminus">-        if (!rnp_hex_encode(locator-&gt;by.grip,</span>
<a href="#l18.502"></a><span id="l18.502" class="difflineminus">-                            PGP_KEY_GRIP_SIZE,</span>
<a href="#l18.503"></a><span id="l18.503" class="difflineplus">+        if (!rnp_hex_encode(locator-&gt;by.grip.data(),</span>
<a href="#l18.504"></a><span id="l18.504" class="difflineplus">+                            locator-&gt;by.grip.size(),</span>
<a href="#l18.505"></a><span id="l18.505">                             identifier,</span>
<a href="#l18.506"></a><span id="l18.506">                             identifier_size,</span>
<a href="#l18.507"></a><span id="l18.507">                             RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.508"></a><span id="l18.508">             return false;</span>
<a href="#l18.509"></a><span id="l18.509">         }</span>
<a href="#l18.510"></a><span id="l18.510">         break;</span>
<a href="#l18.511"></a><span id="l18.511">     default:</span>
<a href="#l18.512"></a><span id="l18.512">         assert(false);</span>
<a href="#l18.513"></a><span id="l18.513" class="difflineat">@@ -3197,38 +3208,37 @@ rnp_key_get_revocation(rnp_ffi_t        </span>
<a href="#l18.514"></a><span id="l18.514">         FFI_LOG(ffi, &quot;Wrong revocation code: %s&quot;, code);</span>
<a href="#l18.515"></a><span id="l18.515">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.516"></a><span id="l18.516">     }</span>
<a href="#l18.517"></a><span id="l18.517">     if (revinfo.code &gt; PGP_REVOCATION_RETIRED) {</span>
<a href="#l18.518"></a><span id="l18.518">         FFI_LOG(ffi, &quot;Wrong key revocation code: %d&quot;, (int) revinfo.code);</span>
<a href="#l18.519"></a><span id="l18.519">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.520"></a><span id="l18.520">     }</span>
<a href="#l18.521"></a><span id="l18.521">     if (reason) {</span>
<a href="#l18.522"></a><span id="l18.522" class="difflineminus">-        revinfo.reason = strdup(reason);</span>
<a href="#l18.523"></a><span id="l18.523" class="difflineminus">-        if (!revinfo.reason) {</span>
<a href="#l18.524"></a><span id="l18.524" class="difflineminus">-            FFI_LOG(ffi, &quot;Allocation failed&quot;);</span>
<a href="#l18.525"></a><span id="l18.525" class="difflineplus">+        try {</span>
<a href="#l18.526"></a><span id="l18.526" class="difflineplus">+            revinfo.reason = reason;</span>
<a href="#l18.527"></a><span id="l18.527" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l18.528"></a><span id="l18.528" class="difflineplus">+            FFI_LOG(ffi, &quot;%s&quot;, e.what());</span>
<a href="#l18.529"></a><span id="l18.529">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.530"></a><span id="l18.530">         }</span>
<a href="#l18.531"></a><span id="l18.531">     }</span>
<a href="#l18.532"></a><span id="l18.532">     /* unlock the secret key if needed */</span>
<a href="#l18.533"></a><span id="l18.533">     bool locked = pgp_key_is_locked(revoker);</span>
<a href="#l18.534"></a><span id="l18.534">     if (locked &amp;&amp; !pgp_key_unlock(revoker, &amp;ffi-&gt;pass_provider)) {</span>
<a href="#l18.535"></a><span id="l18.535">         FFI_LOG(ffi, &quot;Failed to unlock secret key&quot;);</span>
<a href="#l18.536"></a><span id="l18.536" class="difflineminus">-        revoke_free(&amp;revinfo);</span>
<a href="#l18.537"></a><span id="l18.537">         return RNP_ERROR_BAD_PASSWORD;</span>
<a href="#l18.538"></a><span id="l18.538">     }</span>
<a href="#l18.539"></a><span id="l18.539">     *sig =</span>
<a href="#l18.540"></a><span id="l18.540">       transferable_key_revoke(pgp_key_get_pkt(key), pgp_key_get_pkt(revoker), halg, &amp;revinfo);</span>
<a href="#l18.541"></a><span id="l18.541">     if (!*sig) {</span>
<a href="#l18.542"></a><span id="l18.542">         FFI_LOG(ffi, &quot;Failed to generate revocation signature&quot;);</span>
<a href="#l18.543"></a><span id="l18.543">     }</span>
<a href="#l18.544"></a><span id="l18.544">     if (locked) {</span>
<a href="#l18.545"></a><span id="l18.545">         pgp_key_lock(revoker);</span>
<a href="#l18.546"></a><span id="l18.546">     }</span>
<a href="#l18.547"></a><span id="l18.547" class="difflineminus">-    revoke_free(&amp;revinfo);</span>
<a href="#l18.548"></a><span id="l18.548">     return *sig ? RNP_SUCCESS : RNP_ERROR_BAD_STATE;</span>
<a href="#l18.549"></a><span id="l18.549"> }</span>
<a href="#l18.550"></a><span id="l18.550"> </span>
<a href="#l18.551"></a><span id="l18.551"> rnp_result_t</span>
<a href="#l18.552"></a><span id="l18.552"> rnp_key_export_revocation(rnp_key_handle_t key,</span>
<a href="#l18.553"></a><span id="l18.553">                           rnp_output_t     output,</span>
<a href="#l18.554"></a><span id="l18.554">                           uint32_t         flags,</span>
<a href="#l18.555"></a><span id="l18.555">                           const char *     hash,</span>
<a href="#l18.556"></a><span id="l18.556" class="difflineat">@@ -3713,18 +3723,18 @@ gen_json_grips(char **result, const pgp_</span>
<a href="#l18.557"></a><span id="l18.557">     }</span>
<a href="#l18.558"></a><span id="l18.558"> </span>
<a href="#l18.559"></a><span id="l18.559">     if (primary) {</span>
<a href="#l18.560"></a><span id="l18.560">         json_object *jsoprimary = json_object_new_object();</span>
<a href="#l18.561"></a><span id="l18.561">         if (!jsoprimary) {</span>
<a href="#l18.562"></a><span id="l18.562">             goto done;</span>
<a href="#l18.563"></a><span id="l18.563">         }</span>
<a href="#l18.564"></a><span id="l18.564">         json_object_object_add(jso, &quot;primary&quot;, jsoprimary);</span>
<a href="#l18.565"></a><span id="l18.565" class="difflineminus">-        if (!rnp_hex_encode(pgp_key_get_grip(primary),</span>
<a href="#l18.566"></a><span id="l18.566" class="difflineminus">-                            PGP_KEY_GRIP_SIZE,</span>
<a href="#l18.567"></a><span id="l18.567" class="difflineplus">+        if (!rnp_hex_encode(pgp_key_get_grip(primary).data(),</span>
<a href="#l18.568"></a><span id="l18.568" class="difflineplus">+                            pgp_key_get_grip(primary).size(),</span>
<a href="#l18.569"></a><span id="l18.569">                             grip,</span>
<a href="#l18.570"></a><span id="l18.570">                             sizeof(grip),</span>
<a href="#l18.571"></a><span id="l18.571">                             RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.572"></a><span id="l18.572">             goto done;</span>
<a href="#l18.573"></a><span id="l18.573">         }</span>
<a href="#l18.574"></a><span id="l18.574">         json_object *jsogrip = json_object_new_string(grip);</span>
<a href="#l18.575"></a><span id="l18.575">         if (!jsogrip) {</span>
<a href="#l18.576"></a><span id="l18.576">             goto done;</span>
<a href="#l18.577"></a><span id="l18.577" class="difflineat">@@ -3732,18 +3742,18 @@ gen_json_grips(char **result, const pgp_</span>
<a href="#l18.578"></a><span id="l18.578">         json_object_object_add(jsoprimary, &quot;grip&quot;, jsogrip);</span>
<a href="#l18.579"></a><span id="l18.579">     }</span>
<a href="#l18.580"></a><span id="l18.580">     if (sub) {</span>
<a href="#l18.581"></a><span id="l18.581">         json_object *jsosub = json_object_new_object();</span>
<a href="#l18.582"></a><span id="l18.582">         if (!jsosub) {</span>
<a href="#l18.583"></a><span id="l18.583">             goto done;</span>
<a href="#l18.584"></a><span id="l18.584">         }</span>
<a href="#l18.585"></a><span id="l18.585">         json_object_object_add(jso, &quot;sub&quot;, jsosub);</span>
<a href="#l18.586"></a><span id="l18.586" class="difflineminus">-        if (!rnp_hex_encode(pgp_key_get_grip(sub),</span>
<a href="#l18.587"></a><span id="l18.587" class="difflineminus">-                            PGP_KEY_GRIP_SIZE,</span>
<a href="#l18.588"></a><span id="l18.588" class="difflineplus">+        if (!rnp_hex_encode(pgp_key_get_grip(sub).data(),</span>
<a href="#l18.589"></a><span id="l18.589" class="difflineplus">+                            pgp_key_get_grip(sub).size(),</span>
<a href="#l18.590"></a><span id="l18.590">                             grip,</span>
<a href="#l18.591"></a><span id="l18.591">                             sizeof(grip),</span>
<a href="#l18.592"></a><span id="l18.592">                             RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.593"></a><span id="l18.593">             goto done;</span>
<a href="#l18.594"></a><span id="l18.594">         }</span>
<a href="#l18.595"></a><span id="l18.595">         json_object *jsogrip = json_object_new_string(grip);</span>
<a href="#l18.596"></a><span id="l18.596">         if (!jsogrip) {</span>
<a href="#l18.597"></a><span id="l18.597">             goto done;</span>
<a href="#l18.598"></a><span id="l18.598" class="difflineat">@@ -4687,17 +4697,17 @@ rnp_op_generate_get_key(rnp_op_generate_</span>
<a href="#l18.599"></a><span id="l18.599">     if (!op || !handle) {</span>
<a href="#l18.600"></a><span id="l18.600">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l18.601"></a><span id="l18.601">     }</span>
<a href="#l18.602"></a><span id="l18.602">     if (!op-&gt;gen_sec || !op-&gt;gen_pub) {</span>
<a href="#l18.603"></a><span id="l18.603">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.604"></a><span id="l18.604">     }</span>
<a href="#l18.605"></a><span id="l18.605"> </span>
<a href="#l18.606"></a><span id="l18.606">     *handle = (rnp_key_handle_t) malloc(sizeof(**handle));</span>
<a href="#l18.607"></a><span id="l18.607" class="difflineminus">-    if (!handle) {</span>
<a href="#l18.608"></a><span id="l18.608" class="difflineplus">+    if (!*handle) {</span>
<a href="#l18.609"></a><span id="l18.609">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.610"></a><span id="l18.610">     }</span>
<a href="#l18.611"></a><span id="l18.611">     (*handle)-&gt;ffi = op-&gt;ffi;</span>
<a href="#l18.612"></a><span id="l18.612">     (*handle)-&gt;pub = op-&gt;gen_pub;</span>
<a href="#l18.613"></a><span id="l18.613">     (*handle)-&gt;sec = op-&gt;gen_sec;</span>
<a href="#l18.614"></a><span id="l18.614">     return RNP_SUCCESS;</span>
<a href="#l18.615"></a><span id="l18.615"> }</span>
<a href="#l18.616"></a><span id="l18.616"> </span>
<a href="#l18.617"></a><span id="l18.617" class="difflineat">@@ -4795,23 +4805,20 @@ static rnp_result_t</span>
<a href="#l18.618"></a><span id="l18.618"> key_get_uid_at(pgp_key_t *key, size_t idx, char **uid)</span>
<a href="#l18.619"></a><span id="l18.619"> {</span>
<a href="#l18.620"></a><span id="l18.620">     if (!key || !uid) {</span>
<a href="#l18.621"></a><span id="l18.621">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l18.622"></a><span id="l18.622">     }</span>
<a href="#l18.623"></a><span id="l18.623">     if (idx &gt;= pgp_key_get_userid_count(key)) {</span>
<a href="#l18.624"></a><span id="l18.624">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.625"></a><span id="l18.625">     }</span>
<a href="#l18.626"></a><span id="l18.626" class="difflineminus">-    const char *keyuid = pgp_key_get_userid(key, idx)-&gt;str;</span>
<a href="#l18.627"></a><span id="l18.627" class="difflineminus">-    size_t      len = strlen(keyuid);</span>
<a href="#l18.628"></a><span id="l18.628" class="difflineminus">-    *uid = (char *) calloc(1, len + 1);</span>
<a href="#l18.629"></a><span id="l18.629" class="difflineplus">+    *uid = strdup(pgp_key_get_userid(key, idx)-&gt;str.c_str());</span>
<a href="#l18.630"></a><span id="l18.630">     if (!*uid) {</span>
<a href="#l18.631"></a><span id="l18.631">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.632"></a><span id="l18.632">     }</span>
<a href="#l18.633"></a><span id="l18.633" class="difflineminus">-    memcpy(*uid, keyuid, len);</span>
<a href="#l18.634"></a><span id="l18.634">     return RNP_SUCCESS;</span>
<a href="#l18.635"></a><span id="l18.635"> }</span>
<a href="#l18.636"></a><span id="l18.636"> </span>
<a href="#l18.637"></a><span id="l18.637"> rnp_result_t</span>
<a href="#l18.638"></a><span id="l18.638"> rnp_key_add_uid(rnp_key_handle_t handle,</span>
<a href="#l18.639"></a><span id="l18.639">                 const char *     uid,</span>
<a href="#l18.640"></a><span id="l18.640">                 const char *     hash,</span>
<a href="#l18.641"></a><span id="l18.641">                 uint32_t         expiration,</span>
<a href="#l18.642"></a><span id="l18.642" class="difflineat">@@ -5159,18 +5166,17 @@ done:</span>
<a href="#l18.643"></a><span id="l18.643">     src_close(&amp;memsrc);</span>
<a href="#l18.644"></a><span id="l18.644">     return ret;</span>
<a href="#l18.645"></a><span id="l18.645"> }</span>
<a href="#l18.646"></a><span id="l18.646"> </span>
<a href="#l18.647"></a><span id="l18.647"> rnp_result_t</span>
<a href="#l18.648"></a><span id="l18.648"> rnp_signature_handle_destroy(rnp_signature_handle_t sig)</span>
<a href="#l18.649"></a><span id="l18.649"> {</span>
<a href="#l18.650"></a><span id="l18.650">     if (sig &amp;&amp; sig-&gt;own_sig) {</span>
<a href="#l18.651"></a><span id="l18.651" class="difflineminus">-        pgp_subsig_free(sig-&gt;sig);</span>
<a href="#l18.652"></a><span id="l18.652" class="difflineminus">-        free(sig-&gt;sig);</span>
<a href="#l18.653"></a><span id="l18.653" class="difflineplus">+        delete sig-&gt;sig;</span>
<a href="#l18.654"></a><span id="l18.654">     }</span>
<a href="#l18.655"></a><span id="l18.655">     free(sig);</span>
<a href="#l18.656"></a><span id="l18.656">     return RNP_SUCCESS;</span>
<a href="#l18.657"></a><span id="l18.657"> }</span>
<a href="#l18.658"></a><span id="l18.658"> </span>
<a href="#l18.659"></a><span id="l18.659"> rnp_result_t</span>
<a href="#l18.660"></a><span id="l18.660"> rnp_uid_is_revoked(rnp_uid_handle_t uid, bool *result)</span>
<a href="#l18.661"></a><span id="l18.661"> {</span>
<a href="#l18.662"></a><span id="l18.662" class="difflineat">@@ -5210,20 +5216,20 @@ rnp_key_get_subkey_at(rnp_key_handle_t h</span>
<a href="#l18.663"></a><span id="l18.663"> {</span>
<a href="#l18.664"></a><span id="l18.664">     if (!handle || !subkey) {</span>
<a href="#l18.665"></a><span id="l18.665">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l18.666"></a><span id="l18.666">     }</span>
<a href="#l18.667"></a><span id="l18.667">     pgp_key_t *key = get_key_prefer_public(handle);</span>
<a href="#l18.668"></a><span id="l18.668">     if (idx &gt;= pgp_key_get_subkey_count(key)) {</span>
<a href="#l18.669"></a><span id="l18.669">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.670"></a><span id="l18.670">     }</span>
<a href="#l18.671"></a><span id="l18.671" class="difflineminus">-    const uint8_t *grip = pgp_key_get_subkey_grip(key, idx);</span>
<a href="#l18.672"></a><span id="l18.672" class="difflineminus">-    char           griphex[PGP_KEY_GRIP_SIZE * 2 + 1] = {0};</span>
<a href="#l18.673"></a><span id="l18.673" class="difflineplus">+    const pgp_key_grip_t &amp;grip = pgp_key_get_subkey_grip(key, idx);</span>
<a href="#l18.674"></a><span id="l18.674" class="difflineplus">+    char                  griphex[PGP_KEY_GRIP_SIZE * 2 + 1] = {0};</span>
<a href="#l18.675"></a><span id="l18.675">     if (!rnp_hex_encode(</span>
<a href="#l18.676"></a><span id="l18.676" class="difflineminus">-          grip, PGP_KEY_GRIP_SIZE, griphex, sizeof(griphex), RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.677"></a><span id="l18.677" class="difflineplus">+          grip.data(), grip.size(), griphex, sizeof(griphex), RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.678"></a><span id="l18.678">         return RNP_ERROR_BAD_STATE;</span>
<a href="#l18.679"></a><span id="l18.679">     }</span>
<a href="#l18.680"></a><span id="l18.680">     return rnp_locate_key(handle-&gt;ffi, &quot;grip&quot;, griphex, subkey);</span>
<a href="#l18.681"></a><span id="l18.681"> }</span>
<a href="#l18.682"></a><span id="l18.682"> </span>
<a href="#l18.683"></a><span id="l18.683"> rnp_result_t</span>
<a href="#l18.684"></a><span id="l18.684"> rnp_key_get_alg(rnp_key_handle_t handle, char **alg)</span>
<a href="#l18.685"></a><span id="l18.685"> {</span>
<a href="#l18.686"></a><span id="l18.686" class="difflineat">@@ -5348,45 +5354,48 @@ rnp_key_get_grip(rnp_key_handle_t handle</span>
<a href="#l18.687"></a><span id="l18.687">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l18.688"></a><span id="l18.688"> </span>
<a href="#l18.689"></a><span id="l18.689">     size_t hex_len = PGP_KEY_GRIP_SIZE * 2 + 1;</span>
<a href="#l18.690"></a><span id="l18.690">     *grip = (char *) malloc(hex_len);</span>
<a href="#l18.691"></a><span id="l18.691">     if (*grip == NULL)</span>
<a href="#l18.692"></a><span id="l18.692">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.693"></a><span id="l18.693"> </span>
<a href="#l18.694"></a><span id="l18.694">     pgp_key_t *key = get_key_prefer_public(handle);</span>
<a href="#l18.695"></a><span id="l18.695" class="difflineminus">-    if (!rnp_hex_encode(</span>
<a href="#l18.696"></a><span id="l18.696" class="difflineminus">-          pgp_key_get_grip(key), PGP_KEY_GRIP_SIZE, *grip, hex_len, RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.697"></a><span id="l18.697" class="difflineplus">+    if (!rnp_hex_encode(pgp_key_get_grip(key).data(),</span>
<a href="#l18.698"></a><span id="l18.698" class="difflineplus">+                        pgp_key_get_grip(key).size(),</span>
<a href="#l18.699"></a><span id="l18.699" class="difflineplus">+                        *grip,</span>
<a href="#l18.700"></a><span id="l18.700" class="difflineplus">+                        hex_len,</span>
<a href="#l18.701"></a><span id="l18.701" class="difflineplus">+                        RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.702"></a><span id="l18.702">         return RNP_ERROR_GENERIC;</span>
<a href="#l18.703"></a><span id="l18.703">     }</span>
<a href="#l18.704"></a><span id="l18.704">     return RNP_SUCCESS;</span>
<a href="#l18.705"></a><span id="l18.705"> }</span>
<a href="#l18.706"></a><span id="l18.706"> </span>
<a href="#l18.707"></a><span id="l18.707"> rnp_result_t</span>
<a href="#l18.708"></a><span id="l18.708"> rnp_key_get_primary_grip(rnp_key_handle_t handle, char **grip)</span>
<a href="#l18.709"></a><span id="l18.709"> {</span>
<a href="#l18.710"></a><span id="l18.710">     if (handle == NULL || grip == NULL) {</span>
<a href="#l18.711"></a><span id="l18.711">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l18.712"></a><span id="l18.712">     }</span>
<a href="#l18.713"></a><span id="l18.713"> </span>
<a href="#l18.714"></a><span id="l18.714">     pgp_key_t *key = get_key_prefer_public(handle);</span>
<a href="#l18.715"></a><span id="l18.715">     if (!pgp_key_is_subkey(key)) {</span>
<a href="#l18.716"></a><span id="l18.716">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.717"></a><span id="l18.717">     }</span>
<a href="#l18.718"></a><span id="l18.718" class="difflineminus">-    if (!pgp_key_get_primary_grip(key)) {</span>
<a href="#l18.719"></a><span id="l18.719" class="difflineplus">+    if (!pgp_key_has_primary_grip(key)) {</span>
<a href="#l18.720"></a><span id="l18.720">         *grip = NULL;</span>
<a href="#l18.721"></a><span id="l18.721">         return RNP_SUCCESS;</span>
<a href="#l18.722"></a><span id="l18.722">     }</span>
<a href="#l18.723"></a><span id="l18.723">     size_t hex_len = PGP_KEY_GRIP_SIZE * 2 + 1;</span>
<a href="#l18.724"></a><span id="l18.724">     *grip = (char *) malloc(hex_len);</span>
<a href="#l18.725"></a><span id="l18.725">     if (*grip == NULL) {</span>
<a href="#l18.726"></a><span id="l18.726">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.727"></a><span id="l18.727">     }</span>
<a href="#l18.728"></a><span id="l18.728" class="difflineminus">-    if (!rnp_hex_encode(pgp_key_get_primary_grip(key),</span>
<a href="#l18.729"></a><span id="l18.729" class="difflineminus">-                        PGP_KEY_GRIP_SIZE,</span>
<a href="#l18.730"></a><span id="l18.730" class="difflineplus">+    if (!rnp_hex_encode(pgp_key_get_primary_grip(key).data(),</span>
<a href="#l18.731"></a><span id="l18.731" class="difflineplus">+                        pgp_key_get_primary_grip(key).size(),</span>
<a href="#l18.732"></a><span id="l18.732">                         *grip,</span>
<a href="#l18.733"></a><span id="l18.733">                         hex_len,</span>
<a href="#l18.734"></a><span id="l18.734">                         RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.735"></a><span id="l18.735">         free(*grip);</span>
<a href="#l18.736"></a><span id="l18.736">         return RNP_ERROR_GENERIC;</span>
<a href="#l18.737"></a><span id="l18.737">     }</span>
<a href="#l18.738"></a><span id="l18.738">     return RNP_SUCCESS;</span>
<a href="#l18.739"></a><span id="l18.739"> }</span>
<a href="#l18.740"></a><span id="l18.740" class="difflineat">@@ -5469,26 +5478,25 @@ rnp_key_set_expiration(rnp_key_handle_t </span>
<a href="#l18.741"></a><span id="l18.741">     }</span>
<a href="#l18.742"></a><span id="l18.742"> </span>
<a href="#l18.743"></a><span id="l18.743">     if (pgp_key_is_primary_key(pkey)) {</span>
<a href="#l18.744"></a><span id="l18.744">         bool res = pgp_key_set_expiration(pkey, skey, expiry);</span>
<a href="#l18.745"></a><span id="l18.745">         return res ? RNP_SUCCESS : RNP_ERROR_GENERIC;</span>
<a href="#l18.746"></a><span id="l18.746">     }</span>
<a href="#l18.747"></a><span id="l18.747"> </span>
<a href="#l18.748"></a><span id="l18.748">     /* for subkey we need primary key */</span>
<a href="#l18.749"></a><span id="l18.749" class="difflineminus">-    const uint8_t *grip = pgp_key_get_primary_grip(pkey);</span>
<a href="#l18.750"></a><span id="l18.750" class="difflineminus">-    if (!grip) {</span>
<a href="#l18.751"></a><span id="l18.751" class="difflineplus">+    if (!pgp_key_has_primary_grip(pkey)) {</span>
<a href="#l18.752"></a><span id="l18.752">         FFI_LOG(key-&gt;ffi, &quot;Primary key grip not available.&quot;);</span>
<a href="#l18.753"></a><span id="l18.753">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.754"></a><span id="l18.754">     }</span>
<a href="#l18.755"></a><span id="l18.755"> </span>
<a href="#l18.756"></a><span id="l18.756">     pgp_key_request_ctx_t request = {};</span>
<a href="#l18.757"></a><span id="l18.757">     request.secret = true;</span>
<a href="#l18.758"></a><span id="l18.758">     request.search.type = PGP_KEY_SEARCH_GRIP;</span>
<a href="#l18.759"></a><span id="l18.759" class="difflineminus">-    memcpy(request.search.by.grip, grip, PGP_KEY_GRIP_SIZE);</span>
<a href="#l18.760"></a><span id="l18.760" class="difflineplus">+    request.search.by.grip = pgp_key_get_primary_grip(pkey);</span>
<a href="#l18.761"></a><span id="l18.761">     pgp_key_t *prim_sec = pgp_request_key(&amp;key-&gt;ffi-&gt;key_provider, &amp;request);</span>
<a href="#l18.762"></a><span id="l18.762">     if (!prim_sec) {</span>
<a href="#l18.763"></a><span id="l18.763">         FFI_LOG(key-&gt;ffi, &quot;Primary secret key not found.&quot;);</span>
<a href="#l18.764"></a><span id="l18.764">         return RNP_ERROR_KEY_NOT_FOUND;</span>
<a href="#l18.765"></a><span id="l18.765">     }</span>
<a href="#l18.766"></a><span id="l18.766"> </span>
<a href="#l18.767"></a><span id="l18.767">     bool res = pgp_subkey_set_expiration(pkey, prim_sec, skey, expiry);</span>
<a href="#l18.768"></a><span id="l18.768">     return res ? RNP_SUCCESS : RNP_ERROR_GENERIC;</span>
<a href="#l18.769"></a><span id="l18.769" class="difflineat">@@ -5500,22 +5508,17 @@ rnp_key_get_revocation_reason(rnp_key_ha</span>
<a href="#l18.770"></a><span id="l18.770">     if (!handle || !result) {</span>
<a href="#l18.771"></a><span id="l18.771">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l18.772"></a><span id="l18.772">     }</span>
<a href="#l18.773"></a><span id="l18.773">     pgp_key_t *key = get_key_prefer_public(handle);</span>
<a href="#l18.774"></a><span id="l18.774">     if (!key || !key-&gt;revoked) {</span>
<a href="#l18.775"></a><span id="l18.775">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.776"></a><span id="l18.776">     }</span>
<a href="#l18.777"></a><span id="l18.777"> </span>
<a href="#l18.778"></a><span id="l18.778" class="difflineminus">-    if (!key-&gt;revocation.reason) {</span>
<a href="#l18.779"></a><span id="l18.779" class="difflineminus">-        *result = NULL;</span>
<a href="#l18.780"></a><span id="l18.780" class="difflineminus">-        return RNP_SUCCESS;</span>
<a href="#l18.781"></a><span id="l18.781" class="difflineminus">-    }</span>
<a href="#l18.782"></a><span id="l18.782" class="difflineminus">-</span>
<a href="#l18.783"></a><span id="l18.783" class="difflineminus">-    *result = strdup(key-&gt;revocation.reason);</span>
<a href="#l18.784"></a><span id="l18.784" class="difflineplus">+    *result = strdup(key-&gt;revocation.reason.c_str());</span>
<a href="#l18.785"></a><span id="l18.785">     if (!*result) {</span>
<a href="#l18.786"></a><span id="l18.786">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.787"></a><span id="l18.787">     }</span>
<a href="#l18.788"></a><span id="l18.788">     return RNP_SUCCESS;</span>
<a href="#l18.789"></a><span id="l18.789"> }</span>
<a href="#l18.790"></a><span id="l18.790"> </span>
<a href="#l18.791"></a><span id="l18.791"> static rnp_result_t</span>
<a href="#l18.792"></a><span id="l18.792"> rnp_key_is_revoked_with_code(rnp_key_handle_t handle, bool *result, int code)</span>
<a href="#l18.793"></a><span id="l18.793" class="difflineat">@@ -5751,35 +5754,30 @@ rnp_key_have_public(rnp_key_handle_t han</span>
<a href="#l18.794"></a><span id="l18.794">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l18.795"></a><span id="l18.795">     *result = handle-&gt;pub != NULL;</span>
<a href="#l18.796"></a><span id="l18.796">     return RNP_SUCCESS;</span>
<a href="#l18.797"></a><span id="l18.797"> }</span>
<a href="#l18.798"></a><span id="l18.798"> </span>
<a href="#l18.799"></a><span id="l18.799"> static rnp_result_t</span>
<a href="#l18.800"></a><span id="l18.800"> key_to_bytes(pgp_key_t *key, uint8_t **buf, size_t *buf_len)</span>
<a href="#l18.801"></a><span id="l18.801"> {</span>
<a href="#l18.802"></a><span id="l18.802" class="difflineminus">-    // get a total byte size</span>
<a href="#l18.803"></a><span id="l18.803" class="difflineminus">-    *buf_len = 0;</span>
<a href="#l18.804"></a><span id="l18.804" class="difflineminus">-    for (size_t i = 0; i &lt; pgp_key_get_rawpacket_count(key); i++) {</span>
<a href="#l18.805"></a><span id="l18.805" class="difflineminus">-        const pgp_rawpacket_t *pkt = pgp_key_get_rawpacket(key, i);</span>
<a href="#l18.806"></a><span id="l18.806" class="difflineminus">-        *buf_len += pkt-&gt;length;</span>
<a href="#l18.807"></a><span id="l18.807" class="difflineminus">-    }</span>
<a href="#l18.808"></a><span id="l18.808" class="difflineminus">-    // allocate our buffer</span>
<a href="#l18.809"></a><span id="l18.809" class="difflineminus">-    *buf = (uint8_t *) malloc(*buf_len);</span>
<a href="#l18.810"></a><span id="l18.810" class="difflineminus">-    if (!*buf) {</span>
<a href="#l18.811"></a><span id="l18.811" class="difflineminus">-        *buf_len = 0;</span>
<a href="#l18.812"></a><span id="l18.812" class="difflineplus">+    pgp_dest_t memdst = {};</span>
<a href="#l18.813"></a><span id="l18.813" class="difflineplus">+</span>
<a href="#l18.814"></a><span id="l18.814" class="difflineplus">+    if (init_mem_dest(&amp;memdst, NULL, 0)) {</span>
<a href="#l18.815"></a><span id="l18.815">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.816"></a><span id="l18.816">     }</span>
<a href="#l18.817"></a><span id="l18.817" class="difflineminus">-    // copy each packet</span>
<a href="#l18.818"></a><span id="l18.818" class="difflineminus">-    *buf_len = 0;</span>
<a href="#l18.819"></a><span id="l18.819" class="difflineminus">-    for (size_t i = 0; i &lt; pgp_key_get_rawpacket_count(key); i++) {</span>
<a href="#l18.820"></a><span id="l18.820" class="difflineminus">-        const pgp_rawpacket_t *pkt = pgp_key_get_rawpacket(key, i);</span>
<a href="#l18.821"></a><span id="l18.821" class="difflineminus">-        memcpy(*buf + *buf_len, pkt-&gt;raw, pkt-&gt;length);</span>
<a href="#l18.822"></a><span id="l18.822" class="difflineminus">-        *buf_len += pkt-&gt;length;</span>
<a href="#l18.823"></a><span id="l18.823" class="difflineminus">-    }</span>
<a href="#l18.824"></a><span id="l18.824" class="difflineplus">+</span>
<a href="#l18.825"></a><span id="l18.825" class="difflineplus">+    if (!pgp_key_write_packets(key, &amp;memdst)) {</span>
<a href="#l18.826"></a><span id="l18.826" class="difflineplus">+        dst_close(&amp;memdst, true);</span>
<a href="#l18.827"></a><span id="l18.827" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.828"></a><span id="l18.828" class="difflineplus">+    }</span>
<a href="#l18.829"></a><span id="l18.829" class="difflineplus">+</span>
<a href="#l18.830"></a><span id="l18.830" class="difflineplus">+    *buf_len = memdst.writeb;</span>
<a href="#l18.831"></a><span id="l18.831" class="difflineplus">+    *buf = (uint8_t *) mem_dest_own_memory(&amp;memdst);</span>
<a href="#l18.832"></a><span id="l18.832" class="difflineplus">+    dst_close(&amp;memdst, true);</span>
<a href="#l18.833"></a><span id="l18.833">     return RNP_SUCCESS;</span>
<a href="#l18.834"></a><span id="l18.834"> }</span>
<a href="#l18.835"></a><span id="l18.835"> </span>
<a href="#l18.836"></a><span id="l18.836"> rnp_result_t</span>
<a href="#l18.837"></a><span id="l18.837"> rnp_get_public_key_data(rnp_key_handle_t handle, uint8_t **buf, size_t *buf_len)</span>
<a href="#l18.838"></a><span id="l18.838"> {</span>
<a href="#l18.839"></a><span id="l18.839">     // checks</span>
<a href="#l18.840"></a><span id="l18.840">     if (!handle || !buf || !buf_len) {</span>
<a href="#l18.841"></a><span id="l18.841" class="difflineat">@@ -6273,18 +6271,21 @@ key_to_json(json_object *jso, rnp_key_ha</span>
<a href="#l18.842"></a><span id="l18.842">                         RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.843"></a><span id="l18.843">         return RNP_ERROR_GENERIC;</span>
<a href="#l18.844"></a><span id="l18.844">     }</span>
<a href="#l18.845"></a><span id="l18.845">     if (!add_json_string_field(jso, &quot;fingerprint&quot;, fpr)) {</span>
<a href="#l18.846"></a><span id="l18.846">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.847"></a><span id="l18.847">     }</span>
<a href="#l18.848"></a><span id="l18.848">     // grip</span>
<a href="#l18.849"></a><span id="l18.849">     char grip[PGP_KEY_GRIP_SIZE * 2 + 1];</span>
<a href="#l18.850"></a><span id="l18.850" class="difflineminus">-    if (!rnp_hex_encode(</span>
<a href="#l18.851"></a><span id="l18.851" class="difflineminus">-          pgp_key_get_grip(key), PGP_KEY_GRIP_SIZE, grip, sizeof(grip), RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.852"></a><span id="l18.852" class="difflineplus">+    if (!rnp_hex_encode(pgp_key_get_grip(key).data(),</span>
<a href="#l18.853"></a><span id="l18.853" class="difflineplus">+                        pgp_key_get_grip(key).size(),</span>
<a href="#l18.854"></a><span id="l18.854" class="difflineplus">+                        grip,</span>
<a href="#l18.855"></a><span id="l18.855" class="difflineplus">+                        sizeof(grip),</span>
<a href="#l18.856"></a><span id="l18.856" class="difflineplus">+                        RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.857"></a><span id="l18.857">         return RNP_ERROR_GENERIC;</span>
<a href="#l18.858"></a><span id="l18.858">     }</span>
<a href="#l18.859"></a><span id="l18.859">     if (!add_json_string_field(jso, &quot;grip&quot;, grip)) {</span>
<a href="#l18.860"></a><span id="l18.860">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.861"></a><span id="l18.861">     }</span>
<a href="#l18.862"></a><span id="l18.862">     // revoked</span>
<a href="#l18.863"></a><span id="l18.863">     json_object *jsorevoked = json_object_new_boolean(key-&gt;revoked ? true : false);</span>
<a href="#l18.864"></a><span id="l18.864">     if (!jsorevoked) {</span>
<a href="#l18.865"></a><span id="l18.865" class="difflineat">@@ -6313,36 +6314,31 @@ key_to_json(json_object *jso, rnp_key_ha</span>
<a href="#l18.866"></a><span id="l18.866">     }</span>
<a href="#l18.867"></a><span id="l18.867">     // parent / subkeys</span>
<a href="#l18.868"></a><span id="l18.868">     if (pgp_key_is_primary_key(key)) {</span>
<a href="#l18.869"></a><span id="l18.869">         json_object *jsosubkeys_arr = json_object_new_array();</span>
<a href="#l18.870"></a><span id="l18.870">         if (!jsosubkeys_arr) {</span>
<a href="#l18.871"></a><span id="l18.871">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.872"></a><span id="l18.872">         }</span>
<a href="#l18.873"></a><span id="l18.873">         json_object_object_add(jso, &quot;subkey grips&quot;, jsosubkeys_arr);</span>
<a href="#l18.874"></a><span id="l18.874" class="difflineminus">-        list_item *subgrip_item = list_front(key-&gt;subkey_grips);</span>
<a href="#l18.875"></a><span id="l18.875" class="difflineminus">-        while (subgrip_item) {</span>
<a href="#l18.876"></a><span id="l18.876" class="difflineminus">-            uint8_t *subgrip = (uint8_t *) subgrip_item;</span>
<a href="#l18.877"></a><span id="l18.877" class="difflineplus">+        for (auto &amp;subgrip : key-&gt;subkey_grips) {</span>
<a href="#l18.878"></a><span id="l18.878">             if (!rnp_hex_encode(</span>
<a href="#l18.879"></a><span id="l18.879" class="difflineminus">-                  subgrip, PGP_KEY_GRIP_SIZE, grip, sizeof(grip), RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.880"></a><span id="l18.880" class="difflineplus">+                  subgrip.data(), subgrip.size(), grip, sizeof(grip), RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.881"></a><span id="l18.881">                 return RNP_ERROR_GENERIC;</span>
<a href="#l18.882"></a><span id="l18.882">             }</span>
<a href="#l18.883"></a><span id="l18.883">             json_object *jsostr = json_object_new_string(grip);</span>
<a href="#l18.884"></a><span id="l18.884">             if (!jsostr || json_object_array_add(jsosubkeys_arr, jsostr)) {</span>
<a href="#l18.885"></a><span id="l18.885">                 json_object_put(jsostr);</span>
<a href="#l18.886"></a><span id="l18.886">                 return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.887"></a><span id="l18.887">             }</span>
<a href="#l18.888"></a><span id="l18.888" class="difflineminus">-            subgrip_item = list_next(subgrip_item);</span>
<a href="#l18.889"></a><span id="l18.889">         }</span>
<a href="#l18.890"></a><span id="l18.890">     } else {</span>
<a href="#l18.891"></a><span id="l18.891" class="difflineminus">-        if (!rnp_hex_encode(pgp_key_get_primary_grip(key),</span>
<a href="#l18.892"></a><span id="l18.892" class="difflineminus">-                            PGP_KEY_GRIP_SIZE,</span>
<a href="#l18.893"></a><span id="l18.893" class="difflineminus">-                            grip,</span>
<a href="#l18.894"></a><span id="l18.894" class="difflineminus">-                            sizeof(grip),</span>
<a href="#l18.895"></a><span id="l18.895" class="difflineminus">-                            RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.896"></a><span id="l18.896" class="difflineplus">+        auto pgrip = pgp_key_get_primary_grip(key);</span>
<a href="#l18.897"></a><span id="l18.897" class="difflineplus">+        if (!rnp_hex_encode(</span>
<a href="#l18.898"></a><span id="l18.898" class="difflineplus">+              pgrip.data(), pgrip.size(), grip, sizeof(grip), RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.899"></a><span id="l18.899">             return RNP_ERROR_GENERIC;</span>
<a href="#l18.900"></a><span id="l18.900">         }</span>
<a href="#l18.901"></a><span id="l18.901">         if (!add_json_string_field(jso, &quot;primary key grip&quot;, grip)) {</span>
<a href="#l18.902"></a><span id="l18.902">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.903"></a><span id="l18.903">         }</span>
<a href="#l18.904"></a><span id="l18.904">     }</span>
<a href="#l18.905"></a><span id="l18.905">     // public</span>
<a href="#l18.906"></a><span id="l18.906">     json_object *jsopublic = json_object_new_object();</span>
<a href="#l18.907"></a><span id="l18.907" class="difflineat">@@ -6403,17 +6399,18 @@ key_to_json(json_object *jso, rnp_key_ha</span>
<a href="#l18.908"></a><span id="l18.908">     // userids</span>
<a href="#l18.909"></a><span id="l18.909">     if (pgp_key_is_primary_key(key)) {</span>
<a href="#l18.910"></a><span id="l18.910">         json_object *jsouids_arr = json_object_new_array();</span>
<a href="#l18.911"></a><span id="l18.911">         if (!jsouids_arr) {</span>
<a href="#l18.912"></a><span id="l18.912">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.913"></a><span id="l18.913">         }</span>
<a href="#l18.914"></a><span id="l18.914">         json_object_object_add(jso, &quot;userids&quot;, jsouids_arr);</span>
<a href="#l18.915"></a><span id="l18.915">         for (unsigned i = 0; i &lt; pgp_key_get_userid_count(key); i++) {</span>
<a href="#l18.916"></a><span id="l18.916" class="difflineminus">-            json_object *jsouid = json_object_new_string(pgp_key_get_userid(key, i)-&gt;str);</span>
<a href="#l18.917"></a><span id="l18.917" class="difflineplus">+            json_object *jsouid =</span>
<a href="#l18.918"></a><span id="l18.918" class="difflineplus">+              json_object_new_string(pgp_key_get_userid(key, i)-&gt;str.c_str());</span>
<a href="#l18.919"></a><span id="l18.919">             if (!jsouid || json_object_array_add(jsouids_arr, jsouid)) {</span>
<a href="#l18.920"></a><span id="l18.920">                 json_object_put(jsouid);</span>
<a href="#l18.921"></a><span id="l18.921">                 return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.922"></a><span id="l18.922">             }</span>
<a href="#l18.923"></a><span id="l18.923">         }</span>
<a href="#l18.924"></a><span id="l18.924">     }</span>
<a href="#l18.925"></a><span id="l18.925">     // signatures</span>
<a href="#l18.926"></a><span id="l18.926">     if (flags &amp; RNP_JSON_SIGNATURES) {</span>
<a href="#l18.927"></a><span id="l18.927" class="difflineat">@@ -6585,58 +6582,57 @@ rnp_dump_packets_to_output(rnp_input_t i</span>
<a href="#l18.928"></a><span id="l18.928">         dumpctx.dump_grips = true;</span>
<a href="#l18.929"></a><span id="l18.929">         flags &amp;= ~RNP_DUMP_GRIP;</span>
<a href="#l18.930"></a><span id="l18.930">     }</span>
<a href="#l18.931"></a><span id="l18.931">     if (flags) {</span>
<a href="#l18.932"></a><span id="l18.932">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.933"></a><span id="l18.933">     }</span>
<a href="#l18.934"></a><span id="l18.934"> </span>
<a href="#l18.935"></a><span id="l18.935">     rnp_result_t ret = stream_dump_packets(&amp;dumpctx, &amp;input-&gt;src, &amp;output-&gt;dst);</span>
<a href="#l18.936"></a><span id="l18.936" class="difflineminus">-    output-&gt;keep = !ret;</span>
<a href="#l18.937"></a><span id="l18.937" class="difflineplus">+    output-&gt;keep = true;</span>
<a href="#l18.938"></a><span id="l18.938">     return ret;</span>
<a href="#l18.939"></a><span id="l18.939"> }</span>
<a href="#l18.940"></a><span id="l18.940"> </span>
<a href="#l18.941"></a><span id="l18.941"> // move to next key</span>
<a href="#l18.942"></a><span id="l18.942"> static bool</span>
<a href="#l18.943"></a><span id="l18.943"> key_iter_next_key(rnp_identifier_iterator_t it)</span>
<a href="#l18.944"></a><span id="l18.944"> {</span>
<a href="#l18.945"></a><span id="l18.945" class="difflineminus">-    it-&gt;keyp = (pgp_key_t *) list_next((list_item *) it-&gt;keyp);</span>
<a href="#l18.946"></a><span id="l18.946" class="difflineminus">-    it-&gt;uididx = 0;</span>
<a href="#l18.947"></a><span id="l18.947" class="difflineminus">-    // check if we reached the end of the ring</span>
<a href="#l18.948"></a><span id="l18.948" class="difflineminus">-    if (!it-&gt;keyp) {</span>
<a href="#l18.949"></a><span id="l18.949" class="difflineminus">-        // if we are currently on pubring, switch to secring (if not empty)</span>
<a href="#l18.950"></a><span id="l18.950" class="difflineminus">-        if (it-&gt;store == it-&gt;ffi-&gt;pubring &amp;&amp; rnp_key_store_get_key_count(it-&gt;ffi-&gt;secring)) {</span>
<a href="#l18.951"></a><span id="l18.951" class="difflineminus">-            it-&gt;store = it-&gt;ffi-&gt;secring;</span>
<a href="#l18.952"></a><span id="l18.952" class="difflineminus">-            it-&gt;keyp = (pgp_key_t *) list_front(rnp_key_store_get_keys(it-&gt;store));</span>
<a href="#l18.953"></a><span id="l18.953" class="difflineminus">-        } else {</span>
<a href="#l18.954"></a><span id="l18.954" class="difflineminus">-            // we've gone through both rings</span>
<a href="#l18.955"></a><span id="l18.955" class="difflineminus">-            return false;</span>
<a href="#l18.956"></a><span id="l18.956" class="difflineminus">-        }</span>
<a href="#l18.957"></a><span id="l18.957" class="difflineplus">+    // check if we not reached the end of the ring</span>
<a href="#l18.958"></a><span id="l18.958" class="difflineplus">+    it-&gt;keyp = std::next(it-&gt;keyp);</span>
<a href="#l18.959"></a><span id="l18.959" class="difflineplus">+    if (it-&gt;keyp != it-&gt;store-&gt;keys.end()) {</span>
<a href="#l18.960"></a><span id="l18.960" class="difflineplus">+        it-&gt;uididx = 0;</span>
<a href="#l18.961"></a><span id="l18.961" class="difflineplus">+        return true;</span>
<a href="#l18.962"></a><span id="l18.962" class="difflineplus">+    }</span>
<a href="#l18.963"></a><span id="l18.963" class="difflineplus">+    // if we are currently on pubring, switch to secring (if not empty)</span>
<a href="#l18.964"></a><span id="l18.964" class="difflineplus">+    if (it-&gt;store == it-&gt;ffi-&gt;pubring &amp;&amp; rnp_key_store_get_key_count(it-&gt;ffi-&gt;secring)) {</span>
<a href="#l18.965"></a><span id="l18.965" class="difflineplus">+        it-&gt;store = it-&gt;ffi-&gt;secring;</span>
<a href="#l18.966"></a><span id="l18.966" class="difflineplus">+        it-&gt;keyp = it-&gt;store-&gt;keys.begin();</span>
<a href="#l18.967"></a><span id="l18.967" class="difflineplus">+    } else {</span>
<a href="#l18.968"></a><span id="l18.968" class="difflineplus">+        // we've gone through both rings</span>
<a href="#l18.969"></a><span id="l18.969" class="difflineplus">+        return false;</span>
<a href="#l18.970"></a><span id="l18.970">     }</span>
<a href="#l18.971"></a><span id="l18.971">     return true;</span>
<a href="#l18.972"></a><span id="l18.972"> }</span>
<a href="#l18.973"></a><span id="l18.973"> </span>
<a href="#l18.974"></a><span id="l18.974"> // move to next item (key or userid)</span>
<a href="#l18.975"></a><span id="l18.975"> static bool</span>
<a href="#l18.976"></a><span id="l18.976"> key_iter_next_item(rnp_identifier_iterator_t it)</span>
<a href="#l18.977"></a><span id="l18.977"> {</span>
<a href="#l18.978"></a><span id="l18.978">     switch (it-&gt;type) {</span>
<a href="#l18.979"></a><span id="l18.979">     case PGP_KEY_SEARCH_KEYID:</span>
<a href="#l18.980"></a><span id="l18.980">     case PGP_KEY_SEARCH_FINGERPRINT:</span>
<a href="#l18.981"></a><span id="l18.981">     case PGP_KEY_SEARCH_GRIP:</span>
<a href="#l18.982"></a><span id="l18.982">         return key_iter_next_key(it);</span>
<a href="#l18.983"></a><span id="l18.983">     case PGP_KEY_SEARCH_USERID:</span>
<a href="#l18.984"></a><span id="l18.984">         it-&gt;uididx++;</span>
<a href="#l18.985"></a><span id="l18.985" class="difflineminus">-        if (it-&gt;keyp) {</span>
<a href="#l18.986"></a><span id="l18.986" class="difflineminus">-            while (it-&gt;uididx &gt;= pgp_key_get_userid_count(it-&gt;keyp)) {</span>
<a href="#l18.987"></a><span id="l18.987" class="difflineminus">-                if (!key_iter_next_key(it)) {</span>
<a href="#l18.988"></a><span id="l18.988" class="difflineminus">-                    return false;</span>
<a href="#l18.989"></a><span id="l18.989" class="difflineminus">-                }</span>
<a href="#l18.990"></a><span id="l18.990" class="difflineminus">-                it-&gt;uididx = 0;</span>
<a href="#l18.991"></a><span id="l18.991" class="difflineplus">+        while (it-&gt;uididx &gt;= pgp_key_get_userid_count(&amp;*it-&gt;keyp)) {</span>
<a href="#l18.992"></a><span id="l18.992" class="difflineplus">+            if (!key_iter_next_key(it)) {</span>
<a href="#l18.993"></a><span id="l18.993" class="difflineplus">+                return false;</span>
<a href="#l18.994"></a><span id="l18.994">             }</span>
<a href="#l18.995"></a><span id="l18.995" class="difflineplus">+            it-&gt;uididx = 0;</span>
<a href="#l18.996"></a><span id="l18.996">         }</span>
<a href="#l18.997"></a><span id="l18.997">         break;</span>
<a href="#l18.998"></a><span id="l18.998">     default:</span>
<a href="#l18.999"></a><span id="l18.999">         assert(false);</span>
<a href="#l18.1000"></a><span id="l18.1000">         break;</span>
<a href="#l18.1001"></a><span id="l18.1001">     }</span>
<a href="#l18.1002"></a><span id="l18.1002">     return true;</span>
<a href="#l18.1003"></a><span id="l18.1003"> }</span>
<a href="#l18.1004"></a><span id="l18.1004" class="difflineat">@@ -6647,34 +6643,34 @@ key_iter_first_key(rnp_identifier_iterat</span>
<a href="#l18.1005"></a><span id="l18.1005">     if (rnp_key_store_get_key_count(it-&gt;ffi-&gt;pubring)) {</span>
<a href="#l18.1006"></a><span id="l18.1006">         it-&gt;store = it-&gt;ffi-&gt;pubring;</span>
<a href="#l18.1007"></a><span id="l18.1007">     } else if (rnp_key_store_get_key_count(it-&gt;ffi-&gt;secring)) {</span>
<a href="#l18.1008"></a><span id="l18.1008">         it-&gt;store = it-&gt;ffi-&gt;secring;</span>
<a href="#l18.1009"></a><span id="l18.1009">     } else {</span>
<a href="#l18.1010"></a><span id="l18.1010">         it-&gt;store = NULL;</span>
<a href="#l18.1011"></a><span id="l18.1011">         return false;</span>
<a href="#l18.1012"></a><span id="l18.1012">     }</span>
<a href="#l18.1013"></a><span id="l18.1013" class="difflineminus">-    it-&gt;keyp = (pgp_key_t *) list_front(rnp_key_store_get_keys(it-&gt;store));</span>
<a href="#l18.1014"></a><span id="l18.1014" class="difflineplus">+    it-&gt;keyp = it-&gt;store-&gt;keys.begin();</span>
<a href="#l18.1015"></a><span id="l18.1015">     it-&gt;uididx = 0;</span>
<a href="#l18.1016"></a><span id="l18.1016">     return true;</span>
<a href="#l18.1017"></a><span id="l18.1017"> }</span>
<a href="#l18.1018"></a><span id="l18.1018"> </span>
<a href="#l18.1019"></a><span id="l18.1019"> static bool</span>
<a href="#l18.1020"></a><span id="l18.1020"> key_iter_first_item(rnp_identifier_iterator_t it)</span>
<a href="#l18.1021"></a><span id="l18.1021"> {</span>
<a href="#l18.1022"></a><span id="l18.1022">     switch (it-&gt;type) {</span>
<a href="#l18.1023"></a><span id="l18.1023">     case PGP_KEY_SEARCH_KEYID:</span>
<a href="#l18.1024"></a><span id="l18.1024">     case PGP_KEY_SEARCH_FINGERPRINT:</span>
<a href="#l18.1025"></a><span id="l18.1025">     case PGP_KEY_SEARCH_GRIP:</span>
<a href="#l18.1026"></a><span id="l18.1026">         return key_iter_first_key(it);</span>
<a href="#l18.1027"></a><span id="l18.1027">     case PGP_KEY_SEARCH_USERID:</span>
<a href="#l18.1028"></a><span id="l18.1028">         if (!key_iter_first_key(it)) {</span>
<a href="#l18.1029"></a><span id="l18.1029">             return false;</span>
<a href="#l18.1030"></a><span id="l18.1030">         }</span>
<a href="#l18.1031"></a><span id="l18.1031" class="difflineminus">-        while (it-&gt;uididx &gt;= pgp_key_get_userid_count(it-&gt;keyp)) {</span>
<a href="#l18.1032"></a><span id="l18.1032" class="difflineplus">+        while (it-&gt;uididx &gt;= pgp_key_get_userid_count(&amp;*it-&gt;keyp)) {</span>
<a href="#l18.1033"></a><span id="l18.1033">             if (!key_iter_next_key(it)) {</span>
<a href="#l18.1034"></a><span id="l18.1034">                 it-&gt;store = NULL;</span>
<a href="#l18.1035"></a><span id="l18.1035">                 return false;</span>
<a href="#l18.1036"></a><span id="l18.1036">             }</span>
<a href="#l18.1037"></a><span id="l18.1037">             it-&gt;uididx = 0;</span>
<a href="#l18.1038"></a><span id="l18.1038">         }</span>
<a href="#l18.1039"></a><span id="l18.1039">         break;</span>
<a href="#l18.1040"></a><span id="l18.1040">     default:</span>
<a href="#l18.1041"></a><span id="l18.1041" class="difflineat">@@ -6682,17 +6678,17 @@ key_iter_first_item(rnp_identifier_itera</span>
<a href="#l18.1042"></a><span id="l18.1042">         break;</span>
<a href="#l18.1043"></a><span id="l18.1043">     }</span>
<a href="#l18.1044"></a><span id="l18.1044">     return true;</span>
<a href="#l18.1045"></a><span id="l18.1045"> }</span>
<a href="#l18.1046"></a><span id="l18.1046"> </span>
<a href="#l18.1047"></a><span id="l18.1047"> static bool</span>
<a href="#l18.1048"></a><span id="l18.1048"> key_iter_get_item(const rnp_identifier_iterator_t it, char *buf, size_t buf_len)</span>
<a href="#l18.1049"></a><span id="l18.1049"> {</span>
<a href="#l18.1050"></a><span id="l18.1050" class="difflineminus">-    const pgp_key_t *key = it-&gt;keyp;</span>
<a href="#l18.1051"></a><span id="l18.1051" class="difflineplus">+    const pgp_key_t *key = &amp;*it-&gt;keyp;</span>
<a href="#l18.1052"></a><span id="l18.1052">     switch (it-&gt;type) {</span>
<a href="#l18.1053"></a><span id="l18.1053">     case PGP_KEY_SEARCH_KEYID:</span>
<a href="#l18.1054"></a><span id="l18.1054">         if (!rnp_hex_encode(</span>
<a href="#l18.1055"></a><span id="l18.1055">               pgp_key_get_keyid(key), PGP_KEY_ID_SIZE, buf, buf_len, RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.1056"></a><span id="l18.1056">             return false;</span>
<a href="#l18.1057"></a><span id="l18.1057">         }</span>
<a href="#l18.1058"></a><span id="l18.1058">         break;</span>
<a href="#l18.1059"></a><span id="l18.1059">     case PGP_KEY_SEARCH_FINGERPRINT:</span>
<a href="#l18.1060"></a><span id="l18.1060" class="difflineat">@@ -6700,30 +6696,33 @@ key_iter_get_item(const rnp_identifier_i</span>
<a href="#l18.1061"></a><span id="l18.1061">                             pgp_key_get_fp(key)-&gt;length,</span>
<a href="#l18.1062"></a><span id="l18.1062">                             buf,</span>
<a href="#l18.1063"></a><span id="l18.1063">                             buf_len,</span>
<a href="#l18.1064"></a><span id="l18.1064">                             RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.1065"></a><span id="l18.1065">             return false;</span>
<a href="#l18.1066"></a><span id="l18.1066">         }</span>
<a href="#l18.1067"></a><span id="l18.1067">         break;</span>
<a href="#l18.1068"></a><span id="l18.1068">     case PGP_KEY_SEARCH_GRIP:</span>
<a href="#l18.1069"></a><span id="l18.1069" class="difflineminus">-        if (!rnp_hex_encode(</span>
<a href="#l18.1070"></a><span id="l18.1070" class="difflineminus">-              pgp_key_get_grip(key), PGP_KEY_GRIP_SIZE, buf, buf_len, RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.1071"></a><span id="l18.1071" class="difflineplus">+        if (!rnp_hex_encode(pgp_key_get_grip(key).data(),</span>
<a href="#l18.1072"></a><span id="l18.1072" class="difflineplus">+                            pgp_key_get_grip(key).size(),</span>
<a href="#l18.1073"></a><span id="l18.1073" class="difflineplus">+                            buf,</span>
<a href="#l18.1074"></a><span id="l18.1074" class="difflineplus">+                            buf_len,</span>
<a href="#l18.1075"></a><span id="l18.1075" class="difflineplus">+                            RNP_HEX_UPPERCASE)) {</span>
<a href="#l18.1076"></a><span id="l18.1076">             return false;</span>
<a href="#l18.1077"></a><span id="l18.1077">         }</span>
<a href="#l18.1078"></a><span id="l18.1078">         break;</span>
<a href="#l18.1079"></a><span id="l18.1079">     case PGP_KEY_SEARCH_USERID: {</span>
<a href="#l18.1080"></a><span id="l18.1080">         const pgp_userid_t *uid = pgp_key_get_userid(key, it-&gt;uididx);</span>
<a href="#l18.1081"></a><span id="l18.1081">         if (!uid) {</span>
<a href="#l18.1082"></a><span id="l18.1082">             return false;</span>
<a href="#l18.1083"></a><span id="l18.1083">         }</span>
<a href="#l18.1084"></a><span id="l18.1084" class="difflineminus">-        if (strlen(uid-&gt;str) &gt;= buf_len) {</span>
<a href="#l18.1085"></a><span id="l18.1085" class="difflineplus">+        if (uid-&gt;str.size() &gt;= buf_len) {</span>
<a href="#l18.1086"></a><span id="l18.1086">             return false;</span>
<a href="#l18.1087"></a><span id="l18.1087">         }</span>
<a href="#l18.1088"></a><span id="l18.1088" class="difflineminus">-        strcpy(buf, uid-&gt;str);</span>
<a href="#l18.1089"></a><span id="l18.1089" class="difflineplus">+        strcpy(buf, uid-&gt;str.c_str());</span>
<a href="#l18.1090"></a><span id="l18.1090">     } break;</span>
<a href="#l18.1091"></a><span id="l18.1091">     default:</span>
<a href="#l18.1092"></a><span id="l18.1092">         assert(false);</span>
<a href="#l18.1093"></a><span id="l18.1093">         break;</span>
<a href="#l18.1094"></a><span id="l18.1094">     }</span>
<a href="#l18.1095"></a><span id="l18.1095">     return true;</span>
<a href="#l18.1096"></a><span id="l18.1096"> }</span>
<a href="#l18.1097"></a><span id="l18.1097"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/third_party/rnp/src/lib/types.h</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/third_party/rnp/src/lib/types.h</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -47,16 +47,20 @@</span>
<a href="#l19.4"></a><span id="l19.4">  *</span>
<a href="#l19.5"></a><span id="l19.5">  * See the License for the specific language governing permissions and</span>
<a href="#l19.6"></a><span id="l19.6">  * limitations under the License.</span>
<a href="#l19.7"></a><span id="l19.7">  */</span>
<a href="#l19.8"></a><span id="l19.8"> #ifndef TYPES_H_</span>
<a href="#l19.9"></a><span id="l19.9"> #define TYPES_H_</span>
<a href="#l19.10"></a><span id="l19.10"> </span>
<a href="#l19.11"></a><span id="l19.11"> #include &lt;stdint.h&gt;</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineplus">+#include &lt;string&gt;</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+#include &lt;vector&gt;</span>
<a href="#l19.14"></a><span id="l19.14" class="difflineplus">+#include &lt;array&gt;</span>
<a href="#l19.15"></a><span id="l19.15" class="difflineplus">+</span>
<a href="#l19.16"></a><span id="l19.16"> #include &lt;rnp/rnp_def.h&gt;</span>
<a href="#l19.17"></a><span id="l19.17"> #include &quot;list.h&quot;</span>
<a href="#l19.18"></a><span id="l19.18"> #include &quot;crypto/common.h&quot;</span>
<a href="#l19.19"></a><span id="l19.19"> </span>
<a href="#l19.20"></a><span id="l19.20"> /* SHA1 Hash Size */</span>
<a href="#l19.21"></a><span id="l19.21"> #define PGP_SHA1_HASH_SIZE 20</span>
<a href="#l19.22"></a><span id="l19.22"> </span>
<a href="#l19.23"></a><span id="l19.23"> /* Maximum length of the packet header */</span>
<a href="#l19.24"></a><span id="l19.24" class="difflineat">@@ -83,16 +87,18 @@ typedef struct pgp_hash_t pgp_hash_t;</span>
<a href="#l19.25"></a><span id="l19.25"> typedef uint8_t pgp_ss_rr_code_t;</span>
<a href="#l19.26"></a><span id="l19.26"> </span>
<a href="#l19.27"></a><span id="l19.27"> /** pgp_fingerprint_t */</span>
<a href="#l19.28"></a><span id="l19.28"> typedef struct pgp_fingerprint_t {</span>
<a href="#l19.29"></a><span id="l19.29">     uint8_t  fingerprint[PGP_FINGERPRINT_SIZE];</span>
<a href="#l19.30"></a><span id="l19.30">     unsigned length;</span>
<a href="#l19.31"></a><span id="l19.31"> } pgp_fingerprint_t;</span>
<a href="#l19.32"></a><span id="l19.32"> </span>
<a href="#l19.33"></a><span id="l19.33" class="difflineplus">+typedef std::array&lt;uint8_t, PGP_KEY_GRIP_SIZE&gt; pgp_key_grip_t;</span>
<a href="#l19.34"></a><span id="l19.34" class="difflineplus">+</span>
<a href="#l19.35"></a><span id="l19.35"> /**</span>
<a href="#l19.36"></a><span id="l19.36">  * Type to keep public/secret key mpis without any openpgp-dependent data.</span>
<a href="#l19.37"></a><span id="l19.37">  */</span>
<a href="#l19.38"></a><span id="l19.38"> typedef struct pgp_key_material_t {</span>
<a href="#l19.39"></a><span id="l19.39">     pgp_pubkey_alg_t alg;    /* algorithm of the key */</span>
<a href="#l19.40"></a><span id="l19.40">     bool             secret; /* secret part of the key material is populated */</span>
<a href="#l19.41"></a><span id="l19.41"> </span>
<a href="#l19.42"></a><span id="l19.42">     union {</span>
<a href="#l19.43"></a><span id="l19.43" class="difflineat">@@ -274,19 +280,27 @@ typedef struct pgp_sig_subpkt_t {</span>
<a href="#l19.44"></a><span id="l19.44">             uint8_t *fp;</span>
<a href="#l19.45"></a><span id="l19.45">             unsigned len;</span>
<a href="#l19.46"></a><span id="l19.46">         } issuer_fp; /* 5.2.3.28.  Issuer Fingerprint, RFC 4880 bis 04 */</span>
<a href="#l19.47"></a><span id="l19.47">     } fields;        /* parsed contents of the subpacket */</span>
<a href="#l19.48"></a><span id="l19.48"> } pgp_sig_subpkt_t;</span>
<a href="#l19.49"></a><span id="l19.49"> </span>
<a href="#l19.50"></a><span id="l19.50"> /** pgp_rawpacket_t */</span>
<a href="#l19.51"></a><span id="l19.51"> typedef struct pgp_rawpacket_t {</span>
<a href="#l19.52"></a><span id="l19.52" class="difflineminus">-    pgp_pkt_type_t tag;</span>
<a href="#l19.53"></a><span id="l19.53" class="difflineminus">-    size_t         length;</span>
<a href="#l19.54"></a><span id="l19.54" class="difflineminus">-    uint8_t *      raw;</span>
<a href="#l19.55"></a><span id="l19.55" class="difflineplus">+    pgp_pkt_type_t       tag;</span>
<a href="#l19.56"></a><span id="l19.56" class="difflineplus">+    std::vector&lt;uint8_t&gt; raw;</span>
<a href="#l19.57"></a><span id="l19.57" class="difflineplus">+</span>
<a href="#l19.58"></a><span id="l19.58" class="difflineplus">+    pgp_rawpacket_t() = default;</span>
<a href="#l19.59"></a><span id="l19.59" class="difflineplus">+    pgp_rawpacket_t(const uint8_t *data, size_t len, pgp_pkt_type_t tag)</span>
<a href="#l19.60"></a><span id="l19.60" class="difflineplus">+        : tag(tag),</span>
<a href="#l19.61"></a><span id="l19.61" class="difflineplus">+          raw(data ? std::vector&lt;uint8_t&gt;(data, data + len) : std::vector&lt;uint8_t&gt;()){};</span>
<a href="#l19.62"></a><span id="l19.62" class="difflineplus">+    pgp_rawpacket_t(const pgp_signature_t &amp;sig);</span>
<a href="#l19.63"></a><span id="l19.63" class="difflineplus">+    pgp_rawpacket_t(pgp_key_pkt_t &amp;key);</span>
<a href="#l19.64"></a><span id="l19.64" class="difflineplus">+    pgp_rawpacket_t(const pgp_userid_pkt_t &amp;uid);</span>
<a href="#l19.65"></a><span id="l19.65" class="difflineplus">+    ~pgp_rawpacket_t();</span>
<a href="#l19.66"></a><span id="l19.66"> } pgp_rawpacket_t;</span>
<a href="#l19.67"></a><span id="l19.67"> </span>
<a href="#l19.68"></a><span id="l19.68"> typedef enum {</span>
<a href="#l19.69"></a><span id="l19.69">     /* first octet */</span>
<a href="#l19.70"></a><span id="l19.70">     PGP_KEY_SERVER_NO_MODIFY = 0x80</span>
<a href="#l19.71"></a><span id="l19.71"> } pgp_key_server_prefs_t;</span>
<a href="#l19.72"></a><span id="l19.72"> </span>
<a href="#l19.73"></a><span id="l19.73"> /** pgp_one_pass_sig_t */</span>
<a href="#l19.74"></a><span id="l19.74" class="difflineat">@@ -345,17 +359,17 @@ typedef struct {</span>
<a href="#l19.75"></a><span id="l19.75">     uint8_t        iv[PGP_MAX_BLOCK_SIZE];</span>
<a href="#l19.76"></a><span id="l19.76">     unsigned       ivlen;</span>
<a href="#l19.77"></a><span id="l19.77"> } pgp_sk_sesskey_t;</span>
<a href="#l19.78"></a><span id="l19.78"> </span>
<a href="#l19.79"></a><span id="l19.79"> /* user revocation info */</span>
<a href="#l19.80"></a><span id="l19.80"> typedef struct pgp_revoke_t {</span>
<a href="#l19.81"></a><span id="l19.81">     uint32_t              uid;    /* index in uid array */</span>
<a href="#l19.82"></a><span id="l19.82">     pgp_revocation_type_t code;   /* revocation code */</span>
<a href="#l19.83"></a><span id="l19.83" class="difflineminus">-    char *                reason; /* c'mon, spill the beans */</span>
<a href="#l19.84"></a><span id="l19.84" class="difflineplus">+    std::string           reason; /* revocation reason */</span>
<a href="#l19.85"></a><span id="l19.85"> } pgp_revoke_t;</span>
<a href="#l19.86"></a><span id="l19.86"> </span>
<a href="#l19.87"></a><span id="l19.87"> typedef struct pgp_user_prefs_t {</span>
<a href="#l19.88"></a><span id="l19.88">     // preferred symmetric algs (pgp_symm_alg_t)</span>
<a href="#l19.89"></a><span id="l19.89">     uint8_t *symm_algs;</span>
<a href="#l19.90"></a><span id="l19.90">     size_t   symm_alg_count;</span>
<a href="#l19.91"></a><span id="l19.91">     // preferred hash algs (pgp_hash_alg_t)</span>
<a href="#l19.92"></a><span id="l19.92">     uint8_t *hash_algs;</span>
<a href="#l19.93"></a><span id="l19.93" class="difflineat">@@ -369,27 +383,47 @@ typedef struct pgp_user_prefs_t {</span>
<a href="#l19.94"></a><span id="l19.94">     // preferred key server</span>
<a href="#l19.95"></a><span id="l19.95">     uint8_t *key_server;</span>
<a href="#l19.96"></a><span id="l19.96"> } pgp_user_prefs_t;</span>
<a href="#l19.97"></a><span id="l19.97"> </span>
<a href="#l19.98"></a><span id="l19.98"> /** information about the signature */</span>
<a href="#l19.99"></a><span id="l19.99"> typedef struct pgp_subsig_t {</span>
<a href="#l19.100"></a><span id="l19.100">     uint32_t         uid;         /* index in userid array in key for certification sig */</span>
<a href="#l19.101"></a><span id="l19.101">     pgp_signature_t  sig;         /* signature packet */</span>
<a href="#l19.102"></a><span id="l19.102" class="difflineplus">+    pgp_rawpacket_t  rawpkt;      /* signature's rawpacket */</span>
<a href="#l19.103"></a><span id="l19.103">     uint8_t          trustlevel;  /* level of trust */</span>
<a href="#l19.104"></a><span id="l19.104">     uint8_t          trustamount; /* amount of trust */</span>
<a href="#l19.105"></a><span id="l19.105">     uint8_t          key_flags;   /* key flags for certification/direct key sig */</span>
<a href="#l19.106"></a><span id="l19.106">     pgp_user_prefs_t prefs;       /* user preferences for certification sig */</span>
<a href="#l19.107"></a><span id="l19.107">     bool             validated;   /* signature was validated */</span>
<a href="#l19.108"></a><span id="l19.108">     bool             valid;       /* signature was validated and is valid */</span>
<a href="#l19.109"></a><span id="l19.109" class="difflineplus">+</span>
<a href="#l19.110"></a><span id="l19.110" class="difflineplus">+    pgp_subsig_t() = default;</span>
<a href="#l19.111"></a><span id="l19.111" class="difflineplus">+    pgp_subsig_t(pgp_subsig_t &amp;&amp;src);</span>
<a href="#l19.112"></a><span id="l19.112" class="difflineplus">+    pgp_subsig_t &amp;operator=(pgp_subsig_t &amp;&amp;src);</span>
<a href="#l19.113"></a><span id="l19.113" class="difflineplus">+    pgp_subsig_t &amp;operator=(const pgp_subsig_t &amp;src);</span>
<a href="#l19.114"></a><span id="l19.114" class="difflineplus">+    ~pgp_subsig_t();</span>
<a href="#l19.115"></a><span id="l19.115" class="difflineplus">+</span>
<a href="#l19.116"></a><span id="l19.116" class="difflineplus">+    /* make sure we use only explicitly defined constructors/operators */</span>
<a href="#l19.117"></a><span id="l19.117" class="difflineplus">+    pgp_subsig_t(const pgp_subsig_t &amp;) = delete;</span>
<a href="#l19.118"></a><span id="l19.118"> } pgp_subsig_t;</span>
<a href="#l19.119"></a><span id="l19.119"> </span>
<a href="#l19.120"></a><span id="l19.120"> typedef struct pgp_userid_t {</span>
<a href="#l19.121"></a><span id="l19.121" class="difflineminus">-    pgp_userid_pkt_t pkt; /* User ID or User Attribute packet as it was loaded */</span>
<a href="#l19.122"></a><span id="l19.122" class="difflineminus">-    char *           str; /* Human-readable representation of the userid */</span>
<a href="#l19.123"></a><span id="l19.123" class="difflineplus">+    pgp_userid_pkt_t pkt;    /* User ID or User Attribute packet as it was loaded */</span>
<a href="#l19.124"></a><span id="l19.124" class="difflineplus">+    pgp_rawpacket_t  rawpkt; /* Raw packet contents */</span>
<a href="#l19.125"></a><span id="l19.125" class="difflineplus">+    std::string      str;    /* Human-readable representation of the userid */</span>
<a href="#l19.126"></a><span id="l19.126" class="difflineplus">+</span>
<a href="#l19.127"></a><span id="l19.127" class="difflineplus">+    pgp_userid_t() = default;</span>
<a href="#l19.128"></a><span id="l19.128" class="difflineplus">+    pgp_userid_t(pgp_userid_t &amp;&amp;src);</span>
<a href="#l19.129"></a><span id="l19.129" class="difflineplus">+    pgp_userid_t &amp;operator=(const pgp_userid_t &amp;src);</span>
<a href="#l19.130"></a><span id="l19.130" class="difflineplus">+    ~pgp_userid_t();</span>
<a href="#l19.131"></a><span id="l19.131" class="difflineplus">+</span>
<a href="#l19.132"></a><span id="l19.132" class="difflineplus">+    /* make sure we use only explicitly defined constructors/operators */</span>
<a href="#l19.133"></a><span id="l19.133" class="difflineplus">+    pgp_userid_t(const pgp_userid_t &amp;) = delete;</span>
<a href="#l19.134"></a><span id="l19.134" class="difflineplus">+    pgp_userid_t &amp;operator=(pgp_userid_t &amp;&amp;) = delete;</span>
<a href="#l19.135"></a><span id="l19.135"> } pgp_userid_t;</span>
<a href="#l19.136"></a><span id="l19.136"> </span>
<a href="#l19.137"></a><span id="l19.137"> struct rnp_keygen_ecc_params_t {</span>
<a href="#l19.138"></a><span id="l19.138">     pgp_curve_t curve;</span>
<a href="#l19.139"></a><span id="l19.139"> };</span>
<a href="#l19.140"></a><span id="l19.140"> </span>
<a href="#l19.141"></a><span id="l19.141"> struct rnp_keygen_rsa_params_t {</span>
<a href="#l19.142"></a><span id="l19.142">     uint32_t modulus_bit_len;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/third_party/rnp/src/lib/utils.h</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/third_party/rnp/src/lib/utils.h</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -26,18 +26,24 @@</span>
<a href="#l20.4"></a><span id="l20.4"> #ifndef RNP_UTILS_H_</span>
<a href="#l20.5"></a><span id="l20.5"> #define RNP_UTILS_H_</span>
<a href="#l20.6"></a><span id="l20.6"> </span>
<a href="#l20.7"></a><span id="l20.7"> #include &lt;stdio.h&gt;</span>
<a href="#l20.8"></a><span id="l20.8"> #include &quot;types.h&quot;</span>
<a href="#l20.9"></a><span id="l20.9"> #include &lt;limits.h&gt;</span>
<a href="#l20.10"></a><span id="l20.10"> </span>
<a href="#l20.11"></a><span id="l20.11"> #define RNP_MSG(msg) (void) fprintf(stdout, msg);</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineplus">+</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+bool rnp_log_switch();</span>
<a href="#l20.14"></a><span id="l20.14" class="difflineplus">+void set_rnp_log_switch(int8_t);</span>
<a href="#l20.15"></a><span id="l20.15" class="difflineplus">+</span>
<a href="#l20.16"></a><span id="l20.16"> #define RNP_LOG_FD(fd, ...)                                                  \</span>
<a href="#l20.17"></a><span id="l20.17">     do {                                                                     \</span>
<a href="#l20.18"></a><span id="l20.18" class="difflineplus">+        if (!rnp_log_switch())                                               \</span>
<a href="#l20.19"></a><span id="l20.19" class="difflineplus">+            break;                                                           \</span>
<a href="#l20.20"></a><span id="l20.20">         (void) fprintf((fd), &quot;[%s() %s:%d] &quot;, __func__, __FILE__, __LINE__); \</span>
<a href="#l20.21"></a><span id="l20.21">         (void) fprintf((fd), __VA_ARGS__);                                   \</span>
<a href="#l20.22"></a><span id="l20.22">         (void) fprintf((fd), &quot;\n&quot;);                                          \</span>
<a href="#l20.23"></a><span id="l20.23">     } while (0)</span>
<a href="#l20.24"></a><span id="l20.24"> </span>
<a href="#l20.25"></a><span id="l20.25"> #define RNP_LOG(...) RNP_LOG_FD(stderr, __VA_ARGS__)</span>
<a href="#l20.26"></a><span id="l20.26"> </span>
<a href="#l20.27"></a><span id="l20.27"> #define RNP_DLOG(...)                    \</span>
<a href="#l20.28"></a><span id="l20.28" class="difflineat">@@ -128,16 +134,19 @@ void hexdump(FILE *, const char *, const</span>
<a href="#l20.29"></a><span id="l20.29"> </span>
<a href="#l20.30"></a><span id="l20.30"> const char *pgp_str_from_map(int, pgp_map_t *);</span>
<a href="#l20.31"></a><span id="l20.31"> </span>
<a href="#l20.32"></a><span id="l20.32"> /* debugging, reflection and information */</span>
<a href="#l20.33"></a><span id="l20.33"> bool rnp_set_debug(const char *);</span>
<a href="#l20.34"></a><span id="l20.34"> bool rnp_get_debug(const char *);</span>
<a href="#l20.35"></a><span id="l20.35"> void rnp_clear_debug();</span>
<a href="#l20.36"></a><span id="l20.36"> </span>
<a href="#l20.37"></a><span id="l20.37" class="difflineplus">+/* environment variable name */</span>
<a href="#l20.38"></a><span id="l20.38" class="difflineplus">+static const char RNP_LOG_CONSOLE[] = &quot;RNP_LOG_CONSOLE&quot;;</span>
<a href="#l20.39"></a><span id="l20.39" class="difflineplus">+</span>
<a href="#l20.40"></a><span id="l20.40"> /* Portable way to convert bits to bytes */</span>
<a href="#l20.41"></a><span id="l20.41"> </span>
<a href="#l20.42"></a><span id="l20.42"> #define BITS_TO_BYTES(b) (((b) + (CHAR_BIT - 1)) / CHAR_BIT)</span>
<a href="#l20.43"></a><span id="l20.43"> </span>
<a href="#l20.44"></a><span id="l20.44"> /* Load little-endian 32-bit from y to x in portable fashion */</span>
<a href="#l20.45"></a><span id="l20.45"> </span>
<a href="#l20.46"></a><span id="l20.46"> inline void</span>
<a href="#l20.47"></a><span id="l20.47"> LOAD32LE(uint32_t &amp;x, uint8_t y[4])</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/third_party/rnp/src/lib/version.h</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/third_party/rnp/src/lib/version.h</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -23,19 +23,19 @@</span>
<a href="#l21.4"></a><span id="l21.4">  * POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l21.5"></a><span id="l21.5">  */</span>
<a href="#l21.6"></a><span id="l21.6"> </span>
<a href="#l21.7"></a><span id="l21.7"> #define RNP_VERSION_MAJOR 0</span>
<a href="#l21.8"></a><span id="l21.8"> #define RNP_VERSION_MINOR 13</span>
<a href="#l21.9"></a><span id="l21.9"> #define RNP_VERSION_PATCH 1</span>
<a href="#l21.10"></a><span id="l21.10"> </span>
<a href="#l21.11"></a><span id="l21.11"> #define RNP_VERSION_STRING &quot;0.13.1&quot;</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-#define RNP_VERSION_STRING_FULL &quot;0.13.1+git20200506.eabaa5d0.MZLA&quot;</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+#define RNP_VERSION_STRING_FULL &quot;0.13.1+git20200530.6e74b752.MZLA&quot;</span>
<a href="#l21.14"></a><span id="l21.14"> </span>
<a href="#l21.15"></a><span id="l21.15" class="difflineminus">-#define RNP_VERSION_COMMIT_TIMESTAMP 1588776848</span>
<a href="#l21.16"></a><span id="l21.16" class="difflineplus">+#define RNP_VERSION_COMMIT_TIMESTAMP 1590833119</span>
<a href="#l21.17"></a><span id="l21.17"> </span>
<a href="#l21.18"></a><span id="l21.18"> // using a 32-bit version with 10 bits per component</span>
<a href="#l21.19"></a><span id="l21.19"> #define RNP_VERSION_COMPONENT_MASK 0x3ff</span>
<a href="#l21.20"></a><span id="l21.20"> #define RNP_VERSION_MAJOR_SHIFT 20</span>
<a href="#l21.21"></a><span id="l21.21"> #define RNP_VERSION_MINOR_SHIFT 10</span>
<a href="#l21.22"></a><span id="l21.22"> #define RNP_VERSION_PATCH_SHIFT 0</span>
<a href="#l21.23"></a><span id="l21.23"> #define RNP_VERSION_CODE_FOR(major, minor, patch)                        \</span>
<a href="#l21.24"></a><span id="l21.24">     (((major &amp; RNP_VERSION_COMPONENT_MASK) &lt;&lt; RNP_VERSION_MAJOR_SHIFT) | \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/third_party/rnp/src/librekey/key_store_g10.cpp</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/key_store_g10.cpp</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -569,23 +569,26 @@ parse_pubkey(pgp_key_pkt_t *pubkey, s_ex</span>
<a href="#l22.4"></a><span id="l22.4">             !read_mpi(s_exp, &quot;q&quot;, &amp;pubkey-&gt;material.dsa.q) ||</span>
<a href="#l22.5"></a><span id="l22.5">             !read_mpi(s_exp, &quot;g&quot;, &amp;pubkey-&gt;material.dsa.g) ||</span>
<a href="#l22.6"></a><span id="l22.6">             !read_mpi(s_exp, &quot;y&quot;, &amp;pubkey-&gt;material.dsa.y)) {</span>
<a href="#l22.7"></a><span id="l22.7">             return false;</span>
<a href="#l22.8"></a><span id="l22.8">         }</span>
<a href="#l22.9"></a><span id="l22.9">         break;</span>
<a href="#l22.10"></a><span id="l22.10"> </span>
<a href="#l22.11"></a><span id="l22.11">     case PGP_PKA_RSA:</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l22.14"></a><span id="l22.14">         if (!read_mpi(s_exp, &quot;n&quot;, &amp;pubkey-&gt;material.rsa.n) ||</span>
<a href="#l22.15"></a><span id="l22.15">             !read_mpi(s_exp, &quot;e&quot;, &amp;pubkey-&gt;material.rsa.e)) {</span>
<a href="#l22.16"></a><span id="l22.16">             return false;</span>
<a href="#l22.17"></a><span id="l22.17">         }</span>
<a href="#l22.18"></a><span id="l22.18">         break;</span>
<a href="#l22.19"></a><span id="l22.19"> </span>
<a href="#l22.20"></a><span id="l22.20">     case PGP_PKA_ELGAMAL:</span>
<a href="#l22.21"></a><span id="l22.21" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l22.22"></a><span id="l22.22">         if (!read_mpi(s_exp, &quot;p&quot;, &amp;pubkey-&gt;material.eg.p) ||</span>
<a href="#l22.23"></a><span id="l22.23">             !read_mpi(s_exp, &quot;g&quot;, &amp;pubkey-&gt;material.eg.g) ||</span>
<a href="#l22.24"></a><span id="l22.24">             !read_mpi(s_exp, &quot;y&quot;, &amp;pubkey-&gt;material.eg.y)) {</span>
<a href="#l22.25"></a><span id="l22.25">             return false;</span>
<a href="#l22.26"></a><span id="l22.26">         }</span>
<a href="#l22.27"></a><span id="l22.27">         break;</span>
<a href="#l22.28"></a><span id="l22.28">     case PGP_PKA_ECDSA:</span>
<a href="#l22.29"></a><span id="l22.29">     case PGP_PKA_ECDH:</span>
<a href="#l22.30"></a><span id="l22.30" class="difflineat">@@ -614,25 +617,28 @@ parse_seckey(pgp_key_pkt_t *seckey, s_ex</span>
<a href="#l22.31"></a><span id="l22.31">     switch (alg) {</span>
<a href="#l22.32"></a><span id="l22.32">     case PGP_PKA_DSA:</span>
<a href="#l22.33"></a><span id="l22.33">         if (!read_mpi(s_exp, &quot;x&quot;, &amp;seckey-&gt;material.dsa.x)) {</span>
<a href="#l22.34"></a><span id="l22.34">             return false;</span>
<a href="#l22.35"></a><span id="l22.35">         }</span>
<a href="#l22.36"></a><span id="l22.36">         break;</span>
<a href="#l22.37"></a><span id="l22.37"> </span>
<a href="#l22.38"></a><span id="l22.38">     case PGP_PKA_RSA:</span>
<a href="#l22.39"></a><span id="l22.39" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l22.40"></a><span id="l22.40" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l22.41"></a><span id="l22.41">         if (!read_mpi(s_exp, &quot;d&quot;, &amp;seckey-&gt;material.rsa.d) ||</span>
<a href="#l22.42"></a><span id="l22.42">             !read_mpi(s_exp, &quot;p&quot;, &amp;seckey-&gt;material.rsa.p) ||</span>
<a href="#l22.43"></a><span id="l22.43">             !read_mpi(s_exp, &quot;q&quot;, &amp;seckey-&gt;material.rsa.q) ||</span>
<a href="#l22.44"></a><span id="l22.44">             !read_mpi(s_exp, &quot;u&quot;, &amp;seckey-&gt;material.rsa.u)) {</span>
<a href="#l22.45"></a><span id="l22.45">             return false;</span>
<a href="#l22.46"></a><span id="l22.46">         }</span>
<a href="#l22.47"></a><span id="l22.47">         break;</span>
<a href="#l22.48"></a><span id="l22.48"> </span>
<a href="#l22.49"></a><span id="l22.49">     case PGP_PKA_ELGAMAL:</span>
<a href="#l22.50"></a><span id="l22.50" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l22.51"></a><span id="l22.51">         if (!read_mpi(s_exp, &quot;x&quot;, &amp;seckey-&gt;material.eg.x)) {</span>
<a href="#l22.52"></a><span id="l22.52">             return false;</span>
<a href="#l22.53"></a><span id="l22.53">         }</span>
<a href="#l22.54"></a><span id="l22.54">         break;</span>
<a href="#l22.55"></a><span id="l22.55">     case PGP_PKA_ECDSA:</span>
<a href="#l22.56"></a><span id="l22.56">     case PGP_PKA_ECDH:</span>
<a href="#l22.57"></a><span id="l22.57">     case PGP_PKA_EDDSA:</span>
<a href="#l22.58"></a><span id="l22.58">         if (!read_mpi(s_exp, &quot;d&quot;, &amp;seckey-&gt;material.ec.x)) {</span>
<a href="#l22.59"></a><span id="l22.59" class="difflineat">@@ -1013,21 +1019,21 @@ g10_parse_seckey(pgp_key_pkt_t *seckey,</span>
<a href="#l22.60"></a><span id="l22.60">         seckey-&gt;sec_protection.s2k.hash_alg = PGP_HASH_UNKNOWN;</span>
<a href="#l22.61"></a><span id="l22.61">         if (!parse_seckey(seckey, algorithm_s_exp, alg)) {</span>
<a href="#l22.62"></a><span id="l22.62">             RNP_LOG(&quot;failed to parse seckey&quot;);</span>
<a href="#l22.63"></a><span id="l22.63">             goto done;</span>
<a href="#l22.64"></a><span id="l22.64">         }</span>
<a href="#l22.65"></a><span id="l22.65">     }</span>
<a href="#l22.66"></a><span id="l22.66"> </span>
<a href="#l22.67"></a><span id="l22.67">     if (rnp_get_debug(__FILE__)) {</span>
<a href="#l22.68"></a><span id="l22.68" class="difflineminus">-        uint8_t grip[PGP_KEY_GRIP_SIZE];</span>
<a href="#l22.69"></a><span id="l22.69" class="difflineminus">-        char    grips[PGP_KEY_GRIP_SIZE * 3];</span>
<a href="#l22.70"></a><span id="l22.70" class="difflineplus">+        pgp_key_grip_t grip;</span>
<a href="#l22.71"></a><span id="l22.71" class="difflineplus">+        char           grips[PGP_KEY_GRIP_SIZE * 3];</span>
<a href="#l22.72"></a><span id="l22.72">         if (rnp_key_store_get_key_grip(&amp;seckey-&gt;material, grip)) {</span>
<a href="#l22.73"></a><span id="l22.73">             RNP_LOG(&quot;loaded G10 key with GRIP: %s\n&quot;,</span>
<a href="#l22.74"></a><span id="l22.74" class="difflineminus">-                    rnp_strhexdump_upper(grips, grip, PGP_KEY_GRIP_SIZE, &quot;&quot;));</span>
<a href="#l22.75"></a><span id="l22.75" class="difflineplus">+                    rnp_strhexdump_upper(grips, grip.data(), grip.size(), &quot;&quot;));</span>
<a href="#l22.76"></a><span id="l22.76">         }</span>
<a href="#l22.77"></a><span id="l22.77">     }</span>
<a href="#l22.78"></a><span id="l22.78">     ret = true;</span>
<a href="#l22.79"></a><span id="l22.79"> </span>
<a href="#l22.80"></a><span id="l22.80"> done:</span>
<a href="#l22.81"></a><span id="l22.81">     destroy_s_exp(&amp;s_exp);</span>
<a href="#l22.82"></a><span id="l22.82">     if (!ret) {</span>
<a href="#l22.83"></a><span id="l22.83">         free_key_pkt(seckey);</span>
<a href="#l22.84"></a><span id="l22.84" class="difflineat">@@ -1068,22 +1074,25 @@ done:</span>
<a href="#l22.85"></a><span id="l22.85"> static bool</span>
<a href="#l22.86"></a><span id="l22.86"> copy_secret_fields(pgp_key_pkt_t *dst, const pgp_key_pkt_t *src)</span>
<a href="#l22.87"></a><span id="l22.87"> {</span>
<a href="#l22.88"></a><span id="l22.88">     switch (src-&gt;alg) {</span>
<a href="#l22.89"></a><span id="l22.89">     case PGP_PKA_DSA:</span>
<a href="#l22.90"></a><span id="l22.90">         dst-&gt;material.dsa.x = src-&gt;material.dsa.x;</span>
<a href="#l22.91"></a><span id="l22.91">         break;</span>
<a href="#l22.92"></a><span id="l22.92">     case PGP_PKA_RSA:</span>
<a href="#l22.93"></a><span id="l22.93" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l22.94"></a><span id="l22.94" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l22.95"></a><span id="l22.95">         dst-&gt;material.rsa.d = src-&gt;material.rsa.d;</span>
<a href="#l22.96"></a><span id="l22.96">         dst-&gt;material.rsa.p = src-&gt;material.rsa.p;</span>
<a href="#l22.97"></a><span id="l22.97">         dst-&gt;material.rsa.q = src-&gt;material.rsa.q;</span>
<a href="#l22.98"></a><span id="l22.98">         dst-&gt;material.rsa.u = src-&gt;material.rsa.u;</span>
<a href="#l22.99"></a><span id="l22.99">         break;</span>
<a href="#l22.100"></a><span id="l22.100">     case PGP_PKA_ELGAMAL:</span>
<a href="#l22.101"></a><span id="l22.101" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l22.102"></a><span id="l22.102">         dst-&gt;material.eg.x = src-&gt;material.eg.x;</span>
<a href="#l22.103"></a><span id="l22.103">         break;</span>
<a href="#l22.104"></a><span id="l22.104">     case PGP_PKA_ECDSA:</span>
<a href="#l22.105"></a><span id="l22.105">     case PGP_PKA_ECDH:</span>
<a href="#l22.106"></a><span id="l22.106">     case PGP_PKA_EDDSA:</span>
<a href="#l22.107"></a><span id="l22.107">         dst-&gt;material.ec.x = src-&gt;material.ec.x;</span>
<a href="#l22.108"></a><span id="l22.108">         break;</span>
<a href="#l22.109"></a><span id="l22.109">     default:</span>
<a href="#l22.110"></a><span id="l22.110" class="difflineat">@@ -1149,19 +1158,21 @@ rnp_key_store_g10_from_src(rnp_key_store</span>
<a href="#l22.111"></a><span id="l22.111">         if (!copy_secret_fields(&amp;key.pkt, &amp;seckey)) {</span>
<a href="#l22.112"></a><span id="l22.112">             goto done;</span>
<a href="#l22.113"></a><span id="l22.113">         }</span>
<a href="#l22.114"></a><span id="l22.114">     } else {</span>
<a href="#l22.115"></a><span id="l22.115">         key.pkt = seckey;</span>
<a href="#l22.116"></a><span id="l22.116">         memset(&amp;seckey, 0, sizeof(seckey));</span>
<a href="#l22.117"></a><span id="l22.117">     }</span>
<a href="#l22.118"></a><span id="l22.118"> </span>
<a href="#l22.119"></a><span id="l22.119" class="difflineminus">-    if (!pgp_key_add_rawpacket(</span>
<a href="#l22.120"></a><span id="l22.120" class="difflineminus">-          &amp;key, (uint8_t *) mem_src_get_memory(&amp;memsrc), memsrc.size, PGP_PKT_RESERVED)) {</span>
<a href="#l22.121"></a><span id="l22.121" class="difflineminus">-        RNP_LOG(&quot;failed to add packet&quot;);</span>
<a href="#l22.122"></a><span id="l22.122" class="difflineplus">+    try {</span>
<a href="#l22.123"></a><span id="l22.123" class="difflineplus">+        key.rawpkt = pgp_rawpacket_t(</span>
<a href="#l22.124"></a><span id="l22.124" class="difflineplus">+          (uint8_t *) mem_src_get_memory(&amp;memsrc), memsrc.size, PGP_PKT_RESERVED);</span>
<a href="#l22.125"></a><span id="l22.125" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l22.126"></a><span id="l22.126" class="difflineplus">+        RNP_LOG(&quot;failed to add packet: %s&quot;, e.what());</span>
<a href="#l22.127"></a><span id="l22.127">         goto done;</span>
<a href="#l22.128"></a><span id="l22.128">     }</span>
<a href="#l22.129"></a><span id="l22.129">     key.format = PGP_KEY_STORE_G10;</span>
<a href="#l22.130"></a><span id="l22.130">     if (!rnp_key_store_add_key(key_store, &amp;key)) {</span>
<a href="#l22.131"></a><span id="l22.131">         goto done;</span>
<a href="#l22.132"></a><span id="l22.132">     }</span>
<a href="#l22.133"></a><span id="l22.133">     ret = true;</span>
<a href="#l22.134"></a><span id="l22.134"> done:</span>
<a href="#l22.135"></a><span id="l22.135" class="difflineat">@@ -1559,20 +1570,19 @@ error:</span>
<a href="#l22.136"></a><span id="l22.136">     dst_close(&amp;memdst, true);</span>
<a href="#l22.137"></a><span id="l22.137">     destroy_s_exp(&amp;s_exp);</span>
<a href="#l22.138"></a><span id="l22.138">     return false;</span>
<a href="#l22.139"></a><span id="l22.139"> }</span>
<a href="#l22.140"></a><span id="l22.140"> </span>
<a href="#l22.141"></a><span id="l22.141"> bool</span>
<a href="#l22.142"></a><span id="l22.142"> rnp_key_store_g10_key_to_dst(pgp_key_t *key, pgp_dest_t *dest)</span>
<a href="#l22.143"></a><span id="l22.143"> {</span>
<a href="#l22.144"></a><span id="l22.144" class="difflineminus">-    pgp_rawpacket_t *packet = NULL;</span>
<a href="#l22.145"></a><span id="l22.145">     if (!pgp_key_get_rawpacket_count(key)) {</span>
<a href="#l22.146"></a><span id="l22.146">         return false;</span>
<a href="#l22.147"></a><span id="l22.147">     }</span>
<a href="#l22.148"></a><span id="l22.148">     if (key-&gt;format != PGP_KEY_STORE_G10) {</span>
<a href="#l22.149"></a><span id="l22.149">         RNP_LOG(&quot;incorrect format: %d&quot;, key-&gt;format);</span>
<a href="#l22.150"></a><span id="l22.150">         return false;</span>
<a href="#l22.151"></a><span id="l22.151">     }</span>
<a href="#l22.152"></a><span id="l22.152" class="difflineminus">-    packet = pgp_key_get_rawpacket(key, 0);</span>
<a href="#l22.153"></a><span id="l22.153" class="difflineminus">-    dst_write(dest, packet-&gt;raw, packet-&gt;length);</span>
<a href="#l22.154"></a><span id="l22.154" class="difflineplus">+    pgp_rawpacket_t &amp;packet = pgp_key_get_rawpacket(key);</span>
<a href="#l22.155"></a><span id="l22.155" class="difflineplus">+    dst_write(dest, packet.raw.data(), packet.raw.size());</span>
<a href="#l22.156"></a><span id="l22.156">     return dest-&gt;werr == RNP_SUCCESS;</span>
<a href="#l22.157"></a><span id="l22.157"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/third_party/rnp/src/librekey/key_store_kbx.cpp</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/key_store_kbx.cpp</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -534,34 +534,33 @@ rnp_key_store_kbx_write_pgp(rnp_key_stor</span>
<a href="#l23.4"></a><span id="l23.4">         goto finish;</span>
<a href="#l23.5"></a><span id="l23.5">     }</span>
<a href="#l23.6"></a><span id="l23.6"> </span>
<a href="#l23.7"></a><span id="l23.7">     if (!pu32(&amp;memdst, 0) ||</span>
<a href="#l23.8"></a><span id="l23.8">         !pu32(&amp;memdst, 0)) { // offset and length of keyblock, update later</span>
<a href="#l23.9"></a><span id="l23.9">         goto finish;</span>
<a href="#l23.10"></a><span id="l23.10">     }</span>
<a href="#l23.11"></a><span id="l23.11"> </span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-    if (!pu16(&amp;memdst, 1 + list_length(key-&gt;subkey_grips))) { // number of keys in keyblock</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+    if (!pu16(&amp;memdst, 1 + key-&gt;subkey_grips.size())) { // number of keys in keyblock</span>
<a href="#l23.14"></a><span id="l23.14">         goto finish;</span>
<a href="#l23.15"></a><span id="l23.15">     }</span>
<a href="#l23.16"></a><span id="l23.16">     if (!pu16(&amp;memdst, 28)) { // size of key info structure)</span>
<a href="#l23.17"></a><span id="l23.17">         goto finish;</span>
<a href="#l23.18"></a><span id="l23.18">     }</span>
<a href="#l23.19"></a><span id="l23.19"> </span>
<a href="#l23.20"></a><span id="l23.20">     if (!pbuf(&amp;memdst, pgp_key_get_fp(key)-&gt;fingerprint, PGP_FINGERPRINT_SIZE) ||</span>
<a href="#l23.21"></a><span id="l23.21">         !pu32(&amp;memdst, memdst.writeb - 8) || // offset to keyid (part of fpr for V4)</span>
<a href="#l23.22"></a><span id="l23.22">         !pu16(&amp;memdst, 0) ||                 // flags, not used by GnuPG</span>
<a href="#l23.23"></a><span id="l23.23">         !pu16(&amp;memdst, 0)) {                 // RFU</span>
<a href="#l23.24"></a><span id="l23.24">         goto finish;</span>
<a href="#l23.25"></a><span id="l23.25">     }</span>
<a href="#l23.26"></a><span id="l23.26"> </span>
<a href="#l23.27"></a><span id="l23.27">     // same as above, for each subkey</span>
<a href="#l23.28"></a><span id="l23.28" class="difflineminus">-    for (list_item *sgrip = list_front(key-&gt;subkey_grips); sgrip; sgrip = list_next(sgrip)) {</span>
<a href="#l23.29"></a><span id="l23.29" class="difflineminus">-        const pgp_key_t *subkey =</span>
<a href="#l23.30"></a><span id="l23.30" class="difflineminus">-          rnp_key_store_get_key_by_grip(key_store, (const uint8_t *) sgrip);</span>
<a href="#l23.31"></a><span id="l23.31" class="difflineplus">+    for (auto &amp;sgrip : key-&gt;subkey_grips) {</span>
<a href="#l23.32"></a><span id="l23.32" class="difflineplus">+        const pgp_key_t *subkey = rnp_key_store_get_key_by_grip(key_store, sgrip);</span>
<a href="#l23.33"></a><span id="l23.33">         if (!pbuf(&amp;memdst, pgp_key_get_fp(subkey)-&gt;fingerprint, PGP_FINGERPRINT_SIZE) ||</span>
<a href="#l23.34"></a><span id="l23.34">             !pu32(&amp;memdst, memdst.writeb - 8) || // offset to keyid (part of fpr for V4)</span>
<a href="#l23.35"></a><span id="l23.35">             !pu16(&amp;memdst, 0) ||                 // flags, not used by GnuPG</span>
<a href="#l23.36"></a><span id="l23.36">             !pu16(&amp;memdst, 0)) {                 // RFU</span>
<a href="#l23.37"></a><span id="l23.37">             goto finish;</span>
<a href="#l23.38"></a><span id="l23.38">         }</span>
<a href="#l23.39"></a><span id="l23.39">         // load signature expirations while we're at it</span>
<a href="#l23.40"></a><span id="l23.40">         for (i = 0; i &lt; pgp_key_get_subsig_count(subkey); i++) {</span>
<a href="#l23.41"></a><span id="l23.41" class="difflineat">@@ -658,18 +657,18 @@ rnp_key_store_kbx_write_pgp(rnp_key_stor</span>
<a href="#l23.42"></a><span id="l23.42">     pt = key_start;</span>
<a href="#l23.43"></a><span id="l23.43">     p = (uint8_t *) mem_dest_get_memory(&amp;memdst) + 8;</span>
<a href="#l23.44"></a><span id="l23.44">     STORE32BE(p, pt);</span>
<a href="#l23.45"></a><span id="l23.45"> </span>
<a href="#l23.46"></a><span id="l23.46">     if (!pgp_key_write_packets(key, &amp;memdst)) {</span>
<a href="#l23.47"></a><span id="l23.47">         goto finish;</span>
<a href="#l23.48"></a><span id="l23.48">     }</span>
<a href="#l23.49"></a><span id="l23.49"> </span>
<a href="#l23.50"></a><span id="l23.50" class="difflineminus">-    for (list_item *sgrip = list_front(key-&gt;subkey_grips); sgrip; sgrip = list_next(sgrip)) {</span>
<a href="#l23.51"></a><span id="l23.51" class="difflineminus">-        const pgp_key_t *subkey = rnp_key_store_get_key_by_grip(key_store, (uint8_t *) sgrip);</span>
<a href="#l23.52"></a><span id="l23.52" class="difflineplus">+    for (auto &amp;sgrip : key-&gt;subkey_grips) {</span>
<a href="#l23.53"></a><span id="l23.53" class="difflineplus">+        const pgp_key_t *subkey = rnp_key_store_get_key_by_grip(key_store, sgrip);</span>
<a href="#l23.54"></a><span id="l23.54">         if (!pgp_key_write_packets(subkey, &amp;memdst)) {</span>
<a href="#l23.55"></a><span id="l23.55">             goto finish;</span>
<a href="#l23.56"></a><span id="l23.56">         }</span>
<a href="#l23.57"></a><span id="l23.57">     }</span>
<a href="#l23.58"></a><span id="l23.58"> </span>
<a href="#l23.59"></a><span id="l23.59">     /* key blob length */</span>
<a href="#l23.60"></a><span id="l23.60">     pt = memdst.writeb - key_start;</span>
<a href="#l23.61"></a><span id="l23.61">     p = (uint8_t *) mem_dest_get_memory(&amp;memdst) + 12;</span>
<a href="#l23.62"></a><span id="l23.62" class="difflineat">@@ -730,24 +729,22 @@ rnp_key_store_kbx_write_x509(rnp_key_sto</span>
<a href="#l23.63"></a><span id="l23.63"> bool</span>
<a href="#l23.64"></a><span id="l23.64"> rnp_key_store_kbx_to_dst(rnp_key_store_t *key_store, pgp_dest_t *dst)</span>
<a href="#l23.65"></a><span id="l23.65"> {</span>
<a href="#l23.66"></a><span id="l23.66">     if (!rnp_key_store_kbx_write_header(key_store, dst)) {</span>
<a href="#l23.67"></a><span id="l23.67">         RNP_LOG(&quot;Can't write KBX header&quot;);</span>
<a href="#l23.68"></a><span id="l23.68">         return false;</span>
<a href="#l23.69"></a><span id="l23.69">     }</span>
<a href="#l23.70"></a><span id="l23.70"> </span>
<a href="#l23.71"></a><span id="l23.71" class="difflineminus">-    for (list_item *key_item = list_front(rnp_key_store_get_keys(key_store)); key_item;</span>
<a href="#l23.72"></a><span id="l23.72" class="difflineminus">-         key_item = list_next(key_item)) {</span>
<a href="#l23.73"></a><span id="l23.73" class="difflineminus">-        pgp_key_t *key = (pgp_key_t *) key_item;</span>
<a href="#l23.74"></a><span id="l23.74" class="difflineminus">-        if (!pgp_key_is_primary_key(key)) {</span>
<a href="#l23.75"></a><span id="l23.75" class="difflineplus">+    for (auto &amp;key : key_store-&gt;keys) {</span>
<a href="#l23.76"></a><span id="l23.76" class="difflineplus">+        if (!pgp_key_is_primary_key(&amp;key)) {</span>
<a href="#l23.77"></a><span id="l23.77">             continue;</span>
<a href="#l23.78"></a><span id="l23.78">         }</span>
<a href="#l23.79"></a><span id="l23.79" class="difflineminus">-        if (!rnp_key_store_kbx_write_pgp(key_store, key, dst)) {</span>
<a href="#l23.80"></a><span id="l23.80" class="difflineminus">-            RNP_LOG(&quot;Can't write PGP blobs for key %p&quot;, key);</span>
<a href="#l23.81"></a><span id="l23.81" class="difflineplus">+        if (!rnp_key_store_kbx_write_pgp(key_store, &amp;key, dst)) {</span>
<a href="#l23.82"></a><span id="l23.82" class="difflineplus">+            RNP_LOG(&quot;Can't write PGP blobs for key %p&quot;, &amp;key);</span>
<a href="#l23.83"></a><span id="l23.83">             return false;</span>
<a href="#l23.84"></a><span id="l23.84">         }</span>
<a href="#l23.85"></a><span id="l23.85">     }</span>
<a href="#l23.86"></a><span id="l23.86"> </span>
<a href="#l23.87"></a><span id="l23.87">     if (!rnp_key_store_kbx_write_x509(key_store, dst)) {</span>
<a href="#l23.88"></a><span id="l23.88">         RNP_LOG(&quot;Can't write X509 blobs&quot;);</span>
<a href="#l23.89"></a><span id="l23.89">         return false;</span>
<a href="#l23.90"></a><span id="l23.90">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/third_party/rnp/src/librekey/key_store_pgp.cpp</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/key_store_pgp.cpp</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -70,20 +70,16 @@</span>
<a href="#l24.4"></a><span id="l24.4"> bool</span>
<a href="#l24.5"></a><span id="l24.5"> rnp_key_add_signature(pgp_key_t *key, const pgp_signature_t *sig)</span>
<a href="#l24.6"></a><span id="l24.6"> {</span>
<a href="#l24.7"></a><span id="l24.7">     pgp_subsig_t *subsig = pgp_key_add_subsig(key);</span>
<a href="#l24.8"></a><span id="l24.8">     if (!subsig) {</span>
<a href="#l24.9"></a><span id="l24.9">         RNP_LOG(&quot;Failed to add subsig&quot;);</span>
<a href="#l24.10"></a><span id="l24.10">         return false;</span>
<a href="#l24.11"></a><span id="l24.11">     }</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-    /* add signature rawpacket */</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineminus">-    if (!pgp_key_add_sig_rawpacket(key, sig)) {</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineminus">-        return false;</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineminus">-    }</span>
<a href="#l24.16"></a><span id="l24.16">     /* setup subsig and key from signature */</span>
<a href="#l24.17"></a><span id="l24.17">     if (!pgp_subsig_from_signature(subsig, sig)) {</span>
<a href="#l24.18"></a><span id="l24.18">         return false;</span>
<a href="#l24.19"></a><span id="l24.19">     }</span>
<a href="#l24.20"></a><span id="l24.20">     subsig-&gt;uid = pgp_key_get_userid_count(key) - 1;</span>
<a href="#l24.21"></a><span id="l24.21">     return true;</span>
<a href="#l24.22"></a><span id="l24.22"> }</span>
<a href="#l24.23"></a><span id="l24.23"> </span>
<a href="#l24.24"></a><span id="l24.24" class="difflineat">@@ -117,39 +113,38 @@ rnp_key_store_add_transferable_subkey(rn</span>
<a href="#l24.25"></a><span id="l24.25">         RNP_LOG(&quot;Failed to add subkey to key store.&quot;);</span>
<a href="#l24.26"></a><span id="l24.26">     }</span>
<a href="#l24.27"></a><span id="l24.27">     return res;</span>
<a href="#l24.28"></a><span id="l24.28"> }</span>
<a href="#l24.29"></a><span id="l24.29"> </span>
<a href="#l24.30"></a><span id="l24.30"> bool</span>
<a href="#l24.31"></a><span id="l24.31"> rnp_key_add_transferable_userid(pgp_key_t *key, pgp_transferable_userid_t *uid)</span>
<a href="#l24.32"></a><span id="l24.32"> {</span>
<a href="#l24.33"></a><span id="l24.33" class="difflineminus">-    if (!pgp_key_add_uid_rawpacket(key, &amp;uid-&gt;uid)) {</span>
<a href="#l24.34"></a><span id="l24.34" class="difflineminus">-        return false;</span>
<a href="#l24.35"></a><span id="l24.35" class="difflineminus">-    }</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineminus">-</span>
<a href="#l24.37"></a><span id="l24.37">     pgp_userid_t *userid = pgp_key_add_userid(key);</span>
<a href="#l24.38"></a><span id="l24.38">     if (!userid) {</span>
<a href="#l24.39"></a><span id="l24.39">         RNP_LOG(&quot;Failed to add userid&quot;);</span>
<a href="#l24.40"></a><span id="l24.40">         return false;</span>
<a href="#l24.41"></a><span id="l24.41">     }</span>
<a href="#l24.42"></a><span id="l24.42" class="difflineminus">-    if (uid-&gt;uid.tag == PGP_PKT_USER_ID) {</span>
<a href="#l24.43"></a><span id="l24.43" class="difflineminus">-        userid-&gt;str = (char *) calloc(1, uid-&gt;uid.uid_len + 1);</span>
<a href="#l24.44"></a><span id="l24.44" class="difflineminus">-        if (!userid-&gt;str) {</span>
<a href="#l24.45"></a><span id="l24.45" class="difflineminus">-            RNP_LOG(&quot;uid alloc failed&quot;);</span>
<a href="#l24.46"></a><span id="l24.46" class="difflineminus">-            return false;</span>
<a href="#l24.47"></a><span id="l24.47" class="difflineplus">+    try {</span>
<a href="#l24.48"></a><span id="l24.48" class="difflineplus">+        userid-&gt;rawpkt = pgp_rawpacket_t(uid-&gt;uid);</span>
<a href="#l24.49"></a><span id="l24.49" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l24.50"></a><span id="l24.50" class="difflineplus">+        RNP_LOG(&quot;Raw packet allocation failed: %s&quot;, e.what());</span>
<a href="#l24.51"></a><span id="l24.51" class="difflineplus">+        return false;</span>
<a href="#l24.52"></a><span id="l24.52" class="difflineplus">+    }</span>
<a href="#l24.53"></a><span id="l24.53" class="difflineplus">+</span>
<a href="#l24.54"></a><span id="l24.54" class="difflineplus">+    try {</span>
<a href="#l24.55"></a><span id="l24.55" class="difflineplus">+        if (uid-&gt;uid.tag == PGP_PKT_USER_ID) {</span>
<a href="#l24.56"></a><span id="l24.56" class="difflineplus">+            userid-&gt;str = std::string(uid-&gt;uid.uid, uid-&gt;uid.uid + uid-&gt;uid.uid_len);</span>
<a href="#l24.57"></a><span id="l24.57" class="difflineplus">+        } else {</span>
<a href="#l24.58"></a><span id="l24.58" class="difflineplus">+            userid-&gt;str = &quot;(photo)&quot;;</span>
<a href="#l24.59"></a><span id="l24.59">         }</span>
<a href="#l24.60"></a><span id="l24.60" class="difflineminus">-        memcpy(userid-&gt;str, uid-&gt;uid.uid, uid-&gt;uid.uid_len);</span>
<a href="#l24.61"></a><span id="l24.61" class="difflineminus">-        userid-&gt;str[uid-&gt;uid.uid_len] = 0;</span>
<a href="#l24.62"></a><span id="l24.62" class="difflineminus">-    } else {</span>
<a href="#l24.63"></a><span id="l24.63" class="difflineminus">-        userid-&gt;str = strdup(&quot;(photo)&quot;);</span>
<a href="#l24.64"></a><span id="l24.64" class="difflineminus">-        if (!userid-&gt;str) {</span>
<a href="#l24.65"></a><span id="l24.65" class="difflineminus">-            RNP_LOG(&quot;uattr alloc failed&quot;);</span>
<a href="#l24.66"></a><span id="l24.66" class="difflineminus">-            return false;</span>
<a href="#l24.67"></a><span id="l24.67" class="difflineminus">-        }</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l24.69"></a><span id="l24.69" class="difflineplus">+        RNP_LOG(</span>
<a href="#l24.70"></a><span id="l24.70" class="difflineplus">+          &quot;%s alloc failed: %s&quot;, uid-&gt;uid.tag == PGP_PKT_USER_ID ? &quot;uid&quot; : &quot;uattr&quot;, e.what());</span>
<a href="#l24.71"></a><span id="l24.71" class="difflineplus">+        return false;</span>
<a href="#l24.72"></a><span id="l24.72">     }</span>
<a href="#l24.73"></a><span id="l24.73"> </span>
<a href="#l24.74"></a><span id="l24.74">     if (!copy_userid_pkt(&amp;userid-&gt;pkt, &amp;uid-&gt;uid)) {</span>
<a href="#l24.75"></a><span id="l24.75">         RNP_LOG(&quot;failed to copy user id pkt&quot;);</span>
<a href="#l24.76"></a><span id="l24.76">         return false;</span>
<a href="#l24.77"></a><span id="l24.77">     }</span>
<a href="#l24.78"></a><span id="l24.78"> </span>
<a href="#l24.79"></a><span id="l24.79">     if (!rnp_key_add_signatures(key, uid-&gt;signatures)) {</span>
<a href="#l24.80"></a><span id="l24.80" class="difflineat">@@ -284,91 +279,57 @@ rnp_key_store_pgp_read_from_src(rnp_key_</span>
<a href="#l24.81"></a><span id="l24.81"> </span>
<a href="#l24.82"></a><span id="l24.82">     ret = RNP_SUCCESS;</span>
<a href="#l24.83"></a><span id="l24.83"> done:</span>
<a href="#l24.84"></a><span id="l24.84">     key_sequence_destroy(&amp;keys);</span>
<a href="#l24.85"></a><span id="l24.85">     return ret;</span>
<a href="#l24.86"></a><span id="l24.86"> }</span>
<a href="#l24.87"></a><span id="l24.87"> </span>
<a href="#l24.88"></a><span id="l24.88"> bool</span>
<a href="#l24.89"></a><span id="l24.89" class="difflineminus">-rnp_key_write_packets_stream(const pgp_key_t *key, pgp_dest_t *dst)</span>
<a href="#l24.90"></a><span id="l24.90" class="difflineminus">-{</span>
<a href="#l24.91"></a><span id="l24.91" class="difflineminus">-    if (!pgp_key_get_rawpacket_count(key)) {</span>
<a href="#l24.92"></a><span id="l24.92" class="difflineminus">-        return false;</span>
<a href="#l24.93"></a><span id="l24.93" class="difflineminus">-    }</span>
<a href="#l24.94"></a><span id="l24.94" class="difflineminus">-    for (size_t i = 0; i &lt; pgp_key_get_rawpacket_count(key); i++) {</span>
<a href="#l24.95"></a><span id="l24.95" class="difflineminus">-        const pgp_rawpacket_t *pkt = pgp_key_get_rawpacket(key, i);</span>
<a href="#l24.96"></a><span id="l24.96" class="difflineminus">-        if (!pkt-&gt;raw || !pkt-&gt;length) {</span>
<a href="#l24.97"></a><span id="l24.97" class="difflineminus">-            return false;</span>
<a href="#l24.98"></a><span id="l24.98" class="difflineminus">-        }</span>
<a href="#l24.99"></a><span id="l24.99" class="difflineminus">-        dst_write(dst, pkt-&gt;raw, pkt-&gt;length);</span>
<a href="#l24.100"></a><span id="l24.100" class="difflineminus">-    }</span>
<a href="#l24.101"></a><span id="l24.101" class="difflineminus">-    return !dst-&gt;werr;</span>
<a href="#l24.102"></a><span id="l24.102" class="difflineminus">-}</span>
<a href="#l24.103"></a><span id="l24.103" class="difflineminus">-</span>
<a href="#l24.104"></a><span id="l24.104" class="difflineminus">-bool</span>
<a href="#l24.105"></a><span id="l24.105"> rnp_key_to_src(const pgp_key_t *key, pgp_source_t *src)</span>
<a href="#l24.106"></a><span id="l24.106"> {</span>
<a href="#l24.107"></a><span id="l24.107">     pgp_dest_t dst = {};</span>
<a href="#l24.108"></a><span id="l24.108">     bool       res;</span>
<a href="#l24.109"></a><span id="l24.109"> </span>
<a href="#l24.110"></a><span id="l24.110">     if (init_mem_dest(&amp;dst, NULL, 0)) {</span>
<a href="#l24.111"></a><span id="l24.111">         return false;</span>
<a href="#l24.112"></a><span id="l24.112">     }</span>
<a href="#l24.113"></a><span id="l24.113"> </span>
<a href="#l24.114"></a><span id="l24.114" class="difflineminus">-    res = rnp_key_write_packets_stream(key, &amp;dst) &amp;&amp;</span>
<a href="#l24.115"></a><span id="l24.115" class="difflineplus">+    res = pgp_key_write_packets(key, &amp;dst) &amp;&amp;</span>
<a href="#l24.116"></a><span id="l24.116">           !init_mem_src(src, mem_dest_own_memory(&amp;dst), dst.writeb, true);</span>
<a href="#l24.117"></a><span id="l24.117">     dst_close(&amp;dst, true);</span>
<a href="#l24.118"></a><span id="l24.118">     return res;</span>
<a href="#l24.119"></a><span id="l24.119"> }</span>
<a href="#l24.120"></a><span id="l24.120"> </span>
<a href="#l24.121"></a><span id="l24.121"> static bool</span>
<a href="#l24.122"></a><span id="l24.122"> do_write(rnp_key_store_t *key_store, pgp_dest_t *dst, bool secret)</span>
<a href="#l24.123"></a><span id="l24.123"> {</span>
<a href="#l24.124"></a><span id="l24.124" class="difflineminus">-    for (list_item *key_item = list_front(rnp_key_store_get_keys(key_store)); key_item;</span>
<a href="#l24.125"></a><span id="l24.125" class="difflineminus">-         key_item = list_next(key_item)) {</span>
<a href="#l24.126"></a><span id="l24.126" class="difflineminus">-        pgp_key_t *key = (pgp_key_t *) key_item;</span>
<a href="#l24.127"></a><span id="l24.127" class="difflineminus">-        if (pgp_key_is_secret(key) != secret) {</span>
<a href="#l24.128"></a><span id="l24.128" class="difflineplus">+    for (auto &amp;key : key_store-&gt;keys) {</span>
<a href="#l24.129"></a><span id="l24.129" class="difflineplus">+        if (pgp_key_is_secret(&amp;key) != secret) {</span>
<a href="#l24.130"></a><span id="l24.130">             continue;</span>
<a href="#l24.131"></a><span id="l24.131">         }</span>
<a href="#l24.132"></a><span id="l24.132">         // skip subkeys, they are written below (orphans are ignored)</span>
<a href="#l24.133"></a><span id="l24.133" class="difflineminus">-        if (!pgp_key_is_primary_key(key)) {</span>
<a href="#l24.134"></a><span id="l24.134" class="difflineplus">+        if (!pgp_key_is_primary_key(&amp;key)) {</span>
<a href="#l24.135"></a><span id="l24.135">             continue;</span>
<a href="#l24.136"></a><span id="l24.136">         }</span>
<a href="#l24.137"></a><span id="l24.137"> </span>
<a href="#l24.138"></a><span id="l24.138" class="difflineminus">-        if (key-&gt;format != PGP_KEY_STORE_GPG) {</span>
<a href="#l24.139"></a><span id="l24.139" class="difflineminus">-            RNP_LOG(&quot;incorrect format (conversions not supported): %d&quot;, key-&gt;format);</span>
<a href="#l24.140"></a><span id="l24.140" class="difflineminus">-            return false;</span>
<a href="#l24.141"></a><span id="l24.141" class="difflineminus">-        }</span>
<a href="#l24.142"></a><span id="l24.142" class="difflineminus">-        if (!rnp_key_write_packets_stream(key, dst)) {</span>
<a href="#l24.143"></a><span id="l24.143" class="difflineplus">+        if (key.format != PGP_KEY_STORE_GPG) {</span>
<a href="#l24.144"></a><span id="l24.144" class="difflineplus">+            RNP_LOG(&quot;incorrect format (conversions not supported): %d&quot;, key.format);</span>
<a href="#l24.145"></a><span id="l24.145">             return false;</span>
<a href="#l24.146"></a><span id="l24.146">         }</span>
<a href="#l24.147"></a><span id="l24.147" class="difflineminus">-        for (list_item *subkey_grip = list_front(key-&gt;subkey_grips); subkey_grip;</span>
<a href="#l24.148"></a><span id="l24.148" class="difflineminus">-             subkey_grip = list_next(subkey_grip)) {</span>
<a href="#l24.149"></a><span id="l24.149" class="difflineminus">-            pgp_key_search_t search = {};</span>
<a href="#l24.150"></a><span id="l24.150" class="difflineminus">-            search.type = PGP_KEY_SEARCH_GRIP;</span>
<a href="#l24.151"></a><span id="l24.151" class="difflineminus">-            memcpy(search.by.grip, (uint8_t *) subkey_grip, PGP_KEY_GRIP_SIZE);</span>
<a href="#l24.152"></a><span id="l24.152" class="difflineminus">-            pgp_key_t *subkey = NULL;</span>
<a href="#l24.153"></a><span id="l24.153" class="difflineminus">-            for (list_item *subkey_item = list_front(rnp_key_store_get_keys(key_store));</span>
<a href="#l24.154"></a><span id="l24.154" class="difflineminus">-                 subkey_item;</span>
<a href="#l24.155"></a><span id="l24.155" class="difflineminus">-                 subkey_item = list_next(subkey_item)) {</span>
<a href="#l24.156"></a><span id="l24.156" class="difflineminus">-                pgp_key_t *candidate = (pgp_key_t *) subkey_item;</span>
<a href="#l24.157"></a><span id="l24.157" class="difflineminus">-                if (pgp_key_is_secret(candidate) != secret) {</span>
<a href="#l24.158"></a><span id="l24.158" class="difflineminus">-                    continue;</span>
<a href="#l24.159"></a><span id="l24.159" class="difflineminus">-                }</span>
<a href="#l24.160"></a><span id="l24.160" class="difflineminus">-                if (rnp_key_matches_search(candidate, &amp;search)) {</span>
<a href="#l24.161"></a><span id="l24.161" class="difflineminus">-                    subkey = candidate;</span>
<a href="#l24.162"></a><span id="l24.162" class="difflineminus">-                    break;</span>
<a href="#l24.163"></a><span id="l24.163" class="difflineminus">-                }</span>
<a href="#l24.164"></a><span id="l24.164" class="difflineminus">-            }</span>
<a href="#l24.165"></a><span id="l24.165" class="difflineplus">+        if (!pgp_key_write_packets(&amp;key, dst)) {</span>
<a href="#l24.166"></a><span id="l24.166" class="difflineplus">+            return false;</span>
<a href="#l24.167"></a><span id="l24.167" class="difflineplus">+        }</span>
<a href="#l24.168"></a><span id="l24.168" class="difflineplus">+        for (auto &amp;sgrip : key.subkey_grips) {</span>
<a href="#l24.169"></a><span id="l24.169" class="difflineplus">+            pgp_key_t *subkey = rnp_key_store_get_key_by_grip(key_store, sgrip);</span>
<a href="#l24.170"></a><span id="l24.170">             if (!subkey) {</span>
<a href="#l24.171"></a><span id="l24.171">                 RNP_LOG(&quot;Missing subkey&quot;);</span>
<a href="#l24.172"></a><span id="l24.172">                 continue;</span>
<a href="#l24.173"></a><span id="l24.173">             }</span>
<a href="#l24.174"></a><span id="l24.174" class="difflineminus">-            if (!rnp_key_write_packets_stream(subkey, dst)) {</span>
<a href="#l24.175"></a><span id="l24.175" class="difflineplus">+            if (!pgp_key_write_packets(subkey, dst)) {</span>
<a href="#l24.176"></a><span id="l24.176">                 return false;</span>
<a href="#l24.177"></a><span id="l24.177">             }</span>
<a href="#l24.178"></a><span id="l24.178">         }</span>
<a href="#l24.179"></a><span id="l24.179">     }</span>
<a href="#l24.180"></a><span id="l24.180">     return true;</span>
<a href="#l24.181"></a><span id="l24.181"> }</span>
<a href="#l24.182"></a><span id="l24.182"> </span>
<a href="#l24.183"></a><span id="l24.183"> bool</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/third_party/rnp/src/librekey/key_store_pgp.h</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/key_store_pgp.h</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -75,13 +75,11 @@ bool rnp_key_from_transferable_key(pgp_k</span>
<a href="#l25.4"></a><span id="l25.4"> bool rnp_key_from_transferable_subkey(pgp_key_t *                subkey,</span>
<a href="#l25.5"></a><span id="l25.5">                                       pgp_transferable_subkey_t *tskey,</span>
<a href="#l25.6"></a><span id="l25.6">                                       pgp_key_t *                primary);</span>
<a href="#l25.7"></a><span id="l25.7"> </span>
<a href="#l25.8"></a><span id="l25.8"> bool rnp_key_add_transferable_userid(pgp_key_t *key, pgp_transferable_userid_t *uid);</span>
<a href="#l25.9"></a><span id="l25.9"> </span>
<a href="#l25.10"></a><span id="l25.10"> bool rnp_key_add_signature(pgp_key_t *key, const pgp_signature_t *sig);</span>
<a href="#l25.11"></a><span id="l25.11"> </span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-bool rnp_key_write_packets_stream(const pgp_key_t *key, pgp_dest_t *dst);</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineminus">-</span>
<a href="#l25.14"></a><span id="l25.14"> bool rnp_key_to_src(const pgp_key_t *key, pgp_source_t *src);</span>
<a href="#l25.15"></a><span id="l25.15"> </span>
<a href="#l25.16"></a><span id="l25.16"> #endif /* KEY_STORE_PGP_H_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/third_party/rnp/src/librekey/rnp_key_store.cpp</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/rnp_key_store.cpp</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -34,16 +34,17 @@</span>
<a href="#l26.4"></a><span id="l26.4"> </span>
<a href="#l26.5"></a><span id="l26.5"> #include &lt;assert.h&gt;</span>
<a href="#l26.6"></a><span id="l26.6"> #include &lt;stdio.h&gt;</span>
<a href="#l26.7"></a><span id="l26.7"> #include &lt;string.h&gt;</span>
<a href="#l26.8"></a><span id="l26.8"> #include &lt;stdint.h&gt;</span>
<a href="#l26.9"></a><span id="l26.9"> #include &lt;stdlib.h&gt;</span>
<a href="#l26.10"></a><span id="l26.10"> #include &lt;dirent.h&gt;</span>
<a href="#l26.11"></a><span id="l26.11"> #include &lt;errno.h&gt;</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineplus">+#include &lt;algorithm&gt;</span>
<a href="#l26.13"></a><span id="l26.13"> </span>
<a href="#l26.14"></a><span id="l26.14"> #include &lt;rnp/rnp_sdk.h&gt;</span>
<a href="#l26.15"></a><span id="l26.15"> #include &lt;rekey/rnp_key_store.h&gt;</span>
<a href="#l26.16"></a><span id="l26.16"> #include &lt;librepgp/stream-packet.h&gt;</span>
<a href="#l26.17"></a><span id="l26.17"> </span>
<a href="#l26.18"></a><span id="l26.18"> #include &quot;key_store_pgp.h&quot;</span>
<a href="#l26.19"></a><span id="l26.19"> #include &quot;key_store_kbx.h&quot;</span>
<a href="#l26.20"></a><span id="l26.20"> #include &quot;key_store_g10.h&quot;</span>
<a href="#l26.21"></a><span id="l26.21" class="difflineat">@@ -54,58 +55,40 @@</span>
<a href="#l26.22"></a><span id="l26.22"> </span>
<a href="#l26.23"></a><span id="l26.23"> // must be placed after include &quot;utils.h&quot;</span>
<a href="#l26.24"></a><span id="l26.24"> #ifndef RNP_USE_STD_REGEX</span>
<a href="#l26.25"></a><span id="l26.25"> #include &lt;regex.h&gt;</span>
<a href="#l26.26"></a><span id="l26.26"> #else</span>
<a href="#l26.27"></a><span id="l26.27"> #include &lt;regex&gt;</span>
<a href="#l26.28"></a><span id="l26.28"> #endif</span>
<a href="#l26.29"></a><span id="l26.29"> </span>
<a href="#l26.30"></a><span id="l26.30" class="difflineminus">-rnp_key_store_t *</span>
<a href="#l26.31"></a><span id="l26.31" class="difflineminus">-rnp_key_store_new(pgp_key_store_format_t format, const char *path)</span>
<a href="#l26.32"></a><span id="l26.32" class="difflineminus">-{</span>
<a href="#l26.33"></a><span id="l26.33" class="difflineminus">-    if (format == PGP_KEY_STORE_UNKNOWN) {</span>
<a href="#l26.34"></a><span id="l26.34" class="difflineminus">-        RNP_LOG(&quot;Invalid key store format&quot;);</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineminus">-        return NULL;</span>
<a href="#l26.36"></a><span id="l26.36" class="difflineminus">-    }</span>
<a href="#l26.37"></a><span id="l26.37" class="difflineminus">-</span>
<a href="#l26.38"></a><span id="l26.38" class="difflineminus">-    rnp_key_store_t *key_store = (rnp_key_store_t *) calloc(1, sizeof(*key_store));</span>
<a href="#l26.39"></a><span id="l26.39" class="difflineminus">-    if (!key_store) {</span>
<a href="#l26.40"></a><span id="l26.40" class="difflineminus">-        RNP_LOG(&quot;Can't allocate memory&quot;);</span>
<a href="#l26.41"></a><span id="l26.41" class="difflineminus">-        return NULL;</span>
<a href="#l26.42"></a><span id="l26.42" class="difflineminus">-    }</span>
<a href="#l26.43"></a><span id="l26.43" class="difflineminus">-</span>
<a href="#l26.44"></a><span id="l26.44" class="difflineminus">-    key_store-&gt;format = format;</span>
<a href="#l26.45"></a><span id="l26.45" class="difflineminus">-    key_store-&gt;path = strdup(path);</span>
<a href="#l26.46"></a><span id="l26.46" class="difflineminus">-    return key_store;</span>
<a href="#l26.47"></a><span id="l26.47" class="difflineminus">-}</span>
<a href="#l26.48"></a><span id="l26.48" class="difflineminus">-</span>
<a href="#l26.49"></a><span id="l26.49"> bool</span>
<a href="#l26.50"></a><span id="l26.50"> rnp_key_store_load_from_path(rnp_key_store_t *         key_store,</span>
<a href="#l26.51"></a><span id="l26.51">                              const pgp_key_provider_t *key_provider)</span>
<a href="#l26.52"></a><span id="l26.52"> {</span>
<a href="#l26.53"></a><span id="l26.53">     DIR *          dir;</span>
<a href="#l26.54"></a><span id="l26.54">     bool           rc;</span>
<a href="#l26.55"></a><span id="l26.55">     pgp_source_t   src = {};</span>
<a href="#l26.56"></a><span id="l26.56">     struct dirent *ent;</span>
<a href="#l26.57"></a><span id="l26.57">     char           path[MAXPATHLEN];</span>
<a href="#l26.58"></a><span id="l26.58"> </span>
<a href="#l26.59"></a><span id="l26.59">     if (key_store-&gt;format == PGP_KEY_STORE_G10) {</span>
<a href="#l26.60"></a><span id="l26.60" class="difflineminus">-        dir = opendir(key_store-&gt;path);</span>
<a href="#l26.61"></a><span id="l26.61" class="difflineplus">+        dir = opendir(key_store-&gt;path.c_str());</span>
<a href="#l26.62"></a><span id="l26.62">         if (dir == NULL) {</span>
<a href="#l26.63"></a><span id="l26.63" class="difflineminus">-            RNP_LOG(&quot;Can't open G10 directory %s: %s&quot;, key_store-&gt;path, strerror(errno));</span>
<a href="#l26.64"></a><span id="l26.64" class="difflineplus">+            RNP_LOG(</span>
<a href="#l26.65"></a><span id="l26.65" class="difflineplus">+              &quot;Can't open G10 directory %s: %s&quot;, key_store-&gt;path.c_str(), strerror(errno));</span>
<a href="#l26.66"></a><span id="l26.66">             return false;</span>
<a href="#l26.67"></a><span id="l26.67">         }</span>
<a href="#l26.68"></a><span id="l26.68"> </span>
<a href="#l26.69"></a><span id="l26.69">         while ((ent = readdir(dir)) != NULL) {</span>
<a href="#l26.70"></a><span id="l26.70">             if (!strcmp(ent-&gt;d_name, &quot;.&quot;) || !strcmp(ent-&gt;d_name, &quot;..&quot;)) {</span>
<a href="#l26.71"></a><span id="l26.71">                 continue;</span>
<a href="#l26.72"></a><span id="l26.72">             }</span>
<a href="#l26.73"></a><span id="l26.73"> </span>
<a href="#l26.74"></a><span id="l26.74" class="difflineminus">-            snprintf(path, sizeof(path), &quot;%s/%s&quot;, key_store-&gt;path, ent-&gt;d_name);</span>
<a href="#l26.75"></a><span id="l26.75" class="difflineplus">+            snprintf(path, sizeof(path), &quot;%s/%s&quot;, key_store-&gt;path.c_str(), ent-&gt;d_name);</span>
<a href="#l26.76"></a><span id="l26.76">             RNP_DLOG(&quot;Loading G10 key from file '%s'&quot;, path);</span>
<a href="#l26.77"></a><span id="l26.77"> </span>
<a href="#l26.78"></a><span id="l26.78">             if (init_file_src(&amp;src, path)) {</span>
<a href="#l26.79"></a><span id="l26.79">                 RNP_LOG(&quot;failed to read file %s&quot;, path);</span>
<a href="#l26.80"></a><span id="l26.80">                 continue;</span>
<a href="#l26.81"></a><span id="l26.81">             }</span>
<a href="#l26.82"></a><span id="l26.82"> </span>
<a href="#l26.83"></a><span id="l26.83">             // G10 may don't read one file, so, ignore it!</span>
<a href="#l26.84"></a><span id="l26.84" class="difflineat">@@ -114,18 +97,18 @@ rnp_key_store_load_from_path(rnp_key_sto</span>
<a href="#l26.85"></a><span id="l26.85">             }</span>
<a href="#l26.86"></a><span id="l26.86">             src_close(&amp;src);</span>
<a href="#l26.87"></a><span id="l26.87">         }</span>
<a href="#l26.88"></a><span id="l26.88">         closedir(dir);</span>
<a href="#l26.89"></a><span id="l26.89">         return true;</span>
<a href="#l26.90"></a><span id="l26.90">     }</span>
<a href="#l26.91"></a><span id="l26.91"> </span>
<a href="#l26.92"></a><span id="l26.92">     /* init file source and load from it */</span>
<a href="#l26.93"></a><span id="l26.93" class="difflineminus">-    if (init_file_src(&amp;src, key_store-&gt;path)) {</span>
<a href="#l26.94"></a><span id="l26.94" class="difflineminus">-        RNP_LOG(&quot;failed to read file %s&quot;, key_store-&gt;path);</span>
<a href="#l26.95"></a><span id="l26.95" class="difflineplus">+    if (init_file_src(&amp;src, key_store-&gt;path.c_str())) {</span>
<a href="#l26.96"></a><span id="l26.96" class="difflineplus">+        RNP_LOG(&quot;failed to read file %s&quot;, key_store-&gt;path.c_str());</span>
<a href="#l26.97"></a><span id="l26.97">         return false;</span>
<a href="#l26.98"></a><span id="l26.98">     }</span>
<a href="#l26.99"></a><span id="l26.99"> </span>
<a href="#l26.100"></a><span id="l26.100">     rc = rnp_key_store_load_from_src(key_store, &amp;src, key_provider);</span>
<a href="#l26.101"></a><span id="l26.101">     src_close(&amp;src);</span>
<a href="#l26.102"></a><span id="l26.102">     return rc;</span>
<a href="#l26.103"></a><span id="l26.103"> }</span>
<a href="#l26.104"></a><span id="l26.104"> </span>
<a href="#l26.105"></a><span id="l26.105" class="difflineat">@@ -155,48 +138,46 @@ rnp_key_store_write_to_path(rnp_key_stor</span>
<a href="#l26.106"></a><span id="l26.106">     pgp_dest_t keydst = {};</span>
<a href="#l26.107"></a><span id="l26.107"> </span>
<a href="#l26.108"></a><span id="l26.108">     /* write g10 key store to the directory */</span>
<a href="#l26.109"></a><span id="l26.109">     if (key_store-&gt;format == PGP_KEY_STORE_G10) {</span>
<a href="#l26.110"></a><span id="l26.110">         char path[MAXPATHLEN];</span>
<a href="#l26.111"></a><span id="l26.111">         char grips[PGP_FINGERPRINT_HEX_SIZE];</span>
<a href="#l26.112"></a><span id="l26.112"> </span>
<a href="#l26.113"></a><span id="l26.113">         struct stat path_stat;</span>
<a href="#l26.114"></a><span id="l26.114" class="difflineminus">-        if (stat(key_store-&gt;path, &amp;path_stat) != -1) {</span>
<a href="#l26.115"></a><span id="l26.115" class="difflineplus">+        if (stat(key_store-&gt;path.c_str(), &amp;path_stat) != -1) {</span>
<a href="#l26.116"></a><span id="l26.116">             if (!S_ISDIR(path_stat.st_mode)) {</span>
<a href="#l26.117"></a><span id="l26.117" class="difflineminus">-                RNP_LOG(&quot;G10 keystore should be a directory: %s&quot;, key_store-&gt;path);</span>
<a href="#l26.118"></a><span id="l26.118" class="difflineplus">+                RNP_LOG(&quot;G10 keystore should be a directory: %s&quot;, key_store-&gt;path.c_str());</span>
<a href="#l26.119"></a><span id="l26.119">                 return false;</span>
<a href="#l26.120"></a><span id="l26.120">             }</span>
<a href="#l26.121"></a><span id="l26.121">         } else {</span>
<a href="#l26.122"></a><span id="l26.122">             if (errno != ENOENT) {</span>
<a href="#l26.123"></a><span id="l26.123" class="difflineminus">-                RNP_LOG(&quot;stat(%s): %s&quot;, key_store-&gt;path, strerror(errno));</span>
<a href="#l26.124"></a><span id="l26.124" class="difflineplus">+                RNP_LOG(&quot;stat(%s): %s&quot;, key_store-&gt;path.c_str(), strerror(errno));</span>
<a href="#l26.125"></a><span id="l26.125">                 return false;</span>
<a href="#l26.126"></a><span id="l26.126">             }</span>
<a href="#l26.127"></a><span id="l26.127" class="difflineminus">-            if (RNP_MKDIR(key_store-&gt;path, S_IRWXU) != 0) {</span>
<a href="#l26.128"></a><span id="l26.128" class="difflineminus">-                RNP_LOG(&quot;mkdir(%s, S_IRWXU): %s&quot;, key_store-&gt;path, strerror(errno));</span>
<a href="#l26.129"></a><span id="l26.129" class="difflineplus">+            if (RNP_MKDIR(key_store-&gt;path.c_str(), S_IRWXU) != 0) {</span>
<a href="#l26.130"></a><span id="l26.130" class="difflineplus">+                RNP_LOG(&quot;mkdir(%s, S_IRWXU): %s&quot;, key_store-&gt;path.c_str(), strerror(errno));</span>
<a href="#l26.131"></a><span id="l26.131">                 return false;</span>
<a href="#l26.132"></a><span id="l26.132">             }</span>
<a href="#l26.133"></a><span id="l26.133">         }</span>
<a href="#l26.134"></a><span id="l26.134"> </span>
<a href="#l26.135"></a><span id="l26.135" class="difflineminus">-        for (list_item *key_item = list_front(rnp_key_store_get_keys(key_store)); key_item;</span>
<a href="#l26.136"></a><span id="l26.136" class="difflineminus">-             key_item = list_next(key_item)) {</span>
<a href="#l26.137"></a><span id="l26.137" class="difflineminus">-            pgp_key_t *key = (pgp_key_t *) key_item;</span>
<a href="#l26.138"></a><span id="l26.138" class="difflineminus">-            snprintf(</span>
<a href="#l26.139"></a><span id="l26.139" class="difflineminus">-              path,</span>
<a href="#l26.140"></a><span id="l26.140" class="difflineminus">-              sizeof(path),</span>
<a href="#l26.141"></a><span id="l26.141" class="difflineminus">-              &quot;%s/%s.key&quot;,</span>
<a href="#l26.142"></a><span id="l26.142" class="difflineminus">-              key_store-&gt;path,</span>
<a href="#l26.143"></a><span id="l26.143" class="difflineminus">-              rnp_strhexdump_upper(grips, pgp_key_get_grip(key), PGP_KEY_GRIP_SIZE, &quot;&quot;));</span>
<a href="#l26.144"></a><span id="l26.144" class="difflineplus">+        for (auto &amp;key : key_store-&gt;keys) {</span>
<a href="#l26.145"></a><span id="l26.145" class="difflineplus">+            const pgp_key_grip_t &amp;grip = pgp_key_get_grip(&amp;key);</span>
<a href="#l26.146"></a><span id="l26.146" class="difflineplus">+            snprintf(path,</span>
<a href="#l26.147"></a><span id="l26.147" class="difflineplus">+                     sizeof(path),</span>
<a href="#l26.148"></a><span id="l26.148" class="difflineplus">+                     &quot;%s/%s.key&quot;,</span>
<a href="#l26.149"></a><span id="l26.149" class="difflineplus">+                     key_store-&gt;path.c_str(),</span>
<a href="#l26.150"></a><span id="l26.150" class="difflineplus">+                     rnp_strhexdump_upper(grips, grip.data(), grip.size(), &quot;&quot;));</span>
<a href="#l26.151"></a><span id="l26.151"> </span>
<a href="#l26.152"></a><span id="l26.152">             if (init_tmpfile_dest(&amp;keydst, path, true)) {</span>
<a href="#l26.153"></a><span id="l26.153">                 RNP_LOG(&quot;failed to create file&quot;);</span>
<a href="#l26.154"></a><span id="l26.154">                 return false;</span>
<a href="#l26.155"></a><span id="l26.155">             }</span>
<a href="#l26.156"></a><span id="l26.156"> </span>
<a href="#l26.157"></a><span id="l26.157" class="difflineminus">-            if (!rnp_key_store_g10_key_to_dst(key, &amp;keydst)) {</span>
<a href="#l26.158"></a><span id="l26.158" class="difflineplus">+            if (!rnp_key_store_g10_key_to_dst(&amp;key, &amp;keydst)) {</span>
<a href="#l26.159"></a><span id="l26.159">                 RNP_LOG(&quot;failed to write key to file&quot;);</span>
<a href="#l26.160"></a><span id="l26.160">                 dst_close(&amp;keydst, true);</span>
<a href="#l26.161"></a><span id="l26.161">                 return false;</span>
<a href="#l26.162"></a><span id="l26.162">             }</span>
<a href="#l26.163"></a><span id="l26.163"> </span>
<a href="#l26.164"></a><span id="l26.164">             rc = dst_finish(&amp;keydst) == RNP_SUCCESS;</span>
<a href="#l26.165"></a><span id="l26.165">             dst_close(&amp;keydst, !rc);</span>
<a href="#l26.166"></a><span id="l26.166"> </span>
<a href="#l26.167"></a><span id="l26.167" class="difflineat">@@ -204,17 +185,17 @@ rnp_key_store_write_to_path(rnp_key_stor</span>
<a href="#l26.168"></a><span id="l26.168">                 return false;</span>
<a href="#l26.169"></a><span id="l26.169">             }</span>
<a href="#l26.170"></a><span id="l26.170">         }</span>
<a href="#l26.171"></a><span id="l26.171"> </span>
<a href="#l26.172"></a><span id="l26.172">         return true;</span>
<a href="#l26.173"></a><span id="l26.173">     }</span>
<a href="#l26.174"></a><span id="l26.174"> </span>
<a href="#l26.175"></a><span id="l26.175">     /* write kbx/gpg store to the single file */</span>
<a href="#l26.176"></a><span id="l26.176" class="difflineminus">-    if (init_tmpfile_dest(&amp;keydst, key_store-&gt;path, true)) {</span>
<a href="#l26.177"></a><span id="l26.177" class="difflineplus">+    if (init_tmpfile_dest(&amp;keydst, key_store-&gt;path.c_str(), true)) {</span>
<a href="#l26.178"></a><span id="l26.178">         RNP_LOG(&quot;failed to create keystore file&quot;);</span>
<a href="#l26.179"></a><span id="l26.179">         return false;</span>
<a href="#l26.180"></a><span id="l26.180">     }</span>
<a href="#l26.181"></a><span id="l26.181"> </span>
<a href="#l26.182"></a><span id="l26.182">     if (!rnp_key_store_write_to_dst(key_store, &amp;keydst)) {</span>
<a href="#l26.183"></a><span id="l26.183">         RNP_LOG(&quot;failed to write keys to file&quot;);</span>
<a href="#l26.184"></a><span id="l26.184">         dst_close(&amp;keydst, true);</span>
<a href="#l26.185"></a><span id="l26.185">         return false;</span>
<a href="#l26.186"></a><span id="l26.186" class="difflineat">@@ -238,60 +219,33 @@ rnp_key_store_write_to_dst(rnp_key_store</span>
<a href="#l26.187"></a><span id="l26.187">     }</span>
<a href="#l26.188"></a><span id="l26.188"> </span>
<a href="#l26.189"></a><span id="l26.189">     return false;</span>
<a href="#l26.190"></a><span id="l26.190"> }</span>
<a href="#l26.191"></a><span id="l26.191"> </span>
<a href="#l26.192"></a><span id="l26.192"> void</span>
<a href="#l26.193"></a><span id="l26.193"> rnp_key_store_clear(rnp_key_store_t *keyring)</span>
<a href="#l26.194"></a><span id="l26.194"> {</span>
<a href="#l26.195"></a><span id="l26.195" class="difflineminus">-    for (list_item *key = list_front(keyring-&gt;keys); key; key = list_next(key)) {</span>
<a href="#l26.196"></a><span id="l26.196" class="difflineminus">-        ((pgp_key_t *) key)-&gt;~pgp_key_t();</span>
<a href="#l26.197"></a><span id="l26.197" class="difflineminus">-    }</span>
<a href="#l26.198"></a><span id="l26.198" class="difflineminus">-    list_destroy(&amp;keyring-&gt;keys);</span>
<a href="#l26.199"></a><span id="l26.199" class="difflineminus">-</span>
<a href="#l26.200"></a><span id="l26.200" class="difflineplus">+    keyring-&gt;keybygrip.clear();</span>
<a href="#l26.201"></a><span id="l26.201" class="difflineplus">+    keyring-&gt;keys.clear();</span>
<a href="#l26.202"></a><span id="l26.202">     for (list_item *item = list_front(keyring-&gt;blobs); item; item = list_next(item)) {</span>
<a href="#l26.203"></a><span id="l26.203">         kbx_blob_t *blob = *((kbx_blob_t **) item);</span>
<a href="#l26.204"></a><span id="l26.204">         if (blob-&gt;type == KBX_PGP_BLOB) {</span>
<a href="#l26.205"></a><span id="l26.205">             kbx_pgp_blob_t *pgpblob = (kbx_pgp_blob_t *) blob;</span>
<a href="#l26.206"></a><span id="l26.206">             free_kbx_pgp_blob(pgpblob);</span>
<a href="#l26.207"></a><span id="l26.207">         }</span>
<a href="#l26.208"></a><span id="l26.208">         free(blob);</span>
<a href="#l26.209"></a><span id="l26.209">     }</span>
<a href="#l26.210"></a><span id="l26.210">     list_destroy(&amp;keyring-&gt;blobs);</span>
<a href="#l26.211"></a><span id="l26.211"> }</span>
<a href="#l26.212"></a><span id="l26.212"> </span>
<a href="#l26.213"></a><span id="l26.213" class="difflineminus">-void</span>
<a href="#l26.214"></a><span id="l26.214" class="difflineminus">-rnp_key_store_free(rnp_key_store_t *keyring)</span>
<a href="#l26.215"></a><span id="l26.215" class="difflineminus">-{</span>
<a href="#l26.216"></a><span id="l26.216" class="difflineminus">-    if (keyring == NULL) {</span>
<a href="#l26.217"></a><span id="l26.217" class="difflineminus">-        return;</span>
<a href="#l26.218"></a><span id="l26.218" class="difflineminus">-    }</span>
<a href="#l26.219"></a><span id="l26.219" class="difflineminus">-</span>
<a href="#l26.220"></a><span id="l26.220" class="difflineminus">-    rnp_key_store_clear(keyring);</span>
<a href="#l26.221"></a><span id="l26.221" class="difflineminus">-    free((void *) keyring-&gt;path);</span>
<a href="#l26.222"></a><span id="l26.222" class="difflineminus">-    free(keyring);</span>
<a href="#l26.223"></a><span id="l26.223" class="difflineminus">-}</span>
<a href="#l26.224"></a><span id="l26.224" class="difflineminus">-</span>
<a href="#l26.225"></a><span id="l26.225"> size_t</span>
<a href="#l26.226"></a><span id="l26.226"> rnp_key_store_get_key_count(const rnp_key_store_t *keyring)</span>
<a href="#l26.227"></a><span id="l26.227"> {</span>
<a href="#l26.228"></a><span id="l26.228" class="difflineminus">-    return list_length(keyring-&gt;keys);</span>
<a href="#l26.229"></a><span id="l26.229" class="difflineminus">-}</span>
<a href="#l26.230"></a><span id="l26.230" class="difflineminus">-</span>
<a href="#l26.231"></a><span id="l26.231" class="difflineminus">-pgp_key_t *</span>
<a href="#l26.232"></a><span id="l26.232" class="difflineminus">-rnp_key_store_get_key(const rnp_key_store_t *keyring, size_t idx)</span>
<a href="#l26.233"></a><span id="l26.233" class="difflineminus">-{</span>
<a href="#l26.234"></a><span id="l26.234" class="difflineminus">-    return (pgp_key_t *) list_at(keyring-&gt;keys, idx);</span>
<a href="#l26.235"></a><span id="l26.235" class="difflineminus">-}</span>
<a href="#l26.236"></a><span id="l26.236" class="difflineminus">-</span>
<a href="#l26.237"></a><span id="l26.237" class="difflineminus">-list</span>
<a href="#l26.238"></a><span id="l26.238" class="difflineminus">-rnp_key_store_get_keys(const rnp_key_store_t *keyring)</span>
<a href="#l26.239"></a><span id="l26.239" class="difflineminus">-{</span>
<a href="#l26.240"></a><span id="l26.240" class="difflineminus">-    return keyring-&gt;keys;</span>
<a href="#l26.241"></a><span id="l26.241" class="difflineplus">+    return keyring-&gt;keys.size();</span>
<a href="#l26.242"></a><span id="l26.242"> }</span>
<a href="#l26.243"></a><span id="l26.243"> </span>
<a href="#l26.244"></a><span id="l26.244"> static bool</span>
<a href="#l26.245"></a><span id="l26.245"> rnp_key_store_merge_subkey(pgp_key_t *dst, const pgp_key_t *src, pgp_key_t *primary)</span>
<a href="#l26.246"></a><span id="l26.246"> {</span>
<a href="#l26.247"></a><span id="l26.247">     pgp_transferable_subkey_t dstkey = {};</span>
<a href="#l26.248"></a><span id="l26.248">     pgp_transferable_subkey_t srckey = {};</span>
<a href="#l26.249"></a><span id="l26.249">     pgp_key_t                 tmpkey = {};</span>
<a href="#l26.250"></a><span id="l26.250" class="difflineat">@@ -391,20 +345,19 @@ rnp_key_store_merge_key(pgp_key_t *dst, </span>
<a href="#l26.251"></a><span id="l26.251">     }</span>
<a href="#l26.252"></a><span id="l26.252"> </span>
<a href="#l26.253"></a><span id="l26.253">     if (!rnp_key_from_transferable_key(&amp;tmpkey, &amp;dstkey)) {</span>
<a href="#l26.254"></a><span id="l26.254">         RNP_LOG(&quot;failed to process key&quot;);</span>
<a href="#l26.255"></a><span id="l26.255">         goto done;</span>
<a href="#l26.256"></a><span id="l26.256">     }</span>
<a href="#l26.257"></a><span id="l26.257"> </span>
<a href="#l26.258"></a><span id="l26.258">     /* move existing subkey grips since they are not present in transferable key */</span>
<a href="#l26.259"></a><span id="l26.259" class="difflineminus">-    tmpkey.subkey_grips = dst-&gt;subkey_grips;</span>
<a href="#l26.260"></a><span id="l26.260" class="difflineminus">-    dst-&gt;subkey_grips = NULL;</span>
<a href="#l26.261"></a><span id="l26.261" class="difflineminus">-    for (list_item *li = list_front(src-&gt;subkey_grips); li; li = list_next(li)) {</span>
<a href="#l26.262"></a><span id="l26.262" class="difflineminus">-        if (!pgp_key_add_subkey_grip(&amp;tmpkey, (uint8_t *) li)) {</span>
<a href="#l26.263"></a><span id="l26.263" class="difflineplus">+    tmpkey.subkey_grips = std::move(dst-&gt;subkey_grips);</span>
<a href="#l26.264"></a><span id="l26.264" class="difflineplus">+    for (auto &amp;grip : src-&gt;subkey_grips) {</span>
<a href="#l26.265"></a><span id="l26.265" class="difflineplus">+        if (!pgp_key_add_subkey_grip(&amp;tmpkey, grip)) {</span>
<a href="#l26.266"></a><span id="l26.266">             RNP_LOG(&quot;failed to add subkey grip&quot;);</span>
<a href="#l26.267"></a><span id="l26.267">         }</span>
<a href="#l26.268"></a><span id="l26.268">     }</span>
<a href="#l26.269"></a><span id="l26.269">     /* check whether key was unlocked and assign secret key data */</span>
<a href="#l26.270"></a><span id="l26.270">     if (pgp_key_is_secret(dst) &amp;&amp; !pgp_key_is_locked(dst)) {</span>
<a href="#l26.271"></a><span id="l26.271">         /* we may do thing below only because key material is opaque structure without</span>
<a href="#l26.272"></a><span id="l26.272">          * pointers! */</span>
<a href="#l26.273"></a><span id="l26.273">         tmpkey.pkt.material = dst-&gt;pkt.material;</span>
<a href="#l26.274"></a><span id="l26.274" class="difflineat">@@ -432,27 +385,26 @@ rnp_key_store_refresh_subkey_grips(rnp_k</span>
<a href="#l26.275"></a><span id="l26.275">     uint8_t           keyid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l26.276"></a><span id="l26.276">     pgp_fingerprint_t keyfp = {};</span>
<a href="#l26.277"></a><span id="l26.277"> </span>
<a href="#l26.278"></a><span id="l26.278">     if (pgp_key_is_subkey(key)) {</span>
<a href="#l26.279"></a><span id="l26.279">         RNP_LOG(&quot;wrong argument&quot;);</span>
<a href="#l26.280"></a><span id="l26.280">         return false;</span>
<a href="#l26.281"></a><span id="l26.281">     }</span>
<a href="#l26.282"></a><span id="l26.282"> </span>
<a href="#l26.283"></a><span id="l26.283" class="difflineminus">-    for (list_item *ki = list_front(rnp_key_store_get_keys(keyring)); ki; ki = list_next(ki)) {</span>
<a href="#l26.284"></a><span id="l26.284" class="difflineminus">-        pgp_key_t *skey = (pgp_key_t *) ki;</span>
<a href="#l26.285"></a><span id="l26.285" class="difflineminus">-        bool       found = false;</span>
<a href="#l26.286"></a><span id="l26.286" class="difflineplus">+    for (auto &amp;skey : keyring-&gt;keys) {</span>
<a href="#l26.287"></a><span id="l26.287" class="difflineplus">+        bool found = false;</span>
<a href="#l26.288"></a><span id="l26.288"> </span>
<a href="#l26.289"></a><span id="l26.289">         /* if we have primary_grip then we also added to subkey_grips */</span>
<a href="#l26.290"></a><span id="l26.290" class="difflineminus">-        if (!pgp_key_is_subkey(skey) || pgp_key_get_primary_grip(skey)) {</span>
<a href="#l26.291"></a><span id="l26.291" class="difflineplus">+        if (!pgp_key_is_subkey(&amp;skey) || pgp_key_has_primary_grip(&amp;skey)) {</span>
<a href="#l26.292"></a><span id="l26.292">             continue;</span>
<a href="#l26.293"></a><span id="l26.293">         }</span>
<a href="#l26.294"></a><span id="l26.294"> </span>
<a href="#l26.295"></a><span id="l26.295" class="difflineminus">-        for (unsigned i = 0; i &lt; pgp_key_get_subsig_count(skey); i++) {</span>
<a href="#l26.296"></a><span id="l26.296" class="difflineminus">-            const pgp_subsig_t *subsig = pgp_key_get_subsig(skey, i);</span>
<a href="#l26.297"></a><span id="l26.297" class="difflineplus">+        for (unsigned i = 0; i &lt; pgp_key_get_subsig_count(&amp;skey); i++) {</span>
<a href="#l26.298"></a><span id="l26.298" class="difflineplus">+            const pgp_subsig_t *subsig = pgp_key_get_subsig(&amp;skey, i);</span>
<a href="#l26.299"></a><span id="l26.299"> </span>
<a href="#l26.300"></a><span id="l26.300">             if (subsig-&gt;sig.type != PGP_SIG_SUBKEY) {</span>
<a href="#l26.301"></a><span id="l26.301">                 continue;</span>
<a href="#l26.302"></a><span id="l26.302">             }</span>
<a href="#l26.303"></a><span id="l26.303"> </span>
<a href="#l26.304"></a><span id="l26.304">             if (signature_get_keyfp(&amp;subsig-&gt;sig, &amp;keyfp) &amp;&amp;</span>
<a href="#l26.305"></a><span id="l26.305">                 fingerprint_equal(pgp_key_get_fp(key), &amp;keyfp)) {</span>
<a href="#l26.306"></a><span id="l26.306">                 found = true;</span>
<a href="#l26.307"></a><span id="l26.307" class="difflineat">@@ -461,17 +413,17 @@ rnp_key_store_refresh_subkey_grips(rnp_k</span>
<a href="#l26.308"></a><span id="l26.308"> </span>
<a href="#l26.309"></a><span id="l26.309">             if (signature_get_keyid(&amp;subsig-&gt;sig, keyid) &amp;&amp;</span>
<a href="#l26.310"></a><span id="l26.310">                 !memcmp(pgp_key_get_keyid(key), keyid, PGP_KEY_ID_SIZE)) {</span>
<a href="#l26.311"></a><span id="l26.311">                 found = true;</span>
<a href="#l26.312"></a><span id="l26.312">                 break;</span>
<a href="#l26.313"></a><span id="l26.313">             }</span>
<a href="#l26.314"></a><span id="l26.314">         }</span>
<a href="#l26.315"></a><span id="l26.315"> </span>
<a href="#l26.316"></a><span id="l26.316" class="difflineminus">-        if (found &amp;&amp; !pgp_key_link_subkey_grip(key, skey)) {</span>
<a href="#l26.317"></a><span id="l26.317" class="difflineplus">+        if (found &amp;&amp; !pgp_key_link_subkey_grip(key, &amp;skey)) {</span>
<a href="#l26.318"></a><span id="l26.318">             return false;</span>
<a href="#l26.319"></a><span id="l26.319">         }</span>
<a href="#l26.320"></a><span id="l26.320">     }</span>
<a href="#l26.321"></a><span id="l26.321"> </span>
<a href="#l26.322"></a><span id="l26.322">     return true;</span>
<a href="#l26.323"></a><span id="l26.323"> }</span>
<a href="#l26.324"></a><span id="l26.324"> </span>
<a href="#l26.325"></a><span id="l26.325"> static pgp_key_t *</span>
<a href="#l26.326"></a><span id="l26.326" class="difflineat">@@ -484,24 +436,28 @@ rnp_key_store_add_subkey(rnp_key_store_t</span>
<a href="#l26.327"></a><span id="l26.327"> </span>
<a href="#l26.328"></a><span id="l26.328">     if (oldkey) {</span>
<a href="#l26.329"></a><span id="l26.329">         /* in case we already have key let's merge it in */</span>
<a href="#l26.330"></a><span id="l26.330">         if (!rnp_key_store_merge_subkey(oldkey, srckey, primary)) {</span>
<a href="#l26.331"></a><span id="l26.331">             RNP_LOG(&quot;failed to merge subkey&quot;);</span>
<a href="#l26.332"></a><span id="l26.332">             return NULL;</span>
<a href="#l26.333"></a><span id="l26.333">         }</span>
<a href="#l26.334"></a><span id="l26.334">     } else {</span>
<a href="#l26.335"></a><span id="l26.335" class="difflineminus">-        oldkey = (pgp_key_t *) list_append(&amp;keyring-&gt;keys, NULL, sizeof(*srckey));</span>
<a href="#l26.336"></a><span id="l26.336" class="difflineminus">-        if (!oldkey) {</span>
<a href="#l26.337"></a><span id="l26.337" class="difflineminus">-            RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l26.338"></a><span id="l26.338" class="difflineplus">+        try {</span>
<a href="#l26.339"></a><span id="l26.339" class="difflineplus">+            keyring-&gt;keys.emplace_back();</span>
<a href="#l26.340"></a><span id="l26.340" class="difflineplus">+            oldkey = &amp;keyring-&gt;keys.back();</span>
<a href="#l26.341"></a><span id="l26.341" class="difflineplus">+            keyring-&gt;keybygrip[pgp_key_get_grip(srckey)] = std::prev(keyring-&gt;keys.end());</span>
<a href="#l26.342"></a><span id="l26.342" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l26.343"></a><span id="l26.343" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l26.344"></a><span id="l26.344">             return NULL;</span>
<a href="#l26.345"></a><span id="l26.345">         }</span>
<a href="#l26.346"></a><span id="l26.346">         if (pgp_key_copy(oldkey, srckey, false)) {</span>
<a href="#l26.347"></a><span id="l26.347">             RNP_LOG(&quot;key copying failed&quot;);</span>
<a href="#l26.348"></a><span id="l26.348" class="difflineminus">-            list_remove((list_item *) oldkey);</span>
<a href="#l26.349"></a><span id="l26.349" class="difflineplus">+            keyring-&gt;keys.pop_back();</span>
<a href="#l26.350"></a><span id="l26.350" class="difflineplus">+            keyring-&gt;keybygrip.erase(pgp_key_get_grip(srckey));</span>
<a href="#l26.351"></a><span id="l26.351">             return NULL;</span>
<a href="#l26.352"></a><span id="l26.352">         }</span>
<a href="#l26.353"></a><span id="l26.353">         if (primary &amp;&amp; !pgp_key_link_subkey_grip(primary, oldkey)) {</span>
<a href="#l26.354"></a><span id="l26.354">             RNP_LOG(&quot;failed to link subkey grip&quot;);</span>
<a href="#l26.355"></a><span id="l26.355">         }</span>
<a href="#l26.356"></a><span id="l26.356">     }</span>
<a href="#l26.357"></a><span id="l26.357"> </span>
<a href="#l26.358"></a><span id="l26.358">     RNP_DLOG(&quot;keyc %lu&quot;, (long unsigned) rnp_key_store_get_key_count(keyring));</span>
<a href="#l26.359"></a><span id="l26.359" class="difflineat">@@ -531,24 +487,28 @@ rnp_key_store_add_key(rnp_key_store_t *k</span>
<a href="#l26.360"></a><span id="l26.360">     }</span>
<a href="#l26.361"></a><span id="l26.361"> </span>
<a href="#l26.362"></a><span id="l26.362">     if (added_key) {</span>
<a href="#l26.363"></a><span id="l26.363">         if (!rnp_key_store_merge_key(added_key, srckey)) {</span>
<a href="#l26.364"></a><span id="l26.364">             RNP_LOG(&quot;failed to merge key&quot;);</span>
<a href="#l26.365"></a><span id="l26.365">             return NULL;</span>
<a href="#l26.366"></a><span id="l26.366">         }</span>
<a href="#l26.367"></a><span id="l26.367">     } else {</span>
<a href="#l26.368"></a><span id="l26.368" class="difflineminus">-        added_key = (pgp_key_t *) list_append(&amp;keyring-&gt;keys, NULL, sizeof(*srckey));</span>
<a href="#l26.369"></a><span id="l26.369" class="difflineminus">-        if (!added_key) {</span>
<a href="#l26.370"></a><span id="l26.370" class="difflineminus">-            RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l26.371"></a><span id="l26.371" class="difflineplus">+        try {</span>
<a href="#l26.372"></a><span id="l26.372" class="difflineplus">+            keyring-&gt;keys.emplace_back();</span>
<a href="#l26.373"></a><span id="l26.373" class="difflineplus">+            added_key = &amp;keyring-&gt;keys.back();</span>
<a href="#l26.374"></a><span id="l26.374" class="difflineplus">+            keyring-&gt;keybygrip[pgp_key_get_grip(srckey)] = std::prev(keyring-&gt;keys.end());</span>
<a href="#l26.375"></a><span id="l26.375" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l26.376"></a><span id="l26.376" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l26.377"></a><span id="l26.377">             return NULL;</span>
<a href="#l26.378"></a><span id="l26.378">         }</span>
<a href="#l26.379"></a><span id="l26.379">         if (pgp_key_copy(added_key, srckey, false)) {</span>
<a href="#l26.380"></a><span id="l26.380">             RNP_LOG(&quot;key copying failed&quot;);</span>
<a href="#l26.381"></a><span id="l26.381" class="difflineminus">-            list_remove((list_item *) added_key);</span>
<a href="#l26.382"></a><span id="l26.382" class="difflineplus">+            keyring-&gt;keys.pop_back();</span>
<a href="#l26.383"></a><span id="l26.383" class="difflineplus">+            keyring-&gt;keybygrip.erase(pgp_key_get_grip(srckey));</span>
<a href="#l26.384"></a><span id="l26.384">             return NULL;</span>
<a href="#l26.385"></a><span id="l26.385">         }</span>
<a href="#l26.386"></a><span id="l26.386">         /* primary key may be added after subkeys, so let's handle this case correctly */</span>
<a href="#l26.387"></a><span id="l26.387">         if (!rnp_key_store_refresh_subkey_grips(keyring, added_key)) {</span>
<a href="#l26.388"></a><span id="l26.388">             RNP_LOG(&quot;failed to refresh subkey grips&quot;);</span>
<a href="#l26.389"></a><span id="l26.389">         }</span>
<a href="#l26.390"></a><span id="l26.390">     }</span>
<a href="#l26.391"></a><span id="l26.391"> </span>
<a href="#l26.392"></a><span id="l26.392" class="difflineat">@@ -622,23 +582,22 @@ static pgp_sig_import_status_t</span>
<a href="#l26.393"></a><span id="l26.393"> rnp_key_store_import_subkey_signature(rnp_key_store_t *      keyring,</span>
<a href="#l26.394"></a><span id="l26.394">                                       pgp_key_t *            key,</span>
<a href="#l26.395"></a><span id="l26.395">                                       const pgp_signature_t *sig)</span>
<a href="#l26.396"></a><span id="l26.396"> {</span>
<a href="#l26.397"></a><span id="l26.397">     pgp_sig_type_t sigtype = signature_get_type(sig);</span>
<a href="#l26.398"></a><span id="l26.398">     if ((sigtype != PGP_SIG_SUBKEY) &amp;&amp; (sigtype != PGP_SIG_REV_SUBKEY)) {</span>
<a href="#l26.399"></a><span id="l26.399">         return PGP_SIG_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l26.400"></a><span id="l26.400">     }</span>
<a href="#l26.401"></a><span id="l26.401" class="difflineminus">-    const uint8_t *prim_grip = pgp_key_get_primary_grip(key);</span>
<a href="#l26.402"></a><span id="l26.402" class="difflineminus">-    pgp_key_t *    primary = rnp_key_store_get_signer_key(keyring, sig);</span>
<a href="#l26.403"></a><span id="l26.403" class="difflineminus">-    if (!prim_grip || !primary) {</span>
<a href="#l26.404"></a><span id="l26.404" class="difflineplus">+    pgp_key_t *primary = rnp_key_store_get_signer_key(keyring, sig);</span>
<a href="#l26.405"></a><span id="l26.405" class="difflineplus">+    if (!primary || !pgp_key_has_primary_grip(key)) {</span>
<a href="#l26.406"></a><span id="l26.406">         RNP_LOG(&quot;No primary grip or primary key&quot;);</span>
<a href="#l26.407"></a><span id="l26.407">         return PGP_SIG_IMPORT_STATUS_UNKNOWN_KEY;</span>
<a href="#l26.408"></a><span id="l26.408">     }</span>
<a href="#l26.409"></a><span id="l26.409" class="difflineminus">-    if (memcmp(pgp_key_get_grip(primary), prim_grip, PGP_KEY_GRIP_SIZE)) {</span>
<a href="#l26.410"></a><span id="l26.410" class="difflineplus">+    if (pgp_key_get_grip(primary) != pgp_key_get_primary_grip(key)) {</span>
<a href="#l26.411"></a><span id="l26.411">         RNP_LOG(&quot;Wrong subkey signature's signer.&quot;);</span>
<a href="#l26.412"></a><span id="l26.412">         return PGP_SIG_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l26.413"></a><span id="l26.413">     }</span>
<a href="#l26.414"></a><span id="l26.414"> </span>
<a href="#l26.415"></a><span id="l26.415">     pgp_key_t tmpkey = {};</span>
<a href="#l26.416"></a><span id="l26.416">     if (!pgp_key_from_pkt(&amp;tmpkey, &amp;key-&gt;pkt) || !rnp_key_add_signature(&amp;tmpkey, sig) ||</span>
<a href="#l26.417"></a><span id="l26.417">         !pgp_subkey_refresh_data(&amp;tmpkey, primary)) {</span>
<a href="#l26.418"></a><span id="l26.418">         RNP_LOG(&quot;Failed to add signature to the key.&quot;);</span>
<a href="#l26.419"></a><span id="l26.419" class="difflineat">@@ -710,23 +669,23 @@ rnp_key_store_import_signature(rnp_key_s</span>
<a href="#l26.420"></a><span id="l26.420">     }</span>
<a href="#l26.421"></a><span id="l26.421">     *status = rnp_key_store_import_key_signature(keyring, res_key, sig);</span>
<a href="#l26.422"></a><span id="l26.422">     return res_key;</span>
<a href="#l26.423"></a><span id="l26.423"> }</span>
<a href="#l26.424"></a><span id="l26.424"> </span>
<a href="#l26.425"></a><span id="l26.425"> bool</span>
<a href="#l26.426"></a><span id="l26.426"> rnp_key_store_remove_key(rnp_key_store_t *keyring, const pgp_key_t *key)</span>
<a href="#l26.427"></a><span id="l26.427"> {</span>
<a href="#l26.428"></a><span id="l26.428" class="difflineminus">-    // check if we were passed a key that isn't from this ring</span>
<a href="#l26.429"></a><span id="l26.429" class="difflineminus">-    if (!list_is_member(keyring-&gt;keys, (list_item *) key)) {</span>
<a href="#l26.430"></a><span id="l26.430" class="difflineminus">-        return false;</span>
<a href="#l26.431"></a><span id="l26.431" class="difflineminus">-    }</span>
<a href="#l26.432"></a><span id="l26.432" class="difflineminus">-    key-&gt;~pgp_key_t();</span>
<a href="#l26.433"></a><span id="l26.433" class="difflineminus">-    list_remove((list_item *) key);</span>
<a href="#l26.434"></a><span id="l26.434" class="difflineminus">-    return true;</span>
<a href="#l26.435"></a><span id="l26.435" class="difflineplus">+    keyring-&gt;keybygrip.erase(pgp_key_get_grip(key));</span>
<a href="#l26.436"></a><span id="l26.436" class="difflineplus">+    size_t oldsize = keyring-&gt;keys.size();</span>
<a href="#l26.437"></a><span id="l26.437" class="difflineplus">+    keyring-&gt;keys.erase(std::remove_if(keyring-&gt;keys.begin(),</span>
<a href="#l26.438"></a><span id="l26.438" class="difflineplus">+                                       keyring-&gt;keys.end(),</span>
<a href="#l26.439"></a><span id="l26.439" class="difflineplus">+                                       [key](pgp_key_t &amp;_key) { return key == &amp;_key; }));</span>
<a href="#l26.440"></a><span id="l26.440" class="difflineplus">+</span>
<a href="#l26.441"></a><span id="l26.441" class="difflineplus">+    return oldsize != keyring-&gt;keys.size();</span>
<a href="#l26.442"></a><span id="l26.442"> }</span>
<a href="#l26.443"></a><span id="l26.443"> </span>
<a href="#l26.444"></a><span id="l26.444"> /**</span>
<a href="#l26.445"></a><span id="l26.445">    \ingroup HighLevel_KeyringFind</span>
<a href="#l26.446"></a><span id="l26.446"> </span>
<a href="#l26.447"></a><span id="l26.447">    \brief Finds key in keyring from its Key ID</span>
<a href="#l26.448"></a><span id="l26.448"> </span>
<a href="#l26.449"></a><span id="l26.449">    \param keyring Keyring to be searched</span>
<a href="#l26.450"></a><span id="l26.450" class="difflineat">@@ -734,89 +693,84 @@ rnp_key_store_remove_key(rnp_key_store_t</span>
<a href="#l26.451"></a><span id="l26.451"> </span>
<a href="#l26.452"></a><span id="l26.452">    \return Pointer to key, if found; NULL, if not found</span>
<a href="#l26.453"></a><span id="l26.453"> </span>
<a href="#l26.454"></a><span id="l26.454">    \note This returns a pointer to the key inside the given keyring,</span>
<a href="#l26.455"></a><span id="l26.455">    not a copy.  Do not free it after use.</span>
<a href="#l26.456"></a><span id="l26.456"> </span>
<a href="#l26.457"></a><span id="l26.457"> */</span>
<a href="#l26.458"></a><span id="l26.458"> pgp_key_t *</span>
<a href="#l26.459"></a><span id="l26.459" class="difflineminus">-rnp_key_store_get_key_by_id(const rnp_key_store_t *keyring,</span>
<a href="#l26.460"></a><span id="l26.460" class="difflineminus">-                            const uint8_t *        keyid,</span>
<a href="#l26.461"></a><span id="l26.461" class="difflineminus">-                            pgp_key_t *            after)</span>
<a href="#l26.462"></a><span id="l26.462" class="difflineplus">+rnp_key_store_get_key_by_id(rnp_key_store_t *keyring, const uint8_t *keyid, pgp_key_t *after)</span>
<a href="#l26.463"></a><span id="l26.463"> {</span>
<a href="#l26.464"></a><span id="l26.464">     RNP_DLOG(&quot;searching keyring %p&quot;, keyring);</span>
<a href="#l26.465"></a><span id="l26.465" class="difflineminus">-</span>
<a href="#l26.466"></a><span id="l26.466">     if (!keyring) {</span>
<a href="#l26.467"></a><span id="l26.467">         return NULL;</span>
<a href="#l26.468"></a><span id="l26.468">     }</span>
<a href="#l26.469"></a><span id="l26.469"> </span>
<a href="#l26.470"></a><span id="l26.470" class="difflineminus">-    // if after is provided, make sure it is a member of the appropriate list</span>
<a href="#l26.471"></a><span id="l26.471" class="difflineminus">-    assert(!after || list_is_member(keyring-&gt;keys, (list_item *) after));</span>
<a href="#l26.472"></a><span id="l26.472" class="difflineplus">+    auto it =</span>
<a href="#l26.473"></a><span id="l26.473" class="difflineplus">+      std::find_if(keyring-&gt;keys.begin(), keyring-&gt;keys.end(), [after](const pgp_key_t &amp;key) {</span>
<a href="#l26.474"></a><span id="l26.474" class="difflineplus">+          return !after || (after == &amp;key);</span>
<a href="#l26.475"></a><span id="l26.475" class="difflineplus">+      });</span>
<a href="#l26.476"></a><span id="l26.476" class="difflineplus">+    if (after &amp;&amp; (it == keyring-&gt;keys.end())) {</span>
<a href="#l26.477"></a><span id="l26.477" class="difflineplus">+        RNP_LOG(&quot;searching with non-keyrings after param&quot;);</span>
<a href="#l26.478"></a><span id="l26.478" class="difflineplus">+        return NULL;</span>
<a href="#l26.479"></a><span id="l26.479" class="difflineplus">+    }</span>
<a href="#l26.480"></a><span id="l26.480" class="difflineplus">+    if (after) {</span>
<a href="#l26.481"></a><span id="l26.481" class="difflineplus">+        it = std::next(it);</span>
<a href="#l26.482"></a><span id="l26.482" class="difflineplus">+    }</span>
<a href="#l26.483"></a><span id="l26.483" class="difflineplus">+    it = std::find_if(it, keyring-&gt;keys.end(), [keyid](const pgp_key_t &amp;key) {</span>
<a href="#l26.484"></a><span id="l26.484" class="difflineplus">+        return !memcmp(pgp_key_get_keyid(&amp;key), keyid, PGP_KEY_ID_SIZE) ||</span>
<a href="#l26.485"></a><span id="l26.485" class="difflineplus">+               !memcmp(</span>
<a href="#l26.486"></a><span id="l26.486" class="difflineplus">+                 pgp_key_get_keyid(&amp;key) + PGP_KEY_ID_SIZE / 2, keyid, PGP_KEY_ID_SIZE / 2);</span>
<a href="#l26.487"></a><span id="l26.487" class="difflineplus">+    });</span>
<a href="#l26.488"></a><span id="l26.488" class="difflineplus">+    return (it == keyring-&gt;keys.end()) ? NULL : &amp;(*it);</span>
<a href="#l26.489"></a><span id="l26.489" class="difflineplus">+}</span>
<a href="#l26.490"></a><span id="l26.490"> </span>
<a href="#l26.491"></a><span id="l26.491" class="difflineminus">-    for (list_item *key_item = after ? list_next((list_item *) after) :</span>
<a href="#l26.492"></a><span id="l26.492" class="difflineminus">-                                       list_front(keyring-&gt;keys);</span>
<a href="#l26.493"></a><span id="l26.493" class="difflineminus">-         key_item;</span>
<a href="#l26.494"></a><span id="l26.494" class="difflineminus">-         key_item = list_next(key_item)) {</span>
<a href="#l26.495"></a><span id="l26.495" class="difflineminus">-        pgp_key_t *key = (pgp_key_t *) key_item;</span>
<a href="#l26.496"></a><span id="l26.496" class="difflineminus">-        RNP_DHEX(&quot;keyring keyid&quot;, pgp_key_get_keyid(key), PGP_KEY_ID_SIZE);</span>
<a href="#l26.497"></a><span id="l26.497" class="difflineminus">-        RNP_DHEX(&quot;keyid&quot;, keyid, PGP_KEY_ID_SIZE);</span>
<a href="#l26.498"></a><span id="l26.498" class="difflineminus">-        if (memcmp(pgp_key_get_keyid(key), keyid, PGP_KEY_ID_SIZE) == 0 ||</span>
<a href="#l26.499"></a><span id="l26.499" class="difflineminus">-            memcmp(pgp_key_get_keyid(key) + PGP_KEY_ID_SIZE / 2, keyid, PGP_KEY_ID_SIZE / 2) ==</span>
<a href="#l26.500"></a><span id="l26.500" class="difflineminus">-              0) {</span>
<a href="#l26.501"></a><span id="l26.501" class="difflineminus">-            return key;</span>
<a href="#l26.502"></a><span id="l26.502" class="difflineminus">-        }</span>
<a href="#l26.503"></a><span id="l26.503" class="difflineplus">+const pgp_key_t *</span>
<a href="#l26.504"></a><span id="l26.504" class="difflineplus">+rnp_key_store_get_key_by_grip(const rnp_key_store_t *keyring, const pgp_key_grip_t &amp;grip)</span>
<a href="#l26.505"></a><span id="l26.505" class="difflineplus">+{</span>
<a href="#l26.506"></a><span id="l26.506" class="difflineplus">+    try {</span>
<a href="#l26.507"></a><span id="l26.507" class="difflineplus">+        return &amp;*keyring-&gt;keybygrip.at(grip);</span>
<a href="#l26.508"></a><span id="l26.508" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l26.509"></a><span id="l26.509" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l26.510"></a><span id="l26.510" class="difflineplus">+        return NULL;</span>
<a href="#l26.511"></a><span id="l26.511">     }</span>
<a href="#l26.512"></a><span id="l26.512" class="difflineminus">-    return NULL;</span>
<a href="#l26.513"></a><span id="l26.513"> }</span>
<a href="#l26.514"></a><span id="l26.514"> </span>
<a href="#l26.515"></a><span id="l26.515"> pgp_key_t *</span>
<a href="#l26.516"></a><span id="l26.516" class="difflineminus">-rnp_key_store_get_key_by_grip(const rnp_key_store_t *keyring, const uint8_t *grip)</span>
<a href="#l26.517"></a><span id="l26.517" class="difflineplus">+rnp_key_store_get_key_by_grip(rnp_key_store_t *keyring, const pgp_key_grip_t &amp;grip)</span>
<a href="#l26.518"></a><span id="l26.518"> {</span>
<a href="#l26.519"></a><span id="l26.519" class="difflineminus">-    RNP_DLOG(&quot;looking keyring %p&quot;, keyring);</span>
<a href="#l26.520"></a><span id="l26.520" class="difflineminus">-</span>
<a href="#l26.521"></a><span id="l26.521" class="difflineminus">-    if (!grip) {</span>
<a href="#l26.522"></a><span id="l26.522" class="difflineplus">+    auto it = keyring-&gt;keybygrip.find(grip);</span>
<a href="#l26.523"></a><span id="l26.523" class="difflineplus">+    if (it == keyring-&gt;keybygrip.end()) {</span>
<a href="#l26.524"></a><span id="l26.524">         return NULL;</span>
<a href="#l26.525"></a><span id="l26.525">     }</span>
<a href="#l26.526"></a><span id="l26.526" class="difflineminus">-</span>
<a href="#l26.527"></a><span id="l26.527" class="difflineminus">-    for (list_item *key_item = list_front(keyring-&gt;keys); key_item;</span>
<a href="#l26.528"></a><span id="l26.528" class="difflineminus">-         key_item = list_next(key_item)) {</span>
<a href="#l26.529"></a><span id="l26.529" class="difflineminus">-        pgp_key_t *key = (pgp_key_t *) key_item;</span>
<a href="#l26.530"></a><span id="l26.530" class="difflineminus">-        RNP_DHEX(&quot;looking for grip&quot;, grip, PGP_KEY_GRIP_SIZE);</span>
<a href="#l26.531"></a><span id="l26.531" class="difflineminus">-        RNP_DHEX(&quot;key grip&quot;, pgp_key_get_grip(key), PGP_KEY_GRIP_SIZE);</span>
<a href="#l26.532"></a><span id="l26.532" class="difflineminus">-</span>
<a href="#l26.533"></a><span id="l26.533" class="difflineminus">-        if (memcmp(pgp_key_get_grip(key), grip, PGP_KEY_GRIP_SIZE) == 0) {</span>
<a href="#l26.534"></a><span id="l26.534" class="difflineminus">-            return key;</span>
<a href="#l26.535"></a><span id="l26.535" class="difflineminus">-        }</span>
<a href="#l26.536"></a><span id="l26.536" class="difflineminus">-    }</span>
<a href="#l26.537"></a><span id="l26.537" class="difflineminus">-    return NULL;</span>
<a href="#l26.538"></a><span id="l26.538" class="difflineplus">+    return &amp;*it-&gt;second;</span>
<a href="#l26.539"></a><span id="l26.539"> }</span>
<a href="#l26.540"></a><span id="l26.540"> </span>
<a href="#l26.541"></a><span id="l26.541"> pgp_key_t *</span>
<a href="#l26.542"></a><span id="l26.542" class="difflineminus">-rnp_key_store_get_key_by_fpr(const rnp_key_store_t *keyring, const pgp_fingerprint_t *fpr)</span>
<a href="#l26.543"></a><span id="l26.543" class="difflineplus">+rnp_key_store_get_key_by_fpr(rnp_key_store_t *keyring, const pgp_fingerprint_t *fpr)</span>
<a href="#l26.544"></a><span id="l26.544"> {</span>
<a href="#l26.545"></a><span id="l26.545" class="difflineminus">-    for (list_item *key = list_front(keyring-&gt;keys); key; key = list_next(key)) {</span>
<a href="#l26.546"></a><span id="l26.546" class="difflineminus">-        if (fingerprint_equal(pgp_key_get_fp((pgp_key_t *) key), fpr)) {</span>
<a href="#l26.547"></a><span id="l26.547" class="difflineminus">-            return (pgp_key_t *) key;</span>
<a href="#l26.548"></a><span id="l26.548" class="difflineminus">-        }</span>
<a href="#l26.549"></a><span id="l26.549" class="difflineminus">-    }</span>
<a href="#l26.550"></a><span id="l26.550" class="difflineminus">-    return NULL;</span>
<a href="#l26.551"></a><span id="l26.551" class="difflineplus">+    auto it =</span>
<a href="#l26.552"></a><span id="l26.552" class="difflineplus">+      std::find_if(keyring-&gt;keys.begin(), keyring-&gt;keys.end(), [fpr](const pgp_key_t &amp;key) {</span>
<a href="#l26.553"></a><span id="l26.553" class="difflineplus">+          return fingerprint_equal(pgp_key_get_fp(&amp;key), fpr);</span>
<a href="#l26.554"></a><span id="l26.554" class="difflineplus">+      });</span>
<a href="#l26.555"></a><span id="l26.555" class="difflineplus">+    return (it == keyring-&gt;keys.end()) ? NULL : &amp;(*it);</span>
<a href="#l26.556"></a><span id="l26.556"> }</span>
<a href="#l26.557"></a><span id="l26.557"> </span>
<a href="#l26.558"></a><span id="l26.558"> pgp_key_t *</span>
<a href="#l26.559"></a><span id="l26.559" class="difflineminus">-rnp_key_store_get_primary_key(const rnp_key_store_t *keyring, const pgp_key_t *subkey)</span>
<a href="#l26.560"></a><span id="l26.560" class="difflineplus">+rnp_key_store_get_primary_key(rnp_key_store_t *keyring, const pgp_key_t *subkey)</span>
<a href="#l26.561"></a><span id="l26.561"> {</span>
<a href="#l26.562"></a><span id="l26.562">     uint8_t           keyid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l26.563"></a><span id="l26.563">     pgp_fingerprint_t keyfp = {};</span>
<a href="#l26.564"></a><span id="l26.564"> </span>
<a href="#l26.565"></a><span id="l26.565">     if (!pgp_key_is_subkey(subkey)) {</span>
<a href="#l26.566"></a><span id="l26.566">         return NULL;</span>
<a href="#l26.567"></a><span id="l26.567">     }</span>
<a href="#l26.568"></a><span id="l26.568"> </span>
<a href="#l26.569"></a><span id="l26.569" class="difflineminus">-    if (pgp_key_get_primary_grip(subkey)) {</span>
<a href="#l26.570"></a><span id="l26.570" class="difflineplus">+    if (pgp_key_has_primary_grip(subkey)) {</span>
<a href="#l26.571"></a><span id="l26.571">         return rnp_key_store_get_key_by_grip(keyring, pgp_key_get_primary_grip(subkey));</span>
<a href="#l26.572"></a><span id="l26.572">     }</span>
<a href="#l26.573"></a><span id="l26.573"> </span>
<a href="#l26.574"></a><span id="l26.574">     for (unsigned i = 0; i &lt; pgp_key_get_subsig_count(subkey); i++) {</span>
<a href="#l26.575"></a><span id="l26.575">         const pgp_subsig_t *subsig = pgp_key_get_subsig(subkey, i);</span>
<a href="#l26.576"></a><span id="l26.576">         if (subsig-&gt;sig.type != PGP_SIG_SUBKEY) {</span>
<a href="#l26.577"></a><span id="l26.577">             continue;</span>
<a href="#l26.578"></a><span id="l26.578">         }</span>
<a href="#l26.579"></a><span id="l26.579" class="difflineat">@@ -927,17 +881,17 @@ grip_hash_ec(pgp_hash_t *hash, const pgp</span>
<a href="#l26.580"></a><span id="l26.580">     } else {</span>
<a href="#l26.581"></a><span id="l26.581">         res &amp;= grip_hash_mpi(hash, &amp;key-&gt;p, 'q', false);</span>
<a href="#l26.582"></a><span id="l26.582">     }</span>
<a href="#l26.583"></a><span id="l26.583">     return res;</span>
<a href="#l26.584"></a><span id="l26.584"> }</span>
<a href="#l26.585"></a><span id="l26.585"> </span>
<a href="#l26.586"></a><span id="l26.586"> /* keygrip is subjectKeyHash from pkcs#15 for RSA. */</span>
<a href="#l26.587"></a><span id="l26.587"> bool</span>
<a href="#l26.588"></a><span id="l26.588" class="difflineminus">-rnp_key_store_get_key_grip(const pgp_key_material_t *key, uint8_t *grip)</span>
<a href="#l26.589"></a><span id="l26.589" class="difflineplus">+rnp_key_store_get_key_grip(const pgp_key_material_t *key, pgp_key_grip_t &amp;grip)</span>
<a href="#l26.590"></a><span id="l26.590"> {</span>
<a href="#l26.591"></a><span id="l26.591">     pgp_hash_t hash = {0};</span>
<a href="#l26.592"></a><span id="l26.592"> </span>
<a href="#l26.593"></a><span id="l26.593">     if (!pgp_hash_create(&amp;hash, PGP_HASH_SHA1)) {</span>
<a href="#l26.594"></a><span id="l26.594">         RNP_LOG(&quot;bad sha1 alloc&quot;);</span>
<a href="#l26.595"></a><span id="l26.595">         return false;</span>
<a href="#l26.596"></a><span id="l26.596">     }</span>
<a href="#l26.597"></a><span id="l26.597"> </span>
<a href="#l26.598"></a><span id="l26.598" class="difflineat">@@ -951,50 +905,72 @@ rnp_key_store_get_key_grip(const pgp_key</span>
<a href="#l26.599"></a><span id="l26.599">     case PGP_PKA_DSA:</span>
<a href="#l26.600"></a><span id="l26.600">         grip_hash_mpi(&amp;hash, &amp;key-&gt;dsa.p, 'p', true);</span>
<a href="#l26.601"></a><span id="l26.601">         grip_hash_mpi(&amp;hash, &amp;key-&gt;dsa.q, 'q', true);</span>
<a href="#l26.602"></a><span id="l26.602">         grip_hash_mpi(&amp;hash, &amp;key-&gt;dsa.g, 'g', true);</span>
<a href="#l26.603"></a><span id="l26.603">         grip_hash_mpi(&amp;hash, &amp;key-&gt;dsa.y, 'y', true);</span>
<a href="#l26.604"></a><span id="l26.604">         break;</span>
<a href="#l26.605"></a><span id="l26.605"> </span>
<a href="#l26.606"></a><span id="l26.606">     case PGP_PKA_ELGAMAL:</span>
<a href="#l26.607"></a><span id="l26.607" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l26.608"></a><span id="l26.608">         grip_hash_mpi(&amp;hash, &amp;key-&gt;eg.p, 'p', true);</span>
<a href="#l26.609"></a><span id="l26.609">         grip_hash_mpi(&amp;hash, &amp;key-&gt;eg.g, 'g', true);</span>
<a href="#l26.610"></a><span id="l26.610">         grip_hash_mpi(&amp;hash, &amp;key-&gt;eg.y, 'y', true);</span>
<a href="#l26.611"></a><span id="l26.611">         break;</span>
<a href="#l26.612"></a><span id="l26.612"> </span>
<a href="#l26.613"></a><span id="l26.613">     case PGP_PKA_ECDH:</span>
<a href="#l26.614"></a><span id="l26.614">     case PGP_PKA_ECDSA:</span>
<a href="#l26.615"></a><span id="l26.615">     case PGP_PKA_EDDSA:</span>
<a href="#l26.616"></a><span id="l26.616">     case PGP_PKA_SM2:</span>
<a href="#l26.617"></a><span id="l26.617">         if (!grip_hash_ec(&amp;hash, &amp;key-&gt;ec)) {</span>
<a href="#l26.618"></a><span id="l26.618" class="difflineminus">-            pgp_hash_finish(&amp;hash, grip);</span>
<a href="#l26.619"></a><span id="l26.619" class="difflineplus">+            pgp_hash_finish(&amp;hash, grip.data());</span>
<a href="#l26.620"></a><span id="l26.620">             return false;</span>
<a href="#l26.621"></a><span id="l26.621">         }</span>
<a href="#l26.622"></a><span id="l26.622">         break;</span>
<a href="#l26.623"></a><span id="l26.623"> </span>
<a href="#l26.624"></a><span id="l26.624">     default:</span>
<a href="#l26.625"></a><span id="l26.625">         RNP_LOG(&quot;unsupported public-key algorithm %d&quot;, (int) key-&gt;alg);</span>
<a href="#l26.626"></a><span id="l26.626" class="difflineminus">-        pgp_hash_finish(&amp;hash, grip);</span>
<a href="#l26.627"></a><span id="l26.627" class="difflineplus">+        pgp_hash_finish(&amp;hash, grip.data());</span>
<a href="#l26.628"></a><span id="l26.628">         return false;</span>
<a href="#l26.629"></a><span id="l26.629">     }</span>
<a href="#l26.630"></a><span id="l26.630"> </span>
<a href="#l26.631"></a><span id="l26.631" class="difflineminus">-    return pgp_hash_finish(&amp;hash, grip) == PGP_KEY_GRIP_SIZE;</span>
<a href="#l26.632"></a><span id="l26.632" class="difflineplus">+    return pgp_hash_finish(&amp;hash, grip.data()) == grip.size();</span>
<a href="#l26.633"></a><span id="l26.633"> }</span>
<a href="#l26.634"></a><span id="l26.634"> </span>
<a href="#l26.635"></a><span id="l26.635"> pgp_key_t *</span>
<a href="#l26.636"></a><span id="l26.636" class="difflineminus">-rnp_key_store_search(const rnp_key_store_t * keyring,</span>
<a href="#l26.637"></a><span id="l26.637" class="difflineplus">+rnp_key_store_search(rnp_key_store_t *       keyring,</span>
<a href="#l26.638"></a><span id="l26.638">                      const pgp_key_search_t *search,</span>
<a href="#l26.639"></a><span id="l26.639">                      pgp_key_t *             after)</span>
<a href="#l26.640"></a><span id="l26.640"> {</span>
<a href="#l26.641"></a><span id="l26.641">     // if after is provided, make sure it is a member of the appropriate list</span>
<a href="#l26.642"></a><span id="l26.642" class="difflineminus">-    assert(!after || list_is_member(keyring-&gt;keys, (list_item *) after));</span>
<a href="#l26.643"></a><span id="l26.643" class="difflineminus">-    for (list_item *key_item = after ? list_next((list_item *) after) :</span>
<a href="#l26.644"></a><span id="l26.644" class="difflineminus">-                                       list_front(keyring-&gt;keys);</span>
<a href="#l26.645"></a><span id="l26.645" class="difflineminus">-         key_item;</span>
<a href="#l26.646"></a><span id="l26.646" class="difflineminus">-         key_item = list_next(key_item)) {</span>
<a href="#l26.647"></a><span id="l26.647" class="difflineminus">-        pgp_key_t *key = (pgp_key_t *) key_item;</span>
<a href="#l26.648"></a><span id="l26.648" class="difflineminus">-        if (rnp_key_matches_search(key, search)) {</span>
<a href="#l26.649"></a><span id="l26.649" class="difflineminus">-            return key;</span>
<a href="#l26.650"></a><span id="l26.650" class="difflineminus">-        }</span>
<a href="#l26.651"></a><span id="l26.651" class="difflineplus">+    auto it =</span>
<a href="#l26.652"></a><span id="l26.652" class="difflineplus">+      std::find_if(keyring-&gt;keys.begin(), keyring-&gt;keys.end(), [after](const pgp_key_t &amp;key) {</span>
<a href="#l26.653"></a><span id="l26.653" class="difflineplus">+          return !after || (after == &amp;key);</span>
<a href="#l26.654"></a><span id="l26.654" class="difflineplus">+      });</span>
<a href="#l26.655"></a><span id="l26.655" class="difflineplus">+    if (after &amp;&amp; (it == keyring-&gt;keys.end())) {</span>
<a href="#l26.656"></a><span id="l26.656" class="difflineplus">+        RNP_LOG(&quot;searching with non-keyrings after param&quot;);</span>
<a href="#l26.657"></a><span id="l26.657" class="difflineplus">+        return NULL;</span>
<a href="#l26.658"></a><span id="l26.658" class="difflineplus">+    }</span>
<a href="#l26.659"></a><span id="l26.659" class="difflineplus">+    if (after) {</span>
<a href="#l26.660"></a><span id="l26.660" class="difflineplus">+        it = std::next(it);</span>
<a href="#l26.661"></a><span id="l26.661">     }</span>
<a href="#l26.662"></a><span id="l26.662" class="difflineminus">-    return NULL;</span>
<a href="#l26.663"></a><span id="l26.663" class="difflineplus">+    it = std::find_if(it, keyring-&gt;keys.end(), [search](const pgp_key_t &amp;key) {</span>
<a href="#l26.664"></a><span id="l26.664" class="difflineplus">+        return rnp_key_matches_search(&amp;key, search);</span>
<a href="#l26.665"></a><span id="l26.665" class="difflineplus">+    });</span>
<a href="#l26.666"></a><span id="l26.666" class="difflineplus">+    return (it == keyring-&gt;keys.end()) ? NULL : &amp;(*it);</span>
<a href="#l26.667"></a><span id="l26.667"> }</span>
<a href="#l26.668"></a><span id="l26.668" class="difflineplus">+</span>
<a href="#l26.669"></a><span id="l26.669" class="difflineplus">+rnp_key_store_t::rnp_key_store_t(pgp_key_store_format_t _format, const std::string &amp;_path)</span>
<a href="#l26.670"></a><span id="l26.670" class="difflineplus">+{</span>
<a href="#l26.671"></a><span id="l26.671" class="difflineplus">+    if (_format == PGP_KEY_STORE_UNKNOWN) {</span>
<a href="#l26.672"></a><span id="l26.672" class="difflineplus">+        RNP_LOG(&quot;Invalid key store format&quot;);</span>
<a href="#l26.673"></a><span id="l26.673" class="difflineplus">+        throw std::invalid_argument(&quot;format&quot;);</span>
<a href="#l26.674"></a><span id="l26.674" class="difflineplus">+    }</span>
<a href="#l26.675"></a><span id="l26.675" class="difflineplus">+    format = _format;</span>
<a href="#l26.676"></a><span id="l26.676" class="difflineplus">+    path = _path;</span>
<a href="#l26.677"></a><span id="l26.677" class="difflineplus">+    disable_validation = false;</span>
<a href="#l26.678"></a><span id="l26.678" class="difflineplus">+    blobs = NULL;</span>
<a href="#l26.679"></a><span id="l26.679" class="difflineplus">+}</span>
<a href="#l26.680"></a><span id="l26.680" class="difflineplus">+</span>
<a href="#l26.681"></a><span id="l26.681" class="difflineplus">+rnp_key_store_t::~rnp_key_store_t()</span>
<a href="#l26.682"></a><span id="l26.682" class="difflineplus">+{</span>
<a href="#l26.683"></a><span id="l26.683" class="difflineplus">+    rnp_key_store_clear(this);</span>
<a href="#l26.684"></a><span id="l26.684" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-common.cpp</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-common.cpp</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -657,17 +657,17 @@ dst_write(pgp_dest_t *dst, const void *b</span>
<a href="#l27.4"></a><span id="l27.4">             dst-&gt;clen += len;</span>
<a href="#l27.5"></a><span id="l27.5">         }</span>
<a href="#l27.6"></a><span id="l27.6">     }</span>
<a href="#l27.7"></a><span id="l27.7"> }</span>
<a href="#l27.8"></a><span id="l27.8"> </span>
<a href="#l27.9"></a><span id="l27.9"> void</span>
<a href="#l27.10"></a><span id="l27.10"> dst_printf(pgp_dest_t *dst, const char *format, ...)</span>
<a href="#l27.11"></a><span id="l27.11"> {</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-    char    buf[1024];</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+    char    buf[2048];</span>
<a href="#l27.14"></a><span id="l27.14">     size_t  len;</span>
<a href="#l27.15"></a><span id="l27.15">     va_list ap;</span>
<a href="#l27.16"></a><span id="l27.16"> </span>
<a href="#l27.17"></a><span id="l27.17">     va_start(ap, format);</span>
<a href="#l27.18"></a><span id="l27.18">     len = vsnprintf(buf, sizeof(buf), format, ap);</span>
<a href="#l27.19"></a><span id="l27.19">     va_end(ap);</span>
<a href="#l27.20"></a><span id="l27.20"> </span>
<a href="#l27.21"></a><span id="l27.21">     if (len &gt;= sizeof(buf)) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-dump.cpp</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-dump.cpp</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -499,17 +499,17 @@ dst_hexdump(pgp_dest_t *dst, const uint8</span>
<a href="#l28.4"></a><span id="l28.4">         line[LINELEN] = 0x0;</span>
<a href="#l28.5"></a><span id="l28.5">         dst_printf(dst, &quot; | %s\n&quot;, line);</span>
<a href="#l28.6"></a><span id="l28.6">     }</span>
<a href="#l28.7"></a><span id="l28.7"> }</span>
<a href="#l28.8"></a><span id="l28.8"> </span>
<a href="#l28.9"></a><span id="l28.9"> static rnp_result_t stream_dump_packets_raw(rnp_dump_ctx_t *ctx,</span>
<a href="#l28.10"></a><span id="l28.10">                                             pgp_source_t *  src,</span>
<a href="#l28.11"></a><span id="l28.11">                                             pgp_dest_t *    dst);</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-static rnp_result_t stream_dump_signature_pkt(rnp_dump_ctx_t * ctx,</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+static void         stream_dump_signature_pkt(rnp_dump_ctx_t * ctx,</span>
<a href="#l28.14"></a><span id="l28.14">                                               pgp_signature_t *sig,</span>
<a href="#l28.15"></a><span id="l28.15">                                               pgp_dest_t *     dst);</span>
<a href="#l28.16"></a><span id="l28.16"> </span>
<a href="#l28.17"></a><span id="l28.17"> static void</span>
<a href="#l28.18"></a><span id="l28.18"> signature_dump_subpacket(rnp_dump_ctx_t *ctx, pgp_dest_t *dst, pgp_sig_subpkt_t *subpkt)</span>
<a href="#l28.19"></a><span id="l28.19"> {</span>
<a href="#l28.20"></a><span id="l28.20">     const char *sname = pgp_str_from_map(subpkt-&gt;type, sig_subpkt_type_map);</span>
<a href="#l28.21"></a><span id="l28.21"> </span>
<a href="#l28.22"></a><span id="l28.22" class="difflineat">@@ -670,17 +670,17 @@ signature_dump_subpackets(rnp_dump_ctx_t</span>
<a href="#l28.23"></a><span id="l28.23">         signature_dump_subpacket(ctx, dst, subpkt);</span>
<a href="#l28.24"></a><span id="l28.24">     }</span>
<a href="#l28.25"></a><span id="l28.25"> </span>
<a href="#l28.26"></a><span id="l28.26">     if (empty) {</span>
<a href="#l28.27"></a><span id="l28.27">         dst_printf(dst, &quot;none\n&quot;);</span>
<a href="#l28.28"></a><span id="l28.28">     }</span>
<a href="#l28.29"></a><span id="l28.29"> }</span>
<a href="#l28.30"></a><span id="l28.30"> </span>
<a href="#l28.31"></a><span id="l28.31" class="difflineminus">-static rnp_result_t</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+static void</span>
<a href="#l28.33"></a><span id="l28.33"> stream_dump_signature_pkt(rnp_dump_ctx_t *ctx, pgp_signature_t *sig, pgp_dest_t *dst)</span>
<a href="#l28.34"></a><span id="l28.34"> {</span>
<a href="#l28.35"></a><span id="l28.35">     indent_dest_increase(dst);</span>
<a href="#l28.36"></a><span id="l28.36"> </span>
<a href="#l28.37"></a><span id="l28.37">     dst_printf(dst, &quot;version: %d\n&quot;, (int) sig-&gt;version);</span>
<a href="#l28.38"></a><span id="l28.38">     dst_print_sig_type(dst, &quot;type&quot;, sig-&gt;type);</span>
<a href="#l28.39"></a><span id="l28.39">     if (sig-&gt;version &lt; PGP_V4) {</span>
<a href="#l28.40"></a><span id="l28.40">         dst_print_time(dst, &quot;creation time&quot;, sig-&gt;creation_time);</span>
<a href="#l28.41"></a><span id="l28.41" class="difflineat">@@ -702,55 +702,58 @@ stream_dump_signature_pkt(rnp_dump_ctx_t</span>
<a href="#l28.42"></a><span id="l28.42">     }</span>
<a href="#l28.43"></a><span id="l28.43"> </span>
<a href="#l28.44"></a><span id="l28.44">     dst_print_hex(dst, &quot;lbits&quot;, sig-&gt;lbits, sizeof(sig-&gt;lbits), false);</span>
<a href="#l28.45"></a><span id="l28.45">     dst_printf(dst, &quot;signature material:\n&quot;);</span>
<a href="#l28.46"></a><span id="l28.46">     indent_dest_increase(dst);</span>
<a href="#l28.47"></a><span id="l28.47"> </span>
<a href="#l28.48"></a><span id="l28.48">     switch (sig-&gt;palg) {</span>
<a href="#l28.49"></a><span id="l28.49">     case PGP_PKA_RSA:</span>
<a href="#l28.50"></a><span id="l28.50" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l28.52"></a><span id="l28.52">         dst_print_mpi(dst, &quot;rsa s&quot;, &amp;sig-&gt;material.rsa.s, ctx-&gt;dump_mpi);</span>
<a href="#l28.53"></a><span id="l28.53">         break;</span>
<a href="#l28.54"></a><span id="l28.54">     case PGP_PKA_DSA:</span>
<a href="#l28.55"></a><span id="l28.55">         dst_print_mpi(dst, &quot;dsa r&quot;, &amp;sig-&gt;material.dsa.r, ctx-&gt;dump_mpi);</span>
<a href="#l28.56"></a><span id="l28.56">         dst_print_mpi(dst, &quot;dsa s&quot;, &amp;sig-&gt;material.dsa.s, ctx-&gt;dump_mpi);</span>
<a href="#l28.57"></a><span id="l28.57">         break;</span>
<a href="#l28.58"></a><span id="l28.58">     case PGP_PKA_EDDSA:</span>
<a href="#l28.59"></a><span id="l28.59">     case PGP_PKA_ECDSA:</span>
<a href="#l28.60"></a><span id="l28.60">     case PGP_PKA_SM2:</span>
<a href="#l28.61"></a><span id="l28.61">     case PGP_PKA_ECDH:</span>
<a href="#l28.62"></a><span id="l28.62">         dst_print_mpi(dst, &quot;ecc r&quot;, &amp;sig-&gt;material.ecc.r, ctx-&gt;dump_mpi);</span>
<a href="#l28.63"></a><span id="l28.63">         dst_print_mpi(dst, &quot;ecc s&quot;, &amp;sig-&gt;material.ecc.s, ctx-&gt;dump_mpi);</span>
<a href="#l28.64"></a><span id="l28.64">         break;</span>
<a href="#l28.65"></a><span id="l28.65" class="difflineplus">+    case PGP_PKA_ELGAMAL:</span>
<a href="#l28.66"></a><span id="l28.66">     case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l28.67"></a><span id="l28.67">         dst_print_mpi(dst, &quot;eg r&quot;, &amp;sig-&gt;material.eg.r, ctx-&gt;dump_mpi);</span>
<a href="#l28.68"></a><span id="l28.68">         dst_print_mpi(dst, &quot;eg s&quot;, &amp;sig-&gt;material.eg.s, ctx-&gt;dump_mpi);</span>
<a href="#l28.69"></a><span id="l28.69">         break;</span>
<a href="#l28.70"></a><span id="l28.70">     default:</span>
<a href="#l28.71"></a><span id="l28.71">         dst_printf(dst, &quot;unknown algorithm\n&quot;);</span>
<a href="#l28.72"></a><span id="l28.72">     }</span>
<a href="#l28.73"></a><span id="l28.73">     indent_dest_decrease(dst);</span>
<a href="#l28.74"></a><span id="l28.74">     indent_dest_decrease(dst);</span>
<a href="#l28.75"></a><span id="l28.75" class="difflineminus">-    return RNP_SUCCESS;</span>
<a href="#l28.76"></a><span id="l28.76"> }</span>
<a href="#l28.77"></a><span id="l28.77"> </span>
<a href="#l28.78"></a><span id="l28.78" class="difflineminus">-static rnp_result_t</span>
<a href="#l28.79"></a><span id="l28.79" class="difflineplus">+static void</span>
<a href="#l28.80"></a><span id="l28.80"> stream_dump_signature(rnp_dump_ctx_t *ctx, pgp_source_t *src, pgp_dest_t *dst)</span>
<a href="#l28.81"></a><span id="l28.81"> {</span>
<a href="#l28.82"></a><span id="l28.82">     pgp_signature_t sig;</span>
<a href="#l28.83"></a><span id="l28.83" class="difflineminus">-    rnp_result_t    ret;</span>
<a href="#l28.84"></a><span id="l28.84"> </span>
<a href="#l28.85"></a><span id="l28.85" class="difflineminus">-    if ((ret = stream_parse_signature(src, &amp;sig))) {</span>
<a href="#l28.86"></a><span id="l28.86" class="difflineminus">-        return ret;</span>
<a href="#l28.87"></a><span id="l28.87" class="difflineplus">+    dst_printf(dst, &quot;Signature packet\n&quot;);</span>
<a href="#l28.88"></a><span id="l28.88" class="difflineplus">+    if (stream_parse_signature(src, &amp;sig)) {</span>
<a href="#l28.89"></a><span id="l28.89" class="difflineplus">+        indent_dest_increase(dst);</span>
<a href="#l28.90"></a><span id="l28.90" class="difflineplus">+        dst_printf(dst, &quot;failed to parse\n&quot;);</span>
<a href="#l28.91"></a><span id="l28.91" class="difflineplus">+        indent_dest_decrease(dst);</span>
<a href="#l28.92"></a><span id="l28.92" class="difflineplus">+        return;</span>
<a href="#l28.93"></a><span id="l28.93">     }</span>
<a href="#l28.94"></a><span id="l28.94"> </span>
<a href="#l28.95"></a><span id="l28.95" class="difflineminus">-    dst_printf(dst, &quot;Signature packet\n&quot;);</span>
<a href="#l28.96"></a><span id="l28.96" class="difflineminus">-    ret = stream_dump_signature_pkt(ctx, &amp;sig, dst);</span>
<a href="#l28.97"></a><span id="l28.97" class="difflineplus">+    stream_dump_signature_pkt(ctx, &amp;sig, dst);</span>
<a href="#l28.98"></a><span id="l28.98">     free_signature(&amp;sig);</span>
<a href="#l28.99"></a><span id="l28.99" class="difflineminus">-    return ret;</span>
<a href="#l28.100"></a><span id="l28.100"> }</span>
<a href="#l28.101"></a><span id="l28.101"> </span>
<a href="#l28.102"></a><span id="l28.102"> static rnp_result_t</span>
<a href="#l28.103"></a><span id="l28.103"> stream_dump_key(rnp_dump_ctx_t *ctx, pgp_source_t *src, pgp_dest_t *dst)</span>
<a href="#l28.104"></a><span id="l28.104"> {</span>
<a href="#l28.105"></a><span id="l28.105">     pgp_key_pkt_t     key;</span>
<a href="#l28.106"></a><span id="l28.106">     rnp_result_t      ret;</span>
<a href="#l28.107"></a><span id="l28.107">     uint8_t           keyid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l28.108"></a><span id="l28.108" class="difflineat">@@ -846,18 +849,19 @@ stream_dump_key(rnp_dump_ctx_t *ctx, pgp</span>
<a href="#l28.109"></a><span id="l28.109">         if (!pgp_fingerprint(&amp;keyfp, &amp;key)) {</span>
<a href="#l28.110"></a><span id="l28.110">             dst_print_hex(dst, &quot;fingerprint&quot;, keyfp.fingerprint, keyfp.length, false);</span>
<a href="#l28.111"></a><span id="l28.111">         } else {</span>
<a href="#l28.112"></a><span id="l28.112">             dst_printf(dst, &quot;fingerprint: failed to calculate&quot;);</span>
<a href="#l28.113"></a><span id="l28.113">         }</span>
<a href="#l28.114"></a><span id="l28.114">     }</span>
<a href="#l28.115"></a><span id="l28.115"> </span>
<a href="#l28.116"></a><span id="l28.116">     if (ctx-&gt;dump_grips) {</span>
<a href="#l28.117"></a><span id="l28.117" class="difflineminus">-        if (rnp_key_store_get_key_grip(&amp;key.material, keyfp.fingerprint)) {</span>
<a href="#l28.118"></a><span id="l28.118" class="difflineminus">-            dst_print_hex(dst, &quot;grip&quot;, keyfp.fingerprint, PGP_FINGERPRINT_SIZE, false);</span>
<a href="#l28.119"></a><span id="l28.119" class="difflineplus">+        pgp_key_grip_t grip;</span>
<a href="#l28.120"></a><span id="l28.120" class="difflineplus">+        if (rnp_key_store_get_key_grip(&amp;key.material, grip)) {</span>
<a href="#l28.121"></a><span id="l28.121" class="difflineplus">+            dst_print_hex(dst, &quot;grip&quot;, grip.data(), grip.size(), false);</span>
<a href="#l28.122"></a><span id="l28.122">         } else {</span>
<a href="#l28.123"></a><span id="l28.123">             dst_printf(dst, &quot;grip: failed to calculate&quot;);</span>
<a href="#l28.124"></a><span id="l28.124">         }</span>
<a href="#l28.125"></a><span id="l28.125">     }</span>
<a href="#l28.126"></a><span id="l28.126"> </span>
<a href="#l28.127"></a><span id="l28.127">     free_key_pkt(&amp;key);</span>
<a href="#l28.128"></a><span id="l28.128">     indent_dest_decrease(dst);</span>
<a href="#l28.129"></a><span id="l28.129">     return RNP_SUCCESS;</span>
<a href="#l28.130"></a><span id="l28.130" class="difflineat">@@ -921,19 +925,22 @@ stream_dump_pk_session_key(rnp_dump_ctx_</span>
<a href="#l28.131"></a><span id="l28.131">     dst_printf(dst, &quot;version: %d\n&quot;, (int) pkey.version);</span>
<a href="#l28.132"></a><span id="l28.132">     dst_print_keyid(dst, NULL, pkey.key_id);</span>
<a href="#l28.133"></a><span id="l28.133">     dst_print_palg(dst, NULL, pkey.alg);</span>
<a href="#l28.134"></a><span id="l28.134">     dst_printf(dst, &quot;encrypted material:\n&quot;);</span>
<a href="#l28.135"></a><span id="l28.135">     indent_dest_increase(dst);</span>
<a href="#l28.136"></a><span id="l28.136"> </span>
<a href="#l28.137"></a><span id="l28.137">     switch (pkey.alg) {</span>
<a href="#l28.138"></a><span id="l28.138">     case PGP_PKA_RSA:</span>
<a href="#l28.139"></a><span id="l28.139" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l28.140"></a><span id="l28.140" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l28.141"></a><span id="l28.141">         dst_print_mpi(dst, &quot;rsa m&quot;, &amp;pkey.material.rsa.m, ctx-&gt;dump_mpi);</span>
<a href="#l28.142"></a><span id="l28.142">         break;</span>
<a href="#l28.143"></a><span id="l28.143">     case PGP_PKA_ELGAMAL:</span>
<a href="#l28.144"></a><span id="l28.144" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l28.145"></a><span id="l28.145">         dst_print_mpi(dst, &quot;eg g&quot;, &amp;pkey.material.eg.g, ctx-&gt;dump_mpi);</span>
<a href="#l28.146"></a><span id="l28.146">         dst_print_mpi(dst, &quot;eg m&quot;, &amp;pkey.material.eg.m, ctx-&gt;dump_mpi);</span>
<a href="#l28.147"></a><span id="l28.147">         break;</span>
<a href="#l28.148"></a><span id="l28.148">     case PGP_PKA_SM2:</span>
<a href="#l28.149"></a><span id="l28.149">         dst_print_mpi(dst, &quot;sm2 m&quot;, &amp;pkey.material.sm2.m, ctx-&gt;dump_mpi);</span>
<a href="#l28.150"></a><span id="l28.150">         break;</span>
<a href="#l28.151"></a><span id="l28.151">     case PGP_PKA_ECDH:</span>
<a href="#l28.152"></a><span id="l28.152">         dst_print_mpi(dst, &quot;ecdh p&quot;, &amp;pkey.material.ecdh.p, ctx-&gt;dump_mpi);</span>
<a href="#l28.153"></a><span id="l28.153" class="difflineat">@@ -1186,17 +1193,18 @@ stream_dump_packets_raw(rnp_dump_ctx_t *</span>
<a href="#l28.154"></a><span id="l28.154">                 dst_hexdump(dst, (uint8_t *) msg + hdr.hdr_len, rlen);</span>
<a href="#l28.155"></a><span id="l28.155">                 indent_dest_decrease(dst);</span>
<a href="#l28.156"></a><span id="l28.156">             }</span>
<a href="#l28.157"></a><span id="l28.157">             dst_printf(dst, &quot;\n&quot;);</span>
<a href="#l28.158"></a><span id="l28.158">         }</span>
<a href="#l28.159"></a><span id="l28.159"> </span>
<a href="#l28.160"></a><span id="l28.160">         switch (hdr.tag) {</span>
<a href="#l28.161"></a><span id="l28.161">         case PGP_PKT_SIGNATURE:</span>
<a href="#l28.162"></a><span id="l28.162" class="difflineminus">-            ret = stream_dump_signature(ctx, src, dst);</span>
<a href="#l28.163"></a><span id="l28.163" class="difflineplus">+            stream_dump_signature(ctx, src, dst);</span>
<a href="#l28.164"></a><span id="l28.164" class="difflineplus">+            ret = RNP_SUCCESS;</span>
<a href="#l28.165"></a><span id="l28.165">             break;</span>
<a href="#l28.166"></a><span id="l28.166">         case PGP_PKT_SECRET_KEY:</span>
<a href="#l28.167"></a><span id="l28.167">         case PGP_PKT_PUBLIC_KEY:</span>
<a href="#l28.168"></a><span id="l28.168">         case PGP_PKT_SECRET_SUBKEY:</span>
<a href="#l28.169"></a><span id="l28.169">         case PGP_PKT_PUBLIC_SUBKEY:</span>
<a href="#l28.170"></a><span id="l28.170">             ret = stream_dump_key(ctx, src, dst);</span>
<a href="#l28.171"></a><span id="l28.171">             break;</span>
<a href="#l28.172"></a><span id="l28.172">         case PGP_PKT_USER_ID:</span>
<a href="#l28.173"></a><span id="l28.173" class="difflineat">@@ -1670,16 +1678,18 @@ stream_dump_signature_pkt_json(rnp_dump_</span>
<a href="#l28.174"></a><span id="l28.174"> </span>
<a href="#l28.175"></a><span id="l28.175">     material = json_object_new_object();</span>
<a href="#l28.176"></a><span id="l28.176">     if (!material || !obj_add_field_json(pkt, &quot;material&quot;, material)) {</span>
<a href="#l28.177"></a><span id="l28.177">         goto done;</span>
<a href="#l28.178"></a><span id="l28.178">     }</span>
<a href="#l28.179"></a><span id="l28.179"> </span>
<a href="#l28.180"></a><span id="l28.180">     switch (sig-&gt;palg) {</span>
<a href="#l28.181"></a><span id="l28.181">     case PGP_PKA_RSA:</span>
<a href="#l28.182"></a><span id="l28.182" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l28.183"></a><span id="l28.183" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l28.184"></a><span id="l28.184">         if (!obj_add_mpi_json(material, &quot;s&quot;, &amp;sig-&gt;material.rsa.s, ctx-&gt;dump_mpi)) {</span>
<a href="#l28.185"></a><span id="l28.185">             goto done;</span>
<a href="#l28.186"></a><span id="l28.186">         }</span>
<a href="#l28.187"></a><span id="l28.187">         break;</span>
<a href="#l28.188"></a><span id="l28.188">     case PGP_PKA_DSA:</span>
<a href="#l28.189"></a><span id="l28.189">         if (!obj_add_mpi_json(material, &quot;r&quot;, &amp;sig-&gt;material.dsa.r, ctx-&gt;dump_mpi) ||</span>
<a href="#l28.190"></a><span id="l28.190">             !obj_add_mpi_json(material, &quot;s&quot;, &amp;sig-&gt;material.dsa.s, ctx-&gt;dump_mpi)) {</span>
<a href="#l28.191"></a><span id="l28.191">             goto done;</span>
<a href="#l28.192"></a><span id="l28.192" class="difflineat">@@ -1689,16 +1699,17 @@ stream_dump_signature_pkt_json(rnp_dump_</span>
<a href="#l28.193"></a><span id="l28.193">     case PGP_PKA_ECDSA:</span>
<a href="#l28.194"></a><span id="l28.194">     case PGP_PKA_SM2:</span>
<a href="#l28.195"></a><span id="l28.195">     case PGP_PKA_ECDH:</span>
<a href="#l28.196"></a><span id="l28.196">         if (!obj_add_mpi_json(material, &quot;r&quot;, &amp;sig-&gt;material.ecc.r, ctx-&gt;dump_mpi) ||</span>
<a href="#l28.197"></a><span id="l28.197">             !obj_add_mpi_json(material, &quot;s&quot;, &amp;sig-&gt;material.ecc.s, ctx-&gt;dump_mpi)) {</span>
<a href="#l28.198"></a><span id="l28.198">             goto done;</span>
<a href="#l28.199"></a><span id="l28.199">         }</span>
<a href="#l28.200"></a><span id="l28.200">         break;</span>
<a href="#l28.201"></a><span id="l28.201" class="difflineplus">+    case PGP_PKA_ELGAMAL:</span>
<a href="#l28.202"></a><span id="l28.202">     case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l28.203"></a><span id="l28.203">         if (!obj_add_mpi_json(material, &quot;r&quot;, &amp;sig-&gt;material.eg.r, ctx-&gt;dump_mpi) ||</span>
<a href="#l28.204"></a><span id="l28.204">             !obj_add_mpi_json(material, &quot;s&quot;, &amp;sig-&gt;material.eg.s, ctx-&gt;dump_mpi)) {</span>
<a href="#l28.205"></a><span id="l28.205">             goto done;</span>
<a href="#l28.206"></a><span id="l28.206">         }</span>
<a href="#l28.207"></a><span id="l28.207">         break;</span>
<a href="#l28.208"></a><span id="l28.208">     default:</span>
<a href="#l28.209"></a><span id="l28.209">         break;</span>
<a href="#l28.210"></a><span id="l28.210" class="difflineat">@@ -1707,23 +1718,21 @@ stream_dump_signature_pkt_json(rnp_dump_</span>
<a href="#l28.211"></a><span id="l28.211"> done:</span>
<a href="#l28.212"></a><span id="l28.212">     return ret;</span>
<a href="#l28.213"></a><span id="l28.213"> }</span>
<a href="#l28.214"></a><span id="l28.214"> </span>
<a href="#l28.215"></a><span id="l28.215"> static rnp_result_t</span>
<a href="#l28.216"></a><span id="l28.216"> stream_dump_signature_json(rnp_dump_ctx_t *ctx, pgp_source_t *src, json_object *pkt)</span>
<a href="#l28.217"></a><span id="l28.217"> {</span>
<a href="#l28.218"></a><span id="l28.218">     pgp_signature_t sig;</span>
<a href="#l28.219"></a><span id="l28.219" class="difflineminus">-    rnp_result_t    ret;</span>
<a href="#l28.220"></a><span id="l28.220" class="difflineminus">-</span>
<a href="#l28.221"></a><span id="l28.221" class="difflineminus">-    if ((ret = stream_parse_signature(src, &amp;sig))) {</span>
<a href="#l28.222"></a><span id="l28.222" class="difflineminus">-        return ret;</span>
<a href="#l28.223"></a><span id="l28.223" class="difflineplus">+    if (stream_parse_signature(src, &amp;sig)) {</span>
<a href="#l28.224"></a><span id="l28.224" class="difflineplus">+        return RNP_SUCCESS;</span>
<a href="#l28.225"></a><span id="l28.225">     }</span>
<a href="#l28.226"></a><span id="l28.226"> </span>
<a href="#l28.227"></a><span id="l28.227" class="difflineminus">-    ret = stream_dump_signature_pkt_json(ctx, &amp;sig, pkt);</span>
<a href="#l28.228"></a><span id="l28.228" class="difflineplus">+    rnp_result_t ret = stream_dump_signature_pkt_json(ctx, &amp;sig, pkt);</span>
<a href="#l28.229"></a><span id="l28.229">     free_signature(&amp;sig);</span>
<a href="#l28.230"></a><span id="l28.230">     return ret;</span>
<a href="#l28.231"></a><span id="l28.231"> }</span>
<a href="#l28.232"></a><span id="l28.232"> </span>
<a href="#l28.233"></a><span id="l28.233"> static rnp_result_t</span>
<a href="#l28.234"></a><span id="l28.234"> stream_dump_key_json(rnp_dump_ctx_t *ctx, pgp_source_t *src, json_object *pkt)</span>
<a href="#l28.235"></a><span id="l28.235"> {</span>
<a href="#l28.236"></a><span id="l28.236">     pgp_key_pkt_t     key;</span>
<a href="#l28.237"></a><span id="l28.237" class="difflineat">@@ -1841,26 +1850,27 @@ stream_dump_key_json(rnp_dump_ctx_t *ctx</span>
<a href="#l28.238"></a><span id="l28.238">     }</span>
<a href="#l28.239"></a><span id="l28.239"> </span>
<a href="#l28.240"></a><span id="l28.240">     if (ctx-&gt;dump_grips) {</span>
<a href="#l28.241"></a><span id="l28.241">         if (pgp_fingerprint(&amp;keyfp, &amp;key) ||</span>
<a href="#l28.242"></a><span id="l28.242">             !obj_add_hex_json(pkt, &quot;fingerprint&quot;, keyfp.fingerprint, keyfp.length)) {</span>
<a href="#l28.243"></a><span id="l28.243">             goto done;</span>
<a href="#l28.244"></a><span id="l28.244">         }</span>
<a href="#l28.245"></a><span id="l28.245"> </span>
<a href="#l28.246"></a><span id="l28.246" class="difflineminus">-        if (!rnp_key_store_get_key_grip(&amp;key.material, keyfp.fingerprint) ||</span>
<a href="#l28.247"></a><span id="l28.247" class="difflineminus">-            !obj_add_hex_json(pkt, &quot;grip&quot;, keyfp.fingerprint, PGP_KEY_GRIP_SIZE)) {</span>
<a href="#l28.248"></a><span id="l28.248" class="difflineplus">+        pgp_key_grip_t grip;</span>
<a href="#l28.249"></a><span id="l28.249" class="difflineplus">+        if (!rnp_key_store_get_key_grip(&amp;key.material, grip) ||</span>
<a href="#l28.250"></a><span id="l28.250" class="difflineplus">+            !obj_add_hex_json(pkt, &quot;grip&quot;, grip.data(), grip.size())) {</span>
<a href="#l28.251"></a><span id="l28.251">             goto done;</span>
<a href="#l28.252"></a><span id="l28.252">         }</span>
<a href="#l28.253"></a><span id="l28.253">     }</span>
<a href="#l28.254"></a><span id="l28.254"> </span>
<a href="#l28.255"></a><span id="l28.255">     ret = RNP_SUCCESS;</span>
<a href="#l28.256"></a><span id="l28.256"> done:</span>
<a href="#l28.257"></a><span id="l28.257">     free_key_pkt(&amp;key);</span>
<a href="#l28.258"></a><span id="l28.258" class="difflineminus">-    return RNP_SUCCESS;</span>
<a href="#l28.259"></a><span id="l28.259" class="difflineplus">+    return ret;</span>
<a href="#l28.260"></a><span id="l28.260"> }</span>
<a href="#l28.261"></a><span id="l28.261"> </span>
<a href="#l28.262"></a><span id="l28.262"> static rnp_result_t</span>
<a href="#l28.263"></a><span id="l28.263"> stream_dump_userid_json(pgp_source_t *src, json_object *pkt)</span>
<a href="#l28.264"></a><span id="l28.264"> {</span>
<a href="#l28.265"></a><span id="l28.265">     pgp_userid_pkt_t uid;</span>
<a href="#l28.266"></a><span id="l28.266">     rnp_result_t     ret;</span>
<a href="#l28.267"></a><span id="l28.267"> </span>
<a href="#l28.268"></a><span id="l28.268" class="difflineat">@@ -1909,21 +1919,24 @@ stream_dump_pk_session_key_json(rnp_dump</span>
<a href="#l28.269"></a><span id="l28.269"> </span>
<a href="#l28.270"></a><span id="l28.270">     json_object *material = json_object_new_object();</span>
<a href="#l28.271"></a><span id="l28.271">     if (!obj_add_field_json(pkt, &quot;material&quot;, material)) {</span>
<a href="#l28.272"></a><span id="l28.272">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l28.273"></a><span id="l28.273">     }</span>
<a href="#l28.274"></a><span id="l28.274"> </span>
<a href="#l28.275"></a><span id="l28.275">     switch (pkey.alg) {</span>
<a href="#l28.276"></a><span id="l28.276">     case PGP_PKA_RSA:</span>
<a href="#l28.277"></a><span id="l28.277" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l28.278"></a><span id="l28.278" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l28.279"></a><span id="l28.279">         if (!obj_add_mpi_json(material, &quot;m&quot;, &amp;pkey.material.rsa.m, ctx-&gt;dump_mpi)) {</span>
<a href="#l28.280"></a><span id="l28.280">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l28.281"></a><span id="l28.281">         }</span>
<a href="#l28.282"></a><span id="l28.282">         break;</span>
<a href="#l28.283"></a><span id="l28.283">     case PGP_PKA_ELGAMAL:</span>
<a href="#l28.284"></a><span id="l28.284" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l28.285"></a><span id="l28.285">         if (!obj_add_mpi_json(material, &quot;g&quot;, &amp;pkey.material.eg.g, ctx-&gt;dump_mpi) ||</span>
<a href="#l28.286"></a><span id="l28.286">             !obj_add_mpi_json(material, &quot;m&quot;, &amp;pkey.material.eg.m, ctx-&gt;dump_mpi)) {</span>
<a href="#l28.287"></a><span id="l28.287">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l28.288"></a><span id="l28.288">         }</span>
<a href="#l28.289"></a><span id="l28.289">         break;</span>
<a href="#l28.290"></a><span id="l28.290">     case PGP_PKA_SM2:</span>
<a href="#l28.291"></a><span id="l28.291">         if (!obj_add_mpi_json(material, &quot;m&quot;, &amp;pkey.material.sm2.m, ctx-&gt;dump_mpi)) {</span>
<a href="#l28.292"></a><span id="l28.292">             return RNP_ERROR_OUT_OF_MEMORY;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-key.cpp</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-key.cpp</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -706,17 +706,17 @@ transferable_key_revoke(const pgp_key_pk</span>
<a href="#l29.4"></a><span id="l29.4">     if (!signature_set_keyfp(sig, &amp;keyfp)) {</span>
<a href="#l29.5"></a><span id="l29.5">         RNP_LOG(&quot;failed to set issuer fingerprint&quot;);</span>
<a href="#l29.6"></a><span id="l29.6">         goto end;</span>
<a href="#l29.7"></a><span id="l29.7">     }</span>
<a href="#l29.8"></a><span id="l29.8">     if (!signature_set_creation(sig, time(NULL))) {</span>
<a href="#l29.9"></a><span id="l29.9">         RNP_LOG(&quot;failed to set creation time&quot;);</span>
<a href="#l29.10"></a><span id="l29.10">         goto end;</span>
<a href="#l29.11"></a><span id="l29.11">     }</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-    if (!signature_set_revocation_reason(sig, revoke-&gt;code, revoke-&gt;reason)) {</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+    if (!signature_set_revocation_reason(sig, revoke-&gt;code, revoke-&gt;reason.c_str())) {</span>
<a href="#l29.14"></a><span id="l29.14">         RNP_LOG(&quot;failed to set revocation reason&quot;);</span>
<a href="#l29.15"></a><span id="l29.15">         goto end;</span>
<a href="#l29.16"></a><span id="l29.16">     }</span>
<a href="#l29.17"></a><span id="l29.17">     if (!signature_set_keyid(sig, keyid)) {</span>
<a href="#l29.18"></a><span id="l29.18">         RNP_LOG(&quot;failed to set issuer key id&quot;);</span>
<a href="#l29.19"></a><span id="l29.19">         goto end;</span>
<a href="#l29.20"></a><span id="l29.20">     }</span>
<a href="#l29.21"></a><span id="l29.21"> </span>
<a href="#l29.22"></a><span id="l29.22" class="difflineat">@@ -1232,16 +1232,17 @@ parse_secret_key_mpis(pgp_key_pkt_t *key</span>
<a href="#l29.23"></a><span id="l29.23">         break;</span>
<a href="#l29.24"></a><span id="l29.24">     case PGP_PKA_EDDSA:</span>
<a href="#l29.25"></a><span id="l29.25">     case PGP_PKA_ECDSA:</span>
<a href="#l29.26"></a><span id="l29.26">     case PGP_PKA_SM2:</span>
<a href="#l29.27"></a><span id="l29.27">     case PGP_PKA_ECDH:</span>
<a href="#l29.28"></a><span id="l29.28">         res = get_packet_body_mpi(&amp;body, &amp;key-&gt;material.ec.x);</span>
<a href="#l29.29"></a><span id="l29.29">         break;</span>
<a href="#l29.30"></a><span id="l29.30">     case PGP_PKA_ELGAMAL:</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l29.32"></a><span id="l29.32">         res = get_packet_body_mpi(&amp;body, &amp;key-&gt;material.eg.x);</span>
<a href="#l29.33"></a><span id="l29.33">         break;</span>
<a href="#l29.34"></a><span id="l29.34">     default:</span>
<a href="#l29.35"></a><span id="l29.35">         RNP_LOG(&quot;uknown pk alg : %d&quot;, (int) key-&gt;alg);</span>
<a href="#l29.36"></a><span id="l29.36">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.37"></a><span id="l29.37">     }</span>
<a href="#l29.38"></a><span id="l29.38"> </span>
<a href="#l29.39"></a><span id="l29.39">     if (!res) {</span>
<a href="#l29.40"></a><span id="l29.40" class="difflineat">@@ -1362,16 +1363,17 @@ write_secret_key_mpis(pgp_packet_body_t </span>
<a href="#l29.41"></a><span id="l29.41">         break;</span>
<a href="#l29.42"></a><span id="l29.42">     case PGP_PKA_EDDSA:</span>
<a href="#l29.43"></a><span id="l29.43">     case PGP_PKA_ECDSA:</span>
<a href="#l29.44"></a><span id="l29.44">     case PGP_PKA_SM2:</span>
<a href="#l29.45"></a><span id="l29.45">     case PGP_PKA_ECDH:</span>
<a href="#l29.46"></a><span id="l29.46">         res = add_packet_body_mpi(body, &amp;key-&gt;material.ec.x);</span>
<a href="#l29.47"></a><span id="l29.47">         break;</span>
<a href="#l29.48"></a><span id="l29.48">     case PGP_PKA_ELGAMAL:</span>
<a href="#l29.49"></a><span id="l29.49" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l29.50"></a><span id="l29.50">         res = add_packet_body_mpi(body, &amp;key-&gt;material.eg.x);</span>
<a href="#l29.51"></a><span id="l29.51">         break;</span>
<a href="#l29.52"></a><span id="l29.52">     default:</span>
<a href="#l29.53"></a><span id="l29.53">         RNP_LOG(&quot;uknown pk alg : %d&quot;, (int) key-&gt;alg);</span>
<a href="#l29.54"></a><span id="l29.54">         return false;</span>
<a href="#l29.55"></a><span id="l29.55">     }</span>
<a href="#l29.56"></a><span id="l29.56"> </span>
<a href="#l29.57"></a><span id="l29.57">     if (!res) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-packet.cpp</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-packet.cpp</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -504,24 +504,26 @@ get_packet_body_mpi(pgp_packet_body_t *b</span>
<a href="#l30.4"></a><span id="l30.4">         RNP_LOG(&quot;too large mpi&quot;);</span>
<a href="#l30.5"></a><span id="l30.5">         return false;</span>
<a href="#l30.6"></a><span id="l30.6">     }</span>
<a href="#l30.7"></a><span id="l30.7">     if (len == 0) {</span>
<a href="#l30.8"></a><span id="l30.8">         RNP_LOG(&quot;0 mpi&quot;);</span>
<a href="#l30.9"></a><span id="l30.9">         return false;</span>
<a href="#l30.10"></a><span id="l30.10">     }</span>
<a href="#l30.11"></a><span id="l30.11">     if (!get_packet_body_buf(body, val-&gt;mpi, len)) {</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineplus">+        RNP_LOG(&quot;failed to read mpi body&quot;);</span>
<a href="#l30.13"></a><span id="l30.13">         return false;</span>
<a href="#l30.14"></a><span id="l30.14">     }</span>
<a href="#l30.15"></a><span id="l30.15">     /* check the mpi bit count */</span>
<a href="#l30.16"></a><span id="l30.16">     unsigned hbits = bits &amp; 7 ? bits &amp; 7 : 8;</span>
<a href="#l30.17"></a><span id="l30.17">     if ((((unsigned) val-&gt;mpi[0] &gt;&gt; hbits) != 0) ||</span>
<a href="#l30.18"></a><span id="l30.18">         !((unsigned) val-&gt;mpi[0] &amp; (1U &lt;&lt; (hbits - 1)))) {</span>
<a href="#l30.19"></a><span id="l30.19" class="difflineminus">-        RNP_LOG(&quot;wrong mpi bit count&quot;);</span>
<a href="#l30.20"></a><span id="l30.20" class="difflineminus">-        return false;</span>
<a href="#l30.21"></a><span id="l30.21" class="difflineplus">+        RNP_LOG(&quot;Warning! Wrong mpi bit count: got %d, but high byte is %d&quot;,</span>
<a href="#l30.22"></a><span id="l30.22" class="difflineplus">+                (int) bits,</span>
<a href="#l30.23"></a><span id="l30.23" class="difflineplus">+                (int) val-&gt;mpi[0]);</span>
<a href="#l30.24"></a><span id="l30.24">     }</span>
<a href="#l30.25"></a><span id="l30.25"> </span>
<a href="#l30.26"></a><span id="l30.26">     val-&gt;len = len;</span>
<a href="#l30.27"></a><span id="l30.27">     return true;</span>
<a href="#l30.28"></a><span id="l30.28"> }</span>
<a href="#l30.29"></a><span id="l30.29"> </span>
<a href="#l30.30"></a><span id="l30.30"> /* @brief Read ECC key curve and convert it to pgp_curve_t */</span>
<a href="#l30.31"></a><span id="l30.31"> static bool</span>
<a href="#l30.32"></a><span id="l30.32" class="difflineat">@@ -656,19 +658,25 @@ stream_read_packet_body(pgp_source_t *sr</span>
<a href="#l30.33"></a><span id="l30.33">     body-&gt;hdr_len = len;</span>
<a href="#l30.34"></a><span id="l30.34"> </span>
<a href="#l30.35"></a><span id="l30.35">     int ptag = get_packet_type(body-&gt;hdr[0]);</span>
<a href="#l30.36"></a><span id="l30.36">     if (ptag &lt; 0) {</span>
<a href="#l30.37"></a><span id="l30.37">         return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l30.38"></a><span id="l30.38">     }</span>
<a href="#l30.39"></a><span id="l30.39">     body-&gt;tag = (pgp_pkt_type_t) ptag;</span>
<a href="#l30.40"></a><span id="l30.40"> </span>
<a href="#l30.41"></a><span id="l30.41" class="difflineminus">-    if (!stream_read_pkt_len(src, &amp;len) || !len) {</span>
<a href="#l30.42"></a><span id="l30.42" class="difflineplus">+    if (!stream_read_pkt_len(src, &amp;len)) {</span>
<a href="#l30.43"></a><span id="l30.43">         return RNP_ERROR_READ;</span>
<a href="#l30.44"></a><span id="l30.44">     }</span>
<a href="#l30.45"></a><span id="l30.45" class="difflineplus">+</span>
<a href="#l30.46"></a><span id="l30.46" class="difflineplus">+    /* early exit for the empty packet */</span>
<a href="#l30.47"></a><span id="l30.47" class="difflineplus">+    if (!len) {</span>
<a href="#l30.48"></a><span id="l30.48" class="difflineplus">+        return RNP_SUCCESS;</span>
<a href="#l30.49"></a><span id="l30.49" class="difflineplus">+    }</span>
<a href="#l30.50"></a><span id="l30.50" class="difflineplus">+</span>
<a href="#l30.51"></a><span id="l30.51">     if (len &gt; PGP_MAX_PKT_SIZE) {</span>
<a href="#l30.52"></a><span id="l30.52">         RNP_LOG(&quot;too large packet&quot;);</span>
<a href="#l30.53"></a><span id="l30.53">         return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l30.54"></a><span id="l30.54">     }</span>
<a href="#l30.55"></a><span id="l30.55"> </span>
<a href="#l30.56"></a><span id="l30.56">     /* Read the packet contents */</span>
<a href="#l30.57"></a><span id="l30.57">     if (!(body-&gt;data = (uint8_t *) malloc(len))) {</span>
<a href="#l30.58"></a><span id="l30.58">         RNP_LOG(&quot;malloc of %d bytes failed&quot;, (int) len);</span>
<a href="#l30.59"></a><span id="l30.59" class="difflineat">@@ -1122,23 +1130,25 @@ stream_parse_pk_sesskey(pgp_source_t *sr</span>
<a href="#l30.60"></a><span id="l30.60">     if (!get_packet_body_byte(&amp;pkt, &amp;bt)) {</span>
<a href="#l30.61"></a><span id="l30.61">         RNP_LOG(&quot;failed to get palg&quot;);</span>
<a href="#l30.62"></a><span id="l30.62">         goto finish;</span>
<a href="#l30.63"></a><span id="l30.63">     }</span>
<a href="#l30.64"></a><span id="l30.64">     pkey-&gt;alg = (pgp_pubkey_alg_t) bt;</span>
<a href="#l30.65"></a><span id="l30.65"> </span>
<a href="#l30.66"></a><span id="l30.66">     switch (pkey-&gt;alg) {</span>
<a href="#l30.67"></a><span id="l30.67">     case PGP_PKA_RSA:</span>
<a href="#l30.68"></a><span id="l30.68" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l30.69"></a><span id="l30.69">         /* RSA m */</span>
<a href="#l30.70"></a><span id="l30.70">         if (!get_packet_body_mpi(&amp;pkt, &amp;pkey-&gt;material.rsa.m)) {</span>
<a href="#l30.71"></a><span id="l30.71">             RNP_LOG(&quot;failed to get rsa m&quot;);</span>
<a href="#l30.72"></a><span id="l30.72">             goto finish;</span>
<a href="#l30.73"></a><span id="l30.73">         }</span>
<a href="#l30.74"></a><span id="l30.74">         break;</span>
<a href="#l30.75"></a><span id="l30.75">     case PGP_PKA_ELGAMAL:</span>
<a href="#l30.76"></a><span id="l30.76" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l30.77"></a><span id="l30.77">         /* ElGamal g, m */</span>
<a href="#l30.78"></a><span id="l30.78">         if (!get_packet_body_mpi(&amp;pkt, &amp;pkey-&gt;material.eg.g) ||</span>
<a href="#l30.79"></a><span id="l30.79">             !get_packet_body_mpi(&amp;pkt, &amp;pkey-&gt;material.eg.m)) {</span>
<a href="#l30.80"></a><span id="l30.80">             RNP_LOG(&quot;failed to get elgamal mpis&quot;);</span>
<a href="#l30.81"></a><span id="l30.81">             goto finish;</span>
<a href="#l30.82"></a><span id="l30.82">         }</span>
<a href="#l30.83"></a><span id="l30.83">         break;</span>
<a href="#l30.84"></a><span id="l30.84">     case PGP_PKA_SM2:</span>
<a href="#l30.85"></a><span id="l30.85" class="difflineat">@@ -1411,16 +1421,34 @@ signature_parse_subpacket(pgp_sig_subpkt</span>
<a href="#l30.86"></a><span id="l30.86">     }</span>
<a href="#l30.87"></a><span id="l30.87">     case PGP_SIG_SUBPKT_ISSUER_FPR:</span>
<a href="#l30.88"></a><span id="l30.88">         if ((oklen = subpkt-&gt;len &gt;= 21)) {</span>
<a href="#l30.89"></a><span id="l30.89">             subpkt-&gt;fields.issuer_fp.version = subpkt-&gt;data[0];</span>
<a href="#l30.90"></a><span id="l30.90">             subpkt-&gt;fields.issuer_fp.fp = &amp;subpkt-&gt;data[1];</span>
<a href="#l30.91"></a><span id="l30.91">             subpkt-&gt;fields.issuer_fp.len = subpkt-&gt;len - 1;</span>
<a href="#l30.92"></a><span id="l30.92">         }</span>
<a href="#l30.93"></a><span id="l30.93">         break;</span>
<a href="#l30.94"></a><span id="l30.94" class="difflineplus">+    case PGP_SIG_SUBPKT_PRIVATE_FIRST ... PGP_SIG_SUBPKT_PRIVATE_LAST:</span>
<a href="#l30.95"></a><span id="l30.95" class="difflineplus">+        oklen = true;</span>
<a href="#l30.96"></a><span id="l30.96" class="difflineplus">+        checked = !subpkt-&gt;critical;</span>
<a href="#l30.97"></a><span id="l30.97" class="difflineplus">+        if (!checked) {</span>
<a href="#l30.98"></a><span id="l30.98" class="difflineplus">+            RNP_LOG(&quot;unknown critical private subpacket %d&quot;, (int) subpkt-&gt;type);</span>
<a href="#l30.99"></a><span id="l30.99" class="difflineplus">+        }</span>
<a href="#l30.100"></a><span id="l30.100" class="difflineplus">+        break;</span>
<a href="#l30.101"></a><span id="l30.101" class="difflineplus">+    case PGP_SIG_SUBPKT_RESERVED_1:</span>
<a href="#l30.102"></a><span id="l30.102" class="difflineplus">+    case PGP_SIG_SUBPKT_RESERVED_8:</span>
<a href="#l30.103"></a><span id="l30.103" class="difflineplus">+    case PGP_SIG_SUBPKT_PLACEHOLDER:</span>
<a href="#l30.104"></a><span id="l30.104" class="difflineplus">+    case PGP_SIG_SUBPKT_RESERVED_13:</span>
<a href="#l30.105"></a><span id="l30.105" class="difflineplus">+    case PGP_SIG_SUBPKT_RESERVED_14:</span>
<a href="#l30.106"></a><span id="l30.106" class="difflineplus">+    case PGP_SIG_SUBPKT_RESERVED_15:</span>
<a href="#l30.107"></a><span id="l30.107" class="difflineplus">+    case PGP_SIG_SUBPKT_RESERVED_17:</span>
<a href="#l30.108"></a><span id="l30.108" class="difflineplus">+    case PGP_SIG_SUBPKT_RESERVED_18:</span>
<a href="#l30.109"></a><span id="l30.109" class="difflineplus">+    case PGP_SIG_SUBPKT_RESERVED_19:</span>
<a href="#l30.110"></a><span id="l30.110" class="difflineplus">+        /* do not report reserved/placeholder subpacket */</span>
<a href="#l30.111"></a><span id="l30.111" class="difflineplus">+        return !subpkt-&gt;critical;</span>
<a href="#l30.112"></a><span id="l30.112">     default:</span>
<a href="#l30.113"></a><span id="l30.113">         RNP_LOG(&quot;unknown subpacket : %d&quot;, (int) subpkt-&gt;type);</span>
<a href="#l30.114"></a><span id="l30.114">         return !subpkt-&gt;critical;</span>
<a href="#l30.115"></a><span id="l30.115">     }</span>
<a href="#l30.116"></a><span id="l30.116"> </span>
<a href="#l30.117"></a><span id="l30.117">     if (!oklen) {</span>
<a href="#l30.118"></a><span id="l30.118">         RNP_LOG(&quot;wrong len %d of subpacket type %d&quot;, (int) subpkt-&gt;len, (int) subpkt-&gt;type);</span>
<a href="#l30.119"></a><span id="l30.119">     }</span>
<a href="#l30.120"></a><span id="l30.120" class="difflineat">@@ -1621,16 +1649,17 @@ stream_parse_signature_body(pgp_packet_b</span>
<a href="#l30.121"></a><span id="l30.121">     if (!get_packet_body_buf(pkt, sig-&gt;lbits, 2)) {</span>
<a href="#l30.122"></a><span id="l30.122">         RNP_LOG(&quot;not enough data for hash left bits&quot;);</span>
<a href="#l30.123"></a><span id="l30.123">         goto finish;</span>
<a href="#l30.124"></a><span id="l30.124">     }</span>
<a href="#l30.125"></a><span id="l30.125"> </span>
<a href="#l30.126"></a><span id="l30.126">     /* signature MPIs */</span>
<a href="#l30.127"></a><span id="l30.127">     switch (sig-&gt;palg) {</span>
<a href="#l30.128"></a><span id="l30.128">     case PGP_PKA_RSA:</span>
<a href="#l30.129"></a><span id="l30.129" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l30.130"></a><span id="l30.130">         if (!get_packet_body_mpi(pkt, &amp;sig-&gt;material.rsa.s)) {</span>
<a href="#l30.131"></a><span id="l30.131">             goto finish;</span>
<a href="#l30.132"></a><span id="l30.132">         }</span>
<a href="#l30.133"></a><span id="l30.133">         break;</span>
<a href="#l30.134"></a><span id="l30.134">     case PGP_PKA_DSA:</span>
<a href="#l30.135"></a><span id="l30.135">         if (!get_packet_body_mpi(pkt, &amp;sig-&gt;material.dsa.r) ||</span>
<a href="#l30.136"></a><span id="l30.136">             !get_packet_body_mpi(pkt, &amp;sig-&gt;material.dsa.s)) {</span>
<a href="#l30.137"></a><span id="l30.137">             goto finish;</span>
<a href="#l30.138"></a><span id="l30.138" class="difflineat">@@ -1644,16 +1673,17 @@ stream_parse_signature_body(pgp_packet_b</span>
<a href="#l30.139"></a><span id="l30.139">     case PGP_PKA_ECDSA:</span>
<a href="#l30.140"></a><span id="l30.140">     case PGP_PKA_SM2:</span>
<a href="#l30.141"></a><span id="l30.141">     case PGP_PKA_ECDH:</span>
<a href="#l30.142"></a><span id="l30.142">         if (!get_packet_body_mpi(pkt, &amp;sig-&gt;material.ecc.r) ||</span>
<a href="#l30.143"></a><span id="l30.143">             !get_packet_body_mpi(pkt, &amp;sig-&gt;material.ecc.s)) {</span>
<a href="#l30.144"></a><span id="l30.144">             goto finish;</span>
<a href="#l30.145"></a><span id="l30.145">         }</span>
<a href="#l30.146"></a><span id="l30.146">         break;</span>
<a href="#l30.147"></a><span id="l30.147" class="difflineplus">+    case PGP_PKA_ELGAMAL: /* we support reading it but will not validate */</span>
<a href="#l30.148"></a><span id="l30.148">     case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l30.149"></a><span id="l30.149">         if (!get_packet_body_mpi(pkt, &amp;sig-&gt;material.eg.r) ||</span>
<a href="#l30.150"></a><span id="l30.150">             !get_packet_body_mpi(pkt, &amp;sig-&gt;material.eg.s)) {</span>
<a href="#l30.151"></a><span id="l30.151">             goto finish;</span>
<a href="#l30.152"></a><span id="l30.152">         }</span>
<a href="#l30.153"></a><span id="l30.153">         break;</span>
<a href="#l30.154"></a><span id="l30.154">     default:</span>
<a href="#l30.155"></a><span id="l30.155">         RNP_LOG(&quot;Unknown pk algorithm : %d&quot;, (int) sig-&gt;palg);</span>
<a href="#l30.156"></a><span id="l30.156" class="difflineat">@@ -1741,16 +1771,17 @@ signature_pkt_equal(const pgp_signature_</span>
<a href="#l30.157"></a><span id="l30.157"> </span>
<a href="#l30.158"></a><span id="l30.158">     if ((sig1-&gt;hashed_len != sig2-&gt;hashed_len) ||</span>
<a href="#l30.159"></a><span id="l30.159">         memcmp(sig1-&gt;hashed_data, sig2-&gt;hashed_data, sig1-&gt;hashed_len)) {</span>
<a href="#l30.160"></a><span id="l30.160">         return false;</span>
<a href="#l30.161"></a><span id="l30.161">     }</span>
<a href="#l30.162"></a><span id="l30.162"> </span>
<a href="#l30.163"></a><span id="l30.163">     switch (sig1-&gt;palg) {</span>
<a href="#l30.164"></a><span id="l30.164">     case PGP_PKA_RSA:</span>
<a href="#l30.165"></a><span id="l30.165" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l30.166"></a><span id="l30.166">         return mpi_equal(&amp;sig1-&gt;material.rsa.s, &amp;sig2-&gt;material.rsa.s);</span>
<a href="#l30.167"></a><span id="l30.167">     case PGP_PKA_DSA:</span>
<a href="#l30.168"></a><span id="l30.168">         return mpi_equal(&amp;sig1-&gt;material.dsa.r, &amp;sig2-&gt;material.dsa.r) &amp;&amp;</span>
<a href="#l30.169"></a><span id="l30.169">                mpi_equal(&amp;sig1-&gt;material.dsa.s, &amp;sig2-&gt;material.dsa.s);</span>
<a href="#l30.170"></a><span id="l30.170">     case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l30.171"></a><span id="l30.171">         return mpi_equal(&amp;sig1-&gt;material.eg.r, &amp;sig2-&gt;material.eg.r) &amp;&amp;</span>
<a href="#l30.172"></a><span id="l30.172">                mpi_equal(&amp;sig1-&gt;material.eg.s, &amp;sig2-&gt;material.eg.s);</span>
<a href="#l30.173"></a><span id="l30.173">     case PGP_PKA_EDDSA:</span>
<a href="#l30.174"></a><span id="l30.174" class="difflineat">@@ -1959,17 +1990,16 @@ stream_write_key(pgp_key_pkt_t *key, pgp</span>
<a href="#l30.175"></a><span id="l30.175">             res = false;</span>
<a href="#l30.176"></a><span id="l30.176">             goto finish;</span>
<a href="#l30.177"></a><span id="l30.177">         }</span>
<a href="#l30.178"></a><span id="l30.178">         if (!(res = add_packet_body_byte(&amp;pktbody, key-&gt;sec_protection.s2k.usage))) {</span>
<a href="#l30.179"></a><span id="l30.179">             goto finish;</span>
<a href="#l30.180"></a><span id="l30.180">         }</span>
<a href="#l30.181"></a><span id="l30.181">         switch (key-&gt;sec_protection.s2k.usage) {</span>
<a href="#l30.182"></a><span id="l30.182">         case PGP_S2KU_NONE:</span>
<a href="#l30.183"></a><span id="l30.183" class="difflineminus">-            res = true;</span>
<a href="#l30.184"></a><span id="l30.184">             break;</span>
<a href="#l30.185"></a><span id="l30.185">         case PGP_S2KU_ENCRYPTED_AND_HASHED:</span>
<a href="#l30.186"></a><span id="l30.186">         case PGP_S2KU_ENCRYPTED: {</span>
<a href="#l30.187"></a><span id="l30.187">             size_t blsize = pgp_block_size(key-&gt;sec_protection.symm_alg);</span>
<a href="#l30.188"></a><span id="l30.188">             if (!blsize) {</span>
<a href="#l30.189"></a><span id="l30.189">                 res = false;</span>
<a href="#l30.190"></a><span id="l30.190">                 goto finish;</span>
<a href="#l30.191"></a><span id="l30.191">             }</span>
<a href="#l30.192"></a><span id="l30.192" class="difflineat">@@ -2287,27 +2317,27 @@ stream_write_userid(const pgp_userid_pkt</span>
<a href="#l30.193"></a><span id="l30.193">     pgp_packet_body_t pktbody;</span>
<a href="#l30.194"></a><span id="l30.194">     bool              res;</span>
<a href="#l30.195"></a><span id="l30.195"> </span>
<a href="#l30.196"></a><span id="l30.196">     if ((userid-&gt;tag != PGP_PKT_USER_ID) &amp;&amp; (userid-&gt;tag != PGP_PKT_USER_ATTR)) {</span>
<a href="#l30.197"></a><span id="l30.197">         RNP_LOG(&quot;wrong userid tag&quot;);</span>
<a href="#l30.198"></a><span id="l30.198">         return false;</span>
<a href="#l30.199"></a><span id="l30.199">     }</span>
<a href="#l30.200"></a><span id="l30.200"> </span>
<a href="#l30.201"></a><span id="l30.201" class="difflineminus">-    if (!userid-&gt;uid || !userid-&gt;uid_len) {</span>
<a href="#l30.202"></a><span id="l30.202" class="difflineminus">-        RNP_LOG(&quot;empty or null userid&quot;);</span>
<a href="#l30.203"></a><span id="l30.203" class="difflineplus">+    if (userid-&gt;uid_len &amp;&amp; !userid-&gt;uid) {</span>
<a href="#l30.204"></a><span id="l30.204" class="difflineplus">+        RNP_LOG(&quot;null but non-empty userid&quot;);</span>
<a href="#l30.205"></a><span id="l30.205">         return false;</span>
<a href="#l30.206"></a><span id="l30.206">     }</span>
<a href="#l30.207"></a><span id="l30.207"> </span>
<a href="#l30.208"></a><span id="l30.208">     if (!init_packet_body(&amp;pktbody, userid-&gt;tag)) {</span>
<a href="#l30.209"></a><span id="l30.209">         RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l30.210"></a><span id="l30.210">         return false;</span>
<a href="#l30.211"></a><span id="l30.211">     }</span>
<a href="#l30.212"></a><span id="l30.212"> </span>
<a href="#l30.213"></a><span id="l30.213" class="difflineminus">-    res = add_packet_body(&amp;pktbody, userid-&gt;uid, userid-&gt;uid_len);</span>
<a href="#l30.214"></a><span id="l30.214" class="difflineplus">+    res = userid-&gt;uid ? add_packet_body(&amp;pktbody, userid-&gt;uid, userid-&gt;uid_len) : true;</span>
<a href="#l30.215"></a><span id="l30.215"> </span>
<a href="#l30.216"></a><span id="l30.216">     if (res) {</span>
<a href="#l30.217"></a><span id="l30.217">         stream_flush_packet_body(&amp;pktbody, dst);</span>
<a href="#l30.218"></a><span id="l30.218">         res = dst-&gt;werr == RNP_SUCCESS;</span>
<a href="#l30.219"></a><span id="l30.219">     } else {</span>
<a href="#l30.220"></a><span id="l30.220">         free_packet_body(&amp;pktbody);</span>
<a href="#l30.221"></a><span id="l30.221">     }</span>
<a href="#l30.222"></a><span id="l30.222"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-parse.cpp</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-parse.cpp</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -1285,32 +1285,34 @@ encrypted_try_key(pgp_source_encrypted_p</span>
<a href="#l31.4"></a><span id="l31.4">     pgp_symm_alg_t      salg;</span>
<a href="#l31.5"></a><span id="l31.5">     unsigned            checksum = 0;</span>
<a href="#l31.6"></a><span id="l31.6">     bool                res = false;</span>
<a href="#l31.7"></a><span id="l31.7">     pgp_key_material_t *keymaterial = &amp;seckey-&gt;material;</span>
<a href="#l31.8"></a><span id="l31.8"> </span>
<a href="#l31.9"></a><span id="l31.9">     /* Decrypting session key value */</span>
<a href="#l31.10"></a><span id="l31.10">     switch (sesskey-&gt;alg) {</span>
<a href="#l31.11"></a><span id="l31.11">     case PGP_PKA_RSA:</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineplus">+    case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l31.13"></a><span id="l31.13">         err =</span>
<a href="#l31.14"></a><span id="l31.14">           rsa_decrypt_pkcs1(rng, decbuf, &amp;declen, &amp;sesskey-&gt;material.rsa, &amp;keymaterial-&gt;rsa);</span>
<a href="#l31.15"></a><span id="l31.15">         if (err) {</span>
<a href="#l31.16"></a><span id="l31.16">             RNP_LOG(&quot;RSA decryption failure&quot;);</span>
<a href="#l31.17"></a><span id="l31.17">             return false;</span>
<a href="#l31.18"></a><span id="l31.18">         }</span>
<a href="#l31.19"></a><span id="l31.19">         break;</span>
<a href="#l31.20"></a><span id="l31.20">     case PGP_PKA_SM2:</span>
<a href="#l31.21"></a><span id="l31.21">         declen = sizeof(decbuf);</span>
<a href="#l31.22"></a><span id="l31.22">         err = sm2_decrypt(decbuf, &amp;declen, &amp;sesskey-&gt;material.sm2, &amp;keymaterial-&gt;ec);</span>
<a href="#l31.23"></a><span id="l31.23">         if (err != RNP_SUCCESS) {</span>
<a href="#l31.24"></a><span id="l31.24">             RNP_LOG(&quot;SM2 decryption failure, error %x&quot;, (int) err);</span>
<a href="#l31.25"></a><span id="l31.25">             return false;</span>
<a href="#l31.26"></a><span id="l31.26">         }</span>
<a href="#l31.27"></a><span id="l31.27">         break;</span>
<a href="#l31.28"></a><span id="l31.28" class="difflineminus">-    case PGP_PKA_ELGAMAL: {</span>
<a href="#l31.29"></a><span id="l31.29" class="difflineplus">+    case PGP_PKA_ELGAMAL:</span>
<a href="#l31.30"></a><span id="l31.30" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN: {</span>
<a href="#l31.31"></a><span id="l31.31">         const rnp_result_t ret =</span>
<a href="#l31.32"></a><span id="l31.32">           elgamal_decrypt_pkcs1(rng, decbuf, &amp;declen, &amp;sesskey-&gt;material.eg, &amp;keymaterial-&gt;eg);</span>
<a href="#l31.33"></a><span id="l31.33">         if (ret) {</span>
<a href="#l31.34"></a><span id="l31.34">             RNP_LOG(&quot;ElGamal decryption failure [%X]&quot;, ret);</span>
<a href="#l31.35"></a><span id="l31.35">             return false;</span>
<a href="#l31.36"></a><span id="l31.36">         }</span>
<a href="#l31.37"></a><span id="l31.37">         break;</span>
<a href="#l31.38"></a><span id="l31.38">     }</span>
<a href="#l31.39"></a><span id="l31.39" class="difflineat">@@ -1389,17 +1391,16 @@ encrypted_sesk_set_ad(pgp_crypt_t *crypt</span>
<a href="#l31.40"></a><span id="l31.40"> static int</span>
<a href="#l31.41"></a><span id="l31.41"> encrypted_try_password(pgp_source_encrypted_param_t *param, const char *password)</span>
<a href="#l31.42"></a><span id="l31.42"> {</span>
<a href="#l31.43"></a><span id="l31.43">     pgp_crypt_t    crypt;</span>
<a href="#l31.44"></a><span id="l31.44">     pgp_symm_alg_t alg;</span>
<a href="#l31.45"></a><span id="l31.45">     uint8_t        keybuf[PGP_MAX_KEY_SIZE + 1];</span>
<a href="#l31.46"></a><span id="l31.46">     uint8_t        nonce[PGP_AEAD_MAX_NONCE_LEN];</span>
<a href="#l31.47"></a><span id="l31.47">     size_t         keysize;</span>
<a href="#l31.48"></a><span id="l31.48" class="difflineminus">-    size_t         blsize;</span>
<a href="#l31.49"></a><span id="l31.49">     bool           keyavail = false; /* tried password at least once */</span>
<a href="#l31.50"></a><span id="l31.50">     bool           decres;</span>
<a href="#l31.51"></a><span id="l31.51">     int            res;</span>
<a href="#l31.52"></a><span id="l31.52"> </span>
<a href="#l31.53"></a><span id="l31.53">     for (list_item *se = list_front(param-&gt;symencs); se; se = list_next(se)) {</span>
<a href="#l31.54"></a><span id="l31.54">         /* deriving symmetric key from password */</span>
<a href="#l31.55"></a><span id="l31.55">         pgp_sk_sesskey_t *skey = (pgp_sk_sesskey_t *) se;</span>
<a href="#l31.56"></a><span id="l31.56"> </span>
<a href="#l31.57"></a><span id="l31.57" class="difflineat">@@ -1425,17 +1426,17 @@ encrypted_try_password(pgp_source_encryp</span>
<a href="#l31.58"></a><span id="l31.58">                 if (!keysize || (keysize + 1 != skey-&gt;enckeylen)) {</span>
<a href="#l31.59"></a><span id="l31.59">                     continue;</span>
<a href="#l31.60"></a><span id="l31.60">                 }</span>
<a href="#l31.61"></a><span id="l31.61">                 memmove(keybuf, keybuf + 1, keysize);</span>
<a href="#l31.62"></a><span id="l31.62">             } else {</span>
<a href="#l31.63"></a><span id="l31.63">                 alg = (pgp_symm_alg_t) skey-&gt;alg;</span>
<a href="#l31.64"></a><span id="l31.64">             }</span>
<a href="#l31.65"></a><span id="l31.65"> </span>
<a href="#l31.66"></a><span id="l31.66" class="difflineminus">-            if (!(blsize = pgp_block_size(alg))) {</span>
<a href="#l31.67"></a><span id="l31.67" class="difflineplus">+            if (!pgp_block_size(alg)) {</span>
<a href="#l31.68"></a><span id="l31.68">                 continue;</span>
<a href="#l31.69"></a><span id="l31.69">             }</span>
<a href="#l31.70"></a><span id="l31.70"> </span>
<a href="#l31.71"></a><span id="l31.71">             keyavail = true;</span>
<a href="#l31.72"></a><span id="l31.72">         } else if (skey-&gt;version == PGP_SKSK_V5) {</span>
<a href="#l31.73"></a><span id="l31.73">             /* v5 AEAD-encrypted session key */</span>
<a href="#l31.74"></a><span id="l31.74">             size_t taglen = pgp_cipher_aead_tag_len(skey-&gt;aalg);</span>
<a href="#l31.75"></a><span id="l31.75">             size_t noncelen;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-sig.cpp</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-sig.cpp</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -1012,96 +1012,16 @@ signature_hash_direct(const pgp_signatur</span>
<a href="#l32.4"></a><span id="l32.4">     if (!res) {</span>
<a href="#l32.5"></a><span id="l32.5">         pgp_hash_finish(hash, NULL);</span>
<a href="#l32.6"></a><span id="l32.6">     }</span>
<a href="#l32.7"></a><span id="l32.7"> </span>
<a href="#l32.8"></a><span id="l32.8">     return res;</span>
<a href="#l32.9"></a><span id="l32.9"> }</span>
<a href="#l32.10"></a><span id="l32.10"> </span>
<a href="#l32.11"></a><span id="l32.11"> rnp_result_t</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-signature_validate_certification(const pgp_signature_t *   sig,</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineminus">-                                 const pgp_key_pkt_t *     key,</span>
<a href="#l32.14"></a><span id="l32.14" class="difflineminus">-                                 const pgp_userid_pkt_t *  uid,</span>
<a href="#l32.15"></a><span id="l32.15" class="difflineminus">-                                 const pgp_key_material_t *signer)</span>
<a href="#l32.16"></a><span id="l32.16" class="difflineminus">-{</span>
<a href="#l32.17"></a><span id="l32.17" class="difflineminus">-    pgp_hash_t hash = {0};</span>
<a href="#l32.18"></a><span id="l32.18" class="difflineminus">-</span>
<a href="#l32.19"></a><span id="l32.19" class="difflineminus">-    if (!signature_hash_certification(sig, key, uid, &amp;hash)) {</span>
<a href="#l32.20"></a><span id="l32.20" class="difflineminus">-        return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l32.21"></a><span id="l32.21" class="difflineminus">-    }</span>
<a href="#l32.22"></a><span id="l32.22" class="difflineminus">-</span>
<a href="#l32.23"></a><span id="l32.23" class="difflineminus">-    return signature_validate(sig, signer, &amp;hash);</span>
<a href="#l32.24"></a><span id="l32.24" class="difflineminus">-}</span>
<a href="#l32.25"></a><span id="l32.25" class="difflineminus">-</span>
<a href="#l32.26"></a><span id="l32.26" class="difflineminus">-rnp_result_t</span>
<a href="#l32.27"></a><span id="l32.27" class="difflineminus">-signature_validate_binding(const pgp_signature_t *sig,</span>
<a href="#l32.28"></a><span id="l32.28" class="difflineminus">-                           const pgp_key_pkt_t *  key,</span>
<a href="#l32.29"></a><span id="l32.29" class="difflineminus">-                           const pgp_key_pkt_t *  subkey)</span>
<a href="#l32.30"></a><span id="l32.30" class="difflineminus">-{</span>
<a href="#l32.31"></a><span id="l32.31" class="difflineminus">-    pgp_hash_t   hash = {};</span>
<a href="#l32.32"></a><span id="l32.32" class="difflineminus">-    pgp_hash_t   hashcp = {};</span>
<a href="#l32.33"></a><span id="l32.33" class="difflineminus">-    rnp_result_t res = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l32.34"></a><span id="l32.34" class="difflineminus">-</span>
<a href="#l32.35"></a><span id="l32.35" class="difflineminus">-    if (!signature_hash_binding(sig, key, subkey, &amp;hash)) {</span>
<a href="#l32.36"></a><span id="l32.36" class="difflineminus">-        return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l32.37"></a><span id="l32.37" class="difflineminus">-    }</span>
<a href="#l32.38"></a><span id="l32.38" class="difflineminus">-</span>
<a href="#l32.39"></a><span id="l32.39" class="difflineminus">-    if (!pgp_hash_copy(&amp;hashcp, &amp;hash)) {</span>
<a href="#l32.40"></a><span id="l32.40" class="difflineminus">-        RNP_LOG(&quot;hash copy failed&quot;);</span>
<a href="#l32.41"></a><span id="l32.41" class="difflineminus">-        return RNP_ERROR_BAD_STATE;</span>
<a href="#l32.42"></a><span id="l32.42" class="difflineminus">-    }</span>
<a href="#l32.43"></a><span id="l32.43" class="difflineminus">-</span>
<a href="#l32.44"></a><span id="l32.44" class="difflineminus">-    res = signature_validate(sig, &amp;key-&gt;material, &amp;hash);</span>
<a href="#l32.45"></a><span id="l32.45" class="difflineminus">-</span>
<a href="#l32.46"></a><span id="l32.46" class="difflineminus">-    /* check primary key binding signature if any */</span>
<a href="#l32.47"></a><span id="l32.47" class="difflineminus">-    if (!res &amp;&amp; (signature_get_key_flags(sig) &amp; PGP_KF_SIGN)) {</span>
<a href="#l32.48"></a><span id="l32.48" class="difflineminus">-        pgp_sig_subpkt_t *subpkt =</span>
<a href="#l32.49"></a><span id="l32.49" class="difflineminus">-          signature_get_subpkt(sig, PGP_SIG_SUBPKT_EMBEDDED_SIGNATURE);</span>
<a href="#l32.50"></a><span id="l32.50" class="difflineminus">-        if (!subpkt) {</span>
<a href="#l32.51"></a><span id="l32.51" class="difflineminus">-            RNP_LOG(&quot;error! no primary key binding signature&quot;);</span>
<a href="#l32.52"></a><span id="l32.52" class="difflineminus">-            res = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l32.53"></a><span id="l32.53" class="difflineminus">-            goto finish;</span>
<a href="#l32.54"></a><span id="l32.54" class="difflineminus">-        }</span>
<a href="#l32.55"></a><span id="l32.55" class="difflineminus">-        if (!subpkt-&gt;parsed) {</span>
<a href="#l32.56"></a><span id="l32.56" class="difflineminus">-            RNP_LOG(&quot;invalid embedded signature subpacket&quot;);</span>
<a href="#l32.57"></a><span id="l32.57" class="difflineminus">-            res = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l32.58"></a><span id="l32.58" class="difflineminus">-            goto finish;</span>
<a href="#l32.59"></a><span id="l32.59" class="difflineminus">-        }</span>
<a href="#l32.60"></a><span id="l32.60" class="difflineminus">-        if (subpkt-&gt;fields.sig.type != PGP_SIG_PRIMARY) {</span>
<a href="#l32.61"></a><span id="l32.61" class="difflineminus">-            RNP_LOG(&quot;invalid primary key binding signature&quot;);</span>
<a href="#l32.62"></a><span id="l32.62" class="difflineminus">-            res = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l32.63"></a><span id="l32.63" class="difflineminus">-            goto finish;</span>
<a href="#l32.64"></a><span id="l32.64" class="difflineminus">-        }</span>
<a href="#l32.65"></a><span id="l32.65" class="difflineminus">-        if (subpkt-&gt;fields.sig.version &lt; PGP_V4) {</span>
<a href="#l32.66"></a><span id="l32.66" class="difflineminus">-            RNP_LOG(&quot;invalid primary key binding signature version&quot;);</span>
<a href="#l32.67"></a><span id="l32.67" class="difflineminus">-            res = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l32.68"></a><span id="l32.68" class="difflineminus">-            goto finish;</span>
<a href="#l32.69"></a><span id="l32.69" class="difflineminus">-        }</span>
<a href="#l32.70"></a><span id="l32.70" class="difflineminus">-        res = signature_validate(&amp;subpkt-&gt;fields.sig, &amp;subkey-&gt;material, &amp;hashcp);</span>
<a href="#l32.71"></a><span id="l32.71" class="difflineminus">-    }</span>
<a href="#l32.72"></a><span id="l32.72" class="difflineminus">-finish:</span>
<a href="#l32.73"></a><span id="l32.73" class="difflineminus">-    pgp_hash_finish(&amp;hashcp, NULL);</span>
<a href="#l32.74"></a><span id="l32.74" class="difflineminus">-    return res;</span>
<a href="#l32.75"></a><span id="l32.75" class="difflineminus">-}</span>
<a href="#l32.76"></a><span id="l32.76" class="difflineminus">-</span>
<a href="#l32.77"></a><span id="l32.77" class="difflineminus">-rnp_result_t</span>
<a href="#l32.78"></a><span id="l32.78" class="difflineminus">-signature_validate_direct(const pgp_signature_t *   sig,</span>
<a href="#l32.79"></a><span id="l32.79" class="difflineminus">-                          const pgp_key_pkt_t *     key,</span>
<a href="#l32.80"></a><span id="l32.80" class="difflineminus">-                          const pgp_key_material_t *signer)</span>
<a href="#l32.81"></a><span id="l32.81" class="difflineminus">-{</span>
<a href="#l32.82"></a><span id="l32.82" class="difflineminus">-    pgp_hash_t hash = {0};</span>
<a href="#l32.83"></a><span id="l32.83" class="difflineminus">-</span>
<a href="#l32.84"></a><span id="l32.84" class="difflineminus">-    if (!signature_hash_direct(sig, key, &amp;hash)) {</span>
<a href="#l32.85"></a><span id="l32.85" class="difflineminus">-        return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l32.86"></a><span id="l32.86" class="difflineminus">-    }</span>
<a href="#l32.87"></a><span id="l32.87" class="difflineminus">-</span>
<a href="#l32.88"></a><span id="l32.88" class="difflineminus">-    return signature_validate(sig, signer, &amp;hash);</span>
<a href="#l32.89"></a><span id="l32.89" class="difflineminus">-}</span>
<a href="#l32.90"></a><span id="l32.90" class="difflineminus">-</span>
<a href="#l32.91"></a><span id="l32.91" class="difflineminus">-rnp_result_t</span>
<a href="#l32.92"></a><span id="l32.92"> signature_check(pgp_signature_info_t *sinfo, pgp_hash_t *hash)</span>
<a href="#l32.93"></a><span id="l32.93"> {</span>
<a href="#l32.94"></a><span id="l32.94">     time_t            now;</span>
<a href="#l32.95"></a><span id="l32.95">     uint32_t          create, expiry, kcreate;</span>
<a href="#l32.96"></a><span id="l32.96">     pgp_fingerprint_t fp = {};</span>
<a href="#l32.97"></a><span id="l32.97">     rnp_result_t      ret = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l32.98"></a><span id="l32.98"> </span>
<a href="#l32.99"></a><span id="l32.99">     sinfo-&gt;no_signer = !sinfo-&gt;signer;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-sig.h</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-sig.h</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -322,29 +322,16 @@ bool signature_hash_binding(const pgp_si</span>
<a href="#l33.4"></a><span id="l33.4">                             const pgp_key_pkt_t *  key,</span>
<a href="#l33.5"></a><span id="l33.5">                             const pgp_key_pkt_t *  subkey,</span>
<a href="#l33.6"></a><span id="l33.6">                             pgp_hash_t *           hash);</span>
<a href="#l33.7"></a><span id="l33.7"> </span>
<a href="#l33.8"></a><span id="l33.8"> bool signature_hash_direct(const pgp_signature_t *sig,</span>
<a href="#l33.9"></a><span id="l33.9">                            const pgp_key_pkt_t *  key,</span>
<a href="#l33.10"></a><span id="l33.10">                            pgp_hash_t *           hash);</span>
<a href="#l33.11"></a><span id="l33.11"> </span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">-rnp_result_t signature_validate_certification(const pgp_signature_t *   sig,</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineminus">-                                              const pgp_key_pkt_t *     key,</span>
<a href="#l33.14"></a><span id="l33.14" class="difflineminus">-                                              const pgp_userid_pkt_t *  uid,</span>
<a href="#l33.15"></a><span id="l33.15" class="difflineminus">-                                              const pgp_key_material_t *signer);</span>
<a href="#l33.16"></a><span id="l33.16" class="difflineminus">-</span>
<a href="#l33.17"></a><span id="l33.17" class="difflineminus">-rnp_result_t signature_validate_binding(const pgp_signature_t *sig,</span>
<a href="#l33.18"></a><span id="l33.18" class="difflineminus">-                                        const pgp_key_pkt_t *  key,</span>
<a href="#l33.19"></a><span id="l33.19" class="difflineminus">-                                        const pgp_key_pkt_t *  subkey);</span>
<a href="#l33.20"></a><span id="l33.20" class="difflineminus">-</span>
<a href="#l33.21"></a><span id="l33.21" class="difflineminus">-rnp_result_t signature_validate_direct(const pgp_signature_t *   sig,</span>
<a href="#l33.22"></a><span id="l33.22" class="difflineminus">-                                       const pgp_key_pkt_t *     key,</span>
<a href="#l33.23"></a><span id="l33.23" class="difflineminus">-                                       const pgp_key_material_t *signer);</span>
<a href="#l33.24"></a><span id="l33.24" class="difflineminus">-</span>
<a href="#l33.25"></a><span id="l33.25"> /**</span>
<a href="#l33.26"></a><span id="l33.26">  * @brief Check signature, including the expiration time, key validity and so on.</span>
<a href="#l33.27"></a><span id="l33.27">  *</span>
<a href="#l33.28"></a><span id="l33.28">  * @param sinfo populated signature info structure. Method will set flags valid, no_signer,</span>
<a href="#l33.29"></a><span id="l33.29">  *              expired.</span>
<a href="#l33.30"></a><span id="l33.30">  * @param hash populated hash</span>
<a href="#l33.31"></a><span id="l33.31">  * @return RNP_SUCCESS if all checks were passed, RNP_ERROR_SIGNATURE_INVALID for invalid sig,</span>
<a href="#l33.32"></a><span id="l33.32">  *         RNP_ERROR_SIGNATURE_EXPIRED for expired signature. Other error code means problems</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/third_party/rnp/src/rnp/fficli.cpp</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/third_party/rnp/src/rnp/fficli.cpp</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -194,17 +194,16 @@ stdin_getpass(const char *prompt, char *</span>
<a href="#l34.4"></a><span id="l34.4">     }</span>
<a href="#l34.5"></a><span id="l34.5">     // doesn't hurt</span>
<a href="#l34.6"></a><span id="l34.6">     *buffer = '\0';</span>
<a href="#l34.7"></a><span id="l34.7"> </span>
<a href="#l34.8"></a><span id="l34.8"> #ifndef _WIN32</span>
<a href="#l34.9"></a><span id="l34.9">     in = fopen(&quot;/dev/tty&quot;, &quot;w+ce&quot;);</span>
<a href="#l34.10"></a><span id="l34.10"> #endif</span>
<a href="#l34.11"></a><span id="l34.11">     if (!in) {</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-        in = stdin;</span>
<a href="#l34.13"></a><span id="l34.13">         in = userio_in;</span>
<a href="#l34.14"></a><span id="l34.14">         out = stderr;</span>
<a href="#l34.15"></a><span id="l34.15">     } else {</span>
<a href="#l34.16"></a><span id="l34.16">         out = in;</span>
<a href="#l34.17"></a><span id="l34.17">     }</span>
<a href="#l34.18"></a><span id="l34.18"> </span>
<a href="#l34.19"></a><span id="l34.19">     // TODO: Implement alternative for hiding password entry on Windows</span>
<a href="#l34.20"></a><span id="l34.20">     // TODO: avoid duplicate termios code with pass-provider.cpp</span>
<a href="#l34.21"></a><span id="l34.21" class="difflineat">@@ -1212,18 +1211,18 @@ add_key_to_array(rnp_ffi_t              </span>
<a href="#l34.22"></a><span id="l34.22">     bool subkey = false;</span>
<a href="#l34.23"></a><span id="l34.23">     bool subkeys = (flags &amp; CLI_SEARCH_SUBKEYS_AFTER) == CLI_SEARCH_SUBKEYS_AFTER;</span>
<a href="#l34.24"></a><span id="l34.24">     if (rnp_key_is_sub(key, &amp;subkey)) {</span>
<a href="#l34.25"></a><span id="l34.25">         return false;</span>
<a href="#l34.26"></a><span id="l34.26">     }</span>
<a href="#l34.27"></a><span id="l34.27"> </span>
<a href="#l34.28"></a><span id="l34.28">     try {</span>
<a href="#l34.29"></a><span id="l34.29">         keys.push_back(key);</span>
<a href="#l34.30"></a><span id="l34.30" class="difflineminus">-    } catch (...) {</span>
<a href="#l34.31"></a><span id="l34.31" class="difflineminus">-        ERR_MSG(&quot;allocation failed&quot;);</span>
<a href="#l34.32"></a><span id="l34.32" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l34.33"></a><span id="l34.33" class="difflineplus">+        ERR_MSG(&quot;%s&quot;, e.what());</span>
<a href="#l34.34"></a><span id="l34.34">         return false;</span>
<a href="#l34.35"></a><span id="l34.35">     }</span>
<a href="#l34.36"></a><span id="l34.36">     if (!subkeys || subkey) {</span>
<a href="#l34.37"></a><span id="l34.37">         return true;</span>
<a href="#l34.38"></a><span id="l34.38">     }</span>
<a href="#l34.39"></a><span id="l34.39"> </span>
<a href="#l34.40"></a><span id="l34.40">     std::vector&lt;rnp_key_handle_t&gt; subs;</span>
<a href="#l34.41"></a><span id="l34.41">     size_t                        sub_count = 0;</span>
<a href="#l34.42"></a><span id="l34.42" class="difflineat">@@ -1235,18 +1234,18 @@ add_key_to_array(rnp_ffi_t              </span>
<a href="#l34.43"></a><span id="l34.43">         for (size_t i = 0; i &lt; sub_count; i++) {</span>
<a href="#l34.44"></a><span id="l34.44">             rnp_key_handle_t sub_handle = NULL;</span>
<a href="#l34.45"></a><span id="l34.45">             if (rnp_key_get_subkey_at(key, i, &amp;sub_handle)) {</span>
<a href="#l34.46"></a><span id="l34.46">                 goto error;</span>
<a href="#l34.47"></a><span id="l34.47">             }</span>
<a href="#l34.48"></a><span id="l34.48">             subs.push_back(sub_handle);</span>
<a href="#l34.49"></a><span id="l34.49">         }</span>
<a href="#l34.50"></a><span id="l34.50">         std::move(subs.begin(), subs.end(), std::back_inserter(keys));</span>
<a href="#l34.51"></a><span id="l34.51" class="difflineminus">-    } catch (...) {</span>
<a href="#l34.52"></a><span id="l34.52" class="difflineminus">-        ERR_MSG(&quot;allocation or move failed&quot;);</span>
<a href="#l34.53"></a><span id="l34.53" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l34.54"></a><span id="l34.54" class="difflineplus">+        ERR_MSG(&quot;%s&quot;, e.what());</span>
<a href="#l34.55"></a><span id="l34.55">         goto error;</span>
<a href="#l34.56"></a><span id="l34.56">     }</span>
<a href="#l34.57"></a><span id="l34.57">     return true;</span>
<a href="#l34.58"></a><span id="l34.58"> error:</span>
<a href="#l34.59"></a><span id="l34.59">     keys.pop_back();</span>
<a href="#l34.60"></a><span id="l34.60">     clear_key_handles(subs);</span>
<a href="#l34.61"></a><span id="l34.61">     return false;</span>
<a href="#l34.62"></a><span id="l34.62"> }</span>
<a href="#l34.63"></a><span id="l34.63" class="difflineat">@@ -1310,17 +1309,17 @@ cli_rnp_keys_matching_strings(cli_rnp_t </span>
<a href="#l34.64"></a><span id="l34.64">     }</span>
<a href="#l34.65"></a><span id="l34.65"> </span>
<a href="#l34.66"></a><span id="l34.66">     /* search for default key */</span>
<a href="#l34.67"></a><span id="l34.67">     if (keys.empty() &amp;&amp; (flags &amp; CLI_SEARCH_DEFAULT)) {</span>
<a href="#l34.68"></a><span id="l34.68">         if (cli_rnp_defkey(rnp).empty()) {</span>
<a href="#l34.69"></a><span id="l34.69">             ERR_MSG(&quot;No userid or default key for operation&quot;);</span>
<a href="#l34.70"></a><span id="l34.70">             goto done;</span>
<a href="#l34.71"></a><span id="l34.71">         }</span>
<a href="#l34.72"></a><span id="l34.72" class="difflineminus">-        res = cli_rnp_keys_matching_string(</span>
<a href="#l34.73"></a><span id="l34.73" class="difflineplus">+        cli_rnp_keys_matching_string(</span>
<a href="#l34.74"></a><span id="l34.74">           rnp, keys, cli_rnp_defkey(rnp), flags &amp; ~CLI_SEARCH_DEFAULT);</span>
<a href="#l34.75"></a><span id="l34.75">         if (keys.empty()) {</span>
<a href="#l34.76"></a><span id="l34.76">             ERR_MSG(&quot;Default key not found&quot;);</span>
<a href="#l34.77"></a><span id="l34.77">         }</span>
<a href="#l34.78"></a><span id="l34.78">     }</span>
<a href="#l34.79"></a><span id="l34.79">     res = !keys.empty();</span>
<a href="#l34.80"></a><span id="l34.80"> done:</span>
<a href="#l34.81"></a><span id="l34.81">     if (!res) {</span>
<a href="#l34.82"></a><span id="l34.82" class="difflineat">@@ -2397,16 +2396,17 @@ cli_rnp_process_file(cli_rnp_t *rnp)</span>
<a href="#l34.83"></a><span id="l34.83">     if (!cli_rnp_init_io(&quot;verify&quot;, &amp;input, NULL, rnp)) {</span>
<a href="#l34.84"></a><span id="l34.84">         ERR_MSG(&quot;failed to open source&quot;);</span>
<a href="#l34.85"></a><span id="l34.85">         return false;</span>
<a href="#l34.86"></a><span id="l34.86">     }</span>
<a href="#l34.87"></a><span id="l34.87"> </span>
<a href="#l34.88"></a><span id="l34.88">     char *contents = NULL;</span>
<a href="#l34.89"></a><span id="l34.89">     if (rnp_guess_contents(input, &amp;contents)) {</span>
<a href="#l34.90"></a><span id="l34.90">         ERR_MSG(&quot;failed to check source contents&quot;);</span>
<a href="#l34.91"></a><span id="l34.91" class="difflineplus">+        rnp_input_destroy(input);</span>
<a href="#l34.92"></a><span id="l34.92">         return false;</span>
<a href="#l34.93"></a><span id="l34.93">     }</span>
<a href="#l34.94"></a><span id="l34.94"> </span>
<a href="#l34.95"></a><span id="l34.95">     /* source data for detached signature verification */</span>
<a href="#l34.96"></a><span id="l34.96">     rnp_input_t                            source = NULL;</span>
<a href="#l34.97"></a><span id="l34.97">     rnp_output_t                           output = NULL;</span>
<a href="#l34.98"></a><span id="l34.98">     rnp_op_verify_t                        verify = NULL;</span>
<a href="#l34.99"></a><span id="l34.99">     rnp_result_t                           ret = RNP_ERROR_GENERIC;</span>
<a href="#l34.100"></a><span id="l34.100" class="difflineat">@@ -2454,18 +2454,18 @@ cli_rnp_process_file(cli_rnp_t *rnp)</span>
<a href="#l34.101"></a><span id="l34.101">         rnp_op_verify_signature_t sig = NULL;</span>
<a href="#l34.102"></a><span id="l34.102">         if (rnp_op_verify_get_signature_at(verify, i, &amp;sig)) {</span>
<a href="#l34.103"></a><span id="l34.103">             ERR_MSG(&quot;Failed to obtain signature info.&quot;);</span>
<a href="#l34.104"></a><span id="l34.104">             res = false;</span>
<a href="#l34.105"></a><span id="l34.105">             goto done;</span>
<a href="#l34.106"></a><span id="l34.106">         }</span>
<a href="#l34.107"></a><span id="l34.107">         try {</span>
<a href="#l34.108"></a><span id="l34.108">             sigs.push_back(sig);</span>
<a href="#l34.109"></a><span id="l34.109" class="difflineminus">-        } catch (...) {</span>
<a href="#l34.110"></a><span id="l34.110" class="difflineminus">-            ERR_MSG(&quot;allocation failed&quot;);</span>
<a href="#l34.111"></a><span id="l34.111" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l34.112"></a><span id="l34.112" class="difflineplus">+            ERR_MSG(&quot;%s&quot;, e.what());</span>
<a href="#l34.113"></a><span id="l34.113">             res = false;</span>
<a href="#l34.114"></a><span id="l34.114">             goto done;</span>
<a href="#l34.115"></a><span id="l34.115">         }</span>
<a href="#l34.116"></a><span id="l34.116">     }</span>
<a href="#l34.117"></a><span id="l34.117">     cli_rnp_print_signatures(rnp, sigs);</span>
<a href="#l34.118"></a><span id="l34.118"> done:</span>
<a href="#l34.119"></a><span id="l34.119">     rnp_buffer_destroy(contents);</span>
<a href="#l34.120"></a><span id="l34.120">     rnp_input_destroy(input);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/third_party/rnp/src/rnp/rnpcfg.cpp</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/third_party/rnp/src/rnp/rnpcfg.cpp</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -445,18 +445,18 @@ rnp_cfg_copylist_string(const rnp_cfg_t </span>
<a href="#l35.4"></a><span id="l35.4">     for (list_item *li = list_front(it-&gt;val.val._list); li; li = list_next(li)) {</span>
<a href="#l35.5"></a><span id="l35.5">         rnp_cfg_val_t *val = (rnp_cfg_val_t *) li;</span>
<a href="#l35.6"></a><span id="l35.6">         if ((val-&gt;type != RNP_CFG_VAL_STRING) || !val-&gt;val._string) {</span>
<a href="#l35.7"></a><span id="l35.7">             RNP_LOG(&quot;wrong item in string list&quot;);</span>
<a href="#l35.8"></a><span id="l35.8">             goto fail;</span>
<a href="#l35.9"></a><span id="l35.9">         }</span>
<a href="#l35.10"></a><span id="l35.10">         try {</span>
<a href="#l35.11"></a><span id="l35.11">             dst.emplace_back(val-&gt;val._string);</span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-        } catch (...) {</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineminus">-            RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l35.14"></a><span id="l35.14" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l35.15"></a><span id="l35.15" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l35.16"></a><span id="l35.16">             goto fail;</span>
<a href="#l35.17"></a><span id="l35.17">         }</span>
<a href="#l35.18"></a><span id="l35.18">     }</span>
<a href="#l35.19"></a><span id="l35.19"> </span>
<a href="#l35.20"></a><span id="l35.20">     return true;</span>
<a href="#l35.21"></a><span id="l35.21"> fail:</span>
<a href="#l35.22"></a><span id="l35.22">     dst.clear();</span>
<a href="#l35.23"></a><span id="l35.23">     return false;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/third_party/rnp/src/tests/CMakeLists.txt</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/third_party/rnp/src/tests/CMakeLists.txt</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -77,22 +77,24 @@ add_executable(rnp_tests</span>
<a href="#l36.4"></a><span id="l36.4">   key-protect.cpp</span>
<a href="#l36.5"></a><span id="l36.5">   key-store-search.cpp</span>
<a href="#l36.6"></a><span id="l36.6">   key-unlock.cpp</span>
<a href="#l36.7"></a><span id="l36.7">   key-validate.cpp</span>
<a href="#l36.8"></a><span id="l36.8">   large-packet.cpp</span>
<a href="#l36.9"></a><span id="l36.9">   large-mpi.cpp</span>
<a href="#l36.10"></a><span id="l36.10">   load-g10.cpp</span>
<a href="#l36.11"></a><span id="l36.11">   load-pgp.cpp</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineplus">+  log-switch.cpp</span>
<a href="#l36.13"></a><span id="l36.13">   partial-length.cpp</span>
<a href="#l36.14"></a><span id="l36.14">   rnp_tests.cpp</span>
<a href="#l36.15"></a><span id="l36.15">   s2k-iterations.cpp</span>
<a href="#l36.16"></a><span id="l36.16">   streams.cpp</span>
<a href="#l36.17"></a><span id="l36.17">   support.cpp</span>
<a href="#l36.18"></a><span id="l36.18">   user-prefs.cpp</span>
<a href="#l36.19"></a><span id="l36.19" class="difflineplus">+  utils-hex2bin.cpp</span>
<a href="#l36.20"></a><span id="l36.20">   utils-list.cpp</span>
<a href="#l36.21"></a><span id="l36.21">   utils-rnpcfg.cpp</span>
<a href="#l36.22"></a><span id="l36.22">   issues/1030.cpp</span>
<a href="#l36.23"></a><span id="l36.23">   issues/1115.cpp</span>
<a href="#l36.24"></a><span id="l36.24"> )</span>
<a href="#l36.25"></a><span id="l36.25"> </span>
<a href="#l36.26"></a><span id="l36.26"> target_include_directories(rnp_tests</span>
<a href="#l36.27"></a><span id="l36.27">   PRIVATE</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/third_party/rnp/src/tests/cli_tests.py</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/third_party/rnp/src/tests/cli_tests.py</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -733,16 +733,18 @@ def setup(loglvl):</span>
<a href="#l37.4"></a><span id="l37.4">     logging.info('Running in ' + WORKDIR)</span>
<a href="#l37.5"></a><span id="l37.5"> </span>
<a href="#l37.6"></a><span id="l37.6">     cli_common.WORKDIR = WORKDIR</span>
<a href="#l37.7"></a><span id="l37.7">     RNPDIR = path.join(WORKDIR, '.rnp')</span>
<a href="#l37.8"></a><span id="l37.8">     RNP = os.getenv('RNP_TESTS_RNP_PATH') or 'rnp'</span>
<a href="#l37.9"></a><span id="l37.9">     RNPK = os.getenv('RNP_TESTS_RNPKEYS_PATH') or 'rnpkeys'</span>
<a href="#l37.10"></a><span id="l37.10">     os.mkdir(RNPDIR, 0o700)</span>
<a href="#l37.11"></a><span id="l37.11"> </span>
<a href="#l37.12"></a><span id="l37.12" class="difflineplus">+    os.environ[&quot;RNP_LOG_CONSOLE&quot;] = &quot;1&quot;</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+</span>
<a href="#l37.14"></a><span id="l37.14">     GPGDIR = path.join(WORKDIR, '.gpg')</span>
<a href="#l37.15"></a><span id="l37.15">     GPGHOME = path_for_gpg(GPGDIR) if is_windows() else GPGDIR</span>
<a href="#l37.16"></a><span id="l37.16">     GPG = os.getenv('RNP_TESTS_GPG_PATH') or find_utility('gpg')</span>
<a href="#l37.17"></a><span id="l37.17">     GPGCONF = os.getenv('RNP_TESTS_GPGCONF_PATH') or find_utility('gpgconf')</span>
<a href="#l37.18"></a><span id="l37.18">     os.mkdir(GPGDIR, 0o700)</span>
<a href="#l37.19"></a><span id="l37.19"> </span>
<a href="#l37.20"></a><span id="l37.20"> def data_path(subpath):</span>
<a href="#l37.21"></a><span id="l37.21">     ''' Constructs path to the tests data file/dir'''</span>
<a href="#l37.22"></a><span id="l37.22" class="difflineat">@@ -1601,16 +1603,89 @@ class Misc(unittest.TestCase):</span>
<a href="#l37.23"></a><span id="l37.23">             'test_list_packets/ecc-p256-pub.asc'), '--mpi', '--grips']</span>
<a href="#l37.24"></a><span id="l37.24">         ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.25"></a><span id="l37.25">         if ret != 0:</span>
<a href="#l37.26"></a><span id="l37.26">             raise_err('json all listing failed', err)</span>
<a href="#l37.27"></a><span id="l37.27">         compare_file_ex(data_path('test_list_packets/list_json_all.txt'), out,</span>
<a href="#l37.28"></a><span id="l37.28">                         'json all listing mismatch')</span>
<a href="#l37.29"></a><span id="l37.29">         return</span>
<a href="#l37.30"></a><span id="l37.30"> </span>
<a href="#l37.31"></a><span id="l37.31" class="difflineplus">+    def test_rnp_list_packets(self):</span>
<a href="#l37.32"></a><span id="l37.32" class="difflineplus">+        # List empty key packets</span>
<a href="#l37.33"></a><span id="l37.33" class="difflineplus">+        params = ['--list-packets', data_path('test_key_edge_cases/key-empty-packets.pgp')]</span>
<a href="#l37.34"></a><span id="l37.34" class="difflineplus">+        ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.35"></a><span id="l37.35" class="difflineplus">+        if ret == 0:</span>
<a href="#l37.36"></a><span id="l37.36" class="difflineplus">+            raise_err('packet listing not failed', err)</span>
<a href="#l37.37"></a><span id="l37.37" class="difflineplus">+        compare_file_ex(data_path('test_key_edge_cases/key-empty-packets.txt'), out,</span>
<a href="#l37.38"></a><span id="l37.38" class="difflineplus">+                        'key-empty-packets listing mismatch')</span>
<a href="#l37.39"></a><span id="l37.39" class="difflineplus">+        </span>
<a href="#l37.40"></a><span id="l37.40" class="difflineplus">+        # List empty key packets json</span>
<a href="#l37.41"></a><span id="l37.41" class="difflineplus">+        params = ['--list-packets', '--json', data_path('test_key_edge_cases/key-empty-packets.pgp')]</span>
<a href="#l37.42"></a><span id="l37.42" class="difflineplus">+        ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.43"></a><span id="l37.43" class="difflineplus">+        if ret == 0:</span>
<a href="#l37.44"></a><span id="l37.44" class="difflineplus">+            raise_err('packet listing not failed', err)</span>
<a href="#l37.45"></a><span id="l37.45" class="difflineplus">+</span>
<a href="#l37.46"></a><span id="l37.46" class="difflineplus">+        # List empty uid</span>
<a href="#l37.47"></a><span id="l37.47" class="difflineplus">+        params = ['--list-packets', data_path('test_key_edge_cases/key-empty-uid.pgp')]</span>
<a href="#l37.48"></a><span id="l37.48" class="difflineplus">+        ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.49"></a><span id="l37.49" class="difflineplus">+        if ret != 0:</span>
<a href="#l37.50"></a><span id="l37.50" class="difflineplus">+            raise_err('packet listing failed', err)</span>
<a href="#l37.51"></a><span id="l37.51" class="difflineplus">+        compare_file_ex(data_path('test_key_edge_cases/key-empty-uid.txt'), out,</span>
<a href="#l37.52"></a><span id="l37.52" class="difflineplus">+                        'key-empty-uid listing mismatch')</span>
<a href="#l37.53"></a><span id="l37.53" class="difflineplus">+</span>
<a href="#l37.54"></a><span id="l37.54" class="difflineplus">+        # List empty uid with raw packet contents</span>
<a href="#l37.55"></a><span id="l37.55" class="difflineplus">+        params = ['--list-packets', '--raw', data_path('test_key_edge_cases/key-empty-uid.pgp')]</span>
<a href="#l37.56"></a><span id="l37.56" class="difflineplus">+        ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.57"></a><span id="l37.57" class="difflineplus">+        if ret != 0:</span>
<a href="#l37.58"></a><span id="l37.58" class="difflineplus">+            raise_err('packet listing failed', err)</span>
<a href="#l37.59"></a><span id="l37.59" class="difflineplus">+        compare_file_ex(data_path('test_key_edge_cases/key-empty-uid-raw.txt'), out,</span>
<a href="#l37.60"></a><span id="l37.60" class="difflineplus">+                        'key-empty-uid-raw listing mismatch')</span>
<a href="#l37.61"></a><span id="l37.61" class="difflineplus">+</span>
<a href="#l37.62"></a><span id="l37.62" class="difflineplus">+        # List empty uid packet contents to JSON</span>
<a href="#l37.63"></a><span id="l37.63" class="difflineplus">+        params = ['--list-packets', '--json', data_path('test_key_edge_cases/key-empty-uid.pgp')]</span>
<a href="#l37.64"></a><span id="l37.64" class="difflineplus">+        ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.65"></a><span id="l37.65" class="difflineplus">+        if ret != 0:</span>
<a href="#l37.66"></a><span id="l37.66" class="difflineplus">+            raise_err('packet listing failed', err)</span>
<a href="#l37.67"></a><span id="l37.67" class="difflineplus">+        compare_file_ex(data_path('test_key_edge_cases/key-empty-uid.json'), out,</span>
<a href="#l37.68"></a><span id="l37.68" class="difflineplus">+                        'key-empty-uid json listing mismatch')</span>
<a href="#l37.69"></a><span id="l37.69" class="difflineplus">+</span>
<a href="#l37.70"></a><span id="l37.70" class="difflineplus">+        # List experimental subpackets</span>
<a href="#l37.71"></a><span id="l37.71" class="difflineplus">+        params = ['--list-packets', data_path('test_key_edge_cases/key-subpacket-101-110.pgp')]</span>
<a href="#l37.72"></a><span id="l37.72" class="difflineplus">+        ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.73"></a><span id="l37.73" class="difflineplus">+        if ret != 0:</span>
<a href="#l37.74"></a><span id="l37.74" class="difflineplus">+            raise_err('packet listing failed', err)</span>
<a href="#l37.75"></a><span id="l37.75" class="difflineplus">+        compare_file_ex(data_path('test_key_edge_cases/key-subpacket-101-110.txt'), out,</span>
<a href="#l37.76"></a><span id="l37.76" class="difflineplus">+                        'key-subpacket-101-110 listing mismatch')</span>
<a href="#l37.77"></a><span id="l37.77" class="difflineplus">+</span>
<a href="#l37.78"></a><span id="l37.78" class="difflineplus">+        # List experimental subpackets JSON</span>
<a href="#l37.79"></a><span id="l37.79" class="difflineplus">+        params = ['--list-packets', '--json', data_path('test_key_edge_cases/key-subpacket-101-110.pgp')]</span>
<a href="#l37.80"></a><span id="l37.80" class="difflineplus">+        ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.81"></a><span id="l37.81" class="difflineplus">+        if ret != 0:</span>
<a href="#l37.82"></a><span id="l37.82" class="difflineplus">+            raise_err('packet listing failed', err)</span>
<a href="#l37.83"></a><span id="l37.83" class="difflineplus">+        compare_file_ex(data_path('test_key_edge_cases/key-subpacket-101-110.json'), out,</span>
<a href="#l37.84"></a><span id="l37.84" class="difflineplus">+                        'key-subpacket-101-110 json listing mismatch')</span>
<a href="#l37.85"></a><span id="l37.85" class="difflineplus">+</span>
<a href="#l37.86"></a><span id="l37.86" class="difflineplus">+        # List malformed signature</span>
<a href="#l37.87"></a><span id="l37.87" class="difflineplus">+        params = ['--list-packets', data_path('test_key_edge_cases/key-malf-sig.pgp')]</span>
<a href="#l37.88"></a><span id="l37.88" class="difflineplus">+        ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.89"></a><span id="l37.89" class="difflineplus">+        if ret != 0:</span>
<a href="#l37.90"></a><span id="l37.90" class="difflineplus">+            raise_err('packet listing failed', err)</span>
<a href="#l37.91"></a><span id="l37.91" class="difflineplus">+        compare_file_ex(data_path('test_key_edge_cases/key-malf-sig.txt'), out,</span>
<a href="#l37.92"></a><span id="l37.92" class="difflineplus">+                        'key-malf-sig listing mismatch')</span>
<a href="#l37.93"></a><span id="l37.93" class="difflineplus">+</span>
<a href="#l37.94"></a><span id="l37.94" class="difflineplus">+        # List malformed signature JSON</span>
<a href="#l37.95"></a><span id="l37.95" class="difflineplus">+        params = ['--list-packets', '--json', data_path('test_key_edge_cases/key-malf-sig.pgp')]</span>
<a href="#l37.96"></a><span id="l37.96" class="difflineplus">+        ret, out, err = run_proc(RNP, params)</span>
<a href="#l37.97"></a><span id="l37.97" class="difflineplus">+        if ret != 0:</span>
<a href="#l37.98"></a><span id="l37.98" class="difflineplus">+            raise_err('packet listing failed', err)</span>
<a href="#l37.99"></a><span id="l37.99" class="difflineplus">+        compare_file_ex(data_path('test_key_edge_cases/key-malf-sig.json'), out,</span>
<a href="#l37.100"></a><span id="l37.100" class="difflineplus">+                        'key-malf-sig json listing mismatch')</span>
<a href="#l37.101"></a><span id="l37.101" class="difflineplus">+</span>
<a href="#l37.102"></a><span id="l37.102" class="difflineplus">+        return</span>
<a href="#l37.103"></a><span id="l37.103" class="difflineplus">+</span>
<a href="#l37.104"></a><span id="l37.104">     def test_debug_log(self):</span>
<a href="#l37.105"></a><span id="l37.105">         run_proc(RNPK, ['--homedir', data_path('keyrings/1'), '--list-keys', '--debug', '--all'])</span>
<a href="#l37.106"></a><span id="l37.106">         run_proc(RNPK, ['--homedir', data_path('keyrings/2'), '--list-keys', '--debug', '--all'])</span>
<a href="#l37.107"></a><span id="l37.107">         run_proc(RNPK, ['--homedir', data_path('keyrings/3'), '--list-keys', '--debug', '--all'])</span>
<a href="#l37.108"></a><span id="l37.108">         run_proc(RNPK, ['--homedir', data_path('test_stream_key_load/g10'),</span>
<a href="#l37.109"></a><span id="l37.109">                         '--list-keys', '--debug', '--all'])</span>
<a href="#l37.110"></a><span id="l37.110">         return</span>
<a href="#l37.111"></a><span id="l37.111"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1">new file mode 100644</span>
<a href="#l38.2"></a><span id="l38.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..c166aa866e437047349d1186208880d9b5da44b6</span>
<a href="#l38.3"></a><span id="l38.3">GIT binary patch
literal 337
zc$_&lt;C%o4}4Utf$&lt;n~jl$@s&gt;M3BO|+m`iFGhlXEN-ng4Cwemds7tm&gt;~R3?6TCYu#7&amp;
zx3QmSvOiSHq9De&gt;AS&lt;TGQvCMJM9K9h9^Kx1_9;uC!?eu*_iR|1;?6RLGH`JUz(l(D
zF#Ipd$SO&gt;djlJ~vZlN2Cb&lt;##_bH^(mrXRf;qB~oAZ;skshM$aE6C@k_S8aH4#O_CY
z+uX+GyXS4*#F75epGo&lt;l%}GY4vx1H}naQaNHi;n0p(wAw?$87lVW3MaaJvNPIVNdl
zR&amp;GuXb|yAaE=~?^CKfR!W=1ACMketFWJjvZW%%zGwO-H4&amp;+*AtUAvFz#}+PGJJUh#
z{@O;_-B(!_G&gt;VoRFf#1B^ncyEj7{g0kLR_l?D!_&gt;!7g=MV%3&gt;H{V{vr&gt;ZKZT0RVEY
BhF|~y</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1">new file mode 100644</span>
<a href="#l39.2"></a><span id="l39.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..92743b9a3073a9eda7493cf76a59f71feb2d03e5</span>
<a href="#l39.3"></a><span id="l39.3">GIT binary patch
literal 1096
zc$_&lt;C%o4}4Utf$&lt;n~jl$@s&gt;M3BO|+m`iFGhlXEN-ng4Cwemds7tm&gt;~R3?6TCYu#7&amp;
zx3QmSvOg&gt;6n3I{Ds$i1{q8y6y3hWL|U=bGMV6YHVWGQ}oW}@W!6OV51J^Pd;&amp;|zBU
z|9dv9OdwmBq?uW{IXT#w*hINFIk=fv#F&amp;^FndBIm#2Xm6I0ayeRpv7M_lsJuXXWSk
zWUH&gt;-$Mj&lt;hm#m%XAa{RlqwMahEDIV%%MBPA_FekF?p?;F^U25aT2^*^lk{Mhx-GHl
z%%A?4y&gt;InW4Y|&amp;Rv&amp;6CS9Tei!R$*pl;sE-KiJ2wF-^A{@Xw#ba!Tchw6+ZQM-en%X
z$lcFh=w0_X)~{fxGyk^b(T2?-DGXu@zHfG9W_07@a?O6e&amp;e%Tk&amp;-Pu0$C(*9*bh~(
zNC3U6fZMA;Ynh~ZkiE2U0VBhfzt&gt;OCpVq%SX4M7tZEGXWIsVCf@hspjgNi=qnuCs)
zof-Za&amp;71U+wNp3Nn?LsTi-2X$T++IB*B9Q+(K%+J#H`}Le5jN~18B1&gt;Zkx|Cyg;@#
z&gt;Mg_nnk_F*Ycail!5M1qr13r^*FNUFfBaSc+b&lt;VvzI~NTlbPY4&gt;TPX@k{gRAzB)ET
j#$;Q*^%Jk?)6E~2-MrfCb)d&gt;(7xS^vG%}h-2&amp;54J80EGi</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1">new file mode 100644</span>
<a href="#l40.2"></a><span id="l40.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..4f4e84ed4b6e8ff6a927441ebac09cf4a19c42c0</span>
<a href="#l40.3"></a><span id="l40.3">GIT binary patch
literal 6
Nc$}NTu!W(60RRVf0o4Ei</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1">new file mode 100644</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineminus">--- /dev/null</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-packets.txt</span>
<a href="#l41.4"></a><span id="l41.4" class="difflineat">@@ -0,0 +1,1 @@</span>
<a href="#l41.5"></a><span id="l41.5" class="difflineplus">+:off 0: packet header 0x9800 (tag 6, len 0)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l42.1"></a><span id="l42.1">new file mode 100644</span>
<a href="#l42.2"></a><span id="l42.2" class="difflineminus">--- /dev/null</span>
<a href="#l42.3"></a><span id="l42.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid-raw.txt</span>
<a href="#l42.4"></a><span id="l42.4" class="difflineat">@@ -0,0 +1,91 @@</span>
<a href="#l42.5"></a><span id="l42.5" class="difflineplus">+:off 0: packet header 0x9833 (tag 6, len 51)</span>
<a href="#l42.6"></a><span id="l42.6" class="difflineplus">+:off 2: packet contents (51 bytes)</span>
<a href="#l42.7"></a><span id="l42.7" class="difflineplus">+    00000 | 04 5e c6 91 74 16 09 2b 06 01 04 01 da 47 0f 01  | .^..t..+.....G..</span>
<a href="#l42.8"></a><span id="l42.8" class="difflineplus">+    00016 | 01 07 40 6b 11 04 c2 03 24 19 05 23 f9 b0 35 2b  | ..@k....$..#..5+</span>
<a href="#l42.9"></a><span id="l42.9" class="difflineplus">+    00032 | 1d 0a 94 82 d7 96 30 77 3b 78 7e 5a 53 61 f3 c6  | ......0w;x~ZSa..</span>
<a href="#l42.10"></a><span id="l42.10" class="difflineplus">+    00048 | 84 56 e1                                         | .V.             </span>
<a href="#l42.11"></a><span id="l42.11" class="difflineplus">+</span>
<a href="#l42.12"></a><span id="l42.12" class="difflineplus">+Public key packet</span>
<a href="#l42.13"></a><span id="l42.13" class="difflineplus">+    version: 4</span>
<a href="#l42.14"></a><span id="l42.14" class="difflineplus">+    creation time: 1590071668 (??? ??? ?? ??:??:?? ????)</span>
<a href="#l42.15"></a><span id="l42.15" class="difflineplus">+    public key algorithm: 22 (EdDSA)</span>
<a href="#l42.16"></a><span id="l42.16" class="difflineplus">+    public key material:</span>
<a href="#l42.17"></a><span id="l42.17" class="difflineplus">+        ecc p: 263 bits</span>
<a href="#l42.18"></a><span id="l42.18" class="difflineplus">+        ecc curve: Ed25519</span>
<a href="#l42.19"></a><span id="l42.19" class="difflineplus">+    keyid: 0xc972affd358bf887</span>
<a href="#l42.20"></a><span id="l42.20" class="difflineplus">+:off 53: packet header 0xb400 (tag 13, len 0)</span>
<a href="#l42.21"></a><span id="l42.21" class="difflineplus">+:off 55: packet contents (first 146 bytes)</span>
<a href="#l42.22"></a><span id="l42.22" class="difflineplus">+    00000 | 88 90 04 13 16 08 00 38 16 21 04 75 3d 5b 94 7e  | .......8.!.u=[.~</span>
<a href="#l42.23"></a><span id="l42.23" class="difflineplus">+    00016 | 9a 2b 2e 01 14 7c 1f c9 72 af fd 35 8b f8 87 05  | .+...|..r..5....</span>
<a href="#l42.24"></a><span id="l42.24" class="difflineplus">+    00032 | 02 5e c6 91 74 02 1b 03 05 0b 09 08 07 02 06 15  | .^..t...........</span>
<a href="#l42.25"></a><span id="l42.25" class="difflineplus">+    00048 | 0a 09 08 0b 02 04 16 02 03 01 02 1e 01 02 17 80  | ................</span>
<a href="#l42.26"></a><span id="l42.26" class="difflineplus">+    00064 | 00 0a 09 10 c9 72 af fd 35 8b f8 87 de c3 00 fa  | .....r..5.......</span>
<a href="#l42.27"></a><span id="l42.27" class="difflineplus">+    00080 | 02 b2 e8 10 20 19 c4 f2 60 b0 d1 6b 5e 50 83 21  | .... ...`..k^P.!</span>
<a href="#l42.28"></a><span id="l42.28" class="difflineplus">+    00096 | b8 3a a4 cd c0 39 18 fa 66 23 29 e0 2b 09 90 fe  | .:...9..f#).+...</span>
<a href="#l42.29"></a><span id="l42.29" class="difflineplus">+    00112 | 01 00 cd 1f a9 5e 59 be ba c9 35 ce 45 76 2b 3a  | .....^Y...5.Ev+:</span>
<a href="#l42.30"></a><span id="l42.30" class="difflineplus">+    00128 | 4e 8c b8 7a 9f 06 77 15 dd e3 c2 d9 da e7 4e 5c  | N..z..w.......N\</span>
<a href="#l42.31"></a><span id="l42.31" class="difflineplus">+    00144 | b2 0f                                            | ..              </span>
<a href="#l42.32"></a><span id="l42.32" class="difflineplus">+</span>
<a href="#l42.33"></a><span id="l42.33" class="difflineplus">+UserID packet</span>
<a href="#l42.34"></a><span id="l42.34" class="difflineplus">+    id: </span>
<a href="#l42.35"></a><span id="l42.35" class="difflineplus">+:off 55: packet header 0x8890 (tag 2, len 144)</span>
<a href="#l42.36"></a><span id="l42.36" class="difflineplus">+:off 57: packet contents (144 bytes)</span>
<a href="#l42.37"></a><span id="l42.37" class="difflineplus">+    00000 | 04 13 16 08 00 38 16 21 04 75 3d 5b 94 7e 9a 2b  | .....8.!.u=[.~.+</span>
<a href="#l42.38"></a><span id="l42.38" class="difflineplus">+    00016 | 2e 01 14 7c 1f c9 72 af fd 35 8b f8 87 05 02 5e  | ...|..r..5.....^</span>
<a href="#l42.39"></a><span id="l42.39" class="difflineplus">+    00032 | c6 91 74 02 1b 03 05 0b 09 08 07 02 06 15 0a 09  | ..t.............</span>
<a href="#l42.40"></a><span id="l42.40" class="difflineplus">+    00048 | 08 0b 02 04 16 02 03 01 02 1e 01 02 17 80 00 0a  | ................</span>
<a href="#l42.41"></a><span id="l42.41" class="difflineplus">+    00064 | 09 10 c9 72 af fd 35 8b f8 87 de c3 00 fa 02 b2  | ...r..5.........</span>
<a href="#l42.42"></a><span id="l42.42" class="difflineplus">+    00080 | e8 10 20 19 c4 f2 60 b0 d1 6b 5e 50 83 21 b8 3a  | .. ...`..k^P.!.:</span>
<a href="#l42.43"></a><span id="l42.43" class="difflineplus">+    00096 | a4 cd c0 39 18 fa 66 23 29 e0 2b 09 90 fe 01 00  | ...9..f#).+.....</span>
<a href="#l42.44"></a><span id="l42.44" class="difflineplus">+    00112 | cd 1f a9 5e 59 be ba c9 35 ce 45 76 2b 3a 4e 8c  | ...^Y...5.Ev+:N.</span>
<a href="#l42.45"></a><span id="l42.45" class="difflineplus">+    00128 | b8 7a 9f 06 77 15 dd e3 c2 d9 da e7 4e 5c b2 0f  | .z..w.......N\..</span>
<a href="#l42.46"></a><span id="l42.46" class="difflineplus">+</span>
<a href="#l42.47"></a><span id="l42.47" class="difflineplus">+Signature packet</span>
<a href="#l42.48"></a><span id="l42.48" class="difflineplus">+    version: 4</span>
<a href="#l42.49"></a><span id="l42.49" class="difflineplus">+    type: 19 (Positive User ID certification)</span>
<a href="#l42.50"></a><span id="l42.50" class="difflineplus">+    public key algorithm: 22 (EdDSA)</span>
<a href="#l42.51"></a><span id="l42.51" class="difflineplus">+    hash algorithm: 8 (SHA256)</span>
<a href="#l42.52"></a><span id="l42.52" class="difflineplus">+    hashed subpackets:</span>
<a href="#l42.53"></a><span id="l42.53" class="difflineplus">+        :type 33, len 21</span>
<a href="#l42.54"></a><span id="l42.54" class="difflineplus">+        :subpacket contents:</span>
<a href="#l42.55"></a><span id="l42.55" class="difflineplus">+            00000 | 04 75 3d 5b 94 7e 9a 2b 2e 01 14 7c 1f c9 72 af  | .u=[.~.+...|..r.</span>
<a href="#l42.56"></a><span id="l42.56" class="difflineplus">+            00016 | fd 35 8b f8 87                                   | .5...           </span>
<a href="#l42.57"></a><span id="l42.57" class="difflineplus">+        issuer fingerprint: 0x753d5b947e9a2b2e01147c1fc972affd358bf887 (20 bytes)</span>
<a href="#l42.58"></a><span id="l42.58" class="difflineplus">+        :type 2, len 4</span>
<a href="#l42.59"></a><span id="l42.59" class="difflineplus">+        :subpacket contents:</span>
<a href="#l42.60"></a><span id="l42.60" class="difflineplus">+            00000 | 5e c6 91 74                                      | ^..t            </span>
<a href="#l42.61"></a><span id="l42.61" class="difflineplus">+        signature creation time: 1590071668 (??? ??? ?? ??:??:?? ????)</span>
<a href="#l42.62"></a><span id="l42.62" class="difflineplus">+        :type 27, len 1</span>
<a href="#l42.63"></a><span id="l42.63" class="difflineplus">+        :subpacket contents:</span>
<a href="#l42.64"></a><span id="l42.64" class="difflineplus">+            00000 | 03                                               | .               </span>
<a href="#l42.65"></a><span id="l42.65" class="difflineplus">+        key flags: 0x03 ( certify sign )</span>
<a href="#l42.66"></a><span id="l42.66" class="difflineplus">+        :type 11, len 4</span>
<a href="#l42.67"></a><span id="l42.67" class="difflineplus">+        :subpacket contents:</span>
<a href="#l42.68"></a><span id="l42.68" class="difflineplus">+            00000 | 09 08 07 02                                      | ....            </span>
<a href="#l42.69"></a><span id="l42.69" class="difflineplus">+        preferred symmetric algorithms: AES-256, AES-192, AES-128, TripleDES (9, 8, 7, 2)</span>
<a href="#l42.70"></a><span id="l42.70" class="difflineplus">+        :type 21, len 5</span>
<a href="#l42.71"></a><span id="l42.71" class="difflineplus">+        :subpacket contents:</span>
<a href="#l42.72"></a><span id="l42.72" class="difflineplus">+            00000 | 0a 09 08 0b 02                                   | .....           </span>
<a href="#l42.73"></a><span id="l42.73" class="difflineplus">+        preferred hash algorithms: SHA512, SHA384, SHA256, SHA224, SHA1 (10, 9, 8, 11, 2)</span>
<a href="#l42.74"></a><span id="l42.74" class="difflineplus">+        :type 22, len 3</span>
<a href="#l42.75"></a><span id="l42.75" class="difflineplus">+        :subpacket contents:</span>
<a href="#l42.76"></a><span id="l42.76" class="difflineplus">+            00000 | 02 03 01                                         | ...             </span>
<a href="#l42.77"></a><span id="l42.77" class="difflineplus">+        preferred compression algorithms: ZLib, BZip2, ZIP (2, 3, 1)</span>
<a href="#l42.78"></a><span id="l42.78" class="difflineplus">+        :type 30, len 1</span>
<a href="#l42.79"></a><span id="l42.79" class="difflineplus">+        :subpacket contents:</span>
<a href="#l42.80"></a><span id="l42.80" class="difflineplus">+            00000 | 01                                               | .               </span>
<a href="#l42.81"></a><span id="l42.81" class="difflineplus">+        features: 0x01 ( mdc )</span>
<a href="#l42.82"></a><span id="l42.82" class="difflineplus">+        :type 23, len 1</span>
<a href="#l42.83"></a><span id="l42.83" class="difflineplus">+        :subpacket contents:</span>
<a href="#l42.84"></a><span id="l42.84" class="difflineplus">+            00000 | 80                                               | .               </span>
<a href="#l42.85"></a><span id="l42.85" class="difflineplus">+        key server preferences</span>
<a href="#l42.86"></a><span id="l42.86" class="difflineplus">+        no-modify: 1</span>
<a href="#l42.87"></a><span id="l42.87" class="difflineplus">+    unhashed subpackets:</span>
<a href="#l42.88"></a><span id="l42.88" class="difflineplus">+        :type 16, len 8</span>
<a href="#l42.89"></a><span id="l42.89" class="difflineplus">+        :subpacket contents:</span>
<a href="#l42.90"></a><span id="l42.90" class="difflineplus">+            00000 | c9 72 af fd 35 8b f8 87                          | .r..5...        </span>
<a href="#l42.91"></a><span id="l42.91" class="difflineplus">+        issuer key ID: 0xc972affd358bf887</span>
<a href="#l42.92"></a><span id="l42.92" class="difflineplus">+    lbits: 0xdec3</span>
<a href="#l42.93"></a><span id="l42.93" class="difflineplus">+    signature material:</span>
<a href="#l42.94"></a><span id="l42.94" class="difflineplus">+        ecc r: 250 bits</span>
<a href="#l42.95"></a><span id="l42.95" class="difflineplus">+        ecc s: 256 bits</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l43.1"></a><span id="l43.1">new file mode 100644</span>
<a href="#l43.2"></a><span id="l43.2" class="difflineminus">--- /dev/null</span>
<a href="#l43.3"></a><span id="l43.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.json</span>
<a href="#l43.4"></a><span id="l43.4" class="difflineat">@@ -0,0 +1,170 @@</span>
<a href="#l43.5"></a><span id="l43.5" class="difflineplus">+[</span>
<a href="#l43.6"></a><span id="l43.6" class="difflineplus">+  {</span>
<a href="#l43.7"></a><span id="l43.7" class="difflineplus">+    &quot;header&quot;:{</span>
<a href="#l43.8"></a><span id="l43.8" class="difflineplus">+      &quot;offset&quot;:0,</span>
<a href="#l43.9"></a><span id="l43.9" class="difflineplus">+      &quot;tag&quot;:6,</span>
<a href="#l43.10"></a><span id="l43.10" class="difflineplus">+      &quot;tag.str&quot;:&quot;Public Key&quot;,</span>
<a href="#l43.11"></a><span id="l43.11" class="difflineplus">+      &quot;raw&quot;:&quot;9833&quot;,</span>
<a href="#l43.12"></a><span id="l43.12" class="difflineplus">+      &quot;length&quot;:51,</span>
<a href="#l43.13"></a><span id="l43.13" class="difflineplus">+      &quot;partial&quot;:false,</span>
<a href="#l43.14"></a><span id="l43.14" class="difflineplus">+      &quot;indeterminate&quot;:false</span>
<a href="#l43.15"></a><span id="l43.15" class="difflineplus">+    },</span>
<a href="#l43.16"></a><span id="l43.16" class="difflineplus">+    &quot;version&quot;:4,</span>
<a href="#l43.17"></a><span id="l43.17" class="difflineplus">+    &quot;creation time&quot;:1590071668,</span>
<a href="#l43.18"></a><span id="l43.18" class="difflineplus">+    &quot;algorithm&quot;:22,</span>
<a href="#l43.19"></a><span id="l43.19" class="difflineplus">+    &quot;algorithm.str&quot;:&quot;EdDSA&quot;,</span>
<a href="#l43.20"></a><span id="l43.20" class="difflineplus">+    &quot;material&quot;:{</span>
<a href="#l43.21"></a><span id="l43.21" class="difflineplus">+      &quot;p.bits&quot;:263,</span>
<a href="#l43.22"></a><span id="l43.22" class="difflineplus">+      &quot;curve&quot;:&quot;Ed25519&quot;</span>
<a href="#l43.23"></a><span id="l43.23" class="difflineplus">+    },</span>
<a href="#l43.24"></a><span id="l43.24" class="difflineplus">+    &quot;keyid&quot;:&quot;c972affd358bf887&quot;</span>
<a href="#l43.25"></a><span id="l43.25" class="difflineplus">+  },</span>
<a href="#l43.26"></a><span id="l43.26" class="difflineplus">+  {</span>
<a href="#l43.27"></a><span id="l43.27" class="difflineplus">+    &quot;header&quot;:{</span>
<a href="#l43.28"></a><span id="l43.28" class="difflineplus">+      &quot;offset&quot;:53,</span>
<a href="#l43.29"></a><span id="l43.29" class="difflineplus">+      &quot;tag&quot;:13,</span>
<a href="#l43.30"></a><span id="l43.30" class="difflineplus">+      &quot;tag.str&quot;:&quot;User ID&quot;,</span>
<a href="#l43.31"></a><span id="l43.31" class="difflineplus">+      &quot;raw&quot;:&quot;b400&quot;,</span>
<a href="#l43.32"></a><span id="l43.32" class="difflineplus">+      &quot;length&quot;:0,</span>
<a href="#l43.33"></a><span id="l43.33" class="difflineplus">+      &quot;partial&quot;:false,</span>
<a href="#l43.34"></a><span id="l43.34" class="difflineplus">+      &quot;indeterminate&quot;:false</span>
<a href="#l43.35"></a><span id="l43.35" class="difflineplus">+    },</span>
<a href="#l43.36"></a><span id="l43.36" class="difflineplus">+    &quot;userid&quot;:&quot;&quot;</span>
<a href="#l43.37"></a><span id="l43.37" class="difflineplus">+  },</span>
<a href="#l43.38"></a><span id="l43.38" class="difflineplus">+  {</span>
<a href="#l43.39"></a><span id="l43.39" class="difflineplus">+    &quot;header&quot;:{</span>
<a href="#l43.40"></a><span id="l43.40" class="difflineplus">+      &quot;offset&quot;:55,</span>
<a href="#l43.41"></a><span id="l43.41" class="difflineplus">+      &quot;tag&quot;:2,</span>
<a href="#l43.42"></a><span id="l43.42" class="difflineplus">+      &quot;tag.str&quot;:&quot;Signature&quot;,</span>
<a href="#l43.43"></a><span id="l43.43" class="difflineplus">+      &quot;raw&quot;:&quot;8890&quot;,</span>
<a href="#l43.44"></a><span id="l43.44" class="difflineplus">+      &quot;length&quot;:144,</span>
<a href="#l43.45"></a><span id="l43.45" class="difflineplus">+      &quot;partial&quot;:false,</span>
<a href="#l43.46"></a><span id="l43.46" class="difflineplus">+      &quot;indeterminate&quot;:false</span>
<a href="#l43.47"></a><span id="l43.47" class="difflineplus">+    },</span>
<a href="#l43.48"></a><span id="l43.48" class="difflineplus">+    &quot;version&quot;:4,</span>
<a href="#l43.49"></a><span id="l43.49" class="difflineplus">+    &quot;type&quot;:19,</span>
<a href="#l43.50"></a><span id="l43.50" class="difflineplus">+    &quot;type.str&quot;:&quot;Positive User ID certification&quot;,</span>
<a href="#l43.51"></a><span id="l43.51" class="difflineplus">+    &quot;algorithm&quot;:22,</span>
<a href="#l43.52"></a><span id="l43.52" class="difflineplus">+    &quot;algorithm.str&quot;:&quot;EdDSA&quot;,</span>
<a href="#l43.53"></a><span id="l43.53" class="difflineplus">+    &quot;hash algorithm&quot;:8,</span>
<a href="#l43.54"></a><span id="l43.54" class="difflineplus">+    &quot;hash algorithm.str&quot;:&quot;SHA256&quot;,</span>
<a href="#l43.55"></a><span id="l43.55" class="difflineplus">+    &quot;subpackets&quot;:[</span>
<a href="#l43.56"></a><span id="l43.56" class="difflineplus">+      {</span>
<a href="#l43.57"></a><span id="l43.57" class="difflineplus">+        &quot;type&quot;:33,</span>
<a href="#l43.58"></a><span id="l43.58" class="difflineplus">+        &quot;type.str&quot;:&quot;issuer fingerprint&quot;,</span>
<a href="#l43.59"></a><span id="l43.59" class="difflineplus">+        &quot;length&quot;:21,</span>
<a href="#l43.60"></a><span id="l43.60" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l43.61"></a><span id="l43.61" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l43.62"></a><span id="l43.62" class="difflineplus">+        &quot;fingerprint&quot;:&quot;753d5b947e9a2b2e01147c1fc972affd358bf887&quot;</span>
<a href="#l43.63"></a><span id="l43.63" class="difflineplus">+      },</span>
<a href="#l43.64"></a><span id="l43.64" class="difflineplus">+      {</span>
<a href="#l43.65"></a><span id="l43.65" class="difflineplus">+        &quot;type&quot;:2,</span>
<a href="#l43.66"></a><span id="l43.66" class="difflineplus">+        &quot;type.str&quot;:&quot;signature creation time&quot;,</span>
<a href="#l43.67"></a><span id="l43.67" class="difflineplus">+        &quot;length&quot;:4,</span>
<a href="#l43.68"></a><span id="l43.68" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l43.69"></a><span id="l43.69" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l43.70"></a><span id="l43.70" class="difflineplus">+        &quot;creation time&quot;:1590071668</span>
<a href="#l43.71"></a><span id="l43.71" class="difflineplus">+      },</span>
<a href="#l43.72"></a><span id="l43.72" class="difflineplus">+      {</span>
<a href="#l43.73"></a><span id="l43.73" class="difflineplus">+        &quot;type&quot;:27,</span>
<a href="#l43.74"></a><span id="l43.74" class="difflineplus">+        &quot;type.str&quot;:&quot;key flags&quot;,</span>
<a href="#l43.75"></a><span id="l43.75" class="difflineplus">+        &quot;length&quot;:1,</span>
<a href="#l43.76"></a><span id="l43.76" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l43.77"></a><span id="l43.77" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l43.78"></a><span id="l43.78" class="difflineplus">+        &quot;flags&quot;:3,</span>
<a href="#l43.79"></a><span id="l43.79" class="difflineplus">+        &quot;flags.str&quot;:[</span>
<a href="#l43.80"></a><span id="l43.80" class="difflineplus">+          &quot;certify&quot;,</span>
<a href="#l43.81"></a><span id="l43.81" class="difflineplus">+          &quot;sign&quot;</span>
<a href="#l43.82"></a><span id="l43.82" class="difflineplus">+        ]</span>
<a href="#l43.83"></a><span id="l43.83" class="difflineplus">+      },</span>
<a href="#l43.84"></a><span id="l43.84" class="difflineplus">+      {</span>
<a href="#l43.85"></a><span id="l43.85" class="difflineplus">+        &quot;type&quot;:11,</span>
<a href="#l43.86"></a><span id="l43.86" class="difflineplus">+        &quot;type.str&quot;:&quot;preferred symmetric algorithms&quot;,</span>
<a href="#l43.87"></a><span id="l43.87" class="difflineplus">+        &quot;length&quot;:4,</span>
<a href="#l43.88"></a><span id="l43.88" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l43.89"></a><span id="l43.89" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l43.90"></a><span id="l43.90" class="difflineplus">+        &quot;algorithms&quot;:[</span>
<a href="#l43.91"></a><span id="l43.91" class="difflineplus">+          9,</span>
<a href="#l43.92"></a><span id="l43.92" class="difflineplus">+          8,</span>
<a href="#l43.93"></a><span id="l43.93" class="difflineplus">+          7,</span>
<a href="#l43.94"></a><span id="l43.94" class="difflineplus">+          2</span>
<a href="#l43.95"></a><span id="l43.95" class="difflineplus">+        ],</span>
<a href="#l43.96"></a><span id="l43.96" class="difflineplus">+        &quot;algorithms.str&quot;:[</span>
<a href="#l43.97"></a><span id="l43.97" class="difflineplus">+          &quot;AES-256&quot;,</span>
<a href="#l43.98"></a><span id="l43.98" class="difflineplus">+          &quot;AES-192&quot;,</span>
<a href="#l43.99"></a><span id="l43.99" class="difflineplus">+          &quot;AES-128&quot;,</span>
<a href="#l43.100"></a><span id="l43.100" class="difflineplus">+          &quot;TripleDES&quot;</span>
<a href="#l43.101"></a><span id="l43.101" class="difflineplus">+        ]</span>
<a href="#l43.102"></a><span id="l43.102" class="difflineplus">+      },</span>
<a href="#l43.103"></a><span id="l43.103" class="difflineplus">+      {</span>
<a href="#l43.104"></a><span id="l43.104" class="difflineplus">+        &quot;type&quot;:21,</span>
<a href="#l43.105"></a><span id="l43.105" class="difflineplus">+        &quot;type.str&quot;:&quot;preferred hash algorithms&quot;,</span>
<a href="#l43.106"></a><span id="l43.106" class="difflineplus">+        &quot;length&quot;:5,</span>
<a href="#l43.107"></a><span id="l43.107" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l43.108"></a><span id="l43.108" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l43.109"></a><span id="l43.109" class="difflineplus">+        &quot;algorithms&quot;:[</span>
<a href="#l43.110"></a><span id="l43.110" class="difflineplus">+          10,</span>
<a href="#l43.111"></a><span id="l43.111" class="difflineplus">+          9,</span>
<a href="#l43.112"></a><span id="l43.112" class="difflineplus">+          8,</span>
<a href="#l43.113"></a><span id="l43.113" class="difflineplus">+          11,</span>
<a href="#l43.114"></a><span id="l43.114" class="difflineplus">+          2</span>
<a href="#l43.115"></a><span id="l43.115" class="difflineplus">+        ],</span>
<a href="#l43.116"></a><span id="l43.116" class="difflineplus">+        &quot;algorithms.str&quot;:[</span>
<a href="#l43.117"></a><span id="l43.117" class="difflineplus">+          &quot;SHA512&quot;,</span>
<a href="#l43.118"></a><span id="l43.118" class="difflineplus">+          &quot;SHA384&quot;,</span>
<a href="#l43.119"></a><span id="l43.119" class="difflineplus">+          &quot;SHA256&quot;,</span>
<a href="#l43.120"></a><span id="l43.120" class="difflineplus">+          &quot;SHA224&quot;,</span>
<a href="#l43.121"></a><span id="l43.121" class="difflineplus">+          &quot;SHA1&quot;</span>
<a href="#l43.122"></a><span id="l43.122" class="difflineplus">+        ]</span>
<a href="#l43.123"></a><span id="l43.123" class="difflineplus">+      },</span>
<a href="#l43.124"></a><span id="l43.124" class="difflineplus">+      {</span>
<a href="#l43.125"></a><span id="l43.125" class="difflineplus">+        &quot;type&quot;:22,</span>
<a href="#l43.126"></a><span id="l43.126" class="difflineplus">+        &quot;type.str&quot;:&quot;preferred compression algorithms&quot;,</span>
<a href="#l43.127"></a><span id="l43.127" class="difflineplus">+        &quot;length&quot;:3,</span>
<a href="#l43.128"></a><span id="l43.128" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l43.129"></a><span id="l43.129" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l43.130"></a><span id="l43.130" class="difflineplus">+        &quot;algorithms&quot;:[</span>
<a href="#l43.131"></a><span id="l43.131" class="difflineplus">+          2,</span>
<a href="#l43.132"></a><span id="l43.132" class="difflineplus">+          3,</span>
<a href="#l43.133"></a><span id="l43.133" class="difflineplus">+          1</span>
<a href="#l43.134"></a><span id="l43.134" class="difflineplus">+        ],</span>
<a href="#l43.135"></a><span id="l43.135" class="difflineplus">+        &quot;algorithms.str&quot;:[</span>
<a href="#l43.136"></a><span id="l43.136" class="difflineplus">+          &quot;ZLib&quot;,</span>
<a href="#l43.137"></a><span id="l43.137" class="difflineplus">+          &quot;BZip2&quot;,</span>
<a href="#l43.138"></a><span id="l43.138" class="difflineplus">+          &quot;ZIP&quot;</span>
<a href="#l43.139"></a><span id="l43.139" class="difflineplus">+        ]</span>
<a href="#l43.140"></a><span id="l43.140" class="difflineplus">+      },</span>
<a href="#l43.141"></a><span id="l43.141" class="difflineplus">+      {</span>
<a href="#l43.142"></a><span id="l43.142" class="difflineplus">+        &quot;type&quot;:30,</span>
<a href="#l43.143"></a><span id="l43.143" class="difflineplus">+        &quot;type.str&quot;:&quot;features&quot;,</span>
<a href="#l43.144"></a><span id="l43.144" class="difflineplus">+        &quot;length&quot;:1,</span>
<a href="#l43.145"></a><span id="l43.145" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l43.146"></a><span id="l43.146" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l43.147"></a><span id="l43.147" class="difflineplus">+        &quot;mdc&quot;:true,</span>
<a href="#l43.148"></a><span id="l43.148" class="difflineplus">+        &quot;aead&quot;:false,</span>
<a href="#l43.149"></a><span id="l43.149" class="difflineplus">+        &quot;v5 keys&quot;:false</span>
<a href="#l43.150"></a><span id="l43.150" class="difflineplus">+      },</span>
<a href="#l43.151"></a><span id="l43.151" class="difflineplus">+      {</span>
<a href="#l43.152"></a><span id="l43.152" class="difflineplus">+        &quot;type&quot;:23,</span>
<a href="#l43.153"></a><span id="l43.153" class="difflineplus">+        &quot;type.str&quot;:&quot;key server preferences&quot;,</span>
<a href="#l43.154"></a><span id="l43.154" class="difflineplus">+        &quot;length&quot;:1,</span>
<a href="#l43.155"></a><span id="l43.155" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l43.156"></a><span id="l43.156" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l43.157"></a><span id="l43.157" class="difflineplus">+        &quot;no-modify&quot;:true</span>
<a href="#l43.158"></a><span id="l43.158" class="difflineplus">+      },</span>
<a href="#l43.159"></a><span id="l43.159" class="difflineplus">+      {</span>
<a href="#l43.160"></a><span id="l43.160" class="difflineplus">+        &quot;type&quot;:16,</span>
<a href="#l43.161"></a><span id="l43.161" class="difflineplus">+        &quot;type.str&quot;:&quot;issuer key ID&quot;,</span>
<a href="#l43.162"></a><span id="l43.162" class="difflineplus">+        &quot;length&quot;:8,</span>
<a href="#l43.163"></a><span id="l43.163" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l43.164"></a><span id="l43.164" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l43.165"></a><span id="l43.165" class="difflineplus">+        &quot;issuer keyid&quot;:&quot;c972affd358bf887&quot;</span>
<a href="#l43.166"></a><span id="l43.166" class="difflineplus">+      }</span>
<a href="#l43.167"></a><span id="l43.167" class="difflineplus">+    ],</span>
<a href="#l43.168"></a><span id="l43.168" class="difflineplus">+    &quot;lbits&quot;:&quot;dec3&quot;,</span>
<a href="#l43.169"></a><span id="l43.169" class="difflineplus">+    &quot;material&quot;:{</span>
<a href="#l43.170"></a><span id="l43.170" class="difflineplus">+      &quot;r.bits&quot;:250,</span>
<a href="#l43.171"></a><span id="l43.171" class="difflineplus">+      &quot;s.bits&quot;:256</span>
<a href="#l43.172"></a><span id="l43.172" class="difflineplus">+    }</span>
<a href="#l43.173"></a><span id="l43.173" class="difflineplus">+  }</span>
<a href="#l43.174"></a><span id="l43.174" class="difflineplus">+]</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l44.1"></a><span id="l44.1">new file mode 100644</span>
<a href="#l44.2"></a><span id="l44.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..ad9876dd7b6db27abd514fb6517dfdefda62396a</span>
<a href="#l44.3"></a><span id="l44.3">GIT binary patch
literal 201
zc$}MI%o2BOVu={1HX9=g&lt;1Kf7Mn-mrY(bVo%qo(s%0D-lYRhs&gt;X}UhmpxnBmE-E&lt;j
z^Rbq&amp;hg%prCa?&amp;LaWGhjDYBH&gt;Mo+1mrLD&amp;(QX_w|X#HQ)?jP-}Odvy&lt;q?uW{IXT#w
z*hINFIk=fv#F&amp;^FndBIm#2Xm6I0aye?;U3N#kA&gt;#fP&amp;&lt;aPYD|?X2%6IEAFsba`u3w
y#IH1E%?H|?6aFzWoRwc07rAfONz-$#W!hGLJv*xAvz3e9eSGNVt&gt;=C*oA?0-{71$B</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l45.1"></a><span id="l45.1">new file mode 100644</span>
<a href="#l45.2"></a><span id="l45.2" class="difflineminus">--- /dev/null</span>
<a href="#l45.3"></a><span id="l45.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_edge_cases/key-empty-uid.txt</span>
<a href="#l45.4"></a><span id="l45.4" class="difflineat">@@ -0,0 +1,43 @@</span>
<a href="#l45.5"></a><span id="l45.5" class="difflineplus">+:off 0: packet header 0x9833 (tag 6, len 51)</span>
<a href="#l45.6"></a><span id="l45.6" class="difflineplus">+Public key packet</span>
<a href="#l45.7"></a><span id="l45.7" class="difflineplus">+    version: 4</span>
<a href="#l45.8"></a><span id="l45.8" class="difflineplus">+    creation time: 1590071668 (??? ??? ?? ??:??:?? ????)</span>
<a href="#l45.9"></a><span id="l45.9" class="difflineplus">+    public key algorithm: 22 (EdDSA)</span>
<a href="#l45.10"></a><span id="l45.10" class="difflineplus">+    public key material:</span>
<a href="#l45.11"></a><span id="l45.11" class="difflineplus">+        ecc p: 263 bits</span>
<a href="#l45.12"></a><span id="l45.12" class="difflineplus">+        ecc curve: Ed25519</span>
<a href="#l45.13"></a><span id="l45.13" class="difflineplus">+    keyid: 0xc972affd358bf887</span>
<a href="#l45.14"></a><span id="l45.14" class="difflineplus">+:off 53: packet header 0xb400 (tag 13, len 0)</span>
<a href="#l45.15"></a><span id="l45.15" class="difflineplus">+UserID packet</span>
<a href="#l45.16"></a><span id="l45.16" class="difflineplus">+    id: </span>
<a href="#l45.17"></a><span id="l45.17" class="difflineplus">+:off 55: packet header 0x8890 (tag 2, len 144)</span>
<a href="#l45.18"></a><span id="l45.18" class="difflineplus">+Signature packet</span>
<a href="#l45.19"></a><span id="l45.19" class="difflineplus">+    version: 4</span>
<a href="#l45.20"></a><span id="l45.20" class="difflineplus">+    type: 19 (Positive User ID certification)</span>
<a href="#l45.21"></a><span id="l45.21" class="difflineplus">+    public key algorithm: 22 (EdDSA)</span>
<a href="#l45.22"></a><span id="l45.22" class="difflineplus">+    hash algorithm: 8 (SHA256)</span>
<a href="#l45.23"></a><span id="l45.23" class="difflineplus">+    hashed subpackets:</span>
<a href="#l45.24"></a><span id="l45.24" class="difflineplus">+        :type 33, len 21</span>
<a href="#l45.25"></a><span id="l45.25" class="difflineplus">+        issuer fingerprint: 0x753d5b947e9a2b2e01147c1fc972affd358bf887 (20 bytes)</span>
<a href="#l45.26"></a><span id="l45.26" class="difflineplus">+        :type 2, len 4</span>
<a href="#l45.27"></a><span id="l45.27" class="difflineplus">+        signature creation time: 1590071668 (??? ??? ?? ??:??:?? ????)</span>
<a href="#l45.28"></a><span id="l45.28" class="difflineplus">+        :type 27, len 1</span>
<a href="#l45.29"></a><span id="l45.29" class="difflineplus">+        key flags: 0x03 ( certify sign )</span>
<a href="#l45.30"></a><span id="l45.30" class="difflineplus">+        :type 11, len 4</span>
<a href="#l45.31"></a><span id="l45.31" class="difflineplus">+        preferred symmetric algorithms: AES-256, AES-192, AES-128, TripleDES (9, 8, 7, 2)</span>
<a href="#l45.32"></a><span id="l45.32" class="difflineplus">+        :type 21, len 5</span>
<a href="#l45.33"></a><span id="l45.33" class="difflineplus">+        preferred hash algorithms: SHA512, SHA384, SHA256, SHA224, SHA1 (10, 9, 8, 11, 2)</span>
<a href="#l45.34"></a><span id="l45.34" class="difflineplus">+        :type 22, len 3</span>
<a href="#l45.35"></a><span id="l45.35" class="difflineplus">+        preferred compression algorithms: ZLib, BZip2, ZIP (2, 3, 1)</span>
<a href="#l45.36"></a><span id="l45.36" class="difflineplus">+        :type 30, len 1</span>
<a href="#l45.37"></a><span id="l45.37" class="difflineplus">+        features: 0x01 ( mdc )</span>
<a href="#l45.38"></a><span id="l45.38" class="difflineplus">+        :type 23, len 1</span>
<a href="#l45.39"></a><span id="l45.39" class="difflineplus">+        key server preferences</span>
<a href="#l45.40"></a><span id="l45.40" class="difflineplus">+        no-modify: 1</span>
<a href="#l45.41"></a><span id="l45.41" class="difflineplus">+    unhashed subpackets:</span>
<a href="#l45.42"></a><span id="l45.42" class="difflineplus">+        :type 16, len 8</span>
<a href="#l45.43"></a><span id="l45.43" class="difflineplus">+        issuer key ID: 0xc972affd358bf887</span>
<a href="#l45.44"></a><span id="l45.44" class="difflineplus">+    lbits: 0xdec3</span>
<a href="#l45.45"></a><span id="l45.45" class="difflineplus">+    signature material:</span>
<a href="#l45.46"></a><span id="l45.46" class="difflineplus">+        ecc r: 250 bits</span>
<a href="#l45.47"></a><span id="l45.47" class="difflineplus">+        ecc s: 256 bits</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l46.1"></a><span id="l46.1">new file mode 100644</span>
<a href="#l46.2"></a><span id="l46.2" class="difflineminus">--- /dev/null</span>
<a href="#l46.3"></a><span id="l46.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.json</span>
<a href="#l46.4"></a><span id="l46.4" class="difflineat">@@ -0,0 +1,45 @@</span>
<a href="#l46.5"></a><span id="l46.5" class="difflineplus">+[</span>
<a href="#l46.6"></a><span id="l46.6" class="difflineplus">+  {</span>
<a href="#l46.7"></a><span id="l46.7" class="difflineplus">+    &quot;header&quot;:{</span>
<a href="#l46.8"></a><span id="l46.8" class="difflineplus">+      &quot;offset&quot;:0,</span>
<a href="#l46.9"></a><span id="l46.9" class="difflineplus">+      &quot;tag&quot;:6,</span>
<a href="#l46.10"></a><span id="l46.10" class="difflineplus">+      &quot;tag.str&quot;:&quot;Public Key&quot;,</span>
<a href="#l46.11"></a><span id="l46.11" class="difflineplus">+      &quot;raw&quot;:&quot;9833&quot;,</span>
<a href="#l46.12"></a><span id="l46.12" class="difflineplus">+      &quot;length&quot;:51,</span>
<a href="#l46.13"></a><span id="l46.13" class="difflineplus">+      &quot;partial&quot;:false,</span>
<a href="#l46.14"></a><span id="l46.14" class="difflineplus">+      &quot;indeterminate&quot;:false</span>
<a href="#l46.15"></a><span id="l46.15" class="difflineplus">+    },</span>
<a href="#l46.16"></a><span id="l46.16" class="difflineplus">+    &quot;version&quot;:4,</span>
<a href="#l46.17"></a><span id="l46.17" class="difflineplus">+    &quot;creation time&quot;:1590071668,</span>
<a href="#l46.18"></a><span id="l46.18" class="difflineplus">+    &quot;algorithm&quot;:22,</span>
<a href="#l46.19"></a><span id="l46.19" class="difflineplus">+    &quot;algorithm.str&quot;:&quot;EdDSA&quot;,</span>
<a href="#l46.20"></a><span id="l46.20" class="difflineplus">+    &quot;material&quot;:{</span>
<a href="#l46.21"></a><span id="l46.21" class="difflineplus">+      &quot;p.bits&quot;:263,</span>
<a href="#l46.22"></a><span id="l46.22" class="difflineplus">+      &quot;curve&quot;:&quot;Ed25519&quot;</span>
<a href="#l46.23"></a><span id="l46.23" class="difflineplus">+    },</span>
<a href="#l46.24"></a><span id="l46.24" class="difflineplus">+    &quot;keyid&quot;:&quot;c972affd358bf887&quot;</span>
<a href="#l46.25"></a><span id="l46.25" class="difflineplus">+  },</span>
<a href="#l46.26"></a><span id="l46.26" class="difflineplus">+  {</span>
<a href="#l46.27"></a><span id="l46.27" class="difflineplus">+    &quot;header&quot;:{</span>
<a href="#l46.28"></a><span id="l46.28" class="difflineplus">+      &quot;offset&quot;:53,</span>
<a href="#l46.29"></a><span id="l46.29" class="difflineplus">+      &quot;tag&quot;:13,</span>
<a href="#l46.30"></a><span id="l46.30" class="difflineplus">+      &quot;tag.str&quot;:&quot;User ID&quot;,</span>
<a href="#l46.31"></a><span id="l46.31" class="difflineplus">+      &quot;raw&quot;:&quot;b400&quot;,</span>
<a href="#l46.32"></a><span id="l46.32" class="difflineplus">+      &quot;length&quot;:0,</span>
<a href="#l46.33"></a><span id="l46.33" class="difflineplus">+      &quot;partial&quot;:false,</span>
<a href="#l46.34"></a><span id="l46.34" class="difflineplus">+      &quot;indeterminate&quot;:false</span>
<a href="#l46.35"></a><span id="l46.35" class="difflineplus">+    },</span>
<a href="#l46.36"></a><span id="l46.36" class="difflineplus">+    &quot;userid&quot;:&quot;&quot;</span>
<a href="#l46.37"></a><span id="l46.37" class="difflineplus">+  },</span>
<a href="#l46.38"></a><span id="l46.38" class="difflineplus">+  {</span>
<a href="#l46.39"></a><span id="l46.39" class="difflineplus">+    &quot;header&quot;:{</span>
<a href="#l46.40"></a><span id="l46.40" class="difflineplus">+      &quot;offset&quot;:55,</span>
<a href="#l46.41"></a><span id="l46.41" class="difflineplus">+      &quot;tag&quot;:2,</span>
<a href="#l46.42"></a><span id="l46.42" class="difflineplus">+      &quot;tag.str&quot;:&quot;Signature&quot;,</span>
<a href="#l46.43"></a><span id="l46.43" class="difflineplus">+      &quot;raw&quot;:&quot;8890&quot;,</span>
<a href="#l46.44"></a><span id="l46.44" class="difflineplus">+      &quot;length&quot;:144,</span>
<a href="#l46.45"></a><span id="l46.45" class="difflineplus">+      &quot;partial&quot;:false,</span>
<a href="#l46.46"></a><span id="l46.46" class="difflineplus">+      &quot;indeterminate&quot;:false</span>
<a href="#l46.47"></a><span id="l46.47" class="difflineplus">+    }</span>
<a href="#l46.48"></a><span id="l46.48" class="difflineplus">+  }</span>
<a href="#l46.49"></a><span id="l46.49" class="difflineplus">+]</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l47.1"></a><span id="l47.1">new file mode 100644</span>
<a href="#l47.2"></a><span id="l47.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..e9d6a53fc8a19bca91d1da4fe912246797dac841</span>
<a href="#l47.3"></a><span id="l47.3">GIT binary patch
literal 201
zc$}MI%o2BOVu={1HX9=g&lt;1Kf7Mn-mrY(bVo%qo(s%0D-lYRhs&gt;X}UhmpxnBmE-E&lt;j
z^Rbq&amp;hg%prCa?;NaWGhjDYBH&gt;Mo+1mrLD&amp;(QX_w|X#HQ)?jP-}Odvy&lt;q?uW{IXT#w
z*hINFIk=fv#F&amp;^FndBIm#2Xm6I0aye?;U3N#kA&gt;#fP&amp;&lt;aPYD|?X2%6IEAFsba`u3w
y#IH1E%?H|?6aFzWoRwc07rAfONz-$#W!hGLJv*xAvz3e9eSGNVt&gt;=C*oA?0;j7P@+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l48.1"></a><span id="l48.1">new file mode 100644</span>
<a href="#l48.2"></a><span id="l48.2" class="difflineminus">--- /dev/null</span>
<a href="#l48.3"></a><span id="l48.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_edge_cases/key-malf-sig.txt</span>
<a href="#l48.4"></a><span id="l48.4" class="difflineat">@@ -0,0 +1,15 @@</span>
<a href="#l48.5"></a><span id="l48.5" class="difflineplus">+:off 0: packet header 0x9833 (tag 6, len 51)</span>
<a href="#l48.6"></a><span id="l48.6" class="difflineplus">+Public key packet</span>
<a href="#l48.7"></a><span id="l48.7" class="difflineplus">+    version: 4</span>
<a href="#l48.8"></a><span id="l48.8" class="difflineplus">+    creation time: 1590071668 (??? ??? ?? ??:??:?? ????)</span>
<a href="#l48.9"></a><span id="l48.9" class="difflineplus">+    public key algorithm: 22 (EdDSA)</span>
<a href="#l48.10"></a><span id="l48.10" class="difflineplus">+    public key material:</span>
<a href="#l48.11"></a><span id="l48.11" class="difflineplus">+        ecc p: 263 bits</span>
<a href="#l48.12"></a><span id="l48.12" class="difflineplus">+        ecc curve: Ed25519</span>
<a href="#l48.13"></a><span id="l48.13" class="difflineplus">+    keyid: 0xc972affd358bf887</span>
<a href="#l48.14"></a><span id="l48.14" class="difflineplus">+:off 53: packet header 0xb400 (tag 13, len 0)</span>
<a href="#l48.15"></a><span id="l48.15" class="difflineplus">+UserID packet</span>
<a href="#l48.16"></a><span id="l48.16" class="difflineplus">+    id: </span>
<a href="#l48.17"></a><span id="l48.17" class="difflineplus">+:off 55: packet header 0x8890 (tag 2, len 144)</span>
<a href="#l48.18"></a><span id="l48.18" class="difflineplus">+Signature packet</span>
<a href="#l48.19"></a><span id="l48.19" class="difflineplus">+    failed to parse</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l49.1"></a><span id="l49.1">new file mode 100644</span>
<a href="#l49.2"></a><span id="l49.2" class="difflineminus">--- /dev/null</span>
<a href="#l49.3"></a><span id="l49.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_edge_cases/key-sec.asc</span>
<a href="#l49.4"></a><span id="l49.4" class="difflineat">@@ -0,0 +1,11 @@</span>
<a href="#l49.5"></a><span id="l49.5" class="difflineplus">+-----BEGIN PGP PRIVATE KEY BLOCK-----</span>
<a href="#l49.6"></a><span id="l49.6" class="difflineplus">+</span>
<a href="#l49.7"></a><span id="l49.7" class="difflineplus">+lIYEXsaRdBYJKwYBBAHaRw8BAQdAaxEEwgMkGQUj+bA1Kx0KlILXljB3O3h+WlNh</span>
<a href="#l49.8"></a><span id="l49.8" class="difflineplus">+88aEVuH+BwMCXuyNBH0+daDjGdIZx6FJFjJnaeSH2dOy6Z6dZXFjnASj/FgG8wuT</span>
<a href="#l49.9"></a><span id="l49.9" class="difflineplus">+OISz9ttnpnEW5KoAoTwz03wNEXVngwF8+5jFQaBFajFYhyTN6wilkLQFTm9VSUSI</span>
<a href="#l49.10"></a><span id="l49.10" class="difflineplus">+kAQTFggAOBYhBHU9W5R+misuARR8H8lyr/01i/iHBQJexpF0AhsDBQsJCAcCBhUK</span>
<a href="#l49.11"></a><span id="l49.11" class="difflineplus">+CQgLAgQWAgMBAh4BAheAAAoJEMlyr/01i/iH3sMA+gKy6BAgGcTyYLDRa15QgyG4</span>
<a href="#l49.12"></a><span id="l49.12" class="difflineplus">+OqTNwDkY+mYjKeArCZD+AQDNH6leWb66yTXORXYrOk6MuHqfBncV3ePC2drnTlyy</span>
<a href="#l49.13"></a><span id="l49.13" class="difflineplus">+Dw==</span>
<a href="#l49.14"></a><span id="l49.14" class="difflineplus">+=R2SZ</span>
<a href="#l49.15"></a><span id="l49.15" class="difflineplus">+-----END PGP PRIVATE KEY BLOCK-----</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l50.1"></a><span id="l50.1">new file mode 100644</span>
<a href="#l50.2"></a><span id="l50.2" class="difflineminus">--- /dev/null</span>
<a href="#l50.3"></a><span id="l50.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.json</span>
<a href="#l50.4"></a><span id="l50.4" class="difflineat">@@ -0,0 +1,250 @@</span>
<a href="#l50.5"></a><span id="l50.5" class="difflineplus">+[</span>
<a href="#l50.6"></a><span id="l50.6" class="difflineplus">+  {</span>
<a href="#l50.7"></a><span id="l50.7" class="difflineplus">+    &quot;header&quot;:{</span>
<a href="#l50.8"></a><span id="l50.8" class="difflineplus">+      &quot;offset&quot;:0,</span>
<a href="#l50.9"></a><span id="l50.9" class="difflineplus">+      &quot;tag&quot;:6,</span>
<a href="#l50.10"></a><span id="l50.10" class="difflineplus">+      &quot;tag.str&quot;:&quot;Public Key&quot;,</span>
<a href="#l50.11"></a><span id="l50.11" class="difflineplus">+      &quot;raw&quot;:&quot;9833&quot;,</span>
<a href="#l50.12"></a><span id="l50.12" class="difflineplus">+      &quot;length&quot;:51,</span>
<a href="#l50.13"></a><span id="l50.13" class="difflineplus">+      &quot;partial&quot;:false,</span>
<a href="#l50.14"></a><span id="l50.14" class="difflineplus">+      &quot;indeterminate&quot;:false</span>
<a href="#l50.15"></a><span id="l50.15" class="difflineplus">+    },</span>
<a href="#l50.16"></a><span id="l50.16" class="difflineplus">+    &quot;version&quot;:4,</span>
<a href="#l50.17"></a><span id="l50.17" class="difflineplus">+    &quot;creation time&quot;:1590071668,</span>
<a href="#l50.18"></a><span id="l50.18" class="difflineplus">+    &quot;algorithm&quot;:22,</span>
<a href="#l50.19"></a><span id="l50.19" class="difflineplus">+    &quot;algorithm.str&quot;:&quot;EdDSA&quot;,</span>
<a href="#l50.20"></a><span id="l50.20" class="difflineplus">+    &quot;material&quot;:{</span>
<a href="#l50.21"></a><span id="l50.21" class="difflineplus">+      &quot;p.bits&quot;:263,</span>
<a href="#l50.22"></a><span id="l50.22" class="difflineplus">+      &quot;curve&quot;:&quot;Ed25519&quot;</span>
<a href="#l50.23"></a><span id="l50.23" class="difflineplus">+    },</span>
<a href="#l50.24"></a><span id="l50.24" class="difflineplus">+    &quot;keyid&quot;:&quot;c972affd358bf887&quot;</span>
<a href="#l50.25"></a><span id="l50.25" class="difflineplus">+  },</span>
<a href="#l50.26"></a><span id="l50.26" class="difflineplus">+  {</span>
<a href="#l50.27"></a><span id="l50.27" class="difflineplus">+    &quot;header&quot;:{</span>
<a href="#l50.28"></a><span id="l50.28" class="difflineplus">+      &quot;offset&quot;:53,</span>
<a href="#l50.29"></a><span id="l50.29" class="difflineplus">+      &quot;tag&quot;:13,</span>
<a href="#l50.30"></a><span id="l50.30" class="difflineplus">+      &quot;tag.str&quot;:&quot;User ID&quot;,</span>
<a href="#l50.31"></a><span id="l50.31" class="difflineplus">+      &quot;raw&quot;:&quot;b405&quot;,</span>
<a href="#l50.32"></a><span id="l50.32" class="difflineplus">+      &quot;length&quot;:5,</span>
<a href="#l50.33"></a><span id="l50.33" class="difflineplus">+      &quot;partial&quot;:false,</span>
<a href="#l50.34"></a><span id="l50.34" class="difflineplus">+      &quot;indeterminate&quot;:false</span>
<a href="#l50.35"></a><span id="l50.35" class="difflineplus">+    },</span>
<a href="#l50.36"></a><span id="l50.36" class="difflineplus">+    &quot;userid&quot;:&quot;NoUID&quot;</span>
<a href="#l50.37"></a><span id="l50.37" class="difflineplus">+  },</span>
<a href="#l50.38"></a><span id="l50.38" class="difflineplus">+  {</span>
<a href="#l50.39"></a><span id="l50.39" class="difflineplus">+    &quot;header&quot;:{</span>
<a href="#l50.40"></a><span id="l50.40" class="difflineplus">+      &quot;offset&quot;:60,</span>
<a href="#l50.41"></a><span id="l50.41" class="difflineplus">+      &quot;tag&quot;:2,</span>
<a href="#l50.42"></a><span id="l50.42" class="difflineplus">+      &quot;tag.str&quot;:&quot;Signature&quot;,</span>
<a href="#l50.43"></a><span id="l50.43" class="difflineplus">+      &quot;raw&quot;:&quot;88b8&quot;,</span>
<a href="#l50.44"></a><span id="l50.44" class="difflineplus">+      &quot;length&quot;:184,</span>
<a href="#l50.45"></a><span id="l50.45" class="difflineplus">+      &quot;partial&quot;:false,</span>
<a href="#l50.46"></a><span id="l50.46" class="difflineplus">+      &quot;indeterminate&quot;:false</span>
<a href="#l50.47"></a><span id="l50.47" class="difflineplus">+    },</span>
<a href="#l50.48"></a><span id="l50.48" class="difflineplus">+    &quot;version&quot;:4,</span>
<a href="#l50.49"></a><span id="l50.49" class="difflineplus">+    &quot;type&quot;:19,</span>
<a href="#l50.50"></a><span id="l50.50" class="difflineplus">+    &quot;type.str&quot;:&quot;Positive User ID certification&quot;,</span>
<a href="#l50.51"></a><span id="l50.51" class="difflineplus">+    &quot;algorithm&quot;:22,</span>
<a href="#l50.52"></a><span id="l50.52" class="difflineplus">+    &quot;algorithm.str&quot;:&quot;EdDSA&quot;,</span>
<a href="#l50.53"></a><span id="l50.53" class="difflineplus">+    &quot;hash algorithm&quot;:8,</span>
<a href="#l50.54"></a><span id="l50.54" class="difflineplus">+    &quot;hash algorithm.str&quot;:&quot;SHA256&quot;,</span>
<a href="#l50.55"></a><span id="l50.55" class="difflineplus">+    &quot;subpackets&quot;:[</span>
<a href="#l50.56"></a><span id="l50.56" class="difflineplus">+      {</span>
<a href="#l50.57"></a><span id="l50.57" class="difflineplus">+        &quot;type&quot;:33,</span>
<a href="#l50.58"></a><span id="l50.58" class="difflineplus">+        &quot;type.str&quot;:&quot;issuer fingerprint&quot;,</span>
<a href="#l50.59"></a><span id="l50.59" class="difflineplus">+        &quot;length&quot;:21,</span>
<a href="#l50.60"></a><span id="l50.60" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l50.61"></a><span id="l50.61" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.62"></a><span id="l50.62" class="difflineplus">+        &quot;fingerprint&quot;:&quot;753d5b947e9a2b2e01147c1fc972affd358bf887&quot;</span>
<a href="#l50.63"></a><span id="l50.63" class="difflineplus">+      },</span>
<a href="#l50.64"></a><span id="l50.64" class="difflineplus">+      {</span>
<a href="#l50.65"></a><span id="l50.65" class="difflineplus">+        &quot;type&quot;:2,</span>
<a href="#l50.66"></a><span id="l50.66" class="difflineplus">+        &quot;type.str&quot;:&quot;signature creation time&quot;,</span>
<a href="#l50.67"></a><span id="l50.67" class="difflineplus">+        &quot;length&quot;:4,</span>
<a href="#l50.68"></a><span id="l50.68" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l50.69"></a><span id="l50.69" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.70"></a><span id="l50.70" class="difflineplus">+        &quot;creation time&quot;:1590071668</span>
<a href="#l50.71"></a><span id="l50.71" class="difflineplus">+      },</span>
<a href="#l50.72"></a><span id="l50.72" class="difflineplus">+      {</span>
<a href="#l50.73"></a><span id="l50.73" class="difflineplus">+        &quot;type&quot;:27,</span>
<a href="#l50.74"></a><span id="l50.74" class="difflineplus">+        &quot;type.str&quot;:&quot;key flags&quot;,</span>
<a href="#l50.75"></a><span id="l50.75" class="difflineplus">+        &quot;length&quot;:1,</span>
<a href="#l50.76"></a><span id="l50.76" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l50.77"></a><span id="l50.77" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.78"></a><span id="l50.78" class="difflineplus">+        &quot;flags&quot;:3,</span>
<a href="#l50.79"></a><span id="l50.79" class="difflineplus">+        &quot;flags.str&quot;:[</span>
<a href="#l50.80"></a><span id="l50.80" class="difflineplus">+          &quot;certify&quot;,</span>
<a href="#l50.81"></a><span id="l50.81" class="difflineplus">+          &quot;sign&quot;</span>
<a href="#l50.82"></a><span id="l50.82" class="difflineplus">+        ]</span>
<a href="#l50.83"></a><span id="l50.83" class="difflineplus">+      },</span>
<a href="#l50.84"></a><span id="l50.84" class="difflineplus">+      {</span>
<a href="#l50.85"></a><span id="l50.85" class="difflineplus">+        &quot;type&quot;:11,</span>
<a href="#l50.86"></a><span id="l50.86" class="difflineplus">+        &quot;type.str&quot;:&quot;preferred symmetric algorithms&quot;,</span>
<a href="#l50.87"></a><span id="l50.87" class="difflineplus">+        &quot;length&quot;:4,</span>
<a href="#l50.88"></a><span id="l50.88" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l50.89"></a><span id="l50.89" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.90"></a><span id="l50.90" class="difflineplus">+        &quot;algorithms&quot;:[</span>
<a href="#l50.91"></a><span id="l50.91" class="difflineplus">+          9,</span>
<a href="#l50.92"></a><span id="l50.92" class="difflineplus">+          8,</span>
<a href="#l50.93"></a><span id="l50.93" class="difflineplus">+          7,</span>
<a href="#l50.94"></a><span id="l50.94" class="difflineplus">+          2</span>
<a href="#l50.95"></a><span id="l50.95" class="difflineplus">+        ],</span>
<a href="#l50.96"></a><span id="l50.96" class="difflineplus">+        &quot;algorithms.str&quot;:[</span>
<a href="#l50.97"></a><span id="l50.97" class="difflineplus">+          &quot;AES-256&quot;,</span>
<a href="#l50.98"></a><span id="l50.98" class="difflineplus">+          &quot;AES-192&quot;,</span>
<a href="#l50.99"></a><span id="l50.99" class="difflineplus">+          &quot;AES-128&quot;,</span>
<a href="#l50.100"></a><span id="l50.100" class="difflineplus">+          &quot;TripleDES&quot;</span>
<a href="#l50.101"></a><span id="l50.101" class="difflineplus">+        ]</span>
<a href="#l50.102"></a><span id="l50.102" class="difflineplus">+      },</span>
<a href="#l50.103"></a><span id="l50.103" class="difflineplus">+      {</span>
<a href="#l50.104"></a><span id="l50.104" class="difflineplus">+        &quot;type&quot;:21,</span>
<a href="#l50.105"></a><span id="l50.105" class="difflineplus">+        &quot;type.str&quot;:&quot;preferred hash algorithms&quot;,</span>
<a href="#l50.106"></a><span id="l50.106" class="difflineplus">+        &quot;length&quot;:5,</span>
<a href="#l50.107"></a><span id="l50.107" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l50.108"></a><span id="l50.108" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.109"></a><span id="l50.109" class="difflineplus">+        &quot;algorithms&quot;:[</span>
<a href="#l50.110"></a><span id="l50.110" class="difflineplus">+          10,</span>
<a href="#l50.111"></a><span id="l50.111" class="difflineplus">+          9,</span>
<a href="#l50.112"></a><span id="l50.112" class="difflineplus">+          8,</span>
<a href="#l50.113"></a><span id="l50.113" class="difflineplus">+          11,</span>
<a href="#l50.114"></a><span id="l50.114" class="difflineplus">+          2</span>
<a href="#l50.115"></a><span id="l50.115" class="difflineplus">+        ],</span>
<a href="#l50.116"></a><span id="l50.116" class="difflineplus">+        &quot;algorithms.str&quot;:[</span>
<a href="#l50.117"></a><span id="l50.117" class="difflineplus">+          &quot;SHA512&quot;,</span>
<a href="#l50.118"></a><span id="l50.118" class="difflineplus">+          &quot;SHA384&quot;,</span>
<a href="#l50.119"></a><span id="l50.119" class="difflineplus">+          &quot;SHA256&quot;,</span>
<a href="#l50.120"></a><span id="l50.120" class="difflineplus">+          &quot;SHA224&quot;,</span>
<a href="#l50.121"></a><span id="l50.121" class="difflineplus">+          &quot;SHA1&quot;</span>
<a href="#l50.122"></a><span id="l50.122" class="difflineplus">+        ]</span>
<a href="#l50.123"></a><span id="l50.123" class="difflineplus">+      },</span>
<a href="#l50.124"></a><span id="l50.124" class="difflineplus">+      {</span>
<a href="#l50.125"></a><span id="l50.125" class="difflineplus">+        &quot;type&quot;:22,</span>
<a href="#l50.126"></a><span id="l50.126" class="difflineplus">+        &quot;type.str&quot;:&quot;preferred compression algorithms&quot;,</span>
<a href="#l50.127"></a><span id="l50.127" class="difflineplus">+        &quot;length&quot;:3,</span>
<a href="#l50.128"></a><span id="l50.128" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l50.129"></a><span id="l50.129" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.130"></a><span id="l50.130" class="difflineplus">+        &quot;algorithms&quot;:[</span>
<a href="#l50.131"></a><span id="l50.131" class="difflineplus">+          2,</span>
<a href="#l50.132"></a><span id="l50.132" class="difflineplus">+          3,</span>
<a href="#l50.133"></a><span id="l50.133" class="difflineplus">+          1</span>
<a href="#l50.134"></a><span id="l50.134" class="difflineplus">+        ],</span>
<a href="#l50.135"></a><span id="l50.135" class="difflineplus">+        &quot;algorithms.str&quot;:[</span>
<a href="#l50.136"></a><span id="l50.136" class="difflineplus">+          &quot;ZLib&quot;,</span>
<a href="#l50.137"></a><span id="l50.137" class="difflineplus">+          &quot;BZip2&quot;,</span>
<a href="#l50.138"></a><span id="l50.138" class="difflineplus">+          &quot;ZIP&quot;</span>
<a href="#l50.139"></a><span id="l50.139" class="difflineplus">+        ]</span>
<a href="#l50.140"></a><span id="l50.140" class="difflineplus">+      },</span>
<a href="#l50.141"></a><span id="l50.141" class="difflineplus">+      {</span>
<a href="#l50.142"></a><span id="l50.142" class="difflineplus">+        &quot;type&quot;:30,</span>
<a href="#l50.143"></a><span id="l50.143" class="difflineplus">+        &quot;type.str&quot;:&quot;features&quot;,</span>
<a href="#l50.144"></a><span id="l50.144" class="difflineplus">+        &quot;length&quot;:1,</span>
<a href="#l50.145"></a><span id="l50.145" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l50.146"></a><span id="l50.146" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.147"></a><span id="l50.147" class="difflineplus">+        &quot;mdc&quot;:true,</span>
<a href="#l50.148"></a><span id="l50.148" class="difflineplus">+        &quot;aead&quot;:false,</span>
<a href="#l50.149"></a><span id="l50.149" class="difflineplus">+        &quot;v5 keys&quot;:false</span>
<a href="#l50.150"></a><span id="l50.150" class="difflineplus">+      },</span>
<a href="#l50.151"></a><span id="l50.151" class="difflineplus">+      {</span>
<a href="#l50.152"></a><span id="l50.152" class="difflineplus">+        &quot;type&quot;:23,</span>
<a href="#l50.153"></a><span id="l50.153" class="difflineplus">+        &quot;type.str&quot;:&quot;key server preferences&quot;,</span>
<a href="#l50.154"></a><span id="l50.154" class="difflineplus">+        &quot;length&quot;:1,</span>
<a href="#l50.155"></a><span id="l50.155" class="difflineplus">+        &quot;hashed&quot;:true,</span>
<a href="#l50.156"></a><span id="l50.156" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.157"></a><span id="l50.157" class="difflineplus">+        &quot;no-modify&quot;:true</span>
<a href="#l50.158"></a><span id="l50.158" class="difflineplus">+      },</span>
<a href="#l50.159"></a><span id="l50.159" class="difflineplus">+      {</span>
<a href="#l50.160"></a><span id="l50.160" class="difflineplus">+        &quot;type&quot;:16,</span>
<a href="#l50.161"></a><span id="l50.161" class="difflineplus">+        &quot;type.str&quot;:&quot;issuer key ID&quot;,</span>
<a href="#l50.162"></a><span id="l50.162" class="difflineplus">+        &quot;length&quot;:8,</span>
<a href="#l50.163"></a><span id="l50.163" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.164"></a><span id="l50.164" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.165"></a><span id="l50.165" class="difflineplus">+        &quot;issuer keyid&quot;:&quot;c972affd358bf887&quot;</span>
<a href="#l50.166"></a><span id="l50.166" class="difflineplus">+      },</span>
<a href="#l50.167"></a><span id="l50.167" class="difflineplus">+      {</span>
<a href="#l50.168"></a><span id="l50.168" class="difflineplus">+        &quot;type&quot;:101,</span>
<a href="#l50.169"></a><span id="l50.169" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.170"></a><span id="l50.170" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.171"></a><span id="l50.171" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.172"></a><span id="l50.172" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.173"></a><span id="l50.173" class="difflineplus">+        &quot;raw&quot;:&quot;0101&quot;</span>
<a href="#l50.174"></a><span id="l50.174" class="difflineplus">+      },</span>
<a href="#l50.175"></a><span id="l50.175" class="difflineplus">+      {</span>
<a href="#l50.176"></a><span id="l50.176" class="difflineplus">+        &quot;type&quot;:102,</span>
<a href="#l50.177"></a><span id="l50.177" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.178"></a><span id="l50.178" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.179"></a><span id="l50.179" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.180"></a><span id="l50.180" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.181"></a><span id="l50.181" class="difflineplus">+        &quot;raw&quot;:&quot;0102&quot;</span>
<a href="#l50.182"></a><span id="l50.182" class="difflineplus">+      },</span>
<a href="#l50.183"></a><span id="l50.183" class="difflineplus">+      {</span>
<a href="#l50.184"></a><span id="l50.184" class="difflineplus">+        &quot;type&quot;:103,</span>
<a href="#l50.185"></a><span id="l50.185" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.186"></a><span id="l50.186" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.187"></a><span id="l50.187" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.188"></a><span id="l50.188" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.189"></a><span id="l50.189" class="difflineplus">+        &quot;raw&quot;:&quot;0103&quot;</span>
<a href="#l50.190"></a><span id="l50.190" class="difflineplus">+      },</span>
<a href="#l50.191"></a><span id="l50.191" class="difflineplus">+      {</span>
<a href="#l50.192"></a><span id="l50.192" class="difflineplus">+        &quot;type&quot;:104,</span>
<a href="#l50.193"></a><span id="l50.193" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.194"></a><span id="l50.194" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.195"></a><span id="l50.195" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.196"></a><span id="l50.196" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.197"></a><span id="l50.197" class="difflineplus">+        &quot;raw&quot;:&quot;0104&quot;</span>
<a href="#l50.198"></a><span id="l50.198" class="difflineplus">+      },</span>
<a href="#l50.199"></a><span id="l50.199" class="difflineplus">+      {</span>
<a href="#l50.200"></a><span id="l50.200" class="difflineplus">+        &quot;type&quot;:105,</span>
<a href="#l50.201"></a><span id="l50.201" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.202"></a><span id="l50.202" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.203"></a><span id="l50.203" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.204"></a><span id="l50.204" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.205"></a><span id="l50.205" class="difflineplus">+        &quot;raw&quot;:&quot;0105&quot;</span>
<a href="#l50.206"></a><span id="l50.206" class="difflineplus">+      },</span>
<a href="#l50.207"></a><span id="l50.207" class="difflineplus">+      {</span>
<a href="#l50.208"></a><span id="l50.208" class="difflineplus">+        &quot;type&quot;:106,</span>
<a href="#l50.209"></a><span id="l50.209" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.210"></a><span id="l50.210" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.211"></a><span id="l50.211" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.212"></a><span id="l50.212" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.213"></a><span id="l50.213" class="difflineplus">+        &quot;raw&quot;:&quot;0106&quot;</span>
<a href="#l50.214"></a><span id="l50.214" class="difflineplus">+      },</span>
<a href="#l50.215"></a><span id="l50.215" class="difflineplus">+      {</span>
<a href="#l50.216"></a><span id="l50.216" class="difflineplus">+        &quot;type&quot;:107,</span>
<a href="#l50.217"></a><span id="l50.217" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.218"></a><span id="l50.218" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.219"></a><span id="l50.219" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.220"></a><span id="l50.220" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.221"></a><span id="l50.221" class="difflineplus">+        &quot;raw&quot;:&quot;0107&quot;</span>
<a href="#l50.222"></a><span id="l50.222" class="difflineplus">+      },</span>
<a href="#l50.223"></a><span id="l50.223" class="difflineplus">+      {</span>
<a href="#l50.224"></a><span id="l50.224" class="difflineplus">+        &quot;type&quot;:108,</span>
<a href="#l50.225"></a><span id="l50.225" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.226"></a><span id="l50.226" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.227"></a><span id="l50.227" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.228"></a><span id="l50.228" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.229"></a><span id="l50.229" class="difflineplus">+        &quot;raw&quot;:&quot;0108&quot;</span>
<a href="#l50.230"></a><span id="l50.230" class="difflineplus">+      },</span>
<a href="#l50.231"></a><span id="l50.231" class="difflineplus">+      {</span>
<a href="#l50.232"></a><span id="l50.232" class="difflineplus">+        &quot;type&quot;:109,</span>
<a href="#l50.233"></a><span id="l50.233" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.234"></a><span id="l50.234" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.235"></a><span id="l50.235" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.236"></a><span id="l50.236" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.237"></a><span id="l50.237" class="difflineplus">+        &quot;raw&quot;:&quot;0109&quot;</span>
<a href="#l50.238"></a><span id="l50.238" class="difflineplus">+      },</span>
<a href="#l50.239"></a><span id="l50.239" class="difflineplus">+      {</span>
<a href="#l50.240"></a><span id="l50.240" class="difflineplus">+        &quot;type&quot;:110,</span>
<a href="#l50.241"></a><span id="l50.241" class="difflineplus">+        &quot;type.str&quot;:&quot;Unknown&quot;,</span>
<a href="#l50.242"></a><span id="l50.242" class="difflineplus">+        &quot;length&quot;:2,</span>
<a href="#l50.243"></a><span id="l50.243" class="difflineplus">+        &quot;hashed&quot;:false,</span>
<a href="#l50.244"></a><span id="l50.244" class="difflineplus">+        &quot;critical&quot;:false,</span>
<a href="#l50.245"></a><span id="l50.245" class="difflineplus">+        &quot;raw&quot;:&quot;0110&quot;</span>
<a href="#l50.246"></a><span id="l50.246" class="difflineplus">+      }</span>
<a href="#l50.247"></a><span id="l50.247" class="difflineplus">+    ],</span>
<a href="#l50.248"></a><span id="l50.248" class="difflineplus">+    &quot;lbits&quot;:&quot;dec3&quot;,</span>
<a href="#l50.249"></a><span id="l50.249" class="difflineplus">+    &quot;material&quot;:{</span>
<a href="#l50.250"></a><span id="l50.250" class="difflineplus">+      &quot;r.bits&quot;:250,</span>
<a href="#l50.251"></a><span id="l50.251" class="difflineplus">+      &quot;s.bits&quot;:256</span>
<a href="#l50.252"></a><span id="l50.252" class="difflineplus">+    }</span>
<a href="#l50.253"></a><span id="l50.253" class="difflineplus">+  }</span>
<a href="#l50.254"></a><span id="l50.254" class="difflineplus">+]</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l51.1"></a><span id="l51.1">new file mode 100644</span>
<a href="#l51.2"></a><span id="l51.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..4f232503c23b6769643092b6a40c4c16935265d1</span>
<a href="#l51.3"></a><span id="l51.3">GIT binary patch
literal 246
zc$}MI%o2BOVu={1HX9=g&lt;1Kf7Mn-mrY(bVo%qo(s%0D-lYRhs&gt;X}UhmpxnBmE-E&lt;j
z^Rbq&amp;hg(?v@&lt;TmcI(D!Ki*Ybmh$*s^+D1&gt;Qo29MCC{iPTvS|HZ)9xSbtV|%2nWULn
zxj8x5nb&lt;_RI61hPSj3o^8JXl5nZz3yj5q~gikVXx8JW`&lt;nV8cVnVB;fS(q~!S(&amp;pK
z*_g8#*_m?~Ihb=9Ihpeq1@0YY_{Fs8g@A(OkxvO5E@sCCG%N0~T5|S)rNpl^Wz7fL
roD=&gt;rGMtrP85g;4*GbcJu4UR*emy&amp;?=ChTH-hF)N=B?*`F`M`SMr}?$</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l52.1"></a><span id="l52.1">new file mode 100644</span>
<a href="#l52.2"></a><span id="l52.2" class="difflineminus">--- /dev/null</span>
<a href="#l52.3"></a><span id="l52.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_edge_cases/key-subpacket-101-110.txt</span>
<a href="#l52.4"></a><span id="l52.4" class="difflineat">@@ -0,0 +1,63 @@</span>
<a href="#l52.5"></a><span id="l52.5" class="difflineplus">+:off 0: packet header 0x9833 (tag 6, len 51)</span>
<a href="#l52.6"></a><span id="l52.6" class="difflineplus">+Public key packet</span>
<a href="#l52.7"></a><span id="l52.7" class="difflineplus">+    version: 4</span>
<a href="#l52.8"></a><span id="l52.8" class="difflineplus">+    creation time: 1590071668 (??? ??? ?? ??:??:?? ????)</span>
<a href="#l52.9"></a><span id="l52.9" class="difflineplus">+    public key algorithm: 22 (EdDSA)</span>
<a href="#l52.10"></a><span id="l52.10" class="difflineplus">+    public key material:</span>
<a href="#l52.11"></a><span id="l52.11" class="difflineplus">+        ecc p: 263 bits</span>
<a href="#l52.12"></a><span id="l52.12" class="difflineplus">+        ecc curve: Ed25519</span>
<a href="#l52.13"></a><span id="l52.13" class="difflineplus">+    keyid: 0xc972affd358bf887</span>
<a href="#l52.14"></a><span id="l52.14" class="difflineplus">+:off 53: packet header 0xb405 (tag 13, len 5)</span>
<a href="#l52.15"></a><span id="l52.15" class="difflineplus">+UserID packet</span>
<a href="#l52.16"></a><span id="l52.16" class="difflineplus">+    id: NoUID</span>
<a href="#l52.17"></a><span id="l52.17" class="difflineplus">+:off 60: packet header 0x88b8 (tag 2, len 184)</span>
<a href="#l52.18"></a><span id="l52.18" class="difflineplus">+Signature packet</span>
<a href="#l52.19"></a><span id="l52.19" class="difflineplus">+    version: 4</span>
<a href="#l52.20"></a><span id="l52.20" class="difflineplus">+    type: 19 (Positive User ID certification)</span>
<a href="#l52.21"></a><span id="l52.21" class="difflineplus">+    public key algorithm: 22 (EdDSA)</span>
<a href="#l52.22"></a><span id="l52.22" class="difflineplus">+    hash algorithm: 8 (SHA256)</span>
<a href="#l52.23"></a><span id="l52.23" class="difflineplus">+    hashed subpackets:</span>
<a href="#l52.24"></a><span id="l52.24" class="difflineplus">+        :type 33, len 21</span>
<a href="#l52.25"></a><span id="l52.25" class="difflineplus">+        issuer fingerprint: 0x753d5b947e9a2b2e01147c1fc972affd358bf887 (20 bytes)</span>
<a href="#l52.26"></a><span id="l52.26" class="difflineplus">+        :type 2, len 4</span>
<a href="#l52.27"></a><span id="l52.27" class="difflineplus">+        signature creation time: 1590071668 (??? ??? ?? ??:??:?? ????)</span>
<a href="#l52.28"></a><span id="l52.28" class="difflineplus">+        :type 27, len 1</span>
<a href="#l52.29"></a><span id="l52.29" class="difflineplus">+        key flags: 0x03 ( certify sign )</span>
<a href="#l52.30"></a><span id="l52.30" class="difflineplus">+        :type 11, len 4</span>
<a href="#l52.31"></a><span id="l52.31" class="difflineplus">+        preferred symmetric algorithms: AES-256, AES-192, AES-128, TripleDES (9, 8, 7, 2)</span>
<a href="#l52.32"></a><span id="l52.32" class="difflineplus">+        :type 21, len 5</span>
<a href="#l52.33"></a><span id="l52.33" class="difflineplus">+        preferred hash algorithms: SHA512, SHA384, SHA256, SHA224, SHA1 (10, 9, 8, 11, 2)</span>
<a href="#l52.34"></a><span id="l52.34" class="difflineplus">+        :type 22, len 3</span>
<a href="#l52.35"></a><span id="l52.35" class="difflineplus">+        preferred compression algorithms: ZLib, BZip2, ZIP (2, 3, 1)</span>
<a href="#l52.36"></a><span id="l52.36" class="difflineplus">+        :type 30, len 1</span>
<a href="#l52.37"></a><span id="l52.37" class="difflineplus">+        features: 0x01 ( mdc )</span>
<a href="#l52.38"></a><span id="l52.38" class="difflineplus">+        :type 23, len 1</span>
<a href="#l52.39"></a><span id="l52.39" class="difflineplus">+        key server preferences</span>
<a href="#l52.40"></a><span id="l52.40" class="difflineplus">+        no-modify: 1</span>
<a href="#l52.41"></a><span id="l52.41" class="difflineplus">+    unhashed subpackets:</span>
<a href="#l52.42"></a><span id="l52.42" class="difflineplus">+        :type 16, len 8</span>
<a href="#l52.43"></a><span id="l52.43" class="difflineplus">+        issuer key ID: 0xc972affd358bf887</span>
<a href="#l52.44"></a><span id="l52.44" class="difflineplus">+        :type 101, len 2</span>
<a href="#l52.45"></a><span id="l52.45" class="difflineplus">+            00000 | 01 01                                            | ..              </span>
<a href="#l52.46"></a><span id="l52.46" class="difflineplus">+        :type 102, len 2</span>
<a href="#l52.47"></a><span id="l52.47" class="difflineplus">+            00000 | 01 02                                            | ..              </span>
<a href="#l52.48"></a><span id="l52.48" class="difflineplus">+        :type 103, len 2</span>
<a href="#l52.49"></a><span id="l52.49" class="difflineplus">+            00000 | 01 03                                            | ..              </span>
<a href="#l52.50"></a><span id="l52.50" class="difflineplus">+        :type 104, len 2</span>
<a href="#l52.51"></a><span id="l52.51" class="difflineplus">+            00000 | 01 04                                            | ..              </span>
<a href="#l52.52"></a><span id="l52.52" class="difflineplus">+        :type 105, len 2</span>
<a href="#l52.53"></a><span id="l52.53" class="difflineplus">+            00000 | 01 05                                            | ..              </span>
<a href="#l52.54"></a><span id="l52.54" class="difflineplus">+        :type 106, len 2</span>
<a href="#l52.55"></a><span id="l52.55" class="difflineplus">+            00000 | 01 06                                            | ..              </span>
<a href="#l52.56"></a><span id="l52.56" class="difflineplus">+        :type 107, len 2</span>
<a href="#l52.57"></a><span id="l52.57" class="difflineplus">+            00000 | 01 07                                            | ..              </span>
<a href="#l52.58"></a><span id="l52.58" class="difflineplus">+        :type 108, len 2</span>
<a href="#l52.59"></a><span id="l52.59" class="difflineplus">+            00000 | 01 08                                            | ..              </span>
<a href="#l52.60"></a><span id="l52.60" class="difflineplus">+        :type 109, len 2</span>
<a href="#l52.61"></a><span id="l52.61" class="difflineplus">+            00000 | 01 09                                            | ..              </span>
<a href="#l52.62"></a><span id="l52.62" class="difflineplus">+        :type 110, len 2</span>
<a href="#l52.63"></a><span id="l52.63" class="difflineplus">+            00000 | 01 10                                            | ..              </span>
<a href="#l52.64"></a><span id="l52.64" class="difflineplus">+    lbits: 0xdec3</span>
<a href="#l52.65"></a><span id="l52.65" class="difflineplus">+    signature material:</span>
<a href="#l52.66"></a><span id="l52.66" class="difflineplus">+        ecc r: 250 bits</span>
<a href="#l52.67"></a><span id="l52.67" class="difflineplus">+        ecc s: 256 bits</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l53.1"></a><span id="l53.1">new file mode 100644</span>
<a href="#l53.2"></a><span id="l53.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..0d2b9bb3ae2c45f353079b10a262bb95f774b69e</span>
<a href="#l53.3"></a><span id="l53.3">GIT binary patch
literal 325
zc$@)60lNOdi~}ClKILz%!%YDM08wrki|bIukMGgtfwXdQ0VCcavAE}5^ravbIRjVG
zhqa(?OodH*dsZs!Ik(_9-(n+@im_IukP*V{nU_$Q)xHtlw#TumZ8&amp;2x`vrzqCr5bf
zT`*P{P`#*i=9PBwPumT7_X$SzTfZOBn1e7q?V$aKyOmX&gt;xq5N9oVP11Vbrw&amp;2&gt;}(Y
z2yK*-*7wZyr{TO&amp;^uk!A*XJ(_XrHgXzNzrI|C8MUQvw5yqBS0ip=u+oMqfzM9=etI
z)|y4{@L5~_Xh?2c=nZ%{T&gt;GX@C@PnN&amp;DB~Lx}I~t&gt;esNJOt)wvh&amp;V@r{2Z(atNs*T
zl2t~?(I_ka=Y!(%P&lt;AaSlK^YJ&lt;|&amp;+9L{H+y{`$xX4RVXCRR&lt;WWC%SdXbP!~40XEOj
XS+%*jAXy}+^xwQF)w7A=1wSLnv$&gt;@Q</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l54.1"></a><span id="l54.1">new file mode 100644</span>
<a href="#l54.2"></a><span id="l54.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..2e9a6a2afdc85e825be8855ce0c41b590df24358</span>
<a href="#l54.3"></a><span id="l54.3">GIT binary patch
literal 326
zc$@)70lEIcjRPLmKILz%!%YDM0RT~M8H?*s#gFgN&lt;$&lt;(vaRDRVA+fmUUG$|O6*&amp;V}
z(TBC5ZcK$udwW(Y&gt;^ZmKH{W6-l8UibrH~QA?3tHPnAN@!-nPfFs%&lt;!9GW!LFS0_h!
z&gt;|HQc7*M^ab&gt;@|J@lV?gdG`rM^;^Fm(3pcTJ?)_Vhr5+kq`7)=xSY2uEMe5O0SN&amp;W
ztq5(DlGgXk^{3&amp;yQS`!Cq}S&amp;!3uvFOzP_pOxc`&amp;g0#gD5j-oXli=k&gt;Gtwvu+(jK~%
z_|}?5@9&lt;e${%A;UT&lt;8sWI9&amp;UtPADpug3Z-h7rLHvzv|bppG&gt;!CB8WIgg8Uq;39J4T
zUXoQt$k8Y({^x_@@=$gyD3btdzUC&gt;MTtrXe#s2!p2@P_Kt5pXWt0%g3$#f88Z~-&gt;Y
Y&amp;{?&amp;)xgc32sPx~wDAlux;RQb&lt;$-B^{2&gt;&lt;{9</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l55.1"></a><span id="l55.1">new file mode 100644</span>
<a href="#l55.2"></a><span id="l55.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..7ab171174fa9abe9ca1f7e551897bed6b87b7ce8</span>
<a href="#l55.3"></a><span id="l55.3">GIT binary patch
literal 326
zc$@)70lEIcjRPLmKILz%!%YDM2LMrS8H?*s#gFgN&lt;$&lt;(vaRDRVA+fmUUG$|O6*&amp;V}
z(TBC5ZcK$udwW(Y&gt;^ZmKH{W6-l8UibrH~QA?3tHPnAN@!-nPfFs%&lt;!9GW!LFS0_h!
z&gt;|HQc7*M^ab&gt;@|J@lV?gdG`rM^;^Fm(3pcTJ?)_Vhr5+kq`7)=xSY2uEMe5O0SN&amp;W
ztq5(DlGgXk^{3&amp;yQS`!Cq}S&amp;!3uvFOzP_pOxc`&amp;g0#gD5j-oXli=k&gt;Gtwvu+(jK~%
z_|}?5@9&lt;e${%A;UT&lt;8sWI9&amp;UtPADpug3Z-h7rLHvzv|bppG&gt;!CB8WIgg8Uq;39J4T
zUXoQt$k8Y({^x_@@=$gyD3btdzUC&gt;MTtrXe#s2!p2@P_Kt5pXWt0%g3$#f88Z~-&gt;Y
Y&amp;{?&amp;)xgc32sPx~wDAlux;RQb&lt;$-^e44*&amp;oF</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l56.1"></a><span id="l56.1">new file mode 100644</span>
<a href="#l56.2"></a><span id="l56.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..020812a8d62968b0f258b1dc0b8717576e27bf28</span>
<a href="#l56.3"></a><span id="l56.3">GIT binary patch
literal 327
zc$@)80l5CbjsqUnKILz%!%YDM5C8yCZW)W~P{oh$(dB`(a&amp;ZA8-XXEL=Uw!rAQd?S
zSJ8*Hpl(csO?!J*D(pG8;5Xl5Ba(`-R;7&gt;;!t9xsP?*)e5#F}Pv8ru2V&gt;0^%hF2#?
zc&lt;fy;Rv1vdsCDL*cJWW!4SDwoM)h02AJCYCFg@*{{fE1iRiwFkak!kfD=cBuwE+nM
z6|D$ul#&lt;r&gt;%=M??yixSRSftnIFAHd&amp;ufD#i@VNhz-2zhr1CF9K9*d!BBdtbXNYWm&lt;
zmH5`0Mep!gTmEQBZd~XMcsN}9rcNj-mx9gJS{J&amp;WbHD1&gt;u%Aq~Xd;L&gt;M}qtutO=|B
z6kd{5M##}9EB@z$;_^^-Ehv)!Yrf_woLodt;&gt;G^@$O#Q{i&gt;p-!7^^3`b;)!PWN-mC
Z&amp;(K-5xw#-&amp;B&amp;hV?yeQSPiQxr5Bgxelr5OMK</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l57.1"></a><span id="l57.1">new file mode 100644</span>
<a href="#l57.2"></a><span id="l57.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..9f56341245cef4cc364023dcdbe3488e22235fdd</span>
<a href="#l57.3"></a><span id="l57.3">GIT binary patch
literal 325
zc$@)60lNOdi~}ClKILz%!%YDL`B82ei|bIukMGgtfwXdQ0VCcavAE}5^ravbIRjVG
zhqa(?OodH*dsZs!Ik(_9-(n+@im_IukP*V{nU_$Q)xHtlw#TumZ8&amp;2x`vrzqCr5bf
zT`*P{P`#*i=9PBwPumT7_X$SzTfZOBn1e7q?V$aKyOmX&gt;xq5N9oVP11Vbrw&amp;2&gt;}(Y
z2yK*-*7wZyr{TO&amp;^uk!A*XJ(_XrHgXzNzrI|C8MUQvw5yqBS0ip=u+oMqfzM9=etI
z)|y4{@L5~_Xh?2c=nZ%{T&gt;GX@C@PnN&amp;DB~Lx}I~t&gt;esNJOt)wvh&amp;V@r{2Z(atNs*T
zl2t~?(I_ka=Y!(%P&lt;AaSlK^YJ&lt;|&amp;+9L{H+y{`$xX4RVXCRR&lt;WWC%SdXbP!~40XEOj
XS+%*jAXy}+^xwQF)w7A=1wSLn;s&gt;Sw</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l58.1"></a><span id="l58.1" class="difflineminus">--- a/third_party/rnp/src/tests/ffi.cpp</span>
<a href="#l58.2"></a><span id="l58.2" class="difflineplus">+++ b/third_party/rnp/src/tests/ffi.cpp</span>
<a href="#l58.3"></a><span id="l58.3" class="difflineat">@@ -6481,154 +6481,166 @@ TEST_F(rnp_tests, test_ffi_op_verify_sig</span>
<a href="#l58.4"></a><span id="l58.4">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.5"></a><span id="l58.5">     assert_int_equal(sigcount, 1);</span>
<a href="#l58.6"></a><span id="l58.6">     assert_true(check_signature(verify, 0, RNP_SUCCESS));</span>
<a href="#l58.7"></a><span id="l58.7">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.8"></a><span id="l58.8">     rnp_input_destroy(input);</span>
<a href="#l58.9"></a><span id="l58.9">     rnp_output_destroy(output);</span>
<a href="#l58.10"></a><span id="l58.10"> </span>
<a href="#l58.11"></a><span id="l58.11">     /* signed with unknown key */</span>
<a href="#l58.12"></a><span id="l58.12" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.13"></a><span id="l58.13">     assert_rnp_success(</span>
<a href="#l58.14"></a><span id="l58.14">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.signed.unknown&quot;));</span>
<a href="#l58.15"></a><span id="l58.15">     assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.16"></a><span id="l58.16">     assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l58.17"></a><span id="l58.17">     assert_rnp_success(rnp_op_verify_execute(verify));</span>
<a href="#l58.18"></a><span id="l58.18">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.19"></a><span id="l58.19">     assert_int_equal(sigcount, 1);</span>
<a href="#l58.20"></a><span id="l58.20">     assert_true(check_signature(verify, 0, RNP_ERROR_KEY_NOT_FOUND));</span>
<a href="#l58.21"></a><span id="l58.21">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.22"></a><span id="l58.22">     rnp_input_destroy(input);</span>
<a href="#l58.23"></a><span id="l58.23">     rnp_output_destroy(output);</span>
<a href="#l58.24"></a><span id="l58.24"> </span>
<a href="#l58.25"></a><span id="l58.25">     /* signed with malformed signature (bad version) */</span>
<a href="#l58.26"></a><span id="l58.26" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.27"></a><span id="l58.27">     assert_rnp_success(</span>
<a href="#l58.28"></a><span id="l58.28">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.signed.malfsig&quot;));</span>
<a href="#l58.29"></a><span id="l58.29">     assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.30"></a><span id="l58.30">     assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l58.31"></a><span id="l58.31">     assert_rnp_failure(rnp_op_verify_execute(verify));</span>
<a href="#l58.32"></a><span id="l58.32">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.33"></a><span id="l58.33">     assert_int_equal(sigcount, 0);</span>
<a href="#l58.34"></a><span id="l58.34">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.35"></a><span id="l58.35">     rnp_input_destroy(input);</span>
<a href="#l58.36"></a><span id="l58.36">     rnp_output_destroy(output);</span>
<a href="#l58.37"></a><span id="l58.37"> </span>
<a href="#l58.38"></a><span id="l58.38">     /* signed with invalid signature (modified hash alg) */</span>
<a href="#l58.39"></a><span id="l58.39" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.40"></a><span id="l58.40">     assert_rnp_success(</span>
<a href="#l58.41"></a><span id="l58.41">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.signed.invsig&quot;));</span>
<a href="#l58.42"></a><span id="l58.42">     assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.43"></a><span id="l58.43">     assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l58.44"></a><span id="l58.44">     assert_int_equal(rnp_op_verify_execute(verify), RNP_ERROR_SIGNATURE_INVALID);</span>
<a href="#l58.45"></a><span id="l58.45">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.46"></a><span id="l58.46">     assert_int_equal(sigcount, 1);</span>
<a href="#l58.47"></a><span id="l58.47">     assert_true(check_signature(verify, 0, RNP_ERROR_SIGNATURE_INVALID));</span>
<a href="#l58.48"></a><span id="l58.48">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.49"></a><span id="l58.49">     rnp_input_destroy(input);</span>
<a href="#l58.50"></a><span id="l58.50">     rnp_output_destroy(output);</span>
<a href="#l58.51"></a><span id="l58.51"> </span>
<a href="#l58.52"></a><span id="l58.52">     /* signed without the signature */</span>
<a href="#l58.53"></a><span id="l58.53" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.54"></a><span id="l58.54">     assert_rnp_success(</span>
<a href="#l58.55"></a><span id="l58.55">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.signed.nosig&quot;));</span>
<a href="#l58.56"></a><span id="l58.56">     assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.57"></a><span id="l58.57">     assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l58.58"></a><span id="l58.58">     assert_rnp_failure(rnp_op_verify_execute(verify));</span>
<a href="#l58.59"></a><span id="l58.59">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.60"></a><span id="l58.60">     assert_int_equal(sigcount, 0);</span>
<a href="#l58.61"></a><span id="l58.61">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.62"></a><span id="l58.62">     rnp_input_destroy(input);</span>
<a href="#l58.63"></a><span id="l58.63">     rnp_output_destroy(output);</span>
<a href="#l58.64"></a><span id="l58.64"> </span>
<a href="#l58.65"></a><span id="l58.65">     /* detached signature */</span>
<a href="#l58.66"></a><span id="l58.66">     rnp_input_t source = NULL;</span>
<a href="#l58.67"></a><span id="l58.67" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.68"></a><span id="l58.68">     assert_rnp_success(rnp_input_from_path(&amp;source, &quot;data/test_messages/message.txt&quot;));</span>
<a href="#l58.69"></a><span id="l58.69">     assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.sig&quot;));</span>
<a href="#l58.70"></a><span id="l58.70">     assert_rnp_success(rnp_op_verify_detached_create(&amp;verify, ffi, source, input));</span>
<a href="#l58.71"></a><span id="l58.71">     assert_rnp_success(rnp_op_verify_execute(verify));</span>
<a href="#l58.72"></a><span id="l58.72">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.73"></a><span id="l58.73">     assert_int_equal(sigcount, 1);</span>
<a href="#l58.74"></a><span id="l58.74">     assert_true(check_signature(verify, 0, RNP_SUCCESS));</span>
<a href="#l58.75"></a><span id="l58.75">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.76"></a><span id="l58.76">     rnp_input_destroy(source);</span>
<a href="#l58.77"></a><span id="l58.77">     rnp_input_destroy(input);</span>
<a href="#l58.78"></a><span id="l58.78"> </span>
<a href="#l58.79"></a><span id="l58.79">     /* malformed detached signature */</span>
<a href="#l58.80"></a><span id="l58.80" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.81"></a><span id="l58.81">     assert_rnp_success(rnp_input_from_path(&amp;source, &quot;data/test_messages/message.txt&quot;));</span>
<a href="#l58.82"></a><span id="l58.82">     assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.sig.malf&quot;));</span>
<a href="#l58.83"></a><span id="l58.83">     assert_rnp_success(rnp_op_verify_detached_create(&amp;verify, ffi, source, input));</span>
<a href="#l58.84"></a><span id="l58.84">     assert_rnp_failure(rnp_op_verify_execute(verify));</span>
<a href="#l58.85"></a><span id="l58.85">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.86"></a><span id="l58.86">     assert_int_equal(sigcount, 0);</span>
<a href="#l58.87"></a><span id="l58.87">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.88"></a><span id="l58.88">     rnp_input_destroy(source);</span>
<a href="#l58.89"></a><span id="l58.89">     rnp_input_destroy(input);</span>
<a href="#l58.90"></a><span id="l58.90"> </span>
<a href="#l58.91"></a><span id="l58.91">     /* malformed detached signature, wrong bitlen in MPI  */</span>
<a href="#l58.92"></a><span id="l58.92" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.93"></a><span id="l58.93">     assert_rnp_success(rnp_input_from_path(&amp;source, &quot;data/test_messages/message.txt&quot;));</span>
<a href="#l58.94"></a><span id="l58.94">     assert_rnp_success(</span>
<a href="#l58.95"></a><span id="l58.95">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.sig.wrong-mpi-bitlen&quot;));</span>
<a href="#l58.96"></a><span id="l58.96">     assert_rnp_success(rnp_op_verify_detached_create(&amp;verify, ffi, source, input));</span>
<a href="#l58.97"></a><span id="l58.97" class="difflineminus">-    assert_int_equal(rnp_op_verify_execute(verify), RNP_ERROR_BAD_PARAMETERS);</span>
<a href="#l58.98"></a><span id="l58.98" class="difflineplus">+    assert_rnp_success(rnp_op_verify_execute(verify));</span>
<a href="#l58.99"></a><span id="l58.99">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.100"></a><span id="l58.100" class="difflineminus">-    assert_int_equal(sigcount, 0);</span>
<a href="#l58.101"></a><span id="l58.101" class="difflineplus">+    assert_int_equal(sigcount, 1);</span>
<a href="#l58.102"></a><span id="l58.102">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.103"></a><span id="l58.103">     rnp_input_destroy(source);</span>
<a href="#l58.104"></a><span id="l58.104">     rnp_input_destroy(input);</span>
<a href="#l58.105"></a><span id="l58.105"> </span>
<a href="#l58.106"></a><span id="l58.106">     /* encrypted message */</span>
<a href="#l58.107"></a><span id="l58.107" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.108"></a><span id="l58.108">     assert_rnp_success(</span>
<a href="#l58.109"></a><span id="l58.109">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.encrypted&quot;));</span>
<a href="#l58.110"></a><span id="l58.110">     assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.111"></a><span id="l58.111">     assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;password&quot;));</span>
<a href="#l58.112"></a><span id="l58.112">     assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l58.113"></a><span id="l58.113">     assert_rnp_success(rnp_op_verify_execute(verify));</span>
<a href="#l58.114"></a><span id="l58.114">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.115"></a><span id="l58.115">     assert_int_equal(sigcount, 0);</span>
<a href="#l58.116"></a><span id="l58.116">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.117"></a><span id="l58.117">     rnp_input_destroy(input);</span>
<a href="#l58.118"></a><span id="l58.118">     rnp_output_destroy(output);</span>
<a href="#l58.119"></a><span id="l58.119"> </span>
<a href="#l58.120"></a><span id="l58.120">     /* encrypted and signed message */</span>
<a href="#l58.121"></a><span id="l58.121" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.122"></a><span id="l58.122">     assert_rnp_success(</span>
<a href="#l58.123"></a><span id="l58.123">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.signed-encrypted&quot;));</span>
<a href="#l58.124"></a><span id="l58.124">     assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.125"></a><span id="l58.125">     assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l58.126"></a><span id="l58.126">     assert_rnp_success(rnp_op_verify_execute(verify));</span>
<a href="#l58.127"></a><span id="l58.127">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.128"></a><span id="l58.128">     assert_int_equal(sigcount, 1);</span>
<a href="#l58.129"></a><span id="l58.129">     assert_true(check_signature(verify, 0, RNP_SUCCESS));</span>
<a href="#l58.130"></a><span id="l58.130">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.131"></a><span id="l58.131">     rnp_input_destroy(input);</span>
<a href="#l58.132"></a><span id="l58.132">     rnp_output_destroy(output);</span>
<a href="#l58.133"></a><span id="l58.133"> </span>
<a href="#l58.134"></a><span id="l58.134">     /* cleartext signed message */</span>
<a href="#l58.135"></a><span id="l58.135" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.136"></a><span id="l58.136">     assert_rnp_success(</span>
<a href="#l58.137"></a><span id="l58.137">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.cleartext-signed&quot;));</span>
<a href="#l58.138"></a><span id="l58.138">     assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.139"></a><span id="l58.139">     assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l58.140"></a><span id="l58.140">     assert_rnp_success(rnp_op_verify_execute(verify));</span>
<a href="#l58.141"></a><span id="l58.141">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.142"></a><span id="l58.142">     assert_int_equal(sigcount, 1);</span>
<a href="#l58.143"></a><span id="l58.143">     assert_true(check_signature(verify, 0, RNP_SUCCESS));</span>
<a href="#l58.144"></a><span id="l58.144">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.145"></a><span id="l58.145">     rnp_input_destroy(input);</span>
<a href="#l58.146"></a><span id="l58.146">     rnp_output_destroy(output);</span>
<a href="#l58.147"></a><span id="l58.147"> </span>
<a href="#l58.148"></a><span id="l58.148">     /* cleartext signed with malformed signature (wrong mpi len) */</span>
<a href="#l58.149"></a><span id="l58.149" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.150"></a><span id="l58.150">     assert_rnp_success(</span>
<a href="#l58.151"></a><span id="l58.151">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.cleartext-malf&quot;));</span>
<a href="#l58.152"></a><span id="l58.152">     assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.153"></a><span id="l58.153">     assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l58.154"></a><span id="l58.154">     assert_int_equal(rnp_op_verify_execute(verify), RNP_ERROR_SIGNATURE_INVALID);</span>
<a href="#l58.155"></a><span id="l58.155">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.156"></a><span id="l58.156">     assert_int_equal(sigcount, 1);</span>
<a href="#l58.157"></a><span id="l58.157">     assert_true(check_signature(verify, 0, RNP_ERROR_SIGNATURE_INVALID));</span>
<a href="#l58.158"></a><span id="l58.158">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.159"></a><span id="l58.159">     rnp_input_destroy(input);</span>
<a href="#l58.160"></a><span id="l58.160">     rnp_output_destroy(output);</span>
<a href="#l58.161"></a><span id="l58.161"> </span>
<a href="#l58.162"></a><span id="l58.162">     /* cleartext signed without the signature */</span>
<a href="#l58.163"></a><span id="l58.163" class="difflineplus">+    sigcount = 255;</span>
<a href="#l58.164"></a><span id="l58.164">     assert_rnp_success(</span>
<a href="#l58.165"></a><span id="l58.165">       rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.cleartext-nosig&quot;));</span>
<a href="#l58.166"></a><span id="l58.166">     assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.167"></a><span id="l58.167">     assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l58.168"></a><span id="l58.168">     assert_rnp_failure(rnp_op_verify_execute(verify));</span>
<a href="#l58.169"></a><span id="l58.169">     assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;sigcount));</span>
<a href="#l58.170"></a><span id="l58.170">     assert_int_equal(sigcount, 0);</span>
<a href="#l58.171"></a><span id="l58.171">     rnp_op_verify_destroy(verify);</span>
<a href="#l58.172"></a><span id="l58.172" class="difflineat">@@ -7491,8 +7503,176 @@ TEST_F(rnp_tests, test_ffi_mdc_8k_bounda</span>
<a href="#l58.173"></a><span id="l58.173">     assert_rnp_failure(rnp_op_verify_execute(verify));</span>
<a href="#l58.174"></a><span id="l58.174">     /* cleanup */</span>
<a href="#l58.175"></a><span id="l58.175">     assert_rnp_success(rnp_op_verify_destroy(verify));</span>
<a href="#l58.176"></a><span id="l58.176">     assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l58.177"></a><span id="l58.177"> </span>
<a href="#l58.178"></a><span id="l58.178">     assert_rnp_success(rnp_output_destroy(output));</span>
<a href="#l58.179"></a><span id="l58.179">     assert_rnp_success(rnp_ffi_destroy(ffi));</span>
<a href="#l58.180"></a><span id="l58.180"> }</span>
<a href="#l58.181"></a><span id="l58.181" class="difflineplus">+</span>
<a href="#l58.182"></a><span id="l58.182" class="difflineplus">+TEST_F(rnp_tests, test_ffi_decrypt_wrong_mpi_bits)</span>
<a href="#l58.183"></a><span id="l58.183" class="difflineplus">+{</span>
<a href="#l58.184"></a><span id="l58.184" class="difflineplus">+    rnp_ffi_t    ffi = NULL;</span>
<a href="#l58.185"></a><span id="l58.185" class="difflineplus">+    rnp_input_t  input = NULL;</span>
<a href="#l58.186"></a><span id="l58.186" class="difflineplus">+    rnp_output_t output = NULL;</span>
<a href="#l58.187"></a><span id="l58.187" class="difflineplus">+</span>
<a href="#l58.188"></a><span id="l58.188" class="difflineplus">+    // init ffi</span>
<a href="#l58.189"></a><span id="l58.189" class="difflineplus">+    test_ffi_init(&amp;ffi);</span>
<a href="#l58.190"></a><span id="l58.190" class="difflineplus">+</span>
<a href="#l58.191"></a><span id="l58.191" class="difflineplus">+    /* 1024 bitcount instead of 1023 */</span>
<a href="#l58.192"></a><span id="l58.192" class="difflineplus">+    rnp_op_verify_t op = NULL;</span>
<a href="#l58.193"></a><span id="l58.193" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l58.194"></a><span id="l58.194" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.enc-malf-1&quot;));</span>
<a href="#l58.195"></a><span id="l58.195" class="difflineplus">+    assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.196"></a><span id="l58.196" class="difflineplus">+    assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;password&quot;));</span>
<a href="#l58.197"></a><span id="l58.197" class="difflineplus">+    assert_rnp_success(rnp_op_verify_create(&amp;op, ffi, input, output));</span>
<a href="#l58.198"></a><span id="l58.198" class="difflineplus">+    assert_rnp_success(rnp_op_verify_execute(op));</span>
<a href="#l58.199"></a><span id="l58.199" class="difflineplus">+    rnp_op_verify_destroy(op);</span>
<a href="#l58.200"></a><span id="l58.200" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l58.201"></a><span id="l58.201" class="difflineplus">+    rnp_output_destroy(output);</span>
<a href="#l58.202"></a><span id="l58.202" class="difflineplus">+</span>
<a href="#l58.203"></a><span id="l58.203" class="difflineplus">+    /* 1025 bitcount instead of 1023 */</span>
<a href="#l58.204"></a><span id="l58.204" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l58.205"></a><span id="l58.205" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.enc-malf-2&quot;));</span>
<a href="#l58.206"></a><span id="l58.206" class="difflineplus">+    assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.207"></a><span id="l58.207" class="difflineplus">+    assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;password&quot;));</span>
<a href="#l58.208"></a><span id="l58.208" class="difflineplus">+    assert_rnp_success(rnp_op_verify_create(&amp;op, ffi, input, output));</span>
<a href="#l58.209"></a><span id="l58.209" class="difflineplus">+    assert_rnp_success(rnp_op_verify_execute(op));</span>
<a href="#l58.210"></a><span id="l58.210" class="difflineplus">+    rnp_op_verify_destroy(op);</span>
<a href="#l58.211"></a><span id="l58.211" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l58.212"></a><span id="l58.212" class="difflineplus">+    rnp_output_destroy(output);</span>
<a href="#l58.213"></a><span id="l58.213" class="difflineplus">+</span>
<a href="#l58.214"></a><span id="l58.214" class="difflineplus">+    /* 1031 bitcount instead of 1023 */</span>
<a href="#l58.215"></a><span id="l58.215" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l58.216"></a><span id="l58.216" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.enc-malf-3&quot;));</span>
<a href="#l58.217"></a><span id="l58.217" class="difflineplus">+    assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.218"></a><span id="l58.218" class="difflineplus">+    assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;password&quot;));</span>
<a href="#l58.219"></a><span id="l58.219" class="difflineplus">+    assert_rnp_success(rnp_op_verify_create(&amp;op, ffi, input, output));</span>
<a href="#l58.220"></a><span id="l58.220" class="difflineplus">+    assert_rnp_success(rnp_op_verify_execute(op));</span>
<a href="#l58.221"></a><span id="l58.221" class="difflineplus">+    rnp_op_verify_destroy(op);</span>
<a href="#l58.222"></a><span id="l58.222" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l58.223"></a><span id="l58.223" class="difflineplus">+    rnp_output_destroy(output);</span>
<a href="#l58.224"></a><span id="l58.224" class="difflineplus">+</span>
<a href="#l58.225"></a><span id="l58.225" class="difflineplus">+    /* 1040 bitcount instead of 1023 */</span>
<a href="#l58.226"></a><span id="l58.226" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l58.227"></a><span id="l58.227" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.enc-malf-4&quot;));</span>
<a href="#l58.228"></a><span id="l58.228" class="difflineplus">+    assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.229"></a><span id="l58.229" class="difflineplus">+    assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;password&quot;));</span>
<a href="#l58.230"></a><span id="l58.230" class="difflineplus">+    assert_rnp_success(rnp_op_verify_create(&amp;op, ffi, input, output));</span>
<a href="#l58.231"></a><span id="l58.231" class="difflineplus">+    assert_rnp_success(rnp_op_verify_execute(op));</span>
<a href="#l58.232"></a><span id="l58.232" class="difflineplus">+    rnp_op_verify_destroy(op);</span>
<a href="#l58.233"></a><span id="l58.233" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l58.234"></a><span id="l58.234" class="difflineplus">+    rnp_output_destroy(output);</span>
<a href="#l58.235"></a><span id="l58.235" class="difflineplus">+</span>
<a href="#l58.236"></a><span id="l58.236" class="difflineplus">+    /* 1017 bitcount instead of 1023 */</span>
<a href="#l58.237"></a><span id="l58.237" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l58.238"></a><span id="l58.238" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.enc-malf-5&quot;));</span>
<a href="#l58.239"></a><span id="l58.239" class="difflineplus">+    assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l58.240"></a><span id="l58.240" class="difflineplus">+    assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;password&quot;));</span>
<a href="#l58.241"></a><span id="l58.241" class="difflineplus">+    assert_rnp_success(rnp_op_verify_create(&amp;op, ffi, input, output));</span>
<a href="#l58.242"></a><span id="l58.242" class="difflineplus">+    assert_rnp_success(rnp_op_verify_execute(op));</span>
<a href="#l58.243"></a><span id="l58.243" class="difflineplus">+    rnp_op_verify_destroy(op);</span>
<a href="#l58.244"></a><span id="l58.244" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l58.245"></a><span id="l58.245" class="difflineplus">+    rnp_output_destroy(output);</span>
<a href="#l58.246"></a><span id="l58.246" class="difflineplus">+</span>
<a href="#l58.247"></a><span id="l58.247" class="difflineplus">+    rnp_ffi_destroy(ffi);</span>
<a href="#l58.248"></a><span id="l58.248" class="difflineplus">+}</span>
<a href="#l58.249"></a><span id="l58.249" class="difflineplus">+</span>
<a href="#l58.250"></a><span id="l58.250" class="difflineplus">+TEST_F(rnp_tests, test_ffi_key_import_edge_cases)</span>
<a href="#l58.251"></a><span id="l58.251" class="difflineplus">+{</span>
<a href="#l58.252"></a><span id="l58.252" class="difflineplus">+    rnp_ffi_t ffi = NULL;</span>
<a href="#l58.253"></a><span id="l58.253" class="difflineplus">+    assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l58.254"></a><span id="l58.254" class="difflineplus">+</span>
<a href="#l58.255"></a><span id="l58.255" class="difflineplus">+    /* key with empty packets - must fail with bad format */</span>
<a href="#l58.256"></a><span id="l58.256" class="difflineplus">+    rnp_input_t input = NULL;</span>
<a href="#l58.257"></a><span id="l58.257" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l58.258"></a><span id="l58.258" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/key-empty-packets.pgp&quot;));</span>
<a href="#l58.259"></a><span id="l58.259" class="difflineplus">+    char *results = NULL;</span>
<a href="#l58.260"></a><span id="l58.260" class="difflineplus">+    assert_int_equal(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, &amp;results),</span>
<a href="#l58.261"></a><span id="l58.261" class="difflineplus">+                     RNP_ERROR_BAD_FORMAT);</span>
<a href="#l58.262"></a><span id="l58.262" class="difflineplus">+    assert_null(results);</span>
<a href="#l58.263"></a><span id="l58.263" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l58.264"></a><span id="l58.264" class="difflineplus">+</span>
<a href="#l58.265"></a><span id="l58.265" class="difflineplus">+    /* key with empty uid - must succeed */</span>
<a href="#l58.266"></a><span id="l58.266" class="difflineplus">+    json_object *jso = NULL;</span>
<a href="#l58.267"></a><span id="l58.267" class="difflineplus">+    json_object *jsokeys = NULL;</span>
<a href="#l58.268"></a><span id="l58.268" class="difflineplus">+    assert_true(check_import_keys(</span>
<a href="#l58.269"></a><span id="l58.269" class="difflineplus">+      ffi, &amp;jso, &amp;jsokeys, &quot;data/test_key_edge_cases/key-empty-uid.pgp&quot;, 1, 0));</span>
<a href="#l58.270"></a><span id="l58.270" class="difflineplus">+    assert_int_equal(json_object_array_length(jsokeys), 1);</span>
<a href="#l58.271"></a><span id="l58.271" class="difflineplus">+    json_object *jsokey = json_object_array_get_idx(jsokeys, 0);</span>
<a href="#l58.272"></a><span id="l58.272" class="difflineplus">+    assert_true(</span>
<a href="#l58.273"></a><span id="l58.273" class="difflineplus">+      check_key_status(jsokey, &quot;new&quot;, &quot;none&quot;, &quot;753d5b947e9a2b2e01147c1fc972affd358bf887&quot;));</span>
<a href="#l58.274"></a><span id="l58.274" class="difflineplus">+    json_object_put(jso);</span>
<a href="#l58.275"></a><span id="l58.275" class="difflineplus">+</span>
<a href="#l58.276"></a><span id="l58.276" class="difflineplus">+    /* key with experimental signature subpackets - must succeed and append uid and signature</span>
<a href="#l58.277"></a><span id="l58.277" class="difflineplus">+     */</span>
<a href="#l58.278"></a><span id="l58.278" class="difflineplus">+    assert_true(check_import_keys(</span>
<a href="#l58.279"></a><span id="l58.279" class="difflineplus">+      ffi, &amp;jso, &amp;jsokeys, &quot;data/test_key_edge_cases/key-subpacket-101-110.pgp&quot;, 1, 0));</span>
<a href="#l58.280"></a><span id="l58.280" class="difflineplus">+    assert_int_equal(json_object_array_length(jsokeys), 1);</span>
<a href="#l58.281"></a><span id="l58.281" class="difflineplus">+    jsokey = json_object_array_get_idx(jsokeys, 0);</span>
<a href="#l58.282"></a><span id="l58.282" class="difflineplus">+    assert_true(</span>
<a href="#l58.283"></a><span id="l58.283" class="difflineplus">+      check_key_status(jsokey, &quot;updated&quot;, &quot;none&quot;, &quot;753d5b947e9a2b2e01147c1fc972affd358bf887&quot;));</span>
<a href="#l58.284"></a><span id="l58.284" class="difflineplus">+    json_object_put(jso);</span>
<a href="#l58.285"></a><span id="l58.285" class="difflineplus">+</span>
<a href="#l58.286"></a><span id="l58.286" class="difflineplus">+    rnp_key_handle_t key = NULL;</span>
<a href="#l58.287"></a><span id="l58.287" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;C972AFFD358BF887&quot;, &amp;key));</span>
<a href="#l58.288"></a><span id="l58.288" class="difflineplus">+    size_t count = 0;</span>
<a href="#l58.289"></a><span id="l58.289" class="difflineplus">+    assert_rnp_success(rnp_key_get_uid_count(key, &amp;count));</span>
<a href="#l58.290"></a><span id="l58.290" class="difflineplus">+    assert_int_equal(count, 2);</span>
<a href="#l58.291"></a><span id="l58.291" class="difflineplus">+    char *uid = NULL;</span>
<a href="#l58.292"></a><span id="l58.292" class="difflineplus">+    assert_rnp_success(rnp_key_get_uid_at(key, 0, &amp;uid));</span>
<a href="#l58.293"></a><span id="l58.293" class="difflineplus">+    assert_int_equal(strcmp(uid, &quot;&quot;), 0);</span>
<a href="#l58.294"></a><span id="l58.294" class="difflineplus">+    rnp_buffer_destroy(uid);</span>
<a href="#l58.295"></a><span id="l58.295" class="difflineplus">+    assert_rnp_success(rnp_key_get_uid_at(key, 1, &amp;uid));</span>
<a href="#l58.296"></a><span id="l58.296" class="difflineplus">+    assert_int_equal(strcmp(uid, &quot;NoUID&quot;), 0);</span>
<a href="#l58.297"></a><span id="l58.297" class="difflineplus">+    rnp_buffer_destroy(uid);</span>
<a href="#l58.298"></a><span id="l58.298" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l58.299"></a><span id="l58.299" class="difflineplus">+</span>
<a href="#l58.300"></a><span id="l58.300" class="difflineplus">+    /* key with malformed signature - must fail */</span>
<a href="#l58.301"></a><span id="l58.301" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l58.302"></a><span id="l58.302" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/key-malf-sig.pgp&quot;));</span>
<a href="#l58.303"></a><span id="l58.303" class="difflineplus">+    assert_int_equal(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, &amp;results),</span>
<a href="#l58.304"></a><span id="l58.304" class="difflineplus">+                     RNP_ERROR_BAD_FORMAT);</span>
<a href="#l58.305"></a><span id="l58.305" class="difflineplus">+    assert_null(results);</span>
<a href="#l58.306"></a><span id="l58.306" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l58.307"></a><span id="l58.307" class="difflineplus">+</span>
<a href="#l58.308"></a><span id="l58.308" class="difflineplus">+    /* revoked key without revocation reason signature subpacket */</span>
<a href="#l58.309"></a><span id="l58.309" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l58.310"></a><span id="l58.310" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/alice-rev-no-reason.pgp&quot;));</span>
<a href="#l58.311"></a><span id="l58.311" class="difflineplus">+    assert_rnp_success(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, &amp;results));</span>
<a href="#l58.312"></a><span id="l58.312" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l58.313"></a><span id="l58.313" class="difflineplus">+    assert_non_null(results);</span>
<a href="#l58.314"></a><span id="l58.314" class="difflineplus">+    rnp_buffer_destroy(results);</span>
<a href="#l58.315"></a><span id="l58.315" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;0451409669FFDE3C&quot;, &amp;key));</span>
<a href="#l58.316"></a><span id="l58.316" class="difflineplus">+    assert_rnp_success(rnp_key_get_revocation_reason(key, &amp;results));</span>
<a href="#l58.317"></a><span id="l58.317" class="difflineplus">+    assert_int_equal(strcmp(results, &quot;No reason specified&quot;), 0);</span>
<a href="#l58.318"></a><span id="l58.318" class="difflineplus">+    rnp_buffer_destroy(results);</span>
<a href="#l58.319"></a><span id="l58.319" class="difflineplus">+    bool revoked = false;</span>
<a href="#l58.320"></a><span id="l58.320" class="difflineplus">+    assert_rnp_success(rnp_key_is_revoked(key, &amp;revoked));</span>
<a href="#l58.321"></a><span id="l58.321" class="difflineplus">+    assert_true(revoked);</span>
<a href="#l58.322"></a><span id="l58.322" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l58.323"></a><span id="l58.323" class="difflineplus">+    assert_rnp_success(rnp_unload_keys(ffi, RNP_KEY_UNLOAD_PUBLIC));</span>
<a href="#l58.324"></a><span id="l58.324" class="difflineplus">+</span>
<a href="#l58.325"></a><span id="l58.325" class="difflineplus">+    /* revoked subkey without revocation reason signature subpacket */</span>
<a href="#l58.326"></a><span id="l58.326" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l58.327"></a><span id="l58.327" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/alice-sub-rev-no-reason.pgp&quot;));</span>
<a href="#l58.328"></a><span id="l58.328" class="difflineplus">+    assert_rnp_success(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, &amp;results));</span>
<a href="#l58.329"></a><span id="l58.329" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l58.330"></a><span id="l58.330" class="difflineplus">+    assert_non_null(results);</span>
<a href="#l58.331"></a><span id="l58.331" class="difflineplus">+    rnp_buffer_destroy(results);</span>
<a href="#l58.332"></a><span id="l58.332" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;0451409669FFDE3C&quot;, &amp;key));</span>
<a href="#l58.333"></a><span id="l58.333" class="difflineplus">+    assert_int_equal(rnp_key_get_revocation_reason(key, &amp;results), RNP_ERROR_BAD_PARAMETERS);</span>
<a href="#l58.334"></a><span id="l58.334" class="difflineplus">+    revoked = true;</span>
<a href="#l58.335"></a><span id="l58.335" class="difflineplus">+    assert_rnp_success(rnp_key_is_revoked(key, &amp;revoked));</span>
<a href="#l58.336"></a><span id="l58.336" class="difflineplus">+    assert_false(revoked);</span>
<a href="#l58.337"></a><span id="l58.337" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l58.338"></a><span id="l58.338" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;DD23CEB7FEBEFF17&quot;, &amp;key));</span>
<a href="#l58.339"></a><span id="l58.339" class="difflineplus">+    assert_rnp_success(rnp_key_get_revocation_reason(key, &amp;results));</span>
<a href="#l58.340"></a><span id="l58.340" class="difflineplus">+    assert_int_equal(strcmp(results, &quot;No reason specified&quot;), 0);</span>
<a href="#l58.341"></a><span id="l58.341" class="difflineplus">+    rnp_buffer_destroy(results);</span>
<a href="#l58.342"></a><span id="l58.342" class="difflineplus">+    revoked = false;</span>
<a href="#l58.343"></a><span id="l58.343" class="difflineplus">+    assert_rnp_success(rnp_key_is_revoked(key, &amp;revoked));</span>
<a href="#l58.344"></a><span id="l58.344" class="difflineplus">+    assert_true(revoked);</span>
<a href="#l58.345"></a><span id="l58.345" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l58.346"></a><span id="l58.346" class="difflineplus">+</span>
<a href="#l58.347"></a><span id="l58.347" class="difflineplus">+    rnp_ffi_destroy(ffi);</span>
<a href="#l58.348"></a><span id="l58.348" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l59.1"></a><span id="l59.1" class="difflineminus">--- a/third_party/rnp/src/tests/generatekey.cpp</span>
<a href="#l59.2"></a><span id="l59.2" class="difflineplus">+++ b/third_party/rnp/src/tests/generatekey.cpp</span>
<a href="#l59.3"></a><span id="l59.3" class="difflineat">@@ -897,36 +897,32 @@ TEST_F(rnp_tests, generatekeyECDSA_expli</span>
<a href="#l59.4"></a><span id="l59.4">     cli_rnp_end(&amp;rnp);</span>
<a href="#l59.5"></a><span id="l59.5"> }</span>
<a href="#l59.6"></a><span id="l59.6"> </span>
<a href="#l59.7"></a><span id="l59.7"> /* This tests some of the mid-level key generation functions and their</span>
<a href="#l59.8"></a><span id="l59.8">  * generated sigs in the keyring.</span>
<a href="#l59.9"></a><span id="l59.9">  */</span>
<a href="#l59.10"></a><span id="l59.10"> TEST_F(rnp_tests, test_generated_key_sigs)</span>
<a href="#l59.11"></a><span id="l59.11"> {</span>
<a href="#l59.12"></a><span id="l59.12" class="difflineminus">-    rnp_key_store_t *pubring = NULL;</span>
<a href="#l59.13"></a><span id="l59.13" class="difflineminus">-    rnp_key_store_t *secring = NULL;</span>
<a href="#l59.14"></a><span id="l59.14" class="difflineplus">+    rnp_key_store_t *pubring = new rnp_key_store_t();</span>
<a href="#l59.15"></a><span id="l59.15" class="difflineplus">+    rnp_key_store_t *secring = new rnp_key_store_t();</span>
<a href="#l59.16"></a><span id="l59.16">     pgp_key_t *      primary_pub = NULL, *primary_sec = NULL;</span>
<a href="#l59.17"></a><span id="l59.17">     pgp_key_t *      sub_pub = NULL, *sub_sec = NULL;</span>
<a href="#l59.18"></a><span id="l59.18"> </span>
<a href="#l59.19"></a><span id="l59.19" class="difflineminus">-    // create a couple keyrings</span>
<a href="#l59.20"></a><span id="l59.20" class="difflineminus">-    pubring = (rnp_key_store_t *) calloc(1, sizeof(*pubring));</span>
<a href="#l59.21"></a><span id="l59.21" class="difflineminus">-    secring = (rnp_key_store_t *) calloc(1, sizeof(*secring));</span>
<a href="#l59.22"></a><span id="l59.22" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l59.23"></a><span id="l59.23" class="difflineminus">-    assert_non_null(secring);</span>
<a href="#l59.24"></a><span id="l59.24" class="difflineminus">-</span>
<a href="#l59.25"></a><span id="l59.25">     // primary</span>
<a href="#l59.26"></a><span id="l59.26">     {</span>
<a href="#l59.27"></a><span id="l59.27">         pgp_key_t                 pub = {};</span>
<a href="#l59.28"></a><span id="l59.28">         pgp_key_t                 sec = {};</span>
<a href="#l59.29"></a><span id="l59.29">         rnp_keygen_primary_desc_t desc;</span>
<a href="#l59.30"></a><span id="l59.30">         pgp_fingerprint_t         fp = {};</span>
<a href="#l59.31"></a><span id="l59.31">         pgp_sig_subpkt_t *        subpkt = NULL;</span>
<a href="#l59.32"></a><span id="l59.32">         pgp_signature_t *         psig = NULL;</span>
<a href="#l59.33"></a><span id="l59.33">         pgp_signature_t *         ssig = NULL;</span>
<a href="#l59.34"></a><span id="l59.34" class="difflineplus">+        pgp_signature_info_t      psiginfo = {};</span>
<a href="#l59.35"></a><span id="l59.35" class="difflineplus">+        pgp_signature_info_t      ssiginfo = {};</span>
<a href="#l59.36"></a><span id="l59.36"> </span>
<a href="#l59.37"></a><span id="l59.37">         memset(&amp;desc, 0, sizeof(desc));</span>
<a href="#l59.38"></a><span id="l59.38">         desc.crypto.key_alg = PGP_PKA_RSA;</span>
<a href="#l59.39"></a><span id="l59.39">         desc.crypto.rsa.modulus_bit_len = 1024;</span>
<a href="#l59.40"></a><span id="l59.40">         desc.crypto.rng = &amp;global_rng;</span>
<a href="#l59.41"></a><span id="l59.41">         strcpy((char *) desc.cert.userid, &quot;test&quot;);</span>
<a href="#l59.42"></a><span id="l59.42"> </span>
<a href="#l59.43"></a><span id="l59.43">         // generate</span>
<a href="#l59.44"></a><span id="l59.44" class="difflineat">@@ -951,70 +947,67 @@ TEST_F(rnp_tests, test_generated_key_sig</span>
<a href="#l59.45"></a><span id="l59.45">         assert_int_equal(1, pgp_key_get_subsig_count(&amp;pub));</span>
<a href="#l59.46"></a><span id="l59.46">         assert_int_equal(1, pgp_key_get_subsig_count(&amp;sec));</span>
<a href="#l59.47"></a><span id="l59.47">         psig = &amp;pgp_key_get_subsig(&amp;pub, 0)-&gt;sig;</span>
<a href="#l59.48"></a><span id="l59.48">         ssig = &amp;pgp_key_get_subsig(&amp;sec, 0)-&gt;sig;</span>
<a href="#l59.49"></a><span id="l59.49">         // make sure our sig MPI is not NULL</span>
<a href="#l59.50"></a><span id="l59.50">         assert_int_not_equal(psig-&gt;material.rsa.s.len, 0);</span>
<a href="#l59.51"></a><span id="l59.51">         assert_int_not_equal(ssig-&gt;material.rsa.s.len, 0);</span>
<a href="#l59.52"></a><span id="l59.52">         // make sure we're targeting the right packet</span>
<a href="#l59.53"></a><span id="l59.53" class="difflineminus">-        assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_rawpacket(&amp;pub, 2)-&gt;tag);</span>
<a href="#l59.54"></a><span id="l59.54" class="difflineminus">-        assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_rawpacket(&amp;sec, 2)-&gt;tag);</span>
<a href="#l59.55"></a><span id="l59.55" class="difflineplus">+        assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_subsig(&amp;pub, 0)-&gt;rawpkt.tag);</span>
<a href="#l59.56"></a><span id="l59.56" class="difflineplus">+        assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_subsig(&amp;sec, 0)-&gt;rawpkt.tag);</span>
<a href="#l59.57"></a><span id="l59.57"> </span>
<a href="#l59.58"></a><span id="l59.58">         // validate the userid self-sig</span>
<a href="#l59.59"></a><span id="l59.59"> </span>
<a href="#l59.60"></a><span id="l59.60" class="difflineminus">-        assert_rnp_success(signature_validate_certification(psig,</span>
<a href="#l59.61"></a><span id="l59.61" class="difflineminus">-                                                            pgp_key_get_pkt(&amp;pub),</span>
<a href="#l59.62"></a><span id="l59.62" class="difflineminus">-                                                            &amp;pgp_key_get_userid(&amp;pub, 0)-&gt;pkt,</span>
<a href="#l59.63"></a><span id="l59.63" class="difflineminus">-                                                            pgp_key_get_material(&amp;pub)));</span>
<a href="#l59.64"></a><span id="l59.64" class="difflineplus">+        psiginfo.sig = psig;</span>
<a href="#l59.65"></a><span id="l59.65" class="difflineplus">+        psiginfo.signer = &amp;pub;</span>
<a href="#l59.66"></a><span id="l59.66" class="difflineplus">+        assert_rnp_success(signature_check_certification(</span>
<a href="#l59.67"></a><span id="l59.67" class="difflineplus">+          &amp;psiginfo, pgp_key_get_pkt(&amp;pub), &amp;pgp_key_get_userid(&amp;pub, 0)-&gt;pkt));</span>
<a href="#l59.68"></a><span id="l59.68">         assert_true(signature_get_keyfp(psig, &amp;fp));</span>
<a href="#l59.69"></a><span id="l59.69">         assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(&amp;pub)));</span>
<a href="#l59.70"></a><span id="l59.70">         // check subpackets and their contents</span>
<a href="#l59.71"></a><span id="l59.71">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_ISSUER_FPR);</span>
<a href="#l59.72"></a><span id="l59.72">         assert_non_null(subpkt);</span>
<a href="#l59.73"></a><span id="l59.73">         assert_true(subpkt-&gt;hashed);</span>
<a href="#l59.74"></a><span id="l59.74">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_ISSUER_KEY_ID);</span>
<a href="#l59.75"></a><span id="l59.75">         assert_non_null(subpkt);</span>
<a href="#l59.76"></a><span id="l59.76">         assert_false(subpkt-&gt;hashed);</span>
<a href="#l59.77"></a><span id="l59.77">         assert_int_equal(</span>
<a href="#l59.78"></a><span id="l59.78">           0, memcmp(subpkt-&gt;fields.issuer, pgp_key_get_keyid(&amp;pub), PGP_KEY_ID_SIZE));</span>
<a href="#l59.79"></a><span id="l59.79">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_CREATION_TIME);</span>
<a href="#l59.80"></a><span id="l59.80">         assert_non_null(subpkt);</span>
<a href="#l59.81"></a><span id="l59.81">         assert_true(subpkt-&gt;hashed);</span>
<a href="#l59.82"></a><span id="l59.82">         assert_true(subpkt-&gt;fields.create &lt;= time(NULL));</span>
<a href="#l59.83"></a><span id="l59.83"> </span>
<a href="#l59.84"></a><span id="l59.84" class="difflineminus">-        assert_rnp_success(signature_validate_certification(ssig,</span>
<a href="#l59.85"></a><span id="l59.85" class="difflineminus">-                                                            pgp_key_get_pkt(&amp;sec),</span>
<a href="#l59.86"></a><span id="l59.86" class="difflineminus">-                                                            &amp;pgp_key_get_userid(&amp;sec, 0)-&gt;pkt,</span>
<a href="#l59.87"></a><span id="l59.87" class="difflineminus">-                                                            pgp_key_get_material(&amp;sec)));</span>
<a href="#l59.88"></a><span id="l59.88" class="difflineplus">+        ssiginfo.sig = ssig;</span>
<a href="#l59.89"></a><span id="l59.89" class="difflineplus">+        ssiginfo.signer = &amp;sec;</span>
<a href="#l59.90"></a><span id="l59.90" class="difflineplus">+        assert_rnp_success(signature_check_certification(</span>
<a href="#l59.91"></a><span id="l59.91" class="difflineplus">+          &amp;ssiginfo, pgp_key_get_pkt(&amp;sec), &amp;pgp_key_get_userid(&amp;sec, 0)-&gt;pkt));</span>
<a href="#l59.92"></a><span id="l59.92">         assert_true(signature_get_keyfp(ssig, &amp;fp));</span>
<a href="#l59.93"></a><span id="l59.93">         assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(&amp;sec)));</span>
<a href="#l59.94"></a><span id="l59.94"> </span>
<a href="#l59.95"></a><span id="l59.95">         // modify a hashed portion of the sig packets</span>
<a href="#l59.96"></a><span id="l59.96">         psig-&gt;hashed_data[32] ^= 0xff;</span>
<a href="#l59.97"></a><span id="l59.97">         ssig-&gt;hashed_data[32] ^= 0xff;</span>
<a href="#l59.98"></a><span id="l59.98">         // ensure validation fails</span>
<a href="#l59.99"></a><span id="l59.99" class="difflineminus">-        assert_rnp_failure(signature_validate_certification(psig,</span>
<a href="#l59.100"></a><span id="l59.100" class="difflineminus">-                                                            pgp_key_get_pkt(&amp;pub),</span>
<a href="#l59.101"></a><span id="l59.101" class="difflineminus">-                                                            &amp;pgp_key_get_userid(&amp;pub, 0)-&gt;pkt,</span>
<a href="#l59.102"></a><span id="l59.102" class="difflineminus">-                                                            pgp_key_get_material(&amp;pub)));</span>
<a href="#l59.103"></a><span id="l59.103" class="difflineminus">-        assert_rnp_failure(signature_validate_certification(ssig,</span>
<a href="#l59.104"></a><span id="l59.104" class="difflineminus">-                                                            pgp_key_get_pkt(&amp;sec),</span>
<a href="#l59.105"></a><span id="l59.105" class="difflineminus">-                                                            &amp;pgp_key_get_userid(&amp;sec, 0)-&gt;pkt,</span>
<a href="#l59.106"></a><span id="l59.106" class="difflineminus">-                                                            pgp_key_get_material(&amp;sec)));</span>
<a href="#l59.107"></a><span id="l59.107" class="difflineplus">+        assert_rnp_failure(signature_check_certification(</span>
<a href="#l59.108"></a><span id="l59.108" class="difflineplus">+          &amp;psiginfo, pgp_key_get_pkt(&amp;pub), &amp;pgp_key_get_userid(&amp;pub, 0)-&gt;pkt));</span>
<a href="#l59.109"></a><span id="l59.109" class="difflineplus">+        assert_rnp_failure(signature_check_certification(</span>
<a href="#l59.110"></a><span id="l59.110" class="difflineplus">+          &amp;ssiginfo, pgp_key_get_pkt(&amp;sec), &amp;pgp_key_get_userid(&amp;sec, 0)-&gt;pkt));</span>
<a href="#l59.111"></a><span id="l59.111">         // restore the original data</span>
<a href="#l59.112"></a><span id="l59.112">         psig-&gt;hashed_data[32] ^= 0xff;</span>
<a href="#l59.113"></a><span id="l59.113">         ssig-&gt;hashed_data[32] ^= 0xff;</span>
<a href="#l59.114"></a><span id="l59.114">         // ensure validation fails with incorrect uid</span>
<a href="#l59.115"></a><span id="l59.115">         pgp_userid_pkt_t uid = {</span>
<a href="#l59.116"></a><span id="l59.116">           .tag = PGP_PKT_USER_ID, .uid = (uint8_t *) &quot;fake&quot;, .uid_len = 4};</span>
<a href="#l59.117"></a><span id="l59.117" class="difflineminus">-        assert_rnp_failure(signature_validate_certification(</span>
<a href="#l59.118"></a><span id="l59.118" class="difflineminus">-          psig, pgp_key_get_pkt(&amp;pub), &amp;uid, pgp_key_get_material(&amp;pub)));</span>
<a href="#l59.119"></a><span id="l59.119" class="difflineminus">-        assert_rnp_failure(signature_validate_certification(</span>
<a href="#l59.120"></a><span id="l59.120" class="difflineminus">-          ssig, pgp_key_get_pkt(&amp;sec), &amp;uid, pgp_key_get_material(&amp;sec)));</span>
<a href="#l59.121"></a><span id="l59.121" class="difflineplus">+</span>
<a href="#l59.122"></a><span id="l59.122" class="difflineplus">+        assert_rnp_failure(</span>
<a href="#l59.123"></a><span id="l59.123" class="difflineplus">+          signature_check_certification(&amp;psiginfo, pgp_key_get_pkt(&amp;pub), &amp;uid));</span>
<a href="#l59.124"></a><span id="l59.124" class="difflineplus">+        assert_rnp_failure(</span>
<a href="#l59.125"></a><span id="l59.125" class="difflineplus">+          signature_check_certification(&amp;ssiginfo, pgp_key_get_pkt(&amp;sec), &amp;uid));</span>
<a href="#l59.126"></a><span id="l59.126"> </span>
<a href="#l59.127"></a><span id="l59.127">         // validate via an alternative method</span>
<a href="#l59.128"></a><span id="l59.128">         // primary_pub + pubring</span>
<a href="#l59.129"></a><span id="l59.129">         primary_pub-&gt;valid = false;</span>
<a href="#l59.130"></a><span id="l59.130">         primary_pub-&gt;validated = false;</span>
<a href="#l59.131"></a><span id="l59.131">         pgp_key_validate(primary_pub, pubring);</span>
<a href="#l59.132"></a><span id="l59.132">         assert_true(primary_pub-&gt;valid);</span>
<a href="#l59.133"></a><span id="l59.133">         assert_true(primary_pub-&gt;validated);</span>
<a href="#l59.134"></a><span id="l59.134" class="difflineat">@@ -1055,16 +1048,18 @@ TEST_F(rnp_tests, test_generated_key_sig</span>
<a href="#l59.135"></a><span id="l59.135">     {</span>
<a href="#l59.136"></a><span id="l59.136">         pgp_key_t                pub = {};</span>
<a href="#l59.137"></a><span id="l59.137">         pgp_key_t                sec = {};</span>
<a href="#l59.138"></a><span id="l59.138">         rnp_keygen_subkey_desc_t desc;</span>
<a href="#l59.139"></a><span id="l59.139">         pgp_fingerprint_t        fp = {};</span>
<a href="#l59.140"></a><span id="l59.140">         pgp_sig_subpkt_t *       subpkt = NULL;</span>
<a href="#l59.141"></a><span id="l59.141">         pgp_signature_t *        psig = NULL;</span>
<a href="#l59.142"></a><span id="l59.142">         pgp_signature_t *        ssig = NULL;</span>
<a href="#l59.143"></a><span id="l59.143" class="difflineplus">+        pgp_signature_info_t     psiginfo = {};</span>
<a href="#l59.144"></a><span id="l59.144" class="difflineplus">+        pgp_signature_info_t     ssiginfo = {};</span>
<a href="#l59.145"></a><span id="l59.145"> </span>
<a href="#l59.146"></a><span id="l59.146">         memset(&amp;desc, 0, sizeof(desc));</span>
<a href="#l59.147"></a><span id="l59.147">         desc.crypto.key_alg = PGP_PKA_RSA;</span>
<a href="#l59.148"></a><span id="l59.148">         desc.crypto.rsa.modulus_bit_len = 1024;</span>
<a href="#l59.149"></a><span id="l59.149">         desc.crypto.rng = &amp;global_rng;</span>
<a href="#l59.150"></a><span id="l59.150"> </span>
<a href="#l59.151"></a><span id="l59.151">         // generate</span>
<a href="#l59.152"></a><span id="l59.152">         assert_true(pgp_generate_subkey(</span>
<a href="#l59.153"></a><span id="l59.153" class="difflineat">@@ -1080,50 +1075,54 @@ TEST_F(rnp_tests, test_generated_key_sig</span>
<a href="#l59.154"></a><span id="l59.154">         assert_int_equal(1, pgp_key_get_subsig_count(&amp;pub));</span>
<a href="#l59.155"></a><span id="l59.155">         assert_int_equal(1, pgp_key_get_subsig_count(&amp;sec));</span>
<a href="#l59.156"></a><span id="l59.156">         psig = &amp;pgp_key_get_subsig(&amp;pub, 0)-&gt;sig;</span>
<a href="#l59.157"></a><span id="l59.157">         ssig = &amp;pgp_key_get_subsig(&amp;sec, 0)-&gt;sig;</span>
<a href="#l59.158"></a><span id="l59.158">         // make sure our sig MPI is not NULL</span>
<a href="#l59.159"></a><span id="l59.159">         assert_int_not_equal(psig-&gt;material.rsa.s.len, 0);</span>
<a href="#l59.160"></a><span id="l59.160">         assert_int_not_equal(ssig-&gt;material.rsa.s.len, 0);</span>
<a href="#l59.161"></a><span id="l59.161">         // make sure we're targeting the right packet</span>
<a href="#l59.162"></a><span id="l59.162" class="difflineminus">-        assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_rawpacket(&amp;pub, 1)-&gt;tag);</span>
<a href="#l59.163"></a><span id="l59.163" class="difflineminus">-        assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_rawpacket(&amp;sec, 1)-&gt;tag);</span>
<a href="#l59.164"></a><span id="l59.164" class="difflineplus">+        assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_subsig(&amp;pub, 0)-&gt;rawpkt.tag);</span>
<a href="#l59.165"></a><span id="l59.165" class="difflineplus">+        assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_subsig(&amp;sec, 0)-&gt;rawpkt.tag);</span>
<a href="#l59.166"></a><span id="l59.166">         // validate the binding sig</span>
<a href="#l59.167"></a><span id="l59.167" class="difflineminus">-        assert_rnp_success(signature_validate_binding(</span>
<a href="#l59.168"></a><span id="l59.168" class="difflineminus">-          psig, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;pub)));</span>
<a href="#l59.169"></a><span id="l59.169" class="difflineplus">+        psiginfo.sig = psig;</span>
<a href="#l59.170"></a><span id="l59.170" class="difflineplus">+        psiginfo.signer = primary_pub;</span>
<a href="#l59.171"></a><span id="l59.171" class="difflineplus">+        assert_rnp_success(signature_check_binding(</span>
<a href="#l59.172"></a><span id="l59.172" class="difflineplus">+          &amp;psiginfo, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;pub)));</span>
<a href="#l59.173"></a><span id="l59.173">         assert_true(signature_get_keyfp(psig, &amp;fp));</span>
<a href="#l59.174"></a><span id="l59.174">         assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(primary_pub)));</span>
<a href="#l59.175"></a><span id="l59.175">         // check subpackets and their contents</span>
<a href="#l59.176"></a><span id="l59.176">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_ISSUER_FPR);</span>
<a href="#l59.177"></a><span id="l59.177">         assert_non_null(subpkt);</span>
<a href="#l59.178"></a><span id="l59.178">         assert_true(subpkt-&gt;hashed);</span>
<a href="#l59.179"></a><span id="l59.179">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_ISSUER_KEY_ID);</span>
<a href="#l59.180"></a><span id="l59.180">         assert_non_null(subpkt);</span>
<a href="#l59.181"></a><span id="l59.181">         assert_false(subpkt-&gt;hashed);</span>
<a href="#l59.182"></a><span id="l59.182">         assert_int_equal(</span>
<a href="#l59.183"></a><span id="l59.183">           0, memcmp(subpkt-&gt;fields.issuer, pgp_key_get_keyid(primary_pub), PGP_KEY_ID_SIZE));</span>
<a href="#l59.184"></a><span id="l59.184">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_CREATION_TIME);</span>
<a href="#l59.185"></a><span id="l59.185">         assert_non_null(subpkt);</span>
<a href="#l59.186"></a><span id="l59.186">         assert_true(subpkt-&gt;hashed);</span>
<a href="#l59.187"></a><span id="l59.187">         assert_true(subpkt-&gt;fields.create &lt;= time(NULL));</span>
<a href="#l59.188"></a><span id="l59.188"> </span>
<a href="#l59.189"></a><span id="l59.189" class="difflineminus">-        assert_rnp_success(signature_validate_binding(</span>
<a href="#l59.190"></a><span id="l59.190" class="difflineminus">-          ssig, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;sec)));</span>
<a href="#l59.191"></a><span id="l59.191" class="difflineplus">+        ssiginfo.sig = ssig;</span>
<a href="#l59.192"></a><span id="l59.192" class="difflineplus">+        ssiginfo.signer = primary_pub;</span>
<a href="#l59.193"></a><span id="l59.193" class="difflineplus">+        assert_rnp_success(signature_check_binding(</span>
<a href="#l59.194"></a><span id="l59.194" class="difflineplus">+          &amp;ssiginfo, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;sec)));</span>
<a href="#l59.195"></a><span id="l59.195">         assert_true(signature_get_keyfp(ssig, &amp;fp));</span>
<a href="#l59.196"></a><span id="l59.196">         assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(primary_sec)));</span>
<a href="#l59.197"></a><span id="l59.197"> </span>
<a href="#l59.198"></a><span id="l59.198">         // modify a hashed portion of the sig packets</span>
<a href="#l59.199"></a><span id="l59.199">         psig-&gt;hashed_data[10] ^= 0xff;</span>
<a href="#l59.200"></a><span id="l59.200">         ssig-&gt;hashed_data[10] ^= 0xff;</span>
<a href="#l59.201"></a><span id="l59.201">         // ensure validation fails</span>
<a href="#l59.202"></a><span id="l59.202" class="difflineminus">-        assert_rnp_failure(signature_validate_binding(</span>
<a href="#l59.203"></a><span id="l59.203" class="difflineminus">-          psig, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;pub)));</span>
<a href="#l59.204"></a><span id="l59.204" class="difflineminus">-        assert_rnp_failure(signature_validate_binding(</span>
<a href="#l59.205"></a><span id="l59.205" class="difflineminus">-          ssig, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;sec)));</span>
<a href="#l59.206"></a><span id="l59.206" class="difflineplus">+        assert_rnp_failure(signature_check_binding(</span>
<a href="#l59.207"></a><span id="l59.207" class="difflineplus">+          &amp;psiginfo, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;pub)));</span>
<a href="#l59.208"></a><span id="l59.208" class="difflineplus">+        assert_rnp_failure(signature_check_binding(</span>
<a href="#l59.209"></a><span id="l59.209" class="difflineplus">+          &amp;ssiginfo, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;sec)));</span>
<a href="#l59.210"></a><span id="l59.210">         // restore the original data</span>
<a href="#l59.211"></a><span id="l59.211">         psig-&gt;hashed_data[10] ^= 0xff;</span>
<a href="#l59.212"></a><span id="l59.212">         ssig-&gt;hashed_data[10] ^= 0xff;</span>
<a href="#l59.213"></a><span id="l59.213"> </span>
<a href="#l59.214"></a><span id="l59.214">         // add to our rings</span>
<a href="#l59.215"></a><span id="l59.215">         assert_true(rnp_key_store_add_key(pubring, &amp;pub));</span>
<a href="#l59.216"></a><span id="l59.216">         assert_true(rnp_key_store_add_key(secring, &amp;sec));</span>
<a href="#l59.217"></a><span id="l59.217">         // retrieve back from our rings</span>
<a href="#l59.218"></a><span id="l59.218" class="difflineat">@@ -1144,11 +1143,11 @@ TEST_F(rnp_tests, test_generated_key_sig</span>
<a href="#l59.219"></a><span id="l59.219">         assert_true(sub_pub-&gt;validated);</span>
<a href="#l59.220"></a><span id="l59.220">         sub_sec-&gt;valid = false;</span>
<a href="#l59.221"></a><span id="l59.221">         sub_sec-&gt;validated = false;</span>
<a href="#l59.222"></a><span id="l59.222">         pgp_key_validate(sub_sec, pubring);</span>
<a href="#l59.223"></a><span id="l59.223">         assert_true(sub_sec-&gt;valid);</span>
<a href="#l59.224"></a><span id="l59.224">         assert_true(sub_sec-&gt;validated);</span>
<a href="#l59.225"></a><span id="l59.225">     }</span>
<a href="#l59.226"></a><span id="l59.226"> </span>
<a href="#l59.227"></a><span id="l59.227" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l59.228"></a><span id="l59.228" class="difflineminus">-    rnp_key_store_free(secring);</span>
<a href="#l59.229"></a><span id="l59.229" class="difflineplus">+    delete pubring;</span>
<a href="#l59.230"></a><span id="l59.230" class="difflineplus">+    delete secring;</span>
<a href="#l59.231"></a><span id="l59.231"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l60.1"></a><span id="l60.1" class="difflineminus">--- a/third_party/rnp/src/tests/key-add-userid.cpp</span>
<a href="#l60.2"></a><span id="l60.2" class="difflineplus">+++ b/third_party/rnp/src/tests/key-add-userid.cpp</span>
<a href="#l60.3"></a><span id="l60.3" class="difflineat">@@ -41,18 +41,17 @@ TEST_F(rnp_tests, test_key_add_userid)</span>
<a href="#l60.4"></a><span id="l60.4">     static const char *keyids[] = {&quot;7bc6709b15c23a4a&quot;, // primary</span>
<a href="#l60.5"></a><span id="l60.5">                                    &quot;1ed63ee56fadc34d&quot;,</span>
<a href="#l60.6"></a><span id="l60.6">                                    &quot;1d7e8a5393c997a8&quot;,</span>
<a href="#l60.7"></a><span id="l60.7">                                    &quot;8a05b89fad5aded1&quot;,</span>
<a href="#l60.8"></a><span id="l60.8">                                    &quot;2fcadf05ffa501bb&quot;, // primary</span>
<a href="#l60.9"></a><span id="l60.9">                                    &quot;54505a936a4a970e&quot;,</span>
<a href="#l60.10"></a><span id="l60.10">                                    &quot;326ef111425d14a5&quot;};</span>
<a href="#l60.11"></a><span id="l60.11"> </span>
<a href="#l60.12"></a><span id="l60.12" class="difflineminus">-    rnp_key_store_t *ks = (rnp_key_store_t *) calloc(1, sizeof(*ks));</span>
<a href="#l60.13"></a><span id="l60.13" class="difflineminus">-    assert_non_null(ks);</span>
<a href="#l60.14"></a><span id="l60.14" class="difflineplus">+    rnp_key_store_t *ks = new rnp_key_store_t();</span>
<a href="#l60.15"></a><span id="l60.15"> </span>
<a href="#l60.16"></a><span id="l60.16">     assert_rnp_success(init_file_src(&amp;src, &quot;data/keyrings/1/secring.gpg&quot;));</span>
<a href="#l60.17"></a><span id="l60.17">     assert_rnp_success(rnp_key_store_pgp_read_from_src(ks, &amp;src));</span>
<a href="#l60.18"></a><span id="l60.18">     src_close(&amp;src);</span>
<a href="#l60.19"></a><span id="l60.19"> </span>
<a href="#l60.20"></a><span id="l60.20">     // locate our key</span>
<a href="#l60.21"></a><span id="l60.21">     assert_non_null(key = rnp_tests_get_key_by_id(ks, keyids[0], NULL));</span>
<a href="#l60.22"></a><span id="l60.22">     assert_non_null(key);</span>
<a href="#l60.23"></a><span id="l60.23" class="difflineat">@@ -107,36 +106,33 @@ TEST_F(rnp_tests, test_key_add_userid)</span>
<a href="#l60.24"></a><span id="l60.24">     assert_int_equal(pgp_key_get_userid_count(key), uidc + 2);</span>
<a href="#l60.25"></a><span id="l60.25">     assert_int_equal(pgp_key_get_subsig_count(key), subsigc + 2);</span>
<a href="#l60.26"></a><span id="l60.26"> </span>
<a href="#l60.27"></a><span id="l60.27">     // make sure key expiration and flags are now updated</span>
<a href="#l60.28"></a><span id="l60.28">     assert_int_equal(0, pgp_key_get_expiration(key));</span>
<a href="#l60.29"></a><span id="l60.29">     assert_int_equal(0xCD, pgp_key_get_flags(key));</span>
<a href="#l60.30"></a><span id="l60.30">     // check the userids array</span>
<a href="#l60.31"></a><span id="l60.31">     // added1</span>
<a href="#l60.32"></a><span id="l60.32" class="difflineminus">-    assert_int_equal(0, strcmp(pgp_key_get_userid(key, uidc)-&gt;str, &quot;added1&quot;));</span>
<a href="#l60.33"></a><span id="l60.33" class="difflineplus">+    assert_true(pgp_key_get_userid(key, uidc)-&gt;str == &quot;added1&quot;);</span>
<a href="#l60.34"></a><span id="l60.34">     assert_int_equal(uidc, pgp_key_get_subsig(key, subsigc)-&gt;uid);</span>
<a href="#l60.35"></a><span id="l60.35">     assert_int_equal(0xAB, pgp_key_get_subsig(key, subsigc)-&gt;key_flags);</span>
<a href="#l60.36"></a><span id="l60.36">     // added2</span>
<a href="#l60.37"></a><span id="l60.37" class="difflineminus">-    assert_int_equal(0, strcmp(pgp_key_get_userid(key, uidc + 1)-&gt;str, &quot;added2&quot;));</span>
<a href="#l60.38"></a><span id="l60.38" class="difflineplus">+    assert_true(pgp_key_get_userid(key, uidc + 1)-&gt;str == &quot;added2&quot;);</span>
<a href="#l60.39"></a><span id="l60.39">     assert_int_equal(uidc + 1, pgp_key_get_subsig(key, subsigc + 1)-&gt;uid);</span>
<a href="#l60.40"></a><span id="l60.40">     assert_int_equal(0xCD, pgp_key_get_subsig(key, subsigc + 1)-&gt;key_flags);</span>
<a href="#l60.41"></a><span id="l60.41"> </span>
<a href="#l60.42"></a><span id="l60.42">     // save the raw packets for the key (to reload later)</span>
<a href="#l60.43"></a><span id="l60.43">     assert_rnp_success(init_mem_dest(&amp;dst, NULL, 0));</span>
<a href="#l60.44"></a><span id="l60.44" class="difflineminus">-    for (size_t i = 0; i &lt; pgp_key_get_rawpacket_count(key); i++) {</span>
<a href="#l60.45"></a><span id="l60.45" class="difflineminus">-        pgp_rawpacket_t *pkt = pgp_key_get_rawpacket(key, i);</span>
<a href="#l60.46"></a><span id="l60.46" class="difflineminus">-        dst_write(&amp;dst, pkt-&gt;raw, pkt-&gt;length);</span>
<a href="#l60.47"></a><span id="l60.47" class="difflineminus">-    }</span>
<a href="#l60.48"></a><span id="l60.48" class="difflineplus">+    pgp_key_write_packets(key, &amp;dst);</span>
<a href="#l60.49"></a><span id="l60.49">     // cleanup</span>
<a href="#l60.50"></a><span id="l60.50" class="difflineminus">-    rnp_key_store_free(ks);</span>
<a href="#l60.51"></a><span id="l60.51" class="difflineplus">+    delete ks;</span>
<a href="#l60.52"></a><span id="l60.52">     key = NULL;</span>
<a href="#l60.53"></a><span id="l60.53"> </span>
<a href="#l60.54"></a><span id="l60.54">     // start over</span>
<a href="#l60.55"></a><span id="l60.55" class="difflineminus">-    ks = (rnp_key_store_t *) calloc(1, sizeof(*ks));</span>
<a href="#l60.56"></a><span id="l60.56" class="difflineplus">+    ks = new rnp_key_store_t();</span>
<a href="#l60.57"></a><span id="l60.57">     assert_non_null(ks);</span>
<a href="#l60.58"></a><span id="l60.58">     // read from the saved packets</span>
<a href="#l60.59"></a><span id="l60.59">     assert_rnp_success(init_mem_src(&amp;src, mem_dest_get_memory(&amp;dst), dst.writeb, false));</span>
<a href="#l60.60"></a><span id="l60.60">     assert_rnp_success(rnp_key_store_pgp_read_from_src(ks, &amp;src));</span>
<a href="#l60.61"></a><span id="l60.61">     src_close(&amp;src);</span>
<a href="#l60.62"></a><span id="l60.62">     dst_close(&amp;dst, true);</span>
<a href="#l60.63"></a><span id="l60.63">     assert_non_null(key = rnp_tests_get_key_by_id(ks, keyids[0], NULL));</span>
<a href="#l60.64"></a><span id="l60.64"> </span>
<a href="#l60.65"></a><span id="l60.65" class="difflineat">@@ -145,19 +141,19 @@ TEST_F(rnp_tests, test_key_add_userid)</span>
<a href="#l60.66"></a><span id="l60.66">     assert_int_equal(pgp_key_get_subsig_count(key), subsigc + 2);</span>
<a href="#l60.67"></a><span id="l60.67"> </span>
<a href="#l60.68"></a><span id="l60.68">     // make sure correct key expiration and flags are set</span>
<a href="#l60.69"></a><span id="l60.69">     assert_int_equal(0, pgp_key_get_expiration(key));</span>
<a href="#l60.70"></a><span id="l60.70">     assert_int_equal(0xCD, pgp_key_get_flags(key));</span>
<a href="#l60.71"></a><span id="l60.71"> </span>
<a href="#l60.72"></a><span id="l60.72">     // check the userids array</span>
<a href="#l60.73"></a><span id="l60.73">     // added1</span>
<a href="#l60.74"></a><span id="l60.74" class="difflineminus">-    assert_int_equal(0, strcmp(pgp_key_get_userid(key, uidc)-&gt;str, &quot;added1&quot;));</span>
<a href="#l60.75"></a><span id="l60.75" class="difflineplus">+    assert_true(pgp_key_get_userid(key, uidc)-&gt;str == &quot;added1&quot;);</span>
<a href="#l60.76"></a><span id="l60.76">     assert_int_equal(uidc, pgp_key_get_subsig(key, subsigc)-&gt;uid);</span>
<a href="#l60.77"></a><span id="l60.77">     assert_int_equal(0xAB, pgp_key_get_subsig(key, subsigc)-&gt;key_flags);</span>
<a href="#l60.78"></a><span id="l60.78">     // added2</span>
<a href="#l60.79"></a><span id="l60.79" class="difflineminus">-    assert_int_equal(0, strcmp(pgp_key_get_userid(key, uidc + 1)-&gt;str, &quot;added2&quot;));</span>
<a href="#l60.80"></a><span id="l60.80" class="difflineplus">+    assert_true(pgp_key_get_userid(key, uidc + 1)-&gt;str == &quot;added2&quot;);</span>
<a href="#l60.81"></a><span id="l60.81">     assert_int_equal(uidc + 1, pgp_key_get_subsig(key, subsigc + 1)-&gt;uid);</span>
<a href="#l60.82"></a><span id="l60.82">     assert_int_equal(0xCD, pgp_key_get_subsig(key, subsigc + 1)-&gt;key_flags);</span>
<a href="#l60.83"></a><span id="l60.83"> </span>
<a href="#l60.84"></a><span id="l60.84">     // cleanup</span>
<a href="#l60.85"></a><span id="l60.85" class="difflineminus">-    rnp_key_store_free(ks);</span>
<a href="#l60.86"></a><span id="l60.86" class="difflineplus">+    delete ks;</span>
<a href="#l60.87"></a><span id="l60.87"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l61.1"></a><span id="l61.1" class="difflineminus">--- a/third_party/rnp/src/tests/key-grip.cpp</span>
<a href="#l61.2"></a><span id="l61.2" class="difflineplus">+++ b/third_party/rnp/src/tests/key-grip.cpp</span>
<a href="#l61.3"></a><span id="l61.3" class="difflineat">@@ -29,135 +29,133 @@</span>
<a href="#l61.4"></a><span id="l61.4"> #include &quot;../librepgp/stream-sig.h&quot;</span>
<a href="#l61.5"></a><span id="l61.5"> #include &quot;pgp-key.h&quot;</span>
<a href="#l61.6"></a><span id="l61.6"> </span>
<a href="#l61.7"></a><span id="l61.7"> #include &quot;rnp_tests.h&quot;</span>
<a href="#l61.8"></a><span id="l61.8"> #include &quot;support.h&quot;</span>
<a href="#l61.9"></a><span id="l61.9"> </span>
<a href="#l61.10"></a><span id="l61.10"> TEST_F(rnp_tests, key_grip)</span>
<a href="#l61.11"></a><span id="l61.11"> {</span>
<a href="#l61.12"></a><span id="l61.12" class="difflineminus">-    uint8_t          grip[PGP_KEY_GRIP_SIZE];</span>
<a href="#l61.13"></a><span id="l61.13" class="difflineplus">+    pgp_key_grip_t   grip;</span>
<a href="#l61.14"></a><span id="l61.14">     const pgp_key_t *key;</span>
<a href="#l61.15"></a><span id="l61.15">     rnp_key_store_t *pub_store = NULL;</span>
<a href="#l61.16"></a><span id="l61.16">     rnp_key_store_t *sec_store = NULL;</span>
<a href="#l61.17"></a><span id="l61.17"> </span>
<a href="#l61.18"></a><span id="l61.18">     pub_store =</span>
<a href="#l61.19"></a><span id="l61.19" class="difflineminus">-      rnp_key_store_new(PGP_KEY_STORE_KBX, &quot;data/test_stream_key_load/g10/pubring.kbx&quot;);</span>
<a href="#l61.20"></a><span id="l61.20" class="difflineminus">-    assert_non_null(pub_store);</span>
<a href="#l61.21"></a><span id="l61.21" class="difflineplus">+      new rnp_key_store_t(PGP_KEY_STORE_KBX, &quot;data/test_stream_key_load/g10/pubring.kbx&quot;);</span>
<a href="#l61.22"></a><span id="l61.22">     assert_true(rnp_key_store_load_from_path(pub_store, NULL));</span>
<a href="#l61.23"></a><span id="l61.23"> </span>
<a href="#l61.24"></a><span id="l61.24" class="difflineminus">-    sec_store =</span>
<a href="#l61.25"></a><span id="l61.25" class="difflineminus">-      rnp_key_store_new(PGP_KEY_STORE_G10, &quot;data/test_stream_key_load/g10/private-keys-v1.d&quot;);</span>
<a href="#l61.26"></a><span id="l61.26" class="difflineminus">-    assert_non_null(sec_store);</span>
<a href="#l61.27"></a><span id="l61.27" class="difflineplus">+    sec_store = new rnp_key_store_t(PGP_KEY_STORE_G10,</span>
<a href="#l61.28"></a><span id="l61.28" class="difflineplus">+                                    &quot;data/test_stream_key_load/g10/private-keys-v1.d&quot;);</span>
<a href="#l61.29"></a><span id="l61.29">     pgp_key_provider_t key_provider = {.callback = rnp_key_provider_store,</span>
<a href="#l61.30"></a><span id="l61.30">                                        .userdata = pub_store};</span>
<a href="#l61.31"></a><span id="l61.31">     assert_true(rnp_key_store_load_from_path(sec_store, &amp;key_provider));</span>
<a href="#l61.32"></a><span id="l61.32"> </span>
<a href="#l61.33"></a><span id="l61.33">     // dsa-eg public/secret key</span>
<a href="#l61.34"></a><span id="l61.34">     assert_true(</span>
<a href="#l61.35"></a><span id="l61.35" class="difflineminus">-      rnp_hex_decode(&quot;552286BEB2999F0A9E26A50385B90D9724001187&quot;, grip, sizeof(grip)));</span>
<a href="#l61.36"></a><span id="l61.36" class="difflineplus">+      rnp_hex_decode(&quot;552286BEB2999F0A9E26A50385B90D9724001187&quot;, grip.data(), grip.size()));</span>
<a href="#l61.37"></a><span id="l61.37">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.38"></a><span id="l61.38">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.39"></a><span id="l61.39">     assert_true(</span>
<a href="#l61.40"></a><span id="l61.40" class="difflineminus">-      rnp_hex_decode(&quot;A5E4CD2CBBE44A16E4D6EC05C2E3C3A599DC763C&quot;, grip, sizeof(grip)));</span>
<a href="#l61.41"></a><span id="l61.41" class="difflineplus">+      rnp_hex_decode(&quot;A5E4CD2CBBE44A16E4D6EC05C2E3C3A599DC763C&quot;, grip.data(), grip.size()));</span>
<a href="#l61.42"></a><span id="l61.42">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.43"></a><span id="l61.43">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.44"></a><span id="l61.44"> </span>
<a href="#l61.45"></a><span id="l61.45">     // rsa/rsa public/secret key</span>
<a href="#l61.46"></a><span id="l61.46">     assert_true(</span>
<a href="#l61.47"></a><span id="l61.47" class="difflineminus">-      rnp_hex_decode(&quot;D148210FAF36468055B83D0F5A6DEB83FBC8E864&quot;, grip, sizeof(grip)));</span>
<a href="#l61.48"></a><span id="l61.48" class="difflineplus">+      rnp_hex_decode(&quot;D148210FAF36468055B83D0F5A6DEB83FBC8E864&quot;, grip.data(), grip.size()));</span>
<a href="#l61.49"></a><span id="l61.49">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.50"></a><span id="l61.50">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.51"></a><span id="l61.51">     assert_true(</span>
<a href="#l61.52"></a><span id="l61.52" class="difflineminus">-      rnp_hex_decode(&quot;CED7034A8EB5F4CE90DF99147EC33D86FCD3296C&quot;, grip, sizeof(grip)));</span>
<a href="#l61.53"></a><span id="l61.53" class="difflineplus">+      rnp_hex_decode(&quot;CED7034A8EB5F4CE90DF99147EC33D86FCD3296C&quot;, grip.data(), grip.size()));</span>
<a href="#l61.54"></a><span id="l61.54">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.55"></a><span id="l61.55">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.56"></a><span id="l61.56"> </span>
<a href="#l61.57"></a><span id="l61.57">     // ed25519 : public/secret key</span>
<a href="#l61.58"></a><span id="l61.58">     assert_true(</span>
<a href="#l61.59"></a><span id="l61.59" class="difflineminus">-      rnp_hex_decode(&quot;940D97D75C306D737A59A98EAFF1272832CEDC0B&quot;, grip, sizeof(grip)));</span>
<a href="#l61.60"></a><span id="l61.60" class="difflineplus">+      rnp_hex_decode(&quot;940D97D75C306D737A59A98EAFF1272832CEDC0B&quot;, grip.data(), grip.size()));</span>
<a href="#l61.61"></a><span id="l61.61">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.62"></a><span id="l61.62">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.63"></a><span id="l61.63"> </span>
<a href="#l61.64"></a><span id="l61.64">     // x25519 : public/secret key/subkey</span>
<a href="#l61.65"></a><span id="l61.65">     assert_true(</span>
<a href="#l61.66"></a><span id="l61.66" class="difflineminus">-      rnp_hex_decode(&quot;A77DC8173DA6BEE126F5BD6F5A14E01200B52FCE&quot;, grip, sizeof(grip)));</span>
<a href="#l61.67"></a><span id="l61.67" class="difflineplus">+      rnp_hex_decode(&quot;A77DC8173DA6BEE126F5BD6F5A14E01200B52FCE&quot;, grip.data(), grip.size()));</span>
<a href="#l61.68"></a><span id="l61.68">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.69"></a><span id="l61.69">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.70"></a><span id="l61.70">     assert_true(</span>
<a href="#l61.71"></a><span id="l61.71" class="difflineminus">-      rnp_hex_decode(&quot;636C983EDB558527BA82780B52CB5DAE011BE46B&quot;, grip, sizeof(grip)));</span>
<a href="#l61.72"></a><span id="l61.72" class="difflineplus">+      rnp_hex_decode(&quot;636C983EDB558527BA82780B52CB5DAE011BE46B&quot;, grip.data(), grip.size()));</span>
<a href="#l61.73"></a><span id="l61.73">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.74"></a><span id="l61.74">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.75"></a><span id="l61.75"> </span>
<a href="#l61.76"></a><span id="l61.76">     // nistp256 : public/secret key/subkey</span>
<a href="#l61.77"></a><span id="l61.77">     assert_true(</span>
<a href="#l61.78"></a><span id="l61.78" class="difflineminus">-      rnp_hex_decode(&quot;FC81AECE90BCE6E54D0D637D266109783AC8DAC0&quot;, grip, sizeof(grip)));</span>
<a href="#l61.79"></a><span id="l61.79" class="difflineplus">+      rnp_hex_decode(&quot;FC81AECE90BCE6E54D0D637D266109783AC8DAC0&quot;, grip.data(), grip.size()));</span>
<a href="#l61.80"></a><span id="l61.80">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.81"></a><span id="l61.81">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.82"></a><span id="l61.82">     assert_true(</span>
<a href="#l61.83"></a><span id="l61.83" class="difflineminus">-      rnp_hex_decode(&quot;A56DC8DB8355747A809037459B4258B8A743EAB5&quot;, grip, sizeof(grip)));</span>
<a href="#l61.84"></a><span id="l61.84" class="difflineplus">+      rnp_hex_decode(&quot;A56DC8DB8355747A809037459B4258B8A743EAB5&quot;, grip.data(), grip.size()));</span>
<a href="#l61.85"></a><span id="l61.85">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.86"></a><span id="l61.86">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.87"></a><span id="l61.87"> </span>
<a href="#l61.88"></a><span id="l61.88">     // nistp384 : public/secret key/subkey</span>
<a href="#l61.89"></a><span id="l61.89">     assert_true(</span>
<a href="#l61.90"></a><span id="l61.90" class="difflineminus">-      rnp_hex_decode(&quot;A1338230AED1C9C125663518470B49056C9D1733&quot;, grip, sizeof(grip)));</span>
<a href="#l61.91"></a><span id="l61.91" class="difflineplus">+      rnp_hex_decode(&quot;A1338230AED1C9C125663518470B49056C9D1733&quot;, grip.data(), grip.size()));</span>
<a href="#l61.92"></a><span id="l61.92">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.93"></a><span id="l61.93">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.94"></a><span id="l61.94">     assert_true(</span>
<a href="#l61.95"></a><span id="l61.95" class="difflineminus">-      rnp_hex_decode(&quot;797A83FE041FFE06A7F4B1D32C6F4AE0F6D87ADF&quot;, grip, sizeof(grip)));</span>
<a href="#l61.96"></a><span id="l61.96" class="difflineplus">+      rnp_hex_decode(&quot;797A83FE041FFE06A7F4B1D32C6F4AE0F6D87ADF&quot;, grip.data(), grip.size()));</span>
<a href="#l61.97"></a><span id="l61.97">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.98"></a><span id="l61.98">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.99"></a><span id="l61.99"> </span>
<a href="#l61.100"></a><span id="l61.100">     // nistp521 : public/secret key/subkey</span>
<a href="#l61.101"></a><span id="l61.101">     assert_true(</span>
<a href="#l61.102"></a><span id="l61.102" class="difflineminus">-      rnp_hex_decode(&quot;D91B789603EC9138AA20342A2B6DC86C81B70F5D&quot;, grip, sizeof(grip)));</span>
<a href="#l61.103"></a><span id="l61.103" class="difflineplus">+      rnp_hex_decode(&quot;D91B789603EC9138AA20342A2B6DC86C81B70F5D&quot;, grip.data(), grip.size()));</span>
<a href="#l61.104"></a><span id="l61.104">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.105"></a><span id="l61.105">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.106"></a><span id="l61.106">     assert_true(</span>
<a href="#l61.107"></a><span id="l61.107" class="difflineminus">-      rnp_hex_decode(&quot;FD048B2CA1919CB241DC8A2C7FA3E742EF343DCA&quot;, grip, sizeof(grip)));</span>
<a href="#l61.108"></a><span id="l61.108" class="difflineplus">+      rnp_hex_decode(&quot;FD048B2CA1919CB241DC8A2C7FA3E742EF343DCA&quot;, grip.data(), grip.size()));</span>
<a href="#l61.109"></a><span id="l61.109">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.110"></a><span id="l61.110">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.111"></a><span id="l61.111"> </span>
<a href="#l61.112"></a><span id="l61.112">     // brainpool256 : public/secret key/subkey</span>
<a href="#l61.113"></a><span id="l61.113">     assert_true(</span>
<a href="#l61.114"></a><span id="l61.114" class="difflineminus">-      rnp_hex_decode(&quot;A01BAA22A72F09A0FF0A1D4CBCE70844DD52DDD7&quot;, grip, sizeof(grip)));</span>
<a href="#l61.115"></a><span id="l61.115" class="difflineplus">+      rnp_hex_decode(&quot;A01BAA22A72F09A0FF0A1D4CBCE70844DD52DDD7&quot;, grip.data(), grip.size()));</span>
<a href="#l61.116"></a><span id="l61.116">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.117"></a><span id="l61.117">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.118"></a><span id="l61.118">     assert_true(</span>
<a href="#l61.119"></a><span id="l61.119" class="difflineminus">-      rnp_hex_decode(&quot;C1678B7DE5F144C93B89468D5F9764ACE182ED36&quot;, grip, sizeof(grip)));</span>
<a href="#l61.120"></a><span id="l61.120" class="difflineplus">+      rnp_hex_decode(&quot;C1678B7DE5F144C93B89468D5F9764ACE182ED36&quot;, grip.data(), grip.size()));</span>
<a href="#l61.121"></a><span id="l61.121">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.122"></a><span id="l61.122">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.123"></a><span id="l61.123"> </span>
<a href="#l61.124"></a><span id="l61.124">     // brainpool384 : public/secret key/subkey</span>
<a href="#l61.125"></a><span id="l61.125">     assert_true(</span>
<a href="#l61.126"></a><span id="l61.126" class="difflineminus">-      rnp_hex_decode(&quot;2F25DB025DEBF3EA2715350209B985829B04F50A&quot;, grip, sizeof(grip)));</span>
<a href="#l61.127"></a><span id="l61.127" class="difflineplus">+      rnp_hex_decode(&quot;2F25DB025DEBF3EA2715350209B985829B04F50A&quot;, grip.data(), grip.size()));</span>
<a href="#l61.128"></a><span id="l61.128">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.129"></a><span id="l61.129">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.130"></a><span id="l61.130">     assert_true(</span>
<a href="#l61.131"></a><span id="l61.131" class="difflineminus">-      rnp_hex_decode(&quot;B6BD8B81F75AF914163D97DF8DE8F6FC64C283F8&quot;, grip, sizeof(grip)));</span>
<a href="#l61.132"></a><span id="l61.132" class="difflineplus">+      rnp_hex_decode(&quot;B6BD8B81F75AF914163D97DF8DE8F6FC64C283F8&quot;, grip.data(), grip.size()));</span>
<a href="#l61.133"></a><span id="l61.133">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.134"></a><span id="l61.134">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.135"></a><span id="l61.135"> </span>
<a href="#l61.136"></a><span id="l61.136">     // brainpool512 : public/secret key/subkey</span>
<a href="#l61.137"></a><span id="l61.137">     assert_true(</span>
<a href="#l61.138"></a><span id="l61.138" class="difflineminus">-      rnp_hex_decode(&quot;5A484F56AB4B8B6583B6365034999F6543FAE1AE&quot;, grip, sizeof(grip)));</span>
<a href="#l61.139"></a><span id="l61.139" class="difflineplus">+      rnp_hex_decode(&quot;5A484F56AB4B8B6583B6365034999F6543FAE1AE&quot;, grip.data(), grip.size()));</span>
<a href="#l61.140"></a><span id="l61.140">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.141"></a><span id="l61.141">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.142"></a><span id="l61.142">     assert_true(</span>
<a href="#l61.143"></a><span id="l61.143" class="difflineminus">-      rnp_hex_decode(&quot;9133E4A7E8FC8515518DF444C3F2F247EEBBADEC&quot;, grip, sizeof(grip)));</span>
<a href="#l61.144"></a><span id="l61.144" class="difflineplus">+      rnp_hex_decode(&quot;9133E4A7E8FC8515518DF444C3F2F247EEBBADEC&quot;, grip.data(), grip.size()));</span>
<a href="#l61.145"></a><span id="l61.145">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.146"></a><span id="l61.146">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.147"></a><span id="l61.147"> </span>
<a href="#l61.148"></a><span id="l61.148">     // secp256k1 : public/secret key/subkey</span>
<a href="#l61.149"></a><span id="l61.149">     assert_true(</span>
<a href="#l61.150"></a><span id="l61.150" class="difflineminus">-      rnp_hex_decode(&quot;498B89C485489BA16B40755C0EBA580166393074&quot;, grip, sizeof(grip)));</span>
<a href="#l61.151"></a><span id="l61.151" class="difflineplus">+      rnp_hex_decode(&quot;498B89C485489BA16B40755C0EBA580166393074&quot;, grip.data(), grip.size()));</span>
<a href="#l61.152"></a><span id="l61.152">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.153"></a><span id="l61.153">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.154"></a><span id="l61.154">     assert_true(</span>
<a href="#l61.155"></a><span id="l61.155" class="difflineminus">-      rnp_hex_decode(&quot;48FFED40D018747363BDEFFDD404D1F4870F8064&quot;, grip, sizeof(grip)));</span>
<a href="#l61.156"></a><span id="l61.156" class="difflineplus">+      rnp_hex_decode(&quot;48FFED40D018747363BDEFFDD404D1F4870F8064&quot;, grip.data(), grip.size()));</span>
<a href="#l61.157"></a><span id="l61.157">     assert_non_null(key = rnp_key_store_get_key_by_grip(pub_store, grip));</span>
<a href="#l61.158"></a><span id="l61.158">     assert_non_null(key = rnp_key_store_get_key_by_grip(sec_store, grip));</span>
<a href="#l61.159"></a><span id="l61.159"> </span>
<a href="#l61.160"></a><span id="l61.160">     // cleanup</span>
<a href="#l61.161"></a><span id="l61.161" class="difflineminus">-    rnp_key_store_free(pub_store);</span>
<a href="#l61.162"></a><span id="l61.162" class="difflineminus">-    rnp_key_store_free(sec_store);</span>
<a href="#l61.163"></a><span id="l61.163" class="difflineplus">+    delete pub_store;</span>
<a href="#l61.164"></a><span id="l61.164" class="difflineplus">+    delete sec_store;</span>
<a href="#l61.165"></a><span id="l61.165"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l62.1"></a><span id="l62.1" class="difflineminus">--- a/third_party/rnp/src/tests/key-protect.cpp</span>
<a href="#l62.2"></a><span id="l62.2" class="difflineplus">+++ b/third_party/rnp/src/tests/key-protect.cpp</span>
<a href="#l62.3"></a><span id="l62.3" class="difflineat">@@ -50,18 +50,17 @@ TEST_F(rnp_tests, test_key_protect_load_</span>
<a href="#l62.4"></a><span id="l62.4">                                    &quot;8a05b89fad5aded1&quot;,</span>
<a href="#l62.5"></a><span id="l62.5">                                    &quot;2fcadf05ffa501bb&quot;, // primary</span>
<a href="#l62.6"></a><span id="l62.6">                                    &quot;54505a936a4a970e&quot;,</span>
<a href="#l62.7"></a><span id="l62.7">                                    &quot;326ef111425d14a5&quot;};</span>
<a href="#l62.8"></a><span id="l62.8"> </span>
<a href="#l62.9"></a><span id="l62.9">     // load our keyring and do some quick checks</span>
<a href="#l62.10"></a><span id="l62.10">     {</span>
<a href="#l62.11"></a><span id="l62.11">         pgp_source_t     src = {};</span>
<a href="#l62.12"></a><span id="l62.12" class="difflineminus">-        rnp_key_store_t *ks = (rnp_key_store_t *) calloc(1, sizeof(*ks));</span>
<a href="#l62.13"></a><span id="l62.13" class="difflineminus">-        assert_non_null(ks);</span>
<a href="#l62.14"></a><span id="l62.14" class="difflineplus">+        rnp_key_store_t *ks = new rnp_key_store_t();</span>
<a href="#l62.15"></a><span id="l62.15"> </span>
<a href="#l62.16"></a><span id="l62.16">         assert_rnp_success(init_file_src(&amp;src, &quot;data/keyrings/1/secring.gpg&quot;));</span>
<a href="#l62.17"></a><span id="l62.17">         assert_rnp_success(rnp_key_store_pgp_read_from_src(ks, &amp;src));</span>
<a href="#l62.18"></a><span id="l62.18">         src_close(&amp;src);</span>
<a href="#l62.19"></a><span id="l62.19"> </span>
<a href="#l62.20"></a><span id="l62.20">         for (size_t i = 0; i &lt; ARRAY_SIZE(keyids); i++) {</span>
<a href="#l62.21"></a><span id="l62.21">             pgp_key_t * key = NULL;</span>
<a href="#l62.22"></a><span id="l62.22">             const char *keyid = keyids[i];</span>
<a href="#l62.23"></a><span id="l62.23" class="difflineat">@@ -75,17 +74,17 @@ TEST_F(rnp_tests, test_key_protect_load_</span>
<a href="#l62.24"></a><span id="l62.24"> </span>
<a href="#l62.25"></a><span id="l62.25">         pgp_key_t *tmp = NULL;</span>
<a href="#l62.26"></a><span id="l62.26">         assert_non_null(tmp = rnp_tests_get_key_by_id(ks, keyids[0], NULL));</span>
<a href="#l62.27"></a><span id="l62.27"> </span>
<a href="#l62.28"></a><span id="l62.28">         // steal this key from the store</span>
<a href="#l62.29"></a><span id="l62.29">         key = new pgp_key_t();</span>
<a href="#l62.30"></a><span id="l62.30">         assert_non_null(key);</span>
<a href="#l62.31"></a><span id="l62.31">         pgp_key_copy(key, tmp, false);</span>
<a href="#l62.32"></a><span id="l62.32" class="difflineminus">-        rnp_key_store_free(ks);</span>
<a href="#l62.33"></a><span id="l62.33" class="difflineplus">+        delete ks;</span>
<a href="#l62.34"></a><span id="l62.34">     }</span>
<a href="#l62.35"></a><span id="l62.35"> </span>
<a href="#l62.36"></a><span id="l62.36">     // confirm that this key is indeed RSA</span>
<a href="#l62.37"></a><span id="l62.37">     assert_int_equal(pgp_key_get_alg(key), PGP_PKA_RSA);</span>
<a href="#l62.38"></a><span id="l62.38"> </span>
<a href="#l62.39"></a><span id="l62.39">     // confirm key material is currently all NULL (in other words, the key is locked)</span>
<a href="#l62.40"></a><span id="l62.40">     assert_true(mpi_empty(&amp;pgp_key_get_material(key)-&gt;rsa.d));</span>
<a href="#l62.41"></a><span id="l62.41">     assert_true(mpi_empty(&amp;pgp_key_get_material(key)-&gt;rsa.p));</span>
<a href="#l62.42"></a><span id="l62.42" class="difflineat">@@ -129,21 +128,20 @@ TEST_F(rnp_tests, test_key_protect_load_</span>
<a href="#l62.43"></a><span id="l62.43">     pgp_mpi_t d = pgp_key_get_material(key)-&gt;rsa.d;</span>
<a href="#l62.44"></a><span id="l62.44">     pgp_mpi_t p = pgp_key_get_material(key)-&gt;rsa.p;</span>
<a href="#l62.45"></a><span id="l62.45">     pgp_mpi_t q = pgp_key_get_material(key)-&gt;rsa.q;</span>
<a href="#l62.46"></a><span id="l62.46">     pgp_mpi_t u = pgp_key_get_material(key)-&gt;rsa.u;</span>
<a href="#l62.47"></a><span id="l62.47"> </span>
<a href="#l62.48"></a><span id="l62.48">     // confirm that packets[0] is no longer encrypted</span>
<a href="#l62.49"></a><span id="l62.49">     {</span>
<a href="#l62.50"></a><span id="l62.50">         pgp_source_t     memsrc = {};</span>
<a href="#l62.51"></a><span id="l62.51" class="difflineminus">-        rnp_key_store_t *ks = (rnp_key_store_t *) calloc(1, sizeof(*ks));</span>
<a href="#l62.52"></a><span id="l62.52" class="difflineminus">-        assert_non_null(ks);</span>
<a href="#l62.53"></a><span id="l62.53" class="difflineminus">-        pgp_rawpacket_t *pkt = pgp_key_get_rawpacket(key, 0);</span>
<a href="#l62.54"></a><span id="l62.54" class="difflineplus">+        rnp_key_store_t *ks = new rnp_key_store_t();</span>
<a href="#l62.55"></a><span id="l62.55" class="difflineplus">+        pgp_rawpacket_t &amp;pkt = pgp_key_get_rawpacket(key);</span>
<a href="#l62.56"></a><span id="l62.56"> </span>
<a href="#l62.57"></a><span id="l62.57" class="difflineminus">-        assert_rnp_success(init_mem_src(&amp;memsrc, pkt-&gt;raw, pkt-&gt;length, false));</span>
<a href="#l62.58"></a><span id="l62.58" class="difflineplus">+        assert_rnp_success(init_mem_src(&amp;memsrc, pkt.raw.data(), pkt.raw.size(), false));</span>
<a href="#l62.59"></a><span id="l62.59">         assert_rnp_success(rnp_key_store_pgp_read_from_src(ks, &amp;memsrc));</span>
<a href="#l62.60"></a><span id="l62.60">         src_close(&amp;memsrc);</span>
<a href="#l62.61"></a><span id="l62.61"> </span>
<a href="#l62.62"></a><span id="l62.62">         // grab the first key</span>
<a href="#l62.63"></a><span id="l62.63">         pgp_key_t *reloaded_key = NULL;</span>
<a href="#l62.64"></a><span id="l62.64">         assert_non_null(reloaded_key = rnp_tests_get_key_by_id(ks, keyids[0], NULL));</span>
<a href="#l62.65"></a><span id="l62.65">         assert_non_null(reloaded_key);</span>
<a href="#l62.66"></a><span id="l62.66"> </span>
<a href="#l62.67"></a><span id="l62.67" class="difflineat">@@ -187,17 +185,17 @@ TEST_F(rnp_tests, test_key_protect_load_</span>
<a href="#l62.68"></a><span id="l62.68">                               &amp;pgp_key_get_material(reloaded_key)-&gt;rsa.d));</span>
<a href="#l62.69"></a><span id="l62.69">         assert_true(mpi_equal(&amp;pgp_key_get_material(key)-&gt;rsa.p,</span>
<a href="#l62.70"></a><span id="l62.70">                               &amp;pgp_key_get_material(reloaded_key)-&gt;rsa.p));</span>
<a href="#l62.71"></a><span id="l62.71">         assert_true(mpi_equal(&amp;pgp_key_get_material(key)-&gt;rsa.q,</span>
<a href="#l62.72"></a><span id="l62.72">                               &amp;pgp_key_get_material(reloaded_key)-&gt;rsa.q));</span>
<a href="#l62.73"></a><span id="l62.73">         assert_true(mpi_equal(&amp;pgp_key_get_material(key)-&gt;rsa.u,</span>
<a href="#l62.74"></a><span id="l62.74">                               &amp;pgp_key_get_material(reloaded_key)-&gt;rsa.u));</span>
<a href="#l62.75"></a><span id="l62.75"> </span>
<a href="#l62.76"></a><span id="l62.76" class="difflineminus">-        rnp_key_store_free(ks);</span>
<a href="#l62.77"></a><span id="l62.77" class="difflineplus">+        delete ks;</span>
<a href="#l62.78"></a><span id="l62.78">     }</span>
<a href="#l62.79"></a><span id="l62.79"> </span>
<a href="#l62.80"></a><span id="l62.80">     // lock</span>
<a href="#l62.81"></a><span id="l62.81">     assert_true(pgp_key_lock(key));</span>
<a href="#l62.82"></a><span id="l62.82"> </span>
<a href="#l62.83"></a><span id="l62.83">     // try to protect (will fail when key is locked)</span>
<a href="#l62.84"></a><span id="l62.84">     pprov = {.callback = string_copy_password_callback, .userdata = (void *) &quot;newpass&quot;};</span>
<a href="#l62.85"></a><span id="l62.85">     assert_false(rnp_key_add_protection(key,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l63.1"></a><span id="l63.1" class="difflineminus">--- a/third_party/rnp/src/tests/key-store-search.cpp</span>
<a href="#l63.2"></a><span id="l63.2" class="difflineplus">+++ b/third_party/rnp/src/tests/key-store-search.cpp</span>
<a href="#l63.3"></a><span id="l63.3" class="difflineat">@@ -31,18 +31,17 @@</span>
<a href="#l63.4"></a><span id="l63.4"> #include &quot;support.h&quot;</span>
<a href="#l63.5"></a><span id="l63.5"> </span>
<a href="#l63.6"></a><span id="l63.6"> /* This test adds some fake keys to a key store and tests some of</span>
<a href="#l63.7"></a><span id="l63.7">  * the search functions.</span>
<a href="#l63.8"></a><span id="l63.8">  */</span>
<a href="#l63.9"></a><span id="l63.9"> TEST_F(rnp_tests, test_key_store_search)</span>
<a href="#l63.10"></a><span id="l63.10"> {</span>
<a href="#l63.11"></a><span id="l63.11">     // create our store</span>
<a href="#l63.12"></a><span id="l63.12" class="difflineminus">-    rnp_key_store_t *store = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l63.13"></a><span id="l63.13" class="difflineminus">-    assert_non_null(store);</span>
<a href="#l63.14"></a><span id="l63.14" class="difflineplus">+    rnp_key_store_t *store = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l63.15"></a><span id="l63.15">     store-&gt;disable_validation = true;</span>
<a href="#l63.16"></a><span id="l63.16"> </span>
<a href="#l63.17"></a><span id="l63.17">     // some fake key data</span>
<a href="#l63.18"></a><span id="l63.18">     static const struct {</span>
<a href="#l63.19"></a><span id="l63.19">         const char *keyid;</span>
<a href="#l63.20"></a><span id="l63.20">         size_t      count;      // number of keys like this to add to the store</span>
<a href="#l63.21"></a><span id="l63.21">         const char *userids[5]; // NULL terminator required on array and strings</span>
<a href="#l63.22"></a><span id="l63.22">     } testdata[] = {{&quot;000000000000AAAA&quot;, 1, {&quot;user1-1&quot;, NULL}},</span>
<a href="#l63.23"></a><span id="l63.23" class="difflineat">@@ -55,24 +54,23 @@ TEST_F(rnp_tests, test_key_store_search)</span>
<a href="#l63.24"></a><span id="l63.24">             pgp_key_t key = {};</span>
<a href="#l63.25"></a><span id="l63.25"> </span>
<a href="#l63.26"></a><span id="l63.26">             key.pkt.tag = PGP_PKT_PUBLIC_KEY;</span>
<a href="#l63.27"></a><span id="l63.27">             key.pkt.version = PGP_V4;</span>
<a href="#l63.28"></a><span id="l63.28"> </span>
<a href="#l63.29"></a><span id="l63.29">             // set the keyid</span>
<a href="#l63.30"></a><span id="l63.30">             assert_true(rnp_hex_decode(testdata[i].keyid, key.keyid, sizeof(key.keyid)));</span>
<a href="#l63.31"></a><span id="l63.31">             // keys should have different grips otherwise rnp_key_store_add_key will fail here</span>
<a href="#l63.32"></a><span id="l63.32" class="difflineminus">-            assert_true(rnp_hex_decode(testdata[i].keyid, key.grip, sizeof(key.grip)));</span>
<a href="#l63.33"></a><span id="l63.33" class="difflineplus">+            assert_true(rnp_hex_decode(testdata[i].keyid, key.grip.data(), key.grip.size()));</span>
<a href="#l63.34"></a><span id="l63.34">             key.grip[0] = (uint8_t) n;</span>
<a href="#l63.35"></a><span id="l63.35">             // set the userids</span>
<a href="#l63.36"></a><span id="l63.36">             for (size_t uidn = 0; testdata[i].userids[uidn]; uidn++) {</span>
<a href="#l63.37"></a><span id="l63.37">                 pgp_userid_t *userid = pgp_key_add_userid(&amp;key);</span>
<a href="#l63.38"></a><span id="l63.38">                 assert_non_null(userid);</span>
<a href="#l63.39"></a><span id="l63.39" class="difflineminus">-                userid-&gt;str = strdup(testdata[i].userids[uidn]);</span>
<a href="#l63.40"></a><span id="l63.40" class="difflineminus">-                assert_non_null(userid-&gt;str);</span>
<a href="#l63.41"></a><span id="l63.41" class="difflineplus">+                userid-&gt;str = testdata[i].userids[uidn];</span>
<a href="#l63.42"></a><span id="l63.42">             }</span>
<a href="#l63.43"></a><span id="l63.43">             // add to the store</span>
<a href="#l63.44"></a><span id="l63.44">             assert_true(rnp_key_store_add_key(store, &amp;key));</span>
<a href="#l63.45"></a><span id="l63.45">         }</span>
<a href="#l63.46"></a><span id="l63.46">     }</span>
<a href="#l63.47"></a><span id="l63.47"> </span>
<a href="#l63.48"></a><span id="l63.48">     // keyid search</span>
<a href="#l63.49"></a><span id="l63.49">     for (size_t i = 0; i &lt; ARRAY_SIZE(testdata); i++) {</span>
<a href="#l63.50"></a><span id="l63.50" class="difflineat">@@ -123,17 +121,17 @@ TEST_F(rnp_tests, test_key_store_search)</span>
<a href="#l63.51"></a><span id="l63.51">             list        seen_keys = NULL;</span>
<a href="#l63.52"></a><span id="l63.52">             pgp_key_t * key = NULL;</span>
<a href="#l63.53"></a><span id="l63.53">             const char *userid = testdata[i].userids[uidn];</span>
<a href="#l63.54"></a><span id="l63.54">             key = rnp_tests_key_search(store, userid);</span>
<a href="#l63.55"></a><span id="l63.55">             while (key) {</span>
<a href="#l63.56"></a><span id="l63.56">                 // check that the userid actually matches</span>
<a href="#l63.57"></a><span id="l63.57">                 bool found = false;</span>
<a href="#l63.58"></a><span id="l63.58">                 for (unsigned j = 0; j &lt; pgp_key_get_userid_count(key); j++) {</span>
<a href="#l63.59"></a><span id="l63.59" class="difflineminus">-                    if (!strcmp(pgp_key_get_userid(key, j)-&gt;str, userid)) {</span>
<a href="#l63.60"></a><span id="l63.60" class="difflineplus">+                    if (pgp_key_get_userid(key, j)-&gt;str == userid) {</span>
<a href="#l63.61"></a><span id="l63.61">                         found = true;</span>
<a href="#l63.62"></a><span id="l63.62">                     }</span>
<a href="#l63.63"></a><span id="l63.63">                 }</span>
<a href="#l63.64"></a><span id="l63.64">                 assert_true(found);</span>
<a href="#l63.65"></a><span id="l63.65">                 // check that we have not already encountered this key pointer</span>
<a href="#l63.66"></a><span id="l63.66">                 assert_null(list_find(seen_keys, &amp;key, sizeof(key)));</span>
<a href="#l63.67"></a><span id="l63.67">                 // keep track of what key pointers we have seen</span>
<a href="#l63.68"></a><span id="l63.68">                 assert_non_null(list_append(&amp;seen_keys, &amp;key, sizeof(key)));</span>
<a href="#l63.69"></a><span id="l63.69" class="difflineat">@@ -165,36 +163,34 @@ TEST_F(rnp_tests, test_key_store_search)</span>
<a href="#l63.70"></a><span id="l63.70">         // check the count</span>
<a href="#l63.71"></a><span id="l63.71">         assert_int_equal(list_length(seen_keys), 3);</span>
<a href="#l63.72"></a><span id="l63.72">         // cleanup</span>
<a href="#l63.73"></a><span id="l63.73">         list_destroy(&amp;seen_keys);</span>
<a href="#l63.74"></a><span id="l63.74">     }</span>
<a href="#l63.75"></a><span id="l63.75"> #endif // RNP_KEY_STORE_SEARCH_REGEX</span>
<a href="#l63.76"></a><span id="l63.76"> </span>
<a href="#l63.77"></a><span id="l63.77">     // cleanup</span>
<a href="#l63.78"></a><span id="l63.78" class="difflineminus">-    rnp_key_store_free(store);</span>
<a href="#l63.79"></a><span id="l63.79" class="difflineplus">+    delete store;</span>
<a href="#l63.80"></a><span id="l63.80"> }</span>
<a href="#l63.81"></a><span id="l63.81"> </span>
<a href="#l63.82"></a><span id="l63.82"> TEST_F(rnp_tests, test_key_store_search_by_name)</span>
<a href="#l63.83"></a><span id="l63.83"> {</span>
<a href="#l63.84"></a><span id="l63.84">     const pgp_key_t *key;</span>
<a href="#l63.85"></a><span id="l63.85">     pgp_key_t *      primsec;</span>
<a href="#l63.86"></a><span id="l63.86">     pgp_key_t *      subsec;</span>
<a href="#l63.87"></a><span id="l63.87">     pgp_key_t *      primpub;</span>
<a href="#l63.88"></a><span id="l63.88">     pgp_key_t *      subpub;</span>
<a href="#l63.89"></a><span id="l63.89"> </span>
<a href="#l63.90"></a><span id="l63.90">     // load pubring</span>
<a href="#l63.91"></a><span id="l63.91">     rnp_key_store_t *pub_store =</span>
<a href="#l63.92"></a><span id="l63.92" class="difflineminus">-      rnp_key_store_new(PGP_KEY_STORE_KBX, &quot;data/keyrings/3/pubring.kbx&quot;);</span>
<a href="#l63.93"></a><span id="l63.93" class="difflineminus">-    assert_non_null(pub_store);</span>
<a href="#l63.94"></a><span id="l63.94" class="difflineplus">+      new rnp_key_store_t(PGP_KEY_STORE_KBX, &quot;data/keyrings/3/pubring.kbx&quot;);</span>
<a href="#l63.95"></a><span id="l63.95">     assert_true(rnp_key_store_load_from_path(pub_store, NULL));</span>
<a href="#l63.96"></a><span id="l63.96">     // load secring</span>
<a href="#l63.97"></a><span id="l63.97">     rnp_key_store_t *sec_store =</span>
<a href="#l63.98"></a><span id="l63.98" class="difflineminus">-      rnp_key_store_new(PGP_KEY_STORE_G10, &quot;data/keyrings/3/private-keys-v1.d&quot;);</span>
<a href="#l63.99"></a><span id="l63.99" class="difflineminus">-    assert_non_null(sec_store);</span>
<a href="#l63.100"></a><span id="l63.100" class="difflineplus">+      new rnp_key_store_t(PGP_KEY_STORE_G10, &quot;data/keyrings/3/private-keys-v1.d&quot;);</span>
<a href="#l63.101"></a><span id="l63.101">     pgp_key_provider_t key_provider = {.callback = rnp_key_provider_store,</span>
<a href="#l63.102"></a><span id="l63.102">                                        .userdata = pub_store};</span>
<a href="#l63.103"></a><span id="l63.103">     assert_true(rnp_key_store_load_from_path(sec_store, &amp;key_provider));</span>
<a href="#l63.104"></a><span id="l63.104"> </span>
<a href="#l63.105"></a><span id="l63.105">     /* Main key fingerprint and id:</span>
<a href="#l63.106"></a><span id="l63.106">        4F2E62B74E6A4CD333BC19004BE147BB22DF1E60, 4BE147BB22DF1E60</span>
<a href="#l63.107"></a><span id="l63.107">        Subkey fingerprint and id:</span>
<a href="#l63.108"></a><span id="l63.108">        10793E367EE867C32E358F2AA49BAE05C16E8BC8, A49BAE05C16E8BC8</span>
<a href="#l63.109"></a><span id="l63.109" class="difflineat">@@ -217,41 +213,41 @@ TEST_F(rnp_tests, test_key_store_search_</span>
<a href="#l63.110"></a><span id="l63.110">     subpub = rnp_tests_get_key_by_fpr(pub_store, &quot;10793E367EE867C32E358F2AA49BAE05C16E8BC8&quot;);</span>
<a href="#l63.111"></a><span id="l63.111">     assert_true(primpub != subpub);</span>
<a href="#l63.112"></a><span id="l63.112">     assert_true(subpub != subsec);</span>
<a href="#l63.113"></a><span id="l63.113">     key = rnp_tests_key_search(pub_store, &quot;test1&quot;);</span>
<a href="#l63.114"></a><span id="l63.114">     assert_true(key == primpub);</span>
<a href="#l63.115"></a><span id="l63.115"> </span>
<a href="#l63.116"></a><span id="l63.116">     /* Try other searches */</span>
<a href="#l63.117"></a><span id="l63.117">     key = rnp_tests_get_key_by_fpr(sec_store, &quot;4f2e62b74e6a4cd333bc19004be147bb22df1e60&quot;);</span>
<a href="#l63.118"></a><span id="l63.118" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.119"></a><span id="l63.119" class="difflineplus">+    assert_true(key == primsec);</span>
<a href="#l63.120"></a><span id="l63.120">     key = rnp_tests_get_key_by_fpr(sec_store, &quot;0x4f2e62b74e6a4cd333bc19004be147bb22df1e60&quot;);</span>
<a href="#l63.121"></a><span id="l63.121" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.122"></a><span id="l63.122" class="difflineplus">+    assert_true(key == primsec);</span>
<a href="#l63.123"></a><span id="l63.123">     key = rnp_tests_get_key_by_id(pub_store, &quot;4BE147BB22DF1E60&quot;, NULL);</span>
<a href="#l63.124"></a><span id="l63.124" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.125"></a><span id="l63.125" class="difflineplus">+    assert_true(key == primpub);</span>
<a href="#l63.126"></a><span id="l63.126">     key = rnp_tests_get_key_by_id(pub_store, &quot;4be147bb22df1e60&quot;, NULL);</span>
<a href="#l63.127"></a><span id="l63.127" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.128"></a><span id="l63.128" class="difflineplus">+    assert_true(key == primpub);</span>
<a href="#l63.129"></a><span id="l63.129">     key = rnp_tests_get_key_by_id(pub_store, &quot;0x4be147bb22df1e60&quot;, NULL);</span>
<a href="#l63.130"></a><span id="l63.130" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.131"></a><span id="l63.131" class="difflineplus">+    assert_true(key == primpub);</span>
<a href="#l63.132"></a><span id="l63.132">     key = rnp_tests_get_key_by_id(pub_store, &quot;22df1e60&quot;, NULL);</span>
<a href="#l63.133"></a><span id="l63.133" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.134"></a><span id="l63.134" class="difflineplus">+    assert_true(key == primpub);</span>
<a href="#l63.135"></a><span id="l63.135">     key = rnp_tests_get_key_by_id(pub_store, &quot;0x22df1e60&quot;, NULL);</span>
<a href="#l63.136"></a><span id="l63.136" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.137"></a><span id="l63.137" class="difflineplus">+    assert_true(key == primpub);</span>
<a href="#l63.138"></a><span id="l63.138">     key = rnp_tests_get_key_by_id(pub_store, &quot;4be1 47bb 22df 1e60&quot;, NULL);</span>
<a href="#l63.139"></a><span id="l63.139" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.140"></a><span id="l63.140" class="difflineplus">+    assert_true(key == primpub);</span>
<a href="#l63.141"></a><span id="l63.141">     key = rnp_tests_get_key_by_id(pub_store, &quot;4be147bb 22df1e60&quot;, NULL);</span>
<a href="#l63.142"></a><span id="l63.142" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.143"></a><span id="l63.143" class="difflineplus">+    assert_true(key == primpub);</span>
<a href="#l63.144"></a><span id="l63.144">     key = rnp_tests_get_key_by_id(pub_store, &quot;    4be147bb\t22df1e60   &quot;, NULL);</span>
<a href="#l63.145"></a><span id="l63.145" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.146"></a><span id="l63.146" class="difflineplus">+    assert_true(key == primpub);</span>
<a href="#l63.147"></a><span id="l63.147">     key = rnp_tests_get_key_by_id(pub_store, &quot;test1&quot;, NULL);</span>
<a href="#l63.148"></a><span id="l63.148" class="difflineminus">-    assert_true(key = primsec);</span>
<a href="#l63.149"></a><span id="l63.149" class="difflineplus">+    assert_null(key);</span>
<a href="#l63.150"></a><span id="l63.150">     /* Try negative searches */</span>
<a href="#l63.151"></a><span id="l63.151">     assert_null(rnp_tests_get_key_by_fpr(sec_store, &quot;4f2e62b74e6a4cd333bc19004be147bb22df1e&quot;));</span>
<a href="#l63.152"></a><span id="l63.152">     assert_null(rnp_tests_get_key_by_fpr(sec_store, &quot;2e62b74e6a4cd333bc19004be147bb22df1e60&quot;));</span>
<a href="#l63.153"></a><span id="l63.153">     assert_null(rnp_tests_get_key_by_id(sec_store, &quot;4be147bb22dfle60&quot;, NULL));</span>
<a href="#l63.154"></a><span id="l63.154">     assert_null(rnp_tests_get_key_by_id(sec_store, &quot;&quot;, NULL));</span>
<a href="#l63.155"></a><span id="l63.155">     assert_null(rnp_tests_get_key_by_id(sec_store, &quot;test11&quot;, NULL));</span>
<a href="#l63.156"></a><span id="l63.156">     assert_null(rnp_tests_get_key_by_id(sec_store, &quot;atest1&quot;, NULL));</span>
<a href="#l63.157"></a><span id="l63.157"> </span>
<a href="#l63.158"></a><span id="l63.158">     // cleanup</span>
<a href="#l63.159"></a><span id="l63.159" class="difflineminus">-    rnp_key_store_free(pub_store);</span>
<a href="#l63.160"></a><span id="l63.160" class="difflineminus">-    rnp_key_store_free(sec_store);</span>
<a href="#l63.161"></a><span id="l63.161" class="difflineplus">+    delete pub_store;</span>
<a href="#l63.162"></a><span id="l63.162" class="difflineplus">+    delete sec_store;</span>
<a href="#l63.163"></a><span id="l63.163"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l64.1"></a><span id="l64.1" class="difflineminus">--- a/third_party/rnp/src/tests/key-validate.cpp</span>
<a href="#l64.2"></a><span id="l64.2" class="difflineplus">+++ b/third_party/rnp/src/tests/key-validate.cpp</span>
<a href="#l64.3"></a><span id="l64.3" class="difflineat">@@ -31,20 +31,19 @@</span>
<a href="#l64.4"></a><span id="l64.4"> #include &quot;support.h&quot;</span>
<a href="#l64.5"></a><span id="l64.5"> #include &quot;../librepgp/stream-packet.h&quot;</span>
<a href="#l64.6"></a><span id="l64.6"> </span>
<a href="#l64.7"></a><span id="l64.7"> static bool</span>
<a href="#l64.8"></a><span id="l64.8"> all_keys_valid(const rnp_key_store_t *keyring)</span>
<a href="#l64.9"></a><span id="l64.9"> {</span>
<a href="#l64.10"></a><span id="l64.10">     char keyid[PGP_KEY_ID_SIZE * 2 + 3] = {0};</span>
<a href="#l64.11"></a><span id="l64.11"> </span>
<a href="#l64.12"></a><span id="l64.12" class="difflineminus">-    for (size_t i = 0; i &lt; rnp_key_store_get_key_count(keyring); i++) {</span>
<a href="#l64.13"></a><span id="l64.13" class="difflineminus">-        pgp_key_t *key = rnp_key_store_get_key(keyring, i);</span>
<a href="#l64.14"></a><span id="l64.14" class="difflineminus">-        if (!key-&gt;valid) {</span>
<a href="#l64.15"></a><span id="l64.15" class="difflineminus">-            assert_true(rnp_hex_encode(pgp_key_get_keyid(key),</span>
<a href="#l64.16"></a><span id="l64.16" class="difflineplus">+    for (auto &amp;key : keyring-&gt;keys) {</span>
<a href="#l64.17"></a><span id="l64.17" class="difflineplus">+        if (!key.valid) {</span>
<a href="#l64.18"></a><span id="l64.18" class="difflineplus">+            assert_true(rnp_hex_encode(pgp_key_get_keyid(&amp;key),</span>
<a href="#l64.19"></a><span id="l64.19">                                        PGP_KEY_ID_SIZE,</span>
<a href="#l64.20"></a><span id="l64.20">                                        keyid,</span>
<a href="#l64.21"></a><span id="l64.21">                                        sizeof(keyid),</span>
<a href="#l64.22"></a><span id="l64.22">                                        RNP_HEX_LOWERCASE));</span>
<a href="#l64.23"></a><span id="l64.23">             RNP_LOG(&quot;key %s is not valid&quot;, keyid);</span>
<a href="#l64.24"></a><span id="l64.24">             return false;</span>
<a href="#l64.25"></a><span id="l64.25">         }</span>
<a href="#l64.26"></a><span id="l64.26">     }</span>
<a href="#l64.27"></a><span id="l64.27" class="difflineat">@@ -52,84 +51,74 @@ all_keys_valid(const rnp_key_store_t *ke</span>
<a href="#l64.28"></a><span id="l64.28"> }</span>
<a href="#l64.29"></a><span id="l64.29"> </span>
<a href="#l64.30"></a><span id="l64.30"> TEST_F(rnp_tests, test_key_validate)</span>
<a href="#l64.31"></a><span id="l64.31"> {</span>
<a href="#l64.32"></a><span id="l64.32">     rnp_key_store_t *pubring;</span>
<a href="#l64.33"></a><span id="l64.33">     rnp_key_store_t *secring;</span>
<a href="#l64.34"></a><span id="l64.34">     pgp_key_t *      key = NULL;</span>
<a href="#l64.35"></a><span id="l64.35"> </span>
<a href="#l64.36"></a><span id="l64.36" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l64.37"></a><span id="l64.37" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.38"></a><span id="l64.38" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l64.39"></a><span id="l64.39">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.40"></a><span id="l64.40">     /* this keyring has one expired subkey */</span>
<a href="#l64.41"></a><span id="l64.41">     assert_non_null(key = rnp_tests_get_key_by_id(pubring, &quot;1d7e8a5393c997a8&quot;, NULL));</span>
<a href="#l64.42"></a><span id="l64.42">     assert_false(key-&gt;valid);</span>
<a href="#l64.43"></a><span id="l64.43">     key-&gt;valid = true;</span>
<a href="#l64.44"></a><span id="l64.44">     assert_true(all_keys_valid(pubring));</span>
<a href="#l64.45"></a><span id="l64.45" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.46"></a><span id="l64.46" class="difflineplus">+    delete pubring;</span>
<a href="#l64.47"></a><span id="l64.47"> </span>
<a href="#l64.48"></a><span id="l64.48">     /* secret key doesn't have expired binding signature so considered as valid */</span>
<a href="#l64.49"></a><span id="l64.49" class="difflineminus">-    secring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/secring.gpg&quot;);</span>
<a href="#l64.50"></a><span id="l64.50" class="difflineminus">-    assert_non_null(secring);</span>
<a href="#l64.51"></a><span id="l64.51" class="difflineplus">+    secring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/secring.gpg&quot;);</span>
<a href="#l64.52"></a><span id="l64.52">     assert_true(rnp_key_store_load_from_path(secring, NULL));</span>
<a href="#l64.53"></a><span id="l64.53">     assert_non_null(key = rnp_tests_get_key_by_id(secring, &quot;1d7e8a5393c997a8&quot;, NULL));</span>
<a href="#l64.54"></a><span id="l64.54">     assert_true(key-&gt;valid);</span>
<a href="#l64.55"></a><span id="l64.55">     assert_true(all_keys_valid(secring));</span>
<a href="#l64.56"></a><span id="l64.56" class="difflineminus">-    rnp_key_store_free(secring);</span>
<a href="#l64.57"></a><span id="l64.57" class="difflineplus">+    delete secring;</span>
<a href="#l64.58"></a><span id="l64.58"> </span>
<a href="#l64.59"></a><span id="l64.59" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/2/pubring.gpg&quot;);</span>
<a href="#l64.60"></a><span id="l64.60" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.61"></a><span id="l64.61" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/2/pubring.gpg&quot;);</span>
<a href="#l64.62"></a><span id="l64.62">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.63"></a><span id="l64.63">     assert_true(all_keys_valid(pubring));</span>
<a href="#l64.64"></a><span id="l64.64" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.65"></a><span id="l64.65" class="difflineplus">+    delete pubring;</span>
<a href="#l64.66"></a><span id="l64.66"> </span>
<a href="#l64.67"></a><span id="l64.67" class="difflineminus">-    secring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/2/secring.gpg&quot;);</span>
<a href="#l64.68"></a><span id="l64.68" class="difflineminus">-    assert_non_null(secring);</span>
<a href="#l64.69"></a><span id="l64.69" class="difflineplus">+    secring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/2/secring.gpg&quot;);</span>
<a href="#l64.70"></a><span id="l64.70">     assert_true(rnp_key_store_load_from_path(secring, NULL));</span>
<a href="#l64.71"></a><span id="l64.71">     assert_true(all_keys_valid(secring));</span>
<a href="#l64.72"></a><span id="l64.72" class="difflineminus">-    rnp_key_store_free(secring);</span>
<a href="#l64.73"></a><span id="l64.73" class="difflineplus">+    delete secring;</span>
<a href="#l64.74"></a><span id="l64.74"> </span>
<a href="#l64.75"></a><span id="l64.75" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_KBX, &quot;data/keyrings/3/pubring.kbx&quot;);</span>
<a href="#l64.76"></a><span id="l64.76" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.77"></a><span id="l64.77" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_KBX, &quot;data/keyrings/3/pubring.kbx&quot;);</span>
<a href="#l64.78"></a><span id="l64.78">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.79"></a><span id="l64.79">     assert_true(all_keys_valid(pubring));</span>
<a href="#l64.80"></a><span id="l64.80"> </span>
<a href="#l64.81"></a><span id="l64.81" class="difflineminus">-    secring = rnp_key_store_new(PGP_KEY_STORE_G10, &quot;data/keyrings/3/private-keys-v1.d&quot;);</span>
<a href="#l64.82"></a><span id="l64.82" class="difflineminus">-    assert_non_null(secring);</span>
<a href="#l64.83"></a><span id="l64.83" class="difflineplus">+    secring = new rnp_key_store_t(PGP_KEY_STORE_G10, &quot;data/keyrings/3/private-keys-v1.d&quot;);</span>
<a href="#l64.84"></a><span id="l64.84">     pgp_key_provider_t key_provider = {.callback = rnp_key_provider_store,</span>
<a href="#l64.85"></a><span id="l64.85">                                        .userdata = pubring};</span>
<a href="#l64.86"></a><span id="l64.86">     assert_true(rnp_key_store_load_from_path(secring, &amp;key_provider));</span>
<a href="#l64.87"></a><span id="l64.87">     assert_true(all_keys_valid(secring));</span>
<a href="#l64.88"></a><span id="l64.88" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.89"></a><span id="l64.89" class="difflineminus">-    rnp_key_store_free(secring);</span>
<a href="#l64.90"></a><span id="l64.90" class="difflineplus">+    delete pubring;</span>
<a href="#l64.91"></a><span id="l64.91" class="difflineplus">+    delete secring;</span>
<a href="#l64.92"></a><span id="l64.92"> </span>
<a href="#l64.93"></a><span id="l64.93" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/4/pubring.pgp&quot;);</span>
<a href="#l64.94"></a><span id="l64.94" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.95"></a><span id="l64.95" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/4/pubring.pgp&quot;);</span>
<a href="#l64.96"></a><span id="l64.96">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.97"></a><span id="l64.97">     assert_true(all_keys_valid(pubring));</span>
<a href="#l64.98"></a><span id="l64.98" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.99"></a><span id="l64.99" class="difflineplus">+    delete pubring;</span>
<a href="#l64.100"></a><span id="l64.100"> </span>
<a href="#l64.101"></a><span id="l64.101" class="difflineminus">-    secring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/4/secring.pgp&quot;);</span>
<a href="#l64.102"></a><span id="l64.102" class="difflineminus">-    assert_non_null(secring);</span>
<a href="#l64.103"></a><span id="l64.103" class="difflineplus">+    secring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/4/secring.pgp&quot;);</span>
<a href="#l64.104"></a><span id="l64.104">     assert_true(rnp_key_store_load_from_path(secring, NULL));</span>
<a href="#l64.105"></a><span id="l64.105">     assert_true(all_keys_valid(secring));</span>
<a href="#l64.106"></a><span id="l64.106" class="difflineminus">-    rnp_key_store_free(secring);</span>
<a href="#l64.107"></a><span id="l64.107" class="difflineplus">+    delete secring;</span>
<a href="#l64.108"></a><span id="l64.108"> </span>
<a href="#l64.109"></a><span id="l64.109" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/5/pubring.gpg&quot;);</span>
<a href="#l64.110"></a><span id="l64.110" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.111"></a><span id="l64.111" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/5/pubring.gpg&quot;);</span>
<a href="#l64.112"></a><span id="l64.112">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.113"></a><span id="l64.113">     assert_true(all_keys_valid(pubring));</span>
<a href="#l64.114"></a><span id="l64.114" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.115"></a><span id="l64.115" class="difflineplus">+    delete pubring;</span>
<a href="#l64.116"></a><span id="l64.116"> </span>
<a href="#l64.117"></a><span id="l64.117" class="difflineminus">-    secring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/5/secring.gpg&quot;);</span>
<a href="#l64.118"></a><span id="l64.118" class="difflineminus">-    assert_non_null(secring);</span>
<a href="#l64.119"></a><span id="l64.119" class="difflineplus">+    secring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/5/secring.gpg&quot;);</span>
<a href="#l64.120"></a><span id="l64.120">     assert_true(rnp_key_store_load_from_path(secring, NULL));</span>
<a href="#l64.121"></a><span id="l64.121">     assert_true(all_keys_valid(secring));</span>
<a href="#l64.122"></a><span id="l64.122" class="difflineminus">-    rnp_key_store_free(secring);</span>
<a href="#l64.123"></a><span id="l64.123" class="difflineplus">+    delete secring;</span>
<a href="#l64.124"></a><span id="l64.124"> }</span>
<a href="#l64.125"></a><span id="l64.125"> </span>
<a href="#l64.126"></a><span id="l64.126"> #define DATA_PATH &quot;data/test_forged_keys/&quot;</span>
<a href="#l64.127"></a><span id="l64.127"> </span>
<a href="#l64.128"></a><span id="l64.128"> static void</span>
<a href="#l64.129"></a><span id="l64.129"> key_store_add(rnp_key_store_t *keyring, const char *keypath)</span>
<a href="#l64.130"></a><span id="l64.130"> {</span>
<a href="#l64.131"></a><span id="l64.131">     pgp_source_t           keysrc = {};</span>
<a href="#l64.132"></a><span id="l64.132" class="difflineat">@@ -138,29 +127,28 @@ key_store_add(rnp_key_store_t *keyring, </span>
<a href="#l64.133"></a><span id="l64.133">     assert_rnp_success(init_file_src(&amp;keysrc, keypath));</span>
<a href="#l64.134"></a><span id="l64.134">     assert_rnp_success(process_pgp_key(&amp;keysrc, &amp;tkey));</span>
<a href="#l64.135"></a><span id="l64.135">     assert_true(rnp_key_store_add_transferable_key(keyring, &amp;tkey));</span>
<a href="#l64.136"></a><span id="l64.136">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l64.137"></a><span id="l64.137">     src_close(&amp;keysrc);</span>
<a href="#l64.138"></a><span id="l64.138"> }</span>
<a href="#l64.139"></a><span id="l64.139"> </span>
<a href="#l64.140"></a><span id="l64.140"> static bool</span>
<a href="#l64.141"></a><span id="l64.141" class="difflineminus">-key_check(const rnp_key_store_t *keyring, const std::string &amp;keyid, bool valid)</span>
<a href="#l64.142"></a><span id="l64.142" class="difflineplus">+key_check(rnp_key_store_t *keyring, const std::string &amp;keyid, bool valid)</span>
<a href="#l64.143"></a><span id="l64.143"> {</span>
<a href="#l64.144"></a><span id="l64.144">     pgp_key_t *key = rnp_tests_get_key_by_id(keyring, keyid, NULL);</span>
<a href="#l64.145"></a><span id="l64.145">     return key &amp;&amp; (key-&gt;validated) &amp;&amp; (key-&gt;valid == valid);</span>
<a href="#l64.146"></a><span id="l64.146"> }</span>
<a href="#l64.147"></a><span id="l64.147"> </span>
<a href="#l64.148"></a><span id="l64.148"> TEST_F(rnp_tests, test_forged_key_validate)</span>
<a href="#l64.149"></a><span id="l64.149"> {</span>
<a href="#l64.150"></a><span id="l64.150">     rnp_key_store_t *pubring;</span>
<a href="#l64.151"></a><span id="l64.151">     pgp_key_t *      key = NULL;</span>
<a href="#l64.152"></a><span id="l64.152"> </span>
<a href="#l64.153"></a><span id="l64.153" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l64.154"></a><span id="l64.154" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.155"></a><span id="l64.155" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l64.156"></a><span id="l64.156"> </span>
<a href="#l64.157"></a><span id="l64.157">     /* load valid dsa-eg key */</span>
<a href="#l64.158"></a><span id="l64.158">     key_store_add(pubring, DATA_PATH &quot;dsa-eg-pub.pgp&quot;);</span>
<a href="#l64.159"></a><span id="l64.159">     assert_true(key_check(pubring, &quot;C8A10A7D78273E10&quot;, true));</span>
<a href="#l64.160"></a><span id="l64.160">     rnp_key_store_clear(pubring);</span>
<a href="#l64.161"></a><span id="l64.161"> </span>
<a href="#l64.162"></a><span id="l64.162">     /* load dsa-eg key with forged self-signature and binding. Subkey will not be valid as</span>
<a href="#l64.163"></a><span id="l64.163">      * well. */</span>
<a href="#l64.164"></a><span id="l64.164" class="difflineat">@@ -303,154 +291,146 @@ TEST_F(rnp_tests, test_forged_key_valida</span>
<a href="#l64.165"></a><span id="l64.165">     rnp_key_store_clear(pubring);</span>
<a href="#l64.166"></a><span id="l64.166"> </span>
<a href="#l64.167"></a><span id="l64.167">     /* load ecdsa/ecdh keypair with expired key */</span>
<a href="#l64.168"></a><span id="l64.168">     key_store_add(pubring, DATA_PATH &quot;ecc-p256-pub-expired-key.pgp&quot;);</span>
<a href="#l64.169"></a><span id="l64.169">     assert_true(key_check(pubring, &quot;23674F21B2441527&quot;, false));</span>
<a href="#l64.170"></a><span id="l64.170">     assert_true(key_check(pubring, &quot;37E285E9E9851491&quot;, false));</span>
<a href="#l64.171"></a><span id="l64.171">     rnp_key_store_clear(pubring);</span>
<a href="#l64.172"></a><span id="l64.172"> </span>
<a href="#l64.173"></a><span id="l64.173" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.174"></a><span id="l64.174" class="difflineplus">+    delete pubring;</span>
<a href="#l64.175"></a><span id="l64.175"> }</span>
<a href="#l64.176"></a><span id="l64.176"> </span>
<a href="#l64.177"></a><span id="l64.177"> #define KEYSIG_PATH &quot;data/test_key_validity/&quot;</span>
<a href="#l64.178"></a><span id="l64.178"> </span>
<a href="#l64.179"></a><span id="l64.179"> TEST_F(rnp_tests, test_key_validity)</span>
<a href="#l64.180"></a><span id="l64.180"> {</span>
<a href="#l64.181"></a><span id="l64.181">     rnp_key_store_t *pubring;</span>
<a href="#l64.182"></a><span id="l64.182">     pgp_key_t *      key = NULL;</span>
<a href="#l64.183"></a><span id="l64.183"> </span>
<a href="#l64.184"></a><span id="l64.184">     /* Case1:</span>
<a href="#l64.185"></a><span id="l64.185">      * Keys: Alice [pub]</span>
<a href="#l64.186"></a><span id="l64.186">      * Alice is signed by Basil, but without the Basil's key.</span>
<a href="#l64.187"></a><span id="l64.187">      * Result: Alice [valid]</span>
<a href="#l64.188"></a><span id="l64.188">      */</span>
<a href="#l64.189"></a><span id="l64.189" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case1/pubring.gpg&quot;);</span>
<a href="#l64.190"></a><span id="l64.190" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.191"></a><span id="l64.191" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case1/pubring.gpg&quot;);</span>
<a href="#l64.192"></a><span id="l64.192">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.193"></a><span id="l64.193">     assert_non_null(key = rnp_tests_key_search(pubring, &quot;Alice &lt;alice@rnp&gt;&quot;));</span>
<a href="#l64.194"></a><span id="l64.194">     assert_true(key-&gt;valid);</span>
<a href="#l64.195"></a><span id="l64.195" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.196"></a><span id="l64.196" class="difflineplus">+    delete pubring;</span>
<a href="#l64.197"></a><span id="l64.197"> </span>
<a href="#l64.198"></a><span id="l64.198">     /* Case2:</span>
<a href="#l64.199"></a><span id="l64.199">      * Keys: Alice [pub], Basil [pub]</span>
<a href="#l64.200"></a><span id="l64.200">      * Alice is signed by Basil, Basil is signed by Alice, but Alice's self-signature is</span>
<a href="#l64.201"></a><span id="l64.201">      * corrupted.</span>
<a href="#l64.202"></a><span id="l64.202">      * Result: Alice [invalid], Basil [valid]</span>
<a href="#l64.203"></a><span id="l64.203">      */</span>
<a href="#l64.204"></a><span id="l64.204" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case2/pubring.gpg&quot;);</span>
<a href="#l64.205"></a><span id="l64.205" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.206"></a><span id="l64.206" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case2/pubring.gpg&quot;);</span>
<a href="#l64.207"></a><span id="l64.207">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.208"></a><span id="l64.208">     assert_non_null(key = rnp_tests_key_search(pubring, &quot;Alice &lt;alice@rnp&gt;&quot;));</span>
<a href="#l64.209"></a><span id="l64.209">     assert_false(key-&gt;valid);</span>
<a href="#l64.210"></a><span id="l64.210">     assert_non_null(key = rnp_tests_key_search(pubring, &quot;Basil &lt;basil@rnp&gt;&quot;));</span>
<a href="#l64.211"></a><span id="l64.211">     assert_true(key-&gt;valid);</span>
<a href="#l64.212"></a><span id="l64.212" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.213"></a><span id="l64.213" class="difflineplus">+    delete pubring;</span>
<a href="#l64.214"></a><span id="l64.214"> </span>
<a href="#l64.215"></a><span id="l64.215">     /* Case3:</span>
<a href="#l64.216"></a><span id="l64.216">      * Keys: Alice [pub], Basil [pub]</span>
<a href="#l64.217"></a><span id="l64.217">      * Alice is signed by Basil, but doesn't have self-signature</span>
<a href="#l64.218"></a><span id="l64.218">      * Result: Alice [invalid]</span>
<a href="#l64.219"></a><span id="l64.219">      */</span>
<a href="#l64.220"></a><span id="l64.220" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case3/pubring.gpg&quot;);</span>
<a href="#l64.221"></a><span id="l64.221" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.222"></a><span id="l64.222" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case3/pubring.gpg&quot;);</span>
<a href="#l64.223"></a><span id="l64.223">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.224"></a><span id="l64.224">     assert_non_null(key = rnp_tests_key_search(pubring, &quot;Alice &lt;alice@rnp&gt;&quot;));</span>
<a href="#l64.225"></a><span id="l64.225">     assert_false(key-&gt;valid);</span>
<a href="#l64.226"></a><span id="l64.226">     assert_non_null(key = rnp_tests_key_search(pubring, &quot;Basil &lt;basil@rnp&gt;&quot;));</span>
<a href="#l64.227"></a><span id="l64.227">     assert_true(key-&gt;valid);</span>
<a href="#l64.228"></a><span id="l64.228" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.229"></a><span id="l64.229" class="difflineplus">+    delete pubring;</span>
<a href="#l64.230"></a><span id="l64.230"> </span>
<a href="#l64.231"></a><span id="l64.231">     /* Case4:</span>
<a href="#l64.232"></a><span id="l64.232">      * Keys Alice [pub, sub]</span>
<a href="#l64.233"></a><span id="l64.233">      * Alice subkey has invalid binding signature</span>
<a href="#l64.234"></a><span id="l64.234">      * Result: Alice [valid], Alice sub [invalid]</span>
<a href="#l64.235"></a><span id="l64.235">      */</span>
<a href="#l64.236"></a><span id="l64.236" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case4/pubring.gpg&quot;);</span>
<a href="#l64.237"></a><span id="l64.237" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.238"></a><span id="l64.238" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case4/pubring.gpg&quot;);</span>
<a href="#l64.239"></a><span id="l64.239">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.240"></a><span id="l64.240">     assert_non_null(key = rnp_tests_key_search(pubring, &quot;Alice &lt;alice@rnp&gt;&quot;));</span>
<a href="#l64.241"></a><span id="l64.241">     assert_true(key-&gt;valid);</span>
<a href="#l64.242"></a><span id="l64.242">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l64.243"></a><span id="l64.243">     pgp_key_t *subkey = NULL;</span>
<a href="#l64.244"></a><span id="l64.244">     assert_non_null(subkey = pgp_key_get_subkey(key, pubring, 0));</span>
<a href="#l64.245"></a><span id="l64.245">     assert_false(subkey-&gt;valid);</span>
<a href="#l64.246"></a><span id="l64.246" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.247"></a><span id="l64.247" class="difflineplus">+    delete pubring;</span>
<a href="#l64.248"></a><span id="l64.248"> </span>
<a href="#l64.249"></a><span id="l64.249">     /* Case5:</span>
<a href="#l64.250"></a><span id="l64.250">      * Keys Alice [pub, sub], Basil [pub]</span>
<a href="#l64.251"></a><span id="l64.251">      * Alice subkey has valid binding signature, but from the key Basil</span>
<a href="#l64.252"></a><span id="l64.252">      * Result: Alice [valid], Alice sub [invalid]</span>
<a href="#l64.253"></a><span id="l64.253">      *</span>
<a href="#l64.254"></a><span id="l64.254">      * Note: to re-generate keyring file, use generate.cpp from case5 folder.</span>
<a href="#l64.255"></a><span id="l64.255">      *       To build it, feed -DBUILD_TESTING_GENERATORS=On to the cmake.</span>
<a href="#l64.256"></a><span id="l64.256">      */</span>
<a href="#l64.257"></a><span id="l64.257" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case5/pubring.gpg&quot;);</span>
<a href="#l64.258"></a><span id="l64.258" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.259"></a><span id="l64.259" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case5/pubring.gpg&quot;);</span>
<a href="#l64.260"></a><span id="l64.260">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.261"></a><span id="l64.261">     assert_non_null(key = rnp_tests_key_search(pubring, &quot;Alice &lt;alice@rnp&gt;&quot;));</span>
<a href="#l64.262"></a><span id="l64.262">     assert_true(key-&gt;valid);</span>
<a href="#l64.263"></a><span id="l64.263">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l64.264"></a><span id="l64.264">     assert_non_null(subkey = pgp_key_get_subkey(key, pubring, 0));</span>
<a href="#l64.265"></a><span id="l64.265">     assert_false(subkey-&gt;valid);</span>
<a href="#l64.266"></a><span id="l64.266" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.267"></a><span id="l64.267" class="difflineplus">+    delete pubring;</span>
<a href="#l64.268"></a><span id="l64.268"> </span>
<a href="#l64.269"></a><span id="l64.269">     /* Case6:</span>
<a href="#l64.270"></a><span id="l64.270">      * Keys Alice [pub, sub]</span>
<a href="#l64.271"></a><span id="l64.271">      * Key Alice has revocation signature by Alice, and subkey doesn't</span>
<a href="#l64.272"></a><span id="l64.272">      * Result: Alice [invalid], Alice sub [invalid]</span>
<a href="#l64.273"></a><span id="l64.273">      */</span>
<a href="#l64.274"></a><span id="l64.274" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case6/pubring.gpg&quot;);</span>
<a href="#l64.275"></a><span id="l64.275" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.276"></a><span id="l64.276" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case6/pubring.gpg&quot;);</span>
<a href="#l64.277"></a><span id="l64.277">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.278"></a><span id="l64.278">     assert_non_null(key = rnp_tests_key_search(pubring, &quot;Alice &lt;alice@rnp&gt;&quot;));</span>
<a href="#l64.279"></a><span id="l64.279">     assert_false(key-&gt;valid);</span>
<a href="#l64.280"></a><span id="l64.280">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l64.281"></a><span id="l64.281">     assert_non_null(subkey = pgp_key_get_subkey(key, pubring, 0));</span>
<a href="#l64.282"></a><span id="l64.282">     assert_false(subkey-&gt;valid);</span>
<a href="#l64.283"></a><span id="l64.283" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.284"></a><span id="l64.284" class="difflineplus">+    delete pubring;</span>
<a href="#l64.285"></a><span id="l64.285"> </span>
<a href="#l64.286"></a><span id="l64.286">     /* Case7:</span>
<a href="#l64.287"></a><span id="l64.287">      * Keys Alice [pub, sub]</span>
<a href="#l64.288"></a><span id="l64.288">      * Alice subkey has revocation signature by Alice</span>
<a href="#l64.289"></a><span id="l64.289">      * Result: Alice [valid], Alice sub [invalid]</span>
<a href="#l64.290"></a><span id="l64.290">      */</span>
<a href="#l64.291"></a><span id="l64.291" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case7/pubring.gpg&quot;);</span>
<a href="#l64.292"></a><span id="l64.292" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.293"></a><span id="l64.293" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case7/pubring.gpg&quot;);</span>
<a href="#l64.294"></a><span id="l64.294">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.295"></a><span id="l64.295">     assert_non_null(key = rnp_tests_key_search(pubring, &quot;Alice &lt;alice@rnp&gt;&quot;));</span>
<a href="#l64.296"></a><span id="l64.296">     assert_true(key-&gt;valid);</span>
<a href="#l64.297"></a><span id="l64.297">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l64.298"></a><span id="l64.298">     assert_non_null(subkey = pgp_key_get_subkey(key, pubring, 0));</span>
<a href="#l64.299"></a><span id="l64.299">     assert_false(subkey-&gt;valid);</span>
<a href="#l64.300"></a><span id="l64.300" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.301"></a><span id="l64.301" class="difflineplus">+    delete pubring;</span>
<a href="#l64.302"></a><span id="l64.302"> </span>
<a href="#l64.303"></a><span id="l64.303">     /* Case8:</span>
<a href="#l64.304"></a><span id="l64.304">      * Keys Alice [pub, sub]</span>
<a href="#l64.305"></a><span id="l64.305">      * Userid is stripped from the key, but it still has valid subkey binding</span>
<a href="#l64.306"></a><span id="l64.306">      * Result: Alice [valid], Alice sub[valid]</span>
<a href="#l64.307"></a><span id="l64.307">      */</span>
<a href="#l64.308"></a><span id="l64.308" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case8/pubring.gpg&quot;);</span>
<a href="#l64.309"></a><span id="l64.309" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case8/pubring.gpg&quot;);</span>
<a href="#l64.310"></a><span id="l64.310" class="difflineplus">+    assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.311"></a><span id="l64.311" class="difflineplus">+    assert_non_null(key = rnp_tests_get_key_by_id(pubring, &quot;0451409669FFDE3C&quot;, NULL));</span>
<a href="#l64.312"></a><span id="l64.312" class="difflineplus">+    assert_true(key-&gt;valid);</span>
<a href="#l64.313"></a><span id="l64.313" class="difflineplus">+    assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l64.314"></a><span id="l64.314" class="difflineplus">+    assert_non_null(subkey = pgp_key_get_subkey(key, pubring, 0));</span>
<a href="#l64.315"></a><span id="l64.315" class="difflineplus">+    assert_true(subkey-&gt;valid);</span>
<a href="#l64.316"></a><span id="l64.316" class="difflineplus">+    delete pubring;</span>
<a href="#l64.317"></a><span id="l64.317" class="difflineplus">+</span>
<a href="#l64.318"></a><span id="l64.318" class="difflineplus">+    /* Case9:</span>
<a href="#l64.319"></a><span id="l64.319" class="difflineplus">+     * Keys Alice [pub, sub]</span>
<a href="#l64.320"></a><span id="l64.320" class="difflineplus">+     * Alice key has two self-signatures, one which expires key and second without key</span>
<a href="#l64.321"></a><span id="l64.321" class="difflineplus">+     * expiration.</span>
<a href="#l64.322"></a><span id="l64.322" class="difflineplus">+     * Result: Alice [valid], Alice sub[valid]</span>
<a href="#l64.323"></a><span id="l64.323" class="difflineplus">+     */</span>
<a href="#l64.324"></a><span id="l64.324" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case9/pubring.gpg&quot;);</span>
<a href="#l64.325"></a><span id="l64.325">     assert_non_null(pubring);</span>
<a href="#l64.326"></a><span id="l64.326">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.327"></a><span id="l64.327">     assert_non_null(key = rnp_tests_get_key_by_id(pubring, &quot;0451409669FFDE3C&quot;, NULL));</span>
<a href="#l64.328"></a><span id="l64.328">     assert_true(key-&gt;valid);</span>
<a href="#l64.329"></a><span id="l64.329">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l64.330"></a><span id="l64.330">     assert_non_null(subkey = pgp_key_get_subkey(key, pubring, 0));</span>
<a href="#l64.331"></a><span id="l64.331">     assert_true(subkey-&gt;valid);</span>
<a href="#l64.332"></a><span id="l64.332" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.333"></a><span id="l64.333" class="difflineminus">-</span>
<a href="#l64.334"></a><span id="l64.334" class="difflineminus">-    /* Case9:</span>
<a href="#l64.335"></a><span id="l64.335" class="difflineminus">-     * Keys Alice [pub, sub]</span>
<a href="#l64.336"></a><span id="l64.336" class="difflineminus">-     * Alice key has two self-signatures, one which expires key and second without key</span>
<a href="#l64.337"></a><span id="l64.337" class="difflineminus">-     * expiration.</span>
<a href="#l64.338"></a><span id="l64.338" class="difflineminus">-     * Result: Alice [valid], Alice sub[valid]</span>
<a href="#l64.339"></a><span id="l64.339" class="difflineminus">-     */</span>
<a href="#l64.340"></a><span id="l64.340" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, KEYSIG_PATH &quot;case9/pubring.gpg&quot;);</span>
<a href="#l64.341"></a><span id="l64.341" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l64.342"></a><span id="l64.342" class="difflineminus">-    assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l64.343"></a><span id="l64.343" class="difflineminus">-    assert_non_null(key = rnp_tests_get_key_by_id(pubring, &quot;0451409669FFDE3C&quot;, NULL));</span>
<a href="#l64.344"></a><span id="l64.344" class="difflineminus">-    assert_true(key-&gt;valid);</span>
<a href="#l64.345"></a><span id="l64.345" class="difflineminus">-    assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l64.346"></a><span id="l64.346" class="difflineminus">-    assert_non_null(subkey = pgp_key_get_subkey(key, pubring, 0));</span>
<a href="#l64.347"></a><span id="l64.347" class="difflineminus">-    assert_true(subkey-&gt;valid);</span>
<a href="#l64.348"></a><span id="l64.348" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l64.349"></a><span id="l64.349" class="difflineplus">+    delete pubring;</span>
<a href="#l64.350"></a><span id="l64.350"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l65.1"></a><span id="l65.1" class="difflineminus">--- a/third_party/rnp/src/tests/load-g10.cpp</span>
<a href="#l65.2"></a><span id="l65.2" class="difflineplus">+++ b/third_party/rnp/src/tests/load-g10.cpp</span>
<a href="#l65.3"></a><span id="l65.3" class="difflineat">@@ -55,41 +55,37 @@ test_load_g10_check_key(rnp_key_store_t </span>
<a href="#l65.4"></a><span id="l65.4">  */</span>
<a href="#l65.5"></a><span id="l65.5"> TEST_F(rnp_tests, test_load_g10)</span>
<a href="#l65.6"></a><span id="l65.6"> {</span>
<a href="#l65.7"></a><span id="l65.7">     rnp_key_store_t *  pub_store = NULL;</span>
<a href="#l65.8"></a><span id="l65.8">     rnp_key_store_t *  sec_store = NULL;</span>
<a href="#l65.9"></a><span id="l65.9">     pgp_key_provider_t key_provider = {.callback = rnp_key_provider_store, .userdata = NULL};</span>
<a href="#l65.10"></a><span id="l65.10"> </span>
<a href="#l65.11"></a><span id="l65.11">     // load pubring</span>
<a href="#l65.12"></a><span id="l65.12" class="difflineminus">-    assert_non_null(pub_store =</span>
<a href="#l65.13"></a><span id="l65.13" class="difflineminus">-                      rnp_key_store_new(PGP_KEY_STORE_KBX, &quot;data/keyrings/3/pubring.kbx&quot;));</span>
<a href="#l65.14"></a><span id="l65.14" class="difflineplus">+    pub_store = new rnp_key_store_t(PGP_KEY_STORE_KBX, &quot;data/keyrings/3/pubring.kbx&quot;);</span>
<a href="#l65.15"></a><span id="l65.15">     assert_true(rnp_key_store_load_from_path(pub_store, NULL));</span>
<a href="#l65.16"></a><span id="l65.16">     // load secring</span>
<a href="#l65.17"></a><span id="l65.17" class="difflineminus">-    assert_non_null(</span>
<a href="#l65.18"></a><span id="l65.18" class="difflineminus">-      sec_store = rnp_key_store_new(PGP_KEY_STORE_G10, &quot;data/keyrings/3/private-keys-v1.d&quot;));</span>
<a href="#l65.19"></a><span id="l65.19" class="difflineplus">+    sec_store = new rnp_key_store_t(PGP_KEY_STORE_G10, &quot;data/keyrings/3/private-keys-v1.d&quot;);</span>
<a href="#l65.20"></a><span id="l65.20">     key_provider.userdata = pub_store;</span>
<a href="#l65.21"></a><span id="l65.21">     assert_true(rnp_key_store_load_from_path(sec_store, &amp;key_provider));</span>
<a href="#l65.22"></a><span id="l65.22"> </span>
<a href="#l65.23"></a><span id="l65.23">     /* check primary key and subkey */</span>
<a href="#l65.24"></a><span id="l65.24">     test_load_g10_check_key(pub_store, sec_store, &quot;4BE147BB22DF1E60&quot;);</span>
<a href="#l65.25"></a><span id="l65.25">     test_load_g10_check_key(pub_store, sec_store, &quot;A49BAE05C16E8BC8&quot;);</span>
<a href="#l65.26"></a><span id="l65.26"> </span>
<a href="#l65.27"></a><span id="l65.27">     // cleanup</span>
<a href="#l65.28"></a><span id="l65.28" class="difflineminus">-    rnp_key_store_free(pub_store);</span>
<a href="#l65.29"></a><span id="l65.29" class="difflineminus">-    rnp_key_store_free(sec_store);</span>
<a href="#l65.30"></a><span id="l65.30" class="difflineplus">+    delete pub_store;</span>
<a href="#l65.31"></a><span id="l65.31" class="difflineplus">+    delete sec_store;</span>
<a href="#l65.32"></a><span id="l65.32"> </span>
<a href="#l65.33"></a><span id="l65.33">     /* another store */</span>
<a href="#l65.34"></a><span id="l65.34">     pub_store =</span>
<a href="#l65.35"></a><span id="l65.35" class="difflineminus">-      rnp_key_store_new(PGP_KEY_STORE_KBX, &quot;data/test_stream_key_load/g10/pubring.kbx&quot;);</span>
<a href="#l65.36"></a><span id="l65.36" class="difflineminus">-    assert_non_null(pub_store);</span>
<a href="#l65.37"></a><span id="l65.37" class="difflineplus">+      new rnp_key_store_t(PGP_KEY_STORE_KBX, &quot;data/test_stream_key_load/g10/pubring.kbx&quot;);</span>
<a href="#l65.38"></a><span id="l65.38">     assert_true(rnp_key_store_load_from_path(pub_store, NULL));</span>
<a href="#l65.39"></a><span id="l65.39" class="difflineminus">-    sec_store =</span>
<a href="#l65.40"></a><span id="l65.40" class="difflineminus">-      rnp_key_store_new(PGP_KEY_STORE_G10, &quot;data/test_stream_key_load/g10/private-keys-v1.d&quot;);</span>
<a href="#l65.41"></a><span id="l65.41" class="difflineminus">-    assert_non_null(sec_store);</span>
<a href="#l65.42"></a><span id="l65.42" class="difflineplus">+    sec_store = new rnp_key_store_t(PGP_KEY_STORE_G10,</span>
<a href="#l65.43"></a><span id="l65.43" class="difflineplus">+                                    &quot;data/test_stream_key_load/g10/private-keys-v1.d&quot;);</span>
<a href="#l65.44"></a><span id="l65.44">     key_provider.userdata = pub_store;</span>
<a href="#l65.45"></a><span id="l65.45">     assert_true(rnp_key_store_load_from_path(sec_store, &amp;key_provider));</span>
<a href="#l65.46"></a><span id="l65.46"> </span>
<a href="#l65.47"></a><span id="l65.47">     /* dsa/eg key */</span>
<a href="#l65.48"></a><span id="l65.48">     assert_true(test_load_g10_check_key(pub_store, sec_store, &quot;C8A10A7D78273E10&quot;));</span>
<a href="#l65.49"></a><span id="l65.49">     assert_true(test_load_g10_check_key(pub_store, sec_store, &quot;02A5715C3537717E&quot;));</span>
<a href="#l65.50"></a><span id="l65.50"> </span>
<a href="#l65.51"></a><span id="l65.51">     /* rsa/rsa key */</span>
<a href="#l65.52"></a><span id="l65.52" class="difflineat">@@ -114,11 +110,11 @@ TEST_F(rnp_tests, test_load_g10)</span>
<a href="#l65.53"></a><span id="l65.53">     /* p-521/p-521 key */</span>
<a href="#l65.54"></a><span id="l65.54">     assert_true(test_load_g10_check_key(pub_store, sec_store, &quot;2092CA8324263B6A&quot;));</span>
<a href="#l65.55"></a><span id="l65.55">     assert_true(test_load_g10_check_key(pub_store, sec_store, &quot;9853DF2F6D297442&quot;));</span>
<a href="#l65.56"></a><span id="l65.56"> </span>
<a href="#l65.57"></a><span id="l65.57">     /* p256k1/p156k1 key */</span>
<a href="#l65.58"></a><span id="l65.58">     assert_true(test_load_g10_check_key(pub_store, sec_store, &quot;3EA5BB6F9692C1A0&quot;));</span>
<a href="#l65.59"></a><span id="l65.59">     assert_true(test_load_g10_check_key(pub_store, sec_store, &quot;7635401F90D3E533&quot;));</span>
<a href="#l65.60"></a><span id="l65.60"> </span>
<a href="#l65.61"></a><span id="l65.61" class="difflineminus">-    rnp_key_store_free(pub_store);</span>
<a href="#l65.62"></a><span id="l65.62" class="difflineminus">-    rnp_key_store_free(sec_store);</span>
<a href="#l65.63"></a><span id="l65.63" class="difflineplus">+    delete pub_store;</span>
<a href="#l65.64"></a><span id="l65.64" class="difflineplus">+    delete sec_store;</span>
<a href="#l65.65"></a><span id="l65.65"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l66.1"></a><span id="l66.1" class="difflineminus">--- a/third_party/rnp/src/tests/load-pgp.cpp</span>
<a href="#l66.2"></a><span id="l66.2" class="difflineplus">+++ b/third_party/rnp/src/tests/load-pgp.cpp</span>
<a href="#l66.3"></a><span id="l66.3" class="difflineat">@@ -35,18 +35,17 @@</span>
<a href="#l66.4"></a><span id="l66.4"> </span>
<a href="#l66.5"></a><span id="l66.5"> /* This test loads a .gpg pubring with a single V3 key,</span>
<a href="#l66.6"></a><span id="l66.6">  * and confirms that appropriate key flags are set.</span>
<a href="#l66.7"></a><span id="l66.7">  */</span>
<a href="#l66.8"></a><span id="l66.8"> TEST_F(rnp_tests, test_load_v3_keyring_pgp)</span>
<a href="#l66.9"></a><span id="l66.9"> {</span>
<a href="#l66.10"></a><span id="l66.10">     pgp_source_t src = {};</span>
<a href="#l66.11"></a><span id="l66.11"> </span>
<a href="#l66.12"></a><span id="l66.12" class="difflineminus">-    rnp_key_store_t *key_store = (rnp_key_store_t *) calloc(1, sizeof(*key_store));</span>
<a href="#l66.13"></a><span id="l66.13" class="difflineminus">-    assert_non_null(key_store);</span>
<a href="#l66.14"></a><span id="l66.14" class="difflineplus">+    rnp_key_store_t *key_store = new rnp_key_store_t();</span>
<a href="#l66.15"></a><span id="l66.15"> </span>
<a href="#l66.16"></a><span id="l66.16">     // load pubring in to the key store</span>
<a href="#l66.17"></a><span id="l66.17">     assert_rnp_success(init_file_src(&amp;src, &quot;data/keyrings/2/pubring.gpg&quot;));</span>
<a href="#l66.18"></a><span id="l66.18">     assert_rnp_success(rnp_key_store_pgp_read_from_src(key_store, &amp;src));</span>
<a href="#l66.19"></a><span id="l66.19">     src_close(&amp;src);</span>
<a href="#l66.20"></a><span id="l66.20">     assert_int_equal(1, rnp_key_store_get_key_count(key_store));</span>
<a href="#l66.21"></a><span id="l66.21"> </span>
<a href="#l66.22"></a><span id="l66.22">     // find the key by keyid</span>
<a href="#l66.23"></a><span id="l66.23" class="difflineat">@@ -57,22 +56,21 @@ TEST_F(rnp_tests, test_load_v3_keyring_p</span>
<a href="#l66.24"></a><span id="l66.24">     // confirm the key flags are correct</span>
<a href="#l66.25"></a><span id="l66.25">     assert_int_equal(pgp_key_get_flags(key),</span>
<a href="#l66.26"></a><span id="l66.26">                      PGP_KF_ENCRYPT | PGP_KF_SIGN | PGP_KF_CERTIFY | PGP_KF_AUTH);</span>
<a href="#l66.27"></a><span id="l66.27"> </span>
<a href="#l66.28"></a><span id="l66.28">     // confirm that key expiration is correct</span>
<a href="#l66.29"></a><span id="l66.29">     assert_int_equal(pgp_key_get_expiration(key), 0);</span>
<a href="#l66.30"></a><span id="l66.30"> </span>
<a href="#l66.31"></a><span id="l66.31">     // cleanup</span>
<a href="#l66.32"></a><span id="l66.32" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l66.33"></a><span id="l66.33" class="difflineplus">+    delete key_store;</span>
<a href="#l66.34"></a><span id="l66.34"> </span>
<a href="#l66.35"></a><span id="l66.35">     // load secret keyring and decrypt the key</span>
<a href="#l66.36"></a><span id="l66.36"> </span>
<a href="#l66.37"></a><span id="l66.37" class="difflineminus">-    key_store = (rnp_key_store_t *) calloc(1, sizeof(*key_store));</span>
<a href="#l66.38"></a><span id="l66.38" class="difflineminus">-    assert_non_null(key_store);</span>
<a href="#l66.39"></a><span id="l66.39" class="difflineplus">+    key_store = new rnp_key_store_t();</span>
<a href="#l66.40"></a><span id="l66.40"> </span>
<a href="#l66.41"></a><span id="l66.41">     assert_rnp_success(init_file_src(&amp;src, &quot;data/keyrings/4/secring.pgp&quot;));</span>
<a href="#l66.42"></a><span id="l66.42">     assert_rnp_success(rnp_key_store_pgp_read_from_src(key_store, &amp;src));</span>
<a href="#l66.43"></a><span id="l66.43">     src_close(&amp;src);</span>
<a href="#l66.44"></a><span id="l66.44">     assert_int_equal(1, rnp_key_store_get_key_count(key_store));</span>
<a href="#l66.45"></a><span id="l66.45"> </span>
<a href="#l66.46"></a><span id="l66.46">     static const uint8_t keyid2[] = {0x7D, 0x0B, 0xC1, 0x0E, 0x93, 0x34, 0x04, 0xC9};</span>
<a href="#l66.47"></a><span id="l66.47">     key = rnp_key_store_get_key_by_id(key_store, keyid2, NULL);</span>
<a href="#l66.48"></a><span id="l66.48" class="difflineat">@@ -82,99 +80,96 @@ TEST_F(rnp_tests, test_load_v3_keyring_p</span>
<a href="#l66.49"></a><span id="l66.49">     assert_int_equal(pgp_key_get_flags(key),</span>
<a href="#l66.50"></a><span id="l66.50">                      PGP_KF_ENCRYPT | PGP_KF_SIGN | PGP_KF_CERTIFY | PGP_KF_AUTH);</span>
<a href="#l66.51"></a><span id="l66.51"> </span>
<a href="#l66.52"></a><span id="l66.52">     // check if the key is secret and is locked</span>
<a href="#l66.53"></a><span id="l66.53">     assert_true(pgp_key_is_secret(key));</span>
<a href="#l66.54"></a><span id="l66.54">     assert_true(pgp_key_is_locked(key));</span>
<a href="#l66.55"></a><span id="l66.55"> </span>
<a href="#l66.56"></a><span id="l66.56">     // decrypt the key</span>
<a href="#l66.57"></a><span id="l66.57" class="difflineminus">-    const pgp_rawpacket_t *pkt = pgp_key_get_rawpacket(key, 0);</span>
<a href="#l66.58"></a><span id="l66.58" class="difflineplus">+    const pgp_rawpacket_t &amp;pkt = pgp_key_get_rawpacket(key);</span>
<a href="#l66.59"></a><span id="l66.59">     pgp_key_pkt_t *        seckey =</span>
<a href="#l66.60"></a><span id="l66.60" class="difflineminus">-      pgp_decrypt_seckey_pgp(pkt-&gt;raw, pkt-&gt;length, pgp_key_get_pkt(key), &quot;password&quot;);</span>
<a href="#l66.61"></a><span id="l66.61" class="difflineplus">+      pgp_decrypt_seckey_pgp(pkt.raw.data(), pkt.raw.size(), pgp_key_get_pkt(key), &quot;password&quot;);</span>
<a href="#l66.62"></a><span id="l66.62">     assert_non_null(seckey);</span>
<a href="#l66.63"></a><span id="l66.63"> </span>
<a href="#l66.64"></a><span id="l66.64">     // cleanup</span>
<a href="#l66.65"></a><span id="l66.65">     free_key_pkt(seckey);</span>
<a href="#l66.66"></a><span id="l66.66">     free(seckey);</span>
<a href="#l66.67"></a><span id="l66.67" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l66.68"></a><span id="l66.68" class="difflineplus">+    delete key_store;</span>
<a href="#l66.69"></a><span id="l66.69"> }</span>
<a href="#l66.70"></a><span id="l66.70"> </span>
<a href="#l66.71"></a><span id="l66.71"> /* This test loads a .gpg pubring with multiple V4 keys,</span>
<a href="#l66.72"></a><span id="l66.72">  * finds a particular key of interest, and confirms that</span>
<a href="#l66.73"></a><span id="l66.73">  * the appropriate key flags are set.</span>
<a href="#l66.74"></a><span id="l66.74">  */</span>
<a href="#l66.75"></a><span id="l66.75"> TEST_F(rnp_tests, test_load_v4_keyring_pgp)</span>
<a href="#l66.76"></a><span id="l66.76"> {</span>
<a href="#l66.77"></a><span id="l66.77">     pgp_source_t src = {};</span>
<a href="#l66.78"></a><span id="l66.78"> </span>
<a href="#l66.79"></a><span id="l66.79" class="difflineminus">-    rnp_key_store_t *key_store = (rnp_key_store_t *) calloc(1, sizeof(*key_store));</span>
<a href="#l66.80"></a><span id="l66.80" class="difflineminus">-    assert_non_null(key_store);</span>
<a href="#l66.81"></a><span id="l66.81" class="difflineplus">+    rnp_key_store_t *key_store = new rnp_key_store_t();</span>
<a href="#l66.82"></a><span id="l66.82"> </span>
<a href="#l66.83"></a><span id="l66.83">     // load it in to the key store</span>
<a href="#l66.84"></a><span id="l66.84">     assert_rnp_success(init_file_src(&amp;src, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l66.85"></a><span id="l66.85">     assert_rnp_success(rnp_key_store_pgp_read_from_src(key_store, &amp;src));</span>
<a href="#l66.86"></a><span id="l66.86">     src_close(&amp;src);</span>
<a href="#l66.87"></a><span id="l66.87">     assert_int_equal(7, rnp_key_store_get_key_count(key_store));</span>
<a href="#l66.88"></a><span id="l66.88"> </span>
<a href="#l66.89"></a><span id="l66.89">     // find the key by keyid</span>
<a href="#l66.90"></a><span id="l66.90">     static const uint8_t keyid[] = {0x8a, 0x05, 0xb8, 0x9f, 0xad, 0x5a, 0xde, 0xd1};</span>
<a href="#l66.91"></a><span id="l66.91">     const pgp_key_t *    key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.92"></a><span id="l66.92">     assert_non_null(key);</span>
<a href="#l66.93"></a><span id="l66.93"> </span>
<a href="#l66.94"></a><span id="l66.94">     // confirm the key flags are correct</span>
<a href="#l66.95"></a><span id="l66.95">     assert_int_equal(pgp_key_get_flags(key), PGP_KF_ENCRYPT);</span>
<a href="#l66.96"></a><span id="l66.96"> </span>
<a href="#l66.97"></a><span id="l66.97">     // cleanup</span>
<a href="#l66.98"></a><span id="l66.98" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l66.99"></a><span id="l66.99" class="difflineplus">+    delete key_store;</span>
<a href="#l66.100"></a><span id="l66.100"> }</span>
<a href="#l66.101"></a><span id="l66.101"> </span>
<a href="#l66.102"></a><span id="l66.102"> /* Just a helper for the below test */</span>
<a href="#l66.103"></a><span id="l66.103"> static void</span>
<a href="#l66.104"></a><span id="l66.104"> check_pgp_keyring_counts(const char *   path,</span>
<a href="#l66.105"></a><span id="l66.105">                          unsigned       primary_count,</span>
<a href="#l66.106"></a><span id="l66.106">                          const unsigned subkey_counts[])</span>
<a href="#l66.107"></a><span id="l66.107"> {</span>
<a href="#l66.108"></a><span id="l66.108">     pgp_source_t     src = {};</span>
<a href="#l66.109"></a><span id="l66.109" class="difflineminus">-    rnp_key_store_t *key_store = (rnp_key_store_t *) calloc(1, sizeof(*key_store));</span>
<a href="#l66.110"></a><span id="l66.110" class="difflineplus">+    rnp_key_store_t *key_store = new rnp_key_store_t();</span>
<a href="#l66.111"></a><span id="l66.111"> </span>
<a href="#l66.112"></a><span id="l66.112" class="difflineminus">-    assert_non_null(key_store);</span>
<a href="#l66.113"></a><span id="l66.113">     // load it in to the key store</span>
<a href="#l66.114"></a><span id="l66.114">     assert_rnp_success(init_file_src(&amp;src, path));</span>
<a href="#l66.115"></a><span id="l66.115">     assert_rnp_success(rnp_key_store_pgp_read_from_src(key_store, &amp;src));</span>
<a href="#l66.116"></a><span id="l66.116">     src_close(&amp;src);</span>
<a href="#l66.117"></a><span id="l66.117"> </span>
<a href="#l66.118"></a><span id="l66.118">     // count primary keys first</span>
<a href="#l66.119"></a><span id="l66.119">     unsigned total_primary_count = 0;</span>
<a href="#l66.120"></a><span id="l66.120" class="difflineminus">-    for (size_t i = 0; i &lt; rnp_key_store_get_key_count(key_store); i++) {</span>
<a href="#l66.121"></a><span id="l66.121" class="difflineminus">-        if (pgp_key_is_primary_key(rnp_key_store_get_key(key_store, i))) {</span>
<a href="#l66.122"></a><span id="l66.122" class="difflineplus">+    for (auto &amp;key : key_store-&gt;keys) {</span>
<a href="#l66.123"></a><span id="l66.123" class="difflineplus">+        if (pgp_key_is_primary_key(&amp;key)) {</span>
<a href="#l66.124"></a><span id="l66.124">             total_primary_count++;</span>
<a href="#l66.125"></a><span id="l66.125">         }</span>
<a href="#l66.126"></a><span id="l66.126">     }</span>
<a href="#l66.127"></a><span id="l66.127">     assert_int_equal(primary_count, total_primary_count);</span>
<a href="#l66.128"></a><span id="l66.128"> </span>
<a href="#l66.129"></a><span id="l66.129">     // now count subkeys in each primary key</span>
<a href="#l66.130"></a><span id="l66.130">     unsigned total_subkey_count = 0;</span>
<a href="#l66.131"></a><span id="l66.131">     unsigned primary = 0;</span>
<a href="#l66.132"></a><span id="l66.132" class="difflineminus">-    for (size_t i = 0; i &lt; rnp_key_store_get_key_count(key_store); i++) {</span>
<a href="#l66.133"></a><span id="l66.133" class="difflineminus">-        pgp_key_t *key = rnp_key_store_get_key(key_store, i);</span>
<a href="#l66.134"></a><span id="l66.134" class="difflineminus">-        if (pgp_key_is_primary_key(key)) {</span>
<a href="#l66.135"></a><span id="l66.135" class="difflineplus">+    for (auto &amp;key : key_store-&gt;keys) {</span>
<a href="#l66.136"></a><span id="l66.136" class="difflineplus">+        if (pgp_key_is_primary_key(&amp;key)) {</span>
<a href="#l66.137"></a><span id="l66.137">             // check the subkey count for this primary key</span>
<a href="#l66.138"></a><span id="l66.138" class="difflineminus">-            assert_int_equal(pgp_key_get_subkey_count(key), subkey_counts[primary++]);</span>
<a href="#l66.139"></a><span id="l66.139" class="difflineminus">-        } else if (pgp_key_is_subkey(key)) {</span>
<a href="#l66.140"></a><span id="l66.140" class="difflineplus">+            assert_int_equal(pgp_key_get_subkey_count(&amp;key), subkey_counts[primary++]);</span>
<a href="#l66.141"></a><span id="l66.141" class="difflineplus">+        } else if (pgp_key_is_subkey(&amp;key)) {</span>
<a href="#l66.142"></a><span id="l66.142">             total_subkey_count++;</span>
<a href="#l66.143"></a><span id="l66.143">         }</span>
<a href="#l66.144"></a><span id="l66.144">     }</span>
<a href="#l66.145"></a><span id="l66.145"> </span>
<a href="#l66.146"></a><span id="l66.146">     // check the total (not really needed)</span>
<a href="#l66.147"></a><span id="l66.147">     assert_int_equal(rnp_key_store_get_key_count(key_store),</span>
<a href="#l66.148"></a><span id="l66.148">                      total_primary_count + total_subkey_count);</span>
<a href="#l66.149"></a><span id="l66.149"> </span>
<a href="#l66.150"></a><span id="l66.150">     // cleanup</span>
<a href="#l66.151"></a><span id="l66.151" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l66.152"></a><span id="l66.152" class="difflineplus">+    delete key_store;</span>
<a href="#l66.153"></a><span id="l66.153"> }</span>
<a href="#l66.154"></a><span id="l66.154"> </span>
<a href="#l66.155"></a><span id="l66.155"> /* This test loads a pubring.gpg and secring.gpg and confirms</span>
<a href="#l66.156"></a><span id="l66.156">  * that it contains the expected number of primary keys</span>
<a href="#l66.157"></a><span id="l66.157">  * and the expected number of subkeys for each primary key.</span>
<a href="#l66.158"></a><span id="l66.158">  */</span>
<a href="#l66.159"></a><span id="l66.159"> TEST_F(rnp_tests, test_load_keyring_and_count_pgp)</span>
<a href="#l66.160"></a><span id="l66.160"> {</span>
<a href="#l66.161"></a><span id="l66.161" class="difflineat">@@ -195,18 +190,17 @@ TEST_F(rnp_tests, test_load_check_bitfie</span>
<a href="#l66.162"></a><span id="l66.162"> {</span>
<a href="#l66.163"></a><span id="l66.163">     uint8_t                keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.164"></a><span id="l66.164">     uint8_t                signer_id[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l66.165"></a><span id="l66.165">     const pgp_key_t *      key;</span>
<a href="#l66.166"></a><span id="l66.166">     const pgp_signature_t *sig = NULL;</span>
<a href="#l66.167"></a><span id="l66.167"> </span>
<a href="#l66.168"></a><span id="l66.168">     // load keyring</span>
<a href="#l66.169"></a><span id="l66.169">     rnp_key_store_t *key_store =</span>
<a href="#l66.170"></a><span id="l66.170" class="difflineminus">-      rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l66.171"></a><span id="l66.171" class="difflineminus">-    assert_non_null(key_store);</span>
<a href="#l66.172"></a><span id="l66.172" class="difflineplus">+      new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l66.173"></a><span id="l66.173">     assert_true(rnp_key_store_load_from_path(key_store, NULL));</span>
<a href="#l66.174"></a><span id="l66.174"> </span>
<a href="#l66.175"></a><span id="l66.175">     // find</span>
<a href="#l66.176"></a><span id="l66.176">     key = NULL;</span>
<a href="#l66.177"></a><span id="l66.177">     assert_true(rnp_hex_decode(&quot;7BC6709B15C23A4A&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.178"></a><span id="l66.178">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.179"></a><span id="l66.179">     assert_non_null(key);</span>
<a href="#l66.180"></a><span id="l66.180">     // check subsig count</span>
<a href="#l66.181"></a><span id="l66.181" class="difflineat">@@ -345,33 +339,32 @@ TEST_F(rnp_tests, test_load_check_bitfie</span>
<a href="#l66.182"></a><span id="l66.182">     assert_int_equal(signature_get_creation(sig), 1500570165);</span>
<a href="#l66.183"></a><span id="l66.183">     assert_int_equal(signature_get_creation(sig), pgp_key_get_creation(key));</span>
<a href="#l66.184"></a><span id="l66.184">     // check SS_EXPIRATION_TIME [0]</span>
<a href="#l66.185"></a><span id="l66.185">     assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.186"></a><span id="l66.186">     // check SS_KEY_EXPIRY</span>
<a href="#l66.187"></a><span id="l66.187">     assert_int_equal(pgp_key_get_expiration(key), 0);</span>
<a href="#l66.188"></a><span id="l66.188"> </span>
<a href="#l66.189"></a><span id="l66.189">     // cleanup</span>
<a href="#l66.190"></a><span id="l66.190" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l66.191"></a><span id="l66.191" class="difflineplus">+    delete key_store;</span>
<a href="#l66.192"></a><span id="l66.192"> }</span>
<a href="#l66.193"></a><span id="l66.193"> </span>
<a href="#l66.194"></a><span id="l66.194"> /* This test loads a V3 keyring and confirms that certain</span>
<a href="#l66.195"></a><span id="l66.195">  * bitfields and time fields are set correctly.</span>
<a href="#l66.196"></a><span id="l66.196">  */</span>
<a href="#l66.197"></a><span id="l66.197"> TEST_F(rnp_tests, test_load_check_bitfields_and_times_v3)</span>
<a href="#l66.198"></a><span id="l66.198"> {</span>
<a href="#l66.199"></a><span id="l66.199">     uint8_t                keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.200"></a><span id="l66.200">     uint8_t                signer_id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.201"></a><span id="l66.201">     const pgp_key_t *      key;</span>
<a href="#l66.202"></a><span id="l66.202">     const pgp_signature_t *sig = NULL;</span>
<a href="#l66.203"></a><span id="l66.203"> </span>
<a href="#l66.204"></a><span id="l66.204">     // load keyring</span>
<a href="#l66.205"></a><span id="l66.205">     rnp_key_store_t *key_store =</span>
<a href="#l66.206"></a><span id="l66.206" class="difflineminus">-      rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/2/pubring.gpg&quot;);</span>
<a href="#l66.207"></a><span id="l66.207" class="difflineminus">-    assert_non_null(key_store);</span>
<a href="#l66.208"></a><span id="l66.208" class="difflineplus">+      new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/2/pubring.gpg&quot;);</span>
<a href="#l66.209"></a><span id="l66.209">     assert_true(rnp_key_store_load_from_path(key_store, NULL));</span>
<a href="#l66.210"></a><span id="l66.210"> </span>
<a href="#l66.211"></a><span id="l66.211">     // find</span>
<a href="#l66.212"></a><span id="l66.212">     key = NULL;</span>
<a href="#l66.213"></a><span id="l66.213">     assert_true(rnp_hex_decode(&quot;DC70C124A50283F1&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.214"></a><span id="l66.214">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.215"></a><span id="l66.215">     assert_non_null(key);</span>
<a href="#l66.216"></a><span id="l66.216">     // check key version</span>
<a href="#l66.217"></a><span id="l66.217" class="difflineat">@@ -390,69 +383,68 @@ TEST_F(rnp_tests, test_load_check_bitfie</span>
<a href="#l66.218"></a><span id="l66.218">     assert_int_equal(signature_get_creation(sig), pgp_key_get_creation(key));</span>
<a href="#l66.219"></a><span id="l66.219">     // check signature expiration time (V3 sigs have none)</span>
<a href="#l66.220"></a><span id="l66.220">     assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.221"></a><span id="l66.221">     // check key expiration</span>
<a href="#l66.222"></a><span id="l66.222">     assert_int_equal(pgp_key_get_expiration(key), 0); // only for V4 keys</span>
<a href="#l66.223"></a><span id="l66.223">     assert_int_equal(pgp_key_get_pkt(key)-&gt;v3_days, 0);</span>
<a href="#l66.224"></a><span id="l66.224"> </span>
<a href="#l66.225"></a><span id="l66.225">     // cleanup</span>
<a href="#l66.226"></a><span id="l66.226" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l66.227"></a><span id="l66.227" class="difflineplus">+    delete key_store;</span>
<a href="#l66.228"></a><span id="l66.228"> }</span>
<a href="#l66.229"></a><span id="l66.229"> </span>
<a href="#l66.230"></a><span id="l66.230"> #define MERGE_PATH &quot;data/test_stream_key_merge/&quot;</span>
<a href="#l66.231"></a><span id="l66.231"> </span>
<a href="#l66.232"></a><span id="l66.232"> TEST_F(rnp_tests, test_load_armored_pub_sec)</span>
<a href="#l66.233"></a><span id="l66.233"> {</span>
<a href="#l66.234"></a><span id="l66.234">     pgp_key_t *      key;</span>
<a href="#l66.235"></a><span id="l66.235">     uint8_t          keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.236"></a><span id="l66.236">     rnp_key_store_t *key_store;</span>
<a href="#l66.237"></a><span id="l66.237"> </span>
<a href="#l66.238"></a><span id="l66.238" class="difflineminus">-    key_store = rnp_key_store_new(PGP_KEY_STORE_GPG, MERGE_PATH &quot;key-both.asc&quot;);</span>
<a href="#l66.239"></a><span id="l66.239" class="difflineminus">-    assert_non_null(key_store);</span>
<a href="#l66.240"></a><span id="l66.240" class="difflineplus">+    key_store = new rnp_key_store_t(PGP_KEY_STORE_GPG, MERGE_PATH &quot;key-both.asc&quot;);</span>
<a href="#l66.241"></a><span id="l66.241">     assert_true(rnp_key_store_load_from_path(key_store, NULL));</span>
<a href="#l66.242"></a><span id="l66.242"> </span>
<a href="#l66.243"></a><span id="l66.243">     /* we must have 1 main key and 2 subkeys */</span>
<a href="#l66.244"></a><span id="l66.244">     assert_int_equal(rnp_key_store_get_key_count(key_store), 3);</span>
<a href="#l66.245"></a><span id="l66.245"> </span>
<a href="#l66.246"></a><span id="l66.246">     assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.247"></a><span id="l66.247">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.248"></a><span id="l66.248">     assert_true(key-&gt;valid);</span>
<a href="#l66.249"></a><span id="l66.249">     assert_true(pgp_key_is_primary_key(key));</span>
<a href="#l66.250"></a><span id="l66.250">     assert_true(pgp_key_is_secret(key));</span>
<a href="#l66.251"></a><span id="l66.251">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.252"></a><span id="l66.252" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.253"></a><span id="l66.253" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.254"></a><span id="l66.254" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 2)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.255"></a><span id="l66.255" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 3)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.256"></a><span id="l66.256" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 4)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.257"></a><span id="l66.257" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.258"></a><span id="l66.258" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.259"></a><span id="l66.259" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.260"></a><span id="l66.260" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.261"></a><span id="l66.261" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.262"></a><span id="l66.262"> </span>
<a href="#l66.263"></a><span id="l66.263">     assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.264"></a><span id="l66.264">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.265"></a><span id="l66.265">     assert_true(key-&gt;valid);</span>
<a href="#l66.266"></a><span id="l66.266">     assert_true(pgp_key_is_subkey(key));</span>
<a href="#l66.267"></a><span id="l66.267">     assert_true(pgp_key_is_secret(key));</span>
<a href="#l66.268"></a><span id="l66.268">     assert_int_equal(pgp_key_get_rawpacket_count(key), 2);</span>
<a href="#l66.269"></a><span id="l66.269" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.270"></a><span id="l66.270" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.271"></a><span id="l66.271" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.272"></a><span id="l66.272" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.273"></a><span id="l66.273"> </span>
<a href="#l66.274"></a><span id="l66.274">     assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.275"></a><span id="l66.275">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.276"></a><span id="l66.276">     assert_true(key-&gt;valid);</span>
<a href="#l66.277"></a><span id="l66.277">     assert_true(pgp_key_is_subkey(key));</span>
<a href="#l66.278"></a><span id="l66.278">     assert_true(pgp_key_is_secret(key));</span>
<a href="#l66.279"></a><span id="l66.279">     assert_int_equal(pgp_key_get_rawpacket_count(key), 2);</span>
<a href="#l66.280"></a><span id="l66.280" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.281"></a><span id="l66.281" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.282"></a><span id="l66.282" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.283"></a><span id="l66.283" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.284"></a><span id="l66.284"> </span>
<a href="#l66.285"></a><span id="l66.285">     /* both user ids should be present */</span>
<a href="#l66.286"></a><span id="l66.286">     assert_non_null(rnp_tests_key_search(key_store, &quot;key-merge-uid-1&quot;));</span>
<a href="#l66.287"></a><span id="l66.287">     assert_non_null(rnp_tests_key_search(key_store, &quot;key-merge-uid-2&quot;));</span>
<a href="#l66.288"></a><span id="l66.288"> </span>
<a href="#l66.289"></a><span id="l66.289" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l66.290"></a><span id="l66.290" class="difflineplus">+    delete key_store;</span>
<a href="#l66.291"></a><span id="l66.291"> }</span>
<a href="#l66.292"></a><span id="l66.292"> </span>
<a href="#l66.293"></a><span id="l66.293"> static bool</span>
<a href="#l66.294"></a><span id="l66.294"> load_transferable_key(pgp_transferable_key_t *key, const char *fname)</span>
<a href="#l66.295"></a><span id="l66.295"> {</span>
<a href="#l66.296"></a><span id="l66.296">     pgp_source_t src = {};</span>
<a href="#l66.297"></a><span id="l66.297">     bool         res = !init_file_src(&amp;src, fname) &amp;&amp; !process_pgp_key(&amp;src, key);</span>
<a href="#l66.298"></a><span id="l66.298">     src_close(&amp;src);</span>
<a href="#l66.299"></a><span id="l66.299" class="difflineat">@@ -475,143 +467,141 @@ load_keystore(rnp_key_store_t *keystore,</span>
<a href="#l66.300"></a><span id="l66.300">     bool res = !init_file_src(&amp;src, fname) &amp;&amp; !rnp_key_store_pgp_read_from_src(keystore, &amp;src);</span>
<a href="#l66.301"></a><span id="l66.301">     src_close(&amp;src);</span>
<a href="#l66.302"></a><span id="l66.302">     return res;</span>
<a href="#l66.303"></a><span id="l66.303"> }</span>
<a href="#l66.304"></a><span id="l66.304"> </span>
<a href="#l66.305"></a><span id="l66.305"> static bool</span>
<a href="#l66.306"></a><span id="l66.306"> check_subkey_grip(pgp_key_t *key, pgp_key_t *subkey, size_t index)</span>
<a href="#l66.307"></a><span id="l66.307"> {</span>
<a href="#l66.308"></a><span id="l66.308" class="difflineminus">-    if (memcmp(</span>
<a href="#l66.309"></a><span id="l66.309" class="difflineminus">-          pgp_key_get_subkey_grip(key, index), pgp_key_get_grip(subkey), PGP_KEY_GRIP_SIZE)) {</span>
<a href="#l66.310"></a><span id="l66.310" class="difflineplus">+    if (pgp_key_get_subkey_grip(key, index) != pgp_key_get_grip(subkey)) {</span>
<a href="#l66.311"></a><span id="l66.311">         return false;</span>
<a href="#l66.312"></a><span id="l66.312">     }</span>
<a href="#l66.313"></a><span id="l66.313" class="difflineminus">-    return !memcmp(pgp_key_get_grip(key), pgp_key_get_primary_grip(subkey), PGP_KEY_GRIP_SIZE);</span>
<a href="#l66.314"></a><span id="l66.314" class="difflineplus">+    return pgp_key_get_grip(key) == pgp_key_get_primary_grip(subkey);</span>
<a href="#l66.315"></a><span id="l66.315"> }</span>
<a href="#l66.316"></a><span id="l66.316"> </span>
<a href="#l66.317"></a><span id="l66.317"> TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.318"></a><span id="l66.318"> {</span>
<a href="#l66.319"></a><span id="l66.319">     pgp_key_t *               key, *skey1, *skey2;</span>
<a href="#l66.320"></a><span id="l66.320">     uint8_t                   keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.321"></a><span id="l66.321">     uint8_t                   sub1id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.322"></a><span id="l66.322">     uint8_t                   sub2id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.323"></a><span id="l66.323">     rnp_key_store_t *         key_store;</span>
<a href="#l66.324"></a><span id="l66.324">     pgp_transferable_key_t    tkey = {};</span>
<a href="#l66.325"></a><span id="l66.325">     pgp_transferable_subkey_t tskey = {};</span>
<a href="#l66.326"></a><span id="l66.326">     pgp_password_provider_t   provider = (pgp_password_provider_t){</span>
<a href="#l66.327"></a><span id="l66.327">       .callback = string_copy_password_callback, .userdata = (void *) &quot;password&quot;};</span>
<a href="#l66.328"></a><span id="l66.328"> </span>
<a href="#l66.329"></a><span id="l66.329" class="difflineminus">-    key_store = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l66.330"></a><span id="l66.330" class="difflineminus">-    assert_non_null(key_store);</span>
<a href="#l66.331"></a><span id="l66.331" class="difflineplus">+    key_store = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l66.332"></a><span id="l66.332">     assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.333"></a><span id="l66.333">     assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, sub1id, sizeof(sub1id)));</span>
<a href="#l66.334"></a><span id="l66.334">     assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, sub2id, sizeof(sub2id)));</span>
<a href="#l66.335"></a><span id="l66.335"> </span>
<a href="#l66.336"></a><span id="l66.336">     /* load just key packet */</span>
<a href="#l66.337"></a><span id="l66.337">     assert_true(load_transferable_key(&amp;tkey, MERGE_PATH &quot;key-pub-just-key.pgp&quot;));</span>
<a href="#l66.338"></a><span id="l66.338">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.339"></a><span id="l66.339">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.340"></a><span id="l66.340">     assert_int_equal(rnp_key_store_get_key_count(key_store), 1);</span>
<a href="#l66.341"></a><span id="l66.341">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.342"></a><span id="l66.342">     assert_false(key-&gt;valid);</span>
<a href="#l66.343"></a><span id="l66.343">     assert_int_equal(pgp_key_get_rawpacket_count(key), 1);</span>
<a href="#l66.344"></a><span id="l66.344" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.345"></a><span id="l66.345" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.346"></a><span id="l66.346"> </span>
<a href="#l66.347"></a><span id="l66.347">     /* load key + user id 1 without sigs */</span>
<a href="#l66.348"></a><span id="l66.348">     assert_true(load_transferable_key(&amp;tkey, MERGE_PATH &quot;key-pub-uid-1-no-sigs.pgp&quot;));</span>
<a href="#l66.349"></a><span id="l66.349">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.350"></a><span id="l66.350">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.351"></a><span id="l66.351">     assert_int_equal(rnp_key_store_get_key_count(key_store), 1);</span>
<a href="#l66.352"></a><span id="l66.352">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.353"></a><span id="l66.353">     assert_false(key-&gt;valid);</span>
<a href="#l66.354"></a><span id="l66.354">     assert_int_equal(pgp_key_get_userid_count(key), 1);</span>
<a href="#l66.355"></a><span id="l66.355">     assert_int_equal(pgp_key_get_rawpacket_count(key), 2);</span>
<a href="#l66.356"></a><span id="l66.356" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.357"></a><span id="l66.357" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.358"></a><span id="l66.358" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.359"></a><span id="l66.359" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.360"></a><span id="l66.360">     assert_true(key == rnp_tests_key_search(key_store, &quot;key-merge-uid-1&quot;));</span>
<a href="#l66.361"></a><span id="l66.361"> </span>
<a href="#l66.362"></a><span id="l66.362">     /* load key + user id 1 with sigs */</span>
<a href="#l66.363"></a><span id="l66.363">     assert_true(load_transferable_key(&amp;tkey, MERGE_PATH &quot;key-pub-uid-1.pgp&quot;));</span>
<a href="#l66.364"></a><span id="l66.364">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.365"></a><span id="l66.365">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.366"></a><span id="l66.366">     assert_int_equal(rnp_key_store_get_key_count(key_store), 1);</span>
<a href="#l66.367"></a><span id="l66.367">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.368"></a><span id="l66.368">     assert_true(key-&gt;valid);</span>
<a href="#l66.369"></a><span id="l66.369">     assert_int_equal(pgp_key_get_userid_count(key), 1);</span>
<a href="#l66.370"></a><span id="l66.370">     assert_int_equal(pgp_key_get_rawpacket_count(key), 3);</span>
<a href="#l66.371"></a><span id="l66.371" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.372"></a><span id="l66.372" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.373"></a><span id="l66.373" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 2)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.374"></a><span id="l66.374" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.375"></a><span id="l66.375" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.376"></a><span id="l66.376" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.377"></a><span id="l66.377">     assert_true(key == rnp_tests_key_search(key_store, &quot;key-merge-uid-1&quot;));</span>
<a href="#l66.378"></a><span id="l66.378"> </span>
<a href="#l66.379"></a><span id="l66.379">     /* load key + user id 2 with sigs */</span>
<a href="#l66.380"></a><span id="l66.380">     assert_true(load_transferable_key(&amp;tkey, MERGE_PATH &quot;key-pub-uid-2.pgp&quot;));</span>
<a href="#l66.381"></a><span id="l66.381">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.382"></a><span id="l66.382">     /* try to add it twice */</span>
<a href="#l66.383"></a><span id="l66.383">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.384"></a><span id="l66.384">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.385"></a><span id="l66.385">     assert_int_equal(rnp_key_store_get_key_count(key_store), 1);</span>
<a href="#l66.386"></a><span id="l66.386">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.387"></a><span id="l66.387">     assert_true(key-&gt;valid);</span>
<a href="#l66.388"></a><span id="l66.388">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.389"></a><span id="l66.389">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.390"></a><span id="l66.390" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.391"></a><span id="l66.391" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.392"></a><span id="l66.392" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 2)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.393"></a><span id="l66.393" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 3)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.394"></a><span id="l66.394" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 4)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.395"></a><span id="l66.395" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.396"></a><span id="l66.396" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.397"></a><span id="l66.397" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.398"></a><span id="l66.398" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.399"></a><span id="l66.399" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.400"></a><span id="l66.400">     assert_true(key == rnp_tests_key_search(key_store, &quot;key-merge-uid-1&quot;));</span>
<a href="#l66.401"></a><span id="l66.401">     assert_true(key == rnp_tests_key_search(key_store, &quot;key-merge-uid-2&quot;));</span>
<a href="#l66.402"></a><span id="l66.402"> </span>
<a href="#l66.403"></a><span id="l66.403">     /* load key + subkey 1 without sigs */</span>
<a href="#l66.404"></a><span id="l66.404">     assert_true(load_transferable_key(&amp;tkey, MERGE_PATH &quot;key-pub-subkey-1-no-sigs.pgp&quot;));</span>
<a href="#l66.405"></a><span id="l66.405">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.406"></a><span id="l66.406">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.407"></a><span id="l66.407">     assert_int_equal(rnp_key_store_get_key_count(key_store), 2);</span>
<a href="#l66.408"></a><span id="l66.408">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.409"></a><span id="l66.409">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.410"></a><span id="l66.410">     assert_true(key-&gt;valid);</span>
<a href="#l66.411"></a><span id="l66.411">     assert_false(skey1-&gt;valid);</span>
<a href="#l66.412"></a><span id="l66.412">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.413"></a><span id="l66.413">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l66.414"></a><span id="l66.414">     assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.415"></a><span id="l66.415">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.416"></a><span id="l66.416" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.417"></a><span id="l66.417" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.418"></a><span id="l66.418" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 2)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.419"></a><span id="l66.419" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 3)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.420"></a><span id="l66.420" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 4)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.421"></a><span id="l66.421" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.422"></a><span id="l66.422" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.423"></a><span id="l66.423" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.424"></a><span id="l66.424" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.425"></a><span id="l66.425" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.426"></a><span id="l66.426">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.427"></a><span id="l66.427">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 1);</span>
<a href="#l66.428"></a><span id="l66.428" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 0)-&gt;tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.429"></a><span id="l66.429" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey1).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.430"></a><span id="l66.430"> </span>
<a href="#l66.431"></a><span id="l66.431">     /* load just subkey 1 but with signature */</span>
<a href="#l66.432"></a><span id="l66.432">     assert_true(load_transferable_subkey(&amp;tskey, MERGE_PATH &quot;key-pub-no-key-subkey-1.pgp&quot;));</span>
<a href="#l66.433"></a><span id="l66.433">     assert_true(rnp_key_store_add_transferable_subkey(key_store, &amp;tskey, key));</span>
<a href="#l66.434"></a><span id="l66.434">     /* try to add it twice */</span>
<a href="#l66.435"></a><span id="l66.435">     assert_true(rnp_key_store_add_transferable_subkey(key_store, &amp;tskey, key));</span>
<a href="#l66.436"></a><span id="l66.436">     transferable_subkey_destroy(&amp;tskey);</span>
<a href="#l66.437"></a><span id="l66.437">     assert_int_equal(rnp_key_store_get_key_count(key_store), 2);</span>
<a href="#l66.438"></a><span id="l66.438">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.439"></a><span id="l66.439">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.440"></a><span id="l66.440">     assert_true(key-&gt;valid);</span>
<a href="#l66.441"></a><span id="l66.441">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.442"></a><span id="l66.442">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.443"></a><span id="l66.443">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l66.444"></a><span id="l66.444">     assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.445"></a><span id="l66.445">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.446"></a><span id="l66.446" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.447"></a><span id="l66.447" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.448"></a><span id="l66.448" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 2)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.449"></a><span id="l66.449" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 3)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.450"></a><span id="l66.450" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 4)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.451"></a><span id="l66.451" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.452"></a><span id="l66.452" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.453"></a><span id="l66.453" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.454"></a><span id="l66.454" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.455"></a><span id="l66.455" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.456"></a><span id="l66.456">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.457"></a><span id="l66.457">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.458"></a><span id="l66.458" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 0)-&gt;tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.459"></a><span id="l66.459" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.460"></a><span id="l66.460" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey1).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.461"></a><span id="l66.461" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(skey1, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.462"></a><span id="l66.462"> </span>
<a href="#l66.463"></a><span id="l66.463">     /* load key + subkey 2 with signature */</span>
<a href="#l66.464"></a><span id="l66.464">     assert_true(load_transferable_key(&amp;tkey, MERGE_PATH &quot;key-pub-subkey-2.pgp&quot;));</span>
<a href="#l66.465"></a><span id="l66.465">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.466"></a><span id="l66.466">     /* try to add it twice */</span>
<a href="#l66.467"></a><span id="l66.467">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.468"></a><span id="l66.468">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.469"></a><span id="l66.469">     assert_int_equal(rnp_key_store_get_key_count(key_store), 3);</span>
<a href="#l66.470"></a><span id="l66.470" class="difflineat">@@ -621,29 +611,29 @@ TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.471"></a><span id="l66.471">     assert_true(key-&gt;valid);</span>
<a href="#l66.472"></a><span id="l66.472">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.473"></a><span id="l66.473">     assert_true(skey2-&gt;valid);</span>
<a href="#l66.474"></a><span id="l66.474">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.475"></a><span id="l66.475">     assert_int_equal(pgp_key_get_subkey_count(key), 2);</span>
<a href="#l66.476"></a><span id="l66.476">     assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.477"></a><span id="l66.477">     assert_true(check_subkey_grip(key, skey2, 1));</span>
<a href="#l66.478"></a><span id="l66.478">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.479"></a><span id="l66.479" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.480"></a><span id="l66.480" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.481"></a><span id="l66.481" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 2)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.482"></a><span id="l66.482" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 3)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.483"></a><span id="l66.483" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 4)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.484"></a><span id="l66.484" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.485"></a><span id="l66.485" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.486"></a><span id="l66.486" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.487"></a><span id="l66.487" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.488"></a><span id="l66.488" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.489"></a><span id="l66.489">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.490"></a><span id="l66.490">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.491"></a><span id="l66.491" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 0)-&gt;tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.492"></a><span id="l66.492" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.493"></a><span id="l66.493" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey1).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.494"></a><span id="l66.494" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(skey1, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.495"></a><span id="l66.495">     assert_int_equal(pgp_key_get_userid_count(skey2), 0);</span>
<a href="#l66.496"></a><span id="l66.496">     assert_int_equal(pgp_key_get_rawpacket_count(skey2), 2);</span>
<a href="#l66.497"></a><span id="l66.497" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey2, 0)-&gt;tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.498"></a><span id="l66.498" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey2, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.499"></a><span id="l66.499" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey2).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.500"></a><span id="l66.500" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(skey2, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.501"></a><span id="l66.501"> </span>
<a href="#l66.502"></a><span id="l66.502">     /* load secret key &amp; subkeys */</span>
<a href="#l66.503"></a><span id="l66.503">     assert_true(load_transferable_key(&amp;tkey, MERGE_PATH &quot;key-sec-no-uid-no-sigs.pgp&quot;));</span>
<a href="#l66.504"></a><span id="l66.504">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.505"></a><span id="l66.505">     /* try to add it twice */</span>
<a href="#l66.506"></a><span id="l66.506">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.507"></a><span id="l66.507">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.508"></a><span id="l66.508">     assert_int_equal(rnp_key_store_get_key_count(key_store), 3);</span>
<a href="#l66.509"></a><span id="l66.509" class="difflineat">@@ -653,29 +643,29 @@ TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.510"></a><span id="l66.510">     assert_true(key-&gt;valid);</span>
<a href="#l66.511"></a><span id="l66.511">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.512"></a><span id="l66.512">     assert_true(skey2-&gt;valid);</span>
<a href="#l66.513"></a><span id="l66.513">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.514"></a><span id="l66.514">     assert_int_equal(pgp_key_get_subkey_count(key), 2);</span>
<a href="#l66.515"></a><span id="l66.515">     assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.516"></a><span id="l66.516">     assert_true(check_subkey_grip(key, skey2, 1));</span>
<a href="#l66.517"></a><span id="l66.517">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.518"></a><span id="l66.518" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.519"></a><span id="l66.519" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.520"></a><span id="l66.520" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 2)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.521"></a><span id="l66.521" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 3)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.522"></a><span id="l66.522" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 4)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.523"></a><span id="l66.523" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.524"></a><span id="l66.524" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.525"></a><span id="l66.525" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.526"></a><span id="l66.526" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.527"></a><span id="l66.527" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.528"></a><span id="l66.528">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.529"></a><span id="l66.529">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.530"></a><span id="l66.530" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 0)-&gt;tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.531"></a><span id="l66.531" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.532"></a><span id="l66.532" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey1).tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.533"></a><span id="l66.533" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(skey1, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.534"></a><span id="l66.534">     assert_int_equal(pgp_key_get_userid_count(skey2), 0);</span>
<a href="#l66.535"></a><span id="l66.535">     assert_int_equal(pgp_key_get_rawpacket_count(skey2), 2);</span>
<a href="#l66.536"></a><span id="l66.536" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey2, 0)-&gt;tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.537"></a><span id="l66.537" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey2, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.538"></a><span id="l66.538" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey2).tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.539"></a><span id="l66.539" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(skey2, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.540"></a><span id="l66.540"> </span>
<a href="#l66.541"></a><span id="l66.541">     assert_true(pgp_key_unlock(key, &amp;provider));</span>
<a href="#l66.542"></a><span id="l66.542">     assert_true(pgp_key_unlock(skey1, &amp;provider));</span>
<a href="#l66.543"></a><span id="l66.543">     assert_true(pgp_key_unlock(skey2, &amp;provider));</span>
<a href="#l66.544"></a><span id="l66.544"> </span>
<a href="#l66.545"></a><span id="l66.545">     /* load the whole public + secret key */</span>
<a href="#l66.546"></a><span id="l66.546">     assert_true(load_transferable_key(&amp;tkey, MERGE_PATH &quot;key-pub.asc&quot;));</span>
<a href="#l66.547"></a><span id="l66.547">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.548"></a><span id="l66.548" class="difflineat">@@ -690,114 +680,112 @@ TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.549"></a><span id="l66.549">     assert_true(key-&gt;valid);</span>
<a href="#l66.550"></a><span id="l66.550">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.551"></a><span id="l66.551">     assert_true(skey2-&gt;valid);</span>
<a href="#l66.552"></a><span id="l66.552">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.553"></a><span id="l66.553">     assert_int_equal(pgp_key_get_subkey_count(key), 2);</span>
<a href="#l66.554"></a><span id="l66.554">     assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.555"></a><span id="l66.555">     assert_true(check_subkey_grip(key, skey2, 1));</span>
<a href="#l66.556"></a><span id="l66.556">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.557"></a><span id="l66.557" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.558"></a><span id="l66.558" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.559"></a><span id="l66.559" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 2)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.560"></a><span id="l66.560" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 3)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.561"></a><span id="l66.561" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 4)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.562"></a><span id="l66.562" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.563"></a><span id="l66.563" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.564"></a><span id="l66.564" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.565"></a><span id="l66.565" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.566"></a><span id="l66.566" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.567"></a><span id="l66.567">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.568"></a><span id="l66.568">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.569"></a><span id="l66.569" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 0)-&gt;tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.570"></a><span id="l66.570" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.571"></a><span id="l66.571" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey1).tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.572"></a><span id="l66.572" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(skey1, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.573"></a><span id="l66.573">     assert_int_equal(pgp_key_get_userid_count(skey2), 0);</span>
<a href="#l66.574"></a><span id="l66.574">     assert_int_equal(pgp_key_get_rawpacket_count(skey2), 2);</span>
<a href="#l66.575"></a><span id="l66.575" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey2, 0)-&gt;tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.576"></a><span id="l66.576" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey2, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.577"></a><span id="l66.577" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey2).tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.578"></a><span id="l66.578" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(skey2, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.579"></a><span id="l66.579">     assert_true(key == rnp_tests_key_search(key_store, &quot;key-merge-uid-1&quot;));</span>
<a href="#l66.580"></a><span id="l66.580">     assert_true(key == rnp_tests_key_search(key_store, &quot;key-merge-uid-2&quot;));</span>
<a href="#l66.581"></a><span id="l66.581"> </span>
<a href="#l66.582"></a><span id="l66.582" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l66.583"></a><span id="l66.583" class="difflineplus">+    delete key_store;</span>
<a href="#l66.584"></a><span id="l66.584"> }</span>
<a href="#l66.585"></a><span id="l66.585"> </span>
<a href="#l66.586"></a><span id="l66.586"> TEST_F(rnp_tests, test_load_public_from_secret)</span>
<a href="#l66.587"></a><span id="l66.587"> {</span>
<a href="#l66.588"></a><span id="l66.588">     pgp_key_t *      key, *skey1, *skey2, keycp = {};</span>
<a href="#l66.589"></a><span id="l66.589">     uint8_t          keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.590"></a><span id="l66.590">     uint8_t          sub1id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.591"></a><span id="l66.591">     uint8_t          sub2id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.592"></a><span id="l66.592">     rnp_key_store_t *secstore, *pubstore;</span>
<a href="#l66.593"></a><span id="l66.593"> </span>
<a href="#l66.594"></a><span id="l66.594" class="difflineminus">-    assert_non_null(secstore = rnp_key_store_new(PGP_KEY_STORE_GPG, MERGE_PATH &quot;key-sec.asc&quot;));</span>
<a href="#l66.595"></a><span id="l66.595" class="difflineplus">+    secstore = new rnp_key_store_t(PGP_KEY_STORE_GPG, MERGE_PATH &quot;key-sec.asc&quot;);</span>
<a href="#l66.596"></a><span id="l66.596">     assert_true(rnp_key_store_load_from_path(secstore, NULL));</span>
<a href="#l66.597"></a><span id="l66.597" class="difflineminus">-    assert_non_null(pubstore = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;pubring.gpg&quot;));</span>
<a href="#l66.598"></a><span id="l66.598" class="difflineplus">+    pubstore = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;pubring.gpg&quot;);</span>
<a href="#l66.599"></a><span id="l66.599"> </span>
<a href="#l66.600"></a><span id="l66.600">     assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.601"></a><span id="l66.601">     assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, sub1id, sizeof(sub1id)));</span>
<a href="#l66.602"></a><span id="l66.602">     assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, sub2id, sizeof(sub2id)));</span>
<a href="#l66.603"></a><span id="l66.603"> </span>
<a href="#l66.604"></a><span id="l66.604">     assert_non_null(key = rnp_key_store_get_key_by_id(secstore, keyid, NULL));</span>
<a href="#l66.605"></a><span id="l66.605">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(secstore, sub1id, NULL));</span>
<a href="#l66.606"></a><span id="l66.606">     assert_non_null(skey2 = rnp_key_store_get_key_by_id(secstore, sub2id, NULL));</span>
<a href="#l66.607"></a><span id="l66.607"> </span>
<a href="#l66.608"></a><span id="l66.608">     /* copy the secret key */</span>
<a href="#l66.609"></a><span id="l66.609">     assert_rnp_success(pgp_key_copy(&amp;keycp, key, false));</span>
<a href="#l66.610"></a><span id="l66.610">     assert_true(pgp_key_is_secret(&amp;keycp));</span>
<a href="#l66.611"></a><span id="l66.611">     assert_int_equal(pgp_key_get_subkey_count(&amp;keycp), 2);</span>
<a href="#l66.612"></a><span id="l66.612" class="difflineminus">-    assert_false(</span>
<a href="#l66.613"></a><span id="l66.613" class="difflineminus">-      memcmp(pgp_key_get_subkey_grip(&amp;keycp, 0), pgp_key_get_grip(skey1), PGP_KEY_GRIP_SIZE));</span>
<a href="#l66.614"></a><span id="l66.614" class="difflineminus">-    assert_false(</span>
<a href="#l66.615"></a><span id="l66.615" class="difflineminus">-      memcmp(pgp_key_get_subkey_grip(&amp;keycp, 1), pgp_key_get_grip(skey2), PGP_KEY_GRIP_SIZE));</span>
<a href="#l66.616"></a><span id="l66.616" class="difflineminus">-    assert_false(memcmp(pgp_key_get_grip(&amp;keycp), pgp_key_get_grip(key), PGP_KEY_GRIP_SIZE));</span>
<a href="#l66.617"></a><span id="l66.617" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(&amp;keycp, 0)-&gt;tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.618"></a><span id="l66.618" class="difflineplus">+    assert_true(pgp_key_get_subkey_grip(&amp;keycp, 0) == pgp_key_get_grip(skey1));</span>
<a href="#l66.619"></a><span id="l66.619" class="difflineplus">+    assert_true(pgp_key_get_subkey_grip(&amp;keycp, 1) == pgp_key_get_grip(skey2));</span>
<a href="#l66.620"></a><span id="l66.620" class="difflineplus">+    assert_true(pgp_key_get_grip(&amp;keycp) == pgp_key_get_grip(key));</span>
<a href="#l66.621"></a><span id="l66.621" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(&amp;keycp).tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.622"></a><span id="l66.622"> </span>
<a href="#l66.623"></a><span id="l66.623">     /* copy the public part */</span>
<a href="#l66.624"></a><span id="l66.624">     assert_rnp_success(pgp_key_copy(&amp;keycp, key, true));</span>
<a href="#l66.625"></a><span id="l66.625">     assert_false(pgp_key_is_secret(&amp;keycp));</span>
<a href="#l66.626"></a><span id="l66.626">     assert_int_equal(pgp_key_get_subkey_count(&amp;keycp), 2);</span>
<a href="#l66.627"></a><span id="l66.627">     assert_true(check_subkey_grip(&amp;keycp, skey1, 0));</span>
<a href="#l66.628"></a><span id="l66.628">     assert_true(check_subkey_grip(&amp;keycp, skey2, 1));</span>
<a href="#l66.629"></a><span id="l66.629" class="difflineminus">-    assert_false(memcmp(pgp_key_get_grip(&amp;keycp), pgp_key_get_grip(key), PGP_KEY_GRIP_SIZE));</span>
<a href="#l66.630"></a><span id="l66.630" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(&amp;keycp, 0)-&gt;tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.631"></a><span id="l66.631" class="difflineplus">+    assert_true(pgp_key_get_grip(&amp;keycp) == pgp_key_get_grip(key));</span>
<a href="#l66.632"></a><span id="l66.632" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(&amp;keycp).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.633"></a><span id="l66.633">     assert_null(pgp_key_get_pkt(&amp;keycp)-&gt;sec_data);</span>
<a href="#l66.634"></a><span id="l66.634">     assert_int_equal(pgp_key_get_pkt(&amp;keycp)-&gt;sec_len, 0);</span>
<a href="#l66.635"></a><span id="l66.635">     assert_false(pgp_key_get_pkt(&amp;keycp)-&gt;material.secret);</span>
<a href="#l66.636"></a><span id="l66.636">     rnp_key_store_add_key(pubstore, &amp;keycp);</span>
<a href="#l66.637"></a><span id="l66.637">     /* subkey 1 */</span>
<a href="#l66.638"></a><span id="l66.638">     assert_rnp_success(pgp_key_copy(&amp;keycp, skey1, true));</span>
<a href="#l66.639"></a><span id="l66.639">     assert_false(pgp_key_is_secret(&amp;keycp));</span>
<a href="#l66.640"></a><span id="l66.640">     assert_int_equal(pgp_key_get_subkey_count(&amp;keycp), 0);</span>
<a href="#l66.641"></a><span id="l66.641">     assert_true(check_subkey_grip(key, &amp;keycp, 0));</span>
<a href="#l66.642"></a><span id="l66.642" class="difflineminus">-    assert_false(memcmp(pgp_key_get_grip(&amp;keycp), pgp_key_get_grip(skey1), PGP_KEY_GRIP_SIZE));</span>
<a href="#l66.643"></a><span id="l66.643" class="difflineplus">+    assert_true(pgp_key_get_grip(&amp;keycp) == pgp_key_get_grip(skey1));</span>
<a href="#l66.644"></a><span id="l66.644">     assert_false(memcmp(pgp_key_get_keyid(&amp;keycp), sub1id, PGP_KEY_ID_SIZE));</span>
<a href="#l66.645"></a><span id="l66.645" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(&amp;keycp, 0)-&gt;tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.646"></a><span id="l66.646" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(&amp;keycp).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.647"></a><span id="l66.647">     assert_null(pgp_key_get_pkt(&amp;keycp)-&gt;sec_data);</span>
<a href="#l66.648"></a><span id="l66.648">     assert_int_equal(pgp_key_get_pkt(&amp;keycp)-&gt;sec_len, 0);</span>
<a href="#l66.649"></a><span id="l66.649">     assert_false(pgp_key_get_pkt(&amp;keycp)-&gt;material.secret);</span>
<a href="#l66.650"></a><span id="l66.650">     rnp_key_store_add_key(pubstore, &amp;keycp);</span>
<a href="#l66.651"></a><span id="l66.651">     /* subkey 2 */</span>
<a href="#l66.652"></a><span id="l66.652">     assert_rnp_success(pgp_key_copy(&amp;keycp, skey2, true));</span>
<a href="#l66.653"></a><span id="l66.653">     assert_false(pgp_key_is_secret(&amp;keycp));</span>
<a href="#l66.654"></a><span id="l66.654">     assert_int_equal(pgp_key_get_subkey_count(&amp;keycp), 0);</span>
<a href="#l66.655"></a><span id="l66.655">     assert_true(check_subkey_grip(key, &amp;keycp, 1));</span>
<a href="#l66.656"></a><span id="l66.656" class="difflineminus">-    assert_false(memcmp(pgp_key_get_grip(&amp;keycp), pgp_key_get_grip(skey2), PGP_KEY_GRIP_SIZE));</span>
<a href="#l66.657"></a><span id="l66.657" class="difflineplus">+    assert_true(pgp_key_get_grip(&amp;keycp) == pgp_key_get_grip(skey2));</span>
<a href="#l66.658"></a><span id="l66.658">     assert_false(memcmp(pgp_key_get_keyid(&amp;keycp), sub2id, PGP_KEY_ID_SIZE));</span>
<a href="#l66.659"></a><span id="l66.659" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(&amp;keycp, 0)-&gt;tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.660"></a><span id="l66.660" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(&amp;keycp).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.661"></a><span id="l66.661">     assert_null(pgp_key_get_pkt(&amp;keycp)-&gt;sec_data);</span>
<a href="#l66.662"></a><span id="l66.662">     assert_int_equal(pgp_key_get_pkt(&amp;keycp)-&gt;sec_len, 0);</span>
<a href="#l66.663"></a><span id="l66.663">     assert_false(pgp_key_get_pkt(&amp;keycp)-&gt;material.secret);</span>
<a href="#l66.664"></a><span id="l66.664">     rnp_key_store_add_key(pubstore, &amp;keycp);</span>
<a href="#l66.665"></a><span id="l66.665">     /* save pubring */</span>
<a href="#l66.666"></a><span id="l66.666">     assert_true(rnp_key_store_write_to_path(pubstore));</span>
<a href="#l66.667"></a><span id="l66.667" class="difflineminus">-    rnp_key_store_free(pubstore);</span>
<a href="#l66.668"></a><span id="l66.668" class="difflineplus">+    delete pubstore;</span>
<a href="#l66.669"></a><span id="l66.669">     /* reload */</span>
<a href="#l66.670"></a><span id="l66.670" class="difflineminus">-    assert_non_null(pubstore = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;pubring.gpg&quot;));</span>
<a href="#l66.671"></a><span id="l66.671" class="difflineplus">+    pubstore = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;pubring.gpg&quot;);</span>
<a href="#l66.672"></a><span id="l66.672">     assert_true(rnp_key_store_load_from_path(pubstore, NULL));</span>
<a href="#l66.673"></a><span id="l66.673">     assert_non_null(key = rnp_key_store_get_key_by_id(pubstore, keyid, NULL));</span>
<a href="#l66.674"></a><span id="l66.674">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(pubstore, sub1id, NULL));</span>
<a href="#l66.675"></a><span id="l66.675">     assert_non_null(skey2 = rnp_key_store_get_key_by_id(pubstore, sub2id, NULL));</span>
<a href="#l66.676"></a><span id="l66.676"> </span>
<a href="#l66.677"></a><span id="l66.677" class="difflineminus">-    rnp_key_store_free(pubstore);</span>
<a href="#l66.678"></a><span id="l66.678" class="difflineminus">-    rnp_key_store_free(secstore);</span>
<a href="#l66.679"></a><span id="l66.679" class="difflineplus">+    delete pubstore;</span>
<a href="#l66.680"></a><span id="l66.680" class="difflineplus">+    delete secstore;</span>
<a href="#l66.681"></a><span id="l66.681"> }</span>
<a href="#l66.682"></a><span id="l66.682"> </span>
<a href="#l66.683"></a><span id="l66.683"> TEST_F(rnp_tests, test_key_import)</span>
<a href="#l66.684"></a><span id="l66.684"> {</span>
<a href="#l66.685"></a><span id="l66.685">     cli_rnp_t                  rnp = {};</span>
<a href="#l66.686"></a><span id="l66.686">     pgp_transferable_key_t     tkey = {};</span>
<a href="#l66.687"></a><span id="l66.687">     pgp_transferable_subkey_t *tskey = NULL;</span>
<a href="#l66.688"></a><span id="l66.688">     pgp_transferable_userid_t *tuid = NULL;</span>
<a href="#l66.689"></a><span id="l66.689" class="difflineat">@@ -985,64 +973,63 @@ TEST_F(rnp_tests, test_key_import)</span>
<a href="#l66.690"></a><span id="l66.690"> TEST_F(rnp_tests, test_load_subkey)</span>
<a href="#l66.691"></a><span id="l66.691"> {</span>
<a href="#l66.692"></a><span id="l66.692">     pgp_key_t *      key, *skey1, *skey2;</span>
<a href="#l66.693"></a><span id="l66.693">     uint8_t          keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.694"></a><span id="l66.694">     uint8_t          sub1id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.695"></a><span id="l66.695">     uint8_t          sub2id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.696"></a><span id="l66.696">     rnp_key_store_t *key_store;</span>
<a href="#l66.697"></a><span id="l66.697"> </span>
<a href="#l66.698"></a><span id="l66.698" class="difflineminus">-    key_store = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l66.699"></a><span id="l66.699" class="difflineminus">-    assert_non_null(key_store);</span>
<a href="#l66.700"></a><span id="l66.700" class="difflineplus">+    key_store = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l66.701"></a><span id="l66.701">     assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.702"></a><span id="l66.702">     assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, sub1id, sizeof(sub1id)));</span>
<a href="#l66.703"></a><span id="l66.703">     assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, sub2id, sizeof(sub2id)));</span>
<a href="#l66.704"></a><span id="l66.704"> </span>
<a href="#l66.705"></a><span id="l66.705">     /* load first subkey with signature */</span>
<a href="#l66.706"></a><span id="l66.706">     assert_true(load_keystore(key_store, MERGE_PATH &quot;key-pub-just-subkey-1.pgp&quot;));</span>
<a href="#l66.707"></a><span id="l66.707">     assert_int_equal(rnp_key_store_get_key_count(key_store), 1);</span>
<a href="#l66.708"></a><span id="l66.708">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.709"></a><span id="l66.709">     assert_false(skey1-&gt;valid);</span>
<a href="#l66.710"></a><span id="l66.710">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.711"></a><span id="l66.711" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 0)-&gt;tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.712"></a><span id="l66.712" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey1, 1)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.713"></a><span id="l66.713" class="difflineminus">-    assert_null(pgp_key_get_primary_grip(skey1));</span>
<a href="#l66.714"></a><span id="l66.714" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey1).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.715"></a><span id="l66.715" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(skey1, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.716"></a><span id="l66.716" class="difflineplus">+    assert_false(pgp_key_has_primary_grip(skey1));</span>
<a href="#l66.717"></a><span id="l66.717"> </span>
<a href="#l66.718"></a><span id="l66.718">     /* load second subkey, without signature */</span>
<a href="#l66.719"></a><span id="l66.719">     assert_true(load_keystore(key_store, MERGE_PATH &quot;key-pub-just-subkey-2-no-sigs.pgp&quot;));</span>
<a href="#l66.720"></a><span id="l66.720">     assert_int_equal(rnp_key_store_get_key_count(key_store), 2);</span>
<a href="#l66.721"></a><span id="l66.721">     assert_non_null(skey2 = rnp_key_store_get_key_by_id(key_store, sub2id, NULL));</span>
<a href="#l66.722"></a><span id="l66.722">     assert_false(skey2-&gt;valid);</span>
<a href="#l66.723"></a><span id="l66.723">     assert_int_equal(pgp_key_get_rawpacket_count(skey2), 1);</span>
<a href="#l66.724"></a><span id="l66.724" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(skey2, 0)-&gt;tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.725"></a><span id="l66.725" class="difflineminus">-    assert_null(pgp_key_get_primary_grip(skey2));</span>
<a href="#l66.726"></a><span id="l66.726" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(skey2).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.727"></a><span id="l66.727" class="difflineplus">+    assert_false(pgp_key_has_primary_grip(skey2));</span>
<a href="#l66.728"></a><span id="l66.728">     assert_false(skey1 == skey2);</span>
<a href="#l66.729"></a><span id="l66.729"> </span>
<a href="#l66.730"></a><span id="l66.730">     /* load primary key without subkey signatures */</span>
<a href="#l66.731"></a><span id="l66.731">     assert_true(load_keystore(key_store, MERGE_PATH &quot;key-pub-uid-1.pgp&quot;));</span>
<a href="#l66.732"></a><span id="l66.732">     assert_int_equal(rnp_key_store_get_key_count(key_store), 3);</span>
<a href="#l66.733"></a><span id="l66.733">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.734"></a><span id="l66.734">     assert_true(key-&gt;valid);</span>
<a href="#l66.735"></a><span id="l66.735">     assert_int_equal(pgp_key_get_rawpacket_count(key), 3);</span>
<a href="#l66.736"></a><span id="l66.736" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 0)-&gt;tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.737"></a><span id="l66.737" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 1)-&gt;tag, PGP_PKT_USER_ID);</span>
<a href="#l66.738"></a><span id="l66.738" class="difflineminus">-    assert_int_equal(pgp_key_get_rawpacket(key, 2)-&gt;tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.739"></a><span id="l66.739" class="difflineplus">+    assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.740"></a><span id="l66.740" class="difflineplus">+    assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.741"></a><span id="l66.741" class="difflineplus">+    assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.742"></a><span id="l66.742">     assert_true(skey1 == rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.743"></a><span id="l66.743">     assert_true(skey2 == rnp_key_store_get_key_by_id(key_store, sub2id, NULL));</span>
<a href="#l66.744"></a><span id="l66.744" class="difflineminus">-    assert_non_null(pgp_key_get_primary_grip(skey1));</span>
<a href="#l66.745"></a><span id="l66.745" class="difflineplus">+    assert_true(pgp_key_has_primary_grip(skey1));</span>
<a href="#l66.746"></a><span id="l66.746">     assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.747"></a><span id="l66.747">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l66.748"></a><span id="l66.748">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.749"></a><span id="l66.749">     assert_false(skey2-&gt;valid);</span>
<a href="#l66.750"></a><span id="l66.750"> </span>
<a href="#l66.751"></a><span id="l66.751">     /* load second subkey with signature */</span>
<a href="#l66.752"></a><span id="l66.752">     assert_true(load_keystore(key_store, MERGE_PATH &quot;key-pub-just-subkey-2.pgp&quot;));</span>
<a href="#l66.753"></a><span id="l66.753">     assert_int_equal(rnp_key_store_get_key_count(key_store), 3);</span>
<a href="#l66.754"></a><span id="l66.754">     assert_true(key == rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.755"></a><span id="l66.755">     assert_true(skey1 == rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.756"></a><span id="l66.756">     assert_true(skey2 == rnp_key_store_get_key_by_id(key_store, sub2id, NULL));</span>
<a href="#l66.757"></a><span id="l66.757" class="difflineminus">-    assert_non_null(pgp_key_get_primary_grip(skey2));</span>
<a href="#l66.758"></a><span id="l66.758" class="difflineplus">+    assert_true(pgp_key_has_primary_grip(skey2));</span>
<a href="#l66.759"></a><span id="l66.759">     assert_true(check_subkey_grip(key, skey2, 1));</span>
<a href="#l66.760"></a><span id="l66.760">     assert_int_equal(pgp_key_get_subkey_count(key), 2);</span>
<a href="#l66.761"></a><span id="l66.761">     assert_true(skey2-&gt;valid);</span>
<a href="#l66.762"></a><span id="l66.762"> </span>
<a href="#l66.763"></a><span id="l66.763" class="difflineminus">-    rnp_key_store_free(key_store);</span>
<a href="#l66.764"></a><span id="l66.764" class="difflineplus">+    delete key_store;</span>
<a href="#l66.765"></a><span id="l66.765"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l67.1"></a><span id="l67.1">new file mode 100644</span>
<a href="#l67.2"></a><span id="l67.2" class="difflineminus">--- /dev/null</span>
<a href="#l67.3"></a><span id="l67.3" class="difflineplus">+++ b/third_party/rnp/src/tests/log-switch.cpp</span>
<a href="#l67.4"></a><span id="l67.4" class="difflineat">@@ -0,0 +1,91 @@</span>
<a href="#l67.5"></a><span id="l67.5" class="difflineplus">+/*</span>
<a href="#l67.6"></a><span id="l67.6" class="difflineplus">+ * Copyright (c) 2018-2019 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l67.7"></a><span id="l67.7" class="difflineplus">+ * All rights reserved.</span>
<a href="#l67.8"></a><span id="l67.8" class="difflineplus">+ *</span>
<a href="#l67.9"></a><span id="l67.9" class="difflineplus">+ * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l67.10"></a><span id="l67.10" class="difflineplus">+ * are permitted provided that the following conditions are met:</span>
<a href="#l67.11"></a><span id="l67.11" class="difflineplus">+ *</span>
<a href="#l67.12"></a><span id="l67.12" class="difflineplus">+ * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l67.13"></a><span id="l67.13" class="difflineplus">+ *     this list of conditions and the following disclaimer.</span>
<a href="#l67.14"></a><span id="l67.14" class="difflineplus">+ *</span>
<a href="#l67.15"></a><span id="l67.15" class="difflineplus">+ * 2.  Redistributions in binary form must reproduce the above copyright notice,</span>
<a href="#l67.16"></a><span id="l67.16" class="difflineplus">+ *     this list of conditions and the following disclaimer in the documentation</span>
<a href="#l67.17"></a><span id="l67.17" class="difflineplus">+ *     and/or other materials provided with the distribution.</span>
<a href="#l67.18"></a><span id="l67.18" class="difflineplus">+ *</span>
<a href="#l67.19"></a><span id="l67.19" class="difflineplus">+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a href="#l67.20"></a><span id="l67.20" class="difflineplus">+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a href="#l67.21"></a><span id="l67.21" class="difflineplus">+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a href="#l67.22"></a><span id="l67.22" class="difflineplus">+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<a href="#l67.23"></a><span id="l67.23" class="difflineplus">+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a href="#l67.24"></a><span id="l67.24" class="difflineplus">+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a href="#l67.25"></a><span id="l67.25" class="difflineplus">+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a href="#l67.26"></a><span id="l67.26" class="difflineplus">+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a href="#l67.27"></a><span id="l67.27" class="difflineplus">+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a href="#l67.28"></a><span id="l67.28" class="difflineplus">+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l67.29"></a><span id="l67.29" class="difflineplus">+ */</span>
<a href="#l67.30"></a><span id="l67.30" class="difflineplus">+</span>
<a href="#l67.31"></a><span id="l67.31" class="difflineplus">+#include &quot;rnp_tests.h&quot;</span>
<a href="#l67.32"></a><span id="l67.32" class="difflineplus">+#include &quot;support.h&quot;</span>
<a href="#l67.33"></a><span id="l67.33" class="difflineplus">+</span>
<a href="#l67.34"></a><span id="l67.34" class="difflineplus">+static const char LOGTEST_FILENAME[] = &quot;logtest.log&quot;;</span>
<a href="#l67.35"></a><span id="l67.35" class="difflineplus">+</span>
<a href="#l67.36"></a><span id="l67.36" class="difflineplus">+TEST_F(rnp_tests, test_log_switch)</span>
<a href="#l67.37"></a><span id="l67.37" class="difflineplus">+{</span>
<a href="#l67.38"></a><span id="l67.38" class="difflineplus">+    FILE *stream = fopen(LOGTEST_FILENAME, &quot;w&quot;);</span>
<a href="#l67.39"></a><span id="l67.39" class="difflineplus">+    assert_non_null(stream);</span>
<a href="#l67.40"></a><span id="l67.40" class="difflineplus">+    bool saved_rnp_log_switch = rnp_log_switch();</span>
<a href="#l67.41"></a><span id="l67.41" class="difflineplus">+</span>
<a href="#l67.42"></a><span id="l67.42" class="difflineplus">+    // reset _rnp_log_switch manually</span>
<a href="#l67.43"></a><span id="l67.43" class="difflineplus">+    set_rnp_log_switch(0);</span>
<a href="#l67.44"></a><span id="l67.44" class="difflineplus">+    RNP_LOG_FD(stream, &quot;x&quot;);</span>
<a href="#l67.45"></a><span id="l67.45" class="difflineplus">+    fflush(stream);</span>
<a href="#l67.46"></a><span id="l67.46" class="difflineplus">+    assert_int_equal(0, ftell(stream)); // nothing was written</span>
<a href="#l67.47"></a><span id="l67.47" class="difflineplus">+</span>
<a href="#l67.48"></a><span id="l67.48" class="difflineplus">+    // enable _rnp_log_switch manually</span>
<a href="#l67.49"></a><span id="l67.49" class="difflineplus">+    set_rnp_log_switch(1);</span>
<a href="#l67.50"></a><span id="l67.50" class="difflineplus">+    RNP_LOG_FD(stream, &quot;x&quot;);</span>
<a href="#l67.51"></a><span id="l67.51" class="difflineplus">+    fflush(stream);</span>
<a href="#l67.52"></a><span id="l67.52" class="difflineplus">+    assert_int_not_equal(0, ftell(stream)); // something was written</span>
<a href="#l67.53"></a><span id="l67.53" class="difflineplus">+</span>
<a href="#l67.54"></a><span id="l67.54" class="difflineplus">+    fclose(stream);</span>
<a href="#l67.55"></a><span id="l67.55" class="difflineplus">+    assert_int_equal(0, unlink(LOGTEST_FILENAME));</span>
<a href="#l67.56"></a><span id="l67.56" class="difflineplus">+</span>
<a href="#l67.57"></a><span id="l67.57" class="difflineplus">+    stream = fopen(LOGTEST_FILENAME, &quot;w&quot;);</span>
<a href="#l67.58"></a><span id="l67.58" class="difflineplus">+    assert_non_null(stream);</span>
<a href="#l67.59"></a><span id="l67.59" class="difflineplus">+</span>
<a href="#l67.60"></a><span id="l67.60" class="difflineplus">+    const char *saved_env = getenv(RNP_LOG_CONSOLE);</span>
<a href="#l67.61"></a><span id="l67.61" class="difflineplus">+</span>
<a href="#l67.62"></a><span id="l67.62" class="difflineplus">+    // let _rnp_log_switch initialize to 0 from unset environment variable</span>
<a href="#l67.63"></a><span id="l67.63" class="difflineplus">+    assert_int_equal(0, unsetenv(RNP_LOG_CONSOLE));</span>
<a href="#l67.64"></a><span id="l67.64" class="difflineplus">+    set_rnp_log_switch(-1);</span>
<a href="#l67.65"></a><span id="l67.65" class="difflineplus">+    RNP_LOG_FD(stream, &quot;x&quot;);</span>
<a href="#l67.66"></a><span id="l67.66" class="difflineplus">+    fflush(stream);</span>
<a href="#l67.67"></a><span id="l67.67" class="difflineplus">+    assert_int_equal(0, ftell(stream)); // nothing was written</span>
<a href="#l67.68"></a><span id="l67.68" class="difflineplus">+</span>
<a href="#l67.69"></a><span id="l67.69" class="difflineplus">+    // let _rnp_log_switch initialize to 0 from environment variable &quot;0&quot;</span>
<a href="#l67.70"></a><span id="l67.70" class="difflineplus">+    setenv(RNP_LOG_CONSOLE, &quot;0&quot;, 1);</span>
<a href="#l67.71"></a><span id="l67.71" class="difflineplus">+    set_rnp_log_switch(-1);</span>
<a href="#l67.72"></a><span id="l67.72" class="difflineplus">+    RNP_LOG_FD(stream, &quot;x&quot;);</span>
<a href="#l67.73"></a><span id="l67.73" class="difflineplus">+    fflush(stream);</span>
<a href="#l67.74"></a><span id="l67.74" class="difflineplus">+    assert_int_equal(0, ftell(stream)); // nothing was written</span>
<a href="#l67.75"></a><span id="l67.75" class="difflineplus">+</span>
<a href="#l67.76"></a><span id="l67.76" class="difflineplus">+    // let _rnp_log_switch initialize to 1 from environment variable &quot;1&quot;</span>
<a href="#l67.77"></a><span id="l67.77" class="difflineplus">+    setenv(RNP_LOG_CONSOLE, &quot;1&quot;, 1);</span>
<a href="#l67.78"></a><span id="l67.78" class="difflineplus">+    set_rnp_log_switch(-1);</span>
<a href="#l67.79"></a><span id="l67.79" class="difflineplus">+    RNP_LOG_FD(stream, &quot;x&quot;);</span>
<a href="#l67.80"></a><span id="l67.80" class="difflineplus">+    fflush(stream);</span>
<a href="#l67.81"></a><span id="l67.81" class="difflineplus">+    assert_int_not_equal(0, ftell(stream)); // something was written</span>
<a href="#l67.82"></a><span id="l67.82" class="difflineplus">+</span>
<a href="#l67.83"></a><span id="l67.83" class="difflineplus">+    // restore environment variable</span>
<a href="#l67.84"></a><span id="l67.84" class="difflineplus">+    if (saved_env) {</span>
<a href="#l67.85"></a><span id="l67.85" class="difflineplus">+        assert_int_equal(0, setenv(RNP_LOG_CONSOLE, saved_env, 1));</span>
<a href="#l67.86"></a><span id="l67.86" class="difflineplus">+    } else {</span>
<a href="#l67.87"></a><span id="l67.87" class="difflineplus">+        unsetenv(RNP_LOG_CONSOLE);</span>
<a href="#l67.88"></a><span id="l67.88" class="difflineplus">+    }</span>
<a href="#l67.89"></a><span id="l67.89" class="difflineplus">+</span>
<a href="#l67.90"></a><span id="l67.90" class="difflineplus">+    // restore _rnp_log_switch</span>
<a href="#l67.91"></a><span id="l67.91" class="difflineplus">+    set_rnp_log_switch(saved_rnp_log_switch ? 1 : 0);</span>
<a href="#l67.92"></a><span id="l67.92" class="difflineplus">+</span>
<a href="#l67.93"></a><span id="l67.93" class="difflineplus">+    fclose(stream);</span>
<a href="#l67.94"></a><span id="l67.94" class="difflineplus">+    assert_int_equal(0, unlink(LOGTEST_FILENAME));</span>
<a href="#l67.95"></a><span id="l67.95" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l68.1"></a><span id="l68.1" class="difflineminus">--- a/third_party/rnp/src/tests/rnp_tests.h</span>
<a href="#l68.2"></a><span id="l68.2" class="difflineplus">+++ b/third_party/rnp/src/tests/rnp_tests.h</span>
<a href="#l68.3"></a><span id="l68.3" class="difflineat">@@ -282,16 +282,20 @@ void test_ffi_secret_sig_import(void **s</span>
<a href="#l68.4"></a><span id="l68.4"> void test_ffi_rnp_request_password(void **state);</span>
<a href="#l68.5"></a><span id="l68.5"> </span>
<a href="#l68.6"></a><span id="l68.6"> void test_ffi_key_revoke(void **state);</span>
<a href="#l68.7"></a><span id="l68.7"> </span>
<a href="#l68.8"></a><span id="l68.8"> void test_ffi_set_key_expiry(void **state);</span>
<a href="#l68.9"></a><span id="l68.9"> </span>
<a href="#l68.10"></a><span id="l68.10"> void test_ffi_mdc_8k_boundary(void **state);</span>
<a href="#l68.11"></a><span id="l68.11"> </span>
<a href="#l68.12"></a><span id="l68.12" class="difflineplus">+void test_ffi_decrypt_wrong_mpi_bits(void **state);</span>
<a href="#l68.13"></a><span id="l68.13" class="difflineplus">+</span>
<a href="#l68.14"></a><span id="l68.14" class="difflineplus">+void test_ffi_key_import_edge_cases(void **state);</span>
<a href="#l68.15"></a><span id="l68.15" class="difflineplus">+</span>
<a href="#l68.16"></a><span id="l68.16"> void test_dsa_roundtrip(void **state);</span>
<a href="#l68.17"></a><span id="l68.17"> </span>
<a href="#l68.18"></a><span id="l68.18"> void test_dsa_verify_negative(void **state);</span>
<a href="#l68.19"></a><span id="l68.19"> </span>
<a href="#l68.20"></a><span id="l68.20"> void test_stream_memory(void **state);</span>
<a href="#l68.21"></a><span id="l68.21"> </span>
<a href="#l68.22"></a><span id="l68.22"> void test_stream_memory_discard(void **state);</span>
<a href="#l68.23"></a><span id="l68.23"> </span>
<a href="#l68.24"></a><span id="l68.24" class="difflineat">@@ -356,16 +360,18 @@ void test_partial_length_zero_last_chunk</span>
<a href="#l68.25"></a><span id="l68.25"> void test_partial_length_largest(void **state);</span>
<a href="#l68.26"></a><span id="l68.26"> </span>
<a href="#l68.27"></a><span id="l68.27"> void test_partial_length_first_packet_length(void **state);</span>
<a href="#l68.28"></a><span id="l68.28"> </span>
<a href="#l68.29"></a><span id="l68.29"> void test_kbx_nsigs(void **state);</span>
<a href="#l68.30"></a><span id="l68.30"> </span>
<a href="#l68.31"></a><span id="l68.31"> void test_issue_1115(void **state);</span>
<a href="#l68.32"></a><span id="l68.32"> </span>
<a href="#l68.33"></a><span id="l68.33" class="difflineplus">+void test_log_switch(void **state);</span>
<a href="#l68.34"></a><span id="l68.34" class="difflineplus">+</span>
<a href="#l68.35"></a><span id="l68.35"> #define assert_true(a) EXPECT_TRUE((a))</span>
<a href="#l68.36"></a><span id="l68.36"> #define assert_false(a) EXPECT_FALSE((a))</span>
<a href="#l68.37"></a><span id="l68.37"> #define assert_string_equal(a, b) EXPECT_STREQ((a), (b))</span>
<a href="#l68.38"></a><span id="l68.38"> #define assert_int_equal(a, b) EXPECT_EQ((a), (b))</span>
<a href="#l68.39"></a><span id="l68.39"> #define assert_int_not_equal(a, b) EXPECT_NE((a), (b))</span>
<a href="#l68.40"></a><span id="l68.40"> #define assert_non_null(a) EXPECT_NE((a), nullptr)</span>
<a href="#l68.41"></a><span id="l68.41"> #define assert_null(a) EXPECT_EQ((a), nullptr)</span>
<a href="#l68.42"></a><span id="l68.42"> #define assert_rnp_success(a) EXPECT_EQ((a), RNP_SUCCESS)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l69.1"></a><span id="l69.1" class="difflineminus">--- a/third_party/rnp/src/tests/streams.cpp</span>
<a href="#l69.2"></a><span id="l69.2" class="difflineplus">+++ b/third_party/rnp/src/tests/streams.cpp</span>
<a href="#l69.3"></a><span id="l69.3" class="difflineat">@@ -342,18 +342,17 @@ TEST_F(rnp_tests, test_stream_signatures</span>
<a href="#l69.4"></a><span id="l69.4">     uint8_t           keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l69.5"></a><span id="l69.5">     pgp_key_t *       key = NULL;</span>
<a href="#l69.6"></a><span id="l69.6">     rng_t             rng;</span>
<a href="#l69.7"></a><span id="l69.7">     pgp_fingerprint_t fp;</span>
<a href="#l69.8"></a><span id="l69.8"> </span>
<a href="#l69.9"></a><span id="l69.9">     /* we need rng for key validation */</span>
<a href="#l69.10"></a><span id="l69.10">     assert_true(rng_init(&amp;rng, RNG_SYSTEM));</span>
<a href="#l69.11"></a><span id="l69.11">     /* load keys */</span>
<a href="#l69.12"></a><span id="l69.12" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/test_stream_signatures/pub.asc&quot;);</span>
<a href="#l69.13"></a><span id="l69.13" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l69.14"></a><span id="l69.14" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/test_stream_signatures/pub.asc&quot;);</span>
<a href="#l69.15"></a><span id="l69.15">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l69.16"></a><span id="l69.16">     /* load signature */</span>
<a href="#l69.17"></a><span id="l69.17">     assert_rnp_success(init_file_src(&amp;sigsrc, &quot;data/test_stream_signatures/source.txt.sig&quot;));</span>
<a href="#l69.18"></a><span id="l69.18">     assert_rnp_success(stream_parse_signature(&amp;sigsrc, &amp;sig));</span>
<a href="#l69.19"></a><span id="l69.19">     src_close(&amp;sigsrc);</span>
<a href="#l69.20"></a><span id="l69.20">     /* hash signed file */</span>
<a href="#l69.21"></a><span id="l69.21">     halg = sig.halg;</span>
<a href="#l69.22"></a><span id="l69.22">     assert_true(pgp_hash_create(&amp;hash_orig, halg));</span>
<a href="#l69.23"></a><span id="l69.23" class="difflineat">@@ -371,18 +370,17 @@ TEST_F(rnp_tests, test_stream_signatures</span>
<a href="#l69.24"></a><span id="l69.24">     assert_rnp_success(signature_validate(&amp;sig, pgp_key_get_material(key), &amp;hash));</span>
<a href="#l69.25"></a><span id="l69.25">     /* check forged file */</span>
<a href="#l69.26"></a><span id="l69.26">     assert_true(pgp_hash_copy(&amp;hash, &amp;hash_forged));</span>
<a href="#l69.27"></a><span id="l69.27">     assert_rnp_failure(signature_validate(&amp;sig, pgp_key_get_material(key), &amp;hash));</span>
<a href="#l69.28"></a><span id="l69.28">     free_signature(&amp;sig);</span>
<a href="#l69.29"></a><span id="l69.29">     /* now let's create signature and sign file */</span>
<a href="#l69.30"></a><span id="l69.30"> </span>
<a href="#l69.31"></a><span id="l69.31">     /* load secret key */</span>
<a href="#l69.32"></a><span id="l69.32" class="difflineminus">-    secring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/test_stream_signatures/sec.asc&quot;);</span>
<a href="#l69.33"></a><span id="l69.33" class="difflineminus">-    assert_non_null(secring);</span>
<a href="#l69.34"></a><span id="l69.34" class="difflineplus">+    secring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/test_stream_signatures/sec.asc&quot;);</span>
<a href="#l69.35"></a><span id="l69.35">     assert_true(rnp_key_store_load_from_path(secring, NULL));</span>
<a href="#l69.36"></a><span id="l69.36">     assert_non_null(key = rnp_key_store_get_key_by_id(secring, keyid, NULL));</span>
<a href="#l69.37"></a><span id="l69.37">     assert_true(pgp_key_is_secret(key));</span>
<a href="#l69.38"></a><span id="l69.38">     /* fill signature */</span>
<a href="#l69.39"></a><span id="l69.39">     uint32_t create = time(NULL);</span>
<a href="#l69.40"></a><span id="l69.40">     uint32_t expire = 123456;</span>
<a href="#l69.41"></a><span id="l69.41">     memset(&amp;sig, 0, sizeof(sig));</span>
<a href="#l69.42"></a><span id="l69.42">     sig.version = PGP_V4;</span>
<a href="#l69.43"></a><span id="l69.43" class="difflineat">@@ -409,18 +407,18 @@ TEST_F(rnp_tests, test_stream_signatures</span>
<a href="#l69.44"></a><span id="l69.44">     assert_int_equal(signature_get_creation(&amp;sig), create);</span>
<a href="#l69.45"></a><span id="l69.45">     assert_int_equal(signature_get_expiration(&amp;sig), expire);</span>
<a href="#l69.46"></a><span id="l69.46">     assert_true(signature_has_keyfp(&amp;sig));</span>
<a href="#l69.47"></a><span id="l69.47">     assert_true(signature_get_keyfp(&amp;sig, &amp;fp));</span>
<a href="#l69.48"></a><span id="l69.48">     assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(key)));</span>
<a href="#l69.49"></a><span id="l69.49">     assert_rnp_success(signature_validate(&amp;sig, pgp_key_get_material(key), &amp;hash));</span>
<a href="#l69.50"></a><span id="l69.50">     free_signature(&amp;sig);</span>
<a href="#l69.51"></a><span id="l69.51">     /* cleanup */</span>
<a href="#l69.52"></a><span id="l69.52" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l69.53"></a><span id="l69.53" class="difflineminus">-    rnp_key_store_free(secring);</span>
<a href="#l69.54"></a><span id="l69.54" class="difflineplus">+    delete pubring;</span>
<a href="#l69.55"></a><span id="l69.55" class="difflineplus">+    delete secring;</span>
<a href="#l69.56"></a><span id="l69.56">     pgp_hash_finish(&amp;hash_orig, NULL);</span>
<a href="#l69.57"></a><span id="l69.57">     pgp_hash_finish(&amp;hash_forged, NULL);</span>
<a href="#l69.58"></a><span id="l69.58">     rng_destroy(&amp;rng);</span>
<a href="#l69.59"></a><span id="l69.59"> }</span>
<a href="#l69.60"></a><span id="l69.60"> </span>
<a href="#l69.61"></a><span id="l69.61"> TEST_F(rnp_tests, test_stream_signatures_revoked_key)</span>
<a href="#l69.62"></a><span id="l69.62"> {</span>
<a href="#l69.63"></a><span id="l69.63">     pgp_signature_t sig = {(pgp_version_t) 0};</span>
<a href="#l69.64"></a><span id="l69.64" class="difflineat">@@ -1065,23 +1063,23 @@ TEST_F(rnp_tests, test_stream_key_signat</span>
<a href="#l69.65"></a><span id="l69.65">     pgp_transferable_key_t *   key = NULL;</span>
<a href="#l69.66"></a><span id="l69.66">     pgp_transferable_subkey_t *subkey = NULL;</span>
<a href="#l69.67"></a><span id="l69.67">     pgp_transferable_userid_t *uid = NULL;</span>
<a href="#l69.68"></a><span id="l69.68">     rng_t                      rng;</span>
<a href="#l69.69"></a><span id="l69.69">     pgp_signature_t *          sig;</span>
<a href="#l69.70"></a><span id="l69.70">     uint8_t                    keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l69.71"></a><span id="l69.71">     pgp_key_t *                pkey = NULL;</span>
<a href="#l69.72"></a><span id="l69.72">     pgp_hash_t                 hash;</span>
<a href="#l69.73"></a><span id="l69.73" class="difflineplus">+    pgp_signature_info_t       sinfo = {};</span>
<a href="#l69.74"></a><span id="l69.74"> </span>
<a href="#l69.75"></a><span id="l69.75">     /* we need rng for key validation */</span>
<a href="#l69.76"></a><span id="l69.76">     assert_true(rng_init(&amp;rng, RNG_SYSTEM));</span>
<a href="#l69.77"></a><span id="l69.77"> </span>
<a href="#l69.78"></a><span id="l69.78">     /* v3 public key */</span>
<a href="#l69.79"></a><span id="l69.79" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/4/rsav3-p.asc&quot;);</span>
<a href="#l69.80"></a><span id="l69.80" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l69.81"></a><span id="l69.81" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/4/rsav3-p.asc&quot;);</span>
<a href="#l69.82"></a><span id="l69.82">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l69.83"></a><span id="l69.83">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/4/rsav3-p.asc&quot;));</span>
<a href="#l69.84"></a><span id="l69.84">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l69.85"></a><span id="l69.85">     src_close(&amp;keysrc);</span>
<a href="#l69.86"></a><span id="l69.86">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.87"></a><span id="l69.87">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.88"></a><span id="l69.88">     assert_non_null(uid = (pgp_transferable_userid_t *) list_front(key-&gt;userids));</span>
<a href="#l69.89"></a><span id="l69.89">     assert_non_null(sig = (pgp_signature_t *) list_front(uid-&gt;signatures));</span>
<a href="#l69.90"></a><span id="l69.90" class="difflineat">@@ -1089,22 +1087,21 @@ TEST_F(rnp_tests, test_stream_key_signat</span>
<a href="#l69.91"></a><span id="l69.91">     assert_non_null(pkey = rnp_key_store_get_key_by_id(pubring, keyid, NULL));</span>
<a href="#l69.92"></a><span id="l69.92">     /* check certification signature */</span>
<a href="#l69.93"></a><span id="l69.93">     assert_true(signature_hash_certification(sig, &amp;key-&gt;key, &amp;uid-&gt;uid, &amp;hash));</span>
<a href="#l69.94"></a><span id="l69.94">     assert_rnp_success(signature_validate(sig, pgp_key_get_material(pkey), &amp;hash));</span>
<a href="#l69.95"></a><span id="l69.95">     /* modify userid and check signature */</span>
<a href="#l69.96"></a><span id="l69.96">     uid-&gt;uid.uid[2] = '?';</span>
<a href="#l69.97"></a><span id="l69.97">     assert_true(signature_hash_certification(sig, &amp;key-&gt;key, &amp;uid-&gt;uid, &amp;hash));</span>
<a href="#l69.98"></a><span id="l69.98">     assert_rnp_failure(signature_validate(sig, pgp_key_get_material(pkey), &amp;hash));</span>
<a href="#l69.99"></a><span id="l69.99" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l69.100"></a><span id="l69.100" class="difflineplus">+    delete pubring;</span>
<a href="#l69.101"></a><span id="l69.101">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.102"></a><span id="l69.102"> </span>
<a href="#l69.103"></a><span id="l69.103">     /* keyring */</span>
<a href="#l69.104"></a><span id="l69.104" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l69.105"></a><span id="l69.105" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l69.106"></a><span id="l69.106" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l69.107"></a><span id="l69.107">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l69.108"></a><span id="l69.108">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l69.109"></a><span id="l69.109">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l69.110"></a><span id="l69.110">     src_close(&amp;keysrc);</span>
<a href="#l69.111"></a><span id="l69.111"> </span>
<a href="#l69.112"></a><span id="l69.112">     /* check key signatures */</span>
<a href="#l69.113"></a><span id="l69.113">     for (list_item *li = list_front(keyseq.keys); li; li = list_next(li)) {</span>
<a href="#l69.114"></a><span id="l69.114">         key = (pgp_transferable_key_t *) li;</span>
<a href="#l69.115"></a><span id="l69.115" class="difflineat">@@ -1114,96 +1111,96 @@ TEST_F(rnp_tests, test_stream_key_signat</span>
<a href="#l69.116"></a><span id="l69.116"> </span>
<a href="#l69.117"></a><span id="l69.117">             /* userid certifications */</span>
<a href="#l69.118"></a><span id="l69.118">             for (list_item *sli = list_front(uid-&gt;signatures); sli; sli = list_next(sli)) {</span>
<a href="#l69.119"></a><span id="l69.119">                 sig = (pgp_signature_t *) sli;</span>
<a href="#l69.120"></a><span id="l69.120"> </span>
<a href="#l69.121"></a><span id="l69.121">                 assert_true(signature_get_keyid(sig, keyid));</span>
<a href="#l69.122"></a><span id="l69.122">                 assert_non_null(pkey = rnp_key_store_get_key_by_id(pubring, keyid, NULL));</span>
<a href="#l69.123"></a><span id="l69.123">                 /* high level interface */</span>
<a href="#l69.124"></a><span id="l69.124" class="difflineminus">-                assert_rnp_success(signature_validate_certification(</span>
<a href="#l69.125"></a><span id="l69.125" class="difflineminus">-                  sig, &amp;key-&gt;key, &amp;uid-&gt;uid, pgp_key_get_material(pkey)));</span>
<a href="#l69.126"></a><span id="l69.126" class="difflineplus">+                sinfo.sig = sig;</span>
<a href="#l69.127"></a><span id="l69.127" class="difflineplus">+                sinfo.signer = pkey;</span>
<a href="#l69.128"></a><span id="l69.128" class="difflineplus">+                assert_rnp_success(</span>
<a href="#l69.129"></a><span id="l69.129" class="difflineplus">+                  signature_check_certification(&amp;sinfo, &amp;key-&gt;key, &amp;uid-&gt;uid));</span>
<a href="#l69.130"></a><span id="l69.130">                 /* low level check */</span>
<a href="#l69.131"></a><span id="l69.131">                 assert_true(signature_hash_certification(sig, &amp;key-&gt;key, &amp;uid-&gt;uid, &amp;hash));</span>
<a href="#l69.132"></a><span id="l69.132">                 assert_rnp_success(signature_validate(sig, pgp_key_get_material(pkey), &amp;hash));</span>
<a href="#l69.133"></a><span id="l69.133">                 /* modify userid and check signature */</span>
<a href="#l69.134"></a><span id="l69.134">                 uid-&gt;uid.uid[2] = '?';</span>
<a href="#l69.135"></a><span id="l69.135" class="difflineminus">-                assert_rnp_failure(signature_validate_certification(</span>
<a href="#l69.136"></a><span id="l69.136" class="difflineminus">-                  sig, &amp;key-&gt;key, &amp;uid-&gt;uid, pgp_key_get_material(pkey)));</span>
<a href="#l69.137"></a><span id="l69.137" class="difflineplus">+                assert_rnp_failure(</span>
<a href="#l69.138"></a><span id="l69.138" class="difflineplus">+                  signature_check_certification(&amp;sinfo, &amp;key-&gt;key, &amp;uid-&gt;uid));</span>
<a href="#l69.139"></a><span id="l69.139">                 assert_true(signature_hash_certification(sig, &amp;key-&gt;key, &amp;uid-&gt;uid, &amp;hash));</span>
<a href="#l69.140"></a><span id="l69.140">                 assert_rnp_failure(signature_validate(sig, pgp_key_get_material(pkey), &amp;hash));</span>
<a href="#l69.141"></a><span id="l69.141">             }</span>
<a href="#l69.142"></a><span id="l69.142">         }</span>
<a href="#l69.143"></a><span id="l69.143"> </span>
<a href="#l69.144"></a><span id="l69.144">         /* subkey binding signatures */</span>
<a href="#l69.145"></a><span id="l69.145">         for (list_item *sli = list_front(key-&gt;subkeys); sli; sli = list_next(sli)) {</span>
<a href="#l69.146"></a><span id="l69.146">             subkey = (pgp_transferable_subkey_t *) sli;</span>
<a href="#l69.147"></a><span id="l69.147">             sig = (pgp_signature_t *) list_front(subkey-&gt;signatures);</span>
<a href="#l69.148"></a><span id="l69.148">             assert_non_null(sig);</span>
<a href="#l69.149"></a><span id="l69.149">             assert_true(signature_get_keyid(sig, keyid));</span>
<a href="#l69.150"></a><span id="l69.150">             assert_non_null(pkey = rnp_key_store_get_key_by_id(pubring, keyid, NULL));</span>
<a href="#l69.151"></a><span id="l69.151">             /* high level interface */</span>
<a href="#l69.152"></a><span id="l69.152" class="difflineminus">-            assert_rnp_success(signature_validate_binding(sig, &amp;key-&gt;key, &amp;subkey-&gt;subkey));</span>
<a href="#l69.153"></a><span id="l69.153" class="difflineplus">+            sinfo.sig = sig;</span>
<a href="#l69.154"></a><span id="l69.154" class="difflineplus">+            sinfo.signer = pkey;</span>
<a href="#l69.155"></a><span id="l69.155" class="difflineplus">+            assert_rnp_success(signature_check_binding(&amp;sinfo, &amp;key-&gt;key, &amp;subkey-&gt;subkey));</span>
<a href="#l69.156"></a><span id="l69.156">             /* low level check */</span>
<a href="#l69.157"></a><span id="l69.157">             assert_true(signature_hash_binding(sig, &amp;key-&gt;key, &amp;subkey-&gt;subkey, &amp;hash));</span>
<a href="#l69.158"></a><span id="l69.158">             assert_rnp_success(signature_validate(sig, pgp_key_get_material(pkey), &amp;hash));</span>
<a href="#l69.159"></a><span id="l69.159">         }</span>
<a href="#l69.160"></a><span id="l69.160">     }</span>
<a href="#l69.161"></a><span id="l69.161"> </span>
<a href="#l69.162"></a><span id="l69.162" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l69.163"></a><span id="l69.163" class="difflineplus">+    delete pubring;</span>
<a href="#l69.164"></a><span id="l69.164">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.165"></a><span id="l69.165">     rng_destroy(&amp;rng);</span>
<a href="#l69.166"></a><span id="l69.166"> }</span>
<a href="#l69.167"></a><span id="l69.167"> </span>
<a href="#l69.168"></a><span id="l69.168"> static void</span>
<a href="#l69.169"></a><span id="l69.169"> validate_key_sigs(const char *path)</span>
<a href="#l69.170"></a><span id="l69.170"> {</span>
<a href="#l69.171"></a><span id="l69.171" class="difflineminus">-    rnp_key_store_t *pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, path);</span>
<a href="#l69.172"></a><span id="l69.172" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l69.173"></a><span id="l69.173" class="difflineplus">+    rnp_key_store_t *pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, path);</span>
<a href="#l69.174"></a><span id="l69.174">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l69.175"></a><span id="l69.175" class="difflineminus">-    for (size_t i = 0; i &lt; rnp_key_store_get_key_count(pubring); i++) {</span>
<a href="#l69.176"></a><span id="l69.176" class="difflineminus">-        pgp_key_t *pkey = rnp_key_store_get_key(pubring, i);</span>
<a href="#l69.177"></a><span id="l69.177" class="difflineminus">-        assert_non_null(pkey);</span>
<a href="#l69.178"></a><span id="l69.178" class="difflineminus">-        pgp_key_validate(pkey, pubring);</span>
<a href="#l69.179"></a><span id="l69.179" class="difflineminus">-        assert_true(pkey-&gt;valid);</span>
<a href="#l69.180"></a><span id="l69.180" class="difflineplus">+    for (auto &amp;key : pubring-&gt;keys) {</span>
<a href="#l69.181"></a><span id="l69.181" class="difflineplus">+        pgp_key_validate(&amp;key, pubring);</span>
<a href="#l69.182"></a><span id="l69.182" class="difflineplus">+        assert_true(key.valid);</span>
<a href="#l69.183"></a><span id="l69.183">     }</span>
<a href="#l69.184"></a><span id="l69.184" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l69.185"></a><span id="l69.185" class="difflineplus">+    delete pubring;</span>
<a href="#l69.186"></a><span id="l69.186"> }</span>
<a href="#l69.187"></a><span id="l69.187"> </span>
<a href="#l69.188"></a><span id="l69.188"> TEST_F(rnp_tests, test_stream_key_signature_validate)</span>
<a href="#l69.189"></a><span id="l69.189"> {</span>
<a href="#l69.190"></a><span id="l69.190">     rnp_key_store_t *pubring;</span>
<a href="#l69.191"></a><span id="l69.191">     pgp_key_t *      pkey = NULL;</span>
<a href="#l69.192"></a><span id="l69.192"> </span>
<a href="#l69.193"></a><span id="l69.193">     /* v3 public key */</span>
<a href="#l69.194"></a><span id="l69.194" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/4/rsav3-p.asc&quot;);</span>
<a href="#l69.195"></a><span id="l69.195" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l69.196"></a><span id="l69.196" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/4/rsav3-p.asc&quot;);</span>
<a href="#l69.197"></a><span id="l69.197">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l69.198"></a><span id="l69.198">     assert_int_equal(rnp_key_store_get_key_count(pubring), 1);</span>
<a href="#l69.199"></a><span id="l69.199" class="difflineminus">-    assert_non_null(pkey = rnp_key_store_get_key(pubring, 0));</span>
<a href="#l69.200"></a><span id="l69.200" class="difflineplus">+    pkey = &amp;pubring-&gt;keys.front();</span>
<a href="#l69.201"></a><span id="l69.201">     pgp_key_validate(pkey, pubring);</span>
<a href="#l69.202"></a><span id="l69.202">     assert_true(pkey-&gt;valid);</span>
<a href="#l69.203"></a><span id="l69.203" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l69.204"></a><span id="l69.204" class="difflineplus">+    delete pubring;</span>
<a href="#l69.205"></a><span id="l69.205"> </span>
<a href="#l69.206"></a><span id="l69.206">     /* keyring */</span>
<a href="#l69.207"></a><span id="l69.207" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l69.208"></a><span id="l69.208" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l69.209"></a><span id="l69.209" class="difflineplus">+    pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l69.210"></a><span id="l69.210">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l69.211"></a><span id="l69.211">     assert_true(rnp_key_store_get_key_count(pubring) &gt; 0);</span>
<a href="#l69.212"></a><span id="l69.212" class="difflineminus">-    for (size_t i = 0; i &lt; rnp_key_store_get_key_count(pubring); i++) {</span>
<a href="#l69.213"></a><span id="l69.213" class="difflineminus">-        pkey = rnp_key_store_get_key(pubring, i);</span>
<a href="#l69.214"></a><span id="l69.214" class="difflineminus">-        pgp_key_validate(pkey, pubring);</span>
<a href="#l69.215"></a><span id="l69.215" class="difflineplus">+    int i = 0;</span>
<a href="#l69.216"></a><span id="l69.216" class="difflineplus">+    for (auto &amp;key : pubring-&gt;keys) {</span>
<a href="#l69.217"></a><span id="l69.217" class="difflineplus">+        pgp_key_validate(&amp;key, pubring);</span>
<a href="#l69.218"></a><span id="l69.218">         // subkey #2 is expired</span>
<a href="#l69.219"></a><span id="l69.219">         if (i == 2) {</span>
<a href="#l69.220"></a><span id="l69.220" class="difflineminus">-            assert_false(pkey-&gt;valid);</span>
<a href="#l69.221"></a><span id="l69.221" class="difflineplus">+            assert_false(key.valid);</span>
<a href="#l69.222"></a><span id="l69.222">         } else {</span>
<a href="#l69.223"></a><span id="l69.223" class="difflineminus">-            assert_true(pkey-&gt;valid);</span>
<a href="#l69.224"></a><span id="l69.224" class="difflineplus">+            assert_true(key.valid);</span>
<a href="#l69.225"></a><span id="l69.225">         }</span>
<a href="#l69.226"></a><span id="l69.226" class="difflineplus">+        i++;</span>
<a href="#l69.227"></a><span id="l69.227">     }</span>
<a href="#l69.228"></a><span id="l69.228" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l69.229"></a><span id="l69.229" class="difflineplus">+    delete pubring;</span>
<a href="#l69.230"></a><span id="l69.230"> </span>
<a href="#l69.231"></a><span id="l69.231">     /* misc key files */</span>
<a href="#l69.232"></a><span id="l69.232">     const char *key_files[] = {&quot;data/test_stream_key_load/dsa-eg-pub.asc&quot;,</span>
<a href="#l69.233"></a><span id="l69.233">                                &quot;data/test_stream_key_load/dsa-eg-sec.asc&quot;,</span>
<a href="#l69.234"></a><span id="l69.234">                                &quot;data/test_stream_key_load/ecc-25519-pub.asc&quot;,</span>
<a href="#l69.235"></a><span id="l69.235">                                &quot;data/test_stream_key_load/ecc-25519-sec.asc&quot;,</span>
<a href="#l69.236"></a><span id="l69.236">                                &quot;data/test_stream_key_load/ecc-x25519-pub.asc&quot;,</span>
<a href="#l69.237"></a><span id="l69.237">                                &quot;data/test_stream_key_load/ecc-x25519-sec.asc&quot;,</span>
<a href="#l69.238"></a><span id="l69.238" class="difflineat">@@ -1440,24 +1437,23 @@ TEST_F(rnp_tests, test_stream_814_dearmo</span>
<a href="#l69.239"></a><span id="l69.239">     dst_close(&amp;dst, true);</span>
<a href="#l69.240"></a><span id="l69.240"> }</span>
<a href="#l69.241"></a><span id="l69.241"> </span>
<a href="#l69.242"></a><span id="l69.242"> TEST_F(rnp_tests, test_stream_825_dearmor_blank_line)</span>
<a href="#l69.243"></a><span id="l69.243"> {</span>
<a href="#l69.244"></a><span id="l69.244">     rnp_key_store_t *keystore = NULL;</span>
<a href="#l69.245"></a><span id="l69.245">     pgp_source_t     src = {};</span>
<a href="#l69.246"></a><span id="l69.246"> </span>
<a href="#l69.247"></a><span id="l69.247" class="difflineminus">-    keystore = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l69.248"></a><span id="l69.248" class="difflineminus">-    assert_non_null(keystore);</span>
<a href="#l69.249"></a><span id="l69.249" class="difflineplus">+    keystore = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l69.250"></a><span id="l69.250">     assert_rnp_success(</span>
<a href="#l69.251"></a><span id="l69.251">       init_file_src(&amp;src, &quot;data/test_stream_armor/extra_line_before_trailer.asc&quot;));</span>
<a href="#l69.252"></a><span id="l69.252">     assert_true(rnp_key_store_load_from_src(keystore, &amp;src, NULL));</span>
<a href="#l69.253"></a><span id="l69.253">     assert_int_equal(rnp_key_store_get_key_count(keystore), 2);</span>
<a href="#l69.254"></a><span id="l69.254">     src_close(&amp;src);</span>
<a href="#l69.255"></a><span id="l69.255" class="difflineminus">-    rnp_key_store_free(keystore);</span>
<a href="#l69.256"></a><span id="l69.256" class="difflineplus">+    delete keystore;</span>
<a href="#l69.257"></a><span id="l69.257"> }</span>
<a href="#l69.258"></a><span id="l69.258"> </span>
<a href="#l69.259"></a><span id="l69.259"> static bool</span>
<a href="#l69.260"></a><span id="l69.260"> try_dearmor(const char *str, int len)</span>
<a href="#l69.261"></a><span id="l69.261"> {</span>
<a href="#l69.262"></a><span id="l69.262">     pgp_source_t src = {};</span>
<a href="#l69.263"></a><span id="l69.263">     pgp_dest_t   dst = {};</span>
<a href="#l69.264"></a><span id="l69.264">     bool         res = false;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l70.1"></a><span id="l70.1" class="difflineminus">--- a/third_party/rnp/src/tests/support.cpp</span>
<a href="#l70.2"></a><span id="l70.2" class="difflineplus">+++ b/third_party/rnp/src/tests/support.cpp</span>
<a href="#l70.3"></a><span id="l70.3" class="difflineat">@@ -56,28 +56,16 @@ int</span>
<a href="#l70.4"></a><span id="l70.4"> unsetenv(const char *name)</span>
<a href="#l70.5"></a><span id="l70.5"> {</span>
<a href="#l70.6"></a><span id="l70.6">     char varbuf[512] = {0};</span>
<a href="#l70.7"></a><span id="l70.7">     snprintf(varbuf, sizeof(varbuf) - 1, &quot;%s=&quot;, name);</span>
<a href="#l70.8"></a><span id="l70.8">     return _putenv(varbuf);</span>
<a href="#l70.9"></a><span id="l70.9"> }</span>
<a href="#l70.10"></a><span id="l70.10"> #endif</span>
<a href="#l70.11"></a><span id="l70.11"> </span>
<a href="#l70.12"></a><span id="l70.12" class="difflineminus">-#ifndef HAVE_MKDTEMP</span>
<a href="#l70.13"></a><span id="l70.13" class="difflineminus">-char *</span>
<a href="#l70.14"></a><span id="l70.14" class="difflineminus">-mkdtemp(char *templ)</span>
<a href="#l70.15"></a><span id="l70.15" class="difflineminus">-{</span>
<a href="#l70.16"></a><span id="l70.16" class="difflineminus">-    char *dirpath = mktemp(templ);</span>
<a href="#l70.17"></a><span id="l70.17" class="difflineminus">-    if (!dirpath) {</span>
<a href="#l70.18"></a><span id="l70.18" class="difflineminus">-        return NULL;</span>
<a href="#l70.19"></a><span id="l70.19" class="difflineminus">-    }</span>
<a href="#l70.20"></a><span id="l70.20" class="difflineminus">-    return !RNP_MKDIR(dirpath, S_IRWXU) ? dirpath : NULL;</span>
<a href="#l70.21"></a><span id="l70.21" class="difflineminus">-}</span>
<a href="#l70.22"></a><span id="l70.22" class="difflineminus">-#endif</span>
<a href="#l70.23"></a><span id="l70.23" class="difflineminus">-</span>
<a href="#l70.24"></a><span id="l70.24"> /* Check if a file exists.</span>
<a href="#l70.25"></a><span id="l70.25">  * Use with assert_true and rnp_assert_false(rstate, .</span>
<a href="#l70.26"></a><span id="l70.26">  */</span>
<a href="#l70.27"></a><span id="l70.27"> bool</span>
<a href="#l70.28"></a><span id="l70.28"> file_exists(const char *path)</span>
<a href="#l70.29"></a><span id="l70.29"> {</span>
<a href="#l70.30"></a><span id="l70.30">     struct stat st = {0};</span>
<a href="#l70.31"></a><span id="l70.31">     return stat(path, &amp;st) == 0 &amp;&amp; S_ISREG(st.st_mode);</span>
<a href="#l70.32"></a><span id="l70.32" class="difflineat">@@ -261,16 +249,17 @@ copy_recursively(const char *src, const </span>
<a href="#l70.33"></a><span id="l70.33">     snprintf(buf, sizeof(buf), &quot;xcopy \&quot;%s\&quot; \&quot;%s\&quot; /I /Q /E /Y&quot;, src, dst);</span>
<a href="#l70.34"></a><span id="l70.34"> #endif</span>
<a href="#l70.35"></a><span id="l70.35">     assert_int_equal(0, system(buf));</span>
<a href="#l70.36"></a><span id="l70.36"> }</span>
<a href="#l70.37"></a><span id="l70.37"> </span>
<a href="#l70.38"></a><span id="l70.38"> /* Creates and returns a temporary directory path.</span>
<a href="#l70.39"></a><span id="l70.39">  * Caller must free the string.</span>
<a href="#l70.40"></a><span id="l70.40">  */</span>
<a href="#l70.41"></a><span id="l70.41" class="difflineplus">+#if defined(HAVE_MKDTEMP)</span>
<a href="#l70.42"></a><span id="l70.42"> char *</span>
<a href="#l70.43"></a><span id="l70.43"> make_temp_dir()</span>
<a href="#l70.44"></a><span id="l70.44"> {</span>
<a href="#l70.45"></a><span id="l70.45">     char rltmp[PATH_MAX] = {0};</span>
<a href="#l70.46"></a><span id="l70.46">     if (!realpath(get_tmp(), rltmp)) {</span>
<a href="#l70.47"></a><span id="l70.47">         printf(&quot;Fatal: realpath on tmp folder failed. Error %d.\n&quot;, errno);</span>
<a href="#l70.48"></a><span id="l70.48">         return NULL;</span>
<a href="#l70.49"></a><span id="l70.49">     }</span>
<a href="#l70.50"></a><span id="l70.50" class="difflineat">@@ -284,16 +273,40 @@ make_temp_dir()</span>
<a href="#l70.51"></a><span id="l70.51">     memcpy(buffer + strlen(rltmp), tmplate, strlen(tmplate));</span>
<a href="#l70.52"></a><span id="l70.52">     buffer[strlen(rltmp) + strlen(tmplate)] = '\0';</span>
<a href="#l70.53"></a><span id="l70.53">     char *res = mkdtemp(buffer);</span>
<a href="#l70.54"></a><span id="l70.54">     if (!res) {</span>
<a href="#l70.55"></a><span id="l70.55">         free(buffer);</span>
<a href="#l70.56"></a><span id="l70.56">     }</span>
<a href="#l70.57"></a><span id="l70.57">     return res;</span>
<a href="#l70.58"></a><span id="l70.58"> }</span>
<a href="#l70.59"></a><span id="l70.59" class="difflineplus">+#elif defined(HAVE__TEMPNAM)</span>
<a href="#l70.60"></a><span id="l70.60" class="difflineplus">+char *</span>
<a href="#l70.61"></a><span id="l70.61" class="difflineplus">+make_temp_dir()</span>
<a href="#l70.62"></a><span id="l70.62" class="difflineplus">+{</span>
<a href="#l70.63"></a><span id="l70.63" class="difflineplus">+    const int MAX_ATTEMPTS = 10;</span>
<a href="#l70.64"></a><span id="l70.64" class="difflineplus">+    for (int i = 0; i &lt; MAX_ATTEMPTS; i++) {</span>
<a href="#l70.65"></a><span id="l70.65" class="difflineplus">+        char *dir = _tempnam(NULL, &quot;rnp-gtest-&quot;);</span>
<a href="#l70.66"></a><span id="l70.66" class="difflineplus">+        if (!dir) {</span>
<a href="#l70.67"></a><span id="l70.67" class="difflineplus">+            fprintf(stderr, &quot;_tempnam failed to generate temporary path&quot;);</span>
<a href="#l70.68"></a><span id="l70.68" class="difflineplus">+            continue;</span>
<a href="#l70.69"></a><span id="l70.69" class="difflineplus">+        }</span>
<a href="#l70.70"></a><span id="l70.70" class="difflineplus">+        if (RNP_MKDIR(dir, S_IRWXU)) {</span>
<a href="#l70.71"></a><span id="l70.71" class="difflineplus">+            fprintf(stderr, &quot;Failed to create temporary directory&quot;);</span>
<a href="#l70.72"></a><span id="l70.72" class="difflineplus">+            free(dir);</span>
<a href="#l70.73"></a><span id="l70.73" class="difflineplus">+            continue;</span>
<a href="#l70.74"></a><span id="l70.74" class="difflineplus">+        }</span>
<a href="#l70.75"></a><span id="l70.75" class="difflineplus">+        return dir;</span>
<a href="#l70.76"></a><span id="l70.76" class="difflineplus">+    }</span>
<a href="#l70.77"></a><span id="l70.77" class="difflineplus">+    fprintf(stderr, &quot;Failed to make temporary directory, aborting&quot;);</span>
<a href="#l70.78"></a><span id="l70.78" class="difflineplus">+    return NULL;</span>
<a href="#l70.79"></a><span id="l70.79" class="difflineplus">+}</span>
<a href="#l70.80"></a><span id="l70.80" class="difflineplus">+#else</span>
<a href="#l70.81"></a><span id="l70.81" class="difflineplus">+#error Unsupported platform</span>
<a href="#l70.82"></a><span id="l70.82" class="difflineplus">+#endif</span>
<a href="#l70.83"></a><span id="l70.83"> </span>
<a href="#l70.84"></a><span id="l70.84"> static char *</span>
<a href="#l70.85"></a><span id="l70.85"> directory_from_absolute_file_path(const char *file_path)</span>
<a href="#l70.86"></a><span id="l70.86"> {</span>
<a href="#l70.87"></a><span id="l70.87">     const char *last_sep = strrchr(file_path, '/');</span>
<a href="#l70.88"></a><span id="l70.88">     if (!last_sep) {</span>
<a href="#l70.89"></a><span id="l70.89">         return NULL;</span>
<a href="#l70.90"></a><span id="l70.90">     }</span>
<a href="#l70.91"></a><span id="l70.91" class="difflineat">@@ -763,40 +776,36 @@ ishex(const std::string &amp;hexid)</span>
<a href="#l70.92"></a><span id="l70.92">             continue;</span>
<a href="#l70.93"></a><span id="l70.93">         }</span>
<a href="#l70.94"></a><span id="l70.94">         return false;</span>
<a href="#l70.95"></a><span id="l70.95">     }</span>
<a href="#l70.96"></a><span id="l70.96">     return true;</span>
<a href="#l70.97"></a><span id="l70.97"> }</span>
<a href="#l70.98"></a><span id="l70.98"> </span>
<a href="#l70.99"></a><span id="l70.99"> pgp_key_t *</span>
<a href="#l70.100"></a><span id="l70.100" class="difflineminus">-rnp_tests_get_key_by_id(const rnp_key_store_t *keyring,</span>
<a href="#l70.101"></a><span id="l70.101" class="difflineminus">-                        const std::string &amp;    keyid,</span>
<a href="#l70.102"></a><span id="l70.102" class="difflineminus">-                        pgp_key_t *            after)</span>
<a href="#l70.103"></a><span id="l70.103" class="difflineplus">+rnp_tests_get_key_by_id(rnp_key_store_t *keyring, const std::string &amp;keyid, pgp_key_t *after)</span>
<a href="#l70.104"></a><span id="l70.104"> {</span>
<a href="#l70.105"></a><span id="l70.105">     pgp_key_t *          key = NULL;</span>
<a href="#l70.106"></a><span id="l70.106">     std::vector&lt;uint8_t&gt; keyid_bin(PGP_KEY_ID_SIZE, 0);</span>
<a href="#l70.107"></a><span id="l70.107">     size_t               binlen = 0;</span>
<a href="#l70.108"></a><span id="l70.108"> </span>
<a href="#l70.109"></a><span id="l70.109">     if (!keyring || keyid.empty()) {</span>
<a href="#l70.110"></a><span id="l70.110">         return NULL;</span>
<a href="#l70.111"></a><span id="l70.111">     }</span>
<a href="#l70.112"></a><span id="l70.112" class="difflineminus">-    assert(!after || list_is_member(keyring-&gt;keys, (list_item *) after));</span>
<a href="#l70.113"></a><span id="l70.113" class="difflineminus">-</span>
<a href="#l70.114"></a><span id="l70.114">     if (ishex(keyid) &amp;&amp;</span>
<a href="#l70.115"></a><span id="l70.115">         hex2bin(keyid.c_str(), keyid.size(), keyid_bin.data(), keyid_bin.size(), &amp;binlen)) {</span>
<a href="#l70.116"></a><span id="l70.116">         if (binlen &lt;= PGP_KEY_ID_SIZE) {</span>
<a href="#l70.117"></a><span id="l70.117">             key = rnp_key_store_get_key_by_id(keyring, keyid_bin.data(), after);</span>
<a href="#l70.118"></a><span id="l70.118">         }</span>
<a href="#l70.119"></a><span id="l70.119">     }</span>
<a href="#l70.120"></a><span id="l70.120">     return key;</span>
<a href="#l70.121"></a><span id="l70.121"> }</span>
<a href="#l70.122"></a><span id="l70.122"> </span>
<a href="#l70.123"></a><span id="l70.123"> pgp_key_t *</span>
<a href="#l70.124"></a><span id="l70.124" class="difflineminus">-rnp_tests_get_key_by_fpr(const rnp_key_store_t *keyring, const std::string &amp;keyid)</span>
<a href="#l70.125"></a><span id="l70.125" class="difflineplus">+rnp_tests_get_key_by_fpr(rnp_key_store_t *keyring, const std::string &amp;keyid)</span>
<a href="#l70.126"></a><span id="l70.126"> {</span>
<a href="#l70.127"></a><span id="l70.127">     pgp_key_t *          key = NULL;</span>
<a href="#l70.128"></a><span id="l70.128">     std::vector&lt;uint8_t&gt; keyid_bin(PGP_FINGERPRINT_SIZE, 0);</span>
<a href="#l70.129"></a><span id="l70.129">     size_t               binlen = 0;</span>
<a href="#l70.130"></a><span id="l70.130"> </span>
<a href="#l70.131"></a><span id="l70.131">     if (!keyring || keyid.empty()) {</span>
<a href="#l70.132"></a><span id="l70.132">         return NULL;</span>
<a href="#l70.133"></a><span id="l70.133">     }</span>
<a href="#l70.134"></a><span id="l70.134" class="difflineat">@@ -808,17 +817,17 @@ rnp_tests_get_key_by_fpr(const rnp_key_s</span>
<a href="#l70.135"></a><span id="l70.135">             memcpy(fp.fingerprint, keyid_bin.data(), binlen);</span>
<a href="#l70.136"></a><span id="l70.136">             key = rnp_key_store_get_key_by_fpr(keyring, &amp;fp);</span>
<a href="#l70.137"></a><span id="l70.137">         }</span>
<a href="#l70.138"></a><span id="l70.138">     }</span>
<a href="#l70.139"></a><span id="l70.139">     return key;</span>
<a href="#l70.140"></a><span id="l70.140"> }</span>
<a href="#l70.141"></a><span id="l70.141"> </span>
<a href="#l70.142"></a><span id="l70.142"> pgp_key_t *</span>
<a href="#l70.143"></a><span id="l70.143" class="difflineminus">-rnp_tests_key_search(const rnp_key_store_t *keyring, const std::string &amp;keyid)</span>
<a href="#l70.144"></a><span id="l70.144" class="difflineplus">+rnp_tests_key_search(rnp_key_store_t *keyring, const std::string &amp;keyid)</span>
<a href="#l70.145"></a><span id="l70.145"> {</span>
<a href="#l70.146"></a><span id="l70.146">     if (!keyring || keyid.empty()) {</span>
<a href="#l70.147"></a><span id="l70.147">         return NULL;</span>
<a href="#l70.148"></a><span id="l70.148">     }</span>
<a href="#l70.149"></a><span id="l70.149"> </span>
<a href="#l70.150"></a><span id="l70.150">     pgp_key_search_t srch_userid = {PGP_KEY_SEARCH_USERID};</span>
<a href="#l70.151"></a><span id="l70.151">     strncpy(srch_userid.by.userid, keyid.c_str(), sizeof(srch_userid.by.userid));</span>
<a href="#l70.152"></a><span id="l70.152">     srch_userid.by.userid[sizeof(srch_userid.by.userid) - 1] = '\0';</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l71.1"></a><span id="l71.1" class="difflineminus">--- a/third_party/rnp/src/tests/support.h</span>
<a href="#l71.2"></a><span id="l71.2" class="difflineplus">+++ b/third_party/rnp/src/tests/support.h</span>
<a href="#l71.3"></a><span id="l71.3" class="difflineat">@@ -213,13 +213,13 @@ std::string strip_eol(const std::string </span>
<a href="#l71.4"></a><span id="l71.4"> </span>
<a href="#l71.5"></a><span id="l71.5"> bool check_json_field_str(json_object *      obj,</span>
<a href="#l71.6"></a><span id="l71.6">                           const std::string &amp;field,</span>
<a href="#l71.7"></a><span id="l71.7">                           const std::string &amp;value);</span>
<a href="#l71.8"></a><span id="l71.8"> bool check_json_field_int(json_object *obj, const std::string &amp;field, int value);</span>
<a href="#l71.9"></a><span id="l71.9"> bool check_json_field_bool(json_object *obj, const std::string &amp;field, bool value);</span>
<a href="#l71.10"></a><span id="l71.10"> bool check_json_pkt_type(json_object *pkt, int tag);</span>
<a href="#l71.11"></a><span id="l71.11"> </span>
<a href="#l71.12"></a><span id="l71.12" class="difflineminus">-pgp_key_t *rnp_tests_get_key_by_id(const rnp_key_store_t *keyring,</span>
<a href="#l71.13"></a><span id="l71.13" class="difflineminus">-                                   const std::string &amp;    keyid,</span>
<a href="#l71.14"></a><span id="l71.14" class="difflineminus">-                                   pgp_key_t *            after);</span>
<a href="#l71.15"></a><span id="l71.15" class="difflineminus">-pgp_key_t *rnp_tests_get_key_by_fpr(const rnp_key_store_t *keyring, const std::string &amp;keyid);</span>
<a href="#l71.16"></a><span id="l71.16" class="difflineminus">-pgp_key_t *rnp_tests_key_search(const rnp_key_store_t *keyring, const std::string &amp;keyid);</span>
<a href="#l71.17"></a><span id="l71.17" class="difflineplus">+pgp_key_t *rnp_tests_get_key_by_id(rnp_key_store_t *  keyring,</span>
<a href="#l71.18"></a><span id="l71.18" class="difflineplus">+                                   const std::string &amp;keyid,</span>
<a href="#l71.19"></a><span id="l71.19" class="difflineplus">+                                   pgp_key_t *        after);</span>
<a href="#l71.20"></a><span id="l71.20" class="difflineplus">+pgp_key_t *rnp_tests_get_key_by_fpr(rnp_key_store_t *keyring, const std::string &amp;keyid);</span>
<a href="#l71.21"></a><span id="l71.21" class="difflineplus">+pgp_key_t *rnp_tests_key_search(rnp_key_store_t *keyring, const std::string &amp;keyid);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l72.1"></a><span id="l72.1" class="difflineminus">--- a/third_party/rnp/src/tests/user-prefs.cpp</span>
<a href="#l72.2"></a><span id="l72.2" class="difflineplus">+++ b/third_party/rnp/src/tests/user-prefs.cpp</span>
<a href="#l72.3"></a><span id="l72.3" class="difflineat">@@ -31,17 +31,17 @@</span>
<a href="#l72.4"></a><span id="l72.4"> #include &quot;pgp-key.h&quot;</span>
<a href="#l72.5"></a><span id="l72.5"> </span>
<a href="#l72.6"></a><span id="l72.6"> static const pgp_subsig_t *</span>
<a href="#l72.7"></a><span id="l72.7"> find_subsig(const pgp_key_t *key, const char *userid)</span>
<a href="#l72.8"></a><span id="l72.8"> {</span>
<a href="#l72.9"></a><span id="l72.9">     // find the userid index</span>
<a href="#l72.10"></a><span id="l72.10">     int uididx = -1;</span>
<a href="#l72.11"></a><span id="l72.11">     for (unsigned i = 0; i &lt; pgp_key_get_userid_count(key); i++) {</span>
<a href="#l72.12"></a><span id="l72.12" class="difflineminus">-        if (!strcmp(pgp_key_get_userid(key, i)-&gt;str, userid)) {</span>
<a href="#l72.13"></a><span id="l72.13" class="difflineplus">+        if (pgp_key_get_userid(key, i)-&gt;str == userid) {</span>
<a href="#l72.14"></a><span id="l72.14">             uididx = i;</span>
<a href="#l72.15"></a><span id="l72.15">             break;</span>
<a href="#l72.16"></a><span id="l72.16">         }</span>
<a href="#l72.17"></a><span id="l72.17">     }</span>
<a href="#l72.18"></a><span id="l72.18">     if (uididx == -1) {</span>
<a href="#l72.19"></a><span id="l72.19">         return NULL;</span>
<a href="#l72.20"></a><span id="l72.20">     }</span>
<a href="#l72.21"></a><span id="l72.21">     // find the subsig index</span>
<a href="#l72.22"></a><span id="l72.22" class="difflineat">@@ -51,20 +51,18 @@ find_subsig(const pgp_key_t *key, const </span>
<a href="#l72.23"></a><span id="l72.23">             return subsig;</span>
<a href="#l72.24"></a><span id="l72.24">         }</span>
<a href="#l72.25"></a><span id="l72.25">     }</span>
<a href="#l72.26"></a><span id="l72.26">     return NULL;</span>
<a href="#l72.27"></a><span id="l72.27"> }</span>
<a href="#l72.28"></a><span id="l72.28"> </span>
<a href="#l72.29"></a><span id="l72.29"> TEST_F(rnp_tests, test_load_user_prefs)</span>
<a href="#l72.30"></a><span id="l72.30"> {</span>
<a href="#l72.31"></a><span id="l72.31" class="difflineminus">-    rnp_key_store_t *pubring = NULL;</span>
<a href="#l72.32"></a><span id="l72.32" class="difflineminus">-</span>
<a href="#l72.33"></a><span id="l72.33" class="difflineminus">-    pubring = rnp_key_store_new(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l72.34"></a><span id="l72.34" class="difflineminus">-    assert_non_null(pubring);</span>
<a href="#l72.35"></a><span id="l72.35" class="difflineplus">+    rnp_key_store_t *pubring =</span>
<a href="#l72.36"></a><span id="l72.36" class="difflineplus">+      new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l72.37"></a><span id="l72.37">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l72.38"></a><span id="l72.38">     assert_int_equal(rnp_key_store_get_key_count(pubring), 7);</span>
<a href="#l72.39"></a><span id="l72.39"> </span>
<a href="#l72.40"></a><span id="l72.40">     {</span>
<a href="#l72.41"></a><span id="l72.41">         const char *userid = &quot;key1-uid0&quot;;</span>
<a href="#l72.42"></a><span id="l72.42"> </span>
<a href="#l72.43"></a><span id="l72.43">         // find the key</span>
<a href="#l72.44"></a><span id="l72.44">         pgp_key_t *key = NULL;</span>
<a href="#l72.45"></a><span id="l72.45" class="difflineat">@@ -154,10 +152,10 @@ TEST_F(rnp_tests, test_load_user_prefs)</span>
<a href="#l72.46"></a><span id="l72.46">         }</span>
<a href="#l72.47"></a><span id="l72.47">         // preferred key server</span>
<a href="#l72.48"></a><span id="l72.48">         {</span>
<a href="#l72.49"></a><span id="l72.49">             assert_null(prefs-&gt;key_server);</span>
<a href="#l72.50"></a><span id="l72.50">         }</span>
<a href="#l72.51"></a><span id="l72.51">     }</span>
<a href="#l72.52"></a><span id="l72.52"> </span>
<a href="#l72.53"></a><span id="l72.53">     /* Cleanup */</span>
<a href="#l72.54"></a><span id="l72.54" class="difflineminus">-    rnp_key_store_free(pubring);</span>
<a href="#l72.55"></a><span id="l72.55" class="difflineplus">+    delete pubring;</span>
<a href="#l72.56"></a><span id="l72.56"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l73.1"></a><span id="l73.1">new file mode 100644</span>
<a href="#l73.2"></a><span id="l73.2" class="difflineminus">--- /dev/null</span>
<a href="#l73.3"></a><span id="l73.3" class="difflineplus">+++ b/third_party/rnp/src/tests/utils-hex2bin.cpp</span>
<a href="#l73.4"></a><span id="l73.4" class="difflineat">@@ -0,0 +1,82 @@</span>
<a href="#l73.5"></a><span id="l73.5" class="difflineplus">+/*</span>
<a href="#l73.6"></a><span id="l73.6" class="difflineplus">+ * Copyright (c) 2020 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l73.7"></a><span id="l73.7" class="difflineplus">+ * All rights reserved.</span>
<a href="#l73.8"></a><span id="l73.8" class="difflineplus">+ *</span>
<a href="#l73.9"></a><span id="l73.9" class="difflineplus">+ * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l73.10"></a><span id="l73.10" class="difflineplus">+ * are permitted provided that the following conditions are met:</span>
<a href="#l73.11"></a><span id="l73.11" class="difflineplus">+ *</span>
<a href="#l73.12"></a><span id="l73.12" class="difflineplus">+ * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l73.13"></a><span id="l73.13" class="difflineplus">+ *     this list of conditions and the following disclaimer.</span>
<a href="#l73.14"></a><span id="l73.14" class="difflineplus">+ *</span>
<a href="#l73.15"></a><span id="l73.15" class="difflineplus">+ * 2.  Redistributions in binary form must reproduce the above copyright notice,</span>
<a href="#l73.16"></a><span id="l73.16" class="difflineplus">+ *     this list of conditions and the following disclaimer in the documentation</span>
<a href="#l73.17"></a><span id="l73.17" class="difflineplus">+ *     and/or other materials provided with the distribution.</span>
<a href="#l73.18"></a><span id="l73.18" class="difflineplus">+ *</span>
<a href="#l73.19"></a><span id="l73.19" class="difflineplus">+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a href="#l73.20"></a><span id="l73.20" class="difflineplus">+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a href="#l73.21"></a><span id="l73.21" class="difflineplus">+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a href="#l73.22"></a><span id="l73.22" class="difflineplus">+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<a href="#l73.23"></a><span id="l73.23" class="difflineplus">+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a href="#l73.24"></a><span id="l73.24" class="difflineplus">+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a href="#l73.25"></a><span id="l73.25" class="difflineplus">+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a href="#l73.26"></a><span id="l73.26" class="difflineplus">+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a href="#l73.27"></a><span id="l73.27" class="difflineplus">+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a href="#l73.28"></a><span id="l73.28" class="difflineplus">+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l73.29"></a><span id="l73.29" class="difflineplus">+ */</span>
<a href="#l73.30"></a><span id="l73.30" class="difflineplus">+</span>
<a href="#l73.31"></a><span id="l73.31" class="difflineplus">+#include &quot;rnp_tests.h&quot;</span>
<a href="#l73.32"></a><span id="l73.32" class="difflineplus">+#include &lt;rnp/rnp_sdk.h&gt;</span>
<a href="#l73.33"></a><span id="l73.33" class="difflineplus">+</span>
<a href="#l73.34"></a><span id="l73.34" class="difflineplus">+TEST_F(rnp_tests, test_utils_hex2bin)</span>
<a href="#l73.35"></a><span id="l73.35" class="difflineplus">+{</span>
<a href="#l73.36"></a><span id="l73.36" class="difflineplus">+    // with 0x prefix</span>
<a href="#l73.37"></a><span id="l73.37" class="difflineplus">+    {</span>
<a href="#l73.38"></a><span id="l73.38" class="difflineplus">+        uint8_t     buf[4];</span>
<a href="#l73.39"></a><span id="l73.39" class="difflineplus">+        const char *hex = &quot;0xfeedbeef&quot;;</span>
<a href="#l73.40"></a><span id="l73.40" class="difflineplus">+        size_t      outsz = 0;</span>
<a href="#l73.41"></a><span id="l73.41" class="difflineplus">+</span>
<a href="#l73.42"></a><span id="l73.42" class="difflineplus">+        assert_true(hex2bin(hex, strlen(hex), buf, sizeof(buf), &amp;outsz));</span>
<a href="#l73.43"></a><span id="l73.43" class="difflineplus">+        assert_int_equal(outsz, 4);</span>
<a href="#l73.44"></a><span id="l73.44" class="difflineplus">+        assert_int_equal(0, memcmp(buf, &quot;\xfe\xed\xbe\xef&quot;, 4));</span>
<a href="#l73.45"></a><span id="l73.45" class="difflineplus">+    }</span>
<a href="#l73.46"></a><span id="l73.46" class="difflineplus">+    // with 0X prefix, capital</span>
<a href="#l73.47"></a><span id="l73.47" class="difflineplus">+    {</span>
<a href="#l73.48"></a><span id="l73.48" class="difflineplus">+        uint8_t     buf[4];</span>
<a href="#l73.49"></a><span id="l73.49" class="difflineplus">+        const char *hex = &quot;0XFEEDBEEF&quot;;</span>
<a href="#l73.50"></a><span id="l73.50" class="difflineplus">+        size_t      outsz = 0;</span>
<a href="#l73.51"></a><span id="l73.51" class="difflineplus">+</span>
<a href="#l73.52"></a><span id="l73.52" class="difflineplus">+        assert_true(hex2bin(hex, strlen(hex), buf, sizeof(buf), &amp;outsz));</span>
<a href="#l73.53"></a><span id="l73.53" class="difflineplus">+        assert_int_equal(outsz, 4);</span>
<a href="#l73.54"></a><span id="l73.54" class="difflineplus">+        assert_int_equal(0, memcmp(buf, &quot;\xfe\xed\xbe\xef&quot;, 4));</span>
<a href="#l73.55"></a><span id="l73.55" class="difflineplus">+    }</span>
<a href="#l73.56"></a><span id="l73.56" class="difflineplus">+    // without 0x prefix</span>
<a href="#l73.57"></a><span id="l73.57" class="difflineplus">+    {</span>
<a href="#l73.58"></a><span id="l73.58" class="difflineplus">+        uint8_t     buf[4];</span>
<a href="#l73.59"></a><span id="l73.59" class="difflineplus">+        const char *hex = &quot;feedbeef&quot;;</span>
<a href="#l73.60"></a><span id="l73.60" class="difflineplus">+        size_t      outsz = 0;</span>
<a href="#l73.61"></a><span id="l73.61" class="difflineplus">+</span>
<a href="#l73.62"></a><span id="l73.62" class="difflineplus">+        assert_true(hex2bin(hex, strlen(hex), buf, sizeof(buf), &amp;outsz));</span>
<a href="#l73.63"></a><span id="l73.63" class="difflineplus">+        assert_int_equal(outsz, 4);</span>
<a href="#l73.64"></a><span id="l73.64" class="difflineplus">+        assert_int_equal(0, memcmp(buf, &quot;\xfe\xed\xbe\xef&quot;, 4));</span>
<a href="#l73.65"></a><span id="l73.65" class="difflineplus">+    }</span>
<a href="#l73.66"></a><span id="l73.66" class="difflineplus">+    // keyid with spaces</span>
<a href="#l73.67"></a><span id="l73.67" class="difflineplus">+    {</span>
<a href="#l73.68"></a><span id="l73.68" class="difflineplus">+        uint8_t     buf[PGP_KEY_ID_SIZE];</span>
<a href="#l73.69"></a><span id="l73.69" class="difflineplus">+        const char *hex = &quot;4be1 47bb 22df 1e60&quot;;</span>
<a href="#l73.70"></a><span id="l73.70" class="difflineplus">+        size_t      outsz = 0;</span>
<a href="#l73.71"></a><span id="l73.71" class="difflineplus">+</span>
<a href="#l73.72"></a><span id="l73.72" class="difflineplus">+        assert_true(hex2bin(hex, strlen(hex), buf, sizeof(buf), &amp;outsz));</span>
<a href="#l73.73"></a><span id="l73.73" class="difflineplus">+        assert_int_equal(outsz, PGP_KEY_ID_SIZE);</span>
<a href="#l73.74"></a><span id="l73.74" class="difflineplus">+        assert_int_equal(0, memcmp(buf, &quot;\x4b\xe1\x47\xbb\x22\xdf\x1e\x60&quot;, PGP_KEY_ID_SIZE));</span>
<a href="#l73.75"></a><span id="l73.75" class="difflineplus">+    }</span>
<a href="#l73.76"></a><span id="l73.76" class="difflineplus">+    // keyid with spaces and tab</span>
<a href="#l73.77"></a><span id="l73.77" class="difflineplus">+    {</span>
<a href="#l73.78"></a><span id="l73.78" class="difflineplus">+        uint8_t     buf[PGP_KEY_ID_SIZE];</span>
<a href="#l73.79"></a><span id="l73.79" class="difflineplus">+        const char *hex = &quot;    4be147bb\t22df1e60   &quot;;</span>
<a href="#l73.80"></a><span id="l73.80" class="difflineplus">+        size_t      outsz = 0;</span>
<a href="#l73.81"></a><span id="l73.81" class="difflineplus">+</span>
<a href="#l73.82"></a><span id="l73.82" class="difflineplus">+        assert_true(hex2bin(hex, strlen(hex), buf, sizeof(buf), &amp;outsz));</span>
<a href="#l73.83"></a><span id="l73.83" class="difflineplus">+        assert_int_equal(outsz, PGP_KEY_ID_SIZE);</span>
<a href="#l73.84"></a><span id="l73.84" class="difflineplus">+        assert_int_equal(0, memcmp(buf, &quot;\x4b\xe1\x47\xbb\x22\xdf\x1e\x60&quot;, PGP_KEY_ID_SIZE));</span>
<a href="#l73.85"></a><span id="l73.85" class="difflineplus">+    }</span>
<a href="#l73.86"></a><span id="l73.86" class="difflineplus">+}</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:33Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

