<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 978:fc01f4852a99fc70aade625c2a929de943530615</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ fc01f4852a99fc70aade625c2a929de943530615" />
<meta property="og:url" content="/comm-central/rev/fc01f4852a99fc70aade625c2a929de943530615" />
<meta property="og:description" content="status commit; indexing seems to be working pretty well, haven't tried exptoolbar." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / fc01f4852a99fc70aade625c2a929de943530615 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/fc01f4852a99fc70aade625c2a929de943530615">shortlog</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/fc01f4852a99fc70aade625c2a929de943530615">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615">files</a> |
changeset |
<a href="/comm-central/raw-rev/fc01f4852a99fc70aade625c2a929de943530615">raw</a>  | <a href="/comm-central/archive/fc01f4852a99fc70aade625c2a929de943530615.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
status commit; indexing seems to be working pretty well, haven't tried exptoolbar.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 19 Oct 2008 00:57:25 -0700</td></tr>

<tr>
 <td>changeset 978</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/fc01f4852a99fc70aade625c2a929de943530615">fc01f4852a99fc70aade625c2a929de943530615</a></td>
</tr>



<tr>
<td>parent 977</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/e9885bc4b347eff252efc76a6402b30747198cec">e9885bc4b347eff252efc76a6402b30747198cec</a>
</td>
</tr>

<tr>
<td>child 979</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/7d39e7afd1751d830e2eabe8f69801905a413e9a">7d39e7afd1751d830e2eabe8f69801905a413e9a</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=fc01f4852a99fc70aade625c2a929de943530615">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">status commit; indexing seems to be working pretty well, haven't tried exptoolbar.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615/modules/collection.js">file</a> |
<a href="/comm-central/annotate/fc01f4852a99fc70aade625c2a929de943530615/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/fc01f4852a99fc70aade625c2a929de943530615/modules/collection.js">comparison</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/fc01f4852a99fc70aade625c2a929de943530615/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/fc01f4852a99fc70aade625c2a929de943530615/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/fc01f4852a99fc70aade625c2a929de943530615/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/fc01f4852a99fc70aade625c2a929de943530615/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/explattr.js">modules/explattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615/modules/explattr.js">file</a> |
<a href="/comm-central/annotate/fc01f4852a99fc70aade625c2a929de943530615/modules/explattr.js">annotate</a> |
<a href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/explattr.js">diff</a> |
<a href="/comm-central/comparison/fc01f4852a99fc70aade625c2a929de943530615/modules/explattr.js">comparison</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615/modules/explattr.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/fundattr.js">modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/fc01f4852a99fc70aade625c2a929de943530615/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/fc01f4852a99fc70aade625c2a929de943530615/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/fc01f4852a99fc70aade625c2a929de943530615/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/fc01f4852a99fc70aade625c2a929de943530615/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/index_ab.js">modules/index_ab.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615/modules/index_ab.js">file</a> |
<a href="/comm-central/annotate/fc01f4852a99fc70aade625c2a929de943530615/modules/index_ab.js">annotate</a> |
<a href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/index_ab.js">diff</a> |
<a href="/comm-central/comparison/fc01f4852a99fc70aade625c2a929de943530615/modules/index_ab.js">comparison</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615/modules/index_ab.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/fc01f4852a99fc70aade625c2a929de943530615/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/fc01f4852a99fc70aade625c2a929de943530615/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/query.js">modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fc01f4852a99fc70aade625c2a929de943530615/modules/query.js">file</a> |
<a href="/comm-central/annotate/fc01f4852a99fc70aade625c2a929de943530615/modules/query.js">annotate</a> |
<a href="/comm-central/diff/fc01f4852a99fc70aade625c2a929de943530615/modules/query.js">diff</a> |
<a href="/comm-central/comparison/fc01f4852a99fc70aade625c2a929de943530615/modules/query.js">comparison</a> |
<a href="/comm-central/log/fc01f4852a99fc70aade625c2a929de943530615/modules/query.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -134,17 +134,17 @@ var GlodaCollectionManager = {</span>
<a href="#l1.4"></a><span id="l1.4">     </span>
<a href="#l1.5"></a><span id="l1.5">     return null;</span>
<a href="#l1.6"></a><span id="l1.6">   },</span>
<a href="#l1.7"></a><span id="l1.7"> </span>
<a href="#l1.8"></a><span id="l1.8">   /**</span>
<a href="#l1.9"></a><span id="l1.9">    * Lookup multiple nouns by ID from the cache/existing collections.</span>
<a href="#l1.10"></a><span id="l1.10">    * @return [The number that were found, the number that were not found.]</span>
<a href="#l1.11"></a><span id="l1.11">    */</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  cacheLookupMany: function gloda_colm_cacheLookupOne(aNounID, aIDMap,</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  cacheLookupMany: function gloda_colm_cacheLookupMany(aNounID, aIDMap,</span>
<a href="#l1.14"></a><span id="l1.14">       aDoCache) {</span>
<a href="#l1.15"></a><span id="l1.15">     let foundCount = 0, notFoundCount = 0, notFound = {};</span>
<a href="#l1.16"></a><span id="l1.16">     </span>
<a href="#l1.17"></a><span id="l1.17">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l1.18"></a><span id="l1.18">     </span>
<a href="#l1.19"></a><span id="l1.19">     if (cache) {</span>
<a href="#l1.20"></a><span id="l1.20">       for (let key in aIDMap) {</span>
<a href="#l1.21"></a><span id="l1.21">         let cacheValue = cache._idMap[key];</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -440,27 +440,32 @@ function GlodaCollection(aNounDef, aItem</span>
<a href="#l1.23"></a><span id="l1.23"> </span>
<a href="#l1.24"></a><span id="l1.24">   this.pendingItems = [];</span>
<a href="#l1.25"></a><span id="l1.25">   this.items = [];</span>
<a href="#l1.26"></a><span id="l1.26">   this._idMap = {};</span>
<a href="#l1.27"></a><span id="l1.27">   </span>
<a href="#l1.28"></a><span id="l1.28">   // force the listener to null for our call to _onItemsAdded; no events for</span>
<a href="#l1.29"></a><span id="l1.29">   //  the initial load-out.</span>
<a href="#l1.30"></a><span id="l1.30">   this._listener = null;</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-  this._onItemsAdded(items);</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+  if (aItems &amp;&amp; aItems.length)</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+    this._onItemsAdded(aItems);</span>
<a href="#l1.34"></a><span id="l1.34">   </span>
<a href="#l1.35"></a><span id="l1.35">   this.query = aQuery || null;</span>
<a href="#l1.36"></a><span id="l1.36">   this._listener = aListener || null;</span>
<a href="#l1.37"></a><span id="l1.37">   </span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+  this.deferredCount = 0;</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+  this.resolvedCount = 0;</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+  </span>
<a href="#l1.41"></a><span id="l1.41">   if (aMasterCollection) {</span>
<a href="#l1.42"></a><span id="l1.42">     this.masterCollection = aMasterCollection;</span>
<a href="#l1.43"></a><span id="l1.43">   }</span>
<a href="#l1.44"></a><span id="l1.44">   else {</span>
<a href="#l1.45"></a><span id="l1.45">     this.masterCollection = this;</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineminus">-    this.referencesByNounDef = {};</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+    this.referencesByNounID = {};</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+    this.inverseReferencesByNounID = {};</span>
<a href="#l1.49"></a><span id="l1.49">     this.subCollections = {};</span>
<a href="#l1.50"></a><span id="l1.50">   }</span>
<a href="#l1.51"></a><span id="l1.51"> }</span>
<a href="#l1.52"></a><span id="l1.52"> </span>
<a href="#l1.53"></a><span id="l1.53"> GlodaCollection.prototype = {</span>
<a href="#l1.54"></a><span id="l1.54">   get listener() { return this._listener; },</span>
<a href="#l1.55"></a><span id="l1.55">   set listener(aListener) { this._listener = aListener; },</span>
<a href="#l1.56"></a><span id="l1.56">   </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -30,17 +30,17 @@</span>
<a href="#l2.4"></a><span id="l2.4">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l2.5"></a><span id="l2.5">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l2.6"></a><span id="l2.6">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l2.7"></a><span id="l2.7">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l2.8"></a><span id="l2.8">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l2.9"></a><span id="l2.9">  *</span>
<a href="#l2.10"></a><span id="l2.10">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-EXPORTED_SYMBOLS = [&quot;GlodaAttributeDef&quot;,</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+EXPORTED_SYMBOLS = [&quot;GlodaAttributeDBDef&quot;,</span>
<a href="#l2.14"></a><span id="l2.14">                     &quot;GlodaConversation&quot;, &quot;GlodaFolder&quot;, &quot;GlodaMessage&quot;,</span>
<a href="#l2.15"></a><span id="l2.15">                     &quot;GlodaContact&quot;, &quot;GlodaIdentity&quot;];</span>
<a href="#l2.16"></a><span id="l2.16"> </span>
<a href="#l2.17"></a><span id="l2.17"> const Cc = Components.classes;</span>
<a href="#l2.18"></a><span id="l2.18"> const Ci = Components.interfaces;</span>
<a href="#l2.19"></a><span id="l2.19"> const Cr = Components.results;</span>
<a href="#l2.20"></a><span id="l2.20"> const Cu = Components.utils;</span>
<a href="#l2.21"></a><span id="l2.21"> </span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -53,31 +53,32 @@ Cu.import(&quot;resource://gloda/modules/util</span>
<a href="#l2.23"></a><span id="l2.23">  * @class Represents a gloda attribute definition's DB form.  This class</span>
<a href="#l2.24"></a><span id="l2.24">  *  stores the information in the database relating to this attribute</span>
<a href="#l2.25"></a><span id="l2.25">  *  definition.  Access its attrDef attribute to get at the realy juicy data.</span>
<a href="#l2.26"></a><span id="l2.26">  *  This main interesting thing this class does is serve as the keeper of the</span>
<a href="#l2.27"></a><span id="l2.27">  *  mapping from parameters to attribute ids in the database if this is a </span>
<a href="#l2.28"></a><span id="l2.28">  *  parameterized attribute.</span>
<a href="#l2.29"></a><span id="l2.29">  */</span>
<a href="#l2.30"></a><span id="l2.30"> function GlodaAttributeDBDef(aDatastore, aID, aCompoundName, aAttrType,</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-                           aPluginName, aAttrName) {</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+                           aPluginName, aNounName, aAttrName) {</span>
<a href="#l2.33"></a><span id="l2.33">   this._datastore = aDatastore;</span>
<a href="#l2.34"></a><span id="l2.34">   this._id = aID;</span>
<a href="#l2.35"></a><span id="l2.35">   this._compoundName = aCompoundName;</span>
<a href="#l2.36"></a><span id="l2.36">   this._attrType = aAttrType;</span>
<a href="#l2.37"></a><span id="l2.37">   this._pluginName = aPluginName;</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+  this._nounName = aNounName;</span>
<a href="#l2.39"></a><span id="l2.39">   this._attrName = aAttrName;</span>
<a href="#l2.40"></a><span id="l2.40">   </span>
<a href="#l2.41"></a><span id="l2.41">   this.attrDef = null;</span>
<a href="#l2.42"></a><span id="l2.42"> </span>
<a href="#l2.43"></a><span id="l2.43">   /** Map parameter values to the underlying database id. */</span>
<a href="#l2.44"></a><span id="l2.44">   this._parameterBindings = {};</span>
<a href="#l2.45"></a><span id="l2.45"> }</span>
<a href="#l2.46"></a><span id="l2.46"> </span>
<a href="#l2.47"></a><span id="l2.47" class="difflineminus">-GlodaAttributeDef.prototype = {</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+GlodaAttributeDBDef.prototype = {</span>
<a href="#l2.49"></a><span id="l2.49">   get id() { return this._id; },</span>
<a href="#l2.50"></a><span id="l2.50">   get attributeName() { return this._attrName; },</span>
<a href="#l2.51"></a><span id="l2.51"> </span>
<a href="#l2.52"></a><span id="l2.52">   get parameterBindings() { return this._parameterBindings; },</span>
<a href="#l2.53"></a><span id="l2.53">   </span>
<a href="#l2.54"></a><span id="l2.54">   /**</span>
<a href="#l2.55"></a><span id="l2.55">    * Bind a parameter value to the attribute definition, allowing use of the</span>
<a href="#l2.56"></a><span id="l2.56">    *  attribute-parameter as an attribute.</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineat">@@ -103,17 +104,17 @@ GlodaAttributeDef.prototype = {</span>
<a href="#l2.58"></a><span id="l2.58">   /**</span>
<a href="#l2.59"></a><span id="l2.59">    * Given a list of values (if non-singular) or a single value (if singular),</span>
<a href="#l2.60"></a><span id="l2.60">    *  return a list (regardless of plurality) of database-ready [attribute id,</span>
<a href="#l2.61"></a><span id="l2.61">    *  value] tuples.  This is intended to be used to directly convert the value</span>
<a href="#l2.62"></a><span id="l2.62">    *  of a property on an object that corresponds to a bound attribute.</span>
<a href="#l2.63"></a><span id="l2.63">    */</span>
<a href="#l2.64"></a><span id="l2.64">   convertValuesToDBAttributes:</span>
<a href="#l2.65"></a><span id="l2.65">       function gloda_attr_convertValuesToDBAttributes(aInstanceValues) {</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineminus">-    let nounDef = this._objectNounDef;</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+    let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l2.68"></a><span id="l2.68">     </span>
<a href="#l2.69"></a><span id="l2.69">     if (this._singular) {</span>
<a href="#l2.70"></a><span id="l2.70">       if (nounDef.usesParameter) {</span>
<a href="#l2.71"></a><span id="l2.71">         let [param, dbValue] = nounDef.toParamAndValue(aInstanceValues);</span>
<a href="#l2.72"></a><span id="l2.72">         return [[this.bindParameter(param), dbValue]];</span>
<a href="#l2.73"></a><span id="l2.73">       }</span>
<a href="#l2.74"></a><span id="l2.74">       else {</span>
<a href="#l2.75"></a><span id="l2.75">         return [[this._id, nounDef.toParamAndValue(aInstanceValues)[1]]];</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineat">@@ -137,115 +138,17 @@ GlodaAttributeDef.prototype = {</span>
<a href="#l2.77"></a><span id="l2.77">     }</span>
<a href="#l2.78"></a><span id="l2.78">   },</span>
<a href="#l2.79"></a><span id="l2.79"> </span>
<a href="#l2.80"></a><span id="l2.80">   toString: function() {</span>
<a href="#l2.81"></a><span id="l2.81">     return this._compoundName;</span>
<a href="#l2.82"></a><span id="l2.82">   }</span>
<a href="#l2.83"></a><span id="l2.83"> };</span>
<a href="#l2.84"></a><span id="l2.84"> </span>
<a href="#l2.85"></a><span id="l2.85" class="difflineminus">-</span>
<a href="#l2.86"></a><span id="l2.86"> let GlodaHasAttributesMixIn = {</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineminus">-  _attributes: null,</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineminus">-  /**</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineminus">-   * Return the (normalized, not stored on the row) attributes in a raw form,</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineminus">-   *  aka tuples of [attribute id, parameter, value].  If you want to</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineminus">-   *  generically know about the attributes available, use attributes.</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineminus">-   */</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineminus">-  get_rawAttributes: function() {</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineminus">-    if (this._attributes == null)</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineminus">-      this._attributes = this._datastore.getMessageAttributes(this);</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineminus">-    return this._attributes;</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineminus">-  },</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineminus">-</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineminus">-  /**</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineminus">-   * For consistency of caching with the bound attributes, we try and access the</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineminus">-   *  attributes through their bound names if they are bound.</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineminus">-   */</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineminus">-  get_attributes: function() {</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineminus">-    let seenDefs = {};</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineminus">-    let attribs = [];</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineminus">-    for each (let [iAPV, attrParamVal] in Iterator(this.rawAttributes)) {</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineminus">-      let attrDef = attrParamVal[0];</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineminus">-      if (!(attrDef in seenDefs)) {</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineminus">-        if (attrDef.isBound) {</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineminus">-          if (attrDef.singular) {</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineminus">-            attribs.push([attrDef, this[attrDef.boundName]]);</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineminus">-          }</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineminus">-          else {</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineminus">-            let values = this[attrDef.boundName];</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineminus">-            for (let iValue = 0; iValue &lt; values.length; iValue++)</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineminus">-              attribs.push([attrDef, values[iValue]]);</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineminus">-          }</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineminus">-          seenDefs[attrDef] = true;</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineminus">-        }</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineminus">-        else {</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineminus">-          // TODO: actually deal with unbound attributes</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineminus">-          LOG.info(&quot;unbound attribute ignored in traversal: &quot; + attrDef +</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineminus">-                   &quot; value: &quot; + attrParamVal[2]);</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineminus">-        }</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineminus">-      }</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineminus">-    }</span>
<a href="#l2.127"></a><span id="l2.127" class="difflineminus">-</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineminus">-    return attribs;</span>
<a href="#l2.129"></a><span id="l2.129" class="difflineminus">-  },</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineminus">-</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineminus">-  /**</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineminus">-   * Replace the set of attributes on us.  We need to make sure we purge</span>
<a href="#l2.133"></a><span id="l2.133" class="difflineminus">-   *  existing cached values off this instance.  For simplicity and because of</span>
<a href="#l2.134"></a><span id="l2.134" class="difflineminus">-   *  how we cache things currently (we define getters on the instance), we</span>
<a href="#l2.135"></a><span id="l2.135" class="difflineminus">-   *  force the prototype-resident getters to be activated and to cache</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineminus">-   *  everything anew.  This is arguably wasteful; it might be better to go</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineminus">-   *  back to just using storage properties, possibly on a sub-object that</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineminus">-   *  we could just replace with a new one...</span>
<a href="#l2.139"></a><span id="l2.139" class="difflineminus">-   * Note: We actually avoid doing this if the attributes weren't previously</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineminus">-   *  fetched.  Of course, since we do set _attributes with these new</span>
<a href="#l2.141"></a><span id="l2.141" class="difflineminus">-   *  attributes, this check does not steady-state.</span>
<a href="#l2.142"></a><span id="l2.142" class="difflineminus">-   *</span>
<a href="#l2.143"></a><span id="l2.143" class="difflineminus">-   * @XXX Try and avoid compelling ourselves to cache every bound attribute.</span>
<a href="#l2.144"></a><span id="l2.144" class="difflineminus">-   *  (If we stored the cached values in a sub-object, we could just trash the</span>
<a href="#l2.145"></a><span id="l2.145" class="difflineminus">-   *   sub-object.  This would imply a return to having the getters just create</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineminus">-   *   a storage field rather than creating magic getters.)</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineminus">-   */</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineminus">-  _replaceAttributes: function gloda_attrix_replaceAttributes(aNewAttribs) {</span>
<a href="#l2.149"></a><span id="l2.149" class="difflineminus">-    let hadAttributes = this._attributes !== null;</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineminus">-    this._attributes = aNewAttribs;</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineminus">-    // if this guy didn't already have attributes, we don't actually need to</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineminus">-    //  do any caching work.</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineminus">-    if (!hadAttributes)</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineminus">-      return;</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineminus">-</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineminus">-    let seenDefs = {};</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineminus">-    for each (let [iAPV, attrParamVal] in Iterator(this._attributes)) {</span>
<a href="#l2.158"></a><span id="l2.158" class="difflineminus">-      let attrDef = attrParamVal[0];</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineminus">-      if (!(attrDef in seenDefs)) {</span>
<a href="#l2.160"></a><span id="l2.160" class="difflineminus">-        if (attrDef.isBound) {</span>
<a href="#l2.161"></a><span id="l2.161" class="difflineminus">-          // get the getter from our _prototype_ (not us!)</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineminus">-          let getterFunc = this.__proto__.__lookupGetter__(attrDef.boundName);</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineminus">-          // force the getter to do his work (on us)</span>
<a href="#l2.164"></a><span id="l2.164" class="difflineminus">-          getterFunc.call(this);</span>
<a href="#l2.165"></a><span id="l2.165" class="difflineminus">-          seenDefs[attrDef] = true;</span>
<a href="#l2.166"></a><span id="l2.166" class="difflineminus">-        }</span>
<a href="#l2.167"></a><span id="l2.167" class="difflineminus">-      }</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineminus">-    }</span>
<a href="#l2.169"></a><span id="l2.169" class="difflineminus">-  },</span>
<a href="#l2.170"></a><span id="l2.170" class="difflineminus">-</span>
<a href="#l2.171"></a><span id="l2.171" class="difflineminus">-  getAttributeInstances: function gloda_attrix_getAttributeInstances(aAttr) {</span>
<a href="#l2.172"></a><span id="l2.172" class="difflineminus">-    return [attrParamVal for each</span>
<a href="#l2.173"></a><span id="l2.173" class="difflineminus">-            ([iAPV, attrParamVal] in Iterator(this.rawAttributes)) if</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineminus">-            (attrParamVal[0] == aAttr)];</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineminus">-  },</span>
<a href="#l2.176"></a><span id="l2.176" class="difflineminus">-</span>
<a href="#l2.177"></a><span id="l2.177" class="difflineminus">-  getSingleAttribute: function gloda_attrix_getSingleAttribute(aAttr) {</span>
<a href="#l2.178"></a><span id="l2.178" class="difflineminus">-    let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l2.179"></a><span id="l2.179" class="difflineminus">-    if (instances.length &gt; 0)</span>
<a href="#l2.180"></a><span id="l2.180" class="difflineminus">-      return instances[0];</span>
<a href="#l2.181"></a><span id="l2.181" class="difflineminus">-    else</span>
<a href="#l2.182"></a><span id="l2.182" class="difflineminus">-      return null;</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineminus">-  }</span>
<a href="#l2.184"></a><span id="l2.184"> };</span>
<a href="#l2.185"></a><span id="l2.185"> </span>
<a href="#l2.186"></a><span id="l2.186"> function MixIn(aConstructor, aMixIn) {</span>
<a href="#l2.187"></a><span id="l2.187">   let proto = aConstructor.prototype;</span>
<a href="#l2.188"></a><span id="l2.188">   for (let [name, func] in Iterator(aMixIn)) {</span>
<a href="#l2.189"></a><span id="l2.189">     if (name.substring(0, 4) == &quot;get_&quot;)</span>
<a href="#l2.190"></a><span id="l2.190">       proto.__defineGetter__(name.substring(4), func);</span>
<a href="#l2.191"></a><span id="l2.191">     else</span>
<a href="#l2.192"></a><span id="l2.192" class="difflineat">@@ -268,17 +171,17 @@ function GlodaConversation(aDatastore, a</span>
<a href="#l2.193"></a><span id="l2.193"> GlodaConversation.prototype = {</span>
<a href="#l2.194"></a><span id="l2.194">   NOUN_ID: 101,</span>
<a href="#l2.195"></a><span id="l2.195">   get id() { return this._id; },</span>
<a href="#l2.196"></a><span id="l2.196">   get subject() { return this._subject; },</span>
<a href="#l2.197"></a><span id="l2.197">   get oldestMessageDate() { return this._oldestMessageDate; },</span>
<a href="#l2.198"></a><span id="l2.198">   get newestMessageDate() { return this._newestMessageDate; },</span>
<a href="#l2.199"></a><span id="l2.199"> </span>
<a href="#l2.200"></a><span id="l2.200">   toString: function gloda_conversation_toString() {</span>
<a href="#l2.201"></a><span id="l2.201" class="difflineminus">-    return this._subject;</span>
<a href="#l2.202"></a><span id="l2.202" class="difflineplus">+    return &quot;Conversation:&quot; + this._id;</span>
<a href="#l2.203"></a><span id="l2.203">   },</span>
<a href="#l2.204"></a><span id="l2.204"> };</span>
<a href="#l2.205"></a><span id="l2.205"> </span>
<a href="#l2.206"></a><span id="l2.206"> function GlodaFolder(aDatastore, aID, aURI, aDirtyStatus, aPrettyName) {</span>
<a href="#l2.207"></a><span id="l2.207">   this._datastore = aDatastore;</span>
<a href="#l2.208"></a><span id="l2.208">   this._id = aID;</span>
<a href="#l2.209"></a><span id="l2.209">   this._uri = aURI;</span>
<a href="#l2.210"></a><span id="l2.210">   this._dirtyStatus = aDirtyStatus;</span>
<a href="#l2.211"></a><span id="l2.211" class="difflineat">@@ -300,34 +203,36 @@ GlodaFolder.prototype = {</span>
<a href="#l2.212"></a><span id="l2.212">   set dirtyStatus(aNewStatus) {</span>
<a href="#l2.213"></a><span id="l2.213">     if (aNewStatus != this._dirtyStatus) {</span>
<a href="#l2.214"></a><span id="l2.214">       this._dirtyStatus = aNewStatus;</span>
<a href="#l2.215"></a><span id="l2.215">       this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l2.216"></a><span id="l2.216">     }</span>
<a href="#l2.217"></a><span id="l2.217">   },</span>
<a href="#l2.218"></a><span id="l2.218">   get name() { return this._prettyName; },</span>
<a href="#l2.219"></a><span id="l2.219">   toString: function gloda_folder_toString() {</span>
<a href="#l2.220"></a><span id="l2.220" class="difflineminus">-    return this._prettyName;</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineplus">+    return &quot;Folder:&quot; + this._id;</span>
<a href="#l2.222"></a><span id="l2.222">   }</span>
<a href="#l2.223"></a><span id="l2.223"> }</span>
<a href="#l2.224"></a><span id="l2.224"> </span>
<a href="#l2.225"></a><span id="l2.225"> /**</span>
<a href="#l2.226"></a><span id="l2.226">  * @class A message representation.</span>
<a href="#l2.227"></a><span id="l2.227">  */</span>
<a href="#l2.228"></a><span id="l2.228"> function GlodaMessage(aDatastore, aID, aFolderID, aMessageKey,</span>
<a href="#l2.229"></a><span id="l2.229">                       aConversationID, aConversation, aDate,</span>
<a href="#l2.230"></a><span id="l2.230" class="difflineminus">-                      aHeaderMessageID, aDeleted) {</span>
<a href="#l2.231"></a><span id="l2.231" class="difflineplus">+                      aHeaderMessageID, aDeleted, aJsonText) {</span>
<a href="#l2.232"></a><span id="l2.232">   this._datastore = aDatastore;</span>
<a href="#l2.233"></a><span id="l2.233">   this._id = aID;</span>
<a href="#l2.234"></a><span id="l2.234">   this._folderID = aFolderID;</span>
<a href="#l2.235"></a><span id="l2.235">   this._messageKey = aMessageKey;</span>
<a href="#l2.236"></a><span id="l2.236">   this._conversationID = aConversationID;</span>
<a href="#l2.237"></a><span id="l2.237">   this._conversation = aConversation;</span>
<a href="#l2.238"></a><span id="l2.238">   this._date = aDate;</span>
<a href="#l2.239"></a><span id="l2.239">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l2.240"></a><span id="l2.240" class="difflineplus">+  if (aJsonText)</span>
<a href="#l2.241"></a><span id="l2.241" class="difflineplus">+    this._jsonText = aJsonText;</span>
<a href="#l2.242"></a><span id="l2.242"> </span>
<a href="#l2.243"></a><span id="l2.243">   // only set _deleted if we're deleted, otherwise the undefined does our</span>
<a href="#l2.244"></a><span id="l2.244">   //  speaking for us.</span>
<a href="#l2.245"></a><span id="l2.245">   if (aDeleted)</span>
<a href="#l2.246"></a><span id="l2.246">     this._deleted = aDeleted;</span>
<a href="#l2.247"></a><span id="l2.247"> }</span>
<a href="#l2.248"></a><span id="l2.248"> </span>
<a href="#l2.249"></a><span id="l2.249"> GlodaMessage.prototype = {</span>
<a href="#l2.250"></a><span id="l2.250" class="difflineat">@@ -353,21 +258,21 @@ GlodaMessage.prototype = {</span>
<a href="#l2.251"></a><span id="l2.251">       this._conversation = this._datastore.getConversationByID(</span>
<a href="#l2.252"></a><span id="l2.252">         this._conversationID);</span>
<a href="#l2.253"></a><span id="l2.253">     }</span>
<a href="#l2.254"></a><span id="l2.254">     return this._conversation;</span>
<a href="#l2.255"></a><span id="l2.255">   },</span>
<a href="#l2.256"></a><span id="l2.256"> </span>
<a href="#l2.257"></a><span id="l2.257">   toString: function gloda_message_toString() {</span>
<a href="#l2.258"></a><span id="l2.258">     // uh, this is a tough one...</span>
<a href="#l2.259"></a><span id="l2.259" class="difflineminus">-    return &quot;Message &quot; + this._id;</span>
<a href="#l2.260"></a><span id="l2.260" class="difflineplus">+    return &quot;Message:&quot; + this._id;</span>
<a href="#l2.261"></a><span id="l2.261">   },</span>
<a href="#l2.262"></a><span id="l2.262"> </span>
<a href="#l2.263"></a><span id="l2.263">   _clone: function gloda_message_clone() {</span>
<a href="#l2.264"></a><span id="l2.264" class="difflineminus">-    return new GlodaMessage(this._datastore, this._id, this._folderId,</span>
<a href="#l2.265"></a><span id="l2.265" class="difflineplus">+    return new GlodaMessage(this._datastore, this._id, this._folderID,</span>
<a href="#l2.266"></a><span id="l2.266">       this._messageKey, this._conversationID, this._conversation, this._date,</span>
<a href="#l2.267"></a><span id="l2.267">       this._headerMessageID, this._deleted);</span>
<a href="#l2.268"></a><span id="l2.268">   },</span>
<a href="#l2.269"></a><span id="l2.269"> </span>
<a href="#l2.270"></a><span id="l2.270">   _ghost: function gloda_message_ghost() {</span>
<a href="#l2.271"></a><span id="l2.271">     this._folderID = null;</span>
<a href="#l2.272"></a><span id="l2.272">     this._messageKey = null;</span>
<a href="#l2.273"></a><span id="l2.273">   },</span>
<a href="#l2.274"></a><span id="l2.274" class="difflineat">@@ -427,24 +332,26 @@ GlodaMessage.prototype = {</span>
<a href="#l2.275"></a><span id="l2.275"> };</span>
<a href="#l2.276"></a><span id="l2.276"> MixIn(GlodaMessage, GlodaHasAttributesMixIn);</span>
<a href="#l2.277"></a><span id="l2.277"> </span>
<a href="#l2.278"></a><span id="l2.278"> /**</span>
<a href="#l2.279"></a><span id="l2.279">  * @class Contacts correspond to people (one per person), and may own multiple</span>
<a href="#l2.280"></a><span id="l2.280">  *  identities (e-mail address, IM account, etc.)</span>
<a href="#l2.281"></a><span id="l2.281">  */</span>
<a href="#l2.282"></a><span id="l2.282"> function GlodaContact(aDatastore, aID, aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l2.283"></a><span id="l2.283" class="difflineminus">-                      aPopularity, aFrecency) {</span>
<a href="#l2.284"></a><span id="l2.284" class="difflineplus">+                      aPopularity, aFrecency, aJsonText) {</span>
<a href="#l2.285"></a><span id="l2.285">   this._datastore = aDatastore;</span>
<a href="#l2.286"></a><span id="l2.286">   this._id = aID;</span>
<a href="#l2.287"></a><span id="l2.287">   this._directoryUUID = aDirectoryUUID;</span>
<a href="#l2.288"></a><span id="l2.288">   this._contactUUID = aContactUUID;</span>
<a href="#l2.289"></a><span id="l2.289">   this._name = aName;</span>
<a href="#l2.290"></a><span id="l2.290">   this._popularity = aPopularity;</span>
<a href="#l2.291"></a><span id="l2.291">   this._frecency = aFrecency;</span>
<a href="#l2.292"></a><span id="l2.292" class="difflineplus">+  if (aJsonText)</span>
<a href="#l2.293"></a><span id="l2.293" class="difflineplus">+    this._jsonText = aJsonText;</span>
<a href="#l2.294"></a><span id="l2.294"> </span>
<a href="#l2.295"></a><span id="l2.295">   this._identities = null;</span>
<a href="#l2.296"></a><span id="l2.296"> }</span>
<a href="#l2.297"></a><span id="l2.297"> </span>
<a href="#l2.298"></a><span id="l2.298"> GlodaContact.prototype = {</span>
<a href="#l2.299"></a><span id="l2.299">   NOUN_ID: 103,</span>
<a href="#l2.300"></a><span id="l2.300"> </span>
<a href="#l2.301"></a><span id="l2.301">   get id() { return this._id; },</span>
<a href="#l2.302"></a><span id="l2.302" class="difflineat">@@ -461,27 +368,25 @@ GlodaContact.prototype = {</span>
<a href="#l2.303"></a><span id="l2.303"> </span>
<a href="#l2.304"></a><span id="l2.304">   get frecency() { return this._frecency; },</span>
<a href="#l2.305"></a><span id="l2.305">   set frecency(aFrecency) {</span>
<a href="#l2.306"></a><span id="l2.306">     this._frecency = aFrecency;</span>
<a href="#l2.307"></a><span id="l2.307">     this.dirty = true;</span>
<a href="#l2.308"></a><span id="l2.308">   },</span>
<a href="#l2.309"></a><span id="l2.309"> </span>
<a href="#l2.310"></a><span id="l2.310">   get identities() {</span>
<a href="#l2.311"></a><span id="l2.311" class="difflineminus">-    if (this._identities === null)</span>
<a href="#l2.312"></a><span id="l2.312" class="difflineminus">-      this._identities = this._datastore.getIdentitiesByContactID(this._id);</span>
<a href="#l2.313"></a><span id="l2.313">     return this._identities;</span>
<a href="#l2.314"></a><span id="l2.314">   },</span>
<a href="#l2.315"></a><span id="l2.315"> </span>
<a href="#l2.316"></a><span id="l2.316">   toString: function gloda_contact_toString() {</span>
<a href="#l2.317"></a><span id="l2.317">     return this._name;</span>
<a href="#l2.318"></a><span id="l2.318">   },</span>
<a href="#l2.319"></a><span id="l2.319">   </span>
<a href="#l2.320"></a><span id="l2.320">   get accessibleLabel() {</span>
<a href="#l2.321"></a><span id="l2.321" class="difflineminus">-    return &quot;Contact: &quot; + this._name;</span>
<a href="#l2.322"></a><span id="l2.322" class="difflineplus">+    return &quot;Contact:&quot; + this._id;</span>
<a href="#l2.323"></a><span id="l2.323">   },</span>
<a href="#l2.324"></a><span id="l2.324"> </span>
<a href="#l2.325"></a><span id="l2.325">   _clone: function gloda_contact_clone() {</span>
<a href="#l2.326"></a><span id="l2.326">     return new GlodaContact(this._datastore, this._id, this._directoryUUID,</span>
<a href="#l2.327"></a><span id="l2.327">       this._contactUUID, this._name, this._popularity, this._frecency);</span>
<a href="#l2.328"></a><span id="l2.328">   },</span>
<a href="#l2.329"></a><span id="l2.329"> };</span>
<a href="#l2.330"></a><span id="l2.330"> MixIn(GlodaContact, GlodaHasAttributesMixIn);</span>
<a href="#l2.331"></a><span id="l2.331" class="difflineat">@@ -501,33 +406,28 @@ function GlodaIdentity(aDatastore, aID, </span>
<a href="#l2.332"></a><span id="l2.332">   this._description = aDescription;</span>
<a href="#l2.333"></a><span id="l2.333">   this._isRelay = aIsRelay;</span>
<a href="#l2.334"></a><span id="l2.334"> }</span>
<a href="#l2.335"></a><span id="l2.335"> </span>
<a href="#l2.336"></a><span id="l2.336"> GlodaIdentity.prototype = {</span>
<a href="#l2.337"></a><span id="l2.337">   NOUN_ID: 104,</span>
<a href="#l2.338"></a><span id="l2.338">   get id() { return this._id; },</span>
<a href="#l2.339"></a><span id="l2.339">   get contactID() { return this._contactID; },</span>
<a href="#l2.340"></a><span id="l2.340" class="difflineplus">+  get contact() { return this._contact; },</span>
<a href="#l2.341"></a><span id="l2.341">   get kind() { return this._kind; },</span>
<a href="#l2.342"></a><span id="l2.342">   get value() { return this._value; },</span>
<a href="#l2.343"></a><span id="l2.343">   get description() { return this._description; },</span>
<a href="#l2.344"></a><span id="l2.344">   get isRelay() { return this._isRelay; },</span>
<a href="#l2.345"></a><span id="l2.345"> </span>
<a href="#l2.346"></a><span id="l2.346">   get uniqueValue() {</span>
<a href="#l2.347"></a><span id="l2.347">     return this._kind + &quot;@&quot; + this._value;</span>
<a href="#l2.348"></a><span id="l2.348">   },</span>
<a href="#l2.349"></a><span id="l2.349"> </span>
<a href="#l2.350"></a><span id="l2.350" class="difflineminus">-  get contact() {</span>
<a href="#l2.351"></a><span id="l2.351" class="difflineminus">-    if (this._contact === null)</span>
<a href="#l2.352"></a><span id="l2.352" class="difflineminus">-      this._contact = this._datastore.getContactByID(this._contactID);</span>
<a href="#l2.353"></a><span id="l2.353" class="difflineminus">-    return this._contact;</span>
<a href="#l2.354"></a><span id="l2.354" class="difflineminus">-  },</span>
<a href="#l2.355"></a><span id="l2.355" class="difflineminus">-</span>
<a href="#l2.356"></a><span id="l2.356">   toString: function gloda_identity_toString() {</span>
<a href="#l2.357"></a><span id="l2.357" class="difflineminus">-    return this._value;</span>
<a href="#l2.358"></a><span id="l2.358" class="difflineplus">+    return &quot;Identity:&quot; + this._kind + &quot;:&quot; + this._value;</span>
<a href="#l2.359"></a><span id="l2.359">   },</span>
<a href="#l2.360"></a><span id="l2.360"> </span>
<a href="#l2.361"></a><span id="l2.361">   get abCard() {</span>
<a href="#l2.362"></a><span id="l2.362">     return GlodaUtils.getCardForEmail(this._value);</span>
<a href="#l2.363"></a><span id="l2.363">   },</span>
<a href="#l2.364"></a><span id="l2.364">   </span>
<a href="#l2.365"></a><span id="l2.365">   pictureURL: function(aSize) {</span>
<a href="#l2.366"></a><span id="l2.366">     let md5hash = GlodaUtils.md5HashString(this._value);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -48,68 +48,51 @@ const Cr = Components.results;</span>
<a href="#l3.4"></a><span id="l3.4"> const Cu = Components.utils;</span>
<a href="#l3.5"></a><span id="l3.5"> </span>
<a href="#l3.6"></a><span id="l3.6"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8"> Cu.import(&quot;resource://gloda/modules/datamodel.js&quot;);</span>
<a href="#l3.9"></a><span id="l3.9"> Cu.import(&quot;resource://gloda/modules/databind.js&quot;);</span>
<a href="#l3.10"></a><span id="l3.10"> Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+let MBM_LOG = Log4Moz.Service.getLogger(&quot;gloda.ds.mbm&quot;);</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+</span>
<a href="#l3.14"></a><span id="l3.14"> /**</span>
<a href="#l3.15"></a><span id="l3.15">  * @class This callback handles processing the asynchronous query results of</span>
<a href="#l3.16"></a><span id="l3.16">  *  GlodaDatastore.getMessagesByMessageID.  Because that method is only</span>
<a href="#l3.17"></a><span id="l3.17">  *  called as part of the indexing process, we are guaranteed that there will</span>
<a href="#l3.18"></a><span id="l3.18">  *  be no real caching ramifications.  Accordingly, we can also defer our cache</span>
<a href="#l3.19"></a><span id="l3.19">  *  processing (via GlodaCollectionManager) until the query completes.</span>
<a href="#l3.20"></a><span id="l3.20">  *</span>
<a href="#l3.21"></a><span id="l3.21">  * @param aMsgIDToIndex Map from message-id to the desired</span>
<a href="#l3.22"></a><span id="l3.22">  *</span>
<a href="#l3.23"></a><span id="l3.23">  * @constructor</span>
<a href="#l3.24"></a><span id="l3.24">  */</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineminus">-function MessagesByMessageIdCallback(aStatement, aMsgIDToIndex, aResults,</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineminus">-                                     aCallback, aCallbackThis, aCallbackArgs) {</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineminus">-  this.statement = aStatement;</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+function MessagesByMessageIdCallback(aMsgIDToIndex, aResults,</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+                                     aCallback, aCallbackThis) {</span>
<a href="#l3.30"></a><span id="l3.30">   this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l3.31"></a><span id="l3.31">   this.results = aResults;</span>
<a href="#l3.32"></a><span id="l3.32">   this.callback = aCallback;</span>
<a href="#l3.33"></a><span id="l3.33">   this.callbackThis = aCallbackThis;</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineminus">-  this.callbackArgs = aCallbackArgs;</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineminus">-</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineminus">-  GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l3.37"></a><span id="l3.37"> }</span>
<a href="#l3.38"></a><span id="l3.38"> </span>
<a href="#l3.39"></a><span id="l3.39"> MessagesByMessageIdCallback.prototype = {</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineminus">-  handleResult: function gloda_ds_mbmi_handleResult(aResultSet) {</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineminus">-    let row;</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineminus">-    while (row = aResultSet.getNextRow()) {</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineminus">-      let message = GlodaDatastore._messageFromRow(row);</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+  onItemsAdded: function gloda_ds_mbmi_onItemsAdded(aItems, aCollection) {</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+    MBM_LOG.debug(&quot;getting results...&quot;);</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+    for each (let [, message] in Iterator(aItems)) {</span>
<a href="#l3.47"></a><span id="l3.47">       this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l3.48"></a><span id="l3.48">     }</span>
<a href="#l3.49"></a><span id="l3.49">   },</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineminus">-</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineminus">-  handleError: function gloda_ds_mbmi_handleError(aError) {</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineminus">-    GlodaDatastore._log.error(&quot;Async getMessagesByMessageId error: &quot; +</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineminus">-      aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineminus">-  },</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+  onItemsModified: function () {},</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+  onItemsRemoved: function () {},</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+  onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+    MBM_LOG.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+    // we no longer need to unify; it is done for us.</span>
<a href="#l3.60"></a><span id="l3.60"> </span>
<a href="#l3.61"></a><span id="l3.61" class="difflineminus">-  handleCompletion: function gloda_ds_mbmi_handleCompletion(aReason) {</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineminus">-    for (let iResult = 0; iResult &lt; this.results.length; iResult++) {</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineminus">-      if (this.results[iResult].length)</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineminus">-        GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineminus">-                                              this.results[iResult]);</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineminus">-    }</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineminus">-</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineminus">-    let args = [this.results].concat(this.callbackArgs);</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-    this.statement.finalize();</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-    this.statement = null;</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineminus">-</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineminus">-    this.callback.apply(this.callbackThis, args);</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineminus">-</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineminus">-    GlodaDatastore._asyncCompleted();</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+    this.callback.call(this.callbackThis, this.results);</span>
<a href="#l3.77"></a><span id="l3.77">   }</span>
<a href="#l3.78"></a><span id="l3.78"> };</span>
<a href="#l3.79"></a><span id="l3.79"> </span>
<a href="#l3.80"></a><span id="l3.80"> function PostCommitHandler(aCallbacks) {</span>
<a href="#l3.81"></a><span id="l3.81">   this.callbacks = aCallbacks;</span>
<a href="#l3.82"></a><span id="l3.82"> }</span>
<a href="#l3.83"></a><span id="l3.83"> </span>
<a href="#l3.84"></a><span id="l3.84"> PostCommitHandler.prototype = {</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineat">@@ -133,24 +116,37 @@ PostCommitHandler.prototype = {</span>
<a href="#l3.86"></a><span id="l3.86">     }</span>
<a href="#l3.87"></a><span id="l3.87">     GlodaDatastore._asyncCompleted();</span>
<a href="#l3.88"></a><span id="l3.88">   }</span>
<a href="#l3.89"></a><span id="l3.89"> };</span>
<a href="#l3.90"></a><span id="l3.90"> </span>
<a href="#l3.91"></a><span id="l3.91"> let QFQ_LOG = Log4Moz.Service.getLogger(&quot;gloda.ds.qfq&quot;);</span>
<a href="#l3.92"></a><span id="l3.92"> </span>
<a href="#l3.93"></a><span id="l3.93"> let QueryFromQueryResolver = {</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineminus">-  onItemsAdded: function(aItems, aCollection) {</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+  onItemsAdded: function(aItems, aCollection, aFake) {</span>
<a href="#l3.96"></a><span id="l3.96">     let originColl = aCollection.data;</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineminus">-    let referencesByNounDef = originColl.masterCollection.referencesbyNounDef;</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+    if (!aFake) {</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+      originColl.deferredCount--;</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+      originColl.resolvedCount++;</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+    }</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+    </span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+    // bail if we are still pending on some other load completion</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+    if (originColl.deferredCount &gt; 0)</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+      return;</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+    </span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+    let referencesByNounID = originColl.masterCollection.referencesByNounID;</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+    let inverseReferencesByNounID = </span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+      originColl.masterCollection.inverseReferencesByNounID</span>
<a href="#l3.111"></a><span id="l3.111"> </span>
<a href="#l3.112"></a><span id="l3.112">     QFQ_LOG.debug(&quot;QFQR: onItemsAdded: &quot; + originColl._nounDef.name);</span>
<a href="#l3.113"></a><span id="l3.113">     </span>
<a href="#l3.114"></a><span id="l3.114">     for (let [, item] in Iterator(originColl.pendingItems)) {</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineminus">-      GlodaDatastore.loadNounDeferredDeps(item, referencesByNounDef);</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineplus">+      GlodaDatastore.loadNounDeferredDeps(item, referencesByNounID,</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+          inverseReferencesByNounID);</span>
<a href="#l3.118"></a><span id="l3.118">     }</span>
<a href="#l3.119"></a><span id="l3.119">     </span>
<a href="#l3.120"></a><span id="l3.120">     // we need to consider the possibility that we are racing a collection very</span>
<a href="#l3.121"></a><span id="l3.121">     //  much like our own.  as such, this means we need to perform cache</span>
<a href="#l3.122"></a><span id="l3.122">     //  unification as our last step.</span>
<a href="#l3.123"></a><span id="l3.123">     GlodaCollectionManager.cacheLoadUnify(originColl._nounDef.id,</span>
<a href="#l3.124"></a><span id="l3.124">       originColl.pendingItems, false);</span>
<a href="#l3.125"></a><span id="l3.125"> </span>
<a href="#l3.126"></a><span id="l3.126" class="difflineat">@@ -174,46 +170,52 @@ let QueryFromQueryResolver = {</span>
<a href="#l3.127"></a><span id="l3.127">  * @class Handles the results from a GlodaDatastore.queryFromQuery call.</span>
<a href="#l3.128"></a><span id="l3.128">  * @constructor</span>
<a href="#l3.129"></a><span id="l3.129">  */</span>
<a href="#l3.130"></a><span id="l3.130"> function QueryFromQueryCallback(aStatement, aNounDef, aCollection) {</span>
<a href="#l3.131"></a><span id="l3.131">   this.statement = aStatement;</span>
<a href="#l3.132"></a><span id="l3.132">   this.nounDef = aNounDef;</span>
<a href="#l3.133"></a><span id="l3.133">   this.collection = aCollection;</span>
<a href="#l3.134"></a><span id="l3.134">   </span>
<a href="#l3.135"></a><span id="l3.135" class="difflineminus">-  // the master collection holds the referencesByNounDef</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineminus">-  this.referencesByNounDef =</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineminus">-    this.collection.masterCollection.referencesByNounDef;</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineplus">+  QFQ_LOG.debug(&quot;Creating QFQCallback for noun: &quot; + aNounDef.name);</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+  </span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+  // the master collection holds the referencesByNounID</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineplus">+  this.referencesByNounID =</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineplus">+    this.collection.masterCollection.referencesByNounID;</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+  this.inverseReferencesByNounID =</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineplus">+    this.collection.masterCollection.inverseReferencesByNounID;</span>
<a href="#l3.145"></a><span id="l3.145">   // we need to contribute our references as we load things; we need this </span>
<a href="#l3.146"></a><span id="l3.146">   //  because of the potential for circular dependencies and our inability to</span>
<a href="#l3.147"></a><span id="l3.147">   //  put things into the caching layer (or collection's _idMap) until we have</span>
<a href="#l3.148"></a><span id="l3.148">   //  fully resolved things.</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineminus">-  if (this.nounDef in this.referencesByNounDef)</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineminus">-    this.selfReferences = this.referencesByNounDef[this.nounDef];</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+  if (this.nounDef.id in this.referencesByNounID)</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineplus">+    this.selfReferences = this.referencesByNounID[this.nounDef.id];</span>
<a href="#l3.153"></a><span id="l3.153">   else</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineminus">-    this.selfReferences = this.referencesByNounDef[this.nounDef] = {};</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineplus">+    this.selfReferences = this.referencesByNounID[this.nounDef.id] = {};</span>
<a href="#l3.156"></a><span id="l3.156">   </span>
<a href="#l3.157"></a><span id="l3.157">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l3.158"></a><span id="l3.158"> }</span>
<a href="#l3.159"></a><span id="l3.159"> </span>
<a href="#l3.160"></a><span id="l3.160"> QueryFromQueryCallback.prototype = {</span>
<a href="#l3.161"></a><span id="l3.161">   handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l3.162"></a><span id="l3.162">     let pendingItems = this.collection.pendingItems;</span>
<a href="#l3.163"></a><span id="l3.163">     let row;</span>
<a href="#l3.164"></a><span id="l3.164">     let nounDef = this.nounDef;</span>
<a href="#l3.165"></a><span id="l3.165">     let nounID = nounDef.id;</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineminus">-    let thisReferences = this.referencesbyNounDef[nounDef];</span>
<a href="#l3.167"></a><span id="l3.167">     while (row = aResultSet.getNextRow()) {</span>
<a href="#l3.168"></a><span id="l3.168">       let item = nounDef.objFromRow.call(nounDef.datastore, row);</span>
<a href="#l3.169"></a><span id="l3.169">       // try and replace the item with one from the cache, if we can</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineminus">-      let cachedItem = GlodaCollection.cacheLookupOne(nounID, item.id, false);</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineplus">+      let cachedItem = GlodaCollectionManager.cacheLookupOne(nounID, item.id,</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+                                                             false);</span>
<a href="#l3.173"></a><span id="l3.173">       if (cachedItem)</span>
<a href="#l3.174"></a><span id="l3.174">         item = cachedItem;</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineminus">-      else // perform loading logic which may produce reference dependencies</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineminus">-        GlodaDatastore.loadNounItem(item, this.referencesByNounDef);</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+      // perform loading logic which may produce reference dependencies</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+      else if (nounDef.allowsArbitraryAttrs) </span>
<a href="#l3.179"></a><span id="l3.179" class="difflineplus">+        GlodaDatastore.loadNounItem(item, this.referencesByNounID,</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineplus">+            this.inverseReferencesByNounID);</span>
<a href="#l3.181"></a><span id="l3.181">       </span>
<a href="#l3.182"></a><span id="l3.182">       this.selfReferences[item.id] = item;</span>
<a href="#l3.183"></a><span id="l3.183">       pendingItems.push(item);</span>
<a href="#l3.184"></a><span id="l3.184">     }</span>
<a href="#l3.185"></a><span id="l3.185">   },</span>
<a href="#l3.186"></a><span id="l3.186"> </span>
<a href="#l3.187"></a><span id="l3.187">   handleError: function gloda_ds_qfq_handleError(aError) {</span>
<a href="#l3.188"></a><span id="l3.188">     GlodaDatastore._log.error(&quot;Async queryFromQuery error: &quot; +</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineat">@@ -221,48 +223,74 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l3.190"></a><span id="l3.190">   },</span>
<a href="#l3.191"></a><span id="l3.191"> </span>
<a href="#l3.192"></a><span id="l3.192">   handleCompletion: function gloda_ds_qfq_handleCompletion(aReason) {</span>
<a href="#l3.193"></a><span id="l3.193">     this.statement.finalize();</span>
<a href="#l3.194"></a><span id="l3.194">     this.statement = null;</span>
<a href="#l3.195"></a><span id="l3.195">     </span>
<a href="#l3.196"></a><span id="l3.196">     QFQ_LOG.debug(&quot;handleCompletion: &quot; + this.collection._nounDef.name);</span>
<a href="#l3.197"></a><span id="l3.197">     </span>
<a href="#l3.198"></a><span id="l3.198" class="difflineminus">-    let deferCount = 0;</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineminus">-    let resolvedCount = 0;</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineminus">-    for each (let [nounDef, references] in Iterator(this.referencesByNounDef)) {</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+    for each (let [nounID, references] in Iterator(this.referencesByNounID)) {</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+      if (nounID == this.nounDef.id)</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+        continue;</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+      let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineplus">+      QFQ_LOG.debug(&quot;  have references for noun: &quot; + nounDef.name);</span>
<a href="#l3.206"></a><span id="l3.206">       // try and load them out of the cache/existing collections.  items in the</span>
<a href="#l3.207"></a><span id="l3.207">       //  cache will be fully formed, which is nice for us.</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineplus">+      // XXX this mechanism will get dubious when we have multiple paths to a</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+      //  single noun-type.  For example, a -&gt; b -&gt; c, a-&gt; c; two paths to c</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+      //  and we're looking at issuing two requests to c, the latter of which</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+      //  will be a superset of the first one.  This does not currently pose</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+      //  a problem because we only have a -&gt; b -&gt; c -&gt; b, and sequential</span>
<a href="#l3.213"></a><span id="l3.213" class="difflineplus">+      //  processing means no alarms and no surprises.</span>
<a href="#l3.214"></a><span id="l3.214">       let [foundCount, notFoundCount, notFound] =</span>
<a href="#l3.215"></a><span id="l3.215" class="difflineminus">-        GlodaCollection.cacheLookupMany(nounID, references);</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+        GlodaCollectionManager.cacheLookupMany(nounDef.id, references);</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+      QFQ_LOG.debug(&quot;  found: &quot; + foundCount + &quot; not found: &quot; + notFoundCount);</span>
<a href="#l3.218"></a><span id="l3.218">       if (notFoundCount === 0) {</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineminus">-        resolvedCount++;</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+        this.collection.resolvedCount++;</span>
<a href="#l3.221"></a><span id="l3.221">       }</span>
<a href="#l3.222"></a><span id="l3.222">       else {</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineminus">-        deferCount++;</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineminus">-        let query = nounDef.queryClass();</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineminus">-        query.id.apply(query.id, [id for (id in notFound)]);</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineplus">+        this.collection.deferredCount++;</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineplus">+        let query = new nounDef.queryClass();</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineplus">+        query.id.apply(query, [id for (id in notFound)]);</span>
<a href="#l3.229"></a><span id="l3.229">         </span>
<a href="#l3.230"></a><span id="l3.230">         this.collection.masterCollection.subCollections[nounDef.id] = </span>
<a href="#l3.231"></a><span id="l3.231">           GlodaDatastore.queryFromQuery(query, null, this.collection,</span>
<a href="#l3.232"></a><span id="l3.232">             // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l3.233"></a><span id="l3.233">             this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l3.234"></a><span id="l3.234">             this.collection.masterCollection);</span>
<a href="#l3.235"></a><span id="l3.235">       }</span>
<a href="#l3.236"></a><span id="l3.236">     }</span>
<a href="#l3.237"></a><span id="l3.237">     </span>
<a href="#l3.238"></a><span id="l3.238" class="difflineminus">-    QFQ_LOG.debug(&quot;  defer: &quot; + deferCount + &quot; resolved: &quot; + resolvedCount);</span>
<a href="#l3.239"></a><span id="l3.239" class="difflineplus">+    for each (let [nounID, inverseReferencess] in</span>
<a href="#l3.240"></a><span id="l3.240" class="difflineplus">+        Iterator(this.inverseReferencesByNounID)) {</span>
<a href="#l3.241"></a><span id="l3.241" class="difflineplus">+      this.collection.deferredCount++;</span>
<a href="#l3.242"></a><span id="l3.242" class="difflineplus">+      let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l3.243"></a><span id="l3.243" class="difflineplus">+</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineplus">+      let query = nounDef.queryClass();</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineplus">+      // we want to constrain using the parent column</span>
<a href="#l3.246"></a><span id="l3.246" class="difflineplus">+      let queryConstrainer = query[nounDef.parentColumnAttr.boundName];</span>
<a href="#l3.247"></a><span id="l3.247" class="difflineplus">+      queryConstrainer.apply(query, [pid for (pid in inverseReferences)]);</span>
<a href="#l3.248"></a><span id="l3.248" class="difflineplus">+      this.collection.masterCollection.subCollections[nounDef.id] = </span>
<a href="#l3.249"></a><span id="l3.249" class="difflineplus">+        GlodaDatastore.queryFromQuery(query, null, this.collection,</span>
<a href="#l3.250"></a><span id="l3.250" class="difflineplus">+          // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l3.251"></a><span id="l3.251" class="difflineplus">+          this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l3.252"></a><span id="l3.252" class="difflineplus">+          this.collection.masterCollection);</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineplus">+    }</span>
<a href="#l3.254"></a><span id="l3.254" class="difflineplus">+    </span>
<a href="#l3.255"></a><span id="l3.255" class="difflineplus">+    QFQ_LOG.debug(&quot;  defer: &quot; + this.collection.deferredCount +</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineplus">+                  &quot; resolved: &quot; + this.collection.resolvedCount);</span>
<a href="#l3.257"></a><span id="l3.257">     </span>
<a href="#l3.258"></a><span id="l3.258">     // process immediately and kick-up to the master collection...</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineminus">-    if (!deferCount &amp;&amp; resolvedCount) {</span>
<a href="#l3.260"></a><span id="l3.260" class="difflineminus">-      // this guy will resolve everyone using referencesByNounDef and issue the</span>
<a href="#l3.261"></a><span id="l3.261" class="difflineplus">+    if (!this.collection.deferredCount) {</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineplus">+      // this guy will resolve everyone using referencesByNounID and issue the</span>
<a href="#l3.263"></a><span id="l3.263">       //  call to this.collection._onItemsAdded to propagate things to the</span>
<a href="#l3.264"></a><span id="l3.264">       //  next concerned subCollection or the actual listener if this is the</span>
<a href="#l3.265"></a><span id="l3.265">       //  master collection.  (Also, call _onQueryCompleted).</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineminus">-      QueryFromQueryResolver.onItemsAdded(null, {data: this.collection});</span>
<a href="#l3.267"></a><span id="l3.267" class="difflineplus">+      QueryFromQueryResolver.onItemsAdded(null, {data: this.collection}, true);</span>
<a href="#l3.268"></a><span id="l3.268">     }</span>
<a href="#l3.269"></a><span id="l3.269"> </span>
<a href="#l3.270"></a><span id="l3.270">     GlodaDatastore._asyncCompleted();</span>
<a href="#l3.271"></a><span id="l3.271">   }</span>
<a href="#l3.272"></a><span id="l3.272"> };</span>
<a href="#l3.273"></a><span id="l3.273"> </span>
<a href="#l3.274"></a><span id="l3.274"> </span>
<a href="#l3.275"></a><span id="l3.275"> /**</span>
<a href="#l3.276"></a><span id="l3.276" class="difflineat">@@ -355,19 +383,22 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l3.277"></a><span id="l3.277">  *  needs to be addressed, and may be best addressed at layers above</span>
<a href="#l3.278"></a><span id="l3.278">  *  datastore.js.</span>
<a href="#l3.279"></a><span id="l3.279">  * @namespace</span>
<a href="#l3.280"></a><span id="l3.280">  */</span>
<a href="#l3.281"></a><span id="l3.281"> var GlodaDatastore = {</span>
<a href="#l3.282"></a><span id="l3.282">   _log: null,</span>
<a href="#l3.283"></a><span id="l3.283"> </span>
<a href="#l3.284"></a><span id="l3.284">   /* see Gloda's documentation for these constants */</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineminus">-  kSpecialColumn: 1,</span>
<a href="#l3.286"></a><span id="l3.286" class="difflineminus">-  kSpecialString: 2,</span>
<a href="#l3.287"></a><span id="l3.287" class="difflineminus">-  kSpecialFulltext: 3,</span>
<a href="#l3.288"></a><span id="l3.288" class="difflineplus">+  kSpecialNotAtAll: 0,</span>
<a href="#l3.289"></a><span id="l3.289" class="difflineplus">+  kSpecialColumn: 16,</span>
<a href="#l3.290"></a><span id="l3.290" class="difflineplus">+  kSpecialColumnChildren: 16|1,</span>
<a href="#l3.291"></a><span id="l3.291" class="difflineplus">+  kSpecialColumnParent: 16|2,</span>
<a href="#l3.292"></a><span id="l3.292" class="difflineplus">+  kSpecialString: 32,</span>
<a href="#l3.293"></a><span id="l3.293" class="difflineplus">+  kSpecialFulltext: 64,</span>
<a href="#l3.294"></a><span id="l3.294">   </span>
<a href="#l3.295"></a><span id="l3.295">   kConstraintIdIn: 0,</span>
<a href="#l3.296"></a><span id="l3.296">   kConstraintIn: 1,</span>
<a href="#l3.297"></a><span id="l3.297">   kConstraintRanges: 2,</span>
<a href="#l3.298"></a><span id="l3.298">   kConstraintEquals: 3,</span>
<a href="#l3.299"></a><span id="l3.299">   kConstraintStringLike: 4,</span>
<a href="#l3.300"></a><span id="l3.300">   kConstraintFulltext: 5,</span>
<a href="#l3.301"></a><span id="l3.301"> </span>
<a href="#l3.302"></a><span id="l3.302" class="difflineat">@@ -564,65 +595,76 @@ var GlodaDatastore = {</span>
<a href="#l3.303"></a><span id="l3.303">    */</span>
<a href="#l3.304"></a><span id="l3.304">   asyncConnection: null,</span>
<a href="#l3.305"></a><span id="l3.305"> </span>
<a href="#l3.306"></a><span id="l3.306">   /**</span>
<a href="#l3.307"></a><span id="l3.307">    * Initialize logging, create the database if it doesn't exist, &quot;upgrade&quot; it</span>
<a href="#l3.308"></a><span id="l3.308">    *  if it does and it's not up-to-date, fill our authoritative folder uri/id</span>
<a href="#l3.309"></a><span id="l3.309">    *  mapping.</span>
<a href="#l3.310"></a><span id="l3.310">    */</span>
<a href="#l3.311"></a><span id="l3.311" class="difflineminus">-  _init: function gloda_ds_init(aNsJSON) {</span>
<a href="#l3.312"></a><span id="l3.312" class="difflineplus">+  _init: function gloda_ds_init(aNsJSON, aNounIDToDef) {</span>
<a href="#l3.313"></a><span id="l3.313">     this._log = Log4Moz.Service.getLogger(&quot;gloda.datastore&quot;);</span>
<a href="#l3.314"></a><span id="l3.314" class="difflineplus">+    this._log.debug(&quot;Beginning datastore initialization.&quot;);</span>
<a href="#l3.315"></a><span id="l3.315">     </span>
<a href="#l3.316"></a><span id="l3.316">     this._json = aNsJSON;</span>
<a href="#l3.317"></a><span id="l3.317" class="difflineplus">+    this._nounIDToDef = aNounIDToDef;</span>
<a href="#l3.318"></a><span id="l3.318"> </span>
<a href="#l3.319"></a><span id="l3.319">     // Get the path to our global database</span>
<a href="#l3.320"></a><span id="l3.320">     var dirService = Cc[&quot;@mozilla.org/file/directory_service;1&quot;].</span>
<a href="#l3.321"></a><span id="l3.321">                      getService(Ci.nsIProperties);</span>
<a href="#l3.322"></a><span id="l3.322">     var dbFile = dirService.get(&quot;ProfD&quot;, Ci.nsIFile);</span>
<a href="#l3.323"></a><span id="l3.323">     dbFile.append(&quot;global-messages-db.sqlite&quot;);</span>
<a href="#l3.324"></a><span id="l3.324"> </span>
<a href="#l3.325"></a><span id="l3.325">     // Get the storage (sqlite) service</span>
<a href="#l3.326"></a><span id="l3.326">     var dbService = Cc[&quot;@mozilla.org/storage/service;1&quot;].</span>
<a href="#l3.327"></a><span id="l3.327">                     getService(Ci.mozIStorageService);</span>
<a href="#l3.328"></a><span id="l3.328"> </span>
<a href="#l3.329"></a><span id="l3.329">     var dbConnection;</span>
<a href="#l3.330"></a><span id="l3.330"> </span>
<a href="#l3.331"></a><span id="l3.331">     // Create the file if it does not exist</span>
<a href="#l3.332"></a><span id="l3.332">     if (!dbFile.exists()) {</span>
<a href="#l3.333"></a><span id="l3.333" class="difflineplus">+      this._log.debug(&quot;Creating database because it does't exist.&quot;);</span>
<a href="#l3.334"></a><span id="l3.334">       dbConnection = this._createDB(dbService, dbFile);</span>
<a href="#l3.335"></a><span id="l3.335">     }</span>
<a href="#l3.336"></a><span id="l3.336">     // It does exist, but we (someday) might need to upgrade the schema</span>
<a href="#l3.337"></a><span id="l3.337">     else {</span>
<a href="#l3.338"></a><span id="l3.338">       // (Exceptions may be thrown if the database is corrupt)</span>
<a href="#l3.339"></a><span id="l3.339">       { // try {</span>
<a href="#l3.340"></a><span id="l3.340">         dbConnection = dbService.openUnsharedDatabase(dbFile);</span>
<a href="#l3.341"></a><span id="l3.341"> </span>
<a href="#l3.342"></a><span id="l3.342">         if (dbConnection.schemaVersion != this._schemaVersion) {</span>
<a href="#l3.343"></a><span id="l3.343" class="difflineplus">+          this._log.debug(&quot;Need to migrate database.  (DB version: &quot; +</span>
<a href="#l3.344"></a><span id="l3.344" class="difflineplus">+            dbConnection.schemaVersion + &quot; desired version: &quot; +</span>
<a href="#l3.345"></a><span id="l3.345" class="difflineplus">+            this._schemaVersion);</span>
<a href="#l3.346"></a><span id="l3.346">           dbConnection = this._migrate(dbService, dbFile,</span>
<a href="#l3.347"></a><span id="l3.347">                                        dbConnection,</span>
<a href="#l3.348"></a><span id="l3.348">                                        dbConnection.schemaVersion,</span>
<a href="#l3.349"></a><span id="l3.349">                                        this._schemaVersion);</span>
<a href="#l3.350"></a><span id="l3.350" class="difflineplus">+          this._log.debug(&quot;Migration completed.&quot;);</span>
<a href="#l3.351"></a><span id="l3.351">         }</span>
<a href="#l3.352"></a><span id="l3.352">       }</span>
<a href="#l3.353"></a><span id="l3.353">       // Handle corrupt databases, other oddities</span>
<a href="#l3.354"></a><span id="l3.354">       // ... in the future. for now, let us die</span>
<a href="#l3.355"></a><span id="l3.355">     }</span>
<a href="#l3.356"></a><span id="l3.356"> </span>
<a href="#l3.357"></a><span id="l3.357">     this.syncConnection = dbConnection;</span>
<a href="#l3.358"></a><span id="l3.358">     this.asyncConnection = dbService.openUnsharedDatabase(dbFile);</span>
<a href="#l3.359"></a><span id="l3.359"> </span>
<a href="#l3.360"></a><span id="l3.360" class="difflineplus">+    this._log.debug(&quot;Initializing folder mappings.&quot;);</span>
<a href="#l3.361"></a><span id="l3.361">     this._getAllFolderMappings();</span>
<a href="#l3.362"></a><span id="l3.362">     // we need to figure out the next id's for all of the tables where we</span>
<a href="#l3.363"></a><span id="l3.363">     //  manage that.</span>
<a href="#l3.364"></a><span id="l3.364" class="difflineplus">+    this._log.debug(&quot;Populating managed id counters.&quot;);</span>
<a href="#l3.365"></a><span id="l3.365">     this._populateAttributeDefManagedId();</span>
<a href="#l3.366"></a><span id="l3.366">     this._populateConversationManagedId();</span>
<a href="#l3.367"></a><span id="l3.367">     this._populateMessageManagedId();</span>
<a href="#l3.368"></a><span id="l3.368">     this._populateContactManagedId();</span>
<a href="#l3.369"></a><span id="l3.369">     this._populateIdentityManagedId();</span>
<a href="#l3.370"></a><span id="l3.370" class="difflineplus">+    </span>
<a href="#l3.371"></a><span id="l3.371" class="difflineplus">+    this._log.debug(&quot;Completed datastore initialization.&quot;);</span>
<a href="#l3.372"></a><span id="l3.372">   },</span>
<a href="#l3.373"></a><span id="l3.373"> </span>
<a href="#l3.374"></a><span id="l3.374">   /**</span>
<a href="#l3.375"></a><span id="l3.375">    * Initiate database shutdown; because this might requiring waiting for</span>
<a href="#l3.376"></a><span id="l3.376">    *  outstanding synchronous events to drain, we allow the caller to pass in</span>
<a href="#l3.377"></a><span id="l3.377">    *  a callback to invoke if we are unable to complete shutdown within this</span>
<a href="#l3.378"></a><span id="l3.378">    *  call.</span>
<a href="#l3.379"></a><span id="l3.379">    * @return true if we were able to shutdown fully, false if we were not.  The</span>
<a href="#l3.380"></a><span id="l3.380" class="difflineat">@@ -1059,17 +1101,17 @@ var GlodaDatastore = {</span>
<a href="#l3.381"></a><span id="l3.381">                                   name, parameter) \</span>
<a href="#l3.382"></a><span id="l3.382">               VALUES (?1, ?2, ?3, ?4, ?5)&quot;);</span>
<a href="#l3.383"></a><span id="l3.383">     this.__defineGetter__(&quot;_insertAttributeDefStatement&quot;, function() statement);</span>
<a href="#l3.384"></a><span id="l3.384">     return this._insertAttributeDefStatement;</span>
<a href="#l3.385"></a><span id="l3.385">   },</span>
<a href="#l3.386"></a><span id="l3.386"> </span>
<a href="#l3.387"></a><span id="l3.387">   /**</span>
<a href="#l3.388"></a><span id="l3.388">    * Create an attribute definition and return the row ID.  Special/atypical</span>
<a href="#l3.389"></a><span id="l3.389" class="difflineminus">-   *  in that it doesn't directly return a GlodaAttributeDef; we leave that up</span>
<a href="#l3.390"></a><span id="l3.390" class="difflineplus">+   *  in that it doesn't directly return a GlodaAttributeDBDef; we leave that up</span>
<a href="#l3.391"></a><span id="l3.391">    *  to the caller since they know much more than actually needs to go in the</span>
<a href="#l3.392"></a><span id="l3.392">    *  database.</span>
<a href="#l3.393"></a><span id="l3.393">    *</span>
<a href="#l3.394"></a><span id="l3.394">    * @return The attribute id allocated to this attribute.</span>
<a href="#l3.395"></a><span id="l3.395">    */</span>
<a href="#l3.396"></a><span id="l3.396">   _createAttributeDef: function gloda_ds_createAttributeDef(aAttrType,</span>
<a href="#l3.397"></a><span id="l3.397">                                     aExtensionName, aAttrName, aParameter) {</span>
<a href="#l3.398"></a><span id="l3.398">     let attributeId = this._nextAttributeId++;</span>
<a href="#l3.399"></a><span id="l3.399" class="difflineat">@@ -1136,17 +1178,17 @@ var GlodaDatastore = {</span>
<a href="#l3.400"></a><span id="l3.400"> </span>
<a href="#l3.401"></a><span id="l3.401">     this._log.info(&quot;done loading all attribute defs&quot;);</span>
<a href="#l3.402"></a><span id="l3.402"> </span>
<a href="#l3.403"></a><span id="l3.403">     this._attributeDBDefs = attribs;</span>
<a href="#l3.404"></a><span id="l3.404">     this._attributeIDToDBDefAndParam = idToAttribAndParam;</span>
<a href="#l3.405"></a><span id="l3.405">   },</span>
<a href="#l3.406"></a><span id="l3.406"> </span>
<a href="#l3.407"></a><span id="l3.407">   /**</span>
<a href="#l3.408"></a><span id="l3.408" class="difflineminus">-   * Helper method for GlodaAttributeDef to tell us when their bindParameter</span>
<a href="#l3.409"></a><span id="l3.409" class="difflineplus">+   * Helper method for GlodaAttributeDBDef to tell us when their bindParameter</span>
<a href="#l3.410"></a><span id="l3.410">    *  method is called and they have created a new binding (using</span>
<a href="#l3.411"></a><span id="l3.411">    *  GlodaDatastore._createAttributeDef).  In theory, that method could take</span>
<a href="#l3.412"></a><span id="l3.412">    *  an additional argument and obviate the need for this method.</span>
<a href="#l3.413"></a><span id="l3.413">    */</span>
<a href="#l3.414"></a><span id="l3.414">   reportBinding: function gloda_ds_reportBinding(aID, aAttrDef, aParamValue) {</span>
<a href="#l3.415"></a><span id="l3.415">     this._attributeIDToDBDefAndParam[aID] = [aAttrDef, aParamValue];</span>
<a href="#l3.416"></a><span id="l3.416">   },</span>
<a href="#l3.417"></a><span id="l3.417"> </span>
<a href="#l3.418"></a><span id="l3.418" class="difflineat">@@ -1208,27 +1250,28 @@ var GlodaDatastore = {</span>
<a href="#l3.419"></a><span id="l3.419">     let folderURI = aFolder.URI;</span>
<a href="#l3.420"></a><span id="l3.420">     if (folderURI in this._folderByURI) {</span>
<a href="#l3.421"></a><span id="l3.421">       return this._folderByURI[folderURI];</span>
<a href="#l3.422"></a><span id="l3.422">     }</span>
<a href="#l3.423"></a><span id="l3.423"> </span>
<a href="#l3.424"></a><span id="l3.424">     let folderID = this._nextFolderId++;</span>
<a href="#l3.425"></a><span id="l3.425">     </span>
<a href="#l3.426"></a><span id="l3.426">     let folder = new GlodaFolder(this, folderID, folderURI,</span>
<a href="#l3.427"></a><span id="l3.427" class="difflineminus">-      GlodaFolder.prototype.kFolderFilthy, aFolder.prettyName);</span>
<a href="#l3.428"></a><span id="l3.428" class="difflineplus">+      GlodaFolder.prototype.kFolderFilthy, aFolder.prettiestName);</span>
<a href="#l3.429"></a><span id="l3.429">     </span>
<a href="#l3.430"></a><span id="l3.430">     this._insertFolderLocationStatement.bindInt64Parameter(0, folder.id)</span>
<a href="#l3.431"></a><span id="l3.431">     this._insertFolderLocationStatement.bindStringParameter(1, folder.uri);</span>
<a href="#l3.432"></a><span id="l3.432">     this._insertFolderLocationStatement.bindInt64Parameter(2,</span>
<a href="#l3.433"></a><span id="l3.433">                                                            folder.dirtyStatus);</span>
<a href="#l3.434"></a><span id="l3.434">     this._insertFolderLocationStatement.bindStringParameter(3, folder.name);</span>
<a href="#l3.435"></a><span id="l3.435">     this._insertFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l3.436"></a><span id="l3.436"> </span>
<a href="#l3.437"></a><span id="l3.437" class="difflineminus">-    this._folderByURI[aFolderURI] = folder;</span>
<a href="#l3.438"></a><span id="l3.438" class="difflineplus">+    this._folderByURI[folderURI] = folder;</span>
<a href="#l3.439"></a><span id="l3.439">     this._folderByID[folderID] = folder;</span>
<a href="#l3.440"></a><span id="l3.440" class="difflineplus">+    this._log.debug(&quot;!! mapped &quot; + folder.id + &quot; from &quot; + folderURI);</span>
<a href="#l3.441"></a><span id="l3.441">     return folder;</span>
<a href="#l3.442"></a><span id="l3.442">   },</span>
<a href="#l3.443"></a><span id="l3.443"> </span>
<a href="#l3.444"></a><span id="l3.444">   _mapFolderID: function gloda_ds_mapFolderID(aFolderID) {</span>
<a href="#l3.445"></a><span id="l3.445">     if (aFolderID === null)</span>
<a href="#l3.446"></a><span id="l3.446">       return null;</span>
<a href="#l3.447"></a><span id="l3.447">     if (aFolderID in this._folderByID)</span>
<a href="#l3.448"></a><span id="l3.448">       return this._folderByID[aFolderID];</span>
<a href="#l3.449"></a><span id="l3.449" class="difflineat">@@ -1241,18 +1284,18 @@ var GlodaDatastore = {</span>
<a href="#l3.450"></a><span id="l3.450">               WHERE id = ?2&quot;);</span>
<a href="#l3.451"></a><span id="l3.451">     this.__defineGetter__(&quot;_updateFolderDirtyStatusStatement&quot;,</span>
<a href="#l3.452"></a><span id="l3.452">       function() statement);</span>
<a href="#l3.453"></a><span id="l3.453">     return this._updateFolderDirtyStatusStatement;</span>
<a href="#l3.454"></a><span id="l3.454">   },</span>
<a href="#l3.455"></a><span id="l3.455"> </span>
<a href="#l3.456"></a><span id="l3.456">   updateFolderDirtyStatus: function gloda_ds_updateFolderDirtyStatus(aFolder) {</span>
<a href="#l3.457"></a><span id="l3.457">     let ufds = this._updateFolderDirtyStatusStatement;</span>
<a href="#l3.458"></a><span id="l3.458" class="difflineminus">-    ufds.bindInt64Parameter(1, folder.id);</span>
<a href="#l3.459"></a><span id="l3.459" class="difflineminus">-    ufds.bindInt64Parameter(0, folder.dirtyStatus);</span>
<a href="#l3.460"></a><span id="l3.460" class="difflineplus">+    ufds.bindInt64Parameter(1, aFolder.id);</span>
<a href="#l3.461"></a><span id="l3.461" class="difflineplus">+    ufds.bindInt64Parameter(0, aFolder.dirtyStatus);</span>
<a href="#l3.462"></a><span id="l3.462">     ufds.executeAsync(this.trackAsync());</span>
<a href="#l3.463"></a><span id="l3.463">   },</span>
<a href="#l3.464"></a><span id="l3.464"> </span>
<a href="#l3.465"></a><span id="l3.465">   get _updateFolderLocationStatement() {</span>
<a href="#l3.466"></a><span id="l3.466">     let statement = this._createAsyncStatement(</span>
<a href="#l3.467"></a><span id="l3.467">       &quot;UPDATE folderLocations SET folderURI = ?1 \</span>
<a href="#l3.468"></a><span id="l3.468">               WHERE id = ?2&quot;);</span>
<a href="#l3.469"></a><span id="l3.469">     this.__defineGetter__(&quot;_updateFolderLocationStatement&quot;,</span>
<a href="#l3.470"></a><span id="l3.470" class="difflineat">@@ -1465,18 +1508,17 @@ var GlodaDatastore = {</span>
<a href="#l3.471"></a><span id="l3.471">    *  completed), it's on the caller's head to call GlodaCollectionManager's</span>
<a href="#l3.472"></a><span id="l3.472">    *  itemAdded method once the message is fully created.</span>
<a href="#l3.473"></a><span id="l3.473">    *</span>
<a href="#l3.474"></a><span id="l3.474">    * This method uses the async connection, any downstream logic that depends on</span>
<a href="#l3.475"></a><span id="l3.475">    *  this message actually existing in the database must be done using an</span>
<a href="#l3.476"></a><span id="l3.476">    *  async query.</span>
<a href="#l3.477"></a><span id="l3.477">    */</span>
<a href="#l3.478"></a><span id="l3.478">   createMessage: function gloda_ds_createMessage(aFolder, aMessageKey,</span>
<a href="#l3.479"></a><span id="l3.479" class="difflineminus">-                              aConversationID, aDatePRTime, aHeaderMessageID,</span>
<a href="#l3.480"></a><span id="l3.480" class="difflineminus">-                              aSubject, aBody, aAttachmentNames) {</span>
<a href="#l3.481"></a><span id="l3.481" class="difflineplus">+                              aConversationID, aDatePRTime, aHeaderMessageID) {</span>
<a href="#l3.482"></a><span id="l3.482">     let folderID;</span>
<a href="#l3.483"></a><span id="l3.483">     if (aFolder != null) {</span>
<a href="#l3.484"></a><span id="l3.484">       folderID = this._mapFolder(aFolder).id;</span>
<a href="#l3.485"></a><span id="l3.485">     }</span>
<a href="#l3.486"></a><span id="l3.486">     else {</span>
<a href="#l3.487"></a><span id="l3.487">       folderID = null;</span>
<a href="#l3.488"></a><span id="l3.488">     }</span>
<a href="#l3.489"></a><span id="l3.489"> </span>
<a href="#l3.490"></a><span id="l3.490" class="difflineat">@@ -1495,29 +1537,28 @@ var GlodaDatastore = {</span>
<a href="#l3.491"></a><span id="l3.491">     //  point (at least if it's not a ghost), but we can't yet.  We need to wait</span>
<a href="#l3.492"></a><span id="l3.492">     //  until the attributes have been indexed, which means it's out of our</span>
<a href="#l3.493"></a><span id="l3.493">     //  hands.  (Gloda.processMessage does it.)</span>
<a href="#l3.494"></a><span id="l3.494"> </span>
<a href="#l3.495"></a><span id="l3.495">     return message;</span>
<a href="#l3.496"></a><span id="l3.496">   },</span>
<a href="#l3.497"></a><span id="l3.497">   </span>
<a href="#l3.498"></a><span id="l3.498">   insertMessage: function gloda_ds_insertMessage(aMessage) {</span>
<a href="#l3.499"></a><span id="l3.499" class="difflineminus">-</span>
<a href="#l3.500"></a><span id="l3.500">     let ims = this._insertMessageStatement;</span>
<a href="#l3.501"></a><span id="l3.501">     ims.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l3.502"></a><span id="l3.502" class="difflineminus">-    if (aMessage.folderID === null)</span>
<a href="#l3.503"></a><span id="l3.503" class="difflineplus">+    if (aMessage.folderID == null)</span>
<a href="#l3.504"></a><span id="l3.504">       ims.bindNullParameter(1);</span>
<a href="#l3.505"></a><span id="l3.505">     else</span>
<a href="#l3.506"></a><span id="l3.506">       ims.bindInt64Parameter(1, aMessage.folderID);</span>
<a href="#l3.507"></a><span id="l3.507" class="difflineminus">-    if (aMessage.messageKey === null)</span>
<a href="#l3.508"></a><span id="l3.508" class="difflineplus">+    if (aMessage.messageKey == null)</span>
<a href="#l3.509"></a><span id="l3.509">       ims.bindNullParameter(2);</span>
<a href="#l3.510"></a><span id="l3.510">     else</span>
<a href="#l3.511"></a><span id="l3.511">       ims.bindInt64Parameter(2, aMessage.messageKey);</span>
<a href="#l3.512"></a><span id="l3.512">     ims.bindInt64Parameter(3, aMessage.conversationID);</span>
<a href="#l3.513"></a><span id="l3.513" class="difflineminus">-    if (aMessage.date === null)</span>
<a href="#l3.514"></a><span id="l3.514" class="difflineplus">+    if (aMessage.date == null)</span>
<a href="#l3.515"></a><span id="l3.515">       ims.bindNullParameter(4);</span>
<a href="#l3.516"></a><span id="l3.516">     else</span>
<a href="#l3.517"></a><span id="l3.517">       ims.bindInt64Parameter(4, aMessage.date * 1000);</span>
<a href="#l3.518"></a><span id="l3.518">     ims.bindStringParameter(5, aMessage.headerMessageID);</span>
<a href="#l3.519"></a><span id="l3.519">     if (aMessage._jsonText)</span>
<a href="#l3.520"></a><span id="l3.520">       ims.bindStringParameter(6, aMessage._jsonText);</span>
<a href="#l3.521"></a><span id="l3.521">     else</span>
<a href="#l3.522"></a><span id="l3.522">       ims.bindNullParameter(6);</span>
<a href="#l3.523"></a><span id="l3.523" class="difflineat">@@ -1529,58 +1570,60 @@ var GlodaDatastore = {</span>
<a href="#l3.524"></a><span id="l3.524">        throw(&quot;error executing statement... &quot; +</span>
<a href="#l3.525"></a><span id="l3.525">              this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.526"></a><span id="l3.526">              this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.527"></a><span id="l3.527">     }</span>
<a href="#l3.528"></a><span id="l3.528"> </span>
<a href="#l3.529"></a><span id="l3.529">     // we only create the full-text row if the body is non-null.</span>
<a href="#l3.530"></a><span id="l3.530">     // so, even though body might be null, we still want to create the</span>
<a href="#l3.531"></a><span id="l3.531">     //  full-text search row</span>
<a href="#l3.532"></a><span id="l3.532" class="difflineminus">-    if (aBody) {</span>
<a href="#l3.533"></a><span id="l3.533" class="difflineplus">+    if (aMessage._body) {</span>
<a href="#l3.534"></a><span id="l3.534">       let imts = this._insertMessageTextStatement;</span>
<a href="#l3.535"></a><span id="l3.535" class="difflineminus">-      imts.bindInt64Parameter(0, messageID);</span>
<a href="#l3.536"></a><span id="l3.536" class="difflineminus">-      imts.bindStringParameter(1, aSubject);</span>
<a href="#l3.537"></a><span id="l3.537" class="difflineminus">-      imts.bindStringParameter(2, aBody);</span>
<a href="#l3.538"></a><span id="l3.538" class="difflineminus">-      if (aAttachmentNames === null)</span>
<a href="#l3.539"></a><span id="l3.539" class="difflineplus">+      imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l3.540"></a><span id="l3.540" class="difflineplus">+      imts.bindStringParameter(1, aMessage._subject);</span>
<a href="#l3.541"></a><span id="l3.541" class="difflineplus">+      imts.bindStringParameter(2, aMessage._body);</span>
<a href="#l3.542"></a><span id="l3.542" class="difflineplus">+      if (aMessage._attachmentNames === null)</span>
<a href="#l3.543"></a><span id="l3.543">         imts.bindNullParameter(3);</span>
<a href="#l3.544"></a><span id="l3.544">       else</span>
<a href="#l3.545"></a><span id="l3.545" class="difflineminus">-        imts.bindStringParameter(3, aAttachmentNames);</span>
<a href="#l3.546"></a><span id="l3.546" class="difflineplus">+        imts.bindStringParameter(3, aMessage._attachmentNames);</span>
<a href="#l3.547"></a><span id="l3.547" class="difflineplus">+      </span>
<a href="#l3.548"></a><span id="l3.548" class="difflineplus">+      delete aMessage._subject;</span>
<a href="#l3.549"></a><span id="l3.549" class="difflineplus">+      delete aMessage._body;</span>
<a href="#l3.550"></a><span id="l3.550" class="difflineplus">+      delete aMessage._attachmentNames;</span>
<a href="#l3.551"></a><span id="l3.551"> </span>
<a href="#l3.552"></a><span id="l3.552">       try {</span>
<a href="#l3.553"></a><span id="l3.553">          imts.executeAsync(this.trackAsync());</span>
<a href="#l3.554"></a><span id="l3.554">       }</span>
<a href="#l3.555"></a><span id="l3.555">       catch(ex) {</span>
<a href="#l3.556"></a><span id="l3.556">          throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l3.557"></a><span id="l3.557">                this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.558"></a><span id="l3.558">                this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.559"></a><span id="l3.559">       }</span>
<a href="#l3.560"></a><span id="l3.560">     }</span>
<a href="#l3.561"></a><span id="l3.561" class="difflineminus">-</span>
<a href="#l3.562"></a><span id="l3.562">   },</span>
<a href="#l3.563"></a><span id="l3.563"> </span>
<a href="#l3.564"></a><span id="l3.564">   get _updateMessageStatement() {</span>
<a href="#l3.565"></a><span id="l3.565">     let statement = this._createAsyncStatement(</span>
<a href="#l3.566"></a><span id="l3.566">       &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l3.567"></a><span id="l3.567">                            messageKey = ?2, \</span>
<a href="#l3.568"></a><span id="l3.568">                            conversationID = ?3, \</span>
<a href="#l3.569"></a><span id="l3.569">                            date = ?4, \</span>
<a href="#l3.570"></a><span id="l3.570" class="difflineminus">-                           headerMessageID = ?5,</span>
<a href="#l3.571"></a><span id="l3.571" class="difflineplus">+                           headerMessageID = ?5, \</span>
<a href="#l3.572"></a><span id="l3.572">                            jsonAttributes = ?6 \</span>
<a href="#l3.573"></a><span id="l3.573">               WHERE id = ?7&quot;);</span>
<a href="#l3.574"></a><span id="l3.574">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l3.575"></a><span id="l3.575">     return this._updateMessageStatement;</span>
<a href="#l3.576"></a><span id="l3.576">   },</span>
<a href="#l3.577"></a><span id="l3.577"> </span>
<a href="#l3.578"></a><span id="l3.578">   /**</span>
<a href="#l3.579"></a><span id="l3.579">    * Update the database row associated with the message.  If aBody is supplied,</span>
<a href="#l3.580"></a><span id="l3.580">    *  the associated full-text row is created; it is assumed that it did not</span>
<a href="#l3.581"></a><span id="l3.581">    *  previously exist.</span>
<a href="#l3.582"></a><span id="l3.582">    */</span>
<a href="#l3.583"></a><span id="l3.583" class="difflineminus">-  updateMessage: function gloda_ds_updateMessage(aMessage, aSubject, aBody,</span>
<a href="#l3.584"></a><span id="l3.584" class="difflineminus">-                                                 aAttachmentNames) {</span>
<a href="#l3.585"></a><span id="l3.585" class="difflineplus">+  updateMessage: function gloda_ds_updateMessage(aMessage) {</span>
<a href="#l3.586"></a><span id="l3.586">     let ums = this._updateMessageStatement;</span>
<a href="#l3.587"></a><span id="l3.587">     ums.bindInt64Parameter(6, aMessage.id);</span>
<a href="#l3.588"></a><span id="l3.588">     if (aMessage.folderID === null)</span>
<a href="#l3.589"></a><span id="l3.589">       ums.bindNullParameter(0);</span>
<a href="#l3.590"></a><span id="l3.590">     else</span>
<a href="#l3.591"></a><span id="l3.591">       ums.bindInt64Parameter(0, aMessage.folderID);</span>
<a href="#l3.592"></a><span id="l3.592">     if (aMessage.messageKey === null)</span>
<a href="#l3.593"></a><span id="l3.593">       ums.bindNullParameter(1);</span>
<a href="#l3.594"></a><span id="l3.594" class="difflineat">@@ -1588,33 +1631,44 @@ var GlodaDatastore = {</span>
<a href="#l3.595"></a><span id="l3.595">       ums.bindInt64Parameter(1, aMessage.messageKey);</span>
<a href="#l3.596"></a><span id="l3.596">     ums.bindInt64Parameter(2, aMessage.conversationID);</span>
<a href="#l3.597"></a><span id="l3.597">     if (aMessage.date === null)</span>
<a href="#l3.598"></a><span id="l3.598">       ums.bindNullParameter(3);</span>
<a href="#l3.599"></a><span id="l3.599">     else</span>
<a href="#l3.600"></a><span id="l3.600">       ums.bindInt64Parameter(3, aMessage.date * 1000);</span>
<a href="#l3.601"></a><span id="l3.601">     ums.bindStringParameter(4, aMessage.headerMessageID);</span>
<a href="#l3.602"></a><span id="l3.602">     if (aMessage._jsonText)</span>
<a href="#l3.603"></a><span id="l3.603" class="difflineminus">-      ims.bindStringParameter(5, aMessage._jsonText);</span>
<a href="#l3.604"></a><span id="l3.604" class="difflineplus">+      ums.bindStringParameter(5, aMessage._jsonText);</span>
<a href="#l3.605"></a><span id="l3.605">     else</span>
<a href="#l3.606"></a><span id="l3.606" class="difflineminus">-      ims.bindNullParameter(5);</span>
<a href="#l3.607"></a><span id="l3.607" class="difflineplus">+      ums.bindNullParameter(5);</span>
<a href="#l3.608"></a><span id="l3.608"> </span>
<a href="#l3.609"></a><span id="l3.609">     ums.executeAsync(this.trackAsync());</span>
<a href="#l3.610"></a><span id="l3.610"> </span>
<a href="#l3.611"></a><span id="l3.611" class="difflineminus">-    if (aBody) {</span>
<a href="#l3.612"></a><span id="l3.612" class="difflineplus">+    if (aMessage._body) {</span>
<a href="#l3.613"></a><span id="l3.613">       let imts = this._insertMessageTextStatement;</span>
<a href="#l3.614"></a><span id="l3.614">       imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l3.615"></a><span id="l3.615" class="difflineminus">-      imts.bindStringParameter(1, aSubject);</span>
<a href="#l3.616"></a><span id="l3.616" class="difflineminus">-      imts.bindStringParameter(2, aBody);</span>
<a href="#l3.617"></a><span id="l3.617" class="difflineminus">-      if (aAttachmentNames === null)</span>
<a href="#l3.618"></a><span id="l3.618" class="difflineplus">+      imts.bindStringParameter(1, aMessage._subject);</span>
<a href="#l3.619"></a><span id="l3.619" class="difflineplus">+      imts.bindStringParameter(2, aMessage._body);</span>
<a href="#l3.620"></a><span id="l3.620" class="difflineplus">+      if (aMessage._attachmentNames === null)</span>
<a href="#l3.621"></a><span id="l3.621">         imts.bindNullParameter(3);</span>
<a href="#l3.622"></a><span id="l3.622">       else</span>
<a href="#l3.623"></a><span id="l3.623" class="difflineminus">-        imts.bindStringParameter(3, aAttachmentNames);</span>
<a href="#l3.624"></a><span id="l3.624" class="difflineminus">-</span>
<a href="#l3.625"></a><span id="l3.625" class="difflineminus">-      imts.executeAsync(this.trackAsync());</span>
<a href="#l3.626"></a><span id="l3.626" class="difflineplus">+        imts.bindStringParameter(3, aMessage._attachmentNames);</span>
<a href="#l3.627"></a><span id="l3.627" class="difflineplus">+      </span>
<a href="#l3.628"></a><span id="l3.628" class="difflineplus">+      delete aMessage._subject;</span>
<a href="#l3.629"></a><span id="l3.629" class="difflineplus">+      delete aMessage._body;</span>
<a href="#l3.630"></a><span id="l3.630" class="difflineplus">+      delete aMessage._attachmentNames;</span>
<a href="#l3.631"></a><span id="l3.631" class="difflineplus">+      </span>
<a href="#l3.632"></a><span id="l3.632" class="difflineplus">+      try {</span>
<a href="#l3.633"></a><span id="l3.633" class="difflineplus">+         imts.executeAsync(this.trackAsync());</span>
<a href="#l3.634"></a><span id="l3.634" class="difflineplus">+      }</span>
<a href="#l3.635"></a><span id="l3.635" class="difflineplus">+      catch(ex) {</span>
<a href="#l3.636"></a><span id="l3.636" class="difflineplus">+         throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l3.637"></a><span id="l3.637" class="difflineplus">+               this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.638"></a><span id="l3.638" class="difflineplus">+               this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.639"></a><span id="l3.639" class="difflineplus">+      }</span>
<a href="#l3.640"></a><span id="l3.640">     }</span>
<a href="#l3.641"></a><span id="l3.641"> </span>
<a href="#l3.642"></a><span id="l3.642">     // In completely abstract theory, this is where we would call</span>
<a href="#l3.643"></a><span id="l3.643">     //  GlodaCollectionManager.itemsModified, except that the attributes may</span>
<a href="#l3.644"></a><span id="l3.644">     //  also have changed, so it's out of our hands.  (Gloda.processMessage</span>
<a href="#l3.645"></a><span id="l3.645">     //  handles it.)</span>
<a href="#l3.646"></a><span id="l3.646">   },</span>
<a href="#l3.647"></a><span id="l3.647"> </span>
<a href="#l3.648"></a><span id="l3.648" class="difflineat">@@ -1712,17 +1766,17 @@ var GlodaDatastore = {</span>
<a href="#l3.649"></a><span id="l3.649">     else</span>
<a href="#l3.650"></a><span id="l3.650">       messageKey = aRow.getInt64(2);</span>
<a href="#l3.651"></a><span id="l3.651">     if (aRow.getTypeOfIndex(4) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.652"></a><span id="l3.652">       date = null;</span>
<a href="#l3.653"></a><span id="l3.653">     else</span>
<a href="#l3.654"></a><span id="l3.654">       date = new Date(aRow.getInt64(4) / 1000);</span>
<a href="#l3.655"></a><span id="l3.655">     return new GlodaMessage(this, aRow.getInt64(0), folderId, messageKey,</span>
<a href="#l3.656"></a><span id="l3.656">                             aRow.getInt64(3), null, date, aRow.getString(5),</span>
<a href="#l3.657"></a><span id="l3.657" class="difflineminus">-                            aRow.getInt64(6));</span>
<a href="#l3.658"></a><span id="l3.658" class="difflineplus">+                            aRow.getInt64(6), aRow.getString(7));</span>
<a href="#l3.659"></a><span id="l3.659">   },</span>
<a href="#l3.660"></a><span id="l3.660"> </span>
<a href="#l3.661"></a><span id="l3.661">   get _selectMessageByIDStatement() {</span>
<a href="#l3.662"></a><span id="l3.662">     let statement = this._createSyncStatement(</span>
<a href="#l3.663"></a><span id="l3.663">       &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageID, \</span>
<a href="#l3.664"></a><span id="l3.664">            deleted FROM messages WHERE id = ?1&quot;);</span>
<a href="#l3.665"></a><span id="l3.665">     this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l3.666"></a><span id="l3.666">       function() statement);</span>
<a href="#l3.667"></a><span id="l3.667" class="difflineat">@@ -1774,17 +1828,17 @@ var GlodaDatastore = {</span>
<a href="#l3.668"></a><span id="l3.668"> </span>
<a href="#l3.669"></a><span id="l3.669">     let message = null;</span>
<a href="#l3.670"></a><span id="l3.670">     if (this._syncStep(this._selectMessageByLocationStatement))</span>
<a href="#l3.671"></a><span id="l3.671">       message = this._messageFromRow(this._selectMessageByLocationStatement);</span>
<a href="#l3.672"></a><span id="l3.672">     this._selectMessageByLocationStatement.reset();</span>
<a href="#l3.673"></a><span id="l3.673"> </span>
<a href="#l3.674"></a><span id="l3.674">     if (message === null)</span>
<a href="#l3.675"></a><span id="l3.675">       this._log.info(&quot;Error locating message with key=&quot; + aMessageKey +</span>
<a href="#l3.676"></a><span id="l3.676" class="difflineminus">-                     &quot; and URI &quot; + aFolderURI);</span>
<a href="#l3.677"></a><span id="l3.677" class="difflineplus">+                     &quot; and URI &quot; + aFolder.URI);</span>
<a href="#l3.678"></a><span id="l3.678"> </span>
<a href="#l3.679"></a><span id="l3.679">     return message &amp;&amp; GlodaCollectionManager.cacheLoadUnifyOne(message);</span>
<a href="#l3.680"></a><span id="l3.680">   },</span>
<a href="#l3.681"></a><span id="l3.681"> </span>
<a href="#l3.682"></a><span id="l3.682">   get _selectMessageIDsByFolderStatement() {</span>
<a href="#l3.683"></a><span id="l3.683">     let statement = this._createSyncStatement(</span>
<a href="#l3.684"></a><span id="l3.684">       &quot;SELECT id FROM messages WHERE folderID = ?1&quot;);</span>
<a href="#l3.685"></a><span id="l3.685">     this.__defineGetter__(&quot;_selectMessageIDsByFolderStatement&quot;,</span>
<a href="#l3.686"></a><span id="l3.686" class="difflineat">@@ -1818,37 +1872,39 @@ var GlodaDatastore = {</span>
<a href="#l3.687"></a><span id="l3.687">    * This call is asynchronous because it depends on previously created messages</span>
<a href="#l3.688"></a><span id="l3.688">    *  to be reflected in our results, which requires us to execute on the async</span>
<a href="#l3.689"></a><span id="l3.689">    *  thread where all our writes happen.  This also turns out to be a</span>
<a href="#l3.690"></a><span id="l3.690">    *  reasonable thing because we could imagine pathological cases where there</span>
<a href="#l3.691"></a><span id="l3.691">    *  could be a lot of message-id's and/or a lot of messages with those</span>
<a href="#l3.692"></a><span id="l3.692">    *  message-id's.</span>
<a href="#l3.693"></a><span id="l3.693">    */</span>
<a href="#l3.694"></a><span id="l3.694">   getMessagesByMessageID: function gloda_ds_getMessagesByMessageID(aMessageIDs,</span>
<a href="#l3.695"></a><span id="l3.695" class="difflineminus">-      aCallback, aCallbackThis, aCallbackArgs) {</span>
<a href="#l3.696"></a><span id="l3.696" class="difflineplus">+      aCallback, aCallbackThis) {</span>
<a href="#l3.697"></a><span id="l3.697">     let msgIDToIndex = {};</span>
<a href="#l3.698"></a><span id="l3.698">     let results = [];</span>
<a href="#l3.699"></a><span id="l3.699">     for (let iID = 0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l3.700"></a><span id="l3.700">       let msgID = aMessageIDs[iID];</span>
<a href="#l3.701"></a><span id="l3.701">       results.push([]);</span>
<a href="#l3.702"></a><span id="l3.702">       msgIDToIndex[msgID] = iID;</span>
<a href="#l3.703"></a><span id="l3.703">     }</span>
<a href="#l3.704"></a><span id="l3.704"> </span>
<a href="#l3.705"></a><span id="l3.705">     // Unfortunately, IN doesn't work with statement binding mechanisms, and</span>
<a href="#l3.706"></a><span id="l3.706">     //  a chain of ORed tests really can't be bound unless we create one per</span>
<a href="#l3.707"></a><span id="l3.707">     //  value of N (seems silly).</span>
<a href="#l3.708"></a><span id="l3.708">     let quotedIDs = [&quot;'&quot; + msgID.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot; for each</span>
<a href="#l3.709"></a><span id="l3.709">                      ([i, msgID] in Iterator(aMessageIDs))]</span>
<a href="#l3.710"></a><span id="l3.710">     let sqlString = &quot;SELECT * FROM messages WHERE headerMessageID IN (&quot; +</span>
<a href="#l3.711"></a><span id="l3.711">                     quotedIDs + &quot;)&quot;;</span>
<a href="#l3.712"></a><span id="l3.712" class="difflineminus">-    let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l3.713"></a><span id="l3.713" class="difflineminus">-</span>
<a href="#l3.714"></a><span id="l3.714" class="difflineminus">-    statement.executeAsync(new MessagesByMessageIdCallback(statement,</span>
<a href="#l3.715"></a><span id="l3.715" class="difflineminus">-      msgIDToIndex, results, aCallback, aCallbackThis, aCallbackArgs));</span>
<a href="#l3.716"></a><span id="l3.716" class="difflineminus">-    statement.finalize();</span>
<a href="#l3.717"></a><span id="l3.717" class="difflineplus">+    </span>
<a href="#l3.718"></a><span id="l3.718" class="difflineplus">+    let nounDef = GlodaMessage.prototype.NOUN_DEF;</span>
<a href="#l3.719"></a><span id="l3.719" class="difflineplus">+    let listener = new MessagesByMessageIdCallback(msgIDToIndex, results,</span>
<a href="#l3.720"></a><span id="l3.720" class="difflineplus">+        aCallback, aCallbackThis);</span>
<a href="#l3.721"></a><span id="l3.721" class="difflineplus">+    let query = new nounDef.explicitQueryClass();</span>
<a href="#l3.722"></a><span id="l3.722" class="difflineplus">+    return this._queryFromSQLString(sqlString, [], nounDef,</span>
<a href="#l3.723"></a><span id="l3.723" class="difflineplus">+        query, listener);</span>
<a href="#l3.724"></a><span id="l3.724">   },</span>
<a href="#l3.725"></a><span id="l3.725"> </span>
<a href="#l3.726"></a><span id="l3.726">   get _updateMessagesMarkDeletedByFolderID() {</span>
<a href="#l3.727"></a><span id="l3.727">     let statement = this._createAsyncStatement(</span>
<a href="#l3.728"></a><span id="l3.728">       &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, \</span>
<a href="#l3.729"></a><span id="l3.729">               deleted = 1 WHERE folderID = ?1&quot;);</span>
<a href="#l3.730"></a><span id="l3.730">     this.__defineGetter__(&quot;_updateMessagesMarkDeletedByFolderID&quot;,</span>
<a href="#l3.731"></a><span id="l3.731">       function() statement);</span>
<a href="#l3.732"></a><span id="l3.732" class="difflineat">@@ -2224,17 +2280,17 @@ var GlodaDatastore = {</span>
<a href="#l3.733"></a><span id="l3.733">     function gloda_ds__convertToDBValuesAndGroupByAttributeID(aAttrDef,</span>
<a href="#l3.734"></a><span id="l3.734">                                                               aValues) {</span>
<a href="#l3.735"></a><span id="l3.735">     let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l3.736"></a><span id="l3.736">     if (!aAttrDef.usesParameter) {</span>
<a href="#l3.737"></a><span id="l3.737">       let dbValues = [];</span>
<a href="#l3.738"></a><span id="l3.738">       for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l3.739"></a><span id="l3.739">         dbValues.push(objectNounDef.toParamAndValue(aValues[iValue])[1]);</span>
<a href="#l3.740"></a><span id="l3.740">       }</span>
<a href="#l3.741"></a><span id="l3.741" class="difflineminus">-      yield [aAttrDef.id, dbValues];</span>
<a href="#l3.742"></a><span id="l3.742" class="difflineplus">+      yield [aAttrDef.special ? undefined : aAttrDef.id, dbValues];</span>
<a href="#l3.743"></a><span id="l3.743">       return;</span>
<a href="#l3.744"></a><span id="l3.744">     }</span>
<a href="#l3.745"></a><span id="l3.745">     </span>
<a href="#l3.746"></a><span id="l3.746">     let curParam, attrID, dbValues;</span>
<a href="#l3.747"></a><span id="l3.747">     let attrDBDef = aAttrDef.dbDef;</span>
<a href="#l3.748"></a><span id="l3.748">     for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l3.749"></a><span id="l3.749">       let [dbParam, dbValue] = objectNounDef.toParamAndValue(aValues[iValue]);</span>
<a href="#l3.750"></a><span id="l3.750">       if (curParam === undefined) {</span>
<a href="#l3.751"></a><span id="l3.751" class="difflineat">@@ -2271,17 +2327,17 @@ var GlodaDatastore = {</span>
<a href="#l3.752"></a><span id="l3.752">         else if (upperVal == null)</span>
<a href="#l3.753"></a><span id="l3.753">           dbStrings.push(aValueColumnName + &quot; &gt;= &quot; +</span>
<a href="#l3.754"></a><span id="l3.754">                          objectNounDef.toParamAndValue(lowerVal)[1]);</span>
<a href="#l3.755"></a><span id="l3.755">         else // no one is null!</span>
<a href="#l3.756"></a><span id="l3.756">           dbStrings.push(aValueColumnName + &quot; BETWEEN &quot; +</span>
<a href="#l3.757"></a><span id="l3.757">                          objectNounDef.toParamAndValue(lowerVal)[1] + &quot; AND &quot; +</span>
<a href="#l3.758"></a><span id="l3.758">                          objectNounDef.toParamAndValue(upperVal)[1]);</span>
<a href="#l3.759"></a><span id="l3.759">       }</span>
<a href="#l3.760"></a><span id="l3.760" class="difflineminus">-      yield [aAttrDef.id, dbStrings];</span>
<a href="#l3.761"></a><span id="l3.761" class="difflineplus">+      yield [aAttrDef.special ? undefined : aAttrDef.id, dbStrings];</span>
<a href="#l3.762"></a><span id="l3.762">       return;</span>
<a href="#l3.763"></a><span id="l3.763">     }</span>
<a href="#l3.764"></a><span id="l3.764">     </span>
<a href="#l3.765"></a><span id="l3.765">     let curParam, attrID, dbStrings;</span>
<a href="#l3.766"></a><span id="l3.766">     let attrDBDef = aAttrDef.dbDef;</span>
<a href="#l3.767"></a><span id="l3.767">     for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l3.768"></a><span id="l3.768">       let [lowerVal, upperVal] = aValues[iValue];</span>
<a href="#l3.769"></a><span id="l3.769"> </span>
<a href="#l3.770"></a><span id="l3.770" class="difflineat">@@ -2301,17 +2357,17 @@ var GlodaDatastore = {</span>
<a href="#l3.771"></a><span id="l3.771">                    objectNounDef.toParamAndValue(upperVal)[1];</span>
<a href="#l3.772"></a><span id="l3.772">       }</span>
<a href="#l3.773"></a><span id="l3.773"> </span>
<a href="#l3.774"></a><span id="l3.774">       if (curParam === undefined) {</span>
<a href="#l3.775"></a><span id="l3.775">         curParam = dbParam;</span>
<a href="#l3.776"></a><span id="l3.776">         attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l3.777"></a><span id="l3.777">         dbStrings = [dbString];</span>
<a href="#l3.778"></a><span id="l3.778">       }</span>
<a href="#l3.779"></a><span id="l3.779" class="difflineminus">-      else if (curParam == dbParam) {</span>
<a href="#l3.780"></a><span id="l3.780" class="difflineplus">+      else if (curParam === dbParam) {</span>
<a href="#l3.781"></a><span id="l3.781">         dbStrings.push(dbString);</span>
<a href="#l3.782"></a><span id="l3.782">       }</span>
<a href="#l3.783"></a><span id="l3.783">       else {</span>
<a href="#l3.784"></a><span id="l3.784">         yield [attrID, dbStrings];</span>
<a href="#l3.785"></a><span id="l3.785">         curParam = dbParam;</span>
<a href="#l3.786"></a><span id="l3.786">         attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l3.787"></a><span id="l3.787">         dbStrings = [dbString];</span>
<a href="#l3.788"></a><span id="l3.788">       }</span>
<a href="#l3.789"></a><span id="l3.789" class="difflineat">@@ -2337,113 +2393,135 @@ var GlodaDatastore = {</span>
<a href="#l3.790"></a><span id="l3.790"> </span>
<a href="#l3.791"></a><span id="l3.791">     let whereClauses = [];</span>
<a href="#l3.792"></a><span id="l3.792">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l3.793"></a><span id="l3.793">     let boundArgs = [];</span>
<a href="#l3.794"></a><span id="l3.794"> </span>
<a href="#l3.795"></a><span id="l3.795">     for (let iUnion = 0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l3.796"></a><span id="l3.796">       let curQuery = unionQueries[iUnion];</span>
<a href="#l3.797"></a><span id="l3.797">       let selects = [];</span>
<a href="#l3.798"></a><span id="l3.798" class="difflineplus">+      </span>
<a href="#l3.799"></a><span id="l3.799" class="difflineplus">+      let lastConstraintWasSpecial = false;</span>
<a href="#l3.800"></a><span id="l3.800" class="difflineplus">+      let curConstraintIsSpecial;</span>
<a href="#l3.801"></a><span id="l3.801"> </span>
<a href="#l3.802"></a><span id="l3.802">       for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length;</span>
<a href="#l3.803"></a><span id="l3.803">            iConstraint++) {</span>
<a href="#l3.804"></a><span id="l3.804">         let constraint = curQuery._constraints[iConstraint];</span>
<a href="#l3.805"></a><span id="l3.805">         let [constraintType, attrDef] = constraint;</span>
<a href="#l3.806"></a><span id="l3.806">         let constraintValues = constraint.slice(2);</span>
<a href="#l3.807"></a><span id="l3.807">         </span>
<a href="#l3.808"></a><span id="l3.808">         let idColumnName, tableColumnName;</span>
<a href="#l3.809"></a><span id="l3.809">         if (constraintType == this.kConstraintIdIn) {</span>
<a href="#l3.810"></a><span id="l3.810">           // we don't need any of the next cases' setup code, and we especially</span>
<a href="#l3.811"></a><span id="l3.811">           //  would prefer that attrDef isn't accessed since it's null for us.</span>
<a href="#l3.812"></a><span id="l3.812">         }</span>
<a href="#l3.813"></a><span id="l3.813">         else if (attrDef.special) {</span>
<a href="#l3.814"></a><span id="l3.814">           tableName = nounDef.tableName;</span>
<a href="#l3.815"></a><span id="l3.815">           idColumnName = &quot;id&quot;; // canonical id for a table is &quot;id&quot;.</span>
<a href="#l3.816"></a><span id="l3.816">           valueColumnName = attrDef.specialColumnName;</span>
<a href="#l3.817"></a><span id="l3.817" class="difflineplus">+          curConstraintIsSpecial = true;</span>
<a href="#l3.818"></a><span id="l3.818">         }</span>
<a href="#l3.819"></a><span id="l3.819">         else {</span>
<a href="#l3.820"></a><span id="l3.820">           tableName = nounDef.attrTableName;</span>
<a href="#l3.821"></a><span id="l3.821">           idColumnName = nounDef.attrIDColumnName;</span>
<a href="#l3.822"></a><span id="l3.822">           valueColumnName = &quot;value&quot;;</span>
<a href="#l3.823"></a><span id="l3.823" class="difflineplus">+          curConstraintIsSpecial = false;</span>
<a href="#l3.824"></a><span id="l3.824">         }</span>
<a href="#l3.825"></a><span id="l3.825">         </span>
<a href="#l3.826"></a><span id="l3.826" class="difflineminus">-        let select = null, bindArgs = null;</span>
<a href="#l3.827"></a><span id="l3.827" class="difflineplus">+        let select = null, test = null, bindArgs = null;</span>
<a href="#l3.828"></a><span id="l3.828">         if (constraintType === this.kConstraintIdIn) {</span>
<a href="#l3.829"></a><span id="l3.829">           // this is somewhat of a trick.  this does mean that this can be the</span>
<a href="#l3.830"></a><span id="l3.830">           //  only constraint.  Namely, our idiom is:</span>
<a href="#l3.831"></a><span id="l3.831">           // SELECT * FROM blah WHERE id IN (a INTERSECT b INTERSECT c)</span>
<a href="#l3.832"></a><span id="l3.832">           //  but if we only have 'a', then that becomes &quot;...IN (a)&quot;, and if</span>
<a href="#l3.833"></a><span id="l3.833">           //  'a' is not a select but a list of id's... tricky, no?  </span>
<a href="#l3.834"></a><span id="l3.834" class="difflineminus">-          select = constraintValue.join(&quot;,&quot;);</span>
<a href="#l3.835"></a><span id="l3.835" class="difflineplus">+          select = constraintValues.join(&quot;,&quot;);</span>
<a href="#l3.836"></a><span id="l3.836">         }</span>
<a href="#l3.837"></a><span id="l3.837">         else if (constraintType === this.kConstraintIn) {</span>
<a href="#l3.838"></a><span id="l3.838">           let clauses = [];</span>
<a href="#l3.839"></a><span id="l3.839">           for each ([attrID, values] in</span>
<a href="#l3.840"></a><span id="l3.840">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l3.841"></a><span id="l3.841">                                                            constraintValues)) {</span>
<a href="#l3.842"></a><span id="l3.842" class="difflineminus">-            clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l3.843"></a><span id="l3.843" class="difflineminus">-                         &quot; AND &quot; + valueColumnName + &quot; IN (&quot; +</span>
<a href="#l3.844"></a><span id="l3.844" class="difflineminus">-                         values.join(&quot;,&quot;) + &quot;))&quot;);</span>
<a href="#l3.845"></a><span id="l3.845" class="difflineplus">+            if (attrID !== undefined)</span>
<a href="#l3.846"></a><span id="l3.846" class="difflineplus">+              clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l3.847"></a><span id="l3.847" class="difflineplus">+                  &quot; AND &quot; + valueColumnName + &quot; IN (&quot; +</span>
<a href="#l3.848"></a><span id="l3.848" class="difflineplus">+                  values.join(&quot;,&quot;) + &quot;))&quot;);</span>
<a href="#l3.849"></a><span id="l3.849" class="difflineplus">+            else</span>
<a href="#l3.850"></a><span id="l3.850" class="difflineplus">+              clauses.push(&quot;(&quot; + valueColumnName + &quot; IN (&quot; +</span>
<a href="#l3.851"></a><span id="l3.851" class="difflineplus">+                  values.join(&quot;,&quot;) + &quot;)&quot;);</span>
<a href="#l3.852"></a><span id="l3.852">           }</span>
<a href="#l3.853"></a><span id="l3.853" class="difflineminus">-          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l3.854"></a><span id="l3.854" class="difflineminus">-            &quot; WHERE &quot; + clauses.join(&quot; OR &quot;);</span>
<a href="#l3.855"></a><span id="l3.855" class="difflineplus">+          test = clauses.join(&quot; OR &quot;);</span>
<a href="#l3.856"></a><span id="l3.856">         }</span>
<a href="#l3.857"></a><span id="l3.857">         else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l3.858"></a><span id="l3.858">           let clauses = [];</span>
<a href="#l3.859"></a><span id="l3.859">           for each ([attrID, dbStrings] in</span>
<a href="#l3.860"></a><span id="l3.860">               this._convertRangesToDBStringsAndGroupByAttributeID(attrDef,</span>
<a href="#l3.861"></a><span id="l3.861">                               constraintValues, valueColumnName)) {</span>
<a href="#l3.862"></a><span id="l3.862" class="difflineminus">-            clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l3.863"></a><span id="l3.863" class="difflineminus">-                         &quot; AND (&quot; + dbStrings.join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l3.864"></a><span id="l3.864" class="difflineplus">+            if (attrID !== undefined)</span>
<a href="#l3.865"></a><span id="l3.865" class="difflineplus">+              clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l3.866"></a><span id="l3.866" class="difflineplus">+                           &quot; AND (&quot; + dbStrings.join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l3.867"></a><span id="l3.867" class="difflineplus">+            else</span>
<a href="#l3.868"></a><span id="l3.868" class="difflineplus">+              clauses.push(&quot;(&quot; + dbStrings.join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l3.869"></a><span id="l3.869">           }</span>
<a href="#l3.870"></a><span id="l3.870" class="difflineminus">-          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l3.871"></a><span id="l3.871" class="difflineminus">-            &quot; WHERE &quot; + clauses.join(&quot; OR &quot;);</span>
<a href="#l3.872"></a><span id="l3.872" class="difflineplus">+          test = clauses.join(&quot; OR &quot;);</span>
<a href="#l3.873"></a><span id="l3.873">         }</span>
<a href="#l3.874"></a><span id="l3.874">         else if (constraintType === this.kConstraintEquals) {</span>
<a href="#l3.875"></a><span id="l3.875">           let clauses = [];</span>
<a href="#l3.876"></a><span id="l3.876">           for each ([attrID, values] in</span>
<a href="#l3.877"></a><span id="l3.877">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l3.878"></a><span id="l3.878">                                                            constraintValues)) {</span>
<a href="#l3.879"></a><span id="l3.879" class="difflineminus">-            clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l3.880"></a><span id="l3.880" class="difflineminus">-                         &quot; AND (&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l3.881"></a><span id="l3.881" class="difflineminus">-                         (value in values)].join(&quot;OR&quot;) + &quot;)&quot;);</span>
<a href="#l3.882"></a><span id="l3.882" class="difflineplus">+            if (attrID !== undefined)</span>
<a href="#l3.883"></a><span id="l3.883" class="difflineplus">+              clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l3.884"></a><span id="l3.884" class="difflineplus">+                  &quot; AND (&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l3.885"></a><span id="l3.885" class="difflineplus">+                  (value in values)].join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l3.886"></a><span id="l3.886" class="difflineplus">+            else</span>
<a href="#l3.887"></a><span id="l3.887" class="difflineplus">+              clauses.push(&quot;(&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l3.888"></a><span id="l3.888" class="difflineplus">+                  (value in values)].join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l3.889"></a><span id="l3.889">             boundArgs.push.apply(boundArgs, values);</span>
<a href="#l3.890"></a><span id="l3.890">           }</span>
<a href="#l3.891"></a><span id="l3.891" class="difflineminus">-          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l3.892"></a><span id="l3.892" class="difflineminus">-            &quot; WHERE &quot; + clauses.join(&quot; OR &quot;);</span>
<a href="#l3.893"></a><span id="l3.893" class="difflineplus">+          test = clauses.join(&quot; OR &quot;);</span>
<a href="#l3.894"></a><span id="l3.894">         }</span>
<a href="#l3.895"></a><span id="l3.895">         else if (constraintType === this.kConstraintStringLike) {</span>
<a href="#l3.896"></a><span id="l3.896">           likePayload = '';</span>
<a href="#l3.897"></a><span id="l3.897" class="difflineminus">-          for each (let [iValuePart, valuePart] in Iterator(constraintValues) {</span>
<a href="#l3.898"></a><span id="l3.898" class="difflineplus">+          for each (let [iValuePart, valuePart] in Iterator(constraintValues)) {</span>
<a href="#l3.899"></a><span id="l3.899">             if (typeof valuePart == &quot;string&quot;)</span>
<a href="#l3.900"></a><span id="l3.900">               likePayload += this._escapeLikeStatement.escapeStringForLIKE(</span>
<a href="#l3.901"></a><span id="l3.901">                 valuePart, &quot;/&quot;);</span>
<a href="#l3.902"></a><span id="l3.902">             else</span>
<a href="#l3.903"></a><span id="l3.903">               likePayload += &quot;%&quot;;</span>
<a href="#l3.904"></a><span id="l3.904">           }</span>
<a href="#l3.905"></a><span id="l3.905" class="difflineminus">-          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l3.906"></a><span id="l3.906" class="difflineminus">-            &quot; WHERE &quot; + valueColumnName + &quot; LIKE ? ESCAPE '/'&quot;;</span>
<a href="#l3.907"></a><span id="l3.907" class="difflineplus">+          test = valueColumnName + &quot; LIKE ? ESCAPE '/'&quot;;</span>
<a href="#l3.908"></a><span id="l3.908">           boundArgs.push(likePayload);</span>
<a href="#l3.909"></a><span id="l3.909">         }</span>
<a href="#l3.910"></a><span id="l3.910">         else if (constraintType === this.kConstraintFulltext) {</span>
<a href="#l3.911"></a><span id="l3.911">           let matchStr = constraintValues[0];</span>
<a href="#l3.912"></a><span id="l3.912">           select = &quot;SELECT docid FROM &quot; + nounDef.tableName + &quot;Text&quot; +</span>
<a href="#l3.913"></a><span id="l3.913">             &quot; WHERE &quot; + attrDef.specialColumnName + &quot; MATCH ?&quot;;</span>
<a href="#l3.914"></a><span id="l3.914">           boundArgs.push(matchStr);</span>
<a href="#l3.915"></a><span id="l3.915">         }</span>
<a href="#l3.916"></a><span id="l3.916">         </span>
<a href="#l3.917"></a><span id="l3.917" class="difflineminus">-        if (select)</span>
<a href="#l3.918"></a><span id="l3.918" class="difflineplus">+        if (curConstraintIsSpecial &amp;&amp; lastConstraintWasSpecial) {</span>
<a href="#l3.919"></a><span id="l3.919" class="difflineplus">+          selects[selects.length-1] += &quot; AND &quot; + test;</span>
<a href="#l3.920"></a><span id="l3.920" class="difflineplus">+        }</span>
<a href="#l3.921"></a><span id="l3.921" class="difflineplus">+        else if (select)</span>
<a href="#l3.922"></a><span id="l3.922" class="difflineplus">+          selects.push(select)</span>
<a href="#l3.923"></a><span id="l3.923" class="difflineplus">+        else if (test) {</span>
<a href="#l3.924"></a><span id="l3.924" class="difflineplus">+          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName + &quot; WHERE &quot; +</span>
<a href="#l3.925"></a><span id="l3.925" class="difflineplus">+              test;</span>
<a href="#l3.926"></a><span id="l3.926">           selects.push(select);</span>
<a href="#l3.927"></a><span id="l3.927" class="difflineplus">+        }</span>
<a href="#l3.928"></a><span id="l3.928">         else</span>
<a href="#l3.929"></a><span id="l3.929">           this._log.warning(&quot;Unable to translate constraint of type &quot; + </span>
<a href="#l3.930"></a><span id="l3.930">             constraintType + &quot; on attribute bound as &quot; + aAttrDef.boundName);</span>
<a href="#l3.931"></a><span id="l3.931" class="difflineplus">+</span>
<a href="#l3.932"></a><span id="l3.932" class="difflineplus">+        lastConstraintWasSpecial = curConstraintIsSpecial;</span>
<a href="#l3.933"></a><span id="l3.933">       }</span>
<a href="#l3.934"></a><span id="l3.934"> </span>
<a href="#l3.935"></a><span id="l3.935">       if (selects.length)</span>
<a href="#l3.936"></a><span id="l3.936" class="difflineminus">-        whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot; )&quot;);</span>
<a href="#l3.937"></a><span id="l3.937" class="difflineplus">+        whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot;)&quot;);</span>
<a href="#l3.938"></a><span id="l3.938">     }</span>
<a href="#l3.939"></a><span id="l3.939"> </span>
<a href="#l3.940"></a><span id="l3.940">     let sqlString = &quot;SELECT * FROM &quot; + nounDef.tableName;</span>
<a href="#l3.941"></a><span id="l3.941">     if (whereClauses.length)</span>
<a href="#l3.942"></a><span id="l3.942">       sqlString += &quot; WHERE &quot; + whereClauses.join(&quot; OR &quot;);</span>
<a href="#l3.943"></a><span id="l3.943">     </span>
<a href="#l3.944"></a><span id="l3.944">     if (aQuery._order.length) {</span>
<a href="#l3.945"></a><span id="l3.945">       let orderClauses = [];</span>
<a href="#l3.946"></a><span id="l3.946" class="difflineat">@@ -2456,126 +2534,171 @@ var GlodaDatastore = {</span>
<a href="#l3.947"></a><span id="l3.947">       sqlString += &quot; ORDER BY &quot; + orderClauses.join(&quot;, &quot;);</span>
<a href="#l3.948"></a><span id="l3.948">     }</span>
<a href="#l3.949"></a><span id="l3.949">     </span>
<a href="#l3.950"></a><span id="l3.950">     if (aQuery._limit) {</span>
<a href="#l3.951"></a><span id="l3.951">       sqlString += &quot; LIMIT ?&quot;;</span>
<a href="#l3.952"></a><span id="l3.952">       boundArgs.push(aQuery._limit); </span>
<a href="#l3.953"></a><span id="l3.953">     }</span>
<a href="#l3.954"></a><span id="l3.954"> </span>
<a href="#l3.955"></a><span id="l3.955" class="difflineminus">-    this._log.debug(&quot;QUERY FROM QUERY: &quot; + sqlString);</span>
<a href="#l3.956"></a><span id="l3.956" class="difflineminus">-</span>
<a href="#l3.957"></a><span id="l3.957" class="difflineminus">-    let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l3.958"></a><span id="l3.958" class="difflineminus">-    for (let [iBinding, bindingValue] in Iterator(boundArgs)) {</span>
<a href="#l3.959"></a><span id="l3.959" class="difflineplus">+    this._log.debug(&quot;QUERY FROM QUERY: &quot; + sqlString + &quot; ARGS: &quot; + boundArgs);</span>
<a href="#l3.960"></a><span id="l3.960" class="difflineplus">+    </span>
<a href="#l3.961"></a><span id="l3.961" class="difflineplus">+    return this._queryFromSQLString(sqlString, boundArgs, nounDef, aQuery,</span>
<a href="#l3.962"></a><span id="l3.962" class="difflineplus">+        aListener, aListenerData, aExistingCollection);</span>
<a href="#l3.963"></a><span id="l3.963" class="difflineplus">+  },</span>
<a href="#l3.964"></a><span id="l3.964" class="difflineplus">+  </span>
<a href="#l3.965"></a><span id="l3.965" class="difflineplus">+  _queryFromSQLString: function gloda_ds__queryFromSQLString(aSqlString,</span>
<a href="#l3.966"></a><span id="l3.966" class="difflineplus">+      aBoundArgs, aNounDef, aQuery, aListener, aListenerData,</span>
<a href="#l3.967"></a><span id="l3.967" class="difflineplus">+      aExistingCollection) {</span>
<a href="#l3.968"></a><span id="l3.968" class="difflineplus">+    let statement = this._createAsyncStatement(aSqlString, true);</span>
<a href="#l3.969"></a><span id="l3.969" class="difflineplus">+    for (let [iBinding, bindingValue] in Iterator(aBoundArgs)) {</span>
<a href="#l3.970"></a><span id="l3.970">       this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l3.971"></a><span id="l3.971">     }</span>
<a href="#l3.972"></a><span id="l3.972"> </span>
<a href="#l3.973"></a><span id="l3.973">     let collection;</span>
<a href="#l3.974"></a><span id="l3.974">     if (aExistingCollection)</span>
<a href="#l3.975"></a><span id="l3.975">       collection = aExistingCollection;</span>
<a href="#l3.976"></a><span id="l3.976">     else {</span>
<a href="#l3.977"></a><span id="l3.977" class="difflineminus">-      collection = new GlodaCollection(nounDef, [], aQuery, aListener);</span>
<a href="#l3.978"></a><span id="l3.978" class="difflineplus">+      collection = new GlodaCollection(aNounDef, [], aQuery, aListener);</span>
<a href="#l3.979"></a><span id="l3.979">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l3.980"></a><span id="l3.980">     }</span>
<a href="#l3.981"></a><span id="l3.981">     if (aListenerData !== undefined)</span>
<a href="#l3.982"></a><span id="l3.982">       collection.data = aListenerData;</span>
<a href="#l3.983"></a><span id="l3.983"> </span>
<a href="#l3.984"></a><span id="l3.984" class="difflineminus">-    statement.executeAsync(new QueryFromQueryCallback(statement, nounDef,</span>
<a href="#l3.985"></a><span id="l3.985" class="difflineplus">+    statement.executeAsync(new QueryFromQueryCallback(statement, aNounDef,</span>
<a href="#l3.986"></a><span id="l3.986">       collection));</span>
<a href="#l3.987"></a><span id="l3.987">     statement.finalize();</span>
<a href="#l3.988"></a><span id="l3.988">     return collection;</span>
<a href="#l3.989"></a><span id="l3.989">   },</span>
<a href="#l3.990"></a><span id="l3.990"> </span>
<a href="#l3.991"></a><span id="l3.991">   /**</span>
<a href="#l3.992"></a><span id="l3.992">    * </span>
<a href="#l3.993"></a><span id="l3.993">    * </span>
<a href="#l3.994"></a><span id="l3.994">    */</span>
<a href="#l3.995"></a><span id="l3.995" class="difflineminus">-  loadNounItem: function gloda_ds_loadNounItem(aItem, aReferencesByNounDef) {</span>
<a href="#l3.996"></a><span id="l3.996" class="difflineplus">+  loadNounItem: function gloda_ds_loadNounItem(aItem, aReferencesByNounID,</span>
<a href="#l3.997"></a><span id="l3.997" class="difflineplus">+      aInverseReferencesByNounID) {</span>
<a href="#l3.998"></a><span id="l3.998" class="difflineplus">+    this._log.debug(&quot; load json: &quot; + aItem._jsonText);</span>
<a href="#l3.999"></a><span id="l3.999">     let jsonDict = this._json.decode(aItem._jsonText);</span>
<a href="#l3.1000"></a><span id="l3.1000">     delete aItem._jsonText;</span>
<a href="#l3.1001"></a><span id="l3.1001">     </span>
<a href="#l3.1002"></a><span id="l3.1002">     let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l3.1003"></a><span id="l3.1003">     </span>
<a href="#l3.1004"></a><span id="l3.1004">     let deps = {};</span>
<a href="#l3.1005"></a><span id="l3.1005">     let hasDeps = false;</span>
<a href="#l3.1006"></a><span id="l3.1006">     </span>
<a href="#l3.1007"></a><span id="l3.1007" class="difflineplus">+    for each (let [, attrib] in Iterator(aItem.NOUN_DEF.specialLoadAttribs)) {</span>
<a href="#l3.1008"></a><span id="l3.1008" class="difflineplus">+      let objectNounDef = attrib.objectNounDef;</span>
<a href="#l3.1009"></a><span id="l3.1009" class="difflineplus">+      </span>
<a href="#l3.1010"></a><span id="l3.1010" class="difflineplus">+      if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l3.1011"></a><span id="l3.1011" class="difflineplus">+        let invReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l3.1012"></a><span id="l3.1012" class="difflineplus">+        if (invReferences === undefined)</span>
<a href="#l3.1013"></a><span id="l3.1013" class="difflineplus">+          invReferences = aInverseReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l3.1014"></a><span id="l3.1014" class="difflineplus">+        invReferences[aItem.id] = null;</span>
<a href="#l3.1015"></a><span id="l3.1015" class="difflineplus">+      }</span>
<a href="#l3.1016"></a><span id="l3.1016" class="difflineplus">+      else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l3.1017"></a><span id="l3.1017" class="difflineplus">+        let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l3.1018"></a><span id="l3.1018" class="difflineplus">+        if (references === undefined)</span>
<a href="#l3.1019"></a><span id="l3.1019" class="difflineplus">+          references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l3.1020"></a><span id="l3.1020" class="difflineplus">+        references[aItem[attrib.idStorageAttributeName]] = null;</span>
<a href="#l3.1021"></a><span id="l3.1021" class="difflineplus">+        deps[attrib.id] = null;</span>
<a href="#l3.1022"></a><span id="l3.1022" class="difflineplus">+        hasDeps = true;</span>
<a href="#l3.1023"></a><span id="l3.1023" class="difflineplus">+      }</span>
<a href="#l3.1024"></a><span id="l3.1024" class="difflineplus">+    }</span>
<a href="#l3.1025"></a><span id="l3.1025" class="difflineplus">+    </span>
<a href="#l3.1026"></a><span id="l3.1026">     // Iterate over the attributes on the item</span>
<a href="#l3.1027"></a><span id="l3.1027">     for each (let [attribId, jsonValue] in Iterator(jsonDict)) {</span>
<a href="#l3.1028"></a><span id="l3.1028">       // find the attribute definition that corresponds to this key</span>
<a href="#l3.1029"></a><span id="l3.1029" class="difflineminus">-      let attrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l3.1030"></a><span id="l3.1030" class="difflineplus">+      let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l3.1031"></a><span id="l3.1031">       // the attribute should only fail to exist if an extension was removed</span>
<a href="#l3.1032"></a><span id="l3.1032" class="difflineminus">-      if (attrib === undefined)</span>
<a href="#l3.1033"></a><span id="l3.1033" class="difflineplus">+      if (dbAttrib === undefined)</span>
<a href="#l3.1034"></a><span id="l3.1034">         continue;</span>
<a href="#l3.1035"></a><span id="l3.1035">       </span>
<a href="#l3.1036"></a><span id="l3.1036" class="difflineplus">+      let attrib = dbAttrib.attrDef;</span>
<a href="#l3.1037"></a><span id="l3.1037">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l3.1038"></a><span id="l3.1038">       </span>
<a href="#l3.1039"></a><span id="l3.1039">       // if it has a tableName member, then it's a persistent object that needs</span>
<a href="#l3.1040"></a><span id="l3.1040">       //  to be loaded, which also means we need to hold it in a collection</span>
<a href="#l3.1041"></a><span id="l3.1041">       //  owned by our collection.</span>
<a href="#l3.1042"></a><span id="l3.1042">       if (objectNounDef.tableName) {</span>
<a href="#l3.1043"></a><span id="l3.1043" class="difflineminus">-        let references = aReferencesByNounDef[objectNounDef];</span>
<a href="#l3.1044"></a><span id="l3.1044" class="difflineplus">+        let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l3.1045"></a><span id="l3.1045">         if (references === undefined)</span>
<a href="#l3.1046"></a><span id="l3.1046" class="difflineminus">-          references = aReferencesByNounDef[objectNounDef] = {};</span>
<a href="#l3.1047"></a><span id="l3.1047" class="difflineplus">+          references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l3.1048"></a><span id="l3.1048">           </span>
<a href="#l3.1049"></a><span id="l3.1049">         if (attrib.singular)</span>
<a href="#l3.1050"></a><span id="l3.1050">           references[jsonValue] = null;</span>
<a href="#l3.1051"></a><span id="l3.1051">         else {</span>
<a href="#l3.1052"></a><span id="l3.1052">           for each (let [, anID] in Iterator(jsonValue))</span>
<a href="#l3.1053"></a><span id="l3.1053">             references[anID] = null;</span>
<a href="#l3.1054"></a><span id="l3.1054">         }</span>
<a href="#l3.1055"></a><span id="l3.1055">         </span>
<a href="#l3.1056"></a><span id="l3.1056" class="difflineminus">-        deps[attrib] = jsonValue;</span>
<a href="#l3.1057"></a><span id="l3.1057" class="difflineplus">+        deps[attribId] = jsonValue;</span>
<a href="#l3.1058"></a><span id="l3.1058">         hasDeps = true;</span>
<a href="#l3.1059"></a><span id="l3.1059">       }</span>
<a href="#l3.1060"></a><span id="l3.1060">       /* if it has custom contribution logic, use it */</span>
<a href="#l3.1061"></a><span id="l3.1061">       else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l3.1062"></a><span id="l3.1062">         if (objectNounDef.contributeObjDependencies(jsonValue,</span>
<a href="#l3.1063"></a><span id="l3.1063" class="difflineminus">-                                                    aReferencesByNounDef)) {</span>
<a href="#l3.1064"></a><span id="l3.1064" class="difflineminus">-          deps[attrib] = jsonValue;</span>
<a href="#l3.1065"></a><span id="l3.1065" class="difflineplus">+                             aReferencesByNounID, aInverseReferencesByNounID)) {</span>
<a href="#l3.1066"></a><span id="l3.1066" class="difflineplus">+          deps[attribId] = jsonValue;</span>
<a href="#l3.1067"></a><span id="l3.1067">           hasDeps = true;</span>
<a href="#l3.1068"></a><span id="l3.1068">         }</span>
<a href="#l3.1069"></a><span id="l3.1069">         else // just propagate the value, it's some form of simple sentinel</span>
<a href="#l3.1070"></a><span id="l3.1070">           aItem[attrib.boundName] = jsonValue;</span>
<a href="#l3.1071"></a><span id="l3.1071">       }</span>
<a href="#l3.1072"></a><span id="l3.1072">       // otherwise, the value just needs to be de-persisted, or not</span>
<a href="#l3.1073"></a><span id="l3.1073">       else if (objectNounDef.fromJSON) {</span>
<a href="#l3.1074"></a><span id="l3.1074">         if (attrib.singular)</span>
<a href="#l3.1075"></a><span id="l3.1075">           aItem[attrib.boundName] = objectNounDef.fromJSON(jsonValue);</span>
<a href="#l3.1076"></a><span id="l3.1076">         else</span>
<a href="#l3.1077"></a><span id="l3.1077">           aItem[attrib.boundName] = [objectNounDef.fromJSON(val) for each</span>
<a href="#l3.1078"></a><span id="l3.1078" class="difflineminus">-            ([, val] in Iterator(jsonValue)];</span>
<a href="#l3.1079"></a><span id="l3.1079" class="difflineplus">+            ([, val] in Iterator(jsonValue))];</span>
<a href="#l3.1080"></a><span id="l3.1080">       }</span>
<a href="#l3.1081"></a><span id="l3.1081">       // it's fine as is</span>
<a href="#l3.1082"></a><span id="l3.1082">       else</span>
<a href="#l3.1083"></a><span id="l3.1083">         aItem[attrib.boundName] = jsonValue;</span>
<a href="#l3.1084"></a><span id="l3.1084">     }</span>
<a href="#l3.1085"></a><span id="l3.1085">     </span>
<a href="#l3.1086"></a><span id="l3.1086">     if (hasDeps)</span>
<a href="#l3.1087"></a><span id="l3.1087">       aItem._deps = deps;</span>
<a href="#l3.1088"></a><span id="l3.1088">     return hasDeps;</span>
<a href="#l3.1089"></a><span id="l3.1089">   },</span>
<a href="#l3.1090"></a><span id="l3.1090">   </span>
<a href="#l3.1091"></a><span id="l3.1091">   loadNounDeferredDeps: function gloda_ds_loadNounDeferredDeps(aItem,</span>
<a href="#l3.1092"></a><span id="l3.1092" class="difflineminus">-      aReferencesByNounDef) {</span>
<a href="#l3.1093"></a><span id="l3.1093" class="difflineplus">+      aReferencesByNounID, aInverseReferencesByNounID) {</span>
<a href="#l3.1094"></a><span id="l3.1094">     if (aItem._deps === undefined)</span>
<a href="#l3.1095"></a><span id="l3.1095">       return;</span>
<a href="#l3.1096"></a><span id="l3.1096">     </span>
<a href="#l3.1097"></a><span id="l3.1097" class="difflineminus">-    for (let [attrib, jsonValue] in Iterator(aItem._deps)) {</span>
<a href="#l3.1098"></a><span id="l3.1098" class="difflineplus">+    let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l3.1099"></a><span id="l3.1099" class="difflineplus">+</span>
<a href="#l3.1100"></a><span id="l3.1100" class="difflineplus">+    for (let [attribId, jsonValue] in Iterator(aItem._deps)) {</span>
<a href="#l3.1101"></a><span id="l3.1101" class="difflineplus">+      let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l3.1102"></a><span id="l3.1102" class="difflineplus">+      let attrib = dbAttrib.attrDef;</span>
<a href="#l3.1103"></a><span id="l3.1103" class="difflineplus">+      </span>
<a href="#l3.1104"></a><span id="l3.1104">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l3.1105"></a><span id="l3.1105" class="difflineminus">-      let references = aReferencesByNounDef[objectNounDef];</span>
<a href="#l3.1106"></a><span id="l3.1106" class="difflineminus">-      if (objectNounDef.tableName) {</span>
<a href="#l3.1107"></a><span id="l3.1107" class="difflineplus">+      let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l3.1108"></a><span id="l3.1108" class="difflineplus">+      if (attrib.special) {</span>
<a href="#l3.1109"></a><span id="l3.1109" class="difflineplus">+        if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l3.1110"></a><span id="l3.1110" class="difflineplus">+          let inverseReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l3.1111"></a><span id="l3.1111" class="difflineplus">+          aItem[attrib.storageAttributeName] = inverseReferences[aItem.id];</span>
<a href="#l3.1112"></a><span id="l3.1112" class="difflineplus">+        }</span>
<a href="#l3.1113"></a><span id="l3.1113" class="difflineplus">+        else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l3.1114"></a><span id="l3.1114" class="difflineplus">+          aItem[attrib.valueStorageAttributeName] =</span>
<a href="#l3.1115"></a><span id="l3.1115" class="difflineplus">+            references[aItem[attrib.idStorageAttributeName]];</span>
<a href="#l3.1116"></a><span id="l3.1116" class="difflineplus">+        }</span>
<a href="#l3.1117"></a><span id="l3.1117" class="difflineplus">+      }</span>
<a href="#l3.1118"></a><span id="l3.1118" class="difflineplus">+      else if (objectNounDef.tableName) {</span>
<a href="#l3.1119"></a><span id="l3.1119">         if (attrib.singular)</span>
<a href="#l3.1120"></a><span id="l3.1120">           aItem[attrib.boundName] = references[jsonValue];</span>
<a href="#l3.1121"></a><span id="l3.1121">         else</span>
<a href="#l3.1122"></a><span id="l3.1122">           aItem[attrib.boundName] = [references[val] for each</span>
<a href="#l3.1123"></a><span id="l3.1123" class="difflineminus">-                                     ([, val] in Iterator(jsonValue)];</span>
<a href="#l3.1124"></a><span id="l3.1124" class="difflineplus">+                                     ([, val] in Iterator(jsonValue))];</span>
<a href="#l3.1125"></a><span id="l3.1125">       }</span>
<a href="#l3.1126"></a><span id="l3.1126">       else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l3.1127"></a><span id="l3.1127">         aItem[attrib.boundName] =</span>
<a href="#l3.1128"></a><span id="l3.1128" class="difflineminus">-          objectNounDef.resolveObjDependencies(jsonValue, aReferencesByNounDef);</span>
<a href="#l3.1129"></a><span id="l3.1129" class="difflineplus">+          objectNounDef.resolveObjDependencies(jsonValue, aReferencesByNounID,</span>
<a href="#l3.1130"></a><span id="l3.1130" class="difflineplus">+            aInverseReferencesByNounID);</span>
<a href="#l3.1131"></a><span id="l3.1131">       }</span>
<a href="#l3.1132"></a><span id="l3.1132">       // there is no other case</span>
<a href="#l3.1133"></a><span id="l3.1133">     }</span>
<a href="#l3.1134"></a><span id="l3.1134">     </span>
<a href="#l3.1135"></a><span id="l3.1135">     delete aItem._deps;</span>
<a href="#l3.1136"></a><span id="l3.1136">   },</span>
<a href="#l3.1137"></a><span id="l3.1137"> </span>
<a href="#l3.1138"></a><span id="l3.1138">   /* ********** Contact ********** */</span>
<a href="#l3.1139"></a><span id="l3.1139" class="difflineat">@@ -2619,51 +2742,51 @@ var GlodaDatastore = {</span>
<a href="#l3.1140"></a><span id="l3.1140">     if (aContact.contactUUID == null)</span>
<a href="#l3.1141"></a><span id="l3.1141">       ics.bindNullParameter(2);</span>
<a href="#l3.1142"></a><span id="l3.1142">     else</span>
<a href="#l3.1143"></a><span id="l3.1143">       ics.bindStringParameter(2, aContact.contactUUID);</span>
<a href="#l3.1144"></a><span id="l3.1144">     ics.bindStringParameter(3, aContact.name);</span>
<a href="#l3.1145"></a><span id="l3.1145">     ics.bindInt64Parameter(4, aContact.popularity);</span>
<a href="#l3.1146"></a><span id="l3.1146">     ics.bindInt64Parameter(5, aContact.frecency);</span>
<a href="#l3.1147"></a><span id="l3.1147">     if (aContact._jsonText)</span>
<a href="#l3.1148"></a><span id="l3.1148" class="difflineminus">-      ims.bindStringParameter(6, aContact._jsonText);</span>
<a href="#l3.1149"></a><span id="l3.1149" class="difflineplus">+      ics.bindStringParameter(6, aContact._jsonText);</span>
<a href="#l3.1150"></a><span id="l3.1150">     else</span>
<a href="#l3.1151"></a><span id="l3.1151" class="difflineminus">-      ims.bindNullParameter(6);</span>
<a href="#l3.1152"></a><span id="l3.1152" class="difflineplus">+      ics.bindNullParameter(6);</span>
<a href="#l3.1153"></a><span id="l3.1153"> </span>
<a href="#l3.1154"></a><span id="l3.1154">     ics.executeAsync(this.trackAsync());</span>
<a href="#l3.1155"></a><span id="l3.1155"> </span>
<a href="#l3.1156"></a><span id="l3.1156" class="difflineminus">-    GlodaCollectionManager.itemsAdded(contact.NOUN_ID, [contact]);</span>
<a href="#l3.1157"></a><span id="l3.1157" class="difflineminus">-    return contact;</span>
<a href="#l3.1158"></a><span id="l3.1158" class="difflineplus">+    GlodaCollectionManager.itemsAdded(aContact.NOUN_ID, [aContact]);</span>
<a href="#l3.1159"></a><span id="l3.1159" class="difflineplus">+    return aContact;</span>
<a href="#l3.1160"></a><span id="l3.1160">   },</span>
<a href="#l3.1161"></a><span id="l3.1161"> </span>
<a href="#l3.1162"></a><span id="l3.1162">   get _updateContactStatement() {</span>
<a href="#l3.1163"></a><span id="l3.1163">     let statement = this._createAsyncStatement(</span>
<a href="#l3.1164"></a><span id="l3.1164">       &quot;UPDATE contacts SET directoryUUID = ?1, \</span>
<a href="#l3.1165"></a><span id="l3.1165">                            contactUUID = ?2, \</span>
<a href="#l3.1166"></a><span id="l3.1166">                            name = ?3, \</span>
<a href="#l3.1167"></a><span id="l3.1167">                            popularity = ?4, \</span>
<a href="#l3.1168"></a><span id="l3.1168" class="difflineminus">-                           frecency = ?5,</span>
<a href="#l3.1169"></a><span id="l3.1169" class="difflineplus">+                           frecency = ?5, \</span>
<a href="#l3.1170"></a><span id="l3.1170">                            jsonAttributes = ?6 \</span>
<a href="#l3.1171"></a><span id="l3.1171">                        WHERE id = ?7&quot;);</span>
<a href="#l3.1172"></a><span id="l3.1172">     this.__defineGetter__(&quot;_updateContactStatement&quot;, function() statement);</span>
<a href="#l3.1173"></a><span id="l3.1173">     return this._updateContactStatement;</span>
<a href="#l3.1174"></a><span id="l3.1174">   },</span>
<a href="#l3.1175"></a><span id="l3.1175"> </span>
<a href="#l3.1176"></a><span id="l3.1176">   updateContact: function gloda_ds_updateContact(aContact) {</span>
<a href="#l3.1177"></a><span id="l3.1177">     let ucs = this._updateContactStatement;</span>
<a href="#l3.1178"></a><span id="l3.1178">     ucs.bindInt64Parameter(6, aContact.id);</span>
<a href="#l3.1179"></a><span id="l3.1179">     ucs.bindStringParameter(0, aContact.directoryUUID);</span>
<a href="#l3.1180"></a><span id="l3.1180">     ucs.bindStringParameter(1, aContact.contactUUID);</span>
<a href="#l3.1181"></a><span id="l3.1181">     ucs.bindStringParameter(2, aContact.name);</span>
<a href="#l3.1182"></a><span id="l3.1182">     ucs.bindInt64Parameter(3, aContact.popularity);</span>
<a href="#l3.1183"></a><span id="l3.1183">     ucs.bindInt64Parameter(4, aContact.frecency);</span>
<a href="#l3.1184"></a><span id="l3.1184">     if (aContact._jsonText)</span>
<a href="#l3.1185"></a><span id="l3.1185" class="difflineminus">-      ims.bindStringParameter(5, aContact._jsonText);</span>
<a href="#l3.1186"></a><span id="l3.1186" class="difflineplus">+      ucs.bindStringParameter(5, aContact._jsonText);</span>
<a href="#l3.1187"></a><span id="l3.1187">     else</span>
<a href="#l3.1188"></a><span id="l3.1188" class="difflineminus">-      ims.bindNullParameter(5);</span>
<a href="#l3.1189"></a><span id="l3.1189" class="difflineplus">+      ucs.bindNullParameter(5);</span>
<a href="#l3.1190"></a><span id="l3.1190"> </span>
<a href="#l3.1191"></a><span id="l3.1191">     ucs.executeAsync(this.trackAsync());</span>
<a href="#l3.1192"></a><span id="l3.1192">   },</span>
<a href="#l3.1193"></a><span id="l3.1193"> </span>
<a href="#l3.1194"></a><span id="l3.1194">   _contactFromRow: function gloda_ds_contactFromRow(aRow) {</span>
<a href="#l3.1195"></a><span id="l3.1195">     let directoryUUID, contactUUID;</span>
<a href="#l3.1196"></a><span id="l3.1196">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.1197"></a><span id="l3.1197">       directoryUUID = null;</span>
<a href="#l3.1198"></a><span id="l3.1198" class="difflineat">@@ -2671,17 +2794,18 @@ var GlodaDatastore = {</span>
<a href="#l3.1199"></a><span id="l3.1199">       directoryUUID = aRow.getString(1);</span>
<a href="#l3.1200"></a><span id="l3.1200">     if (aRow.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.1201"></a><span id="l3.1201">       contactUUID = null;</span>
<a href="#l3.1202"></a><span id="l3.1202">     else</span>
<a href="#l3.1203"></a><span id="l3.1203">       contactUUID = aRow.getString(2);</span>
<a href="#l3.1204"></a><span id="l3.1204"> </span>
<a href="#l3.1205"></a><span id="l3.1205">     return new GlodaContact(this, aRow.getInt64(0), directoryUUID,</span>
<a href="#l3.1206"></a><span id="l3.1206">                             contactUUID, aRow.getString(5),</span>
<a href="#l3.1207"></a><span id="l3.1207" class="difflineminus">-                            aRow.getInt64(3), aRow.getInt64(4));</span>
<a href="#l3.1208"></a><span id="l3.1208" class="difflineplus">+                            aRow.getInt64(3), aRow.getInt64(4),</span>
<a href="#l3.1209"></a><span id="l3.1209" class="difflineplus">+                            aRow.getString(5));</span>
<a href="#l3.1210"></a><span id="l3.1210">   },</span>
<a href="#l3.1211"></a><span id="l3.1211"> </span>
<a href="#l3.1212"></a><span id="l3.1212">   get _selectContactByIDStatement() {</span>
<a href="#l3.1213"></a><span id="l3.1213">     let statement = this._createSyncStatement(</span>
<a href="#l3.1214"></a><span id="l3.1214">       &quot;SELECT * FROM contacts WHERE id = ?1&quot;);</span>
<a href="#l3.1215"></a><span id="l3.1215">     this.__defineGetter__(&quot;_selectContactByIDStatement&quot;,</span>
<a href="#l3.1216"></a><span id="l3.1216">       function() statement);</span>
<a href="#l3.1217"></a><span id="l3.1217">     return this._selectContactByIDStatement;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/explattr.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/explattr.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -129,19 +129,22 @@ var GlodaExplicitAttr = {</span>
<a href="#l4.4"></a><span id="l4.4">                         singular: true,</span>
<a href="#l4.5"></a><span id="l4.5">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l4.6"></a><span id="l4.6">                         objectNoun: Gloda.NOUN_BOOLEAN,</span>
<a href="#l4.7"></a><span id="l4.7">                         parameterNoun: null,</span>
<a href="#l4.8"></a><span id="l4.8">                         }); // tested-by: test_attributes_explicit</span>
<a href="#l4.9"></a><span id="l4.9">     </span>
<a href="#l4.10"></a><span id="l4.10">   },</span>
<a href="#l4.11"></a><span id="l4.11">   </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-  process: function Gloda_explattr_process(aGlodaMessage, aMsgHdr, aMimeMsg) {</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+  process: function Gloda_explattr_process(aGlodaMessage, aRawReps, aIsNew,</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+                                           aCallbackHandle) {</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+    let aMsgHdr = aRawReps.header;</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+    </span>
<a href="#l4.17"></a><span id="l4.17">     aGlodaMessage.flagged = aMsgHdr.isFlagged;</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineminus">-    aGlodeMessage.read = aMsgHdr.isRead;</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+    aGlodaMessage.read = aMsgHdr.isRead;</span>
<a href="#l4.20"></a><span id="l4.20">     </span>
<a href="#l4.21"></a><span id="l4.21">     let tags = aGlodaMessage.tags = [];</span>
<a href="#l4.22"></a><span id="l4.22">     </span>
<a href="#l4.23"></a><span id="l4.23">     // -- Tag</span>
<a href="#l4.24"></a><span id="l4.24">     // build a map of the keywords</span>
<a href="#l4.25"></a><span id="l4.25">     let keywords = aMsgHdr.getStringProperty(&quot;keywords&quot;);</span>
<a href="#l4.26"></a><span id="l4.26">     let keywordList = keywords.split(' ');</span>
<a href="#l4.27"></a><span id="l4.27">     let keywordMap = {};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/fundattr.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/fundattr.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -291,18 +291,18 @@ var GlodaFundAttr = {</span>
<a href="#l5.4"></a><span id="l5.4">     // me specialization optimizations</span>
<a href="#l5.5"></a><span id="l5.5">     let toMe = aGlodaMessage.toMe;</span>
<a href="#l5.6"></a><span id="l5.6">     if (toMe === undefined)</span>
<a href="#l5.7"></a><span id="l5.7">       toMe = aGlodaMessage.toMe = [];</span>
<a href="#l5.8"></a><span id="l5.8">     let fromMeTo = aGlodaMessage.fromMeTo;</span>
<a href="#l5.9"></a><span id="l5.9">     if (fromMeTo === undefined)</span>
<a href="#l5.10"></a><span id="l5.10">       fromMeTo = aGlodaMessage.fromMeTo = [];</span>
<a href="#l5.11"></a><span id="l5.11">     let ccMe = aGlodaMessage.ccMe;</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-    if (ccMe === undefineD)</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineminus">-      ccMe = aGlodaMEssage.ccMe = [];</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+    if (ccMe === undefined)</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+      ccMe = aGlodaMessage.ccMe = [];</span>
<a href="#l5.16"></a><span id="l5.16">     let fromMeCc = aGlodaMessage.fromMeCc;</span>
<a href="#l5.17"></a><span id="l5.17">     if (fromMeCc === undefined)</span>
<a href="#l5.18"></a><span id="l5.18">       fromMeCc = aGlodaMessage.fromMeCc = [];</span>
<a href="#l5.19"></a><span id="l5.19">     </span>
<a href="#l5.20"></a><span id="l5.20">     // -- From</span>
<a href="#l5.21"></a><span id="l5.21">     // Let's use replyTo if available.</span>
<a href="#l5.22"></a><span id="l5.22">     // er, since we are just dealing with mailing lists for now, forget the</span>
<a href="#l5.23"></a><span id="l5.23">     //  reply-to...</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineat">@@ -324,36 +324,37 @@ var GlodaFundAttr = {</span>
<a href="#l5.25"></a><span id="l5.25">                                         author, aMsgHdr.recipients,</span>
<a href="#l5.26"></a><span id="l5.26">                                         aMsgHdr.ccList));</span>
<a href="#l5.27"></a><span id="l5.27"> </span>
<a href="#l5.28"></a><span id="l5.28">     if (authorIdentities.length == 0) {</span>
<a href="#l5.29"></a><span id="l5.29">       this._log.error(&quot;Message with subject '&quot; + aMsgHdr.mime2DecodedSubject +</span>
<a href="#l5.30"></a><span id="l5.30">                       &quot;' somehow lacks a valid author.  Bailing.&quot;);</span>
<a href="#l5.31"></a><span id="l5.31">       return; // being a generator, this generates an exception; we like.</span>
<a href="#l5.32"></a><span id="l5.32">     }</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineminus">-    aGlodaMessage.from = authorIdentities[0];</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineminus">-    involved.push(authorIdentities[0]);</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineminus">-    involvedIdentities[authorIdentities[0].id] = true;</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+    let authorIdentity = authorIdentities[0];</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineplus">+    aGlodaMessage.from = authorIdentity;</span>
<a href="#l5.38"></a><span id="l5.38" class="difflineplus">+    involved.push(authorIdentity);</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineplus">+    involvedIdentities[authorIdentity.id] = true;</span>
<a href="#l5.40"></a><span id="l5.40">     </span>
<a href="#l5.41"></a><span id="l5.41">     let myIdentities = Gloda.myIdentities; // needless optimization?</span>
<a href="#l5.42"></a><span id="l5.42">     let isFromMe = authorIdentity.id in myIdentities;</span>
<a href="#l5.43"></a><span id="l5.43">     </span>
<a href="#l5.44"></a><span id="l5.44">     // -- To, Cc</span>
<a href="#l5.45"></a><span id="l5.45">     // TODO: handle mailing list semantics (use my visterity logic as a first</span>
<a href="#l5.46"></a><span id="l5.46">     //  pass.)</span>
<a href="#l5.47"></a><span id="l5.47">     for (let iTo = 0; iTo &lt; toIdentities.length; iTo++) {</span>
<a href="#l5.48"></a><span id="l5.48">       let toIdentity = toIdentities[iTo];</span>
<a href="#l5.49"></a><span id="l5.49">       to.push(toIdentity);</span>
<a href="#l5.50"></a><span id="l5.50">       if (!(toIdentity.id in involvedIdentities)) {</span>
<a href="#l5.51"></a><span id="l5.51">         involved.push(toIdentity);</span>
<a href="#l5.52"></a><span id="l5.52">         involvedIdentities[toIdentity.id] = true;</span>
<a href="#l5.53"></a><span id="l5.53">       }</span>
<a href="#l5.54"></a><span id="l5.54">       // optimization attribute to-me ('I' am the parameter)</span>
<a href="#l5.55"></a><span id="l5.55">       if (toIdentity.id in myIdentities) {</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineminus">-        toMe.push([toIDentity, authorIdentity]);</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+        toMe.push([toIdentity, authorIdentity]);</span>
<a href="#l5.58"></a><span id="l5.58">         if (aIsNew)</span>
<a href="#l5.59"></a><span id="l5.59">           authorIdentity.contact.popularity += this.POPULARITY_TO_ME;</span>
<a href="#l5.60"></a><span id="l5.60">       }</span>
<a href="#l5.61"></a><span id="l5.61">       // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l5.62"></a><span id="l5.62">       if (isFromMe) {</span>
<a href="#l5.63"></a><span id="l5.63">         fromMeTo.push([authorIdentity, toIdentity]);</span>
<a href="#l5.64"></a><span id="l5.64">         // also, popularity</span>
<a href="#l5.65"></a><span id="l5.65">         if (aIsNew)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -147,17 +147,17 @@ var Gloda = {</span>
<a href="#l6.4"></a><span id="l6.4">    *</span>
<a href="#l6.5"></a><span id="l6.5">    * Additional nouns and the core attribute providers are initialized by the</span>
<a href="#l6.6"></a><span id="l6.6">    *  everybody.js module which ensures all of those dependencies are loaded</span>
<a href="#l6.7"></a><span id="l6.7">    *  (and initialized).</span>
<a href="#l6.8"></a><span id="l6.8">    */</span>
<a href="#l6.9"></a><span id="l6.9">   _init: function gloda_ns_init() {</span>
<a href="#l6.10"></a><span id="l6.10">     this._initLogging();</span>
<a href="#l6.11"></a><span id="l6.11">     this._json = Cc[&quot;@mozilla.org/dom/json;1&quot;].createInstance(Ci.nsIJSON);</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-    GlodaDatastore._init(this._jsn);</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+    GlodaDatastore._init(this._json, this._nounIDToDef);</span>
<a href="#l6.14"></a><span id="l6.14">     this._initAttributes();</span>
<a href="#l6.15"></a><span id="l6.15">     this._initMyIdentities();</span>
<a href="#l6.16"></a><span id="l6.16">   },</span>
<a href="#l6.17"></a><span id="l6.17"> </span>
<a href="#l6.18"></a><span id="l6.18">   _log: null,</span>
<a href="#l6.19"></a><span id="l6.19">   /**</span>
<a href="#l6.20"></a><span id="l6.20">    * Initialize logging; the error console window gets Warning/Error, and stdout</span>
<a href="#l6.21"></a><span id="l6.21">    *  (via dump) gets everything.</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineat">@@ -249,59 +249,70 @@ var Gloda = {</span>
<a href="#l6.23"></a><span id="l6.23">           addresses[address].push(resultList);</span>
<a href="#l6.24"></a><span id="l6.24">         else</span>
<a href="#l6.25"></a><span id="l6.25">           addresses[address] = [parsed.names[iAddress], resultList];</span>
<a href="#l6.26"></a><span id="l6.26">       }</span>
<a href="#l6.27"></a><span id="l6.27">     }</span>
<a href="#l6.28"></a><span id="l6.28"> </span>
<a href="#l6.29"></a><span id="l6.29">     let query = this.newQuery(this.NOUN_IDENTITY);</span>
<a href="#l6.30"></a><span id="l6.30">     query.kind(&quot;email&quot;);</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-    query.value.apply(query.value, [address for (address in addresses)]);</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+    query.value.apply(query, [address for (address in addresses)]);</span>
<a href="#l6.33"></a><span id="l6.33">     let collection = query.getCollection(aCallbackHandle);</span>
<a href="#l6.34"></a><span id="l6.34">     yield this.kWorkAsync;</span>
<a href="#l6.35"></a><span id="l6.35"> </span>
<a href="#l6.36"></a><span id="l6.36">     // put the identities in the appropriate result lists</span>
<a href="#l6.37"></a><span id="l6.37">     for each (let [, identity] in Iterator(collection.items)) {</span>
<a href="#l6.38"></a><span id="l6.38">       let nameAndResultLists = addresses[identity.value];</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+      this._log.debug(&quot; found identity for '&quot; + nameAndResultLists[0] + &quot;' (&quot; +</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+                      identity.value + &quot;)&quot;);</span>
<a href="#l6.41"></a><span id="l6.41">       // index 0 is the name, skip it</span>
<a href="#l6.42"></a><span id="l6.42">       for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++) {</span>
<a href="#l6.43"></a><span id="l6.43">         nameAndResultLists[iResList].push(identity);</span>
<a href="#l6.44"></a><span id="l6.44">       }</span>
<a href="#l6.45"></a><span id="l6.45">       delete addresses[identity.value];</span>
<a href="#l6.46"></a><span id="l6.46">     }</span>
<a href="#l6.47"></a><span id="l6.47">     </span>
<a href="#l6.48"></a><span id="l6.48">     // create the identities that did not exist yet</span>
<a href="#l6.49"></a><span id="l6.49">     for each (let [address, nameAndResultLists] in Iterator(addresses)) {</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineminus">-      let name = nameAndResultsLists[0];</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineplus">+      let name = nameAndResultLists[0];</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineplus">+      </span>
<a href="#l6.53"></a><span id="l6.53" class="difflineplus">+      this._log.debug(&quot; creating contact for '&quot; + name + &quot;' (&quot; + address + &quot;)&quot;);</span>
<a href="#l6.54"></a><span id="l6.54"> </span>
<a href="#l6.55"></a><span id="l6.55">       // try and find an existing address book contact.</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineminus">-      let card = GlodaUtils.getCardForEmail();</span>
<a href="#l6.57"></a><span id="l6.57" class="difflineplus">+      let card = GlodaUtils.getCardForEmail(address);</span>
<a href="#l6.58"></a><span id="l6.58">       // XXX when we have the address book GUID stuff, we need to use that to</span>
<a href="#l6.59"></a><span id="l6.59">       //  find existing contacts... (this will introduce a new query phase</span>
<a href="#l6.60"></a><span id="l6.60">       //  where we batch all the GUIDs for an async query)</span>
<a href="#l6.61"></a><span id="l6.61">       // XXX when the address book supports multiple e-mail addresses, we</span>
<a href="#l6.62"></a><span id="l6.62">       //  should also just create identities for any that don't yet exist</span>
<a href="#l6.63"></a><span id="l6.63"> </span>
<a href="#l6.64"></a><span id="l6.64">       let contact = GlodaDatastore.createContact(null, null, name, 0, 0);</span>
<a href="#l6.65"></a><span id="l6.65" class="difflineplus">+</span>
<a href="#l6.66"></a><span id="l6.66" class="difflineplus">+      // we must create the identity.  use a blank description because there's</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineplus">+      //  nothing to differentiate it from other identities, as this contact</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+      //  only has one initially (us).</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineplus">+      // XXX when we have multiple e-mails and there is a meaning associated</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineplus">+      //  with each e-mail, try and use that to populate the description.</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+      // XXX we are creating the identity here before we insert the contact.</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+      //  conceptually it is good for us to be creating the identity before</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+      //  exposing it to the address-book indexer, but we could get our id's</span>
<a href="#l6.74"></a><span id="l6.74" class="difflineplus">+      //  in a bad way from not deferring the identity insertion until after</span>
<a href="#l6.75"></a><span id="l6.75" class="difflineplus">+      //  the contact insertion.</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineplus">+      let identity = GlodaDatastore.createIdentity(contact.id, contact,</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineplus">+        &quot;email&quot;, address, /* description */ &quot;&quot;, /* relay? */ false);</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineplus">+      contact._identities = [identity];</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineplus">+      </span>
<a href="#l6.80"></a><span id="l6.80">       // give the address book indexer a chance if we have a card.</span>
<a href="#l6.81"></a><span id="l6.81">       // (it will fix-up the name based on the card as appropriate)</span>
<a href="#l6.82"></a><span id="l6.82">       if (card)</span>
<a href="#l6.83"></a><span id="l6.83">         yield aCallbackHandle.pushAndGo(</span>
<a href="#l6.84"></a><span id="l6.84">           Gloda.grokNounItem(contact, card, true));</span>
<a href="#l6.85"></a><span id="l6.85">       else // grokNounItem will issue the insert for us...</span>
<a href="#l6.86"></a><span id="l6.86">         GlodaDatastore.insertContact(contact);</span>
<a href="#l6.87"></a><span id="l6.87"> </span>
<a href="#l6.88"></a><span id="l6.88" class="difflineminus">-      // we must create the identity.  use a blank description because there's</span>
<a href="#l6.89"></a><span id="l6.89" class="difflineminus">-      //  nothing to differentiate it from other identities, as this contact</span>
<a href="#l6.90"></a><span id="l6.90" class="difflineminus">-      //  only has one initially (us).</span>
<a href="#l6.91"></a><span id="l6.91" class="difflineminus">-      // XXX when we have multiple e-mails and there is a meaning associated</span>
<a href="#l6.92"></a><span id="l6.92" class="difflineminus">-      //  with each e-mail, try and use that to populate the description. </span>
<a href="#l6.93"></a><span id="l6.93" class="difflineminus">-      let identity = GlodaDatastore.createIdentity(contact.id, contact,</span>
<a href="#l6.94"></a><span id="l6.94" class="difflineminus">-        &quot;email&quot;, mailAddr, /* description */ &quot;&quot;, /* relay? */ false);</span>
<a href="#l6.95"></a><span id="l6.95" class="difflineminus">-      </span>
<a href="#l6.96"></a><span id="l6.96">       for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++) {</span>
<a href="#l6.97"></a><span id="l6.97">         nameAndResultLists[iResList].push(identity);</span>
<a href="#l6.98"></a><span id="l6.98">       }</span>
<a href="#l6.99"></a><span id="l6.99">     }</span>
<a href="#l6.100"></a><span id="l6.100"> </span>
<a href="#l6.101"></a><span id="l6.101">     yield aCallbackHandle.doneWithResult(resultLists);</span>
<a href="#l6.102"></a><span id="l6.102">   },</span>
<a href="#l6.103"></a><span id="l6.103"> </span>
<a href="#l6.104"></a><span id="l6.104" class="difflineat">@@ -377,16 +388,21 @@ var Gloda = {</span>
<a href="#l6.105"></a><span id="l6.105">             existingIdentities.push(identity);</span>
<a href="#l6.106"></a><span id="l6.106">           else</span>
<a href="#l6.107"></a><span id="l6.107">             identitiesToCreate.push(parsed.addresses[0]);</span>
<a href="#l6.108"></a><span id="l6.108">           myEmailAddresses[parsed.addresses[0]] = true;</span>
<a href="#l6.109"></a><span id="l6.109">         }</span>
<a href="#l6.110"></a><span id="l6.110">       }</span>
<a href="#l6.111"></a><span id="l6.111">     }</span>
<a href="#l6.112"></a><span id="l6.112"> </span>
<a href="#l6.113"></a><span id="l6.113" class="difflineplus">+    // we need to establish the identity.contact portions of the relationship</span>
<a href="#l6.114"></a><span id="l6.114" class="difflineplus">+    for each (let [,identity] in Iterator(existingIdentities)) {</span>
<a href="#l6.115"></a><span id="l6.115" class="difflineplus">+      identity._contact = GlodaDatastore.getContactByID(identity.contactID);</span>
<a href="#l6.116"></a><span id="l6.116" class="difflineplus">+    }</span>
<a href="#l6.117"></a><span id="l6.117" class="difflineplus">+    </span>
<a href="#l6.118"></a><span id="l6.118">     if (existingIdentities.length) {</span>
<a href="#l6.119"></a><span id="l6.119">       // just use the first guy's contact</span>
<a href="#l6.120"></a><span id="l6.120">       myContact = existingIdentities[0].contact;</span>
<a href="#l6.121"></a><span id="l6.121">     }</span>
<a href="#l6.122"></a><span id="l6.122">     else {</span>
<a href="#l6.123"></a><span id="l6.123">       // create a new contact</span>
<a href="#l6.124"></a><span id="l6.124">       myContact = GlodaDatastore.createContact(null, null, fullName || &quot;Me&quot;,</span>
<a href="#l6.125"></a><span id="l6.125">                                                0, 0);</span>
<a href="#l6.126"></a><span id="l6.126" class="difflineat">@@ -410,17 +426,17 @@ var Gloda = {</span>
<a href="#l6.127"></a><span id="l6.127"> </span>
<a href="#l6.128"></a><span id="l6.128">     for (let iIdentity = 0; iIdentity &lt; existingIdentities.length;</span>
<a href="#l6.129"></a><span id="l6.129">         iIdentity++) {</span>
<a href="#l6.130"></a><span id="l6.130">       let identity = existingIdentities[iIdentity];</span>
<a href="#l6.131"></a><span id="l6.131">       myIdentities[identity.id] = identity;</span>
<a href="#l6.132"></a><span id="l6.132">     }</span>
<a href="#l6.133"></a><span id="l6.133"> </span>
<a href="#l6.134"></a><span id="l6.134">     this.myContact = myContact;</span>
<a href="#l6.135"></a><span id="l6.135" class="difflineminus">-    this.myIdentities = myIdentities;</span>
<a href="#l6.136"></a><span id="l6.136" class="difflineplus">+    this.myIdentities = myContact._identities = myIdentities;</span>
<a href="#l6.137"></a><span id="l6.137">   },</span>
<a href="#l6.138"></a><span id="l6.138"> </span>
<a href="#l6.139"></a><span id="l6.139">   /**</span>
<a href="#l6.140"></a><span id="l6.140">    * An attribute that is a defining characteristic of the subject.</span>
<a href="#l6.141"></a><span id="l6.141">    */</span>
<a href="#l6.142"></a><span id="l6.142">   kAttrFundamental: 0,</span>
<a href="#l6.143"></a><span id="l6.143">   /**</span>
<a href="#l6.144"></a><span id="l6.144">    * An attribute that is an optimization derived from two or more fundamental</span>
<a href="#l6.145"></a><span id="l6.145" class="difflineat">@@ -448,23 +464,25 @@ var Gloda = {</span>
<a href="#l6.146"></a><span id="l6.146">   kAttrImplicit: 4,</span>
<a href="#l6.147"></a><span id="l6.147"> </span>
<a href="#l6.148"></a><span id="l6.148">   /**</span>
<a href="#l6.149"></a><span id="l6.149">    * This attribute is not 'special'; it is stored as a (thing id, attribute id,</span>
<a href="#l6.150"></a><span id="l6.150">    *  attribute id) tuple in the database rather than on thing's row or on</span>
<a href="#l6.151"></a><span id="l6.151">    *  thing's fulltext row.  (Where &quot;thing&quot; could be a message or any other</span>
<a href="#l6.152"></a><span id="l6.152">    *  first class noun.)</span>
<a href="#l6.153"></a><span id="l6.153">    */</span>
<a href="#l6.154"></a><span id="l6.154" class="difflineminus">-  kSpecialNotAtAll: 0,</span>
<a href="#l6.155"></a><span id="l6.155" class="difflineplus">+  kSpecialNotAtAll: GlodaDatastore.kSpecialNotAtAll,</span>
<a href="#l6.156"></a><span id="l6.156">   /**</span>
<a href="#l6.157"></a><span id="l6.157">    * This attribute is stored as a numeric column on the row for the noun.  The</span>
<a href="#l6.158"></a><span id="l6.158">    *  attribute definition should include this value as 'special' and the</span>
<a href="#l6.159"></a><span id="l6.159">    *  column name that stores the attribute as 'specialColumnName'.</span>
<a href="#l6.160"></a><span id="l6.160">    */</span>
<a href="#l6.161"></a><span id="l6.161">   kSpecialColumn: GlodaDatastore.kSpecialColumn,</span>
<a href="#l6.162"></a><span id="l6.162" class="difflineplus">+  kSpecialColumnChildren: GlodaDatastore.kSpecialColumnChildren,</span>
<a href="#l6.163"></a><span id="l6.163" class="difflineplus">+  kSpecialColumnParent: GlodaDatastore.kSpecialColumnParent,</span>
<a href="#l6.164"></a><span id="l6.164">   /**</span>
<a href="#l6.165"></a><span id="l6.165">    * This attribute is stored as a string column on the row for the noun.  It</span>
<a href="#l6.166"></a><span id="l6.166">    *  differs from kSpecialColumn in that it is a string and thus uses different</span>
<a href="#l6.167"></a><span id="l6.167">    *  query mechanisms.</span>
<a href="#l6.168"></a><span id="l6.168">    */</span>
<a href="#l6.169"></a><span id="l6.169">   kSpecialString: GlodaDatastore.kSpecialString,</span>
<a href="#l6.170"></a><span id="l6.170">   /**</span>
<a href="#l6.171"></a><span id="l6.171">    * This attribute is stored as a fulltext column on the fulltext table for</span>
<a href="#l6.172"></a><span id="l6.172" class="difflineat">@@ -644,44 +662,45 @@ var Gloda = {</span>
<a href="#l6.173"></a><span id="l6.173">     // if it has a table, you can query on it.  seems straight-forward.</span>
<a href="#l6.174"></a><span id="l6.174">     if (aNounDef.tableName) {</span>
<a href="#l6.175"></a><span id="l6.175">       [aNounDef.queryClass, aNounDef.explicitQueryClass,</span>
<a href="#l6.176"></a><span id="l6.176">        aNounDef.wildcardQueryClass] =</span>
<a href="#l6.177"></a><span id="l6.177">           GlodaQueryClassFactory(aNounDef);</span>
<a href="#l6.178"></a><span id="l6.178">       aNounDef._dbMeta = {};</span>
<a href="#l6.179"></a><span id="l6.179">       aNounDef.class.prototype.NOUN_DEF = aNounDef;</span>
<a href="#l6.180"></a><span id="l6.180">       aNounDef.toJSON = this._managedToJSON;</span>
<a href="#l6.181"></a><span id="l6.181" class="difflineplus">+      </span>
<a href="#l6.182"></a><span id="l6.182" class="difflineplus">+      aNounDef.specialLoadAttribs = [];</span>
<a href="#l6.183"></a><span id="l6.183" class="difflineplus">+</span>
<a href="#l6.184"></a><span id="l6.184" class="difflineplus">+      // - define the 'id' constrainer</span>
<a href="#l6.185"></a><span id="l6.185" class="difflineplus">+      let idConstrainer = function() {</span>
<a href="#l6.186"></a><span id="l6.186" class="difflineplus">+        let constraint = [GlodaDatastore.kConstraintIdIn, null];</span>
<a href="#l6.187"></a><span id="l6.187" class="difflineplus">+        for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l6.188"></a><span id="l6.188" class="difflineplus">+          constraint.push(arguments[iArg]);</span>
<a href="#l6.189"></a><span id="l6.189" class="difflineplus">+        }</span>
<a href="#l6.190"></a><span id="l6.190" class="difflineplus">+        this._constraints.push(constraint);</span>
<a href="#l6.191"></a><span id="l6.191" class="difflineplus">+        return this;</span>
<a href="#l6.192"></a><span id="l6.192" class="difflineplus">+      };</span>
<a href="#l6.193"></a><span id="l6.193" class="difflineplus">+      aNounDef.queryClass.prototype.id = idConstrainer;</span>
<a href="#l6.194"></a><span id="l6.194">     }</span>
<a href="#l6.195"></a><span id="l6.195">     if (aNounDef.cache) {</span>
<a href="#l6.196"></a><span id="l6.196">       let cacheCost = aNounDef.cacheCost || 1024;</span>
<a href="#l6.197"></a><span id="l6.197">       let cacheBudget = aNounDef.cacheBudget || 128 * 1024;</span>
<a href="#l6.198"></a><span id="l6.198">       let cacheSize = Math.floor(cacheBudget / cacheCost);</span>
<a href="#l6.199"></a><span id="l6.199">       if (cacheSize)</span>
<a href="#l6.200"></a><span id="l6.200">         GlodaCollectionManager.defineCache(aNounDef, cacheSize);</span>
<a href="#l6.201"></a><span id="l6.201">     }</span>
<a href="#l6.202"></a><span id="l6.202" class="difflineminus">-    if (aNounDef.allowsArbitraryAttrs) {</span>
<a href="#l6.203"></a><span id="l6.203" class="difflineminus">-      aNounDef.attribsByBoundName = {};</span>
<a href="#l6.204"></a><span id="l6.204" class="difflineminus">-    }</span>
<a href="#l6.205"></a><span id="l6.205" class="difflineplus">+    aNounDef.attribsByBoundName = {};</span>
<a href="#l6.206"></a><span id="l6.206" class="difflineplus">+    </span>
<a href="#l6.207"></a><span id="l6.207">     this._nounNameToNounID[aNounDef.name] = aNounID;</span>
<a href="#l6.208"></a><span id="l6.208">     this._nounIDToDef[aNounID] = aNounDef;</span>
<a href="#l6.209"></a><span id="l6.209">     aNounDef.actions = [];</span>
<a href="#l6.210"></a><span id="l6.210">     </span>
<a href="#l6.211"></a><span id="l6.211">     this._attrProviderOrderByNoun[aNounDef.id] = [];</span>
<a href="#l6.212"></a><span id="l6.212">     this._attrProvidersByNoun[aNounDef.id] = {};</span>
<a href="#l6.213"></a><span id="l6.213" class="difflineminus">-    </span>
<a href="#l6.214"></a><span id="l6.214" class="difflineminus">-    // - define the 'id' constrainer</span>
<a href="#l6.215"></a><span id="l6.215" class="difflineminus">-    let idConstrainer = function() {</span>
<a href="#l6.216"></a><span id="l6.216" class="difflineminus">-      let constraint = [GlodaDatastore.kConstraintIdIn, null];</span>
<a href="#l6.217"></a><span id="l6.217" class="difflineminus">-      for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l6.218"></a><span id="l6.218" class="difflineminus">-        constraint.push(arguments[iArg]);</span>
<a href="#l6.219"></a><span id="l6.219" class="difflineminus">-      }</span>
<a href="#l6.220"></a><span id="l6.220" class="difflineminus">-      this._constraints.push(constraint);</span>
<a href="#l6.221"></a><span id="l6.221" class="difflineminus">-      return this;</span>
<a href="#l6.222"></a><span id="l6.222" class="difflineminus">-    };</span>
<a href="#l6.223"></a><span id="l6.223" class="difflineminus">-    subjectNounDef.queryClass.prototype.id = idConstrainer;</span>
<a href="#l6.224"></a><span id="l6.224">   },</span>
<a href="#l6.225"></a><span id="l6.225"> </span>
<a href="#l6.226"></a><span id="l6.226">   /**</span>
<a href="#l6.227"></a><span id="l6.227">    * Lookup a noun (ID) suitable for passing to defineAttribute's various</span>
<a href="#l6.228"></a><span id="l6.228">    *  noun arguments.  Throws an exception if the noun with the given name</span>
<a href="#l6.229"></a><span id="l6.229">    *  cannot be found; the assumption is that you can't live without the noun.</span>
<a href="#l6.230"></a><span id="l6.230">    */</span>
<a href="#l6.231"></a><span id="l6.231">   lookupNoun: function gloda_ns_lookupNoun(aNounName) {</span>
<a href="#l6.232"></a><span id="l6.232" class="difflineat">@@ -877,16 +896,17 @@ var Gloda = {</span>
<a href="#l6.233"></a><span id="l6.233">     this.defineNoun({</span>
<a href="#l6.234"></a><span id="l6.234">       name: &quot;contact&quot;,</span>
<a href="#l6.235"></a><span id="l6.235">       class: GlodaContact,</span>
<a href="#l6.236"></a><span id="l6.236">       allowsArbitraryAttrs: true,</span>
<a href="#l6.237"></a><span id="l6.237">       cache: true, cacheCost: 128,</span>
<a href="#l6.238"></a><span id="l6.238">       tableName: &quot;contacts&quot;,</span>
<a href="#l6.239"></a><span id="l6.239">       attrTableName: &quot;contactAttributes&quot;, attrIDColumnName: &quot;contactID&quot;,</span>
<a href="#l6.240"></a><span id="l6.240">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._contactFromRow,</span>
<a href="#l6.241"></a><span id="l6.241" class="difflineplus">+      dbAttribAdjuster: GlodaDatastore.adjustMessageAttributes,</span>
<a href="#l6.242"></a><span id="l6.242">       objInsert: GlodaDatastore.insertContact,</span>
<a href="#l6.243"></a><span id="l6.243">       objUpdate: GlodaDatastore.updateContact,</span>
<a href="#l6.244"></a><span id="l6.244">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l6.245"></a><span id="l6.245">         return GlodaDatastore.getContactByID(aID);</span>
<a href="#l6.246"></a><span id="l6.246">       },</span>
<a href="#l6.247"></a><span id="l6.247">       toParamAndValue: function(aContact) {</span>
<a href="#l6.248"></a><span id="l6.248">         if (aContact instanceof GlodaContact)</span>
<a href="#l6.249"></a><span id="l6.249">           return [null, aContact.id];</span>
<a href="#l6.250"></a><span id="l6.250" class="difflineat">@@ -942,37 +962,39 @@ var Gloda = {</span>
<a href="#l6.251"></a><span id="l6.251">         for each (let [originIdentity, targets] in Iterator(oldMap)) {</span>
<a href="#l6.252"></a><span id="l6.252">           for (let targetIdentity in targets) {</span>
<a href="#l6.253"></a><span id="l6.253">             removed.push([originIdentity, targetIdentity]);</span>
<a href="#l6.254"></a><span id="l6.254">           }</span>
<a href="#l6.255"></a><span id="l6.255">         }</span>
<a href="#l6.256"></a><span id="l6.256">         </span>
<a href="#l6.257"></a><span id="l6.257">         return [added, removed];</span>
<a href="#l6.258"></a><span id="l6.258">       },</span>
<a href="#l6.259"></a><span id="l6.259" class="difflineminus">-      contributeObjDependencies: function(aJsonValues, aReferencesByNounDef) {</span>
<a href="#l6.260"></a><span id="l6.260" class="difflineplus">+      contributeObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l6.261"></a><span id="l6.261" class="difflineplus">+          aInverseReferencesByNounID) {</span>
<a href="#l6.262"></a><span id="l6.262">         // nothing to do with a zero-length list</span>
<a href="#l6.263"></a><span id="l6.263">         if (aJsonValues.length == 0)</span>
<a href="#l6.264"></a><span id="l6.264">           return false;</span>
<a href="#l6.265"></a><span id="l6.265">       </span>
<a href="#l6.266"></a><span id="l6.266">         let nounIdentityDef = Gloda._nounIDToDef[this.NOUN_IDENTITY]</span>
<a href="#l6.267"></a><span id="l6.267" class="difflineminus">-        let references = aReferencesByNounDef[nounIdentityDef];</span>
<a href="#l6.268"></a><span id="l6.268" class="difflineplus">+        let references = aReferencesByNounID[nounIdentityDef.id];</span>
<a href="#l6.269"></a><span id="l6.269">         if (references === undefined)</span>
<a href="#l6.270"></a><span id="l6.270" class="difflineminus">-          references = aReferencesByNounDef[nounIdentityDef] = {};</span>
<a href="#l6.271"></a><span id="l6.271" class="difflineplus">+          references = aReferencesByNounID[nounIdentityDef.id] = {};</span>
<a href="#l6.272"></a><span id="l6.272">         </span>
<a href="#l6.273"></a><span id="l6.273">         for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l6.274"></a><span id="l6.274">           let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l6.275"></a><span id="l6.275">           references[originIdentityID] = null;</span>
<a href="#l6.276"></a><span id="l6.276">           references[targetIdentityID] = null;</span>
<a href="#l6.277"></a><span id="l6.277">         }</span>
<a href="#l6.278"></a><span id="l6.278">         </span>
<a href="#l6.279"></a><span id="l6.279">         return true;</span>
<a href="#l6.280"></a><span id="l6.280">       },</span>
<a href="#l6.281"></a><span id="l6.281" class="difflineminus">-      resolveObjDependencies: function(aJsonValues, aReferencesByNounDef) {</span>
<a href="#l6.282"></a><span id="l6.282" class="difflineplus">+      resolveObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l6.283"></a><span id="l6.283" class="difflineplus">+          aInverseReferencesByNounID) {</span>
<a href="#l6.284"></a><span id="l6.284">         let references =</span>
<a href="#l6.285"></a><span id="l6.285" class="difflineminus">-          aReferencesByNounDef[Gloda._nounIDToDef[this.NOUN_IDENTITY]];</span>
<a href="#l6.286"></a><span id="l6.286" class="difflineplus">+          aReferencesByNounID[this.NOUN_IDENTITY];</span>
<a href="#l6.287"></a><span id="l6.287">         </span>
<a href="#l6.288"></a><span id="l6.288">         let results = [];</span>
<a href="#l6.289"></a><span id="l6.289">         for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l6.290"></a><span id="l6.290">           let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l6.291"></a><span id="l6.291">           results.push([references[originIdentityID],</span>
<a href="#l6.292"></a><span id="l6.292">                         references[targetIdentityID]]);</span>
<a href="#l6.293"></a><span id="l6.293">         }</span>
<a href="#l6.294"></a><span id="l6.294">         </span>
<a href="#l6.295"></a><span id="l6.295" class="difflineat">@@ -994,76 +1016,80 @@ var Gloda = {</span>
<a href="#l6.296"></a><span id="l6.296">    *  attribute storage, as well as creating the appropriate query object</span>
<a href="#l6.297"></a><span id="l6.297">    *  constraint helper functions.  This name is somewhat of a misnomer because</span>
<a href="#l6.298"></a><span id="l6.298">    *  special attributes are not 'bound' (because specific/non-generic per-class</span>
<a href="#l6.299"></a><span id="l6.299">    *  code provides the properties) but still depend on this method to</span>
<a href="#l6.300"></a><span id="l6.300">    *  establish their constraint helper methods.</span>
<a href="#l6.301"></a><span id="l6.301">    *</span>
<a href="#l6.302"></a><span id="l6.302">    * @XXX potentially rename to not suggest binding is required.</span>
<a href="#l6.303"></a><span id="l6.303">    */</span>
<a href="#l6.304"></a><span id="l6.304" class="difflineminus">-  _bindAttribute: function gloda_ns_bindAttr(aAttrDef, aSubjectType) {</span>
<a href="#l6.305"></a><span id="l6.305" class="difflineminus">-    if (!(aSubjectType in this._nounIDToDef))</span>
<a href="#l6.306"></a><span id="l6.306" class="difflineminus">-      throw Error(&quot;Invalid subject type: &quot; + aSubjectType);</span>
<a href="#l6.307"></a><span id="l6.307" class="difflineminus">-</span>
<a href="#l6.308"></a><span id="l6.308" class="difflineminus">-    let objNounDef = this._nounIDToDef[aAttrDef.objectNoun];</span>
<a href="#l6.309"></a><span id="l6.309" class="difflineminus">-    let subjectNounDef = this._nounIDToDef[aSubjectType];</span>
<a href="#l6.310"></a><span id="l6.310" class="difflineminus">-</span>
<a href="#l6.311"></a><span id="l6.311" class="difflineminus">-    // -- the on-object bindings</span>
<a href="#l6.312"></a><span id="l6.312" class="difflineminus">-    if (aDoBind) {</span>
<a href="#l6.313"></a><span id="l6.313" class="difflineminus">-      aAttr.boundName = aBindName;</span>
<a href="#l6.314"></a><span id="l6.314" class="difflineminus">-    }</span>
<a href="#l6.315"></a><span id="l6.315" class="difflineplus">+  _bindAttribute: function gloda_ns_bindAttr(aAttrDef, aSubjectNounDef) {</span>
<a href="#l6.316"></a><span id="l6.316" class="difflineplus">+    let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l6.317"></a><span id="l6.317"> </span>
<a href="#l6.318"></a><span id="l6.318">     // -- the query constraint helpers</span>
<a href="#l6.319"></a><span id="l6.319" class="difflineminus">-    if (subjectNounDef.queryClass !== undefined) {</span>
<a href="#l6.320"></a><span id="l6.320" class="difflineminus">-      let constrainer = function() {</span>
<a href="#l6.321"></a><span id="l6.321" class="difflineminus">-        let constraint = [GlodaDatastore.kConstraintIn, aAttrDef];</span>
<a href="#l6.322"></a><span id="l6.322" class="difflineminus">-        for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l6.323"></a><span id="l6.323" class="difflineminus">-          constraint.push(arguments[iArg]);</span>
<a href="#l6.324"></a><span id="l6.324" class="difflineminus">-        }</span>
<a href="#l6.325"></a><span id="l6.325" class="difflineminus">-        this._constraints.push(constraint);</span>
<a href="#l6.326"></a><span id="l6.326" class="difflineminus">-        return this;</span>
<a href="#l6.327"></a><span id="l6.327" class="difflineminus">-      };</span>
<a href="#l6.328"></a><span id="l6.328" class="difflineplus">+    if (aSubjectNounDef.queryClass !== undefined) {</span>
<a href="#l6.329"></a><span id="l6.329" class="difflineplus">+      let constrainer;</span>
<a href="#l6.330"></a><span id="l6.330" class="difflineplus">+      // non-strings can use IN</span>
<a href="#l6.331"></a><span id="l6.331" class="difflineplus">+      if (aAttrDef.special != this.kSpecialString) {</span>
<a href="#l6.332"></a><span id="l6.332" class="difflineplus">+        constrainer = function() {</span>
<a href="#l6.333"></a><span id="l6.333" class="difflineplus">+          let constraint = [GlodaDatastore.kConstraintIn, aAttrDef];</span>
<a href="#l6.334"></a><span id="l6.334" class="difflineplus">+          for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l6.335"></a><span id="l6.335" class="difflineplus">+            constraint.push(arguments[iArg]);</span>
<a href="#l6.336"></a><span id="l6.336" class="difflineplus">+          }</span>
<a href="#l6.337"></a><span id="l6.337" class="difflineplus">+          this._constraints.push(constraint);</span>
<a href="#l6.338"></a><span id="l6.338" class="difflineplus">+          return this;</span>
<a href="#l6.339"></a><span id="l6.339" class="difflineplus">+        };</span>
<a href="#l6.340"></a><span id="l6.340" class="difflineplus">+      }</span>
<a href="#l6.341"></a><span id="l6.341" class="difflineplus">+      else { // strings need to use equals for escaping reasons</span>
<a href="#l6.342"></a><span id="l6.342" class="difflineplus">+        // (we could introduce an 'escaped' in that we manually escape though)</span>
<a href="#l6.343"></a><span id="l6.343" class="difflineplus">+        constrainer = function() {</span>
<a href="#l6.344"></a><span id="l6.344" class="difflineplus">+          let constraint = [GlodaDatastore.kConstraintEquals, aAttrDef];</span>
<a href="#l6.345"></a><span id="l6.345" class="difflineplus">+          for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l6.346"></a><span id="l6.346" class="difflineplus">+            constraint.push(arguments[iArg]);</span>
<a href="#l6.347"></a><span id="l6.347" class="difflineplus">+          }</span>
<a href="#l6.348"></a><span id="l6.348" class="difflineplus">+          this._constraints.push(constraint);</span>
<a href="#l6.349"></a><span id="l6.349" class="difflineplus">+          return this;</span>
<a href="#l6.350"></a><span id="l6.350" class="difflineplus">+        };</span>
<a href="#l6.351"></a><span id="l6.351" class="difflineplus">+      }</span>
<a href="#l6.352"></a><span id="l6.352"> </span>
<a href="#l6.353"></a><span id="l6.353" class="difflineminus">-      subjectNounDef.queryClass.prototype[aBindName] = constrainer;</span>
<a href="#l6.354"></a><span id="l6.354" class="difflineplus">+      aSubjectNounDef.queryClass.prototype[aAttrDef.boundName] = constrainer;</span>
<a href="#l6.355"></a><span id="l6.355"> </span>
<a href="#l6.356"></a><span id="l6.356">       // - ranged value helper: fooRange</span>
<a href="#l6.357"></a><span id="l6.357" class="difflineminus">-      if (objNounDef.continuous) {</span>
<a href="#l6.358"></a><span id="l6.358" class="difflineplus">+      if (objectNounDef.continuous) {</span>
<a href="#l6.359"></a><span id="l6.359">         // takes one or more tuples of [lower bound, upper bound]</span>
<a href="#l6.360"></a><span id="l6.360">         let rangedConstrainer = function() {</span>
<a href="#l6.361"></a><span id="l6.361">           let constraint = [GlodaDatastore.kConstraintRanges, aAttrDef];</span>
<a href="#l6.362"></a><span id="l6.362">           for (let iArg = 0; iArg &lt; arguments.length; iArg++ ) {</span>
<a href="#l6.363"></a><span id="l6.363">             constraint.push(arguments[iArg]);</span>
<a href="#l6.364"></a><span id="l6.364">           }</span>
<a href="#l6.365"></a><span id="l6.365">           this._constraints.push(constraints);</span>
<a href="#l6.366"></a><span id="l6.366">           return this;</span>
<a href="#l6.367"></a><span id="l6.367">         }</span>
<a href="#l6.368"></a><span id="l6.368"> </span>
<a href="#l6.369"></a><span id="l6.369" class="difflineminus">-        subjectNounDef.queryClass.prototype[aBindName + &quot;Range&quot;] =</span>
<a href="#l6.370"></a><span id="l6.370" class="difflineplus">+        aSubjectNounDef.queryClass.prototype[aAttrDef.boundName + &quot;Range&quot;] =</span>
<a href="#l6.371"></a><span id="l6.371">           rangedConstrainer;</span>
<a href="#l6.372"></a><span id="l6.372">       }</span>
<a href="#l6.373"></a><span id="l6.373"> </span>
<a href="#l6.374"></a><span id="l6.374">       // - string LIKE helper for special on-row attributes: fooLike</span>
<a href="#l6.375"></a><span id="l6.375">       // (it is impossible to store a string as an indexed attribute, which is</span>
<a href="#l6.376"></a><span id="l6.376">       //  why we do this for on-row only.)</span>
<a href="#l6.377"></a><span id="l6.377" class="difflineminus">-      if (aAttr.special == this.kSpecialString) {</span>
<a href="#l6.378"></a><span id="l6.378" class="difflineplus">+      if (aAttrDef.special == this.kSpecialString) {</span>
<a href="#l6.379"></a><span id="l6.379">         let likeConstrainer = function() {</span>
<a href="#l6.380"></a><span id="l6.380">           let constraint = [GlodaDatastore.kConstraintStringLike, aAttrDef];</span>
<a href="#l6.381"></a><span id="l6.381">           for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l6.382"></a><span id="l6.382">             constraint.push(arguments[iArg]);</span>
<a href="#l6.383"></a><span id="l6.383">           }</span>
<a href="#l6.384"></a><span id="l6.384">           this._constraints.push(constraints);</span>
<a href="#l6.385"></a><span id="l6.385">           return this;</span>
<a href="#l6.386"></a><span id="l6.386">         }</span>
<a href="#l6.387"></a><span id="l6.387"> </span>
<a href="#l6.388"></a><span id="l6.388" class="difflineminus">-        subjectNounDef.queryClass.prototype[aBindName + &quot;Like&quot;] =</span>
<a href="#l6.389"></a><span id="l6.389" class="difflineplus">+        aSubjectNounDef.queryClass.prototype[aAttrDef.boundName + &quot;Like&quot;] =</span>
<a href="#l6.390"></a><span id="l6.390">           likeConstrainer;</span>
<a href="#l6.391"></a><span id="l6.391">       }</span>
<a href="#l6.392"></a><span id="l6.392">     }</span>
<a href="#l6.393"></a><span id="l6.393" class="difflineminus">-</span>
<a href="#l6.394"></a><span id="l6.394" class="difflineminus">-    aAttr._singular = aSingular;</span>
<a href="#l6.395"></a><span id="l6.395">   },</span>
<a href="#l6.396"></a><span id="l6.396"> </span>
<a href="#l6.397"></a><span id="l6.397">   /**</span>
<a href="#l6.398"></a><span id="l6.398">    * Define an attribute and all its meta-data.  Takes a single dictionary as</span>
<a href="#l6.399"></a><span id="l6.399">    *  its argument, with the following required properties:</span>
<a href="#l6.400"></a><span id="l6.400">    *</span>
<a href="#l6.401"></a><span id="l6.401">    * @param provider The object instance providing a 'process' method.</span>
<a href="#l6.402"></a><span id="l6.402">    * @param extensionName The name of the extension providing these attributes.</span>
<a href="#l6.403"></a><span id="l6.403" class="difflineat">@@ -1101,17 +1127,16 @@ var Gloda = {</span>
<a href="#l6.404"></a><span id="l6.404">    *     'object' whose type you are defining right here.</span>
<a href="#l6.405"></a><span id="l6.405">    */</span>
<a href="#l6.406"></a><span id="l6.406">   defineAttribute: function gloda_ns_defineAttribute(aAttrDef) {</span>
<a href="#l6.407"></a><span id="l6.407">     // ensure required properties exist on aAttrDef</span>
<a href="#l6.408"></a><span id="l6.408">     if (!(&quot;provider&quot; in aAttrDef) ||</span>
<a href="#l6.409"></a><span id="l6.409">         !(&quot;extensionName&quot; in aAttrDef) ||</span>
<a href="#l6.410"></a><span id="l6.410">         !(&quot;attributeType&quot; in aAttrDef) ||</span>
<a href="#l6.411"></a><span id="l6.411">         !(&quot;attributeName&quot; in aAttrDef) ||</span>
<a href="#l6.412"></a><span id="l6.412" class="difflineminus">-        !(&quot;bind&quot; in aAttrDef) ||</span>
<a href="#l6.413"></a><span id="l6.413">         !(&quot;singular&quot; in aAttrDef) ||</span>
<a href="#l6.414"></a><span id="l6.414">         !(&quot;subjectNouns&quot; in aAttrDef) ||</span>
<a href="#l6.415"></a><span id="l6.415">         !(&quot;objectNoun&quot; in aAttrDef))</span>
<a href="#l6.416"></a><span id="l6.416">       // perhaps we should have a list of required attributes, perchance with</span>
<a href="#l6.417"></a><span id="l6.417">       //  and explanation of what it holds, and use that to be friendlier?</span>
<a href="#l6.418"></a><span id="l6.418">       throw Error(&quot;You omitted a required attribute defining property, please&quot; +</span>
<a href="#l6.419"></a><span id="l6.419">                   &quot; consult the documentation as penance.&quot;)</span>
<a href="#l6.420"></a><span id="l6.420"> </span>
<a href="#l6.421"></a><span id="l6.421" class="difflineat">@@ -1123,17 +1148,17 @@ var Gloda = {</span>
<a href="#l6.422"></a><span id="l6.422">     // provider tracking</span>
<a href="#l6.423"></a><span id="l6.423">     if (!(aAttrDef.provider.providerName in this._attrProviders)) {</span>
<a href="#l6.424"></a><span id="l6.424">       this._attrProviders[aAttrDef.provider.providerName] = [];</span>
<a href="#l6.425"></a><span id="l6.425">     }</span>
<a href="#l6.426"></a><span id="l6.426"> </span>
<a href="#l6.427"></a><span id="l6.427">     let compoundName = aAttrDef.extensionName + &quot;:&quot; + aAttrDef.attributeName;</span>
<a href="#l6.428"></a><span id="l6.428">     let attrDBDef;</span>
<a href="#l6.429"></a><span id="l6.429">     if (compoundName in GlodaDatastore._attributeDBDefs) {</span>
<a href="#l6.430"></a><span id="l6.430" class="difflineminus">-      // the existence of the GlodaAttributeDef means that either it has</span>
<a href="#l6.431"></a><span id="l6.431" class="difflineplus">+      // the existence of the GlodaAttributeDBDef means that either it has</span>
<a href="#l6.432"></a><span id="l6.432">       //  already been fully defined, or has been loaded from the database but</span>
<a href="#l6.433"></a><span id="l6.433">       //  not yet 'bound' to a provider (and had important meta-info that</span>
<a href="#l6.434"></a><span id="l6.434">       //  doesn't go in the db copied over)</span>
<a href="#l6.435"></a><span id="l6.435">       attrDBDef = GlodaDatastore._attributeDBDefs[compoundName];</span>
<a href="#l6.436"></a><span id="l6.436">     }</span>
<a href="#l6.437"></a><span id="l6.437">     // we need to create the attribute definition in the database</span>
<a href="#l6.438"></a><span id="l6.438">     else {</span>
<a href="#l6.439"></a><span id="l6.439">       let attrID = null;</span>
<a href="#l6.440"></a><span id="l6.440" class="difflineat">@@ -1145,53 +1170,60 @@ var Gloda = {</span>
<a href="#l6.441"></a><span id="l6.441">       attrDBDef = new GlodaAttributeDBDef(GlodaDatastore, attrID, compoundName,</span>
<a href="#l6.442"></a><span id="l6.442">         aAttrDef.attributeType, aAttrDef.extensionName, aAttrDef.attributeName);</span>
<a href="#l6.443"></a><span id="l6.443">       GlodaDatastore._attributeDBDefs[compoundName] = attrDBDef;</span>
<a href="#l6.444"></a><span id="l6.444">       GlodaDatastore._attributeIDToDBDefAndParam[attrID] = [attrDBDef, null];</span>
<a href="#l6.445"></a><span id="l6.445">     }</span>
<a href="#l6.446"></a><span id="l6.446">     </span>
<a href="#l6.447"></a><span id="l6.447">     aAttrDef.dbDef = attrDBDef;</span>
<a href="#l6.448"></a><span id="l6.448">     attrDBDef.attrDef = aAttrDef;</span>
<a href="#l6.449"></a><span id="l6.449" class="difflineplus">+    </span>
<a href="#l6.450"></a><span id="l6.450" class="difflineplus">+    aAttrDef.id = aAttrDef.dbDef.id;</span>
<a href="#l6.451"></a><span id="l6.451"> </span>
<a href="#l6.452"></a><span id="l6.452" class="difflineminus">-    let bindName;</span>
<a href="#l6.453"></a><span id="l6.453">     if (&quot;bindName&quot; in aAttrDef)</span>
<a href="#l6.454"></a><span id="l6.454" class="difflineminus">-      bindName = aAttrDef.bindName;</span>
<a href="#l6.455"></a><span id="l6.455" class="difflineplus">+      aAttrDef.boundName = aAttrDef.bindName;</span>
<a href="#l6.456"></a><span id="l6.456">     else</span>
<a href="#l6.457"></a><span id="l6.457" class="difflineminus">-      bindName = aAttrDef.attributeName;</span>
<a href="#l6.458"></a><span id="l6.458" class="difflineminus">-    aAttrDef.boundName = bindName;</span>
<a href="#l6.459"></a><span id="l6.459" class="difflineplus">+      aAttrDef.boundName = aAttrDef.attributeName;</span>
<a href="#l6.460"></a><span id="l6.460" class="difflineplus">+    </span>
<a href="#l6.461"></a><span id="l6.461" class="difflineplus">+    aAttrDef.objectNounDef = this._nounIDToDef[aAttrDef.objectNoun];</span>
<a href="#l6.462"></a><span id="l6.462"> </span>
<a href="#l6.463"></a><span id="l6.463">     for (let iSubject = 0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l6.464"></a><span id="l6.464">            iSubject++) {</span>
<a href="#l6.465"></a><span id="l6.465">       let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l6.466"></a><span id="l6.466" class="difflineminus">-      this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l6.467"></a><span id="l6.467" class="difflineminus">-                          aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l6.468"></a><span id="l6.468" class="difflineplus">+      let subjectNounDef = this._nounIDToDef[subjectType];</span>
<a href="#l6.469"></a><span id="l6.469" class="difflineplus">+      this._bindAttribute(aAttrDef, subjectNounDef);</span>
<a href="#l6.470"></a><span id="l6.470"> </span>
<a href="#l6.471"></a><span id="l6.471">       // update the provider maps...</span>
<a href="#l6.472"></a><span id="l6.472">       if (this._attrProviderOrderByNoun[subjectType]</span>
<a href="#l6.473"></a><span id="l6.473">               .indexOf(aAttrDef.provider) == -1) {</span>
<a href="#l6.474"></a><span id="l6.474">         this._attrProviderOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l6.475"></a><span id="l6.475">         this._attrProvidersByNoun[subjectType][aAttrDef.provider] = [];</span>
<a href="#l6.476"></a><span id="l6.476">       }</span>
<a href="#l6.477"></a><span id="l6.477">       this._attrProvidersByNoun[subjectType][aAttrDef.provider].push(aAttrDef);</span>
<a href="#l6.478"></a><span id="l6.478">       </span>
<a href="#l6.479"></a><span id="l6.479" class="difflineminus">-      let subjectNounDef = this._nounIDToDef[subjectType];</span>
<a href="#l6.480"></a><span id="l6.480" class="difflineminus">-      subjectNounDef.attribsByBoundName[bindName] = attr;</span>
<a href="#l6.481"></a><span id="l6.481" class="difflineplus">+      subjectNounDef.attribsByBoundName[aAttrDef.boundName] = aAttrDef;</span>
<a href="#l6.482"></a><span id="l6.482" class="difflineplus">+      </span>
<a href="#l6.483"></a><span id="l6.483" class="difflineplus">+      if (aAttrDef.special &amp; this.kSpecialColumn)</span>
<a href="#l6.484"></a><span id="l6.484" class="difflineplus">+        subjectNounDef.specialLoadAttribs.push(aAttrDef);</span>
<a href="#l6.485"></a><span id="l6.485">       </span>
<a href="#l6.486"></a><span id="l6.486" class="difflineplus">+      // if this is a parent column attribute, make note of it so that if we</span>
<a href="#l6.487"></a><span id="l6.487" class="difflineplus">+      //  need to do an inverse references lookup, we know what column we are</span>
<a href="#l6.488"></a><span id="l6.488" class="difflineplus">+      //  issuing against.</span>
<a href="#l6.489"></a><span id="l6.489" class="difflineplus">+      if (aAttrDef.special === this.kSpecialColumnParent) {</span>
<a href="#l6.490"></a><span id="l6.490" class="difflineplus">+        subjectNounDef.parentColumnAttr = aAttrDef;</span>
<a href="#l6.491"></a><span id="l6.491" class="difflineplus">+      }</span>
<a href="#l6.492"></a><span id="l6.492">       </span>
<a href="#l6.493"></a><span id="l6.493" class="difflineminus">-      if (objectNounDef.tableName ||</span>
<a href="#l6.494"></a><span id="l6.494" class="difflineminus">-          objectNounDef.contributeObjDependencies) {</span>
<a href="#l6.495"></a><span id="l6.495" class="difflineplus">+      if (aAttrDef.objectNounDef.tableName ||</span>
<a href="#l6.496"></a><span id="l6.496" class="difflineplus">+          aAttrDef.objectNounDef.contributeObjDependencies) {</span>
<a href="#l6.497"></a><span id="l6.497">         subjectNounDef.hasObjDependencies = true;</span>
<a href="#l6.498"></a><span id="l6.498">       }</span>
<a href="#l6.499"></a><span id="l6.499" class="difflineminus">-      </span>
<a href="#l6.500"></a><span id="l6.500" class="difflineminus">-      this._attrProviders[aAttrDef.provider.providerName].push(attr);</span>
<a href="#l6.501"></a><span id="l6.501" class="difflineminus">-      return attr;</span>
<a href="#l6.502"></a><span id="l6.502">     }</span>
<a href="#l6.503"></a><span id="l6.503">     </span>
<a href="#l6.504"></a><span id="l6.504" class="difflineminus">-    this._attrProviders[aAttrDef.provider.providerName].push(attr);</span>
<a href="#l6.505"></a><span id="l6.505" class="difflineminus">-    return attr;</span>
<a href="#l6.506"></a><span id="l6.506" class="difflineplus">+    this._attrProviders[aAttrDef.provider.providerName].push(aAttrDef);</span>
<a href="#l6.507"></a><span id="l6.507" class="difflineplus">+    return aAttrDef;</span>
<a href="#l6.508"></a><span id="l6.508">   },</span>
<a href="#l6.509"></a><span id="l6.509"> </span>
<a href="#l6.510"></a><span id="l6.510">   /**</span>
<a href="#l6.511"></a><span id="l6.511">    * Retrieve the attribute provided by the given extension with the given</span>
<a href="#l6.512"></a><span id="l6.512">    *  attribute name.  The original idea was that plugins would effectively</span>
<a href="#l6.513"></a><span id="l6.513">    *  name-space attributes, helping avoid collisions.  Since we are leaning</span>
<a href="#l6.514"></a><span id="l6.514">    *  towards using binding heavily, this doesn't really help, as the collisions</span>
<a href="#l6.515"></a><span id="l6.515">    *  will just occur on the attribute name instead.  Also, this can turn</span>
<a href="#l6.516"></a><span id="l6.516" class="difflineat">@@ -1289,158 +1321,93 @@ var Gloda = {</span>
<a href="#l6.517"></a><span id="l6.517">    *  as new.  The result is that it allows you to be notified as new items</span>
<a href="#l6.518"></a><span id="l6.518">    *  as they are indexed, existing items as they are loaded from the database,</span>
<a href="#l6.519"></a><span id="l6.519">    *  etc.</span>
<a href="#l6.520"></a><span id="l6.520">    * Because the items are added to the collection without limit, this will</span>
<a href="#l6.521"></a><span id="l6.521">    *  result in a leak if you don't do something to clean up after the</span>
<a href="#l6.522"></a><span id="l6.522">    *  collection.  (Forgetting about the collection will suffice, as it is still</span>
<a href="#l6.523"></a><span id="l6.523">    *  weakly held.)</span>
<a href="#l6.524"></a><span id="l6.524">    */</span>
<a href="#l6.525"></a><span id="l6.525" class="difflineminus">-  _wildcardCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l6.526"></a><span id="l6.526" class="difflineplus">+  _wildcardCollection: function gloda_ns_wildcardCollection(aNounID, aItems) {</span>
<a href="#l6.527"></a><span id="l6.527">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l6.528"></a><span id="l6.528">     let collection = new GlodaCollection(nounDef, aItems, null, null)</span>
<a href="#l6.529"></a><span id="l6.529">     let query = new nounDef.wildcardQueryClass(collection);</span>
<a href="#l6.530"></a><span id="l6.530">     collection.query = query;</span>
<a href="#l6.531"></a><span id="l6.531">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l6.532"></a><span id="l6.532">     return collection;</span>
<a href="#l6.533"></a><span id="l6.533">   },</span>
<a href="#l6.534"></a><span id="l6.534"> </span>
<a href="#l6.535"></a><span id="l6.535">   /**</span>
<a href="#l6.536"></a><span id="l6.536" class="difflineminus">-   * Process the given GlodaMessage, determining all the attributes it should</span>
<a href="#l6.537"></a><span id="l6.537" class="difflineminus">-   *  possess.  This should not be publicly exposed here for multiple reasons.</span>
<a href="#l6.538"></a><span id="l6.538" class="difflineminus">-   * What we eventually want is the ability for pluggable (non-message specific)</span>
<a href="#l6.539"></a><span id="l6.539" class="difflineminus">-   *  indexers to be added to the system, and for them to register via this</span>
<a href="#l6.540"></a><span id="l6.540" class="difflineminus">-   *  Gloda interface.  However, we don't want that mechanism directly exposed</span>
<a href="#l6.541"></a><span id="l6.541" class="difflineminus">-   *  to user/extension code, at least in the sense that it seems like we are</span>
<a href="#l6.542"></a><span id="l6.542" class="difflineminus">-   *  suggesting they should use it.</span>
<a href="#l6.543"></a><span id="l6.543" class="difflineminus">-   * This method should probably end up generalized, and implicitly integrated</span>
<a href="#l6.544"></a><span id="l6.544" class="difflineminus">-   *  into things as a result of registering an indexing mechanism for a given</span>
<a href="#l6.545"></a><span id="l6.545" class="difflineminus">-   *  noun type.</span>
<a href="#l6.546"></a><span id="l6.546" class="difflineminus">-   */</span>
<a href="#l6.547"></a><span id="l6.547" class="difflineminus">-  processMessage: function gloda_ns_processMessage(aMessage, aMsgHdr,</span>
<a href="#l6.548"></a><span id="l6.548" class="difflineminus">-                                                   aMimeMsg, aIsNew) {</span>
<a href="#l6.549"></a><span id="l6.549" class="difflineminus">-    // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l6.550"></a><span id="l6.550" class="difflineminus">-    //  before applying the new attributes.</span>
<a href="#l6.551"></a><span id="l6.551" class="difflineminus">-    aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l6.552"></a><span id="l6.552" class="difflineminus">-</span>
<a href="#l6.553"></a><span id="l6.553" class="difflineminus">-    let allAttribs = [];</span>
<a href="#l6.554"></a><span id="l6.554" class="difflineminus">-</span>
<a href="#l6.555"></a><span id="l6.555" class="difflineminus">-    let attrProviders = this._attrProviderOrderByNoun[aMessage.NOUN_ID];</span>
<a href="#l6.556"></a><span id="l6.556" class="difflineminus">-    for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l6.557"></a><span id="l6.557" class="difflineminus">-      let attribs = attrProviders[iProvider].process(aMessage, aMsgHdr,</span>
<a href="#l6.558"></a><span id="l6.558" class="difflineminus">-                                                     aMimeMsg, aIsNew);</span>
<a href="#l6.559"></a><span id="l6.559" class="difflineminus">-      allAttribs = allAttribs.concat(attribs);</span>
<a href="#l6.560"></a><span id="l6.560" class="difflineminus">-    }</span>
<a href="#l6.561"></a><span id="l6.561" class="difflineminus">-</span>
<a href="#l6.562"></a><span id="l6.562" class="difflineminus">-    // [attribute id, value] for for the database</span>
<a href="#l6.563"></a><span id="l6.563" class="difflineminus">-    let outAttribs = [];</span>
<a href="#l6.564"></a><span id="l6.564" class="difflineminus">-    // [attribute def, parameter, value] for memory usage</span>
<a href="#l6.565"></a><span id="l6.565" class="difflineminus">-    let memAttribs = [];</span>
<a href="#l6.566"></a><span id="l6.566" class="difflineminus">-</span>
<a href="#l6.567"></a><span id="l6.567" class="difflineminus">-    for (let iAttrib = 0; iAttrib &lt; allAttribs.length; iAttrib++) {</span>
<a href="#l6.568"></a><span id="l6.568" class="difflineminus">-      let attribDesc = allAttribs[iAttrib];</span>
<a href="#l6.569"></a><span id="l6.569" class="difflineminus">-</span>
<a href="#l6.570"></a><span id="l6.570" class="difflineminus">-      // is it an (attributedef / attribute def id, value) tuple?</span>
<a href="#l6.571"></a><span id="l6.571" class="difflineminus">-      if (attribDesc.length == 2) {</span>
<a href="#l6.572"></a><span id="l6.572" class="difflineminus">-        // if it's already an attrib id, we can use the tuple outright</span>
<a href="#l6.573"></a><span id="l6.573" class="difflineminus">-        if (typeof attribDesc[0] == &quot;number&quot;) {</span>
<a href="#l6.574"></a><span id="l6.574" class="difflineminus">-          outAttribs.push(attribDesc);</span>
<a href="#l6.575"></a><span id="l6.575" class="difflineminus">-          let [attribDef, attribParam] =</span>
<a href="#l6.576"></a><span id="l6.576" class="difflineminus">-            GlodaDatastore._attributeIDToDBDefAndParam[attribDesc[0]];</span>
<a href="#l6.577"></a><span id="l6.577" class="difflineminus">-          memAttribs.push([attribDef, attribParam, attribDesc[1]]);</span>
<a href="#l6.578"></a><span id="l6.578" class="difflineminus">-        }</span>
<a href="#l6.579"></a><span id="l6.579" class="difflineminus">-        else {</span>
<a href="#l6.580"></a><span id="l6.580" class="difflineminus">-          outAttribs.push([attribDesc[0].id, attribDesc[1]]);</span>
<a href="#l6.581"></a><span id="l6.581" class="difflineminus">-          // the parameter is null if they just pass an attribute def</span>
<a href="#l6.582"></a><span id="l6.582" class="difflineminus">-          memAttribs.push([attribDesc[0], null, attribDesc[1]]);</span>
<a href="#l6.583"></a><span id="l6.583" class="difflineminus">-        }</span>
<a href="#l6.584"></a><span id="l6.584" class="difflineminus">-      }</span>
<a href="#l6.585"></a><span id="l6.585" class="difflineminus">-      // it must be an (attrib, parameter value, attrib value) tuple</span>
<a href="#l6.586"></a><span id="l6.586" class="difflineminus">-      else {</span>
<a href="#l6.587"></a><span id="l6.587" class="difflineminus">-        // just store it verbatim for memory purposes</span>
<a href="#l6.588"></a><span id="l6.588" class="difflineminus">-        memAttribs.push(attribDesc);</span>
<a href="#l6.589"></a><span id="l6.589" class="difflineminus">-</span>
<a href="#l6.590"></a><span id="l6.590" class="difflineminus">-        let attrib = attribDesc[0];</span>
<a href="#l6.591"></a><span id="l6.591" class="difflineminus">-        let parameterValue = attribDesc[1];</span>
<a href="#l6.592"></a><span id="l6.592" class="difflineminus">-        let attribID;</span>
<a href="#l6.593"></a><span id="l6.593" class="difflineminus">-        if (parameterValue != null)</span>
<a href="#l6.594"></a><span id="l6.594" class="difflineminus">-          attribID = attrib.bindParameter(parameterValue);</span>
<a href="#l6.595"></a><span id="l6.595" class="difflineminus">-        else</span>
<a href="#l6.596"></a><span id="l6.596" class="difflineminus">-          attribID = attrib.id;</span>
<a href="#l6.597"></a><span id="l6.597" class="difflineminus">-        outAttribs.push([attribID, attribDesc[2]]);</span>
<a href="#l6.598"></a><span id="l6.598" class="difflineminus">-      }</span>
<a href="#l6.599"></a><span id="l6.599" class="difflineminus">-    }</span>
<a href="#l6.600"></a><span id="l6.600" class="difflineminus">-</span>
<a href="#l6.601"></a><span id="l6.601" class="difflineminus">-    GlodaDatastore.insertMessageAttributes(aMessage, outAttribs);</span>
<a href="#l6.602"></a><span id="l6.602" class="difflineminus">-    aMessage._replaceAttributes(memAttribs);</span>
<a href="#l6.603"></a><span id="l6.603" class="difflineminus">-</span>
<a href="#l6.604"></a><span id="l6.604" class="difflineminus">-    if (aIsNew)</span>
<a href="#l6.605"></a><span id="l6.605" class="difflineminus">-      GlodaCollectionManager.itemsAdded(aMessage.NOUN_ID, [aMessage]);</span>
<a href="#l6.606"></a><span id="l6.606" class="difflineminus">-    else</span>
<a href="#l6.607"></a><span id="l6.607" class="difflineminus">-      GlodaCollectionManager.itemsModified(aMessage.NOUN_ID, [aMessage]);</span>
<a href="#l6.608"></a><span id="l6.608" class="difflineminus">-  },</span>
<a href="#l6.609"></a><span id="l6.609" class="difflineminus">-  </span>
<a href="#l6.610"></a><span id="l6.610" class="difflineminus">-  /**</span>
<a href="#l6.611"></a><span id="l6.611">    * Populate a gloda representation of an item given the thus-far built</span>
<a href="#l6.612"></a><span id="l6.612">    *  representation, the previous representation, and one or more raw</span>
<a href="#l6.613"></a><span id="l6.613">    *  representations.</span>
<a href="#l6.614"></a><span id="l6.614">    *</span>
<a href="#l6.615"></a><span id="l6.615">    * The result of the processing ends up with attributes in 3 different forms:</span>
<a href="#l6.616"></a><span id="l6.616">    * - Database attribute rows (to be added and removed).</span>
<a href="#l6.617"></a><span id="l6.617">    * - In-memory representation.</span>
<a href="#l6.618"></a><span id="l6.618">    * - JSON-able representation.</span>
<a href="#l6.619"></a><span id="l6.619">    */</span>
<a href="#l6.620"></a><span id="l6.620">   grokNounItem: function gloda_ns_grokNounItem(aItem, aRawReps, aIsNew,</span>
<a href="#l6.621"></a><span id="l6.621">       aCallbackHandle) {</span>
<a href="#l6.622"></a><span id="l6.622">     let itemNounDef = this._nounIDToDef[aItem.NOUN_ID];</span>
<a href="#l6.623"></a><span id="l6.623">     let attribsByBoundName = itemNounDef.attribsByBoundName;</span>
<a href="#l6.624"></a><span id="l6.624">     </span>
<a href="#l6.625"></a><span id="l6.625" class="difflineplus">+    this._log.debug(&quot;grokNounItem: &quot; + itemNounDef.name);</span>
<a href="#l6.626"></a><span id="l6.626" class="difflineplus">+    </span>
<a href="#l6.627"></a><span id="l6.627">     let addDBAttribs = [];</span>
<a href="#l6.628"></a><span id="l6.628">     let removeDBAttribs = [];</span>
<a href="#l6.629"></a><span id="l6.629">     </span>
<a href="#l6.630"></a><span id="l6.630">     let jsonDict = {};</span>
<a href="#l6.631"></a><span id="l6.631">     </span>
<a href="#l6.632"></a><span id="l6.632" class="difflineminus">-    let aOldItem = aItem;</span>
<a href="#l6.633"></a><span id="l6.633" class="difflineminus">-    // we want to create a clone of the existing item so that we can know the</span>
<a href="#l6.634"></a><span id="l6.634" class="difflineminus">-    //  deltas that happened for indexing purposes</span>
<a href="#l6.635"></a><span id="l6.635" class="difflineminus">-    aItem = aItem._clone();</span>
<a href="#l6.636"></a><span id="l6.636" class="difflineplus">+    let aOldItem;</span>
<a href="#l6.637"></a><span id="l6.637" class="difflineplus">+    if (aIsNew) // there is no old item if we are new.</span>
<a href="#l6.638"></a><span id="l6.638" class="difflineplus">+      aOldItem = {};</span>
<a href="#l6.639"></a><span id="l6.639" class="difflineplus">+    else {</span>
<a href="#l6.640"></a><span id="l6.640" class="difflineplus">+      aOldItem = aItem;</span>
<a href="#l6.641"></a><span id="l6.641" class="difflineplus">+      // we want to create a clone of the existing item so that we can know the</span>
<a href="#l6.642"></a><span id="l6.642" class="difflineplus">+      //  deltas that happened for indexing purposes</span>
<a href="#l6.643"></a><span id="l6.643" class="difflineplus">+      aItem = aItem._clone();</span>
<a href="#l6.644"></a><span id="l6.644" class="difflineplus">+    }</span>
<a href="#l6.645"></a><span id="l6.645">   </span>
<a href="#l6.646"></a><span id="l6.646">     // Have the attribute providers directly set properties on the aItem</span>
<a href="#l6.647"></a><span id="l6.647">     let attrProviders = this._attrProviderOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l6.648"></a><span id="l6.648">     for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l6.649"></a><span id="l6.649" class="difflineplus">+      this._log.debug(&quot;  provider: &quot; + attrProviders[iProvider].providerName);</span>
<a href="#l6.650"></a><span id="l6.650">       yield aCallbackHandle.pushAndGo(</span>
<a href="#l6.651"></a><span id="l6.651" class="difflineminus">-        attrProviders[iProvider].process(aItem, aRawItem, aIsNew,</span>
<a href="#l6.652"></a><span id="l6.652" class="difflineplus">+        attrProviders[iProvider].process(aItem, aRawReps, aIsNew,</span>
<a href="#l6.653"></a><span id="l6.653">                                          aCallbackHandle));</span>
<a href="#l6.654"></a><span id="l6.654">     }</span>
<a href="#l6.655"></a><span id="l6.655" class="difflineplus">+    </span>
<a href="#l6.656"></a><span id="l6.656" class="difflineplus">+    this._log.debug(&quot; done with providers.&quot;);</span>
<a href="#l6.657"></a><span id="l6.657">   </span>
<a href="#l6.658"></a><span id="l6.658">     // Iterate over the attributes on the item</span>
<a href="#l6.659"></a><span id="l6.659">     for each (let [key, value] in Iterator(aItem)) {</span>
<a href="#l6.660"></a><span id="l6.660">       // ignore keys that start with underscores, they are private and not</span>
<a href="#l6.661"></a><span id="l6.661">       //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l6.662"></a><span id="l6.662">       //  the object implementation.)</span>
<a href="#l6.663"></a><span id="l6.663">       if (key[0] == &quot;_&quot;)</span>
<a href="#l6.664"></a><span id="l6.664">         continue;</span>
<a href="#l6.665"></a><span id="l6.665">       // find the attribute definition that corresponds to this key</span>
<a href="#l6.666"></a><span id="l6.666">       let attrib = attribsByBoundName[key];</span>
<a href="#l6.667"></a><span id="l6.667">       // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l6.668"></a><span id="l6.668">       if (attrib === undefined)</span>
<a href="#l6.669"></a><span id="l6.669">         continue;</span>
<a href="#l6.670"></a><span id="l6.670">       </span>
<a href="#l6.671"></a><span id="l6.671" class="difflineminus">-      let objNounDef = attrib.objectNounDef;</span>
<a href="#l6.672"></a><span id="l6.672" class="difflineplus">+      let objectNounDef = attrib.objectNounDef;</span>
<a href="#l6.673"></a><span id="l6.673">       </span>
<a href="#l6.674"></a><span id="l6.674">       // - translate for our JSON rep</span>
<a href="#l6.675"></a><span id="l6.675">       if (attrib.singular) {</span>
<a href="#l6.676"></a><span id="l6.676" class="difflineminus">-        if (obnNounDef.toJSON)</span>
<a href="#l6.677"></a><span id="l6.677" class="difflineminus">-          jsonDict[attrib.id] = objNounDef.toJSON(value);</span>
<a href="#l6.678"></a><span id="l6.678" class="difflineplus">+        if (objectNounDef.toJSON)</span>
<a href="#l6.679"></a><span id="l6.679" class="difflineplus">+          jsonDict[attrib.id] = objectNounDef.toJSON(value);</span>
<a href="#l6.680"></a><span id="l6.680">         else</span>
<a href="#l6.681"></a><span id="l6.681">           jsonDict[attrib.id] = value; </span>
<a href="#l6.682"></a><span id="l6.682">       }</span>
<a href="#l6.683"></a><span id="l6.683">       else {</span>
<a href="#l6.684"></a><span id="l6.684" class="difflineminus">-        if (objNounDef.toJSON) {</span>
<a href="#l6.685"></a><span id="l6.685" class="difflineminus">-          toJSON = objNounDef.toJSON;</span>
<a href="#l6.686"></a><span id="l6.686" class="difflineplus">+        if (objectNounDef.toJSON) {</span>
<a href="#l6.687"></a><span id="l6.687" class="difflineplus">+          toJSON = objectNounDef.toJSON;</span>
<a href="#l6.688"></a><span id="l6.688">           jsonDict[attrib.id] = [toJSON(subValue) for each</span>
<a href="#l6.689"></a><span id="l6.689">                            ([, subValue] in Iterator(value))] ;</span>
<a href="#l6.690"></a><span id="l6.690">         }</span>
<a href="#l6.691"></a><span id="l6.691">         else</span>
<a href="#l6.692"></a><span id="l6.692">           jsonDict[attrib.id] = value;</span>
<a href="#l6.693"></a><span id="l6.693">       }</span>
<a href="#l6.694"></a><span id="l6.694">       </span>
<a href="#l6.695"></a><span id="l6.695">       // perform a delta analysis against the old value, if we have one</span>
<a href="#l6.696"></a><span id="l6.696" class="difflineat">@@ -1454,19 +1421,19 @@ var Gloda = {</span>
<a href="#l6.697"></a><span id="l6.697">               attrib.convertValuesToDBAttributes(oldValue)[0]);</span>
<a href="#l6.698"></a><span id="l6.698">           }</span>
<a href="#l6.699"></a><span id="l6.699">         }</span>
<a href="#l6.700"></a><span id="l6.700">         // in the plural case, we have to figure the deltas accounting for</span>
<a href="#l6.701"></a><span id="l6.701">         //  possible changes in ordering (which is insignificant from an</span>
<a href="#l6.702"></a><span id="l6.702">         //  indexing perspective)</span>
<a href="#l6.703"></a><span id="l6.703">         // some nouns may not meet === equivalence needs, so must provide a</span>
<a href="#l6.704"></a><span id="l6.704">         //  custom computeDelta method to help us out</span>
<a href="#l6.705"></a><span id="l6.705" class="difflineminus">-        else if (objNounDef.computeDelta) {</span>
<a href="#l6.706"></a><span id="l6.706" class="difflineplus">+        else if (objectNounDef.computeDelta) {</span>
<a href="#l6.707"></a><span id="l6.707">           let [valuesAdded, valuesRemoved] = </span>
<a href="#l6.708"></a><span id="l6.708" class="difflineminus">-            objNounDef.computeDelta(value, oldValue);</span>
<a href="#l6.709"></a><span id="l6.709" class="difflineplus">+            objectNounDef.computeDelta(value, oldValue);</span>
<a href="#l6.710"></a><span id="l6.710">           // convert the values to database-style attribute rows</span>
<a href="#l6.711"></a><span id="l6.711">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l6.712"></a><span id="l6.712">             attrib.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l6.713"></a><span id="l6.713">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l6.714"></a><span id="l6.714">             attrib.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l6.715"></a><span id="l6.715">         }</span>
<a href="#l6.716"></a><span id="l6.716">         else {</span>
<a href="#l6.717"></a><span id="l6.717">           // build a map of the previous values; we will delete the values as</span>
<a href="#l6.718"></a><span id="l6.718" class="difflineat">@@ -1494,17 +1461,17 @@ var Gloda = {</span>
<a href="#l6.719"></a><span id="l6.719">         }</span>
<a href="#l6.720"></a><span id="l6.720">       </span>
<a href="#l6.721"></a><span id="l6.721">         // delete the old values to mark that we have processed them</span>
<a href="#l6.722"></a><span id="l6.722">         delete aOldItem[key];</span>
<a href="#l6.723"></a><span id="l6.723">       }</span>
<a href="#l6.724"></a><span id="l6.724">       // no old value, all attributes are new</span>
<a href="#l6.725"></a><span id="l6.725">       else {</span>
<a href="#l6.726"></a><span id="l6.726">         addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l6.727"></a><span id="l6.727" class="difflineminus">-                                attrib.convertValuesToDBAttributes(value));</span>
<a href="#l6.728"></a><span id="l6.728" class="difflineplus">+                                attrib.dbDef.convertValuesToDBAttributes(value));</span>
<a href="#l6.729"></a><span id="l6.729">       }</span>
<a href="#l6.730"></a><span id="l6.730">     }</span>
<a href="#l6.731"></a><span id="l6.731">     </span>
<a href="#l6.732"></a><span id="l6.732">     // Iterate over any remaining values in old items for purge purposes.</span>
<a href="#l6.733"></a><span id="l6.733">     for each (let [key, value] in Iterator(aOldItem)) {</span>
<a href="#l6.734"></a><span id="l6.734">       // ignore keys that start with underscores, they are private and not</span>
<a href="#l6.735"></a><span id="l6.735">       //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l6.736"></a><span id="l6.736">       //  the object implementation.)</span>
<a href="#l6.737"></a><span id="l6.737" class="difflineat">@@ -1516,87 +1483,35 @@ var Gloda = {</span>
<a href="#l6.738"></a><span id="l6.738">       if (attrib === undefined)</span>
<a href="#l6.739"></a><span id="l6.739">         continue;</span>
<a href="#l6.740"></a><span id="l6.740">       </span>
<a href="#l6.741"></a><span id="l6.741">       removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l6.742"></a><span id="l6.742">                                  attrib.convertValuesToDBAttributes(value));</span>
<a href="#l6.743"></a><span id="l6.743">     }</span>
<a href="#l6.744"></a><span id="l6.744">     </span>
<a href="#l6.745"></a><span id="l6.745">     aItem._jsonText = this._json.encode(jsonDict);</span>
<a href="#l6.746"></a><span id="l6.746" class="difflineplus">+    this._log.debug(&quot;  json text: &quot; + aItem._jsonText);</span>
<a href="#l6.747"></a><span id="l6.747">     </span>
<a href="#l6.748"></a><span id="l6.748">     if (aIsNew) {</span>
<a href="#l6.749"></a><span id="l6.749" class="difflineplus">+      this._log.debug(&quot; inserting item&quot;);</span>
<a href="#l6.750"></a><span id="l6.750">       itemNounDef.objInsert.call(itemNounDef.datastore, aItem);</span>
<a href="#l6.751"></a><span id="l6.751">     }</span>
<a href="#l6.752"></a><span id="l6.752">     else {</span>
<a href="#l6.753"></a><span id="l6.753" class="difflineplus">+      this._log.debug(&quot; updating item&quot;);</span>
<a href="#l6.754"></a><span id="l6.754">       itemNounDef.objUpdate.call(itemNounDef.datastore, aItem);</span>
<a href="#l6.755"></a><span id="l6.755">     }</span>
<a href="#l6.756"></a><span id="l6.756">     </span>
<a href="#l6.757"></a><span id="l6.757" class="difflineplus">+    this._log.debug(&quot; adjusting attributes&quot;);</span>
<a href="#l6.758"></a><span id="l6.758" class="difflineplus">+    itemNounDef.dbAttribAdjuster.call(itemNounDef.datastore, aItem,</span>
<a href="#l6.759"></a><span id="l6.759" class="difflineplus">+      addDBAttribs, removeDBAttribs);</span>
<a href="#l6.760"></a><span id="l6.760" class="difflineplus">+    </span>
<a href="#l6.761"></a><span id="l6.761" class="difflineplus">+    this._log.debug(&quot; done grokking.&quot;);</span>
<a href="#l6.762"></a><span id="l6.762" class="difflineplus">+    </span>
<a href="#l6.763"></a><span id="l6.763">     yield this.kWorkDone;</span>
<a href="#l6.764"></a><span id="l6.764">   },</span>
<a href="#l6.765"></a><span id="l6.765" class="difflineminus">-</span>
<a href="#l6.766"></a><span id="l6.766" class="difflineminus">-  _processNounItem: function gloda_ns_processNounItem(aItem, aRawItem, aIsNew) {</span>
<a href="#l6.767"></a><span id="l6.767" class="difflineminus">-    // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l6.768"></a><span id="l6.768" class="difflineminus">-    //  before applying the new attributes.</span>
<a href="#l6.769"></a><span id="l6.769" class="difflineminus">-    aItem._datastore.clearAttributes(aItem);</span>
<a href="#l6.770"></a><span id="l6.770" class="difflineminus">-</span>
<a href="#l6.771"></a><span id="l6.771" class="difflineminus">-    let allAttribs = [];</span>
<a href="#l6.772"></a><span id="l6.772" class="difflineminus">-</span>
<a href="#l6.773"></a><span id="l6.773" class="difflineminus">-    let attrProviders = this._attrProviderOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l6.774"></a><span id="l6.774" class="difflineminus">-    for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l6.775"></a><span id="l6.775" class="difflineminus">-      let attribs = attrProviders[iProvider].process(aItem, aRawItem);</span>
<a href="#l6.776"></a><span id="l6.776" class="difflineminus">-      allAttribs = allAttribs.concat(attribs);</span>
<a href="#l6.777"></a><span id="l6.777" class="difflineminus">-    }</span>
<a href="#l6.778"></a><span id="l6.778" class="difflineminus">-</span>
<a href="#l6.779"></a><span id="l6.779" class="difflineminus">-    // [attribute id, value] for for the database</span>
<a href="#l6.780"></a><span id="l6.780" class="difflineminus">-    let outAttribs = [];</span>
<a href="#l6.781"></a><span id="l6.781" class="difflineminus">-    // [attribute def, parameter, value] for memory usage</span>
<a href="#l6.782"></a><span id="l6.782" class="difflineminus">-    let memAttribs = [];</span>
<a href="#l6.783"></a><span id="l6.783" class="difflineminus">-</span>
<a href="#l6.784"></a><span id="l6.784" class="difflineminus">-    for (let iAttrib = 0; iAttrib &lt; allAttribs.length; iAttrib++) {</span>
<a href="#l6.785"></a><span id="l6.785" class="difflineminus">-      let attribDesc = allAttribs[iAttrib];</span>
<a href="#l6.786"></a><span id="l6.786" class="difflineminus">-</span>
<a href="#l6.787"></a><span id="l6.787" class="difflineminus">-      // is it an (attributedef / attribute def id, value) tuple?</span>
<a href="#l6.788"></a><span id="l6.788" class="difflineminus">-      if (attribDesc.length == 2) {</span>
<a href="#l6.789"></a><span id="l6.789" class="difflineminus">-        // if it's already an attrib id, we can use the tuple outright</span>
<a href="#l6.790"></a><span id="l6.790" class="difflineminus">-        if (typeof attribDesc[0] == &quot;number&quot;) {</span>
<a href="#l6.791"></a><span id="l6.791" class="difflineminus">-          outAttribs.push(attribDesc);</span>
<a href="#l6.792"></a><span id="l6.792" class="difflineminus">-          let [attribDef, attribParam] =</span>
<a href="#l6.793"></a><span id="l6.793" class="difflineminus">-            GlodaDatastore._attributeIDToDBDefAndParam[attribDesc[0]];</span>
<a href="#l6.794"></a><span id="l6.794" class="difflineminus">-          memAttribs.push([attribDef, attribParam, attribDesc[1]]);</span>
<a href="#l6.795"></a><span id="l6.795" class="difflineminus">-        }</span>
<a href="#l6.796"></a><span id="l6.796" class="difflineminus">-        else {</span>
<a href="#l6.797"></a><span id="l6.797" class="difflineminus">-          outAttribs.push([attribDesc[0].id, attribDesc[1]]);</span>
<a href="#l6.798"></a><span id="l6.798" class="difflineminus">-          // the parameter is null if they just pass an attribute def</span>
<a href="#l6.799"></a><span id="l6.799" class="difflineminus">-          memAttribs.push([attribDesc[0], null, attribDesc[1]]);</span>
<a href="#l6.800"></a><span id="l6.800" class="difflineminus">-        }</span>
<a href="#l6.801"></a><span id="l6.801" class="difflineminus">-      }</span>
<a href="#l6.802"></a><span id="l6.802" class="difflineminus">-      // it must be an (attrib, parameter value, attrib value) tuple</span>
<a href="#l6.803"></a><span id="l6.803" class="difflineminus">-      else {</span>
<a href="#l6.804"></a><span id="l6.804" class="difflineminus">-        // just store it verbatim for memory purposes</span>
<a href="#l6.805"></a><span id="l6.805" class="difflineminus">-        memAttribs.push(attribDesc);</span>
<a href="#l6.806"></a><span id="l6.806" class="difflineminus">-</span>
<a href="#l6.807"></a><span id="l6.807" class="difflineminus">-        let attrib = attribDesc[0];</span>
<a href="#l6.808"></a><span id="l6.808" class="difflineminus">-        let parameterValue = attribDesc[1];</span>
<a href="#l6.809"></a><span id="l6.809" class="difflineminus">-        let attribID;</span>
<a href="#l6.810"></a><span id="l6.810" class="difflineminus">-        if (parameterValue != null)</span>
<a href="#l6.811"></a><span id="l6.811" class="difflineminus">-          attribID = attrib.bindParameter(parameterValue);</span>
<a href="#l6.812"></a><span id="l6.812" class="difflineminus">-        else</span>
<a href="#l6.813"></a><span id="l6.813" class="difflineminus">-          attribID = attrib.id;</span>
<a href="#l6.814"></a><span id="l6.814" class="difflineminus">-        outAttribs.push([attribID, attribDesc[2]]);</span>
<a href="#l6.815"></a><span id="l6.815" class="difflineminus">-      }</span>
<a href="#l6.816"></a><span id="l6.816" class="difflineminus">-    }</span>
<a href="#l6.817"></a><span id="l6.817" class="difflineminus">-</span>
<a href="#l6.818"></a><span id="l6.818" class="difflineminus">-    GlodaDatastore.insertAttributes(aItem, outAttribs);</span>
<a href="#l6.819"></a><span id="l6.819" class="difflineminus">-    aItem._replaceAttributes(memAttribs);</span>
<a href="#l6.820"></a><span id="l6.820" class="difflineminus">-</span>
<a href="#l6.821"></a><span id="l6.821" class="difflineminus">-    if (aIsNew)</span>
<a href="#l6.822"></a><span id="l6.822" class="difflineminus">-      GlodaCollectionManager.itemsAdded(aItem.NOUN_ID, [aItem]);</span>
<a href="#l6.823"></a><span id="l6.823" class="difflineminus">-    else</span>
<a href="#l6.824"></a><span id="l6.824" class="difflineminus">-      GlodaCollectionManager.itemsModified(aItem.NOUN_ID, [aItem]);</span>
<a href="#l6.825"></a><span id="l6.825" class="difflineminus">-  },</span>
<a href="#l6.826"></a><span id="l6.826"> };</span>
<a href="#l6.827"></a><span id="l6.827"> </span>
<a href="#l6.828"></a><span id="l6.828"> /* and initialize the Gloda object/NS before we return... */</span>
<a href="#l6.829"></a><span id="l6.829"> try {</span>
<a href="#l6.830"></a><span id="l6.830">   Gloda._init();</span>
<a href="#l6.831"></a><span id="l6.831"> }</span>
<a href="#l6.832"></a><span id="l6.832"> catch (ex) {</span>
<a href="#l6.833"></a><span id="l6.833">   Gloda._log.debug(&quot;Exception during Gloda init (&quot; + ex.fileName + &quot;:&quot; +</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/modules/index_ab.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/modules/index_ab.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -67,42 +67,55 @@ var GlodaABIndexer = {</span>
<a href="#l7.4"></a><span id="l7.4">   },</span>
<a href="#l7.5"></a><span id="l7.5">   </span>
<a href="#l7.6"></a><span id="l7.6">   disable: function() {</span>
<a href="#l7.7"></a><span id="l7.7">     let abManager = Cc[&quot;@mozilla.org/abmanager;1&quot;].getService(Ci.nsIAbManager);</span>
<a href="#l7.8"></a><span id="l7.8">     abManager.removeAddressBookListener(this);</span>
<a href="#l7.9"></a><span id="l7.9">   },</span>
<a href="#l7.10"></a><span id="l7.10"> </span>
<a href="#l7.11"></a><span id="l7.11">   get workers() {</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-    return [[&quot;ab-index&quot;, this._worker_index]];</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+    return [[&quot;ab-card&quot;, this._worker_index_card]];</span>
<a href="#l7.14"></a><span id="l7.14">   },</span>
<a href="#l7.15"></a><span id="l7.15">   </span>
<a href="#l7.16"></a><span id="l7.16" class="difflineminus">-  _worker_index: function(aJob) {</span>
<a href="#l7.17"></a><span id="l7.17" class="difflineplus">+  _worker_index_card: function(aJob, aCallbackHandle) {</span>
<a href="#l7.18"></a><span id="l7.18" class="difflineplus">+    // load the identity</span>
<a href="#l7.19"></a><span id="l7.19" class="difflineplus">+    let query = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineplus">+    query.kind(&quot;email&quot;);</span>
<a href="#l7.21"></a><span id="l7.21" class="difflineplus">+    query.value(card.primaryEmail);</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineplus">+    let identityCollection = query.getCollection(aCallbackHandle);</span>
<a href="#l7.23"></a><span id="l7.23" class="difflineplus">+    yield Gloda.kWorkAsync;</span>
<a href="#l7.24"></a><span id="l7.24" class="difflineplus">+    </span>
<a href="#l7.25"></a><span id="l7.25" class="difflineplus">+    if (identityCollection.length) {</span>
<a href="#l7.26"></a><span id="l7.26" class="difflineplus">+      let identity = identityCollection.items[0];</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineplus">+</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineplus">+      this._log.debug(&quot;Found identity, processing card.&quot;);</span>
<a href="#l7.29"></a><span id="l7.29" class="difflineplus">+      yield aCallbackHandle.pushAndGo(</span>
<a href="#l7.30"></a><span id="l7.30" class="difflineplus">+          Gloda.grokNounItem(identity.contact, card, false, aCallbackHandle));</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+      this._log.debug(&quot;Done processing card.&quot;);</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+    }</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineplus">+    </span>
<a href="#l7.34"></a><span id="l7.34">     yield GlodaIndexer.kWorkDone;</span>
<a href="#l7.35"></a><span id="l7.35">   },</span>
<a href="#l7.36"></a><span id="l7.36">   </span>
<a href="#l7.37"></a><span id="l7.37">   initialSweep: function() {</span>
<a href="#l7.38"></a><span id="l7.38">   },</span>
<a href="#l7.39"></a><span id="l7.39">   </span>
<a href="#l7.40"></a><span id="l7.40">   /* ------ nsIAbListener ------ */</span>
<a href="#l7.41"></a><span id="l7.41">   onItemAdded: function ab_indexer_onItemAdded(aParentDir, aItem) {</span>
<a href="#l7.42"></a><span id="l7.42">   },</span>
<a href="#l7.43"></a><span id="l7.43">   onItemRemoved: function ab_indexer_onItemRemoved(aParentDir, aItem) {</span>
<a href="#l7.44"></a><span id="l7.44">   },</span>
<a href="#l7.45"></a><span id="l7.45">   onItemPropertyChanged: function ab_indexer_onItemPropertyChanged(aItem,</span>
<a href="#l7.46"></a><span id="l7.46">       aProperty, aOldValue, aNewValue) {</span>
<a href="#l7.47"></a><span id="l7.47">     if (aProperty == null &amp;&amp; aItem instanceof Ci.nsIAbCard) {</span>
<a href="#l7.48"></a><span id="l7.48">       this._log.debug(&quot;Received Card Change Notification&quot;);</span>
<a href="#l7.49"></a><span id="l7.49" class="difflineplus">+</span>
<a href="#l7.50"></a><span id="l7.50">       let card = aItem; // instanceof already QueryInterface'd for us.</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineminus">-      let identity = GlodaDatastore.getIdentity(&quot;email&quot;, card.primaryEmail);</span>
<a href="#l7.52"></a><span id="l7.52" class="difflineminus">-      if (identity) {</span>
<a href="#l7.53"></a><span id="l7.53" class="difflineminus">-        this._log.debug(&quot;Found identity, processing card.&quot;);</span>
<a href="#l7.54"></a><span id="l7.54" class="difflineminus">-        Gloda._processNounItem(identity.contact, card, false);</span>
<a href="#l7.55"></a><span id="l7.55" class="difflineminus">-        this._log.debug(&quot;Done processing card.&quot;);</span>
<a href="#l7.56"></a><span id="l7.56" class="difflineminus">-      }</span>
<a href="#l7.57"></a><span id="l7.57" class="difflineplus">+      let job = new IndexingJob(&quot;ab-card&quot;, 1, card);</span>
<a href="#l7.58"></a><span id="l7.58" class="difflineplus">+      GlodaIndexer.indexJob(job);</span>
<a href="#l7.59"></a><span id="l7.59">     }</span>
<a href="#l7.60"></a><span id="l7.60">   }</span>
<a href="#l7.61"></a><span id="l7.61"> };</span>
<a href="#l7.62"></a><span id="l7.62"> GlodaIndexer.registerIndexer(GlodaABIndexer);</span>
<a href="#l7.63"></a><span id="l7.63"> </span>
<a href="#l7.64"></a><span id="l7.64"> var GlodaABAttrs = {</span>
<a href="#l7.65"></a><span id="l7.65">   providerName: &quot;gloda.ab_attr&quot;,</span>
<a href="#l7.66"></a><span id="l7.66">   _log: null,</span>
<a href="#l7.67"></a><span id="l7.67" class="difflineat">@@ -118,84 +131,92 @@ var GlodaABAttrs = {</span>
<a href="#l7.68"></a><span id="l7.68">     catch (ex) {</span>
<a href="#l7.69"></a><span id="l7.69">       this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l7.70"></a><span id="l7.70">       throw ex;</span>
<a href="#l7.71"></a><span id="l7.71">     }</span>
<a href="#l7.72"></a><span id="l7.72">   },</span>
<a href="#l7.73"></a><span id="l7.73">   </span>
<a href="#l7.74"></a><span id="l7.74">   defineAttributes: function() {</span>
<a href="#l7.75"></a><span id="l7.75">     /* ***** Contacts ***** */</span>
<a href="#l7.76"></a><span id="l7.76" class="difflineplus">+    this._attrIdentityContact = Gloda.defineAttribute({</span>
<a href="#l7.77"></a><span id="l7.77" class="difflineplus">+      provider: this,</span>
<a href="#l7.78"></a><span id="l7.78" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.79"></a><span id="l7.79" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l7.80"></a><span id="l7.80" class="difflineplus">+      attributeName: &quot;identities&quot;,</span>
<a href="#l7.81"></a><span id="l7.81" class="difflineplus">+      singular: false,</span>
<a href="#l7.82"></a><span id="l7.82" class="difflineplus">+      special: Gloda.kSpecialColumnChildren,</span>
<a href="#l7.83"></a><span id="l7.83" class="difflineplus">+      //specialColumnName: &quot;contactID&quot;,</span>
<a href="#l7.84"></a><span id="l7.84" class="difflineplus">+      storageAttributeName: &quot;_identities&quot;,</span>
<a href="#l7.85"></a><span id="l7.85" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l7.86"></a><span id="l7.86" class="difflineplus">+      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l7.87"></a><span id="l7.87" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l7.88"></a><span id="l7.88">     this._attrContactName = Gloda.defineAttribute({</span>
<a href="#l7.89"></a><span id="l7.89">       provider: this,</span>
<a href="#l7.90"></a><span id="l7.90">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.91"></a><span id="l7.91">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l7.92"></a><span id="l7.92">       attributeName: &quot;name&quot;,</span>
<a href="#l7.93"></a><span id="l7.93" class="difflineminus">-      bind: false,</span>
<a href="#l7.94"></a><span id="l7.94">       singular: true,</span>
<a href="#l7.95"></a><span id="l7.95">       special: Gloda.kSpecialString,</span>
<a href="#l7.96"></a><span id="l7.96">       specialColumnName: &quot;name&quot;,</span>
<a href="#l7.97"></a><span id="l7.97">       subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l7.98"></a><span id="l7.98">       objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l7.99"></a><span id="l7.99">       }); // tested-by: test_attributes_fundamental</span>
<a href="#l7.100"></a><span id="l7.100">     this._attrContactPopularity = Gloda.defineAttribute({</span>
<a href="#l7.101"></a><span id="l7.101">       provider: this,</span>
<a href="#l7.102"></a><span id="l7.102">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.103"></a><span id="l7.103">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l7.104"></a><span id="l7.104">       attributeName: &quot;popularity&quot;,</span>
<a href="#l7.105"></a><span id="l7.105" class="difflineminus">-      bind: false,</span>
<a href="#l7.106"></a><span id="l7.106">       singular: true,</span>
<a href="#l7.107"></a><span id="l7.107">       special: Gloda.kSpecialColumn,</span>
<a href="#l7.108"></a><span id="l7.108">       specialColumnName: &quot;popularity&quot;,</span>
<a href="#l7.109"></a><span id="l7.109">       subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l7.110"></a><span id="l7.110">       objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l7.111"></a><span id="l7.111">       }); // not-tested</span>
<a href="#l7.112"></a><span id="l7.112">     this._attrContactFrecency = Gloda.defineAttribute({</span>
<a href="#l7.113"></a><span id="l7.113">       provider: this,</span>
<a href="#l7.114"></a><span id="l7.114">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.115"></a><span id="l7.115">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l7.116"></a><span id="l7.116">       attributeName: &quot;frecency&quot;,</span>
<a href="#l7.117"></a><span id="l7.117" class="difflineminus">-      bind: false,</span>
<a href="#l7.118"></a><span id="l7.118">       singular: true,</span>
<a href="#l7.119"></a><span id="l7.119">       special: Gloda.kSpecialColumn,</span>
<a href="#l7.120"></a><span id="l7.120">       specialColumnName: &quot;frecency&quot;,</span>
<a href="#l7.121"></a><span id="l7.121">       subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l7.122"></a><span id="l7.122">       objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l7.123"></a><span id="l7.123">       }); // not-tested</span>
<a href="#l7.124"></a><span id="l7.124"> </span>
<a href="#l7.125"></a><span id="l7.125">     /* ***** Identities ***** */</span>
<a href="#l7.126"></a><span id="l7.126">     this._attrIdentityContact = Gloda.defineAttribute({</span>
<a href="#l7.127"></a><span id="l7.127">       provider: this,</span>
<a href="#l7.128"></a><span id="l7.128">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.129"></a><span id="l7.129">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l7.130"></a><span id="l7.130">       attributeName: &quot;contact&quot;,</span>
<a href="#l7.131"></a><span id="l7.131" class="difflineminus">-      bind: false,</span>
<a href="#l7.132"></a><span id="l7.132">       singular: true,</span>
<a href="#l7.133"></a><span id="l7.133">       special: Gloda.kSpecialColumn,</span>
<a href="#l7.134"></a><span id="l7.134" class="difflineminus">-      specialColumnName: &quot;contactID&quot;,</span>
<a href="#l7.135"></a><span id="l7.135" class="difflineplus">+      specialColumnName: &quot;contactID&quot;, // the column in the db</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineplus">+      idStorageAttributeName: &quot;_contactID&quot;,</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineplus">+      valueStorageAttributeName: &quot;_contact&quot;, </span>
<a href="#l7.138"></a><span id="l7.138">       subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l7.139"></a><span id="l7.139">       objectNoun: Gloda.NOUN_CONTACT,</span>
<a href="#l7.140"></a><span id="l7.140">       }); // tested-by: test_attributes_fundamental</span>
<a href="#l7.141"></a><span id="l7.141">     this._attrIdentityKind = Gloda.defineAttribute({</span>
<a href="#l7.142"></a><span id="l7.142">       provider: this,</span>
<a href="#l7.143"></a><span id="l7.143">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.144"></a><span id="l7.144">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l7.145"></a><span id="l7.145">       attributeName: &quot;kind&quot;,</span>
<a href="#l7.146"></a><span id="l7.146" class="difflineminus">-      bind: false,</span>
<a href="#l7.147"></a><span id="l7.147">       singular: true,</span>
<a href="#l7.148"></a><span id="l7.148">       special: Gloda.kSpecialString,</span>
<a href="#l7.149"></a><span id="l7.149">       specialColumnName: &quot;kind&quot;,</span>
<a href="#l7.150"></a><span id="l7.150">       subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l7.151"></a><span id="l7.151">       objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l7.152"></a><span id="l7.152">       }); // tested-by: test_attributes_fundamental</span>
<a href="#l7.153"></a><span id="l7.153">     this._attrIdentityValue = Gloda.defineAttribute({</span>
<a href="#l7.154"></a><span id="l7.154">       provider: this,</span>
<a href="#l7.155"></a><span id="l7.155">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.156"></a><span id="l7.156">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l7.157"></a><span id="l7.157">       attributeName: &quot;value&quot;,</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineminus">-      bind: false,</span>
<a href="#l7.159"></a><span id="l7.159">       singular: true,</span>
<a href="#l7.160"></a><span id="l7.160">       special: Gloda.kSpecialString,</span>
<a href="#l7.161"></a><span id="l7.161">       specialColumnName: &quot;value&quot;,</span>
<a href="#l7.162"></a><span id="l7.162">       subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l7.163"></a><span id="l7.163">       objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l7.164"></a><span id="l7.164">       }); // tested-by: test_attributes_fundamental</span>
<a href="#l7.165"></a><span id="l7.165"> </span>
<a href="#l7.166"></a><span id="l7.166">     /* ***** Contact Meta ***** */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -38,17 +38,17 @@</span>
<a href="#l8.4"></a><span id="l8.4"> /*</span>
<a href="#l8.5"></a><span id="l8.5">  * This file currently contains a fairly general implementation of asynchronous</span>
<a href="#l8.6"></a><span id="l8.6">  *  indexing with a very explicit message indexing implementation.  As gloda</span>
<a href="#l8.7"></a><span id="l8.7">  *  will eventually want to index more than just messages, the message-specific</span>
<a href="#l8.8"></a><span id="l8.8">  *  things should ideally lose their special hold on this file.  This will</span>
<a href="#l8.9"></a><span id="l8.9">  *  benefit readability/size as well.</span>
<a href="#l8.10"></a><span id="l8.10">  */</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-EXPORTED_SYMBOLS = ['GlodaIndexer'];</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+EXPORTED_SYMBOLS = ['GlodaIndexer', 'IndexingJob'];</span>
<a href="#l8.14"></a><span id="l8.14"> </span>
<a href="#l8.15"></a><span id="l8.15"> const Cc = Components.classes;</span>
<a href="#l8.16"></a><span id="l8.16"> const Ci = Components.interfaces;</span>
<a href="#l8.17"></a><span id="l8.17"> const Cr = Components.results;</span>
<a href="#l8.18"></a><span id="l8.18"> const Cu = Components.utils;</span>
<a href="#l8.19"></a><span id="l8.19"> </span>
<a href="#l8.20"></a><span id="l8.20"> Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l8.21"></a><span id="l8.21"> </span>
<a href="#l8.22"></a><span id="l8.22" class="difflineat">@@ -126,28 +126,30 @@ function fixIterator(aEnum, aIface) {</span>
<a href="#l8.23"></a><span id="l8.23">     let iter = function () {</span>
<a href="#l8.24"></a><span id="l8.24">       while (aEnum.hasMoreElements())</span>
<a href="#l8.25"></a><span id="l8.25">         yield aEnum.getNext().QueryInterface(face);</span>
<a href="#l8.26"></a><span id="l8.26">     }</span>
<a href="#l8.27"></a><span id="l8.27">     return { __iterator__: iter };</span>
<a href="#l8.28"></a><span id="l8.28">   } catch(ex) {}</span>
<a href="#l8.29"></a><span id="l8.29"> }</span>
<a href="#l8.30"></a><span id="l8.30"> </span>
<a href="#l8.31"></a><span id="l8.31" class="difflineminus">-function MakeCleanMsgHdrCallback(aMsgHdr) {</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+function MakeCleanMsgHdrCallback(aMsgHdr, aGlodaMessageID) {</span>
<a href="#l8.33"></a><span id="l8.33">   return function() {</span>
<a href="#l8.34"></a><span id="l8.34">     // Mark this message as indexed</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineminus">-    aMsgHdr.setUint32Property(this.GLODA_MESSAGE_ID_PROPERTY, curMsg.id);</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+    aMsgHdr.setUint32Property(GlodaIndexer.GLODA_MESSAGE_ID_PROPERTY,</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+                              aGlodaMessageID);</span>
<a href="#l8.38"></a><span id="l8.38">     // If there is a gloda-dirty flag on there, clear it by writing a 0.  (But</span>
<a href="#l8.39"></a><span id="l8.39">     //  don't do this if we didn't have a dirty flag on there in the first</span>
<a href="#l8.40"></a><span id="l8.40">     //  case.)  It sounds like we would actually prefer to &quot;cut&quot; the &quot;cell&quot;,</span>
<a href="#l8.41"></a><span id="l8.41">     //  but I don't see any in-domain means of doing that.</span>
<a href="#l8.42"></a><span id="l8.42">     try {</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineminus">-      let isDirty = aMsgHdr.getUint32Property(this.GLODA_DIRTY_PROPERTY);</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+      let isDirty = aMsgHdr.getUint32Property(</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineplus">+        GlodaIndexer.GLODA_DIRTY_PROPERTY);</span>
<a href="#l8.46"></a><span id="l8.46">       if (isDirty)</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineminus">-        aMsgHdr.setUint32Property(this.GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineplus">+        aMsgHdr.setUint32Property(GlodaIndexer.GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l8.49"></a><span id="l8.49">     }</span>
<a href="#l8.50"></a><span id="l8.50">     catch (ex) {}</span>
<a href="#l8.51"></a><span id="l8.51">   };</span>
<a href="#l8.52"></a><span id="l8.52"> }</span>
<a href="#l8.53"></a><span id="l8.53"> </span>
<a href="#l8.54"></a><span id="l8.54"> const MSG_FLAG_OFFLINE = 0x80;</span>
<a href="#l8.55"></a><span id="l8.55"> const MSG_FLAG_EXPUNGED = 0x08;</span>
<a href="#l8.56"></a><span id="l8.56"> </span>
<a href="#l8.57"></a><span id="l8.57" class="difflineat">@@ -292,17 +294,17 @@ var GlodaIndexer = {</span>
<a href="#l8.58"></a><span id="l8.58">     </span>
<a href="#l8.59"></a><span id="l8.59">     this._inited = true;</span>
<a href="#l8.60"></a><span id="l8.60">     </span>
<a href="#l8.61"></a><span id="l8.61">     // initialize our listeners' this pointers</span>
<a href="#l8.62"></a><span id="l8.62">     this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l8.63"></a><span id="l8.63">     this._msgFolderListener.indexer = this;</span>
<a href="#l8.64"></a><span id="l8.64">     this._shutdownTask.indexer = this;</span>
<a href="#l8.65"></a><span id="l8.65">     </span>
<a href="#l8.66"></a><span id="l8.66" class="difflineminus">-    this._callbackHandler.init();</span>
<a href="#l8.67"></a><span id="l8.67" class="difflineplus">+    this._callbackHandle.init();</span>
<a href="#l8.68"></a><span id="l8.68">     </span>
<a href="#l8.69"></a><span id="l8.69">     // create the timer that drives our intermittent indexing</span>
<a href="#l8.70"></a><span id="l8.70">     this._timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l8.71"></a><span id="l8.71"> </span>
<a href="#l8.72"></a><span id="l8.72"> </span>
<a href="#l8.73"></a><span id="l8.73">     // figure out if event-driven indexing should be enabled...</span>
<a href="#l8.74"></a><span id="l8.74">     let prefService = Cc[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l8.75"></a><span id="l8.75">                         getService(Ci.nsIPrefService);</span>
<a href="#l8.76"></a><span id="l8.76" class="difflineat">@@ -904,24 +906,25 @@ var GlodaIndexer = {</span>
<a href="#l8.77"></a><span id="l8.77">       if (this._batch === null)</span>
<a href="#l8.78"></a><span id="l8.78">         this._batch = this.workBatch();</span>
<a href="#l8.79"></a><span id="l8.79">       </span>
<a href="#l8.80"></a><span id="l8.80">       // kWorkAsync, kWorkDone, kWorkPause are allowed out; kWorkSync is not</span>
<a href="#l8.81"></a><span id="l8.81">       // On kWorkDone, we want to schedule another timer to fire on us if we are</span>
<a href="#l8.82"></a><span id="l8.82">       //  not done indexing.  (On kWorkAsync, we don't care what happens, because</span>
<a href="#l8.83"></a><span id="l8.83">       //  someone else will be receiving the callback, and they will call us when</span>
<a href="#l8.84"></a><span id="l8.84">       //  they are done doing their thing.</span>
<a href="#l8.85"></a><span id="l8.85" class="difflineminus">-      let result;</span>
<a href="#l8.86"></a><span id="l8.86">       let args;</span>
<a href="#l8.87"></a><span id="l8.87">       if (this._savedCallbackArgs != null) {</span>
<a href="#l8.88"></a><span id="l8.88">         args = this._savedCallbackArgs;</span>
<a href="#l8.89"></a><span id="l8.89">         this._savedCallbackArgs = null;</span>
<a href="#l8.90"></a><span id="l8.90">       }</span>
<a href="#l8.91"></a><span id="l8.91">       else</span>
<a href="#l8.92"></a><span id="l8.92" class="difflineminus">-        args = arguments;</span>
<a href="#l8.93"></a><span id="l8.93" class="difflineplus">+        args = arguments; //Array.slice.call(arguments);</span>
<a href="#l8.94"></a><span id="l8.94" class="difflineplus">+      </span>
<a href="#l8.95"></a><span id="l8.95" class="difflineplus">+      let result;</span>
<a href="#l8.96"></a><span id="l8.96">       if (args.length == 0)</span>
<a href="#l8.97"></a><span id="l8.97">         result = this._batch.next();</span>
<a href="#l8.98"></a><span id="l8.98">       else if (args.length == 1)</span>
<a href="#l8.99"></a><span id="l8.99">         result = this._batch.send(args[0]);</span>
<a href="#l8.100"></a><span id="l8.100">       else // arguments works with destructuring assignment</span>
<a href="#l8.101"></a><span id="l8.101">         result = this._batch.send(args);</span>
<a href="#l8.102"></a><span id="l8.102">       switch (result) {</span>
<a href="#l8.103"></a><span id="l8.103">         // job's done, close the batch and re-schedule ourselves if there's more</span>
<a href="#l8.104"></a><span id="l8.104" class="difflineat">@@ -946,20 +949,20 @@ var GlodaIndexer = {</span>
<a href="#l8.105"></a><span id="l8.105">       }</span>
<a href="#l8.106"></a><span id="l8.106">     }</span>
<a href="#l8.107"></a><span id="l8.107">     finally {    </span>
<a href="#l8.108"></a><span id="l8.108">       this._inCallback = false;</span>
<a href="#l8.109"></a><span id="l8.109">     }</span>
<a href="#l8.110"></a><span id="l8.110">   },</span>
<a href="#l8.111"></a><span id="l8.111"> </span>
<a href="#l8.112"></a><span id="l8.112">   _callbackHandle: {</span>
<a href="#l8.113"></a><span id="l8.113" class="difflineminus">-    _init: function gloda_index_callbackhandle_init() {</span>
<a href="#l8.114"></a><span id="l8.114" class="difflineplus">+    init: function gloda_index_callbackhandle_init() {</span>
<a href="#l8.115"></a><span id="l8.115">       this.wrappedCallback = GlodaIndexer._wrapCallbackDriver;</span>
<a href="#l8.116"></a><span id="l8.116" class="difflineplus">+      this.callbackThis = GlodaIndexer;</span>
<a href="#l8.117"></a><span id="l8.117">       this.callback = GlodaIndexer.callbackDriver;</span>
<a href="#l8.118"></a><span id="l8.118" class="difflineminus">-      </span>
<a href="#l8.119"></a><span id="l8.119">     },</span>
<a href="#l8.120"></a><span id="l8.120">     activeStack: [],</span>
<a href="#l8.121"></a><span id="l8.121">     activeIterator: null,</span>
<a href="#l8.122"></a><span id="l8.122">     push: function gloda_index_callbackhandle_push(aIterator) {</span>
<a href="#l8.123"></a><span id="l8.123">       this.activeStack.push(aIterator);</span>
<a href="#l8.124"></a><span id="l8.124">       this.activeIterator = aIterator;</span>
<a href="#l8.125"></a><span id="l8.125">     },</span>
<a href="#l8.126"></a><span id="l8.126">     pushAndGo: function gloda_index_callbackhandle_pushAndGo(aIterator) {</span>
<a href="#l8.127"></a><span id="l8.127" class="difflineat">@@ -980,76 +983,78 @@ var GlodaIndexer = {</span>
<a href="#l8.128"></a><span id="l8.128">      */</span>
<a href="#l8.129"></a><span id="l8.129">     cleanup: function gloda_index_callbackhandle_cleanup() {</span>
<a href="#l8.130"></a><span id="l8.130">       while (this.activeIterator !== null) {</span>
<a href="#l8.131"></a><span id="l8.131">         this.pop();</span>
<a href="#l8.132"></a><span id="l8.132">       }</span>
<a href="#l8.133"></a><span id="l8.133">     },</span>
<a href="#l8.134"></a><span id="l8.134">     popWithResult: function gloda_index_callbackhandle_popWithResult() {</span>
<a href="#l8.135"></a><span id="l8.135">       this.pop();</span>
<a href="#l8.136"></a><span id="l8.136" class="difflineminus">-      let reslt = this._result;</span>
<a href="#l8.137"></a><span id="l8.137" class="difflineplus">+      let result = this._result;</span>
<a href="#l8.138"></a><span id="l8.138">       this._result = null;</span>
<a href="#l8.139"></a><span id="l8.139">       return result;</span>
<a href="#l8.140"></a><span id="l8.140">     },</span>
<a href="#l8.141"></a><span id="l8.141">     _result: null,</span>
<a href="#l8.142"></a><span id="l8.142">     doneWithResult: function gloda_index_callbackhandle_doneWithResult(aResult){</span>
<a href="#l8.143"></a><span id="l8.143">       this._result = aResult;</span>
<a href="#l8.144"></a><span id="l8.144" class="difflineminus">-      yield Gloda.kWorkDoneWithResult;</span>
<a href="#l8.145"></a><span id="l8.145" class="difflineplus">+      return Gloda.kWorkDoneWithResult;</span>
<a href="#l8.146"></a><span id="l8.146">     },</span>
<a href="#l8.147"></a><span id="l8.147">     </span>
<a href="#l8.148"></a><span id="l8.148">     /* be able to serve as a collection listener, resuming the active iterator's</span>
<a href="#l8.149"></a><span id="l8.149">        last yield kWorkAsync */</span>
<a href="#l8.150"></a><span id="l8.150" class="difflineminus">-    _onItemsAdded: function() {},</span>
<a href="#l8.151"></a><span id="l8.151" class="difflineminus">-    _onItemsModified: function() {},</span>
<a href="#l8.152"></a><span id="l8.152" class="difflineminus">-    _onItemsRemoved: function() {},</span>
<a href="#l8.153"></a><span id="l8.153" class="difflineminus">-    _onQueryCompleted: function(aCollection) {</span>
<a href="#l8.154"></a><span id="l8.154" class="difflineplus">+    onItemsAdded: function() {},</span>
<a href="#l8.155"></a><span id="l8.155" class="difflineplus">+    onItemsModified: function() {},</span>
<a href="#l8.156"></a><span id="l8.156" class="difflineplus">+    onItemsRemoved: function() {},</span>
<a href="#l8.157"></a><span id="l8.157" class="difflineplus">+    onQueryCompleted: function(aCollection) {</span>
<a href="#l8.158"></a><span id="l8.158">       GlodaIndexer.callbackDriver();</span>
<a href="#l8.159"></a><span id="l8.159">     }</span>
<a href="#l8.160"></a><span id="l8.160">   },</span>
<a href="#l8.161"></a><span id="l8.161" class="difflineplus">+  _workBatchData: undefined,</span>
<a href="#l8.162"></a><span id="l8.162">   /**</span>
<a href="#l8.163"></a><span id="l8.163">    * The workBatch generator handles a single 'batch' of processing, managing</span>
<a href="#l8.164"></a><span id="l8.164">    *  the database transaction and keeping track of &quot;tokens&quot;.  It drives the</span>
<a href="#l8.165"></a><span id="l8.165">    *  _actualWorker generator which is doing the work.</span>
<a href="#l8.166"></a><span id="l8.166">    * workBatch will only produce kWorkAsync and kWorkDone notifications.</span>
<a href="#l8.167"></a><span id="l8.167">    *  If _actualWorker returns kWorkSync and there are still tokens available,</span>
<a href="#l8.168"></a><span id="l8.168">    *  workBatch will keep driving _actualWorker until it encounters a</span>
<a href="#l8.169"></a><span id="l8.169">    *  kWorkAsync (which workBatch will yield to callbackDriver), or it runs</span>
<a href="#l8.170"></a><span id="l8.170">    *  out of tokens and yields a kWorkDone. </span>
<a href="#l8.171"></a><span id="l8.171">    */</span>
<a href="#l8.172"></a><span id="l8.172">   workBatch: function gloda_index_workBatch() {</span>
<a href="#l8.173"></a><span id="l8.173">     let commitTokens = this._indexCommitTokens;</span>
<a href="#l8.174"></a><span id="l8.174">     GlodaDatastore._beginTransaction();</span>
<a href="#l8.175"></a><span id="l8.175"> </span>
<a href="#l8.176"></a><span id="l8.176" class="difflineminus">-    let data = undefined;</span>
<a href="#l8.177"></a><span id="l8.177">     while (commitTokens &gt; 0) {</span>
<a href="#l8.178"></a><span id="l8.178">       for (let tokensLeft = this._indexTokens; tokensLeft &gt; 0;</span>
<a href="#l8.179"></a><span id="l8.179">           tokensLeft--, commitTokens--) {</span>
<a href="#l8.180"></a><span id="l8.180">         if ((this._callbackHandle.activeIterator === null) &amp;&amp;</span>
<a href="#l8.181"></a><span id="l8.181">             !this._hireJobWorker()) {</span>
<a href="#l8.182"></a><span id="l8.182">           commitTokens = 0;</span>
<a href="#l8.183"></a><span id="l8.183">           break;</span>
<a href="#l8.184"></a><span id="l8.184">         }</span>
<a href="#l8.185"></a><span id="l8.185">       </span>
<a href="#l8.186"></a><span id="l8.186">         // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l8.187"></a><span id="l8.187">         //  with a quasi-redundant outer loop that shunts control back inside</span>
<a href="#l8.188"></a><span id="l8.188">         //  if we left the loop due to an exception (without consuming all the</span>
<a href="#l8.189"></a><span id="l8.189">         //  tokens.)</span>
<a href="#l8.190"></a><span id="l8.190">         try {</span>
<a href="#l8.191"></a><span id="l8.191" class="difflineminus">-          switch (this._callbackHandler.activeIterator.send(data)) {</span>
<a href="#l8.192"></a><span id="l8.192" class="difflineplus">+          switch (this._callbackHandle.activeIterator.send(this._workBatchData)) {</span>
<a href="#l8.193"></a><span id="l8.193">             case this.kWorkSync:</span>
<a href="#l8.194"></a><span id="l8.194" class="difflineplus">+              this._workBatchData = undefined;</span>
<a href="#l8.195"></a><span id="l8.195">               break;</span>
<a href="#l8.196"></a><span id="l8.196">             case this.kWorkAsync:</span>
<a href="#l8.197"></a><span id="l8.197" class="difflineminus">-              data = yield this.kWorkAsync;</span>
<a href="#l8.198"></a><span id="l8.198" class="difflineplus">+              this._workBatchData = yield this.kWorkAsync;</span>
<a href="#l8.199"></a><span id="l8.199">               break;</span>
<a href="#l8.200"></a><span id="l8.200">             case this.kWorkDone:</span>
<a href="#l8.201"></a><span id="l8.201" class="difflineminus">-              this._callbackHandler.pop();</span>
<a href="#l8.202"></a><span id="l8.202" class="difflineplus">+              this._callbackHandle.pop();</span>
<a href="#l8.203"></a><span id="l8.203" class="difflineplus">+              this._workBatchData = undefined;</span>
<a href="#l8.204"></a><span id="l8.204">               tokensLeft++; // don't eat a token for this pass</span>
<a href="#l8.205"></a><span id="l8.205">               break;</span>
<a href="#l8.206"></a><span id="l8.206">             case this.kWorkDoneWithResult:</span>
<a href="#l8.207"></a><span id="l8.207" class="difflineminus">-              data = this._callbackHandler.popWithResult();</span>
<a href="#l8.208"></a><span id="l8.208" class="difflineplus">+              this._workBatchData = this._callbackHandle.popWithResult();</span>
<a href="#l8.209"></a><span id="l8.209">               tokensLeft++; // don't eat a token for this pass</span>
<a href="#l8.210"></a><span id="l8.210">               continue;</span>
<a href="#l8.211"></a><span id="l8.211">           }</span>
<a href="#l8.212"></a><span id="l8.212">         }</span>
<a href="#l8.213"></a><span id="l8.213">         catch (ex) {</span>
<a href="#l8.214"></a><span id="l8.214">           this._log.debug(&quot;Bailing on job (at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l8.215"></a><span id="l8.215">               ex.lineNumber + &quot;) because: &quot; + ex);</span>
<a href="#l8.216"></a><span id="l8.216">           this._indexerLeaveFolder(true);</span>
<a href="#l8.217"></a><span id="l8.217" class="difflineat">@@ -1119,17 +1124,17 @@ var GlodaIndexer = {</span>
<a href="#l8.218"></a><span id="l8.218">     }</span>
<a href="#l8.219"></a><span id="l8.219">     else if (job.jobType == &quot;delete&quot;) {</span>
<a href="#l8.220"></a><span id="l8.220">       // we'll count the block processing as a cost of 1...</span>
<a href="#l8.221"></a><span id="l8.221">       job.goal = 1;</span>
<a href="#l8.222"></a><span id="l8.222">       generator = this._worker_processDeletes(job);</span>
<a href="#l8.223"></a><span id="l8.223">     }</span>
<a href="#l8.224"></a><span id="l8.224">     else if (job.jobType in this._otherIndexerWorkers) {</span>
<a href="#l8.225"></a><span id="l8.225">       let [indexer, workerFunc] = this._otherIndexerWorkers[job.jobType];</span>
<a href="#l8.226"></a><span id="l8.226" class="difflineminus">-      generator = workerFunc.call(indexer, job);</span>
<a href="#l8.227"></a><span id="l8.227" class="difflineplus">+      generator = workerFunc.call(indexer, job, this._callbackHandle);</span>
<a href="#l8.228"></a><span id="l8.228">     }</span>
<a href="#l8.229"></a><span id="l8.229">     else {</span>
<a href="#l8.230"></a><span id="l8.230">       this._log.warning(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l8.231"></a><span id="l8.231">     }</span>
<a href="#l8.232"></a><span id="l8.232">     </span>
<a href="#l8.233"></a><span id="l8.233">     if (generator) {</span>
<a href="#l8.234"></a><span id="l8.234">       this._callbackHandle.push(generator);</span>
<a href="#l8.235"></a><span id="l8.235">       return true;</span>
<a href="#l8.236"></a><span id="l8.236" class="difflineat">@@ -1310,17 +1315,20 @@ var GlodaIndexer = {</span>
<a href="#l8.237"></a><span id="l8.237">           // (returns 0 when missing)</span>
<a href="#l8.238"></a><span id="l8.238">           let isDirty = msgHdr.getUint32Property(this.GLODA_DIRTY_PROPERTY)!= 0;</span>
<a href="#l8.239"></a><span id="l8.239"> </span>
<a href="#l8.240"></a><span id="l8.240">           // it's up to date if it's not dirty </span>
<a href="#l8.241"></a><span id="l8.241">           if (!isDirty)</span>
<a href="#l8.242"></a><span id="l8.242">             continue;</span>
<a href="#l8.243"></a><span id="l8.243">         }</span>
<a href="#l8.244"></a><span id="l8.244">         </span>
<a href="#l8.245"></a><span id="l8.245" class="difflineminus">-        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr));</span>
<a href="#l8.246"></a><span id="l8.246" class="difflineplus">+        this._log.debug(&quot;&gt;&gt;&gt;  _indexMessage&quot;);</span>
<a href="#l8.247"></a><span id="l8.247" class="difflineplus">+        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l8.248"></a><span id="l8.248" class="difflineplus">+            this._callbackHandle));</span>
<a href="#l8.249"></a><span id="l8.249" class="difflineplus">+        this._log.debug(&quot;&lt;&lt;&lt;  _indexMessage&quot;);</span>
<a href="#l8.250"></a><span id="l8.250">       }</span>
<a href="#l8.251"></a><span id="l8.251">     }</span>
<a href="#l8.252"></a><span id="l8.252">     </span>
<a href="#l8.253"></a><span id="l8.253">     glodaFolder.dirtyStatus = glodaFolder.kFolderClean;</span>
<a href="#l8.254"></a><span id="l8.254">     </span>
<a href="#l8.255"></a><span id="l8.255">     // by definition, it's not likely we'll visit this folder again anytime soon</span>
<a href="#l8.256"></a><span id="l8.256">     this._indexerLeaveFolder();</span>
<a href="#l8.257"></a><span id="l8.257">     </span>
<a href="#l8.258"></a><span id="l8.258" class="difflineat">@@ -1345,17 +1353,18 @@ var GlodaIndexer = {</span>
<a href="#l8.259"></a><span id="l8.259">       if (typeof item[1] == &quot;number&quot;)</span>
<a href="#l8.260"></a><span id="l8.260">         msgHdr = this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l8.261"></a><span id="l8.261">       else</span>
<a href="#l8.262"></a><span id="l8.262">         // same deal as in move processing.</span>
<a href="#l8.263"></a><span id="l8.263">         // TODO fixme to not assume singular message-id's.</span>
<a href="#l8.264"></a><span id="l8.264">         msgHdr = this._indexingDatabase.getMsgHdrForMessageID(item[1]);</span>
<a href="#l8.265"></a><span id="l8.265">       </span>
<a href="#l8.266"></a><span id="l8.266">       if (msgHdr &amp;&amp; !(msgHdr.flags&amp;MSG_FLAG_EXPUNGED))</span>
<a href="#l8.267"></a><span id="l8.267" class="difflineminus">-        yield this._indexMessage(msgHdr);</span>
<a href="#l8.268"></a><span id="l8.268" class="difflineplus">+        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l8.269"></a><span id="l8.269" class="difflineplus">+            this._callbackHandle));</span>
<a href="#l8.270"></a><span id="l8.270">       else</span>
<a href="#l8.271"></a><span id="l8.271">         yield this.kWorkSync;</span>
<a href="#l8.272"></a><span id="l8.272">     }</span>
<a href="#l8.273"></a><span id="l8.273">     yield this.kWorkDone;</span>
<a href="#l8.274"></a><span id="l8.274">   },</span>
<a href="#l8.275"></a><span id="l8.275">   </span>
<a href="#l8.276"></a><span id="l8.276">   /**</span>
<a href="#l8.277"></a><span id="l8.277">    * Process pending deletes...</span>
<a href="#l8.278"></a><span id="l8.278" class="difflineat">@@ -1424,16 +1433,24 @@ var GlodaIndexer = {</span>
<a href="#l8.279"></a><span id="l8.279">       this._indexQueue = this._indexQueue.concat(folderJobs);</span>
<a href="#l8.280"></a><span id="l8.280">       this.indexing = true;</span>
<a href="#l8.281"></a><span id="l8.281">     }</span>
<a href="#l8.282"></a><span id="l8.282">     else {</span>
<a href="#l8.283"></a><span id="l8.283">       this._log.info(&quot;Skipping Account, root folder not nsIMsgFolder&quot;);</span>
<a href="#l8.284"></a><span id="l8.284">     }</span>
<a href="#l8.285"></a><span id="l8.285">   },</span>
<a href="#l8.286"></a><span id="l8.286"> </span>
<a href="#l8.287"></a><span id="l8.287" class="difflineplus">+  indexJob: function glodaIndexJob(aJob) {</span>
<a href="#l8.288"></a><span id="l8.288" class="difflineplus">+    this._log.info(&quot;Queue-ing job for indexing: &quot; + aJob.jobType);</span>
<a href="#l8.289"></a><span id="l8.289" class="difflineplus">+    </span>
<a href="#l8.290"></a><span id="l8.290" class="difflineplus">+    this._indexQueue.push(aJob);</span>
<a href="#l8.291"></a><span id="l8.291" class="difflineplus">+    this._indexingJobGoal++;</span>
<a href="#l8.292"></a><span id="l8.292" class="difflineplus">+    this.indexing = true;</span>
<a href="#l8.293"></a><span id="l8.293" class="difflineplus">+  },</span>
<a href="#l8.294"></a><span id="l8.294" class="difflineplus">+  </span>
<a href="#l8.295"></a><span id="l8.295">   /**</span>
<a href="#l8.296"></a><span id="l8.296">    * Queue a single folder for indexing given an nsIMsgFolder.</span>
<a href="#l8.297"></a><span id="l8.297">    */</span>
<a href="#l8.298"></a><span id="l8.298">   indexFolder: function glodaIndexFolder(aFolder) {</span>
<a href="#l8.299"></a><span id="l8.299">     this._log.info(&quot;Queue-ing folder for indexing: &quot; + aFolder.prettiestName);</span>
<a href="#l8.300"></a><span id="l8.300">     </span>
<a href="#l8.301"></a><span id="l8.301">     this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l8.302"></a><span id="l8.302">                           GlodaDatastore._mapFolder(aFolder).id));</span>
<a href="#l8.303"></a><span id="l8.303" class="difflineat">@@ -1969,18 +1986,19 @@ var GlodaIndexer = {</span>
<a href="#l8.304"></a><span id="l8.304">     getCurrentTaskName: function gloda_indexer_getCurrentTaskName() {</span>
<a href="#l8.305"></a><span id="l8.305">       return &quot;Global Database Indexer&quot;; // L10n-me</span>
<a href="#l8.306"></a><span id="l8.306">     },</span>
<a href="#l8.307"></a><span id="l8.307">   }, </span>
<a href="#l8.308"></a><span id="l8.308">   </span>
<a href="#l8.309"></a><span id="l8.309">   _indexMessage: function gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l8.310"></a><span id="l8.310">     this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l8.311"></a><span id="l8.311">                     aMsgHdr.subject);</span>
<a href="#l8.312"></a><span id="l8.312" class="difflineminus">-    MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle, aCallbackHandle.callback);</span>
<a href="#l8.313"></a><span id="l8.313" class="difflineminus">-    let aMimeMsg = yield this.kWorkAsync;</span>
<a href="#l8.314"></a><span id="l8.314" class="difflineplus">+    MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l8.315"></a><span id="l8.315" class="difflineplus">+        aCallbackHandle.callback);</span>
<a href="#l8.316"></a><span id="l8.316" class="difflineplus">+    let [,aMimeMsg] = yield this.kWorkAsync;</span>
<a href="#l8.317"></a><span id="l8.317"> </span>
<a href="#l8.318"></a><span id="l8.318">     if (aMimeMsg)</span>
<a href="#l8.319"></a><span id="l8.319">       this._log.debug(&quot;  * Got Body! Length: &quot; + aMimeMsg.body.length);</span>
<a href="#l8.320"></a><span id="l8.320">     else</span>
<a href="#l8.321"></a><span id="l8.321">       this._log.debug(&quot;  * Did not get body!&quot;);</span>
<a href="#l8.322"></a><span id="l8.322"> </span>
<a href="#l8.323"></a><span id="l8.323">     // -- Find/create the conversation the message belongs to.</span>
<a href="#l8.324"></a><span id="l8.324">     // Our invariant is that all messages that exist in the database belong to</span>
<a href="#l8.325"></a><span id="l8.325" class="difflineat">@@ -1989,19 +2007,24 @@ var GlodaIndexer = {</span>
<a href="#l8.326"></a><span id="l8.326">     // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l8.327"></a><span id="l8.327">     // (references are ordered from old [0] to new [n-1])</span>
<a href="#l8.328"></a><span id="l8.328">     let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l8.329"></a><span id="l8.329">                       (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l8.330"></a><span id="l8.330">     // also see if we already know about the message...</span>
<a href="#l8.331"></a><span id="l8.331">     references.push(aMsgHdr.messageId);</span>
<a href="#l8.332"></a><span id="l8.332">     </span>
<a href="#l8.333"></a><span id="l8.333">     this._datastore.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l8.334"></a><span id="l8.334" class="difflineminus">-      aCallbackHandle);</span>
<a href="#l8.335"></a><span id="l8.335" class="difflineplus">+      aCallbackHandle.callbackThis);</span>
<a href="#l8.336"></a><span id="l8.336">     // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l8.337"></a><span id="l8.337" class="difflineminus">-    let ancestorLists = yield kWorkAsync; </span>
<a href="#l8.338"></a><span id="l8.338" class="difflineplus">+    let ancestorLists = yield this.kWorkAsync; </span>
<a href="#l8.339"></a><span id="l8.339" class="difflineplus">+    </span>
<a href="#l8.340"></a><span id="l8.340" class="difflineplus">+    this._log.debug(&quot;ancestors raw: &quot; + ancestorLists);</span>
<a href="#l8.341"></a><span id="l8.341" class="difflineplus">+    this._log.debug(&quot;ref len: &quot; + references.length + &quot; anc len: &quot; + ancestorLists.length);</span>
<a href="#l8.342"></a><span id="l8.342" class="difflineplus">+    this._log.debug(&quot;references: &quot; + Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l8.343"></a><span id="l8.343" class="difflineplus">+    this._log.debug(&quot;ancestors: &quot; + Log4Moz.enumerateProperties(ancestorLists).join(&quot;,&quot;));</span>
<a href="#l8.344"></a><span id="l8.344">     </span>
<a href="#l8.345"></a><span id="l8.345">     // pull our current message lookup results off</span>
<a href="#l8.346"></a><span id="l8.346">     references.pop();</span>
<a href="#l8.347"></a><span id="l8.347">     let candidateCurMsgs = ancestorLists.pop();</span>
<a href="#l8.348"></a><span id="l8.348">     </span>
<a href="#l8.349"></a><span id="l8.349">     let conversationID = null;</span>
<a href="#l8.350"></a><span id="l8.350">     // -- figure out the conversation ID</span>
<a href="#l8.351"></a><span id="l8.351">     // if we have a clone/already exist, just use his conversation ID</span>
<a href="#l8.352"></a><span id="l8.352" class="difflineat">@@ -2114,46 +2137,48 @@ var GlodaIndexer = {</span>
<a href="#l8.353"></a><span id="l8.353">     let isNew;</span>
<a href="#l8.354"></a><span id="l8.354">     if (curMsg === null) {</span>
<a href="#l8.355"></a><span id="l8.355">       this._log.debug(&quot;...creating new message.  body length: &quot; +</span>
<a href="#l8.356"></a><span id="l8.356">                       (aMimeMsg ? aMimeMsg.body.length : null));</span>
<a href="#l8.357"></a><span id="l8.357">       curMsg = this._datastore.createMessage(aMsgHdr.folder,</span>
<a href="#l8.358"></a><span id="l8.358">                                              aMsgHdr.messageKey,                </span>
<a href="#l8.359"></a><span id="l8.359">                                              conversationID,</span>
<a href="#l8.360"></a><span id="l8.360">                                              aMsgHdr.date,</span>
<a href="#l8.361"></a><span id="l8.361" class="difflineminus">-                                             aMsgHdr.messageId,</span>
<a href="#l8.362"></a><span id="l8.362" class="difflineminus">-                                             aMsgHdr.subject,</span>
<a href="#l8.363"></a><span id="l8.363" class="difflineminus">-                                             aMimeMsg ? aMimeMsg.body : null,</span>
<a href="#l8.364"></a><span id="l8.364" class="difflineminus">-                                             attachmentNames);</span>
<a href="#l8.365"></a><span id="l8.365" class="difflineplus">+                                             aMsgHdr.messageId);</span>
<a href="#l8.366"></a><span id="l8.366" class="difflineplus">+      curMsg._conversation = conversation;</span>
<a href="#l8.367"></a><span id="l8.367">       isNew = true;</span>
<a href="#l8.368"></a><span id="l8.368">     }</span>
<a href="#l8.369"></a><span id="l8.369">     else {</span>
<a href="#l8.370"></a><span id="l8.370">       isNew = (curMsg._folderID === null); // aka was-a-ghost</span>
<a href="#l8.371"></a><span id="l8.371">       // (messageKey can be null if it's not new in the move-case)</span>
<a href="#l8.372"></a><span id="l8.372">       curMsg._folderID = this._datastore._mapFolder(aMsgHdr.folder).id;</span>
<a href="#l8.373"></a><span id="l8.373">       curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l8.374"></a><span id="l8.374">       curMsg.date = new Date(aMsgHdr.date / 1000); </span>
<a href="#l8.375"></a><span id="l8.375">       // note: we are assuming that our matching logic is flawless in that</span>
<a href="#l8.376"></a><span id="l8.376">       //  if this message was not a ghost, we are assuming the 'body'</span>
<a href="#l8.377"></a><span id="l8.377">       //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l8.378"></a><span id="l8.378">       //  that there are cases where this is not true.</span>
<a href="#l8.379"></a><span id="l8.379" class="difflineminus">-      this._datastore.updateMessage(curMsg, isNew ? aMsgHdr.subject : null,</span>
<a href="#l8.380"></a><span id="l8.380" class="difflineminus">-        (isNew &amp;&amp; aMimeMsg) ? aMimeMsg.body : null,</span>
<a href="#l8.381"></a><span id="l8.381" class="difflineminus">-        isNew ? attachmentNames : null);</span>
<a href="#l8.382"></a><span id="l8.382">     }</span>
<a href="#l8.383"></a><span id="l8.383">     </span>
<a href="#l8.384"></a><span id="l8.384" class="difflineminus">-    yield aCallbackHandle.pushAndGo(&quot;Process Message Attributes&quot;,</span>
<a href="#l8.385"></a><span id="l8.385" class="difflineminus">-      Gloda.grokNounItem(curMsg, {header: aMsgHdr, mime: aMimeMsg}, isNew));</span>
<a href="#l8.386"></a><span id="l8.386" class="difflineplus">+    if (isNew) {</span>
<a href="#l8.387"></a><span id="l8.387" class="difflineplus">+      curMsg._subject = aMsgHdr.subject;</span>
<a href="#l8.388"></a><span id="l8.388" class="difflineplus">+      curMsg._body = aMimeMsg.body;</span>
<a href="#l8.389"></a><span id="l8.389" class="difflineplus">+      curMsg._attachmentNames = attachmentNames;</span>
<a href="#l8.390"></a><span id="l8.390" class="difflineplus">+    }</span>
<a href="#l8.391"></a><span id="l8.391" class="difflineplus">+    </span>
<a href="#l8.392"></a><span id="l8.392" class="difflineplus">+    yield aCallbackHandle.pushAndGo(</span>
<a href="#l8.393"></a><span id="l8.393" class="difflineplus">+        Gloda.grokNounItem(curMsg, {header: aMsgHdr, mime: aMimeMsg}, isNew,</span>
<a href="#l8.394"></a><span id="l8.394" class="difflineplus">+            aCallbackHandle));</span>
<a href="#l8.395"></a><span id="l8.395">     </span>
<a href="#l8.396"></a><span id="l8.396">     // we want to update the header for messages only after the transaction</span>
<a href="#l8.397"></a><span id="l8.397">     //  irrevocably hits the disk.  otherwise we could get confused if the</span>
<a href="#l8.398"></a><span id="l8.398">     //  transaction rolls back or what not.</span>
<a href="#l8.399"></a><span id="l8.399" class="difflineminus">-    GlodaDatastore.runPostCommit(MakeCleanMsgHdrCallback(aMsgHdr));</span>
<a href="#l8.400"></a><span id="l8.400" class="difflineplus">+    GlodaDatastore.runPostCommit(MakeCleanMsgHdrCallback(aMsgHdr, curMsg.id));</span>
<a href="#l8.401"></a><span id="l8.401">     </span>
<a href="#l8.402"></a><span id="l8.402" class="difflineminus">-    this.callbackDriver();</span>
<a href="#l8.403"></a><span id="l8.403" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l8.404"></a><span id="l8.404">   },</span>
<a href="#l8.405"></a><span id="l8.405">   </span>
<a href="#l8.406"></a><span id="l8.406">   /**</span>
<a href="#l8.407"></a><span id="l8.407">    * Wipe a message out of existence from our index.  This is slightly more</span>
<a href="#l8.408"></a><span id="l8.408">    *  tricky than one would first expect because there are potentially</span>
<a href="#l8.409"></a><span id="l8.409">    *  attributes not immediately associated with this message that reference</span>
<a href="#l8.410"></a><span id="l8.410">    *  the message.  Not only that, but deletion of messages may leave a</span>
<a href="#l8.411"></a><span id="l8.411">    *  conversation posessing only ghost messages, which we don't want, so we</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/modules/query.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/modules/query.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -339,17 +339,17 @@ GlodaWildcardQueryClass.prototype = {</span>
<a href="#l9.4"></a><span id="l9.4">  *  this allows us to add per-noun helpers.  For the others, this is merely a</span>
<a href="#l9.5"></a><span id="l9.5">  *  means of allowing us to attach the (per-noun) nounDef to the 'class'.</span>
<a href="#l9.6"></a><span id="l9.6">  */</span>
<a href="#l9.7"></a><span id="l9.7"> function GlodaQueryClassFactory(aNounDef) {</span>
<a href="#l9.8"></a><span id="l9.8">   let newQueryClass = function() {</span>
<a href="#l9.9"></a><span id="l9.9">     GlodaQueryClass.call(this);</span>
<a href="#l9.10"></a><span id="l9.10">   }; </span>
<a href="#l9.11"></a><span id="l9.11">   </span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-  newQueryClass.prototype = new GlodaQueryClass;</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+  newQueryClass.prototype = new GlodaQueryClass();</span>
<a href="#l9.14"></a><span id="l9.14">   newQueryClass.prototype._queryClass = newQueryClass;</span>
<a href="#l9.15"></a><span id="l9.15">   newQueryClass.prototype._nounDef = aNounDef;</span>
<a href="#l9.16"></a><span id="l9.16">   </span>
<a href="#l9.17"></a><span id="l9.17">   let newExplicitClass = function(aCollection) {</span>
<a href="#l9.18"></a><span id="l9.18">     GlodaExplicitQueryClass.call(this);</span>
<a href="#l9.19"></a><span id="l9.19">     this.collection = aCollection;</span>
<a href="#l9.20"></a><span id="l9.20">   };</span>
<a href="#l9.21"></a><span id="l9.21">   newExplicitClass.prototype = new GlodaExplicitQueryClass();</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineat">@@ -357,12 +357,12 @@ function GlodaQueryClassFactory(aNounDef</span>
<a href="#l9.23"></a><span id="l9.23">   newExplicitClass.prototype._nounDef = aNounDef;</span>
<a href="#l9.24"></a><span id="l9.24"> </span>
<a href="#l9.25"></a><span id="l9.25">   let newWildcardClass = function(aCollection) {</span>
<a href="#l9.26"></a><span id="l9.26">     GlodaWildcardQueryClass.call(this);</span>
<a href="#l9.27"></a><span id="l9.27">     this.collection = aCollection;</span>
<a href="#l9.28"></a><span id="l9.28">   };</span>
<a href="#l9.29"></a><span id="l9.29">   newWildcardClass.prototype = new GlodaWildcardQueryClass();</span>
<a href="#l9.30"></a><span id="l9.30">   newWildcardClass.prototype._queryClass = newWildcardClass;</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineminus">-  newWildcardClass.prototype._nounDef = aNounDefww;</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+  newWildcardClass.prototype._nounDef = aNounDef;</span>
<a href="#l9.33"></a><span id="l9.33">   </span>
<a href="#l9.34"></a><span id="l9.34">   return [newQueryClass, newExplicitClass, newWildcardClass];</span>
<a href="#l9.35"></a><span id="l9.35"> }</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

