<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 10469:0401e822b882080904cd31ab5b4524195ca0967b</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 0401e822b882080904cd31ab5b4524195ca0967b" />
<meta property="og:url" content="/comm-central/rev/0401e822b882080904cd31ab5b4524195ca0967b" />
<meta property="og:description" content="Bug 740453: Investigate download whole message vs. download in chunks,r=bienvenu" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 0401e822b882080904cd31ab5b4524195ca0967b 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/0401e822b882080904cd31ab5b4524195ca0967b">shortlog</a> |
<a href="/comm-central/log/0401e822b882080904cd31ab5b4524195ca0967b">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/0401e822b882080904cd31ab5b4524195ca0967b">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/0401e822b882080904cd31ab5b4524195ca0967b">files</a> |
changeset |
<a href="/comm-central/raw-rev/0401e822b882080904cd31ab5b4524195ca0967b">raw</a>  | <a href="/comm-central/archive/0401e822b882080904cd31ab5b4524195ca0967b.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=740453">Bug 740453</a>: Investigate download whole message vs. download in chunks,r=bienvenu
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#73;&#114;&#118;&#105;&#110;&#103;&#32;&#82;&#101;&#105;&#100;&#32;&#60;&#105;&#114;&#118;&#105;&#110;&#103;&#64;&#109;&#111;&#122;&#105;&#108;&#108;&#97;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 19 Jun 2012 09:00:03 -0700</td></tr>

<tr>
 <td>changeset 10469</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/0401e822b882080904cd31ab5b4524195ca0967b">0401e822b882080904cd31ab5b4524195ca0967b</a></td>
</tr>



<tr>
<td>parent 10468</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/5a6bee21734011d67e9b51162cf8e208f0d61f17">5a6bee21734011d67e9b51162cf8e208f0d61f17</a>
</td>
</tr>

<tr>
<td>child 10470</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/13c4be7e7d31a7c09afeb6a2290d7765bc730487">13c4be7e7d31a7c09afeb6a2290d7765bc730487</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=0401e822b882080904cd31ab5b4524195ca0967b">7918</a></td></tr>
<tr><td>push user</td><td>bienvenu@nventure.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 19 Jun 2012 16:01:25 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@0401e822b882 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=0401e822b882080904cd31ab5b4524195ca0967b">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=0401e822b882080904cd31ab5b4524195ca0967b&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=0401e822b882080904cd31ab5b4524195ca0967b&newProject=comm-central&newRevision=0401e822b882080904cd31ab5b4524195ca0967b&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=0401e822b882080904cd31ab5b4524195ca0967b&newProject=comm-central&newRevision=0401e822b882080904cd31ab5b4524195ca0967b&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=0401e822b882080904cd31ab5b4524195ca0967b&newProject=comm-central&newRevision=0401e822b882080904cd31ab5b4524195ca0967b&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28bienvenu%29&revcount=50">bienvenu</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=740453">740453</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=740453">Bug 740453</a>: Investigate download whole message vs. download in chunks,r=bienvenu
* * *
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=740453">Bug 740453</a> part two - try to remove the size parameter from ParseAdoptedMsgLine</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/public/nsIImapMessageSink.idl">mailnews/imap/public/nsIImapMessageSink.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/public/nsIImapMessageSink.idl">file</a> |
<a href="/comm-central/annotate/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/public/nsIImapMessageSink.idl">annotate</a> |
<a href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/public/nsIImapMessageSink.idl">diff</a> |
<a href="/comm-central/comparison/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/public/nsIImapMessageSink.idl">comparison</a> |
<a href="/comm-central/log/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/public/nsIImapMessageSink.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapMailFolder.cpp">mailnews/imap/src/nsImapMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.cpp">mailnews/imap/src/nsImapProtocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.cpp">file</a> |
<a href="/comm-central/annotate/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.cpp">annotate</a> |
<a href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.cpp">diff</a> |
<a href="/comm-central/comparison/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.cpp">comparison</a> |
<a href="/comm-central/log/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.h">mailnews/imap/src/nsImapProtocol.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.h">file</a> |
<a href="/comm-central/annotate/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.h">annotate</a> |
<a href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.h">diff</a> |
<a href="/comm-central/comparison/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.h">comparison</a> |
<a href="/comm-central/log/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapProtocol.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.cpp">mailnews/imap/src/nsImapServerResponseParser.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.cpp">file</a> |
<a href="/comm-central/annotate/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.cpp">annotate</a> |
<a href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.cpp">diff</a> |
<a href="/comm-central/comparison/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.cpp">comparison</a> |
<a href="/comm-central/log/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.h">mailnews/imap/src/nsImapServerResponseParser.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.h">file</a> |
<a href="/comm-central/annotate/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.h">annotate</a> |
<a href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.h">diff</a> |
<a href="/comm-central/comparison/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.h">comparison</a> |
<a href="/comm-central/log/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsImapServerResponseParser.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsSyncRunnableHelpers.cpp">mailnews/imap/src/nsSyncRunnableHelpers.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsSyncRunnableHelpers.cpp">file</a> |
<a href="/comm-central/annotate/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsSyncRunnableHelpers.cpp">annotate</a> |
<a href="/comm-central/diff/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsSyncRunnableHelpers.cpp">diff</a> |
<a href="/comm-central/comparison/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsSyncRunnableHelpers.cpp">comparison</a> |
<a href="/comm-central/log/0401e822b882080904cd31ab5b4524195ca0967b/mailnews/imap/src/nsSyncRunnableHelpers.cpp">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/imap/public/nsIImapMessageSink.idl</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/imap/public/nsIImapMessageSink.idl</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -17,24 +17,34 @@ interface nsIImapMessageSink : nsISuppor</span>
<a href="#l1.4"></a><span id="l1.4"> </span>
<a href="#l1.5"></a><span id="l1.5">   /**</span>
<a href="#l1.6"></a><span id="l1.6">    * Used by the imap protocol code to notify the core backend code about</span>
<a href="#l1.7"></a><span id="l1.7">    * downloaded imap messages.</span>
<a href="#l1.8"></a><span id="l1.8">    *</span>
<a href="#l1.9"></a><span id="l1.9">    * @param aAdoptedMsgLine  a string with a lot of message lines,</span>
<a href="#l1.10"></a><span id="l1.10">    *                         separated by native line terminators.</span>
<a href="#l1.11"></a><span id="l1.11">    * @param aUidOfMsg        IMAP UID of the fetched message.</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-   * @param aSizeOfMsg       RFC822.Size of the fetched message</span>
<a href="#l1.13"></a><span id="l1.13">    * @param aImapUrl         IMAP Url used to fetch the message.</span>
<a href="#l1.14"></a><span id="l1.14">    */</span>
<a href="#l1.15"></a><span id="l1.15">   void parseAdoptedMsgLine(in string aAdoptedMsgLine, in nsMsgKey aUidOfMsg,</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineminus">-                           in long aSizeOfMsg, in nsIImapUrl aImapUrl);</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+                           in nsIImapUrl aImapUrl);</span>
<a href="#l1.18"></a><span id="l1.18"> </span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+  /**</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+   * Notify the backend that the imap protocol is done downloading a message</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+   *</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineplus">+   * @param aUidOfMsg           IMAP UID of the fetched message.</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+   * @param aMarkMsgRead        Set the SEEN flag on the message.</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+   * @param aImapUrl            IMAP Url used to fetch the message.</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+   * @param aUpdatedMessageSize if this parameter is not -1, the stored size of the message</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+   *                            should be set to this value to reflect the actual size of</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+   *                            the downloaded message.</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineplus">+   */</span>
<a href="#l1.29"></a><span id="l1.29">   void normalEndMsgWriteStream(in nsMsgKey aUidOfMessage,</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineminus">-                               in boolean aMarkMsgRead, in nsIImapUrl aImapUrl);</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+                               in boolean aMarkMsgRead, in nsIImapUrl aImapUrl,</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+                               in long aUpdatedMessageSize);</span>
<a href="#l1.33"></a><span id="l1.33"> </span>
<a href="#l1.34"></a><span id="l1.34">   void abortMsgWriteStream();</span>
<a href="#l1.35"></a><span id="l1.35"> </span>
<a href="#l1.36"></a><span id="l1.36">   void beginMessageUpload();</span>
<a href="#l1.37"></a><span id="l1.37"> </span>
<a href="#l1.38"></a><span id="l1.38">   /**</span>
<a href="#l1.39"></a><span id="l1.39">    *  Notify the message sink that one or more flags have changed</span>
<a href="#l1.40"></a><span id="l1.40">    *  For Condstore servers, also update the highestMod Sequence</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -4539,31 +4539,29 @@ NS_IMETHODIMP nsImapMailFolder::Download</span>
<a href="#l2.4"></a><span id="l2.4">   else</span>
<a href="#l2.5"></a><span id="l2.5">     rv = NS_MSG_FOLDER_UNREADABLE;</span>
<a href="#l2.6"></a><span id="l2.6">   return rv;</span>
<a href="#l2.7"></a><span id="l2.7"> }</span>
<a href="#l2.8"></a><span id="l2.8"> </span>
<a href="#l2.9"></a><span id="l2.9"> NS_IMETHODIMP</span>
<a href="#l2.10"></a><span id="l2.10"> nsImapMailFolder::ParseAdoptedMsgLine(const char *adoptedMessageLine,</span>
<a href="#l2.11"></a><span id="l2.11">                                       nsMsgKey uidOfMessage,</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-                                      PRInt32 aMsgSize,</span>
<a href="#l2.13"></a><span id="l2.13">                                       nsIImapUrl *aImapUrl)</span>
<a href="#l2.14"></a><span id="l2.14"> {</span>
<a href="#l2.15"></a><span id="l2.15">   NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l2.16"></a><span id="l2.16">   PRUint32 count = 0;</span>
<a href="#l2.17"></a><span id="l2.17">   nsresult rv;</span>
<a href="#l2.18"></a><span id="l2.18">   // remember the uid of the message we're downloading.</span>
<a href="#l2.19"></a><span id="l2.19">   m_curMsgUid = uidOfMessage;</span>
<a href="#l2.20"></a><span id="l2.20">   if (!m_offlineHeader)</span>
<a href="#l2.21"></a><span id="l2.21">   {</span>
<a href="#l2.22"></a><span id="l2.22">     rv = GetMessageHeader(uidOfMessage, getter_AddRefs(m_offlineHeader));</span>
<a href="#l2.23"></a><span id="l2.23">     if (NS_SUCCEEDED(rv) &amp;&amp; !m_offlineHeader)</span>
<a href="#l2.24"></a><span id="l2.24">       rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l2.25"></a><span id="l2.25">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineminus">-    m_offlineHeader-&gt;SetMessageSize(aMsgSize);</span>
<a href="#l2.27"></a><span id="l2.27">     rv = StartNewOfflineMessage();</span>
<a href="#l2.28"></a><span id="l2.28">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l2.29"></a><span id="l2.29">   }</span>
<a href="#l2.30"></a><span id="l2.30">   // adoptedMessageLine is actually a string with a lot of message lines, separated by native line terminators</span>
<a href="#l2.31"></a><span id="l2.31">   // we need to count the number of MSG_LINEBREAK's to determine how much to increment m_numOfflineMsgLines by.</span>
<a href="#l2.32"></a><span id="l2.32">   const char *nextLine = adoptedMessageLine;</span>
<a href="#l2.33"></a><span id="l2.33">   do</span>
<a href="#l2.34"></a><span id="l2.34">   {</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineat">@@ -4597,20 +4595,42 @@ void nsImapMailFolder::EndOfflineDownloa</span>
<a href="#l2.36"></a><span id="l2.36">       mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l2.37"></a><span id="l2.37">   }</span>
<a href="#l2.38"></a><span id="l2.38">   m_offlineHeader = nsnull;</span>
<a href="#l2.39"></a><span id="l2.39"> }</span>
<a href="#l2.40"></a><span id="l2.40"> </span>
<a href="#l2.41"></a><span id="l2.41"> NS_IMETHODIMP</span>
<a href="#l2.42"></a><span id="l2.42"> nsImapMailFolder::NormalEndMsgWriteStream(nsMsgKey uidOfMessage,</span>
<a href="#l2.43"></a><span id="l2.43">                                           bool markRead,</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineminus">-                                          nsIImapUrl *imapUrl)</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineminus">-{</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+                                          nsIImapUrl *imapUrl,</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+                                          PRInt32 updatedMessageSize)</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+{</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+  if (updatedMessageSize != -1) {</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+    // retrieve the message header to update size, if we don't already have it</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHeader = m_offlineHeader;</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+    if (!msgHeader)</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+      GetMessageHeader(uidOfMessage, getter_AddRefs(msgHeader));</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+    if (msgHeader) {</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+      PRUint32 msgSize;</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+      msgHeader-&gt;GetMessageSize(&amp;msgSize);</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+      PR_LOG(IMAP, PR_LOG_DEBUG, (&quot;Updating stored message size from %u, new size %d&quot;,</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+                                  msgSize, updatedMessageSize));</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+      msgHeader-&gt;SetMessageSize(updatedMessageSize);</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+      // only commit here if this isn't an offline message</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+      // offline header gets committed in EndNewOfflineMessage() called below</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+      if (mDatabase &amp;&amp; !m_offlineHeader)</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+        mDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+    }</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+    else</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineplus">+      NS_WARNING(&quot;Failed to get message header when trying to update message size&quot;);</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+  }</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+</span>
<a href="#l2.69"></a><span id="l2.69">   if (m_offlineHeader)</span>
<a href="#l2.70"></a><span id="l2.70">     EndNewOfflineMessage();</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+</span>
<a href="#l2.72"></a><span id="l2.72">   m_curMsgUid = uidOfMessage;</span>
<a href="#l2.73"></a><span id="l2.73"> </span>
<a href="#l2.74"></a><span id="l2.74">   // Apply filter now if it needed a body</span>
<a href="#l2.75"></a><span id="l2.75">   if (m_filterListRequiresBody)</span>
<a href="#l2.76"></a><span id="l2.76">   {</span>
<a href="#l2.77"></a><span id="l2.77">     if (m_filterList)</span>
<a href="#l2.78"></a><span id="l2.78">     {</span>
<a href="#l2.79"></a><span id="l2.79">       nsCOMPtr&lt;nsIMsgDBHdr&gt; newMsgHdr;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -341,25 +341,25 @@ nsresult nsImapProtocol::GlobalInitializ</span>
<a href="#l3.4"></a><span id="l3.4">       appInfo-&gt;GetVersion(appVersion);</span>
<a href="#l3.5"></a><span id="l3.5">       PL_strncpyz(gAppName, appName.get(), kAppBufSize);</span>
<a href="#l3.6"></a><span id="l3.6">       PL_strncpyz(gAppVersion, appVersion.get(), kAppBufSize);</span>
<a href="#l3.7"></a><span id="l3.7">     }</span>
<a href="#l3.8"></a><span id="l3.8">     return NS_OK;</span>
<a href="#l3.9"></a><span id="l3.9"> }</span>
<a href="#l3.10"></a><span id="l3.10"> </span>
<a href="#l3.11"></a><span id="l3.11"> nsImapProtocol::nsImapProtocol() : nsMsgProtocol(nsnull),</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-    mLock(&quot;nsImapProtocol.mLock&quot;),</span>
<a href="#l3.13"></a><span id="l3.13">     m_dataAvailableMonitor(&quot;imapDataAvailable&quot;),</span>
<a href="#l3.14"></a><span id="l3.14">     m_urlReadyToRunMonitor(&quot;imapUrlReadyToRun&quot;),</span>
<a href="#l3.15"></a><span id="l3.15">     m_pseudoInterruptMonitor(&quot;imapPseudoInterrupt&quot;),</span>
<a href="#l3.16"></a><span id="l3.16">     m_dataMemberMonitor(&quot;imapDataMember&quot;),</span>
<a href="#l3.17"></a><span id="l3.17">     m_threadDeathMonitor(&quot;imapThreadDeath&quot;),</span>
<a href="#l3.18"></a><span id="l3.18">     m_waitForBodyIdsMonitor(&quot;imapWaitForBodyIds&quot;),</span>
<a href="#l3.19"></a><span id="l3.19">     m_fetchBodyListMonitor(&quot;imapFetchBodyList&quot;),</span>
<a href="#l3.20"></a><span id="l3.20">     m_passwordReadyMonitor(&quot;imapPasswordReady&quot;),</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+    mLock(&quot;nsImapProtocol.mLock&quot;),</span>
<a href="#l3.22"></a><span id="l3.22">     m_parser(*this)</span>
<a href="#l3.23"></a><span id="l3.23"> {</span>
<a href="#l3.24"></a><span id="l3.24">   m_urlInProgress = false;</span>
<a href="#l3.25"></a><span id="l3.25">   m_idle = false;</span>
<a href="#l3.26"></a><span id="l3.26">   m_retryUrlOnError = false;</span>
<a href="#l3.27"></a><span id="l3.27">   m_useIdle = true; // by default, use it</span>
<a href="#l3.28"></a><span id="l3.28">   m_useCondStore = true;</span>
<a href="#l3.29"></a><span id="l3.29">   m_useCompressDeflate = true;</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineat">@@ -1702,17 +1702,17 @@ bool nsImapProtocol::ProcessCurrentURL()</span>
<a href="#l3.31"></a><span id="l3.31">       FindMailboxesIfNecessary();</span>
<a href="#l3.32"></a><span id="l3.32"> </span>
<a href="#l3.33"></a><span id="l3.33">     nsImapState imapState;</span>
<a href="#l3.34"></a><span id="l3.34">     if (m_runningUrl)</span>
<a href="#l3.35"></a><span id="l3.35">       m_runningUrl-&gt;GetRequiredImapState(&amp;imapState);</span>
<a href="#l3.36"></a><span id="l3.36"> </span>
<a href="#l3.37"></a><span id="l3.37">     if (imapState == nsIImapUrl::nsImapAuthenticatedState)</span>
<a href="#l3.38"></a><span id="l3.38">       ProcessAuthenticatedStateURL();</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineminus">-    else   // must be a url that requires us to be in the selected stae</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+    else   // must be a url that requires us to be in the selected state</span>
<a href="#l3.41"></a><span id="l3.41">       ProcessSelectedStateURL();</span>
<a href="#l3.42"></a><span id="l3.42"> </span>
<a href="#l3.43"></a><span id="l3.43">     if (m_retryUrlOnError)</span>
<a href="#l3.44"></a><span id="l3.44">       return RetryUrl();</span>
<a href="#l3.45"></a><span id="l3.45"> </span>
<a href="#l3.46"></a><span id="l3.46">   // The URL has now been processed</span>
<a href="#l3.47"></a><span id="l3.47">     if ((!logonFailed &amp;&amp; NS_FAILED(GetConnectionStatus())) ||</span>
<a href="#l3.48"></a><span id="l3.48">          DeathSignalReceived())</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineat">@@ -2995,17 +2995,19 @@ void nsImapProtocol::AutoSubscribeToMail</span>
<a href="#l3.50"></a><span id="l3.50"> nsresult nsImapProtocol::BeginMessageDownLoad(</span>
<a href="#l3.51"></a><span id="l3.51">                                               PRUint32 total_message_size, // for user, headers and body</span>
<a href="#l3.52"></a><span id="l3.52">                                               const char *content_type)</span>
<a href="#l3.53"></a><span id="l3.53"> {</span>
<a href="#l3.54"></a><span id="l3.54">   nsresult rv = NS_OK;</span>
<a href="#l3.55"></a><span id="l3.55">   char *sizeString = PR_smprintf(&quot;OPEN Size: %ld&quot;, total_message_size);</span>
<a href="#l3.56"></a><span id="l3.56">   Log(&quot;STREAM&quot;,sizeString,&quot;Begin Message Download Stream&quot;);</span>
<a href="#l3.57"></a><span id="l3.57">   PR_Free(sizeString);</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineminus">-  //total_message_size));</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+  // start counting how many bytes we see in this message after all transformations</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+  m_bytesToChannel = 0;</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+</span>
<a href="#l3.62"></a><span id="l3.62">   if (content_type)</span>
<a href="#l3.63"></a><span id="l3.63">   {</span>
<a href="#l3.64"></a><span id="l3.64">     m_fromHeaderSeen = false;</span>
<a href="#l3.65"></a><span id="l3.65">     if (GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l3.66"></a><span id="l3.66">     {</span>
<a href="#l3.67"></a><span id="l3.67">       // if we get multiple calls to BeginMessageDownload w/o intervening</span>
<a href="#l3.68"></a><span id="l3.68">       // calls to NormalEndMessageDownload or Abort, then we're just</span>
<a href="#l3.69"></a><span id="l3.69">       // going to fake a NormalMessageEndDownload. This will most likely</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineat">@@ -3268,17 +3270,16 @@ void nsImapProtocol::FetchMsgAttribute(c</span>
<a href="#l3.71"></a><span id="l3.71">     commandString.Append(&quot; (&quot;);</span>
<a href="#l3.72"></a><span id="l3.72">     commandString.Append(attribute);</span>
<a href="#l3.73"></a><span id="l3.73">     commandString.Append(&quot;)&quot; CRLF);</span>
<a href="#l3.74"></a><span id="l3.74">     nsresult rv = SendData(commandString.get());</span>
<a href="#l3.75"></a><span id="l3.75"> </span>
<a href="#l3.76"></a><span id="l3.76">     if (NS_SUCCEEDED(rv))</span>
<a href="#l3.77"></a><span id="l3.77">        ParseIMAPandCheckForNewMail(commandString.get());</span>
<a href="#l3.78"></a><span id="l3.78">     GetServerStateParser().SetFetchingFlags(false);</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineminus">-    GetServerStateParser().SetFetchingEverythingRFC822(false); // always clear this flag after every fetch....</span>
<a href="#l3.80"></a><span id="l3.80"> }</span>
<a href="#l3.81"></a><span id="l3.81"> </span>
<a href="#l3.82"></a><span id="l3.82"> // this routine is used to fetch a message or messages, or headers for a</span>
<a href="#l3.83"></a><span id="l3.83"> // message...</span>
<a href="#l3.84"></a><span id="l3.84"> </span>
<a href="#l3.85"></a><span id="l3.85"> void nsImapProtocol::FallbackToFetchWholeMsg(const nsCString &amp;messageId, PRUint32 messageSize)</span>
<a href="#l3.86"></a><span id="l3.86"> {</span>
<a href="#l3.87"></a><span id="l3.87">   if (m_imapMessageSink &amp;&amp; m_runningUrl)</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineat">@@ -3303,17 +3304,16 @@ nsImapProtocol::FetchMessage(const nsCSt</span>
<a href="#l3.89"></a><span id="l3.89">   IncrementCommandTagNumber();</span>
<a href="#l3.90"></a><span id="l3.90"> </span>
<a href="#l3.91"></a><span id="l3.91">   nsCString commandString;</span>
<a href="#l3.92"></a><span id="l3.92">   commandString = &quot;%s UID fetch&quot;;</span>
<a href="#l3.93"></a><span id="l3.93"> </span>
<a href="#l3.94"></a><span id="l3.94">   switch (whatToFetch) {</span>
<a href="#l3.95"></a><span id="l3.95">   case kEveryThingRFC822:</span>
<a href="#l3.96"></a><span id="l3.96">     m_flagChangeCount++;</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineminus">-    GetServerStateParser().SetFetchingEverythingRFC822(true);</span>
<a href="#l3.98"></a><span id="l3.98">     if (m_trackingTime)</span>
<a href="#l3.99"></a><span id="l3.99">       AdjustChunkSize();      // we started another segment</span>
<a href="#l3.100"></a><span id="l3.100">     m_startTime = PR_Now();     // save start of download time</span>
<a href="#l3.101"></a><span id="l3.101">     m_trackingTime = true;</span>
<a href="#l3.102"></a><span id="l3.102">     PR_LOG(IMAP, PR_LOG_DEBUG, (&quot;FetchMessage everything: curFetchSize %u numBytes %u&quot;,</span>
<a href="#l3.103"></a><span id="l3.103">                                 m_curFetchSize, numBytes));</span>
<a href="#l3.104"></a><span id="l3.104">     if (numBytes &gt; 0)</span>
<a href="#l3.105"></a><span id="l3.105">       m_curFetchSize = numBytes;</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineat">@@ -3350,17 +3350,16 @@ nsImapProtocol::FetchMessage(const nsCSt</span>
<a href="#l3.107"></a><span id="l3.107">     {</span>
<a href="#l3.108"></a><span id="l3.108">       PR_LOG(IMAP, PR_LOG_DEBUG, (&quot;FetchMessage peek: curFetchSize %u numBytes %u&quot;,</span>
<a href="#l3.109"></a><span id="l3.109">                                   m_curFetchSize, numBytes));</span>
<a href="#l3.110"></a><span id="l3.110">       if (numBytes &gt; 0)</span>
<a href="#l3.111"></a><span id="l3.111">         m_curFetchSize = numBytes;</span>
<a href="#l3.112"></a><span id="l3.112">       const char *formatString = &quot;&quot;;</span>
<a href="#l3.113"></a><span id="l3.113">       eIMAPCapabilityFlags server_capabilityFlags = GetServerStateParser().GetCapabilityFlag();</span>
<a href="#l3.114"></a><span id="l3.114"> </span>
<a href="#l3.115"></a><span id="l3.115" class="difflineminus">-      GetServerStateParser().SetFetchingEverythingRFC822(true);</span>
<a href="#l3.116"></a><span id="l3.116">       if (server_capabilityFlags &amp; kIMAP4rev1Capability)</span>
<a href="#l3.117"></a><span id="l3.117">       {</span>
<a href="#l3.118"></a><span id="l3.118">         // use body[].peek since rfc822.peek is not in IMAP4rev1</span>
<a href="#l3.119"></a><span id="l3.119">         if (server_capabilityFlags &amp; kHasXSenderCapability)</span>
<a href="#l3.120"></a><span id="l3.120">           formatString = &quot; %s (XSENDER UID RFC822.SIZE BODY.PEEK[]&quot;;</span>
<a href="#l3.121"></a><span id="l3.121">         else</span>
<a href="#l3.122"></a><span id="l3.122">           formatString = &quot; %s (UID RFC822.SIZE BODY.PEEK[]&quot;;</span>
<a href="#l3.123"></a><span id="l3.123">       }</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineat">@@ -3541,17 +3540,16 @@ nsImapProtocol::FetchMessage(const nsCSt</span>
<a href="#l3.125"></a><span id="l3.125"> </span>
<a href="#l3.126"></a><span id="l3.126">     nsresult rv = SendData(protocolString);</span>
<a href="#l3.127"></a><span id="l3.127"> </span>
<a href="#l3.128"></a><span id="l3.128">     nsMemory::Free(cCommandStr);</span>
<a href="#l3.129"></a><span id="l3.129">     if (NS_SUCCEEDED(rv))</span>
<a href="#l3.130"></a><span id="l3.130">       ParseIMAPandCheckForNewMail(protocolString);</span>
<a href="#l3.131"></a><span id="l3.131">     PR_Free(protocolString);</span>
<a href="#l3.132"></a><span id="l3.132">     GetServerStateParser().SetFetchingFlags(false);</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineminus">-    GetServerStateParser().SetFetchingEverythingRFC822(false); // always clear this flag after every fetch....</span>
<a href="#l3.134"></a><span id="l3.134">     if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; CheckNeeded())</span>
<a href="#l3.135"></a><span id="l3.135">       Check();</span>
<a href="#l3.136"></a><span id="l3.136">   }</span>
<a href="#l3.137"></a><span id="l3.137">   else</span>
<a href="#l3.138"></a><span id="l3.138">     HandleMemoryFailure();</span>
<a href="#l3.139"></a><span id="l3.139"> }</span>
<a href="#l3.140"></a><span id="l3.140"> </span>
<a href="#l3.141"></a><span id="l3.141"> void nsImapProtocol::FetchTryChunking(const nsCString &amp;messageIds,</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineat">@@ -3676,39 +3674,41 @@ void nsImapProtocol::PipelinedFetchMessa</span>
<a href="#l3.143"></a><span id="l3.143"> }</span>
<a href="#l3.144"></a><span id="l3.144"> </span>
<a href="#l3.145"></a><span id="l3.145"> </span>
<a href="#l3.146"></a><span id="l3.146"> void</span>
<a href="#l3.147"></a><span id="l3.147"> nsImapProtocol::PostLineDownLoadEvent(const char *line, PRUint32 uidOfMessage)</span>
<a href="#l3.148"></a><span id="l3.148"> {</span>
<a href="#l3.149"></a><span id="l3.149">   if (!GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l3.150"></a><span id="l3.150">   {</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+    PRUint32 byteCount = PL_strlen(line);</span>
<a href="#l3.152"></a><span id="l3.152">     bool echoLineToMessageSink = false;</span>
<a href="#l3.153"></a><span id="l3.153">     // if we have a channel listener, then just spool the message</span>
<a href="#l3.154"></a><span id="l3.154">     // directly to the listener</span>
<a href="#l3.155"></a><span id="l3.155">     if (m_channelListener)</span>
<a href="#l3.156"></a><span id="l3.156">     {</span>
<a href="#l3.157"></a><span id="l3.157">       PRUint32 count = 0;</span>
<a href="#l3.158"></a><span id="l3.158">       if (m_channelOutputStream)</span>
<a href="#l3.159"></a><span id="l3.159">       {</span>
<a href="#l3.160"></a><span id="l3.160" class="difflineminus">-        nsresult rv = m_channelOutputStream-&gt;Write(line, PL_strlen(line), &amp;count);</span>
<a href="#l3.161"></a><span id="l3.161" class="difflineplus">+        nsresult rv = m_channelOutputStream-&gt;Write(line, byteCount, &amp;count);</span>
<a href="#l3.162"></a><span id="l3.162" class="difflineplus">+        NS_ASSERTION(count == byteCount, &quot;IMAP channel pipe couldn't buffer entire write&quot;);</span>
<a href="#l3.163"></a><span id="l3.163">         if (NS_SUCCEEDED(rv))</span>
<a href="#l3.164"></a><span id="l3.164">         {</span>
<a href="#l3.165"></a><span id="l3.165">           nsCOMPtr&lt;nsIRequest&gt; request = do_QueryInterface(m_mockChannel);</span>
<a href="#l3.166"></a><span id="l3.166">           m_channelListener-&gt;OnDataAvailable(request, m_channelContext, m_channelInputStream, 0, count);</span>
<a href="#l3.167"></a><span id="l3.167">         }</span>
<a href="#l3.168"></a><span id="l3.168" class="difflineplus">+        // else some sort of explosion?</span>
<a href="#l3.169"></a><span id="l3.169">       }</span>
<a href="#l3.170"></a><span id="l3.170">     }</span>
<a href="#l3.171"></a><span id="l3.171">     if (m_runningUrl)</span>
<a href="#l3.172"></a><span id="l3.172">       m_runningUrl-&gt;GetStoreResultsOffline(&amp;echoLineToMessageSink);</span>
<a href="#l3.173"></a><span id="l3.173"> </span>
<a href="#l3.174"></a><span id="l3.174" class="difflineplus">+    m_bytesToChannel += byteCount;</span>
<a href="#l3.175"></a><span id="l3.175">     if (m_imapMessageSink &amp;&amp; line &amp;&amp; echoLineToMessageSink &amp;&amp; !GetPseudoInterrupted())</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineminus">-      m_imapMessageSink-&gt;ParseAdoptedMsgLine(line, uidOfMessage,</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineminus">-                                             GetServerStateParser().SizeOfMostRecentMessage(),</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineminus">-                                             m_runningUrl);</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineplus">+      m_imapMessageSink-&gt;ParseAdoptedMsgLine(line, uidOfMessage, m_runningUrl);</span>
<a href="#l3.180"></a><span id="l3.180">   }</span>
<a href="#l3.181"></a><span id="l3.181">   // ***** We need to handle the pseudo interrupt here *****</span>
<a href="#l3.182"></a><span id="l3.182"> }</span>
<a href="#l3.183"></a><span id="l3.183"> </span>
<a href="#l3.184"></a><span id="l3.184"> // Handle a line seen by the parser.</span>
<a href="#l3.185"></a><span id="l3.185"> // * The argument |lineCopy| must be nsnull or should contain the same string as</span>
<a href="#l3.186"></a><span id="l3.186"> //   |line|.  |lineCopy| will be modified.</span>
<a href="#l3.187"></a><span id="l3.187"> // * A line may be passed by parts, e.g., &quot;part1 part2\r\n&quot; may be passed as</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineat">@@ -3729,18 +3729,18 @@ void nsImapProtocol::HandleMessageDownLo</span>
<a href="#l3.189"></a><span id="l3.189">   // If we obtain a partial line (due to fetching by chunks), we do not</span>
<a href="#l3.190"></a><span id="l3.190">   // add/modify the end-of-line terminator.</span>
<a href="#l3.191"></a><span id="l3.191">   if (!isPartialLine)</span>
<a href="#l3.192"></a><span id="l3.192">   {</span>
<a href="#l3.193"></a><span id="l3.193">     // Change this line to native line termination, duplicate if necessary.</span>
<a href="#l3.194"></a><span id="l3.194">     // Do not assume that the line really ends in CRLF</span>
<a href="#l3.195"></a><span id="l3.195">     // to start with, even though it is supposed to be RFC822</span>
<a href="#l3.196"></a><span id="l3.196"> </span>
<a href="#l3.197"></a><span id="l3.197" class="difflineminus">-    // note: usually canonicalLineEnding==FALSE</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineminus">-    bool canonicalLineEnding = false;</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+    // normalize line endings to CRLF unless we are saving the message to disk</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+    bool canonicalLineEnding = true;</span>
<a href="#l3.201"></a><span id="l3.201">     nsCOMPtr&lt;nsIMsgMessageUrl&gt; msgUrl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.202"></a><span id="l3.202"> </span>
<a href="#l3.203"></a><span id="l3.203">     if (m_imapAction == nsIImapUrl::nsImapSaveMessageToDisk &amp;&amp; msgUrl)</span>
<a href="#l3.204"></a><span id="l3.204">       msgUrl-&gt;GetCanonicalLineEnding(&amp;canonicalLineEnding);</span>
<a href="#l3.205"></a><span id="l3.205"> </span>
<a href="#l3.206"></a><span id="l3.206">     NS_PRECONDITION(MSG_LINEBREAK_LEN == 1 ||</span>
<a href="#l3.207"></a><span id="l3.207">                     MSG_LINEBREAK_LEN == 2 &amp;&amp; !PL_strcmp(CRLF, MSG_LINEBREAK),</span>
<a href="#l3.208"></a><span id="l3.208">                     &quot;violated assumptions on MSG_LINEBREAK&quot;);</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineat">@@ -3910,31 +3910,34 @@ void nsImapProtocol::NormalMessageEndDow</span>
<a href="#l3.210"></a><span id="l3.210">       m_imapMailFolderSink-&gt;ParseMsgHdrs(this, m_hdrDownloadCache);</span>
<a href="#l3.211"></a><span id="l3.211">       m_hdrDownloadCache-&gt;ResetAll();</span>
<a href="#l3.212"></a><span id="l3.212">     }</span>
<a href="#l3.213"></a><span id="l3.213">   }</span>
<a href="#l3.214"></a><span id="l3.214">   FlushDownloadCache();</span>
<a href="#l3.215"></a><span id="l3.215"> </span>
<a href="#l3.216"></a><span id="l3.216">   if (!GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l3.217"></a><span id="l3.217">   {</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineminus">-    if (m_channelListener)</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineminus">-    {</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineminus">-//      PRUint32 inlength = 0;</span>
<a href="#l3.221"></a><span id="l3.221" class="difflineminus">-//      m_channelInputStream-&gt;Available(&amp;inlength);</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineminus">-      //if (inlength &gt; 0) // broadcast our batched up ODA changes</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineminus">-//        m_channelListener-&gt;OnDataAvailable(m_mockChannel, m_channelContext, m_channelInputStream, 0, inlength);</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineminus">-    }</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineminus">-</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineplus">+    PRInt32 updatedMessageSize = -1;</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineplus">+    if (m_bytesToChannel != GetServerStateParser().SizeOfMostRecentMessage()) {</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineplus">+      updatedMessageSize = m_bytesToChannel;</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineplus">+#ifdef DEBUG</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineplus">+      nsCAutoString message(&quot;Server's RFC822.SIZE &quot;);</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineplus">+      message.AppendInt(GetServerStateParser().SizeOfMostRecentMessage());</span>
<a href="#l3.232"></a><span id="l3.232" class="difflineplus">+      message += &quot; actual size &quot;;</span>
<a href="#l3.233"></a><span id="l3.233" class="difflineplus">+      message.AppendInt(m_bytesToChannel);</span>
<a href="#l3.234"></a><span id="l3.234" class="difflineplus">+      NS_WARNING(message.get());</span>
<a href="#l3.235"></a><span id="l3.235" class="difflineplus">+#endif</span>
<a href="#l3.236"></a><span id="l3.236" class="difflineplus">+    }</span>
<a href="#l3.237"></a><span id="l3.237">     // need to know if we're downloading for display or not. We'll use action == nsImapMsgFetch for now</span>
<a href="#l3.238"></a><span id="l3.238">     nsImapAction imapAction = nsIImapUrl::nsImapSelectFolder; // just set it to some legal value</span>
<a href="#l3.239"></a><span id="l3.239">     if (m_runningUrl)</span>
<a href="#l3.240"></a><span id="l3.240">       m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.241"></a><span id="l3.241"> </span>
<a href="#l3.242"></a><span id="l3.242">     if (m_imapMessageSink)</span>
<a href="#l3.243"></a><span id="l3.243" class="difflineminus">-      m_imapMessageSink-&gt;NormalEndMsgWriteStream(m_downloadLineCache-&gt;CurrentUID(), imapAction == nsIImapUrl::nsImapMsgFetch, m_runningUrl);</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineplus">+      m_imapMessageSink-&gt;NormalEndMsgWriteStream(m_downloadLineCache-&gt;CurrentUID(), imapAction == nsIImapUrl::nsImapMsgFetch, m_runningUrl, updatedMessageSize);</span>
<a href="#l3.245"></a><span id="l3.245"> </span>
<a href="#l3.246"></a><span id="l3.246">     if (m_runningUrl &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l3.247"></a><span id="l3.247">     {</span>
<a href="#l3.248"></a><span id="l3.248">       nsCOMPtr &lt;nsISupports&gt; copyState;</span>
<a href="#l3.249"></a><span id="l3.249">       m_runningUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l3.250"></a><span id="l3.250">       if (copyState) // only need this notification during copy</span>
<a href="#l3.251"></a><span id="l3.251">       {</span>
<a href="#l3.252"></a><span id="l3.252">         nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl (do_QueryInterface(m_runningUrl));</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineat">@@ -8669,20 +8672,17 @@ NS_IMETHODIMP nsImapMockChannel::Close()</span>
<a href="#l3.254"></a><span id="l3.254">   else</span>
<a href="#l3.255"></a><span id="l3.255">   {</span>
<a href="#l3.256"></a><span id="l3.256">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_url);</span>
<a href="#l3.257"></a><span id="l3.257">     if (mailnewsUrl)</span>
<a href="#l3.258"></a><span id="l3.258">     {</span>
<a href="#l3.259"></a><span id="l3.259">       nsCOMPtr&lt;nsICacheEntryDescriptor&gt;  cacheEntry;</span>
<a href="#l3.260"></a><span id="l3.260">       mailnewsUrl-&gt;GetMemCacheEntry(getter_AddRefs(cacheEntry));</span>
<a href="#l3.261"></a><span id="l3.261">       if (cacheEntry)</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineminus">-      {</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineminus">-        nsCOMPtr &lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(m_url);</span>
<a href="#l3.264"></a><span id="l3.264">         cacheEntry-&gt;MarkValid();</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineminus">-      }</span>
<a href="#l3.266"></a><span id="l3.266">       // remove the channel from the load group</span>
<a href="#l3.267"></a><span id="l3.267">       nsCOMPtr &lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.268"></a><span id="l3.268">       GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.269"></a><span id="l3.269">       // if the mock channel wasn't initialized with a load group then</span>
<a href="#l3.270"></a><span id="l3.270">       // use our load group (they may differ)</span>
<a href="#l3.271"></a><span id="l3.271">       if (!loadGroup)</span>
<a href="#l3.272"></a><span id="l3.272">         mailnewsUrl-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.273"></a><span id="l3.273">       if (loadGroup)</span>
<a href="#l3.274"></a><span id="l3.274" class="difflineat">@@ -8841,19 +8841,20 @@ nsImapMockChannel::OnCacheEntryAvailable</span>
<a href="#l3.275"></a><span id="l3.275">   {</span>
<a href="#l3.276"></a><span id="l3.276">     entry-&gt;Doom();</span>
<a href="#l3.277"></a><span id="l3.277">     return NS_OK;</span>
<a href="#l3.278"></a><span id="l3.278">   }</span>
<a href="#l3.279"></a><span id="l3.279"> </span>
<a href="#l3.280"></a><span id="l3.280">   NS_ENSURE_ARG(m_url); // kick out if m_url is null for some reason.</span>
<a href="#l3.281"></a><span id="l3.281"> </span>
<a href="#l3.282"></a><span id="l3.282"> #ifdef DEBUG_bienvenu</span>
<a href="#l3.283"></a><span id="l3.283" class="difflineminus">-      nsCAutoString entryKey;</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineminus">-      entry-&gt;GetKey(entryKey);</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineminus">-      printf(&quot;%s with access %ld status %ld\n&quot;, entryKey.get(), access, status);</span>
<a href="#l3.286"></a><span id="l3.286" class="difflineplus">+      nsCAutoString entryKey(&quot;null&quot;);</span>
<a href="#l3.287"></a><span id="l3.287" class="difflineplus">+      if (entry)</span>
<a href="#l3.288"></a><span id="l3.288" class="difflineplus">+        entry-&gt;GetKey(entryKey);</span>
<a href="#l3.289"></a><span id="l3.289" class="difflineplus">+      printf(&quot;*** OnCacheEntryAvailable %s with access %d status %u\n&quot;, entryKey.get(), access, status);</span>
<a href="#l3.290"></a><span id="l3.290"> #endif</span>
<a href="#l3.291"></a><span id="l3.291">   if (NS_SUCCEEDED(status))</span>
<a href="#l3.292"></a><span id="l3.292">   {</span>
<a href="#l3.293"></a><span id="l3.293">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_url, &amp;rv);</span>
<a href="#l3.294"></a><span id="l3.294">     mailnewsUrl-&gt;SetMemCacheEntry(entry);</span>
<a href="#l3.295"></a><span id="l3.295"> </span>
<a href="#l3.296"></a><span id="l3.296">     if (mTryingToReadPart &amp;&amp; access &amp; nsICache::ACCESS_WRITE &amp;&amp; !(access &amp; nsICache::ACCESS_READ))</span>
<a href="#l3.297"></a><span id="l3.297">     {</span>
<a href="#l3.298"></a><span id="l3.298" class="difflineat">@@ -8863,29 +8864,30 @@ nsImapMockChannel::OnCacheEntryAvailable</span>
<a href="#l3.299"></a><span id="l3.299">       SetupPartExtractorListener(imapUrl, m_channelListener);</span>
<a href="#l3.300"></a><span id="l3.300">       return OpenCacheEntry();</span>
<a href="#l3.301"></a><span id="l3.301">     }</span>
<a href="#l3.302"></a><span id="l3.302">     // if we have write access then insert a &quot;stream T&quot; into the flow so data</span>
<a href="#l3.303"></a><span id="l3.303">     // gets written to both</span>
<a href="#l3.304"></a><span id="l3.304">     if (access &amp; nsICache::ACCESS_WRITE &amp;&amp; !(access &amp; nsICache::ACCESS_READ))</span>
<a href="#l3.305"></a><span id="l3.305">     {</span>
<a href="#l3.306"></a><span id="l3.306">       // use a stream listener Tee to force data into the cache and to our current channel listener...</span>
<a href="#l3.307"></a><span id="l3.307" class="difflineminus">-      nsCOMPtr&lt;nsIStreamListener&gt; newListener;</span>
<a href="#l3.308"></a><span id="l3.308">       nsCOMPtr&lt;nsIStreamListenerTee&gt; tee = do_CreateInstance(NS_STREAMLISTENERTEE_CONTRACTID, &amp;rv);</span>
<a href="#l3.309"></a><span id="l3.309">       if (NS_SUCCEEDED(rv))</span>
<a href="#l3.310"></a><span id="l3.310">       {</span>
<a href="#l3.311"></a><span id="l3.311">         nsCOMPtr&lt;nsIOutputStream&gt; out;</span>
<a href="#l3.312"></a><span id="l3.312">         // this will fail with the mem cache turned off, so we need to fall through</span>
<a href="#l3.313"></a><span id="l3.313">         // to ReadFromImapConnection instead of aborting with NS_ENSURE_SUCCESS(rv,rv)</span>
<a href="#l3.314"></a><span id="l3.314">         rv = entry-&gt;OpenOutputStream(0, getter_AddRefs(out));</span>
<a href="#l3.315"></a><span id="l3.315">         if (NS_SUCCEEDED(rv))</span>
<a href="#l3.316"></a><span id="l3.316">         {</span>
<a href="#l3.317"></a><span id="l3.317">           rv = tee-&gt;Init(m_channelListener, out, nsnull);</span>
<a href="#l3.318"></a><span id="l3.318">           m_channelListener = do_QueryInterface(tee);</span>
<a href="#l3.319"></a><span id="l3.319">         }</span>
<a href="#l3.320"></a><span id="l3.320" class="difflineplus">+        else</span>
<a href="#l3.321"></a><span id="l3.321" class="difflineplus">+          NS_WARNING(&quot;IMAP Protocol failed to open output stream to Necko cache&quot;);</span>
<a href="#l3.322"></a><span id="l3.322">       }</span>
<a href="#l3.323"></a><span id="l3.323">     }</span>
<a href="#l3.324"></a><span id="l3.324">     else</span>
<a href="#l3.325"></a><span id="l3.325">     {</span>
<a href="#l3.326"></a><span id="l3.326">       rv = ReadFromMemCache(entry);</span>
<a href="#l3.327"></a><span id="l3.327">       if (NS_SUCCEEDED(rv))</span>
<a href="#l3.328"></a><span id="l3.328">       {</span>
<a href="#l3.329"></a><span id="l3.329">         NotifyStartEndReadFromCache(true);</span>
<a href="#l3.330"></a><span id="l3.330" class="difflineat">@@ -9018,17 +9020,22 @@ nsresult nsImapMockChannel::ReadFromMemC</span>
<a href="#l3.331"></a><span id="l3.331">         nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l3.332"></a><span id="l3.332">         // A failure to get a message header isn't an error</span>
<a href="#l3.333"></a><span id="l3.333">         msgUrl-&gt;GetMessageHeader(getter_AddRefs(msgHdr));</span>
<a href="#l3.334"></a><span id="l3.334">         if (msgHdr)</span>
<a href="#l3.335"></a><span id="l3.335">         {</span>
<a href="#l3.336"></a><span id="l3.336">           PRUint32 messageSize;</span>
<a href="#l3.337"></a><span id="l3.337">           if (NS_SUCCEEDED(msgHdr-&gt;GetMessageSize(&amp;messageSize)) &amp;&amp;</span>
<a href="#l3.338"></a><span id="l3.338">               messageSize != entrySize)</span>
<a href="#l3.339"></a><span id="l3.339" class="difflineplus">+          {</span>
<a href="#l3.340"></a><span id="l3.340" class="difflineplus">+            PR_LOG(IMAP, PR_LOG_WARN,</span>
<a href="#l3.341"></a><span id="l3.341" class="difflineplus">+                (&quot;ReadFromMemCache size mismatch for %s: message %d, cache %d\n&quot;,</span>
<a href="#l3.342"></a><span id="l3.342" class="difflineplus">+                 entryKey.get(), messageSize, entrySize));</span>
<a href="#l3.343"></a><span id="l3.343">             shouldUseCacheEntry = false;</span>
<a href="#l3.344"></a><span id="l3.344" class="difflineplus">+          }</span>
<a href="#l3.345"></a><span id="l3.345">         }</span>
<a href="#l3.346"></a><span id="l3.346">       }</span>
<a href="#l3.347"></a><span id="l3.347">     }</span>
<a href="#l3.348"></a><span id="l3.348">   }</span>
<a href="#l3.349"></a><span id="l3.349">   if (shouldUseCacheEntry)</span>
<a href="#l3.350"></a><span id="l3.350">   {</span>
<a href="#l3.351"></a><span id="l3.351">     nsCOMPtr&lt;nsIInputStream&gt; in;</span>
<a href="#l3.352"></a><span id="l3.352">     PRUint32 readCount;</span>
<a href="#l3.353"></a><span id="l3.353" class="difflineat">@@ -9081,17 +9088,17 @@ nsresult nsImapMockChannel::ReadFromMemC</span>
<a href="#l3.354"></a><span id="l3.354">       imapUrl-&gt;SetMsgLoadingFromCache(true);</span>
<a href="#l3.355"></a><span id="l3.355"> </span>
<a href="#l3.356"></a><span id="l3.356">       // be sure to set the cache entry's security info status as our security info status...</span>
<a href="#l3.357"></a><span id="l3.357">       nsCOMPtr&lt;nsISupports&gt; securityInfo;</span>
<a href="#l3.358"></a><span id="l3.358">       entry-&gt;GetSecurityInfo(getter_AddRefs(securityInfo));</span>
<a href="#l3.359"></a><span id="l3.359">       SetSecurityInfo(securityInfo);</span>
<a href="#l3.360"></a><span id="l3.360">       return NS_OK;</span>
<a href="#l3.361"></a><span id="l3.361">     } // if AsyncRead succeeded.</span>
<a href="#l3.362"></a><span id="l3.362" class="difflineminus">-  } // if contnet is not modified</span>
<a href="#l3.363"></a><span id="l3.363" class="difflineplus">+  } // if content is not modified</span>
<a href="#l3.364"></a><span id="l3.364">   else</span>
<a href="#l3.365"></a><span id="l3.365">     rv = NS_ERROR_FAILURE; // content is modified so return an error so we try to open it the old fashioned way</span>
<a href="#l3.366"></a><span id="l3.366"> </span>
<a href="#l3.367"></a><span id="l3.367">   return rv;</span>
<a href="#l3.368"></a><span id="l3.368"> }</span>
<a href="#l3.369"></a><span id="l3.369"> </span>
<a href="#l3.370"></a><span id="l3.370"> // the requested url isn't in any of our caches so create an imap connection</span>
<a href="#l3.371"></a><span id="l3.371"> // to process it.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -329,16 +329,17 @@ private:</span>
<a href="#l4.4"></a><span id="l4.4">   nsCString       m_trashFolderName;</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6">   // Ouput stream for writing commands to the socket</span>
<a href="#l4.7"></a><span id="l4.7">   nsCOMPtr&lt;nsISocketTransport&gt;  m_transport;</span>
<a href="#l4.8"></a><span id="l4.8"> </span>
<a href="#l4.9"></a><span id="l4.9">   nsCOMPtr&lt;nsIAsyncInputStream&gt;   m_channelInputStream;</span>
<a href="#l4.10"></a><span id="l4.10">   nsCOMPtr&lt;nsIAsyncOutputStream&gt;  m_channelOutputStream;</span>
<a href="#l4.11"></a><span id="l4.11">   nsCOMPtr&lt;nsIImapMockChannel&gt;    m_mockChannel;   // this is the channel we should forward to people</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+  PRUint32 m_bytesToChannel;</span>
<a href="#l4.13"></a><span id="l4.13">   //nsCOMPtr&lt;nsIRequest&gt; mAsyncReadRequest; // we're going to cancel this when we're done with the conn.</span>
<a href="#l4.14"></a><span id="l4.14"> </span>
<a href="#l4.15"></a><span id="l4.15"> </span>
<a href="#l4.16"></a><span id="l4.16">   // ******* Thread support *******</span>
<a href="#l4.17"></a><span id="l4.17">   nsCOMPtr&lt;nsIThread&gt;      m_iThread;</span>
<a href="#l4.18"></a><span id="l4.18">   PRThread     *m_thread;</span>
<a href="#l4.19"></a><span id="l4.19">   mozilla::ReentrantMonitor m_dataAvailableMonitor;   // used to notify the arrival of data from the server</span>
<a href="#l4.20"></a><span id="l4.20">   mozilla::ReentrantMonitor m_urlReadyToRunMonitor;   // used to notify the arrival of a new url to be processed</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/imap/src/nsImapServerResponseParser.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapServerResponseParser.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -25,17 +25,16 @@</span>
<a href="#l5.4"></a><span id="l5.4"> </span>
<a href="#l5.5"></a><span id="l5.5"> extern PRLogModuleInfo* IMAP;</span>
<a href="#l5.6"></a><span id="l5.6"> </span>
<a href="#l5.7"></a><span id="l5.7"> nsImapServerResponseParser::nsImapServerResponseParser(nsImapProtocol &amp;imapProtocolConnection) </span>
<a href="#l5.8"></a><span id="l5.8">                             : nsIMAPGenericParser(),</span>
<a href="#l5.9"></a><span id="l5.9">     fReportingErrors(true),</span>
<a href="#l5.10"></a><span id="l5.10">     fCurrentFolderReadOnly(false),</span>
<a href="#l5.11"></a><span id="l5.11">     fCurrentLineContainedFlagInfo(false),</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-    fFetchEverythingRFC822(false),</span>
<a href="#l5.13"></a><span id="l5.13">     fServerIsNetscape3xServer(false),</span>
<a href="#l5.14"></a><span id="l5.14">     fNumberOfUnseenMessages(0),</span>
<a href="#l5.15"></a><span id="l5.15">     fNumberOfExistingMessages(0),</span>
<a href="#l5.16"></a><span id="l5.16">     fNumberOfRecentMessages(0),</span>
<a href="#l5.17"></a><span id="l5.17">     fSizeOfMostRecentMessage(0),</span>
<a href="#l5.18"></a><span id="l5.18">     fTotalDownloadSize(0),</span>
<a href="#l5.19"></a><span id="l5.19">     fCurrentCommandTag(nsnull),</span>
<a href="#l5.20"></a><span id="l5.20">     fSelectedMailboxName(nsnull),</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineat">@@ -3020,22 +3019,16 @@ bool nsImapServerResponseParser::msg_fet</span>
<a href="#l5.22"></a><span id="l5.22">     PR_LOG(IMAP, PR_LOG_DEBUG, (&quot;PARSER: fetch_literal chunk = %d, requested %d, receiving %d&quot;,</span>
<a href="#l5.23"></a><span id="l5.23">                                 chunk, fServerConnection.GetCurFetchSize(),</span>
<a href="#l5.24"></a><span id="l5.24">                                 numberOfCharsInThisChunk));</span>
<a href="#l5.25"></a><span id="l5.25"> #endif</span>
<a href="#l5.26"></a><span id="l5.26"> </span>
<a href="#l5.27"></a><span id="l5.27">   charsReadSoFar = 0;</span>
<a href="#l5.28"></a><span id="l5.28">   static bool lastCRLFwasCRCRLF = false;</span>
<a href="#l5.29"></a><span id="l5.29"> </span>
<a href="#l5.30"></a><span id="l5.30" class="difflineminus">-  // If we're fetching the whole message, the length of the returned literal</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineminus">-  // must be the message size, and for servers like Exchange that only</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineminus">-  // approximate the rfc822 size, we can use this size as the correct size.</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineminus">-  if (lastChunk &amp;&amp; fFetchEverythingRFC822)</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineminus">-    fSizeOfMostRecentMessage = origin + numberOfCharsInThisChunk;</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineminus">-</span>
<a href="#l5.36"></a><span id="l5.36">   while (ContinueParse() &amp;&amp; !fServerConnection.DeathSignalReceived() &amp;&amp; (charsReadSoFar &lt; numberOfCharsInThisChunk))</span>
<a href="#l5.37"></a><span id="l5.37">   {</span>
<a href="#l5.38"></a><span id="l5.38">     AdvanceToNextLine();</span>
<a href="#l5.39"></a><span id="l5.39">     if (ContinueParse())</span>
<a href="#l5.40"></a><span id="l5.40">     {</span>
<a href="#l5.41"></a><span id="l5.41">       // When we split CRLF across two chunks, AdvanceToNextLine() turns the LF at the</span>
<a href="#l5.42"></a><span id="l5.42">       // beginning of the next chunk into an empty line ending with CRLF, so discard</span>
<a href="#l5.43"></a><span id="l5.43">       // that leading CR</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/imap/src/nsImapServerResponseParser.h</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapServerResponseParser.h</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -66,17 +66,16 @@ public:</span>
<a href="#l6.4"></a><span id="l6.4">   PRInt32    NumberOfUnseenMessages();</span>
<a href="#l6.5"></a><span id="l6.5">   PRInt32    FolderUID();</span>
<a href="#l6.6"></a><span id="l6.6">   PRUint32   CurrentResponseUID();</span>
<a href="#l6.7"></a><span id="l6.7">   PRUint32   HighestRecordedUID();</span>
<a href="#l6.8"></a><span id="l6.8">   void       SetCurrentResponseUID(PRUint32 uid);</span>
<a href="#l6.9"></a><span id="l6.9">   bool       IsNumericString(const char *string);</span>
<a href="#l6.10"></a><span id="l6.10">   PRInt32    SizeOfMostRecentMessage();</span>
<a href="#l6.11"></a><span id="l6.11">   void       SetTotalDownloadSize(PRInt32 newSize) { fTotalDownloadSize = newSize; }</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-  void       SetFetchingEverythingRFC822(bool fetchingEverythingRFC822) { fFetchEverythingRFC822 = fetchingEverythingRFC822;}</span>
<a href="#l6.13"></a><span id="l6.13"> </span>
<a href="#l6.14"></a><span id="l6.14">   nsImapSearchResultIterator *CreateSearchResultIterator();</span>
<a href="#l6.15"></a><span id="l6.15">   void ResetSearchResultSequence() {fSearchResults-&gt;ResetSequence();}</span>
<a href="#l6.16"></a><span id="l6.16"> </span>
<a href="#l6.17"></a><span id="l6.17">   // create a struct mailbox_spec from our info, used in</span>
<a href="#l6.18"></a><span id="l6.18">   // libmsg c interface</span>
<a href="#l6.19"></a><span id="l6.19">   nsImapMailboxSpec *CreateCurrentMailboxSpec(const char *mailboxName = nsnull);</span>
<a href="#l6.20"></a><span id="l6.20"> </span>
<a href="#l6.21"></a><span id="l6.21" class="difflineat">@@ -191,18 +190,16 @@ private:</span>
<a href="#l6.22"></a><span id="l6.22">   bool            fCurrentCommandFailed;</span>
<a href="#l6.23"></a><span id="l6.23">   bool            fReportingErrors;</span>
<a href="#l6.24"></a><span id="l6.24"> </span>
<a href="#l6.25"></a><span id="l6.25"> </span>
<a href="#l6.26"></a><span id="l6.26">   bool            fCurrentFolderReadOnly;</span>
<a href="#l6.27"></a><span id="l6.27">   bool            fCurrentLineContainedFlagInfo;</span>
<a href="#l6.28"></a><span id="l6.28">   bool            fFetchingAllFlags;</span>
<a href="#l6.29"></a><span id="l6.29">   bool            fWaitingForMoreClientInput;</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineminus">-  // when issuing a fetch command, are we fetching everything or just a part?</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-  bool            fFetchEverythingRFC822;</span>
<a href="#l6.32"></a><span id="l6.32">   // Is the server a Netscape 3.x Messaging Server?</span>
<a href="#l6.33"></a><span id="l6.33">   bool            fServerIsNetscape3xServer;</span>
<a href="#l6.34"></a><span id="l6.34">   bool            fDownloadingHeaders;</span>
<a href="#l6.35"></a><span id="l6.35">   bool            fCurrentCommandIsSingleMessageFetch;</span>
<a href="#l6.36"></a><span id="l6.36">   bool            fGotPermanentFlags;</span>
<a href="#l6.37"></a><span id="l6.37">   imapMessageFlagsType   fSavedFlagInfo;</span>
<a href="#l6.38"></a><span id="l6.38">   nsTArray&lt;nsCString&gt; fCustomFlags;</span>
<a href="#l6.39"></a><span id="l6.39"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/imap/src/nsSyncRunnableHelpers.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/imap/src/nsSyncRunnableHelpers.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -399,18 +399,18 @@ NS_SYNCRUNNABLEMETHOD1(ImapMailFolderSin</span>
<a href="#l7.4"></a><span id="l7.4"> NS_SYNCRUNNABLEMETHOD3(ImapMailFolderSink, ProgressStatus, nsIImapProtocol*, PRUint32, const PRUnichar *)</span>
<a href="#l7.5"></a><span id="l7.5"> NS_SYNCRUNNABLEMETHOD4(ImapMailFolderSink, PercentProgress, nsIImapProtocol*, const PRUnichar *, PRInt64, PRInt64)</span>
<a href="#l7.6"></a><span id="l7.6"> NS_SYNCRUNNABLEMETHOD0(ImapMailFolderSink, ClearFolderRights)</span>
<a href="#l7.7"></a><span id="l7.7"> NS_SYNCRUNNABLEMETHOD2(ImapMailFolderSink, SetCopyResponseUid, const char *, nsIImapUrl *)</span>
<a href="#l7.8"></a><span id="l7.8"> NS_SYNCRUNNABLEMETHOD2(ImapMailFolderSink, SetAppendMsgUid, nsMsgKey, nsIImapUrl *)</span>
<a href="#l7.9"></a><span id="l7.9"> NS_SYNCRUNNABLEMETHOD2(ImapMailFolderSink, GetMessageId, nsIImapUrl *, nsACString &amp;)</span>
<a href="#l7.10"></a><span id="l7.10"> </span>
<a href="#l7.11"></a><span id="l7.11"> NS_SYNCRUNNABLEMETHOD2(ImapMessageSink, SetupMsgWriteStream, nsIFile *, bool)</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-NS_SYNCRUNNABLEMETHOD4(ImapMessageSink, ParseAdoptedMsgLine, const char *, nsMsgKey, PRInt32, nsIImapUrl *)</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineminus">-NS_SYNCRUNNABLEMETHOD3(ImapMessageSink, NormalEndMsgWriteStream, nsMsgKey, bool, nsIImapUrl *)</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+NS_SYNCRUNNABLEMETHOD3(ImapMessageSink, ParseAdoptedMsgLine, const char *, nsMsgKey, nsIImapUrl *)</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+NS_SYNCRUNNABLEMETHOD4(ImapMessageSink, NormalEndMsgWriteStream, nsMsgKey, bool, nsIImapUrl *, PRInt32)</span>
<a href="#l7.16"></a><span id="l7.16"> NS_SYNCRUNNABLEMETHOD0(ImapMessageSink, AbortMsgWriteStream)</span>
<a href="#l7.17"></a><span id="l7.17"> NS_SYNCRUNNABLEMETHOD0(ImapMessageSink, BeginMessageUpload)</span>
<a href="#l7.18"></a><span id="l7.18"> NS_SYNCRUNNABLEMETHOD4(ImapMessageSink, NotifyMessageFlags, PRUint32, const nsACString &amp;, nsMsgKey, PRUint64)</span>
<a href="#l7.19"></a><span id="l7.19"> NS_SYNCRUNNABLEMETHOD3(ImapMessageSink, NotifyMessageDeleted, const char *, bool, const char *)</span>
<a href="#l7.20"></a><span id="l7.20"> NS_SYNCRUNNABLEMETHOD2(ImapMessageSink, GetMessageSizeFromDB, const char *, PRUint32 *)</span>
<a href="#l7.21"></a><span id="l7.21"> NS_SYNCRUNNABLEMETHOD2(ImapMessageSink, SetContentModified, nsIImapUrl *, nsImapContentModifiedType)</span>
<a href="#l7.22"></a><span id="l7.22"> NS_SYNCRUNNABLEMETHOD1(ImapMessageSink, SetImageCacheSessionForUrl, nsIMsgMailNewsUrl *)</span>
<a href="#l7.23"></a><span id="l7.23"> NS_SYNCRUNNABLEMETHOD4(ImapMessageSink, GetCurMoveCopyMessageInfo, nsIImapUrl *, PRTime *, nsACString &amp;, PRUint32 *)</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

