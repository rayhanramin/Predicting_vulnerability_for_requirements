<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 22136:fd85506c79b1bbf409bd67c73bf4944ee4c2a07d</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ fd85506c79b1bbf409bd67c73bf4944ee4c2a07d" />
<meta property="og:url" content="/comm-central/rev/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d" />
<meta property="og:description" content="Bug 1399756 - remove trailing spaces in mailnews/base/util. rs=white-space-only" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / fd85506c79b1bbf409bd67c73bf4944ee4c2a07d 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d">shortlog</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d">files</a> |
changeset |
<a href="/comm-central/raw-rev/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d">raw</a>  | <a href="/comm-central/archive/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399756">Bug 1399756</a> - remove trailing spaces in mailnews/base/util. rs=white-space-only
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#114;&#103;&#32;&#75;&#32;&#60;&#106;&#111;&#114;&#103;&#107;&#64;&#106;&#111;&#114;&#103;&#107;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 15 Sep 2017 11:52:29 +0200</td></tr>

<tr>
 <td>changeset 22136</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d">fd85506c79b1bbf409bd67c73bf4944ee4c2a07d</a></td>
</tr>



<tr>
<td>parent 22135</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/ebe355c1d925132c3dd4ce6acca6506079518d89">ebe355c1d925132c3dd4ce6acca6506079518d89</a>
</td>
</tr>

<tr>
<td>child 22137</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/4600e944bce2589ca1d4f0881b246b4e8897f7a1">4600e944bce2589ca1d4f0881b246b4e8897f7a1</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=fd85506c79b1bbf409bd67c73bf4944ee4c2a07d">13512</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Fri, 15 Sep 2017 09:57:41 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@fd85506c79b1 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=fd85506c79b1bbf409bd67c73bf4944ee4c2a07d">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=fd85506c79b1bbf409bd67c73bf4944ee4c2a07d&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=fd85506c79b1bbf409bd67c73bf4944ee4c2a07d&newProject=comm-central&newRevision=fd85506c79b1bbf409bd67c73bf4944ee4c2a07d&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=fd85506c79b1bbf409bd67c73bf4944ee4c2a07d&newProject=comm-central&newRevision=fd85506c79b1bbf409bd67c73bf4944ee4c2a07d&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=fd85506c79b1bbf409bd67c73bf4944ee4c2a07d&newProject=comm-central&newRevision=fd85506c79b1bbf409bd67c73bf4944ee4c2a07d&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28white-space-only%29&revcount=50">white-space-only</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399756">1399756</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399756">Bug 1399756</a> - remove trailing spaces in mailnews/base/util. rs=white-space-only</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsImapMoveCoalescer.cpp">mailnews/base/util/nsImapMoveCoalescer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsImapMoveCoalescer.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsImapMoveCoalescer.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsImapMoveCoalescer.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsImapMoveCoalescer.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsImapMoveCoalescer.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.cpp">mailnews/base/util/nsMsgCompressIStream.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.h">mailnews/base/util/nsMsgCompressIStream.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressIStream.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressOStream.cpp">mailnews/base/util/nsMsgCompressOStream.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressOStream.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressOStream.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressOStream.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressOStream.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgCompressOStream.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.cpp">mailnews/base/util/nsMsgDBFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.h">mailnews/base/util/nsMsgDBFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgDBFolder.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.cpp">mailnews/base/util/nsMsgFileStream.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.h">mailnews/base/util/nsMsgFileStream.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgFileStream.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.cpp">mailnews/base/util/nsMsgI18N.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.h">mailnews/base/util/nsMsgI18N.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgI18N.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIdentity.h">mailnews/base/util/nsMsgIdentity.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIdentity.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIdentity.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIdentity.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIdentity.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIdentity.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIncomingServer.h">mailnews/base/util/nsMsgIncomingServer.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIncomingServer.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIncomingServer.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIncomingServer.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIncomingServer.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgIncomingServer.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.cpp">mailnews/base/util/nsMsgKeySet.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.h">mailnews/base/util/nsMsgKeySet.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgKeySet.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.cpp">mailnews/base/util/nsMsgLineBuffer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.h">mailnews/base/util/nsMsgLineBuffer.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgLineBuffer.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgProtocol.h">mailnews/base/util/nsMsgProtocol.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgProtocol.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgProtocol.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgProtocol.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgProtocol.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgProtocol.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgReadStateTxn.cpp">mailnews/base/util/nsMsgReadStateTxn.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgReadStateTxn.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgReadStateTxn.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgReadStateTxn.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgReadStateTxn.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgReadStateTxn.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.cpp">mailnews/base/util/nsMsgTxn.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.h">mailnews/base/util/nsMsgTxn.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgTxn.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgUtils.h">mailnews/base/util/nsMsgUtils.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgUtils.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgUtils.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgUtils.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgUtils.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsMsgUtils.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.cpp">mailnews/base/util/nsStopwatch.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.cpp">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.cpp">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.cpp">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.cpp">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.h">mailnews/base/util/nsStopwatch.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.h">file</a> |
<a href="/comm-central/annotate/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.h">annotate</a> |
<a href="/comm-central/diff/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.h">diff</a> |
<a href="/comm-central/comparison/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.h">comparison</a> |
<a href="/comm-central/log/fd85506c79b1bbf409bd67c73bf4944ee4c2a07d/mailnews/base/util/nsStopwatch.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/base/util/nsImapMoveCoalescer.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/base/util/nsImapMoveCoalescer.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -19,17 +19,17 @@</span>
<a href="#l1.4"></a><span id="l1.4"> #include &quot;nsArrayUtils.h&quot;</span>
<a href="#l1.5"></a><span id="l1.5"> #include &quot;nsComponentManagerUtils.h&quot;</span>
<a href="#l1.6"></a><span id="l1.6"> #include &quot;mozilla/ArrayUtils.h&quot;</span>
<a href="#l1.7"></a><span id="l1.7"> </span>
<a href="#l1.8"></a><span id="l1.8"> NS_IMPL_ISUPPORTS(nsImapMoveCoalescer, nsIUrlListener)</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10"> nsImapMoveCoalescer::nsImapMoveCoalescer(nsIMsgFolder *sourceFolder, nsIMsgWindow *msgWindow)</span>
<a href="#l1.11"></a><span id="l1.11"> {</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  m_sourceFolder = sourceFolder; </span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  m_sourceFolder = sourceFolder;</span>
<a href="#l1.14"></a><span id="l1.14">   m_msgWindow = msgWindow;</span>
<a href="#l1.15"></a><span id="l1.15">   m_hasPendingMoves = false;</span>
<a href="#l1.16"></a><span id="l1.16"> }</span>
<a href="#l1.17"></a><span id="l1.17"> </span>
<a href="#l1.18"></a><span id="l1.18"> nsImapMoveCoalescer::~nsImapMoveCoalescer()</span>
<a href="#l1.19"></a><span id="l1.19"> {</span>
<a href="#l1.20"></a><span id="l1.20"> }</span>
<a href="#l1.21"></a><span id="l1.21"> </span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -160,17 +160,17 @@ nsTArray&lt;nsMsgKey&gt; *nsImapMoveCoalescer:</span>
<a href="#l1.23"></a><span id="l1.23">   NS_ASSERTION(keyArrayIndex &lt; MOZ_ARRAY_LENGTH(m_keyBuckets), &quot;invalid index&quot;);</span>
<a href="#l1.24"></a><span id="l1.24"> </span>
<a href="#l1.25"></a><span id="l1.25">   return keyArrayIndex &lt; mozilla::ArrayLength(m_keyBuckets) ?</span>
<a href="#l1.26"></a><span id="l1.26">            &amp;(m_keyBuckets[keyArrayIndex]) : nullptr;</span>
<a href="#l1.27"></a><span id="l1.27"> }</span>
<a href="#l1.28"></a><span id="l1.28"> </span>
<a href="#l1.29"></a><span id="l1.29"> NS_IMPL_ISUPPORTS(nsMoveCoalescerCopyListener, nsIMsgCopyServiceListener)</span>
<a href="#l1.30"></a><span id="l1.30"> </span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-nsMoveCoalescerCopyListener::nsMoveCoalescerCopyListener(nsImapMoveCoalescer * coalescer, </span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+nsMoveCoalescerCopyListener::nsMoveCoalescerCopyListener(nsImapMoveCoalescer * coalescer,</span>
<a href="#l1.33"></a><span id="l1.33">                                                          nsIMsgFolder *destFolder)</span>
<a href="#l1.34"></a><span id="l1.34"> {</span>
<a href="#l1.35"></a><span id="l1.35">   m_destFolder = destFolder;</span>
<a href="#l1.36"></a><span id="l1.36">   m_coalescer = coalescer;</span>
<a href="#l1.37"></a><span id="l1.37"> }</span>
<a href="#l1.38"></a><span id="l1.38"> </span>
<a href="#l1.39"></a><span id="l1.39"> nsMoveCoalescerCopyListener::~nsMoveCoalescerCopyListener()</span>
<a href="#l1.40"></a><span id="l1.40"> {</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineat">@@ -208,17 +208,17 @@ NS_IMETHODIMP nsMoveCoalescerCopyListene</span>
<a href="#l1.42"></a><span id="l1.42">     // if the dest folder is imap, update it.</span>
<a href="#l1.43"></a><span id="l1.43">     nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(m_destFolder);</span>
<a href="#l1.44"></a><span id="l1.44">     if (imapFolder)</span>
<a href="#l1.45"></a><span id="l1.45">     {</span>
<a href="#l1.46"></a><span id="l1.46">       uint32_t folderFlags;</span>
<a href="#l1.47"></a><span id="l1.47">       m_destFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l1.48"></a><span id="l1.48">       if (!(folderFlags &amp; (nsMsgFolderFlags::Junk | nsMsgFolderFlags::Trash)))</span>
<a href="#l1.49"></a><span id="l1.49">       {</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-        nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv); </span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+        nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l1.52"></a><span id="l1.52">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.53"></a><span id="l1.53">         nsCOMPtr &lt;nsIURI&gt; url;</span>
<a href="#l1.54"></a><span id="l1.54">         nsCOMPtr &lt;nsIUrlListener&gt; listener = do_QueryInterface(m_coalescer);</span>
<a href="#l1.55"></a><span id="l1.55">         rv = imapService-&gt;SelectFolder(m_destFolder, listener, nullptr, getter_AddRefs(url));</span>
<a href="#l1.56"></a><span id="l1.56">       }</span>
<a href="#l1.57"></a><span id="l1.57">     }</span>
<a href="#l1.58"></a><span id="l1.58">     else // give junk filters a chance to run on new msgs in destination local folder</span>
<a href="#l1.59"></a><span id="l1.59">     {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/base/util/nsMsgCompressIStream.cpp</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgCompressIStream.cpp</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -41,17 +41,17 @@ nsresult nsMsgCompressIStream::InitInput</span>
<a href="#l2.4"></a><span id="l2.4">   if (!m_databuf)</span>
<a href="#l2.5"></a><span id="l2.5">     return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l2.6"></a><span id="l2.6"> </span>
<a href="#l2.7"></a><span id="l2.7">   // set up zlib object</span>
<a href="#l2.8"></a><span id="l2.8">   m_zstream.zalloc = Z_NULL;</span>
<a href="#l2.9"></a><span id="l2.9">   m_zstream.zfree = Z_NULL;</span>
<a href="#l2.10"></a><span id="l2.10">   m_zstream.opaque = Z_NULL;</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  // http://zlib.net/manual.html is rather silent on the topic, but </span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  // http://zlib.net/manual.html is rather silent on the topic, but</span>
<a href="#l2.14"></a><span id="l2.14">   // perl's Compress::Raw::Zlib manual says:</span>
<a href="#l2.15"></a><span id="l2.15">   // -WindowBits</span>
<a href="#l2.16"></a><span id="l2.16">   //  To compress an RFC 1951 data stream, set WindowBits to -MAX_WBITS.</span>
<a href="#l2.17"></a><span id="l2.17">   if (inflateInit2(&amp;m_zstream, -MAX_WBITS) != Z_OK)</span>
<a href="#l2.18"></a><span id="l2.18">     return NS_ERROR_FAILURE;</span>
<a href="#l2.19"></a><span id="l2.19"> </span>
<a href="#l2.20"></a><span id="l2.20">   m_iStream = rawStream;</span>
<a href="#l2.21"></a><span id="l2.21"> </span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -60,31 +60,31 @@ nsresult nsMsgCompressIStream::InitInput</span>
<a href="#l2.23"></a><span id="l2.23"> </span>
<a href="#l2.24"></a><span id="l2.24"> nsresult nsMsgCompressIStream::DoInflation()</span>
<a href="#l2.25"></a><span id="l2.25"> {</span>
<a href="#l2.26"></a><span id="l2.26">   // if there's something in the input buffer of the zstream, process it.</span>
<a href="#l2.27"></a><span id="l2.27">   m_zstream.next_out = (Bytef *) m_databuf.get();</span>
<a href="#l2.28"></a><span id="l2.28">   m_zstream.avail_out = BUFFER_SIZE;</span>
<a href="#l2.29"></a><span id="l2.29">   int zr = inflate(&amp;m_zstream, Z_SYNC_FLUSH);</span>
<a href="#l2.30"></a><span id="l2.30"> </span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-  // inflate() should normally be called until it returns </span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+  // inflate() should normally be called until it returns</span>
<a href="#l2.33"></a><span id="l2.33">   // Z_STREAM_END or an error, and Z_BUF_ERROR just means</span>
<a href="#l2.34"></a><span id="l2.34">   // unable to progress any further (possible if we filled</span>
<a href="#l2.35"></a><span id="l2.35">   // an output buffer exactly)</span>
<a href="#l2.36"></a><span id="l2.36">   if (zr == Z_BUF_ERROR || zr == Z_STREAM_END)</span>
<a href="#l2.37"></a><span id="l2.37">     zr = Z_OK;</span>
<a href="#l2.38"></a><span id="l2.38"> </span>
<a href="#l2.39"></a><span id="l2.39">   // otherwise it's an error</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineminus">-  if (zr != Z_OK) </span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+  if (zr != Z_OK)</span>
<a href="#l2.42"></a><span id="l2.42">     return NS_ERROR_FAILURE;</span>
<a href="#l2.43"></a><span id="l2.43"> </span>
<a href="#l2.44"></a><span id="l2.44">   // http://www.zlib.net/manual.html says:</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineminus">-  // If inflate returns Z_OK and with zero avail_out, it must be called </span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+  // If inflate returns Z_OK and with zero avail_out, it must be called</span>
<a href="#l2.47"></a><span id="l2.47">   // again after making room in the output buffer because there might be</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineminus">-  // more output pending. </span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+  // more output pending.</span>
<a href="#l2.50"></a><span id="l2.50">   m_inflateAgain = m_zstream.avail_out ? false : true;</span>
<a href="#l2.51"></a><span id="l2.51"> </span>
<a href="#l2.52"></a><span id="l2.52">   // set the pointer to the start of the buffer, and the count to how</span>
<a href="#l2.53"></a><span id="l2.53">   // based on how many bytes are left unconsumed.</span>
<a href="#l2.54"></a><span id="l2.54">   m_dataptr = m_databuf.get();</span>
<a href="#l2.55"></a><span id="l2.55">   m_dataleft = BUFFER_SIZE - m_zstream.avail_out;</span>
<a href="#l2.56"></a><span id="l2.56"> </span>
<a href="#l2.57"></a><span id="l2.57">   return NS_OK;</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineat">@@ -119,67 +119,67 @@ NS_IMETHODIMP nsMsgCompressIStream::Clos</span>
<a href="#l2.59"></a><span id="l2.59">   m_dataleft = 0;</span>
<a href="#l2.60"></a><span id="l2.60"> </span>
<a href="#l2.61"></a><span id="l2.61">   return rv;</span>
<a href="#l2.62"></a><span id="l2.62"> }</span>
<a href="#l2.63"></a><span id="l2.63"> </span>
<a href="#l2.64"></a><span id="l2.64"> /* unsigned long long available (); */</span>
<a href="#l2.65"></a><span id="l2.65"> NS_IMETHODIMP nsMsgCompressIStream::Available(uint64_t *aResult)</span>
<a href="#l2.66"></a><span id="l2.66"> {</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineminus">-  if (!m_iStream) </span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+  if (!m_iStream)</span>
<a href="#l2.69"></a><span id="l2.69">     return NS_BASE_STREAM_CLOSED;</span>
<a href="#l2.70"></a><span id="l2.70"> </span>
<a href="#l2.71"></a><span id="l2.71">   // check if there's anything still in flight</span>
<a href="#l2.72"></a><span id="l2.72">   if (!m_dataleft &amp;&amp; m_inflateAgain)</span>
<a href="#l2.73"></a><span id="l2.73">   {</span>
<a href="#l2.74"></a><span id="l2.74">     nsresult rv = DoInflation();</span>
<a href="#l2.75"></a><span id="l2.75">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l2.76"></a><span id="l2.76">   }</span>
<a href="#l2.77"></a><span id="l2.77"> </span>
<a href="#l2.78"></a><span id="l2.78">   // we'll be returning this many to the next read, guaranteed</span>
<a href="#l2.79"></a><span id="l2.79">   if (m_dataleft)</span>
<a href="#l2.80"></a><span id="l2.80">   {</span>
<a href="#l2.81"></a><span id="l2.81">     *aResult = m_dataleft;</span>
<a href="#l2.82"></a><span id="l2.82">     return NS_OK;</span>
<a href="#l2.83"></a><span id="l2.83">   }</span>
<a href="#l2.84"></a><span id="l2.84"> </span>
<a href="#l2.85"></a><span id="l2.85" class="difflineminus">-  // this value isn't accurate, but will give a good true/false </span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+  // this value isn't accurate, but will give a good true/false</span>
<a href="#l2.87"></a><span id="l2.87">   // indication for idle purposes, and next read will fill</span>
<a href="#l2.88"></a><span id="l2.88">   // m_dataleft, so we'll have an accurate count for the next call.</span>
<a href="#l2.89"></a><span id="l2.89">   return m_iStream-&gt;Available(aResult);</span>
<a href="#l2.90"></a><span id="l2.90"> }</span>
<a href="#l2.91"></a><span id="l2.91"> </span>
<a href="#l2.92"></a><span id="l2.92"> /* [noscript] unsigned long read (in charPtr aBuf, in unsigned long aCount); */</span>
<a href="#l2.93"></a><span id="l2.93"> NS_IMETHODIMP nsMsgCompressIStream::Read(char * aBuf, uint32_t aCount, uint32_t *aResult)</span>
<a href="#l2.94"></a><span id="l2.94"> {</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineminus">-  if (!m_iStream) </span>
<a href="#l2.96"></a><span id="l2.96" class="difflineplus">+  if (!m_iStream)</span>
<a href="#l2.97"></a><span id="l2.97">   {</span>
<a href="#l2.98"></a><span id="l2.98">     *aResult = 0;</span>
<a href="#l2.99"></a><span id="l2.99">     return NS_OK;</span>
<a href="#l2.100"></a><span id="l2.100">   }</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineminus">-  </span>
<a href="#l2.102"></a><span id="l2.102" class="difflineplus">+</span>
<a href="#l2.103"></a><span id="l2.103">   // There are two stages of buffering:</span>
<a href="#l2.104"></a><span id="l2.104">   // * m_zbuf contains the compressed data from the remote server</span>
<a href="#l2.105"></a><span id="l2.105">   // * m_databuf contains the uncompressed raw bytes for consumption</span>
<a href="#l2.106"></a><span id="l2.106">   //   by the local client.</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineminus">-  // </span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+  //</span>
<a href="#l2.109"></a><span id="l2.109">   // Each buffer will only be filled when the following buffers</span>
<a href="#l2.110"></a><span id="l2.110">   // have been entirely consumed.</span>
<a href="#l2.111"></a><span id="l2.111">   //</span>
<a href="#l2.112"></a><span id="l2.112">   // m_dataptr and m_dataleft are respectively a pointer to the</span>
<a href="#l2.113"></a><span id="l2.113">   // unconsumed portion of m_databuf and the number of bytes</span>
<a href="#l2.114"></a><span id="l2.114">   // of uncompressed data remaining in m_databuf.</span>
<a href="#l2.115"></a><span id="l2.115">   //</span>
<a href="#l2.116"></a><span id="l2.116">   // both buffers have a maximum size of BUFFER_SIZE, so it is</span>
<a href="#l2.117"></a><span id="l2.117">   // possible that multiple inflate passes will be required to</span>
<a href="#l2.118"></a><span id="l2.118">   // consume all of m_zbuf.</span>
<a href="#l2.119"></a><span id="l2.119">   while (!m_dataleft)</span>
<a href="#l2.120"></a><span id="l2.120">   {</span>
<a href="#l2.121"></a><span id="l2.121">     // get some more data if we don't already have any</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineminus">-    if (!m_inflateAgain) </span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+    if (!m_inflateAgain)</span>
<a href="#l2.124"></a><span id="l2.124">     {</span>
<a href="#l2.125"></a><span id="l2.125">       uint32_t bytesRead;</span>
<a href="#l2.126"></a><span id="l2.126">       nsresult rv = m_iStream-&gt;Read(m_zbuf.get(), (uint32_t)BUFFER_SIZE, &amp;bytesRead);</span>
<a href="#l2.127"></a><span id="l2.127">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l2.128"></a><span id="l2.128">       if (!bytesRead)</span>
<a href="#l2.129"></a><span id="l2.129">         return NS_BASE_STREAM_CLOSED;</span>
<a href="#l2.130"></a><span id="l2.130">       m_zstream.next_in = (Bytef *) m_zbuf.get();</span>
<a href="#l2.131"></a><span id="l2.131">       m_zstream.avail_in = bytesRead;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/base/util/nsMsgCompressIStream.h</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgCompressIStream.h</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -10,17 +10,17 @@</span>
<a href="#l3.4"></a><span id="l3.4"> #include &quot;zlib.h&quot;</span>
<a href="#l3.5"></a><span id="l3.5"> </span>
<a href="#l3.6"></a><span id="l3.6"> class NS_MSG_BASE nsMsgCompressIStream final : public nsIAsyncInputStream</span>
<a href="#l3.7"></a><span id="l3.7"> {</span>
<a href="#l3.8"></a><span id="l3.8"> public:</span>
<a href="#l3.9"></a><span id="l3.9">   nsMsgCompressIStream();</span>
<a href="#l3.10"></a><span id="l3.10"> </span>
<a href="#l3.11"></a><span id="l3.11">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-    </span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+</span>
<a href="#l3.14"></a><span id="l3.14">   NS_DECL_NSIINPUTSTREAM</span>
<a href="#l3.15"></a><span id="l3.15">   NS_DECL_NSIASYNCINPUTSTREAM</span>
<a href="#l3.16"></a><span id="l3.16"> </span>
<a href="#l3.17"></a><span id="l3.17">   nsresult InitInputStream(nsIInputStream *rawStream);</span>
<a href="#l3.18"></a><span id="l3.18"> </span>
<a href="#l3.19"></a><span id="l3.19"> protected:</span>
<a href="#l3.20"></a><span id="l3.20">   ~nsMsgCompressIStream();</span>
<a href="#l3.21"></a><span id="l3.21">   nsresult DoInflation();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/base/util/nsMsgCompressOStream.cpp</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgCompressOStream.cpp</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -35,17 +35,17 @@ nsresult nsMsgCompressOStream::InitOutpu</span>
<a href="#l4.4"></a><span id="l4.4">   m_zstream.zalloc = Z_NULL;</span>
<a href="#l4.5"></a><span id="l4.5">   m_zstream.zfree = Z_NULL;</span>
<a href="#l4.6"></a><span id="l4.6">   m_zstream.opaque = Z_NULL;</span>
<a href="#l4.7"></a><span id="l4.7"> </span>
<a href="#l4.8"></a><span id="l4.8">   // http://zlib.net/manual.html is rather silent on the topic, but</span>
<a href="#l4.9"></a><span id="l4.9">   // perl's Compress::Raw::Zlib manual says:</span>
<a href="#l4.10"></a><span id="l4.10">   // -WindowBits [...]</span>
<a href="#l4.11"></a><span id="l4.11">   //  To compress an RFC 1951 data stream, set WindowBits to -MAX_WBITS.</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-  if (deflateInit2(&amp;m_zstream, Z_DEFAULT_COMPRESSION, Z_DEFLATED, </span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+  if (deflateInit2(&amp;m_zstream, Z_DEFAULT_COMPRESSION, Z_DEFLATED,</span>
<a href="#l4.14"></a><span id="l4.14">                    -MAX_WBITS, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY) != Z_OK)</span>
<a href="#l4.15"></a><span id="l4.15">     return NS_ERROR_FAILURE;</span>
<a href="#l4.16"></a><span id="l4.16"> </span>
<a href="#l4.17"></a><span id="l4.17">   m_oStream = rawStream;</span>
<a href="#l4.18"></a><span id="l4.18"> </span>
<a href="#l4.19"></a><span id="l4.19">   return NS_OK;</span>
<a href="#l4.20"></a><span id="l4.20"> }</span>
<a href="#l4.21"></a><span id="l4.21"> </span>
<a href="#l4.22"></a><span id="l4.22" class="difflineat">@@ -99,33 +99,33 @@ nsMsgCompressOStream::Write(const char *</span>
<a href="#l4.23"></a><span id="l4.23">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.24"></a><span id="l4.24">       if (!out_result)</span>
<a href="#l4.25"></a><span id="l4.25"> 	return NS_BASE_STREAM_CLOSED;</span>
<a href="#l4.26"></a><span id="l4.26">       out_size -= out_result;</span>
<a href="#l4.27"></a><span id="l4.27">       out_buf += out_result;</span>
<a href="#l4.28"></a><span id="l4.28">     }</span>
<a href="#l4.29"></a><span id="l4.29"> </span>
<a href="#l4.30"></a><span id="l4.30">   // http://www.zlib.net/manual.html says:</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">-  // If deflate returns with avail_out == 0, this function must be </span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+  // If deflate returns with avail_out == 0, this function must be</span>
<a href="#l4.33"></a><span id="l4.33">   // called again with the same value of the flush parameter and</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineminus">-  // more output space (updated avail_out), until the flush is </span>
<a href="#l4.35"></a><span id="l4.35" class="difflineminus">-  // complete (deflate returns with non-zero avail_out). </span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+  // more output space (updated avail_out), until the flush is</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+  // complete (deflate returns with non-zero avail_out).</span>
<a href="#l4.38"></a><span id="l4.38">   } while (!m_zstream.avail_out);</span>
<a href="#l4.39"></a><span id="l4.39"> </span>
<a href="#l4.40"></a><span id="l4.40">   *result = count;</span>
<a href="#l4.41"></a><span id="l4.41"> </span>
<a href="#l4.42"></a><span id="l4.42">   return NS_OK;</span>
<a href="#l4.43"></a><span id="l4.43"> }</span>
<a href="#l4.44"></a><span id="l4.44"> </span>
<a href="#l4.45"></a><span id="l4.45"> NS_IMETHODIMP</span>
<a href="#l4.46"></a><span id="l4.46"> nsMsgCompressOStream::Flush(void)</span>
<a href="#l4.47"></a><span id="l4.47"> {</span>
<a href="#l4.48"></a><span id="l4.48">   if (!m_oStream)</span>
<a href="#l4.49"></a><span id="l4.49">     return NS_BASE_STREAM_CLOSED;</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineminus">-  </span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+</span>
<a href="#l4.52"></a><span id="l4.52">   return m_oStream-&gt;Flush();</span>
<a href="#l4.53"></a><span id="l4.53"> }</span>
<a href="#l4.54"></a><span id="l4.54"> </span>
<a href="#l4.55"></a><span id="l4.55"> NS_IMETHODIMP</span>
<a href="#l4.56"></a><span id="l4.56"> nsMsgCompressOStream::WriteFrom(nsIInputStream *inStr, uint32_t count, uint32_t *_retval)</span>
<a href="#l4.57"></a><span id="l4.57"> {</span>
<a href="#l4.58"></a><span id="l4.58">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l4.59"></a><span id="l4.59"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -361,17 +361,17 @@ NS_IMETHODIMP nsMsgDBFolder::RemoveBacku</span>
<a href="#l5.4"></a><span id="l5.4"> </span>
<a href="#l5.5"></a><span id="l5.5">   if (mBackupDatabase)</span>
<a href="#l5.6"></a><span id="l5.6">   {</span>
<a href="#l5.7"></a><span id="l5.7">     mBackupDatabase-&gt;ForceClosed();</span>
<a href="#l5.8"></a><span id="l5.8">     mBackupDatabase = nullptr;</span>
<a href="#l5.9"></a><span id="l5.9">   }</span>
<a href="#l5.10"></a><span id="l5.10"> </span>
<a href="#l5.11"></a><span id="l5.11">   return backupDBFile-&gt;Remove(false);</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-}  </span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+}</span>
<a href="#l5.14"></a><span id="l5.14"> </span>
<a href="#l5.15"></a><span id="l5.15"> NS_IMETHODIMP nsMsgDBFolder::StartFolderLoading(void)</span>
<a href="#l5.16"></a><span id="l5.16"> {</span>
<a href="#l5.17"></a><span id="l5.17">   if(mDatabase)</span>
<a href="#l5.18"></a><span id="l5.18">     mDatabase-&gt;RemoveListener(this);</span>
<a href="#l5.19"></a><span id="l5.19">   mAddListener = false;</span>
<a href="#l5.20"></a><span id="l5.20">   return NS_OK;</span>
<a href="#l5.21"></a><span id="l5.21"> }</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineat">@@ -1009,17 +1009,17 @@ nsMsgDBFolder::OnReadChanged(nsIDBChange</span>
<a href="#l5.23"></a><span id="l5.23"> NS_IMETHODIMP</span>
<a href="#l5.24"></a><span id="l5.24"> nsMsgDBFolder::OnJunkScoreChanged(nsIDBChangeListener * aInstigator)</span>
<a href="#l5.25"></a><span id="l5.25"> {</span>
<a href="#l5.26"></a><span id="l5.26">   NotifyFolderEvent(kJunkStatusChanged);</span>
<a href="#l5.27"></a><span id="l5.27">   return NS_OK;</span>
<a href="#l5.28"></a><span id="l5.28"> }</span>
<a href="#l5.29"></a><span id="l5.29"> </span>
<a href="#l5.30"></a><span id="l5.30"> NS_IMETHODIMP</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineminus">-nsMsgDBFolder::OnHdrPropertyChanged(nsIMsgDBHdr *aHdrToChange, bool aPreChange, uint32_t *aStatus, </span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+nsMsgDBFolder::OnHdrPropertyChanged(nsIMsgDBHdr *aHdrToChange, bool aPreChange, uint32_t *aStatus,</span>
<a href="#l5.33"></a><span id="l5.33">                                    nsIDBChangeListener *aInstigator)</span>
<a href="#l5.34"></a><span id="l5.34"> {</span>
<a href="#l5.35"></a><span id="l5.35">   /* do nothing.  if you care about this, override it.*/</span>
<a href="#l5.36"></a><span id="l5.36">   return NS_OK;</span>
<a href="#l5.37"></a><span id="l5.37"> }</span>
<a href="#l5.38"></a><span id="l5.38"> </span>
<a href="#l5.39"></a><span id="l5.39"> // 1.  When the status of a message changes.</span>
<a href="#l5.40"></a><span id="l5.40"> NS_IMETHODIMP nsMsgDBFolder::OnHdrFlagsChanged(nsIMsgDBHdr *aHdrChanged, uint32_t aOldFlags, uint32_t aNewFlags,</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineat">@@ -2453,17 +2453,17 @@ nsMsgDBFolder::OnMessageClassified(const</span>
<a href="#l5.42"></a><span id="l5.42"> NS_IMETHODIMP</span>
<a href="#l5.43"></a><span id="l5.43"> nsMsgDBFolder::OnMessageTraitsClassified(const char *aMsgURI,</span>
<a href="#l5.44"></a><span id="l5.44">                                          uint32_t aTraitCount,</span>
<a href="#l5.45"></a><span id="l5.45">                                          uint32_t *aTraits,</span>
<a href="#l5.46"></a><span id="l5.46">                                          uint32_t *aPercents)</span>
<a href="#l5.47"></a><span id="l5.47"> {</span>
<a href="#l5.48"></a><span id="l5.48">   if (!aMsgURI) // This signifies end of batch</span>
<a href="#l5.49"></a><span id="l5.49">     return NS_OK; // We are not handling batching</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineminus">-  </span>
<a href="#l5.51"></a><span id="l5.51" class="difflineplus">+</span>
<a href="#l5.52"></a><span id="l5.52">   nsresult rv;</span>
<a href="#l5.53"></a><span id="l5.53">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l5.54"></a><span id="l5.54">   rv = GetMsgDBHdrFromURI(aMsgURI, getter_AddRefs(msgHdr));</span>
<a href="#l5.55"></a><span id="l5.55">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.56"></a><span id="l5.56"> </span>
<a href="#l5.57"></a><span id="l5.57">   nsMsgKey msgKey;</span>
<a href="#l5.58"></a><span id="l5.58">   rv = msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l5.59"></a><span id="l5.59">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineat">@@ -4170,17 +4170,17 @@ NS_IMETHODIMP nsMsgDBFolder::UpdateSumma</span>
<a href="#l5.61"></a><span id="l5.61"> {</span>
<a href="#l5.62"></a><span id="l5.62">   if (!mNotifyCountChanges)</span>
<a href="#l5.63"></a><span id="l5.63">     return NS_OK;</span>
<a href="#l5.64"></a><span id="l5.64"> </span>
<a href="#l5.65"></a><span id="l5.65">   int32_t oldUnreadMessages = mNumUnreadMessages + mNumPendingUnreadMessages;</span>
<a href="#l5.66"></a><span id="l5.66">   int32_t oldTotalMessages = mNumTotalMessages + mNumPendingTotalMessages;</span>
<a href="#l5.67"></a><span id="l5.67">   //We need to read this info from the database</span>
<a href="#l5.68"></a><span id="l5.68">   nsresult rv = ReadDBFolderInfo(force);</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineminus">-  </span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+</span>
<a href="#l5.71"></a><span id="l5.71">   if (NS_SUCCEEDED(rv))</span>
<a href="#l5.72"></a><span id="l5.72">   {</span>
<a href="#l5.73"></a><span id="l5.73">     int32_t newUnreadMessages = mNumUnreadMessages + mNumPendingUnreadMessages;</span>
<a href="#l5.74"></a><span id="l5.74">     int32_t newTotalMessages = mNumTotalMessages + mNumPendingTotalMessages;</span>
<a href="#l5.75"></a><span id="l5.75"> </span>
<a href="#l5.76"></a><span id="l5.76">     //Need to notify listeners that total count changed.</span>
<a href="#l5.77"></a><span id="l5.77">     if(oldTotalMessages != newTotalMessages)</span>
<a href="#l5.78"></a><span id="l5.78">       NotifyIntPropertyChanged(kTotalMessages, oldTotalMessages, newTotalMessages);</span>
<a href="#l5.79"></a><span id="l5.79" class="difflineat">@@ -4634,17 +4634,17 @@ NS_IMETHODIMP nsMsgDBFolder::SetBiffStat</span>
<a href="#l5.80"></a><span id="l5.80"> </span>
<a href="#l5.81"></a><span id="l5.81"> NS_IMETHODIMP nsMsgDBFolder::GetNumNewMessages(bool deep, int32_t *aNumNewMessages)</span>
<a href="#l5.82"></a><span id="l5.82"> {</span>
<a href="#l5.83"></a><span id="l5.83">   NS_ENSURE_ARG_POINTER(aNumNewMessages);</span>
<a href="#l5.84"></a><span id="l5.84"> </span>
<a href="#l5.85"></a><span id="l5.85">   int32_t numNewMessages = (!deep || ! (mFlags &amp; nsMsgFolderFlags::Virtual))</span>
<a href="#l5.86"></a><span id="l5.86">     ? mNumNewBiffMessages : 0;</span>
<a href="#l5.87"></a><span id="l5.87">   if (deep)</span>
<a href="#l5.88"></a><span id="l5.88" class="difflineminus">-  { </span>
<a href="#l5.89"></a><span id="l5.89" class="difflineplus">+  {</span>
<a href="#l5.90"></a><span id="l5.90">     int32_t count = mSubFolders.Count();</span>
<a href="#l5.91"></a><span id="l5.91">     for (int32_t i = 0; i &lt; count; i++)</span>
<a href="#l5.92"></a><span id="l5.92">     {</span>
<a href="#l5.93"></a><span id="l5.93">       int32_t num;</span>
<a href="#l5.94"></a><span id="l5.94">       mSubFolders[i]-&gt;GetNumNewMessages(deep, &amp;num);</span>
<a href="#l5.95"></a><span id="l5.95">       if (num &gt; 0) // it's legal for counts to be negative if we don't know</span>
<a href="#l5.96"></a><span id="l5.96">         numNewMessages += num;</span>
<a href="#l5.97"></a><span id="l5.97">     }</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineat">@@ -5394,17 +5394,17 @@ NS_IMETHODIMP nsMsgDBFolder::GetSortKey(</span>
<a href="#l5.99"></a><span id="l5.99">   orderString.Append(folderName);</span>
<a href="#l5.100"></a><span id="l5.100">   return CreateCollationKey(orderString, aKey, aLength);</span>
<a href="#l5.101"></a><span id="l5.101"> }</span>
<a href="#l5.102"></a><span id="l5.102"> </span>
<a href="#l5.103"></a><span id="l5.103"> nsresult</span>
<a href="#l5.104"></a><span id="l5.104"> nsMsgDBFolder::CreateCollationKey(const nsString &amp;aSource,  uint8_t **aKey, uint32_t *aLength)</span>
<a href="#l5.105"></a><span id="l5.105"> {</span>
<a href="#l5.106"></a><span id="l5.106">   NS_ENSURE_TRUE(gCollationKeyGenerator, NS_ERROR_NULL_POINTER);</span>
<a href="#l5.107"></a><span id="l5.107" class="difflineminus">-  return gCollationKeyGenerator-&gt;AllocateRawSortKey(nsICollation::kCollationCaseInSensitive, aSource, </span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+  return gCollationKeyGenerator-&gt;AllocateRawSortKey(nsICollation::kCollationCaseInSensitive, aSource,</span>
<a href="#l5.109"></a><span id="l5.109">                                                     aKey, aLength);</span>
<a href="#l5.110"></a><span id="l5.110"> }</span>
<a href="#l5.111"></a><span id="l5.111"> </span>
<a href="#l5.112"></a><span id="l5.112"> NS_IMETHODIMP nsMsgDBFolder::CompareSortKeys(nsIMsgFolder *aFolder, int32_t *sortOrder)</span>
<a href="#l5.113"></a><span id="l5.113"> {</span>
<a href="#l5.114"></a><span id="l5.114">   uint8_t *sortKey1=nullptr;</span>
<a href="#l5.115"></a><span id="l5.115">   uint8_t *sortKey2=nullptr;</span>
<a href="#l5.116"></a><span id="l5.116">   uint32_t sortKey1Length;</span>
<a href="#l5.117"></a><span id="l5.117" class="difflineat">@@ -5751,17 +5751,17 @@ NS_IMETHODIMP nsMsgDBFolder::ConvertMsgS</span>
<a href="#l5.118"></a><span id="l5.118"> </span>
<a href="#l5.119"></a><span id="l5.119"> nsresult nsMsgDBFolder::GetMsgPreviewTextFromStream(nsIMsgDBHdr *msgHdr, nsIInputStream *stream)</span>
<a href="#l5.120"></a><span id="l5.120"> {</span>
<a href="#l5.121"></a><span id="l5.121">   nsCString msgBody;</span>
<a href="#l5.122"></a><span id="l5.122">   nsAutoCString charset;</span>
<a href="#l5.123"></a><span id="l5.123">   msgHdr-&gt;GetCharset(getter_Copies(charset));</span>
<a href="#l5.124"></a><span id="l5.124">   nsAutoCString contentType;</span>
<a href="#l5.125"></a><span id="l5.125">   nsresult rv = GetMsgTextFromStream(stream, charset, 4096, 255, true, true, contentType, msgBody);</span>
<a href="#l5.126"></a><span id="l5.126" class="difflineminus">-  // replaces all tabs and line returns with a space, </span>
<a href="#l5.127"></a><span id="l5.127" class="difflineplus">+  // replaces all tabs and line returns with a space,</span>
<a href="#l5.128"></a><span id="l5.128">   // then trims off leading and trailing white space</span>
<a href="#l5.129"></a><span id="l5.129">   MsgCompressWhitespace(msgBody);</span>
<a href="#l5.130"></a><span id="l5.130">   msgHdr-&gt;SetStringProperty(&quot;preview&quot;, msgBody.get());</span>
<a href="#l5.131"></a><span id="l5.131">   return rv;</span>
<a href="#l5.132"></a><span id="l5.132"> }</span>
<a href="#l5.133"></a><span id="l5.133"> </span>
<a href="#l5.134"></a><span id="l5.134"> void nsMsgDBFolder::UpdateTimestamps(bool allowUndo)</span>
<a href="#l5.135"></a><span id="l5.135"> {</span>
<a href="#l5.136"></a><span id="l5.136" class="difflineat">@@ -5830,17 +5830,17 @@ NS_IMETHODIMP nsMsgDBFolder::AddKeywords</span>
<a href="#l5.137"></a><span id="l5.137">           keywords.Append(keywordArray[j]);</span>
<a href="#l5.138"></a><span id="l5.138">           addCount++;</span>
<a href="#l5.139"></a><span id="l5.139">         }</span>
<a href="#l5.140"></a><span id="l5.140">       }</span>
<a href="#l5.141"></a><span id="l5.141">       // avoid using the message key to set the string property, because</span>
<a href="#l5.142"></a><span id="l5.142">       // in the case of filters running on incoming pop3 mail with quarantining</span>
<a href="#l5.143"></a><span id="l5.143">       // turned on, the message key is wrong.</span>
<a href="#l5.144"></a><span id="l5.144">       mDatabase-&gt;SetStringPropertyByHdr(message, &quot;keywords&quot;, keywords.get());</span>
<a href="#l5.145"></a><span id="l5.145" class="difflineminus">-      </span>
<a href="#l5.146"></a><span id="l5.146" class="difflineplus">+</span>
<a href="#l5.147"></a><span id="l5.147">       if (addCount)</span>
<a href="#l5.148"></a><span id="l5.148">         NotifyPropertyFlagChanged(message, kKeywords, 0, addCount);</span>
<a href="#l5.149"></a><span id="l5.149">     }</span>
<a href="#l5.150"></a><span id="l5.150">   }</span>
<a href="#l5.151"></a><span id="l5.151">   return rv;</span>
<a href="#l5.152"></a><span id="l5.152"> }</span>
<a href="#l5.153"></a><span id="l5.153"> </span>
<a href="#l5.154"></a><span id="l5.154"> NS_IMETHODIMP nsMsgDBFolder::RemoveKeywordsFromMessages(nsIArray *aMessages, const nsACString&amp; aKeywords)</span>
<a href="#l5.155"></a><span id="l5.155" class="difflineat">@@ -5915,25 +5915,25 @@ NS_IMETHODIMP nsMsgDBFolder::GetCustomId</span>
<a href="#l5.156"></a><span id="l5.156"> NS_IMETHODIMP nsMsgDBFolder::GetProcessingFlags(nsMsgKey aKey, uint32_t *aFlags)</span>
<a href="#l5.157"></a><span id="l5.157"> {</span>
<a href="#l5.158"></a><span id="l5.158">   NS_ENSURE_ARG_POINTER(aFlags);</span>
<a href="#l5.159"></a><span id="l5.159">   *aFlags = 0;</span>
<a href="#l5.160"></a><span id="l5.160">   for (uint32_t i = 0; i &lt; nsMsgProcessingFlags::NumberOfFlags; i++)</span>
<a href="#l5.161"></a><span id="l5.161">     if (mProcessingFlag[i].keys &amp;&amp; mProcessingFlag[i].keys-&gt;IsMember(aKey))</span>
<a href="#l5.162"></a><span id="l5.162">       *aFlags |= mProcessingFlag[i].bit;</span>
<a href="#l5.163"></a><span id="l5.163">   return NS_OK;</span>
<a href="#l5.164"></a><span id="l5.164" class="difflineminus">-}  </span>
<a href="#l5.165"></a><span id="l5.165" class="difflineplus">+}</span>
<a href="#l5.166"></a><span id="l5.166"> </span>
<a href="#l5.167"></a><span id="l5.167"> NS_IMETHODIMP nsMsgDBFolder::OrProcessingFlags(nsMsgKey aKey, uint32_t mask)</span>
<a href="#l5.168"></a><span id="l5.168"> {</span>
<a href="#l5.169"></a><span id="l5.169">   for (uint32_t i = 0; i &lt; nsMsgProcessingFlags::NumberOfFlags; i++)</span>
<a href="#l5.170"></a><span id="l5.170">     if (mProcessingFlag[i].bit &amp; mask &amp;&amp; mProcessingFlag[i].keys)</span>
<a href="#l5.171"></a><span id="l5.171">       mProcessingFlag[i].keys-&gt;Add(aKey);</span>
<a href="#l5.172"></a><span id="l5.172">   return NS_OK;</span>
<a href="#l5.173"></a><span id="l5.173" class="difflineminus">-}  </span>
<a href="#l5.174"></a><span id="l5.174" class="difflineplus">+}</span>
<a href="#l5.175"></a><span id="l5.175"> </span>
<a href="#l5.176"></a><span id="l5.176"> NS_IMETHODIMP nsMsgDBFolder::AndProcessingFlags(nsMsgKey aKey, uint32_t mask)</span>
<a href="#l5.177"></a><span id="l5.177"> {</span>
<a href="#l5.178"></a><span id="l5.178">   for (uint32_t i = 0; i &lt; nsMsgProcessingFlags::NumberOfFlags; i++)</span>
<a href="#l5.179"></a><span id="l5.179">     if (!(mProcessingFlag[i].bit &amp; mask) &amp;&amp; mProcessingFlag[i].keys)</span>
<a href="#l5.180"></a><span id="l5.180">       mProcessingFlag[i].keys-&gt;Remove(aKey);</span>
<a href="#l5.181"></a><span id="l5.181">   return NS_OK;</span>
<a href="#l5.182"></a><span id="l5.182"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -3,17 +3,17 @@</span>
<a href="#l6.4"></a><span id="l6.4">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l6.5"></a><span id="l6.5">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l6.6"></a><span id="l6.6"> </span>
<a href="#l6.7"></a><span id="l6.7"> #ifndef nsMsgDBFolder_h__</span>
<a href="#l6.8"></a><span id="l6.8"> #define nsMsgDBFolder_h__</span>
<a href="#l6.9"></a><span id="l6.9"> </span>
<a href="#l6.10"></a><span id="l6.10"> #include &quot;mozilla/Attributes.h&quot;</span>
<a href="#l6.11"></a><span id="l6.11"> #include &quot;msgCore.h&quot;</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-#include &quot;nsIMsgFolder.h&quot; </span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+#include &quot;nsIMsgFolder.h&quot;</span>
<a href="#l6.14"></a><span id="l6.14"> #include &quot;nsRDFResource.h&quot;</span>
<a href="#l6.15"></a><span id="l6.15"> #include &quot;nsIDBFolderInfo.h&quot;</span>
<a href="#l6.16"></a><span id="l6.16"> #include &quot;nsIMsgDatabase.h&quot;</span>
<a href="#l6.17"></a><span id="l6.17"> #include &quot;nsIMsgIncomingServer.h&quot;</span>
<a href="#l6.18"></a><span id="l6.18"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l6.19"></a><span id="l6.19"> #include &quot;nsIDBChangeListener.h&quot;</span>
<a href="#l6.20"></a><span id="l6.20"> #include &quot;nsIMsgPluggableStore.h&quot;</span>
<a href="#l6.21"></a><span id="l6.21"> #include &quot;nsIURL.h&quot;</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineat">@@ -67,41 +67,41 @@ extern const nsLiteralCString kFolderCre</span>
<a href="#l6.23"></a><span id="l6.23"> extern const nsLiteralCString kFolderLoaded;</span>
<a href="#l6.24"></a><span id="l6.24"> extern const nsLiteralCString kNumNewBiffMessages;</span>
<a href="#l6.25"></a><span id="l6.25"> extern const nsLiteralCString kRenameCompleted;</span>
<a href="#l6.26"></a><span id="l6.26"> </span>
<a href="#l6.27"></a><span id="l6.27"> class nsIMsgFolderCacheElement;</span>
<a href="#l6.28"></a><span id="l6.28"> class nsICollation;</span>
<a href="#l6.29"></a><span id="l6.29"> class nsMsgKeySetU;</span>
<a href="#l6.30"></a><span id="l6.30"> </span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">- /* </span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+ /*</span>
<a href="#l6.33"></a><span id="l6.33">   * nsMsgDBFolder</span>
<a href="#l6.34"></a><span id="l6.34">   * class derived from nsMsgFolder for those folders that use an nsIMsgDatabase</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineminus">-  */ </span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+  */</span>
<a href="#l6.37"></a><span id="l6.37"> </span>
<a href="#l6.38"></a><span id="l6.38"> #undef IMETHOD_VISIBILITY</span>
<a href="#l6.39"></a><span id="l6.39"> #define IMETHOD_VISIBILITY NS_VISIBILITY_DEFAULT</span>
<a href="#l6.40"></a><span id="l6.40"> </span>
<a href="#l6.41"></a><span id="l6.41"> class NS_MSG_BASE nsMsgDBFolder: public nsRDFResource,</span>
<a href="#l6.42"></a><span id="l6.42">                                  public nsSupportsWeakReference,</span>
<a href="#l6.43"></a><span id="l6.43">                                  public nsIMsgFolder,</span>
<a href="#l6.44"></a><span id="l6.44">                                  public nsIDBChangeListener,</span>
<a href="#l6.45"></a><span id="l6.45">                                  public nsIUrlListener,</span>
<a href="#l6.46"></a><span id="l6.46">                                  public nsIJunkMailClassificationListener,</span>
<a href="#l6.47"></a><span id="l6.47">                                  public nsIMsgTraitClassificationListener</span>
<a href="#l6.48"></a><span id="l6.48"> {</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineminus">-public: </span>
<a href="#l6.50"></a><span id="l6.50" class="difflineplus">+public:</span>
<a href="#l6.51"></a><span id="l6.51">   nsMsgDBFolder(void);</span>
<a href="#l6.52"></a><span id="l6.52">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l6.53"></a><span id="l6.53">   NS_DECL_NSIMSGFOLDER</span>
<a href="#l6.54"></a><span id="l6.54">   NS_DECL_NSIDBCHANGELISTENER</span>
<a href="#l6.55"></a><span id="l6.55">   NS_DECL_NSIURLLISTENER</span>
<a href="#l6.56"></a><span id="l6.56">   NS_DECL_NSIJUNKMAILCLASSIFICATIONLISTENER</span>
<a href="#l6.57"></a><span id="l6.57">   NS_DECL_NSIMSGTRAITCLASSIFICATIONLISTENER</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineminus">-  </span>
<a href="#l6.59"></a><span id="l6.59" class="difflineplus">+</span>
<a href="#l6.60"></a><span id="l6.60">   NS_IMETHOD WriteToFolderCacheElem(nsIMsgFolderCacheElement *element);</span>
<a href="#l6.61"></a><span id="l6.61">   NS_IMETHOD ReadFromFolderCacheElem(nsIMsgFolderCacheElement *element);</span>
<a href="#l6.62"></a><span id="l6.62"> </span>
<a href="#l6.63"></a><span id="l6.63">   // nsRDFResource overrides</span>
<a href="#l6.64"></a><span id="l6.64">   NS_IMETHOD Init(const char* aURI) override;</span>
<a href="#l6.65"></a><span id="l6.65"> </span>
<a href="#l6.66"></a><span id="l6.66">   nsresult CreateDirectoryForFolder(nsIFile **result);</span>
<a href="#l6.67"></a><span id="l6.67">   nsresult CreateBackupDirectory(nsIFile **result);</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineat">@@ -219,33 +219,33 @@ protected:</span>
<a href="#l6.69"></a><span id="l6.69">   nsTObserverArray&lt;nsIFolderListener*&gt; mListeners;</span>
<a href="#l6.70"></a><span id="l6.70"> </span>
<a href="#l6.71"></a><span id="l6.71">   bool mInitializedFromCache;</span>
<a href="#l6.72"></a><span id="l6.72">   nsISupports *mSemaphoreHolder; // set when the folder is being written to</span>
<a href="#l6.73"></a><span id="l6.73">                                  //Due to ownership issues, this won't be AddRef'd.</span>
<a href="#l6.74"></a><span id="l6.74"> </span>
<a href="#l6.75"></a><span id="l6.75">   nsWeakPtr mServer;</span>
<a href="#l6.76"></a><span id="l6.76"> </span>
<a href="#l6.77"></a><span id="l6.77" class="difflineminus">-  // These values are used for tricking the front end into thinking that we have more </span>
<a href="#l6.78"></a><span id="l6.78" class="difflineplus">+  // These values are used for tricking the front end into thinking that we have more</span>
<a href="#l6.79"></a><span id="l6.79">   // messages than are really in the DB.  This is usually after and IMAP message copy where</span>
<a href="#l6.80"></a><span id="l6.80">   // we don't want to do an expensive select until the user actually opens that folder</span>
<a href="#l6.81"></a><span id="l6.81">   int32_t mNumPendingUnreadMessages;</span>
<a href="#l6.82"></a><span id="l6.82">   int32_t mNumPendingTotalMessages;</span>
<a href="#l6.83"></a><span id="l6.83">   int64_t mFolderSize;</span>
<a href="#l6.84"></a><span id="l6.84"> </span>
<a href="#l6.85"></a><span id="l6.85">   int32_t mNumNewBiffMessages;</span>
<a href="#l6.86"></a><span id="l6.86"> </span>
<a href="#l6.87"></a><span id="l6.87">   // these are previous set of new msgs, which we might</span>
<a href="#l6.88"></a><span id="l6.88">   // want to run junk controls on. This is in addition to &quot;new&quot; hdrs</span>
<a href="#l6.89"></a><span id="l6.89">   // in the db, which might get cleared because the user clicked away</span>
<a href="#l6.90"></a><span id="l6.90">   // from the folder.</span>
<a href="#l6.91"></a><span id="l6.91">   nsTArray&lt;nsMsgKey&gt; m_saveNewMsgs;</span>
<a href="#l6.92"></a><span id="l6.92"> </span>
<a href="#l6.93"></a><span id="l6.93">   // These are the set of new messages for a folder who has had</span>
<a href="#l6.94"></a><span id="l6.94" class="difflineminus">-  // its db closed, without the user reading the folder. This </span>
<a href="#l6.95"></a><span id="l6.95" class="difflineplus">+  // its db closed, without the user reading the folder. This</span>
<a href="#l6.96"></a><span id="l6.96">   // happens with pop3 mail filtered to a different local folder.</span>
<a href="#l6.97"></a><span id="l6.97">   nsTArray&lt;nsMsgKey&gt; m_newMsgs;</span>
<a href="#l6.98"></a><span id="l6.98"> </span>
<a href="#l6.99"></a><span id="l6.99">   //</span>
<a href="#l6.100"></a><span id="l6.100">   // stuff from the uri</span>
<a href="#l6.101"></a><span id="l6.101">   //</span>
<a href="#l6.102"></a><span id="l6.102">   bool mHaveParsedURI;        // is the URI completely parsed?</span>
<a href="#l6.103"></a><span id="l6.103">   bool mIsServerIsValid;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/base/util/nsMsgFileStream.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgFileStream.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -26,17 +26,17 @@ ErrorAccordingToNSPR()</span>
<a href="#l7.4"></a><span id="l7.4">       case PR_NO_DEVICE_SPACE_ERROR:            return NS_ERROR_FILE_NO_DEVICE_SPACE;</span>
<a href="#l7.5"></a><span id="l7.5">       case PR_NAME_TOO_LONG_ERROR:              return NS_ERROR_FILE_NAME_TOO_LONG;</span>
<a href="#l7.6"></a><span id="l7.6">       case PR_DIRECTORY_NOT_EMPTY_ERROR:        return NS_ERROR_FILE_DIR_NOT_EMPTY;</span>
<a href="#l7.7"></a><span id="l7.7">       case PR_NO_ACCESS_RIGHTS_ERROR:           return NS_ERROR_FILE_ACCESS_DENIED;</span>
<a href="#l7.8"></a><span id="l7.8">       default:                                  return NS_ERROR_FAILURE;</span>
<a href="#l7.9"></a><span id="l7.9">     }</span>
<a href="#l7.10"></a><span id="l7.10"> }</span>
<a href="#l7.11"></a><span id="l7.11"> </span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-nsMsgFileStream::nsMsgFileStream() </span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+nsMsgFileStream::nsMsgFileStream()</span>
<a href="#l7.14"></a><span id="l7.14"> {</span>
<a href="#l7.15"></a><span id="l7.15">   mFileDesc = nullptr;</span>
<a href="#l7.16"></a><span id="l7.16">   mSeekedToEnd = false;</span>
<a href="#l7.17"></a><span id="l7.17"> }</span>
<a href="#l7.18"></a><span id="l7.18"> </span>
<a href="#l7.19"></a><span id="l7.19"> nsMsgFileStream::~nsMsgFileStream()</span>
<a href="#l7.20"></a><span id="l7.20"> {</span>
<a href="#l7.21"></a><span id="l7.21">   if (mFileDesc)</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineat">@@ -69,17 +69,17 @@ nsMsgFileStream::Seek(int32_t whence, in</span>
<a href="#l7.23"></a><span id="l7.23">   return NS_OK;</span>
<a href="#l7.24"></a><span id="l7.24"> }</span>
<a href="#l7.25"></a><span id="l7.25"> </span>
<a href="#l7.26"></a><span id="l7.26"> NS_IMETHODIMP</span>
<a href="#l7.27"></a><span id="l7.27"> nsMsgFileStream::Tell(int64_t *result)</span>
<a href="#l7.28"></a><span id="l7.28"> {</span>
<a href="#l7.29"></a><span id="l7.29">   if (mFileDesc == nullptr)</span>
<a href="#l7.30"></a><span id="l7.30">     return NS_BASE_STREAM_CLOSED;</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-  </span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+</span>
<a href="#l7.33"></a><span id="l7.33">   int64_t cnt = PR_Seek64(mFileDesc, 0, PR_SEEK_CUR);</span>
<a href="#l7.34"></a><span id="l7.34">   if (cnt == int64_t(-1)) {</span>
<a href="#l7.35"></a><span id="l7.35">     return ErrorAccordingToNSPR();</span>
<a href="#l7.36"></a><span id="l7.36">   }</span>
<a href="#l7.37"></a><span id="l7.37">   *result = cnt;</span>
<a href="#l7.38"></a><span id="l7.38">   return NS_OK;</span>
<a href="#l7.39"></a><span id="l7.39"> }</span>
<a href="#l7.40"></a><span id="l7.40"> </span>
<a href="#l7.41"></a><span id="l7.41" class="difflineat">@@ -99,40 +99,40 @@ NS_IMETHODIMP nsMsgFileStream::Close()</span>
<a href="#l7.42"></a><span id="l7.42">         rv = NS_BASE_STREAM_OSERROR;</span>
<a href="#l7.43"></a><span id="l7.43">     mFileDesc = nullptr;</span>
<a href="#l7.44"></a><span id="l7.44">   return rv;</span>
<a href="#l7.45"></a><span id="l7.45"> }</span>
<a href="#l7.46"></a><span id="l7.46"> </span>
<a href="#l7.47"></a><span id="l7.47"> /* unsigned long long available (); */</span>
<a href="#l7.48"></a><span id="l7.48"> NS_IMETHODIMP nsMsgFileStream::Available(uint64_t *aResult)</span>
<a href="#l7.49"></a><span id="l7.49"> {</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineminus">-  if (!mFileDesc) </span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+  if (!mFileDesc)</span>
<a href="#l7.52"></a><span id="l7.52">     return NS_BASE_STREAM_CLOSED;</span>
<a href="#l7.53"></a><span id="l7.53" class="difflineminus">-  </span>
<a href="#l7.54"></a><span id="l7.54" class="difflineplus">+</span>
<a href="#l7.55"></a><span id="l7.55">   int64_t avail = PR_Available64(mFileDesc);</span>
<a href="#l7.56"></a><span id="l7.56">   if (avail == -1)</span>
<a href="#l7.57"></a><span id="l7.57">     return ErrorAccordingToNSPR();</span>
<a href="#l7.58"></a><span id="l7.58"> </span>
<a href="#l7.59"></a><span id="l7.59">   *aResult = avail;</span>
<a href="#l7.60"></a><span id="l7.60">   return NS_OK;</span>
<a href="#l7.61"></a><span id="l7.61"> }</span>
<a href="#l7.62"></a><span id="l7.62"> </span>
<a href="#l7.63"></a><span id="l7.63"> /* [noscript] unsigned long read (in charPtr aBuf, in unsigned long aCount); */</span>
<a href="#l7.64"></a><span id="l7.64"> NS_IMETHODIMP nsMsgFileStream::Read(char * aBuf, uint32_t aCount, uint32_t *aResult)</span>
<a href="#l7.65"></a><span id="l7.65"> {</span>
<a href="#l7.66"></a><span id="l7.66" class="difflineminus">-  if (!mFileDesc) </span>
<a href="#l7.67"></a><span id="l7.67" class="difflineplus">+  if (!mFileDesc)</span>
<a href="#l7.68"></a><span id="l7.68">   {</span>
<a href="#l7.69"></a><span id="l7.69">     *aResult = 0;</span>
<a href="#l7.70"></a><span id="l7.70">     return NS_OK;</span>
<a href="#l7.71"></a><span id="l7.71">   }</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineminus">-  </span>
<a href="#l7.73"></a><span id="l7.73" class="difflineplus">+</span>
<a href="#l7.74"></a><span id="l7.74">   int32_t bytesRead = PR_Read(mFileDesc, aBuf, aCount);</span>
<a href="#l7.75"></a><span id="l7.75">   if (bytesRead == -1)</span>
<a href="#l7.76"></a><span id="l7.76">     return ErrorAccordingToNSPR();</span>
<a href="#l7.77"></a><span id="l7.77" class="difflineminus">-  </span>
<a href="#l7.78"></a><span id="l7.78" class="difflineplus">+</span>
<a href="#l7.79"></a><span id="l7.79">   *aResult = bytesRead;</span>
<a href="#l7.80"></a><span id="l7.80">   return NS_OK;</span>
<a href="#l7.81"></a><span id="l7.81"> }</span>
<a href="#l7.82"></a><span id="l7.82"> </span>
<a href="#l7.83"></a><span id="l7.83"> /* [noscript] unsigned long readSegments (in nsWriteSegmentFun aWriter, in voidPtr aClosure, in unsigned long aCount); */</span>
<a href="#l7.84"></a><span id="l7.84"> NS_IMETHODIMP nsMsgFileStream::ReadSegments(nsWriteSegmentFun aWriter, void * aClosure, uint32_t aCount, uint32_t *_retval)</span>
<a href="#l7.85"></a><span id="l7.85"> {</span>
<a href="#l7.86"></a><span id="l7.86">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l7.87"></a><span id="l7.87" class="difflineat">@@ -145,33 +145,33 @@ NS_IMETHODIMP nsMsgFileStream::IsNonBloc</span>
<a href="#l7.88"></a><span id="l7.88">   return NS_OK;</span>
<a href="#l7.89"></a><span id="l7.89"> }</span>
<a href="#l7.90"></a><span id="l7.90"> </span>
<a href="#l7.91"></a><span id="l7.91"> NS_IMETHODIMP</span>
<a href="#l7.92"></a><span id="l7.92"> nsMsgFileStream::Write(const char *buf, uint32_t count, uint32_t *result)</span>
<a href="#l7.93"></a><span id="l7.93"> {</span>
<a href="#l7.94"></a><span id="l7.94">   if (mFileDesc == nullptr)</span>
<a href="#l7.95"></a><span id="l7.95">     return NS_BASE_STREAM_CLOSED;</span>
<a href="#l7.96"></a><span id="l7.96" class="difflineminus">-  </span>
<a href="#l7.97"></a><span id="l7.97" class="difflineplus">+</span>
<a href="#l7.98"></a><span id="l7.98">   int32_t cnt = PR_Write(mFileDesc, buf, count);</span>
<a href="#l7.99"></a><span id="l7.99">   if (cnt == -1) {</span>
<a href="#l7.100"></a><span id="l7.100">     return ErrorAccordingToNSPR();</span>
<a href="#l7.101"></a><span id="l7.101">   }</span>
<a href="#l7.102"></a><span id="l7.102">   *result = cnt;</span>
<a href="#l7.103"></a><span id="l7.103">   return NS_OK;</span>
<a href="#l7.104"></a><span id="l7.104"> }</span>
<a href="#l7.105"></a><span id="l7.105"> </span>
<a href="#l7.106"></a><span id="l7.106"> NS_IMETHODIMP</span>
<a href="#l7.107"></a><span id="l7.107"> nsMsgFileStream::Flush(void)</span>
<a href="#l7.108"></a><span id="l7.108"> {</span>
<a href="#l7.109"></a><span id="l7.109">   if (mFileDesc == nullptr)</span>
<a href="#l7.110"></a><span id="l7.110">     return NS_BASE_STREAM_CLOSED;</span>
<a href="#l7.111"></a><span id="l7.111" class="difflineminus">-  </span>
<a href="#l7.112"></a><span id="l7.112" class="difflineplus">+</span>
<a href="#l7.113"></a><span id="l7.113">   int32_t cnt = PR_Sync(mFileDesc);</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineminus">-  if (cnt == -1) </span>
<a href="#l7.115"></a><span id="l7.115" class="difflineplus">+  if (cnt == -1)</span>
<a href="#l7.116"></a><span id="l7.116">     return ErrorAccordingToNSPR();</span>
<a href="#l7.117"></a><span id="l7.117"> </span>
<a href="#l7.118"></a><span id="l7.118">   return NS_OK;</span>
<a href="#l7.119"></a><span id="l7.119"> }</span>
<a href="#l7.120"></a><span id="l7.120"> </span>
<a href="#l7.121"></a><span id="l7.121"> NS_IMETHODIMP</span>
<a href="#l7.122"></a><span id="l7.122"> nsMsgFileStream::WriteFrom(nsIInputStream *inStr, uint32_t count, uint32_t *_retval)</span>
<a href="#l7.123"></a><span id="l7.123"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/base/util/nsMsgFileStream.h</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgFileStream.h</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -13,18 +13,18 @@ class nsMsgFileStream final : public nsI</span>
<a href="#l8.4"></a><span id="l8.4">                                   public nsIOutputStream,</span>
<a href="#l8.5"></a><span id="l8.5">                                   public nsISeekableStream</span>
<a href="#l8.6"></a><span id="l8.6"> {</span>
<a href="#l8.7"></a><span id="l8.7"> public:</span>
<a href="#l8.8"></a><span id="l8.8">   nsMsgFileStream();</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10">   NS_DECL_ISUPPORTS</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  NS_IMETHOD Available(uint64_t *_retval) override; </span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">-  NS_IMETHOD Read(char * aBuf, uint32_t aCount, uint32_t *_retval) override; </span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+  NS_IMETHOD Available(uint64_t *_retval) override;</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+  NS_IMETHOD Read(char * aBuf, uint32_t aCount, uint32_t *_retval) override;</span>
<a href="#l8.16"></a><span id="l8.16">   NS_IMETHOD ReadSegments(nsWriteSegmentFun aWriter, void * aClosure, uint32_t aCount, uint32_t *_retval) override;</span>
<a href="#l8.17"></a><span id="l8.17">   NS_DECL_NSIOUTPUTSTREAM</span>
<a href="#l8.18"></a><span id="l8.18">   NS_DECL_NSISEEKABLESTREAM</span>
<a href="#l8.19"></a><span id="l8.19"> </span>
<a href="#l8.20"></a><span id="l8.20">   nsresult InitWithFile(nsIFile *localFile);</span>
<a href="#l8.21"></a><span id="l8.21"> protected:</span>
<a href="#l8.22"></a><span id="l8.22">   ~nsMsgFileStream();</span>
<a href="#l8.23"></a><span id="l8.23"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/base/util/nsMsgI18N.cpp</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgI18N.cpp</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -59,17 +59,17 @@ nsresult nsMsgI18NConvertFromUnicode(con</span>
<a href="#l9.4"></a><span id="l9.4">   if (rv == NS_OK_HAD_REPLACEMENTS) {</span>
<a href="#l9.5"></a><span id="l9.5">     rv = aReportUencNoMapping ? NS_ERROR_UENC_NOMAPPING : NS_OK;</span>
<a href="#l9.6"></a><span id="l9.6">   }</span>
<a href="#l9.7"></a><span id="l9.7"> </span>
<a href="#l9.8"></a><span id="l9.8">   return rv;</span>
<a href="#l9.9"></a><span id="l9.9"> }</span>
<a href="#l9.10"></a><span id="l9.10"> </span>
<a href="#l9.11"></a><span id="l9.11"> nsresult nsMsgI18NConvertToUnicode(const char* aCharset,</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-                                   const nsCString&amp; inString, </span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+                                   const nsCString&amp; inString,</span>
<a href="#l9.14"></a><span id="l9.14">                                    nsAString&amp; outString)</span>
<a href="#l9.15"></a><span id="l9.15"> {</span>
<a href="#l9.16"></a><span id="l9.16">   if (inString.IsEmpty()) {</span>
<a href="#l9.17"></a><span id="l9.17">     outString.Truncate();</span>
<a href="#l9.18"></a><span id="l9.18">     return NS_OK;</span>
<a href="#l9.19"></a><span id="l9.19">   }</span>
<a href="#l9.20"></a><span id="l9.20">   else if (!*aCharset) {</span>
<a href="#l9.21"></a><span id="l9.21">     // Despite its name, it also works for Latin-1.</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineat">@@ -125,26 +125,26 @@ nsresult CopyMUTF7toUTF16(const nsCStrin</span>
<a href="#l9.23"></a><span id="l9.23"> }</span>
<a href="#l9.24"></a><span id="l9.24"> </span>
<a href="#l9.25"></a><span id="l9.25"> // Charset used by the file system.</span>
<a href="#l9.26"></a><span id="l9.26"> const char * nsMsgI18NFileSystemCharset()</span>
<a href="#l9.27"></a><span id="l9.27"> {</span>
<a href="#l9.28"></a><span id="l9.28">   /* Get a charset used for the file. */</span>
<a href="#l9.29"></a><span id="l9.29">   static nsAutoCString fileSystemCharset;</span>
<a href="#l9.30"></a><span id="l9.30"> </span>
<a href="#l9.31"></a><span id="l9.31" class="difflineminus">-  if (fileSystemCharset.IsEmpty()) </span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+  if (fileSystemCharset.IsEmpty())</span>
<a href="#l9.33"></a><span id="l9.33">   {</span>
<a href="#l9.34"></a><span id="l9.34">     nsresult rv;</span>
<a href="#l9.35"></a><span id="l9.35">     nsCOMPtr &lt;nsIPlatformCharset&gt; platformCharset = do_GetService(NS_PLATFORMCHARSET_CONTRACTID, &amp;rv);</span>
<a href="#l9.36"></a><span id="l9.36">         if (NS_SUCCEEDED(rv)) {</span>
<a href="#l9.37"></a><span id="l9.37">           rv = platformCharset-&gt;GetCharset(kPlatformCharsetSel_FileName,</span>
<a href="#l9.38"></a><span id="l9.38">                                            fileSystemCharset);</span>
<a href="#l9.39"></a><span id="l9.39">         }</span>
<a href="#l9.40"></a><span id="l9.40"> </span>
<a href="#l9.41"></a><span id="l9.41" class="difflineminus">-    if (NS_FAILED(rv)) </span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+    if (NS_FAILED(rv))</span>
<a href="#l9.43"></a><span id="l9.43">       fileSystemCharset.Assign(&quot;ISO-8859-1&quot;);</span>
<a href="#l9.44"></a><span id="l9.44">   }</span>
<a href="#l9.45"></a><span id="l9.45">   return fileSystemCharset.get();</span>
<a href="#l9.46"></a><span id="l9.46"> }</span>
<a href="#l9.47"></a><span id="l9.47"> </span>
<a href="#l9.48"></a><span id="l9.48"> // Charset used by the text file.</span>
<a href="#l9.49"></a><span id="l9.49"> void nsMsgI18NTextFileCharset(nsACString&amp; aCharset)</span>
<a href="#l9.50"></a><span id="l9.50"> {</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineat">@@ -157,17 +157,17 @@ void nsMsgI18NTextFileCharset(nsACString</span>
<a href="#l9.52"></a><span id="l9.52">   }</span>
<a href="#l9.53"></a><span id="l9.53"> </span>
<a href="#l9.54"></a><span id="l9.54">   if (NS_FAILED(rv))</span>
<a href="#l9.55"></a><span id="l9.55">     aCharset.Assign(&quot;ISO-8859-1&quot;);</span>
<a href="#l9.56"></a><span id="l9.56"> }</span>
<a href="#l9.57"></a><span id="l9.57"> </span>
<a href="#l9.58"></a><span id="l9.58"> // MIME encoder, output string should be freed by PR_FREE</span>
<a href="#l9.59"></a><span id="l9.59"> // XXX : fix callers later to avoid allocation and copy</span>
<a href="#l9.60"></a><span id="l9.60" class="difflineminus">-char * nsMsgI18NEncodeMimePartIIStr(const char *header, bool structured, const char *charset, int32_t fieldnamelen, bool usemime) </span>
<a href="#l9.61"></a><span id="l9.61" class="difflineplus">+char * nsMsgI18NEncodeMimePartIIStr(const char *header, bool structured, const char *charset, int32_t fieldnamelen, bool usemime)</span>
<a href="#l9.62"></a><span id="l9.62"> {</span>
<a href="#l9.63"></a><span id="l9.63">   // No MIME, convert to the outgoing mail charset.</span>
<a href="#l9.64"></a><span id="l9.64">   if (false == usemime) {</span>
<a href="#l9.65"></a><span id="l9.65">     nsAutoCString convertedStr;</span>
<a href="#l9.66"></a><span id="l9.66">     if (NS_SUCCEEDED(ConvertFromUnicode(charset, NS_ConvertUTF8toUTF16(header),</span>
<a href="#l9.67"></a><span id="l9.67">                                         convertedStr)))</span>
<a href="#l9.68"></a><span id="l9.68">       return PL_strdup(convertedStr.get());</span>
<a href="#l9.69"></a><span id="l9.69">     else</span>
<a href="#l9.70"></a><span id="l9.70" class="difflineat">@@ -237,85 +237,85 @@ bool nsMsgI18Ncheck_data_in_charset_rang</span>
<a href="#l9.71"></a><span id="l9.71">       // Didn't use all the input but the outout isn't full, hence</span>
<a href="#l9.72"></a><span id="l9.72">       // there was an unencodable character.</span>
<a href="#l9.73"></a><span id="l9.73">       res = false;</span>
<a href="#l9.74"></a><span id="l9.74">       break;</span>
<a href="#l9.75"></a><span id="l9.75">     }</span>
<a href="#l9.76"></a><span id="l9.76">     src = src.From(read);</span>
<a href="#l9.77"></a><span id="l9.77">     // dst = dst.From(written); // Just overwrite output since we don't need it.</span>
<a href="#l9.78"></a><span id="l9.78">   }</span>
<a href="#l9.79"></a><span id="l9.79" class="difflineminus">-  </span>
<a href="#l9.80"></a><span id="l9.80" class="difflineplus">+</span>
<a href="#l9.81"></a><span id="l9.81">   return res;</span>
<a href="#l9.82"></a><span id="l9.82"> }</span>
<a href="#l9.83"></a><span id="l9.83"> </span>
<a href="#l9.84"></a><span id="l9.84" class="difflineminus">-// Simple parser to parse META charset. </span>
<a href="#l9.85"></a><span id="l9.85" class="difflineminus">-// It only supports the case when the description is within one line. </span>
<a href="#l9.86"></a><span id="l9.86" class="difflineminus">-const char * </span>
<a href="#l9.87"></a><span id="l9.87" class="difflineminus">-nsMsgI18NParseMetaCharset(nsIFile* file) </span>
<a href="#l9.88"></a><span id="l9.88" class="difflineminus">-{ </span>
<a href="#l9.89"></a><span id="l9.89" class="difflineplus">+// Simple parser to parse META charset.</span>
<a href="#l9.90"></a><span id="l9.90" class="difflineplus">+// It only supports the case when the description is within one line.</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineplus">+const char *</span>
<a href="#l9.92"></a><span id="l9.92" class="difflineplus">+nsMsgI18NParseMetaCharset(nsIFile* file)</span>
<a href="#l9.93"></a><span id="l9.93" class="difflineplus">+{</span>
<a href="#l9.94"></a><span id="l9.94">   static char charset[nsIMimeConverter::MAX_CHARSET_NAME_LENGTH+1];</span>
<a href="#l9.95"></a><span id="l9.95"> </span>
<a href="#l9.96"></a><span id="l9.96" class="difflineminus">-  *charset = '\0'; </span>
<a href="#l9.97"></a><span id="l9.97" class="difflineplus">+  *charset = '\0';</span>
<a href="#l9.98"></a><span id="l9.98"> </span>
<a href="#l9.99"></a><span id="l9.99">   bool isDirectory = false;</span>
<a href="#l9.100"></a><span id="l9.100">   file-&gt;IsDirectory(&amp;isDirectory);</span>
<a href="#l9.101"></a><span id="l9.101">   if (isDirectory) {</span>
<a href="#l9.102"></a><span id="l9.102">     NS_ERROR(&quot;file is a directory&quot;);</span>
<a href="#l9.103"></a><span id="l9.103" class="difflineminus">-    return charset; </span>
<a href="#l9.104"></a><span id="l9.104" class="difflineplus">+    return charset;</span>
<a href="#l9.105"></a><span id="l9.105">   }</span>
<a href="#l9.106"></a><span id="l9.106"> </span>
<a href="#l9.107"></a><span id="l9.107">   nsresult rv;</span>
<a href="#l9.108"></a><span id="l9.108">   nsCOMPtr &lt;nsIFileInputStream&gt; fileStream = do_CreateInstance(NS_LOCALFILEINPUTSTREAM_CONTRACTID, &amp;rv);</span>
<a href="#l9.109"></a><span id="l9.109">   NS_ENSURE_SUCCESS(rv, charset);</span>
<a href="#l9.110"></a><span id="l9.110" class="difflineminus">-  </span>
<a href="#l9.111"></a><span id="l9.111" class="difflineplus">+</span>
<a href="#l9.112"></a><span id="l9.112">   rv = fileStream-&gt;Init(file, PR_RDONLY, 0664, false);</span>
<a href="#l9.113"></a><span id="l9.113">   nsCOMPtr &lt;nsILineInputStream&gt; lineStream = do_QueryInterface(fileStream, &amp;rv);</span>
<a href="#l9.114"></a><span id="l9.114"> </span>
<a href="#l9.115"></a><span id="l9.115">   nsCString curLine;</span>
<a href="#l9.116"></a><span id="l9.116">   bool more = true;</span>
<a href="#l9.117"></a><span id="l9.117" class="difflineminus">-  while (NS_SUCCEEDED(rv) &amp;&amp; more) { </span>
<a href="#l9.118"></a><span id="l9.118" class="difflineminus">-    rv = lineStream-&gt;ReadLine(curLine, &amp;more); </span>
<a href="#l9.119"></a><span id="l9.119" class="difflineminus">-    if (curLine.IsEmpty()) </span>
<a href="#l9.120"></a><span id="l9.120" class="difflineminus">-      continue; </span>
<a href="#l9.121"></a><span id="l9.121" class="difflineplus">+  while (NS_SUCCEEDED(rv) &amp;&amp; more) {</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineplus">+    rv = lineStream-&gt;ReadLine(curLine, &amp;more);</span>
<a href="#l9.123"></a><span id="l9.123" class="difflineplus">+    if (curLine.IsEmpty())</span>
<a href="#l9.124"></a><span id="l9.124" class="difflineplus">+      continue;</span>
<a href="#l9.125"></a><span id="l9.125"> </span>
<a href="#l9.126"></a><span id="l9.126">     ToUpperCase(curLine);</span>
<a href="#l9.127"></a><span id="l9.127"> </span>
<a href="#l9.128"></a><span id="l9.128" class="difflineminus">-    if (curLine.Find(&quot;/HEAD&quot;) != -1) </span>
<a href="#l9.129"></a><span id="l9.129" class="difflineminus">-      break; </span>
<a href="#l9.130"></a><span id="l9.130" class="difflineplus">+    if (curLine.Find(&quot;/HEAD&quot;) != -1)</span>
<a href="#l9.131"></a><span id="l9.131" class="difflineplus">+      break;</span>
<a href="#l9.132"></a><span id="l9.132"> </span>
<a href="#l9.133"></a><span id="l9.133" class="difflineminus">-    if (curLine.Find(&quot;META&quot;) != -1 &amp;&amp; </span>
<a href="#l9.134"></a><span id="l9.134" class="difflineminus">-       curLine.Find(&quot;HTTP-EQUIV&quot;) != -1 &amp;&amp; </span>
<a href="#l9.135"></a><span id="l9.135" class="difflineminus">-        curLine.Find(&quot;CONTENT-TYPE&quot;) != -1 &amp;&amp; </span>
<a href="#l9.136"></a><span id="l9.136" class="difflineminus">-       curLine.Find(&quot;CHARSET&quot;) != -1) { </span>
<a href="#l9.137"></a><span id="l9.137" class="difflineplus">+    if (curLine.Find(&quot;META&quot;) != -1 &amp;&amp;</span>
<a href="#l9.138"></a><span id="l9.138" class="difflineplus">+        curLine.Find(&quot;HTTP-EQUIV&quot;) != -1 &amp;&amp;</span>
<a href="#l9.139"></a><span id="l9.139" class="difflineplus">+        curLine.Find(&quot;CONTENT-TYPE&quot;) != -1 &amp;&amp;</span>
<a href="#l9.140"></a><span id="l9.140" class="difflineplus">+        curLine.Find(&quot;CHARSET&quot;) != -1) {</span>
<a href="#l9.141"></a><span id="l9.141">       char *cp = (char *) PL_strchr(PL_strstr(curLine.get(), &quot;CHARSET&quot;), '=');</span>
<a href="#l9.142"></a><span id="l9.142">       char *token = nullptr;</span>
<a href="#l9.143"></a><span id="l9.143">       if (cp)</span>
<a href="#l9.144"></a><span id="l9.144">       {</span>
<a href="#l9.145"></a><span id="l9.145">         char *newStr = cp + 1;</span>
<a href="#l9.146"></a><span id="l9.146">         token = NS_strtok(&quot; \&quot;\'&quot;, &amp;newStr);</span>
<a href="#l9.147"></a><span id="l9.147">       }</span>
<a href="#l9.148"></a><span id="l9.148" class="difflineminus">-      if (token) { </span>
<a href="#l9.149"></a><span id="l9.149" class="difflineplus">+      if (token) {</span>
<a href="#l9.150"></a><span id="l9.150">         PL_strncpy(charset, token, sizeof(charset));</span>
<a href="#l9.151"></a><span id="l9.151">         charset[sizeof(charset)-1] = '\0';</span>
<a href="#l9.152"></a><span id="l9.152"> </span>
<a href="#l9.153"></a><span id="l9.153">         // this function cannot parse a file if it is really</span>
<a href="#l9.154"></a><span id="l9.154">         // encoded by one of the following charsets</span>
<a href="#l9.155"></a><span id="l9.155">         // so we can say that the charset label must be incorrect for</span>
<a href="#l9.156"></a><span id="l9.156">         // the .html if we actually see those charsets parsed</span>
<a href="#l9.157"></a><span id="l9.157">         // and we should ignore them</span>
<a href="#l9.158"></a><span id="l9.158" class="difflineminus">-        if (!PL_strncasecmp(&quot;UTF-16&quot;, charset, sizeof(&quot;UTF-16&quot;)-1) || </span>
<a href="#l9.159"></a><span id="l9.159" class="difflineplus">+        if (!PL_strncasecmp(&quot;UTF-16&quot;, charset, sizeof(&quot;UTF-16&quot;)-1) ||</span>
<a href="#l9.160"></a><span id="l9.160">             !PL_strncasecmp(&quot;UTF-32&quot;, charset, sizeof(&quot;UTF-32&quot;)-1))</span>
<a href="#l9.161"></a><span id="l9.161">           charset[0] = '\0';</span>
<a href="#l9.162"></a><span id="l9.162"> </span>
<a href="#l9.163"></a><span id="l9.163">         break;</span>
<a href="#l9.164"></a><span id="l9.164" class="difflineminus">-      } </span>
<a href="#l9.165"></a><span id="l9.165" class="difflineminus">-    } </span>
<a href="#l9.166"></a><span id="l9.166" class="difflineminus">-  } </span>
<a href="#l9.167"></a><span id="l9.167" class="difflineplus">+      }</span>
<a href="#l9.168"></a><span id="l9.168" class="difflineplus">+    }</span>
<a href="#l9.169"></a><span id="l9.169" class="difflineplus">+  }</span>
<a href="#l9.170"></a><span id="l9.170"> </span>
<a href="#l9.171"></a><span id="l9.171" class="difflineminus">-  return charset; </span>
<a href="#l9.172"></a><span id="l9.172" class="difflineplus">+  return charset;</span>
<a href="#l9.173"></a><span id="l9.173"> }</span>
<a href="#l9.174"></a><span id="l9.174"> </span>
<a href="#l9.175"></a><span id="l9.175"> nsresult nsMsgI18NShrinkUTF8Str(const nsCString &amp;inString,</span>
<a href="#l9.176"></a><span id="l9.176">                                 uint32_t aMaxLength,</span>
<a href="#l9.177"></a><span id="l9.177">                                 nsACString &amp;outString)</span>
<a href="#l9.178"></a><span id="l9.178"> {</span>
<a href="#l9.179"></a><span id="l9.179">   if (inString.IsEmpty()) {</span>
<a href="#l9.180"></a><span id="l9.180">     outString.Truncate();</span>
<a href="#l9.181"></a><span id="l9.181" class="difflineat">@@ -341,17 +341,17 @@ nsresult nsMsgI18NShrinkUTF8Str(const ns</span>
<a href="#l9.182"></a><span id="l9.182">     outString.Truncate();</span>
<a href="#l9.183"></a><span id="l9.183">     return NS_OK;</span>
<a href="#l9.184"></a><span id="l9.184">   }</span>
<a href="#l9.185"></a><span id="l9.185">   uint32_t len = prev - start;</span>
<a href="#l9.186"></a><span id="l9.186">   outString.Assign(Substring(inString, 0, len));</span>
<a href="#l9.187"></a><span id="l9.187">   return NS_OK;</span>
<a href="#l9.188"></a><span id="l9.188"> }</span>
<a href="#l9.189"></a><span id="l9.189"> </span>
<a href="#l9.190"></a><span id="l9.190" class="difflineminus">-void nsMsgI18NConvertRawBytesToUTF16(const nsCString&amp; inString, </span>
<a href="#l9.191"></a><span id="l9.191" class="difflineplus">+void nsMsgI18NConvertRawBytesToUTF16(const nsCString&amp; inString,</span>
<a href="#l9.192"></a><span id="l9.192">                                      const char* charset,</span>
<a href="#l9.193"></a><span id="l9.193">                                      nsAString&amp; outString)</span>
<a href="#l9.194"></a><span id="l9.194"> {</span>
<a href="#l9.195"></a><span id="l9.195">   if (MsgIsUTF8(inString))</span>
<a href="#l9.196"></a><span id="l9.196">   {</span>
<a href="#l9.197"></a><span id="l9.197">     CopyUTF8toUTF16(inString, outString);</span>
<a href="#l9.198"></a><span id="l9.198">     return;</span>
<a href="#l9.199"></a><span id="l9.199">   }</span>
<a href="#l9.200"></a><span id="l9.200" class="difflineat">@@ -367,17 +367,17 @@ void nsMsgI18NConvertRawBytesToUTF16(con</span>
<a href="#l9.201"></a><span id="l9.201">     char c = *cur++;</span>
<a href="#l9.202"></a><span id="l9.202">     if (c &amp; char(0x80))</span>
<a href="#l9.203"></a><span id="l9.203">       outString.Append(UCS2_REPLACEMENT_CHAR);</span>
<a href="#l9.204"></a><span id="l9.204">     else</span>
<a href="#l9.205"></a><span id="l9.205">       outString.Append(c);</span>
<a href="#l9.206"></a><span id="l9.206">   }</span>
<a href="#l9.207"></a><span id="l9.207"> }</span>
<a href="#l9.208"></a><span id="l9.208"> </span>
<a href="#l9.209"></a><span id="l9.209" class="difflineminus">-void nsMsgI18NConvertRawBytesToUTF8(const nsCString&amp; inString, </span>
<a href="#l9.210"></a><span id="l9.210" class="difflineplus">+void nsMsgI18NConvertRawBytesToUTF8(const nsCString&amp; inString,</span>
<a href="#l9.211"></a><span id="l9.211">                                     const char* charset,</span>
<a href="#l9.212"></a><span id="l9.212">                                     nsACString&amp; outString)</span>
<a href="#l9.213"></a><span id="l9.213"> {</span>
<a href="#l9.214"></a><span id="l9.214">   if (MsgIsUTF8(inString))</span>
<a href="#l9.215"></a><span id="l9.215">   {</span>
<a href="#l9.216"></a><span id="l9.216">     outString.Assign(inString);</span>
<a href="#l9.217"></a><span id="l9.217">     return;</span>
<a href="#l9.218"></a><span id="l9.218">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/base/util/nsMsgI18N.h</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgI18N.h</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -42,17 +42,17 @@ NS_MSG_BASE bool nsMsgI18Nmultibyte_char</span>
<a href="#l10.4"></a><span id="l10.4"> /**</span>
<a href="#l10.5"></a><span id="l10.5">  * Check the input (unicode) string is in a range of the given charset after the conversion.</span>
<a href="#l10.6"></a><span id="l10.6">  * Note, do not use this for large string (e.g. message body) since this actually applies the conversion to the buffer.</span>
<a href="#l10.7"></a><span id="l10.7">  *</span>
<a href="#l10.8"></a><span id="l10.8">  * @param charset     [IN] Charset to be converted.</span>
<a href="#l10.9"></a><span id="l10.9">  * @param inString    [IN] Input unicode string to be examined.</span>
<a href="#l10.10"></a><span id="l10.10">  * @param fallbackCharset [OUT]</span>
<a href="#l10.11"></a><span id="l10.11">  *                         null if fallback charset is not needed.</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">- *                         Otherwise, a fallback charset name may be set if that was used for the conversion. </span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+ *                         Otherwise, a fallback charset name may be set if that was used for the conversion.</span>
<a href="#l10.14"></a><span id="l10.14">  *                         Caller is responsible for freeing the memory.</span>
<a href="#l10.15"></a><span id="l10.15">  * @return            True if the string can be converted within the charset range.</span>
<a href="#l10.16"></a><span id="l10.16">  *                    False if one or more characters cannot be converted to the target charset.</span>
<a href="#l10.17"></a><span id="l10.17">  */</span>
<a href="#l10.18"></a><span id="l10.18"> NS_MSG_BASE bool      nsMsgI18Ncheck_data_in_charset_range(const char *charset, const char16_t* inString);</span>
<a href="#l10.19"></a><span id="l10.19"> </span>
<a href="#l10.20"></a><span id="l10.20"> /**</span>
<a href="#l10.21"></a><span id="l10.21">  * Return charset name of file system (OS dependent).</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineat">@@ -119,27 +119,27 @@ NS_MSG_BASE nsresult nsMsgI18NShrinkUTF8</span>
<a href="#l10.23"></a><span id="l10.23">                                             nsACString &amp;outString);</span>
<a href="#l10.24"></a><span id="l10.24"> </span>
<a href="#l10.25"></a><span id="l10.25"> /*</span>
<a href="#l10.26"></a><span id="l10.26">  * Convert raw bytes in header to UTF-16</span>
<a href="#l10.27"></a><span id="l10.27">  *</span>
<a href="#l10.28"></a><span id="l10.28">  * @param inString   [IN] Input raw octets</span>
<a href="#l10.29"></a><span id="l10.29">  * @param outString  [OUT] Output UTF-16 string</span>
<a href="#l10.30"></a><span id="l10.30">  */</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineminus">-NS_MSG_BASE void nsMsgI18NConvertRawBytesToUTF16(const nsCString&amp; inString, </span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+NS_MSG_BASE void nsMsgI18NConvertRawBytesToUTF16(const nsCString&amp; inString,</span>
<a href="#l10.33"></a><span id="l10.33">                                                  const char* charset,</span>
<a href="#l10.34"></a><span id="l10.34">                                                  nsAString&amp; outString);</span>
<a href="#l10.35"></a><span id="l10.35"> </span>
<a href="#l10.36"></a><span id="l10.36"> /*</span>
<a href="#l10.37"></a><span id="l10.37">  * Convert raw bytes in header to UTF-8</span>
<a href="#l10.38"></a><span id="l10.38">  *</span>
<a href="#l10.39"></a><span id="l10.39">  * @param inString   [IN] Input raw octets</span>
<a href="#l10.40"></a><span id="l10.40">  * @param outString  [OUT] Output UTF-8 string</span>
<a href="#l10.41"></a><span id="l10.41">  */</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineminus">-NS_MSG_BASE void nsMsgI18NConvertRawBytesToUTF8(const nsCString&amp; inString, </span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+NS_MSG_BASE void nsMsgI18NConvertRawBytesToUTF8(const nsCString&amp; inString,</span>
<a href="#l10.44"></a><span id="l10.44">                                                 const char* charset,</span>
<a href="#l10.45"></a><span id="l10.45">                                                 nsACString&amp; outString);</span>
<a href="#l10.46"></a><span id="l10.46"> </span>
<a href="#l10.47"></a><span id="l10.47"> // Convert between UTF-16 and modified UTF-7 used for IMAP.</span>
<a href="#l10.48"></a><span id="l10.48"> NS_MSG_BASE nsresult CopyUTF16toMUTF7(const nsString &amp;aSrc, nsACString&amp; aDest);</span>
<a href="#l10.49"></a><span id="l10.49"> NS_MSG_BASE nsresult CopyMUTF7toUTF16(const nsCString&amp; aSrc, nsAString&amp; aDest);</span>
<a href="#l10.50"></a><span id="l10.50"> </span>
<a href="#l10.51"></a><span id="l10.51"> inline nsresult ConvertToUnicode(const char* charset,</span>
<a href="#l10.52"></a><span id="l10.52" class="difflineat">@@ -155,29 +155,29 @@ inline nsresult ConvertToUnicode(const c</span>
<a href="#l10.53"></a><span id="l10.53"> }</span>
<a href="#l10.54"></a><span id="l10.54"> </span>
<a href="#l10.55"></a><span id="l10.55"> inline nsresult ConvertFromUnicode(const char* charset,</span>
<a href="#l10.56"></a><span id="l10.56">                                    const nsString &amp;aSrc, nsACString&amp; aDest)</span>
<a href="#l10.57"></a><span id="l10.57"> {</span>
<a href="#l10.58"></a><span id="l10.58">     return nsMsgI18NConvertFromUnicode(charset, aSrc, aDest);</span>
<a href="#l10.59"></a><span id="l10.59"> }</span>
<a href="#l10.60"></a><span id="l10.60"> </span>
<a href="#l10.61"></a><span id="l10.61" class="difflineminus">-inline void ConvertRawBytesToUTF16(const nsCString&amp; inString, </span>
<a href="#l10.62"></a><span id="l10.62" class="difflineplus">+inline void ConvertRawBytesToUTF16(const nsCString&amp; inString,</span>
<a href="#l10.63"></a><span id="l10.63">                                    const char* charset, nsAString&amp; outString)</span>
<a href="#l10.64"></a><span id="l10.64"> {</span>
<a href="#l10.65"></a><span id="l10.65">     return nsMsgI18NConvertRawBytesToUTF16(inString, charset, outString);</span>
<a href="#l10.66"></a><span id="l10.66"> }</span>
<a href="#l10.67"></a><span id="l10.67"> </span>
<a href="#l10.68"></a><span id="l10.68" class="difflineminus">-inline void ConvertRawBytesToUTF16(const char* inString, </span>
<a href="#l10.69"></a><span id="l10.69" class="difflineplus">+inline void ConvertRawBytesToUTF16(const char* inString,</span>
<a href="#l10.70"></a><span id="l10.70">                                    const char* charset, nsAString&amp; outString)</span>
<a href="#l10.71"></a><span id="l10.71"> {</span>
<a href="#l10.72"></a><span id="l10.72">     return nsMsgI18NConvertRawBytesToUTF16(nsDependentCString(inString),</span>
<a href="#l10.73"></a><span id="l10.73">                                            charset,</span>
<a href="#l10.74"></a><span id="l10.74">                                            outString);</span>
<a href="#l10.75"></a><span id="l10.75"> }</span>
<a href="#l10.76"></a><span id="l10.76"> </span>
<a href="#l10.77"></a><span id="l10.77" class="difflineminus">-inline void ConvertRawBytesToUTF8(const nsCString&amp; inString, </span>
<a href="#l10.78"></a><span id="l10.78" class="difflineplus">+inline void ConvertRawBytesToUTF8(const nsCString&amp; inString,</span>
<a href="#l10.79"></a><span id="l10.79">                                   const char* charset, nsACString&amp; outString)</span>
<a href="#l10.80"></a><span id="l10.80"> {</span>
<a href="#l10.81"></a><span id="l10.81">     return nsMsgI18NConvertRawBytesToUTF8(inString, charset, outString);</span>
<a href="#l10.82"></a><span id="l10.82"> }</span>
<a href="#l10.83"></a><span id="l10.83"> </span>
<a href="#l10.84"></a><span id="l10.84"> #endif /* _nsMsgI18N_H_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/base/util/nsMsgIdentity.h</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgIdentity.h</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -12,17 +12,17 @@</span>
<a href="#l11.4"></a><span id="l11.4"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l11.5"></a><span id="l11.5"> #include &quot;nsString.h&quot;</span>
<a href="#l11.6"></a><span id="l11.6"> </span>
<a href="#l11.7"></a><span id="l11.7"> class NS_MSG_BASE nsMsgIdentity final : public nsIMsgIdentity</span>
<a href="#l11.8"></a><span id="l11.8"> {</span>
<a href="#l11.9"></a><span id="l11.9"> public:</span>
<a href="#l11.10"></a><span id="l11.10">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l11.11"></a><span id="l11.11">   NS_DECL_NSIMSGIDENTITY</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-  </span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+</span>
<a href="#l11.14"></a><span id="l11.14"> private:</span>
<a href="#l11.15"></a><span id="l11.15">   ~nsMsgIdentity() {}</span>
<a href="#l11.16"></a><span id="l11.16">   nsCString mKey;</span>
<a href="#l11.17"></a><span id="l11.17">   nsCOMPtr&lt;nsIPrefBranch&gt; mPrefBranch;</span>
<a href="#l11.18"></a><span id="l11.18">   nsCOMPtr&lt;nsIPrefBranch&gt; mDefPrefBranch;</span>
<a href="#l11.19"></a><span id="l11.19"> </span>
<a href="#l11.20"></a><span id="l11.20"> protected:</span>
<a href="#l11.21"></a><span id="l11.21">   nsresult getFolderPref(const char *pref, nsCString&amp;, const char *, uint32_t);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/base/util/nsMsgIncomingServer.h</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgIncomingServer.h</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -43,17 +43,17 @@ class NS_MSG_BASE nsMsgIncomingServer : </span>
<a href="#l12.4"></a><span id="l12.4"> </span>
<a href="#l12.5"></a><span id="l12.5">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l12.6"></a><span id="l12.6">   NS_DECL_NSIMSGINCOMINGSERVER</span>
<a href="#l12.7"></a><span id="l12.7"> </span>
<a href="#l12.8"></a><span id="l12.8"> protected:</span>
<a href="#l12.9"></a><span id="l12.9">   virtual ~nsMsgIncomingServer();</span>
<a href="#l12.10"></a><span id="l12.10">   nsCString m_serverKey;</span>
<a href="#l12.11"></a><span id="l12.11"> </span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-  // Sets m_password, if password found. Can return NS_ERROR_ABORT if the </span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+  // Sets m_password, if password found. Can return NS_ERROR_ABORT if the</span>
<a href="#l12.14"></a><span id="l12.14">   // user cancels the master password dialog.</span>
<a href="#l12.15"></a><span id="l12.15">   nsresult GetPasswordWithoutUI();</span>
<a href="#l12.16"></a><span id="l12.16"> </span>
<a href="#l12.17"></a><span id="l12.17">   nsresult ConfigureTemporaryReturnReceiptsFilter(nsIMsgFilterList *filterList);</span>
<a href="#l12.18"></a><span id="l12.18">   nsresult ConfigureTemporaryServerSpamFilters(nsIMsgFilterList *filterList);</span>
<a href="#l12.19"></a><span id="l12.19"> </span>
<a href="#l12.20"></a><span id="l12.20">   nsCOMPtr &lt;nsIMsgFolder&gt; m_rootFolder;</span>
<a href="#l12.21"></a><span id="l12.21">   nsCOMPtr &lt;nsIMsgDownloadSettings&gt; m_downloadSettings;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/base/util/nsMsgKeySet.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgKeySet.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -260,17 +260,17 @@ nsMsgKeySet::FirstNonMember ()</span>
<a href="#l13.4"></a><span id="l13.4">     } else {</span>
<a href="#l13.5"></a><span id="l13.5">       /* handle &quot;M,...&quot; where M &gt;= 2. */</span>
<a href="#l13.6"></a><span id="l13.6">       return 1;</span>
<a href="#l13.7"></a><span id="l13.7">     }</span>
<a href="#l13.8"></a><span id="l13.8">   }</span>
<a href="#l13.9"></a><span id="l13.9"> }</span>
<a href="#l13.10"></a><span id="l13.10"> </span>
<a href="#l13.11"></a><span id="l13.11"> </span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-nsresult </span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+nsresult</span>
<a href="#l13.14"></a><span id="l13.14"> nsMsgKeySet::Output(char **outputStr)</span>
<a href="#l13.15"></a><span id="l13.15"> {</span>
<a href="#l13.16"></a><span id="l13.16">   NS_ENSURE_ARG(outputStr);</span>
<a href="#l13.17"></a><span id="l13.17">   int32_t size;</span>
<a href="#l13.18"></a><span id="l13.18">   int32_t *head;</span>
<a href="#l13.19"></a><span id="l13.19">   int32_t *tail;</span>
<a href="#l13.20"></a><span id="l13.20">   int32_t *end;</span>
<a href="#l13.21"></a><span id="l13.21">   int32_t s_size;</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineat">@@ -342,17 +342,17 @@ nsMsgKeySet::Output(char **outputStr)</span>
<a href="#l13.23"></a><span id="l13.23">   }</span>
<a href="#l13.24"></a><span id="l13.24"> </span>
<a href="#l13.25"></a><span id="l13.25">   *s = 0;</span>
<a href="#l13.26"></a><span id="l13.26"> </span>
<a href="#l13.27"></a><span id="l13.27">   *outputStr = s_head;</span>
<a href="#l13.28"></a><span id="l13.28">   return NS_OK;</span>
<a href="#l13.29"></a><span id="l13.29"> }</span>
<a href="#l13.30"></a><span id="l13.30"> </span>
<a href="#l13.31"></a><span id="l13.31" class="difflineminus">-int32_t </span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+int32_t</span>
<a href="#l13.33"></a><span id="l13.33"> nsMsgKeySet::GetLastMember()</span>
<a href="#l13.34"></a><span id="l13.34"> {</span>
<a href="#l13.35"></a><span id="l13.35">   if (m_length &gt; 1)</span>
<a href="#l13.36"></a><span id="l13.36">   {</span>
<a href="#l13.37"></a><span id="l13.37">     int32_t nextToLast = m_data[m_length - 2];</span>
<a href="#l13.38"></a><span id="l13.38">     if (nextToLast &lt; 0)  // is range at end?</span>
<a href="#l13.39"></a><span id="l13.39">     {</span>
<a href="#l13.40"></a><span id="l13.40">       int32_t last = m_data[m_length - 1];</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineat">@@ -381,17 +381,17 @@ void nsMsgKeySet::SetLastMember(int32_t </span>
<a href="#l13.42"></a><span id="l13.42">         int32_t curHighWater;</span>
<a href="#l13.43"></a><span id="l13.43">         if (nextToLast &lt; 0)  // is range at end?</span>
<a href="#l13.44"></a><span id="l13.44">         {</span>
<a href="#l13.45"></a><span id="l13.45">           int32_t rangeStart = m_data[m_length - 1];</span>
<a href="#l13.46"></a><span id="l13.46">           int32_t rangeLength = -nextToLast;</span>
<a href="#l13.47"></a><span id="l13.47">           curHighWater = (rangeLength + rangeStart - 1);</span>
<a href="#l13.48"></a><span id="l13.48">           if (curHighWater &gt; newHighWaterMark)</span>
<a href="#l13.49"></a><span id="l13.49">           {</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineminus">-            if (rangeStart &gt; newHighWaterMark)  </span>
<a href="#l13.51"></a><span id="l13.51" class="difflineplus">+            if (rangeStart &gt; newHighWaterMark)</span>
<a href="#l13.52"></a><span id="l13.52">             {</span>
<a href="#l13.53"></a><span id="l13.53">               m_length -= 2;  // throw away whole range</span>
<a href="#l13.54"></a><span id="l13.54">             }</span>
<a href="#l13.55"></a><span id="l13.55">             else if (rangeStart == newHighWaterMark)</span>
<a href="#l13.56"></a><span id="l13.56">             {</span>
<a href="#l13.57"></a><span id="l13.57">               // turn range into single element.</span>
<a href="#l13.58"></a><span id="l13.58">               m_data[m_length - 2] = newHighWaterMark;</span>
<a href="#l13.59"></a><span id="l13.59">               m_length--;</span>
<a href="#l13.60"></a><span id="l13.60" class="difflineat">@@ -402,38 +402,38 @@ void nsMsgKeySet::SetLastMember(int32_t </span>
<a href="#l13.61"></a><span id="l13.61">               m_data[m_length - 2] = -(newHighWaterMark - rangeStart);</span>
<a href="#l13.62"></a><span id="l13.62">               break;</span>
<a href="#l13.63"></a><span id="l13.63">             }</span>
<a href="#l13.64"></a><span id="l13.64">           }</span>
<a href="#l13.65"></a><span id="l13.65">           else {</span>
<a href="#l13.66"></a><span id="l13.66">             // prevent the infinite loop</span>
<a href="#l13.67"></a><span id="l13.67">             // see bug #13062</span>
<a href="#l13.68"></a><span id="l13.68">             break;</span>
<a href="#l13.69"></a><span id="l13.69" class="difflineminus">-          }  </span>
<a href="#l13.70"></a><span id="l13.70" class="difflineplus">+          }</span>
<a href="#l13.71"></a><span id="l13.71">         }</span>
<a href="#l13.72"></a><span id="l13.72">         else if (m_data[m_length - 1] &gt; newHighWaterMark)  // no, so last number must be last member</span>
<a href="#l13.73"></a><span id="l13.73">         {</span>
<a href="#l13.74"></a><span id="l13.74">           m_length--;</span>
<a href="#l13.75"></a><span id="l13.75">         }</span>
<a href="#l13.76"></a><span id="l13.76">         else</span>
<a href="#l13.77"></a><span id="l13.77">           break;</span>
<a href="#l13.78"></a><span id="l13.78">       }</span>
<a href="#l13.79"></a><span id="l13.79" class="difflineminus">-      else </span>
<a href="#l13.80"></a><span id="l13.80" class="difflineplus">+      else</span>
<a href="#l13.81"></a><span id="l13.81">         break;</span>
<a href="#l13.82"></a><span id="l13.82">     }</span>
<a href="#l13.83"></a><span id="l13.83" class="difflineminus">-    // well, the whole range is probably invalid, because the server probably re-ordered ids, </span>
<a href="#l13.84"></a><span id="l13.84" class="difflineplus">+    // well, the whole range is probably invalid, because the server probably re-ordered ids,</span>
<a href="#l13.85"></a><span id="l13.85">     // but what can you do?</span>
<a href="#l13.86"></a><span id="l13.86"> #ifdef NEWSRC_DOES_HOST_STUFF</span>
<a href="#l13.87"></a><span id="l13.87" class="difflineminus">-    if (m_host) </span>
<a href="#l13.88"></a><span id="l13.88" class="difflineplus">+    if (m_host)</span>
<a href="#l13.89"></a><span id="l13.89">       m_host-&gt;MarkDirty();</span>
<a href="#l13.90"></a><span id="l13.90"> #endif</span>
<a href="#l13.91"></a><span id="l13.91">   }</span>
<a href="#l13.92"></a><span id="l13.92"> }</span>
<a href="#l13.93"></a><span id="l13.93"> </span>
<a href="#l13.94"></a><span id="l13.94" class="difflineminus">-int32_t </span>
<a href="#l13.95"></a><span id="l13.95" class="difflineplus">+int32_t</span>
<a href="#l13.96"></a><span id="l13.96"> nsMsgKeySet::GetFirstMember()</span>
<a href="#l13.97"></a><span id="l13.97"> {</span>
<a href="#l13.98"></a><span id="l13.98">   if (m_length &gt; 1)</span>
<a href="#l13.99"></a><span id="l13.99">   {</span>
<a href="#l13.100"></a><span id="l13.100">     int32_t first = m_data[0];</span>
<a href="#l13.101"></a><span id="l13.101">     if (first &lt; 0)  // is range at start?</span>
<a href="#l13.102"></a><span id="l13.102">     {</span>
<a href="#l13.103"></a><span id="l13.103">       int32_t second = m_data[1];</span>
<a href="#l13.104"></a><span id="l13.104" class="difflineat">@@ -496,17 +496,17 @@ nsMsgKeySet::Optimize()</span>
<a href="#l13.105"></a><span id="l13.105"> </span>
<a href="#l13.106"></a><span id="l13.106">     if (range_p) {</span>
<a href="#l13.107"></a><span id="l13.107">       /* it's a range */</span>
<a href="#l13.108"></a><span id="l13.108">       from = input_tail[1];</span>
<a href="#l13.109"></a><span id="l13.109">       to = from + (-(input_tail[0]));</span>
<a href="#l13.110"></a><span id="l13.110"> </span>
<a href="#l13.111"></a><span id="l13.111">       /* Copy it over */</span>
<a href="#l13.112"></a><span id="l13.112">       *output_tail++ = *input_tail++;</span>
<a href="#l13.113"></a><span id="l13.113" class="difflineminus">-      *output_tail++ = *input_tail++;        </span>
<a href="#l13.114"></a><span id="l13.114" class="difflineplus">+      *output_tail++ = *input_tail++;</span>
<a href="#l13.115"></a><span id="l13.115">     } else {</span>
<a href="#l13.116"></a><span id="l13.116">       /* it's a literal */</span>
<a href="#l13.117"></a><span id="l13.117">       from = *input_tail;</span>
<a href="#l13.118"></a><span id="l13.118">       to = from;</span>
<a href="#l13.119"></a><span id="l13.119"> </span>
<a href="#l13.120"></a><span id="l13.120">       /* Copy it over */</span>
<a href="#l13.121"></a><span id="l13.121">       *output_tail++ = *input_tail++;</span>
<a href="#l13.122"></a><span id="l13.122">     }</span>
<a href="#l13.123"></a><span id="l13.123" class="difflineat">@@ -644,17 +644,17 @@ nsMsgKeySet::Add(int32_t number)</span>
<a href="#l13.124"></a><span id="l13.124">   int32_t size;</span>
<a href="#l13.125"></a><span id="l13.125">   int32_t *head;</span>
<a href="#l13.126"></a><span id="l13.126">   int32_t *tail;</span>
<a href="#l13.127"></a><span id="l13.127">   int32_t *end;</span>
<a href="#l13.128"></a><span id="l13.128"> </span>
<a href="#l13.129"></a><span id="l13.129"> #ifdef DEBUG_MSGKEYSET</span>
<a href="#l13.130"></a><span id="l13.130">     printf(&quot;add %d\n&quot;,number);</span>
<a href="#l13.131"></a><span id="l13.131"> #endif</span>
<a href="#l13.132"></a><span id="l13.132" class="difflineminus">-    </span>
<a href="#l13.133"></a><span id="l13.133" class="difflineplus">+</span>
<a href="#l13.134"></a><span id="l13.134">   size = m_length;</span>
<a href="#l13.135"></a><span id="l13.135">   head = m_data;</span>
<a href="#l13.136"></a><span id="l13.136">   tail = head;</span>
<a href="#l13.137"></a><span id="l13.137">   end = head + size;</span>
<a href="#l13.138"></a><span id="l13.138"> </span>
<a href="#l13.139"></a><span id="l13.139">   NS_ASSERTION (number &gt;= 0, &quot;can't have negative items&quot;);</span>
<a href="#l13.140"></a><span id="l13.140">   if (number &lt; 0)</span>
<a href="#l13.141"></a><span id="l13.141">     return 0;</span>
<a href="#l13.142"></a><span id="l13.142" class="difflineat">@@ -699,17 +699,17 @@ nsMsgKeySet::Add(int32_t number)</span>
<a href="#l13.143"></a><span id="l13.143">     }</span>
<a href="#l13.144"></a><span id="l13.144">   }</span>
<a href="#l13.145"></a><span id="l13.145"> </span>
<a href="#l13.146"></a><span id="l13.146">   /* At this point, `tail' points to a position in the set which represents</span>
<a href="#l13.147"></a><span id="l13.147">      a value greater than `new'; or it is at `end'. In the interest of</span>
<a href="#l13.148"></a><span id="l13.148">      avoiding massive duplication of code, simply insert a literal here and</span>
<a href="#l13.149"></a><span id="l13.149">      then run the optimizer.</span>
<a href="#l13.150"></a><span id="l13.150">      */</span>
<a href="#l13.151"></a><span id="l13.151" class="difflineminus">-  int mid = (tail - head); </span>
<a href="#l13.152"></a><span id="l13.152" class="difflineplus">+  int mid = (tail - head);</span>
<a href="#l13.153"></a><span id="l13.153"> </span>
<a href="#l13.154"></a><span id="l13.154">   if (m_data_size &lt;= m_length + 1) {</span>
<a href="#l13.155"></a><span id="l13.155">     int endo = end - head;</span>
<a href="#l13.156"></a><span id="l13.156">     if (!Grow()) {</span>
<a href="#l13.157"></a><span id="l13.157">       // out of memory</span>
<a href="#l13.158"></a><span id="l13.158">       return -1;</span>
<a href="#l13.159"></a><span id="l13.159">     }</span>
<a href="#l13.160"></a><span id="l13.160">     head = m_data;</span>
<a href="#l13.161"></a><span id="l13.161" class="difflineat">@@ -1022,17 +1022,17 @@ nsMsgKeySet::CountMissingInRange(int32_t</span>
<a href="#l13.162"></a><span id="l13.162">       tail++;</span>
<a href="#l13.163"></a><span id="l13.163">     }</span>
<a href="#l13.164"></a><span id="l13.164">     NS_ASSERTION (count &gt;= 0, &quot;invalid count&quot;);</span>
<a href="#l13.165"></a><span id="l13.165">   }</span>
<a href="#l13.166"></a><span id="l13.166">   return count;</span>
<a href="#l13.167"></a><span id="l13.167"> }</span>
<a href="#l13.168"></a><span id="l13.168"> </span>
<a href="#l13.169"></a><span id="l13.169"> </span>
<a href="#l13.170"></a><span id="l13.170" class="difflineminus">-int </span>
<a href="#l13.171"></a><span id="l13.171" class="difflineplus">+int</span>
<a href="#l13.172"></a><span id="l13.172"> nsMsgKeySet::FirstMissingRange(int32_t min, int32_t max,</span>
<a href="#l13.173"></a><span id="l13.173">                   int32_t* first, int32_t* last)</span>
<a href="#l13.174"></a><span id="l13.174"> {</span>
<a href="#l13.175"></a><span id="l13.175">   int32_t size;</span>
<a href="#l13.176"></a><span id="l13.176">   int32_t *head;</span>
<a href="#l13.177"></a><span id="l13.177">   int32_t *tail;</span>
<a href="#l13.178"></a><span id="l13.178">   int32_t *end;</span>
<a href="#l13.179"></a><span id="l13.179">   int32_t from = 0;</span>
<a href="#l13.180"></a><span id="l13.180" class="difflineat">@@ -1069,30 +1069,30 @@ nsMsgKeySet::FirstMissingRange(int32_t m</span>
<a href="#l13.181"></a><span id="l13.181">        intersects the [min,max] range we were given. */</span>
<a href="#l13.182"></a><span id="l13.182">     if (a &gt; max) return 0;  /* It's hopeless; there are none. */</span>
<a href="#l13.183"></a><span id="l13.183">     if (a &lt;= b &amp;&amp; b &gt;= min) {</span>
<a href="#l13.184"></a><span id="l13.184">       /* Ah-hah!  We found an intersection. */</span>
<a href="#l13.185"></a><span id="l13.185">       *first = a &gt; min ? a : min;</span>
<a href="#l13.186"></a><span id="l13.186">       *last = b &lt; max ? b : max;</span>
<a href="#l13.187"></a><span id="l13.187">       return 0;</span>
<a href="#l13.188"></a><span id="l13.188">     }</span>
<a href="#l13.189"></a><span id="l13.189" class="difflineminus">-  } </span>
<a href="#l13.190"></a><span id="l13.190" class="difflineplus">+  }</span>
<a href="#l13.191"></a><span id="l13.191">   /* We found no holes in the newsrc that overlaps the range, nor did we hit</span>
<a href="#l13.192"></a><span id="l13.192">      something read beyond the end of the range.  So, the great infinite</span>
<a href="#l13.193"></a><span id="l13.193">      range of unread articles at the end of any newsrc line intersects the</span>
<a href="#l13.194"></a><span id="l13.194">      range we want, and we just need to return that. */</span>
<a href="#l13.195"></a><span id="l13.195">   a = to + 1;</span>
<a href="#l13.196"></a><span id="l13.196">   *first = a &gt; min ? a : min;</span>
<a href="#l13.197"></a><span id="l13.197">   *last = max;</span>
<a href="#l13.198"></a><span id="l13.198">   return 0;</span>
<a href="#l13.199"></a><span id="l13.199"> }</span>
<a href="#l13.200"></a><span id="l13.200"> </span>
<a href="#l13.201"></a><span id="l13.201"> // I'm guessing we didn't include this because we didn't think we're going</span>
<a href="#l13.202"></a><span id="l13.202"> // to need it. I'm not so sure. I'm putting it in for now.</span>
<a href="#l13.203"></a><span id="l13.203" class="difflineminus">-int </span>
<a href="#l13.204"></a><span id="l13.204" class="difflineplus">+int</span>
<a href="#l13.205"></a><span id="l13.205"> nsMsgKeySet::LastMissingRange(int32_t min, int32_t max,</span>
<a href="#l13.206"></a><span id="l13.206">                   int32_t* first, int32_t* last)</span>
<a href="#l13.207"></a><span id="l13.207"> {</span>
<a href="#l13.208"></a><span id="l13.208">   int32_t size;</span>
<a href="#l13.209"></a><span id="l13.209">   int32_t *head;</span>
<a href="#l13.210"></a><span id="l13.210">   int32_t *tail;</span>
<a href="#l13.211"></a><span id="l13.211">   int32_t *end;</span>
<a href="#l13.212"></a><span id="l13.212">   int32_t from = 0;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/base/util/nsMsgKeySet.h</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgKeySet.h</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -23,51 +23,51 @@ class NS_MSG_BASE nsMsgKeySet {</span>
<a href="#l14.4"></a><span id="l14.4"> public:</span>
<a href="#l14.5"></a><span id="l14.5">   // Creates an empty set.</span>
<a href="#l14.6"></a><span id="l14.6">   static nsMsgKeySet* Create(/* MSG_NewsHost* host = NULL*/);</span>
<a href="#l14.7"></a><span id="l14.7"> </span>
<a href="#l14.8"></a><span id="l14.8">   // Creates a set from the list of numbers, as might be found in a</span>
<a href="#l14.9"></a><span id="l14.9">   // newsrc file.</span>
<a href="#l14.10"></a><span id="l14.10">   static nsMsgKeySet* Create(const char* str/* , MSG_NewsHost* host = NULL*/);</span>
<a href="#l14.11"></a><span id="l14.11">   ~nsMsgKeySet();</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-  </span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+</span>
<a href="#l14.14"></a><span id="l14.14">   // FirstNonMember() returns the lowest non-member of the set that is</span>
<a href="#l14.15"></a><span id="l14.15">   // greater than 0.</span>
<a href="#l14.16"></a><span id="l14.16">   int32_t FirstNonMember();</span>
<a href="#l14.17"></a><span id="l14.17"> </span>
<a href="#l14.18"></a><span id="l14.18">   // Output() converts to a string representation suitable for writing to a</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineminus">-  // .newsrc file.  </span>
<a href="#l14.20"></a><span id="l14.20" class="difflineminus">-  nsresult Output(char **outputStr);    </span>
<a href="#l14.21"></a><span id="l14.21" class="difflineplus">+  // .newsrc file.</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineplus">+  nsresult Output(char **outputStr);</span>
<a href="#l14.23"></a><span id="l14.23"> </span>
<a href="#l14.24"></a><span id="l14.24">   // IsMember() returns whether the given article is a member of this set.</span>
<a href="#l14.25"></a><span id="l14.25">   bool IsMember(int32_t art);</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineminus">-  </span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+</span>
<a href="#l14.28"></a><span id="l14.28">   // Add() adds the given article to the set.  (Returns 1 if a change was</span>
<a href="#l14.29"></a><span id="l14.29">   // made, 0 if it was already there, and negative on error.)</span>
<a href="#l14.30"></a><span id="l14.30">   int Add(int32_t art);</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineminus">-  </span>
<a href="#l14.32"></a><span id="l14.32" class="difflineminus">-  // Remove() removes the given article from the set. </span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+  // Remove() removes the given article from the set.</span>
<a href="#l14.35"></a><span id="l14.35">   int Remove(int32_t art);</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineminus">-  </span>
<a href="#l14.37"></a><span id="l14.37" class="difflineplus">+</span>
<a href="#l14.38"></a><span id="l14.38">   // AddRange() adds the (inclusive) given range of articles to the set.</span>
<a href="#l14.39"></a><span id="l14.39">   int AddRange(int32_t first, int32_t last);</span>
<a href="#l14.40"></a><span id="l14.40" class="difflineminus">-  </span>
<a href="#l14.41"></a><span id="l14.41" class="difflineplus">+</span>
<a href="#l14.42"></a><span id="l14.42">   // CountMissingInRange() takes an inclusive range of articles and returns</span>
<a href="#l14.43"></a><span id="l14.43">   // the number of articles in that range which are not in the set.</span>
<a href="#l14.44"></a><span id="l14.44">   int32_t CountMissingInRange(int32_t start, int32_t end);</span>
<a href="#l14.45"></a><span id="l14.45" class="difflineminus">-  </span>
<a href="#l14.46"></a><span id="l14.46" class="difflineplus">+</span>
<a href="#l14.47"></a><span id="l14.47">   // FirstMissingRange() takes an inclusive range and finds the first range</span>
<a href="#l14.48"></a><span id="l14.48" class="difflineminus">-  // of articles that are not in the set.  If none, return zeros. </span>
<a href="#l14.49"></a><span id="l14.49" class="difflineplus">+  // of articles that are not in the set.  If none, return zeros.</span>
<a href="#l14.50"></a><span id="l14.50">   int FirstMissingRange(int32_t min, int32_t max, int32_t* first, int32_t* last);</span>
<a href="#l14.51"></a><span id="l14.51" class="difflineminus">-  </span>
<a href="#l14.52"></a><span id="l14.52" class="difflineplus">+</span>
<a href="#l14.53"></a><span id="l14.53"> </span>
<a href="#l14.54"></a><span id="l14.54">   // LastMissingRange() takes an inclusive range and finds the last range</span>
<a href="#l14.55"></a><span id="l14.55" class="difflineminus">-  // of articles that are not in the set.  If none, return zeros. </span>
<a href="#l14.56"></a><span id="l14.56" class="difflineplus">+  // of articles that are not in the set.  If none, return zeros.</span>
<a href="#l14.57"></a><span id="l14.57">   int LastMissingRange(int32_t min, int32_t max, int32_t* first, int32_t* last);</span>
<a href="#l14.58"></a><span id="l14.58" class="difflineminus">-  </span>
<a href="#l14.59"></a><span id="l14.59" class="difflineplus">+</span>
<a href="#l14.60"></a><span id="l14.60">   int32_t GetLastMember();</span>
<a href="#l14.61"></a><span id="l14.61">   int32_t GetFirstMember();</span>
<a href="#l14.62"></a><span id="l14.62">   void  SetLastMember(int32_t highWaterMark);</span>
<a href="#l14.63"></a><span id="l14.63">   // For debugging only...</span>
<a href="#l14.64"></a><span id="l14.64">   int32_t getLength() {return m_length;}</span>
<a href="#l14.65"></a><span id="l14.65"> </span>
<a href="#l14.66"></a><span id="l14.66"> /**</span>
<a href="#l14.67"></a><span id="l14.67">  * Fill the passed in aArray with the keys in the message key set.</span>
<a href="#l14.68"></a><span id="l14.68" class="difflineat">@@ -78,28 +78,28 @@ public:</span>
<a href="#l14.69"></a><span id="l14.69">   static void RunTests();</span>
<a href="#l14.70"></a><span id="l14.70"> #endif</span>
<a href="#l14.71"></a><span id="l14.71"> </span>
<a href="#l14.72"></a><span id="l14.72"> protected:</span>
<a href="#l14.73"></a><span id="l14.73">   nsMsgKeySet(/* MSG_NewsHost* host */);</span>
<a href="#l14.74"></a><span id="l14.74">   nsMsgKeySet(const char* /* , MSG_NewsHost* host */);</span>
<a href="#l14.75"></a><span id="l14.75">   bool Grow();</span>
<a href="#l14.76"></a><span id="l14.76">   bool Optimize();</span>
<a href="#l14.77"></a><span id="l14.77" class="difflineminus">-  </span>
<a href="#l14.78"></a><span id="l14.78" class="difflineplus">+</span>
<a href="#l14.79"></a><span id="l14.79"> #ifdef DEBUG</span>
<a href="#l14.80"></a><span id="l14.80">   static void test_decoder(const char*);</span>
<a href="#l14.81"></a><span id="l14.81">   static void test_adder();</span>
<a href="#l14.82"></a><span id="l14.82">   static void test_ranges();</span>
<a href="#l14.83"></a><span id="l14.83">   static void test_member(bool with_cache);</span>
<a href="#l14.84"></a><span id="l14.84"> #endif</span>
<a href="#l14.85"></a><span id="l14.85" class="difflineminus">-  </span>
<a href="#l14.86"></a><span id="l14.86" class="difflineplus">+</span>
<a href="#l14.87"></a><span id="l14.87">   int32_t *m_data;          /* the numbers composing the `chunks' */</span>
<a href="#l14.88"></a><span id="l14.88">   int32_t m_data_size;        /* size of that malloc'ed block */</span>
<a href="#l14.89"></a><span id="l14.89">   int32_t m_length;        /* active area */</span>
<a href="#l14.90"></a><span id="l14.90" class="difflineminus">-  </span>
<a href="#l14.91"></a><span id="l14.91" class="difflineplus">+</span>
<a href="#l14.92"></a><span id="l14.92">   int32_t m_cached_value;      /* a potential set member, or -1 if unset*/</span>
<a href="#l14.93"></a><span id="l14.93">   int32_t m_cached_value_index;    /* the index into `data' at which a search</span>
<a href="#l14.94"></a><span id="l14.94">                      to determine whether `cached_value' was</span>
<a href="#l14.95"></a><span id="l14.95">                      a member of the set ended. */</span>
<a href="#l14.96"></a><span id="l14.96"> #ifdef NEWSRC_DOES_HOST_STUFF</span>
<a href="#l14.97"></a><span id="l14.97">   MSG_NewsHost* m_host;</span>
<a href="#l14.98"></a><span id="l14.98"> #endif</span>
<a href="#l14.99"></a><span id="l14.99"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/base/util/nsMsgLineBuffer.cpp</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgLineBuffer.cpp</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -29,34 +29,33 @@ nsByteArray::~nsByteArray()</span>
<a href="#l15.4"></a><span id="l15.4"> nsresult nsByteArray::GrowBuffer(uint32_t desired_size, uint32_t quantum)</span>
<a href="#l15.5"></a><span id="l15.5"> {</span>
<a href="#l15.6"></a><span id="l15.6">   if (m_bufferSize &lt; desired_size)</span>
<a href="#l15.7"></a><span id="l15.7">   {</span>
<a href="#l15.8"></a><span id="l15.8">     char *new_buf;</span>
<a href="#l15.9"></a><span id="l15.9">     uint32_t increment = desired_size - m_bufferSize;</span>
<a href="#l15.10"></a><span id="l15.10">     if (increment &lt; quantum) /* always grow by a minimum of N bytes */</span>
<a href="#l15.11"></a><span id="l15.11">       increment = quantum;</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-    </span>
<a href="#l15.13"></a><span id="l15.13" class="difflineminus">-    </span>
<a href="#l15.14"></a><span id="l15.14" class="difflineplus">+</span>
<a href="#l15.15"></a><span id="l15.15">     new_buf = (m_buffer</span>
<a href="#l15.16"></a><span id="l15.16">       ? (char *) PR_REALLOC (m_buffer, (m_bufferSize + increment))</span>
<a href="#l15.17"></a><span id="l15.17">       : (char *) PR_MALLOC (m_bufferSize + increment));</span>
<a href="#l15.18"></a><span id="l15.18">     if (! new_buf)</span>
<a href="#l15.19"></a><span id="l15.19">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l15.20"></a><span id="l15.20">     m_buffer = new_buf;</span>
<a href="#l15.21"></a><span id="l15.21">     m_bufferSize += increment;</span>
<a href="#l15.22"></a><span id="l15.22">   }</span>
<a href="#l15.23"></a><span id="l15.23">   return NS_OK;</span>
<a href="#l15.24"></a><span id="l15.24"> }</span>
<a href="#l15.25"></a><span id="l15.25"> </span>
<a href="#l15.26"></a><span id="l15.26"> nsresult nsByteArray::AppendString(const char *string)</span>
<a href="#l15.27"></a><span id="l15.27"> {</span>
<a href="#l15.28"></a><span id="l15.28">   uint32_t strLength = (string) ? PL_strlen(string) : 0;</span>
<a href="#l15.29"></a><span id="l15.29">   return AppendBuffer(string, strLength);</span>
<a href="#l15.30"></a><span id="l15.30" class="difflineminus">-  </span>
<a href="#l15.31"></a><span id="l15.31" class="difflineplus">+</span>
<a href="#l15.32"></a><span id="l15.32"> }</span>
<a href="#l15.33"></a><span id="l15.33"> </span>
<a href="#l15.34"></a><span id="l15.34"> nsresult nsByteArray::AppendBuffer(const char *buffer, uint32_t length)</span>
<a href="#l15.35"></a><span id="l15.35"> {</span>
<a href="#l15.36"></a><span id="l15.36">   nsresult ret = NS_OK;</span>
<a href="#l15.37"></a><span id="l15.37">   if (m_bufferPos + length &gt; m_bufferSize)</span>
<a href="#l15.38"></a><span id="l15.38">     ret = GrowBuffer(m_bufferPos + length, 1024);</span>
<a href="#l15.39"></a><span id="l15.39">   if (NS_SUCCEEDED(ret))</span>
<a href="#l15.40"></a><span id="l15.40" class="difflineat">@@ -137,45 +136,45 @@ nsresult nsMsgLineBuffer::BufferInput(co</span>
<a href="#l15.41"></a><span id="l15.41">             /* if not looking for a CRLF, stop at CR or LF.  (for example, when parsing the newsrc file).  this fixes #9896, where we'd lose the last line of anything we'd parse that used CR as the line break. */</span>
<a href="#l15.42"></a><span id="l15.42">             if (*s == '\r' || *s == '\n') {</span>
<a href="#l15.43"></a><span id="l15.43">               newline = s;</span>
<a href="#l15.44"></a><span id="l15.44">               newline++;</span>
<a href="#l15.45"></a><span id="l15.45">               break;</span>
<a href="#l15.46"></a><span id="l15.46">             }</span>
<a href="#l15.47"></a><span id="l15.47">           }</span>
<a href="#l15.48"></a><span id="l15.48">         }</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineminus">-        </span>
<a href="#l15.50"></a><span id="l15.50" class="difflineplus">+</span>
<a href="#l15.51"></a><span id="l15.51">         /* Ensure room in the net_buffer and append some or all of the current</span>
<a href="#l15.52"></a><span id="l15.52">            chunk of data to it. */</span>
<a href="#l15.53"></a><span id="l15.53">         {</span>
<a href="#l15.54"></a><span id="l15.54">             const char *end = (newline ? newline : net_buffer_end);</span>
<a href="#l15.55"></a><span id="l15.55">             uint32_t desired_size = (end - net_buffer) + m_bufferPos + 1;</span>
<a href="#l15.56"></a><span id="l15.56" class="difflineminus">-            </span>
<a href="#l15.57"></a><span id="l15.57" class="difflineplus">+</span>
<a href="#l15.58"></a><span id="l15.58">             if (desired_size &gt;= m_bufferSize)</span>
<a href="#l15.59"></a><span id="l15.59">             {</span>
<a href="#l15.60"></a><span id="l15.60">                 status = GrowBuffer (desired_size, 1024);</span>
<a href="#l15.61"></a><span id="l15.61">                 if (NS_FAILED(status))</span>
<a href="#l15.62"></a><span id="l15.62">                     return status;</span>
<a href="#l15.63"></a><span id="l15.63">             }</span>
<a href="#l15.64"></a><span id="l15.64">             memcpy (m_buffer + m_bufferPos, net_buffer, (end - net_buffer));</span>
<a href="#l15.65"></a><span id="l15.65">             m_bufferPos += (end - net_buffer);</span>
<a href="#l15.66"></a><span id="l15.66">         }</span>
<a href="#l15.67"></a><span id="l15.67" class="difflineminus">-        </span>
<a href="#l15.68"></a><span id="l15.68" class="difflineplus">+</span>
<a href="#l15.69"></a><span id="l15.69">         /* Now m_buffer contains either a complete line, or as complete</span>
<a href="#l15.70"></a><span id="l15.70">            a line as we have read so far.</span>
<a href="#l15.71"></a><span id="l15.71" class="difflineminus">-           </span>
<a href="#l15.72"></a><span id="l15.72" class="difflineplus">+</span>
<a href="#l15.73"></a><span id="l15.73">            If we have a line, process it, and then remove it from `m_buffer'.</span>
<a href="#l15.74"></a><span id="l15.74">            Then go around the loop again, until we drain the incoming data.</span>
<a href="#l15.75"></a><span id="l15.75" class="difflineminus">-           */</span>
<a href="#l15.76"></a><span id="l15.76" class="difflineplus">+         */</span>
<a href="#l15.77"></a><span id="l15.77">         if (!newline)</span>
<a href="#l15.78"></a><span id="l15.78">             return NS_OK;</span>
<a href="#l15.79"></a><span id="l15.79"> </span>
<a href="#l15.80"></a><span id="l15.80">         if (NS_FAILED(ConvertAndSendBuffer()))</span>
<a href="#l15.81"></a><span id="l15.81">           return NS_ERROR_FAILURE;</span>
<a href="#l15.82"></a><span id="l15.82" class="difflineminus">-        </span>
<a href="#l15.83"></a><span id="l15.83" class="difflineplus">+</span>
<a href="#l15.84"></a><span id="l15.84">         net_buffer_size -= (newline - net_buffer);</span>
<a href="#l15.85"></a><span id="l15.85">         net_buffer = newline;</span>
<a href="#l15.86"></a><span id="l15.86">         m_bufferPos = 0;</span>
<a href="#l15.87"></a><span id="l15.87">     }</span>
<a href="#l15.88"></a><span id="l15.88">     return NS_OK;</span>
<a href="#l15.89"></a><span id="l15.89"> }</span>
<a href="#l15.90"></a><span id="l15.90"> </span>
<a href="#l15.91"></a><span id="l15.91"> nsresult nsMsgLineBuffer::HandleLine(const char *line, uint32_t line_length)</span>
<a href="#l15.92"></a><span id="l15.92" class="difflineat">@@ -188,26 +187,26 @@ nsresult nsMsgLineBuffer::ConvertAndSend</span>
<a href="#l15.93"></a><span id="l15.93"> {</span>
<a href="#l15.94"></a><span id="l15.94">     /* Convert the line terminator to the native form.</span>
<a href="#l15.95"></a><span id="l15.95">      */</span>
<a href="#l15.96"></a><span id="l15.96"> </span>
<a href="#l15.97"></a><span id="l15.97">     char *buf = m_buffer;</span>
<a href="#l15.98"></a><span id="l15.98">     int32_t length = m_bufferPos;</span>
<a href="#l15.99"></a><span id="l15.99"> </span>
<a href="#l15.100"></a><span id="l15.100">     char* newline;</span>
<a href="#l15.101"></a><span id="l15.101" class="difflineminus">-    </span>
<a href="#l15.102"></a><span id="l15.102" class="difflineplus">+</span>
<a href="#l15.103"></a><span id="l15.103">     PR_ASSERT(buf &amp;&amp; length &gt; 0);</span>
<a href="#l15.104"></a><span id="l15.104" class="difflineminus">-    if (!buf || length &lt;= 0) </span>
<a href="#l15.105"></a><span id="l15.105" class="difflineplus">+    if (!buf || length &lt;= 0)</span>
<a href="#l15.106"></a><span id="l15.106">         return NS_ERROR_FAILURE;</span>
<a href="#l15.107"></a><span id="l15.107">     newline = buf + length;</span>
<a href="#l15.108"></a><span id="l15.108" class="difflineminus">-    </span>
<a href="#l15.109"></a><span id="l15.109" class="difflineplus">+</span>
<a href="#l15.110"></a><span id="l15.110">     PR_ASSERT(newline[-1] == '\r' || newline[-1] == '\n');</span>
<a href="#l15.111"></a><span id="l15.111">     if (newline[-1] != '\r' &amp;&amp; newline[-1] != '\n')</span>
<a href="#l15.112"></a><span id="l15.112">         return NS_ERROR_FAILURE;</span>
<a href="#l15.113"></a><span id="l15.113" class="difflineminus">-    </span>
<a href="#l15.114"></a><span id="l15.114" class="difflineplus">+</span>
<a href="#l15.115"></a><span id="l15.115">     if (m_convertNewlinesP)</span>
<a href="#l15.116"></a><span id="l15.116">     {</span>
<a href="#l15.117"></a><span id="l15.117"> #if (MSG_LINEBREAK_LEN == 1)</span>
<a href="#l15.118"></a><span id="l15.118">       if ((newline - buf) &gt;= 2 &amp;&amp;</span>
<a href="#l15.119"></a><span id="l15.119">            newline[-2] == '\r' &amp;&amp;</span>
<a href="#l15.120"></a><span id="l15.120">            newline[-1] == '\n')</span>
<a href="#l15.121"></a><span id="l15.121">       {</span>
<a href="#l15.122"></a><span id="l15.122">         /* CRLF -&gt; CR or LF */</span>
<a href="#l15.123"></a><span id="l15.123" class="difflineat">@@ -225,37 +224,37 @@ nsresult nsMsgLineBuffer::ConvertAndSend</span>
<a href="#l15.124"></a><span id="l15.124">                ((newline - buf) &gt;= 1 &amp;&amp; newline[-1] != '\n'))</span>
<a href="#l15.125"></a><span id="l15.125">       {</span>
<a href="#l15.126"></a><span id="l15.126">         /* LF -&gt; CRLF or CR -&gt; CRLF */</span>
<a href="#l15.127"></a><span id="l15.127">         length++;</span>
<a href="#l15.128"></a><span id="l15.128">         buf[length - 2] = MSG_LINEBREAK[0];</span>
<a href="#l15.129"></a><span id="l15.129">         buf[length - 1] = MSG_LINEBREAK[1];</span>
<a href="#l15.130"></a><span id="l15.130">       }</span>
<a href="#l15.131"></a><span id="l15.131"> #endif</span>
<a href="#l15.132"></a><span id="l15.132" class="difflineminus">-    }    </span>
<a href="#l15.133"></a><span id="l15.133" class="difflineplus">+    }</span>
<a href="#l15.134"></a><span id="l15.134">     return (m_handler) ? m_handler-&gt;HandleLine(buf, length) : HandleLine(buf, length);</span>
<a href="#l15.135"></a><span id="l15.135"> }</span>
<a href="#l15.136"></a><span id="l15.136"> </span>
<a href="#l15.137"></a><span id="l15.137"> // If there's still some data (non CRLF terminated) flush it out</span>
<a href="#l15.138"></a><span id="l15.138"> nsresult nsMsgLineBuffer::FlushLastLine()</span>
<a href="#l15.139"></a><span id="l15.139"> {</span>
<a href="#l15.140"></a><span id="l15.140">   char *buf = m_buffer + m_bufferPos;</span>
<a href="#l15.141"></a><span id="l15.141">   int32_t length = m_bufferPos - 1;</span>
<a href="#l15.142"></a><span id="l15.142">   if (length &gt; 0)</span>
<a href="#l15.143"></a><span id="l15.143">     return (m_handler) ? m_handler-&gt;HandleLine(buf, length) : HandleLine(buf, length);</span>
<a href="#l15.144"></a><span id="l15.144">   else</span>
<a href="#l15.145"></a><span id="l15.145">     return NS_OK;</span>
<a href="#l15.146"></a><span id="l15.146"> }</span>
<a href="#l15.147"></a><span id="l15.147"> </span>
<a href="#l15.148"></a><span id="l15.148"> ///////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l15.149"></a><span id="l15.149"> // This is a utility class used to efficiently extract lines from an input stream by buffering</span>
<a href="#l15.150"></a><span id="l15.150" class="difflineminus">-// read but unprocessed stream data in a buffer. </span>
<a href="#l15.151"></a><span id="l15.151" class="difflineplus">+// read but unprocessed stream data in a buffer.</span>
<a href="#l15.152"></a><span id="l15.152"> ///////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l15.153"></a><span id="l15.153"> </span>
<a href="#l15.154"></a><span id="l15.154" class="difflineminus">-nsMsgLineStreamBuffer::nsMsgLineStreamBuffer(uint32_t aBufferSize, bool aAllocateNewLines, bool aEatCRLFs, char aLineToken) </span>
<a href="#l15.155"></a><span id="l15.155" class="difflineplus">+nsMsgLineStreamBuffer::nsMsgLineStreamBuffer(uint32_t aBufferSize, bool aAllocateNewLines, bool aEatCRLFs, char aLineToken)</span>
<a href="#l15.156"></a><span id="l15.156">            : m_eatCRLFs(aEatCRLFs), m_allocateNewLines(aAllocateNewLines), m_lineToken(aLineToken)</span>
<a href="#l15.157"></a><span id="l15.157"> {</span>
<a href="#l15.158"></a><span id="l15.158">   NS_PRECONDITION(aBufferSize &gt; 0, &quot;invalid buffer size!!!&quot;);</span>
<a href="#l15.159"></a><span id="l15.159">   m_dataBuffer = nullptr;</span>
<a href="#l15.160"></a><span id="l15.160">   m_startPos = 0;</span>
<a href="#l15.161"></a><span id="l15.161">     m_numBytesInBuffer = 0;</span>
<a href="#l15.162"></a><span id="l15.162"> </span>
<a href="#l15.163"></a><span id="l15.163">   // used to buffer incoming data by ReadNextLineFromInput</span>
<a href="#l15.164"></a><span id="l15.164" class="difflineat">@@ -291,33 +290,33 @@ void nsMsgLineStreamBuffer::ClearBuffer(</span>
<a href="#l15.165"></a><span id="l15.165"> // aInputStream - the input stream we want to read a line from</span>
<a href="#l15.166"></a><span id="l15.166"> // aPauseForMoreData is returned as true if the stream does not yet contain a line and we must wait for more</span>
<a href="#l15.167"></a><span id="l15.167"> // data to come into the stream.</span>
<a href="#l15.168"></a><span id="l15.168"> // Note to people wishing to modify this function: Be *VERY CAREFUL* this is a critical function used by all of</span>
<a href="#l15.169"></a><span id="l15.169"> // our mail protocols including imap, nntp, and pop. If you screw it up, you could break a lot of stuff.....</span>
<a href="#l15.170"></a><span id="l15.170"> </span>
<a href="#l15.171"></a><span id="l15.171"> char * nsMsgLineStreamBuffer::ReadNextLine(nsIInputStream * aInputStream, uint32_t &amp;aNumBytesInLine, bool &amp;aPauseForMoreData, nsresult *prv, bool addLineTerminator)</span>
<a href="#l15.172"></a><span id="l15.172"> {</span>
<a href="#l15.173"></a><span id="l15.173" class="difflineminus">-  // try to extract a line from m_inputBuffer. If we don't have an entire line, </span>
<a href="#l15.174"></a><span id="l15.174" class="difflineplus">+  // try to extract a line from m_inputBuffer. If we don't have an entire line,</span>
<a href="#l15.175"></a><span id="l15.175">   // then read more bytes out from the stream. If the stream is empty then wait</span>
<a href="#l15.176"></a><span id="l15.176">   // on the monitor for more data to come in.</span>
<a href="#l15.177"></a><span id="l15.177" class="difflineminus">-  </span>
<a href="#l15.178"></a><span id="l15.178" class="difflineplus">+</span>
<a href="#l15.179"></a><span id="l15.179">   NS_PRECONDITION(m_dataBuffer &amp;&amp; m_dataBufferSize &gt; 0, &quot;invalid input arguments for read next line from input&quot;);</span>
<a href="#l15.180"></a><span id="l15.180"> </span>
<a href="#l15.181"></a><span id="l15.181">   if (prv)</span>
<a href="#l15.182"></a><span id="l15.182">     *prv = NS_OK;</span>
<a href="#l15.183"></a><span id="l15.183">   // initialize out values</span>
<a href="#l15.184"></a><span id="l15.184">   aPauseForMoreData = false;</span>
<a href="#l15.185"></a><span id="l15.185">   aNumBytesInLine = 0;</span>
<a href="#l15.186"></a><span id="l15.186">   char * endOfLine = nullptr;</span>
<a href="#l15.187"></a><span id="l15.187">   char * startOfLine = m_dataBuffer+m_startPos;</span>
<a href="#l15.188"></a><span id="l15.188" class="difflineminus">-  </span>
<a href="#l15.189"></a><span id="l15.189" class="difflineplus">+</span>
<a href="#l15.190"></a><span id="l15.190">   if (m_numBytesInBuffer &gt; 0) // any data in our internal buffer?</span>
<a href="#l15.191"></a><span id="l15.191">     endOfLine = PL_strchr(startOfLine, m_lineToken); // see if we already have a line ending...</span>
<a href="#l15.192"></a><span id="l15.192" class="difflineminus">-  </span>
<a href="#l15.193"></a><span id="l15.193" class="difflineplus">+</span>
<a href="#l15.194"></a><span id="l15.194">   // it's possible that we got here before the first time we receive data from the server</span>
<a href="#l15.195"></a><span id="l15.195">   // so aInputStream will be nullptr...</span>
<a href="#l15.196"></a><span id="l15.196">   if (!endOfLine &amp;&amp; aInputStream) // get some more data from the server</span>
<a href="#l15.197"></a><span id="l15.197">   {</span>
<a href="#l15.198"></a><span id="l15.198">     nsresult rv;</span>
<a href="#l15.199"></a><span id="l15.199">     uint64_t numBytesInStream = 0;</span>
<a href="#l15.200"></a><span id="l15.200">     uint32_t numBytesCopied = 0;</span>
<a href="#l15.201"></a><span id="l15.201">     bool nonBlockingStream;</span>
<a href="#l15.202"></a><span id="l15.202" class="difflineat">@@ -361,17 +360,17 @@ char * nsMsgLineStreamBuffer::ReadNextLi</span>
<a href="#l15.203"></a><span id="l15.203">         // if we can't grow the buffer, we have to bail.</span>
<a href="#l15.204"></a><span id="l15.204">         if (NS_FAILED(rv))</span>
<a href="#l15.205"></a><span id="l15.205">           return nullptr;</span>
<a href="#l15.206"></a><span id="l15.206">         startOfLine = m_dataBuffer;</span>
<a href="#l15.207"></a><span id="l15.207">         numFreeBytesInBuffer += growBy;</span>
<a href="#l15.208"></a><span id="l15.208">       }</span>
<a href="#l15.209"></a><span id="l15.209">       NS_ASSERTION(m_startPos == 0, &quot;m_startPos should be 0 .....\n&quot;);</span>
<a href="#l15.210"></a><span id="l15.210">     }</span>
<a href="#l15.211"></a><span id="l15.211" class="difflineminus">-    </span>
<a href="#l15.212"></a><span id="l15.212" class="difflineplus">+</span>
<a href="#l15.213"></a><span id="l15.213">     uint32_t numBytesToCopy = std::min(uint64_t(numFreeBytesInBuffer - 1) /* leave one for a null terminator */, numBytesInStream);</span>
<a href="#l15.214"></a><span id="l15.214">     if (numBytesToCopy &gt; 0)</span>
<a href="#l15.215"></a><span id="l15.215">     {</span>
<a href="#l15.216"></a><span id="l15.216">       // read the data into the end of our data buffer</span>
<a href="#l15.217"></a><span id="l15.217">       char *startOfNewData = startOfLine + m_numBytesInBuffer;</span>
<a href="#l15.218"></a><span id="l15.218">       rv = aInputStream-&gt;Read(startOfNewData, numBytesToCopy, &amp;numBytesCopied);</span>
<a href="#l15.219"></a><span id="l15.219">       if (prv)</span>
<a href="#l15.220"></a><span id="l15.220">         *prv = rv;</span>
<a href="#l15.221"></a><span id="l15.221" class="difflineat">@@ -384,57 +383,57 @@ char * nsMsgLineStreamBuffer::ReadNextLi</span>
<a href="#l15.222"></a><span id="l15.222">       m_numBytesInBuffer += numBytesCopied;</span>
<a href="#l15.223"></a><span id="l15.223">       m_dataBuffer[m_startPos + m_numBytesInBuffer] = '\0';</span>
<a href="#l15.224"></a><span id="l15.224"> </span>
<a href="#l15.225"></a><span id="l15.225">       // okay, now that we've tried to read in more data from the stream,</span>
<a href="#l15.226"></a><span id="l15.226">       // look for another end of line character in the new data</span>
<a href="#l15.227"></a><span id="l15.227">       endOfLine = PL_strchr(startOfNewData, m_lineToken);</span>
<a href="#l15.228"></a><span id="l15.228">     }</span>
<a href="#l15.229"></a><span id="l15.229">   }</span>
<a href="#l15.230"></a><span id="l15.230" class="difflineminus">-  </span>
<a href="#l15.231"></a><span id="l15.231" class="difflineplus">+</span>
<a href="#l15.232"></a><span id="l15.232">   // okay, now check again for endOfLine.</span>
<a href="#l15.233"></a><span id="l15.233">   if (endOfLine)</span>
<a href="#l15.234"></a><span id="l15.234">   {</span>
<a href="#l15.235"></a><span id="l15.235">     if (!m_eatCRLFs)</span>
<a href="#l15.236"></a><span id="l15.236">       endOfLine += 1; // count for LF or CR</span>
<a href="#l15.237"></a><span id="l15.237" class="difflineminus">-    </span>
<a href="#l15.238"></a><span id="l15.238" class="difflineplus">+</span>
<a href="#l15.239"></a><span id="l15.239">     aNumBytesInLine = endOfLine - startOfLine;</span>
<a href="#l15.240"></a><span id="l15.240" class="difflineminus">-    </span>
<a href="#l15.241"></a><span id="l15.241" class="difflineplus">+</span>
<a href="#l15.242"></a><span id="l15.242">     if (m_eatCRLFs &amp;&amp; aNumBytesInLine &gt; 0 &amp;&amp; startOfLine[aNumBytesInLine-1] == '\r') // Remove the CR in a CRLF sequence</span>
<a href="#l15.243"></a><span id="l15.243">       aNumBytesInLine--;</span>
<a href="#l15.244"></a><span id="l15.244" class="difflineminus">-    </span>
<a href="#l15.245"></a><span id="l15.245" class="difflineplus">+</span>
<a href="#l15.246"></a><span id="l15.246">     // PR_CALLOC zeros out the allocated line</span>
<a href="#l15.247"></a><span id="l15.247">     char* newLine = (char*) PR_CALLOC(aNumBytesInLine + (addLineTerminator ? MSG_LINEBREAK_LEN : 0) + 1);</span>
<a href="#l15.248"></a><span id="l15.248">     if (!newLine)</span>
<a href="#l15.249"></a><span id="l15.249">     {</span>
<a href="#l15.250"></a><span id="l15.250">       aNumBytesInLine = 0;</span>
<a href="#l15.251"></a><span id="l15.251">       aPauseForMoreData = true;</span>
<a href="#l15.252"></a><span id="l15.252">       return nullptr;</span>
<a href="#l15.253"></a><span id="l15.253">     }</span>
<a href="#l15.254"></a><span id="l15.254" class="difflineminus">-    </span>
<a href="#l15.255"></a><span id="l15.255" class="difflineplus">+</span>
<a href="#l15.256"></a><span id="l15.256">     memcpy(newLine, startOfLine, aNumBytesInLine); // copy the string into the new line buffer</span>
<a href="#l15.257"></a><span id="l15.257">     if (addLineTerminator)</span>
<a href="#l15.258"></a><span id="l15.258">     {</span>
<a href="#l15.259"></a><span id="l15.259">       memcpy(newLine + aNumBytesInLine, MSG_LINEBREAK, MSG_LINEBREAK_LEN);</span>
<a href="#l15.260"></a><span id="l15.260">       aNumBytesInLine += MSG_LINEBREAK_LEN;</span>
<a href="#l15.261"></a><span id="l15.261">     }</span>
<a href="#l15.262"></a><span id="l15.262" class="difflineminus">-    </span>
<a href="#l15.263"></a><span id="l15.263" class="difflineplus">+</span>
<a href="#l15.264"></a><span id="l15.264">     if (m_eatCRLFs)</span>
<a href="#l15.265"></a><span id="l15.265">       endOfLine += 1; // advance past LF or CR if we haven't already done so...</span>
<a href="#l15.266"></a><span id="l15.266" class="difflineminus">-    </span>
<a href="#l15.267"></a><span id="l15.267" class="difflineminus">-    // now we need to update the data buffer to go past the line we just read out. </span>
<a href="#l15.268"></a><span id="l15.268" class="difflineplus">+</span>
<a href="#l15.269"></a><span id="l15.269" class="difflineplus">+    // now we need to update the data buffer to go past the line we just read out.</span>
<a href="#l15.270"></a><span id="l15.270">     m_numBytesInBuffer -= (endOfLine - startOfLine);</span>
<a href="#l15.271"></a><span id="l15.271">     if (m_numBytesInBuffer)</span>
<a href="#l15.272"></a><span id="l15.272">       m_startPos = endOfLine - m_dataBuffer;</span>
<a href="#l15.273"></a><span id="l15.273">     else</span>
<a href="#l15.274"></a><span id="l15.274">       m_startPos = 0;</span>
<a href="#l15.275"></a><span id="l15.275" class="difflineminus">-    </span>
<a href="#l15.276"></a><span id="l15.276" class="difflineplus">+</span>
<a href="#l15.277"></a><span id="l15.277">     return newLine;</span>
<a href="#l15.278"></a><span id="l15.278">   }</span>
<a href="#l15.279"></a><span id="l15.279" class="difflineminus">-  </span>
<a href="#l15.280"></a><span id="l15.280" class="difflineplus">+</span>
<a href="#l15.281"></a><span id="l15.281">   aPauseForMoreData = true;</span>
<a href="#l15.282"></a><span id="l15.282">   return nullptr; // if we somehow got here. we don't have another line in the buffer yet...need to wait for more data...</span>
<a href="#l15.283"></a><span id="l15.283"> }</span>
<a href="#l15.284"></a><span id="l15.284"> </span>
<a href="#l15.285"></a><span id="l15.285"> bool nsMsgLineStreamBuffer::NextLineAvailable()</span>
<a href="#l15.286"></a><span id="l15.286"> {</span>
<a href="#l15.287"></a><span id="l15.287">   return (m_numBytesInBuffer &gt; 0 &amp;&amp; PL_strchr(m_dataBuffer+m_startPos, m_lineToken));</span>
<a href="#l15.288"></a><span id="l15.288"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/base/util/nsMsgLineBuffer.h</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgLineBuffer.h</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -6,17 +6,17 @@</span>
<a href="#l16.4"></a><span id="l16.4"> #define _nsMsgLineBuffer_H</span>
<a href="#l16.5"></a><span id="l16.5"> </span>
<a href="#l16.6"></a><span id="l16.6"> #include &quot;msgCore.h&quot;    // precompiled header...</span>
<a href="#l16.7"></a><span id="l16.7"> </span>
<a href="#l16.8"></a><span id="l16.8"> // I can't believe I have to have this stupid class, but I can't find</span>
<a href="#l16.9"></a><span id="l16.9"> // anything suitable (nsStrImpl might be, when it's done). nsIByteBuffer</span>
<a href="#l16.10"></a><span id="l16.10"> // would do, if I had a stream for input, which I don't.</span>
<a href="#l16.11"></a><span id="l16.11"> </span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-class NS_MSG_BASE nsByteArray </span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+class NS_MSG_BASE nsByteArray</span>
<a href="#l16.14"></a><span id="l16.14"> {</span>
<a href="#l16.15"></a><span id="l16.15"> public:</span>
<a href="#l16.16"></a><span id="l16.16">   nsByteArray();</span>
<a href="#l16.17"></a><span id="l16.17">   virtual ~nsByteArray();</span>
<a href="#l16.18"></a><span id="l16.18">   uint32_t  GetSize() {return m_bufferSize;}</span>
<a href="#l16.19"></a><span id="l16.19">   uint32_t  GetBufferPos() {return m_bufferPos;}</span>
<a href="#l16.20"></a><span id="l16.20">   nsresult  GrowBuffer(uint32_t desired_size, uint32_t quantum = 1024);</span>
<a href="#l16.21"></a><span id="l16.21">   nsresult  AppendString(const char *string);</span>
<a href="#l16.22"></a><span id="l16.22" class="difflineat">@@ -35,61 +35,61 @@ class NS_MSG_BASE nsMsgLineBufferHandler</span>
<a href="#l16.23"></a><span id="l16.23"> public:</span>
<a href="#l16.24"></a><span id="l16.24">   virtual nsresult HandleLine(const char *line, uint32_t line_length) = 0;</span>
<a href="#l16.25"></a><span id="l16.25"> };</span>
<a href="#l16.26"></a><span id="l16.26"> </span>
<a href="#l16.27"></a><span id="l16.27"> class NS_MSG_BASE nsMsgLineBuffer : public nsMsgLineBufferHandler</span>
<a href="#l16.28"></a><span id="l16.28"> {</span>
<a href="#l16.29"></a><span id="l16.29"> public:</span>
<a href="#l16.30"></a><span id="l16.30">   nsMsgLineBuffer(nsMsgLineBufferHandler *handler, bool convertNewlinesP);</span>
<a href="#l16.31"></a><span id="l16.31" class="difflineminus">-  </span>
<a href="#l16.32"></a><span id="l16.32" class="difflineplus">+</span>
<a href="#l16.33"></a><span id="l16.33">   virtual    ~nsMsgLineBuffer();</span>
<a href="#l16.34"></a><span id="l16.34">   nsresult    BufferInput(const char *net_buffer, int32_t net_buffer_size);</span>
<a href="#l16.35"></a><span id="l16.35">   // Not sure why anyone cares, by NNTPHost seems to want to know the buf pos.</span>
<a href="#l16.36"></a><span id="l16.36">   uint32_t    GetBufferPos() {return m_bufferPos;}</span>
<a href="#l16.37"></a><span id="l16.37" class="difflineminus">-  </span>
<a href="#l16.38"></a><span id="l16.38" class="difflineplus">+</span>
<a href="#l16.39"></a><span id="l16.39">   virtual nsresult HandleLine(const char *line, uint32_t line_length);</span>
<a href="#l16.40"></a><span id="l16.40">   // flush last line, though it won't be CRLF terminated.</span>
<a href="#l16.41"></a><span id="l16.41">   virtual nsresult FlushLastLine();</span>
<a href="#l16.42"></a><span id="l16.42"> protected:</span>
<a href="#l16.43"></a><span id="l16.43">   nsMsgLineBuffer(bool convertNewlinesP);</span>
<a href="#l16.44"></a><span id="l16.44" class="difflineminus">-  </span>
<a href="#l16.45"></a><span id="l16.45" class="difflineplus">+</span>
<a href="#l16.46"></a><span id="l16.46">   nsresult ConvertAndSendBuffer();</span>
<a href="#l16.47"></a><span id="l16.47">   void SetLookingForCRLF(bool b);</span>
<a href="#l16.48"></a><span id="l16.48" class="difflineminus">-  </span>
<a href="#l16.49"></a><span id="l16.49" class="difflineplus">+</span>
<a href="#l16.50"></a><span id="l16.50">   nsMsgLineBufferHandler *m_handler;</span>
<a href="#l16.51"></a><span id="l16.51">   bool        m_convertNewlinesP;</span>
<a href="#l16.52"></a><span id="l16.52" class="difflineminus">-  bool        m_lookingForCRLF; </span>
<a href="#l16.53"></a><span id="l16.53" class="difflineplus">+  bool        m_lookingForCRLF;</span>
<a href="#l16.54"></a><span id="l16.54"> };</span>
<a href="#l16.55"></a><span id="l16.55"> </span>
<a href="#l16.56"></a><span id="l16.56"> // I'm adding this utility class here for lack of a better place. This utility class is similar to nsMsgLineBuffer</span>
<a href="#l16.57"></a><span id="l16.57"> // except it works from an input stream. It is geared towards efficiently parsing new lines out of a stream by storing</span>
<a href="#l16.58"></a><span id="l16.58"> // read but unprocessed bytes in a buffer. I envision the primary use of this to be our mail protocols such as imap, news and</span>
<a href="#l16.59"></a><span id="l16.59"> // pop which need to process line by line data being returned in the form of a proxied stream from the server.</span>
<a href="#l16.60"></a><span id="l16.60"> </span>
<a href="#l16.61"></a><span id="l16.61"> class nsIInputStream;</span>
<a href="#l16.62"></a><span id="l16.62"> </span>
<a href="#l16.63"></a><span id="l16.63"> class NS_MSG_BASE nsMsgLineStreamBuffer</span>
<a href="#l16.64"></a><span id="l16.64"> {</span>
<a href="#l16.65"></a><span id="l16.65"> public:</span>
<a href="#l16.66"></a><span id="l16.66">   // aBufferSize -- size of the buffer you want us to use for buffering stream data</span>
<a href="#l16.67"></a><span id="l16.67" class="difflineminus">-  // aEndOfLinetoken -- The delimiter string to be used for determining the end of line. This </span>
<a href="#l16.68"></a><span id="l16.68" class="difflineplus">+  // aEndOfLinetoken -- The delimiter string to be used for determining the end of line. This</span>
<a href="#l16.69"></a><span id="l16.69">   //              allows us to parse platform specific end of line endings by making it</span>
<a href="#l16.70"></a><span id="l16.70">   //            a parameter.</span>
<a href="#l16.71"></a><span id="l16.71" class="difflineminus">-  // aAllocateNewLines -- true if you want calls to ReadNextLine to allocate new memory for the line. </span>
<a href="#l16.72"></a><span id="l16.72" class="difflineplus">+  // aAllocateNewLines -- true if you want calls to ReadNextLine to allocate new memory for the line.</span>
<a href="#l16.73"></a><span id="l16.73">   //            if false, the char * returned is just a ptr into the buffer. Subsequent calls to</span>
<a href="#l16.74"></a><span id="l16.74">   //            ReadNextLine will alter the data so your ptr only has a life time of a per call.</span>
<a href="#l16.75"></a><span id="l16.75" class="difflineminus">-  // aEatCRLFs  -- true if you don't want to see the CRLFs on the lines returned by ReadNextLine. </span>
<a href="#l16.76"></a><span id="l16.76" class="difflineplus">+  // aEatCRLFs  -- true if you don't want to see the CRLFs on the lines returned by ReadNextLine.</span>
<a href="#l16.77"></a><span id="l16.77">   //         false if you do want to see them.</span>
<a href="#l16.78"></a><span id="l16.78">   // aLineToken -- Specify the line token to look for, by default is LF ('\n') which cover as well CRLF. If</span>
<a href="#l16.79"></a><span id="l16.79">   //            lines are terminated with a CR only, you need to set aLineToken to CR ('\r')</span>
<a href="#l16.80"></a><span id="l16.80" class="difflineminus">-  nsMsgLineStreamBuffer(uint32_t aBufferSize, bool aAllocateNewLines, </span>
<a href="#l16.81"></a><span id="l16.81" class="difflineplus">+  nsMsgLineStreamBuffer(uint32_t aBufferSize, bool aAllocateNewLines,</span>
<a href="#l16.82"></a><span id="l16.82">                         bool aEatCRLFs = true, char aLineToken = '\n'); // specify the size of the buffer you want the class to use....</span>
<a href="#l16.83"></a><span id="l16.83">   virtual ~nsMsgLineStreamBuffer();</span>
<a href="#l16.84"></a><span id="l16.84" class="difflineminus">-  </span>
<a href="#l16.85"></a><span id="l16.85" class="difflineplus">+</span>
<a href="#l16.86"></a><span id="l16.86">   // Caller must free the line returned using PR_Free</span>
<a href="#l16.87"></a><span id="l16.87">   // aEndOfLinetoken -- delimiter used to denote the end of a line.</span>
<a href="#l16.88"></a><span id="l16.88">   // aNumBytesInLine -- The number of bytes in the line returned</span>
<a href="#l16.89"></a><span id="l16.89">   // aPauseForMoreData -- There is not enough data in the stream to make a line at this time...</span>
<a href="#l16.90"></a><span id="l16.90">   char * ReadNextLine(nsIInputStream * aInputStream, uint32_t &amp;anumBytesInLine, bool &amp;aPauseForMoreData, nsresult *rv = nullptr, bool addLineTerminator = false);</span>
<a href="#l16.91"></a><span id="l16.91">   nsresult GrowBuffer(int32_t desiredSize);</span>
<a href="#l16.92"></a><span id="l16.92">   void ClearBuffer();</span>
<a href="#l16.93"></a><span id="l16.93">   bool NextLineAvailable();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/base/util/nsMsgProtocol.h</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgProtocol.h</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -46,23 +46,23 @@ class NS_MSG_BASE nsMsgProtocol : public</span>
<a href="#l17.4"></a><span id="l17.4"> {</span>
<a href="#l17.5"></a><span id="l17.5"> public:</span>
<a href="#l17.6"></a><span id="l17.6">   nsMsgProtocol(nsIURI * aURL);</span>
<a href="#l17.7"></a><span id="l17.7"> </span>
<a href="#l17.8"></a><span id="l17.8">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l17.9"></a><span id="l17.9">   // nsIChannel support</span>
<a href="#l17.10"></a><span id="l17.10">   NS_DECL_NSICHANNEL</span>
<a href="#l17.11"></a><span id="l17.11">   NS_DECL_NSIREQUEST</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-  </span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+</span>
<a href="#l17.14"></a><span id="l17.14">   NS_DECL_NSISTREAMLISTENER</span>
<a href="#l17.15"></a><span id="l17.15">   NS_DECL_NSIREQUESTOBSERVER</span>
<a href="#l17.16"></a><span id="l17.16">   NS_DECL_NSITRANSPORTEVENTSINK</span>
<a href="#l17.17"></a><span id="l17.17"> </span>
<a href="#l17.18"></a><span id="l17.18">   // LoadUrl -- A protocol typically overrides this function, sets up any local state for the url and</span>
<a href="#l17.19"></a><span id="l17.19" class="difflineminus">-  // then calls the base class which opens the socket if it needs opened. If the socket is </span>
<a href="#l17.20"></a><span id="l17.20" class="difflineplus">+  // then calls the base class which opens the socket if it needs opened. If the socket is</span>
<a href="#l17.21"></a><span id="l17.21">   // already opened then we just call ProcessProtocolState to start the churning process.</span>
<a href="#l17.22"></a><span id="l17.22">   // aConsumer is the consumer for the url. It can be null if this argument is not appropriate</span>
<a href="#l17.23"></a><span id="l17.23">   virtual nsresult LoadUrl(nsIURI * aURL, nsISupports * aConsumer = nullptr);</span>
<a href="#l17.24"></a><span id="l17.24"> </span>
<a href="#l17.25"></a><span id="l17.25">   virtual nsresult SetUrl(nsIURI * aURL); // sometimes we want to set the url before we load it</span>
<a href="#l17.26"></a><span id="l17.26"> </span>
<a href="#l17.27"></a><span id="l17.27">   // Flag manipulators</span>
<a href="#l17.28"></a><span id="l17.28">   virtual bool TestFlag  (uint32_t flag) {return flag &amp; m_flags;}</span>
<a href="#l17.29"></a><span id="l17.29" class="difflineat">@@ -89,48 +89,48 @@ protected:</span>
<a href="#l17.30"></a><span id="l17.30"> </span>
<a href="#l17.31"></a><span id="l17.31">   nsresult GetTopmostMsgWindow(nsIMsgWindow **aWindow);</span>
<a href="#l17.32"></a><span id="l17.32"> </span>
<a href="#l17.33"></a><span id="l17.33">   virtual const char* GetType() {return nullptr;}</span>
<a href="#l17.34"></a><span id="l17.34">   nsresult GetQoSBits(uint8_t *aQoSBits);</span>
<a href="#l17.35"></a><span id="l17.35"> </span>
<a href="#l17.36"></a><span id="l17.36">   // a Protocol typically overrides this method. They free any of their own connection state and then</span>
<a href="#l17.37"></a><span id="l17.37">   // they call up into the base class to free the generic connection objects</span>
<a href="#l17.38"></a><span id="l17.38" class="difflineminus">-  virtual nsresult CloseSocket(); </span>
<a href="#l17.39"></a><span id="l17.39" class="difflineplus">+  virtual nsresult CloseSocket();</span>
<a href="#l17.40"></a><span id="l17.40"> </span>
<a href="#l17.41"></a><span id="l17.41">   virtual nsresult SetupTransportState(); // private method used by OpenNetworkSocket and OpenFileSocket</span>
<a href="#l17.42"></a><span id="l17.42"> </span>
<a href="#l17.43"></a><span id="l17.43" class="difflineminus">-  // ProcessProtocolState - This is the function that gets churned by calls to OnDataAvailable. </span>
<a href="#l17.44"></a><span id="l17.44" class="difflineplus">+  // ProcessProtocolState - This is the function that gets churned by calls to OnDataAvailable.</span>
<a href="#l17.45"></a><span id="l17.45">   // As data arrives on the socket, OnDataAvailable calls ProcessProtocolState.</span>
<a href="#l17.46"></a><span id="l17.46" class="difflineminus">-  </span>
<a href="#l17.47"></a><span id="l17.47" class="difflineminus">-  virtual nsresult ProcessProtocolState(nsIURI * url, nsIInputStream * inputStream, </span>
<a href="#l17.48"></a><span id="l17.48" class="difflineplus">+</span>
<a href="#l17.49"></a><span id="l17.49" class="difflineplus">+  virtual nsresult ProcessProtocolState(nsIURI * url, nsIInputStream * inputStream,</span>
<a href="#l17.50"></a><span id="l17.50">                                         uint64_t sourceOffset, uint32_t length) = 0;</span>
<a href="#l17.51"></a><span id="l17.51"> </span>
<a href="#l17.52"></a><span id="l17.52" class="difflineminus">-  // SendData -- Writes the data contained in dataBuffer into the current output stream. </span>
<a href="#l17.53"></a><span id="l17.53" class="difflineplus">+  // SendData -- Writes the data contained in dataBuffer into the current output stream.</span>
<a href="#l17.54"></a><span id="l17.54">   // It also informs the transport layer that this data is now available for transmission.</span>
<a href="#l17.55"></a><span id="l17.55">   // Returns a positive number for success, 0 for failure (not all the bytes were written to the</span>
<a href="#l17.56"></a><span id="l17.56" class="difflineminus">-  // stream, etc). </span>
<a href="#l17.57"></a><span id="l17.57" class="difflineplus">+  // stream, etc).</span>
<a href="#l17.58"></a><span id="l17.58">     // aSuppressLogging is a hint that sensitive data is being sent and should not be logged</span>
<a href="#l17.59"></a><span id="l17.59">   virtual nsresult SendData(const char * dataBuffer, bool aSuppressLogging = false);</span>
<a href="#l17.60"></a><span id="l17.60"> </span>
<a href="#l17.61"></a><span id="l17.61">   virtual nsresult PostMessage(nsIURI* url, nsIFile* aPostFile);</span>
<a href="#l17.62"></a><span id="l17.62"> </span>
<a href="#l17.63"></a><span id="l17.63">   virtual nsresult InitFromURI(nsIURI *aUrl);</span>
<a href="#l17.64"></a><span id="l17.64"> </span>
<a href="#l17.65"></a><span id="l17.65">   nsresult DoNtlmStep1(const char *username, const char *password, nsCString &amp;response);</span>
<a href="#l17.66"></a><span id="l17.66">   nsresult DoNtlmStep2(nsCString &amp;commandResponse, nsCString &amp;response);</span>
<a href="#l17.67"></a><span id="l17.67"> </span>
<a href="#l17.68"></a><span id="l17.68">   nsresult DoGSSAPIStep1(const char *service, const char *username, nsCString &amp;response);</span>
<a href="#l17.69"></a><span id="l17.69">   nsresult DoGSSAPIStep2(nsCString &amp;commandResponse, nsCString &amp;response);</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineminus">-  // Ouput stream for writing commands to the socket  </span>
<a href="#l17.71"></a><span id="l17.71" class="difflineplus">+  // Ouput stream for writing commands to the socket</span>
<a href="#l17.72"></a><span id="l17.72">   nsCOMPtr&lt;nsIOutputStream&gt;   m_outputStream;   // this will be obtained from the transport interface</span>
<a href="#l17.73"></a><span id="l17.73">   nsCOMPtr&lt;nsIInputStream&gt;    m_inputStream;</span>
<a href="#l17.74"></a><span id="l17.74"> </span>
<a href="#l17.75"></a><span id="l17.75">   // Ouput stream for writing commands to the socket</span>
<a href="#l17.76"></a><span id="l17.76" class="difflineminus">-  nsCOMPtr&lt;nsITransport&gt;  m_transport; </span>
<a href="#l17.77"></a><span id="l17.77" class="difflineplus">+  nsCOMPtr&lt;nsITransport&gt;  m_transport;</span>
<a href="#l17.78"></a><span id="l17.78">   nsCOMPtr&lt;nsIRequest&gt;    m_request;</span>
<a href="#l17.79"></a><span id="l17.79">   nsCOMPtr&lt;nsICancelable&gt; m_proxyRequest;</span>
<a href="#l17.80"></a><span id="l17.80"> </span>
<a href="#l17.81"></a><span id="l17.81">   bool          m_socketIsOpen; // mscott: we should look into keeping this state in the nsSocketTransport...</span>
<a href="#l17.82"></a><span id="l17.82">                                   // I'm using it to make sure I open the socket the first time a URL is loaded into the connection</span>
<a href="#l17.83"></a><span id="l17.83">   uint32_t      m_flags; // used to store flag information</span>
<a href="#l17.84"></a><span id="l17.84">   //uint32_t  m_startPosition;</span>
<a href="#l17.85"></a><span id="l17.85">   int32_t       m_readCount;</span>
<a href="#l17.86"></a><span id="l17.86" class="difflineat">@@ -154,17 +154,17 @@ protected:</span>
<a href="#l17.87"></a><span id="l17.87">   nsCString                   mContentType;</span>
<a href="#l17.88"></a><span id="l17.88">   nsCString                   mCharset;</span>
<a href="#l17.89"></a><span id="l17.89">   int64_t                     mContentLength;</span>
<a href="#l17.90"></a><span id="l17.90">   nsCOMPtr&lt;nsILoadInfo&gt;       m_loadInfo;</span>
<a href="#l17.91"></a><span id="l17.91"> </span>
<a href="#l17.92"></a><span id="l17.92">   nsCString m_lastPasswordSent; // used to prefill the password prompt</span>
<a href="#l17.93"></a><span id="l17.93"> </span>
<a href="#l17.94"></a><span id="l17.94">   // private helper routine used by subclasses to quickly get a reference to the correct prompt dialog</span>
<a href="#l17.95"></a><span id="l17.95" class="difflineminus">-  // for a mailnews url. </span>
<a href="#l17.96"></a><span id="l17.96" class="difflineplus">+  // for a mailnews url.</span>
<a href="#l17.97"></a><span id="l17.97">   nsresult GetPromptDialogFromUrl(nsIMsgMailNewsUrl * aMsgUrl, nsIPrompt ** aPromptDialog);</span>
<a href="#l17.98"></a><span id="l17.98"> </span>
<a href="#l17.99"></a><span id="l17.99">   // if a url isn't going to result in any content then we want to suppress calls to</span>
<a href="#l17.100"></a><span id="l17.100">   // OnStartRequest, OnDataAvailable and OnStopRequest</span>
<a href="#l17.101"></a><span id="l17.101">   bool mSuppressListenerNotifications;</span>
<a href="#l17.102"></a><span id="l17.102"> };</span>
<a href="#l17.103"></a><span id="l17.103"> </span>
<a href="#l17.104"></a><span id="l17.104"> </span>
<a href="#l17.105"></a><span id="l17.105" class="difflineat">@@ -175,67 +175,67 @@ class NS_MSG_BASE nsMsgAsyncWriteProtoco</span>
<a href="#l17.106"></a><span id="l17.106">                                           , public nsSupportsWeakReference</span>
<a href="#l17.107"></a><span id="l17.107"> {</span>
<a href="#l17.108"></a><span id="l17.108"> public:</span>
<a href="#l17.109"></a><span id="l17.109">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l17.110"></a><span id="l17.110"> </span>
<a href="#l17.111"></a><span id="l17.111">   NS_IMETHOD Cancel(nsresult status) override;</span>
<a href="#l17.112"></a><span id="l17.112"> </span>
<a href="#l17.113"></a><span id="l17.113">   nsMsgAsyncWriteProtocol(nsIURI * aURL);</span>
<a href="#l17.114"></a><span id="l17.114" class="difflineminus">-  </span>
<a href="#l17.115"></a><span id="l17.115" class="difflineplus">+</span>
<a href="#l17.116"></a><span id="l17.116">   // temporary over ride...</span>
<a href="#l17.117"></a><span id="l17.117">   virtual nsresult PostMessage(nsIURI* url, nsIFile *postFile) override;</span>
<a href="#l17.118"></a><span id="l17.118" class="difflineminus">-  </span>
<a href="#l17.119"></a><span id="l17.119" class="difflineplus">+</span>
<a href="#l17.120"></a><span id="l17.120">   // over ride the following methods from the base class</span>
<a href="#l17.121"></a><span id="l17.121">   virtual nsresult SetupTransportState() override;</span>
<a href="#l17.122"></a><span id="l17.122">   virtual nsresult SendData(const char * dataBuffer, bool aSuppressLogging = false) override;</span>
<a href="#l17.123"></a><span id="l17.123">   nsCString mAsyncBuffer;</span>
<a href="#l17.124"></a><span id="l17.124"> </span>
<a href="#l17.125"></a><span id="l17.125">   // if we suspended the asynch write while waiting for more data to write then this will be TRUE</span>
<a href="#l17.126"></a><span id="l17.126">   bool mSuspendedWrite;</span>
<a href="#l17.127"></a><span id="l17.127">   nsCOMPtr&lt;nsIRequest&gt;     m_WriteRequest;</span>
<a href="#l17.128"></a><span id="l17.128">   nsCOMPtr&lt;nsIAsyncOutputStream&gt;    mAsyncOutStream;</span>
<a href="#l17.129"></a><span id="l17.129">   nsCOMPtr&lt;nsIOutputStreamCallback&gt; mProvider;</span>
<a href="#l17.130"></a><span id="l17.130">   nsCOMPtr&lt;nsIThread&gt;               mProviderThread;</span>
<a href="#l17.131"></a><span id="l17.131"> </span>
<a href="#l17.132"></a><span id="l17.132" class="difflineminus">-  // because we are reading the post data in asychronously, it's possible that we aren't sending it </span>
<a href="#l17.133"></a><span id="l17.133" class="difflineminus">-  // out fast enough and the reading gets blocked. The following set of state variables are used to </span>
<a href="#l17.134"></a><span id="l17.134" class="difflineplus">+  // because we are reading the post data in asychronously, it's possible that we aren't sending it</span>
<a href="#l17.135"></a><span id="l17.135" class="difflineplus">+  // out fast enough and the reading gets blocked. The following set of state variables are used to</span>
<a href="#l17.136"></a><span id="l17.136">   // track this.</span>
<a href="#l17.137"></a><span id="l17.137">   bool    mSuspendedRead;</span>
<a href="#l17.138"></a><span id="l17.138">   bool    mInsertPeriodRequired; // do we need to insert a '.' as part of the unblocking process</span>
<a href="#l17.139"></a><span id="l17.139" class="difflineminus">-   </span>
<a href="#l17.140"></a><span id="l17.140" class="difflineplus">+</span>
<a href="#l17.141"></a><span id="l17.141">   nsresult ProcessIncomingPostData(nsIInputStream *inStr, uint32_t count);</span>
<a href="#l17.142"></a><span id="l17.142">   nsresult UnblockPostReader();</span>
<a href="#l17.143"></a><span id="l17.143">   nsresult UpdateSuspendedReadBytes(uint32_t aNewBytes, bool aAddToPostPeriodByteCount);</span>
<a href="#l17.144"></a><span id="l17.144">   nsresult PostDataFinished(); // this is so we'll send out a closing '.' and release any state related to the post</span>
<a href="#l17.145"></a><span id="l17.145"> </span>
<a href="#l17.146"></a><span id="l17.146"> </span>
<a href="#l17.147"></a><span id="l17.147">   // these two routines are used to pause and resume our loading of the file containing the contents</span>
<a href="#l17.148"></a><span id="l17.148">   // we are trying to post. We call these routines when we aren't sending the bits out fast enough</span>
<a href="#l17.149"></a><span id="l17.149" class="difflineminus">-  // to keep up with the file read. </span>
<a href="#l17.150"></a><span id="l17.150" class="difflineplus">+  // to keep up with the file read.</span>
<a href="#l17.151"></a><span id="l17.151">   nsresult SuspendPostFileRead();</span>
<a href="#l17.152"></a><span id="l17.152" class="difflineminus">-  nsresult ResumePostFileRead(); </span>
<a href="#l17.153"></a><span id="l17.153" class="difflineminus">-  nsresult UpdateSuspendedReadBytes(uint32_t aNewBytes); </span>
<a href="#l17.154"></a><span id="l17.154" class="difflineplus">+  nsresult ResumePostFileRead();</span>
<a href="#l17.155"></a><span id="l17.155" class="difflineplus">+  nsresult UpdateSuspendedReadBytes(uint32_t aNewBytes);</span>
<a href="#l17.156"></a><span id="l17.156">   void UpdateProgress(uint32_t aNewBytes);</span>
<a href="#l17.157"></a><span id="l17.157">   nsMsgFilePostHelper * mFilePostHelper; // needs to be a weak reference</span>
<a href="#l17.158"></a><span id="l17.158"> protected:</span>
<a href="#l17.159"></a><span id="l17.159">   virtual ~nsMsgAsyncWriteProtocol();</span>
<a href="#l17.160"></a><span id="l17.160"> </span>
<a href="#l17.161"></a><span id="l17.161">   // the streams for the pipe used to queue up data for the async write calls to the server.</span>
<a href="#l17.162"></a><span id="l17.162">   // we actually re-use the same mOutStream variable in our parent class for the output</span>
<a href="#l17.163"></a><span id="l17.163">   // stream to the socket channel. So no need for a new variable here.</span>
<a href="#l17.164"></a><span id="l17.164" class="difflineminus">-  nsCOMPtr&lt;nsIInputStream&gt;  mInStream;    </span>
<a href="#l17.165"></a><span id="l17.165" class="difflineplus">+  nsCOMPtr&lt;nsIInputStream&gt;  mInStream;</span>
<a href="#l17.166"></a><span id="l17.166">   nsCOMPtr&lt;nsIInputStream&gt;  mPostDataStream;</span>
<a href="#l17.167"></a><span id="l17.167" class="difflineminus">-  uint32_t                  mSuspendedReadBytes;   // remaining # of bytes we need to read before   </span>
<a href="#l17.168"></a><span id="l17.168" class="difflineplus">+  uint32_t                  mSuspendedReadBytes;   // remaining # of bytes we need to read before</span>
<a href="#l17.169"></a><span id="l17.169">                                                    // the input stream becomes unblocked</span>
<a href="#l17.170"></a><span id="l17.170" class="difflineminus">-  uint32_t                  mSuspendedReadBytesPostPeriod; // # of bytes which need processed after we insert a '.' before </span>
<a href="#l17.171"></a><span id="l17.171" class="difflineplus">+  uint32_t                  mSuspendedReadBytesPostPeriod; // # of bytes which need processed after we insert a '.' before</span>
<a href="#l17.172"></a><span id="l17.172">                                                            // the input stream becomes unblocked.</span>
<a href="#l17.173"></a><span id="l17.173">   int64_t   mFilePostSize; // used for file size, we post a single message in a file</span>
<a href="#l17.174"></a><span id="l17.174">   uint32_t  mNumBytesPosted; // used for determining progress on posting files</span>
<a href="#l17.175"></a><span id="l17.175">   bool      mGenerateProgressNotifications; // set during a post operation after we've started sending the post data...</span>
<a href="#l17.176"></a><span id="l17.176"> </span>
<a href="#l17.177"></a><span id="l17.177" class="difflineminus">-  virtual nsresult CloseSocket() override; </span>
<a href="#l17.178"></a><span id="l17.178" class="difflineplus">+  virtual nsresult CloseSocket() override;</span>
<a href="#l17.179"></a><span id="l17.179"> };</span>
<a href="#l17.180"></a><span id="l17.180"> </span>
<a href="#l17.181"></a><span id="l17.181"> #undef  IMETHOD_VISIBILITY</span>
<a href="#l17.182"></a><span id="l17.182"> #define IMETHOD_VISIBILITY NS_VISIBILITY_HIDDEN</span>
<a href="#l17.183"></a><span id="l17.183"> </span>
<a href="#l17.184"></a><span id="l17.184"> #endif /* nsMsgProtocol_h__ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/base/util/nsMsgReadStateTxn.cpp</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgReadStateTxn.cpp</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -26,40 +26,40 @@ nsMsgReadStateTxn::Init(nsIMsgFolder *aP</span>
<a href="#l18.4"></a><span id="l18.4">   NS_ENSURE_ARG_POINTER(aParentFolder);</span>
<a href="#l18.5"></a><span id="l18.5"> </span>
<a href="#l18.6"></a><span id="l18.6">   mParentFolder = aParentFolder;</span>
<a href="#l18.7"></a><span id="l18.7">   mMarkedMessages.AppendElements(aMsgKeyArray, aNumKeys);</span>
<a href="#l18.8"></a><span id="l18.8"> </span>
<a href="#l18.9"></a><span id="l18.9">   return nsMsgTxn::Init();</span>
<a href="#l18.10"></a><span id="l18.10"> }</span>
<a href="#l18.11"></a><span id="l18.11"> </span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l18.14"></a><span id="l18.14"> nsMsgReadStateTxn::UndoTransaction()</span>
<a href="#l18.15"></a><span id="l18.15"> {</span>
<a href="#l18.16"></a><span id="l18.16">   return MarkMessages(false);</span>
<a href="#l18.17"></a><span id="l18.17"> }</span>
<a href="#l18.18"></a><span id="l18.18"> </span>
<a href="#l18.19"></a><span id="l18.19" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l18.20"></a><span id="l18.20" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l18.21"></a><span id="l18.21"> nsMsgReadStateTxn::RedoTransaction()</span>
<a href="#l18.22"></a><span id="l18.22"> {</span>
<a href="#l18.23"></a><span id="l18.23">   return MarkMessages(true);</span>
<a href="#l18.24"></a><span id="l18.24"> }</span>
<a href="#l18.25"></a><span id="l18.25"> </span>
<a href="#l18.26"></a><span id="l18.26"> NS_IMETHODIMP</span>
<a href="#l18.27"></a><span id="l18.27"> nsMsgReadStateTxn::MarkMessages(bool aAsRead)</span>
<a href="#l18.28"></a><span id="l18.28"> {</span>
<a href="#l18.29"></a><span id="l18.29">   nsresult rv;</span>
<a href="#l18.30"></a><span id="l18.30" class="difflineminus">-  nsCOMPtr&lt;nsIMutableArray&gt; messageArray = </span>
<a href="#l18.31"></a><span id="l18.31" class="difflineplus">+  nsCOMPtr&lt;nsIMutableArray&gt; messageArray =</span>
<a href="#l18.32"></a><span id="l18.32">     do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l18.33"></a><span id="l18.33">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.34"></a><span id="l18.34"> </span>
<a href="#l18.35"></a><span id="l18.35">   uint32_t length = mMarkedMessages.Length();</span>
<a href="#l18.36"></a><span id="l18.36">   for (uint32_t i = 0; i &lt; length; i++) {</span>
<a href="#l18.37"></a><span id="l18.37">     nsCOMPtr&lt;nsIMsgDBHdr&gt; curMsgHdr;</span>
<a href="#l18.38"></a><span id="l18.38" class="difflineminus">-    rv = mParentFolder-&gt;GetMessageHeader(mMarkedMessages[i], </span>
<a href="#l18.39"></a><span id="l18.39" class="difflineplus">+    rv = mParentFolder-&gt;GetMessageHeader(mMarkedMessages[i],</span>
<a href="#l18.40"></a><span id="l18.40">                                          getter_AddRefs(curMsgHdr));</span>
<a href="#l18.41"></a><span id="l18.41">     if (NS_SUCCEEDED(rv) &amp;&amp; curMsgHdr) {</span>
<a href="#l18.42"></a><span id="l18.42">       messageArray-&gt;AppendElement(curMsgHdr, false);</span>
<a href="#l18.43"></a><span id="l18.43">     }</span>
<a href="#l18.44"></a><span id="l18.44">   }</span>
<a href="#l18.45"></a><span id="l18.45"> </span>
<a href="#l18.46"></a><span id="l18.46">   return mParentFolder-&gt;MarkMessagesRead(messageArray, aAsRead);</span>
<a href="#l18.47"></a><span id="l18.47"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/base/util/nsMsgTxn.cpp</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgTxn.cpp</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -20,17 +20,17 @@ NS_INTERFACE_MAP_BEGIN(nsMsgTxn)</span>
<a href="#l19.4"></a><span id="l19.4">   NS_INTERFACE_MAP_ENTRY(nsIWritablePropertyBag)</span>
<a href="#l19.5"></a><span id="l19.5">   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIPropertyBag, nsIWritablePropertyBag)</span>
<a href="#l19.6"></a><span id="l19.6">   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWritablePropertyBag)</span>
<a href="#l19.7"></a><span id="l19.7">   NS_INTERFACE_MAP_ENTRY(nsITransaction)</span>
<a href="#l19.8"></a><span id="l19.8">   NS_INTERFACE_MAP_ENTRY(nsIPropertyBag2)</span>
<a href="#l19.9"></a><span id="l19.9">   NS_INTERFACE_MAP_ENTRY(nsIWritablePropertyBag2)</span>
<a href="#l19.10"></a><span id="l19.10"> NS_INTERFACE_MAP_END</span>
<a href="#l19.11"></a><span id="l19.11"> </span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-nsMsgTxn::nsMsgTxn() </span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+nsMsgTxn::nsMsgTxn()</span>
<a href="#l19.14"></a><span id="l19.14"> {</span>
<a href="#l19.15"></a><span id="l19.15">   m_txnType = 0;</span>
<a href="#l19.16"></a><span id="l19.16"> }</span>
<a href="#l19.17"></a><span id="l19.17"> </span>
<a href="#l19.18"></a><span id="l19.18"> nsMsgTxn::~nsMsgTxn()</span>
<a href="#l19.19"></a><span id="l19.19"> {</span>
<a href="#l19.20"></a><span id="l19.20"> }</span>
<a href="#l19.21"></a><span id="l19.21"> </span>
<a href="#l19.22"></a><span id="l19.22" class="difflineat">@@ -72,17 +72,17 @@ NS_IMETHODIMP nsMsgTxn::DeleteProperty(c</span>
<a href="#l19.23"></a><span id="l19.23">   return mPropertyHash.Get(name, nullptr) ? NS_ERROR_FAILURE : NS_OK;</span>
<a href="#l19.24"></a><span id="l19.24"> }</span>
<a href="#l19.25"></a><span id="l19.25"> </span>
<a href="#l19.26"></a><span id="l19.26"> //</span>
<a href="#l19.27"></a><span id="l19.27"> // nsMailSimpleProperty class and impl; used for GetEnumerator</span>
<a href="#l19.28"></a><span id="l19.28"> // This is same as nsSimpleProperty but for external API use.</span>
<a href="#l19.29"></a><span id="l19.29"> //</span>
<a href="#l19.30"></a><span id="l19.30"> </span>
<a href="#l19.31"></a><span id="l19.31" class="difflineminus">-class nsMailSimpleProperty final : public nsIProperty </span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+class nsMailSimpleProperty final : public nsIProperty</span>
<a href="#l19.33"></a><span id="l19.33"> {</span>
<a href="#l19.34"></a><span id="l19.34"> public:</span>
<a href="#l19.35"></a><span id="l19.35">   nsMailSimpleProperty(const nsAString&amp; aName, nsIVariant* aValue)</span>
<a href="#l19.36"></a><span id="l19.36">       : mName(aName), mValue(aValue)</span>
<a href="#l19.37"></a><span id="l19.37">   {</span>
<a href="#l19.38"></a><span id="l19.38">   }</span>
<a href="#l19.39"></a><span id="l19.39"> </span>
<a href="#l19.40"></a><span id="l19.40">   NS_DECL_ISUPPORTS</span>
<a href="#l19.41"></a><span id="l19.41" class="difflineat">@@ -141,35 +141,35 @@ nsMsgTxn::SetPropertyAs ## Name (const n</span>
<a href="#l19.42"></a><span id="l19.42"> </span>
<a href="#l19.43"></a><span id="l19.43"> IMPL_GETSETPROPERTY_AS(Int32, int32_t)</span>
<a href="#l19.44"></a><span id="l19.44"> IMPL_GETSETPROPERTY_AS(Uint32, uint32_t)</span>
<a href="#l19.45"></a><span id="l19.45"> IMPL_GETSETPROPERTY_AS(Int64, int64_t)</span>
<a href="#l19.46"></a><span id="l19.46"> IMPL_GETSETPROPERTY_AS(Uint64, uint64_t)</span>
<a href="#l19.47"></a><span id="l19.47"> IMPL_GETSETPROPERTY_AS(Double, double)</span>
<a href="#l19.48"></a><span id="l19.48"> IMPL_GETSETPROPERTY_AS(Bool, bool)</span>
<a href="#l19.49"></a><span id="l19.49"> </span>
<a href="#l19.50"></a><span id="l19.50" class="difflineminus">-NS_IMETHODIMP nsMsgTxn::GetPropertyAsAString(const nsAString &amp; prop, </span>
<a href="#l19.51"></a><span id="l19.51" class="difflineplus">+NS_IMETHODIMP nsMsgTxn::GetPropertyAsAString(const nsAString &amp; prop,</span>
<a href="#l19.52"></a><span id="l19.52">                                              nsAString &amp; _retval)</span>
<a href="#l19.53"></a><span id="l19.53"> {</span>
<a href="#l19.54"></a><span id="l19.54">   nsIVariant* v = mPropertyHash.GetWeak(prop);</span>
<a href="#l19.55"></a><span id="l19.55">   if (!v)</span>
<a href="#l19.56"></a><span id="l19.56">     return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l19.57"></a><span id="l19.57">   return v-&gt;GetAsAString(_retval);</span>
<a href="#l19.58"></a><span id="l19.58"> }</span>
<a href="#l19.59"></a><span id="l19.59"> </span>
<a href="#l19.60"></a><span id="l19.60" class="difflineminus">-NS_IMETHODIMP nsMsgTxn::GetPropertyAsACString(const nsAString &amp; prop, </span>
<a href="#l19.61"></a><span id="l19.61" class="difflineplus">+NS_IMETHODIMP nsMsgTxn::GetPropertyAsACString(const nsAString &amp; prop,</span>
<a href="#l19.62"></a><span id="l19.62">                                               nsACString &amp; _retval)</span>
<a href="#l19.63"></a><span id="l19.63"> {</span>
<a href="#l19.64"></a><span id="l19.64">   nsIVariant* v = mPropertyHash.GetWeak(prop);</span>
<a href="#l19.65"></a><span id="l19.65">   if (!v)</span>
<a href="#l19.66"></a><span id="l19.66">     return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l19.67"></a><span id="l19.67">   return v-&gt;GetAsACString(_retval);</span>
<a href="#l19.68"></a><span id="l19.68"> }</span>
<a href="#l19.69"></a><span id="l19.69"> </span>
<a href="#l19.70"></a><span id="l19.70" class="difflineminus">-NS_IMETHODIMP nsMsgTxn::GetPropertyAsAUTF8String(const nsAString &amp; prop, </span>
<a href="#l19.71"></a><span id="l19.71" class="difflineplus">+NS_IMETHODIMP nsMsgTxn::GetPropertyAsAUTF8String(const nsAString &amp; prop,</span>
<a href="#l19.72"></a><span id="l19.72">                                                  nsACString &amp; _retval)</span>
<a href="#l19.73"></a><span id="l19.73"> {</span>
<a href="#l19.74"></a><span id="l19.74">   nsIVariant* v = mPropertyHash.GetWeak(prop);</span>
<a href="#l19.75"></a><span id="l19.75">   if (!v)</span>
<a href="#l19.76"></a><span id="l19.76">     return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l19.77"></a><span id="l19.77">   return v-&gt;GetAsAUTF8String(_retval);</span>
<a href="#l19.78"></a><span id="l19.78"> }</span>
<a href="#l19.79"></a><span id="l19.79"> </span>
<a href="#l19.80"></a><span id="l19.80" class="difflineat">@@ -187,41 +187,41 @@ NS_IMETHODIMP nsMsgTxn::GetPropertyAsInt</span>
<a href="#l19.81"></a><span id="l19.81">   if (!val) {</span>
<a href="#l19.82"></a><span id="l19.82">     // We have a value, but it's null</span>
<a href="#l19.83"></a><span id="l19.83">     *_retval = nullptr;</span>
<a href="#l19.84"></a><span id="l19.84">     return NS_OK;</span>
<a href="#l19.85"></a><span id="l19.85">   }</span>
<a href="#l19.86"></a><span id="l19.86">   return val-&gt;QueryInterface(aIID, _retval);</span>
<a href="#l19.87"></a><span id="l19.87"> }</span>
<a href="#l19.88"></a><span id="l19.88"> </span>
<a href="#l19.89"></a><span id="l19.89" class="difflineminus">-NS_IMETHODIMP nsMsgTxn::SetPropertyAsAString(const nsAString &amp; prop, </span>
<a href="#l19.90"></a><span id="l19.90" class="difflineplus">+NS_IMETHODIMP nsMsgTxn::SetPropertyAsAString(const nsAString &amp; prop,</span>
<a href="#l19.91"></a><span id="l19.91">                                              const nsAString &amp; value)</span>
<a href="#l19.92"></a><span id="l19.92"> {</span>
<a href="#l19.93"></a><span id="l19.93">   nsCOMPtr&lt;nsIWritableVariant&gt; var = new nsVariant();</span>
<a href="#l19.94"></a><span id="l19.94">   var-&gt;SetAsAString(value);</span>
<a href="#l19.95"></a><span id="l19.95">   return SetProperty(prop, var);</span>
<a href="#l19.96"></a><span id="l19.96"> }</span>
<a href="#l19.97"></a><span id="l19.97"> </span>
<a href="#l19.98"></a><span id="l19.98" class="difflineminus">-NS_IMETHODIMP nsMsgTxn::SetPropertyAsACString(const nsAString &amp; prop, </span>
<a href="#l19.99"></a><span id="l19.99" class="difflineplus">+NS_IMETHODIMP nsMsgTxn::SetPropertyAsACString(const nsAString &amp; prop,</span>
<a href="#l19.100"></a><span id="l19.100">                                               const nsACString &amp; value)</span>
<a href="#l19.101"></a><span id="l19.101"> {</span>
<a href="#l19.102"></a><span id="l19.102">   nsCOMPtr&lt;nsIWritableVariant&gt; var = new nsVariant();</span>
<a href="#l19.103"></a><span id="l19.103">   var-&gt;SetAsACString(value);</span>
<a href="#l19.104"></a><span id="l19.104">   return SetProperty(prop, var);</span>
<a href="#l19.105"></a><span id="l19.105"> }</span>
<a href="#l19.106"></a><span id="l19.106"> </span>
<a href="#l19.107"></a><span id="l19.107" class="difflineminus">-NS_IMETHODIMP nsMsgTxn::SetPropertyAsAUTF8String(const nsAString &amp; prop, </span>
<a href="#l19.108"></a><span id="l19.108" class="difflineplus">+NS_IMETHODIMP nsMsgTxn::SetPropertyAsAUTF8String(const nsAString &amp; prop,</span>
<a href="#l19.109"></a><span id="l19.109">                                                  const nsACString &amp; value)</span>
<a href="#l19.110"></a><span id="l19.110"> {</span>
<a href="#l19.111"></a><span id="l19.111">   nsCOMPtr&lt;nsIWritableVariant&gt; var = new nsVariant();</span>
<a href="#l19.112"></a><span id="l19.112">   var-&gt;SetAsAUTF8String(value);</span>
<a href="#l19.113"></a><span id="l19.113">   return SetProperty(prop, var);</span>
<a href="#l19.114"></a><span id="l19.114"> }</span>
<a href="#l19.115"></a><span id="l19.115"> </span>
<a href="#l19.116"></a><span id="l19.116" class="difflineminus">-NS_IMETHODIMP nsMsgTxn::SetPropertyAsInterface(const nsAString &amp; prop, </span>
<a href="#l19.117"></a><span id="l19.117" class="difflineplus">+NS_IMETHODIMP nsMsgTxn::SetPropertyAsInterface(const nsAString &amp; prop,</span>
<a href="#l19.118"></a><span id="l19.118">                                                nsISupports* value)</span>
<a href="#l19.119"></a><span id="l19.119"> {</span>
<a href="#l19.120"></a><span id="l19.120">   nsCOMPtr&lt;nsIWritableVariant&gt; var = new nsVariant();</span>
<a href="#l19.121"></a><span id="l19.121">   var-&gt;SetAsISupports(value);</span>
<a href="#l19.122"></a><span id="l19.122">   return SetProperty(prop, var);</span>
<a href="#l19.123"></a><span id="l19.123"> }</span>
<a href="#l19.124"></a><span id="l19.124"> </span>
<a href="#l19.125"></a><span id="l19.125"> /////////////////////// Transaction Stuff //////////////////</span>
<a href="#l19.126"></a><span id="l19.126" class="difflineat">@@ -261,19 +261,19 @@ nsresult nsMsgTxn::SetMsgWindow(nsIMsgWi</span>
<a href="#l19.127"></a><span id="l19.127"> </span>
<a href="#l19.128"></a><span id="l19.128"> </span>
<a href="#l19.129"></a><span id="l19.129"> nsresult</span>
<a href="#l19.130"></a><span id="l19.130"> nsMsgTxn::SetTransactionType(uint32_t txnType)</span>
<a href="#l19.131"></a><span id="l19.131"> {</span>
<a href="#l19.132"></a><span id="l19.132">   return SetPropertyAsUint32(NS_LITERAL_STRING(&quot;type&quot;), txnType);</span>
<a href="#l19.133"></a><span id="l19.133"> }</span>
<a href="#l19.134"></a><span id="l19.134"> </span>
<a href="#l19.135"></a><span id="l19.135" class="difflineminus">-/*none of the callers pass null aFolder, </span>
<a href="#l19.136"></a><span id="l19.136" class="difflineplus">+/*none of the callers pass null aFolder,</span>
<a href="#l19.137"></a><span id="l19.137">   we always initialize aResult (before we pass in) for the case where the key is not in the db*/</span>
<a href="#l19.138"></a><span id="l19.138" class="difflineminus">-nsresult </span>
<a href="#l19.139"></a><span id="l19.139" class="difflineplus">+nsresult</span>
<a href="#l19.140"></a><span id="l19.140"> nsMsgTxn::CheckForToggleDelete(nsIMsgFolder *aFolder, const nsMsgKey &amp;aMsgKey, bool *aResult)</span>
<a href="#l19.141"></a><span id="l19.141"> {</span>
<a href="#l19.142"></a><span id="l19.142">   NS_ENSURE_ARG(aResult);</span>
<a href="#l19.143"></a><span id="l19.143">   nsCOMPtr&lt;nsIMsgDBHdr&gt; message;</span>
<a href="#l19.144"></a><span id="l19.144">   nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l19.145"></a><span id="l19.145">   nsresult rv = aFolder-&gt;GetMsgDatabase(getter_AddRefs(db));</span>
<a href="#l19.146"></a><span id="l19.146">   if (db)</span>
<a href="#l19.147"></a><span id="l19.147">   {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/base/util/nsMsgTxn.h</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgTxn.h</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -23,39 +23,39 @@</span>
<a href="#l20.4"></a><span id="l20.4">   { 0xab, 0xe4, 0x00, 0x80, 0x5f, 0x8a, 0xc9, 0x68 } }</span>
<a href="#l20.5"></a><span id="l20.5"> /**</span>
<a href="#l20.6"></a><span id="l20.6">  * base class for all message undo/redo transactions.</span>
<a href="#l20.7"></a><span id="l20.7">  */</span>
<a href="#l20.8"></a><span id="l20.8"> </span>
<a href="#l20.9"></a><span id="l20.9"> #undef  IMETHOD_VISIBILITY</span>
<a href="#l20.10"></a><span id="l20.10"> #define IMETHOD_VISIBILITY NS_VISIBILITY_DEFAULT</span>
<a href="#l20.11"></a><span id="l20.11"> </span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-class NS_MSG_BASE nsMsgTxn : public nsITransaction, </span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+class NS_MSG_BASE nsMsgTxn : public nsITransaction,</span>
<a href="#l20.14"></a><span id="l20.14">                              public nsIWritablePropertyBag,</span>
<a href="#l20.15"></a><span id="l20.15">                              public nsIWritablePropertyBag2</span>
<a href="#l20.16"></a><span id="l20.16"> {</span>
<a href="#l20.17"></a><span id="l20.17"> public:</span>
<a href="#l20.18"></a><span id="l20.18">     nsMsgTxn();</span>
<a href="#l20.19"></a><span id="l20.19"> </span>
<a href="#l20.20"></a><span id="l20.20">     nsresult Init();</span>
<a href="#l20.21"></a><span id="l20.21"> </span>
<a href="#l20.22"></a><span id="l20.22">     NS_IMETHOD DoTransaction(void) override;</span>
<a href="#l20.23"></a><span id="l20.23"> </span>
<a href="#l20.24"></a><span id="l20.24">     NS_IMETHOD UndoTransaction(void) override = 0;</span>
<a href="#l20.25"></a><span id="l20.25"> </span>
<a href="#l20.26"></a><span id="l20.26">     NS_IMETHOD RedoTransaction(void) override = 0;</span>
<a href="#l20.27"></a><span id="l20.27" class="difflineminus">-    </span>
<a href="#l20.28"></a><span id="l20.28" class="difflineplus">+</span>
<a href="#l20.29"></a><span id="l20.29">     NS_IMETHOD GetIsTransient(bool *aIsTransient) override;</span>
<a href="#l20.30"></a><span id="l20.30"> </span>
<a href="#l20.31"></a><span id="l20.31">     NS_IMETHOD Merge(nsITransaction *aTransaction, bool *aDidMerge) override;</span>
<a href="#l20.32"></a><span id="l20.32"> </span>
<a href="#l20.33"></a><span id="l20.33">     nsresult GetMsgWindow(nsIMsgWindow **msgWindow);</span>
<a href="#l20.34"></a><span id="l20.34">     nsresult SetMsgWindow(nsIMsgWindow *msgWindow);</span>
<a href="#l20.35"></a><span id="l20.35">     nsresult SetTransactionType(uint32_t txnType);</span>
<a href="#l20.36"></a><span id="l20.36" class="difflineminus">- </span>
<a href="#l20.37"></a><span id="l20.37" class="difflineplus">+</span>
<a href="#l20.38"></a><span id="l20.38">     NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l20.39"></a><span id="l20.39">     NS_DECL_NSIPROPERTYBAG</span>
<a href="#l20.40"></a><span id="l20.40">     NS_DECL_NSIPROPERTYBAG2</span>
<a href="#l20.41"></a><span id="l20.41">     NS_DECL_NSIWRITABLEPROPERTYBAG</span>
<a href="#l20.42"></a><span id="l20.42">     NS_DECL_NSIWRITABLEPROPERTYBAG2</span>
<a href="#l20.43"></a><span id="l20.43"> </span>
<a href="#l20.44"></a><span id="l20.44"> protected:</span>
<a href="#l20.45"></a><span id="l20.45">     virtual ~nsMsgTxn();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/base/util/nsMsgUtils.h</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgUtils.h</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -72,36 +72,36 @@ NS_MSG_BASE nsresult FormatFileSize(int6</span>
<a href="#l21.4"></a><span id="l21.4"> /**</span>
<a href="#l21.5"></a><span id="l21.5">  * given a folder uri, return the path to folder in the user profile directory.</span>
<a href="#l21.6"></a><span id="l21.6">  *</span>
<a href="#l21.7"></a><span id="l21.7">  * @param aFolderURI uri of folder we want the path to, without the scheme</span>
<a href="#l21.8"></a><span id="l21.8">  * @param[out] aPathString result path string</span>
<a href="#l21.9"></a><span id="l21.9">  * @param aScheme scheme of the uri</span>
<a href="#l21.10"></a><span id="l21.10">  * @param[optional] aIsNewsFolder is this a news folder?</span>
<a href="#l21.11"></a><span id="l21.11">  */</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-NS_MSG_BASE nsresult </span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+NS_MSG_BASE nsresult</span>
<a href="#l21.14"></a><span id="l21.14"> NS_MsgCreatePathStringFromFolderURI(const char *aFolderURI,</span>
<a href="#l21.15"></a><span id="l21.15">                                     nsCString&amp; aPathString,</span>
<a href="#l21.16"></a><span id="l21.16">                                     const nsCString &amp;aScheme,</span>
<a href="#l21.17"></a><span id="l21.17">                                     bool aIsNewsFolder=false);</span>
<a href="#l21.18"></a><span id="l21.18"> </span>
<a href="#l21.19"></a><span id="l21.19"> /**</span>
<a href="#l21.20"></a><span id="l21.20">  * Given a string and a length, removes any &quot;Re:&quot; strings from the front.</span>
<a href="#l21.21"></a><span id="l21.21">  * It also deals with that dumbass &quot;Re[2]:&quot; thing that some losing mailers do.</span>
<a href="#l21.22"></a><span id="l21.22">  *</span>
<a href="#l21.23"></a><span id="l21.23">  * If mailnews.localizedRe is set, it will also remove localized &quot;Re:&quot; strings.</span>
<a href="#l21.24"></a><span id="l21.24">  *</span>
<a href="#l21.25"></a><span id="l21.25">  * @return true if it made a change (in which case the caller should look to</span>
<a href="#l21.26"></a><span id="l21.26">  *         modifiedSubject for the result) and false otherwise (in which</span>
<a href="#l21.27"></a><span id="l21.27" class="difflineminus">- *         case the caller should look at stringp/length for the result) </span>
<a href="#l21.28"></a><span id="l21.28" class="difflineplus">+ *         case the caller should look at stringp/length for the result)</span>
<a href="#l21.29"></a><span id="l21.29">  *</span>
<a href="#l21.30"></a><span id="l21.30">  * @note In the case of a true return value, the string is not altered:</span>
<a href="#l21.31"></a><span id="l21.31">  *       the pointer to its head is merely advanced, and the length</span>
<a href="#l21.32"></a><span id="l21.32">  *       correspondingly decreased.</span>
<a href="#l21.33"></a><span id="l21.33" class="difflineminus">- * </span>
<a href="#l21.34"></a><span id="l21.34" class="difflineplus">+ *</span>
<a href="#l21.35"></a><span id="l21.35">  * @note This API is insane and should be fixed.</span>
<a href="#l21.36"></a><span id="l21.36">  */</span>
<a href="#l21.37"></a><span id="l21.37"> NS_MSG_BASE bool NS_MsgStripRE(const char **stringP, uint32_t *lengthP, char **modifiedSubject=nullptr);</span>
<a href="#l21.38"></a><span id="l21.38"> </span>
<a href="#l21.39"></a><span id="l21.39"> NS_MSG_BASE char * NS_MsgSACopy(char **destination, const char *source);</span>
<a href="#l21.40"></a><span id="l21.40"> </span>
<a href="#l21.41"></a><span id="l21.41"> NS_MSG_BASE char * NS_MsgSACat(char **destination, const char *source);</span>
<a href="#l21.42"></a><span id="l21.42"> </span>
<a href="#l21.43"></a><span id="l21.43" class="difflineat">@@ -215,17 +215,17 @@ NS_MSG_BASE bool MsgIsUTF8(const nsACStr</span>
<a href="#l21.44"></a><span id="l21.44"> </span>
<a href="#l21.45"></a><span id="l21.45"> /*</span>
<a href="#l21.46"></a><span id="l21.46">  * Utility functions that call functions from nsINetUtil</span>
<a href="#l21.47"></a><span id="l21.47">  */</span>
<a href="#l21.48"></a><span id="l21.48"> </span>
<a href="#l21.49"></a><span id="l21.49"> NS_MSG_BASE nsresult MsgEscapeString(const nsACString &amp;aStr,</span>
<a href="#l21.50"></a><span id="l21.50">                                      uint32_t aType, nsACString &amp;aResult);</span>
<a href="#l21.51"></a><span id="l21.51"> </span>
<a href="#l21.52"></a><span id="l21.52" class="difflineminus">-NS_MSG_BASE nsresult MsgUnescapeString(const nsACString &amp;aStr, </span>
<a href="#l21.53"></a><span id="l21.53" class="difflineplus">+NS_MSG_BASE nsresult MsgUnescapeString(const nsACString &amp;aStr,</span>
<a href="#l21.54"></a><span id="l21.54">                                        uint32_t aFlags, nsACString &amp;aResult);</span>
<a href="#l21.55"></a><span id="l21.55"> </span>
<a href="#l21.56"></a><span id="l21.56"> NS_MSG_BASE nsresult MsgEscapeURL(const nsACString &amp;aStr, uint32_t aFlags,</span>
<a href="#l21.57"></a><span id="l21.57">                                   nsACString &amp;aResult);</span>
<a href="#l21.58"></a><span id="l21.58"> </span>
<a href="#l21.59"></a><span id="l21.59"> // Converts an nsTArray of nsMsgKeys plus a database, to an array of nsIMsgDBHdrs.</span>
<a href="#l21.60"></a><span id="l21.60"> NS_MSG_BASE nsresult MsgGetHeadersFromKeys(nsIMsgDatabase *aDB,</span>
<a href="#l21.61"></a><span id="l21.61">                                            const nsTArray&lt;nsMsgKey&gt; &amp;aKeys,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/base/util/nsStopwatch.cpp</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/base/util/nsStopwatch.cpp</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -14,21 +14,21 @@</span>
<a href="#l22.4"></a><span id="l22.4"> #elif defined(XP_WIN)</span>
<a href="#l22.5"></a><span id="l22.5"> #include &quot;windows.h&quot;</span>
<a href="#l22.6"></a><span id="l22.6"> #endif // elif defined(XP_WIN)</span>
<a href="#l22.7"></a><span id="l22.7"> </span>
<a href="#l22.8"></a><span id="l22.8"> #include &quot;nsMemory.h&quot;</span>
<a href="#l22.9"></a><span id="l22.9"> /*</span>
<a href="#l22.10"></a><span id="l22.10">  * This basis for the logic in this file comes from (will used to come from):</span>
<a href="#l22.11"></a><span id="l22.11">  *  (mozilla/)modules/libutil/public/stopwatch.cpp.</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">- *  </span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+ *</span>
<a href="#l22.14"></a><span id="l22.14">  * It was no longer used in the mozilla tree, and is being migrated to</span>
<a href="#l22.15"></a><span id="l22.15">  * comm-central where we actually have a need for it.  (&quot;Being&quot; in the sense</span>
<a href="#l22.16"></a><span id="l22.16">  * that it will not be removed immediately from mozilla-central.)</span>
<a href="#l22.17"></a><span id="l22.17" class="difflineminus">- * </span>
<a href="#l22.18"></a><span id="l22.18" class="difflineplus">+ *</span>
<a href="#l22.19"></a><span id="l22.19">  * Simplification and general clean-up has been performed and the fix for</span>
<a href="#l22.20"></a><span id="l22.20">  * bug 96669 has been integrated.</span>
<a href="#l22.21"></a><span id="l22.21">  */</span>
<a href="#l22.22"></a><span id="l22.22"> </span>
<a href="#l22.23"></a><span id="l22.23"> NS_IMPL_ISUPPORTS(nsStopwatch, nsIStopwatch)</span>
<a href="#l22.24"></a><span id="l22.24"> </span>
<a href="#l22.25"></a><span id="l22.25"> #if defined(XP_UNIX)</span>
<a href="#l22.26"></a><span id="l22.26"> /** the number of ticks per second */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mailnews/base/util/nsStopwatch.h</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mailnews/base/util/nsStopwatch.h</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -30,21 +30,21 @@ private:</span>
<a href="#l23.4"></a><span id="l23.4">   /// Wall-clock start time in seconds since unix epoch.</span>
<a href="#l23.5"></a><span id="l23.5">   double fStartRealTimeSecs;</span>
<a href="#l23.6"></a><span id="l23.6">   /// Wall-clock stop time in seconds since unix epoch.</span>
<a href="#l23.7"></a><span id="l23.7">   double fStopRealTimeSecs;</span>
<a href="#l23.8"></a><span id="l23.8">   /// CPU-clock start time in seconds (of CPU time used since app start)</span>
<a href="#l23.9"></a><span id="l23.9">   double fStartCpuTimeSecs;</span>
<a href="#l23.10"></a><span id="l23.10">   /// CPU-clock stop time in seconds (of CPU time used since app start)</span>
<a href="#l23.11"></a><span id="l23.11">   double fStopCpuTimeSecs;</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-  /// Total wall-clock time elapsed in seconds. </span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+  /// Total wall-clock time elapsed in seconds.</span>
<a href="#l23.14"></a><span id="l23.14">   double fTotalRealTimeSecs;</span>
<a href="#l23.15"></a><span id="l23.15">   /// Total CPU time elapsed in seconds.</span>
<a href="#l23.16"></a><span id="l23.16">   double fTotalCpuTimeSecs;</span>
<a href="#l23.17"></a><span id="l23.17"> </span>
<a href="#l23.18"></a><span id="l23.18">   /// Is the timer running?</span>
<a href="#l23.19"></a><span id="l23.19">   bool fRunning;</span>
<a href="#l23.20"></a><span id="l23.20" class="difflineminus">-  </span>
<a href="#l23.21"></a><span id="l23.21" class="difflineplus">+</span>
<a href="#l23.22"></a><span id="l23.22">   static double GetRealTime();</span>
<a href="#l23.23"></a><span id="l23.23">   static double GetCPUTime();</span>
<a href="#l23.24"></a><span id="l23.24"> };</span>
<a href="#l23.25"></a><span id="l23.25"> </span>
<a href="#l23.26"></a><span id="l23.26"> #endif // _nsStopwatch_h_</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

