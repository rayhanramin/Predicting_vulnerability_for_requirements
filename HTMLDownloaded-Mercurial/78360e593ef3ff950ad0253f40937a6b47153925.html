<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 774:78360e593ef3ff950ad0253f40937a6b47153925</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 78360e593ef3ff950ad0253f40937a6b47153925" />
<meta property="og:url" content="/comm-central/rev/78360e593ef3ff950ad0253f40937a6b47153925" />
<meta property="og:description" content="add threading and grouping to saved searches, r=standard8, sr=neil, 379806" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 78360e593ef3ff950ad0253f40937a6b47153925 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/78360e593ef3ff950ad0253f40937a6b47153925">shortlog</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/78360e593ef3ff950ad0253f40937a6b47153925">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925">files</a> |
changeset |
<a href="/comm-central/raw-rev/78360e593ef3ff950ad0253f40937a6b47153925">raw</a>  | <a href="/comm-central/archive/78360e593ef3ff950ad0253f40937a6b47153925.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
add threading and grouping to saved searches, r=standard8, sr=neil, 379806
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#68;&#97;&#118;&#105;&#100;&#32;&#66;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#32;&#60;&#98;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#64;&#110;&#118;&#101;&#110;&#116;&#117;&#114;&#101;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Thu, 30 Oct 2008 15:40:30 -0700</td></tr>

<tr>
 <td>changeset 774</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/78360e593ef3ff950ad0253f40937a6b47153925">78360e593ef3ff950ad0253f40937a6b47153925</a></td>
</tr>



<tr>
<td>parent 773</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/0a9821e4db57bda91775e57961614f857c545e37">0a9821e4db57bda91775e57961614f857c545e37</a>
</td>
</tr>

<tr>
<td>child 775</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/252720b87e3f8ff9309eee139f8e9e7eb5ccae91">252720b87e3f8ff9309eee139f8e9e7eb5ccae91</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=78360e593ef3ff950ad0253f40937a6b47153925">699</a></td></tr>
<tr><td>push user</td><td>bienvenu@nventure.com</td></tr>
<tr><td>push date</td><td class="date age">Thu, 30 Oct 2008 22:40:35 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@78360e593ef3 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=78360e593ef3ff950ad0253f40937a6b47153925">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=78360e593ef3ff950ad0253f40937a6b47153925&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=78360e593ef3ff950ad0253f40937a6b47153925&newProject=comm-central&newRevision=78360e593ef3ff950ad0253f40937a6b47153925&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=78360e593ef3ff950ad0253f40937a6b47153925&newProject=comm-central&newRevision=78360e593ef3ff950ad0253f40937a6b47153925&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=78360e593ef3ff950ad0253f40937a6b47153925&newProject=comm-central&newRevision=78360e593ef3ff950ad0253f40937a6b47153925&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28standard8%29&revcount=50">standard8</a>, <a href="/comm-central/log?rev=reviewer%28neil%29&revcount=50">neil</a>, <a href="/comm-central/log?rev=reviewer%28379806%29&revcount=50">379806</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=379806">379806</a></td></tr>




</table></div>

<div class="page_body description">add threading and grouping to saved searches, r=standard8, sr=neil, 379806</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/commandglue.js">mail/base/content/commandglue.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/commandglue.js">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/commandglue.js">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/commandglue.js">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/commandglue.js">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/commandglue.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mail3PaneWindowCommands.js">mail/base/content/mail3PaneWindowCommands.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mail3PaneWindowCommands.js">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mail3PaneWindowCommands.js">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mail3PaneWindowCommands.js">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mail3PaneWindowCommands.js">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mail3PaneWindowCommands.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mailWindowOverlay.js">mail/base/content/mailWindowOverlay.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mailWindowOverlay.js">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mailWindowOverlay.js">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mailWindowOverlay.js">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mailWindowOverlay.js">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/mailWindowOverlay.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/searchBar.js">mail/base/content/searchBar.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/searchBar.js">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/searchBar.js">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/searchBar.js">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/searchBar.js">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mail/base/content/searchBar.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mail3PaneWindowCommands.js">mailnews/base/resources/content/mail3PaneWindowCommands.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mail3PaneWindowCommands.js">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mail3PaneWindowCommands.js">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mail3PaneWindowCommands.js">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mail3PaneWindowCommands.js">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mail3PaneWindowCommands.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mailWindowOverlay.js">mailnews/base/resources/content/mailWindowOverlay.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mailWindowOverlay.js">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mailWindowOverlay.js">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mailWindowOverlay.js">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mailWindowOverlay.js">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/mailWindowOverlay.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/threadPane.js">mailnews/base/resources/content/threadPane.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/threadPane.js">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/threadPane.js">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/threadPane.js">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/threadPane.js">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/resources/content/threadPane.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/Makefile.in">mailnews/base/src/Makefile.in</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/Makefile.in">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/Makefile.in">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/Makefile.in">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/Makefile.in">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/Makefile.in">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.cpp">mailnews/base/src/nsMsgDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.cpp">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.cpp">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.cpp">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.cpp">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.h">mailnews/base/src/nsMsgDBView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.h">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.h">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.h">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.h">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgDBView.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.cpp">mailnews/base/src/nsMsgGroupThread.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.cpp">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.cpp">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.cpp">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.cpp">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.h">mailnews/base/src/nsMsgGroupThread.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.h">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.h">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.h">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.h">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupThread.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.cpp">mailnews/base/src/nsMsgGroupView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.cpp">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.cpp">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.cpp">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.cpp">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.h">mailnews/base/src/nsMsgGroupView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.h">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.h">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.h">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.h">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgGroupView.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.cpp">mailnews/base/src/nsMsgQuickSearchDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.cpp">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.cpp">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.cpp">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.cpp">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.h">mailnews/base/src/nsMsgQuickSearchDBView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.h">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.h">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.h">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.h">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgQuickSearchDBView.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.cpp">mailnews/base/src/nsMsgSearchDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.cpp">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.cpp">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.cpp">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.cpp">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.h">mailnews/base/src/nsMsgSearchDBView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.h">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.h">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.h">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.h">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSearchDBView.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.cpp">mailnews/base/src/nsMsgSpecialViews.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.cpp">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.cpp">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.cpp">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.cpp">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.h">mailnews/base/src/nsMsgSpecialViews.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.h">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.h">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.h">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.h">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgSpecialViews.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.cpp">mailnews/base/src/nsMsgThreadedDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.cpp">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.cpp">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.cpp">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.cpp">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.h">mailnews/base/src/nsMsgThreadedDBView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.h">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.h">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.h">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.h">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgThreadedDBView.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.cpp">mailnews/base/src/nsMsgXFViewThread.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.cpp">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.cpp">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.cpp">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.cpp">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.h">mailnews/base/src/nsMsgXFViewThread.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.h">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.h">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.h">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.h">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFViewThread.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.h">mailnews/base/src/nsMsgXFVirtualFolderDBView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.h">file</a> |
<a href="/comm-central/annotate/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.h">annotate</a> |
<a href="/comm-central/diff/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.h">diff</a> |
<a href="/comm-central/comparison/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.h">comparison</a> |
<a href="/comm-central/log/78360e593ef3ff950ad0253f40937a6b47153925/mailnews/base/src/nsMsgXFVirtualFolderDBView.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mail/base/content/commandglue.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mail/base/content/commandglue.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -363,67 +363,81 @@ function RerootFolder(uri, newFolder, vi</span>
<a href="#l1.4"></a><span id="l1.4">   }</span>
<a href="#l1.5"></a><span id="l1.5"> }</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7"> function SwitchView(command)</span>
<a href="#l1.8"></a><span id="l1.8"> {</span>
<a href="#l1.9"></a><span id="l1.9">   // when switching thread views, we might be coming out of quick search</span>
<a href="#l1.10"></a><span id="l1.10">   // or a message view.</span>
<a href="#l1.11"></a><span id="l1.11">   // first set view picker to all</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  ViewChangeByValue(kViewItemAll);</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  if (gCurrentViewValue != kViewItemAll)</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+    ViewChangeByValue(kViewItemAll);</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16">   // clear the QS text, if we need to</span>
<a href="#l1.17"></a><span id="l1.17">   ClearQSIfNecessary();</span>
<a href="#l1.18"></a><span id="l1.18">   </span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+  var oldSortType, oldSortOrder, viewFlags, viewType, db;</span>
<a href="#l1.20"></a><span id="l1.20">   // now switch views</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineminus">-  var oldSortType = gDBView ? gDBView.sortType : nsMsgViewSortType.byThread;</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineminus">-  var oldSortOrder = gDBView ? gDBView.sortOrder : nsMsgViewSortOrder.ascending;</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineminus">-  var viewFlags = gDBView ? gDBView.viewFlags : gCurViewFlags;</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineminus">-</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineminus">-  // close existing view.</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineminus">-  if (gDBView) {</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+  if (gDBView) </span>
<a href="#l1.28"></a><span id="l1.28" class="difflineplus">+  {</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineplus">+    oldSortType = gDBView.sortType;</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+    oldSortOrder = gDBView.sortOrder;</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+    viewFlags = gDBView.viewFlags;</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+    viewType = gDBView.viewType;</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+    db = gDBView.db;</span>
<a href="#l1.34"></a><span id="l1.34">     gDBView.close();</span>
<a href="#l1.35"></a><span id="l1.35">     gDBView = null; </span>
<a href="#l1.36"></a><span id="l1.36">   }</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+  else</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+  {</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+    oldSortType = nsMsgViewSortType.byThread;</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+    oldSortOrder = nsMsgViewSortOrder.ascending;</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+    viewFlags = gCurViewFlags;</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+    viewType = nsMsgViewType.eShowAllThreads;</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+    db = null;</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+  }</span>
<a href="#l1.46"></a><span id="l1.46">   switch(command)</span>
<a href="#l1.47"></a><span id="l1.47">   {</span>
<a href="#l1.48"></a><span id="l1.48">     // &quot;All&quot; threads and &quot;Unread&quot; threads don't change threading state</span>
<a href="#l1.49"></a><span id="l1.49">     case &quot;cmd_viewAllMsgs&quot;:</span>
<a href="#l1.50"></a><span id="l1.50">       viewFlags = viewFlags &amp; ~nsMsgViewFlagsType.kUnreadOnly;</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineminus">-      CreateDBView(msgWindow.openFolder, nsMsgViewType.eShowAllThreads, viewFlags,</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineminus">-            oldSortType, oldSortOrder);</span>
<a href="#l1.53"></a><span id="l1.53">       break;</span>
<a href="#l1.54"></a><span id="l1.54">     case &quot;cmd_viewUnreadMsgs&quot;:</span>
<a href="#l1.55"></a><span id="l1.55">       viewFlags = viewFlags | nsMsgViewFlagsType.kUnreadOnly;</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineminus">-      CreateDBView(msgWindow.openFolder, nsMsgViewType.eShowAllThreads, viewFlags,</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineminus">-            oldSortType, oldSortOrder );</span>
<a href="#l1.58"></a><span id="l1.58">       break;</span>
<a href="#l1.59"></a><span id="l1.59">     // &quot;Threads with Unread&quot; and &quot;Watched Threads with Unread&quot; force threading</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+    case &quot;cmd_viewWatchedThreadsWithUnread&quot;:</span>
<a href="#l1.61"></a><span id="l1.61">     case &quot;cmd_viewThreadsWithUnread&quot;:</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineminus">-      CreateDBView(msgWindow.openFolder, nsMsgViewType.eShowThreadsWithUnread, nsMsgViewFlagsType.kThreadedDisplay,</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineminus">-            oldSortType, oldSortOrder);</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineminus">-      break;</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineminus">-    case &quot;cmd_viewWatchedThreadsWithUnread&quot;:</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineminus">-      CreateDBView(msgWindow.openFolder, nsMsgViewType.eShowWatchedThreadsWithUnread, nsMsgViewFlagsType.kThreadedDisplay,</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineminus">-            oldSortType, oldSortOrder);</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+      viewType = nsMsgViewType.eShowThreadsWithUnread;</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+      viewFlags |= nsMsgViewFlagsType.kThreadedDisplay;</span>
<a href="#l1.70"></a><span id="l1.70">       break;</span>
<a href="#l1.71"></a><span id="l1.71">     // &quot;Ignored Threads&quot; toggles 'ignored' inclusion --</span>
<a href="#l1.72"></a><span id="l1.72">     //   but it also resets 'With Unread' views to 'All'</span>
<a href="#l1.73"></a><span id="l1.73">     case &quot;cmd_viewIgnoredThreads&quot;:</span>
<a href="#l1.74"></a><span id="l1.74">       if (viewFlags &amp; nsMsgViewFlagsType.kShowIgnored)</span>
<a href="#l1.75"></a><span id="l1.75">         viewFlags = viewFlags &amp; ~nsMsgViewFlagsType.kShowIgnored;</span>
<a href="#l1.76"></a><span id="l1.76">       else</span>
<a href="#l1.77"></a><span id="l1.77">         viewFlags = viewFlags | nsMsgViewFlagsType.kShowIgnored;</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineminus">-      CreateDBView(msgWindow.openFolder, nsMsgViewType.eShowAllThreads, viewFlags,</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineminus">-            oldSortType, oldSortOrder);</span>
<a href="#l1.80"></a><span id="l1.80">       break;</span>
<a href="#l1.81"></a><span id="l1.81">   }</span>
<a href="#l1.82"></a><span id="l1.82"> </span>
<a href="#l1.83"></a><span id="l1.83" class="difflineplus">+  if (db &amp;&amp; viewType == nsMsgViewType.eShowVirtualFolderResults)</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineplus">+  {</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineplus">+      db.dBFolderInfo.viewFlags = viewFlags;</span>
<a href="#l1.86"></a><span id="l1.86" class="difflineplus">+      gMsgFolderSelected = null;</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineplus">+      msgWindow.openFolder = null;</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineplus">+      FolderPaneSelectionChange();</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineplus">+      LoadCurrentlyDisplayedMessage();</span>
<a href="#l1.90"></a><span id="l1.90" class="difflineplus">+  }</span>
<a href="#l1.91"></a><span id="l1.91" class="difflineplus">+  else</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineplus">+  {</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineplus">+    CreateDBView(msgWindow.openFolder, viewType, viewFlags, oldSortType,</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineplus">+                 oldSortOrder);</span>
<a href="#l1.95"></a><span id="l1.95">   RerootThreadPane();</span>
<a href="#l1.96"></a><span id="l1.96" class="difflineplus">+  }</span>
<a href="#l1.97"></a><span id="l1.97"> }</span>
<a href="#l1.98"></a><span id="l1.98"> </span>
<a href="#l1.99"></a><span id="l1.99"> function SetSentFolderColumns(isSentFolder)</span>
<a href="#l1.100"></a><span id="l1.100"> {</span>
<a href="#l1.101"></a><span id="l1.101">   var tree = GetThreadTree();</span>
<a href="#l1.102"></a><span id="l1.102"> </span>
<a href="#l1.103"></a><span id="l1.103">   var lastFolderSent = tree.getAttribute(&quot;lastfoldersent&quot;) == &quot;true&quot;;</span>
<a href="#l1.104"></a><span id="l1.104">   if (isSentFolder != lastFolderSent)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mail/base/content/mail3PaneWindowCommands.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mail/base/content/mail3PaneWindowCommands.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -397,28 +397,28 @@ var DefaultController =</span>
<a href="#l2.4"></a><span id="l2.4">       case &quot;cmd_selectAll&quot;:</span>
<a href="#l2.5"></a><span id="l2.5">       case &quot;cmd_selectFlagged&quot;:</span>
<a href="#l2.6"></a><span id="l2.6">         return gDBView != null;</span>
<a href="#l2.7"></a><span id="l2.7">       // these are enabled on when we are in threaded mode</span>
<a href="#l2.8"></a><span id="l2.8">       case &quot;cmd_selectThread&quot;:</span>
<a href="#l2.9"></a><span id="l2.9">         if (GetNumSelectedMessages() &lt;= 0) return false;</span>
<a href="#l2.10"></a><span id="l2.10">       case &quot;cmd_expandAllThreads&quot;:</span>
<a href="#l2.11"></a><span id="l2.11">       case &quot;cmd_collapseAllThreads&quot;:</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-        if (!gDBView || !gDBView.supportsThreading)</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-          return false;</span>
<a href="#l2.14"></a><span id="l2.14">         return (gDBView.viewFlags &amp; nsMsgViewFlagsType.kThreadedDisplay);</span>
<a href="#l2.15"></a><span id="l2.15">       case &quot;cmd_nextFlaggedMsg&quot;:</span>
<a href="#l2.16"></a><span id="l2.16">       case &quot;cmd_previousFlaggedMsg&quot;:</span>
<a href="#l2.17"></a><span id="l2.17">         return IsViewNavigationItemEnabled();</span>
<a href="#l2.18"></a><span id="l2.18">       case &quot;cmd_viewAllMsgs&quot;:</span>
<a href="#l2.19"></a><span id="l2.19">       case &quot;cmd_viewUnreadMsgs&quot;:</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+      case &quot;cmd_viewIgnoredThreads&quot;:</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+        return gDBView;</span>
<a href="#l2.22"></a><span id="l2.22">       case &quot;cmd_viewThreadsWithUnread&quot;:</span>
<a href="#l2.23"></a><span id="l2.23">       case &quot;cmd_viewWatchedThreadsWithUnread&quot;:</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineminus">-      case &quot;cmd_viewIgnoredThreads&quot;:</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineminus">-        return gDBView;</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+        return gDBView &amp;&amp; !(GetSelectedMsgFolders()[0].flags &amp; </span>
<a href="#l2.27"></a><span id="l2.27" class="difflineplus">+                            MSG_FOLDER_FLAG_VIRTUAL);</span>
<a href="#l2.28"></a><span id="l2.28">       case &quot;cmd_stop&quot;:</span>
<a href="#l2.29"></a><span id="l2.29">         return true;</span>
<a href="#l2.30"></a><span id="l2.30">       case &quot;cmd_undo&quot;:</span>
<a href="#l2.31"></a><span id="l2.31">       case &quot;cmd_redo&quot;:</span>
<a href="#l2.32"></a><span id="l2.32">           return SetupUndoRedoCommand(command);</span>
<a href="#l2.33"></a><span id="l2.33">       case &quot;cmd_renameFolder&quot;:</span>
<a href="#l2.34"></a><span id="l2.34">         return IsRenameFolderEnabled();</span>
<a href="#l2.35"></a><span id="l2.35">       case &quot;cmd_sendUnsentMsgs&quot;:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mail/base/content/mailWindowOverlay.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mail/base/content/mailWindowOverlay.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -249,22 +249,19 @@ function InitViewSortByMenu()</span>
<a href="#l3.4"></a><span id="l3.4">   var grouped = ((gDBView.viewFlags &amp; nsMsgViewFlagsType.kGroupBySort) != 0);</span>
<a href="#l3.5"></a><span id="l3.5">   var threaded = ((gDBView.viewFlags &amp; nsMsgViewFlagsType.kThreadedDisplay) != 0 &amp;&amp; !grouped);</span>
<a href="#l3.6"></a><span id="l3.6">   var sortThreadedMenuItem = document.getElementById(&quot;sortThreaded&quot;);</span>
<a href="#l3.7"></a><span id="l3.7">   var sortUnthreadedMenuItem = document.getElementById(&quot;sortUnthreaded&quot;);</span>
<a href="#l3.8"></a><span id="l3.8"> </span>
<a href="#l3.9"></a><span id="l3.9">   sortThreadedMenuItem.setAttribute(&quot;checked&quot;, threaded);</span>
<a href="#l3.10"></a><span id="l3.10">   sortUnthreadedMenuItem.setAttribute(&quot;checked&quot;, !threaded &amp;&amp; !grouped);</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-  sortThreadedMenuItem.setAttribute(&quot;disabled&quot;, !gDBView.supportsThreading);</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-  sortUnthreadedMenuItem.setAttribute(&quot;disabled&quot;, !gDBView.supportsThreading);</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-</span>
<a href="#l3.15"></a><span id="l3.15">   var groupBySortOrderMenuItem = document.getElementById(&quot;groupBySort&quot;);</span>
<a href="#l3.16"></a><span id="l3.16"> </span>
<a href="#l3.17"></a><span id="l3.17" class="difflineminus">-  groupBySortOrderMenuItem.setAttribute(&quot;disabled&quot;, !gDBView.supportsThreading || !sortTypeSupportsGrouping);</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+  groupBySortOrderMenuItem.setAttribute(&quot;disabled&quot;, !sortTypeSupportsGrouping);</span>
<a href="#l3.19"></a><span id="l3.19">   groupBySortOrderMenuItem.setAttribute(&quot;checked&quot;, grouped);</span>
<a href="#l3.20"></a><span id="l3.20"> }</span>
<a href="#l3.21"></a><span id="l3.21"> </span>
<a href="#l3.22"></a><span id="l3.22"> function InitViewMessagesMenu()</span>
<a href="#l3.23"></a><span id="l3.23"> {</span>
<a href="#l3.24"></a><span id="l3.24">   var viewFlags = (gDBView) ? gDBView.viewFlags : 0;</span>
<a href="#l3.25"></a><span id="l3.25">   var viewType = (gDBView) ? gDBView.viewType : 0;</span>
<a href="#l3.26"></a><span id="l3.26"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mail/base/content/searchBar.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mail/base/content/searchBar.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -172,21 +172,17 @@ function createQuickSearchView()</span>
<a href="#l4.4"></a><span id="l4.4">       treeView.selection.clearSelection();</span>
<a href="#l4.5"></a><span id="l4.5">     gPreQuickSearchView = gDBView;</span>
<a href="#l4.6"></a><span id="l4.6">     if (gDBView.viewType == nsMsgViewType.eShowVirtualFolderResults)</span>
<a href="#l4.7"></a><span id="l4.7">     {</span>
<a href="#l4.8"></a><span id="l4.8">       // remove the view as a listener on the search results</span>
<a href="#l4.9"></a><span id="l4.9">       var saveViewSearchListener = gDBView.QueryInterface(Components.interfaces.nsIMsgSearchNotify);</span>
<a href="#l4.10"></a><span id="l4.10">       gSearchSession.unregisterListener(saveViewSearchListener);</span>
<a href="#l4.11"></a><span id="l4.11">     }</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-    // if grouped by sort, turn that off, as well as threaded, since we don't</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">-    // group quick search results yet.</span>
<a href="#l4.14"></a><span id="l4.14">     var viewFlags = gDBView.viewFlags;</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineminus">-    if (viewFlags &amp; nsMsgViewFlagsType.kGroupBySort)</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">-      viewFlags &amp;= ~(nsMsgViewFlagsType.kGroupBySort | nsMsgViewFlagsType.kThreadedDisplay);</span>
<a href="#l4.17"></a><span id="l4.17">     CreateDBView(gDBView.msgFolder, (gXFVirtualFolderTerms) ? nsMsgViewType.eShowVirtualFolderResults : nsMsgViewType.eShowQuickSearchResults, viewFlags, gDBView.sortType, gDBView.sortOrder);</span>
<a href="#l4.18"></a><span id="l4.18">   }</span>
<a href="#l4.19"></a><span id="l4.19"> }</span>
<a href="#l4.20"></a><span id="l4.20"> </span>
<a href="#l4.21"></a><span id="l4.21"> function initializeSearchBar()</span>
<a href="#l4.22"></a><span id="l4.22"> {</span>
<a href="#l4.23"></a><span id="l4.23">    createQuickSearchView();</span>
<a href="#l4.24"></a><span id="l4.24">    if (!gSearchSession)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/base/resources/content/mail3PaneWindowCommands.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/base/resources/content/mail3PaneWindowCommands.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -404,29 +404,29 @@ var DefaultController =</span>
<a href="#l5.4"></a><span id="l5.4">       case &quot;cmd_selectAll&quot;:</span>
<a href="#l5.5"></a><span id="l5.5">       case &quot;cmd_selectFlagged&quot;:</span>
<a href="#l5.6"></a><span id="l5.6">         return gDBView != null;</span>
<a href="#l5.7"></a><span id="l5.7">       // these are enabled on when we are in threaded mode</span>
<a href="#l5.8"></a><span id="l5.8">       case &quot;cmd_selectThread&quot;:</span>
<a href="#l5.9"></a><span id="l5.9">         if (GetNumSelectedMessages() &lt;= 0) return false;</span>
<a href="#l5.10"></a><span id="l5.10">       case &quot;cmd_expandAllThreads&quot;:</span>
<a href="#l5.11"></a><span id="l5.11">       case &quot;cmd_collapseAllThreads&quot;:</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-        if (!gDBView || !gDBView.supportsThreading) </span>
<a href="#l5.13"></a><span id="l5.13" class="difflineminus">-          return false;</span>
<a href="#l5.14"></a><span id="l5.14">         return (gDBView.viewFlags &amp; nsMsgViewFlagsType.kThreadedDisplay);</span>
<a href="#l5.15"></a><span id="l5.15">         break;</span>
<a href="#l5.16"></a><span id="l5.16">       case &quot;cmd_nextFlaggedMsg&quot;:</span>
<a href="#l5.17"></a><span id="l5.17">       case &quot;cmd_previousFlaggedMsg&quot;:</span>
<a href="#l5.18"></a><span id="l5.18">         return IsViewNavigationItemEnabled();</span>
<a href="#l5.19"></a><span id="l5.19">       case &quot;cmd_viewAllMsgs&quot;:</span>
<a href="#l5.20"></a><span id="l5.20">       case &quot;cmd_viewUnreadMsgs&quot;:</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+      case &quot;cmd_viewIgnoredThreads&quot;:</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+        return gDBView;</span>
<a href="#l5.23"></a><span id="l5.23">       case &quot;cmd_viewThreadsWithUnread&quot;:</span>
<a href="#l5.24"></a><span id="l5.24">       case &quot;cmd_viewWatchedThreadsWithUnread&quot;:</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineminus">-      case &quot;cmd_viewIgnoredThreads&quot;:</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineminus">-        return gDBView;</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineplus">+        return gDBView &amp;&amp; !(GetSelectedMsgFolders()[0].flags &amp; </span>
<a href="#l5.28"></a><span id="l5.28" class="difflineplus">+                            MSG_FOLDER_FLAG_VIRTUAL);</span>
<a href="#l5.29"></a><span id="l5.29">       case &quot;cmd_stop&quot;:</span>
<a href="#l5.30"></a><span id="l5.30">         return true;</span>
<a href="#l5.31"></a><span id="l5.31">       case &quot;cmd_undo&quot;:</span>
<a href="#l5.32"></a><span id="l5.32">       case &quot;cmd_redo&quot;:</span>
<a href="#l5.33"></a><span id="l5.33">           return SetupUndoRedoCommand(command);</span>
<a href="#l5.34"></a><span id="l5.34">       case &quot;cmd_renameFolder&quot;:</span>
<a href="#l5.35"></a><span id="l5.35">         return IsRenameFolderEnabled();</span>
<a href="#l5.36"></a><span id="l5.36">       case &quot;cmd_sendUnsentMsgs&quot;:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/base/resources/content/mailWindowOverlay.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/base/resources/content/mailWindowOverlay.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -250,22 +250,19 @@ function InitViewSortByMenu()</span>
<a href="#l6.4"></a><span id="l6.4">     var grouped = ((gDBView.viewFlags &amp; nsMsgViewFlagsType.kGroupBySort) != 0);</span>
<a href="#l6.5"></a><span id="l6.5">     var threaded = ((gDBView.viewFlags &amp; nsMsgViewFlagsType.kThreadedDisplay) != 0 &amp;&amp; !grouped);</span>
<a href="#l6.6"></a><span id="l6.6">     var sortThreadedMenuItem = document.getElementById(&quot;sortThreaded&quot;);</span>
<a href="#l6.7"></a><span id="l6.7">     var sortUnthreadedMenuItem = document.getElementById(&quot;sortUnthreaded&quot;);</span>
<a href="#l6.8"></a><span id="l6.8"> </span>
<a href="#l6.9"></a><span id="l6.9">     sortThreadedMenuItem.setAttribute(&quot;checked&quot;, threaded);</span>
<a href="#l6.10"></a><span id="l6.10">     sortUnthreadedMenuItem.setAttribute(&quot;checked&quot;, !threaded &amp;&amp; !grouped);</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-    sortThreadedMenuItem.setAttribute(&quot;disabled&quot;, !gDBView.supportsThreading);</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineminus">-    sortUnthreadedMenuItem.setAttribute(&quot;disabled&quot;, !gDBView.supportsThreading);</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineminus">-</span>
<a href="#l6.15"></a><span id="l6.15">     var groupBySortOrderMenuItem = document.getElementById(&quot;groupBySort&quot;);</span>
<a href="#l6.16"></a><span id="l6.16"> </span>
<a href="#l6.17"></a><span id="l6.17" class="difflineminus">-    groupBySortOrderMenuItem.setAttribute(&quot;disabled&quot;, !gDBView.supportsThreading || !sortTypeSupportsGrouping);</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+    groupBySortOrderMenuItem.setAttribute(&quot;disabled&quot;, !sortTypeSupportsGrouping);</span>
<a href="#l6.19"></a><span id="l6.19">     groupBySortOrderMenuItem.setAttribute(&quot;checked&quot;, grouped);</span>
<a href="#l6.20"></a><span id="l6.20"> }</span>
<a href="#l6.21"></a><span id="l6.21"> </span>
<a href="#l6.22"></a><span id="l6.22"> function InitViewMessagesMenu()</span>
<a href="#l6.23"></a><span id="l6.23"> {</span>
<a href="#l6.24"></a><span id="l6.24">   var viewFlags = gDBView ? gDBView.viewFlags : 0;</span>
<a href="#l6.25"></a><span id="l6.25">   var viewType = gDBView ? gDBView.viewType : 0;</span>
<a href="#l6.26"></a><span id="l6.26"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/base/resources/content/threadPane.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/base/resources/content/threadPane.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -170,19 +170,16 @@ function HandleColumnClick(columnID)</span>
<a href="#l7.4"></a><span id="l7.4">   var dbview = GetDBView();</span>
<a href="#l7.5"></a><span id="l7.5">   var simpleColumns = false;</span>
<a href="#l7.6"></a><span id="l7.6">   try {</span>
<a href="#l7.7"></a><span id="l7.7">     simpleColumns = !pref.getBoolPref(&quot;mailnews.thread_pane_column_unthreads&quot;);</span>
<a href="#l7.8"></a><span id="l7.8">   }</span>
<a href="#l7.9"></a><span id="l7.9">   catch (ex) {</span>
<a href="#l7.10"></a><span id="l7.10">   }</span>
<a href="#l7.11"></a><span id="l7.11">   if (sortType == &quot;byThread&quot;) {</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-    if (!dbview.supportsThreading)</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineminus">-      return;</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineminus">-</span>
<a href="#l7.15"></a><span id="l7.15">     if (simpleColumns)</span>
<a href="#l7.16"></a><span id="l7.16">       MsgToggleThreaded();</span>
<a href="#l7.17"></a><span id="l7.17">     else if (dbview.viewFlags &amp; nsMsgViewFlagsType.kThreadedDisplay)</span>
<a href="#l7.18"></a><span id="l7.18">       MsgReverseSortThreadPane();</span>
<a href="#l7.19"></a><span id="l7.19">     else</span>
<a href="#l7.20"></a><span id="l7.20">       MsgSortByThread();</span>
<a href="#l7.21"></a><span id="l7.21">   }</span>
<a href="#l7.22"></a><span id="l7.22">   else {</span>
<a href="#l7.23"></a><span id="l7.23" class="difflineat">@@ -232,36 +229,28 @@ function ThreadPaneKeyPress(event)</span>
<a href="#l7.24"></a><span id="l7.24"> {</span>
<a href="#l7.25"></a><span id="l7.25">     if (event.keyCode == 13)</span>
<a href="#l7.26"></a><span id="l7.26">       ThreadPaneDoubleClick();</span>
<a href="#l7.27"></a><span id="l7.27"> }</span>
<a href="#l7.28"></a><span id="l7.28"> </span>
<a href="#l7.29"></a><span id="l7.29"> function MsgSortByThread()</span>
<a href="#l7.30"></a><span id="l7.30"> {</span>
<a href="#l7.31"></a><span id="l7.31">   var dbview = GetDBView();</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineminus">-  if(dbview &amp;&amp; !dbview.supportsThreading)</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineminus">-    return;</span>
<a href="#l7.34"></a><span id="l7.34">   dbview.viewFlags |= nsMsgViewFlagsType.kThreadedDisplay;</span>
<a href="#l7.35"></a><span id="l7.35">   dbview.viewFlags &amp;= ~nsMsgViewFlagsType.kGroupBySort;</span>
<a href="#l7.36"></a><span id="l7.36">   MsgSortThreadPane('byDate');</span>
<a href="#l7.37"></a><span id="l7.37"> }</span>
<a href="#l7.38"></a><span id="l7.38"> </span>
<a href="#l7.39"></a><span id="l7.39"> function MsgSortThreadPane(sortName)</span>
<a href="#l7.40"></a><span id="l7.40"> {</span>
<a href="#l7.41"></a><span id="l7.41">   var sortType = nsMsgViewSortType[sortName];</span>
<a href="#l7.42"></a><span id="l7.42">   var dbview = GetDBView();</span>
<a href="#l7.43"></a><span id="l7.43"> </span>
<a href="#l7.44"></a><span id="l7.44" class="difflineminus">-  if (dbview.viewFlags &amp; nsMsgViewFlagsType.kGroupBySort)</span>
<a href="#l7.45"></a><span id="l7.45" class="difflineminus">-  {</span>
<a href="#l7.46"></a><span id="l7.46" class="difflineminus">-    dbview.viewFlags &amp;= ~nsMsgViewFlagsType.kGroupBySort;</span>
<a href="#l7.47"></a><span id="l7.47" class="difflineminus">-    dbview.sortType = sortType; // save sort in current view</span>
<a href="#l7.48"></a><span id="l7.48" class="difflineminus">-    viewDebug(&quot;switching view to all msgs\n&quot;);</span>
<a href="#l7.49"></a><span id="l7.49" class="difflineminus">-    SwitchView(&quot;cmd_viewAllMsgs&quot;);</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineminus">-    return;</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineminus">-  }</span>
<a href="#l7.52"></a><span id="l7.52" class="difflineplus">+  // turn off grouping</span>
<a href="#l7.53"></a><span id="l7.53" class="difflineplus">+  dbview.viewFlags &amp;= ~nsMsgViewFlagsType.kGroupBySort;</span>
<a href="#l7.54"></a><span id="l7.54"> </span>
<a href="#l7.55"></a><span id="l7.55">   dbview.sort(sortType, nsMsgViewSortOrder.ascending);</span>
<a href="#l7.56"></a><span id="l7.56">   UpdateSortIndicators(sortType, nsMsgViewSortOrder.ascending);</span>
<a href="#l7.57"></a><span id="l7.57"> }</span>
<a href="#l7.58"></a><span id="l7.58"> </span>
<a href="#l7.59"></a><span id="l7.59"> function MsgReverseSortThreadPane()</span>
<a href="#l7.60"></a><span id="l7.60"> {</span>
<a href="#l7.61"></a><span id="l7.61">   var dbview = GetDBView();</span>
<a href="#l7.62"></a><span id="l7.62" class="difflineat">@@ -271,41 +260,34 @@ function MsgReverseSortThreadPane()</span>
<a href="#l7.63"></a><span id="l7.63">   else {</span>
<a href="#l7.64"></a><span id="l7.64">     MsgSortAscending();</span>
<a href="#l7.65"></a><span id="l7.65">   }</span>
<a href="#l7.66"></a><span id="l7.66"> }</span>
<a href="#l7.67"></a><span id="l7.67"> </span>
<a href="#l7.68"></a><span id="l7.68"> function MsgToggleThreaded()</span>
<a href="#l7.69"></a><span id="l7.69"> {</span>
<a href="#l7.70"></a><span id="l7.70">     var dbview = GetDBView();</span>
<a href="#l7.71"></a><span id="l7.71" class="difflineminus">-</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineminus">-    dbview.viewFlags ^= nsMsgViewFlagsType.kThreadedDisplay;</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineminus">-    if (dbview.viewFlags &amp; nsMsgViewFlagsType.kGroupBySort)</span>
<a href="#l7.74"></a><span id="l7.74" class="difflineminus">-    {</span>
<a href="#l7.75"></a><span id="l7.75" class="difflineminus">-      dbview.viewFlags &amp;= ~nsMsgViewFlagsType.kGroupBySort;</span>
<a href="#l7.76"></a><span id="l7.76" class="difflineminus">-      viewDebug(&quot;switching view to all msgs\n&quot;);</span>
<a href="#l7.77"></a><span id="l7.77" class="difflineminus">-      SwitchView(&quot;cmd_viewAllMsgs&quot;);</span>
<a href="#l7.78"></a><span id="l7.78" class="difflineminus">-      return;</span>
<a href="#l7.79"></a><span id="l7.79" class="difflineminus">-    }</span>
<a href="#l7.80"></a><span id="l7.80" class="difflineplus">+    var newViewFlags = dbview.viewFlags ^ nsMsgViewFlagsType.kThreadedDisplay;</span>
<a href="#l7.81"></a><span id="l7.81" class="difflineplus">+    newViewFlags &amp;= ~nsMsgViewFlagsType.kGroupBySort;</span>
<a href="#l7.82"></a><span id="l7.82" class="difflineplus">+    dbview.viewFlags = newViewFlags;</span>
<a href="#l7.83"></a><span id="l7.83"> </span>
<a href="#l7.84"></a><span id="l7.84">     dbview.sort(dbview.sortType, dbview.sortOrder);</span>
<a href="#l7.85"></a><span id="l7.85">     UpdateSortIndicators(dbview.sortType, dbview.sortOrder);</span>
<a href="#l7.86"></a><span id="l7.86"> }</span>
<a href="#l7.87"></a><span id="l7.87"> </span>
<a href="#l7.88"></a><span id="l7.88"> function MsgSortThreaded()</span>
<a href="#l7.89"></a><span id="l7.89"> {</span>
<a href="#l7.90"></a><span id="l7.90">     var dbview = GetDBView();</span>
<a href="#l7.91"></a><span id="l7.91">     var viewFlags = dbview.viewFlags;</span>
<a href="#l7.92"></a><span id="l7.92" class="difflineminus">-</span>
<a href="#l7.93"></a><span id="l7.93" class="difflineminus">-    if (viewFlags &amp; nsMsgViewFlagsType.kGroupBySort)</span>
<a href="#l7.94"></a><span id="l7.94" class="difflineminus">-    {</span>
<a href="#l7.95"></a><span id="l7.95" class="difflineminus">-      dbview.viewFlags &amp;= ~nsMsgViewFlagsType.kGroupBySort;</span>
<a href="#l7.96"></a><span id="l7.96" class="difflineminus">-      viewDebug(&quot;switching view to all msgs\n&quot;);</span>
<a href="#l7.97"></a><span id="l7.97" class="difflineplus">+    let wasGrouped = viewFlags &amp; nsMsgViewFlagsType.kGroupBySort;</span>
<a href="#l7.98"></a><span id="l7.98" class="difflineplus">+    dbview.viewFlags &amp;= ~nsMsgViewFlagsType.kGroupBySort;</span>
<a href="#l7.99"></a><span id="l7.99" class="difflineplus">+    // if we were grouped, and not a saved search, just rebuild the view</span>
<a href="#l7.100"></a><span id="l7.100" class="difflineplus">+    if (wasGrouped &amp;&amp; !(gMsgFolderSelected.flags &amp; </span>
<a href="#l7.101"></a><span id="l7.101" class="difflineplus">+                       Components.interfaces.nsMsgFolderFlags.Virtual))</span>
<a href="#l7.102"></a><span id="l7.102">       SwitchView(&quot;cmd_viewAllMsgs&quot;);</span>
<a href="#l7.103"></a><span id="l7.103" class="difflineminus">-    }</span>
<a href="#l7.104"></a><span id="l7.104">     // Toggle if not already threaded.</span>
<a href="#l7.105"></a><span id="l7.105">     else if ((viewFlags &amp; nsMsgViewFlagsType.kThreadedDisplay) == 0)</span>
<a href="#l7.106"></a><span id="l7.106">         MsgToggleThreaded();</span>
<a href="#l7.107"></a><span id="l7.107"> }</span>
<a href="#l7.108"></a><span id="l7.108"> </span>
<a href="#l7.109"></a><span id="l7.109"> function MsgGroupBySort()</span>
<a href="#l7.110"></a><span id="l7.110"> {</span>
<a href="#l7.111"></a><span id="l7.111">   var dbview = GetDBView();</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineat">@@ -317,27 +299,34 @@ function MsgGroupBySort()</span>
<a href="#l7.113"></a><span id="l7.113"> </span>
<a href="#l7.114"></a><span id="l7.114">   var sortTypeSupportsGrouping = (sortType == nsMsgViewSortType.byAuthor </span>
<a href="#l7.115"></a><span id="l7.115">          || sortType == nsMsgViewSortType.byDate || sortType == nsMsgViewSortType.byReceived || sortType == nsMsgViewSortType.byPriority</span>
<a href="#l7.116"></a><span id="l7.116">          || sortType == nsMsgViewSortType.bySubject || sortType == nsMsgViewSortType.byTags</span>
<a href="#l7.117"></a><span id="l7.117">          || sortType == nsMsgViewSortType.byStatus  || sortType == nsMsgViewSortType.byRecipient</span>
<a href="#l7.118"></a><span id="l7.118">          || sortType == nsMsgViewSortType.byAccount || sortType == nsMsgViewSortType.byFlagged</span>
<a href="#l7.119"></a><span id="l7.119">          || sortType == nsMsgViewSortType.byAttachments);</span>
<a href="#l7.120"></a><span id="l7.120"> </span>
<a href="#l7.121"></a><span id="l7.121" class="difflineminus">-  if (!dbview.supportsThreading || !sortTypeSupportsGrouping)</span>
<a href="#l7.122"></a><span id="l7.122" class="difflineplus">+  if (!sortTypeSupportsGrouping)</span>
<a href="#l7.123"></a><span id="l7.123">     return; // we shouldn't be trying to group something we don't support grouping for...</span>
<a href="#l7.124"></a><span id="l7.124"> </span>
<a href="#l7.125"></a><span id="l7.125">   viewFlags |= nsMsgViewFlagsType.kThreadedDisplay | nsMsgViewFlagsType.kGroupBySort;</span>
<a href="#l7.126"></a><span id="l7.126" class="difflineplus">+  if (gDBView &amp;&amp;</span>
<a href="#l7.127"></a><span id="l7.127" class="difflineplus">+      gMsgFolderSelected.flags &amp; Components.interfaces.nsMsgFolderFlags.Virtual)</span>
<a href="#l7.128"></a><span id="l7.128" class="difflineplus">+  {</span>
<a href="#l7.129"></a><span id="l7.129" class="difflineplus">+    gDBView.viewFlags = viewFlags;</span>
<a href="#l7.130"></a><span id="l7.130" class="difflineplus">+    UpdateSortIndicators(sortType, nsMsgViewSortOrder.ascending);</span>
<a href="#l7.131"></a><span id="l7.131" class="difflineplus">+    return;</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineplus">+  }</span>
<a href="#l7.133"></a><span id="l7.133">   // null this out, so we don't try sort.</span>
<a href="#l7.134"></a><span id="l7.134">   if (gDBView) {</span>
<a href="#l7.135"></a><span id="l7.135">     gDBView.close();</span>
<a href="#l7.136"></a><span id="l7.136">     gDBView = null;</span>
<a href="#l7.137"></a><span id="l7.137">   }</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineminus">-  var dbviewContractId = &quot;@mozilla.org/messenger/msgdbview;1?type=group&quot;;</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineminus">-  gDBView = Components.classes[dbviewContractId].createInstance(Components.interfaces.nsIMsgDBView);</span>
<a href="#l7.140"></a><span id="l7.140" class="difflineplus">+  gDBView = Components.classes[&quot;@mozilla.org/messenger/msgdbview;1?type=group&quot;]</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+                                .createInstance(Components.interfaces.nsIMsgDBView);</span>
<a href="#l7.142"></a><span id="l7.142"> </span>
<a href="#l7.143"></a><span id="l7.143">   if (!gThreadPaneCommandUpdater)</span>
<a href="#l7.144"></a><span id="l7.144">     gThreadPaneCommandUpdater = new nsMsgDBViewCommandUpdater();</span>
<a href="#l7.145"></a><span id="l7.145"> </span>
<a href="#l7.146"></a><span id="l7.146"> </span>
<a href="#l7.147"></a><span id="l7.147">   gDBView.init(messenger, msgWindow, gThreadPaneCommandUpdater);</span>
<a href="#l7.148"></a><span id="l7.148">   gDBView.open(msgFolder, sortType, sortOrder, viewFlags, count);</span>
<a href="#l7.149"></a><span id="l7.149">   RerootThreadPane();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/base/src/Makefile.in</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/base/src/Makefile.in</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -116,16 +116,17 @@ CPPSRCS		= \</span>
<a href="#l8.4"></a><span id="l8.4"> 		nsMsgPrintEngine.cpp \</span>
<a href="#l8.5"></a><span id="l8.5"> 		nsStatusBarBiffManager.cpp \</span>
<a href="#l8.6"></a><span id="l8.6"> 		nsMsgDBView.cpp \</span>
<a href="#l8.7"></a><span id="l8.7"> 		nsMsgThreadedDBView.cpp \</span>
<a href="#l8.8"></a><span id="l8.8"> 		nsMsgSpecialViews.cpp \</span>
<a href="#l8.9"></a><span id="l8.9"> 		nsMsgQuickSearchDBView.cpp \</span>
<a href="#l8.10"></a><span id="l8.10"> 		nsMsgSearchDBView.cpp \</span>
<a href="#l8.11"></a><span id="l8.11"> 		nsMsgXFVirtualFolderDBView.cpp \</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+		nsMsgXFViewThread.cpp \</span>
<a href="#l8.13"></a><span id="l8.13"> 		nsMsgGroupThread.cpp \</span>
<a href="#l8.14"></a><span id="l8.14"> 		nsMsgGroupView.cpp \</span>
<a href="#l8.15"></a><span id="l8.15"> 		nsMsgOfflineManager.cpp \</span>
<a href="#l8.16"></a><span id="l8.16"> 		nsMsgProgress.cpp \</span>
<a href="#l8.17"></a><span id="l8.17"> 		nsMessengerContentHandler.cpp \</span>
<a href="#l8.18"></a><span id="l8.18"> 		nsSpamSettings.cpp \</span>
<a href="#l8.19"></a><span id="l8.19"> 		nsCidProtocolHandler.cpp \</span>
<a href="#l8.20"></a><span id="l8.20"> 		nsMsgContentPolicy.cpp \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l9.4"></a><span id="l9.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l9.5"></a><span id="l9.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l9.6"></a><span id="l9.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l9.7"></a><span id="l9.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l9.8"></a><span id="l9.8">  *</span>
<a href="#l9.9"></a><span id="l9.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l9.10"></a><span id="l9.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l9.11"></a><span id="l9.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l9.12"></a><span id="l9.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l9.13"></a><span id="l9.13">  *</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineat">@@ -839,16 +839,21 @@ nsresult nsMsgDBView::RestoreSelection(n</span>
<a href="#l9.15"></a><span id="l9.15"> }</span>
<a href="#l9.16"></a><span id="l9.16"> </span>
<a href="#l9.17"></a><span id="l9.17"> nsresult nsMsgDBView::GenerateURIForMsgKey(nsMsgKey aMsgKey, nsIMsgFolder *folder, nsACString &amp; aURI)</span>
<a href="#l9.18"></a><span id="l9.18"> {</span>
<a href="#l9.19"></a><span id="l9.19">   NS_ENSURE_ARG(folder);</span>
<a href="#l9.20"></a><span id="l9.20">   return folder-&gt;GenerateMessageURI(aMsgKey, aURI);</span>
<a href="#l9.21"></a><span id="l9.21"> }</span>
<a href="#l9.22"></a><span id="l9.22"> </span>
<a href="#l9.23"></a><span id="l9.23" class="difflineplus">+nsresult nsMsgDBView::GetMessageEnumerator(nsISimpleEnumerator **enumerator)</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineplus">+{</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineplus">+  return m_db-&gt;EnumerateMessages(enumerator);</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineplus">+}</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineplus">+</span>
<a href="#l9.28"></a><span id="l9.28"> nsresult nsMsgDBView::CycleThreadedColumn(nsIDOMElement * aElement)</span>
<a href="#l9.29"></a><span id="l9.29"> {</span>
<a href="#l9.30"></a><span id="l9.30">   nsAutoString currentView;</span>
<a href="#l9.31"></a><span id="l9.31"> </span>
<a href="#l9.32"></a><span id="l9.32">   // toggle threaded/unthreaded mode</span>
<a href="#l9.33"></a><span id="l9.33">   aElement-&gt;GetAttribute(NS_LITERAL_STRING(&quot;currentView&quot;), currentView);</span>
<a href="#l9.34"></a><span id="l9.34">   if (currentView.EqualsLiteral(&quot;threaded&quot;))</span>
<a href="#l9.35"></a><span id="l9.35">     aElement-&gt;SetAttribute(NS_LITERAL_STRING(&quot;currentView&quot;), NS_LITERAL_STRING(&quot;unthreaded&quot;));</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineat">@@ -2747,17 +2752,17 @@ nsresult nsMsgDBView::DownloadForOffline</span>
<a href="#l9.37"></a><span id="l9.37">   return rv;</span>
<a href="#l9.38"></a><span id="l9.38"> }</span>
<a href="#l9.39"></a><span id="l9.39"> </span>
<a href="#l9.40"></a><span id="l9.40"> nsresult nsMsgDBView::DownloadFlaggedForOffline(nsIMsgWindow *window)</span>
<a href="#l9.41"></a><span id="l9.41"> {</span>
<a href="#l9.42"></a><span id="l9.42">   nsresult rv = NS_OK;</span>
<a href="#l9.43"></a><span id="l9.43">   nsCOMPtr&lt;nsIMutableArray&gt; messageArray(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l9.44"></a><span id="l9.44">   nsCOMPtr &lt;nsISimpleEnumerator&gt; enumerator;</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineminus">-  rv = m_db-&gt;EnumerateMessages(getter_AddRefs(enumerator));</span>
<a href="#l9.46"></a><span id="l9.46" class="difflineplus">+  rv = GetMessageEnumerator(getter_AddRefs(enumerator));</span>
<a href="#l9.47"></a><span id="l9.47">   if (NS_SUCCEEDED(rv) &amp;&amp; enumerator)</span>
<a href="#l9.48"></a><span id="l9.48">   {</span>
<a href="#l9.49"></a><span id="l9.49">     PRBool hasMore;</span>
<a href="#l9.50"></a><span id="l9.50"> </span>
<a href="#l9.51"></a><span id="l9.51">     while (NS_SUCCEEDED(rv = enumerator-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; (hasMore == PR_TRUE))</span>
<a href="#l9.52"></a><span id="l9.52">     {</span>
<a href="#l9.53"></a><span id="l9.53">       nsCOMPtr &lt;nsIMsgDBHdr&gt; pHeader;</span>
<a href="#l9.54"></a><span id="l9.54">       rv = enumerator-&gt;GetNext(getter_AddRefs(pHeader));</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineat">@@ -2809,17 +2814,17 @@ nsresult nsMsgDBView::SetReadByIndex(nsM</span>
<a href="#l9.56"></a><span id="l9.56">   nsCOMPtr &lt;nsIMsgDatabase&gt; dbToUse;</span>
<a href="#l9.57"></a><span id="l9.57">   rv = GetDBForViewIndex(index, getter_AddRefs(dbToUse));</span>
<a href="#l9.58"></a><span id="l9.58">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.59"></a><span id="l9.59"> </span>
<a href="#l9.60"></a><span id="l9.60">   rv = dbToUse-&gt;MarkRead(m_keys[index], read, this);</span>
<a href="#l9.61"></a><span id="l9.61">   NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l9.62"></a><span id="l9.62">   if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)</span>
<a href="#l9.63"></a><span id="l9.63">   {</span>
<a href="#l9.64"></a><span id="l9.64" class="difflineminus">-    nsMsgViewIndex threadIndex = ThreadIndexOfMsg(m_keys[index], index, nsnull, nsnull);</span>
<a href="#l9.65"></a><span id="l9.65" class="difflineplus">+    nsMsgViewIndex threadIndex = GetThreadIndex(index);</span>
<a href="#l9.66"></a><span id="l9.66">     if (threadIndex != index)</span>
<a href="#l9.67"></a><span id="l9.67">       NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l9.68"></a><span id="l9.68">   }</span>
<a href="#l9.69"></a><span id="l9.69">   return rv;</span>
<a href="#l9.70"></a><span id="l9.70"> }</span>
<a href="#l9.71"></a><span id="l9.71"> </span>
<a href="#l9.72"></a><span id="l9.72"> nsresult nsMsgDBView::SetThreadOfMsgReadByIndex(nsMsgViewIndex index, nsTArray&lt;nsMsgKey&gt; &amp;keysMarkedRead, PRBool /*read*/)</span>
<a href="#l9.73"></a><span id="l9.73"> {</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineat">@@ -3462,31 +3467,31 @@ nsresult nsMsgDBView::GetLongField(nsIMs</span>
<a href="#l9.75"></a><span id="l9.75">       break;</span>
<a href="#l9.76"></a><span id="l9.76">     case nsMsgViewSortType::byDate:</span>
<a href="#l9.77"></a><span id="l9.77">       // when sorting threads by date, we want the date of the newest msg</span>
<a href="#l9.78"></a><span id="l9.78">       // in the thread</span>
<a href="#l9.79"></a><span id="l9.79">       if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay</span>
<a href="#l9.80"></a><span id="l9.80">         &amp;&amp; ! (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l9.81"></a><span id="l9.81">       {</span>
<a href="#l9.82"></a><span id="l9.82">         nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l9.83"></a><span id="l9.83" class="difflineminus">-        rv = m_db-&gt;GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(thread));</span>
<a href="#l9.84"></a><span id="l9.84" class="difflineplus">+        rv = GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(thread));</span>
<a href="#l9.85"></a><span id="l9.85">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.86"></a><span id="l9.86">         thread-&gt;GetNewestMsgDate(result);</span>
<a href="#l9.87"></a><span id="l9.87">       }</span>
<a href="#l9.88"></a><span id="l9.88">       else</span>
<a href="#l9.89"></a><span id="l9.89">         rv = msgHdr-&gt;GetDateInSeconds(result);</span>
<a href="#l9.90"></a><span id="l9.90">       break;</span>
<a href="#l9.91"></a><span id="l9.91">     case nsMsgViewSortType::byReceived:</span>
<a href="#l9.92"></a><span id="l9.92">       // when sorting threads by received date, we want the received date of the newest msg</span>
<a href="#l9.93"></a><span id="l9.93">       // in the thread</span>
<a href="#l9.94"></a><span id="l9.94">       if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay</span>
<a href="#l9.95"></a><span id="l9.95">         &amp;&amp; ! (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l9.96"></a><span id="l9.96">       {</span>
<a href="#l9.97"></a><span id="l9.97">         nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l9.98"></a><span id="l9.98" class="difflineminus">-        rv = m_db-&gt;GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(thread));</span>
<a href="#l9.99"></a><span id="l9.99" class="difflineplus">+        rv = GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(thread));</span>
<a href="#l9.100"></a><span id="l9.100">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.101"></a><span id="l9.101">         thread-&gt;GetNewestMsgDate(result);</span>
<a href="#l9.102"></a><span id="l9.102">       }</span>
<a href="#l9.103"></a><span id="l9.103">       else</span>
<a href="#l9.104"></a><span id="l9.104">       {</span>
<a href="#l9.105"></a><span id="l9.105">         rv = msgHdr-&gt;GetUint32Property(&quot;dateReceived&quot;, result);  // Already in seconds...</span>
<a href="#l9.106"></a><span id="l9.106">         if (*result == 0)  // Use Date instead, we have no Received property</span>
<a href="#l9.107"></a><span id="l9.107">           rv = msgHdr-&gt;GetDateInSeconds(result);</span>
<a href="#l9.108"></a><span id="l9.108" class="difflineat">@@ -4022,19 +4027,19 @@ nsMsgViewIndex nsMsgDBView::GetIndexOfFi</span>
<a href="#l9.109"></a><span id="l9.109">   // unread message in the thread. Sometimes, that will be wrong, however, so</span>
<a href="#l9.110"></a><span id="l9.110">   // let's skip it until we're sure it's necessary.</span>
<a href="#l9.111"></a><span id="l9.111">   //  (m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly)</span>
<a href="#l9.112"></a><span id="l9.112">   //    ? threadHdr-&gt;GetFirstUnreadKey(m_db) : threadHdr-&gt;GetChildAt(0);</span>
<a href="#l9.113"></a><span id="l9.113">   PRUint32 numThreadChildren;</span>
<a href="#l9.114"></a><span id="l9.114">   threadHdr-&gt;GetNumChildren(&amp;numThreadChildren);</span>
<a href="#l9.115"></a><span id="l9.115">   while (retIndex == nsMsgViewIndex_None &amp;&amp; childIndex &lt; numThreadChildren)</span>
<a href="#l9.116"></a><span id="l9.116">   {</span>
<a href="#l9.117"></a><span id="l9.117" class="difflineminus">-    nsMsgKey childKey;</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineminus">-    threadHdr-&gt;GetChildKeyAt(childIndex++, &amp;childKey);</span>
<a href="#l9.119"></a><span id="l9.119" class="difflineminus">-    retIndex = FindViewIndex(childKey);</span>
<a href="#l9.120"></a><span id="l9.120" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; childHdr;</span>
<a href="#l9.121"></a><span id="l9.121" class="difflineplus">+    threadHdr-&gt;GetChildHdrAt(childIndex++, getter_AddRefs(childHdr));</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineplus">+    retIndex = FindHdr(childHdr);</span>
<a href="#l9.123"></a><span id="l9.123">   }</span>
<a href="#l9.124"></a><span id="l9.124">   return retIndex;</span>
<a href="#l9.125"></a><span id="l9.125"> }</span>
<a href="#l9.126"></a><span id="l9.126"> </span>
<a href="#l9.127"></a><span id="l9.127"> nsresult nsMsgDBView::GetFirstMessageHdrToDisplayInThread(nsIMsgThread *threadHdr, nsIMsgDBHdr **result)</span>
<a href="#l9.128"></a><span id="l9.128"> {</span>
<a href="#l9.129"></a><span id="l9.129">   nsresult rv;</span>
<a href="#l9.130"></a><span id="l9.130"> </span>
<a href="#l9.131"></a><span id="l9.131" class="difflineat">@@ -4051,31 +4056,51 @@ nsresult nsMsgDBView::GetFirstMessageHdr</span>
<a href="#l9.132"></a><span id="l9.132"> // then we can avoid looking for the msgKey.</span>
<a href="#l9.133"></a><span id="l9.133"> nsMsgViewIndex nsMsgDBView::ThreadIndexOfMsg(nsMsgKey msgKey,</span>
<a href="#l9.134"></a><span id="l9.134">                                             nsMsgViewIndex msgIndex /* = nsMsgViewIndex_None */,</span>
<a href="#l9.135"></a><span id="l9.135">                                             PRInt32 *pThreadCount /* = NULL */,</span>
<a href="#l9.136"></a><span id="l9.136">                                             PRUint32 *pFlags /* = NULL */)</span>
<a href="#l9.137"></a><span id="l9.137"> {</span>
<a href="#l9.138"></a><span id="l9.138">   if (! (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l9.139"></a><span id="l9.139">     return nsMsgViewIndex_None;</span>
<a href="#l9.140"></a><span id="l9.140" class="difflineminus">-  nsCOMPtr &lt;nsIMsgThread&gt; threadHdr;</span>
<a href="#l9.141"></a><span id="l9.141">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l9.142"></a><span id="l9.142">   nsresult rv = m_db-&gt;GetMsgHdrForKey(msgKey, getter_AddRefs(msgHdr));</span>
<a href="#l9.143"></a><span id="l9.143">   NS_ENSURE_SUCCESS(rv, nsMsgViewIndex_None);</span>
<a href="#l9.144"></a><span id="l9.144" class="difflineminus">-  rv = GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(threadHdr));</span>
<a href="#l9.145"></a><span id="l9.145" class="difflineplus">+  return ThreadIndexOfMsgHdr(msgHdr, msgIndex, pThreadCount, pFlags);</span>
<a href="#l9.146"></a><span id="l9.146" class="difflineplus">+}</span>
<a href="#l9.147"></a><span id="l9.147" class="difflineplus">+</span>
<a href="#l9.148"></a><span id="l9.148" class="difflineplus">+nsMsgViewIndex nsMsgDBView::GetThreadIndex(nsMsgViewIndex msgIndex)</span>
<a href="#l9.149"></a><span id="l9.149" class="difflineplus">+{</span>
<a href="#l9.150"></a><span id="l9.150" class="difflineplus">+  if (!IsValidIndex(msgIndex))</span>
<a href="#l9.151"></a><span id="l9.151" class="difflineplus">+    return NS_MSG_INVALID_DBVIEW_INDEX;</span>
<a href="#l9.152"></a><span id="l9.152" class="difflineplus">+</span>
<a href="#l9.153"></a><span id="l9.153" class="difflineplus">+  // scan up looking for level 0 message.</span>
<a href="#l9.154"></a><span id="l9.154" class="difflineplus">+  while (m_levels[msgIndex] &amp;&amp; msgIndex)</span>
<a href="#l9.155"></a><span id="l9.155" class="difflineplus">+    --msgIndex;</span>
<a href="#l9.156"></a><span id="l9.156" class="difflineplus">+  return msgIndex;</span>
<a href="#l9.157"></a><span id="l9.157" class="difflineplus">+}</span>
<a href="#l9.158"></a><span id="l9.158" class="difflineplus">+</span>
<a href="#l9.159"></a><span id="l9.159" class="difflineplus">+nsMsgViewIndex </span>
<a href="#l9.160"></a><span id="l9.160" class="difflineplus">+nsMsgDBView::ThreadIndexOfMsgHdr(nsIMsgDBHdr *msgHdr, </span>
<a href="#l9.161"></a><span id="l9.161" class="difflineplus">+                                 nsMsgViewIndex msgIndex,</span>
<a href="#l9.162"></a><span id="l9.162" class="difflineplus">+                                 PRInt32 *pThreadCount,</span>
<a href="#l9.163"></a><span id="l9.163" class="difflineplus">+                                 PRUint32 *pFlags)</span>
<a href="#l9.164"></a><span id="l9.164" class="difflineplus">+{</span>
<a href="#l9.165"></a><span id="l9.165" class="difflineplus">+  nsCOMPtr&lt;nsIMsgThread&gt; threadHdr;</span>
<a href="#l9.166"></a><span id="l9.166" class="difflineplus">+  nsresult rv = GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(threadHdr));</span>
<a href="#l9.167"></a><span id="l9.167">   NS_ENSURE_SUCCESS(rv, nsMsgViewIndex_None);</span>
<a href="#l9.168"></a><span id="l9.168"> </span>
<a href="#l9.169"></a><span id="l9.169">   nsMsgViewIndex retIndex = nsMsgViewIndex_None;</span>
<a href="#l9.170"></a><span id="l9.170"> </span>
<a href="#l9.171"></a><span id="l9.171">   if (threadHdr != nsnull)</span>
<a href="#l9.172"></a><span id="l9.172">   {</span>
<a href="#l9.173"></a><span id="l9.173">     if (msgIndex == nsMsgViewIndex_None)</span>
<a href="#l9.174"></a><span id="l9.174" class="difflineminus">-      msgIndex = FindViewIndex(msgKey);</span>
<a href="#l9.175"></a><span id="l9.175" class="difflineminus">-</span>
<a href="#l9.176"></a><span id="l9.176" class="difflineminus">-    if (msgIndex == nsMsgViewIndex_None)  // key is not in view, need to find by thread</span>
<a href="#l9.177"></a><span id="l9.177" class="difflineplus">+      msgIndex = FindHdr(msgHdr);</span>
<a href="#l9.178"></a><span id="l9.178" class="difflineplus">+</span>
<a href="#l9.179"></a><span id="l9.179" class="difflineplus">+    if (msgIndex == nsMsgViewIndex_None)  // hdr is not in view, need to find by thread</span>
<a href="#l9.180"></a><span id="l9.180">     {</span>
<a href="#l9.181"></a><span id="l9.181">       msgIndex = GetIndexOfFirstDisplayedKeyInThread(threadHdr);</span>
<a href="#l9.182"></a><span id="l9.182">       //nsMsgKey    threadKey = (msgIndex == nsMsgViewIndex_None) ? nsMsgKey_None : GetAt(msgIndex);</span>
<a href="#l9.183"></a><span id="l9.183">       if (pFlags)</span>
<a href="#l9.184"></a><span id="l9.184">         threadHdr-&gt;GetFlags(pFlags);</span>
<a href="#l9.185"></a><span id="l9.185">     }</span>
<a href="#l9.186"></a><span id="l9.186">     nsMsgViewIndex startOfThread = msgIndex;</span>
<a href="#l9.187"></a><span id="l9.187">     while ((PRInt32) startOfThread &gt;= 0 &amp;&amp; m_levels[startOfThread] != 0)</span>
<a href="#l9.188"></a><span id="l9.188" class="difflineat">@@ -4155,21 +4180,20 @@ nsMsgViewIndex  nsMsgDBView::FindKey(nsM</span>
<a href="#l9.189"></a><span id="l9.189">           || (flags &amp; MSG_VIEW_FLAG_DUMMY))</span>
<a href="#l9.190"></a><span id="l9.190">           retIndex = (nsMsgViewIndex) m_keys.IndexOf(key, threadIndex + 1);</span>
<a href="#l9.191"></a><span id="l9.191">       }</span>
<a href="#l9.192"></a><span id="l9.192">     }</span>
<a href="#l9.193"></a><span id="l9.193">   }</span>
<a href="#l9.194"></a><span id="l9.194">   return retIndex;</span>
<a href="#l9.195"></a><span id="l9.195"> }</span>
<a href="#l9.196"></a><span id="l9.196"> </span>
<a href="#l9.197"></a><span id="l9.197" class="difflineminus">-nsresult nsMsgDBView::GetThreadCount(nsMsgKey messageKey, PRUint32 *pThreadCount)</span>
<a href="#l9.198"></a><span id="l9.198" class="difflineminus">-{</span>
<a href="#l9.199"></a><span id="l9.199" class="difflineminus">-  nsresult rv = NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l9.200"></a><span id="l9.200" class="difflineplus">+nsresult nsMsgDBView::GetThreadCount(nsMsgViewIndex index, PRUint32 *pThreadCount)</span>
<a href="#l9.201"></a><span id="l9.201" class="difflineplus">+{</span>
<a href="#l9.202"></a><span id="l9.202">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l9.203"></a><span id="l9.203" class="difflineminus">-  rv = m_db-&gt;GetMsgHdrForKey(messageKey, getter_AddRefs(msgHdr));</span>
<a href="#l9.204"></a><span id="l9.204" class="difflineplus">+  nsresult rv = GetMsgHdrForViewIndex(index, getter_AddRefs(msgHdr));</span>
<a href="#l9.205"></a><span id="l9.205">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.206"></a><span id="l9.206">   nsCOMPtr &lt;nsIMsgThread&gt; pThread;</span>
<a href="#l9.207"></a><span id="l9.207">   rv = GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(pThread));</span>
<a href="#l9.208"></a><span id="l9.208">   if (NS_SUCCEEDED(rv) &amp;&amp; pThread != nsnull)</span>
<a href="#l9.209"></a><span id="l9.209">     rv = pThread-&gt;GetNumChildren(pThreadCount);</span>
<a href="#l9.210"></a><span id="l9.210">   return rv;</span>
<a href="#l9.211"></a><span id="l9.211"> }</span>
<a href="#l9.212"></a><span id="l9.212"> </span>
<a href="#l9.213"></a><span id="l9.213" class="difflineat">@@ -4207,17 +4231,17 @@ nsresult nsMsgDBView::ExpansionDelta(nsM</span>
<a href="#l9.214"></a><span id="l9.214">   if (!(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l9.215"></a><span id="l9.215">     return NS_OK;</span>
<a href="#l9.216"></a><span id="l9.216"> </span>
<a href="#l9.217"></a><span id="l9.217">   // The client can pass in the key of any message</span>
<a href="#l9.218"></a><span id="l9.218">   // in a thread and get the expansion delta for the thread.</span>
<a href="#l9.219"></a><span id="l9.219"> </span>
<a href="#l9.220"></a><span id="l9.220">   if (!(m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly))</span>
<a href="#l9.221"></a><span id="l9.221">   {</span>
<a href="#l9.222"></a><span id="l9.222" class="difflineminus">-    rv = GetThreadCount(m_keys[index], &amp;numChildren);</span>
<a href="#l9.223"></a><span id="l9.223" class="difflineplus">+    rv = GetThreadCount(index, &amp;numChildren);</span>
<a href="#l9.224"></a><span id="l9.224">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.225"></a><span id="l9.225">   }</span>
<a href="#l9.226"></a><span id="l9.226">   else</span>
<a href="#l9.227"></a><span id="l9.227">   {</span>
<a href="#l9.228"></a><span id="l9.228">     numChildren = CountExpandedThread(index);</span>
<a href="#l9.229"></a><span id="l9.229">   }</span>
<a href="#l9.230"></a><span id="l9.230"> </span>
<a href="#l9.231"></a><span id="l9.231">   if (flags &amp; MSG_FLAG_ELIDED)</span>
<a href="#l9.232"></a><span id="l9.232" class="difflineat">@@ -4227,17 +4251,17 @@ nsresult nsMsgDBView::ExpansionDelta(nsM</span>
<a href="#l9.233"></a><span id="l9.233"> </span>
<a href="#l9.234"></a><span id="l9.234">   return NS_OK;</span>
<a href="#l9.235"></a><span id="l9.235"> }</span>
<a href="#l9.236"></a><span id="l9.236"> </span>
<a href="#l9.237"></a><span id="l9.237"> nsresult nsMsgDBView::ToggleExpansion(nsMsgViewIndex index, PRUint32 *numChanged)</span>
<a href="#l9.238"></a><span id="l9.238"> {</span>
<a href="#l9.239"></a><span id="l9.239">   NS_ENSURE_ARG(numChanged);</span>
<a href="#l9.240"></a><span id="l9.240">   *numChanged = 0;</span>
<a href="#l9.241"></a><span id="l9.241" class="difflineminus">-  nsMsgViewIndex threadIndex = ThreadIndexOfMsg(GetAt(index), index);</span>
<a href="#l9.242"></a><span id="l9.242" class="difflineplus">+  nsMsgViewIndex threadIndex = GetThreadIndex(index);</span>
<a href="#l9.243"></a><span id="l9.243">   if (threadIndex == nsMsgViewIndex_None)</span>
<a href="#l9.244"></a><span id="l9.244">   {</span>
<a href="#l9.245"></a><span id="l9.245">     NS_ASSERTION(PR_FALSE, &quot;couldn't find thread&quot;);</span>
<a href="#l9.246"></a><span id="l9.246">     return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l9.247"></a><span id="l9.247">   }</span>
<a href="#l9.248"></a><span id="l9.248">   PRInt32  flags = m_flags[threadIndex];</span>
<a href="#l9.249"></a><span id="l9.249"> </span>
<a href="#l9.250"></a><span id="l9.250">   // if not a thread, or doesn't have children, no expand/collapse</span>
<a href="#l9.251"></a><span id="l9.251" class="difflineat">@@ -4271,17 +4295,19 @@ nsresult nsMsgDBView::ExpandAndSelectThr</span>
<a href="#l9.252"></a><span id="l9.252"> {</span>
<a href="#l9.253"></a><span id="l9.253">   nsresult rv;</span>
<a href="#l9.254"></a><span id="l9.254"> </span>
<a href="#l9.255"></a><span id="l9.255">   nsMsgViewIndex threadIndex;</span>
<a href="#l9.256"></a><span id="l9.256">   PRBool inThreadedMode = (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay);</span>
<a href="#l9.257"></a><span id="l9.257"> </span>
<a href="#l9.258"></a><span id="l9.258">   if (inThreadedMode)</span>
<a href="#l9.259"></a><span id="l9.259">   {</span>
<a href="#l9.260"></a><span id="l9.260" class="difflineminus">-    threadIndex = ThreadIndexOfMsg(GetAt(index), index);</span>
<a href="#l9.261"></a><span id="l9.261" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l9.262"></a><span id="l9.262" class="difflineplus">+    GetMsgHdrForViewIndex(index, getter_AddRefs(msgHdr));</span>
<a href="#l9.263"></a><span id="l9.263" class="difflineplus">+    threadIndex = ThreadIndexOfMsgHdr(msgHdr, index);</span>
<a href="#l9.264"></a><span id="l9.264">     if (threadIndex == nsMsgViewIndex_None)</span>
<a href="#l9.265"></a><span id="l9.265">     {</span>
<a href="#l9.266"></a><span id="l9.266">       NS_ASSERTION(PR_FALSE, &quot;couldn't find thread&quot;);</span>
<a href="#l9.267"></a><span id="l9.267">       return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l9.268"></a><span id="l9.268">     }</span>
<a href="#l9.269"></a><span id="l9.269">   }</span>
<a href="#l9.270"></a><span id="l9.270">   else</span>
<a href="#l9.271"></a><span id="l9.271">   {</span>
<a href="#l9.272"></a><span id="l9.272" class="difflineat">@@ -4352,37 +4378,30 @@ nsresult nsMsgDBView::ExpandByIndex(nsMs</span>
<a href="#l9.273"></a><span id="l9.273">   flags &amp;= ~MSG_FLAG_ELIDED;</span>
<a href="#l9.274"></a><span id="l9.274"> </span>
<a href="#l9.275"></a><span id="l9.275">   if ((PRUint32) index &gt; m_keys.Length())</span>
<a href="#l9.276"></a><span id="l9.276">     return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l9.277"></a><span id="l9.277"> </span>
<a href="#l9.278"></a><span id="l9.278">   nsMsgKey firstIdInThread = m_keys[index];</span>
<a href="#l9.279"></a><span id="l9.279">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l9.280"></a><span id="l9.280">   nsCOMPtr &lt;nsIMsgThread&gt; pThread;</span>
<a href="#l9.281"></a><span id="l9.281" class="difflineminus">-  m_db-&gt;GetMsgHdrForKey(firstIdInThread, getter_AddRefs(msgHdr));</span>
<a href="#l9.282"></a><span id="l9.282" class="difflineminus">-  if (msgHdr == nsnull)</span>
<a href="#l9.283"></a><span id="l9.283" class="difflineminus">-  {</span>
<a href="#l9.284"></a><span id="l9.284" class="difflineminus">-    NS_ASSERTION(PR_FALSE, &quot;couldn't find message to expand&quot;);</span>
<a href="#l9.285"></a><span id="l9.285" class="difflineminus">-    return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l9.286"></a><span id="l9.286" class="difflineminus">-  }</span>
<a href="#l9.287"></a><span id="l9.287" class="difflineminus">-  nsresult rv = GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(pThread));</span>
<a href="#l9.288"></a><span id="l9.288" class="difflineplus">+  nsresult rv = GetThreadContainingIndex(index, getter_AddRefs(pThread));</span>
<a href="#l9.289"></a><span id="l9.289">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.290"></a><span id="l9.290">   m_flags[index] = flags;</span>
<a href="#l9.291"></a><span id="l9.291">   NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l9.292"></a><span id="l9.292">   if (m_viewFlags &amp; nsMsgViewFlagsType::kUnreadOnly)</span>
<a href="#l9.293"></a><span id="l9.293">   {</span>
<a href="#l9.294"></a><span id="l9.294">     if (flags &amp; MSG_FLAG_READ)</span>
<a href="#l9.295"></a><span id="l9.295">       m_levels.AppendElement(0);  // keep top level hdr in thread, even though read.</span>
<a href="#l9.296"></a><span id="l9.296">     rv = ListUnreadIdsInThread(pThread,  index, &amp;numExpanded);</span>
<a href="#l9.297"></a><span id="l9.297">   }</span>
<a href="#l9.298"></a><span id="l9.298">   else</span>
<a href="#l9.299"></a><span id="l9.299">     rv = ListIdsInThread(pThread,  index, &amp;numExpanded);</span>
<a href="#l9.300"></a><span id="l9.300"> </span>
<a href="#l9.301"></a><span id="l9.301">   NoteStartChange(index + 1, numExpanded, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l9.302"></a><span id="l9.302" class="difflineminus">-</span>
<a href="#l9.303"></a><span id="l9.303">   NoteEndChange(index + 1, numExpanded, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l9.304"></a><span id="l9.304">   if (pNumExpanded != nsnull)</span>
<a href="#l9.305"></a><span id="l9.305">     *pNumExpanded = numExpanded;</span>
<a href="#l9.306"></a><span id="l9.306">   return rv;</span>
<a href="#l9.307"></a><span id="l9.307"> }</span>
<a href="#l9.308"></a><span id="l9.308"> </span>
<a href="#l9.309"></a><span id="l9.309"> nsresult nsMsgDBView::CollapseAll()</span>
<a href="#l9.310"></a><span id="l9.310"> {</span>
<a href="#l9.311"></a><span id="l9.311" class="difflineat">@@ -4435,20 +4454,17 @@ nsresult nsMsgDBView::OnNewHeader(nsIMsg</span>
<a href="#l9.312"></a><span id="l9.312">     if (newHdr)</span>
<a href="#l9.313"></a><span id="l9.313">   rv = AddHdr(newHdr);</span>
<a href="#l9.314"></a><span id="l9.314">     return rv;</span>
<a href="#l9.315"></a><span id="l9.315"> }</span>
<a href="#l9.316"></a><span id="l9.316"> </span>
<a href="#l9.317"></a><span id="l9.317"> nsresult nsMsgDBView::GetThreadContainingIndex(nsMsgViewIndex index, nsIMsgThread **resultThread)</span>
<a href="#l9.318"></a><span id="l9.318"> {</span>
<a href="#l9.319"></a><span id="l9.319">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l9.320"></a><span id="l9.320" class="difflineminus">-</span>
<a href="#l9.321"></a><span id="l9.321" class="difflineminus">-  NS_ENSURE_TRUE(m_db, NS_ERROR_NULL_POINTER);</span>
<a href="#l9.322"></a><span id="l9.322" class="difflineminus">-</span>
<a href="#l9.323"></a><span id="l9.323" class="difflineminus">-  nsresult rv = m_db-&gt;GetMsgHdrForKey(m_keys[index], getter_AddRefs(msgHdr));</span>
<a href="#l9.324"></a><span id="l9.324" class="difflineplus">+  nsresult rv = GetMsgHdrForViewIndex(index, getter_AddRefs(msgHdr));</span>
<a href="#l9.325"></a><span id="l9.325">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.326"></a><span id="l9.326">   return GetThreadContainingMsgHdr(msgHdr, resultThread);</span>
<a href="#l9.327"></a><span id="l9.327"> }</span>
<a href="#l9.328"></a><span id="l9.328"> </span>
<a href="#l9.329"></a><span id="l9.329"> nsMsgViewIndex </span>
<a href="#l9.330"></a><span id="l9.330"> nsMsgDBView::GetIndexForThread(nsIMsgDBHdr *msgHdr)</span>
<a href="#l9.331"></a><span id="l9.331"> {</span>
<a href="#l9.332"></a><span id="l9.332">   // Take advantage of the fact that we're already sorted</span>
<a href="#l9.333"></a><span id="l9.333" class="difflineat">@@ -4685,17 +4701,17 @@ nsresult  nsMsgDBView::AddHdr(nsIMsgDBHd</span>
<a href="#l9.334"></a><span id="l9.334"> #endif</span>
<a href="#l9.335"></a><span id="l9.335"> </span>
<a href="#l9.336"></a><span id="l9.336">   if (resultIndex)</span>
<a href="#l9.337"></a><span id="l9.337">     *resultIndex = nsMsgViewIndex_None;</span>
<a href="#l9.338"></a><span id="l9.338"> </span>
<a href="#l9.339"></a><span id="l9.339">   if (!GetShowingIgnored())</span>
<a href="#l9.340"></a><span id="l9.340">   {</span>
<a href="#l9.341"></a><span id="l9.341">     nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l9.342"></a><span id="l9.342" class="difflineminus">-    m_db-&gt;GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(thread));</span>
<a href="#l9.343"></a><span id="l9.343" class="difflineplus">+    GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(thread));</span>
<a href="#l9.344"></a><span id="l9.344">     if (thread)</span>
<a href="#l9.345"></a><span id="l9.345">     {</span>
<a href="#l9.346"></a><span id="l9.346">       thread-&gt;GetFlags(&amp;flags);</span>
<a href="#l9.347"></a><span id="l9.347">       if (flags &amp; MSG_FLAG_IGNORED)</span>
<a href="#l9.348"></a><span id="l9.348">         return NS_OK;</span>
<a href="#l9.349"></a><span id="l9.349">     }</span>
<a href="#l9.350"></a><span id="l9.350"> </span>
<a href="#l9.351"></a><span id="l9.351">     PRBool ignored;</span>
<a href="#l9.352"></a><span id="l9.352" class="difflineat">@@ -4922,22 +4938,19 @@ nsresult nsMsgDBView::ListIdsInThread(ns</span>
<a href="#l9.353"></a><span id="l9.353">       // we'll use this rv to indicate there's something wrong with the db</span>
<a href="#l9.354"></a><span id="l9.354">       // though for now it probably won't get paid attention to.</span>
<a href="#l9.355"></a><span id="l9.355">       m_db-&gt;SetSummaryValid(PR_FALSE);</span>
<a href="#l9.356"></a><span id="l9.356">       rv = NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE;</span>
<a href="#l9.357"></a><span id="l9.357">     }</span>
<a href="#l9.358"></a><span id="l9.358">   }</span>
<a href="#l9.359"></a><span id="l9.359"> </span>
<a href="#l9.360"></a><span id="l9.360">   // We may have added too many elements (i.e., subthreads were cut)</span>
<a href="#l9.361"></a><span id="l9.361" class="difflineplus">+  // ### fix for cross folder view case.</span>
<a href="#l9.362"></a><span id="l9.362">   if (*pNumListed &lt; numChildren)</span>
<a href="#l9.363"></a><span id="l9.363" class="difflineminus">-  {</span>
<a href="#l9.364"></a><span id="l9.364" class="difflineminus">-    m_keys.RemoveElementsAt(viewIndex, numChildren - *pNumListed);</span>
<a href="#l9.365"></a><span id="l9.365" class="difflineminus">-    m_flags.RemoveElementsAt(viewIndex, numChildren - *pNumListed);</span>
<a href="#l9.366"></a><span id="l9.366" class="difflineminus">-    m_levels.RemoveElementsAt(viewIndex, numChildren - *pNumListed);</span>
<a href="#l9.367"></a><span id="l9.367" class="difflineminus">-  }</span>
<a href="#l9.368"></a><span id="l9.368" class="difflineplus">+    RemoveRows(viewIndex, numChildren - *pNumListed);</span>
<a href="#l9.369"></a><span id="l9.369">   return rv;</span>
<a href="#l9.370"></a><span id="l9.370"> }</span>
<a href="#l9.371"></a><span id="l9.371"> </span>
<a href="#l9.372"></a><span id="l9.372"> PRInt32 nsMsgDBView::FindLevelInThread(nsIMsgDBHdr *msgHdr, nsMsgViewIndex startOfThread, nsMsgViewIndex viewIndex)</span>
<a href="#l9.373"></a><span id="l9.373"> {</span>
<a href="#l9.374"></a><span id="l9.374">   nsCOMPtr &lt;nsIMsgDBHdr&gt; curMsgHdr = msgHdr;</span>
<a href="#l9.375"></a><span id="l9.375">   nsMsgKey msgKey;</span>
<a href="#l9.376"></a><span id="l9.376">   msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l9.377"></a><span id="l9.377" class="difflineat">@@ -4970,16 +4983,246 @@ PRInt32 nsMsgDBView::FindLevelInThread(n</span>
<a href="#l9.378"></a><span id="l9.378">       // need to update msgKey so the check for a msgHdr with matching</span>
<a href="#l9.379"></a><span id="l9.379">       // key+parentKey will work after first time through loop</span>
<a href="#l9.380"></a><span id="l9.380">       curMsgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l9.381"></a><span id="l9.381">     }</span>
<a href="#l9.382"></a><span id="l9.382">   }</span>
<a href="#l9.383"></a><span id="l9.383">   return 1;</span>
<a href="#l9.384"></a><span id="l9.384"> }</span>
<a href="#l9.385"></a><span id="l9.385"> </span>
<a href="#l9.386"></a><span id="l9.386" class="difflineplus">+// ### Can this be combined with GetIndexForThread??</span>
<a href="#l9.387"></a><span id="l9.387" class="difflineplus">+nsMsgViewIndex </span>
<a href="#l9.388"></a><span id="l9.388" class="difflineplus">+nsMsgDBView::GetThreadRootIndex(nsIMsgDBHdr *msgHdr)</span>
<a href="#l9.389"></a><span id="l9.389" class="difflineplus">+{</span>
<a href="#l9.390"></a><span id="l9.390" class="difflineplus">+  // Take advantage of the fact that we're already sorted</span>
<a href="#l9.391"></a><span id="l9.391" class="difflineplus">+  // and find the thread root via a binary search.</span>
<a href="#l9.392"></a><span id="l9.392" class="difflineplus">+</span>
<a href="#l9.393"></a><span id="l9.393" class="difflineplus">+  nsMsgViewIndex highIndex = m_keys.Length();</span>
<a href="#l9.394"></a><span id="l9.394" class="difflineplus">+  nsMsgViewIndex lowIndex = 0;</span>
<a href="#l9.395"></a><span id="l9.395" class="difflineplus">+  IdKeyPtr EntryInfo1, EntryInfo2;</span>
<a href="#l9.396"></a><span id="l9.396" class="difflineplus">+  EntryInfo1.key = nsnull;</span>
<a href="#l9.397"></a><span id="l9.397" class="difflineplus">+  EntryInfo2.key = nsnull;</span>
<a href="#l9.398"></a><span id="l9.398" class="difflineplus">+</span>
<a href="#l9.399"></a><span id="l9.399" class="difflineplus">+  nsresult rv;</span>
<a href="#l9.400"></a><span id="l9.400" class="difflineplus">+  PRUint16 maxLen;</span>
<a href="#l9.401"></a><span id="l9.401" class="difflineplus">+  eFieldType fieldType;</span>
<a href="#l9.402"></a><span id="l9.402" class="difflineplus">+  rv = GetFieldTypeAndLenForSort(m_sortType, &amp;maxLen, &amp;fieldType);</span>
<a href="#l9.403"></a><span id="l9.403" class="difflineplus">+  const void *pValue1 = &amp;EntryInfo1, *pValue2 = &amp;EntryInfo2;</span>
<a href="#l9.404"></a><span id="l9.404" class="difflineplus">+</span>
<a href="#l9.405"></a><span id="l9.405" class="difflineplus">+  int retStatus = 0;</span>
<a href="#l9.406"></a><span id="l9.406" class="difflineplus">+  msgHdr-&gt;GetMessageKey(&amp;EntryInfo1.id);</span>
<a href="#l9.407"></a><span id="l9.407" class="difflineplus">+  msgHdr-&gt;GetFolder(&amp;EntryInfo1.folder);</span>
<a href="#l9.408"></a><span id="l9.408" class="difflineplus">+  EntryInfo1.folder-&gt;Release();</span>
<a href="#l9.409"></a><span id="l9.409" class="difflineplus">+  //check if a custom column handler exists. If it does then grab it and pass it in</span>
<a href="#l9.410"></a><span id="l9.410" class="difflineplus">+  //to either GetCollationKey or GetLongField</span>
<a href="#l9.411"></a><span id="l9.411" class="difflineplus">+  nsIMsgCustomColumnHandler* colHandler = GetCurColumnHandlerFromDBInfo();</span>
<a href="#l9.412"></a><span id="l9.412" class="difflineplus">+</span>
<a href="#l9.413"></a><span id="l9.413" class="difflineplus">+  viewSortInfo comparisonContext;</span>
<a href="#l9.414"></a><span id="l9.414" class="difflineplus">+  comparisonContext.view = this;</span>
<a href="#l9.415"></a><span id="l9.415" class="difflineplus">+  comparisonContext.isSecondarySort = PR_FALSE;</span>
<a href="#l9.416"></a><span id="l9.416" class="difflineplus">+  comparisonContext.ascendingSort = (m_sortOrder == nsMsgViewSortOrder::ascending);</span>
<a href="#l9.417"></a><span id="l9.417" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDatabase&gt; hdrDB;</span>
<a href="#l9.418"></a><span id="l9.418" class="difflineplus">+  EntryInfo1.folder-&gt;GetMsgDatabase(nsnull, getter_AddRefs(hdrDB));</span>
<a href="#l9.419"></a><span id="l9.419" class="difflineplus">+  comparisonContext.db = hdrDB.get();</span>
<a href="#l9.420"></a><span id="l9.420" class="difflineplus">+  switch (fieldType)</span>
<a href="#l9.421"></a><span id="l9.421" class="difflineplus">+  {</span>
<a href="#l9.422"></a><span id="l9.422" class="difflineplus">+    case kCollationKey:</span>
<a href="#l9.423"></a><span id="l9.423" class="difflineplus">+      rv = GetCollationKey(msgHdr, m_sortType, &amp;EntryInfo1.key, &amp;EntryInfo1.dword, colHandler);</span>
<a href="#l9.424"></a><span id="l9.424" class="difflineplus">+      NS_ASSERTION(NS_SUCCEEDED(rv),&quot;failed to create collation key&quot;);</span>
<a href="#l9.425"></a><span id="l9.425" class="difflineplus">+      break;</span>
<a href="#l9.426"></a><span id="l9.426" class="difflineplus">+    case kU32:</span>
<a href="#l9.427"></a><span id="l9.427" class="difflineplus">+      if (m_sortType == nsMsgViewSortType::byId)</span>
<a href="#l9.428"></a><span id="l9.428" class="difflineplus">+        EntryInfo1.dword = EntryInfo1.id;</span>
<a href="#l9.429"></a><span id="l9.429" class="difflineplus">+      else</span>
<a href="#l9.430"></a><span id="l9.430" class="difflineplus">+        GetLongField(msgHdr, m_sortType, &amp;EntryInfo1.dword, colHandler);</span>
<a href="#l9.431"></a><span id="l9.431" class="difflineplus">+      break;</span>
<a href="#l9.432"></a><span id="l9.432" class="difflineplus">+    default:</span>
<a href="#l9.433"></a><span id="l9.433" class="difflineplus">+      return highIndex;</span>
<a href="#l9.434"></a><span id="l9.434" class="difflineplus">+  }</span>
<a href="#l9.435"></a><span id="l9.435" class="difflineplus">+  while (highIndex &gt; lowIndex)</span>
<a href="#l9.436"></a><span id="l9.436" class="difflineplus">+  {</span>
<a href="#l9.437"></a><span id="l9.437" class="difflineplus">+    nsMsgViewIndex tryIndex = (lowIndex + highIndex) / 2;</span>
<a href="#l9.438"></a><span id="l9.438" class="difflineplus">+    // need to adjust tryIndex if it's not a thread.</span>
<a href="#l9.439"></a><span id="l9.439" class="difflineplus">+    while (m_levels[tryIndex] &amp;&amp; tryIndex)</span>
<a href="#l9.440"></a><span id="l9.440" class="difflineplus">+      tryIndex--;</span>
<a href="#l9.441"></a><span id="l9.441" class="difflineplus">+</span>
<a href="#l9.442"></a><span id="l9.442" class="difflineplus">+    if (tryIndex &lt; lowIndex)</span>
<a href="#l9.443"></a><span id="l9.443" class="difflineplus">+    {</span>
<a href="#l9.444"></a><span id="l9.444" class="difflineplus">+      NS_ERROR(&quot;try index shouldn't be less than low index&quot;);</span>
<a href="#l9.445"></a><span id="l9.445" class="difflineplus">+      break;</span>
<a href="#l9.446"></a><span id="l9.446" class="difflineplus">+    }</span>
<a href="#l9.447"></a><span id="l9.447" class="difflineplus">+    EntryInfo2.id = m_keys[tryIndex];</span>
<a href="#l9.448"></a><span id="l9.448" class="difflineplus">+    GetFolderForViewIndex(tryIndex, &amp;EntryInfo2.folder);</span>
<a href="#l9.449"></a><span id="l9.449" class="difflineplus">+    EntryInfo2.folder-&gt;Release();</span>
<a href="#l9.450"></a><span id="l9.450" class="difflineplus">+    </span>
<a href="#l9.451"></a><span id="l9.451" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; tryHdr;</span>
<a href="#l9.452"></a><span id="l9.452" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l9.453"></a><span id="l9.453" class="difflineplus">+    // ### this should get the db from the folder...</span>
<a href="#l9.454"></a><span id="l9.454" class="difflineplus">+    GetDBForViewIndex(tryIndex, getter_AddRefs(db));</span>
<a href="#l9.455"></a><span id="l9.455" class="difflineplus">+    if (db)</span>
<a href="#l9.456"></a><span id="l9.456" class="difflineplus">+      rv = db-&gt;GetMsgHdrForKey(EntryInfo2.id, getter_AddRefs(tryHdr));</span>
<a href="#l9.457"></a><span id="l9.457" class="difflineplus">+    if (!tryHdr)</span>
<a href="#l9.458"></a><span id="l9.458" class="difflineplus">+      break;</span>
<a href="#l9.459"></a><span id="l9.459" class="difflineplus">+    if (tryHdr == msgHdr)</span>
<a href="#l9.460"></a><span id="l9.460" class="difflineplus">+    {</span>
<a href="#l9.461"></a><span id="l9.461" class="difflineplus">+      highIndex = tryIndex;</span>
<a href="#l9.462"></a><span id="l9.462" class="difflineplus">+      break;</span>
<a href="#l9.463"></a><span id="l9.463" class="difflineplus">+    }</span>
<a href="#l9.464"></a><span id="l9.464" class="difflineplus">+    if (fieldType == kCollationKey)</span>
<a href="#l9.465"></a><span id="l9.465" class="difflineplus">+    {</span>
<a href="#l9.466"></a><span id="l9.466" class="difflineplus">+      PR_FREEIF(EntryInfo2.key);</span>
<a href="#l9.467"></a><span id="l9.467" class="difflineplus">+      rv = GetCollationKey(tryHdr, m_sortType, &amp;EntryInfo2.key, &amp;EntryInfo2.dword, colHandler);</span>
<a href="#l9.468"></a><span id="l9.468" class="difflineplus">+      NS_ASSERTION(NS_SUCCEEDED(rv),&quot;failed to create collation key&quot;);</span>
<a href="#l9.469"></a><span id="l9.469" class="difflineplus">+      retStatus = FnSortIdKeyPtr(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l9.470"></a><span id="l9.470" class="difflineplus">+    }</span>
<a href="#l9.471"></a><span id="l9.471" class="difflineplus">+    else if (fieldType == kU32)</span>
<a href="#l9.472"></a><span id="l9.472" class="difflineplus">+    {</span>
<a href="#l9.473"></a><span id="l9.473" class="difflineplus">+      if (m_sortType == nsMsgViewSortType::byId)</span>
<a href="#l9.474"></a><span id="l9.474" class="difflineplus">+        EntryInfo2.dword = EntryInfo2.id;</span>
<a href="#l9.475"></a><span id="l9.475" class="difflineplus">+      else</span>
<a href="#l9.476"></a><span id="l9.476" class="difflineplus">+        GetLongField(tryHdr, m_sortType, &amp;EntryInfo2.dword, colHandler);</span>
<a href="#l9.477"></a><span id="l9.477" class="difflineplus">+      retStatus = FnSortIdUint32(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l9.478"></a><span id="l9.478" class="difflineplus">+    }</span>
<a href="#l9.479"></a><span id="l9.479" class="difflineplus">+    if (retStatus == 0)</span>
<a href="#l9.480"></a><span id="l9.480" class="difflineplus">+    {</span>
<a href="#l9.481"></a><span id="l9.481" class="difflineplus">+      highIndex = tryIndex;</span>
<a href="#l9.482"></a><span id="l9.482" class="difflineplus">+      break;</span>
<a href="#l9.483"></a><span id="l9.483" class="difflineplus">+    }</span>
<a href="#l9.484"></a><span id="l9.484" class="difflineplus">+</span>
<a href="#l9.485"></a><span id="l9.485" class="difflineplus">+    if (retStatus &lt; 0)</span>
<a href="#l9.486"></a><span id="l9.486" class="difflineplus">+    {</span>
<a href="#l9.487"></a><span id="l9.487" class="difflineplus">+      highIndex = tryIndex;</span>
<a href="#l9.488"></a><span id="l9.488" class="difflineplus">+      // we already made sure tryIndex was at a thread at the top of the loop.</span>
<a href="#l9.489"></a><span id="l9.489" class="difflineplus">+    }</span>
<a href="#l9.490"></a><span id="l9.490" class="difflineplus">+    else</span>
<a href="#l9.491"></a><span id="l9.491" class="difflineplus">+    {</span>
<a href="#l9.492"></a><span id="l9.492" class="difflineplus">+      lowIndex = tryIndex + 1;</span>
<a href="#l9.493"></a><span id="l9.493" class="difflineplus">+      while (lowIndex &lt; GetSize() &amp;&amp; m_levels[lowIndex])</span>
<a href="#l9.494"></a><span id="l9.494" class="difflineplus">+        lowIndex++;</span>
<a href="#l9.495"></a><span id="l9.495" class="difflineplus">+    }</span>
<a href="#l9.496"></a><span id="l9.496" class="difflineplus">+  }</span>
<a href="#l9.497"></a><span id="l9.497" class="difflineplus">+</span>
<a href="#l9.498"></a><span id="l9.498" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; resultHdr;</span>
<a href="#l9.499"></a><span id="l9.499" class="difflineplus">+  GetMsgHdrForViewIndex(highIndex, getter_AddRefs(resultHdr));</span>
<a href="#l9.500"></a><span id="l9.500" class="difflineplus">+</span>
<a href="#l9.501"></a><span id="l9.501" class="difflineplus">+  if (resultHdr != msgHdr)</span>
<a href="#l9.502"></a><span id="l9.502" class="difflineplus">+  {</span>
<a href="#l9.503"></a><span id="l9.503" class="difflineplus">+    NS_WARNING(&quot;didn't find hdr&quot;);</span>
<a href="#l9.504"></a><span id="l9.504" class="difflineplus">+    highIndex = FindHdr(msgHdr);</span>
<a href="#l9.505"></a><span id="l9.505" class="difflineplus">+#ifdef DEBUG_David_Bienvenu</span>
<a href="#l9.506"></a><span id="l9.506" class="difflineplus">+    if (highIndex != nsMsgViewIndex_None)</span>
<a href="#l9.507"></a><span id="l9.507" class="difflineplus">+    {</span>
<a href="#l9.508"></a><span id="l9.508" class="difflineplus">+      NS_WARNING(&quot;but find hdr did&quot;);</span>
<a href="#l9.509"></a><span id="l9.509" class="difflineplus">+      printf(&quot;level of found hdr = %d\n&quot;, m_levels[highIndex]);</span>
<a href="#l9.510"></a><span id="l9.510" class="difflineplus">+      ValidateSort();</span>
<a href="#l9.511"></a><span id="l9.511" class="difflineplus">+    }</span>
<a href="#l9.512"></a><span id="l9.512" class="difflineplus">+#endif</span>
<a href="#l9.513"></a><span id="l9.513" class="difflineplus">+    return highIndex;</span>
<a href="#l9.514"></a><span id="l9.514" class="difflineplus">+  }</span>
<a href="#l9.515"></a><span id="l9.515" class="difflineplus">+  PR_Free(EntryInfo1.key);</span>
<a href="#l9.516"></a><span id="l9.516" class="difflineplus">+  PR_Free(EntryInfo2.key);</span>
<a href="#l9.517"></a><span id="l9.517" class="difflineplus">+  return msgHdr == resultHdr ? highIndex : nsMsgViewIndex_None;</span>
<a href="#l9.518"></a><span id="l9.518" class="difflineplus">+}</span>
<a href="#l9.519"></a><span id="l9.519" class="difflineplus">+</span>
<a href="#l9.520"></a><span id="l9.520" class="difflineplus">+#ifdef DEBUG_David_Bienvenu</span>
<a href="#l9.521"></a><span id="l9.521" class="difflineplus">+</span>
<a href="#l9.522"></a><span id="l9.522" class="difflineplus">+void nsMsgDBView::InitEntryInfoForIndex(nsMsgViewIndex i, IdKeyPtr &amp;EntryInfo)</span>
<a href="#l9.523"></a><span id="l9.523" class="difflineplus">+{</span>
<a href="#l9.524"></a><span id="l9.524" class="difflineplus">+  EntryInfo.key = nsnull;</span>
<a href="#l9.525"></a><span id="l9.525" class="difflineplus">+</span>
<a href="#l9.526"></a><span id="l9.526" class="difflineplus">+  nsresult rv;</span>
<a href="#l9.527"></a><span id="l9.527" class="difflineplus">+  PRUint16 maxLen;</span>
<a href="#l9.528"></a><span id="l9.528" class="difflineplus">+  eFieldType fieldType;</span>
<a href="#l9.529"></a><span id="l9.529" class="difflineplus">+  rv = GetFieldTypeAndLenForSort(m_sortType, &amp;maxLen, &amp;fieldType);</span>
<a href="#l9.530"></a><span id="l9.530" class="difflineplus">+</span>
<a href="#l9.531"></a><span id="l9.531" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l9.532"></a><span id="l9.532" class="difflineplus">+  GetMsgHdrForViewIndex(i, getter_AddRefs(msgHdr));</span>
<a href="#l9.533"></a><span id="l9.533" class="difflineplus">+</span>
<a href="#l9.534"></a><span id="l9.534" class="difflineplus">+  msgHdr-&gt;GetMessageKey(&amp;EntryInfo.id);</span>
<a href="#l9.535"></a><span id="l9.535" class="difflineplus">+  msgHdr-&gt;GetFolder(&amp;EntryInfo.folder);</span>
<a href="#l9.536"></a><span id="l9.536" class="difflineplus">+  EntryInfo.folder-&gt;Release();</span>
<a href="#l9.537"></a><span id="l9.537" class="difflineplus">+  //check if a custom column handler exists. If it does then grab it and pass it in</span>
<a href="#l9.538"></a><span id="l9.538" class="difflineplus">+  //to either GetCollationKey or GetLongField</span>
<a href="#l9.539"></a><span id="l9.539" class="difflineplus">+  nsIMsgCustomColumnHandler* colHandler = GetCurColumnHandlerFromDBInfo();</span>
<a href="#l9.540"></a><span id="l9.540" class="difflineplus">+</span>
<a href="#l9.541"></a><span id="l9.541" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDatabase&gt; hdrDB;</span>
<a href="#l9.542"></a><span id="l9.542" class="difflineplus">+  EntryInfo.folder-&gt;GetMsgDatabase(nsnull, getter_AddRefs(hdrDB));</span>
<a href="#l9.543"></a><span id="l9.543" class="difflineplus">+  switch (fieldType)</span>
<a href="#l9.544"></a><span id="l9.544" class="difflineplus">+  {</span>
<a href="#l9.545"></a><span id="l9.545" class="difflineplus">+    case kCollationKey:</span>
<a href="#l9.546"></a><span id="l9.546" class="difflineplus">+      PR_FREEIF(EntryInfo.key);</span>
<a href="#l9.547"></a><span id="l9.547" class="difflineplus">+      rv = GetCollationKey(msgHdr, m_sortType, &amp;EntryInfo.key, &amp;EntryInfo.dword, colHandler);</span>
<a href="#l9.548"></a><span id="l9.548" class="difflineplus">+      NS_ASSERTION(NS_SUCCEEDED(rv),&quot;failed to create collation key&quot;);</span>
<a href="#l9.549"></a><span id="l9.549" class="difflineplus">+      break;</span>
<a href="#l9.550"></a><span id="l9.550" class="difflineplus">+    case kU32:</span>
<a href="#l9.551"></a><span id="l9.551" class="difflineplus">+      if (m_sortType == nsMsgViewSortType::byId)</span>
<a href="#l9.552"></a><span id="l9.552" class="difflineplus">+        EntryInfo.dword = EntryInfo.id;</span>
<a href="#l9.553"></a><span id="l9.553" class="difflineplus">+      else</span>
<a href="#l9.554"></a><span id="l9.554" class="difflineplus">+        GetLongField(msgHdr, m_sortType, &amp;EntryInfo.dword, colHandler);</span>
<a href="#l9.555"></a><span id="l9.555" class="difflineplus">+      break;</span>
<a href="#l9.556"></a><span id="l9.556" class="difflineplus">+    default:</span>
<a href="#l9.557"></a><span id="l9.557" class="difflineplus">+      NS_ERROR(&quot;invalid field type&quot;);</span>
<a href="#l9.558"></a><span id="l9.558" class="difflineplus">+  }</span>
<a href="#l9.559"></a><span id="l9.559" class="difflineplus">+}</span>
<a href="#l9.560"></a><span id="l9.560" class="difflineplus">+</span>
<a href="#l9.561"></a><span id="l9.561" class="difflineplus">+void nsMsgDBView::ValidateSort()</span>
<a href="#l9.562"></a><span id="l9.562" class="difflineplus">+{</span>
<a href="#l9.563"></a><span id="l9.563" class="difflineplus">+  IdKeyPtr EntryInfo1, EntryInfo2;</span>
<a href="#l9.564"></a><span id="l9.564" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; hdr1, hdr2;</span>
<a href="#l9.565"></a><span id="l9.565" class="difflineplus">+</span>
<a href="#l9.566"></a><span id="l9.566" class="difflineplus">+  PRUint16  maxLen;</span>
<a href="#l9.567"></a><span id="l9.567" class="difflineplus">+  eFieldType fieldType;</span>
<a href="#l9.568"></a><span id="l9.568" class="difflineplus">+  GetFieldTypeAndLenForSort(m_sortType, &amp;maxLen, &amp;fieldType);</span>
<a href="#l9.569"></a><span id="l9.569" class="difflineplus">+</span>
<a href="#l9.570"></a><span id="l9.570" class="difflineplus">+  viewSortInfo comparisonContext;</span>
<a href="#l9.571"></a><span id="l9.571" class="difflineplus">+  comparisonContext.view = this;</span>
<a href="#l9.572"></a><span id="l9.572" class="difflineplus">+  comparisonContext.isSecondarySort = PR_FALSE;</span>
<a href="#l9.573"></a><span id="l9.573" class="difflineplus">+  comparisonContext.ascendingSort = (m_sortOrder == nsMsgViewSortOrder::ascending);</span>
<a href="#l9.574"></a><span id="l9.574" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l9.575"></a><span id="l9.575" class="difflineplus">+  GetDBForViewIndex(0, getter_AddRefs(db));</span>
<a href="#l9.576"></a><span id="l9.576" class="difflineplus">+  // this is only for comparing collation keys - it could be any db.</span>
<a href="#l9.577"></a><span id="l9.577" class="difflineplus">+  comparisonContext.db = db.get();</span>
<a href="#l9.578"></a><span id="l9.578" class="difflineplus">+</span>
<a href="#l9.579"></a><span id="l9.579" class="difflineplus">+  for (nsMsgViewIndex i = 0; i &lt; m_keys.Length();)</span>
<a href="#l9.580"></a><span id="l9.580" class="difflineplus">+  {</span>
<a href="#l9.581"></a><span id="l9.581" class="difflineplus">+    // ignore non threads</span>
<a href="#l9.582"></a><span id="l9.582" class="difflineplus">+    if (m_levels[i])</span>
<a href="#l9.583"></a><span id="l9.583" class="difflineplus">+    {</span>
<a href="#l9.584"></a><span id="l9.584" class="difflineplus">+      i++;</span>
<a href="#l9.585"></a><span id="l9.585" class="difflineplus">+      continue;</span>
<a href="#l9.586"></a><span id="l9.586" class="difflineplus">+    }</span>
<a href="#l9.587"></a><span id="l9.587" class="difflineplus">+</span>
<a href="#l9.588"></a><span id="l9.588" class="difflineplus">+    // find next header.</span>
<a href="#l9.589"></a><span id="l9.589" class="difflineplus">+    nsMsgViewIndex j = i + 1;</span>
<a href="#l9.590"></a><span id="l9.590" class="difflineplus">+    while (j &lt; m_keys.Length() &amp;&amp; m_levels[j])</span>
<a href="#l9.591"></a><span id="l9.591" class="difflineplus">+      j++;</span>
<a href="#l9.592"></a><span id="l9.592" class="difflineplus">+    if (j == m_keys.Length())</span>
<a href="#l9.593"></a><span id="l9.593" class="difflineplus">+      break;</span>
<a href="#l9.594"></a><span id="l9.594" class="difflineplus">+</span>
<a href="#l9.595"></a><span id="l9.595" class="difflineplus">+    InitEntryInfoForIndex(i, EntryInfo1);</span>
<a href="#l9.596"></a><span id="l9.596" class="difflineplus">+    InitEntryInfoForIndex(j, EntryInfo2);</span>
<a href="#l9.597"></a><span id="l9.597" class="difflineplus">+    const void *pValue1 = &amp;EntryInfo1, *pValue2 = &amp;EntryInfo2;</span>
<a href="#l9.598"></a><span id="l9.598" class="difflineplus">+    int retStatus = 0;</span>
<a href="#l9.599"></a><span id="l9.599" class="difflineplus">+    if (fieldType == kCollationKey)</span>
<a href="#l9.600"></a><span id="l9.600" class="difflineplus">+      retStatus = FnSortIdKeyPtr(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l9.601"></a><span id="l9.601" class="difflineplus">+    else if (fieldType == kU32)</span>
<a href="#l9.602"></a><span id="l9.602" class="difflineplus">+      retStatus = FnSortIdUint32(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l9.603"></a><span id="l9.603" class="difflineplus">+</span>
<a href="#l9.604"></a><span id="l9.604" class="difflineplus">+    if (retStatus &amp;&amp; (retStatus &lt; 0) == (m_sortOrder == nsMsgViewSortOrder::ascending))</span>
<a href="#l9.605"></a><span id="l9.605" class="difflineplus">+    {</span>
<a href="#l9.606"></a><span id="l9.606" class="difflineplus">+      NS_ERROR(&quot;view not sorted correctly&quot;);</span>
<a href="#l9.607"></a><span id="l9.607" class="difflineplus">+      break;</span>
<a href="#l9.608"></a><span id="l9.608" class="difflineplus">+    }</span>
<a href="#l9.609"></a><span id="l9.609" class="difflineplus">+    // j is the new i.</span>
<a href="#l9.610"></a><span id="l9.610" class="difflineplus">+    i = j;</span>
<a href="#l9.611"></a><span id="l9.611" class="difflineplus">+  }</span>
<a href="#l9.612"></a><span id="l9.612" class="difflineplus">+}</span>
<a href="#l9.613"></a><span id="l9.613" class="difflineplus">+</span>
<a href="#l9.614"></a><span id="l9.614" class="difflineplus">+#endif</span>
<a href="#l9.615"></a><span id="l9.615" class="difflineplus">+</span>
<a href="#l9.616"></a><span id="l9.616"> nsresult nsMsgDBView::ListUnreadIdsInThread(nsIMsgThread *threadHdr, nsMsgViewIndex startOfThreadViewIndex, PRUint32 *pNumListed)</span>
<a href="#l9.617"></a><span id="l9.617"> {</span>
<a href="#l9.618"></a><span id="l9.618">   NS_ENSURE_ARG(threadHdr);</span>
<a href="#l9.619"></a><span id="l9.619">   // these children ids should be in thread order.</span>
<a href="#l9.620"></a><span id="l9.620">   nsMsgViewIndex viewIndex = startOfThreadViewIndex + 1;</span>
<a href="#l9.621"></a><span id="l9.621">   *pNumListed = 0;</span>
<a href="#l9.622"></a><span id="l9.622">   nsMsgKey topLevelMsgKey = m_keys[startOfThreadViewIndex];</span>
<a href="#l9.623"></a><span id="l9.623"> </span>
<a href="#l9.624"></a><span id="l9.624" class="difflineat">@@ -5043,17 +5286,17 @@ NS_IMETHODIMP nsMsgDBView::OnHdrFlagsCha</span>
<a href="#l9.625"></a><span id="l9.625">       // update the previous view, if any.</span>
<a href="#l9.626"></a><span id="l9.626">       OnExtraFlagChanged(index, aNewFlags);</span>
<a href="#l9.627"></a><span id="l9.627">       NoteChange(index, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l9.628"></a><span id="l9.628">     }</span>
<a href="#l9.629"></a><span id="l9.629"> </span>
<a href="#l9.630"></a><span id="l9.630">     PRUint32 deltaFlags = (aOldFlags ^ aNewFlags);</span>
<a href="#l9.631"></a><span id="l9.631">     if (deltaFlags &amp; (MSG_FLAG_READ | MSG_FLAG_NEW))</span>
<a href="#l9.632"></a><span id="l9.632">     {</span>
<a href="#l9.633"></a><span id="l9.633" class="difflineminus">-      nsMsgViewIndex threadIndex = ThreadIndexOfMsg(msgKey);</span>
<a href="#l9.634"></a><span id="l9.634" class="difflineplus">+      nsMsgViewIndex threadIndex = GetThreadIndex(index);</span>
<a href="#l9.635"></a><span id="l9.635">       // may need to fix thread counts</span>
<a href="#l9.636"></a><span id="l9.636">       if (threadIndex != nsMsgViewIndex_None &amp;&amp; threadIndex != index)</span>
<a href="#l9.637"></a><span id="l9.637">         NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l9.638"></a><span id="l9.638">     }</span>
<a href="#l9.639"></a><span id="l9.639">  }</span>
<a href="#l9.640"></a><span id="l9.640">   // don't need to propagate notifications, right?</span>
<a href="#l9.641"></a><span id="l9.641">   return NS_OK;</span>
<a href="#l9.642"></a><span id="l9.642"> }</span>
<a href="#l9.643"></a><span id="l9.643" class="difflineat">@@ -5478,17 +5721,17 @@ nsresult nsMsgDBView::NavigateFromPos(ns</span>
<a href="#l9.644"></a><span id="l9.644">               break;</span>
<a href="#l9.645"></a><span id="l9.645">             rv = FindPrevUnread(m_keys[startIndex], pResultKey,</span>
<a href="#l9.646"></a><span id="l9.646">                                 &amp;resultThreadKey);</span>
<a href="#l9.647"></a><span id="l9.647">             if (NS_SUCCEEDED(rv))</span>
<a href="#l9.648"></a><span id="l9.648">             {</span>
<a href="#l9.649"></a><span id="l9.649">                 *pResultIndex = FindViewIndex(*pResultKey);</span>
<a href="#l9.650"></a><span id="l9.650">                 if (*pResultKey != resultThreadKey &amp;&amp; (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l9.651"></a><span id="l9.651">                 {</span>
<a href="#l9.652"></a><span id="l9.652" class="difflineminus">-                    threadIndex  = ThreadIndexOfMsg(*pResultKey, nsMsgViewIndex_None);</span>
<a href="#l9.653"></a><span id="l9.653" class="difflineplus">+                    threadIndex  = GetThreadIndex(*pResultIndex);</span>
<a href="#l9.654"></a><span id="l9.654">                     if (*pResultIndex == nsMsgViewIndex_None)</span>
<a href="#l9.655"></a><span id="l9.655">                     {</span>
<a href="#l9.656"></a><span id="l9.656">                         nsCOMPtr &lt;nsIMsgThread&gt; threadHdr;</span>
<a href="#l9.657"></a><span id="l9.657">                         nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l9.658"></a><span id="l9.658">                         rv = m_db-&gt;GetMsgHdrForKey(*pResultKey, getter_AddRefs(msgHdr));</span>
<a href="#l9.659"></a><span id="l9.659">                         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.660"></a><span id="l9.660">                         rv = GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(threadHdr));</span>
<a href="#l9.661"></a><span id="l9.661">                         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.662"></a><span id="l9.662" class="difflineat">@@ -5984,17 +6227,17 @@ nsresult nsMsgDBView::SetSubthreadKilled</span>
<a href="#l9.663"></a><span id="l9.663"> </span>
<a href="#l9.664"></a><span id="l9.664">   rv = m_db-&gt;MarkHeaderKilled(header, ignored, this);</span>
<a href="#l9.665"></a><span id="l9.665">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l9.666"></a><span id="l9.666">  </span>
<a href="#l9.667"></a><span id="l9.667">   if (ignored)</span>
<a href="#l9.668"></a><span id="l9.668">   {</span>
<a href="#l9.669"></a><span id="l9.669">     nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l9.670"></a><span id="l9.670">     nsresult rv;</span>
<a href="#l9.671"></a><span id="l9.671" class="difflineminus">-    rv = m_db-&gt;GetThreadContainingMsgHdr(header, getter_AddRefs(thread));</span>
<a href="#l9.672"></a><span id="l9.672" class="difflineplus">+    rv = GetThreadContainingMsgHdr(header, getter_AddRefs(thread));</span>
<a href="#l9.673"></a><span id="l9.673">     if (NS_FAILED(rv))</span>
<a href="#l9.674"></a><span id="l9.674">       return NS_OK; // So we didn't mark threads read</span>
<a href="#l9.675"></a><span id="l9.675"> </span>
<a href="#l9.676"></a><span id="l9.676">     PRUint32 children, current;</span>
<a href="#l9.677"></a><span id="l9.677">     thread-&gt;GetNumChildren(&amp;children);</span>
<a href="#l9.678"></a><span id="l9.678"> </span>
<a href="#l9.679"></a><span id="l9.679">     nsMsgKey headKey;</span>
<a href="#l9.680"></a><span id="l9.680">     header-&gt;GetMessageKey(&amp;headKey);</span>
<a href="#l9.681"></a><span id="l9.681" class="difflineat">@@ -6492,17 +6735,17 @@ nsMsgDBView::SetSearchSession(nsIMsgSear</span>
<a href="#l9.682"></a><span id="l9.682">   NS_ASSERTION(PR_FALSE, &quot;should be overriden by child class&quot;);</span>
<a href="#l9.683"></a><span id="l9.683">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l9.684"></a><span id="l9.684"> }</span>
<a href="#l9.685"></a><span id="l9.685"> </span>
<a href="#l9.686"></a><span id="l9.686"> NS_IMETHODIMP</span>
<a href="#l9.687"></a><span id="l9.687"> nsMsgDBView::GetSupportsThreading(PRBool *aResult)</span>
<a href="#l9.688"></a><span id="l9.688"> {</span>
<a href="#l9.689"></a><span id="l9.689">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l9.690"></a><span id="l9.690" class="difflineminus">-  *aResult = PR_FALSE;</span>
<a href="#l9.691"></a><span id="l9.691" class="difflineplus">+  *aResult = PR_TRUE;</span>
<a href="#l9.692"></a><span id="l9.692">   return NS_OK;</span>
<a href="#l9.693"></a><span id="l9.693"> }</span>
<a href="#l9.694"></a><span id="l9.694"> </span>
<a href="#l9.695"></a><span id="l9.695"> NS_IMETHODIMP</span>
<a href="#l9.696"></a><span id="l9.696"> nsMsgDBView::FindIndexFromKey(nsMsgKey aMsgKey, PRBool aExpand, nsMsgViewIndex *aIndex)</span>
<a href="#l9.697"></a><span id="l9.697"> {</span>
<a href="#l9.698"></a><span id="l9.698">   NS_ENSURE_ARG_POINTER(aIndex);</span>
<a href="#l9.699"></a><span id="l9.699"> </span>
<a href="#l9.700"></a><span id="l9.700" class="difflineat">@@ -6547,8 +6790,55 @@ nsresult nsMsgDBView::InitDisplayFormats</span>
<a href="#l9.701"></a><span id="l9.701"> void nsMsgDBView::SetMRUTimeForFolder(nsIMsgFolder *folder)</span>
<a href="#l9.702"></a><span id="l9.702"> {</span>
<a href="#l9.703"></a><span id="l9.703">   PRUint32 seconds;</span>
<a href="#l9.704"></a><span id="l9.704">   PRTime2Seconds(PR_Now(), &amp;seconds);</span>
<a href="#l9.705"></a><span id="l9.705">   nsCAutoString nowStr;</span>
<a href="#l9.706"></a><span id="l9.706">   nowStr.AppendInt(seconds);</span>
<a href="#l9.707"></a><span id="l9.707">   folder-&gt;SetStringProperty(MRU_TIME_PROPERTY, nowStr);</span>
<a href="#l9.708"></a><span id="l9.708"> }</span>
<a href="#l9.709"></a><span id="l9.709" class="difflineplus">+</span>
<a href="#l9.710"></a><span id="l9.710" class="difflineplus">+</span>
<a href="#l9.711"></a><span id="l9.711" class="difflineplus">+NS_IMPL_ISUPPORTS1(nsMsgDBView::nsMsgViewHdrEnumerator, nsISimpleEnumerator)</span>
<a href="#l9.712"></a><span id="l9.712" class="difflineplus">+</span>
<a href="#l9.713"></a><span id="l9.713" class="difflineplus">+nsMsgDBView::nsMsgViewHdrEnumerator::nsMsgViewHdrEnumerator(nsMsgDBView *view)</span>
<a href="#l9.714"></a><span id="l9.714" class="difflineplus">+{</span>
<a href="#l9.715"></a><span id="l9.715" class="difflineplus">+  // we need to clone the view because the caller may clear the</span>
<a href="#l9.716"></a><span id="l9.716" class="difflineplus">+  // current view immediately. It also makes it easier to expand all</span>
<a href="#l9.717"></a><span id="l9.717" class="difflineplus">+  // if we're working on a copy.</span>
<a href="#l9.718"></a><span id="l9.718" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBView&gt; clonedView;</span>
<a href="#l9.719"></a><span id="l9.719" class="difflineplus">+  view-&gt;CloneDBView(nsnull, nsnull, nsnull, getter_AddRefs(clonedView));</span>
<a href="#l9.720"></a><span id="l9.720" class="difflineplus">+  m_view = static_cast&lt;nsMsgDBView*&gt;(clonedView.get());</span>
<a href="#l9.721"></a><span id="l9.721" class="difflineplus">+  // make sure we enumerate over collapsed threads by expanding all.</span>
<a href="#l9.722"></a><span id="l9.722" class="difflineplus">+  m_view-&gt;ExpandAll();</span>
<a href="#l9.723"></a><span id="l9.723" class="difflineplus">+  m_curHdrIndex = 0;</span>
<a href="#l9.724"></a><span id="l9.724" class="difflineplus">+}</span>
<a href="#l9.725"></a><span id="l9.725" class="difflineplus">+</span>
<a href="#l9.726"></a><span id="l9.726" class="difflineplus">+nsMsgDBView::nsMsgViewHdrEnumerator::~nsMsgViewHdrEnumerator()</span>
<a href="#l9.727"></a><span id="l9.727" class="difflineplus">+{</span>
<a href="#l9.728"></a><span id="l9.728" class="difflineplus">+}</span>
<a href="#l9.729"></a><span id="l9.729" class="difflineplus">+</span>
<a href="#l9.730"></a><span id="l9.730" class="difflineplus">+NS_IMETHODIMP nsMsgDBView::nsMsgViewHdrEnumerator::GetNext(nsISupports **aItem)</span>
<a href="#l9.731"></a><span id="l9.731" class="difflineplus">+{</span>
<a href="#l9.732"></a><span id="l9.732" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aItem);</span>
<a href="#l9.733"></a><span id="l9.733" class="difflineplus">+</span>
<a href="#l9.734"></a><span id="l9.734" class="difflineplus">+  if (m_curHdrIndex &gt;= m_view-&gt;GetSize())</span>
<a href="#l9.735"></a><span id="l9.735" class="difflineplus">+    return NS_ERROR_FAILURE;</span>
<a href="#l9.736"></a><span id="l9.736" class="difflineplus">+</span>
<a href="#l9.737"></a><span id="l9.737" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; nextHdr;</span>
<a href="#l9.738"></a><span id="l9.738" class="difflineplus">+</span>
<a href="#l9.739"></a><span id="l9.739" class="difflineplus">+  nsresult rv = m_view-&gt;GetMsgHdrForViewIndex(m_curHdrIndex++, getter_AddRefs(nextHdr));</span>
<a href="#l9.740"></a><span id="l9.740" class="difflineplus">+  NS_IF_ADDREF(*aItem = nextHdr);</span>
<a href="#l9.741"></a><span id="l9.741" class="difflineplus">+  return rv;</span>
<a href="#l9.742"></a><span id="l9.742" class="difflineplus">+}</span>
<a href="#l9.743"></a><span id="l9.743" class="difflineplus">+</span>
<a href="#l9.744"></a><span id="l9.744" class="difflineplus">+NS_IMETHODIMP nsMsgDBView::nsMsgViewHdrEnumerator::HasMoreElements(PRBool *aResult)</span>
<a href="#l9.745"></a><span id="l9.745" class="difflineplus">+{</span>
<a href="#l9.746"></a><span id="l9.746" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l9.747"></a><span id="l9.747" class="difflineplus">+  *aResult = m_curHdrIndex &lt; m_view-&gt;GetSize();</span>
<a href="#l9.748"></a><span id="l9.748" class="difflineplus">+  return NS_OK;</span>
<a href="#l9.749"></a><span id="l9.749" class="difflineplus">+}</span>
<a href="#l9.750"></a><span id="l9.750" class="difflineplus">+</span>
<a href="#l9.751"></a><span id="l9.751" class="difflineplus">+nsresult nsMsgDBView::GetViewEnumerator(nsISimpleEnumerator **enumerator)</span>
<a href="#l9.752"></a><span id="l9.752" class="difflineplus">+{</span>
<a href="#l9.753"></a><span id="l9.753" class="difflineplus">+  NS_IF_ADDREF(*enumerator = new nsMsgViewHdrEnumerator(this));</span>
<a href="#l9.754"></a><span id="l9.754" class="difflineplus">+  return (*enumerator) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l9.755"></a><span id="l9.755" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.h</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.h</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -215,16 +215,22 @@ protected:</span>
<a href="#l10.4"></a><span id="l10.4">   nsresult FetchSize(nsIMsgDBHdr * aHdr, nsAString &amp; aSizeString);</span>
<a href="#l10.5"></a><span id="l10.5">   nsresult FetchPriority(nsIMsgDBHdr *aHdr, nsAString &amp; aPriorityString);</span>
<a href="#l10.6"></a><span id="l10.6">   nsresult FetchLabel(nsIMsgDBHdr *aHdr, nsAString &amp; aLabelString);</span>
<a href="#l10.7"></a><span id="l10.7">   nsresult FetchTags(nsIMsgDBHdr *aHdr, nsAString &amp; aTagString);</span>
<a href="#l10.8"></a><span id="l10.8">   nsresult FetchKeywords(nsIMsgDBHdr *aHdr, nsACString &amp; keywordString);</span>
<a href="#l10.9"></a><span id="l10.9">   nsresult FetchAccount(nsIMsgDBHdr * aHdr, nsAString&amp; aAccount);</span>
<a href="#l10.10"></a><span id="l10.10">   nsresult CycleThreadedColumn(nsIDOMElement * aElement);</span>
<a href="#l10.11"></a><span id="l10.11"> </span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+  // The default enumerator is over the db, but things like</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+  // quick search views will enumerate just the displayed messages.</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+  virtual nsresult GetMessageEnumerator(nsISimpleEnumerator **enumerator);</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+  // this is a message enumerator that enumerates based on the view contents</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+  virtual nsresult GetViewEnumerator(nsISimpleEnumerator **enumerator);</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+</span>
<a href="#l10.18"></a><span id="l10.18">   // Save and Restore Selection are a pair of routines you should</span>
<a href="#l10.19"></a><span id="l10.19">   // use when performing an operation which is going to change the view</span>
<a href="#l10.20"></a><span id="l10.20">   // and you want to remember the selection. (i.e. for sorting). </span>
<a href="#l10.21"></a><span id="l10.21">   // Call SaveAndClearSelection and we'll give you an array of msg keys for</span>
<a href="#l10.22"></a><span id="l10.22">   // the current selection. We also freeze and clear the selection. </span>
<a href="#l10.23"></a><span id="l10.23">   // When you are done changing the view, </span>
<a href="#l10.24"></a><span id="l10.24">   // call RestoreSelection passing in the same array</span>
<a href="#l10.25"></a><span id="l10.25">   // and we'll restore the selection AND unfreeze selection in the UI.</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineat">@@ -241,41 +247,47 @@ protected:</span>
<a href="#l10.27"></a><span id="l10.27">   nsresult GenerateURIForMsgKey(nsMsgKey aMsgKey, nsIMsgFolder *folder, nsACString &amp;aURI);</span>
<a href="#l10.28"></a><span id="l10.28"> // routines used in building up view</span>
<a href="#l10.29"></a><span id="l10.29">   virtual PRBool WantsThisThread(nsIMsgThread * thread);</span>
<a href="#l10.30"></a><span id="l10.30">   virtual nsresult AddHdr(nsIMsgDBHdr *msgHdr, nsMsgViewIndex *resultIndex = nsnull);</span>
<a href="#l10.31"></a><span id="l10.31">   PRBool GetShowingIgnored() {return (m_viewFlags &amp; nsMsgViewFlagsType::kShowIgnored) != 0;}</span>
<a href="#l10.32"></a><span id="l10.32">   virtual nsresult OnNewHeader(nsIMsgDBHdr *aNewHdr, nsMsgKey parentKey, PRBool ensureListed);</span>
<a href="#l10.33"></a><span id="l10.33">   virtual nsMsgViewIndex GetInsertIndex(nsIMsgDBHdr *msgHdr);</span>
<a href="#l10.34"></a><span id="l10.34">   nsMsgViewIndex GetIndexForThread(nsIMsgDBHdr *hdr);</span>
<a href="#l10.35"></a><span id="l10.35" class="difflineplus">+  nsMsgViewIndex GetThreadRootIndex(nsIMsgDBHdr *msgHdr);</span>
<a href="#l10.36"></a><span id="l10.36">   virtual nsresult GetThreadContainingIndex(nsMsgViewIndex index, nsIMsgThread **thread);</span>
<a href="#l10.37"></a><span id="l10.37">   virtual nsresult GetMsgHdrForViewIndex(nsMsgViewIndex index, nsIMsgDBHdr **msgHdr);</span>
<a href="#l10.38"></a><span id="l10.38" class="difflineminus">-  nsMsgViewIndex FindIndexForThread(nsIMsgDBHdr *msgHdr, PRBool newThread);</span>
<a href="#l10.39"></a><span id="l10.39" class="difflineplus">+  // given a view index, return the index of the top-level msg in the thread.</span>
<a href="#l10.40"></a><span id="l10.40" class="difflineplus">+  nsMsgViewIndex GetThreadIndex(nsMsgViewIndex msgIndex);</span>
<a href="#l10.41"></a><span id="l10.41"> </span>
<a href="#l10.42"></a><span id="l10.42">   virtual void InsertMsgHdrAt(nsMsgViewIndex index, nsIMsgDBHdr *hdr,</span>
<a href="#l10.43"></a><span id="l10.43">                               nsMsgKey msgKey, PRUint32 flags, PRUint32 level);</span>
<a href="#l10.44"></a><span id="l10.44">   virtual void SetMsgHdrAt(nsIMsgDBHdr *hdr, nsMsgViewIndex index, </span>
<a href="#l10.45"></a><span id="l10.45">                               nsMsgKey msgKey, PRUint32 flags, PRUint32 level);</span>
<a href="#l10.46"></a><span id="l10.46">   virtual PRBool InsertEmptyRows(nsMsgViewIndex viewIndex, PRInt32 numRows);</span>
<a href="#l10.47"></a><span id="l10.47">   virtual void RemoveRows(nsMsgViewIndex viewIndex, PRInt32 numRows);</span>
<a href="#l10.48"></a><span id="l10.48">   nsresult ToggleExpansion(nsMsgViewIndex index, PRUint32 *numChanged);</span>
<a href="#l10.49"></a><span id="l10.49">   nsresult ExpandByIndex(nsMsgViewIndex index, PRUint32 *pNumExpanded);</span>
<a href="#l10.50"></a><span id="l10.50">   nsresult CollapseByIndex(nsMsgViewIndex index, PRUint32 *pNumCollapsed);</span>
<a href="#l10.51"></a><span id="l10.51">   nsresult ExpandAll();</span>
<a href="#l10.52"></a><span id="l10.52">   nsresult CollapseAll();</span>
<a href="#l10.53"></a><span id="l10.53">   nsresult ExpandAndSelectThread();</span>
<a href="#l10.54"></a><span id="l10.54"> </span>
<a href="#l10.55"></a><span id="l10.55">   // helper routines for thread expanding and collapsing.</span>
<a href="#l10.56"></a><span id="l10.56" class="difflineminus">-  nsresult		GetThreadCount(nsMsgKey messageKey, PRUint32 *pThreadCount);</span>
<a href="#l10.57"></a><span id="l10.57" class="difflineplus">+  nsresult GetThreadCount(nsMsgViewIndex viewIndex, PRUint32 *pThreadCount);</span>
<a href="#l10.58"></a><span id="l10.58">   nsMsgViewIndex GetIndexOfFirstDisplayedKeyInThread(nsIMsgThread *threadHdr);</span>
<a href="#l10.59"></a><span id="l10.59">   virtual nsresult GetFirstMessageHdrToDisplayInThread(nsIMsgThread *threadHdr, nsIMsgDBHdr **result);</span>
<a href="#l10.60"></a><span id="l10.60">   virtual nsMsgViewIndex ThreadIndexOfMsg(nsMsgKey msgKey, </span>
<a href="#l10.61"></a><span id="l10.61"> 				  nsMsgViewIndex msgIndex = nsMsgViewIndex_None,</span>
<a href="#l10.62"></a><span id="l10.62"> 				  PRInt32 *pThreadCount = nsnull,</span>
<a href="#l10.63"></a><span id="l10.63"> 				  PRUint32 *pFlags = nsnull);</span>
<a href="#l10.64"></a><span id="l10.64" class="difflineplus">+  nsMsgViewIndex ThreadIndexOfMsgHdr(nsIMsgDBHdr *msgHdr, </span>
<a href="#l10.65"></a><span id="l10.65" class="difflineplus">+                                 nsMsgViewIndex msgIndex = nsMsgViewIndex_None,</span>
<a href="#l10.66"></a><span id="l10.66" class="difflineplus">+                                 PRInt32 *pThreadCount = nsnull,</span>
<a href="#l10.67"></a><span id="l10.67" class="difflineplus">+                                 PRUint32 *pFlags = nsnull);</span>
<a href="#l10.68"></a><span id="l10.68">   virtual nsresult GetThreadContainingMsgHdr(nsIMsgDBHdr *msgHdr, nsIMsgThread **pThread);</span>
<a href="#l10.69"></a><span id="l10.69">   nsMsgKey GetKeyOfFirstMsgInThread(nsMsgKey key);</span>
<a href="#l10.70"></a><span id="l10.70">   PRInt32 CountExpandedThread(nsMsgViewIndex index);</span>
<a href="#l10.71"></a><span id="l10.71">   virtual  nsresult ExpansionDelta(nsMsgViewIndex index, PRInt32 *expansionDelta);</span>
<a href="#l10.72"></a><span id="l10.72">   void ReverseSort();</span>
<a href="#l10.73"></a><span id="l10.73">   void ReverseThreads();</span>
<a href="#l10.74"></a><span id="l10.74">   nsresult SaveSortInfo(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder);</span>
<a href="#l10.75"></a><span id="l10.75">   nsresult PersistFolderInfo(nsIDBFolderInfo **dbFolderInfo);</span>
<a href="#l10.76"></a><span id="l10.76" class="difflineat">@@ -457,24 +469,43 @@ protected:</span>
<a href="#l10.77"></a><span id="l10.77">   </span>
<a href="#l10.78"></a><span id="l10.78">   //these hold pointers (and IDs) for the nsIMsgCustomColumnHandler object that constitutes the custom column handler</span>
<a href="#l10.79"></a><span id="l10.79">   nsCOMArray &lt;nsIMsgCustomColumnHandler&gt; m_customColumnHandlers;</span>
<a href="#l10.80"></a><span id="l10.80">   nsStringArray m_customColumnHandlerIDs;</span>
<a href="#l10.81"></a><span id="l10.81">   </span>
<a href="#l10.82"></a><span id="l10.82">   nsIMsgCustomColumnHandler* GetColumnHandler(const PRUnichar*);</span>
<a href="#l10.83"></a><span id="l10.83">   nsIMsgCustomColumnHandler* GetCurColumnHandlerFromDBInfo();</span>
<a href="#l10.84"></a><span id="l10.84">   void GetCurCustomColumn(nsString &amp;colID);</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineplus">+#ifdef DEBUG_David_Bienvenu</span>
<a href="#l10.86"></a><span id="l10.86" class="difflineplus">+void InitEntryInfoForIndex(nsMsgViewIndex i, IdKeyPtr &amp;EntryInfo);</span>
<a href="#l10.87"></a><span id="l10.87" class="difflineplus">+void ValidateSort();</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineplus">+#endif</span>
<a href="#l10.89"></a><span id="l10.89"> </span>
<a href="#l10.90"></a><span id="l10.90"> protected:</span>
<a href="#l10.91"></a><span id="l10.91">   static nsresult   InitDisplayFormats();</span>
<a href="#l10.92"></a><span id="l10.92"> </span>
<a href="#l10.93"></a><span id="l10.93"> private:</span>
<a href="#l10.94"></a><span id="l10.94">   static nsDateFormatSelector  m_dateFormatDefault;</span>
<a href="#l10.95"></a><span id="l10.95">   static nsDateFormatSelector  m_dateFormatThisWeek;</span>
<a href="#l10.96"></a><span id="l10.96">   static nsDateFormatSelector  m_dateFormatToday;</span>
<a href="#l10.97"></a><span id="l10.97">   PRBool ServerSupportsFilterAfterTheFact();</span>
<a href="#l10.98"></a><span id="l10.98"> </span>
<a href="#l10.99"></a><span id="l10.99">   nsresult PerformActionsOnJunkMsgs();</span>
<a href="#l10.100"></a><span id="l10.100">   nsresult DetermineActionsForJunkMsgs(PRBool* movingJunkMessages, PRBool* markingJunkMessagesRead, nsIMsgFolder** junkTargetFolder);</span>
<a href="#l10.101"></a><span id="l10.101"> </span>
<a href="#l10.102"></a><span id="l10.102" class="difflineplus">+  class nsMsgViewHdrEnumerator : public nsISimpleEnumerator </span>
<a href="#l10.103"></a><span id="l10.103" class="difflineplus">+  {</span>
<a href="#l10.104"></a><span id="l10.104" class="difflineplus">+  public:</span>
<a href="#l10.105"></a><span id="l10.105" class="difflineplus">+    NS_DECL_ISUPPORTS</span>
<a href="#l10.106"></a><span id="l10.106" class="difflineplus">+</span>
<a href="#l10.107"></a><span id="l10.107" class="difflineplus">+    // nsISimpleEnumerator methods:</span>
<a href="#l10.108"></a><span id="l10.108" class="difflineplus">+    NS_DECL_NSISIMPLEENUMERATOR</span>
<a href="#l10.109"></a><span id="l10.109" class="difflineplus">+</span>
<a href="#l10.110"></a><span id="l10.110" class="difflineplus">+    // nsMsgThreadEnumerator methods:</span>
<a href="#l10.111"></a><span id="l10.111" class="difflineplus">+    nsMsgViewHdrEnumerator(nsMsgDBView *view);</span>
<a href="#l10.112"></a><span id="l10.112" class="difflineplus">+    ~nsMsgViewHdrEnumerator();</span>
<a href="#l10.113"></a><span id="l10.113" class="difflineplus">+</span>
<a href="#l10.114"></a><span id="l10.114" class="difflineplus">+    nsRefPtr &lt;nsMsgDBView&gt; m_view;</span>
<a href="#l10.115"></a><span id="l10.115" class="difflineplus">+    nsMsgViewIndex m_curHdrIndex;</span>
<a href="#l10.116"></a><span id="l10.116" class="difflineplus">+  };</span>
<a href="#l10.117"></a><span id="l10.117"> };</span>
<a href="#l10.118"></a><span id="l10.118"> </span>
<a href="#l10.119"></a><span id="l10.119"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/base/src/nsMsgGroupThread.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgGroupThread.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l11.4"></a><span id="l11.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l11.5"></a><span id="l11.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l11.6"></a><span id="l11.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l11.7"></a><span id="l11.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l11.8"></a><span id="l11.8">  *</span>
<a href="#l11.9"></a><span id="l11.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l11.10"></a><span id="l11.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l11.11"></a><span id="l11.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l11.12"></a><span id="l11.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l11.13"></a><span id="l11.13">  *</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineat">@@ -127,52 +127,16 @@ NS_IMETHODIMP nsMsgGroupThread::GetNumUn</span>
<a href="#l11.15"></a><span id="l11.15"> </span>
<a href="#l11.16"></a><span id="l11.16"> void nsMsgGroupThread::InsertMsgHdrAt(nsMsgViewIndex index, nsIMsgDBHdr *hdr)</span>
<a href="#l11.17"></a><span id="l11.17"> {</span>
<a href="#l11.18"></a><span id="l11.18">   nsMsgKey msgKey;</span>
<a href="#l11.19"></a><span id="l11.19">   hdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l11.20"></a><span id="l11.20">   m_keys.InsertElementAt(index, msgKey);</span>
<a href="#l11.21"></a><span id="l11.21"> }</span>
<a href="#l11.22"></a><span id="l11.22"> </span>
<a href="#l11.23"></a><span id="l11.23" class="difflineminus">-#if 0</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineminus">-nsresult nsMsgGroupThread::RerootThread(nsIMsgDBHdr *newParentOfOldRoot, nsIMsgDBHdr *oldRoot, nsIDBChangeAnnouncer *announcer)</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineminus">-{</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineminus">-  nsCOMPtr &lt;nsIMsgDBHdr&gt; ancestorHdr = newParentOfOldRoot;</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineminus">-  nsMsgKey newRoot;</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineminus">-  newParentOfOldRoot-&gt;GetMessageKey(&amp;newRoot);</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineminus">-</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineminus">-  nsMsgKey newHdrAncestor;</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineminus">-  nsresult rv = NS_OK;</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineminus">-  // loop trying to find the oldest ancestor of this msg</span>
<a href="#l11.33"></a><span id="l11.33" class="difflineminus">-  // that is a parent of the root. The oldest ancestor will</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineminus">-  // become the root of the thread.</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineminus">-  do </span>
<a href="#l11.36"></a><span id="l11.36" class="difflineminus">-  {</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineminus">-    ancestorHdr-&gt;GetThreadParent(&amp;newHdrAncestor);</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineminus">-    if (newHdrAncestor != nsMsgKey_None &amp;&amp; newHdrAncestor != m_threadRootKey &amp;&amp; newHdrAncestor != newRoot)</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineminus">-    {</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineminus">-      newRoot = newHdrAncestor;</span>
<a href="#l11.41"></a><span id="l11.41" class="difflineminus">-      rv = m_db-&gt;GetMsgHdrForKey(newRoot, getter_AddRefs(ancestorHdr));</span>
<a href="#l11.42"></a><span id="l11.42" class="difflineminus">-    }</span>
<a href="#l11.43"></a><span id="l11.43" class="difflineminus">-  }</span>
<a href="#l11.44"></a><span id="l11.44" class="difflineminus">-  while (NS_SUCCEEDED(rv) &amp;&amp; ancestorHdr &amp;&amp; newHdrAncestor != nsMsgKey_None &amp;&amp; newHdrAncestor != m_threadRootKey</span>
<a href="#l11.45"></a><span id="l11.45" class="difflineminus">-    &amp;&amp; newHdrAncestor != newRoot);</span>
<a href="#l11.46"></a><span id="l11.46" class="difflineminus">-  m_threadRootKey = newRoot;</span>
<a href="#l11.47"></a><span id="l11.47" class="difflineminus">-//  ReparentNonReferenceChildrenOf(oldRoot, newRoot, announcer);</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineminus">-  if (ancestorHdr)</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineminus">-  {</span>
<a href="#l11.50"></a><span id="l11.50" class="difflineminus">-    // move the  root hdr to pos 0 by removing it and adding it at 0.</span>
<a href="#l11.51"></a><span id="l11.51" class="difflineminus">-    m_keys.RemoveElement(newRoot);</span>
<a href="#l11.52"></a><span id="l11.52" class="difflineminus">-    m_keys.InsertElementAt(0, newRoot);</span>
<a href="#l11.53"></a><span id="l11.53" class="difflineminus">-    ancestorHdr-&gt;SetThreadParent(nsMsgKey_None);</span>
<a href="#l11.54"></a><span id="l11.54" class="difflineminus">-  }</span>
<a href="#l11.55"></a><span id="l11.55" class="difflineminus">-  return rv;</span>
<a href="#l11.56"></a><span id="l11.56" class="difflineminus">-}</span>
<a href="#l11.57"></a><span id="l11.57" class="difflineminus">-#endif</span>
<a href="#l11.58"></a><span id="l11.58" class="difflineminus">-</span>
<a href="#l11.59"></a><span id="l11.59"> NS_IMETHODIMP nsMsgGroupThread::AddChild(nsIMsgDBHdr *child, nsIMsgDBHdr *inReplyTo, PRBool threadInThread, </span>
<a href="#l11.60"></a><span id="l11.60">                                     nsIDBChangeAnnouncer *announcer)</span>
<a href="#l11.61"></a><span id="l11.61"> {</span>
<a href="#l11.62"></a><span id="l11.62">   NS_ASSERTION(PR_FALSE, &quot;shouldn't call this&quot;);</span>
<a href="#l11.63"></a><span id="l11.63">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l11.64"></a><span id="l11.64"> }</span>
<a href="#l11.65"></a><span id="l11.65"> </span>
<a href="#l11.66"></a><span id="l11.66"> nsMsgViewIndex nsMsgGroupThread::AddMsgHdrInDateOrder(nsIMsgDBHdr *child, nsMsgDBView *view)</span>
<a href="#l11.67"></a><span id="l11.67" class="difflineat">@@ -235,45 +199,16 @@ nsresult nsMsgGroupThread::AddChildFromG</span>
<a href="#l11.68"></a><span id="l11.68">     ChangeUnreadChildCount(1);</span>
<a href="#l11.69"></a><span id="l11.69"> </span>
<a href="#l11.70"></a><span id="l11.70">   return AddMsgHdrInDateOrder(child, view);</span>
<a href="#l11.71"></a><span id="l11.71"> }</span>
<a href="#l11.72"></a><span id="l11.72"> </span>
<a href="#l11.73"></a><span id="l11.73"> nsresult nsMsgGroupThread::ReparentNonReferenceChildrenOf(nsIMsgDBHdr *topLevelHdr, nsMsgKey newParentKey,</span>
<a href="#l11.74"></a><span id="l11.74">                                                             nsIDBChangeAnnouncer *announcer)</span>
<a href="#l11.75"></a><span id="l11.75"> {</span>
<a href="#l11.76"></a><span id="l11.76" class="difflineminus">-#if 0</span>
<a href="#l11.77"></a><span id="l11.77" class="difflineminus">-  nsCOMPtr &lt;nsIMsgDBHdr&gt; curHdr;</span>
<a href="#l11.78"></a><span id="l11.78" class="difflineminus">-  PRUint32 numChildren;</span>
<a href="#l11.79"></a><span id="l11.79" class="difflineminus">-  PRUint32 childIndex = 0;</span>
<a href="#l11.80"></a><span id="l11.80" class="difflineminus">-  </span>
<a href="#l11.81"></a><span id="l11.81" class="difflineminus">-  GetNumChildren(&amp;numChildren);</span>
<a href="#l11.82"></a><span id="l11.82" class="difflineminus">-  for (childIndex = 0; childIndex &lt; numChildren; childIndex++)</span>
<a href="#l11.83"></a><span id="l11.83" class="difflineminus">-  {</span>
<a href="#l11.84"></a><span id="l11.84" class="difflineminus">-    nsMsgKey msgKey;</span>
<a href="#l11.85"></a><span id="l11.85" class="difflineminus">-    </span>
<a href="#l11.86"></a><span id="l11.86" class="difflineminus">-    topLevelHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l11.87"></a><span id="l11.87" class="difflineminus">-    nsresult ret = GetChildHdrAt(childIndex, getter_AddRefs(curHdr));</span>
<a href="#l11.88"></a><span id="l11.88" class="difflineminus">-    if (NS_SUCCEEDED(ret) &amp;&amp; curHdr)</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineminus">-    {</span>
<a href="#l11.90"></a><span id="l11.90" class="difflineminus">-      nsMsgKey oldThreadParent, curHdrKey;</span>
<a href="#l11.91"></a><span id="l11.91" class="difflineminus">-      nsIMsgDBHdr *curMsgHdr = curHdr;</span>
<a href="#l11.92"></a><span id="l11.92" class="difflineminus">-      curHdr-&gt;GetThreadParent(&amp;oldThreadParent);</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineminus">-      curHdr-&gt;GetMessageKey(&amp;curHdrKey);</span>
<a href="#l11.94"></a><span id="l11.94" class="difflineminus">-      if (oldThreadParent == msgKey &amp;&amp; curHdrKey != newParentKey &amp;&amp; topLevelMsgHdr-&gt;IsParentOf(curHdr))</span>
<a href="#l11.95"></a><span id="l11.95" class="difflineminus">-      {</span>
<a href="#l11.96"></a><span id="l11.96" class="difflineminus">-        curHdr-&gt;GetThreadParent(&amp;oldThreadParent);</span>
<a href="#l11.97"></a><span id="l11.97" class="difflineminus">-        curHdr-&gt;SetThreadParent(newParentKey);</span>
<a href="#l11.98"></a><span id="l11.98" class="difflineminus">-        // OK, this is a reparenting - need to send notification</span>
<a href="#l11.99"></a><span id="l11.99" class="difflineminus">-        if (announcer)</span>
<a href="#l11.100"></a><span id="l11.100" class="difflineminus">-          announcer-&gt;NotifyParentChangedAll(curHdrKey, oldThreadParent, newParentKey, nsnull);</span>
<a href="#l11.101"></a><span id="l11.101" class="difflineminus">-      }</span>
<a href="#l11.102"></a><span id="l11.102" class="difflineminus">-    }</span>
<a href="#l11.103"></a><span id="l11.103" class="difflineminus">-  }</span>
<a href="#l11.104"></a><span id="l11.104" class="difflineminus">-#endif</span>
<a href="#l11.105"></a><span id="l11.105">   return NS_OK;</span>
<a href="#l11.106"></a><span id="l11.106"> }</span>
<a href="#l11.107"></a><span id="l11.107"> </span>
<a href="#l11.108"></a><span id="l11.108"> NS_IMETHODIMP nsMsgGroupThread::GetChildKeyAt(PRInt32 aIndex, nsMsgKey *aResult)</span>
<a href="#l11.109"></a><span id="l11.109"> {</span>
<a href="#l11.110"></a><span id="l11.110">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l11.111"></a><span id="l11.111">   if (aIndex &gt;= m_keys.Length())</span>
<a href="#l11.112"></a><span id="l11.112">     return NS_ERROR_INVALID_ARG;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/base/src/nsMsgGroupThread.h</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgGroupThread.h</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l12.4"></a><span id="l12.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l12.5"></a><span id="l12.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l12.6"></a><span id="l12.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l12.7"></a><span id="l12.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l12.8"></a><span id="l12.8">  *</span>
<a href="#l12.9"></a><span id="l12.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l12.10"></a><span id="l12.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l12.11"></a><span id="l12.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l12.12"></a><span id="l12.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l12.13"></a><span id="l12.13">  *</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/base/src/nsMsgGroupView.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgGroupView.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l13.4"></a><span id="l13.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l13.5"></a><span id="l13.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l13.6"></a><span id="l13.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l13.7"></a><span id="l13.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l13.8"></a><span id="l13.8">  *</span>
<a href="#l13.9"></a><span id="l13.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l13.10"></a><span id="l13.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l13.11"></a><span id="l13.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l13.12"></a><span id="l13.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l13.13"></a><span id="l13.13">  *</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineat">@@ -74,16 +74,20 @@ NS_IMETHODIMP nsMsgGroupView::Open(nsIMs</span>
<a href="#l13.15"></a><span id="l13.15">   rv = m_db-&gt;EnumerateMessages(getter_AddRefs(headers));</span>
<a href="#l13.16"></a><span id="l13.16">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l13.17"></a><span id="l13.17"> </span>
<a href="#l13.18"></a><span id="l13.18">   return OpenWithHdrs(headers, aSortType, aSortOrder, aViewFlags, aCount);</span>
<a href="#l13.19"></a><span id="l13.19"> }</span>
<a href="#l13.20"></a><span id="l13.20"> </span>
<a href="#l13.21"></a><span id="l13.21"> void nsMsgGroupView::InternalClose()</span>
<a href="#l13.22"></a><span id="l13.22"> {</span>
<a href="#l13.23"></a><span id="l13.23" class="difflineplus">+  // nothing to do if we're not grouped.</span>
<a href="#l13.24"></a><span id="l13.24" class="difflineplus">+  if (!(m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l13.25"></a><span id="l13.25" class="difflineplus">+    return;</span>
<a href="#l13.26"></a><span id="l13.26" class="difflineplus">+</span>
<a href="#l13.27"></a><span id="l13.27">   PRBool rcvDate = PR_FALSE;</span>
<a href="#l13.28"></a><span id="l13.28"> </span>
<a href="#l13.29"></a><span id="l13.29">   if (m_sortType == nsMsgViewSortType::byReceived)</span>
<a href="#l13.30"></a><span id="l13.30">     rcvDate = PR_TRUE;</span>
<a href="#l13.31"></a><span id="l13.31">   if (m_db &amp;&amp; (m_sortType == nsMsgViewSortType::byDate) || (m_sortType == nsMsgViewSortType::byReceived))</span>
<a href="#l13.32"></a><span id="l13.32">   {</span>
<a href="#l13.33"></a><span id="l13.33">     nsCOMPtr &lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l13.34"></a><span id="l13.34">     m_db-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineat">@@ -111,17 +115,17 @@ void nsMsgGroupView::InternalClose()</span>
<a href="#l13.36"></a><span id="l13.36">     }</span>
<a href="#l13.37"></a><span id="l13.37">   }</span>
<a href="#l13.38"></a><span id="l13.38">   m_groupsTable.Clear();</span>
<a href="#l13.39"></a><span id="l13.39"> }</span>
<a href="#l13.40"></a><span id="l13.40"> </span>
<a href="#l13.41"></a><span id="l13.41"> NS_IMETHODIMP nsMsgGroupView::Close()</span>
<a href="#l13.42"></a><span id="l13.42"> {</span>
<a href="#l13.43"></a><span id="l13.43">   InternalClose();</span>
<a href="#l13.44"></a><span id="l13.44" class="difflineminus">-  return nsMsgThreadedDBView::Close();</span>
<a href="#l13.45"></a><span id="l13.45" class="difflineplus">+  return nsMsgDBView::Close();</span>
<a href="#l13.46"></a><span id="l13.46"> }</span>
<a href="#l13.47"></a><span id="l13.47"> </span>
<a href="#l13.48"></a><span id="l13.48"> // Set rcvDate to PR_TRUE to get the Received: date instead of the Date: date.</span>
<a href="#l13.49"></a><span id="l13.49"> nsresult nsMsgGroupView::GetAgeBucketValue(nsIMsgDBHdr *aMsgHdr, PRUint32 * aAgeBucket, PRBool rcvDate)</span>
<a href="#l13.50"></a><span id="l13.50"> {</span>
<a href="#l13.51"></a><span id="l13.51">   NS_ENSURE_ARG_POINTER(aMsgHdr);</span>
<a href="#l13.52"></a><span id="l13.52">   NS_ENSURE_ARG_POINTER(aAgeBucket);</span>
<a href="#l13.53"></a><span id="l13.53"> </span>
<a href="#l13.54"></a><span id="l13.54" class="difflineat">@@ -284,16 +288,21 @@ nsresult nsMsgGroupView::HashHdr(nsIMsgD</span>
<a href="#l13.55"></a><span id="l13.55">     }</span>
<a href="#l13.56"></a><span id="l13.56">     default:</span>
<a href="#l13.57"></a><span id="l13.57">       NS_ASSERTION(PR_FALSE, &quot;no hash key for this type&quot;);</span>
<a href="#l13.58"></a><span id="l13.58">       rv = NS_ERROR_FAILURE;</span>
<a href="#l13.59"></a><span id="l13.59">   }</span>
<a href="#l13.60"></a><span id="l13.60">   return rv;</span>
<a href="#l13.61"></a><span id="l13.61"> }</span>
<a href="#l13.62"></a><span id="l13.62"> </span>
<a href="#l13.63"></a><span id="l13.63" class="difflineplus">+nsMsgGroupThread *nsMsgGroupView::CreateGroupThread(nsIMsgDatabase *db)</span>
<a href="#l13.64"></a><span id="l13.64" class="difflineplus">+{</span>
<a href="#l13.65"></a><span id="l13.65" class="difflineplus">+  return new nsMsgGroupThread(db);</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineplus">+}</span>
<a href="#l13.67"></a><span id="l13.67" class="difflineplus">+</span>
<a href="#l13.68"></a><span id="l13.68"> nsMsgGroupThread *nsMsgGroupView::AddHdrToThread(nsIMsgDBHdr *msgHdr, PRBool *pNewThread)</span>
<a href="#l13.69"></a><span id="l13.69"> {</span>
<a href="#l13.70"></a><span id="l13.70">   nsMsgKey msgKey;</span>
<a href="#l13.71"></a><span id="l13.71">   PRUint32 msgFlags;</span>
<a href="#l13.72"></a><span id="l13.72">   msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l13.73"></a><span id="l13.73">   msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l13.74"></a><span id="l13.74">   nsString hashKey;</span>
<a href="#l13.75"></a><span id="l13.75">   nsresult rv = HashHdr(msgHdr, hashKey);</span>
<a href="#l13.76"></a><span id="l13.76" class="difflineat">@@ -306,35 +315,35 @@ nsMsgGroupThread *nsMsgGroupView::AddHdr</span>
<a href="#l13.77"></a><span id="l13.77">   m_groupsTable.Get(hashKey, getter_AddRefs(msgThread));</span>
<a href="#l13.78"></a><span id="l13.78">   PRBool newThread = !msgThread;</span>
<a href="#l13.79"></a><span id="l13.79">   *pNewThread = newThread;</span>
<a href="#l13.80"></a><span id="l13.80">   nsMsgViewIndex viewIndexOfThread;</span>
<a href="#l13.81"></a><span id="l13.81"> </span>
<a href="#l13.82"></a><span id="l13.82">   nsMsgGroupThread *foundThread = static_cast&lt;nsMsgGroupThread *&gt;(msgThread.get());</span>
<a href="#l13.83"></a><span id="l13.83">   if (!foundThread)</span>
<a href="#l13.84"></a><span id="l13.84">   {</span>
<a href="#l13.85"></a><span id="l13.85" class="difflineminus">-    foundThread = new nsMsgGroupThread(m_db);</span>
<a href="#l13.86"></a><span id="l13.86" class="difflineplus">+    foundThread = CreateGroupThread(m_db);</span>
<a href="#l13.87"></a><span id="l13.87">     msgThread = do_QueryInterface(foundThread);</span>
<a href="#l13.88"></a><span id="l13.88">     m_groupsTable.Put(hashKey, msgThread);</span>
<a href="#l13.89"></a><span id="l13.89">     if (GroupViewUsesDummyRow())</span>
<a href="#l13.90"></a><span id="l13.90">     {</span>
<a href="#l13.91"></a><span id="l13.91">       foundThread-&gt;m_dummy = PR_TRUE;</span>
<a href="#l13.92"></a><span id="l13.92">       msgFlags |=  MSG_VIEW_FLAG_DUMMY | MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l13.93"></a><span id="l13.93">     }</span>
<a href="#l13.94"></a><span id="l13.94"> </span>
<a href="#l13.95"></a><span id="l13.95">     nsMsgViewIndex insertIndex = GetInsertIndex(msgHdr);</span>
<a href="#l13.96"></a><span id="l13.96">     if (insertIndex == nsMsgViewIndex_None)</span>
<a href="#l13.97"></a><span id="l13.97">       insertIndex = m_keys.Length();</span>
<a href="#l13.98"></a><span id="l13.98" class="difflineminus">-    m_keys.InsertElementAt(insertIndex, msgKey);</span>
<a href="#l13.99"></a><span id="l13.99" class="difflineminus">-    m_flags.InsertElementAt(insertIndex, msgFlags | MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED);</span>
<a href="#l13.100"></a><span id="l13.100" class="difflineminus">-    m_levels.InsertElementAt(insertIndex, 0);</span>
<a href="#l13.101"></a><span id="l13.101" class="difflineplus">+    InsertMsgHdrAt(insertIndex, msgHdr, msgKey, </span>
<a href="#l13.102"></a><span id="l13.102" class="difflineplus">+                  msgFlags | MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED, 0);</span>
<a href="#l13.103"></a><span id="l13.103">     // if grouped by date, insert dummy header for &quot;age&quot;</span>
<a href="#l13.104"></a><span id="l13.104">     if (GroupViewUsesDummyRow())</span>
<a href="#l13.105"></a><span id="l13.105">     {</span>
<a href="#l13.106"></a><span id="l13.106" class="difflineminus">-      foundThread-&gt;m_keys.InsertElementAt(0, msgKey /* nsMsgKey_None */);</span>
<a href="#l13.107"></a><span id="l13.107" class="difflineplus">+      // this needs to do something different for xf groups</span>
<a href="#l13.108"></a><span id="l13.108" class="difflineplus">+      foundThread-&gt;InsertMsgHdrAt(0, msgHdr);</span>
<a href="#l13.109"></a><span id="l13.109">       // the previous code made it look like hashKey in this case was always an integer</span>
<a href="#l13.110"></a><span id="l13.110">       foundThread-&gt;m_threadKey = atoi(NS_LossyConvertUTF16toASCII(hashKey).get());</span>
<a href="#l13.111"></a><span id="l13.111">     }</span>
<a href="#l13.112"></a><span id="l13.112">   }</span>
<a href="#l13.113"></a><span id="l13.113">   else</span>
<a href="#l13.114"></a><span id="l13.114">     viewIndexOfThread = GetIndexOfFirstDisplayedKeyInThread(foundThread);</span>
<a href="#l13.115"></a><span id="l13.115">   if (foundThread)</span>
<a href="#l13.116"></a><span id="l13.116">     foundThread-&gt;AddChildFromGroupView(msgHdr, this);</span>
<a href="#l13.117"></a><span id="l13.117" class="difflineat">@@ -351,16 +360,17 @@ nsMsgGroupThread *nsMsgGroupView::AddHdr</span>
<a href="#l13.118"></a><span id="l13.118"> }</span>
<a href="#l13.119"></a><span id="l13.119"> </span>
<a href="#l13.120"></a><span id="l13.120"> NS_IMETHODIMP nsMsgGroupView::OpenWithHdrs(nsISimpleEnumerator *aHeaders, nsMsgViewSortTypeValue aSortType,</span>
<a href="#l13.121"></a><span id="l13.121">                                         nsMsgViewSortOrderValue aSortOrder, nsMsgViewFlagsTypeValue aViewFlags,</span>
<a href="#l13.122"></a><span id="l13.122">                                         PRInt32 *aCount)</span>
<a href="#l13.123"></a><span id="l13.123"> {</span>
<a href="#l13.124"></a><span id="l13.124">   nsresult rv = NS_OK;</span>
<a href="#l13.125"></a><span id="l13.125"> </span>
<a href="#l13.126"></a><span id="l13.126" class="difflineplus">+  m_groupsTable.Clear();</span>
<a href="#l13.127"></a><span id="l13.127">   if (aSortType == nsMsgViewSortType::byThread || aSortType == nsMsgViewSortType::byId</span>
<a href="#l13.128"></a><span id="l13.128">     || aSortType == nsMsgViewSortType::byNone || aSortType == nsMsgViewSortType::bySize)</span>
<a href="#l13.129"></a><span id="l13.129">     return NS_ERROR_INVALID_ARG;</span>
<a href="#l13.130"></a><span id="l13.130"> </span>
<a href="#l13.131"></a><span id="l13.131">   m_sortType = aSortType;</span>
<a href="#l13.132"></a><span id="l13.132">   m_sortOrder = aSortOrder;</span>
<a href="#l13.133"></a><span id="l13.133">   m_viewFlags = aViewFlags | nsMsgViewFlagsType::kThreadedDisplay | nsMsgViewFlagsType::kGroupBySort;</span>
<a href="#l13.134"></a><span id="l13.134"> </span>
<a href="#l13.135"></a><span id="l13.135" class="difflineat">@@ -411,21 +421,31 @@ NS_IMETHODIMP nsMsgGroupView::OpenWithHd</span>
<a href="#l13.136"></a><span id="l13.136">         }</span>
<a href="#l13.137"></a><span id="l13.137">       }</span>
<a href="#l13.138"></a><span id="l13.138">     }</span>
<a href="#l13.139"></a><span id="l13.139">   }</span>
<a href="#l13.140"></a><span id="l13.140">   *aCount = m_keys.Length();</span>
<a href="#l13.141"></a><span id="l13.141">   return rv;</span>
<a href="#l13.142"></a><span id="l13.142"> }</span>
<a href="#l13.143"></a><span id="l13.143"> </span>
<a href="#l13.144"></a><span id="l13.144" class="difflineminus">-// if the day has changed, we need to close and re-open the view.</span>
<a href="#l13.145"></a><span id="l13.145" class="difflineminus">-nsresult nsMsgGroupView::HandleDayChange()</span>
<a href="#l13.146"></a><span id="l13.146" class="difflineplus">+// we wouldn't need this if we never instantiated this directly,</span>
<a href="#l13.147"></a><span id="l13.147" class="difflineplus">+// but instead used nsMsgThreadedDBView with the grouping flag set.</span>
<a href="#l13.148"></a><span id="l13.148" class="difflineplus">+// Or, we could get rid of the nsMsgThreadedDBView impl of this method.</span>
<a href="#l13.149"></a><span id="l13.149" class="difflineplus">+NS_IMETHODIMP nsMsgGroupView::GetViewType(nsMsgViewTypeValue *aViewType)</span>
<a href="#l13.150"></a><span id="l13.150" class="difflineplus">+{</span>
<a href="#l13.151"></a><span id="l13.151" class="difflineplus">+    NS_ENSURE_ARG_POINTER(aViewType);</span>
<a href="#l13.152"></a><span id="l13.152" class="difflineplus">+    *aViewType = nsMsgViewType::eShowAllThreads; </span>
<a href="#l13.153"></a><span id="l13.153" class="difflineplus">+    return NS_OK;</span>
<a href="#l13.154"></a><span id="l13.154" class="difflineplus">+}</span>
<a href="#l13.155"></a><span id="l13.155" class="difflineplus">+</span>
<a href="#l13.156"></a><span id="l13.156" class="difflineplus">+// E.g., if the day has changed, we need to close and re-open the view.</span>
<a href="#l13.157"></a><span id="l13.157" class="difflineplus">+nsresult nsMsgGroupView::RebuildView()</span>
<a href="#l13.158"></a><span id="l13.158"> {</span>
<a href="#l13.159"></a><span id="l13.159">   nsCOMPtr &lt;nsISimpleEnumerator&gt; headers;</span>
<a href="#l13.160"></a><span id="l13.160" class="difflineminus">-  if (NS_SUCCEEDED(m_db-&gt;EnumerateMessages(getter_AddRefs(headers))))</span>
<a href="#l13.161"></a><span id="l13.161" class="difflineplus">+  if (NS_SUCCEEDED(GetMessageEnumerator(getter_AddRefs(headers))))</span>
<a href="#l13.162"></a><span id="l13.162">   {</span>
<a href="#l13.163"></a><span id="l13.163">     PRInt32 count;</span>
<a href="#l13.164"></a><span id="l13.164">     m_dayChanged = PR_FALSE;</span>
<a href="#l13.165"></a><span id="l13.165">     nsAutoTArray&lt;nsMsgKey, 1&gt; preservedSelection;</span>
<a href="#l13.166"></a><span id="l13.166">     nsMsgKey curSelectedKey;</span>
<a href="#l13.167"></a><span id="l13.167">     SaveAndClearSelection(&amp;curSelectedKey, preservedSelection);</span>
<a href="#l13.168"></a><span id="l13.168">     InternalClose();</span>
<a href="#l13.169"></a><span id="l13.169">     PRInt32 oldSize = GetSize();</span>
<a href="#l13.170"></a><span id="l13.170" class="difflineat">@@ -451,34 +471,36 @@ nsresult nsMsgGroupView::HandleDayChange</span>
<a href="#l13.171"></a><span id="l13.171">     nsAutoTArray&lt;nsMsgKey, 1&gt; keyArray;</span>
<a href="#l13.172"></a><span id="l13.172">     keyArray.AppendElement(curSelectedKey);</span>
<a href="#l13.173"></a><span id="l13.173"> </span>
<a href="#l13.174"></a><span id="l13.174">     return RestoreSelection(curSelectedKey, keyArray);</span>
<a href="#l13.175"></a><span id="l13.175">   }</span>
<a href="#l13.176"></a><span id="l13.176">   return NS_OK;</span>
<a href="#l13.177"></a><span id="l13.177"> }</span>
<a href="#l13.178"></a><span id="l13.178"> </span>
<a href="#l13.179"></a><span id="l13.179" class="difflineminus">-nsresult nsMsgGroupView::OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey, PRBool /*ensureListed*/)</span>
<a href="#l13.180"></a><span id="l13.180" class="difflineplus">+nsresult nsMsgGroupView::OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey, PRBool ensureListed)</span>
<a href="#l13.181"></a><span id="l13.181"> {</span>
<a href="#l13.182"></a><span id="l13.182" class="difflineplus">+  if (!(m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l13.183"></a><span id="l13.183" class="difflineplus">+    return nsMsgDBView::OnNewHeader(newHdr, aParentKey, ensureListed);</span>
<a href="#l13.184"></a><span id="l13.184"> </span>
<a href="#l13.185"></a><span id="l13.185">   // check if we're adding a header, and the current day has changed. If it has, we're just going to</span>
<a href="#l13.186"></a><span id="l13.186">   // close and re-open the view so things will be correctly categorized.</span>
<a href="#l13.187"></a><span id="l13.187">   if (m_dayChanged)</span>
<a href="#l13.188"></a><span id="l13.188" class="difflineminus">-    return HandleDayChange();</span>
<a href="#l13.189"></a><span id="l13.189" class="difflineplus">+    return RebuildView();</span>
<a href="#l13.190"></a><span id="l13.190"> </span>
<a href="#l13.191"></a><span id="l13.191">   PRBool newThread;</span>
<a href="#l13.192"></a><span id="l13.192">   nsMsgGroupThread *thread = AddHdrToThread(newHdr, &amp;newThread);</span>
<a href="#l13.193"></a><span id="l13.193">   if (thread)</span>
<a href="#l13.194"></a><span id="l13.194">   {</span>
<a href="#l13.195"></a><span id="l13.195">     nsMsgKey msgKey;</span>
<a href="#l13.196"></a><span id="l13.196">     PRUint32 msgFlags;</span>
<a href="#l13.197"></a><span id="l13.197">     newHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l13.198"></a><span id="l13.198">     newHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l13.199"></a><span id="l13.199"> </span>
<a href="#l13.200"></a><span id="l13.200" class="difflineminus">-    nsMsgViewIndex threadIndex = ThreadIndexOfMsg(msgKey);</span>
<a href="#l13.201"></a><span id="l13.201" class="difflineplus">+    nsMsgViewIndex threadIndex = ThreadIndexOfMsgHdr(newHdr);</span>
<a href="#l13.202"></a><span id="l13.202">     PRInt32 numRowsInserted = 1;</span>
<a href="#l13.203"></a><span id="l13.203">     if (newThread &amp;&amp; GroupViewUsesDummyRow())</span>
<a href="#l13.204"></a><span id="l13.204">       numRowsInserted++;</span>
<a href="#l13.205"></a><span id="l13.205">     // may need to fix thread counts</span>
<a href="#l13.206"></a><span id="l13.206">     if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l13.207"></a><span id="l13.207">     {</span>
<a href="#l13.208"></a><span id="l13.208">       if (newThread)</span>
<a href="#l13.209"></a><span id="l13.209">         m_flags[threadIndex] &amp;= ~MSG_FLAG_ELIDED;</span>
<a href="#l13.210"></a><span id="l13.210" class="difflineat">@@ -506,27 +528,21 @@ nsresult nsMsgGroupView::OnNewHeader(nsI</span>
<a href="#l13.211"></a><span id="l13.211"> </span>
<a href="#l13.212"></a><span id="l13.212">             m_flags[threadIndex + msgIndexInThread] = msgFlags;</span>
<a href="#l13.213"></a><span id="l13.213">             // this will cause us to insert the old header as the first child, with</span>
<a href="#l13.214"></a><span id="l13.214">             // the right key and flags.</span>
<a href="#l13.215"></a><span id="l13.215">             msgFlags = saveOldFlags;</span>
<a href="#l13.216"></a><span id="l13.216">             msgIndexInThread++;</span>
<a href="#l13.217"></a><span id="l13.217">             msgKey = thread-&gt;m_keys[msgIndexInThread];</span>
<a href="#l13.218"></a><span id="l13.218">           }</span>
<a href="#l13.219"></a><span id="l13.219" class="difflineminus">-</span>
<a href="#l13.220"></a><span id="l13.220" class="difflineminus">-          m_keys.InsertElementAt(threadIndex + msgIndexInThread, msgKey);</span>
<a href="#l13.221"></a><span id="l13.221" class="difflineminus">-          m_flags.InsertElementAt(threadIndex + msgIndexInThread, msgFlags);</span>
<a href="#l13.222"></a><span id="l13.222" class="difflineminus">-          if (msgIndexInThread &gt; 0)</span>
<a href="#l13.223"></a><span id="l13.223" class="difflineminus">-          {</span>
<a href="#l13.224"></a><span id="l13.224" class="difflineminus">-            m_levels.InsertElementAt(threadIndex + msgIndexInThread, 1);</span>
<a href="#l13.225"></a><span id="l13.225" class="difflineminus">-          }</span>
<a href="#l13.226"></a><span id="l13.226" class="difflineminus">-          else // insert new header at level 0, and bump old level 0 to 1</span>
<a href="#l13.227"></a><span id="l13.227" class="difflineminus">-          {</span>
<a href="#l13.228"></a><span id="l13.228" class="difflineminus">-            m_levels.InsertElementAt(threadIndex + 1, 1);</span>
<a href="#l13.229"></a><span id="l13.229" class="difflineminus">-          }</span>
<a href="#l13.230"></a><span id="l13.230" class="difflineplus">+          InsertMsgHdrAt(threadIndex + msgIndexInThread, newHdr, msgKey,</span>
<a href="#l13.231"></a><span id="l13.231" class="difflineplus">+                         msgFlags, msgIndexInThread ? 1 : 0);</span>
<a href="#l13.232"></a><span id="l13.232" class="difflineplus">+          // if we inserted new header at level 0, bump old level 0 to 1</span>
<a href="#l13.233"></a><span id="l13.233" class="difflineplus">+          if (!msgIndexInThread)</span>
<a href="#l13.234"></a><span id="l13.234" class="difflineplus">+            m_levels[threadIndex + 1] = 1;</span>
<a href="#l13.235"></a><span id="l13.235">         }</span>
<a href="#l13.236"></a><span id="l13.236">         // the call to NoteChange() has to happen after we add the key</span>
<a href="#l13.237"></a><span id="l13.237">         // as NoteChange() will call RowCountChanged() which will call our GetRowCount()</span>
<a href="#l13.238"></a><span id="l13.238">         NoteChange((insertedAtThreadRoot &amp;&amp; GroupViewUsesDummyRow()) ? threadIndex + msgIndexInThread - 1 : threadIndex + msgIndexInThread,</span>
<a href="#l13.239"></a><span id="l13.239">                       numRowsInserted, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l13.240"></a><span id="l13.240">         numRowsToInvalidate = msgIndexInThread;</span>
<a href="#l13.241"></a><span id="l13.241">       }</span>
<a href="#l13.242"></a><span id="l13.242">       NoteChange(threadIndex, numRowsToInvalidate, nsMsgViewNotificationCode::changed);</span>
<a href="#l13.243"></a><span id="l13.243" class="difflineat">@@ -534,39 +550,46 @@ nsresult nsMsgGroupView::OnNewHeader(nsI</span>
<a href="#l13.244"></a><span id="l13.244">   }</span>
<a href="#l13.245"></a><span id="l13.245">   // if thread is expanded, we need to add hdr to view...</span>
<a href="#l13.246"></a><span id="l13.246">   return NS_OK;</span>
<a href="#l13.247"></a><span id="l13.247"> }</span>
<a href="#l13.248"></a><span id="l13.248"> </span>
<a href="#l13.249"></a><span id="l13.249"> NS_IMETHODIMP nsMsgGroupView::OnHdrFlagsChanged(nsIMsgDBHdr *aHdrChanged, PRUint32 aOldFlags,</span>
<a href="#l13.250"></a><span id="l13.250">                                       PRUint32 aNewFlags, nsIDBChangeListener *aInstigator)</span>
<a href="#l13.251"></a><span id="l13.251"> {</span>
<a href="#l13.252"></a><span id="l13.252" class="difflineplus">+  if (!(m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l13.253"></a><span id="l13.253" class="difflineplus">+    return nsMsgDBView::OnHdrFlagsChanged(aHdrChanged, aOldFlags, aNewFlags,</span>
<a href="#l13.254"></a><span id="l13.254" class="difflineplus">+                                          aInstigator);</span>
<a href="#l13.255"></a><span id="l13.255" class="difflineplus">+</span>
<a href="#l13.256"></a><span id="l13.256">   nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l13.257"></a><span id="l13.257"> </span>
<a href="#l13.258"></a><span id="l13.258">   // check if we're adding a header, and the current day has changed. If it has, we're just going to</span>
<a href="#l13.259"></a><span id="l13.259">   // close and re-open the view so things will be correctly categorized.</span>
<a href="#l13.260"></a><span id="l13.260">   if (m_dayChanged)</span>
<a href="#l13.261"></a><span id="l13.261" class="difflineminus">-    return HandleDayChange();</span>
<a href="#l13.262"></a><span id="l13.262" class="difflineplus">+    return RebuildView();</span>
<a href="#l13.263"></a><span id="l13.263"> </span>
<a href="#l13.264"></a><span id="l13.264">   nsresult rv = GetThreadContainingMsgHdr(aHdrChanged, getter_AddRefs(thread));</span>
<a href="#l13.265"></a><span id="l13.265">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l13.266"></a><span id="l13.266">   PRUint32 deltaFlags = (aOldFlags ^ aNewFlags);</span>
<a href="#l13.267"></a><span id="l13.267">   if (deltaFlags &amp; MSG_FLAG_READ)</span>
<a href="#l13.268"></a><span id="l13.268">     thread-&gt;MarkChildRead(aNewFlags &amp; MSG_FLAG_READ);</span>
<a href="#l13.269"></a><span id="l13.269"> </span>
<a href="#l13.270"></a><span id="l13.270">   return nsMsgDBView::OnHdrFlagsChanged(aHdrChanged, aOldFlags, aNewFlags, aInstigator);</span>
<a href="#l13.271"></a><span id="l13.271"> }</span>
<a href="#l13.272"></a><span id="l13.272"> </span>
<a href="#l13.273"></a><span id="l13.273"> NS_IMETHODIMP nsMsgGroupView::OnHdrDeleted(nsIMsgDBHdr *aHdrDeleted, nsMsgKey aParentKey, PRInt32 aFlags,</span>
<a href="#l13.274"></a><span id="l13.274">                             nsIDBChangeListener *aInstigator)</span>
<a href="#l13.275"></a><span id="l13.275"> {</span>
<a href="#l13.276"></a><span id="l13.276" class="difflineplus">+  if (!(m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l13.277"></a><span id="l13.277" class="difflineplus">+    return nsMsgDBView::OnHdrDeleted(aHdrDeleted, aParentKey, aFlags, aInstigator);</span>
<a href="#l13.278"></a><span id="l13.278" class="difflineplus">+</span>
<a href="#l13.279"></a><span id="l13.279">   // check if we're adding a header, and the current day has changed. If it has, we're just going to</span>
<a href="#l13.280"></a><span id="l13.280">   // close and re-open the view so things will be correctly categorized.</span>
<a href="#l13.281"></a><span id="l13.281">   if (m_dayChanged)</span>
<a href="#l13.282"></a><span id="l13.282" class="difflineminus">-    return HandleDayChange();</span>
<a href="#l13.283"></a><span id="l13.283" class="difflineplus">+    return RebuildView();</span>
<a href="#l13.284"></a><span id="l13.284"> </span>
<a href="#l13.285"></a><span id="l13.285">   nsCOMPtr &lt;nsIMsgThread&gt; thread;</span>
<a href="#l13.286"></a><span id="l13.286">   nsMsgKey keyDeleted;</span>
<a href="#l13.287"></a><span id="l13.287">   aHdrDeleted-&gt;GetMessageKey(&amp;keyDeleted);</span>
<a href="#l13.288"></a><span id="l13.288"> </span>
<a href="#l13.289"></a><span id="l13.289">   nsresult rv = GetThreadContainingMsgHdr(aHdrDeleted, getter_AddRefs(thread));</span>
<a href="#l13.290"></a><span id="l13.290">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l13.291"></a><span id="l13.291">   nsMsgViewIndex viewIndexOfThread = GetIndexOfFirstDisplayedKeyInThread(thread);</span>
<a href="#l13.292"></a><span id="l13.292" class="difflineat">@@ -579,23 +602,24 @@ NS_IMETHODIMP nsMsgGroupView::OnHdrDelet</span>
<a href="#l13.293"></a><span id="l13.293">   rv = nsMsgDBView::OnHdrDeleted(aHdrDeleted, aParentKey, aFlags, aInstigator);</span>
<a href="#l13.294"></a><span id="l13.294">   if (groupThread-&gt;m_dummy)</span>
<a href="#l13.295"></a><span id="l13.295">   {</span>
<a href="#l13.296"></a><span id="l13.296">     if (!groupThread-&gt;NumRealChildren())</span>
<a href="#l13.297"></a><span id="l13.297">     {</span>
<a href="#l13.298"></a><span id="l13.298">       thread-&gt;RemoveChildAt(0); // get rid of dummy</span>
<a href="#l13.299"></a><span id="l13.299">       if (viewIndexOfThread != nsMsgKey_None)</span>
<a href="#l13.300"></a><span id="l13.300">       {</span>
<a href="#l13.301"></a><span id="l13.301" class="difflineminus">-        nsMsgDBView::RemoveByIndex(viewIndexOfThread - 1);</span>
<a href="#l13.302"></a><span id="l13.302" class="difflineplus">+        RemoveByIndex(viewIndexOfThread - 1);</span>
<a href="#l13.303"></a><span id="l13.303">         if (m_deletingRows)</span>
<a href="#l13.304"></a><span id="l13.304">           mIndicesToNoteChange.AppendElement(viewIndexOfThread - 1);</span>
<a href="#l13.305"></a><span id="l13.305">       }</span>
<a href="#l13.306"></a><span id="l13.306">     }</span>
<a href="#l13.307"></a><span id="l13.307">     else if (rootDeleted &amp;&amp; viewIndexOfThread &gt; 0)</span>
<a href="#l13.308"></a><span id="l13.308">     {</span>
<a href="#l13.309"></a><span id="l13.309" class="difflineplus">+      // ### what about cross-folder views?</span>
<a href="#l13.310"></a><span id="l13.310">       m_keys[viewIndexOfThread - 1] = m_keys[viewIndexOfThread];</span>
<a href="#l13.311"></a><span id="l13.311">       OrExtraFlag(viewIndexOfThread - 1, MSG_VIEW_FLAG_DUMMY | MSG_VIEW_FLAG_ISTHREAD);</span>
<a href="#l13.312"></a><span id="l13.312">     }</span>
<a href="#l13.313"></a><span id="l13.313">   }</span>
<a href="#l13.314"></a><span id="l13.314">   if (!groupThread-&gt;m_keys.Length())</span>
<a href="#l13.315"></a><span id="l13.315">   {</span>
<a href="#l13.316"></a><span id="l13.316">     nsString hashKey;</span>
<a href="#l13.317"></a><span id="l13.317">     rv = HashHdr(aHdrDeleted, hashKey);</span>
<a href="#l13.318"></a><span id="l13.318" class="difflineat">@@ -765,17 +789,16 @@ NS_IMETHODIMP nsMsgGroupView::GetCellTex</span>
<a href="#l13.319"></a><span id="l13.319">     }</span>
<a href="#l13.320"></a><span id="l13.320">     return NS_OK;</span>
<a href="#l13.321"></a><span id="l13.321">   }</span>
<a href="#l13.322"></a><span id="l13.322">   return nsMsgDBView::GetCellText(aRow, aCol, aValue);</span>
<a href="#l13.323"></a><span id="l13.323"> }</span>
<a href="#l13.324"></a><span id="l13.324"> </span>
<a href="#l13.325"></a><span id="l13.325"> NS_IMETHODIMP nsMsgGroupView::LoadMessageByViewIndex(nsMsgViewIndex aViewIndex)</span>
<a href="#l13.326"></a><span id="l13.326"> {</span>
<a href="#l13.327"></a><span id="l13.327" class="difflineminus">-</span>
<a href="#l13.328"></a><span id="l13.328">   if (m_flags[aViewIndex] &amp; MSG_VIEW_FLAG_DUMMY)</span>
<a href="#l13.329"></a><span id="l13.329">   {</span>
<a href="#l13.330"></a><span id="l13.330">     // if we used to have one item selected, and now we have more than one, we should clear the message pane.</span>
<a href="#l13.331"></a><span id="l13.331">     nsCOMPtr&lt;nsIMsgWindow&gt; msgWindow(do_QueryReferent(mMsgWindowWeak));</span>
<a href="#l13.332"></a><span id="l13.332">     nsCOMPtr &lt;nsIMsgWindowCommands&gt; windowCommands;</span>
<a href="#l13.333"></a><span id="l13.333">     if (msgWindow &amp;&amp; NS_SUCCEEDED(msgWindow-&gt;GetWindowCommands(getter_AddRefs(windowCommands))) &amp;&amp; windowCommands)</span>
<a href="#l13.334"></a><span id="l13.334">       windowCommands-&gt;ClearMsgPane();</span>
<a href="#l13.335"></a><span id="l13.335">     // since we are selecting a dummy row, we should also clear out m_currentlyDisplayedMsgUri</span>
<a href="#l13.336"></a><span id="l13.336" class="difflineat">@@ -783,16 +806,19 @@ NS_IMETHODIMP nsMsgGroupView::LoadMessag</span>
<a href="#l13.337"></a><span id="l13.337">     return NS_OK;</span>
<a href="#l13.338"></a><span id="l13.338">   }</span>
<a href="#l13.339"></a><span id="l13.339">   else</span>
<a href="#l13.340"></a><span id="l13.340">     return nsMsgDBView::LoadMessageByViewIndex(aViewIndex);</span>
<a href="#l13.341"></a><span id="l13.341"> }</span>
<a href="#l13.342"></a><span id="l13.342"> </span>
<a href="#l13.343"></a><span id="l13.343"> nsresult nsMsgGroupView::GetThreadContainingMsgHdr(nsIMsgDBHdr *msgHdr, nsIMsgThread **pThread)</span>
<a href="#l13.344"></a><span id="l13.344"> {</span>
<a href="#l13.345"></a><span id="l13.345" class="difflineplus">+  if (!(m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l13.346"></a><span id="l13.346" class="difflineplus">+    return nsMsgDBView::GetThreadContainingMsgHdr(msgHdr, pThread);</span>
<a href="#l13.347"></a><span id="l13.347" class="difflineplus">+</span>
<a href="#l13.348"></a><span id="l13.348">   nsString hashKey;</span>
<a href="#l13.349"></a><span id="l13.349">   nsresult rv = HashHdr(msgHdr, hashKey);</span>
<a href="#l13.350"></a><span id="l13.350">   *pThread = nsnull;</span>
<a href="#l13.351"></a><span id="l13.351">   if (NS_SUCCEEDED(rv))</span>
<a href="#l13.352"></a><span id="l13.352">   {</span>
<a href="#l13.353"></a><span id="l13.353">     nsCOMPtr&lt;nsIMsgThread&gt; thread;</span>
<a href="#l13.354"></a><span id="l13.354">     m_groupsTable.Get(hashKey, getter_AddRefs(thread));</span>
<a href="#l13.355"></a><span id="l13.355">     thread.swap(*pThread);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/base/src/nsMsgGroupView.h</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgGroupView.h</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l14.4"></a><span id="l14.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l14.5"></a><span id="l14.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l14.6"></a><span id="l14.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l14.7"></a><span id="l14.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l14.8"></a><span id="l14.8">  *</span>
<a href="#l14.9"></a><span id="l14.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l14.10"></a><span id="l14.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l14.11"></a><span id="l14.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l14.12"></a><span id="l14.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l14.13"></a><span id="l14.13">  *</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineat">@@ -31,32 +31,39 @@</span>
<a href="#l14.15"></a><span id="l14.15">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l14.16"></a><span id="l14.16">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l14.17"></a><span id="l14.17">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l14.18"></a><span id="l14.18">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l14.19"></a><span id="l14.19">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l14.20"></a><span id="l14.20">  *</span>
<a href="#l14.21"></a><span id="l14.21">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l14.22"></a><span id="l14.22"> </span>
<a href="#l14.23"></a><span id="l14.23" class="difflineminus">-#include &quot;nsMsgThreadedDBView.h&quot;</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineplus">+#ifndef _nsMsgGroupView_H_</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+#define _nsMsgGroupView_H_</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineplus">+</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+#include &quot;nsMsgDBView.h&quot;</span>
<a href="#l14.28"></a><span id="l14.28"> #include &quot;nsInterfaceHashtable.h&quot;</span>
<a href="#l14.29"></a><span id="l14.29"> </span>
<a href="#l14.30"></a><span id="l14.30"> class nsIMsgThread;</span>
<a href="#l14.31"></a><span id="l14.31"> class nsMsgGroupThread;</span>
<a href="#l14.32"></a><span id="l14.32"> </span>
<a href="#l14.33"></a><span id="l14.33" class="difflineminus">-class nsMsgGroupView : public nsMsgThreadedDBView</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+// Please note that if you override a method of nsMsgDBView,</span>
<a href="#l14.35"></a><span id="l14.35" class="difflineplus">+// you will most likely want to check the m_viewFlags to see if</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineplus">+// we're grouping, and if not, call the base class implementation.</span>
<a href="#l14.37"></a><span id="l14.37" class="difflineplus">+class nsMsgGroupView : public nsMsgDBView</span>
<a href="#l14.38"></a><span id="l14.38"> {</span>
<a href="#l14.39"></a><span id="l14.39"> public:</span>
<a href="#l14.40"></a><span id="l14.40">   nsMsgGroupView();</span>
<a href="#l14.41"></a><span id="l14.41">   virtual ~nsMsgGroupView();</span>
<a href="#l14.42"></a><span id="l14.42"> </span>
<a href="#l14.43"></a><span id="l14.43">   NS_IMETHOD Open(nsIMsgFolder *folder, nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder, nsMsgViewFlagsTypeValue viewFlags, PRInt32 *pCount);</span>
<a href="#l14.44"></a><span id="l14.44">   NS_IMETHOD OpenWithHdrs(nsISimpleEnumerator *aHeaders, nsMsgViewSortTypeValue aSortType, </span>
<a href="#l14.45"></a><span id="l14.45">                                         nsMsgViewSortOrderValue aSortOrder, nsMsgViewFlagsTypeValue aViewFlags, </span>
<a href="#l14.46"></a><span id="l14.46">                                         PRInt32 *aCount);</span>
<a href="#l14.47"></a><span id="l14.47" class="difflineplus">+  NS_IMETHOD GetViewType(nsMsgViewTypeValue *aViewType);</span>
<a href="#l14.48"></a><span id="l14.48">   NS_IMETHOD Close();</span>
<a href="#l14.49"></a><span id="l14.49">   NS_IMETHOD OnHdrDeleted(nsIMsgDBHdr *aHdrDeleted, nsMsgKey aParentKey, PRInt32 aFlags, </span>
<a href="#l14.50"></a><span id="l14.50">                             nsIDBChangeListener *aInstigator);</span>
<a href="#l14.51"></a><span id="l14.51">   NS_IMETHOD OnHdrFlagsChanged(nsIMsgDBHdr *aHdrChanged, PRUint32 aOldFlags, </span>
<a href="#l14.52"></a><span id="l14.52">                                       PRUint32 aNewFlags, nsIDBChangeListener *aInstigator);</span>
<a href="#l14.53"></a><span id="l14.53"> </span>
<a href="#l14.54"></a><span id="l14.54">   NS_IMETHOD LoadMessageByViewIndex(nsMsgViewIndex aViewIndex);</span>
<a href="#l14.55"></a><span id="l14.55">   NS_IMETHOD GetCellProperties(PRInt32 aRow, nsITreeColumn *aCol, nsISupportsArray *aProperties);</span>
<a href="#l14.56"></a><span id="l14.56" class="difflineat">@@ -72,22 +79,25 @@ protected:</span>
<a href="#l14.57"></a><span id="l14.57">   virtual nsresult GetThreadContainingMsgHdr(nsIMsgDBHdr *msgHdr, nsIMsgThread **pThread);</span>
<a href="#l14.58"></a><span id="l14.58">   virtual PRInt32 FindLevelInThread(nsIMsgDBHdr *msgHdr, nsMsgViewIndex startOfThread, nsMsgViewIndex viewIndex);</span>
<a href="#l14.59"></a><span id="l14.59">   nsMsgViewIndex ThreadIndexOfMsg(nsMsgKey msgKey, </span>
<a href="#l14.60"></a><span id="l14.60">                                             nsMsgViewIndex msgIndex = nsMsgViewIndex_None,</span>
<a href="#l14.61"></a><span id="l14.61">                                             PRInt32 *pThreadCount = NULL,</span>
<a href="#l14.62"></a><span id="l14.62">                                             PRUint32 *pFlags = NULL);</span>
<a href="#l14.63"></a><span id="l14.63"> </span>
<a href="#l14.64"></a><span id="l14.64">   PRBool GroupViewUsesDummyRow(); // returns true if we are grouped by a sort attribute that uses a dummy row</span>
<a href="#l14.65"></a><span id="l14.65" class="difflineminus">-  nsresult HandleDayChange();</span>
<a href="#l14.66"></a><span id="l14.66" class="difflineplus">+  virtual nsresult RebuildView();</span>
<a href="#l14.67"></a><span id="l14.67" class="difflineplus">+  virtual nsMsgGroupThread *CreateGroupThread(nsIMsgDatabase *db);</span>
<a href="#l14.68"></a><span id="l14.68"> </span>
<a href="#l14.69"></a><span id="l14.69">   nsInterfaceHashtable &lt;nsStringHashKey, nsIMsgThread&gt; m_groupsTable;</span>
<a href="#l14.70"></a><span id="l14.70">   PRExplodedTime m_lastCurExplodedTime;</span>
<a href="#l14.71"></a><span id="l14.71">   PRBool m_dayChanged;</span>
<a href="#l14.72"></a><span id="l14.72"> </span>
<a href="#l14.73"></a><span id="l14.73"> private:</span>
<a href="#l14.74"></a><span id="l14.74">   nsString m_kTodayString;</span>
<a href="#l14.75"></a><span id="l14.75">   nsString m_kYesterdayString;</span>
<a href="#l14.76"></a><span id="l14.76">   nsString m_kLastWeekString;</span>
<a href="#l14.77"></a><span id="l14.77">   nsString m_kTwoWeeksAgoString;</span>
<a href="#l14.78"></a><span id="l14.78">   nsString m_kOldMailString;</span>
<a href="#l14.79"></a><span id="l14.79"> };</span>
<a href="#l14.80"></a><span id="l14.80"> </span>
<a href="#l14.81"></a><span id="l14.81" class="difflineplus">+#endif</span>
<a href="#l14.82"></a><span id="l14.82" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/base/src/nsMsgQuickSearchDBView.cpp</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgQuickSearchDBView.cpp</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l15.4"></a><span id="l15.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l15.5"></a><span id="l15.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l15.6"></a><span id="l15.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l15.7"></a><span id="l15.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l15.8"></a><span id="l15.8">  *</span>
<a href="#l15.9"></a><span id="l15.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l15.10"></a><span id="l15.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l15.11"></a><span id="l15.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l15.12"></a><span id="l15.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l15.13"></a><span id="l15.13">  *</span>
<a href="#l15.14"></a><span id="l15.14" class="difflineat">@@ -40,16 +40,17 @@</span>
<a href="#l15.15"></a><span id="l15.15"> #include &quot;nsMsgQuickSearchDBView.h&quot;</span>
<a href="#l15.16"></a><span id="l15.16"> #include &quot;nsMsgFolderFlags.h&quot;</span>
<a href="#l15.17"></a><span id="l15.17"> #include &quot;nsIMsgHdr.h&quot;</span>
<a href="#l15.18"></a><span id="l15.18"> #include &quot;nsMsgBaseCID.h&quot;</span>
<a href="#l15.19"></a><span id="l15.19"> #include &quot;nsIMsgImapMailFolder.h&quot;</span>
<a href="#l15.20"></a><span id="l15.20"> #include &quot;nsImapCore.h&quot;</span>
<a href="#l15.21"></a><span id="l15.21"> #include &quot;nsIMsgHdr.h&quot;</span>
<a href="#l15.22"></a><span id="l15.22"> #include &quot;nsIDBFolderInfo.h&quot;</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineplus">+#include &quot;nsArrayEnumerator.h&quot;</span>
<a href="#l15.24"></a><span id="l15.24"> </span>
<a href="#l15.25"></a><span id="l15.25"> nsMsgQuickSearchDBView::nsMsgQuickSearchDBView()</span>
<a href="#l15.26"></a><span id="l15.26"> {</span>
<a href="#l15.27"></a><span id="l15.27">   m_usingCachedHits = PR_FALSE;</span>
<a href="#l15.28"></a><span id="l15.28">   m_cacheEmpty = PR_TRUE;</span>
<a href="#l15.29"></a><span id="l15.29"> }</span>
<a href="#l15.30"></a><span id="l15.30"> </span>
<a href="#l15.31"></a><span id="l15.31"> nsMsgQuickSearchDBView::~nsMsgQuickSearchDBView()</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineat">@@ -115,16 +116,23 @@ NS_IMETHODIMP nsMsgQuickSearchDBView::Do</span>
<a href="#l15.33"></a><span id="l15.33"> </span>
<a href="#l15.34"></a><span id="l15.34"> NS_IMETHODIMP nsMsgQuickSearchDBView::GetViewType(nsMsgViewTypeValue *aViewType)</span>
<a href="#l15.35"></a><span id="l15.35"> {</span>
<a href="#l15.36"></a><span id="l15.36">     NS_ENSURE_ARG_POINTER(aViewType);</span>
<a href="#l15.37"></a><span id="l15.37">     *aViewType = nsMsgViewType::eShowQuickSearchResults; </span>
<a href="#l15.38"></a><span id="l15.38">     return NS_OK;</span>
<a href="#l15.39"></a><span id="l15.39"> }</span>
<a href="#l15.40"></a><span id="l15.40"> </span>
<a href="#l15.41"></a><span id="l15.41" class="difflineplus">+nsresult nsMsgQuickSearchDBView::AddHdr(nsIMsgDBHdr *msgHdr, nsMsgViewIndex *resultIndex)</span>
<a href="#l15.42"></a><span id="l15.42" class="difflineplus">+{</span>
<a href="#l15.43"></a><span id="l15.43" class="difflineplus">+  return (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l15.44"></a><span id="l15.44" class="difflineplus">+          ? nsMsgGroupView::OnNewHeader(msgHdr, nsMsgKey_None, PR_TRUE)</span>
<a href="#l15.45"></a><span id="l15.45" class="difflineplus">+          : nsMsgDBView::AddHdr(msgHdr, resultIndex);</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineplus">+}</span>
<a href="#l15.47"></a><span id="l15.47" class="difflineplus">+</span>
<a href="#l15.48"></a><span id="l15.48"> nsresult nsMsgQuickSearchDBView::OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey, PRBool ensureListed)</span>
<a href="#l15.49"></a><span id="l15.49"> {</span>
<a href="#l15.50"></a><span id="l15.50">   if (newHdr)</span>
<a href="#l15.51"></a><span id="l15.51">   {</span>
<a href="#l15.52"></a><span id="l15.52">     PRBool match=PR_FALSE;</span>
<a href="#l15.53"></a><span id="l15.53">     nsCOMPtr &lt;nsIMsgSearchSession&gt; searchSession = do_QueryReferent(m_searchSession);</span>
<a href="#l15.54"></a><span id="l15.54">     if (searchSession)</span>
<a href="#l15.55"></a><span id="l15.55">       searchSession-&gt;MatchHdr(newHdr, m_db, &amp;match);</span>
<a href="#l15.56"></a><span id="l15.56" class="difflineat">@@ -141,17 +149,17 @@ nsresult nsMsgQuickSearchDBView::OnNewHe</span>
<a href="#l15.57"></a><span id="l15.57">     }</span>
<a href="#l15.58"></a><span id="l15.58">   }</span>
<a href="#l15.59"></a><span id="l15.59">   return NS_OK;</span>
<a href="#l15.60"></a><span id="l15.60"> }</span>
<a href="#l15.61"></a><span id="l15.61"> </span>
<a href="#l15.62"></a><span id="l15.62"> NS_IMETHODIMP nsMsgQuickSearchDBView::OnHdrFlagsChanged(nsIMsgDBHdr *aHdrChanged, PRUint32 aOldFlags, </span>
<a href="#l15.63"></a><span id="l15.63">                                        PRUint32 aNewFlags, nsIDBChangeListener *aInstigator)</span>
<a href="#l15.64"></a><span id="l15.64"> {</span>
<a href="#l15.65"></a><span id="l15.65" class="difflineminus">-  nsresult rv = nsMsgDBView::OnHdrFlagsChanged(aHdrChanged, aOldFlags, aNewFlags, aInstigator);</span>
<a href="#l15.66"></a><span id="l15.66" class="difflineplus">+  nsresult rv = nsMsgGroupView::OnHdrFlagsChanged(aHdrChanged, aOldFlags, aNewFlags, aInstigator);</span>
<a href="#l15.67"></a><span id="l15.67"> </span>
<a href="#l15.68"></a><span id="l15.68">   if (m_viewFolder &amp;&amp; (aOldFlags &amp; MSG_FLAG_READ) != (aNewFlags &amp; MSG_FLAG_READ))</span>
<a href="#l15.69"></a><span id="l15.69">   {</span>
<a href="#l15.70"></a><span id="l15.70">     // if we're displaying a single folder virtual folder for an imap folder,</span>
<a href="#l15.71"></a><span id="l15.71">     // the search criteria might be on message body, and we might not have the</span>
<a href="#l15.72"></a><span id="l15.72">     // message body offline, in which case we can't tell if the message </span>
<a href="#l15.73"></a><span id="l15.73">     // matched or not. But if the unread flag changed, we need to update the</span>
<a href="#l15.74"></a><span id="l15.74">     // unread counts. Normally, VirtualFolderChangeListener::OnHdrFlagsChanged will</span>
<a href="#l15.75"></a><span id="l15.75" class="difflineat">@@ -258,20 +266,25 @@ nsMsgQuickSearchDBView::OnSearchHit(nsIM</span>
<a href="#l15.76"></a><span id="l15.76">   NS_ENSURE_ARG(aMsgHdr);</span>
<a href="#l15.77"></a><span id="l15.77">   if (!m_db)</span>
<a href="#l15.78"></a><span id="l15.78">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l15.79"></a><span id="l15.79">   // remember search hit and when search is done, reconcile cache</span>
<a href="#l15.80"></a><span id="l15.80">   // with new hits;</span>
<a href="#l15.81"></a><span id="l15.81">   m_hdrHits.AppendObject(aMsgHdr);</span>
<a href="#l15.82"></a><span id="l15.82">   nsMsgKey key;</span>
<a href="#l15.83"></a><span id="l15.83">   aMsgHdr-&gt;GetMessageKey(&amp;key);</span>
<a href="#l15.84"></a><span id="l15.84" class="difflineplus">+  // put the new header in m_origKeys, so that expanding a thread will</span>
<a href="#l15.85"></a><span id="l15.85" class="difflineplus">+  // show the newly added header.</span>
<a href="#l15.86"></a><span id="l15.86" class="difflineplus">+  nsMsgViewIndex insertIndex = GetInsertIndexHelper(aMsgHdr, m_origKeys, nsnull,</span>
<a href="#l15.87"></a><span id="l15.87" class="difflineplus">+                  nsMsgViewSortOrder::ascending, nsMsgViewSortType::byId);</span>
<a href="#l15.88"></a><span id="l15.88" class="difflineplus">+  m_origKeys.InsertElementAt(insertIndex, key);</span>
<a href="#l15.89"></a><span id="l15.89">   // is FindKey going to be expensive here? A lot of hits could make</span>
<a href="#l15.90"></a><span id="l15.90">   // it a little bit slow to search through the view for every hit.</span>
<a href="#l15.91"></a><span id="l15.91">   if (m_cacheEmpty || FindKey(key, PR_FALSE) == nsMsgViewIndex_None)</span>
<a href="#l15.92"></a><span id="l15.92" class="difflineminus">-  return AddHdr(aMsgHdr); </span>
<a href="#l15.93"></a><span id="l15.93" class="difflineplus">+    return AddHdr(aMsgHdr); </span>
<a href="#l15.94"></a><span id="l15.94">   else</span>
<a href="#l15.95"></a><span id="l15.95">     return NS_OK;</span>
<a href="#l15.96"></a><span id="l15.96"> }</span>
<a href="#l15.97"></a><span id="l15.97"> </span>
<a href="#l15.98"></a><span id="l15.98"> NS_IMETHODIMP</span>
<a href="#l15.99"></a><span id="l15.99"> nsMsgQuickSearchDBView::OnSearchDone(nsresult status)</span>
<a href="#l15.100"></a><span id="l15.100"> {</span>
<a href="#l15.101"></a><span id="l15.101">   if (m_viewFolder)</span>
<a href="#l15.102"></a><span id="l15.102" class="difflineat">@@ -307,17 +320,16 @@ nsMsgQuickSearchDBView::OnSearchDone(nsr</span>
<a href="#l15.103"></a><span id="l15.103">   if (m_sortType != nsMsgViewSortType::byThread)//we do not find levels for the results.</span>
<a href="#l15.104"></a><span id="l15.104">   {</span>
<a href="#l15.105"></a><span id="l15.105">     m_sortValid = PR_FALSE;       //sort the results </span>
<a href="#l15.106"></a><span id="l15.106">     Sort(m_sortType, m_sortOrder);</span>
<a href="#l15.107"></a><span id="l15.107">   }</span>
<a href="#l15.108"></a><span id="l15.108">   if (m_viewFolder)</span>
<a href="#l15.109"></a><span id="l15.109">     SetMRUTimeForFolder(m_viewFolder);</span>
<a href="#l15.110"></a><span id="l15.110"> </span>
<a href="#l15.111"></a><span id="l15.111" class="difflineminus">-  m_hdrHits.Clear();</span>
<a href="#l15.112"></a><span id="l15.112">   return NS_OK;</span>
<a href="#l15.113"></a><span id="l15.113"> }</span>
<a href="#l15.114"></a><span id="l15.114"> </span>
<a href="#l15.115"></a><span id="l15.115"> </span>
<a href="#l15.116"></a><span id="l15.116"> NS_IMETHODIMP</span>
<a href="#l15.117"></a><span id="l15.117"> nsMsgQuickSearchDBView::OnNewSearch()</span>
<a href="#l15.118"></a><span id="l15.118"> {</span>
<a href="#l15.119"></a><span id="l15.119">   PRInt32 oldSize = GetSize();</span>
<a href="#l15.120"></a><span id="l15.120" class="difflineat">@@ -430,20 +442,19 @@ nsresult nsMsgQuickSearchDBView::GetFirs</span>
<a href="#l15.121"></a><span id="l15.121">     }</span>
<a href="#l15.122"></a><span id="l15.122">   }</span>
<a href="#l15.123"></a><span id="l15.123">   NS_IF_ADDREF(*result = retHdr);</span>
<a href="#l15.124"></a><span id="l15.124">   return NS_OK; </span>
<a href="#l15.125"></a><span id="l15.125"> }</span>
<a href="#l15.126"></a><span id="l15.126"> </span>
<a href="#l15.127"></a><span id="l15.127"> nsresult nsMsgQuickSearchDBView::SortThreads(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l15.128"></a><span id="l15.128"> {</span>
<a href="#l15.129"></a><span id="l15.129" class="difflineminus">-  // we don't handle grouping in quick search views yet.</span>
<a href="#l15.130"></a><span id="l15.130" class="difflineplus">+  // don't need to sort by threads for group view.</span>
<a href="#l15.131"></a><span id="l15.131">   if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l15.132"></a><span id="l15.132">     return NS_OK;</span>
<a href="#l15.133"></a><span id="l15.133" class="difflineminus">-</span>
<a href="#l15.134"></a><span id="l15.134">   // iterate over the messages in the view, getting the thread id's</span>
<a href="#l15.135"></a><span id="l15.135">   // sort m_keys so we can quickly find if a key is in the view. </span>
<a href="#l15.136"></a><span id="l15.136">   m_keys.Sort();</span>
<a href="#l15.137"></a><span id="l15.137">   // array of the threads' root hdr keys.</span>
<a href="#l15.138"></a><span id="l15.138">   nsTArray&lt;nsMsgKey&gt; threadRootIds;</span>
<a href="#l15.139"></a><span id="l15.139">   nsCOMPtr &lt;nsIMsgDBHdr&gt; rootHdr;</span>
<a href="#l15.140"></a><span id="l15.140">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l15.141"></a><span id="l15.141">   nsCOMPtr &lt;nsIMsgThread&gt; threadHdr;</span>
<a href="#l15.142"></a><span id="l15.142" class="difflineat">@@ -519,46 +530,47 @@ nsresult  nsMsgQuickSearchDBView::ListId</span>
<a href="#l15.143"></a><span id="l15.143">   PRUint32 i;</span>
<a href="#l15.144"></a><span id="l15.144">   PRUint32 viewIndex = startOfThreadViewIndex + 1;</span>
<a href="#l15.145"></a><span id="l15.145">   nsCOMPtr &lt;nsIMsgDBHdr&gt; rootHdr;</span>
<a href="#l15.146"></a><span id="l15.146">   nsMsgKey rootKey;</span>
<a href="#l15.147"></a><span id="l15.147">   PRUint32 rootFlags = m_flags[startOfThreadViewIndex];</span>
<a href="#l15.148"></a><span id="l15.148">   *pNumListed = 0;</span>
<a href="#l15.149"></a><span id="l15.149">   GetMsgHdrForViewIndex(startOfThreadViewIndex, getter_AddRefs(rootHdr));</span>
<a href="#l15.150"></a><span id="l15.150">   rootHdr-&gt;GetMessageKey(&amp;rootKey);</span>
<a href="#l15.151"></a><span id="l15.151" class="difflineplus">+  // group threads can have the root key twice, one for the dummy row.</span>
<a href="#l15.152"></a><span id="l15.152" class="difflineplus">+  PRBool rootKeySkipped = PR_FALSE;</span>
<a href="#l15.153"></a><span id="l15.153">   for (i = 0; i &lt; numChildren; i++)</span>
<a href="#l15.154"></a><span id="l15.154">   {</span>
<a href="#l15.155"></a><span id="l15.155">     nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l15.156"></a><span id="l15.156">     threadHdr-&gt;GetChildHdrAt(i, getter_AddRefs(msgHdr));</span>
<a href="#l15.157"></a><span id="l15.157">     if (msgHdr != nsnull)</span>
<a href="#l15.158"></a><span id="l15.158">     {</span>
<a href="#l15.159"></a><span id="l15.159">       nsMsgKey msgKey;</span>
<a href="#l15.160"></a><span id="l15.160">       msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l15.161"></a><span id="l15.161" class="difflineminus">-      if (msgKey != rootKey)</span>
<a href="#l15.162"></a><span id="l15.162" class="difflineplus">+      if (msgKey != rootKey || (GroupViewUsesDummyRow() &amp;&amp; rootKeySkipped))</span>
<a href="#l15.163"></a><span id="l15.163">       {</span>
<a href="#l15.164"></a><span id="l15.164">         nsMsgViewIndex threadRootIndex = m_origKeys.BinaryIndexOf(msgKey);</span>
<a href="#l15.165"></a><span id="l15.165">         // if this hdr is in the original view, add it to new view.</span>
<a href="#l15.166"></a><span id="l15.166">         if (threadRootIndex != kNotFound)</span>
<a href="#l15.167"></a><span id="l15.167">         {</span>
<a href="#l15.168"></a><span id="l15.168">           PRUint32 childFlags;</span>
<a href="#l15.169"></a><span id="l15.169">           msgHdr-&gt;GetFlags(&amp;childFlags);</span>
<a href="#l15.170"></a><span id="l15.170" class="difflineminus">-          PRUint8 levelToAdd;</span>
<a href="#l15.171"></a><span id="l15.171" class="difflineminus">-          m_keys.InsertElementAt(viewIndex, msgKey);</span>
<a href="#l15.172"></a><span id="l15.172" class="difflineminus">-          m_flags.InsertElementAt(viewIndex, childFlags);</span>
<a href="#l15.173"></a><span id="l15.173" class="difflineplus">+          InsertMsgHdrAt(viewIndex, msgHdr, msgKey, childFlags, </span>
<a href="#l15.174"></a><span id="l15.174" class="difflineplus">+                        FindLevelInThread(msgHdr, startOfThreadViewIndex, viewIndex));</span>
<a href="#l15.175"></a><span id="l15.175">           if (! (rootFlags &amp; MSG_VIEW_FLAG_HASCHILDREN))</span>
<a href="#l15.176"></a><span id="l15.176" class="difflineminus">-          {</span>
<a href="#l15.177"></a><span id="l15.177" class="difflineminus">-            rootFlags |= MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l15.178"></a><span id="l15.178" class="difflineminus">-            m_flags[startOfThreadViewIndex] = rootFlags;</span>
<a href="#l15.179"></a><span id="l15.179" class="difflineminus">-          }</span>
<a href="#l15.180"></a><span id="l15.180" class="difflineminus">-          levelToAdd = FindLevelInThread(msgHdr, startOfThreadViewIndex, viewIndex);</span>
<a href="#l15.181"></a><span id="l15.181" class="difflineminus">-          m_levels.InsertElementAt(viewIndex, levelToAdd);</span>
<a href="#l15.182"></a><span id="l15.182" class="difflineplus">+            m_flags[startOfThreadViewIndex] = rootFlags | MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l15.183"></a><span id="l15.183" class="difflineplus">+</span>
<a href="#l15.184"></a><span id="l15.184">           viewIndex++;</span>
<a href="#l15.185"></a><span id="l15.185">           (*pNumListed)++;</span>
<a href="#l15.186"></a><span id="l15.186">         }</span>
<a href="#l15.187"></a><span id="l15.187">       }</span>
<a href="#l15.188"></a><span id="l15.188" class="difflineplus">+      else</span>
<a href="#l15.189"></a><span id="l15.189" class="difflineplus">+      {</span>
<a href="#l15.190"></a><span id="l15.190" class="difflineplus">+        rootKeySkipped = PR_TRUE;</span>
<a href="#l15.191"></a><span id="l15.191" class="difflineplus">+      }</span>
<a href="#l15.192"></a><span id="l15.192">     }</span>
<a href="#l15.193"></a><span id="l15.193">   }</span>
<a href="#l15.194"></a><span id="l15.194">   return NS_OK;</span>
<a href="#l15.195"></a><span id="l15.195"> }</span>
<a href="#l15.196"></a><span id="l15.196"> </span>
<a href="#l15.197"></a><span id="l15.197"> nsresult nsMsgQuickSearchDBView::ExpansionDelta(nsMsgViewIndex index, PRInt32 *expansionDelta)</span>
<a href="#l15.198"></a><span id="l15.198"> {</span>
<a href="#l15.199"></a><span id="l15.199">   *expansionDelta = 0;</span>
<a href="#l15.200"></a><span id="l15.200" class="difflineat">@@ -574,8 +586,60 @@ nsresult nsMsgQuickSearchDBView::Expansi</span>
<a href="#l15.201"></a><span id="l15.201">   // in a thread and get the expansion delta for the thread.</span>
<a href="#l15.202"></a><span id="l15.202"> </span>
<a href="#l15.203"></a><span id="l15.203">   PRInt32 numChildren = CountExpandedThread(index);</span>
<a href="#l15.204"></a><span id="l15.204"> </span>
<a href="#l15.205"></a><span id="l15.205">   *expansionDelta = (flags &amp; MSG_FLAG_ELIDED) ? </span>
<a href="#l15.206"></a><span id="l15.206">                     numChildren - 1 : - (PRInt32) (numChildren - 1);</span>
<a href="#l15.207"></a><span id="l15.207">   return NS_OK;</span>
<a href="#l15.208"></a><span id="l15.208"> }</span>
<a href="#l15.209"></a><span id="l15.209" class="difflineplus">+</span>
<a href="#l15.210"></a><span id="l15.210" class="difflineplus">+NS_IMETHODIMP </span>
<a href="#l15.211"></a><span id="l15.211" class="difflineplus">+nsMsgQuickSearchDBView::OpenWithHdrs(nsISimpleEnumerator *aHeaders, </span>
<a href="#l15.212"></a><span id="l15.212" class="difflineplus">+                                     nsMsgViewSortTypeValue aSortType,</span>
<a href="#l15.213"></a><span id="l15.213" class="difflineplus">+                                     nsMsgViewSortOrderValue aSortOrder, </span>
<a href="#l15.214"></a><span id="l15.214" class="difflineplus">+                                     nsMsgViewFlagsTypeValue aViewFlags,</span>
<a href="#l15.215"></a><span id="l15.215" class="difflineplus">+                                     PRInt32 *aCount)</span>
<a href="#l15.216"></a><span id="l15.216" class="difflineplus">+{</span>
<a href="#l15.217"></a><span id="l15.217" class="difflineplus">+  if (aViewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l15.218"></a><span id="l15.218" class="difflineplus">+    return nsMsgGroupView::OpenWithHdrs(aHeaders, aSortType, aSortOrder, </span>
<a href="#l15.219"></a><span id="l15.219" class="difflineplus">+                                        aViewFlags, aCount);</span>
<a href="#l15.220"></a><span id="l15.220" class="difflineplus">+</span>
<a href="#l15.221"></a><span id="l15.221" class="difflineplus">+  m_sortType = aSortType;</span>
<a href="#l15.222"></a><span id="l15.222" class="difflineplus">+  m_sortOrder = aSortOrder;</span>
<a href="#l15.223"></a><span id="l15.223" class="difflineplus">+  m_viewFlags = aViewFlags;</span>
<a href="#l15.224"></a><span id="l15.224" class="difflineplus">+</span>
<a href="#l15.225"></a><span id="l15.225" class="difflineplus">+  PRBool hasMore;</span>
<a href="#l15.226"></a><span id="l15.226" class="difflineplus">+  nsCOMPtr&lt;nsISupports&gt; supports;</span>
<a href="#l15.227"></a><span id="l15.227" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l15.228"></a><span id="l15.228" class="difflineplus">+  nsresult rv = NS_OK;</span>
<a href="#l15.229"></a><span id="l15.229" class="difflineplus">+  while (NS_SUCCEEDED(rv = aHeaders-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l15.230"></a><span id="l15.230" class="difflineplus">+  {</span>
<a href="#l15.231"></a><span id="l15.231" class="difflineplus">+    rv = aHeaders-&gt;GetNext(getter_AddRefs(supports));</span>
<a href="#l15.232"></a><span id="l15.232" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; supports)</span>
<a href="#l15.233"></a><span id="l15.233" class="difflineplus">+    {</span>
<a href="#l15.234"></a><span id="l15.234" class="difflineplus">+      msgHdr = do_QueryInterface(supports);</span>
<a href="#l15.235"></a><span id="l15.235" class="difflineplus">+      AddHdr(msgHdr); </span>
<a href="#l15.236"></a><span id="l15.236" class="difflineplus">+    }</span>
<a href="#l15.237"></a><span id="l15.237" class="difflineplus">+    else</span>
<a href="#l15.238"></a><span id="l15.238" class="difflineplus">+      break;</span>
<a href="#l15.239"></a><span id="l15.239" class="difflineplus">+  }</span>
<a href="#l15.240"></a><span id="l15.240" class="difflineplus">+  *aCount = m_keys.Length();</span>
<a href="#l15.241"></a><span id="l15.241" class="difflineplus">+  return rv;</span>
<a href="#l15.242"></a><span id="l15.242" class="difflineplus">+}</span>
<a href="#l15.243"></a><span id="l15.243" class="difflineplus">+</span>
<a href="#l15.244"></a><span id="l15.244" class="difflineplus">+NS_IMETHODIMP nsMsgQuickSearchDBView::SetViewFlags(nsMsgViewFlagsTypeValue aViewFlags)</span>
<a href="#l15.245"></a><span id="l15.245" class="difflineplus">+{</span>
<a href="#l15.246"></a><span id="l15.246" class="difflineplus">+  nsMsgViewFlagsTypeValue saveViewFlags = m_viewFlags;</span>
<a href="#l15.247"></a><span id="l15.247" class="difflineplus">+  nsresult rv = nsMsgDBView::SetViewFlags(aViewFlags);</span>
<a href="#l15.248"></a><span id="l15.248" class="difflineplus">+  // if the grouping has changed, rebuild the view</span>
<a href="#l15.249"></a><span id="l15.249" class="difflineplus">+  if (saveViewFlags &amp; nsMsgViewFlagsType::kGroupBySort ^</span>
<a href="#l15.250"></a><span id="l15.250" class="difflineplus">+      (aViewFlags &amp; nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l15.251"></a><span id="l15.251" class="difflineplus">+    RebuildView();</span>
<a href="#l15.252"></a><span id="l15.252" class="difflineplus">+</span>
<a href="#l15.253"></a><span id="l15.253" class="difflineplus">+  return rv;</span>
<a href="#l15.254"></a><span id="l15.254" class="difflineplus">+}</span>
<a href="#l15.255"></a><span id="l15.255" class="difflineplus">+</span>
<a href="#l15.256"></a><span id="l15.256" class="difflineplus">+nsresult </span>
<a href="#l15.257"></a><span id="l15.257" class="difflineplus">+nsMsgQuickSearchDBView::GetMessageEnumerator(nsISimpleEnumerator **enumerator)</span>
<a href="#l15.258"></a><span id="l15.258" class="difflineplus">+{</span>
<a href="#l15.259"></a><span id="l15.259" class="difflineplus">+  return GetViewEnumerator(enumerator);</span>
<a href="#l15.260"></a><span id="l15.260" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/base/src/nsMsgQuickSearchDBView.h</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgQuickSearchDBView.h</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -31,17 +31,17 @@</span>
<a href="#l16.4"></a><span id="l16.4">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l16.5"></a><span id="l16.5">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l16.6"></a><span id="l16.6">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l16.7"></a><span id="l16.7">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l16.8"></a><span id="l16.8">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l16.9"></a><span id="l16.9">  *</span>
<a href="#l16.10"></a><span id="l16.10">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l16.11"></a><span id="l16.11"> </span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-#ifndef _nsMsgQuickSearchDBViewsH_</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+#ifndef _nsMsgQuickSearchDBView_H_</span>
<a href="#l16.14"></a><span id="l16.14"> #define _nsMsgQuickSearchDBView_H_</span>
<a href="#l16.15"></a><span id="l16.15"> </span>
<a href="#l16.16"></a><span id="l16.16"> #include &quot;nsMsgThreadedDBView.h&quot;</span>
<a href="#l16.17"></a><span id="l16.17"> #include &quot;nsIMsgSearchNotify.h&quot;</span>
<a href="#l16.18"></a><span id="l16.18"> #include &quot;nsIMsgSearchSession.h&quot;</span>
<a href="#l16.19"></a><span id="l16.19"> #include &quot;nsCOMArray.h&quot;</span>
<a href="#l16.20"></a><span id="l16.20"> #include &quot;nsIMsgHdr.h&quot;</span>
<a href="#l16.21"></a><span id="l16.21"> </span>
<a href="#l16.22"></a><span id="l16.22" class="difflineat">@@ -54,35 +54,43 @@ public:</span>
<a href="#l16.23"></a><span id="l16.23"> </span>
<a href="#l16.24"></a><span id="l16.24">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l16.25"></a><span id="l16.25">   NS_DECL_NSIMSGSEARCHNOTIFY</span>
<a href="#l16.26"></a><span id="l16.26"> </span>
<a href="#l16.27"></a><span id="l16.27">   virtual const char * GetViewName(void) {return &quot;QuickSearchView&quot;; }</span>
<a href="#l16.28"></a><span id="l16.28">   NS_IMETHOD Open(nsIMsgFolder *folder, nsMsgViewSortTypeValue sortType, </span>
<a href="#l16.29"></a><span id="l16.29">                   nsMsgViewSortOrderValue sortOrder, </span>
<a href="#l16.30"></a><span id="l16.30">                   nsMsgViewFlagsTypeValue viewFlags, PRInt32 *pCount);</span>
<a href="#l16.31"></a><span id="l16.31" class="difflineplus">+  NS_IMETHOD OpenWithHdrs(nsISimpleEnumerator *aHeaders, </span>
<a href="#l16.32"></a><span id="l16.32" class="difflineplus">+                          nsMsgViewSortTypeValue aSortType, </span>
<a href="#l16.33"></a><span id="l16.33" class="difflineplus">+                          nsMsgViewSortOrderValue aSortOrder, </span>
<a href="#l16.34"></a><span id="l16.34" class="difflineplus">+                          nsMsgViewFlagsTypeValue aViewFlags, </span>
<a href="#l16.35"></a><span id="l16.35" class="difflineplus">+                          PRInt32 *aCount);</span>
<a href="#l16.36"></a><span id="l16.36">   NS_IMETHOD DoCommand(nsMsgViewCommandTypeValue aCommand);</span>
<a href="#l16.37"></a><span id="l16.37">   NS_IMETHOD GetViewType(nsMsgViewTypeValue *aViewType);</span>
<a href="#l16.38"></a><span id="l16.38" class="difflineplus">+  NS_IMETHOD SetViewFlags(nsMsgViewFlagsTypeValue aViewFlags);</span>
<a href="#l16.39"></a><span id="l16.39">   NS_IMETHOD SetSearchSession(nsIMsgSearchSession *aSearchSession);</span>
<a href="#l16.40"></a><span id="l16.40">   NS_IMETHOD GetSearchSession(nsIMsgSearchSession* *aSearchSession);</span>
<a href="#l16.41"></a><span id="l16.41">   NS_IMETHOD OnHdrFlagsChanged(nsIMsgDBHdr *aHdrChanged, PRUint32 aOldFlags, </span>
<a href="#l16.42"></a><span id="l16.42">                          PRUint32 aNewFlags, nsIDBChangeListener *aInstigator);</span>
<a href="#l16.43"></a><span id="l16.43">   NS_IMETHOD OnHdrPropertyChanged(nsIMsgDBHdr *aHdrToChange, PRBool aPreChange, PRUint32 *aStatus, </span>
<a href="#l16.44"></a><span id="l16.44">                                  nsIDBChangeListener * aInstigator);</span>
<a href="#l16.45"></a><span id="l16.45"> </span>
<a href="#l16.46"></a><span id="l16.46"> protected:</span>
<a href="#l16.47"></a><span id="l16.47">   nsWeakPtr m_searchSession;</span>
<a href="#l16.48"></a><span id="l16.48">   nsTArray&lt;nsMsgKey&gt; m_origKeys;</span>
<a href="#l16.49"></a><span id="l16.49">   PRBool    m_usingCachedHits;</span>
<a href="#l16.50"></a><span id="l16.50">   PRBool    m_cacheEmpty;</span>
<a href="#l16.51"></a><span id="l16.51">   nsCOMArray &lt;nsIMsgDBHdr&gt; m_hdrHits;</span>
<a href="#l16.52"></a><span id="l16.52" class="difflineplus">+  virtual nsresult AddHdr(nsIMsgDBHdr *msgHdr, nsMsgViewIndex *resultIndex = nsnull);</span>
<a href="#l16.53"></a><span id="l16.53">   virtual nsresult OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey, PRBool ensureListed);</span>
<a href="#l16.54"></a><span id="l16.54">   virtual nsresult DeleteMessages(nsIMsgWindow *window, nsMsgViewIndex *indices, PRInt32 numIndices, PRBool deleteStorage);</span>
<a href="#l16.55"></a><span id="l16.55">   virtual nsresult SortThreads(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder);</span>
<a href="#l16.56"></a><span id="l16.56">   virtual nsresult GetFirstMessageHdrToDisplayInThread(nsIMsgThread *threadHdr, nsIMsgDBHdr **result);</span>
<a href="#l16.57"></a><span id="l16.57">   virtual nsresult ExpansionDelta(nsMsgViewIndex index, PRInt32 *expansionDelta);</span>
<a href="#l16.58"></a><span id="l16.58">   virtual nsresult ListIdsInThread(nsIMsgThread *threadHdr, nsMsgViewIndex startOfThreadViewIndex, PRUint32 *pNumListed);</span>
<a href="#l16.59"></a><span id="l16.59" class="difflineplus">+  virtual nsresult GetMessageEnumerator(nsISimpleEnumerator **enumerator);</span>
<a href="#l16.60"></a><span id="l16.60">   void      SavePreSearchInfo();</span>
<a href="#l16.61"></a><span id="l16.61">   void      ClearPreSearchInfo();</span>
<a href="#l16.62"></a><span id="l16.62"> </span>
<a href="#l16.63"></a><span id="l16.63"> };</span>
<a href="#l16.64"></a><span id="l16.64"> </span>
<a href="#l16.65"></a><span id="l16.65"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/base/src/nsMsgSearchDBView.cpp</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgSearchDBView.cpp</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l17.4"></a><span id="l17.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l17.5"></a><span id="l17.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l17.6"></a><span id="l17.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l17.7"></a><span id="l17.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l17.8"></a><span id="l17.8">  *</span>
<a href="#l17.9"></a><span id="l17.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l17.10"></a><span id="l17.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l17.11"></a><span id="l17.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l17.12"></a><span id="l17.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l17.13"></a><span id="l17.13">  *</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineat">@@ -45,45 +45,79 @@</span>
<a href="#l17.15"></a><span id="l17.15"> #include &quot;nsMsgBaseCID.h&quot;</span>
<a href="#l17.16"></a><span id="l17.16"> #include &quot;nsIMsgCopyService.h&quot;</span>
<a href="#l17.17"></a><span id="l17.17"> #include &quot;nsICopyMsgStreamListener.h&quot;</span>
<a href="#l17.18"></a><span id="l17.18"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l17.19"></a><span id="l17.19"> #include &quot;nsITreeColumns.h&quot;</span>
<a href="#l17.20"></a><span id="l17.20"> #include &quot;nsIMsgMessageService.h&quot;</span>
<a href="#l17.21"></a><span id="l17.21"> #include &quot;nsAutoPtr.h&quot;</span>
<a href="#l17.22"></a><span id="l17.22"> #include &quot;nsIMutableArray.h&quot;</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineplus">+#include &quot;nsMsgGroupThread.h&quot;</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineplus">+#include &quot;nsIPrefService.h&quot;</span>
<a href="#l17.25"></a><span id="l17.25" class="difflineplus">+#include &quot;nsIPrefBranch.h&quot;</span>
<a href="#l17.26"></a><span id="l17.26" class="difflineplus">+</span>
<a href="#l17.27"></a><span id="l17.27" class="difflineplus">+static PRBool gReferenceOnlyThreading;</span>
<a href="#l17.28"></a><span id="l17.28"> </span>
<a href="#l17.29"></a><span id="l17.29"> nsMsgSearchDBView::nsMsgSearchDBView()</span>
<a href="#l17.30"></a><span id="l17.30"> {</span>
<a href="#l17.31"></a><span id="l17.31">   // don't try to display messages for the search pane.</span>
<a href="#l17.32"></a><span id="l17.32">   mSuppressMsgDisplay = PR_TRUE;</span>
<a href="#l17.33"></a><span id="l17.33" class="difflineplus">+  m_threadsTable.Init();</span>
<a href="#l17.34"></a><span id="l17.34" class="difflineplus">+  m_hdrsTable.Init();</span>
<a href="#l17.35"></a><span id="l17.35"> }</span>
<a href="#l17.36"></a><span id="l17.36"> </span>
<a href="#l17.37"></a><span id="l17.37"> nsMsgSearchDBView::~nsMsgSearchDBView()</span>
<a href="#l17.38"></a><span id="l17.38"> {	</span>
<a href="#l17.39"></a><span id="l17.39"> }</span>
<a href="#l17.40"></a><span id="l17.40"> </span>
<a href="#l17.41"></a><span id="l17.41" class="difflineminus">-NS_IMPL_ISUPPORTS_INHERITED3(nsMsgSearchDBView, nsMsgDBView, nsIMsgDBView, nsIMsgCopyServiceListener, nsIMsgSearchNotify)</span>
<a href="#l17.42"></a><span id="l17.42" class="difflineplus">+NS_IMPL_ISUPPORTS_INHERITED3(nsMsgSearchDBView, nsMsgDBView, nsIMsgDBView, </span>
<a href="#l17.43"></a><span id="l17.43" class="difflineplus">+                             nsIMsgCopyServiceListener, nsIMsgSearchNotify)</span>
<a href="#l17.44"></a><span id="l17.44"> </span>
<a href="#l17.45"></a><span id="l17.45" class="difflineminus">-NS_IMETHODIMP nsMsgSearchDBView::Open(nsIMsgFolder *folder, nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder, nsMsgViewFlagsTypeValue viewFlags, PRInt32 *pCount)</span>
<a href="#l17.46"></a><span id="l17.46" class="difflineplus">+NS_IMETHODIMP nsMsgSearchDBView::Open(nsIMsgFolder *folder, </span>
<a href="#l17.47"></a><span id="l17.47" class="difflineplus">+                                      nsMsgViewSortTypeValue sortType, </span>
<a href="#l17.48"></a><span id="l17.48" class="difflineplus">+                                      nsMsgViewSortOrderValue sortOrder, </span>
<a href="#l17.49"></a><span id="l17.49" class="difflineplus">+                                      nsMsgViewFlagsTypeValue viewFlags, </span>
<a href="#l17.50"></a><span id="l17.50" class="difflineplus">+                                      PRInt32 *pCount)</span>
<a href="#l17.51"></a><span id="l17.51"> {</span>
<a href="#l17.52"></a><span id="l17.52" class="difflineminus">-    nsresult rv = nsMsgDBView::Open(folder, sortType, sortOrder, viewFlags, pCount);</span>
<a href="#l17.53"></a><span id="l17.53" class="difflineplus">+  nsresult rv = nsMsgDBView::Open(folder, sortType, sortOrder, </span>
<a href="#l17.54"></a><span id="l17.54" class="difflineplus">+                                    viewFlags, pCount);</span>
<a href="#l17.55"></a><span id="l17.55" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.56"></a><span id="l17.56" class="difflineplus">+</span>
<a href="#l17.57"></a><span id="l17.57" class="difflineplus">+  nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l17.58"></a><span id="l17.58">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.59"></a><span id="l17.59" class="difflineplus">+  prefBranch-&gt;GetBoolPref(&quot;mail.strict_threading&quot;, &amp;gReferenceOnlyThreading);</span>
<a href="#l17.60"></a><span id="l17.60"> </span>
<a href="#l17.61"></a><span id="l17.61">     if (pCount)</span>
<a href="#l17.62"></a><span id="l17.62">       *pCount = 0;</span>
<a href="#l17.63"></a><span id="l17.63">     m_folder = nsnull;</span>
<a href="#l17.64"></a><span id="l17.64">     return rv;</span>
<a href="#l17.65"></a><span id="l17.65"> }</span>
<a href="#l17.66"></a><span id="l17.66"> </span>
<a href="#l17.67"></a><span id="l17.67" class="difflineplus">+</span>
<a href="#l17.68"></a><span id="l17.68" class="difflineplus">+PLDHashOperator</span>
<a href="#l17.69"></a><span id="l17.69" class="difflineplus">+nsMsgSearchDBView::ThreadTableCloner(const nsAString &amp;aKey, nsIMsgThread* aThread, void* aArg)</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineplus">+{</span>
<a href="#l17.71"></a><span id="l17.71" class="difflineplus">+  nsMsgSearchDBView* view = static_cast&lt;nsMsgSearchDBView*&gt;(aArg);</span>
<a href="#l17.72"></a><span id="l17.72" class="difflineplus">+  nsresult rv = view-&gt;m_threadsTable.Put(aKey, aThread);</span>
<a href="#l17.73"></a><span id="l17.73" class="difflineplus">+  return NS_SUCCEEDED(rv) ? PL_DHASH_NEXT : PL_DHASH_STOP;</span>
<a href="#l17.74"></a><span id="l17.74" class="difflineplus">+}</span>
<a href="#l17.75"></a><span id="l17.75" class="difflineplus">+</span>
<a href="#l17.76"></a><span id="l17.76" class="difflineplus">+PLDHashOperator</span>
<a href="#l17.77"></a><span id="l17.77" class="difflineplus">+nsMsgSearchDBView::MsgHdrTableCloner(const nsAString &amp;aKey, nsIMsgDBHdr* aMsgHdr, void* aArg)</span>
<a href="#l17.78"></a><span id="l17.78" class="difflineplus">+{</span>
<a href="#l17.79"></a><span id="l17.79" class="difflineplus">+  nsMsgSearchDBView* view = static_cast&lt;nsMsgSearchDBView*&gt;(aArg);</span>
<a href="#l17.80"></a><span id="l17.80" class="difflineplus">+  nsresult rv = view-&gt;m_hdrsTable.Put(aKey, aMsgHdr);</span>
<a href="#l17.81"></a><span id="l17.81" class="difflineplus">+  return NS_SUCCEEDED(rv) ? PL_DHASH_NEXT : PL_DHASH_STOP;</span>
<a href="#l17.82"></a><span id="l17.82" class="difflineplus">+}</span>
<a href="#l17.83"></a><span id="l17.83" class="difflineplus">+</span>
<a href="#l17.84"></a><span id="l17.84"> NS_IMETHODIMP</span>
<a href="#l17.85"></a><span id="l17.85"> nsMsgSearchDBView::CopyDBView(nsMsgDBView *aNewMsgDBView, nsIMessenger *aMessengerInstance, </span>
<a href="#l17.86"></a><span id="l17.86">                                        nsIMsgWindow *aMsgWindow, nsIMsgDBViewCommandUpdater *aCmdUpdater)</span>
<a href="#l17.87"></a><span id="l17.87"> {</span>
<a href="#l17.88"></a><span id="l17.88" class="difflineminus">-  nsMsgDBView::CopyDBView(aNewMsgDBView, aMessengerInstance, aMsgWindow, aCmdUpdater);</span>
<a href="#l17.89"></a><span id="l17.89" class="difflineplus">+  nsMsgGroupView::CopyDBView(aNewMsgDBView, aMessengerInstance, aMsgWindow, aCmdUpdater);</span>
<a href="#l17.90"></a><span id="l17.90">   nsMsgSearchDBView* newMsgDBView = (nsMsgSearchDBView *) aNewMsgDBView;</span>
<a href="#l17.91"></a><span id="l17.91"> </span>
<a href="#l17.92"></a><span id="l17.92">   // now copy all of our private member data</span>
<a href="#l17.93"></a><span id="l17.93">   newMsgDBView-&gt;mDestFolder = mDestFolder;</span>
<a href="#l17.94"></a><span id="l17.94">   newMsgDBView-&gt;mCommand = mCommand;</span>
<a href="#l17.95"></a><span id="l17.95">   newMsgDBView-&gt;mTotalIndices = mTotalIndices;</span>
<a href="#l17.96"></a><span id="l17.96">   newMsgDBView-&gt;mCurIndex = mCurIndex; </span>
<a href="#l17.97"></a><span id="l17.97">   newMsgDBView-&gt;m_folders.InsertObjectsAt(m_folders, 0);</span>
<a href="#l17.98"></a><span id="l17.98" class="difflineat">@@ -98,56 +132,173 @@ nsMsgSearchDBView::CopyDBView(nsMsgDBVie</span>
<a href="#l17.99"></a><span id="l17.99"> </span>
<a href="#l17.100"></a><span id="l17.100">   PRInt32 count = m_dbToUseList.Count(); </span>
<a href="#l17.101"></a><span id="l17.101">   for(PRInt32 i = 0; i &lt; count; i++)</span>
<a href="#l17.102"></a><span id="l17.102">   {</span>
<a href="#l17.103"></a><span id="l17.103">     newMsgDBView-&gt;m_dbToUseList.AppendObject(m_dbToUseList[i]);</span>
<a href="#l17.104"></a><span id="l17.104">     // register the new view with the database so it gets notifications</span>
<a href="#l17.105"></a><span id="l17.105">     m_dbToUseList[i]-&gt;AddListener(newMsgDBView);</span>
<a href="#l17.106"></a><span id="l17.106">   }</span>
<a href="#l17.107"></a><span id="l17.107" class="difflineminus">-</span>
<a href="#l17.108"></a><span id="l17.108" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)</span>
<a href="#l17.109"></a><span id="l17.109" class="difflineplus">+  {</span>
<a href="#l17.110"></a><span id="l17.110" class="difflineplus">+    // We need to clone the thread and msg hdr hash tables.</span>
<a href="#l17.111"></a><span id="l17.111" class="difflineplus">+    m_threadsTable.EnumerateRead(ThreadTableCloner, newMsgDBView);</span>
<a href="#l17.112"></a><span id="l17.112" class="difflineplus">+    m_hdrsTable.EnumerateRead(MsgHdrTableCloner, newMsgDBView);</span>
<a href="#l17.113"></a><span id="l17.113" class="difflineplus">+  }</span>
<a href="#l17.114"></a><span id="l17.114">   return NS_OK;</span>
<a href="#l17.115"></a><span id="l17.115"> }</span>
<a href="#l17.116"></a><span id="l17.116"> </span>
<a href="#l17.117"></a><span id="l17.117"> NS_IMETHODIMP nsMsgSearchDBView::Close()</span>
<a href="#l17.118"></a><span id="l17.118"> {</span>
<a href="#l17.119"></a><span id="l17.119">   PRInt32 count = m_dbToUseList.Count();</span>
<a href="#l17.120"></a><span id="l17.120">   </span>
<a href="#l17.121"></a><span id="l17.121">   for(PRInt32 i = 0; i &lt; count; i++)</span>
<a href="#l17.122"></a><span id="l17.122">     m_dbToUseList[i]-&gt;RemoveListener(this);</span>
<a href="#l17.123"></a><span id="l17.123"> </span>
<a href="#l17.124"></a><span id="l17.124">   m_dbToUseList.Clear();</span>
<a href="#l17.125"></a><span id="l17.125"> </span>
<a href="#l17.126"></a><span id="l17.126" class="difflineminus">-  return nsMsgDBView::Close();</span>
<a href="#l17.127"></a><span id="l17.127" class="difflineplus">+  return nsMsgGroupView::Close();</span>
<a href="#l17.128"></a><span id="l17.128"> }</span>
<a href="#l17.129"></a><span id="l17.129"> </span>
<a href="#l17.130"></a><span id="l17.130"> NS_IMETHODIMP nsMsgSearchDBView::GetCellText(PRInt32 aRow, nsITreeColumn* aCol, nsAString&amp; aValue)</span>
<a href="#l17.131"></a><span id="l17.131"> {</span>
<a href="#l17.132"></a><span id="l17.132">   const PRUnichar* colID;</span>
<a href="#l17.133"></a><span id="l17.133">   aCol-&gt;GetIdConst(&amp;colID);</span>
<a href="#l17.134"></a><span id="l17.134" class="difflineminus">-  if (colID[0] == 'l' &amp;&amp; colID[1] == 'o') // location, need to check for &quot;lo&quot; not just &quot;l&quot; to avoid &quot;label&quot; column</span>
<a href="#l17.135"></a><span id="l17.135" class="difflineplus">+  // location, need to check for &quot;lo&quot; not just &quot;l&quot; to avoid &quot;label&quot; column</span>
<a href="#l17.136"></a><span id="l17.136" class="difflineplus">+  if (colID[0] == 'l' &amp;&amp; colID[1] == 'o') </span>
<a href="#l17.137"></a><span id="l17.137">     return FetchLocation(aRow, aValue);</span>
<a href="#l17.138"></a><span id="l17.138">   else</span>
<a href="#l17.139"></a><span id="l17.139" class="difflineminus">-    return nsMsgDBView::GetCellText(aRow, aCol, aValue);</span>
<a href="#l17.140"></a><span id="l17.140" class="difflineplus">+    return nsMsgGroupView::GetCellText(aRow, aCol, aValue);</span>
<a href="#l17.141"></a><span id="l17.141"> }</span>
<a href="#l17.142"></a><span id="l17.142"> </span>
<a href="#l17.143"></a><span id="l17.143"> nsresult nsMsgSearchDBView::FetchLocation(PRInt32 aRow, nsAString&amp; aLocationString)</span>
<a href="#l17.144"></a><span id="l17.144"> {</span>
<a href="#l17.145"></a><span id="l17.145">   nsCOMPtr &lt;nsIMsgFolder&gt; folder;</span>
<a href="#l17.146"></a><span id="l17.146">   nsresult rv = GetFolderForViewIndex(aRow, getter_AddRefs(folder));</span>
<a href="#l17.147"></a><span id="l17.147">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l17.148"></a><span id="l17.148">   return folder-&gt;GetPrettiestName(aLocationString);</span>
<a href="#l17.149"></a><span id="l17.149"> }</span>
<a href="#l17.150"></a><span id="l17.150"> </span>
<a href="#l17.151"></a><span id="l17.151" class="difflineminus">-nsresult nsMsgSearchDBView::OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey, PRBool /*ensureListed*/)</span>
<a href="#l17.152"></a><span id="l17.152" class="difflineplus">+nsresult nsMsgSearchDBView::OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey,</span>
<a href="#l17.153"></a><span id="l17.153" class="difflineplus">+                                        PRBool /*ensureListed*/)</span>
<a href="#l17.154"></a><span id="l17.154"> {</span>
<a href="#l17.155"></a><span id="l17.155">    return NS_OK;</span>
<a href="#l17.156"></a><span id="l17.156"> }</span>
<a href="#l17.157"></a><span id="l17.157"> </span>
<a href="#l17.158"></a><span id="l17.158" class="difflineminus">-nsresult nsMsgSearchDBView::GetMsgHdrForViewIndex(nsMsgViewIndex index, nsIMsgDBHdr **msgHdr)</span>
<a href="#l17.159"></a><span id="l17.159" class="difflineplus">+NS_IMETHODIMP </span>
<a href="#l17.160"></a><span id="l17.160" class="difflineplus">+nsMsgSearchDBView::OnHdrDeleted(nsIMsgDBHdr *aHdrDeleted, nsMsgKey aParentKey, </span>
<a href="#l17.161"></a><span id="l17.161" class="difflineplus">+                                PRInt32 aFlags, nsIDBChangeListener *aInstigator)</span>
<a href="#l17.162"></a><span id="l17.162" class="difflineplus">+{</span>
<a href="#l17.163"></a><span id="l17.163" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l17.164"></a><span id="l17.164" class="difflineplus">+    return nsMsgGroupView::OnHdrDeleted(aHdrDeleted, aParentKey, </span>
<a href="#l17.165"></a><span id="l17.165" class="difflineplus">+                                        aFlags, aInstigator);</span>
<a href="#l17.166"></a><span id="l17.166" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)</span>
<a href="#l17.167"></a><span id="l17.167" class="difflineplus">+  {</span>
<a href="#l17.168"></a><span id="l17.168" class="difflineplus">+    nsMsgViewIndex deletedIndex = FindHdr(aHdrDeleted);</span>
<a href="#l17.169"></a><span id="l17.169" class="difflineplus">+    PRUint32 savedFlags = 0;</span>
<a href="#l17.170"></a><span id="l17.170" class="difflineplus">+    if (deletedIndex != nsMsgViewIndex_None)</span>
<a href="#l17.171"></a><span id="l17.171" class="difflineplus">+    {</span>
<a href="#l17.172"></a><span id="l17.172" class="difflineplus">+      savedFlags = m_flags[deletedIndex];</span>
<a href="#l17.173"></a><span id="l17.173" class="difflineplus">+      RemoveByIndex(deletedIndex);</span>
<a href="#l17.174"></a><span id="l17.174" class="difflineplus">+    }</span>
<a href="#l17.175"></a><span id="l17.175" class="difflineplus">+</span>
<a href="#l17.176"></a><span id="l17.176" class="difflineplus">+    nsCOMPtr&lt;nsIMsgThread&gt; thread;</span>
<a href="#l17.177"></a><span id="l17.177" class="difflineplus">+    GetXFThreadFromMsgHdr(aHdrDeleted, getter_AddRefs(thread));</span>
<a href="#l17.178"></a><span id="l17.178" class="difflineplus">+    if (thread)</span>
<a href="#l17.179"></a><span id="l17.179" class="difflineplus">+    {</span>
<a href="#l17.180"></a><span id="l17.180" class="difflineplus">+      nsMsgXFViewThread *viewThread = static_cast&lt;nsMsgXFViewThread*&gt;(thread.get());</span>
<a href="#l17.181"></a><span id="l17.181" class="difflineplus">+      viewThread-&gt;RemoveChildHdr(aHdrDeleted, nsnull);</span>
<a href="#l17.182"></a><span id="l17.182" class="difflineplus">+      if (deletedIndex == nsMsgViewIndex_None &amp;&amp; viewThread-&gt;MsgCount() == 1)</span>
<a href="#l17.183"></a><span id="l17.183" class="difflineplus">+      {</span>
<a href="#l17.184"></a><span id="l17.184" class="difflineplus">+        // remove the last child of a collapsed thread. Need to find the root,</span>
<a href="#l17.185"></a><span id="l17.185" class="difflineplus">+        // and remove the thread flags on it.</span>
<a href="#l17.186"></a><span id="l17.186" class="difflineplus">+        nsCOMPtr&lt;nsIMsgDBHdr&gt; rootHdr;</span>
<a href="#l17.187"></a><span id="l17.187" class="difflineplus">+        thread-&gt;GetRootHdr(nsnull, getter_AddRefs(rootHdr));</span>
<a href="#l17.188"></a><span id="l17.188" class="difflineplus">+        if (rootHdr)</span>
<a href="#l17.189"></a><span id="l17.189" class="difflineplus">+        {</span>
<a href="#l17.190"></a><span id="l17.190" class="difflineplus">+          nsMsgViewIndex threadIndex = GetThreadRootIndex(rootHdr);</span>
<a href="#l17.191"></a><span id="l17.191" class="difflineplus">+          if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l17.192"></a><span id="l17.192" class="difflineplus">+            AndExtraFlag(threadIndex, ~(MSG_VIEW_FLAG_ISTHREAD | </span>
<a href="#l17.193"></a><span id="l17.193" class="difflineplus">+                                        MSG_FLAG_ELIDED | </span>
<a href="#l17.194"></a><span id="l17.194" class="difflineplus">+                                        MSG_VIEW_FLAG_HASCHILDREN));</span>
<a href="#l17.195"></a><span id="l17.195" class="difflineplus">+        }</span>
<a href="#l17.196"></a><span id="l17.196" class="difflineplus">+      }</span>
<a href="#l17.197"></a><span id="l17.197" class="difflineplus">+      else if (savedFlags &amp; MSG_VIEW_FLAG_HASCHILDREN)</span>
<a href="#l17.198"></a><span id="l17.198" class="difflineplus">+{</span>
<a href="#l17.199"></a><span id="l17.199" class="difflineplus">+        if (savedFlags &amp; MSG_FLAG_ELIDED)</span>
<a href="#l17.200"></a><span id="l17.200" class="difflineplus">+        {</span>
<a href="#l17.201"></a><span id="l17.201" class="difflineplus">+          nsCOMPtr&lt;nsIMsgDBHdr&gt; rootHdr;</span>
<a href="#l17.202"></a><span id="l17.202" class="difflineplus">+          nsresult rv = thread-&gt;GetRootHdr(nsnull, getter_AddRefs(rootHdr));</span>
<a href="#l17.203"></a><span id="l17.203" class="difflineplus">+          NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.204"></a><span id="l17.204" class="difflineplus">+          nsMsgKey msgKey;</span>
<a href="#l17.205"></a><span id="l17.205" class="difflineplus">+          PRUint32 msgFlags;</span>
<a href="#l17.206"></a><span id="l17.206" class="difflineplus">+          rootHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l17.207"></a><span id="l17.207" class="difflineplus">+          rootHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l17.208"></a><span id="l17.208" class="difflineplus">+          // promote the new thread root</span>
<a href="#l17.209"></a><span id="l17.209" class="difflineplus">+          if (viewThread-&gt;MsgCount() &gt; 1)</span>
<a href="#l17.210"></a><span id="l17.210" class="difflineplus">+            msgFlags |= MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED | </span>
<a href="#l17.211"></a><span id="l17.211" class="difflineplus">+                        MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l17.212"></a><span id="l17.212" class="difflineplus">+          InsertMsgHdrAt(deletedIndex, rootHdr, msgKey, msgFlags, 0);</span>
<a href="#l17.213"></a><span id="l17.213" class="difflineplus">+          NoteChange(deletedIndex, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l17.214"></a><span id="l17.214" class="difflineplus">+        }</span>
<a href="#l17.215"></a><span id="l17.215" class="difflineplus">+        else if (viewThread-&gt;MsgCount() &gt; 1)</span>
<a href="#l17.216"></a><span id="l17.216" class="difflineplus">+        {</span>
<a href="#l17.217"></a><span id="l17.217" class="difflineplus">+          OrExtraFlag(deletedIndex, MSG_VIEW_FLAG_ISTHREAD |</span>
<a href="#l17.218"></a><span id="l17.218" class="difflineplus">+                                    MSG_VIEW_FLAG_HASCHILDREN);</span>
<a href="#l17.219"></a><span id="l17.219" class="difflineplus">+        }</span>
<a href="#l17.220"></a><span id="l17.220" class="difflineplus">+      }</span>
<a href="#l17.221"></a><span id="l17.221" class="difflineplus">+    }</span>
<a href="#l17.222"></a><span id="l17.222" class="difflineplus">+  }</span>
<a href="#l17.223"></a><span id="l17.223" class="difflineplus">+  else</span>
<a href="#l17.224"></a><span id="l17.224" class="difflineplus">+  {</span>
<a href="#l17.225"></a><span id="l17.225" class="difflineplus">+    return nsMsgDBView::OnHdrDeleted(aHdrDeleted, aParentKey, </span>
<a href="#l17.226"></a><span id="l17.226" class="difflineplus">+                                        aFlags, aInstigator);</span>
<a href="#l17.227"></a><span id="l17.227" class="difflineplus">+  }</span>
<a href="#l17.228"></a><span id="l17.228" class="difflineplus">+   return NS_OK;</span>
<a href="#l17.229"></a><span id="l17.229" class="difflineplus">+}</span>
<a href="#l17.230"></a><span id="l17.230" class="difflineplus">+</span>
<a href="#l17.231"></a><span id="l17.231" class="difflineplus">+void nsMsgSearchDBView::InsertMsgHdrAt(nsMsgViewIndex index, nsIMsgDBHdr *hdr,</span>
<a href="#l17.232"></a><span id="l17.232" class="difflineplus">+                              nsMsgKey msgKey, PRUint32 flags, PRUint32 level)</span>
<a href="#l17.233"></a><span id="l17.233" class="difflineplus">+{</span>
<a href="#l17.234"></a><span id="l17.234" class="difflineplus">+  m_keys.InsertElementAt(index, msgKey);</span>
<a href="#l17.235"></a><span id="l17.235" class="difflineplus">+  m_flags.InsertElementAt(index, flags);</span>
<a href="#l17.236"></a><span id="l17.236" class="difflineplus">+  m_levels.InsertElementAt(index, level);</span>
<a href="#l17.237"></a><span id="l17.237" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l17.238"></a><span id="l17.238" class="difflineplus">+  hdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l17.239"></a><span id="l17.239" class="difflineplus">+  m_folders.InsertObjectAt(folder, index);</span>
<a href="#l17.240"></a><span id="l17.240" class="difflineplus">+}</span>
<a href="#l17.241"></a><span id="l17.241" class="difflineplus">+</span>
<a href="#l17.242"></a><span id="l17.242" class="difflineplus">+void nsMsgSearchDBView::SetMsgHdrAt(nsIMsgDBHdr *hdr, nsMsgViewIndex index, </span>
<a href="#l17.243"></a><span id="l17.243" class="difflineplus">+                              nsMsgKey msgKey, PRUint32 flags, PRUint32 level)</span>
<a href="#l17.244"></a><span id="l17.244" class="difflineplus">+{</span>
<a href="#l17.245"></a><span id="l17.245" class="difflineplus">+  m_keys[index] = msgKey;</span>
<a href="#l17.246"></a><span id="l17.246" class="difflineplus">+  m_flags[index] = flags;</span>
<a href="#l17.247"></a><span id="l17.247" class="difflineplus">+  m_levels[index] = level;</span>
<a href="#l17.248"></a><span id="l17.248" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l17.249"></a><span id="l17.249" class="difflineplus">+  hdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l17.250"></a><span id="l17.250" class="difflineplus">+  m_folders.ReplaceObjectAt(folder, index);</span>
<a href="#l17.251"></a><span id="l17.251" class="difflineplus">+}</span>
<a href="#l17.252"></a><span id="l17.252" class="difflineplus">+</span>
<a href="#l17.253"></a><span id="l17.253" class="difflineplus">+PRBool nsMsgSearchDBView::InsertEmptyRows(nsMsgViewIndex viewIndex, PRInt32 numRows)</span>
<a href="#l17.254"></a><span id="l17.254" class="difflineplus">+{</span>
<a href="#l17.255"></a><span id="l17.255" class="difflineplus">+  for (PRInt32 i = 0; i &lt; numRows; i++)</span>
<a href="#l17.256"></a><span id="l17.256" class="difflineplus">+    if (!m_folders.InsertObjectAt(nsnull, viewIndex + i))</span>
<a href="#l17.257"></a><span id="l17.257" class="difflineplus">+      return PR_FALSE;</span>
<a href="#l17.258"></a><span id="l17.258" class="difflineplus">+  return nsMsgDBView::InsertEmptyRows(viewIndex, numRows);</span>
<a href="#l17.259"></a><span id="l17.259" class="difflineplus">+}</span>
<a href="#l17.260"></a><span id="l17.260" class="difflineplus">+</span>
<a href="#l17.261"></a><span id="l17.261" class="difflineplus">+void nsMsgSearchDBView::RemoveRows(nsMsgViewIndex viewIndex, PRInt32 numRows)</span>
<a href="#l17.262"></a><span id="l17.262" class="difflineplus">+{</span>
<a href="#l17.263"></a><span id="l17.263" class="difflineplus">+  nsMsgDBView::RemoveRows(viewIndex, numRows);</span>
<a href="#l17.264"></a><span id="l17.264" class="difflineplus">+  for (PRInt32 i = 0; i &lt; numRows; i++)</span>
<a href="#l17.265"></a><span id="l17.265" class="difflineplus">+    m_folders.RemoveObjectAt(viewIndex);</span>
<a href="#l17.266"></a><span id="l17.266" class="difflineplus">+}</span>
<a href="#l17.267"></a><span id="l17.267" class="difflineplus">+</span>
<a href="#l17.268"></a><span id="l17.268" class="difflineplus">+nsresult nsMsgSearchDBView::GetMsgHdrForViewIndex(nsMsgViewIndex index, </span>
<a href="#l17.269"></a><span id="l17.269" class="difflineplus">+                                                  nsIMsgDBHdr **msgHdr)</span>
<a href="#l17.270"></a><span id="l17.270"> {</span>
<a href="#l17.271"></a><span id="l17.271">   nsresult rv = NS_MSG_INVALID_DBVIEW_INDEX;</span>
<a href="#l17.272"></a><span id="l17.272">   if (index == nsMsgViewIndex_None || index &gt; (PRUint32) m_folders.Count())</span>
<a href="#l17.273"></a><span id="l17.273">     return rv;</span>
<a href="#l17.274"></a><span id="l17.274">   nsIMsgFolder *folder = m_folders[index];</span>
<a href="#l17.275"></a><span id="l17.275">   if (folder)</span>
<a href="#l17.276"></a><span id="l17.276">   {</span>
<a href="#l17.277"></a><span id="l17.277">     nsCOMPtr &lt;nsIMsgDatabase&gt; db;</span>
<a href="#l17.278"></a><span id="l17.278" class="difflineat">@@ -174,35 +325,237 @@ nsresult nsMsgSearchDBView::GetDBForView</span>
<a href="#l17.279"></a><span id="l17.279">   nsCOMPtr &lt;nsIMsgFolder&gt; aFolder;</span>
<a href="#l17.280"></a><span id="l17.280">   nsresult rv = GetFolderForViewIndex(index, getter_AddRefs(aFolder));</span>
<a href="#l17.281"></a><span id="l17.281">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.282"></a><span id="l17.282">   return aFolder-&gt;GetMsgDatabase(nsnull, db);</span>
<a href="#l17.283"></a><span id="l17.283"> }</span>
<a href="#l17.284"></a><span id="l17.284"> </span>
<a href="#l17.285"></a><span id="l17.285"> nsresult nsMsgSearchDBView::AddHdrFromFolder(nsIMsgDBHdr *msgHdr, nsIMsgFolder *folder)</span>
<a href="#l17.286"></a><span id="l17.286"> {</span>
<a href="#l17.287"></a><span id="l17.287" class="difflineminus">-  m_folders.AppendObject(folder);</span>
<a href="#l17.288"></a><span id="l17.288" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l17.289"></a><span id="l17.289" class="difflineplus">+    return nsMsgGroupView::OnNewHeader(msgHdr, nsMsgKey_None, PR_TRUE);</span>
<a href="#l17.290"></a><span id="l17.290">   nsMsgKey msgKey;</span>
<a href="#l17.291"></a><span id="l17.291">   PRUint32 msgFlags;</span>
<a href="#l17.292"></a><span id="l17.292">   msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l17.293"></a><span id="l17.293" class="difflineplus">+  msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l17.294"></a><span id="l17.294" class="difflineplus">+</span>
<a href="#l17.295"></a><span id="l17.295" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)</span>
<a href="#l17.296"></a><span id="l17.296" class="difflineplus">+  {</span>
<a href="#l17.297"></a><span id="l17.297" class="difflineplus">+    nsCOMPtr&lt;nsIMsgThread&gt; thread;</span>
<a href="#l17.298"></a><span id="l17.298" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; threadRoot;</span>
<a href="#l17.299"></a><span id="l17.299" class="difflineplus">+    // if we find an xf thread in the hash table corresponding to the new msg's</span>
<a href="#l17.300"></a><span id="l17.300" class="difflineplus">+    // message id, a previous header must be a reference child of the new </span>
<a href="#l17.301"></a><span id="l17.301" class="difflineplus">+    // message, which means we need to reparent later.</span>
<a href="#l17.302"></a><span id="l17.302" class="difflineplus">+    PRBool msgIsReferredTo;</span>
<a href="#l17.303"></a><span id="l17.303" class="difflineplus">+    GetXFThreadFromMsgHdr(msgHdr, getter_AddRefs(thread), &amp;msgIsReferredTo);</span>
<a href="#l17.304"></a><span id="l17.304" class="difflineplus">+    PRBool newThread = !thread;</span>
<a href="#l17.305"></a><span id="l17.305" class="difflineplus">+    nsMsgXFViewThread *viewThread;</span>
<a href="#l17.306"></a><span id="l17.306" class="difflineplus">+    if (!thread)</span>
<a href="#l17.307"></a><span id="l17.307" class="difflineplus">+    {</span>
<a href="#l17.308"></a><span id="l17.308" class="difflineplus">+      viewThread = new nsMsgXFViewThread(this);</span>
<a href="#l17.309"></a><span id="l17.309" class="difflineplus">+      if (!viewThread)</span>
<a href="#l17.310"></a><span id="l17.310" class="difflineplus">+        return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l17.311"></a><span id="l17.311" class="difflineplus">+      thread = do_QueryInterface(viewThread);</span>
<a href="#l17.312"></a><span id="l17.312" class="difflineplus">+    }</span>
<a href="#l17.313"></a><span id="l17.313" class="difflineplus">+    else</span>
<a href="#l17.314"></a><span id="l17.314" class="difflineplus">+    {</span>
<a href="#l17.315"></a><span id="l17.315" class="difflineplus">+      viewThread = static_cast&lt;nsMsgXFViewThread*&gt;(thread.get());</span>
<a href="#l17.316"></a><span id="l17.316" class="difflineplus">+      thread-&gt;GetChildAt(0, getter_AddRefs(threadRoot));</span>
<a href="#l17.317"></a><span id="l17.317" class="difflineplus">+    }</span>
<a href="#l17.318"></a><span id="l17.318" class="difflineplus">+</span>
<a href="#l17.319"></a><span id="l17.319" class="difflineplus">+    AddMsgToHashTables(msgHdr, thread);</span>
<a href="#l17.320"></a><span id="l17.320" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; parent;</span>
<a href="#l17.321"></a><span id="l17.321" class="difflineplus">+    PRUint32 posInThread;</span>
<a href="#l17.322"></a><span id="l17.322" class="difflineplus">+    // We need to move threads in order to keep ourselves sorted</span>
<a href="#l17.323"></a><span id="l17.323" class="difflineplus">+    // correctly.  We want the index of the original thread...we can do this by</span>
<a href="#l17.324"></a><span id="l17.324" class="difflineplus">+    // getting the root header before we add the new header, and finding that.</span>
<a href="#l17.325"></a><span id="l17.325" class="difflineplus">+    if (newThread || !viewThread-&gt;MsgCount())</span>
<a href="#l17.326"></a><span id="l17.326" class="difflineplus">+    {</span>
<a href="#l17.327"></a><span id="l17.327" class="difflineplus">+      viewThread-&gt;AddHdr(msgHdr, PR_FALSE, posInThread,</span>
<a href="#l17.328"></a><span id="l17.328" class="difflineplus">+                         getter_AddRefs(parent));</span>
<a href="#l17.329"></a><span id="l17.329" class="difflineplus">+      nsMsgViewIndex insertIndex = GetIndexForThread(msgHdr);</span>
<a href="#l17.330"></a><span id="l17.330" class="difflineplus">+      NS_ASSERTION(insertIndex == m_levels.Length() || !m_levels[insertIndex],</span>
<a href="#l17.331"></a><span id="l17.331" class="difflineplus">+                    &quot;inserting into middle of thread&quot;);</span>
<a href="#l17.332"></a><span id="l17.332" class="difflineplus">+      if (insertIndex == nsMsgViewIndex_None)</span>
<a href="#l17.333"></a><span id="l17.333" class="difflineplus">+        return NS_ERROR_FAILURE;</span>
<a href="#l17.334"></a><span id="l17.334" class="difflineplus">+      if (!(m_viewFlags &amp; nsMsgViewFlagsType::kExpandAll))</span>
<a href="#l17.335"></a><span id="l17.335" class="difflineplus">+        msgFlags |= MSG_FLAG_ELIDED;</span>
<a href="#l17.336"></a><span id="l17.336" class="difflineplus">+      InsertMsgHdrAt(insertIndex, msgHdr, msgKey, msgFlags, 0);</span>
<a href="#l17.337"></a><span id="l17.337" class="difflineplus">+      NoteChange(insertIndex, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l17.338"></a><span id="l17.338" class="difflineplus">+    }</span>
<a href="#l17.339"></a><span id="l17.339" class="difflineplus">+    else</span>
<a href="#l17.340"></a><span id="l17.340" class="difflineplus">+    {</span>
<a href="#l17.341"></a><span id="l17.341" class="difflineplus">+      // get the thread root index before we add the header, because adding</span>
<a href="#l17.342"></a><span id="l17.342" class="difflineplus">+      // the header can change the sort position.</span>
<a href="#l17.343"></a><span id="l17.343" class="difflineplus">+      nsMsgViewIndex threadIndex = GetThreadRootIndex(threadRoot);</span>
<a href="#l17.344"></a><span id="l17.344" class="difflineplus">+      NS_ASSERTION(!m_levels[threadIndex], &quot;threadRoot incorrect, or level incorrect&quot;);</span>
<a href="#l17.345"></a><span id="l17.345" class="difflineplus">+      viewThread-&gt;AddHdr(msgHdr, msgIsReferredTo, posInThread,</span>
<a href="#l17.346"></a><span id="l17.346" class="difflineplus">+                         getter_AddRefs(parent));</span>
<a href="#l17.347"></a><span id="l17.347" class="difflineplus">+</span>
<a href="#l17.348"></a><span id="l17.348" class="difflineplus">+      PRBool moveThread = PR_FALSE;</span>
<a href="#l17.349"></a><span id="l17.349" class="difflineplus">+      if (m_sortType == nsMsgViewSortType::byDate)</span>
<a href="#l17.350"></a><span id="l17.350" class="difflineplus">+      {</span>
<a href="#l17.351"></a><span id="l17.351" class="difflineplus">+        PRUint32 newestMsgInThread = 0, msgDate = 0;</span>
<a href="#l17.352"></a><span id="l17.352" class="difflineplus">+        viewThread-&gt;GetNewestMsgDate(&amp;newestMsgInThread);</span>
<a href="#l17.353"></a><span id="l17.353" class="difflineplus">+        msgHdr-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l17.354"></a><span id="l17.354" class="difflineplus">+        moveThread = (msgDate == newestMsgInThread);</span>
<a href="#l17.355"></a><span id="l17.355" class="difflineplus">+      }</span>
<a href="#l17.356"></a><span id="l17.356" class="difflineplus">+      OrExtraFlag(threadIndex, MSG_VIEW_FLAG_HASCHILDREN | MSG_VIEW_FLAG_ISTHREAD);</span>
<a href="#l17.357"></a><span id="l17.357" class="difflineplus">+      if (!(m_flags[threadIndex] &amp; MSG_FLAG_ELIDED))</span>
<a href="#l17.358"></a><span id="l17.358" class="difflineplus">+      {</span>
<a href="#l17.359"></a><span id="l17.359" class="difflineplus">+        if (parent)</span>
<a href="#l17.360"></a><span id="l17.360" class="difflineplus">+        {</span>
<a href="#l17.361"></a><span id="l17.361" class="difflineplus">+          // since we know posInThread, we just want to insert the new hdr</span>
<a href="#l17.362"></a><span id="l17.362" class="difflineplus">+          // at threadIndex + posInThread, and then rebuild the view until we</span>
<a href="#l17.363"></a><span id="l17.363" class="difflineplus">+          // get to a sibling of the new hdr.</span>
<a href="#l17.364"></a><span id="l17.364" class="difflineplus">+          PRUint8 newMsgLevel = viewThread-&gt;ChildLevelAt(posInThread);</span>
<a href="#l17.365"></a><span id="l17.365" class="difflineplus">+          InsertMsgHdrAt(threadIndex + posInThread, msgHdr, msgKey, msgFlags,</span>
<a href="#l17.366"></a><span id="l17.366" class="difflineplus">+                         newMsgLevel);</span>
<a href="#l17.367"></a><span id="l17.367" class="difflineplus">+</span>
<a href="#l17.368"></a><span id="l17.368" class="difflineplus">+          NoteChange(threadIndex + posInThread, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l17.369"></a><span id="l17.369" class="difflineplus">+          for (nsMsgViewIndex viewIndex = threadIndex + ++posInThread;</span>
<a href="#l17.370"></a><span id="l17.370" class="difflineplus">+               posInThread &lt; viewThread-&gt;MsgCount() &amp;&amp; </span>
<a href="#l17.371"></a><span id="l17.371" class="difflineplus">+               viewThread-&gt;ChildLevelAt(posInThread) &gt; newMsgLevel; viewIndex++)</span>
<a href="#l17.372"></a><span id="l17.372" class="difflineplus">+          {</span>
<a href="#l17.373"></a><span id="l17.373" class="difflineplus">+            m_levels[viewIndex] = viewThread-&gt;ChildLevelAt(posInThread++);</span>
<a href="#l17.374"></a><span id="l17.374" class="difflineplus">+          }</span>
<a href="#l17.375"></a><span id="l17.375" class="difflineplus">+</span>
<a href="#l17.376"></a><span id="l17.376" class="difflineplus">+        }</span>
<a href="#l17.377"></a><span id="l17.377" class="difflineplus">+        else // The new header is the root, so we need to adjust </span>
<a href="#l17.378"></a><span id="l17.378" class="difflineplus">+             // all the children.</span>
<a href="#l17.379"></a><span id="l17.379" class="difflineplus">+        {</span>
<a href="#l17.380"></a><span id="l17.380" class="difflineplus">+          InsertMsgHdrAt(threadIndex, msgHdr, msgKey, msgFlags, 0);</span>
<a href="#l17.381"></a><span id="l17.381" class="difflineplus">+</span>
<a href="#l17.382"></a><span id="l17.382" class="difflineplus">+          NoteChange(threadIndex, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l17.383"></a><span id="l17.383" class="difflineplus">+          nsMsgViewIndex i;</span>
<a href="#l17.384"></a><span id="l17.384" class="difflineplus">+          for (i = threadIndex + 1; </span>
<a href="#l17.385"></a><span id="l17.385" class="difflineplus">+               i &lt; m_keys.Length() &amp;&amp; (i == threadIndex + 1 || m_levels[i]); i++)</span>
<a href="#l17.386"></a><span id="l17.386" class="difflineplus">+            m_levels[i] = m_levels[i] + 1;</span>
<a href="#l17.387"></a><span id="l17.387" class="difflineplus">+          // turn off thread flags on old root.</span>
<a href="#l17.388"></a><span id="l17.388" class="difflineplus">+          AndExtraFlag(threadIndex + 1, ~(MSG_VIEW_FLAG_ISTHREAD | </span>
<a href="#l17.389"></a><span id="l17.389" class="difflineplus">+                                          MSG_FLAG_ELIDED | </span>
<a href="#l17.390"></a><span id="l17.390" class="difflineplus">+                                          MSG_VIEW_FLAG_HASCHILDREN));</span>
<a href="#l17.391"></a><span id="l17.391" class="difflineplus">+</span>
<a href="#l17.392"></a><span id="l17.392" class="difflineplus">+          NoteChange(threadIndex + 1, i - threadIndex + 1, </span>
<a href="#l17.393"></a><span id="l17.393" class="difflineplus">+                     nsMsgViewNotificationCode::changed);</span>
<a href="#l17.394"></a><span id="l17.394" class="difflineplus">+        }</span>
<a href="#l17.395"></a><span id="l17.395" class="difflineplus">+      }</span>
<a href="#l17.396"></a><span id="l17.396" class="difflineplus">+      else if (!parent)</span>
<a href="#l17.397"></a><span id="l17.397" class="difflineplus">+      {</span>
<a href="#l17.398"></a><span id="l17.398" class="difflineplus">+        // new parent came into collapsed thread</span>
<a href="#l17.399"></a><span id="l17.399" class="difflineplus">+        nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l17.400"></a><span id="l17.400" class="difflineplus">+        msgHdr-&gt;GetFolder(getter_AddRefs(msgFolder));</span>
<a href="#l17.401"></a><span id="l17.401" class="difflineplus">+        m_keys[threadIndex] = msgKey;</span>
<a href="#l17.402"></a><span id="l17.402" class="difflineplus">+        m_folders.ReplaceObjectAt(msgFolder, threadIndex);</span>
<a href="#l17.403"></a><span id="l17.403" class="difflineplus">+        m_flags[threadIndex] = msgFlags | MSG_VIEW_FLAG_ISTHREAD | </span>
<a href="#l17.404"></a><span id="l17.404" class="difflineplus">+                                          MSG_FLAG_ELIDED | </span>
<a href="#l17.405"></a><span id="l17.405" class="difflineplus">+                                          MSG_VIEW_FLAG_HASCHILDREN;</span>
<a href="#l17.406"></a><span id="l17.406" class="difflineplus">+        NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l17.407"></a><span id="l17.407" class="difflineplus">+</span>
<a href="#l17.408"></a><span id="l17.408" class="difflineplus">+      }</span>
<a href="#l17.409"></a><span id="l17.409" class="difflineplus">+      if (moveThread)</span>
<a href="#l17.410"></a><span id="l17.410" class="difflineplus">+        MoveThreadAt(threadIndex);</span>
<a href="#l17.411"></a><span id="l17.411" class="difflineplus">+    }</span>
<a href="#l17.412"></a><span id="l17.412" class="difflineplus">+  }</span>
<a href="#l17.413"></a><span id="l17.413" class="difflineplus">+  else</span>
<a href="#l17.414"></a><span id="l17.414" class="difflineplus">+  {</span>
<a href="#l17.415"></a><span id="l17.415" class="difflineplus">+    m_folders.AppendObject(folder);</span>
<a href="#l17.416"></a><span id="l17.416">   // nsMsgKey_None means it's not a valid hdr.</span>
<a href="#l17.417"></a><span id="l17.417">   if (msgKey != nsMsgKey_None)</span>
<a href="#l17.418"></a><span id="l17.418">   {</span>
<a href="#l17.419"></a><span id="l17.419">     msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l17.420"></a><span id="l17.420">     m_keys.AppendElement(msgKey);</span>
<a href="#l17.421"></a><span id="l17.421">     m_levels.AppendElement(0);</span>
<a href="#l17.422"></a><span id="l17.422">     m_flags.AppendElement(msgFlags);</span>
<a href="#l17.423"></a><span id="l17.423" class="difflineminus">-    </span>
<a href="#l17.424"></a><span id="l17.424" class="difflineminus">-    // this needs to be called after we add the key, since RowCountChanged() will call our GetRowCount()</span>
<a href="#l17.425"></a><span id="l17.425" class="difflineminus">-    if (mTree)</span>
<a href="#l17.426"></a><span id="l17.426" class="difflineminus">-      mTree-&gt;RowCountChanged(GetSize() - 1, 1);</span>
<a href="#l17.427"></a><span id="l17.427" class="difflineplus">+      NoteChange(GetSize() - 1, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l17.428"></a><span id="l17.428" class="difflineplus">+    }</span>
<a href="#l17.429"></a><span id="l17.429">   }</span>
<a href="#l17.430"></a><span id="l17.430">   return NS_OK;</span>
<a href="#l17.431"></a><span id="l17.431">   }</span>
<a href="#l17.432"></a><span id="l17.432"> </span>
<a href="#l17.433"></a><span id="l17.433" class="difflineplus">+// This method removes the thread at threadIndex from the view </span>
<a href="#l17.434"></a><span id="l17.434" class="difflineplus">+// and puts it back in its new position, determined by the sort order.</span>
<a href="#l17.435"></a><span id="l17.435" class="difflineplus">+// And, if the selection is affected, save and restore the selection.</span>
<a href="#l17.436"></a><span id="l17.436" class="difflineplus">+void nsMsgSearchDBView::MoveThreadAt(nsMsgViewIndex threadIndex)</span>
<a href="#l17.437"></a><span id="l17.437" class="difflineplus">+{</span>
<a href="#l17.438"></a><span id="l17.438" class="difflineplus">+  PRBool updatesSuppressed = mSuppressChangeNotification;</span>
<a href="#l17.439"></a><span id="l17.439" class="difflineplus">+  // Turn off tree notifications so that we don't reload the current message.</span>
<a href="#l17.440"></a><span id="l17.440" class="difflineplus">+  if (!updatesSuppressed)</span>
<a href="#l17.441"></a><span id="l17.441" class="difflineplus">+    DisableChangeUpdates();</span>
<a href="#l17.442"></a><span id="l17.442" class="difflineplus">+</span>
<a href="#l17.443"></a><span id="l17.443" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; threadHdr;</span>
<a href="#l17.444"></a><span id="l17.444" class="difflineplus">+  GetMsgHdrForViewIndex(threadIndex, getter_AddRefs(threadHdr));</span>
<a href="#l17.445"></a><span id="l17.445" class="difflineplus">+</span>
<a href="#l17.446"></a><span id="l17.446" class="difflineplus">+  PRUint32 saveFlags = m_flags[threadIndex];</span>
<a href="#l17.447"></a><span id="l17.447" class="difflineplus">+  PRBool threadIsExpanded = !(saveFlags &amp; MSG_FLAG_ELIDED);</span>
<a href="#l17.448"></a><span id="l17.448" class="difflineplus">+  PRInt32 childCount = 0;</span>
<a href="#l17.449"></a><span id="l17.449" class="difflineplus">+  nsMsgKey preservedKey;</span>
<a href="#l17.450"></a><span id="l17.450" class="difflineplus">+  nsAutoTArray&lt;nsMsgKey, 1&gt; preservedSelection;</span>
<a href="#l17.451"></a><span id="l17.451" class="difflineplus">+  PRInt32 selCount;</span>
<a href="#l17.452"></a><span id="l17.452" class="difflineplus">+</span>
<a href="#l17.453"></a><span id="l17.453" class="difflineplus">+  SaveAndClearSelection(&amp;preservedKey, preservedSelection);</span>
<a href="#l17.454"></a><span id="l17.454" class="difflineplus">+  if (threadIsExpanded)</span>
<a href="#l17.455"></a><span id="l17.455" class="difflineplus">+  {</span>
<a href="#l17.456"></a><span id="l17.456" class="difflineplus">+    ExpansionDelta(threadIndex, &amp;childCount);</span>
<a href="#l17.457"></a><span id="l17.457" class="difflineplus">+    childCount = -childCount;</span>
<a href="#l17.458"></a><span id="l17.458" class="difflineplus">+  }</span>
<a href="#l17.459"></a><span id="l17.459" class="difflineplus">+  nsTArray&lt;nsMsgKey&gt; threadKeys;</span>
<a href="#l17.460"></a><span id="l17.460" class="difflineplus">+  nsTArray&lt;PRUint32&gt; threadFlags;</span>
<a href="#l17.461"></a><span id="l17.461" class="difflineplus">+  nsTArray&lt;PRUint8&gt; threadLevels;</span>
<a href="#l17.462"></a><span id="l17.462" class="difflineplus">+  nsCOMArray&lt;nsIMsgFolder&gt; threadFolders;</span>
<a href="#l17.463"></a><span id="l17.463" class="difflineplus">+</span>
<a href="#l17.464"></a><span id="l17.464" class="difflineplus">+  if (threadIsExpanded)</span>
<a href="#l17.465"></a><span id="l17.465" class="difflineplus">+  {</span>
<a href="#l17.466"></a><span id="l17.466" class="difflineplus">+    threadKeys.SetCapacity(childCount);</span>
<a href="#l17.467"></a><span id="l17.467" class="difflineplus">+    threadFlags.SetCapacity(childCount);</span>
<a href="#l17.468"></a><span id="l17.468" class="difflineplus">+    threadLevels.SetCapacity(childCount);</span>
<a href="#l17.469"></a><span id="l17.469" class="difflineplus">+    threadFolders.SetCapacity(childCount);</span>
<a href="#l17.470"></a><span id="l17.470" class="difflineplus">+    for (nsMsgViewIndex index = threadIndex + 1; </span>
<a href="#l17.471"></a><span id="l17.471" class="difflineplus">+        index &lt; (nsMsgViewIndex) GetSize() &amp;&amp; m_levels[index]; index++)</span>
<a href="#l17.472"></a><span id="l17.472" class="difflineplus">+    {</span>
<a href="#l17.473"></a><span id="l17.473" class="difflineplus">+      threadKeys.AppendElement(m_keys[index]);</span>
<a href="#l17.474"></a><span id="l17.474" class="difflineplus">+      threadFlags.AppendElement(m_flags[index]);</span>
<a href="#l17.475"></a><span id="l17.475" class="difflineplus">+      threadLevels.AppendElement(m_levels[index]);</span>
<a href="#l17.476"></a><span id="l17.476" class="difflineplus">+      threadFolders.AppendObject(m_folders[index]);</span>
<a href="#l17.477"></a><span id="l17.477" class="difflineplus">+    }</span>
<a href="#l17.478"></a><span id="l17.478" class="difflineplus">+    PRUint32 collapseCount;</span>
<a href="#l17.479"></a><span id="l17.479" class="difflineplus">+    CollapseByIndex(threadIndex, &amp;collapseCount);</span>
<a href="#l17.480"></a><span id="l17.480" class="difflineplus">+  }</span>
<a href="#l17.481"></a><span id="l17.481" class="difflineplus">+  nsMsgDBView::RemoveByIndex(threadIndex);</span>
<a href="#l17.482"></a><span id="l17.482" class="difflineplus">+  m_folders.RemoveObjectAt(threadIndex);</span>
<a href="#l17.483"></a><span id="l17.483" class="difflineplus">+  nsMsgViewIndex newIndex = GetIndexForThread(threadHdr);</span>
<a href="#l17.484"></a><span id="l17.484" class="difflineplus">+  NS_ASSERTION(newIndex == m_levels.Length() || !m_levels[newIndex],</span>
<a href="#l17.485"></a><span id="l17.485" class="difflineplus">+                &quot;inserting into middle of thread&quot;);</span>
<a href="#l17.486"></a><span id="l17.486" class="difflineplus">+  if (newIndex == nsMsgViewIndex_None)</span>
<a href="#l17.487"></a><span id="l17.487" class="difflineplus">+    newIndex = 0;</span>
<a href="#l17.488"></a><span id="l17.488" class="difflineplus">+  nsMsgKey msgKey;</span>
<a href="#l17.489"></a><span id="l17.489" class="difflineplus">+  PRUint32 msgFlags;</span>
<a href="#l17.490"></a><span id="l17.490" class="difflineplus">+  threadHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l17.491"></a><span id="l17.491" class="difflineplus">+  threadHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l17.492"></a><span id="l17.492" class="difflineplus">+  InsertMsgHdrAt(newIndex, threadHdr, msgKey, msgFlags, 0);</span>
<a href="#l17.493"></a><span id="l17.493" class="difflineplus">+</span>
<a href="#l17.494"></a><span id="l17.494" class="difflineplus">+  if (threadIsExpanded)</span>
<a href="#l17.495"></a><span id="l17.495" class="difflineplus">+  {</span>
<a href="#l17.496"></a><span id="l17.496" class="difflineplus">+    m_keys.InsertElementsAt(newIndex + 1, threadKeys);</span>
<a href="#l17.497"></a><span id="l17.497" class="difflineplus">+    m_flags.InsertElementsAt(newIndex + 1, threadFlags);</span>
<a href="#l17.498"></a><span id="l17.498" class="difflineplus">+    m_levels.InsertElementsAt(newIndex + 1, threadLevels);</span>
<a href="#l17.499"></a><span id="l17.499" class="difflineplus">+    m_folders.InsertObjectsAt(threadFolders, newIndex + 1);</span>
<a href="#l17.500"></a><span id="l17.500" class="difflineplus">+  }</span>
<a href="#l17.501"></a><span id="l17.501" class="difflineplus">+  m_flags[newIndex] = saveFlags;</span>
<a href="#l17.502"></a><span id="l17.502" class="difflineplus">+  // unfreeze selection.</span>
<a href="#l17.503"></a><span id="l17.503" class="difflineplus">+  RestoreSelection(preservedKey, preservedSelection);</span>
<a href="#l17.504"></a><span id="l17.504" class="difflineplus">+</span>
<a href="#l17.505"></a><span id="l17.505" class="difflineplus">+  if (!updatesSuppressed)</span>
<a href="#l17.506"></a><span id="l17.506" class="difflineplus">+    EnableChangeUpdates();</span>
<a href="#l17.507"></a><span id="l17.507" class="difflineplus">+  nsMsgViewIndex lowIndex = threadIndex &lt; newIndex ? threadIndex : newIndex;</span>
<a href="#l17.508"></a><span id="l17.508" class="difflineplus">+  nsMsgViewIndex highIndex = lowIndex == threadIndex ? newIndex : threadIndex;</span>
<a href="#l17.509"></a><span id="l17.509" class="difflineplus">+  NoteChange(lowIndex, highIndex - lowIndex + childCount, </span>
<a href="#l17.510"></a><span id="l17.510" class="difflineplus">+              nsMsgViewNotificationCode::changed);</span>
<a href="#l17.511"></a><span id="l17.511" class="difflineplus">+}</span>
<a href="#l17.512"></a><span id="l17.512" class="difflineplus">+</span>
<a href="#l17.513"></a><span id="l17.513"> NS_IMETHODIMP</span>
<a href="#l17.514"></a><span id="l17.514"> nsMsgSearchDBView::OnSearchHit(nsIMsgDBHdr* aMsgHdr, nsIMsgFolder *folder)</span>
<a href="#l17.515"></a><span id="l17.515"> {</span>
<a href="#l17.516"></a><span id="l17.516">   NS_ENSURE_ARG(aMsgHdr);</span>
<a href="#l17.517"></a><span id="l17.517">   NS_ENSURE_ARG(folder);</span>
<a href="#l17.518"></a><span id="l17.518"> </span>
<a href="#l17.519"></a><span id="l17.519">   if (m_folders.IndexOf(folder) &lt; 0 ) //do this just for new folder</span>
<a href="#l17.520"></a><span id="l17.520">   {</span>
<a href="#l17.521"></a><span id="l17.521" class="difflineat">@@ -289,25 +642,27 @@ nsMsgSearchDBView::GetCommandStatus(nsMs</span>
<a href="#l17.522"></a><span id="l17.522">   return NS_OK;</span>
<a href="#l17.523"></a><span id="l17.523"> }</span>
<a href="#l17.524"></a><span id="l17.524"> </span>
<a href="#l17.525"></a><span id="l17.525"> NS_IMETHODIMP </span>
<a href="#l17.526"></a><span id="l17.526"> nsMsgSearchDBView::DoCommandWithFolder(nsMsgViewCommandTypeValue command, nsIMsgFolder *destFolder)</span>
<a href="#l17.527"></a><span id="l17.527"> {</span>
<a href="#l17.528"></a><span id="l17.528">     mCommand = command;</span>
<a href="#l17.529"></a><span id="l17.529">     mDestFolder = destFolder;</span>
<a href="#l17.530"></a><span id="l17.530" class="difflineminus">-</span>
<a href="#l17.531"></a><span id="l17.531">     return nsMsgDBView::DoCommandWithFolder(command, destFolder);</span>
<a href="#l17.532"></a><span id="l17.532"> }</span>
<a href="#l17.533"></a><span id="l17.533"> </span>
<a href="#l17.534"></a><span id="l17.534"> NS_IMETHODIMP nsMsgSearchDBView::DoCommand(nsMsgViewCommandTypeValue command)</span>
<a href="#l17.535"></a><span id="l17.535"> {</span>
<a href="#l17.536"></a><span id="l17.536">   mCommand = command;</span>
<a href="#l17.537"></a><span id="l17.537" class="difflineminus">-  if (command == nsMsgViewCommandType::deleteMsg || command == nsMsgViewCommandType::deleteNoTrash</span>
<a href="#l17.538"></a><span id="l17.538" class="difflineminus">-    || command == nsMsgViewCommandType::selectAll)</span>
<a href="#l17.539"></a><span id="l17.539" class="difflineplus">+  if (command == nsMsgViewCommandType::deleteMsg || </span>
<a href="#l17.540"></a><span id="l17.540" class="difflineplus">+      command == nsMsgViewCommandType::deleteNoTrash ||</span>
<a href="#l17.541"></a><span id="l17.541" class="difflineplus">+      command == nsMsgViewCommandType::selectAll || </span>
<a href="#l17.542"></a><span id="l17.542" class="difflineplus">+      command ==nsMsgViewCommandType::expandAll ||</span>
<a href="#l17.543"></a><span id="l17.543" class="difflineplus">+      command == nsMsgViewCommandType::collapseAll)</span>
<a href="#l17.544"></a><span id="l17.544">     return nsMsgDBView::DoCommand(command);</span>
<a href="#l17.545"></a><span id="l17.545">   nsresult rv = NS_OK;</span>
<a href="#l17.546"></a><span id="l17.546">   nsMsgViewIndexArray selection;</span>
<a href="#l17.547"></a><span id="l17.547">   GetSelectedIndices(selection);</span>
<a href="#l17.548"></a><span id="l17.548"> </span>
<a href="#l17.549"></a><span id="l17.549">   nsMsgViewIndex *indices = selection.Elements();</span>
<a href="#l17.550"></a><span id="l17.550">   PRInt32 numIndices = selection.Length();</span>
<a href="#l17.551"></a><span id="l17.551"> </span>
<a href="#l17.552"></a><span id="l17.552" class="difflineat">@@ -323,25 +678,65 @@ NS_IMETHODIMP nsMsgSearchDBView::DoComma</span>
<a href="#l17.553"></a><span id="l17.553">   {</span>
<a href="#l17.554"></a><span id="l17.554">     rv = ApplyCommandToIndices(command, indexArrays[folderIndex].Elements(), indexArrays[folderIndex].Length());</span>
<a href="#l17.555"></a><span id="l17.555">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.556"></a><span id="l17.556">   }</span>
<a href="#l17.557"></a><span id="l17.557"> </span>
<a href="#l17.558"></a><span id="l17.558">   return rv;</span>
<a href="#l17.559"></a><span id="l17.559"> }</span>
<a href="#l17.560"></a><span id="l17.560"> </span>
<a href="#l17.561"></a><span id="l17.561" class="difflineminus">-// This method just removes the specified line from the view. It does</span>
<a href="#l17.562"></a><span id="l17.562" class="difflineminus">-// NOT delete it from the database.</span>
<a href="#l17.563"></a><span id="l17.563" class="difflineplus">+// This method removes the specified line from the view, and adjusts the</span>
<a href="#l17.564"></a><span id="l17.564" class="difflineplus">+// various flags and levels of affected messages.</span>
<a href="#l17.565"></a><span id="l17.565"> nsresult nsMsgSearchDBView::RemoveByIndex(nsMsgViewIndex index)</span>
<a href="#l17.566"></a><span id="l17.566"> {</span>
<a href="#l17.567"></a><span id="l17.567">     if (!IsValidIndex(index))</span>
<a href="#l17.568"></a><span id="l17.568">         return NS_MSG_INVALID_DBVIEW_INDEX;</span>
<a href="#l17.569"></a><span id="l17.569"> </span>
<a href="#l17.570"></a><span id="l17.570" class="difflineminus">-    m_folders.RemoveObjectAt(index);</span>
<a href="#l17.571"></a><span id="l17.571" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)</span>
<a href="#l17.572"></a><span id="l17.572" class="difflineplus">+  {</span>
<a href="#l17.573"></a><span id="l17.573" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l17.574"></a><span id="l17.574" class="difflineplus">+    nsCOMPtr&lt;nsIMsgThread&gt; thread;</span>
<a href="#l17.575"></a><span id="l17.575" class="difflineplus">+    nsresult rv = GetMsgHdrForViewIndex(index, getter_AddRefs(msgHdr));</span>
<a href="#l17.576"></a><span id="l17.576" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.577"></a><span id="l17.577">     </span>
<a href="#l17.578"></a><span id="l17.578" class="difflineplus">+    GetXFThreadFromMsgHdr(msgHdr, getter_AddRefs(thread));</span>
<a href="#l17.579"></a><span id="l17.579" class="difflineplus">+    if (thread)</span>
<a href="#l17.580"></a><span id="l17.580" class="difflineplus">+    {</span>
<a href="#l17.581"></a><span id="l17.581" class="difflineplus">+      nsMsgXFViewThread *viewThread = static_cast&lt;nsMsgXFViewThread*&gt;(thread.get());</span>
<a href="#l17.582"></a><span id="l17.582" class="difflineplus">+      if (viewThread-&gt;MsgCount() == 2)</span>
<a href="#l17.583"></a><span id="l17.583" class="difflineplus">+      {</span>
<a href="#l17.584"></a><span id="l17.584" class="difflineplus">+        // if we removed the next to last message in the thread,</span>
<a href="#l17.585"></a><span id="l17.585" class="difflineplus">+        // we need to adjust the flags on the first message in the thread.</span>
<a href="#l17.586"></a><span id="l17.586" class="difflineplus">+        nsMsgViewIndex threadIndex = m_levels[index] ? index -1 : index;</span>
<a href="#l17.587"></a><span id="l17.587" class="difflineplus">+        if (threadIndex != nsMsgViewIndex_None)</span>
<a href="#l17.588"></a><span id="l17.588" class="difflineplus">+        {</span>
<a href="#l17.589"></a><span id="l17.589" class="difflineplus">+          AndExtraFlag(threadIndex, ~(MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED |</span>
<a href="#l17.590"></a><span id="l17.590" class="difflineplus">+                                      MSG_VIEW_FLAG_HASCHILDREN));</span>
<a href="#l17.591"></a><span id="l17.591" class="difflineplus">+          m_levels[threadIndex] = 0;</span>
<a href="#l17.592"></a><span id="l17.592" class="difflineplus">+          NoteChange(threadIndex, 1, nsMsgViewNotificationCode::changed);</span>
<a href="#l17.593"></a><span id="l17.593" class="difflineplus">+        }</span>
<a href="#l17.594"></a><span id="l17.594" class="difflineplus">+      }</span>
<a href="#l17.595"></a><span id="l17.595" class="difflineplus">+      // Bump up the level of all the descendents of the message</span>
<a href="#l17.596"></a><span id="l17.596" class="difflineplus">+      // that was removed, if the thread was expanded.</span>
<a href="#l17.597"></a><span id="l17.597" class="difflineplus">+      PRUint8 removedLevel = m_levels[index];</span>
<a href="#l17.598"></a><span id="l17.598" class="difflineplus">+      nsMsgViewIndex i = index + 1;</span>
<a href="#l17.599"></a><span id="l17.599" class="difflineplus">+      if (i &lt; m_levels.Length() &amp;&amp; m_levels[i] &gt; removedLevel)</span>
<a href="#l17.600"></a><span id="l17.600" class="difflineplus">+      {</span>
<a href="#l17.601"></a><span id="l17.601" class="difflineplus">+        // promote the child of the removed message.</span>
<a href="#l17.602"></a><span id="l17.602" class="difflineplus">+        PRUint8 promotedLevel = m_levels[i];</span>
<a href="#l17.603"></a><span id="l17.603" class="difflineplus">+        m_levels[i] = promotedLevel - 1;</span>
<a href="#l17.604"></a><span id="l17.604" class="difflineplus">+        i++;</span>
<a href="#l17.605"></a><span id="l17.605" class="difflineplus">+        // now promote all the children of the promoted message.</span>
<a href="#l17.606"></a><span id="l17.606" class="difflineplus">+        for (; i &lt; m_levels.Length() &amp;&amp; </span>
<a href="#l17.607"></a><span id="l17.607" class="difflineplus">+              m_levels[i] &gt; promotedLevel; i++)</span>
<a href="#l17.608"></a><span id="l17.608" class="difflineplus">+          m_levels[i] = m_levels[i] - 1;</span>
<a href="#l17.609"></a><span id="l17.609" class="difflineplus">+      }</span>
<a href="#l17.610"></a><span id="l17.610" class="difflineplus">+    }</span>
<a href="#l17.611"></a><span id="l17.611" class="difflineplus">+  }</span>
<a href="#l17.612"></a><span id="l17.612" class="difflineplus">+  m_folders.RemoveObjectAt(index);</span>
<a href="#l17.613"></a><span id="l17.613">     return nsMsgDBView::RemoveByIndex(index);</span>
<a href="#l17.614"></a><span id="l17.614"> }</span>
<a href="#l17.615"></a><span id="l17.615"> </span>
<a href="#l17.616"></a><span id="l17.616"> nsresult nsMsgSearchDBView::DeleteMessages(nsIMsgWindow *window, nsMsgViewIndex *indices, PRInt32 numIndices, PRBool deleteStorage)</span>
<a href="#l17.617"></a><span id="l17.617"> {</span>
<a href="#l17.618"></a><span id="l17.618">    nsresult rv;</span>
<a href="#l17.619"></a><span id="l17.619">    GetFoldersAndHdrsForSelection(indices, numIndices);</span>
<a href="#l17.620"></a><span id="l17.620">    if (mDeleteModel != nsMsgImapDeleteModels::MoveToTrash)</span>
<a href="#l17.621"></a><span id="l17.621" class="difflineat">@@ -362,22 +757,18 @@ nsresult nsMsgSearchDBView::DeleteMessag</span>
<a href="#l17.622"></a><span id="l17.622">     else</span>
<a href="#l17.623"></a><span id="l17.623">       rv = ProcessRequestsInAllFolders(window);</span>
<a href="#l17.624"></a><span id="l17.624">     return rv;</span>
<a href="#l17.625"></a><span id="l17.625"> }</span>
<a href="#l17.626"></a><span id="l17.626"> </span>
<a href="#l17.627"></a><span id="l17.627"> nsresult </span>
<a href="#l17.628"></a><span id="l17.628"> nsMsgSearchDBView::CopyMessages(nsIMsgWindow *window, nsMsgViewIndex *indices, PRInt32 numIndices, PRBool isMove, nsIMsgFolder *destFolder)</span>
<a href="#l17.629"></a><span id="l17.629"> {</span>
<a href="#l17.630"></a><span id="l17.630" class="difflineminus">-    nsresult rv;</span>
<a href="#l17.631"></a><span id="l17.631">     GetFoldersAndHdrsForSelection(indices, numIndices);</span>
<a href="#l17.632"></a><span id="l17.632" class="difflineminus">-</span>
<a href="#l17.633"></a><span id="l17.633" class="difflineminus">-    rv = ProcessRequestsInOneFolder(window);</span>
<a href="#l17.634"></a><span id="l17.634" class="difflineminus">-</span>
<a href="#l17.635"></a><span id="l17.635" class="difflineminus">-    return rv;</span>
<a href="#l17.636"></a><span id="l17.636" class="difflineplus">+    return ProcessRequestsInOneFolder(window);</span>
<a href="#l17.637"></a><span id="l17.637"> }</span>
<a href="#l17.638"></a><span id="l17.638"> </span>
<a href="#l17.639"></a><span id="l17.639"> nsresult</span>
<a href="#l17.640"></a><span id="l17.640"> nsMsgSearchDBView::PartitionSelectionByFolder(nsMsgViewIndex *indices, PRInt32 numIndices, nsTArray&lt;PRUint32&gt; **indexArrays, PRInt32 *numArrays)</span>
<a href="#l17.641"></a><span id="l17.641"> {</span>
<a href="#l17.642"></a><span id="l17.642">   nsMsgViewIndex i;</span>
<a href="#l17.643"></a><span id="l17.643">   PRInt32 folderIndex;</span>
<a href="#l17.644"></a><span id="l17.644">   nsCOMArray&lt;nsIMsgFolder&gt; uniqueFoldersSelected;</span>
<a href="#l17.645"></a><span id="l17.645" class="difflineat">@@ -564,42 +955,49 @@ nsresult nsMsgSearchDBView::ProcessReque</span>
<a href="#l17.646"></a><span id="l17.646"> </span>
<a href="#l17.647"></a><span id="l17.647">     curFolder-&gt;DeleteMessages(messageArray, window, PR_TRUE /* delete storage */, PR_FALSE /* is move*/, nsnull/*copyServListener*/, PR_FALSE /*allowUndo*/ );</span>
<a href="#l17.648"></a><span id="l17.648">   }</span>
<a href="#l17.649"></a><span id="l17.649">   return NS_OK;</span>
<a href="#l17.650"></a><span id="l17.650"> }</span>
<a href="#l17.651"></a><span id="l17.651"> </span>
<a href="#l17.652"></a><span id="l17.652"> NS_IMETHODIMP nsMsgSearchDBView::Sort(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l17.653"></a><span id="l17.653"> {</span>
<a href="#l17.654"></a><span id="l17.654" class="difflineminus">-    nsresult rv;</span>
<a href="#l17.655"></a><span id="l17.655">     PRInt32 rowCountBeforeSort = GetSize();</span>
<a href="#l17.656"></a><span id="l17.656"> </span>
<a href="#l17.657"></a><span id="l17.657">     if (!rowCountBeforeSort)</span>
<a href="#l17.658"></a><span id="l17.658">         return NS_OK;</span>
<a href="#l17.659"></a><span id="l17.659"> </span>
<a href="#l17.660"></a><span id="l17.660" class="difflineplus">+    if (m_viewFlags &amp; (nsMsgViewFlagsType::kThreadedDisplay |</span>
<a href="#l17.661"></a><span id="l17.661" class="difflineplus">+                      nsMsgViewFlagsType::kGroupBySort))</span>
<a href="#l17.662"></a><span id="l17.662" class="difflineplus">+    {</span>
<a href="#l17.663"></a><span id="l17.663" class="difflineplus">+      // ### This forgets which threads were expanded, and is sub-optimal</span>
<a href="#l17.664"></a><span id="l17.664" class="difflineplus">+      // since it rebuilds the thread objects.  </span>
<a href="#l17.665"></a><span id="l17.665" class="difflineplus">+      m_sortType = sortType;</span>
<a href="#l17.666"></a><span id="l17.666" class="difflineplus">+      m_sortOrder = sortOrder;</span>
<a href="#l17.667"></a><span id="l17.667" class="difflineplus">+      return RebuildView();</span>
<a href="#l17.668"></a><span id="l17.668" class="difflineplus">+    }</span>
<a href="#l17.669"></a><span id="l17.669" class="difflineplus">+</span>
<a href="#l17.670"></a><span id="l17.670">     nsMsgKey preservedKey;</span>
<a href="#l17.671"></a><span id="l17.671">     nsAutoTArray&lt;nsMsgKey, 1&gt; preservedSelection;</span>
<a href="#l17.672"></a><span id="l17.672">     SaveAndClearSelection(&amp;preservedKey, preservedSelection);</span>
<a href="#l17.673"></a><span id="l17.673"> </span>
<a href="#l17.674"></a><span id="l17.674" class="difflineminus">-    rv = nsMsgDBView::Sort(sortType,sortOrder);</span>
<a href="#l17.675"></a><span id="l17.675" class="difflineminus">-</span>
<a href="#l17.676"></a><span id="l17.676" class="difflineplus">+    nsresult rv = nsMsgDBView::Sort(sortType,sortOrder);</span>
<a href="#l17.677"></a><span id="l17.677">     // the sort may have changed the number of rows</span>
<a href="#l17.678"></a><span id="l17.678">     // before we restore the selection, tell the tree</span>
<a href="#l17.679"></a><span id="l17.679">     // do this before we call restore selection</span>
<a href="#l17.680"></a><span id="l17.680">     // this is safe when there is no selection. </span>
<a href="#l17.681"></a><span id="l17.681">     rv = AdjustRowCount(rowCountBeforeSort, GetSize());</span>
<a href="#l17.682"></a><span id="l17.682"> </span>
<a href="#l17.683"></a><span id="l17.683">     RestoreSelection(preservedKey, preservedSelection);</span>
<a href="#l17.684"></a><span id="l17.684">     if (mTree) mTree-&gt;Invalidate();</span>
<a href="#l17.685"></a><span id="l17.685"> </span>
<a href="#l17.686"></a><span id="l17.686">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l17.687"></a><span id="l17.687">     return rv;</span>
<a href="#l17.688"></a><span id="l17.688"> }</span>
<a href="#l17.689"></a><span id="l17.689"> </span>
<a href="#l17.690"></a><span id="l17.690" class="difflineminus">-</span>
<a href="#l17.691"></a><span id="l17.691"> // if nothing selected, return an NS_ERROR</span>
<a href="#l17.692"></a><span id="l17.692"> NS_IMETHODIMP</span>
<a href="#l17.693"></a><span id="l17.693"> nsMsgSearchDBView::GetHdrForFirstSelectedMessage(nsIMsgDBHdr **hdr)</span>
<a href="#l17.694"></a><span id="l17.694"> {</span>
<a href="#l17.695"></a><span id="l17.695">   NS_ENSURE_ARG_POINTER(hdr);</span>
<a href="#l17.696"></a><span id="l17.696">   PRInt32 index;</span>
<a href="#l17.697"></a><span id="l17.697">   if (!mTreeSelection)</span>
<a href="#l17.698"></a><span id="l17.698">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l17.699"></a><span id="l17.699" class="difflineat">@@ -618,8 +1016,290 @@ nsMsgSearchDBView::GetFolderFromMsgURI(c</span>
<a href="#l17.700"></a><span id="l17.700">   </span>
<a href="#l17.701"></a><span id="l17.701">   nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l17.702"></a><span id="l17.702">   rv = msgMessageService-&gt;MessageURIToMsgHdr(aMsgURI, getter_AddRefs(msgHdr));</span>
<a href="#l17.703"></a><span id="l17.703">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l17.704"></a><span id="l17.704">   </span>
<a href="#l17.705"></a><span id="l17.705">   return msgHdr-&gt;GetFolder(aFolder);</span>
<a href="#l17.706"></a><span id="l17.706"> }</span>
<a href="#l17.707"></a><span id="l17.707"> </span>
<a href="#l17.708"></a><span id="l17.708" class="difflineplus">+nsMsgViewIndex nsMsgSearchDBView::FindHdr(nsIMsgDBHdr *msgHdr)</span>
<a href="#l17.709"></a><span id="l17.709" class="difflineplus">+{</span>
<a href="#l17.710"></a><span id="l17.710" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; curHdr;</span>
<a href="#l17.711"></a><span id="l17.711" class="difflineplus">+  PRInt32 index;</span>
<a href="#l17.712"></a><span id="l17.712" class="difflineplus">+  // it would be nice to take advantage of sorted views when possible.</span>
<a href="#l17.713"></a><span id="l17.713" class="difflineplus">+  for (index = 0; index &lt; GetSize(); index++)</span>
<a href="#l17.714"></a><span id="l17.714" class="difflineplus">+  {</span>
<a href="#l17.715"></a><span id="l17.715" class="difflineplus">+    GetMsgHdrForViewIndex(index, getter_AddRefs(curHdr));</span>
<a href="#l17.716"></a><span id="l17.716" class="difflineplus">+    if (curHdr == msgHdr &amp;&amp; (!(m_flags[index] &amp; MSG_VIEW_FLAG_DUMMY) ||</span>
<a href="#l17.717"></a><span id="l17.717" class="difflineplus">+        (m_flags[index] &amp; MSG_FLAG_ELIDED)))</span>
<a href="#l17.718"></a><span id="l17.718" class="difflineplus">+      break;</span>
<a href="#l17.719"></a><span id="l17.719" class="difflineplus">+  }</span>
<a href="#l17.720"></a><span id="l17.720" class="difflineplus">+  return index &lt; GetSize() ? index : nsMsgViewIndex_None;</span>
<a href="#l17.721"></a><span id="l17.721" class="difflineplus">+}</span>
<a href="#l17.722"></a><span id="l17.722" class="difflineplus">+</span>
<a href="#l17.723"></a><span id="l17.723" class="difflineplus">+// This method looks for the XF thread that corresponds to this message hdr,</span>
<a href="#l17.724"></a><span id="l17.724" class="difflineplus">+// first by looking up the message id, then references, and finally, if subject</span>
<a href="#l17.725"></a><span id="l17.725" class="difflineplus">+// threading is turned on, the subject.</span>
<a href="#l17.726"></a><span id="l17.726" class="difflineplus">+nsresult nsMsgSearchDBView::GetXFThreadFromMsgHdr(nsIMsgDBHdr *msgHdr, </span>
<a href="#l17.727"></a><span id="l17.727" class="difflineplus">+                                                  nsIMsgThread **pThread,</span>
<a href="#l17.728"></a><span id="l17.728" class="difflineplus">+                                                  PRBool *foundByMessageId)</span>
<a href="#l17.729"></a><span id="l17.729" class="difflineplus">+{</span>
<a href="#l17.730"></a><span id="l17.730" class="difflineplus">+  nsAutoString hashKey;</span>
<a href="#l17.731"></a><span id="l17.731" class="difflineplus">+  nsCAutoString messageId;</span>
<a href="#l17.732"></a><span id="l17.732" class="difflineplus">+  msgHdr-&gt;GetMessageId(getter_Copies(messageId));</span>
<a href="#l17.733"></a><span id="l17.733" class="difflineplus">+  CopyASCIItoUTF16(messageId, hashKey);</span>
<a href="#l17.734"></a><span id="l17.734" class="difflineplus">+  *pThread = nsnull;</span>
<a href="#l17.735"></a><span id="l17.735" class="difflineplus">+  m_threadsTable.Get(hashKey, pThread);</span>
<a href="#l17.736"></a><span id="l17.736" class="difflineplus">+  // The caller may want to know if we found the thread by the msgHdr's</span>
<a href="#l17.737"></a><span id="l17.737" class="difflineplus">+  // messageId</span>
<a href="#l17.738"></a><span id="l17.738" class="difflineplus">+  if (foundByMessageId)</span>
<a href="#l17.739"></a><span id="l17.739" class="difflineplus">+    *foundByMessageId = *pThread != nsnull;</span>
<a href="#l17.740"></a><span id="l17.740" class="difflineplus">+  if (!*pThread)</span>
<a href="#l17.741"></a><span id="l17.741" class="difflineplus">+  {</span>
<a href="#l17.742"></a><span id="l17.742" class="difflineplus">+    PRUint16 numReferences = 0;</span>
<a href="#l17.743"></a><span id="l17.743" class="difflineplus">+    msgHdr-&gt;GetNumReferences(&amp;numReferences);</span>
<a href="#l17.744"></a><span id="l17.744" class="difflineplus">+    for (PRInt32 i = numReferences - 1; i &gt;= 0  &amp;&amp; !*pThread; i--)</span>
<a href="#l17.745"></a><span id="l17.745" class="difflineplus">+    {</span>
<a href="#l17.746"></a><span id="l17.746" class="difflineplus">+      nsCAutoString reference;</span>
<a href="#l17.747"></a><span id="l17.747" class="difflineplus">+      </span>
<a href="#l17.748"></a><span id="l17.748" class="difflineplus">+      msgHdr-&gt;GetStringReference(i, reference);</span>
<a href="#l17.749"></a><span id="l17.749" class="difflineplus">+      if (reference.IsEmpty())</span>
<a href="#l17.750"></a><span id="l17.750" class="difflineplus">+        break;</span>
<a href="#l17.751"></a><span id="l17.751" class="difflineplus">+</span>
<a href="#l17.752"></a><span id="l17.752" class="difflineplus">+      CopyASCIItoUTF16(reference, hashKey);</span>
<a href="#l17.753"></a><span id="l17.753" class="difflineplus">+      m_threadsTable.Get(hashKey, pThread);</span>
<a href="#l17.754"></a><span id="l17.754" class="difflineplus">+    }</span>
<a href="#l17.755"></a><span id="l17.755" class="difflineplus">+  }</span>
<a href="#l17.756"></a><span id="l17.756" class="difflineplus">+  // if we're threading by subject, and we couldn't find the thread by ref,</span>
<a href="#l17.757"></a><span id="l17.757" class="difflineplus">+  // just treat subject as an other ref.</span>
<a href="#l17.758"></a><span id="l17.758" class="difflineplus">+  if (!*pThread &amp;&amp; !gReferenceOnlyThreading)</span>
<a href="#l17.759"></a><span id="l17.759" class="difflineplus">+  {</span>
<a href="#l17.760"></a><span id="l17.760" class="difflineplus">+    nsCString subject;</span>
<a href="#l17.761"></a><span id="l17.761" class="difflineplus">+    msgHdr-&gt;GetSubject(getter_Copies(subject));</span>
<a href="#l17.762"></a><span id="l17.762" class="difflineplus">+    // this is the raw rfc822 subject header, so this is OK</span>
<a href="#l17.763"></a><span id="l17.763" class="difflineplus">+    CopyASCIItoUTF16(subject, hashKey);</span>
<a href="#l17.764"></a><span id="l17.764" class="difflineplus">+    m_threadsTable.Get(hashKey, pThread);</span>
<a href="#l17.765"></a><span id="l17.765" class="difflineplus">+  }</span>
<a href="#l17.766"></a><span id="l17.766" class="difflineplus">+  return (*pThread) ? NS_OK : NS_ERROR_FAILURE;</span>
<a href="#l17.767"></a><span id="l17.767" class="difflineplus">+}</span>
<a href="#l17.768"></a><span id="l17.768" class="difflineplus">+</span>
<a href="#l17.769"></a><span id="l17.769" class="difflineplus">+nsresult nsMsgSearchDBView::GetMsgHdrFromHash(nsCString &amp;reference, nsIMsgDBHdr **hdr)</span>
<a href="#l17.770"></a><span id="l17.770" class="difflineplus">+{</span>
<a href="#l17.771"></a><span id="l17.771" class="difflineplus">+  nsString hashKey;</span>
<a href="#l17.772"></a><span id="l17.772" class="difflineplus">+  CopyASCIItoUTF16(reference, hashKey);</span>
<a href="#l17.773"></a><span id="l17.773" class="difflineplus">+  return m_hdrsTable.Get(hashKey, hdr);</span>
<a href="#l17.774"></a><span id="l17.774" class="difflineplus">+}</span>
<a href="#l17.775"></a><span id="l17.775" class="difflineplus">+</span>
<a href="#l17.776"></a><span id="l17.776" class="difflineplus">+nsresult nsMsgSearchDBView::GetThreadFromHash(nsCString &amp;reference, </span>
<a href="#l17.777"></a><span id="l17.777" class="difflineplus">+                                              nsIMsgThread **thread)</span>
<a href="#l17.778"></a><span id="l17.778" class="difflineplus">+{</span>
<a href="#l17.779"></a><span id="l17.779" class="difflineplus">+  nsString hashKey;</span>
<a href="#l17.780"></a><span id="l17.780" class="difflineplus">+  CopyASCIItoUTF16(reference, hashKey);</span>
<a href="#l17.781"></a><span id="l17.781" class="difflineplus">+  return m_threadsTable.Get(hashKey, thread);</span>
<a href="#l17.782"></a><span id="l17.782" class="difflineplus">+}</span>
<a href="#l17.783"></a><span id="l17.783" class="difflineplus">+</span>
<a href="#l17.784"></a><span id="l17.784" class="difflineplus">+nsresult nsMsgSearchDBView::AddRefToHash(nsCString &amp;reference, </span>
<a href="#l17.785"></a><span id="l17.785" class="difflineplus">+                                         nsIMsgThread *thread)</span>
<a href="#l17.786"></a><span id="l17.786" class="difflineplus">+{</span>
<a href="#l17.787"></a><span id="l17.787" class="difflineplus">+  nsString hashKey;</span>
<a href="#l17.788"></a><span id="l17.788" class="difflineplus">+  CopyASCIItoUTF16(reference, hashKey);</span>
<a href="#l17.789"></a><span id="l17.789" class="difflineplus">+  // Check if this reference is already is associated with a thread;</span>
<a href="#l17.790"></a><span id="l17.790" class="difflineplus">+  // If so, don't overwrite that association.</span>
<a href="#l17.791"></a><span id="l17.791" class="difflineplus">+  nsCOMPtr&lt;nsIMsgThread&gt; oldThread;</span>
<a href="#l17.792"></a><span id="l17.792" class="difflineplus">+  m_threadsTable.Get(hashKey, getter_AddRefs(oldThread));</span>
<a href="#l17.793"></a><span id="l17.793" class="difflineplus">+  if (oldThread)</span>
<a href="#l17.794"></a><span id="l17.794" class="difflineplus">+    return NS_OK;</span>
<a href="#l17.795"></a><span id="l17.795" class="difflineplus">+</span>
<a href="#l17.796"></a><span id="l17.796" class="difflineplus">+  return m_threadsTable.Put(hashKey, thread);</span>
<a href="#l17.797"></a><span id="l17.797" class="difflineplus">+}</span>
<a href="#l17.798"></a><span id="l17.798" class="difflineplus">+</span>
<a href="#l17.799"></a><span id="l17.799" class="difflineplus">+nsresult nsMsgSearchDBView::AddMsgToHashTables(nsIMsgDBHdr *msgHdr,</span>
<a href="#l17.800"></a><span id="l17.800" class="difflineplus">+                                               nsIMsgThread *thread)</span>
<a href="#l17.801"></a><span id="l17.801" class="difflineplus">+{</span>
<a href="#l17.802"></a><span id="l17.802" class="difflineplus">+  PRUint16 numReferences = 0;</span>
<a href="#l17.803"></a><span id="l17.803" class="difflineplus">+  nsresult rv;</span>
<a href="#l17.804"></a><span id="l17.804" class="difflineplus">+</span>
<a href="#l17.805"></a><span id="l17.805" class="difflineplus">+  msgHdr-&gt;GetNumReferences(&amp;numReferences);</span>
<a href="#l17.806"></a><span id="l17.806" class="difflineplus">+  for (PRInt32 i = 0; i &lt; numReferences; i++)</span>
<a href="#l17.807"></a><span id="l17.807" class="difflineplus">+  {</span>
<a href="#l17.808"></a><span id="l17.808" class="difflineplus">+    nsCAutoString reference;</span>
<a href="#l17.809"></a><span id="l17.809" class="difflineplus">+    </span>
<a href="#l17.810"></a><span id="l17.810" class="difflineplus">+    msgHdr-&gt;GetStringReference(i, reference);</span>
<a href="#l17.811"></a><span id="l17.811" class="difflineplus">+    if (reference.IsEmpty())</span>
<a href="#l17.812"></a><span id="l17.812" class="difflineplus">+      break;</span>
<a href="#l17.813"></a><span id="l17.813" class="difflineplus">+</span>
<a href="#l17.814"></a><span id="l17.814" class="difflineplus">+    rv = AddRefToHash(reference, thread);</span>
<a href="#l17.815"></a><span id="l17.815" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.816"></a><span id="l17.816" class="difflineplus">+  }</span>
<a href="#l17.817"></a><span id="l17.817" class="difflineplus">+</span>
<a href="#l17.818"></a><span id="l17.818" class="difflineplus">+  nsCString messageId;</span>
<a href="#l17.819"></a><span id="l17.819" class="difflineplus">+  msgHdr-&gt;GetMessageId(getter_Copies(messageId));</span>
<a href="#l17.820"></a><span id="l17.820" class="difflineplus">+  nsString hashKey;</span>
<a href="#l17.821"></a><span id="l17.821" class="difflineplus">+  CopyASCIItoUTF16(messageId, hashKey);</span>
<a href="#l17.822"></a><span id="l17.822" class="difflineplus">+  m_hdrsTable.Put(hashKey, msgHdr);</span>
<a href="#l17.823"></a><span id="l17.823" class="difflineplus">+  if (!gReferenceOnlyThreading)</span>
<a href="#l17.824"></a><span id="l17.824" class="difflineplus">+  {</span>
<a href="#l17.825"></a><span id="l17.825" class="difflineplus">+    nsCString subject;</span>
<a href="#l17.826"></a><span id="l17.826" class="difflineplus">+    msgHdr-&gt;GetSubject(getter_Copies(subject));</span>
<a href="#l17.827"></a><span id="l17.827" class="difflineplus">+    // if we're threading by subject, just treat subject as an other ref.</span>
<a href="#l17.828"></a><span id="l17.828" class="difflineplus">+    AddRefToHash(subject, thread);</span>
<a href="#l17.829"></a><span id="l17.829" class="difflineplus">+  }</span>
<a href="#l17.830"></a><span id="l17.830" class="difflineplus">+  return AddRefToHash(messageId, thread);</span>
<a href="#l17.831"></a><span id="l17.831" class="difflineplus">+}</span>
<a href="#l17.832"></a><span id="l17.832" class="difflineplus">+</span>
<a href="#l17.833"></a><span id="l17.833" class="difflineplus">+nsresult nsMsgSearchDBView::RemoveRefFromHash(nsCString &amp;reference)</span>
<a href="#l17.834"></a><span id="l17.834" class="difflineplus">+{</span>
<a href="#l17.835"></a><span id="l17.835" class="difflineplus">+  nsString hashKey;</span>
<a href="#l17.836"></a><span id="l17.836" class="difflineplus">+  CopyASCIItoUTF16(reference, hashKey);</span>
<a href="#l17.837"></a><span id="l17.837" class="difflineplus">+  m_threadsTable.Remove(hashKey);</span>
<a href="#l17.838"></a><span id="l17.838" class="difflineplus">+  return NS_OK;</span>
<a href="#l17.839"></a><span id="l17.839" class="difflineplus">+}</span>
<a href="#l17.840"></a><span id="l17.840" class="difflineplus">+</span>
<a href="#l17.841"></a><span id="l17.841" class="difflineplus">+nsresult nsMsgSearchDBView::RemoveMsgFromHashTables(nsIMsgDBHdr *msgHdr)</span>
<a href="#l17.842"></a><span id="l17.842" class="difflineplus">+{</span>
<a href="#l17.843"></a><span id="l17.843" class="difflineplus">+  PRUint16 numReferences = 0;</span>
<a href="#l17.844"></a><span id="l17.844" class="difflineplus">+  nsresult rv = NS_OK;</span>
<a href="#l17.845"></a><span id="l17.845" class="difflineplus">+</span>
<a href="#l17.846"></a><span id="l17.846" class="difflineplus">+  msgHdr-&gt;GetNumReferences(&amp;numReferences);</span>
<a href="#l17.847"></a><span id="l17.847" class="difflineplus">+</span>
<a href="#l17.848"></a><span id="l17.848" class="difflineplus">+  for (PRInt32 i = 0; i &lt; numReferences; i++)</span>
<a href="#l17.849"></a><span id="l17.849" class="difflineplus">+  {</span>
<a href="#l17.850"></a><span id="l17.850" class="difflineplus">+    nsCAutoString reference;</span>
<a href="#l17.851"></a><span id="l17.851" class="difflineplus">+    msgHdr-&gt;GetStringReference(i, reference);</span>
<a href="#l17.852"></a><span id="l17.852" class="difflineplus">+    if (reference.IsEmpty())</span>
<a href="#l17.853"></a><span id="l17.853" class="difflineplus">+      break;</span>
<a href="#l17.854"></a><span id="l17.854" class="difflineplus">+</span>
<a href="#l17.855"></a><span id="l17.855" class="difflineplus">+    rv = RemoveRefFromHash(reference);</span>
<a href="#l17.856"></a><span id="l17.856" class="difflineplus">+    if (NS_FAILED(rv))</span>
<a href="#l17.857"></a><span id="l17.857" class="difflineplus">+      break;</span>
<a href="#l17.858"></a><span id="l17.858" class="difflineplus">+  }</span>
<a href="#l17.859"></a><span id="l17.859" class="difflineplus">+  nsCString messageId;</span>
<a href="#l17.860"></a><span id="l17.860" class="difflineplus">+  msgHdr-&gt;GetMessageId(getter_Copies(messageId));</span>
<a href="#l17.861"></a><span id="l17.861" class="difflineplus">+  nsString hashKey;</span>
<a href="#l17.862"></a><span id="l17.862" class="difflineplus">+  CopyASCIItoUTF16(messageId, hashKey);</span>
<a href="#l17.863"></a><span id="l17.863" class="difflineplus">+  m_hdrsTable.Remove(hashKey);</span>
<a href="#l17.864"></a><span id="l17.864" class="difflineplus">+  RemoveRefFromHash(messageId);</span>
<a href="#l17.865"></a><span id="l17.865" class="difflineplus">+  if (!gReferenceOnlyThreading)</span>
<a href="#l17.866"></a><span id="l17.866" class="difflineplus">+  {</span>
<a href="#l17.867"></a><span id="l17.867" class="difflineplus">+    nsCString subject;</span>
<a href="#l17.868"></a><span id="l17.868" class="difflineplus">+    msgHdr-&gt;GetSubject(getter_Copies(subject));</span>
<a href="#l17.869"></a><span id="l17.869" class="difflineplus">+    // if we're threading by subject, just treat subject as an other ref.</span>
<a href="#l17.870"></a><span id="l17.870" class="difflineplus">+    RemoveRefFromHash(subject);</span>
<a href="#l17.871"></a><span id="l17.871" class="difflineplus">+  }</span>
<a href="#l17.872"></a><span id="l17.872" class="difflineplus">+  return rv;</span>
<a href="#l17.873"></a><span id="l17.873" class="difflineplus">+}</span>
<a href="#l17.874"></a><span id="l17.874" class="difflineplus">+</span>
<a href="#l17.875"></a><span id="l17.875" class="difflineplus">+nsMsgGroupThread *nsMsgSearchDBView::CreateGroupThread(nsIMsgDatabase * /* db */)</span>
<a href="#l17.876"></a><span id="l17.876" class="difflineplus">+{</span>
<a href="#l17.877"></a><span id="l17.877" class="difflineplus">+  return new nsMsgXFGroupThread();</span>
<a href="#l17.878"></a><span id="l17.878" class="difflineplus">+}</span>
<a href="#l17.879"></a><span id="l17.879" class="difflineplus">+</span>
<a href="#l17.880"></a><span id="l17.880" class="difflineplus">+nsresult nsMsgSearchDBView::GetThreadContainingMsgHdr(nsIMsgDBHdr *msgHdr, </span>
<a href="#l17.881"></a><span id="l17.881" class="difflineplus">+                                                      nsIMsgThread **pThread)</span>
<a href="#l17.882"></a><span id="l17.882" class="difflineplus">+{</span>
<a href="#l17.883"></a><span id="l17.883" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l17.884"></a><span id="l17.884" class="difflineplus">+    return nsMsgGroupView::GetThreadContainingMsgHdr(msgHdr, pThread);</span>
<a href="#l17.885"></a><span id="l17.885" class="difflineplus">+  else if (m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay)</span>
<a href="#l17.886"></a><span id="l17.886" class="difflineplus">+    return GetXFThreadFromMsgHdr(msgHdr, pThread);</span>
<a href="#l17.887"></a><span id="l17.887" class="difflineplus">+</span>
<a href="#l17.888"></a><span id="l17.888" class="difflineplus">+  // if not threaded, use the real thread. </span>
<a href="#l17.889"></a><span id="l17.889" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l17.890"></a><span id="l17.890" class="difflineplus">+  nsresult rv = msgHdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l17.891"></a><span id="l17.891" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.892"></a><span id="l17.892" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDatabase&gt; msgDB;</span>
<a href="#l17.893"></a><span id="l17.893" class="difflineplus">+  rv = folder-&gt;GetMsgDatabase(nsnull, getter_AddRefs(msgDB));</span>
<a href="#l17.894"></a><span id="l17.894" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l17.895"></a><span id="l17.895" class="difflineplus">+  return msgDB-&gt;GetThreadContainingMsgHdr(msgHdr, pThread);</span>
<a href="#l17.896"></a><span id="l17.896" class="difflineplus">+}</span>
<a href="#l17.897"></a><span id="l17.897" class="difflineplus">+</span>
<a href="#l17.898"></a><span id="l17.898" class="difflineplus">+nsresult </span>
<a href="#l17.899"></a><span id="l17.899" class="difflineplus">+nsMsgSearchDBView::ListIdsInThread(nsIMsgThread *threadHdr, </span>
<a href="#l17.900"></a><span id="l17.900" class="difflineplus">+                                   nsMsgViewIndex startOfThreadViewIndex, </span>
<a href="#l17.901"></a><span id="l17.901" class="difflineplus">+                                   PRUint32 *pNumListed)</span>
<a href="#l17.902"></a><span id="l17.902" class="difflineplus">+{</span>
<a href="#l17.903"></a><span id="l17.903" class="difflineplus">+  NS_ENSURE_ARG(threadHdr);</span>
<a href="#l17.904"></a><span id="l17.904" class="difflineplus">+  // these children ids should be in thread order.</span>
<a href="#l17.905"></a><span id="l17.905" class="difflineplus">+  PRUint32 i;</span>
<a href="#l17.906"></a><span id="l17.906" class="difflineplus">+  nsMsgViewIndex viewIndex = startOfThreadViewIndex + 1;</span>
<a href="#l17.907"></a><span id="l17.907" class="difflineplus">+  *pNumListed = 0;</span>
<a href="#l17.908"></a><span id="l17.908" class="difflineplus">+</span>
<a href="#l17.909"></a><span id="l17.909" class="difflineplus">+  PRUint32 numChildren;</span>
<a href="#l17.910"></a><span id="l17.910" class="difflineplus">+  threadHdr-&gt;GetNumChildren(&amp;numChildren);</span>
<a href="#l17.911"></a><span id="l17.911" class="difflineplus">+  NS_ASSERTION(numChildren, &quot;Empty thread in view/db&quot;);</span>
<a href="#l17.912"></a><span id="l17.912" class="difflineplus">+  if (!numChildren)</span>
<a href="#l17.913"></a><span id="l17.913" class="difflineplus">+    return NS_OK;</span>
<a href="#l17.914"></a><span id="l17.914" class="difflineplus">+</span>
<a href="#l17.915"></a><span id="l17.915" class="difflineplus">+  numChildren--; // account for the existing thread root</span>
<a href="#l17.916"></a><span id="l17.916" class="difflineplus">+  if (!InsertEmptyRows(viewIndex, numChildren))</span>
<a href="#l17.917"></a><span id="l17.917" class="difflineplus">+    return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l17.918"></a><span id="l17.918" class="difflineplus">+</span>
<a href="#l17.919"></a><span id="l17.919" class="difflineplus">+  PRBool threadedView = m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay &amp;&amp;</span>
<a href="#l17.920"></a><span id="l17.920" class="difflineplus">+    !(m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort);</span>
<a href="#l17.921"></a><span id="l17.921" class="difflineplus">+  nsMsgXFViewThread *viewThread;</span>
<a href="#l17.922"></a><span id="l17.922" class="difflineplus">+  if (threadedView)</span>
<a href="#l17.923"></a><span id="l17.923" class="difflineplus">+    viewThread = static_cast&lt;nsMsgXFViewThread*&gt;(threadHdr);</span>
<a href="#l17.924"></a><span id="l17.924" class="difflineplus">+</span>
<a href="#l17.925"></a><span id="l17.925" class="difflineplus">+  for (i = 1; i &lt;= numChildren; i++)</span>
<a href="#l17.926"></a><span id="l17.926" class="difflineplus">+  {</span>
<a href="#l17.927"></a><span id="l17.927" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l17.928"></a><span id="l17.928" class="difflineplus">+    threadHdr-&gt;GetChildHdrAt(i, getter_AddRefs(msgHdr));</span>
<a href="#l17.929"></a><span id="l17.929" class="difflineplus">+</span>
<a href="#l17.930"></a><span id="l17.930" class="difflineplus">+    if (msgHdr)</span>
<a href="#l17.931"></a><span id="l17.931" class="difflineplus">+    {</span>
<a href="#l17.932"></a><span id="l17.932" class="difflineplus">+      nsMsgKey msgKey;</span>
<a href="#l17.933"></a><span id="l17.933" class="difflineplus">+      PRUint32 msgFlags;</span>
<a href="#l17.934"></a><span id="l17.934" class="difflineplus">+      msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l17.935"></a><span id="l17.935" class="difflineplus">+      msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l17.936"></a><span id="l17.936" class="difflineplus">+      PRUint8 level = (threadedView) ? viewThread-&gt;ChildLevelAt(i) : 1;</span>
<a href="#l17.937"></a><span id="l17.937" class="difflineplus">+      SetMsgHdrAt(msgHdr, viewIndex, msgKey, msgFlags &amp; ~MSG_VIEW_FLAGS, </span>
<a href="#l17.938"></a><span id="l17.938" class="difflineplus">+                  level);</span>
<a href="#l17.939"></a><span id="l17.939" class="difflineplus">+      (*pNumListed)++;</span>
<a href="#l17.940"></a><span id="l17.940" class="difflineplus">+      viewIndex++;</span>
<a href="#l17.941"></a><span id="l17.941" class="difflineplus">+    }</span>
<a href="#l17.942"></a><span id="l17.942" class="difflineplus">+  }</span>
<a href="#l17.943"></a><span id="l17.943" class="difflineplus">+  return NS_OK;</span>
<a href="#l17.944"></a><span id="l17.944" class="difflineplus">+}</span>
<a href="#l17.945"></a><span id="l17.945" class="difflineplus">+</span>
<a href="#l17.946"></a><span id="l17.946" class="difflineplus">+nsresult nsMsgSearchDBView::RebuildView()</span>
<a href="#l17.947"></a><span id="l17.947" class="difflineplus">+{</span>
<a href="#l17.948"></a><span id="l17.948" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l17.949"></a><span id="l17.949" class="difflineplus">+    return nsMsgGroupView::RebuildView();</span>
<a href="#l17.950"></a><span id="l17.950" class="difflineplus">+</span>
<a href="#l17.951"></a><span id="l17.951" class="difflineplus">+  nsCOMPtr&lt;nsISimpleEnumerator&gt; headers;</span>
<a href="#l17.952"></a><span id="l17.952" class="difflineplus">+  if (NS_SUCCEEDED(GetMessageEnumerator(getter_AddRefs(headers))))</span>
<a href="#l17.953"></a><span id="l17.953" class="difflineplus">+  {</span>
<a href="#l17.954"></a><span id="l17.954" class="difflineplus">+    PRInt32 count;</span>
<a href="#l17.955"></a><span id="l17.955" class="difflineplus">+    // ### we need to be remembering headers, not keys.</span>
<a href="#l17.956"></a><span id="l17.956" class="difflineplus">+    nsAutoTArray&lt;nsMsgKey, 1&gt; preservedSelection;</span>
<a href="#l17.957"></a><span id="l17.957" class="difflineplus">+    nsMsgKey curSelectedKey;</span>
<a href="#l17.958"></a><span id="l17.958" class="difflineplus">+    SaveAndClearSelection(&amp;curSelectedKey, preservedSelection);</span>
<a href="#l17.959"></a><span id="l17.959" class="difflineplus">+    InternalClose();</span>
<a href="#l17.960"></a><span id="l17.960" class="difflineplus">+    PRInt32 oldSize = GetSize();</span>
<a href="#l17.961"></a><span id="l17.961" class="difflineplus">+    // this is important, because the tree will ask us for our</span>
<a href="#l17.962"></a><span id="l17.962" class="difflineplus">+    // row count, which get determine from the number of keys.</span>
<a href="#l17.963"></a><span id="l17.963" class="difflineplus">+    m_keys.Clear();</span>
<a href="#l17.964"></a><span id="l17.964" class="difflineplus">+    // be consistent</span>
<a href="#l17.965"></a><span id="l17.965" class="difflineplus">+    m_flags.Clear();</span>
<a href="#l17.966"></a><span id="l17.966" class="difflineplus">+    m_levels.Clear();</span>
<a href="#l17.967"></a><span id="l17.967" class="difflineplus">+    m_folders.Clear();</span>
<a href="#l17.968"></a><span id="l17.968" class="difflineplus">+    m_threadsTable.Clear();</span>
<a href="#l17.969"></a><span id="l17.969" class="difflineplus">+    m_hdrsTable.Clear();</span>
<a href="#l17.970"></a><span id="l17.970" class="difflineplus">+</span>
<a href="#l17.971"></a><span id="l17.971" class="difflineplus">+    // this needs to happen after we remove all the keys, since RowCountChanged() will call our GetRowCount()</span>
<a href="#l17.972"></a><span id="l17.972" class="difflineplus">+    if (mTree)</span>
<a href="#l17.973"></a><span id="l17.973" class="difflineplus">+      mTree-&gt;RowCountChanged(0, -oldSize);</span>
<a href="#l17.974"></a><span id="l17.974" class="difflineplus">+    DisableChangeUpdates();</span>
<a href="#l17.975"></a><span id="l17.975" class="difflineplus">+    nsresult rv = OpenWithHdrs(headers, m_sortType, m_sortOrder, m_viewFlags, &amp;count);</span>
<a href="#l17.976"></a><span id="l17.976" class="difflineplus">+    EnableChangeUpdates();</span>
<a href="#l17.977"></a><span id="l17.977" class="difflineplus">+    if (mTree)</span>
<a href="#l17.978"></a><span id="l17.978" class="difflineplus">+      mTree-&gt;RowCountChanged(0, GetSize());</span>
<a href="#l17.979"></a><span id="l17.979" class="difflineplus">+</span>
<a href="#l17.980"></a><span id="l17.980" class="difflineplus">+    NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l17.981"></a><span id="l17.981" class="difflineplus">+</span>
<a href="#l17.982"></a><span id="l17.982" class="difflineplus">+    // now, restore our desired selection</span>
<a href="#l17.983"></a><span id="l17.983" class="difflineplus">+    nsAutoTArray&lt;nsMsgKey, 1&gt; keyArray;</span>
<a href="#l17.984"></a><span id="l17.984" class="difflineplus">+    keyArray.AppendElement(curSelectedKey);</span>
<a href="#l17.985"></a><span id="l17.985" class="difflineplus">+</span>
<a href="#l17.986"></a><span id="l17.986" class="difflineplus">+    return RestoreSelection(curSelectedKey, keyArray);</span>
<a href="#l17.987"></a><span id="l17.987" class="difflineplus">+  }</span>
<a href="#l17.988"></a><span id="l17.988" class="difflineplus">+  return NS_OK;</span>
<a href="#l17.989"></a><span id="l17.989" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/base/src/nsMsgSearchDBView.h</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgSearchDBView.h</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l18.4"></a><span id="l18.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l18.5"></a><span id="l18.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l18.6"></a><span id="l18.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l18.7"></a><span id="l18.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l18.8"></a><span id="l18.8">  *</span>
<a href="#l18.9"></a><span id="l18.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l18.10"></a><span id="l18.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l18.11"></a><span id="l18.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l18.12"></a><span id="l18.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l18.13"></a><span id="l18.13">  *</span>
<a href="#l18.14"></a><span id="l18.14" class="difflineat">@@ -33,75 +33,125 @@</span>
<a href="#l18.15"></a><span id="l18.15">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l18.16"></a><span id="l18.16">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l18.17"></a><span id="l18.17">  *</span>
<a href="#l18.18"></a><span id="l18.18">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l18.19"></a><span id="l18.19"> </span>
<a href="#l18.20"></a><span id="l18.20"> #ifndef _nsMsgSearchDBViewsH_</span>
<a href="#l18.21"></a><span id="l18.21"> #define _nsMsgSearchDBView_H_</span>
<a href="#l18.22"></a><span id="l18.22"> </span>
<a href="#l18.23"></a><span id="l18.23" class="difflineminus">-#include &quot;nsMsgDBView.h&quot;</span>
<a href="#l18.24"></a><span id="l18.24" class="difflineplus">+#include &quot;nsMsgGroupView.h&quot;</span>
<a href="#l18.25"></a><span id="l18.25"> #include &quot;nsIMsgCopyServiceListener.h&quot;</span>
<a href="#l18.26"></a><span id="l18.26"> #include &quot;nsIMsgSearchNotify.h&quot;</span>
<a href="#l18.27"></a><span id="l18.27" class="difflineplus">+#include &quot;nsMsgXFViewThread.h&quot;</span>
<a href="#l18.28"></a><span id="l18.28"> #include &quot;nsCOMArray.h&quot;</span>
<a href="#l18.29"></a><span id="l18.29"> </span>
<a href="#l18.30"></a><span id="l18.30" class="difflineminus">-class nsMsgSearchDBView : public nsMsgDBView, public nsIMsgCopyServiceListener, public nsIMsgSearchNotify</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineplus">+class nsMsgSearchDBView : public nsMsgGroupView, public nsIMsgCopyServiceListener, public nsIMsgSearchNotify</span>
<a href="#l18.32"></a><span id="l18.32"> {</span>
<a href="#l18.33"></a><span id="l18.33"> public:</span>
<a href="#l18.34"></a><span id="l18.34">   nsMsgSearchDBView();</span>
<a href="#l18.35"></a><span id="l18.35">   virtual ~nsMsgSearchDBView();</span>
<a href="#l18.36"></a><span id="l18.36"> </span>
<a href="#l18.37"></a><span id="l18.37" class="difflineplus">+  // these are tied together pretty intimately</span>
<a href="#l18.38"></a><span id="l18.38" class="difflineplus">+  friend class nsMsgXFViewThread;</span>
<a href="#l18.39"></a><span id="l18.39" class="difflineplus">+</span>
<a href="#l18.40"></a><span id="l18.40">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l18.41"></a><span id="l18.41">   NS_DECL_NSIMSGSEARCHNOTIFY</span>
<a href="#l18.42"></a><span id="l18.42">   NS_DECL_NSIMSGCOPYSERVICELISTENER</span>
<a href="#l18.43"></a><span id="l18.43"> </span>
<a href="#l18.44"></a><span id="l18.44">   virtual const char * GetViewName(void) {return &quot;SearchView&quot;; }</span>
<a href="#l18.45"></a><span id="l18.45">   NS_IMETHOD Open(nsIMsgFolder *folder, nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder, </span>
<a href="#l18.46"></a><span id="l18.46">         nsMsgViewFlagsTypeValue viewFlags, PRInt32 *pCount);</span>
<a href="#l18.47"></a><span id="l18.47">   NS_IMETHOD CopyDBView(nsMsgDBView *aNewMsgDBView, nsIMessenger *aMessengerInstance, </span>
<a href="#l18.48"></a><span id="l18.48">                         nsIMsgWindow *aMsgWindow, nsIMsgDBViewCommandUpdater *aCmdUpdater);</span>
<a href="#l18.49"></a><span id="l18.49">   NS_IMETHOD Close();</span>
<a href="#l18.50"></a><span id="l18.50">   NS_IMETHOD GetViewType(nsMsgViewTypeValue *aViewType);</span>
<a href="#l18.51"></a><span id="l18.51" class="difflineminus">-  NS_IMETHOD Sort(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder);</span>
<a href="#l18.52"></a><span id="l18.52" class="difflineminus">-  NS_IMETHOD GetCommandStatus(nsMsgViewCommandTypeValue command, PRBool *selectable_p, nsMsgViewCommandCheckStateValue *selected_p);</span>
<a href="#l18.53"></a><span id="l18.53" class="difflineplus">+  NS_IMETHOD Sort(nsMsgViewSortTypeValue sortType, </span>
<a href="#l18.54"></a><span id="l18.54" class="difflineplus">+                  nsMsgViewSortOrderValue sortOrder);</span>
<a href="#l18.55"></a><span id="l18.55" class="difflineplus">+  NS_IMETHOD GetCommandStatus(nsMsgViewCommandTypeValue command,</span>
<a href="#l18.56"></a><span id="l18.56" class="difflineplus">+                              PRBool *selectable_p, </span>
<a href="#l18.57"></a><span id="l18.57" class="difflineplus">+                              nsMsgViewCommandCheckStateValue *selected_p);</span>
<a href="#l18.58"></a><span id="l18.58">   NS_IMETHOD DoCommand(nsMsgViewCommandTypeValue command);</span>
<a href="#l18.59"></a><span id="l18.59">   NS_IMETHOD DoCommandWithFolder(nsMsgViewCommandTypeValue command, nsIMsgFolder *destFolder);</span>
<a href="#l18.60"></a><span id="l18.60">   NS_IMETHOD GetHdrForFirstSelectedMessage(nsIMsgDBHdr **hdr);</span>
<a href="#l18.61"></a><span id="l18.61" class="difflineplus">+  NS_IMETHOD OnHdrDeleted(nsIMsgDBHdr *aHdrDeleted, nsMsgKey aParentKey, </span>
<a href="#l18.62"></a><span id="l18.62" class="difflineplus">+                          PRInt32 aFlags, nsIDBChangeListener *aInstigator);</span>
<a href="#l18.63"></a><span id="l18.63">   // override to get location</span>
<a href="#l18.64"></a><span id="l18.64">   NS_IMETHOD GetCellText(PRInt32 aRow, nsITreeColumn* aCol, nsAString&amp; aValue);</span>
<a href="#l18.65"></a><span id="l18.65">   virtual nsresult GetMsgHdrForViewIndex(nsMsgViewIndex index, nsIMsgDBHdr **msgHdr);</span>
<a href="#l18.66"></a><span id="l18.66">   virtual nsresult OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey parentKey, PRBool ensureListed);</span>
<a href="#l18.67"></a><span id="l18.67">   NS_IMETHOD GetFolderForViewIndex(nsMsgViewIndex index, nsIMsgFolder **folder);</span>
<a href="#l18.68"></a><span id="l18.68" class="difflineplus">+  virtual nsresult RebuildView();</span>
<a href="#l18.69"></a><span id="l18.69"> </span>
<a href="#l18.70"></a><span id="l18.70">   NS_IMETHOD OnAnnouncerGoingAway(nsIDBChangeAnnouncer *instigator);</span>
<a href="#l18.71"></a><span id="l18.71"> </span>
<a href="#l18.72"></a><span id="l18.72">   virtual nsCOMArray&lt;nsIMsgFolder&gt;* GetFolders();</span>
<a href="#l18.73"></a><span id="l18.73">   virtual nsresult GetFolderFromMsgURI(const char *aMsgURI, nsIMsgFolder **aFolder);</span>
<a href="#l18.74"></a><span id="l18.74"> </span>
<a href="#l18.75"></a><span id="l18.75"> protected:</span>
<a href="#l18.76"></a><span id="l18.76" class="difflineplus">+  virtual nsresult ListIdsInThread(nsIMsgThread *threadHdr, </span>
<a href="#l18.77"></a><span id="l18.77" class="difflineplus">+                                   nsMsgViewIndex startOfThreadViewIndex, </span>
<a href="#l18.78"></a><span id="l18.78" class="difflineplus">+                                   PRUint32 *pNumListed);</span>
<a href="#l18.79"></a><span id="l18.79">   nsresult FetchLocation(PRInt32 aRow, nsAString&amp; aLocationString);</span>
<a href="#l18.80"></a><span id="l18.80">   virtual nsresult AddHdrFromFolder(nsIMsgDBHdr *msgHdr, nsIMsgFolder *folder);</span>
<a href="#l18.81"></a><span id="l18.81">   virtual nsresult GetDBForViewIndex(nsMsgViewIndex index, nsIMsgDatabase **db);</span>
<a href="#l18.82"></a><span id="l18.82">   virtual nsresult RemoveByIndex(nsMsgViewIndex index);</span>
<a href="#l18.83"></a><span id="l18.83">   virtual nsresult CopyMessages(nsIMsgWindow *window, nsMsgViewIndex *indices, PRInt32 numIndices, PRBool isMove, nsIMsgFolder *destFolder);</span>
<a href="#l18.84"></a><span id="l18.84">   virtual nsresult DeleteMessages(nsIMsgWindow *window, nsMsgViewIndex *indices, PRInt32 numIndices, PRBool deleteStorage);</span>
<a href="#l18.85"></a><span id="l18.85" class="difflineplus">+  virtual void InsertMsgHdrAt(nsMsgViewIndex index, nsIMsgDBHdr *hdr,</span>
<a href="#l18.86"></a><span id="l18.86" class="difflineplus">+                              nsMsgKey msgKey, PRUint32 flags, PRUint32 level);</span>
<a href="#l18.87"></a><span id="l18.87" class="difflineplus">+  virtual void SetMsgHdrAt(nsIMsgDBHdr *hdr, nsMsgViewIndex index, </span>
<a href="#l18.88"></a><span id="l18.88" class="difflineplus">+                              nsMsgKey msgKey, PRUint32 flags, PRUint32 level);</span>
<a href="#l18.89"></a><span id="l18.89" class="difflineplus">+  virtual PRBool InsertEmptyRows(nsMsgViewIndex viewIndex, PRInt32 numRows);</span>
<a href="#l18.90"></a><span id="l18.90" class="difflineplus">+  virtual void RemoveRows(nsMsgViewIndex viewIndex, PRInt32 numRows);</span>
<a href="#l18.91"></a><span id="l18.91" class="difflineplus">+  virtual nsMsgViewIndex FindHdr(nsIMsgDBHdr *msgHdr);</span>
<a href="#l18.92"></a><span id="l18.92" class="difflineplus">+  virtual nsresult GetThreadContainingMsgHdr(nsIMsgDBHdr *msgHdr, nsIMsgThread **pThread);</span>
<a href="#l18.93"></a><span id="l18.93">   nsresult GetFoldersAndHdrsForSelection(nsMsgViewIndex *indices, PRInt32 numIndices);</span>
<a href="#l18.94"></a><span id="l18.94">   nsresult GroupSearchResultsByFolder();</span>
<a href="#l18.95"></a><span id="l18.95">   nsresult PartitionSelectionByFolder(nsMsgViewIndex *indices, PRInt32 numIndices, nsTArray&lt;PRUint32&gt; **indexArrays, PRInt32 *numArrays);</span>
<a href="#l18.96"></a><span id="l18.96">   virtual nsresult ApplyCommandToIndicesWithFolder(nsMsgViewCommandTypeValue command, nsMsgViewIndex* indices,</span>
<a href="#l18.97"></a><span id="l18.97">                     PRInt32 numIndices, nsIMsgFolder *destFolder);</span>
<a href="#l18.98"></a><span id="l18.98" class="difflineplus">+  void MoveThreadAt(nsMsgViewIndex threadIndex);</span>
<a href="#l18.99"></a><span id="l18.99">   </span>
<a href="#l18.100"></a><span id="l18.100">   nsCOMArray&lt;nsIMsgFolder&gt; m_folders;</span>
<a href="#l18.101"></a><span id="l18.101">   nsCOMPtr &lt;nsISupportsArray&gt; m_hdrsForEachFolder;</span>
<a href="#l18.102"></a><span id="l18.102">   nsCOMPtr &lt;nsISupportsArray&gt; m_copyListenerList;</span>
<a href="#l18.103"></a><span id="l18.103">   nsCOMArray&lt;nsIMsgFolder&gt; m_uniqueFoldersSelected;</span>
<a href="#l18.104"></a><span id="l18.104" class="difflineminus">-  PRInt32 mCurIndex;</span>
<a href="#l18.105"></a><span id="l18.105" class="difflineplus">+  PRUint32 mCurIndex;</span>
<a href="#l18.106"></a><span id="l18.106"> </span>
<a href="#l18.107"></a><span id="l18.107">   nsMsgViewIndex* mIndicesForChainedDeleteAndFile;</span>
<a href="#l18.108"></a><span id="l18.108">   PRInt32 mTotalIndices;</span>
<a href="#l18.109"></a><span id="l18.109">   nsCOMArray&lt;nsIMsgDatabase&gt; m_dbToUseList;</span>
<a href="#l18.110"></a><span id="l18.110">   nsMsgViewCommandTypeValue mCommand;</span>
<a href="#l18.111"></a><span id="l18.111">   nsCOMPtr &lt;nsIMsgFolder&gt; mDestFolder;</span>
<a href="#l18.112"></a><span id="l18.112">   nsresult ProcessRequestsInOneFolder(nsIMsgWindow *window);</span>
<a href="#l18.113"></a><span id="l18.113">   nsresult ProcessRequestsInAllFolders(nsIMsgWindow *window);</span>
<a href="#l18.114"></a><span id="l18.114" class="difflineplus">+  // these are for doing threading of the search hits</span>
<a href="#l18.115"></a><span id="l18.115" class="difflineplus">+</span>
<a href="#l18.116"></a><span id="l18.116" class="difflineplus">+</span>
<a href="#l18.117"></a><span id="l18.117" class="difflineplus">+  // this maps message-ids and reference message ids to</span>
<a href="#l18.118"></a><span id="l18.118" class="difflineplus">+  // the corresponding nsMsgXFViewThread object. If we're </span>
<a href="#l18.119"></a><span id="l18.119" class="difflineplus">+  // doing subject threading, we would throw subjects</span>
<a href="#l18.120"></a><span id="l18.120" class="difflineplus">+  // into the same table.</span>
<a href="#l18.121"></a><span id="l18.121" class="difflineplus">+  nsInterfaceHashtable &lt;nsStringHashKey, nsIMsgThread&gt; m_threadsTable;</span>
<a href="#l18.122"></a><span id="l18.122" class="difflineplus">+</span>
<a href="#l18.123"></a><span id="l18.123" class="difflineplus">+  // map message-ids to msg hdrs in the view, used for threading.</span>
<a href="#l18.124"></a><span id="l18.124" class="difflineplus">+  nsInterfaceHashtable &lt;nsStringHashKey, nsIMsgDBHdr&gt; m_hdrsTable;</span>
<a href="#l18.125"></a><span id="l18.125" class="difflineplus">+</span>
<a href="#l18.126"></a><span id="l18.126" class="difflineplus">+  PR_STATIC_CALLBACK(PLDHashOperator) ThreadTableCloner(const nsAString &amp;aKey, </span>
<a href="#l18.127"></a><span id="l18.127" class="difflineplus">+                                                        nsIMsgThread* aThread, </span>
<a href="#l18.128"></a><span id="l18.128" class="difflineplus">+                                                        void* aArg);</span>
<a href="#l18.129"></a><span id="l18.129" class="difflineplus">+  PR_STATIC_CALLBACK(PLDHashOperator) MsgHdrTableCloner(const nsAString &amp;aKey, </span>
<a href="#l18.130"></a><span id="l18.130" class="difflineplus">+                                                        nsIMsgDBHdr* aMsgHdr, </span>
<a href="#l18.131"></a><span id="l18.131" class="difflineplus">+                                                        void* aArg);</span>
<a href="#l18.132"></a><span id="l18.132" class="difflineplus">+  virtual nsMsgGroupThread *CreateGroupThread(nsIMsgDatabase *db);</span>
<a href="#l18.133"></a><span id="l18.133" class="difflineplus">+  nsresult GetXFThreadFromMsgHdr(nsIMsgDBHdr *msgHdr, nsIMsgThread **pThread,</span>
<a href="#l18.134"></a><span id="l18.134" class="difflineplus">+                                 PRBool *foundByMessageId = nsnull);</span>
<a href="#l18.135"></a><span id="l18.135" class="difflineplus">+  nsresult GetThreadFromHash(nsCString &amp;reference, nsIMsgThread **thread);</span>
<a href="#l18.136"></a><span id="l18.136" class="difflineplus">+  nsresult GetMsgHdrFromHash(nsCString &amp;reference, nsIMsgDBHdr **hdr);</span>
<a href="#l18.137"></a><span id="l18.137" class="difflineplus">+  nsresult AddRefToHash(nsCString &amp;reference, nsIMsgThread *thread);</span>
<a href="#l18.138"></a><span id="l18.138" class="difflineplus">+  nsresult AddMsgToHashTables(nsIMsgDBHdr *msgHdr, nsIMsgThread *thread);</span>
<a href="#l18.139"></a><span id="l18.139" class="difflineplus">+  nsresult RemoveRefFromHash(nsCString &amp;reference);</span>
<a href="#l18.140"></a><span id="l18.140" class="difflineplus">+  nsresult RemoveMsgFromHashTables(nsIMsgDBHdr *msgHdr);</span>
<a href="#l18.141"></a><span id="l18.141" class="difflineplus">+  nsresult InitRefHash();</span>
<a href="#l18.142"></a><span id="l18.142"> };</span>
<a href="#l18.143"></a><span id="l18.143"> </span>
<a href="#l18.144"></a><span id="l18.144"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/base/src/nsMsgSpecialViews.cpp</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgSpecialViews.cpp</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l19.4"></a><span id="l19.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l19.5"></a><span id="l19.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l19.6"></a><span id="l19.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l19.7"></a><span id="l19.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l19.8"></a><span id="l19.8">  *</span>
<a href="#l19.9"></a><span id="l19.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l19.10"></a><span id="l19.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l19.11"></a><span id="l19.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l19.12"></a><span id="l19.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l19.13"></a><span id="l19.13">  *</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/base/src/nsMsgSpecialViews.h</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgSpecialViews.h</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l20.4"></a><span id="l20.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l20.5"></a><span id="l20.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l20.6"></a><span id="l20.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l20.7"></a><span id="l20.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l20.8"></a><span id="l20.8">  *</span>
<a href="#l20.9"></a><span id="l20.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l20.10"></a><span id="l20.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l20.11"></a><span id="l20.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l20.12"></a><span id="l20.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l20.13"></a><span id="l20.13">  *</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/base/src/nsMsgThreadedDBView.cpp</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgThreadedDBView.cpp</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l21.4"></a><span id="l21.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l21.5"></a><span id="l21.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l21.6"></a><span id="l21.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l21.7"></a><span id="l21.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l21.8"></a><span id="l21.8">  *</span>
<a href="#l21.9"></a><span id="l21.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l21.10"></a><span id="l21.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l21.11"></a><span id="l21.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l21.12"></a><span id="l21.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l21.13"></a><span id="l21.13">  *</span>
<a href="#l21.14"></a><span id="l21.14" class="difflineat">@@ -550,16 +550,19 @@ void nsMsgThreadedDBView::ClearPrevIdArr</span>
<a href="#l21.15"></a><span id="l21.15">   m_prevKeys.Clear();</span>
<a href="#l21.16"></a><span id="l21.16">   m_prevLevels.Clear();</span>
<a href="#l21.17"></a><span id="l21.17">   m_prevFlags.Clear();</span>
<a href="#l21.18"></a><span id="l21.18">   m_havePrevView = PR_FALSE;</span>
<a href="#l21.19"></a><span id="l21.19"> }</span>
<a href="#l21.20"></a><span id="l21.20"> </span>
<a href="#l21.21"></a><span id="l21.21"> nsresult nsMsgThreadedDBView::InitSort(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder)</span>
<a href="#l21.22"></a><span id="l21.22"> {</span>
<a href="#l21.23"></a><span id="l21.23" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l21.24"></a><span id="l21.24" class="difflineplus">+    return NS_OK; // nothing to do.</span>
<a href="#l21.25"></a><span id="l21.25" class="difflineplus">+</span>
<a href="#l21.26"></a><span id="l21.26">   if (sortType == nsMsgViewSortType::byThread)</span>
<a href="#l21.27"></a><span id="l21.27">   {</span>
<a href="#l21.28"></a><span id="l21.28">     nsMsgDBView::Sort(nsMsgViewSortType::byId, sortOrder); // sort top level threads by id.</span>
<a href="#l21.29"></a><span id="l21.29">     m_sortType = nsMsgViewSortType::byThread;</span>
<a href="#l21.30"></a><span id="l21.30">     m_viewFlags |= nsMsgViewFlagsType::kThreadedDisplay;</span>
<a href="#l21.31"></a><span id="l21.31">     m_viewFlags &amp;= ~nsMsgViewFlagsType::kGroupBySort;</span>
<a href="#l21.32"></a><span id="l21.32">     SetViewFlags(m_viewFlags); // persist the view flags.</span>
<a href="#l21.33"></a><span id="l21.33">     //		m_db-&gt;SetSortInfo(m_sortType, sortOrder);</span>
<a href="#l21.34"></a><span id="l21.34" class="difflineat">@@ -577,16 +580,19 @@ nsresult nsMsgThreadedDBView::InitSort(n</span>
<a href="#l21.35"></a><span id="l21.35">   Sort(sortType, sortOrder);</span>
<a href="#l21.36"></a><span id="l21.36">   if (sortType != nsMsgViewSortType::byThread)	// forget prev view, since it has everything expanded.</span>
<a href="#l21.37"></a><span id="l21.37">     ClearPrevIdArray();</span>
<a href="#l21.38"></a><span id="l21.38">   return NS_OK;</span>
<a href="#l21.39"></a><span id="l21.39"> }</span>
<a href="#l21.40"></a><span id="l21.40"> </span>
<a href="#l21.41"></a><span id="l21.41"> nsresult nsMsgThreadedDBView::OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey, PRBool ensureListed)</span>
<a href="#l21.42"></a><span id="l21.42"> {</span>
<a href="#l21.43"></a><span id="l21.43" class="difflineplus">+  if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l21.44"></a><span id="l21.44" class="difflineplus">+    return nsMsgGroupView::OnNewHeader(newHdr, aParentKey, ensureListed);</span>
<a href="#l21.45"></a><span id="l21.45" class="difflineplus">+</span>
<a href="#l21.46"></a><span id="l21.46">   nsresult rv = NS_OK;</span>
<a href="#l21.47"></a><span id="l21.47">   nsMsgKey newKey;</span>
<a href="#l21.48"></a><span id="l21.48">   newHdr-&gt;GetMessageKey(&amp;newKey);</span>
<a href="#l21.49"></a><span id="l21.49"> </span>
<a href="#l21.50"></a><span id="l21.50">   // views can override this behaviour, which is to append to view.</span>
<a href="#l21.51"></a><span id="l21.51">   // This is the mail behaviour, but threaded views want</span>
<a href="#l21.52"></a><span id="l21.52">   // to insert in order...</span>
<a href="#l21.53"></a><span id="l21.53">   if (newHdr)</span>
<a href="#l21.54"></a><span id="l21.54" class="difflineat">@@ -946,16 +952,8 @@ nsMsgThreadedDBView::CloneDBView(nsIMess</span>
<a href="#l21.55"></a><span id="l21.55">     return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l21.56"></a><span id="l21.56"> </span>
<a href="#l21.57"></a><span id="l21.57">   nsresult rv = CopyDBView(newMsgDBView, aMessengerInstance, aMsgWindow, aCmdUpdater);</span>
<a href="#l21.58"></a><span id="l21.58">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l21.59"></a><span id="l21.59"> </span>
<a href="#l21.60"></a><span id="l21.60">   NS_IF_ADDREF(*_retval = newMsgDBView);</span>
<a href="#l21.61"></a><span id="l21.61">   return NS_OK;</span>
<a href="#l21.62"></a><span id="l21.62"> }</span>
<a href="#l21.63"></a><span id="l21.63" class="difflineminus">-</span>
<a href="#l21.64"></a><span id="l21.64" class="difflineminus">-NS_IMETHODIMP</span>
<a href="#l21.65"></a><span id="l21.65" class="difflineminus">-nsMsgThreadedDBView::GetSupportsThreading(PRBool *aResult)</span>
<a href="#l21.66"></a><span id="l21.66" class="difflineminus">-{</span>
<a href="#l21.67"></a><span id="l21.67" class="difflineminus">-  NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l21.68"></a><span id="l21.68" class="difflineminus">-  *aResult = PR_TRUE;</span>
<a href="#l21.69"></a><span id="l21.69" class="difflineminus">-  return NS_OK;</span>
<a href="#l21.70"></a><span id="l21.70" class="difflineminus">-}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/base/src/nsMsgThreadedDBView.h</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgThreadedDBView.h</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l22.4"></a><span id="l22.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l22.5"></a><span id="l22.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l22.6"></a><span id="l22.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l22.7"></a><span id="l22.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l22.8"></a><span id="l22.8">  *</span>
<a href="#l22.9"></a><span id="l22.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l22.10"></a><span id="l22.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l22.11"></a><span id="l22.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l22.12"></a><span id="l22.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l22.13"></a><span id="l22.13">  *</span>
<a href="#l22.14"></a><span id="l22.14" class="difflineat">@@ -33,35 +33,30 @@</span>
<a href="#l22.15"></a><span id="l22.15">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l22.16"></a><span id="l22.16">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l22.17"></a><span id="l22.17">  *</span>
<a href="#l22.18"></a><span id="l22.18">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l22.19"></a><span id="l22.19"> </span>
<a href="#l22.20"></a><span id="l22.20"> #ifndef _nsMsgThreadedDBView_H_</span>
<a href="#l22.21"></a><span id="l22.21"> #define _nsMsgThreadedDBView_H_</span>
<a href="#l22.22"></a><span id="l22.22"> </span>
<a href="#l22.23"></a><span id="l22.23" class="difflineminus">-#include &quot;nsMsgDBView.h&quot;</span>
<a href="#l22.24"></a><span id="l22.24" class="difflineplus">+#include &quot;nsMsgGroupView.h&quot;</span>
<a href="#l22.25"></a><span id="l22.25"> </span>
<a href="#l22.26"></a><span id="l22.26" class="difflineminus">-// this class should probably inherit from the class that</span>
<a href="#l22.27"></a><span id="l22.27" class="difflineminus">-// implements the tree. Since I don't know what that is yet,</span>
<a href="#l22.28"></a><span id="l22.28" class="difflineminus">-// I'll just make it inherit from nsMsgDBView for now.</span>
<a href="#l22.29"></a><span id="l22.29" class="difflineminus">-class nsMsgThreadedDBView : public nsMsgDBView</span>
<a href="#l22.30"></a><span id="l22.30" class="difflineplus">+class nsMsgThreadedDBView : public nsMsgGroupView</span>
<a href="#l22.31"></a><span id="l22.31"> {</span>
<a href="#l22.32"></a><span id="l22.32"> public:</span>
<a href="#l22.33"></a><span id="l22.33">   nsMsgThreadedDBView();</span>
<a href="#l22.34"></a><span id="l22.34">   virtual ~nsMsgThreadedDBView();</span>
<a href="#l22.35"></a><span id="l22.35"> </span>
<a href="#l22.36"></a><span id="l22.36">   NS_IMETHOD Open(nsIMsgFolder *folder, nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder, nsMsgViewFlagsTypeValue viewFlags, PRInt32 *pCount);</span>
<a href="#l22.37"></a><span id="l22.37">   NS_IMETHOD CloneDBView(nsIMessenger *aMessengerInstance, nsIMsgWindow *aMsgWindow, nsIMsgDBViewCommandUpdater *aCommandUpdater, nsIMsgDBView **_retval);</span>
<a href="#l22.38"></a><span id="l22.38">   NS_IMETHOD Close();</span>
<a href="#l22.39"></a><span id="l22.39">   virtual nsresult AddKeys(nsMsgKey *pKeys, PRInt32 *pFlags, const char *pLevels, nsMsgViewSortTypeValue sortType, PRInt32 numKeysToAdd);</span>
<a href="#l22.40"></a><span id="l22.40">   NS_IMETHOD Sort(nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder);</span>
<a href="#l22.41"></a><span id="l22.41">   NS_IMETHOD GetViewType(nsMsgViewTypeValue *aViewType);</span>
<a href="#l22.42"></a><span id="l22.42" class="difflineminus">-  NS_IMETHOD GetSupportsThreading(PRBool *aResult);</span>
<a href="#l22.43"></a><span id="l22.43" class="difflineminus">-</span>
<a href="#l22.44"></a><span id="l22.44">   NS_IMETHOD OnParentChanged (nsMsgKey aKeyChanged, nsMsgKey oldParent, nsMsgKey newParent, nsIDBChangeListener *aInstigator);</span>
<a href="#l22.45"></a><span id="l22.45"> </span>
<a href="#l22.46"></a><span id="l22.46"> protected:</span>
<a href="#l22.47"></a><span id="l22.47">   virtual const char * GetViewName(void) {return &quot;ThreadedDBView&quot;; }</span>
<a href="#l22.48"></a><span id="l22.48">   nsresult InitThreadedView(PRInt32 *pCount);</span>
<a href="#l22.49"></a><span id="l22.49">   virtual nsresult OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey aParentKey, PRBool ensureListed);</span>
<a href="#l22.50"></a><span id="l22.50">   virtual nsresult AddMsgToThreadNotInView(nsIMsgThread *threadHdr, nsIMsgDBHdr *msgHdr, PRBool ensureListed);</span>
<a href="#l22.51"></a><span id="l22.51">   nsresult ListThreadIds(nsMsgKey *startMsg, PRBool unreadOnly, nsMsgKey *pOutput, PRInt32 *pFlags, char *pLevels, </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1">new file mode 100644</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineminus">--- /dev/null</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineplus">+++ b/mailnews/base/src/nsMsgXFViewThread.cpp</span>
<a href="#l23.4"></a><span id="l23.4" class="difflineat">@@ -0,0 +1,511 @@</span>
<a href="#l23.5"></a><span id="l23.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l23.6"></a><span id="l23.6" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l23.7"></a><span id="l23.7" class="difflineplus">+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l23.8"></a><span id="l23.8" class="difflineplus">+ *</span>
<a href="#l23.9"></a><span id="l23.9" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l23.10"></a><span id="l23.10" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l23.11"></a><span id="l23.11" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+ *</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l23.16"></a><span id="l23.16" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l23.17"></a><span id="l23.17" class="difflineplus">+ * License.</span>
<a href="#l23.18"></a><span id="l23.18" class="difflineplus">+ *</span>
<a href="#l23.19"></a><span id="l23.19" class="difflineplus">+ * The Original Code is mozilla.org code.</span>
<a href="#l23.20"></a><span id="l23.20" class="difflineplus">+ *</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineplus">+ * David Bienvenu.</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l23.24"></a><span id="l23.24" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l23.25"></a><span id="l23.25" class="difflineplus">+ *</span>
<a href="#l23.26"></a><span id="l23.26" class="difflineplus">+ * Contributor(s):</span>
<a href="#l23.27"></a><span id="l23.27" class="difflineplus">+ *   David Bienvenu &lt;bienvenu@nventure.com&gt;</span>
<a href="#l23.28"></a><span id="l23.28" class="difflineplus">+ *</span>
<a href="#l23.29"></a><span id="l23.29" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l23.30"></a><span id="l23.30" class="difflineplus">+ * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l23.31"></a><span id="l23.31" class="difflineplus">+ * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l23.32"></a><span id="l23.32" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l23.33"></a><span id="l23.33" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l23.34"></a><span id="l23.34" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l23.35"></a><span id="l23.35" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l23.36"></a><span id="l23.36" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l23.37"></a><span id="l23.37" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l23.38"></a><span id="l23.38" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l23.39"></a><span id="l23.39" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l23.40"></a><span id="l23.40" class="difflineplus">+ *</span>
<a href="#l23.41"></a><span id="l23.41" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l23.42"></a><span id="l23.42" class="difflineplus">+</span>
<a href="#l23.43"></a><span id="l23.43" class="difflineplus">+#include &quot;msgCore.h&quot;</span>
<a href="#l23.44"></a><span id="l23.44" class="difflineplus">+#include &quot;nsMsgXFViewThread.h&quot;</span>
<a href="#l23.45"></a><span id="l23.45" class="difflineplus">+#include &quot;nsMsgSearchDBView.h&quot;</span>
<a href="#l23.46"></a><span id="l23.46" class="difflineplus">+</span>
<a href="#l23.47"></a><span id="l23.47" class="difflineplus">+NS_IMPL_ISUPPORTS1(nsMsgXFViewThread, nsIMsgThread)</span>
<a href="#l23.48"></a><span id="l23.48" class="difflineplus">+</span>
<a href="#l23.49"></a><span id="l23.49" class="difflineplus">+nsMsgXFViewThread::nsMsgXFViewThread(nsMsgSearchDBView *view)</span>
<a href="#l23.50"></a><span id="l23.50" class="difflineplus">+{</span>
<a href="#l23.51"></a><span id="l23.51" class="difflineplus">+  m_numUnreadChildren = 0;</span>
<a href="#l23.52"></a><span id="l23.52" class="difflineplus">+  m_numChildren = 0;</span>
<a href="#l23.53"></a><span id="l23.53" class="difflineplus">+  m_flags = 0;</span>
<a href="#l23.54"></a><span id="l23.54" class="difflineplus">+  m_newestMsgDate = 0;</span>
<a href="#l23.55"></a><span id="l23.55" class="difflineplus">+  m_view = view;</span>
<a href="#l23.56"></a><span id="l23.56" class="difflineplus">+}</span>
<a href="#l23.57"></a><span id="l23.57" class="difflineplus">+</span>
<a href="#l23.58"></a><span id="l23.58" class="difflineplus">+nsMsgXFViewThread::~nsMsgXFViewThread()</span>
<a href="#l23.59"></a><span id="l23.59" class="difflineplus">+{</span>
<a href="#l23.60"></a><span id="l23.60" class="difflineplus">+}</span>
<a href="#l23.61"></a><span id="l23.61" class="difflineplus">+</span>
<a href="#l23.62"></a><span id="l23.62" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::SetThreadKey(nsMsgKey threadKey)</span>
<a href="#l23.63"></a><span id="l23.63" class="difflineplus">+{</span>
<a href="#l23.64"></a><span id="l23.64" class="difflineplus">+  NS_ERROR(&quot;shouldn't call this&quot;);</span>
<a href="#l23.65"></a><span id="l23.65" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l23.66"></a><span id="l23.66" class="difflineplus">+}</span>
<a href="#l23.67"></a><span id="l23.67" class="difflineplus">+</span>
<a href="#l23.68"></a><span id="l23.68" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetThreadKey(nsMsgKey *aResult)</span>
<a href="#l23.69"></a><span id="l23.69" class="difflineplus">+{</span>
<a href="#l23.70"></a><span id="l23.70" class="difflineplus">+  NS_ERROR(&quot;shouldn't call this&quot;);</span>
<a href="#l23.71"></a><span id="l23.71" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l23.72"></a><span id="l23.72" class="difflineplus">+}</span>
<a href="#l23.73"></a><span id="l23.73" class="difflineplus">+</span>
<a href="#l23.74"></a><span id="l23.74" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetFlags(PRUint32 *aFlags)</span>
<a href="#l23.75"></a><span id="l23.75" class="difflineplus">+{</span>
<a href="#l23.76"></a><span id="l23.76" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aFlags);</span>
<a href="#l23.77"></a><span id="l23.77" class="difflineplus">+  *aFlags = m_flags;</span>
<a href="#l23.78"></a><span id="l23.78" class="difflineplus">+  return NS_OK;</span>
<a href="#l23.79"></a><span id="l23.79" class="difflineplus">+}</span>
<a href="#l23.80"></a><span id="l23.80" class="difflineplus">+</span>
<a href="#l23.81"></a><span id="l23.81" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::SetFlags(PRUint32 aFlags)</span>
<a href="#l23.82"></a><span id="l23.82" class="difflineplus">+{</span>
<a href="#l23.83"></a><span id="l23.83" class="difflineplus">+  m_flags = aFlags;</span>
<a href="#l23.84"></a><span id="l23.84" class="difflineplus">+  return NS_OK;</span>
<a href="#l23.85"></a><span id="l23.85" class="difflineplus">+}</span>
<a href="#l23.86"></a><span id="l23.86" class="difflineplus">+</span>
<a href="#l23.87"></a><span id="l23.87" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::SetSubject(const nsACString&amp; aSubject)</span>
<a href="#l23.88"></a><span id="l23.88" class="difflineplus">+{</span>
<a href="#l23.89"></a><span id="l23.89" class="difflineplus">+  NS_ASSERTION(PR_FALSE, &quot;shouldn't call this&quot;);</span>
<a href="#l23.90"></a><span id="l23.90" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l23.91"></a><span id="l23.91" class="difflineplus">+}</span>
<a href="#l23.92"></a><span id="l23.92" class="difflineplus">+</span>
<a href="#l23.93"></a><span id="l23.93" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetSubject(nsACString&amp; result)</span>
<a href="#l23.94"></a><span id="l23.94" class="difflineplus">+{</span>
<a href="#l23.95"></a><span id="l23.95" class="difflineplus">+  NS_ASSERTION(PR_FALSE, &quot;shouldn't call this&quot;);</span>
<a href="#l23.96"></a><span id="l23.96" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l23.97"></a><span id="l23.97" class="difflineplus">+}</span>
<a href="#l23.98"></a><span id="l23.98" class="difflineplus">+</span>
<a href="#l23.99"></a><span id="l23.99" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetNumChildren(PRUint32 *aNumChildren)</span>
<a href="#l23.100"></a><span id="l23.100" class="difflineplus">+{</span>
<a href="#l23.101"></a><span id="l23.101" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aNumChildren);</span>
<a href="#l23.102"></a><span id="l23.102" class="difflineplus">+  *aNumChildren = m_keys.Length();</span>
<a href="#l23.103"></a><span id="l23.103" class="difflineplus">+  return NS_OK;</span>
<a href="#l23.104"></a><span id="l23.104" class="difflineplus">+}</span>
<a href="#l23.105"></a><span id="l23.105" class="difflineplus">+</span>
<a href="#l23.106"></a><span id="l23.106" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetNumUnreadChildren (PRUint32 *aNumUnreadChildren)</span>
<a href="#l23.107"></a><span id="l23.107" class="difflineplus">+{</span>
<a href="#l23.108"></a><span id="l23.108" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aNumUnreadChildren);</span>
<a href="#l23.109"></a><span id="l23.109" class="difflineplus">+  *aNumUnreadChildren = m_numUnreadChildren;</span>
<a href="#l23.110"></a><span id="l23.110" class="difflineplus">+  return NS_OK;</span>
<a href="#l23.111"></a><span id="l23.111" class="difflineplus">+}</span>
<a href="#l23.112"></a><span id="l23.112" class="difflineplus">+</span>
<a href="#l23.113"></a><span id="l23.113" class="difflineplus">+NS_IMETHODIMP </span>
<a href="#l23.114"></a><span id="l23.114" class="difflineplus">+nsMsgXFViewThread::AddChild(nsIMsgDBHdr *aNewHdr, nsIMsgDBHdr *aInReplyTo, </span>
<a href="#l23.115"></a><span id="l23.115" class="difflineplus">+                            PRBool aThreadInThread, nsIDBChangeAnnouncer *aAnnouncer)</span>
<a href="#l23.116"></a><span id="l23.116" class="difflineplus">+{</span>
<a href="#l23.117"></a><span id="l23.117" class="difflineplus">+  PRUint32 whereInserted;</span>
<a href="#l23.118"></a><span id="l23.118" class="difflineplus">+  return AddHdr(aNewHdr, PR_FALSE, whereInserted, nsnull);</span>
<a href="#l23.119"></a><span id="l23.119" class="difflineplus">+}</span>
<a href="#l23.120"></a><span id="l23.120" class="difflineplus">+</span>
<a href="#l23.121"></a><span id="l23.121" class="difflineplus">+// Returns the parent of the newly added header. If reparentChildren</span>
<a href="#l23.122"></a><span id="l23.122" class="difflineplus">+// is true, we believe that the new header is a parent of an existing</span>
<a href="#l23.123"></a><span id="l23.123" class="difflineplus">+// header, and we should find it, and reparent it.</span>
<a href="#l23.124"></a><span id="l23.124" class="difflineplus">+nsresult nsMsgXFViewThread::AddHdr(nsIMsgDBHdr *newHdr,</span>
<a href="#l23.125"></a><span id="l23.125" class="difflineplus">+                                   PRBool reparentChildren,</span>
<a href="#l23.126"></a><span id="l23.126" class="difflineplus">+                                   PRUint32 &amp;whereInserted,</span>
<a href="#l23.127"></a><span id="l23.127" class="difflineplus">+                                   nsIMsgDBHdr **outParent)</span>
<a href="#l23.128"></a><span id="l23.128" class="difflineplus">+{</span>
<a href="#l23.129"></a><span id="l23.129" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; newHdrFolder;</span>
<a href="#l23.130"></a><span id="l23.130" class="difflineplus">+  newHdr-&gt;GetFolder(getter_AddRefs(newHdrFolder));</span>
<a href="#l23.131"></a><span id="l23.131" class="difflineplus">+</span>
<a href="#l23.132"></a><span id="l23.132" class="difflineplus">+  PRUint32 newHdrFlags = 0;</span>
<a href="#l23.133"></a><span id="l23.133" class="difflineplus">+  PRUint32 msgDate;</span>
<a href="#l23.134"></a><span id="l23.134" class="difflineplus">+  nsMsgKey newHdrKey = 0;</span>
<a href="#l23.135"></a><span id="l23.135" class="difflineplus">+</span>
<a href="#l23.136"></a><span id="l23.136" class="difflineplus">+  newHdr-&gt;GetMessageKey(&amp;newHdrKey);</span>
<a href="#l23.137"></a><span id="l23.137" class="difflineplus">+  newHdr-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l23.138"></a><span id="l23.138" class="difflineplus">+  newHdr-&gt;GetFlags(&amp;newHdrFlags);</span>
<a href="#l23.139"></a><span id="l23.139" class="difflineplus">+  if (msgDate &gt; m_newestMsgDate)</span>
<a href="#l23.140"></a><span id="l23.140" class="difflineplus">+    SetNewestMsgDate(msgDate);</span>
<a href="#l23.141"></a><span id="l23.141" class="difflineplus">+</span>
<a href="#l23.142"></a><span id="l23.142" class="difflineplus">+  if (newHdrFlags &amp; MSG_FLAG_WATCHED)</span>
<a href="#l23.143"></a><span id="l23.143" class="difflineplus">+    SetFlags(m_flags | MSG_FLAG_WATCHED);</span>
<a href="#l23.144"></a><span id="l23.144" class="difflineplus">+</span>
<a href="#l23.145"></a><span id="l23.145" class="difflineplus">+  ChangeChildCount(1);</span>
<a href="#l23.146"></a><span id="l23.146" class="difflineplus">+  if (! (newHdrFlags &amp; MSG_FLAG_READ))</span>
<a href="#l23.147"></a><span id="l23.147" class="difflineplus">+    ChangeUnreadChildCount(1);</span>
<a href="#l23.148"></a><span id="l23.148" class="difflineplus">+</span>
<a href="#l23.149"></a><span id="l23.149" class="difflineplus">+  if (m_numChildren == 1)</span>
<a href="#l23.150"></a><span id="l23.150" class="difflineplus">+  {</span>
<a href="#l23.151"></a><span id="l23.151" class="difflineplus">+    m_keys.InsertElementAt(0, newHdrKey);</span>
<a href="#l23.152"></a><span id="l23.152" class="difflineplus">+    m_levels.InsertElementAt(0, 0);</span>
<a href="#l23.153"></a><span id="l23.153" class="difflineplus">+    m_folders.InsertObjectAt(newHdrFolder, 0);</span>
<a href="#l23.154"></a><span id="l23.154" class="difflineplus">+    if (outParent)</span>
<a href="#l23.155"></a><span id="l23.155" class="difflineplus">+      *outParent = nsnull;</span>
<a href="#l23.156"></a><span id="l23.156" class="difflineplus">+    whereInserted = 0;</span>
<a href="#l23.157"></a><span id="l23.157" class="difflineplus">+    return NS_OK;</span>
<a href="#l23.158"></a><span id="l23.158" class="difflineplus">+  }</span>
<a href="#l23.159"></a><span id="l23.159" class="difflineplus">+</span>
<a href="#l23.160"></a><span id="l23.160" class="difflineplus">+  // Find our parent, if any, in the thread. Starting at the newest</span>
<a href="#l23.161"></a><span id="l23.161" class="difflineplus">+  // reference, and working our way back, see if we've mapped that reference</span>
<a href="#l23.162"></a><span id="l23.162" class="difflineplus">+  // to this thread.</span>
<a href="#l23.163"></a><span id="l23.163" class="difflineplus">+  PRUint16 numReferences;</span>
<a href="#l23.164"></a><span id="l23.164" class="difflineplus">+  newHdr-&gt;GetNumReferences(&amp;numReferences);</span>
<a href="#l23.165"></a><span id="l23.165" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; parent;</span>
<a href="#l23.166"></a><span id="l23.166" class="difflineplus">+  PRInt32 parentIndex;</span>
<a href="#l23.167"></a><span id="l23.167" class="difflineplus">+</span>
<a href="#l23.168"></a><span id="l23.168" class="difflineplus">+  for (PRInt32 i = numReferences - 1; i &gt;= 0;  i--)</span>
<a href="#l23.169"></a><span id="l23.169" class="difflineplus">+  {</span>
<a href="#l23.170"></a><span id="l23.170" class="difflineplus">+    nsCAutoString reference;</span>
<a href="#l23.171"></a><span id="l23.171" class="difflineplus">+    newHdr-&gt;GetStringReference(i, reference);</span>
<a href="#l23.172"></a><span id="l23.172" class="difflineplus">+    if (reference.IsEmpty())</span>
<a href="#l23.173"></a><span id="l23.173" class="difflineplus">+      break;</span>
<a href="#l23.174"></a><span id="l23.174" class="difflineplus">+</span>
<a href="#l23.175"></a><span id="l23.175" class="difflineplus">+    // I could look for the thread from the reference, but getting</span>
<a href="#l23.176"></a><span id="l23.176" class="difflineplus">+    // the header directly should be fine. If it's not, that means</span>
<a href="#l23.177"></a><span id="l23.177" class="difflineplus">+    // that the parent isn't in this thread, though it should be.</span>
<a href="#l23.178"></a><span id="l23.178" class="difflineplus">+    m_view-&gt;GetMsgHdrFromHash(reference, getter_AddRefs(parent));</span>
<a href="#l23.179"></a><span id="l23.179" class="difflineplus">+    if (parent)</span>
<a href="#l23.180"></a><span id="l23.180" class="difflineplus">+    {</span>
<a href="#l23.181"></a><span id="l23.181" class="difflineplus">+      parentIndex = HdrIndex(parent);</span>
<a href="#l23.182"></a><span id="l23.182" class="difflineplus">+      if (parentIndex == -1)</span>
<a href="#l23.183"></a><span id="l23.183" class="difflineplus">+      {</span>
<a href="#l23.184"></a><span id="l23.184" class="difflineplus">+        NS_ERROR(&quot;how did we get in the wrong thread?&quot;);</span>
<a href="#l23.185"></a><span id="l23.185" class="difflineplus">+        parent = nsnull;</span>
<a href="#l23.186"></a><span id="l23.186" class="difflineplus">+      }</span>
<a href="#l23.187"></a><span id="l23.187" class="difflineplus">+      break;</span>
<a href="#l23.188"></a><span id="l23.188" class="difflineplus">+    }</span>
<a href="#l23.189"></a><span id="l23.189" class="difflineplus">+  }</span>
<a href="#l23.190"></a><span id="l23.190" class="difflineplus">+  if (parent)</span>
<a href="#l23.191"></a><span id="l23.191" class="difflineplus">+  {</span>
<a href="#l23.192"></a><span id="l23.192" class="difflineplus">+    if (outParent)</span>
<a href="#l23.193"></a><span id="l23.193" class="difflineplus">+      NS_ADDREF(*outParent = parent);</span>
<a href="#l23.194"></a><span id="l23.194" class="difflineplus">+    PRUint8 parentLevel = m_levels[parentIndex];</span>
<a href="#l23.195"></a><span id="l23.195" class="difflineplus">+    nsMsgKey parentKey;</span>
<a href="#l23.196"></a><span id="l23.196" class="difflineplus">+    parent-&gt;GetMessageKey(&amp;parentKey);</span>
<a href="#l23.197"></a><span id="l23.197" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolder&gt; parentFolder;</span>
<a href="#l23.198"></a><span id="l23.198" class="difflineplus">+    parent-&gt;GetFolder(getter_AddRefs(parentFolder));</span>
<a href="#l23.199"></a><span id="l23.199" class="difflineplus">+    // iterate over our parents' children until we find one we're older than,</span>
<a href="#l23.200"></a><span id="l23.200" class="difflineplus">+    // and insert ourselves before it, or as the last child. In other words,</span>
<a href="#l23.201"></a><span id="l23.201" class="difflineplus">+    // insert, sorted by date.</span>
<a href="#l23.202"></a><span id="l23.202" class="difflineplus">+    PRUint32 msgDate, childDate;</span>
<a href="#l23.203"></a><span id="l23.203" class="difflineplus">+    newHdr-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l23.204"></a><span id="l23.204" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; child;</span>
<a href="#l23.205"></a><span id="l23.205" class="difflineplus">+    nsMsgViewIndex i;</span>
<a href="#l23.206"></a><span id="l23.206" class="difflineplus">+    PRInt32 insertIndex = m_keys.Length();</span>
<a href="#l23.207"></a><span id="l23.207" class="difflineplus">+    for (i = parentIndex; </span>
<a href="#l23.208"></a><span id="l23.208" class="difflineplus">+         i &lt; m_keys.Length() &amp;&amp; (i == parentIndex ||  m_levels[i] &gt; parentLevel); i++)</span>
<a href="#l23.209"></a><span id="l23.209" class="difflineplus">+    {</span>
<a href="#l23.210"></a><span id="l23.210" class="difflineplus">+      if (m_levels[i] == parentLevel + 1) // possible sibling</span>
<a href="#l23.211"></a><span id="l23.211" class="difflineplus">+      {</span>
<a href="#l23.212"></a><span id="l23.212" class="difflineplus">+        GetChildHdrAt(i, getter_AddRefs(child));</span>
<a href="#l23.213"></a><span id="l23.213" class="difflineplus">+        if (child)</span>
<a href="#l23.214"></a><span id="l23.214" class="difflineplus">+        {</span>
<a href="#l23.215"></a><span id="l23.215" class="difflineplus">+          if (reparentChildren &amp;&amp; IsHdrParentOf(newHdr, child))</span>
<a href="#l23.216"></a><span id="l23.216" class="difflineplus">+          {</span>
<a href="#l23.217"></a><span id="l23.217" class="difflineplus">+            insertIndex = i;</span>
<a href="#l23.218"></a><span id="l23.218" class="difflineplus">+            // bump all the children of the current child.</span>
<a href="#l23.219"></a><span id="l23.219" class="difflineplus">+            nsMsgViewIndex i = insertIndex; </span>
<a href="#l23.220"></a><span id="l23.220" class="difflineplus">+            do </span>
<a href="#l23.221"></a><span id="l23.221" class="difflineplus">+            {</span>
<a href="#l23.222"></a><span id="l23.222" class="difflineplus">+              m_levels[i] = m_levels[i] + 1;</span>
<a href="#l23.223"></a><span id="l23.223" class="difflineplus">+              i++;</span>
<a href="#l23.224"></a><span id="l23.224" class="difflineplus">+            }</span>
<a href="#l23.225"></a><span id="l23.225" class="difflineplus">+            while (i &lt; m_keys.Length() &amp;&amp; m_levels[i] &gt; parentLevel + 1);</span>
<a href="#l23.226"></a><span id="l23.226" class="difflineplus">+            break;</span>
<a href="#l23.227"></a><span id="l23.227" class="difflineplus">+          }</span>
<a href="#l23.228"></a><span id="l23.228" class="difflineplus">+          else</span>
<a href="#l23.229"></a><span id="l23.229" class="difflineplus">+          {</span>
<a href="#l23.230"></a><span id="l23.230" class="difflineplus">+            child-&gt;GetDateInSeconds(&amp;childDate);</span>
<a href="#l23.231"></a><span id="l23.231" class="difflineplus">+            if (msgDate &lt; childDate)</span>
<a href="#l23.232"></a><span id="l23.232" class="difflineplus">+            {</span>
<a href="#l23.233"></a><span id="l23.233" class="difflineplus">+              // if we think we need to reparent, remember this</span>
<a href="#l23.234"></a><span id="l23.234" class="difflineplus">+              // insert index, but keep looking for children.</span>
<a href="#l23.235"></a><span id="l23.235" class="difflineplus">+              insertIndex = i;</span>
<a href="#l23.236"></a><span id="l23.236" class="difflineplus">+              if (!reparentChildren)</span>
<a href="#l23.237"></a><span id="l23.237" class="difflineplus">+                break;</span>
<a href="#l23.238"></a><span id="l23.238" class="difflineplus">+            }</span>
<a href="#l23.239"></a><span id="l23.239" class="difflineplus">+          }</span>
<a href="#l23.240"></a><span id="l23.240" class="difflineplus">+        }</span>
<a href="#l23.241"></a><span id="l23.241" class="difflineplus">+      }</span>
<a href="#l23.242"></a><span id="l23.242" class="difflineplus">+    }</span>
<a href="#l23.243"></a><span id="l23.243" class="difflineplus">+    m_keys.InsertElementAt(insertIndex, newHdrKey);</span>
<a href="#l23.244"></a><span id="l23.244" class="difflineplus">+    m_levels.InsertElementAt(insertIndex, m_levels[parentIndex] + 1);</span>
<a href="#l23.245"></a><span id="l23.245" class="difflineplus">+    m_folders.InsertObjectAt(newHdrFolder, insertIndex);</span>
<a href="#l23.246"></a><span id="l23.246" class="difflineplus">+    whereInserted = insertIndex;</span>
<a href="#l23.247"></a><span id="l23.247" class="difflineplus">+  }</span>
<a href="#l23.248"></a><span id="l23.248" class="difflineplus">+  else</span>
<a href="#l23.249"></a><span id="l23.249" class="difflineplus">+  {</span>
<a href="#l23.250"></a><span id="l23.250" class="difflineplus">+    if (outParent)</span>
<a href="#l23.251"></a><span id="l23.251" class="difflineplus">+      *outParent = nsnull;</span>
<a href="#l23.252"></a><span id="l23.252" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; rootHdr;</span>
<a href="#l23.253"></a><span id="l23.253" class="difflineplus">+    GetChildHdrAt(0, getter_AddRefs(rootHdr));</span>
<a href="#l23.254"></a><span id="l23.254" class="difflineplus">+    // If the new header is a parent of the root then it should be promoted. </span>
<a href="#l23.255"></a><span id="l23.255" class="difflineplus">+    if (rootHdr &amp;&amp; IsHdrParentOf(newHdr, rootHdr))</span>
<a href="#l23.256"></a><span id="l23.256" class="difflineplus">+    {</span>
<a href="#l23.257"></a><span id="l23.257" class="difflineplus">+      m_keys.InsertElementAt(0, newHdrKey);</span>
<a href="#l23.258"></a><span id="l23.258" class="difflineplus">+      m_levels.InsertElementAt(0, 0);</span>
<a href="#l23.259"></a><span id="l23.259" class="difflineplus">+      m_folders.InsertObjectAt(newHdrFolder, 0);</span>
<a href="#l23.260"></a><span id="l23.260" class="difflineplus">+      whereInserted = 0;</span>
<a href="#l23.261"></a><span id="l23.261" class="difflineplus">+      // Adjust level of root hdr. We still have to reparent children of root,</span>
<a href="#l23.262"></a><span id="l23.262" class="difflineplus">+      // and adjust levels if if neccessary.</span>
<a href="#l23.263"></a><span id="l23.263" class="difflineplus">+      m_levels[1] = 1;</span>
<a href="#l23.264"></a><span id="l23.264" class="difflineplus">+    }</span>
<a href="#l23.265"></a><span id="l23.265" class="difflineplus">+    else</span>
<a href="#l23.266"></a><span id="l23.266" class="difflineplus">+    {</span>
<a href="#l23.267"></a><span id="l23.267" class="difflineplus">+      m_keys.AppendElement(newHdrKey);</span>
<a href="#l23.268"></a><span id="l23.268" class="difflineplus">+      m_levels.AppendElement(1);</span>
<a href="#l23.269"></a><span id="l23.269" class="difflineplus">+      m_folders.AppendObject(newHdrFolder);</span>
<a href="#l23.270"></a><span id="l23.270" class="difflineplus">+      if (outParent)</span>
<a href="#l23.271"></a><span id="l23.271" class="difflineplus">+        NS_ADDREF(*outParent = rootHdr);</span>
<a href="#l23.272"></a><span id="l23.272" class="difflineplus">+      whereInserted = m_keys.Length() -1;</span>
<a href="#l23.273"></a><span id="l23.273" class="difflineplus">+    }</span>
<a href="#l23.274"></a><span id="l23.274" class="difflineplus">+  }</span>
<a href="#l23.275"></a><span id="l23.275" class="difflineplus">+</span>
<a href="#l23.276"></a><span id="l23.276" class="difflineplus">+  // ### TODO handle the case where the root header starts </span>
<a href="#l23.277"></a><span id="l23.277" class="difflineplus">+  // with Re, and the new one doesn't, and is earlier. In that</span>
<a href="#l23.278"></a><span id="l23.278" class="difflineplus">+  // case, we want to promote the new header to root.</span>
<a href="#l23.279"></a><span id="l23.279" class="difflineplus">+</span>
<a href="#l23.280"></a><span id="l23.280" class="difflineplus">+//  PRTime newHdrDate;</span>
<a href="#l23.281"></a><span id="l23.281" class="difflineplus">+//  newHdr-&gt;GetDate(&amp;newHdrDate);</span>
<a href="#l23.282"></a><span id="l23.282" class="difflineplus">+</span>
<a href="#l23.283"></a><span id="l23.283" class="difflineplus">+//  if (numChildren &gt; 0 &amp;&amp; !(newHdrFlags &amp; MSG_FLAG_HAS_RE))</span>
<a href="#l23.284"></a><span id="l23.284" class="difflineplus">+//  {</span>
<a href="#l23.285"></a><span id="l23.285" class="difflineplus">+//    PRTime topLevelHdrDate;</span>
<a href="#l23.286"></a><span id="l23.286" class="difflineplus">+</span>
<a href="#l23.287"></a><span id="l23.287" class="difflineplus">+//    nsCOMPtr&lt;nsIMsgDBHdr&gt; topLevelHdr;</span>
<a href="#l23.288"></a><span id="l23.288" class="difflineplus">+//    rv = GetRootHdr(nsnull, getter_AddRefs(topLevelHdr));</span>
<a href="#l23.289"></a><span id="l23.289" class="difflineplus">+//    if (NS_SUCCEEDED(rv) &amp;&amp; topLevelHdr)</span>
<a href="#l23.290"></a><span id="l23.290" class="difflineplus">+//    {</span>
<a href="#l23.291"></a><span id="l23.291" class="difflineplus">+//      topLevelHdr-&gt;GetDate(&amp;topLevelHdrDate);</span>
<a href="#l23.292"></a><span id="l23.292" class="difflineplus">+//      if (LL_CMP(newHdrDate, &lt;, topLevelHdrDate))</span>
<a href="#l23.293"></a><span id="l23.293" class="difflineplus">+      </span>
<a href="#l23.294"></a><span id="l23.294" class="difflineplus">+//    }</span>
<a href="#l23.295"></a><span id="l23.295" class="difflineplus">+//  }</span>
<a href="#l23.296"></a><span id="l23.296" class="difflineplus">+  return NS_OK;</span>
<a href="#l23.297"></a><span id="l23.297" class="difflineplus">+}</span>
<a href="#l23.298"></a><span id="l23.298" class="difflineplus">+</span>
<a href="#l23.299"></a><span id="l23.299" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetChildAt(PRInt32 aIndex, nsIMsgDBHdr **aResult)</span>
<a href="#l23.300"></a><span id="l23.300" class="difflineplus">+{</span>
<a href="#l23.301"></a><span id="l23.301" class="difflineplus">+  if (aIndex &gt;= (PRInt32) m_keys.Length())</span>
<a href="#l23.302"></a><span id="l23.302" class="difflineplus">+    return NS_MSG_MESSAGE_NOT_FOUND;</span>
<a href="#l23.303"></a><span id="l23.303" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l23.304"></a><span id="l23.304" class="difflineplus">+  nsresult rv = m_folders[aIndex]-&gt;GetMsgDatabase(nsnull, getter_AddRefs(db));</span>
<a href="#l23.305"></a><span id="l23.305" class="difflineplus">+  NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l23.306"></a><span id="l23.306" class="difflineplus">+  return db-&gt;GetMsgHdrForKey(m_keys[aIndex], aResult);</span>
<a href="#l23.307"></a><span id="l23.307" class="difflineplus">+}</span>
<a href="#l23.308"></a><span id="l23.308" class="difflineplus">+</span>
<a href="#l23.309"></a><span id="l23.309" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetChildHdrAt(PRInt32 aIndex, nsIMsgDBHdr **aResult)</span>
<a href="#l23.310"></a><span id="l23.310" class="difflineplus">+{</span>
<a href="#l23.311"></a><span id="l23.311" class="difflineplus">+  return GetChildAt(aIndex, aResult);</span>
<a href="#l23.312"></a><span id="l23.312" class="difflineplus">+}</span>
<a href="#l23.313"></a><span id="l23.313" class="difflineplus">+</span>
<a href="#l23.314"></a><span id="l23.314" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::RemoveChildAt(PRInt32 aIndex)</span>
<a href="#l23.315"></a><span id="l23.315" class="difflineplus">+{</span>
<a href="#l23.316"></a><span id="l23.316" class="difflineplus">+  m_keys.RemoveElementAt(aIndex);</span>
<a href="#l23.317"></a><span id="l23.317" class="difflineplus">+  m_levels.RemoveElementAt(aIndex);</span>
<a href="#l23.318"></a><span id="l23.318" class="difflineplus">+  m_folders.RemoveObjectAt(aIndex);</span>
<a href="#l23.319"></a><span id="l23.319" class="difflineplus">+  return NS_OK;</span>
<a href="#l23.320"></a><span id="l23.320" class="difflineplus">+}</span>
<a href="#l23.321"></a><span id="l23.321" class="difflineplus">+</span>
<a href="#l23.322"></a><span id="l23.322" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::RemoveChildHdr(nsIMsgDBHdr *child, nsIDBChangeAnnouncer *announcer)</span>
<a href="#l23.323"></a><span id="l23.323" class="difflineplus">+{</span>
<a href="#l23.324"></a><span id="l23.324" class="difflineplus">+  NS_ENSURE_ARG_POINTER(child);</span>
<a href="#l23.325"></a><span id="l23.325" class="difflineplus">+  nsMsgKey msgKey;</span>
<a href="#l23.326"></a><span id="l23.326" class="difflineplus">+  PRUint32 msgFlags;</span>
<a href="#l23.327"></a><span id="l23.327" class="difflineplus">+  child-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l23.328"></a><span id="l23.328" class="difflineplus">+  child-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l23.329"></a><span id="l23.329" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l23.330"></a><span id="l23.330" class="difflineplus">+  child-&gt;GetFolder(getter_AddRefs(msgFolder));</span>
<a href="#l23.331"></a><span id="l23.331" class="difflineplus">+  // if this was the newest msg, clear the newest msg date so we'll recalc.</span>
<a href="#l23.332"></a><span id="l23.332" class="difflineplus">+  PRUint32 date;</span>
<a href="#l23.333"></a><span id="l23.333" class="difflineplus">+  child-&gt;GetDateInSeconds(&amp;date);</span>
<a href="#l23.334"></a><span id="l23.334" class="difflineplus">+  if (date == m_newestMsgDate)</span>
<a href="#l23.335"></a><span id="l23.335" class="difflineplus">+    SetNewestMsgDate(0);</span>
<a href="#l23.336"></a><span id="l23.336" class="difflineplus">+</span>
<a href="#l23.337"></a><span id="l23.337" class="difflineplus">+  for (PRUint32 childIndex = 0; childIndex &lt; m_keys.Length(); childIndex++)</span>
<a href="#l23.338"></a><span id="l23.338" class="difflineplus">+  {</span>
<a href="#l23.339"></a><span id="l23.339" class="difflineplus">+    if (m_keys[childIndex] == msgKey &amp;&amp; m_folders[childIndex] == msgFolder)</span>
<a href="#l23.340"></a><span id="l23.340" class="difflineplus">+    {</span>
<a href="#l23.341"></a><span id="l23.341" class="difflineplus">+      PRUint8 levelRemoved = m_keys[childIndex];</span>
<a href="#l23.342"></a><span id="l23.342" class="difflineplus">+      // Adjust the levels of all the children of this header</span>
<a href="#l23.343"></a><span id="l23.343" class="difflineplus">+      nsMsgViewIndex i;</span>
<a href="#l23.344"></a><span id="l23.344" class="difflineplus">+      for (i = childIndex + 1; </span>
<a href="#l23.345"></a><span id="l23.345" class="difflineplus">+               i &lt; m_keys.Length() &amp;&amp; m_levels[i] &gt; levelRemoved; i++)</span>
<a href="#l23.346"></a><span id="l23.346" class="difflineplus">+            m_levels[i] = m_levels[i] - 1;</span>
<a href="#l23.347"></a><span id="l23.347" class="difflineplus">+</span>
<a href="#l23.348"></a><span id="l23.348" class="difflineplus">+      m_view-&gt;NoteChange(childIndex + 1, i - childIndex + 1,</span>
<a href="#l23.349"></a><span id="l23.349" class="difflineplus">+                         nsMsgViewNotificationCode::changed);</span>
<a href="#l23.350"></a><span id="l23.350" class="difflineplus">+      m_keys.RemoveElementAt(childIndex);</span>
<a href="#l23.351"></a><span id="l23.351" class="difflineplus">+      m_levels.RemoveElementAt(childIndex);</span>
<a href="#l23.352"></a><span id="l23.352" class="difflineplus">+      m_folders.RemoveObjectAt(childIndex);</span>
<a href="#l23.353"></a><span id="l23.353" class="difflineplus">+      if (!(msgFlags &amp; MSG_FLAG_READ))</span>
<a href="#l23.354"></a><span id="l23.354" class="difflineplus">+        ChangeUnreadChildCount(-1);</span>
<a href="#l23.355"></a><span id="l23.355" class="difflineplus">+      ChangeChildCount(-1);</span>
<a href="#l23.356"></a><span id="l23.356" class="difflineplus">+      return NS_OK;</span>
<a href="#l23.357"></a><span id="l23.357" class="difflineplus">+    }</span>
<a href="#l23.358"></a><span id="l23.358" class="difflineplus">+  }</span>
<a href="#l23.359"></a><span id="l23.359" class="difflineplus">+  return NS_ERROR_FAILURE;</span>
<a href="#l23.360"></a><span id="l23.360" class="difflineplus">+}</span>
<a href="#l23.361"></a><span id="l23.361" class="difflineplus">+</span>
<a href="#l23.362"></a><span id="l23.362" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetRootHdr(PRInt32 *aResultIndex, nsIMsgDBHdr **aResult)</span>
<a href="#l23.363"></a><span id="l23.363" class="difflineplus">+{</span>
<a href="#l23.364"></a><span id="l23.364" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l23.365"></a><span id="l23.365" class="difflineplus">+  if (aResultIndex)</span>
<a href="#l23.366"></a><span id="l23.366" class="difflineplus">+    *aResultIndex = 0;</span>
<a href="#l23.367"></a><span id="l23.367" class="difflineplus">+  return GetChildHdrAt(0, aResult);</span>
<a href="#l23.368"></a><span id="l23.368" class="difflineplus">+}</span>
<a href="#l23.369"></a><span id="l23.369" class="difflineplus">+</span>
<a href="#l23.370"></a><span id="l23.370" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetChildKeyAt(PRInt32 aIndex, nsMsgKey *aResult)</span>
<a href="#l23.371"></a><span id="l23.371" class="difflineplus">+{</span>
<a href="#l23.372"></a><span id="l23.372" class="difflineplus">+  NS_ASSERTION(PR_FALSE, &quot;shouldn't call this&quot;);</span>
<a href="#l23.373"></a><span id="l23.373" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l23.374"></a><span id="l23.374" class="difflineplus">+}</span>
<a href="#l23.375"></a><span id="l23.375" class="difflineplus">+</span>
<a href="#l23.376"></a><span id="l23.376" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetChild(nsMsgKey msgKey, nsIMsgDBHdr **aResult)</span>
<a href="#l23.377"></a><span id="l23.377" class="difflineplus">+{</span>
<a href="#l23.378"></a><span id="l23.378" class="difflineplus">+  NS_ASSERTION(PR_FALSE, &quot;shouldn't call this&quot;);</span>
<a href="#l23.379"></a><span id="l23.379" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l23.380"></a><span id="l23.380" class="difflineplus">+}</span>
<a href="#l23.381"></a><span id="l23.381" class="difflineplus">+</span>
<a href="#l23.382"></a><span id="l23.382" class="difflineplus">+</span>
<a href="#l23.383"></a><span id="l23.383" class="difflineplus">+PRUint32 nsMsgXFViewThread::HdrIndex(nsIMsgDBHdr *hdr)</span>
<a href="#l23.384"></a><span id="l23.384" class="difflineplus">+{</span>
<a href="#l23.385"></a><span id="l23.385" class="difflineplus">+  nsMsgKey msgKey;</span>
<a href="#l23.386"></a><span id="l23.386" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l23.387"></a><span id="l23.387" class="difflineplus">+  hdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l23.388"></a><span id="l23.388" class="difflineplus">+  hdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l23.389"></a><span id="l23.389" class="difflineplus">+  for (PRUint32 i = 0; i &lt; m_keys.Length(); i++)</span>
<a href="#l23.390"></a><span id="l23.390" class="difflineplus">+  {</span>
<a href="#l23.391"></a><span id="l23.391" class="difflineplus">+    if (m_keys[i] == msgKey &amp;&amp; m_folders[i] == folder)</span>
<a href="#l23.392"></a><span id="l23.392" class="difflineplus">+      return i;</span>
<a href="#l23.393"></a><span id="l23.393" class="difflineplus">+  }</span>
<a href="#l23.394"></a><span id="l23.394" class="difflineplus">+  return -1;</span>
<a href="#l23.395"></a><span id="l23.395" class="difflineplus">+}</span>
<a href="#l23.396"></a><span id="l23.396" class="difflineplus">+</span>
<a href="#l23.397"></a><span id="l23.397" class="difflineplus">+void nsMsgXFViewThread::ChangeUnreadChildCount(PRInt32 delta)</span>
<a href="#l23.398"></a><span id="l23.398" class="difflineplus">+{</span>
<a href="#l23.399"></a><span id="l23.399" class="difflineplus">+  m_numUnreadChildren += delta;</span>
<a href="#l23.400"></a><span id="l23.400" class="difflineplus">+}</span>
<a href="#l23.401"></a><span id="l23.401" class="difflineplus">+</span>
<a href="#l23.402"></a><span id="l23.402" class="difflineplus">+void nsMsgXFViewThread::ChangeChildCount(PRInt32 delta)</span>
<a href="#l23.403"></a><span id="l23.403" class="difflineplus">+{</span>
<a href="#l23.404"></a><span id="l23.404" class="difflineplus">+  m_numChildren += delta;</span>
<a href="#l23.405"></a><span id="l23.405" class="difflineplus">+}</span>
<a href="#l23.406"></a><span id="l23.406" class="difflineplus">+</span>
<a href="#l23.407"></a><span id="l23.407" class="difflineplus">+PRBool nsMsgXFViewThread::IsHdrParentOf(nsIMsgDBHdr *possibleParent, </span>
<a href="#l23.408"></a><span id="l23.408" class="difflineplus">+                                        nsIMsgDBHdr *possibleChild)</span>
<a href="#l23.409"></a><span id="l23.409" class="difflineplus">+{</span>
<a href="#l23.410"></a><span id="l23.410" class="difflineplus">+  PRUint16 referenceToCheck = 0;</span>
<a href="#l23.411"></a><span id="l23.411" class="difflineplus">+  possibleChild-&gt;GetNumReferences(&amp;referenceToCheck);</span>
<a href="#l23.412"></a><span id="l23.412" class="difflineplus">+  nsCAutoString reference;</span>
<a href="#l23.413"></a><span id="l23.413" class="difflineplus">+</span>
<a href="#l23.414"></a><span id="l23.414" class="difflineplus">+  nsCString messageId;</span>
<a href="#l23.415"></a><span id="l23.415" class="difflineplus">+  possibleParent-&gt;GetMessageId(getter_Copies(messageId));</span>
<a href="#l23.416"></a><span id="l23.416" class="difflineplus">+</span>
<a href="#l23.417"></a><span id="l23.417" class="difflineplus">+  while (referenceToCheck &gt; 0)</span>
<a href="#l23.418"></a><span id="l23.418" class="difflineplus">+  {</span>
<a href="#l23.419"></a><span id="l23.419" class="difflineplus">+    possibleChild-&gt;GetStringReference(referenceToCheck - 1, reference);</span>
<a href="#l23.420"></a><span id="l23.420" class="difflineplus">+</span>
<a href="#l23.421"></a><span id="l23.421" class="difflineplus">+    if (reference.Equals(messageId))</span>
<a href="#l23.422"></a><span id="l23.422" class="difflineplus">+      return PR_TRUE;</span>
<a href="#l23.423"></a><span id="l23.423" class="difflineplus">+    // if reference didn't match, check if this ref is for a non-existent</span>
<a href="#l23.424"></a><span id="l23.424" class="difflineplus">+    // header. If it is, continue looking at ancestors.</span>
<a href="#l23.425"></a><span id="l23.425" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; refHdr;</span>
<a href="#l23.426"></a><span id="l23.426" class="difflineplus">+    m_view-&gt;GetMsgHdrFromHash(reference, getter_AddRefs(refHdr));</span>
<a href="#l23.427"></a><span id="l23.427" class="difflineplus">+    if (refHdr)</span>
<a href="#l23.428"></a><span id="l23.428" class="difflineplus">+      break;</span>
<a href="#l23.429"></a><span id="l23.429" class="difflineplus">+    referenceToCheck--;</span>
<a href="#l23.430"></a><span id="l23.430" class="difflineplus">+  }</span>
<a href="#l23.431"></a><span id="l23.431" class="difflineplus">+  return PR_FALSE;</span>
<a href="#l23.432"></a><span id="l23.432" class="difflineplus">+}</span>
<a href="#l23.433"></a><span id="l23.433" class="difflineplus">+</span>
<a href="#l23.434"></a><span id="l23.434" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetNewestMsgDate(PRUint32 *aResult) </span>
<a href="#l23.435"></a><span id="l23.435" class="difflineplus">+{</span>
<a href="#l23.436"></a><span id="l23.436" class="difflineplus">+  // if this hasn't been set, figure it out by enumerating the msgs in the thread.</span>
<a href="#l23.437"></a><span id="l23.437" class="difflineplus">+  if (!m_newestMsgDate)</span>
<a href="#l23.438"></a><span id="l23.438" class="difflineplus">+  {</span>
<a href="#l23.439"></a><span id="l23.439" class="difflineplus">+    PRUint32 numChildren;</span>
<a href="#l23.440"></a><span id="l23.440" class="difflineplus">+    nsresult rv = NS_OK;</span>
<a href="#l23.441"></a><span id="l23.441" class="difflineplus">+  </span>
<a href="#l23.442"></a><span id="l23.442" class="difflineplus">+    GetNumChildren(&amp;numChildren);</span>
<a href="#l23.443"></a><span id="l23.443" class="difflineplus">+  </span>
<a href="#l23.444"></a><span id="l23.444" class="difflineplus">+    if ((PRInt32) numChildren &lt; 0)</span>
<a href="#l23.445"></a><span id="l23.445" class="difflineplus">+      numChildren = 0;</span>
<a href="#l23.446"></a><span id="l23.446" class="difflineplus">+  </span>
<a href="#l23.447"></a><span id="l23.447" class="difflineplus">+    for (PRUint32 childIndex = 0; childIndex &lt; numChildren; childIndex++)</span>
<a href="#l23.448"></a><span id="l23.448" class="difflineplus">+    {</span>
<a href="#l23.449"></a><span id="l23.449" class="difflineplus">+      nsCOMPtr&lt;nsIMsgDBHdr&gt; child;</span>
<a href="#l23.450"></a><span id="l23.450" class="difflineplus">+      rv = GetChildHdrAt(childIndex, getter_AddRefs(child));</span>
<a href="#l23.451"></a><span id="l23.451" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; child)</span>
<a href="#l23.452"></a><span id="l23.452" class="difflineplus">+      {</span>
<a href="#l23.453"></a><span id="l23.453" class="difflineplus">+        PRUint32 msgDate;</span>
<a href="#l23.454"></a><span id="l23.454" class="difflineplus">+        child-&gt;GetDateInSeconds(&amp;msgDate);</span>
<a href="#l23.455"></a><span id="l23.455" class="difflineplus">+        if (msgDate &gt; m_newestMsgDate)</span>
<a href="#l23.456"></a><span id="l23.456" class="difflineplus">+          m_newestMsgDate = msgDate;</span>
<a href="#l23.457"></a><span id="l23.457" class="difflineplus">+      }</span>
<a href="#l23.458"></a><span id="l23.458" class="difflineplus">+    }</span>
<a href="#l23.459"></a><span id="l23.459" class="difflineplus">+  }</span>
<a href="#l23.460"></a><span id="l23.460" class="difflineplus">+  *aResult = m_newestMsgDate;</span>
<a href="#l23.461"></a><span id="l23.461" class="difflineplus">+  return NS_OK;</span>
<a href="#l23.462"></a><span id="l23.462" class="difflineplus">+}</span>
<a href="#l23.463"></a><span id="l23.463" class="difflineplus">+</span>
<a href="#l23.464"></a><span id="l23.464" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::SetNewestMsgDate(PRUint32 aNewestMsgDate) </span>
<a href="#l23.465"></a><span id="l23.465" class="difflineplus">+{</span>
<a href="#l23.466"></a><span id="l23.466" class="difflineplus">+  m_newestMsgDate = aNewestMsgDate;</span>
<a href="#l23.467"></a><span id="l23.467" class="difflineplus">+  return NS_OK;</span>
<a href="#l23.468"></a><span id="l23.468" class="difflineplus">+}</span>
<a href="#l23.469"></a><span id="l23.469" class="difflineplus">+</span>
<a href="#l23.470"></a><span id="l23.470" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::MarkChildRead(PRBool aRead)</span>
<a href="#l23.471"></a><span id="l23.471" class="difflineplus">+{</span>
<a href="#l23.472"></a><span id="l23.472" class="difflineplus">+  ChangeUnreadChildCount(aRead ? -1 : 1);</span>
<a href="#l23.473"></a><span id="l23.473" class="difflineplus">+  return NS_OK;</span>
<a href="#l23.474"></a><span id="l23.474" class="difflineplus">+}</span>
<a href="#l23.475"></a><span id="l23.475" class="difflineplus">+</span>
<a href="#l23.476"></a><span id="l23.476" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::GetFirstUnreadChild(nsIMsgDBHdr **aResult)</span>
<a href="#l23.477"></a><span id="l23.477" class="difflineplus">+{</span>
<a href="#l23.478"></a><span id="l23.478" class="difflineplus">+  NS_ENSURE_ARG(aResult);</span>
<a href="#l23.479"></a><span id="l23.479" class="difflineplus">+  PRUint32 numChildren;</span>
<a href="#l23.480"></a><span id="l23.480" class="difflineplus">+  nsresult rv = NS_OK;</span>
<a href="#l23.481"></a><span id="l23.481" class="difflineplus">+  </span>
<a href="#l23.482"></a><span id="l23.482" class="difflineplus">+  GetNumChildren(&amp;numChildren);</span>
<a href="#l23.483"></a><span id="l23.483" class="difflineplus">+  </span>
<a href="#l23.484"></a><span id="l23.484" class="difflineplus">+  if ((PRInt32) numChildren &lt; 0)</span>
<a href="#l23.485"></a><span id="l23.485" class="difflineplus">+    numChildren = 0;</span>
<a href="#l23.486"></a><span id="l23.486" class="difflineplus">+  </span>
<a href="#l23.487"></a><span id="l23.487" class="difflineplus">+  for (PRUint32 childIndex = 0; childIndex &lt; numChildren; childIndex++)</span>
<a href="#l23.488"></a><span id="l23.488" class="difflineplus">+  {</span>
<a href="#l23.489"></a><span id="l23.489" class="difflineplus">+    nsCOMPtr&lt;nsIMsgDBHdr&gt; child;</span>
<a href="#l23.490"></a><span id="l23.490" class="difflineplus">+    rv = GetChildHdrAt(childIndex, getter_AddRefs(child));</span>
<a href="#l23.491"></a><span id="l23.491" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; child)</span>
<a href="#l23.492"></a><span id="l23.492" class="difflineplus">+    {</span>
<a href="#l23.493"></a><span id="l23.493" class="difflineplus">+      nsMsgKey msgKey;</span>
<a href="#l23.494"></a><span id="l23.494" class="difflineplus">+      child-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l23.495"></a><span id="l23.495" class="difflineplus">+      </span>
<a href="#l23.496"></a><span id="l23.496" class="difflineplus">+      PRBool isRead;</span>
<a href="#l23.497"></a><span id="l23.497" class="difflineplus">+      nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l23.498"></a><span id="l23.498" class="difflineplus">+      nsresult rv = m_folders[childIndex]-&gt;GetMsgDatabase(nsnull, getter_AddRefs(db));</span>
<a href="#l23.499"></a><span id="l23.499" class="difflineplus">+      if (NS_SUCCEEDED(rv))</span>
<a href="#l23.500"></a><span id="l23.500" class="difflineplus">+        rv = db-&gt;IsRead(msgKey, &amp;isRead);</span>
<a href="#l23.501"></a><span id="l23.501" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; !isRead)</span>
<a href="#l23.502"></a><span id="l23.502" class="difflineplus">+      {</span>
<a href="#l23.503"></a><span id="l23.503" class="difflineplus">+        NS_ADDREF(*aResult = child);</span>
<a href="#l23.504"></a><span id="l23.504" class="difflineplus">+        break;</span>
<a href="#l23.505"></a><span id="l23.505" class="difflineplus">+      }</span>
<a href="#l23.506"></a><span id="l23.506" class="difflineplus">+    }</span>
<a href="#l23.507"></a><span id="l23.507" class="difflineplus">+  }</span>
<a href="#l23.508"></a><span id="l23.508" class="difflineplus">+  return rv;</span>
<a href="#l23.509"></a><span id="l23.509" class="difflineplus">+}</span>
<a href="#l23.510"></a><span id="l23.510" class="difflineplus">+NS_IMETHODIMP nsMsgXFViewThread::EnumerateMessages(PRUint32 aParentKey, </span>
<a href="#l23.511"></a><span id="l23.511" class="difflineplus">+                                                   nsISimpleEnumerator **aResult)</span>
<a href="#l23.512"></a><span id="l23.512" class="difflineplus">+{</span>
<a href="#l23.513"></a><span id="l23.513" class="difflineplus">+  NS_ERROR(&quot;shouldn't call this&quot;);</span>
<a href="#l23.514"></a><span id="l23.514" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l23.515"></a><span id="l23.515" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1">new file mode 100644</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineminus">--- /dev/null</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineplus">+++ b/mailnews/base/src/nsMsgXFViewThread.h</span>
<a href="#l24.4"></a><span id="l24.4" class="difflineat">@@ -0,0 +1,85 @@</span>
<a href="#l24.5"></a><span id="l24.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l24.6"></a><span id="l24.6" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l24.7"></a><span id="l24.7" class="difflineplus">+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l24.8"></a><span id="l24.8" class="difflineplus">+ *</span>
<a href="#l24.9"></a><span id="l24.9" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l24.10"></a><span id="l24.10" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l24.11"></a><span id="l24.11" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+ *</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l24.17"></a><span id="l24.17" class="difflineplus">+ * License.</span>
<a href="#l24.18"></a><span id="l24.18" class="difflineplus">+ *</span>
<a href="#l24.19"></a><span id="l24.19" class="difflineplus">+ * The Original Code is mozilla.org code.</span>
<a href="#l24.20"></a><span id="l24.20" class="difflineplus">+ *</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineplus">+ * David Bienvenu.</span>
<a href="#l24.23"></a><span id="l24.23" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l24.24"></a><span id="l24.24" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l24.25"></a><span id="l24.25" class="difflineplus">+ *</span>
<a href="#l24.26"></a><span id="l24.26" class="difflineplus">+ * Contributor(s):</span>
<a href="#l24.27"></a><span id="l24.27" class="difflineplus">+ *   David Bienvenu &lt;bienvenu@nventure.com&gt;</span>
<a href="#l24.28"></a><span id="l24.28" class="difflineplus">+ *</span>
<a href="#l24.29"></a><span id="l24.29" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l24.30"></a><span id="l24.30" class="difflineplus">+ * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l24.31"></a><span id="l24.31" class="difflineplus">+ * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l24.32"></a><span id="l24.32" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l24.33"></a><span id="l24.33" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l24.34"></a><span id="l24.34" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l24.35"></a><span id="l24.35" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l24.37"></a><span id="l24.37" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l24.38"></a><span id="l24.38" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l24.39"></a><span id="l24.39" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l24.40"></a><span id="l24.40" class="difflineplus">+ *</span>
<a href="#l24.41"></a><span id="l24.41" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l24.42"></a><span id="l24.42" class="difflineplus">+#ifndef nsMsgXFViewThread_h__</span>
<a href="#l24.43"></a><span id="l24.43" class="difflineplus">+#define nsMsgXFViewThread_h__</span>
<a href="#l24.44"></a><span id="l24.44" class="difflineplus">+</span>
<a href="#l24.45"></a><span id="l24.45" class="difflineplus">+#include &quot;msgCore.h&quot;</span>
<a href="#l24.46"></a><span id="l24.46" class="difflineplus">+#include &quot;nsCOMArray.h&quot;</span>
<a href="#l24.47"></a><span id="l24.47" class="difflineplus">+#include &quot;nsIMsgThread.h&quot;</span>
<a href="#l24.48"></a><span id="l24.48" class="difflineplus">+#include &quot;MailNewsTypes.h&quot;</span>
<a href="#l24.49"></a><span id="l24.49" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l24.50"></a><span id="l24.50" class="difflineplus">+#include &quot;nsIMsgDatabase.h&quot;</span>
<a href="#l24.51"></a><span id="l24.51" class="difflineplus">+#include &quot;nsIMsgHdr.h&quot;</span>
<a href="#l24.52"></a><span id="l24.52" class="difflineplus">+#include &quot;nsMsgDBView.h&quot;</span>
<a href="#l24.53"></a><span id="l24.53" class="difflineplus">+</span>
<a href="#l24.54"></a><span id="l24.54" class="difflineplus">+class nsMsgSearchDBView;</span>
<a href="#l24.55"></a><span id="l24.55" class="difflineplus">+</span>
<a href="#l24.56"></a><span id="l24.56" class="difflineplus">+class nsMsgXFViewThread : public nsIMsgThread</span>
<a href="#l24.57"></a><span id="l24.57" class="difflineplus">+{</span>
<a href="#l24.58"></a><span id="l24.58" class="difflineplus">+public:</span>
<a href="#l24.59"></a><span id="l24.59" class="difflineplus">+</span>
<a href="#l24.60"></a><span id="l24.60" class="difflineplus">+  nsMsgXFViewThread(nsMsgSearchDBView *view);</span>
<a href="#l24.61"></a><span id="l24.61" class="difflineplus">+  virtual ~nsMsgXFViewThread();</span>
<a href="#l24.62"></a><span id="l24.62" class="difflineplus">+</span>
<a href="#l24.63"></a><span id="l24.63" class="difflineplus">+  NS_DECL_NSIMSGTHREAD</span>
<a href="#l24.64"></a><span id="l24.64" class="difflineplus">+  NS_DECL_ISUPPORTS</span>
<a href="#l24.65"></a><span id="l24.65" class="difflineplus">+</span>
<a href="#l24.66"></a><span id="l24.66" class="difflineplus">+  PRBool    IsHdrParentOf(nsIMsgDBHdr *possibleParent,</span>
<a href="#l24.67"></a><span id="l24.67" class="difflineplus">+                          nsIMsgDBHdr *possibleChild);</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineplus">+</span>
<a href="#l24.69"></a><span id="l24.69" class="difflineplus">+  void      ChangeUnreadChildCount(PRInt32 delta);</span>
<a href="#l24.70"></a><span id="l24.70" class="difflineplus">+  void      ChangeChildCount(PRInt32 delta);</span>
<a href="#l24.71"></a><span id="l24.71" class="difflineplus">+</span>
<a href="#l24.72"></a><span id="l24.72" class="difflineplus">+  nsresult  AddHdr(nsIMsgDBHdr *newHdr, PRBool reparentChildren, </span>
<a href="#l24.73"></a><span id="l24.73" class="difflineplus">+                   PRUint32 &amp;whereInserted, nsIMsgDBHdr **outParent);</span>
<a href="#l24.74"></a><span id="l24.74" class="difflineplus">+  PRUint32  HdrIndex(nsIMsgDBHdr *hdr);</span>
<a href="#l24.75"></a><span id="l24.75" class="difflineplus">+  PRUint32  ChildLevelAt(PRUint32 msgIndex) {return m_levels[msgIndex];}</span>
<a href="#l24.76"></a><span id="l24.76" class="difflineplus">+  PRUint32  MsgCount() {return m_numChildren;};</span>
<a href="#l24.77"></a><span id="l24.77" class="difflineplus">+</span>
<a href="#l24.78"></a><span id="l24.78" class="difflineplus">+protected:</span>
<a href="#l24.79"></a><span id="l24.79" class="difflineplus">+  nsMsgSearchDBView *m_view;</span>
<a href="#l24.80"></a><span id="l24.80" class="difflineplus">+  PRUint32        m_numUnreadChildren;	</span>
<a href="#l24.81"></a><span id="l24.81" class="difflineplus">+  PRUint32        m_numChildren;</span>
<a href="#l24.82"></a><span id="l24.82" class="difflineplus">+  PRUint32        m_flags;</span>
<a href="#l24.83"></a><span id="l24.83" class="difflineplus">+  PRUint32        m_newestMsgDate;</span>
<a href="#l24.84"></a><span id="l24.84" class="difflineplus">+  nsTArray&lt;nsMsgKey&gt; m_keys;</span>
<a href="#l24.85"></a><span id="l24.85" class="difflineplus">+  nsCOMArray&lt;nsIMsgFolder&gt; m_folders;</span>
<a href="#l24.86"></a><span id="l24.86" class="difflineplus">+  nsTArray&lt;PRUint8&gt; m_levels;</span>
<a href="#l24.87"></a><span id="l24.87" class="difflineplus">+};</span>
<a href="#l24.88"></a><span id="l24.88" class="difflineplus">+</span>
<a href="#l24.89"></a><span id="l24.89" class="difflineplus">+#endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l25.4"></a><span id="l25.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l25.5"></a><span id="l25.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l25.6"></a><span id="l25.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l25.7"></a><span id="l25.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l25.8"></a><span id="l25.8">  *</span>
<a href="#l25.9"></a><span id="l25.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l25.10"></a><span id="l25.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l25.11"></a><span id="l25.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l25.12"></a><span id="l25.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l25.13"></a><span id="l25.13">  *</span>
<a href="#l25.14"></a><span id="l25.14" class="difflineat">@@ -55,17 +55,21 @@ nsMsgXFVirtualFolderDBView::nsMsgXFVirtu</span>
<a href="#l25.15"></a><span id="l25.15">   mSuppressMsgDisplay = PR_FALSE;</span>
<a href="#l25.16"></a><span id="l25.16">   m_doingSearch = PR_FALSE;</span>
<a href="#l25.17"></a><span id="l25.17"> }</span>
<a href="#l25.18"></a><span id="l25.18"> </span>
<a href="#l25.19"></a><span id="l25.19"> nsMsgXFVirtualFolderDBView::~nsMsgXFVirtualFolderDBView()</span>
<a href="#l25.20"></a><span id="l25.20"> {</span>
<a href="#l25.21"></a><span id="l25.21"> }</span>
<a href="#l25.22"></a><span id="l25.22"> </span>
<a href="#l25.23"></a><span id="l25.23" class="difflineminus">-NS_IMETHODIMP nsMsgXFVirtualFolderDBView::Open(nsIMsgFolder *folder, nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder, nsMsgViewFlagsTypeValue viewFlags, PRInt32 *pCount)</span>
<a href="#l25.24"></a><span id="l25.24" class="difflineplus">+NS_IMETHODIMP nsMsgXFVirtualFolderDBView::Open(nsIMsgFolder *folder, </span>
<a href="#l25.25"></a><span id="l25.25" class="difflineplus">+                                               nsMsgViewSortTypeValue sortType, </span>
<a href="#l25.26"></a><span id="l25.26" class="difflineplus">+                                               nsMsgViewSortOrderValue sortOrder, </span>
<a href="#l25.27"></a><span id="l25.27" class="difflineplus">+                                               nsMsgViewFlagsTypeValue viewFlags, </span>
<a href="#l25.28"></a><span id="l25.28" class="difflineplus">+                                               PRInt32 *pCount)</span>
<a href="#l25.29"></a><span id="l25.29"> {</span>
<a href="#l25.30"></a><span id="l25.30">   m_viewFolder = folder;</span>
<a href="#l25.31"></a><span id="l25.31">   return nsMsgSearchDBView::Open(folder, sortType, sortOrder, viewFlags, pCount);</span>
<a href="#l25.32"></a><span id="l25.32"> }</span>
<a href="#l25.33"></a><span id="l25.33"> </span>
<a href="#l25.34"></a><span id="l25.34"> void nsMsgXFVirtualFolderDBView::RemovePendingDBListeners()</span>
<a href="#l25.35"></a><span id="l25.35"> {</span>
<a href="#l25.36"></a><span id="l25.36">   nsresult rv;</span>
<a href="#l25.37"></a><span id="l25.37" class="difflineat">@@ -107,17 +111,16 @@ nsMsgXFVirtualFolderDBView::CopyDBView(n</span>
<a href="#l25.38"></a><span id="l25.38"> </span>
<a href="#l25.39"></a><span id="l25.39">   nsMsgXFVirtualFolderDBView* newMsgDBView = (nsMsgXFVirtualFolderDBView *) aNewMsgDBView;</span>
<a href="#l25.40"></a><span id="l25.40"> </span>
<a href="#l25.41"></a><span id="l25.41">   newMsgDBView-&gt;m_viewFolder = m_viewFolder;</span>
<a href="#l25.42"></a><span id="l25.42">   newMsgDBView-&gt;m_searchSession = m_searchSession;</span>
<a href="#l25.43"></a><span id="l25.43">   return NS_OK;</span>
<a href="#l25.44"></a><span id="l25.44"> }</span>
<a href="#l25.45"></a><span id="l25.45"> </span>
<a href="#l25.46"></a><span id="l25.46" class="difflineminus">-</span>
<a href="#l25.47"></a><span id="l25.47"> NS_IMETHODIMP nsMsgXFVirtualFolderDBView::GetViewType(nsMsgViewTypeValue *aViewType)</span>
<a href="#l25.48"></a><span id="l25.48"> {</span>
<a href="#l25.49"></a><span id="l25.49">     NS_ENSURE_ARG_POINTER(aViewType);</span>
<a href="#l25.50"></a><span id="l25.50">     *aViewType = nsMsgViewType::eShowVirtualFolderResults;</span>
<a href="#l25.51"></a><span id="l25.51">     return NS_OK;</span>
<a href="#l25.52"></a><span id="l25.52"> }</span>
<a href="#l25.53"></a><span id="l25.53"> </span>
<a href="#l25.54"></a><span id="l25.54"> NS_IMETHODIMP</span>
<a href="#l25.55"></a><span id="l25.55" class="difflineat">@@ -200,20 +203,17 @@ nsresult nsMsgXFVirtualFolderDBView::Ins</span>
<a href="#l25.56"></a><span id="l25.56">   nsMsgViewIndex insertIndex = GetInsertIndex(msgHdr);</span>
<a href="#l25.57"></a><span id="l25.57">   if (insertIndex == nsMsgViewIndex_None)</span>
<a href="#l25.58"></a><span id="l25.58">     return AddHdrFromFolder(msgHdr, folder);</span>
<a href="#l25.59"></a><span id="l25.59"> </span>
<a href="#l25.60"></a><span id="l25.60">   nsMsgKey msgKey;</span>
<a href="#l25.61"></a><span id="l25.61">   PRUint32 msgFlags;</span>
<a href="#l25.62"></a><span id="l25.62">   msgHdr-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l25.63"></a><span id="l25.63">   msgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l25.64"></a><span id="l25.64" class="difflineminus">-  m_keys.InsertElementAt(insertIndex, msgKey);</span>
<a href="#l25.65"></a><span id="l25.65" class="difflineminus">-  m_flags.InsertElementAt(insertIndex, msgFlags);</span>
<a href="#l25.66"></a><span id="l25.66" class="difflineminus">-  m_folders.InsertObjectAt(folder, insertIndex);</span>
<a href="#l25.67"></a><span id="l25.67" class="difflineminus">-  m_levels.InsertElementAt(insertIndex, 0);</span>
<a href="#l25.68"></a><span id="l25.68" class="difflineplus">+  InsertMsgHdrAt(insertIndex, msgHdr, msgKey, msgFlags, 0);</span>
<a href="#l25.69"></a><span id="l25.69"> </span>
<a href="#l25.70"></a><span id="l25.70">   // the call to NoteChange() has to happen after we add the key</span>
<a href="#l25.71"></a><span id="l25.71">   // as NoteChange() will call RowCountChanged() which will call our GetRowCount()</span>
<a href="#l25.72"></a><span id="l25.72">   NoteChange(insertIndex, 1, nsMsgViewNotificationCode::insertOrDelete);</span>
<a href="#l25.73"></a><span id="l25.73">   return NS_OK;</span>
<a href="#l25.74"></a><span id="l25.74"> }</span>
<a href="#l25.75"></a><span id="l25.75"> </span>
<a href="#l25.76"></a><span id="l25.76"> void nsMsgXFVirtualFolderDBView::UpdateCacheAndViewForFolder(nsIMsgFolder *folder, nsMsgKey *newHits, PRUint32 numNewHits)</span>
<a href="#l25.77"></a><span id="l25.77" class="difflineat">@@ -225,22 +225,26 @@ void nsMsgXFVirtualFolderDBView::UpdateC</span>
<a href="#l25.78"></a><span id="l25.78">     nsCString searchUri;</span>
<a href="#l25.79"></a><span id="l25.79">     m_viewFolder-&gt;GetURI(searchUri);</span>
<a href="#l25.80"></a><span id="l25.80">     PRUint32 numBadHits;</span>
<a href="#l25.81"></a><span id="l25.81">     nsMsgKey *badHits;</span>
<a href="#l25.82"></a><span id="l25.82">     rv = db-&gt;RefreshCache(searchUri.get(), numNewHits, newHits,</span>
<a href="#l25.83"></a><span id="l25.83">                      &amp;numBadHits, &amp;badHits);</span>
<a href="#l25.84"></a><span id="l25.84">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.85"></a><span id="l25.85">     {</span>
<a href="#l25.86"></a><span id="l25.86" class="difflineplus">+      nsCOMPtr&lt;nsIMsgDBHdr&gt; badHdr;</span>
<a href="#l25.87"></a><span id="l25.87">       for (PRUint32 badHitIndex = 0; badHitIndex &lt; numBadHits; badHitIndex++)</span>
<a href="#l25.88"></a><span id="l25.88">       {</span>
<a href="#l25.89"></a><span id="l25.89" class="difflineminus">-        // of course, this isn't quite right</span>
<a href="#l25.90"></a><span id="l25.90" class="difflineminus">-        nsMsgViewIndex staleHitIndex = FindKey(badHits[badHitIndex], PR_TRUE);</span>
<a href="#l25.91"></a><span id="l25.91" class="difflineminus">-        if (staleHitIndex != nsMsgViewIndex_None)</span>
<a href="#l25.92"></a><span id="l25.92" class="difflineminus">-          RemoveByIndex(staleHitIndex);</span>
<a href="#l25.93"></a><span id="l25.93" class="difflineplus">+        // ### of course, this isn't quite right, since we should be </span>
<a href="#l25.94"></a><span id="l25.94" class="difflineplus">+        // using FindHdr, and we shouldn't be expanding the threads.</span>
<a href="#l25.95"></a><span id="l25.95" class="difflineplus">+        db-&gt;GetMsgHdrForKey(badHits[badHitIndex], getter_AddRefs(badHdr));</span>
<a href="#l25.96"></a><span id="l25.96" class="difflineplus">+        // let nsMsgSearchDBView decide what to do about this header</span>
<a href="#l25.97"></a><span id="l25.97" class="difflineplus">+        // getting removed.</span>
<a href="#l25.98"></a><span id="l25.98" class="difflineplus">+        if (badHdr)</span>
<a href="#l25.99"></a><span id="l25.99" class="difflineplus">+          OnHdrDeleted(badHdr, nsMsgKey_None, 0, this);</span>
<a href="#l25.100"></a><span id="l25.100">       }</span>
<a href="#l25.101"></a><span id="l25.101">       delete [] badHits;</span>
<a href="#l25.102"></a><span id="l25.102">     }</span>
<a href="#l25.103"></a><span id="l25.103">   }</span>
<a href="#l25.104"></a><span id="l25.104"> }</span>
<a href="#l25.105"></a><span id="l25.105"> </span>
<a href="#l25.106"></a><span id="l25.106"> void nsMsgXFVirtualFolderDBView::UpdateCacheAndViewForPrevSearchedFolders(nsIMsgFolder *curSearchFolder)</span>
<a href="#l25.107"></a><span id="l25.107"> {</span>
<a href="#l25.108"></a><span id="l25.108" class="difflineat">@@ -298,17 +302,19 @@ nsMsgXFVirtualFolderDBView::OnSearchHit(</span>
<a href="#l25.109"></a><span id="l25.109">     m_curFolderStartKeyIndex = m_keys.Length();</span>
<a href="#l25.110"></a><span id="l25.110">   }</span>
<a href="#l25.111"></a><span id="l25.111">   PRBool hdrInCache = PR_FALSE;</span>
<a href="#l25.112"></a><span id="l25.112">   nsCString searchUri;</span>
<a href="#l25.113"></a><span id="l25.113">   m_viewFolder-&gt;GetURI(searchUri);</span>
<a href="#l25.114"></a><span id="l25.114">   dbToUse-&gt;HdrIsInCache(searchUri.get(), aMsgHdr, &amp;hdrInCache);</span>
<a href="#l25.115"></a><span id="l25.115">   if (!m_doingSearch || !m_curFolderHasCachedHits || !hdrInCache)</span>
<a href="#l25.116"></a><span id="l25.116">   {</span>
<a href="#l25.117"></a><span id="l25.117" class="difflineminus">-    if (m_sortValid)</span>
<a href="#l25.118"></a><span id="l25.118" class="difflineplus">+    if (m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l25.119"></a><span id="l25.119" class="difflineplus">+      nsMsgGroupView::OnNewHeader(aMsgHdr, nsMsgKey_None, PR_TRUE);</span>
<a href="#l25.120"></a><span id="l25.120" class="difflineplus">+    else if (m_sortValid)</span>
<a href="#l25.121"></a><span id="l25.121">       InsertHdrFromFolder(aMsgHdr, aFolder);</span>
<a href="#l25.122"></a><span id="l25.122">     else</span>
<a href="#l25.123"></a><span id="l25.123">       AddHdrFromFolder(aMsgHdr, aFolder);</span>
<a href="#l25.124"></a><span id="l25.124">   }</span>
<a href="#l25.125"></a><span id="l25.125">   m_hdrHits.AppendObject(aMsgHdr);</span>
<a href="#l25.126"></a><span id="l25.126"> </span>
<a href="#l25.127"></a><span id="l25.127">   return NS_OK;</span>
<a href="#l25.128"></a><span id="l25.128"> }</span>
<a href="#l25.129"></a><span id="l25.129" class="difflineat">@@ -319,36 +325,55 @@ nsMsgXFVirtualFolderDBView::OnSearchDone</span>
<a href="#l25.130"></a><span id="l25.130">   // handle any non verified hits we haven't handled yet.</span>
<a href="#l25.131"></a><span id="l25.131">   UpdateCacheAndViewForPrevSearchedFolders(nsnull);</span>
<a href="#l25.132"></a><span id="l25.132"> </span>
<a href="#l25.133"></a><span id="l25.133">   m_doingSearch = PR_FALSE;</span>
<a href="#l25.134"></a><span id="l25.134">   //we want to set imap delete model once the search is over because setting next</span>
<a href="#l25.135"></a><span id="l25.135">   //message after deletion will happen before deleting the message and search scope</span>
<a href="#l25.136"></a><span id="l25.136">   //can change with every search.</span>
<a href="#l25.137"></a><span id="l25.137">   mDeleteModel = nsMsgImapDeleteModels::MoveToTrash;  //set to default in case it is non-imap folder</span>
<a href="#l25.138"></a><span id="l25.138" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; curFolder = m_folders.SafeObjectAt(0);</span>
<a href="#l25.139"></a><span id="l25.139" class="difflineplus">+  nsIMsgFolder *curFolder = m_folders.SafeObjectAt(0);</span>
<a href="#l25.140"></a><span id="l25.140">   if (curFolder)</span>
<a href="#l25.141"></a><span id="l25.141">     GetImapDeleteModel(curFolder);</span>
<a href="#l25.142"></a><span id="l25.142"> </span>
<a href="#l25.143"></a><span id="l25.143">   nsCOMPtr &lt;nsIMsgDatabase&gt; virtDatabase;</span>
<a href="#l25.144"></a><span id="l25.144">   nsCOMPtr &lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l25.145"></a><span id="l25.145">   nsresult rv = m_viewFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(dbFolderInfo), getter_AddRefs(virtDatabase));</span>
<a href="#l25.146"></a><span id="l25.146">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.147"></a><span id="l25.147">   // count up the number of unread and total messages from the view, and set those in the</span>
<a href="#l25.148"></a><span id="l25.148">   // folder - easier than trying to keep the count up to date in the face of</span>
<a href="#l25.149"></a><span id="l25.149">   // search hits coming in while the user is reading/deleting messages.</span>
<a href="#l25.150"></a><span id="l25.150" class="difflineminus">-  PRInt32 numUnread = 0;</span>
<a href="#l25.151"></a><span id="l25.151" class="difflineplus">+  PRUint32 numUnread = 0;</span>
<a href="#l25.152"></a><span id="l25.152" class="difflineplus">+  PRUint32 numTotal = 0;</span>
<a href="#l25.153"></a><span id="l25.153">   for (PRUint32 i = 0; i &lt; m_flags.Length(); i++)</span>
<a href="#l25.154"></a><span id="l25.154" class="difflineplus">+    if (m_flags[i] &amp; MSG_FLAG_ELIDED)</span>
<a href="#l25.155"></a><span id="l25.155" class="difflineplus">+    {</span>
<a href="#l25.156"></a><span id="l25.156" class="difflineplus">+      nsCOMPtr&lt;nsIMsgThread&gt; thread;</span>
<a href="#l25.157"></a><span id="l25.157" class="difflineplus">+      GetThreadContainingIndex(i, getter_AddRefs(thread));</span>
<a href="#l25.158"></a><span id="l25.158" class="difflineplus">+      if (thread)</span>
<a href="#l25.159"></a><span id="l25.159" class="difflineplus">+      {</span>
<a href="#l25.160"></a><span id="l25.160" class="difflineplus">+        PRUint32 totalInThread, unreadInThread;</span>
<a href="#l25.161"></a><span id="l25.161" class="difflineplus">+        thread-&gt;GetNumUnreadChildren(&amp;unreadInThread);</span>
<a href="#l25.162"></a><span id="l25.162" class="difflineplus">+        thread-&gt;GetNumChildren(&amp;totalInThread);</span>
<a href="#l25.163"></a><span id="l25.163" class="difflineplus">+        numTotal += totalInThread;</span>
<a href="#l25.164"></a><span id="l25.164" class="difflineplus">+        numUnread += unreadInThread;</span>
<a href="#l25.165"></a><span id="l25.165" class="difflineplus">+      }</span>
<a href="#l25.166"></a><span id="l25.166" class="difflineplus">+    }</span>
<a href="#l25.167"></a><span id="l25.167" class="difflineplus">+    else</span>
<a href="#l25.168"></a><span id="l25.168" class="difflineplus">+    {</span>
<a href="#l25.169"></a><span id="l25.169" class="difflineplus">+      numTotal++;</span>
<a href="#l25.170"></a><span id="l25.170">     if (!(m_flags[i] &amp; MSG_FLAG_READ))</span>
<a href="#l25.171"></a><span id="l25.171">       numUnread++;</span>
<a href="#l25.172"></a><span id="l25.172" class="difflineplus">+    }</span>
<a href="#l25.173"></a><span id="l25.173">   dbFolderInfo-&gt;SetNumUnreadMessages(numUnread);</span>
<a href="#l25.174"></a><span id="l25.174" class="difflineminus">-  dbFolderInfo-&gt;SetNumMessages(GetSize());</span>
<a href="#l25.175"></a><span id="l25.175" class="difflineplus">+  dbFolderInfo-&gt;SetNumMessages(numTotal);</span>
<a href="#l25.176"></a><span id="l25.176">   m_viewFolder-&gt;UpdateSummaryTotals(true); // force update from db.</span>
<a href="#l25.177"></a><span id="l25.177">   virtDatabase-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l25.178"></a><span id="l25.178" class="difflineminus">-  if (!m_sortValid &amp;&amp; m_sortType != nsMsgViewSortType::byThread)</span>
<a href="#l25.179"></a><span id="l25.179" class="difflineplus">+  if (!m_sortValid &amp;&amp; m_sortType != nsMsgViewSortType::byThread &amp;&amp; </span>
<a href="#l25.180"></a><span id="l25.180" class="difflineplus">+      !(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l25.181"></a><span id="l25.181">   {</span>
<a href="#l25.182"></a><span id="l25.182">     m_sortValid = PR_FALSE;       //sort the results</span>
<a href="#l25.183"></a><span id="l25.183">     Sort(m_sortType, m_sortOrder);</span>
<a href="#l25.184"></a><span id="l25.184">   }</span>
<a href="#l25.185"></a><span id="l25.185">   m_foldersSearchingOver.Clear();</span>
<a href="#l25.186"></a><span id="l25.186">   m_curFolderGettingHits = nsnull;</span>
<a href="#l25.187"></a><span id="l25.187">   return rv;</span>
<a href="#l25.188"></a><span id="l25.188"> }</span>
<a href="#l25.189"></a><span id="l25.189" class="difflineat">@@ -436,23 +461,24 @@ nsMsgXFVirtualFolderDBView::OnNewSearch(</span>
<a href="#l25.190"></a><span id="l25.190"> </span>
<a href="#l25.191"></a><span id="l25.191">   m_curFolderStartKeyIndex = 0;</span>
<a href="#l25.192"></a><span id="l25.192">   m_curFolderGettingHits = nsnull;</span>
<a href="#l25.193"></a><span id="l25.193">   m_curFolderHasCachedHits = PR_FALSE;</span>
<a href="#l25.194"></a><span id="l25.194"> </span>
<a href="#l25.195"></a><span id="l25.195">   // if we have cached hits, sort them.</span>
<a href="#l25.196"></a><span id="l25.196">   if (GetSize() &gt; 0)</span>
<a href="#l25.197"></a><span id="l25.197">   {</span>
<a href="#l25.198"></a><span id="l25.198" class="difflineminus">-    if (m_sortType != nsMsgViewSortType::byThread)</span>
<a href="#l25.199"></a><span id="l25.199" class="difflineplus">+    // currently, we keep threaded views sorted while we build them.</span>
<a href="#l25.200"></a><span id="l25.200" class="difflineplus">+    if (m_sortType != nsMsgViewSortType::byThread &amp;&amp;</span>
<a href="#l25.201"></a><span id="l25.201" class="difflineplus">+      !(m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay))</span>
<a href="#l25.202"></a><span id="l25.202">     {</span>
<a href="#l25.203"></a><span id="l25.203">       m_sortValid = PR_FALSE;       //sort the results</span>
<a href="#l25.204"></a><span id="l25.204">       Sort(m_sortType, m_sortOrder);</span>
<a href="#l25.205"></a><span id="l25.205">     }</span>
<a href="#l25.206"></a><span id="l25.206">   }</span>
<a href="#l25.207"></a><span id="l25.207" class="difflineminus">-//    mSearchResults-&gt;Clear();</span>
<a href="#l25.208"></a><span id="l25.208">     return NS_OK;</span>
<a href="#l25.209"></a><span id="l25.209"> }</span>
<a href="#l25.210"></a><span id="l25.210"> </span>
<a href="#l25.211"></a><span id="l25.211"> </span>
<a href="#l25.212"></a><span id="l25.212"> NS_IMETHODIMP nsMsgXFVirtualFolderDBView::DoCommand(nsMsgViewCommandTypeValue command)</span>
<a href="#l25.213"></a><span id="l25.213"> {</span>
<a href="#l25.214"></a><span id="l25.214">     return nsMsgSearchDBView::DoCommand(command);</span>
<a href="#l25.215"></a><span id="l25.215"> }</span>
<a href="#l25.216"></a><span id="l25.216" class="difflineat">@@ -460,8 +486,60 @@ NS_IMETHODIMP nsMsgXFVirtualFolderDBView</span>
<a href="#l25.217"></a><span id="l25.217"> </span>
<a href="#l25.218"></a><span id="l25.218"> </span>
<a href="#l25.219"></a><span id="l25.219"> NS_IMETHODIMP nsMsgXFVirtualFolderDBView::GetMsgFolder(nsIMsgFolder **aMsgFolder)</span>
<a href="#l25.220"></a><span id="l25.220"> {</span>
<a href="#l25.221"></a><span id="l25.221">   NS_ENSURE_ARG_POINTER(aMsgFolder);</span>
<a href="#l25.222"></a><span id="l25.222">   NS_IF_ADDREF(*aMsgFolder = m_viewFolder);</span>
<a href="#l25.223"></a><span id="l25.223">   return NS_OK;</span>
<a href="#l25.224"></a><span id="l25.224"> }</span>
<a href="#l25.225"></a><span id="l25.225" class="difflineplus">+</span>
<a href="#l25.226"></a><span id="l25.226" class="difflineplus">+NS_IMETHODIMP nsMsgXFVirtualFolderDBView::SetViewFlags(nsMsgViewFlagsTypeValue aViewFlags)</span>
<a href="#l25.227"></a><span id="l25.227" class="difflineplus">+{</span>
<a href="#l25.228"></a><span id="l25.228" class="difflineplus">+  nsMsgViewFlagsTypeValue saveViewFlags = m_viewFlags;</span>
<a href="#l25.229"></a><span id="l25.229" class="difflineplus">+  nsresult rv =  nsMsgDBView::SetViewFlags(aViewFlags);</span>
<a href="#l25.230"></a><span id="l25.230" class="difflineplus">+  // if the grouping/threading has changed, rebuild the view</span>
<a href="#l25.231"></a><span id="l25.231" class="difflineplus">+  if ((saveViewFlags &amp; (nsMsgViewFlagsType::kGroupBySort |</span>
<a href="#l25.232"></a><span id="l25.232" class="difflineplus">+                      nsMsgViewFlagsType::kThreadedDisplay)) !=</span>
<a href="#l25.233"></a><span id="l25.233" class="difflineplus">+      (aViewFlags &amp; (nsMsgViewFlagsType::kGroupBySort |</span>
<a href="#l25.234"></a><span id="l25.234" class="difflineplus">+                     nsMsgViewFlagsType::kThreadedDisplay)))</span>
<a href="#l25.235"></a><span id="l25.235" class="difflineplus">+    RebuildView();</span>
<a href="#l25.236"></a><span id="l25.236" class="difflineplus">+</span>
<a href="#l25.237"></a><span id="l25.237" class="difflineplus">+  return rv;</span>
<a href="#l25.238"></a><span id="l25.238" class="difflineplus">+}</span>
<a href="#l25.239"></a><span id="l25.239" class="difflineplus">+</span>
<a href="#l25.240"></a><span id="l25.240" class="difflineplus">+NS_IMETHODIMP nsMsgXFVirtualFolderDBView::OpenWithHdrs(nsISimpleEnumerator *aHeaders, nsMsgViewSortTypeValue aSortType,</span>
<a href="#l25.241"></a><span id="l25.241" class="difflineplus">+                                        nsMsgViewSortOrderValue aSortOrder, nsMsgViewFlagsTypeValue aViewFlags,</span>
<a href="#l25.242"></a><span id="l25.242" class="difflineplus">+                                        PRInt32 *aCount)</span>
<a href="#l25.243"></a><span id="l25.243" class="difflineplus">+{</span>
<a href="#l25.244"></a><span id="l25.244" class="difflineplus">+  if (aViewFlags &amp; nsMsgViewFlagsType::kGroupBySort)</span>
<a href="#l25.245"></a><span id="l25.245" class="difflineplus">+    return nsMsgGroupView::OpenWithHdrs(aHeaders, aSortType, aSortOrder, </span>
<a href="#l25.246"></a><span id="l25.246" class="difflineplus">+                                        aViewFlags, aCount);</span>
<a href="#l25.247"></a><span id="l25.247" class="difflineplus">+</span>
<a href="#l25.248"></a><span id="l25.248" class="difflineplus">+  m_sortType = aSortType;</span>
<a href="#l25.249"></a><span id="l25.249" class="difflineplus">+  m_sortOrder = aSortOrder;</span>
<a href="#l25.250"></a><span id="l25.250" class="difflineplus">+  m_viewFlags = aViewFlags;</span>
<a href="#l25.251"></a><span id="l25.251" class="difflineplus">+</span>
<a href="#l25.252"></a><span id="l25.252" class="difflineplus">+  PRBool hasMore;</span>
<a href="#l25.253"></a><span id="l25.253" class="difflineplus">+  nsCOMPtr&lt;nsISupports&gt; supports;</span>
<a href="#l25.254"></a><span id="l25.254" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l25.255"></a><span id="l25.255" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l25.256"></a><span id="l25.256" class="difflineplus">+  nsresult rv = NS_OK;</span>
<a href="#l25.257"></a><span id="l25.257" class="difflineplus">+  while (NS_SUCCEEDED(rv) &amp;&amp; NS_SUCCEEDED(rv = aHeaders-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l25.258"></a><span id="l25.258" class="difflineplus">+  {</span>
<a href="#l25.259"></a><span id="l25.259" class="difflineplus">+    rv = aHeaders-&gt;GetNext(getter_AddRefs(supports));</span>
<a href="#l25.260"></a><span id="l25.260" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; supports)</span>
<a href="#l25.261"></a><span id="l25.261" class="difflineplus">+    {</span>
<a href="#l25.262"></a><span id="l25.262" class="difflineplus">+      msgHdr = do_QueryInterface(supports);</span>
<a href="#l25.263"></a><span id="l25.263" class="difflineplus">+      msgHdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l25.264"></a><span id="l25.264" class="difflineplus">+      AddHdrFromFolder(msgHdr, folder); </span>
<a href="#l25.265"></a><span id="l25.265" class="difflineplus">+    }</span>
<a href="#l25.266"></a><span id="l25.266" class="difflineplus">+  }</span>
<a href="#l25.267"></a><span id="l25.267" class="difflineplus">+  *aCount = m_keys.Length();</span>
<a href="#l25.268"></a><span id="l25.268" class="difflineplus">+  return rv;</span>
<a href="#l25.269"></a><span id="l25.269" class="difflineplus">+}</span>
<a href="#l25.270"></a><span id="l25.270" class="difflineplus">+</span>
<a href="#l25.271"></a><span id="l25.271" class="difflineplus">+</span>
<a href="#l25.272"></a><span id="l25.272" class="difflineplus">+nsresult </span>
<a href="#l25.273"></a><span id="l25.273" class="difflineplus">+nsMsgXFVirtualFolderDBView::GetMessageEnumerator(nsISimpleEnumerator **enumerator)</span>
<a href="#l25.274"></a><span id="l25.274" class="difflineplus">+{</span>
<a href="#l25.275"></a><span id="l25.275" class="difflineplus">+  return GetViewEnumerator(enumerator);</span>
<a href="#l25.276"></a><span id="l25.276" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/base/src/nsMsgXFVirtualFolderDBView.h</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgXFVirtualFolderDBView.h</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -1,9 +1,9 @@</span>
<a href="#l26.4"></a><span id="l26.4" class="difflineminus">-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l26.5"></a><span id="l26.5" class="difflineplus">+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l26.6"></a><span id="l26.6"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l26.7"></a><span id="l26.7">  * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l26.8"></a><span id="l26.8">  *</span>
<a href="#l26.9"></a><span id="l26.9">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l26.10"></a><span id="l26.10">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l26.11"></a><span id="l26.11">  * the License. You may obtain a copy of the License at</span>
<a href="#l26.12"></a><span id="l26.12">  * http://www.mozilla.org/MPL/</span>
<a href="#l26.13"></a><span id="l26.13">  *</span>
<a href="#l26.14"></a><span id="l26.14" class="difflineat">@@ -39,47 +39,58 @@</span>
<a href="#l26.15"></a><span id="l26.15"> #ifndef _nsMsgXFVirtualFolderDBView_H_</span>
<a href="#l26.16"></a><span id="l26.16"> #define _nsMsgXFVirtualFolderDBView_H_</span>
<a href="#l26.17"></a><span id="l26.17"> </span>
<a href="#l26.18"></a><span id="l26.18"> #include &quot;nsMsgSearchDBView.h&quot;</span>
<a href="#l26.19"></a><span id="l26.19"> #include &quot;nsIMsgCopyServiceListener.h&quot;</span>
<a href="#l26.20"></a><span id="l26.20"> #include &quot;nsIMsgSearchNotify.h&quot;</span>
<a href="#l26.21"></a><span id="l26.21"> #include &quot;nsCOMArray.h&quot;</span>
<a href="#l26.22"></a><span id="l26.22"> </span>
<a href="#l26.23"></a><span id="l26.23" class="difflineplus">+class nsMsgGroupThread;</span>
<a href="#l26.24"></a><span id="l26.24" class="difflineplus">+</span>
<a href="#l26.25"></a><span id="l26.25"> class nsMsgXFVirtualFolderDBView : public nsMsgSearchDBView</span>
<a href="#l26.26"></a><span id="l26.26"> {</span>
<a href="#l26.27"></a><span id="l26.27"> public:</span>
<a href="#l26.28"></a><span id="l26.28">   nsMsgXFVirtualFolderDBView();</span>
<a href="#l26.29"></a><span id="l26.29">   virtual ~nsMsgXFVirtualFolderDBView();</span>
<a href="#l26.30"></a><span id="l26.30"> </span>
<a href="#l26.31"></a><span id="l26.31">   NS_IMETHOD SetSearchSession(nsIMsgSearchSession *aSearchSession);</span>
<a href="#l26.32"></a><span id="l26.32">   // we override all the methods, currently. Might change...</span>
<a href="#l26.33"></a><span id="l26.33">   NS_DECL_NSIMSGSEARCHNOTIFY</span>
<a href="#l26.34"></a><span id="l26.34"> </span>
<a href="#l26.35"></a><span id="l26.35">   virtual const char * GetViewName(void) {return &quot;XFVirtualFolderView&quot;; }</span>
<a href="#l26.36"></a><span id="l26.36">   NS_IMETHOD Open(nsIMsgFolder *folder, nsMsgViewSortTypeValue sortType, nsMsgViewSortOrderValue sortOrder, </span>
<a href="#l26.37"></a><span id="l26.37">         nsMsgViewFlagsTypeValue viewFlags, PRInt32 *pCount);</span>
<a href="#l26.38"></a><span id="l26.38" class="difflineplus">+  NS_IMETHOD OpenWithHdrs(nsISimpleEnumerator *aHeaders, </span>
<a href="#l26.39"></a><span id="l26.39" class="difflineplus">+                          nsMsgViewSortTypeValue aSortType,</span>
<a href="#l26.40"></a><span id="l26.40" class="difflineplus">+                          nsMsgViewSortOrderValue aSortOrder, </span>
<a href="#l26.41"></a><span id="l26.41" class="difflineplus">+                          nsMsgViewFlagsTypeValue aViewFlags,</span>
<a href="#l26.42"></a><span id="l26.42" class="difflineplus">+                          PRInt32 *aCount);</span>
<a href="#l26.43"></a><span id="l26.43">   NS_IMETHOD CloneDBView(nsIMessenger *aMessengerInstance, nsIMsgWindow *aMsgWindow, </span>
<a href="#l26.44"></a><span id="l26.44">                          nsIMsgDBViewCommandUpdater *aCmdUpdater, nsIMsgDBView **_retval);</span>
<a href="#l26.45"></a><span id="l26.45">   NS_IMETHOD CopyDBView(nsMsgDBView *aNewMsgDBView, nsIMessenger *aMessengerInstance, </span>
<a href="#l26.46"></a><span id="l26.46">                         nsIMsgWindow *aMsgWindow, nsIMsgDBViewCommandUpdater *aCmdUpdater);</span>
<a href="#l26.47"></a><span id="l26.47">   NS_IMETHOD Close();</span>
<a href="#l26.48"></a><span id="l26.48">   NS_IMETHOD GetViewType(nsMsgViewTypeValue *aViewType);</span>
<a href="#l26.49"></a><span id="l26.49">   NS_IMETHOD DoCommand(nsMsgViewCommandTypeValue command);</span>
<a href="#l26.50"></a><span id="l26.50" class="difflineminus">-  virtual nsresult OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey parentKey, PRBool ensureListed);</span>
<a href="#l26.51"></a><span id="l26.51" class="difflineplus">+  NS_IMETHOD SetViewFlags(nsMsgViewFlagsTypeValue aViewFlags);</span>
<a href="#l26.52"></a><span id="l26.52">   NS_IMETHOD OnHdrPropertyChanged(nsIMsgDBHdr *aHdrToChange, PRBool aPreChange, PRUint32 *aStatus, </span>
<a href="#l26.53"></a><span id="l26.53">                                  nsIDBChangeListener * aInstigator);</span>
<a href="#l26.54"></a><span id="l26.54" class="difflineplus">+  NS_IMETHOD GetMsgFolder(nsIMsgFolder **aMsgFolder);</span>
<a href="#l26.55"></a><span id="l26.55" class="difflineplus">+</span>
<a href="#l26.56"></a><span id="l26.56" class="difflineplus">+  virtual nsresult OnNewHeader(nsIMsgDBHdr *newHdr, nsMsgKey parentKey, PRBool ensureListed);</span>
<a href="#l26.57"></a><span id="l26.57">   virtual nsresult InsertHdrFromFolder(nsIMsgDBHdr *msgHdr, nsIMsgFolder *folder);</span>
<a href="#l26.58"></a><span id="l26.58" class="difflineminus">-  NS_IMETHOD GetMsgFolder(nsIMsgFolder **aMsgFolder);</span>
<a href="#l26.59"></a><span id="l26.59">   void UpdateCacheAndViewForPrevSearchedFolders(nsIMsgFolder *curSearchFolder);</span>
<a href="#l26.60"></a><span id="l26.60">   void UpdateCacheAndViewForFolder(nsIMsgFolder *folder, nsMsgKey *newHits, PRUint32 numNewHits);</span>
<a href="#l26.61"></a><span id="l26.61">   void RemovePendingDBListeners();</span>
<a href="#l26.62"></a><span id="l26.62"> </span>
<a href="#l26.63"></a><span id="l26.63"> protected:</span>
<a href="#l26.64"></a><span id="l26.64"> </span>
<a href="#l26.65"></a><span id="l26.65" class="difflineplus">+  virtual nsresult GetMessageEnumerator(nsISimpleEnumerator **enumerator);</span>
<a href="#l26.66"></a><span id="l26.66" class="difflineplus">+</span>
<a href="#l26.67"></a><span id="l26.67">   PRUint32 m_cachedFolderArrayIndex; // array index of next folder with cached hits to deal with.</span>
<a href="#l26.68"></a><span id="l26.68">   nsCOMArray&lt;nsIMsgFolder&gt; m_foldersSearchingOver;</span>
<a href="#l26.69"></a><span id="l26.69">   nsCOMArray&lt;nsIMsgDBHdr&gt; m_hdrHits;</span>
<a href="#l26.70"></a><span id="l26.70">   nsCOMPtr &lt;nsIMsgFolder&gt; m_curFolderGettingHits;</span>
<a href="#l26.71"></a><span id="l26.71">   PRUint32 m_curFolderStartKeyIndex; // keeps track of the index of the first hit from the cur folder</span>
<a href="#l26.72"></a><span id="l26.72">   PRBool m_curFolderHasCachedHits;</span>
<a href="#l26.73"></a><span id="l26.73">   PRBool m_doingSearch;</span>
<a href="#l26.74"></a><span id="l26.74">   nsWeakPtr m_searchSession;</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

