<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 928:74b3e2a7887f956c3d6c6b16e894f12d28cd16a5</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 74b3e2a7887f956c3d6c6b16e894f12d28cd16a5" />
<meta property="og:url" content="/comm-central/rev/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5" />
<meta property="og:description" content="indexing changes status commit; not working! (I'm not going to push until the" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 74b3e2a7887f956c3d6c6b16e894f12d28cd16a5 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5">shortlog</a> |
<a href="/comm-central/log/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5">files</a> |
changeset |
<a href="/comm-central/raw-rev/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5">raw</a>  | <a href="/comm-central/archive/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
indexing changes status commit; not working! (I'm not going to push until the
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 19 Sep 2008 04:03:41 -0700</td></tr>

<tr>
 <td>changeset 928</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5">74b3e2a7887f956c3d6c6b16e894f12d28cd16a5</a></td>
</tr>



<tr>
<td>parent 927</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/55a9fce200d63c33e59d3becc1292d7649b6590a">55a9fce200d63c33e59d3becc1292d7649b6590a</a>
</td>
</tr>

<tr>
<td>child 929</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/63628cda0155ba3ab503a8658f8e280d3ab84db1">63628cda0155ba3ab503a8658f8e280d3ab84db1</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=74b3e2a7887f956c3d6c6b16e894f12d28cd16a5">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">indexing changes status commit; not working! (I'm not going to push until the
working commit gets in...)</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/74b3e2a7887f956c3d6c6b16e894f12d28cd16a5/modules/indexer.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -190,43 +190,46 @@ GlodaConversation.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">   toString: function gloda_conversation_toString() {</span>
<a href="#l1.5"></a><span id="l1.5">     return this._subject;</span>
<a href="#l1.6"></a><span id="l1.6">   },</span>
<a href="#l1.7"></a><span id="l1.7"> };</span>
<a href="#l1.8"></a><span id="l1.8"> </span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10"> function GlodaMessage(aDatastore, aID, aFolderID, aMessageKey,</span>
<a href="#l1.11"></a><span id="l1.11">                       aConversationID, aConversation, aDate,</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-                      aHeaderMessageID, aBodySnippet) {</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+                      aHeaderMessageID, aDeleted) {</span>
<a href="#l1.14"></a><span id="l1.14">   this._datastore = aDatastore;</span>
<a href="#l1.15"></a><span id="l1.15">   this._id = aID;</span>
<a href="#l1.16"></a><span id="l1.16">   this._folderID = aFolderID;</span>
<a href="#l1.17"></a><span id="l1.17">   this._messageKey = aMessageKey;</span>
<a href="#l1.18"></a><span id="l1.18">   this._conversationID = aConversationID;</span>
<a href="#l1.19"></a><span id="l1.19">   this._conversation = aConversation;</span>
<a href="#l1.20"></a><span id="l1.20">   this.date = aDate;</span>
<a href="#l1.21"></a><span id="l1.21">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineminus">-  this._bodySnippet = aBodySnippet;</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+  // only set _deleted if we're deleted, otherwise the undefined does our</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+  //  speaking for us.</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+  if (aDeleted)</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+    this._deleted = aDeleted;</span>
<a href="#l1.28"></a><span id="l1.28"> </span>
<a href="#l1.29"></a><span id="l1.29">   // for now, let's always cache this; they should really be forgetting about us</span>
<a href="#l1.30"></a><span id="l1.30">   //  if they want to forget about the underlying storage anyways...</span>
<a href="#l1.31"></a><span id="l1.31">   this._folderMessage = undefined;</span>
<a href="#l1.32"></a><span id="l1.32">   // the list of attributes, un-processed</span>
<a href="#l1.33"></a><span id="l1.33">   this._attributes = null;</span>
<a href="#l1.34"></a><span id="l1.34"> }</span>
<a href="#l1.35"></a><span id="l1.35"> </span>
<a href="#l1.36"></a><span id="l1.36"> GlodaMessage.prototype = {</span>
<a href="#l1.37"></a><span id="l1.37">   NOUN_ID: 102,</span>
<a href="#l1.38"></a><span id="l1.38">   get id() { return this._id; },</span>
<a href="#l1.39"></a><span id="l1.39">   get folderID() { return this._folderID; },</span>
<a href="#l1.40"></a><span id="l1.40">   get messageKey() { return this._messageKey; },</span>
<a href="#l1.41"></a><span id="l1.41">   get conversationID() { return this._conversationID; },</span>
<a href="#l1.42"></a><span id="l1.42">   // conversation is special</span>
<a href="#l1.43"></a><span id="l1.43">   get headerMessageID() { return this._headerMessageID; },</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineminus">-  get bodySnippet() { return this._bodySnippet; },</span>
<a href="#l1.45"></a><span id="l1.45"> </span>
<a href="#l1.46"></a><span id="l1.46">   get folderURI() {</span>
<a href="#l1.47"></a><span id="l1.47">     if (this._folderID != null)</span>
<a href="#l1.48"></a><span id="l1.48">       return this._datastore._mapFolderID(this._folderID);</span>
<a href="#l1.49"></a><span id="l1.49">     else</span>
<a href="#l1.50"></a><span id="l1.50">       return null;</span>
<a href="#l1.51"></a><span id="l1.51">   },</span>
<a href="#l1.52"></a><span id="l1.52">   get conversation() {</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineat">@@ -253,18 +256,18 @@ GlodaMessage.prototype = {</span>
<a href="#l1.54"></a><span id="l1.54">   },</span>
<a href="#l1.55"></a><span id="l1.55">   </span>
<a href="#l1.56"></a><span id="l1.56">   _nuke: function gloda_message_nuke() {</span>
<a href="#l1.57"></a><span id="l1.57">     this._id = null;</span>
<a href="#l1.58"></a><span id="l1.58">     this._folderID = null;</span>
<a href="#l1.59"></a><span id="l1.59">     this._messageKey = null;</span>
<a href="#l1.60"></a><span id="l1.60">     this._conversationID = null;</span>
<a href="#l1.61"></a><span id="l1.61">     this._conversation = null;</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+    this.date = null;</span>
<a href="#l1.63"></a><span id="l1.63">     this._headerMessageID = null;</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineminus">-    this._bodySnippet = null;</span>
<a href="#l1.65"></a><span id="l1.65">     </span>
<a href="#l1.66"></a><span id="l1.66">     this._datastore = null;</span>
<a href="#l1.67"></a><span id="l1.67">   },</span>
<a href="#l1.68"></a><span id="l1.68">   </span>
<a href="#l1.69"></a><span id="l1.69">   /**</span>
<a href="#l1.70"></a><span id="l1.70">    * Return the underlying nsIMsgDBHdr from the folder storage for this, or</span>
<a href="#l1.71"></a><span id="l1.71">    *  null if the message does not exist for one reason or another.</span>
<a href="#l1.72"></a><span id="l1.72">    */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -70,16 +70,18 @@ const kSpecialFulltext = 3;</span>
<a href="#l2.4"></a><span id="l2.4"> function MessagesByMessageIdCallback(aStatement, aMsgIDToIndex, aResults,</span>
<a href="#l2.5"></a><span id="l2.5">                                      aCallback, aCallbackThis, aCallbackArgs) {</span>
<a href="#l2.6"></a><span id="l2.6">   this.statement = aStatement;</span>
<a href="#l2.7"></a><span id="l2.7">   this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l2.8"></a><span id="l2.8">   this.results = aResults;</span>
<a href="#l2.9"></a><span id="l2.9">   this.callback = aCallback;</span>
<a href="#l2.10"></a><span id="l2.10">   this.callbackThis = aCallbackThis;</span>
<a href="#l2.11"></a><span id="l2.11">   this.callbackArgs = aCallbackArgs;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+  </span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l2.14"></a><span id="l2.14"> }</span>
<a href="#l2.15"></a><span id="l2.15"> </span>
<a href="#l2.16"></a><span id="l2.16"> MessagesByMessageIdCallback.prototype = {</span>
<a href="#l2.17"></a><span id="l2.17">   handleResult: function gloda_ds_mbmi_handleResult(aResultSet) {</span>
<a href="#l2.18"></a><span id="l2.18">     let row;</span>
<a href="#l2.19"></a><span id="l2.19">     while (row = aResultSet.getNextRow()) {</span>
<a href="#l2.20"></a><span id="l2.20">       let message = GlodaDatastore._messageFromRow(row);</span>
<a href="#l2.21"></a><span id="l2.21">       this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -99,23 +101,27 @@ MessagesByMessageIdCallback.prototype = </span>
<a href="#l2.23"></a><span id="l2.23">     }</span>
<a href="#l2.24"></a><span id="l2.24"> </span>
<a href="#l2.25"></a><span id="l2.25">     let args = [this.results].concat(this.callbackArgs);</span>
<a href="#l2.26"></a><span id="l2.26"> </span>
<a href="#l2.27"></a><span id="l2.27">     this.statement.finalize();</span>
<a href="#l2.28"></a><span id="l2.28">     this.statement = null;</span>
<a href="#l2.29"></a><span id="l2.29"> </span>
<a href="#l2.30"></a><span id="l2.30">     this.callback.apply(this.callbackThis, args);</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+    </span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+    GlodaDatastore._asyncCompleted();</span>
<a href="#l2.33"></a><span id="l2.33">   }</span>
<a href="#l2.34"></a><span id="l2.34"> };</span>
<a href="#l2.35"></a><span id="l2.35"> </span>
<a href="#l2.36"></a><span id="l2.36"> function QueryFromQueryCallback(aStatement, aNounMeta, aCollection) {</span>
<a href="#l2.37"></a><span id="l2.37">   this.statement = aStatement;</span>
<a href="#l2.38"></a><span id="l2.38">   this.nounMeta = aNounMeta;</span>
<a href="#l2.39"></a><span id="l2.39">   this.collection = aCollection;</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+  </span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+  GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l2.42"></a><span id="l2.42"> }</span>
<a href="#l2.43"></a><span id="l2.43"> </span>
<a href="#l2.44"></a><span id="l2.44"> QueryFromQueryCallback.prototype = {</span>
<a href="#l2.45"></a><span id="l2.45">   handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l2.46"></a><span id="l2.46">     let newItems = [];</span>
<a href="#l2.47"></a><span id="l2.47">     let row;</span>
<a href="#l2.48"></a><span id="l2.48">     let nounMeta = this.nounMeta;</span>
<a href="#l2.49"></a><span id="l2.49">     while (row = aResultSet.getNextRow()) {</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineat">@@ -143,16 +149,18 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l2.51"></a><span id="l2.51">   handleError: function gloda_ds_qfq_handleError(aError) {</span>
<a href="#l2.52"></a><span id="l2.52">     GlodaDatastore._log.error(&quot;Async queryFromQuery error: &quot; +</span>
<a href="#l2.53"></a><span id="l2.53">       aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l2.54"></a><span id="l2.54">   },</span>
<a href="#l2.55"></a><span id="l2.55">   </span>
<a href="#l2.56"></a><span id="l2.56">   handleCompletion: function gloda_ds_qfq_handleCompletion(aReason) {</span>
<a href="#l2.57"></a><span id="l2.57">     this.statement.finalize();</span>
<a href="#l2.58"></a><span id="l2.58">     this.statement = null;</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+    </span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+    GlodaDatastore._asyncCompleted();</span>
<a href="#l2.61"></a><span id="l2.61">   }</span>
<a href="#l2.62"></a><span id="l2.62"> };</span>
<a href="#l2.63"></a><span id="l2.63"> </span>
<a href="#l2.64"></a><span id="l2.64"> </span>
<a href="#l2.65"></a><span id="l2.65"> /**</span>
<a href="#l2.66"></a><span id="l2.66">  * Database abstraction layer.  Contains explicit SQL schemas for our</span>
<a href="#l2.67"></a><span id="l2.67">  *  fundamental representations (core 'nouns', if you will) as well as</span>
<a href="#l2.68"></a><span id="l2.68">  *  specialized functions for then dealing with each type of object.  At the</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineat">@@ -300,23 +308,25 @@ let GlodaDatastore = {</span>
<a href="#l2.70"></a><span id="l2.70">           &quot;folderID INTEGER REFERENCES folderLocations(id)&quot;,</span>
<a href="#l2.71"></a><span id="l2.71">           &quot;messageKey INTEGER&quot;,</span>
<a href="#l2.72"></a><span id="l2.72">           &quot;conversationID INTEGER NOT NULL REFERENCES conversations(id)&quot;,</span>
<a href="#l2.73"></a><span id="l2.73">           &quot;date INTEGER&quot;,</span>
<a href="#l2.74"></a><span id="l2.74">           // we used to have the parentID, but because of the very real</span>
<a href="#l2.75"></a><span id="l2.75">           //  possibility of multiple copies of a message with a given</span>
<a href="#l2.76"></a><span id="l2.76">           //  message-id, the parentID concept is unreliable.</span>
<a href="#l2.77"></a><span id="l2.77">           &quot;headerMessageID TEXT&quot;,</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+          &quot;deleted INTEGER NOT NULL default 0&quot;,</span>
<a href="#l2.79"></a><span id="l2.79">         ],</span>
<a href="#l2.80"></a><span id="l2.80">         </span>
<a href="#l2.81"></a><span id="l2.81">         indices: {</span>
<a href="#l2.82"></a><span id="l2.82">           messageLocation: ['folderID', 'messageKey'],</span>
<a href="#l2.83"></a><span id="l2.83">           headerMessageID: ['headerMessageID'],</span>
<a href="#l2.84"></a><span id="l2.84">           conversationID: ['conversationID'],</span>
<a href="#l2.85"></a><span id="l2.85">           date: ['date'],</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+          deleted: ['deleted'],</span>
<a href="#l2.87"></a><span id="l2.87">         },</span>
<a href="#l2.88"></a><span id="l2.88">         </span>
<a href="#l2.89"></a><span id="l2.89">         fulltextColumns: [</span>
<a href="#l2.90"></a><span id="l2.90">           &quot;subject TEXT&quot;,</span>
<a href="#l2.91"></a><span id="l2.91">           &quot;body TEXT&quot;,</span>
<a href="#l2.92"></a><span id="l2.92">           &quot;attachmentNames TEXT&quot;,</span>
<a href="#l2.93"></a><span id="l2.93">         ],</span>
<a href="#l2.94"></a><span id="l2.94">         </span>
<a href="#l2.95"></a><span id="l2.95" class="difflineat">@@ -745,17 +755,17 @@ let GlodaDatastore = {</span>
<a href="#l2.96"></a><span id="l2.96">   /**</span>
<a href="#l2.97"></a><span id="l2.97">    * Begin a potentially nested transaction; only the outermost transaction gets</span>
<a href="#l2.98"></a><span id="l2.98">    *  to be an actual transaction, and the failure of any nested transaction</span>
<a href="#l2.99"></a><span id="l2.99">    *  results in a rollback of the entire outer transaction.  If you really</span>
<a href="#l2.100"></a><span id="l2.100">    *  need an atomic transaction </span>
<a href="#l2.101"></a><span id="l2.101">    */</span>
<a href="#l2.102"></a><span id="l2.102">   _beginTransaction: function gloda_ds_beginTransaction() {</span>
<a href="#l2.103"></a><span id="l2.103">     if (this._transactionDepth == 0) {</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineminus">-      this._beginTransactionStatement.executeAsync();</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineplus">+      this._beginTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l2.106"></a><span id="l2.106">       this._transactionGood = true;</span>
<a href="#l2.107"></a><span id="l2.107">     }</span>
<a href="#l2.108"></a><span id="l2.108">     this._transactionDepth++;</span>
<a href="#l2.109"></a><span id="l2.109">   },</span>
<a href="#l2.110"></a><span id="l2.110">   /**</span>
<a href="#l2.111"></a><span id="l2.111">    * Commit a potentially nested transaction; if we are the outer-most</span>
<a href="#l2.112"></a><span id="l2.112">    *  transaction and no sub-transaction issues a rollback</span>
<a href="#l2.113"></a><span id="l2.113">    *  (via _rollbackTransaction) then we commit, otherwise we rollback.</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineat">@@ -793,24 +803,52 @@ let GlodaDatastore = {</span>
<a href="#l2.115"></a><span id="l2.115">    *  outermost transaction, we set a flag that tells the outermost transaction</span>
<a href="#l2.116"></a><span id="l2.116">    *  that it must roll back.</span>
<a href="#l2.117"></a><span id="l2.117">    */</span>
<a href="#l2.118"></a><span id="l2.118">   _rollbackTransaction: function gloda_ds_rollbackTransaction() {</span>
<a href="#l2.119"></a><span id="l2.119">     this._transactionDepth--;</span>
<a href="#l2.120"></a><span id="l2.120">     this._transactionGood = false;</span>
<a href="#l2.121"></a><span id="l2.121">     if (this._transactionDepth == 0) {</span>
<a href="#l2.122"></a><span id="l2.122">       try {</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineminus">-        this._rollbackTransactionStatement.executeAsync();</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+        this._rollbackTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l2.125"></a><span id="l2.125">       }</span>
<a href="#l2.126"></a><span id="l2.126">       catch (ex) {</span>
<a href="#l2.127"></a><span id="l2.127">         this._log.error(&quot;Rollback problem: &quot; + ex);</span>
<a href="#l2.128"></a><span id="l2.128">       }</span>
<a href="#l2.129"></a><span id="l2.129">     }</span>
<a href="#l2.130"></a><span id="l2.130">   },</span>
<a href="#l2.131"></a><span id="l2.131">   </span>
<a href="#l2.132"></a><span id="l2.132" class="difflineplus">+  _pendingAsyncStatements: 0,</span>
<a href="#l2.133"></a><span id="l2.133" class="difflineplus">+  /**</span>
<a href="#l2.134"></a><span id="l2.134" class="difflineplus">+   * The function to call, if any, when we hit 0 pending async statements.</span>
<a href="#l2.135"></a><span id="l2.135" class="difflineplus">+   */</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineplus">+  _pendingAsyncCompletedListener: null,</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineplus">+  _asyncCompleted: function () {</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineplus">+    if (--this._pendingAsyncStatements == 0) {</span>
<a href="#l2.139"></a><span id="l2.139" class="difflineplus">+      if (this._pendingAsyncCompletedListener !== null) {</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineplus">+        this._pendingAsyncCompletedListener();</span>
<a href="#l2.141"></a><span id="l2.141" class="difflineplus">+        this._pendingAsyncCompletedListener = null;</span>
<a href="#l2.142"></a><span id="l2.142" class="difflineplus">+      }</span>
<a href="#l2.143"></a><span id="l2.143" class="difflineplus">+    }</span>
<a href="#l2.144"></a><span id="l2.144" class="difflineplus">+  },</span>
<a href="#l2.145"></a><span id="l2.145" class="difflineplus">+  _ayncTrackerListener: {</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineplus">+    handleResult: function () {},</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineplus">+    handleError: function() {},</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineplus">+    handleCompletion: function () {</span>
<a href="#l2.149"></a><span id="l2.149" class="difflineplus">+      // the helper method exists because the other classes need to call it too</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineplus">+      GlodaDatastore._asyncCompleted();</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineplus">+    }</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineplus">+  },</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineplus">+  /**</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineplus">+   * Increments _pendingAsyncStatements and returns a listener that will</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineplus">+   *  decrement the value when the statement completes.</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineplus">+   */</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+  trackAsync: function() {</span>
<a href="#l2.158"></a><span id="l2.158" class="difflineplus">+  },</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineplus">+  </span>
<a href="#l2.160"></a><span id="l2.160">   /* ********** Attribute Definitions ********** */</span>
<a href="#l2.161"></a><span id="l2.161">   /** Maps (attribute def) compound names to the GlodaAttributeDef objects. */</span>
<a href="#l2.162"></a><span id="l2.162">   _attributes: {},</span>
<a href="#l2.163"></a><span id="l2.163">   /** Map attribute ID to the definition and parameter value that produce it. */</span>
<a href="#l2.164"></a><span id="l2.164">   _attributeIDToDef: {},</span>
<a href="#l2.165"></a><span id="l2.165">   /**</span>
<a href="#l2.166"></a><span id="l2.166">    * We maintain the attributeDefinitions next id counter mainly because we can.</span>
<a href="#l2.167"></a><span id="l2.167">    *  Since we mediate the access, there's no real risk to doing so, and it</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineat">@@ -851,17 +889,17 @@ let GlodaDatastore = {</span>
<a href="#l2.169"></a><span id="l2.169">                                     </span>
<a href="#l2.170"></a><span id="l2.170">     let iads = this._insertAttributeDefStatement;</span>
<a href="#l2.171"></a><span id="l2.171">     iads.bindInt64Parameter(0, attributeId);</span>
<a href="#l2.172"></a><span id="l2.172">     iads.bindInt64Parameter(1, aAttrType);</span>
<a href="#l2.173"></a><span id="l2.173">     iads.bindStringParameter(2, aExtensionName);</span>
<a href="#l2.174"></a><span id="l2.174">     iads.bindStringParameter(3, aAttrName);</span>
<a href="#l2.175"></a><span id="l2.175">     this._bindVariant(iads, 4, aParameter);</span>
<a href="#l2.176"></a><span id="l2.176">     </span>
<a href="#l2.177"></a><span id="l2.177" class="difflineminus">-    iads.executeAsync();</span>
<a href="#l2.178"></a><span id="l2.178" class="difflineplus">+    iads.executeAsync(this.trackAsync());</span>
<a href="#l2.179"></a><span id="l2.179">     </span>
<a href="#l2.180"></a><span id="l2.180">     return attributeId;</span>
<a href="#l2.181"></a><span id="l2.181">   },</span>
<a href="#l2.182"></a><span id="l2.182">   </span>
<a href="#l2.183"></a><span id="l2.183">   /**</span>
<a href="#l2.184"></a><span id="l2.184">    * Sync-ly look-up all the attribute definitions, populating our authoritative </span>
<a href="#l2.185"></a><span id="l2.185">    *  _attributes and _attributeIDToDef maps.  (In other words, once this method</span>
<a href="#l2.186"></a><span id="l2.186">    *  is called, those maps should always be in sync with the underlying</span>
<a href="#l2.187"></a><span id="l2.187" class="difflineat">@@ -960,29 +998,33 @@ let GlodaDatastore = {</span>
<a href="#l2.188"></a><span id="l2.188">       this._folderIDs[folderID] = folderURI;</span>
<a href="#l2.189"></a><span id="l2.189">       </span>
<a href="#l2.190"></a><span id="l2.190">       if (folderID + 1 &gt; this._nextFolderId)</span>
<a href="#l2.191"></a><span id="l2.191">         this._nextFolderId = folderID + 1;</span>
<a href="#l2.192"></a><span id="l2.192">     }</span>
<a href="#l2.193"></a><span id="l2.193">     stmt.finalize();</span>
<a href="#l2.194"></a><span id="l2.194">   },</span>
<a href="#l2.195"></a><span id="l2.195">   </span>
<a href="#l2.196"></a><span id="l2.196" class="difflineplus">+  _folderURIKnown: function gloda_ds_folderURIKnown(aFolderURI) {</span>
<a href="#l2.197"></a><span id="l2.197" class="difflineplus">+    return aFolderURI in this._folderURIs;</span>
<a href="#l2.198"></a><span id="l2.198" class="difflineplus">+  },</span>
<a href="#l2.199"></a><span id="l2.199" class="difflineplus">+  </span>
<a href="#l2.200"></a><span id="l2.200">   /**</span>
<a href="#l2.201"></a><span id="l2.201">    * Map a folder URI to a folder ID, creating the mapping if it does not yet</span>
<a href="#l2.202"></a><span id="l2.202">    *  exist.</span>
<a href="#l2.203"></a><span id="l2.203">    */</span>
<a href="#l2.204"></a><span id="l2.204">   _mapFolderURI: function gloda_ds_mapFolderURI(aFolderURI) {</span>
<a href="#l2.205"></a><span id="l2.205">     if (aFolderURI in this._folderURIs) {</span>
<a href="#l2.206"></a><span id="l2.206">       return this._folderURIs[aFolderURI];</span>
<a href="#l2.207"></a><span id="l2.207">     }</span>
<a href="#l2.208"></a><span id="l2.208">     </span>
<a href="#l2.209"></a><span id="l2.209">     let folderID = this._nextFolderId++;</span>
<a href="#l2.210"></a><span id="l2.210">     this._insertFolderLocationStatement.bindInt64Parameter(0, folderID)</span>
<a href="#l2.211"></a><span id="l2.211">     this._insertFolderLocationStatement.bindStringParameter(1, aFolderURI);</span>
<a href="#l2.212"></a><span id="l2.212" class="difflineminus">-    this._insertFolderLocationStatement.executeAsync();</span>
<a href="#l2.213"></a><span id="l2.213" class="difflineplus">+    this._insertFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l2.214"></a><span id="l2.214"> </span>
<a href="#l2.215"></a><span id="l2.215">     this._folderURIs[aFolderURI] = folderID;</span>
<a href="#l2.216"></a><span id="l2.216">     this._folderIDs[folderID] = aFolderURI;</span>
<a href="#l2.217"></a><span id="l2.217">     this._log.info(&quot;mapping URI &quot; + aFolderURI + &quot; to &quot; + folderID);</span>
<a href="#l2.218"></a><span id="l2.218">     return folderID;</span>
<a href="#l2.219"></a><span id="l2.219">   },</span>
<a href="#l2.220"></a><span id="l2.220">   </span>
<a href="#l2.221"></a><span id="l2.221">   _mapFolderID: function gloda_ds_mapFolderID(aFolderID) {</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineat">@@ -1010,32 +1052,32 @@ let GlodaDatastore = {</span>
<a href="#l2.223"></a><span id="l2.223">    */</span>
<a href="#l2.224"></a><span id="l2.224">   renameFolder: function gloda_ds_renameFolder(aOldURI, aNewURI) {</span>
<a href="#l2.225"></a><span id="l2.225">     let folderID = this._mapFolderURI(aOldURI); // ensure the URI is mapped...</span>
<a href="#l2.226"></a><span id="l2.226">     this._folderURIs[aNewURI] = folderID;</span>
<a href="#l2.227"></a><span id="l2.227">     this._folderIDs[folderID] = aNewURI;</span>
<a href="#l2.228"></a><span id="l2.228">     this._log.info(&quot;renaming folder URI &quot; + aOldURI + &quot; to &quot; + aNewURI);</span>
<a href="#l2.229"></a><span id="l2.229">     this._updateFolderLocationStatement.bindStringParameter(1, aOldURI);</span>
<a href="#l2.230"></a><span id="l2.230">     this._updateFolderLocationStatement.bindStringParameter(0, aNewURI);</span>
<a href="#l2.231"></a><span id="l2.231" class="difflineminus">-    this._updateFolderLocationStatement.executeAsync();</span>
<a href="#l2.232"></a><span id="l2.232" class="difflineplus">+    this._updateFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l2.233"></a><span id="l2.233">     delete this._folderURIs[aOldURI];</span>
<a href="#l2.234"></a><span id="l2.234">   },</span>
<a href="#l2.235"></a><span id="l2.235">   </span>
<a href="#l2.236"></a><span id="l2.236">   get _deleteFolderByIDStatement() {</span>
<a href="#l2.237"></a><span id="l2.237">     let statement = this._createAsyncStatement(</span>
<a href="#l2.238"></a><span id="l2.238">       &quot;DELETE FROM folderLocations WHERE id = ?1&quot;);</span>
<a href="#l2.239"></a><span id="l2.239">     this.__defineGetter__(&quot;_deleteFolderByIDStatement&quot;,</span>
<a href="#l2.240"></a><span id="l2.240">       function() statement);</span>
<a href="#l2.241"></a><span id="l2.241">     return this._deleteFolderByIDStatement;</span>
<a href="#l2.242"></a><span id="l2.242">   },</span>
<a href="#l2.243"></a><span id="l2.243">   </span>
<a href="#l2.244"></a><span id="l2.244">   deleteFolderByID: function gloda_ds_deleteFolder(aFolderID) {</span>
<a href="#l2.245"></a><span id="l2.245">     let dfbis = this._deleteFolderByIDStatement;</span>
<a href="#l2.246"></a><span id="l2.246">     dfbis.bindInt64Parameter(0, aFolderID);</span>
<a href="#l2.247"></a><span id="l2.247" class="difflineminus">-    dfbis.executeAsync();</span>
<a href="#l2.248"></a><span id="l2.248" class="difflineplus">+    dfbis.executeAsync(this.trackAsync());</span>
<a href="#l2.249"></a><span id="l2.249">   },</span>
<a href="#l2.250"></a><span id="l2.250">   </span>
<a href="#l2.251"></a><span id="l2.251">   /* ********** Conversation ********** */</span>
<a href="#l2.252"></a><span id="l2.252">   /** The next conversation id to allocate.  Initialize at startup. */</span>
<a href="#l2.253"></a><span id="l2.253">   _nextConversationId: 1,</span>
<a href="#l2.254"></a><span id="l2.254">   </span>
<a href="#l2.255"></a><span id="l2.255">   _populateConversationManagedId: function () {</span>
<a href="#l2.256"></a><span id="l2.256">     let stmt = this._createSyncStatement(</span>
<a href="#l2.257"></a><span id="l2.257" class="difflineat">@@ -1078,23 +1120,23 @@ let GlodaDatastore = {</span>
<a href="#l2.258"></a><span id="l2.258">     if (aOldestMessageDate == null)</span>
<a href="#l2.259"></a><span id="l2.259">       ics.bindNullParameter(2);</span>
<a href="#l2.260"></a><span id="l2.260">     else</span>
<a href="#l2.261"></a><span id="l2.261">       ics.bindInt64Parameter(2, aOldestMessageDate);</span>
<a href="#l2.262"></a><span id="l2.262">     if (aNewestMessageDate == null)</span>
<a href="#l2.263"></a><span id="l2.263">       ics.bindNullParameter(3);</span>
<a href="#l2.264"></a><span id="l2.264">     else</span>
<a href="#l2.265"></a><span id="l2.265">       ics.bindInt64Parameter(3, aNewestMessageDate);</span>
<a href="#l2.266"></a><span id="l2.266" class="difflineminus">-    ics.executeAsync();</span>
<a href="#l2.267"></a><span id="l2.267" class="difflineplus">+    ics.executeAsync(this.trackAsync());</span>
<a href="#l2.268"></a><span id="l2.268">     </span>
<a href="#l2.269"></a><span id="l2.269">     // create the fulltext row, using the same rowid/docid</span>
<a href="#l2.270"></a><span id="l2.270">     let icts = this._insertConversationTextStatement;</span>
<a href="#l2.271"></a><span id="l2.271">     icts.bindInt64Parameter(0, conversationID);</span>
<a href="#l2.272"></a><span id="l2.272">     icts.bindStringParameter(1, aSubject);</span>
<a href="#l2.273"></a><span id="l2.273" class="difflineminus">-    icts.executeAsync();</span>
<a href="#l2.274"></a><span id="l2.274" class="difflineplus">+    icts.executeAsync(this.trackAsync());</span>
<a href="#l2.275"></a><span id="l2.275">     </span>
<a href="#l2.276"></a><span id="l2.276">     // create it</span>
<a href="#l2.277"></a><span id="l2.277">     let conversation = new GlodaConversation(this, conversationID,</span>
<a href="#l2.278"></a><span id="l2.278">                                  aSubject, aOldestMessageDate,</span>
<a href="#l2.279"></a><span id="l2.279">                                  aNewestMessageDate);</span>
<a href="#l2.280"></a><span id="l2.280">     // it's new! let the collection manager know about it.</span>
<a href="#l2.281"></a><span id="l2.281">     GlodaCollectionManager.itemsAdded(conversation.NOUN_ID, [conversation]);</span>
<a href="#l2.282"></a><span id="l2.282">     // return it</span>
<a href="#l2.283"></a><span id="l2.283" class="difflineat">@@ -1111,17 +1153,17 @@ let GlodaDatastore = {</span>
<a href="#l2.284"></a><span id="l2.284"> </span>
<a href="#l2.285"></a><span id="l2.285">   /**</span>
<a href="#l2.286"></a><span id="l2.286">    * Asynchronously delete a conversation given its ID.</span>
<a href="#l2.287"></a><span id="l2.287">    */</span>
<a href="#l2.288"></a><span id="l2.288">   deleteConversationByID: function gloda_ds_deleteConversationByID(</span>
<a href="#l2.289"></a><span id="l2.289">                                       aConversationID) {</span>
<a href="#l2.290"></a><span id="l2.290">     let dcbids = this._deleteConversationByIDStatement;</span>
<a href="#l2.291"></a><span id="l2.291">     dcbids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l2.292"></a><span id="l2.292" class="difflineminus">-    dcbids.executeAsync();</span>
<a href="#l2.293"></a><span id="l2.293" class="difflineplus">+    dcbids.executeAsync(this.trackAsync());</span>
<a href="#l2.294"></a><span id="l2.294">     </span>
<a href="#l2.295"></a><span id="l2.295">     // TODO: collection manager implications</span>
<a href="#l2.296"></a><span id="l2.296">     //GlodaCollectionManager.removeByID()</span>
<a href="#l2.297"></a><span id="l2.297">   },</span>
<a href="#l2.298"></a><span id="l2.298"> </span>
<a href="#l2.299"></a><span id="l2.299">   get _selectConversationByIDStatement() {</span>
<a href="#l2.300"></a><span id="l2.300">     let statement = this._createSyncStatement(</span>
<a href="#l2.301"></a><span id="l2.301">       &quot;SELECT id, subject, oldestMessageDate, newestMessageDate \</span>
<a href="#l2.302"></a><span id="l2.302" class="difflineat">@@ -1235,17 +1277,17 @@ let GlodaDatastore = {</span>
<a href="#l2.303"></a><span id="l2.303">     ims.bindInt64Parameter(3, aConversationID);</span>
<a href="#l2.304"></a><span id="l2.304">     if (aDatePRTime === null)</span>
<a href="#l2.305"></a><span id="l2.305">       ims.bindNullParameter(4);</span>
<a href="#l2.306"></a><span id="l2.306">     else</span>
<a href="#l2.307"></a><span id="l2.307">       ims.bindInt64Parameter(4, aDatePRTime);</span>
<a href="#l2.308"></a><span id="l2.308">     ims.bindStringParameter(5, aHeaderMessageID);</span>
<a href="#l2.309"></a><span id="l2.309"> </span>
<a href="#l2.310"></a><span id="l2.310">     try {</span>
<a href="#l2.311"></a><span id="l2.311" class="difflineminus">-       ims.executeAsync();</span>
<a href="#l2.312"></a><span id="l2.312" class="difflineplus">+       ims.executeAsync(this.trackAsync());</span>
<a href="#l2.313"></a><span id="l2.313">     }</span>
<a href="#l2.314"></a><span id="l2.314">     catch(ex) {</span>
<a href="#l2.315"></a><span id="l2.315">        throw(&quot;error executing statement... &quot; +</span>
<a href="#l2.316"></a><span id="l2.316">              this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l2.317"></a><span id="l2.317">              this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l2.318"></a><span id="l2.318">     }</span>
<a href="#l2.319"></a><span id="l2.319"> </span>
<a href="#l2.320"></a><span id="l2.320">     this._log.debug(&quot;CreateMessage: &quot; + folderID + &quot;, &quot; + aMessageKey + &quot;, &quot; +</span>
<a href="#l2.321"></a><span id="l2.321" class="difflineat">@@ -1261,17 +1303,17 @@ let GlodaDatastore = {</span>
<a href="#l2.322"></a><span id="l2.322">       imts.bindStringParameter(1, aSubject);</span>
<a href="#l2.323"></a><span id="l2.323">       imts.bindStringParameter(2, aBody);</span>
<a href="#l2.324"></a><span id="l2.324">       if (aAttachmentNames === null)</span>
<a href="#l2.325"></a><span id="l2.325">         imts.bindNullParameter(3);</span>
<a href="#l2.326"></a><span id="l2.326">       else</span>
<a href="#l2.327"></a><span id="l2.327">         imts.bindStringParameter(3, aAttachmentNames);</span>
<a href="#l2.328"></a><span id="l2.328">       </span>
<a href="#l2.329"></a><span id="l2.329">       try {</span>
<a href="#l2.330"></a><span id="l2.330" class="difflineminus">-         imts.executeAsync();</span>
<a href="#l2.331"></a><span id="l2.331" class="difflineplus">+         imts.executeAsync(this.trackAsync());</span>
<a href="#l2.332"></a><span id="l2.332">       }</span>
<a href="#l2.333"></a><span id="l2.333">       catch(ex) {</span>
<a href="#l2.334"></a><span id="l2.334">          throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l2.335"></a><span id="l2.335">                this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l2.336"></a><span id="l2.336">                this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l2.337"></a><span id="l2.337">       }</span>
<a href="#l2.338"></a><span id="l2.338">     }</span>
<a href="#l2.339"></a><span id="l2.339">     </span>
<a href="#l2.340"></a><span id="l2.340" class="difflineat">@@ -1319,29 +1361,29 @@ let GlodaDatastore = {</span>
<a href="#l2.341"></a><span id="l2.341">       ums.bindInt64Parameter(1, aMessage.messageKey);</span>
<a href="#l2.342"></a><span id="l2.342">     ums.bindInt64Parameter(2, aMessage.conversationID);</span>
<a href="#l2.343"></a><span id="l2.343">     if (aMessage.date === null)</span>
<a href="#l2.344"></a><span id="l2.344">       ums.bindNullParameter(3);</span>
<a href="#l2.345"></a><span id="l2.345">     else</span>
<a href="#l2.346"></a><span id="l2.346">       ums.bindInt64Parameter(3, aMessage.date * 1000);</span>
<a href="#l2.347"></a><span id="l2.347">     ums.bindStringParameter(4, aMessage.headerMessageID);</span>
<a href="#l2.348"></a><span id="l2.348">     </span>
<a href="#l2.349"></a><span id="l2.349" class="difflineminus">-    ums.executeAsync();</span>
<a href="#l2.350"></a><span id="l2.350" class="difflineplus">+    ums.executeAsync(this.trackAsync());</span>
<a href="#l2.351"></a><span id="l2.351">     </span>
<a href="#l2.352"></a><span id="l2.352">     if (aBody) {</span>
<a href="#l2.353"></a><span id="l2.353">       let imts = this._insertMessageTextStatement;</span>
<a href="#l2.354"></a><span id="l2.354">       imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l2.355"></a><span id="l2.355">       imts.bindStringParameter(1, aSubject);</span>
<a href="#l2.356"></a><span id="l2.356">       imts.bindStringParameter(2, aBody);</span>
<a href="#l2.357"></a><span id="l2.357">       if (aAttachmentNames === null)</span>
<a href="#l2.358"></a><span id="l2.358">         imts.bindNullParameter(3);</span>
<a href="#l2.359"></a><span id="l2.359">       else</span>
<a href="#l2.360"></a><span id="l2.360">         imts.bindStringParameter(3, aAttachmentNames);</span>
<a href="#l2.361"></a><span id="l2.361">       </span>
<a href="#l2.362"></a><span id="l2.362" class="difflineminus">-      imts.executeAsync();</span>
<a href="#l2.363"></a><span id="l2.363" class="difflineplus">+      imts.executeAsync(this.trackAsync());</span>
<a href="#l2.364"></a><span id="l2.364">     }</span>
<a href="#l2.365"></a><span id="l2.365">     </span>
<a href="#l2.366"></a><span id="l2.366">     // In completely abstract theory, this is where we would call</span>
<a href="#l2.367"></a><span id="l2.367">     //  GlodaCollectionManager.itemsModified, except that the attributes may</span>
<a href="#l2.368"></a><span id="l2.368">     //  also have changed, so it's out of our hands.  (Gloda.processMessage</span>
<a href="#l2.369"></a><span id="l2.369">     //  handles it.)</span>
<a href="#l2.370"></a><span id="l2.370">   },</span>
<a href="#l2.371"></a><span id="l2.371"> </span>
<a href="#l2.372"></a><span id="l2.372" class="difflineat">@@ -1359,17 +1401,17 @@ let GlodaDatastore = {</span>
<a href="#l2.373"></a><span id="l2.373">     let sqlStr = &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l2.374"></a><span id="l2.374">                                       messageKey = ?2 \</span>
<a href="#l2.375"></a><span id="l2.375">                    WHERE folderID = ?3 \</span>
<a href="#l2.376"></a><span id="l2.376">                      AND messageKey IN (&quot; + aMessageKeys.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l2.377"></a><span id="l2.377">     let statement = this._createAsyncStatement(sqlStr, true);</span>
<a href="#l2.378"></a><span id="l2.378">     statement.bindInt64Parameter(2, srcFolderID);</span>
<a href="#l2.379"></a><span id="l2.379">     statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l2.380"></a><span id="l2.380">     statement.bindNullParameter(1);</span>
<a href="#l2.381"></a><span id="l2.381" class="difflineminus">-    statement.executeAsync();</span>
<a href="#l2.382"></a><span id="l2.382" class="difflineplus">+    statement.executeAsync(this.trackAsync());</span>
<a href="#l2.383"></a><span id="l2.383">     statement.finalize();</span>
<a href="#l2.384"></a><span id="l2.384">   },</span>
<a href="#l2.385"></a><span id="l2.385">   </span>
<a href="#l2.386"></a><span id="l2.386">   _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l2.387"></a><span id="l2.387">     let folderId, messageKey, date;</span>
<a href="#l2.388"></a><span id="l2.388">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l2.389"></a><span id="l2.389">       folderId = null;</span>
<a href="#l2.390"></a><span id="l2.390">     else</span>
<a href="#l2.391"></a><span id="l2.391" class="difflineat">@@ -1378,23 +1420,24 @@ let GlodaDatastore = {</span>
<a href="#l2.392"></a><span id="l2.392">       messageKey = null;</span>
<a href="#l2.393"></a><span id="l2.393">     else</span>
<a href="#l2.394"></a><span id="l2.394">       messageKey = aRow.getInt64(2);</span>
<a href="#l2.395"></a><span id="l2.395">     if (aRow.getTypeOfIndex(4) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l2.396"></a><span id="l2.396">       date = null;</span>
<a href="#l2.397"></a><span id="l2.397">     else</span>
<a href="#l2.398"></a><span id="l2.398">       date = new Date(aRow.getInt64(4) / 1000);</span>
<a href="#l2.399"></a><span id="l2.399">     return new GlodaMessage(this, aRow.getInt64(0), folderId, messageKey,</span>
<a href="#l2.400"></a><span id="l2.400" class="difflineminus">-                            aRow.getInt64(3), null, date, aRow.getString(5));</span>
<a href="#l2.401"></a><span id="l2.401" class="difflineplus">+                            aRow.getInt64(3), null, date, aRow.getString(5),</span>
<a href="#l2.402"></a><span id="l2.402" class="difflineplus">+                            aRow.getInt64(6);</span>
<a href="#l2.403"></a><span id="l2.403">   },</span>
<a href="#l2.404"></a><span id="l2.404"> </span>
<a href="#l2.405"></a><span id="l2.405">   get _selectMessageByIDStatement() {</span>
<a href="#l2.406"></a><span id="l2.406">     let statement = this._createSyncStatement(</span>
<a href="#l2.407"></a><span id="l2.407" class="difflineminus">-      &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageID \</span>
<a href="#l2.408"></a><span id="l2.408" class="difflineminus">-         FROM messages WHERE id = ?1&quot;);</span>
<a href="#l2.409"></a><span id="l2.409" class="difflineplus">+      &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageID, \</span>
<a href="#l2.410"></a><span id="l2.410" class="difflineplus">+           deleted FROM messages WHERE id = ?1&quot;);</span>
<a href="#l2.411"></a><span id="l2.411">     this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l2.412"></a><span id="l2.412">       function() statement);</span>
<a href="#l2.413"></a><span id="l2.413">     return this._selectMessageByIDStatement;</span>
<a href="#l2.414"></a><span id="l2.414">   },</span>
<a href="#l2.415"></a><span id="l2.415"> </span>
<a href="#l2.416"></a><span id="l2.416">   /**</span>
<a href="#l2.417"></a><span id="l2.417">    * Synchronously retrieve the given message given its gloda message id.</span>
<a href="#l2.418"></a><span id="l2.418">    */</span>
<a href="#l2.419"></a><span id="l2.419" class="difflineat">@@ -1413,18 +1456,18 @@ let GlodaDatastore = {</span>
<a href="#l2.420"></a><span id="l2.420">       smbis.reset();</span>
<a href="#l2.421"></a><span id="l2.421">     }</span>
<a href="#l2.422"></a><span id="l2.422">     </span>
<a href="#l2.423"></a><span id="l2.423">     return message;</span>
<a href="#l2.424"></a><span id="l2.424">   },</span>
<a href="#l2.425"></a><span id="l2.425"> </span>
<a href="#l2.426"></a><span id="l2.426">   get _selectMessageByLocationStatement() {</span>
<a href="#l2.427"></a><span id="l2.427">     let statement = this._createSyncStatement(</span>
<a href="#l2.428"></a><span id="l2.428" class="difflineminus">-      &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageId \</span>
<a href="#l2.429"></a><span id="l2.429" class="difflineminus">-       FROM messages WHERE folderID = ?1 AND messageKey = ?2&quot;);</span>
<a href="#l2.430"></a><span id="l2.430" class="difflineplus">+      &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageId, \</span>
<a href="#l2.431"></a><span id="l2.431" class="difflineplus">+       deleted FROM messages WHERE folderID = ?1 AND messageKey = ?2&quot;);</span>
<a href="#l2.432"></a><span id="l2.432">     this.__defineGetter__(&quot;_selectMessageByLocationStatement&quot;,</span>
<a href="#l2.433"></a><span id="l2.433">       function() statement);</span>
<a href="#l2.434"></a><span id="l2.434">     return this._selectMessageByLocationStatement;</span>
<a href="#l2.435"></a><span id="l2.435">   },</span>
<a href="#l2.436"></a><span id="l2.436"> </span>
<a href="#l2.437"></a><span id="l2.437">   /**</span>
<a href="#l2.438"></a><span id="l2.438">    * Synchronously retrieve the message that we believe to correspond to the </span>
<a href="#l2.439"></a><span id="l2.439">    *  given message key in the given folder.</span>
<a href="#l2.440"></a><span id="l2.440" class="difflineat">@@ -1507,29 +1550,56 @@ let GlodaDatastore = {</span>
<a href="#l2.441"></a><span id="l2.441">                     quotedIDs + &quot;)&quot;;</span>
<a href="#l2.442"></a><span id="l2.442">     let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l2.443"></a><span id="l2.443">     </span>
<a href="#l2.444"></a><span id="l2.444">     statement.executeAsync(new MessagesByMessageIdCallback(statement,</span>
<a href="#l2.445"></a><span id="l2.445">       msgIDToIndex, results, aCallback, aCallbackThis, aCallbackArgs));</span>
<a href="#l2.446"></a><span id="l2.446">     statement.finalize();</span>
<a href="#l2.447"></a><span id="l2.447">   },</span>
<a href="#l2.448"></a><span id="l2.448"> </span>
<a href="#l2.449"></a><span id="l2.449" class="difflineplus">+  get _updateMessagesMarkDeletedByFolderID() {</span>
<a href="#l2.450"></a><span id="l2.450" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l2.451"></a><span id="l2.451" class="difflineplus">+      &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, \</span>
<a href="#l2.452"></a><span id="l2.452" class="difflineplus">+              deleted = 1 WHERE folderID = ?1&quot;);</span>
<a href="#l2.453"></a><span id="l2.453" class="difflineplus">+    this.__defineGetter__(&quot;_updateMessagesMarkDeletedByFolderID&quot;,</span>
<a href="#l2.454"></a><span id="l2.454" class="difflineplus">+      function() statement);</span>
<a href="#l2.455"></a><span id="l2.455" class="difflineplus">+    return this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l2.456"></a><span id="l2.456" class="difflineplus">+  },</span>
<a href="#l2.457"></a><span id="l2.457" class="difflineplus">+</span>
<a href="#l2.458"></a><span id="l2.458" class="difflineplus">+  markMessagesDeletedByFolderID: function gloda_ds_markMessagesDeletedByIDs(</span>
<a href="#l2.459"></a><span id="l2.459" class="difflineplus">+      aFolderID) {</span>
<a href="#l2.460"></a><span id="l2.460" class="difflineplus">+    let statement = this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l2.461"></a><span id="l2.461" class="difflineplus">+    statement.bindInt64Parameter(0, aFolderID);</span>
<a href="#l2.462"></a><span id="l2.462" class="difflineplus">+    statement.executeAsync(this.trackAsync());</span>
<a href="#l2.463"></a><span id="l2.463" class="difflineplus">+    statement.finalize();</span>
<a href="#l2.464"></a><span id="l2.464" class="difflineplus">+  },</span>
<a href="#l2.465"></a><span id="l2.465" class="difflineplus">+</span>
<a href="#l2.466"></a><span id="l2.466" class="difflineplus">+  markMessagesDeletedByIDs: function gloda_ds_markMessagesDeletedByIDs(</span>
<a href="#l2.467"></a><span id="l2.467" class="difflineplus">+      aMessageIDs) {</span>
<a href="#l2.468"></a><span id="l2.468" class="difflineplus">+    let sqlString = &quot;UPDATE messages SET deleted = 1 WHERE id IN (&quot; + </span>
<a href="#l2.469"></a><span id="l2.469" class="difflineplus">+      aMessageIDs.join(&quot;,&quot;) + &quot;)&quot;;</span>
<a href="#l2.470"></a><span id="l2.470" class="difflineplus">+    </span>
<a href="#l2.471"></a><span id="l2.471" class="difflineplus">+    let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l2.472"></a><span id="l2.472" class="difflineplus">+    statement.executeAsync(this.trackAsync());</span>
<a href="#l2.473"></a><span id="l2.473" class="difflineplus">+    statement.finalize();</span>
<a href="#l2.474"></a><span id="l2.474" class="difflineplus">+  },</span>
<a href="#l2.475"></a><span id="l2.475" class="difflineplus">+</span>
<a href="#l2.476"></a><span id="l2.476">   get _deleteMessageByIDStatement() {</span>
<a href="#l2.477"></a><span id="l2.477">     let statement = this._createAsyncStatement(</span>
<a href="#l2.478"></a><span id="l2.478">       &quot;DELETE FROM messages WHERE id = ?1&quot;);</span>
<a href="#l2.479"></a><span id="l2.479">     this.__defineGetter__(&quot;_deleteMessageByIDStatement&quot;,</span>
<a href="#l2.480"></a><span id="l2.480">                           function() statement);</span>
<a href="#l2.481"></a><span id="l2.481">     return this._deleteMessageByIDStatement; </span>
<a href="#l2.482"></a><span id="l2.482">   },</span>
<a href="#l2.483"></a><span id="l2.483">   </span>
<a href="#l2.484"></a><span id="l2.484">   deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l2.485"></a><span id="l2.485">     // TODO: collection manager implications</span>
<a href="#l2.486"></a><span id="l2.486">     let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l2.487"></a><span id="l2.487">     dmbids.bindInt64Parameter(0, aMessageID);</span>
<a href="#l2.488"></a><span id="l2.488" class="difflineminus">-    dmbids.executeAsync();</span>
<a href="#l2.489"></a><span id="l2.489" class="difflineplus">+    dmbids.executeAsync(this.trackAsync());</span>
<a href="#l2.490"></a><span id="l2.490">   },</span>
<a href="#l2.491"></a><span id="l2.491"> </span>
<a href="#l2.492"></a><span id="l2.492">   get _deleteMessagesByConversationIDStatement() {</span>
<a href="#l2.493"></a><span id="l2.493">     let statement = this._createAsyncStatement(</span>
<a href="#l2.494"></a><span id="l2.494">       &quot;DELETE FROM messages WHERE conversationID = ?1&quot;);</span>
<a href="#l2.495"></a><span id="l2.495">     this.__defineGetter__(&quot;_deleteMessagesByConversationIDStatement&quot;,</span>
<a href="#l2.496"></a><span id="l2.496">                           function() statement);</span>
<a href="#l2.497"></a><span id="l2.497">     return this._deleteMessagesByConversationIDStatement; </span>
<a href="#l2.498"></a><span id="l2.498" class="difflineat">@@ -1539,17 +1609,17 @@ let GlodaDatastore = {</span>
<a href="#l2.499"></a><span id="l2.499">    * Delete messages by conversation ID.  For use by the indexer's deletion</span>
<a href="#l2.500"></a><span id="l2.500">    *  logic, NOT you.</span>
<a href="#l2.501"></a><span id="l2.501">    */</span>
<a href="#l2.502"></a><span id="l2.502">   deleteMessagesByConversationID:</span>
<a href="#l2.503"></a><span id="l2.503">     // TODO: collection manager implications</span>
<a href="#l2.504"></a><span id="l2.504">       function gloda_ds_deleteMessagesByConversationID(aConversationID) {</span>
<a href="#l2.505"></a><span id="l2.505">     let dmbcids = this._deleteMessagesByConversationIDStatement;</span>
<a href="#l2.506"></a><span id="l2.506">     dmbcids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l2.507"></a><span id="l2.507" class="difflineminus">-    dmbcids.executeAsync();</span>
<a href="#l2.508"></a><span id="l2.508" class="difflineplus">+    dmbcids.executeAsync(this.trackAsync());</span>
<a href="#l2.509"></a><span id="l2.509">   },</span>
<a href="#l2.510"></a><span id="l2.510"> </span>
<a href="#l2.511"></a><span id="l2.511">   get _selectMessagesByConversationIDStatement() {</span>
<a href="#l2.512"></a><span id="l2.512">     let statement = this._createSyncStatement(</span>
<a href="#l2.513"></a><span id="l2.513">       &quot;SELECT * FROM messages WHERE conversationID = ?1&quot;);</span>
<a href="#l2.514"></a><span id="l2.514">     this.__defineGetter__(&quot;_selectMessagesByConversationIDStatement&quot;,</span>
<a href="#l2.515"></a><span id="l2.515">       function() statement);</span>
<a href="#l2.516"></a><span id="l2.516">     return this._selectMessagesByConversationIDStatement;</span>
<a href="#l2.517"></a><span id="l2.517" class="difflineat">@@ -1650,17 +1720,17 @@ let GlodaDatastore = {</span>
<a href="#l2.518"></a><span id="l2.518">         // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l2.519"></a><span id="l2.519">         //  really care anyways.)</span>
<a href="#l2.520"></a><span id="l2.520">         if (attribValueTuple[1] == null)</span>
<a href="#l2.521"></a><span id="l2.521">           imas.bindInt64Parameter(3, 0);</span>
<a href="#l2.522"></a><span id="l2.522">         else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l2.523"></a><span id="l2.523">           imas.bindInt64Parameter(3, attribValueTuple[1]);</span>
<a href="#l2.524"></a><span id="l2.524">         else</span>
<a href="#l2.525"></a><span id="l2.525">           imas.bindDoubleParameter(3, attribValueTuple[1]);</span>
<a href="#l2.526"></a><span id="l2.526" class="difflineminus">-        imas.executeAsync();</span>
<a href="#l2.527"></a><span id="l2.527" class="difflineplus">+        imas.executeAsync(this.trackAsync());</span>
<a href="#l2.528"></a><span id="l2.528">       }</span>
<a href="#l2.529"></a><span id="l2.529">       </span>
<a href="#l2.530"></a><span id="l2.530">       this._commitTransaction();</span>
<a href="#l2.531"></a><span id="l2.531">     }</span>
<a href="#l2.532"></a><span id="l2.532">     catch (ex) {</span>
<a href="#l2.533"></a><span id="l2.533">       this._rollbackTransaction();</span>
<a href="#l2.534"></a><span id="l2.534">       throw ex;</span>
<a href="#l2.535"></a><span id="l2.535">     }</span>
<a href="#l2.536"></a><span id="l2.536" class="difflineat">@@ -1681,17 +1751,18 @@ let GlodaDatastore = {</span>
<a href="#l2.537"></a><span id="l2.537">    *</span>
<a href="#l2.538"></a><span id="l2.538">    * @param aMessage The GlodaMessage whose database attributes should be</span>
<a href="#l2.539"></a><span id="l2.539">    *     purged.</span>
<a href="#l2.540"></a><span id="l2.540">    */</span>
<a href="#l2.541"></a><span id="l2.541">   clearMessageAttributes: function gloda_ds_clearMessageAttributes(aMessage) {</span>
<a href="#l2.542"></a><span id="l2.542">     if (aMessage.id != null) {</span>
<a href="#l2.543"></a><span id="l2.543">       this._deleteMessageAttributesByMessageIDStatement.bindInt64Parameter(0,</span>
<a href="#l2.544"></a><span id="l2.544">         aMessage.id);</span>
<a href="#l2.545"></a><span id="l2.545" class="difflineminus">-      this._deleteMessageAttributesByMessageIDStatement.executeAsync();</span>
<a href="#l2.546"></a><span id="l2.546" class="difflineplus">+      this._deleteMessageAttributesByMessageIDStatement.executeAsync(</span>
<a href="#l2.547"></a><span id="l2.547" class="difflineplus">+        this.trackAsync());</span>
<a href="#l2.548"></a><span id="l2.548">     }</span>
<a href="#l2.549"></a><span id="l2.549">   },</span>
<a href="#l2.550"></a><span id="l2.550">   </span>
<a href="#l2.551"></a><span id="l2.551">   get _selectMessageAttributesByMessageIDStatement() {</span>
<a href="#l2.552"></a><span id="l2.552">     let statement = this._createSyncStatement(</span>
<a href="#l2.553"></a><span id="l2.553">       &quot;SELECT attributeID, value FROM messageAttributes \</span>
<a href="#l2.554"></a><span id="l2.554">          WHERE messageID = ?1&quot;);</span>
<a href="#l2.555"></a><span id="l2.555">     this.__defineGetter__(&quot;_selectMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l2.556"></a><span id="l2.556" class="difflineat">@@ -1989,17 +2060,17 @@ let GlodaDatastore = {</span>
<a href="#l2.557"></a><span id="l2.557">     if (aContactUUID == null)</span>
<a href="#l2.558"></a><span id="l2.558">       ics.bindNullParameter(2);</span>
<a href="#l2.559"></a><span id="l2.559">     else</span>
<a href="#l2.560"></a><span id="l2.560">       ics.bindStringParameter(2, aContactUUID);</span>
<a href="#l2.561"></a><span id="l2.561">     ics.bindStringParameter(3, aName);</span>
<a href="#l2.562"></a><span id="l2.562">     ics.bindInt64Parameter(4, aPopularity);</span>
<a href="#l2.563"></a><span id="l2.563">     ics.bindInt64Parameter(5, aFrecency);</span>
<a href="#l2.564"></a><span id="l2.564">     </span>
<a href="#l2.565"></a><span id="l2.565" class="difflineminus">-    ics.executeAsync();</span>
<a href="#l2.566"></a><span id="l2.566" class="difflineplus">+    ics.executeAsync(this.trackAsync());</span>
<a href="#l2.567"></a><span id="l2.567">     </span>
<a href="#l2.568"></a><span id="l2.568">     let contact = new GlodaContact(this, contactID,</span>
<a href="#l2.569"></a><span id="l2.569">                                    aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l2.570"></a><span id="l2.570">                                    aPopularity, aFrecency);</span>
<a href="#l2.571"></a><span id="l2.571">     GlodaCollectionManager.itemsAdded(contact.NOUN_ID, [contact]);</span>
<a href="#l2.572"></a><span id="l2.572">     return contact;</span>
<a href="#l2.573"></a><span id="l2.573">   },</span>
<a href="#l2.574"></a><span id="l2.574"> </span>
<a href="#l2.575"></a><span id="l2.575" class="difflineat">@@ -2019,17 +2090,17 @@ let GlodaDatastore = {</span>
<a href="#l2.576"></a><span id="l2.576">     let ucs = this._updateContactStatement;</span>
<a href="#l2.577"></a><span id="l2.577">     ucs.bindInt64Parameter(5, aContact.id);</span>
<a href="#l2.578"></a><span id="l2.578">     ucs.bindStringParameter(0, aContact.directoryUUID);</span>
<a href="#l2.579"></a><span id="l2.579">     ucs.bindStringParameter(1, aContact.contactUUID);</span>
<a href="#l2.580"></a><span id="l2.580">     ucs.bindStringParameter(2, aContact.name);</span>
<a href="#l2.581"></a><span id="l2.581">     ucs.bindInt64Parameter(3, aContact.popularity);</span>
<a href="#l2.582"></a><span id="l2.582">     ucs.bindInt64Parameter(4, aContact.frecency);</span>
<a href="#l2.583"></a><span id="l2.583">     </span>
<a href="#l2.584"></a><span id="l2.584" class="difflineminus">-    ucs.executeAsync();</span>
<a href="#l2.585"></a><span id="l2.585" class="difflineplus">+    ucs.executeAsync(this.trackAsync());</span>
<a href="#l2.586"></a><span id="l2.586">   },</span>
<a href="#l2.587"></a><span id="l2.587">   </span>
<a href="#l2.588"></a><span id="l2.588">   _contactFromRow: function gloda_ds_contactFromRow(aRow) {</span>
<a href="#l2.589"></a><span id="l2.589">     let directoryUUID, contactUUID;</span>
<a href="#l2.590"></a><span id="l2.590">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l2.591"></a><span id="l2.591">       directoryUUID = null;</span>
<a href="#l2.592"></a><span id="l2.592">     else</span>
<a href="#l2.593"></a><span id="l2.593">       directoryUUID = aRow.getString(1);</span>
<a href="#l2.594"></a><span id="l2.594" class="difflineat">@@ -2094,17 +2165,17 @@ let GlodaDatastore = {</span>
<a href="#l2.595"></a><span id="l2.595">     let identityID = this._nextIdentityId++;</span>
<a href="#l2.596"></a><span id="l2.596">     let iis = this._insertIdentityStatement;</span>
<a href="#l2.597"></a><span id="l2.597">     iis.bindInt64Parameter(0, identityID);</span>
<a href="#l2.598"></a><span id="l2.598">     iis.bindInt64Parameter(1, aContactID);</span>
<a href="#l2.599"></a><span id="l2.599">     iis.bindStringParameter(2, aKind);</span>
<a href="#l2.600"></a><span id="l2.600">     iis.bindStringParameter(3, aValue);</span>
<a href="#l2.601"></a><span id="l2.601">     iis.bindStringParameter(4, aDescription);</span>
<a href="#l2.602"></a><span id="l2.602">     iis.bindInt64Parameter(5, aIsRelay ? 1 : 0);</span>
<a href="#l2.603"></a><span id="l2.603" class="difflineminus">-    iis.executeAsync();</span>
<a href="#l2.604"></a><span id="l2.604" class="difflineplus">+    iis.executeAsync(this.trackAsync());</span>
<a href="#l2.605"></a><span id="l2.605">   </span>
<a href="#l2.606"></a><span id="l2.606">     let identity = new GlodaIdentity(this, identityID,</span>
<a href="#l2.607"></a><span id="l2.607">                                      aContactID, aContact, aKind, aValue,</span>
<a href="#l2.608"></a><span id="l2.608">                                      aDescription, aIsRelay);</span>
<a href="#l2.609"></a><span id="l2.609">     GlodaCollectionManager.itemsAdded(identity.NOUN_ID, [identity]);</span>
<a href="#l2.610"></a><span id="l2.610">     return identity;</span>
<a href="#l2.611"></a><span id="l2.611">   },</span>
<a href="#l2.612"></a><span id="l2.612">   </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -124,16 +124,18 @@ function fixIterator(aEnum, aIface) {</span>
<a href="#l3.4"></a><span id="l3.4">     let iter = function () {</span>
<a href="#l3.5"></a><span id="l3.5">       while (aEnum.hasMoreElements())</span>
<a href="#l3.6"></a><span id="l3.6">         yield aEnum.getNext().QueryInterface(face);</span>
<a href="#l3.7"></a><span id="l3.7">     }</span>
<a href="#l3.8"></a><span id="l3.8">     return { __iterator__: iter };</span>
<a href="#l3.9"></a><span id="l3.9">   } catch(ex) {}</span>
<a href="#l3.10"></a><span id="l3.10"> }</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+const MSG_FLAG_OFFLINE = 0x80;</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+</span>
<a href="#l3.14"></a><span id="l3.14"> /**</span>
<a href="#l3.15"></a><span id="l3.15">  * Capture the indexing batch concept explicitly.</span>
<a href="#l3.16"></a><span id="l3.16">  *</span>
<a href="#l3.17"></a><span id="l3.17">  * @param aJobType The type of thing we are indexing.  Current choices are:</span>
<a href="#l3.18"></a><span id="l3.18">  *   &quot;folder&quot; and &quot;message&quot;.  Previous choices included &quot;account&quot;.  The indexer</span>
<a href="#l3.19"></a><span id="l3.19">  *   currently knows too much about these; they should be de-coupled.</span>
<a href="#l3.20"></a><span id="l3.20">  * @param aDeltaType -1 for deletion, 0 for move, 1 for addition/new.</span>
<a href="#l3.21"></a><span id="l3.21">  * @param aID Specific to the job type, but for now only used to hold folder</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -167,18 +169,77 @@ const kWorkSync = 0;</span>
<a href="#l3.23"></a><span id="l3.23">  * Asynchronous activity performed, you need to relinquish flow control and</span>
<a href="#l3.24"></a><span id="l3.24">  *  trust us to call callbackDriver later.</span>
<a href="#l3.25"></a><span id="l3.25">  */</span>
<a href="#l3.26"></a><span id="l3.26"> const kWorkAsync = 1;</span>
<a href="#l3.27"></a><span id="l3.27"> /**</span>
<a href="#l3.28"></a><span id="l3.28">  * We are all done with our task, close us and figure out something else to do.</span>
<a href="#l3.29"></a><span id="l3.29">  */</span>
<a href="#l3.30"></a><span id="l3.30"> const kWorkDone = 2;</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+/**</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+ * We are not done with our task, but we think it's a good idea to take a</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+ *  breather.</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+ */</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+const kWorkPause = 3;</span>
<a href="#l3.36"></a><span id="l3.36"> </span>
<a href="#l3.37"></a><span id="l3.37"> /**</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+ * === Indexing Goals</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+ * We have the following goals:</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+ *</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+ * Responsiveness</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+ * - When the user wants to quit, we should be able to stop and quit in a timely</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+ *   fasion.</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+ * - We should not interfere with the user's thunderbird usage.</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+ *</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+ * Correctness</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+ * - Quitting should not result in any information loss; we should (eventually)</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+ *   end up at the same indexed state regardless of whether a user lets</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+ *   indexing run to completion or restarts thunderbird in the middle of the</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+ *   process.  (It is okay to take slightly longer in the latter case.)</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+ * </span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+ * Worst Case Scenario Avoidance</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+ * - We should try to be O(1) memory-wise regardless of what notifications</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+ *   are thrown at us.</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+ *</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+ * === Indexing Strategy</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+ * To these ends, we implement things like so:</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+ *</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+ * Mesage State Tracking</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+ * - We store a property on all indexed headers indicating their gloda message</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+ *   id.  This allows us to tell whether a message is indexed from the header,</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+ *   without having to consult the SQL database.</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+ * - When we receive an event that indicates that a message's meta-data has</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+ *   changed and gloda needs to re-index the message, we set a property on the</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+ *   header that indicates the message is dirty.</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+ * - We store a property on folders that indicate that the folder's index is</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+ *   up-to-date.  Absence of this property is akin to a 0=folder not up to date.</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+ *   There is no particular reason for the choice of using the folder's</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+ *   properties (via the folder cache implementation) over gloda's own folder</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+ *   meta-data.</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+ *</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+ * Indexing Message Control</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+ * - We index IMAP messages that are offline.  We index all local messages.</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+ *   We plan to avoid indexing news messages.</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+ * - We would like a way to express desires about indexing that either don't</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+ *   confound offline storage with indexing, or actually allow some choice.</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+ *</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+ * Indexing</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+ * - We process one folder at a time, walking the headers in the folder,</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+ *   indexing those which should be indexed, but which have never been indexed</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+ *   or are dirty.</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+ * - For local folders, we use GetDatabaseWithReparse to ensure that the .msf</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+ *   file exists.  For IMAP folders, we simply use GetDatabase because we know</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+ *   the auto-sync logic will make sure that the folder is up-to-date and we</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+ *   want to avoid creating problems through use of updateFolder.</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineplus">+ *</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineplus">+ * Indexing Throttling</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+ * - Unless we believe everything is up-to-date, then we are always indexing.</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+ *   We must be able to process messages </span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+ *</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+ *</span>
<a href="#l3.92"></a><span id="l3.92">  * === Message Indexing</span>
<a href="#l3.93"></a><span id="l3.93">  * </span>
<a href="#l3.94"></a><span id="l3.94">  * We are good at listening to nsIMsgFolderListener events.  Unfortunately,</span>
<a href="#l3.95"></a><span id="l3.95">  *  MailNews isn't pervasively thorough at generating these yet (newsgroups</span>
<a href="#l3.96"></a><span id="l3.96">  *  don't produce them, probably not RSS either.)  This provides us with</span>
<a href="#l3.97"></a><span id="l3.97">  *  message addition, moves/copies, and deletion.</span>
<a href="#l3.98"></a><span id="l3.98">  * We are not good at listening to nsIFolderListener events.  This means we fail</span>
<a href="#l3.99"></a><span id="l3.99">  *  to update ourselves when a message is changed because of a change in tags,</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineat">@@ -219,16 +280,20 @@ let GlodaIndexer = {</span>
<a href="#l3.101"></a><span id="l3.101">    * Initialize the indexer.</span>
<a href="#l3.102"></a><span id="l3.102">    */</span>
<a href="#l3.103"></a><span id="l3.103">   _init: function gloda_index_init() {</span>
<a href="#l3.104"></a><span id="l3.104">     if (this._inited)</span>
<a href="#l3.105"></a><span id="l3.105">       return;</span>
<a href="#l3.106"></a><span id="l3.106">     </span>
<a href="#l3.107"></a><span id="l3.107">     this._inited = true;</span>
<a href="#l3.108"></a><span id="l3.108">     </span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+    // initialize our listeners' this pointers</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+    this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineplus">+    this._msgFolderListener.indexer = this;</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineplus">+    </span>
<a href="#l3.113"></a><span id="l3.113">     // create the timer that drives our intermittent indexing</span>
<a href="#l3.114"></a><span id="l3.114">     this._timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l3.115"></a><span id="l3.115"> </span>
<a href="#l3.116"></a><span id="l3.116">     // register for:</span>
<a href="#l3.117"></a><span id="l3.117">     // - folder loaded events, so we know when updateFolder has finished</span>
<a href="#l3.118"></a><span id="l3.118">     //   updating the index/what not (if it was't immediately available)</span>
<a href="#l3.119"></a><span id="l3.119">     // - property changes (so we know when a message's read/starred state have</span>
<a href="#l3.120"></a><span id="l3.120">     //   changed.)</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineat">@@ -269,18 +334,16 @@ let GlodaIndexer = {</span>
<a href="#l3.122"></a><span id="l3.122">   </span>
<a href="#l3.123"></a><span id="l3.123">   /**</span>
<a href="#l3.124"></a><span id="l3.124">    * Are we enabled, read: are we processing change events?</span>
<a href="#l3.125"></a><span id="l3.125">    */</span>
<a href="#l3.126"></a><span id="l3.126">   _enabled: false,</span>
<a href="#l3.127"></a><span id="l3.127">   get enabled() { return this._enabled; },</span>
<a href="#l3.128"></a><span id="l3.128">   set enabled(aEnable) {</span>
<a href="#l3.129"></a><span id="l3.129">     if (!this._enabled &amp;&amp; aEnable) {</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineminus">-      this._msgFolderListener.indexer = this;</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineminus">-      </span>
<a href="#l3.132"></a><span id="l3.132">       let notificationService =</span>
<a href="#l3.133"></a><span id="l3.133">         Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l3.134"></a><span id="l3.134">         getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l3.135"></a><span id="l3.135">       notificationService.addListener(this._msgFolderListener,</span>
<a href="#l3.136"></a><span id="l3.136">                                       Ci.nsIMsgFolderNotificationService.all);</span>
<a href="#l3.137"></a><span id="l3.137">       </span>
<a href="#l3.138"></a><span id="l3.138">       this._enabled = true;</span>
<a href="#l3.139"></a><span id="l3.139">     }</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineat">@@ -306,32 +369,41 @@ let GlodaIndexer = {</span>
<a href="#l3.141"></a><span id="l3.141">       this._log.info(&quot;+++ Indexing Queue Processing Commencing&quot;);</span>
<a href="#l3.142"></a><span id="l3.142">       this._indexingActive = true;</span>
<a href="#l3.143"></a><span id="l3.143">       this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l3.144"></a><span id="l3.144">                                    this._indexInterval,</span>
<a href="#l3.145"></a><span id="l3.145">                                    Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l3.146"></a><span id="l3.146">     }  </span>
<a href="#l3.147"></a><span id="l3.147">   },</span>
<a href="#l3.148"></a><span id="l3.148">   </span>
<a href="#l3.149"></a><span id="l3.149" class="difflineplus">+  GLODA_MESSAGE_ID_PROPERTY: &quot;gloda-id&quot;,</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+  GLODA_DIRTY_PROPERTY: &quot;gloda-dirty&quot;,</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+  </span>
<a href="#l3.152"></a><span id="l3.152">   /**</span>
<a href="#l3.153"></a><span id="l3.153">    * Our current job number, out of _indexingJobGoal.  Although our jobs comes</span>
<a href="#l3.154"></a><span id="l3.154">    *  from _indexQueue, this is not an offset into that list because we forget</span>
<a href="#l3.155"></a><span id="l3.155">    *  jobs once we complete them.  As such, this value is strictly for progress</span>
<a href="#l3.156"></a><span id="l3.156">    *  tracking.</span>
<a href="#l3.157"></a><span id="l3.157">    */ </span>
<a href="#l3.158"></a><span id="l3.158">   _indexingJobCount: 0,</span>
<a href="#l3.159"></a><span id="l3.159">   /**</span>
<a href="#l3.160"></a><span id="l3.160">    * Total number of jobs to process in this current indexing session; may</span>
<a href="#l3.161"></a><span id="l3.161">    *  increase as new jobs are added to the _indexQueue.  This value won't</span>
<a href="#l3.162"></a><span id="l3.162">    *  decrease until the indexing session is completed (and we become idle),</span>
<a href="#l3.163"></a><span id="l3.163">    *  and then it will go to zero.</span>
<a href="#l3.164"></a><span id="l3.164">    */</span>
<a href="#l3.165"></a><span id="l3.165">   _indexingJobGoal: 0,</span>
<a href="#l3.166"></a><span id="l3.166">   </span>
<a href="#l3.167"></a><span id="l3.167">   /**</span>
<a href="#l3.168"></a><span id="l3.168" class="difflineplus">+   * Indicates that we have pending deletions to process, meaning that there</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineplus">+   *  are gloda message rows </span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+   */</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineplus">+  _pendingDeletions: null,</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+  </span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+  /**</span>
<a href="#l3.174"></a><span id="l3.174">    * A list of IndexingJob instances to process.</span>
<a href="#l3.175"></a><span id="l3.175">    * - ['account', account object]</span>
<a href="#l3.176"></a><span id="l3.176">    * - ['folder', folder URI]</span>
<a href="#l3.177"></a><span id="l3.177">    * - ['message', delta type, message header, folder ID, message key,</span>
<a href="#l3.178"></a><span id="l3.178">    *      message ID]</span>
<a href="#l3.179"></a><span id="l3.179">    *   (we use folder ID instead of URI so that renames can't trick us)</span>
<a href="#l3.180"></a><span id="l3.180">    */</span>
<a href="#l3.181"></a><span id="l3.181">   _indexQueue: [],</span>
<a href="#l3.182"></a><span id="l3.182" class="difflineat">@@ -351,25 +423,49 @@ let GlodaIndexer = {</span>
<a href="#l3.183"></a><span id="l3.183">    *  or the message progress bar.</span>
<a href="#l3.184"></a><span id="l3.184">    */</span>
<a href="#l3.185"></a><span id="l3.185">   _pendingAddJob: null,</span>
<a href="#l3.186"></a><span id="l3.186">   </span>
<a href="#l3.187"></a><span id="l3.187">   /**</span>
<a href="#l3.188"></a><span id="l3.188">    * The time interval, in milliseconds between performing indexing work.</span>
<a href="#l3.189"></a><span id="l3.189">    *  This may be altered by user session (in)activity.</span>
<a href="#l3.190"></a><span id="l3.190">    */ </span>
<a href="#l3.191"></a><span id="l3.191" class="difflineminus">-  _indexInterval: 80,</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+  _indexInterval: 100,</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineplus">+  _indexInterval_whenActive: 100,</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+  _indexInterval_whenIdle: 20,</span>
<a href="#l3.195"></a><span id="l3.195">   /**</span>
<a href="#l3.196"></a><span id="l3.196">    * Number of indexing 'tokens' we are allowed to consume before yielding for</span>
<a href="#l3.197"></a><span id="l3.197">    *  each incremental pass.  Consider a single token equal to indexing a single</span>
<a href="#l3.198"></a><span id="l3.198">    *  medium-sized message.  This may be altered by user session (in)activity.</span>
<a href="#l3.199"></a><span id="l3.199">    * Because we fetch message bodies, which is potentially asynchronous, this</span>
<a href="#l3.200"></a><span id="l3.200">    *  is not a precise knob to twiddle.</span>
<a href="#l3.201"></a><span id="l3.201">    */</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineminus">-  _indexTokens: 15,</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+  _indexTokens: 2,</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+  _indexTokens_whenActive: 2,</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineplus">+  _indexTokens_whenIdle: 10,</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineplus">+  </span>
<a href="#l3.207"></a><span id="l3.207" class="difflineplus">+  /**</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineplus">+   * Number of indexing 'tokens' we consume before we issue a commit.  The</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+   *  goal is to de-couple our time scheduling from our commit schedule.  It's</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+   *  far better for user responsiveness to take lots of little bites instead</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+   *  of a few big ones, but bites that result in commits cannot be little... </span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+   */</span>
<a href="#l3.213"></a><span id="l3.213" class="difflineplus">+  _indexCommitTokens: 10,</span>
<a href="#l3.214"></a><span id="l3.214" class="difflineplus">+  </span>
<a href="#l3.215"></a><span id="l3.215" class="difflineplus">+  /**</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+   * The number of messages that we should queue for processing before letting</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+   *  them fall on the floor and relying on our folder-walking logic to ensure</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+   *  that the messages are indexed.</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineplus">+   * The reason we allow for queueing messages in an event-driven fashion is</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+   *  that once we have reached a steady-state, it is preferable to be able to</span>
<a href="#l3.221"></a><span id="l3.221" class="difflineplus">+   *  deal with new messages and modified meta-data in a prompt fasion rather</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+   *  than having to (potentially) walk every folder in the system just to find</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineplus">+   *  the message that the user changed the tag on.</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineplus">+   */</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineplus">+  _indexMaxEventQueueMessages: 20,</span>
<a href="#l3.226"></a><span id="l3.226">   </span>
<a href="#l3.227"></a><span id="l3.227">   _indexListeners: [],</span>
<a href="#l3.228"></a><span id="l3.228">   /**</span>
<a href="#l3.229"></a><span id="l3.229">    * Add an indexing progress listener.  The listener will be notified of at</span>
<a href="#l3.230"></a><span id="l3.230">    *  least all major status changes (idle -&gt; indexing, indexing -&gt; idle), plus</span>
<a href="#l3.231"></a><span id="l3.231">    *  arbitrary progress updates during the indexing process.</span>
<a href="#l3.232"></a><span id="l3.232">    * If indexing is not active when the listener is added, a synthetic idle</span>
<a href="#l3.233"></a><span id="l3.233">    *  notification will be generated.</span>
<a href="#l3.234"></a><span id="l3.234" class="difflineat">@@ -479,47 +575,44 @@ let GlodaIndexer = {</span>
<a href="#l3.235"></a><span id="l3.235">     let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l3.236"></a><span id="l3.236">                      getService(Ci.nsIRDFService);</span>
<a href="#l3.237"></a><span id="l3.237">     let folder = rdfService.GetResource(folderURI);</span>
<a href="#l3.238"></a><span id="l3.238">     folder.QueryInterface(Ci.nsIMsgFolder); // (we want to explode in the try</span>
<a href="#l3.239"></a><span id="l3.239">     // if this guy wasn't what we wanted)</span>
<a href="#l3.240"></a><span id="l3.240">     this._indexingFolder = folder;</span>
<a href="#l3.241"></a><span id="l3.241">     this._indexingFolderID = aFolderID;</span>
<a href="#l3.242"></a><span id="l3.242"> </span>
<a href="#l3.243"></a><span id="l3.243" class="difflineminus">-    // The msf may need to be created or otherwise updated, updateFolder will</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineminus">-    //  do this for us.  (GetNewMessages would also do it, but we would be</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineminus">-    //  triggering new message retrieval in that case, which we don't actually</span>
<a href="#l3.246"></a><span id="l3.246" class="difflineminus">-    //  desire.</span>
<a href="#l3.247"></a><span id="l3.247" class="difflineminus">-    // TODO: handle password-protected local cache potentially triggering a</span>
<a href="#l3.248"></a><span id="l3.248" class="difflineminus">-    //  password prompt here...</span>
<a href="#l3.249"></a><span id="l3.249">     try {</span>
<a href="#l3.250"></a><span id="l3.250" class="difflineplus">+      // The msf may need to be created or otherwise updated for local folders.</span>
<a href="#l3.251"></a><span id="l3.251" class="difflineplus">+      // This may require yielding until such time as the msf has been created.</span>
<a href="#l3.252"></a><span id="l3.252">       try {</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineminus">-        this._indexingFolder.updateFolder(null);</span>
<a href="#l3.254"></a><span id="l3.254" class="difflineplus">+        if (this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineplus">+          this._indexingDatabase = this._indexingFolder.GetDatabaseWithReparse();</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineplus">+        }</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineplus">+        // we need do nothing special for IMAP, news, or other</span>
<a href="#l3.258"></a><span id="l3.258">       }</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineminus">-      // on NS_ERROR_NOT_INITIALIZED</span>
<a href="#l3.260"></a><span id="l3.260" class="difflineminus">-      catch ( e if e.result == 0xc1f30001) {</span>
<a href="#l3.261"></a><span id="l3.261" class="difflineplus">+      catch ( e if e.result == Components.results.NS_ERROR_NOT_INITIALIZED) {</span>
<a href="#l3.262"></a><span id="l3.262">         // this means that we need to pend on the update.</span>
<a href="#l3.263"></a><span id="l3.263">         this._log.debug(&quot;Pending on folder load...&quot;);</span>
<a href="#l3.264"></a><span id="l3.264">         this._pendingFolderEntry = this._indexingFolder;</span>
<a href="#l3.265"></a><span id="l3.265">         this._indexingFolder = null;</span>
<a href="#l3.266"></a><span id="l3.266">         this._indexingFolderID = null;</span>
<a href="#l3.267"></a><span id="l3.267">         this._indexingDatabase = null;</span>
<a href="#l3.268"></a><span id="l3.268">         this._indexingIterator = null;</span>
<a href="#l3.269"></a><span id="l3.269">         return kWorkAsync;</span>
<a href="#l3.270"></a><span id="l3.270">       }</span>
<a href="#l3.271"></a><span id="l3.271">       // we get an nsIMsgDatabase out of this (unsurprisingly) which</span>
<a href="#l3.272"></a><span id="l3.272">       //  explicitly inherits from nsIDBChangeAnnouncer, which has the</span>
<a href="#l3.273"></a><span id="l3.273">       //  AddListener call we want.</span>
<a href="#l3.274"></a><span id="l3.274" class="difflineminus">-      this._indexingDatabase = folder.getMsgDatabase(null);</span>
<a href="#l3.275"></a><span id="l3.275" class="difflineplus">+      if (this._indexingDatabase == null)</span>
<a href="#l3.276"></a><span id="l3.276" class="difflineplus">+        this._indexingDatabase = folder.getMsgDatabase(null);</span>
<a href="#l3.277"></a><span id="l3.277">       if (aNeedIterator)</span>
<a href="#l3.278"></a><span id="l3.278">         this._indexingIterator = fixIterator(</span>
<a href="#l3.279"></a><span id="l3.279" class="difflineminus">-                                   //folder.getMessages(null),</span>
<a href="#l3.280"></a><span id="l3.280">                                    this._indexingDatabase.EnumerateMessages(),</span>
<a href="#l3.281"></a><span id="l3.281">                                    Ci.nsIMsgDBHdr);</span>
<a href="#l3.282"></a><span id="l3.282" class="difflineminus">-      this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l3.283"></a><span id="l3.283">       this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l3.284"></a><span id="l3.284">     }</span>
<a href="#l3.285"></a><span id="l3.285">     catch (ex) {</span>
<a href="#l3.286"></a><span id="l3.286">       this._log.error(&quot;Problem entering folder: &quot; +</span>
<a href="#l3.287"></a><span id="l3.287">                       folder.prettiestName + &quot;, skipping.&quot;);</span>
<a href="#l3.288"></a><span id="l3.288">       this._log.error(&quot;Error was: &quot; + ex);</span>
<a href="#l3.289"></a><span id="l3.289">       this._indexingFolder = null;</span>
<a href="#l3.290"></a><span id="l3.290">       this._indexingFolderID = null;</span>
<a href="#l3.291"></a><span id="l3.291" class="difflineat">@@ -603,29 +696,39 @@ let GlodaIndexer = {</span>
<a href="#l3.292"></a><span id="l3.292">       return;</span>
<a href="#l3.293"></a><span id="l3.293">     }</span>
<a href="#l3.294"></a><span id="l3.294">     this._inCallback = true;</span>
<a href="#l3.295"></a><span id="l3.295"> </span>
<a href="#l3.296"></a><span id="l3.296">     try {</span>
<a href="#l3.297"></a><span id="l3.297">       if (this._batch === null)</span>
<a href="#l3.298"></a><span id="l3.298">         this._batch = this.workBatch();</span>
<a href="#l3.299"></a><span id="l3.299">       </span>
<a href="#l3.300"></a><span id="l3.300" class="difflineminus">-      // only kWorkAsync and kWorkDone are allowed out of our call to the batch.</span>
<a href="#l3.301"></a><span id="l3.301" class="difflineplus">+      // kWorkAsync, kWorkDone, kWorkPause are allowed out; kWorkSync is not</span>
<a href="#l3.302"></a><span id="l3.302">       // On kWorkDone, we want to schedule another timer to fire on us if we are</span>
<a href="#l3.303"></a><span id="l3.303">       //  not done indexing.  (On kWorkAsync, we don't care what happens, because</span>
<a href="#l3.304"></a><span id="l3.304">       //  someone else will be receiving the callback, and they will call us when</span>
<a href="#l3.305"></a><span id="l3.305">       //  they are done doing their thing.</span>
<a href="#l3.306"></a><span id="l3.306" class="difflineminus">-      if (this._batch.next() == kWorkDone) {</span>
<a href="#l3.307"></a><span id="l3.307" class="difflineminus">-        this._batch.close();</span>
<a href="#l3.308"></a><span id="l3.308" class="difflineminus">-        this._batch = null;</span>
<a href="#l3.309"></a><span id="l3.309" class="difflineminus">-</span>
<a href="#l3.310"></a><span id="l3.310" class="difflineminus">-        if (this.indexing)</span>
<a href="#l3.311"></a><span id="l3.311" class="difflineminus">-          this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l3.312"></a><span id="l3.312" class="difflineminus">-                                       this._indexInterval,</span>
<a href="#l3.313"></a><span id="l3.313" class="difflineminus">-                                       Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l3.314"></a><span id="l3.314" class="difflineplus">+      switch (this._batch.next()) {</span>
<a href="#l3.315"></a><span id="l3.315" class="difflineplus">+        // job's done, close the batch and re-schedule ourselves if there's more</span>
<a href="#l3.316"></a><span id="l3.316" class="difflineplus">+        //  to do.</span>
<a href="#l3.317"></a><span id="l3.317" class="difflineplus">+        case kWorkDone:</span>
<a href="#l3.318"></a><span id="l3.318" class="difflineplus">+          this._batch.close();</span>
<a href="#l3.319"></a><span id="l3.319" class="difflineplus">+          this._batch = null;</span>
<a href="#l3.320"></a><span id="l3.320" class="difflineplus">+          // (intentional fall-through to re-scheduling logic) </span>
<a href="#l3.321"></a><span id="l3.321" class="difflineplus">+        // the batch wants to get re-scheduled, do so.</span>
<a href="#l3.322"></a><span id="l3.322" class="difflineplus">+        case kWorkPause:</span>
<a href="#l3.323"></a><span id="l3.323" class="difflineplus">+          if (this.indexing)</span>
<a href="#l3.324"></a><span id="l3.324" class="difflineplus">+            this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l3.325"></a><span id="l3.325" class="difflineplus">+                                         this._indexInterval,</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineplus">+                                         Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l3.327"></a><span id="l3.327" class="difflineplus">+          break;</span>
<a href="#l3.328"></a><span id="l3.328" class="difflineplus">+        case kWorkAsync:</span>
<a href="#l3.329"></a><span id="l3.329" class="difflineplus">+          // there is nothing to do.  some other code is now responsible for</span>
<a href="#l3.330"></a><span id="l3.330" class="difflineplus">+          //  calling us.</span>
<a href="#l3.331"></a><span id="l3.331" class="difflineplus">+          break;</span>
<a href="#l3.332"></a><span id="l3.332">       }</span>
<a href="#l3.333"></a><span id="l3.333">     }</span>
<a href="#l3.334"></a><span id="l3.334">     finally {    </span>
<a href="#l3.335"></a><span id="l3.335">       this._inCallback = false;</span>
<a href="#l3.336"></a><span id="l3.336">     }</span>
<a href="#l3.337"></a><span id="l3.337">   },</span>
<a href="#l3.338"></a><span id="l3.338"> </span>
<a href="#l3.339"></a><span id="l3.339">   /**</span>
<a href="#l3.340"></a><span id="l3.340" class="difflineat">@@ -644,49 +747,61 @@ let GlodaIndexer = {</span>
<a href="#l3.341"></a><span id="l3.341">    *  _actualWorker generator which is doing the work.</span>
<a href="#l3.342"></a><span id="l3.342">    * workBatch will only produce kWorkAsync and kWorkDone notifications.</span>
<a href="#l3.343"></a><span id="l3.343">    *  If _actualWorker returns kWorkSync and there are still tokens available,</span>
<a href="#l3.344"></a><span id="l3.344">    *  workBatch will keep driving _actualWorker until it encounters a</span>
<a href="#l3.345"></a><span id="l3.345">    *  kWorkAsync (which workBatch will yield to callbackDriver), or it runs</span>
<a href="#l3.346"></a><span id="l3.346">    *  out of tokens and yields a kWorkDone. </span>
<a href="#l3.347"></a><span id="l3.347">    */</span>
<a href="#l3.348"></a><span id="l3.348">   workBatch: function gloda_index_workBatch() {</span>
<a href="#l3.349"></a><span id="l3.349" class="difflineplus">+    let commitTokens = this._indexCommitTokens;</span>
<a href="#l3.350"></a><span id="l3.350">     GlodaDatastore._beginTransaction();</span>
<a href="#l3.351"></a><span id="l3.351"> </span>
<a href="#l3.352"></a><span id="l3.352" class="difflineminus">-    for (let tokensLeft=this._indexTokens; tokensLeft &gt; 0; tokensLeft--) {</span>
<a href="#l3.353"></a><span id="l3.353" class="difflineminus">-      if ((this._actualWorker === null) &amp;&amp; !this._hireJobWorker())</span>
<a href="#l3.354"></a><span id="l3.354" class="difflineminus">-        break;</span>
<a href="#l3.355"></a><span id="l3.355" class="difflineminus">-    </span>
<a href="#l3.356"></a><span id="l3.356" class="difflineminus">-      // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l3.357"></a><span id="l3.357" class="difflineminus">-      //  with a quasi-redundant outer loop that shunts control back inside</span>
<a href="#l3.358"></a><span id="l3.358" class="difflineminus">-      //  if we left the loop due to an exception (without consuming all the</span>
<a href="#l3.359"></a><span id="l3.359" class="difflineminus">-      //  tokens.)</span>
<a href="#l3.360"></a><span id="l3.360" class="difflineminus">-      try {</span>
<a href="#l3.361"></a><span id="l3.361" class="difflineminus">-        switch (this._actualWorker.next()) {</span>
<a href="#l3.362"></a><span id="l3.362" class="difflineminus">-          case kWorkSync:</span>
<a href="#l3.363"></a><span id="l3.363" class="difflineminus">-            break;</span>
<a href="#l3.364"></a><span id="l3.364" class="difflineminus">-          case kWorkAsync:</span>
<a href="#l3.365"></a><span id="l3.365" class="difflineminus">-            yield kWorkAsync;</span>
<a href="#l3.366"></a><span id="l3.366" class="difflineminus">-            break;</span>
<a href="#l3.367"></a><span id="l3.367" class="difflineminus">-          case kWorkDone:</span>
<a href="#l3.368"></a><span id="l3.368" class="difflineplus">+    while (commitTokens &gt; 0) {</span>
<a href="#l3.369"></a><span id="l3.369" class="difflineplus">+      for (let tokensLeft=this._indexTokens; tokensLeft &gt; 0;</span>
<a href="#l3.370"></a><span id="l3.370" class="difflineplus">+          tokensLeft--, commitTokens--) {</span>
<a href="#l3.371"></a><span id="l3.371" class="difflineplus">+        if ((this._actualWorker === null) &amp;&amp; !this._hireJobWorker()) {</span>
<a href="#l3.372"></a><span id="l3.372" class="difflineplus">+          commitTokens = 0;</span>
<a href="#l3.373"></a><span id="l3.373" class="difflineplus">+          break;</span>
<a href="#l3.374"></a><span id="l3.374" class="difflineplus">+        }</span>
<a href="#l3.375"></a><span id="l3.375" class="difflineplus">+      </span>
<a href="#l3.376"></a><span id="l3.376" class="difflineplus">+        // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l3.377"></a><span id="l3.377" class="difflineplus">+        //  with a quasi-redundant outer loop that shunts control back inside</span>
<a href="#l3.378"></a><span id="l3.378" class="difflineplus">+        //  if we left the loop due to an exception (without consuming all the</span>
<a href="#l3.379"></a><span id="l3.379" class="difflineplus">+        //  tokens.)</span>
<a href="#l3.380"></a><span id="l3.380" class="difflineplus">+        try {</span>
<a href="#l3.381"></a><span id="l3.381" class="difflineplus">+          switch (this._actualWorker.next()) {</span>
<a href="#l3.382"></a><span id="l3.382" class="difflineplus">+            case kWorkSync:</span>
<a href="#l3.383"></a><span id="l3.383" class="difflineplus">+              break;</span>
<a href="#l3.384"></a><span id="l3.384" class="difflineplus">+            case kWorkAsync:</span>
<a href="#l3.385"></a><span id="l3.385" class="difflineplus">+              commit</span>
<a href="#l3.386"></a><span id="l3.386" class="difflineplus">+              yield kWorkAsync;</span>
<a href="#l3.387"></a><span id="l3.387" class="difflineplus">+              break;</span>
<a href="#l3.388"></a><span id="l3.388" class="difflineplus">+            case kWorkDone:</span>
<a href="#l3.389"></a><span id="l3.389" class="difflineplus">+              this._actualWorker.close();</span>
<a href="#l3.390"></a><span id="l3.390" class="difflineplus">+              this._actualWorker = null;</span>
<a href="#l3.391"></a><span id="l3.391" class="difflineplus">+              break;</span>
<a href="#l3.392"></a><span id="l3.392" class="difflineplus">+          }</span>
<a href="#l3.393"></a><span id="l3.393" class="difflineplus">+        }</span>
<a href="#l3.394"></a><span id="l3.394" class="difflineplus">+        catch (ex) {</span>
<a href="#l3.395"></a><span id="l3.395" class="difflineplus">+          this._log.debug(&quot;Bailing on job (at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l3.396"></a><span id="l3.396" class="difflineplus">+              ex.lineNumber + &quot;) because: &quot; + ex);</span>
<a href="#l3.397"></a><span id="l3.397" class="difflineplus">+          this._indexerLeaveFolder(true);</span>
<a href="#l3.398"></a><span id="l3.398" class="difflineplus">+          this._curIndexingJob = null;</span>
<a href="#l3.399"></a><span id="l3.399" class="difflineplus">+          if (this._actualWorker !== null) {</span>
<a href="#l3.400"></a><span id="l3.400">             this._actualWorker.close();</span>
<a href="#l3.401"></a><span id="l3.401">             this._actualWorker = null;</span>
<a href="#l3.402"></a><span id="l3.402" class="difflineminus">-            break;</span>
<a href="#l3.403"></a><span id="l3.403" class="difflineplus">+          }</span>
<a href="#l3.404"></a><span id="l3.404">         }</span>
<a href="#l3.405"></a><span id="l3.405">       }</span>
<a href="#l3.406"></a><span id="l3.406" class="difflineminus">-      catch (ex) {</span>
<a href="#l3.407"></a><span id="l3.407" class="difflineminus">-        this._log.debug(&quot;Bailing on job (at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l3.408"></a><span id="l3.408" class="difflineminus">-            ex.lineNumber + &quot;) because: &quot; + ex);</span>
<a href="#l3.409"></a><span id="l3.409" class="difflineminus">-        this._indexerLeaveFolder(true);</span>
<a href="#l3.410"></a><span id="l3.410" class="difflineminus">-        this._curIndexingJob = null;</span>
<a href="#l3.411"></a><span id="l3.411" class="difflineminus">-        if (this._actualWorker !== null) {</span>
<a href="#l3.412"></a><span id="l3.412" class="difflineminus">-          this._actualWorker.close();</span>
<a href="#l3.413"></a><span id="l3.413" class="difflineminus">-          this._actualWorker = null;</span>
<a href="#l3.414"></a><span id="l3.414" class="difflineminus">-        }</span>
<a href="#l3.415"></a><span id="l3.415" class="difflineminus">-      }</span>
<a href="#l3.416"></a><span id="l3.416" class="difflineplus">+      </span>
<a href="#l3.417"></a><span id="l3.417" class="difflineplus">+      // take a breather by having the caller re-schedule us sometime in the</span>
<a href="#l3.418"></a><span id="l3.418" class="difflineplus">+      //  future, but only if we're going to perform another loop iteration.</span>
<a href="#l3.419"></a><span id="l3.419" class="difflineplus">+      if (commitTokens &gt; 0)</span>
<a href="#l3.420"></a><span id="l3.420" class="difflineplus">+        yield kWorkPause;</span>
<a href="#l3.421"></a><span id="l3.421">     }</span>
<a href="#l3.422"></a><span id="l3.422">     // XXX doing the dirty commit/check every time could be pretty expensive...</span>
<a href="#l3.423"></a><span id="l3.423">     GlodaCollectionManager.cacheCommitDirty();</span>
<a href="#l3.424"></a><span id="l3.424">     GlodaDatastore._commitTransaction();</span>
<a href="#l3.425"></a><span id="l3.425">     </span>
<a href="#l3.426"></a><span id="l3.426">     // try and get a job if we don't have one for the sake of the notification</span>
<a href="#l3.427"></a><span id="l3.427">     if (this.indexing &amp;&amp; (this._actualWorker === null))</span>
<a href="#l3.428"></a><span id="l3.428">       this._hireJobWorker();</span>
<a href="#l3.429"></a><span id="l3.429" class="difflineat">@@ -720,55 +835,80 @@ let GlodaIndexer = {</span>
<a href="#l3.430"></a><span id="l3.430">     this._indexingJobCount++;</span>
<a href="#l3.431"></a><span id="l3.431">     this._log.debug(&quot;Pulled job: &quot; + job.jobType + &quot;, &quot; +</span>
<a href="#l3.432"></a><span id="l3.432">                     job.deltaType + &quot;, &quot; + job.id);</span>
<a href="#l3.433"></a><span id="l3.433">     let generator = null;</span>
<a href="#l3.434"></a><span id="l3.434">     </span>
<a href="#l3.435"></a><span id="l3.435">     if (job.jobType == &quot;folder&quot;) {</span>
<a href="#l3.436"></a><span id="l3.436">       if (job.deltaType &gt; 0)</span>
<a href="#l3.437"></a><span id="l3.437">         this._actualWorker = this._worker_folderAdd(job);</span>
<a href="#l3.438"></a><span id="l3.438" class="difflineminus">-      else if (job.deltaType &lt; 0)</span>
<a href="#l3.439"></a><span id="l3.439" class="difflineminus">-        this._actualWorker = this._worker_folderDelete(job);</span>
<a href="#l3.440"></a><span id="l3.440">     }</span>
<a href="#l3.441"></a><span id="l3.441">     else if(job.jobType == &quot;message&quot;) {</span>
<a href="#l3.442"></a><span id="l3.442">       if (job === this._pendingAddJob)</span>
<a href="#l3.443"></a><span id="l3.443">                   this._pendingAddJob = null;</span>
<a href="#l3.444"></a><span id="l3.444">       // update our goal from the items length</span>
<a href="#l3.445"></a><span id="l3.445">       job.goal = job.items.length;</span>
<a href="#l3.446"></a><span id="l3.446">                   </span>
<a href="#l3.447"></a><span id="l3.447">       if (job.deltaType &gt; 0)</span>
<a href="#l3.448"></a><span id="l3.448" class="difflineminus">-        this._actualWorker = this._worker_messageAdd(job);</span>
<a href="#l3.449"></a><span id="l3.449" class="difflineplus">+        this._actualWorker = this._worker_messageIndex(job);</span>
<a href="#l3.450"></a><span id="l3.450">       else if (job.deltaType == 0)</span>
<a href="#l3.451"></a><span id="l3.451">         this._actualWorker = this._worker_messageMove(job);</span>
<a href="#l3.452"></a><span id="l3.452" class="difflineminus">-      else</span>
<a href="#l3.453"></a><span id="l3.453" class="difflineminus">-        this._actualWorker = this._worker_messageDelete(job);</span>
<a href="#l3.454"></a><span id="l3.454">     }</span>
<a href="#l3.455"></a><span id="l3.455">     </span>
<a href="#l3.456"></a><span id="l3.456">     return true;</span>
<a href="#l3.457"></a><span id="l3.457">   },</span>
<a href="#l3.458"></a><span id="l3.458"> </span>
<a href="#l3.459"></a><span id="l3.459" class="difflineminus">-  _worker_folderAdd: function (aJob) {</span>
<a href="#l3.460"></a><span id="l3.460" class="difflineplus">+  _worker_folderIndex: function gloda_worker_folderAdd(aJob) {</span>
<a href="#l3.461"></a><span id="l3.461">     yield this._indexerEnterFolder(aJob.id, true);</span>
<a href="#l3.462"></a><span id="l3.462">     aJob.goal = this._indexingFolder.getTotalMessages(false);</span>
<a href="#l3.463"></a><span id="l3.463">     </span>
<a href="#l3.464"></a><span id="l3.464" class="difflineplus">+    // there is of course a cost to all this header investigation even if we</span>
<a href="#l3.465"></a><span id="l3.465" class="difflineplus">+    //  don't do something.  so we will yield with kWorkSync for every block. </span>
<a href="#l3.466"></a><span id="l3.466" class="difflineplus">+    const HEADER_CHECK_BLOCK_SIZE = 100;</span>
<a href="#l3.467"></a><span id="l3.467" class="difflineplus">+    </span>
<a href="#l3.468"></a><span id="l3.468" class="difflineplus">+    let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l3.469"></a><span id="l3.469" class="difflineplus">+    // we can safely presume if we are here that this folder has been selected</span>
<a href="#l3.470"></a><span id="l3.470" class="difflineplus">+    //  for offline processing...</span>
<a href="#l3.471"></a><span id="l3.471" class="difflineplus">+    </span>
<a href="#l3.472"></a><span id="l3.472">     for (let msgHdr in this._indexingIterator) {</span>
<a href="#l3.473"></a><span id="l3.473" class="difflineminus">-      aJob.offset++;</span>
<a href="#l3.474"></a><span id="l3.474" class="difflineminus">-      yield this._indexMessage(msgHdr);</span>
<a href="#l3.475"></a><span id="l3.475" class="difflineplus">+      // per above, we want to periodically release control while doing all</span>
<a href="#l3.476"></a><span id="l3.476" class="difflineplus">+      //  this header traversal/investigation.</span>
<a href="#l3.477"></a><span id="l3.477" class="difflineplus">+      if (aJob.offset++ % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l3.478"></a><span id="l3.478" class="difflineplus">+        yield kWorkSync;</span>
<a href="#l3.479"></a><span id="l3.479" class="difflineplus">+      </span>
<a href="#l3.480"></a><span id="l3.480" class="difflineplus">+      if (isLocal || msgHdr.flags&amp;MSG_FLAG_OFFLINE) {</span>
<a href="#l3.481"></a><span id="l3.481" class="difflineplus">+        let glodaMessageId = null;</span>
<a href="#l3.482"></a><span id="l3.482" class="difflineplus">+        try {</span>
<a href="#l3.483"></a><span id="l3.483" class="difflineplus">+          glodaMessageId = msgHdr.getUint32Property(</span>
<a href="#l3.484"></a><span id="l3.484" class="difflineplus">+                             this.GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l3.485"></a><span id="l3.485" class="difflineplus">+        }</span>
<a href="#l3.486"></a><span id="l3.486" class="difflineplus">+        catch(ex) {}</span>
<a href="#l3.487"></a><span id="l3.487" class="difflineplus">+        </span>
<a href="#l3.488"></a><span id="l3.488" class="difflineplus">+        // if it has a gloda message id, it has been indexed, but it still</span>
<a href="#l3.489"></a><span id="l3.489" class="difflineplus">+        //  could be dirty.</span>
<a href="#l3.490"></a><span id="l3.490" class="difflineplus">+        if (glodaMessageId != null) {</span>
<a href="#l3.491"></a><span id="l3.491" class="difflineplus">+          let isDirty = false;</span>
<a href="#l3.492"></a><span id="l3.492" class="difflineplus">+          try {</span>
<a href="#l3.493"></a><span id="l3.493" class="difflineplus">+            isDirty = (msgHdr.getUint32Property(this.GLODA_DIRTY_PROPERTY) != 0;</span>
<a href="#l3.494"></a><span id="l3.494" class="difflineplus">+          }</span>
<a href="#l3.495"></a><span id="l3.495" class="difflineplus">+          catch(ex) {}</span>
<a href="#l3.496"></a><span id="l3.496" class="difflineplus">+          </span>
<a href="#l3.497"></a><span id="l3.497" class="difflineplus">+          // it's up to date if it's not dirty </span>
<a href="#l3.498"></a><span id="l3.498" class="difflineplus">+          if (!isDirty)</span>
<a href="#l3.499"></a><span id="l3.499" class="difflineplus">+            continue;</span>
<a href="#l3.500"></a><span id="l3.500" class="difflineplus">+        }</span>
<a href="#l3.501"></a><span id="l3.501" class="difflineplus">+        </span>
<a href="#l3.502"></a><span id="l3.502" class="difflineplus">+        yield this._indexMessage(msgHdr);</span>
<a href="#l3.503"></a><span id="l3.503" class="difflineplus">+      }</span>
<a href="#l3.504"></a><span id="l3.504">     }</span>
<a href="#l3.505"></a><span id="l3.505">     </span>
<a href="#l3.506"></a><span id="l3.506">     yield kWorkDone;</span>
<a href="#l3.507"></a><span id="l3.507">   },</span>
<a href="#l3.508"></a><span id="l3.508">   </span>
<a href="#l3.509"></a><span id="l3.509" class="difflineminus">-  _worker_folderDelete: function (aJob) {</span>
<a href="#l3.510"></a><span id="l3.510" class="difflineminus">-    // nuke the folder id</span>
<a href="#l3.511"></a><span id="l3.511" class="difflineminus">-    this._datastore.deleteFolderByID(aJob.id);</span>
<a href="#l3.512"></a><span id="l3.512" class="difflineminus">-    yield kWorkDone;</span>
<a href="#l3.513"></a><span id="l3.513" class="difflineminus">-  },</span>
<a href="#l3.514"></a><span id="l3.514" class="difflineminus">-  </span>
<a href="#l3.515"></a><span id="l3.515" class="difflineminus">-  _worker_messageAdd: function (aJob) {</span>
<a href="#l3.516"></a><span id="l3.516" class="difflineplus">+  _worker_messageIndex: function gloda_worker_messageAdd(aJob) {</span>
<a href="#l3.517"></a><span id="l3.517">     for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l3.518"></a><span id="l3.518">       let item = aJob.items[aJob.offset];</span>
<a href="#l3.519"></a><span id="l3.519">       // item is either [folder ID, message key] or</span>
<a href="#l3.520"></a><span id="l3.520">       //                [folder ID, message ID]</span>
<a href="#l3.521"></a><span id="l3.521"> </span>
<a href="#l3.522"></a><span id="l3.522">       // get in the folder</span>
<a href="#l3.523"></a><span id="l3.523">       if (this._indexingFolderID != item[0])</span>
<a href="#l3.524"></a><span id="l3.524">         yield this._indexerEnterFolder(item[0], false);</span>
<a href="#l3.525"></a><span id="l3.525" class="difflineat">@@ -784,17 +924,17 @@ let GlodaIndexer = {</span>
<a href="#l3.526"></a><span id="l3.526">       if (msgHdr)</span>
<a href="#l3.527"></a><span id="l3.527">         yield this._indexMessage(msgHdr);</span>
<a href="#l3.528"></a><span id="l3.528">       else</span>
<a href="#l3.529"></a><span id="l3.529">         yield kWorkSync;</span>
<a href="#l3.530"></a><span id="l3.530">     }</span>
<a href="#l3.531"></a><span id="l3.531">     yield kWorkDone;</span>
<a href="#l3.532"></a><span id="l3.532">   },</span>
<a href="#l3.533"></a><span id="l3.533">   </span>
<a href="#l3.534"></a><span id="l3.534" class="difflineminus">-  _worker_messageMove: function (aJob) {</span>
<a href="#l3.535"></a><span id="l3.535" class="difflineplus">+  _worker_messageMove: function gloda_worker_messageMove(aJob) {</span>
<a href="#l3.536"></a><span id="l3.536">     for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l3.537"></a><span id="l3.537">       let item = aJob.items[aJob.offset];</span>
<a href="#l3.538"></a><span id="l3.538">       // item must be [folder ID, header message-id]</span>
<a href="#l3.539"></a><span id="l3.539">       </span>
<a href="#l3.540"></a><span id="l3.540">       if (this._indexingFolderID != item[0])</span>
<a href="#l3.541"></a><span id="l3.541">         yield this._indexerEnterFolder(item[0], false);</span>
<a href="#l3.542"></a><span id="l3.542">       </span>
<a href="#l3.543"></a><span id="l3.543">       // process everyone with the message-id.  yeck.</span>
<a href="#l3.544"></a><span id="l3.544" class="difflineat">@@ -809,47 +949,16 @@ let GlodaIndexer = {</span>
<a href="#l3.545"></a><span id="l3.545">           &quot;message-id &quot; + item[1] + &quot;. Folder is known to possess &quot; +</span>
<a href="#l3.546"></a><span id="l3.546">           this._indexingFolder.getTotalMessages(false) +&quot; messages.&quot;);</span>
<a href="#l3.547"></a><span id="l3.547">         yield kWorkSync;</span>
<a href="#l3.548"></a><span id="l3.548">       }</span>
<a href="#l3.549"></a><span id="l3.549">     }</span>
<a href="#l3.550"></a><span id="l3.550">     </span>
<a href="#l3.551"></a><span id="l3.551">     yield kWorkDone;</span>
<a href="#l3.552"></a><span id="l3.552">   },</span>
<a href="#l3.553"></a><span id="l3.553" class="difflineminus">-  </span>
<a href="#l3.554"></a><span id="l3.554" class="difflineminus">-  /**</span>
<a href="#l3.555"></a><span id="l3.555" class="difflineminus">-   * Handle the destruction (not just moved to trash) of one or more messages.</span>
<a href="#l3.556"></a><span id="l3.556" class="difflineminus">-   */</span>
<a href="#l3.557"></a><span id="l3.557" class="difflineminus">-  _worker_messageDelete: function (aJob) {</span>
<a href="#l3.558"></a><span id="l3.558" class="difflineminus">-    for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l3.559"></a><span id="l3.559" class="difflineminus">-      let item = aJob.items[aJob.offset];</span>
<a href="#l3.560"></a><span id="l3.560" class="difflineminus">-</span>
<a href="#l3.561"></a><span id="l3.561" class="difflineminus">-      // item is either: a message id</span>
<a href="#l3.562"></a><span id="l3.562" class="difflineminus">-      //              or [folder ID, message key]</span>
<a href="#l3.563"></a><span id="l3.563" class="difflineminus">-      // we need to load the actual message because deletion may need to cascade</span>
<a href="#l3.564"></a><span id="l3.564" class="difflineminus">-      //  to other tables, which requires us to actually have all of the details</span>
<a href="#l3.565"></a><span id="l3.565" class="difflineminus">-      //  on the message available to us.</span>
<a href="#l3.566"></a><span id="l3.566" class="difflineminus">-      let message;</span>
<a href="#l3.567"></a><span id="l3.567" class="difflineminus">-      if (item instanceof Array) {</span>
<a href="#l3.568"></a><span id="l3.568" class="difflineminus">-        if (this._indexingFolderID != item[0])</span>
<a href="#l3.569"></a><span id="l3.569" class="difflineminus">-          yield this._indexerEnterFolder(item[0], false);</span>
<a href="#l3.570"></a><span id="l3.570" class="difflineminus">-        let msgHdr = this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l3.571"></a><span id="l3.571" class="difflineminus">-        message = GlodaDatastore.getMessageFromLocation(msgHdr.folder.URI,</span>
<a href="#l3.572"></a><span id="l3.572" class="difflineminus">-                                                        msgHdr.messageKey);</span>
<a href="#l3.573"></a><span id="l3.573" class="difflineminus">-      }</span>
<a href="#l3.574"></a><span id="l3.574" class="difflineminus">-      else</span>
<a href="#l3.575"></a><span id="l3.575" class="difflineminus">-        message = GlodaDatastore.getMessageByID(item);</span>
<a href="#l3.576"></a><span id="l3.576" class="difflineminus">-</span>
<a href="#l3.577"></a><span id="l3.577" class="difflineminus">-      // delete the message!</span>
<a href="#l3.578"></a><span id="l3.578" class="difflineminus">-      if (message !== null)</span>
<a href="#l3.579"></a><span id="l3.579" class="difflineminus">-        this._deleteMessage(message);</span>
<a href="#l3.580"></a><span id="l3.580" class="difflineminus">-      yield kWorkSync;</span>
<a href="#l3.581"></a><span id="l3.581" class="difflineminus">-    }</span>
<a href="#l3.582"></a><span id="l3.582" class="difflineminus">-    yield kWorkDone;</span>
<a href="#l3.583"></a><span id="l3.583" class="difflineminus">-  },</span>
<a href="#l3.584"></a><span id="l3.584"> </span>
<a href="#l3.585"></a><span id="l3.585">   /**</span>
<a href="#l3.586"></a><span id="l3.586">    * Queue all of the folders of all of the accounts of the current profile</span>
<a href="#l3.587"></a><span id="l3.587">    *  for indexing.  We traverse all folders and queue them immediately to try</span>
<a href="#l3.588"></a><span id="l3.588">    *  and have an accurate estimate of the number of folders that need to be</span>
<a href="#l3.589"></a><span id="l3.589">    *  indexed.  (We previously queued accounts rather than immediately</span>
<a href="#l3.590"></a><span id="l3.590">    *  walking their list of folders.)</span>
<a href="#l3.591"></a><span id="l3.591">    */</span>
<a href="#l3.592"></a><span id="l3.592" class="difflineat">@@ -926,17 +1035,22 @@ let GlodaIndexer = {</span>
<a href="#l3.593"></a><span id="l3.593">                  (fm in aFoldersAndMessages)];</span>
<a href="#l3.594"></a><span id="l3.594">     this._indexQueue.push(job);</span>
<a href="#l3.595"></a><span id="l3.595">     this._indexingJobGoal++;</span>
<a href="#l3.596"></a><span id="l3.596">     this.indexing = true;</span>
<a href="#l3.597"></a><span id="l3.597">   },</span>
<a href="#l3.598"></a><span id="l3.598">   </span>
<a href="#l3.599"></a><span id="l3.599">   /* *********** Event Processing *********** */</span>
<a href="#l3.600"></a><span id="l3.600">   observe: function gloda_indexer_observe(aSubject, aTopic, aData) {</span>
<a href="#l3.601"></a><span id="l3.601" class="difflineminus">-    if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l3.602"></a><span id="l3.602" class="difflineplus">+    if (aTopic == &quot;idle&quot;) {</span>
<a href="#l3.603"></a><span id="l3.603" class="difflineplus">+      </span>
<a href="#l3.604"></a><span id="l3.604" class="difflineplus">+    }</span>
<a href="#l3.605"></a><span id="l3.605" class="difflineplus">+    else if (aTopic == &quot;back&quot;) {</span>
<a href="#l3.606"></a><span id="l3.606" class="difflineplus">+    }</span>
<a href="#l3.607"></a><span id="l3.607" class="difflineplus">+    else if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l3.608"></a><span id="l3.608">       GlodaIndexer._shutdown();</span>
<a href="#l3.609"></a><span id="l3.609">     }</span>
<a href="#l3.610"></a><span id="l3.610">   },</span>
<a href="#l3.611"></a><span id="l3.611"> </span>
<a href="#l3.612"></a><span id="l3.612">   /* ***** Folder Changes ***** */  </span>
<a href="#l3.613"></a><span id="l3.613">   /**</span>
<a href="#l3.614"></a><span id="l3.614">    * All additions and removals are queued for processing.  Indexing messages</span>
<a href="#l3.615"></a><span id="l3.615">    *  is potentially phenomenally expensive, and deletion can still be</span>
<a href="#l3.616"></a><span id="l3.616" class="difflineat">@@ -981,32 +1095,38 @@ let GlodaIndexer = {</span>
<a href="#l3.617"></a><span id="l3.617">     },</span>
<a href="#l3.618"></a><span id="l3.618">     </span>
<a href="#l3.619"></a><span id="l3.619">     /**</span>
<a href="#l3.620"></a><span id="l3.620">      * Handle real, actual deletion (move to trash and IMAP deletion model</span>
<a href="#l3.621"></a><span id="l3.621">      *  don't count; we only see the deletion here when it becomes forever,</span>
<a href="#l3.622"></a><span id="l3.622">      *  or rather _just before_ it becomes forever.  Because the header is</span>
<a href="#l3.623"></a><span id="l3.623">      *  going away, we need to either process things immediately or extract the</span>
<a href="#l3.624"></a><span id="l3.624">      *  information required to purge it later without the header.</span>
<a href="#l3.625"></a><span id="l3.625" class="difflineminus">-     *</span>
<a href="#l3.626"></a><span id="l3.626" class="difflineminus">-     * We opt to process all of the headers immediately, inside a transaction.</span>
<a href="#l3.627"></a><span id="l3.627" class="difflineminus">-     *  We do this because deletions may actually be a batch deletion of many,</span>
<a href="#l3.628"></a><span id="l3.628" class="difflineminus">-     *  many messages, which could be a lot to queue</span>
<a href="#l3.629"></a><span id="l3.629" class="difflineplus">+     * To this end, we mark all messages that were indexed in the gloda message</span>
<a href="#l3.630"></a><span id="l3.630" class="difflineplus">+     *  database as deleted.  We set our pending </span>
<a href="#l3.631"></a><span id="l3.631">      */</span>
<a href="#l3.632"></a><span id="l3.632">     msgsDeleted: function gloda_indexer_msgsDeleted(aMsgHdrs) {</span>
<a href="#l3.633"></a><span id="l3.633">       this.indexer._log.debug(&quot;msgsDeleted notification&quot;);</span>
<a href="#l3.634"></a><span id="l3.634" class="difflineplus">+      </span>
<a href="#l3.635"></a><span id="l3.635" class="difflineplus">+      let glodaMessageIds = [];</span>
<a href="#l3.636"></a><span id="l3.636" class="difflineplus">+      </span>
<a href="#l3.637"></a><span id="l3.637">       let deleteJob = new IndexingJob(&quot;message&quot;, -1, null);</span>
<a href="#l3.638"></a><span id="l3.638">       for (let iMsgHdr=0; iMsgHdr &lt; aMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l3.639"></a><span id="l3.639">         let msgHdr = aMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l3.640"></a><span id="l3.640" class="difflineminus">-        deleteJob.items.push([GlodaDatastore._mapFolderURI(msgHdr.folder.URI),</span>
<a href="#l3.641"></a><span id="l3.641" class="difflineminus">-                              msgHdr.messageKey]);</span>
<a href="#l3.642"></a><span id="l3.642" class="difflineplus">+        try {</span>
<a href="#l3.643"></a><span id="l3.643" class="difflineplus">+          glodaMessageIds.push(msgHdr.getUint32Property(</span>
<a href="#l3.644"></a><span id="l3.644" class="difflineplus">+            this.GLODA_MESSAGE_ID_PROPERTY));</span>
<a href="#l3.645"></a><span id="l3.645" class="difflineplus">+        }</span>
<a href="#l3.646"></a><span id="l3.646" class="difflineplus">+        catch (ex) {}</span>
<a href="#l3.647"></a><span id="l3.647">       }</span>
<a href="#l3.648"></a><span id="l3.648" class="difflineminus">-      this.indexer._indexQueue.push(deleteJob);</span>
<a href="#l3.649"></a><span id="l3.649" class="difflineminus">-      this.indexer._indexingJobGoal++;</span>
<a href="#l3.650"></a><span id="l3.650" class="difflineminus">-      this.indexer.indexing = true;</span>
<a href="#l3.651"></a><span id="l3.651" class="difflineplus">+      </span>
<a href="#l3.652"></a><span id="l3.652" class="difflineplus">+      if (glodaMessageIds.length) {</span>
<a href="#l3.653"></a><span id="l3.653" class="difflineplus">+        this._datastore.markMessagesDeletedByIDs(glodaMessageIds);</span>
<a href="#l3.654"></a><span id="l3.654" class="difflineplus">+        this.indexer.pendingDeletions = true;</span>
<a href="#l3.655"></a><span id="l3.655" class="difflineplus">+      }</span>
<a href="#l3.656"></a><span id="l3.656">     },</span>
<a href="#l3.657"></a><span id="l3.657">     </span>
<a href="#l3.658"></a><span id="l3.658">     /**</span>
<a href="#l3.659"></a><span id="l3.659">      * Process a move or copy.  Copies are treated as additions and accordingly</span>
<a href="#l3.660"></a><span id="l3.660">      *  queued for subsequent indexing.  Moves are annoying in that, in theory,</span>
<a href="#l3.661"></a><span id="l3.661">      *  we should be able to just alter the location information and be done</span>
<a href="#l3.662"></a><span id="l3.662">      *  with it.  Unfortunately, we have no clue what the messageKey is for</span>
<a href="#l3.663"></a><span id="l3.663">      *  the moved message until we go looking.  For now, we &quot;simply&quot; move the</span>
<a href="#l3.664"></a><span id="l3.664" class="difflineat">@@ -1018,119 +1138,154 @@ let GlodaIndexer = {</span>
<a href="#l3.665"></a><span id="l3.665">      *     messages when possible.  (In fact, the _indexMessage method basically</span>
<a href="#l3.666"></a><span id="l3.666">      *     has enough information to try and give this a whirl, but it's not</span>
<a href="#l3.667"></a><span id="l3.667">      *     foolproof, hence not done and this issue yet to-do.  </span>
<a href="#l3.668"></a><span id="l3.668">      */</span>
<a href="#l3.669"></a><span id="l3.669">     msgsMoveCopyCompleted: function gloda_indexer_msgsMoveCopyCompleted(aMove,</span>
<a href="#l3.670"></a><span id="l3.670">                              aSrcMsgHdrs, aDestFolder) {</span>
<a href="#l3.671"></a><span id="l3.671">       this.indexer._log.debug(&quot;MoveCopy notification.  Move: &quot; + aMove);</span>
<a href="#l3.672"></a><span id="l3.672">       try {</span>
<a href="#l3.673"></a><span id="l3.673" class="difflineminus">-      if (aMove) {</span>
<a href="#l3.674"></a><span id="l3.674" class="difflineminus">-        let srcFolder = aSrcMsgHdrs.queryElementAt(0, Ci.nsIMsgDBHdr).folder;</span>
<a href="#l3.675"></a><span id="l3.675" class="difflineminus">-        let messageKeys = [];</span>
<a href="#l3.676"></a><span id="l3.676" class="difflineminus">-</span>
<a href="#l3.677"></a><span id="l3.677" class="difflineminus">-        let reindexJob = new IndexingJob(&quot;message&quot;, 0, null);</span>
<a href="#l3.678"></a><span id="l3.678" class="difflineminus">-</span>
<a href="#l3.679"></a><span id="l3.679" class="difflineminus">-        // get the current (about to be nulled) messageKeys and build the</span>
<a href="#l3.680"></a><span id="l3.680" class="difflineminus">-        //  job list too.</span>
<a href="#l3.681"></a><span id="l3.681" class="difflineminus">-        for (let iSrcMsgHdr=0; iSrcMsgHdr &lt; aSrcMsgHdrs.length; iSrcMsgHdr++) {</span>
<a href="#l3.682"></a><span id="l3.682" class="difflineminus">-          let msgHdr = aSrcMsgHdrs.queryElementAt(iSrcMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l3.683"></a><span id="l3.683" class="difflineminus">-          messageKeys.push(msgHdr.messageKey);</span>
<a href="#l3.684"></a><span id="l3.684" class="difflineminus">-          reindexJob.items.push(</span>
<a href="#l3.685"></a><span id="l3.685" class="difflineminus">-            [GlodaDatastore._mapFolderURI(aDestFolder.URI),</span>
<a href="#l3.686"></a><span id="l3.686" class="difflineminus">-             msgHdr.messageId]);</span>
<a href="#l3.687"></a><span id="l3.687" class="difflineplus">+        if (aMove) {</span>
<a href="#l3.688"></a><span id="l3.688" class="difflineplus">+          let srcFolder = aSrcMsgHdrs.queryElementAt(0, Ci.nsIMsgDBHdr).folder;</span>
<a href="#l3.689"></a><span id="l3.689" class="difflineplus">+          let messageKeys = [];</span>
<a href="#l3.690"></a><span id="l3.690" class="difflineplus">+  </span>
<a href="#l3.691"></a><span id="l3.691" class="difflineplus">+          let reindexJob = new IndexingJob(&quot;message&quot;, 0, null);</span>
<a href="#l3.692"></a><span id="l3.692" class="difflineplus">+  </span>
<a href="#l3.693"></a><span id="l3.693" class="difflineplus">+          // get the current (about to be nulled) messageKeys and build the</span>
<a href="#l3.694"></a><span id="l3.694" class="difflineplus">+          //  job list too.</span>
<a href="#l3.695"></a><span id="l3.695" class="difflineplus">+          for (let iSrcMsgHdr=0; iSrcMsgHdr &lt; aSrcMsgHdrs.length; iSrcMsgHdr++) {</span>
<a href="#l3.696"></a><span id="l3.696" class="difflineplus">+            let msgHdr = aSrcMsgHdrs.queryElementAt(iSrcMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l3.697"></a><span id="l3.697" class="difflineplus">+            messageKeys.push(msgHdr.messageKey);</span>
<a href="#l3.698"></a><span id="l3.698" class="difflineplus">+            reindexJob.items.push(</span>
<a href="#l3.699"></a><span id="l3.699" class="difflineplus">+              [GlodaDatastore._mapFolderURI(aDestFolder.URI),</span>
<a href="#l3.700"></a><span id="l3.700" class="difflineplus">+               msgHdr.messageId]);</span>
<a href="#l3.701"></a><span id="l3.701" class="difflineplus">+          }</span>
<a href="#l3.702"></a><span id="l3.702" class="difflineplus">+          // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l3.703"></a><span id="l3.703" class="difflineplus">+          GlodaDatastore.updateMessageFoldersByKeyPurging(srcFolder.URI,</span>
<a href="#l3.704"></a><span id="l3.704" class="difflineplus">+                                                          messageKeys,</span>
<a href="#l3.705"></a><span id="l3.705" class="difflineplus">+                                                          aDestFolder.URI);</span>
<a href="#l3.706"></a><span id="l3.706" class="difflineplus">+          // and now let us queue the re-indexings...</span>
<a href="#l3.707"></a><span id="l3.707" class="difflineplus">+          this.indexer._indexQueue.push(reindexJob);</span>
<a href="#l3.708"></a><span id="l3.708" class="difflineplus">+          this.indexer.indexingJobGoal++;</span>
<a href="#l3.709"></a><span id="l3.709" class="difflineplus">+          this.indexer.indexing = true;</span>
<a href="#l3.710"></a><span id="l3.710">         }</span>
<a href="#l3.711"></a><span id="l3.711" class="difflineminus">-        // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l3.712"></a><span id="l3.712" class="difflineminus">-        GlodaDatastore.updateMessageFoldersByKeyPurging(srcFolder.URI,</span>
<a href="#l3.713"></a><span id="l3.713" class="difflineminus">-                                                        messageKeys,</span>
<a href="#l3.714"></a><span id="l3.714" class="difflineminus">-                                                        aDestFolder.URI);</span>
<a href="#l3.715"></a><span id="l3.715" class="difflineminus">-        // and now let us queue the re-indexings...</span>
<a href="#l3.716"></a><span id="l3.716" class="difflineminus">-        this.indexer._indexQueue.push(reindexJob);</span>
<a href="#l3.717"></a><span id="l3.717" class="difflineminus">-        this.indexer.indexingJobGoal++;</span>
<a href="#l3.718"></a><span id="l3.718" class="difflineminus">-        this.indexer.indexing = true;</span>
<a href="#l3.719"></a><span id="l3.719" class="difflineplus">+        else {</span>
<a href="#l3.720"></a><span id="l3.720" class="difflineplus">+          let copyIndexJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l3.721"></a><span id="l3.721" class="difflineplus">+  </span>
<a href="#l3.722"></a><span id="l3.722" class="difflineplus">+          for (let iSrcMsgHdr=0; iSrcMsgHdr &lt; aSrcMsgHdrs.length; iSrcMsgHdr++) {</span>
<a href="#l3.723"></a><span id="l3.723" class="difflineplus">+            let msgHdr = aSrcMsgHdrs.queryElementAt(iSrcMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l3.724"></a><span id="l3.724" class="difflineplus">+            copyIndexJob.items.push([</span>
<a href="#l3.725"></a><span id="l3.725" class="difflineplus">+              GlodaDatastore._mapFolderURI(aDestFolder.URI),</span>
<a href="#l3.726"></a><span id="l3.726" class="difflineplus">+              msgHdr.messageId]);</span>
<a href="#l3.727"></a><span id="l3.727" class="difflineplus">+          }</span>
<a href="#l3.728"></a><span id="l3.728" class="difflineplus">+  </span>
<a href="#l3.729"></a><span id="l3.729" class="difflineplus">+          this.indexer._indexQueue.push(copyIndexJob);</span>
<a href="#l3.730"></a><span id="l3.730" class="difflineplus">+          this.indexer._indexingJobGoal++;</span>
<a href="#l3.731"></a><span id="l3.731" class="difflineplus">+          this.indexer.indexing = true;</span>
<a href="#l3.732"></a><span id="l3.732" class="difflineplus">+        }</span>
<a href="#l3.733"></a><span id="l3.733" class="difflineplus">+      } catch (ex) {</span>
<a href="#l3.734"></a><span id="l3.734" class="difflineplus">+        this.indexer._log.error(&quot;Problem encountered during message move/copy&quot; +</span>
<a href="#l3.735"></a><span id="l3.735" class="difflineplus">+          &quot;: &quot; + ex);</span>
<a href="#l3.736"></a><span id="l3.736">       }</span>
<a href="#l3.737"></a><span id="l3.737" class="difflineminus">-      else {</span>
<a href="#l3.738"></a><span id="l3.738" class="difflineminus">-        let copyIndexJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l3.739"></a><span id="l3.739" class="difflineminus">-</span>
<a href="#l3.740"></a><span id="l3.740" class="difflineminus">-        for (let iSrcMsgHdr=0; iSrcMsgHdr &lt; aSrcMsgHdrs.length; iSrcMsgHdr++) {</span>
<a href="#l3.741"></a><span id="l3.741" class="difflineminus">-          let msgHdr = aSrcMsgHdrs.queryElementAt(iSrcMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l3.742"></a><span id="l3.742" class="difflineminus">-          copyIndexJob.items.push([</span>
<a href="#l3.743"></a><span id="l3.743" class="difflineminus">-            GlodaDatastore._mapFolderURI(aDestFolder.URI),</span>
<a href="#l3.744"></a><span id="l3.744" class="difflineminus">-            msgHdr.messageId]);</span>
<a href="#l3.745"></a><span id="l3.745" class="difflineminus">-        }</span>
<a href="#l3.746"></a><span id="l3.746" class="difflineminus">-</span>
<a href="#l3.747"></a><span id="l3.747" class="difflineminus">-        this.indexer._indexQueue.push(copyIndexJob);</span>
<a href="#l3.748"></a><span id="l3.748" class="difflineminus">-        this.indexer._indexingJobGoal++;</span>
<a href="#l3.749"></a><span id="l3.749" class="difflineminus">-        this.indexer.indexing = true;</span>
<a href="#l3.750"></a><span id="l3.750" class="difflineminus">-      }</span>
<a href="#l3.751"></a><span id="l3.751" class="difflineminus">-      } catch (ex) { this.indexer._log.error(&quot;SAD SAD: &quot; + ex); }</span>
<a href="#l3.752"></a><span id="l3.752">     },</span>
<a href="#l3.753"></a><span id="l3.753">     </span>
<a href="#l3.754"></a><span id="l3.754">     /**</span>
<a href="#l3.755"></a><span id="l3.755" class="difflineminus">-     * Handles folder no-longer-exists-ence.  We want to delete all messages</span>
<a href="#l3.756"></a><span id="l3.756" class="difflineminus">-     *  located in the folder and then kill the URI/id.  To this end we create</span>
<a href="#l3.757"></a><span id="l3.757" class="difflineminus">-     *  two jobs.  One kills all the messages, and one actually deletes the</span>
<a href="#l3.758"></a><span id="l3.758" class="difflineminus">-     *  URI/id.</span>
<a href="#l3.759"></a><span id="l3.759" class="difflineplus">+     * Handles folder no-longer-exists-ence.  We mark all messages as deleted</span>
<a href="#l3.760"></a><span id="l3.760" class="difflineplus">+     *  and remove the folder from our URI table.  Currently, if a folder that</span>
<a href="#l3.761"></a><span id="l3.761" class="difflineplus">+     *  contains other folders is deleted, we may either receive one</span>
<a href="#l3.762"></a><span id="l3.762" class="difflineplus">+     *  notification for the folder that is deleted, or a notification for the</span>
<a href="#l3.763"></a><span id="l3.763" class="difflineplus">+     *  folder and one for each of its descendents.  This depends upon the</span>
<a href="#l3.764"></a><span id="l3.764" class="difflineplus">+     *  underlying account implementation, so we explicitly handle each case.</span>
<a href="#l3.765"></a><span id="l3.765" class="difflineplus">+     *  Namely, we treat it as if we're only planning on getting one, but we</span>
<a href="#l3.766"></a><span id="l3.766" class="difflineplus">+     *  handle if the children are already gone for some reason.</span>
<a href="#l3.767"></a><span id="l3.767">      */</span>
<a href="#l3.768"></a><span id="l3.768">     folderDeleted: function gloda_indexer_folderDeleted(aFolder) {</span>
<a href="#l3.769"></a><span id="l3.769">       this.indexer._log.debug(&quot;folderDeleted notification&quot;);</span>
<a href="#l3.770"></a><span id="l3.770" class="difflineminus">-      let folderID = GlodaDatastore._mapFolderURI(aFolder.URI);</span>
<a href="#l3.771"></a><span id="l3.771">       </span>
<a href="#l3.772"></a><span id="l3.772" class="difflineminus">-      let messageJob = new IndexingJob(&quot;message&quot;, -1, null);</span>
<a href="#l3.773"></a><span id="l3.773" class="difflineminus">-      messageJob.items = GlodaDatastore.getMessageIDsByFolderID(folderID);</span>
<a href="#l3.774"></a><span id="l3.774" class="difflineminus">-      if (messageJob.items.length &gt; 0)</span>
<a href="#l3.775"></a><span id="l3.775" class="difflineminus">-        this.indexer._indexQueue.push(messageJob);</span>
<a href="#l3.776"></a><span id="l3.776" class="difflineplus">+      delFunc = function(folder) {</span>
<a href="#l3.777"></a><span id="l3.777" class="difflineplus">+        let folderURI = aFolder.URI;</span>
<a href="#l3.778"></a><span id="l3.778" class="difflineplus">+        if (this._datastore._folderURIKnown(aFolder.URI)) {</span>
<a href="#l3.779"></a><span id="l3.779" class="difflineplus">+          let folderID = GlodaDatastore._mapFolderURI(aFolder.URI);</span>
<a href="#l3.780"></a><span id="l3.780" class="difflineplus">+          this._datastore.markMessagesDeletedByID(folderID);</span>
<a href="#l3.781"></a><span id="l3.781" class="difflineplus">+          this._datastore.deleteFolderByID(folderID);</span>
<a href="#l3.782"></a><span id="l3.782" class="difflineplus">+        }</span>
<a href="#l3.783"></a><span id="l3.783" class="difflineplus">+      };</span>
<a href="#l3.784"></a><span id="l3.784" class="difflineplus">+</span>
<a href="#l3.785"></a><span id="l3.785" class="difflineplus">+      let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l3.786"></a><span id="l3.786" class="difflineplus">+                                createInstance(Ci.nsISupportsArray);</span>
<a href="#l3.787"></a><span id="l3.787" class="difflineplus">+      aFolder.ListDescendents(descendentFolders);</span>
<a href="#l3.788"></a><span id="l3.788">       </span>
<a href="#l3.789"></a><span id="l3.789" class="difflineminus">-      let folderJob = new IndexingJob(&quot;folder&quot;, -1, folderID);</span>
<a href="#l3.790"></a><span id="l3.790" class="difflineminus">-      this.indexer._indexQueue.push(folderJob);</span>
<a href="#l3.791"></a><span id="l3.791" class="difflineminus">-</span>
<a href="#l3.792"></a><span id="l3.792" class="difflineminus">-      this.indexer._indexingJobGoal += 2;</span>
<a href="#l3.793"></a><span id="l3.793" class="difflineminus">-      this.indexer.indexing = true;</span>
<a href="#l3.794"></a><span id="l3.794" class="difflineplus">+      // (the order of operations does not matter; child, non-child, whatever.)</span>
<a href="#l3.795"></a><span id="l3.795" class="difflineplus">+      // delete the parent</span>
<a href="#l3.796"></a><span id="l3.796" class="difflineplus">+      delFunc(aFolder);</span>
<a href="#l3.797"></a><span id="l3.797" class="difflineplus">+      // delete all its descendents</span>
<a href="#l3.798"></a><span id="l3.798" class="difflineplus">+      for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l3.799"></a><span id="l3.799" class="difflineplus">+        delFunc(folder);</span>
<a href="#l3.800"></a><span id="l3.800" class="difflineplus">+      }</span>
<a href="#l3.801"></a><span id="l3.801" class="difflineplus">+        </span>
<a href="#l3.802"></a><span id="l3.802" class="difflineplus">+      this.pendingDeletions = true;</span>
<a href="#l3.803"></a><span id="l3.803">     },</span>
<a href="#l3.804"></a><span id="l3.804">     </span>
<a href="#l3.805"></a><span id="l3.805">     /**</span>
<a href="#l3.806"></a><span id="l3.806" class="difflineminus">-     * Handle a folder being copied.  I do not believe the MailNews code is</span>
<a href="#l3.807"></a><span id="l3.807" class="difflineminus">-     *  capable of generating a case where aMove is true, but just in case we'll</span>
<a href="#l3.808"></a><span id="l3.808" class="difflineminus">-     *  dispatch to our sibling method, folderRenamed.</span>
<a href="#l3.809"></a><span id="l3.809" class="difflineminus">-     *</span>
<a href="#l3.810"></a><span id="l3.810" class="difflineminus">-     * Folder copying is conceptually all kinds of annoying (I mean, why would</span>
<a href="#l3.811"></a><span id="l3.811" class="difflineminus">-     *  you really need to duplicate all those messages?) but is easily dealt</span>
<a href="#l3.812"></a><span id="l3.812" class="difflineminus">-     *  with by queueing the destination folder for initial indexing. </span>
<a href="#l3.813"></a><span id="l3.813" class="difflineplus">+     * Handle a folder being copied or moved.</span>
<a href="#l3.814"></a><span id="l3.814" class="difflineplus">+     * Moves are handled by a helper function shared with _folderRenameHelper</span>
<a href="#l3.815"></a><span id="l3.815" class="difflineplus">+     *  (which takes care of any nesting involved).</span>
<a href="#l3.816"></a><span id="l3.816" class="difflineplus">+     * Copies are actually ignored, because our periodic indexing traversal</span>
<a href="#l3.817"></a><span id="l3.817" class="difflineplus">+     *  should discover these automatically.  We could hint ourselves into</span>
<a href="#l3.818"></a><span id="l3.818" class="difflineplus">+     *  action, but arguably a set of completely duplicate messages is not</span>
<a href="#l3.819"></a><span id="l3.819" class="difflineplus">+     *  a high priority for indexing.</span>
<a href="#l3.820"></a><span id="l3.820">      */</span>
<a href="#l3.821"></a><span id="l3.821">     folderMoveCopyCompleted: function gloda_indexer_folderMoveCopyCompleted(</span>
<a href="#l3.822"></a><span id="l3.822">                                aMove, aSrcFolder, aDestFolder) {</span>
<a href="#l3.823"></a><span id="l3.823">       this.indexer._log.debug(&quot;folderMoveCopy notification (Move: &quot; + aMove</span>
<a href="#l3.824"></a><span id="l3.824">                               + &quot;)&quot;);</span>
<a href="#l3.825"></a><span id="l3.825">       if (aMove) {</span>
<a href="#l3.826"></a><span id="l3.826" class="difflineminus">-        // TODO handle nested folder ramifications (we don't receive events</span>
<a href="#l3.827"></a><span id="l3.827" class="difflineminus">-        //  for these, so nested folders will become wrong.)</span>
<a href="#l3.828"></a><span id="l3.828" class="difflineminus">-        let srcURI = aSrcFolder.URI;</span>
<a href="#l3.829"></a><span id="l3.829">         let targetURI = aDestFolder.URI +</span>
<a href="#l3.830"></a><span id="l3.830">                         srcURI.substring(srcURI.lastIndexOf(&quot;/&quot;));</span>
<a href="#l3.831"></a><span id="l3.831" class="difflineminus">-        this.indexer._log.debug(&quot;renaming &quot; + srcURI + &quot; to &quot; + targetURI);</span>
<a href="#l3.832"></a><span id="l3.832" class="difflineminus">-        GlodaDatastore.renameFolder(srcURI, targetURI);</span>
<a href="#l3.833"></a><span id="l3.833" class="difflineminus">-        return;</span>
<a href="#l3.834"></a><span id="l3.834" class="difflineplus">+        return this._folderRenameHelper(aSrcFolder, targetURI);</span>
<a href="#l3.835"></a><span id="l3.835">       }</span>
<a href="#l3.836"></a><span id="l3.836" class="difflineminus">-      this.indexer._indexingFolderGoal++;</span>
<a href="#l3.837"></a><span id="l3.837" class="difflineminus">-      this.indexer._indexQueue.push([&quot;folder&quot;, 1,</span>
<a href="#l3.838"></a><span id="l3.838" class="difflineminus">-        GlodaDatastore._mapFolderURI(aDestFolder.URI)]);</span>
<a href="#l3.839"></a><span id="l3.839" class="difflineminus">-      this.indexer.indexing = true;</span>
<a href="#l3.840"></a><span id="l3.840">     },</span>
<a href="#l3.841"></a><span id="l3.841">     </span>
<a href="#l3.842"></a><span id="l3.842">     /**</span>
<a href="#l3.843"></a><span id="l3.843">      * We just need to update the URI &lt;-&gt; ID maps and the row in the database,</span>
<a href="#l3.844"></a><span id="l3.844">      *  all of which is actually done by the datastore for us.</span>
<a href="#l3.845"></a><span id="l3.845" class="difflineplus">+     * This method needs to deal with the complexity where local folders will</span>
<a href="#l3.846"></a><span id="l3.846" class="difflineplus">+     *  generate a rename notification for each sub-folder, but IMAP folders</span>
<a href="#l3.847"></a><span id="l3.847" class="difflineplus">+     *  will generate only a single notification.  Our logic primarily handles</span>
<a href="#l3.848"></a><span id="l3.848" class="difflineplus">+     *  this by not exploding if the original folder no longer exists.</span>
<a href="#l3.849"></a><span id="l3.849" class="difflineplus">+     */</span>
<a href="#l3.850"></a><span id="l3.850" class="difflineplus">+    _folderRenameHelper: function gloda_indexer_folderRenameHelper(aOrigFolder,</span>
<a href="#l3.851"></a><span id="l3.851" class="difflineplus">+                                                                   aNewURI) {</span>
<a href="#l3.852"></a><span id="l3.852" class="difflineplus">+      let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l3.853"></a><span id="l3.853" class="difflineplus">+                                createInstance(Ci.nsISupportsArray);</span>
<a href="#l3.854"></a><span id="l3.854" class="difflineplus">+      aOrigFolder.ListDescendents(descendentFolders);</span>
<a href="#l3.855"></a><span id="l3.855" class="difflineplus">+      </span>
<a href="#l3.856"></a><span id="l3.856" class="difflineplus">+      let origURI = aOrigFolder.URI;</span>
<a href="#l3.857"></a><span id="l3.857" class="difflineplus">+      // this rename is straightforward.</span>
<a href="#l3.858"></a><span id="l3.858" class="difflineplus">+      GlodaDatastore.renameFolder(origURI, aNewURI);</span>
<a href="#l3.859"></a><span id="l3.859" class="difflineplus">+      </span>
<a href="#l3.860"></a><span id="l3.860" class="difflineplus">+      for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l3.861"></a><span id="l3.861" class="difflineplus">+        let oldSubURI = folder.URI;</span>
<a href="#l3.862"></a><span id="l3.862" class="difflineplus">+        // mangle a new URI from the old URI.  we could also try and do a</span>
<a href="#l3.863"></a><span id="l3.863" class="difflineplus">+        //  parallel traversal of the new folder hierarchy, but that seems like</span>
<a href="#l3.864"></a><span id="l3.864" class="difflineplus">+        //  more work.</span>
<a href="#l3.865"></a><span id="l3.865" class="difflineplus">+        let newSubURI = aNewURI + oldSubURI.substring(origURI.length)</span>
<a href="#l3.866"></a><span id="l3.866" class="difflineplus">+        this.indexer._datastore.renameFolder(oldSubURI, newSubURI);</span>
<a href="#l3.867"></a><span id="l3.867" class="difflineplus">+      }</span>
<a href="#l3.868"></a><span id="l3.868" class="difflineplus">+</span>
<a href="#l3.869"></a><span id="l3.869" class="difflineplus">+      this.indexer._log.debug(&quot;folder renamed: &quot; + origURI + &quot; to &quot; + aNewURI);</span>
<a href="#l3.870"></a><span id="l3.870" class="difflineplus">+    },</span>
<a href="#l3.871"></a><span id="l3.871" class="difflineplus">+    </span>
<a href="#l3.872"></a><span id="l3.872" class="difflineplus">+    /**</span>
<a href="#l3.873"></a><span id="l3.873" class="difflineplus">+     * Handle folder renames, dispatching to our rename helper (which also</span>
<a href="#l3.874"></a><span id="l3.874" class="difflineplus">+     *  takes care of any nested folder issues.)</span>
<a href="#l3.875"></a><span id="l3.875">      */</span>
<a href="#l3.876"></a><span id="l3.876">     folderRenamed: function gloda_indexer_folderRenamed(aOrigFolder,</span>
<a href="#l3.877"></a><span id="l3.877">                                                         aNewFolder) {</span>
<a href="#l3.878"></a><span id="l3.878" class="difflineminus">-      // TODO handle nested folder ramifications (we don't receive events for</span>
<a href="#l3.879"></a><span id="l3.879" class="difflineminus">-      //  these, so nested folders will become wrong)</span>
<a href="#l3.880"></a><span id="l3.880" class="difflineminus">-      this.indexer._log.debug(&quot;folderRenamed notification: &quot; + aOrigFolder.URI +</span>
<a href="#l3.881"></a><span id="l3.881" class="difflineminus">-                              &quot; to &quot; + aNewFolder.URI);</span>
<a href="#l3.882"></a><span id="l3.882" class="difflineminus">-      GlodaDatastore.renameFolder(aOrigFolder.URI, aNewFolder.URI);</span>
<a href="#l3.883"></a><span id="l3.883" class="difflineplus">+      this._folderRenameHelper(aOrigFolder, aNewFolder.URI);</span>
<a href="#l3.884"></a><span id="l3.884">     },</span>
<a href="#l3.885"></a><span id="l3.885">     </span>
<a href="#l3.886"></a><span id="l3.886">     itemEvent: function gloda_indexer_itemEvent(aItem, aEvent, aData) {</span>
<a href="#l3.887"></a><span id="l3.887">       // nop.  this is an expansion method on the part of the interface and has</span>
<a href="#l3.888"></a><span id="l3.888">       //  no known events that we need to handle.</span>
<a href="#l3.889"></a><span id="l3.889">     },</span>
<a href="#l3.890"></a><span id="l3.890">   },</span>
<a href="#l3.891"></a><span id="l3.891">   </span>
<a href="#l3.892"></a><span id="l3.892" class="difflineat">@@ -1160,24 +1315,33 @@ let GlodaIndexer = {</span>
<a href="#l3.893"></a><span id="l3.893">     /**</span>
<a href="#l3.894"></a><span id="l3.894">      * Helper method to do the leg-work associated with flagging a message</span>
<a href="#l3.895"></a><span id="l3.895">      *  for re-indexing because of some change in meta-state that happened to</span>
<a href="#l3.896"></a><span id="l3.896">      *  it.  Job-wise, we treat this as a message addition; we are uniquely</span>
<a href="#l3.897"></a><span id="l3.897">      *  identifying the message by providing its folder ID and message key, and</span>
<a href="#l3.898"></a><span id="l3.898">      *  the indexer will cleanly map this to the existing gloda message.</span>
<a href="#l3.899"></a><span id="l3.899">      */</span>
<a href="#l3.900"></a><span id="l3.900">     _reindexChangedMessage: function(aMsgHdr) {</span>
<a href="#l3.901"></a><span id="l3.901" class="difflineplus">+      // mark the message as dirty</span>
<a href="#l3.902"></a><span id="l3.902" class="difflineplus">+      // (We could check for the presence of the gloda message id property</span>
<a href="#l3.903"></a><span id="l3.903" class="difflineplus">+      //  first to know whether we technically need the dirty property.  I'm</span>
<a href="#l3.904"></a><span id="l3.904" class="difflineplus">+      //  not sure whether it is worth the high-probability exception cost.) </span>
<a href="#l3.905"></a><span id="l3.905" class="difflineplus">+      aMsgHdr.setUint32Property(this.GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l3.906"></a><span id="l3.906" class="difflineplus">+      </span>
<a href="#l3.907"></a><span id="l3.907">       if (this.indexer._pendingAddJob === null) {</span>
<a href="#l3.908"></a><span id="l3.908">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l3.909"></a><span id="l3.909">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l3.910"></a><span id="l3.910">         this.indexer._indexingJobGoal++;</span>
<a href="#l3.911"></a><span id="l3.911">       }</span>
<a href="#l3.912"></a><span id="l3.912" class="difflineminus">-      this.indexer._pendingAddJob.items.push(</span>
<a href="#l3.913"></a><span id="l3.913" class="difflineminus">-        [GlodaDatastore._mapFolderURI(aMsgHdr.folder.URI),</span>
<a href="#l3.914"></a><span id="l3.914" class="difflineminus">-         aMsgHdr.messageKey]);</span>
<a href="#l3.915"></a><span id="l3.915" class="difflineplus">+      // only queue the messe if we haven't overflowed our event-driven budget</span>
<a href="#l3.916"></a><span id="l3.916" class="difflineplus">+      if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l3.917"></a><span id="l3.917" class="difflineplus">+          this._indexMaxEventQueueMessages)</span>
<a href="#l3.918"></a><span id="l3.918" class="difflineplus">+        this.indexer._pendingAddJob.items.push(</span>
<a href="#l3.919"></a><span id="l3.919" class="difflineplus">+          [GlodaDatastore._mapFolderURI(aMsgHdr.folder.URI),</span>
<a href="#l3.920"></a><span id="l3.920" class="difflineplus">+           aMsgHdr.messageKey]);</span>
<a href="#l3.921"></a><span id="l3.921">       this.indexer.indexing = true;</span>
<a href="#l3.922"></a><span id="l3.922">     },</span>
<a href="#l3.923"></a><span id="l3.923">   </span>
<a href="#l3.924"></a><span id="l3.924">     /**</span>
<a href="#l3.925"></a><span id="l3.925">      * Find out when folders are added or new messages show up in a newsgroup.</span>
<a href="#l3.926"></a><span id="l3.926">      */</span>
<a href="#l3.927"></a><span id="l3.927">     OnItemAdded: function gloda_indexer_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l3.928"></a><span id="l3.928">     },</span>
<a href="#l3.929"></a><span id="l3.929" class="difflineat">@@ -1206,18 +1370,20 @@ let GlodaIndexer = {</span>
<a href="#l3.930"></a><span id="l3.930">           aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l3.931"></a><span id="l3.931">       </span>
<a href="#l3.932"></a><span id="l3.932">     },</span>
<a href="#l3.933"></a><span id="l3.933">     OnItemPropertyFlagChanged: function gloda_indexer_OnItemPropertyFlagChanged(</span>
<a href="#l3.934"></a><span id="l3.934">                                 aMsgHdr, aProperty, aOldValue, aNewValue) {</span>
<a href="#l3.935"></a><span id="l3.935">       if (aProperty == this._kStatusAtom ||</span>
<a href="#l3.936"></a><span id="l3.936">           aProperty == this._kFlaggedAtom ||</span>
<a href="#l3.937"></a><span id="l3.937">           aProperty == this._kJunkStatusChangedAtom) {</span>
<a href="#l3.938"></a><span id="l3.938" class="difflineminus">-        this.indexer._log.debug(&quot;ItemPropertyFlagChanged notification&quot;);</span>
<a href="#l3.939"></a><span id="l3.939" class="difflineminus">-        this._reindexChangedMessage(aMsgHdr);</span>
<a href="#l3.940"></a><span id="l3.940" class="difflineplus">+        if (this.indexer.enabled) {</span>
<a href="#l3.941"></a><span id="l3.941" class="difflineplus">+          this.indexer._log.debug(&quot;ItemPropertyFlagChanged notification&quot;);</span>
<a href="#l3.942"></a><span id="l3.942" class="difflineplus">+          this._reindexChangedMessage(aMsgHdr);</span>
<a href="#l3.943"></a><span id="l3.943" class="difflineplus">+        }</span>
<a href="#l3.944"></a><span id="l3.944">       }</span>
<a href="#l3.945"></a><span id="l3.945">     },</span>
<a href="#l3.946"></a><span id="l3.946">     </span>
<a href="#l3.947"></a><span id="l3.947">     /**</span>
<a href="#l3.948"></a><span id="l3.948">      * Get folder loaded notifications for folders that had to do some</span>
<a href="#l3.949"></a><span id="l3.949">      *  (asynchronous) processing before they could be opened.</span>
<a href="#l3.950"></a><span id="l3.950">      */</span>
<a href="#l3.951"></a><span id="l3.951">     OnItemEvent: function gloda_indexer_OnItemEvent(aFolder, aEvent) {</span>
<a href="#l3.952"></a><span id="l3.952" class="difflineat">@@ -1482,17 +1648,30 @@ let GlodaIndexer = {</span>
<a href="#l3.953"></a><span id="l3.953">       this._datastore.updateMessage(curMsg, isNew ? aMsgHdr.subject : null,</span>
<a href="#l3.954"></a><span id="l3.954">         (isNew &amp;&amp; aMimeMsg) ? aMimeMsg.body : null,</span>
<a href="#l3.955"></a><span id="l3.955">         isNew ? attachmentNames : null);</span>
<a href="#l3.956"></a><span id="l3.956">     }</span>
<a href="#l3.957"></a><span id="l3.957">     </span>
<a href="#l3.958"></a><span id="l3.958">     // TODO: provide the parent gloda message if we can conjure it up.</span>
<a href="#l3.959"></a><span id="l3.959">     Gloda.processMessage(curMsg, aMsgHdr, aMimeMsg, isNew,</span>
<a href="#l3.960"></a><span id="l3.960">                          /* parent gloda message */ null);</span>
<a href="#l3.961"></a><span id="l3.961" class="difflineminus">-     </span>
<a href="#l3.962"></a><span id="l3.962" class="difflineplus">+    </span>
<a href="#l3.963"></a><span id="l3.963" class="difflineplus">+    // Mark this message as indexed</span>
<a href="#l3.964"></a><span id="l3.964" class="difflineplus">+    aMsgHdr.setUint32Property(this.GLODA_MESSAGE_ID_PROPERTY, curMsg.id);</span>
<a href="#l3.965"></a><span id="l3.965" class="difflineplus">+    // If there is a gloda-dirty flag on there, clear it by writing a 0.  (But</span>
<a href="#l3.966"></a><span id="l3.966" class="difflineplus">+    //  don't do this if we didn't have a dirty flag on there in the first</span>
<a href="#l3.967"></a><span id="l3.967" class="difflineplus">+    //  case.)  It sounds like we would actually prefer to &quot;cut&quot; the &quot;cell&quot;,</span>
<a href="#l3.968"></a><span id="l3.968" class="difflineplus">+    //  but I don't see any in-domain means of doing that.</span>
<a href="#l3.969"></a><span id="l3.969" class="difflineplus">+    try {</span>
<a href="#l3.970"></a><span id="l3.970" class="difflineplus">+      let isDirty = aMsgHdr.getUint32Property(this.GLODA_DIRTY_PROPERTY);</span>
<a href="#l3.971"></a><span id="l3.971" class="difflineplus">+      if (isDirty)</span>
<a href="#l3.972"></a><span id="l3.972" class="difflineplus">+        aMsgHdr.setUint32Property(this.GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l3.973"></a><span id="l3.973" class="difflineplus">+    }</span>
<a href="#l3.974"></a><span id="l3.974" class="difflineplus">+    catch (ex) {}</span>
<a href="#l3.975"></a><span id="l3.975" class="difflineplus">+    </span>
<a href="#l3.976"></a><span id="l3.976">     this.callbackDriver();</span>
<a href="#l3.977"></a><span id="l3.977">   },</span>
<a href="#l3.978"></a><span id="l3.978">   </span>
<a href="#l3.979"></a><span id="l3.979">   /**</span>
<a href="#l3.980"></a><span id="l3.980">    * Wipe a message out of existence from our index.  This is slightly more</span>
<a href="#l3.981"></a><span id="l3.981">    *  tricky than one would first expect because there are potentially</span>
<a href="#l3.982"></a><span id="l3.982">    *  attributes not immediately associated with this message that reference</span>
<a href="#l3.983"></a><span id="l3.983">    *  the message.  Not only that, but deletion of messages may leave a</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

