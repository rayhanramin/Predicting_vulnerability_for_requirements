<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 878:cb22786c1ac026e1288a1b0dd1f1c8b7b63441db</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ cb22786c1ac026e1288a1b0dd1f1c8b7b63441db" />
<meta property="og:url" content="/comm-central/rev/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db" />
<meta property="og:description" content="status commit: end of day." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / cb22786c1ac026e1288a1b0dd1f1c8b7b63441db 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db">shortlog</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db">files</a> |
changeset |
<a href="/comm-central/raw-rev/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db">raw</a>  | <a href="/comm-central/archive/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
status commit: end of day.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 17 Aug 2008 02:13:56 -0700</td></tr>

<tr>
 <td>changeset 878</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db">cb22786c1ac026e1288a1b0dd1f1c8b7b63441db</a></td>
</tr>



<tr>
<td>parent 877</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/94ca4330edc8ec70cbc65f05998687e169d4f07d">94ca4330edc8ec70cbc65f05998687e169d4f07d</a>
</td>
</tr>

<tr>
<td>child 879</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/f8c55de23fac621c56dfdc33ca9d1af062bc6f96">f8c55de23fac621c56dfdc33ca9d1af062bc6f96</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=cb22786c1ac026e1288a1b0dd1f1c8b7b63441db">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">status commit: end of day.
 * add fulltext support; explicit code for conversations/messages, plus the generalized stuff for constraints.  untested.
 * datastore now opens connection unshared for fts3 support.
 * datastore will purge existing database on upgrade for now; this current schema should probably be mature enough that we might be able to just ALTER TABLE in the future, but no promises yet.  (by code freeze though :)
 * introducing a caching layer to the collection manager and use by the datastore to maintain single object instance.
 * concept of dirty introduced, hopefully allowing reasonable performance.  erring on the side of too often and too expensive for committing the data right now.  (need to scan to find dirty things if we're not just flushing on cache eviction.  this clearly could be optimized, but I'd rather not add a data structure for that.)
 * add all the to-me, cc-me, from-me-to, from-me-cc optimization attributes, plus the logic to mess with popularity in the fundamental attributes.
 * and more!</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/overlay.js">content/overlay.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/overlay.js">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/overlay.js">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/overlay.js">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/overlay.js">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/overlay.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/thunderbirdOverlay.xul">content/thunderbirdOverlay.xul</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/thunderbirdOverlay.xul">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/thunderbirdOverlay.xul">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/thunderbirdOverlay.xul">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/thunderbirdOverlay.xul">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/content/thunderbirdOverlay.xul">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.dtd">locale/en-US/gloda.dtd</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.dtd">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.dtd">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.dtd">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.dtd">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.dtd">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.properties">locale/en-US/gloda.properties</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.properties">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.properties">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.properties">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.properties">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/locale/en-US/gloda.properties">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/collection.js">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/collection.js">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/fundattr.js">modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db/modules/indexer.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/content/overlay.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/content/overlay.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -53,19 +53,22 @@ var gloda = {</span>
<a href="#l1.4"></a><span id="l1.4">     // initialize the globals required for the JS Mime representation</span>
<a href="#l1.5"></a><span id="l1.5">     Components.utils.import(&quot;resource://gloda/modules/mimemsg.js&quot;,</span>
<a href="#l1.6"></a><span id="l1.6">                             this._mimeMsg);</span>
<a href="#l1.7"></a><span id="l1.7">     this._mimeMsg.MsgHdrToMimeMessage.initGlobals(messenger, msgWindow);</span>
<a href="#l1.8"></a><span id="l1.8">     </span>
<a href="#l1.9"></a><span id="l1.9">     GlodaIndexer.init(window, msgWindow, this.strings, messenger);</span>
<a href="#l1.10"></a><span id="l1.10">     GlodaIndexer.enabled = true;</span>
<a href="#l1.11"></a><span id="l1.11">   },</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  onMenuItemCommand: function(e) {</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  onIndexEverythingCommand: function(e) {</span>
<a href="#l1.14"></a><span id="l1.14">     GlodaIndexer.indexEverything();</span>
<a href="#l1.15"></a><span id="l1.15">   },</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+  onIndexAddressBookCommand: function(e) {</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+    // TODO support address-book indexing or something.</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+  },  </span>
<a href="#l1.19"></a><span id="l1.19">   indexSelectedMessages: function () {</span>
<a href="#l1.20"></a><span id="l1.20">     var dbView = GetDBView();</span>
<a href="#l1.21"></a><span id="l1.21">     var indices = GetSelectedIndices(dbView);</span>
<a href="#l1.22"></a><span id="l1.22">     var toindex = [];</span>
<a href="#l1.23"></a><span id="l1.23">     for (var iIndex=0; iIndex &lt; indices.length; iIndex++) {</span>
<a href="#l1.24"></a><span id="l1.24">       var actualIndex = indices[iIndex];</span>
<a href="#l1.25"></a><span id="l1.25">       var folder = dbView.getFolderForViewIndex(actualIndex);</span>
<a href="#l1.26"></a><span id="l1.26">       var msgKey = dbView.getKeyAt(actualIndex);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/content/thunderbirdOverlay.xul</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/content/thunderbirdOverlay.xul</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -41,18 +41,20 @@</span>
<a href="#l2.4"></a><span id="l2.4"> &lt;overlay id=&quot;gloda-overlay&quot;</span>
<a href="#l2.5"></a><span id="l2.5">          xmlns=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;&gt;</span>
<a href="#l2.6"></a><span id="l2.6">   &lt;script src=&quot;overlay.js&quot;/&gt;</span>
<a href="#l2.7"></a><span id="l2.7">   &lt;stringbundleset id=&quot;stringbundleset&quot;&gt;</span>
<a href="#l2.8"></a><span id="l2.8">     &lt;stringbundle id=&quot;gloda-strings&quot; src=&quot;chrome://gloda/locale/gloda.properties&quot;/&gt;</span>
<a href="#l2.9"></a><span id="l2.9">   &lt;/stringbundleset&gt;</span>
<a href="#l2.10"></a><span id="l2.10"> </span>
<a href="#l2.11"></a><span id="l2.11">   &lt;menupopup id=&quot;taskPopup&quot;&gt;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-    &lt;menuitem id=&quot;gloda-hello&quot; label=&quot;&amp;gloda.label;&quot; </span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-              oncommand=&quot;gloda.onMenuItemCommand(event);&quot;/&gt;</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+    &lt;menuitem id=&quot;gloda-hello&quot; label=&quot;&amp;glodaIndexEverything.label;&quot; </span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+              oncommand=&quot;gloda.onIndexEverythingCommand(event);&quot;/&gt;</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+    &lt;menuitem id=&quot;gloda-hello&quot; label=&quot;&amp;glodaIndexAddressBook.label;&quot; </span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+              oncommand=&quot;gloda.onIndexAddressBookCommand(event);&quot;/&gt;</span>
<a href="#l2.18"></a><span id="l2.18">   &lt;/menupopup&gt;</span>
<a href="#l2.19"></a><span id="l2.19">   </span>
<a href="#l2.20"></a><span id="l2.20">   &lt;popup id=&quot;folderPaneContext&quot;&gt;</span>
<a href="#l2.21"></a><span id="l2.21">     &lt;menuseparator id=&quot;folderPaneContext-sep-gloda&quot;/&gt;</span>
<a href="#l2.22"></a><span id="l2.22">     &lt;menuitem id=&quot;folderPaneContext-gloda-index&quot;</span>
<a href="#l2.23"></a><span id="l2.23">               label=&quot;&amp;folderContextGlodaIndex.label;&quot;</span>
<a href="#l2.24"></a><span id="l2.24">               accesskey=&quot;&amp;folderContextGlodaIndex.accesskey;&quot;</span>
<a href="#l2.25"></a><span id="l2.25">               oncommand=&quot;GlodaIndexer.indexFolderByURI(GetSelectedFolderURI());&quot;/&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/locale/en-US/gloda.dtd</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/locale/en-US/gloda.dtd</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -1,5 +1,6 @@</span>
<a href="#l3.4"></a><span id="l3.4" class="difflineminus">-&lt;!ENTITY gloda.label &quot;Index Everything&quot;&gt;</span>
<a href="#l3.5"></a><span id="l3.5" class="difflineplus">+&lt;!ENTITY glodaIndexEverything.label &quot;Index Everything&quot;&gt;</span>
<a href="#l3.6"></a><span id="l3.6" class="difflineplus">+&lt;!ENTITY glodaIndexAddressBook.label &quot;Index Addressbook&quot;&gt;</span>
<a href="#l3.7"></a><span id="l3.7"> &lt;!ENTITY folderContextGlodaIndex.label &quot;Gloda Index&quot;&gt;</span>
<a href="#l3.8"></a><span id="l3.8"> &lt;!ENTITY folderContextGlodaIndex.accesskey &quot;x&quot;&gt;</span>
<a href="#l3.9"></a><span id="l3.9"> &lt;!ENTITY threadContextGlodaIndex.label &quot;Gloda Index&quot;&gt;</span>
<a href="#l3.10"></a><span id="l3.10"> &lt;!ENTITY threadContextGlodaIndex.accesskey &quot;x&quot;&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/locale/en-US/gloda.properties</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/locale/en-US/gloda.properties</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -6,12 +6,16 @@ actionIndexing=Indexing</span>
<a href="#l4.4"></a><span id="l4.4"> actionDeindexing=De-Indexing</span>
<a href="#l4.5"></a><span id="l4.5"> actionMoving=Move Processing</span>
<a href="#l4.6"></a><span id="l4.6"> messageIndexingExplanation=some messages</span>
<a href="#l4.7"></a><span id="l4.7"> attrFolderExplanation=%{subject} is in folder %{object}</span>
<a href="#l4.8"></a><span id="l4.8"> attrFromExplanation=%{subject} was sent by %{object}</span>
<a href="#l4.9"></a><span id="l4.9"> attrToExplanation=%{subject} was sent to %{object}</span>
<a href="#l4.10"></a><span id="l4.10"> attrCcExplanation=%{subject} was carbon-copied to %{object}</span>
<a href="#l4.11"></a><span id="l4.11"> attrDateExplanation=%{subject} was sent on %{object}</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+attrFromMeToExplanation=%{subject} was sent by me to %{object}</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+attrFromMeCcExplanation=%{subject} was sent by me carbon-copied to %{object}</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+attrToMeExplanation=%{subject} was sent to me by %{object}</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+attrCcMeExplanation=%{subject} was carbon-copied to me by %{object}</span>
<a href="#l4.16"></a><span id="l4.16"> attrListExplanation=%{subject} was sent via %{object}</span>
<a href="#l4.17"></a><span id="l4.17"> attrTagExplanation=%{subject} was tagged %{object}</span>
<a href="#l4.18"></a><span id="l4.18"> attrStarExplanation=%{subject} has a star state of %{object}</span>
<a href="#l4.19"></a><span id="l4.19"> attrReadExplanation=%{subject} has a read state of %{object}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -39,23 +39,38 @@ EXPORTED_SYMBOLS = ['GlodaCollection', '</span>
<a href="#l5.4"></a><span id="l5.4"> </span>
<a href="#l5.5"></a><span id="l5.5"> const Cc = Components.classes;</span>
<a href="#l5.6"></a><span id="l5.6"> const Ci = Components.interfaces;</span>
<a href="#l5.7"></a><span id="l5.7"> const Cr = Components.results;</span>
<a href="#l5.8"></a><span id="l5.8"> const Cu = Components.utils;</span>
<a href="#l5.9"></a><span id="l5.9"> </span>
<a href="#l5.10"></a><span id="l5.10"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+/**</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+ * The collection manager is a singleton that has the following tasks:</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+ * - Let views of objects (nouns) know when their objects have changed.  For</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+ *   example, an attribute has changed due to user action.</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+ * - Let views of objects based on queries know when new objects match their</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+ *   query, or when their existing objects no longer match due to changes.</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+ * - Caching/object-identity maintenance.  It is ideal if we only ever have</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+ *   one instance of an object at a time.  (More specifically, only one instance</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+ *   per database row 'id'.)  The collection mechanism lets us find existing</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+ *   instances to this end.  Caching can be directly integrated by being treated</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+ *   as a special collection.</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+ */</span>
<a href="#l5.24"></a><span id="l5.24"> function GlodaCollectionManager() {</span>
<a href="#l5.25"></a><span id="l5.25">   this._collectionsByNoun = {};</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineplus">+  this._cachesByNoun = {};</span>
<a href="#l5.27"></a><span id="l5.27"> }</span>
<a href="#l5.28"></a><span id="l5.28"> </span>
<a href="#l5.29"></a><span id="l5.29"> GlodaCollectionManager.prototype = {</span>
<a href="#l5.30"></a><span id="l5.30">   /**</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineminus">-   *</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+   * Registers the existence of a collection with the collection manager.  This</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+   *  is done using a weak reference so that the collection can go away if it</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+   *  wants to.</span>
<a href="#l5.35"></a><span id="l5.35">    */</span>
<a href="#l5.36"></a><span id="l5.36">   registerCollection: function gloda_colm_registerCollection(aCollection) {</span>
<a href="#l5.37"></a><span id="l5.37">     let collections;</span>
<a href="#l5.38"></a><span id="l5.38">     let nounID = aCollection.query._nounMeta.id;</span>
<a href="#l5.39"></a><span id="l5.39">     if (!(nounID in this._collectionsByNoun))</span>
<a href="#l5.40"></a><span id="l5.40">       collections = this._collectionsByNoun[nounID] = [];</span>
<a href="#l5.41"></a><span id="l5.41">     else {</span>
<a href="#l5.42"></a><span id="l5.42">       // purge dead weak references while we're at it</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineat">@@ -77,25 +92,72 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l5.44"></a><span id="l5.44">     for (let iColl=0; iColl &lt; weakCollections.length; iColl++) {</span>
<a href="#l5.45"></a><span id="l5.45">       let collection = weakCollections[iColl].get();</span>
<a href="#l5.46"></a><span id="l5.46">       if (collection)</span>
<a href="#l5.47"></a><span id="l5.47">         collections.push(collection);</span>
<a href="#l5.48"></a><span id="l5.48">     }</span>
<a href="#l5.49"></a><span id="l5.49">     return collections;</span>
<a href="#l5.50"></a><span id="l5.50">   },</span>
<a href="#l5.51"></a><span id="l5.51">   </span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+  defineCache: function gloda_colm_defineCache(aNounMeta, aCacheSize) {</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+    this._cachesByNoun[aNounMeta.id] = new GlodaLRUCacheCollection(aNounMeta,</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+                                                                   aCacheSize);</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+  },</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+  </span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+  /** </span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+   * Attempt to locate existing instances of nouns with the given IDs. </span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+   */</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+  cacheLookup: function gloda_colm_cacheLookup(aNounMetaID, aIDs) {</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+    // try the cache first; it has explicit semantics related to caching so</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+    //  needs slightly different treatment.  (plus, it makes sense to check</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+    //  the cache first, especially since it's not an exclusive cache.)</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+    let cache = this._cachesByNoun[aNounMetaID];</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+    </span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+    if (cache) {</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+      let results = [];</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+      let hits = 0;</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+      let misses = </span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+      for each (id in aIDs) {</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineplus">+        if (id in cache._idMap) {</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+          results.push(cache.hit(id));</span>
<a href="#l5.73"></a><span id="l5.73" class="difflineplus">+          hits++;</span>
<a href="#l5.74"></a><span id="l5.74" class="difflineplus">+        }</span>
<a href="#l5.75"></a><span id="l5.75" class="difflineplus">+        else</span>
<a href="#l5.76"></a><span id="l5.76" class="difflineplus">+          results.push(null);</span>
<a href="#l5.77"></a><span id="l5.77" class="difflineplus">+      }</span>
<a href="#l5.78"></a><span id="l5.78" class="difflineplus">+    }</span>
<a href="#l5.79"></a><span id="l5.79" class="difflineplus">+  </span>
<a href="#l5.80"></a><span id="l5.80" class="difflineplus">+    // next, let's fall back to our friend dudes</span>
<a href="#l5.81"></a><span id="l5.81" class="difflineplus">+    for each (let collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l5.82"></a><span id="l5.82" class="difflineplus">+    }</span>
<a href="#l5.83"></a><span id="l5.83" class="difflineplus">+  },</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineplus">+  </span>
<a href="#l5.85"></a><span id="l5.85" class="difflineplus">+  cacheAdd: function gloda_colm_cacheAdd(aNounMetaID, aObjs) {</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineplus">+    let cache = this._cachesByNoun[aNounMetaID];</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineplus">+    </span>
<a href="#l5.88"></a><span id="l5.88" class="difflineplus">+    if (cache) {</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineplus">+      cache.add(aObjs);</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineplus">+    }</span>
<a href="#l5.91"></a><span id="l5.91" class="difflineplus">+  },</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineplus">+  </span>
<a href="#l5.93"></a><span id="l5.93" class="difflineplus">+  cacheCommitDirty: function glod_colm_cacheCommitDirty() {</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineplus">+    for each (let cache in this._cachesByNoun) {</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineplus">+      cache.commitDirty();</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+    }</span>
<a href="#l5.97"></a><span id="l5.97" class="difflineplus">+  }</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineplus">+  </span>
<a href="#l5.99"></a><span id="l5.99">   /**</span>
<a href="#l5.100"></a><span id="l5.100">    * This should be called when items are added to the global database.  This</span>
<a href="#l5.101"></a><span id="l5.101">    *  should generally mean during indexing by indexers or an attribute</span>
<a href="#l5.102"></a><span id="l5.102">    *  provider.</span>
<a href="#l5.103"></a><span id="l5.103">    * We walk all existing collections for the given noun type and add the items</span>
<a href="#l5.104"></a><span id="l5.104">    *  to the collection if the item meets the query that defines the collection.</span>
<a href="#l5.105"></a><span id="l5.105">    */</span>
<a href="#l5.106"></a><span id="l5.106" class="difflineminus">-  itemsAdded: function gloda_colm_itemsAdded(aItems) {</span>
<a href="#l5.107"></a><span id="l5.107" class="difflineminus">-    for each (let collection in this.getCollectionsForNounID()) {</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+  itemsAdded: function gloda_colm_itemsAdded(aNounID, aItems) {</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineplus">+    for each (let collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l5.110"></a><span id="l5.110">       let addItems = [item for each (item in aItems)</span>
<a href="#l5.111"></a><span id="l5.111">                       if (collection.query.test(item))];</span>
<a href="#l5.112"></a><span id="l5.112">       if (addItems.length)</span>
<a href="#l5.113"></a><span id="l5.113">         collection._onItemsAdded(addItems);</span>
<a href="#l5.114"></a><span id="l5.114">     }</span>
<a href="#l5.115"></a><span id="l5.115">   },</span>
<a href="#l5.116"></a><span id="l5.116">   /**</span>
<a href="#l5.117"></a><span id="l5.117">    * This should be called when items in the global database are modified.  For</span>
<a href="#l5.118"></a><span id="l5.118" class="difflineat">@@ -103,18 +165,18 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l5.119"></a><span id="l5.119">    *  by indexers or by attribute providers.</span>
<a href="#l5.120"></a><span id="l5.120">    * We walk all existing collections for the given noun type.  For items</span>
<a href="#l5.121"></a><span id="l5.121">    *  currently included in each collection but should no longer be (per the</span>
<a href="#l5.122"></a><span id="l5.122">    *  collection's defining query) we generate onItemsRemoved events.  For items</span>
<a href="#l5.123"></a><span id="l5.123">    *  not currently included in the collection but should now be, we generate</span>
<a href="#l5.124"></a><span id="l5.124">    *  onItemsAdded events.  For items included that still match the query, we</span>
<a href="#l5.125"></a><span id="l5.125">    *  generate onItemsModified events.</span>
<a href="#l5.126"></a><span id="l5.126">    */</span>
<a href="#l5.127"></a><span id="l5.127" class="difflineminus">-  itemsModified: function gloda_colm_itemsModified(aItems) {</span>
<a href="#l5.128"></a><span id="l5.128" class="difflineminus">-    for each (collection in this.getCollectionsForNounID()) {</span>
<a href="#l5.129"></a><span id="l5.129" class="difflineplus">+  itemsModified: function gloda_colm_itemsModified(aNounID, aItems) {</span>
<a href="#l5.130"></a><span id="l5.130" class="difflineplus">+    for each (collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l5.131"></a><span id="l5.131">       let added = [], modified = [], removed = [];</span>
<a href="#l5.132"></a><span id="l5.132">       for each (let item in aItems) {</span>
<a href="#l5.133"></a><span id="l5.133">         if (item.id in collection._idMap) {</span>
<a href="#l5.134"></a><span id="l5.134">           // currently in... but should it still be there?</span>
<a href="#l5.135"></a><span id="l5.135">           if (collection.query.test(item))</span>
<a href="#l5.136"></a><span id="l5.136">             modified.push(item); // yes, keep it</span>
<a href="#l5.137"></a><span id="l5.137">           else</span>
<a href="#l5.138"></a><span id="l5.138">             removed.push(item); // no, bin it</span>
<a href="#l5.139"></a><span id="l5.139" class="difflineat">@@ -134,18 +196,18 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l5.140"></a><span id="l5.140">    * This should be called when items in the global database are permanently</span>
<a href="#l5.141"></a><span id="l5.141">    *  deleted.  (This is distinct from concepts like message deletion which may</span>
<a href="#l5.142"></a><span id="l5.142">    *  involved trash folders or other modified forms of existence.  Deleted</span>
<a href="#l5.143"></a><span id="l5.143">    *  means the data is gone and if it were to come back, it would come back</span>
<a href="#l5.144"></a><span id="l5.144">    *  with a brand new unique id and we would get an itemsAdded event.)</span>
<a href="#l5.145"></a><span id="l5.145">    * We walk all existing collections for the given noun type.  For items</span>
<a href="#l5.146"></a><span id="l5.146">    *  currently in the collection, we generate onItemsRemoved events.</span>
<a href="#l5.147"></a><span id="l5.147">    */</span>
<a href="#l5.148"></a><span id="l5.148" class="difflineminus">-  itemsDeleted: function gloda_colm_itemsDeleted(aItems) {</span>
<a href="#l5.149"></a><span id="l5.149" class="difflineminus">-    for each (let collection in this.getCollectionsForNounID()) {</span>
<a href="#l5.150"></a><span id="l5.150" class="difflineplus">+  itemsDeleted: function gloda_colm_itemsDeleted(aNounID, aItems) {</span>
<a href="#l5.151"></a><span id="l5.151" class="difflineplus">+    for each (let collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l5.152"></a><span id="l5.152">       let removeItems = [item for each (item in aItems)</span>
<a href="#l5.153"></a><span id="l5.153">                          if (item.id in collection._idMap)];</span>
<a href="#l5.154"></a><span id="l5.154">       if (removeItems.length)</span>
<a href="#l5.155"></a><span id="l5.155">         collection._onItemsRemoved(removeItems);</span>
<a href="#l5.156"></a><span id="l5.156">     }</span>
<a href="#l5.157"></a><span id="l5.157">   },</span>
<a href="#l5.158"></a><span id="l5.158"> }</span>
<a href="#l5.159"></a><span id="l5.159"> // singleton</span>
<a href="#l5.160"></a><span id="l5.160" class="difflineat">@@ -205,8 +267,104 @@ GlodaCollection.prototype = {</span>
<a href="#l5.161"></a><span id="l5.161">         items[iWrite++] = item;</span>
<a href="#l5.162"></a><span id="l5.162">     }</span>
<a href="#l5.163"></a><span id="l5.163">     items.slice(iWrite);</span>
<a href="#l5.164"></a><span id="l5.164">     </span>
<a href="#l5.165"></a><span id="l5.165">     if (this._listener)</span>
<a href="#l5.166"></a><span id="l5.166">       this._listener.onItemsRemoved(aItems);</span>
<a href="#l5.167"></a><span id="l5.167">   },</span>
<a href="#l5.168"></a><span id="l5.168"> };</span>
<a href="#l5.169"></a><span id="l5.169" class="difflineplus">+</span>
<a href="#l5.170"></a><span id="l5.170" class="difflineplus">+/**</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineplus">+ * A LRU-discard cache.  We use a doubly linked-list for the eviction</span>
<a href="#l5.172"></a><span id="l5.172" class="difflineplus">+ *  tracking.  Since we require that there is at most one LRU-discard cache per</span>
<a href="#l5.173"></a><span id="l5.173" class="difflineplus">+ *  noun class, we simplify our lives by adding our own attributes to the</span>
<a href="#l5.174"></a><span id="l5.174" class="difflineplus">+ *  cached objects.</span>
<a href="#l5.175"></a><span id="l5.175" class="difflineplus">+ */</span>
<a href="#l5.176"></a><span id="l5.176" class="difflineplus">+function GlodaLRUCacheCollection(aNounMeta, aCacheSize) {</span>
<a href="#l5.177"></a><span id="l5.177" class="difflineplus">+  GlodaCollection.call(this, null, null, null);</span>
<a href="#l5.178"></a><span id="l5.178" class="difflineplus">+  </span>
<a href="#l5.179"></a><span id="l5.179" class="difflineplus">+  this._nounMeta = aNounMeta;</span>
<a href="#l5.180"></a><span id="l5.180" class="difflineplus">+  </span>
<a href="#l5.181"></a><span id="l5.181" class="difflineplus">+  this._head = null; // aka oldest!</span>
<a href="#l5.182"></a><span id="l5.182" class="difflineplus">+  this._tail = null; // aka newest!</span>
<a href="#l5.183"></a><span id="l5.183" class="difflineplus">+  this._size = 0;</span>
<a href="#l5.184"></a><span id="l5.184" class="difflineplus">+  // let's keep things sane, and simplify our logic a little...</span>
<a href="#l5.185"></a><span id="l5.185" class="difflineplus">+  if (aCacheSize &lt; 32)</span>
<a href="#l5.186"></a><span id="l5.186" class="difflineplus">+    aCacheSize = 32;</span>
<a href="#l5.187"></a><span id="l5.187" class="difflineplus">+  this._maxCacheSize = aCacheSize;</span>
<a href="#l5.188"></a><span id="l5.188" class="difflineplus">+}</span>
<a href="#l5.189"></a><span id="l5.189" class="difflineplus">+</span>
<a href="#l5.190"></a><span id="l5.190" class="difflineplus">+GlodaLRUCacheCollection.prototype = new GlodaCollection;</span>
<a href="#l5.191"></a><span id="l5.191" class="difflineplus">+GlodaLRUCacheCollection.prototype.add = function(aItems) {</span>
<a href="#l5.192"></a><span id="l5.192" class="difflineplus">+  for each (let item in aItems) {</span>
<a href="#l5.193"></a><span id="l5.193" class="difflineplus">+    this._idMap[item.id] = item;</span>
<a href="#l5.194"></a><span id="l5.194" class="difflineplus">+    </span>
<a href="#l5.195"></a><span id="l5.195" class="difflineplus">+    item._lruPrev = this._tail;</span>
<a href="#l5.196"></a><span id="l5.196" class="difflineplus">+    // we do have to make sure that we will set _head the first time we insert</span>
<a href="#l5.197"></a><span id="l5.197" class="difflineplus">+    //  something</span>
<a href="#l5.198"></a><span id="l5.198" class="difflineplus">+    if (this._tail !== null)</span>
<a href="#l5.199"></a><span id="l5.199" class="difflineplus">+      this._tail._lruNext = item;</span>
<a href="#l5.200"></a><span id="l5.200" class="difflineplus">+    else</span>
<a href="#l5.201"></a><span id="l5.201" class="difflineplus">+      this._head = item;</span>
<a href="#l5.202"></a><span id="l5.202" class="difflineplus">+    item._lruNext = null;</span>
<a href="#l5.203"></a><span id="l5.203" class="difflineplus">+    this._tail = item;</span>
<a href="#l5.204"></a><span id="l5.204" class="difflineplus">+    </span>
<a href="#l5.205"></a><span id="l5.205" class="difflineplus">+    this._size++;</span>
<a href="#l5.206"></a><span id="l5.206" class="difflineplus">+  }</span>
<a href="#l5.207"></a><span id="l5.207" class="difflineplus">+  </span>
<a href="#l5.208"></a><span id="l5.208" class="difflineplus">+  while (this._size &gt; this._maxCacheSize) {</span>
<a href="#l5.209"></a><span id="l5.209" class="difflineplus">+    let item = this._head;</span>
<a href="#l5.210"></a><span id="l5.210" class="difflineplus">+    </span>
<a href="#l5.211"></a><span id="l5.211" class="difflineplus">+    // we never have to deal with the possibility of needing to make _head/_tail</span>
<a href="#l5.212"></a><span id="l5.212" class="difflineplus">+    //  null.</span>
<a href="#l5.213"></a><span id="l5.213" class="difflineplus">+    this._head = item._lruNext;</span>
<a href="#l5.214"></a><span id="l5.214" class="difflineplus">+    this._head._lruPrev = null;</span>
<a href="#l5.215"></a><span id="l5.215" class="difflineplus">+    // (because we are nice, we will delete the properties...)</span>
<a href="#l5.216"></a><span id="l5.216" class="difflineplus">+    delete item._lruNext;</span>
<a href="#l5.217"></a><span id="l5.217" class="difflineplus">+    delete item._lruPrev;</span>
<a href="#l5.218"></a><span id="l5.218" class="difflineplus">+    </span>
<a href="#l5.219"></a><span id="l5.219" class="difflineplus">+    // nuke from our id map</span>
<a href="#l5.220"></a><span id="l5.220" class="difflineplus">+    delete this._idMap[item.id];</span>
<a href="#l5.221"></a><span id="l5.221" class="difflineplus">+    </span>
<a href="#l5.222"></a><span id="l5.222" class="difflineplus">+    // flush dirty items to disk (they may not have this attribute, in which</span>
<a href="#l5.223"></a><span id="l5.223" class="difflineplus">+    //  case, this returns false, which is fine.)</span>
<a href="#l5.224"></a><span id="l5.224" class="difflineplus">+    if (item.dirty) {</span>
<a href="#l5.225"></a><span id="l5.225" class="difflineplus">+      this._nounMeta.objUpdate.call(this._nounMeta.datastore, item);</span>
<a href="#l5.226"></a><span id="l5.226" class="difflineplus">+      delete item.dirty;</span>
<a href="#l5.227"></a><span id="l5.227" class="difflineplus">+    }</span>
<a href="#l5.228"></a><span id="l5.228" class="difflineplus">+  }</span>
<a href="#l5.229"></a><span id="l5.229" class="difflineplus">+};</span>
<a href="#l5.230"></a><span id="l5.230" class="difflineplus">+</span>
<a href="#l5.231"></a><span id="l5.231" class="difflineplus">+GlodaLRUCacheCollection.prototype.hit = function(aItem) {</span>
<a href="#l5.232"></a><span id="l5.232" class="difflineplus">+  // don't do anything in the 0 or 1 items case</span>
<a href="#l5.233"></a><span id="l5.233" class="difflineplus">+  if (this._head === this._tail)</span>
<a href="#l5.234"></a><span id="l5.234" class="difflineplus">+    return;</span>
<a href="#l5.235"></a><span id="l5.235" class="difflineplus">+</span>
<a href="#l5.236"></a><span id="l5.236" class="difflineplus">+  // unlink the item  </span>
<a href="#l5.237"></a><span id="l5.237" class="difflineplus">+  if (aItem._lruPrev !== null)</span>
<a href="#l5.238"></a><span id="l5.238" class="difflineplus">+    aItem._lruPrev._lruNext = aItem._lruNext;</span>
<a href="#l5.239"></a><span id="l5.239" class="difflineplus">+  if (aItem._lruNext !== null)</span>
<a href="#l5.240"></a><span id="l5.240" class="difflineplus">+    aItem._lruNext._lruPrev = aIrem._lruPrev;</span>
<a href="#l5.241"></a><span id="l5.241" class="difflineplus">+  // link it in to the end</span>
<a href="#l5.242"></a><span id="l5.242" class="difflineplus">+  this._tail._lruNext = aItem; </span>
<a href="#l5.243"></a><span id="l5.243" class="difflineplus">+  aItem._lruPrev = this._tail;</span>
<a href="#l5.244"></a><span id="l5.244" class="difflineplus">+  aItem._lruNext = null;</span>
<a href="#l5.245"></a><span id="l5.245" class="difflineplus">+  // update tail tracking</span>
<a href="#l5.246"></a><span id="l5.246" class="difflineplus">+  this._tail = aItem;</span>
<a href="#l5.247"></a><span id="l5.247" class="difflineplus">+};</span>
<a href="#l5.248"></a><span id="l5.248" class="difflineplus">+</span>
<a href="#l5.249"></a><span id="l5.249" class="difflineplus">+/**</span>
<a href="#l5.250"></a><span id="l5.250" class="difflineplus">+ * If any of the cached items are dirty, commit them, and make them no longer</span>
<a href="#l5.251"></a><span id="l5.251" class="difflineplus">+ *  dirty.</span>
<a href="#l5.252"></a><span id="l5.252" class="difflineplus">+ */</span>
<a href="#l5.253"></a><span id="l5.253" class="difflineplus">+GlodaLRUCacheCollection.prototype.commitDirty = function() {</span>
<a href="#l5.254"></a><span id="l5.254" class="difflineplus">+  // we can only do this if there is an update method available...</span>
<a href="#l5.255"></a><span id="l5.255" class="difflineplus">+  if (!this._nounMeta.objUpdate)</span>
<a href="#l5.256"></a><span id="l5.256" class="difflineplus">+    return;</span>
<a href="#l5.257"></a><span id="l5.257" class="difflineplus">+</span>
<a href="#l5.258"></a><span id="l5.258" class="difflineplus">+  for each (let item in this._idMap) {</span>
<a href="#l5.259"></a><span id="l5.259" class="difflineplus">+    if (item.dirty) {</span>
<a href="#l5.260"></a><span id="l5.260" class="difflineplus">+      this._nounMeta.objUpdate.call(this._nounMeta.datastore, item);</span>
<a href="#l5.261"></a><span id="l5.261" class="difflineplus">+      delete item.dirty;</span>
<a href="#l5.262"></a><span id="l5.262" class="difflineplus">+    }</span>
<a href="#l5.263"></a><span id="l5.263" class="difflineplus">+  }</span>
<a href="#l5.264"></a><span id="l5.264" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -30,17 +30,18 @@</span>
<a href="#l6.4"></a><span id="l6.4">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l6.5"></a><span id="l6.5">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l6.6"></a><span id="l6.6">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l6.7"></a><span id="l6.7">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l6.8"></a><span id="l6.8">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l6.9"></a><span id="l6.9">  *</span>
<a href="#l6.10"></a><span id="l6.10">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-EXPORTED_SYMBOLS = [&quot;GlodaAttributeDef&quot;, &quot;GlodaConversation&quot;, &quot;GlodaMessage&quot;,</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+EXPORTED_SYMBOLS = [&quot;GlodaAttributeDef&quot;,</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+                    &quot;GlodaConversation&quot;, &quot;GlodaMessage&quot;,</span>
<a href="#l6.15"></a><span id="l6.15">                     &quot;GlodaContact&quot;, &quot;GlodaIdentity&quot;];</span>
<a href="#l6.16"></a><span id="l6.16"> </span>
<a href="#l6.17"></a><span id="l6.17"> const Cc = Components.classes;</span>
<a href="#l6.18"></a><span id="l6.18"> const Ci = Components.interfaces;</span>
<a href="#l6.19"></a><span id="l6.19"> const Cr = Components.results;</span>
<a href="#l6.20"></a><span id="l6.20"> const Cu = Components.utils;</span>
<a href="#l6.21"></a><span id="l6.21"> </span>
<a href="#l6.22"></a><span id="l6.22"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineat">@@ -60,34 +61,36 @@ function GlodaAttributeDef(aDatastore, a</span>
<a href="#l6.24"></a><span id="l6.24">   this._subjectTypes = aSubjectTypes;</span>
<a href="#l6.25"></a><span id="l6.25">   this._objectType = aObjectType;</span>
<a href="#l6.26"></a><span id="l6.26">   this._objectNounMeta = aObjectNounMeta;</span>
<a href="#l6.27"></a><span id="l6.27">   this._explanationFormat = aExplanationFormat;</span>
<a href="#l6.28"></a><span id="l6.28">   </span>
<a href="#l6.29"></a><span id="l6.29">   this._boundName = null;</span>
<a href="#l6.30"></a><span id="l6.30">   this._singular = null;</span>
<a href="#l6.31"></a><span id="l6.31">   </span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+  this._special = 0; // not special</span>
<a href="#l6.33"></a><span id="l6.33">   this._specialColumnName = null;</span>
<a href="#l6.34"></a><span id="l6.34">   </span>
<a href="#l6.35"></a><span id="l6.35">   /** Map parameter values to the underlying database id. */</span>
<a href="#l6.36"></a><span id="l6.36">   this._parameterBindings = {};</span>
<a href="#l6.37"></a><span id="l6.37"> }</span>
<a href="#l6.38"></a><span id="l6.38"> </span>
<a href="#l6.39"></a><span id="l6.39"> GlodaAttributeDef.prototype = {</span>
<a href="#l6.40"></a><span id="l6.40">   get id() { return this._id; },</span>
<a href="#l6.41"></a><span id="l6.41">   get provider() { return this._provider; },</span>
<a href="#l6.42"></a><span id="l6.42">   get attributeName() { return this._attrName; },</span>
<a href="#l6.43"></a><span id="l6.43"> </span>
<a href="#l6.44"></a><span id="l6.44">   get objectNoun() { return this._objectType; },</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+  get objectNounMeta() { return this._objectNounMeta; },</span>
<a href="#l6.46"></a><span id="l6.46"> </span>
<a href="#l6.47"></a><span id="l6.47">   get isBound() { return this._boundName !== null; },</span>
<a href="#l6.48"></a><span id="l6.48">   get boundName() { return this._boundName; },</span>
<a href="#l6.49"></a><span id="l6.49">   get singular() { return this._singular; },</span>
<a href="#l6.50"></a><span id="l6.50">   </span>
<a href="#l6.51"></a><span id="l6.51" class="difflineminus">-  get isSpecial() { return this._specialColumnName !== null; },</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineplus">+  get special() { return this._special; },</span>
<a href="#l6.53"></a><span id="l6.53">   get specialColumnName() { return this._specialColumnName; },</span>
<a href="#l6.54"></a><span id="l6.54"> </span>
<a href="#l6.55"></a><span id="l6.55">   /**</span>
<a href="#l6.56"></a><span id="l6.56">    * Bind a parameter value to the attribute definition, allowing use of the</span>
<a href="#l6.57"></a><span id="l6.57">    *  attribute-parameter as an attribute.</span>
<a href="#l6.58"></a><span id="l6.58">    *</span>
<a href="#l6.59"></a><span id="l6.59">    * @return </span>
<a href="#l6.60"></a><span id="l6.60">    */</span>
<a href="#l6.61"></a><span id="l6.61" class="difflineat">@@ -349,30 +352,47 @@ GlodaMessage.prototype = {</span>
<a href="#l6.62"></a><span id="l6.62">     let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l6.63"></a><span id="l6.63">     if (instances.length &gt; 0)</span>
<a href="#l6.64"></a><span id="l6.64">       return instances[0];</span>
<a href="#l6.65"></a><span id="l6.65">     else</span>
<a href="#l6.66"></a><span id="l6.66">       return null;</span>
<a href="#l6.67"></a><span id="l6.67">   },</span>
<a href="#l6.68"></a><span id="l6.68"> };</span>
<a href="#l6.69"></a><span id="l6.69"> </span>
<a href="#l6.70"></a><span id="l6.70" class="difflineminus">-function GlodaContact(aDatastore, aID, aDirectoryUUID, aContactUUID, aName) {</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+function GlodaContact(aDatastore, aID, aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+                      aPopularity, aFrecency) {</span>
<a href="#l6.73"></a><span id="l6.73">   this._datastore = aDatastore;</span>
<a href="#l6.74"></a><span id="l6.74">   this._id = aID;</span>
<a href="#l6.75"></a><span id="l6.75">   this._directoryUUID = aDirectoryUUID;</span>
<a href="#l6.76"></a><span id="l6.76">   this._contactUUID = aContactUUID;</span>
<a href="#l6.77"></a><span id="l6.77">   this._name = aName;</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineplus">+  this._popularity = aPopularity;</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineplus">+  this._frecency = aFrecency;</span>
<a href="#l6.80"></a><span id="l6.80"> }</span>
<a href="#l6.81"></a><span id="l6.81"> </span>
<a href="#l6.82"></a><span id="l6.82"> GlodaContact.prototype = {</span>
<a href="#l6.83"></a><span id="l6.83" class="difflineplus">+  NOUN_ID: 103,</span>
<a href="#l6.84"></a><span id="l6.84" class="difflineplus">+</span>
<a href="#l6.85"></a><span id="l6.85">   get id() { return this._id; },</span>
<a href="#l6.86"></a><span id="l6.86">   get directoryUUID() { return this._directoryUUID; },</span>
<a href="#l6.87"></a><span id="l6.87">   get contactUUID() { return this._contactUUID; },</span>
<a href="#l6.88"></a><span id="l6.88">   get name() { return this._name },</span>
<a href="#l6.89"></a><span id="l6.89">   </span>
<a href="#l6.90"></a><span id="l6.90" class="difflineplus">+  get popularity() { return this._popularity; },</span>
<a href="#l6.91"></a><span id="l6.91" class="difflineplus">+  set popularity(aPopularity) {</span>
<a href="#l6.92"></a><span id="l6.92" class="difflineplus">+    this.popularity = aPopularity;</span>
<a href="#l6.93"></a><span id="l6.93" class="difflineplus">+    this.dirty = true;</span>
<a href="#l6.94"></a><span id="l6.94" class="difflineplus">+  },</span>
<a href="#l6.95"></a><span id="l6.95" class="difflineplus">+</span>
<a href="#l6.96"></a><span id="l6.96" class="difflineplus">+  get frecency() { return this._frecency; },</span>
<a href="#l6.97"></a><span id="l6.97" class="difflineplus">+  set frecency(aFrecency) {</span>
<a href="#l6.98"></a><span id="l6.98" class="difflineplus">+    this._frecency = aFrecency;</span>
<a href="#l6.99"></a><span id="l6.99" class="difflineplus">+    this.dirty = true;</span>
<a href="#l6.100"></a><span id="l6.100" class="difflineplus">+  },</span>
<a href="#l6.101"></a><span id="l6.101" class="difflineplus">+  </span>
<a href="#l6.102"></a><span id="l6.102">   toString: function gloda_contact_toString() {</span>
<a href="#l6.103"></a><span id="l6.103">     return this._name;</span>
<a href="#l6.104"></a><span id="l6.104">   }</span>
<a href="#l6.105"></a><span id="l6.105"> };</span>
<a href="#l6.106"></a><span id="l6.106"> </span>
<a href="#l6.107"></a><span id="l6.107"> function GlodaIdentity(aDatastore, aID, aContactID, aContact, aKind, aValue,</span>
<a href="#l6.108"></a><span id="l6.108">                        aIsRelay) {</span>
<a href="#l6.109"></a><span id="l6.109">   this._datastore = aDatastore;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -83,16 +83,20 @@ let GlodaDatastore = {</span>
<a href="#l7.4"></a><span id="l7.4">         ],</span>
<a href="#l7.5"></a><span id="l7.5">         </span>
<a href="#l7.6"></a><span id="l7.6">         indices: {</span>
<a href="#l7.7"></a><span id="l7.7">           subject: ['subject'],</span>
<a href="#l7.8"></a><span id="l7.8">           oldestMessageDate: ['oldestMessageDate'],</span>
<a href="#l7.9"></a><span id="l7.9">           newestMessageDate: ['newestMessageDate'],</span>
<a href="#l7.10"></a><span id="l7.10">         },</span>
<a href="#l7.11"></a><span id="l7.11">         </span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+        fulltextColumns: [</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+          &quot;subject TEXT&quot;,</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+        ],</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+        </span>
<a href="#l7.16"></a><span id="l7.16">         triggers: {</span>
<a href="#l7.17"></a><span id="l7.17">           delete: &quot;DELETE from messages WHERE conversationID = OLD.id&quot;,</span>
<a href="#l7.18"></a><span id="l7.18">         },</span>
<a href="#l7.19"></a><span id="l7.19">       },</span>
<a href="#l7.20"></a><span id="l7.20">       </span>
<a href="#l7.21"></a><span id="l7.21">       /**</span>
<a href="#l7.22"></a><span id="l7.22">        * A message record correspond to an actual message stored in a folder</span>
<a href="#l7.23"></a><span id="l7.23">        *  somewhere, or is a ghost record indicating a message that we know</span>
<a href="#l7.24"></a><span id="l7.24" class="difflineat">@@ -107,26 +111,29 @@ let GlodaDatastore = {</span>
<a href="#l7.25"></a><span id="l7.25">           &quot;folderID INTEGER REFERENCES folderLocations(id)&quot;,</span>
<a href="#l7.26"></a><span id="l7.26">           &quot;messageKey INTEGER&quot;,</span>
<a href="#l7.27"></a><span id="l7.27">           &quot;conversationID INTEGER NOT NULL REFERENCES conversations(id)&quot;,</span>
<a href="#l7.28"></a><span id="l7.28">           &quot;date INTEGER&quot;,</span>
<a href="#l7.29"></a><span id="l7.29">           // we used to have the parentID, but because of the very real</span>
<a href="#l7.30"></a><span id="l7.30">           //  possibility of multiple copies of a message with a given</span>
<a href="#l7.31"></a><span id="l7.31">           //  message-id, the parentID concept is unreliable.</span>
<a href="#l7.32"></a><span id="l7.32">           &quot;headerMessageID TEXT&quot;,</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineminus">-          &quot;bodySnippet TEXT&quot;,</span>
<a href="#l7.34"></a><span id="l7.34">         ],</span>
<a href="#l7.35"></a><span id="l7.35">         </span>
<a href="#l7.36"></a><span id="l7.36">         indices: {</span>
<a href="#l7.37"></a><span id="l7.37">           messageLocation: ['folderID', 'messageKey'],</span>
<a href="#l7.38"></a><span id="l7.38">           headerMessageID: ['headerMessageID'],</span>
<a href="#l7.39"></a><span id="l7.39">           conversationID: ['conversationID'],</span>
<a href="#l7.40"></a><span id="l7.40">           date: ['date'],</span>
<a href="#l7.41"></a><span id="l7.41">         },</span>
<a href="#l7.42"></a><span id="l7.42">         </span>
<a href="#l7.43"></a><span id="l7.43" class="difflineplus">+        fulltextColumns: [</span>
<a href="#l7.44"></a><span id="l7.44" class="difflineplus">+          &quot;body TEXT&quot;,</span>
<a href="#l7.45"></a><span id="l7.45" class="difflineplus">+        ],</span>
<a href="#l7.46"></a><span id="l7.46" class="difflineplus">+        </span>
<a href="#l7.47"></a><span id="l7.47">         triggers: {</span>
<a href="#l7.48"></a><span id="l7.48">           delete: &quot;DELETE FROM messageAttributes WHERE messageID = OLD.id&quot;,</span>
<a href="#l7.49"></a><span id="l7.49">         },</span>
<a href="#l7.50"></a><span id="l7.50">       },</span>
<a href="#l7.51"></a><span id="l7.51">       </span>
<a href="#l7.52"></a><span id="l7.52">       // ----- Attributes</span>
<a href="#l7.53"></a><span id="l7.53">       attributeDefinitions: {</span>
<a href="#l7.54"></a><span id="l7.54">         columns: [</span>
<a href="#l7.55"></a><span id="l7.55" class="difflineat">@@ -233,34 +240,36 @@ let GlodaDatastore = {</span>
<a href="#l7.56"></a><span id="l7.56">     // Create the file if it does not exist</span>
<a href="#l7.57"></a><span id="l7.57">     if (!dbFile.exists()) {</span>
<a href="#l7.58"></a><span id="l7.58">       dbConnection = this._createDB(dbService, dbFile);</span>
<a href="#l7.59"></a><span id="l7.59">     }</span>
<a href="#l7.60"></a><span id="l7.60">     // It does exist, but we (someday) might need to upgrade the schema</span>
<a href="#l7.61"></a><span id="l7.61">     else {</span>
<a href="#l7.62"></a><span id="l7.62">       // (Exceptions may be thrown if the database is corrupt)</span>
<a href="#l7.63"></a><span id="l7.63">       { // try {</span>
<a href="#l7.64"></a><span id="l7.64" class="difflineminus">-        dbConnection = dbService.openDatabase(dbFile);</span>
<a href="#l7.65"></a><span id="l7.65" class="difflineplus">+        dbConnection = dbService.openUnsharedDatabase(dbFile);</span>
<a href="#l7.66"></a><span id="l7.66">       </span>
<a href="#l7.67"></a><span id="l7.67">         if (dbConnection.schemaVersion != this._schemaVersion) {</span>
<a href="#l7.68"></a><span id="l7.68" class="difflineminus">-          this._migrate(dbConnection,</span>
<a href="#l7.69"></a><span id="l7.69" class="difflineminus">-                        dbConnection.schemaVersion, this._schemaVersion);</span>
<a href="#l7.70"></a><span id="l7.70" class="difflineplus">+          dbConnection = this._migrate(dbService, dbFile,</span>
<a href="#l7.71"></a><span id="l7.71" class="difflineplus">+                                       dbConnection,</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineplus">+                                       dbConnection.schemaVersion,</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineplus">+                                       this._schemaVersion);</span>
<a href="#l7.74"></a><span id="l7.74">         }</span>
<a href="#l7.75"></a><span id="l7.75">       }</span>
<a href="#l7.76"></a><span id="l7.76">       // Handle corrupt databases, other oddities</span>
<a href="#l7.77"></a><span id="l7.77">       // ... in the future. for now, let us die</span>
<a href="#l7.78"></a><span id="l7.78">     }</span>
<a href="#l7.79"></a><span id="l7.79">     </span>
<a href="#l7.80"></a><span id="l7.80">     this.dbConnection = dbConnection;</span>
<a href="#l7.81"></a><span id="l7.81">     </span>
<a href="#l7.82"></a><span id="l7.82">     this._getAllFolderMappings();</span>
<a href="#l7.83"></a><span id="l7.83">   },</span>
<a href="#l7.84"></a><span id="l7.84">   </span>
<a href="#l7.85"></a><span id="l7.85">   _createDB: function gloda_ds_createDB(aDBService, aDBFile) {</span>
<a href="#l7.86"></a><span id="l7.86" class="difflineminus">-    var dbConnection = aDBService.openDatabase(aDBFile);</span>
<a href="#l7.87"></a><span id="l7.87" class="difflineplus">+    var dbConnection = aDBService.openUnsharedDatabase(aDBFile);</span>
<a href="#l7.88"></a><span id="l7.88">     </span>
<a href="#l7.89"></a><span id="l7.89">     dbConnection.beginTransaction();</span>
<a href="#l7.90"></a><span id="l7.90">     try {</span>
<a href="#l7.91"></a><span id="l7.91">       this._createSchema(dbConnection);</span>
<a href="#l7.92"></a><span id="l7.92">       dbConnection.commitTransaction();</span>
<a href="#l7.93"></a><span id="l7.93">     }</span>
<a href="#l7.94"></a><span id="l7.94">     catch(ex) {</span>
<a href="#l7.95"></a><span id="l7.95">       dbConnection.rollbackTransaction();</span>
<a href="#l7.96"></a><span id="l7.96" class="difflineat">@@ -273,16 +282,24 @@ let GlodaDatastore = {</span>
<a href="#l7.97"></a><span id="l7.97">   _createSchema: function gloda_ds_createSchema(aDBConnection) {</span>
<a href="#l7.98"></a><span id="l7.98">     // -- For each table...</span>
<a href="#l7.99"></a><span id="l7.99">     for (let tableName in this._schema.tables) {</span>
<a href="#l7.100"></a><span id="l7.100">       let table = this._schema.tables[tableName];</span>
<a href="#l7.101"></a><span id="l7.101">       </span>
<a href="#l7.102"></a><span id="l7.102">       // - Create the table</span>
<a href="#l7.103"></a><span id="l7.103">       aDBConnection.createTable(tableName, table.columns.join(&quot;, &quot;));</span>
<a href="#l7.104"></a><span id="l7.104">       </span>
<a href="#l7.105"></a><span id="l7.105" class="difflineplus">+      // - Create the fulltext table if applicable</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineplus">+      if (&quot;fulltextColumns&quot; in table) {</span>
<a href="#l7.107"></a><span id="l7.107" class="difflineplus">+        let createFulltextSQL = &quot;CREATE VIRTUAL TABLE &quot; + tableName + &quot;Text&quot; +</span>
<a href="#l7.108"></a><span id="l7.108" class="difflineplus">+          &quot; USING fts3(TOKENIZE PORTER, &quot; + table.fulltextColumns.join(&quot;, &quot;) +</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineplus">+          &quot;)&quot;;</span>
<a href="#l7.110"></a><span id="l7.110" class="difflineplus">+        aDBConnection.executeSimpleSQL(createFulltextSQL);</span>
<a href="#l7.111"></a><span id="l7.111" class="difflineplus">+      }</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineplus">+      </span>
<a href="#l7.113"></a><span id="l7.113">       // - Create its indices</span>
<a href="#l7.114"></a><span id="l7.114">       for (let indexName in table.indices) {</span>
<a href="#l7.115"></a><span id="l7.115">         let indexColumns = table.indices[indexName];</span>
<a href="#l7.116"></a><span id="l7.116">         </span>
<a href="#l7.117"></a><span id="l7.117">         aDBConnection.executeSimpleSQL(</span>
<a href="#l7.118"></a><span id="l7.118">           &quot;CREATE INDEX &quot; + indexName + &quot; ON &quot; + tableName +</span>
<a href="#l7.119"></a><span id="l7.119">           &quot;(&quot; + indexColumns.join(&quot;, &quot;) + &quot;)&quot;); </span>
<a href="#l7.120"></a><span id="l7.120">       }</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineat">@@ -329,20 +346,26 @@ let GlodaDatastore = {</span>
<a href="#l7.122"></a><span id="l7.122">         }</span>
<a href="#l7.123"></a><span id="l7.123">       }</span>
<a href="#l7.124"></a><span id="l7.124">     }</span>
<a href="#l7.125"></a><span id="l7.125">     testTableStmt.reset();</span>
<a href="#l7.126"></a><span id="l7.126">     </span>
<a href="#l7.127"></a><span id="l7.127">     return new GlodaDatabind(aTableDef, this);</span>
<a href="#l7.128"></a><span id="l7.128">   },</span>
<a href="#l7.129"></a><span id="l7.129">   </span>
<a href="#l7.130"></a><span id="l7.130" class="difflineminus">-  _migrate: function gloda_ds_migrate(aDBConnection, aCurVersion, aNewVersion) {</span>
<a href="#l7.131"></a><span id="l7.131" class="difflineminus">-    let msg = &quot;We currently aren't clever enough to migrate. Delete your DB.&quot;</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineminus">-    this._log.error(msg)</span>
<a href="#l7.133"></a><span id="l7.133" class="difflineminus">-    throw new Error(msg);</span>
<a href="#l7.134"></a><span id="l7.134" class="difflineplus">+  _migrate: function gloda_ds_migrate(aDBService, aDBFile, aDBConnection,</span>
<a href="#l7.135"></a><span id="l7.135" class="difflineplus">+                                      aCurVersion, aNewVersion) {</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineplus">+    // the 4-to-5 migration is the only possible case right now, and is so</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineplus">+    //  significant that we want everything purged anyways.</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineplus">+    // generalize me in the future.</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineplus">+    aDBConnection.close();</span>
<a href="#l7.140"></a><span id="l7.140" class="difflineplus">+    aDBFile.remove();</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+    this._log.warning(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineplus">+    </span>
<a href="#l7.143"></a><span id="l7.143" class="difflineplus">+    return this._createDB(aDBService, aDBFile);</span>
<a href="#l7.144"></a><span id="l7.144">   },</span>
<a href="#l7.145"></a><span id="l7.145">   </span>
<a href="#l7.146"></a><span id="l7.146">   // cribbed from snowl</span>
<a href="#l7.147"></a><span id="l7.147">   _createStatement: function gloda_ds_createStatement(aSQLString) {</span>
<a href="#l7.148"></a><span id="l7.148">     let statement = null;</span>
<a href="#l7.149"></a><span id="l7.149">     try {</span>
<a href="#l7.150"></a><span id="l7.150">       statement = this.dbConnection.createStatement(aSQLString);</span>
<a href="#l7.151"></a><span id="l7.151">     }</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineat">@@ -604,29 +627,47 @@ let GlodaDatastore = {</span>
<a href="#l7.153"></a><span id="l7.153">   get _insertConversationStatement() {</span>
<a href="#l7.154"></a><span id="l7.154">     let statement = this._createStatement(</span>
<a href="#l7.155"></a><span id="l7.155">       &quot;INSERT INTO conversations (subject, oldestMessageDate, \</span>
<a href="#l7.156"></a><span id="l7.156">                                   newestMessageDate) \</span>
<a href="#l7.157"></a><span id="l7.157">               VALUES (:subject, :oldestMessageDate, :newestMessageDate)&quot;);</span>
<a href="#l7.158"></a><span id="l7.158">     this.__defineGetter__(&quot;_insertConversationStatement&quot;, function() statement);</span>
<a href="#l7.159"></a><span id="l7.159">     return this._insertConversationStatement; </span>
<a href="#l7.160"></a><span id="l7.160">   }, </span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineplus">+  get _insertConversationTextStatement() {</span>
<a href="#l7.163"></a><span id="l7.163" class="difflineplus">+    let statement = this._createStatement(</span>
<a href="#l7.164"></a><span id="l7.164" class="difflineplus">+      &quot;INSERT INTO conversationsText (docid, subject) \</span>
<a href="#l7.165"></a><span id="l7.165" class="difflineplus">+              VALUES (:docid, :subject)&quot;);</span>
<a href="#l7.166"></a><span id="l7.166" class="difflineplus">+    this.__defineGetter__(&quot;_insertConversationTextStatement&quot;,</span>
<a href="#l7.167"></a><span id="l7.167" class="difflineplus">+      function() statement);</span>
<a href="#l7.168"></a><span id="l7.168" class="difflineplus">+    return this._insertConversationTextStatement; </span>
<a href="#l7.169"></a><span id="l7.169" class="difflineplus">+  }, </span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+</span>
<a href="#l7.171"></a><span id="l7.171">   </span>
<a href="#l7.172"></a><span id="l7.172">   /** Create a conversation. */</span>
<a href="#l7.173"></a><span id="l7.173">   createConversation: function gloda_ds_createConversation(aSubject,</span>
<a href="#l7.174"></a><span id="l7.174">         aOldestMessageDate, aNewestMessageDate) {</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineminus">-    </span>
<a href="#l7.176"></a><span id="l7.176" class="difflineplus">+</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+    // create the data row    </span>
<a href="#l7.178"></a><span id="l7.178">     let ics = this._insertConversationStatement;</span>
<a href="#l7.179"></a><span id="l7.179">     ics.params.subject = aSubject;</span>
<a href="#l7.180"></a><span id="l7.180">     ics.params.oldestMessageDate = aOldestMessageDate;</span>
<a href="#l7.181"></a><span id="l7.181">     ics.params.newestMessageDate = aNewestMessageDate;</span>
<a href="#l7.182"></a><span id="l7.182" class="difflineminus">-        </span>
<a href="#l7.183"></a><span id="l7.183">     ics.execute();</span>
<a href="#l7.184"></a><span id="l7.184">     </span>
<a href="#l7.185"></a><span id="l7.185" class="difflineminus">-    return new GlodaConversation(this, this.dbConnection.lastInsertRowID,</span>
<a href="#l7.186"></a><span id="l7.186" class="difflineplus">+    let conversationID = this.dbConnection.lastInsertRowID; </span>
<a href="#l7.187"></a><span id="l7.187" class="difflineplus">+    </span>
<a href="#l7.188"></a><span id="l7.188" class="difflineplus">+    // create the fulltext row, using the same rowid/docid</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineplus">+    let icts = this._insertConversationTextStatement;</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineplus">+    icts.params.docid = conversationID;</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineplus">+    icts.params.subject = aSubject;</span>
<a href="#l7.192"></a><span id="l7.192" class="difflineplus">+    icts.execute();</span>
<a href="#l7.193"></a><span id="l7.193" class="difflineplus">+    </span>
<a href="#l7.194"></a><span id="l7.194" class="difflineplus">+    return new GlodaConversation(this, conversationID,</span>
<a href="#l7.195"></a><span id="l7.195">                                  aSubject, aOldestMessageDate,</span>
<a href="#l7.196"></a><span id="l7.196">                                  aNewestMessageDate);</span>
<a href="#l7.197"></a><span id="l7.197">   },</span>
<a href="#l7.198"></a><span id="l7.198"> </span>
<a href="#l7.199"></a><span id="l7.199">   get _deleteConversationByIDStatement() {</span>
<a href="#l7.200"></a><span id="l7.200">     let statement = this._createStatement(</span>
<a href="#l7.201"></a><span id="l7.201">       &quot;DELETE FROM conversations WHERE id = :conversationID&quot;);</span>
<a href="#l7.202"></a><span id="l7.202">     this.__defineGetter__(&quot;_deleteConversationByIDStatement&quot;,</span>
<a href="#l7.203"></a><span id="l7.203" class="difflineat">@@ -662,83 +703,120 @@ let GlodaDatastore = {</span>
<a href="#l7.204"></a><span id="l7.204">     </span>
<a href="#l7.205"></a><span id="l7.205">     return conversation;</span>
<a href="#l7.206"></a><span id="l7.206">   },</span>
<a href="#l7.207"></a><span id="l7.207">   </span>
<a href="#l7.208"></a><span id="l7.208">   /* ********** Message ********** */</span>
<a href="#l7.209"></a><span id="l7.209">   get _insertMessageStatement() {</span>
<a href="#l7.210"></a><span id="l7.210">     let statement = this._createStatement(</span>
<a href="#l7.211"></a><span id="l7.211">       &quot;INSERT INTO messages (folderID, messageKey, conversationID, date, \</span>
<a href="#l7.212"></a><span id="l7.212" class="difflineminus">-                             headerMessageID, bodySnippet) \</span>
<a href="#l7.213"></a><span id="l7.213" class="difflineplus">+                             headerMessageID) \</span>
<a href="#l7.214"></a><span id="l7.214">               VALUES (:folderID, :messageKey, :conversationID, :date, \</span>
<a href="#l7.215"></a><span id="l7.215" class="difflineminus">-                      :headerMessageID, :bodySnippet)&quot;);</span>
<a href="#l7.216"></a><span id="l7.216" class="difflineplus">+                      :headerMessageID)&quot;);</span>
<a href="#l7.217"></a><span id="l7.217">     this.__defineGetter__(&quot;_insertMessageStatement&quot;, function() statement);</span>
<a href="#l7.218"></a><span id="l7.218">     return this._insertMessageStatement; </span>
<a href="#l7.219"></a><span id="l7.219">   }, </span>
<a href="#l7.220"></a><span id="l7.220" class="difflineplus">+</span>
<a href="#l7.221"></a><span id="l7.221" class="difflineplus">+  get _insertMessageTextStatement() {</span>
<a href="#l7.222"></a><span id="l7.222" class="difflineplus">+    let statement = this._createStatement(</span>
<a href="#l7.223"></a><span id="l7.223" class="difflineplus">+      &quot;INSERT INTO messagesText (docid, body) \</span>
<a href="#l7.224"></a><span id="l7.224" class="difflineplus">+              VALUES (:docid, :body)&quot;);</span>
<a href="#l7.225"></a><span id="l7.225" class="difflineplus">+    this.__defineGetter__(&quot;_insertMessageTextStatement&quot;, function() statement);</span>
<a href="#l7.226"></a><span id="l7.226" class="difflineplus">+    return this._insertMessageTextStatement; </span>
<a href="#l7.227"></a><span id="l7.227" class="difflineplus">+  },</span>
<a href="#l7.228"></a><span id="l7.228">   </span>
<a href="#l7.229"></a><span id="l7.229">   /**</span>
<a href="#l7.230"></a><span id="l7.230">    *</span>
<a href="#l7.231"></a><span id="l7.231">    */</span>
<a href="#l7.232"></a><span id="l7.232">   createMessage: function gloda_ds_createMessage(aFolderURI, aMessageKey,</span>
<a href="#l7.233"></a><span id="l7.233">                               aConversationID, aDatePRTime, aHeaderMessageID,</span>
<a href="#l7.234"></a><span id="l7.234" class="difflineminus">-                              aBodySnippet) {</span>
<a href="#l7.235"></a><span id="l7.235" class="difflineplus">+                              aBody) {</span>
<a href="#l7.236"></a><span id="l7.236">     let folderID;</span>
<a href="#l7.237"></a><span id="l7.237">     if (aFolderURI != null) {</span>
<a href="#l7.238"></a><span id="l7.238">       folderID = this._mapFolderURI(aFolderURI);</span>
<a href="#l7.239"></a><span id="l7.239">     }</span>
<a href="#l7.240"></a><span id="l7.240">     else {</span>
<a href="#l7.241"></a><span id="l7.241">       folderID = null;</span>
<a href="#l7.242"></a><span id="l7.242">     }</span>
<a href="#l7.243"></a><span id="l7.243">     </span>
<a href="#l7.244"></a><span id="l7.244">     let ims = this._insertMessageStatement;</span>
<a href="#l7.245"></a><span id="l7.245">     ims.params.folderID = folderID;</span>
<a href="#l7.246"></a><span id="l7.246">     ims.params.messageKey = aMessageKey;</span>
<a href="#l7.247"></a><span id="l7.247">     ims.params.conversationID = aConversationID;</span>
<a href="#l7.248"></a><span id="l7.248">     ims.params.date = aDatePRTime;</span>
<a href="#l7.249"></a><span id="l7.249">     ims.params.headerMessageID = aHeaderMessageID;</span>
<a href="#l7.250"></a><span id="l7.250" class="difflineminus">-    ims.params.bodySnippet = aBodySnippet;</span>
<a href="#l7.251"></a><span id="l7.251"> </span>
<a href="#l7.252"></a><span id="l7.252">     try {</span>
<a href="#l7.253"></a><span id="l7.253">        ims.execute();</span>
<a href="#l7.254"></a><span id="l7.254">     }</span>
<a href="#l7.255"></a><span id="l7.255">     catch(ex) {</span>
<a href="#l7.256"></a><span id="l7.256">        throw(&quot;error executing statement... &quot; +</span>
<a href="#l7.257"></a><span id="l7.257">              this.dbConnection.lastError + &quot;: &quot; +</span>
<a href="#l7.258"></a><span id="l7.258">              this.dbConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l7.259"></a><span id="l7.259">     }</span>
<a href="#l7.260"></a><span id="l7.260" class="difflineminus">-    //ims.execute();</span>
<a href="#l7.261"></a><span id="l7.261" class="difflineplus">+    </span>
<a href="#l7.262"></a><span id="l7.262" class="difflineplus">+    let messageID = this.dbConnection.lastInsertRowID;</span>
<a href="#l7.263"></a><span id="l7.263">     </span>
<a href="#l7.264"></a><span id="l7.264" class="difflineminus">-    return new GlodaMessage(this, this.dbConnection.lastInsertRowID, folderID,</span>
<a href="#l7.265"></a><span id="l7.265" class="difflineplus">+    // we only create the full-text row if the body is non-null.</span>
<a href="#l7.266"></a><span id="l7.266" class="difflineplus">+    // so, even though body might be null, we still want to create the</span>
<a href="#l7.267"></a><span id="l7.267" class="difflineplus">+    //  full-text search row</span>
<a href="#l7.268"></a><span id="l7.268" class="difflineplus">+    if (aBody) {</span>
<a href="#l7.269"></a><span id="l7.269" class="difflineplus">+      let imts = this._insertMessageTextStatement;</span>
<a href="#l7.270"></a><span id="l7.270" class="difflineplus">+      imts.params.docid = messageID;</span>
<a href="#l7.271"></a><span id="l7.271" class="difflineplus">+      imts.params.body = aBody;</span>
<a href="#l7.272"></a><span id="l7.272" class="difflineplus">+      </span>
<a href="#l7.273"></a><span id="l7.273" class="difflineplus">+      try {</span>
<a href="#l7.274"></a><span id="l7.274" class="difflineplus">+         imts.execute();</span>
<a href="#l7.275"></a><span id="l7.275" class="difflineplus">+      }</span>
<a href="#l7.276"></a><span id="l7.276" class="difflineplus">+      catch(ex) {</span>
<a href="#l7.277"></a><span id="l7.277" class="difflineplus">+         throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l7.278"></a><span id="l7.278" class="difflineplus">+               this.dbConnection.lastError + &quot;: &quot; +</span>
<a href="#l7.279"></a><span id="l7.279" class="difflineplus">+               this.dbConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l7.280"></a><span id="l7.280" class="difflineplus">+      }</span>
<a href="#l7.281"></a><span id="l7.281" class="difflineplus">+    }</span>
<a href="#l7.282"></a><span id="l7.282" class="difflineplus">+    </span>
<a href="#l7.283"></a><span id="l7.283" class="difflineplus">+    return new GlodaMessage(this, messageID, folderID,</span>
<a href="#l7.284"></a><span id="l7.284">                             aMessageKey, aConversationID, null,</span>
<a href="#l7.285"></a><span id="l7.285">                             aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l7.286"></a><span id="l7.286" class="difflineminus">-                            aHeaderMessageID, aBodySnippet);</span>
<a href="#l7.287"></a><span id="l7.287" class="difflineplus">+                            aHeaderMessageID);</span>
<a href="#l7.288"></a><span id="l7.288">   },</span>
<a href="#l7.289"></a><span id="l7.289">   </span>
<a href="#l7.290"></a><span id="l7.290">   get _updateMessageStatement() {</span>
<a href="#l7.291"></a><span id="l7.291">     let statement = this._createStatement(</span>
<a href="#l7.292"></a><span id="l7.292">       &quot;UPDATE messages SET folderID = :folderID, \</span>
<a href="#l7.293"></a><span id="l7.293">                            messageKey = :messageKey, \</span>
<a href="#l7.294"></a><span id="l7.294">                            conversationID = :conversationID, \</span>
<a href="#l7.295"></a><span id="l7.295">                            headerMessageID = :headerMessageID, \</span>
<a href="#l7.296"></a><span id="l7.296" class="difflineminus">-                           bodySnippet = :bodySnippet \</span>
<a href="#l7.297"></a><span id="l7.297">               WHERE id = :id&quot;);</span>
<a href="#l7.298"></a><span id="l7.298">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l7.299"></a><span id="l7.299">     return this._updateMessageStatement; </span>
<a href="#l7.300"></a><span id="l7.300">   }, </span>
<a href="#l7.301"></a><span id="l7.301">   </span>
<a href="#l7.302"></a><span id="l7.302" class="difflineminus">-  updateMessage: function gloda_ds_updateMessage(aMessage) {</span>
<a href="#l7.303"></a><span id="l7.303" class="difflineplus">+  /**</span>
<a href="#l7.304"></a><span id="l7.304" class="difflineplus">+   * Update the database row associated with the message.  If aBody is supplied,</span>
<a href="#l7.305"></a><span id="l7.305" class="difflineplus">+   *  the associated full-text row is created; it is assumed that it did not</span>
<a href="#l7.306"></a><span id="l7.306" class="difflineplus">+   *  previously exist.</span>
<a href="#l7.307"></a><span id="l7.307" class="difflineplus">+   */</span>
<a href="#l7.308"></a><span id="l7.308" class="difflineplus">+  updateMessage: function gloda_ds_updateMessage(aMessage, aBody) {</span>
<a href="#l7.309"></a><span id="l7.309">     let ums = this._updateMessageStatement;</span>
<a href="#l7.310"></a><span id="l7.310">     ums.params.id = aMessage.id;</span>
<a href="#l7.311"></a><span id="l7.311">     ums.params.folderID = aMessage.folderID;</span>
<a href="#l7.312"></a><span id="l7.312">     ums.params.messageKey = aMessage.messageKey;</span>
<a href="#l7.313"></a><span id="l7.313">     ums.params.conversationID = aMessage.conversationID;</span>
<a href="#l7.314"></a><span id="l7.314">     ums.params.headerMessageID = aMessage.headerMessageID;</span>
<a href="#l7.315"></a><span id="l7.315" class="difflineminus">-    ums.params.bodySnippet = aMessage.bodySnippet;</span>
<a href="#l7.316"></a><span id="l7.316">     </span>
<a href="#l7.317"></a><span id="l7.317">     ums.execute();</span>
<a href="#l7.318"></a><span id="l7.318" class="difflineplus">+    </span>
<a href="#l7.319"></a><span id="l7.319" class="difflineplus">+    if (aBody) {</span>
<a href="#l7.320"></a><span id="l7.320" class="difflineplus">+      let imts = this._insertMessageTextStatement;</span>
<a href="#l7.321"></a><span id="l7.321" class="difflineplus">+      imts.params.docid = aMessage.id;</span>
<a href="#l7.322"></a><span id="l7.322" class="difflineplus">+      imts.params.body = aBody;</span>
<a href="#l7.323"></a><span id="l7.323" class="difflineplus">+      </span>
<a href="#l7.324"></a><span id="l7.324" class="difflineplus">+      imts.execute();</span>
<a href="#l7.325"></a><span id="l7.325" class="difflineplus">+    }</span>
<a href="#l7.326"></a><span id="l7.326">   },</span>
<a href="#l7.327"></a><span id="l7.327"> </span>
<a href="#l7.328"></a><span id="l7.328">   updateMessageFoldersByKeyPurging:</span>
<a href="#l7.329"></a><span id="l7.329">       function gloda_ds_updateMessageFoldersByKeyPurging(aSrcFolderURI,</span>
<a href="#l7.330"></a><span id="l7.330">         aMessageKeys, aDestFolderURI) {</span>
<a href="#l7.331"></a><span id="l7.331">     let srcFolderID = this._mapFolderURI(aSrcFolderURI);</span>
<a href="#l7.332"></a><span id="l7.332">     let destFolderID = this._mapFolderURI(aDestFolderURI);</span>
<a href="#l7.333"></a><span id="l7.333">     </span>
<a href="#l7.334"></a><span id="l7.334" class="difflineat">@@ -754,17 +832,17 @@ let GlodaDatastore = {</span>
<a href="#l7.335"></a><span id="l7.335">   },</span>
<a href="#l7.336"></a><span id="l7.336">   </span>
<a href="#l7.337"></a><span id="l7.337">   _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l7.338"></a><span id="l7.338">     let datePRTime = aRow[&quot;date&quot;];</span>
<a href="#l7.339"></a><span id="l7.339">     return new GlodaMessage(this, aRow[&quot;id&quot;], aRow[&quot;folderID&quot;],</span>
<a href="#l7.340"></a><span id="l7.340">                             aRow[&quot;messageKey&quot;],</span>
<a href="#l7.341"></a><span id="l7.341">                             aRow[&quot;conversationID&quot;], null,</span>
<a href="#l7.342"></a><span id="l7.342">                             datePRTime ? new Date(datePRTime / 1000) : null,</span>
<a href="#l7.343"></a><span id="l7.343" class="difflineminus">-                            aRow[&quot;headerMessageID&quot;], aRow[&quot;bodySnippet&quot;]);</span>
<a href="#l7.344"></a><span id="l7.344" class="difflineplus">+                            aRow[&quot;headerMessageID&quot;]);</span>
<a href="#l7.345"></a><span id="l7.345">   },</span>
<a href="#l7.346"></a><span id="l7.346"> </span>
<a href="#l7.347"></a><span id="l7.347">   get _selectMessageByIDStatement() {</span>
<a href="#l7.348"></a><span id="l7.348">     let statement = this._createStatement(</span>
<a href="#l7.349"></a><span id="l7.349">       &quot;SELECT * FROM messages WHERE id = :id&quot;);</span>
<a href="#l7.350"></a><span id="l7.350">     this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l7.351"></a><span id="l7.351">       function() statement);</span>
<a href="#l7.352"></a><span id="l7.352">     return this._selectMessageByIDStatement;</span>
<a href="#l7.353"></a><span id="l7.353" class="difflineat">@@ -1060,21 +1138,41 @@ let GlodaDatastore = {</span>
<a href="#l7.354"></a><span id="l7.354">       for (let iConstraint=0; iConstraint &lt; curQuery._constraints.length; </span>
<a href="#l7.355"></a><span id="l7.355">            iConstraint++) {</span>
<a href="#l7.356"></a><span id="l7.356">         let attr_ors = curQuery._constraints[iConstraint];</span>
<a href="#l7.357"></a><span id="l7.357">         </span>
<a href="#l7.358"></a><span id="l7.358">         let lastAttributeID = null;</span>
<a href="#l7.359"></a><span id="l7.359">         let attrValueTests = [];</span>
<a href="#l7.360"></a><span id="l7.360">         let valueTests = null;</span>
<a href="#l7.361"></a><span id="l7.361">         </span>
<a href="#l7.362"></a><span id="l7.362" class="difflineplus">+        // our implementation requires that everyone in attr_ors has the same</span>
<a href="#l7.363"></a><span id="l7.363" class="difflineplus">+        //  attribute.</span>
<a href="#l7.364"></a><span id="l7.364" class="difflineplus">+        let presumedAttr = attr_ors[0][0];</span>
<a href="#l7.365"></a><span id="l7.365" class="difflineplus">+        </span>
<a href="#l7.366"></a><span id="l7.366" class="difflineplus">+        // -- handle full-text specially here, it's different than the other</span>
<a href="#l7.367"></a><span id="l7.367" class="difflineplus">+        //  cases...</span>
<a href="#l7.368"></a><span id="l7.368" class="difflineplus">+        if (presumedAttr.isSpecial == Gloda.kSpecialFulltext) {</span>
<a href="#l7.369"></a><span id="l7.369" class="difflineplus">+          let matchStr = [APV[2] for each (APV in attr_ors)].join(&quot; OR &quot;);</span>
<a href="#l7.370"></a><span id="l7.370" class="difflineplus">+          matchStr.replace(&quot;'&quot;, &quot;''&quot;);</span>
<a href="#l7.371"></a><span id="l7.371" class="difflineplus">+        </span>
<a href="#l7.372"></a><span id="l7.372" class="difflineplus">+          // for example, the match </span>
<a href="#l7.373"></a><span id="l7.373" class="difflineplus">+          let ftSelect = &quot;SELECT docid FROM &quot; + nounMeta.tableName + &quot;Text&quot; +</span>
<a href="#l7.374"></a><span id="l7.374" class="difflineplus">+            &quot; WHERE &quot; + presumedAttr.specialColumnName + &quot; MATCH '&quot; +</span>
<a href="#l7.375"></a><span id="l7.375" class="difflineplus">+            matchStr + &quot;'&quot;;</span>
<a href="#l7.376"></a><span id="l7.376" class="difflineplus">+          selects.push(ftSelect);</span>
<a href="#l7.377"></a><span id="l7.377" class="difflineplus">+        </span>
<a href="#l7.378"></a><span id="l7.378" class="difflineplus">+          // bypass the logic used by the other cases</span>
<a href="#l7.379"></a><span id="l7.379" class="difflineplus">+          continue;</span>
<a href="#l7.380"></a><span id="l7.380" class="difflineplus">+        }</span>
<a href="#l7.381"></a><span id="l7.381" class="difflineplus">+        </span>
<a href="#l7.382"></a><span id="l7.382">         let tableName, idColumnName, valueColumnName;</span>
<a href="#l7.383"></a><span id="l7.383" class="difflineminus">-        if (attr_ors[0][0].isSpecial) {</span>
<a href="#l7.384"></a><span id="l7.384" class="difflineplus">+        if (presumedAttr.isSpecial == Gloda.kSpecialColumn) {</span>
<a href="#l7.385"></a><span id="l7.385">           tableName = nounMeta.tableName;</span>
<a href="#l7.386"></a><span id="l7.386">           idColumnName = &quot;id&quot;; // canonical id for a table is &quot;id&quot;.</span>
<a href="#l7.387"></a><span id="l7.387" class="difflineminus">-          valueColumnName = attr_ors[0][0].specialColumnName;</span>
<a href="#l7.388"></a><span id="l7.388" class="difflineplus">+          valueColumnName = presumedAttr.specialColumnName;</span>
<a href="#l7.389"></a><span id="l7.389">         }</span>
<a href="#l7.390"></a><span id="l7.390">         else {</span>
<a href="#l7.391"></a><span id="l7.391">           tableName = nounMeta.attrTableName;</span>
<a href="#l7.392"></a><span id="l7.392">           idColumnName = nounMeta.attrIDColumnName;</span>
<a href="#l7.393"></a><span id="l7.393">           valueColumnName = &quot;value&quot;;</span>
<a href="#l7.394"></a><span id="l7.394">         }</span>
<a href="#l7.395"></a><span id="l7.395">         </span>
<a href="#l7.396"></a><span id="l7.396">         // we want a net 'or' for everyone in here, where 'everyone' is presumed</span>
<a href="#l7.397"></a><span id="l7.397" class="difflineat">@@ -1190,58 +1288,97 @@ let GlodaDatastore = {</span>
<a href="#l7.398"></a><span id="l7.398">     statement.reset();</span>
<a href="#l7.399"></a><span id="l7.399">      </span>
<a href="#l7.400"></a><span id="l7.400">     return messages;</span>
<a href="#l7.401"></a><span id="l7.401">   },</span>
<a href="#l7.402"></a><span id="l7.402">   </span>
<a href="#l7.403"></a><span id="l7.403">   /* ********** Contact ********** */</span>
<a href="#l7.404"></a><span id="l7.404">   get _insertContactStatement() {</span>
<a href="#l7.405"></a><span id="l7.405">     let statement = this._createStatement(</span>
<a href="#l7.406"></a><span id="l7.406" class="difflineminus">-      &quot;INSERT INTO contacts (directoryUUID, contactUUID, name) \</span>
<a href="#l7.407"></a><span id="l7.407" class="difflineminus">-              VALUES (:directoryUUID, :contactUUID, :name)&quot;);</span>
<a href="#l7.408"></a><span id="l7.408" class="difflineplus">+      &quot;INSERT INTO contacts (directoryUUID, contactUUID, name, popularity,\</span>
<a href="#l7.409"></a><span id="l7.409" class="difflineplus">+                             frecency) \</span>
<a href="#l7.410"></a><span id="l7.410" class="difflineplus">+              VALUES (:directoryUUID, :contactUUID, :name, :popularity,\</span>
<a href="#l7.411"></a><span id="l7.411" class="difflineplus">+                      :frecency)&quot;);</span>
<a href="#l7.412"></a><span id="l7.412">     this.__defineGetter__(&quot;_insertContactStatement&quot;, function() statement);</span>
<a href="#l7.413"></a><span id="l7.413">     return this._insertContactStatement; </span>
<a href="#l7.414"></a><span id="l7.414">   },</span>
<a href="#l7.415"></a><span id="l7.415">   </span>
<a href="#l7.416"></a><span id="l7.416">   createContact: function gloda_ds_createContact(aDirectoryUUID, aContactUUID,</span>
<a href="#l7.417"></a><span id="l7.417" class="difflineminus">-                                                 aName) {</span>
<a href="#l7.418"></a><span id="l7.418" class="difflineplus">+      aName, aPopularity, aFrecency) {</span>
<a href="#l7.419"></a><span id="l7.419">     let ics = this._insertContactStatement;</span>
<a href="#l7.420"></a><span id="l7.420">     ics.params.directoryUUID = aDirectoryUUID;</span>
<a href="#l7.421"></a><span id="l7.421">     ics.params.contactUUID = aContactUUID;</span>
<a href="#l7.422"></a><span id="l7.422">     ics.params.name = aName;</span>
<a href="#l7.423"></a><span id="l7.423" class="difflineplus">+    ics.params.popularity = aPopularity;</span>
<a href="#l7.424"></a><span id="l7.424" class="difflineplus">+    ics.params.frecency = aFrecency;</span>
<a href="#l7.425"></a><span id="l7.425">     </span>
<a href="#l7.426"></a><span id="l7.426">     ics.execute();</span>
<a href="#l7.427"></a><span id="l7.427">     </span>
<a href="#l7.428"></a><span id="l7.428">     return new GlodaContact(this, this.dbConnection.lastInsertRowID,</span>
<a href="#l7.429"></a><span id="l7.429" class="difflineminus">-                            aDirectoryUUID, aContactUUID, aName);</span>
<a href="#l7.430"></a><span id="l7.430" class="difflineplus">+                            aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l7.431"></a><span id="l7.431" class="difflineplus">+                            aPopularity, aFrecency);</span>
<a href="#l7.432"></a><span id="l7.432" class="difflineplus">+  },</span>
<a href="#l7.433"></a><span id="l7.433" class="difflineplus">+</span>
<a href="#l7.434"></a><span id="l7.434" class="difflineplus">+  get _updateContactStatement() {</span>
<a href="#l7.435"></a><span id="l7.435" class="difflineplus">+    let statement = this._createStatement(</span>
<a href="#l7.436"></a><span id="l7.436" class="difflineplus">+      &quot;UPDATE contacts SET directoryUUID = :directoryUUID, \</span>
<a href="#l7.437"></a><span id="l7.437" class="difflineplus">+                           contactUUID = :contactUUID, \</span>
<a href="#l7.438"></a><span id="l7.438" class="difflineplus">+                           name = :name, \</span>
<a href="#l7.439"></a><span id="l7.439" class="difflineplus">+                           popularity = :popularity, \</span>
<a href="#l7.440"></a><span id="l7.440" class="difflineplus">+                           frecency = :frecency \</span>
<a href="#l7.441"></a><span id="l7.441" class="difflineplus">+                       WHERE id = :id&quot;);</span>
<a href="#l7.442"></a><span id="l7.442" class="difflineplus">+    this.__defineGetter__(&quot;_updateContactStatement&quot;, function() statement);</span>
<a href="#l7.443"></a><span id="l7.443" class="difflineplus">+    return this._updateContactStatement; </span>
<a href="#l7.444"></a><span id="l7.444" class="difflineplus">+  },</span>
<a href="#l7.445"></a><span id="l7.445" class="difflineplus">+</span>
<a href="#l7.446"></a><span id="l7.446" class="difflineplus">+  updateContact: function gloda_ds_updateContact(aContact) {</span>
<a href="#l7.447"></a><span id="l7.447" class="difflineplus">+    let ucs = this._updateContactStatement;</span>
<a href="#l7.448"></a><span id="l7.448" class="difflineplus">+    ucs.params.id = aContact.id;</span>
<a href="#l7.449"></a><span id="l7.449" class="difflineplus">+    ucs.params.directoryUUID = aContact.directoryUUID;</span>
<a href="#l7.450"></a><span id="l7.450" class="difflineplus">+    ucs.params.contactUUID = aContact.contactUUID;</span>
<a href="#l7.451"></a><span id="l7.451" class="difflineplus">+    ucs.params.name = aContact.name;</span>
<a href="#l7.452"></a><span id="l7.452" class="difflineplus">+    ucs.params.popularity = aContact.popularity;</span>
<a href="#l7.453"></a><span id="l7.453" class="difflineplus">+    ucs.params.frecency = aContact.frecency;</span>
<a href="#l7.454"></a><span id="l7.454" class="difflineplus">+    </span>
<a href="#l7.455"></a><span id="l7.455" class="difflineplus">+    ucs.execute();</span>
<a href="#l7.456"></a><span id="l7.456">   },</span>
<a href="#l7.457"></a><span id="l7.457">   </span>
<a href="#l7.458"></a><span id="l7.458">   _contactFromRow: function gloda_ds_contactFromRow(aRow) {</span>
<a href="#l7.459"></a><span id="l7.459">     return new GlodaContact(this, aRow[&quot;id&quot;], aRow[&quot;directoryUUID&quot;],</span>
<a href="#l7.460"></a><span id="l7.460" class="difflineminus">-                            aRow[&quot;contactUUID&quot;], aRow[&quot;name&quot;]);</span>
<a href="#l7.461"></a><span id="l7.461" class="difflineplus">+                            aRow[&quot;contactUUID&quot;], aRow[&quot;name&quot;],</span>
<a href="#l7.462"></a><span id="l7.462" class="difflineplus">+                            aRow[&quot;popularity&quot;], aRow[&quot;frecency&quot;]);</span>
<a href="#l7.463"></a><span id="l7.463">   },</span>
<a href="#l7.464"></a><span id="l7.464">   </span>
<a href="#l7.465"></a><span id="l7.465">   get _selectContactByIDStatement() {</span>
<a href="#l7.466"></a><span id="l7.466">     let statement = this._createStatement(</span>
<a href="#l7.467"></a><span id="l7.467">       &quot;SELECT * FROM contacts WHERE id = :id&quot;);</span>
<a href="#l7.468"></a><span id="l7.468">     this.__defineGetter__(&quot;_selectContactByIDStatement&quot;,</span>
<a href="#l7.469"></a><span id="l7.469">       function() statement);</span>
<a href="#l7.470"></a><span id="l7.470">     return this._selectContactByIDStatement;</span>
<a href="#l7.471"></a><span id="l7.471">   },</span>
<a href="#l7.472"></a><span id="l7.472"> </span>
<a href="#l7.473"></a><span id="l7.473">   getContactByID: function gloda_ds_getContactByID(aContactID) {</span>
<a href="#l7.474"></a><span id="l7.474">     let contact = null;</span>
<a href="#l7.475"></a><span id="l7.475" class="difflineplus">+    </span>
<a href="#l7.476"></a><span id="l7.476" class="difflineplus">+    let [hit, miss] = GlodaCollectionManager.cacheLookup(</span>
<a href="#l7.477"></a><span id="l7.477" class="difflineplus">+      GlodaContact.prototype.NOUN_ID, [aContactID]);</span>
<a href="#l7.478"></a><span id="l7.478" class="difflineplus">+  </span>
<a href="#l7.479"></a><span id="l7.479" class="difflineplus">+    if (hit.length)</span>
<a href="#l7.480"></a><span id="l7.480" class="difflineplus">+      return hit[0];</span>
<a href="#l7.481"></a><span id="l7.481">   </span>
<a href="#l7.482"></a><span id="l7.482">     let scbi = this._selectContactByIDStatement;</span>
<a href="#l7.483"></a><span id="l7.483">     scbi.params.id = aContactID;</span>
<a href="#l7.484"></a><span id="l7.484">     if (scbi.step()) {</span>
<a href="#l7.485"></a><span id="l7.485">       contact = this._contactFromRow(scbi.row);</span>
<a href="#l7.486"></a><span id="l7.486">     }</span>
<a href="#l7.487"></a><span id="l7.487">     scbi.reset();</span>
<a href="#l7.488"></a><span id="l7.488">     </span>
<a href="#l7.489"></a><span id="l7.489" class="difflineplus">+    if (contact)</span>
<a href="#l7.490"></a><span id="l7.490" class="difflineplus">+      GlodaCollectionManager.cacheAdd(contact.NOUN_ID, [contact]);</span>
<a href="#l7.491"></a><span id="l7.491" class="difflineplus">+    </span>
<a href="#l7.492"></a><span id="l7.492">     return contact;</span>
<a href="#l7.493"></a><span id="l7.493">   },</span>
<a href="#l7.494"></a><span id="l7.494">   </span>
<a href="#l7.495"></a><span id="l7.495">   /* ********** Identity ********** */</span>
<a href="#l7.496"></a><span id="l7.496">   get _insertIdentityStatement() {</span>
<a href="#l7.497"></a><span id="l7.497">     let statement = this._createStatement(</span>
<a href="#l7.498"></a><span id="l7.498">       &quot;INSERT INTO identities (contactID, kind, value, description, relay) \</span>
<a href="#l7.499"></a><span id="l7.499">               VALUES (:contactID, :kind, :value, :description, :relay)&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/modules/fundattr.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/modules/fundattr.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -68,77 +68,145 @@ let GlodaFundAttr = {</span>
<a href="#l8.4"></a><span id="l8.4">       this.defineAttributes();</span>
<a href="#l8.5"></a><span id="l8.5">     }</span>
<a href="#l8.6"></a><span id="l8.6">     catch (ex) {</span>
<a href="#l8.7"></a><span id="l8.7">       this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l8.8"></a><span id="l8.8">       throw ex;</span>
<a href="#l8.9"></a><span id="l8.9">     }</span>
<a href="#l8.10"></a><span id="l8.10">   },</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+  POPULARITY_FROM_ME_TO: 10,</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+  POPULARITY_FROM_ME_CC: 4,</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+  POPULARITY_TO_ME: 5,</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+  POPULARITY_CC_ME: 1,</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineplus">+  _attrConvSubject: null,</span>
<a href="#l8.18"></a><span id="l8.18">   _attrFolder: null,</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+  _attrBody: null,</span>
<a href="#l8.20"></a><span id="l8.20">   _attrFrom: null,</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+  _attrFromMe: null,</span>
<a href="#l8.22"></a><span id="l8.22">   _attrTo: null,</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineplus">+  _attrToMe: null,</span>
<a href="#l8.24"></a><span id="l8.24">   _attrCc: null,</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineplus">+  _attrCcMe: null,</span>
<a href="#l8.26"></a><span id="l8.26">   _attrDate: null,</span>
<a href="#l8.27"></a><span id="l8.27">   </span>
<a href="#l8.28"></a><span id="l8.28">   defineAttributes: function() {</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineplus">+    /* ***** Conversations ***** */</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+    // conversation: subjectMatches</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+    this._attrConvSubject = Gloda.defineAttribute({</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+      provider: this,</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+      attributeName: &quot;subjectMatches&quot;,</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+      bind: false,</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+      singular: true,</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+      special: Gloda.kSpecialFulltext,</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+      specialColumnName: &quot;subject&quot;,</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONVERSATION],</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+      objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineplus">+      explanation: null, // this does not merit explanation</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineplus">+      });</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+    </span>
<a href="#l8.45"></a><span id="l8.45" class="difflineplus">+    /* ***** Contacts ***** */</span>
<a href="#l8.46"></a><span id="l8.46" class="difflineplus">+    this._attrContactPopularity = Gloda.defineAttribute({</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineplus">+      provider: this,</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.49"></a><span id="l8.49" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineplus">+      attributeName: &quot;popularity&quot;,</span>
<a href="#l8.51"></a><span id="l8.51" class="difflineplus">+      bind: false,</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineplus">+      singular: true,</span>
<a href="#l8.53"></a><span id="l8.53" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l8.54"></a><span id="l8.54" class="difflineplus">+      specialColumnName: &quot;popularity&quot;,</span>
<a href="#l8.55"></a><span id="l8.55" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineplus">+      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineplus">+      explanation: null, // popularity is internal, no explanation required</span>
<a href="#l8.58"></a><span id="l8.58" class="difflineplus">+      });    </span>
<a href="#l8.59"></a><span id="l8.59" class="difflineplus">+    this._attrContactFrecency = Gloda.defineAttribute({</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineplus">+      provider: this,</span>
<a href="#l8.61"></a><span id="l8.61" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.62"></a><span id="l8.62" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l8.63"></a><span id="l8.63" class="difflineplus">+      attributeName: &quot;frecency&quot;,</span>
<a href="#l8.64"></a><span id="l8.64" class="difflineplus">+      bind: false,</span>
<a href="#l8.65"></a><span id="l8.65" class="difflineplus">+      singular: true,</span>
<a href="#l8.66"></a><span id="l8.66" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l8.67"></a><span id="l8.67" class="difflineplus">+      specialColumnName: &quot;frecency&quot;,</span>
<a href="#l8.68"></a><span id="l8.68" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineplus">+      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l8.70"></a><span id="l8.70" class="difflineplus">+      explanation: null, // frecency is internal, no explanation required</span>
<a href="#l8.71"></a><span id="l8.71" class="difflineplus">+      });    </span>
<a href="#l8.72"></a><span id="l8.72" class="difflineplus">+  </span>
<a href="#l8.73"></a><span id="l8.73" class="difflineplus">+    /* ***** Messages ***** */</span>
<a href="#l8.74"></a><span id="l8.74" class="difflineplus">+    // folder</span>
<a href="#l8.75"></a><span id="l8.75">     this._attrFolder = Gloda.defineAttribute({</span>
<a href="#l8.76"></a><span id="l8.76">       provider: this,</span>
<a href="#l8.77"></a><span id="l8.77">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.78"></a><span id="l8.78">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.79"></a><span id="l8.79">       attributeName: &quot;folderURI&quot;,</span>
<a href="#l8.80"></a><span id="l8.80">       bind: false,</span>
<a href="#l8.81"></a><span id="l8.81">       singular: true,</span>
<a href="#l8.82"></a><span id="l8.82" class="difflineminus">-      special: true,</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l8.84"></a><span id="l8.84">       specialColumnName: &quot;folderID&quot;,</span>
<a href="#l8.85"></a><span id="l8.85">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.86"></a><span id="l8.86">       objectNoun: Gloda.NOUN_FOLDER,</span>
<a href="#l8.87"></a><span id="l8.87" class="difflineminus">-      parameterNoun: null,</span>
<a href="#l8.88"></a><span id="l8.88">       explanation: this._strBundle.GetStringFromName(&quot;attrFolderExplanation&quot;),</span>
<a href="#l8.89"></a><span id="l8.89">       });</span>
<a href="#l8.90"></a><span id="l8.90" class="difflineplus">+    </span>
<a href="#l8.91"></a><span id="l8.91" class="difflineplus">+    // bodyMatches. super-synthetic full-text matching...</span>
<a href="#l8.92"></a><span id="l8.92" class="difflineplus">+    this._attrBody = Gloda.defineAttribute({</span>
<a href="#l8.93"></a><span id="l8.93" class="difflineplus">+      provider: this,</span>
<a href="#l8.94"></a><span id="l8.94" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.95"></a><span id="l8.95" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l8.96"></a><span id="l8.96" class="difflineplus">+      attributeName: &quot;bodyMatches&quot;,</span>
<a href="#l8.97"></a><span id="l8.97" class="difflineplus">+      bind: false,</span>
<a href="#l8.98"></a><span id="l8.98" class="difflineplus">+      singular: true,</span>
<a href="#l8.99"></a><span id="l8.99" class="difflineplus">+      special: Gloda.kSpecialFulltext,</span>
<a href="#l8.100"></a><span id="l8.100" class="difflineplus">+      specialColumnName: &quot;body&quot;,</span>
<a href="#l8.101"></a><span id="l8.101" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.102"></a><span id="l8.102" class="difflineplus">+      objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l8.103"></a><span id="l8.103" class="difflineplus">+      explanation: null, // this does not merit explanation</span>
<a href="#l8.104"></a><span id="l8.104" class="difflineplus">+      });</span>
<a href="#l8.105"></a><span id="l8.105">   </span>
<a href="#l8.106"></a><span id="l8.106" class="difflineplus">+    // --- Fundamental</span>
<a href="#l8.107"></a><span id="l8.107">     // From</span>
<a href="#l8.108"></a><span id="l8.108">     this._attrFrom = Gloda.defineAttribute({</span>
<a href="#l8.109"></a><span id="l8.109">                         provider: this,</span>
<a href="#l8.110"></a><span id="l8.110">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.111"></a><span id="l8.111">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.112"></a><span id="l8.112">                         attributeName: &quot;from&quot;,</span>
<a href="#l8.113"></a><span id="l8.113">                         bind: true,</span>
<a href="#l8.114"></a><span id="l8.114">                         singular: true,</span>
<a href="#l8.115"></a><span id="l8.115">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.116"></a><span id="l8.116">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.117"></a><span id="l8.117" class="difflineminus">-                        parameterNoun: null,</span>
<a href="#l8.118"></a><span id="l8.118">                         explanation: this._strBundle.GetStringFromName(</span>
<a href="#l8.119"></a><span id="l8.119">                                        &quot;attrFromExplanation&quot;),</span>
<a href="#l8.120"></a><span id="l8.120">                         });</span>
<a href="#l8.121"></a><span id="l8.121">     // To</span>
<a href="#l8.122"></a><span id="l8.122">     this._attrTo = Gloda.defineAttribute({</span>
<a href="#l8.123"></a><span id="l8.123">                         provider: this,</span>
<a href="#l8.124"></a><span id="l8.124">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.125"></a><span id="l8.125">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.126"></a><span id="l8.126">                         attributeName: &quot;to&quot;,</span>
<a href="#l8.127"></a><span id="l8.127">                         bind: true,</span>
<a href="#l8.128"></a><span id="l8.128">                         singular: false,</span>
<a href="#l8.129"></a><span id="l8.129">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.130"></a><span id="l8.130">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.131"></a><span id="l8.131" class="difflineminus">-                        parameterNoun: null,</span>
<a href="#l8.132"></a><span id="l8.132">                         explanation: this._strBundle.GetStringFromName(</span>
<a href="#l8.133"></a><span id="l8.133">                                        &quot;attrToExplanation&quot;),</span>
<a href="#l8.134"></a><span id="l8.134">                         });</span>
<a href="#l8.135"></a><span id="l8.135">     // Cc</span>
<a href="#l8.136"></a><span id="l8.136">     this._attrCc = Gloda.defineAttribute({</span>
<a href="#l8.137"></a><span id="l8.137">                         provider: this,</span>
<a href="#l8.138"></a><span id="l8.138">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.139"></a><span id="l8.139">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.140"></a><span id="l8.140">                         attributeName: &quot;cc&quot;,</span>
<a href="#l8.141"></a><span id="l8.141">                         bind: true,</span>
<a href="#l8.142"></a><span id="l8.142">                         singular: false,</span>
<a href="#l8.143"></a><span id="l8.143">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.144"></a><span id="l8.144">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.145"></a><span id="l8.145" class="difflineminus">-                        parameterNoun: null,</span>
<a href="#l8.146"></a><span id="l8.146">                         explanation: this._strBundle.GetStringFromName(</span>
<a href="#l8.147"></a><span id="l8.147">                                        &quot;attrCcExplanation&quot;),</span>
<a href="#l8.148"></a><span id="l8.148">                         });</span>
<a href="#l8.149"></a><span id="l8.149"> </span>
<a href="#l8.150"></a><span id="l8.150">     Gloda.defineNounAction(Gloda.NOUN_IDENTITY, {actionType: &quot;filter&quot;,</span>
<a href="#l8.151"></a><span id="l8.151">       actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l8.152"></a><span id="l8.152">       shortName: &quot;from&quot;,</span>
<a href="#l8.153"></a><span id="l8.153">       makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l8.154"></a><span id="l8.154" class="difflineat">@@ -163,24 +231,75 @@ let GlodaFundAttr = {</span>
<a href="#l8.155"></a><span id="l8.155">     // Date.  now lives on the row.</span>
<a href="#l8.156"></a><span id="l8.156">     this._attrDate = Gloda.defineAttribute({</span>
<a href="#l8.157"></a><span id="l8.157">                         provider: this,</span>
<a href="#l8.158"></a><span id="l8.158">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.159"></a><span id="l8.159">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.160"></a><span id="l8.160">                         attributeName: &quot;date&quot;,</span>
<a href="#l8.161"></a><span id="l8.161">                         bind: false,</span>
<a href="#l8.162"></a><span id="l8.162">                         singular: true,</span>
<a href="#l8.163"></a><span id="l8.163" class="difflineminus">-                        special: true,</span>
<a href="#l8.164"></a><span id="l8.164" class="difflineplus">+                        special: Gloda.kSpecialColumn,</span>
<a href="#l8.165"></a><span id="l8.165">                         specialColumnName: &quot;date&quot;,</span>
<a href="#l8.166"></a><span id="l8.166">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.167"></a><span id="l8.167">                         objectNoun: Gloda.NOUN_DATE,</span>
<a href="#l8.168"></a><span id="l8.168" class="difflineminus">-                        parameterNoun: null,</span>
<a href="#l8.169"></a><span id="l8.169">                         explanation: this._strBundle.GetStringFromName(</span>
<a href="#l8.170"></a><span id="l8.170">                                        &quot;attrDateExplanation&quot;),</span>
<a href="#l8.171"></a><span id="l8.171">                         });</span>
<a href="#l8.172"></a><span id="l8.172" class="difflineplus">+</span>
<a href="#l8.173"></a><span id="l8.173" class="difflineplus">+    // --- Optimization</span>
<a href="#l8.174"></a><span id="l8.174" class="difflineplus">+    // From Me To</span>
<a href="#l8.175"></a><span id="l8.175" class="difflineplus">+    this._attrFromMeTo = Gloda.defineAttribute({</span>
<a href="#l8.176"></a><span id="l8.176" class="difflineplus">+      provider: this,</span>
<a href="#l8.177"></a><span id="l8.177" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.178"></a><span id="l8.178" class="difflineplus">+      attributeType: Gloda.kAttrOptimization,</span>
<a href="#l8.179"></a><span id="l8.179" class="difflineplus">+      attributeName: &quot;fromMeTo&quot;,</span>
<a href="#l8.180"></a><span id="l8.180" class="difflineplus">+      bind: false,</span>
<a href="#l8.181"></a><span id="l8.181" class="difflineplus">+      singular: false,</span>
<a href="#l8.182"></a><span id="l8.182" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.183"></a><span id="l8.183" class="difflineplus">+      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.184"></a><span id="l8.184" class="difflineplus">+      explanation: this._strBundle.GetStringFromName(&quot;attrFromMeToExplanation&quot;)</span>
<a href="#l8.185"></a><span id="l8.185" class="difflineplus">+      });</span>
<a href="#l8.186"></a><span id="l8.186" class="difflineplus">+    // From Me Cc</span>
<a href="#l8.187"></a><span id="l8.187" class="difflineplus">+    this._attrFromMeCc = Gloda.defineAttribute({</span>
<a href="#l8.188"></a><span id="l8.188" class="difflineplus">+      provider: this,</span>
<a href="#l8.189"></a><span id="l8.189" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.190"></a><span id="l8.190" class="difflineplus">+      attributeType: Gloda.kAttrOptimization,</span>
<a href="#l8.191"></a><span id="l8.191" class="difflineplus">+      attributeName: &quot;fromMeCc&quot;,</span>
<a href="#l8.192"></a><span id="l8.192" class="difflineplus">+      bind: false,</span>
<a href="#l8.193"></a><span id="l8.193" class="difflineplus">+      singular: false,</span>
<a href="#l8.194"></a><span id="l8.194" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.195"></a><span id="l8.195" class="difflineplus">+      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.196"></a><span id="l8.196" class="difflineplus">+      explanation: this._strBundle.GetStringFromName(&quot;attrFromMeCcExplanation&quot;)</span>
<a href="#l8.197"></a><span id="l8.197" class="difflineplus">+      });</span>
<a href="#l8.198"></a><span id="l8.198" class="difflineplus">+    // To Me</span>
<a href="#l8.199"></a><span id="l8.199" class="difflineplus">+    this._attrToMe = Gloda.defineAttribute({</span>
<a href="#l8.200"></a><span id="l8.200" class="difflineplus">+      provider: this,</span>
<a href="#l8.201"></a><span id="l8.201" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.202"></a><span id="l8.202" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.203"></a><span id="l8.203" class="difflineplus">+      attributeName: &quot;toMe&quot;,</span>
<a href="#l8.204"></a><span id="l8.204" class="difflineplus">+      bind: false,</span>
<a href="#l8.205"></a><span id="l8.205" class="difflineplus">+      singular: false,</span>
<a href="#l8.206"></a><span id="l8.206" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.207"></a><span id="l8.207" class="difflineplus">+      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.208"></a><span id="l8.208" class="difflineplus">+      explanation: this._strBundle.GetStringFromName(&quot;attrToMeExplanation&quot;)</span>
<a href="#l8.209"></a><span id="l8.209" class="difflineplus">+      });</span>
<a href="#l8.210"></a><span id="l8.210" class="difflineplus">+    // Cc Me</span>
<a href="#l8.211"></a><span id="l8.211" class="difflineplus">+    this._attrCcMe = Gloda.defineAttribute({</span>
<a href="#l8.212"></a><span id="l8.212" class="difflineplus">+      provider: this,</span>
<a href="#l8.213"></a><span id="l8.213" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.214"></a><span id="l8.214" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.215"></a><span id="l8.215" class="difflineplus">+      attributeName: &quot;ccMe&quot;,</span>
<a href="#l8.216"></a><span id="l8.216" class="difflineplus">+      bind: false,</span>
<a href="#l8.217"></a><span id="l8.217" class="difflineplus">+      singular: false,</span>
<a href="#l8.218"></a><span id="l8.218" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.219"></a><span id="l8.219" class="difflineplus">+      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.220"></a><span id="l8.220" class="difflineplus">+      explanation: this._strBundle.GetStringFromName(&quot;attrCcMeExplanation&quot;) </span>
<a href="#l8.221"></a><span id="l8.221" class="difflineplus">+      });</span>
<a href="#l8.222"></a><span id="l8.222" class="difflineplus">+</span>
<a href="#l8.223"></a><span id="l8.223" class="difflineplus">+</span>
<a href="#l8.224"></a><span id="l8.224">     // -- Mailing List</span>
<a href="#l8.225"></a><span id="l8.225">     // Non-singular, but a hard call.  Namely, it is obvious that a message can</span>
<a href="#l8.226"></a><span id="l8.226">     //  be addressed to multiple mailing lists.  However, I don't see how you</span>
<a href="#l8.227"></a><span id="l8.227">     //  could receive a message with more than one set of List-* headers,</span>
<a href="#l8.228"></a><span id="l8.228">     //  since each list-serve would each send you a copy.  Based on our current</span>
<a href="#l8.229"></a><span id="l8.229">     //  decision to treat each physical message as separate, it almost seems</span>
<a href="#l8.230"></a><span id="l8.230">     //  right to limit the list attribute to the copy that originated at the</span>
<a href="#l8.231"></a><span id="l8.231">     //  list.  That may sound entirely wrong, but keep in mind that until we</span>
<a href="#l8.232"></a><span id="l8.232" class="difflineat">@@ -197,33 +316,33 @@ let GlodaFundAttr = {</span>
<a href="#l8.233"></a><span id="l8.233">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.234"></a><span id="l8.234">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.235"></a><span id="l8.235">                         attributeName: &quot;mailing-list&quot;,</span>
<a href="#l8.236"></a><span id="l8.236">                         bind: true,</span>
<a href="#l8.237"></a><span id="l8.237">                         bindName: &quot;mailingLists&quot;,</span>
<a href="#l8.238"></a><span id="l8.238">                         singular: false,</span>
<a href="#l8.239"></a><span id="l8.239">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.240"></a><span id="l8.240">                         objectNoun: Gloda.NOUN_DATE,</span>
<a href="#l8.241"></a><span id="l8.241" class="difflineminus">-                        parameterNoun: null,</span>
<a href="#l8.242"></a><span id="l8.242">                         explanation: this._strBundle.GetStringFromName(</span>
<a href="#l8.243"></a><span id="l8.243">                                        &quot;attrListExplanation&quot;),</span>
<a href="#l8.244"></a><span id="l8.244">                         });</span>
<a href="#l8.245"></a><span id="l8.245">   },</span>
<a href="#l8.246"></a><span id="l8.246">   </span>
<a href="#l8.247"></a><span id="l8.247">   /**</span>
<a href="#l8.248"></a><span id="l8.248">    *</span>
<a href="#l8.249"></a><span id="l8.249">    * Specializations:</span>
<a href="#l8.250"></a><span id="l8.250">    * - Mailing Lists.  Replies to a message on a mailing list frequently only</span>
<a href="#l8.251"></a><span id="l8.251">    *   have the list-serve as the 'to', so we try to generate a synthetic 'to'</span>
<a href="#l8.252"></a><span id="l8.252">    *   based on the author of the parent message when possible.  (The 'possible'</span>
<a href="#l8.253"></a><span id="l8.253">    *   part is that we may not have a copy of the parent message at the time of</span>
<a href="#l8.254"></a><span id="l8.254">    *   processing.)</span>
<a href="#l8.255"></a><span id="l8.255">    * - Newsgroups.  Same deal as mailing lists.</span>
<a href="#l8.256"></a><span id="l8.256">    */</span>
<a href="#l8.257"></a><span id="l8.257" class="difflineminus">-  process: function gloda_fundattr_process(aGlodaMessage, aMsgHdr, aMimeMsg) {</span>
<a href="#l8.258"></a><span id="l8.258" class="difflineplus">+  process: function gloda_fundattr_process(aGlodaMessage, aMsgHdr, aMimeMsg,</span>
<a href="#l8.259"></a><span id="l8.259" class="difflineplus">+                                           aIsNew) {</span>
<a href="#l8.260"></a><span id="l8.260">     let attribs = [];</span>
<a href="#l8.261"></a><span id="l8.261">     </span>
<a href="#l8.262"></a><span id="l8.262">     // -- From</span>
<a href="#l8.263"></a><span id="l8.263">     // Let's use replyTo if available.</span>
<a href="#l8.264"></a><span id="l8.264">     // er, since we are just dealing with mailing lists for now, forget the</span>
<a href="#l8.265"></a><span id="l8.265">     //  reply-to...</span>
<a href="#l8.266"></a><span id="l8.266">     // TODO: deal with default charset issues</span>
<a href="#l8.267"></a><span id="l8.267">     let author = null;</span>
<a href="#l8.268"></a><span id="l8.268" class="difflineat">@@ -238,31 +357,71 @@ let GlodaFundAttr = {</span>
<a href="#l8.269"></a><span id="l8.269">       author = aMsgHdr.author;</span>
<a href="#l8.270"></a><span id="l8.270"> </span>
<a href="#l8.271"></a><span id="l8.271">     let authorIdentity = Gloda.getIdentityForFullMailAddress(author);</span>
<a href="#l8.272"></a><span id="l8.272">     if (authorIdentity == null) {</span>
<a href="#l8.273"></a><span id="l8.273">       this._log.error(&quot;Message with subject '&quot; + aMsgHdr.mime2DecodedSubject +</span>
<a href="#l8.274"></a><span id="l8.274">                       &quot;' somehow lacks a valid author.  Bailing.&quot;);</span>
<a href="#l8.275"></a><span id="l8.275">       return attribs;</span>
<a href="#l8.276"></a><span id="l8.276">     }</span>
<a href="#l8.277"></a><span id="l8.277" class="difflineminus">-    attribs.push([this._attrFrom.id, authorIdentity.id]); </span>
<a href="#l8.278"></a><span id="l8.278" class="difflineplus">+    attribs.push([this._attrFrom.id, authorIdentity.id]);</span>
<a href="#l8.279"></a><span id="l8.279" class="difflineplus">+    </span>
<a href="#l8.280"></a><span id="l8.280" class="difflineplus">+    let myIdentities = Gloda.myIdentities; // needless optimization?</span>
<a href="#l8.281"></a><span id="l8.281" class="difflineplus">+    let isFromMe = authorIdentity.id in myIdentities;</span>
<a href="#l8.282"></a><span id="l8.282">     </span>
<a href="#l8.283"></a><span id="l8.283">     // -- To, Cc</span>
<a href="#l8.284"></a><span id="l8.284">     // TODO: handle mailing list semantics (use my visterity logic as a first</span>
<a href="#l8.285"></a><span id="l8.285">     //  pass.)</span>
<a href="#l8.286"></a><span id="l8.286">     let toIdentities = Gloda.getIdentitiesForFullMailAddresses(</span>
<a href="#l8.287"></a><span id="l8.287">                            aMsgHdr.recipients);</span>
<a href="#l8.288"></a><span id="l8.288">     for (let iTo=0; iTo &lt; toIdentities.length; iTo++) {</span>
<a href="#l8.289"></a><span id="l8.289" class="difflineminus">-      attribs.push([this._attrTo.id, toIdentities[iTo].id]);</span>
<a href="#l8.290"></a><span id="l8.290" class="difflineplus">+      let toIdentity = toIdentities[iTo];</span>
<a href="#l8.291"></a><span id="l8.291" class="difflineplus">+      attribs.push([this._attrTo.id, toIdentity.id]);</span>
<a href="#l8.292"></a><span id="l8.292" class="difflineplus">+      // optimization attribute to-me ('I' am the parameter)</span>
<a href="#l8.293"></a><span id="l8.293" class="difflineplus">+      if (toIdentity.id in myIdentities) {</span>
<a href="#l8.294"></a><span id="l8.294" class="difflineplus">+        attribs.push([this._attrCcMe.bindParameter(toIdentity.id),</span>
<a href="#l8.295"></a><span id="l8.295" class="difflineplus">+                      authorIdentity.id]);</span>
<a href="#l8.296"></a><span id="l8.296" class="difflineplus">+        if (aIsNew)</span>
<a href="#l8.297"></a><span id="l8.297" class="difflineplus">+          toIdentity.contact.popularity += this.POPULARITY_TO_ME;</span>
<a href="#l8.298"></a><span id="l8.298" class="difflineplus">+      }</span>
<a href="#l8.299"></a><span id="l8.299" class="difflineplus">+      // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l8.300"></a><span id="l8.300" class="difflineplus">+      if (isFromMe) {</span>
<a href="#l8.301"></a><span id="l8.301" class="difflineplus">+        attribs.push([this._attrFromMeCc.bindParameter(authorIdentity.id),</span>
<a href="#l8.302"></a><span id="l8.302" class="difflineplus">+                      toIdentity.id]);</span>
<a href="#l8.303"></a><span id="l8.303" class="difflineplus">+        // also, popularity</span>
<a href="#l8.304"></a><span id="l8.304" class="difflineplus">+        if (aIsNew)</span>
<a href="#l8.305"></a><span id="l8.305" class="difflineplus">+          toIdentity.contact.popularity += this.POPULARITY_FROM_ME_TO;</span>
<a href="#l8.306"></a><span id="l8.306" class="difflineplus">+      }</span>
<a href="#l8.307"></a><span id="l8.307">     }</span>
<a href="#l8.308"></a><span id="l8.308">     let ccIdentities = Gloda.getIdentitiesForFullMailAddresses(aMsgHdr.ccList);</span>
<a href="#l8.309"></a><span id="l8.309">     for (let iCc=0; iCc &lt; ccIdentities.length; iCc++) {</span>
<a href="#l8.310"></a><span id="l8.310" class="difflineminus">-      attribs.push([this._attrCc.id, ccIdentities[iCc].id]);</span>
<a href="#l8.311"></a><span id="l8.311" class="difflineplus">+      let ccIdentity = ccIdentities[iCc];</span>
<a href="#l8.312"></a><span id="l8.312" class="difflineplus">+      attribs.push([this._attrCc.id, ccIdentity.id]);</span>
<a href="#l8.313"></a><span id="l8.313" class="difflineplus">+      // optimization attribute cc-me ('I' am the parameter)</span>
<a href="#l8.314"></a><span id="l8.314" class="difflineplus">+      if (ccIdentity.id in myIdentities) {</span>
<a href="#l8.315"></a><span id="l8.315" class="difflineplus">+        attribs.push([this._attrCcMe.bindParameter(ccIdentity.id),</span>
<a href="#l8.316"></a><span id="l8.316" class="difflineplus">+                      authorIdentity.id]);</span>
<a href="#l8.317"></a><span id="l8.317" class="difflineplus">+        if (aIsNew)</span>
<a href="#l8.318"></a><span id="l8.318" class="difflineplus">+          ccIdentity.contact.popularity += this.POPULARITY_CC_ME;</span>
<a href="#l8.319"></a><span id="l8.319" class="difflineplus">+      }</span>
<a href="#l8.320"></a><span id="l8.320" class="difflineplus">+      // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l8.321"></a><span id="l8.321" class="difflineplus">+      if (isFromMe) {</span>
<a href="#l8.322"></a><span id="l8.322" class="difflineplus">+        attribs.push([this._attrFromMeCc.bindParameter(authorIdentity.id),</span>
<a href="#l8.323"></a><span id="l8.323" class="difflineplus">+                      ccIdentity.id]);</span>
<a href="#l8.324"></a><span id="l8.324" class="difflineplus">+        // also, popularity</span>
<a href="#l8.325"></a><span id="l8.325" class="difflineplus">+        if (aIsNew)</span>
<a href="#l8.326"></a><span id="l8.326" class="difflineplus">+          ccIdentity.contact.popularity += this.POPULARITY_FROM_ME_CC;</span>
<a href="#l8.327"></a><span id="l8.327" class="difflineplus">+      }</span>
<a href="#l8.328"></a><span id="l8.328">     }</span>
<a href="#l8.329"></a><span id="l8.329">     </span>
<a href="#l8.330"></a><span id="l8.330" class="difflineplus">+    // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l8.331"></a><span id="l8.331" class="difflineplus">+    //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l8.332"></a><span id="l8.332" class="difflineplus">+    //  available.  (which we'll simply pass to everyone... it can help body</span>
<a href="#l8.333"></a><span id="l8.333" class="difflineplus">+    //  logic for quoting purposes, etc. too.)</span>
<a href="#l8.334"></a><span id="l8.334" class="difflineplus">+    </span>
<a href="#l8.335"></a><span id="l8.335">     // -- Date</span>
<a href="#l8.336"></a><span id="l8.336">     attribs.push([this._attrDate.id, aMsgHdr.date]);</span>
<a href="#l8.337"></a><span id="l8.337">     </span>
<a href="#l8.338"></a><span id="l8.338">     this._log.debug(&quot;returning attribs: &quot; + attribs);</span>
<a href="#l8.339"></a><span id="l8.339">     </span>
<a href="#l8.340"></a><span id="l8.340">     return attribs;</span>
<a href="#l8.341"></a><span id="l8.341">   },</span>
<a href="#l8.342"></a><span id="l8.342"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -53,16 +53,17 @@ Cu.import(&quot;resource://gloda/modules/util</span>
<a href="#l9.4"></a><span id="l9.4"> /**</span>
<a href="#l9.5"></a><span id="l9.5">  * </span>
<a href="#l9.6"></a><span id="l9.6">  */</span>
<a href="#l9.7"></a><span id="l9.7"> let Gloda = {</span>
<a href="#l9.8"></a><span id="l9.8">   _init: function gloda_ns_init() {</span>
<a href="#l9.9"></a><span id="l9.9">     this._initLogging();</span>
<a href="#l9.10"></a><span id="l9.10">     GlodaDatastore._init();</span>
<a href="#l9.11"></a><span id="l9.11">     this._initAttributes();</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+    this._initMyIdentities();</span>
<a href="#l9.13"></a><span id="l9.13">   },</span>
<a href="#l9.14"></a><span id="l9.14">   </span>
<a href="#l9.15"></a><span id="l9.15">   _log: null,</span>
<a href="#l9.16"></a><span id="l9.16">   _initLogging: function gloda_ns_initLogging() {</span>
<a href="#l9.17"></a><span id="l9.17">     let formatter = new Log4Moz.BasicFormatter();</span>
<a href="#l9.18"></a><span id="l9.18">     let root = Log4Moz.Service.rootLogger;</span>
<a href="#l9.19"></a><span id="l9.19">     root.level = Log4Moz.Level.Debug;</span>
<a href="#l9.20"></a><span id="l9.20"> </span>
<a href="#l9.21"></a><span id="l9.21" class="difflineat">@@ -136,16 +137,114 @@ let Gloda = {</span>
<a href="#l9.22"></a><span id="l9.22">                      &quot; for address: &quot; + aMailAddress);</span>
<a href="#l9.23"></a><span id="l9.23">       return null;</span>
<a href="#l9.24"></a><span id="l9.24">     }    </span>
<a href="#l9.25"></a><span id="l9.25">     </span>
<a href="#l9.26"></a><span id="l9.26">     return identities[0];</span>
<a href="#l9.27"></a><span id="l9.27">   },</span>
<a href="#l9.28"></a><span id="l9.28">   </span>
<a href="#l9.29"></a><span id="l9.29">   /**</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineplus">+   * Dictionary of the user's known identities; key is the identity id, value</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineplus">+   *  is the actual identity.</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+   */</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineplus">+  myIdentities: {},</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineplus">+  myContact: null,</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineplus">+  /**</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineplus">+   * Populate myIdentities with all of our identities.  Also, populate</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineplus">+   *  myContact.</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineplus">+   *</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineplus">+   * @TODO deal with account addition/modification/removal</span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+   */</span>
<a href="#l9.41"></a><span id="l9.41" class="difflineplus">+  _initMyIdentities: function gloda_ns_initMyIdentities() {</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+    let myContact = null;</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineplus">+    let myIdentities = {};</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+    let myEmailAddresses = {}; // process each email at most once; stored here</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineplus">+    </span>
<a href="#l9.46"></a><span id="l9.46" class="difflineplus">+    let fullName = null;</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineplus">+    let existingIdentities = [];</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineplus">+    let identitiesToCreate = [];</span>
<a href="#l9.49"></a><span id="l9.49" class="difflineplus">+  </span>
<a href="#l9.50"></a><span id="l9.50" class="difflineplus">+    let msgAccountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineplus">+                            getService(Ci.nsIMsgAccountManager);</span>
<a href="#l9.52"></a><span id="l9.52" class="difflineplus">+    let numIdentities = msgAccountManager.allIdentities.Count();</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineplus">+    </span>
<a href="#l9.54"></a><span id="l9.54" class="difflineplus">+    // nothing to do if there are no accounts/identities.</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineplus">+    if (!numIdentities)</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineplus">+      return;</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineplus">+    </span>
<a href="#l9.58"></a><span id="l9.58" class="difflineplus">+    for (let iIdentity=0; iIdentity &lt; numIdentities; iIdentity++) {</span>
<a href="#l9.59"></a><span id="l9.59" class="difflineplus">+      let msgIdentity = msgAccountManager.allIdentities.GetElementAt(iIdentity)</span>
<a href="#l9.60"></a><span id="l9.60" class="difflineplus">+                                         .QueryInterface(Ci.nsIMsgIdentity);</span>
<a href="#l9.61"></a><span id="l9.61" class="difflineplus">+      </span>
<a href="#l9.62"></a><span id="l9.62" class="difflineplus">+      if (fullName === null)</span>
<a href="#l9.63"></a><span id="l9.63" class="difflineplus">+        fullName = msgIdentity.fullName;</span>
<a href="#l9.64"></a><span id="l9.64" class="difflineplus">+        </span>
<a href="#l9.65"></a><span id="l9.65" class="difflineplus">+      let emailAddress = msgIdentity.email;</span>
<a href="#l9.66"></a><span id="l9.66" class="difflineplus">+      let replyTo = msgIdentity.replyTo;</span>
<a href="#l9.67"></a><span id="l9.67" class="difflineplus">+</span>
<a href="#l9.68"></a><span id="l9.68" class="difflineplus">+      // find the identities if they exist, flag to create them if they don't</span>
<a href="#l9.69"></a><span id="l9.69" class="difflineplus">+      if (emailAddress) {</span>
<a href="#l9.70"></a><span id="l9.70" class="difflineplus">+        parsed = GlodaUtils.parseMailAddresses(emailAddress);</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineplus">+        if (!(parsed.addresses[0] in myEmailAddresses)) {</span>
<a href="#l9.72"></a><span id="l9.72" class="difflineplus">+          let identity = GlodaDatastore.getIdentity(&quot;email&quot;,</span>
<a href="#l9.73"></a><span id="l9.73" class="difflineplus">+                                                    parsed.addresses[0]);</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineplus">+          if (identity)</span>
<a href="#l9.75"></a><span id="l9.75" class="difflineplus">+            existingIdentities.push(identity);</span>
<a href="#l9.76"></a><span id="l9.76" class="difflineplus">+          else</span>
<a href="#l9.77"></a><span id="l9.77" class="difflineplus">+            identitiesToCreate.push(parsed.addresses[0]);</span>
<a href="#l9.78"></a><span id="l9.78" class="difflineplus">+          myEmailAddresses[parsed.addresses[0]] = true;</span>
<a href="#l9.79"></a><span id="l9.79" class="difflineplus">+        }</span>
<a href="#l9.80"></a><span id="l9.80" class="difflineplus">+      }</span>
<a href="#l9.81"></a><span id="l9.81" class="difflineplus">+      if (replyTo) {</span>
<a href="#l9.82"></a><span id="l9.82" class="difflineplus">+        parsed = GlodaUtils.parseMailAddresses(replyTo);</span>
<a href="#l9.83"></a><span id="l9.83" class="difflineplus">+        if (!(parsed.addresses[0] in myEmailAddresses)) {</span>
<a href="#l9.84"></a><span id="l9.84" class="difflineplus">+          let identity = GlodaDatastore.getIdentity(&quot;email&quot;,</span>
<a href="#l9.85"></a><span id="l9.85" class="difflineplus">+                                                    parsed.addresses[0]);</span>
<a href="#l9.86"></a><span id="l9.86" class="difflineplus">+          if (identity)</span>
<a href="#l9.87"></a><span id="l9.87" class="difflineplus">+            existingIdentities.push(identity);</span>
<a href="#l9.88"></a><span id="l9.88" class="difflineplus">+          else</span>
<a href="#l9.89"></a><span id="l9.89" class="difflineplus">+            identitiesToCreate.push(parsed.addresses[0]);</span>
<a href="#l9.90"></a><span id="l9.90" class="difflineplus">+          myEmailAddresses[parsed.addresses[0]] = true;</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineplus">+        }</span>
<a href="#l9.92"></a><span id="l9.92" class="difflineplus">+      }</span>
<a href="#l9.93"></a><span id="l9.93" class="difflineplus">+    }</span>
<a href="#l9.94"></a><span id="l9.94" class="difflineplus">+    </span>
<a href="#l9.95"></a><span id="l9.95" class="difflineplus">+    if (existingIdentities.length) {</span>
<a href="#l9.96"></a><span id="l9.96" class="difflineplus">+      // just use the first guy's contact</span>
<a href="#l9.97"></a><span id="l9.97" class="difflineplus">+      myContact = existingIdentities[0].contact;</span>
<a href="#l9.98"></a><span id="l9.98" class="difflineplus">+    }</span>
<a href="#l9.99"></a><span id="l9.99" class="difflineplus">+    else {</span>
<a href="#l9.100"></a><span id="l9.100" class="difflineplus">+      // create a new contact</span>
<a href="#l9.101"></a><span id="l9.101" class="difflineplus">+      myContact = GlodaDatastore.createContact(null, null, fullName || &quot;Me&quot;);</span>
<a href="#l9.102"></a><span id="l9.102" class="difflineplus">+    }</span>
<a href="#l9.103"></a><span id="l9.103" class="difflineplus">+    </span>
<a href="#l9.104"></a><span id="l9.104" class="difflineplus">+    if (identitiesToCreate.length) {</span>
<a href="#l9.105"></a><span id="l9.105" class="difflineplus">+      for (let iIdentity=0; iIdentity &lt; identitiesToCreate.length; iIdentity++){</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineplus">+        let emailAddress = identitiesToCreate[iIdentity];</span>
<a href="#l9.107"></a><span id="l9.107" class="difflineplus">+        // XXX this won't always be of type &quot;email&quot; as we add new account types</span>
<a href="#l9.108"></a><span id="l9.108" class="difflineplus">+        // XXX the blank string could be trying to differentiate; we do have</span>
<a href="#l9.109"></a><span id="l9.109" class="difflineplus">+        //  enough info to do it.</span>
<a href="#l9.110"></a><span id="l9.110" class="difflineplus">+        let identity = GlodaDatastore.createIdentity(myContact.id, myContact,</span>
<a href="#l9.111"></a><span id="l9.111" class="difflineplus">+                                                     &quot;email&quot;,</span>
<a href="#l9.112"></a><span id="l9.112" class="difflineplus">+                                                     emailAddress,</span>
<a href="#l9.113"></a><span id="l9.113" class="difflineplus">+                                                     &quot;&quot;, false);</span>
<a href="#l9.114"></a><span id="l9.114" class="difflineplus">+        existingIdentities.push(identity);</span>
<a href="#l9.115"></a><span id="l9.115" class="difflineplus">+      }</span>
<a href="#l9.116"></a><span id="l9.116" class="difflineplus">+    }</span>
<a href="#l9.117"></a><span id="l9.117" class="difflineplus">+    </span>
<a href="#l9.118"></a><span id="l9.118" class="difflineplus">+    for (let iIdentity=0; iIdentity &lt; existingIdentities.length; iIdentity++) {</span>
<a href="#l9.119"></a><span id="l9.119" class="difflineplus">+      let identity = existingIdentities[iIdentity];</span>
<a href="#l9.120"></a><span id="l9.120" class="difflineplus">+      myIdentities[identity.id] = identity;</span>
<a href="#l9.121"></a><span id="l9.121" class="difflineplus">+    }</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineplus">+    </span>
<a href="#l9.123"></a><span id="l9.123" class="difflineplus">+    this.myContact = myContact;</span>
<a href="#l9.124"></a><span id="l9.124" class="difflineplus">+    this.myIdentities = myIdentities;   </span>
<a href="#l9.125"></a><span id="l9.125" class="difflineplus">+  },</span>
<a href="#l9.126"></a><span id="l9.126" class="difflineplus">+  </span>
<a href="#l9.127"></a><span id="l9.127" class="difflineplus">+  /**</span>
<a href="#l9.128"></a><span id="l9.128">    * An attribute that is a defining characteristic of the subject.</span>
<a href="#l9.129"></a><span id="l9.129">    */</span>
<a href="#l9.130"></a><span id="l9.130">   kAttrFundamental: 0,</span>
<a href="#l9.131"></a><span id="l9.131">   /**</span>
<a href="#l9.132"></a><span id="l9.132">    * An attribute that is an optimization derived from two or more fundamental</span>
<a href="#l9.133"></a><span id="l9.133">    *  attributes and exists solely to improve database query performance.</span>
<a href="#l9.134"></a><span id="l9.134">    */</span>
<a href="#l9.135"></a><span id="l9.135">   kAttrOptimization: 1,</span>
<a href="#l9.136"></a><span id="l9.136" class="difflineat">@@ -164,28 +263,61 @@ let Gloda = {</span>
<a href="#l9.137"></a><span id="l9.137">   /**</span>
<a href="#l9.138"></a><span id="l9.138">    * An attribute that is indirectly the result of a user's behaviour.  For</span>
<a href="#l9.139"></a><span id="l9.139">    *  example, if a user consults a message multiple times, we may conclude that</span>
<a href="#l9.140"></a><span id="l9.140">    *  the user finds the message interesting.  It is &quot;implied&quot;, if you will,</span>
<a href="#l9.141"></a><span id="l9.141">    *  that the message is interesting.</span>
<a href="#l9.142"></a><span id="l9.142">    */</span>
<a href="#l9.143"></a><span id="l9.143">   kAttrImplicit: 4,</span>
<a href="#l9.144"></a><span id="l9.144">   </span>
<a href="#l9.145"></a><span id="l9.145" class="difflineplus">+  kSpecialNotAtAll: 0,</span>
<a href="#l9.146"></a><span id="l9.146" class="difflineplus">+  /**</span>
<a href="#l9.147"></a><span id="l9.147" class="difflineplus">+   * This attribute is stored as a column on the row for the noun.  The</span>
<a href="#l9.148"></a><span id="l9.148" class="difflineplus">+   *  attribute definition should include this value as 'special' and the</span>
<a href="#l9.149"></a><span id="l9.149" class="difflineplus">+   *  column name that stores the attribute as 'specialColumnName'.</span>
<a href="#l9.150"></a><span id="l9.150" class="difflineplus">+   */</span>
<a href="#l9.151"></a><span id="l9.151" class="difflineplus">+  kSpecialColumn: 1,</span>
<a href="#l9.152"></a><span id="l9.152" class="difflineplus">+  /**</span>
<a href="#l9.153"></a><span id="l9.153" class="difflineplus">+   * This attribute is stored as a fulltext column on the fulltext table for</span>
<a href="#l9.154"></a><span id="l9.154" class="difflineplus">+   *  the noun.  The attribute defintion should include this value as 'special'</span>
<a href="#l9.155"></a><span id="l9.155" class="difflineplus">+   *  and the column name that stores the table as 'specialColumnName'.</span>
<a href="#l9.156"></a><span id="l9.156" class="difflineplus">+   */</span>
<a href="#l9.157"></a><span id="l9.157" class="difflineplus">+  kSpecialFulltext: 2,</span>
<a href="#l9.158"></a><span id="l9.158" class="difflineplus">+  </span>
<a href="#l9.159"></a><span id="l9.159">   BUILT_IN: &quot;built-in&quot;,</span>
<a href="#l9.160"></a><span id="l9.160">   </span>
<a href="#l9.161"></a><span id="l9.161">   NOUN_BOOLEAN: 1,</span>
<a href="#l9.162"></a><span id="l9.162" class="difflineplus">+  NOUN_NUMBER: 2,</span>
<a href="#l9.163"></a><span id="l9.163">   /** A date, encoded as a PRTime, represented as a js Date object. */</span>
<a href="#l9.164"></a><span id="l9.164">   NOUN_DATE: 10,</span>
<a href="#l9.165"></a><span id="l9.165" class="difflineplus">+  /**</span>
<a href="#l9.166"></a><span id="l9.166" class="difflineplus">+   * Fulltext search support, somewhat magical.  This is only intended to be</span>
<a href="#l9.167"></a><span id="l9.167" class="difflineplus">+   *  used for kSpecialFulltext attributes, and exclusively as a constraint</span>
<a href="#l9.168"></a><span id="l9.168" class="difflineplus">+   *  mechanism.  The values are always represented as strings.  It is presumed</span>
<a href="#l9.169"></a><span id="l9.169" class="difflineplus">+   *  that the user of this functionality knows how to generate SQLite FTS3</span>
<a href="#l9.170"></a><span id="l9.170" class="difflineplus">+   *  style MATCH queries, or is okay with us just gluing them together with</span>
<a href="#l9.171"></a><span id="l9.171" class="difflineplus">+   *  &quot; OR &quot; when used in an or-constraint case.  Gloda's query mechanism</span>
<a href="#l9.172"></a><span id="l9.172" class="difflineplus">+   *  currently lacks the ability to to compile Gloda-style and-constraints</span>
<a href="#l9.173"></a><span id="l9.173" class="difflineplus">+   *  into a single MATCH query, but it will turn out okay, just less</span>
<a href="#l9.174"></a><span id="l9.174" class="difflineplus">+   *  efficiently than it could.</span>
<a href="#l9.175"></a><span id="l9.175" class="difflineplus">+   */</span>
<a href="#l9.176"></a><span id="l9.176" class="difflineplus">+  NOUN_FULLTEXT: 20,</span>
<a href="#l9.177"></a><span id="l9.177">   NOUN_TAG: 50,</span>
<a href="#l9.178"></a><span id="l9.178">   NOUN_FOLDER: 100,</span>
<a href="#l9.179"></a><span id="l9.179">   NOUN_CONVERSATION: 101,</span>
<a href="#l9.180"></a><span id="l9.180">   NOUN_MESSAGE: 102,</span>
<a href="#l9.181"></a><span id="l9.181" class="difflineminus">-  NOUN_CONTACT: 103,</span>
<a href="#l9.182"></a><span id="l9.182" class="difflineplus">+  NOUN_CONTACT: GlodaContact.prototype.NOUN_ID, // 103</span>
<a href="#l9.183"></a><span id="l9.183">   NOUN_IDENTITY: 104,</span>
<a href="#l9.184"></a><span id="l9.184">   </span>
<a href="#l9.185"></a><span id="l9.185" class="difflineplus">+  /**</span>
<a href="#l9.186"></a><span id="l9.186" class="difflineplus">+   * Parameterized identities, for use in the from-me, to-me, cc-me optimization</span>
<a href="#l9.187"></a><span id="l9.187" class="difflineplus">+   *  cases.  Not for reuse without some thought.</span>
<a href="#l9.188"></a><span id="l9.188" class="difflineplus">+   */</span>
<a href="#l9.189"></a><span id="l9.189" class="difflineplus">+  NOUN_PARAM_IDENTITY: 200,</span>
<a href="#l9.190"></a><span id="l9.190" class="difflineplus">+  </span>
<a href="#l9.191"></a><span id="l9.191">   /** Next Noun ID to hand out, these don't need to be persisted (for now). */</span>
<a href="#l9.192"></a><span id="l9.192">   _nextNounID: 1000,</span>
<a href="#l9.193"></a><span id="l9.193"> </span>
<a href="#l9.194"></a><span id="l9.194">   _nounNameToNounID: {},</span>
<a href="#l9.195"></a><span id="l9.195">   _nounIDToMeta: {},</span>
<a href="#l9.196"></a><span id="l9.196">   </span>
<a href="#l9.197"></a><span id="l9.197">   /**</span>
<a href="#l9.198"></a><span id="l9.198">    * Define a noun.  Takes a dictionary with the following keys/values:</span>
<a href="#l9.199"></a><span id="l9.199" class="difflineat">@@ -228,16 +360,23 @@ let Gloda = {</span>
<a href="#l9.200"></a><span id="l9.200">     if (aNounID === undefined)</span>
<a href="#l9.201"></a><span id="l9.201">       aNounID = this._nextNounID++;</span>
<a href="#l9.202"></a><span id="l9.202">     aNounMeta.id = aNounID;</span>
<a href="#l9.203"></a><span id="l9.203">     // if it has a table, you can query on it.  seems straight-forward.</span>
<a href="#l9.204"></a><span id="l9.204">     if (aNounMeta.tableName) {</span>
<a href="#l9.205"></a><span id="l9.205">       [aNounMeta.queryClass, aNounMeta.explicitQueryClass] =</span>
<a href="#l9.206"></a><span id="l9.206">         GlodaQueryClassFactory(aNounMeta);</span>
<a href="#l9.207"></a><span id="l9.207">     }</span>
<a href="#l9.208"></a><span id="l9.208" class="difflineplus">+    if (aNounMeta.cache) {</span>
<a href="#l9.209"></a><span id="l9.209" class="difflineplus">+      let cacheCost = aNounMeta.cacheCost || 1024;</span>
<a href="#l9.210"></a><span id="l9.210" class="difflineplus">+      let cacheBudget = aNounMeta.cacheBudget || 128 * 1024;</span>
<a href="#l9.211"></a><span id="l9.211" class="difflineplus">+      let cacheSize = Math.floor(cacheBudget / cacheCost);</span>
<a href="#l9.212"></a><span id="l9.212" class="difflineplus">+      if (cacheSize)</span>
<a href="#l9.213"></a><span id="l9.213" class="difflineplus">+        GlodaCollectionManager.defineCache(aNounMeta, cacheSize);</span>
<a href="#l9.214"></a><span id="l9.214" class="difflineplus">+    }</span>
<a href="#l9.215"></a><span id="l9.215">     this._nounNameToNounID[aNounMeta.name] = aNounID; </span>
<a href="#l9.216"></a><span id="l9.216">     this._nounIDToMeta[aNounID] = aNounMeta;</span>
<a href="#l9.217"></a><span id="l9.217">     aNounMeta.actions = [];</span>
<a href="#l9.218"></a><span id="l9.218">   },</span>
<a href="#l9.219"></a><span id="l9.219">   </span>
<a href="#l9.220"></a><span id="l9.220">   /**</span>
<a href="#l9.221"></a><span id="l9.221">    * Lookup a noun (ID) suitable for passing to defineAttribute's various</span>
<a href="#l9.222"></a><span id="l9.222">    *  noun arguments.  Throws an exception if the noun with the given name</span>
<a href="#l9.223"></a><span id="l9.223" class="difflineat">@@ -277,24 +416,44 @@ let Gloda = {</span>
<a href="#l9.224"></a><span id="l9.224">       class: Boolean, firstClass: false,</span>
<a href="#l9.225"></a><span id="l9.225">       fromParamAndValue: function(aParam, aVal) {</span>
<a href="#l9.226"></a><span id="l9.226">         if(aVal != 0) return true; else return false;</span>
<a href="#l9.227"></a><span id="l9.227">       },</span>
<a href="#l9.228"></a><span id="l9.228">       toParamAndValue: function(aBool) {</span>
<a href="#l9.229"></a><span id="l9.229">         return [null, aBool ? 1 : 0];</span>
<a href="#l9.230"></a><span id="l9.230">       }}, this.NOUN_BOOLEAN);</span>
<a href="#l9.231"></a><span id="l9.231">     this.defineNoun({</span>
<a href="#l9.232"></a><span id="l9.232" class="difflineplus">+      name: &quot;number&quot;,</span>
<a href="#l9.233"></a><span id="l9.233" class="difflineplus">+      class: Number, firstClass: false,</span>
<a href="#l9.234"></a><span id="l9.234" class="difflineplus">+      fromParamAndValue: function(aIgnoredParam, aNum) {</span>
<a href="#l9.235"></a><span id="l9.235" class="difflineplus">+        return aNum;</span>
<a href="#l9.236"></a><span id="l9.236" class="difflineplus">+      },</span>
<a href="#l9.237"></a><span id="l9.237" class="difflineplus">+      toParamAndValue: function(aNum) {</span>
<a href="#l9.238"></a><span id="l9.238" class="difflineplus">+        return [null, aNum];</span>
<a href="#l9.239"></a><span id="l9.239" class="difflineplus">+      }}, this.NOUN_NUMBER);</span>
<a href="#l9.240"></a><span id="l9.240" class="difflineplus">+    this.defineNoun({</span>
<a href="#l9.241"></a><span id="l9.241">       name: &quot;date&quot;,</span>
<a href="#l9.242"></a><span id="l9.242">       class: Date, firstClass: false, continuous: true,</span>
<a href="#l9.243"></a><span id="l9.243">       fromParamAndValue: function(aParam, aPRTime) {</span>
<a href="#l9.244"></a><span id="l9.244">         return new Date(aPRTime / 1000);</span>
<a href="#l9.245"></a><span id="l9.245">       },</span>
<a href="#l9.246"></a><span id="l9.246">       toParamAndValue: function(aDate) {</span>
<a href="#l9.247"></a><span id="l9.247">         return [null, aDate.valueOf() * 1000];</span>
<a href="#l9.248"></a><span id="l9.248">       }}, this.NOUN_DATE);</span>
<a href="#l9.249"></a><span id="l9.249" class="difflineplus">+    this.defineNoun({</span>
<a href="#l9.250"></a><span id="l9.250" class="difflineplus">+      name: &quot;fulltext&quot;,</span>
<a href="#l9.251"></a><span id="l9.251" class="difflineplus">+      class: String, firstClass: false, continuous: false,</span>
<a href="#l9.252"></a><span id="l9.252" class="difflineplus">+      // as noted on NOUN_FULLTEXT, we just pass the string around.  it never</span>
<a href="#l9.253"></a><span id="l9.253" class="difflineplus">+      //  hits the database, so it's okay.</span>
<a href="#l9.254"></a><span id="l9.254" class="difflineplus">+      fromParamAndValue: function(aParam, aString) {</span>
<a href="#l9.255"></a><span id="l9.255" class="difflineplus">+        return aString;</span>
<a href="#l9.256"></a><span id="l9.256" class="difflineplus">+      },</span>
<a href="#l9.257"></a><span id="l9.257" class="difflineplus">+      toParamAndValue: function(aString) {</span>
<a href="#l9.258"></a><span id="l9.258" class="difflineplus">+        return [null, aString];</span>
<a href="#l9.259"></a><span id="l9.259" class="difflineplus">+      }}, this.NOUN_FULLTEXT);</span>
<a href="#l9.260"></a><span id="l9.260"> </span>
<a href="#l9.261"></a><span id="l9.261">     this.defineNoun({</span>
<a href="#l9.262"></a><span id="l9.262">       name: &quot;folder&quot;,</span>
<a href="#l9.263"></a><span id="l9.263">       class: null,</span>
<a href="#l9.264"></a><span id="l9.264">       firstClass: false,</span>
<a href="#l9.265"></a><span id="l9.265">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l9.266"></a><span id="l9.266">         return GlodaDatastore._mapFolderID(aID);</span>
<a href="#l9.267"></a><span id="l9.267">       },</span>
<a href="#l9.268"></a><span id="l9.268" class="difflineat">@@ -304,76 +463,99 @@ let Gloda = {</span>
<a href="#l9.269"></a><span id="l9.269">     // TODO: use some form of (weak) caching layer... it is reasonably likely</span>
<a href="#l9.270"></a><span id="l9.270">     //  that there will be a high degree of correlation in many cases, and</span>
<a href="#l9.271"></a><span id="l9.271">     //  unless the UI is extremely clever and does its cleverness before</span>
<a href="#l9.272"></a><span id="l9.272">     //  examining the data, we will probably hit the correlation.</span>
<a href="#l9.273"></a><span id="l9.273">     this.defineNoun({</span>
<a href="#l9.274"></a><span id="l9.274">       name: &quot;conversation&quot;,</span>
<a href="#l9.275"></a><span id="l9.275">       class: GlodaConversation,</span>
<a href="#l9.276"></a><span id="l9.276">       firstClass: false,</span>
<a href="#l9.277"></a><span id="l9.277" class="difflineplus">+      cache: true, cacheCost: 512,</span>
<a href="#l9.278"></a><span id="l9.278">       tableName: &quot;conversations&quot;,</span>
<a href="#l9.279"></a><span id="l9.279">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;conversationID&quot;,</span>
<a href="#l9.280"></a><span id="l9.280">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l9.281"></a><span id="l9.281">         return GlodaDatastore.getConversationByID(aID);</span>
<a href="#l9.282"></a><span id="l9.282">       },</span>
<a href="#l9.283"></a><span id="l9.283">       toParamAndValue: function(aConversation) {</span>
<a href="#l9.284"></a><span id="l9.284">         if (aConversation instanceof GlodaConversation)</span>
<a href="#l9.285"></a><span id="l9.285">           return [null, aConversation.id];</span>
<a href="#l9.286"></a><span id="l9.286">         else // assume they're just passing the id directly</span>
<a href="#l9.287"></a><span id="l9.287">           return [null, aConversation];</span>
<a href="#l9.288"></a><span id="l9.288">       }}, this.NOUN_CONVERSATION);</span>
<a href="#l9.289"></a><span id="l9.289">     this.defineNoun({</span>
<a href="#l9.290"></a><span id="l9.290">       name: &quot;message&quot;,</span>
<a href="#l9.291"></a><span id="l9.291">       class: GlodaMessage,</span>
<a href="#l9.292"></a><span id="l9.292">       firstClass: true,</span>
<a href="#l9.293"></a><span id="l9.293" class="difflineplus">+      cache: true, cacheCost: 2048, </span>
<a href="#l9.294"></a><span id="l9.294">       tableName: &quot;messages&quot;,</span>
<a href="#l9.295"></a><span id="l9.295">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;messageID&quot;,</span>
<a href="#l9.296"></a><span id="l9.296">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._messageFromRow,</span>
<a href="#l9.297"></a><span id="l9.297">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l9.298"></a><span id="l9.298">         return GlodaDatastore.getMessageByID(aID);</span>
<a href="#l9.299"></a><span id="l9.299">       },</span>
<a href="#l9.300"></a><span id="l9.300">       toParamAndValue: function(aMessage) {</span>
<a href="#l9.301"></a><span id="l9.301">         if (aMessage instanceof GlodaMessage)</span>
<a href="#l9.302"></a><span id="l9.302">           return [null, aMessage.id];</span>
<a href="#l9.303"></a><span id="l9.303">         else // assume they're just passing the id directly</span>
<a href="#l9.304"></a><span id="l9.304">           return [null, aMessage];</span>
<a href="#l9.305"></a><span id="l9.305">       }}, this.NOUN_MESSAGE);</span>
<a href="#l9.306"></a><span id="l9.306">     this.defineNoun({</span>
<a href="#l9.307"></a><span id="l9.307">       name: &quot;contact&quot;,</span>
<a href="#l9.308"></a><span id="l9.308">       class: GlodaContact,</span>
<a href="#l9.309"></a><span id="l9.309">       firstClass: false,</span>
<a href="#l9.310"></a><span id="l9.310" class="difflineplus">+      cache: true, cacheCost: 128,</span>
<a href="#l9.311"></a><span id="l9.311">       tableName: &quot;contacts&quot;,</span>
<a href="#l9.312"></a><span id="l9.312">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._contactFromRow,</span>
<a href="#l9.313"></a><span id="l9.313" class="difflineplus">+      objUpdate: GlodaDatastore.updateContact,</span>
<a href="#l9.314"></a><span id="l9.314">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l9.315"></a><span id="l9.315">         return GlodaDatastore.getContactByID(aID);</span>
<a href="#l9.316"></a><span id="l9.316">       },</span>
<a href="#l9.317"></a><span id="l9.317">       toParamAndValue: function(aContact) {</span>
<a href="#l9.318"></a><span id="l9.318">         if (aContact instanceof GlodaContact)</span>
<a href="#l9.319"></a><span id="l9.319">           return [null, aContact.id];</span>
<a href="#l9.320"></a><span id="l9.320">         else // assume they're just passing the id directly</span>
<a href="#l9.321"></a><span id="l9.321">           return [null, aContact];</span>
<a href="#l9.322"></a><span id="l9.322">       }}, this.NOUN_CONTACT);</span>
<a href="#l9.323"></a><span id="l9.323">     this.defineNoun({</span>
<a href="#l9.324"></a><span id="l9.324">       name: &quot;identity&quot;,</span>
<a href="#l9.325"></a><span id="l9.325">       class: GlodaIdentity,</span>
<a href="#l9.326"></a><span id="l9.326">       firstClass: false,</span>
<a href="#l9.327"></a><span id="l9.327" class="difflineplus">+      cache: true, cacheCost: 128,</span>
<a href="#l9.328"></a><span id="l9.328">       tableName: &quot;identities&quot;,</span>
<a href="#l9.329"></a><span id="l9.329">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._identityFromRow,</span>
<a href="#l9.330"></a><span id="l9.330">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l9.331"></a><span id="l9.331">         return GlodaDatastore.getIdentityByID(aID);</span>
<a href="#l9.332"></a><span id="l9.332">       },</span>
<a href="#l9.333"></a><span id="l9.333">       toParamAndValue: function(aIdentity) {</span>
<a href="#l9.334"></a><span id="l9.334">         if (aIdentity instanceof GlodaIdentity)</span>
<a href="#l9.335"></a><span id="l9.335">           return [null, aIdentity.id];</span>
<a href="#l9.336"></a><span id="l9.336">         else // assume they're just passing the id directly</span>
<a href="#l9.337"></a><span id="l9.337">           return [null, aIdentity];</span>
<a href="#l9.338"></a><span id="l9.338">       }}, this.NOUN_IDENTITY);</span>
<a href="#l9.339"></a><span id="l9.339" class="difflineplus">+</span>
<a href="#l9.340"></a><span id="l9.340" class="difflineplus">+    // parameterized identity is just two identities; we store the first one</span>
<a href="#l9.341"></a><span id="l9.341" class="difflineplus">+    //  (whose value set must be very constrainted, like the 'me' identities)</span>
<a href="#l9.342"></a><span id="l9.342" class="difflineplus">+    //  as the parameter, the second (which does not need to be constrained)</span>
<a href="#l9.343"></a><span id="l9.343" class="difflineplus">+    //  as the value.</span>
<a href="#l9.344"></a><span id="l9.344" class="difflineplus">+    this.defineNoun({</span>
<a href="#l9.345"></a><span id="l9.345" class="difflineplus">+      name: &quot;parameterized-identity&quot;,</span>
<a href="#l9.346"></a><span id="l9.346" class="difflineplus">+      class: null,</span>
<a href="#l9.347"></a><span id="l9.347" class="difflineplus">+      firstClass: false,</span>
<a href="#l9.348"></a><span id="l9.348" class="difflineplus">+      fromParamAndValue: function(aParamIdentityID, aValueIdentityID) {</span>
<a href="#l9.349"></a><span id="l9.349" class="difflineplus">+        return [GlodaDatastore.getIdentityByID(aParamIdentityID),</span>
<a href="#l9.350"></a><span id="l9.350" class="difflineplus">+                GlodaDatastore.getIdentityByID(aValueIdentityID)];</span>
<a href="#l9.351"></a><span id="l9.351" class="difflineplus">+      },</span>
<a href="#l9.352"></a><span id="l9.352" class="difflineplus">+      toParamAndValue: function(aIdentityTuple) {</span>
<a href="#l9.353"></a><span id="l9.353" class="difflineplus">+        if (typeof aIdentityTuple == &quot;number&quot;)</span>
<a href="#l9.354"></a><span id="l9.354" class="difflineplus">+          return aIdentityTuple;</span>
<a href="#l9.355"></a><span id="l9.355" class="difflineplus">+        return [aIdentityTuple[0].id, aIdentityTuple[1].id];</span>
<a href="#l9.356"></a><span id="l9.356" class="difflineplus">+      }}, this.NOUN_PARAM_IDENTITY);</span>
<a href="#l9.357"></a><span id="l9.357">   </span>
<a href="#l9.358"></a><span id="l9.358">     GlodaDatastore.getAllAttributes();</span>
<a href="#l9.359"></a><span id="l9.359" class="difflineminus">-    </span>
<a href="#l9.360"></a><span id="l9.360" class="difflineplus">+        </span>
<a href="#l9.361"></a><span id="l9.361">     /* boolean actions, these are parameterized by the attribute they operate</span>
<a href="#l9.362"></a><span id="l9.362">        in the context of.  They are also (not coincidentally), ugly. */</span>
<a href="#l9.363"></a><span id="l9.363">     Gloda.defineNounAction(Gloda.NOUN_BOOLEAN, {actionType: &quot;filter&quot;,</span>
<a href="#l9.364"></a><span id="l9.364">       actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l9.365"></a><span id="l9.365">       shortName: &quot;true&quot;,</span>
<a href="#l9.366"></a><span id="l9.366">       makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l9.367"></a><span id="l9.367">         return [aAttrDef, null, 1];</span>
<a href="#l9.368"></a><span id="l9.368">       },</span>
<a href="#l9.369"></a><span id="l9.369" class="difflineat">@@ -570,16 +752,17 @@ let Gloda = {</span>
<a href="#l9.370"></a><span id="l9.370">         return attr;</span>
<a href="#l9.371"></a><span id="l9.371">       }</span>
<a href="#l9.372"></a><span id="l9.372">       </span>
<a href="#l9.373"></a><span id="l9.373">       // we are behind the abstraction veil and can set these things</span>
<a href="#l9.374"></a><span id="l9.374">       attr._provider = aAttrDef.provider;</span>
<a href="#l9.375"></a><span id="l9.375">       attr._subjectTypes = aAttrDef.subjectNouns;</span>
<a href="#l9.376"></a><span id="l9.376">       attr._objectType = aAttrDef.objectNoun;</span>
<a href="#l9.377"></a><span id="l9.377">       attr._explanationFormat = aAttrDef.explanation;</span>
<a href="#l9.378"></a><span id="l9.378" class="difflineplus">+      attr._special = aAttrDef.special || this.kSpecialNotAtAll;</span>
<a href="#l9.379"></a><span id="l9.379">       attr._specialColumnName = aAttrDef.specialColumnName || null;</span>
<a href="#l9.380"></a><span id="l9.380">       </span>
<a href="#l9.381"></a><span id="l9.381">       for (let iSubject=0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l9.382"></a><span id="l9.382">            iSubject++) {</span>
<a href="#l9.383"></a><span id="l9.383">         let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l9.384"></a><span id="l9.384">         this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l9.385"></a><span id="l9.385">                             aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l9.386"></a><span id="l9.386">       }</span>
<a href="#l9.387"></a><span id="l9.387" class="difflineat">@@ -659,26 +842,26 @@ let Gloda = {</span>
<a href="#l9.388"></a><span id="l9.388">     let collection = new GlodaCollection(aItems, null, null)</span>
<a href="#l9.389"></a><span id="l9.389">     let query = new nounMeta.explicitQueryClass(collection);</span>
<a href="#l9.390"></a><span id="l9.390">     collection.query = query;</span>
<a href="#l9.391"></a><span id="l9.391">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l9.392"></a><span id="l9.392">     return colleciton;</span>
<a href="#l9.393"></a><span id="l9.393">   },</span>
<a href="#l9.394"></a><span id="l9.394">   </span>
<a href="#l9.395"></a><span id="l9.395">   processMessage: function gloda_ns_processMessage(aMessage, aMsgHdr,</span>
<a href="#l9.396"></a><span id="l9.396" class="difflineminus">-                                                   aMimeMsg) {</span>
<a href="#l9.397"></a><span id="l9.397" class="difflineplus">+                                                   aMimeMsg, aIsNew) {</span>
<a href="#l9.398"></a><span id="l9.398">     // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l9.399"></a><span id="l9.399">     //  before applying the new attributes.</span>
<a href="#l9.400"></a><span id="l9.400">     aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l9.401"></a><span id="l9.401">     </span>
<a href="#l9.402"></a><span id="l9.402">     let allAttribs = [];</span>
<a href="#l9.403"></a><span id="l9.403">   </span>
<a href="#l9.404"></a><span id="l9.404">     for(let i = 0; i &lt; this._attrProviderOrder.length; i++) {</span>
<a href="#l9.405"></a><span id="l9.405">       let attribs = this._attrProviderOrder[i].process(aMessage, aMsgHdr,</span>
<a href="#l9.406"></a><span id="l9.406" class="difflineminus">-                                                       aMimeMsg);</span>
<a href="#l9.407"></a><span id="l9.407" class="difflineplus">+                                                       aMimeMsg, aIsNew);</span>
<a href="#l9.408"></a><span id="l9.408">       allAttribs = allAttribs.concat(attribs);</span>
<a href="#l9.409"></a><span id="l9.409">     }</span>
<a href="#l9.410"></a><span id="l9.410">     </span>
<a href="#l9.411"></a><span id="l9.411">     let outAttribs = [];</span>
<a href="#l9.412"></a><span id="l9.412">     </span>
<a href="#l9.413"></a><span id="l9.413">     for(let iAttrib=0; iAttrib &lt; allAttribs.length; iAttrib++) {</span>
<a href="#l9.414"></a><span id="l9.414">       let attribDesc = allAttribs[iAttrib];</span>
<a href="#l9.415"></a><span id="l9.415">       </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -593,16 +593,18 @@ let GlodaIndexer = {</span>
<a href="#l10.4"></a><span id="l10.4">         this._indexerLeaveFolder(true);</span>
<a href="#l10.5"></a><span id="l10.5">         this._curIndexingJob = null;</span>
<a href="#l10.6"></a><span id="l10.6">         if (this._actualWorker !== null) {</span>
<a href="#l10.7"></a><span id="l10.7">           this._actualWorker.close();</span>
<a href="#l10.8"></a><span id="l10.8">           this._actualWorker = null;</span>
<a href="#l10.9"></a><span id="l10.9">         }</span>
<a href="#l10.10"></a><span id="l10.10">       }</span>
<a href="#l10.11"></a><span id="l10.11">     }</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+    // XXX doing the dirty commit/check every time could be pretty expensive...</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+    GlodaCollectionManager.cacheCommitDirty();</span>
<a href="#l10.14"></a><span id="l10.14">     GlodaDatastore._commitTransaction();</span>
<a href="#l10.15"></a><span id="l10.15">     </span>
<a href="#l10.16"></a><span id="l10.16">     // try and get a job if we don't have one for the sake of the notification</span>
<a href="#l10.17"></a><span id="l10.17">     if (this.indexing &amp;&amp; (this._actualWorker === null))</span>
<a href="#l10.18"></a><span id="l10.18">       this._hireJobWorker();</span>
<a href="#l10.19"></a><span id="l10.19">     this._notifyListeners();</span>
<a href="#l10.20"></a><span id="l10.20">     </span>
<a href="#l10.21"></a><span id="l10.21">     yield kWorkDone;</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineat">@@ -1236,17 +1238,17 @@ let GlodaIndexer = {</span>
<a href="#l10.23"></a><span id="l10.23">       </span>
<a href="#l10.24"></a><span id="l10.24">       if (ancestorList.length == 0) {</span>
<a href="#l10.25"></a><span id="l10.25">         this._log.debug(&quot;creating message with: null, &quot; + conversationID +</span>
<a href="#l10.26"></a><span id="l10.26">                         &quot;, &quot; + references[iAncestor] +</span>
<a href="#l10.27"></a><span id="l10.27">                         &quot;, null.&quot;);</span>
<a href="#l10.28"></a><span id="l10.28">         let ancestor = this._datastore.createMessage(null, null, // ghost</span>
<a href="#l10.29"></a><span id="l10.29">                                                      conversationID, null,</span>
<a href="#l10.30"></a><span id="l10.30">                                                      references[iAncestor],</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineminus">-                                                     null); // no snippet</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+                                                     null); // no body</span>
<a href="#l10.33"></a><span id="l10.33">         ancestorLists[iAncestor].push(ancestor);</span>
<a href="#l10.34"></a><span id="l10.34">       }</span>
<a href="#l10.35"></a><span id="l10.35">     }</span>
<a href="#l10.36"></a><span id="l10.36">     // now all our ancestors exist, though they may be ghost-like...</span>
<a href="#l10.37"></a><span id="l10.37">     </span>
<a href="#l10.38"></a><span id="l10.38">     // find if there's a ghost version of our message or we already have indexed</span>
<a href="#l10.39"></a><span id="l10.39">     //  this message.</span>
<a href="#l10.40"></a><span id="l10.40">     let curMsg = null;</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineat">@@ -1281,34 +1283,43 @@ let GlodaIndexer = {</span>
<a href="#l10.42"></a><span id="l10.42">           curMsg = candMsg;</span>
<a href="#l10.43"></a><span id="l10.43">       }</span>
<a href="#l10.44"></a><span id="l10.44">       // our choice of last resort, but still okay, is a ghost message</span>
<a href="#l10.45"></a><span id="l10.45">       else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l10.46"></a><span id="l10.46">         curMsg = candMsg;</span>
<a href="#l10.47"></a><span id="l10.47">       }</span>
<a href="#l10.48"></a><span id="l10.48">     }</span>
<a href="#l10.49"></a><span id="l10.49">     </span>
<a href="#l10.50"></a><span id="l10.50" class="difflineplus">+    let isNew;</span>
<a href="#l10.51"></a><span id="l10.51">     if (curMsg === null) {</span>
<a href="#l10.52"></a><span id="l10.52">       this._log.debug(&quot;...creating new message&quot;);</span>
<a href="#l10.53"></a><span id="l10.53">       curMsg = this._datastore.createMessage(aMsgHdr.folder.URI,</span>
<a href="#l10.54"></a><span id="l10.54">                                              aMsgHdr.messageKey,                </span>
<a href="#l10.55"></a><span id="l10.55">                                              conversationID,</span>
<a href="#l10.56"></a><span id="l10.56">                                              aMsgHdr.date,</span>
<a href="#l10.57"></a><span id="l10.57">                                              aMsgHdr.messageId,</span>
<a href="#l10.58"></a><span id="l10.58">                                              null); // no snippet</span>
<a href="#l10.59"></a><span id="l10.59" class="difflineminus">-     }</span>
<a href="#l10.60"></a><span id="l10.60" class="difflineminus">-     else {</span>
<a href="#l10.61"></a><span id="l10.61" class="difflineminus">-        curMsg._folderID = this._datastore._mapFolderURI(aMsgHdr.folder.URI);</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineminus">-        curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l10.63"></a><span id="l10.63" class="difflineminus">-        this._datastore.updateMessage(curMsg);</span>
<a href="#l10.64"></a><span id="l10.64" class="difflineminus">-     }</span>
<a href="#l10.65"></a><span id="l10.65" class="difflineplus">+      isNew = true;</span>
<a href="#l10.66"></a><span id="l10.66" class="difflineplus">+    }</span>
<a href="#l10.67"></a><span id="l10.67" class="difflineplus">+    else {</span>
<a href="#l10.68"></a><span id="l10.68" class="difflineplus">+      isNew = (curMsg._messageKey === null); // aka was-a-ghost</span>
<a href="#l10.69"></a><span id="l10.69" class="difflineplus">+      curMsg._folderID = this._datastore._mapFolderURI(aMsgHdr.folder.URI);</span>
<a href="#l10.70"></a><span id="l10.70" class="difflineplus">+      curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l10.71"></a><span id="l10.71" class="difflineplus">+      // note: we are assuming that our matching logic is flawless in that</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineplus">+      //  if this message was not a ghost, we are assuming the 'body'</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineplus">+      //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineplus">+      //  that there are cases where this is not true.</span>
<a href="#l10.75"></a><span id="l10.75" class="difflineplus">+      this._datastore.updateMessage(curMsg, isNew ? aBody : null);</span>
<a href="#l10.76"></a><span id="l10.76" class="difflineplus">+    }</span>
<a href="#l10.77"></a><span id="l10.77" class="difflineplus">+    </span>
<a href="#l10.78"></a><span id="l10.78" class="difflineplus">+    // TODO: provide the parent gloda message if we can conjure it up.</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineplus">+    Gloda.processMessage(curMsg, aMsgHdr, aMimeMsg, isNew,</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineplus">+                         /* parent gloda message */ null);</span>
<a href="#l10.81"></a><span id="l10.81">      </span>
<a href="#l10.82"></a><span id="l10.82" class="difflineminus">-     Gloda.processMessage(curMsg, aMsgHdr, aMimeMsg);</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineminus">-     </span>
<a href="#l10.84"></a><span id="l10.84" class="difflineminus">-     this.callbackDriver();</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineplus">+    this.callbackDriver();</span>
<a href="#l10.86"></a><span id="l10.86">   },</span>
<a href="#l10.87"></a><span id="l10.87">   </span>
<a href="#l10.88"></a><span id="l10.88">   /**</span>
<a href="#l10.89"></a><span id="l10.89">    * Wipe a message out of existence from our index.  This is slightly more</span>
<a href="#l10.90"></a><span id="l10.90">    *  tricky than one would first expect because there are potentially</span>
<a href="#l10.91"></a><span id="l10.91">    *  attributes not immediately associated with this message that reference</span>
<a href="#l10.92"></a><span id="l10.92">    *  the message.  Not only that, but deletion of messages may leave a</span>
<a href="#l10.93"></a><span id="l10.93">    *  conversation posessing only ghost messages, which we don't want, so we</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

