<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 879:f8c55de23fac621c56dfdc33ca9d1af062bc6f96</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ f8c55de23fac621c56dfdc33ca9d1af062bc6f96" />
<meta property="og:url" content="/comm-central/rev/f8c55de23fac621c56dfdc33ca9d1af062bc6f96" />
<meta property="og:description" content="status commit: end of day." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / f8c55de23fac621c56dfdc33ca9d1af062bc6f96 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/f8c55de23fac621c56dfdc33ca9d1af062bc6f96">shortlog</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/f8c55de23fac621c56dfdc33ca9d1af062bc6f96">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96">files</a> |
changeset |
<a href="/comm-central/raw-rev/f8c55de23fac621c56dfdc33ca9d1af062bc6f96">raw</a>  | <a href="/comm-central/archive/f8c55de23fac621c56dfdc33ca9d1af062bc6f96.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
status commit: end of day.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Mon, 18 Aug 2008 03:17:16 -0700</td></tr>

<tr>
 <td>changeset 879</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/f8c55de23fac621c56dfdc33ca9d1af062bc6f96">f8c55de23fac621c56dfdc33ca9d1af062bc6f96</a></td>
</tr>



<tr>
<td>parent 878</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/cb22786c1ac026e1288a1b0dd1f1c8b7b63441db">cb22786c1ac026e1288a1b0dd1f1c8b7b63441db</a>
</td>
</tr>

<tr>
<td>child 880</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/e2e18f05fca747b2bc41a15d342924a04dbe55a1">e2e18f05fca747b2bc41a15d342924a04dbe55a1</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=f8c55de23fac621c56dfdc33ca9d1af062bc6f96">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">status commit: end of day.
 * subject auto-completion proof-of-working!
 * caching pretty much there and seems to work, including explicit dirty flushing and cache eviction.
 * popularity stuff seems to work.
 * constraints on identities based on contacts is happy.
 * suffix tree glitch fixed.
 * etc.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glautocomp.js">components/glautocomp.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glautocomp.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glautocomp.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glautocomp.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glautocomp.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glautocomp.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glmsgdbview.js">components/glmsgdbview.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glmsgdbview.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glmsgdbview.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glmsgdbview.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glmsgdbview.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/components/glmsgdbview.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/collection.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/collection.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/fundattr.js">modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/query.js">modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/query.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/query.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/query.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/query.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/query.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/suffixtree.js">modules/suffixtree.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/suffixtree.js">file</a> |
<a href="/comm-central/annotate/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/suffixtree.js">annotate</a> |
<a href="/comm-central/diff/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/suffixtree.js">diff</a> |
<a href="/comm-central/comparison/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/suffixtree.js">comparison</a> |
<a href="/comm-central/log/f8c55de23fac621c56dfdc33ca9d1af062bc6f96/modules/suffixtree.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/components/glautocomp.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/components/glautocomp.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -61,17 +61,17 @@ nsAutoCompleteGlodaResult.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">   _results: null,</span>
<a href="#l1.5"></a><span id="l1.5">   searchString: null,</span>
<a href="#l1.6"></a><span id="l1.6">   searchResult: Ci.nsIAutoCompleteResult.RESULT_FAILURE,</span>
<a href="#l1.7"></a><span id="l1.7">   defaultIndex: -1,</span>
<a href="#l1.8"></a><span id="l1.8">   errorDescription: null,</span>
<a href="#l1.9"></a><span id="l1.9">   matchCount: 0,</span>
<a href="#l1.10"></a><span id="l1.10">   getValueAt: function(aIndex) {</span>
<a href="#l1.11"></a><span id="l1.11">     let thing = this._results[aIndex];</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-    return thing.name || thing.value;</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+    return thing.name || thing.value || thing.subject;</span>
<a href="#l1.14"></a><span id="l1.14">   },</span>
<a href="#l1.15"></a><span id="l1.15">   getCommentAt: function() { return null; },</span>
<a href="#l1.16"></a><span id="l1.16">   getStyleAt: function() { return &quot;gloda-contact&quot;; },</span>
<a href="#l1.17"></a><span id="l1.17">   getImageAt: function() { return null; },</span>
<a href="#l1.18"></a><span id="l1.18">   removeValueAt: function() {}</span>
<a href="#l1.19"></a><span id="l1.19"> };</span>
<a href="#l1.20"></a><span id="l1.20"> </span>
<a href="#l1.21"></a><span id="l1.21"> function nsAutoCompleteGloda() {</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -88,43 +88,60 @@ function nsAutoCompleteGloda() {</span>
<a href="#l1.23"></a><span id="l1.23">     Cu.import(&quot;resource://gloda/modules/suffixtree.js&quot;, loadNS);</span>
<a href="#l1.24"></a><span id="l1.24">     MultiSuffixTree = loadNS.MultiSuffixTree;</span>
<a href="#l1.25"></a><span id="l1.25">   }</span>
<a href="#l1.26"></a><span id="l1.26">   </span>
<a href="#l1.27"></a><span id="l1.27">   Gloda.lookupNoun(&quot;contact&quot;);</span>
<a href="#l1.28"></a><span id="l1.28">   </span>
<a href="#l1.29"></a><span id="l1.29">   // get all the contacts</span>
<a href="#l1.30"></a><span id="l1.30">   let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-  this.contactCollection = contactQuery.getAllSync();</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+  this.contactCollection = contactQuery.popularityRange(10, null).getAllSync();</span>
<a href="#l1.33"></a><span id="l1.33"> </span>
<a href="#l1.34"></a><span id="l1.34" class="difflineminus">-  // get all the identities</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineminus">-  let identityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineminus">-  this.identityCollection = identityQuery.getAllSync();</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineplus">+  // assuming we found some contacts...</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+  if (this.contactCollection.items.length) {</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+    // get all the identities...</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+    let identityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+    // ...that belong to one of the above contacts.</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+    identityQuery.contact.apply(identityQuery, this.contactCollection.items);</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+    this.identityCollection = identityQuery.getAllSync();</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+  }</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+  else {</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+    // create an empty explicit collection</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+    this.identityCollection = Gloda.explicitCollection(Gloda.NOUN_IDENTITY, []);</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+  }</span>
<a href="#l1.49"></a><span id="l1.49">   </span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-  let contactNames = [(c.name.replace(&quot; &quot;, &quot;&quot;) || &quot;x&quot;) for each</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+  let contactNames = [(c.name.replace(&quot; &quot;, &quot;&quot;).toLowerCase() || &quot;x&quot;) for each</span>
<a href="#l1.52"></a><span id="l1.52">                       (c in this.contactCollection.items)];</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineminus">-  let identityMails = [i.value for each (i in this.identityCollection.items)];</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+  let identityMails = [i.value.toLowerCase() for each</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+                       (i in this.identityCollection.items)];</span>
<a href="#l1.56"></a><span id="l1.56">   </span>
<a href="#l1.57"></a><span id="l1.57">   this.suffixTree = new MultiSuffixTree(contactNames.concat(identityMails),</span>
<a href="#l1.58"></a><span id="l1.58">     this.contactCollection.items.concat(this.identityCollection.items));</span>
<a href="#l1.59"></a><span id="l1.59"> }</span>
<a href="#l1.60"></a><span id="l1.60"> </span>
<a href="#l1.61"></a><span id="l1.61"> nsAutoCompleteGloda.prototype = {</span>
<a href="#l1.62"></a><span id="l1.62">   classDescription: &quot;AutoCompleteGloda&quot;,</span>
<a href="#l1.63"></a><span id="l1.63">   contractID: &quot;@mozilla.org/autocomplete/search;1?name=gloda&quot;,</span>
<a href="#l1.64"></a><span id="l1.64">   classID: Components.ID(&quot;{3bbe4d77-3f70-4252-9500-bc00c26f476c}&quot;),</span>
<a href="#l1.65"></a><span id="l1.65">   QueryInterface: XPCOMUtils.generateQI([</span>
<a href="#l1.66"></a><span id="l1.66">       Components.interfaces.nsIAutoCompleteSearch]),</span>
<a href="#l1.67"></a><span id="l1.67"> </span>
<a href="#l1.68"></a><span id="l1.68">   startSearch: function(aString, aParam, aResult, aListener) {</span>
<a href="#l1.69"></a><span id="l1.69">     // only match if they type at least 3 letters...</span>
<a href="#l1.70"></a><span id="l1.70">     let matches = [];</span>
<a href="#l1.71"></a><span id="l1.71">     if (aString.length &gt;= 3) {</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineminus">-      matches = this.suffixTree.findMatches(aString);</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineminus">-    } </span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+      matches = this.suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+    }</span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+    </span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+    if (aString.length &gt;= 4) {</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+      let subjectQuery = Gloda.newQuery(Gloda.NOUN_CONVERSATION);</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+      subjectQuery.subjectMatches(aString + &quot;*&quot;);</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+      let convSubjectCollection = subjectQuery.getAllSync();</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+      matches = matches.concat(convSubjectCollection.items);</span>
<a href="#l1.82"></a><span id="l1.82" class="difflineplus">+    }</span>
<a href="#l1.83"></a><span id="l1.83">   </span>
<a href="#l1.84"></a><span id="l1.84">     var result = new nsAutoCompleteGlodaResult(aString, matches);</span>
<a href="#l1.85"></a><span id="l1.85">     aListener.onSearchResult(this, result);</span>
<a href="#l1.86"></a><span id="l1.86">   },</span>
<a href="#l1.87"></a><span id="l1.87"> </span>
<a href="#l1.88"></a><span id="l1.88">   stopSearch: function() {}</span>
<a href="#l1.89"></a><span id="l1.89"> };</span>
<a href="#l1.90"></a><span id="l1.90"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/components/glmsgdbview.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/components/glmsgdbview.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -1030,17 +1030,20 @@ dump(&quot;&amp;&amp;&amp; findIndexFromKey\n&quot;);</span>
<a href="#l2.4"></a><span id="l2.4">       return &quot;&quot;;</span>
<a href="#l2.5"></a><span id="l2.5">     </span>
<a href="#l2.6"></a><span id="l2.6">     switch(columnId[0]) {</span>
<a href="#l2.7"></a><span id="l2.7">       case &quot;s&quot;: // subject, sender, size, status</span>
<a href="#l2.8"></a><span id="l2.8">         switch(columnId[1]) {</span>
<a href="#l2.9"></a><span id="l2.9">           case &quot;u&quot;: // subject</span>
<a href="#l2.10"></a><span id="l2.10">             return message.conversation.subject; //folderMessage.mime2DecodedSubject;</span>
<a href="#l2.11"></a><span id="l2.11">           case &quot;e&quot;: // sender</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-            return message.from.contact.name;</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+            if (message.from)</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+              return message.from.contact.name;</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+            else</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+              return &quot;???&quot;;</span>
<a href="#l2.17"></a><span id="l2.17">           case &quot;i&quot;: // size</span>
<a href="#l2.18"></a><span id="l2.18">             return folderMessage.messageSize;</span>
<a href="#l2.19"></a><span id="l2.19">           case &quot;t&quot;: // status</span>
<a href="#l2.20"></a><span id="l2.20">             return messageStatusString(folderMessage.flags);</span>
<a href="#l2.21"></a><span id="l2.21">         }</span>
<a href="#l2.22"></a><span id="l2.22">         break;</span>
<a href="#l2.23"></a><span id="l2.23">       case &quot;r&quot;: // recipient, received</span>
<a href="#l2.24"></a><span id="l2.24">         switch(columnId[3]) {</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineat">@@ -1049,17 +1052,20 @@ dump(&quot;&amp;&amp;&amp; findIndexFromKey\n&quot;);</span>
<a href="#l2.26"></a><span id="l2.26">                     (recip in message.to)].join(&quot; &quot;) // folderMessage.recipients;</span>
<a href="#l2.27"></a><span id="l2.27">           case &quot;e&quot;: // received</span>
<a href="#l2.28"></a><span id="l2.28">             let recDate = new Date(1000 *</span>
<a href="#l2.29"></a><span id="l2.29">               folderMessage.getUint32Property(&quot;dateReceived&quot;));</span>
<a href="#l2.30"></a><span id="l2.30">             return GlodaUtils.dateFormat(recDate);</span>
<a href="#l2.31"></a><span id="l2.31">         }</span>
<a href="#l2.32"></a><span id="l2.32">         break;</span>
<a href="#l2.33"></a><span id="l2.33">       case &quot;d&quot;: // date</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineminus">-        return GlodaUtils.dateFormat(message.date);</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+        if (message.date)</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+          return GlodaUtils.dateFormat(message.date);</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+        else</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+          return &quot;???&quot;;</span>
<a href="#l2.39"></a><span id="l2.39">       case &quot;p&quot;: // priority</span>
<a href="#l2.40"></a><span id="l2.40">         return messagePriorityString(folderMessage.priority);</span>
<a href="#l2.41"></a><span id="l2.41">       case &quot;a&quot;: // account</span>
<a href="#l2.42"></a><span id="l2.42">         return folderMessage.accountKey;</span>
<a href="#l2.43"></a><span id="l2.43">       case &quot;t&quot;: // total messages in thread, tags</span>
<a href="#l2.44"></a><span id="l2.44">         switch (columnId[1]) {</span>
<a href="#l2.45"></a><span id="l2.45">           case &quot;h&quot;: // total messages in thread</span>
<a href="#l2.46"></a><span id="l2.46">             // per idiom, only return this for top-level nodes</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -39,16 +39,18 @@ EXPORTED_SYMBOLS = ['GlodaCollection', '</span>
<a href="#l3.4"></a><span id="l3.4"> </span>
<a href="#l3.5"></a><span id="l3.5"> const Cc = Components.classes;</span>
<a href="#l3.6"></a><span id="l3.6"> const Ci = Components.interfaces;</span>
<a href="#l3.7"></a><span id="l3.7"> const Cr = Components.results;</span>
<a href="#l3.8"></a><span id="l3.8"> const Cu = Components.utils;</span>
<a href="#l3.9"></a><span id="l3.9"> </span>
<a href="#l3.10"></a><span id="l3.10"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+const LOG = Log4Moz.Service.getLogger(&quot;gloda.collection&quot;);</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+</span>
<a href="#l3.14"></a><span id="l3.14"> /**</span>
<a href="#l3.15"></a><span id="l3.15">  * The collection manager is a singleton that has the following tasks:</span>
<a href="#l3.16"></a><span id="l3.16">  * - Let views of objects (nouns) know when their objects have changed.  For</span>
<a href="#l3.17"></a><span id="l3.17">  *   example, an attribute has changed due to user action.</span>
<a href="#l3.18"></a><span id="l3.18">  * - Let views of objects based on queries know when new objects match their</span>
<a href="#l3.19"></a><span id="l3.19">  *   query, or when their existing objects no longer match due to changes.</span>
<a href="#l3.20"></a><span id="l3.20">  * - Caching/object-identity maintenance.  It is ideal if we only ever have</span>
<a href="#l3.21"></a><span id="l3.21">  *   one instance of an object at a time.  (More specifically, only one instance</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -76,17 +78,17 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l3.23"></a><span id="l3.23">       // purge dead weak references while we're at it</span>
<a href="#l3.24"></a><span id="l3.24">       collections = this._collectionsByNoun[nounID].filter(function (aRef) {</span>
<a href="#l3.25"></a><span id="l3.25">         return aRef.get(); });</span>
<a href="#l3.26"></a><span id="l3.26">       this._collectionsByNoun[nounID] = collections;</span>
<a href="#l3.27"></a><span id="l3.27">     }</span>
<a href="#l3.28"></a><span id="l3.28">     collections.push(Cu.getWeakReference(aCollection));</span>
<a href="#l3.29"></a><span id="l3.29">   },</span>
<a href="#l3.30"></a><span id="l3.30">   </span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-  getCollectionsForNounID: function(aNounID) {</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+  getCollectionsForNounID: function gloda_colm_getCollectionsForNounID(aNounID){</span>
<a href="#l3.33"></a><span id="l3.33">     if (!(aNounID in this._collectionsByNoun))</span>
<a href="#l3.34"></a><span id="l3.34">       return [];</span>
<a href="#l3.35"></a><span id="l3.35">     </span>
<a href="#l3.36"></a><span id="l3.36">     // generator would be nice, but I suspect get() is too expensive to use</span>
<a href="#l3.37"></a><span id="l3.37">     //  twice (guard/predicate and value)</span>
<a href="#l3.38"></a><span id="l3.38">     let weakCollections = this._collectionsByNoun[aNounID];</span>
<a href="#l3.39"></a><span id="l3.39">     let collections = [];</span>
<a href="#l3.40"></a><span id="l3.40">     for (let iColl=0; iColl &lt; weakCollections.length; iColl++) {</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineat">@@ -97,66 +99,171 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l3.42"></a><span id="l3.42">     return collections;</span>
<a href="#l3.43"></a><span id="l3.43">   },</span>
<a href="#l3.44"></a><span id="l3.44">   </span>
<a href="#l3.45"></a><span id="l3.45">   defineCache: function gloda_colm_defineCache(aNounMeta, aCacheSize) {</span>
<a href="#l3.46"></a><span id="l3.46">     this._cachesByNoun[aNounMeta.id] = new GlodaLRUCacheCollection(aNounMeta,</span>
<a href="#l3.47"></a><span id="l3.47">                                                                    aCacheSize);</span>
<a href="#l3.48"></a><span id="l3.48">   },</span>
<a href="#l3.49"></a><span id="l3.49">   </span>
<a href="#l3.50"></a><span id="l3.50" class="difflineminus">-  /** </span>
<a href="#l3.51"></a><span id="l3.51" class="difflineminus">-   * Attempt to locate existing instances of nouns with the given IDs. </span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+  /**</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+   * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+   *  given id.  Counts as a cache hit if found.  (And if it was't in a cache,</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+   *  but rather a collection, it is added to the cache.)</span>
<a href="#l3.56"></a><span id="l3.56">    */</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineminus">-  cacheLookup: function gloda_colm_cacheLookup(aNounMetaID, aIDs) {</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineminus">-    // try the cache first; it has explicit semantics related to caching so</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineminus">-    //  needs slightly different treatment.  (plus, it makes sense to check</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineminus">-    //  the cache first, especially since it's not an exclusive cache.)</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineminus">-    let cache = this._cachesByNoun[aNounMetaID];</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+  cacheLookupOne: function gloda_colm_cacheLookupOne(aNounID, aID) {</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l3.64"></a><span id="l3.64">     </span>
<a href="#l3.65"></a><span id="l3.65">     if (cache) {</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineminus">-      let results = [];</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineminus">-      let hits = 0;</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineminus">-      let misses = </span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-      for each (id in aIDs) {</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-        if (id in cache._idMap) {</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-          results.push(cache.hit(id));</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineminus">-          hits++;</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineminus">-        }</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineminus">-        else</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineminus">-          results.push(null);</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+      if (aID in cache._idMap) {</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+        let item = cache._idMap[aID];</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+        return cache.hit(item);</span>
<a href="#l3.79"></a><span id="l3.79">       }</span>
<a href="#l3.80"></a><span id="l3.80">     }</span>
<a href="#l3.81"></a><span id="l3.81">   </span>
<a href="#l3.82"></a><span id="l3.82" class="difflineminus">-    // next, let's fall back to our friend dudes</span>
<a href="#l3.83"></a><span id="l3.83">     for each (let collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+      if (aID in collection._idMap) {</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+        let item = collection._idMap[aID];</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineplus">+        if (cache)</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineplus">+          cache.add([item]);</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+        return item;</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+      }</span>
<a href="#l3.90"></a><span id="l3.90">     }</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+    </span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+    return null;</span>
<a href="#l3.93"></a><span id="l3.93">   },</span>
<a href="#l3.94"></a><span id="l3.94">   </span>
<a href="#l3.95"></a><span id="l3.95" class="difflineminus">-  cacheAdd: function gloda_colm_cacheAdd(aNounMetaID, aObjs) {</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineminus">-    let cache = this._cachesByNoun[aNounMetaID];</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+  /**</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+   * Checks whether the provided item with the given id is actually a duplicate</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+   *  of an instance that already exists in the cache/a collection.  If it is,</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+   *  the pre-existing instance is returned and counts as a cache hit.  If it</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+   *  is not, the passed-in instance is added to the cache and returned.</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+   */</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+  cacheLoadUnifyOne: function gloda_colm_cacheLoadUnifyOne(aItem) {</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+    let items = [aItem];</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+    this.cacheLoadUnify(aItem.NOUN_ID, items);</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+    return items[0];</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+  },</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+  /**</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+   * Given a list of items, check if any of them already have duplicate,</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineplus">+   *  canonical, instances in the cache or collections.  Items with pre-existing</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineplus">+   *  instances are replaced by those instances in the provided list, and each</span>
<a href="#l3.113"></a><span id="l3.113" class="difflineplus">+   *  counts as a cache hit.  Items without pre-existing instances are added</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineplus">+   *  to the cache and left intact.</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineplus">+   */</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineplus">+  cacheLoadUnify: function gloda_colm_cacheLoadUnify(aNounID, aItems) {</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineplus">+    </span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+    // track the items we haven't yet found in a cache/collection (value) and</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+    //  their index in aItems (key).  We're somewhat abusing the dictionary</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+    //  metaphor with the intent of storing tuples here.  We also do it because</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineplus">+    //  it allows random-access deletion theoretically without cost.  (Since</span>
<a href="#l3.123"></a><span id="l3.123" class="difflineplus">+    //  we delete during iteration, that may be wrong, but it sounds like the</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineplus">+    //  semantics still work?)</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineplus">+    let unresolvedIndexToItem = {};</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineplus">+    let numUnresolved = 0;</span>
<a href="#l3.127"></a><span id="l3.127">     </span>
<a href="#l3.128"></a><span id="l3.128">     if (cache) {</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineminus">-      cache.add(aObjs);</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+      for (let iItem=0; iItem &lt; aItems.length; iItem++) {</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+        let item = aItems[iItem];</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+        </span>
<a href="#l3.133"></a><span id="l3.133" class="difflineplus">+        if (item.id in cache._idMap) {</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+          let realItem = cache._idMap[item.id];</span>
<a href="#l3.135"></a><span id="l3.135" class="difflineplus">+          // update the caller's array with the reference to the 'real' item</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineplus">+          aItems[iItem] = realItem;</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineplus">+          cache.hit(realItem);</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineplus">+        }</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+        else {</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+          unresolvedIndexToItem[iItem] = item;</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineplus">+          numUnresolved++;</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineplus">+        }</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+      }</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineplus">+      </span>
<a href="#l3.145"></a><span id="l3.145" class="difflineplus">+      // we're done if everyone was a hit.</span>
<a href="#l3.146"></a><span id="l3.146" class="difflineplus">+      if (numUnresolved == 0)</span>
<a href="#l3.147"></a><span id="l3.147" class="difflineplus">+        return;</span>
<a href="#l3.148"></a><span id="l3.148" class="difflineplus">+    }</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineplus">+    else {</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+      for (let iItem=0; iItem &lt; aItems.length; iItem++) {</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+        unresolvedIndexToItem[iItem] = aItems[iItem];</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineplus">+      }</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineplus">+      numUnresolved = aItems.length;</span>
<a href="#l3.154"></a><span id="l3.154">     }</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineplus">+  </span>
<a href="#l3.156"></a><span id="l3.156" class="difflineplus">+    let needToCache = [];</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+    // next, let's fall back to our collections</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+    for each (let collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l3.159"></a><span id="l3.159" class="difflineplus">+      for (let [iItem, item] in Iterator(unresolvedIndexToItem)) {</span>
<a href="#l3.160"></a><span id="l3.160" class="difflineplus">+        if (item.id in collection._idMap) {</span>
<a href="#l3.161"></a><span id="l3.161" class="difflineplus">+          let realItem = collection._idMap[item.id];</span>
<a href="#l3.162"></a><span id="l3.162" class="difflineplus">+          // update the caller's array to now have the 'real' object</span>
<a href="#l3.163"></a><span id="l3.163" class="difflineplus">+          aItems[iItem] = realItem;</span>
<a href="#l3.164"></a><span id="l3.164" class="difflineplus">+          // flag that we need to cache this guy (we use an inclusive cache)</span>
<a href="#l3.165"></a><span id="l3.165" class="difflineplus">+          needToCache.push(realItem);</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineplus">+          // we no longer need to resolve this item...</span>
<a href="#l3.167"></a><span id="l3.167" class="difflineplus">+          delete unresolvedIndexToItem[iItem];</span>
<a href="#l3.168"></a><span id="l3.168" class="difflineplus">+          // stop checking collections if we got everybody</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineplus">+          if (--numUnresolved == 0)</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+            break;</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineplus">+        }</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+      }</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+    }</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineplus">+    </span>
<a href="#l3.175"></a><span id="l3.175" class="difflineplus">+    // anything left in unresolvedIndexToItem should be added to the cache...</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineplus">+    // plus, we already have 'needToCache'</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+    if (cache) {</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+      cache.add(needToCache.concat([val for each</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineplus">+                                    (val in unresolvedIndexToItem)]));</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineplus">+    }</span>
<a href="#l3.181"></a><span id="l3.181" class="difflineplus">+    </span>
<a href="#l3.182"></a><span id="l3.182" class="difflineplus">+    return aItems;</span>
<a href="#l3.183"></a><span id="l3.183">   },</span>
<a href="#l3.184"></a><span id="l3.184">   </span>
<a href="#l3.185"></a><span id="l3.185">   cacheCommitDirty: function glod_colm_cacheCommitDirty() {</span>
<a href="#l3.186"></a><span id="l3.186">     for each (let cache in this._cachesByNoun) {</span>
<a href="#l3.187"></a><span id="l3.187">       cache.commitDirty();</span>
<a href="#l3.188"></a><span id="l3.188">     }</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineminus">-  }</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineplus">+  },</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineplus">+</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+  /**</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineplus">+   * Notifies the collection manager that an item has been loaded and should</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+   *  be cached, assuming caching is active.</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+   */    </span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+  itemLoaded: function gloda_colm_itemsLoaded(aItem) {</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+    let cache = this._cachesByNoun[aItem.NOUN_ID];</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+    if (cache) {</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+      cache.add([aItem]);</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+    }</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+  },</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+  /**</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+   * Notifies the collection manager that multiple items has been loaded and</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineplus">+   *  should be cached, assuming caching is active.</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineplus">+   */  </span>
<a href="#l3.207"></a><span id="l3.207" class="difflineplus">+  itemsLoaded: function gloda_colm_itemsLoaded(aNounID, aItems) {</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+    if (cache) {</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+      cache.add(aItems);</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+    }</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+  },</span>
<a href="#l3.213"></a><span id="l3.213">   </span>
<a href="#l3.214"></a><span id="l3.214">   /**</span>
<a href="#l3.215"></a><span id="l3.215">    * This should be called when items are added to the global database.  This</span>
<a href="#l3.216"></a><span id="l3.216">    *  should generally mean during indexing by indexers or an attribute</span>
<a href="#l3.217"></a><span id="l3.217">    *  provider.</span>
<a href="#l3.218"></a><span id="l3.218">    * We walk all existing collections for the given noun type and add the items</span>
<a href="#l3.219"></a><span id="l3.219">    *  to the collection if the item meets the query that defines the collection.</span>
<a href="#l3.220"></a><span id="l3.220">    */</span>
<a href="#l3.221"></a><span id="l3.221">   itemsAdded: function gloda_colm_itemsAdded(aNounID, aItems) {</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineplus">+    if (cache) {</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineplus">+      cache.add(aItems);</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineplus">+    }</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineplus">+</span>
<a href="#l3.227"></a><span id="l3.227">     for each (let collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l3.228"></a><span id="l3.228">       let addItems = [item for each (item in aItems)</span>
<a href="#l3.229"></a><span id="l3.229">                       if (collection.query.test(item))];</span>
<a href="#l3.230"></a><span id="l3.230">       if (addItems.length)</span>
<a href="#l3.231"></a><span id="l3.231">         collection._onItemsAdded(addItems);</span>
<a href="#l3.232"></a><span id="l3.232">     }</span>
<a href="#l3.233"></a><span id="l3.233">   },</span>
<a href="#l3.234"></a><span id="l3.234">   /**</span>
<a href="#l3.235"></a><span id="l3.235" class="difflineat">@@ -197,16 +304,26 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l3.236"></a><span id="l3.236">    *  deleted.  (This is distinct from concepts like message deletion which may</span>
<a href="#l3.237"></a><span id="l3.237">    *  involved trash folders or other modified forms of existence.  Deleted</span>
<a href="#l3.238"></a><span id="l3.238">    *  means the data is gone and if it were to come back, it would come back</span>
<a href="#l3.239"></a><span id="l3.239">    *  with a brand new unique id and we would get an itemsAdded event.)</span>
<a href="#l3.240"></a><span id="l3.240">    * We walk all existing collections for the given noun type.  For items</span>
<a href="#l3.241"></a><span id="l3.241">    *  currently in the collection, we generate onItemsRemoved events.</span>
<a href="#l3.242"></a><span id="l3.242">    */</span>
<a href="#l3.243"></a><span id="l3.243">   itemsDeleted: function gloda_colm_itemsDeleted(aNounID, aItems) {</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineplus">+    // cache</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l3.246"></a><span id="l3.246" class="difflineplus">+    if (cache) {</span>
<a href="#l3.247"></a><span id="l3.247" class="difflineplus">+      for each (let item in aItem) {</span>
<a href="#l3.248"></a><span id="l3.248" class="difflineplus">+        if (item.id in cache._idMap)</span>
<a href="#l3.249"></a><span id="l3.249" class="difflineplus">+          cache.delete(item);</span>
<a href="#l3.250"></a><span id="l3.250" class="difflineplus">+      }</span>
<a href="#l3.251"></a><span id="l3.251" class="difflineplus">+    }</span>
<a href="#l3.252"></a><span id="l3.252" class="difflineplus">+</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineplus">+    // collections</span>
<a href="#l3.254"></a><span id="l3.254">     for each (let collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l3.255"></a><span id="l3.255">       let removeItems = [item for each (item in aItems)</span>
<a href="#l3.256"></a><span id="l3.256">                          if (item.id in collection._idMap)];</span>
<a href="#l3.257"></a><span id="l3.257">       if (removeItems.length)</span>
<a href="#l3.258"></a><span id="l3.258">         collection._onItemsRemoved(removeItems);</span>
<a href="#l3.259"></a><span id="l3.259">     }</span>
<a href="#l3.260"></a><span id="l3.260">   },</span>
<a href="#l3.261"></a><span id="l3.261"> }</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineat">@@ -289,17 +406,17 @@ function GlodaLRUCacheCollection(aNounMe</span>
<a href="#l3.263"></a><span id="l3.263">   this._size = 0;</span>
<a href="#l3.264"></a><span id="l3.264">   // let's keep things sane, and simplify our logic a little...</span>
<a href="#l3.265"></a><span id="l3.265">   if (aCacheSize &lt; 32)</span>
<a href="#l3.266"></a><span id="l3.266">     aCacheSize = 32;</span>
<a href="#l3.267"></a><span id="l3.267">   this._maxCacheSize = aCacheSize;</span>
<a href="#l3.268"></a><span id="l3.268"> }</span>
<a href="#l3.269"></a><span id="l3.269"> </span>
<a href="#l3.270"></a><span id="l3.270"> GlodaLRUCacheCollection.prototype = new GlodaCollection;</span>
<a href="#l3.271"></a><span id="l3.271" class="difflineminus">-GlodaLRUCacheCollection.prototype.add = function(aItems) {</span>
<a href="#l3.272"></a><span id="l3.272" class="difflineplus">+GlodaLRUCacheCollection.prototype.add = function cache_add(aItems) {</span>
<a href="#l3.273"></a><span id="l3.273">   for each (let item in aItems) {</span>
<a href="#l3.274"></a><span id="l3.274">     this._idMap[item.id] = item;</span>
<a href="#l3.275"></a><span id="l3.275">     </span>
<a href="#l3.276"></a><span id="l3.276">     item._lruPrev = this._tail;</span>
<a href="#l3.277"></a><span id="l3.277">     // we do have to make sure that we will set _head the first time we insert</span>
<a href="#l3.278"></a><span id="l3.278">     //  something</span>
<a href="#l3.279"></a><span id="l3.279">     if (this._tail !== null)</span>
<a href="#l3.280"></a><span id="l3.280">       this._tail._lruNext = item;</span>
<a href="#l3.281"></a><span id="l3.281" class="difflineat">@@ -326,45 +443,74 @@ GlodaLRUCacheCollection.prototype.add = </span>
<a href="#l3.282"></a><span id="l3.282">     delete this._idMap[item.id];</span>
<a href="#l3.283"></a><span id="l3.283">     </span>
<a href="#l3.284"></a><span id="l3.284">     // flush dirty items to disk (they may not have this attribute, in which</span>
<a href="#l3.285"></a><span id="l3.285">     //  case, this returns false, which is fine.)</span>
<a href="#l3.286"></a><span id="l3.286">     if (item.dirty) {</span>
<a href="#l3.287"></a><span id="l3.287">       this._nounMeta.objUpdate.call(this._nounMeta.datastore, item);</span>
<a href="#l3.288"></a><span id="l3.288">       delete item.dirty;</span>
<a href="#l3.289"></a><span id="l3.289">     }</span>
<a href="#l3.290"></a><span id="l3.290" class="difflineplus">+    </span>
<a href="#l3.291"></a><span id="l3.291" class="difflineplus">+    this._size--;</span>
<a href="#l3.292"></a><span id="l3.292">   }</span>
<a href="#l3.293"></a><span id="l3.293"> };</span>
<a href="#l3.294"></a><span id="l3.294"> </span>
<a href="#l3.295"></a><span id="l3.295" class="difflineminus">-GlodaLRUCacheCollection.prototype.hit = function(aItem) {</span>
<a href="#l3.296"></a><span id="l3.296" class="difflineminus">-  // don't do anything in the 0 or 1 items case</span>
<a href="#l3.297"></a><span id="l3.297" class="difflineminus">-  if (this._head === this._tail)</span>
<a href="#l3.298"></a><span id="l3.298" class="difflineplus">+GlodaLRUCacheCollection.prototype.hit = function cache_hit(aItem) {</span>
<a href="#l3.299"></a><span id="l3.299" class="difflineplus">+  // don't do anything in the 0 or 1 items case, or if we're already</span>
<a href="#l3.300"></a><span id="l3.300" class="difflineplus">+  //  the last item</span>
<a href="#l3.301"></a><span id="l3.301" class="difflineplus">+  if ((this._head === this._tail) || (this._tail === aItem))</span>
<a href="#l3.302"></a><span id="l3.302">     return;</span>
<a href="#l3.303"></a><span id="l3.303"> </span>
<a href="#l3.304"></a><span id="l3.304">   // unlink the item  </span>
<a href="#l3.305"></a><span id="l3.305">   if (aItem._lruPrev !== null)</span>
<a href="#l3.306"></a><span id="l3.306">     aItem._lruPrev._lruNext = aItem._lruNext;</span>
<a href="#l3.307"></a><span id="l3.307" class="difflineminus">-  if (aItem._lruNext !== null)</span>
<a href="#l3.308"></a><span id="l3.308" class="difflineminus">-    aItem._lruNext._lruPrev = aIrem._lruPrev;</span>
<a href="#l3.309"></a><span id="l3.309" class="difflineplus">+  else</span>
<a href="#l3.310"></a><span id="l3.310" class="difflineplus">+    this._head = aItem._lruNext;</span>
<a href="#l3.311"></a><span id="l3.311" class="difflineplus">+  // _lruNext cannot be null</span>
<a href="#l3.312"></a><span id="l3.312" class="difflineplus">+  aItem._lruNext._lruPrev = aItem._lruPrev;</span>
<a href="#l3.313"></a><span id="l3.313">   // link it in to the end</span>
<a href="#l3.314"></a><span id="l3.314">   this._tail._lruNext = aItem; </span>
<a href="#l3.315"></a><span id="l3.315">   aItem._lruPrev = this._tail;</span>
<a href="#l3.316"></a><span id="l3.316">   aItem._lruNext = null;</span>
<a href="#l3.317"></a><span id="l3.317">   // update tail tracking</span>
<a href="#l3.318"></a><span id="l3.318">   this._tail = aItem;</span>
<a href="#l3.319"></a><span id="l3.319" class="difflineplus">+  </span>
<a href="#l3.320"></a><span id="l3.320" class="difflineplus">+  return aItem;</span>
<a href="#l3.321"></a><span id="l3.321"> };</span>
<a href="#l3.322"></a><span id="l3.322"> </span>
<a href="#l3.323"></a><span id="l3.323" class="difflineplus">+GlodaLRUCacheCollection.prototype.deleted = function cache_deleted(aItem) {</span>
<a href="#l3.324"></a><span id="l3.324" class="difflineplus">+  // unlink the item  </span>
<a href="#l3.325"></a><span id="l3.325" class="difflineplus">+  if (aItem._lruPrev !== null)</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineplus">+    aItem._lruPrev._lruNext = aItem._lruNext;</span>
<a href="#l3.327"></a><span id="l3.327" class="difflineplus">+  else</span>
<a href="#l3.328"></a><span id="l3.328" class="difflineplus">+    this._head = aItem._lruNext;</span>
<a href="#l3.329"></a><span id="l3.329" class="difflineplus">+  if (aItem._lruNext !== null)</span>
<a href="#l3.330"></a><span id="l3.330" class="difflineplus">+    aItem._lruNext._lruPrev = aItem._lruPrev;</span>
<a href="#l3.331"></a><span id="l3.331" class="difflineplus">+  else</span>
<a href="#l3.332"></a><span id="l3.332" class="difflineplus">+    this._tail = aItem._lruPrev;</span>
<a href="#l3.333"></a><span id="l3.333" class="difflineplus">+</span>
<a href="#l3.334"></a><span id="l3.334" class="difflineplus">+  // (because we are nice, we will delete the properties...)</span>
<a href="#l3.335"></a><span id="l3.335" class="difflineplus">+  delete aItem._lruNext;</span>
<a href="#l3.336"></a><span id="l3.336" class="difflineplus">+  delete aItem._lruPrev;</span>
<a href="#l3.337"></a><span id="l3.337" class="difflineplus">+    </span>
<a href="#l3.338"></a><span id="l3.338" class="difflineplus">+  // nuke from our id map</span>
<a href="#l3.339"></a><span id="l3.339" class="difflineplus">+  delete this._idMap[aItem.id];</span>
<a href="#l3.340"></a><span id="l3.340" class="difflineplus">+  </span>
<a href="#l3.341"></a><span id="l3.341" class="difflineplus">+  this._size--;</span>
<a href="#l3.342"></a><span id="l3.342" class="difflineplus">+}</span>
<a href="#l3.343"></a><span id="l3.343" class="difflineplus">+</span>
<a href="#l3.344"></a><span id="l3.344"> /**</span>
<a href="#l3.345"></a><span id="l3.345">  * If any of the cached items are dirty, commit them, and make them no longer</span>
<a href="#l3.346"></a><span id="l3.346">  *  dirty.</span>
<a href="#l3.347"></a><span id="l3.347">  */</span>
<a href="#l3.348"></a><span id="l3.348" class="difflineminus">-GlodaLRUCacheCollection.prototype.commitDirty = function() {</span>
<a href="#l3.349"></a><span id="l3.349" class="difflineplus">+GlodaLRUCacheCollection.prototype.commitDirty = function cache_commitDirty() {</span>
<a href="#l3.350"></a><span id="l3.350">   // we can only do this if there is an update method available...</span>
<a href="#l3.351"></a><span id="l3.351">   if (!this._nounMeta.objUpdate)</span>
<a href="#l3.352"></a><span id="l3.352">     return;</span>
<a href="#l3.353"></a><span id="l3.353"> </span>
<a href="#l3.354"></a><span id="l3.354">   for each (let item in this._idMap) {</span>
<a href="#l3.355"></a><span id="l3.355">     if (item.dirty) {</span>
<a href="#l3.356"></a><span id="l3.356" class="difflineplus">+      LOG.debug(&quot;flushing dirty: &quot; + item);</span>
<a href="#l3.357"></a><span id="l3.357">       this._nounMeta.objUpdate.call(this._nounMeta.datastore, item);</span>
<a href="#l3.358"></a><span id="l3.358">       delete item.dirty;</span>
<a href="#l3.359"></a><span id="l3.359">     }</span>
<a href="#l3.360"></a><span id="l3.360">   }</span>
<a href="#l3.361"></a><span id="l3.361"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -124,29 +124,31 @@ GlodaAttributeDef.prototype = {</span>
<a href="#l4.4"></a><span id="l4.4">   </span>
<a href="#l4.5"></a><span id="l4.5">   /**</span>
<a href="#l4.6"></a><span id="l4.6">    * Given an instance of an object with this attribute, return the value</span>
<a href="#l4.7"></a><span id="l4.7">    *  of the attribute.  This handles bound and un-bound attributes.  For</span>
<a href="#l4.8"></a><span id="l4.8">    *  singular attributes, the value is null or the value; for non-singular</span>
<a href="#l4.9"></a><span id="l4.9">    *  attributes the value is a list.</span>
<a href="#l4.10"></a><span id="l4.10">    */</span>
<a href="#l4.11"></a><span id="l4.11">   getValueFromInstance: function gloda_attr_getValueFromInstance(aObj) {</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-    if (this._boundName !== null) {</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+    // if it's bound, we can just use the binding and trigger his caching</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+    // if it's special, the attribute actually exists, but just with explicit</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+    //  code backing it.</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+    if (this._boundName !== null || this._special) {</span>
<a href="#l4.17"></a><span id="l4.17">       return aObj[this._boundName];</span>
<a href="#l4.18"></a><span id="l4.18">     }</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineminus">-    let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+    let instances = aObj.getAttributeInstances(this);</span>
<a href="#l4.21"></a><span id="l4.21">     let nounMeta = this._objectNounMeta;</span>
<a href="#l4.22"></a><span id="l4.22">     if (this._singular) {</span>
<a href="#l4.23"></a><span id="l4.23">       if (instances.length &gt; 0)</span>
<a href="#l4.24"></a><span id="l4.24">         return nounMeta.fromParamAndValue(instances[0][1], instances[0][2]);</span>
<a href="#l4.25"></a><span id="l4.25">       else</span>
<a href="#l4.26"></a><span id="l4.26">         return null;</span>
<a href="#l4.27"></a><span id="l4.27">     }</span>
<a href="#l4.28"></a><span id="l4.28">     else {</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineminus">-      let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l4.30"></a><span id="l4.30">       let values;</span>
<a href="#l4.31"></a><span id="l4.31">       if (instances.length &gt; 0) {</span>
<a href="#l4.32"></a><span id="l4.32">         values = [];</span>
<a href="#l4.33"></a><span id="l4.33">         for (let iInst=0; iInst &lt; instances.length; iInst++) {</span>
<a href="#l4.34"></a><span id="l4.34">           values.push(nounMeta.fromParamAndValue(instances[iInst][1],</span>
<a href="#l4.35"></a><span id="l4.35">                                                  instances[iInst][2]));</span>
<a href="#l4.36"></a><span id="l4.36">         }</span>
<a href="#l4.37"></a><span id="l4.37">       }</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineat">@@ -169,16 +171,17 @@ function GlodaConversation(aDatastore, a</span>
<a href="#l4.39"></a><span id="l4.39">   this._subject = aSubject;</span>
<a href="#l4.40"></a><span id="l4.40">   this._oldestMessageDate = aOldestMessageDate;</span>
<a href="#l4.41"></a><span id="l4.41">   this._newestMessageDate = aNewestMessageDate;</span>
<a href="#l4.42"></a><span id="l4.42"> </span>
<a href="#l4.43"></a><span id="l4.43">   this._messages = null;</span>
<a href="#l4.44"></a><span id="l4.44"> }</span>
<a href="#l4.45"></a><span id="l4.45"> </span>
<a href="#l4.46"></a><span id="l4.46"> GlodaConversation.prototype = {</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+  NOUN_ID: 101,</span>
<a href="#l4.48"></a><span id="l4.48">   get id() { return this._id; },</span>
<a href="#l4.49"></a><span id="l4.49">   get subject() { return this._subject; },</span>
<a href="#l4.50"></a><span id="l4.50">   get oldestMessageDate() { return this._oldestMessageDate; },</span>
<a href="#l4.51"></a><span id="l4.51">   get newestMessageDate() { return this._newestMessageDate; },</span>
<a href="#l4.52"></a><span id="l4.52"> </span>
<a href="#l4.53"></a><span id="l4.53">   get messages() {</span>
<a href="#l4.54"></a><span id="l4.54">     if (this._messages == null) {</span>
<a href="#l4.55"></a><span id="l4.55">       this._messages = this._datastore.getMessagesByConversationID(this._id,</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineat">@@ -197,28 +200,29 @@ function GlodaMessage(aDatastore, aID, a</span>
<a href="#l4.57"></a><span id="l4.57">                       aConversationID, aConversation, aDate,</span>
<a href="#l4.58"></a><span id="l4.58">                       aHeaderMessageID, aBodySnippet) {</span>
<a href="#l4.59"></a><span id="l4.59">   this._datastore = aDatastore;</span>
<a href="#l4.60"></a><span id="l4.60">   this._id = aID;</span>
<a href="#l4.61"></a><span id="l4.61">   this._folderID = aFolderID;</span>
<a href="#l4.62"></a><span id="l4.62">   this._messageKey = aMessageKey;</span>
<a href="#l4.63"></a><span id="l4.63">   this._conversationID = aConversationID;</span>
<a href="#l4.64"></a><span id="l4.64">   this._conversation = aConversation;</span>
<a href="#l4.65"></a><span id="l4.65" class="difflineminus">-  this.date = date;</span>
<a href="#l4.66"></a><span id="l4.66" class="difflineplus">+  this.date = aDate;</span>
<a href="#l4.67"></a><span id="l4.67">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l4.68"></a><span id="l4.68">   this._bodySnippet = aBodySnippet;</span>
<a href="#l4.69"></a><span id="l4.69"> </span>
<a href="#l4.70"></a><span id="l4.70">   // for now, let's always cache this; they should really be forgetting about us</span>
<a href="#l4.71"></a><span id="l4.71">   //  if they want to forget about the underlying storage anyways...</span>
<a href="#l4.72"></a><span id="l4.72">   this._folderMessage = undefined;</span>
<a href="#l4.73"></a><span id="l4.73">   // the list of attributes, un-processed</span>
<a href="#l4.74"></a><span id="l4.74">   this._attributes = null;</span>
<a href="#l4.75"></a><span id="l4.75"> }</span>
<a href="#l4.76"></a><span id="l4.76"> </span>
<a href="#l4.77"></a><span id="l4.77"> GlodaMessage.prototype = {</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+  NOUN_ID: 102,</span>
<a href="#l4.79"></a><span id="l4.79">   get id() { return this._id; },</span>
<a href="#l4.80"></a><span id="l4.80">   get folderID() { return this._folderID; },</span>
<a href="#l4.81"></a><span id="l4.81">   get messageKey() { return this._messageKey; },</span>
<a href="#l4.82"></a><span id="l4.82">   get conversationID() { return this._conversationID; },</span>
<a href="#l4.83"></a><span id="l4.83">   // conversation is special</span>
<a href="#l4.84"></a><span id="l4.84">   get headerMessageID() { return this._headerMessageID; },</span>
<a href="#l4.85"></a><span id="l4.85">   get bodySnippet() { return this._bodySnippet; },</span>
<a href="#l4.86"></a><span id="l4.86"> </span>
<a href="#l4.87"></a><span id="l4.87" class="difflineat">@@ -373,17 +377,17 @@ GlodaContact.prototype = {</span>
<a href="#l4.88"></a><span id="l4.88"> </span>
<a href="#l4.89"></a><span id="l4.89">   get id() { return this._id; },</span>
<a href="#l4.90"></a><span id="l4.90">   get directoryUUID() { return this._directoryUUID; },</span>
<a href="#l4.91"></a><span id="l4.91">   get contactUUID() { return this._contactUUID; },</span>
<a href="#l4.92"></a><span id="l4.92">   get name() { return this._name },</span>
<a href="#l4.93"></a><span id="l4.93">   </span>
<a href="#l4.94"></a><span id="l4.94">   get popularity() { return this._popularity; },</span>
<a href="#l4.95"></a><span id="l4.95">   set popularity(aPopularity) {</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineminus">-    this.popularity = aPopularity;</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+    this._popularity = aPopularity;</span>
<a href="#l4.98"></a><span id="l4.98">     this.dirty = true;</span>
<a href="#l4.99"></a><span id="l4.99">   },</span>
<a href="#l4.100"></a><span id="l4.100"> </span>
<a href="#l4.101"></a><span id="l4.101">   get frecency() { return this._frecency; },</span>
<a href="#l4.102"></a><span id="l4.102">   set frecency(aFrecency) {</span>
<a href="#l4.103"></a><span id="l4.103">     this._frecency = aFrecency;</span>
<a href="#l4.104"></a><span id="l4.104">     this.dirty = true;</span>
<a href="#l4.105"></a><span id="l4.105">   },</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineat">@@ -400,26 +404,26 @@ function GlodaIdentity(aDatastore, aID, </span>
<a href="#l4.107"></a><span id="l4.107">   this._contactID = aContactID;</span>
<a href="#l4.108"></a><span id="l4.108">   this._contact = aContact;</span>
<a href="#l4.109"></a><span id="l4.109">   this._kind = aKind;</span>
<a href="#l4.110"></a><span id="l4.110">   this._value = aValue;</span>
<a href="#l4.111"></a><span id="l4.111">   this._isRelay = aIsRelay;</span>
<a href="#l4.112"></a><span id="l4.112"> }</span>
<a href="#l4.113"></a><span id="l4.113"> </span>
<a href="#l4.114"></a><span id="l4.114"> GlodaIdentity.prototype = {</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineplus">+  NOUN_ID: 104,</span>
<a href="#l4.116"></a><span id="l4.116">   get id() { return this._id; },</span>
<a href="#l4.117"></a><span id="l4.117">   get contactID() { return this._contactID; }, </span>
<a href="#l4.118"></a><span id="l4.118">   get kind() { return this._kind; },</span>
<a href="#l4.119"></a><span id="l4.119">   get value() { return this._value; },</span>
<a href="#l4.120"></a><span id="l4.120">   get isRelay() { return this._isRelay; },</span>
<a href="#l4.121"></a><span id="l4.121">   </span>
<a href="#l4.122"></a><span id="l4.122">   get contact() {</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineminus">-    if (this._contact == null) {</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineplus">+    if (this._contact === null)</span>
<a href="#l4.125"></a><span id="l4.125">       this._contact = this._datastore.getContactByID(this._contactID);</span>
<a href="#l4.126"></a><span id="l4.126" class="difflineminus">-    }</span>
<a href="#l4.127"></a><span id="l4.127">     return this._contact;</span>
<a href="#l4.128"></a><span id="l4.128">   },</span>
<a href="#l4.129"></a><span id="l4.129">   </span>
<a href="#l4.130"></a><span id="l4.130">   toString: function gloda_identity_toString() {</span>
<a href="#l4.131"></a><span id="l4.131">     return this._value;</span>
<a href="#l4.132"></a><span id="l4.132">   },</span>
<a href="#l4.133"></a><span id="l4.133">   </span>
<a href="#l4.134"></a><span id="l4.134">   get abCard() {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -48,16 +48,20 @@ const Cr = Components.results;</span>
<a href="#l5.4"></a><span id="l5.4"> const Cu = Components.utils;</span>
<a href="#l5.5"></a><span id="l5.5"> </span>
<a href="#l5.6"></a><span id="l5.6"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l5.7"></a><span id="l5.7"> </span>
<a href="#l5.8"></a><span id="l5.8"> Cu.import(&quot;resource://gloda/modules/datamodel.js&quot;);</span>
<a href="#l5.9"></a><span id="l5.9"> Cu.import(&quot;resource://gloda/modules/databind.js&quot;);</span>
<a href="#l5.10"></a><span id="l5.10"> Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+// XXX from Gloda.js</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+const kSpecialColumn = 1;</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+const kSpecialFulltext = 2;</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+</span>
<a href="#l5.16"></a><span id="l5.16"> let GlodaDatastore = {</span>
<a href="#l5.17"></a><span id="l5.17">   _log: null,</span>
<a href="#l5.18"></a><span id="l5.18"> </span>
<a href="#l5.19"></a><span id="l5.19">   /* ******************* SCHEMA ******************* */</span>
<a href="#l5.20"></a><span id="l5.20"> </span>
<a href="#l5.21"></a><span id="l5.21">   _schemaVersion: 5,</span>
<a href="#l5.22"></a><span id="l5.22">   _schema: {</span>
<a href="#l5.23"></a><span id="l5.23">     tables: {</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineat">@@ -285,18 +289,19 @@ let GlodaDatastore = {</span>
<a href="#l5.25"></a><span id="l5.25">       let table = this._schema.tables[tableName];</span>
<a href="#l5.26"></a><span id="l5.26">       </span>
<a href="#l5.27"></a><span id="l5.27">       // - Create the table</span>
<a href="#l5.28"></a><span id="l5.28">       aDBConnection.createTable(tableName, table.columns.join(&quot;, &quot;));</span>
<a href="#l5.29"></a><span id="l5.29">       </span>
<a href="#l5.30"></a><span id="l5.30">       // - Create the fulltext table if applicable</span>
<a href="#l5.31"></a><span id="l5.31">       if (&quot;fulltextColumns&quot; in table) {</span>
<a href="#l5.32"></a><span id="l5.32">         let createFulltextSQL = &quot;CREATE VIRTUAL TABLE &quot; + tableName + &quot;Text&quot; +</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineminus">-          &quot; USING fts3(TOKENIZE PORTER, &quot; + table.fulltextColumns.join(&quot;, &quot;) +</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+          &quot; USING fts3(tokenize porter, &quot; + table.fulltextColumns.join(&quot;, &quot;) +</span>
<a href="#l5.35"></a><span id="l5.35">           &quot;)&quot;;</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+        this._log.info(&quot;Create fulltext: &quot; + createFulltextSQL);</span>
<a href="#l5.37"></a><span id="l5.37">         aDBConnection.executeSimpleSQL(createFulltextSQL);</span>
<a href="#l5.38"></a><span id="l5.38">       }</span>
<a href="#l5.39"></a><span id="l5.39">       </span>
<a href="#l5.40"></a><span id="l5.40">       // - Create its indices</span>
<a href="#l5.41"></a><span id="l5.41">       for (let indexName in table.indices) {</span>
<a href="#l5.42"></a><span id="l5.42">         let indexColumns = table.indices[indexName];</span>
<a href="#l5.43"></a><span id="l5.43">         </span>
<a href="#l5.44"></a><span id="l5.44">         aDBConnection.executeSimpleSQL(</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineat">@@ -352,18 +357,18 @@ let GlodaDatastore = {</span>
<a href="#l5.46"></a><span id="l5.46">   },</span>
<a href="#l5.47"></a><span id="l5.47">   </span>
<a href="#l5.48"></a><span id="l5.48">   _migrate: function gloda_ds_migrate(aDBService, aDBFile, aDBConnection,</span>
<a href="#l5.49"></a><span id="l5.49">                                       aCurVersion, aNewVersion) {</span>
<a href="#l5.50"></a><span id="l5.50">     // the 4-to-5 migration is the only possible case right now, and is so</span>
<a href="#l5.51"></a><span id="l5.51">     //  significant that we want everything purged anyways.</span>
<a href="#l5.52"></a><span id="l5.52">     // generalize me in the future.</span>
<a href="#l5.53"></a><span id="l5.53">     aDBConnection.close();</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineminus">-    aDBFile.remove();</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineminus">-    this._log.warning(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+    aDBFile.remove(false);</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+    this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l5.58"></a><span id="l5.58">     </span>
<a href="#l5.59"></a><span id="l5.59">     return this._createDB(aDBService, aDBFile);</span>
<a href="#l5.60"></a><span id="l5.60">   },</span>
<a href="#l5.61"></a><span id="l5.61">   </span>
<a href="#l5.62"></a><span id="l5.62">   // cribbed from snowl</span>
<a href="#l5.63"></a><span id="l5.63">   _createStatement: function gloda_ds_createStatement(aSQLString) {</span>
<a href="#l5.64"></a><span id="l5.64">     let statement = null;</span>
<a href="#l5.65"></a><span id="l5.65">     try {</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineat">@@ -638,17 +643,19 @@ let GlodaDatastore = {</span>
<a href="#l5.67"></a><span id="l5.67">       &quot;INSERT INTO conversationsText (docid, subject) \</span>
<a href="#l5.68"></a><span id="l5.68">               VALUES (:docid, :subject)&quot;);</span>
<a href="#l5.69"></a><span id="l5.69">     this.__defineGetter__(&quot;_insertConversationTextStatement&quot;,</span>
<a href="#l5.70"></a><span id="l5.70">       function() statement);</span>
<a href="#l5.71"></a><span id="l5.71">     return this._insertConversationTextStatement; </span>
<a href="#l5.72"></a><span id="l5.72">   }, </span>
<a href="#l5.73"></a><span id="l5.73"> </span>
<a href="#l5.74"></a><span id="l5.74">   </span>
<a href="#l5.75"></a><span id="l5.75" class="difflineminus">-  /** Create a conversation. */</span>
<a href="#l5.76"></a><span id="l5.76" class="difflineplus">+  /**</span>
<a href="#l5.77"></a><span id="l5.77" class="difflineplus">+   * Create a conversation.</span>
<a href="#l5.78"></a><span id="l5.78" class="difflineplus">+   */</span>
<a href="#l5.79"></a><span id="l5.79">   createConversation: function gloda_ds_createConversation(aSubject,</span>
<a href="#l5.80"></a><span id="l5.80">         aOldestMessageDate, aNewestMessageDate) {</span>
<a href="#l5.81"></a><span id="l5.81"> </span>
<a href="#l5.82"></a><span id="l5.82">     // create the data row    </span>
<a href="#l5.83"></a><span id="l5.83">     let ics = this._insertConversationStatement;</span>
<a href="#l5.84"></a><span id="l5.84">     ics.params.subject = aSubject;</span>
<a href="#l5.85"></a><span id="l5.85">     ics.params.oldestMessageDate = aOldestMessageDate;</span>
<a href="#l5.86"></a><span id="l5.86">     ics.params.newestMessageDate = aNewestMessageDate;</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineat">@@ -657,54 +664,71 @@ let GlodaDatastore = {</span>
<a href="#l5.88"></a><span id="l5.88">     let conversationID = this.dbConnection.lastInsertRowID; </span>
<a href="#l5.89"></a><span id="l5.89">     </span>
<a href="#l5.90"></a><span id="l5.90">     // create the fulltext row, using the same rowid/docid</span>
<a href="#l5.91"></a><span id="l5.91">     let icts = this._insertConversationTextStatement;</span>
<a href="#l5.92"></a><span id="l5.92">     icts.params.docid = conversationID;</span>
<a href="#l5.93"></a><span id="l5.93">     icts.params.subject = aSubject;</span>
<a href="#l5.94"></a><span id="l5.94">     icts.execute();</span>
<a href="#l5.95"></a><span id="l5.95">     </span>
<a href="#l5.96"></a><span id="l5.96" class="difflineminus">-    return new GlodaConversation(this, conversationID,</span>
<a href="#l5.97"></a><span id="l5.97" class="difflineplus">+    // create it</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineplus">+    let conversation = new GlodaConversation(this, conversationID,</span>
<a href="#l5.99"></a><span id="l5.99">                                  aSubject, aOldestMessageDate,</span>
<a href="#l5.100"></a><span id="l5.100">                                  aNewestMessageDate);</span>
<a href="#l5.101"></a><span id="l5.101" class="difflineplus">+    // it's new! let the collection manager know about it.</span>
<a href="#l5.102"></a><span id="l5.102" class="difflineplus">+    GlodaCollectionManager.itemsAdded(conversation.NOUN_ID, [conversation]);</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineplus">+    // return it</span>
<a href="#l5.104"></a><span id="l5.104" class="difflineplus">+    return conversation;</span>
<a href="#l5.105"></a><span id="l5.105">   },</span>
<a href="#l5.106"></a><span id="l5.106"> </span>
<a href="#l5.107"></a><span id="l5.107">   get _deleteConversationByIDStatement() {</span>
<a href="#l5.108"></a><span id="l5.108">     let statement = this._createStatement(</span>
<a href="#l5.109"></a><span id="l5.109">       &quot;DELETE FROM conversations WHERE id = :conversationID&quot;);</span>
<a href="#l5.110"></a><span id="l5.110">     this.__defineGetter__(&quot;_deleteConversationByIDStatement&quot;,</span>
<a href="#l5.111"></a><span id="l5.111">                           function() statement);</span>
<a href="#l5.112"></a><span id="l5.112">     return this._deleteConversationByIDStatement; </span>
<a href="#l5.113"></a><span id="l5.113">   },</span>
<a href="#l5.114"></a><span id="l5.114"> </span>
<a href="#l5.115"></a><span id="l5.115">   deleteConversationByID: function gloda_ds_deleteConversationByID(</span>
<a href="#l5.116"></a><span id="l5.116">                                       aConversationID) {</span>
<a href="#l5.117"></a><span id="l5.117">     let dcbids = this._deleteConversationByIDStatement;</span>
<a href="#l5.118"></a><span id="l5.118">     dcbids.params.conversationID = aConversationID;</span>
<a href="#l5.119"></a><span id="l5.119">     dcbids.execute();</span>
<a href="#l5.120"></a><span id="l5.120" class="difflineplus">+    </span>
<a href="#l5.121"></a><span id="l5.121" class="difflineplus">+    // TODO: collection manager implications</span>
<a href="#l5.122"></a><span id="l5.122" class="difflineplus">+    GlodaCollectionManager.removeByID()</span>
<a href="#l5.123"></a><span id="l5.123">   },</span>
<a href="#l5.124"></a><span id="l5.124"> </span>
<a href="#l5.125"></a><span id="l5.125">   get _selectConversationByIDStatement() {</span>
<a href="#l5.126"></a><span id="l5.126">     let statement = this._createStatement(</span>
<a href="#l5.127"></a><span id="l5.127">       &quot;SELECT * FROM conversations WHERE id = :conversationID&quot;);</span>
<a href="#l5.128"></a><span id="l5.128" class="difflineminus">-    this.__defineGetter__(&quot;_selectConversationByIDStatement&quot;, function() statement);</span>
<a href="#l5.129"></a><span id="l5.129" class="difflineminus">-    return this._selectConversationByIDStatement; </span>
<a href="#l5.130"></a><span id="l5.130" class="difflineplus">+    this.__defineGetter__(&quot;_selectConversationByIDStatement&quot;,</span>
<a href="#l5.131"></a><span id="l5.131" class="difflineplus">+      function() statement);</span>
<a href="#l5.132"></a><span id="l5.132" class="difflineplus">+    return this._selectConversationByIDStatement;</span>
<a href="#l5.133"></a><span id="l5.133">   }, </span>
<a href="#l5.134"></a><span id="l5.134"> </span>
<a href="#l5.135"></a><span id="l5.135" class="difflineplus">+  _conversationFromRow: function gloda_ds_conversationFromRow(aRow) {</span>
<a href="#l5.136"></a><span id="l5.136" class="difflineplus">+      return new GlodaConversation(this, aRow[&quot;id&quot;],</span>
<a href="#l5.137"></a><span id="l5.137" class="difflineplus">+        aRow[&quot;subject&quot;], aRow[&quot;oldestMessageDate&quot;], aRow[&quot;newestMessageDate&quot;]);  </span>
<a href="#l5.138"></a><span id="l5.138" class="difflineplus">+  },</span>
<a href="#l5.139"></a><span id="l5.139" class="difflineplus">+</span>
<a href="#l5.140"></a><span id="l5.140">   getConversationByID: function gloda_ds_getConversationByID(aConversationID) {</span>
<a href="#l5.141"></a><span id="l5.141" class="difflineminus">-    this._selectConversationByIDStatement.params.conversationID =</span>
<a href="#l5.142"></a><span id="l5.142" class="difflineminus">-      aConversationID;</span>
<a href="#l5.143"></a><span id="l5.143" class="difflineminus">-    </span>
<a href="#l5.144"></a><span id="l5.144" class="difflineminus">-    let conversation = null;</span>
<a href="#l5.145"></a><span id="l5.145" class="difflineminus">-    if (this._selectConversationByIDStatement.step()) {</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineminus">-      let row = this._selectConversationByIDStatement.row;</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineminus">-      conversation = new GlodaConversation(this, aConversationID,</span>
<a href="#l5.148"></a><span id="l5.148" class="difflineminus">-        row[&quot;subject&quot;], row[&quot;oldestMessageDate&quot;], row[&quot;newestMessageDate&quot;]);</span>
<a href="#l5.149"></a><span id="l5.149" class="difflineplus">+    let conversation = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l5.150"></a><span id="l5.150" class="difflineplus">+      GlodaConversation.prototype.NOUN_ID, aConversationID);</span>
<a href="#l5.151"></a><span id="l5.151" class="difflineplus">+</span>
<a href="#l5.152"></a><span id="l5.152" class="difflineplus">+    if (conversation === null) {</span>
<a href="#l5.153"></a><span id="l5.153" class="difflineplus">+      let scbids = this._selectConversationByIDStatement;</span>
<a href="#l5.154"></a><span id="l5.154" class="difflineplus">+      </span>
<a href="#l5.155"></a><span id="l5.155" class="difflineplus">+      scbids.params.conversationID = aConversationID;</span>
<a href="#l5.156"></a><span id="l5.156" class="difflineplus">+      if (scbids.step()) {</span>
<a href="#l5.157"></a><span id="l5.157" class="difflineplus">+        conversation = this._conversationFromRow(scbids.row);</span>
<a href="#l5.158"></a><span id="l5.158" class="difflineplus">+        GlodaCollectionManager.itemLoaded(conversation);</span>
<a href="#l5.159"></a><span id="l5.159" class="difflineplus">+      }</span>
<a href="#l5.160"></a><span id="l5.160" class="difflineplus">+      scbids.reset();</span>
<a href="#l5.161"></a><span id="l5.161">     }</span>
<a href="#l5.162"></a><span id="l5.162" class="difflineminus">-    this._selectConversationByIDStatement.reset();</span>
<a href="#l5.163"></a><span id="l5.163">     </span>
<a href="#l5.164"></a><span id="l5.164">     return conversation;</span>
<a href="#l5.165"></a><span id="l5.165">   },</span>
<a href="#l5.166"></a><span id="l5.166">   </span>
<a href="#l5.167"></a><span id="l5.167">   /* ********** Message ********** */</span>
<a href="#l5.168"></a><span id="l5.168">   get _insertMessageStatement() {</span>
<a href="#l5.169"></a><span id="l5.169">     let statement = this._createStatement(</span>
<a href="#l5.170"></a><span id="l5.170">       &quot;INSERT INTO messages (folderID, messageKey, conversationID, date, \</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineat">@@ -768,28 +792,30 @@ let GlodaDatastore = {</span>
<a href="#l5.172"></a><span id="l5.172">       }</span>
<a href="#l5.173"></a><span id="l5.173">       catch(ex) {</span>
<a href="#l5.174"></a><span id="l5.174">          throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l5.175"></a><span id="l5.175">                this.dbConnection.lastError + &quot;: &quot; +</span>
<a href="#l5.176"></a><span id="l5.176">                this.dbConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l5.177"></a><span id="l5.177">       }</span>
<a href="#l5.178"></a><span id="l5.178">     }</span>
<a href="#l5.179"></a><span id="l5.179">     </span>
<a href="#l5.180"></a><span id="l5.180" class="difflineminus">-    return new GlodaMessage(this, messageID, folderID,</span>
<a href="#l5.181"></a><span id="l5.181" class="difflineplus">+    let message = new GlodaMessage(this, messageID, folderID,</span>
<a href="#l5.182"></a><span id="l5.182">                             aMessageKey, aConversationID, null,</span>
<a href="#l5.183"></a><span id="l5.183">                             aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l5.184"></a><span id="l5.184">                             aHeaderMessageID);</span>
<a href="#l5.185"></a><span id="l5.185" class="difflineplus">+    GlodaCollectionManager.itemsAdded(message.NOUN_ID, [message]);</span>
<a href="#l5.186"></a><span id="l5.186" class="difflineplus">+    return message;</span>
<a href="#l5.187"></a><span id="l5.187">   },</span>
<a href="#l5.188"></a><span id="l5.188">   </span>
<a href="#l5.189"></a><span id="l5.189">   get _updateMessageStatement() {</span>
<a href="#l5.190"></a><span id="l5.190">     let statement = this._createStatement(</span>
<a href="#l5.191"></a><span id="l5.191">       &quot;UPDATE messages SET folderID = :folderID, \</span>
<a href="#l5.192"></a><span id="l5.192">                            messageKey = :messageKey, \</span>
<a href="#l5.193"></a><span id="l5.193">                            conversationID = :conversationID, \</span>
<a href="#l5.194"></a><span id="l5.194" class="difflineminus">-                           headerMessageID = :headerMessageID, \</span>
<a href="#l5.195"></a><span id="l5.195" class="difflineplus">+                           headerMessageID = :headerMessageID \</span>
<a href="#l5.196"></a><span id="l5.196">               WHERE id = :id&quot;);</span>
<a href="#l5.197"></a><span id="l5.197">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l5.198"></a><span id="l5.198">     return this._updateMessageStatement; </span>
<a href="#l5.199"></a><span id="l5.199">   }, </span>
<a href="#l5.200"></a><span id="l5.200">   </span>
<a href="#l5.201"></a><span id="l5.201">   /**</span>
<a href="#l5.202"></a><span id="l5.202">    * Update the database row associated with the message.  If aBody is supplied,</span>
<a href="#l5.203"></a><span id="l5.203">    *  the associated full-text row is created; it is assumed that it did not</span>
<a href="#l5.204"></a><span id="l5.204" class="difflineat">@@ -844,24 +870,29 @@ let GlodaDatastore = {</span>
<a href="#l5.205"></a><span id="l5.205">     let statement = this._createStatement(</span>
<a href="#l5.206"></a><span id="l5.206">       &quot;SELECT * FROM messages WHERE id = :id&quot;);</span>
<a href="#l5.207"></a><span id="l5.207">     this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l5.208"></a><span id="l5.208">       function() statement);</span>
<a href="#l5.209"></a><span id="l5.209">     return this._selectMessageByIDStatement;</span>
<a href="#l5.210"></a><span id="l5.210">   },</span>
<a href="#l5.211"></a><span id="l5.211"> </span>
<a href="#l5.212"></a><span id="l5.212">   getMessageByID: function gloda_ds_getMessageByID(aID) {</span>
<a href="#l5.213"></a><span id="l5.213" class="difflineminus">-    let message = null;</span>
<a href="#l5.214"></a><span id="l5.214" class="difflineplus">+    let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l5.215"></a><span id="l5.215" class="difflineplus">+      GlodaMessage.prototype.NOUN_ID, aID);</span>
<a href="#l5.216"></a><span id="l5.216">   </span>
<a href="#l5.217"></a><span id="l5.217" class="difflineminus">-    let smbis = this._selectMessageByIDStatement;</span>
<a href="#l5.218"></a><span id="l5.218" class="difflineminus">-    </span>
<a href="#l5.219"></a><span id="l5.219" class="difflineminus">-    smbis.params.id = aID;</span>
<a href="#l5.220"></a><span id="l5.220" class="difflineminus">-    if (smbis.step())</span>
<a href="#l5.221"></a><span id="l5.221" class="difflineminus">-      message = this._messageFromRow(smbis.row);</span>
<a href="#l5.222"></a><span id="l5.222" class="difflineminus">-    smbis.reset();</span>
<a href="#l5.223"></a><span id="l5.223" class="difflineplus">+    if (message === null) {</span>
<a href="#l5.224"></a><span id="l5.224" class="difflineplus">+      let smbis = this._selectMessageByIDStatement;</span>
<a href="#l5.225"></a><span id="l5.225" class="difflineplus">+      </span>
<a href="#l5.226"></a><span id="l5.226" class="difflineplus">+      smbis.params.id = aID;</span>
<a href="#l5.227"></a><span id="l5.227" class="difflineplus">+      if (smbis.step()) {</span>
<a href="#l5.228"></a><span id="l5.228" class="difflineplus">+        message = this._messageFromRow(smbis.row);</span>
<a href="#l5.229"></a><span id="l5.229" class="difflineplus">+        GlodaCollectionManager.itemLoaded(message);</span>
<a href="#l5.230"></a><span id="l5.230" class="difflineplus">+      }</span>
<a href="#l5.231"></a><span id="l5.231" class="difflineplus">+      smbis.reset();</span>
<a href="#l5.232"></a><span id="l5.232" class="difflineplus">+    }</span>
<a href="#l5.233"></a><span id="l5.233">     </span>
<a href="#l5.234"></a><span id="l5.234">     return message;</span>
<a href="#l5.235"></a><span id="l5.235">   },</span>
<a href="#l5.236"></a><span id="l5.236"> </span>
<a href="#l5.237"></a><span id="l5.237">   get _selectMessageByLocationStatement() {</span>
<a href="#l5.238"></a><span id="l5.238">     let statement = this._createStatement(</span>
<a href="#l5.239"></a><span id="l5.239">       &quot;SELECT * FROM messages WHERE folderID = :folderID AND \</span>
<a href="#l5.240"></a><span id="l5.240">                                     messageKey = :messageKey&quot;);</span>
<a href="#l5.241"></a><span id="l5.241" class="difflineat">@@ -880,17 +911,17 @@ let GlodaDatastore = {</span>
<a href="#l5.242"></a><span id="l5.242">     if (this._selectMessageByLocationStatement.step())</span>
<a href="#l5.243"></a><span id="l5.243">       message = this._messageFromRow(this._selectMessageByLocationStatement.row);</span>
<a href="#l5.244"></a><span id="l5.244">     this._selectMessageByLocationStatement.reset();</span>
<a href="#l5.245"></a><span id="l5.245">     </span>
<a href="#l5.246"></a><span id="l5.246">     if (message === null)</span>
<a href="#l5.247"></a><span id="l5.247">       this._log.info(&quot;Error locating message with key=&quot; + aMessageKey +</span>
<a href="#l5.248"></a><span id="l5.248">                      &quot; and URI &quot; + aFolderURI);</span>
<a href="#l5.249"></a><span id="l5.249">     </span>
<a href="#l5.250"></a><span id="l5.250" class="difflineminus">-    return message;</span>
<a href="#l5.251"></a><span id="l5.251" class="difflineplus">+    return message &amp;&amp; GlodaCollectionManager.cacheLoadUnifyOne(message);</span>
<a href="#l5.252"></a><span id="l5.252">   },</span>
<a href="#l5.253"></a><span id="l5.253"> </span>
<a href="#l5.254"></a><span id="l5.254">   get _selectMessageIDsByFolderStatement() {</span>
<a href="#l5.255"></a><span id="l5.255">     let statement = this._createStatement(</span>
<a href="#l5.256"></a><span id="l5.256">       &quot;SELECT id FROM messages WHERE folderID = :folderID&quot;);</span>
<a href="#l5.257"></a><span id="l5.257">     this.__defineGetter__(&quot;_selectMessageIDsByFolderStatement&quot;,</span>
<a href="#l5.258"></a><span id="l5.258">       function() statement);</span>
<a href="#l5.259"></a><span id="l5.259">     return this._selectMessageIDsByFolderStatement;</span>
<a href="#l5.260"></a><span id="l5.260" class="difflineat">@@ -939,28 +970,35 @@ let GlodaDatastore = {</span>
<a href="#l5.261"></a><span id="l5.261">     let statement = this._createStatement(sqlString);</span>
<a href="#l5.262"></a><span id="l5.262">     </span>
<a href="#l5.263"></a><span id="l5.263">     while (statement.step()) {</span>
<a href="#l5.264"></a><span id="l5.264">       results[msgIDToIndex[statement.row[&quot;headerMessageID&quot;]]].push(</span>
<a href="#l5.265"></a><span id="l5.265">         this._messageFromRow(statement.row));</span>
<a href="#l5.266"></a><span id="l5.266">     }</span>
<a href="#l5.267"></a><span id="l5.267">     statement.reset();</span>
<a href="#l5.268"></a><span id="l5.268">     </span>
<a href="#l5.269"></a><span id="l5.269" class="difflineplus">+    for (let iResult=0; iResult &lt; results.length; iResult++) {</span>
<a href="#l5.270"></a><span id="l5.270" class="difflineplus">+      if (results[iResult].length)</span>
<a href="#l5.271"></a><span id="l5.271" class="difflineplus">+        GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l5.272"></a><span id="l5.272" class="difflineplus">+                                              results[iResult]);</span>
<a href="#l5.273"></a><span id="l5.273" class="difflineplus">+    }</span>
<a href="#l5.274"></a><span id="l5.274" class="difflineplus">+    </span>
<a href="#l5.275"></a><span id="l5.275">     return results;</span>
<a href="#l5.276"></a><span id="l5.276">   },</span>
<a href="#l5.277"></a><span id="l5.277"> </span>
<a href="#l5.278"></a><span id="l5.278">   get _deleteMessageByIDStatement() {</span>
<a href="#l5.279"></a><span id="l5.279">     let statement = this._createStatement(</span>
<a href="#l5.280"></a><span id="l5.280">       &quot;DELETE FROM messages WHERE id = :id&quot;);</span>
<a href="#l5.281"></a><span id="l5.281">     this.__defineGetter__(&quot;_deleteMessageByIDStatement&quot;,</span>
<a href="#l5.282"></a><span id="l5.282">                           function() statement);</span>
<a href="#l5.283"></a><span id="l5.283">     return this._deleteMessageByIDStatement; </span>
<a href="#l5.284"></a><span id="l5.284">   },</span>
<a href="#l5.285"></a><span id="l5.285">   </span>
<a href="#l5.286"></a><span id="l5.286">   deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l5.287"></a><span id="l5.287" class="difflineplus">+    // TODO: collection manager implications</span>
<a href="#l5.288"></a><span id="l5.288">     let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l5.289"></a><span id="l5.289">     dmbids.params.id = aMessageID;</span>
<a href="#l5.290"></a><span id="l5.290">     dmbids.execute();</span>
<a href="#l5.291"></a><span id="l5.291">   },</span>
<a href="#l5.292"></a><span id="l5.292"> </span>
<a href="#l5.293"></a><span id="l5.293">   get _deleteMessagesByConversationIDStatement() {</span>
<a href="#l5.294"></a><span id="l5.294">     let statement = this._createStatement(</span>
<a href="#l5.295"></a><span id="l5.295">       &quot;DELETE FROM messages WHERE conversationID = :conversationID&quot;);</span>
<a href="#l5.296"></a><span id="l5.296" class="difflineat">@@ -969,31 +1007,33 @@ let GlodaDatastore = {</span>
<a href="#l5.297"></a><span id="l5.297">     return this._deleteMessagesByConversationIDStatement; </span>
<a href="#l5.298"></a><span id="l5.298">   },</span>
<a href="#l5.299"></a><span id="l5.299"> </span>
<a href="#l5.300"></a><span id="l5.300">   /**</span>
<a href="#l5.301"></a><span id="l5.301">    * Delete messages by conversation ID.  For use by the indexer's deletion</span>
<a href="#l5.302"></a><span id="l5.302">    *  logic, NOT you.</span>
<a href="#l5.303"></a><span id="l5.303">    */</span>
<a href="#l5.304"></a><span id="l5.304">   deleteMessagesByConversationID:</span>
<a href="#l5.305"></a><span id="l5.305" class="difflineplus">+    // TODO: collection manager implications</span>
<a href="#l5.306"></a><span id="l5.306">       function gloda_ds_deleteMessagesByConversationID(aConversationID) {</span>
<a href="#l5.307"></a><span id="l5.307">     let dmbcids = this._deleteMessagesByConversationIDStatement;</span>
<a href="#l5.308"></a><span id="l5.308">     dmbcids.params.conversationID = aConversationID;</span>
<a href="#l5.309"></a><span id="l5.309">     dmbcids.execute();</span>
<a href="#l5.310"></a><span id="l5.310">   },</span>
<a href="#l5.311"></a><span id="l5.311">   </span>
<a href="#l5.312"></a><span id="l5.312">   /**</span>
<a href="#l5.313"></a><span id="l5.313">    * Get the first message found in the database with the given header</span>
<a href="#l5.314"></a><span id="l5.314">    *  Message-ID, or null if none exists.  Because of the good chance of there</span>
<a href="#l5.315"></a><span id="l5.315">    *  being more than one message with a Message-ID, you probably want a</span>
<a href="#l5.316"></a><span id="l5.316">    *  different method than this one.  At the very least, a method that takes</span>
<a href="#l5.317"></a><span id="l5.317">    *  a hint about what folder to look in...</span>
<a href="#l5.318"></a><span id="l5.318">    */</span>
<a href="#l5.319"></a><span id="l5.319">   getMessageByMessageID: function gloda_ds_getMessageByMessageID(aMessageID) {</span>
<a href="#l5.320"></a><span id="l5.320">     let ids = [aMessageID];</span>
<a href="#l5.321"></a><span id="l5.321" class="difflineplus">+    // getMessagesByMessageID handles the collection manager cache resolution</span>
<a href="#l5.322"></a><span id="l5.322">     let messagesWithID = this.getMessagesByMessageID(ids)[0];</span>
<a href="#l5.323"></a><span id="l5.323">     // Just return the first one; we are a failure </span>
<a href="#l5.324"></a><span id="l5.324">     if (messagesWithID.length &gt; 0)</span>
<a href="#l5.325"></a><span id="l5.325">       return messagesWithID[0];</span>
<a href="#l5.326"></a><span id="l5.326">     else</span>
<a href="#l5.327"></a><span id="l5.327">       return null;</span>
<a href="#l5.328"></a><span id="l5.328">   },</span>
<a href="#l5.329"></a><span id="l5.329"> </span>
<a href="#l5.330"></a><span id="l5.330" class="difflineat">@@ -1023,16 +1063,20 @@ let GlodaDatastore = {</span>
<a href="#l5.331"></a><span id="l5.331">       statement = this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l5.332"></a><span id="l5.332">     statement.params.conversationID = aConversationID; </span>
<a href="#l5.333"></a><span id="l5.333">     </span>
<a href="#l5.334"></a><span id="l5.334">     let messages = [];</span>
<a href="#l5.335"></a><span id="l5.335">     while (statement.step()) {</span>
<a href="#l5.336"></a><span id="l5.336">       messages.push(this._messageFromRow(statement.row));</span>
<a href="#l5.337"></a><span id="l5.337">     }</span>
<a href="#l5.338"></a><span id="l5.338">     statement.reset();</span>
<a href="#l5.339"></a><span id="l5.339" class="difflineplus">+</span>
<a href="#l5.340"></a><span id="l5.340" class="difflineplus">+    if (messages.length)</span>
<a href="#l5.341"></a><span id="l5.341" class="difflineplus">+      GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l5.342"></a><span id="l5.342" class="difflineplus">+                                            messages);</span>
<a href="#l5.343"></a><span id="l5.343">     </span>
<a href="#l5.344"></a><span id="l5.344">     return messages;</span>
<a href="#l5.345"></a><span id="l5.345">   },</span>
<a href="#l5.346"></a><span id="l5.346">   </span>
<a href="#l5.347"></a><span id="l5.347">   /* ********** Message Attributes ********** */</span>
<a href="#l5.348"></a><span id="l5.348">   get _insertMessageAttributeStatement() {</span>
<a href="#l5.349"></a><span id="l5.349">     let statement = this._createStatement(</span>
<a href="#l5.350"></a><span id="l5.350">       &quot;INSERT INTO messageAttributes (conversationID, messageID, attributeID, \</span>
<a href="#l5.351"></a><span id="l5.351" class="difflineat">@@ -1144,32 +1188,32 @@ let GlodaDatastore = {</span>
<a href="#l5.352"></a><span id="l5.352">         let valueTests = null;</span>
<a href="#l5.353"></a><span id="l5.353">         </span>
<a href="#l5.354"></a><span id="l5.354">         // our implementation requires that everyone in attr_ors has the same</span>
<a href="#l5.355"></a><span id="l5.355">         //  attribute.</span>
<a href="#l5.356"></a><span id="l5.356">         let presumedAttr = attr_ors[0][0];</span>
<a href="#l5.357"></a><span id="l5.357">         </span>
<a href="#l5.358"></a><span id="l5.358">         // -- handle full-text specially here, it's different than the other</span>
<a href="#l5.359"></a><span id="l5.359">         //  cases...</span>
<a href="#l5.360"></a><span id="l5.360" class="difflineminus">-        if (presumedAttr.isSpecial == Gloda.kSpecialFulltext) {</span>
<a href="#l5.361"></a><span id="l5.361" class="difflineplus">+        if (presumedAttr.special == kSpecialFulltext) {</span>
<a href="#l5.362"></a><span id="l5.362">           let matchStr = [APV[2] for each (APV in attr_ors)].join(&quot; OR &quot;);</span>
<a href="#l5.363"></a><span id="l5.363">           matchStr.replace(&quot;'&quot;, &quot;''&quot;);</span>
<a href="#l5.364"></a><span id="l5.364">         </span>
<a href="#l5.365"></a><span id="l5.365">           // for example, the match </span>
<a href="#l5.366"></a><span id="l5.366">           let ftSelect = &quot;SELECT docid FROM &quot; + nounMeta.tableName + &quot;Text&quot; +</span>
<a href="#l5.367"></a><span id="l5.367">             &quot; WHERE &quot; + presumedAttr.specialColumnName + &quot; MATCH '&quot; +</span>
<a href="#l5.368"></a><span id="l5.368">             matchStr + &quot;'&quot;;</span>
<a href="#l5.369"></a><span id="l5.369">           selects.push(ftSelect);</span>
<a href="#l5.370"></a><span id="l5.370">         </span>
<a href="#l5.371"></a><span id="l5.371">           // bypass the logic used by the other cases</span>
<a href="#l5.372"></a><span id="l5.372">           continue;</span>
<a href="#l5.373"></a><span id="l5.373">         }</span>
<a href="#l5.374"></a><span id="l5.374">         </span>
<a href="#l5.375"></a><span id="l5.375">         let tableName, idColumnName, valueColumnName;</span>
<a href="#l5.376"></a><span id="l5.376" class="difflineminus">-        if (presumedAttr.isSpecial == Gloda.kSpecialColumn) {</span>
<a href="#l5.377"></a><span id="l5.377" class="difflineplus">+        if (presumedAttr.special == kSpecialColumn) {</span>
<a href="#l5.378"></a><span id="l5.378">           tableName = nounMeta.tableName;</span>
<a href="#l5.379"></a><span id="l5.379">           idColumnName = &quot;id&quot;; // canonical id for a table is &quot;id&quot;.</span>
<a href="#l5.380"></a><span id="l5.380">           valueColumnName = presumedAttr.specialColumnName;</span>
<a href="#l5.381"></a><span id="l5.381">         }</span>
<a href="#l5.382"></a><span id="l5.382">         else {</span>
<a href="#l5.383"></a><span id="l5.383">           tableName = nounMeta.attrTableName;</span>
<a href="#l5.384"></a><span id="l5.384">           idColumnName = nounMeta.attrIDColumnName;</span>
<a href="#l5.385"></a><span id="l5.385">           valueColumnName = &quot;value&quot;;</span>
<a href="#l5.386"></a><span id="l5.386" class="difflineat">@@ -1191,17 +1235,17 @@ let GlodaDatastore = {</span>
<a href="#l5.387"></a><span id="l5.387">         </span>
<a href="#l5.388"></a><span id="l5.388">           let attributeID;</span>
<a href="#l5.389"></a><span id="l5.389">           if (APV[1] != null)</span>
<a href="#l5.390"></a><span id="l5.390">             attributeID = APV[0].bindParameter(APV[1]);</span>
<a href="#l5.391"></a><span id="l5.391">           else</span>
<a href="#l5.392"></a><span id="l5.392">             attributeID = APV[0].id;</span>
<a href="#l5.393"></a><span id="l5.393">           if (attributeID != lastAttributeID) {</span>
<a href="#l5.394"></a><span id="l5.394">             valueTests = [];</span>
<a href="#l5.395"></a><span id="l5.395" class="difflineminus">-            if (APV[0].isSpecial)</span>
<a href="#l5.396"></a><span id="l5.396" class="difflineplus">+            if (APV[0].special == kSpecialColumn)</span>
<a href="#l5.397"></a><span id="l5.397">               attrValueTests.push([&quot;&quot;, valueTests]);</span>
<a href="#l5.398"></a><span id="l5.398">             else</span>
<a href="#l5.399"></a><span id="l5.399">               attrValueTests.push([&quot;attributeID = &quot; + attributeID + &quot; AND &quot;,</span>
<a href="#l5.400"></a><span id="l5.400">                                    valueTests]);</span>
<a href="#l5.401"></a><span id="l5.401">             lastAttributeID = attributeID;</span>
<a href="#l5.402"></a><span id="l5.402">           }</span>
<a href="#l5.403"></a><span id="l5.403">           </span>
<a href="#l5.404"></a><span id="l5.404">           // straight value match?</span>
<a href="#l5.405"></a><span id="l5.405" class="difflineat">@@ -1240,22 +1284,31 @@ let GlodaDatastore = {</span>
<a href="#l5.406"></a><span id="l5.406">     </span>
<a href="#l5.407"></a><span id="l5.407">     let statement = this._createStatement(sqlString);</span>
<a href="#l5.408"></a><span id="l5.408">     </span>
<a href="#l5.409"></a><span id="l5.409">     let items = [];</span>
<a href="#l5.410"></a><span id="l5.410">     while (statement.step()) {</span>
<a href="#l5.411"></a><span id="l5.411">       items.push(nounMeta.objFromRow.call(nounMeta.datastore, statement.row));</span>
<a href="#l5.412"></a><span id="l5.412">     }</span>
<a href="#l5.413"></a><span id="l5.413">     statement.reset();</span>
<a href="#l5.414"></a><span id="l5.414" class="difflineplus">+    // have the collection manager attempt to replace the instances we just</span>
<a href="#l5.415"></a><span id="l5.415" class="difflineplus">+    //  created with pre-existing instances.  if the instance didn't exist,</span>
<a href="#l5.416"></a><span id="l5.416" class="difflineplus">+    //  cache the newly observed ones.  We are trading off wastes here; we don't</span>
<a href="#l5.417"></a><span id="l5.417" class="difflineplus">+    //  want to have to ask the collection manager about every row, and we don't</span>
<a href="#l5.418"></a><span id="l5.418" class="difflineplus">+    //  want to invent some alternate row storage.</span>
<a href="#l5.419"></a><span id="l5.419" class="difflineplus">+    GlodaCollectionManager.cacheLoadUnify(nounMeta.id, items);</span>
<a href="#l5.420"></a><span id="l5.420">     </span>
<a href="#l5.421"></a><span id="l5.421">     let collection = new GlodaCollection(items, aQuery);</span>
<a href="#l5.422"></a><span id="l5.422">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l5.423"></a><span id="l5.423">     return collection;</span>
<a href="#l5.424"></a><span id="l5.424">   },</span>
<a href="#l5.425"></a><span id="l5.425">   </span>
<a href="#l5.426"></a><span id="l5.426" class="difflineplus">+  /**</span>
<a href="#l5.427"></a><span id="l5.427" class="difflineplus">+   * Deprecated.  Use queries (which in turn use queryFromQuery).</span>
<a href="#l5.428"></a><span id="l5.428" class="difflineplus">+   */</span>
<a href="#l5.429"></a><span id="l5.429">   queryMessagesAPV: function gloda_ds_queryMessagesAPV(aAPVs) {</span>
<a href="#l5.430"></a><span id="l5.430">     let selects = [];</span>
<a href="#l5.431"></a><span id="l5.431">     </span>
<a href="#l5.432"></a><span id="l5.432">     for (let iAPV=0; iAPV &lt; aAPVs.length; iAPV++) {</span>
<a href="#l5.433"></a><span id="l5.433">       let APV = aAPVs[iAPV];</span>
<a href="#l5.434"></a><span id="l5.434">       </span>
<a href="#l5.435"></a><span id="l5.435">       let attributeID;</span>
<a href="#l5.436"></a><span id="l5.436">       if (APV[1] != null)</span>
<a href="#l5.437"></a><span id="l5.437" class="difflineat">@@ -1281,16 +1334,20 @@ let GlodaDatastore = {</span>
<a href="#l5.438"></a><span id="l5.438">                     selects.join(&quot; INTERSECT &quot;) + &quot; )&quot;;</span>
<a href="#l5.439"></a><span id="l5.439">     let statement = this._createStatement(sqlString);</span>
<a href="#l5.440"></a><span id="l5.440">     </span>
<a href="#l5.441"></a><span id="l5.441">     let messages = [];</span>
<a href="#l5.442"></a><span id="l5.442">     while (statement.step()) {</span>
<a href="#l5.443"></a><span id="l5.443">       messages.push(this._messageFromRow(statement.row));</span>
<a href="#l5.444"></a><span id="l5.444">     }</span>
<a href="#l5.445"></a><span id="l5.445">     statement.reset();</span>
<a href="#l5.446"></a><span id="l5.446" class="difflineplus">+    </span>
<a href="#l5.447"></a><span id="l5.447" class="difflineplus">+    if (messages.length)</span>
<a href="#l5.448"></a><span id="l5.448" class="difflineplus">+      GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l5.449"></a><span id="l5.449" class="difflineplus">+                                            messages);</span>
<a href="#l5.450"></a><span id="l5.450">      </span>
<a href="#l5.451"></a><span id="l5.451">     return messages;</span>
<a href="#l5.452"></a><span id="l5.452">   },</span>
<a href="#l5.453"></a><span id="l5.453">   </span>
<a href="#l5.454"></a><span id="l5.454">   /* ********** Contact ********** */</span>
<a href="#l5.455"></a><span id="l5.455">   get _insertContactStatement() {</span>
<a href="#l5.456"></a><span id="l5.456">     let statement = this._createStatement(</span>
<a href="#l5.457"></a><span id="l5.457">       &quot;INSERT INTO contacts (directoryUUID, contactUUID, name, popularity,\</span>
<a href="#l5.458"></a><span id="l5.458" class="difflineat">@@ -1307,19 +1364,21 @@ let GlodaDatastore = {</span>
<a href="#l5.459"></a><span id="l5.459">     ics.params.directoryUUID = aDirectoryUUID;</span>
<a href="#l5.460"></a><span id="l5.460">     ics.params.contactUUID = aContactUUID;</span>
<a href="#l5.461"></a><span id="l5.461">     ics.params.name = aName;</span>
<a href="#l5.462"></a><span id="l5.462">     ics.params.popularity = aPopularity;</span>
<a href="#l5.463"></a><span id="l5.463">     ics.params.frecency = aFrecency;</span>
<a href="#l5.464"></a><span id="l5.464">     </span>
<a href="#l5.465"></a><span id="l5.465">     ics.execute();</span>
<a href="#l5.466"></a><span id="l5.466">     </span>
<a href="#l5.467"></a><span id="l5.467" class="difflineminus">-    return new GlodaContact(this, this.dbConnection.lastInsertRowID,</span>
<a href="#l5.468"></a><span id="l5.468" class="difflineminus">-                            aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l5.469"></a><span id="l5.469" class="difflineminus">-                            aPopularity, aFrecency);</span>
<a href="#l5.470"></a><span id="l5.470" class="difflineplus">+    let contact = new GlodaContact(this, this.dbConnection.lastInsertRowID,</span>
<a href="#l5.471"></a><span id="l5.471" class="difflineplus">+                                   aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l5.472"></a><span id="l5.472" class="difflineplus">+                                   aPopularity, aFrecency);</span>
<a href="#l5.473"></a><span id="l5.473" class="difflineplus">+    GlodaCollectionManager.itemsAdded(contact.NOUN_ID, [contact]);</span>
<a href="#l5.474"></a><span id="l5.474" class="difflineplus">+    return contact;</span>
<a href="#l5.475"></a><span id="l5.475">   },</span>
<a href="#l5.476"></a><span id="l5.476"> </span>
<a href="#l5.477"></a><span id="l5.477">   get _updateContactStatement() {</span>
<a href="#l5.478"></a><span id="l5.478">     let statement = this._createStatement(</span>
<a href="#l5.479"></a><span id="l5.479">       &quot;UPDATE contacts SET directoryUUID = :directoryUUID, \</span>
<a href="#l5.480"></a><span id="l5.480">                            contactUUID = :contactUUID, \</span>
<a href="#l5.481"></a><span id="l5.481">                            name = :name, \</span>
<a href="#l5.482"></a><span id="l5.482">                            popularity = :popularity, \</span>
<a href="#l5.483"></a><span id="l5.483" class="difflineat">@@ -1351,33 +1410,28 @@ let GlodaDatastore = {</span>
<a href="#l5.484"></a><span id="l5.484">     let statement = this._createStatement(</span>
<a href="#l5.485"></a><span id="l5.485">       &quot;SELECT * FROM contacts WHERE id = :id&quot;);</span>
<a href="#l5.486"></a><span id="l5.486">     this.__defineGetter__(&quot;_selectContactByIDStatement&quot;,</span>
<a href="#l5.487"></a><span id="l5.487">       function() statement);</span>
<a href="#l5.488"></a><span id="l5.488">     return this._selectContactByIDStatement;</span>
<a href="#l5.489"></a><span id="l5.489">   },</span>
<a href="#l5.490"></a><span id="l5.490"> </span>
<a href="#l5.491"></a><span id="l5.491">   getContactByID: function gloda_ds_getContactByID(aContactID) {</span>
<a href="#l5.492"></a><span id="l5.492" class="difflineminus">-    let contact = null;</span>
<a href="#l5.493"></a><span id="l5.493" class="difflineplus">+    let contact = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l5.494"></a><span id="l5.494" class="difflineplus">+      GlodaContact.prototype.NOUN_ID, aContactID);</span>
<a href="#l5.495"></a><span id="l5.495">     </span>
<a href="#l5.496"></a><span id="l5.496" class="difflineminus">-    let [hit, miss] = GlodaCollectionManager.cacheLookup(</span>
<a href="#l5.497"></a><span id="l5.497" class="difflineminus">-      GlodaContact.prototype.NOUN_ID, [aContactID]);</span>
<a href="#l5.498"></a><span id="l5.498" class="difflineminus">-  </span>
<a href="#l5.499"></a><span id="l5.499" class="difflineminus">-    if (hit.length)</span>
<a href="#l5.500"></a><span id="l5.500" class="difflineminus">-      return hit[0];</span>
<a href="#l5.501"></a><span id="l5.501" class="difflineminus">-  </span>
<a href="#l5.502"></a><span id="l5.502" class="difflineminus">-    let scbi = this._selectContactByIDStatement;</span>
<a href="#l5.503"></a><span id="l5.503" class="difflineminus">-    scbi.params.id = aContactID;</span>
<a href="#l5.504"></a><span id="l5.504" class="difflineminus">-    if (scbi.step()) {</span>
<a href="#l5.505"></a><span id="l5.505" class="difflineminus">-      contact = this._contactFromRow(scbi.row);</span>
<a href="#l5.506"></a><span id="l5.506" class="difflineplus">+    if (contact === null) {</span>
<a href="#l5.507"></a><span id="l5.507" class="difflineplus">+      let scbi = this._selectContactByIDStatement;</span>
<a href="#l5.508"></a><span id="l5.508" class="difflineplus">+      scbi.params.id = aContactID;</span>
<a href="#l5.509"></a><span id="l5.509" class="difflineplus">+      if (scbi.step()) {</span>
<a href="#l5.510"></a><span id="l5.510" class="difflineplus">+        contact = this._contactFromRow(scbi.row);</span>
<a href="#l5.511"></a><span id="l5.511" class="difflineplus">+        GlodaCollectionManager.itemLoaded(contact);</span>
<a href="#l5.512"></a><span id="l5.512" class="difflineplus">+      }</span>
<a href="#l5.513"></a><span id="l5.513" class="difflineplus">+      scbi.reset();</span>
<a href="#l5.514"></a><span id="l5.514">     }</span>
<a href="#l5.515"></a><span id="l5.515" class="difflineminus">-    scbi.reset();</span>
<a href="#l5.516"></a><span id="l5.516" class="difflineminus">-    </span>
<a href="#l5.517"></a><span id="l5.517" class="difflineminus">-    if (contact)</span>
<a href="#l5.518"></a><span id="l5.518" class="difflineminus">-      GlodaCollectionManager.cacheAdd(contact.NOUN_ID, [contact]);</span>
<a href="#l5.519"></a><span id="l5.519">     </span>
<a href="#l5.520"></a><span id="l5.520">     return contact;</span>
<a href="#l5.521"></a><span id="l5.521">   },</span>
<a href="#l5.522"></a><span id="l5.522">   </span>
<a href="#l5.523"></a><span id="l5.523">   /* ********** Identity ********** */</span>
<a href="#l5.524"></a><span id="l5.524">   get _insertIdentityStatement() {</span>
<a href="#l5.525"></a><span id="l5.525">     let statement = this._createStatement(</span>
<a href="#l5.526"></a><span id="l5.526">       &quot;INSERT INTO identities (contactID, kind, value, description, relay) \</span>
<a href="#l5.527"></a><span id="l5.527" class="difflineat">@@ -1392,19 +1446,21 @@ let GlodaDatastore = {</span>
<a href="#l5.528"></a><span id="l5.528">     let iis = this._insertIdentityStatement;</span>
<a href="#l5.529"></a><span id="l5.529">     iis.params.contactID = aContactID;</span>
<a href="#l5.530"></a><span id="l5.530">     iis.params.kind = aKind;</span>
<a href="#l5.531"></a><span id="l5.531">     iis.params.value = aValue;</span>
<a href="#l5.532"></a><span id="l5.532">     iis.params.description = aDescription;</span>
<a href="#l5.533"></a><span id="l5.533">     iis.params.relay = aIsRelay ? 1 : 0;</span>
<a href="#l5.534"></a><span id="l5.534">     iis.execute();</span>
<a href="#l5.535"></a><span id="l5.535">   </span>
<a href="#l5.536"></a><span id="l5.536" class="difflineminus">-    return new GlodaIdentity(this, this.dbConnection.lastInsertRowID,</span>
<a href="#l5.537"></a><span id="l5.537" class="difflineminus">-                             aContactID, aContact, aKind, aValue,</span>
<a href="#l5.538"></a><span id="l5.538" class="difflineminus">-                             aDescription, aIsRelay);</span>
<a href="#l5.539"></a><span id="l5.539" class="difflineplus">+    let identity = new GlodaIdentity(this, this.dbConnection.lastInsertRowID,</span>
<a href="#l5.540"></a><span id="l5.540" class="difflineplus">+                                     aContactID, aContact, aKind, aValue,</span>
<a href="#l5.541"></a><span id="l5.541" class="difflineplus">+                                     aDescription, aIsRelay);</span>
<a href="#l5.542"></a><span id="l5.542" class="difflineplus">+    GlodaCollectionManager.itemsAdded(identity.NOUN_ID, [identity]);</span>
<a href="#l5.543"></a><span id="l5.543" class="difflineplus">+    return identity;</span>
<a href="#l5.544"></a><span id="l5.544">   },</span>
<a href="#l5.545"></a><span id="l5.545">   </span>
<a href="#l5.546"></a><span id="l5.546">   _identityFromRow: function gloda_ds_identityFromRow(aRow) {</span>
<a href="#l5.547"></a><span id="l5.547">     return new GlodaIdentity(this, aRow[&quot;id&quot;], aRow[&quot;contactID&quot;], null,</span>
<a href="#l5.548"></a><span id="l5.548">                              aRow[&quot;kind&quot;], aRow[&quot;value&quot;], aRow[&quot;description&quot;],</span>
<a href="#l5.549"></a><span id="l5.549">                              aRow[&quot;relay&quot;] ? true : false);</span>
<a href="#l5.550"></a><span id="l5.550">   },</span>
<a href="#l5.551"></a><span id="l5.551">   </span>
<a href="#l5.552"></a><span id="l5.552" class="difflineat">@@ -1423,33 +1479,37 @@ let GlodaDatastore = {</span>
<a href="#l5.553"></a><span id="l5.553">     let ibkv = this._selectIdentityByKindValueStatement;</span>
<a href="#l5.554"></a><span id="l5.554">     ibkv.params.kind = aKind;</span>
<a href="#l5.555"></a><span id="l5.555">     ibkv.params.value = aValue;</span>
<a href="#l5.556"></a><span id="l5.556">     if (ibkv.step()) {</span>
<a href="#l5.557"></a><span id="l5.557">       identity = this._identityFromRow(ibkv.row);</span>
<a href="#l5.558"></a><span id="l5.558">     }</span>
<a href="#l5.559"></a><span id="l5.559">     ibkv.reset();</span>
<a href="#l5.560"></a><span id="l5.560">     </span>
<a href="#l5.561"></a><span id="l5.561" class="difflineminus">-    return identity;</span>
<a href="#l5.562"></a><span id="l5.562" class="difflineplus">+    return identity &amp;&amp; GlodaCollectionManager.cacheLoadUnifyOne(identity);</span>
<a href="#l5.563"></a><span id="l5.563">   },</span>
<a href="#l5.564"></a><span id="l5.564"> </span>
<a href="#l5.565"></a><span id="l5.565">   get _selectIdentityByIDStatement() {</span>
<a href="#l5.566"></a><span id="l5.566">     let statement = this._createStatement(</span>
<a href="#l5.567"></a><span id="l5.567">       &quot;SELECT * FROM identities WHERE id = :id&quot;);</span>
<a href="#l5.568"></a><span id="l5.568">     this.__defineGetter__(&quot;_selectIdentityByIDStatement&quot;,</span>
<a href="#l5.569"></a><span id="l5.569">       function() statement);</span>
<a href="#l5.570"></a><span id="l5.570">     return this._selectIdentityByIDStatement;</span>
<a href="#l5.571"></a><span id="l5.571">   },</span>
<a href="#l5.572"></a><span id="l5.572"> </span>
<a href="#l5.573"></a><span id="l5.573">   getIdentityByID: function gloda_ds_getIdentity(aID) {</span>
<a href="#l5.574"></a><span id="l5.574" class="difflineminus">-    let identity = null;</span>
<a href="#l5.575"></a><span id="l5.575" class="difflineplus">+    let identity = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l5.576"></a><span id="l5.576" class="difflineplus">+      GlodaIdentity.prototype.NOUN_ID, aID);</span>
<a href="#l5.577"></a><span id="l5.577">     </span>
<a href="#l5.578"></a><span id="l5.578" class="difflineminus">-    let sibis = this._selectIdentityByIDStatement;</span>
<a href="#l5.579"></a><span id="l5.579" class="difflineminus">-    sibis.params.id = aID;</span>
<a href="#l5.580"></a><span id="l5.580" class="difflineminus">-    if (sibis.step()) {</span>
<a href="#l5.581"></a><span id="l5.581" class="difflineminus">-      identity = this._identityFromRow(sibis.row);</span>
<a href="#l5.582"></a><span id="l5.582" class="difflineplus">+    if (identity === null) {</span>
<a href="#l5.583"></a><span id="l5.583" class="difflineplus">+      let sibis = this._selectIdentityByIDStatement;</span>
<a href="#l5.584"></a><span id="l5.584" class="difflineplus">+      sibis.params.id = aID;</span>
<a href="#l5.585"></a><span id="l5.585" class="difflineplus">+      if (sibis.step()) {</span>
<a href="#l5.586"></a><span id="l5.586" class="difflineplus">+        identity = this._identityFromRow(sibis.row);</span>
<a href="#l5.587"></a><span id="l5.587" class="difflineplus">+        GlodaCollectionManager.itemLoaded(identity);</span>
<a href="#l5.588"></a><span id="l5.588" class="difflineplus">+      }</span>
<a href="#l5.589"></a><span id="l5.589" class="difflineplus">+      sibis.reset();</span>
<a href="#l5.590"></a><span id="l5.590">     }</span>
<a href="#l5.591"></a><span id="l5.591" class="difflineminus">-    sibis.reset();</span>
<a href="#l5.592"></a><span id="l5.592">     </span>
<a href="#l5.593"></a><span id="l5.593">     return identity;</span>
<a href="#l5.594"></a><span id="l5.594">   },</span>
<a href="#l5.595"></a><span id="l5.595"> </span>
<a href="#l5.596"></a><span id="l5.596"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/fundattr.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/fundattr.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -128,16 +128,31 @@ let GlodaFundAttr = {</span>
<a href="#l6.4"></a><span id="l6.4">       bind: false,</span>
<a href="#l6.5"></a><span id="l6.5">       singular: true,</span>
<a href="#l6.6"></a><span id="l6.6">       special: Gloda.kSpecialColumn,</span>
<a href="#l6.7"></a><span id="l6.7">       specialColumnName: &quot;frecency&quot;,</span>
<a href="#l6.8"></a><span id="l6.8">       subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l6.9"></a><span id="l6.9">       objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l6.10"></a><span id="l6.10">       explanation: null, // frecency is internal, no explanation required</span>
<a href="#l6.11"></a><span id="l6.11">       });    </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+    /* ***** Identities ***** */</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+    this._attrIdentityContact = Gloda.defineAttribute({</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+      provider: this,</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+      attributeName: &quot;contact&quot;,</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+      bind: false,</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+      singular: true,</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+      specialColumnName: &quot;contactID&quot;,</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+      objectNoun: Gloda.NOUN_CONTACT,</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+      explanation: null, // popularity is internal, no explanation required</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+      });</span>
<a href="#l6.27"></a><span id="l6.27">   </span>
<a href="#l6.28"></a><span id="l6.28">     /* ***** Messages ***** */</span>
<a href="#l6.29"></a><span id="l6.29">     // folder</span>
<a href="#l6.30"></a><span id="l6.30">     this._attrFolder = Gloda.defineAttribute({</span>
<a href="#l6.31"></a><span id="l6.31">       provider: this,</span>
<a href="#l6.32"></a><span id="l6.32">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l6.33"></a><span id="l6.33">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l6.34"></a><span id="l6.34">       attributeName: &quot;folderURI&quot;,</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineat">@@ -375,17 +390,17 @@ let GlodaFundAttr = {</span>
<a href="#l6.36"></a><span id="l6.36">     for (let iTo=0; iTo &lt; toIdentities.length; iTo++) {</span>
<a href="#l6.37"></a><span id="l6.37">       let toIdentity = toIdentities[iTo];</span>
<a href="#l6.38"></a><span id="l6.38">       attribs.push([this._attrTo.id, toIdentity.id]);</span>
<a href="#l6.39"></a><span id="l6.39">       // optimization attribute to-me ('I' am the parameter)</span>
<a href="#l6.40"></a><span id="l6.40">       if (toIdentity.id in myIdentities) {</span>
<a href="#l6.41"></a><span id="l6.41">         attribs.push([this._attrCcMe.bindParameter(toIdentity.id),</span>
<a href="#l6.42"></a><span id="l6.42">                       authorIdentity.id]);</span>
<a href="#l6.43"></a><span id="l6.43">         if (aIsNew)</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineminus">-          toIdentity.contact.popularity += this.POPULARITY_TO_ME;</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+          authorIdentity.contact.popularity += this.POPULARITY_TO_ME;</span>
<a href="#l6.46"></a><span id="l6.46">       }</span>
<a href="#l6.47"></a><span id="l6.47">       // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l6.48"></a><span id="l6.48">       if (isFromMe) {</span>
<a href="#l6.49"></a><span id="l6.49">         attribs.push([this._attrFromMeCc.bindParameter(authorIdentity.id),</span>
<a href="#l6.50"></a><span id="l6.50">                       toIdentity.id]);</span>
<a href="#l6.51"></a><span id="l6.51">         // also, popularity</span>
<a href="#l6.52"></a><span id="l6.52">         if (aIsNew)</span>
<a href="#l6.53"></a><span id="l6.53">           toIdentity.contact.popularity += this.POPULARITY_FROM_ME_TO;</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineat">@@ -395,17 +410,17 @@ let GlodaFundAttr = {</span>
<a href="#l6.55"></a><span id="l6.55">     for (let iCc=0; iCc &lt; ccIdentities.length; iCc++) {</span>
<a href="#l6.56"></a><span id="l6.56">       let ccIdentity = ccIdentities[iCc];</span>
<a href="#l6.57"></a><span id="l6.57">       attribs.push([this._attrCc.id, ccIdentity.id]);</span>
<a href="#l6.58"></a><span id="l6.58">       // optimization attribute cc-me ('I' am the parameter)</span>
<a href="#l6.59"></a><span id="l6.59">       if (ccIdentity.id in myIdentities) {</span>
<a href="#l6.60"></a><span id="l6.60">         attribs.push([this._attrCcMe.bindParameter(ccIdentity.id),</span>
<a href="#l6.61"></a><span id="l6.61">                       authorIdentity.id]);</span>
<a href="#l6.62"></a><span id="l6.62">         if (aIsNew)</span>
<a href="#l6.63"></a><span id="l6.63" class="difflineminus">-          ccIdentity.contact.popularity += this.POPULARITY_CC_ME;</span>
<a href="#l6.64"></a><span id="l6.64" class="difflineplus">+          authorIdentity.contact.popularity += this.POPULARITY_CC_ME;</span>
<a href="#l6.65"></a><span id="l6.65">       }</span>
<a href="#l6.66"></a><span id="l6.66">       // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l6.67"></a><span id="l6.67">       if (isFromMe) {</span>
<a href="#l6.68"></a><span id="l6.68">         attribs.push([this._attrFromMeCc.bindParameter(authorIdentity.id),</span>
<a href="#l6.69"></a><span id="l6.69">                       ccIdentity.id]);</span>
<a href="#l6.70"></a><span id="l6.70">         // also, popularity</span>
<a href="#l6.71"></a><span id="l6.71">         if (aIsNew)</span>
<a href="#l6.72"></a><span id="l6.72">           ccIdentity.contact.popularity += this.POPULARITY_FROM_ME_CC;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -109,17 +109,17 @@ let Gloda = {</span>
<a href="#l7.4"></a><span id="l7.4">         let name = parsed.names[iAddress];</span>
<a href="#l7.5"></a><span id="l7.5">         let mailAddr = parsed.addresses[iAddress];</span>
<a href="#l7.6"></a><span id="l7.6">         </span>
<a href="#l7.7"></a><span id="l7.7">         // fall-back to the mail address if the name is empty</span>
<a href="#l7.8"></a><span id="l7.8">         if ((name === null) || (name == &quot;&quot;))</span>
<a href="#l7.9"></a><span id="l7.9">           name = mailAddr;</span>
<a href="#l7.10"></a><span id="l7.10">           </span>
<a href="#l7.11"></a><span id="l7.11">         // we must create a contact</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-        let contact = GlodaDatastore.createContact(null, null, name);</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+        let contact = GlodaDatastore.createContact(null, null, name, 0, 0);</span>
<a href="#l7.14"></a><span id="l7.14">         </span>
<a href="#l7.15"></a><span id="l7.15">         // we must create the identity.  use a blank description because there's</span>
<a href="#l7.16"></a><span id="l7.16">         //  nothing to differentiate it from other identities, as this contact</span>
<a href="#l7.17"></a><span id="l7.17">         //  only has one initially (us).</span>
<a href="#l7.18"></a><span id="l7.18">         identity = GlodaDatastore.createIdentity(contact.id, contact, &quot;email&quot;,</span>
<a href="#l7.19"></a><span id="l7.19">                                                  mailAddr,</span>
<a href="#l7.20"></a><span id="l7.20">                                                  &quot;&quot;, false);</span>
<a href="#l7.21"></a><span id="l7.21">       }</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineat">@@ -208,17 +208,18 @@ let Gloda = {</span>
<a href="#l7.23"></a><span id="l7.23">     }</span>
<a href="#l7.24"></a><span id="l7.24">     </span>
<a href="#l7.25"></a><span id="l7.25">     if (existingIdentities.length) {</span>
<a href="#l7.26"></a><span id="l7.26">       // just use the first guy's contact</span>
<a href="#l7.27"></a><span id="l7.27">       myContact = existingIdentities[0].contact;</span>
<a href="#l7.28"></a><span id="l7.28">     }</span>
<a href="#l7.29"></a><span id="l7.29">     else {</span>
<a href="#l7.30"></a><span id="l7.30">       // create a new contact</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-      myContact = GlodaDatastore.createContact(null, null, fullName || &quot;Me&quot;);</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+      myContact = GlodaDatastore.createContact(null, null, fullName || &quot;Me&quot;,</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineplus">+                                               0, 0);</span>
<a href="#l7.34"></a><span id="l7.34">     }</span>
<a href="#l7.35"></a><span id="l7.35">     </span>
<a href="#l7.36"></a><span id="l7.36">     if (identitiesToCreate.length) {</span>
<a href="#l7.37"></a><span id="l7.37">       for (let iIdentity=0; iIdentity &lt; identitiesToCreate.length; iIdentity++){</span>
<a href="#l7.38"></a><span id="l7.38">         let emailAddress = identitiesToCreate[iIdentity];</span>
<a href="#l7.39"></a><span id="l7.39">         // XXX this won't always be of type &quot;email&quot; as we add new account types</span>
<a href="#l7.40"></a><span id="l7.40">         // XXX the blank string could be trying to differentiate; we do have</span>
<a href="#l7.41"></a><span id="l7.41">         //  enough info to do it.</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineat">@@ -297,20 +298,20 @@ let Gloda = {</span>
<a href="#l7.43"></a><span id="l7.43">    *  &quot; OR &quot; when used in an or-constraint case.  Gloda's query mechanism</span>
<a href="#l7.44"></a><span id="l7.44">    *  currently lacks the ability to to compile Gloda-style and-constraints</span>
<a href="#l7.45"></a><span id="l7.45">    *  into a single MATCH query, but it will turn out okay, just less</span>
<a href="#l7.46"></a><span id="l7.46">    *  efficiently than it could.</span>
<a href="#l7.47"></a><span id="l7.47">    */</span>
<a href="#l7.48"></a><span id="l7.48">   NOUN_FULLTEXT: 20,</span>
<a href="#l7.49"></a><span id="l7.49">   NOUN_TAG: 50,</span>
<a href="#l7.50"></a><span id="l7.50">   NOUN_FOLDER: 100,</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineminus">-  NOUN_CONVERSATION: 101,</span>
<a href="#l7.52"></a><span id="l7.52" class="difflineminus">-  NOUN_MESSAGE: 102,</span>
<a href="#l7.53"></a><span id="l7.53" class="difflineplus">+  NOUN_CONVERSATION: GlodaConversation.prototype.NOUN_ID, // 101</span>
<a href="#l7.54"></a><span id="l7.54" class="difflineplus">+  NOUN_MESSAGE: GlodaMessage.prototype.NOUN_ID, // 102</span>
<a href="#l7.55"></a><span id="l7.55">   NOUN_CONTACT: GlodaContact.prototype.NOUN_ID, // 103</span>
<a href="#l7.56"></a><span id="l7.56" class="difflineminus">-  NOUN_IDENTITY: 104,</span>
<a href="#l7.57"></a><span id="l7.57" class="difflineplus">+  NOUN_IDENTITY: GlodaIdentity.prototype.NOUN_ID, // 104</span>
<a href="#l7.58"></a><span id="l7.58">   </span>
<a href="#l7.59"></a><span id="l7.59">   /**</span>
<a href="#l7.60"></a><span id="l7.60">    * Parameterized identities, for use in the from-me, to-me, cc-me optimization</span>
<a href="#l7.61"></a><span id="l7.61">    *  cases.  Not for reuse without some thought.</span>
<a href="#l7.62"></a><span id="l7.62">    */</span>
<a href="#l7.63"></a><span id="l7.63">   NOUN_PARAM_IDENTITY: 200,</span>
<a href="#l7.64"></a><span id="l7.64">   </span>
<a href="#l7.65"></a><span id="l7.65">   /** Next Noun ID to hand out, these don't need to be persisted (for now). */</span>
<a href="#l7.66"></a><span id="l7.66" class="difflineat">@@ -417,17 +418,17 @@ let Gloda = {</span>
<a href="#l7.67"></a><span id="l7.67">       fromParamAndValue: function(aParam, aVal) {</span>
<a href="#l7.68"></a><span id="l7.68">         if(aVal != 0) return true; else return false;</span>
<a href="#l7.69"></a><span id="l7.69">       },</span>
<a href="#l7.70"></a><span id="l7.70">       toParamAndValue: function(aBool) {</span>
<a href="#l7.71"></a><span id="l7.71">         return [null, aBool ? 1 : 0];</span>
<a href="#l7.72"></a><span id="l7.72">       }}, this.NOUN_BOOLEAN);</span>
<a href="#l7.73"></a><span id="l7.73">     this.defineNoun({</span>
<a href="#l7.74"></a><span id="l7.74">       name: &quot;number&quot;,</span>
<a href="#l7.75"></a><span id="l7.75" class="difflineminus">-      class: Number, firstClass: false,</span>
<a href="#l7.76"></a><span id="l7.76" class="difflineplus">+      class: Number, firstClass: false, continuous: true,</span>
<a href="#l7.77"></a><span id="l7.77">       fromParamAndValue: function(aIgnoredParam, aNum) {</span>
<a href="#l7.78"></a><span id="l7.78">         return aNum;</span>
<a href="#l7.79"></a><span id="l7.79">       },</span>
<a href="#l7.80"></a><span id="l7.80">       toParamAndValue: function(aNum) {</span>
<a href="#l7.81"></a><span id="l7.81">         return [null, aNum];</span>
<a href="#l7.82"></a><span id="l7.82">       }}, this.NOUN_NUMBER);</span>
<a href="#l7.83"></a><span id="l7.83">     this.defineNoun({</span>
<a href="#l7.84"></a><span id="l7.84">       name: &quot;date&quot;,</span>
<a href="#l7.85"></a><span id="l7.85" class="difflineat">@@ -466,16 +467,18 @@ let Gloda = {</span>
<a href="#l7.86"></a><span id="l7.86">     //  examining the data, we will probably hit the correlation.</span>
<a href="#l7.87"></a><span id="l7.87">     this.defineNoun({</span>
<a href="#l7.88"></a><span id="l7.88">       name: &quot;conversation&quot;,</span>
<a href="#l7.89"></a><span id="l7.89">       class: GlodaConversation,</span>
<a href="#l7.90"></a><span id="l7.90">       firstClass: false,</span>
<a href="#l7.91"></a><span id="l7.91">       cache: true, cacheCost: 512,</span>
<a href="#l7.92"></a><span id="l7.92">       tableName: &quot;conversations&quot;,</span>
<a href="#l7.93"></a><span id="l7.93">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;conversationID&quot;,</span>
<a href="#l7.94"></a><span id="l7.94" class="difflineplus">+      datastore: GlodaDatastore,</span>
<a href="#l7.95"></a><span id="l7.95" class="difflineplus">+      objFromRow: GlodaDatastore._conversationFromRow,</span>
<a href="#l7.96"></a><span id="l7.96">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l7.97"></a><span id="l7.97">         return GlodaDatastore.getConversationByID(aID);</span>
<a href="#l7.98"></a><span id="l7.98">       },</span>
<a href="#l7.99"></a><span id="l7.99">       toParamAndValue: function(aConversation) {</span>
<a href="#l7.100"></a><span id="l7.100">         if (aConversation instanceof GlodaConversation)</span>
<a href="#l7.101"></a><span id="l7.101">           return [null, aConversation.id];</span>
<a href="#l7.102"></a><span id="l7.102">         else // assume they're just passing the id directly</span>
<a href="#l7.103"></a><span id="l7.103">           return [null, aConversation];</span>
<a href="#l7.104"></a><span id="l7.104" class="difflineat">@@ -647,17 +650,17 @@ let Gloda = {</span>
<a href="#l7.105"></a><span id="l7.105">       </span>
<a href="#l7.106"></a><span id="l7.106">       if (nounMeta.continuous) {</span>
<a href="#l7.107"></a><span id="l7.107">         let rangedConstrainer = function() {</span>
<a href="#l7.108"></a><span id="l7.108">           // all the arguments provided end up being ORed together</span>
<a href="#l7.109"></a><span id="l7.109">           let our_ors = [];</span>
<a href="#l7.110"></a><span id="l7.110">           for(let iArg=0; iArg &lt; arguments.length; iArg +=2 ) {</span>
<a href="#l7.111"></a><span id="l7.111">             let pv1 = nounMeta.toParamAndValue(arguments[iArg]);</span>
<a href="#l7.112"></a><span id="l7.112">             let pv2 = nounMeta.toParamAndValue(arguments[iArg+1]);</span>
<a href="#l7.113"></a><span id="l7.113" class="difflineminus">-            our_ors.push([aAttr, pv1[0], pv[1], pv2[1]]);</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineplus">+            our_ors.push([aAttr, pv1[0], pv1[1], pv2[1]]);</span>
<a href="#l7.115"></a><span id="l7.115">           }</span>
<a href="#l7.116"></a><span id="l7.116">           // but the constraints are ANDed together</span>
<a href="#l7.117"></a><span id="l7.117">           this._constraints.push(our_ors);</span>
<a href="#l7.118"></a><span id="l7.118">           return this;</span>
<a href="#l7.119"></a><span id="l7.119">         }</span>
<a href="#l7.120"></a><span id="l7.120">         </span>
<a href="#l7.121"></a><span id="l7.121">         subjectNounMeta.queryClass.prototype[aBindName + &quot;Range&quot;] =</span>
<a href="#l7.122"></a><span id="l7.122">           rangedConstrainer;</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineat">@@ -748,20 +751,24 @@ let Gloda = {</span>
<a href="#l7.124"></a><span id="l7.124">       //  not yet 'bound' to a provider (and had important meta-info that</span>
<a href="#l7.125"></a><span id="l7.125">       //  doesn't go in the db copied over)</span>
<a href="#l7.126"></a><span id="l7.126">       attr = GlodaDatastore._attributes[compoundName];</span>
<a href="#l7.127"></a><span id="l7.127">       if (attr.provider !== null) {</span>
<a href="#l7.128"></a><span id="l7.128">         return attr;</span>
<a href="#l7.129"></a><span id="l7.129">       }</span>
<a href="#l7.130"></a><span id="l7.130">       </span>
<a href="#l7.131"></a><span id="l7.131">       // we are behind the abstraction veil and can set these things</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineplus">+      // (these would otherwise be passed in to the GlodaAttributeDef</span>
<a href="#l7.133"></a><span id="l7.133" class="difflineplus">+      //  constructor.  they are not like the HATHATHAT guys below)</span>
<a href="#l7.134"></a><span id="l7.134">       attr._provider = aAttrDef.provider;</span>
<a href="#l7.135"></a><span id="l7.135">       attr._subjectTypes = aAttrDef.subjectNouns;</span>
<a href="#l7.136"></a><span id="l7.136">       attr._objectType = aAttrDef.objectNoun;</span>
<a href="#l7.137"></a><span id="l7.137">       attr._explanationFormat = aAttrDef.explanation;</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineplus">+      // things after here also need to be set below the new GlodaAttributeDef</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineplus">+      //  clause below... HATHATHAT</span>
<a href="#l7.140"></a><span id="l7.140">       attr._special = aAttrDef.special || this.kSpecialNotAtAll;</span>
<a href="#l7.141"></a><span id="l7.141">       attr._specialColumnName = aAttrDef.specialColumnName || null;</span>
<a href="#l7.142"></a><span id="l7.142">       </span>
<a href="#l7.143"></a><span id="l7.143">       for (let iSubject=0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l7.144"></a><span id="l7.144">            iSubject++) {</span>
<a href="#l7.145"></a><span id="l7.145">         let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l7.146"></a><span id="l7.146">         this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l7.147"></a><span id="l7.147">                             aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l7.148"></a><span id="l7.148" class="difflineat">@@ -784,16 +791,21 @@ let Gloda = {</span>
<a href="#l7.149"></a><span id="l7.149">                                                   null);</span>
<a href="#l7.150"></a><span id="l7.150">     }</span>
<a href="#l7.151"></a><span id="l7.151">     </span>
<a href="#l7.152"></a><span id="l7.152">     attr = new GlodaAttributeDef(GlodaDatastore, attrID, compoundName,</span>
<a href="#l7.153"></a><span id="l7.153">                                  aAttrDef.provider, aAttrDef.attributeType,</span>
<a href="#l7.154"></a><span id="l7.154">                                  aAttrDef.extensionName, aAttrDef.attributeName,</span>
<a href="#l7.155"></a><span id="l7.155">                                  aAttrDef.subjectNouns, aAttrDef.objectNoun,</span>
<a href="#l7.156"></a><span id="l7.156">                                  aAttrDef.explanation);</span>
<a href="#l7.157"></a><span id="l7.157" class="difflineplus">+    // things here match the HATHATHAT clause above.  clearly, this should also</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineplus">+    //  be resolved more satisfactorily.</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineplus">+    attr._special = aAttrDef.special || this.kSpecialNotAtAll;</span>
<a href="#l7.160"></a><span id="l7.160" class="difflineplus">+    attr._specialColumnName = aAttrDef.specialColumnName || null;</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+    </span>
<a href="#l7.162"></a><span id="l7.162">     GlodaDatastore._attributes[compoundName] = attr;</span>
<a href="#l7.163"></a><span id="l7.163"> </span>
<a href="#l7.164"></a><span id="l7.164">     for (let iSubject=0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l7.165"></a><span id="l7.165">          iSubject++) {</span>
<a href="#l7.166"></a><span id="l7.166">       let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l7.167"></a><span id="l7.167">       this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l7.168"></a><span id="l7.168">                           aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l7.169"></a><span id="l7.169">     }</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineat">@@ -838,17 +850,17 @@ let Gloda = {</span>
<a href="#l7.171"></a><span id="l7.171">    *  that you would still like to receive updates for. </span>
<a href="#l7.172"></a><span id="l7.172">    */</span>
<a href="#l7.173"></a><span id="l7.173">   explicitCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l7.174"></a><span id="l7.174">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l7.175"></a><span id="l7.175">     let collection = new GlodaCollection(aItems, null, null)</span>
<a href="#l7.176"></a><span id="l7.176">     let query = new nounMeta.explicitQueryClass(collection);</span>
<a href="#l7.177"></a><span id="l7.177">     collection.query = query;</span>
<a href="#l7.178"></a><span id="l7.178">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l7.179"></a><span id="l7.179" class="difflineminus">-    return colleciton;</span>
<a href="#l7.180"></a><span id="l7.180" class="difflineplus">+    return collection;</span>
<a href="#l7.181"></a><span id="l7.181">   },</span>
<a href="#l7.182"></a><span id="l7.182">   </span>
<a href="#l7.183"></a><span id="l7.183">   processMessage: function gloda_ns_processMessage(aMessage, aMsgHdr,</span>
<a href="#l7.184"></a><span id="l7.184">                                                    aMimeMsg, aIsNew) {</span>
<a href="#l7.185"></a><span id="l7.185">     // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l7.186"></a><span id="l7.186">     //  before applying the new attributes.</span>
<a href="#l7.187"></a><span id="l7.187">     aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l7.188"></a><span id="l7.188">     </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -42,16 +42,17 @@ const Ci = Components.interfaces;</span>
<a href="#l8.4"></a><span id="l8.4"> const Cr = Components.results;</span>
<a href="#l8.5"></a><span id="l8.5"> const Cu = Components.utils;</span>
<a href="#l8.6"></a><span id="l8.6"> </span>
<a href="#l8.7"></a><span id="l8.7"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l8.8"></a><span id="l8.8"> </span>
<a href="#l8.9"></a><span id="l8.9"> Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l8.10"></a><span id="l8.10"> Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l8.11"></a><span id="l8.11"> Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l8.13"></a><span id="l8.13"> </span>
<a href="#l8.14"></a><span id="l8.14"> Cu.import(&quot;resource://gloda/modules/mimemsg.js&quot;);</span>
<a href="#l8.15"></a><span id="l8.15"> </span>
<a href="#l8.16"></a><span id="l8.16"> function range(begin, end) {</span>
<a href="#l8.17"></a><span id="l8.17">   for (let i = begin; i &lt; end; ++i) {</span>
<a href="#l8.18"></a><span id="l8.18">     yield i;</span>
<a href="#l8.19"></a><span id="l8.19">   }</span>
<a href="#l8.20"></a><span id="l8.20"> }</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineat">@@ -1291,28 +1292,30 @@ let GlodaIndexer = {</span>
<a href="#l8.22"></a><span id="l8.22">     let isNew;</span>
<a href="#l8.23"></a><span id="l8.23">     if (curMsg === null) {</span>
<a href="#l8.24"></a><span id="l8.24">       this._log.debug(&quot;...creating new message&quot;);</span>
<a href="#l8.25"></a><span id="l8.25">       curMsg = this._datastore.createMessage(aMsgHdr.folder.URI,</span>
<a href="#l8.26"></a><span id="l8.26">                                              aMsgHdr.messageKey,                </span>
<a href="#l8.27"></a><span id="l8.27">                                              conversationID,</span>
<a href="#l8.28"></a><span id="l8.28">                                              aMsgHdr.date,</span>
<a href="#l8.29"></a><span id="l8.29">                                              aMsgHdr.messageId,</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineminus">-                                             null); // no snippet</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+                                             aMimeMsg ?</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+                                             aMimeMsg.body : null); // no snippet</span>
<a href="#l8.33"></a><span id="l8.33">       isNew = true;</span>
<a href="#l8.34"></a><span id="l8.34">     }</span>
<a href="#l8.35"></a><span id="l8.35">     else {</span>
<a href="#l8.36"></a><span id="l8.36">       isNew = (curMsg._messageKey === null); // aka was-a-ghost</span>
<a href="#l8.37"></a><span id="l8.37">       curMsg._folderID = this._datastore._mapFolderURI(aMsgHdr.folder.URI);</span>
<a href="#l8.38"></a><span id="l8.38">       curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l8.39"></a><span id="l8.39">       // note: we are assuming that our matching logic is flawless in that</span>
<a href="#l8.40"></a><span id="l8.40">       //  if this message was not a ghost, we are assuming the 'body'</span>
<a href="#l8.41"></a><span id="l8.41">       //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l8.42"></a><span id="l8.42">       //  that there are cases where this is not true.</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineminus">-      this._datastore.updateMessage(curMsg, isNew ? aBody : null);</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+      this._datastore.updateMessage(curMsg, (isNew &amp;&amp; aMimeMsg) ?</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineplus">+                                    aMimeMsg.body : null);</span>
<a href="#l8.46"></a><span id="l8.46">     }</span>
<a href="#l8.47"></a><span id="l8.47">     </span>
<a href="#l8.48"></a><span id="l8.48">     // TODO: provide the parent gloda message if we can conjure it up.</span>
<a href="#l8.49"></a><span id="l8.49">     Gloda.processMessage(curMsg, aMsgHdr, aMimeMsg, isNew,</span>
<a href="#l8.50"></a><span id="l8.50">                          /* parent gloda message */ null);</span>
<a href="#l8.51"></a><span id="l8.51">      </span>
<a href="#l8.52"></a><span id="l8.52">     this.callbackDriver();</span>
<a href="#l8.53"></a><span id="l8.53">   },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/modules/query.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/modules/query.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -79,17 +79,17 @@ GlodaQueryClass.prototype = {</span>
<a href="#l9.4"></a><span id="l9.4">   </span>
<a href="#l9.5"></a><span id="l9.5">   /**</span>
<a href="#l9.6"></a><span id="l9.6">    * Test whether the given first-class noun instance satisfies this query.</span>
<a href="#l9.7"></a><span id="l9.7">    * </span>
<a href="#l9.8"></a><span id="l9.8">    */</span>
<a href="#l9.9"></a><span id="l9.9">   test: function gloda_query_test(aObj) {</span>
<a href="#l9.10"></a><span id="l9.10">     // when changing this method, be sure that GlodaDatastore's queryFromQuery</span>
<a href="#l9.11"></a><span id="l9.11">     //  method likewise has any required changes made. </span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-    let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+    let unionQueries = [this].concat(this._unions);</span>
<a href="#l9.14"></a><span id="l9.14">     </span>
<a href="#l9.15"></a><span id="l9.15">     for (let iUnion=0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l9.16"></a><span id="l9.16">       let curQuery = unionQueries[iUnion];</span>
<a href="#l9.17"></a><span id="l9.17"> </span>
<a href="#l9.18"></a><span id="l9.18">       // assume success until a specific (or) constraint proves us wrong</span>
<a href="#l9.19"></a><span id="l9.19">       let querySatisfied = true;</span>
<a href="#l9.20"></a><span id="l9.20">       for (let iConstraint=0; iConstraint &lt; curQuery._constraints.length; </span>
<a href="#l9.21"></a><span id="l9.21">            iConstraint++) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/modules/suffixtree.js</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/modules/suffixtree.js</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -113,31 +113,49 @@ function SuffixTree(aStr) {</span>
<a href="#l10.4"></a><span id="l10.4"> /**</span>
<a href="#l10.5"></a><span id="l10.5">  * States are </span>
<a href="#l10.6"></a><span id="l10.6">  */</span>
<a href="#l10.7"></a><span id="l10.7"> SuffixTree.prototype = {</span>
<a href="#l10.8"></a><span id="l10.8">   /**</span>
<a href="#l10.9"></a><span id="l10.9">    * Find all items matching the provided substring.</span>
<a href="#l10.10"></a><span id="l10.10">    */</span>
<a href="#l10.11"></a><span id="l10.11">   findMatches: function findMatches(aSubstring) {</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+    let results = [];</span>
<a href="#l10.13"></a><span id="l10.13">     let state = this._root;</span>
<a href="#l10.14"></a><span id="l10.14">     let index=0;</span>
<a href="#l10.15"></a><span id="l10.15">     let end = aSubstring.length;</span>
<a href="#l10.16"></a><span id="l10.16">     while(index &lt; end) {</span>
<a href="#l10.17"></a><span id="l10.17">       state = state[aSubstring[index]];</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+      // bail if there was no edge</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineplus">+      if (state === undefined)</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+        return results;</span>
<a href="#l10.21"></a><span id="l10.21">       index += state.length; </span>
<a href="#l10.22"></a><span id="l10.22">     }</span>
<a href="#l10.23"></a><span id="l10.23">     </span>
<a href="#l10.24"></a><span id="l10.24">     // state should now be the node which itself and all its children match...</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineminus">-    let results = [];</span>
<a href="#l10.26"></a><span id="l10.26"> this.dump(state);</span>
<a href="#l10.27"></a><span id="l10.27" class="difflineplus">+    // The delta is to adjust us to the offset of the last letter of our match;</span>
<a href="#l10.28"></a><span id="l10.28" class="difflineplus">+    //  the edge we traversed to get here may have found us traversing more</span>
<a href="#l10.29"></a><span id="l10.29" class="difflineplus">+    //  than we wanted.</span>
<a href="#l10.30"></a><span id="l10.30">     // index - end captures the over-shoot of the edge traversal,</span>
<a href="#l10.31"></a><span id="l10.31">     // index - end + 1 captures the fact that we want to find the last letter</span>
<a href="#l10.32"></a><span id="l10.32">     //  that matched, not just the first letter beyond it</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineminus">-    this._resultGather(state, results, {}, end, index - end + 1, true);</span>
<a href="#l10.34"></a><span id="l10.34" class="difflineplus">+    // However, if this state is a leaf node (end == 'infinity'), then 'end'</span>
<a href="#l10.35"></a><span id="l10.35" class="difflineplus">+    //  isn't describing an edge at all and we want to avoid accounting for it.</span>
<a href="#l10.36"></a><span id="l10.36" class="difflineplus">+    let delta;</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineplus">+    /*</span>
<a href="#l10.38"></a><span id="l10.38" class="difflineplus">+    if (state.end != this._infinity)</span>
<a href="#l10.39"></a><span id="l10.39" class="difflineplus">+      //delta = index - end + 1;</span>
<a href="#l10.40"></a><span id="l10.40" class="difflineplus">+      delta = end - (index - state.length); </span>
<a href="#l10.41"></a><span id="l10.41" class="difflineplus">+    else */</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineplus">+    delta = index - state.length - end + 1;</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+ </span>
<a href="#l10.44"></a><span id="l10.44" class="difflineplus">+dump(&quot;about to resultgather. end: &quot; + end + &quot; index: &quot; + index + </span>
<a href="#l10.45"></a><span id="l10.45" class="difflineplus">+     &quot; state.end: &quot; + state.end + &quot; infinity: &quot; + this._infinity + &quot;\n&quot;);</span>
<a href="#l10.46"></a><span id="l10.46" class="difflineplus">+    this._resultGather(state, results, {}, end, delta, true);</span>
<a href="#l10.47"></a><span id="l10.47">     return results;</span>
<a href="#l10.48"></a><span id="l10.48">   },</span>
<a href="#l10.49"></a><span id="l10.49">   </span>
<a href="#l10.50"></a><span id="l10.50">   _resultGather: function resultGather(aState, aResults, aPresence,</span>
<a href="#l10.51"></a><span id="l10.51">                                        aPatLength, aDelta, alreadyAdjusted) {</span>
<a href="#l10.52"></a><span id="l10.52">     // find the item that this state originated from based on the state's</span>
<a href="#l10.53"></a><span id="l10.53">     //  start character.  offsetToItem holds [string start index, string end</span>
<a href="#l10.54"></a><span id="l10.54">     //  index (exclusive), item reference].  So we want to binary search to</span>
<a href="#l10.55"></a><span id="l10.55" class="difflineat">@@ -167,47 +185,36 @@ this.dump(state);</span>
<a href="#l10.56"></a><span id="l10.56">     //   a match.</span>
<a href="#l10.57"></a><span id="l10.57">     </span>
<a href="#l10.58"></a><span id="l10.58">     // at this point, we have located the origin string that corresponds to the</span>
<a href="#l10.59"></a><span id="l10.59">     //  start index of this state.</span>
<a href="#l10.60"></a><span id="l10.60">     // - The match terminated with the end of the preceding string, and does</span>
<a href="#l10.61"></a><span id="l10.61">     //   not match us at all.  We, and potentially our children, are merely</span>
<a href="#l10.62"></a><span id="l10.62">     //   serving as a unique terminal.</span>
<a href="#l10.63"></a><span id="l10.63">     // - The </span>
<a href="#l10.64"></a><span id="l10.64" class="difflineplus">+</span>
<a href="#l10.65"></a><span id="l10.65" class="difflineplus">+  let patternFirst = patternLast - (aPatLength - 1);</span>
<a href="#l10.66"></a><span id="l10.66">     </span>
<a href="#l10.67"></a><span id="l10.67"> dump(&quot;considering &quot; + this._str.slice(stringStart, stringEnd) + &quot; with pos &quot; + </span>
<a href="#l10.68"></a><span id="l10.68">      stringStart + &quot;:&quot; + stringEnd + &quot; with state &quot; +</span>
<a href="#l10.69"></a><span id="l10.69">      aState.start + &quot;:&quot; + aState.end +</span>
<a href="#l10.70"></a><span id="l10.70" class="difflineminus">-     &quot;(patternLast: &quot; + patternLast + &quot; delta: &quot; + aDelta + &quot;)\n&quot;);</span>
<a href="#l10.71"></a><span id="l10.71" class="difflineminus">-/*</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineminus">-    // we don't want this string if its start is the start of a string...</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineminus">-    let bail = false;</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineminus">-    if (start == aState.start) {</span>
<a href="#l10.75"></a><span id="l10.75" class="difflineminus">-      if (mid) {</span>
<a href="#l10.76"></a><span id="l10.76" class="difflineminus">-        mid--;</span>
<a href="#l10.77"></a><span id="l10.77" class="difflineminus">-        start = this._offsetsToItems[mid*3];</span>
<a href="#l10.78"></a><span id="l10.78" class="difflineminus">-        end = this._offsetsToItems[mid*3+1];</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineminus">-        bail = true;</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineminus">-dump(&quot;revised to &quot; + this._str.slice(start, end) + &quot; with pos &quot; + </span>
<a href="#l10.81"></a><span id="l10.81" class="difflineminus">-     start + &quot;:&quot; + end + &quot; with state &quot; +</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineminus">-     aState.start + &quot;:&quot; + aState.end + &quot;\n&quot;);</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineminus">-      }</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineminus">-      else</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineminus">-        return; </span>
<a href="#l10.86"></a><span id="l10.86" class="difflineminus">-    }</span>
<a href="#l10.87"></a><span id="l10.87" class="difflineminus">-*/</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineminus">-  if (patternLast - aPatLength &gt;= stringStart) {</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineplus">+     &quot;(patFirst:&quot; + patternFirst + &quot; patLast: &quot; + patternLast +</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineplus">+     &quot; delta: &quot; + aDelta + &quot;)\n&quot;);</span>
<a href="#l10.91"></a><span id="l10.91" class="difflineplus">+</span>
<a href="#l10.92"></a><span id="l10.92" class="difflineplus">+  if (patternFirst &gt;= stringStart) {</span>
<a href="#l10.93"></a><span id="l10.93">     if (!(stringStart in aPresence)) {</span>
<a href="#l10.94"></a><span id="l10.94" class="difflineminus">-dump(&quot;  adding!\n&quot;);</span>
<a href="#l10.95"></a><span id="l10.95" class="difflineplus">+dump(&quot;  adding! (patternFirst: &quot; + patternFirst + &quot;)\n&quot;);</span>
<a href="#l10.96"></a><span id="l10.96">       aPresence[stringStart] = true;</span>
<a href="#l10.97"></a><span id="l10.97">       aResults.push(this._offsetsToItems[mid*3+2]);</span>
<a href="#l10.98"></a><span id="l10.98">     }</span>
<a href="#l10.99"></a><span id="l10.99">   }</span>
<a href="#l10.100"></a><span id="l10.100">   else {</span>
<a href="#l10.101"></a><span id="l10.101" class="difflineminus">-dump(&quot;  disregarding because pattern is not contained.\n&quot;); </span>
<a href="#l10.102"></a><span id="l10.102" class="difflineplus">+dump(&quot;  disregarding because pattern is not contained. (patternLast:&quot; +</span>
<a href="#l10.103"></a><span id="l10.103" class="difflineplus">+  patternLast + &quot; aPatLength: &quot; + aPatLength + &quot; stringstart: &quot; +</span>
<a href="#l10.104"></a><span id="l10.104" class="difflineplus">+  stringStart + &quot;\n&quot;); </span>
<a href="#l10.105"></a><span id="l10.105">   }</span>
<a href="#l10.106"></a><span id="l10.106">     </span>
<a href="#l10.107"></a><span id="l10.107">     // bail if we had it coming OR</span>
<a href="#l10.108"></a><span id="l10.108">     // if the result terminates at/part-way through this state, meaning any</span>
<a href="#l10.109"></a><span id="l10.109">     //  of its children are not going to be actual results, just hangers</span>
<a href="#l10.110"></a><span id="l10.110">     //  on.</span>
<a href="#l10.111"></a><span id="l10.111"> /*</span>
<a href="#l10.112"></a><span id="l10.112">     if (bail || (end &lt;= aState.end)) {</span>
<a href="#l10.113"></a><span id="l10.113" class="difflineat">@@ -216,17 +223,17 @@ dump(&quot;  bailing! (bail was: &quot; + bail + &quot;</span>
<a href="#l10.114"></a><span id="l10.114">     }</span>
<a href="#l10.115"></a><span id="l10.115"> */    </span>
<a href="#l10.116"></a><span id="l10.116">     // process our children...</span>
<a href="#l10.117"></a><span id="l10.117">     for (let key in aState) {</span>
<a href="#l10.118"></a><span id="l10.118">       // edges have attributes of length 1...</span>
<a href="#l10.119"></a><span id="l10.119">       if (key.length == 1) {</span>
<a href="#l10.120"></a><span id="l10.120">         let statePrime = aState[key];</span>
<a href="#l10.121"></a><span id="l10.121">         this._resultGather(statePrime, aResults, aPresence, aPatLength,</span>
<a href="#l10.122"></a><span id="l10.122" class="difflineminus">-                           aDelta + (alreadyAdjusted ? 0 : aState.length),</span>
<a href="#l10.123"></a><span id="l10.123" class="difflineplus">+                           aDelta + aState.length, //(alreadyAdjusted ? 0 : aState.length),</span>
<a href="#l10.124"></a><span id="l10.124">                            false);</span>
<a href="#l10.125"></a><span id="l10.125">       }</span>
<a href="#l10.126"></a><span id="l10.126">     }</span>
<a href="#l10.127"></a><span id="l10.127">   },</span>
<a href="#l10.128"></a><span id="l10.128"> </span>
<a href="#l10.129"></a><span id="l10.129">   /**</span>
<a href="#l10.130"></a><span id="l10.130">    * Given a reference 'pair' of a state and a string (may be 'empty'=explicit,</span>
<a href="#l10.131"></a><span id="l10.131">    *  which means no work to do and we return immediately) follow that state</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

