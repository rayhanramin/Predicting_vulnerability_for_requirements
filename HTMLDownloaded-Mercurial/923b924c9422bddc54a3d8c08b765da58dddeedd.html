<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 8279:923b924c9422bddc54a3d8c08b765da58dddeedd</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 923b924c9422bddc54a3d8c08b765da58dddeedd" />
<meta property="og:url" content="/comm-central/rev/923b924c9422bddc54a3d8c08b765da58dddeedd" />
<meta property="og:description" content="Bug 659788 - Add icons for Windows 7 jumplist taskbar items. r=Standard8" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 923b924c9422bddc54a3d8c08b765da58dddeedd 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/923b924c9422bddc54a3d8c08b765da58dddeedd">shortlog</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/923b924c9422bddc54a3d8c08b765da58dddeedd">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd">files</a> |
changeset |
<a href="/comm-central/raw-rev/923b924c9422bddc54a3d8c08b765da58dddeedd">raw</a>  | <a href="/comm-central/archive/923b924c9422bddc54a3d8c08b765da58dddeedd.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=659788">Bug 659788</a> - Add icons for Windows 7 jumplist taskbar items. r=Standard8
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#83;&#105;&#100;&#100;&#104;&#97;&#114;&#116;&#104;&#32;&#65;&#103;&#97;&#114;&#119;&#97;&#108;&#32;&#60;&#115;&#105;&#100;&#46;&#98;&#117;&#103;&#122;&#105;&#108;&#108;&#97;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Wed, 10 Aug 2011 19:02:14 +0530</td></tr>

<tr>
 <td>changeset 8279</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/923b924c9422bddc54a3d8c08b765da58dddeedd">923b924c9422bddc54a3d8c08b765da58dddeedd</a></td>
</tr>



<tr>
<td>parent 8278</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/4cb88997f292f9cb49d10603d741703551d6e5c0">4cb88997f292f9cb49d10603d741703551d6e5c0</a>
</td>
</tr>

<tr>
<td>child 8280</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/3d7a6ee8b730a2113bcc0831269df922caff87c1">3d7a6ee8b730a2113bcc0831269df922caff87c1</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=923b924c9422bddc54a3d8c08b765da58dddeedd">6364</a></td></tr>
<tr><td>push user</td><td>sid.bugzilla@gmail.com</td></tr>
<tr><td>push date</td><td class="date age">Wed, 10 Aug 2011 13:51:37 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@e7baa8d39055 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=e7baa8d39055607dbb700a451f99734a347ddaa3">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=e7baa8d39055607dbb700a451f99734a347ddaa3&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=e7baa8d39055607dbb700a451f99734a347ddaa3&newProject=comm-central&newRevision=923b924c9422bddc54a3d8c08b765da58dddeedd&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=e7baa8d39055607dbb700a451f99734a347ddaa3&newProject=comm-central&newRevision=923b924c9422bddc54a3d8c08b765da58dddeedd&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=e7baa8d39055607dbb700a451f99734a347ddaa3&newProject=comm-central&newRevision=923b924c9422bddc54a3d8c08b765da58dddeedd&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28Standard8%29&revcount=50">Standard8</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=659788">659788</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=659788">Bug 659788</a> - Add icons for Windows 7 jumplist taskbar items. r=Standard8

The patch does the following at build time:
- extract the icons from the mail-toolbar-aero.png sprite sheet
- add an icon header to each png to convert it into an ico
- embed the icos in the EXE

To do this it adds the MIT-licensed pypng library to the tree.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/png2ico.py">build/png2ico.py</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/png2ico.py">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/png2ico.py">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/png2ico.py">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/png2ico.py">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/png2ico.py">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/exnumpy.py">build/pypng/exnumpy.py</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/exnumpy.py">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/exnumpy.py">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/exnumpy.py">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/exnumpy.py">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/exnumpy.py">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/iccp.py">build/pypng/iccp.py</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/iccp.py">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/iccp.py">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/iccp.py">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/iccp.py">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/iccp.py">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/mkiccp.py">build/pypng/mkiccp.py</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/mkiccp.py">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/mkiccp.py">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/mkiccp.py">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/mkiccp.py">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/mkiccp.py">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pdsimgtopng">build/pypng/pdsimgtopng</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pdsimgtopng">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pdsimgtopng">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pdsimgtopng">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pdsimgtopng">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pdsimgtopng">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipasgrey">build/pypng/pipasgrey</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipasgrey">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipasgrey">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipasgrey">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipasgrey">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipasgrey">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcat">build/pypng/pipcat</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcat">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcat">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcat">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcat">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcat">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcolours">build/pypng/pipcolours</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcolours">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcolours">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcolours">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcolours">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcolours">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcomposite">build/pypng/pipcomposite</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcomposite">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcomposite">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcomposite">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcomposite">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipcomposite">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipdither">build/pypng/pipdither</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipdither">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipdither">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipdither">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipdither">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipdither">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/piprgb">build/pypng/piprgb</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/piprgb">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/piprgb">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/piprgb">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/piprgb">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/piprgb">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipscalez">build/pypng/pipscalez</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipscalez">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipscalez">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipscalez">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipscalez">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipscalez">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipstack">build/pypng/pipstack</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipstack">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipstack">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipstack">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipstack">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipstack">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipwindow">build/pypng/pipwindow</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipwindow">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipwindow">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipwindow">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipwindow">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pipwindow">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/plan9topng.py">build/pypng/plan9topng.py</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/plan9topng.py">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/plan9topng.py">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/plan9topng.py">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/plan9topng.py">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/plan9topng.py">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/png.py">build/pypng/png.py</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/png.py">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/png.py">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/png.py">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/png.py">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/png.py">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pngchunk">build/pypng/pngchunk</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pngchunk">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pngchunk">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pngchunk">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pngchunk">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pngchunk">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnghist">build/pypng/pnghist</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnghist">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnghist">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnghist">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnghist">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnghist">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnglsch">build/pypng/pnglsch</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnglsch">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnglsch">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnglsch">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnglsch">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/pnglsch">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/texttopng">build/pypng/texttopng</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/texttopng">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/texttopng">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/texttopng">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/texttopng">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/build/pypng/texttopng">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/config/config.mk">config/config.mk</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/config/config.mk">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/config/config.mk">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/config/config.mk">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/config/config.mk">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/config/config.mk">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/Makefile.in">mail/app/Makefile.in</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/Makefile.in">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/Makefile.in">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/Makefile.in">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/Makefile.in">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/Makefile.in">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/splash.rc">mail/app/splash.rc</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/splash.rc">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/splash.rc">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/splash.rc">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/splash.rc">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/app/splash.rc">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/components/wintaskbar/windowsJumpLists.js">mail/components/wintaskbar/windowsJumpLists.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/components/wintaskbar/windowsJumpLists.js">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/components/wintaskbar/windowsJumpLists.js">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/components/wintaskbar/windowsJumpLists.js">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/components/wintaskbar/windowsJumpLists.js">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/mail/components/wintaskbar/windowsJumpLists.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/mailnews/base/src/nsMessengerWinIntegration.cpp">mailnews/base/src/nsMessengerWinIntegration.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/mailnews/base/src/nsMessengerWinIntegration.cpp">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/mailnews/base/src/nsMessengerWinIntegration.cpp">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/mailnews/base/src/nsMessengerWinIntegration.cpp">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/mailnews/base/src/nsMessengerWinIntegration.cpp">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/mailnews/base/src/nsMessengerWinIntegration.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/suite/app/splash.rc">suite/app/splash.rc</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/923b924c9422bddc54a3d8c08b765da58dddeedd/suite/app/splash.rc">file</a> |
<a href="/comm-central/annotate/923b924c9422bddc54a3d8c08b765da58dddeedd/suite/app/splash.rc">annotate</a> |
<a href="/comm-central/diff/923b924c9422bddc54a3d8c08b765da58dddeedd/suite/app/splash.rc">diff</a> |
<a href="/comm-central/comparison/923b924c9422bddc54a3d8c08b765da58dddeedd/suite/app/splash.rc">comparison</a> |
<a href="/comm-central/log/923b924c9422bddc54a3d8c08b765da58dddeedd/suite/app/splash.rc">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1">new file mode 100644</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineminus">--- /dev/null</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineplus">+++ b/build/png2ico.py</span>
<a href="#l1.4"></a><span id="l1.4" class="difflineat">@@ -0,0 +1,115 @@</span>
<a href="#l1.5"></a><span id="l1.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l1.6"></a><span id="l1.6" class="difflineplus">+# ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l1.7"></a><span id="l1.7" class="difflineplus">+# Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l1.8"></a><span id="l1.8" class="difflineplus">+#</span>
<a href="#l1.9"></a><span id="l1.9" class="difflineplus">+# The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l1.10"></a><span id="l1.10" class="difflineplus">+# 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l1.11"></a><span id="l1.11" class="difflineplus">+# the License. You may obtain a copy of the License at</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+# http://www.mozilla.org/MPL/</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+#</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+# Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+# for the specific language governing rights and limitations under the</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+# License.</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+#</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+# The Original Code is mozilla.org code.</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+#</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+# The Initial Developer of the Original Code is</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineplus">+# the Mozilla Foundation.</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+# Portions created by the Initial Developer are Copyright (C) 2011</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+# the Initial Developer. All Rights Reserved.</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+#</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+# Contributor(s):</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+#   Siddharth Agarwal &lt;sid.bugzilla@gmail.com&gt;</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineplus">+#</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineplus">+# Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+# either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+# the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+# in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+# of those above. If you wish to allow use of your version of this file only</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+# under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+# use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+# decision by deleting the provisions above and replace them with the notice</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineplus">+# and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+# the provisions above, a recipient may use your version of this file under</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+# the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+#</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+# ***** END LICENSE BLOCK *****</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+import png</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+import sys</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+import StringIO</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+import struct</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+import ctypes</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+# ref: http://msdn.microsoft.com/en-us/library/ms997538</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+class ICONDIR(ctypes.LittleEndianStructure):</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+    _pack_ = 1</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+    _fields_ = [(&quot;idReserved&quot;, ctypes.c_ushort),</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+                (&quot;idType&quot;, ctypes.c_ushort),</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+                (&quot;idCount&quot;, ctypes.c_ushort)]</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+class ICONDIRENTRY(ctypes.LittleEndianStructure):</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+    _pack_ = 1</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+    _fields_ = [(&quot;bWidth&quot;, ctypes.c_byte),</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+                (&quot;bHeight&quot;, ctypes.c_byte),</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+                (&quot;bColorCount&quot;, ctypes.c_byte),</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+                (&quot;bReserved&quot;, ctypes.c_byte),</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+                (&quot;wPlanes&quot;, ctypes.c_ushort),</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+                (&quot;wBitCount&quot;, ctypes.c_ushort),</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+                (&quot;dwBytesInRes&quot;, ctypes.c_ulong),</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+                (&quot;dwImageOffset&quot;, ctypes.c_ulong)]</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+# R, G, B, A, so 4 columns per pixel</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+COLS_PP = 4</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+def main(infile, left, top, size, outfile):</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineplus">+    img = png.Reader(filename=infile)</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineplus">+    pixels = list(img.asRGBA()[2])</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineplus">+    # Take the subarray out. This is the ugliest but probably most efficient way</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+    # to do it</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+    outpixels = [[0] * (size * COLS_PP) for x in xrange(size)]</span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+    for row in xrange(size):</span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+        for col in xrange(size * COLS_PP):</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+            outpixels[row][col] = pixels[top + row][left * COLS_PP + col]</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+    # Set up a 32bpp RGBA PNG.</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+    writer = png.Writer(size=(size, size), bitdepth=8, alpha=True)</span>
<a href="#l1.82"></a><span id="l1.82" class="difflineplus">+    # Write to a memory buffer</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineplus">+    outpng = StringIO.StringIO()</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineplus">+    writer.write(outpng, outpixels)</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineplus">+    outpngbuf = outpng.getvalue()</span>
<a href="#l1.86"></a><span id="l1.86" class="difflineplus">+    outpng.close()</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineplus">+</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineplus">+    # Set up an icon header</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineplus">+    icondir = ICONDIR()</span>
<a href="#l1.90"></a><span id="l1.90" class="difflineplus">+    icondir.idReserved = 0</span>
<a href="#l1.91"></a><span id="l1.91" class="difflineplus">+    # Icons are type 1</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineplus">+    icondir.idType = 1</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineplus">+    icondir.idCount = 1</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineplus">+</span>
<a href="#l1.95"></a><span id="l1.95" class="difflineplus">+    iconentry = ICONDIRENTRY()</span>
<a href="#l1.96"></a><span id="l1.96" class="difflineplus">+    iconentry.bWidth = size</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineplus">+    iconentry.bHeight = size</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineplus">+    # Truecolor images have color count set to 0</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+    iconentry.bColorCount = 0</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+    iconentry.bReserved = 0</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+    # PNGs have 1 color plane</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+    iconentry.wPlanes = 1</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+    # We're RGBA, so 32 bits per pixel</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineplus">+    iconentry.wBitCount = 32</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineplus">+    # Length of the buffer</span>
<a href="#l1.106"></a><span id="l1.106" class="difflineplus">+    iconentry.dwBytesInRes = len(outpngbuf)</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineplus">+    # The data will be right after the icondir and iconentry</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineplus">+    iconentry.dwImageOffset = ctypes.sizeof(icondir) + ctypes.sizeof(iconentry)</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+    # Time to write everything out</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+    out = open(outfile, &quot;wb&quot;)</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineplus">+    out.write(icondir)</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineplus">+    out.write(iconentry)</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineplus">+    out.write(outpngbuf)</span>
<a href="#l1.115"></a><span id="l1.115" class="difflineplus">+    out.close()</span>
<a href="#l1.116"></a><span id="l1.116" class="difflineplus">+</span>
<a href="#l1.117"></a><span id="l1.117" class="difflineplus">+if __name__ == &quot;__main__&quot;:</span>
<a href="#l1.118"></a><span id="l1.118" class="difflineplus">+    # Convert left, top and size into integers</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineplus">+    main(*([sys.argv[1]] + [int(val) for val in sys.argv[2:5]] + [sys.argv[5]]))</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1">new file mode 100644</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineminus">--- /dev/null</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineplus">+++ b/build/pypng/exnumpy.py</span>
<a href="#l2.4"></a><span id="l2.4" class="difflineat">@@ -0,0 +1,128 @@</span>
<a href="#l2.5"></a><span id="l2.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l2.6"></a><span id="l2.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/exnumpy.py $</span>
<a href="#l2.7"></a><span id="l2.7" class="difflineplus">+# $Rev: 126 $</span>
<a href="#l2.8"></a><span id="l2.8" class="difflineplus">+</span>
<a href="#l2.9"></a><span id="l2.9" class="difflineplus">+# Numpy example.</span>
<a href="#l2.10"></a><span id="l2.10" class="difflineplus">+# Original code created by Mel Raab, modified by David Jones.</span>
<a href="#l2.11"></a><span id="l2.11" class="difflineplus">+</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+'''</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  Example code integrating RGB PNG files, PyPNG and NumPy</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+  (abstracted from Mel Raab's functioning code)</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+'''</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+# http://www.python.org/doc/2.4.4/lib/module-itertools.html</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+import itertools</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+import numpy</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+import png</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineplus">+</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineplus">+</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineplus">+''' If you have a PNG file for an RGB image,</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineplus">+    and want to create a numpy array of data from it.</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+'''</span>
<a href="#l2.27"></a><span id="l2.27" class="difflineplus">+# Read the file &quot;picture.png&quot; from the current directory.  The `Reader`</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineplus">+# class can take a filename, a file-like object, or the byte data</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+# directly; this suggests alternatives such as using urllib to read</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+# an image from the internet:</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+# png.Reader(file=urllib.urlopen('http://www.libpng.org/pub/png/PngSuite/basn2c16.png'))</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+pngReader=png.Reader(filename='picture.png')</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+# Tuple unpacking, using multiple assignment, is very useful for the</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+# result of asDirect (and other methods).</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+# See</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+# http://docs.python.org/tutorial/introduction.html#first-steps-towards-programming</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+row_count, column_count, pngdata, meta = pngReader.asDirect()</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+bitdepth=meta['bitdepth']</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+plane_count=meta['planes']</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+# Make sure we're dealing with RGB files</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+assert plane_count == 3</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+''' Boxed row flat pixel:</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+      list([R,G,B, R,G,B, R,G,B],</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+           [R,G,B, R,G,B, R,G,B])</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+    Array dimensions for this example:  (2,9)</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+    Create `image_2d` as a two-dimensional NumPy array by stacking a</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+    sequence of 1-dimensional arrays (rows).</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+    The NumPy array mimics PyPNG's (boxed row flat pixel) representation;</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+    it will have dimensions ``(row_count,column_count*plane_count)``.</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+'''</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+# The use of ``numpy.uint16``, below, is to convert each row to a NumPy</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+# array with data type ``numpy.uint16``.  This is a feature of NumPy,</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+# discussed further in </span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+# http://docs.scipy.org/doc/numpy/user/basics.types.html .</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+# You can use avoid the explicit conversion with</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+# ``numpy.vstack(pngdata)``, but then NumPy will pick the array's data</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+# type; in practice it seems to pick ``numpy.int32``, which is large enough</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+# to hold any pixel value for any PNG image but uses 4 bytes per value when</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+# 1 or 2 would be enough.</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+# --- extract 001 start</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+image_2d = numpy.vstack(itertools.imap(numpy.uint16, pngdata))</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+# --- extract 001 end</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineplus">+# Do not be tempted to use ``numpy.asarray``; when passed an iterator</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+# (`pngdata` is often an iterator) it will attempt to create a size 1</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+# array with the iterator as its only element.</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+# An alternative to the above is to create the target array of the right</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+# shape, then populate it row by row:</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+if 0:</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+    image_2d = numpy.zeros((row_count,plane_count*column_count),</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+                           dtype=numpy.uint16)</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+    for row_index, one_boxed_row_flat_pixels in enumerate(pngdata):</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+        image_2d[row_index,:]=one_boxed_row_flat_pixels</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+del pngReader</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+del pngdata</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+''' Reconfigure for easier referencing, similar to</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+        Boxed row boxed pixel:</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+            list([ (R,G,B), (R,G,B), (R,G,B) ],</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+                 [ (R,G,B), (R,G,B), (R,G,B) ])</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+    Array dimensions for this example:  (2,3,3)</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+    ``image_3d`` will contain the image as a three-dimensional numpy</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+    array, having dimensions ``(row_count,column_count,plane_count)``.</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+'''</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineplus">+# --- extract 002 start</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineplus">+image_3d = numpy.reshape(image_2d,</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineplus">+                         (row_count,column_count,plane_count))</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineplus">+# --- extract 002 end</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineplus">+</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineplus">+</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineplus">+''' ============= '''</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineplus">+</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineplus">+''' Convert NumPy image_3d array to PNG image file.</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineplus">+</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineplus">+    If the data is three-dimensional, as it is above, the best thing</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineplus">+    to do is reshape it into a two-dimensional array with a shape of</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineplus">+    ``(row_count, column_count*plane_count)``.  Because a</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineplus">+    two-dimensional numpy array is an iterator, it can be passed</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineplus">+    directly to the ``png.Writer.write`` method.</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineplus">+'''</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineplus">+</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+row_count, column_count, plane_count = image_3d.shape</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+assert plane_count==3</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineplus">+pngfile = open('picture_out.png', 'wb')</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineplus">+try:</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineplus">+    # This example assumes that you have 16-bit pixel values in the data</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineplus">+    # array (that's what the ``bitdepth=16`` argument is for).</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineplus">+    # If you don't, then the resulting PNG file will likely be</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineplus">+    # very dark.  Hey, it's only an example.</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+    pngWriter = png.Writer(column_count, row_count,</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+                           greyscale=False,</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+                           alpha=False,</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineplus">+                           bitdepth=16)</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineplus">+    # As of 2009-04-13 passing a numpy array that has an element type</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineplus">+    # that is a numpy integer type (for example, the `image_3d` array has an</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+    # element type of ``numpy.uint16``) generates a deprecation warning.</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+    # This is probably a bug in numpy; it may go away in the future.</span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+    # The code still works despite the warning.</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+    # See http://code.google.com/p/pypng/issues/detail?id=44</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+# --- extract 003 start</span>
<a href="#l2.127"></a><span id="l2.127" class="difflineplus">+    pngWriter.write(pngfile,</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineplus">+                    numpy.reshape(image_3d, (-1, column_count*plane_count)))</span>
<a href="#l2.129"></a><span id="l2.129" class="difflineplus">+# --- extract 003 end</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineplus">+finally:</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineplus">+    pngfile.close()</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1">new file mode 100644</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineminus">--- /dev/null</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineplus">+++ b/build/pypng/iccp.py</span>
<a href="#l3.4"></a><span id="l3.4" class="difflineat">@@ -0,0 +1,537 @@</span>
<a href="#l3.5"></a><span id="l3.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l3.6"></a><span id="l3.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/iccp.py $</span>
<a href="#l3.7"></a><span id="l3.7" class="difflineplus">+# $Rev: 182 $</span>
<a href="#l3.8"></a><span id="l3.8" class="difflineplus">+</span>
<a href="#l3.9"></a><span id="l3.9" class="difflineplus">+# iccp</span>
<a href="#l3.10"></a><span id="l3.10" class="difflineplus">+#</span>
<a href="#l3.11"></a><span id="l3.11" class="difflineplus">+# International Color Consortium Profile</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+#</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+# Tools for manipulating ICC profiles.</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+#</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+# An ICC profile can be extracted from a PNG image (iCCP chunk).</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+#</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+#</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+# Non-standard ICCP tags.</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+#</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+# Apple use some (widespread but) non-standard tags.  These can be</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+# displayed in Apple's ColorSync Utility.</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+# - 'vcgt' (Video Card Gamma Tag).  Table to load into video</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+#    card LUT to apply gamma.</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+# - 'ndin' Apple display native information.</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+# - 'dscm' Apple multi-localized description strings.</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+# - 'mmod' Apple display make and model information.</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineplus">+# </span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+# References</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+#</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+# [ICC 2001] ICC Specification ICC.1:2001-04 (Profile version 2.4.0)</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+# [ICC 2004] ICC Specification ICC.1:2004-10 (Profile version 4.2.0.0)</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+import struct</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+import png</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+class FormatError(Exception):</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+    pass</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+class Profile:</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+    &quot;&quot;&quot;An International Color Consortium Profile (ICC Profile).&quot;&quot;&quot;</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+    def __init__(self):</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+        self.rawtagtable = None</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+        self.rawtagdict = {}</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+        self.d = dict()</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+    def fromFile(self, inp, name='&lt;unknown&gt;'):</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+        # See [ICC 2004]</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+        profile = inp.read(128)</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+        if len(profile) &lt; 128:</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+            raise FormatError(&quot;ICC Profile is too short.&quot;)</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+        size, = struct.unpack('&gt;L', profile[:4])</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+        profile += inp.read(d['size'] - len(profile))</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+        return self.fromString(profile, name)</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+    def fromString(self, profile, name='&lt;unknown&gt;'):</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+        self.d = dict()</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+        d = self.d</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+        if len(profile) &lt; 128:</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+            raise FormatError(&quot;ICC Profile is too short.&quot;)</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+        d.update(</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+          zip(['size', 'preferredCMM', 'version',</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+               'profileclass', 'colourspace', 'pcs'],</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+              struct.unpack('&gt;L4sL4s4s4s', profile[:24])))</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+        if len(profile) &lt; d['size']:</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+            warnings.warn(</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+              'Profile size declared to be %d, but only got %d bytes' %</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+                (d['size'], len(profile)))</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+        d['version'] = '%08x' % d['version']</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+        d['created'] = readICCdatetime(profile[24:36])</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+        d.update(</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+          zip(['acsp', 'platform', 'flag', 'manufacturer', 'model'],</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+              struct.unpack('&gt;4s4s3L', profile[36:56])))</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+        if d['acsp'] != 'acsp':</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+            warnings.warn('acsp field not present (not an ICC Profile?).')</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+        d['deviceattributes'] = profile[56:64]</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+        d['intent'], = struct.unpack('&gt;L', profile[64:68])</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+        d['pcsilluminant'] = readICCXYZNumber(profile[68:80])</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+        d['creator'] = profile[80:84]</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+        d['id'] = profile[84:100]</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+        ntags, = struct.unpack('&gt;L', profile[128:132])</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+        d['ntags'] = ntags</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineplus">+        fmt = '4s2L' * ntags</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineplus">+        # tag table</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+        tt = struct.unpack('&gt;' + fmt, profile[132:132+12*ntags])</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+        tt = group(tt, 3)</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+        # Could (should) detect 2 or more tags having the same sig.  But</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+        # we don't.  Two or more tags with the same sig is illegal per</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+        # the ICC spec.</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+        </span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+        # Convert (sig,offset,size) triples into (sig,value) pairs.</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+        rawtag = map(lambda x: (x[0], profile[x[1]:x[1]+x[2]]), tt)</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+        self.rawtagtable = rawtag</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+        self.rawtagdict = dict(rawtag)</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+        tag = dict()</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+        # Interpret the tags whose types we know about</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+        for sig, v in rawtag:</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+            if sig in tag:</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+                warnings.warn(&quot;Duplicate tag %r found.  Ignoring.&quot; % sig)</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+                continue</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+            v = ICCdecode(v)</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+            if v is not None:</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+                tag[sig] = v</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+        self.tag = tag</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+        return self</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineplus">+    def greyInput(self):</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineplus">+        &quot;&quot;&quot;Adjust ``self.d`` dictionary for greyscale input device.</span>
<a href="#l3.113"></a><span id="l3.113" class="difflineplus">+        ``profileclass`` is 'scnr', ``colourspace`` is 'GRAY', ``pcs``</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineplus">+        is 'XYZ '.</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineplus">+</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+        self.d.update(dict(profileclass='scnr',</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineplus">+          colourspace='GRAY', pcs='XYZ '))</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+        return self</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+    def maybeAddDefaults(self):</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineplus">+        if self.rawtagdict:</span>
<a href="#l3.123"></a><span id="l3.123" class="difflineplus">+            return</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineplus">+        self._addTags(</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineplus">+          cprt='Copyright unknown.',</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineplus">+          desc='created by $URL: http://pypng.googlecode.com/svn/trunk/code/iccp.py $ $Rev: 182 $',</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineplus">+          wtpt=D50(),</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineplus">+          )</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+    def addTags(self, **k):</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+        self.maybeAddDefaults()</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+        self._addTags(**k)</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineplus">+</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+    def _addTags(self, **k):</span>
<a href="#l3.135"></a><span id="l3.135" class="difflineplus">+        &quot;&quot;&quot;Helper for :meth:`addTags`.&quot;&quot;&quot;</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineplus">+</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineplus">+        for tag, thing in k.items():</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineplus">+            if not isinstance(thing, (tuple, list)):</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+                thing = (thing,)</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+            typetag = defaulttagtype[tag]</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineplus">+            self.rawtagdict[tag] = encode(typetag, *thing)</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineplus">+        return self</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineplus">+    def write(self, out):</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineplus">+        &quot;&quot;&quot;Write ICC Profile to the file.&quot;&quot;&quot;</span>
<a href="#l3.146"></a><span id="l3.146" class="difflineplus">+</span>
<a href="#l3.147"></a><span id="l3.147" class="difflineplus">+        if not self.rawtagtable:</span>
<a href="#l3.148"></a><span id="l3.148" class="difflineplus">+            self.rawtagtable = self.rawtagdict.items()</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineplus">+        tags = tagblock(self.rawtagtable)</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+        self.writeHeader(out, 128 + len(tags))</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+        out.write(tags)</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineplus">+        out.flush()</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineplus">+</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineplus">+        return self</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineplus">+</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineplus">+    def writeHeader(self, out, size=999):</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+        &quot;&quot;&quot;Add default values to the instance's `d` dictionary, then</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+        write a header out onto the file stream.  The size of the</span>
<a href="#l3.159"></a><span id="l3.159" class="difflineplus">+        profile must be specified using the `size` argument.</span>
<a href="#l3.160"></a><span id="l3.160" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l3.161"></a><span id="l3.161" class="difflineplus">+</span>
<a href="#l3.162"></a><span id="l3.162" class="difflineplus">+        def defaultkey(d, key, value):</span>
<a href="#l3.163"></a><span id="l3.163" class="difflineplus">+            &quot;&quot;&quot;Add ``[key]==value`` to the dictionary `d`, but only if</span>
<a href="#l3.164"></a><span id="l3.164" class="difflineplus">+            it does not have that key already.</span>
<a href="#l3.165"></a><span id="l3.165" class="difflineplus">+            &quot;&quot;&quot;</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineplus">+</span>
<a href="#l3.167"></a><span id="l3.167" class="difflineplus">+            if key in d:</span>
<a href="#l3.168"></a><span id="l3.168" class="difflineplus">+                return</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineplus">+            d[key] = value</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineplus">+        z = '\x00' * 4</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+        defaults = dict(preferredCMM=z,</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+                        version='02000000',</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineplus">+                        profileclass=z,</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineplus">+                        colourspace=z,</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineplus">+                        pcs='XYZ ',</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+                        created=writeICCdatetime(),</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+                        acsp='acsp',</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineplus">+                        platform=z,</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineplus">+                        flag=0,</span>
<a href="#l3.181"></a><span id="l3.181" class="difflineplus">+                        manufacturer=z,</span>
<a href="#l3.182"></a><span id="l3.182" class="difflineplus">+                        model=0,</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineplus">+                        deviceattributes=0,</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineplus">+                        intent=0,</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineplus">+                        pcsilluminant=encodefuns()['XYZ'](*D50()),</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineplus">+                        creator=z,</span>
<a href="#l3.187"></a><span id="l3.187" class="difflineplus">+                        )</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineplus">+        for k,v in defaults.items():</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineplus">+            defaultkey(self.d, k, v)</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineplus">+</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineplus">+        hl = map(self.d.__getitem__,</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+                 ['preferredCMM', 'version', 'profileclass', 'colourspace',</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineplus">+                  'pcs', 'created', 'acsp', 'platform', 'flag',</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+                  'manufacturer', 'model', 'deviceattributes', 'intent',</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+                  'pcsilluminant', 'creator'])</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+        # Convert to struct.pack input</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+        hl[1] = int(hl[1], 16)</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+        out.write(struct.pack('&gt;L4sL4s4s4s12s4s4sL4sLQL12s4s', size, *hl))</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+        out.write('\x00' * 44)</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+        return self</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+def encodefuns():</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+    &quot;&quot;&quot;Returns a dictionary mapping ICC type signature sig to encoding</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineplus">+    function.  Each function returns a string comprising the content of</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineplus">+    the encoded value.  To form the full value, the type sig and the 4</span>
<a href="#l3.207"></a><span id="l3.207" class="difflineplus">+    zero bytes should be prefixed (8 bytes).</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+    def desc(ascii):</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+        &quot;&quot;&quot;Return textDescription type [ICC 2001] 6.5.17.  The ASCII part is</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+        filled in with the string `ascii`, the Unicode and ScriptCode parts</span>
<a href="#l3.213"></a><span id="l3.213" class="difflineplus">+        are empty.&quot;&quot;&quot;</span>
<a href="#l3.214"></a><span id="l3.214" class="difflineplus">+</span>
<a href="#l3.215"></a><span id="l3.215" class="difflineplus">+        ascii += '\x00'</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+        l = len(ascii)</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+        return struct.pack('&gt;L%ds2LHB67s' % l,</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineplus">+                           l, ascii, 0, 0, 0, 0, '')</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+</span>
<a href="#l3.221"></a><span id="l3.221" class="difflineplus">+    def text(ascii):</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+        &quot;&quot;&quot;Return textType [ICC 2001] 6.5.18.&quot;&quot;&quot;</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineplus">+</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineplus">+        return ascii + '\x00'</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineplus">+</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineplus">+    def curv(f=None, n=256):</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineplus">+        &quot;&quot;&quot;Return a curveType, [ICC 2001] 6.5.3.  If no arguments are</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineplus">+        supplied then a TRC for a linear response is generated (no entries).</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineplus">+        If an argument is supplied and it is a number (for *f* to be a</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineplus">+        number it  means that ``float(f)==f``) then a TRC for that</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineplus">+        gamma value is generated.</span>
<a href="#l3.232"></a><span id="l3.232" class="difflineplus">+        Otherwise `f` is assumed to be a function that maps [0.0, 1.0] to</span>
<a href="#l3.233"></a><span id="l3.233" class="difflineplus">+        [0.0, 1.0]; an `n` element table is generated for it.</span>
<a href="#l3.234"></a><span id="l3.234" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l3.235"></a><span id="l3.235" class="difflineplus">+</span>
<a href="#l3.236"></a><span id="l3.236" class="difflineplus">+        if f is None:</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineplus">+            return struct.pack('&gt;L',  0)</span>
<a href="#l3.238"></a><span id="l3.238" class="difflineplus">+        try:</span>
<a href="#l3.239"></a><span id="l3.239" class="difflineplus">+            if float(f) == f:</span>
<a href="#l3.240"></a><span id="l3.240" class="difflineplus">+                return struct.pack('&gt;LH', 1, int(round(f*2**8)))</span>
<a href="#l3.241"></a><span id="l3.241" class="difflineplus">+        except (TypeError, ValueError):</span>
<a href="#l3.242"></a><span id="l3.242" class="difflineplus">+            pass</span>
<a href="#l3.243"></a><span id="l3.243" class="difflineplus">+        assert n &gt;= 2</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineplus">+        table = []</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineplus">+        M = float(n-1)</span>
<a href="#l3.246"></a><span id="l3.246" class="difflineplus">+        for i in range(n):</span>
<a href="#l3.247"></a><span id="l3.247" class="difflineplus">+            x = i/M</span>
<a href="#l3.248"></a><span id="l3.248" class="difflineplus">+            table.append(int(round(f(x) * 65535)))</span>
<a href="#l3.249"></a><span id="l3.249" class="difflineplus">+        return struct.pack('&gt;L%dH' % n, n, *table)</span>
<a href="#l3.250"></a><span id="l3.250" class="difflineplus">+</span>
<a href="#l3.251"></a><span id="l3.251" class="difflineplus">+    def XYZ(*l):</span>
<a href="#l3.252"></a><span id="l3.252" class="difflineplus">+        return struct.pack('&gt;3l', *map(fs15f16, l))</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineplus">+</span>
<a href="#l3.254"></a><span id="l3.254" class="difflineplus">+    return locals()</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineplus">+</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineplus">+# Tag type defaults.</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineplus">+# Most tags can only have one or a few tag types.</span>
<a href="#l3.258"></a><span id="l3.258" class="difflineplus">+# When encoding, we associate a default tag type with each tag so that</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineplus">+# the encoding is implicit.</span>
<a href="#l3.260"></a><span id="l3.260" class="difflineplus">+defaulttagtype=dict(</span>
<a href="#l3.261"></a><span id="l3.261" class="difflineplus">+  A2B0='mft1',</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineplus">+  A2B1='mft1',</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineplus">+  A2B2='mft1',</span>
<a href="#l3.264"></a><span id="l3.264" class="difflineplus">+  bXYZ='XYZ',</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineplus">+  bTRC='curv',</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineplus">+  B2A0='mft1',</span>
<a href="#l3.267"></a><span id="l3.267" class="difflineplus">+  B2A1='mft1',</span>
<a href="#l3.268"></a><span id="l3.268" class="difflineplus">+  B2A2='mft1',</span>
<a href="#l3.269"></a><span id="l3.269" class="difflineplus">+  calt='dtim',</span>
<a href="#l3.270"></a><span id="l3.270" class="difflineplus">+  targ='text',</span>
<a href="#l3.271"></a><span id="l3.271" class="difflineplus">+  chad='sf32',</span>
<a href="#l3.272"></a><span id="l3.272" class="difflineplus">+  chrm='chrm',</span>
<a href="#l3.273"></a><span id="l3.273" class="difflineplus">+  cprt='desc',</span>
<a href="#l3.274"></a><span id="l3.274" class="difflineplus">+  crdi='crdi',</span>
<a href="#l3.275"></a><span id="l3.275" class="difflineplus">+  dmnd='desc',</span>
<a href="#l3.276"></a><span id="l3.276" class="difflineplus">+  dmdd='desc',</span>
<a href="#l3.277"></a><span id="l3.277" class="difflineplus">+  devs='',</span>
<a href="#l3.278"></a><span id="l3.278" class="difflineplus">+  gamt='mft1',</span>
<a href="#l3.279"></a><span id="l3.279" class="difflineplus">+  kTRC='curv',</span>
<a href="#l3.280"></a><span id="l3.280" class="difflineplus">+  gXYZ='XYZ',</span>
<a href="#l3.281"></a><span id="l3.281" class="difflineplus">+  gTRC='curv',</span>
<a href="#l3.282"></a><span id="l3.282" class="difflineplus">+  lumi='XYZ',</span>
<a href="#l3.283"></a><span id="l3.283" class="difflineplus">+  meas='',</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineplus">+  bkpt='XYZ',</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineplus">+  wtpt='XYZ',</span>
<a href="#l3.286"></a><span id="l3.286" class="difflineplus">+  ncol='',</span>
<a href="#l3.287"></a><span id="l3.287" class="difflineplus">+  ncl2='',</span>
<a href="#l3.288"></a><span id="l3.288" class="difflineplus">+  resp='',</span>
<a href="#l3.289"></a><span id="l3.289" class="difflineplus">+  pre0='mft1',</span>
<a href="#l3.290"></a><span id="l3.290" class="difflineplus">+  pre1='mft1',</span>
<a href="#l3.291"></a><span id="l3.291" class="difflineplus">+  pre2='mft1',</span>
<a href="#l3.292"></a><span id="l3.292" class="difflineplus">+  desc='desc',</span>
<a href="#l3.293"></a><span id="l3.293" class="difflineplus">+  pseq='',</span>
<a href="#l3.294"></a><span id="l3.294" class="difflineplus">+  psd0='data',</span>
<a href="#l3.295"></a><span id="l3.295" class="difflineplus">+  psd1='data',</span>
<a href="#l3.296"></a><span id="l3.296" class="difflineplus">+  psd2='data',</span>
<a href="#l3.297"></a><span id="l3.297" class="difflineplus">+  psd3='data',</span>
<a href="#l3.298"></a><span id="l3.298" class="difflineplus">+  ps2s='data',</span>
<a href="#l3.299"></a><span id="l3.299" class="difflineplus">+  ps2i='data',</span>
<a href="#l3.300"></a><span id="l3.300" class="difflineplus">+  rXYZ='XYZ',</span>
<a href="#l3.301"></a><span id="l3.301" class="difflineplus">+  rTRC='curv',</span>
<a href="#l3.302"></a><span id="l3.302" class="difflineplus">+  scrd='desc',</span>
<a href="#l3.303"></a><span id="l3.303" class="difflineplus">+  scrn='',</span>
<a href="#l3.304"></a><span id="l3.304" class="difflineplus">+  tech='sig',</span>
<a href="#l3.305"></a><span id="l3.305" class="difflineplus">+  bfd='',</span>
<a href="#l3.306"></a><span id="l3.306" class="difflineplus">+  vued='desc',</span>
<a href="#l3.307"></a><span id="l3.307" class="difflineplus">+  view='view',</span>
<a href="#l3.308"></a><span id="l3.308" class="difflineplus">+)</span>
<a href="#l3.309"></a><span id="l3.309" class="difflineplus">+</span>
<a href="#l3.310"></a><span id="l3.310" class="difflineplus">+def encode(tsig, *l):</span>
<a href="#l3.311"></a><span id="l3.311" class="difflineplus">+    &quot;&quot;&quot;Encode a Python value as an ICC type.  `tsig` is the type</span>
<a href="#l3.312"></a><span id="l3.312" class="difflineplus">+    signature to (the first 4 bytes of the encoded value, see [ICC 2004]</span>
<a href="#l3.313"></a><span id="l3.313" class="difflineplus">+    section 10.</span>
<a href="#l3.314"></a><span id="l3.314" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l3.315"></a><span id="l3.315" class="difflineplus">+</span>
<a href="#l3.316"></a><span id="l3.316" class="difflineplus">+    fun = encodefuns()</span>
<a href="#l3.317"></a><span id="l3.317" class="difflineplus">+    if tsig not in fun:</span>
<a href="#l3.318"></a><span id="l3.318" class="difflineplus">+        raise &quot;No encoder for type %r.&quot; % tsig</span>
<a href="#l3.319"></a><span id="l3.319" class="difflineplus">+    v = fun[tsig](*l)</span>
<a href="#l3.320"></a><span id="l3.320" class="difflineplus">+    # Padd tsig out with spaces.</span>
<a href="#l3.321"></a><span id="l3.321" class="difflineplus">+    tsig = (tsig + '   ')[:4]</span>
<a href="#l3.322"></a><span id="l3.322" class="difflineplus">+    return tsig + '\x00'*4 + v</span>
<a href="#l3.323"></a><span id="l3.323" class="difflineplus">+</span>
<a href="#l3.324"></a><span id="l3.324" class="difflineplus">+def tagblock(tag):</span>
<a href="#l3.325"></a><span id="l3.325" class="difflineplus">+    &quot;&quot;&quot;`tag` should be a list of (*signature*, *element*) pairs, where</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineplus">+    *signature* (the key) is a length 4 string, and *element* is the</span>
<a href="#l3.327"></a><span id="l3.327" class="difflineplus">+    content of the tag element (another string).</span>
<a href="#l3.328"></a><span id="l3.328" class="difflineplus">+    </span>
<a href="#l3.329"></a><span id="l3.329" class="difflineplus">+    The entire tag block (consisting of first a table and then the</span>
<a href="#l3.330"></a><span id="l3.330" class="difflineplus">+    element data) is constructed and returned as a string.</span>
<a href="#l3.331"></a><span id="l3.331" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l3.332"></a><span id="l3.332" class="difflineplus">+</span>
<a href="#l3.333"></a><span id="l3.333" class="difflineplus">+    n = len(tag)</span>
<a href="#l3.334"></a><span id="l3.334" class="difflineplus">+    tablelen = 12*n</span>
<a href="#l3.335"></a><span id="l3.335" class="difflineplus">+</span>
<a href="#l3.336"></a><span id="l3.336" class="difflineplus">+    # Build the tag table in two parts.  A list of 12-byte tags, and a</span>
<a href="#l3.337"></a><span id="l3.337" class="difflineplus">+    # string of element data.  Offset is the offset from the start of</span>
<a href="#l3.338"></a><span id="l3.338" class="difflineplus">+    # the profile to the start of the element data (so the offset for</span>
<a href="#l3.339"></a><span id="l3.339" class="difflineplus">+    # the next element is this offset plus the length of the element</span>
<a href="#l3.340"></a><span id="l3.340" class="difflineplus">+    # string so far).</span>
<a href="#l3.341"></a><span id="l3.341" class="difflineplus">+    offset = 128 + tablelen + 4</span>
<a href="#l3.342"></a><span id="l3.342" class="difflineplus">+    # The table.  As a string.</span>
<a href="#l3.343"></a><span id="l3.343" class="difflineplus">+    table = ''</span>
<a href="#l3.344"></a><span id="l3.344" class="difflineplus">+    # The element data</span>
<a href="#l3.345"></a><span id="l3.345" class="difflineplus">+    element = ''</span>
<a href="#l3.346"></a><span id="l3.346" class="difflineplus">+    for k,v in tag:</span>
<a href="#l3.347"></a><span id="l3.347" class="difflineplus">+        table += struct.pack('&gt;4s2L', k, offset + len(element), len(v))</span>
<a href="#l3.348"></a><span id="l3.348" class="difflineplus">+        element += v</span>
<a href="#l3.349"></a><span id="l3.349" class="difflineplus">+    return struct.pack('&gt;L', n) + table + element</span>
<a href="#l3.350"></a><span id="l3.350" class="difflineplus">+</span>
<a href="#l3.351"></a><span id="l3.351" class="difflineplus">+def iccp(out, inp):</span>
<a href="#l3.352"></a><span id="l3.352" class="difflineplus">+    profile = Profile().fromString(*profileFromPNG(inp))</span>
<a href="#l3.353"></a><span id="l3.353" class="difflineplus">+    print &gt;&gt;out, profile.d</span>
<a href="#l3.354"></a><span id="l3.354" class="difflineplus">+    print &gt;&gt;out, map(lambda x: x[0], profile.rawtagtable)</span>
<a href="#l3.355"></a><span id="l3.355" class="difflineplus">+    print &gt;&gt;out, profile.tag</span>
<a href="#l3.356"></a><span id="l3.356" class="difflineplus">+</span>
<a href="#l3.357"></a><span id="l3.357" class="difflineplus">+def profileFromPNG(inp):</span>
<a href="#l3.358"></a><span id="l3.358" class="difflineplus">+    &quot;&quot;&quot;Extract profile from PNG file.  Return (*profile*, *name*)</span>
<a href="#l3.359"></a><span id="l3.359" class="difflineplus">+    pair.&quot;&quot;&quot;</span>
<a href="#l3.360"></a><span id="l3.360" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l3.361"></a><span id="l3.361" class="difflineplus">+    _,chunk = r.chunk('iCCP')</span>
<a href="#l3.362"></a><span id="l3.362" class="difflineplus">+    i = chunk.index('\x00')</span>
<a href="#l3.363"></a><span id="l3.363" class="difflineplus">+    name = chunk[:i]</span>
<a href="#l3.364"></a><span id="l3.364" class="difflineplus">+    compression = chunk[i+1]</span>
<a href="#l3.365"></a><span id="l3.365" class="difflineplus">+    assert compression == chr(0)</span>
<a href="#l3.366"></a><span id="l3.366" class="difflineplus">+    profile = chunk[i+2:].decode('zlib')</span>
<a href="#l3.367"></a><span id="l3.367" class="difflineplus">+    return profile, name</span>
<a href="#l3.368"></a><span id="l3.368" class="difflineplus">+</span>
<a href="#l3.369"></a><span id="l3.369" class="difflineplus">+def iccpout(out, inp):</span>
<a href="#l3.370"></a><span id="l3.370" class="difflineplus">+    &quot;&quot;&quot;Extract ICC Profile from PNG file `inp` and write it to</span>
<a href="#l3.371"></a><span id="l3.371" class="difflineplus">+    the file `out`.&quot;&quot;&quot;</span>
<a href="#l3.372"></a><span id="l3.372" class="difflineplus">+</span>
<a href="#l3.373"></a><span id="l3.373" class="difflineplus">+    out.write(profileFromPNG(inp)[0])</span>
<a href="#l3.374"></a><span id="l3.374" class="difflineplus">+</span>
<a href="#l3.375"></a><span id="l3.375" class="difflineplus">+def fs15f16(x):</span>
<a href="#l3.376"></a><span id="l3.376" class="difflineplus">+    &quot;&quot;&quot;Convert float to ICC s15Fixed16Number (as a Python ``int``).&quot;&quot;&quot;</span>
<a href="#l3.377"></a><span id="l3.377" class="difflineplus">+</span>
<a href="#l3.378"></a><span id="l3.378" class="difflineplus">+    return int(round(x * 2**16))</span>
<a href="#l3.379"></a><span id="l3.379" class="difflineplus">+</span>
<a href="#l3.380"></a><span id="l3.380" class="difflineplus">+def D50():</span>
<a href="#l3.381"></a><span id="l3.381" class="difflineplus">+    &quot;&quot;&quot;Return D50 illuminant as an (X,Y,Z) triple.&quot;&quot;&quot;</span>
<a href="#l3.382"></a><span id="l3.382" class="difflineplus">+</span>
<a href="#l3.383"></a><span id="l3.383" class="difflineplus">+    # See [ICC 2001] A.1</span>
<a href="#l3.384"></a><span id="l3.384" class="difflineplus">+    return (0.9642, 1.0000, 0.8249)</span>
<a href="#l3.385"></a><span id="l3.385" class="difflineplus">+</span>
<a href="#l3.386"></a><span id="l3.386" class="difflineplus">+</span>
<a href="#l3.387"></a><span id="l3.387" class="difflineplus">+def writeICCdatetime(t=None):</span>
<a href="#l3.388"></a><span id="l3.388" class="difflineplus">+    &quot;&quot;&quot;`t` should be a gmtime tuple (as returned from</span>
<a href="#l3.389"></a><span id="l3.389" class="difflineplus">+    ``time.gmtime()``).  If not supplied, the current time will be used.</span>
<a href="#l3.390"></a><span id="l3.390" class="difflineplus">+    Return an ICC dateTimeNumber in a 12 byte string.</span>
<a href="#l3.391"></a><span id="l3.391" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l3.392"></a><span id="l3.392" class="difflineplus">+</span>
<a href="#l3.393"></a><span id="l3.393" class="difflineplus">+    import time</span>
<a href="#l3.394"></a><span id="l3.394" class="difflineplus">+    if t is None:</span>
<a href="#l3.395"></a><span id="l3.395" class="difflineplus">+        t = time.gmtime()</span>
<a href="#l3.396"></a><span id="l3.396" class="difflineplus">+    return struct.pack('&gt;6H', *t[:6])</span>
<a href="#l3.397"></a><span id="l3.397" class="difflineplus">+</span>
<a href="#l3.398"></a><span id="l3.398" class="difflineplus">+def readICCdatetime(s):</span>
<a href="#l3.399"></a><span id="l3.399" class="difflineplus">+    &quot;&quot;&quot;Convert from 12 byte ICC representation of dateTimeNumber to</span>
<a href="#l3.400"></a><span id="l3.400" class="difflineplus">+    ISO8601 string. See [ICC 2004] 5.1.1&quot;&quot;&quot;</span>
<a href="#l3.401"></a><span id="l3.401" class="difflineplus">+</span>
<a href="#l3.402"></a><span id="l3.402" class="difflineplus">+    return '%04d-%02d-%02dT%02d:%02d:%02dZ' % struct.unpack('&gt;6H', s)</span>
<a href="#l3.403"></a><span id="l3.403" class="difflineplus">+</span>
<a href="#l3.404"></a><span id="l3.404" class="difflineplus">+def readICCXYZNumber(s):</span>
<a href="#l3.405"></a><span id="l3.405" class="difflineplus">+    &quot;&quot;&quot;Convert from 12 byte ICC representation of XYZNumber to (x,y,z)</span>
<a href="#l3.406"></a><span id="l3.406" class="difflineplus">+    triple of floats.  See [ICC 2004] 5.1.11&quot;&quot;&quot;</span>
<a href="#l3.407"></a><span id="l3.407" class="difflineplus">+</span>
<a href="#l3.408"></a><span id="l3.408" class="difflineplus">+    return s15f16l(s)</span>
<a href="#l3.409"></a><span id="l3.409" class="difflineplus">+</span>
<a href="#l3.410"></a><span id="l3.410" class="difflineplus">+def s15f16l(s):</span>
<a href="#l3.411"></a><span id="l3.411" class="difflineplus">+    &quot;&quot;&quot;Convert sequence of ICC s15Fixed16 to list of float.&quot;&quot;&quot;</span>
<a href="#l3.412"></a><span id="l3.412" class="difflineplus">+    # Note: As long as float has at least 32 bits of mantissa, all</span>
<a href="#l3.413"></a><span id="l3.413" class="difflineplus">+    # values are preserved.</span>
<a href="#l3.414"></a><span id="l3.414" class="difflineplus">+    n = len(s)//4</span>
<a href="#l3.415"></a><span id="l3.415" class="difflineplus">+    t = struct.unpack('&gt;%dl' % n, s)</span>
<a href="#l3.416"></a><span id="l3.416" class="difflineplus">+    return map((2**-16).__mul__, t)</span>
<a href="#l3.417"></a><span id="l3.417" class="difflineplus">+</span>
<a href="#l3.418"></a><span id="l3.418" class="difflineplus">+# Several types and their byte encodings are defined by [ICC 2004]</span>
<a href="#l3.419"></a><span id="l3.419" class="difflineplus">+# section 10.  When encoded, a value begins with a 4 byte type</span>
<a href="#l3.420"></a><span id="l3.420" class="difflineplus">+# signature.  We use the same 4 byte type signature in the names of the</span>
<a href="#l3.421"></a><span id="l3.421" class="difflineplus">+# Python functions that decode the type into a Pythonic representation.</span>
<a href="#l3.422"></a><span id="l3.422" class="difflineplus">+</span>
<a href="#l3.423"></a><span id="l3.423" class="difflineplus">+def ICCdecode(s):</span>
<a href="#l3.424"></a><span id="l3.424" class="difflineplus">+    &quot;&quot;&quot;Take an ICC encoded tag, and dispatch on its type signature</span>
<a href="#l3.425"></a><span id="l3.425" class="difflineplus">+    (first 4 bytes) to decode it into a Python value.  Pair (*sig*,</span>
<a href="#l3.426"></a><span id="l3.426" class="difflineplus">+    *value*) is returned, where *sig* is a 4 byte string, and *value* is</span>
<a href="#l3.427"></a><span id="l3.427" class="difflineplus">+    some Python value determined by the content and type.</span>
<a href="#l3.428"></a><span id="l3.428" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l3.429"></a><span id="l3.429" class="difflineplus">+</span>
<a href="#l3.430"></a><span id="l3.430" class="difflineplus">+    sig = s[0:4].strip()</span>
<a href="#l3.431"></a><span id="l3.431" class="difflineplus">+    f=dict(text=RDtext,</span>
<a href="#l3.432"></a><span id="l3.432" class="difflineplus">+           XYZ=RDXYZ,</span>
<a href="#l3.433"></a><span id="l3.433" class="difflineplus">+           curv=RDcurv,</span>
<a href="#l3.434"></a><span id="l3.434" class="difflineplus">+           vcgt=RDvcgt,</span>
<a href="#l3.435"></a><span id="l3.435" class="difflineplus">+           sf32=RDsf32,</span>
<a href="#l3.436"></a><span id="l3.436" class="difflineplus">+           )</span>
<a href="#l3.437"></a><span id="l3.437" class="difflineplus">+    if sig not in f:</span>
<a href="#l3.438"></a><span id="l3.438" class="difflineplus">+        return None</span>
<a href="#l3.439"></a><span id="l3.439" class="difflineplus">+    return (sig, f[sig](s))</span>
<a href="#l3.440"></a><span id="l3.440" class="difflineplus">+</span>
<a href="#l3.441"></a><span id="l3.441" class="difflineplus">+def RDXYZ(s):</span>
<a href="#l3.442"></a><span id="l3.442" class="difflineplus">+    &quot;&quot;&quot;Convert ICC XYZType to rank 1 array of trimulus values.&quot;&quot;&quot;</span>
<a href="#l3.443"></a><span id="l3.443" class="difflineplus">+</span>
<a href="#l3.444"></a><span id="l3.444" class="difflineplus">+    # See [ICC 2001] 6.5.26</span>
<a href="#l3.445"></a><span id="l3.445" class="difflineplus">+    assert s[0:4] == 'XYZ '</span>
<a href="#l3.446"></a><span id="l3.446" class="difflineplus">+    return readICCXYZNumber(s[8:])</span>
<a href="#l3.447"></a><span id="l3.447" class="difflineplus">+</span>
<a href="#l3.448"></a><span id="l3.448" class="difflineplus">+def RDsf32(s):</span>
<a href="#l3.449"></a><span id="l3.449" class="difflineplus">+    &quot;&quot;&quot;Convert ICC s15Fixed16ArrayType to list of float.&quot;&quot;&quot;</span>
<a href="#l3.450"></a><span id="l3.450" class="difflineplus">+    # See [ICC 2004] 10.18</span>
<a href="#l3.451"></a><span id="l3.451" class="difflineplus">+    assert s[0:4] == 'sf32'</span>
<a href="#l3.452"></a><span id="l3.452" class="difflineplus">+    return s15f16l(s[8:])</span>
<a href="#l3.453"></a><span id="l3.453" class="difflineplus">+</span>
<a href="#l3.454"></a><span id="l3.454" class="difflineplus">+def RDmluc(s):</span>
<a href="#l3.455"></a><span id="l3.455" class="difflineplus">+    &quot;&quot;&quot;Convert ICC multiLocalizedUnicodeType.  This types encodes</span>
<a href="#l3.456"></a><span id="l3.456" class="difflineplus">+    several strings together with a language/country code for each</span>
<a href="#l3.457"></a><span id="l3.457" class="difflineplus">+    string.  A list of (*lc*, *string*) pairs is returned where *lc* is</span>
<a href="#l3.458"></a><span id="l3.458" class="difflineplus">+    the 4 byte language/country code, and *string* is the string</span>
<a href="#l3.459"></a><span id="l3.459" class="difflineplus">+    corresponding to that code.  It seems unlikely that the same</span>
<a href="#l3.460"></a><span id="l3.460" class="difflineplus">+    language/country code will appear more than once with different</span>
<a href="#l3.461"></a><span id="l3.461" class="difflineplus">+    strings, but the ICC standard does not prohibit it.&quot;&quot;&quot;</span>
<a href="#l3.462"></a><span id="l3.462" class="difflineplus">+    # See [ICC 2004] 10.13</span>
<a href="#l3.463"></a><span id="l3.463" class="difflineplus">+    assert s[0:4] == 'mluc'</span>
<a href="#l3.464"></a><span id="l3.464" class="difflineplus">+    n,sz = struct.unpack('&gt;2L', s[8:16])</span>
<a href="#l3.465"></a><span id="l3.465" class="difflineplus">+    assert sz == 12</span>
<a href="#l3.466"></a><span id="l3.466" class="difflineplus">+    record = []</span>
<a href="#l3.467"></a><span id="l3.467" class="difflineplus">+    for i in range(n):</span>
<a href="#l3.468"></a><span id="l3.468" class="difflineplus">+        lc,l,o = struct.unpack('4s2L', s[16+12*n:28+12*n])</span>
<a href="#l3.469"></a><span id="l3.469" class="difflineplus">+        record.append(lc, s[o:o+l])</span>
<a href="#l3.470"></a><span id="l3.470" class="difflineplus">+    # How are strings encoded?</span>
<a href="#l3.471"></a><span id="l3.471" class="difflineplus">+    return record</span>
<a href="#l3.472"></a><span id="l3.472" class="difflineplus">+</span>
<a href="#l3.473"></a><span id="l3.473" class="difflineplus">+def RDtext(s):</span>
<a href="#l3.474"></a><span id="l3.474" class="difflineplus">+    &quot;&quot;&quot;Convert ICC textType to Python string.&quot;&quot;&quot;</span>
<a href="#l3.475"></a><span id="l3.475" class="difflineplus">+    # Note: type not specified or used in [ICC 2004], only in older</span>
<a href="#l3.476"></a><span id="l3.476" class="difflineplus">+    # [ICC 2001].</span>
<a href="#l3.477"></a><span id="l3.477" class="difflineplus">+    # See [ICC 2001] 6.5.18</span>
<a href="#l3.478"></a><span id="l3.478" class="difflineplus">+    assert s[0:4] == 'text'</span>
<a href="#l3.479"></a><span id="l3.479" class="difflineplus">+    return s[8:-1]</span>
<a href="#l3.480"></a><span id="l3.480" class="difflineplus">+</span>
<a href="#l3.481"></a><span id="l3.481" class="difflineplus">+def RDcurv(s):</span>
<a href="#l3.482"></a><span id="l3.482" class="difflineplus">+    &quot;&quot;&quot;Convert ICC curveType.&quot;&quot;&quot;</span>
<a href="#l3.483"></a><span id="l3.483" class="difflineplus">+    # See [ICC 2001] 6.5.3</span>
<a href="#l3.484"></a><span id="l3.484" class="difflineplus">+    assert s[0:4] == 'curv'</span>
<a href="#l3.485"></a><span id="l3.485" class="difflineplus">+    count, = struct.unpack('&gt;L', s[8:12])</span>
<a href="#l3.486"></a><span id="l3.486" class="difflineplus">+    if count == 0:</span>
<a href="#l3.487"></a><span id="l3.487" class="difflineplus">+        return dict(gamma=1)</span>
<a href="#l3.488"></a><span id="l3.488" class="difflineplus">+    table = struct.unpack('&gt;%dH' % count, s[12:])</span>
<a href="#l3.489"></a><span id="l3.489" class="difflineplus">+    if count == 1:</span>
<a href="#l3.490"></a><span id="l3.490" class="difflineplus">+        return dict(gamma=table[0]*2**-8)</span>
<a href="#l3.491"></a><span id="l3.491" class="difflineplus">+    return table</span>
<a href="#l3.492"></a><span id="l3.492" class="difflineplus">+</span>
<a href="#l3.493"></a><span id="l3.493" class="difflineplus">+def RDvcgt(s):</span>
<a href="#l3.494"></a><span id="l3.494" class="difflineplus">+    &quot;&quot;&quot;Convert Apple CMVideoCardGammaType.&quot;&quot;&quot;</span>
<a href="#l3.495"></a><span id="l3.495" class="difflineplus">+    # See</span>
<a href="#l3.496"></a><span id="l3.496" class="difflineplus">+    # http://developer.apple.com/documentation/GraphicsImaging/Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/c/tdef/CMVideoCardGammaType</span>
<a href="#l3.497"></a><span id="l3.497" class="difflineplus">+    assert s[0:4] == 'vcgt'</span>
<a href="#l3.498"></a><span id="l3.498" class="difflineplus">+    tagtype, = struct.unpack('&gt;L', s[8:12])</span>
<a href="#l3.499"></a><span id="l3.499" class="difflineplus">+    if tagtype != 0:</span>
<a href="#l3.500"></a><span id="l3.500" class="difflineplus">+        return s[8:]</span>
<a href="#l3.501"></a><span id="l3.501" class="difflineplus">+    if tagtype == 0:</span>
<a href="#l3.502"></a><span id="l3.502" class="difflineplus">+        # Table.</span>
<a href="#l3.503"></a><span id="l3.503" class="difflineplus">+        channels,count,size = struct.unpack('&gt;3H', s[12:18])</span>
<a href="#l3.504"></a><span id="l3.504" class="difflineplus">+        if size == 1:</span>
<a href="#l3.505"></a><span id="l3.505" class="difflineplus">+            fmt = 'B'</span>
<a href="#l3.506"></a><span id="l3.506" class="difflineplus">+        elif size == 2:</span>
<a href="#l3.507"></a><span id="l3.507" class="difflineplus">+            fmt = 'H'</span>
<a href="#l3.508"></a><span id="l3.508" class="difflineplus">+        else:</span>
<a href="#l3.509"></a><span id="l3.509" class="difflineplus">+            return s[8:]</span>
<a href="#l3.510"></a><span id="l3.510" class="difflineplus">+        l = len(s[18:])//size</span>
<a href="#l3.511"></a><span id="l3.511" class="difflineplus">+        t = struct.unpack('&gt;%d%s' % (l, fmt), s[18:])</span>
<a href="#l3.512"></a><span id="l3.512" class="difflineplus">+        t = group(t, count)</span>
<a href="#l3.513"></a><span id="l3.513" class="difflineplus">+        return size, t</span>
<a href="#l3.514"></a><span id="l3.514" class="difflineplus">+    return s[8:]</span>
<a href="#l3.515"></a><span id="l3.515" class="difflineplus">+</span>
<a href="#l3.516"></a><span id="l3.516" class="difflineplus">+</span>
<a href="#l3.517"></a><span id="l3.517" class="difflineplus">+def group(s, n):</span>
<a href="#l3.518"></a><span id="l3.518" class="difflineplus">+    # See</span>
<a href="#l3.519"></a><span id="l3.519" class="difflineplus">+    # http://www.python.org/doc/2.6/library/functions.html#zip</span>
<a href="#l3.520"></a><span id="l3.520" class="difflineplus">+    return zip(*[iter(s)]*n)</span>
<a href="#l3.521"></a><span id="l3.521" class="difflineplus">+</span>
<a href="#l3.522"></a><span id="l3.522" class="difflineplus">+</span>
<a href="#l3.523"></a><span id="l3.523" class="difflineplus">+def main(argv=None):</span>
<a href="#l3.524"></a><span id="l3.524" class="difflineplus">+    import sys</span>
<a href="#l3.525"></a><span id="l3.525" class="difflineplus">+    from getopt import getopt</span>
<a href="#l3.526"></a><span id="l3.526" class="difflineplus">+    if argv is None:</span>
<a href="#l3.527"></a><span id="l3.527" class="difflineplus">+        argv = sys.argv</span>
<a href="#l3.528"></a><span id="l3.528" class="difflineplus">+    argv = argv[1:]</span>
<a href="#l3.529"></a><span id="l3.529" class="difflineplus">+    opt,arg = getopt(argv, 'o:')</span>
<a href="#l3.530"></a><span id="l3.530" class="difflineplus">+    if len(arg) &gt; 0:</span>
<a href="#l3.531"></a><span id="l3.531" class="difflineplus">+        inp = open(arg[0], 'rb')</span>
<a href="#l3.532"></a><span id="l3.532" class="difflineplus">+    else:</span>
<a href="#l3.533"></a><span id="l3.533" class="difflineplus">+        inp = sys.stdin</span>
<a href="#l3.534"></a><span id="l3.534" class="difflineplus">+    for o,v in opt:</span>
<a href="#l3.535"></a><span id="l3.535" class="difflineplus">+        if o == '-o':</span>
<a href="#l3.536"></a><span id="l3.536" class="difflineplus">+            f = open(v, 'wb')</span>
<a href="#l3.537"></a><span id="l3.537" class="difflineplus">+            return iccpout(f, inp)</span>
<a href="#l3.538"></a><span id="l3.538" class="difflineplus">+    return iccp(sys.stdout, inp)</span>
<a href="#l3.539"></a><span id="l3.539" class="difflineplus">+</span>
<a href="#l3.540"></a><span id="l3.540" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l3.541"></a><span id="l3.541" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1">new file mode 100644</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineminus">--- /dev/null</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineplus">+++ b/build/pypng/mkiccp.py</span>
<a href="#l4.4"></a><span id="l4.4" class="difflineat">@@ -0,0 +1,45 @@</span>
<a href="#l4.5"></a><span id="l4.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l4.6"></a><span id="l4.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/mkiccp.py $</span>
<a href="#l4.7"></a><span id="l4.7" class="difflineplus">+# $Rev: 182 $</span>
<a href="#l4.8"></a><span id="l4.8" class="difflineplus">+# Make ICC Profile</span>
<a href="#l4.9"></a><span id="l4.9" class="difflineplus">+</span>
<a href="#l4.10"></a><span id="l4.10" class="difflineplus">+# References</span>
<a href="#l4.11"></a><span id="l4.11" class="difflineplus">+#</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+# [ICC 2001] ICC Specification ICC.1:2001-04 (Profile version 2.4.0)</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+# [ICC 2004] ICC Specification ICC.1:2004-10 (Profile version 4.2.0.0)</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+import struct</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+# Local module.</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+import iccp</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+def black(m):</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+    &quot;&quot;&quot;Return a function that maps all values from [0.0,m] to 0, and maps</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+    the range [m,1.0] into [0.0, 1.0] linearly.</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+    m = float(m)</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+    def f(x):</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+        if x &lt;= m:</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+            return 0.0</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+        return (x-m)/(1.0-m)</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+    return f</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+# For monochrome input the required tags are (See [ICC 2001] 6.3.1.1):</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+# profileDescription [ICC 2001] 6.4.32</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+# grayTRC [ICC 2001] 6.4.19</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+# mediaWhitePoint [ICC 2001] 6.4.25</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+# copyright [ICC 2001] 6.4.13</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+def agreyprofile(out):</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+    it = iccp.Profile().greyInput()</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+    it.addTags(kTRC=black(0.07))</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+    it.write(out)</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+def main():</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+    import sys</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+    agreyprofile(sys.stdout)</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1">new file mode 100644</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineminus">--- /dev/null</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineplus">+++ b/build/pypng/pdsimgtopng</span>
<a href="#l5.4"></a><span id="l5.4" class="difflineat">@@ -0,0 +1,99 @@</span>
<a href="#l5.5"></a><span id="l5.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l5.6"></a><span id="l5.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pdsimgtopng $</span>
<a href="#l5.7"></a><span id="l5.7" class="difflineplus">+# $Rev: 154 $</span>
<a href="#l5.8"></a><span id="l5.8" class="difflineplus">+# PDS Image to PNG</span>
<a href="#l5.9"></a><span id="l5.9" class="difflineplus">+</span>
<a href="#l5.10"></a><span id="l5.10" class="difflineplus">+import re</span>
<a href="#l5.11"></a><span id="l5.11" class="difflineplus">+import struct</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+import png</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+class FormatError(Exception):</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+    pass</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+def pdskey(s, k):</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+    &quot;&quot;&quot;Lookup key `k` in string `s`.  Returns value (as a string), or</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+    raises exception if not found.</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+    assert re.match(r' *\^?[:\w]+$', k)</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+    safere = '^' + re.escape(k) +r' *= *(\w+)'</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineplus">+    m = re.search(safere, s, re.MULTILINE)</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineplus">+    if not m:</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineplus">+        raise FormatError(&quot;Can't find %s.&quot; % k)</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineplus">+    return m.group(1)</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineplus">+</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+def img(inp):</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+    &quot;&quot;&quot;Open the PDS IMG file `inp` and return (*pixels*, *info*).</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+    *pixels* is an iterator over the rows, *info* is the information</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+    dictionary.</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+    err = __import__('sys').stderr</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineplus">+</span>
<a href="#l5.38"></a><span id="l5.38" class="difflineplus">+    consumed = 1024</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineplus">+</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineplus">+    s = inp.read(consumed)</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+    record_type = pdskey(s, 'RECORD_TYPE')</span>
<a href="#l5.42"></a><span id="l5.42" class="difflineplus">+    if record_type != 'FIXED_LENGTH':</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineplus">+        raise FormatError(</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineplus">+          &quot;Can only deal with FIXED_LENGTH record type (found %s)&quot; %</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineplus">+            record_type)</span>
<a href="#l5.46"></a><span id="l5.46" class="difflineplus">+    record_bytes = int(pdskey(s,'RECORD_BYTES'))</span>
<a href="#l5.47"></a><span id="l5.47" class="difflineplus">+    file_records = int(pdskey(s, 'FILE_RECORDS'))</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineplus">+    label_records = int(pdskey(s, 'LABEL_RECORDS'))</span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+    remaining = label_records * record_bytes - consumed</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineplus">+    s += inp.read(remaining)</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineplus">+    consumed += remaining</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+    image_pointer = int(pdskey(s, '^IMAGE'))</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+    # &quot;^IMAGE&quot; locates a record.  Records are numbered starting from 1.</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+    image_index = image_pointer - 1</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+    image_offset = image_index * record_bytes</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+    gap = image_offset - consumed</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+    assert gap &gt;= 0</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+    if gap:</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+        inp.read(gap)</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+    # This assumes there is only one OBJECT in the file, and it is the</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+    # IMAGE.</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+    height = int(pdskey(s, '  LINES'))</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+    width = int(pdskey(s, '  LINE_SAMPLES'))</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+    sample_type = pdskey(s, '  SAMPLE_TYPE')</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+    sample_bits = int(pdskey(s, '  SAMPLE_BITS'))</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+    # For Messenger MDIS, SAMPLE_BITS is reported as 16, but only values</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+    # from 0 ot 4095 are used.</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+    bitdepth = 12</span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+    if sample_type == 'MSB_UNSIGNED_INTEGER':</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineplus">+        fmt = '&gt;H'</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+    else:</span>
<a href="#l5.73"></a><span id="l5.73" class="difflineplus">+        raise 'Unknown sample type: %s.' % sample_type</span>
<a href="#l5.74"></a><span id="l5.74" class="difflineplus">+    sample_bytes = (1,2)[bitdepth &gt; 8]</span>
<a href="#l5.75"></a><span id="l5.75" class="difflineplus">+    row_bytes = sample_bytes * width</span>
<a href="#l5.76"></a><span id="l5.76" class="difflineplus">+    fmt = fmt[:1] + str(width) + fmt[1:]</span>
<a href="#l5.77"></a><span id="l5.77" class="difflineplus">+    def rowiter():</span>
<a href="#l5.78"></a><span id="l5.78" class="difflineplus">+        for y in range(height):</span>
<a href="#l5.79"></a><span id="l5.79" class="difflineplus">+            yield struct.unpack(fmt, inp.read(row_bytes))</span>
<a href="#l5.80"></a><span id="l5.80" class="difflineplus">+    info = dict(greyscale=True, alpha=False, bitdepth=bitdepth,</span>
<a href="#l5.81"></a><span id="l5.81" class="difflineplus">+      size=(width,height), gamma=1.0)</span>
<a href="#l5.82"></a><span id="l5.82" class="difflineplus">+    return rowiter(), info</span>
<a href="#l5.83"></a><span id="l5.83" class="difflineplus">+</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineplus">+</span>
<a href="#l5.85"></a><span id="l5.85" class="difflineplus">+def main(argv=None):</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineplus">+    import sys</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineplus">+</span>
<a href="#l5.88"></a><span id="l5.88" class="difflineplus">+    if argv is None:</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineplus">+        argv = sys.argv</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineplus">+    argv = argv[1:]</span>
<a href="#l5.91"></a><span id="l5.91" class="difflineplus">+    arg = argv</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineplus">+    if len(arg) &gt;= 1:</span>
<a href="#l5.93"></a><span id="l5.93" class="difflineplus">+        f = open(arg[0], 'rb')</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineplus">+    else:</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineplus">+        f = sys.stdin</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+    pixels,info = img(f)</span>
<a href="#l5.97"></a><span id="l5.97" class="difflineplus">+    w = png.Writer(**info)</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineplus">+    w.write(sys.stdout, pixels)</span>
<a href="#l5.99"></a><span id="l5.99" class="difflineplus">+</span>
<a href="#l5.100"></a><span id="l5.100" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l5.101"></a><span id="l5.101" class="difflineplus">+    main()</span>
<a href="#l5.102"></a><span id="l5.102" class="difflineplus">+</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1">new file mode 100644</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineminus">--- /dev/null</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineplus">+++ b/build/pypng/pipasgrey</span>
<a href="#l6.4"></a><span id="l6.4" class="difflineat">@@ -0,0 +1,73 @@</span>
<a href="#l6.5"></a><span id="l6.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l6.6"></a><span id="l6.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pipasgrey $</span>
<a href="#l6.7"></a><span id="l6.7" class="difflineplus">+# $Rev: 187 $</span>
<a href="#l6.8"></a><span id="l6.8" class="difflineplus">+</span>
<a href="#l6.9"></a><span id="l6.9" class="difflineplus">+# pipasgrey</span>
<a href="#l6.10"></a><span id="l6.10" class="difflineplus">+</span>
<a href="#l6.11"></a><span id="l6.11" class="difflineplus">+# Convert image to grey (L, or LA), but only if that involves no colour</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+# change.</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+def asgrey(out, inp, quiet=False):</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+    &quot;&quot;&quot;Convert image to greyscale, but only when no colour change.  This</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+    works by using the input G channel (green) as the output L channel</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+    (luminance) and checking that every pixel is grey as we go.  A non-grey</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+    pixel will raise an error, but if `quiet` is true then the grey pixel</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+    check is suppressed.</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+    from array import array</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+    import png</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineplus">+    _,_,pixels,info = r.asDirect()</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineplus">+    if info['greyscale']:</span>
<a href="#l6.29"></a><span id="l6.29" class="difflineplus">+        w = png.Writer(**info)</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineplus">+        return w.write(out, pixels)</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineplus">+    planes = info['planes']</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+    targetplanes = planes - 2</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineplus">+    alpha = info['alpha']</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineplus">+    width = info['size'][0]</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineplus">+    typecode = 'BH'[info['bitdepth'] &gt; 8]</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+    # Values per target row</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+    vpr = width * (targetplanes)</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineplus">+    def iterasgrey():</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+        for i,row in enumerate(pixels):</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+            row = array(typecode, row)</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+            targetrow = array(typecode, [0]*vpr)</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+            # Copy G (and possibly A) channel.</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+            green = row[0::planes]</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+            if alpha:</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+                targetrow[0::2] = green</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+                targetrow[1::2] = row[3::4]</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+            else:</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+                targetrow = green</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+            # Check R and B channel match.</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineplus">+            if not quiet and (</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineplus">+              green != row[0::planes] or green != row[2::planes]):</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineplus">+                raise ValueError('Row %i contains non-grey pixel.' % i)</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineplus">+            yield targetrow</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineplus">+    info['greyscale'] = True</span>
<a href="#l6.55"></a><span id="l6.55" class="difflineplus">+    del info['planes']</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineplus">+    w = png.Writer(**info)</span>
<a href="#l6.57"></a><span id="l6.57" class="difflineplus">+    w.write(out, iterasgrey())</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineplus">+</span>
<a href="#l6.59"></a><span id="l6.59" class="difflineplus">+def main(argv=None):</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineplus">+    from getopt import getopt</span>
<a href="#l6.61"></a><span id="l6.61" class="difflineplus">+    import sys</span>
<a href="#l6.62"></a><span id="l6.62" class="difflineplus">+    if argv is None:</span>
<a href="#l6.63"></a><span id="l6.63" class="difflineplus">+        argv = sys.argv</span>
<a href="#l6.64"></a><span id="l6.64" class="difflineplus">+    argv = argv[1:]</span>
<a href="#l6.65"></a><span id="l6.65" class="difflineplus">+    opt,argv = getopt(argv, 'q')</span>
<a href="#l6.66"></a><span id="l6.66" class="difflineplus">+    quiet = False</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineplus">+    for o,v in opt:</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+        if o == '-q':</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineplus">+            quiet = True</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineplus">+    if len(argv) &gt; 0:</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+        f = open(argv[0], 'rb')</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+    else:</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+        f = sys.stdin</span>
<a href="#l6.74"></a><span id="l6.74" class="difflineplus">+    return asgrey(sys.stdout, f, quiet)</span>
<a href="#l6.75"></a><span id="l6.75" class="difflineplus">+</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1">new file mode 100644</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineminus">--- /dev/null</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineplus">+++ b/build/pypng/pipcat</span>
<a href="#l7.4"></a><span id="l7.4" class="difflineat">@@ -0,0 +1,44 @@</span>
<a href="#l7.5"></a><span id="l7.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l7.6"></a><span id="l7.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pipcat $</span>
<a href="#l7.7"></a><span id="l7.7" class="difflineplus">+# $Rev: 77 $</span>
<a href="#l7.8"></a><span id="l7.8" class="difflineplus">+</span>
<a href="#l7.9"></a><span id="l7.9" class="difflineplus">+# http://www.python.org/doc/2.4.4/lib/module-itertools.html</span>
<a href="#l7.10"></a><span id="l7.10" class="difflineplus">+import itertools</span>
<a href="#l7.11"></a><span id="l7.11" class="difflineplus">+import sys</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+import png</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+def cat(out, l):</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+    &quot;&quot;&quot;Concatenate the list of images.  All input images must be same</span>
<a href="#l7.17"></a><span id="l7.17" class="difflineplus">+    height and have the same number of channels.  They are concatenated</span>
<a href="#l7.18"></a><span id="l7.18" class="difflineplus">+    left-to-right.  `out` is the (open file) destination for the</span>
<a href="#l7.19"></a><span id="l7.19" class="difflineplus">+    output image.  `l` should be a list of open files (the input</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineplus">+    image files).</span>
<a href="#l7.21"></a><span id="l7.21" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineplus">+</span>
<a href="#l7.23"></a><span id="l7.23" class="difflineplus">+    l = map(lambda f: png.Reader(file=f), l)</span>
<a href="#l7.24"></a><span id="l7.24" class="difflineplus">+    # Ewgh, side effects.</span>
<a href="#l7.25"></a><span id="l7.25" class="difflineplus">+    map(lambda r: r.preamble(), l)</span>
<a href="#l7.26"></a><span id="l7.26" class="difflineplus">+    # The reference height; from the first image.</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineplus">+    height = l[0].height</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineplus">+    # The total target width</span>
<a href="#l7.29"></a><span id="l7.29" class="difflineplus">+    width = 0</span>
<a href="#l7.30"></a><span id="l7.30" class="difflineplus">+    for i,r in enumerate(l):</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+        if r.height != height:</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+            raise Error('Image %d, height %d, does not match %d.' %</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineplus">+              (i, r.height, height))</span>
<a href="#l7.34"></a><span id="l7.34" class="difflineplus">+        width += r.width</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineplus">+    pixel,info = zip(*map(lambda r: r.asDirect()[2:4], l))</span>
<a href="#l7.36"></a><span id="l7.36" class="difflineplus">+    tinfo = dict(info[0])</span>
<a href="#l7.37"></a><span id="l7.37" class="difflineplus">+    del tinfo['size']</span>
<a href="#l7.38"></a><span id="l7.38" class="difflineplus">+    w = png.Writer(width, height, **tinfo)</span>
<a href="#l7.39"></a><span id="l7.39" class="difflineplus">+    def itercat():</span>
<a href="#l7.40"></a><span id="l7.40" class="difflineplus">+        for row in itertools.izip(*pixel):</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineplus">+            yield itertools.chain(*row)</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineplus">+    w.write(out, itercat())</span>
<a href="#l7.43"></a><span id="l7.43" class="difflineplus">+</span>
<a href="#l7.44"></a><span id="l7.44" class="difflineplus">+def main(argv):</span>
<a href="#l7.45"></a><span id="l7.45" class="difflineplus">+    return cat(sys.stdout, map(lambda n: open(n, 'rb'), argv[1:]))</span>
<a href="#l7.46"></a><span id="l7.46" class="difflineplus">+</span>
<a href="#l7.47"></a><span id="l7.47" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l7.48"></a><span id="l7.48" class="difflineplus">+    main(sys.argv)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1">new file mode 100644</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineminus">--- /dev/null</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineplus">+++ b/build/pypng/pipcolours</span>
<a href="#l8.4"></a><span id="l8.4" class="difflineat">@@ -0,0 +1,56 @@</span>
<a href="#l8.5"></a><span id="l8.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l8.6"></a><span id="l8.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pipcolours $</span>
<a href="#l8.7"></a><span id="l8.7" class="difflineplus">+# $Rev: 96 $</span>
<a href="#l8.8"></a><span id="l8.8" class="difflineplus">+</span>
<a href="#l8.9"></a><span id="l8.9" class="difflineplus">+# pipcolours - extract all colours present in source image.</span>
<a href="#l8.10"></a><span id="l8.10" class="difflineplus">+</span>
<a href="#l8.11"></a><span id="l8.11" class="difflineplus">+def colours(out, inp):</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+    import itertools</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+    import png</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+    _,_,pixels,info = r.asDirect()</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineplus">+    planes = info['planes']</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineplus">+    col = set()</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+    for row in pixels:</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+        # Ewgh, side effects on col</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+        map(col.add, png.group(row, planes))</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+    col,planes = channel_reduce(col, planes)</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineplus">+    col = list(col)</span>
<a href="#l8.24"></a><span id="l8.24" class="difflineplus">+    col.sort()</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineplus">+    col = list(itertools.chain(*col))</span>
<a href="#l8.26"></a><span id="l8.26" class="difflineplus">+    width = len(col)//planes</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineplus">+    greyscale = planes in (1,2)</span>
<a href="#l8.28"></a><span id="l8.28" class="difflineplus">+    alpha = planes in (2,4)</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineplus">+    bitdepth = info['bitdepth']</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+    w = png.Writer(width, 1,</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+        bitdepth=bitdepth, greyscale=greyscale, alpha=alpha)</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+    w.write(out, [col])</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineplus">+</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineplus">+def channel_reduce(col, planes):</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+    &quot;&quot;&quot;Attempt to reduce the number of channels in the set of</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+    colours.&quot;&quot;&quot;</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+    if planes &gt;= 3:</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+        def isgrey(c):</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+            return c[0] == c[1] == c[2]</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineplus">+        if min(map(isgrey, col)) == True:</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+            # Every colour is grey.</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineplus">+            col = set(map(lambda x: x[0::3], col))</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineplus">+            planes -= 2</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+    return col,planes</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineplus">+</span>
<a href="#l8.46"></a><span id="l8.46" class="difflineplus">+def main(argv=None):</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineplus">+    import sys</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineplus">+</span>
<a href="#l8.49"></a><span id="l8.49" class="difflineplus">+    if argv is None:</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineplus">+        argv = sys.argv</span>
<a href="#l8.51"></a><span id="l8.51" class="difflineplus">+</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineplus">+    argv = argv[1:]</span>
<a href="#l8.53"></a><span id="l8.53" class="difflineplus">+    if len(argv) &gt; 0:</span>
<a href="#l8.54"></a><span id="l8.54" class="difflineplus">+        f = open(argv[0], 'rb')</span>
<a href="#l8.55"></a><span id="l8.55" class="difflineplus">+    else:</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineplus">+        f = sys.stdin</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineplus">+    return colours(sys.stdout, f)</span>
<a href="#l8.58"></a><span id="l8.58" class="difflineplus">+</span>
<a href="#l8.59"></a><span id="l8.59" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1">new file mode 100644</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineminus">--- /dev/null</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineplus">+++ b/build/pypng/pipcomposite</span>
<a href="#l9.4"></a><span id="l9.4" class="difflineat">@@ -0,0 +1,121 @@</span>
<a href="#l9.5"></a><span id="l9.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l9.6"></a><span id="l9.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pipcomposite $</span>
<a href="#l9.7"></a><span id="l9.7" class="difflineplus">+# $Rev: 208 $</span>
<a href="#l9.8"></a><span id="l9.8" class="difflineplus">+# pipcomposite</span>
<a href="#l9.9"></a><span id="l9.9" class="difflineplus">+# Image alpha compositing.</span>
<a href="#l9.10"></a><span id="l9.10" class="difflineplus">+</span>
<a href="#l9.11"></a><span id="l9.11" class="difflineplus">+&quot;&quot;&quot;</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+pipcomposite [--background #rrggbb] file.png</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineplus">+Composite an image onto a background and output the result.  The</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineplus">+background colour is specified with an HTML-style triple (3, 6, or 12</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+hex digits), and defaults to black (#000).</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineplus">+</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+The output PNG has no alpha channel.</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineplus">+It is valid for the input to have no alpha channel, but it doesn't</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineplus">+make much sense: the output will equal the input.</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineplus">+&quot;&quot;&quot;</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineplus">+</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineplus">+import sys</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineplus">+</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineplus">+def composite(out, inp, background):</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineplus">+    import png</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineplus">+</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineplus">+    p = png.Reader(file=inp)</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineplus">+    w,h,pixel,info = p.asRGBA()</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineplus">+</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+    outinfo = dict(info)</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineplus">+    outinfo['alpha'] = False</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineplus">+    outinfo['planes'] -= 1</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineplus">+    outinfo['interlace'] = 0</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineplus">+</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineplus">+    # Convert to tuple and normalise to same range as source.</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineplus">+    background = rgbhex(background)</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineplus">+    maxval = float(2**info['bitdepth'] - 1)</span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+    background = map(lambda x: int(0.5 + x*maxval/65535.0),</span>
<a href="#l9.41"></a><span id="l9.41" class="difflineplus">+                     background)</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+    # Repeat background so that it's a whole row of sample values.</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineplus">+    background *= w</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineplus">+    def iterrow():</span>
<a href="#l9.46"></a><span id="l9.46" class="difflineplus">+        for row in pixel:</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineplus">+            # Remove alpha from row, then create a list with one alpha</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineplus">+            # entry _per channel value_.</span>
<a href="#l9.49"></a><span id="l9.49" class="difflineplus">+            # Squirrel the alpha channel away (and normalise it).</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineplus">+            t = map(lambda x: x/maxval, row[3::4])</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineplus">+            row = list(row)</span>
<a href="#l9.52"></a><span id="l9.52" class="difflineplus">+            del row[3::4]</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineplus">+            alpha = row[:]</span>
<a href="#l9.54"></a><span id="l9.54" class="difflineplus">+            for i in range(3):</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineplus">+                alpha[i::3] = t</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineplus">+            assert len(alpha) == len(row) == len(background)</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineplus">+            yield map(lambda a,v,b: int(0.5 + a*v + (1.0-a)*b),</span>
<a href="#l9.58"></a><span id="l9.58" class="difflineplus">+                      alpha, row, background)</span>
<a href="#l9.59"></a><span id="l9.59" class="difflineplus">+</span>
<a href="#l9.60"></a><span id="l9.60" class="difflineplus">+    w = png.Writer(**outinfo)</span>
<a href="#l9.61"></a><span id="l9.61" class="difflineplus">+    w.write(out, iterrow())</span>
<a href="#l9.62"></a><span id="l9.62" class="difflineplus">+</span>
<a href="#l9.63"></a><span id="l9.63" class="difflineplus">+def rgbhex(s):</span>
<a href="#l9.64"></a><span id="l9.64" class="difflineplus">+    &quot;&quot;&quot;Take an HTML style string of the form &quot;#rrggbb&quot; and return a</span>
<a href="#l9.65"></a><span id="l9.65" class="difflineplus">+    colour (R,G,B) triple.  Following the initial '#' there can be 3, 6,</span>
<a href="#l9.66"></a><span id="l9.66" class="difflineplus">+    or 12 digits (for 4-, 8- or 16- bits per channel).  In all cases the</span>
<a href="#l9.67"></a><span id="l9.67" class="difflineplus">+    values are expanded to a full 16-bit range, so the returned values</span>
<a href="#l9.68"></a><span id="l9.68" class="difflineplus">+    are all in range(65536).</span>
<a href="#l9.69"></a><span id="l9.69" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l9.70"></a><span id="l9.70" class="difflineplus">+</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineplus">+    assert s[0] == '#'</span>
<a href="#l9.72"></a><span id="l9.72" class="difflineplus">+    s = s[1:]</span>
<a href="#l9.73"></a><span id="l9.73" class="difflineplus">+    assert len(s) in (3,6,12)</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineplus">+</span>
<a href="#l9.75"></a><span id="l9.75" class="difflineplus">+    # Create a target list of length 12, and expand the string s to make</span>
<a href="#l9.76"></a><span id="l9.76" class="difflineplus">+    # it length 12.</span>
<a href="#l9.77"></a><span id="l9.77" class="difflineplus">+    l = ['z']*12</span>
<a href="#l9.78"></a><span id="l9.78" class="difflineplus">+    if len(s) == 3:</span>
<a href="#l9.79"></a><span id="l9.79" class="difflineplus">+        for i in range(4):</span>
<a href="#l9.80"></a><span id="l9.80" class="difflineplus">+            l[i::4] = s</span>
<a href="#l9.81"></a><span id="l9.81" class="difflineplus">+    if len(s) == 6:</span>
<a href="#l9.82"></a><span id="l9.82" class="difflineplus">+        for i in range(2):</span>
<a href="#l9.83"></a><span id="l9.83" class="difflineplus">+            l[i::4] = s[i::2]</span>
<a href="#l9.84"></a><span id="l9.84" class="difflineplus">+            l[i+2::4] = s[i::2]</span>
<a href="#l9.85"></a><span id="l9.85" class="difflineplus">+    if len(s) == 12:</span>
<a href="#l9.86"></a><span id="l9.86" class="difflineplus">+        l[:] = s</span>
<a href="#l9.87"></a><span id="l9.87" class="difflineplus">+    s = ''.join(l)</span>
<a href="#l9.88"></a><span id="l9.88" class="difflineplus">+    return map(lambda x: int(x, 16), (s[:4], s[4:8], s[8:]))</span>
<a href="#l9.89"></a><span id="l9.89" class="difflineplus">+</span>
<a href="#l9.90"></a><span id="l9.90" class="difflineplus">+class Usage(Exception):</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineplus">+    pass</span>
<a href="#l9.92"></a><span id="l9.92" class="difflineplus">+</span>
<a href="#l9.93"></a><span id="l9.93" class="difflineplus">+def main(argv=None):</span>
<a href="#l9.94"></a><span id="l9.94" class="difflineplus">+    import getopt</span>
<a href="#l9.95"></a><span id="l9.95" class="difflineplus">+    import sys</span>
<a href="#l9.96"></a><span id="l9.96" class="difflineplus">+</span>
<a href="#l9.97"></a><span id="l9.97" class="difflineplus">+    if argv is None:</span>
<a href="#l9.98"></a><span id="l9.98" class="difflineplus">+        argv = sys.argv</span>
<a href="#l9.99"></a><span id="l9.99" class="difflineplus">+</span>
<a href="#l9.100"></a><span id="l9.100" class="difflineplus">+    argv = argv[1:]</span>
<a href="#l9.101"></a><span id="l9.101" class="difflineplus">+</span>
<a href="#l9.102"></a><span id="l9.102" class="difflineplus">+    try:</span>
<a href="#l9.103"></a><span id="l9.103" class="difflineplus">+        try:</span>
<a href="#l9.104"></a><span id="l9.104" class="difflineplus">+            opt,arg = getopt.getopt(argv, '',</span>
<a href="#l9.105"></a><span id="l9.105" class="difflineplus">+                                    ['background='])</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineplus">+        except getopt.error, msg:</span>
<a href="#l9.107"></a><span id="l9.107" class="difflineplus">+            raise Usage(msg)</span>
<a href="#l9.108"></a><span id="l9.108" class="difflineplus">+        background = '#000'</span>
<a href="#l9.109"></a><span id="l9.109" class="difflineplus">+        for o,v in opt:</span>
<a href="#l9.110"></a><span id="l9.110" class="difflineplus">+            if o in ['--background']:</span>
<a href="#l9.111"></a><span id="l9.111" class="difflineplus">+                background = v</span>
<a href="#l9.112"></a><span id="l9.112" class="difflineplus">+    except Usage, err:</span>
<a href="#l9.113"></a><span id="l9.113" class="difflineplus">+        print &gt;&gt;sys.stderr, __doc__</span>
<a href="#l9.114"></a><span id="l9.114" class="difflineplus">+        print &gt;&gt;sys.stderr, str(err)</span>
<a href="#l9.115"></a><span id="l9.115" class="difflineplus">+        return 2</span>
<a href="#l9.116"></a><span id="l9.116" class="difflineplus">+</span>
<a href="#l9.117"></a><span id="l9.117" class="difflineplus">+    if len(arg) &gt; 0:</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineplus">+        f = open(arg[0], 'rb')</span>
<a href="#l9.119"></a><span id="l9.119" class="difflineplus">+    else:</span>
<a href="#l9.120"></a><span id="l9.120" class="difflineplus">+        f = sys.stdin</span>
<a href="#l9.121"></a><span id="l9.121" class="difflineplus">+    return composite(sys.stdout, f, background)</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineplus">+</span>
<a href="#l9.123"></a><span id="l9.123" class="difflineplus">+</span>
<a href="#l9.124"></a><span id="l9.124" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l9.125"></a><span id="l9.125" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1">new file mode 100644</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineminus">--- /dev/null</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineplus">+++ b/build/pypng/pipdither</span>
<a href="#l10.4"></a><span id="l10.4" class="difflineat">@@ -0,0 +1,181 @@</span>
<a href="#l10.5"></a><span id="l10.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l10.6"></a><span id="l10.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pipdither $</span>
<a href="#l10.7"></a><span id="l10.7" class="difflineplus">+# $Rev: 150 $</span>
<a href="#l10.8"></a><span id="l10.8" class="difflineplus">+</span>
<a href="#l10.9"></a><span id="l10.9" class="difflineplus">+# pipdither</span>
<a href="#l10.10"></a><span id="l10.10" class="difflineplus">+# Error Diffusing image dithering.</span>
<a href="#l10.11"></a><span id="l10.11" class="difflineplus">+# Now with serpentine scanning.</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+# See http://www.efg2.com/Lab/Library/ImageProcessing/DHALF.TXT</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+# http://www.python.org/doc/2.4.4/lib/module-bisect.html</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+from bisect import bisect_left</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+import png</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineplus">+</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+def dither(out, inp,</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineplus">+  bitdepth=1, linear=False, defaultgamma=1.0, targetgamma=None,</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineplus">+  cutoff=0.75):</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineplus">+    &quot;&quot;&quot;Dither the input PNG `inp` into an image with a smaller bit depth</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+    and write the result image onto `out`.  `bitdepth` specifies the bit</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineplus">+    depth of the new image.</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineplus">+    </span>
<a href="#l10.27"></a><span id="l10.27" class="difflineplus">+    Normally the source image gamma is honoured (the image is</span>
<a href="#l10.28"></a><span id="l10.28" class="difflineplus">+    converted into a linear light space before being dithered), but</span>
<a href="#l10.29"></a><span id="l10.29" class="difflineplus">+    if the `linear` argument is true then the image is treated as</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineplus">+    being linear already: no gamma conversion is done (this is</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineplus">+    quicker, and if you don't care much about accuracy, it won't</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+    matter much).</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineplus">+    </span>
<a href="#l10.34"></a><span id="l10.34" class="difflineplus">+    Images with no gamma indication (no ``gAMA`` chunk) are normally</span>
<a href="#l10.35"></a><span id="l10.35" class="difflineplus">+    treated as linear (gamma = 1.0), but often it can be better</span>
<a href="#l10.36"></a><span id="l10.36" class="difflineplus">+    to assume a different gamma value: For example continuous tone</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineplus">+    photographs intended for presentation on the web often carry</span>
<a href="#l10.38"></a><span id="l10.38" class="difflineplus">+    an implicit assumption of being encoded with a gamma of about</span>
<a href="#l10.39"></a><span id="l10.39" class="difflineplus">+    0.45 (because that's what you get if you just &quot;blat the pixels&quot;</span>
<a href="#l10.40"></a><span id="l10.40" class="difflineplus">+    onto a PC framebuffer), so ``defaultgamma=0.45`` might be a</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineplus">+    good idea.  `defaultgamma` does not override a gamma value</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineplus">+    specified in the file itself: It is only used when the file</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+    does not specify a gamma.</span>
<a href="#l10.44"></a><span id="l10.44" class="difflineplus">+</span>
<a href="#l10.45"></a><span id="l10.45" class="difflineplus">+    If you (pointlessly) specify both `linear` and `defaultgamma`,</span>
<a href="#l10.46"></a><span id="l10.46" class="difflineplus">+    `linear` wins.</span>
<a href="#l10.47"></a><span id="l10.47" class="difflineplus">+</span>
<a href="#l10.48"></a><span id="l10.48" class="difflineplus">+    The gamma of the output image is, by default, the same as the input</span>
<a href="#l10.49"></a><span id="l10.49" class="difflineplus">+    image.  The `targetgamma` argument can be used to specify a</span>
<a href="#l10.50"></a><span id="l10.50" class="difflineplus">+    different gamma for the output image.  This effectively recodes the</span>
<a href="#l10.51"></a><span id="l10.51" class="difflineplus">+    image to a different gamma, dithering as we go.  The gamma specified</span>
<a href="#l10.52"></a><span id="l10.52" class="difflineplus">+    is the exponent used to encode the output file (and appears in the</span>
<a href="#l10.53"></a><span id="l10.53" class="difflineplus">+    output PNG's ``gAMA`` chunk); it is usually less than 1.</span>
<a href="#l10.54"></a><span id="l10.54" class="difflineplus">+</span>
<a href="#l10.55"></a><span id="l10.55" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l10.56"></a><span id="l10.56" class="difflineplus">+</span>
<a href="#l10.57"></a><span id="l10.57" class="difflineplus">+    # Encoding is what happened when the PNG was made (and also what</span>
<a href="#l10.58"></a><span id="l10.58" class="difflineplus">+    # happens when we output the PNG).  Decoding is what we do to the</span>
<a href="#l10.59"></a><span id="l10.59" class="difflineplus">+    # source PNG in order to process it.</span>
<a href="#l10.60"></a><span id="l10.60" class="difflineplus">+</span>
<a href="#l10.61"></a><span id="l10.61" class="difflineplus">+    # The dithering algorithm is not completely general; it</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineplus">+    # can only do bit depth reduction, not arbitrary palette changes.</span>
<a href="#l10.63"></a><span id="l10.63" class="difflineplus">+    import operator</span>
<a href="#l10.64"></a><span id="l10.64" class="difflineplus">+    maxval = 2**bitdepth - 1</span>
<a href="#l10.65"></a><span id="l10.65" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l10.66"></a><span id="l10.66" class="difflineplus">+    # If image gamma is 1 or gamma is not present and we are assuming a</span>
<a href="#l10.67"></a><span id="l10.67" class="difflineplus">+    # value of 1, then it is faster to pass a maxval parameter to</span>
<a href="#l10.68"></a><span id="l10.68" class="difflineplus">+    # asFloat (the multiplications get combined).  With gamma, we have</span>
<a href="#l10.69"></a><span id="l10.69" class="difflineplus">+    # to have the pixel values from 0.0 to 1.0 (as long as we are doing</span>
<a href="#l10.70"></a><span id="l10.70" class="difflineplus">+    # gamma correction here).</span>
<a href="#l10.71"></a><span id="l10.71" class="difflineplus">+    # Slightly annoyingly, we don't know the image gamma until we've</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineplus">+    # called asFloat().</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineplus">+    _,_,pixels,info = r.asDirect()</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineplus">+    planes = info['planes']</span>
<a href="#l10.75"></a><span id="l10.75" class="difflineplus">+    assert planes == 1</span>
<a href="#l10.76"></a><span id="l10.76" class="difflineplus">+    width = info['size'][0]</span>
<a href="#l10.77"></a><span id="l10.77" class="difflineplus">+    sourcemaxval = 2**info['bitdepth'] - 1</span>
<a href="#l10.78"></a><span id="l10.78" class="difflineplus">+    if linear:</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineplus">+        gamma = 1</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineplus">+    else:</span>
<a href="#l10.81"></a><span id="l10.81" class="difflineplus">+        gamma = info.get('gamma') or defaultgamma</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineplus">+    # Convert gamma from encoding gamma to the required power for</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineplus">+    # decoding.</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineplus">+    decode = 1.0/gamma</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineplus">+    # Build a lookup table for decoding; convert from pixel values to linear</span>
<a href="#l10.86"></a><span id="l10.86" class="difflineplus">+    # space:</span>
<a href="#l10.87"></a><span id="l10.87" class="difflineplus">+    sourcef = 1.0/sourcemaxval</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineplus">+    incode = map(sourcef.__mul__, range(sourcemaxval+1))</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineplus">+    if decode != 1.0:</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineplus">+        incode = map(decode.__rpow__, incode)</span>
<a href="#l10.91"></a><span id="l10.91" class="difflineplus">+    # Could be different, later on.  targetdecode is the assumed gamma</span>
<a href="#l10.92"></a><span id="l10.92" class="difflineplus">+    # that is going to be used to decoding the target PNG.  It is the</span>
<a href="#l10.93"></a><span id="l10.93" class="difflineplus">+    # reciprocal of the exponent that we use to encode the target PNG.</span>
<a href="#l10.94"></a><span id="l10.94" class="difflineplus">+    # This is the value that we need to build our table that we use for</span>
<a href="#l10.95"></a><span id="l10.95" class="difflineplus">+    # converting from linear to target colour space.</span>
<a href="#l10.96"></a><span id="l10.96" class="difflineplus">+    if targetgamma is None:</span>
<a href="#l10.97"></a><span id="l10.97" class="difflineplus">+        targetdecode = decode</span>
<a href="#l10.98"></a><span id="l10.98" class="difflineplus">+    else:</span>
<a href="#l10.99"></a><span id="l10.99" class="difflineplus">+        targetdecode = 1.0/targetgamma</span>
<a href="#l10.100"></a><span id="l10.100" class="difflineplus">+    # The table we use for encoding (creating the target PNG), still</span>
<a href="#l10.101"></a><span id="l10.101" class="difflineplus">+    # maps from pixel value to linear space, but we use it inverted, by</span>
<a href="#l10.102"></a><span id="l10.102" class="difflineplus">+    # searching through it with bisect.</span>
<a href="#l10.103"></a><span id="l10.103" class="difflineplus">+    targetf = 1.0/maxval</span>
<a href="#l10.104"></a><span id="l10.104" class="difflineplus">+    outcode = map(targetf.__mul__, range(maxval+1))</span>
<a href="#l10.105"></a><span id="l10.105" class="difflineplus">+    if targetdecode != 1.0:</span>
<a href="#l10.106"></a><span id="l10.106" class="difflineplus">+        outcode = map(targetdecode.__rpow__, outcode)</span>
<a href="#l10.107"></a><span id="l10.107" class="difflineplus">+    # The table used for choosing output codes.  These values represent</span>
<a href="#l10.108"></a><span id="l10.108" class="difflineplus">+    # the cutoff points between two adjacent output codes.</span>
<a href="#l10.109"></a><span id="l10.109" class="difflineplus">+    choosecode = zip(outcode[1:], outcode)</span>
<a href="#l10.110"></a><span id="l10.110" class="difflineplus">+    p = cutoff</span>
<a href="#l10.111"></a><span id="l10.111" class="difflineplus">+    choosecode = map(lambda x: x[0]*p+x[1]*(1.0-p), choosecode)</span>
<a href="#l10.112"></a><span id="l10.112" class="difflineplus">+    def iterdither():</span>
<a href="#l10.113"></a><span id="l10.113" class="difflineplus">+        # Errors diffused downwards (into next row)</span>
<a href="#l10.114"></a><span id="l10.114" class="difflineplus">+        ed = [0.0]*width</span>
<a href="#l10.115"></a><span id="l10.115" class="difflineplus">+        flipped = False</span>
<a href="#l10.116"></a><span id="l10.116" class="difflineplus">+        for row in pixels:</span>
<a href="#l10.117"></a><span id="l10.117" class="difflineplus">+            row = map(incode.__getitem__, row)</span>
<a href="#l10.118"></a><span id="l10.118" class="difflineplus">+            row = map(operator.add, ed, row)</span>
<a href="#l10.119"></a><span id="l10.119" class="difflineplus">+            if flipped:</span>
<a href="#l10.120"></a><span id="l10.120" class="difflineplus">+                row = row[::-1]</span>
<a href="#l10.121"></a><span id="l10.121" class="difflineplus">+            targetrow = [0] * width</span>
<a href="#l10.122"></a><span id="l10.122" class="difflineplus">+            for i,v in enumerate(row):</span>
<a href="#l10.123"></a><span id="l10.123" class="difflineplus">+                # Clamp.  Necessary because previously added errors may take</span>
<a href="#l10.124"></a><span id="l10.124" class="difflineplus">+                # v out of range.</span>
<a href="#l10.125"></a><span id="l10.125" class="difflineplus">+                v = max(0.0, min(v, 1.0))</span>
<a href="#l10.126"></a><span id="l10.126" class="difflineplus">+                # `it` will be the index of the chosen target colour;</span>
<a href="#l10.127"></a><span id="l10.127" class="difflineplus">+                it = bisect_left(choosecode, v)</span>
<a href="#l10.128"></a><span id="l10.128" class="difflineplus">+                t = outcode[it]</span>
<a href="#l10.129"></a><span id="l10.129" class="difflineplus">+                targetrow[i] = it</span>
<a href="#l10.130"></a><span id="l10.130" class="difflineplus">+                # err is the error that needs distributing.</span>
<a href="#l10.131"></a><span id="l10.131" class="difflineplus">+                err = v - t</span>
<a href="#l10.132"></a><span id="l10.132" class="difflineplus">+                # Sierra &quot;Filter Lite&quot; distributes          * 2</span>
<a href="#l10.133"></a><span id="l10.133" class="difflineplus">+                # as per this diagram.                    1 1</span>
<a href="#l10.134"></a><span id="l10.134" class="difflineplus">+                ef = err/2.0</span>
<a href="#l10.135"></a><span id="l10.135" class="difflineplus">+                # :todo: consider making rows one wider at each end and</span>
<a href="#l10.136"></a><span id="l10.136" class="difflineplus">+                # removing &quot;if&quot;s</span>
<a href="#l10.137"></a><span id="l10.137" class="difflineplus">+                if i+1 &lt; width:</span>
<a href="#l10.138"></a><span id="l10.138" class="difflineplus">+                    row[i+1] += ef</span>
<a href="#l10.139"></a><span id="l10.139" class="difflineplus">+                ef /= 2.0</span>
<a href="#l10.140"></a><span id="l10.140" class="difflineplus">+                ed[i] = ef</span>
<a href="#l10.141"></a><span id="l10.141" class="difflineplus">+                if i:</span>
<a href="#l10.142"></a><span id="l10.142" class="difflineplus">+                    ed[i-1] += ef</span>
<a href="#l10.143"></a><span id="l10.143" class="difflineplus">+            if flipped:</span>
<a href="#l10.144"></a><span id="l10.144" class="difflineplus">+                ed = ed[::-1]</span>
<a href="#l10.145"></a><span id="l10.145" class="difflineplus">+                targetrow = targetrow[::-1]</span>
<a href="#l10.146"></a><span id="l10.146" class="difflineplus">+            yield targetrow</span>
<a href="#l10.147"></a><span id="l10.147" class="difflineplus">+            flipped = not flipped</span>
<a href="#l10.148"></a><span id="l10.148" class="difflineplus">+    info['bitdepth'] = bitdepth</span>
<a href="#l10.149"></a><span id="l10.149" class="difflineplus">+    info['gamma'] = 1.0/targetdecode</span>
<a href="#l10.150"></a><span id="l10.150" class="difflineplus">+    w = png.Writer(**info)</span>
<a href="#l10.151"></a><span id="l10.151" class="difflineplus">+    w.write(out, iterdither())</span>
<a href="#l10.152"></a><span id="l10.152" class="difflineplus">+</span>
<a href="#l10.153"></a><span id="l10.153" class="difflineplus">+</span>
<a href="#l10.154"></a><span id="l10.154" class="difflineplus">+def main(argv=None):</span>
<a href="#l10.155"></a><span id="l10.155" class="difflineplus">+    # http://www.python.org/doc/2.4.4/lib/module-getopt.html</span>
<a href="#l10.156"></a><span id="l10.156" class="difflineplus">+    from getopt import getopt</span>
<a href="#l10.157"></a><span id="l10.157" class="difflineplus">+    import sys</span>
<a href="#l10.158"></a><span id="l10.158" class="difflineplus">+    if argv is None:</span>
<a href="#l10.159"></a><span id="l10.159" class="difflineplus">+        argv = sys.argv</span>
<a href="#l10.160"></a><span id="l10.160" class="difflineplus">+    opt,argv = getopt(argv[1:], 'b:c:g:lo:')</span>
<a href="#l10.161"></a><span id="l10.161" class="difflineplus">+    k = {}</span>
<a href="#l10.162"></a><span id="l10.162" class="difflineplus">+    for o,v in opt:</span>
<a href="#l10.163"></a><span id="l10.163" class="difflineplus">+        if o == '-b':</span>
<a href="#l10.164"></a><span id="l10.164" class="difflineplus">+            k['bitdepth'] = int(v)</span>
<a href="#l10.165"></a><span id="l10.165" class="difflineplus">+        if o == '-c':</span>
<a href="#l10.166"></a><span id="l10.166" class="difflineplus">+            k['cutoff'] = float(v)</span>
<a href="#l10.167"></a><span id="l10.167" class="difflineplus">+        if o == '-g':</span>
<a href="#l10.168"></a><span id="l10.168" class="difflineplus">+            k['defaultgamma'] = float(v)</span>
<a href="#l10.169"></a><span id="l10.169" class="difflineplus">+        if o == '-l':</span>
<a href="#l10.170"></a><span id="l10.170" class="difflineplus">+            k['linear'] = True</span>
<a href="#l10.171"></a><span id="l10.171" class="difflineplus">+        if o == '-o':</span>
<a href="#l10.172"></a><span id="l10.172" class="difflineplus">+            k['targetgamma'] = float(v)</span>
<a href="#l10.173"></a><span id="l10.173" class="difflineplus">+        if o == '-?':</span>
<a href="#l10.174"></a><span id="l10.174" class="difflineplus">+            print &gt;&gt;sys.stderr, &quot;pipdither [-b bits] [-c cutoff] [-g assumed-gamma] [-l] [in.png]&quot;</span>
<a href="#l10.175"></a><span id="l10.175" class="difflineplus">+</span>
<a href="#l10.176"></a><span id="l10.176" class="difflineplus">+    if len(argv) &gt; 0:</span>
<a href="#l10.177"></a><span id="l10.177" class="difflineplus">+        f = open(argv[0], 'rb')</span>
<a href="#l10.178"></a><span id="l10.178" class="difflineplus">+    else:</span>
<a href="#l10.179"></a><span id="l10.179" class="difflineplus">+        f = sys.stdin</span>
<a href="#l10.180"></a><span id="l10.180" class="difflineplus">+</span>
<a href="#l10.181"></a><span id="l10.181" class="difflineplus">+    return dither(sys.stdout, f, **k)</span>
<a href="#l10.182"></a><span id="l10.182" class="difflineplus">+</span>
<a href="#l10.183"></a><span id="l10.183" class="difflineplus">+</span>
<a href="#l10.184"></a><span id="l10.184" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l10.185"></a><span id="l10.185" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1">new file mode 100644</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineminus">--- /dev/null</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineplus">+++ b/build/pypng/piprgb</span>
<a href="#l11.4"></a><span id="l11.4" class="difflineat">@@ -0,0 +1,36 @@</span>
<a href="#l11.5"></a><span id="l11.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l11.6"></a><span id="l11.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/piprgb $</span>
<a href="#l11.7"></a><span id="l11.7" class="difflineplus">+# $Rev: 131 $</span>
<a href="#l11.8"></a><span id="l11.8" class="difflineplus">+# piprgb</span>
<a href="#l11.9"></a><span id="l11.9" class="difflineplus">+#</span>
<a href="#l11.10"></a><span id="l11.10" class="difflineplus">+# Convert input image to RGB or RGBA format.  Output will be colour type</span>
<a href="#l11.11"></a><span id="l11.11" class="difflineplus">+# 2 or 6, and will not have a tRNS chunk.</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+import png</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineplus">+def rgb(out, inp):</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineplus">+    &quot;&quot;&quot;Convert to RGB/RGBA.&quot;&quot;&quot;</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineplus">+</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l11.19"></a><span id="l11.19" class="difflineplus">+    r.preamble()</span>
<a href="#l11.20"></a><span id="l11.20" class="difflineplus">+    if r.alpha or r.trns:</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineplus">+        get = r.asRGBA</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+    else:</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineplus">+        get = r.asRGB</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineplus">+    pixels,info = get()[2:4]</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineplus">+    w = png.Writer(**info)</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineplus">+    w.write(out, pixels)</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineplus">+</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineplus">+def main(argv=None):</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineplus">+    import sys</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineplus">+</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineplus">+    if argv is None:</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+        argv = sys.argv</span>
<a href="#l11.33"></a><span id="l11.33" class="difflineplus">+    if len(argv) &gt; 1:</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineplus">+        f = open(argv[1], 'rb')</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineplus">+    else:</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineplus">+        f = sys.stdin</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineplus">+    return rgb(sys.stdout, f)</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineplus">+</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1">new file mode 100644</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineminus">--- /dev/null</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineplus">+++ b/build/pypng/pipscalez</span>
<a href="#l12.4"></a><span id="l12.4" class="difflineat">@@ -0,0 +1,53 @@</span>
<a href="#l12.5"></a><span id="l12.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l12.6"></a><span id="l12.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pipscalez $</span>
<a href="#l12.7"></a><span id="l12.7" class="difflineplus">+# $Rev: 131 $</span>
<a href="#l12.8"></a><span id="l12.8" class="difflineplus">+</span>
<a href="#l12.9"></a><span id="l12.9" class="difflineplus">+# pipscalez</span>
<a href="#l12.10"></a><span id="l12.10" class="difflineplus">+# Enlarge an image by an integer factor horizontally and vertically.</span>
<a href="#l12.11"></a><span id="l12.11" class="difflineplus">+</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+def rescale(inp, out, xf, yf):</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+    from array import array</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineplus">+    import png</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineplus">+</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l12.17"></a><span id="l12.17" class="difflineplus">+    _,_,pixels,meta = r.asDirect()</span>
<a href="#l12.18"></a><span id="l12.18" class="difflineplus">+    typecode = 'BH'[meta['bitdepth'] &gt; 8]</span>
<a href="#l12.19"></a><span id="l12.19" class="difflineplus">+    planes = meta['planes']</span>
<a href="#l12.20"></a><span id="l12.20" class="difflineplus">+    # We are going to use meta in the call to Writer, so expand the</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineplus">+    # size.</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineplus">+    x,y = meta['size']</span>
<a href="#l12.23"></a><span id="l12.23" class="difflineplus">+    x *= xf</span>
<a href="#l12.24"></a><span id="l12.24" class="difflineplus">+    y *= yf</span>
<a href="#l12.25"></a><span id="l12.25" class="difflineplus">+    meta['size'] = (x,y)</span>
<a href="#l12.26"></a><span id="l12.26" class="difflineplus">+    del x</span>
<a href="#l12.27"></a><span id="l12.27" class="difflineplus">+    del y</span>
<a href="#l12.28"></a><span id="l12.28" class="difflineplus">+    # Values per row, target row.</span>
<a href="#l12.29"></a><span id="l12.29" class="difflineplus">+    vpr = meta['size'][0] * planes</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineplus">+    def iterscale():</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+        for row in pixels:</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+            bigrow = array(typecode, [0]*vpr)</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+            row = array(typecode, row)</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+            for c in range(planes):</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineplus">+                channel = row[c::planes]</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+                for i in range(xf):</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineplus">+                    bigrow[i*planes+c::xf*planes] = channel</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+            for _ in range(yf):</span>
<a href="#l12.39"></a><span id="l12.39" class="difflineplus">+                yield bigrow</span>
<a href="#l12.40"></a><span id="l12.40" class="difflineplus">+    w = png.Writer(**meta)</span>
<a href="#l12.41"></a><span id="l12.41" class="difflineplus">+    w.write(out, iterscale())</span>
<a href="#l12.42"></a><span id="l12.42" class="difflineplus">+</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineplus">+</span>
<a href="#l12.44"></a><span id="l12.44" class="difflineplus">+def main(argv=None):</span>
<a href="#l12.45"></a><span id="l12.45" class="difflineplus">+    import sys</span>
<a href="#l12.46"></a><span id="l12.46" class="difflineplus">+</span>
<a href="#l12.47"></a><span id="l12.47" class="difflineplus">+    if argv is None:</span>
<a href="#l12.48"></a><span id="l12.48" class="difflineplus">+        argv = sys.argv</span>
<a href="#l12.49"></a><span id="l12.49" class="difflineplus">+    xf = int(argv[1])</span>
<a href="#l12.50"></a><span id="l12.50" class="difflineplus">+    if len(argv) &gt; 2:</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineplus">+        yf = int(argv[2])</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineplus">+    else:</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineplus">+        yf = xf</span>
<a href="#l12.54"></a><span id="l12.54" class="difflineplus">+    return rescale(sys.stdin, sys.stdout, xf, yf)</span>
<a href="#l12.55"></a><span id="l12.55" class="difflineplus">+</span>
<a href="#l12.56"></a><span id="l12.56" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l12.57"></a><span id="l12.57" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1">new file mode 100644</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineminus">--- /dev/null</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineplus">+++ b/build/pypng/pipstack</span>
<a href="#l13.4"></a><span id="l13.4" class="difflineat">@@ -0,0 +1,127 @@</span>
<a href="#l13.5"></a><span id="l13.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l13.6"></a><span id="l13.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pipstack $</span>
<a href="#l13.7"></a><span id="l13.7" class="difflineplus">+# $Rev: 190 $</span>
<a href="#l13.8"></a><span id="l13.8" class="difflineplus">+</span>
<a href="#l13.9"></a><span id="l13.9" class="difflineplus">+# pipstack</span>
<a href="#l13.10"></a><span id="l13.10" class="difflineplus">+# Combine input PNG files into a multi-channel output PNG.</span>
<a href="#l13.11"></a><span id="l13.11" class="difflineplus">+</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+&quot;&quot;&quot;</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+pipstack file1.png [file2.png ...]</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineplus">+</span>
<a href="#l13.15"></a><span id="l13.15" class="difflineplus">+pipstack can be used to combine 3 greyscale PNG files into a colour, RGB,</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineplus">+PNG file.  In fact it is slightly more general than that.  The number of</span>
<a href="#l13.17"></a><span id="l13.17" class="difflineplus">+channels in the output PNG is equal to the sum of the numbers of</span>
<a href="#l13.18"></a><span id="l13.18" class="difflineplus">+channels in the input images.  It is an error if this sum exceeds 4 (the</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineplus">+maximum number of channels in a PNG image is 4, for an RGBA image).  The</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+output colour model corresponds to the number of channels: 1 -</span>
<a href="#l13.21"></a><span id="l13.21" class="difflineplus">+greyscale; 2 - greyscale+alpha; 3 - RGB; 4 - RGB+alpha.</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineplus">+</span>
<a href="#l13.23"></a><span id="l13.23" class="difflineplus">+In this way it is possible to combine 3 greyscale PNG files into an RGB</span>
<a href="#l13.24"></a><span id="l13.24" class="difflineplus">+PNG (a common expected use) as well as more esoteric options: rgb.png +</span>
<a href="#l13.25"></a><span id="l13.25" class="difflineplus">+grey.png = rgba.png; grey.png + grey.png = greyalpha.png.</span>
<a href="#l13.26"></a><span id="l13.26" class="difflineplus">+</span>
<a href="#l13.27"></a><span id="l13.27" class="difflineplus">+Color Profile, Gamma, and so on.</span>
<a href="#l13.28"></a><span id="l13.28" class="difflineplus">+</span>
<a href="#l13.29"></a><span id="l13.29" class="difflineplus">+[This is not implemented yet]</span>
<a href="#l13.30"></a><span id="l13.30" class="difflineplus">+</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineplus">+If an input has an ICC Profile (``iCCP`` chunk) then the output will</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+have an ICC Profile, but only if it is possible to combine all the input</span>
<a href="#l13.33"></a><span id="l13.33" class="difflineplus">+ICC Profiles.  It is possible to combine all the input ICC Profiles</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineplus">+only when: they all use the same Profile Connection Space; the PCS white</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineplus">+point is the same (specified in the header; should always be D50);</span>
<a href="#l13.36"></a><span id="l13.36" class="difflineplus">+possibly some other things I haven't thought of yet.</span>
<a href="#l13.37"></a><span id="l13.37" class="difflineplus">+</span>
<a href="#l13.38"></a><span id="l13.38" class="difflineplus">+If some of the inputs have a ``gAMA`` chunk (specifying gamma) and</span>
<a href="#l13.39"></a><span id="l13.39" class="difflineplus">+an output ICC Profile is being generated, then the gamma information</span>
<a href="#l13.40"></a><span id="l13.40" class="difflineplus">+will be incorporated into the ICC Profile.</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineplus">+</span>
<a href="#l13.42"></a><span id="l13.42" class="difflineplus">+When the output is an RGB colour type and the output ICC Profile is</span>
<a href="#l13.43"></a><span id="l13.43" class="difflineplus">+synthesized, it is necessary to supply colorant tags (``rXYZ`` and so</span>
<a href="#l13.44"></a><span id="l13.44" class="difflineplus">+on).  These are taken from ``sRGB``.</span>
<a href="#l13.45"></a><span id="l13.45" class="difflineplus">+</span>
<a href="#l13.46"></a><span id="l13.46" class="difflineplus">+If the input images have ``gAMA`` chunks and no input image has an ICC</span>
<a href="#l13.47"></a><span id="l13.47" class="difflineplus">+Profile then the output image will have a ``gAMA`` chunk, but only if</span>
<a href="#l13.48"></a><span id="l13.48" class="difflineplus">+all the ``gAMA`` chunks specify the same value.  Otherwise a warning</span>
<a href="#l13.49"></a><span id="l13.49" class="difflineplus">+will be emitted and no ``gAMA`` chunk.  It is possible to add or replace</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineplus">+a ``gAMA`` chunk using the ``pipchunk`` tool.</span>
<a href="#l13.51"></a><span id="l13.51" class="difflineplus">+</span>
<a href="#l13.52"></a><span id="l13.52" class="difflineplus">+gAMA, pHYs, iCCP, sRGB, tIME, any other chunks.</span>
<a href="#l13.53"></a><span id="l13.53" class="difflineplus">+&quot;&quot;&quot;</span>
<a href="#l13.54"></a><span id="l13.54" class="difflineplus">+</span>
<a href="#l13.55"></a><span id="l13.55" class="difflineplus">+class Error(Exception):</span>
<a href="#l13.56"></a><span id="l13.56" class="difflineplus">+    pass</span>
<a href="#l13.57"></a><span id="l13.57" class="difflineplus">+</span>
<a href="#l13.58"></a><span id="l13.58" class="difflineplus">+def stack(out, inp):</span>
<a href="#l13.59"></a><span id="l13.59" class="difflineplus">+    &quot;&quot;&quot;Stack the input PNG files into a single output PNG.&quot;&quot;&quot;</span>
<a href="#l13.60"></a><span id="l13.60" class="difflineplus">+</span>
<a href="#l13.61"></a><span id="l13.61" class="difflineplus">+    from array import array</span>
<a href="#l13.62"></a><span id="l13.62" class="difflineplus">+    import itertools</span>
<a href="#l13.63"></a><span id="l13.63" class="difflineplus">+    # Local module</span>
<a href="#l13.64"></a><span id="l13.64" class="difflineplus">+    import png</span>
<a href="#l13.65"></a><span id="l13.65" class="difflineplus">+</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineplus">+    if len(inp) &lt; 1:</span>
<a href="#l13.67"></a><span id="l13.67" class="difflineplus">+        raise Error(&quot;Required input is missing.&quot;)</span>
<a href="#l13.68"></a><span id="l13.68" class="difflineplus">+</span>
<a href="#l13.69"></a><span id="l13.69" class="difflineplus">+    l = map(png.Reader, inp)</span>
<a href="#l13.70"></a><span id="l13.70" class="difflineplus">+    # Let data be a list of (pixel,info) pairs.</span>
<a href="#l13.71"></a><span id="l13.71" class="difflineplus">+    data = map(lambda p: p.asDirect()[2:], l)</span>
<a href="#l13.72"></a><span id="l13.72" class="difflineplus">+    totalchannels = sum(map(lambda x: x[1]['planes'], data))</span>
<a href="#l13.73"></a><span id="l13.73" class="difflineplus">+</span>
<a href="#l13.74"></a><span id="l13.74" class="difflineplus">+    if not (0 &lt; totalchannels &lt;= 4):</span>
<a href="#l13.75"></a><span id="l13.75" class="difflineplus">+        raise Error(&quot;Too many channels in input.&quot;)</span>
<a href="#l13.76"></a><span id="l13.76" class="difflineplus">+    alpha = totalchannels in (2,4)</span>
<a href="#l13.77"></a><span id="l13.77" class="difflineplus">+    greyscale = totalchannels in (1,2)</span>
<a href="#l13.78"></a><span id="l13.78" class="difflineplus">+    bitdepth = []</span>
<a href="#l13.79"></a><span id="l13.79" class="difflineplus">+    for b in map(lambda x: x[1]['bitdepth'], data):</span>
<a href="#l13.80"></a><span id="l13.80" class="difflineplus">+        try:</span>
<a href="#l13.81"></a><span id="l13.81" class="difflineplus">+            if b == int(b):</span>
<a href="#l13.82"></a><span id="l13.82" class="difflineplus">+                bitdepth.append(b)</span>
<a href="#l13.83"></a><span id="l13.83" class="difflineplus">+                continue</span>
<a href="#l13.84"></a><span id="l13.84" class="difflineplus">+        except (TypeError, ValueError):</span>
<a href="#l13.85"></a><span id="l13.85" class="difflineplus">+            pass</span>
<a href="#l13.86"></a><span id="l13.86" class="difflineplus">+        # Assume a tuple.</span>
<a href="#l13.87"></a><span id="l13.87" class="difflineplus">+        bitdepth += b</span>
<a href="#l13.88"></a><span id="l13.88" class="difflineplus">+    # Currently, fail unless all bitdepths equal.</span>
<a href="#l13.89"></a><span id="l13.89" class="difflineplus">+    if len(set(bitdepth)) &gt; 1:</span>
<a href="#l13.90"></a><span id="l13.90" class="difflineplus">+        raise NotImplemented(&quot;Cannot cope when bitdepths differ - sorry!&quot;)</span>
<a href="#l13.91"></a><span id="l13.91" class="difflineplus">+    bitdepth = bitdepth[0]</span>
<a href="#l13.92"></a><span id="l13.92" class="difflineplus">+    arraytype = 'BH'[bitdepth &gt; 8]</span>
<a href="#l13.93"></a><span id="l13.93" class="difflineplus">+    size = map(lambda x: x[1]['size'], data)</span>
<a href="#l13.94"></a><span id="l13.94" class="difflineplus">+    # Currently, fail unless all images same size.</span>
<a href="#l13.95"></a><span id="l13.95" class="difflineplus">+    if len(set(size)) &gt; 1:</span>
<a href="#l13.96"></a><span id="l13.96" class="difflineplus">+        raise NotImplemented(&quot;Cannot cope when sizes differ - sorry!&quot;)</span>
<a href="#l13.97"></a><span id="l13.97" class="difflineplus">+    size = size[0]</span>
<a href="#l13.98"></a><span id="l13.98" class="difflineplus">+    # Values per row</span>
<a href="#l13.99"></a><span id="l13.99" class="difflineplus">+    vpr = totalchannels * size[0]</span>
<a href="#l13.100"></a><span id="l13.100" class="difflineplus">+    def iterstack():</span>
<a href="#l13.101"></a><span id="l13.101" class="difflineplus">+        # the izip call creates an iterator that yields the next row</span>
<a href="#l13.102"></a><span id="l13.102" class="difflineplus">+        # from all the input images combined into a tuple.</span>
<a href="#l13.103"></a><span id="l13.103" class="difflineplus">+        for irow in itertools.izip(*map(lambda x: x[0], data)):</span>
<a href="#l13.104"></a><span id="l13.104" class="difflineplus">+            row = array(arraytype, [0]*vpr)</span>
<a href="#l13.105"></a><span id="l13.105" class="difflineplus">+            # output channel</span>
<a href="#l13.106"></a><span id="l13.106" class="difflineplus">+            och = 0</span>
<a href="#l13.107"></a><span id="l13.107" class="difflineplus">+            for i,arow in enumerate(irow):</span>
<a href="#l13.108"></a><span id="l13.108" class="difflineplus">+                # ensure incoming row is an array</span>
<a href="#l13.109"></a><span id="l13.109" class="difflineplus">+                arow = array(arraytype, arow)</span>
<a href="#l13.110"></a><span id="l13.110" class="difflineplus">+                n = data[i][1]['planes']</span>
<a href="#l13.111"></a><span id="l13.111" class="difflineplus">+                for j in range(n):</span>
<a href="#l13.112"></a><span id="l13.112" class="difflineplus">+                    row[och::totalchannels] = arow[j::n]</span>
<a href="#l13.113"></a><span id="l13.113" class="difflineplus">+                    och += 1</span>
<a href="#l13.114"></a><span id="l13.114" class="difflineplus">+            yield row</span>
<a href="#l13.115"></a><span id="l13.115" class="difflineplus">+    w = png.Writer(size[0], size[1],</span>
<a href="#l13.116"></a><span id="l13.116" class="difflineplus">+      greyscale=greyscale, alpha=alpha, bitdepth=bitdepth)</span>
<a href="#l13.117"></a><span id="l13.117" class="difflineplus">+    w.write(out, iterstack())</span>
<a href="#l13.118"></a><span id="l13.118" class="difflineplus">+</span>
<a href="#l13.119"></a><span id="l13.119" class="difflineplus">+</span>
<a href="#l13.120"></a><span id="l13.120" class="difflineplus">+def main(argv=None):</span>
<a href="#l13.121"></a><span id="l13.121" class="difflineplus">+    import sys</span>
<a href="#l13.122"></a><span id="l13.122" class="difflineplus">+</span>
<a href="#l13.123"></a><span id="l13.123" class="difflineplus">+    if argv is None:</span>
<a href="#l13.124"></a><span id="l13.124" class="difflineplus">+        argv = sys.argv</span>
<a href="#l13.125"></a><span id="l13.125" class="difflineplus">+    argv = argv[1:]</span>
<a href="#l13.126"></a><span id="l13.126" class="difflineplus">+    arg = argv[:]</span>
<a href="#l13.127"></a><span id="l13.127" class="difflineplus">+    return stack(sys.stdout, arg)</span>
<a href="#l13.128"></a><span id="l13.128" class="difflineplus">+</span>
<a href="#l13.129"></a><span id="l13.129" class="difflineplus">+</span>
<a href="#l13.130"></a><span id="l13.130" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l13.131"></a><span id="l13.131" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1">new file mode 100644</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineminus">--- /dev/null</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineplus">+++ b/build/pypng/pipwindow</span>
<a href="#l14.4"></a><span id="l14.4" class="difflineat">@@ -0,0 +1,67 @@</span>
<a href="#l14.5"></a><span id="l14.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l14.6"></a><span id="l14.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pipwindow $</span>
<a href="#l14.7"></a><span id="l14.7" class="difflineplus">+# $Rev: 173 $</span>
<a href="#l14.8"></a><span id="l14.8" class="difflineplus">+</span>
<a href="#l14.9"></a><span id="l14.9" class="difflineplus">+# pipwindow</span>
<a href="#l14.10"></a><span id="l14.10" class="difflineplus">+# Tool to crop/expand an image to a rectangular window.  Come the</span>
<a href="#l14.11"></a><span id="l14.11" class="difflineplus">+# revolution this tool will allow the image and the window to be placed</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+# arbitrarily (in particular the window can be bigger than the picture</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+# and/or overlap it only partially) and the image can be OpenGL style</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineplus">+# border/repeat effects (repeat, mirrored repeat, clamp, fixed</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineplus">+# background colour, background colour from source file).  For now it</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineplus">+# only acts as crop.  The window must be no greater than the image in</span>
<a href="#l14.17"></a><span id="l14.17" class="difflineplus">+# both x and y.</span>
<a href="#l14.18"></a><span id="l14.18" class="difflineplus">+</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineplus">+def window(tl, br, inp, out):</span>
<a href="#l14.20"></a><span id="l14.20" class="difflineplus">+    &quot;&quot;&quot;Place a window onto the image and cut-out the resulting</span>
<a href="#l14.21"></a><span id="l14.21" class="difflineplus">+    rectangle.  The window is an axis aligned rectangle opposite corners</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineplus">+    at *tl* and *br* (each being an (x,y) pair). *inp* specifies the</span>
<a href="#l14.23"></a><span id="l14.23" class="difflineplus">+    input file which should be a PNG image.</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineplus">+    import png</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineplus">+    x,y,pixels,meta = r.asDirect()</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+    if not (0 &lt;= tl[0] &lt; br[0] &lt;= x):</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineplus">+        raise NotImplementedError()</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+    if not (0 &lt;= tl[1] &lt; br[1] &lt;= y):</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+        raise NotImplementedError()</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+    # Compute left and right bounds for each row</span>
<a href="#l14.35"></a><span id="l14.35" class="difflineplus">+    l = tl[0] * meta['planes']</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineplus">+    r = br[0] * meta['planes']</span>
<a href="#l14.37"></a><span id="l14.37" class="difflineplus">+    def itercrop():</span>
<a href="#l14.38"></a><span id="l14.38" class="difflineplus">+        &quot;&quot;&quot;An iterator to perform the crop.&quot;&quot;&quot;</span>
<a href="#l14.39"></a><span id="l14.39" class="difflineplus">+</span>
<a href="#l14.40"></a><span id="l14.40" class="difflineplus">+        for i,row in enumerate(pixels):</span>
<a href="#l14.41"></a><span id="l14.41" class="difflineplus">+            if i &lt; tl[1]:</span>
<a href="#l14.42"></a><span id="l14.42" class="difflineplus">+                continue</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineplus">+            if i &gt;= br[1]:</span>
<a href="#l14.44"></a><span id="l14.44" class="difflineplus">+                # Same as &quot;raise StopIteration&quot;</span>
<a href="#l14.45"></a><span id="l14.45" class="difflineplus">+                return</span>
<a href="#l14.46"></a><span id="l14.46" class="difflineplus">+            yield row[l:r]</span>
<a href="#l14.47"></a><span id="l14.47" class="difflineplus">+    meta['size'] = (br[0]-tl[0], br[1]-tl[1])</span>
<a href="#l14.48"></a><span id="l14.48" class="difflineplus">+    w = png.Writer(**meta)</span>
<a href="#l14.49"></a><span id="l14.49" class="difflineplus">+    w.write(out, itercrop())</span>
<a href="#l14.50"></a><span id="l14.50" class="difflineplus">+</span>
<a href="#l14.51"></a><span id="l14.51" class="difflineplus">+def main(argv=None):</span>
<a href="#l14.52"></a><span id="l14.52" class="difflineplus">+    import sys</span>
<a href="#l14.53"></a><span id="l14.53" class="difflineplus">+</span>
<a href="#l14.54"></a><span id="l14.54" class="difflineplus">+    if argv is None:</span>
<a href="#l14.55"></a><span id="l14.55" class="difflineplus">+        argv = sys.argv</span>
<a href="#l14.56"></a><span id="l14.56" class="difflineplus">+    argv = argv[1:]</span>
<a href="#l14.57"></a><span id="l14.57" class="difflineplus">+</span>
<a href="#l14.58"></a><span id="l14.58" class="difflineplus">+    tl = (0,0)</span>
<a href="#l14.59"></a><span id="l14.59" class="difflineplus">+    br = tuple(map(int, argv[:2]))</span>
<a href="#l14.60"></a><span id="l14.60" class="difflineplus">+    if len(argv) &gt;= 4:</span>
<a href="#l14.61"></a><span id="l14.61" class="difflineplus">+        tl = br</span>
<a href="#l14.62"></a><span id="l14.62" class="difflineplus">+        br = tuple(map(int, argv[2:4]))</span>
<a href="#l14.63"></a><span id="l14.63" class="difflineplus">+    if len(argv) in (2, 4):</span>
<a href="#l14.64"></a><span id="l14.64" class="difflineplus">+        f = sys.stdin</span>
<a href="#l14.65"></a><span id="l14.65" class="difflineplus">+    else:</span>
<a href="#l14.66"></a><span id="l14.66" class="difflineplus">+        f = open(argv[-1], 'rb')</span>
<a href="#l14.67"></a><span id="l14.67" class="difflineplus">+</span>
<a href="#l14.68"></a><span id="l14.68" class="difflineplus">+    return window(tl, br, f, sys.stdout)</span>
<a href="#l14.69"></a><span id="l14.69" class="difflineplus">+</span>
<a href="#l14.70"></a><span id="l14.70" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l14.71"></a><span id="l14.71" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1">new file mode 100644</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineminus">--- /dev/null</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineplus">+++ b/build/pypng/plan9topng.py</span>
<a href="#l15.4"></a><span id="l15.4" class="difflineat">@@ -0,0 +1,293 @@</span>
<a href="#l15.5"></a><span id="l15.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l15.6"></a><span id="l15.6" class="difflineplus">+# $Rev: 184 $</span>
<a href="#l15.7"></a><span id="l15.7" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/plan9topng.py $</span>
<a href="#l15.8"></a><span id="l15.8" class="difflineplus">+</span>
<a href="#l15.9"></a><span id="l15.9" class="difflineplus">+# Imported from //depot/prj/plan9topam/master/code/plan9topam.py#4 on</span>
<a href="#l15.10"></a><span id="l15.10" class="difflineplus">+# 2009-06-15.</span>
<a href="#l15.11"></a><span id="l15.11" class="difflineplus">+</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineplus">+&quot;&quot;&quot;Command line tool to convert from Plan 9 image format to PNG format.</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+</span>
<a href="#l15.14"></a><span id="l15.14" class="difflineplus">+Plan 9 image format description:</span>
<a href="#l15.15"></a><span id="l15.15" class="difflineplus">+http://plan9.bell-labs.com/magic/man2html/6/image</span>
<a href="#l15.16"></a><span id="l15.16" class="difflineplus">+&quot;&quot;&quot;</span>
<a href="#l15.17"></a><span id="l15.17" class="difflineplus">+</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineplus">+# http://www.python.org/doc/2.3.5/lib/module-itertools.html</span>
<a href="#l15.19"></a><span id="l15.19" class="difflineplus">+import itertools</span>
<a href="#l15.20"></a><span id="l15.20" class="difflineplus">+# http://www.python.org/doc/2.3.5/lib/module-re.html</span>
<a href="#l15.21"></a><span id="l15.21" class="difflineplus">+import re</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineplus">+# http://www.python.org/doc/2.3.5/lib/module-sys.html</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineplus">+import sys</span>
<a href="#l15.24"></a><span id="l15.24" class="difflineplus">+</span>
<a href="#l15.25"></a><span id="l15.25" class="difflineplus">+def block(s, n):</span>
<a href="#l15.26"></a><span id="l15.26" class="difflineplus">+    # See http://www.python.org/doc/2.6.2/library/functions.html#zip</span>
<a href="#l15.27"></a><span id="l15.27" class="difflineplus">+    return zip(*[iter(s)]*n)</span>
<a href="#l15.28"></a><span id="l15.28" class="difflineplus">+</span>
<a href="#l15.29"></a><span id="l15.29" class="difflineplus">+def convert(f, output=sys.stdout) :</span>
<a href="#l15.30"></a><span id="l15.30" class="difflineplus">+  &quot;&quot;&quot;Convert Plan 9 file to PNG format.  Works with either uncompressed</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineplus">+  or compressed files.</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+  &quot;&quot;&quot;</span>
<a href="#l15.33"></a><span id="l15.33" class="difflineplus">+</span>
<a href="#l15.34"></a><span id="l15.34" class="difflineplus">+  r = f.read(11)</span>
<a href="#l15.35"></a><span id="l15.35" class="difflineplus">+  if r == 'compressed\n' :</span>
<a href="#l15.36"></a><span id="l15.36" class="difflineplus">+    png(output, *decompress(f))</span>
<a href="#l15.37"></a><span id="l15.37" class="difflineplus">+  else :</span>
<a href="#l15.38"></a><span id="l15.38" class="difflineplus">+    png(output, *glue(f, r))</span>
<a href="#l15.39"></a><span id="l15.39" class="difflineplus">+</span>
<a href="#l15.40"></a><span id="l15.40" class="difflineplus">+</span>
<a href="#l15.41"></a><span id="l15.41" class="difflineplus">+def glue(f, r) :</span>
<a href="#l15.42"></a><span id="l15.42" class="difflineplus">+  &quot;&quot;&quot;Return (metadata, stream) pair where `r` is the initial portion of</span>
<a href="#l15.43"></a><span id="l15.43" class="difflineplus">+  the metadata that has already been read from the stream `f`.</span>
<a href="#l15.44"></a><span id="l15.44" class="difflineplus">+  &quot;&quot;&quot;</span>
<a href="#l15.45"></a><span id="l15.45" class="difflineplus">+</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineplus">+  r = r + f.read(60-len(r))</span>
<a href="#l15.47"></a><span id="l15.47" class="difflineplus">+  return (r, f)</span>
<a href="#l15.48"></a><span id="l15.48" class="difflineplus">+</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineplus">+def meta(r) :</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineplus">+  &quot;&quot;&quot;Convert 60 character string `r`, the metadata from an image file.</span>
<a href="#l15.51"></a><span id="l15.51" class="difflineplus">+  Returns a 5-tuple (*chan*,*minx*,*miny*,*limx*,*limy*).  5-tuples may</span>
<a href="#l15.52"></a><span id="l15.52" class="difflineplus">+  settle into lists in transit.</span>
<a href="#l15.53"></a><span id="l15.53" class="difflineplus">+  </span>
<a href="#l15.54"></a><span id="l15.54" class="difflineplus">+  As per http://plan9.bell-labs.com/magic/man2html/6/image the metadata</span>
<a href="#l15.55"></a><span id="l15.55" class="difflineplus">+  comprises 5 words separated by blanks.  As it happens each word starts</span>
<a href="#l15.56"></a><span id="l15.56" class="difflineplus">+  at an index that is a multiple of 12, but this routine does not care</span>
<a href="#l15.57"></a><span id="l15.57" class="difflineplus">+  about that.&quot;&quot;&quot;</span>
<a href="#l15.58"></a><span id="l15.58" class="difflineplus">+</span>
<a href="#l15.59"></a><span id="l15.59" class="difflineplus">+  r = r.split()</span>
<a href="#l15.60"></a><span id="l15.60" class="difflineplus">+  # :todo: raise FormatError</span>
<a href="#l15.61"></a><span id="l15.61" class="difflineplus">+  assert len(r) == 5</span>
<a href="#l15.62"></a><span id="l15.62" class="difflineplus">+  r = [r[0]] + map(int, r[1:])</span>
<a href="#l15.63"></a><span id="l15.63" class="difflineplus">+  return r</span>
<a href="#l15.64"></a><span id="l15.64" class="difflineplus">+</span>
<a href="#l15.65"></a><span id="l15.65" class="difflineplus">+def bitdepthof(pixel) :</span>
<a href="#l15.66"></a><span id="l15.66" class="difflineplus">+    &quot;&quot;&quot;Return the bitdepth for a Plan9 pixel format string.&quot;&quot;&quot;</span>
<a href="#l15.67"></a><span id="l15.67" class="difflineplus">+</span>
<a href="#l15.68"></a><span id="l15.68" class="difflineplus">+    maxd = 0</span>
<a href="#l15.69"></a><span id="l15.69" class="difflineplus">+    for c in re.findall(r'[a-z]\d*', pixel) :</span>
<a href="#l15.70"></a><span id="l15.70" class="difflineplus">+        if c[0] != 'x':</span>
<a href="#l15.71"></a><span id="l15.71" class="difflineplus">+            maxd = max(maxd, int(c[1:]))</span>
<a href="#l15.72"></a><span id="l15.72" class="difflineplus">+    return maxd</span>
<a href="#l15.73"></a><span id="l15.73" class="difflineplus">+</span>
<a href="#l15.74"></a><span id="l15.74" class="difflineplus">+def maxvalof(pixel):</span>
<a href="#l15.75"></a><span id="l15.75" class="difflineplus">+  &quot;&quot;&quot;Return the netpbm MAXVAL for a Plan9 pixel format string.&quot;&quot;&quot;</span>
<a href="#l15.76"></a><span id="l15.76" class="difflineplus">+</span>
<a href="#l15.77"></a><span id="l15.77" class="difflineplus">+  bitdepth = bitdepthof(pixel)</span>
<a href="#l15.78"></a><span id="l15.78" class="difflineplus">+  return (2**bitdepth)-1</span>
<a href="#l15.79"></a><span id="l15.79" class="difflineplus">+</span>
<a href="#l15.80"></a><span id="l15.80" class="difflineplus">+def pixmeta(metadata, f) :</span>
<a href="#l15.81"></a><span id="l15.81" class="difflineplus">+    &quot;&quot;&quot;Convert (uncompressed) Plan 9 image file to pair of (*metadata*,</span>
<a href="#l15.82"></a><span id="l15.82" class="difflineplus">+    *pixels*).  This is intended to be used by PyPNG format.  *metadata*</span>
<a href="#l15.83"></a><span id="l15.83" class="difflineplus">+    is the metadata returned in a dictionary, *pixels* is an iterator that</span>
<a href="#l15.84"></a><span id="l15.84" class="difflineplus">+    yields each row in boxed row flat pixel format.</span>
<a href="#l15.85"></a><span id="l15.85" class="difflineplus">+</span>
<a href="#l15.86"></a><span id="l15.86" class="difflineplus">+    `f`, the input file, should be cued up to the start of the image data.</span>
<a href="#l15.87"></a><span id="l15.87" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l15.88"></a><span id="l15.88" class="difflineplus">+</span>
<a href="#l15.89"></a><span id="l15.89" class="difflineplus">+    chan,minx,miny,limx,limy = metadata</span>
<a href="#l15.90"></a><span id="l15.90" class="difflineplus">+    rows = limy - miny</span>
<a href="#l15.91"></a><span id="l15.91" class="difflineplus">+    width = limx - minx</span>
<a href="#l15.92"></a><span id="l15.92" class="difflineplus">+    nchans = len(re.findall('[a-wyz]', chan))</span>
<a href="#l15.93"></a><span id="l15.93" class="difflineplus">+    alpha = 'a' in chan</span>
<a href="#l15.94"></a><span id="l15.94" class="difflineplus">+    # Iverson's convention for the win!</span>
<a href="#l15.95"></a><span id="l15.95" class="difflineplus">+    ncolour = nchans - alpha</span>
<a href="#l15.96"></a><span id="l15.96" class="difflineplus">+    greyscale = ncolour == 1</span>
<a href="#l15.97"></a><span id="l15.97" class="difflineplus">+    bitdepth = bitdepthof(chan)</span>
<a href="#l15.98"></a><span id="l15.98" class="difflineplus">+    maxval = 2**bitdepth - 1</span>
<a href="#l15.99"></a><span id="l15.99" class="difflineplus">+    # PNG style metadata</span>
<a href="#l15.100"></a><span id="l15.100" class="difflineplus">+    meta=dict(size=(width,rows), bitdepth=bitdepthof(chan),</span>
<a href="#l15.101"></a><span id="l15.101" class="difflineplus">+      greyscale=greyscale, alpha=alpha, planes=nchans)</span>
<a href="#l15.102"></a><span id="l15.102" class="difflineplus">+</span>
<a href="#l15.103"></a><span id="l15.103" class="difflineplus">+    return itertools.imap(lambda x: itertools.chain(*x),</span>
<a href="#l15.104"></a><span id="l15.104" class="difflineplus">+      block(unpack(f, rows, width, chan, maxval), width)), meta</span>
<a href="#l15.105"></a><span id="l15.105" class="difflineplus">+</span>
<a href="#l15.106"></a><span id="l15.106" class="difflineplus">+def png(out, metadata, f):</span>
<a href="#l15.107"></a><span id="l15.107" class="difflineplus">+    &quot;&quot;&quot;Convert to PNG format.  `metadata` should be a Plan9 5-tuple; `f`</span>
<a href="#l15.108"></a><span id="l15.108" class="difflineplus">+    the input file (see :meth:`pixmeta`).</span>
<a href="#l15.109"></a><span id="l15.109" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l15.110"></a><span id="l15.110" class="difflineplus">+</span>
<a href="#l15.111"></a><span id="l15.111" class="difflineplus">+    import png</span>
<a href="#l15.112"></a><span id="l15.112" class="difflineplus">+</span>
<a href="#l15.113"></a><span id="l15.113" class="difflineplus">+    pixels,meta = pixmeta(metadata, f)</span>
<a href="#l15.114"></a><span id="l15.114" class="difflineplus">+    p = png.Writer(**meta)</span>
<a href="#l15.115"></a><span id="l15.115" class="difflineplus">+    p.write(out, pixels)</span>
<a href="#l15.116"></a><span id="l15.116" class="difflineplus">+</span>
<a href="#l15.117"></a><span id="l15.117" class="difflineplus">+def spam():</span>
<a href="#l15.118"></a><span id="l15.118" class="difflineplus">+  &quot;&quot;&quot;Not really spam, but old PAM code, which is in limbo.&quot;&quot;&quot;</span>
<a href="#l15.119"></a><span id="l15.119" class="difflineplus">+</span>
<a href="#l15.120"></a><span id="l15.120" class="difflineplus">+  if nchans == 3 or nchans == 1 :</span>
<a href="#l15.121"></a><span id="l15.121" class="difflineplus">+    # PGM (P5) or PPM (P6) format.</span>
<a href="#l15.122"></a><span id="l15.122" class="difflineplus">+    output.write('P%d\n%d %d %d\n' % (5+(nchans==3), width, rows, maxval))</span>
<a href="#l15.123"></a><span id="l15.123" class="difflineplus">+  else :</span>
<a href="#l15.124"></a><span id="l15.124" class="difflineplus">+    # PAM format.</span>
<a href="#l15.125"></a><span id="l15.125" class="difflineplus">+    output.write(&quot;&quot;&quot;P7</span>
<a href="#l15.126"></a><span id="l15.126" class="difflineplus">+WIDTH %d</span>
<a href="#l15.127"></a><span id="l15.127" class="difflineplus">+HEIGHT %d</span>
<a href="#l15.128"></a><span id="l15.128" class="difflineplus">+DEPTH %d</span>
<a href="#l15.129"></a><span id="l15.129" class="difflineplus">+MAXVAL %d</span>
<a href="#l15.130"></a><span id="l15.130" class="difflineplus">+&quot;&quot;&quot; % (width, rows, nchans, maxval))</span>
<a href="#l15.131"></a><span id="l15.131" class="difflineplus">+</span>
<a href="#l15.132"></a><span id="l15.132" class="difflineplus">+def unpack(f, rows, width, pixel, maxval) :</span>
<a href="#l15.133"></a><span id="l15.133" class="difflineplus">+  &quot;&quot;&quot;Unpack `f` into pixels.  Assumes the pixel format is such that the depth</span>
<a href="#l15.134"></a><span id="l15.134" class="difflineplus">+  is either a multiple or a divisor of 8.</span>
<a href="#l15.135"></a><span id="l15.135" class="difflineplus">+  `f` is assumed to be an iterator that returns blocks of input such</span>
<a href="#l15.136"></a><span id="l15.136" class="difflineplus">+  that each block contains a whole number of pixels.  An iterator is</span>
<a href="#l15.137"></a><span id="l15.137" class="difflineplus">+  returned that yields each pixel as an n-tuple.  `pixel` describes the</span>
<a href="#l15.138"></a><span id="l15.138" class="difflineplus">+  pixel format using the Plan9 syntax (&quot;k8&quot;, &quot;r8g8b8&quot;, and so on).</span>
<a href="#l15.139"></a><span id="l15.139" class="difflineplus">+  &quot;&quot;&quot;</span>
<a href="#l15.140"></a><span id="l15.140" class="difflineplus">+</span>
<a href="#l15.141"></a><span id="l15.141" class="difflineplus">+  def mask(w) :</span>
<a href="#l15.142"></a><span id="l15.142" class="difflineplus">+    &quot;&quot;&quot;An integer, to be used as a mask, with bottom `w` bits set to 1.&quot;&quot;&quot;</span>
<a href="#l15.143"></a><span id="l15.143" class="difflineplus">+</span>
<a href="#l15.144"></a><span id="l15.144" class="difflineplus">+    return (1 &lt;&lt; w)-1</span>
<a href="#l15.145"></a><span id="l15.145" class="difflineplus">+</span>
<a href="#l15.146"></a><span id="l15.146" class="difflineplus">+  def deblock(f, depth, width) :</span>
<a href="#l15.147"></a><span id="l15.147" class="difflineplus">+    &quot;&quot;&quot;A &quot;packer&quot; used to convert multiple bytes into single pixels.</span>
<a href="#l15.148"></a><span id="l15.148" class="difflineplus">+    `depth` is the pixel depth in bits (&gt;= 8), `width` is the row width in</span>
<a href="#l15.149"></a><span id="l15.149" class="difflineplus">+    pixels.</span>
<a href="#l15.150"></a><span id="l15.150" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l15.151"></a><span id="l15.151" class="difflineplus">+</span>
<a href="#l15.152"></a><span id="l15.152" class="difflineplus">+    w = depth // 8</span>
<a href="#l15.153"></a><span id="l15.153" class="difflineplus">+    i = 0</span>
<a href="#l15.154"></a><span id="l15.154" class="difflineplus">+    for block in f :</span>
<a href="#l15.155"></a><span id="l15.155" class="difflineplus">+      for i in range(len(block)//w) :</span>
<a href="#l15.156"></a><span id="l15.156" class="difflineplus">+        p = block[w*i:w*(i+1)]</span>
<a href="#l15.157"></a><span id="l15.157" class="difflineplus">+        i += w</span>
<a href="#l15.158"></a><span id="l15.158" class="difflineplus">+        # Convert p to little-endian integer, x</span>
<a href="#l15.159"></a><span id="l15.159" class="difflineplus">+        x = 0</span>
<a href="#l15.160"></a><span id="l15.160" class="difflineplus">+        s = 1 # scale</span>
<a href="#l15.161"></a><span id="l15.161" class="difflineplus">+        for j in p :</span>
<a href="#l15.162"></a><span id="l15.162" class="difflineplus">+          x += s * ord(j)</span>
<a href="#l15.163"></a><span id="l15.163" class="difflineplus">+          s &lt;&lt;= 8</span>
<a href="#l15.164"></a><span id="l15.164" class="difflineplus">+        yield x</span>
<a href="#l15.165"></a><span id="l15.165" class="difflineplus">+</span>
<a href="#l15.166"></a><span id="l15.166" class="difflineplus">+  def bitfunge(f, depth, width) :</span>
<a href="#l15.167"></a><span id="l15.167" class="difflineplus">+    &quot;&quot;&quot;A &quot;packer&quot; used to convert single bytes into multiple pixels.</span>
<a href="#l15.168"></a><span id="l15.168" class="difflineplus">+    Depth is the pixel depth (&lt; 8), width is the row width in pixels.</span>
<a href="#l15.169"></a><span id="l15.169" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l15.170"></a><span id="l15.170" class="difflineplus">+</span>
<a href="#l15.171"></a><span id="l15.171" class="difflineplus">+    for block in f :</span>
<a href="#l15.172"></a><span id="l15.172" class="difflineplus">+      col = 0</span>
<a href="#l15.173"></a><span id="l15.173" class="difflineplus">+      for i in block :</span>
<a href="#l15.174"></a><span id="l15.174" class="difflineplus">+        x = ord(i)</span>
<a href="#l15.175"></a><span id="l15.175" class="difflineplus">+        for j in range(8/depth) :</span>
<a href="#l15.176"></a><span id="l15.176" class="difflineplus">+          yield x &gt;&gt; (8 - depth)</span>
<a href="#l15.177"></a><span id="l15.177" class="difflineplus">+          col += 1</span>
<a href="#l15.178"></a><span id="l15.178" class="difflineplus">+          if col == width :</span>
<a href="#l15.179"></a><span id="l15.179" class="difflineplus">+            # A row-end forces a new byte even if we haven't consumed</span>
<a href="#l15.180"></a><span id="l15.180" class="difflineplus">+            # all of the current byte.  Effectively rows are bit-padded</span>
<a href="#l15.181"></a><span id="l15.181" class="difflineplus">+            # to make a whole number of bytes.</span>
<a href="#l15.182"></a><span id="l15.182" class="difflineplus">+            col = 0</span>
<a href="#l15.183"></a><span id="l15.183" class="difflineplus">+            break</span>
<a href="#l15.184"></a><span id="l15.184" class="difflineplus">+          x &lt;&lt;= depth</span>
<a href="#l15.185"></a><span id="l15.185" class="difflineplus">+</span>
<a href="#l15.186"></a><span id="l15.186" class="difflineplus">+  # number of bits in each channel</span>
<a href="#l15.187"></a><span id="l15.187" class="difflineplus">+  chan = map(int, re.findall(r'\d+', pixel))</span>
<a href="#l15.188"></a><span id="l15.188" class="difflineplus">+  # type of each channel</span>
<a href="#l15.189"></a><span id="l15.189" class="difflineplus">+  type = re.findall('[a-z]', pixel)</span>
<a href="#l15.190"></a><span id="l15.190" class="difflineplus">+</span>
<a href="#l15.191"></a><span id="l15.191" class="difflineplus">+  depth = sum(chan)</span>
<a href="#l15.192"></a><span id="l15.192" class="difflineplus">+</span>
<a href="#l15.193"></a><span id="l15.193" class="difflineplus">+  # According to the value of depth pick a &quot;packer&quot; that either gathers</span>
<a href="#l15.194"></a><span id="l15.194" class="difflineplus">+  # multiple bytes into a single pixel (for depth &gt;= 8) or split bytes</span>
<a href="#l15.195"></a><span id="l15.195" class="difflineplus">+  # into several pixels (for depth &lt; 8)</span>
<a href="#l15.196"></a><span id="l15.196" class="difflineplus">+  if depth &gt;= 8 :</span>
<a href="#l15.197"></a><span id="l15.197" class="difflineplus">+    # </span>
<a href="#l15.198"></a><span id="l15.198" class="difflineplus">+    assert depth % 8 == 0</span>
<a href="#l15.199"></a><span id="l15.199" class="difflineplus">+    packer = deblock</span>
<a href="#l15.200"></a><span id="l15.200" class="difflineplus">+  else :</span>
<a href="#l15.201"></a><span id="l15.201" class="difflineplus">+    assert 8 % depth == 0</span>
<a href="#l15.202"></a><span id="l15.202" class="difflineplus">+    packer = bitfunge</span>
<a href="#l15.203"></a><span id="l15.203" class="difflineplus">+</span>
<a href="#l15.204"></a><span id="l15.204" class="difflineplus">+  for x in packer(f, depth, width) :</span>
<a href="#l15.205"></a><span id="l15.205" class="difflineplus">+    # x is the pixel as an unsigned integer</span>
<a href="#l15.206"></a><span id="l15.206" class="difflineplus">+    o = []</span>
<a href="#l15.207"></a><span id="l15.207" class="difflineplus">+    # This is a bit yucky.  Extract each channel from the _most_</span>
<a href="#l15.208"></a><span id="l15.208" class="difflineplus">+    # significant part of x.</span>
<a href="#l15.209"></a><span id="l15.209" class="difflineplus">+    for j in range(len(chan)) :</span>
<a href="#l15.210"></a><span id="l15.210" class="difflineplus">+      v = (x &gt;&gt; (depth - chan[j])) &amp; mask(chan[j])</span>
<a href="#l15.211"></a><span id="l15.211" class="difflineplus">+      x &lt;&lt;= chan[j]</span>
<a href="#l15.212"></a><span id="l15.212" class="difflineplus">+      if type[j] != 'x' :</span>
<a href="#l15.213"></a><span id="l15.213" class="difflineplus">+        # scale to maxval</span>
<a href="#l15.214"></a><span id="l15.214" class="difflineplus">+        v = v * float(maxval) / mask(chan[j])</span>
<a href="#l15.215"></a><span id="l15.215" class="difflineplus">+        v = int(v+0.5)</span>
<a href="#l15.216"></a><span id="l15.216" class="difflineplus">+        o.append(v)</span>
<a href="#l15.217"></a><span id="l15.217" class="difflineplus">+    yield o</span>
<a href="#l15.218"></a><span id="l15.218" class="difflineplus">+</span>
<a href="#l15.219"></a><span id="l15.219" class="difflineplus">+</span>
<a href="#l15.220"></a><span id="l15.220" class="difflineplus">+def decompress(f) :</span>
<a href="#l15.221"></a><span id="l15.221" class="difflineplus">+  &quot;&quot;&quot;Decompress a Plan 9 image file.  Assumes f is already cued past the</span>
<a href="#l15.222"></a><span id="l15.222" class="difflineplus">+  initial 'compressed\n' string.</span>
<a href="#l15.223"></a><span id="l15.223" class="difflineplus">+  &quot;&quot;&quot;</span>
<a href="#l15.224"></a><span id="l15.224" class="difflineplus">+</span>
<a href="#l15.225"></a><span id="l15.225" class="difflineplus">+  r = meta(f.read(60))</span>
<a href="#l15.226"></a><span id="l15.226" class="difflineplus">+  return r, decomprest(f, r[4])</span>
<a href="#l15.227"></a><span id="l15.227" class="difflineplus">+</span>
<a href="#l15.228"></a><span id="l15.228" class="difflineplus">+</span>
<a href="#l15.229"></a><span id="l15.229" class="difflineplus">+def decomprest(f, rows) :</span>
<a href="#l15.230"></a><span id="l15.230" class="difflineplus">+  &quot;&quot;&quot;Iterator that decompresses the rest of a file once the metadata</span>
<a href="#l15.231"></a><span id="l15.231" class="difflineplus">+  have been consumed.&quot;&quot;&quot;</span>
<a href="#l15.232"></a><span id="l15.232" class="difflineplus">+</span>
<a href="#l15.233"></a><span id="l15.233" class="difflineplus">+  row = 0</span>
<a href="#l15.234"></a><span id="l15.234" class="difflineplus">+  while row &lt; rows :</span>
<a href="#l15.235"></a><span id="l15.235" class="difflineplus">+    row,o = deblock(f)</span>
<a href="#l15.236"></a><span id="l15.236" class="difflineplus">+    yield o</span>
<a href="#l15.237"></a><span id="l15.237" class="difflineplus">+</span>
<a href="#l15.238"></a><span id="l15.238" class="difflineplus">+</span>
<a href="#l15.239"></a><span id="l15.239" class="difflineplus">+def deblock(f) :</span>
<a href="#l15.240"></a><span id="l15.240" class="difflineplus">+  &quot;&quot;&quot;Decompress a single block from a compressed Plan 9 image file.</span>
<a href="#l15.241"></a><span id="l15.241" class="difflineplus">+  Each block starts with 2 decimal strings of 12 bytes each.  Yields a</span>
<a href="#l15.242"></a><span id="l15.242" class="difflineplus">+  sequence of (row, data) pairs where row is the total number of rows</span>
<a href="#l15.243"></a><span id="l15.243" class="difflineplus">+  processed according to the file format and data is the decompressed</span>
<a href="#l15.244"></a><span id="l15.244" class="difflineplus">+  data for a set of rows.&quot;&quot;&quot;</span>
<a href="#l15.245"></a><span id="l15.245" class="difflineplus">+</span>
<a href="#l15.246"></a><span id="l15.246" class="difflineplus">+  row = int(f.read(12))</span>
<a href="#l15.247"></a><span id="l15.247" class="difflineplus">+  size = int(f.read(12))</span>
<a href="#l15.248"></a><span id="l15.248" class="difflineplus">+  if not (0 &lt;= size &lt;= 6000) :</span>
<a href="#l15.249"></a><span id="l15.249" class="difflineplus">+    raise 'block has invalid size; not a Plan 9 image file?'</span>
<a href="#l15.250"></a><span id="l15.250" class="difflineplus">+</span>
<a href="#l15.251"></a><span id="l15.251" class="difflineplus">+  # Since each block is at most 6000 bytes we may as well read it all in</span>
<a href="#l15.252"></a><span id="l15.252" class="difflineplus">+  # one go.</span>
<a href="#l15.253"></a><span id="l15.253" class="difflineplus">+  d = f.read(size)</span>
<a href="#l15.254"></a><span id="l15.254" class="difflineplus">+  i = 0</span>
<a href="#l15.255"></a><span id="l15.255" class="difflineplus">+  o = []</span>
<a href="#l15.256"></a><span id="l15.256" class="difflineplus">+</span>
<a href="#l15.257"></a><span id="l15.257" class="difflineplus">+  while i &lt; size :</span>
<a href="#l15.258"></a><span id="l15.258" class="difflineplus">+    x = ord(d[i])</span>
<a href="#l15.259"></a><span id="l15.259" class="difflineplus">+    i += 1</span>
<a href="#l15.260"></a><span id="l15.260" class="difflineplus">+    if x &amp; 0x80 :</span>
<a href="#l15.261"></a><span id="l15.261" class="difflineplus">+      x = (x &amp; 0x7f) + 1</span>
<a href="#l15.262"></a><span id="l15.262" class="difflineplus">+      lit = d[i:i+x]</span>
<a href="#l15.263"></a><span id="l15.263" class="difflineplus">+      i += x</span>
<a href="#l15.264"></a><span id="l15.264" class="difflineplus">+      o.extend(lit)</span>
<a href="#l15.265"></a><span id="l15.265" class="difflineplus">+      continue</span>
<a href="#l15.266"></a><span id="l15.266" class="difflineplus">+    # x's high-order bit is 0</span>
<a href="#l15.267"></a><span id="l15.267" class="difflineplus">+    l = (x &gt;&gt; 2) + 3</span>
<a href="#l15.268"></a><span id="l15.268" class="difflineplus">+    # Offset is made from bottom 2 bits of x and all 8 bits of next</span>
<a href="#l15.269"></a><span id="l15.269" class="difflineplus">+    # byte.  http://plan9.bell-labs.com/magic/man2html/6/image doesn't</span>
<a href="#l15.270"></a><span id="l15.270" class="difflineplus">+    # say whether x's 2 bits are most signiificant or least significant.</span>
<a href="#l15.271"></a><span id="l15.271" class="difflineplus">+    # But it is clear from inspecting a random file,</span>
<a href="#l15.272"></a><span id="l15.272" class="difflineplus">+    # http://plan9.bell-labs.com/sources/plan9/sys/games/lib/sokoban/images/cargo.bit</span>
<a href="#l15.273"></a><span id="l15.273" class="difflineplus">+    # that x's 2 bit are most significant.</span>
<a href="#l15.274"></a><span id="l15.274" class="difflineplus">+    # </span>
<a href="#l15.275"></a><span id="l15.275" class="difflineplus">+    offset = (x &amp; 3) &lt;&lt; 8</span>
<a href="#l15.276"></a><span id="l15.276" class="difflineplus">+    offset |= ord(d[i])</span>
<a href="#l15.277"></a><span id="l15.277" class="difflineplus">+    i += 1</span>
<a href="#l15.278"></a><span id="l15.278" class="difflineplus">+    # Note: complement operator neatly maps (0 to 1023) to (-1 to</span>
<a href="#l15.279"></a><span id="l15.279" class="difflineplus">+    # -1024).  Adding len(o) gives a (non-negative) offset into o from</span>
<a href="#l15.280"></a><span id="l15.280" class="difflineplus">+    # which to start indexing.</span>
<a href="#l15.281"></a><span id="l15.281" class="difflineplus">+    offset = ~offset + len(o)</span>
<a href="#l15.282"></a><span id="l15.282" class="difflineplus">+    if offset &lt; 0 :</span>
<a href="#l15.283"></a><span id="l15.283" class="difflineplus">+      raise 'byte offset indexes off the begininning of the output buffer; not a Plan 9 image file?'</span>
<a href="#l15.284"></a><span id="l15.284" class="difflineplus">+    for j in range(l) :</span>
<a href="#l15.285"></a><span id="l15.285" class="difflineplus">+      o.append(o[offset+j])</span>
<a href="#l15.286"></a><span id="l15.286" class="difflineplus">+  return row,''.join(o)</span>
<a href="#l15.287"></a><span id="l15.287" class="difflineplus">+</span>
<a href="#l15.288"></a><span id="l15.288" class="difflineplus">+def main(argv=None) :</span>
<a href="#l15.289"></a><span id="l15.289" class="difflineplus">+  if argv is None :</span>
<a href="#l15.290"></a><span id="l15.290" class="difflineplus">+    argv = sys.argv</span>
<a href="#l15.291"></a><span id="l15.291" class="difflineplus">+  if len(sys.argv) &lt;= 1 :</span>
<a href="#l15.292"></a><span id="l15.292" class="difflineplus">+    return convert(sys.stdin)</span>
<a href="#l15.293"></a><span id="l15.293" class="difflineplus">+  else :</span>
<a href="#l15.294"></a><span id="l15.294" class="difflineplus">+    return convert(open(argv[1], 'rb'))</span>
<a href="#l15.295"></a><span id="l15.295" class="difflineplus">+</span>
<a href="#l15.296"></a><span id="l15.296" class="difflineplus">+if __name__ == '__main__' :</span>
<a href="#l15.297"></a><span id="l15.297" class="difflineplus">+  sys.exit(main())</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1">new file mode 100644</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineminus">--- /dev/null</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineplus">+++ b/build/pypng/png.py</span>
<a href="#l16.4"></a><span id="l16.4" class="difflineat">@@ -0,0 +1,3785 @@</span>
<a href="#l16.5"></a><span id="l16.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l16.6"></a><span id="l16.6" class="difflineplus">+</span>
<a href="#l16.7"></a><span id="l16.7" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/png.py $</span>
<a href="#l16.8"></a><span id="l16.8" class="difflineplus">+# $Rev: 228 $</span>
<a href="#l16.9"></a><span id="l16.9" class="difflineplus">+</span>
<a href="#l16.10"></a><span id="l16.10" class="difflineplus">+# png.py - PNG encoder/decoder in pure Python</span>
<a href="#l16.11"></a><span id="l16.11" class="difflineplus">+#</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineplus">+# Copyright (C) 2006 Johann C. Rocholl &lt;johann@browsershots.org&gt;</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+# Portions Copyright (C) 2009 David Jones &lt;drj@pobox.com&gt;</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineplus">+# And probably portions Copyright (C) 2006 Nicko van Someren &lt;nicko@nicko.org&gt;</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineplus">+#</span>
<a href="#l16.16"></a><span id="l16.16" class="difflineplus">+# Original concept by Johann C. Rocholl.</span>
<a href="#l16.17"></a><span id="l16.17" class="difflineplus">+#</span>
<a href="#l16.18"></a><span id="l16.18" class="difflineplus">+# LICENSE (The MIT License)</span>
<a href="#l16.19"></a><span id="l16.19" class="difflineplus">+#</span>
<a href="#l16.20"></a><span id="l16.20" class="difflineplus">+# Permission is hereby granted, free of charge, to any person</span>
<a href="#l16.21"></a><span id="l16.21" class="difflineplus">+# obtaining a copy of this software and associated documentation files</span>
<a href="#l16.22"></a><span id="l16.22" class="difflineplus">+# (the &quot;Software&quot;), to deal in the Software without restriction,</span>
<a href="#l16.23"></a><span id="l16.23" class="difflineplus">+# including without limitation the rights to use, copy, modify, merge,</span>
<a href="#l16.24"></a><span id="l16.24" class="difflineplus">+# publish, distribute, sublicense, and/or sell copies of the Software,</span>
<a href="#l16.25"></a><span id="l16.25" class="difflineplus">+# and to permit persons to whom the Software is furnished to do so,</span>
<a href="#l16.26"></a><span id="l16.26" class="difflineplus">+# subject to the following conditions:</span>
<a href="#l16.27"></a><span id="l16.27" class="difflineplus">+#</span>
<a href="#l16.28"></a><span id="l16.28" class="difflineplus">+# The above copyright notice and this permission notice shall be</span>
<a href="#l16.29"></a><span id="l16.29" class="difflineplus">+# included in all copies or substantial portions of the Software.</span>
<a href="#l16.30"></a><span id="l16.30" class="difflineplus">+#</span>
<a href="#l16.31"></a><span id="l16.31" class="difflineplus">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<a href="#l16.32"></a><span id="l16.32" class="difflineplus">+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<a href="#l16.33"></a><span id="l16.33" class="difflineplus">+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<a href="#l16.34"></a><span id="l16.34" class="difflineplus">+# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<a href="#l16.35"></a><span id="l16.35" class="difflineplus">+# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<a href="#l16.36"></a><span id="l16.36" class="difflineplus">+# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<a href="#l16.37"></a><span id="l16.37" class="difflineplus">+# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<a href="#l16.38"></a><span id="l16.38" class="difflineplus">+# SOFTWARE.</span>
<a href="#l16.39"></a><span id="l16.39" class="difflineplus">+#</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineplus">+# Changelog (recent first):</span>
<a href="#l16.41"></a><span id="l16.41" class="difflineplus">+# 2009-03-11 David: interlaced bit depth &lt; 8 (writing).</span>
<a href="#l16.42"></a><span id="l16.42" class="difflineplus">+# 2009-03-10 David: interlaced bit depth &lt; 8 (reading).</span>
<a href="#l16.43"></a><span id="l16.43" class="difflineplus">+# 2009-03-04 David: Flat and Boxed pixel formats.</span>
<a href="#l16.44"></a><span id="l16.44" class="difflineplus">+# 2009-02-26 David: Palette support (writing).</span>
<a href="#l16.45"></a><span id="l16.45" class="difflineplus">+# 2009-02-23 David: Bit-depths &lt; 8; better PNM support.</span>
<a href="#l16.46"></a><span id="l16.46" class="difflineplus">+# 2006-06-17 Nicko: Reworked into a class, faster interlacing.</span>
<a href="#l16.47"></a><span id="l16.47" class="difflineplus">+# 2006-06-17 Johann: Very simple prototype PNG decoder.</span>
<a href="#l16.48"></a><span id="l16.48" class="difflineplus">+# 2006-06-17 Nicko: Test suite with various image generators.</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineplus">+# 2006-06-17 Nicko: Alpha-channel, grey-scale, 16-bit/plane support.</span>
<a href="#l16.50"></a><span id="l16.50" class="difflineplus">+# 2006-06-15 Johann: Scanline iterator interface for large input files.</span>
<a href="#l16.51"></a><span id="l16.51" class="difflineplus">+# 2006-06-09 Johann: Very simple prototype PNG encoder.</span>
<a href="#l16.52"></a><span id="l16.52" class="difflineplus">+</span>
<a href="#l16.53"></a><span id="l16.53" class="difflineplus">+# Incorporated into Bangai-O Development Tools by drj on 2009-02-11 from</span>
<a href="#l16.54"></a><span id="l16.54" class="difflineplus">+# http://trac.browsershots.org/browser/trunk/pypng/lib/png.py?rev=2885</span>
<a href="#l16.55"></a><span id="l16.55" class="difflineplus">+</span>
<a href="#l16.56"></a><span id="l16.56" class="difflineplus">+# Incorporated into pypng by drj on 2009-03-12 from</span>
<a href="#l16.57"></a><span id="l16.57" class="difflineplus">+# //depot/prj/bangaio/master/code/png.py#67</span>
<a href="#l16.58"></a><span id="l16.58" class="difflineplus">+</span>
<a href="#l16.59"></a><span id="l16.59" class="difflineplus">+</span>
<a href="#l16.60"></a><span id="l16.60" class="difflineplus">+&quot;&quot;&quot;</span>
<a href="#l16.61"></a><span id="l16.61" class="difflineplus">+Pure Python PNG Reader/Writer</span>
<a href="#l16.62"></a><span id="l16.62" class="difflineplus">+</span>
<a href="#l16.63"></a><span id="l16.63" class="difflineplus">+This Python module implements support for PNG images (see PNG</span>
<a href="#l16.64"></a><span id="l16.64" class="difflineplus">+specification at http://www.w3.org/TR/2003/REC-PNG-20031110/ ). It reads</span>
<a href="#l16.65"></a><span id="l16.65" class="difflineplus">+and writes PNG files with all allowable bit depths (1/2/4/8/16/24/32/48/64</span>
<a href="#l16.66"></a><span id="l16.66" class="difflineplus">+bits per pixel) and colour combinations: greyscale (1/2/4/8/16 bit); RGB,</span>
<a href="#l16.67"></a><span id="l16.67" class="difflineplus">+RGBA, LA (greyscale with alpha) with 8/16 bits per channel; colour mapped</span>
<a href="#l16.68"></a><span id="l16.68" class="difflineplus">+images (1/2/4/8 bit).  Adam7 interlacing is supported for reading and</span>
<a href="#l16.69"></a><span id="l16.69" class="difflineplus">+writing.  A number of optional chunks can be specified (when writing)</span>
<a href="#l16.70"></a><span id="l16.70" class="difflineplus">+and understood (when reading): ``tRNS``, ``bKGD``, ``gAMA``.</span>
<a href="#l16.71"></a><span id="l16.71" class="difflineplus">+</span>
<a href="#l16.72"></a><span id="l16.72" class="difflineplus">+For help, type ``import png; help(png)`` in your python interpreter.</span>
<a href="#l16.73"></a><span id="l16.73" class="difflineplus">+</span>
<a href="#l16.74"></a><span id="l16.74" class="difflineplus">+A good place to start is the :class:`Reader` and :class:`Writer` classes.</span>
<a href="#l16.75"></a><span id="l16.75" class="difflineplus">+</span>
<a href="#l16.76"></a><span id="l16.76" class="difflineplus">+Requires Python 2.3.  Limited support is available for Python 2.2, but</span>
<a href="#l16.77"></a><span id="l16.77" class="difflineplus">+not everything works.  Best with Python 2.4 and higher.  Installation is</span>
<a href="#l16.78"></a><span id="l16.78" class="difflineplus">+trivial, but see the ``README.txt`` file (with the source distribution)</span>
<a href="#l16.79"></a><span id="l16.79" class="difflineplus">+for details.</span>
<a href="#l16.80"></a><span id="l16.80" class="difflineplus">+</span>
<a href="#l16.81"></a><span id="l16.81" class="difflineplus">+This file can also be used as a command-line utility to convert</span>
<a href="#l16.82"></a><span id="l16.82" class="difflineplus">+`Netpbm &lt;http://netpbm.sourceforge.net/&gt;`_ PNM files to PNG, and the reverse conversion from PNG to</span>
<a href="#l16.83"></a><span id="l16.83" class="difflineplus">+PNM. The interface is similar to that of the ``pnmtopng`` program from</span>
<a href="#l16.84"></a><span id="l16.84" class="difflineplus">+Netpbm.  Type ``python png.py --help`` at the shell prompt</span>
<a href="#l16.85"></a><span id="l16.85" class="difflineplus">+for usage and a list of options.</span>
<a href="#l16.86"></a><span id="l16.86" class="difflineplus">+</span>
<a href="#l16.87"></a><span id="l16.87" class="difflineplus">+A note on spelling and terminology</span>
<a href="#l16.88"></a><span id="l16.88" class="difflineplus">+----------------------------------</span>
<a href="#l16.89"></a><span id="l16.89" class="difflineplus">+</span>
<a href="#l16.90"></a><span id="l16.90" class="difflineplus">+Generally British English spelling is used in the documentation.  So</span>
<a href="#l16.91"></a><span id="l16.91" class="difflineplus">+that's &quot;greyscale&quot; and &quot;colour&quot;.  This not only matches the author's</span>
<a href="#l16.92"></a><span id="l16.92" class="difflineplus">+native language, it's also used by the PNG specification.</span>
<a href="#l16.93"></a><span id="l16.93" class="difflineplus">+</span>
<a href="#l16.94"></a><span id="l16.94" class="difflineplus">+The major colour models supported by PNG (and hence by PyPNG) are:</span>
<a href="#l16.95"></a><span id="l16.95" class="difflineplus">+greyscale, RGB, greyscale--alpha, RGB--alpha.  These are sometimes</span>
<a href="#l16.96"></a><span id="l16.96" class="difflineplus">+referred to using the abbreviations: L, RGB, LA, RGBA.  In this case</span>
<a href="#l16.97"></a><span id="l16.97" class="difflineplus">+each letter abbreviates a single channel: *L* is for Luminance or Luma or</span>
<a href="#l16.98"></a><span id="l16.98" class="difflineplus">+Lightness which is the channel used in greyscale images; *R*, *G*, *B* stand</span>
<a href="#l16.99"></a><span id="l16.99" class="difflineplus">+for Red, Green, Blue, the components of a colour image; *A* stands for</span>
<a href="#l16.100"></a><span id="l16.100" class="difflineplus">+Alpha, the opacity channel (used for transparency effects, but higher</span>
<a href="#l16.101"></a><span id="l16.101" class="difflineplus">+values are more opaque, so it makes sense to call it opacity).</span>
<a href="#l16.102"></a><span id="l16.102" class="difflineplus">+</span>
<a href="#l16.103"></a><span id="l16.103" class="difflineplus">+A note on formats</span>
<a href="#l16.104"></a><span id="l16.104" class="difflineplus">+-----------------</span>
<a href="#l16.105"></a><span id="l16.105" class="difflineplus">+</span>
<a href="#l16.106"></a><span id="l16.106" class="difflineplus">+When getting pixel data out of this module (reading) and presenting</span>
<a href="#l16.107"></a><span id="l16.107" class="difflineplus">+data to this module (writing) there are a number of ways the data could</span>
<a href="#l16.108"></a><span id="l16.108" class="difflineplus">+be represented as a Python value.  Generally this module uses one of</span>
<a href="#l16.109"></a><span id="l16.109" class="difflineplus">+three formats called &quot;flat row flat pixel&quot;, &quot;boxed row flat pixel&quot;, and</span>
<a href="#l16.110"></a><span id="l16.110" class="difflineplus">+&quot;boxed row boxed pixel&quot;.  Basically the concern is whether each pixel</span>
<a href="#l16.111"></a><span id="l16.111" class="difflineplus">+and each row comes in its own little tuple (box), or not.</span>
<a href="#l16.112"></a><span id="l16.112" class="difflineplus">+</span>
<a href="#l16.113"></a><span id="l16.113" class="difflineplus">+Consider an image that is 3 pixels wide by 2 pixels high, and each pixel</span>
<a href="#l16.114"></a><span id="l16.114" class="difflineplus">+has RGB components:</span>
<a href="#l16.115"></a><span id="l16.115" class="difflineplus">+</span>
<a href="#l16.116"></a><span id="l16.116" class="difflineplus">+Boxed row flat pixel::</span>
<a href="#l16.117"></a><span id="l16.117" class="difflineplus">+</span>
<a href="#l16.118"></a><span id="l16.118" class="difflineplus">+  list([R,G,B, R,G,B, R,G,B],</span>
<a href="#l16.119"></a><span id="l16.119" class="difflineplus">+       [R,G,B, R,G,B, R,G,B])</span>
<a href="#l16.120"></a><span id="l16.120" class="difflineplus">+</span>
<a href="#l16.121"></a><span id="l16.121" class="difflineplus">+Each row appears as its own list, but the pixels are flattened so that</span>
<a href="#l16.122"></a><span id="l16.122" class="difflineplus">+three values for one pixel simply follow the three values for the previous</span>
<a href="#l16.123"></a><span id="l16.123" class="difflineplus">+pixel.  This is the most common format used, because it provides a good</span>
<a href="#l16.124"></a><span id="l16.124" class="difflineplus">+compromise between space and convenience.  PyPNG regards itself as</span>
<a href="#l16.125"></a><span id="l16.125" class="difflineplus">+at liberty to replace any sequence type with any sufficiently compatible</span>
<a href="#l16.126"></a><span id="l16.126" class="difflineplus">+other sequence type; in practice each row is an array (from the array</span>
<a href="#l16.127"></a><span id="l16.127" class="difflineplus">+module), and the outer list is sometimes an iterator rather than an</span>
<a href="#l16.128"></a><span id="l16.128" class="difflineplus">+explicit list (so that streaming is possible).</span>
<a href="#l16.129"></a><span id="l16.129" class="difflineplus">+</span>
<a href="#l16.130"></a><span id="l16.130" class="difflineplus">+Flat row flat pixel::</span>
<a href="#l16.131"></a><span id="l16.131" class="difflineplus">+</span>
<a href="#l16.132"></a><span id="l16.132" class="difflineplus">+  [R,G,B, R,G,B, R,G,B,</span>
<a href="#l16.133"></a><span id="l16.133" class="difflineplus">+   R,G,B, R,G,B, R,G,B]</span>
<a href="#l16.134"></a><span id="l16.134" class="difflineplus">+</span>
<a href="#l16.135"></a><span id="l16.135" class="difflineplus">+The entire image is one single giant sequence of colour values.</span>
<a href="#l16.136"></a><span id="l16.136" class="difflineplus">+Generally an array will be used (to save space), not a list.</span>
<a href="#l16.137"></a><span id="l16.137" class="difflineplus">+</span>
<a href="#l16.138"></a><span id="l16.138" class="difflineplus">+Boxed row boxed pixel::</span>
<a href="#l16.139"></a><span id="l16.139" class="difflineplus">+</span>
<a href="#l16.140"></a><span id="l16.140" class="difflineplus">+  list([ (R,G,B), (R,G,B), (R,G,B) ],</span>
<a href="#l16.141"></a><span id="l16.141" class="difflineplus">+       [ (R,G,B), (R,G,B), (R,G,B) ])</span>
<a href="#l16.142"></a><span id="l16.142" class="difflineplus">+</span>
<a href="#l16.143"></a><span id="l16.143" class="difflineplus">+Each row appears in its own list, but each pixel also appears in its own</span>
<a href="#l16.144"></a><span id="l16.144" class="difflineplus">+tuple.  A serious memory burn in Python.</span>
<a href="#l16.145"></a><span id="l16.145" class="difflineplus">+</span>
<a href="#l16.146"></a><span id="l16.146" class="difflineplus">+In all cases the top row comes first, and for each row the pixels are</span>
<a href="#l16.147"></a><span id="l16.147" class="difflineplus">+ordered from left-to-right.  Within a pixel the values appear in the</span>
<a href="#l16.148"></a><span id="l16.148" class="difflineplus">+order, R-G-B-A (or L-A for greyscale--alpha).</span>
<a href="#l16.149"></a><span id="l16.149" class="difflineplus">+</span>
<a href="#l16.150"></a><span id="l16.150" class="difflineplus">+There is a fourth format, mentioned because it is used internally,</span>
<a href="#l16.151"></a><span id="l16.151" class="difflineplus">+is close to what lies inside a PNG file itself, and has some support</span>
<a href="#l16.152"></a><span id="l16.152" class="difflineplus">+from the public API.  This format is called packed.  When packed,</span>
<a href="#l16.153"></a><span id="l16.153" class="difflineplus">+each row is a sequence of bytes (integers from 0 to 255), just as</span>
<a href="#l16.154"></a><span id="l16.154" class="difflineplus">+it is before PNG scanline filtering is applied.  When the bit depth</span>
<a href="#l16.155"></a><span id="l16.155" class="difflineplus">+is 8 this is essentially the same as boxed row flat pixel; when the</span>
<a href="#l16.156"></a><span id="l16.156" class="difflineplus">+bit depth is less than 8, several pixels are packed into each byte;</span>
<a href="#l16.157"></a><span id="l16.157" class="difflineplus">+when the bit depth is 16 (the only value more than 8 that is supported</span>
<a href="#l16.158"></a><span id="l16.158" class="difflineplus">+by the PNG image format) each pixel value is decomposed into 2 bytes</span>
<a href="#l16.159"></a><span id="l16.159" class="difflineplus">+(and `packed` is a misnomer).  This format is used by the</span>
<a href="#l16.160"></a><span id="l16.160" class="difflineplus">+:meth:`Writer.write_packed` method.  It isn't usually a convenient</span>
<a href="#l16.161"></a><span id="l16.161" class="difflineplus">+format, but may be just right if the source data for the PNG image</span>
<a href="#l16.162"></a><span id="l16.162" class="difflineplus">+comes from something that uses a similar format (for example, 1-bit</span>
<a href="#l16.163"></a><span id="l16.163" class="difflineplus">+BMPs, or another PNG file).</span>
<a href="#l16.164"></a><span id="l16.164" class="difflineplus">+</span>
<a href="#l16.165"></a><span id="l16.165" class="difflineplus">+And now, my famous members</span>
<a href="#l16.166"></a><span id="l16.166" class="difflineplus">+--------------------------</span>
<a href="#l16.167"></a><span id="l16.167" class="difflineplus">+&quot;&quot;&quot;</span>
<a href="#l16.168"></a><span id="l16.168" class="difflineplus">+</span>
<a href="#l16.169"></a><span id="l16.169" class="difflineplus">+# http://www.python.org/doc/2.2.3/whatsnew/node5.html</span>
<a href="#l16.170"></a><span id="l16.170" class="difflineplus">+from __future__ import generators</span>
<a href="#l16.171"></a><span id="l16.171" class="difflineplus">+</span>
<a href="#l16.172"></a><span id="l16.172" class="difflineplus">+__version__ = &quot;$URL: http://pypng.googlecode.com/svn/trunk/code/png.py $ $Rev: 228 $&quot;</span>
<a href="#l16.173"></a><span id="l16.173" class="difflineplus">+</span>
<a href="#l16.174"></a><span id="l16.174" class="difflineplus">+from array import array</span>
<a href="#l16.175"></a><span id="l16.175" class="difflineplus">+try: # See :pyver:old</span>
<a href="#l16.176"></a><span id="l16.176" class="difflineplus">+    import itertools</span>
<a href="#l16.177"></a><span id="l16.177" class="difflineplus">+except:</span>
<a href="#l16.178"></a><span id="l16.178" class="difflineplus">+    pass</span>
<a href="#l16.179"></a><span id="l16.179" class="difflineplus">+import math</span>
<a href="#l16.180"></a><span id="l16.180" class="difflineplus">+# http://www.python.org/doc/2.4.4/lib/module-operator.html</span>
<a href="#l16.181"></a><span id="l16.181" class="difflineplus">+import operator</span>
<a href="#l16.182"></a><span id="l16.182" class="difflineplus">+import struct</span>
<a href="#l16.183"></a><span id="l16.183" class="difflineplus">+import sys</span>
<a href="#l16.184"></a><span id="l16.184" class="difflineplus">+import zlib</span>
<a href="#l16.185"></a><span id="l16.185" class="difflineplus">+# http://www.python.org/doc/2.4.4/lib/module-warnings.html</span>
<a href="#l16.186"></a><span id="l16.186" class="difflineplus">+import warnings</span>
<a href="#l16.187"></a><span id="l16.187" class="difflineplus">+</span>
<a href="#l16.188"></a><span id="l16.188" class="difflineplus">+</span>
<a href="#l16.189"></a><span id="l16.189" class="difflineplus">+__all__ = ['Image', 'Reader', 'Writer', 'write_chunks', 'from_array']</span>
<a href="#l16.190"></a><span id="l16.190" class="difflineplus">+</span>
<a href="#l16.191"></a><span id="l16.191" class="difflineplus">+</span>
<a href="#l16.192"></a><span id="l16.192" class="difflineplus">+# The PNG signature.</span>
<a href="#l16.193"></a><span id="l16.193" class="difflineplus">+# http://www.w3.org/TR/PNG/#5PNG-file-signature</span>
<a href="#l16.194"></a><span id="l16.194" class="difflineplus">+_signature = struct.pack('8B', 137, 80, 78, 71, 13, 10, 26, 10)</span>
<a href="#l16.195"></a><span id="l16.195" class="difflineplus">+</span>
<a href="#l16.196"></a><span id="l16.196" class="difflineplus">+_adam7 = ((0, 0, 8, 8),</span>
<a href="#l16.197"></a><span id="l16.197" class="difflineplus">+          (4, 0, 8, 8),</span>
<a href="#l16.198"></a><span id="l16.198" class="difflineplus">+          (0, 4, 4, 8),</span>
<a href="#l16.199"></a><span id="l16.199" class="difflineplus">+          (2, 0, 4, 4),</span>
<a href="#l16.200"></a><span id="l16.200" class="difflineplus">+          (0, 2, 2, 4),</span>
<a href="#l16.201"></a><span id="l16.201" class="difflineplus">+          (1, 0, 2, 2),</span>
<a href="#l16.202"></a><span id="l16.202" class="difflineplus">+          (0, 1, 1, 2))</span>
<a href="#l16.203"></a><span id="l16.203" class="difflineplus">+</span>
<a href="#l16.204"></a><span id="l16.204" class="difflineplus">+def group(s, n):</span>
<a href="#l16.205"></a><span id="l16.205" class="difflineplus">+    # See</span>
<a href="#l16.206"></a><span id="l16.206" class="difflineplus">+    # http://www.python.org/doc/2.6/library/functions.html#zip</span>
<a href="#l16.207"></a><span id="l16.207" class="difflineplus">+    return zip(*[iter(s)]*n)</span>
<a href="#l16.208"></a><span id="l16.208" class="difflineplus">+</span>
<a href="#l16.209"></a><span id="l16.209" class="difflineplus">+def isarray(x):</span>
<a href="#l16.210"></a><span id="l16.210" class="difflineplus">+    &quot;&quot;&quot;Same as ``isinstance(x, array)`` except on Python 2.2, where it</span>
<a href="#l16.211"></a><span id="l16.211" class="difflineplus">+    always returns ``False``.  This helps PyPNG work on Python 2.2.</span>
<a href="#l16.212"></a><span id="l16.212" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.213"></a><span id="l16.213" class="difflineplus">+</span>
<a href="#l16.214"></a><span id="l16.214" class="difflineplus">+    try:</span>
<a href="#l16.215"></a><span id="l16.215" class="difflineplus">+        return isinstance(x, array)</span>
<a href="#l16.216"></a><span id="l16.216" class="difflineplus">+    except:</span>
<a href="#l16.217"></a><span id="l16.217" class="difflineplus">+        return False</span>
<a href="#l16.218"></a><span id="l16.218" class="difflineplus">+</span>
<a href="#l16.219"></a><span id="l16.219" class="difflineplus">+try:  # see :pyver:old</span>
<a href="#l16.220"></a><span id="l16.220" class="difflineplus">+    array.tostring</span>
<a href="#l16.221"></a><span id="l16.221" class="difflineplus">+except:</span>
<a href="#l16.222"></a><span id="l16.222" class="difflineplus">+    def tostring(row):</span>
<a href="#l16.223"></a><span id="l16.223" class="difflineplus">+        l = len(row)</span>
<a href="#l16.224"></a><span id="l16.224" class="difflineplus">+        return struct.pack('%dB' % l, *row)</span>
<a href="#l16.225"></a><span id="l16.225" class="difflineplus">+else:</span>
<a href="#l16.226"></a><span id="l16.226" class="difflineplus">+    def tostring(row):</span>
<a href="#l16.227"></a><span id="l16.227" class="difflineplus">+        &quot;&quot;&quot;Convert row of bytes to string.  Expects `row` to be an</span>
<a href="#l16.228"></a><span id="l16.228" class="difflineplus">+        ``array``.</span>
<a href="#l16.229"></a><span id="l16.229" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.230"></a><span id="l16.230" class="difflineplus">+        return row.tostring()</span>
<a href="#l16.231"></a><span id="l16.231" class="difflineplus">+</span>
<a href="#l16.232"></a><span id="l16.232" class="difflineplus">+# Conditionally convert to bytes.  Works on Python 2 and Python 3.</span>
<a href="#l16.233"></a><span id="l16.233" class="difflineplus">+try:</span>
<a href="#l16.234"></a><span id="l16.234" class="difflineplus">+    bytes('', 'ascii')</span>
<a href="#l16.235"></a><span id="l16.235" class="difflineplus">+    def strtobytes(x): return bytes(x, 'iso8859-1')</span>
<a href="#l16.236"></a><span id="l16.236" class="difflineplus">+    def bytestostr(x): return str(x, 'iso8859-1')</span>
<a href="#l16.237"></a><span id="l16.237" class="difflineplus">+except:</span>
<a href="#l16.238"></a><span id="l16.238" class="difflineplus">+    strtobytes = str</span>
<a href="#l16.239"></a><span id="l16.239" class="difflineplus">+    bytestostr = str</span>
<a href="#l16.240"></a><span id="l16.240" class="difflineplus">+</span>
<a href="#l16.241"></a><span id="l16.241" class="difflineplus">+def interleave_planes(ipixels, apixels, ipsize, apsize):</span>
<a href="#l16.242"></a><span id="l16.242" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.243"></a><span id="l16.243" class="difflineplus">+    Interleave (colour) planes, e.g. RGB + A = RGBA.</span>
<a href="#l16.244"></a><span id="l16.244" class="difflineplus">+</span>
<a href="#l16.245"></a><span id="l16.245" class="difflineplus">+    Return an array of pixels consisting of the `ipsize` elements of data</span>
<a href="#l16.246"></a><span id="l16.246" class="difflineplus">+    from each pixel in `ipixels` followed by the `apsize` elements of data</span>
<a href="#l16.247"></a><span id="l16.247" class="difflineplus">+    from each pixel in `apixels`.  Conventionally `ipixels` and</span>
<a href="#l16.248"></a><span id="l16.248" class="difflineplus">+    `apixels` are byte arrays so the sizes are bytes, but it actually</span>
<a href="#l16.249"></a><span id="l16.249" class="difflineplus">+    works with any arrays of the same type.  The returned array is the</span>
<a href="#l16.250"></a><span id="l16.250" class="difflineplus">+    same type as the input arrays which should be the same type as each other.</span>
<a href="#l16.251"></a><span id="l16.251" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.252"></a><span id="l16.252" class="difflineplus">+</span>
<a href="#l16.253"></a><span id="l16.253" class="difflineplus">+    itotal = len(ipixels)</span>
<a href="#l16.254"></a><span id="l16.254" class="difflineplus">+    atotal = len(apixels)</span>
<a href="#l16.255"></a><span id="l16.255" class="difflineplus">+    newtotal = itotal + atotal</span>
<a href="#l16.256"></a><span id="l16.256" class="difflineplus">+    newpsize = ipsize + apsize</span>
<a href="#l16.257"></a><span id="l16.257" class="difflineplus">+    # Set up the output buffer</span>
<a href="#l16.258"></a><span id="l16.258" class="difflineplus">+    # See http://www.python.org/doc/2.4.4/lib/module-array.html#l2h-1356</span>
<a href="#l16.259"></a><span id="l16.259" class="difflineplus">+    out = array(ipixels.typecode)</span>
<a href="#l16.260"></a><span id="l16.260" class="difflineplus">+    # It's annoying that there is no cheap way to set the array size :-(</span>
<a href="#l16.261"></a><span id="l16.261" class="difflineplus">+    out.extend(ipixels)</span>
<a href="#l16.262"></a><span id="l16.262" class="difflineplus">+    out.extend(apixels)</span>
<a href="#l16.263"></a><span id="l16.263" class="difflineplus">+    # Interleave in the pixel data</span>
<a href="#l16.264"></a><span id="l16.264" class="difflineplus">+    for i in range(ipsize):</span>
<a href="#l16.265"></a><span id="l16.265" class="difflineplus">+        out[i:newtotal:newpsize] = ipixels[i:itotal:ipsize]</span>
<a href="#l16.266"></a><span id="l16.266" class="difflineplus">+    for i in range(apsize):</span>
<a href="#l16.267"></a><span id="l16.267" class="difflineplus">+        out[i+ipsize:newtotal:newpsize] = apixels[i:atotal:apsize]</span>
<a href="#l16.268"></a><span id="l16.268" class="difflineplus">+    return out</span>
<a href="#l16.269"></a><span id="l16.269" class="difflineplus">+</span>
<a href="#l16.270"></a><span id="l16.270" class="difflineplus">+def check_palette(palette):</span>
<a href="#l16.271"></a><span id="l16.271" class="difflineplus">+    &quot;&quot;&quot;Check a palette argument (to the :class:`Writer` class) for validity.</span>
<a href="#l16.272"></a><span id="l16.272" class="difflineplus">+    Returns the palette as a list if okay; raises an exception otherwise.</span>
<a href="#l16.273"></a><span id="l16.273" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.274"></a><span id="l16.274" class="difflineplus">+</span>
<a href="#l16.275"></a><span id="l16.275" class="difflineplus">+    # None is the default and is allowed.</span>
<a href="#l16.276"></a><span id="l16.276" class="difflineplus">+    if palette is None:</span>
<a href="#l16.277"></a><span id="l16.277" class="difflineplus">+        return None</span>
<a href="#l16.278"></a><span id="l16.278" class="difflineplus">+</span>
<a href="#l16.279"></a><span id="l16.279" class="difflineplus">+    p = list(palette)</span>
<a href="#l16.280"></a><span id="l16.280" class="difflineplus">+    if not (0 &lt; len(p) &lt;= 256):</span>
<a href="#l16.281"></a><span id="l16.281" class="difflineplus">+        raise ValueError(&quot;a palette must have between 1 and 256 entries&quot;)</span>
<a href="#l16.282"></a><span id="l16.282" class="difflineplus">+    seen_triple = False</span>
<a href="#l16.283"></a><span id="l16.283" class="difflineplus">+    for i,t in enumerate(p):</span>
<a href="#l16.284"></a><span id="l16.284" class="difflineplus">+        if len(t) not in (3,4):</span>
<a href="#l16.285"></a><span id="l16.285" class="difflineplus">+            raise ValueError(</span>
<a href="#l16.286"></a><span id="l16.286" class="difflineplus">+              &quot;palette entry %d: entries must be 3- or 4-tuples.&quot; % i)</span>
<a href="#l16.287"></a><span id="l16.287" class="difflineplus">+        if len(t) == 3:</span>
<a href="#l16.288"></a><span id="l16.288" class="difflineplus">+            seen_triple = True</span>
<a href="#l16.289"></a><span id="l16.289" class="difflineplus">+        if seen_triple and len(t) == 4:</span>
<a href="#l16.290"></a><span id="l16.290" class="difflineplus">+            raise ValueError(</span>
<a href="#l16.291"></a><span id="l16.291" class="difflineplus">+              &quot;palette entry %d: all 4-tuples must precede all 3-tuples&quot; % i)</span>
<a href="#l16.292"></a><span id="l16.292" class="difflineplus">+        for x in t:</span>
<a href="#l16.293"></a><span id="l16.293" class="difflineplus">+            if int(x) != x or not(0 &lt;= x &lt;= 255):</span>
<a href="#l16.294"></a><span id="l16.294" class="difflineplus">+                raise ValueError(</span>
<a href="#l16.295"></a><span id="l16.295" class="difflineplus">+                  &quot;palette entry %d: values must be integer: 0 &lt;= x &lt;= 255&quot; % i)</span>
<a href="#l16.296"></a><span id="l16.296" class="difflineplus">+    return p</span>
<a href="#l16.297"></a><span id="l16.297" class="difflineplus">+</span>
<a href="#l16.298"></a><span id="l16.298" class="difflineplus">+class Error(Exception):</span>
<a href="#l16.299"></a><span id="l16.299" class="difflineplus">+    prefix = 'Error'</span>
<a href="#l16.300"></a><span id="l16.300" class="difflineplus">+    def __str__(self):</span>
<a href="#l16.301"></a><span id="l16.301" class="difflineplus">+        return self.prefix + ': ' + ' '.join(self.args)</span>
<a href="#l16.302"></a><span id="l16.302" class="difflineplus">+</span>
<a href="#l16.303"></a><span id="l16.303" class="difflineplus">+class FormatError(Error):</span>
<a href="#l16.304"></a><span id="l16.304" class="difflineplus">+    &quot;&quot;&quot;Problem with input file format.  In other words, PNG file does</span>
<a href="#l16.305"></a><span id="l16.305" class="difflineplus">+    not conform to the specification in some way and is invalid.</span>
<a href="#l16.306"></a><span id="l16.306" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.307"></a><span id="l16.307" class="difflineplus">+</span>
<a href="#l16.308"></a><span id="l16.308" class="difflineplus">+    prefix = 'FormatError'</span>
<a href="#l16.309"></a><span id="l16.309" class="difflineplus">+</span>
<a href="#l16.310"></a><span id="l16.310" class="difflineplus">+class ChunkError(FormatError):</span>
<a href="#l16.311"></a><span id="l16.311" class="difflineplus">+    prefix = 'ChunkError'</span>
<a href="#l16.312"></a><span id="l16.312" class="difflineplus">+</span>
<a href="#l16.313"></a><span id="l16.313" class="difflineplus">+</span>
<a href="#l16.314"></a><span id="l16.314" class="difflineplus">+class Writer:</span>
<a href="#l16.315"></a><span id="l16.315" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.316"></a><span id="l16.316" class="difflineplus">+    PNG encoder in pure Python.</span>
<a href="#l16.317"></a><span id="l16.317" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.318"></a><span id="l16.318" class="difflineplus">+</span>
<a href="#l16.319"></a><span id="l16.319" class="difflineplus">+    def __init__(self, width=None, height=None,</span>
<a href="#l16.320"></a><span id="l16.320" class="difflineplus">+                 size=None,</span>
<a href="#l16.321"></a><span id="l16.321" class="difflineplus">+                 greyscale=False,</span>
<a href="#l16.322"></a><span id="l16.322" class="difflineplus">+                 alpha=False,</span>
<a href="#l16.323"></a><span id="l16.323" class="difflineplus">+                 bitdepth=8,</span>
<a href="#l16.324"></a><span id="l16.324" class="difflineplus">+                 palette=None,</span>
<a href="#l16.325"></a><span id="l16.325" class="difflineplus">+                 transparent=None,</span>
<a href="#l16.326"></a><span id="l16.326" class="difflineplus">+                 background=None,</span>
<a href="#l16.327"></a><span id="l16.327" class="difflineplus">+                 gamma=None,</span>
<a href="#l16.328"></a><span id="l16.328" class="difflineplus">+                 compression=None,</span>
<a href="#l16.329"></a><span id="l16.329" class="difflineplus">+                 interlace=False,</span>
<a href="#l16.330"></a><span id="l16.330" class="difflineplus">+                 bytes_per_sample=None, # deprecated</span>
<a href="#l16.331"></a><span id="l16.331" class="difflineplus">+                 planes=None,</span>
<a href="#l16.332"></a><span id="l16.332" class="difflineplus">+                 colormap=None,</span>
<a href="#l16.333"></a><span id="l16.333" class="difflineplus">+                 maxval=None,</span>
<a href="#l16.334"></a><span id="l16.334" class="difflineplus">+                 chunk_limit=2**20):</span>
<a href="#l16.335"></a><span id="l16.335" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.336"></a><span id="l16.336" class="difflineplus">+        Create a PNG encoder object.</span>
<a href="#l16.337"></a><span id="l16.337" class="difflineplus">+</span>
<a href="#l16.338"></a><span id="l16.338" class="difflineplus">+        Arguments:</span>
<a href="#l16.339"></a><span id="l16.339" class="difflineplus">+</span>
<a href="#l16.340"></a><span id="l16.340" class="difflineplus">+        width, height</span>
<a href="#l16.341"></a><span id="l16.341" class="difflineplus">+          Image size in pixels, as two separate arguments.</span>
<a href="#l16.342"></a><span id="l16.342" class="difflineplus">+        size</span>
<a href="#l16.343"></a><span id="l16.343" class="difflineplus">+          Image size (w,h) in pixels, as single argument.</span>
<a href="#l16.344"></a><span id="l16.344" class="difflineplus">+        greyscale</span>
<a href="#l16.345"></a><span id="l16.345" class="difflineplus">+          Input data is greyscale, not RGB.</span>
<a href="#l16.346"></a><span id="l16.346" class="difflineplus">+        alpha</span>
<a href="#l16.347"></a><span id="l16.347" class="difflineplus">+          Input data has alpha channel (RGBA or LA).</span>
<a href="#l16.348"></a><span id="l16.348" class="difflineplus">+        bitdepth</span>
<a href="#l16.349"></a><span id="l16.349" class="difflineplus">+          Bit depth: from 1 to 16.</span>
<a href="#l16.350"></a><span id="l16.350" class="difflineplus">+        palette</span>
<a href="#l16.351"></a><span id="l16.351" class="difflineplus">+          Create a palette for a colour mapped image (colour type 3).</span>
<a href="#l16.352"></a><span id="l16.352" class="difflineplus">+        transparent</span>
<a href="#l16.353"></a><span id="l16.353" class="difflineplus">+          Specify a transparent colour (create a ``tRNS`` chunk).</span>
<a href="#l16.354"></a><span id="l16.354" class="difflineplus">+        background</span>
<a href="#l16.355"></a><span id="l16.355" class="difflineplus">+          Specify a default background colour (create a ``bKGD`` chunk).</span>
<a href="#l16.356"></a><span id="l16.356" class="difflineplus">+        gamma</span>
<a href="#l16.357"></a><span id="l16.357" class="difflineplus">+          Specify a gamma value (create a ``gAMA`` chunk).</span>
<a href="#l16.358"></a><span id="l16.358" class="difflineplus">+        compression</span>
<a href="#l16.359"></a><span id="l16.359" class="difflineplus">+          zlib compression level (1-9).</span>
<a href="#l16.360"></a><span id="l16.360" class="difflineplus">+        interlace</span>
<a href="#l16.361"></a><span id="l16.361" class="difflineplus">+          Create an interlaced image.</span>
<a href="#l16.362"></a><span id="l16.362" class="difflineplus">+        chunk_limit</span>
<a href="#l16.363"></a><span id="l16.363" class="difflineplus">+          Write multiple ``IDAT`` chunks to save memory.</span>
<a href="#l16.364"></a><span id="l16.364" class="difflineplus">+</span>
<a href="#l16.365"></a><span id="l16.365" class="difflineplus">+        The image size (in pixels) can be specified either by using the</span>
<a href="#l16.366"></a><span id="l16.366" class="difflineplus">+        `width` and `height` arguments, or with the single `size`</span>
<a href="#l16.367"></a><span id="l16.367" class="difflineplus">+        argument.  If `size` is used it should be a pair (*width*,</span>
<a href="#l16.368"></a><span id="l16.368" class="difflineplus">+        *height*).</span>
<a href="#l16.369"></a><span id="l16.369" class="difflineplus">+</span>
<a href="#l16.370"></a><span id="l16.370" class="difflineplus">+        `greyscale` and `alpha` are booleans that specify whether</span>
<a href="#l16.371"></a><span id="l16.371" class="difflineplus">+        an image is greyscale (or colour), and whether it has an</span>
<a href="#l16.372"></a><span id="l16.372" class="difflineplus">+        alpha channel (or not).</span>
<a href="#l16.373"></a><span id="l16.373" class="difflineplus">+</span>
<a href="#l16.374"></a><span id="l16.374" class="difflineplus">+        `bitdepth` specifies the bit depth of the source pixel values.</span>
<a href="#l16.375"></a><span id="l16.375" class="difflineplus">+        Each source pixel value must be an integer between 0 and</span>
<a href="#l16.376"></a><span id="l16.376" class="difflineplus">+        ``2**bitdepth-1``.  For example, 8-bit images have values</span>
<a href="#l16.377"></a><span id="l16.377" class="difflineplus">+        between 0 and 255.  PNG only stores images with bit depths of</span>
<a href="#l16.378"></a><span id="l16.378" class="difflineplus">+        1,2,4,8, or 16.  When `bitdepth` is not one of these values,</span>
<a href="#l16.379"></a><span id="l16.379" class="difflineplus">+        the next highest valid bit depth is selected, and an ``sBIT``</span>
<a href="#l16.380"></a><span id="l16.380" class="difflineplus">+        (significant bits) chunk is generated that specifies the original</span>
<a href="#l16.381"></a><span id="l16.381" class="difflineplus">+        precision of the source image.  In this case the supplied pixel</span>
<a href="#l16.382"></a><span id="l16.382" class="difflineplus">+        values will be rescaled to fit the range of the selected bit depth.</span>
<a href="#l16.383"></a><span id="l16.383" class="difflineplus">+</span>
<a href="#l16.384"></a><span id="l16.384" class="difflineplus">+        The details of which bit depth / colour model combinations the</span>
<a href="#l16.385"></a><span id="l16.385" class="difflineplus">+        PNG file format supports directly, are somewhat arcane</span>
<a href="#l16.386"></a><span id="l16.386" class="difflineplus">+        (refer to the PNG specification for full details).  Briefly:</span>
<a href="#l16.387"></a><span id="l16.387" class="difflineplus">+        &quot;small&quot; bit depths (1,2,4) are only allowed with greyscale and</span>
<a href="#l16.388"></a><span id="l16.388" class="difflineplus">+        colour mapped images; colour mapped images cannot have bit depth</span>
<a href="#l16.389"></a><span id="l16.389" class="difflineplus">+        16.</span>
<a href="#l16.390"></a><span id="l16.390" class="difflineplus">+</span>
<a href="#l16.391"></a><span id="l16.391" class="difflineplus">+        For colour mapped images (in other words, when the `palette`</span>
<a href="#l16.392"></a><span id="l16.392" class="difflineplus">+        argument is specified) the `bitdepth` argument must match one of</span>
<a href="#l16.393"></a><span id="l16.393" class="difflineplus">+        the valid PNG bit depths: 1, 2, 4, or 8.  (It is valid to have a</span>
<a href="#l16.394"></a><span id="l16.394" class="difflineplus">+        PNG image with a palette and an ``sBIT`` chunk, but the meaning</span>
<a href="#l16.395"></a><span id="l16.395" class="difflineplus">+        is slightly different; it would be awkward to press the</span>
<a href="#l16.396"></a><span id="l16.396" class="difflineplus">+        `bitdepth` argument into service for this.)</span>
<a href="#l16.397"></a><span id="l16.397" class="difflineplus">+</span>
<a href="#l16.398"></a><span id="l16.398" class="difflineplus">+        The `palette` option, when specified, causes a colour mapped image</span>
<a href="#l16.399"></a><span id="l16.399" class="difflineplus">+        to be created: the PNG colour type is set to 3; greyscale</span>
<a href="#l16.400"></a><span id="l16.400" class="difflineplus">+        must not be set; alpha must not be set; transparent must</span>
<a href="#l16.401"></a><span id="l16.401" class="difflineplus">+        not be set; the bit depth must be 1,2,4, or 8.  When a colour</span>
<a href="#l16.402"></a><span id="l16.402" class="difflineplus">+        mapped image is created, the pixel values are palette indexes</span>
<a href="#l16.403"></a><span id="l16.403" class="difflineplus">+        and the `bitdepth` argument specifies the size of these indexes</span>
<a href="#l16.404"></a><span id="l16.404" class="difflineplus">+        (not the size of the colour values in the palette).</span>
<a href="#l16.405"></a><span id="l16.405" class="difflineplus">+</span>
<a href="#l16.406"></a><span id="l16.406" class="difflineplus">+        The palette argument value should be a sequence of 3- or</span>
<a href="#l16.407"></a><span id="l16.407" class="difflineplus">+        4-tuples.  3-tuples specify RGB palette entries; 4-tuples</span>
<a href="#l16.408"></a><span id="l16.408" class="difflineplus">+        specify RGBA palette entries.  If both 4-tuples and 3-tuples</span>
<a href="#l16.409"></a><span id="l16.409" class="difflineplus">+        appear in the sequence then all the 4-tuples must come</span>
<a href="#l16.410"></a><span id="l16.410" class="difflineplus">+        before all the 3-tuples.  A ``PLTE`` chunk is created; if there</span>
<a href="#l16.411"></a><span id="l16.411" class="difflineplus">+        are 4-tuples then a ``tRNS`` chunk is created as well.  The</span>
<a href="#l16.412"></a><span id="l16.412" class="difflineplus">+        ``PLTE`` chunk will contain all the RGB triples in the same</span>
<a href="#l16.413"></a><span id="l16.413" class="difflineplus">+        sequence; the ``tRNS`` chunk will contain the alpha channel for</span>
<a href="#l16.414"></a><span id="l16.414" class="difflineplus">+        all the 4-tuples, in the same sequence.  Palette entries</span>
<a href="#l16.415"></a><span id="l16.415" class="difflineplus">+        are always 8-bit.</span>
<a href="#l16.416"></a><span id="l16.416" class="difflineplus">+</span>
<a href="#l16.417"></a><span id="l16.417" class="difflineplus">+        If specified, the `transparent` and `background` parameters must</span>
<a href="#l16.418"></a><span id="l16.418" class="difflineplus">+        be a tuple with three integer values for red, green, blue, or</span>
<a href="#l16.419"></a><span id="l16.419" class="difflineplus">+        a simple integer (or singleton tuple) for a greyscale image.</span>
<a href="#l16.420"></a><span id="l16.420" class="difflineplus">+</span>
<a href="#l16.421"></a><span id="l16.421" class="difflineplus">+        If specified, the `gamma` parameter must be a positive number</span>
<a href="#l16.422"></a><span id="l16.422" class="difflineplus">+        (generally, a float).  A ``gAMA`` chunk will be created.  Note that</span>
<a href="#l16.423"></a><span id="l16.423" class="difflineplus">+        this will not change the values of the pixels as they appear in</span>
<a href="#l16.424"></a><span id="l16.424" class="difflineplus">+        the PNG file, they are assumed to have already been converted</span>
<a href="#l16.425"></a><span id="l16.425" class="difflineplus">+        appropriately for the gamma specified.</span>
<a href="#l16.426"></a><span id="l16.426" class="difflineplus">+</span>
<a href="#l16.427"></a><span id="l16.427" class="difflineplus">+        The `compression` argument specifies the compression level</span>
<a href="#l16.428"></a><span id="l16.428" class="difflineplus">+        to be used by the ``zlib`` module.  Higher values are likely</span>
<a href="#l16.429"></a><span id="l16.429" class="difflineplus">+        to compress better, but will be slower to compress.  The</span>
<a href="#l16.430"></a><span id="l16.430" class="difflineplus">+        default for this argument is ``None``; this does not mean</span>
<a href="#l16.431"></a><span id="l16.431" class="difflineplus">+        no compression, rather it means that the default from the</span>
<a href="#l16.432"></a><span id="l16.432" class="difflineplus">+        ``zlib`` module is used (which is generally acceptable).</span>
<a href="#l16.433"></a><span id="l16.433" class="difflineplus">+</span>
<a href="#l16.434"></a><span id="l16.434" class="difflineplus">+        If `interlace` is true then an interlaced image is created</span>
<a href="#l16.435"></a><span id="l16.435" class="difflineplus">+        (using PNG's so far only interace method, *Adam7*).  This does not</span>
<a href="#l16.436"></a><span id="l16.436" class="difflineplus">+        affect how the pixels should be presented to the encoder, rather</span>
<a href="#l16.437"></a><span id="l16.437" class="difflineplus">+        it changes how they are arranged into the PNG file.  On slow</span>
<a href="#l16.438"></a><span id="l16.438" class="difflineplus">+        connexions interlaced images can be partially decoded by the</span>
<a href="#l16.439"></a><span id="l16.439" class="difflineplus">+        browser to give a rough view of the image that is successively</span>
<a href="#l16.440"></a><span id="l16.440" class="difflineplus">+        refined as more image data appears.</span>
<a href="#l16.441"></a><span id="l16.441" class="difflineplus">+        </span>
<a href="#l16.442"></a><span id="l16.442" class="difflineplus">+        .. note ::</span>
<a href="#l16.443"></a><span id="l16.443" class="difflineplus">+        </span>
<a href="#l16.444"></a><span id="l16.444" class="difflineplus">+          Enabling the `interlace` option requires the entire image</span>
<a href="#l16.445"></a><span id="l16.445" class="difflineplus">+          to be processed in working memory.</span>
<a href="#l16.446"></a><span id="l16.446" class="difflineplus">+</span>
<a href="#l16.447"></a><span id="l16.447" class="difflineplus">+        `chunk_limit` is used to limit the amount of memory used whilst</span>
<a href="#l16.448"></a><span id="l16.448" class="difflineplus">+        compressing the image.  In order to avoid using large amounts of</span>
<a href="#l16.449"></a><span id="l16.449" class="difflineplus">+        memory, multiple ``IDAT`` chunks may be created.</span>
<a href="#l16.450"></a><span id="l16.450" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.451"></a><span id="l16.451" class="difflineplus">+</span>
<a href="#l16.452"></a><span id="l16.452" class="difflineplus">+        # At the moment the `planes` argument is ignored;</span>
<a href="#l16.453"></a><span id="l16.453" class="difflineplus">+        # its purpose is to act as a dummy so that</span>
<a href="#l16.454"></a><span id="l16.454" class="difflineplus">+        # ``Writer(x, y, **info)`` works, where `info` is a dictionary</span>
<a href="#l16.455"></a><span id="l16.455" class="difflineplus">+        # returned by Reader.read and friends.</span>
<a href="#l16.456"></a><span id="l16.456" class="difflineplus">+        # Ditto for `colormap`.</span>
<a href="#l16.457"></a><span id="l16.457" class="difflineplus">+</span>
<a href="#l16.458"></a><span id="l16.458" class="difflineplus">+        # A couple of helper functions come first.  Best skipped if you</span>
<a href="#l16.459"></a><span id="l16.459" class="difflineplus">+        # are reading through.</span>
<a href="#l16.460"></a><span id="l16.460" class="difflineplus">+</span>
<a href="#l16.461"></a><span id="l16.461" class="difflineplus">+        def isinteger(x):</span>
<a href="#l16.462"></a><span id="l16.462" class="difflineplus">+            try:</span>
<a href="#l16.463"></a><span id="l16.463" class="difflineplus">+                return int(x) == x</span>
<a href="#l16.464"></a><span id="l16.464" class="difflineplus">+            except:</span>
<a href="#l16.465"></a><span id="l16.465" class="difflineplus">+                return False</span>
<a href="#l16.466"></a><span id="l16.466" class="difflineplus">+</span>
<a href="#l16.467"></a><span id="l16.467" class="difflineplus">+        def check_color(c, which):</span>
<a href="#l16.468"></a><span id="l16.468" class="difflineplus">+            &quot;&quot;&quot;Checks that a colour argument for transparent or</span>
<a href="#l16.469"></a><span id="l16.469" class="difflineplus">+            background options is the right form.  Also &quot;corrects&quot; bare</span>
<a href="#l16.470"></a><span id="l16.470" class="difflineplus">+            integers to 1-tuples.</span>
<a href="#l16.471"></a><span id="l16.471" class="difflineplus">+            &quot;&quot;&quot;</span>
<a href="#l16.472"></a><span id="l16.472" class="difflineplus">+</span>
<a href="#l16.473"></a><span id="l16.473" class="difflineplus">+            if c is None:</span>
<a href="#l16.474"></a><span id="l16.474" class="difflineplus">+                return c</span>
<a href="#l16.475"></a><span id="l16.475" class="difflineplus">+            if greyscale:</span>
<a href="#l16.476"></a><span id="l16.476" class="difflineplus">+                try:</span>
<a href="#l16.477"></a><span id="l16.477" class="difflineplus">+                    l = len(c)</span>
<a href="#l16.478"></a><span id="l16.478" class="difflineplus">+                except TypeError:</span>
<a href="#l16.479"></a><span id="l16.479" class="difflineplus">+                    c = (c,)</span>
<a href="#l16.480"></a><span id="l16.480" class="difflineplus">+                if len(c) != 1:</span>
<a href="#l16.481"></a><span id="l16.481" class="difflineplus">+                    raise ValueError(&quot;%s for greyscale must be 1-tuple&quot; %</span>
<a href="#l16.482"></a><span id="l16.482" class="difflineplus">+                        which)</span>
<a href="#l16.483"></a><span id="l16.483" class="difflineplus">+                if not isinteger(c[0]):</span>
<a href="#l16.484"></a><span id="l16.484" class="difflineplus">+                    raise ValueError(</span>
<a href="#l16.485"></a><span id="l16.485" class="difflineplus">+                        &quot;%s colour for greyscale must be integer&quot; %</span>
<a href="#l16.486"></a><span id="l16.486" class="difflineplus">+                        which)</span>
<a href="#l16.487"></a><span id="l16.487" class="difflineplus">+            else:</span>
<a href="#l16.488"></a><span id="l16.488" class="difflineplus">+                if not (len(c) == 3 and</span>
<a href="#l16.489"></a><span id="l16.489" class="difflineplus">+                        isinteger(c[0]) and</span>
<a href="#l16.490"></a><span id="l16.490" class="difflineplus">+                        isinteger(c[1]) and</span>
<a href="#l16.491"></a><span id="l16.491" class="difflineplus">+                        isinteger(c[2])):</span>
<a href="#l16.492"></a><span id="l16.492" class="difflineplus">+                    raise ValueError(</span>
<a href="#l16.493"></a><span id="l16.493" class="difflineplus">+                        &quot;%s colour must be a triple of integers&quot; %</span>
<a href="#l16.494"></a><span id="l16.494" class="difflineplus">+                        which)</span>
<a href="#l16.495"></a><span id="l16.495" class="difflineplus">+            return c</span>
<a href="#l16.496"></a><span id="l16.496" class="difflineplus">+</span>
<a href="#l16.497"></a><span id="l16.497" class="difflineplus">+        if size:</span>
<a href="#l16.498"></a><span id="l16.498" class="difflineplus">+            if len(size) != 2:</span>
<a href="#l16.499"></a><span id="l16.499" class="difflineplus">+                raise ValueError(</span>
<a href="#l16.500"></a><span id="l16.500" class="difflineplus">+                  &quot;size argument should be a pair (width, height)&quot;)</span>
<a href="#l16.501"></a><span id="l16.501" class="difflineplus">+            if width is not None and width != size[0]:</span>
<a href="#l16.502"></a><span id="l16.502" class="difflineplus">+                raise ValueError(</span>
<a href="#l16.503"></a><span id="l16.503" class="difflineplus">+                  &quot;size[0] (%r) and width (%r) should match when both are used.&quot;</span>
<a href="#l16.504"></a><span id="l16.504" class="difflineplus">+                    % (size[0], width))</span>
<a href="#l16.505"></a><span id="l16.505" class="difflineplus">+            if height is not None and height != size[1]:</span>
<a href="#l16.506"></a><span id="l16.506" class="difflineplus">+                raise ValueError(</span>
<a href="#l16.507"></a><span id="l16.507" class="difflineplus">+                  &quot;size[1] (%r) and height (%r) should match when both are used.&quot;</span>
<a href="#l16.508"></a><span id="l16.508" class="difflineplus">+                    % (size[1], height))</span>
<a href="#l16.509"></a><span id="l16.509" class="difflineplus">+            width,height = size</span>
<a href="#l16.510"></a><span id="l16.510" class="difflineplus">+        del size</span>
<a href="#l16.511"></a><span id="l16.511" class="difflineplus">+</span>
<a href="#l16.512"></a><span id="l16.512" class="difflineplus">+        if width &lt;= 0 or height &lt;= 0:</span>
<a href="#l16.513"></a><span id="l16.513" class="difflineplus">+            raise ValueError(&quot;width and height must be greater than zero&quot;)</span>
<a href="#l16.514"></a><span id="l16.514" class="difflineplus">+        if not isinteger(width) or not isinteger(height):</span>
<a href="#l16.515"></a><span id="l16.515" class="difflineplus">+            raise ValueError(&quot;width and height must be integers&quot;)</span>
<a href="#l16.516"></a><span id="l16.516" class="difflineplus">+        # http://www.w3.org/TR/PNG/#7Integers-and-byte-order</span>
<a href="#l16.517"></a><span id="l16.517" class="difflineplus">+        if width &gt; 2**32-1 or height &gt; 2**32-1:</span>
<a href="#l16.518"></a><span id="l16.518" class="difflineplus">+            raise ValueError(&quot;width and height cannot exceed 2**32-1&quot;)</span>
<a href="#l16.519"></a><span id="l16.519" class="difflineplus">+</span>
<a href="#l16.520"></a><span id="l16.520" class="difflineplus">+        if alpha and transparent is not None:</span>
<a href="#l16.521"></a><span id="l16.521" class="difflineplus">+            raise ValueError(</span>
<a href="#l16.522"></a><span id="l16.522" class="difflineplus">+                &quot;transparent colour not allowed with alpha channel&quot;)</span>
<a href="#l16.523"></a><span id="l16.523" class="difflineplus">+</span>
<a href="#l16.524"></a><span id="l16.524" class="difflineplus">+        if bytes_per_sample is not None:</span>
<a href="#l16.525"></a><span id="l16.525" class="difflineplus">+            warnings.warn('please use bitdepth instead of bytes_per_sample',</span>
<a href="#l16.526"></a><span id="l16.526" class="difflineplus">+                          DeprecationWarning)</span>
<a href="#l16.527"></a><span id="l16.527" class="difflineplus">+            if bytes_per_sample not in (0.125, 0.25, 0.5, 1, 2):</span>
<a href="#l16.528"></a><span id="l16.528" class="difflineplus">+                raise ValueError(</span>
<a href="#l16.529"></a><span id="l16.529" class="difflineplus">+                    &quot;bytes per sample must be .125, .25, .5, 1, or 2&quot;)</span>
<a href="#l16.530"></a><span id="l16.530" class="difflineplus">+            bitdepth = int(8*bytes_per_sample)</span>
<a href="#l16.531"></a><span id="l16.531" class="difflineplus">+        del bytes_per_sample</span>
<a href="#l16.532"></a><span id="l16.532" class="difflineplus">+        if not isinteger(bitdepth) or bitdepth &lt; 1 or 16 &lt; bitdepth:</span>
<a href="#l16.533"></a><span id="l16.533" class="difflineplus">+            raise ValueError(&quot;bitdepth (%r) must be a postive integer &lt;= 16&quot; %</span>
<a href="#l16.534"></a><span id="l16.534" class="difflineplus">+              bitdepth)</span>
<a href="#l16.535"></a><span id="l16.535" class="difflineplus">+</span>
<a href="#l16.536"></a><span id="l16.536" class="difflineplus">+        self.rescale = None</span>
<a href="#l16.537"></a><span id="l16.537" class="difflineplus">+        if palette:</span>
<a href="#l16.538"></a><span id="l16.538" class="difflineplus">+            if bitdepth not in (1,2,4,8):</span>
<a href="#l16.539"></a><span id="l16.539" class="difflineplus">+                raise ValueError(&quot;with palette, bitdepth must be 1, 2, 4, or 8&quot;)</span>
<a href="#l16.540"></a><span id="l16.540" class="difflineplus">+            if transparent is not None:</span>
<a href="#l16.541"></a><span id="l16.541" class="difflineplus">+                raise ValueError(&quot;transparent and palette not compatible&quot;)</span>
<a href="#l16.542"></a><span id="l16.542" class="difflineplus">+            if alpha:</span>
<a href="#l16.543"></a><span id="l16.543" class="difflineplus">+                raise ValueError(&quot;alpha and palette not compatible&quot;)</span>
<a href="#l16.544"></a><span id="l16.544" class="difflineplus">+            if greyscale:</span>
<a href="#l16.545"></a><span id="l16.545" class="difflineplus">+                raise ValueError(&quot;greyscale and palette not compatible&quot;)</span>
<a href="#l16.546"></a><span id="l16.546" class="difflineplus">+        else:</span>
<a href="#l16.547"></a><span id="l16.547" class="difflineplus">+            # No palette, check for sBIT chunk generation.</span>
<a href="#l16.548"></a><span id="l16.548" class="difflineplus">+            if alpha or not greyscale:</span>
<a href="#l16.549"></a><span id="l16.549" class="difflineplus">+                if bitdepth not in (8,16):</span>
<a href="#l16.550"></a><span id="l16.550" class="difflineplus">+                    targetbitdepth = (8,16)[bitdepth &gt; 8]</span>
<a href="#l16.551"></a><span id="l16.551" class="difflineplus">+                    self.rescale = (bitdepth, targetbitdepth)</span>
<a href="#l16.552"></a><span id="l16.552" class="difflineplus">+                    bitdepth = targetbitdepth</span>
<a href="#l16.553"></a><span id="l16.553" class="difflineplus">+                    del targetbitdepth</span>
<a href="#l16.554"></a><span id="l16.554" class="difflineplus">+            else:</span>
<a href="#l16.555"></a><span id="l16.555" class="difflineplus">+                assert greyscale</span>
<a href="#l16.556"></a><span id="l16.556" class="difflineplus">+                assert not alpha</span>
<a href="#l16.557"></a><span id="l16.557" class="difflineplus">+                if bitdepth not in (1,2,4,8,16):</span>
<a href="#l16.558"></a><span id="l16.558" class="difflineplus">+                    if bitdepth &gt; 8:</span>
<a href="#l16.559"></a><span id="l16.559" class="difflineplus">+                        targetbitdepth = 16</span>
<a href="#l16.560"></a><span id="l16.560" class="difflineplus">+                    elif bitdepth == 3:</span>
<a href="#l16.561"></a><span id="l16.561" class="difflineplus">+                        targetbitdepth = 4</span>
<a href="#l16.562"></a><span id="l16.562" class="difflineplus">+                    else:</span>
<a href="#l16.563"></a><span id="l16.563" class="difflineplus">+                        assert bitdepth in (5,6,7)</span>
<a href="#l16.564"></a><span id="l16.564" class="difflineplus">+                        targetbitdepth = 8</span>
<a href="#l16.565"></a><span id="l16.565" class="difflineplus">+                    self.rescale = (bitdepth, targetbitdepth)</span>
<a href="#l16.566"></a><span id="l16.566" class="difflineplus">+                    bitdepth = targetbitdepth</span>
<a href="#l16.567"></a><span id="l16.567" class="difflineplus">+                    del targetbitdepth</span>
<a href="#l16.568"></a><span id="l16.568" class="difflineplus">+</span>
<a href="#l16.569"></a><span id="l16.569" class="difflineplus">+        if bitdepth &lt; 8 and (alpha or not greyscale and not palette):</span>
<a href="#l16.570"></a><span id="l16.570" class="difflineplus">+            raise ValueError(</span>
<a href="#l16.571"></a><span id="l16.571" class="difflineplus">+              &quot;bitdepth &lt; 8 only permitted with greyscale or palette&quot;)</span>
<a href="#l16.572"></a><span id="l16.572" class="difflineplus">+        if bitdepth &gt; 8 and palette:</span>
<a href="#l16.573"></a><span id="l16.573" class="difflineplus">+            raise ValueError(</span>
<a href="#l16.574"></a><span id="l16.574" class="difflineplus">+                &quot;bit depth must be 8 or less for images with palette&quot;)</span>
<a href="#l16.575"></a><span id="l16.575" class="difflineplus">+</span>
<a href="#l16.576"></a><span id="l16.576" class="difflineplus">+        transparent = check_color(transparent, 'transparent')</span>
<a href="#l16.577"></a><span id="l16.577" class="difflineplus">+        background = check_color(background, 'background')</span>
<a href="#l16.578"></a><span id="l16.578" class="difflineplus">+</span>
<a href="#l16.579"></a><span id="l16.579" class="difflineplus">+        # It's important that the true boolean values (greyscale, alpha,</span>
<a href="#l16.580"></a><span id="l16.580" class="difflineplus">+        # colormap, interlace) are converted to bool because Iverson's</span>
<a href="#l16.581"></a><span id="l16.581" class="difflineplus">+        # convention is relied upon later on.</span>
<a href="#l16.582"></a><span id="l16.582" class="difflineplus">+        self.width = width</span>
<a href="#l16.583"></a><span id="l16.583" class="difflineplus">+        self.height = height</span>
<a href="#l16.584"></a><span id="l16.584" class="difflineplus">+        self.transparent = transparent</span>
<a href="#l16.585"></a><span id="l16.585" class="difflineplus">+        self.background = background</span>
<a href="#l16.586"></a><span id="l16.586" class="difflineplus">+        self.gamma = gamma</span>
<a href="#l16.587"></a><span id="l16.587" class="difflineplus">+        self.greyscale = bool(greyscale)</span>
<a href="#l16.588"></a><span id="l16.588" class="difflineplus">+        self.alpha = bool(alpha)</span>
<a href="#l16.589"></a><span id="l16.589" class="difflineplus">+        self.colormap = bool(palette)</span>
<a href="#l16.590"></a><span id="l16.590" class="difflineplus">+        self.bitdepth = int(bitdepth)</span>
<a href="#l16.591"></a><span id="l16.591" class="difflineplus">+        self.compression = compression</span>
<a href="#l16.592"></a><span id="l16.592" class="difflineplus">+        self.chunk_limit = chunk_limit</span>
<a href="#l16.593"></a><span id="l16.593" class="difflineplus">+        self.interlace = bool(interlace)</span>
<a href="#l16.594"></a><span id="l16.594" class="difflineplus">+        self.palette = check_palette(palette)</span>
<a href="#l16.595"></a><span id="l16.595" class="difflineplus">+</span>
<a href="#l16.596"></a><span id="l16.596" class="difflineplus">+        self.color_type = 4*self.alpha + 2*(not greyscale) + 1*self.colormap</span>
<a href="#l16.597"></a><span id="l16.597" class="difflineplus">+        assert self.color_type in (0,2,3,4,6)</span>
<a href="#l16.598"></a><span id="l16.598" class="difflineplus">+</span>
<a href="#l16.599"></a><span id="l16.599" class="difflineplus">+        self.color_planes = (3,1)[self.greyscale or self.colormap]</span>
<a href="#l16.600"></a><span id="l16.600" class="difflineplus">+        self.planes = self.color_planes + self.alpha</span>
<a href="#l16.601"></a><span id="l16.601" class="difflineplus">+        # :todo: fix for bitdepth &lt; 8</span>
<a href="#l16.602"></a><span id="l16.602" class="difflineplus">+        self.psize = (self.bitdepth/8) * self.planes</span>
<a href="#l16.603"></a><span id="l16.603" class="difflineplus">+</span>
<a href="#l16.604"></a><span id="l16.604" class="difflineplus">+    def make_palette(self):</span>
<a href="#l16.605"></a><span id="l16.605" class="difflineplus">+        &quot;&quot;&quot;Create the byte sequences for a ``PLTE`` and if necessary a</span>
<a href="#l16.606"></a><span id="l16.606" class="difflineplus">+        ``tRNS`` chunk.  Returned as a pair (*p*, *t*).  *t* will be</span>
<a href="#l16.607"></a><span id="l16.607" class="difflineplus">+        ``None`` if no ``tRNS`` chunk is necessary.</span>
<a href="#l16.608"></a><span id="l16.608" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.609"></a><span id="l16.609" class="difflineplus">+</span>
<a href="#l16.610"></a><span id="l16.610" class="difflineplus">+        p = array('B')</span>
<a href="#l16.611"></a><span id="l16.611" class="difflineplus">+        t = array('B')</span>
<a href="#l16.612"></a><span id="l16.612" class="difflineplus">+</span>
<a href="#l16.613"></a><span id="l16.613" class="difflineplus">+        for x in self.palette:</span>
<a href="#l16.614"></a><span id="l16.614" class="difflineplus">+            p.extend(x[0:3])</span>
<a href="#l16.615"></a><span id="l16.615" class="difflineplus">+            if len(x) &gt; 3:</span>
<a href="#l16.616"></a><span id="l16.616" class="difflineplus">+                t.append(x[3])</span>
<a href="#l16.617"></a><span id="l16.617" class="difflineplus">+        p = tostring(p)</span>
<a href="#l16.618"></a><span id="l16.618" class="difflineplus">+        t = tostring(t)</span>
<a href="#l16.619"></a><span id="l16.619" class="difflineplus">+        if t:</span>
<a href="#l16.620"></a><span id="l16.620" class="difflineplus">+            return p,t</span>
<a href="#l16.621"></a><span id="l16.621" class="difflineplus">+        return p,None</span>
<a href="#l16.622"></a><span id="l16.622" class="difflineplus">+</span>
<a href="#l16.623"></a><span id="l16.623" class="difflineplus">+    def write(self, outfile, rows):</span>
<a href="#l16.624"></a><span id="l16.624" class="difflineplus">+        &quot;&quot;&quot;Write a PNG image to the output file.  `rows` should be</span>
<a href="#l16.625"></a><span id="l16.625" class="difflineplus">+        an iterable that yields each row in boxed row flat pixel format.</span>
<a href="#l16.626"></a><span id="l16.626" class="difflineplus">+        The rows should be the rows of the original image, so there</span>
<a href="#l16.627"></a><span id="l16.627" class="difflineplus">+        should be ``self.height`` rows of ``self.width * self.planes`` values.</span>
<a href="#l16.628"></a><span id="l16.628" class="difflineplus">+        If `interlace` is specified (when creating the instance), then</span>
<a href="#l16.629"></a><span id="l16.629" class="difflineplus">+        an interlaced PNG file will be written.  Supply the rows in the</span>
<a href="#l16.630"></a><span id="l16.630" class="difflineplus">+        normal image order; the interlacing is carried out internally.</span>
<a href="#l16.631"></a><span id="l16.631" class="difflineplus">+        </span>
<a href="#l16.632"></a><span id="l16.632" class="difflineplus">+        .. note ::</span>
<a href="#l16.633"></a><span id="l16.633" class="difflineplus">+</span>
<a href="#l16.634"></a><span id="l16.634" class="difflineplus">+          Interlacing will require the entire image to be in working memory.</span>
<a href="#l16.635"></a><span id="l16.635" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.636"></a><span id="l16.636" class="difflineplus">+</span>
<a href="#l16.637"></a><span id="l16.637" class="difflineplus">+        if self.interlace:</span>
<a href="#l16.638"></a><span id="l16.638" class="difflineplus">+            fmt = 'BH'[self.bitdepth &gt; 8]</span>
<a href="#l16.639"></a><span id="l16.639" class="difflineplus">+            a = array(fmt, itertools.chain(*rows))</span>
<a href="#l16.640"></a><span id="l16.640" class="difflineplus">+            return self.write_array(outfile, a)</span>
<a href="#l16.641"></a><span id="l16.641" class="difflineplus">+        else:</span>
<a href="#l16.642"></a><span id="l16.642" class="difflineplus">+            nrows = self.write_passes(outfile, rows)</span>
<a href="#l16.643"></a><span id="l16.643" class="difflineplus">+            if nrows != self.height:</span>
<a href="#l16.644"></a><span id="l16.644" class="difflineplus">+                raise ValueError(</span>
<a href="#l16.645"></a><span id="l16.645" class="difflineplus">+                  &quot;rows supplied (%d) does not match height (%d)&quot; %</span>
<a href="#l16.646"></a><span id="l16.646" class="difflineplus">+                  (nrows, self.height))</span>
<a href="#l16.647"></a><span id="l16.647" class="difflineplus">+</span>
<a href="#l16.648"></a><span id="l16.648" class="difflineplus">+    def write_passes(self, outfile, rows, packed=False):</span>
<a href="#l16.649"></a><span id="l16.649" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.650"></a><span id="l16.650" class="difflineplus">+        Write a PNG image to the output file.</span>
<a href="#l16.651"></a><span id="l16.651" class="difflineplus">+</span>
<a href="#l16.652"></a><span id="l16.652" class="difflineplus">+        Most users are expected to find the :meth:`write` or</span>
<a href="#l16.653"></a><span id="l16.653" class="difflineplus">+        :meth:`write_array` method more convenient.</span>
<a href="#l16.654"></a><span id="l16.654" class="difflineplus">+        </span>
<a href="#l16.655"></a><span id="l16.655" class="difflineplus">+        The rows should be given to this method in the order that</span>
<a href="#l16.656"></a><span id="l16.656" class="difflineplus">+        they appear in the output file.  For straightlaced images,</span>
<a href="#l16.657"></a><span id="l16.657" class="difflineplus">+        this is the usual top to bottom ordering, but for interlaced</span>
<a href="#l16.658"></a><span id="l16.658" class="difflineplus">+        images the rows should have already been interlaced before</span>
<a href="#l16.659"></a><span id="l16.659" class="difflineplus">+        passing them to this function.</span>
<a href="#l16.660"></a><span id="l16.660" class="difflineplus">+</span>
<a href="#l16.661"></a><span id="l16.661" class="difflineplus">+        `rows` should be an iterable that yields each row.  When</span>
<a href="#l16.662"></a><span id="l16.662" class="difflineplus">+        `packed` is ``False`` the rows should be in boxed row flat pixel</span>
<a href="#l16.663"></a><span id="l16.663" class="difflineplus">+        format; when `packed` is ``True`` each row should be a packed</span>
<a href="#l16.664"></a><span id="l16.664" class="difflineplus">+        sequence of bytes.</span>
<a href="#l16.665"></a><span id="l16.665" class="difflineplus">+</span>
<a href="#l16.666"></a><span id="l16.666" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.667"></a><span id="l16.667" class="difflineplus">+</span>
<a href="#l16.668"></a><span id="l16.668" class="difflineplus">+        # http://www.w3.org/TR/PNG/#5PNG-file-signature</span>
<a href="#l16.669"></a><span id="l16.669" class="difflineplus">+        outfile.write(_signature)</span>
<a href="#l16.670"></a><span id="l16.670" class="difflineplus">+</span>
<a href="#l16.671"></a><span id="l16.671" class="difflineplus">+        # http://www.w3.org/TR/PNG/#11IHDR</span>
<a href="#l16.672"></a><span id="l16.672" class="difflineplus">+        write_chunk(outfile, 'IHDR',</span>
<a href="#l16.673"></a><span id="l16.673" class="difflineplus">+                    struct.pack(&quot;!2I5B&quot;, self.width, self.height,</span>
<a href="#l16.674"></a><span id="l16.674" class="difflineplus">+                                self.bitdepth, self.color_type,</span>
<a href="#l16.675"></a><span id="l16.675" class="difflineplus">+                                0, 0, self.interlace))</span>
<a href="#l16.676"></a><span id="l16.676" class="difflineplus">+</span>
<a href="#l16.677"></a><span id="l16.677" class="difflineplus">+        # See :chunk:order</span>
<a href="#l16.678"></a><span id="l16.678" class="difflineplus">+        # http://www.w3.org/TR/PNG/#11gAMA</span>
<a href="#l16.679"></a><span id="l16.679" class="difflineplus">+        if self.gamma is not None:</span>
<a href="#l16.680"></a><span id="l16.680" class="difflineplus">+            write_chunk(outfile, 'gAMA',</span>
<a href="#l16.681"></a><span id="l16.681" class="difflineplus">+                        struct.pack(&quot;!L&quot;, int(round(self.gamma*1e5))))</span>
<a href="#l16.682"></a><span id="l16.682" class="difflineplus">+</span>
<a href="#l16.683"></a><span id="l16.683" class="difflineplus">+        # See :chunk:order</span>
<a href="#l16.684"></a><span id="l16.684" class="difflineplus">+        # http://www.w3.org/TR/PNG/#11sBIT</span>
<a href="#l16.685"></a><span id="l16.685" class="difflineplus">+        if self.rescale:</span>
<a href="#l16.686"></a><span id="l16.686" class="difflineplus">+            write_chunk(outfile, 'sBIT',</span>
<a href="#l16.687"></a><span id="l16.687" class="difflineplus">+                struct.pack('%dB' % self.planes,</span>
<a href="#l16.688"></a><span id="l16.688" class="difflineplus">+                            *[self.rescale[0]]*self.planes))</span>
<a href="#l16.689"></a><span id="l16.689" class="difflineplus">+        </span>
<a href="#l16.690"></a><span id="l16.690" class="difflineplus">+        # :chunk:order: Without a palette (PLTE chunk), ordering is</span>
<a href="#l16.691"></a><span id="l16.691" class="difflineplus">+        # relatively relaxed.  With one, gAMA chunk must precede PLTE</span>
<a href="#l16.692"></a><span id="l16.692" class="difflineplus">+        # chunk which must precede tRNS and bKGD.</span>
<a href="#l16.693"></a><span id="l16.693" class="difflineplus">+        # See http://www.w3.org/TR/PNG/#5ChunkOrdering</span>
<a href="#l16.694"></a><span id="l16.694" class="difflineplus">+        if self.palette:</span>
<a href="#l16.695"></a><span id="l16.695" class="difflineplus">+            p,t = self.make_palette()</span>
<a href="#l16.696"></a><span id="l16.696" class="difflineplus">+            write_chunk(outfile, 'PLTE', p)</span>
<a href="#l16.697"></a><span id="l16.697" class="difflineplus">+            if t:</span>
<a href="#l16.698"></a><span id="l16.698" class="difflineplus">+                # tRNS chunk is optional.  Only needed if palette entries</span>
<a href="#l16.699"></a><span id="l16.699" class="difflineplus">+                # have alpha.</span>
<a href="#l16.700"></a><span id="l16.700" class="difflineplus">+                write_chunk(outfile, 'tRNS', t)</span>
<a href="#l16.701"></a><span id="l16.701" class="difflineplus">+</span>
<a href="#l16.702"></a><span id="l16.702" class="difflineplus">+        # http://www.w3.org/TR/PNG/#11tRNS</span>
<a href="#l16.703"></a><span id="l16.703" class="difflineplus">+        if self.transparent is not None:</span>
<a href="#l16.704"></a><span id="l16.704" class="difflineplus">+            if self.greyscale:</span>
<a href="#l16.705"></a><span id="l16.705" class="difflineplus">+                write_chunk(outfile, 'tRNS',</span>
<a href="#l16.706"></a><span id="l16.706" class="difflineplus">+                            struct.pack(&quot;!1H&quot;, *self.transparent))</span>
<a href="#l16.707"></a><span id="l16.707" class="difflineplus">+            else:</span>
<a href="#l16.708"></a><span id="l16.708" class="difflineplus">+                write_chunk(outfile, 'tRNS',</span>
<a href="#l16.709"></a><span id="l16.709" class="difflineplus">+                            struct.pack(&quot;!3H&quot;, *self.transparent))</span>
<a href="#l16.710"></a><span id="l16.710" class="difflineplus">+</span>
<a href="#l16.711"></a><span id="l16.711" class="difflineplus">+        # http://www.w3.org/TR/PNG/#11bKGD</span>
<a href="#l16.712"></a><span id="l16.712" class="difflineplus">+        if self.background is not None:</span>
<a href="#l16.713"></a><span id="l16.713" class="difflineplus">+            if self.greyscale:</span>
<a href="#l16.714"></a><span id="l16.714" class="difflineplus">+                write_chunk(outfile, 'bKGD',</span>
<a href="#l16.715"></a><span id="l16.715" class="difflineplus">+                            struct.pack(&quot;!1H&quot;, *self.background))</span>
<a href="#l16.716"></a><span id="l16.716" class="difflineplus">+            else:</span>
<a href="#l16.717"></a><span id="l16.717" class="difflineplus">+                write_chunk(outfile, 'bKGD',</span>
<a href="#l16.718"></a><span id="l16.718" class="difflineplus">+                            struct.pack(&quot;!3H&quot;, *self.background))</span>
<a href="#l16.719"></a><span id="l16.719" class="difflineplus">+</span>
<a href="#l16.720"></a><span id="l16.720" class="difflineplus">+        # http://www.w3.org/TR/PNG/#11IDAT</span>
<a href="#l16.721"></a><span id="l16.721" class="difflineplus">+        if self.compression is not None:</span>
<a href="#l16.722"></a><span id="l16.722" class="difflineplus">+            compressor = zlib.compressobj(self.compression)</span>
<a href="#l16.723"></a><span id="l16.723" class="difflineplus">+        else:</span>
<a href="#l16.724"></a><span id="l16.724" class="difflineplus">+            compressor = zlib.compressobj()</span>
<a href="#l16.725"></a><span id="l16.725" class="difflineplus">+</span>
<a href="#l16.726"></a><span id="l16.726" class="difflineplus">+        # Choose an extend function based on the bitdepth.  The extend</span>
<a href="#l16.727"></a><span id="l16.727" class="difflineplus">+        # function packs/decomposes the pixel values into bytes and</span>
<a href="#l16.728"></a><span id="l16.728" class="difflineplus">+        # stuffs them onto the data array.</span>
<a href="#l16.729"></a><span id="l16.729" class="difflineplus">+        data = array('B')</span>
<a href="#l16.730"></a><span id="l16.730" class="difflineplus">+        if self.bitdepth == 8 or packed:</span>
<a href="#l16.731"></a><span id="l16.731" class="difflineplus">+            extend = data.extend</span>
<a href="#l16.732"></a><span id="l16.732" class="difflineplus">+        elif self.bitdepth == 16:</span>
<a href="#l16.733"></a><span id="l16.733" class="difflineplus">+            # Decompose into bytes</span>
<a href="#l16.734"></a><span id="l16.734" class="difflineplus">+            def extend(sl):</span>
<a href="#l16.735"></a><span id="l16.735" class="difflineplus">+                fmt = '!%dH' % len(sl)</span>
<a href="#l16.736"></a><span id="l16.736" class="difflineplus">+                data.extend(array('B', struct.pack(fmt, *sl)))</span>
<a href="#l16.737"></a><span id="l16.737" class="difflineplus">+        else:</span>
<a href="#l16.738"></a><span id="l16.738" class="difflineplus">+            # Pack into bytes</span>
<a href="#l16.739"></a><span id="l16.739" class="difflineplus">+            assert self.bitdepth &lt; 8</span>
<a href="#l16.740"></a><span id="l16.740" class="difflineplus">+            # samples per byte</span>
<a href="#l16.741"></a><span id="l16.741" class="difflineplus">+            spb = int(8/self.bitdepth)</span>
<a href="#l16.742"></a><span id="l16.742" class="difflineplus">+            def extend(sl):</span>
<a href="#l16.743"></a><span id="l16.743" class="difflineplus">+                a = array('B', sl)</span>
<a href="#l16.744"></a><span id="l16.744" class="difflineplus">+                # Adding padding bytes so we can group into a whole</span>
<a href="#l16.745"></a><span id="l16.745" class="difflineplus">+                # number of spb-tuples.</span>
<a href="#l16.746"></a><span id="l16.746" class="difflineplus">+                l = float(len(a))</span>
<a href="#l16.747"></a><span id="l16.747" class="difflineplus">+                extra = math.ceil(l / float(spb))*spb - l</span>
<a href="#l16.748"></a><span id="l16.748" class="difflineplus">+                a.extend([0]*int(extra))</span>
<a href="#l16.749"></a><span id="l16.749" class="difflineplus">+                # Pack into bytes</span>
<a href="#l16.750"></a><span id="l16.750" class="difflineplus">+                l = group(a, spb)</span>
<a href="#l16.751"></a><span id="l16.751" class="difflineplus">+                l = map(lambda e: reduce(lambda x,y:</span>
<a href="#l16.752"></a><span id="l16.752" class="difflineplus">+                                           (x &lt;&lt; self.bitdepth) + y, e), l)</span>
<a href="#l16.753"></a><span id="l16.753" class="difflineplus">+                data.extend(l)</span>
<a href="#l16.754"></a><span id="l16.754" class="difflineplus">+        if self.rescale:</span>
<a href="#l16.755"></a><span id="l16.755" class="difflineplus">+            oldextend = extend</span>
<a href="#l16.756"></a><span id="l16.756" class="difflineplus">+            factor = \</span>
<a href="#l16.757"></a><span id="l16.757" class="difflineplus">+              float(2**self.rescale[1]-1) / float(2**self.rescale[0]-1)</span>
<a href="#l16.758"></a><span id="l16.758" class="difflineplus">+            def extend(sl):</span>
<a href="#l16.759"></a><span id="l16.759" class="difflineplus">+                oldextend(map(lambda x: int(round(factor*x)), sl))</span>
<a href="#l16.760"></a><span id="l16.760" class="difflineplus">+</span>
<a href="#l16.761"></a><span id="l16.761" class="difflineplus">+        # Build the first row, testing mostly to see if we need to</span>
<a href="#l16.762"></a><span id="l16.762" class="difflineplus">+        # changed the extend function to cope with NumPy integer types</span>
<a href="#l16.763"></a><span id="l16.763" class="difflineplus">+        # (they cause our ordinary definition of extend to fail, so we</span>
<a href="#l16.764"></a><span id="l16.764" class="difflineplus">+        # wrap it).  See</span>
<a href="#l16.765"></a><span id="l16.765" class="difflineplus">+        # http://code.google.com/p/pypng/issues/detail?id=44</span>
<a href="#l16.766"></a><span id="l16.766" class="difflineplus">+        enumrows = enumerate(rows)</span>
<a href="#l16.767"></a><span id="l16.767" class="difflineplus">+        del rows</span>
<a href="#l16.768"></a><span id="l16.768" class="difflineplus">+</span>
<a href="#l16.769"></a><span id="l16.769" class="difflineplus">+        # First row's filter type.</span>
<a href="#l16.770"></a><span id="l16.770" class="difflineplus">+        data.append(0)</span>
<a href="#l16.771"></a><span id="l16.771" class="difflineplus">+        # :todo: Certain exceptions in the call to ``.next()`` or the</span>
<a href="#l16.772"></a><span id="l16.772" class="difflineplus">+        # following try would indicate no row data supplied.</span>
<a href="#l16.773"></a><span id="l16.773" class="difflineplus">+        # Should catch.</span>
<a href="#l16.774"></a><span id="l16.774" class="difflineplus">+        i,row = enumrows.next()</span>
<a href="#l16.775"></a><span id="l16.775" class="difflineplus">+        try:</span>
<a href="#l16.776"></a><span id="l16.776" class="difflineplus">+            # If this fails...</span>
<a href="#l16.777"></a><span id="l16.777" class="difflineplus">+            extend(row)</span>
<a href="#l16.778"></a><span id="l16.778" class="difflineplus">+        except:</span>
<a href="#l16.779"></a><span id="l16.779" class="difflineplus">+            # ... try a version that converts the values to int first.</span>
<a href="#l16.780"></a><span id="l16.780" class="difflineplus">+            # Not only does this work for the (slightly broken) NumPy</span>
<a href="#l16.781"></a><span id="l16.781" class="difflineplus">+            # types, there are probably lots of other, unknown, &quot;nearly&quot;</span>
<a href="#l16.782"></a><span id="l16.782" class="difflineplus">+            # int types it works for.</span>
<a href="#l16.783"></a><span id="l16.783" class="difflineplus">+            def wrapmapint(f):</span>
<a href="#l16.784"></a><span id="l16.784" class="difflineplus">+                return lambda sl: f(map(int, sl))</span>
<a href="#l16.785"></a><span id="l16.785" class="difflineplus">+            extend = wrapmapint(extend)</span>
<a href="#l16.786"></a><span id="l16.786" class="difflineplus">+            del wrapmapint</span>
<a href="#l16.787"></a><span id="l16.787" class="difflineplus">+            extend(row)</span>
<a href="#l16.788"></a><span id="l16.788" class="difflineplus">+</span>
<a href="#l16.789"></a><span id="l16.789" class="difflineplus">+        for i,row in enumrows:</span>
<a href="#l16.790"></a><span id="l16.790" class="difflineplus">+            # Add &quot;None&quot; filter type.  Currently, it's essential that</span>
<a href="#l16.791"></a><span id="l16.791" class="difflineplus">+            # this filter type be used for every scanline as we do not</span>
<a href="#l16.792"></a><span id="l16.792" class="difflineplus">+            # mark the first row of a reduced pass image; that means we</span>
<a href="#l16.793"></a><span id="l16.793" class="difflineplus">+            # could accidentally compute the wrong filtered scanline if</span>
<a href="#l16.794"></a><span id="l16.794" class="difflineplus">+            # we used &quot;up&quot;, &quot;average&quot;, or &quot;paeth&quot; on such a line.</span>
<a href="#l16.795"></a><span id="l16.795" class="difflineplus">+            data.append(0)</span>
<a href="#l16.796"></a><span id="l16.796" class="difflineplus">+            extend(row)</span>
<a href="#l16.797"></a><span id="l16.797" class="difflineplus">+            if len(data) &gt; self.chunk_limit:</span>
<a href="#l16.798"></a><span id="l16.798" class="difflineplus">+                compressed = compressor.compress(tostring(data))</span>
<a href="#l16.799"></a><span id="l16.799" class="difflineplus">+                if len(compressed):</span>
<a href="#l16.800"></a><span id="l16.800" class="difflineplus">+                    # print &gt;&gt; sys.stderr, len(data), len(compressed)</span>
<a href="#l16.801"></a><span id="l16.801" class="difflineplus">+                    write_chunk(outfile, 'IDAT', compressed)</span>
<a href="#l16.802"></a><span id="l16.802" class="difflineplus">+                # Because of our very witty definition of ``extend``,</span>
<a href="#l16.803"></a><span id="l16.803" class="difflineplus">+                # above, we must re-use the same ``data`` object.  Hence</span>
<a href="#l16.804"></a><span id="l16.804" class="difflineplus">+                # we use ``del`` to empty this one, rather than create a</span>
<a href="#l16.805"></a><span id="l16.805" class="difflineplus">+                # fresh one (which would be my natural FP instinct).</span>
<a href="#l16.806"></a><span id="l16.806" class="difflineplus">+                del data[:]</span>
<a href="#l16.807"></a><span id="l16.807" class="difflineplus">+        if len(data):</span>
<a href="#l16.808"></a><span id="l16.808" class="difflineplus">+            compressed = compressor.compress(tostring(data))</span>
<a href="#l16.809"></a><span id="l16.809" class="difflineplus">+        else:</span>
<a href="#l16.810"></a><span id="l16.810" class="difflineplus">+            compressed = ''</span>
<a href="#l16.811"></a><span id="l16.811" class="difflineplus">+        flushed = compressor.flush()</span>
<a href="#l16.812"></a><span id="l16.812" class="difflineplus">+        if len(compressed) or len(flushed):</span>
<a href="#l16.813"></a><span id="l16.813" class="difflineplus">+            # print &gt;&gt; sys.stderr, len(data), len(compressed), len(flushed)</span>
<a href="#l16.814"></a><span id="l16.814" class="difflineplus">+            write_chunk(outfile, 'IDAT', compressed + flushed)</span>
<a href="#l16.815"></a><span id="l16.815" class="difflineplus">+        # http://www.w3.org/TR/PNG/#11IEND</span>
<a href="#l16.816"></a><span id="l16.816" class="difflineplus">+        write_chunk(outfile, 'IEND')</span>
<a href="#l16.817"></a><span id="l16.817" class="difflineplus">+        return i+1</span>
<a href="#l16.818"></a><span id="l16.818" class="difflineplus">+</span>
<a href="#l16.819"></a><span id="l16.819" class="difflineplus">+    def write_array(self, outfile, pixels):</span>
<a href="#l16.820"></a><span id="l16.820" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.821"></a><span id="l16.821" class="difflineplus">+        Write an array in flat row flat pixel format as a PNG file on</span>
<a href="#l16.822"></a><span id="l16.822" class="difflineplus">+        the output file.  See also :meth:`write` method.</span>
<a href="#l16.823"></a><span id="l16.823" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.824"></a><span id="l16.824" class="difflineplus">+</span>
<a href="#l16.825"></a><span id="l16.825" class="difflineplus">+        if self.interlace:</span>
<a href="#l16.826"></a><span id="l16.826" class="difflineplus">+            self.write_passes(outfile, self.array_scanlines_interlace(pixels))</span>
<a href="#l16.827"></a><span id="l16.827" class="difflineplus">+        else:</span>
<a href="#l16.828"></a><span id="l16.828" class="difflineplus">+            self.write_passes(outfile, self.array_scanlines(pixels))</span>
<a href="#l16.829"></a><span id="l16.829" class="difflineplus">+</span>
<a href="#l16.830"></a><span id="l16.830" class="difflineplus">+    def write_packed(self, outfile, rows):</span>
<a href="#l16.831"></a><span id="l16.831" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.832"></a><span id="l16.832" class="difflineplus">+        Write PNG file to `outfile`.  The pixel data comes from `rows`</span>
<a href="#l16.833"></a><span id="l16.833" class="difflineplus">+        which should be in boxed row packed format.  Each row should be</span>
<a href="#l16.834"></a><span id="l16.834" class="difflineplus">+        a sequence of packed bytes.</span>
<a href="#l16.835"></a><span id="l16.835" class="difflineplus">+</span>
<a href="#l16.836"></a><span id="l16.836" class="difflineplus">+        Technically, this method does work for interlaced images but it</span>
<a href="#l16.837"></a><span id="l16.837" class="difflineplus">+        is best avoided.  For interlaced images, the rows should be</span>
<a href="#l16.838"></a><span id="l16.838" class="difflineplus">+        presented in the order that they appear in the file.</span>
<a href="#l16.839"></a><span id="l16.839" class="difflineplus">+</span>
<a href="#l16.840"></a><span id="l16.840" class="difflineplus">+        This method should not be used when the source image bit depth</span>
<a href="#l16.841"></a><span id="l16.841" class="difflineplus">+        is not one naturally supported by PNG; the bit depth should be</span>
<a href="#l16.842"></a><span id="l16.842" class="difflineplus">+        1, 2, 4, 8, or 16.</span>
<a href="#l16.843"></a><span id="l16.843" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.844"></a><span id="l16.844" class="difflineplus">+</span>
<a href="#l16.845"></a><span id="l16.845" class="difflineplus">+        if self.rescale:</span>
<a href="#l16.846"></a><span id="l16.846" class="difflineplus">+            raise Error(&quot;write_packed method not suitable for bit depth %d&quot; %</span>
<a href="#l16.847"></a><span id="l16.847" class="difflineplus">+              self.rescale[0])</span>
<a href="#l16.848"></a><span id="l16.848" class="difflineplus">+        return self.write_passes(outfile, rows, packed=True)</span>
<a href="#l16.849"></a><span id="l16.849" class="difflineplus">+</span>
<a href="#l16.850"></a><span id="l16.850" class="difflineplus">+    def convert_pnm(self, infile, outfile):</span>
<a href="#l16.851"></a><span id="l16.851" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.852"></a><span id="l16.852" class="difflineplus">+        Convert a PNM file containing raw pixel data into a PNG file</span>
<a href="#l16.853"></a><span id="l16.853" class="difflineplus">+        with the parameters set in the writer object.  Works for</span>
<a href="#l16.854"></a><span id="l16.854" class="difflineplus">+        (binary) PGM, PPM, and PAM formats.</span>
<a href="#l16.855"></a><span id="l16.855" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.856"></a><span id="l16.856" class="difflineplus">+</span>
<a href="#l16.857"></a><span id="l16.857" class="difflineplus">+        if self.interlace:</span>
<a href="#l16.858"></a><span id="l16.858" class="difflineplus">+            pixels = array('B')</span>
<a href="#l16.859"></a><span id="l16.859" class="difflineplus">+            pixels.fromfile(infile,</span>
<a href="#l16.860"></a><span id="l16.860" class="difflineplus">+                            (self.bitdepth/8) * self.color_planes *</span>
<a href="#l16.861"></a><span id="l16.861" class="difflineplus">+                            self.width * self.height)</span>
<a href="#l16.862"></a><span id="l16.862" class="difflineplus">+            self.write_passes(outfile, self.array_scanlines_interlace(pixels))</span>
<a href="#l16.863"></a><span id="l16.863" class="difflineplus">+        else:</span>
<a href="#l16.864"></a><span id="l16.864" class="difflineplus">+            self.write_passes(outfile, self.file_scanlines(infile))</span>
<a href="#l16.865"></a><span id="l16.865" class="difflineplus">+</span>
<a href="#l16.866"></a><span id="l16.866" class="difflineplus">+    def convert_ppm_and_pgm(self, ppmfile, pgmfile, outfile):</span>
<a href="#l16.867"></a><span id="l16.867" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.868"></a><span id="l16.868" class="difflineplus">+        Convert a PPM and PGM file containing raw pixel data into a</span>
<a href="#l16.869"></a><span id="l16.869" class="difflineplus">+        PNG outfile with the parameters set in the writer object.</span>
<a href="#l16.870"></a><span id="l16.870" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.871"></a><span id="l16.871" class="difflineplus">+        pixels = array('B')</span>
<a href="#l16.872"></a><span id="l16.872" class="difflineplus">+        pixels.fromfile(ppmfile,</span>
<a href="#l16.873"></a><span id="l16.873" class="difflineplus">+                        (self.bitdepth/8) * self.color_planes *</span>
<a href="#l16.874"></a><span id="l16.874" class="difflineplus">+                        self.width * self.height)</span>
<a href="#l16.875"></a><span id="l16.875" class="difflineplus">+        apixels = array('B')</span>
<a href="#l16.876"></a><span id="l16.876" class="difflineplus">+        apixels.fromfile(pgmfile,</span>
<a href="#l16.877"></a><span id="l16.877" class="difflineplus">+                         (self.bitdepth/8) *</span>
<a href="#l16.878"></a><span id="l16.878" class="difflineplus">+                         self.width * self.height)</span>
<a href="#l16.879"></a><span id="l16.879" class="difflineplus">+        pixels = interleave_planes(pixels, apixels,</span>
<a href="#l16.880"></a><span id="l16.880" class="difflineplus">+                                   (self.bitdepth/8) * self.color_planes,</span>
<a href="#l16.881"></a><span id="l16.881" class="difflineplus">+                                   (self.bitdepth/8))</span>
<a href="#l16.882"></a><span id="l16.882" class="difflineplus">+        if self.interlace:</span>
<a href="#l16.883"></a><span id="l16.883" class="difflineplus">+            self.write_passes(outfile, self.array_scanlines_interlace(pixels))</span>
<a href="#l16.884"></a><span id="l16.884" class="difflineplus">+        else:</span>
<a href="#l16.885"></a><span id="l16.885" class="difflineplus">+            self.write_passes(outfile, self.array_scanlines(pixels))</span>
<a href="#l16.886"></a><span id="l16.886" class="difflineplus">+</span>
<a href="#l16.887"></a><span id="l16.887" class="difflineplus">+    def file_scanlines(self, infile):</span>
<a href="#l16.888"></a><span id="l16.888" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.889"></a><span id="l16.889" class="difflineplus">+        Generates boxed rows in flat pixel format, from the input file</span>
<a href="#l16.890"></a><span id="l16.890" class="difflineplus">+        `infile`.  It assumes that the input file is in a &quot;Netpbm-like&quot;</span>
<a href="#l16.891"></a><span id="l16.891" class="difflineplus">+        binary format, and is positioned at the beginning of the first</span>
<a href="#l16.892"></a><span id="l16.892" class="difflineplus">+        pixel.  The number of pixels to read is taken from the image</span>
<a href="#l16.893"></a><span id="l16.893" class="difflineplus">+        dimensions (`width`, `height`, `planes`) and the number of bytes</span>
<a href="#l16.894"></a><span id="l16.894" class="difflineplus">+        per value is implied by the image `bitdepth`.</span>
<a href="#l16.895"></a><span id="l16.895" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.896"></a><span id="l16.896" class="difflineplus">+</span>
<a href="#l16.897"></a><span id="l16.897" class="difflineplus">+        # Values per row</span>
<a href="#l16.898"></a><span id="l16.898" class="difflineplus">+        vpr = self.width * self.planes</span>
<a href="#l16.899"></a><span id="l16.899" class="difflineplus">+        row_bytes = vpr</span>
<a href="#l16.900"></a><span id="l16.900" class="difflineplus">+        if self.bitdepth &gt; 8:</span>
<a href="#l16.901"></a><span id="l16.901" class="difflineplus">+            assert self.bitdepth == 16</span>
<a href="#l16.902"></a><span id="l16.902" class="difflineplus">+            row_bytes *= 2</span>
<a href="#l16.903"></a><span id="l16.903" class="difflineplus">+            fmt = '&gt;%dH' % vpr</span>
<a href="#l16.904"></a><span id="l16.904" class="difflineplus">+            def line():</span>
<a href="#l16.905"></a><span id="l16.905" class="difflineplus">+                return array('H', struct.unpack(fmt, infile.read(row_bytes)))</span>
<a href="#l16.906"></a><span id="l16.906" class="difflineplus">+        else:</span>
<a href="#l16.907"></a><span id="l16.907" class="difflineplus">+            def line():</span>
<a href="#l16.908"></a><span id="l16.908" class="difflineplus">+                scanline = array('B', infile.read(row_bytes))</span>
<a href="#l16.909"></a><span id="l16.909" class="difflineplus">+                return scanline</span>
<a href="#l16.910"></a><span id="l16.910" class="difflineplus">+        for y in range(self.height):</span>
<a href="#l16.911"></a><span id="l16.911" class="difflineplus">+            yield line()</span>
<a href="#l16.912"></a><span id="l16.912" class="difflineplus">+</span>
<a href="#l16.913"></a><span id="l16.913" class="difflineplus">+    def array_scanlines(self, pixels):</span>
<a href="#l16.914"></a><span id="l16.914" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.915"></a><span id="l16.915" class="difflineplus">+        Generates boxed rows (flat pixels) from flat rows (flat pixels)</span>
<a href="#l16.916"></a><span id="l16.916" class="difflineplus">+        in an array.</span>
<a href="#l16.917"></a><span id="l16.917" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.918"></a><span id="l16.918" class="difflineplus">+</span>
<a href="#l16.919"></a><span id="l16.919" class="difflineplus">+        # Values per row</span>
<a href="#l16.920"></a><span id="l16.920" class="difflineplus">+        vpr = self.width * self.planes</span>
<a href="#l16.921"></a><span id="l16.921" class="difflineplus">+        stop = 0</span>
<a href="#l16.922"></a><span id="l16.922" class="difflineplus">+        for y in range(self.height):</span>
<a href="#l16.923"></a><span id="l16.923" class="difflineplus">+            start = stop</span>
<a href="#l16.924"></a><span id="l16.924" class="difflineplus">+            stop = start + vpr</span>
<a href="#l16.925"></a><span id="l16.925" class="difflineplus">+            yield pixels[start:stop]</span>
<a href="#l16.926"></a><span id="l16.926" class="difflineplus">+</span>
<a href="#l16.927"></a><span id="l16.927" class="difflineplus">+    def array_scanlines_interlace(self, pixels):</span>
<a href="#l16.928"></a><span id="l16.928" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.929"></a><span id="l16.929" class="difflineplus">+        Generator for interlaced scanlines from an array.  `pixels` is</span>
<a href="#l16.930"></a><span id="l16.930" class="difflineplus">+        the full source image in flat row flat pixel format.  The</span>
<a href="#l16.931"></a><span id="l16.931" class="difflineplus">+        generator yields each scanline of the reduced passes in turn, in</span>
<a href="#l16.932"></a><span id="l16.932" class="difflineplus">+        boxed row flat pixel format.</span>
<a href="#l16.933"></a><span id="l16.933" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.934"></a><span id="l16.934" class="difflineplus">+</span>
<a href="#l16.935"></a><span id="l16.935" class="difflineplus">+        # http://www.w3.org/TR/PNG/#8InterlaceMethods</span>
<a href="#l16.936"></a><span id="l16.936" class="difflineplus">+        # Array type.</span>
<a href="#l16.937"></a><span id="l16.937" class="difflineplus">+        fmt = 'BH'[self.bitdepth &gt; 8]</span>
<a href="#l16.938"></a><span id="l16.938" class="difflineplus">+        # Value per row</span>
<a href="#l16.939"></a><span id="l16.939" class="difflineplus">+        vpr = self.width * self.planes</span>
<a href="#l16.940"></a><span id="l16.940" class="difflineplus">+        for xstart, ystart, xstep, ystep in _adam7:</span>
<a href="#l16.941"></a><span id="l16.941" class="difflineplus">+            if xstart &gt;= self.width:</span>
<a href="#l16.942"></a><span id="l16.942" class="difflineplus">+                continue</span>
<a href="#l16.943"></a><span id="l16.943" class="difflineplus">+            # Pixels per row (of reduced image)</span>
<a href="#l16.944"></a><span id="l16.944" class="difflineplus">+            ppr = int(math.ceil((self.width-xstart)/float(xstep)))</span>
<a href="#l16.945"></a><span id="l16.945" class="difflineplus">+            # number of values in reduced image row.</span>
<a href="#l16.946"></a><span id="l16.946" class="difflineplus">+            row_len = ppr*self.planes</span>
<a href="#l16.947"></a><span id="l16.947" class="difflineplus">+            for y in range(ystart, self.height, ystep):</span>
<a href="#l16.948"></a><span id="l16.948" class="difflineplus">+                if xstep == 1:</span>
<a href="#l16.949"></a><span id="l16.949" class="difflineplus">+                    offset = y * vpr</span>
<a href="#l16.950"></a><span id="l16.950" class="difflineplus">+                    yield pixels[offset:offset+vpr]</span>
<a href="#l16.951"></a><span id="l16.951" class="difflineplus">+                else:</span>
<a href="#l16.952"></a><span id="l16.952" class="difflineplus">+                    row = array(fmt)</span>
<a href="#l16.953"></a><span id="l16.953" class="difflineplus">+                    # There's no easier way to set the length of an array</span>
<a href="#l16.954"></a><span id="l16.954" class="difflineplus">+                    row.extend(pixels[0:row_len])</span>
<a href="#l16.955"></a><span id="l16.955" class="difflineplus">+                    offset = y * vpr + xstart * self.planes</span>
<a href="#l16.956"></a><span id="l16.956" class="difflineplus">+                    end_offset = (y+1) * vpr</span>
<a href="#l16.957"></a><span id="l16.957" class="difflineplus">+                    skip = self.planes * xstep</span>
<a href="#l16.958"></a><span id="l16.958" class="difflineplus">+                    for i in range(self.planes):</span>
<a href="#l16.959"></a><span id="l16.959" class="difflineplus">+                        row[i::self.planes] = \</span>
<a href="#l16.960"></a><span id="l16.960" class="difflineplus">+                            pixels[offset+i:end_offset:skip]</span>
<a href="#l16.961"></a><span id="l16.961" class="difflineplus">+                    yield row</span>
<a href="#l16.962"></a><span id="l16.962" class="difflineplus">+</span>
<a href="#l16.963"></a><span id="l16.963" class="difflineplus">+def write_chunk(outfile, tag, data=strtobytes('')):</span>
<a href="#l16.964"></a><span id="l16.964" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.965"></a><span id="l16.965" class="difflineplus">+    Write a PNG chunk to the output file, including length and</span>
<a href="#l16.966"></a><span id="l16.966" class="difflineplus">+    checksum.</span>
<a href="#l16.967"></a><span id="l16.967" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.968"></a><span id="l16.968" class="difflineplus">+</span>
<a href="#l16.969"></a><span id="l16.969" class="difflineplus">+    # http://www.w3.org/TR/PNG/#5Chunk-layout</span>
<a href="#l16.970"></a><span id="l16.970" class="difflineplus">+    outfile.write(struct.pack(&quot;!I&quot;, len(data)))</span>
<a href="#l16.971"></a><span id="l16.971" class="difflineplus">+    tag = strtobytes(tag)</span>
<a href="#l16.972"></a><span id="l16.972" class="difflineplus">+    outfile.write(tag)</span>
<a href="#l16.973"></a><span id="l16.973" class="difflineplus">+    outfile.write(data)</span>
<a href="#l16.974"></a><span id="l16.974" class="difflineplus">+    checksum = zlib.crc32(tag)</span>
<a href="#l16.975"></a><span id="l16.975" class="difflineplus">+    checksum = zlib.crc32(data, checksum)</span>
<a href="#l16.976"></a><span id="l16.976" class="difflineplus">+    checksum &amp;= 2**32-1</span>
<a href="#l16.977"></a><span id="l16.977" class="difflineplus">+    outfile.write(struct.pack(&quot;!I&quot;, checksum))</span>
<a href="#l16.978"></a><span id="l16.978" class="difflineplus">+</span>
<a href="#l16.979"></a><span id="l16.979" class="difflineplus">+def write_chunks(out, chunks):</span>
<a href="#l16.980"></a><span id="l16.980" class="difflineplus">+    &quot;&quot;&quot;Create a PNG file by writing out the chunks.&quot;&quot;&quot;</span>
<a href="#l16.981"></a><span id="l16.981" class="difflineplus">+</span>
<a href="#l16.982"></a><span id="l16.982" class="difflineplus">+    out.write(_signature)</span>
<a href="#l16.983"></a><span id="l16.983" class="difflineplus">+    for chunk in chunks:</span>
<a href="#l16.984"></a><span id="l16.984" class="difflineplus">+        write_chunk(out, *chunk)</span>
<a href="#l16.985"></a><span id="l16.985" class="difflineplus">+</span>
<a href="#l16.986"></a><span id="l16.986" class="difflineplus">+def filter_scanline(type, line, fo, prev=None):</span>
<a href="#l16.987"></a><span id="l16.987" class="difflineplus">+    &quot;&quot;&quot;Apply a scanline filter to a scanline.  `type` specifies the</span>
<a href="#l16.988"></a><span id="l16.988" class="difflineplus">+    filter type (0 to 4); `line` specifies the current (unfiltered)</span>
<a href="#l16.989"></a><span id="l16.989" class="difflineplus">+    scanline as a sequence of bytes; `prev` specifies the previous</span>
<a href="#l16.990"></a><span id="l16.990" class="difflineplus">+    (unfiltered) scanline as a sequence of bytes. `fo` specifies the</span>
<a href="#l16.991"></a><span id="l16.991" class="difflineplus">+    filter offset; normally this is size of a pixel in bytes (the number</span>
<a href="#l16.992"></a><span id="l16.992" class="difflineplus">+    of bytes per sample times the number of channels), but when this is</span>
<a href="#l16.993"></a><span id="l16.993" class="difflineplus">+    &lt; 1 (for bit depths &lt; 8) then the filter offset is 1.</span>
<a href="#l16.994"></a><span id="l16.994" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.995"></a><span id="l16.995" class="difflineplus">+</span>
<a href="#l16.996"></a><span id="l16.996" class="difflineplus">+    assert 0 &lt;= type &lt; 5</span>
<a href="#l16.997"></a><span id="l16.997" class="difflineplus">+</span>
<a href="#l16.998"></a><span id="l16.998" class="difflineplus">+    # The output array.  Which, pathetically, we extend one-byte at a</span>
<a href="#l16.999"></a><span id="l16.999" class="difflineplus">+    # time (fortunately this is linear).</span>
<a href="#l16.1000"></a><span id="l16.1000" class="difflineplus">+    out = array('B', [type])</span>
<a href="#l16.1001"></a><span id="l16.1001" class="difflineplus">+</span>
<a href="#l16.1002"></a><span id="l16.1002" class="difflineplus">+    def sub():</span>
<a href="#l16.1003"></a><span id="l16.1003" class="difflineplus">+        ai = -fo</span>
<a href="#l16.1004"></a><span id="l16.1004" class="difflineplus">+        for x in line:</span>
<a href="#l16.1005"></a><span id="l16.1005" class="difflineplus">+            if ai &gt;= 0:</span>
<a href="#l16.1006"></a><span id="l16.1006" class="difflineplus">+                x = (x - line[ai]) &amp; 0xff</span>
<a href="#l16.1007"></a><span id="l16.1007" class="difflineplus">+            out.append(x)</span>
<a href="#l16.1008"></a><span id="l16.1008" class="difflineplus">+            ai += 1</span>
<a href="#l16.1009"></a><span id="l16.1009" class="difflineplus">+    def up():</span>
<a href="#l16.1010"></a><span id="l16.1010" class="difflineplus">+        for i,x in enumerate(line):</span>
<a href="#l16.1011"></a><span id="l16.1011" class="difflineplus">+            x = (x - prev[i]) &amp; 0xff</span>
<a href="#l16.1012"></a><span id="l16.1012" class="difflineplus">+            out.append(x)</span>
<a href="#l16.1013"></a><span id="l16.1013" class="difflineplus">+    def average():</span>
<a href="#l16.1014"></a><span id="l16.1014" class="difflineplus">+        ai = -fo</span>
<a href="#l16.1015"></a><span id="l16.1015" class="difflineplus">+        for i,x in enumerate(line):</span>
<a href="#l16.1016"></a><span id="l16.1016" class="difflineplus">+            if ai &gt;= 0:</span>
<a href="#l16.1017"></a><span id="l16.1017" class="difflineplus">+                x = (x - ((line[ai] + prev[i]) &gt;&gt; 1)) &amp; 0xff</span>
<a href="#l16.1018"></a><span id="l16.1018" class="difflineplus">+            else:</span>
<a href="#l16.1019"></a><span id="l16.1019" class="difflineplus">+                x = (x - (prev[i] &gt;&gt; 1)) &amp; 0xff</span>
<a href="#l16.1020"></a><span id="l16.1020" class="difflineplus">+            out.append(x)</span>
<a href="#l16.1021"></a><span id="l16.1021" class="difflineplus">+            ai += 1</span>
<a href="#l16.1022"></a><span id="l16.1022" class="difflineplus">+    def paeth():</span>
<a href="#l16.1023"></a><span id="l16.1023" class="difflineplus">+        # http://www.w3.org/TR/PNG/#9Filter-type-4-Paeth</span>
<a href="#l16.1024"></a><span id="l16.1024" class="difflineplus">+        ai = -fo # also used for ci</span>
<a href="#l16.1025"></a><span id="l16.1025" class="difflineplus">+        for i,x in enumerate(line):</span>
<a href="#l16.1026"></a><span id="l16.1026" class="difflineplus">+            a = 0</span>
<a href="#l16.1027"></a><span id="l16.1027" class="difflineplus">+            b = prev[i]</span>
<a href="#l16.1028"></a><span id="l16.1028" class="difflineplus">+            c = 0</span>
<a href="#l16.1029"></a><span id="l16.1029" class="difflineplus">+</span>
<a href="#l16.1030"></a><span id="l16.1030" class="difflineplus">+            if ai &gt;= 0:</span>
<a href="#l16.1031"></a><span id="l16.1031" class="difflineplus">+                a = line[ai]</span>
<a href="#l16.1032"></a><span id="l16.1032" class="difflineplus">+                c = prev[ai]</span>
<a href="#l16.1033"></a><span id="l16.1033" class="difflineplus">+            p = a + b - c</span>
<a href="#l16.1034"></a><span id="l16.1034" class="difflineplus">+            pa = abs(p - a)</span>
<a href="#l16.1035"></a><span id="l16.1035" class="difflineplus">+            pb = abs(p - b)</span>
<a href="#l16.1036"></a><span id="l16.1036" class="difflineplus">+            pc = abs(p - c)</span>
<a href="#l16.1037"></a><span id="l16.1037" class="difflineplus">+            if pa &lt;= pb and pa &lt;= pc: Pr = a</span>
<a href="#l16.1038"></a><span id="l16.1038" class="difflineplus">+            elif pb &lt;= pc: Pr = b</span>
<a href="#l16.1039"></a><span id="l16.1039" class="difflineplus">+            else: Pr = c</span>
<a href="#l16.1040"></a><span id="l16.1040" class="difflineplus">+</span>
<a href="#l16.1041"></a><span id="l16.1041" class="difflineplus">+            x = (x - Pr) &amp; 0xff</span>
<a href="#l16.1042"></a><span id="l16.1042" class="difflineplus">+            out.append(x)</span>
<a href="#l16.1043"></a><span id="l16.1043" class="difflineplus">+            ai += 1</span>
<a href="#l16.1044"></a><span id="l16.1044" class="difflineplus">+</span>
<a href="#l16.1045"></a><span id="l16.1045" class="difflineplus">+    if not prev:</span>
<a href="#l16.1046"></a><span id="l16.1046" class="difflineplus">+        # We're on the first line.  Some of the filters can be reduced</span>
<a href="#l16.1047"></a><span id="l16.1047" class="difflineplus">+        # to simpler cases which makes handling the line &quot;off the top&quot;</span>
<a href="#l16.1048"></a><span id="l16.1048" class="difflineplus">+        # of the image simpler.  &quot;up&quot; becomes &quot;none&quot;; &quot;paeth&quot; becomes</span>
<a href="#l16.1049"></a><span id="l16.1049" class="difflineplus">+        # &quot;left&quot; (non-trivial, but true). &quot;average&quot; needs to be handled</span>
<a href="#l16.1050"></a><span id="l16.1050" class="difflineplus">+        # specially.</span>
<a href="#l16.1051"></a><span id="l16.1051" class="difflineplus">+        if type == 2: # &quot;up&quot;</span>
<a href="#l16.1052"></a><span id="l16.1052" class="difflineplus">+            return line # type = 0</span>
<a href="#l16.1053"></a><span id="l16.1053" class="difflineplus">+        elif type == 3:</span>
<a href="#l16.1054"></a><span id="l16.1054" class="difflineplus">+            prev = [0]*len(line)</span>
<a href="#l16.1055"></a><span id="l16.1055" class="difflineplus">+        elif type == 4: # &quot;paeth&quot;</span>
<a href="#l16.1056"></a><span id="l16.1056" class="difflineplus">+            type = 1</span>
<a href="#l16.1057"></a><span id="l16.1057" class="difflineplus">+    if type == 0:</span>
<a href="#l16.1058"></a><span id="l16.1058" class="difflineplus">+        out.extend(line)</span>
<a href="#l16.1059"></a><span id="l16.1059" class="difflineplus">+    elif type == 1:</span>
<a href="#l16.1060"></a><span id="l16.1060" class="difflineplus">+        sub()</span>
<a href="#l16.1061"></a><span id="l16.1061" class="difflineplus">+    elif type == 2:</span>
<a href="#l16.1062"></a><span id="l16.1062" class="difflineplus">+        up()</span>
<a href="#l16.1063"></a><span id="l16.1063" class="difflineplus">+    elif type == 3:</span>
<a href="#l16.1064"></a><span id="l16.1064" class="difflineplus">+        average()</span>
<a href="#l16.1065"></a><span id="l16.1065" class="difflineplus">+    else: # type == 4</span>
<a href="#l16.1066"></a><span id="l16.1066" class="difflineplus">+        paeth()</span>
<a href="#l16.1067"></a><span id="l16.1067" class="difflineplus">+    return out</span>
<a href="#l16.1068"></a><span id="l16.1068" class="difflineplus">+</span>
<a href="#l16.1069"></a><span id="l16.1069" class="difflineplus">+</span>
<a href="#l16.1070"></a><span id="l16.1070" class="difflineplus">+def from_array(a, mode=None, info={}):</span>
<a href="#l16.1071"></a><span id="l16.1071" class="difflineplus">+    &quot;&quot;&quot;Create a PNG :class:`Image` object from a 2- or 3-dimensional array.</span>
<a href="#l16.1072"></a><span id="l16.1072" class="difflineplus">+    One application of this function is easy PIL-style saving:</span>
<a href="#l16.1073"></a><span id="l16.1073" class="difflineplus">+    ``png.from_array(pixels, 'L').save('foo.png')``.</span>
<a href="#l16.1074"></a><span id="l16.1074" class="difflineplus">+</span>
<a href="#l16.1075"></a><span id="l16.1075" class="difflineplus">+    .. note :</span>
<a href="#l16.1076"></a><span id="l16.1076" class="difflineplus">+</span>
<a href="#l16.1077"></a><span id="l16.1077" class="difflineplus">+      The use of the term *3-dimensional* is for marketing purposes</span>
<a href="#l16.1078"></a><span id="l16.1078" class="difflineplus">+      only.  It doesn't actually work.  Please bear with us.  Meanwhile</span>
<a href="#l16.1079"></a><span id="l16.1079" class="difflineplus">+      enjoy the complimentary snacks (on request) and please use a</span>
<a href="#l16.1080"></a><span id="l16.1080" class="difflineplus">+      2-dimensional array.</span>
<a href="#l16.1081"></a><span id="l16.1081" class="difflineplus">+    </span>
<a href="#l16.1082"></a><span id="l16.1082" class="difflineplus">+    Unless they are specified using the *info* parameter, the PNG's</span>
<a href="#l16.1083"></a><span id="l16.1083" class="difflineplus">+    height and width are taken from the array size.  For a 3 dimensional</span>
<a href="#l16.1084"></a><span id="l16.1084" class="difflineplus">+    array the first axis is the height; the second axis is the width;</span>
<a href="#l16.1085"></a><span id="l16.1085" class="difflineplus">+    and the third axis is the channel number.  Thus an RGB image that is</span>
<a href="#l16.1086"></a><span id="l16.1086" class="difflineplus">+    16 pixels high and 8 wide will use an array that is 16x8x3.  For 2</span>
<a href="#l16.1087"></a><span id="l16.1087" class="difflineplus">+    dimensional arrays the first axis is the height, but the second axis</span>
<a href="#l16.1088"></a><span id="l16.1088" class="difflineplus">+    is ``width*channels``, so an RGB image that is 16 pixels high and 8</span>
<a href="#l16.1089"></a><span id="l16.1089" class="difflineplus">+    wide will use a 2-dimensional array that is 16x24 (each row will be</span>
<a href="#l16.1090"></a><span id="l16.1090" class="difflineplus">+    8*3==24 sample values).</span>
<a href="#l16.1091"></a><span id="l16.1091" class="difflineplus">+</span>
<a href="#l16.1092"></a><span id="l16.1092" class="difflineplus">+    *mode* is a string that specifies the image colour format in a</span>
<a href="#l16.1093"></a><span id="l16.1093" class="difflineplus">+    PIL-style mode.  It can be:</span>
<a href="#l16.1094"></a><span id="l16.1094" class="difflineplus">+</span>
<a href="#l16.1095"></a><span id="l16.1095" class="difflineplus">+    ``'L'``</span>
<a href="#l16.1096"></a><span id="l16.1096" class="difflineplus">+      greyscale (1 channel)</span>
<a href="#l16.1097"></a><span id="l16.1097" class="difflineplus">+    ``'LA'``</span>
<a href="#l16.1098"></a><span id="l16.1098" class="difflineplus">+      greyscale with alpha (2 channel)</span>
<a href="#l16.1099"></a><span id="l16.1099" class="difflineplus">+    ``'RGB'``</span>
<a href="#l16.1100"></a><span id="l16.1100" class="difflineplus">+      colour image (3 channel)</span>
<a href="#l16.1101"></a><span id="l16.1101" class="difflineplus">+    ``'RGBA'``</span>
<a href="#l16.1102"></a><span id="l16.1102" class="difflineplus">+      colour image with alpha (4 channel)</span>
<a href="#l16.1103"></a><span id="l16.1103" class="difflineplus">+</span>
<a href="#l16.1104"></a><span id="l16.1104" class="difflineplus">+    The mode string can also specify the bit depth (overriding how this</span>
<a href="#l16.1105"></a><span id="l16.1105" class="difflineplus">+    function normally derives the bit depth, see below).  Appending</span>
<a href="#l16.1106"></a><span id="l16.1106" class="difflineplus">+    ``';16'`` to the mode will cause the PNG to be 16 bits per channel;</span>
<a href="#l16.1107"></a><span id="l16.1107" class="difflineplus">+    any decimal from 1 to 16 can be used to specify the bit depth.</span>
<a href="#l16.1108"></a><span id="l16.1108" class="difflineplus">+</span>
<a href="#l16.1109"></a><span id="l16.1109" class="difflineplus">+    When a 2-dimensional array is used *mode* determines how many</span>
<a href="#l16.1110"></a><span id="l16.1110" class="difflineplus">+    channels the image has, and so allows the width to be derived from</span>
<a href="#l16.1111"></a><span id="l16.1111" class="difflineplus">+    the second array dimension.</span>
<a href="#l16.1112"></a><span id="l16.1112" class="difflineplus">+</span>
<a href="#l16.1113"></a><span id="l16.1113" class="difflineplus">+    The array is expected to be a ``numpy`` array, but it can be any</span>
<a href="#l16.1114"></a><span id="l16.1114" class="difflineplus">+    suitable Python sequence.  For example, a list of lists can be used:</span>
<a href="#l16.1115"></a><span id="l16.1115" class="difflineplus">+    ``png.from_array([[0, 255, 0], [255, 0, 255]], 'L')``.  The exact</span>
<a href="#l16.1116"></a><span id="l16.1116" class="difflineplus">+    rules are: ``len(a)`` gives the first dimension, height;</span>
<a href="#l16.1117"></a><span id="l16.1117" class="difflineplus">+    ``len(a[0])`` gives the second dimension; ``len(a[0][0])`` gives the</span>
<a href="#l16.1118"></a><span id="l16.1118" class="difflineplus">+    third dimension, unless an exception is raised in which case a</span>
<a href="#l16.1119"></a><span id="l16.1119" class="difflineplus">+    2-dimensional array is assumed.  It's slightly more complicated than</span>
<a href="#l16.1120"></a><span id="l16.1120" class="difflineplus">+    that because an iterator of rows can be used, and it all still</span>
<a href="#l16.1121"></a><span id="l16.1121" class="difflineplus">+    works.  Using an iterator allows data to be streamed efficiently.</span>
<a href="#l16.1122"></a><span id="l16.1122" class="difflineplus">+</span>
<a href="#l16.1123"></a><span id="l16.1123" class="difflineplus">+    The bit depth of the PNG is normally taken from the array element's</span>
<a href="#l16.1124"></a><span id="l16.1124" class="difflineplus">+    datatype (but if *mode* specifies a bitdepth then that is used</span>
<a href="#l16.1125"></a><span id="l16.1125" class="difflineplus">+    instead).  The array element's datatype is determined in a way which</span>
<a href="#l16.1126"></a><span id="l16.1126" class="difflineplus">+    is supposed to work both for ``numpy`` arrays and for Python</span>
<a href="#l16.1127"></a><span id="l16.1127" class="difflineplus">+    ``array.array`` objects.  A 1 byte datatype will give a bit depth of</span>
<a href="#l16.1128"></a><span id="l16.1128" class="difflineplus">+    8, a 2 byte datatype will give a bit depth of 16.  If the datatype</span>
<a href="#l16.1129"></a><span id="l16.1129" class="difflineplus">+    does not have an implicit size, for example it is a plain Python</span>
<a href="#l16.1130"></a><span id="l16.1130" class="difflineplus">+    list of lists, as above, then a default of 8 is used.</span>
<a href="#l16.1131"></a><span id="l16.1131" class="difflineplus">+</span>
<a href="#l16.1132"></a><span id="l16.1132" class="difflineplus">+    The *info* parameter is a dictionary that can be used to specify</span>
<a href="#l16.1133"></a><span id="l16.1133" class="difflineplus">+    metadata (in the same style as the arguments to the</span>
<a href="#l16.1134"></a><span id="l16.1134" class="difflineplus">+    :class:``png.Writer`` class).  For this function the keys that are</span>
<a href="#l16.1135"></a><span id="l16.1135" class="difflineplus">+    useful are:</span>
<a href="#l16.1136"></a><span id="l16.1136" class="difflineplus">+    </span>
<a href="#l16.1137"></a><span id="l16.1137" class="difflineplus">+    height</span>
<a href="#l16.1138"></a><span id="l16.1138" class="difflineplus">+      overrides the height derived from the array dimensions and allows</span>
<a href="#l16.1139"></a><span id="l16.1139" class="difflineplus">+      *a* to be an iterable.</span>
<a href="#l16.1140"></a><span id="l16.1140" class="difflineplus">+    width</span>
<a href="#l16.1141"></a><span id="l16.1141" class="difflineplus">+      overrides the width derived from the array dimensions.</span>
<a href="#l16.1142"></a><span id="l16.1142" class="difflineplus">+    bitdepth</span>
<a href="#l16.1143"></a><span id="l16.1143" class="difflineplus">+      overrides the bit depth derived from the element datatype (but</span>
<a href="#l16.1144"></a><span id="l16.1144" class="difflineplus">+      must match *mode* if that also specifies a bit depth).</span>
<a href="#l16.1145"></a><span id="l16.1145" class="difflineplus">+</span>
<a href="#l16.1146"></a><span id="l16.1146" class="difflineplus">+    Generally anything specified in the</span>
<a href="#l16.1147"></a><span id="l16.1147" class="difflineplus">+    *info* dictionary will override any implicit choices that this</span>
<a href="#l16.1148"></a><span id="l16.1148" class="difflineplus">+    function would otherwise make, but must match any explicit ones.</span>
<a href="#l16.1149"></a><span id="l16.1149" class="difflineplus">+    For example, if the *info* dictionary has a ``greyscale`` key then</span>
<a href="#l16.1150"></a><span id="l16.1150" class="difflineplus">+    this must be true when mode is ``'L'`` or ``'LA'`` and false when</span>
<a href="#l16.1151"></a><span id="l16.1151" class="difflineplus">+    mode is ``'RGB'`` or ``'RGBA'``.</span>
<a href="#l16.1152"></a><span id="l16.1152" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.1153"></a><span id="l16.1153" class="difflineplus">+</span>
<a href="#l16.1154"></a><span id="l16.1154" class="difflineplus">+    # We abuse the *info* parameter by modifying it.  Take a copy here.</span>
<a href="#l16.1155"></a><span id="l16.1155" class="difflineplus">+    # (Also typechecks *info* to some extent).</span>
<a href="#l16.1156"></a><span id="l16.1156" class="difflineplus">+    info = dict(info)</span>
<a href="#l16.1157"></a><span id="l16.1157" class="difflineplus">+</span>
<a href="#l16.1158"></a><span id="l16.1158" class="difflineplus">+    # Syntax check mode string.</span>
<a href="#l16.1159"></a><span id="l16.1159" class="difflineplus">+    bitdepth = None</span>
<a href="#l16.1160"></a><span id="l16.1160" class="difflineplus">+    try:</span>
<a href="#l16.1161"></a><span id="l16.1161" class="difflineplus">+        mode = mode.split(';')</span>
<a href="#l16.1162"></a><span id="l16.1162" class="difflineplus">+        if len(mode) not in (1,2):</span>
<a href="#l16.1163"></a><span id="l16.1163" class="difflineplus">+            raise Error()</span>
<a href="#l16.1164"></a><span id="l16.1164" class="difflineplus">+        if mode[0] not in ('L', 'LA', 'RGB', 'RGBA'):</span>
<a href="#l16.1165"></a><span id="l16.1165" class="difflineplus">+            raise Error()</span>
<a href="#l16.1166"></a><span id="l16.1166" class="difflineplus">+        if len(mode) == 2:</span>
<a href="#l16.1167"></a><span id="l16.1167" class="difflineplus">+            try:</span>
<a href="#l16.1168"></a><span id="l16.1168" class="difflineplus">+                bitdepth = int(mode[1])</span>
<a href="#l16.1169"></a><span id="l16.1169" class="difflineplus">+            except:</span>
<a href="#l16.1170"></a><span id="l16.1170" class="difflineplus">+                raise Error()</span>
<a href="#l16.1171"></a><span id="l16.1171" class="difflineplus">+    except Error:</span>
<a href="#l16.1172"></a><span id="l16.1172" class="difflineplus">+        raise Error(&quot;mode string should be 'RGB' or 'L;16' or similar.&quot;)</span>
<a href="#l16.1173"></a><span id="l16.1173" class="difflineplus">+    mode = mode[0]</span>
<a href="#l16.1174"></a><span id="l16.1174" class="difflineplus">+</span>
<a href="#l16.1175"></a><span id="l16.1175" class="difflineplus">+    # Get bitdepth from *mode* if possible.</span>
<a href="#l16.1176"></a><span id="l16.1176" class="difflineplus">+    if bitdepth:</span>
<a href="#l16.1177"></a><span id="l16.1177" class="difflineplus">+        if info.get('bitdepth') and bitdepth != info['bitdepth']:</span>
<a href="#l16.1178"></a><span id="l16.1178" class="difflineplus">+            raise Error(&quot;mode bitdepth (%d) should match info bitdepth (%d).&quot; %</span>
<a href="#l16.1179"></a><span id="l16.1179" class="difflineplus">+              (bitdepth, info['bitdepth']))</span>
<a href="#l16.1180"></a><span id="l16.1180" class="difflineplus">+        info['bitdepth'] = bitdepth</span>
<a href="#l16.1181"></a><span id="l16.1181" class="difflineplus">+</span>
<a href="#l16.1182"></a><span id="l16.1182" class="difflineplus">+    # Fill in and/or check entries in *info*.</span>
<a href="#l16.1183"></a><span id="l16.1183" class="difflineplus">+    # Dimensions.</span>
<a href="#l16.1184"></a><span id="l16.1184" class="difflineplus">+    if 'size' in info:</span>
<a href="#l16.1185"></a><span id="l16.1185" class="difflineplus">+        # Check width, height, size all match where used.</span>
<a href="#l16.1186"></a><span id="l16.1186" class="difflineplus">+        for dimension,axis in [('width', 0), ('height', 1)]:</span>
<a href="#l16.1187"></a><span id="l16.1187" class="difflineplus">+            if dimension in info:</span>
<a href="#l16.1188"></a><span id="l16.1188" class="difflineplus">+                if info[dimension] != info['size'][axis]:</span>
<a href="#l16.1189"></a><span id="l16.1189" class="difflineplus">+                    raise Error(</span>
<a href="#l16.1190"></a><span id="l16.1190" class="difflineplus">+                      &quot;info[%r] shhould match info['size'][%r].&quot; %</span>
<a href="#l16.1191"></a><span id="l16.1191" class="difflineplus">+                      (dimension, axis))</span>
<a href="#l16.1192"></a><span id="l16.1192" class="difflineplus">+        info['width'],info['height'] = info['size']</span>
<a href="#l16.1193"></a><span id="l16.1193" class="difflineplus">+    if 'height' not in info:</span>
<a href="#l16.1194"></a><span id="l16.1194" class="difflineplus">+        try:</span>
<a href="#l16.1195"></a><span id="l16.1195" class="difflineplus">+            l = len(a)</span>
<a href="#l16.1196"></a><span id="l16.1196" class="difflineplus">+        except:</span>
<a href="#l16.1197"></a><span id="l16.1197" class="difflineplus">+            raise Error(</span>
<a href="#l16.1198"></a><span id="l16.1198" class="difflineplus">+              &quot;len(a) does not work, supply info['height'] instead.&quot;)</span>
<a href="#l16.1199"></a><span id="l16.1199" class="difflineplus">+        info['height'] = l</span>
<a href="#l16.1200"></a><span id="l16.1200" class="difflineplus">+    # Colour format.</span>
<a href="#l16.1201"></a><span id="l16.1201" class="difflineplus">+    if 'greyscale' in info:</span>
<a href="#l16.1202"></a><span id="l16.1202" class="difflineplus">+        if bool(info['greyscale']) != ('L' in mode):</span>
<a href="#l16.1203"></a><span id="l16.1203" class="difflineplus">+            raise Error(&quot;info['greyscale'] should match mode.&quot;)</span>
<a href="#l16.1204"></a><span id="l16.1204" class="difflineplus">+    info['greyscale'] = 'L' in mode</span>
<a href="#l16.1205"></a><span id="l16.1205" class="difflineplus">+    if 'alpha' in info:</span>
<a href="#l16.1206"></a><span id="l16.1206" class="difflineplus">+        if bool(info['alpha']) != ('A' in mode):</span>
<a href="#l16.1207"></a><span id="l16.1207" class="difflineplus">+            raise Error(&quot;info['alpha'] should match mode.&quot;)</span>
<a href="#l16.1208"></a><span id="l16.1208" class="difflineplus">+    info['alpha'] = 'A' in mode</span>
<a href="#l16.1209"></a><span id="l16.1209" class="difflineplus">+</span>
<a href="#l16.1210"></a><span id="l16.1210" class="difflineplus">+    planes = len(mode)</span>
<a href="#l16.1211"></a><span id="l16.1211" class="difflineplus">+    if 'planes' in info:</span>
<a href="#l16.1212"></a><span id="l16.1212" class="difflineplus">+        if info['planes'] != planes:</span>
<a href="#l16.1213"></a><span id="l16.1213" class="difflineplus">+            raise Error(&quot;info['planes'] should match mode.&quot;)</span>
<a href="#l16.1214"></a><span id="l16.1214" class="difflineplus">+</span>
<a href="#l16.1215"></a><span id="l16.1215" class="difflineplus">+    # In order to work out whether we the array is 2D or 3D we need its</span>
<a href="#l16.1216"></a><span id="l16.1216" class="difflineplus">+    # first row, which requires that we take a copy of its iterator.</span>
<a href="#l16.1217"></a><span id="l16.1217" class="difflineplus">+    # We may also need the first row to derive width and bitdepth.</span>
<a href="#l16.1218"></a><span id="l16.1218" class="difflineplus">+    a,t = itertools.tee(a)</span>
<a href="#l16.1219"></a><span id="l16.1219" class="difflineplus">+    row = t.next()</span>
<a href="#l16.1220"></a><span id="l16.1220" class="difflineplus">+    del t</span>
<a href="#l16.1221"></a><span id="l16.1221" class="difflineplus">+    try:</span>
<a href="#l16.1222"></a><span id="l16.1222" class="difflineplus">+        row[0][0]</span>
<a href="#l16.1223"></a><span id="l16.1223" class="difflineplus">+        threed = True</span>
<a href="#l16.1224"></a><span id="l16.1224" class="difflineplus">+        testelement = row[0]</span>
<a href="#l16.1225"></a><span id="l16.1225" class="difflineplus">+    except:</span>
<a href="#l16.1226"></a><span id="l16.1226" class="difflineplus">+        threed = False</span>
<a href="#l16.1227"></a><span id="l16.1227" class="difflineplus">+        testelement = row</span>
<a href="#l16.1228"></a><span id="l16.1228" class="difflineplus">+    if 'width' not in info:</span>
<a href="#l16.1229"></a><span id="l16.1229" class="difflineplus">+        if threed:</span>
<a href="#l16.1230"></a><span id="l16.1230" class="difflineplus">+            width = len(row)</span>
<a href="#l16.1231"></a><span id="l16.1231" class="difflineplus">+        else:</span>
<a href="#l16.1232"></a><span id="l16.1232" class="difflineplus">+            width = len(row) // planes</span>
<a href="#l16.1233"></a><span id="l16.1233" class="difflineplus">+        info['width'] = width</span>
<a href="#l16.1234"></a><span id="l16.1234" class="difflineplus">+</span>
<a href="#l16.1235"></a><span id="l16.1235" class="difflineplus">+    # Not implemented yet</span>
<a href="#l16.1236"></a><span id="l16.1236" class="difflineplus">+    assert not threed</span>
<a href="#l16.1237"></a><span id="l16.1237" class="difflineplus">+</span>
<a href="#l16.1238"></a><span id="l16.1238" class="difflineplus">+    if 'bitdepth' not in info:</span>
<a href="#l16.1239"></a><span id="l16.1239" class="difflineplus">+        try:</span>
<a href="#l16.1240"></a><span id="l16.1240" class="difflineplus">+            dtype = testelement.dtype</span>
<a href="#l16.1241"></a><span id="l16.1241" class="difflineplus">+            # goto the &quot;else:&quot; clause.  Sorry.</span>
<a href="#l16.1242"></a><span id="l16.1242" class="difflineplus">+        except:</span>
<a href="#l16.1243"></a><span id="l16.1243" class="difflineplus">+            try:</span>
<a href="#l16.1244"></a><span id="l16.1244" class="difflineplus">+                # Try a Python array.array.</span>
<a href="#l16.1245"></a><span id="l16.1245" class="difflineplus">+                bitdepth = 8 * testelement.itemsize</span>
<a href="#l16.1246"></a><span id="l16.1246" class="difflineplus">+            except:</span>
<a href="#l16.1247"></a><span id="l16.1247" class="difflineplus">+                # We can't determine it from the array element's</span>
<a href="#l16.1248"></a><span id="l16.1248" class="difflineplus">+                # datatype, use a default of 8.</span>
<a href="#l16.1249"></a><span id="l16.1249" class="difflineplus">+                bitdepth = 8</span>
<a href="#l16.1250"></a><span id="l16.1250" class="difflineplus">+        else:</span>
<a href="#l16.1251"></a><span id="l16.1251" class="difflineplus">+            # If we got here without exception, we now assume that</span>
<a href="#l16.1252"></a><span id="l16.1252" class="difflineplus">+            # the array is a numpy array.</span>
<a href="#l16.1253"></a><span id="l16.1253" class="difflineplus">+            if dtype.kind == 'b':</span>
<a href="#l16.1254"></a><span id="l16.1254" class="difflineplus">+                bitdepth = 1</span>
<a href="#l16.1255"></a><span id="l16.1255" class="difflineplus">+            else:</span>
<a href="#l16.1256"></a><span id="l16.1256" class="difflineplus">+                bitdepth = 8 * dtype.itemsize</span>
<a href="#l16.1257"></a><span id="l16.1257" class="difflineplus">+        info['bitdepth'] = bitdepth</span>
<a href="#l16.1258"></a><span id="l16.1258" class="difflineplus">+</span>
<a href="#l16.1259"></a><span id="l16.1259" class="difflineplus">+    for thing in 'width height bitdepth greyscale alpha'.split():</span>
<a href="#l16.1260"></a><span id="l16.1260" class="difflineplus">+        assert thing in info</span>
<a href="#l16.1261"></a><span id="l16.1261" class="difflineplus">+    return Image(a, info)</span>
<a href="#l16.1262"></a><span id="l16.1262" class="difflineplus">+</span>
<a href="#l16.1263"></a><span id="l16.1263" class="difflineplus">+# So that refugee's from PIL feel more at home.  Not documented.</span>
<a href="#l16.1264"></a><span id="l16.1264" class="difflineplus">+fromarray = from_array</span>
<a href="#l16.1265"></a><span id="l16.1265" class="difflineplus">+</span>
<a href="#l16.1266"></a><span id="l16.1266" class="difflineplus">+class Image:</span>
<a href="#l16.1267"></a><span id="l16.1267" class="difflineplus">+    &quot;&quot;&quot;A PNG image.</span>
<a href="#l16.1268"></a><span id="l16.1268" class="difflineplus">+    You can create an :class:`Image` object from an array of pixels by calling</span>
<a href="#l16.1269"></a><span id="l16.1269" class="difflineplus">+    :meth:`png.from_array`.  It can be saved to disk with the</span>
<a href="#l16.1270"></a><span id="l16.1270" class="difflineplus">+    :meth:`save` method.&quot;&quot;&quot;</span>
<a href="#l16.1271"></a><span id="l16.1271" class="difflineplus">+    def __init__(self, rows, info):</span>
<a href="#l16.1272"></a><span id="l16.1272" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1273"></a><span id="l16.1273" class="difflineplus">+        .. note ::</span>
<a href="#l16.1274"></a><span id="l16.1274" class="difflineplus">+        </span>
<a href="#l16.1275"></a><span id="l16.1275" class="difflineplus">+          The constructor is not public.  Please do not call it.</span>
<a href="#l16.1276"></a><span id="l16.1276" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1277"></a><span id="l16.1277" class="difflineplus">+        </span>
<a href="#l16.1278"></a><span id="l16.1278" class="difflineplus">+        self.rows = rows</span>
<a href="#l16.1279"></a><span id="l16.1279" class="difflineplus">+        self.info = info</span>
<a href="#l16.1280"></a><span id="l16.1280" class="difflineplus">+</span>
<a href="#l16.1281"></a><span id="l16.1281" class="difflineplus">+    def save(self, file):</span>
<a href="#l16.1282"></a><span id="l16.1282" class="difflineplus">+        &quot;&quot;&quot;Save the image to *file*.  If *file* looks like an open file</span>
<a href="#l16.1283"></a><span id="l16.1283" class="difflineplus">+        descriptor then it is used, otherwise it is treated as a</span>
<a href="#l16.1284"></a><span id="l16.1284" class="difflineplus">+        filename and a fresh file is opened.</span>
<a href="#l16.1285"></a><span id="l16.1285" class="difflineplus">+</span>
<a href="#l16.1286"></a><span id="l16.1286" class="difflineplus">+        In general, you can only call this method once; after it has</span>
<a href="#l16.1287"></a><span id="l16.1287" class="difflineplus">+        been called the first time and the PNG image has been saved, the</span>
<a href="#l16.1288"></a><span id="l16.1288" class="difflineplus">+        source data will have been streamed, and cannot be streamed</span>
<a href="#l16.1289"></a><span id="l16.1289" class="difflineplus">+        again.</span>
<a href="#l16.1290"></a><span id="l16.1290" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1291"></a><span id="l16.1291" class="difflineplus">+</span>
<a href="#l16.1292"></a><span id="l16.1292" class="difflineplus">+        w = Writer(**self.info)</span>
<a href="#l16.1293"></a><span id="l16.1293" class="difflineplus">+</span>
<a href="#l16.1294"></a><span id="l16.1294" class="difflineplus">+        try:</span>
<a href="#l16.1295"></a><span id="l16.1295" class="difflineplus">+            file.write</span>
<a href="#l16.1296"></a><span id="l16.1296" class="difflineplus">+            def close(): pass</span>
<a href="#l16.1297"></a><span id="l16.1297" class="difflineplus">+        except:</span>
<a href="#l16.1298"></a><span id="l16.1298" class="difflineplus">+            file = open(file, 'wb')</span>
<a href="#l16.1299"></a><span id="l16.1299" class="difflineplus">+            def close(): file.close()</span>
<a href="#l16.1300"></a><span id="l16.1300" class="difflineplus">+</span>
<a href="#l16.1301"></a><span id="l16.1301" class="difflineplus">+        try:</span>
<a href="#l16.1302"></a><span id="l16.1302" class="difflineplus">+            w.write(file, self.rows)</span>
<a href="#l16.1303"></a><span id="l16.1303" class="difflineplus">+        finally:</span>
<a href="#l16.1304"></a><span id="l16.1304" class="difflineplus">+            close()</span>
<a href="#l16.1305"></a><span id="l16.1305" class="difflineplus">+</span>
<a href="#l16.1306"></a><span id="l16.1306" class="difflineplus">+class _readable:</span>
<a href="#l16.1307"></a><span id="l16.1307" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.1308"></a><span id="l16.1308" class="difflineplus">+    A simple file-like interface for strings and arrays.</span>
<a href="#l16.1309"></a><span id="l16.1309" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.1310"></a><span id="l16.1310" class="difflineplus">+</span>
<a href="#l16.1311"></a><span id="l16.1311" class="difflineplus">+    def __init__(self, buf):</span>
<a href="#l16.1312"></a><span id="l16.1312" class="difflineplus">+        self.buf = buf</span>
<a href="#l16.1313"></a><span id="l16.1313" class="difflineplus">+        self.offset = 0</span>
<a href="#l16.1314"></a><span id="l16.1314" class="difflineplus">+</span>
<a href="#l16.1315"></a><span id="l16.1315" class="difflineplus">+    def read(self, n):</span>
<a href="#l16.1316"></a><span id="l16.1316" class="difflineplus">+        r = self.buf[self.offset:self.offset+n]</span>
<a href="#l16.1317"></a><span id="l16.1317" class="difflineplus">+        if isarray(r):</span>
<a href="#l16.1318"></a><span id="l16.1318" class="difflineplus">+            r = r.tostring()</span>
<a href="#l16.1319"></a><span id="l16.1319" class="difflineplus">+        self.offset += n</span>
<a href="#l16.1320"></a><span id="l16.1320" class="difflineplus">+        return r</span>
<a href="#l16.1321"></a><span id="l16.1321" class="difflineplus">+</span>
<a href="#l16.1322"></a><span id="l16.1322" class="difflineplus">+</span>
<a href="#l16.1323"></a><span id="l16.1323" class="difflineplus">+class Reader:</span>
<a href="#l16.1324"></a><span id="l16.1324" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.1325"></a><span id="l16.1325" class="difflineplus">+    PNG decoder in pure Python.</span>
<a href="#l16.1326"></a><span id="l16.1326" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.1327"></a><span id="l16.1327" class="difflineplus">+</span>
<a href="#l16.1328"></a><span id="l16.1328" class="difflineplus">+    def __init__(self, _guess=None, **kw):</span>
<a href="#l16.1329"></a><span id="l16.1329" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1330"></a><span id="l16.1330" class="difflineplus">+        Create a PNG decoder object.</span>
<a href="#l16.1331"></a><span id="l16.1331" class="difflineplus">+</span>
<a href="#l16.1332"></a><span id="l16.1332" class="difflineplus">+        The constructor expects exactly one keyword argument. If you</span>
<a href="#l16.1333"></a><span id="l16.1333" class="difflineplus">+        supply a positional argument instead, it will guess the input</span>
<a href="#l16.1334"></a><span id="l16.1334" class="difflineplus">+        type. You can choose among the following keyword arguments:</span>
<a href="#l16.1335"></a><span id="l16.1335" class="difflineplus">+</span>
<a href="#l16.1336"></a><span id="l16.1336" class="difflineplus">+        filename</span>
<a href="#l16.1337"></a><span id="l16.1337" class="difflineplus">+          Name of input file (a PNG file).</span>
<a href="#l16.1338"></a><span id="l16.1338" class="difflineplus">+        file</span>
<a href="#l16.1339"></a><span id="l16.1339" class="difflineplus">+          A file-like object (object with a read() method).</span>
<a href="#l16.1340"></a><span id="l16.1340" class="difflineplus">+        bytes</span>
<a href="#l16.1341"></a><span id="l16.1341" class="difflineplus">+          ``array`` or ``string`` with PNG data.</span>
<a href="#l16.1342"></a><span id="l16.1342" class="difflineplus">+</span>
<a href="#l16.1343"></a><span id="l16.1343" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1344"></a><span id="l16.1344" class="difflineplus">+        if ((_guess is not None and len(kw) != 0) or</span>
<a href="#l16.1345"></a><span id="l16.1345" class="difflineplus">+            (_guess is None and len(kw) != 1)):</span>
<a href="#l16.1346"></a><span id="l16.1346" class="difflineplus">+            raise TypeError(&quot;Reader() takes exactly 1 argument&quot;)</span>
<a href="#l16.1347"></a><span id="l16.1347" class="difflineplus">+</span>
<a href="#l16.1348"></a><span id="l16.1348" class="difflineplus">+        # Will be the first 8 bytes, later on.  See validate_signature.</span>
<a href="#l16.1349"></a><span id="l16.1349" class="difflineplus">+        self.signature = None</span>
<a href="#l16.1350"></a><span id="l16.1350" class="difflineplus">+        self.transparent = None</span>
<a href="#l16.1351"></a><span id="l16.1351" class="difflineplus">+        # A pair of (len,type) if a chunk has been read but its data and</span>
<a href="#l16.1352"></a><span id="l16.1352" class="difflineplus">+        # checksum have not (in other words the file position is just</span>
<a href="#l16.1353"></a><span id="l16.1353" class="difflineplus">+        # past the 4 bytes that specify the chunk type).  See preamble</span>
<a href="#l16.1354"></a><span id="l16.1354" class="difflineplus">+        # method for how this is used.</span>
<a href="#l16.1355"></a><span id="l16.1355" class="difflineplus">+        self.atchunk = None</span>
<a href="#l16.1356"></a><span id="l16.1356" class="difflineplus">+</span>
<a href="#l16.1357"></a><span id="l16.1357" class="difflineplus">+        if _guess is not None:</span>
<a href="#l16.1358"></a><span id="l16.1358" class="difflineplus">+            if isarray(_guess):</span>
<a href="#l16.1359"></a><span id="l16.1359" class="difflineplus">+                kw[&quot;bytes&quot;] = _guess</span>
<a href="#l16.1360"></a><span id="l16.1360" class="difflineplus">+            elif isinstance(_guess, str):</span>
<a href="#l16.1361"></a><span id="l16.1361" class="difflineplus">+                kw[&quot;filename&quot;] = _guess</span>
<a href="#l16.1362"></a><span id="l16.1362" class="difflineplus">+            elif isinstance(_guess, file):</span>
<a href="#l16.1363"></a><span id="l16.1363" class="difflineplus">+                kw[&quot;file&quot;] = _guess</span>
<a href="#l16.1364"></a><span id="l16.1364" class="difflineplus">+</span>
<a href="#l16.1365"></a><span id="l16.1365" class="difflineplus">+        if &quot;filename&quot; in kw:</span>
<a href="#l16.1366"></a><span id="l16.1366" class="difflineplus">+            self.file = open(kw[&quot;filename&quot;], &quot;rb&quot;)</span>
<a href="#l16.1367"></a><span id="l16.1367" class="difflineplus">+        elif &quot;file&quot; in kw:</span>
<a href="#l16.1368"></a><span id="l16.1368" class="difflineplus">+            self.file = kw[&quot;file&quot;]</span>
<a href="#l16.1369"></a><span id="l16.1369" class="difflineplus">+        elif &quot;bytes&quot; in kw:</span>
<a href="#l16.1370"></a><span id="l16.1370" class="difflineplus">+            self.file = _readable(kw[&quot;bytes&quot;])</span>
<a href="#l16.1371"></a><span id="l16.1371" class="difflineplus">+        else:</span>
<a href="#l16.1372"></a><span id="l16.1372" class="difflineplus">+            raise TypeError(&quot;expecting filename, file or bytes array&quot;)</span>
<a href="#l16.1373"></a><span id="l16.1373" class="difflineplus">+</span>
<a href="#l16.1374"></a><span id="l16.1374" class="difflineplus">+    def chunk(self, seek=None):</span>
<a href="#l16.1375"></a><span id="l16.1375" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1376"></a><span id="l16.1376" class="difflineplus">+        Read the next PNG chunk from the input file; returns a</span>
<a href="#l16.1377"></a><span id="l16.1377" class="difflineplus">+        (*type*,*data*) tuple.  *type* is the chunk's type as a string</span>
<a href="#l16.1378"></a><span id="l16.1378" class="difflineplus">+        (all PNG chunk types are 4 characters long).  *data* is the</span>
<a href="#l16.1379"></a><span id="l16.1379" class="difflineplus">+        chunk's data content, as a string.</span>
<a href="#l16.1380"></a><span id="l16.1380" class="difflineplus">+</span>
<a href="#l16.1381"></a><span id="l16.1381" class="difflineplus">+        If the optional `seek` argument is</span>
<a href="#l16.1382"></a><span id="l16.1382" class="difflineplus">+        specified then it will keep reading chunks until it either runs</span>
<a href="#l16.1383"></a><span id="l16.1383" class="difflineplus">+        out of file or finds the type specified by the argument.  Note</span>
<a href="#l16.1384"></a><span id="l16.1384" class="difflineplus">+        that in general the order of chunks in PNGs is unspecified, so</span>
<a href="#l16.1385"></a><span id="l16.1385" class="difflineplus">+        using `seek` can cause you to miss chunks.</span>
<a href="#l16.1386"></a><span id="l16.1386" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1387"></a><span id="l16.1387" class="difflineplus">+</span>
<a href="#l16.1388"></a><span id="l16.1388" class="difflineplus">+        self.validate_signature()</span>
<a href="#l16.1389"></a><span id="l16.1389" class="difflineplus">+</span>
<a href="#l16.1390"></a><span id="l16.1390" class="difflineplus">+        while True:</span>
<a href="#l16.1391"></a><span id="l16.1391" class="difflineplus">+            # http://www.w3.org/TR/PNG/#5Chunk-layout</span>
<a href="#l16.1392"></a><span id="l16.1392" class="difflineplus">+            if not self.atchunk:</span>
<a href="#l16.1393"></a><span id="l16.1393" class="difflineplus">+                self.atchunk = self.chunklentype()</span>
<a href="#l16.1394"></a><span id="l16.1394" class="difflineplus">+            length,type = self.atchunk</span>
<a href="#l16.1395"></a><span id="l16.1395" class="difflineplus">+            self.atchunk = None</span>
<a href="#l16.1396"></a><span id="l16.1396" class="difflineplus">+            data = self.file.read(length)</span>
<a href="#l16.1397"></a><span id="l16.1397" class="difflineplus">+            if len(data) != length:</span>
<a href="#l16.1398"></a><span id="l16.1398" class="difflineplus">+                raise ChunkError('Chunk %s too short for required %i octets.'</span>
<a href="#l16.1399"></a><span id="l16.1399" class="difflineplus">+                  % (type, length))</span>
<a href="#l16.1400"></a><span id="l16.1400" class="difflineplus">+            checksum = self.file.read(4)</span>
<a href="#l16.1401"></a><span id="l16.1401" class="difflineplus">+            if len(checksum) != 4:</span>
<a href="#l16.1402"></a><span id="l16.1402" class="difflineplus">+                raise ValueError('Chunk %s too short for checksum.', tag)</span>
<a href="#l16.1403"></a><span id="l16.1403" class="difflineplus">+            if seek and type != seek:</span>
<a href="#l16.1404"></a><span id="l16.1404" class="difflineplus">+                continue</span>
<a href="#l16.1405"></a><span id="l16.1405" class="difflineplus">+            verify = zlib.crc32(strtobytes(type))</span>
<a href="#l16.1406"></a><span id="l16.1406" class="difflineplus">+            verify = zlib.crc32(data, verify)</span>
<a href="#l16.1407"></a><span id="l16.1407" class="difflineplus">+            # Whether the output from zlib.crc32 is signed or not varies</span>
<a href="#l16.1408"></a><span id="l16.1408" class="difflineplus">+            # according to hideous implementation details, see</span>
<a href="#l16.1409"></a><span id="l16.1409" class="difflineplus">+            # http://bugs.python.org/issue1202 .</span>
<a href="#l16.1410"></a><span id="l16.1410" class="difflineplus">+            # We coerce it to be positive here (in a way which works on</span>
<a href="#l16.1411"></a><span id="l16.1411" class="difflineplus">+            # Python 2.3 and older).</span>
<a href="#l16.1412"></a><span id="l16.1412" class="difflineplus">+            verify &amp;= 2**32 - 1</span>
<a href="#l16.1413"></a><span id="l16.1413" class="difflineplus">+            verify = struct.pack('!I', verify)</span>
<a href="#l16.1414"></a><span id="l16.1414" class="difflineplus">+            if checksum != verify:</span>
<a href="#l16.1415"></a><span id="l16.1415" class="difflineplus">+                # print repr(checksum)</span>
<a href="#l16.1416"></a><span id="l16.1416" class="difflineplus">+                (a, ) = struct.unpack('!I', checksum)</span>
<a href="#l16.1417"></a><span id="l16.1417" class="difflineplus">+                (b, ) = struct.unpack('!I', verify)</span>
<a href="#l16.1418"></a><span id="l16.1418" class="difflineplus">+                raise ChunkError(</span>
<a href="#l16.1419"></a><span id="l16.1419" class="difflineplus">+                  &quot;Checksum error in %s chunk: 0x%08X != 0x%08X.&quot; %</span>
<a href="#l16.1420"></a><span id="l16.1420" class="difflineplus">+                  (type, a, b))</span>
<a href="#l16.1421"></a><span id="l16.1421" class="difflineplus">+            return type, data</span>
<a href="#l16.1422"></a><span id="l16.1422" class="difflineplus">+</span>
<a href="#l16.1423"></a><span id="l16.1423" class="difflineplus">+    def chunks(self):</span>
<a href="#l16.1424"></a><span id="l16.1424" class="difflineplus">+        &quot;&quot;&quot;Return an iterator that will yield each chunk as a</span>
<a href="#l16.1425"></a><span id="l16.1425" class="difflineplus">+        (*chunktype*, *content*) pair.</span>
<a href="#l16.1426"></a><span id="l16.1426" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1427"></a><span id="l16.1427" class="difflineplus">+</span>
<a href="#l16.1428"></a><span id="l16.1428" class="difflineplus">+        while True:</span>
<a href="#l16.1429"></a><span id="l16.1429" class="difflineplus">+            t,v = self.chunk()</span>
<a href="#l16.1430"></a><span id="l16.1430" class="difflineplus">+            yield t,v</span>
<a href="#l16.1431"></a><span id="l16.1431" class="difflineplus">+            if t == 'IEND':</span>
<a href="#l16.1432"></a><span id="l16.1432" class="difflineplus">+                break</span>
<a href="#l16.1433"></a><span id="l16.1433" class="difflineplus">+</span>
<a href="#l16.1434"></a><span id="l16.1434" class="difflineplus">+    def undo_filter(self, filter_type, scanline, previous):</span>
<a href="#l16.1435"></a><span id="l16.1435" class="difflineplus">+        &quot;&quot;&quot;Undo the filter for a scanline.  `scanline` is a sequence of</span>
<a href="#l16.1436"></a><span id="l16.1436" class="difflineplus">+        bytes that does not include the initial filter type byte.</span>
<a href="#l16.1437"></a><span id="l16.1437" class="difflineplus">+        `previous` is decoded previous scanline (for straightlaced</span>
<a href="#l16.1438"></a><span id="l16.1438" class="difflineplus">+        images this is the previous pixel row, but for interlaced</span>
<a href="#l16.1439"></a><span id="l16.1439" class="difflineplus">+        images, it is the previous scanline in the reduced image, which</span>
<a href="#l16.1440"></a><span id="l16.1440" class="difflineplus">+        in general is not the previous pixel row in the final image).</span>
<a href="#l16.1441"></a><span id="l16.1441" class="difflineplus">+        When there is no previous scanline (the first row of a</span>
<a href="#l16.1442"></a><span id="l16.1442" class="difflineplus">+        straightlaced image, or the first row in one of the passes in an</span>
<a href="#l16.1443"></a><span id="l16.1443" class="difflineplus">+        interlaced image), then this argument should be ``None``.</span>
<a href="#l16.1444"></a><span id="l16.1444" class="difflineplus">+</span>
<a href="#l16.1445"></a><span id="l16.1445" class="difflineplus">+        The scanline will have the effects of filtering removed, and the</span>
<a href="#l16.1446"></a><span id="l16.1446" class="difflineplus">+        result will be returned as a fresh sequence of bytes.</span>
<a href="#l16.1447"></a><span id="l16.1447" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1448"></a><span id="l16.1448" class="difflineplus">+</span>
<a href="#l16.1449"></a><span id="l16.1449" class="difflineplus">+        # :todo: Would it be better to update scanline in place?</span>
<a href="#l16.1450"></a><span id="l16.1450" class="difflineplus">+</span>
<a href="#l16.1451"></a><span id="l16.1451" class="difflineplus">+        # Create the result byte array.  It seems that the best way to</span>
<a href="#l16.1452"></a><span id="l16.1452" class="difflineplus">+        # create the array to be the right size is to copy from an</span>
<a href="#l16.1453"></a><span id="l16.1453" class="difflineplus">+        # existing sequence.  *sigh*</span>
<a href="#l16.1454"></a><span id="l16.1454" class="difflineplus">+        # If we fill the result with scanline, then this allows a</span>
<a href="#l16.1455"></a><span id="l16.1455" class="difflineplus">+        # micro-optimisation in the &quot;null&quot; and &quot;sub&quot; cases.</span>
<a href="#l16.1456"></a><span id="l16.1456" class="difflineplus">+        result = array('B', scanline)</span>
<a href="#l16.1457"></a><span id="l16.1457" class="difflineplus">+</span>
<a href="#l16.1458"></a><span id="l16.1458" class="difflineplus">+        if filter_type == 0:</span>
<a href="#l16.1459"></a><span id="l16.1459" class="difflineplus">+            # And here, we _rely_ on filling the result with scanline,</span>
<a href="#l16.1460"></a><span id="l16.1460" class="difflineplus">+            # above.</span>
<a href="#l16.1461"></a><span id="l16.1461" class="difflineplus">+            return result</span>
<a href="#l16.1462"></a><span id="l16.1462" class="difflineplus">+</span>
<a href="#l16.1463"></a><span id="l16.1463" class="difflineplus">+        if filter_type not in (1,2,3,4):</span>
<a href="#l16.1464"></a><span id="l16.1464" class="difflineplus">+            raise FormatError('Invalid PNG Filter Type.'</span>
<a href="#l16.1465"></a><span id="l16.1465" class="difflineplus">+              '  See http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .')</span>
<a href="#l16.1466"></a><span id="l16.1466" class="difflineplus">+</span>
<a href="#l16.1467"></a><span id="l16.1467" class="difflineplus">+        # Filter unit.  The stride from one pixel to the corresponding</span>
<a href="#l16.1468"></a><span id="l16.1468" class="difflineplus">+        # byte from the previous previous.  Normally this is the pixel</span>
<a href="#l16.1469"></a><span id="l16.1469" class="difflineplus">+        # size in bytes, but when this is smaller than 1, the previous</span>
<a href="#l16.1470"></a><span id="l16.1470" class="difflineplus">+        # byte is used instead.</span>
<a href="#l16.1471"></a><span id="l16.1471" class="difflineplus">+        fu = max(1, self.psize)</span>
<a href="#l16.1472"></a><span id="l16.1472" class="difflineplus">+</span>
<a href="#l16.1473"></a><span id="l16.1473" class="difflineplus">+        # For the first line of a pass, synthesize a dummy previous</span>
<a href="#l16.1474"></a><span id="l16.1474" class="difflineplus">+        # line.  An alternative approach would be to observe that on the</span>
<a href="#l16.1475"></a><span id="l16.1475" class="difflineplus">+        # first line 'up' is the same as 'null', 'paeth' is the same</span>
<a href="#l16.1476"></a><span id="l16.1476" class="difflineplus">+        # as 'sub', with only 'average' requiring any special case.</span>
<a href="#l16.1477"></a><span id="l16.1477" class="difflineplus">+        if not previous:</span>
<a href="#l16.1478"></a><span id="l16.1478" class="difflineplus">+            previous = array('B', [0]*len(scanline))</span>
<a href="#l16.1479"></a><span id="l16.1479" class="difflineplus">+</span>
<a href="#l16.1480"></a><span id="l16.1480" class="difflineplus">+        def sub():</span>
<a href="#l16.1481"></a><span id="l16.1481" class="difflineplus">+            &quot;&quot;&quot;Undo sub filter.&quot;&quot;&quot;</span>
<a href="#l16.1482"></a><span id="l16.1482" class="difflineplus">+</span>
<a href="#l16.1483"></a><span id="l16.1483" class="difflineplus">+            ai = 0</span>
<a href="#l16.1484"></a><span id="l16.1484" class="difflineplus">+            # Loops starts at index fu.  Observe that the initial part</span>
<a href="#l16.1485"></a><span id="l16.1485" class="difflineplus">+            # of the result is already filled in correctly with</span>
<a href="#l16.1486"></a><span id="l16.1486" class="difflineplus">+            # scanline.</span>
<a href="#l16.1487"></a><span id="l16.1487" class="difflineplus">+            for i in range(fu, len(result)):</span>
<a href="#l16.1488"></a><span id="l16.1488" class="difflineplus">+                x = scanline[i]</span>
<a href="#l16.1489"></a><span id="l16.1489" class="difflineplus">+                a = result[ai]</span>
<a href="#l16.1490"></a><span id="l16.1490" class="difflineplus">+                result[i] = (x + a) &amp; 0xff</span>
<a href="#l16.1491"></a><span id="l16.1491" class="difflineplus">+                ai += 1</span>
<a href="#l16.1492"></a><span id="l16.1492" class="difflineplus">+</span>
<a href="#l16.1493"></a><span id="l16.1493" class="difflineplus">+        def up():</span>
<a href="#l16.1494"></a><span id="l16.1494" class="difflineplus">+            &quot;&quot;&quot;Undo up filter.&quot;&quot;&quot;</span>
<a href="#l16.1495"></a><span id="l16.1495" class="difflineplus">+</span>
<a href="#l16.1496"></a><span id="l16.1496" class="difflineplus">+            for i in range(len(result)):</span>
<a href="#l16.1497"></a><span id="l16.1497" class="difflineplus">+                x = scanline[i]</span>
<a href="#l16.1498"></a><span id="l16.1498" class="difflineplus">+                b = previous[i]</span>
<a href="#l16.1499"></a><span id="l16.1499" class="difflineplus">+                result[i] = (x + b) &amp; 0xff</span>
<a href="#l16.1500"></a><span id="l16.1500" class="difflineplus">+</span>
<a href="#l16.1501"></a><span id="l16.1501" class="difflineplus">+        def average():</span>
<a href="#l16.1502"></a><span id="l16.1502" class="difflineplus">+            &quot;&quot;&quot;Undo average filter.&quot;&quot;&quot;</span>
<a href="#l16.1503"></a><span id="l16.1503" class="difflineplus">+</span>
<a href="#l16.1504"></a><span id="l16.1504" class="difflineplus">+            ai = -fu</span>
<a href="#l16.1505"></a><span id="l16.1505" class="difflineplus">+            for i in range(len(result)):</span>
<a href="#l16.1506"></a><span id="l16.1506" class="difflineplus">+                x = scanline[i]</span>
<a href="#l16.1507"></a><span id="l16.1507" class="difflineplus">+                if ai &lt; 0:</span>
<a href="#l16.1508"></a><span id="l16.1508" class="difflineplus">+                    a = 0</span>
<a href="#l16.1509"></a><span id="l16.1509" class="difflineplus">+                else:</span>
<a href="#l16.1510"></a><span id="l16.1510" class="difflineplus">+                    a = result[ai]</span>
<a href="#l16.1511"></a><span id="l16.1511" class="difflineplus">+                b = previous[i]</span>
<a href="#l16.1512"></a><span id="l16.1512" class="difflineplus">+                result[i] = (x + ((a + b) &gt;&gt; 1)) &amp; 0xff</span>
<a href="#l16.1513"></a><span id="l16.1513" class="difflineplus">+                ai += 1</span>
<a href="#l16.1514"></a><span id="l16.1514" class="difflineplus">+</span>
<a href="#l16.1515"></a><span id="l16.1515" class="difflineplus">+        def paeth():</span>
<a href="#l16.1516"></a><span id="l16.1516" class="difflineplus">+            &quot;&quot;&quot;Undo Paeth filter.&quot;&quot;&quot;</span>
<a href="#l16.1517"></a><span id="l16.1517" class="difflineplus">+</span>
<a href="#l16.1518"></a><span id="l16.1518" class="difflineplus">+            # Also used for ci.</span>
<a href="#l16.1519"></a><span id="l16.1519" class="difflineplus">+            ai = -fu</span>
<a href="#l16.1520"></a><span id="l16.1520" class="difflineplus">+            for i in range(len(result)):</span>
<a href="#l16.1521"></a><span id="l16.1521" class="difflineplus">+                x = scanline[i]</span>
<a href="#l16.1522"></a><span id="l16.1522" class="difflineplus">+                if ai &lt; 0:</span>
<a href="#l16.1523"></a><span id="l16.1523" class="difflineplus">+                    a = c = 0</span>
<a href="#l16.1524"></a><span id="l16.1524" class="difflineplus">+                else:</span>
<a href="#l16.1525"></a><span id="l16.1525" class="difflineplus">+                    a = result[ai]</span>
<a href="#l16.1526"></a><span id="l16.1526" class="difflineplus">+                    c = previous[ai]</span>
<a href="#l16.1527"></a><span id="l16.1527" class="difflineplus">+                b = previous[i]</span>
<a href="#l16.1528"></a><span id="l16.1528" class="difflineplus">+                p = a + b - c</span>
<a href="#l16.1529"></a><span id="l16.1529" class="difflineplus">+                pa = abs(p - a)</span>
<a href="#l16.1530"></a><span id="l16.1530" class="difflineplus">+                pb = abs(p - b)</span>
<a href="#l16.1531"></a><span id="l16.1531" class="difflineplus">+                pc = abs(p - c)</span>
<a href="#l16.1532"></a><span id="l16.1532" class="difflineplus">+                if pa &lt;= pb and pa &lt;= pc:</span>
<a href="#l16.1533"></a><span id="l16.1533" class="difflineplus">+                    pr = a</span>
<a href="#l16.1534"></a><span id="l16.1534" class="difflineplus">+                elif pb &lt;= pc:</span>
<a href="#l16.1535"></a><span id="l16.1535" class="difflineplus">+                    pr = b</span>
<a href="#l16.1536"></a><span id="l16.1536" class="difflineplus">+                else:</span>
<a href="#l16.1537"></a><span id="l16.1537" class="difflineplus">+                    pr = c</span>
<a href="#l16.1538"></a><span id="l16.1538" class="difflineplus">+                result[i] = (x + pr) &amp; 0xff</span>
<a href="#l16.1539"></a><span id="l16.1539" class="difflineplus">+                ai += 1</span>
<a href="#l16.1540"></a><span id="l16.1540" class="difflineplus">+</span>
<a href="#l16.1541"></a><span id="l16.1541" class="difflineplus">+        # Call appropriate filter algorithm.  Note that 0 has already</span>
<a href="#l16.1542"></a><span id="l16.1542" class="difflineplus">+        # been dealt with.</span>
<a href="#l16.1543"></a><span id="l16.1543" class="difflineplus">+        (None, sub, up, average, paeth)[filter_type]()</span>
<a href="#l16.1544"></a><span id="l16.1544" class="difflineplus">+        return result</span>
<a href="#l16.1545"></a><span id="l16.1545" class="difflineplus">+</span>
<a href="#l16.1546"></a><span id="l16.1546" class="difflineplus">+    def deinterlace(self, raw):</span>
<a href="#l16.1547"></a><span id="l16.1547" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1548"></a><span id="l16.1548" class="difflineplus">+        Read raw pixel data, undo filters, deinterlace, and flatten.</span>
<a href="#l16.1549"></a><span id="l16.1549" class="difflineplus">+        Return in flat row flat pixel format.</span>
<a href="#l16.1550"></a><span id="l16.1550" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1551"></a><span id="l16.1551" class="difflineplus">+</span>
<a href="#l16.1552"></a><span id="l16.1552" class="difflineplus">+        # print &gt;&gt; sys.stderr, (&quot;Reading interlaced, w=%s, r=%s, planes=%s,&quot; +</span>
<a href="#l16.1553"></a><span id="l16.1553" class="difflineplus">+        #     &quot; bpp=%s&quot;) % (self.width, self.height, self.planes, self.bps)</span>
<a href="#l16.1554"></a><span id="l16.1554" class="difflineplus">+        # Values per row (of the target image)</span>
<a href="#l16.1555"></a><span id="l16.1555" class="difflineplus">+        vpr = self.width * self.planes</span>
<a href="#l16.1556"></a><span id="l16.1556" class="difflineplus">+</span>
<a href="#l16.1557"></a><span id="l16.1557" class="difflineplus">+        # Make a result array, and make it big enough.  Interleaving</span>
<a href="#l16.1558"></a><span id="l16.1558" class="difflineplus">+        # writes to the output array randomly (well, not quite), so the</span>
<a href="#l16.1559"></a><span id="l16.1559" class="difflineplus">+        # entire output array must be in memory.</span>
<a href="#l16.1560"></a><span id="l16.1560" class="difflineplus">+        fmt = 'BH'[self.bitdepth &gt; 8]</span>
<a href="#l16.1561"></a><span id="l16.1561" class="difflineplus">+        a = array(fmt, [0]*vpr*self.height)</span>
<a href="#l16.1562"></a><span id="l16.1562" class="difflineplus">+        source_offset = 0</span>
<a href="#l16.1563"></a><span id="l16.1563" class="difflineplus">+</span>
<a href="#l16.1564"></a><span id="l16.1564" class="difflineplus">+        for xstart, ystart, xstep, ystep in _adam7:</span>
<a href="#l16.1565"></a><span id="l16.1565" class="difflineplus">+            # print &gt;&gt; sys.stderr, &quot;Adam7: start=%s,%s step=%s,%s&quot; % (</span>
<a href="#l16.1566"></a><span id="l16.1566" class="difflineplus">+            #     xstart, ystart, xstep, ystep)</span>
<a href="#l16.1567"></a><span id="l16.1567" class="difflineplus">+            if xstart &gt;= self.width:</span>
<a href="#l16.1568"></a><span id="l16.1568" class="difflineplus">+                continue</span>
<a href="#l16.1569"></a><span id="l16.1569" class="difflineplus">+            # The previous (reconstructed) scanline.  None at the</span>
<a href="#l16.1570"></a><span id="l16.1570" class="difflineplus">+            # beginning of a pass to indicate that there is no previous</span>
<a href="#l16.1571"></a><span id="l16.1571" class="difflineplus">+            # line.</span>
<a href="#l16.1572"></a><span id="l16.1572" class="difflineplus">+            recon = None</span>
<a href="#l16.1573"></a><span id="l16.1573" class="difflineplus">+            # Pixels per row (reduced pass image)</span>
<a href="#l16.1574"></a><span id="l16.1574" class="difflineplus">+            ppr = int(math.ceil((self.width-xstart)/float(xstep)))</span>
<a href="#l16.1575"></a><span id="l16.1575" class="difflineplus">+            # Row size in bytes for this pass.</span>
<a href="#l16.1576"></a><span id="l16.1576" class="difflineplus">+            row_size = int(math.ceil(self.psize * ppr))</span>
<a href="#l16.1577"></a><span id="l16.1577" class="difflineplus">+            for y in range(ystart, self.height, ystep):</span>
<a href="#l16.1578"></a><span id="l16.1578" class="difflineplus">+                filter_type = raw[source_offset]</span>
<a href="#l16.1579"></a><span id="l16.1579" class="difflineplus">+                source_offset += 1</span>
<a href="#l16.1580"></a><span id="l16.1580" class="difflineplus">+                scanline = raw[source_offset:source_offset+row_size]</span>
<a href="#l16.1581"></a><span id="l16.1581" class="difflineplus">+                source_offset += row_size</span>
<a href="#l16.1582"></a><span id="l16.1582" class="difflineplus">+                recon = self.undo_filter(filter_type, scanline, recon)</span>
<a href="#l16.1583"></a><span id="l16.1583" class="difflineplus">+                # Convert so that there is one element per pixel value</span>
<a href="#l16.1584"></a><span id="l16.1584" class="difflineplus">+                flat = self.serialtoflat(recon, ppr)</span>
<a href="#l16.1585"></a><span id="l16.1585" class="difflineplus">+                if xstep == 1:</span>
<a href="#l16.1586"></a><span id="l16.1586" class="difflineplus">+                    assert xstart == 0</span>
<a href="#l16.1587"></a><span id="l16.1587" class="difflineplus">+                    offset = y * vpr</span>
<a href="#l16.1588"></a><span id="l16.1588" class="difflineplus">+                    a[offset:offset+vpr] = flat</span>
<a href="#l16.1589"></a><span id="l16.1589" class="difflineplus">+                else:</span>
<a href="#l16.1590"></a><span id="l16.1590" class="difflineplus">+                    offset = y * vpr + xstart * self.planes</span>
<a href="#l16.1591"></a><span id="l16.1591" class="difflineplus">+                    end_offset = (y+1) * vpr</span>
<a href="#l16.1592"></a><span id="l16.1592" class="difflineplus">+                    skip = self.planes * xstep</span>
<a href="#l16.1593"></a><span id="l16.1593" class="difflineplus">+                    for i in range(self.planes):</span>
<a href="#l16.1594"></a><span id="l16.1594" class="difflineplus">+                        a[offset+i:end_offset:skip] = \</span>
<a href="#l16.1595"></a><span id="l16.1595" class="difflineplus">+                            flat[i::self.planes]</span>
<a href="#l16.1596"></a><span id="l16.1596" class="difflineplus">+        return a</span>
<a href="#l16.1597"></a><span id="l16.1597" class="difflineplus">+</span>
<a href="#l16.1598"></a><span id="l16.1598" class="difflineplus">+    def iterboxed(self, rows):</span>
<a href="#l16.1599"></a><span id="l16.1599" class="difflineplus">+        &quot;&quot;&quot;Iterator that yields each scanline in boxed row flat pixel</span>
<a href="#l16.1600"></a><span id="l16.1600" class="difflineplus">+        format.  `rows` should be an iterator that yields the bytes of</span>
<a href="#l16.1601"></a><span id="l16.1601" class="difflineplus">+        each row in turn.</span>
<a href="#l16.1602"></a><span id="l16.1602" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1603"></a><span id="l16.1603" class="difflineplus">+</span>
<a href="#l16.1604"></a><span id="l16.1604" class="difflineplus">+        def asvalues(raw):</span>
<a href="#l16.1605"></a><span id="l16.1605" class="difflineplus">+            &quot;&quot;&quot;Convert a row of raw bytes into a flat row.  Result may</span>
<a href="#l16.1606"></a><span id="l16.1606" class="difflineplus">+            or may not share with argument&quot;&quot;&quot;</span>
<a href="#l16.1607"></a><span id="l16.1607" class="difflineplus">+</span>
<a href="#l16.1608"></a><span id="l16.1608" class="difflineplus">+            if self.bitdepth == 8:</span>
<a href="#l16.1609"></a><span id="l16.1609" class="difflineplus">+                return raw</span>
<a href="#l16.1610"></a><span id="l16.1610" class="difflineplus">+            if self.bitdepth == 16:</span>
<a href="#l16.1611"></a><span id="l16.1611" class="difflineplus">+                raw = tostring(raw)</span>
<a href="#l16.1612"></a><span id="l16.1612" class="difflineplus">+                return array('H', struct.unpack('!%dH' % (len(raw)//2), raw))</span>
<a href="#l16.1613"></a><span id="l16.1613" class="difflineplus">+            assert self.bitdepth &lt; 8</span>
<a href="#l16.1614"></a><span id="l16.1614" class="difflineplus">+            width = self.width</span>
<a href="#l16.1615"></a><span id="l16.1615" class="difflineplus">+            # Samples per byte</span>
<a href="#l16.1616"></a><span id="l16.1616" class="difflineplus">+            spb = 8//self.bitdepth</span>
<a href="#l16.1617"></a><span id="l16.1617" class="difflineplus">+            out = array('B')</span>
<a href="#l16.1618"></a><span id="l16.1618" class="difflineplus">+            mask = 2**self.bitdepth - 1</span>
<a href="#l16.1619"></a><span id="l16.1619" class="difflineplus">+            shifts = map(self.bitdepth.__mul__, reversed(range(spb)))</span>
<a href="#l16.1620"></a><span id="l16.1620" class="difflineplus">+            for o in raw:</span>
<a href="#l16.1621"></a><span id="l16.1621" class="difflineplus">+                out.extend(map(lambda i: mask&amp;(o&gt;&gt;i), shifts))</span>
<a href="#l16.1622"></a><span id="l16.1622" class="difflineplus">+            return out[:width]</span>
<a href="#l16.1623"></a><span id="l16.1623" class="difflineplus">+</span>
<a href="#l16.1624"></a><span id="l16.1624" class="difflineplus">+        return itertools.imap(asvalues, rows)</span>
<a href="#l16.1625"></a><span id="l16.1625" class="difflineplus">+</span>
<a href="#l16.1626"></a><span id="l16.1626" class="difflineplus">+    def serialtoflat(self, bytes, width=None):</span>
<a href="#l16.1627"></a><span id="l16.1627" class="difflineplus">+        &quot;&quot;&quot;Convert serial format (byte stream) pixel data to flat row</span>
<a href="#l16.1628"></a><span id="l16.1628" class="difflineplus">+        flat pixel.</span>
<a href="#l16.1629"></a><span id="l16.1629" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1630"></a><span id="l16.1630" class="difflineplus">+</span>
<a href="#l16.1631"></a><span id="l16.1631" class="difflineplus">+        if self.bitdepth == 8:</span>
<a href="#l16.1632"></a><span id="l16.1632" class="difflineplus">+            return bytes</span>
<a href="#l16.1633"></a><span id="l16.1633" class="difflineplus">+        if self.bitdepth == 16:</span>
<a href="#l16.1634"></a><span id="l16.1634" class="difflineplus">+            bytes = tostring(bytes)</span>
<a href="#l16.1635"></a><span id="l16.1635" class="difflineplus">+            return array('H',</span>
<a href="#l16.1636"></a><span id="l16.1636" class="difflineplus">+              struct.unpack('!%dH' % (len(bytes)//2), bytes))</span>
<a href="#l16.1637"></a><span id="l16.1637" class="difflineplus">+        assert self.bitdepth &lt; 8</span>
<a href="#l16.1638"></a><span id="l16.1638" class="difflineplus">+        if width is None:</span>
<a href="#l16.1639"></a><span id="l16.1639" class="difflineplus">+            width = self.width</span>
<a href="#l16.1640"></a><span id="l16.1640" class="difflineplus">+        # Samples per byte</span>
<a href="#l16.1641"></a><span id="l16.1641" class="difflineplus">+        spb = 8//self.bitdepth</span>
<a href="#l16.1642"></a><span id="l16.1642" class="difflineplus">+        out = array('B')</span>
<a href="#l16.1643"></a><span id="l16.1643" class="difflineplus">+        mask = 2**self.bitdepth - 1</span>
<a href="#l16.1644"></a><span id="l16.1644" class="difflineplus">+        shifts = map(self.bitdepth.__mul__, reversed(range(spb)))</span>
<a href="#l16.1645"></a><span id="l16.1645" class="difflineplus">+        l = width</span>
<a href="#l16.1646"></a><span id="l16.1646" class="difflineplus">+        for o in bytes:</span>
<a href="#l16.1647"></a><span id="l16.1647" class="difflineplus">+            out.extend([(mask&amp;(o&gt;&gt;s)) for s in shifts][:l])</span>
<a href="#l16.1648"></a><span id="l16.1648" class="difflineplus">+            l -= spb</span>
<a href="#l16.1649"></a><span id="l16.1649" class="difflineplus">+            if l &lt;= 0:</span>
<a href="#l16.1650"></a><span id="l16.1650" class="difflineplus">+                l = width</span>
<a href="#l16.1651"></a><span id="l16.1651" class="difflineplus">+        return out</span>
<a href="#l16.1652"></a><span id="l16.1652" class="difflineplus">+</span>
<a href="#l16.1653"></a><span id="l16.1653" class="difflineplus">+    def iterstraight(self, raw):</span>
<a href="#l16.1654"></a><span id="l16.1654" class="difflineplus">+        &quot;&quot;&quot;Iterator that undoes the effect of filtering, and yields each</span>
<a href="#l16.1655"></a><span id="l16.1655" class="difflineplus">+        row in serialised format (as a sequence of bytes).  Assumes input</span>
<a href="#l16.1656"></a><span id="l16.1656" class="difflineplus">+        is straightlaced.  `raw` should be an iterable that yields the</span>
<a href="#l16.1657"></a><span id="l16.1657" class="difflineplus">+        raw bytes in chunks of arbitrary size.&quot;&quot;&quot;</span>
<a href="#l16.1658"></a><span id="l16.1658" class="difflineplus">+</span>
<a href="#l16.1659"></a><span id="l16.1659" class="difflineplus">+        # length of row, in bytes</span>
<a href="#l16.1660"></a><span id="l16.1660" class="difflineplus">+        rb = self.row_bytes</span>
<a href="#l16.1661"></a><span id="l16.1661" class="difflineplus">+        a = array('B')</span>
<a href="#l16.1662"></a><span id="l16.1662" class="difflineplus">+        # The previous (reconstructed) scanline.  None indicates first</span>
<a href="#l16.1663"></a><span id="l16.1663" class="difflineplus">+        # line of image.</span>
<a href="#l16.1664"></a><span id="l16.1664" class="difflineplus">+        recon = None</span>
<a href="#l16.1665"></a><span id="l16.1665" class="difflineplus">+        for some in raw:</span>
<a href="#l16.1666"></a><span id="l16.1666" class="difflineplus">+            a.extend(some)</span>
<a href="#l16.1667"></a><span id="l16.1667" class="difflineplus">+            while len(a) &gt;= rb + 1:</span>
<a href="#l16.1668"></a><span id="l16.1668" class="difflineplus">+                filter_type = a[0]</span>
<a href="#l16.1669"></a><span id="l16.1669" class="difflineplus">+                scanline = a[1:rb+1]</span>
<a href="#l16.1670"></a><span id="l16.1670" class="difflineplus">+                del a[:rb+1]</span>
<a href="#l16.1671"></a><span id="l16.1671" class="difflineplus">+                recon = self.undo_filter(filter_type, scanline, recon)</span>
<a href="#l16.1672"></a><span id="l16.1672" class="difflineplus">+                yield recon</span>
<a href="#l16.1673"></a><span id="l16.1673" class="difflineplus">+        if len(a) != 0:</span>
<a href="#l16.1674"></a><span id="l16.1674" class="difflineplus">+            # :file:format We get here with a file format error: when the</span>
<a href="#l16.1675"></a><span id="l16.1675" class="difflineplus">+            # available bytes (after decompressing) do not pack into exact</span>
<a href="#l16.1676"></a><span id="l16.1676" class="difflineplus">+            # rows.</span>
<a href="#l16.1677"></a><span id="l16.1677" class="difflineplus">+            raise FormatError(</span>
<a href="#l16.1678"></a><span id="l16.1678" class="difflineplus">+              'Wrong size for decompressed IDAT chunk.')</span>
<a href="#l16.1679"></a><span id="l16.1679" class="difflineplus">+        assert len(a) == 0</span>
<a href="#l16.1680"></a><span id="l16.1680" class="difflineplus">+</span>
<a href="#l16.1681"></a><span id="l16.1681" class="difflineplus">+    def validate_signature(self):</span>
<a href="#l16.1682"></a><span id="l16.1682" class="difflineplus">+        &quot;&quot;&quot;If signature (header) has not been read then read and</span>
<a href="#l16.1683"></a><span id="l16.1683" class="difflineplus">+        validate it; otherwise do nothing.</span>
<a href="#l16.1684"></a><span id="l16.1684" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1685"></a><span id="l16.1685" class="difflineplus">+</span>
<a href="#l16.1686"></a><span id="l16.1686" class="difflineplus">+        if self.signature:</span>
<a href="#l16.1687"></a><span id="l16.1687" class="difflineplus">+            return</span>
<a href="#l16.1688"></a><span id="l16.1688" class="difflineplus">+        self.signature = self.file.read(8)</span>
<a href="#l16.1689"></a><span id="l16.1689" class="difflineplus">+        if self.signature != _signature:</span>
<a href="#l16.1690"></a><span id="l16.1690" class="difflineplus">+            raise FormatError(&quot;PNG file has invalid signature.&quot;)</span>
<a href="#l16.1691"></a><span id="l16.1691" class="difflineplus">+</span>
<a href="#l16.1692"></a><span id="l16.1692" class="difflineplus">+    def preamble(self):</span>
<a href="#l16.1693"></a><span id="l16.1693" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1694"></a><span id="l16.1694" class="difflineplus">+        Extract the image metadata by reading the initial part of the PNG</span>
<a href="#l16.1695"></a><span id="l16.1695" class="difflineplus">+        file up to the start of the ``IDAT`` chunk.  All the chunks that</span>
<a href="#l16.1696"></a><span id="l16.1696" class="difflineplus">+        precede the ``IDAT`` chunk are read and either processed for</span>
<a href="#l16.1697"></a><span id="l16.1697" class="difflineplus">+        metadata or discarded.</span>
<a href="#l16.1698"></a><span id="l16.1698" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1699"></a><span id="l16.1699" class="difflineplus">+</span>
<a href="#l16.1700"></a><span id="l16.1700" class="difflineplus">+        self.validate_signature()</span>
<a href="#l16.1701"></a><span id="l16.1701" class="difflineplus">+</span>
<a href="#l16.1702"></a><span id="l16.1702" class="difflineplus">+        while True:</span>
<a href="#l16.1703"></a><span id="l16.1703" class="difflineplus">+            if not self.atchunk:</span>
<a href="#l16.1704"></a><span id="l16.1704" class="difflineplus">+                self.atchunk = self.chunklentype()</span>
<a href="#l16.1705"></a><span id="l16.1705" class="difflineplus">+                if self.atchunk is None:</span>
<a href="#l16.1706"></a><span id="l16.1706" class="difflineplus">+                    raise FormatError(</span>
<a href="#l16.1707"></a><span id="l16.1707" class="difflineplus">+                      'This PNG file has no IDAT chunks.')</span>
<a href="#l16.1708"></a><span id="l16.1708" class="difflineplus">+            if self.atchunk[1] == 'IDAT':</span>
<a href="#l16.1709"></a><span id="l16.1709" class="difflineplus">+                return</span>
<a href="#l16.1710"></a><span id="l16.1710" class="difflineplus">+            self.process_chunk()</span>
<a href="#l16.1711"></a><span id="l16.1711" class="difflineplus">+</span>
<a href="#l16.1712"></a><span id="l16.1712" class="difflineplus">+    def chunklentype(self):</span>
<a href="#l16.1713"></a><span id="l16.1713" class="difflineplus">+        &quot;&quot;&quot;Reads just enough of the input to determine the next</span>
<a href="#l16.1714"></a><span id="l16.1714" class="difflineplus">+        chunk's length and type, returned as a (*length*, *type*) pair</span>
<a href="#l16.1715"></a><span id="l16.1715" class="difflineplus">+        where *type* is a string.  If there are no more chunks, ``None``</span>
<a href="#l16.1716"></a><span id="l16.1716" class="difflineplus">+        is returned.</span>
<a href="#l16.1717"></a><span id="l16.1717" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1718"></a><span id="l16.1718" class="difflineplus">+</span>
<a href="#l16.1719"></a><span id="l16.1719" class="difflineplus">+        x = self.file.read(8)</span>
<a href="#l16.1720"></a><span id="l16.1720" class="difflineplus">+        if not x:</span>
<a href="#l16.1721"></a><span id="l16.1721" class="difflineplus">+            return None</span>
<a href="#l16.1722"></a><span id="l16.1722" class="difflineplus">+        if len(x) != 8:</span>
<a href="#l16.1723"></a><span id="l16.1723" class="difflineplus">+            raise FormatError(</span>
<a href="#l16.1724"></a><span id="l16.1724" class="difflineplus">+              'End of file whilst reading chunk length and type.')</span>
<a href="#l16.1725"></a><span id="l16.1725" class="difflineplus">+        length,type = struct.unpack('!I4s', x)</span>
<a href="#l16.1726"></a><span id="l16.1726" class="difflineplus">+        type = bytestostr(type)</span>
<a href="#l16.1727"></a><span id="l16.1727" class="difflineplus">+        if length &gt; 2**31-1:</span>
<a href="#l16.1728"></a><span id="l16.1728" class="difflineplus">+            raise FormatError('Chunk %s is too large: %d.' % (type,length))</span>
<a href="#l16.1729"></a><span id="l16.1729" class="difflineplus">+        return length,type</span>
<a href="#l16.1730"></a><span id="l16.1730" class="difflineplus">+</span>
<a href="#l16.1731"></a><span id="l16.1731" class="difflineplus">+    def process_chunk(self):</span>
<a href="#l16.1732"></a><span id="l16.1732" class="difflineplus">+        &quot;&quot;&quot;Process the next chunk and its data.  This only processes the</span>
<a href="#l16.1733"></a><span id="l16.1733" class="difflineplus">+        following chunk types, all others are ignored: ``IHDR``,</span>
<a href="#l16.1734"></a><span id="l16.1734" class="difflineplus">+        ``PLTE``, ``bKGD``, ``tRNS``, ``gAMA``, ``sBIT``.</span>
<a href="#l16.1735"></a><span id="l16.1735" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1736"></a><span id="l16.1736" class="difflineplus">+</span>
<a href="#l16.1737"></a><span id="l16.1737" class="difflineplus">+        type, data = self.chunk()</span>
<a href="#l16.1738"></a><span id="l16.1738" class="difflineplus">+        if type == 'IHDR':</span>
<a href="#l16.1739"></a><span id="l16.1739" class="difflineplus">+            # http://www.w3.org/TR/PNG/#11IHDR</span>
<a href="#l16.1740"></a><span id="l16.1740" class="difflineplus">+            if len(data) != 13:</span>
<a href="#l16.1741"></a><span id="l16.1741" class="difflineplus">+                raise FormatError('IHDR chunk has incorrect length.')</span>
<a href="#l16.1742"></a><span id="l16.1742" class="difflineplus">+            (self.width, self.height, self.bitdepth, self.color_type,</span>
<a href="#l16.1743"></a><span id="l16.1743" class="difflineplus">+             self.compression, self.filter,</span>
<a href="#l16.1744"></a><span id="l16.1744" class="difflineplus">+             self.interlace) = struct.unpack(&quot;!2I5B&quot;, data)</span>
<a href="#l16.1745"></a><span id="l16.1745" class="difflineplus">+</span>
<a href="#l16.1746"></a><span id="l16.1746" class="difflineplus">+            # Check that the header specifies only valid combinations.</span>
<a href="#l16.1747"></a><span id="l16.1747" class="difflineplus">+            if self.bitdepth not in (1,2,4,8,16):</span>
<a href="#l16.1748"></a><span id="l16.1748" class="difflineplus">+                raise Error(&quot;invalid bit depth %d&quot; % self.bitdepth)</span>
<a href="#l16.1749"></a><span id="l16.1749" class="difflineplus">+            if self.color_type not in (0,2,3,4,6):</span>
<a href="#l16.1750"></a><span id="l16.1750" class="difflineplus">+                raise Error(&quot;invalid colour type %d&quot; % self.color_type)</span>
<a href="#l16.1751"></a><span id="l16.1751" class="difflineplus">+            # Check indexed (palettized) images have 8 or fewer bits</span>
<a href="#l16.1752"></a><span id="l16.1752" class="difflineplus">+            # per pixel; check only indexed or greyscale images have</span>
<a href="#l16.1753"></a><span id="l16.1753" class="difflineplus">+            # fewer than 8 bits per pixel.</span>
<a href="#l16.1754"></a><span id="l16.1754" class="difflineplus">+            if ((self.color_type &amp; 1 and self.bitdepth &gt; 8) or</span>
<a href="#l16.1755"></a><span id="l16.1755" class="difflineplus">+                (self.bitdepth &lt; 8 and self.color_type not in (0,3))):</span>
<a href="#l16.1756"></a><span id="l16.1756" class="difflineplus">+                raise FormatError(&quot;Illegal combination of bit depth (%d)&quot;</span>
<a href="#l16.1757"></a><span id="l16.1757" class="difflineplus">+                  &quot; and colour type (%d).&quot;</span>
<a href="#l16.1758"></a><span id="l16.1758" class="difflineplus">+                  &quot; See http://www.w3.org/TR/2003/REC-PNG-20031110/#table111 .&quot;</span>
<a href="#l16.1759"></a><span id="l16.1759" class="difflineplus">+                  % (self.bitdepth, self.color_type))</span>
<a href="#l16.1760"></a><span id="l16.1760" class="difflineplus">+            if self.compression != 0:</span>
<a href="#l16.1761"></a><span id="l16.1761" class="difflineplus">+                raise Error(&quot;unknown compression method %d&quot; % self.compression)</span>
<a href="#l16.1762"></a><span id="l16.1762" class="difflineplus">+            if self.filter != 0:</span>
<a href="#l16.1763"></a><span id="l16.1763" class="difflineplus">+                raise FormatError(&quot;Unknown filter method %d,&quot;</span>
<a href="#l16.1764"></a><span id="l16.1764" class="difflineplus">+                  &quot; see http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .&quot;</span>
<a href="#l16.1765"></a><span id="l16.1765" class="difflineplus">+                  % self.filter)</span>
<a href="#l16.1766"></a><span id="l16.1766" class="difflineplus">+            if self.interlace not in (0,1):</span>
<a href="#l16.1767"></a><span id="l16.1767" class="difflineplus">+                raise FormatError(&quot;Unknown interlace method %d,&quot;</span>
<a href="#l16.1768"></a><span id="l16.1768" class="difflineplus">+                  &quot; see http://www.w3.org/TR/2003/REC-PNG-20031110/#8InterlaceMethods .&quot;</span>
<a href="#l16.1769"></a><span id="l16.1769" class="difflineplus">+                  % self.interlace)</span>
<a href="#l16.1770"></a><span id="l16.1770" class="difflineplus">+</span>
<a href="#l16.1771"></a><span id="l16.1771" class="difflineplus">+            # Derived values</span>
<a href="#l16.1772"></a><span id="l16.1772" class="difflineplus">+            # http://www.w3.org/TR/PNG/#6Colour-values</span>
<a href="#l16.1773"></a><span id="l16.1773" class="difflineplus">+            colormap =  bool(self.color_type &amp; 1)</span>
<a href="#l16.1774"></a><span id="l16.1774" class="difflineplus">+            greyscale = not (self.color_type &amp; 2)</span>
<a href="#l16.1775"></a><span id="l16.1775" class="difflineplus">+            alpha = bool(self.color_type &amp; 4)</span>
<a href="#l16.1776"></a><span id="l16.1776" class="difflineplus">+            color_planes = (3,1)[greyscale or colormap]</span>
<a href="#l16.1777"></a><span id="l16.1777" class="difflineplus">+            planes = color_planes + alpha</span>
<a href="#l16.1778"></a><span id="l16.1778" class="difflineplus">+</span>
<a href="#l16.1779"></a><span id="l16.1779" class="difflineplus">+            self.colormap = colormap</span>
<a href="#l16.1780"></a><span id="l16.1780" class="difflineplus">+            self.greyscale = greyscale</span>
<a href="#l16.1781"></a><span id="l16.1781" class="difflineplus">+            self.alpha = alpha</span>
<a href="#l16.1782"></a><span id="l16.1782" class="difflineplus">+            self.color_planes = color_planes</span>
<a href="#l16.1783"></a><span id="l16.1783" class="difflineplus">+            self.planes = planes</span>
<a href="#l16.1784"></a><span id="l16.1784" class="difflineplus">+            self.psize = float(self.bitdepth)/float(8) * planes</span>
<a href="#l16.1785"></a><span id="l16.1785" class="difflineplus">+            if int(self.psize) == self.psize:</span>
<a href="#l16.1786"></a><span id="l16.1786" class="difflineplus">+                self.psize = int(self.psize)</span>
<a href="#l16.1787"></a><span id="l16.1787" class="difflineplus">+            self.row_bytes = int(math.ceil(self.width * self.psize))</span>
<a href="#l16.1788"></a><span id="l16.1788" class="difflineplus">+            # Stores PLTE chunk if present, and is used to check</span>
<a href="#l16.1789"></a><span id="l16.1789" class="difflineplus">+            # chunk ordering constraints.</span>
<a href="#l16.1790"></a><span id="l16.1790" class="difflineplus">+            self.plte = None</span>
<a href="#l16.1791"></a><span id="l16.1791" class="difflineplus">+            # Stores tRNS chunk if present, and is used to check chunk</span>
<a href="#l16.1792"></a><span id="l16.1792" class="difflineplus">+            # ordering constraints.</span>
<a href="#l16.1793"></a><span id="l16.1793" class="difflineplus">+            self.trns = None</span>
<a href="#l16.1794"></a><span id="l16.1794" class="difflineplus">+            # Stores sbit chunk if present.</span>
<a href="#l16.1795"></a><span id="l16.1795" class="difflineplus">+            self.sbit = None</span>
<a href="#l16.1796"></a><span id="l16.1796" class="difflineplus">+        elif type == 'PLTE':</span>
<a href="#l16.1797"></a><span id="l16.1797" class="difflineplus">+            # http://www.w3.org/TR/PNG/#11PLTE</span>
<a href="#l16.1798"></a><span id="l16.1798" class="difflineplus">+            if self.plte:</span>
<a href="#l16.1799"></a><span id="l16.1799" class="difflineplus">+                warnings.warn(&quot;Multiple PLTE chunks present.&quot;)</span>
<a href="#l16.1800"></a><span id="l16.1800" class="difflineplus">+            self.plte = data</span>
<a href="#l16.1801"></a><span id="l16.1801" class="difflineplus">+            if len(data) % 3 != 0:</span>
<a href="#l16.1802"></a><span id="l16.1802" class="difflineplus">+                raise FormatError(</span>
<a href="#l16.1803"></a><span id="l16.1803" class="difflineplus">+                  &quot;PLTE chunk's length should be a multiple of 3.&quot;)</span>
<a href="#l16.1804"></a><span id="l16.1804" class="difflineplus">+            if len(data) &gt; (2**self.bitdepth)*3:</span>
<a href="#l16.1805"></a><span id="l16.1805" class="difflineplus">+                raise FormatError(&quot;PLTE chunk is too long.&quot;)</span>
<a href="#l16.1806"></a><span id="l16.1806" class="difflineplus">+            if len(data) == 0:</span>
<a href="#l16.1807"></a><span id="l16.1807" class="difflineplus">+                raise FormatError(&quot;Empty PLTE is not allowed.&quot;)</span>
<a href="#l16.1808"></a><span id="l16.1808" class="difflineplus">+        elif type == 'bKGD':</span>
<a href="#l16.1809"></a><span id="l16.1809" class="difflineplus">+            try:</span>
<a href="#l16.1810"></a><span id="l16.1810" class="difflineplus">+                if self.colormap:</span>
<a href="#l16.1811"></a><span id="l16.1811" class="difflineplus">+                    if not self.plte:</span>
<a href="#l16.1812"></a><span id="l16.1812" class="difflineplus">+                        warnings.warn(</span>
<a href="#l16.1813"></a><span id="l16.1813" class="difflineplus">+                          &quot;PLTE chunk is required before bKGD chunk.&quot;)</span>
<a href="#l16.1814"></a><span id="l16.1814" class="difflineplus">+                    self.background = struct.unpack('B', data)</span>
<a href="#l16.1815"></a><span id="l16.1815" class="difflineplus">+                else:</span>
<a href="#l16.1816"></a><span id="l16.1816" class="difflineplus">+                    self.background = struct.unpack(&quot;!%dH&quot; % self.color_planes,</span>
<a href="#l16.1817"></a><span id="l16.1817" class="difflineplus">+                      data)</span>
<a href="#l16.1818"></a><span id="l16.1818" class="difflineplus">+            except struct.error:</span>
<a href="#l16.1819"></a><span id="l16.1819" class="difflineplus">+                raise FormatError(&quot;bKGD chunk has incorrect length.&quot;)</span>
<a href="#l16.1820"></a><span id="l16.1820" class="difflineplus">+        elif type == 'tRNS':</span>
<a href="#l16.1821"></a><span id="l16.1821" class="difflineplus">+            # http://www.w3.org/TR/PNG/#11tRNS</span>
<a href="#l16.1822"></a><span id="l16.1822" class="difflineplus">+            self.trns = data</span>
<a href="#l16.1823"></a><span id="l16.1823" class="difflineplus">+            if self.colormap:</span>
<a href="#l16.1824"></a><span id="l16.1824" class="difflineplus">+                if not self.plte:</span>
<a href="#l16.1825"></a><span id="l16.1825" class="difflineplus">+                    warnings.warn(&quot;PLTE chunk is required before tRNS chunk.&quot;)</span>
<a href="#l16.1826"></a><span id="l16.1826" class="difflineplus">+                else:</span>
<a href="#l16.1827"></a><span id="l16.1827" class="difflineplus">+                    if len(data) &gt; len(self.plte)/3:</span>
<a href="#l16.1828"></a><span id="l16.1828" class="difflineplus">+                        # Was warning, but promoted to Error as it</span>
<a href="#l16.1829"></a><span id="l16.1829" class="difflineplus">+                        # would otherwise cause pain later on.</span>
<a href="#l16.1830"></a><span id="l16.1830" class="difflineplus">+                        raise FormatError(&quot;tRNS chunk is too long.&quot;)</span>
<a href="#l16.1831"></a><span id="l16.1831" class="difflineplus">+            else:</span>
<a href="#l16.1832"></a><span id="l16.1832" class="difflineplus">+                if self.alpha:</span>
<a href="#l16.1833"></a><span id="l16.1833" class="difflineplus">+                    raise FormatError(</span>
<a href="#l16.1834"></a><span id="l16.1834" class="difflineplus">+                      &quot;tRNS chunk is not valid with colour type %d.&quot; %</span>
<a href="#l16.1835"></a><span id="l16.1835" class="difflineplus">+                      self.color_type)</span>
<a href="#l16.1836"></a><span id="l16.1836" class="difflineplus">+                try:</span>
<a href="#l16.1837"></a><span id="l16.1837" class="difflineplus">+                    self.transparent = \</span>
<a href="#l16.1838"></a><span id="l16.1838" class="difflineplus">+                        struct.unpack(&quot;!%dH&quot; % self.color_planes, data)</span>
<a href="#l16.1839"></a><span id="l16.1839" class="difflineplus">+                except struct.error:</span>
<a href="#l16.1840"></a><span id="l16.1840" class="difflineplus">+                    raise FormatError(&quot;tRNS chunk has incorrect length.&quot;)</span>
<a href="#l16.1841"></a><span id="l16.1841" class="difflineplus">+        elif type == 'gAMA':</span>
<a href="#l16.1842"></a><span id="l16.1842" class="difflineplus">+            try:</span>
<a href="#l16.1843"></a><span id="l16.1843" class="difflineplus">+                self.gamma = struct.unpack(&quot;!L&quot;, data)[0] / 100000.0</span>
<a href="#l16.1844"></a><span id="l16.1844" class="difflineplus">+            except struct.error:</span>
<a href="#l16.1845"></a><span id="l16.1845" class="difflineplus">+                raise FormatError(&quot;gAMA chunk has incorrect length.&quot;)</span>
<a href="#l16.1846"></a><span id="l16.1846" class="difflineplus">+        elif type == 'sBIT':</span>
<a href="#l16.1847"></a><span id="l16.1847" class="difflineplus">+            self.sbit = data</span>
<a href="#l16.1848"></a><span id="l16.1848" class="difflineplus">+            if (self.colormap and len(data) != 3 or</span>
<a href="#l16.1849"></a><span id="l16.1849" class="difflineplus">+                not self.colormap and len(data) != self.planes):</span>
<a href="#l16.1850"></a><span id="l16.1850" class="difflineplus">+                raise FormatError(&quot;sBIT chunk has incorrect length.&quot;)</span>
<a href="#l16.1851"></a><span id="l16.1851" class="difflineplus">+</span>
<a href="#l16.1852"></a><span id="l16.1852" class="difflineplus">+    def read(self):</span>
<a href="#l16.1853"></a><span id="l16.1853" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1854"></a><span id="l16.1854" class="difflineplus">+        Read the PNG file and decode it.  Returns (`width`, `height`,</span>
<a href="#l16.1855"></a><span id="l16.1855" class="difflineplus">+        `pixels`, `metadata`).</span>
<a href="#l16.1856"></a><span id="l16.1856" class="difflineplus">+</span>
<a href="#l16.1857"></a><span id="l16.1857" class="difflineplus">+        May use excessive memory.</span>
<a href="#l16.1858"></a><span id="l16.1858" class="difflineplus">+</span>
<a href="#l16.1859"></a><span id="l16.1859" class="difflineplus">+        `pixels` are returned in boxed row flat pixel format.</span>
<a href="#l16.1860"></a><span id="l16.1860" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1861"></a><span id="l16.1861" class="difflineplus">+</span>
<a href="#l16.1862"></a><span id="l16.1862" class="difflineplus">+        def iteridat():</span>
<a href="#l16.1863"></a><span id="l16.1863" class="difflineplus">+            &quot;&quot;&quot;Iterator that yields all the ``IDAT`` chunks as strings.&quot;&quot;&quot;</span>
<a href="#l16.1864"></a><span id="l16.1864" class="difflineplus">+            while True:</span>
<a href="#l16.1865"></a><span id="l16.1865" class="difflineplus">+                try:</span>
<a href="#l16.1866"></a><span id="l16.1866" class="difflineplus">+                    type, data = self.chunk()</span>
<a href="#l16.1867"></a><span id="l16.1867" class="difflineplus">+                except ValueError, e:</span>
<a href="#l16.1868"></a><span id="l16.1868" class="difflineplus">+                    raise ChunkError(e.args[0])</span>
<a href="#l16.1869"></a><span id="l16.1869" class="difflineplus">+                if type == 'IEND':</span>
<a href="#l16.1870"></a><span id="l16.1870" class="difflineplus">+                    # http://www.w3.org/TR/PNG/#11IEND</span>
<a href="#l16.1871"></a><span id="l16.1871" class="difflineplus">+                    break</span>
<a href="#l16.1872"></a><span id="l16.1872" class="difflineplus">+                if type != 'IDAT':</span>
<a href="#l16.1873"></a><span id="l16.1873" class="difflineplus">+                    continue</span>
<a href="#l16.1874"></a><span id="l16.1874" class="difflineplus">+                # type == 'IDAT'</span>
<a href="#l16.1875"></a><span id="l16.1875" class="difflineplus">+                # http://www.w3.org/TR/PNG/#11IDAT</span>
<a href="#l16.1876"></a><span id="l16.1876" class="difflineplus">+                if self.colormap and not self.plte:</span>
<a href="#l16.1877"></a><span id="l16.1877" class="difflineplus">+                    warnings.warn(&quot;PLTE chunk is required before IDAT chunk&quot;)</span>
<a href="#l16.1878"></a><span id="l16.1878" class="difflineplus">+                yield data</span>
<a href="#l16.1879"></a><span id="l16.1879" class="difflineplus">+</span>
<a href="#l16.1880"></a><span id="l16.1880" class="difflineplus">+        def iterdecomp(idat):</span>
<a href="#l16.1881"></a><span id="l16.1881" class="difflineplus">+            &quot;&quot;&quot;Iterator that yields decompressed strings.  `idat` should</span>
<a href="#l16.1882"></a><span id="l16.1882" class="difflineplus">+            be an iterator that yields the ``IDAT`` chunk data.</span>
<a href="#l16.1883"></a><span id="l16.1883" class="difflineplus">+            &quot;&quot;&quot;</span>
<a href="#l16.1884"></a><span id="l16.1884" class="difflineplus">+</span>
<a href="#l16.1885"></a><span id="l16.1885" class="difflineplus">+            # Currently, with no max_length paramter to decompress, this</span>
<a href="#l16.1886"></a><span id="l16.1886" class="difflineplus">+            # routine will do one yield per IDAT chunk.  So not very</span>
<a href="#l16.1887"></a><span id="l16.1887" class="difflineplus">+            # incremental.</span>
<a href="#l16.1888"></a><span id="l16.1888" class="difflineplus">+            d = zlib.decompressobj()</span>
<a href="#l16.1889"></a><span id="l16.1889" class="difflineplus">+            # Each IDAT chunk is passed to the decompressor, then any</span>
<a href="#l16.1890"></a><span id="l16.1890" class="difflineplus">+            # remaining state is decompressed out.</span>
<a href="#l16.1891"></a><span id="l16.1891" class="difflineplus">+            for data in idat:</span>
<a href="#l16.1892"></a><span id="l16.1892" class="difflineplus">+                # :todo: add a max_length argument here to limit output</span>
<a href="#l16.1893"></a><span id="l16.1893" class="difflineplus">+                # size.</span>
<a href="#l16.1894"></a><span id="l16.1894" class="difflineplus">+                yield array('B', d.decompress(data))</span>
<a href="#l16.1895"></a><span id="l16.1895" class="difflineplus">+            yield array('B', d.flush())</span>
<a href="#l16.1896"></a><span id="l16.1896" class="difflineplus">+</span>
<a href="#l16.1897"></a><span id="l16.1897" class="difflineplus">+        self.preamble()</span>
<a href="#l16.1898"></a><span id="l16.1898" class="difflineplus">+        raw = iterdecomp(iteridat())</span>
<a href="#l16.1899"></a><span id="l16.1899" class="difflineplus">+</span>
<a href="#l16.1900"></a><span id="l16.1900" class="difflineplus">+        if self.interlace:</span>
<a href="#l16.1901"></a><span id="l16.1901" class="difflineplus">+            raw = array('B', itertools.chain(*raw))</span>
<a href="#l16.1902"></a><span id="l16.1902" class="difflineplus">+            arraycode = 'BH'[self.bitdepth&gt;8]</span>
<a href="#l16.1903"></a><span id="l16.1903" class="difflineplus">+            # Like :meth:`group` but producing an array.array object for</span>
<a href="#l16.1904"></a><span id="l16.1904" class="difflineplus">+            # each row.</span>
<a href="#l16.1905"></a><span id="l16.1905" class="difflineplus">+            pixels = itertools.imap(lambda *row: array(arraycode, row),</span>
<a href="#l16.1906"></a><span id="l16.1906" class="difflineplus">+                       *[iter(self.deinterlace(raw))]*self.width*self.planes)</span>
<a href="#l16.1907"></a><span id="l16.1907" class="difflineplus">+        else:</span>
<a href="#l16.1908"></a><span id="l16.1908" class="difflineplus">+            pixels = self.iterboxed(self.iterstraight(raw))</span>
<a href="#l16.1909"></a><span id="l16.1909" class="difflineplus">+        meta = dict()</span>
<a href="#l16.1910"></a><span id="l16.1910" class="difflineplus">+        for attr in 'greyscale alpha planes bitdepth interlace'.split():</span>
<a href="#l16.1911"></a><span id="l16.1911" class="difflineplus">+            meta[attr] = getattr(self, attr)</span>
<a href="#l16.1912"></a><span id="l16.1912" class="difflineplus">+        meta['size'] = (self.width, self.height)</span>
<a href="#l16.1913"></a><span id="l16.1913" class="difflineplus">+        for attr in 'gamma transparent background'.split():</span>
<a href="#l16.1914"></a><span id="l16.1914" class="difflineplus">+            a = getattr(self, attr, None)</span>
<a href="#l16.1915"></a><span id="l16.1915" class="difflineplus">+            if a is not None:</span>
<a href="#l16.1916"></a><span id="l16.1916" class="difflineplus">+                meta[attr] = a</span>
<a href="#l16.1917"></a><span id="l16.1917" class="difflineplus">+        return self.width, self.height, pixels, meta</span>
<a href="#l16.1918"></a><span id="l16.1918" class="difflineplus">+</span>
<a href="#l16.1919"></a><span id="l16.1919" class="difflineplus">+</span>
<a href="#l16.1920"></a><span id="l16.1920" class="difflineplus">+    def read_flat(self):</span>
<a href="#l16.1921"></a><span id="l16.1921" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1922"></a><span id="l16.1922" class="difflineplus">+        Read a PNG file and decode it into flat row flat pixel format.</span>
<a href="#l16.1923"></a><span id="l16.1923" class="difflineplus">+        Returns (*width*, *height*, *pixels*, *metadata*).</span>
<a href="#l16.1924"></a><span id="l16.1924" class="difflineplus">+</span>
<a href="#l16.1925"></a><span id="l16.1925" class="difflineplus">+        May use excessive memory.</span>
<a href="#l16.1926"></a><span id="l16.1926" class="difflineplus">+</span>
<a href="#l16.1927"></a><span id="l16.1927" class="difflineplus">+        `pixels` are returned in flat row flat pixel format.</span>
<a href="#l16.1928"></a><span id="l16.1928" class="difflineplus">+</span>
<a href="#l16.1929"></a><span id="l16.1929" class="difflineplus">+        See also the :meth:`read` method which returns pixels in the</span>
<a href="#l16.1930"></a><span id="l16.1930" class="difflineplus">+        more stream-friendly boxed row flat pixel format.</span>
<a href="#l16.1931"></a><span id="l16.1931" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1932"></a><span id="l16.1932" class="difflineplus">+</span>
<a href="#l16.1933"></a><span id="l16.1933" class="difflineplus">+        x, y, pixel, meta = self.read()</span>
<a href="#l16.1934"></a><span id="l16.1934" class="difflineplus">+        arraycode = 'BH'[meta['bitdepth']&gt;8]</span>
<a href="#l16.1935"></a><span id="l16.1935" class="difflineplus">+        pixel = array(arraycode, itertools.chain(*pixel))</span>
<a href="#l16.1936"></a><span id="l16.1936" class="difflineplus">+        return x, y, pixel, meta</span>
<a href="#l16.1937"></a><span id="l16.1937" class="difflineplus">+</span>
<a href="#l16.1938"></a><span id="l16.1938" class="difflineplus">+    def palette(self, alpha='natural'):</span>
<a href="#l16.1939"></a><span id="l16.1939" class="difflineplus">+        &quot;&quot;&quot;Returns a palette that is a sequence of 3-tuples or 4-tuples,</span>
<a href="#l16.1940"></a><span id="l16.1940" class="difflineplus">+        synthesizing it from the ``PLTE`` and ``tRNS`` chunks.  These</span>
<a href="#l16.1941"></a><span id="l16.1941" class="difflineplus">+        chunks should have already been processed (for example, by</span>
<a href="#l16.1942"></a><span id="l16.1942" class="difflineplus">+        calling the :meth:`preamble` method).  All the tuples are the</span>
<a href="#l16.1943"></a><span id="l16.1943" class="difflineplus">+        same size: 3-tuples if there is no ``tRNS`` chunk, 4-tuples when</span>
<a href="#l16.1944"></a><span id="l16.1944" class="difflineplus">+        there is a ``tRNS`` chunk.  Assumes that the image is colour type</span>
<a href="#l16.1945"></a><span id="l16.1945" class="difflineplus">+        3 and therefore a ``PLTE`` chunk is required.</span>
<a href="#l16.1946"></a><span id="l16.1946" class="difflineplus">+</span>
<a href="#l16.1947"></a><span id="l16.1947" class="difflineplus">+        If the `alpha` argument is ``'force'`` then an alpha channel is</span>
<a href="#l16.1948"></a><span id="l16.1948" class="difflineplus">+        always added, forcing the result to be a sequence of 4-tuples.</span>
<a href="#l16.1949"></a><span id="l16.1949" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1950"></a><span id="l16.1950" class="difflineplus">+</span>
<a href="#l16.1951"></a><span id="l16.1951" class="difflineplus">+        if not self.plte:</span>
<a href="#l16.1952"></a><span id="l16.1952" class="difflineplus">+            raise FormatError(</span>
<a href="#l16.1953"></a><span id="l16.1953" class="difflineplus">+                &quot;Required PLTE chunk is missing in colour type 3 image.&quot;)</span>
<a href="#l16.1954"></a><span id="l16.1954" class="difflineplus">+        plte = group(array('B', self.plte), 3)</span>
<a href="#l16.1955"></a><span id="l16.1955" class="difflineplus">+        if self.trns or alpha == 'force':</span>
<a href="#l16.1956"></a><span id="l16.1956" class="difflineplus">+            trns = array('B', self.trns or '')</span>
<a href="#l16.1957"></a><span id="l16.1957" class="difflineplus">+            trns.extend([255]*(len(plte)-len(trns)))</span>
<a href="#l16.1958"></a><span id="l16.1958" class="difflineplus">+            plte = map(operator.add, plte, group(trns, 1))</span>
<a href="#l16.1959"></a><span id="l16.1959" class="difflineplus">+        return plte</span>
<a href="#l16.1960"></a><span id="l16.1960" class="difflineplus">+</span>
<a href="#l16.1961"></a><span id="l16.1961" class="difflineplus">+    def asDirect(self):</span>
<a href="#l16.1962"></a><span id="l16.1962" class="difflineplus">+        &quot;&quot;&quot;Returns the image data as a direct representation of an</span>
<a href="#l16.1963"></a><span id="l16.1963" class="difflineplus">+        ``x * y * planes`` array.  This method is intended to remove the</span>
<a href="#l16.1964"></a><span id="l16.1964" class="difflineplus">+        need for callers to deal with palettes and transparency</span>
<a href="#l16.1965"></a><span id="l16.1965" class="difflineplus">+        themselves.  Images with a palette (colour type 3)</span>
<a href="#l16.1966"></a><span id="l16.1966" class="difflineplus">+        are converted to RGB or RGBA; images with transparency (a</span>
<a href="#l16.1967"></a><span id="l16.1967" class="difflineplus">+        ``tRNS`` chunk) are converted to LA or RGBA as appropriate.</span>
<a href="#l16.1968"></a><span id="l16.1968" class="difflineplus">+        When returned in this format the pixel values represent the</span>
<a href="#l16.1969"></a><span id="l16.1969" class="difflineplus">+        colour value directly without needing to refer to palettes or</span>
<a href="#l16.1970"></a><span id="l16.1970" class="difflineplus">+        transparency information.</span>
<a href="#l16.1971"></a><span id="l16.1971" class="difflineplus">+</span>
<a href="#l16.1972"></a><span id="l16.1972" class="difflineplus">+        Like the :meth:`read` method this method returns a 4-tuple:</span>
<a href="#l16.1973"></a><span id="l16.1973" class="difflineplus">+</span>
<a href="#l16.1974"></a><span id="l16.1974" class="difflineplus">+        (*width*, *height*, *pixels*, *meta*)</span>
<a href="#l16.1975"></a><span id="l16.1975" class="difflineplus">+</span>
<a href="#l16.1976"></a><span id="l16.1976" class="difflineplus">+        This method normally returns pixel values with the bit depth</span>
<a href="#l16.1977"></a><span id="l16.1977" class="difflineplus">+        they have in the source image, but when the source PNG has an</span>
<a href="#l16.1978"></a><span id="l16.1978" class="difflineplus">+        ``sBIT`` chunk it is inspected and can reduce the bit depth of</span>
<a href="#l16.1979"></a><span id="l16.1979" class="difflineplus">+        the result pixels; pixel values will be reduced according to</span>
<a href="#l16.1980"></a><span id="l16.1980" class="difflineplus">+        the bit depth specified in the ``sBIT`` chunk (PNG nerds should</span>
<a href="#l16.1981"></a><span id="l16.1981" class="difflineplus">+        note a single result bit depth is used for all channels; the</span>
<a href="#l16.1982"></a><span id="l16.1982" class="difflineplus">+        maximum of the ones specified in the ``sBIT`` chunk.  An RGB565</span>
<a href="#l16.1983"></a><span id="l16.1983" class="difflineplus">+        image will be rescaled to 6-bit RGB666).</span>
<a href="#l16.1984"></a><span id="l16.1984" class="difflineplus">+</span>
<a href="#l16.1985"></a><span id="l16.1985" class="difflineplus">+        The *meta* dictionary that is returned reflects the `direct`</span>
<a href="#l16.1986"></a><span id="l16.1986" class="difflineplus">+        format and not the original source image.  For example, an RGB</span>
<a href="#l16.1987"></a><span id="l16.1987" class="difflineplus">+        source image with a ``tRNS`` chunk to represent a transparent</span>
<a href="#l16.1988"></a><span id="l16.1988" class="difflineplus">+        colour, will have ``planes=3`` and ``alpha=False`` for the</span>
<a href="#l16.1989"></a><span id="l16.1989" class="difflineplus">+        source image, but the *meta* dictionary returned by this method</span>
<a href="#l16.1990"></a><span id="l16.1990" class="difflineplus">+        will have ``planes=4`` and ``alpha=True`` because an alpha</span>
<a href="#l16.1991"></a><span id="l16.1991" class="difflineplus">+        channel is synthesized and added.</span>
<a href="#l16.1992"></a><span id="l16.1992" class="difflineplus">+</span>
<a href="#l16.1993"></a><span id="l16.1993" class="difflineplus">+        *pixels* is the pixel data in boxed row flat pixel format (just</span>
<a href="#l16.1994"></a><span id="l16.1994" class="difflineplus">+        like the :meth:`read` method).</span>
<a href="#l16.1995"></a><span id="l16.1995" class="difflineplus">+</span>
<a href="#l16.1996"></a><span id="l16.1996" class="difflineplus">+        All the other aspects of the image data are not changed.</span>
<a href="#l16.1997"></a><span id="l16.1997" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.1998"></a><span id="l16.1998" class="difflineplus">+</span>
<a href="#l16.1999"></a><span id="l16.1999" class="difflineplus">+        self.preamble()</span>
<a href="#l16.2000"></a><span id="l16.2000" class="difflineplus">+</span>
<a href="#l16.2001"></a><span id="l16.2001" class="difflineplus">+        # Simple case, no conversion necessary.</span>
<a href="#l16.2002"></a><span id="l16.2002" class="difflineplus">+        if not self.colormap and not self.trns and not self.sbit:</span>
<a href="#l16.2003"></a><span id="l16.2003" class="difflineplus">+            return self.read()</span>
<a href="#l16.2004"></a><span id="l16.2004" class="difflineplus">+</span>
<a href="#l16.2005"></a><span id="l16.2005" class="difflineplus">+        x,y,pixels,meta = self.read()</span>
<a href="#l16.2006"></a><span id="l16.2006" class="difflineplus">+</span>
<a href="#l16.2007"></a><span id="l16.2007" class="difflineplus">+        if self.colormap:</span>
<a href="#l16.2008"></a><span id="l16.2008" class="difflineplus">+            meta['colormap'] = False</span>
<a href="#l16.2009"></a><span id="l16.2009" class="difflineplus">+            meta['alpha'] = bool(self.trns)</span>
<a href="#l16.2010"></a><span id="l16.2010" class="difflineplus">+            meta['bitdepth'] = 8</span>
<a href="#l16.2011"></a><span id="l16.2011" class="difflineplus">+            meta['planes'] = 3 + bool(self.trns)</span>
<a href="#l16.2012"></a><span id="l16.2012" class="difflineplus">+            plte = self.palette()</span>
<a href="#l16.2013"></a><span id="l16.2013" class="difflineplus">+            def iterpal(pixels):</span>
<a href="#l16.2014"></a><span id="l16.2014" class="difflineplus">+                for row in pixels:</span>
<a href="#l16.2015"></a><span id="l16.2015" class="difflineplus">+                    row = map(plte.__getitem__, row)</span>
<a href="#l16.2016"></a><span id="l16.2016" class="difflineplus">+                    yield array('B', itertools.chain(*row))</span>
<a href="#l16.2017"></a><span id="l16.2017" class="difflineplus">+            pixels = iterpal(pixels)</span>
<a href="#l16.2018"></a><span id="l16.2018" class="difflineplus">+        elif self.trns:</span>
<a href="#l16.2019"></a><span id="l16.2019" class="difflineplus">+            # It would be nice if there was some reasonable way of doing</span>
<a href="#l16.2020"></a><span id="l16.2020" class="difflineplus">+            # this without generating a whole load of intermediate tuples.</span>
<a href="#l16.2021"></a><span id="l16.2021" class="difflineplus">+            # But tuples does seem like the easiest way, with no other way</span>
<a href="#l16.2022"></a><span id="l16.2022" class="difflineplus">+            # clearly much simpler or much faster.  (Actually, the L to LA</span>
<a href="#l16.2023"></a><span id="l16.2023" class="difflineplus">+            # conversion could perhaps go faster (all those 1-tuples!), but</span>
<a href="#l16.2024"></a><span id="l16.2024" class="difflineplus">+            # I still wonder whether the code proliferation is worth it)</span>
<a href="#l16.2025"></a><span id="l16.2025" class="difflineplus">+            it = self.transparent</span>
<a href="#l16.2026"></a><span id="l16.2026" class="difflineplus">+            maxval = 2**meta['bitdepth']-1</span>
<a href="#l16.2027"></a><span id="l16.2027" class="difflineplus">+            planes = meta['planes']</span>
<a href="#l16.2028"></a><span id="l16.2028" class="difflineplus">+            meta['alpha'] = True</span>
<a href="#l16.2029"></a><span id="l16.2029" class="difflineplus">+            meta['planes'] += 1</span>
<a href="#l16.2030"></a><span id="l16.2030" class="difflineplus">+            typecode = 'BH'[meta['bitdepth']&gt;8]</span>
<a href="#l16.2031"></a><span id="l16.2031" class="difflineplus">+            def itertrns(pixels):</span>
<a href="#l16.2032"></a><span id="l16.2032" class="difflineplus">+                for row in pixels:</span>
<a href="#l16.2033"></a><span id="l16.2033" class="difflineplus">+                    # For each row we group it into pixels, then form a</span>
<a href="#l16.2034"></a><span id="l16.2034" class="difflineplus">+                    # characterisation vector that says whether each pixel</span>
<a href="#l16.2035"></a><span id="l16.2035" class="difflineplus">+                    # is opaque or not.  Then we convert True/False to</span>
<a href="#l16.2036"></a><span id="l16.2036" class="difflineplus">+                    # 0/maxval (by multiplication), and add it as the extra</span>
<a href="#l16.2037"></a><span id="l16.2037" class="difflineplus">+                    # channel.</span>
<a href="#l16.2038"></a><span id="l16.2038" class="difflineplus">+                    row = group(row, planes)</span>
<a href="#l16.2039"></a><span id="l16.2039" class="difflineplus">+                    opa = map(it.__ne__, row)</span>
<a href="#l16.2040"></a><span id="l16.2040" class="difflineplus">+                    opa = map(maxval.__mul__, opa)</span>
<a href="#l16.2041"></a><span id="l16.2041" class="difflineplus">+                    opa = zip(opa) # convert to 1-tuples</span>
<a href="#l16.2042"></a><span id="l16.2042" class="difflineplus">+                    yield array(typecode,</span>
<a href="#l16.2043"></a><span id="l16.2043" class="difflineplus">+                      itertools.chain(*map(operator.add, row, opa)))</span>
<a href="#l16.2044"></a><span id="l16.2044" class="difflineplus">+            pixels = itertrns(pixels)</span>
<a href="#l16.2045"></a><span id="l16.2045" class="difflineplus">+        targetbitdepth = None</span>
<a href="#l16.2046"></a><span id="l16.2046" class="difflineplus">+        if self.sbit:</span>
<a href="#l16.2047"></a><span id="l16.2047" class="difflineplus">+            sbit = struct.unpack('%dB' % len(self.sbit), self.sbit)</span>
<a href="#l16.2048"></a><span id="l16.2048" class="difflineplus">+            targetbitdepth = max(sbit)</span>
<a href="#l16.2049"></a><span id="l16.2049" class="difflineplus">+            if targetbitdepth &gt; meta['bitdepth']:</span>
<a href="#l16.2050"></a><span id="l16.2050" class="difflineplus">+                raise Error('sBIT chunk %r exceeds bitdepth %d' %</span>
<a href="#l16.2051"></a><span id="l16.2051" class="difflineplus">+                    (sbit,self.bitdepth))</span>
<a href="#l16.2052"></a><span id="l16.2052" class="difflineplus">+            if min(sbit) &lt;= 0:</span>
<a href="#l16.2053"></a><span id="l16.2053" class="difflineplus">+                raise Error('sBIT chunk %r has a 0-entry' % sbit)</span>
<a href="#l16.2054"></a><span id="l16.2054" class="difflineplus">+            if targetbitdepth == meta['bitdepth']:</span>
<a href="#l16.2055"></a><span id="l16.2055" class="difflineplus">+                targetbitdepth = None</span>
<a href="#l16.2056"></a><span id="l16.2056" class="difflineplus">+        if targetbitdepth:</span>
<a href="#l16.2057"></a><span id="l16.2057" class="difflineplus">+            shift = meta['bitdepth'] - targetbitdepth</span>
<a href="#l16.2058"></a><span id="l16.2058" class="difflineplus">+            meta['bitdepth'] = targetbitdepth</span>
<a href="#l16.2059"></a><span id="l16.2059" class="difflineplus">+            def itershift(pixels):</span>
<a href="#l16.2060"></a><span id="l16.2060" class="difflineplus">+                for row in pixels:</span>
<a href="#l16.2061"></a><span id="l16.2061" class="difflineplus">+                    yield map(shift.__rrshift__, row)</span>
<a href="#l16.2062"></a><span id="l16.2062" class="difflineplus">+            pixels = itershift(pixels)</span>
<a href="#l16.2063"></a><span id="l16.2063" class="difflineplus">+        return x,y,pixels,meta</span>
<a href="#l16.2064"></a><span id="l16.2064" class="difflineplus">+</span>
<a href="#l16.2065"></a><span id="l16.2065" class="difflineplus">+    def asFloat(self, maxval=1.0):</span>
<a href="#l16.2066"></a><span id="l16.2066" class="difflineplus">+        &quot;&quot;&quot;Return image pixels as per :meth:`asDirect` method, but scale</span>
<a href="#l16.2067"></a><span id="l16.2067" class="difflineplus">+        all pixel values to be floating point values between 0.0 and</span>
<a href="#l16.2068"></a><span id="l16.2068" class="difflineplus">+        *maxval*.</span>
<a href="#l16.2069"></a><span id="l16.2069" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.2070"></a><span id="l16.2070" class="difflineplus">+</span>
<a href="#l16.2071"></a><span id="l16.2071" class="difflineplus">+        x,y,pixels,info = self.asDirect()</span>
<a href="#l16.2072"></a><span id="l16.2072" class="difflineplus">+        sourcemaxval = 2**info['bitdepth']-1</span>
<a href="#l16.2073"></a><span id="l16.2073" class="difflineplus">+        del info['bitdepth']</span>
<a href="#l16.2074"></a><span id="l16.2074" class="difflineplus">+        info['maxval'] = float(maxval)</span>
<a href="#l16.2075"></a><span id="l16.2075" class="difflineplus">+        factor = float(maxval)/float(sourcemaxval)</span>
<a href="#l16.2076"></a><span id="l16.2076" class="difflineplus">+        def iterfloat():</span>
<a href="#l16.2077"></a><span id="l16.2077" class="difflineplus">+            for row in pixels:</span>
<a href="#l16.2078"></a><span id="l16.2078" class="difflineplus">+                yield map(factor.__mul__, row)</span>
<a href="#l16.2079"></a><span id="l16.2079" class="difflineplus">+        return x,y,iterfloat(),info</span>
<a href="#l16.2080"></a><span id="l16.2080" class="difflineplus">+</span>
<a href="#l16.2081"></a><span id="l16.2081" class="difflineplus">+    def _as_rescale(self, get, targetbitdepth):</span>
<a href="#l16.2082"></a><span id="l16.2082" class="difflineplus">+        &quot;&quot;&quot;Helper used by :meth:`asRGB8` and :meth:`asRGBA8`.&quot;&quot;&quot;</span>
<a href="#l16.2083"></a><span id="l16.2083" class="difflineplus">+</span>
<a href="#l16.2084"></a><span id="l16.2084" class="difflineplus">+        width,height,pixels,meta = get()</span>
<a href="#l16.2085"></a><span id="l16.2085" class="difflineplus">+        maxval = 2**meta['bitdepth'] - 1</span>
<a href="#l16.2086"></a><span id="l16.2086" class="difflineplus">+        targetmaxval = 2**targetbitdepth - 1</span>
<a href="#l16.2087"></a><span id="l16.2087" class="difflineplus">+        factor = float(targetmaxval) / float(maxval)</span>
<a href="#l16.2088"></a><span id="l16.2088" class="difflineplus">+        meta['bitdepth'] = targetbitdepth</span>
<a href="#l16.2089"></a><span id="l16.2089" class="difflineplus">+        def iterscale():</span>
<a href="#l16.2090"></a><span id="l16.2090" class="difflineplus">+            for row in pixels:</span>
<a href="#l16.2091"></a><span id="l16.2091" class="difflineplus">+                yield map(lambda x: int(round(x*factor)), row)</span>
<a href="#l16.2092"></a><span id="l16.2092" class="difflineplus">+        return width, height, iterscale(), meta</span>
<a href="#l16.2093"></a><span id="l16.2093" class="difflineplus">+</span>
<a href="#l16.2094"></a><span id="l16.2094" class="difflineplus">+    def asRGB8(self):</span>
<a href="#l16.2095"></a><span id="l16.2095" class="difflineplus">+        &quot;&quot;&quot;Return the image data as an RGB pixels with 8-bits per</span>
<a href="#l16.2096"></a><span id="l16.2096" class="difflineplus">+        sample.  This is like the :meth:`asRGB` method except that</span>
<a href="#l16.2097"></a><span id="l16.2097" class="difflineplus">+        this method additionally rescales the values so that they</span>
<a href="#l16.2098"></a><span id="l16.2098" class="difflineplus">+        are all between 0 and 255 (8-bit).  In the case where the</span>
<a href="#l16.2099"></a><span id="l16.2099" class="difflineplus">+        source image has a bit depth &lt; 8 the transformation preserves</span>
<a href="#l16.2100"></a><span id="l16.2100" class="difflineplus">+        all the information; where the source image has bit depth</span>
<a href="#l16.2101"></a><span id="l16.2101" class="difflineplus">+        &gt; 8, then rescaling to 8-bit values loses precision.  No</span>
<a href="#l16.2102"></a><span id="l16.2102" class="difflineplus">+        dithering is performed.  Like :meth:`asRGB`, an alpha channel</span>
<a href="#l16.2103"></a><span id="l16.2103" class="difflineplus">+        in the source image will raise an exception.</span>
<a href="#l16.2104"></a><span id="l16.2104" class="difflineplus">+</span>
<a href="#l16.2105"></a><span id="l16.2105" class="difflineplus">+        This function returns a 4-tuple:</span>
<a href="#l16.2106"></a><span id="l16.2106" class="difflineplus">+        (*width*, *height*, *pixels*, *metadata*).</span>
<a href="#l16.2107"></a><span id="l16.2107" class="difflineplus">+        *width*, *height*, *metadata* are as per the :meth:`read` method.</span>
<a href="#l16.2108"></a><span id="l16.2108" class="difflineplus">+        </span>
<a href="#l16.2109"></a><span id="l16.2109" class="difflineplus">+        *pixels* is the pixel data in boxed row flat pixel format.</span>
<a href="#l16.2110"></a><span id="l16.2110" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.2111"></a><span id="l16.2111" class="difflineplus">+</span>
<a href="#l16.2112"></a><span id="l16.2112" class="difflineplus">+        return self._as_rescale(self.asRGB, 8)</span>
<a href="#l16.2113"></a><span id="l16.2113" class="difflineplus">+</span>
<a href="#l16.2114"></a><span id="l16.2114" class="difflineplus">+    def asRGBA8(self):</span>
<a href="#l16.2115"></a><span id="l16.2115" class="difflineplus">+        &quot;&quot;&quot;Return the image data as RGBA pixels with 8-bits per</span>
<a href="#l16.2116"></a><span id="l16.2116" class="difflineplus">+        sample.  This method is similar to :meth:`asRGB8` and</span>
<a href="#l16.2117"></a><span id="l16.2117" class="difflineplus">+        :meth:`asRGBA`:  The result pixels have an alpha channel, *and*</span>
<a href="#l16.2118"></a><span id="l16.2118" class="difflineplus">+        values are rescaled to the range 0 to 255.  The alpha channel is</span>
<a href="#l16.2119"></a><span id="l16.2119" class="difflineplus">+        synthesized if necessary (with a small speed penalty).</span>
<a href="#l16.2120"></a><span id="l16.2120" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.2121"></a><span id="l16.2121" class="difflineplus">+</span>
<a href="#l16.2122"></a><span id="l16.2122" class="difflineplus">+        return self._as_rescale(self.asRGBA, 8)</span>
<a href="#l16.2123"></a><span id="l16.2123" class="difflineplus">+</span>
<a href="#l16.2124"></a><span id="l16.2124" class="difflineplus">+    def asRGB(self):</span>
<a href="#l16.2125"></a><span id="l16.2125" class="difflineplus">+        &quot;&quot;&quot;Return image as RGB pixels.  RGB colour images are passed</span>
<a href="#l16.2126"></a><span id="l16.2126" class="difflineplus">+        through unchanged; greyscales are expanded into RGB</span>
<a href="#l16.2127"></a><span id="l16.2127" class="difflineplus">+        triplets (there is a small speed overhead for doing this).</span>
<a href="#l16.2128"></a><span id="l16.2128" class="difflineplus">+</span>
<a href="#l16.2129"></a><span id="l16.2129" class="difflineplus">+        An alpha channel in the source image will raise an</span>
<a href="#l16.2130"></a><span id="l16.2130" class="difflineplus">+        exception.</span>
<a href="#l16.2131"></a><span id="l16.2131" class="difflineplus">+</span>
<a href="#l16.2132"></a><span id="l16.2132" class="difflineplus">+        The return values are as for the :meth:`read` method</span>
<a href="#l16.2133"></a><span id="l16.2133" class="difflineplus">+        except that the *metadata* reflect the returned pixels, not the</span>
<a href="#l16.2134"></a><span id="l16.2134" class="difflineplus">+        source image.  In particular, for this method</span>
<a href="#l16.2135"></a><span id="l16.2135" class="difflineplus">+        ``metadata['greyscale']`` will be ``False``.</span>
<a href="#l16.2136"></a><span id="l16.2136" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.2137"></a><span id="l16.2137" class="difflineplus">+</span>
<a href="#l16.2138"></a><span id="l16.2138" class="difflineplus">+        width,height,pixels,meta = self.asDirect()</span>
<a href="#l16.2139"></a><span id="l16.2139" class="difflineplus">+        if meta['alpha']:</span>
<a href="#l16.2140"></a><span id="l16.2140" class="difflineplus">+            raise Error(&quot;will not convert image with alpha channel to RGB&quot;)</span>
<a href="#l16.2141"></a><span id="l16.2141" class="difflineplus">+        if not meta['greyscale']:</span>
<a href="#l16.2142"></a><span id="l16.2142" class="difflineplus">+            return width,height,pixels,meta</span>
<a href="#l16.2143"></a><span id="l16.2143" class="difflineplus">+        meta['greyscale'] = False</span>
<a href="#l16.2144"></a><span id="l16.2144" class="difflineplus">+        typecode = 'BH'[meta['bitdepth'] &gt; 8]</span>
<a href="#l16.2145"></a><span id="l16.2145" class="difflineplus">+        def iterrgb():</span>
<a href="#l16.2146"></a><span id="l16.2146" class="difflineplus">+            for row in pixels:</span>
<a href="#l16.2147"></a><span id="l16.2147" class="difflineplus">+                a = array(typecode, [0]) * 3 * width</span>
<a href="#l16.2148"></a><span id="l16.2148" class="difflineplus">+                for i in range(3):</span>
<a href="#l16.2149"></a><span id="l16.2149" class="difflineplus">+                    a[i::3] = row</span>
<a href="#l16.2150"></a><span id="l16.2150" class="difflineplus">+                yield a</span>
<a href="#l16.2151"></a><span id="l16.2151" class="difflineplus">+        return width,height,iterrgb(),meta</span>
<a href="#l16.2152"></a><span id="l16.2152" class="difflineplus">+</span>
<a href="#l16.2153"></a><span id="l16.2153" class="difflineplus">+    def asRGBA(self):</span>
<a href="#l16.2154"></a><span id="l16.2154" class="difflineplus">+        &quot;&quot;&quot;Return image as RGBA pixels.  Greyscales are expanded into</span>
<a href="#l16.2155"></a><span id="l16.2155" class="difflineplus">+        RGB triplets; an alpha channel is synthesized if necessary.</span>
<a href="#l16.2156"></a><span id="l16.2156" class="difflineplus">+        The return values are as for the :meth:`read` method</span>
<a href="#l16.2157"></a><span id="l16.2157" class="difflineplus">+        except that the *metadata* reflect the returned pixels, not the</span>
<a href="#l16.2158"></a><span id="l16.2158" class="difflineplus">+        source image.  In particular, for this method</span>
<a href="#l16.2159"></a><span id="l16.2159" class="difflineplus">+        ``metadata['greyscale']`` will be ``False``, and</span>
<a href="#l16.2160"></a><span id="l16.2160" class="difflineplus">+        ``metadata['alpha']`` will be ``True``.</span>
<a href="#l16.2161"></a><span id="l16.2161" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.2162"></a><span id="l16.2162" class="difflineplus">+</span>
<a href="#l16.2163"></a><span id="l16.2163" class="difflineplus">+        width,height,pixels,meta = self.asDirect()</span>
<a href="#l16.2164"></a><span id="l16.2164" class="difflineplus">+        if meta['alpha'] and not meta['greyscale']:</span>
<a href="#l16.2165"></a><span id="l16.2165" class="difflineplus">+            return width,height,pixels,meta</span>
<a href="#l16.2166"></a><span id="l16.2166" class="difflineplus">+        typecode = 'BH'[meta['bitdepth'] &gt; 8]</span>
<a href="#l16.2167"></a><span id="l16.2167" class="difflineplus">+        maxval = 2**meta['bitdepth'] - 1</span>
<a href="#l16.2168"></a><span id="l16.2168" class="difflineplus">+        def newarray():</span>
<a href="#l16.2169"></a><span id="l16.2169" class="difflineplus">+            return array(typecode, [0]) * 4 * width</span>
<a href="#l16.2170"></a><span id="l16.2170" class="difflineplus">+        if meta['alpha'] and meta['greyscale']:</span>
<a href="#l16.2171"></a><span id="l16.2171" class="difflineplus">+            # LA to RGBA</span>
<a href="#l16.2172"></a><span id="l16.2172" class="difflineplus">+            def convert():</span>
<a href="#l16.2173"></a><span id="l16.2173" class="difflineplus">+                for row in pixels:</span>
<a href="#l16.2174"></a><span id="l16.2174" class="difflineplus">+                    # Create a fresh target row, then copy L channel</span>
<a href="#l16.2175"></a><span id="l16.2175" class="difflineplus">+                    # into first three target channels, and A channel</span>
<a href="#l16.2176"></a><span id="l16.2176" class="difflineplus">+                    # into fourth channel.</span>
<a href="#l16.2177"></a><span id="l16.2177" class="difflineplus">+                    a = newarray()</span>
<a href="#l16.2178"></a><span id="l16.2178" class="difflineplus">+                    for i in range(3):</span>
<a href="#l16.2179"></a><span id="l16.2179" class="difflineplus">+                        a[i::4] = row[0::2]</span>
<a href="#l16.2180"></a><span id="l16.2180" class="difflineplus">+                    a[3::4] = row[1::2]</span>
<a href="#l16.2181"></a><span id="l16.2181" class="difflineplus">+                    yield a</span>
<a href="#l16.2182"></a><span id="l16.2182" class="difflineplus">+        elif meta['greyscale']:</span>
<a href="#l16.2183"></a><span id="l16.2183" class="difflineplus">+            # L to RGBA</span>
<a href="#l16.2184"></a><span id="l16.2184" class="difflineplus">+            def convert():</span>
<a href="#l16.2185"></a><span id="l16.2185" class="difflineplus">+                for row in pixels:</span>
<a href="#l16.2186"></a><span id="l16.2186" class="difflineplus">+                    a = newarray()</span>
<a href="#l16.2187"></a><span id="l16.2187" class="difflineplus">+                    for i in range(3):</span>
<a href="#l16.2188"></a><span id="l16.2188" class="difflineplus">+                        a[i::4] = row</span>
<a href="#l16.2189"></a><span id="l16.2189" class="difflineplus">+                    a[3::4] = array(typecode, [maxval]) * width</span>
<a href="#l16.2190"></a><span id="l16.2190" class="difflineplus">+                    yield a</span>
<a href="#l16.2191"></a><span id="l16.2191" class="difflineplus">+        else:</span>
<a href="#l16.2192"></a><span id="l16.2192" class="difflineplus">+            assert not meta['alpha'] and not meta['greyscale']</span>
<a href="#l16.2193"></a><span id="l16.2193" class="difflineplus">+            # RGB to RGBA</span>
<a href="#l16.2194"></a><span id="l16.2194" class="difflineplus">+            def convert():</span>
<a href="#l16.2195"></a><span id="l16.2195" class="difflineplus">+                for row in pixels:</span>
<a href="#l16.2196"></a><span id="l16.2196" class="difflineplus">+                    a = newarray()</span>
<a href="#l16.2197"></a><span id="l16.2197" class="difflineplus">+                    for i in range(3):</span>
<a href="#l16.2198"></a><span id="l16.2198" class="difflineplus">+                        a[i::4] = row[i::3]</span>
<a href="#l16.2199"></a><span id="l16.2199" class="difflineplus">+                    a[3::4] = array(typecode, [maxval]) * width</span>
<a href="#l16.2200"></a><span id="l16.2200" class="difflineplus">+                    yield a</span>
<a href="#l16.2201"></a><span id="l16.2201" class="difflineplus">+        meta['alpha'] = True</span>
<a href="#l16.2202"></a><span id="l16.2202" class="difflineplus">+        meta['greyscale'] = False</span>
<a href="#l16.2203"></a><span id="l16.2203" class="difflineplus">+        return width,height,convert(),meta</span>
<a href="#l16.2204"></a><span id="l16.2204" class="difflineplus">+</span>
<a href="#l16.2205"></a><span id="l16.2205" class="difflineplus">+</span>
<a href="#l16.2206"></a><span id="l16.2206" class="difflineplus">+# === Legacy Version Support ===</span>
<a href="#l16.2207"></a><span id="l16.2207" class="difflineplus">+</span>
<a href="#l16.2208"></a><span id="l16.2208" class="difflineplus">+# :pyver:old:  PyPNG works on Python versions 2.3 and 2.2, but not</span>
<a href="#l16.2209"></a><span id="l16.2209" class="difflineplus">+# without some awkward problems.  Really PyPNG works on Python 2.4 (and</span>
<a href="#l16.2210"></a><span id="l16.2210" class="difflineplus">+# above); it works on Pythons 2.3 and 2.2 by virtue of fixing up</span>
<a href="#l16.2211"></a><span id="l16.2211" class="difflineplus">+# problems here.  It's a bit ugly (which is why it's hidden down here).</span>
<a href="#l16.2212"></a><span id="l16.2212" class="difflineplus">+#</span>
<a href="#l16.2213"></a><span id="l16.2213" class="difflineplus">+# Generally the strategy is one of pretending that we're running on</span>
<a href="#l16.2214"></a><span id="l16.2214" class="difflineplus">+# Python 2.4 (or above), and patching up the library support on earlier</span>
<a href="#l16.2215"></a><span id="l16.2215" class="difflineplus">+# versions so that it looks enough like Python 2.4.  When it comes to</span>
<a href="#l16.2216"></a><span id="l16.2216" class="difflineplus">+# Python 2.2 there is one thing we cannot patch: extended slices</span>
<a href="#l16.2217"></a><span id="l16.2217" class="difflineplus">+# http://www.python.org/doc/2.3/whatsnew/section-slices.html.</span>
<a href="#l16.2218"></a><span id="l16.2218" class="difflineplus">+# Instead we simply declare that features that are implemented using</span>
<a href="#l16.2219"></a><span id="l16.2219" class="difflineplus">+# extended slices will not work on Python 2.2.</span>
<a href="#l16.2220"></a><span id="l16.2220" class="difflineplus">+#</span>
<a href="#l16.2221"></a><span id="l16.2221" class="difflineplus">+# In order to work on Python 2.3 we fix up a recurring annoyance involving</span>
<a href="#l16.2222"></a><span id="l16.2222" class="difflineplus">+# the array type.  In Python 2.3 an array cannot be initialised with an</span>
<a href="#l16.2223"></a><span id="l16.2223" class="difflineplus">+# array, and it cannot be extended with a list (or other sequence).</span>
<a href="#l16.2224"></a><span id="l16.2224" class="difflineplus">+# Both of those are repeated issues in the code.  Whilst I would not</span>
<a href="#l16.2225"></a><span id="l16.2225" class="difflineplus">+# normally tolerate this sort of behaviour, here we &quot;shim&quot; a replacement</span>
<a href="#l16.2226"></a><span id="l16.2226" class="difflineplus">+# for array into place (and hope no-ones notices).  You never read this.</span>
<a href="#l16.2227"></a><span id="l16.2227" class="difflineplus">+#</span>
<a href="#l16.2228"></a><span id="l16.2228" class="difflineplus">+# In an amusing case of warty hacks on top of warty hacks... the array</span>
<a href="#l16.2229"></a><span id="l16.2229" class="difflineplus">+# shimming we try and do only works on Python 2.3 and above (you can't</span>
<a href="#l16.2230"></a><span id="l16.2230" class="difflineplus">+# subclass array.array in Python 2.2).  So to get it working on Python</span>
<a href="#l16.2231"></a><span id="l16.2231" class="difflineplus">+# 2.2 we go for something much simpler and (probably) way slower.</span>
<a href="#l16.2232"></a><span id="l16.2232" class="difflineplus">+try:</span>
<a href="#l16.2233"></a><span id="l16.2233" class="difflineplus">+    array('B').extend([])</span>
<a href="#l16.2234"></a><span id="l16.2234" class="difflineplus">+    array('B', array('B'))</span>
<a href="#l16.2235"></a><span id="l16.2235" class="difflineplus">+except:</span>
<a href="#l16.2236"></a><span id="l16.2236" class="difflineplus">+    # Expect to get here on Python 2.3</span>
<a href="#l16.2237"></a><span id="l16.2237" class="difflineplus">+    try:</span>
<a href="#l16.2238"></a><span id="l16.2238" class="difflineplus">+        class _array_shim(array):</span>
<a href="#l16.2239"></a><span id="l16.2239" class="difflineplus">+            true_array = array</span>
<a href="#l16.2240"></a><span id="l16.2240" class="difflineplus">+            def __new__(cls, typecode, init=None):</span>
<a href="#l16.2241"></a><span id="l16.2241" class="difflineplus">+                super_new = super(_array_shim, cls).__new__</span>
<a href="#l16.2242"></a><span id="l16.2242" class="difflineplus">+                it = super_new(cls, typecode)</span>
<a href="#l16.2243"></a><span id="l16.2243" class="difflineplus">+                if init is None:</span>
<a href="#l16.2244"></a><span id="l16.2244" class="difflineplus">+                    return it</span>
<a href="#l16.2245"></a><span id="l16.2245" class="difflineplus">+                it.extend(init)</span>
<a href="#l16.2246"></a><span id="l16.2246" class="difflineplus">+                return it</span>
<a href="#l16.2247"></a><span id="l16.2247" class="difflineplus">+            def extend(self, extension):</span>
<a href="#l16.2248"></a><span id="l16.2248" class="difflineplus">+                super_extend = super(_array_shim, self).extend</span>
<a href="#l16.2249"></a><span id="l16.2249" class="difflineplus">+                if isinstance(extension, self.true_array):</span>
<a href="#l16.2250"></a><span id="l16.2250" class="difflineplus">+                    return super_extend(extension)</span>
<a href="#l16.2251"></a><span id="l16.2251" class="difflineplus">+                if not isinstance(extension, (list, str)):</span>
<a href="#l16.2252"></a><span id="l16.2252" class="difflineplus">+                    # Convert to list.  Allows iterators to work.</span>
<a href="#l16.2253"></a><span id="l16.2253" class="difflineplus">+                    extension = list(extension)</span>
<a href="#l16.2254"></a><span id="l16.2254" class="difflineplus">+                return super_extend(self.true_array(self.typecode, extension))</span>
<a href="#l16.2255"></a><span id="l16.2255" class="difflineplus">+        array = _array_shim</span>
<a href="#l16.2256"></a><span id="l16.2256" class="difflineplus">+    except:</span>
<a href="#l16.2257"></a><span id="l16.2257" class="difflineplus">+        # Expect to get here on Python 2.2</span>
<a href="#l16.2258"></a><span id="l16.2258" class="difflineplus">+        def array(typecode, init=()):</span>
<a href="#l16.2259"></a><span id="l16.2259" class="difflineplus">+            if type(init) == str:</span>
<a href="#l16.2260"></a><span id="l16.2260" class="difflineplus">+                return map(ord, init)</span>
<a href="#l16.2261"></a><span id="l16.2261" class="difflineplus">+            return list(init)</span>
<a href="#l16.2262"></a><span id="l16.2262" class="difflineplus">+</span>
<a href="#l16.2263"></a><span id="l16.2263" class="difflineplus">+# Further hacks to get it limping along on Python 2.2</span>
<a href="#l16.2264"></a><span id="l16.2264" class="difflineplus">+try:</span>
<a href="#l16.2265"></a><span id="l16.2265" class="difflineplus">+    enumerate</span>
<a href="#l16.2266"></a><span id="l16.2266" class="difflineplus">+except:</span>
<a href="#l16.2267"></a><span id="l16.2267" class="difflineplus">+    def enumerate(seq):</span>
<a href="#l16.2268"></a><span id="l16.2268" class="difflineplus">+        i=0</span>
<a href="#l16.2269"></a><span id="l16.2269" class="difflineplus">+        for x in seq:</span>
<a href="#l16.2270"></a><span id="l16.2270" class="difflineplus">+            yield i,x</span>
<a href="#l16.2271"></a><span id="l16.2271" class="difflineplus">+            i += 1</span>
<a href="#l16.2272"></a><span id="l16.2272" class="difflineplus">+</span>
<a href="#l16.2273"></a><span id="l16.2273" class="difflineplus">+try:</span>
<a href="#l16.2274"></a><span id="l16.2274" class="difflineplus">+    reversed</span>
<a href="#l16.2275"></a><span id="l16.2275" class="difflineplus">+except:</span>
<a href="#l16.2276"></a><span id="l16.2276" class="difflineplus">+    def reversed(l):</span>
<a href="#l16.2277"></a><span id="l16.2277" class="difflineplus">+        l = list(l)</span>
<a href="#l16.2278"></a><span id="l16.2278" class="difflineplus">+        l.reverse()</span>
<a href="#l16.2279"></a><span id="l16.2279" class="difflineplus">+        for x in l:</span>
<a href="#l16.2280"></a><span id="l16.2280" class="difflineplus">+            yield x</span>
<a href="#l16.2281"></a><span id="l16.2281" class="difflineplus">+</span>
<a href="#l16.2282"></a><span id="l16.2282" class="difflineplus">+try:</span>
<a href="#l16.2283"></a><span id="l16.2283" class="difflineplus">+    itertools</span>
<a href="#l16.2284"></a><span id="l16.2284" class="difflineplus">+except:</span>
<a href="#l16.2285"></a><span id="l16.2285" class="difflineplus">+    class _dummy_itertools:</span>
<a href="#l16.2286"></a><span id="l16.2286" class="difflineplus">+        pass</span>
<a href="#l16.2287"></a><span id="l16.2287" class="difflineplus">+    itertools = _dummy_itertools()</span>
<a href="#l16.2288"></a><span id="l16.2288" class="difflineplus">+    def _itertools_imap(f, seq):</span>
<a href="#l16.2289"></a><span id="l16.2289" class="difflineplus">+        for x in seq:</span>
<a href="#l16.2290"></a><span id="l16.2290" class="difflineplus">+            yield f(x)</span>
<a href="#l16.2291"></a><span id="l16.2291" class="difflineplus">+    itertools.imap = _itertools_imap</span>
<a href="#l16.2292"></a><span id="l16.2292" class="difflineplus">+    def _itertools_chain(*iterables):</span>
<a href="#l16.2293"></a><span id="l16.2293" class="difflineplus">+        for it in iterables:</span>
<a href="#l16.2294"></a><span id="l16.2294" class="difflineplus">+            for element in it:</span>
<a href="#l16.2295"></a><span id="l16.2295" class="difflineplus">+                yield element</span>
<a href="#l16.2296"></a><span id="l16.2296" class="difflineplus">+    itertools.chain = _itertools_chain</span>
<a href="#l16.2297"></a><span id="l16.2297" class="difflineplus">+</span>
<a href="#l16.2298"></a><span id="l16.2298" class="difflineplus">+</span>
<a href="#l16.2299"></a><span id="l16.2299" class="difflineplus">+</span>
<a href="#l16.2300"></a><span id="l16.2300" class="difflineplus">+# === Internal Test Support ===</span>
<a href="#l16.2301"></a><span id="l16.2301" class="difflineplus">+</span>
<a href="#l16.2302"></a><span id="l16.2302" class="difflineplus">+# This section comprises the tests that are internally validated (as</span>
<a href="#l16.2303"></a><span id="l16.2303" class="difflineplus">+# opposed to tests which produce output files that are externally</span>
<a href="#l16.2304"></a><span id="l16.2304" class="difflineplus">+# validated).  Primarily they are unittests.</span>
<a href="#l16.2305"></a><span id="l16.2305" class="difflineplus">+</span>
<a href="#l16.2306"></a><span id="l16.2306" class="difflineplus">+# Note that it is difficult to internally validate the results of</span>
<a href="#l16.2307"></a><span id="l16.2307" class="difflineplus">+# writing a PNG file.  The only thing we can do is read it back in</span>
<a href="#l16.2308"></a><span id="l16.2308" class="difflineplus">+# again, which merely checks consistency, not that the PNG file we</span>
<a href="#l16.2309"></a><span id="l16.2309" class="difflineplus">+# produce is valid.</span>
<a href="#l16.2310"></a><span id="l16.2310" class="difflineplus">+</span>
<a href="#l16.2311"></a><span id="l16.2311" class="difflineplus">+# Run the tests from the command line:</span>
<a href="#l16.2312"></a><span id="l16.2312" class="difflineplus">+# python -c 'import png;png.test()'</span>
<a href="#l16.2313"></a><span id="l16.2313" class="difflineplus">+</span>
<a href="#l16.2314"></a><span id="l16.2314" class="difflineplus">+# (For an in-memory binary file IO object) We use BytesIO where</span>
<a href="#l16.2315"></a><span id="l16.2315" class="difflineplus">+# available, otherwise we use StringIO, but name it BytesIO.</span>
<a href="#l16.2316"></a><span id="l16.2316" class="difflineplus">+try:</span>
<a href="#l16.2317"></a><span id="l16.2317" class="difflineplus">+    from io import BytesIO</span>
<a href="#l16.2318"></a><span id="l16.2318" class="difflineplus">+except:</span>
<a href="#l16.2319"></a><span id="l16.2319" class="difflineplus">+    from StringIO import StringIO as BytesIO</span>
<a href="#l16.2320"></a><span id="l16.2320" class="difflineplus">+import tempfile</span>
<a href="#l16.2321"></a><span id="l16.2321" class="difflineplus">+# http://www.python.org/doc/2.4.4/lib/module-unittest.html</span>
<a href="#l16.2322"></a><span id="l16.2322" class="difflineplus">+import unittest</span>
<a href="#l16.2323"></a><span id="l16.2323" class="difflineplus">+</span>
<a href="#l16.2324"></a><span id="l16.2324" class="difflineplus">+</span>
<a href="#l16.2325"></a><span id="l16.2325" class="difflineplus">+def test():</span>
<a href="#l16.2326"></a><span id="l16.2326" class="difflineplus">+    unittest.main(__name__)</span>
<a href="#l16.2327"></a><span id="l16.2327" class="difflineplus">+</span>
<a href="#l16.2328"></a><span id="l16.2328" class="difflineplus">+def topngbytes(name, rows, x, y, **k):</span>
<a href="#l16.2329"></a><span id="l16.2329" class="difflineplus">+    &quot;&quot;&quot;Convenience function for creating a PNG file &quot;in memory&quot; as a</span>
<a href="#l16.2330"></a><span id="l16.2330" class="difflineplus">+    string.  Creates a :class:`Writer` instance using the keyword arguments,</span>
<a href="#l16.2331"></a><span id="l16.2331" class="difflineplus">+    then passes `rows` to its :meth:`Writer.write` method.  The resulting</span>
<a href="#l16.2332"></a><span id="l16.2332" class="difflineplus">+    PNG file is returned as a string.  `name` is used to identify the file for</span>
<a href="#l16.2333"></a><span id="l16.2333" class="difflineplus">+    debugging.</span>
<a href="#l16.2334"></a><span id="l16.2334" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.2335"></a><span id="l16.2335" class="difflineplus">+</span>
<a href="#l16.2336"></a><span id="l16.2336" class="difflineplus">+    import os</span>
<a href="#l16.2337"></a><span id="l16.2337" class="difflineplus">+</span>
<a href="#l16.2338"></a><span id="l16.2338" class="difflineplus">+    print name</span>
<a href="#l16.2339"></a><span id="l16.2339" class="difflineplus">+    f = BytesIO()</span>
<a href="#l16.2340"></a><span id="l16.2340" class="difflineplus">+    w = Writer(x, y, **k)</span>
<a href="#l16.2341"></a><span id="l16.2341" class="difflineplus">+    w.write(f, rows)</span>
<a href="#l16.2342"></a><span id="l16.2342" class="difflineplus">+    if os.environ.get('PYPNG_TEST_TMP'):</span>
<a href="#l16.2343"></a><span id="l16.2343" class="difflineplus">+        w = open(name, 'wb')</span>
<a href="#l16.2344"></a><span id="l16.2344" class="difflineplus">+        w.write(f.getvalue())</span>
<a href="#l16.2345"></a><span id="l16.2345" class="difflineplus">+        w.close()</span>
<a href="#l16.2346"></a><span id="l16.2346" class="difflineplus">+    return f.getvalue()</span>
<a href="#l16.2347"></a><span id="l16.2347" class="difflineplus">+</span>
<a href="#l16.2348"></a><span id="l16.2348" class="difflineplus">+def testWithIO(inp, out, f):</span>
<a href="#l16.2349"></a><span id="l16.2349" class="difflineplus">+    &quot;&quot;&quot;Calls the function `f` with ``sys.stdin`` changed to `inp`</span>
<a href="#l16.2350"></a><span id="l16.2350" class="difflineplus">+    and ``sys.stdout`` changed to `out`.  They are restored when `f`</span>
<a href="#l16.2351"></a><span id="l16.2351" class="difflineplus">+    returns.  This function returns whatever `f` returns.</span>
<a href="#l16.2352"></a><span id="l16.2352" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.2353"></a><span id="l16.2353" class="difflineplus">+</span>
<a href="#l16.2354"></a><span id="l16.2354" class="difflineplus">+    import os</span>
<a href="#l16.2355"></a><span id="l16.2355" class="difflineplus">+</span>
<a href="#l16.2356"></a><span id="l16.2356" class="difflineplus">+    try:</span>
<a href="#l16.2357"></a><span id="l16.2357" class="difflineplus">+        oldin,sys.stdin = sys.stdin,inp</span>
<a href="#l16.2358"></a><span id="l16.2358" class="difflineplus">+        oldout,sys.stdout = sys.stdout,out</span>
<a href="#l16.2359"></a><span id="l16.2359" class="difflineplus">+        x = f()</span>
<a href="#l16.2360"></a><span id="l16.2360" class="difflineplus">+    finally:</span>
<a href="#l16.2361"></a><span id="l16.2361" class="difflineplus">+        sys.stdin = oldin</span>
<a href="#l16.2362"></a><span id="l16.2362" class="difflineplus">+        sys.stdout = oldout</span>
<a href="#l16.2363"></a><span id="l16.2363" class="difflineplus">+    if os.environ.get('PYPNG_TEST_TMP') and hasattr(out,'getvalue'):</span>
<a href="#l16.2364"></a><span id="l16.2364" class="difflineplus">+        name = mycallersname()</span>
<a href="#l16.2365"></a><span id="l16.2365" class="difflineplus">+        if name:</span>
<a href="#l16.2366"></a><span id="l16.2366" class="difflineplus">+            w = open(name+'.png', 'wb')</span>
<a href="#l16.2367"></a><span id="l16.2367" class="difflineplus">+            w.write(out.getvalue())</span>
<a href="#l16.2368"></a><span id="l16.2368" class="difflineplus">+            w.close()</span>
<a href="#l16.2369"></a><span id="l16.2369" class="difflineplus">+    return x</span>
<a href="#l16.2370"></a><span id="l16.2370" class="difflineplus">+</span>
<a href="#l16.2371"></a><span id="l16.2371" class="difflineplus">+def mycallersname():</span>
<a href="#l16.2372"></a><span id="l16.2372" class="difflineplus">+    &quot;&quot;&quot;Returns the name of the caller of the caller of this function</span>
<a href="#l16.2373"></a><span id="l16.2373" class="difflineplus">+    (hence the name of the caller of the function in which</span>
<a href="#l16.2374"></a><span id="l16.2374" class="difflineplus">+    &quot;mycallersname()&quot; textually appears).  Returns None if this cannot</span>
<a href="#l16.2375"></a><span id="l16.2375" class="difflineplus">+    be determined.&quot;&quot;&quot;</span>
<a href="#l16.2376"></a><span id="l16.2376" class="difflineplus">+</span>
<a href="#l16.2377"></a><span id="l16.2377" class="difflineplus">+    # http://docs.python.org/library/inspect.html#the-interpreter-stack</span>
<a href="#l16.2378"></a><span id="l16.2378" class="difflineplus">+    import inspect</span>
<a href="#l16.2379"></a><span id="l16.2379" class="difflineplus">+</span>
<a href="#l16.2380"></a><span id="l16.2380" class="difflineplus">+    frame = inspect.currentframe()</span>
<a href="#l16.2381"></a><span id="l16.2381" class="difflineplus">+    if not frame:</span>
<a href="#l16.2382"></a><span id="l16.2382" class="difflineplus">+        return None</span>
<a href="#l16.2383"></a><span id="l16.2383" class="difflineplus">+    frame_,filename_,lineno_,funname,linelist_,listi_ = (</span>
<a href="#l16.2384"></a><span id="l16.2384" class="difflineplus">+      inspect.getouterframes(frame)[2])</span>
<a href="#l16.2385"></a><span id="l16.2385" class="difflineplus">+    return funname</span>
<a href="#l16.2386"></a><span id="l16.2386" class="difflineplus">+</span>
<a href="#l16.2387"></a><span id="l16.2387" class="difflineplus">+def seqtobytes(s):</span>
<a href="#l16.2388"></a><span id="l16.2388" class="difflineplus">+    &quot;&quot;&quot;Convert a sequence of integers to a *bytes* instance.  Good for</span>
<a href="#l16.2389"></a><span id="l16.2389" class="difflineplus">+    plastering over Python 2 / Python 3 cracks.</span>
<a href="#l16.2390"></a><span id="l16.2390" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.2391"></a><span id="l16.2391" class="difflineplus">+</span>
<a href="#l16.2392"></a><span id="l16.2392" class="difflineplus">+    return strtobytes(''.join(chr(x) for x in s))</span>
<a href="#l16.2393"></a><span id="l16.2393" class="difflineplus">+</span>
<a href="#l16.2394"></a><span id="l16.2394" class="difflineplus">+class Test(unittest.TestCase):</span>
<a href="#l16.2395"></a><span id="l16.2395" class="difflineplus">+    # This member is used by the superclass.  If we don't define a new</span>
<a href="#l16.2396"></a><span id="l16.2396" class="difflineplus">+    # class here then when we use self.assertRaises() and the PyPNG code</span>
<a href="#l16.2397"></a><span id="l16.2397" class="difflineplus">+    # raises an assertion then we get no proper traceback.  I can't work</span>
<a href="#l16.2398"></a><span id="l16.2398" class="difflineplus">+    # out why, but defining a new class here means we get a proper</span>
<a href="#l16.2399"></a><span id="l16.2399" class="difflineplus">+    # traceback.</span>
<a href="#l16.2400"></a><span id="l16.2400" class="difflineplus">+    class failureException(Exception):</span>
<a href="#l16.2401"></a><span id="l16.2401" class="difflineplus">+        pass</span>
<a href="#l16.2402"></a><span id="l16.2402" class="difflineplus">+</span>
<a href="#l16.2403"></a><span id="l16.2403" class="difflineplus">+    def helperLN(self, n):</span>
<a href="#l16.2404"></a><span id="l16.2404" class="difflineplus">+        mask = (1 &lt;&lt; n) - 1</span>
<a href="#l16.2405"></a><span id="l16.2405" class="difflineplus">+        # Use small chunk_limit so that multiple chunk writing is</span>
<a href="#l16.2406"></a><span id="l16.2406" class="difflineplus">+        # tested.  Making it a test for Issue 20.</span>
<a href="#l16.2407"></a><span id="l16.2407" class="difflineplus">+        w = Writer(15, 17, greyscale=True, bitdepth=n, chunk_limit=99)</span>
<a href="#l16.2408"></a><span id="l16.2408" class="difflineplus">+        f = BytesIO()</span>
<a href="#l16.2409"></a><span id="l16.2409" class="difflineplus">+        w.write_array(f, array('B', map(mask.__and__, range(1, 256))))</span>
<a href="#l16.2410"></a><span id="l16.2410" class="difflineplus">+        r = Reader(bytes=f.getvalue())</span>
<a href="#l16.2411"></a><span id="l16.2411" class="difflineplus">+        x,y,pixels,meta = r.read()</span>
<a href="#l16.2412"></a><span id="l16.2412" class="difflineplus">+        self.assertEqual(x, 15)</span>
<a href="#l16.2413"></a><span id="l16.2413" class="difflineplus">+        self.assertEqual(y, 17)</span>
<a href="#l16.2414"></a><span id="l16.2414" class="difflineplus">+        self.assertEqual(list(itertools.chain(*pixels)),</span>
<a href="#l16.2415"></a><span id="l16.2415" class="difflineplus">+                         map(mask.__and__, range(1,256)))</span>
<a href="#l16.2416"></a><span id="l16.2416" class="difflineplus">+    def testL8(self):</span>
<a href="#l16.2417"></a><span id="l16.2417" class="difflineplus">+        return self.helperLN(8)</span>
<a href="#l16.2418"></a><span id="l16.2418" class="difflineplus">+    def testL4(self):</span>
<a href="#l16.2419"></a><span id="l16.2419" class="difflineplus">+        return self.helperLN(4)</span>
<a href="#l16.2420"></a><span id="l16.2420" class="difflineplus">+    def testL2(self):</span>
<a href="#l16.2421"></a><span id="l16.2421" class="difflineplus">+        &quot;Also tests asRGB8.&quot;</span>
<a href="#l16.2422"></a><span id="l16.2422" class="difflineplus">+        w = Writer(1, 4, greyscale=True, bitdepth=2)</span>
<a href="#l16.2423"></a><span id="l16.2423" class="difflineplus">+        f = BytesIO()</span>
<a href="#l16.2424"></a><span id="l16.2424" class="difflineplus">+        w.write_array(f, array('B', range(4)))</span>
<a href="#l16.2425"></a><span id="l16.2425" class="difflineplus">+        r = Reader(bytes=f.getvalue())</span>
<a href="#l16.2426"></a><span id="l16.2426" class="difflineplus">+        x,y,pixels,meta = r.asRGB8()</span>
<a href="#l16.2427"></a><span id="l16.2427" class="difflineplus">+        self.assertEqual(x, 1)</span>
<a href="#l16.2428"></a><span id="l16.2428" class="difflineplus">+        self.assertEqual(y, 4)</span>
<a href="#l16.2429"></a><span id="l16.2429" class="difflineplus">+        for i,row in enumerate(pixels):</span>
<a href="#l16.2430"></a><span id="l16.2430" class="difflineplus">+            self.assertEqual(len(row), 3)</span>
<a href="#l16.2431"></a><span id="l16.2431" class="difflineplus">+            self.assertEqual(list(row), [0x55*i]*3)</span>
<a href="#l16.2432"></a><span id="l16.2432" class="difflineplus">+    def testP2(self):</span>
<a href="#l16.2433"></a><span id="l16.2433" class="difflineplus">+        &quot;2-bit palette.&quot;</span>
<a href="#l16.2434"></a><span id="l16.2434" class="difflineplus">+        a = (255,255,255)</span>
<a href="#l16.2435"></a><span id="l16.2435" class="difflineplus">+        b = (200,120,120)</span>
<a href="#l16.2436"></a><span id="l16.2436" class="difflineplus">+        c = (50,99,50)</span>
<a href="#l16.2437"></a><span id="l16.2437" class="difflineplus">+        w = Writer(1, 4, bitdepth=2, palette=[a,b,c])</span>
<a href="#l16.2438"></a><span id="l16.2438" class="difflineplus">+        f = BytesIO()</span>
<a href="#l16.2439"></a><span id="l16.2439" class="difflineplus">+        w.write_array(f, array('B', (0,1,1,2)))</span>
<a href="#l16.2440"></a><span id="l16.2440" class="difflineplus">+        r = Reader(bytes=f.getvalue())</span>
<a href="#l16.2441"></a><span id="l16.2441" class="difflineplus">+        x,y,pixels,meta = r.asRGB8()</span>
<a href="#l16.2442"></a><span id="l16.2442" class="difflineplus">+        self.assertEqual(x, 1)</span>
<a href="#l16.2443"></a><span id="l16.2443" class="difflineplus">+        self.assertEqual(y, 4)</span>
<a href="#l16.2444"></a><span id="l16.2444" class="difflineplus">+        self.assertEqual(list(pixels), map(list, [a, b, b, c]))</span>
<a href="#l16.2445"></a><span id="l16.2445" class="difflineplus">+    def testPtrns(self):</span>
<a href="#l16.2446"></a><span id="l16.2446" class="difflineplus">+        &quot;Test colour type 3 and tRNS chunk (and 4-bit palette).&quot;</span>
<a href="#l16.2447"></a><span id="l16.2447" class="difflineplus">+        a = (50,99,50,50)</span>
<a href="#l16.2448"></a><span id="l16.2448" class="difflineplus">+        b = (200,120,120,80)</span>
<a href="#l16.2449"></a><span id="l16.2449" class="difflineplus">+        c = (255,255,255)</span>
<a href="#l16.2450"></a><span id="l16.2450" class="difflineplus">+        d = (200,120,120)</span>
<a href="#l16.2451"></a><span id="l16.2451" class="difflineplus">+        e = (50,99,50)</span>
<a href="#l16.2452"></a><span id="l16.2452" class="difflineplus">+        w = Writer(3, 3, bitdepth=4, palette=[a,b,c,d,e])</span>
<a href="#l16.2453"></a><span id="l16.2453" class="difflineplus">+        f = BytesIO()</span>
<a href="#l16.2454"></a><span id="l16.2454" class="difflineplus">+        w.write_array(f, array('B', (4, 3, 2, 3, 2, 0, 2, 0, 1)))</span>
<a href="#l16.2455"></a><span id="l16.2455" class="difflineplus">+        r = Reader(bytes=f.getvalue())</span>
<a href="#l16.2456"></a><span id="l16.2456" class="difflineplus">+        x,y,pixels,meta = r.asRGBA8()</span>
<a href="#l16.2457"></a><span id="l16.2457" class="difflineplus">+        self.assertEqual(x, 3)</span>
<a href="#l16.2458"></a><span id="l16.2458" class="difflineplus">+        self.assertEqual(y, 3)</span>
<a href="#l16.2459"></a><span id="l16.2459" class="difflineplus">+        c = c+(255,)</span>
<a href="#l16.2460"></a><span id="l16.2460" class="difflineplus">+        d = d+(255,)</span>
<a href="#l16.2461"></a><span id="l16.2461" class="difflineplus">+        e = e+(255,)</span>
<a href="#l16.2462"></a><span id="l16.2462" class="difflineplus">+        boxed = [(e,d,c),(d,c,a),(c,a,b)]</span>
<a href="#l16.2463"></a><span id="l16.2463" class="difflineplus">+        flat = map(lambda row: itertools.chain(*row), boxed)</span>
<a href="#l16.2464"></a><span id="l16.2464" class="difflineplus">+        self.assertEqual(map(list, pixels), map(list, flat))</span>
<a href="#l16.2465"></a><span id="l16.2465" class="difflineplus">+    def testRGBtoRGBA(self):</span>
<a href="#l16.2466"></a><span id="l16.2466" class="difflineplus">+        &quot;asRGBA8() on colour type 2 source.&quot;&quot;&quot;</span>
<a href="#l16.2467"></a><span id="l16.2467" class="difflineplus">+        # Test for Issue 26</span>
<a href="#l16.2468"></a><span id="l16.2468" class="difflineplus">+        r = Reader(bytes=_pngsuite['basn2c08'])</span>
<a href="#l16.2469"></a><span id="l16.2469" class="difflineplus">+        x,y,pixels,meta = r.asRGBA8()</span>
<a href="#l16.2470"></a><span id="l16.2470" class="difflineplus">+        # Test the pixels at row 9 columns 0 and 1.</span>
<a href="#l16.2471"></a><span id="l16.2471" class="difflineplus">+        row9 = list(pixels)[9]</span>
<a href="#l16.2472"></a><span id="l16.2472" class="difflineplus">+        self.assertEqual(row9[0:8],</span>
<a href="#l16.2473"></a><span id="l16.2473" class="difflineplus">+                         [0xff, 0xdf, 0xff, 0xff, 0xff, 0xde, 0xff, 0xff])</span>
<a href="#l16.2474"></a><span id="l16.2474" class="difflineplus">+    def testLtoRGBA(self):</span>
<a href="#l16.2475"></a><span id="l16.2475" class="difflineplus">+        &quot;asRGBA() on grey source.&quot;&quot;&quot;</span>
<a href="#l16.2476"></a><span id="l16.2476" class="difflineplus">+        # Test for Issue 60</span>
<a href="#l16.2477"></a><span id="l16.2477" class="difflineplus">+        r = Reader(bytes=_pngsuite['basi0g08'])</span>
<a href="#l16.2478"></a><span id="l16.2478" class="difflineplus">+        x,y,pixels,meta = r.asRGBA()</span>
<a href="#l16.2479"></a><span id="l16.2479" class="difflineplus">+        row9 = list(list(pixels)[9])</span>
<a href="#l16.2480"></a><span id="l16.2480" class="difflineplus">+        self.assertEqual(row9[0:8],</span>
<a href="#l16.2481"></a><span id="l16.2481" class="difflineplus">+          [222, 222, 222, 255, 221, 221, 221, 255])</span>
<a href="#l16.2482"></a><span id="l16.2482" class="difflineplus">+    def testCtrns(self):</span>
<a href="#l16.2483"></a><span id="l16.2483" class="difflineplus">+        &quot;Test colour type 2 and tRNS chunk.&quot;</span>
<a href="#l16.2484"></a><span id="l16.2484" class="difflineplus">+        # Test for Issue 25</span>
<a href="#l16.2485"></a><span id="l16.2485" class="difflineplus">+        r = Reader(bytes=_pngsuite['tbrn2c08'])</span>
<a href="#l16.2486"></a><span id="l16.2486" class="difflineplus">+        x,y,pixels,meta = r.asRGBA8()</span>
<a href="#l16.2487"></a><span id="l16.2487" class="difflineplus">+        # I just happen to know that the first pixel is transparent.</span>
<a href="#l16.2488"></a><span id="l16.2488" class="difflineplus">+        # In particular it should be #7f7f7f00</span>
<a href="#l16.2489"></a><span id="l16.2489" class="difflineplus">+        row0 = list(pixels)[0]</span>
<a href="#l16.2490"></a><span id="l16.2490" class="difflineplus">+        self.assertEqual(tuple(row0[0:4]), (0x7f, 0x7f, 0x7f, 0x00))</span>
<a href="#l16.2491"></a><span id="l16.2491" class="difflineplus">+    def testAdam7read(self):</span>
<a href="#l16.2492"></a><span id="l16.2492" class="difflineplus">+        &quot;&quot;&quot;Adam7 interlace reading.</span>
<a href="#l16.2493"></a><span id="l16.2493" class="difflineplus">+        Specifically, test that for images in the PngSuite that</span>
<a href="#l16.2494"></a><span id="l16.2494" class="difflineplus">+        have both an interlaced and straightlaced pair that both</span>
<a href="#l16.2495"></a><span id="l16.2495" class="difflineplus">+        images from the pair produce the same array of pixels.&quot;&quot;&quot;</span>
<a href="#l16.2496"></a><span id="l16.2496" class="difflineplus">+        for candidate in _pngsuite:</span>
<a href="#l16.2497"></a><span id="l16.2497" class="difflineplus">+            if not candidate.startswith('basn'):</span>
<a href="#l16.2498"></a><span id="l16.2498" class="difflineplus">+                continue</span>
<a href="#l16.2499"></a><span id="l16.2499" class="difflineplus">+            candi = candidate.replace('n', 'i')</span>
<a href="#l16.2500"></a><span id="l16.2500" class="difflineplus">+            if candi not in _pngsuite:</span>
<a href="#l16.2501"></a><span id="l16.2501" class="difflineplus">+                continue</span>
<a href="#l16.2502"></a><span id="l16.2502" class="difflineplus">+            print 'adam7 read', candidate</span>
<a href="#l16.2503"></a><span id="l16.2503" class="difflineplus">+            straight = Reader(bytes=_pngsuite[candidate])</span>
<a href="#l16.2504"></a><span id="l16.2504" class="difflineplus">+            adam7 = Reader(bytes=_pngsuite[candi])</span>
<a href="#l16.2505"></a><span id="l16.2505" class="difflineplus">+            # Just compare the pixels.  Ignore x,y (because they're</span>
<a href="#l16.2506"></a><span id="l16.2506" class="difflineplus">+            # likely to be correct?); metadata is ignored because the</span>
<a href="#l16.2507"></a><span id="l16.2507" class="difflineplus">+            # &quot;interlace&quot; member differs.  Lame.</span>
<a href="#l16.2508"></a><span id="l16.2508" class="difflineplus">+            straight = straight.read()[2]</span>
<a href="#l16.2509"></a><span id="l16.2509" class="difflineplus">+            adam7 = adam7.read()[2]</span>
<a href="#l16.2510"></a><span id="l16.2510" class="difflineplus">+            self.assertEqual(map(list, straight), map(list, adam7))</span>
<a href="#l16.2511"></a><span id="l16.2511" class="difflineplus">+    def testAdam7write(self):</span>
<a href="#l16.2512"></a><span id="l16.2512" class="difflineplus">+        &quot;&quot;&quot;Adam7 interlace writing.</span>
<a href="#l16.2513"></a><span id="l16.2513" class="difflineplus">+        For each test image in the PngSuite, write an interlaced</span>
<a href="#l16.2514"></a><span id="l16.2514" class="difflineplus">+        and a straightlaced version.  Decode both, and compare results.</span>
<a href="#l16.2515"></a><span id="l16.2515" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.2516"></a><span id="l16.2516" class="difflineplus">+        # Not such a great test, because the only way we can check what</span>
<a href="#l16.2517"></a><span id="l16.2517" class="difflineplus">+        # we have written is to read it back again.</span>
<a href="#l16.2518"></a><span id="l16.2518" class="difflineplus">+</span>
<a href="#l16.2519"></a><span id="l16.2519" class="difflineplus">+        for name,bytes in _pngsuite.items():</span>
<a href="#l16.2520"></a><span id="l16.2520" class="difflineplus">+            # Only certain colour types supported for this test.</span>
<a href="#l16.2521"></a><span id="l16.2521" class="difflineplus">+            if name[3:5] not in ['n0', 'n2', 'n4', 'n6']:</span>
<a href="#l16.2522"></a><span id="l16.2522" class="difflineplus">+                continue</span>
<a href="#l16.2523"></a><span id="l16.2523" class="difflineplus">+            it = Reader(bytes=bytes)</span>
<a href="#l16.2524"></a><span id="l16.2524" class="difflineplus">+            x,y,pixels,meta = it.read()</span>
<a href="#l16.2525"></a><span id="l16.2525" class="difflineplus">+            pngi = topngbytes('adam7wn'+name+'.png', pixels,</span>
<a href="#l16.2526"></a><span id="l16.2526" class="difflineplus">+              x=x, y=y, bitdepth=it.bitdepth,</span>
<a href="#l16.2527"></a><span id="l16.2527" class="difflineplus">+              greyscale=it.greyscale, alpha=it.alpha,</span>
<a href="#l16.2528"></a><span id="l16.2528" class="difflineplus">+              transparent=it.transparent,</span>
<a href="#l16.2529"></a><span id="l16.2529" class="difflineplus">+              interlace=False)</span>
<a href="#l16.2530"></a><span id="l16.2530" class="difflineplus">+            x,y,ps,meta = Reader(bytes=pngi).read()</span>
<a href="#l16.2531"></a><span id="l16.2531" class="difflineplus">+            it = Reader(bytes=bytes)</span>
<a href="#l16.2532"></a><span id="l16.2532" class="difflineplus">+            x,y,pixels,meta = it.read()</span>
<a href="#l16.2533"></a><span id="l16.2533" class="difflineplus">+            pngs = topngbytes('adam7wi'+name+'.png', pixels,</span>
<a href="#l16.2534"></a><span id="l16.2534" class="difflineplus">+              x=x, y=y, bitdepth=it.bitdepth,</span>
<a href="#l16.2535"></a><span id="l16.2535" class="difflineplus">+              greyscale=it.greyscale, alpha=it.alpha,</span>
<a href="#l16.2536"></a><span id="l16.2536" class="difflineplus">+              transparent=it.transparent,</span>
<a href="#l16.2537"></a><span id="l16.2537" class="difflineplus">+              interlace=True)</span>
<a href="#l16.2538"></a><span id="l16.2538" class="difflineplus">+            x,y,pi,meta = Reader(bytes=pngs).read()</span>
<a href="#l16.2539"></a><span id="l16.2539" class="difflineplus">+            self.assertEqual(map(list, ps), map(list, pi))</span>
<a href="#l16.2540"></a><span id="l16.2540" class="difflineplus">+    def testPGMin(self):</span>
<a href="#l16.2541"></a><span id="l16.2541" class="difflineplus">+        &quot;&quot;&quot;Test that the command line tool can read PGM files.&quot;&quot;&quot;</span>
<a href="#l16.2542"></a><span id="l16.2542" class="difflineplus">+        def do():</span>
<a href="#l16.2543"></a><span id="l16.2543" class="difflineplus">+            return _main(['testPGMin'])</span>
<a href="#l16.2544"></a><span id="l16.2544" class="difflineplus">+        s = BytesIO()</span>
<a href="#l16.2545"></a><span id="l16.2545" class="difflineplus">+        s.write(strtobytes('P5 2 2 3\n'))</span>
<a href="#l16.2546"></a><span id="l16.2546" class="difflineplus">+        s.write(strtobytes('\x00\x01\x02\x03'))</span>
<a href="#l16.2547"></a><span id="l16.2547" class="difflineplus">+        s.flush()</span>
<a href="#l16.2548"></a><span id="l16.2548" class="difflineplus">+        s.seek(0)</span>
<a href="#l16.2549"></a><span id="l16.2549" class="difflineplus">+        o = BytesIO()</span>
<a href="#l16.2550"></a><span id="l16.2550" class="difflineplus">+        testWithIO(s, o, do)</span>
<a href="#l16.2551"></a><span id="l16.2551" class="difflineplus">+        r = Reader(bytes=o.getvalue())</span>
<a href="#l16.2552"></a><span id="l16.2552" class="difflineplus">+        x,y,pixels,meta = r.read()</span>
<a href="#l16.2553"></a><span id="l16.2553" class="difflineplus">+        self.assertTrue(r.greyscale)</span>
<a href="#l16.2554"></a><span id="l16.2554" class="difflineplus">+        self.assertEqual(r.bitdepth, 2)</span>
<a href="#l16.2555"></a><span id="l16.2555" class="difflineplus">+    def testPAMin(self):</span>
<a href="#l16.2556"></a><span id="l16.2556" class="difflineplus">+        &quot;&quot;&quot;Test that the command line tool can read PAM file.&quot;&quot;&quot;</span>
<a href="#l16.2557"></a><span id="l16.2557" class="difflineplus">+        def do():</span>
<a href="#l16.2558"></a><span id="l16.2558" class="difflineplus">+            return _main(['testPAMin'])</span>
<a href="#l16.2559"></a><span id="l16.2559" class="difflineplus">+        s = BytesIO()</span>
<a href="#l16.2560"></a><span id="l16.2560" class="difflineplus">+        s.write(strtobytes('P7\nWIDTH 3\nHEIGHT 1\nDEPTH 4\nMAXVAL 255\n'</span>
<a href="#l16.2561"></a><span id="l16.2561" class="difflineplus">+                'TUPLTYPE RGB_ALPHA\nENDHDR\n'))</span>
<a href="#l16.2562"></a><span id="l16.2562" class="difflineplus">+        # The pixels in flat row flat pixel format</span>
<a href="#l16.2563"></a><span id="l16.2563" class="difflineplus">+        flat =  [255,0,0,255, 0,255,0,120, 0,0,255,30]</span>
<a href="#l16.2564"></a><span id="l16.2564" class="difflineplus">+        asbytes = seqtobytes(flat)</span>
<a href="#l16.2565"></a><span id="l16.2565" class="difflineplus">+        s.write(asbytes)</span>
<a href="#l16.2566"></a><span id="l16.2566" class="difflineplus">+        s.flush()</span>
<a href="#l16.2567"></a><span id="l16.2567" class="difflineplus">+        s.seek(0)</span>
<a href="#l16.2568"></a><span id="l16.2568" class="difflineplus">+        o = BytesIO()</span>
<a href="#l16.2569"></a><span id="l16.2569" class="difflineplus">+        testWithIO(s, o, do)</span>
<a href="#l16.2570"></a><span id="l16.2570" class="difflineplus">+        r = Reader(bytes=o.getvalue())</span>
<a href="#l16.2571"></a><span id="l16.2571" class="difflineplus">+        x,y,pixels,meta = r.read()</span>
<a href="#l16.2572"></a><span id="l16.2572" class="difflineplus">+        self.assertTrue(r.alpha)</span>
<a href="#l16.2573"></a><span id="l16.2573" class="difflineplus">+        self.assertTrue(not r.greyscale)</span>
<a href="#l16.2574"></a><span id="l16.2574" class="difflineplus">+        self.assertEqual(list(itertools.chain(*pixels)), flat)</span>
<a href="#l16.2575"></a><span id="l16.2575" class="difflineplus">+    def testLA4(self):</span>
<a href="#l16.2576"></a><span id="l16.2576" class="difflineplus">+        &quot;&quot;&quot;Create an LA image with bitdepth 4.&quot;&quot;&quot;</span>
<a href="#l16.2577"></a><span id="l16.2577" class="difflineplus">+        bytes = topngbytes('la4.png', [[5, 12]], 1, 1,</span>
<a href="#l16.2578"></a><span id="l16.2578" class="difflineplus">+          greyscale=True, alpha=True, bitdepth=4)</span>
<a href="#l16.2579"></a><span id="l16.2579" class="difflineplus">+        sbit = Reader(bytes=bytes).chunk('sBIT')[1]</span>
<a href="#l16.2580"></a><span id="l16.2580" class="difflineplus">+        self.assertEqual(sbit, strtobytes('\x04\x04'))</span>
<a href="#l16.2581"></a><span id="l16.2581" class="difflineplus">+    def testPNMsbit(self):</span>
<a href="#l16.2582"></a><span id="l16.2582" class="difflineplus">+        &quot;&quot;&quot;Test that PNM files can generates sBIT chunk.&quot;&quot;&quot;</span>
<a href="#l16.2583"></a><span id="l16.2583" class="difflineplus">+        def do():</span>
<a href="#l16.2584"></a><span id="l16.2584" class="difflineplus">+            return _main(['testPNMsbit'])</span>
<a href="#l16.2585"></a><span id="l16.2585" class="difflineplus">+        s = BytesIO()</span>
<a href="#l16.2586"></a><span id="l16.2586" class="difflineplus">+        s.write(strtobytes('P6 8 1 1\n'))</span>
<a href="#l16.2587"></a><span id="l16.2587" class="difflineplus">+        for pixel in range(8):</span>
<a href="#l16.2588"></a><span id="l16.2588" class="difflineplus">+            s.write(struct.pack('&lt;I', (0x4081*pixel)&amp;0x10101)[:3])</span>
<a href="#l16.2589"></a><span id="l16.2589" class="difflineplus">+        s.flush()</span>
<a href="#l16.2590"></a><span id="l16.2590" class="difflineplus">+        s.seek(0)</span>
<a href="#l16.2591"></a><span id="l16.2591" class="difflineplus">+        o = BytesIO()</span>
<a href="#l16.2592"></a><span id="l16.2592" class="difflineplus">+        testWithIO(s, o, do)</span>
<a href="#l16.2593"></a><span id="l16.2593" class="difflineplus">+        r = Reader(bytes=o.getvalue())</span>
<a href="#l16.2594"></a><span id="l16.2594" class="difflineplus">+        sbit = r.chunk('sBIT')[1]</span>
<a href="#l16.2595"></a><span id="l16.2595" class="difflineplus">+        self.assertEqual(sbit, strtobytes('\x01\x01\x01'))</span>
<a href="#l16.2596"></a><span id="l16.2596" class="difflineplus">+    def testLtrns0(self):</span>
<a href="#l16.2597"></a><span id="l16.2597" class="difflineplus">+        &quot;&quot;&quot;Create greyscale image with tRNS chunk.&quot;&quot;&quot;</span>
<a href="#l16.2598"></a><span id="l16.2598" class="difflineplus">+        return self.helperLtrns(0)</span>
<a href="#l16.2599"></a><span id="l16.2599" class="difflineplus">+    def testLtrns1(self):</span>
<a href="#l16.2600"></a><span id="l16.2600" class="difflineplus">+        &quot;&quot;&quot;Using 1-tuple for transparent arg.&quot;&quot;&quot;</span>
<a href="#l16.2601"></a><span id="l16.2601" class="difflineplus">+        return self.helperLtrns((0,))</span>
<a href="#l16.2602"></a><span id="l16.2602" class="difflineplus">+    def helperLtrns(self, transparent):</span>
<a href="#l16.2603"></a><span id="l16.2603" class="difflineplus">+        &quot;&quot;&quot;Helper used by :meth:`testLtrns*`.&quot;&quot;&quot;</span>
<a href="#l16.2604"></a><span id="l16.2604" class="difflineplus">+        pixels = zip([0x00, 0x38, 0x4c, 0x54, 0x5c, 0x40, 0x38, 0x00])</span>
<a href="#l16.2605"></a><span id="l16.2605" class="difflineplus">+        o = BytesIO()</span>
<a href="#l16.2606"></a><span id="l16.2606" class="difflineplus">+        w = Writer(8, 8, greyscale=True, bitdepth=1, transparent=transparent)</span>
<a href="#l16.2607"></a><span id="l16.2607" class="difflineplus">+        w.write_packed(o, pixels)</span>
<a href="#l16.2608"></a><span id="l16.2608" class="difflineplus">+        r = Reader(bytes=o.getvalue())</span>
<a href="#l16.2609"></a><span id="l16.2609" class="difflineplus">+        x,y,pixels,meta = r.asDirect()</span>
<a href="#l16.2610"></a><span id="l16.2610" class="difflineplus">+        self.assertTrue(meta['alpha'])</span>
<a href="#l16.2611"></a><span id="l16.2611" class="difflineplus">+        self.assertTrue(meta['greyscale'])</span>
<a href="#l16.2612"></a><span id="l16.2612" class="difflineplus">+        self.assertEqual(meta['bitdepth'], 1)</span>
<a href="#l16.2613"></a><span id="l16.2613" class="difflineplus">+    def testWinfo(self):</span>
<a href="#l16.2614"></a><span id="l16.2614" class="difflineplus">+        &quot;&quot;&quot;Test the dictionary returned by a `read` method can be used</span>
<a href="#l16.2615"></a><span id="l16.2615" class="difflineplus">+        as args for :meth:`Writer`.</span>
<a href="#l16.2616"></a><span id="l16.2616" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.2617"></a><span id="l16.2617" class="difflineplus">+        r = Reader(bytes=_pngsuite['basn2c16'])</span>
<a href="#l16.2618"></a><span id="l16.2618" class="difflineplus">+        info = r.read()[3]</span>
<a href="#l16.2619"></a><span id="l16.2619" class="difflineplus">+        w = Writer(**info)</span>
<a href="#l16.2620"></a><span id="l16.2620" class="difflineplus">+    def testPackedIter(self):</span>
<a href="#l16.2621"></a><span id="l16.2621" class="difflineplus">+        &quot;&quot;&quot;Test iterator for row when using write_packed.</span>
<a href="#l16.2622"></a><span id="l16.2622" class="difflineplus">+</span>
<a href="#l16.2623"></a><span id="l16.2623" class="difflineplus">+        Indicative for Issue 47.</span>
<a href="#l16.2624"></a><span id="l16.2624" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.2625"></a><span id="l16.2625" class="difflineplus">+        w = Writer(16, 2, greyscale=True, alpha=False, bitdepth=1)</span>
<a href="#l16.2626"></a><span id="l16.2626" class="difflineplus">+        o = BytesIO()</span>
<a href="#l16.2627"></a><span id="l16.2627" class="difflineplus">+        w.write_packed(o, [itertools.chain([0x0a], [0xaa]),</span>
<a href="#l16.2628"></a><span id="l16.2628" class="difflineplus">+                           itertools.chain([0x0f], [0xff])])</span>
<a href="#l16.2629"></a><span id="l16.2629" class="difflineplus">+        r = Reader(bytes=o.getvalue())</span>
<a href="#l16.2630"></a><span id="l16.2630" class="difflineplus">+        x,y,pixels,info = r.asDirect()</span>
<a href="#l16.2631"></a><span id="l16.2631" class="difflineplus">+        pixels = list(pixels)</span>
<a href="#l16.2632"></a><span id="l16.2632" class="difflineplus">+        self.assertEqual(len(pixels), 2)</span>
<a href="#l16.2633"></a><span id="l16.2633" class="difflineplus">+        self.assertEqual(len(pixels[0]), 16)</span>
<a href="#l16.2634"></a><span id="l16.2634" class="difflineplus">+    def testInterlacedArray(self):</span>
<a href="#l16.2635"></a><span id="l16.2635" class="difflineplus">+        &quot;&quot;&quot;Test that reading an interlaced PNG yields each row as an</span>
<a href="#l16.2636"></a><span id="l16.2636" class="difflineplus">+        array.&quot;&quot;&quot;</span>
<a href="#l16.2637"></a><span id="l16.2637" class="difflineplus">+        r = Reader(bytes=_pngsuite['basi0g08'])</span>
<a href="#l16.2638"></a><span id="l16.2638" class="difflineplus">+        list(r.read()[2])[0].tostring</span>
<a href="#l16.2639"></a><span id="l16.2639" class="difflineplus">+    def testTrnsArray(self):</span>
<a href="#l16.2640"></a><span id="l16.2640" class="difflineplus">+        &quot;&quot;&quot;Test that reading a type 2 PNG with tRNS chunk yields each</span>
<a href="#l16.2641"></a><span id="l16.2641" class="difflineplus">+        row as an array (using asDirect).&quot;&quot;&quot;</span>
<a href="#l16.2642"></a><span id="l16.2642" class="difflineplus">+        r = Reader(bytes=_pngsuite['tbrn2c08'])</span>
<a href="#l16.2643"></a><span id="l16.2643" class="difflineplus">+        list(r.asDirect()[2])[0].tostring</span>
<a href="#l16.2644"></a><span id="l16.2644" class="difflineplus">+</span>
<a href="#l16.2645"></a><span id="l16.2645" class="difflineplus">+    # Invalid file format tests.  These construct various badly</span>
<a href="#l16.2646"></a><span id="l16.2646" class="difflineplus">+    # formatted PNG files, then feed them into a Reader.  When</span>
<a href="#l16.2647"></a><span id="l16.2647" class="difflineplus">+    # everything is working properly, we should get FormatError</span>
<a href="#l16.2648"></a><span id="l16.2648" class="difflineplus">+    # exceptions raised.</span>
<a href="#l16.2649"></a><span id="l16.2649" class="difflineplus">+    def testEmpty(self):</span>
<a href="#l16.2650"></a><span id="l16.2650" class="difflineplus">+        &quot;&quot;&quot;Test empty file.&quot;&quot;&quot;</span>
<a href="#l16.2651"></a><span id="l16.2651" class="difflineplus">+</span>
<a href="#l16.2652"></a><span id="l16.2652" class="difflineplus">+        r = Reader(bytes='')</span>
<a href="#l16.2653"></a><span id="l16.2653" class="difflineplus">+        self.assertRaises(FormatError, r.asDirect)</span>
<a href="#l16.2654"></a><span id="l16.2654" class="difflineplus">+    def testSigOnly(self):</span>
<a href="#l16.2655"></a><span id="l16.2655" class="difflineplus">+        &quot;&quot;&quot;Test file containing just signature bytes.&quot;&quot;&quot;</span>
<a href="#l16.2656"></a><span id="l16.2656" class="difflineplus">+</span>
<a href="#l16.2657"></a><span id="l16.2657" class="difflineplus">+        r = Reader(bytes=_signature)</span>
<a href="#l16.2658"></a><span id="l16.2658" class="difflineplus">+        self.assertRaises(FormatError, r.asDirect)</span>
<a href="#l16.2659"></a><span id="l16.2659" class="difflineplus">+    def testExtraPixels(self):</span>
<a href="#l16.2660"></a><span id="l16.2660" class="difflineplus">+        &quot;&quot;&quot;Test file that contains too many pixels.&quot;&quot;&quot;</span>
<a href="#l16.2661"></a><span id="l16.2661" class="difflineplus">+</span>
<a href="#l16.2662"></a><span id="l16.2662" class="difflineplus">+        def eachchunk(chunk):</span>
<a href="#l16.2663"></a><span id="l16.2663" class="difflineplus">+            if chunk[0] != 'IDAT':</span>
<a href="#l16.2664"></a><span id="l16.2664" class="difflineplus">+                return chunk</span>
<a href="#l16.2665"></a><span id="l16.2665" class="difflineplus">+            data = zlib.decompress(chunk[1])</span>
<a href="#l16.2666"></a><span id="l16.2666" class="difflineplus">+            data += strtobytes('\x00garbage')</span>
<a href="#l16.2667"></a><span id="l16.2667" class="difflineplus">+            data = zlib.compress(data)</span>
<a href="#l16.2668"></a><span id="l16.2668" class="difflineplus">+            chunk = (chunk[0], data)</span>
<a href="#l16.2669"></a><span id="l16.2669" class="difflineplus">+            return chunk</span>
<a href="#l16.2670"></a><span id="l16.2670" class="difflineplus">+        self.assertRaises(FormatError, self.helperFormat, eachchunk)</span>
<a href="#l16.2671"></a><span id="l16.2671" class="difflineplus">+    def testNotEnoughPixels(self):</span>
<a href="#l16.2672"></a><span id="l16.2672" class="difflineplus">+        def eachchunk(chunk):</span>
<a href="#l16.2673"></a><span id="l16.2673" class="difflineplus">+            if chunk[0] != 'IDAT':</span>
<a href="#l16.2674"></a><span id="l16.2674" class="difflineplus">+                return chunk</span>
<a href="#l16.2675"></a><span id="l16.2675" class="difflineplus">+            # Remove last byte.</span>
<a href="#l16.2676"></a><span id="l16.2676" class="difflineplus">+            data = zlib.decompress(chunk[1])</span>
<a href="#l16.2677"></a><span id="l16.2677" class="difflineplus">+            data = data[:-1]</span>
<a href="#l16.2678"></a><span id="l16.2678" class="difflineplus">+            data = zlib.compress(data)</span>
<a href="#l16.2679"></a><span id="l16.2679" class="difflineplus">+            return (chunk[0], data)</span>
<a href="#l16.2680"></a><span id="l16.2680" class="difflineplus">+        self.assertRaises(FormatError, self.helperFormat, eachchunk)</span>
<a href="#l16.2681"></a><span id="l16.2681" class="difflineplus">+    def helperFormat(self, f):</span>
<a href="#l16.2682"></a><span id="l16.2682" class="difflineplus">+        r = Reader(bytes=_pngsuite['basn0g01'])</span>
<a href="#l16.2683"></a><span id="l16.2683" class="difflineplus">+        o = BytesIO()</span>
<a href="#l16.2684"></a><span id="l16.2684" class="difflineplus">+        def newchunks():</span>
<a href="#l16.2685"></a><span id="l16.2685" class="difflineplus">+            for chunk in r.chunks():</span>
<a href="#l16.2686"></a><span id="l16.2686" class="difflineplus">+                yield f(chunk)</span>
<a href="#l16.2687"></a><span id="l16.2687" class="difflineplus">+        write_chunks(o, newchunks())</span>
<a href="#l16.2688"></a><span id="l16.2688" class="difflineplus">+        r = Reader(bytes=o.getvalue())</span>
<a href="#l16.2689"></a><span id="l16.2689" class="difflineplus">+        return list(r.asDirect()[2])</span>
<a href="#l16.2690"></a><span id="l16.2690" class="difflineplus">+    def testBadFilter(self):</span>
<a href="#l16.2691"></a><span id="l16.2691" class="difflineplus">+        def eachchunk(chunk):</span>
<a href="#l16.2692"></a><span id="l16.2692" class="difflineplus">+            if chunk[0] != 'IDAT':</span>
<a href="#l16.2693"></a><span id="l16.2693" class="difflineplus">+                return chunk</span>
<a href="#l16.2694"></a><span id="l16.2694" class="difflineplus">+            data = zlib.decompress(chunk[1])</span>
<a href="#l16.2695"></a><span id="l16.2695" class="difflineplus">+            # Corrupt the first filter byte</span>
<a href="#l16.2696"></a><span id="l16.2696" class="difflineplus">+            data = strtobytes('\x99') + data[1:]</span>
<a href="#l16.2697"></a><span id="l16.2697" class="difflineplus">+            data = zlib.compress(data)</span>
<a href="#l16.2698"></a><span id="l16.2698" class="difflineplus">+            return (chunk[0], data)</span>
<a href="#l16.2699"></a><span id="l16.2699" class="difflineplus">+        self.assertRaises(FormatError, self.helperFormat, eachchunk)</span>
<a href="#l16.2700"></a><span id="l16.2700" class="difflineplus">+    def testFlat(self):</span>
<a href="#l16.2701"></a><span id="l16.2701" class="difflineplus">+        &quot;&quot;&quot;Test read_flat.&quot;&quot;&quot;</span>
<a href="#l16.2702"></a><span id="l16.2702" class="difflineplus">+        import hashlib</span>
<a href="#l16.2703"></a><span id="l16.2703" class="difflineplus">+</span>
<a href="#l16.2704"></a><span id="l16.2704" class="difflineplus">+        r = Reader(bytes=_pngsuite['basn0g02'])</span>
<a href="#l16.2705"></a><span id="l16.2705" class="difflineplus">+        x,y,pixel,meta = r.read_flat()</span>
<a href="#l16.2706"></a><span id="l16.2706" class="difflineplus">+        d = hashlib.md5(seqtobytes(pixel)).digest()</span>
<a href="#l16.2707"></a><span id="l16.2707" class="difflineplus">+        self.assertEqual(_enhex(d), '255cd971ab8cd9e7275ff906e5041aa0')</span>
<a href="#l16.2708"></a><span id="l16.2708" class="difflineplus">+    def testfromarray(self):</span>
<a href="#l16.2709"></a><span id="l16.2709" class="difflineplus">+        img = from_array([[0, 0x33, 0x66], [0xff, 0xcc, 0x99]], 'L')</span>
<a href="#l16.2710"></a><span id="l16.2710" class="difflineplus">+        img.save('testfromarray.png')</span>
<a href="#l16.2711"></a><span id="l16.2711" class="difflineplus">+    def testfromarrayL16(self):</span>
<a href="#l16.2712"></a><span id="l16.2712" class="difflineplus">+        img = from_array(group(range(2**16), 256), 'L;16')</span>
<a href="#l16.2713"></a><span id="l16.2713" class="difflineplus">+        img.save('testL16.png')</span>
<a href="#l16.2714"></a><span id="l16.2714" class="difflineplus">+    def testfromarrayRGB(self):</span>
<a href="#l16.2715"></a><span id="l16.2715" class="difflineplus">+        img = from_array([[0,0,0, 0,0,1, 0,1,0, 0,1,1],</span>
<a href="#l16.2716"></a><span id="l16.2716" class="difflineplus">+                          [1,0,0, 1,0,1, 1,1,0, 1,1,1]], 'RGB;1')</span>
<a href="#l16.2717"></a><span id="l16.2717" class="difflineplus">+        o = BytesIO()</span>
<a href="#l16.2718"></a><span id="l16.2718" class="difflineplus">+        img.save(o)</span>
<a href="#l16.2719"></a><span id="l16.2719" class="difflineplus">+    def testfromarrayIter(self):</span>
<a href="#l16.2720"></a><span id="l16.2720" class="difflineplus">+        import itertools</span>
<a href="#l16.2721"></a><span id="l16.2721" class="difflineplus">+</span>
<a href="#l16.2722"></a><span id="l16.2722" class="difflineplus">+        i = itertools.islice(itertools.count(10), 20)</span>
<a href="#l16.2723"></a><span id="l16.2723" class="difflineplus">+        i = itertools.imap(lambda x: [x, x, x], i)</span>
<a href="#l16.2724"></a><span id="l16.2724" class="difflineplus">+        img = from_array(i, 'RGB;5', dict(height=20))</span>
<a href="#l16.2725"></a><span id="l16.2725" class="difflineplus">+        f = open('testiter.png', 'wb')</span>
<a href="#l16.2726"></a><span id="l16.2726" class="difflineplus">+        img.save(f)</span>
<a href="#l16.2727"></a><span id="l16.2727" class="difflineplus">+        f.close()</span>
<a href="#l16.2728"></a><span id="l16.2728" class="difflineplus">+</span>
<a href="#l16.2729"></a><span id="l16.2729" class="difflineplus">+    # numpy dependent tests.  These are skipped (with a message to</span>
<a href="#l16.2730"></a><span id="l16.2730" class="difflineplus">+    # sys.stderr) if numpy cannot be imported.</span>
<a href="#l16.2731"></a><span id="l16.2731" class="difflineplus">+    def testNumpyuint16(self):</span>
<a href="#l16.2732"></a><span id="l16.2732" class="difflineplus">+        &quot;&quot;&quot;numpy uint16.&quot;&quot;&quot;</span>
<a href="#l16.2733"></a><span id="l16.2733" class="difflineplus">+</span>
<a href="#l16.2734"></a><span id="l16.2734" class="difflineplus">+        try:</span>
<a href="#l16.2735"></a><span id="l16.2735" class="difflineplus">+            import numpy</span>
<a href="#l16.2736"></a><span id="l16.2736" class="difflineplus">+        except ImportError:</span>
<a href="#l16.2737"></a><span id="l16.2737" class="difflineplus">+            print &gt;&gt;sys.stderr, &quot;skipping numpy test&quot;</span>
<a href="#l16.2738"></a><span id="l16.2738" class="difflineplus">+            return</span>
<a href="#l16.2739"></a><span id="l16.2739" class="difflineplus">+</span>
<a href="#l16.2740"></a><span id="l16.2740" class="difflineplus">+        rows = [map(numpy.uint16, range(0,0x10000,0x5555))]</span>
<a href="#l16.2741"></a><span id="l16.2741" class="difflineplus">+        b = topngbytes('numpyuint16.png', rows, 4, 1,</span>
<a href="#l16.2742"></a><span id="l16.2742" class="difflineplus">+            greyscale=True, alpha=False, bitdepth=16)</span>
<a href="#l16.2743"></a><span id="l16.2743" class="difflineplus">+    def testNumpyuint8(self):</span>
<a href="#l16.2744"></a><span id="l16.2744" class="difflineplus">+        &quot;&quot;&quot;numpy uint8.&quot;&quot;&quot;</span>
<a href="#l16.2745"></a><span id="l16.2745" class="difflineplus">+</span>
<a href="#l16.2746"></a><span id="l16.2746" class="difflineplus">+        try:</span>
<a href="#l16.2747"></a><span id="l16.2747" class="difflineplus">+            import numpy</span>
<a href="#l16.2748"></a><span id="l16.2748" class="difflineplus">+        except ImportError:</span>
<a href="#l16.2749"></a><span id="l16.2749" class="difflineplus">+            print &gt;&gt;sys.stderr, &quot;skipping numpy test&quot;</span>
<a href="#l16.2750"></a><span id="l16.2750" class="difflineplus">+            return</span>
<a href="#l16.2751"></a><span id="l16.2751" class="difflineplus">+</span>
<a href="#l16.2752"></a><span id="l16.2752" class="difflineplus">+        rows = [map(numpy.uint8, range(0,0x100,0x55))]</span>
<a href="#l16.2753"></a><span id="l16.2753" class="difflineplus">+        b = topngbytes('numpyuint8.png', rows, 4, 1,</span>
<a href="#l16.2754"></a><span id="l16.2754" class="difflineplus">+            greyscale=True, alpha=False, bitdepth=8)</span>
<a href="#l16.2755"></a><span id="l16.2755" class="difflineplus">+    def testNumpybool(self):</span>
<a href="#l16.2756"></a><span id="l16.2756" class="difflineplus">+        &quot;&quot;&quot;numpy bool.&quot;&quot;&quot;</span>
<a href="#l16.2757"></a><span id="l16.2757" class="difflineplus">+</span>
<a href="#l16.2758"></a><span id="l16.2758" class="difflineplus">+        try:</span>
<a href="#l16.2759"></a><span id="l16.2759" class="difflineplus">+            import numpy</span>
<a href="#l16.2760"></a><span id="l16.2760" class="difflineplus">+        except ImportError:</span>
<a href="#l16.2761"></a><span id="l16.2761" class="difflineplus">+            print &gt;&gt;sys.stderr, &quot;skipping numpy test&quot;</span>
<a href="#l16.2762"></a><span id="l16.2762" class="difflineplus">+            return</span>
<a href="#l16.2763"></a><span id="l16.2763" class="difflineplus">+</span>
<a href="#l16.2764"></a><span id="l16.2764" class="difflineplus">+        rows = [map(numpy.bool, [0,1])]</span>
<a href="#l16.2765"></a><span id="l16.2765" class="difflineplus">+        b = topngbytes('numpybool.png', rows, 2, 1,</span>
<a href="#l16.2766"></a><span id="l16.2766" class="difflineplus">+            greyscale=True, alpha=False, bitdepth=1)</span>
<a href="#l16.2767"></a><span id="l16.2767" class="difflineplus">+    def testNumpyarray(self):</span>
<a href="#l16.2768"></a><span id="l16.2768" class="difflineplus">+        &quot;&quot;&quot;numpy array.&quot;&quot;&quot;</span>
<a href="#l16.2769"></a><span id="l16.2769" class="difflineplus">+        try:</span>
<a href="#l16.2770"></a><span id="l16.2770" class="difflineplus">+            import numpy</span>
<a href="#l16.2771"></a><span id="l16.2771" class="difflineplus">+        except ImportError:</span>
<a href="#l16.2772"></a><span id="l16.2772" class="difflineplus">+            print &gt;&gt;sys.stderr, &quot;skipping numpy test&quot;</span>
<a href="#l16.2773"></a><span id="l16.2773" class="difflineplus">+            return</span>
<a href="#l16.2774"></a><span id="l16.2774" class="difflineplus">+</span>
<a href="#l16.2775"></a><span id="l16.2775" class="difflineplus">+        pixels = numpy.array([[0,0x5555],[0x5555,0xaaaa]], numpy.uint16)</span>
<a href="#l16.2776"></a><span id="l16.2776" class="difflineplus">+        img = from_array(pixels, 'L')</span>
<a href="#l16.2777"></a><span id="l16.2777" class="difflineplus">+        img.save('testnumpyL16.png')</span>
<a href="#l16.2778"></a><span id="l16.2778" class="difflineplus">+</span>
<a href="#l16.2779"></a><span id="l16.2779" class="difflineplus">+# === Command Line Support ===</span>
<a href="#l16.2780"></a><span id="l16.2780" class="difflineplus">+</span>
<a href="#l16.2781"></a><span id="l16.2781" class="difflineplus">+def _dehex(s):</span>
<a href="#l16.2782"></a><span id="l16.2782" class="difflineplus">+    &quot;&quot;&quot;Liberally convert from hex string to binary string.&quot;&quot;&quot;</span>
<a href="#l16.2783"></a><span id="l16.2783" class="difflineplus">+    import re</span>
<a href="#l16.2784"></a><span id="l16.2784" class="difflineplus">+    import binascii</span>
<a href="#l16.2785"></a><span id="l16.2785" class="difflineplus">+</span>
<a href="#l16.2786"></a><span id="l16.2786" class="difflineplus">+    # Remove all non-hexadecimal digits</span>
<a href="#l16.2787"></a><span id="l16.2787" class="difflineplus">+    s = re.sub(r'[^a-fA-F\d]', '', s)</span>
<a href="#l16.2788"></a><span id="l16.2788" class="difflineplus">+    # binscii.unhexlify works in Python 2 and Python 3 (unlike</span>
<a href="#l16.2789"></a><span id="l16.2789" class="difflineplus">+    # thing.decode('hex')).</span>
<a href="#l16.2790"></a><span id="l16.2790" class="difflineplus">+    return binascii.unhexlify(strtobytes(s))</span>
<a href="#l16.2791"></a><span id="l16.2791" class="difflineplus">+def _enhex(s):</span>
<a href="#l16.2792"></a><span id="l16.2792" class="difflineplus">+    &quot;&quot;&quot;Convert from binary string (bytes) to hex string (str).&quot;&quot;&quot;</span>
<a href="#l16.2793"></a><span id="l16.2793" class="difflineplus">+</span>
<a href="#l16.2794"></a><span id="l16.2794" class="difflineplus">+    import binascii</span>
<a href="#l16.2795"></a><span id="l16.2795" class="difflineplus">+</span>
<a href="#l16.2796"></a><span id="l16.2796" class="difflineplus">+    return bytestostr(binascii.hexlify(s))</span>
<a href="#l16.2797"></a><span id="l16.2797" class="difflineplus">+</span>
<a href="#l16.2798"></a><span id="l16.2798" class="difflineplus">+# Copies of PngSuite test files taken</span>
<a href="#l16.2799"></a><span id="l16.2799" class="difflineplus">+# from http://www.schaik.com/pngsuite/pngsuite_bas_png.html</span>
<a href="#l16.2800"></a><span id="l16.2800" class="difflineplus">+# on 2009-02-19 by drj and converted to hex.</span>
<a href="#l16.2801"></a><span id="l16.2801" class="difflineplus">+# Some of these are not actually in PngSuite (but maybe they should</span>
<a href="#l16.2802"></a><span id="l16.2802" class="difflineplus">+# be?), they use the same naming scheme, but start with a capital</span>
<a href="#l16.2803"></a><span id="l16.2803" class="difflineplus">+# letter.</span>
<a href="#l16.2804"></a><span id="l16.2804" class="difflineplus">+_pngsuite = {</span>
<a href="#l16.2805"></a><span id="l16.2805" class="difflineplus">+  'basi0g01': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2806"></a><span id="l16.2806" class="difflineplus">+89504e470d0a1a0a0000000d49484452000000200000002001000000012c0677</span>
<a href="#l16.2807"></a><span id="l16.2807" class="difflineplus">+cf0000000467414d41000186a031e8965f0000009049444154789c2d8d310ec2</span>
<a href="#l16.2808"></a><span id="l16.2808" class="difflineplus">+300c45dfc682c415187a00a42e197ab81e83b127e00c5639001363a580d8582c</span>
<a href="#l16.2809"></a><span id="l16.2809" class="difflineplus">+65c910357c4b78b0bfbfdf4f70168c19e7acb970a3f2d1ded9695ce5bf5963df</span>
<a href="#l16.2810"></a><span id="l16.2810" class="difflineplus">+d92aaf4c9fd927ea449e6487df5b9c36e799b91bdf082b4d4bd4014fe4014b01</span>
<a href="#l16.2811"></a><span id="l16.2811" class="difflineplus">+ab7a17aee694d28d328a2d63837a70451e1648702d9a9ff4a11d2f7a51aa21e5</span>
<a href="#l16.2812"></a><span id="l16.2812" class="difflineplus">+a18c7ffd0094e3511d661822f20000000049454e44ae426082</span>
<a href="#l16.2813"></a><span id="l16.2813" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2814"></a><span id="l16.2814" class="difflineplus">+  'basi0g02': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2815"></a><span id="l16.2815" class="difflineplus">+89504e470d0a1a0a0000000d49484452000000200000002002000000016ba60d</span>
<a href="#l16.2816"></a><span id="l16.2816" class="difflineplus">+1f0000000467414d41000186a031e8965f0000005149444154789c635062e860</span>
<a href="#l16.2817"></a><span id="l16.2817" class="difflineplus">+00e17286bb609c93c370ec189494960631366e4467b3ae675dcf10f521ea0303</span>
<a href="#l16.2818"></a><span id="l16.2818" class="difflineplus">+90c1ca006444e11643482064114a4852c710baea3f18c31918020c30410403a6</span>
<a href="#l16.2819"></a><span id="l16.2819" class="difflineplus">+0ac1a09239009c52804d85b6d97d0000000049454e44ae426082</span>
<a href="#l16.2820"></a><span id="l16.2820" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2821"></a><span id="l16.2821" class="difflineplus">+  'basi0g04': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2822"></a><span id="l16.2822" class="difflineplus">+89504e470d0a1a0a0000000d4948445200000020000000200400000001e4e6f8</span>
<a href="#l16.2823"></a><span id="l16.2823" class="difflineplus">+bf0000000467414d41000186a031e8965f000000ae49444154789c658e5111c2</span>
<a href="#l16.2824"></a><span id="l16.2824" class="difflineplus">+301044171c141c141c041c843a287510ea20d441c041c141c141c04191102454</span>
<a href="#l16.2825"></a><span id="l16.2825" class="difflineplus">+03994998cecd7edcecedbb9bdbc3b2c2b6457545fbc4bac1be437347f7c66a77</span>
<a href="#l16.2826"></a><span id="l16.2826" class="difflineplus">+3c23d60db15e88f5c5627338a5416c2e691a9b475a89cd27eda12895ae8dfdab</span>
<a href="#l16.2827"></a><span id="l16.2827" class="difflineplus">+43d61e590764f5c83a226b40d669bec307f93247701687723abf31ff83a2284b</span>
<a href="#l16.2828"></a><span id="l16.2828" class="difflineplus">+a5b4ae6b63ac6520ad730ca4ed7b06d20e030369bd6720ed383290360406d24e</span>
<a href="#l16.2829"></a><span id="l16.2829" class="difflineplus">+13811f2781eba9d34d07160000000049454e44ae426082</span>
<a href="#l16.2830"></a><span id="l16.2830" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2831"></a><span id="l16.2831" class="difflineplus">+  'basi0g08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2832"></a><span id="l16.2832" class="difflineplus">+89504e470d0a1a0a0000000d4948445200000020000000200800000001211615</span>
<a href="#l16.2833"></a><span id="l16.2833" class="difflineplus">+be0000000467414d41000186a031e8965f000000b549444154789cb5905d0ac2</span>
<a href="#l16.2834"></a><span id="l16.2834" class="difflineplus">+3010849dbac81c42c47bf843cf253e8878b0aa17110f214bdca6be240f5d21a5</span>
<a href="#l16.2835"></a><span id="l16.2835" class="difflineplus">+94ced3e49bcd322c1624115515154998aa424822a82a5624a1aa8a8b24c58f99</span>
<a href="#l16.2836"></a><span id="l16.2836" class="difflineplus">+999908130989a04a00d76c2c09e76cf21adcb209393a6553577da17140a2c59e</span>
<a href="#l16.2837"></a><span id="l16.2837" class="difflineplus">+70ecbfa388dff1f03b82fb82bd07f05f7cb13f80bb07ad2fd60c011c3c588eef</span>
<a href="#l16.2838"></a><span id="l16.2838" class="difflineplus">+f1f4e03bbec7ce832dca927aea005e431b625796345307b019c845e6bfc3bb98</span>
<a href="#l16.2839"></a><span id="l16.2839" class="difflineplus">+769d84f9efb02ea6c00f9bb9ff45e81f9f280000000049454e44ae426082</span>
<a href="#l16.2840"></a><span id="l16.2840" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2841"></a><span id="l16.2841" class="difflineplus">+  'basi0g16': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2842"></a><span id="l16.2842" class="difflineplus">+89504e470d0a1a0a0000000d49484452000000200000002010000000017186c9</span>
<a href="#l16.2843"></a><span id="l16.2843" class="difflineplus">+fd0000000467414d41000186a031e8965f000000e249444154789cb5913b0ec2</span>
<a href="#l16.2844"></a><span id="l16.2844" class="difflineplus">+301044c7490aa8f85d81c3e4301c8f53a4ca0da8902c8144b3920b4043111282</span>
<a href="#l16.2845"></a><span id="l16.2845" class="difflineplus">+23bc4956681a6bf5fc3c5a3ba0448912d91a4de2c38dd8e380231eede4c4f7a1</span>
<a href="#l16.2846"></a><span id="l16.2846" class="difflineplus">+4677700bec7bd9b1d344689315a3418d1a6efbe5b8305ba01f8ff4808c063e26</span>
<a href="#l16.2847"></a><span id="l16.2847" class="difflineplus">+c60d5c81edcf6c58c535e252839e93801b15c0a70d810ae0d306b205dc32b187</span>
<a href="#l16.2848"></a><span id="l16.2848" class="difflineplus">+272b64057e4720ff0502154034831520154034c3df81400510cdf0015c86e5cc</span>
<a href="#l16.2849"></a><span id="l16.2849" class="difflineplus">+5c79c639fddba9dcb5456b51d7980eb52d8e7d7fa620a75120d6064641a05120</span>
<a href="#l16.2850"></a><span id="l16.2850" class="difflineplus">+b606771a05626b401a05f1f589827cf0fe44c1f0bae0055698ee8914fffffe00</span>
<a href="#l16.2851"></a><span id="l16.2851" class="difflineplus">+00000049454e44ae426082</span>
<a href="#l16.2852"></a><span id="l16.2852" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2853"></a><span id="l16.2853" class="difflineplus">+  'basi2c08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2854"></a><span id="l16.2854" class="difflineplus">+89504e470d0a1a0a0000000d49484452000000200000002008020000018b1fdd</span>
<a href="#l16.2855"></a><span id="l16.2855" class="difflineplus">+350000000467414d41000186a031e8965f000000f249444154789cd59341aa04</span>
<a href="#l16.2856"></a><span id="l16.2856" class="difflineplus">+210c44abc07b78133d59d37333bd89d76868b566d10cf4675af8596431a11662</span>
<a href="#l16.2857"></a><span id="l16.2857" class="difflineplus">+7c5688919280e312257dd6a0a4cf1a01008ee312a5f3c69c37e6fcc3f47e6776</span>
<a href="#l16.2858"></a><span id="l16.2858" class="difflineplus">+a07f8bdaf5b40feed2d33e025e2ff4fe2d4a63e1a16d91180b736d8bc45854c5</span>
<a href="#l16.2859"></a><span id="l16.2859" class="difflineplus">+6d951863f4a7e0b66dcf09a900f3ffa2948d4091e53ca86c048a64390f662b50</span>
<a href="#l16.2860"></a><span id="l16.2860" class="difflineplus">+4a999660ced906182b9a01a8be00a56404a6ede182b1223b4025e32c4de34304</span>
<a href="#l16.2861"></a><span id="l16.2861" class="difflineplus">+63457680c93aada6c99b73865aab2fc094920d901a203f5ddfe1970d28456783</span>
<a href="#l16.2862"></a><span id="l16.2862" class="difflineplus">+26cffbafeffcd30654f46d119be4793f827387fc0d189d5bc4d69a3c23d45a7f</span>
<a href="#l16.2863"></a><span id="l16.2863" class="difflineplus">+db803146578337df4d0a3121fc3d330000000049454e44ae426082</span>
<a href="#l16.2864"></a><span id="l16.2864" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2865"></a><span id="l16.2865" class="difflineplus">+  'basi2c16': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2866"></a><span id="l16.2866" class="difflineplus">+89504e470d0a1a0a0000000d4948445200000020000000201002000001db8f01</span>
<a href="#l16.2867"></a><span id="l16.2867" class="difflineplus">+760000000467414d41000186a031e8965f0000020a49444154789cd5962173e3</span>
<a href="#l16.2868"></a><span id="l16.2868" class="difflineplus">+3010853fcf1838cc61a1818185a53e56787fa13fa130852e3b5878b4b0b03081</span>
<a href="#l16.2869"></a><span id="l16.2869" class="difflineplus">+b97f7030070b53e6b057a0a8912bbb9163b9f109ececbc59bd7dcf2b45492409</span>
<a href="#l16.2870"></a><span id="l16.2870" class="difflineplus">+d66f00eb1dd83cb5497d65456aeb8e1040913b3b2c04504c936dd5a9c7e2c6eb</span>
<a href="#l16.2871"></a><span id="l16.2871" class="difflineplus">+b1b8f17a58e8d043da56f06f0f9f62e5217b6ba3a1b76f6c9e99e8696a2a72e2</span>
<a href="#l16.2872"></a><span id="l16.2872" class="difflineplus">+c4fb1e4d452e92ec9652b807486d12b6669be00db38d9114b0c1961e375461a5</span>
<a href="#l16.2873"></a><span id="l16.2873" class="difflineplus">+5f76682a85c367ad6f682ff53a9c2a353191764b78bb07d8ddc3c97c1950f391</span>
<a href="#l16.2874"></a><span id="l16.2874" class="difflineplus">+6745c7b9852c73c2f212605a466a502705c8338069c8b9e84efab941eb393a97</span>
<a href="#l16.2875"></a><span id="l16.2875" class="difflineplus">+d4c9fd63148314209f1c1d3434e847ead6380de291d6f26a25c1ebb5047f5f24</span>
<a href="#l16.2876"></a><span id="l16.2876" class="difflineplus">+d85c49f0f22cc1d34282c72709cab90477bf25b89d49f0f351822297e0ea9704</span>
<a href="#l16.2877"></a><span id="l16.2877" class="difflineplus">+f34c82bc94002448ede51866e5656aef5d7c6a385cb4d80e6a538ceba04e6df2</span>
<a href="#l16.2878"></a><span id="l16.2878" class="difflineplus">+480e9aa84ddedb413bb5c97b3838456df2d4fec2c7a706983e7474d085fae820</span>
<a href="#l16.2879"></a><span id="l16.2879" class="difflineplus">+a841776a83073838973ac0413fea2f1dc4a06e71108fda73109bdae48954ad60</span>
<a href="#l16.2880"></a><span id="l16.2880" class="difflineplus">+bf867aac3ce44c7c1589a711cf8a81df9b219679d96d1cec3d8bbbeaa2012626</span>
<a href="#l16.2881"></a><span id="l16.2881" class="difflineplus">+df8c7802eda201b2d2e0239b409868171fc104ba8b76f10b4da09f6817ffc609</span>
<a href="#l16.2882"></a><span id="l16.2882" class="difflineplus">+c413ede267fd1fbab46880c90f80eccf0013185eb48b47ba03df2bdaadef3181</span>
<a href="#l16.2883"></a><span id="l16.2883" class="difflineplus">+cb8976f18e13188768170f98c0f844bb78cb04c62ddac59d09fc3fa25dfc1da4</span>
<a href="#l16.2884"></a><span id="l16.2884" class="difflineplus">+14deb3df1344f70000000049454e44ae426082</span>
<a href="#l16.2885"></a><span id="l16.2885" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2886"></a><span id="l16.2886" class="difflineplus">+  'basi3p08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2887"></a><span id="l16.2887" class="difflineplus">+89504e470d0a1a0a0000000d494844520000002000000020080300000133a3ba</span>
<a href="#l16.2888"></a><span id="l16.2888" class="difflineplus">+500000000467414d41000186a031e8965f00000300504c5445224400f5ffed77</span>
<a href="#l16.2889"></a><span id="l16.2889" class="difflineplus">+ff77cbffff110a003a77002222ffff11ff110000222200ffac5566ff66ff6666</span>
<a href="#l16.2890"></a><span id="l16.2890" class="difflineplus">+ff01ff221200dcffffccff994444ff005555220000cbcbff44440055ff55cbcb</span>
<a href="#l16.2891"></a><span id="l16.2891" class="difflineplus">+00331a00ffecdcedffffe4ffcbffdcdc44ff446666ff330000442200ededff66</span>
<a href="#l16.2892"></a><span id="l16.2892" class="difflineplus">+6600ffa444ffffaaeded0000cbcbfefffffdfffeffff0133ff33552a000101ff</span>
<a href="#l16.2893"></a><span id="l16.2893" class="difflineplus">+8888ff00aaaa010100440000888800ffe4cbba5b0022ff22663200ffff99aaaa</span>
<a href="#l16.2894"></a><span id="l16.2894" class="difflineplus">+ff550000aaaa00cb630011ff11d4ffaa773a00ff4444dc6b0066000001ff0188</span>
<a href="#l16.2895"></a><span id="l16.2895" class="difflineplus">+4200ecffdc6bdc00ffdcba00333300ed00ed7300ffff88994a0011ffff770000</span>
<a href="#l16.2896"></a><span id="l16.2896" class="difflineplus">+ff8301ffbabafe7b00fffeff00cb00ff999922ffff880000ffff77008888ffdc</span>
<a href="#l16.2897"></a><span id="l16.2897" class="difflineplus">+ff1a33000000aa33ffff009900990000000001326600ffbaff44ffffffaaff00</span>
<a href="#l16.2898"></a><span id="l16.2898" class="difflineplus">+770000fefeaa00004a9900ffff66ff22220000998bff1155ffffff0101ff88ff</span>
<a href="#l16.2899"></a><span id="l16.2899" class="difflineplus">+005500001111fffffefffdfea4ff4466ffffff66ff003300ffff55ff77770000</span>
<a href="#l16.2900"></a><span id="l16.2900" class="difflineplus">+88ff44ff00110077ffff006666ffffed000100fff5ed1111ffffff44ff22ffff</span>
<a href="#l16.2901"></a><span id="l16.2901" class="difflineplus">+eded11110088ffff00007793ff2200dcdc3333fffe00febabaff99ffff333300</span>
<a href="#l16.2902"></a><span id="l16.2902" class="difflineplus">+63cb00baba00acff55ffffdcffff337bfe00ed00ed5555ffaaffffdcdcff5555</span>
<a href="#l16.2903"></a><span id="l16.2903" class="difflineplus">+00000066dcdc00dc00dc83ff017777fffefeffffffcbff5555777700fefe00cb</span>
<a href="#l16.2904"></a><span id="l16.2904" class="difflineplus">+00cb0000fe010200010000122200ffff220044449bff33ffd4aa0000559999ff</span>
<a href="#l16.2905"></a><span id="l16.2905" class="difflineplus">+999900ba00ba2a5500ffcbcbb4ff66ff9b33ffffbaaa00aa42880053aa00ffaa</span>
<a href="#l16.2906"></a><span id="l16.2906" class="difflineplus">+aa0000ed00babaffff1100fe00000044009999990099ffcc99ba000088008800</span>
<a href="#l16.2907"></a><span id="l16.2907" class="difflineplus">+dc00ff93220000dcfefffeaa5300770077020100cb0000000033ffedff00ba00</span>
<a href="#l16.2908"></a><span id="l16.2908" class="difflineplus">+ff3333edffedffc488bcff7700aa00660066002222dc0000ffcbffdcffdcff8b</span>
<a href="#l16.2909"></a><span id="l16.2909" class="difflineplus">+110000cb00010155005500880000002201ffffcbffcbed0000ff88884400445b</span>
<a href="#l16.2910"></a><span id="l16.2910" class="difflineplus">+ba00ffbc77ff99ff006600baffba00777773ed00fe00003300330000baff77ff</span>
<a href="#l16.2911"></a><span id="l16.2911" class="difflineplus">+004400aaffaafffefe000011220022c4ff8800eded99ff99ff55ff002200ffb4</span>
<a href="#l16.2912"></a><span id="l16.2912" class="difflineplus">+661100110a1100ff1111dcffbabaffff88ff88010001ff33ffb98ed362000002</span>
<a href="#l16.2913"></a><span id="l16.2913" class="difflineplus">+a249444154789c65d0695c0b001806f03711a9904a94d24dac63292949e5a810</span>
<a href="#l16.2914"></a><span id="l16.2914" class="difflineplus">+d244588a14ca5161d1a1323973252242d62157d12ae498c8124d25ca3a11398a</span>
<a href="#l16.2915"></a><span id="l16.2915" class="difflineplus">+16e55a3cdffab0ffe7f77d7fcff3528645349b584c3187824d9d19d4ec2e3523</span>
<a href="#l16.2916"></a><span id="l16.2916" class="difflineplus">+9eb0ae975cf8de02f2486d502191841b42967a1ad49e5ddc4265f69a899e26b5</span>
<a href="#l16.2917"></a><span id="l16.2917" class="difflineplus">+e9e468181baae3a71a41b95669da8df2ea3594c1b31046d7b17bfb86592e4cbe</span>
<a href="#l16.2918"></a><span id="l16.2918" class="difflineplus">+d89b23e8db0af6304d756e60a8f4ad378bdc2552ae5948df1d35b52143141533</span>
<a href="#l16.2919"></a><span id="l16.2919" class="difflineplus">+33bbbbababebeb3b3bc9c9c9c6c6c0c0d7b7b535323225a5aa8a02024a4bedec</span>
<a href="#l16.2920"></a><span id="l16.2920" class="difflineplus">+0a0a2a2bcdcd7d7cf2f3a9a9c9cdcdd8b8adcdd5b5ababa828298982824a4ab2</span>
<a href="#l16.2921"></a><span id="l16.2921" class="difflineplus">+b21212acadbdbc1414e2e24859b9a72730302f4f49292c4c57373c9c0a0b7372</span>
<a href="#l16.2922"></a><span id="l16.2922" class="difflineplus">+8c8c1c1c3a3a92936d6dfdfd293e3e26262a4a4eaea2424b4b5fbfbc9c323278</span>
<a href="#l16.2923"></a><span id="l16.2923" class="difflineplus">+3c0b0ba1303abaae8ecdeeed950d6669a9a7a7a141d4de9e9d5d5cdcd2229b94</span>
<a href="#l16.2924"></a><span id="l16.2924" class="difflineplus">+c572716132f97cb1d8db9bc3110864a39795d9db6b6a26267a7a9a98d4d6a6a7</span>
<a href="#l16.2925"></a><span id="l16.2925" class="difflineplus">+cb76090ef6f030354d4d75766e686030545464cb393a1a1ac6c68686eae8f8f9</span>
<a href="#l16.2926"></a><span id="l16.2926" class="difflineplus">+a9aa4644c8b66d6e1689dcdd2512a994cb35330b0991ad9f9b6b659596a6addd</span>
<a href="#l16.2927"></a><span id="l16.2927" class="difflineplus">+d8282fafae5e5323fb8f41d01f76c22fd8061be01bfc041a0323e1002c81cd30</span>
<a href="#l16.2928"></a><span id="l16.2928" class="difflineplus">+0b9ec027a0c930014ec035580fc3e112bc069a0b53e11c0c8095f00176c163a0</span>
<a href="#l16.2929"></a><span id="l16.2929" class="difflineplus">+e5301baec06a580677600ddc05ba0f13e120bc81a770133ec355a017300d4ec2</span>
<a href="#l16.2930"></a><span id="l16.2930" class="difflineplus">+0c7800bbe1219c02fa08f3e13c1c85dbb00a2ec05ea0dff00a6ec15a98027360</span>
<a href="#l16.2931"></a><span id="l16.2931" class="difflineplus">+070c047a06d7e1085c84f1b014f6c03fa0b33018b6c0211801ebe018fc00da0a</span>
<a href="#l16.2932"></a><span id="l16.2932" class="difflineplus">+6f61113c877eb01d4ec317a085700f26c130f80efbe132bc039a0733e106fc81</span>
<a href="#l16.2933"></a><span id="l16.2933" class="difflineplus">+f7f017f6c10aa0d1300a0ec374780943e1382c06fa0a9b60238c83473016cec0</span>
<a href="#l16.2934"></a><span id="l16.2934" class="difflineplus">+02f80f73fefe1072afc1e50000000049454e44ae426082</span>
<a href="#l16.2935"></a><span id="l16.2935" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2936"></a><span id="l16.2936" class="difflineplus">+  'basi6a08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2937"></a><span id="l16.2937" class="difflineplus">+89504e470d0a1a0a0000000d4948445200000020000000200806000001047d4a</span>
<a href="#l16.2938"></a><span id="l16.2938" class="difflineplus">+620000000467414d41000186a031e8965f0000012049444154789cc595414ec3</span>
<a href="#l16.2939"></a><span id="l16.2939" class="difflineplus">+3010459fa541b8bbb26641b8069b861e8b4d12c1c112c1452a710a2a65d840d5</span>
<a href="#l16.2940"></a><span id="l16.2940" class="difflineplus">+949041fc481ec98ae27c7f3f8d27e3e4648047600fec0d1f390fbbe2633a31e2</span>
<a href="#l16.2941"></a><span id="l16.2941" class="difflineplus">+9389e4e4ea7bfdbf3d9a6b800ab89f1bd6b553cfcbb0679e960563d72e0a9293</span>
<a href="#l16.2942"></a><span id="l16.2942" class="difflineplus">+b7337b9f988cc67f5f0e186d20e808042f1c97054e1309da40d02d7e27f92e03</span>
<a href="#l16.2943"></a><span id="l16.2943" class="difflineplus">+6cbfc64df0fc3117a6210a1b6ad1a00df21c1abcf2a01944c7101b0cb568a001</span>
<a href="#l16.2944"></a><span id="l16.2944" class="difflineplus">+909c9cf9e399cf3d8d9d4660a875405d9a60d000b05e2de55e25780b7a5268e0</span>
<a href="#l16.2945"></a><span id="l16.2945" class="difflineplus">+622118e2399aab063a815808462f1ab86890fc2e03e48bb109ded7d26ce4bf59</span>
<a href="#l16.2946"></a><span id="l16.2946" class="difflineplus">+0db91bac0050747fec5015ce80da0e5700281be533f0ce6d5900b59bcb00ea6d</span>
<a href="#l16.2947"></a><span id="l16.2947" class="difflineplus">+200314cf801faab200ea752803a8d7a90c503a039f824a53f4694e7342000000</span>
<a href="#l16.2948"></a><span id="l16.2948" class="difflineplus">+0049454e44ae426082</span>
<a href="#l16.2949"></a><span id="l16.2949" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2950"></a><span id="l16.2950" class="difflineplus">+  'basn0g01': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2951"></a><span id="l16.2951" class="difflineplus">+89504e470d0a1a0a0000000d49484452000000200000002001000000005b0147</span>
<a href="#l16.2952"></a><span id="l16.2952" class="difflineplus">+590000000467414d41000186a031e8965f0000005b49444154789c2dccb10903</span>
<a href="#l16.2953"></a><span id="l16.2953" class="difflineplus">+300c05d1ebd204b24a200b7a346f90153c82c18d0a61450751f1e08a2faaead2</span>
<a href="#l16.2954"></a><span id="l16.2954" class="difflineplus">+a4846ccea9255306e753345712e211b221bf4b263d1b427325255e8bdab29e6f</span>
<a href="#l16.2955"></a><span id="l16.2955" class="difflineplus">+6aca30692e9d29616ee96f3065f0bf1f1087492fd02f14c90000000049454e44</span>
<a href="#l16.2956"></a><span id="l16.2956" class="difflineplus">+ae426082</span>
<a href="#l16.2957"></a><span id="l16.2957" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2958"></a><span id="l16.2958" class="difflineplus">+  'basn0g02': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2959"></a><span id="l16.2959" class="difflineplus">+89504e470d0a1a0a0000000d49484452000000200000002002000000001ca13d</span>
<a href="#l16.2960"></a><span id="l16.2960" class="difflineplus">+890000000467414d41000186a031e8965f0000001f49444154789c6360085df5</span>
<a href="#l16.2961"></a><span id="l16.2961" class="difflineplus">+1f8cf1308850c20053868f0133091f6390b90700bd497f818b0989a900000000</span>
<a href="#l16.2962"></a><span id="l16.2962" class="difflineplus">+49454e44ae426082</span>
<a href="#l16.2963"></a><span id="l16.2963" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2964"></a><span id="l16.2964" class="difflineplus">+  # A version of basn0g04 dithered down to 3 bits.</span>
<a href="#l16.2965"></a><span id="l16.2965" class="difflineplus">+  'Basn0g03': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2966"></a><span id="l16.2966" class="difflineplus">+89504e470d0a1a0a0000000d494844520000002000000020040000000093e1c8</span>
<a href="#l16.2967"></a><span id="l16.2967" class="difflineplus">+2900000001734249540371d88211000000fd49444154789c6d90d18906210c84</span>
<a href="#l16.2968"></a><span id="l16.2968" class="difflineplus">+c356f22356b2889588604301b112112b11d94a96bb495cf7fe87f32d996f2689</span>
<a href="#l16.2969"></a><span id="l16.2969" class="difflineplus">+44741cc658e39c0b118f883e1f63cc89dafbc04c0f619d7d898396c54b875517</span>
<a href="#l16.2970"></a><span id="l16.2970" class="difflineplus">+83f3a2e7ac09a2074430e7f497f00f1138a5444f82839c5206b1f51053cca968</span>
<a href="#l16.2971"></a><span id="l16.2971" class="difflineplus">+63258821e7f2b5438aac16fbecc052b646e709de45cf18996b29648508728612</span>
<a href="#l16.2972"></a><span id="l16.2972" class="difflineplus">+952ca606a73566d44612b876845e9a347084ea4868d2907ff06be4436c4b41a3</span>
<a href="#l16.2973"></a><span id="l16.2973" class="difflineplus">+a3e1774285614c5affb40dbd931a526619d9fa18e4c2be420858de1df0e69893</span>
<a href="#l16.2974"></a><span id="l16.2974" class="difflineplus">+a0e3e5523461be448561001042b7d4a15309ce2c57aef2ba89d1c13794a109d7</span>
<a href="#l16.2975"></a><span id="l16.2975" class="difflineplus">+b5880aa27744fc5c4aecb5e7bcef5fe528ec6293a930690000000049454e44ae</span>
<a href="#l16.2976"></a><span id="l16.2976" class="difflineplus">+426082</span>
<a href="#l16.2977"></a><span id="l16.2977" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2978"></a><span id="l16.2978" class="difflineplus">+  'basn0g04': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2979"></a><span id="l16.2979" class="difflineplus">+89504e470d0a1a0a0000000d494844520000002000000020040000000093e1c8</span>
<a href="#l16.2980"></a><span id="l16.2980" class="difflineplus">+290000000467414d41000186a031e8965f0000004849444154789c6360601014</span>
<a href="#l16.2981"></a><span id="l16.2981" class="difflineplus">+545232367671090d4d4b2b2f6720430095dbd1418e002a77e64c720450b9ab56</span>
<a href="#l16.2982"></a><span id="l16.2982" class="difflineplus">+912380caddbd9b1c0154ee9933e408a072efde25470095fbee1d1902001f14ee</span>
<a href="#l16.2983"></a><span id="l16.2983" class="difflineplus">+01eaff41fa0000000049454e44ae426082</span>
<a href="#l16.2984"></a><span id="l16.2984" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2985"></a><span id="l16.2985" class="difflineplus">+  'basn0g08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2986"></a><span id="l16.2986" class="difflineplus">+89504e470d0a1a0a0000000d4948445200000020000000200800000000561125</span>
<a href="#l16.2987"></a><span id="l16.2987" class="difflineplus">+280000000467414d41000186a031e8965f0000004149444154789c6364602400</span>
<a href="#l16.2988"></a><span id="l16.2988" class="difflineplus">+1408c8b30c05058c0f0829f8f71f3f6079301c1430ca11906764a2795c0c0605</span>
<a href="#l16.2989"></a><span id="l16.2989" class="difflineplus">+8c8ff0cafeffcff887e67131181430cae0956564040050e5fe7135e2d8590000</span>
<a href="#l16.2990"></a><span id="l16.2990" class="difflineplus">+000049454e44ae426082</span>
<a href="#l16.2991"></a><span id="l16.2991" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.2992"></a><span id="l16.2992" class="difflineplus">+  'basn0g16': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.2993"></a><span id="l16.2993" class="difflineplus">+89504e470d0a1a0a0000000d49484452000000200000002010000000000681f9</span>
<a href="#l16.2994"></a><span id="l16.2994" class="difflineplus">+6b0000000467414d41000186a031e8965f0000005e49444154789cd5d2310ac0</span>
<a href="#l16.2995"></a><span id="l16.2995" class="difflineplus">+300c4351395bef7fc6dca093c0287b32d52a04a3d98f3f3880a7b857131363a0</span>
<a href="#l16.2996"></a><span id="l16.2996" class="difflineplus">+3a82601d089900dd82f640ca04e816dc06422640b7a03d903201ba05b7819009</span>
<a href="#l16.2997"></a><span id="l16.2997" class="difflineplus">+d02d680fa44c603f6f07ec4ff41938cf7f0016d84bd85fae2b9fd70000000049</span>
<a href="#l16.2998"></a><span id="l16.2998" class="difflineplus">+454e44ae426082</span>
<a href="#l16.2999"></a><span id="l16.2999" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3000"></a><span id="l16.3000" class="difflineplus">+  'basn2c08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3001"></a><span id="l16.3001" class="difflineplus">+89504e470d0a1a0a0000000d4948445200000020000000200802000000fc18ed</span>
<a href="#l16.3002"></a><span id="l16.3002" class="difflineplus">+a30000000467414d41000186a031e8965f0000004849444154789cedd5c10900</span>
<a href="#l16.3003"></a><span id="l16.3003" class="difflineplus">+300c024085ec91fdb772133b442bf4a1f8cee12bb40d043b800a14f81ca0ede4</span>
<a href="#l16.3004"></a><span id="l16.3004" class="difflineplus">+7d4c784081020f4a871fc284071428f0a0743823a94081bb7077a3c00182b1f9</span>
<a href="#l16.3005"></a><span id="l16.3005" class="difflineplus">+5e0f40cf4b0000000049454e44ae426082</span>
<a href="#l16.3006"></a><span id="l16.3006" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3007"></a><span id="l16.3007" class="difflineplus">+  'basn2c16': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3008"></a><span id="l16.3008" class="difflineplus">+89504e470d0a1a0a0000000d4948445200000020000000201002000000ac8831</span>
<a href="#l16.3009"></a><span id="l16.3009" class="difflineplus">+e00000000467414d41000186a031e8965f000000e549444154789cd596c10a83</span>
<a href="#l16.3010"></a><span id="l16.3010" class="difflineplus">+301044a7e0417fcb7eb7fdadf6961e06039286266693cc7a188645e43dd6a08f</span>
<a href="#l16.3011"></a><span id="l16.3011" class="difflineplus">+1042003e2fe09aef6472737e183d27335fcee2f35a77b702ebce742870a23397</span>
<a href="#l16.3012"></a><span id="l16.3012" class="difflineplus">+f3edf2705dd10160f3b2815fe8ecf2027974a6b0c03f74a6e4192843e75c6c03</span>
<a href="#l16.3013"></a><span id="l16.3013" class="difflineplus">+35e8ec3202f5e84c0181bbe8cca967a00d9df3491bb040671f2e6087ce1c2860</span>
<a href="#l16.3014"></a><span id="l16.3014" class="difflineplus">+8d1e05f8c7ee0f1d00b667e70df44467ef26d01fbd9bc028f42860f71d188bce</span>
<a href="#l16.3015"></a><span id="l16.3015" class="difflineplus">+fb8d3630039dbd59601e7ab3c06cf428507f0634d039afdc80123a7bb1801e7a</span>
<a href="#l16.3016"></a><span id="l16.3016" class="difflineplus">+b1802a7a14c89f016d74ce331bf080ce9e08f8414f04bca133bfe642fe5e07bb</span>
<a href="#l16.3017"></a><span id="l16.3017" class="difflineplus">+c4ec0000000049454e44ae426082</span>
<a href="#l16.3018"></a><span id="l16.3018" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3019"></a><span id="l16.3019" class="difflineplus">+  'basn6a08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3020"></a><span id="l16.3020" class="difflineplus">+89504e470d0a1a0a0000000d4948445200000020000000200806000000737a7a</span>
<a href="#l16.3021"></a><span id="l16.3021" class="difflineplus">+f40000000467414d41000186a031e8965f0000006f49444154789cedd6310a80</span>
<a href="#l16.3022"></a><span id="l16.3022" class="difflineplus">+300c46e12764684fa1f73f55048f21c4ddc545781d52e85028fc1f4d28d98a01</span>
<a href="#l16.3023"></a><span id="l16.3023" class="difflineplus">+305e7b7e9cffba33831d75054703ca06a8f90d58a0074e351e227d805c8254e3</span>
<a href="#l16.3024"></a><span id="l16.3024" class="difflineplus">+1bb0420f5cdc2e0079208892ffe2a00136a07b4007943c1004d900195036407f</span>
<a href="#l16.3025"></a><span id="l16.3025" class="difflineplus">+011bf00052201a9c160fb84c0000000049454e44ae426082</span>
<a href="#l16.3026"></a><span id="l16.3026" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3027"></a><span id="l16.3027" class="difflineplus">+  'cs3n3p08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3028"></a><span id="l16.3028" class="difflineplus">+89504e470d0a1a0a0000000d494844520000002000000020080300000044a48a</span>
<a href="#l16.3029"></a><span id="l16.3029" class="difflineplus">+c60000000467414d41000186a031e8965f0000000373424954030303a392a042</span>
<a href="#l16.3030"></a><span id="l16.3030" class="difflineplus">+00000054504c544592ff0000ff9200ffff00ff0000dbff00ff6dffb600006dff</span>
<a href="#l16.3031"></a><span id="l16.3031" class="difflineplus">+b6ff00ff9200dbff000049ffff2400ff000024ff0049ff0000ffdb00ff4900ff</span>
<a href="#l16.3032"></a><span id="l16.3032" class="difflineplus">+b6ffff0000ff2400b6ffffdb000092ffff6d000024ffff49006dff00df702b17</span>
<a href="#l16.3033"></a><span id="l16.3033" class="difflineplus">+0000004b49444154789c85cac70182000000b1b3625754b0edbfa72324ef7486</span>
<a href="#l16.3034"></a><span id="l16.3034" class="difflineplus">+184ed0177a437b680bcdd0031c0ed00ea21f74852ed00a1c9ed0086da0057487</span>
<a href="#l16.3035"></a><span id="l16.3035" class="difflineplus">+6ed0121cd6d004bda0013a421ff803224033e177f4ae260000000049454e44ae</span>
<a href="#l16.3036"></a><span id="l16.3036" class="difflineplus">+426082</span>
<a href="#l16.3037"></a><span id="l16.3037" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3038"></a><span id="l16.3038" class="difflineplus">+  's09n3p02': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3039"></a><span id="l16.3039" class="difflineplus">+89504e470d0a1a0a0000000d49484452000000090000000902030000009dffee</span>
<a href="#l16.3040"></a><span id="l16.3040" class="difflineplus">+830000000467414d41000186a031e8965f000000037342495404040477f8b5a3</span>
<a href="#l16.3041"></a><span id="l16.3041" class="difflineplus">+0000000c504c544500ff000077ffff00ffff7700ff5600640000001f49444154</span>
<a href="#l16.3042"></a><span id="l16.3042" class="difflineplus">+789c63600002fbff0c0c56ab19182ca381581a4283f82071200000696505c36a</span>
<a href="#l16.3043"></a><span id="l16.3043" class="difflineplus">+437f230000000049454e44ae426082</span>
<a href="#l16.3044"></a><span id="l16.3044" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3045"></a><span id="l16.3045" class="difflineplus">+  'tbgn3p08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3046"></a><span id="l16.3046" class="difflineplus">+89504e470d0a1a0a0000000d494844520000002000000020080300000044a48a</span>
<a href="#l16.3047"></a><span id="l16.3047" class="difflineplus">+c60000000467414d41000186a031e8965f00000207504c54457f7f7fafafafab</span>
<a href="#l16.3048"></a><span id="l16.3048" class="difflineplus">+abab110000222200737300999999510d00444400959500959595e6e600919191</span>
<a href="#l16.3049"></a><span id="l16.3049" class="difflineplus">+8d8d8d620d00898989666600b7b700911600000000730d007373736f6f6faaaa</span>
<a href="#l16.3050"></a><span id="l16.3050" class="difflineplus">+006b6b6b676767c41a00cccc0000f30000ef00d51e0055555567670000dd0051</span>
<a href="#l16.3051"></a><span id="l16.3051" class="difflineplus">+515100d1004d4d4de61e0038380000b700160d0d00ab00560d00090900009500</span>
<a href="#l16.3052"></a><span id="l16.3052" class="difflineplus">+009100008d003333332f2f2f2f2b2f2b2b000077007c7c001a05002b27000073</span>
<a href="#l16.3053"></a><span id="l16.3053" class="difflineplus">+002b2b2b006f00bb1600272727780d002323230055004d4d00cc1e00004d00cc</span>
<a href="#l16.3054"></a><span id="l16.3054" class="difflineplus">+1a000d00003c09006f6f00002f003811271111110d0d0d55554d090909001100</span>
<a href="#l16.3055"></a><span id="l16.3055" class="difflineplus">+4d0900050505000d00e2e200000900000500626200a6a6a6a2a2a29e9e9e8484</span>
<a href="#l16.3056"></a><span id="l16.3056" class="difflineplus">+00fb00fbd5d500801100800d00ea00ea555500a6a600e600e6f7f700e200e233</span>
<a href="#l16.3057"></a><span id="l16.3057" class="difflineplus">+0500888888d900d9848484c01a007777003c3c05c8c8008080804409007c7c7c</span>
<a href="#l16.3058"></a><span id="l16.3058" class="difflineplus">+bb00bbaa00aaa600a61e09056262629e009e9a009af322005e5e5e05050000ee</span>
<a href="#l16.3059"></a><span id="l16.3059" class="difflineplus">+005a5a5adddd00a616008d008d00e20016050027270088110078780000c40078</span>
<a href="#l16.3060"></a><span id="l16.3060" class="difflineplus">+00787300736f006f44444400aa00c81e004040406600663c3c3c090000550055</span>
<a href="#l16.3061"></a><span id="l16.3061" class="difflineplus">+1a1a00343434d91e000084004d004d007c004500453c3c00ea1e00222222113c</span>
<a href="#l16.3062"></a><span id="l16.3062" class="difflineplus">+113300331e1e1efb22001a1a1a004400afaf00270027003c001616161e001e0d</span>
<a href="#l16.3063"></a><span id="l16.3063" class="difflineplus">+160d2f2f00808000001e00d1d1001100110d000db7b7b7090009050005b3b3b3</span>
<a href="#l16.3064"></a><span id="l16.3064" class="difflineplus">+6d34c4230000000174524e530040e6d86600000001624b474402660b7c640000</span>
<a href="#l16.3065"></a><span id="l16.3065" class="difflineplus">+01f249444154789c6360c0048c8c58049100575f215ee92e6161ef109cd2a15e</span>
<a href="#l16.3066"></a><span id="l16.3066" class="difflineplus">+4b9645ce5d2c8f433aa4c24f3cbd4c98833b2314ab74a186f094b9c2c27571d2</span>
<a href="#l16.3067"></a><span id="l16.3067" class="difflineplus">+6a2a58e4253c5cda8559057a392363854db4d9d0641973660b0b0bb76bb16656</span>
<a href="#l16.3068"></a><span id="l16.3068" class="difflineplus">+06970997256877a07a95c75a1804b2fbcd128c80b482a0b0300f8a824276a9a8</span>
<a href="#l16.3069"></a><span id="l16.3069" class="difflineplus">+ec6e61612b3e57ee06fbf0009619d5fac846ac5c60ed20e754921625a2daadc6</span>
<a href="#l16.3070"></a><span id="l16.3070" class="difflineplus">+1967e29e97d2239c8aec7e61fdeca9cecebef54eb36c848517164514af16169e</span>
<a href="#l16.3071"></a><span id="l16.3071" class="difflineplus">+866444b2b0b7b55534c815cc2ec22d89cd1353800a8473100a4485852d924a6a</span>
<a href="#l16.3072"></a><span id="l16.3072" class="difflineplus">+412adc74e7ad1016ceed043267238c901716f633a812022998a4072267c4af02</span>
<a href="#l16.3073"></a><span id="l16.3073" class="difflineplus">+92127005c0f811b62830054935ce017b38bf0948cc5c09955f030a24617d9d46</span>
<a href="#l16.3074"></a><span id="l16.3074" class="difflineplus">+63371fd940b0827931cbfdf4956076ac018b592f72d45594a9b1f307f3261b1a</span>
<a href="#l16.3075"></a><span id="l16.3075" class="difflineplus">+084bc2ad50018b1900719ba6ba4ca325d0427d3f6161449486f981144cf3100e</span>
<a href="#l16.3076"></a><span id="l16.3076" class="difflineplus">+2a5f2a1ce8683e4ddf1b64275240c8438d98af0c729bbe07982b8a1c94201dc2</span>
<a href="#l16.3077"></a><span id="l16.3077" class="difflineplus">+b3174c9820bcc06201585ad81b25b64a2146384e3798290c05ad280a18c0a62e</span>
<a href="#l16.3078"></a><span id="l16.3078" class="difflineplus">+e898260c07fca80a24c076cc864b777131a00190cdfa3069035eccbc038c30e1</span>
<a href="#l16.3079"></a><span id="l16.3079" class="difflineplus">+3e88b46d16b6acc5380d6ac202511c392f4b789aa7b0b08718765990111606c2</span>
<a href="#l16.3080"></a><span id="l16.3080" class="difflineplus">+9e854c38e5191878fbe471e749b0112bb18902008dc473b2b2e8e72700000000</span>
<a href="#l16.3081"></a><span id="l16.3081" class="difflineplus">+49454e44ae426082</span>
<a href="#l16.3082"></a><span id="l16.3082" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3083"></a><span id="l16.3083" class="difflineplus">+  'Tp2n3p08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3084"></a><span id="l16.3084" class="difflineplus">+89504e470d0a1a0a0000000d494844520000002000000020080300000044a48a</span>
<a href="#l16.3085"></a><span id="l16.3085" class="difflineplus">+c60000000467414d41000186a031e8965f00000300504c544502ffff80ff05ff</span>
<a href="#l16.3086"></a><span id="l16.3086" class="difflineplus">+7f0703ff7f0180ff04ff00ffff06ff000880ff05ff7f07ffff06ff000804ff00</span>
<a href="#l16.3087"></a><span id="l16.3087" class="difflineplus">+0180ff02ffff03ff7f02ffff80ff0503ff7f0180ffff0008ff7f0704ff00ffff</span>
<a href="#l16.3088"></a><span id="l16.3088" class="difflineplus">+06ff000802ffffff7f0704ff0003ff7fffff0680ff050180ff04ff000180ffff</span>
<a href="#l16.3089"></a><span id="l16.3089" class="difflineplus">+0008ffff0603ff7f80ff05ff7f0702ffffff000880ff05ffff0603ff7f02ffff</span>
<a href="#l16.3090"></a><span id="l16.3090" class="difflineplus">+ff7f070180ff04ff00ffff06ff000880ff050180ffff7f0702ffff04ff0003ff</span>
<a href="#l16.3091"></a><span id="l16.3091" class="difflineplus">+7fff7f0704ff0003ff7f0180ffffff06ff000880ff0502ffffffff0603ff7fff</span>
<a href="#l16.3092"></a><span id="l16.3092" class="difflineplus">+7f0702ffff04ff000180ff80ff05ff0008ff7f07ffff0680ff0504ff00ff0008</span>
<a href="#l16.3093"></a><span id="l16.3093" class="difflineplus">+0180ff03ff7f02ffff02ffffffff0604ff0003ff7f0180ffff000880ff05ff7f</span>
<a href="#l16.3094"></a><span id="l16.3094" class="difflineplus">+0780ff05ff00080180ff02ffffff7f0703ff7fffff0604ff00ff7f07ff0008ff</span>
<a href="#l16.3095"></a><span id="l16.3095" class="difflineplus">+ff0680ff0504ff0002ffff0180ff03ff7fff0008ffff0680ff0504ff000180ff</span>
<a href="#l16.3096"></a><span id="l16.3096" class="difflineplus">+02ffff03ff7fff7f070180ff02ffff04ff00ffff06ff0008ff7f0780ff0503ff</span>
<a href="#l16.3097"></a><span id="l16.3097" class="difflineplus">+7fffff06ff0008ff7f0780ff0502ffff03ff7f0180ff04ff0002ffffff7f07ff</span>
<a href="#l16.3098"></a><span id="l16.3098" class="difflineplus">+ff0604ff0003ff7fff00080180ff80ff05ffff0603ff7f0180ffff000804ff00</span>
<a href="#l16.3099"></a><span id="l16.3099" class="difflineplus">+80ff0502ffffff7f0780ff05ffff0604ff000180ffff000802ffffff7f0703ff</span>
<a href="#l16.3100"></a><span id="l16.3100" class="difflineplus">+7fff0008ff7f070180ff03ff7f02ffff80ff05ffff0604ff00ff0008ffff0602</span>
<a href="#l16.3101"></a><span id="l16.3101" class="difflineplus">+ffff0180ff04ff0003ff7f80ff05ff7f070180ff04ff00ff7f0780ff0502ffff</span>
<a href="#l16.3102"></a><span id="l16.3102" class="difflineplus">+ff000803ff7fffff0602ffffff7f07ffff0680ff05ff000804ff0003ff7f0180</span>
<a href="#l16.3103"></a><span id="l16.3103" class="difflineplus">+ff02ffff0180ffff7f0703ff7fff000804ff0080ff05ffff0602ffff04ff00ff</span>
<a href="#l16.3104"></a><span id="l16.3104" class="difflineplus">+ff0603ff7fff7f070180ff80ff05ff000803ff7f0180ffff7f0702ffffff0008</span>
<a href="#l16.3105"></a><span id="l16.3105" class="difflineplus">+04ff00ffff0680ff0503ff7f0180ff04ff0080ff05ffff06ff000802ffffff7f</span>
<a href="#l16.3106"></a><span id="l16.3106" class="difflineplus">+0780ff05ff0008ff7f070180ff03ff7f04ff0002ffffffff0604ff00ff7f07ff</span>
<a href="#l16.3107"></a><span id="l16.3107" class="difflineplus">+000880ff05ffff060180ff02ffff03ff7f80ff05ffff0602ffff0180ff03ff7f</span>
<a href="#l16.3108"></a><span id="l16.3108" class="difflineplus">+04ff00ff7f07ff00080180ffff000880ff0502ffff04ff00ff7f0703ff7fffff</span>
<a href="#l16.3109"></a><span id="l16.3109" class="difflineplus">+06ff0008ffff0604ff00ff7f0780ff0502ffff03ff7f0180ffdeb83387000000</span>
<a href="#l16.3110"></a><span id="l16.3110" class="difflineplus">+f874524e53000000000000000008080808080808081010101010101010181818</span>
<a href="#l16.3111"></a><span id="l16.3111" class="difflineplus">+1818181818202020202020202029292929292929293131313131313131393939</span>
<a href="#l16.3112"></a><span id="l16.3112" class="difflineplus">+393939393941414141414141414a4a4a4a4a4a4a4a52525252525252525a5a5a</span>
<a href="#l16.3113"></a><span id="l16.3113" class="difflineplus">+5a5a5a5a5a62626262626262626a6a6a6a6a6a6a6a73737373737373737b7b7b</span>
<a href="#l16.3114"></a><span id="l16.3114" class="difflineplus">+7b7b7b7b7b83838383838383838b8b8b8b8b8b8b8b94949494949494949c9c9c</span>
<a href="#l16.3115"></a><span id="l16.3115" class="difflineplus">+9c9c9c9c9ca4a4a4a4a4a4a4a4acacacacacacacacb4b4b4b4b4b4b4b4bdbdbd</span>
<a href="#l16.3116"></a><span id="l16.3116" class="difflineplus">+bdbdbdbdbdc5c5c5c5c5c5c5c5cdcdcdcdcdcdcdcdd5d5d5d5d5d5d5d5dedede</span>
<a href="#l16.3117"></a><span id="l16.3117" class="difflineplus">+dededededee6e6e6e6e6e6e6e6eeeeeeeeeeeeeeeef6f6f6f6f6f6f6f6b98ac5</span>
<a href="#l16.3118"></a><span id="l16.3118" class="difflineplus">+ca0000012c49444154789c6360e7169150d230b475f7098d4ccc28a96ced9e32</span>
<a href="#l16.3119"></a><span id="l16.3119" class="difflineplus">+63c1da2d7b8e9fb97af3d1fb8f3f18e8a0808953544a4dd7c4c2c9233c2621bf</span>
<a href="#l16.3120"></a><span id="l16.3120" class="difflineplus">+b4aab17fdacce5ab36ee3a72eafaad87efbefea68702362e7159652d031b07cf</span>
<a href="#l16.3121"></a><span id="l16.3121" class="difflineplus">+c0b8a4cce28aa68e89f316aedfb4ffd0b92bf79fbcfcfe931e0a183904e55435</span>
<a href="#l16.3122"></a><span id="l16.3122" class="difflineplus">+8decdcbcc22292b3caaadb7b27cc5db67af3be63e72fdf78fce2d31f7a2860e5</span>
<a href="#l16.3123"></a><span id="l16.3123" class="difflineplus">+119356d037b374f10e8a4fc92eaa6fee99347fc9caad7b0f9ebd74f7c1db2fbf</span>
<a href="#l16.3124"></a><span id="l16.3124" class="difflineplus">+e8a180995f484645dbdccad12f38363dafbcb6a573faeca5ebb6ed3e7ce2c29d</span>
<a href="#l16.3125"></a><span id="l16.3125" class="difflineplus">+e76fbefda38702063e0149751d537b67ff80e8d4dcc29a86bea97316add9b0e3</span>
<a href="#l16.3126"></a><span id="l16.3126" class="difflineplus">+c0e96bf79ebdfafc971e0a587885e515f58cad5d7d43a2d2720aeadaba26cf5a</span>
<a href="#l16.3127"></a><span id="l16.3127" class="difflineplus">+bc62fbcea3272fde7efafac37f3a28000087c0fe101bc2f85f0000000049454e</span>
<a href="#l16.3128"></a><span id="l16.3128" class="difflineplus">+44ae426082</span>
<a href="#l16.3129"></a><span id="l16.3129" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3130"></a><span id="l16.3130" class="difflineplus">+  'tbbn1g04': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3131"></a><span id="l16.3131" class="difflineplus">+89504e470d0a1a0a0000000d494844520000002000000020040000000093e1c8</span>
<a href="#l16.3132"></a><span id="l16.3132" class="difflineplus">+290000000467414d41000186a031e8965f0000000274524e530007e8f7589b00</span>
<a href="#l16.3133"></a><span id="l16.3133" class="difflineplus">+000002624b47440000aa8d23320000013e49444154789c55d1cd4b024118c7f1</span>
<a href="#l16.3134"></a><span id="l16.3134" class="difflineplus">+efbe6419045b6a48a72d352808b435284f9187ae9b098627a1573a19945beba5</span>
<a href="#l16.3135"></a><span id="l16.3135" class="difflineplus">+e8129e8222af11d81e3a4545742de8ef6af6d5762e0fbf0fc33c33f36085cb76</span>
<a href="#l16.3136"></a><span id="l16.3136" class="difflineplus">+bc4204778771b867260683ee57e13f0c922df5c719c2b3b6c6c25b2382cea4b9</span>
<a href="#l16.3137"></a><span id="l16.3137" class="difflineplus">+9f7d4f244370746ac71f4ca88e0f173a6496749af47de8e44ba8f3bf9bdfa98a</span>
<a href="#l16.3138"></a><span id="l16.3138" class="difflineplus">+0faf857a7dd95c7dc8d7c67c782c99727997f41eb2e3c1e554152465bb00fe8e</span>
<a href="#l16.3139"></a><span id="l16.3139" class="difflineplus">+b692d190b718d159f4c0a45c4435915a243c58a7a4312a7a57913f05747594c6</span>
<a href="#l16.3140"></a><span id="l16.3140" class="difflineplus">+46169866c57101e4d4ce4d511423119c419183a3530cc63db88559ae28e7342a</span>
<a href="#l16.3141"></a><span id="l16.3141" class="difflineplus">+1e9c8122b71139b8872d6e913153224bc1f35b60e4445bd4004e20ed6682c759</span>
<a href="#l16.3142"></a><span id="l16.3142" class="difflineplus">+1d9873b3da0fbf50137dc5c9bde84fdb2ec8bde1189e0448b63584735993c209</span>
<a href="#l16.3143"></a><span id="l16.3143" class="difflineplus">+7a601bd2710caceba6158797285b7f2084a2f82c57c01a0000000049454e44ae</span>
<a href="#l16.3144"></a><span id="l16.3144" class="difflineplus">+426082</span>
<a href="#l16.3145"></a><span id="l16.3145" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3146"></a><span id="l16.3146" class="difflineplus">+  'tbrn2c08': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3147"></a><span id="l16.3147" class="difflineplus">+89504e470d0a1a0a0000000d4948445200000020000000200802000000fc18ed</span>
<a href="#l16.3148"></a><span id="l16.3148" class="difflineplus">+a30000000467414d41000186a031e8965f0000000674524e53007f007f007f8a</span>
<a href="#l16.3149"></a><span id="l16.3149" class="difflineplus">+33334f00000006624b474400ff0000000033277cf3000004d649444154789cad</span>
<a href="#l16.3150"></a><span id="l16.3150" class="difflineplus">+965f68537714c73fd912d640235e692f34d0406fa0c1663481045ab060065514</span>
<a href="#l16.3151"></a><span id="l16.3151" class="difflineplus">+56660a295831607df0a1488715167060840a1614e6431e9cb34fd2c00a762c85</span>
<a href="#l16.3152"></a><span id="l16.3152" class="difflineplus">+f6a10f816650c13b0cf40612e1822ddc4863bd628a8924d23d6464f9d3665dd9</span>
<a href="#l16.3153"></a><span id="l16.3153" class="difflineplus">+f7e977ce3dbff3cd3939bfdfef6bb87dfb364782dbed065ebe7cd93acc78b4ec</span>
<a href="#l16.3154"></a><span id="l16.3154" class="difflineplus">+a228debd7bb7bfbfbfbbbbfb7f261045311a8d261209405194274f9ea4d3e916</span>
<a href="#l16.3155"></a><span id="l16.3155" class="difflineplus">+f15f1c3eb5dd6e4fa5fecce526239184a2b0b8486f6f617171b1f5ae4311381c</span>
<a href="#l16.3156"></a><span id="l16.3156" class="difflineplus">+8e57af5e5dbd7a351088150a78bd389d44222c2f93cdfe66b7db8f4ee07038b6</span>
<a href="#l16.3157"></a><span id="l16.3157" class="difflineplus">+b6b6bebf766d7e7e7e60a06432313b4ba984c3c1c4049a46b95c5a58583822c1</span>
<a href="#l16.3158"></a><span id="l16.3158" class="difflineplus">+dbb76f27272733d1b9df853c3030c0f232562b9108cf9eb1b888d7cbf030abab</span>
<a href="#l16.3159"></a><span id="l16.3159" class="difflineplus">+31abd5fa1f08dc6ef7e7cf9f1f3f7e1c8944745d4f1400c62c001313acad21cb</span>
<a href="#l16.3160"></a><span id="l16.3160" class="difflineplus">+b8dd2c2c603271eb1640341aad4c6d331aa7e8c48913a150a861307ecc11e964</span>
<a href="#l16.3161"></a><span id="l16.3161" class="difflineplus">+74899919bc5e14e56fffc404f1388502f178dceff7ef4bf0a5cfe7abb533998c</span>
<a href="#l16.3162"></a><span id="l16.3162" class="difflineplus">+e5f9ea2f1dd88c180d64cb94412df3dd57e83a6b3b3c7a84c98420100c72fd3a</span>
<a href="#l16.3163"></a><span id="l16.3163" class="difflineplus">+636348bae726379fe69e8e8d8dbd79f3a6558b0607079796965256479b918085</span>
<a href="#l16.3164"></a><span id="l16.3164" class="difflineplus">+7b02db12712b6181950233023f3f647494ee6e2e5ea45864cce5b8a7fe3acffc</span>
<a href="#l16.3165"></a><span id="l16.3165" class="difflineplus">+3aebb22c2bd5d20e22d0757d7b7bbbbdbd3d94a313bed1b0aa3cd069838b163a</span>
<a href="#l16.3166"></a><span id="l16.3166" class="difflineplus">+8d4c59585f677292d0b84d9a995bd337def3fe6bbe5e6001989b9b6bfe27ea08</span>
<a href="#l16.3167"></a><span id="l16.3167" class="difflineplus">+36373781542ab56573248b4c5bc843ac4048c7ab21aa24ca00534c25482828a3</span>
<a href="#l16.3168"></a><span id="l16.3168" class="difflineplus">+8c9ee67475bbaaaab22cb722c8e57240a150301a8d219de94e44534d7d90e885</span>
<a href="#l16.3169"></a><span id="l16.3169" class="difflineplus">+87acb0e2c4f9800731629b6c5ee14a35a6b9887d2a0032994cb9cf15dbe59650</span>
<a href="#l16.3170"></a><span id="l16.3170" class="difflineplus">+ff7b46a04c9a749e7cc5112214266cc65c31354d5b5d5d3d90209bcd5616a552</span>
<a href="#l16.3171"></a><span id="l16.3171" class="difflineplus">+a95c2e87f2a659bd9ee01c2cd73964e438f129a6aa9e582c363838b80f81d7eb</span>
<a href="#l16.3172"></a><span id="l16.3172" class="difflineplus">+5555b56a2a8ad2d9d7affd0409f8015c208013fea00177b873831b0282c964f2</span>
<a href="#l16.3173"></a><span id="l16.3173" class="difflineplus">+783c1e8fa7582cee5f81a669b5e6eeeeaee58e8559b0c233d8843c7c0b963a82</span>
<a href="#l16.3174"></a><span id="l16.3174" class="difflineplus">+34e94b5cb2396d7d7d7db22c8ba258fb0afd43f0e2c58b919191ba9de9b4d425</span>
<a href="#l16.3175"></a><span id="l16.3175" class="difflineplus">+118329b0c3323c8709d02041b52b4ea7f39de75d2a934a2693c0a953a76a93d4</span>
<a href="#l16.3176"></a><span id="l16.3176" class="difflineplus">+5d157ebf7f6565a5542a553df97c5e10045dd731c130b86113cc300cbd489224</span>
<a href="#l16.3177"></a><span id="l16.3177" class="difflineplus">+08422a952a140a95788fc763b1d41558d7a2d7af5f5fb870a1d6a3aaaacd6603</span>
<a href="#l16.3178"></a><span id="l16.3178" class="difflineplus">+18802da84c59015bd2e6897b745d9765b99a1df0f97c0daf74e36deaf7fbcd66</span>
<a href="#l16.3179"></a><span id="l16.3179" class="difflineplus">+73ad2797cb89a2c839880188a2e8743a8bc5a22ccbba5e376466b3b9bdbdbd21</span>
<a href="#l16.3180"></a><span id="l16.3180" class="difflineplus">+6123413a9d0e0402b51e4dd3bababa788eb022b85caeb6b6364551b6b7b76942</span>
<a href="#l16.3181"></a><span id="l16.3181" class="difflineplus">+43f7f727007a7a7a04a1ee8065b3595fde2768423299ac1ec6669c3973e65004</span>
<a href="#l16.3182"></a><span id="l16.3182" class="difflineplus">+c0f8f878ad69341a33994ced2969c0d0d0502412f9f8f163f3a7fd654b474787</span>
<a href="#l16.3183"></a><span id="l16.3183" class="difflineplus">+288ad53e74757535df6215b85cae60302849d2410aecc037f9f2e5cbd5b5c160</span>
<a href="#l16.3184"></a><span id="l16.3184" class="difflineplus">+680eb0dbede170381c0e7ff8f0a185be3b906068684892a4ca7a6f6faff69328</span>
<a href="#l16.3185"></a><span id="l16.3185" class="difflineplus">+8ad3d3d3f7efdfdfdbdbfb57e96868a14d0d0643381c96242997cbe5f3794010</span>
<a href="#l16.3186"></a><span id="l16.3186" class="difflineplus">+84603078fcf8f1d6496bd14a3aba5c2ea7d369341a5555b5582c8140e0fcf9f3</span>
<a href="#l16.3187"></a><span id="l16.3187" class="difflineplus">+1b1b1b87cf4eeb0a8063c78e45a3d19e9e1ebfdfdf5a831e844655d18093274f</span>
<a href="#l16.3188"></a><span id="l16.3188" class="difflineplus">+9e3d7bf6d3a74f3b3b3b47c80efc05ff7af28fefb70d9b0000000049454e44ae</span>
<a href="#l16.3189"></a><span id="l16.3189" class="difflineplus">+426082</span>
<a href="#l16.3190"></a><span id="l16.3190" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3191"></a><span id="l16.3191" class="difflineplus">+  'basn6a16': _dehex(&quot;&quot;&quot;</span>
<a href="#l16.3192"></a><span id="l16.3192" class="difflineplus">+89504e470d0a1a0a0000000d494844520000002000000020100600000023eaa6</span>
<a href="#l16.3193"></a><span id="l16.3193" class="difflineplus">+b70000000467414d41000186a031e8965f00000d2249444154789cdd995f6c1c</span>
<a href="#l16.3194"></a><span id="l16.3194" class="difflineplus">+d775c67ff38fb34b724d2ee55a8e4b04a0ac87049100cab4dbd8c6528902cb4d</span>
<a href="#l16.3195"></a><span id="l16.3195" class="difflineplus">+10881620592e52d4325ac0905bc98a94025e71fd622cb5065ac98a0c283050c0</span>
<a href="#l16.3196"></a><span id="l16.3196" class="difflineplus">+728a00b6e542a1d126885cd3298928891d9a0444037e904434951d4b90b84b2f</span>
<a href="#l16.3197"></a><span id="l16.3197" class="difflineplus">+c9dde1fcebc33977a95555348f411e16dfce9d3b77ee77eebde77ce78c95a669</span>
<a href="#l16.3198"></a><span id="l16.3198" class="difflineplus">+0ad07c17009a13edd898b87dfb1fcb7d2b4d1bff217f33df80deb1e6267df0ff</span>
<a href="#l16.3199"></a><span id="l16.3199" class="difflineplus">+c1e6e6dfafdf1f5a7fd30f9aef66b6d546dd355bf02c40662e3307f9725a96c6</span>
<a href="#l16.3200"></a><span id="l16.3200" class="difflineplus">+744c3031f83782f171c148dbc3bf1774f5dad1e79d6f095a3f54d4fbec5234ef</span>
<a href="#l16.3201"></a><span id="l16.3201" class="difflineplus">+d9a2f8d73afe4f14f57ef4f42def7b44f19060f06b45bddf1c5534d77fd922be</span>
<a href="#l16.3202"></a><span id="l16.3202" class="difflineplus">+2973a15a82e648661c6e3240aa3612ead952b604bde57458894f29deaf133bac</span>
<a href="#l16.3203"></a><span id="l16.3203" class="difflineplus">+13d2766f5227a4a3b8cf08da7adfd6fbd6bd8a4fe9dbb43d35e3dfa3f844fbf8</span>
<a href="#l16.3204"></a><span id="l16.3204" class="difflineplus">+9119bf4f7144094fb56333abf8a86063ca106f94b3a3b512343765e60082097f</span>
<a href="#l16.3205"></a><span id="l16.3205" class="difflineplus">+1bb86ba72439a653519b09f5cee1ce61c897d37eedf5553580ae60f4af8af33a</span>
<a href="#l16.3206"></a><span id="l16.3206" class="difflineplus">+b14fd400b6a0f34535c0434afc0b3a9f07147527a5fa7ca218ff56c74d74dc3f</span>
<a href="#l16.3207"></a><span id="l16.3207" class="difflineplus">+155cfd3325fc278acf2ae1cb4a539f5f9937c457263b0bd51234c732a300cdd1</span>
<a href="#l16.3208"></a><span id="l16.3208" class="difflineplus">+cc1840f0aaff54db0e4874ed5a9b5d6d27d4bb36746d80de72baa877ff4b275a</span>
<a href="#l16.3209"></a><span id="l16.3209" class="difflineplus">+d7895ed1897ea4139b5143fcbb1a62560da1ed9662aaed895ec78a91c18795b8</span>
<a href="#l16.3210"></a><span id="l16.3210" class="difflineplus">+5e07ab4af8ba128e95e682e0728bf8f2e5ae815a091a53d902ac1920d8e05f06</span>
<a href="#l16.3211"></a><span id="l16.3211" class="difflineplus">+589de8d8d66680789f4e454fb9d9ec66cd857af796ee2d902fa73fd5bba775a2</span>
<a href="#l16.3212"></a><span id="l16.3212" class="difflineplus">+153580ae44705ed0d37647d15697cb8f14bfa3e3e8fdf8031d47af571503357c</span>
<a href="#l16.3213"></a><span id="l16.3213" class="difflineplus">+f30d25acedcbbf135c9a35c49766ba07ab255859e8ec03684e66860182dff8f7</span>
<a href="#l16.3214"></a><span id="l16.3214" class="difflineplus">+0304bff6ff1c20fc81b7afdd00a71475539a536e36bb5973a19e3b923b02bde5</span>
<a href="#l16.3215"></a><span id="l16.3215" class="difflineplus">+e4efd4003ac170eb2d13fe274157afedbd82d6fb3a9a1e85e4551d47cf7078f8</span>
<a href="#l16.3216"></a><span id="l16.3216" class="difflineplus">+9671fe4289ebf5f2bf08d63f37c4eb4773c55a0996efeefa0ca011671d8060ca</span>
<a href="#l16.3217"></a><span id="l16.3217" class="difflineplus">+2f0004c7fcc300e166ef0240f825efe3361f106d57d423d0723f7acacd66376b</span>
<a href="#l16.3218"></a><span id="l16.3218" class="difflineplus">+2ed47b7a7a7a205f4ef4ac4691e0aad9aa0d41cf13741c3580a506487574ddca</span>
<a href="#l16.3219"></a><span id="l16.3219" class="difflineplus">+61a8c403c1863ebfbcac3475168b2de28b8b3d77544bb05ce92a02aceced3c0d</span>
<a href="#l16.3220"></a><span id="l16.3220" class="difflineplus">+d0cc65ea371b201cf1c601c24dde1c4078cedbdeb60322f50126a019bf6edc9b</span>
<a href="#l16.3221"></a><span id="l16.3221" class="difflineplus">+39e566b39b3517eaf97c3e0fbde5e4491d45bd74537145d155b476aa0176e868</span>
<a href="#l16.3222"></a><span id="l16.3222" class="difflineplus">+c6abebf30dbd5e525c54ac8e18e2d56abeb756827a3d970358a97416019a6f64</span>
<a href="#l16.3223"></a><span id="l16.3223" class="difflineplus">+f60004fdfe1580d5c98e618070cc1b05887eee7e0d209a70db7d8063029889b4</span>
<a href="#l16.3224"></a><span id="l16.3224" class="difflineplus">+c620ead78d7b33a7dc6c76b3e6427ddddbebde867c393aa7845e5403e8ca794a</span>
<a href="#l16.3225"></a><span id="l16.3225" class="difflineplus">+d0d6fb897af5f03525fe5782f5e7046bdaef468bf88d1debc6ab25583cd17310</span>
<a href="#l16.3226"></a><span id="l16.3226" class="difflineplus">+6079b9ab0ba059c914018245bf076075b5a303200c3c1f209a733701444fbbaf</span>
<a href="#l16.3227"></a><span id="l16.3227" class="difflineplus">+00c4134ebb016c5d0b23614c243701cdf875e3decce9349bddacb9505fbf7dfd</span>
<a href="#l16.3228"></a><span id="l16.3228" class="difflineplus">+76e82d87736a00f5d2b5ffd4b7dce2719a4d25ae717ee153c1abef18e257cfad</span>
<a href="#l16.3229"></a><span id="l16.3229" class="difflineplus">+7fa45682da48ef38c052b53b0fd06864b300c151ff08c0ea431de701a287dd5f</span>
<a href="#l16.3230"></a><span id="l16.3230" class="difflineplus">+004497dc7b01a253ee3e80b8c7f91c20f967fb6fdb7c80ada7d8683723614c24</span>
<a href="#l16.3231"></a><span id="l16.3231" class="difflineplus">+3701cdf875e3decc29379bddacb950ef3fd47f08f2e5a61ea4aa2a3eb757cd55</span>
<a href="#l16.3232"></a><span id="l16.3232" class="difflineplus">+13345efcfa59c12b2f19e2578ef77fb75a82854ffbee01a83f977b11a031931d</span>
<a href="#l16.3233"></a><span id="l16.3233" class="difflineplus">+040802df07082b5e11207cc17b1e209a770700e2df0a83e409fb7580f827c230</span>
<a href="#l16.3234"></a><span id="l16.3234" class="difflineplus">+99b06fd901fb058d6835dacd481813c94d40337eddb83773cacd66376b2ed437</span>
<a href="#l16.3235"></a><span id="l16.3235" class="difflineplus">+bebcf165e82d2f4e4beb7f3fa6e652c2d7ee10bc78c010bfb87fe3c95a09ae9f</span>
<a href="#l16.3236"></a><span id="l16.3236" class="difflineplus">+bd732740bd2fb700d0f865f64180e059ff044018ca0ca28a5b04883f701e0088</span>
<a href="#l16.3237"></a><span id="l16.3237" class="difflineplus">+bfec7c0c909cb71f0448c6ec518074b375012079d9dedf66004bcfbc51eb2dd1</span>
<a href="#l16.3238"></a><span id="l16.3238" class="difflineplus">+aadacd481813c94d40337eddb83773cacd66376b2ed487868686205fbe7c49ef</span>
<a href="#l16.3239"></a><span id="l16.3239" class="difflineplus">+5605a73f34c4a7a787eeab96e0da81bb4e022c15ba27019a5b339300e16bf286</span>
<a href="#l16.3240"></a><span id="l16.3240" class="difflineplus">+a8eae601e25866907cdf3e0890acb36f00245fb57f05904e59c300e92561946e</span>
<a href="#l16.3241"></a><span id="l16.3241" class="difflineplus">+b2e600d209ab7d07f04d458dfb46ad1bd16ab49b913026929b8066fcba716fe6</span>
<a href="#l16.3242"></a><span id="l16.3242" class="difflineplus">+949bcd6ed65ca8ef7e7cf7e3d05b7e7c8f217ee6cdddbb6a25a856f37980e0c7</span>
<a href="#l16.3243"></a><span id="l16.3243" class="difflineplus">+fe4e80a82623c48193014846ec7180f4acf518409aca0cd28a5504e03b32c374</span>
<a href="#l16.3244"></a><span id="l16.3244" class="difflineplus">+de1a00608a0240faaa327a4b19fe946fb6f90054dbb5f2333d022db56eb4966a</span>
<a href="#l16.3245"></a><span id="l16.3245" class="difflineplus">+3723614c243701cdf8f556bea8a7dc6c76b3e66bd46584ddbbcebc0990cf4b0f</span>
<a href="#l16.3246"></a><span id="l16.3246" class="difflineplus">+ff4070520c282338a7e26700ec725202b01e4bcf0258963c6f1d4d8f0030cb20</span>
<a href="#l16.3247"></a><span id="l16.3247" class="difflineplus">+805549c520930c03584fa522b676f11600ffc03fde3e1b3489a9c9054c9aa23b</span>
<a href="#l16.3248"></a><span id="l16.3248" class="difflineplus">+c08856a3dd8c843191dc0434e3d78d7b33a75c36fb993761f7ae5a69f72ef97f</span>
<a href="#l16.3249"></a><span id="l16.3249" class="difflineplus">+e6ad336fed7e1c60e8bee96980bbdebbb60da07b7069062033d9dc0ae03d296f</span>
<a href="#l16.3250"></a><span id="l16.3250" class="difflineplus">+70ab511ec071640676252902d833c916007b3e1900b0a6d2028035968e025861</span>
<a href="#l16.3251"></a><span id="l16.3251" class="difflineplus">+ea01581369fb11488c34d18cbc95989afccca42baad65ba2d5683723614c24d7</span>
<a href="#l16.3252"></a><span id="l16.3252" class="difflineplus">+8066fcbab8b7e96918baaf5aaa56219f975fb50a43f7c9bde90fa73f1c1a02d8</span>
<a href="#l16.3253"></a><span id="l16.3253" class="difflineplus">+78f2e27e803b77ca08b90519315b6fe400fc1392097a9eccc0ad444500e70199</span>
<a href="#l16.3254"></a><span id="l16.3254" class="difflineplus">+a1331f0f00d8934901c07e5d526ceb87c2d07e2579badd005a2b31a5089391b7</span>
<a href="#l16.3255"></a><span id="l16.3255" class="difflineplus">+1253358049535a6add8856dd0146c298482e01ede27ed878b256ba7600ee3a09</span>
<a href="#l16.3256"></a><span id="l16.3256" class="difflineplus">+c18fc1df09fe01084ec25defc1b56db0f1a4f4bd78e0e2818d2f0334e7330300</span>
<a href="#l16.3257"></a><span id="l16.3257" class="difflineplus">+7df7c888b917e50dd9c1c60c80efcb0cbc63e1f700bce7c31700dccbd1060027</span>
<a href="#l16.3258"></a><span id="l16.3258" class="difflineplus">+8add9b0de06c8e2f00d84962b7d7030e2a61538331b98051f92631bd253f336a</span>
<a href="#l16.3259"></a><span id="l16.3259" class="difflineplus">+dd8856a3dd44c25c390efddfad96ae9f853b77c25201ba27c533b8bdf28b6ad0</span>
<a href="#l16.3260"></a><span id="l16.3260" class="difflineplus">+3d084b33d2e7fa59099e9901b8f2d29597fa0f01848f78e70082117f1ca07b76</span>
<a href="#l16.3261"></a><span id="l16.3261" class="difflineplus">+6910209b9519f895a008d031bbba05c09d8f06005c5b18b8fba25300cea6780e</span>
<a href="#l16.3262"></a><span id="l16.3262" class="difflineplus">+c03e911c6ccf06d507b48a4fa606634a114609de929f9934c5a87511ad57cfc1</span>
<a href="#l16.3263"></a><span id="l16.3263" class="difflineplus">+fa476aa5854fa1ef1e3910b905686e85cc24c40138198915f133d2d6dc2a7dea</span>
<a href="#l16.3264"></a><span id="l16.3264" class="difflineplus">+7df2ccc2a752faf2cec1d577aebeb37e3b4034eeee0008dff3be0e6b923773b4</span>
<a href="#l16.3265"></a><span id="l16.3265" class="difflineplus">+7904c0ef9119767cb4fa1500ef1361e08e452500f71561e84cc4ed3e20fab6a2</span>
<a href="#l16.3266"></a><span id="l16.3266" class="difflineplus">+c905f40cb76a3026bf3319b91ac2e46792a6dcd801ebc6aba5da08f48ecb81c8</span>
<a href="#l16.3267"></a><span id="l16.3267" class="difflineplus">+bd088d5f42f6417191de93908c803d0e76199292b485af41b60e8d9c3c537f0e</span>
<a href="#l16.3268"></a><span id="l16.3268" class="difflineplus">+8211f0c7211a077707dc18b931b2ee6d80a4d7ae024491ebc24d4a708ff70680</span>
<a href="#l16.3269"></a><span id="l16.3269" class="difflineplus">+7f25e807e8785f1878e322d6ddaf453f0770ff2dfa769b01423dbbad72a391b6</span>
<a href="#l16.3270"></a><span id="l16.3270" class="difflineplus">+5a7c3235985629423372494cab55c8f7d64a8b27a0e7202c55a13b0f8d19c80e</span>
<a href="#l16.3271"></a><span id="l16.3271" class="difflineplus">+4ae9ca3f015115dc3ca467c17a4c7ee95970ab10e5a54ff0ac3cd39881ee5958</span>
<a href="#l16.3272"></a><span id="l16.3272" class="difflineplus">+1a84f03df0be0e492fd855a8d6aa35d10b4962dbb0a604a3d3ee5e80a8eee600</span>
<a href="#l16.3273"></a><span id="l16.3273" class="difflineplus">+a24977f8660378bf0bbf00e01d0a8fb7f980f04b8aa6ce6aca8d5a7533c52753</span>
<a href="#l16.3274"></a><span id="l16.3274" class="difflineplus">+839152c4e222f4dc512dd5eb90cbc981e8ea12cf90cd8a8bf47d89159e2741d3</span>
<a href="#l16.3275"></a><span id="l16.3275" class="difflineplus">+7124f65b96fcd254dae258fa84a13c13043246a32129574787e49eae2b49b86d</span>
<a href="#l16.3276"></a><span id="l16.3276" class="difflineplus">+c3e2e78b9ff7f4002415bb08907c66df0d103b4e0c104db90500ff70700c203a</span>
<a href="#l16.3277"></a><span id="l16.3277" class="difflineplus">+ee1e82dba4c3e16e256c0acca6ceaae9afd1f612d7eb472157ac95962bd05594</span>
<a href="#l16.3278"></a><span id="l16.3278" class="difflineplus">+7dd1598466053245088e827f44628657942a825b84e4fb601f84b4025611aca3</span>
<a href="#l16.3279"></a><span id="l16.3279" class="difflineplus">+901e01bb024911dc0a4445f08e41f83df02b10142173149ab71baf027611ea95</span>
<a href="#l16.3280"></a><span id="l16.3280" class="difflineplus">+7a257704201d14cd9af4d90b00f194530088cb4e09c0df1c5c0088f7393f6833</span>
<a href="#l16.3281"></a><span id="l16.3281" class="difflineplus">+c0aa3ac156655de3bca9b34ab9716906ba07aba5e5bba1eb3358d90b9da7c533</span>
<a href="#l16.3282"></a><span id="l16.3282" class="difflineplus">+64f6888bf47b60f521e8380fe10be03d2feac17900927560df40f4e48f805960</span>
<a href="#l16.3283"></a><span id="l16.3283" class="difflineplus">+50328d648bf4893f9067c217a0631656b7c898c122847bc07b03a2d3e0ee85e4</span>
<a href="#l16.3284"></a><span id="l16.3284" class="difflineplus">+33b0ef867450c4fad2ecd26cf7168074c0ba0c904cdac300c9cfec4701924df6</span>
<a href="#l16.3285"></a><span id="l16.3285" class="difflineplus">+1cdca61e10685c6f7d52d0caba1498972f43d740adb4b2009d7d7220b20e3473</span>
<a href="#l16.3286"></a><span id="l16.3286" class="difflineplus">+90a943d00ffe959bb6eac3e0fe42ea49ee00c45f06e76329b1dabf127d690d80</span>
<a href="#l16.3287"></a><span id="l16.3287" class="difflineplus">+5581b408f63c2403e0cc433c00ee658836803b0fd100747c04ab5f917704fd10</span>
<a href="#l16.3288"></a><span id="l16.3288" class="difflineplus">+d5c1cd41ec801343d207f602a403605d86e5f9e5f9ae0d00e994556833806685</span>
<a href="#l16.3289"></a><span id="l16.3289" class="difflineplus">+c931fb709b0f08b4e869bea5c827859549e82c544b8d29c816a0390999613920</span>
<a href="#l16.3290"></a><span id="l16.3290" class="difflineplus">+7e610d5727a16318c2003c1fa24be0de2b32caf92224e7c17e5004b6350c4c01</span>
<a href="#l16.3291"></a><span id="l16.3291" class="difflineplus">+05601218066b0ad28224e149019c086257ca315102de2712903bde97b8144d82</span>
<a href="#l16.3292"></a><span id="l16.3292" class="difflineplus">+3b2c6ac52d403c054e019249b087f53d0558995a99ea946c70cc927458b3c1ff</span>
<a href="#l16.3293"></a><span id="l16.3293" class="difflineplus">+550f30050df988d4284376b4566a8e416654cc921985e037e0df0fc131f00f4b</span>
<a href="#l16.3294"></a><span id="l16.3294" class="difflineplus">+acf0c6211c036f14a239703741740adc7da227edd7e56b833d0ae92549b4d357</span>
<a href="#l16.3295"></a><span id="l16.3295" class="difflineplus">+25dfb49ed2ff63908e6adf27d6d0dda7638d4154d2778daca17f58e61297c129</span>
<a href="#l16.3296"></a><span id="l16.3296" class="difflineplus">+41f233b01f5dc3740cac51688c35c6b22580f48224fee9b83502569a66b629f1</span>
<a href="#l16.3297"></a><span id="l16.3297" class="difflineplus">+09f3713473413e2666e7fe6f6c6efefdfafda1f56f6e06f93496d9d67cb7366a</span>
<a href="#l16.3298"></a><span id="l16.3298" class="difflineplus">+9964b6f92e64b689196ec6c604646fd3fe4771ff1bf03f65d8ecc3addbb5f300</span>
<a href="#l16.3299"></a><span id="l16.3299" class="difflineplus">+00000049454e44ae426082</span>
<a href="#l16.3300"></a><span id="l16.3300" class="difflineplus">+&quot;&quot;&quot;),</span>
<a href="#l16.3301"></a><span id="l16.3301" class="difflineplus">+}</span>
<a href="#l16.3302"></a><span id="l16.3302" class="difflineplus">+</span>
<a href="#l16.3303"></a><span id="l16.3303" class="difflineplus">+def test_suite(options, args):</span>
<a href="#l16.3304"></a><span id="l16.3304" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3305"></a><span id="l16.3305" class="difflineplus">+    Create a PNG test image and write the file to stdout.</span>
<a href="#l16.3306"></a><span id="l16.3306" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3307"></a><span id="l16.3307" class="difflineplus">+</span>
<a href="#l16.3308"></a><span id="l16.3308" class="difflineplus">+    # Below is a big stack of test image generators.</span>
<a href="#l16.3309"></a><span id="l16.3309" class="difflineplus">+    # They're all really tiny, so PEP 8 rules are suspended.</span>
<a href="#l16.3310"></a><span id="l16.3310" class="difflineplus">+</span>
<a href="#l16.3311"></a><span id="l16.3311" class="difflineplus">+    def test_gradient_horizontal_lr(x, y): return x</span>
<a href="#l16.3312"></a><span id="l16.3312" class="difflineplus">+    def test_gradient_horizontal_rl(x, y): return 1-x</span>
<a href="#l16.3313"></a><span id="l16.3313" class="difflineplus">+    def test_gradient_vertical_tb(x, y): return y</span>
<a href="#l16.3314"></a><span id="l16.3314" class="difflineplus">+    def test_gradient_vertical_bt(x, y): return 1-y</span>
<a href="#l16.3315"></a><span id="l16.3315" class="difflineplus">+    def test_radial_tl(x, y): return max(1-math.sqrt(x*x+y*y), 0.0)</span>
<a href="#l16.3316"></a><span id="l16.3316" class="difflineplus">+    def test_radial_center(x, y): return test_radial_tl(x-0.5, y-0.5)</span>
<a href="#l16.3317"></a><span id="l16.3317" class="difflineplus">+    def test_radial_tr(x, y): return test_radial_tl(1-x, y)</span>
<a href="#l16.3318"></a><span id="l16.3318" class="difflineplus">+    def test_radial_bl(x, y): return test_radial_tl(x, 1-y)</span>
<a href="#l16.3319"></a><span id="l16.3319" class="difflineplus">+    def test_radial_br(x, y): return test_radial_tl(1-x, 1-y)</span>
<a href="#l16.3320"></a><span id="l16.3320" class="difflineplus">+    def test_stripe(x, n): return float(int(x*n) &amp; 1)</span>
<a href="#l16.3321"></a><span id="l16.3321" class="difflineplus">+    def test_stripe_h_2(x, y): return test_stripe(x, 2)</span>
<a href="#l16.3322"></a><span id="l16.3322" class="difflineplus">+    def test_stripe_h_4(x, y): return test_stripe(x, 4)</span>
<a href="#l16.3323"></a><span id="l16.3323" class="difflineplus">+    def test_stripe_h_10(x, y): return test_stripe(x, 10)</span>
<a href="#l16.3324"></a><span id="l16.3324" class="difflineplus">+    def test_stripe_v_2(x, y): return test_stripe(y, 2)</span>
<a href="#l16.3325"></a><span id="l16.3325" class="difflineplus">+    def test_stripe_v_4(x, y): return test_stripe(y, 4)</span>
<a href="#l16.3326"></a><span id="l16.3326" class="difflineplus">+    def test_stripe_v_10(x, y): return test_stripe(y, 10)</span>
<a href="#l16.3327"></a><span id="l16.3327" class="difflineplus">+    def test_stripe_lr_10(x, y): return test_stripe(x+y, 10)</span>
<a href="#l16.3328"></a><span id="l16.3328" class="difflineplus">+    def test_stripe_rl_10(x, y): return test_stripe(1+x-y, 10)</span>
<a href="#l16.3329"></a><span id="l16.3329" class="difflineplus">+    def test_checker(x, y, n): return float((int(x*n) &amp; 1) ^ (int(y*n) &amp; 1))</span>
<a href="#l16.3330"></a><span id="l16.3330" class="difflineplus">+    def test_checker_8(x, y): return test_checker(x, y, 8)</span>
<a href="#l16.3331"></a><span id="l16.3331" class="difflineplus">+    def test_checker_15(x, y): return test_checker(x, y, 15)</span>
<a href="#l16.3332"></a><span id="l16.3332" class="difflineplus">+    def test_zero(x, y): return 0</span>
<a href="#l16.3333"></a><span id="l16.3333" class="difflineplus">+    def test_one(x, y): return 1</span>
<a href="#l16.3334"></a><span id="l16.3334" class="difflineplus">+</span>
<a href="#l16.3335"></a><span id="l16.3335" class="difflineplus">+    test_patterns = {</span>
<a href="#l16.3336"></a><span id="l16.3336" class="difflineplus">+        'GLR': test_gradient_horizontal_lr,</span>
<a href="#l16.3337"></a><span id="l16.3337" class="difflineplus">+        'GRL': test_gradient_horizontal_rl,</span>
<a href="#l16.3338"></a><span id="l16.3338" class="difflineplus">+        'GTB': test_gradient_vertical_tb,</span>
<a href="#l16.3339"></a><span id="l16.3339" class="difflineplus">+        'GBT': test_gradient_vertical_bt,</span>
<a href="#l16.3340"></a><span id="l16.3340" class="difflineplus">+        'RTL': test_radial_tl,</span>
<a href="#l16.3341"></a><span id="l16.3341" class="difflineplus">+        'RTR': test_radial_tr,</span>
<a href="#l16.3342"></a><span id="l16.3342" class="difflineplus">+        'RBL': test_radial_bl,</span>
<a href="#l16.3343"></a><span id="l16.3343" class="difflineplus">+        'RBR': test_radial_br,</span>
<a href="#l16.3344"></a><span id="l16.3344" class="difflineplus">+        'RCTR': test_radial_center,</span>
<a href="#l16.3345"></a><span id="l16.3345" class="difflineplus">+        'HS2': test_stripe_h_2,</span>
<a href="#l16.3346"></a><span id="l16.3346" class="difflineplus">+        'HS4': test_stripe_h_4,</span>
<a href="#l16.3347"></a><span id="l16.3347" class="difflineplus">+        'HS10': test_stripe_h_10,</span>
<a href="#l16.3348"></a><span id="l16.3348" class="difflineplus">+        'VS2': test_stripe_v_2,</span>
<a href="#l16.3349"></a><span id="l16.3349" class="difflineplus">+        'VS4': test_stripe_v_4,</span>
<a href="#l16.3350"></a><span id="l16.3350" class="difflineplus">+        'VS10': test_stripe_v_10,</span>
<a href="#l16.3351"></a><span id="l16.3351" class="difflineplus">+        'LRS': test_stripe_lr_10,</span>
<a href="#l16.3352"></a><span id="l16.3352" class="difflineplus">+        'RLS': test_stripe_rl_10,</span>
<a href="#l16.3353"></a><span id="l16.3353" class="difflineplus">+        'CK8': test_checker_8,</span>
<a href="#l16.3354"></a><span id="l16.3354" class="difflineplus">+        'CK15': test_checker_15,</span>
<a href="#l16.3355"></a><span id="l16.3355" class="difflineplus">+        'ZERO': test_zero,</span>
<a href="#l16.3356"></a><span id="l16.3356" class="difflineplus">+        'ONE': test_one,</span>
<a href="#l16.3357"></a><span id="l16.3357" class="difflineplus">+        }</span>
<a href="#l16.3358"></a><span id="l16.3358" class="difflineplus">+</span>
<a href="#l16.3359"></a><span id="l16.3359" class="difflineplus">+    def test_pattern(width, height, bitdepth, pattern):</span>
<a href="#l16.3360"></a><span id="l16.3360" class="difflineplus">+        &quot;&quot;&quot;Create a single plane (monochrome) test pattern.  Returns a</span>
<a href="#l16.3361"></a><span id="l16.3361" class="difflineplus">+        flat row flat pixel array.</span>
<a href="#l16.3362"></a><span id="l16.3362" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.3363"></a><span id="l16.3363" class="difflineplus">+</span>
<a href="#l16.3364"></a><span id="l16.3364" class="difflineplus">+        maxval = 2**bitdepth-1</span>
<a href="#l16.3365"></a><span id="l16.3365" class="difflineplus">+        if maxval &gt; 255:</span>
<a href="#l16.3366"></a><span id="l16.3366" class="difflineplus">+            a = array('H')</span>
<a href="#l16.3367"></a><span id="l16.3367" class="difflineplus">+        else:</span>
<a href="#l16.3368"></a><span id="l16.3368" class="difflineplus">+            a = array('B')</span>
<a href="#l16.3369"></a><span id="l16.3369" class="difflineplus">+        fw = float(width)</span>
<a href="#l16.3370"></a><span id="l16.3370" class="difflineplus">+        fh = float(height)</span>
<a href="#l16.3371"></a><span id="l16.3371" class="difflineplus">+        pfun = test_patterns[pattern]</span>
<a href="#l16.3372"></a><span id="l16.3372" class="difflineplus">+        for y in range(height):</span>
<a href="#l16.3373"></a><span id="l16.3373" class="difflineplus">+            fy = float(y)/fh</span>
<a href="#l16.3374"></a><span id="l16.3374" class="difflineplus">+            for x in range(width):</span>
<a href="#l16.3375"></a><span id="l16.3375" class="difflineplus">+                a.append(int(round(pfun(float(x)/fw, fy) * maxval)))</span>
<a href="#l16.3376"></a><span id="l16.3376" class="difflineplus">+        return a</span>
<a href="#l16.3377"></a><span id="l16.3377" class="difflineplus">+</span>
<a href="#l16.3378"></a><span id="l16.3378" class="difflineplus">+    def test_rgba(size=256, bitdepth=8,</span>
<a href="#l16.3379"></a><span id="l16.3379" class="difflineplus">+                    red=&quot;GTB&quot;, green=&quot;GLR&quot;, blue=&quot;RTL&quot;, alpha=None):</span>
<a href="#l16.3380"></a><span id="l16.3380" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.3381"></a><span id="l16.3381" class="difflineplus">+        Create a test image.  Each channel is generated from the</span>
<a href="#l16.3382"></a><span id="l16.3382" class="difflineplus">+        specified pattern; any channel apart from red can be set to</span>
<a href="#l16.3383"></a><span id="l16.3383" class="difflineplus">+        None, which will cause it not to be in the image.  It</span>
<a href="#l16.3384"></a><span id="l16.3384" class="difflineplus">+        is possible to create all PNG channel types (L, RGB, LA, RGBA),</span>
<a href="#l16.3385"></a><span id="l16.3385" class="difflineplus">+        as well as non PNG channel types (RGA, and so on).</span>
<a href="#l16.3386"></a><span id="l16.3386" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.3387"></a><span id="l16.3387" class="difflineplus">+</span>
<a href="#l16.3388"></a><span id="l16.3388" class="difflineplus">+        i = test_pattern(size, size, bitdepth, red)</span>
<a href="#l16.3389"></a><span id="l16.3389" class="difflineplus">+        psize = 1</span>
<a href="#l16.3390"></a><span id="l16.3390" class="difflineplus">+        for channel in (green, blue, alpha):</span>
<a href="#l16.3391"></a><span id="l16.3391" class="difflineplus">+            if channel:</span>
<a href="#l16.3392"></a><span id="l16.3392" class="difflineplus">+                c = test_pattern(size, size, bitdepth, channel)</span>
<a href="#l16.3393"></a><span id="l16.3393" class="difflineplus">+                i = interleave_planes(i, c, psize, 1)</span>
<a href="#l16.3394"></a><span id="l16.3394" class="difflineplus">+                psize += 1</span>
<a href="#l16.3395"></a><span id="l16.3395" class="difflineplus">+        return i</span>
<a href="#l16.3396"></a><span id="l16.3396" class="difflineplus">+</span>
<a href="#l16.3397"></a><span id="l16.3397" class="difflineplus">+    def pngsuite_image(name):</span>
<a href="#l16.3398"></a><span id="l16.3398" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.3399"></a><span id="l16.3399" class="difflineplus">+        Create a test image by reading an internal copy of the files</span>
<a href="#l16.3400"></a><span id="l16.3400" class="difflineplus">+        from the PngSuite.  Returned in flat row flat pixel format.</span>
<a href="#l16.3401"></a><span id="l16.3401" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l16.3402"></a><span id="l16.3402" class="difflineplus">+</span>
<a href="#l16.3403"></a><span id="l16.3403" class="difflineplus">+        if name not in _pngsuite:</span>
<a href="#l16.3404"></a><span id="l16.3404" class="difflineplus">+            raise NotImplementedError(&quot;cannot find PngSuite file %s (use -L for a list)&quot; % name)</span>
<a href="#l16.3405"></a><span id="l16.3405" class="difflineplus">+        r = Reader(bytes=_pngsuite[name])</span>
<a href="#l16.3406"></a><span id="l16.3406" class="difflineplus">+        w,h,pixels,meta = r.asDirect()</span>
<a href="#l16.3407"></a><span id="l16.3407" class="difflineplus">+        assert w == h</span>
<a href="#l16.3408"></a><span id="l16.3408" class="difflineplus">+        # LAn for n &lt; 8 is a special case for which we need to rescale</span>
<a href="#l16.3409"></a><span id="l16.3409" class="difflineplus">+        # the data.</span>
<a href="#l16.3410"></a><span id="l16.3410" class="difflineplus">+        if meta['greyscale'] and meta['alpha'] and meta['bitdepth'] &lt; 8:</span>
<a href="#l16.3411"></a><span id="l16.3411" class="difflineplus">+            factor = 255 // (2**meta['bitdepth']-1)</span>
<a href="#l16.3412"></a><span id="l16.3412" class="difflineplus">+            def rescale(data):</span>
<a href="#l16.3413"></a><span id="l16.3413" class="difflineplus">+                for row in data:</span>
<a href="#l16.3414"></a><span id="l16.3414" class="difflineplus">+                    yield map(factor.__mul__, row)</span>
<a href="#l16.3415"></a><span id="l16.3415" class="difflineplus">+            pixels = rescale(pixels)</span>
<a href="#l16.3416"></a><span id="l16.3416" class="difflineplus">+            meta['bitdepth'] = 8</span>
<a href="#l16.3417"></a><span id="l16.3417" class="difflineplus">+        arraycode = 'BH'[meta['bitdepth']&gt;8]</span>
<a href="#l16.3418"></a><span id="l16.3418" class="difflineplus">+        return w, array(arraycode, itertools.chain(*pixels)), meta</span>
<a href="#l16.3419"></a><span id="l16.3419" class="difflineplus">+</span>
<a href="#l16.3420"></a><span id="l16.3420" class="difflineplus">+    # The body of test_suite()</span>
<a href="#l16.3421"></a><span id="l16.3421" class="difflineplus">+    size = 256</span>
<a href="#l16.3422"></a><span id="l16.3422" class="difflineplus">+    if options.test_size:</span>
<a href="#l16.3423"></a><span id="l16.3423" class="difflineplus">+        size = options.test_size</span>
<a href="#l16.3424"></a><span id="l16.3424" class="difflineplus">+    options.bitdepth = options.test_depth</span>
<a href="#l16.3425"></a><span id="l16.3425" class="difflineplus">+    options.greyscale=bool(options.test_black)</span>
<a href="#l16.3426"></a><span id="l16.3426" class="difflineplus">+</span>
<a href="#l16.3427"></a><span id="l16.3427" class="difflineplus">+    kwargs = {}</span>
<a href="#l16.3428"></a><span id="l16.3428" class="difflineplus">+    if options.test_red:</span>
<a href="#l16.3429"></a><span id="l16.3429" class="difflineplus">+        kwargs[&quot;red&quot;] = options.test_red</span>
<a href="#l16.3430"></a><span id="l16.3430" class="difflineplus">+    if options.test_green:</span>
<a href="#l16.3431"></a><span id="l16.3431" class="difflineplus">+        kwargs[&quot;green&quot;] = options.test_green</span>
<a href="#l16.3432"></a><span id="l16.3432" class="difflineplus">+    if options.test_blue:</span>
<a href="#l16.3433"></a><span id="l16.3433" class="difflineplus">+        kwargs[&quot;blue&quot;] = options.test_blue</span>
<a href="#l16.3434"></a><span id="l16.3434" class="difflineplus">+    if options.test_alpha:</span>
<a href="#l16.3435"></a><span id="l16.3435" class="difflineplus">+        kwargs[&quot;alpha&quot;] = options.test_alpha</span>
<a href="#l16.3436"></a><span id="l16.3436" class="difflineplus">+    if options.greyscale:</span>
<a href="#l16.3437"></a><span id="l16.3437" class="difflineplus">+        if options.test_red or options.test_green or options.test_blue:</span>
<a href="#l16.3438"></a><span id="l16.3438" class="difflineplus">+            raise ValueError(&quot;cannot specify colours (R, G, B) when greyscale image (black channel, K) is specified&quot;)</span>
<a href="#l16.3439"></a><span id="l16.3439" class="difflineplus">+        kwargs[&quot;red&quot;] = options.test_black</span>
<a href="#l16.3440"></a><span id="l16.3440" class="difflineplus">+        kwargs[&quot;green&quot;] = None</span>
<a href="#l16.3441"></a><span id="l16.3441" class="difflineplus">+        kwargs[&quot;blue&quot;] = None</span>
<a href="#l16.3442"></a><span id="l16.3442" class="difflineplus">+    options.alpha = bool(options.test_alpha)</span>
<a href="#l16.3443"></a><span id="l16.3443" class="difflineplus">+    if not args:</span>
<a href="#l16.3444"></a><span id="l16.3444" class="difflineplus">+        pixels = test_rgba(size, options.bitdepth, **kwargs)</span>
<a href="#l16.3445"></a><span id="l16.3445" class="difflineplus">+    else:</span>
<a href="#l16.3446"></a><span id="l16.3446" class="difflineplus">+        size,pixels,meta = pngsuite_image(args[0])</span>
<a href="#l16.3447"></a><span id="l16.3447" class="difflineplus">+        for k in ['bitdepth', 'alpha', 'greyscale']:</span>
<a href="#l16.3448"></a><span id="l16.3448" class="difflineplus">+            setattr(options, k, meta[k])</span>
<a href="#l16.3449"></a><span id="l16.3449" class="difflineplus">+</span>
<a href="#l16.3450"></a><span id="l16.3450" class="difflineplus">+    writer = Writer(size, size,</span>
<a href="#l16.3451"></a><span id="l16.3451" class="difflineplus">+                    bitdepth=options.bitdepth,</span>
<a href="#l16.3452"></a><span id="l16.3452" class="difflineplus">+                    transparent=options.transparent,</span>
<a href="#l16.3453"></a><span id="l16.3453" class="difflineplus">+                    background=options.background,</span>
<a href="#l16.3454"></a><span id="l16.3454" class="difflineplus">+                    gamma=options.gamma,</span>
<a href="#l16.3455"></a><span id="l16.3455" class="difflineplus">+                    greyscale=options.greyscale,</span>
<a href="#l16.3456"></a><span id="l16.3456" class="difflineplus">+                    alpha=options.alpha,</span>
<a href="#l16.3457"></a><span id="l16.3457" class="difflineplus">+                    compression=options.compression,</span>
<a href="#l16.3458"></a><span id="l16.3458" class="difflineplus">+                    interlace=options.interlace)</span>
<a href="#l16.3459"></a><span id="l16.3459" class="difflineplus">+    writer.write_array(sys.stdout, pixels)</span>
<a href="#l16.3460"></a><span id="l16.3460" class="difflineplus">+</span>
<a href="#l16.3461"></a><span id="l16.3461" class="difflineplus">+def read_pam_header(infile):</span>
<a href="#l16.3462"></a><span id="l16.3462" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3463"></a><span id="l16.3463" class="difflineplus">+    Read (the rest of a) PAM header.  `infile` should be positioned</span>
<a href="#l16.3464"></a><span id="l16.3464" class="difflineplus">+    immediately after the initial 'P7' line (at the beginning of the</span>
<a href="#l16.3465"></a><span id="l16.3465" class="difflineplus">+    second line).  Returns are as for `read_pnm_header`.</span>
<a href="#l16.3466"></a><span id="l16.3466" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3467"></a><span id="l16.3467" class="difflineplus">+    </span>
<a href="#l16.3468"></a><span id="l16.3468" class="difflineplus">+    # Unlike PBM, PGM, and PPM, we can read the header a line at a time.</span>
<a href="#l16.3469"></a><span id="l16.3469" class="difflineplus">+    header = dict()</span>
<a href="#l16.3470"></a><span id="l16.3470" class="difflineplus">+    while True:</span>
<a href="#l16.3471"></a><span id="l16.3471" class="difflineplus">+        l = infile.readline().strip()</span>
<a href="#l16.3472"></a><span id="l16.3472" class="difflineplus">+        if l == strtobytes('ENDHDR'):</span>
<a href="#l16.3473"></a><span id="l16.3473" class="difflineplus">+            break</span>
<a href="#l16.3474"></a><span id="l16.3474" class="difflineplus">+        if not l:</span>
<a href="#l16.3475"></a><span id="l16.3475" class="difflineplus">+            raise EOFError('PAM ended prematurely')</span>
<a href="#l16.3476"></a><span id="l16.3476" class="difflineplus">+        if l[0] == strtobytes('#'):</span>
<a href="#l16.3477"></a><span id="l16.3477" class="difflineplus">+            continue</span>
<a href="#l16.3478"></a><span id="l16.3478" class="difflineplus">+        l = l.split(None, 1)</span>
<a href="#l16.3479"></a><span id="l16.3479" class="difflineplus">+        if l[0] not in header:</span>
<a href="#l16.3480"></a><span id="l16.3480" class="difflineplus">+            header[l[0]] = l[1]</span>
<a href="#l16.3481"></a><span id="l16.3481" class="difflineplus">+        else:</span>
<a href="#l16.3482"></a><span id="l16.3482" class="difflineplus">+            header[l[0]] += strtobytes(' ') + l[1]</span>
<a href="#l16.3483"></a><span id="l16.3483" class="difflineplus">+</span>
<a href="#l16.3484"></a><span id="l16.3484" class="difflineplus">+    required = ['WIDTH', 'HEIGHT', 'DEPTH', 'MAXVAL']</span>
<a href="#l16.3485"></a><span id="l16.3485" class="difflineplus">+    required = [strtobytes(x) for x in required]</span>
<a href="#l16.3486"></a><span id="l16.3486" class="difflineplus">+    WIDTH,HEIGHT,DEPTH,MAXVAL = required</span>
<a href="#l16.3487"></a><span id="l16.3487" class="difflineplus">+    present = [x for x in required if x in header]</span>
<a href="#l16.3488"></a><span id="l16.3488" class="difflineplus">+    if len(present) != len(required):</span>
<a href="#l16.3489"></a><span id="l16.3489" class="difflineplus">+        raise Error('PAM file must specify WIDTH, HEIGHT, DEPTH, and MAXVAL')</span>
<a href="#l16.3490"></a><span id="l16.3490" class="difflineplus">+    width = int(header[WIDTH])</span>
<a href="#l16.3491"></a><span id="l16.3491" class="difflineplus">+    height = int(header[HEIGHT])</span>
<a href="#l16.3492"></a><span id="l16.3492" class="difflineplus">+    depth = int(header[DEPTH])</span>
<a href="#l16.3493"></a><span id="l16.3493" class="difflineplus">+    maxval = int(header[MAXVAL])</span>
<a href="#l16.3494"></a><span id="l16.3494" class="difflineplus">+    if (width &lt;= 0 or</span>
<a href="#l16.3495"></a><span id="l16.3495" class="difflineplus">+        height &lt;= 0 or</span>
<a href="#l16.3496"></a><span id="l16.3496" class="difflineplus">+        depth &lt;= 0 or</span>
<a href="#l16.3497"></a><span id="l16.3497" class="difflineplus">+        maxval &lt;= 0):</span>
<a href="#l16.3498"></a><span id="l16.3498" class="difflineplus">+        raise Error(</span>
<a href="#l16.3499"></a><span id="l16.3499" class="difflineplus">+          'WIDTH, HEIGHT, DEPTH, MAXVAL must all be positive integers')</span>
<a href="#l16.3500"></a><span id="l16.3500" class="difflineplus">+    return 'P7', width, height, depth, maxval</span>
<a href="#l16.3501"></a><span id="l16.3501" class="difflineplus">+</span>
<a href="#l16.3502"></a><span id="l16.3502" class="difflineplus">+def read_pnm_header(infile, supported=('P5','P6')):</span>
<a href="#l16.3503"></a><span id="l16.3503" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3504"></a><span id="l16.3504" class="difflineplus">+    Read a PNM header, returning (format,width,height,depth,maxval).</span>
<a href="#l16.3505"></a><span id="l16.3505" class="difflineplus">+    `width` and `height` are in pixels.  `depth` is the number of</span>
<a href="#l16.3506"></a><span id="l16.3506" class="difflineplus">+    channels in the image; for PBM and PGM it is synthesized as 1, for</span>
<a href="#l16.3507"></a><span id="l16.3507" class="difflineplus">+    PPM as 3; for PAM images it is read from the header.  `maxval` is</span>
<a href="#l16.3508"></a><span id="l16.3508" class="difflineplus">+    synthesized (as 1) for PBM images.</span>
<a href="#l16.3509"></a><span id="l16.3509" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3510"></a><span id="l16.3510" class="difflineplus">+</span>
<a href="#l16.3511"></a><span id="l16.3511" class="difflineplus">+    # Generally, see http://netpbm.sourceforge.net/doc/ppm.html</span>
<a href="#l16.3512"></a><span id="l16.3512" class="difflineplus">+    # and http://netpbm.sourceforge.net/doc/pam.html</span>
<a href="#l16.3513"></a><span id="l16.3513" class="difflineplus">+</span>
<a href="#l16.3514"></a><span id="l16.3514" class="difflineplus">+    supported = [strtobytes(x) for x in supported]</span>
<a href="#l16.3515"></a><span id="l16.3515" class="difflineplus">+</span>
<a href="#l16.3516"></a><span id="l16.3516" class="difflineplus">+    # Technically 'P7' must be followed by a newline, so by using</span>
<a href="#l16.3517"></a><span id="l16.3517" class="difflineplus">+    # rstrip() we are being liberal in what we accept.  I think this</span>
<a href="#l16.3518"></a><span id="l16.3518" class="difflineplus">+    # is acceptable.</span>
<a href="#l16.3519"></a><span id="l16.3519" class="difflineplus">+    type = infile.read(3).rstrip()</span>
<a href="#l16.3520"></a><span id="l16.3520" class="difflineplus">+    if type not in supported:</span>
<a href="#l16.3521"></a><span id="l16.3521" class="difflineplus">+        raise NotImplementedError('file format %s not supported' % type)</span>
<a href="#l16.3522"></a><span id="l16.3522" class="difflineplus">+    if type == strtobytes('P7'):</span>
<a href="#l16.3523"></a><span id="l16.3523" class="difflineplus">+        # PAM header parsing is completely different.</span>
<a href="#l16.3524"></a><span id="l16.3524" class="difflineplus">+        return read_pam_header(infile)</span>
<a href="#l16.3525"></a><span id="l16.3525" class="difflineplus">+    # Expected number of tokens in header (3 for P4, 4 for P6)</span>
<a href="#l16.3526"></a><span id="l16.3526" class="difflineplus">+    expected = 4</span>
<a href="#l16.3527"></a><span id="l16.3527" class="difflineplus">+    pbm = ('P1', 'P4')</span>
<a href="#l16.3528"></a><span id="l16.3528" class="difflineplus">+    if type in pbm:</span>
<a href="#l16.3529"></a><span id="l16.3529" class="difflineplus">+        expected = 3</span>
<a href="#l16.3530"></a><span id="l16.3530" class="difflineplus">+    header = [type]</span>
<a href="#l16.3531"></a><span id="l16.3531" class="difflineplus">+</span>
<a href="#l16.3532"></a><span id="l16.3532" class="difflineplus">+    # We have to read the rest of the header byte by byte because the</span>
<a href="#l16.3533"></a><span id="l16.3533" class="difflineplus">+    # final whitespace character (immediately following the MAXVAL in</span>
<a href="#l16.3534"></a><span id="l16.3534" class="difflineplus">+    # the case of P6) may not be a newline.  Of course all PNM files in</span>
<a href="#l16.3535"></a><span id="l16.3535" class="difflineplus">+    # the wild use a newline at this point, so it's tempting to use</span>
<a href="#l16.3536"></a><span id="l16.3536" class="difflineplus">+    # readline; but it would be wrong.</span>
<a href="#l16.3537"></a><span id="l16.3537" class="difflineplus">+    def getc():</span>
<a href="#l16.3538"></a><span id="l16.3538" class="difflineplus">+        c = infile.read(1)</span>
<a href="#l16.3539"></a><span id="l16.3539" class="difflineplus">+        if not c:</span>
<a href="#l16.3540"></a><span id="l16.3540" class="difflineplus">+            raise Error('premature EOF reading PNM header')</span>
<a href="#l16.3541"></a><span id="l16.3541" class="difflineplus">+        return c</span>
<a href="#l16.3542"></a><span id="l16.3542" class="difflineplus">+</span>
<a href="#l16.3543"></a><span id="l16.3543" class="difflineplus">+    c = getc()</span>
<a href="#l16.3544"></a><span id="l16.3544" class="difflineplus">+    while True:</span>
<a href="#l16.3545"></a><span id="l16.3545" class="difflineplus">+        # Skip whitespace that precedes a token.</span>
<a href="#l16.3546"></a><span id="l16.3546" class="difflineplus">+        while c.isspace():</span>
<a href="#l16.3547"></a><span id="l16.3547" class="difflineplus">+            c = getc()</span>
<a href="#l16.3548"></a><span id="l16.3548" class="difflineplus">+        # Skip comments.</span>
<a href="#l16.3549"></a><span id="l16.3549" class="difflineplus">+        while c == '#':</span>
<a href="#l16.3550"></a><span id="l16.3550" class="difflineplus">+            while c not in '\n\r':</span>
<a href="#l16.3551"></a><span id="l16.3551" class="difflineplus">+                c = getc()</span>
<a href="#l16.3552"></a><span id="l16.3552" class="difflineplus">+        if not c.isdigit():</span>
<a href="#l16.3553"></a><span id="l16.3553" class="difflineplus">+            raise Error('unexpected character %s found in header' % c)</span>
<a href="#l16.3554"></a><span id="l16.3554" class="difflineplus">+        # According to the specification it is legal to have comments</span>
<a href="#l16.3555"></a><span id="l16.3555" class="difflineplus">+        # that appear in the middle of a token.</span>
<a href="#l16.3556"></a><span id="l16.3556" class="difflineplus">+        # This is bonkers; I've never seen it; and it's a bit awkward to</span>
<a href="#l16.3557"></a><span id="l16.3557" class="difflineplus">+        # code good lexers in Python (no goto).  So we break on such</span>
<a href="#l16.3558"></a><span id="l16.3558" class="difflineplus">+        # cases.</span>
<a href="#l16.3559"></a><span id="l16.3559" class="difflineplus">+        token = strtobytes('')</span>
<a href="#l16.3560"></a><span id="l16.3560" class="difflineplus">+        while c.isdigit():</span>
<a href="#l16.3561"></a><span id="l16.3561" class="difflineplus">+            token += c</span>
<a href="#l16.3562"></a><span id="l16.3562" class="difflineplus">+            c = getc()</span>
<a href="#l16.3563"></a><span id="l16.3563" class="difflineplus">+        # Slight hack.  All &quot;tokens&quot; are decimal integers, so convert</span>
<a href="#l16.3564"></a><span id="l16.3564" class="difflineplus">+        # them here.</span>
<a href="#l16.3565"></a><span id="l16.3565" class="difflineplus">+        header.append(int(token))</span>
<a href="#l16.3566"></a><span id="l16.3566" class="difflineplus">+        if len(header) == expected:</span>
<a href="#l16.3567"></a><span id="l16.3567" class="difflineplus">+            break</span>
<a href="#l16.3568"></a><span id="l16.3568" class="difflineplus">+    # Skip comments (again)</span>
<a href="#l16.3569"></a><span id="l16.3569" class="difflineplus">+    while c == '#':</span>
<a href="#l16.3570"></a><span id="l16.3570" class="difflineplus">+        while c not in '\n\r':</span>
<a href="#l16.3571"></a><span id="l16.3571" class="difflineplus">+            c = getc()</span>
<a href="#l16.3572"></a><span id="l16.3572" class="difflineplus">+    if not c.isspace():</span>
<a href="#l16.3573"></a><span id="l16.3573" class="difflineplus">+        raise Error('expected header to end with whitespace, not %s' % c)</span>
<a href="#l16.3574"></a><span id="l16.3574" class="difflineplus">+</span>
<a href="#l16.3575"></a><span id="l16.3575" class="difflineplus">+    if type in pbm:</span>
<a href="#l16.3576"></a><span id="l16.3576" class="difflineplus">+        # synthesize a MAXVAL</span>
<a href="#l16.3577"></a><span id="l16.3577" class="difflineplus">+        header.append(1)</span>
<a href="#l16.3578"></a><span id="l16.3578" class="difflineplus">+    depth = (1,3)[type == strtobytes('P6')]</span>
<a href="#l16.3579"></a><span id="l16.3579" class="difflineplus">+    return header[0], header[1], header[2], depth, header[3]</span>
<a href="#l16.3580"></a><span id="l16.3580" class="difflineplus">+</span>
<a href="#l16.3581"></a><span id="l16.3581" class="difflineplus">+def write_pnm(file, width, height, pixels, meta):</span>
<a href="#l16.3582"></a><span id="l16.3582" class="difflineplus">+    &quot;&quot;&quot;Write a Netpbm PNM/PAM file.&quot;&quot;&quot;</span>
<a href="#l16.3583"></a><span id="l16.3583" class="difflineplus">+</span>
<a href="#l16.3584"></a><span id="l16.3584" class="difflineplus">+    bitdepth = meta['bitdepth']</span>
<a href="#l16.3585"></a><span id="l16.3585" class="difflineplus">+    maxval = 2**bitdepth - 1</span>
<a href="#l16.3586"></a><span id="l16.3586" class="difflineplus">+    # Rudely, the number of image planes can be used to determine</span>
<a href="#l16.3587"></a><span id="l16.3587" class="difflineplus">+    # whether we are L (PGM), LA (PAM), RGB (PPM), or RGBA (PAM).</span>
<a href="#l16.3588"></a><span id="l16.3588" class="difflineplus">+    planes = meta['planes']</span>
<a href="#l16.3589"></a><span id="l16.3589" class="difflineplus">+    # Can be an assert as long as we assume that pixels and meta came</span>
<a href="#l16.3590"></a><span id="l16.3590" class="difflineplus">+    # from a PNG file.</span>
<a href="#l16.3591"></a><span id="l16.3591" class="difflineplus">+    assert planes in (1,2,3,4)</span>
<a href="#l16.3592"></a><span id="l16.3592" class="difflineplus">+    if planes in (1,3):</span>
<a href="#l16.3593"></a><span id="l16.3593" class="difflineplus">+        if 1 == planes:</span>
<a href="#l16.3594"></a><span id="l16.3594" class="difflineplus">+            # PGM</span>
<a href="#l16.3595"></a><span id="l16.3595" class="difflineplus">+            # Could generate PBM if maxval is 1, but we don't (for one</span>
<a href="#l16.3596"></a><span id="l16.3596" class="difflineplus">+            # thing, we'd have to convert the data, not just blat it</span>
<a href="#l16.3597"></a><span id="l16.3597" class="difflineplus">+            # out).</span>
<a href="#l16.3598"></a><span id="l16.3598" class="difflineplus">+            fmt = 'P5'</span>
<a href="#l16.3599"></a><span id="l16.3599" class="difflineplus">+        else:</span>
<a href="#l16.3600"></a><span id="l16.3600" class="difflineplus">+            # PPM</span>
<a href="#l16.3601"></a><span id="l16.3601" class="difflineplus">+            fmt = 'P6'</span>
<a href="#l16.3602"></a><span id="l16.3602" class="difflineplus">+        file.write('%s %d %d %d\n' % (fmt, width, height, maxval))</span>
<a href="#l16.3603"></a><span id="l16.3603" class="difflineplus">+    if planes in (2,4):</span>
<a href="#l16.3604"></a><span id="l16.3604" class="difflineplus">+        # PAM</span>
<a href="#l16.3605"></a><span id="l16.3605" class="difflineplus">+        # See http://netpbm.sourceforge.net/doc/pam.html</span>
<a href="#l16.3606"></a><span id="l16.3606" class="difflineplus">+        if 2 == planes:</span>
<a href="#l16.3607"></a><span id="l16.3607" class="difflineplus">+            tupltype = 'GRAYSCALE_ALPHA'</span>
<a href="#l16.3608"></a><span id="l16.3608" class="difflineplus">+        else:</span>
<a href="#l16.3609"></a><span id="l16.3609" class="difflineplus">+            tupltype = 'RGB_ALPHA'</span>
<a href="#l16.3610"></a><span id="l16.3610" class="difflineplus">+        file.write('P7\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\n'</span>
<a href="#l16.3611"></a><span id="l16.3611" class="difflineplus">+                   'TUPLTYPE %s\nENDHDR\n' %</span>
<a href="#l16.3612"></a><span id="l16.3612" class="difflineplus">+                   (width, height, planes, maxval, tupltype))</span>
<a href="#l16.3613"></a><span id="l16.3613" class="difflineplus">+    # Values per row</span>
<a href="#l16.3614"></a><span id="l16.3614" class="difflineplus">+    vpr = planes * width</span>
<a href="#l16.3615"></a><span id="l16.3615" class="difflineplus">+    # struct format</span>
<a href="#l16.3616"></a><span id="l16.3616" class="difflineplus">+    fmt = '&gt;%d' % vpr</span>
<a href="#l16.3617"></a><span id="l16.3617" class="difflineplus">+    if maxval &gt; 0xff:</span>
<a href="#l16.3618"></a><span id="l16.3618" class="difflineplus">+        fmt = fmt + 'H'</span>
<a href="#l16.3619"></a><span id="l16.3619" class="difflineplus">+    else:</span>
<a href="#l16.3620"></a><span id="l16.3620" class="difflineplus">+        fmt = fmt + 'B'</span>
<a href="#l16.3621"></a><span id="l16.3621" class="difflineplus">+    for row in pixels:</span>
<a href="#l16.3622"></a><span id="l16.3622" class="difflineplus">+        file.write(struct.pack(fmt, *row))</span>
<a href="#l16.3623"></a><span id="l16.3623" class="difflineplus">+    file.flush()</span>
<a href="#l16.3624"></a><span id="l16.3624" class="difflineplus">+</span>
<a href="#l16.3625"></a><span id="l16.3625" class="difflineplus">+def color_triple(color):</span>
<a href="#l16.3626"></a><span id="l16.3626" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3627"></a><span id="l16.3627" class="difflineplus">+    Convert a command line colour value to a RGB triple of integers.</span>
<a href="#l16.3628"></a><span id="l16.3628" class="difflineplus">+    FIXME: Somewhere we need support for greyscale backgrounds etc.</span>
<a href="#l16.3629"></a><span id="l16.3629" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3630"></a><span id="l16.3630" class="difflineplus">+    if color.startswith('#') and len(color) == 4:</span>
<a href="#l16.3631"></a><span id="l16.3631" class="difflineplus">+        return (int(color[1], 16),</span>
<a href="#l16.3632"></a><span id="l16.3632" class="difflineplus">+                int(color[2], 16),</span>
<a href="#l16.3633"></a><span id="l16.3633" class="difflineplus">+                int(color[3], 16))</span>
<a href="#l16.3634"></a><span id="l16.3634" class="difflineplus">+    if color.startswith('#') and len(color) == 7:</span>
<a href="#l16.3635"></a><span id="l16.3635" class="difflineplus">+        return (int(color[1:3], 16),</span>
<a href="#l16.3636"></a><span id="l16.3636" class="difflineplus">+                int(color[3:5], 16),</span>
<a href="#l16.3637"></a><span id="l16.3637" class="difflineplus">+                int(color[5:7], 16))</span>
<a href="#l16.3638"></a><span id="l16.3638" class="difflineplus">+    elif color.startswith('#') and len(color) == 13:</span>
<a href="#l16.3639"></a><span id="l16.3639" class="difflineplus">+        return (int(color[1:5], 16),</span>
<a href="#l16.3640"></a><span id="l16.3640" class="difflineplus">+                int(color[5:9], 16),</span>
<a href="#l16.3641"></a><span id="l16.3641" class="difflineplus">+                int(color[9:13], 16))</span>
<a href="#l16.3642"></a><span id="l16.3642" class="difflineplus">+</span>
<a href="#l16.3643"></a><span id="l16.3643" class="difflineplus">+</span>
<a href="#l16.3644"></a><span id="l16.3644" class="difflineplus">+def _main(argv):</span>
<a href="#l16.3645"></a><span id="l16.3645" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3646"></a><span id="l16.3646" class="difflineplus">+    Run the PNG encoder with options from the command line.</span>
<a href="#l16.3647"></a><span id="l16.3647" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l16.3648"></a><span id="l16.3648" class="difflineplus">+</span>
<a href="#l16.3649"></a><span id="l16.3649" class="difflineplus">+    # Parse command line arguments</span>
<a href="#l16.3650"></a><span id="l16.3650" class="difflineplus">+    from optparse import OptionParser</span>
<a href="#l16.3651"></a><span id="l16.3651" class="difflineplus">+    import re</span>
<a href="#l16.3652"></a><span id="l16.3652" class="difflineplus">+    version = '%prog ' + re.sub(r'( ?\$|URL: |Rev:)', '', __version__)</span>
<a href="#l16.3653"></a><span id="l16.3653" class="difflineplus">+    parser = OptionParser(version=version)</span>
<a href="#l16.3654"></a><span id="l16.3654" class="difflineplus">+    parser.set_usage(&quot;%prog [options] [imagefile]&quot;)</span>
<a href="#l16.3655"></a><span id="l16.3655" class="difflineplus">+    parser.add_option('-r', '--read-png', default=False,</span>
<a href="#l16.3656"></a><span id="l16.3656" class="difflineplus">+                      action='store_true',</span>
<a href="#l16.3657"></a><span id="l16.3657" class="difflineplus">+                      help='Read PNG, write PNM')</span>
<a href="#l16.3658"></a><span id="l16.3658" class="difflineplus">+    parser.add_option(&quot;-i&quot;, &quot;--interlace&quot;,</span>
<a href="#l16.3659"></a><span id="l16.3659" class="difflineplus">+                      default=False, action=&quot;store_true&quot;,</span>
<a href="#l16.3660"></a><span id="l16.3660" class="difflineplus">+                      help=&quot;create an interlaced PNG file (Adam7)&quot;)</span>
<a href="#l16.3661"></a><span id="l16.3661" class="difflineplus">+    parser.add_option(&quot;-t&quot;, &quot;--transparent&quot;,</span>
<a href="#l16.3662"></a><span id="l16.3662" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;string&quot;, metavar=&quot;color&quot;,</span>
<a href="#l16.3663"></a><span id="l16.3663" class="difflineplus">+                      help=&quot;mark the specified colour (#RRGGBB) as transparent&quot;)</span>
<a href="#l16.3664"></a><span id="l16.3664" class="difflineplus">+    parser.add_option(&quot;-b&quot;, &quot;--background&quot;,</span>
<a href="#l16.3665"></a><span id="l16.3665" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;string&quot;, metavar=&quot;color&quot;,</span>
<a href="#l16.3666"></a><span id="l16.3666" class="difflineplus">+                      help=&quot;save the specified background colour&quot;)</span>
<a href="#l16.3667"></a><span id="l16.3667" class="difflineplus">+    parser.add_option(&quot;-a&quot;, &quot;--alpha&quot;,</span>
<a href="#l16.3668"></a><span id="l16.3668" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;string&quot;, metavar=&quot;pgmfile&quot;,</span>
<a href="#l16.3669"></a><span id="l16.3669" class="difflineplus">+                      help=&quot;alpha channel transparency (RGBA)&quot;)</span>
<a href="#l16.3670"></a><span id="l16.3670" class="difflineplus">+    parser.add_option(&quot;-g&quot;, &quot;--gamma&quot;,</span>
<a href="#l16.3671"></a><span id="l16.3671" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;float&quot;, metavar=&quot;value&quot;,</span>
<a href="#l16.3672"></a><span id="l16.3672" class="difflineplus">+                      help=&quot;save the specified gamma value&quot;)</span>
<a href="#l16.3673"></a><span id="l16.3673" class="difflineplus">+    parser.add_option(&quot;-c&quot;, &quot;--compression&quot;,</span>
<a href="#l16.3674"></a><span id="l16.3674" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;int&quot;, metavar=&quot;level&quot;,</span>
<a href="#l16.3675"></a><span id="l16.3675" class="difflineplus">+                      help=&quot;zlib compression level (0-9)&quot;)</span>
<a href="#l16.3676"></a><span id="l16.3676" class="difflineplus">+    parser.add_option(&quot;-T&quot;, &quot;--test&quot;,</span>
<a href="#l16.3677"></a><span id="l16.3677" class="difflineplus">+                      default=False, action=&quot;store_true&quot;,</span>
<a href="#l16.3678"></a><span id="l16.3678" class="difflineplus">+                      help=&quot;create a test image (a named PngSuite image if an argument is supplied)&quot;)</span>
<a href="#l16.3679"></a><span id="l16.3679" class="difflineplus">+    parser.add_option('-L', '--list',</span>
<a href="#l16.3680"></a><span id="l16.3680" class="difflineplus">+                      default=False, action='store_true',</span>
<a href="#l16.3681"></a><span id="l16.3681" class="difflineplus">+                      help=&quot;print list of named test images&quot;)</span>
<a href="#l16.3682"></a><span id="l16.3682" class="difflineplus">+    parser.add_option(&quot;-R&quot;, &quot;--test-red&quot;,</span>
<a href="#l16.3683"></a><span id="l16.3683" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;string&quot;, metavar=&quot;pattern&quot;,</span>
<a href="#l16.3684"></a><span id="l16.3684" class="difflineplus">+                      help=&quot;test pattern for the red image layer&quot;)</span>
<a href="#l16.3685"></a><span id="l16.3685" class="difflineplus">+    parser.add_option(&quot;-G&quot;, &quot;--test-green&quot;,</span>
<a href="#l16.3686"></a><span id="l16.3686" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;string&quot;, metavar=&quot;pattern&quot;,</span>
<a href="#l16.3687"></a><span id="l16.3687" class="difflineplus">+                      help=&quot;test pattern for the green image layer&quot;)</span>
<a href="#l16.3688"></a><span id="l16.3688" class="difflineplus">+    parser.add_option(&quot;-B&quot;, &quot;--test-blue&quot;,</span>
<a href="#l16.3689"></a><span id="l16.3689" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;string&quot;, metavar=&quot;pattern&quot;,</span>
<a href="#l16.3690"></a><span id="l16.3690" class="difflineplus">+                      help=&quot;test pattern for the blue image layer&quot;)</span>
<a href="#l16.3691"></a><span id="l16.3691" class="difflineplus">+    parser.add_option(&quot;-A&quot;, &quot;--test-alpha&quot;,</span>
<a href="#l16.3692"></a><span id="l16.3692" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;string&quot;, metavar=&quot;pattern&quot;,</span>
<a href="#l16.3693"></a><span id="l16.3693" class="difflineplus">+                      help=&quot;test pattern for the alpha image layer&quot;)</span>
<a href="#l16.3694"></a><span id="l16.3694" class="difflineplus">+    parser.add_option(&quot;-K&quot;, &quot;--test-black&quot;,</span>
<a href="#l16.3695"></a><span id="l16.3695" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;string&quot;, metavar=&quot;pattern&quot;,</span>
<a href="#l16.3696"></a><span id="l16.3696" class="difflineplus">+                      help=&quot;test pattern for greyscale image&quot;)</span>
<a href="#l16.3697"></a><span id="l16.3697" class="difflineplus">+    parser.add_option(&quot;-d&quot;, &quot;--test-depth&quot;,</span>
<a href="#l16.3698"></a><span id="l16.3698" class="difflineplus">+                      default=8, action=&quot;store&quot;, type=&quot;int&quot;,</span>
<a href="#l16.3699"></a><span id="l16.3699" class="difflineplus">+                      metavar='NBITS',</span>
<a href="#l16.3700"></a><span id="l16.3700" class="difflineplus">+                      help=&quot;create test PNGs that are NBITS bits per channel&quot;)</span>
<a href="#l16.3701"></a><span id="l16.3701" class="difflineplus">+    parser.add_option(&quot;-S&quot;, &quot;--test-size&quot;,</span>
<a href="#l16.3702"></a><span id="l16.3702" class="difflineplus">+                      action=&quot;store&quot;, type=&quot;int&quot;, metavar=&quot;size&quot;,</span>
<a href="#l16.3703"></a><span id="l16.3703" class="difflineplus">+                      help=&quot;width and height of the test image&quot;)</span>
<a href="#l16.3704"></a><span id="l16.3704" class="difflineplus">+    (options, args) = parser.parse_args(args=argv[1:])</span>
<a href="#l16.3705"></a><span id="l16.3705" class="difflineplus">+</span>
<a href="#l16.3706"></a><span id="l16.3706" class="difflineplus">+    # Convert options</span>
<a href="#l16.3707"></a><span id="l16.3707" class="difflineplus">+    if options.transparent is not None:</span>
<a href="#l16.3708"></a><span id="l16.3708" class="difflineplus">+        options.transparent = color_triple(options.transparent)</span>
<a href="#l16.3709"></a><span id="l16.3709" class="difflineplus">+    if options.background is not None:</span>
<a href="#l16.3710"></a><span id="l16.3710" class="difflineplus">+        options.background = color_triple(options.background)</span>
<a href="#l16.3711"></a><span id="l16.3711" class="difflineplus">+</span>
<a href="#l16.3712"></a><span id="l16.3712" class="difflineplus">+    if options.list:</span>
<a href="#l16.3713"></a><span id="l16.3713" class="difflineplus">+        names = list(_pngsuite)</span>
<a href="#l16.3714"></a><span id="l16.3714" class="difflineplus">+        names.sort()</span>
<a href="#l16.3715"></a><span id="l16.3715" class="difflineplus">+        for name in names:</span>
<a href="#l16.3716"></a><span id="l16.3716" class="difflineplus">+            print name</span>
<a href="#l16.3717"></a><span id="l16.3717" class="difflineplus">+        return</span>
<a href="#l16.3718"></a><span id="l16.3718" class="difflineplus">+</span>
<a href="#l16.3719"></a><span id="l16.3719" class="difflineplus">+    # Run regression tests</span>
<a href="#l16.3720"></a><span id="l16.3720" class="difflineplus">+    if options.test:</span>
<a href="#l16.3721"></a><span id="l16.3721" class="difflineplus">+        return test_suite(options, args)</span>
<a href="#l16.3722"></a><span id="l16.3722" class="difflineplus">+</span>
<a href="#l16.3723"></a><span id="l16.3723" class="difflineplus">+    # Prepare input and output files</span>
<a href="#l16.3724"></a><span id="l16.3724" class="difflineplus">+    if len(args) == 0:</span>
<a href="#l16.3725"></a><span id="l16.3725" class="difflineplus">+        infilename = '-'</span>
<a href="#l16.3726"></a><span id="l16.3726" class="difflineplus">+        infile = sys.stdin</span>
<a href="#l16.3727"></a><span id="l16.3727" class="difflineplus">+    elif len(args) == 1:</span>
<a href="#l16.3728"></a><span id="l16.3728" class="difflineplus">+        infilename = args[0]</span>
<a href="#l16.3729"></a><span id="l16.3729" class="difflineplus">+        infile = open(infilename, 'rb')</span>
<a href="#l16.3730"></a><span id="l16.3730" class="difflineplus">+    else:</span>
<a href="#l16.3731"></a><span id="l16.3731" class="difflineplus">+        parser.error(&quot;more than one input file&quot;)</span>
<a href="#l16.3732"></a><span id="l16.3732" class="difflineplus">+    outfile = sys.stdout</span>
<a href="#l16.3733"></a><span id="l16.3733" class="difflineplus">+</span>
<a href="#l16.3734"></a><span id="l16.3734" class="difflineplus">+    if options.read_png:</span>
<a href="#l16.3735"></a><span id="l16.3735" class="difflineplus">+        # Encode PNG to PPM</span>
<a href="#l16.3736"></a><span id="l16.3736" class="difflineplus">+        png = Reader(file=infile)</span>
<a href="#l16.3737"></a><span id="l16.3737" class="difflineplus">+        width,height,pixels,meta = png.asDirect()</span>
<a href="#l16.3738"></a><span id="l16.3738" class="difflineplus">+        write_pnm(outfile, width, height, pixels, meta) </span>
<a href="#l16.3739"></a><span id="l16.3739" class="difflineplus">+    else:</span>
<a href="#l16.3740"></a><span id="l16.3740" class="difflineplus">+        # Encode PNM to PNG</span>
<a href="#l16.3741"></a><span id="l16.3741" class="difflineplus">+        format, width, height, depth, maxval = \</span>
<a href="#l16.3742"></a><span id="l16.3742" class="difflineplus">+          read_pnm_header(infile, ('P5','P6','P7'))</span>
<a href="#l16.3743"></a><span id="l16.3743" class="difflineplus">+        # When it comes to the variety of input formats, we do something</span>
<a href="#l16.3744"></a><span id="l16.3744" class="difflineplus">+        # rather rude.  Observe that L, LA, RGB, RGBA are the 4 colour</span>
<a href="#l16.3745"></a><span id="l16.3745" class="difflineplus">+        # types supported by PNG and that they correspond to 1, 2, 3, 4</span>
<a href="#l16.3746"></a><span id="l16.3746" class="difflineplus">+        # channels respectively.  So we use the number of channels in</span>
<a href="#l16.3747"></a><span id="l16.3747" class="difflineplus">+        # the source image to determine which one we have.  We do not</span>
<a href="#l16.3748"></a><span id="l16.3748" class="difflineplus">+        # care about TUPLTYPE.</span>
<a href="#l16.3749"></a><span id="l16.3749" class="difflineplus">+        greyscale = depth &lt;= 2</span>
<a href="#l16.3750"></a><span id="l16.3750" class="difflineplus">+        pamalpha = depth in (2,4)</span>
<a href="#l16.3751"></a><span id="l16.3751" class="difflineplus">+        supported = map(lambda x: 2**x-1, range(1,17))</span>
<a href="#l16.3752"></a><span id="l16.3752" class="difflineplus">+        try:</span>
<a href="#l16.3753"></a><span id="l16.3753" class="difflineplus">+            mi = supported.index(maxval)</span>
<a href="#l16.3754"></a><span id="l16.3754" class="difflineplus">+        except ValueError:</span>
<a href="#l16.3755"></a><span id="l16.3755" class="difflineplus">+            raise NotImplementedError(</span>
<a href="#l16.3756"></a><span id="l16.3756" class="difflineplus">+              'your maxval (%s) not in supported list %s' %</span>
<a href="#l16.3757"></a><span id="l16.3757" class="difflineplus">+              (maxval, str(supported)))</span>
<a href="#l16.3758"></a><span id="l16.3758" class="difflineplus">+        bitdepth = mi+1</span>
<a href="#l16.3759"></a><span id="l16.3759" class="difflineplus">+        writer = Writer(width, height,</span>
<a href="#l16.3760"></a><span id="l16.3760" class="difflineplus">+                        greyscale=greyscale,</span>
<a href="#l16.3761"></a><span id="l16.3761" class="difflineplus">+                        bitdepth=bitdepth,</span>
<a href="#l16.3762"></a><span id="l16.3762" class="difflineplus">+                        interlace=options.interlace,</span>
<a href="#l16.3763"></a><span id="l16.3763" class="difflineplus">+                        transparent=options.transparent,</span>
<a href="#l16.3764"></a><span id="l16.3764" class="difflineplus">+                        background=options.background,</span>
<a href="#l16.3765"></a><span id="l16.3765" class="difflineplus">+                        alpha=bool(pamalpha or options.alpha),</span>
<a href="#l16.3766"></a><span id="l16.3766" class="difflineplus">+                        gamma=options.gamma,</span>
<a href="#l16.3767"></a><span id="l16.3767" class="difflineplus">+                        compression=options.compression)</span>
<a href="#l16.3768"></a><span id="l16.3768" class="difflineplus">+        if options.alpha:</span>
<a href="#l16.3769"></a><span id="l16.3769" class="difflineplus">+            pgmfile = open(options.alpha, 'rb')</span>
<a href="#l16.3770"></a><span id="l16.3770" class="difflineplus">+            format, awidth, aheight, adepth, amaxval = \</span>
<a href="#l16.3771"></a><span id="l16.3771" class="difflineplus">+              read_pnm_header(pgmfile, 'P5')</span>
<a href="#l16.3772"></a><span id="l16.3772" class="difflineplus">+            if amaxval != '255':</span>
<a href="#l16.3773"></a><span id="l16.3773" class="difflineplus">+                raise NotImplementedError(</span>
<a href="#l16.3774"></a><span id="l16.3774" class="difflineplus">+                  'maxval %s not supported for alpha channel' % amaxval)</span>
<a href="#l16.3775"></a><span id="l16.3775" class="difflineplus">+            if (awidth, aheight) != (width, height):</span>
<a href="#l16.3776"></a><span id="l16.3776" class="difflineplus">+                raise ValueError(&quot;alpha channel image size mismatch&quot;</span>
<a href="#l16.3777"></a><span id="l16.3777" class="difflineplus">+                                 &quot; (%s has %sx%s but %s has %sx%s)&quot;</span>
<a href="#l16.3778"></a><span id="l16.3778" class="difflineplus">+                                 % (infilename, width, height,</span>
<a href="#l16.3779"></a><span id="l16.3779" class="difflineplus">+                                    options.alpha, awidth, aheight))</span>
<a href="#l16.3780"></a><span id="l16.3780" class="difflineplus">+            writer.convert_ppm_and_pgm(infile, pgmfile, outfile)</span>
<a href="#l16.3781"></a><span id="l16.3781" class="difflineplus">+        else:</span>
<a href="#l16.3782"></a><span id="l16.3782" class="difflineplus">+            writer.convert_pnm(infile, outfile)</span>
<a href="#l16.3783"></a><span id="l16.3783" class="difflineplus">+</span>
<a href="#l16.3784"></a><span id="l16.3784" class="difflineplus">+</span>
<a href="#l16.3785"></a><span id="l16.3785" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l16.3786"></a><span id="l16.3786" class="difflineplus">+    try:</span>
<a href="#l16.3787"></a><span id="l16.3787" class="difflineplus">+        _main(sys.argv)</span>
<a href="#l16.3788"></a><span id="l16.3788" class="difflineplus">+    except Error, e:</span>
<a href="#l16.3789"></a><span id="l16.3789" class="difflineplus">+        print &gt;&gt;sys.stderr, e</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1">new file mode 100644</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineminus">--- /dev/null</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineplus">+++ b/build/pypng/pngchunk</span>
<a href="#l17.4"></a><span id="l17.4" class="difflineat">@@ -0,0 +1,172 @@</span>
<a href="#l17.5"></a><span id="l17.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l17.6"></a><span id="l17.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pngchunk $</span>
<a href="#l17.7"></a><span id="l17.7" class="difflineplus">+# $Rev: 156 $</span>
<a href="#l17.8"></a><span id="l17.8" class="difflineplus">+# pngchunk</span>
<a href="#l17.9"></a><span id="l17.9" class="difflineplus">+# Chunk editing/extraction tool.</span>
<a href="#l17.10"></a><span id="l17.10" class="difflineplus">+</span>
<a href="#l17.11"></a><span id="l17.11" class="difflineplus">+import struct</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineplus">+import warnings</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineplus">+# Local module.</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineplus">+import png</span>
<a href="#l17.16"></a><span id="l17.16" class="difflineplus">+</span>
<a href="#l17.17"></a><span id="l17.17" class="difflineplus">+&quot;&quot;&quot;</span>
<a href="#l17.18"></a><span id="l17.18" class="difflineplus">+pngchunk [--gamma g] [--iccprofile file] [--sigbit b] [-c cHNK!] [-c cHNK:foo] [-c cHNK&lt;file]</span>
<a href="#l17.19"></a><span id="l17.19" class="difflineplus">+</span>
<a href="#l17.20"></a><span id="l17.20" class="difflineplus">+The ``-c`` option is used to add or remove chunks.  A chunk is specified</span>
<a href="#l17.21"></a><span id="l17.21" class="difflineplus">+by its 4 byte chunk type.  If this is followed by a ``!`` then that</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineplus">+chunk is removed from the PNG file.  If the chunk type is followed by a</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineplus">+``:`` then the chunk is replaced with the contents of the rest of the</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineplus">+argument (this is probably only useful if the content is mostly ASCII,</span>
<a href="#l17.25"></a><span id="l17.25" class="difflineplus">+otherwise it's a pain to quote the contents, otherwise see...).  A ``&lt;``</span>
<a href="#l17.26"></a><span id="l17.26" class="difflineplus">+can be used to take the contents of the chunk from the named file.</span>
<a href="#l17.27"></a><span id="l17.27" class="difflineplus">+&quot;&quot;&quot;</span>
<a href="#l17.28"></a><span id="l17.28" class="difflineplus">+</span>
<a href="#l17.29"></a><span id="l17.29" class="difflineplus">+</span>
<a href="#l17.30"></a><span id="l17.30" class="difflineplus">+def chunk(out, inp, l):</span>
<a href="#l17.31"></a><span id="l17.31" class="difflineplus">+    &quot;&quot;&quot;Process the input PNG file to the output, chunk by chunk.  Chunks</span>
<a href="#l17.32"></a><span id="l17.32" class="difflineplus">+    can be inserted, removed, replaced, or sometimes edited.  Generally, </span>
<a href="#l17.33"></a><span id="l17.33" class="difflineplus">+    chunks are not inspected, so pixel data (in the ``IDAT`` chunks)</span>
<a href="#l17.34"></a><span id="l17.34" class="difflineplus">+    cannot be modified.  `l` should be a list of (*chunktype*,</span>
<a href="#l17.35"></a><span id="l17.35" class="difflineplus">+    *content*) pairs.  *chunktype* is usually the type of the PNG chunk,</span>
<a href="#l17.36"></a><span id="l17.36" class="difflineplus">+    specified as a 4-byte Python string, and *content* is the chunk's</span>
<a href="#l17.37"></a><span id="l17.37" class="difflineplus">+    content, also as a string; if *content* is ``None`` then *all*</span>
<a href="#l17.38"></a><span id="l17.38" class="difflineplus">+    chunks of that type will be removed.</span>
<a href="#l17.39"></a><span id="l17.39" class="difflineplus">+</span>
<a href="#l17.40"></a><span id="l17.40" class="difflineplus">+    This function *knows* about certain chunk types and will</span>
<a href="#l17.41"></a><span id="l17.41" class="difflineplus">+    automatically convert from Python friendly representations to</span>
<a href="#l17.42"></a><span id="l17.42" class="difflineplus">+    string-of-bytes.</span>
<a href="#l17.43"></a><span id="l17.43" class="difflineplus">+</span>
<a href="#l17.44"></a><span id="l17.44" class="difflineplus">+    chunktype</span>
<a href="#l17.45"></a><span id="l17.45" class="difflineplus">+    'gamma'     'gAMA'  float</span>
<a href="#l17.46"></a><span id="l17.46" class="difflineplus">+    'sigbit'    'sBIT'  int, or tuple of length 1,2 or 3</span>
<a href="#l17.47"></a><span id="l17.47" class="difflineplus">+</span>
<a href="#l17.48"></a><span id="l17.48" class="difflineplus">+    Note that the length of the strings used to identify *friendly*</span>
<a href="#l17.49"></a><span id="l17.49" class="difflineplus">+    chunk types is greater than 4, hence they cannot be confused with</span>
<a href="#l17.50"></a><span id="l17.50" class="difflineplus">+    canonical chunk types.</span>
<a href="#l17.51"></a><span id="l17.51" class="difflineplus">+</span>
<a href="#l17.52"></a><span id="l17.52" class="difflineplus">+    Chunk types, if specified using the 4-byte syntax, need not be</span>
<a href="#l17.53"></a><span id="l17.53" class="difflineplus">+    official PNG chunks at all.  Non-standard chunks can be created.</span>
<a href="#l17.54"></a><span id="l17.54" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l17.55"></a><span id="l17.55" class="difflineplus">+</span>
<a href="#l17.56"></a><span id="l17.56" class="difflineplus">+    def canonical(p):</span>
<a href="#l17.57"></a><span id="l17.57" class="difflineplus">+        &quot;&quot;&quot;Take a pair (*chunktype*, *content*), and return canonical</span>
<a href="#l17.58"></a><span id="l17.58" class="difflineplus">+        representation (*chunktype*, *content*) where `chunktype` is the</span>
<a href="#l17.59"></a><span id="l17.59" class="difflineplus">+        4-byte PNG chunk type and `content` is a string.</span>
<a href="#l17.60"></a><span id="l17.60" class="difflineplus">+        &quot;&quot;&quot;</span>
<a href="#l17.61"></a><span id="l17.61" class="difflineplus">+</span>
<a href="#l17.62"></a><span id="l17.62" class="difflineplus">+        t,v = p</span>
<a href="#l17.63"></a><span id="l17.63" class="difflineplus">+        if len(t) == 4:</span>
<a href="#l17.64"></a><span id="l17.64" class="difflineplus">+            return t,v</span>
<a href="#l17.65"></a><span id="l17.65" class="difflineplus">+        if t == 'gamma':</span>
<a href="#l17.66"></a><span id="l17.66" class="difflineplus">+            t = 'gAMA'</span>
<a href="#l17.67"></a><span id="l17.67" class="difflineplus">+            v = int(round(1e5*v))</span>
<a href="#l17.68"></a><span id="l17.68" class="difflineplus">+            v = struct.pack('&gt;I', v)</span>
<a href="#l17.69"></a><span id="l17.69" class="difflineplus">+        elif t == 'sigbit':</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineplus">+            t = 'sBIT'</span>
<a href="#l17.71"></a><span id="l17.71" class="difflineplus">+            try:</span>
<a href="#l17.72"></a><span id="l17.72" class="difflineplus">+                v[0]</span>
<a href="#l17.73"></a><span id="l17.73" class="difflineplus">+            except TypeError:</span>
<a href="#l17.74"></a><span id="l17.74" class="difflineplus">+                v = (v,)</span>
<a href="#l17.75"></a><span id="l17.75" class="difflineplus">+            v = struct.pack('%dB' % len(v), *v)</span>
<a href="#l17.76"></a><span id="l17.76" class="difflineplus">+        elif t == 'iccprofile':</span>
<a href="#l17.77"></a><span id="l17.77" class="difflineplus">+            t = 'iCCP'</span>
<a href="#l17.78"></a><span id="l17.78" class="difflineplus">+            # http://www.w3.org/TR/PNG/#11iCCP</span>
<a href="#l17.79"></a><span id="l17.79" class="difflineplus">+            v = 'a color profile\x00\x00' + v.encode('zip')</span>
<a href="#l17.80"></a><span id="l17.80" class="difflineplus">+        else:</span>
<a href="#l17.81"></a><span id="l17.81" class="difflineplus">+            warnings.warn('Unknown chunk type %r' % t)</span>
<a href="#l17.82"></a><span id="l17.82" class="difflineplus">+        return t[:4],v</span>
<a href="#l17.83"></a><span id="l17.83" class="difflineplus">+</span>
<a href="#l17.84"></a><span id="l17.84" class="difflineplus">+    l = map(canonical, l)</span>
<a href="#l17.85"></a><span id="l17.85" class="difflineplus">+    # Some chunks automagically replace ones that are present in the</span>
<a href="#l17.86"></a><span id="l17.86" class="difflineplus">+    # source PNG.  There can only be one of each of these chunk types.</span>
<a href="#l17.87"></a><span id="l17.87" class="difflineplus">+    # Create a 'replace' dictionary to record these chunks.</span>
<a href="#l17.88"></a><span id="l17.88" class="difflineplus">+    add = []</span>
<a href="#l17.89"></a><span id="l17.89" class="difflineplus">+    delete = set()</span>
<a href="#l17.90"></a><span id="l17.90" class="difflineplus">+    replacing = set(['gAMA', 'sBIT', 'PLTE', 'tRNS', 'sPLT', 'IHDR'])</span>
<a href="#l17.91"></a><span id="l17.91" class="difflineplus">+    replace = dict()</span>
<a href="#l17.92"></a><span id="l17.92" class="difflineplus">+    for t,v in l:</span>
<a href="#l17.93"></a><span id="l17.93" class="difflineplus">+        if v is None:</span>
<a href="#l17.94"></a><span id="l17.94" class="difflineplus">+            delete.add(t)</span>
<a href="#l17.95"></a><span id="l17.95" class="difflineplus">+        elif t in replacing:</span>
<a href="#l17.96"></a><span id="l17.96" class="difflineplus">+            replace[t] = v</span>
<a href="#l17.97"></a><span id="l17.97" class="difflineplus">+        else:</span>
<a href="#l17.98"></a><span id="l17.98" class="difflineplus">+            add.append((t,v))</span>
<a href="#l17.99"></a><span id="l17.99" class="difflineplus">+    del l</span>
<a href="#l17.100"></a><span id="l17.100" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l17.101"></a><span id="l17.101" class="difflineplus">+    chunks = r.chunks()</span>
<a href="#l17.102"></a><span id="l17.102" class="difflineplus">+    def iterchunks():</span>
<a href="#l17.103"></a><span id="l17.103" class="difflineplus">+        for t,v in chunks:</span>
<a href="#l17.104"></a><span id="l17.104" class="difflineplus">+            if t in delete:</span>
<a href="#l17.105"></a><span id="l17.105" class="difflineplus">+                continue</span>
<a href="#l17.106"></a><span id="l17.106" class="difflineplus">+            if t in replace:</span>
<a href="#l17.107"></a><span id="l17.107" class="difflineplus">+                yield t,replace[t]</span>
<a href="#l17.108"></a><span id="l17.108" class="difflineplus">+                del replace[t]</span>
<a href="#l17.109"></a><span id="l17.109" class="difflineplus">+                continue</span>
<a href="#l17.110"></a><span id="l17.110" class="difflineplus">+            if t == 'IDAT' and replace:</span>
<a href="#l17.111"></a><span id="l17.111" class="difflineplus">+                # Insert into the output any chunks that are on the</span>
<a href="#l17.112"></a><span id="l17.112" class="difflineplus">+                # replace list.  We haven't output them yet, because we</span>
<a href="#l17.113"></a><span id="l17.113" class="difflineplus">+                # didn't see an original chunk of the same type to</span>
<a href="#l17.114"></a><span id="l17.114" class="difflineplus">+                # replace.  Thus the &quot;replace&quot; is actually an &quot;insert&quot;.</span>
<a href="#l17.115"></a><span id="l17.115" class="difflineplus">+                for u,w in replace.items():</span>
<a href="#l17.116"></a><span id="l17.116" class="difflineplus">+                    yield u,w</span>
<a href="#l17.117"></a><span id="l17.117" class="difflineplus">+                    del replace[u]</span>
<a href="#l17.118"></a><span id="l17.118" class="difflineplus">+            if t == 'IDAT' and add:</span>
<a href="#l17.119"></a><span id="l17.119" class="difflineplus">+                for item in add:</span>
<a href="#l17.120"></a><span id="l17.120" class="difflineplus">+                    yield item</span>
<a href="#l17.121"></a><span id="l17.121" class="difflineplus">+                del add[:]</span>
<a href="#l17.122"></a><span id="l17.122" class="difflineplus">+            yield t,v</span>
<a href="#l17.123"></a><span id="l17.123" class="difflineplus">+    return png.write_chunks(out, iterchunks())</span>
<a href="#l17.124"></a><span id="l17.124" class="difflineplus">+</span>
<a href="#l17.125"></a><span id="l17.125" class="difflineplus">+class Usage(Exception):</span>
<a href="#l17.126"></a><span id="l17.126" class="difflineplus">+    pass</span>
<a href="#l17.127"></a><span id="l17.127" class="difflineplus">+</span>
<a href="#l17.128"></a><span id="l17.128" class="difflineplus">+def main(argv=None):</span>
<a href="#l17.129"></a><span id="l17.129" class="difflineplus">+    import getopt</span>
<a href="#l17.130"></a><span id="l17.130" class="difflineplus">+    import re</span>
<a href="#l17.131"></a><span id="l17.131" class="difflineplus">+    import sys</span>
<a href="#l17.132"></a><span id="l17.132" class="difflineplus">+</span>
<a href="#l17.133"></a><span id="l17.133" class="difflineplus">+    if argv is None:</span>
<a href="#l17.134"></a><span id="l17.134" class="difflineplus">+        argv = sys.argv</span>
<a href="#l17.135"></a><span id="l17.135" class="difflineplus">+</span>
<a href="#l17.136"></a><span id="l17.136" class="difflineplus">+    argv = argv[1:]</span>
<a href="#l17.137"></a><span id="l17.137" class="difflineplus">+</span>
<a href="#l17.138"></a><span id="l17.138" class="difflineplus">+    try:</span>
<a href="#l17.139"></a><span id="l17.139" class="difflineplus">+        try:</span>
<a href="#l17.140"></a><span id="l17.140" class="difflineplus">+            opt,arg = getopt.getopt(argv, 'c:',</span>
<a href="#l17.141"></a><span id="l17.141" class="difflineplus">+                                    ['gamma=', 'iccprofile=', 'sigbit='])</span>
<a href="#l17.142"></a><span id="l17.142" class="difflineplus">+        except getopt.error, msg:</span>
<a href="#l17.143"></a><span id="l17.143" class="difflineplus">+            raise Usage(msg)</span>
<a href="#l17.144"></a><span id="l17.144" class="difflineplus">+        k = []</span>
<a href="#l17.145"></a><span id="l17.145" class="difflineplus">+        for o,v in opt:</span>
<a href="#l17.146"></a><span id="l17.146" class="difflineplus">+            if o in ['--gamma']:</span>
<a href="#l17.147"></a><span id="l17.147" class="difflineplus">+                k.append(('gamma', float(v)))</span>
<a href="#l17.148"></a><span id="l17.148" class="difflineplus">+            if o in ['--sigbit']:</span>
<a href="#l17.149"></a><span id="l17.149" class="difflineplus">+                k.append(('sigbit', int(v)))</span>
<a href="#l17.150"></a><span id="l17.150" class="difflineplus">+            if o in ['--iccprofile']:</span>
<a href="#l17.151"></a><span id="l17.151" class="difflineplus">+                k.append(('iccprofile', open(v, 'rb').read()))</span>
<a href="#l17.152"></a><span id="l17.152" class="difflineplus">+            if o in ['-c']:</span>
<a href="#l17.153"></a><span id="l17.153" class="difflineplus">+                type = v[:4]</span>
<a href="#l17.154"></a><span id="l17.154" class="difflineplus">+                if not re.match('[a-zA-Z]{4}', type):</span>
<a href="#l17.155"></a><span id="l17.155" class="difflineplus">+                    raise Usage('Chunk type must consist of 4 letters.')</span>
<a href="#l17.156"></a><span id="l17.156" class="difflineplus">+                if v[4] == '!':</span>
<a href="#l17.157"></a><span id="l17.157" class="difflineplus">+                    k.append((type, None))</span>
<a href="#l17.158"></a><span id="l17.158" class="difflineplus">+                if v[4] == ':':</span>
<a href="#l17.159"></a><span id="l17.159" class="difflineplus">+                    k.append((type, v[5:]))</span>
<a href="#l17.160"></a><span id="l17.160" class="difflineplus">+                if v[4] == '&lt;':</span>
<a href="#l17.161"></a><span id="l17.161" class="difflineplus">+                    k.append((type, open(v[5:], 'rb').read()))</span>
<a href="#l17.162"></a><span id="l17.162" class="difflineplus">+    except Usage, err:</span>
<a href="#l17.163"></a><span id="l17.163" class="difflineplus">+        print &gt;&gt;sys.stderr, (</span>
<a href="#l17.164"></a><span id="l17.164" class="difflineplus">+          &quot;usage: pngchunk [--gamma d.dd] [--sigbit b] [-c cHNK! | -c cHNK:text-string]&quot;)</span>
<a href="#l17.165"></a><span id="l17.165" class="difflineplus">+        print &gt;&gt;sys.stderr, err.message</span>
<a href="#l17.166"></a><span id="l17.166" class="difflineplus">+        return 2</span>
<a href="#l17.167"></a><span id="l17.167" class="difflineplus">+</span>
<a href="#l17.168"></a><span id="l17.168" class="difflineplus">+    if len(arg) &gt; 0:</span>
<a href="#l17.169"></a><span id="l17.169" class="difflineplus">+        f = open(arg[0], 'rb')</span>
<a href="#l17.170"></a><span id="l17.170" class="difflineplus">+    else:</span>
<a href="#l17.171"></a><span id="l17.171" class="difflineplus">+        f = sys.stdin</span>
<a href="#l17.172"></a><span id="l17.172" class="difflineplus">+    return chunk(sys.stdout, f, k)</span>
<a href="#l17.173"></a><span id="l17.173" class="difflineplus">+</span>
<a href="#l17.174"></a><span id="l17.174" class="difflineplus">+</span>
<a href="#l17.175"></a><span id="l17.175" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l17.176"></a><span id="l17.176" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1">new file mode 100644</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineminus">--- /dev/null</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineplus">+++ b/build/pypng/pnghist</span>
<a href="#l18.4"></a><span id="l18.4" class="difflineat">@@ -0,0 +1,79 @@</span>
<a href="#l18.5"></a><span id="l18.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l18.6"></a><span id="l18.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pnghist $</span>
<a href="#l18.7"></a><span id="l18.7" class="difflineplus">+# $Rev: 153 $</span>
<a href="#l18.8"></a><span id="l18.8" class="difflineplus">+# PNG Histogram</span>
<a href="#l18.9"></a><span id="l18.9" class="difflineplus">+# Only really works on grayscale images.</span>
<a href="#l18.10"></a><span id="l18.10" class="difflineplus">+</span>
<a href="#l18.11"></a><span id="l18.11" class="difflineplus">+from array import array</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineplus">+import getopt</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+</span>
<a href="#l18.14"></a><span id="l18.14" class="difflineplus">+import png</span>
<a href="#l18.15"></a><span id="l18.15" class="difflineplus">+</span>
<a href="#l18.16"></a><span id="l18.16" class="difflineplus">+def decidemax(level):</span>
<a href="#l18.17"></a><span id="l18.17" class="difflineplus">+    &quot;&quot;&quot;Given an array of levels, decide the maximum value to use for the</span>
<a href="#l18.18"></a><span id="l18.18" class="difflineplus">+    histogram.  This is normally chosen to be a bit bigger than the 99th</span>
<a href="#l18.19"></a><span id="l18.19" class="difflineplus">+    percentile, but if the 100th percentile is not much more (within a</span>
<a href="#l18.20"></a><span id="l18.20" class="difflineplus">+    factor of 2) then the 100th percentile is chosen.</span>
<a href="#l18.21"></a><span id="l18.21" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l18.22"></a><span id="l18.22" class="difflineplus">+</span>
<a href="#l18.23"></a><span id="l18.23" class="difflineplus">+    truemax = max(level)</span>
<a href="#l18.24"></a><span id="l18.24" class="difflineplus">+    sl = level[:]</span>
<a href="#l18.25"></a><span id="l18.25" class="difflineplus">+    sl.sort(reverse=True)</span>
<a href="#l18.26"></a><span id="l18.26" class="difflineplus">+    i99 = int(round(len(level)*0.01))</span>
<a href="#l18.27"></a><span id="l18.27" class="difflineplus">+    if truemax &lt;= 2*sl[i99]:</span>
<a href="#l18.28"></a><span id="l18.28" class="difflineplus">+        return truemax</span>
<a href="#l18.29"></a><span id="l18.29" class="difflineplus">+    return 1.05*sl[i99]</span>
<a href="#l18.30"></a><span id="l18.30" class="difflineplus">+</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineplus">+def hist(out, inp, verbose=None):</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+    &quot;&quot;&quot;Open the PNG file `inp` and generate a histogram.&quot;&quot;&quot;</span>
<a href="#l18.33"></a><span id="l18.33" class="difflineplus">+</span>
<a href="#l18.34"></a><span id="l18.34" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l18.35"></a><span id="l18.35" class="difflineplus">+    x,y,pixels,info = r.asDirect()</span>
<a href="#l18.36"></a><span id="l18.36" class="difflineplus">+    bitdepth = info['bitdepth']</span>
<a href="#l18.37"></a><span id="l18.37" class="difflineplus">+    level = [0]*2**bitdepth</span>
<a href="#l18.38"></a><span id="l18.38" class="difflineplus">+    for row in pixels:</span>
<a href="#l18.39"></a><span id="l18.39" class="difflineplus">+        for v in row:</span>
<a href="#l18.40"></a><span id="l18.40" class="difflineplus">+            level[v] += 1</span>
<a href="#l18.41"></a><span id="l18.41" class="difflineplus">+    maxlevel = decidemax(level)</span>
<a href="#l18.42"></a><span id="l18.42" class="difflineplus">+</span>
<a href="#l18.43"></a><span id="l18.43" class="difflineplus">+    h = 100</span>
<a href="#l18.44"></a><span id="l18.44" class="difflineplus">+    outbitdepth = 8</span>
<a href="#l18.45"></a><span id="l18.45" class="difflineplus">+    outmaxval = 2**outbitdepth - 1</span>
<a href="#l18.46"></a><span id="l18.46" class="difflineplus">+    def genrow():</span>
<a href="#l18.47"></a><span id="l18.47" class="difflineplus">+        for y in range(h):</span>
<a href="#l18.48"></a><span id="l18.48" class="difflineplus">+            y = h-y-1</span>
<a href="#l18.49"></a><span id="l18.49" class="difflineplus">+            # :todo: vary typecode according to outbitdepth</span>
<a href="#l18.50"></a><span id="l18.50" class="difflineplus">+            row = array('B', [0]*len(level))</span>
<a href="#l18.51"></a><span id="l18.51" class="difflineplus">+            fl = y*maxlevel/float(h)</span>
<a href="#l18.52"></a><span id="l18.52" class="difflineplus">+            ce = (y+1)*maxlevel/float(h)</span>
<a href="#l18.53"></a><span id="l18.53" class="difflineplus">+            for x in range(len(row)):</span>
<a href="#l18.54"></a><span id="l18.54" class="difflineplus">+                if level[x] &lt;= fl:</span>
<a href="#l18.55"></a><span id="l18.55" class="difflineplus">+                    # Relies on row being initialised to all 0</span>
<a href="#l18.56"></a><span id="l18.56" class="difflineplus">+                    continue</span>
<a href="#l18.57"></a><span id="l18.57" class="difflineplus">+                if level[x] &gt;= ce:</span>
<a href="#l18.58"></a><span id="l18.58" class="difflineplus">+                    row[x] = outmaxval</span>
<a href="#l18.59"></a><span id="l18.59" class="difflineplus">+                    continue</span>
<a href="#l18.60"></a><span id="l18.60" class="difflineplus">+                frac = (level[x] - fl)/(ce - fl)</span>
<a href="#l18.61"></a><span id="l18.61" class="difflineplus">+                row[x] = int(round(outmaxval*frac))</span>
<a href="#l18.62"></a><span id="l18.62" class="difflineplus">+            yield row</span>
<a href="#l18.63"></a><span id="l18.63" class="difflineplus">+    w = png.Writer(len(level), h, gamma=1.0,</span>
<a href="#l18.64"></a><span id="l18.64" class="difflineplus">+      greyscale=True, alpha=False, bitdepth=outbitdepth)</span>
<a href="#l18.65"></a><span id="l18.65" class="difflineplus">+    w.write(out, genrow())</span>
<a href="#l18.66"></a><span id="l18.66" class="difflineplus">+    if verbose: print &gt;&gt;verbose, level</span>
<a href="#l18.67"></a><span id="l18.67" class="difflineplus">+</span>
<a href="#l18.68"></a><span id="l18.68" class="difflineplus">+def main(argv=None):</span>
<a href="#l18.69"></a><span id="l18.69" class="difflineplus">+    import sys</span>
<a href="#l18.70"></a><span id="l18.70" class="difflineplus">+</span>
<a href="#l18.71"></a><span id="l18.71" class="difflineplus">+    if argv is None:</span>
<a href="#l18.72"></a><span id="l18.72" class="difflineplus">+        argv = sys.argv</span>
<a href="#l18.73"></a><span id="l18.73" class="difflineplus">+    argv = argv[1:]</span>
<a href="#l18.74"></a><span id="l18.74" class="difflineplus">+    opt,arg = getopt.getopt(argv, '')</span>
<a href="#l18.75"></a><span id="l18.75" class="difflineplus">+</span>
<a href="#l18.76"></a><span id="l18.76" class="difflineplus">+    if len(arg) &lt; 1:</span>
<a href="#l18.77"></a><span id="l18.77" class="difflineplus">+        f = sys.stdin</span>
<a href="#l18.78"></a><span id="l18.78" class="difflineplus">+    else:</span>
<a href="#l18.79"></a><span id="l18.79" class="difflineplus">+        f = open(arg[0])</span>
<a href="#l18.80"></a><span id="l18.80" class="difflineplus">+    hist(sys.stdout, f)</span>
<a href="#l18.81"></a><span id="l18.81" class="difflineplus">+</span>
<a href="#l18.82"></a><span id="l18.82" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l18.83"></a><span id="l18.83" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1">new file mode 100644</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineminus">--- /dev/null</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineplus">+++ b/build/pypng/pnglsch</span>
<a href="#l19.4"></a><span id="l19.4" class="difflineat">@@ -0,0 +1,31 @@</span>
<a href="#l19.5"></a><span id="l19.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l19.6"></a><span id="l19.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/pnglsch $</span>
<a href="#l19.7"></a><span id="l19.7" class="difflineplus">+# $Rev: 107 $</span>
<a href="#l19.8"></a><span id="l19.8" class="difflineplus">+# pnglsch</span>
<a href="#l19.9"></a><span id="l19.9" class="difflineplus">+# PNG List Chunks</span>
<a href="#l19.10"></a><span id="l19.10" class="difflineplus">+</span>
<a href="#l19.11"></a><span id="l19.11" class="difflineplus">+import png</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineplus">+</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+def list(out, inp):</span>
<a href="#l19.14"></a><span id="l19.14" class="difflineplus">+    r = png.Reader(file=inp)</span>
<a href="#l19.15"></a><span id="l19.15" class="difflineplus">+    for t,v in r.chunks():</span>
<a href="#l19.16"></a><span id="l19.16" class="difflineplus">+        add = ''</span>
<a href="#l19.17"></a><span id="l19.17" class="difflineplus">+        if len(v) &lt;= 28:</span>
<a href="#l19.18"></a><span id="l19.18" class="difflineplus">+            add = ' ' + v.encode('hex')</span>
<a href="#l19.19"></a><span id="l19.19" class="difflineplus">+        print &gt;&gt;out, &quot;%s %10d%s&quot; % (t, len(v), add)</span>
<a href="#l19.20"></a><span id="l19.20" class="difflineplus">+</span>
<a href="#l19.21"></a><span id="l19.21" class="difflineplus">+def main(argv=None):</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineplus">+    import sys</span>
<a href="#l19.23"></a><span id="l19.23" class="difflineplus">+</span>
<a href="#l19.24"></a><span id="l19.24" class="difflineplus">+    if argv is None:</span>
<a href="#l19.25"></a><span id="l19.25" class="difflineplus">+        argv = sys.argv</span>
<a href="#l19.26"></a><span id="l19.26" class="difflineplus">+    arg = argv[1:]</span>
<a href="#l19.27"></a><span id="l19.27" class="difflineplus">+</span>
<a href="#l19.28"></a><span id="l19.28" class="difflineplus">+    if len(arg) &gt; 0:</span>
<a href="#l19.29"></a><span id="l19.29" class="difflineplus">+        f = open(arg[0], 'rb')</span>
<a href="#l19.30"></a><span id="l19.30" class="difflineplus">+    else:</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineplus">+        f = sys.stdin</span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+    return list(sys.stdout, f)</span>
<a href="#l19.33"></a><span id="l19.33" class="difflineplus">+</span>
<a href="#l19.34"></a><span id="l19.34" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l19.35"></a><span id="l19.35" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1">new file mode 100644</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineminus">--- /dev/null</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineplus">+++ b/build/pypng/texttopng</span>
<a href="#l20.4"></a><span id="l20.4" class="difflineat">@@ -0,0 +1,151 @@</span>
<a href="#l20.5"></a><span id="l20.5" class="difflineplus">+#!/usr/bin/env python</span>
<a href="#l20.6"></a><span id="l20.6" class="difflineplus">+# $URL: http://pypng.googlecode.com/svn/trunk/code/texttopng $</span>
<a href="#l20.7"></a><span id="l20.7" class="difflineplus">+# $Rev: 132 $</span>
<a href="#l20.8"></a><span id="l20.8" class="difflineplus">+# Script to renders text as a PNG image.</span>
<a href="#l20.9"></a><span id="l20.9" class="difflineplus">+</span>
<a href="#l20.10"></a><span id="l20.10" class="difflineplus">+from array import array</span>
<a href="#l20.11"></a><span id="l20.11" class="difflineplus">+import itertools</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineplus">+</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+font = {</span>
<a href="#l20.14"></a><span id="l20.14" class="difflineplus">+  32: '0000000000000000',</span>
<a href="#l20.15"></a><span id="l20.15" class="difflineplus">+  33: '0010101010001000',</span>
<a href="#l20.16"></a><span id="l20.16" class="difflineplus">+  34: '0028280000000000',</span>
<a href="#l20.17"></a><span id="l20.17" class="difflineplus">+  35: '0000287c287c2800',</span>
<a href="#l20.18"></a><span id="l20.18" class="difflineplus">+  36: '00103c5038147810',</span>
<a href="#l20.19"></a><span id="l20.19" class="difflineplus">+  37: '0000644810244c00',</span>
<a href="#l20.20"></a><span id="l20.20" class="difflineplus">+  38: '0020502054483400',</span>
<a href="#l20.21"></a><span id="l20.21" class="difflineplus">+  39: '0010100000000000',</span>
<a href="#l20.22"></a><span id="l20.22" class="difflineplus">+  40: '0008101010101008',</span>
<a href="#l20.23"></a><span id="l20.23" class="difflineplus">+  41: '0020101010101020',</span>
<a href="#l20.24"></a><span id="l20.24" class="difflineplus">+  42: '0010543838541000',</span>
<a href="#l20.25"></a><span id="l20.25" class="difflineplus">+  43: '000010107c101000',</span>
<a href="#l20.26"></a><span id="l20.26" class="difflineplus">+  44: '0000000000301020',</span>
<a href="#l20.27"></a><span id="l20.27" class="difflineplus">+  45: '000000007c000000',</span>
<a href="#l20.28"></a><span id="l20.28" class="difflineplus">+  46: '0000000000303000',</span>
<a href="#l20.29"></a><span id="l20.29" class="difflineplus">+  47: '0000040810204000',</span>
<a href="#l20.30"></a><span id="l20.30" class="difflineplus">+  48: '0038445454443800',</span>
<a href="#l20.31"></a><span id="l20.31" class="difflineplus">+  49: '0008180808080800',</span>
<a href="#l20.32"></a><span id="l20.32" class="difflineplus">+  50: '0038043840407c00',</span>
<a href="#l20.33"></a><span id="l20.33" class="difflineplus">+  51: '003c041804043800',</span>
<a href="#l20.34"></a><span id="l20.34" class="difflineplus">+  52: '00081828487c0800',</span>
<a href="#l20.35"></a><span id="l20.35" class="difflineplus">+  53: '0078407804047800',</span>
<a href="#l20.36"></a><span id="l20.36" class="difflineplus">+  54: '0038407844443800',</span>
<a href="#l20.37"></a><span id="l20.37" class="difflineplus">+  55: '007c040810101000',</span>
<a href="#l20.38"></a><span id="l20.38" class="difflineplus">+  56: '0038443844443800',</span>
<a href="#l20.39"></a><span id="l20.39" class="difflineplus">+  57: '0038443c04040400',</span>
<a href="#l20.40"></a><span id="l20.40" class="difflineplus">+  58: '0000303000303000',</span>
<a href="#l20.41"></a><span id="l20.41" class="difflineplus">+  59: '0000303000301020',</span>
<a href="#l20.42"></a><span id="l20.42" class="difflineplus">+  60: '0004081020100804',</span>
<a href="#l20.43"></a><span id="l20.43" class="difflineplus">+  61: '0000007c007c0000',</span>
<a href="#l20.44"></a><span id="l20.44" class="difflineplus">+  62: '0040201008102040',</span>
<a href="#l20.45"></a><span id="l20.45" class="difflineplus">+  63: '0038440810001000',</span>
<a href="#l20.46"></a><span id="l20.46" class="difflineplus">+  64: '00384c545c403800',</span>
<a href="#l20.47"></a><span id="l20.47" class="difflineplus">+  65: '0038447c44444400',</span>
<a href="#l20.48"></a><span id="l20.48" class="difflineplus">+  66: '0078447844447800',</span>
<a href="#l20.49"></a><span id="l20.49" class="difflineplus">+  67: '0038444040443800',</span>
<a href="#l20.50"></a><span id="l20.50" class="difflineplus">+  68: '0070484444487000',</span>
<a href="#l20.51"></a><span id="l20.51" class="difflineplus">+  69: '007c407840407c00',</span>
<a href="#l20.52"></a><span id="l20.52" class="difflineplus">+  70: '007c407840404000',</span>
<a href="#l20.53"></a><span id="l20.53" class="difflineplus">+  71: '003844405c443c00',</span>
<a href="#l20.54"></a><span id="l20.54" class="difflineplus">+  72: '0044447c44444400',</span>
<a href="#l20.55"></a><span id="l20.55" class="difflineplus">+  73: '0038101010103800',</span>
<a href="#l20.56"></a><span id="l20.56" class="difflineplus">+  74: '003c040404443800',</span>
<a href="#l20.57"></a><span id="l20.57" class="difflineplus">+  75: '0044487048444400',</span>
<a href="#l20.58"></a><span id="l20.58" class="difflineplus">+  76: '0040404040407c00',</span>
<a href="#l20.59"></a><span id="l20.59" class="difflineplus">+  77: '006c545444444400',</span>
<a href="#l20.60"></a><span id="l20.60" class="difflineplus">+  78: '004464544c444400',</span>
<a href="#l20.61"></a><span id="l20.61" class="difflineplus">+  79: '0038444444443800',</span>
<a href="#l20.62"></a><span id="l20.62" class="difflineplus">+  80: '0078447840404000',</span>
<a href="#l20.63"></a><span id="l20.63" class="difflineplus">+  81: '0038444444443c02',</span>
<a href="#l20.64"></a><span id="l20.64" class="difflineplus">+  82: '0078447844444400',</span>
<a href="#l20.65"></a><span id="l20.65" class="difflineplus">+  83: '0038403804047800',</span>
<a href="#l20.66"></a><span id="l20.66" class="difflineplus">+  84: '007c101010101000',</span>
<a href="#l20.67"></a><span id="l20.67" class="difflineplus">+  85: '0044444444443c00',</span>
<a href="#l20.68"></a><span id="l20.68" class="difflineplus">+  86: '0044444444281000',</span>
<a href="#l20.69"></a><span id="l20.69" class="difflineplus">+  87: '0044445454543800',</span>
<a href="#l20.70"></a><span id="l20.70" class="difflineplus">+  88: '0042241818244200',</span>
<a href="#l20.71"></a><span id="l20.71" class="difflineplus">+  89: '0044443810101000',</span>
<a href="#l20.72"></a><span id="l20.72" class="difflineplus">+  90: '007c081020407c00',</span>
<a href="#l20.73"></a><span id="l20.73" class="difflineplus">+  91: '0038202020202038',</span>
<a href="#l20.74"></a><span id="l20.74" class="difflineplus">+  92: '0000402010080400',</span>
<a href="#l20.75"></a><span id="l20.75" class="difflineplus">+  93: '0038080808080838',</span>
<a href="#l20.76"></a><span id="l20.76" class="difflineplus">+  94: '0010284400000000',</span>
<a href="#l20.77"></a><span id="l20.77" class="difflineplus">+  95: '000000000000fe00',</span>
<a href="#l20.78"></a><span id="l20.78" class="difflineplus">+  96: '0040200000000000',</span>
<a href="#l20.79"></a><span id="l20.79" class="difflineplus">+  97: '000038043c443c00',</span>
<a href="#l20.80"></a><span id="l20.80" class="difflineplus">+  98: '0040784444447800',</span>
<a href="#l20.81"></a><span id="l20.81" class="difflineplus">+  99: '0000384040403800',</span>
<a href="#l20.82"></a><span id="l20.82" class="difflineplus">+  100: '00043c4444443c00',</span>
<a href="#l20.83"></a><span id="l20.83" class="difflineplus">+  101: '000038447c403c00',</span>
<a href="#l20.84"></a><span id="l20.84" class="difflineplus">+  102: '0018203820202000',</span>
<a href="#l20.85"></a><span id="l20.85" class="difflineplus">+  103: '00003c44443c0438',</span>
<a href="#l20.86"></a><span id="l20.86" class="difflineplus">+  104: '0040784444444400',</span>
<a href="#l20.87"></a><span id="l20.87" class="difflineplus">+  105: '0010003010101000',</span>
<a href="#l20.88"></a><span id="l20.88" class="difflineplus">+  106: '0010003010101020',</span>
<a href="#l20.89"></a><span id="l20.89" class="difflineplus">+  107: '0040404870484400',</span>
<a href="#l20.90"></a><span id="l20.90" class="difflineplus">+  108: '0030101010101000',</span>
<a href="#l20.91"></a><span id="l20.91" class="difflineplus">+  109: '0000385454444400',</span>
<a href="#l20.92"></a><span id="l20.92" class="difflineplus">+  110: '0000784444444400',</span>
<a href="#l20.93"></a><span id="l20.93" class="difflineplus">+  111: '0000384444443800',</span>
<a href="#l20.94"></a><span id="l20.94" class="difflineplus">+  112: '0000784444784040',</span>
<a href="#l20.95"></a><span id="l20.95" class="difflineplus">+  113: '00003c44443c0406',</span>
<a href="#l20.96"></a><span id="l20.96" class="difflineplus">+  114: '00001c2020202000',</span>
<a href="#l20.97"></a><span id="l20.97" class="difflineplus">+  115: '00003c4038047800',</span>
<a href="#l20.98"></a><span id="l20.98" class="difflineplus">+  116: '0020203820201800',</span>
<a href="#l20.99"></a><span id="l20.99" class="difflineplus">+  117: '0000444444443c00',</span>
<a href="#l20.100"></a><span id="l20.100" class="difflineplus">+  118: '0000444444281000',</span>
<a href="#l20.101"></a><span id="l20.101" class="difflineplus">+  119: '0000444454543800',</span>
<a href="#l20.102"></a><span id="l20.102" class="difflineplus">+  120: '0000442810284400',</span>
<a href="#l20.103"></a><span id="l20.103" class="difflineplus">+  121: '00004444443c0438',</span>
<a href="#l20.104"></a><span id="l20.104" class="difflineplus">+  122: '00007c0810207c00',</span>
<a href="#l20.105"></a><span id="l20.105" class="difflineplus">+  123: '0018202060202018',</span>
<a href="#l20.106"></a><span id="l20.106" class="difflineplus">+  124: '0010101000101010',</span>
<a href="#l20.107"></a><span id="l20.107" class="difflineplus">+  125: '003008080c080830',</span>
<a href="#l20.108"></a><span id="l20.108" class="difflineplus">+  126: '0020540800000000',</span>
<a href="#l20.109"></a><span id="l20.109" class="difflineplus">+}</span>
<a href="#l20.110"></a><span id="l20.110" class="difflineplus">+</span>
<a href="#l20.111"></a><span id="l20.111" class="difflineplus">+def char(i):</span>
<a href="#l20.112"></a><span id="l20.112" class="difflineplus">+    &quot;&quot;&quot;Get image data for the character `i` (a one character string).</span>
<a href="#l20.113"></a><span id="l20.113" class="difflineplus">+    Returned as a list of rows.  Each row is a tuple containing the</span>
<a href="#l20.114"></a><span id="l20.114" class="difflineplus">+    packed pixels.</span>
<a href="#l20.115"></a><span id="l20.115" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l20.116"></a><span id="l20.116" class="difflineplus">+</span>
<a href="#l20.117"></a><span id="l20.117" class="difflineplus">+    i = ord(i)</span>
<a href="#l20.118"></a><span id="l20.118" class="difflineplus">+    if i not in font:</span>
<a href="#l20.119"></a><span id="l20.119" class="difflineplus">+        return [(0,)]*8</span>
<a href="#l20.120"></a><span id="l20.120" class="difflineplus">+    return map(lambda row: (ord(row),), font[i].decode('hex'))</span>
<a href="#l20.121"></a><span id="l20.121" class="difflineplus">+</span>
<a href="#l20.122"></a><span id="l20.122" class="difflineplus">+def texttoraster(m):</span>
<a href="#l20.123"></a><span id="l20.123" class="difflineplus">+    &quot;&quot;&quot;Convert string *m* to a raster image (by rendering it using the</span>
<a href="#l20.124"></a><span id="l20.124" class="difflineplus">+    font in *font*).  A triple of (*width*, *height*, *pixels*) is</span>
<a href="#l20.125"></a><span id="l20.125" class="difflineplus">+    returned; *pixels* is in boxed row packed pixel format.</span>
<a href="#l20.126"></a><span id="l20.126" class="difflineplus">+    &quot;&quot;&quot;</span>
<a href="#l20.127"></a><span id="l20.127" class="difflineplus">+</span>
<a href="#l20.128"></a><span id="l20.128" class="difflineplus">+    # Assumes monospaced font.</span>
<a href="#l20.129"></a><span id="l20.129" class="difflineplus">+    x = 8*len(m)</span>
<a href="#l20.130"></a><span id="l20.130" class="difflineplus">+    y = 8</span>
<a href="#l20.131"></a><span id="l20.131" class="difflineplus">+    return x,y,itertools.imap(lambda row: itertools.chain(*row),</span>
<a href="#l20.132"></a><span id="l20.132" class="difflineplus">+                              zip(*map(char, m)))</span>
<a href="#l20.133"></a><span id="l20.133" class="difflineplus">+</span>
<a href="#l20.134"></a><span id="l20.134" class="difflineplus">+</span>
<a href="#l20.135"></a><span id="l20.135" class="difflineplus">+def render(message, out):</span>
<a href="#l20.136"></a><span id="l20.136" class="difflineplus">+    import png</span>
<a href="#l20.137"></a><span id="l20.137" class="difflineplus">+</span>
<a href="#l20.138"></a><span id="l20.138" class="difflineplus">+    x,y,pixels = texttoraster(message)</span>
<a href="#l20.139"></a><span id="l20.139" class="difflineplus">+    w = png.Writer(x, y, greyscale=True, bitdepth=1)</span>
<a href="#l20.140"></a><span id="l20.140" class="difflineplus">+    w.write_packed(out, pixels)</span>
<a href="#l20.141"></a><span id="l20.141" class="difflineplus">+    out.flush()</span>
<a href="#l20.142"></a><span id="l20.142" class="difflineplus">+</span>
<a href="#l20.143"></a><span id="l20.143" class="difflineplus">+def main(argv=None):</span>
<a href="#l20.144"></a><span id="l20.144" class="difflineplus">+    import sys</span>
<a href="#l20.145"></a><span id="l20.145" class="difflineplus">+</span>
<a href="#l20.146"></a><span id="l20.146" class="difflineplus">+    if argv is None:</span>
<a href="#l20.147"></a><span id="l20.147" class="difflineplus">+        argv = sys.argv</span>
<a href="#l20.148"></a><span id="l20.148" class="difflineplus">+    if len(argv) &gt; 1:</span>
<a href="#l20.149"></a><span id="l20.149" class="difflineplus">+        message = argv[1]</span>
<a href="#l20.150"></a><span id="l20.150" class="difflineplus">+    else:</span>
<a href="#l20.151"></a><span id="l20.151" class="difflineplus">+        message = sys.stdin.read()</span>
<a href="#l20.152"></a><span id="l20.152" class="difflineplus">+    render(message, sys.stdout)</span>
<a href="#l20.153"></a><span id="l20.153" class="difflineplus">+</span>
<a href="#l20.154"></a><span id="l20.154" class="difflineplus">+if __name__ == '__main__':</span>
<a href="#l20.155"></a><span id="l20.155" class="difflineplus">+    main()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/config/config.mk</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/config/config.mk</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -647,16 +647,21 @@ DIR_INSTALL = $(INSTALL)</span>
<a href="#l21.4"></a><span id="l21.4"> endif # WINNT</span>
<a href="#l21.5"></a><span id="l21.5"> </span>
<a href="#l21.6"></a><span id="l21.6"> ifeq ($(OS_ARCH),WINNT)</span>
<a href="#l21.7"></a><span id="l21.7"> ifneq (,$(CYGDRIVE_MOUNT))</span>
<a href="#l21.8"></a><span id="l21.8"> export CYGDRIVE_MOUNT</span>
<a href="#l21.9"></a><span id="l21.9"> endif</span>
<a href="#l21.10"></a><span id="l21.10"> endif</span>
<a href="#l21.11"></a><span id="l21.11"> </span>
<a href="#l21.12"></a><span id="l21.12" class="difflineplus">+# png to ico converter. The function takes 5 arguments, in order: source png</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+# file, left, top, size, output ico file.</span>
<a href="#l21.14"></a><span id="l21.14" class="difflineplus">+png2ico = $(PYTHON) $(MOZILLA_DIR)/config/pythonpath.py \</span>
<a href="#l21.15"></a><span id="l21.15" class="difflineplus">+  -I$(topsrcdir)/build/pypng $(topsrcdir)/build/png2ico.py $(1) $(2) $(3) $(4) $(5)</span>
<a href="#l21.16"></a><span id="l21.16" class="difflineplus">+</span>
<a href="#l21.17"></a><span id="l21.17"> #</span>
<a href="#l21.18"></a><span id="l21.18"> # Localization build automation</span>
<a href="#l21.19"></a><span id="l21.19"> #</span>
<a href="#l21.20"></a><span id="l21.20"> </span>
<a href="#l21.21"></a><span id="l21.21"> # Because you might wish to &quot;make locales AB_CD=ab-CD&quot;, we don't hardcode</span>
<a href="#l21.22"></a><span id="l21.22"> # MOZ_UI_LOCALE directly, but use an intermediate variable that can be</span>
<a href="#l21.23"></a><span id="l21.23"> # overridden by the command line. (Besides, AB_CD is prettier).</span>
<a href="#l21.24"></a><span id="l21.24"> AB_CD = $(MOZ_UI_LOCALE)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mail/app/Makefile.in</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mail/app/Makefile.in</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -138,16 +138,26 @@ include $(topsrcdir)/config/config.mk</span>
<a href="#l22.4"></a><span id="l22.4"> </span>
<a href="#l22.5"></a><span id="l22.5"> ifdef _MSC_VER</span>
<a href="#l22.6"></a><span id="l22.6"> # Always enter a Windows program through wmain, whether or not we're</span>
<a href="#l22.7"></a><span id="l22.7"> # a console application.</span>
<a href="#l22.8"></a><span id="l22.8"> WIN32_EXE_LDFLAGS += -ENTRY:wmainCRTStartup</span>
<a href="#l22.9"></a><span id="l22.9"> endif</span>
<a href="#l22.10"></a><span id="l22.10"> </span>
<a href="#l22.11"></a><span id="l22.11"> ifeq ($(OS_ARCH),WINNT)</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineplus">+# Extract the icons we care about embedding into the EXE</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+mailtoolbar = $(topsrcdir)/mail/themes/qute/mail/icons/mail-toolbar-aero.png</span>
<a href="#l22.14"></a><span id="l22.14" class="difflineplus">+# Each icon is 18x18 in the toolbar, and we want a 16x16 icon here, so we cut</span>
<a href="#l22.15"></a><span id="l22.15" class="difflineplus">+# off a pixel at each end.</span>
<a href="#l22.16"></a><span id="l22.16" class="difflineplus">+libs::</span>
<a href="#l22.17"></a><span id="l22.17" class="difflineplus">+	$(call png2ico,$(mailtoolbar),19,1,16,write-message.ico)</span>
<a href="#l22.18"></a><span id="l22.18" class="difflineplus">+	$(call png2ico,$(mailtoolbar),37,1,16,address-book.ico)</span>
<a href="#l22.19"></a><span id="l22.19" class="difflineplus">+</span>
<a href="#l22.20"></a><span id="l22.20" class="difflineplus">+GARBAGE += write-message.ico address-book.ico</span>
<a href="#l22.21"></a><span id="l22.21" class="difflineplus">+</span>
<a href="#l22.22"></a><span id="l22.22"> OS_LIBS += $(call EXPAND_LIBNAME,comctl32 comdlg32 uuid shell32 ole32 oleaut32 version winspool)</span>
<a href="#l22.23"></a><span id="l22.23"> OS_LIBS += $(call EXPAND_LIBNAME,usp10 msimg32)</span>
<a href="#l22.24"></a><span id="l22.24"> RCINCLUDE = splash.rc</span>
<a href="#l22.25"></a><span id="l22.25"> ifndef GNU_CC</span>
<a href="#l22.26"></a><span id="l22.26"> RCFLAGS += -DMOZ_THUNDERBIRD -I$(srcdir)</span>
<a href="#l22.27"></a><span id="l22.27"> else</span>
<a href="#l22.28"></a><span id="l22.28"> RCFLAGS += -DMOZ_THUNDERBIRD --include-dir $(srcdir)</span>
<a href="#l22.29"></a><span id="l22.29"> endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mail/app/splash.rc</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mail/app/splash.rc</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -78,15 +78,20 @@ IDC_ZOOMIN              CURSOR  DISCARDA</span>
<a href="#l23.4"></a><span id="l23.4"> IDC_ZOOMOUT             CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/zoom_out.cur&quot;</span>
<a href="#l23.5"></a><span id="l23.5"> IDC_COLRESIZE           CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/col_resize.cur&quot;</span>
<a href="#l23.6"></a><span id="l23.6"> IDC_ROWRESIZE           CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/row_resize.cur&quot;</span>
<a href="#l23.7"></a><span id="l23.7"> IDC_VERTICALTEXT        CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/vertical_text.cur&quot;</span>
<a href="#l23.8"></a><span id="l23.8"> IDC_NONE                CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/none.cur&quot;</span>
<a href="#l23.9"></a><span id="l23.9"> </span>
<a href="#l23.10"></a><span id="l23.10"> #endif</span>
<a href="#l23.11"></a><span id="l23.11"> </span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-// For some reason IDI_MAILBIFF needs to be larger than the value of IDI_APPLICATION for static builds</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineminus">-#define IDI_MAILBIFF 32767</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineminus">-IDI_MAILBIFF  ICON  &quot;../../mailnews/build/newmail.ico&quot;</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineminus">-</span>
<a href="#l23.16"></a><span id="l23.16"> // Program icon.</span>
<a href="#l23.17"></a><span id="l23.17"> IDI_APPLICATION ICON THUNDERBIRD_ICO</span>
<a href="#l23.18"></a><span id="l23.18"> </span>
<a href="#l23.19"></a><span id="l23.19" class="difflineplus">+// For some reason IDI_MAILBIFF needs to be larger than the value of IDI_APPLICATION for static builds</span>
<a href="#l23.20"></a><span id="l23.20" class="difflineplus">+#define IDI_MAILBIFF 32576</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineplus">+IDI_MAILBIFF  ICON  &quot;../../mailnews/build/newmail.ico&quot;</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineplus">+</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineplus">+// Windows taskbar icons</span>
<a href="#l23.24"></a><span id="l23.24" class="difflineplus">+#define IDI_WRITE_MESSAGE 32577</span>
<a href="#l23.25"></a><span id="l23.25" class="difflineplus">+#define IDI_ADDRESS_BOOK  32578</span>
<a href="#l23.26"></a><span id="l23.26" class="difflineplus">+IDI_WRITE_MESSAGE ICON &quot;write-message.ico&quot;</span>
<a href="#l23.27"></a><span id="l23.27" class="difflineplus">+IDI_ADDRESS_BOOK  ICON &quot;address-book.ico&quot;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mail/components/wintaskbar/windowsJumpLists.js</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mail/components/wintaskbar/windowsJumpLists.js</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -78,25 +78,25 @@ function _getString(aName) {</span>
<a href="#l24.4"></a><span id="l24.4">  * Task list</span>
<a href="#l24.5"></a><span id="l24.5">  */</span>
<a href="#l24.6"></a><span id="l24.6"> let gTasks = [</span>
<a href="#l24.7"></a><span id="l24.7">   // Write new message</span>
<a href="#l24.8"></a><span id="l24.8">   {</span>
<a href="#l24.9"></a><span id="l24.9">     get title()       _getString(&quot;taskbar.tasks.composeMessage.label&quot;),</span>
<a href="#l24.10"></a><span id="l24.10">     get description() _getString(&quot;taskbar.tasks.composeMessage.description&quot;),</span>
<a href="#l24.11"></a><span id="l24.11">     args:             &quot;-compose&quot;,</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-    iconIndex:        0, // Tb app icon</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+    iconIndex:        2, // Write message icon</span>
<a href="#l24.14"></a><span id="l24.14">   },</span>
<a href="#l24.15"></a><span id="l24.15"> </span>
<a href="#l24.16"></a><span id="l24.16">   // Open address book</span>
<a href="#l24.17"></a><span id="l24.17">   {</span>
<a href="#l24.18"></a><span id="l24.18">     get title()       _getString(&quot;taskbar.tasks.openAddressBook.label&quot;),</span>
<a href="#l24.19"></a><span id="l24.19">     get description() _getString(&quot;taskbar.tasks.openAddressBook.description&quot;),</span>
<a href="#l24.20"></a><span id="l24.20">     args:             &quot;-addressbook&quot;,</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineminus">-    iconIndex:        0, // Tb app icon</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineplus">+    iconIndex:        3, // Open address book icon</span>
<a href="#l24.23"></a><span id="l24.23">   },</span>
<a href="#l24.24"></a><span id="l24.24"> ];</span>
<a href="#l24.25"></a><span id="l24.25"> </span>
<a href="#l24.26"></a><span id="l24.26"> </span>
<a href="#l24.27"></a><span id="l24.27"> let WinTaskbarJumpList = {</span>
<a href="#l24.28"></a><span id="l24.28"> </span>
<a href="#l24.29"></a><span id="l24.29">   /**</span>
<a href="#l24.30"></a><span id="l24.30">    * Startup, shutdown, and update</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/base/src/nsMessengerWinIntegration.cpp</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/base/src/nsMessengerWinIntegration.cpp</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -84,17 +84,17 @@</span>
<a href="#l25.4"></a><span id="l25.4"> </span>
<a href="#l25.5"></a><span id="l25.5"> #define XP_SHSetUnreadMailCounts &quot;SHSetUnreadMailCountW&quot;</span>
<a href="#l25.6"></a><span id="l25.6"> #define XP_SHEnumerateUnreadMailAccounts &quot;SHEnumerateUnreadMailAccountsW&quot;</span>
<a href="#l25.7"></a><span id="l25.7"> #define NOTIFICATIONCLASSNAME &quot;MailBiffNotificationMessageWindow&quot;</span>
<a href="#l25.8"></a><span id="l25.8"> #define UNREADMAILNODEKEY &quot;Software\\Microsoft\\Windows\\CurrentVersion\\UnreadMail\\&quot;</span>
<a href="#l25.9"></a><span id="l25.9"> #define SHELL32_DLL NS_LITERAL_CSTRING(&quot;shell32.dll&quot;)</span>
<a href="#l25.10"></a><span id="l25.10"> #define DOUBLE_QUOTE &quot;\&quot;&quot;</span>
<a href="#l25.11"></a><span id="l25.11"> #define MAIL_COMMANDLINE_ARG &quot; -mail&quot;</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-#define IDI_MAILBIFF 32767</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+#define IDI_MAILBIFF 32576</span>
<a href="#l25.14"></a><span id="l25.14"> #define UNREAD_UPDATE_INTERVAL	(20 * 1000)	// 20 seconds</span>
<a href="#l25.15"></a><span id="l25.15"> #define ALERT_CHROME_URL &quot;chrome://messenger/content/newmailalert.xul&quot;</span>
<a href="#l25.16"></a><span id="l25.16"> #define NEW_MAIL_ALERT_ICON &quot;chrome://messenger/skin/icons/new-mail-alert.png&quot;</span>
<a href="#l25.17"></a><span id="l25.17"> #define SHOW_ALERT_PREF     &quot;mail.biff.show_alert&quot;</span>
<a href="#l25.18"></a><span id="l25.18"> #define SHOW_TRAY_ICON_PREF &quot;mail.biff.show_tray_icon&quot;</span>
<a href="#l25.19"></a><span id="l25.19"> #define SHOW_BALLOON_PREF   &quot;mail.biff.show_balloon&quot;</span>
<a href="#l25.20"></a><span id="l25.20"> </span>
<a href="#l25.21"></a><span id="l25.21"> // since we are including windows.h in this file, undefine get user name....</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/suite/app/splash.rc</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/suite/app/splash.rc</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -74,14 +74,14 @@ IDC_ZOOMIN              CURSOR  DISCARDA</span>
<a href="#l26.4"></a><span id="l26.4"> IDC_ZOOMOUT             CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/zoom_out.cur&quot;</span>
<a href="#l26.5"></a><span id="l26.5"> IDC_COLRESIZE           CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/col_resize.cur&quot;</span>
<a href="#l26.6"></a><span id="l26.6"> IDC_ROWRESIZE           CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/row_resize.cur&quot;</span>
<a href="#l26.7"></a><span id="l26.7"> IDC_VERTICALTEXT        CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/vertical_text.cur&quot;</span>
<a href="#l26.8"></a><span id="l26.8"> IDC_NONE                CURSOR  DISCARDABLE     &quot;../../mozilla/widget/src/build/res/none.cur&quot;</span>
<a href="#l26.9"></a><span id="l26.9"> </span>
<a href="#l26.10"></a><span id="l26.10"> #endif</span>
<a href="#l26.11"></a><span id="l26.11"> </span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-// For some reason IDI_MAILBIFF needs to be larger than the value of IDI_APPLICATION for static builds</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineminus">-#define IDI_MAILBIFF 32767</span>
<a href="#l26.14"></a><span id="l26.14" class="difflineminus">-IDI_MAILBIFF  ICON  &quot;../../mailnews/build/newmail.ico&quot;</span>
<a href="#l26.15"></a><span id="l26.15" class="difflineminus">-</span>
<a href="#l26.16"></a><span id="l26.16"> // Program icon.</span>
<a href="#l26.17"></a><span id="l26.17"> IDI_APPLICATION ICON SEAMONKEY_ICO</span>
<a href="#l26.18"></a><span id="l26.18" class="difflineplus">+</span>
<a href="#l26.19"></a><span id="l26.19" class="difflineplus">+// For some reason IDI_MAILBIFF needs to be larger than the value of IDI_APPLICATION for static builds</span>
<a href="#l26.20"></a><span id="l26.20" class="difflineplus">+#define IDI_MAILBIFF 32576</span>
<a href="#l26.21"></a><span id="l26.21" class="difflineplus">+IDI_MAILBIFF  ICON  &quot;../../mailnews/build/newmail.ico&quot;</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

