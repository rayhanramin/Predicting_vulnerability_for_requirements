<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 28153:e504cc780de97396cc5acb29ffe6adbd1770a821</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ e504cc780de97396cc5acb29ffe6adbd1770a821" />
<meta property="og:url" content="/comm-central/rev/e504cc780de97396cc5acb29ffe6adbd1770a821" />
<meta property="og:description" content="Bug 1593582 - Remove xpidl [array] usage in nsICollation. r=jorgk" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / e504cc780de97396cc5acb29ffe6adbd1770a821 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/e504cc780de97396cc5acb29ffe6adbd1770a821">shortlog</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/e504cc780de97396cc5acb29ffe6adbd1770a821">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821">files</a> |
changeset |
<a href="/comm-central/raw-rev/e504cc780de97396cc5acb29ffe6adbd1770a821">raw</a>  | <a href="/comm-central/archive/e504cc780de97396cc5acb29ffe6adbd1770a821.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1593582">Bug 1593582</a> - Remove xpidl [array] usage in nsICollation. r=jorgk
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#66;&#101;&#110;&#32;&#67;&#97;&#109;&#112;&#98;&#101;&#108;&#108;&#32;&#60;&#98;&#101;&#110;&#99;&#64;&#116;&#104;&#117;&#110;&#100;&#101;&#114;&#98;&#105;&#114;&#100;&#46;&#110;&#101;&#116;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 12 Nov 2019 00:50:53 +0100</td></tr>

<tr>
 <td>changeset 28153</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/e504cc780de97396cc5acb29ffe6adbd1770a821">e504cc780de97396cc5acb29ffe6adbd1770a821</a></td>
</tr>



<tr>
<td>parent 28152</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/8ec96808a776ad111e8e781d9e278a88b55187a2">8ec96808a776ad111e8e781d9e278a88b55187a2</a>
</td>
</tr>

<tr>
<td>child 28154</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/8caa76852c2c73c348822f6430782fb2cd8a7146">8caa76852c2c73c348822f6430782fb2cd8a7146</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=e504cc780de97396cc5acb29ffe6adbd1770a821">16678</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 12 Nov 2019 10:32:22 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a9f7c4aa047f [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a9f7c4aa047f78a9f6f21e9206db567de8196f75">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a9f7c4aa047f78a9f6f21e9206db567de8196f75&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a9f7c4aa047f78a9f6f21e9206db567de8196f75&newProject=comm-central&newRevision=e504cc780de97396cc5acb29ffe6adbd1770a821&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a9f7c4aa047f78a9f6f21e9206db567de8196f75&newProject=comm-central&newRevision=e504cc780de97396cc5acb29ffe6adbd1770a821&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a9f7c4aa047f78a9f6f21e9206db567de8196f75&newProject=comm-central&newRevision=e504cc780de97396cc5acb29ffe6adbd1770a821&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28jorgk%29&revcount=50">jorgk</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1593582">1593582</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1593582">Bug 1593582</a> - Remove xpidl [array] usage in nsICollation. r=jorgk</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.cpp">mailnews/addrbook/src/nsAbView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.cpp">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.cpp">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.cpp">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.cpp">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.h">mailnews/addrbook/src/nsAbView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.h">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.h">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.h">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.h">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/addrbook/src/nsAbView.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/public/nsIMsgHdr.idl">mailnews/base/public/nsIMsgHdr.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/public/nsIMsgHdr.idl">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/public/nsIMsgHdr.idl">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/public/nsIMsgHdr.idl">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/public/nsIMsgHdr.idl">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/public/nsIMsgHdr.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.cpp">mailnews/base/src/nsMsgDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.cpp">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.cpp">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.cpp">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.cpp">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.h">mailnews/base/src/nsMsgDBView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.h">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.h">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.h">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.h">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/src/nsMsgDBView.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.cpp">mailnews/base/util/nsMsgDBFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.cpp">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.cpp">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.cpp">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.cpp">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.h">mailnews/base/util/nsMsgDBFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.h">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.h">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.h">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.h">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/base/util/nsMsgDBFolder.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsIMsgDatabase.idl">mailnews/db/msgdb/public/nsIMsgDatabase.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsIMsgDatabase.idl">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsIMsgDatabase.idl">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsIMsgDatabase.idl">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsIMsgDatabase.idl">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsIMsgDatabase.idl">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsMsgDatabase.h">mailnews/db/msgdb/public/nsMsgDatabase.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsMsgDatabase.h">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsMsgDatabase.h">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsMsgDatabase.h">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsMsgDatabase.h">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/public/nsMsgDatabase.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgDatabase.cpp">mailnews/db/msgdb/src/nsMsgDatabase.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgDatabase.cpp">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgDatabase.cpp">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgDatabase.cpp">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgDatabase.cpp">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgDatabase.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgHdr.cpp">mailnews/db/msgdb/src/nsMsgHdr.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgHdr.cpp">file</a> |
<a href="/comm-central/annotate/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgHdr.cpp">annotate</a> |
<a href="/comm-central/diff/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgHdr.cpp">diff</a> |
<a href="/comm-central/comparison/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgHdr.cpp">comparison</a> |
<a href="/comm-central/log/e504cc780de97396cc5acb29ffe6adbd1770a821/mailnews/db/msgdb/src/nsMsgHdr.cpp">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbView.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbView.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -89,21 +89,18 @@ NS_IMETHODIMP nsAbView::ClearView() {</span>
<a href="#l1.4"></a><span id="l1.4"> </span>
<a href="#l1.5"></a><span id="l1.5">   return NS_OK;</span>
<a href="#l1.6"></a><span id="l1.6"> }</span>
<a href="#l1.7"></a><span id="l1.7"> </span>
<a href="#l1.8"></a><span id="l1.8"> nsresult nsAbView::RemoveCardAt(int32_t row) {</span>
<a href="#l1.9"></a><span id="l1.9">   nsresult rv;</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11">   AbCard *abcard = mCards.ElementAt(row);</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  NS_IF_RELEASE(abcard-&gt;card);</span>
<a href="#l1.13"></a><span id="l1.13">   mCards.RemoveElementAt(row);</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineminus">-  PR_FREEIF(abcard-&gt;primaryCollationKey);</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineminus">-  PR_FREEIF(abcard-&gt;secondaryCollationKey);</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineminus">-  PR_FREEIF(abcard);</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+  delete abcard;</span>
<a href="#l1.18"></a><span id="l1.18"> </span>
<a href="#l1.19"></a><span id="l1.19">   // This needs to happen after we remove the card, as RowCountChanged() will</span>
<a href="#l1.20"></a><span id="l1.20">   // call GetRowCount()</span>
<a href="#l1.21"></a><span id="l1.21">   if (mTree) {</span>
<a href="#l1.22"></a><span id="l1.22">     mTree-&gt;RowCountChanged(row, -1);</span>
<a href="#l1.23"></a><span id="l1.23">   }</span>
<a href="#l1.24"></a><span id="l1.24"> </span>
<a href="#l1.25"></a><span id="l1.25">   if (mAbViewListener &amp;&amp; !mSuppressCountChange) {</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineat">@@ -285,22 +282,17 @@ nsresult nsAbView::EnumerateCards() {</span>
<a href="#l1.27"></a><span id="l1.27">   rv = mDirectory-&gt;GetChildCards(getter_AddRefs(cardsEnumerator));</span>
<a href="#l1.28"></a><span id="l1.28">   if (NS_SUCCEEDED(rv) &amp;&amp; cardsEnumerator) {</span>
<a href="#l1.29"></a><span id="l1.29">     nsCOMPtr&lt;nsISupports&gt; item;</span>
<a href="#l1.30"></a><span id="l1.30">     bool more;</span>
<a href="#l1.31"></a><span id="l1.31">     while (NS_SUCCEEDED(cardsEnumerator-&gt;HasMoreElements(&amp;more)) &amp;&amp; more) {</span>
<a href="#l1.32"></a><span id="l1.32">       rv = cardsEnumerator-&gt;GetNext(getter_AddRefs(item));</span>
<a href="#l1.33"></a><span id="l1.33">       if (NS_SUCCEEDED(rv)) {</span>
<a href="#l1.34"></a><span id="l1.34">         nsCOMPtr&lt;nsIAbCard&gt; card = do_QueryInterface(item);</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineminus">-        // Malloc these from an arena</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineminus">-        AbCard *abcard = (AbCard *)PR_Calloc(1, sizeof(struct AbCard));</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-        if (!abcard) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineminus">-</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineminus">-        abcard-&gt;card = card;</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-        NS_IF_ADDREF(abcard-&gt;card);</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+        AbCard *abcard = new AbCard(card);</span>
<a href="#l1.42"></a><span id="l1.42"> </span>
<a href="#l1.43"></a><span id="l1.43">         // XXX todo</span>
<a href="#l1.44"></a><span id="l1.44">         // Would it be better to do an insertion sort, than append and sort?</span>
<a href="#l1.45"></a><span id="l1.45">         // XXX todo</span>
<a href="#l1.46"></a><span id="l1.46">         // If we knew how many cards there was going to be</span>
<a href="#l1.47"></a><span id="l1.47">         // we could allocate an array of the size,</span>
<a href="#l1.48"></a><span id="l1.48">         // instead of growing and copying as we append.</span>
<a href="#l1.49"></a><span id="l1.49">         DebugOnly&lt;bool&gt; didAppend = mCards.AppendElement(abcard);</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineat">@@ -569,36 +561,31 @@ static int inplaceSortCallback(const AbC</span>
<a href="#l1.51"></a><span id="l1.51">   // If we are sorting the &quot;PrimaryEmail&quot;, swap the collation keys, as the</span>
<a href="#l1.52"></a><span id="l1.52">   // secondary is always the PrimaryEmail. Use the last primary key as the</span>
<a href="#l1.53"></a><span id="l1.53">   // secondary key.</span>
<a href="#l1.54"></a><span id="l1.54">   //</span>
<a href="#l1.55"></a><span id="l1.55">   // &quot;Pr&quot; to distinguish &quot;PrimaryEmail&quot; from &quot;PagerNumber&quot;</span>
<a href="#l1.56"></a><span id="l1.56">   if (closure-&gt;colID[0] == char16_t('P') &amp;&amp;</span>
<a href="#l1.57"></a><span id="l1.57">       closure-&gt;colID[1] == char16_t('r')) {</span>
<a href="#l1.58"></a><span id="l1.58">     sortValue = closure-&gt;abView-&gt;CompareCollationKeys(</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineminus">-        card1-&gt;secondaryCollationKey, card1-&gt;secondaryCollationKeyLen,</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineminus">-        card2-&gt;secondaryCollationKey, card2-&gt;secondaryCollationKeyLen);</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+        card1-&gt;secondaryCollationKey, card2-&gt;secondaryCollationKey);</span>
<a href="#l1.62"></a><span id="l1.62">     if (sortValue)</span>
<a href="#l1.63"></a><span id="l1.63">       return sortValue * closure-&gt;factor;</span>
<a href="#l1.64"></a><span id="l1.64">     else</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineminus">-      return closure-&gt;abView-&gt;CompareCollationKeys(</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineminus">-                 card1-&gt;primaryCollationKey, card1-&gt;primaryCollationKeyLen,</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineminus">-                 card2-&gt;primaryCollationKey, card2-&gt;primaryCollationKeyLen) *</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+      return closure-&gt;abView-&gt;CompareCollationKeys(card1-&gt;primaryCollationKey,</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+                                                   card2-&gt;primaryCollationKey) *</span>
<a href="#l1.70"></a><span id="l1.70">              (closure-&gt;factor);</span>
<a href="#l1.71"></a><span id="l1.71">   } else {</span>
<a href="#l1.72"></a><span id="l1.72">     sortValue = closure-&gt;abView-&gt;CompareCollationKeys(</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineminus">-        card1-&gt;primaryCollationKey, card1-&gt;primaryCollationKeyLen,</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineminus">-        card2-&gt;primaryCollationKey, card2-&gt;primaryCollationKeyLen);</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+        card1-&gt;primaryCollationKey, card2-&gt;primaryCollationKey);</span>
<a href="#l1.76"></a><span id="l1.76">     if (sortValue)</span>
<a href="#l1.77"></a><span id="l1.77">       return sortValue * (closure-&gt;factor);</span>
<a href="#l1.78"></a><span id="l1.78">     else</span>
<a href="#l1.79"></a><span id="l1.79">       return closure-&gt;abView-&gt;CompareCollationKeys(</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineminus">-                 card1-&gt;secondaryCollationKey, card1-&gt;secondaryCollationKeyLen,</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineminus">-                 card2-&gt;secondaryCollationKey,</span>
<a href="#l1.82"></a><span id="l1.82" class="difflineminus">-                 card2-&gt;secondaryCollationKeyLen) *</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineplus">+                 card1-&gt;secondaryCollationKey, card2-&gt;secondaryCollationKey) *</span>
<a href="#l1.84"></a><span id="l1.84">              (closure-&gt;factor);</span>
<a href="#l1.85"></a><span id="l1.85">   }</span>
<a href="#l1.86"></a><span id="l1.86"> }</span>
<a href="#l1.87"></a><span id="l1.87"> </span>
<a href="#l1.88"></a><span id="l1.88"> static void SetSortClosure(const char16_t *sortColumn,</span>
<a href="#l1.89"></a><span id="l1.89">                            const char16_t *sortDirection, nsAbView *abView,</span>
<a href="#l1.90"></a><span id="l1.90">                            SortClosure *closure) {</span>
<a href="#l1.91"></a><span id="l1.91">   closure-&gt;colID = sortColumn;</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineat">@@ -709,25 +696,24 @@ NS_IMETHODIMP nsAbView::SortBy(const cha</span>
<a href="#l1.93"></a><span id="l1.93">     mSortDirection = sortDirection;</span>
<a href="#l1.94"></a><span id="l1.94">   }</span>
<a href="#l1.95"></a><span id="l1.95"> </span>
<a href="#l1.96"></a><span id="l1.96">   rv = InvalidateTree(ALL_ROWS);</span>
<a href="#l1.97"></a><span id="l1.97">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.98"></a><span id="l1.98">   return rv;</span>
<a href="#l1.99"></a><span id="l1.99"> }</span>
<a href="#l1.100"></a><span id="l1.100"> </span>
<a href="#l1.101"></a><span id="l1.101" class="difflineminus">-int32_t nsAbView::CompareCollationKeys(uint8_t *key1, uint32_t len1,</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineminus">-                                       uint8_t *key2, uint32_t len2) {</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+int32_t nsAbView::CompareCollationKeys(const nsTArray&lt;uint8_t&gt; &amp;key1,</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineplus">+                                       const nsTArray&lt;uint8_t&gt; &amp;key2) {</span>
<a href="#l1.105"></a><span id="l1.105">   NS_ASSERTION(mCollationKeyGenerator, &quot;no key generator&quot;);</span>
<a href="#l1.106"></a><span id="l1.106">   if (!mCollationKeyGenerator) return 0;</span>
<a href="#l1.107"></a><span id="l1.107"> </span>
<a href="#l1.108"></a><span id="l1.108">   int32_t result;</span>
<a href="#l1.109"></a><span id="l1.109"> </span>
<a href="#l1.110"></a><span id="l1.110" class="difflineminus">-  nsresult rv = mCollationKeyGenerator-&gt;CompareRawSortKey(key1, len1, key2,</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineminus">-                                                          len2, &amp;result);</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineplus">+  nsresult rv = mCollationKeyGenerator-&gt;CompareRawSortKey(key1, key2, &amp;result);</span>
<a href="#l1.113"></a><span id="l1.113">   NS_ASSERTION(NS_SUCCEEDED(rv), &quot;key compare failed&quot;);</span>
<a href="#l1.114"></a><span id="l1.114">   if (NS_FAILED(rv)) result = 0;</span>
<a href="#l1.115"></a><span id="l1.115">   return result;</span>
<a href="#l1.116"></a><span id="l1.116"> }</span>
<a href="#l1.117"></a><span id="l1.117"> </span>
<a href="#l1.118"></a><span id="l1.118"> nsresult nsAbView::GenerateCollationKeysForCard(const nsAString &amp;colID,</span>
<a href="#l1.119"></a><span id="l1.119">                                                 AbCard *abcard) {</span>
<a href="#l1.120"></a><span id="l1.120">   nsresult rv;</span>
<a href="#l1.121"></a><span id="l1.121" class="difflineat">@@ -740,32 +726,29 @@ nsresult nsAbView::GenerateCollationKeys</span>
<a href="#l1.122"></a><span id="l1.122"> </span>
<a href="#l1.123"></a><span id="l1.123">     rv = factory-&gt;CreateCollation(getter_AddRefs(mCollationKeyGenerator));</span>
<a href="#l1.124"></a><span id="l1.124">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.125"></a><span id="l1.125">   }</span>
<a href="#l1.126"></a><span id="l1.126"> </span>
<a href="#l1.127"></a><span id="l1.127">   rv = GetCardValue(abcard-&gt;card, colID, value);</span>
<a href="#l1.128"></a><span id="l1.128">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.129"></a><span id="l1.129"> </span>
<a href="#l1.130"></a><span id="l1.130" class="difflineminus">-  PR_FREEIF(abcard-&gt;primaryCollationKey);</span>
<a href="#l1.131"></a><span id="l1.131">   rv = mCollationKeyGenerator-&gt;AllocateRawSortKey(</span>
<a href="#l1.132"></a><span id="l1.132">       nsICollation::kCollationCaseInSensitive, value,</span>
<a href="#l1.133"></a><span id="l1.133" class="difflineminus">-      &amp;(abcard-&gt;primaryCollationKey), &amp;(abcard-&gt;primaryCollationKeyLen));</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineplus">+      abcard-&gt;primaryCollationKey);</span>
<a href="#l1.135"></a><span id="l1.135">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.136"></a><span id="l1.136"> </span>
<a href="#l1.137"></a><span id="l1.137">   // Hardcode email to be our secondary key. As we are doing this, just call</span>
<a href="#l1.138"></a><span id="l1.138">   // the card's GetCardValue direct, rather than our own function which will</span>
<a href="#l1.139"></a><span id="l1.139">   // end up doing the same as then we can save a bit of time.</span>
<a href="#l1.140"></a><span id="l1.140">   rv = abcard-&gt;card-&gt;GetPrimaryEmail(value);</span>
<a href="#l1.141"></a><span id="l1.141">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.142"></a><span id="l1.142" class="difflineminus">-</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineminus">-  PR_FREEIF(abcard-&gt;secondaryCollationKey);</span>
<a href="#l1.144"></a><span id="l1.144">   rv = mCollationKeyGenerator-&gt;AllocateRawSortKey(</span>
<a href="#l1.145"></a><span id="l1.145">       nsICollation::kCollationCaseInSensitive, value,</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineminus">-      &amp;(abcard-&gt;secondaryCollationKey), &amp;(abcard-&gt;secondaryCollationKeyLen));</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineplus">+      abcard-&gt;secondaryCollationKey);</span>
<a href="#l1.148"></a><span id="l1.148">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.149"></a><span id="l1.149">   return rv;</span>
<a href="#l1.150"></a><span id="l1.150"> }</span>
<a href="#l1.151"></a><span id="l1.151"> </span>
<a href="#l1.152"></a><span id="l1.152"> // A helper method currently returns true if the directory is an LDAP.</span>
<a href="#l1.153"></a><span id="l1.153"> // We can tweak this to return true for all Remote Address Books where the</span>
<a href="#l1.154"></a><span id="l1.154"> // search is asynchronous.</span>
<a href="#l1.155"></a><span id="l1.155"> bool isDirectoryRemote(nsCOMPtr&lt;nsIAbDirectory&gt; aDir) {</span>
<a href="#l1.156"></a><span id="l1.156" class="difflineat">@@ -810,23 +793,17 @@ NS_IMETHODIMP nsAbView::OnItemAdded(nsIS</span>
<a href="#l1.157"></a><span id="l1.157">   mDirectory-&gt;GetIsQuery(&amp;isMDirectoryQuery);</span>
<a href="#l1.158"></a><span id="l1.158">   // Get the query string for the selected directory in the main AB window.</span>
<a href="#l1.159"></a><span id="l1.159">   nsCString mDirectoryQuery(getQuery(mDirectory));</span>
<a href="#l1.160"></a><span id="l1.160">   if ((mIsAllDirectoryRootView &amp;&amp; isRemote &amp;&amp; isDirectoryQuery &amp;&amp;</span>
<a href="#l1.161"></a><span id="l1.161">        isMDirectoryQuery &amp;&amp; directoryQuery.Equals(mDirectoryQuery)) ||</span>
<a href="#l1.162"></a><span id="l1.162">       directory.get() == mDirectory.get()) {</span>
<a href="#l1.163"></a><span id="l1.163">     nsCOMPtr&lt;nsIAbCard&gt; addedCard = do_QueryInterface(item);</span>
<a href="#l1.164"></a><span id="l1.164">     if (addedCard) {</span>
<a href="#l1.165"></a><span id="l1.165" class="difflineminus">-      // Malloc these from an arena</span>
<a href="#l1.166"></a><span id="l1.166" class="difflineminus">-      AbCard *abcard = (AbCard *)PR_Calloc(1, sizeof(struct AbCard));</span>
<a href="#l1.167"></a><span id="l1.167" class="difflineminus">-      if (!abcard) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.168"></a><span id="l1.168" class="difflineminus">-</span>
<a href="#l1.169"></a><span id="l1.169" class="difflineminus">-      abcard-&gt;card = addedCard;</span>
<a href="#l1.170"></a><span id="l1.170" class="difflineminus">-      NS_IF_ADDREF(abcard-&gt;card);</span>
<a href="#l1.171"></a><span id="l1.171" class="difflineminus">-</span>
<a href="#l1.172"></a><span id="l1.172" class="difflineplus">+      AbCard *abcard = new AbCard(addedCard);</span>
<a href="#l1.173"></a><span id="l1.173">       rv = GenerateCollationKeysForCard(mSortColumn, abcard);</span>
<a href="#l1.174"></a><span id="l1.174">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.175"></a><span id="l1.175"> </span>
<a href="#l1.176"></a><span id="l1.176">       int32_t index;</span>
<a href="#l1.177"></a><span id="l1.177">       rv = AddCard(abcard, false /* select card */, &amp;index);</span>
<a href="#l1.178"></a><span id="l1.178">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.179"></a><span id="l1.179">     }</span>
<a href="#l1.180"></a><span id="l1.180">   }</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineat">@@ -843,16 +820,18 @@ NS_IMETHODIMP nsAbView::Observe(nsISuppo</span>
<a href="#l1.182"></a><span id="l1.182"> </span>
<a href="#l1.183"></a><span id="l1.183">       rv = RefreshTree();</span>
<a href="#l1.184"></a><span id="l1.184">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.185"></a><span id="l1.185">     }</span>
<a href="#l1.186"></a><span id="l1.186">   }</span>
<a href="#l1.187"></a><span id="l1.187">   return NS_OK;</span>
<a href="#l1.188"></a><span id="l1.188"> }</span>
<a href="#l1.189"></a><span id="l1.189"> </span>
<a href="#l1.190"></a><span id="l1.190" class="difflineplus">+// Adds a card into our internal mCards array.</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineplus">+// mCards takes ownership of abcard.</span>
<a href="#l1.192"></a><span id="l1.192"> nsresult nsAbView::AddCard(AbCard *abcard, bool selectCardAfterAdding,</span>
<a href="#l1.193"></a><span id="l1.193">                            int32_t *index) {</span>
<a href="#l1.194"></a><span id="l1.194">   nsresult rv = NS_OK;</span>
<a href="#l1.195"></a><span id="l1.195">   NS_ENSURE_ARG_POINTER(abcard);</span>
<a href="#l1.196"></a><span id="l1.196"> </span>
<a href="#l1.197"></a><span id="l1.197">   *index = FindIndexForInsert(abcard);</span>
<a href="#l1.198"></a><span id="l1.198">   mCards.InsertElementAt(*index, abcard);</span>
<a href="#l1.199"></a><span id="l1.199"> </span>
<a href="#l1.200"></a><span id="l1.200" class="difflineat">@@ -982,47 +961,36 @@ NS_IMETHODIMP nsAbView::OnItemPropertyCh</span>
<a href="#l1.201"></a><span id="l1.201"> </span>
<a href="#l1.202"></a><span id="l1.202">   nsCOMPtr&lt;nsIAbCard&gt; card = do_QueryInterface(item);</span>
<a href="#l1.203"></a><span id="l1.203">   if (!card) return NS_OK;</span>
<a href="#l1.204"></a><span id="l1.204"> </span>
<a href="#l1.205"></a><span id="l1.205">   int32_t index = FindIndexForCard(card);</span>
<a href="#l1.206"></a><span id="l1.206">   if (index == -1) return NS_OK;</span>
<a href="#l1.207"></a><span id="l1.207"> </span>
<a href="#l1.208"></a><span id="l1.208">   AbCard *oldCard = mCards.ElementAt(index);</span>
<a href="#l1.209"></a><span id="l1.209" class="difflineminus">-</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineminus">-  // Malloc these from an arena</span>
<a href="#l1.211"></a><span id="l1.211" class="difflineminus">-  AbCard *newCard = (AbCard *)PR_Calloc(1, sizeof(struct AbCard));</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineminus">-  if (!newCard) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineminus">-</span>
<a href="#l1.214"></a><span id="l1.214" class="difflineminus">-  newCard-&gt;card = card;</span>
<a href="#l1.215"></a><span id="l1.215" class="difflineminus">-  NS_IF_ADDREF(newCard-&gt;card);</span>
<a href="#l1.216"></a><span id="l1.216" class="difflineplus">+  AbCard *newCard = new AbCard(card);</span>
<a href="#l1.217"></a><span id="l1.217"> </span>
<a href="#l1.218"></a><span id="l1.218">   rv = GenerateCollationKeysForCard(mSortColumn, newCard);</span>
<a href="#l1.219"></a><span id="l1.219">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.220"></a><span id="l1.220"> </span>
<a href="#l1.221"></a><span id="l1.221">   bool cardWasSelected = false;</span>
<a href="#l1.222"></a><span id="l1.222"> </span>
<a href="#l1.223"></a><span id="l1.223">   if (mTreeSelection) {</span>
<a href="#l1.224"></a><span id="l1.224">     rv = mTreeSelection-&gt;IsSelected(index, &amp;cardWasSelected);</span>
<a href="#l1.225"></a><span id="l1.225">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.226"></a><span id="l1.226">   }</span>
<a href="#l1.227"></a><span id="l1.227"> </span>
<a href="#l1.228"></a><span id="l1.228" class="difflineminus">-  if (!CompareCollationKeys(</span>
<a href="#l1.229"></a><span id="l1.229" class="difflineminus">-          newCard-&gt;primaryCollationKey, newCard-&gt;primaryCollationKeyLen,</span>
<a href="#l1.230"></a><span id="l1.230" class="difflineminus">-          oldCard-&gt;primaryCollationKey, oldCard-&gt;primaryCollationKeyLen) &amp;&amp;</span>
<a href="#l1.231"></a><span id="l1.231" class="difflineminus">-      CompareCollationKeys(</span>
<a href="#l1.232"></a><span id="l1.232" class="difflineminus">-          newCard-&gt;secondaryCollationKey, newCard-&gt;secondaryCollationKeyLen,</span>
<a href="#l1.233"></a><span id="l1.233" class="difflineminus">-          oldCard-&gt;secondaryCollationKey, oldCard-&gt;secondaryCollationKeyLen)) {</span>
<a href="#l1.234"></a><span id="l1.234" class="difflineplus">+  if (!CompareCollationKeys(newCard-&gt;primaryCollationKey,</span>
<a href="#l1.235"></a><span id="l1.235" class="difflineplus">+                            oldCard-&gt;primaryCollationKey) &amp;&amp;</span>
<a href="#l1.236"></a><span id="l1.236" class="difflineplus">+      CompareCollationKeys(newCard-&gt;secondaryCollationKey,</span>
<a href="#l1.237"></a><span id="l1.237" class="difflineplus">+                           oldCard-&gt;secondaryCollationKey)) {</span>
<a href="#l1.238"></a><span id="l1.238">     // No need to remove and add, since the collation keys haven't changed.</span>
<a href="#l1.239"></a><span id="l1.239">     // Since they haven't changed, the card will sort to the same place.</span>
<a href="#l1.240"></a><span id="l1.240">     // We just need to clean up what we allocated.</span>
<a href="#l1.241"></a><span id="l1.241" class="difflineminus">-    NS_IF_RELEASE(newCard-&gt;card);</span>
<a href="#l1.242"></a><span id="l1.242" class="difflineminus">-    if (newCard-&gt;primaryCollationKey) free(newCard-&gt;primaryCollationKey);</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineminus">-    if (newCard-&gt;secondaryCollationKey) free(newCard-&gt;secondaryCollationKey);</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineminus">-    PR_FREEIF(newCard);</span>
<a href="#l1.245"></a><span id="l1.245" class="difflineplus">+    delete newCard;</span>
<a href="#l1.246"></a><span id="l1.246"> </span>
<a href="#l1.247"></a><span id="l1.247">     // Still need to invalidate, as the other columns may have changed.</span>
<a href="#l1.248"></a><span id="l1.248">     rv = InvalidateTree(index);</span>
<a href="#l1.249"></a><span id="l1.249">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l1.250"></a><span id="l1.250">   } else {</span>
<a href="#l1.251"></a><span id="l1.251">     mSuppressSelectionChange = true;</span>
<a href="#l1.252"></a><span id="l1.252">     mSuppressCountChange = true;</span>
<a href="#l1.253"></a><span id="l1.253"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbView.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbView.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -18,38 +18,37 @@</span>
<a href="#l2.4"></a><span id="l2.4"> #include &quot;nsIAbListener.h&quot;</span>
<a href="#l2.5"></a><span id="l2.5"> #include &quot;nsIObserver.h&quot;</span>
<a href="#l2.6"></a><span id="l2.6"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l2.7"></a><span id="l2.7"> #include &quot;nsComponentManagerUtils.h&quot;</span>
<a href="#l2.8"></a><span id="l2.8"> #include &quot;nsMemory.h&quot;</span>
<a href="#l2.9"></a><span id="l2.9"> #include &quot;nsIStringBundle.h&quot;</span>
<a href="#l2.10"></a><span id="l2.10"> </span>
<a href="#l2.11"></a><span id="l2.11"> typedef struct AbCard {</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  nsIAbCard *card;</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-  uint32_t primaryCollationKeyLen;</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineminus">-  uint32_t secondaryCollationKeyLen;</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineminus">-  uint8_t *primaryCollationKey;</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineminus">-  uint8_t *secondaryCollationKey;</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+  explicit AbCard(nsIAbCard *c) : card(c) {}</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+  nsCOMPtr&lt;nsIAbCard&gt; card;</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+  nsTArray&lt;uint8_t&gt; primaryCollationKey;</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+  nsTArray&lt;uint8_t&gt; secondaryCollationKey;</span>
<a href="#l2.21"></a><span id="l2.21"> } AbCard;</span>
<a href="#l2.22"></a><span id="l2.22"> </span>
<a href="#l2.23"></a><span id="l2.23"> class nsAbView : public nsIAbView,</span>
<a href="#l2.24"></a><span id="l2.24">                  public nsITreeView,</span>
<a href="#l2.25"></a><span id="l2.25">                  public nsIAbListener,</span>
<a href="#l2.26"></a><span id="l2.26">                  public nsIObserver {</span>
<a href="#l2.27"></a><span id="l2.27">  public:</span>
<a href="#l2.28"></a><span id="l2.28">   nsAbView();</span>
<a href="#l2.29"></a><span id="l2.29"> </span>
<a href="#l2.30"></a><span id="l2.30">   NS_DECL_ISUPPORTS</span>
<a href="#l2.31"></a><span id="l2.31">   NS_DECL_NSIABVIEW</span>
<a href="#l2.32"></a><span id="l2.32">   NS_DECL_NSITREEVIEW</span>
<a href="#l2.33"></a><span id="l2.33">   NS_DECL_NSIABLISTENER</span>
<a href="#l2.34"></a><span id="l2.34">   NS_DECL_NSIOBSERVER</span>
<a href="#l2.35"></a><span id="l2.35"> </span>
<a href="#l2.36"></a><span id="l2.36" class="difflineminus">-  int32_t CompareCollationKeys(uint8_t *key1, uint32_t len1, uint8_t *key2,</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineminus">-                               uint32_t len2);</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+  int32_t CompareCollationKeys(const nsTArray&lt;uint8_t&gt; &amp;key1,</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+                               const nsTArray&lt;uint8_t&gt; &amp;key2);</span>
<a href="#l2.40"></a><span id="l2.40"> </span>
<a href="#l2.41"></a><span id="l2.41">  private:</span>
<a href="#l2.42"></a><span id="l2.42">   virtual ~nsAbView();</span>
<a href="#l2.43"></a><span id="l2.43">   nsresult Initialize();</span>
<a href="#l2.44"></a><span id="l2.44">   int32_t FindIndexForInsert(AbCard *abcard);</span>
<a href="#l2.45"></a><span id="l2.45">   int32_t FindIndexForCard(nsIAbCard *card);</span>
<a href="#l2.46"></a><span id="l2.46">   nsresult GenerateCollationKeysForCard(const nsAString &amp;colID, AbCard *abcard);</span>
<a href="#l2.47"></a><span id="l2.47">   nsresult InvalidateTree(int32_t row);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/base/public/nsIMsgHdr.idl</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/base/public/nsIMsgHdr.idl</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -73,22 +73,19 @@ interface nsIMsgDBHdr : nsISupports</span>
<a href="#l3.4"></a><span id="l3.4">     void setReferences(in string references);</span>
<a href="#l3.5"></a><span id="l3.5">     readonly attribute unsigned short numReferences;</span>
<a href="#l3.6"></a><span id="l3.6">     ACString getStringReference(in long refNum);</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8">     readonly attribute AString mime2DecodedAuthor;</span>
<a href="#l3.9"></a><span id="l3.9">     readonly attribute AString mime2DecodedSubject;</span>
<a href="#l3.10"></a><span id="l3.10">     readonly attribute AString mime2DecodedRecipients;</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-    void getAuthorCollationKey(out unsigned long aCount,</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-                              [array, size_is(aCount)] out octet aKey);</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-    void getSubjectCollationKey(out unsigned long aCount,</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">-                                [array, size_is(aCount)] out octet aKey);</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineminus">-    void getRecipientsCollationKey(out unsigned long aCount,</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineminus">-                                  [array, size_is(aCount)] out octet aKey);</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+    Array&lt;octet&gt; getAuthorCollationKey();</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+    Array&lt;octet&gt; getSubjectCollationKey();</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+    Array&lt;octet&gt; getRecipientsCollationKey();</span>
<a href="#l3.21"></a><span id="l3.21"> </span>
<a href="#l3.22"></a><span id="l3.22">     attribute string Charset;</span>
<a href="#l3.23"></a><span id="l3.23">     /**</span>
<a href="#l3.24"></a><span id="l3.24">      * Returns the effective character set for the message (@ref Charset).</span>
<a href="#l3.25"></a><span id="l3.25">      * If there is no specific set defined for the message or the</span>
<a href="#l3.26"></a><span id="l3.26">      * characterSetOverride option is turned on for the folder it will return</span>
<a href="#l3.27"></a><span id="l3.27">      * the effective character set of the folder instead.</span>
<a href="#l3.28"></a><span id="l3.28">      */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -73,21 +73,29 @@ mozilla::nsDateFormatSelector nsMsgDBVie</span>
<a href="#l4.4"></a><span id="l4.4"> static const uint32_t kMaxNumSortColumns = 2;</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6"> static void GetCachedName(const nsCString &amp;unparsedString,</span>
<a href="#l4.7"></a><span id="l4.7">                           int32_t displayVersion, nsACString &amp;cachedName);</span>
<a href="#l4.8"></a><span id="l4.8"> </span>
<a href="#l4.9"></a><span id="l4.9"> static void UpdateCachedName(nsIMsgDBHdr *aHdr, const char *header_field,</span>
<a href="#l4.10"></a><span id="l4.10">                              const nsAString &amp;newName);</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-// This is passed into NS_QuickSort as custom data.</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+// viewSortInfo is context data passed into the sort comparison functions -</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+// FnSortIdUint32 for comparing numeric fields, FnSortIdKey for everything</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+// else. If a comparison function finds two elements with equal primary</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+// ordering, it'll call SecondaryCompare() to break the deadlock.</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+// SecondaryCompare() uses the same comparison functions again, but using the</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+// secondary key and potentially with different criteria (eg secondary sort</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+// order might be different to primary). The viewSortInfo::isSecondarySort</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+// flag lets the comparison function know not to call SecondaryCompare()</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+// again (and again and again)...</span>
<a href="#l4.22"></a><span id="l4.22"> class viewSortInfo {</span>
<a href="#l4.23"></a><span id="l4.23">  public:</span>
<a href="#l4.24"></a><span id="l4.24">   nsMsgDBView *view;</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineminus">-  nsIMsgDatabase *db;</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+  nsIMsgDatabase *db;  // Which db to use for collation compares.</span>
<a href="#l4.27"></a><span id="l4.27">   bool isSecondarySort;</span>
<a href="#l4.28"></a><span id="l4.28">   bool ascendingSort;</span>
<a href="#l4.29"></a><span id="l4.29"> };</span>
<a href="#l4.30"></a><span id="l4.30"> </span>
<a href="#l4.31"></a><span id="l4.31"> NS_IMPL_ADDREF(nsMsgDBView)</span>
<a href="#l4.32"></a><span id="l4.32"> NS_IMPL_RELEASE(nsMsgDBView)</span>
<a href="#l4.33"></a><span id="l4.33"> </span>
<a href="#l4.34"></a><span id="l4.34"> NS_INTERFACE_MAP_BEGIN(nsMsgDBView)</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineat">@@ -3648,84 +3656,57 @@ void nsMsgDBView::ReverseSort() {</span>
<a href="#l4.36"></a><span id="l4.36">     // ReverseSort in non-threaded mode, m_levels are all the same.</span>
<a href="#l4.37"></a><span id="l4.37">   }</span>
<a href="#l4.38"></a><span id="l4.38"> }</span>
<a href="#l4.39"></a><span id="l4.39"> </span>
<a href="#l4.40"></a><span id="l4.40"> int nsMsgDBView::FnSortIdKey(const void *pItem1, const void *pItem2,</span>
<a href="#l4.41"></a><span id="l4.41">                              void *privateData) {</span>
<a href="#l4.42"></a><span id="l4.42">   int32_t retVal = 0;</span>
<a href="#l4.43"></a><span id="l4.43"> </span>
<a href="#l4.44"></a><span id="l4.44" class="difflineminus">-  IdKey **p1 = (IdKey **)pItem1;</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineminus">-  IdKey **p2 = (IdKey **)pItem2;</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+  const IdKey *p1 = *((const IdKey **)pItem1);</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+  const IdKey *p2 = *((const IdKey **)pItem2);</span>
<a href="#l4.48"></a><span id="l4.48">   viewSortInfo *sortInfo = (viewSortInfo *)privateData;</span>
<a href="#l4.49"></a><span id="l4.49"> </span>
<a href="#l4.50"></a><span id="l4.50">   nsIMsgDatabase *db = sortInfo-&gt;db;</span>
<a href="#l4.51"></a><span id="l4.51"> </span>
<a href="#l4.52"></a><span id="l4.52" class="difflineminus">-  mozilla::DebugOnly&lt;nsresult&gt; rv = db-&gt;CompareCollationKeys(</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineminus">-      (*p1)-&gt;dword, (*p1)-&gt;key, (*p2)-&gt;dword, (*p2)-&gt;key, &amp;retVal);</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+  mozilla::DebugOnly&lt;nsresult&gt; rv =</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+      db-&gt;CompareCollationKeys(p1-&gt;key, p2-&gt;key, &amp;retVal);</span>
<a href="#l4.56"></a><span id="l4.56">   NS_ASSERTION(NS_SUCCEEDED(rv), &quot;compare failed&quot;);</span>
<a href="#l4.57"></a><span id="l4.57"> </span>
<a href="#l4.58"></a><span id="l4.58">   if (retVal) return sortInfo-&gt;ascendingSort ? retVal : -retVal;</span>
<a href="#l4.59"></a><span id="l4.59"> </span>
<a href="#l4.60"></a><span id="l4.60">   // clang-format off</span>
<a href="#l4.61"></a><span id="l4.61">   if (sortInfo-&gt;view-&gt;m_secondarySort == nsMsgViewSortType::byId)</span>
<a href="#l4.62"></a><span id="l4.62">     return (sortInfo-&gt;view-&gt;m_secondarySortOrder == nsMsgViewSortOrder::ascending &amp;&amp;</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineminus">-            (*p1)-&gt;id &gt;= (*p2)-&gt;id) ? 1 : -1;</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+            p1-&gt;id &gt;= p2-&gt;id) ? 1 : -1;</span>
<a href="#l4.65"></a><span id="l4.65">   // clang-format on</span>
<a href="#l4.66"></a><span id="l4.66">   else</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineminus">-    return sortInfo-&gt;view-&gt;SecondarySort((*p1)-&gt;id, (*p1)-&gt;folder, (*p2)-&gt;id,</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineminus">-                                         (*p2)-&gt;folder, sortInfo);</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineminus">-  // Here we'd use the secondary sort.</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineminus">-}</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineminus">-</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineminus">-int nsMsgDBView::FnSortIdKeyPtr(const void *pItem1, const void *pItem2,</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineminus">-                                void *privateData) {</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineminus">-  int32_t retVal = 0;</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineminus">-</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineminus">-  IdKeyPtr **p1 = (IdKeyPtr **)pItem1;</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineminus">-  IdKeyPtr **p2 = (IdKeyPtr **)pItem2;</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineminus">-  viewSortInfo *sortInfo = (viewSortInfo *)privateData;</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineminus">-</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineminus">-  nsIMsgDatabase *db = sortInfo-&gt;db;</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineminus">-</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineminus">-  mozilla::DebugOnly&lt;nsresult&gt; rv = db-&gt;CompareCollationKeys(</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineminus">-      (*p1)-&gt;dword, (*p1)-&gt;key, (*p2)-&gt;dword, (*p2)-&gt;key, &amp;retVal);</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineminus">-  NS_ASSERTION(NS_SUCCEEDED(rv), &quot;compare failed&quot;);</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineminus">-</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineminus">-  if (retVal) return sortInfo-&gt;ascendingSort ? retVal : -retVal;</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineminus">-</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineminus">-  // clang-format off</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineminus">-  if (sortInfo-&gt;view-&gt;m_secondarySort == nsMsgViewSortType::byId)</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineminus">-    return (sortInfo-&gt;view-&gt;m_secondarySortOrder == nsMsgViewSortOrder::ascending &amp;&amp;</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineminus">-            (*p1)-&gt;id &gt;= (*p2)-&gt;id) ? 1 : -1;</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineminus">-  // clang-format on</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineminus">-  else</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineminus">-    return sortInfo-&gt;view-&gt;SecondarySort((*p1)-&gt;id, (*p1)-&gt;folder, (*p2)-&gt;id,</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineminus">-                                         (*p2)-&gt;folder, sortInfo);</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+    return sortInfo-&gt;view-&gt;SecondaryCompare(p1-&gt;id, p1-&gt;folder, p2-&gt;id,</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+                                            p2-&gt;folder, sortInfo);</span>
<a href="#l4.98"></a><span id="l4.98"> }</span>
<a href="#l4.99"></a><span id="l4.99"> </span>
<a href="#l4.100"></a><span id="l4.100"> int nsMsgDBView::FnSortIdUint32(const void *pItem1, const void *pItem2,</span>
<a href="#l4.101"></a><span id="l4.101">                                 void *privateData) {</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineminus">-  IdUint32 **p1 = (IdUint32 **)pItem1;</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineminus">-  IdUint32 **p2 = (IdUint32 **)pItem2;</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+  const IdUint32 *p1 = *((const IdUint32 **)pItem1);</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+  const IdUint32 *p2 = *((const IdUint32 **)pItem2);</span>
<a href="#l4.106"></a><span id="l4.106">   viewSortInfo *sortInfo = (viewSortInfo *)privateData;</span>
<a href="#l4.107"></a><span id="l4.107"> </span>
<a href="#l4.108"></a><span id="l4.108" class="difflineminus">-  if ((*p1)-&gt;dword &gt; (*p2)-&gt;dword)</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+  if (p1-&gt;dword &gt; p2-&gt;dword)</span>
<a href="#l4.110"></a><span id="l4.110">     return (sortInfo-&gt;ascendingSort) ? 1 : -1;</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineminus">-  else if ((*p1)-&gt;dword &lt; (*p2)-&gt;dword)</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineplus">+  else if (p1-&gt;dword &lt; p2-&gt;dword)</span>
<a href="#l4.113"></a><span id="l4.113">     return (sortInfo-&gt;ascendingSort) ? -1 : 1;</span>
<a href="#l4.114"></a><span id="l4.114"> </span>
<a href="#l4.115"></a><span id="l4.115">   // clang-format off</span>
<a href="#l4.116"></a><span id="l4.116">   if (sortInfo-&gt;view-&gt;m_secondarySort == nsMsgViewSortType::byId)</span>
<a href="#l4.117"></a><span id="l4.117">     return (sortInfo-&gt;view-&gt;m_secondarySortOrder == nsMsgViewSortOrder::ascending &amp;&amp;</span>
<a href="#l4.118"></a><span id="l4.118" class="difflineminus">-            (*p1)-&gt;id &gt;= (*p2)-&gt;id) ? 1 : -1;</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineplus">+            p1-&gt;id &gt;= p2-&gt;id) ? 1 : -1;</span>
<a href="#l4.120"></a><span id="l4.120">   // clang-format on</span>
<a href="#l4.121"></a><span id="l4.121">   else</span>
<a href="#l4.122"></a><span id="l4.122" class="difflineminus">-    return sortInfo-&gt;view-&gt;SecondarySort((*p1)-&gt;id, (*p1)-&gt;folder, (*p2)-&gt;id,</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineminus">-                                         (*p2)-&gt;folder, sortInfo);</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineplus">+    return sortInfo-&gt;view-&gt;SecondaryCompare(p1-&gt;id, p1-&gt;folder, p2-&gt;id,</span>
<a href="#l4.125"></a><span id="l4.125" class="difflineplus">+                                            p2-&gt;folder, sortInfo);</span>
<a href="#l4.126"></a><span id="l4.126"> }</span>
<a href="#l4.127"></a><span id="l4.127"> </span>
<a href="#l4.128"></a><span id="l4.128"> // XXX are these still correct?</span>
<a href="#l4.129"></a><span id="l4.129"> // To compensate for memory alignment required for systems such as HP-UX, these</span>
<a href="#l4.130"></a><span id="l4.130"> // values must be 4 bytes aligned. Don't break this when modifying the</span>
<a href="#l4.131"></a><span id="l4.131"> // constants.</span>
<a href="#l4.132"></a><span id="l4.132"> const int kMaxSubjectKey = 160;</span>
<a href="#l4.133"></a><span id="l4.133"> const int kMaxLocationKey = 160;  // Also used for account.</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineat">@@ -4035,74 +4016,72 @@ void nsMsgDBView::PushSort(const MsgView</span>
<a href="#l4.135"></a><span id="l4.135">   m_sortColumns.RemoveElement(newSort);</span>
<a href="#l4.136"></a><span id="l4.136">   m_sortColumns.InsertElementAt(0, newSort);</span>
<a href="#l4.137"></a><span id="l4.137">   if (m_sortColumns.Length() &gt; kMaxNumSortColumns)</span>
<a href="#l4.138"></a><span id="l4.138">     m_sortColumns.RemoveElementAt(kMaxNumSortColumns);</span>
<a href="#l4.139"></a><span id="l4.139"> }</span>
<a href="#l4.140"></a><span id="l4.140"> </span>
<a href="#l4.141"></a><span id="l4.141"> nsresult nsMsgDBView::GetCollationKey(nsIMsgDBHdr *msgHdr,</span>
<a href="#l4.142"></a><span id="l4.142">                                       nsMsgViewSortTypeValue sortType,</span>
<a href="#l4.143"></a><span id="l4.143" class="difflineminus">-                                      uint8_t **result, uint32_t *len,</span>
<a href="#l4.144"></a><span id="l4.144" class="difflineplus">+                                      nsTArray&lt;uint8_t&gt; &amp;result,</span>
<a href="#l4.145"></a><span id="l4.145">                                       nsIMsgCustomColumnHandler *colHandler) {</span>
<a href="#l4.146"></a><span id="l4.146">   nsresult rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l4.147"></a><span id="l4.147">   NS_ENSURE_ARG_POINTER(msgHdr);</span>
<a href="#l4.148"></a><span id="l4.148" class="difflineminus">-  NS_ENSURE_ARG_POINTER(result);</span>
<a href="#l4.149"></a><span id="l4.149"> </span>
<a href="#l4.150"></a><span id="l4.150">   switch (sortType) {</span>
<a href="#l4.151"></a><span id="l4.151">     case nsMsgViewSortType::bySubject:</span>
<a href="#l4.152"></a><span id="l4.152" class="difflineminus">-      rv = msgHdr-&gt;GetSubjectCollationKey(len, result);</span>
<a href="#l4.153"></a><span id="l4.153" class="difflineplus">+      rv = msgHdr-&gt;GetSubjectCollationKey(result);</span>
<a href="#l4.154"></a><span id="l4.154">       break;</span>
<a href="#l4.155"></a><span id="l4.155">     case nsMsgViewSortType::byLocation:</span>
<a href="#l4.156"></a><span id="l4.156" class="difflineminus">-      rv = GetLocationCollationKey(msgHdr, result, len);</span>
<a href="#l4.157"></a><span id="l4.157" class="difflineplus">+      rv = GetLocationCollationKey(msgHdr, result);</span>
<a href="#l4.158"></a><span id="l4.158">       break;</span>
<a href="#l4.159"></a><span id="l4.159">     case nsMsgViewSortType::byRecipient: {</span>
<a href="#l4.160"></a><span id="l4.160">       nsString recipients;</span>
<a href="#l4.161"></a><span id="l4.161">       rv = FetchRecipients(msgHdr, recipients);</span>
<a href="#l4.162"></a><span id="l4.162">       if (NS_SUCCEEDED(rv)) {</span>
<a href="#l4.163"></a><span id="l4.163">         nsCOMPtr&lt;nsIMsgDatabase&gt; dbToUse = m_db;</span>
<a href="#l4.164"></a><span id="l4.164">         // Probably a search view.</span>
<a href="#l4.165"></a><span id="l4.165">         if (!dbToUse) {</span>
<a href="#l4.166"></a><span id="l4.166">           rv = GetDBForHeader(msgHdr, getter_AddRefs(dbToUse));</span>
<a href="#l4.167"></a><span id="l4.167">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.168"></a><span id="l4.168">         }</span>
<a href="#l4.169"></a><span id="l4.169" class="difflineminus">-</span>
<a href="#l4.170"></a><span id="l4.170" class="difflineminus">-        rv = dbToUse-&gt;CreateCollationKey(recipients, len, result);</span>
<a href="#l4.171"></a><span id="l4.171" class="difflineplus">+        rv = dbToUse-&gt;CreateCollationKey(recipients, result);</span>
<a href="#l4.172"></a><span id="l4.172">       }</span>
<a href="#l4.173"></a><span id="l4.173">       break;</span>
<a href="#l4.174"></a><span id="l4.174">     }</span>
<a href="#l4.175"></a><span id="l4.175">     case nsMsgViewSortType::byAuthor: {</span>
<a href="#l4.176"></a><span id="l4.176" class="difflineminus">-      rv = msgHdr-&gt;GetAuthorCollationKey(len, result);</span>
<a href="#l4.177"></a><span id="l4.177" class="difflineplus">+      rv = msgHdr-&gt;GetAuthorCollationKey(result);</span>
<a href="#l4.178"></a><span id="l4.178">       nsString author;</span>
<a href="#l4.179"></a><span id="l4.179">       rv = FetchAuthor(msgHdr, author);</span>
<a href="#l4.180"></a><span id="l4.180">       if (NS_SUCCEEDED(rv)) {</span>
<a href="#l4.181"></a><span id="l4.181">         nsCOMPtr&lt;nsIMsgDatabase&gt; dbToUse = m_db;</span>
<a href="#l4.182"></a><span id="l4.182">         // Probably a search view.</span>
<a href="#l4.183"></a><span id="l4.183">         if (!dbToUse) {</span>
<a href="#l4.184"></a><span id="l4.184">           rv = GetDBForHeader(msgHdr, getter_AddRefs(dbToUse));</span>
<a href="#l4.185"></a><span id="l4.185">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.186"></a><span id="l4.186">         }</span>
<a href="#l4.187"></a><span id="l4.187"> </span>
<a href="#l4.188"></a><span id="l4.188" class="difflineminus">-        rv = dbToUse-&gt;CreateCollationKey(author, len, result);</span>
<a href="#l4.189"></a><span id="l4.189" class="difflineplus">+        rv = dbToUse-&gt;CreateCollationKey(author, result);</span>
<a href="#l4.190"></a><span id="l4.190">       }</span>
<a href="#l4.191"></a><span id="l4.191">       break;</span>
<a href="#l4.192"></a><span id="l4.192">     }</span>
<a href="#l4.193"></a><span id="l4.193">     case nsMsgViewSortType::byAccount:</span>
<a href="#l4.194"></a><span id="l4.194">     case nsMsgViewSortType::byTags: {</span>
<a href="#l4.195"></a><span id="l4.195">       nsString str;</span>
<a href="#l4.196"></a><span id="l4.196">       nsCOMPtr&lt;nsIMsgDatabase&gt; dbToUse = m_db;</span>
<a href="#l4.197"></a><span id="l4.197"> </span>
<a href="#l4.198"></a><span id="l4.198">       if (!dbToUse)</span>
<a href="#l4.199"></a><span id="l4.199">         // Probably a search view.</span>
<a href="#l4.200"></a><span id="l4.200">         GetDBForViewIndex(0, getter_AddRefs(dbToUse));</span>
<a href="#l4.201"></a><span id="l4.201"> </span>
<a href="#l4.202"></a><span id="l4.202">       rv = (sortType == nsMsgViewSortType::byAccount)</span>
<a href="#l4.203"></a><span id="l4.203">                ? FetchAccount(msgHdr, str)</span>
<a href="#l4.204"></a><span id="l4.204">                : FetchTags(msgHdr, str);</span>
<a href="#l4.205"></a><span id="l4.205">       if (NS_SUCCEEDED(rv) &amp;&amp; dbToUse)</span>
<a href="#l4.206"></a><span id="l4.206" class="difflineminus">-        rv = dbToUse-&gt;CreateCollationKey(str, len, result);</span>
<a href="#l4.207"></a><span id="l4.207" class="difflineplus">+        rv = dbToUse-&gt;CreateCollationKey(str, result);</span>
<a href="#l4.208"></a><span id="l4.208"> </span>
<a href="#l4.209"></a><span id="l4.209">       break;</span>
<a href="#l4.210"></a><span id="l4.210">     }</span>
<a href="#l4.211"></a><span id="l4.211">     case nsMsgViewSortType::byCustom:</span>
<a href="#l4.212"></a><span id="l4.212">       if (colHandler != nullptr) {</span>
<a href="#l4.213"></a><span id="l4.213">         nsAutoString strKey;</span>
<a href="#l4.214"></a><span id="l4.214">         rv = colHandler-&gt;GetSortStringForRow(msgHdr, strKey);</span>
<a href="#l4.215"></a><span id="l4.215">         NS_ASSERTION(NS_SUCCEEDED(rv),</span>
<a href="#l4.216"></a><span id="l4.216" class="difflineat">@@ -4110,17 +4089,17 @@ nsresult nsMsgDBView::GetCollationKey(ns</span>
<a href="#l4.217"></a><span id="l4.217">         nsAutoString strTemp(strKey);</span>
<a href="#l4.218"></a><span id="l4.218"> </span>
<a href="#l4.219"></a><span id="l4.219">         nsCOMPtr&lt;nsIMsgDatabase&gt; dbToUse = m_db;</span>
<a href="#l4.220"></a><span id="l4.220">         // Probably a search view.</span>
<a href="#l4.221"></a><span id="l4.221">         if (!dbToUse) {</span>
<a href="#l4.222"></a><span id="l4.222">           rv = GetDBForHeader(msgHdr, getter_AddRefs(dbToUse));</span>
<a href="#l4.223"></a><span id="l4.223">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.224"></a><span id="l4.224">         }</span>
<a href="#l4.225"></a><span id="l4.225" class="difflineminus">-        rv = dbToUse-&gt;CreateCollationKey(strKey, len, result);</span>
<a href="#l4.226"></a><span id="l4.226" class="difflineplus">+        rv = dbToUse-&gt;CreateCollationKey(strKey, result);</span>
<a href="#l4.227"></a><span id="l4.227">       } else {</span>
<a href="#l4.228"></a><span id="l4.228">         NS_ERROR(</span>
<a href="#l4.229"></a><span id="l4.229">             &quot;should not be here (Sort Type: byCustom (String), but no custom &quot;</span>
<a href="#l4.230"></a><span id="l4.230">             &quot;handler)&quot;);</span>
<a href="#l4.231"></a><span id="l4.231">         rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l4.232"></a><span id="l4.232">       }</span>
<a href="#l4.233"></a><span id="l4.233">       break;</span>
<a href="#l4.234"></a><span id="l4.234">     case nsMsgViewSortType::byCorrespondent: {</span>
<a href="#l4.235"></a><span id="l4.235" class="difflineat">@@ -4133,53 +4112,52 @@ nsresult nsMsgDBView::GetCollationKey(ns</span>
<a href="#l4.236"></a><span id="l4.236">       if (NS_SUCCEEDED(rv)) {</span>
<a href="#l4.237"></a><span id="l4.237">         nsCOMPtr&lt;nsIMsgDatabase&gt; dbToUse = m_db;</span>
<a href="#l4.238"></a><span id="l4.238">         // Probably a search view.</span>
<a href="#l4.239"></a><span id="l4.239">         if (!dbToUse) {</span>
<a href="#l4.240"></a><span id="l4.240">           rv = GetDBForHeader(msgHdr, getter_AddRefs(dbToUse));</span>
<a href="#l4.241"></a><span id="l4.241">           NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.242"></a><span id="l4.242">         }</span>
<a href="#l4.243"></a><span id="l4.243"> </span>
<a href="#l4.244"></a><span id="l4.244" class="difflineminus">-        rv = dbToUse-&gt;CreateCollationKey(value, len, result);</span>
<a href="#l4.245"></a><span id="l4.245" class="difflineplus">+        rv = dbToUse-&gt;CreateCollationKey(value, result);</span>
<a href="#l4.246"></a><span id="l4.246">       }</span>
<a href="#l4.247"></a><span id="l4.247">       break;</span>
<a href="#l4.248"></a><span id="l4.248">     }</span>
<a href="#l4.249"></a><span id="l4.249">     default:</span>
<a href="#l4.250"></a><span id="l4.250">       rv = NS_ERROR_UNEXPECTED;</span>
<a href="#l4.251"></a><span id="l4.251">       break;</span>
<a href="#l4.252"></a><span id="l4.252">   }</span>
<a href="#l4.253"></a><span id="l4.253"> </span>
<a href="#l4.254"></a><span id="l4.254">   // Bailing out with failure will stop the sort and leave us in</span>
<a href="#l4.255"></a><span id="l4.255">   // a bad state. Try to continue on, instead.</span>
<a href="#l4.256"></a><span id="l4.256">   NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to get the collation key&quot;);</span>
<a href="#l4.257"></a><span id="l4.257">   if (NS_FAILED(rv)) {</span>
<a href="#l4.258"></a><span id="l4.258" class="difflineminus">-    *result = nullptr;</span>
<a href="#l4.259"></a><span id="l4.259" class="difflineminus">-    *len = 0;</span>
<a href="#l4.260"></a><span id="l4.260" class="difflineplus">+    result.Clear();</span>
<a href="#l4.261"></a><span id="l4.261">   }</span>
<a href="#l4.262"></a><span id="l4.262"> </span>
<a href="#l4.263"></a><span id="l4.263">   return NS_OK;</span>
<a href="#l4.264"></a><span id="l4.264"> }</span>
<a href="#l4.265"></a><span id="l4.265"> </span>
<a href="#l4.266"></a><span id="l4.266"> // As the location collation key is created getting folder from the msgHdr,</span>
<a href="#l4.267"></a><span id="l4.267"> // it is defined in this file and not from the db.</span>
<a href="#l4.268"></a><span id="l4.268"> nsresult nsMsgDBView::GetLocationCollationKey(nsIMsgDBHdr *msgHdr,</span>
<a href="#l4.269"></a><span id="l4.269" class="difflineminus">-                                              uint8_t **result, uint32_t *len) {</span>
<a href="#l4.270"></a><span id="l4.270" class="difflineplus">+                                              nsTArray&lt;uint8_t&gt; &amp;result) {</span>
<a href="#l4.271"></a><span id="l4.271">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l4.272"></a><span id="l4.272"> </span>
<a href="#l4.273"></a><span id="l4.273">   nsresult rv = msgHdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l4.274"></a><span id="l4.274">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.275"></a><span id="l4.275">   nsCOMPtr&lt;nsIMsgDatabase&gt; dbToUse;</span>
<a href="#l4.276"></a><span id="l4.276">   rv = folder-&gt;GetMsgDatabase(getter_AddRefs(dbToUse));</span>
<a href="#l4.277"></a><span id="l4.277">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.278"></a><span id="l4.278"> </span>
<a href="#l4.279"></a><span id="l4.279">   nsString locationString;</span>
<a href="#l4.280"></a><span id="l4.280">   rv = folder-&gt;GetPrettyName(locationString);</span>
<a href="#l4.281"></a><span id="l4.281">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.282"></a><span id="l4.282"> </span>
<a href="#l4.283"></a><span id="l4.283" class="difflineminus">-  return dbToUse-&gt;CreateCollationKey(locationString, len, result);</span>
<a href="#l4.284"></a><span id="l4.284" class="difflineplus">+  return dbToUse-&gt;CreateCollationKey(locationString, result);</span>
<a href="#l4.285"></a><span id="l4.285"> }</span>
<a href="#l4.286"></a><span id="l4.286"> </span>
<a href="#l4.287"></a><span id="l4.287"> nsresult nsMsgDBView::SaveSortInfo(nsMsgViewSortTypeValue sortType,</span>
<a href="#l4.288"></a><span id="l4.288">                                    nsMsgViewSortOrderValue sortOrder) {</span>
<a href="#l4.289"></a><span id="l4.289">   if (m_viewFolder) {</span>
<a href="#l4.290"></a><span id="l4.290">     nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l4.291"></a><span id="l4.291">     nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l4.292"></a><span id="l4.292">     nsresult rv = m_viewFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo),</span>
<a href="#l4.293"></a><span id="l4.293" class="difflineat">@@ -4238,34 +4216,29 @@ void nsMsgDBView::EnsureCustomColumnsVal</span>
<a href="#l4.294"></a><span id="l4.294">       // There are only two...</span>
<a href="#l4.295"></a><span id="l4.295">       if (i == 0 &amp;&amp; m_sortType != nsMsgViewSortType::byCustom)</span>
<a href="#l4.296"></a><span id="l4.296">         SetCurCustomColumn(EmptyString());</span>
<a href="#l4.297"></a><span id="l4.297">       if (i == 1) m_secondaryCustomColumn.Truncate();</span>
<a href="#l4.298"></a><span id="l4.298">     }</span>
<a href="#l4.299"></a><span id="l4.299">   }</span>
<a href="#l4.300"></a><span id="l4.300"> }</span>
<a href="#l4.301"></a><span id="l4.301"> </span>
<a href="#l4.302"></a><span id="l4.302" class="difflineminus">-int32_t nsMsgDBView::SecondarySort(nsMsgKey key1, nsISupports *supports1,</span>
<a href="#l4.303"></a><span id="l4.303" class="difflineminus">-                                   nsMsgKey key2, nsISupports *supports2,</span>
<a href="#l4.304"></a><span id="l4.304" class="difflineminus">-                                   viewSortInfo *comparisonContext) {</span>
<a href="#l4.305"></a><span id="l4.305" class="difflineplus">+int32_t nsMsgDBView::SecondaryCompare(nsMsgKey key1, nsIMsgFolder *folder1,</span>
<a href="#l4.306"></a><span id="l4.306" class="difflineplus">+                                      nsMsgKey key2, nsIMsgFolder *folder2,</span>
<a href="#l4.307"></a><span id="l4.307" class="difflineplus">+                                      viewSortInfo *comparisonContext) {</span>
<a href="#l4.308"></a><span id="l4.308">   // We need to make sure that in the case of the secondary sort field also</span>
<a href="#l4.309"></a><span id="l4.309">   // matching, we don't recurse.</span>
<a href="#l4.310"></a><span id="l4.310">   if (comparisonContext-&gt;isSecondarySort) return key1 &gt; key2;</span>
<a href="#l4.311"></a><span id="l4.311"> </span>
<a href="#l4.312"></a><span id="l4.312" class="difflineminus">-  nsCOMPtr&lt;nsIMsgFolder&gt; folder1, folder2;</span>
<a href="#l4.313"></a><span id="l4.313">   nsCOMPtr&lt;nsIMsgDBHdr&gt; hdr1, hdr2;</span>
<a href="#l4.314"></a><span id="l4.314" class="difflineminus">-  folder1 = do_QueryInterface(supports1);</span>
<a href="#l4.315"></a><span id="l4.315" class="difflineminus">-  folder2 = do_QueryInterface(supports2);</span>
<a href="#l4.316"></a><span id="l4.316">   nsresult rv = folder1-&gt;GetMessageHeader(key1, getter_AddRefs(hdr1));</span>
<a href="#l4.317"></a><span id="l4.317">   NS_ENSURE_SUCCESS(rv, 0);</span>
<a href="#l4.318"></a><span id="l4.318">   rv = folder2-&gt;GetMessageHeader(key2, getter_AddRefs(hdr2));</span>
<a href="#l4.319"></a><span id="l4.319">   NS_ENSURE_SUCCESS(rv, 0);</span>
<a href="#l4.320"></a><span id="l4.320" class="difflineminus">-  IdKeyPtr EntryInfo1, EntryInfo2;</span>
<a href="#l4.321"></a><span id="l4.321" class="difflineminus">-  EntryInfo1.key = nullptr;</span>
<a href="#l4.322"></a><span id="l4.322" class="difflineminus">-  EntryInfo2.key = nullptr;</span>
<a href="#l4.323"></a><span id="l4.323" class="difflineplus">+  IdKey EntryInfo1, EntryInfo2;</span>
<a href="#l4.324"></a><span id="l4.324"> </span>
<a href="#l4.325"></a><span id="l4.325">   uint16_t maxLen;</span>
<a href="#l4.326"></a><span id="l4.326">   eFieldType fieldType;</span>
<a href="#l4.327"></a><span id="l4.327">   nsMsgViewSortTypeValue sortType = comparisonContext-&gt;view-&gt;m_secondarySort;</span>
<a href="#l4.328"></a><span id="l4.328">   nsMsgViewSortOrderValue sortOrder =</span>
<a href="#l4.329"></a><span id="l4.329">       comparisonContext-&gt;view-&gt;m_secondarySortOrder;</span>
<a href="#l4.330"></a><span id="l4.330"> </span>
<a href="#l4.331"></a><span id="l4.331">   // Get the custom column handler for the *secondary* sort and pass it first</span>
<a href="#l4.332"></a><span id="l4.332" class="difflineat">@@ -4278,65 +4251,46 @@ int32_t nsMsgDBView::SecondarySort(nsMsg</span>
<a href="#l4.333"></a><span id="l4.333"> </span>
<a href="#l4.334"></a><span id="l4.334">   // The following may leave fieldType undefined.</span>
<a href="#l4.335"></a><span id="l4.335">   // In this case, we can return 0 right away since</span>
<a href="#l4.336"></a><span id="l4.336">   // it is the value returned in the default case of</span>
<a href="#l4.337"></a><span id="l4.337">   // switch (fieldType) statement below.</span>
<a href="#l4.338"></a><span id="l4.338">   rv = GetFieldTypeAndLenForSort(sortType, &amp;maxLen, &amp;fieldType, colHandler);</span>
<a href="#l4.339"></a><span id="l4.339">   NS_ENSURE_SUCCESS(rv, 0);</span>
<a href="#l4.340"></a><span id="l4.340"> </span>
<a href="#l4.341"></a><span id="l4.341" class="difflineminus">-  const void *pValue1 = &amp;EntryInfo1, *pValue2 = &amp;EntryInfo2;</span>
<a href="#l4.342"></a><span id="l4.342" class="difflineminus">-</span>
<a href="#l4.343"></a><span id="l4.343" class="difflineminus">-  int (*comparisonFun)(const void *pItem1, const void *pItem2,</span>
<a href="#l4.344"></a><span id="l4.344" class="difflineminus">-                       void *privateData) = nullptr;</span>
<a href="#l4.345"></a><span id="l4.345" class="difflineminus">-  int retStatus = 0;</span>
<a href="#l4.346"></a><span id="l4.346">   hdr1-&gt;GetMessageKey(&amp;EntryInfo1.id);</span>
<a href="#l4.347"></a><span id="l4.347">   hdr2-&gt;GetMessageKey(&amp;EntryInfo2.id);</span>
<a href="#l4.348"></a><span id="l4.348"> </span>
<a href="#l4.349"></a><span id="l4.349" class="difflineplus">+  // Set up new viewSortInfo data for our secondary comparison.</span>
<a href="#l4.350"></a><span id="l4.350" class="difflineplus">+  viewSortInfo ctx = *comparisonContext;</span>
<a href="#l4.351"></a><span id="l4.351" class="difflineplus">+  ctx.isSecondarySort = true;  // To avoid recursing back here!</span>
<a href="#l4.352"></a><span id="l4.352" class="difflineplus">+  ctx.ascendingSort = (sortOrder == nsMsgViewSortOrder::ascending);</span>
<a href="#l4.353"></a><span id="l4.353" class="difflineplus">+</span>
<a href="#l4.354"></a><span id="l4.354" class="difflineplus">+  // The comparison functions expect to be sorting pointers to entries.</span>
<a href="#l4.355"></a><span id="l4.355" class="difflineplus">+  const void *pValue1 = &amp;EntryInfo1, *pValue2 = &amp;EntryInfo2;</span>
<a href="#l4.356"></a><span id="l4.356" class="difflineplus">+</span>
<a href="#l4.357"></a><span id="l4.357">   switch (fieldType) {</span>
<a href="#l4.358"></a><span id="l4.358">     case kCollationKey:</span>
<a href="#l4.359"></a><span id="l4.359" class="difflineminus">-      rv = GetCollationKey(hdr1, sortType, &amp;EntryInfo1.key, &amp;EntryInfo1.dword,</span>
<a href="#l4.360"></a><span id="l4.360" class="difflineminus">-                           colHandler);</span>
<a href="#l4.361"></a><span id="l4.361" class="difflineplus">+      rv = GetCollationKey(hdr1, sortType, EntryInfo1.key, colHandler);</span>
<a href="#l4.362"></a><span id="l4.362">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.363"></a><span id="l4.363" class="difflineminus">-      comparisonFun = FnSortIdKeyPtr;</span>
<a href="#l4.364"></a><span id="l4.364" class="difflineminus">-      break;</span>
<a href="#l4.365"></a><span id="l4.365" class="difflineplus">+      rv = GetCollationKey(hdr2, sortType, EntryInfo2.key, colHandler);</span>
<a href="#l4.366"></a><span id="l4.366" class="difflineplus">+      NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.367"></a><span id="l4.367" class="difflineplus">+      return FnSortIdKey(&amp;pValue1, &amp;pValue2, &amp;ctx);</span>
<a href="#l4.368"></a><span id="l4.368">     case kU32:</span>
<a href="#l4.369"></a><span id="l4.369" class="difflineminus">-      if (sortType == nsMsgViewSortType::byId)</span>
<a href="#l4.370"></a><span id="l4.370" class="difflineplus">+      if (sortType == nsMsgViewSortType::byId) {</span>
<a href="#l4.371"></a><span id="l4.371">         EntryInfo1.dword = EntryInfo1.id;</span>
<a href="#l4.372"></a><span id="l4.372" class="difflineminus">-      else</span>
<a href="#l4.373"></a><span id="l4.373" class="difflineplus">+        EntryInfo2.dword = EntryInfo2.id;</span>
<a href="#l4.374"></a><span id="l4.374" class="difflineplus">+      } else {</span>
<a href="#l4.375"></a><span id="l4.375">         GetLongField(hdr1, sortType, &amp;EntryInfo1.dword, colHandler);</span>
<a href="#l4.376"></a><span id="l4.376" class="difflineminus">-</span>
<a href="#l4.377"></a><span id="l4.377" class="difflineminus">-      comparisonFun = FnSortIdUint32;</span>
<a href="#l4.378"></a><span id="l4.378" class="difflineminus">-      break;</span>
<a href="#l4.379"></a><span id="l4.379" class="difflineplus">+        GetLongField(hdr2, sortType, &amp;EntryInfo2.dword, colHandler);</span>
<a href="#l4.380"></a><span id="l4.380" class="difflineplus">+      }</span>
<a href="#l4.381"></a><span id="l4.381" class="difflineplus">+      return FnSortIdUint32(&amp;pValue1, &amp;pValue2, &amp;ctx);</span>
<a href="#l4.382"></a><span id="l4.382">     default:</span>
<a href="#l4.383"></a><span id="l4.383">       return 0;</span>
<a href="#l4.384"></a><span id="l4.384">   }</span>
<a href="#l4.385"></a><span id="l4.385" class="difflineminus">-</span>
<a href="#l4.386"></a><span id="l4.386" class="difflineminus">-  bool saveAscendingSort = comparisonContext-&gt;ascendingSort;</span>
<a href="#l4.387"></a><span id="l4.387" class="difflineminus">-  comparisonContext-&gt;isSecondarySort = true;</span>
<a href="#l4.388"></a><span id="l4.388" class="difflineminus">-  comparisonContext-&gt;ascendingSort =</span>
<a href="#l4.389"></a><span id="l4.389" class="difflineminus">-      (sortOrder == nsMsgViewSortOrder::ascending);</span>
<a href="#l4.390"></a><span id="l4.390" class="difflineminus">-  if (fieldType == kCollationKey) {</span>
<a href="#l4.391"></a><span id="l4.391" class="difflineminus">-    PR_FREEIF(EntryInfo2.key);</span>
<a href="#l4.392"></a><span id="l4.392" class="difflineminus">-    rv = GetCollationKey(hdr2, sortType, &amp;EntryInfo2.key, &amp;EntryInfo2.dword,</span>
<a href="#l4.393"></a><span id="l4.393" class="difflineminus">-                         colHandler);</span>
<a href="#l4.394"></a><span id="l4.394" class="difflineminus">-    NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.395"></a><span id="l4.395" class="difflineminus">-  } else if (fieldType == kU32) {</span>
<a href="#l4.396"></a><span id="l4.396" class="difflineminus">-    if (sortType == nsMsgViewSortType::byId)</span>
<a href="#l4.397"></a><span id="l4.397" class="difflineminus">-      EntryInfo2.dword = EntryInfo2.id;</span>
<a href="#l4.398"></a><span id="l4.398" class="difflineminus">-    else</span>
<a href="#l4.399"></a><span id="l4.399" class="difflineminus">-      GetLongField(hdr2, sortType, &amp;EntryInfo2.dword, colHandler);</span>
<a href="#l4.400"></a><span id="l4.400" class="difflineminus">-  }</span>
<a href="#l4.401"></a><span id="l4.401" class="difflineminus">-</span>
<a href="#l4.402"></a><span id="l4.402" class="difflineminus">-  retStatus = (*comparisonFun)(&amp;pValue1, &amp;pValue2, comparisonContext);</span>
<a href="#l4.403"></a><span id="l4.403" class="difflineminus">-</span>
<a href="#l4.404"></a><span id="l4.404" class="difflineminus">-  comparisonContext-&gt;isSecondarySort = false;</span>
<a href="#l4.405"></a><span id="l4.405" class="difflineminus">-  comparisonContext-&gt;ascendingSort = saveAscendingSort;</span>
<a href="#l4.406"></a><span id="l4.406" class="difflineminus">-</span>
<a href="#l4.407"></a><span id="l4.407" class="difflineminus">-  return retStatus;</span>
<a href="#l4.408"></a><span id="l4.408"> }</span>
<a href="#l4.409"></a><span id="l4.409"> </span>
<a href="#l4.410"></a><span id="l4.410"> NS_IMETHODIMP nsMsgDBView::Sort(nsMsgViewSortTypeValue sortType,</span>
<a href="#l4.411"></a><span id="l4.411">                                 nsMsgViewSortOrderValue sortOrder) {</span>
<a href="#l4.412"></a><span id="l4.412">   EnsureCustomColumnsValid();</span>
<a href="#l4.413"></a><span id="l4.413"> </span>
<a href="#l4.414"></a><span id="l4.414">   // If we're doing a stable sort, we can't just reverse the messages.</span>
<a href="#l4.415"></a><span id="l4.415">   // Check also that the custom column we're sorting on hasn't changed.</span>
<a href="#l4.416"></a><span id="l4.416" class="difflineat">@@ -4418,176 +4372,106 @@ NS_IMETHODIMP nsMsgDBView::Sort(nsMsgVie</span>
<a href="#l4.417"></a><span id="l4.417">   if (NS_FAILED(rv)) return NS_OK;</span>
<a href="#l4.418"></a><span id="l4.418"> </span>
<a href="#l4.419"></a><span id="l4.419">   nsTArray&lt;void *&gt; ptrs;</span>
<a href="#l4.420"></a><span id="l4.420">   uint32_t arraySize = GetSize();</span>
<a href="#l4.421"></a><span id="l4.421"> </span>
<a href="#l4.422"></a><span id="l4.422">   if (!arraySize) return NS_OK;</span>
<a href="#l4.423"></a><span id="l4.423"> </span>
<a href="#l4.424"></a><span id="l4.424">   nsCOMArray&lt;nsIMsgFolder&gt; *folders = GetFolders();</span>
<a href="#l4.425"></a><span id="l4.425" class="difflineminus">-</span>
<a href="#l4.426"></a><span id="l4.426" class="difflineminus">-  IdKey **pPtrBase = (IdKey **)PR_Malloc(arraySize * sizeof(IdKey *));</span>
<a href="#l4.427"></a><span id="l4.427" class="difflineminus">-  NS_ASSERTION(pPtrBase, &quot;out of memory, can't sort&quot;);</span>
<a href="#l4.428"></a><span id="l4.428" class="difflineminus">-  if (!pPtrBase) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l4.429"></a><span id="l4.429" class="difflineminus">-</span>
<a href="#l4.430"></a><span id="l4.430" class="difflineminus">-  // Remember this pointer so we can free it later.</span>
<a href="#l4.431"></a><span id="l4.431" class="difflineminus">-  ptrs.AppendElement((void *)pPtrBase);</span>
<a href="#l4.432"></a><span id="l4.432" class="difflineminus">-</span>
<a href="#l4.433"></a><span id="l4.433" class="difflineminus">-  // Build up the beast, so we can sort it.</span>
<a href="#l4.434"></a><span id="l4.434" class="difflineminus">-  uint32_t numSoFar = 0;</span>
<a href="#l4.435"></a><span id="l4.435" class="difflineminus">-  const uint32_t keyOffset = offsetof(IdKey, key);</span>
<a href="#l4.436"></a><span id="l4.436" class="difflineminus">-  // Calc max possible size needed for all the rest.</span>
<a href="#l4.437"></a><span id="l4.437" class="difflineminus">-  uint32_t maxSize = (keyOffset + maxLen) * (arraySize - numSoFar);</span>
<a href="#l4.438"></a><span id="l4.438" class="difflineminus">-</span>
<a href="#l4.439"></a><span id="l4.439" class="difflineminus">-  const uint32_t maxBlockSize = (uint32_t)0xf000L;</span>
<a href="#l4.440"></a><span id="l4.440" class="difflineminus">-  uint32_t allocSize = std::min(maxBlockSize, maxSize);</span>
<a href="#l4.441"></a><span id="l4.441" class="difflineminus">-  char *pTemp = (char *)PR_Malloc(allocSize);</span>
<a href="#l4.442"></a><span id="l4.442" class="difflineminus">-  NS_ASSERTION(pTemp, &quot;out of memory, can't sort&quot;);</span>
<a href="#l4.443"></a><span id="l4.443" class="difflineminus">-  if (!pTemp) {</span>
<a href="#l4.444"></a><span id="l4.444" class="difflineminus">-    FreeAll(&amp;ptrs);</span>
<a href="#l4.445"></a><span id="l4.445" class="difflineminus">-    return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l4.446"></a><span id="l4.446" class="difflineminus">-  }</span>
<a href="#l4.447"></a><span id="l4.447" class="difflineminus">-</span>
<a href="#l4.448"></a><span id="l4.448" class="difflineminus">-  // Remember this pointer so we can free it later.</span>
<a href="#l4.449"></a><span id="l4.449" class="difflineminus">-  ptrs.AppendElement(pTemp);</span>
<a href="#l4.450"></a><span id="l4.450" class="difflineminus">-</span>
<a href="#l4.451"></a><span id="l4.451" class="difflineminus">-  char *pBase = pTemp;</span>
<a href="#l4.452"></a><span id="l4.452" class="difflineminus">-  bool more = true;</span>
<a href="#l4.453"></a><span id="l4.453" class="difflineminus">-</span>
<a href="#l4.454"></a><span id="l4.454" class="difflineminus">-  nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l4.455"></a><span id="l4.455" class="difflineminus">-  uint8_t *keyValue = nullptr;</span>
<a href="#l4.456"></a><span id="l4.456" class="difflineminus">-  uint32_t longValue;</span>
<a href="#l4.457"></a><span id="l4.457" class="difflineminus">-  while (more &amp;&amp; numSoFar &lt; arraySize) {</span>
<a href="#l4.458"></a><span id="l4.458" class="difflineminus">-    nsMsgKey thisKey = m_keys[numSoFar];</span>
<a href="#l4.459"></a><span id="l4.459" class="difflineminus">-    if (sortType != nsMsgViewSortType::byId) {</span>
<a href="#l4.460"></a><span id="l4.460" class="difflineminus">-      rv = GetMsgHdrForViewIndex(numSoFar, getter_AddRefs(msgHdr));</span>
<a href="#l4.461"></a><span id="l4.461" class="difflineminus">-      NS_ASSERTION(NS_SUCCEEDED(rv) &amp;&amp; msgHdr, &quot;header not found&quot;);</span>
<a href="#l4.462"></a><span id="l4.462" class="difflineminus">-      if (NS_FAILED(rv) || !msgHdr) {</span>
<a href="#l4.463"></a><span id="l4.463" class="difflineminus">-        FreeAll(&amp;ptrs);</span>
<a href="#l4.464"></a><span id="l4.464" class="difflineminus">-        return NS_ERROR_UNEXPECTED;</span>
<a href="#l4.465"></a><span id="l4.465" class="difflineminus">-      }</span>
<a href="#l4.466"></a><span id="l4.466" class="difflineminus">-    } else {</span>
<a href="#l4.467"></a><span id="l4.467" class="difflineminus">-      msgHdr = nullptr;</span>
<a href="#l4.468"></a><span id="l4.468" class="difflineminus">-    }</span>
<a href="#l4.469"></a><span id="l4.469" class="difflineminus">-</span>
<a href="#l4.470"></a><span id="l4.470" class="difflineminus">-    // Could be a problem here if the ones that appear here are different than</span>
<a href="#l4.471"></a><span id="l4.471" class="difflineminus">-    // the ones already in the array.</span>
<a href="#l4.472"></a><span id="l4.472" class="difflineminus">-    uint32_t actualFieldLen = 0;</span>
<a href="#l4.473"></a><span id="l4.473" class="difflineminus">-</span>
<a href="#l4.474"></a><span id="l4.474" class="difflineminus">-    if (fieldType == kCollationKey) {</span>
<a href="#l4.475"></a><span id="l4.475" class="difflineminus">-      rv = GetCollationKey(msgHdr, sortType, &amp;keyValue, &amp;actualFieldLen,</span>
<a href="#l4.476"></a><span id="l4.476" class="difflineminus">-                           colHandler);</span>
<a href="#l4.477"></a><span id="l4.477" class="difflineminus">-      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.478"></a><span id="l4.478" class="difflineminus">-</span>
<a href="#l4.479"></a><span id="l4.479" class="difflineminus">-      longValue = actualFieldLen;</span>
<a href="#l4.480"></a><span id="l4.480" class="difflineminus">-    } else {</span>
<a href="#l4.481"></a><span id="l4.481" class="difflineminus">-      if (sortType == nsMsgViewSortType::byId) {</span>
<a href="#l4.482"></a><span id="l4.482" class="difflineminus">-        longValue = thisKey;</span>
<a href="#l4.483"></a><span id="l4.483" class="difflineminus">-      } else {</span>
<a href="#l4.484"></a><span id="l4.484" class="difflineminus">-        rv = GetLongField(msgHdr, sortType, &amp;longValue, colHandler);</span>
<a href="#l4.485"></a><span id="l4.485" class="difflineminus">-        NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.486"></a><span id="l4.486" class="difflineminus">-      }</span>
<a href="#l4.487"></a><span id="l4.487" class="difflineminus">-    }</span>
<a href="#l4.488"></a><span id="l4.488" class="difflineminus">-</span>
<a href="#l4.489"></a><span id="l4.489" class="difflineminus">-    // Check to see if this entry fits into the block we have allocated so far.</span>
<a href="#l4.490"></a><span id="l4.490" class="difflineminus">-    // pTemp - pBase = the space we have used so far.</span>
<a href="#l4.491"></a><span id="l4.491" class="difflineminus">-    // sizeof(EntryInfo) + fieldLen = space we need for this entry.</span>
<a href="#l4.492"></a><span id="l4.492" class="difflineminus">-    // allocSize = size of the current block.</span>
<a href="#l4.493"></a><span id="l4.493" class="difflineminus">-    if ((uint32_t)(pTemp - pBase) + (keyOffset + actualFieldLen) &gt;= allocSize) {</span>
<a href="#l4.494"></a><span id="l4.494" class="difflineminus">-      maxSize = (keyOffset + maxLen) * (arraySize - numSoFar);</span>
<a href="#l4.495"></a><span id="l4.495" class="difflineminus">-      allocSize = std::min(maxBlockSize, maxSize);</span>
<a href="#l4.496"></a><span id="l4.496" class="difflineminus">-      // Make sure allocSize is big enough for the current value.</span>
<a href="#l4.497"></a><span id="l4.497" class="difflineminus">-      allocSize = std::max(allocSize, keyOffset + actualFieldLen);</span>
<a href="#l4.498"></a><span id="l4.498" class="difflineminus">-      pTemp = (char *)PR_Malloc(allocSize);</span>
<a href="#l4.499"></a><span id="l4.499" class="difflineminus">-      NS_ASSERTION(pTemp, &quot;out of memory, can't sort&quot;);</span>
<a href="#l4.500"></a><span id="l4.500" class="difflineminus">-      if (!pTemp) {</span>
<a href="#l4.501"></a><span id="l4.501" class="difflineminus">-        FreeAll(&amp;ptrs);</span>
<a href="#l4.502"></a><span id="l4.502" class="difflineminus">-        return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l4.503"></a><span id="l4.503" class="difflineminus">-      }</span>
<a href="#l4.504"></a><span id="l4.504" class="difflineminus">-      pBase = pTemp;</span>
<a href="#l4.505"></a><span id="l4.505" class="difflineminus">-      // Remember this pointer so we can free it later.</span>
<a href="#l4.506"></a><span id="l4.506" class="difflineminus">-      ptrs.AppendElement(pTemp);</span>
<a href="#l4.507"></a><span id="l4.507" class="difflineminus">-    }</span>
<a href="#l4.508"></a><span id="l4.508" class="difflineminus">-</span>
<a href="#l4.509"></a><span id="l4.509" class="difflineminus">-    // Now store this entry away in the allocated memory.</span>
<a href="#l4.510"></a><span id="l4.510" class="difflineminus">-    IdKey *info = (IdKey *)pTemp;</span>
<a href="#l4.511"></a><span id="l4.511" class="difflineminus">-    pPtrBase[numSoFar] = info;</span>
<a href="#l4.512"></a><span id="l4.512" class="difflineminus">-    info-&gt;id = thisKey;</span>
<a href="#l4.513"></a><span id="l4.513" class="difflineminus">-    info-&gt;bits = m_flags[numSoFar];</span>
<a href="#l4.514"></a><span id="l4.514" class="difflineminus">-    info-&gt;dword = longValue;</span>
<a href="#l4.515"></a><span id="l4.515" class="difflineminus">-    // info-&gt;pad = 0;</span>
<a href="#l4.516"></a><span id="l4.516" class="difflineminus">-    info-&gt;folder = folders ? folders-&gt;ObjectAt(numSoFar) : m_folder.get();</span>
<a href="#l4.517"></a><span id="l4.517" class="difflineminus">-</span>
<a href="#l4.518"></a><span id="l4.518" class="difflineminus">-    memcpy(info-&gt;key, keyValue, actualFieldLen);</span>
<a href="#l4.519"></a><span id="l4.519" class="difflineminus">-    // In order to align memory for systems that require it, such as HP-UX,</span>
<a href="#l4.520"></a><span id="l4.520" class="difflineminus">-    // calculate the correct value to pad the actualFieldLen value.</span>
<a href="#l4.521"></a><span id="l4.521" class="difflineminus">-    const uint32_t align = sizeof(IdKey) - sizeof(IdUint32) - 1;</span>
<a href="#l4.522"></a><span id="l4.522" class="difflineminus">-    actualFieldLen = (actualFieldLen + align) &amp; ~align;</span>
<a href="#l4.523"></a><span id="l4.523" class="difflineminus">-</span>
<a href="#l4.524"></a><span id="l4.524" class="difflineminus">-    pTemp += keyOffset + actualFieldLen;</span>
<a href="#l4.525"></a><span id="l4.525" class="difflineminus">-    ++numSoFar;</span>
<a href="#l4.526"></a><span id="l4.526" class="difflineminus">-    PR_Free(keyValue);</span>
<a href="#l4.527"></a><span id="l4.527" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDatabase&gt; dbToUse = m_db;</span>
<a href="#l4.528"></a><span id="l4.528" class="difflineplus">+  // Probably a search view.</span>
<a href="#l4.529"></a><span id="l4.529" class="difflineplus">+  if (!dbToUse) {</span>
<a href="#l4.530"></a><span id="l4.530" class="difflineplus">+    GetDBForViewIndex(0, getter_AddRefs(dbToUse));</span>
<a href="#l4.531"></a><span id="l4.531" class="difflineplus">+    if (!dbToUse) return NS_ERROR_FAILURE;</span>
<a href="#l4.532"></a><span id="l4.532">   }</span>
<a href="#l4.533"></a><span id="l4.533"> </span>
<a href="#l4.534"></a><span id="l4.534">   viewSortInfo qsPrivateData;</span>
<a href="#l4.535"></a><span id="l4.535">   qsPrivateData.view = this;</span>
<a href="#l4.536"></a><span id="l4.536">   qsPrivateData.isSecondarySort = false;</span>
<a href="#l4.537"></a><span id="l4.537">   qsPrivateData.ascendingSort = (sortOrder == nsMsgViewSortOrder::ascending);</span>
<a href="#l4.538"></a><span id="l4.538" class="difflineminus">-</span>
<a href="#l4.539"></a><span id="l4.539" class="difflineminus">-  nsCOMPtr&lt;nsIMsgDatabase&gt; dbToUse = m_db;</span>
<a href="#l4.540"></a><span id="l4.540" class="difflineminus">-</span>
<a href="#l4.541"></a><span id="l4.541" class="difflineminus">-  // Probably a search view.</span>
<a href="#l4.542"></a><span id="l4.542" class="difflineminus">-  if (!dbToUse) GetDBForViewIndex(0, getter_AddRefs(dbToUse));</span>
<a href="#l4.543"></a><span id="l4.543" class="difflineminus">-</span>
<a href="#l4.544"></a><span id="l4.544">   qsPrivateData.db = dbToUse;</span>
<a href="#l4.545"></a><span id="l4.545" class="difflineminus">-  if (dbToUse) {</span>
<a href="#l4.546"></a><span id="l4.546" class="difflineminus">-    // Do the sort.</span>
<a href="#l4.547"></a><span id="l4.547" class="difflineminus">-    switch (fieldType) {</span>
<a href="#l4.548"></a><span id="l4.548" class="difflineminus">-      case kCollationKey:</span>
<a href="#l4.549"></a><span id="l4.549" class="difflineminus">-        NS_QuickSort(pPtrBase, numSoFar, sizeof(IdKey *), FnSortIdKey,</span>
<a href="#l4.550"></a><span id="l4.550" class="difflineminus">-                     &amp;qsPrivateData);</span>
<a href="#l4.551"></a><span id="l4.551" class="difflineminus">-        break;</span>
<a href="#l4.552"></a><span id="l4.552" class="difflineminus">-      case kU32:</span>
<a href="#l4.553"></a><span id="l4.553" class="difflineminus">-        NS_QuickSort(pPtrBase, numSoFar, sizeof(IdKey *), FnSortIdUint32,</span>
<a href="#l4.554"></a><span id="l4.554" class="difflineminus">-                     &amp;qsPrivateData);</span>
<a href="#l4.555"></a><span id="l4.555" class="difflineminus">-        break;</span>
<a href="#l4.556"></a><span id="l4.556" class="difflineminus">-      default:</span>
<a href="#l4.557"></a><span id="l4.557" class="difflineminus">-        NS_ERROR(&quot;not supposed to get here&quot;);</span>
<a href="#l4.558"></a><span id="l4.558" class="difflineminus">-        break;</span>
<a href="#l4.559"></a><span id="l4.559" class="difflineplus">+</span>
<a href="#l4.560"></a><span id="l4.560" class="difflineplus">+  switch (fieldType) {</span>
<a href="#l4.561"></a><span id="l4.561" class="difflineplus">+    case kCollationKey: {</span>
<a href="#l4.562"></a><span id="l4.562" class="difflineplus">+      // Sort on a non-numeric field. We'll be calculating a collation key for</span>
<a href="#l4.563"></a><span id="l4.563" class="difflineplus">+      // each message.</span>
<a href="#l4.564"></a><span id="l4.564" class="difflineplus">+      nsTArray&lt;IdKey&gt; entries;</span>
<a href="#l4.565"></a><span id="l4.565" class="difflineplus">+      entries.SetLength(arraySize);</span>
<a href="#l4.566"></a><span id="l4.566" class="difflineplus">+      nsTArray&lt;IdKey *&gt; pPtrBase;</span>
<a href="#l4.567"></a><span id="l4.567" class="difflineplus">+      pPtrBase.SetLength(arraySize);</span>
<a href="#l4.568"></a><span id="l4.568" class="difflineplus">+      for (uint32_t i = 0; i &lt; arraySize; ++i) {</span>
<a href="#l4.569"></a><span id="l4.569" class="difflineplus">+        IdKey *info = &amp;entries[i];</span>
<a href="#l4.570"></a><span id="l4.570" class="difflineplus">+        pPtrBase[i] = info;</span>
<a href="#l4.571"></a><span id="l4.571" class="difflineplus">+        info-&gt;id = m_keys[i];</span>
<a href="#l4.572"></a><span id="l4.572" class="difflineplus">+        info-&gt;bits = m_flags[i];</span>
<a href="#l4.573"></a><span id="l4.573" class="difflineplus">+        info-&gt;dword = 0;</span>
<a href="#l4.574"></a><span id="l4.574" class="difflineplus">+        info-&gt;folder = folders ? folders-&gt;ObjectAt(i) : m_folder.get();</span>
<a href="#l4.575"></a><span id="l4.575" class="difflineplus">+        nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l4.576"></a><span id="l4.576" class="difflineplus">+        rv = GetMsgHdrForViewIndex(i, getter_AddRefs(msgHdr));</span>
<a href="#l4.577"></a><span id="l4.577" class="difflineplus">+        NS_ASSERTION(NS_SUCCEEDED(rv) &amp;&amp; msgHdr, &quot;header not found&quot;);</span>
<a href="#l4.578"></a><span id="l4.578" class="difflineplus">+        NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.579"></a><span id="l4.579" class="difflineplus">+        rv = GetCollationKey(msgHdr, sortType, info-&gt;key, colHandler);</span>
<a href="#l4.580"></a><span id="l4.580" class="difflineplus">+        NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.581"></a><span id="l4.581" class="difflineplus">+      }</span>
<a href="#l4.582"></a><span id="l4.582" class="difflineplus">+      // Perform the sort.</span>
<a href="#l4.583"></a><span id="l4.583" class="difflineplus">+      NS_QuickSort(pPtrBase.Elements(), pPtrBase.Length(), sizeof(IdKey *),</span>
<a href="#l4.584"></a><span id="l4.584" class="difflineplus">+                   FnSortIdKey, &amp;qsPrivateData);</span>
<a href="#l4.585"></a><span id="l4.585" class="difflineplus">+      // Now update the view state to reflect the new order.</span>
<a href="#l4.586"></a><span id="l4.586" class="difflineplus">+      for (uint32_t i = 0; i &lt; arraySize; ++i) {</span>
<a href="#l4.587"></a><span id="l4.587" class="difflineplus">+        m_keys[i] = pPtrBase[i]-&gt;id;</span>
<a href="#l4.588"></a><span id="l4.588" class="difflineplus">+        m_flags[i] = pPtrBase[i]-&gt;bits;</span>
<a href="#l4.589"></a><span id="l4.589" class="difflineplus">+        if (folders) folders-&gt;ReplaceObjectAt(pPtrBase[i]-&gt;folder, i);</span>
<a href="#l4.590"></a><span id="l4.590" class="difflineplus">+      }</span>
<a href="#l4.591"></a><span id="l4.591" class="difflineplus">+      m_sortType = sortType;</span>
<a href="#l4.592"></a><span id="l4.592" class="difflineplus">+      m_sortOrder = sortOrder;</span>
<a href="#l4.593"></a><span id="l4.593" class="difflineplus">+      m_sortValid = true;</span>
<a href="#l4.594"></a><span id="l4.594" class="difflineplus">+      return NS_OK;</span>
<a href="#l4.595"></a><span id="l4.595">     }</span>
<a href="#l4.596"></a><span id="l4.596" class="difflineminus">-  }</span>
<a href="#l4.597"></a><span id="l4.597" class="difflineminus">-</span>
<a href="#l4.598"></a><span id="l4.598" class="difflineminus">-  // Now put the IDs into the array in proper order.</span>
<a href="#l4.599"></a><span id="l4.599" class="difflineminus">-  for (uint32_t i = 0; i &lt; numSoFar; i++) {</span>
<a href="#l4.600"></a><span id="l4.600" class="difflineminus">-    m_keys[i] = pPtrBase[i]-&gt;id;</span>
<a href="#l4.601"></a><span id="l4.601" class="difflineminus">-    m_flags[i] = pPtrBase[i]-&gt;bits;</span>
<a href="#l4.602"></a><span id="l4.602" class="difflineminus">-</span>
<a href="#l4.603"></a><span id="l4.603" class="difflineminus">-    if (folders) folders-&gt;ReplaceObjectAt(pPtrBase[i]-&gt;folder, i);</span>
<a href="#l4.604"></a><span id="l4.604" class="difflineminus">-  }</span>
<a href="#l4.605"></a><span id="l4.605" class="difflineminus">-</span>
<a href="#l4.606"></a><span id="l4.606" class="difflineminus">-  m_sortType = sortType;</span>
<a href="#l4.607"></a><span id="l4.607" class="difflineminus">-  m_sortOrder = sortOrder;</span>
<a href="#l4.608"></a><span id="l4.608" class="difflineminus">-</span>
<a href="#l4.609"></a><span id="l4.609" class="difflineminus">-  // Free all the memory we allocated.</span>
<a href="#l4.610"></a><span id="l4.610" class="difflineminus">-  FreeAll(&amp;ptrs);</span>
<a href="#l4.611"></a><span id="l4.611" class="difflineminus">-</span>
<a href="#l4.612"></a><span id="l4.612" class="difflineminus">-  m_sortValid = true;</span>
<a href="#l4.613"></a><span id="l4.613" class="difflineminus">-  // m_db-&gt;SetSortInfo(sortType, sortOrder);</span>
<a href="#l4.614"></a><span id="l4.614" class="difflineminus">-</span>
<a href="#l4.615"></a><span id="l4.615" class="difflineminus">-  return NS_OK;</span>
<a href="#l4.616"></a><span id="l4.616" class="difflineminus">-}</span>
<a href="#l4.617"></a><span id="l4.617" class="difflineminus">-</span>
<a href="#l4.618"></a><span id="l4.618" class="difflineminus">-void nsMsgDBView::FreeAll(nsTArray&lt;void *&gt; *ptrs) {</span>
<a href="#l4.619"></a><span id="l4.619" class="difflineminus">-  int32_t i;</span>
<a href="#l4.620"></a><span id="l4.620" class="difflineminus">-  int32_t count = (int32_t)ptrs-&gt;Length();</span>
<a href="#l4.621"></a><span id="l4.621" class="difflineminus">-  if (count == 0) return;</span>
<a href="#l4.622"></a><span id="l4.622" class="difflineminus">-</span>
<a href="#l4.623"></a><span id="l4.623" class="difflineminus">-  for (i = (count - 1); i &gt;= 0; i--) PR_Free((void *)ptrs-&gt;ElementAt(i));</span>
<a href="#l4.624"></a><span id="l4.624" class="difflineminus">-</span>
<a href="#l4.625"></a><span id="l4.625" class="difflineminus">-  ptrs-&gt;Clear();</span>
<a href="#l4.626"></a><span id="l4.626" class="difflineplus">+    case kU32: {</span>
<a href="#l4.627"></a><span id="l4.627" class="difflineplus">+      // Sort on a numeric field.</span>
<a href="#l4.628"></a><span id="l4.628" class="difflineplus">+      nsTArray&lt;IdUint32&gt; entries;</span>
<a href="#l4.629"></a><span id="l4.629" class="difflineplus">+      entries.SetLength(arraySize);</span>
<a href="#l4.630"></a><span id="l4.630" class="difflineplus">+      nsTArray&lt;IdUint32 *&gt; pPtrBase;</span>
<a href="#l4.631"></a><span id="l4.631" class="difflineplus">+      pPtrBase.SetLength(arraySize);</span>
<a href="#l4.632"></a><span id="l4.632" class="difflineplus">+      for (uint32_t i = 0; i &lt; arraySize; ++i) {</span>
<a href="#l4.633"></a><span id="l4.633" class="difflineplus">+        IdUint32 *info = &amp;entries[i];</span>
<a href="#l4.634"></a><span id="l4.634" class="difflineplus">+        pPtrBase[i] = info;</span>
<a href="#l4.635"></a><span id="l4.635" class="difflineplus">+        info-&gt;id = m_keys[i];</span>
<a href="#l4.636"></a><span id="l4.636" class="difflineplus">+        info-&gt;bits = m_flags[i];</span>
<a href="#l4.637"></a><span id="l4.637" class="difflineplus">+        info-&gt;folder = folders ? folders-&gt;ObjectAt(i) : m_folder.get();</span>
<a href="#l4.638"></a><span id="l4.638" class="difflineplus">+        if (sortType == nsMsgViewSortType::byId) {</span>
<a href="#l4.639"></a><span id="l4.639" class="difflineplus">+          info-&gt;dword = info-&gt;id;  // No msgHdr required.</span>
<a href="#l4.640"></a><span id="l4.640" class="difflineplus">+        } else {</span>
<a href="#l4.641"></a><span id="l4.641" class="difflineplus">+          nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l4.642"></a><span id="l4.642" class="difflineplus">+          rv = GetMsgHdrForViewIndex(i, getter_AddRefs(msgHdr));</span>
<a href="#l4.643"></a><span id="l4.643" class="difflineplus">+          NS_ASSERTION(NS_SUCCEEDED(rv) &amp;&amp; msgHdr, &quot;header not found&quot;);</span>
<a href="#l4.644"></a><span id="l4.644" class="difflineplus">+          NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.645"></a><span id="l4.645" class="difflineplus">+          rv = GetLongField(msgHdr, sortType, &amp;info-&gt;dword, colHandler);</span>
<a href="#l4.646"></a><span id="l4.646" class="difflineplus">+          NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.647"></a><span id="l4.647" class="difflineplus">+        }</span>
<a href="#l4.648"></a><span id="l4.648" class="difflineplus">+      }</span>
<a href="#l4.649"></a><span id="l4.649" class="difflineplus">+      // Perform the sort.</span>
<a href="#l4.650"></a><span id="l4.650" class="difflineplus">+      NS_QuickSort(pPtrBase.Elements(), pPtrBase.Length(), sizeof(IdUint32 *),</span>
<a href="#l4.651"></a><span id="l4.651" class="difflineplus">+                   FnSortIdUint32, &amp;qsPrivateData);</span>
<a href="#l4.652"></a><span id="l4.652" class="difflineplus">+      // Now update the view state to reflect the new order.</span>
<a href="#l4.653"></a><span id="l4.653" class="difflineplus">+      for (uint32_t i = 0; i &lt; arraySize; ++i) {</span>
<a href="#l4.654"></a><span id="l4.654" class="difflineplus">+        m_keys[i] = pPtrBase[i]-&gt;id;</span>
<a href="#l4.655"></a><span id="l4.655" class="difflineplus">+        m_flags[i] = pPtrBase[i]-&gt;bits;</span>
<a href="#l4.656"></a><span id="l4.656" class="difflineplus">+        if (folders) folders-&gt;ReplaceObjectAt(pPtrBase[i]-&gt;folder, i);</span>
<a href="#l4.657"></a><span id="l4.657" class="difflineplus">+      }</span>
<a href="#l4.658"></a><span id="l4.658" class="difflineplus">+      m_sortType = sortType;</span>
<a href="#l4.659"></a><span id="l4.659" class="difflineplus">+      m_sortOrder = sortOrder;</span>
<a href="#l4.660"></a><span id="l4.660" class="difflineplus">+      m_sortValid = true;</span>
<a href="#l4.661"></a><span id="l4.661" class="difflineplus">+      return NS_OK;</span>
<a href="#l4.662"></a><span id="l4.662" class="difflineplus">+    }</span>
<a href="#l4.663"></a><span id="l4.663" class="difflineplus">+    default:</span>
<a href="#l4.664"></a><span id="l4.664" class="difflineplus">+      // If we get this far, we've got a bad fieldType.</span>
<a href="#l4.665"></a><span id="l4.665" class="difflineplus">+      return NS_ERROR_UNEXPECTED;</span>
<a href="#l4.666"></a><span id="l4.666" class="difflineplus">+  }</span>
<a href="#l4.667"></a><span id="l4.667"> }</span>
<a href="#l4.668"></a><span id="l4.668"> </span>
<a href="#l4.669"></a><span id="l4.669"> nsMsgViewIndex nsMsgDBView::GetIndexOfFirstDisplayedKeyInThread(</span>
<a href="#l4.670"></a><span id="l4.670">     nsIMsgThread *threadHdr, bool allowDummy) {</span>
<a href="#l4.671"></a><span id="l4.671">   nsMsgViewIndex retIndex = nsMsgViewIndex_None;</span>
<a href="#l4.672"></a><span id="l4.672">   uint32_t childIndex = 0;</span>
<a href="#l4.673"></a><span id="l4.673">   // We could speed up the unreadOnly view by starting our search with the first</span>
<a href="#l4.674"></a><span id="l4.674">   // unread message in the thread. Sometimes, that will be wrong, however, so</span>
<a href="#l4.675"></a><span id="l4.675" class="difflineat">@@ -5077,19 +4961,17 @@ nsMsgDBView::GetThreadContainingIndex(ns</span>
<a href="#l4.676"></a><span id="l4.676"> </span>
<a href="#l4.677"></a><span id="l4.677"> nsMsgViewIndex nsMsgDBView::GetIndexForThread(nsIMsgDBHdr *msgHdr) {</span>
<a href="#l4.678"></a><span id="l4.678">   // Take advantage of the fact that we're already sorted</span>
<a href="#l4.679"></a><span id="l4.679">   // and find the insert index via a binary search, though expanded threads</span>
<a href="#l4.680"></a><span id="l4.680">   // make that tricky.</span>
<a href="#l4.681"></a><span id="l4.681"> </span>
<a href="#l4.682"></a><span id="l4.682">   nsMsgViewIndex highIndex = m_keys.Length();</span>
<a href="#l4.683"></a><span id="l4.683">   nsMsgViewIndex lowIndex = 0;</span>
<a href="#l4.684"></a><span id="l4.684" class="difflineminus">-  IdKeyPtr EntryInfo1, EntryInfo2;</span>
<a href="#l4.685"></a><span id="l4.685" class="difflineminus">-  EntryInfo1.key = nullptr;</span>
<a href="#l4.686"></a><span id="l4.686" class="difflineminus">-  EntryInfo2.key = nullptr;</span>
<a href="#l4.687"></a><span id="l4.687" class="difflineplus">+  IdKey EntryInfo1, EntryInfo2;</span>
<a href="#l4.688"></a><span id="l4.688"> </span>
<a href="#l4.689"></a><span id="l4.689">   nsresult rv;</span>
<a href="#l4.690"></a><span id="l4.690">   uint16_t maxLen;</span>
<a href="#l4.691"></a><span id="l4.691">   eFieldType fieldType;</span>
<a href="#l4.692"></a><span id="l4.692"> </span>
<a href="#l4.693"></a><span id="l4.693">   // Get the custom column handler for the primary sort and pass it first</span>
<a href="#l4.694"></a><span id="l4.694">   // to GetFieldTypeAndLenForSort to get the fieldType and then either</span>
<a href="#l4.695"></a><span id="l4.695">   // GetCollationKey or GetLongField.</span>
<a href="#l4.696"></a><span id="l4.696" class="difflineat">@@ -5097,35 +4979,32 @@ nsMsgViewIndex nsMsgDBView::GetIndexForT</span>
<a href="#l4.697"></a><span id="l4.697"> </span>
<a href="#l4.698"></a><span id="l4.698">   // The following may leave fieldType undefined.</span>
<a href="#l4.699"></a><span id="l4.699">   // In this case, we can return highIndex right away since</span>
<a href="#l4.700"></a><span id="l4.700">   // it is the value returned in the default case of</span>
<a href="#l4.701"></a><span id="l4.701">   // switch (fieldType) statement below.</span>
<a href="#l4.702"></a><span id="l4.702">   rv = GetFieldTypeAndLenForSort(m_sortType, &amp;maxLen, &amp;fieldType, colHandler);</span>
<a href="#l4.703"></a><span id="l4.703">   NS_ENSURE_SUCCESS(rv, highIndex);</span>
<a href="#l4.704"></a><span id="l4.704"> </span>
<a href="#l4.705"></a><span id="l4.705" class="difflineminus">-  const void *pValue1 = &amp;EntryInfo1, *pValue2 = &amp;EntryInfo2;</span>
<a href="#l4.706"></a><span id="l4.706" class="difflineminus">-</span>
<a href="#l4.707"></a><span id="l4.707">   int retStatus = 0;</span>
<a href="#l4.708"></a><span id="l4.708">   msgHdr-&gt;GetMessageKey(&amp;EntryInfo1.id);</span>
<a href="#l4.709"></a><span id="l4.709">   msgHdr-&gt;GetFolder(&amp;EntryInfo1.folder);</span>
<a href="#l4.710"></a><span id="l4.710">   EntryInfo1.folder-&gt;Release();</span>
<a href="#l4.711"></a><span id="l4.711"> </span>
<a href="#l4.712"></a><span id="l4.712">   viewSortInfo comparisonContext;</span>
<a href="#l4.713"></a><span id="l4.713">   comparisonContext.view = this;</span>
<a href="#l4.714"></a><span id="l4.714">   comparisonContext.isSecondarySort = false;</span>
<a href="#l4.715"></a><span id="l4.715">   comparisonContext.ascendingSort =</span>
<a href="#l4.716"></a><span id="l4.716">       (m_sortOrder == nsMsgViewSortOrder::ascending);</span>
<a href="#l4.717"></a><span id="l4.717">   nsCOMPtr&lt;nsIMsgDatabase&gt; hdrDB;</span>
<a href="#l4.718"></a><span id="l4.718">   EntryInfo1.folder-&gt;GetMsgDatabase(getter_AddRefs(hdrDB));</span>
<a href="#l4.719"></a><span id="l4.719">   comparisonContext.db = hdrDB.get();</span>
<a href="#l4.720"></a><span id="l4.720">   switch (fieldType) {</span>
<a href="#l4.721"></a><span id="l4.721">     case kCollationKey:</span>
<a href="#l4.722"></a><span id="l4.722" class="difflineminus">-      rv = GetCollationKey(msgHdr, m_sortType, &amp;EntryInfo1.key,</span>
<a href="#l4.723"></a><span id="l4.723" class="difflineminus">-                           &amp;EntryInfo1.dword, colHandler);</span>
<a href="#l4.724"></a><span id="l4.724" class="difflineplus">+      rv = GetCollationKey(msgHdr, m_sortType, EntryInfo1.key, colHandler);</span>
<a href="#l4.725"></a><span id="l4.725">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.726"></a><span id="l4.726">       break;</span>
<a href="#l4.727"></a><span id="l4.727">     case kU32:</span>
<a href="#l4.728"></a><span id="l4.728">       if (m_sortType == nsMsgViewSortType::byId)</span>
<a href="#l4.729"></a><span id="l4.729">         EntryInfo1.dword = EntryInfo1.id;</span>
<a href="#l4.730"></a><span id="l4.730">       else</span>
<a href="#l4.731"></a><span id="l4.731">         GetLongField(msgHdr, m_sortType, &amp;EntryInfo1.dword, colHandler);</span>
<a href="#l4.732"></a><span id="l4.732"> </span>
<a href="#l4.733"></a><span id="l4.733" class="difflineat">@@ -5157,22 +5036,21 @@ nsMsgViewIndex nsMsgDBView::GetIndexForT</span>
<a href="#l4.734"></a><span id="l4.734">     if (!tryHdr) break;</span>
<a href="#l4.735"></a><span id="l4.735"> </span>
<a href="#l4.736"></a><span id="l4.736">     if (tryHdr == msgHdr) {</span>
<a href="#l4.737"></a><span id="l4.737">       NS_WARNING(&quot;didn't expect header to already be in view&quot;);</span>
<a href="#l4.738"></a><span id="l4.738">       highIndex = tryIndex;</span>
<a href="#l4.739"></a><span id="l4.739">       break;</span>
<a href="#l4.740"></a><span id="l4.740">     }</span>
<a href="#l4.741"></a><span id="l4.741"> </span>
<a href="#l4.742"></a><span id="l4.742" class="difflineplus">+    const void *pValue1 = &amp;EntryInfo1, *pValue2 = &amp;EntryInfo2;</span>
<a href="#l4.743"></a><span id="l4.743">     if (fieldType == kCollationKey) {</span>
<a href="#l4.744"></a><span id="l4.744" class="difflineminus">-      PR_FREEIF(EntryInfo2.key);</span>
<a href="#l4.745"></a><span id="l4.745" class="difflineminus">-      rv = GetCollationKey(tryHdr, m_sortType, &amp;EntryInfo2.key,</span>
<a href="#l4.746"></a><span id="l4.746" class="difflineminus">-                           &amp;EntryInfo2.dword, colHandler);</span>
<a href="#l4.747"></a><span id="l4.747" class="difflineplus">+      rv = GetCollationKey(tryHdr, m_sortType, EntryInfo2.key, colHandler);</span>
<a href="#l4.748"></a><span id="l4.748">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.749"></a><span id="l4.749" class="difflineminus">-      retStatus = FnSortIdKeyPtr(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l4.750"></a><span id="l4.750" class="difflineplus">+      retStatus = FnSortIdKey(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l4.751"></a><span id="l4.751">     } else if (fieldType == kU32) {</span>
<a href="#l4.752"></a><span id="l4.752">       if (m_sortType == nsMsgViewSortType::byId)</span>
<a href="#l4.753"></a><span id="l4.753">         EntryInfo2.dword = EntryInfo2.id;</span>
<a href="#l4.754"></a><span id="l4.754">       else</span>
<a href="#l4.755"></a><span id="l4.755">         GetLongField(tryHdr, m_sortType, &amp;EntryInfo2.dword, colHandler);</span>
<a href="#l4.756"></a><span id="l4.756"> </span>
<a href="#l4.757"></a><span id="l4.757">       retStatus = FnSortIdUint32(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l4.758"></a><span id="l4.758">     }</span>
<a href="#l4.759"></a><span id="l4.759" class="difflineat">@@ -5186,30 +5064,26 @@ nsMsgViewIndex nsMsgDBView::GetIndexForT</span>
<a href="#l4.760"></a><span id="l4.760">       highIndex = tryIndex;</span>
<a href="#l4.761"></a><span id="l4.761">       // We already made sure tryIndex was at a thread at the top of the loop.</span>
<a href="#l4.762"></a><span id="l4.762">     } else {</span>
<a href="#l4.763"></a><span id="l4.763">       lowIndex = tryIndex + 1;</span>
<a href="#l4.764"></a><span id="l4.764">       while (lowIndex &lt; GetSize() &amp;&amp; m_levels[lowIndex]) lowIndex++;</span>
<a href="#l4.765"></a><span id="l4.765">     }</span>
<a href="#l4.766"></a><span id="l4.766">   }</span>
<a href="#l4.767"></a><span id="l4.767"> </span>
<a href="#l4.768"></a><span id="l4.768" class="difflineminus">-  PR_Free(EntryInfo1.key);</span>
<a href="#l4.769"></a><span id="l4.769" class="difflineminus">-  PR_Free(EntryInfo2.key);</span>
<a href="#l4.770"></a><span id="l4.770">   return highIndex;</span>
<a href="#l4.771"></a><span id="l4.771"> }</span>
<a href="#l4.772"></a><span id="l4.772"> </span>
<a href="#l4.773"></a><span id="l4.773"> nsMsgViewIndex nsMsgDBView::GetInsertIndexHelper(</span>
<a href="#l4.774"></a><span id="l4.774">     nsIMsgDBHdr *msgHdr, nsTArray&lt;nsMsgKey&gt; &amp;keys,</span>
<a href="#l4.775"></a><span id="l4.775">     nsCOMArray&lt;nsIMsgFolder&gt; *folders, nsMsgViewSortOrderValue sortOrder,</span>
<a href="#l4.776"></a><span id="l4.776">     nsMsgViewSortTypeValue sortType) {</span>
<a href="#l4.777"></a><span id="l4.777">   nsMsgViewIndex highIndex = keys.Length();</span>
<a href="#l4.778"></a><span id="l4.778">   nsMsgViewIndex lowIndex = 0;</span>
<a href="#l4.779"></a><span id="l4.779" class="difflineminus">-  IdKeyPtr EntryInfo1, EntryInfo2;</span>
<a href="#l4.780"></a><span id="l4.780" class="difflineminus">-  EntryInfo1.key = nullptr;</span>
<a href="#l4.781"></a><span id="l4.781" class="difflineminus">-  EntryInfo2.key = nullptr;</span>
<a href="#l4.782"></a><span id="l4.782" class="difflineplus">+  IdKey EntryInfo1, EntryInfo2;</span>
<a href="#l4.783"></a><span id="l4.783"> </span>
<a href="#l4.784"></a><span id="l4.784">   nsresult rv;</span>
<a href="#l4.785"></a><span id="l4.785">   uint16_t maxLen;</span>
<a href="#l4.786"></a><span id="l4.786">   eFieldType fieldType;</span>
<a href="#l4.787"></a><span id="l4.787"> </span>
<a href="#l4.788"></a><span id="l4.788">   // Get the custom column handler for the primary sort and pass it first</span>
<a href="#l4.789"></a><span id="l4.789">   // to GetFieldTypeAndLenForSort to get the fieldType and then either</span>
<a href="#l4.790"></a><span id="l4.790">   // GetCollationKey or GetLongField.</span>
<a href="#l4.791"></a><span id="l4.791" class="difflineat">@@ -5237,20 +5111,19 @@ nsMsgViewIndex nsMsgDBView::GetInsertInd</span>
<a href="#l4.792"></a><span id="l4.792">   comparisonContext.ascendingSort =</span>
<a href="#l4.793"></a><span id="l4.793">       (sortOrder == nsMsgViewSortOrder::ascending);</span>
<a href="#l4.794"></a><span id="l4.794">   rv = EntryInfo1.folder-&gt;GetMsgDatabase(&amp;comparisonContext.db);</span>
<a href="#l4.795"></a><span id="l4.795">   NS_ENSURE_SUCCESS(rv, highIndex);</span>
<a href="#l4.796"></a><span id="l4.796">   comparisonContext.db-&gt;Release();</span>
<a href="#l4.797"></a><span id="l4.797"> </span>
<a href="#l4.798"></a><span id="l4.798">   switch (fieldType) {</span>
<a href="#l4.799"></a><span id="l4.799">     case kCollationKey:</span>
<a href="#l4.800"></a><span id="l4.800" class="difflineminus">-      rv = GetCollationKey(msgHdr, sortType, &amp;EntryInfo1.key, &amp;EntryInfo1.dword,</span>
<a href="#l4.801"></a><span id="l4.801" class="difflineminus">-                           colHandler);</span>
<a href="#l4.802"></a><span id="l4.802" class="difflineplus">+      rv = GetCollationKey(msgHdr, sortType, EntryInfo1.key, colHandler);</span>
<a href="#l4.803"></a><span id="l4.803">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.804"></a><span id="l4.804" class="difflineminus">-      comparisonFun = FnSortIdKeyPtr;</span>
<a href="#l4.805"></a><span id="l4.805" class="difflineplus">+      comparisonFun = FnSortIdKey;</span>
<a href="#l4.806"></a><span id="l4.806">       break;</span>
<a href="#l4.807"></a><span id="l4.807">     case kU32:</span>
<a href="#l4.808"></a><span id="l4.808">       if (sortType == nsMsgViewSortType::byId)</span>
<a href="#l4.809"></a><span id="l4.809">         EntryInfo1.dword = EntryInfo1.id;</span>
<a href="#l4.810"></a><span id="l4.810">       else</span>
<a href="#l4.811"></a><span id="l4.811">         GetLongField(msgHdr, sortType, &amp;EntryInfo1.dword, colHandler);</span>
<a href="#l4.812"></a><span id="l4.812"> </span>
<a href="#l4.813"></a><span id="l4.813">       comparisonFun = FnSortIdUint32;</span>
<a href="#l4.814"></a><span id="l4.814" class="difflineat">@@ -5264,19 +5137,17 @@ nsMsgViewIndex nsMsgDBView::GetInsertInd</span>
<a href="#l4.815"></a><span id="l4.815">     EntryInfo2.id = keys[tryIndex];</span>
<a href="#l4.816"></a><span id="l4.816">     EntryInfo2.folder = folders ? folders-&gt;ObjectAt(tryIndex) : m_folder.get();</span>
<a href="#l4.817"></a><span id="l4.817"> </span>
<a href="#l4.818"></a><span id="l4.818">     nsCOMPtr&lt;nsIMsgDBHdr&gt; tryHdr;</span>
<a href="#l4.819"></a><span id="l4.819">     EntryInfo2.folder-&gt;GetMessageHeader(EntryInfo2.id, getter_AddRefs(tryHdr));</span>
<a href="#l4.820"></a><span id="l4.820">     if (!tryHdr) break;</span>
<a href="#l4.821"></a><span id="l4.821"> </span>
<a href="#l4.822"></a><span id="l4.822">     if (fieldType == kCollationKey) {</span>
<a href="#l4.823"></a><span id="l4.823" class="difflineminus">-      PR_FREEIF(EntryInfo2.key);</span>
<a href="#l4.824"></a><span id="l4.824" class="difflineminus">-      rv = GetCollationKey(tryHdr, sortType, &amp;EntryInfo2.key, &amp;EntryInfo2.dword,</span>
<a href="#l4.825"></a><span id="l4.825" class="difflineminus">-                           colHandler);</span>
<a href="#l4.826"></a><span id="l4.826" class="difflineplus">+      rv = GetCollationKey(tryHdr, sortType, EntryInfo2.key, colHandler);</span>
<a href="#l4.827"></a><span id="l4.827">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.828"></a><span id="l4.828">     } else if (fieldType == kU32) {</span>
<a href="#l4.829"></a><span id="l4.829">       if (sortType == nsMsgViewSortType::byId) {</span>
<a href="#l4.830"></a><span id="l4.830">         EntryInfo2.dword = EntryInfo2.id;</span>
<a href="#l4.831"></a><span id="l4.831">       } else {</span>
<a href="#l4.832"></a><span id="l4.832">         GetLongField(tryHdr, sortType, &amp;EntryInfo2.dword, colHandler);</span>
<a href="#l4.833"></a><span id="l4.833">       }</span>
<a href="#l4.834"></a><span id="l4.834">     }</span>
<a href="#l4.835"></a><span id="l4.835" class="difflineat">@@ -5289,18 +5160,16 @@ nsMsgViewIndex nsMsgDBView::GetInsertInd</span>
<a href="#l4.836"></a><span id="l4.836"> </span>
<a href="#l4.837"></a><span id="l4.837">     if (retStatus &lt; 0) {</span>
<a href="#l4.838"></a><span id="l4.838">       highIndex = tryIndex;</span>
<a href="#l4.839"></a><span id="l4.839">     } else {</span>
<a href="#l4.840"></a><span id="l4.840">       lowIndex = tryIndex + 1;</span>
<a href="#l4.841"></a><span id="l4.841">     }</span>
<a href="#l4.842"></a><span id="l4.842">   }</span>
<a href="#l4.843"></a><span id="l4.843"> </span>
<a href="#l4.844"></a><span id="l4.844" class="difflineminus">-  PR_Free(EntryInfo1.key);</span>
<a href="#l4.845"></a><span id="l4.845" class="difflineminus">-  PR_Free(EntryInfo2.key);</span>
<a href="#l4.846"></a><span id="l4.846">   return highIndex;</span>
<a href="#l4.847"></a><span id="l4.847"> }</span>
<a href="#l4.848"></a><span id="l4.848"> </span>
<a href="#l4.849"></a><span id="l4.849"> nsMsgViewIndex nsMsgDBView::GetInsertIndex(nsIMsgDBHdr *msgHdr) {</span>
<a href="#l4.850"></a><span id="l4.850">   if (!GetSize()) return 0;</span>
<a href="#l4.851"></a><span id="l4.851"> </span>
<a href="#l4.852"></a><span id="l4.852">   if ((m_viewFlags &amp; nsMsgViewFlagsType::kThreadedDisplay) != 0 &amp;&amp;</span>
<a href="#l4.853"></a><span id="l4.853">       !(m_viewFlags &amp; nsMsgViewFlagsType::kGroupBySort) &amp;&amp;</span>
<a href="#l4.854"></a><span id="l4.854" class="difflineat">@@ -5660,19 +5529,17 @@ nsMsgViewIndex nsMsgDBView::GetThreadRoo</span>
<a href="#l4.855"></a><span id="l4.855">     return nsMsgViewIndex_None;</span>
<a href="#l4.856"></a><span id="l4.856">   }</span>
<a href="#l4.857"></a><span id="l4.857"> </span>
<a href="#l4.858"></a><span id="l4.858">   // Take advantage of the fact that we're already sorted</span>
<a href="#l4.859"></a><span id="l4.859">   // and find the thread root via a binary search.</span>
<a href="#l4.860"></a><span id="l4.860"> </span>
<a href="#l4.861"></a><span id="l4.861">   nsMsgViewIndex highIndex = m_keys.Length();</span>
<a href="#l4.862"></a><span id="l4.862">   nsMsgViewIndex lowIndex = 0;</span>
<a href="#l4.863"></a><span id="l4.863" class="difflineminus">-  IdKeyPtr EntryInfo1, EntryInfo2;</span>
<a href="#l4.864"></a><span id="l4.864" class="difflineminus">-  EntryInfo1.key = nullptr;</span>
<a href="#l4.865"></a><span id="l4.865" class="difflineminus">-  EntryInfo2.key = nullptr;</span>
<a href="#l4.866"></a><span id="l4.866" class="difflineplus">+  IdKey EntryInfo1, EntryInfo2;</span>
<a href="#l4.867"></a><span id="l4.867"> </span>
<a href="#l4.868"></a><span id="l4.868">   nsresult rv;</span>
<a href="#l4.869"></a><span id="l4.869">   uint16_t maxLen;</span>
<a href="#l4.870"></a><span id="l4.870">   eFieldType fieldType;</span>
<a href="#l4.871"></a><span id="l4.871"> </span>
<a href="#l4.872"></a><span id="l4.872">   // Get the custom column handler for the primary sort and pass it first</span>
<a href="#l4.873"></a><span id="l4.873">   // to GetFieldTypeAndLenForSort to get the fieldType and then either</span>
<a href="#l4.874"></a><span id="l4.874">   // GetCollationKey or GetLongField.</span>
<a href="#l4.875"></a><span id="l4.875" class="difflineat">@@ -5698,18 +5565,17 @@ nsMsgViewIndex nsMsgDBView::GetThreadRoo</span>
<a href="#l4.876"></a><span id="l4.876">   comparisonContext.ascendingSort =</span>
<a href="#l4.877"></a><span id="l4.877">       (m_sortOrder == nsMsgViewSortOrder::ascending);</span>
<a href="#l4.878"></a><span id="l4.878">   nsCOMPtr&lt;nsIMsgDatabase&gt; hdrDB;</span>
<a href="#l4.879"></a><span id="l4.879">   EntryInfo1.folder-&gt;GetMsgDatabase(getter_AddRefs(hdrDB));</span>
<a href="#l4.880"></a><span id="l4.880">   comparisonContext.db = hdrDB.get();</span>
<a href="#l4.881"></a><span id="l4.881"> </span>
<a href="#l4.882"></a><span id="l4.882">   switch (fieldType) {</span>
<a href="#l4.883"></a><span id="l4.883">     case kCollationKey:</span>
<a href="#l4.884"></a><span id="l4.884" class="difflineminus">-      rv = GetCollationKey(msgHdr, m_sortType, &amp;EntryInfo1.key,</span>
<a href="#l4.885"></a><span id="l4.885" class="difflineminus">-                           &amp;EntryInfo1.dword, colHandler);</span>
<a href="#l4.886"></a><span id="l4.886" class="difflineplus">+      rv = GetCollationKey(msgHdr, m_sortType, EntryInfo1.key, colHandler);</span>
<a href="#l4.887"></a><span id="l4.887">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.888"></a><span id="l4.888">       break;</span>
<a href="#l4.889"></a><span id="l4.889">     case kU32:</span>
<a href="#l4.890"></a><span id="l4.890">       if (m_sortType == nsMsgViewSortType::byId)</span>
<a href="#l4.891"></a><span id="l4.891">         EntryInfo1.dword = EntryInfo1.id;</span>
<a href="#l4.892"></a><span id="l4.892">       else</span>
<a href="#l4.893"></a><span id="l4.893">         GetLongField(msgHdr, m_sortType, &amp;EntryInfo1.dword, colHandler);</span>
<a href="#l4.894"></a><span id="l4.894"> </span>
<a href="#l4.895"></a><span id="l4.895" class="difflineat">@@ -5741,21 +5607,19 @@ nsMsgViewIndex nsMsgDBView::GetThreadRoo</span>
<a href="#l4.896"></a><span id="l4.896">     if (!tryHdr) break;</span>
<a href="#l4.897"></a><span id="l4.897"> </span>
<a href="#l4.898"></a><span id="l4.898">     if (tryHdr == msgHdr) {</span>
<a href="#l4.899"></a><span id="l4.899">       highIndex = tryIndex;</span>
<a href="#l4.900"></a><span id="l4.900">       break;</span>
<a href="#l4.901"></a><span id="l4.901">     }</span>
<a href="#l4.902"></a><span id="l4.902"> </span>
<a href="#l4.903"></a><span id="l4.903">     if (fieldType == kCollationKey) {</span>
<a href="#l4.904"></a><span id="l4.904" class="difflineminus">-      PR_FREEIF(EntryInfo2.key);</span>
<a href="#l4.905"></a><span id="l4.905" class="difflineminus">-      rv = GetCollationKey(tryHdr, m_sortType, &amp;EntryInfo2.key,</span>
<a href="#l4.906"></a><span id="l4.906" class="difflineminus">-                           &amp;EntryInfo2.dword, colHandler);</span>
<a href="#l4.907"></a><span id="l4.907" class="difflineplus">+      rv = GetCollationKey(tryHdr, m_sortType, EntryInfo2.key, colHandler);</span>
<a href="#l4.908"></a><span id="l4.908">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.909"></a><span id="l4.909" class="difflineminus">-      retStatus = FnSortIdKeyPtr(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l4.910"></a><span id="l4.910" class="difflineplus">+      retStatus = FnSortIdKey(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l4.911"></a><span id="l4.911">     } else if (fieldType == kU32) {</span>
<a href="#l4.912"></a><span id="l4.912">       if (m_sortType == nsMsgViewSortType::byId)</span>
<a href="#l4.913"></a><span id="l4.913">         EntryInfo2.dword = EntryInfo2.id;</span>
<a href="#l4.914"></a><span id="l4.914">       else</span>
<a href="#l4.915"></a><span id="l4.915">         GetLongField(tryHdr, m_sortType, &amp;EntryInfo2.dword, colHandler);</span>
<a href="#l4.916"></a><span id="l4.916"> </span>
<a href="#l4.917"></a><span id="l4.917">       retStatus = FnSortIdUint32(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l4.918"></a><span id="l4.918">     }</span>
<a href="#l4.919"></a><span id="l4.919" class="difflineat">@@ -5785,26 +5649,22 @@ nsMsgViewIndex nsMsgDBView::GetThreadRoo</span>
<a href="#l4.920"></a><span id="l4.920">       NS_WARNING(&quot;but find hdr did&quot;);</span>
<a href="#l4.921"></a><span id="l4.921">       printf(&quot;level of found hdr = %d\n&quot;, m_levels[highIndex]);</span>
<a href="#l4.922"></a><span id="l4.922">       ValidateSort();</span>
<a href="#l4.923"></a><span id="l4.923">     }</span>
<a href="#l4.924"></a><span id="l4.924"> #endif</span>
<a href="#l4.925"></a><span id="l4.925">     return highIndex;</span>
<a href="#l4.926"></a><span id="l4.926">   }</span>
<a href="#l4.927"></a><span id="l4.927"> </span>
<a href="#l4.928"></a><span id="l4.928" class="difflineminus">-  PR_Free(EntryInfo1.key);</span>
<a href="#l4.929"></a><span id="l4.929" class="difflineminus">-  PR_Free(EntryInfo2.key);</span>
<a href="#l4.930"></a><span id="l4.930">   return msgHdr == resultHdr ? highIndex : nsMsgViewIndex_None;</span>
<a href="#l4.931"></a><span id="l4.931"> }</span>
<a href="#l4.932"></a><span id="l4.932"> </span>
<a href="#l4.933"></a><span id="l4.933"> #ifdef DEBUG_David_Bienvenu</span>
<a href="#l4.934"></a><span id="l4.934"> </span>
<a href="#l4.935"></a><span id="l4.935" class="difflineminus">-void nsMsgDBView::InitEntryInfoForIndex(nsMsgViewIndex i, IdKeyPtr &amp;EntryInfo) {</span>
<a href="#l4.936"></a><span id="l4.936" class="difflineminus">-  EntryInfo.key = nullptr;</span>
<a href="#l4.937"></a><span id="l4.937" class="difflineminus">-</span>
<a href="#l4.938"></a><span id="l4.938" class="difflineplus">+void nsMsgDBView::InitEntryInfoForIndex(nsMsgViewIndex i, IdKey &amp;EntryInfo) {</span>
<a href="#l4.939"></a><span id="l4.939">   nsresult rv;</span>
<a href="#l4.940"></a><span id="l4.940">   uint16_t maxLen;</span>
<a href="#l4.941"></a><span id="l4.941">   eFieldType fieldType;</span>
<a href="#l4.942"></a><span id="l4.942"> </span>
<a href="#l4.943"></a><span id="l4.943">   // Get the custom column handler for the primary sort and pass it first</span>
<a href="#l4.944"></a><span id="l4.944">   // to GetFieldTypeAndLenForSort to get the fieldType and then either</span>
<a href="#l4.945"></a><span id="l4.945">   // GetCollationKey or GetLongField.</span>
<a href="#l4.946"></a><span id="l4.946">   nsIMsgCustomColumnHandler *colHandler = GetCurColumnHandler();</span>
<a href="#l4.947"></a><span id="l4.947" class="difflineat">@@ -5819,51 +5679,50 @@ void nsMsgDBView::InitEntryInfoForIndex(</span>
<a href="#l4.948"></a><span id="l4.948">   msgHdr-&gt;GetMessageKey(&amp;EntryInfo.id);</span>
<a href="#l4.949"></a><span id="l4.949">   msgHdr-&gt;GetFolder(&amp;EntryInfo.folder);</span>
<a href="#l4.950"></a><span id="l4.950">   EntryInfo.folder-&gt;Release();</span>
<a href="#l4.951"></a><span id="l4.951"> </span>
<a href="#l4.952"></a><span id="l4.952">   nsCOMPtr&lt;nsIMsgDatabase&gt; hdrDB;</span>
<a href="#l4.953"></a><span id="l4.953">   EntryInfo.folder-&gt;GetMsgDatabase(getter_AddRefs(hdrDB));</span>
<a href="#l4.954"></a><span id="l4.954">   switch (fieldType) {</span>
<a href="#l4.955"></a><span id="l4.955">     case kCollationKey:</span>
<a href="#l4.956"></a><span id="l4.956" class="difflineminus">-      PR_FREEIF(EntryInfo.key);</span>
<a href="#l4.957"></a><span id="l4.957" class="difflineminus">-      rv = GetCollationKey(msgHdr, m_sortType, &amp;EntryInfo.key, &amp;EntryInfo.dword,</span>
<a href="#l4.958"></a><span id="l4.958" class="difflineminus">-                           colHandler);</span>
<a href="#l4.959"></a><span id="l4.959" class="difflineplus">+      rv = GetCollationKey(msgHdr, m_sortType, EntryInfo.key, colHandler);</span>
<a href="#l4.960"></a><span id="l4.960">       NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to create collation key&quot;);</span>
<a href="#l4.961"></a><span id="l4.961">       break;</span>
<a href="#l4.962"></a><span id="l4.962">     case kU32:</span>
<a href="#l4.963"></a><span id="l4.963">       if (m_sortType == nsMsgViewSortType::byId)</span>
<a href="#l4.964"></a><span id="l4.964">         EntryInfo.dword = EntryInfo.id;</span>
<a href="#l4.965"></a><span id="l4.965">       else</span>
<a href="#l4.966"></a><span id="l4.966">         GetLongField(msgHdr, m_sortType, &amp;EntryInfo.dword, colHandler);</span>
<a href="#l4.967"></a><span id="l4.967"> </span>
<a href="#l4.968"></a><span id="l4.968">       break;</span>
<a href="#l4.969"></a><span id="l4.969">     default:</span>
<a href="#l4.970"></a><span id="l4.970">       NS_ERROR(&quot;invalid field type&quot;);</span>
<a href="#l4.971"></a><span id="l4.971">   }</span>
<a href="#l4.972"></a><span id="l4.972"> }</span>
<a href="#l4.973"></a><span id="l4.973"> </span>
<a href="#l4.974"></a><span id="l4.974"> void nsMsgDBView::ValidateSort() {</span>
<a href="#l4.975"></a><span id="l4.975" class="difflineminus">-  IdKeyPtr EntryInfo1, EntryInfo2;</span>
<a href="#l4.976"></a><span id="l4.976" class="difflineplus">+  IdKey EntryInfo1, EntryInfo2;</span>
<a href="#l4.977"></a><span id="l4.977">   nsCOMPtr&lt;nsIMsgDBHdr&gt; hdr1, hdr2;</span>
<a href="#l4.978"></a><span id="l4.978"> </span>
<a href="#l4.979"></a><span id="l4.979">   uint16_t maxLen;</span>
<a href="#l4.980"></a><span id="l4.980">   eFieldType fieldType;</span>
<a href="#l4.981"></a><span id="l4.981"> </span>
<a href="#l4.982"></a><span id="l4.982">   // Get the custom column handler for the primary sort and pass it first</span>
<a href="#l4.983"></a><span id="l4.983">   // to GetFieldTypeAndLenForSort to get the fieldType and then either</span>
<a href="#l4.984"></a><span id="l4.984">   // GetCollationKey or GetLongField.</span>
<a href="#l4.985"></a><span id="l4.985">   nsIMsgCustomColumnHandler *colHandler = GetCurColumnHandler();</span>
<a href="#l4.986"></a><span id="l4.986"> </span>
<a href="#l4.987"></a><span id="l4.987">   // It is not entirely clear what we should do since,</span>
<a href="#l4.988"></a><span id="l4.988">   // if fieldType is not available, there is no way to know</span>
<a href="#l4.989"></a><span id="l4.989">   // how to compare the field to check for sorting.</span>
<a href="#l4.990"></a><span id="l4.990">   // So we bomb out here. It is OK since this is debug code</span>
<a href="#l4.991"></a><span id="l4.991">   // inside  #ifdef DEBUG_David_Bienvenu</span>
<a href="#l4.992"></a><span id="l4.992" class="difflineminus">-  rv = GetFieldTypeAndLenForSort(m_sortType, &amp;maxLen, &amp;fieldType, colHandler);</span>
<a href="#l4.993"></a><span id="l4.993" class="difflineplus">+  nsresult rv =</span>
<a href="#l4.994"></a><span id="l4.994" class="difflineplus">+      GetFieldTypeAndLenForSort(m_sortType, &amp;maxLen, &amp;fieldType, colHandler);</span>
<a href="#l4.995"></a><span id="l4.995">   NS_ASSERTION(NS_SUCCEEDED(rv), &quot;failed to obtain fieldType&quot;);</span>
<a href="#l4.996"></a><span id="l4.996"> </span>
<a href="#l4.997"></a><span id="l4.997">   viewSortInfo comparisonContext;</span>
<a href="#l4.998"></a><span id="l4.998">   comparisonContext.view = this;</span>
<a href="#l4.999"></a><span id="l4.999">   comparisonContext.isSecondarySort = false;</span>
<a href="#l4.1000"></a><span id="l4.1000">   comparisonContext.ascendingSort =</span>
<a href="#l4.1001"></a><span id="l4.1001">       (m_sortOrder == nsMsgViewSortOrder::ascending);</span>
<a href="#l4.1002"></a><span id="l4.1002">   nsCOMPtr&lt;nsIMsgDatabase&gt; db;</span>
<a href="#l4.1003"></a><span id="l4.1003" class="difflineat">@@ -5884,17 +5743,17 @@ void nsMsgDBView::ValidateSort() {</span>
<a href="#l4.1004"></a><span id="l4.1004"> </span>
<a href="#l4.1005"></a><span id="l4.1005">     if (j == m_keys.Length()) break;</span>
<a href="#l4.1006"></a><span id="l4.1006"> </span>
<a href="#l4.1007"></a><span id="l4.1007">     InitEntryInfoForIndex(i, EntryInfo1);</span>
<a href="#l4.1008"></a><span id="l4.1008">     InitEntryInfoForIndex(j, EntryInfo2);</span>
<a href="#l4.1009"></a><span id="l4.1009">     const void *pValue1 = &amp;EntryInfo1, *pValue2 = &amp;EntryInfo2;</span>
<a href="#l4.1010"></a><span id="l4.1010">     int retStatus = 0;</span>
<a href="#l4.1011"></a><span id="l4.1011">     if (fieldType == kCollationKey)</span>
<a href="#l4.1012"></a><span id="l4.1012" class="difflineminus">-      retStatus = FnSortIdKeyPtr(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l4.1013"></a><span id="l4.1013" class="difflineplus">+      retStatus = FnSortIdKey(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l4.1014"></a><span id="l4.1014">     else if (fieldType == kU32)</span>
<a href="#l4.1015"></a><span id="l4.1015">       retStatus = FnSortIdUint32(&amp;pValue1, &amp;pValue2, &amp;comparisonContext);</span>
<a href="#l4.1016"></a><span id="l4.1016"> </span>
<a href="#l4.1017"></a><span id="l4.1017">     if (retStatus &amp;&amp;</span>
<a href="#l4.1018"></a><span id="l4.1018">         (retStatus &lt; 0) == (m_sortOrder == nsMsgViewSortOrder::ascending)) {</span>
<a href="#l4.1019"></a><span id="l4.1019">       NS_ERROR(&quot;view not sorted correctly&quot;);</span>
<a href="#l4.1020"></a><span id="l4.1020">       break;</span>
<a href="#l4.1021"></a><span id="l4.1021">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.h</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.h</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -61,31 +61,30 @@ class MsgViewSortColumnInfo {</span>
<a href="#l5.4"></a><span id="l5.4"> #define MSG_VIEW_FLAG_OUTGOING 0x2000000</span>
<a href="#l5.5"></a><span id="l5.5"> #define MSG_VIEW_FLAG_INCOMING 0x1000000</span>
<a href="#l5.6"></a><span id="l5.6"> </span>
<a href="#l5.7"></a><span id="l5.7"> // There currently only 5 labels defined.</span>
<a href="#l5.8"></a><span id="l5.8"> #define PREF_LABELS_MAX 5</span>
<a href="#l5.9"></a><span id="l5.9"> #define PREF_LABELS_DESCRIPTION &quot;mailnews.labels.description.&quot;</span>
<a href="#l5.10"></a><span id="l5.10"> #define PREF_LABELS_COLOR &quot;mailnews.labels.color.&quot;</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+// Helper struct for sorting by numeric fields.</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+// Associates a message with a key for ordering it in the view.</span>
<a href="#l5.14"></a><span id="l5.14"> struct IdUint32 {</span>
<a href="#l5.15"></a><span id="l5.15">   nsMsgKey id;</span>
<a href="#l5.16"></a><span id="l5.16">   uint32_t bits;</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineminus">-  uint32_t dword;</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+  uint32_t dword;  // The numeric key.</span>
<a href="#l5.19"></a><span id="l5.19">   nsIMsgFolder *folder;</span>
<a href="#l5.20"></a><span id="l5.20"> };</span>
<a href="#l5.21"></a><span id="l5.21"> </span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+// Extends IdUint32 for sorting by a collation key field (eg subject).</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+// (Also used as IdUint32 a couple of places to simplify the code, where</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+// the overhead of an unused nsTArray isn't a big deal).</span>
<a href="#l5.25"></a><span id="l5.25"> struct IdKey : public IdUint32 {</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineminus">-  // Actually a variable length array, whose actual size is determined</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineminus">-  // when the struct is allocated.</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineminus">-  uint8_t key[1];</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineminus">-};</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineminus">-</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineminus">-struct IdKeyPtr : public IdUint32 {</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineminus">-  uint8_t *key;</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+  nsTArray&lt;uint8_t&gt; key;</span>
<a href="#l5.34"></a><span id="l5.34"> };</span>
<a href="#l5.35"></a><span id="l5.35"> </span>
<a href="#l5.36"></a><span id="l5.36"> // This is an abstract implementation class.</span>
<a href="#l5.37"></a><span id="l5.37"> // The actual view objects will be instances of sub-classes of this class.</span>
<a href="#l5.38"></a><span id="l5.38"> class nsMsgDBView : public nsIMsgDBView,</span>
<a href="#l5.39"></a><span id="l5.39">                     public nsIDBChangeListener,</span>
<a href="#l5.40"></a><span id="l5.40">                     public nsITreeView,</span>
<a href="#l5.41"></a><span id="l5.41">                     public nsIJunkMailClassificationListener {</span>
<a href="#l5.42"></a><span id="l5.42" class="difflineat">@@ -98,19 +97,19 @@ class nsMsgDBView : public nsIMsgDBView,</span>
<a href="#l5.43"></a><span id="l5.43">   NS_DECL_NSITREEVIEW</span>
<a href="#l5.44"></a><span id="l5.44">   NS_DECL_NSIJUNKMAILCLASSIFICATIONLISTENER</span>
<a href="#l5.45"></a><span id="l5.45"> </span>
<a href="#l5.46"></a><span id="l5.46">   nsMsgViewIndex GetInsertIndexHelper(nsIMsgDBHdr *msgHdr,</span>
<a href="#l5.47"></a><span id="l5.47">                                       nsTArray&lt;nsMsgKey&gt; &amp;keys,</span>
<a href="#l5.48"></a><span id="l5.48">                                       nsCOMArray&lt;nsIMsgFolder&gt; *folders,</span>
<a href="#l5.49"></a><span id="l5.49">                                       nsMsgViewSortOrderValue sortOrder,</span>
<a href="#l5.50"></a><span id="l5.50">                                       nsMsgViewSortTypeValue sortType);</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineminus">-  int32_t SecondarySort(nsMsgKey key1, nsISupports *folder1, nsMsgKey key2,</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineminus">-                        nsISupports *folder2,</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineminus">-                        class viewSortInfo *comparisonContext);</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+  int32_t SecondaryCompare(nsMsgKey key1, nsIMsgFolder *folder1, nsMsgKey key2,</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+                           nsIMsgFolder *folder2,</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+                           class viewSortInfo *comparisonContext);</span>
<a href="#l5.57"></a><span id="l5.57"> </span>
<a href="#l5.58"></a><span id="l5.58">  protected:</span>
<a href="#l5.59"></a><span id="l5.59">   virtual ~nsMsgDBView();</span>
<a href="#l5.60"></a><span id="l5.60"> </span>
<a href="#l5.61"></a><span id="l5.61">   static nsrefcnt gInstanceCount;</span>
<a href="#l5.62"></a><span id="l5.62"> </span>
<a href="#l5.63"></a><span id="l5.63">   static char16_t *kHighestPriorityString;</span>
<a href="#l5.64"></a><span id="l5.64">   static char16_t *kHighPriorityString;</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineat">@@ -345,32 +344,30 @@ class nsMsgDBView : public nsIMsgDBView,</span>
<a href="#l5.66"></a><span id="l5.66">   /// Should junk commands be enabled for the current message in the view?</span>
<a href="#l5.67"></a><span id="l5.67">   bool JunkControlsEnabled(nsMsgViewIndex aViewIndex);</span>
<a href="#l5.68"></a><span id="l5.68"> </span>
<a href="#l5.69"></a><span id="l5.69">   // For sorting.</span>
<a href="#l5.70"></a><span id="l5.70">   nsresult GetFieldTypeAndLenForSort(</span>
<a href="#l5.71"></a><span id="l5.71">       nsMsgViewSortTypeValue sortType, uint16_t *pMaxLen,</span>
<a href="#l5.72"></a><span id="l5.72">       eFieldType *pFieldType, nsIMsgCustomColumnHandler *colHandler = nullptr);</span>
<a href="#l5.73"></a><span id="l5.73">   nsresult GetCollationKey(nsIMsgDBHdr *msgHdr, nsMsgViewSortTypeValue sortType,</span>
<a href="#l5.74"></a><span id="l5.74" class="difflineminus">-                           uint8_t **result, uint32_t *len,</span>
<a href="#l5.75"></a><span id="l5.75" class="difflineplus">+                           nsTArray&lt;uint8_t&gt; &amp;result,</span>
<a href="#l5.76"></a><span id="l5.76">                            nsIMsgCustomColumnHandler *colHandler = nullptr);</span>
<a href="#l5.77"></a><span id="l5.77">   nsresult GetLongField(nsIMsgDBHdr *msgHdr, nsMsgViewSortTypeValue sortType,</span>
<a href="#l5.78"></a><span id="l5.78">                         uint32_t *result,</span>
<a href="#l5.79"></a><span id="l5.79">                         nsIMsgCustomColumnHandler *colHandler = nullptr);</span>
<a href="#l5.80"></a><span id="l5.80"> </span>
<a href="#l5.81"></a><span id="l5.81">   static int FnSortIdKey(const void *pItem1, const void *pItem2,</span>
<a href="#l5.82"></a><span id="l5.82">                          void *privateData);</span>
<a href="#l5.83"></a><span id="l5.83" class="difflineminus">-  static int FnSortIdKeyPtr(const void *pItem1, const void *pItem2,</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineminus">-                            void *privateData);</span>
<a href="#l5.85"></a><span id="l5.85">   static int FnSortIdUint32(const void *pItem1, const void *pItem2,</span>
<a href="#l5.86"></a><span id="l5.86">                             void *privateData);</span>
<a href="#l5.87"></a><span id="l5.87"> </span>
<a href="#l5.88"></a><span id="l5.88">   nsresult GetStatusSortValue(nsIMsgDBHdr *msgHdr, uint32_t *result);</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineminus">-  nsresult GetLocationCollationKey(nsIMsgDBHdr *msgHdr, uint8_t **result,</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineminus">-                                   uint32_t *len);</span>
<a href="#l5.91"></a><span id="l5.91" class="difflineplus">+  nsresult GetLocationCollationKey(nsIMsgDBHdr *msgHdr,</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineplus">+                                   nsTArray&lt;uint8_t&gt; &amp;result);</span>
<a href="#l5.93"></a><span id="l5.93">   void PushSort(const MsgViewSortColumnInfo &amp;newSort);</span>
<a href="#l5.94"></a><span id="l5.94">   nsresult EncodeColumnSort(nsString &amp;columnSortString);</span>
<a href="#l5.95"></a><span id="l5.95">   nsresult DecodeColumnSort(nsString &amp;columnSortString);</span>
<a href="#l5.96"></a><span id="l5.96">   // For view navigation.</span>
<a href="#l5.97"></a><span id="l5.97">   nsresult NavigateFromPos(nsMsgNavigationTypeValue motion,</span>
<a href="#l5.98"></a><span id="l5.98">                            nsMsgViewIndex startIndex, nsMsgKey *pResultKey,</span>
<a href="#l5.99"></a><span id="l5.99">                            nsMsgViewIndex *pResultIndex,</span>
<a href="#l5.100"></a><span id="l5.100">                            nsMsgViewIndex *pThreadIndex, bool wrap);</span>
<a href="#l5.101"></a><span id="l5.101" class="difflineat">@@ -505,17 +502,17 @@ class nsMsgDBView : public nsIMsgDBView,</span>
<a href="#l5.102"></a><span id="l5.102">   nsTArray&lt;nsString&gt; m_customColumnHandlerIDs;</span>
<a href="#l5.103"></a><span id="l5.103"> </span>
<a href="#l5.104"></a><span id="l5.104">   nsIMsgCustomColumnHandler *GetColumnHandler(const nsAString &amp;colID);</span>
<a href="#l5.105"></a><span id="l5.105">   nsIMsgCustomColumnHandler *GetCurColumnHandler();</span>
<a href="#l5.106"></a><span id="l5.106">   bool CustomColumnsInSortAndNotRegistered();</span>
<a href="#l5.107"></a><span id="l5.107">   void EnsureCustomColumnsValid();</span>
<a href="#l5.108"></a><span id="l5.108"> </span>
<a href="#l5.109"></a><span id="l5.109"> #ifdef DEBUG_David_Bienvenu</span>
<a href="#l5.110"></a><span id="l5.110" class="difflineminus">-  void InitEntryInfoForIndex(nsMsgViewIndex i, IdKeyPtr &amp;EntryInfo);</span>
<a href="#l5.111"></a><span id="l5.111" class="difflineplus">+  void InitEntryInfoForIndex(nsMsgViewIndex i, IdKey &amp;EntryInfo);</span>
<a href="#l5.112"></a><span id="l5.112">   void ValidateSort();</span>
<a href="#l5.113"></a><span id="l5.113"> #endif</span>
<a href="#l5.114"></a><span id="l5.114"> </span>
<a href="#l5.115"></a><span id="l5.115">  protected:</span>
<a href="#l5.116"></a><span id="l5.116">   static nsresult InitDisplayFormats();</span>
<a href="#l5.117"></a><span id="l5.117"> </span>
<a href="#l5.118"></a><span id="l5.118">  private:</span>
<a href="#l5.119"></a><span id="l5.119">   static mozilla::nsDateFormatSelector m_dateFormatDefault;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -4965,51 +4965,44 @@ NS_IMETHODIMP nsMsgDBFolder::GetSortOrde</span>
<a href="#l6.4"></a><span id="l6.4">   else if (flags &amp; nsMsgFolderFlags::Queue)</span>
<a href="#l6.5"></a><span id="l6.5">     *order = 8;</span>
<a href="#l6.6"></a><span id="l6.6">   else</span>
<a href="#l6.7"></a><span id="l6.7">     *order = 9;</span>
<a href="#l6.8"></a><span id="l6.8"> </span>
<a href="#l6.9"></a><span id="l6.9">   return NS_OK;</span>
<a href="#l6.10"></a><span id="l6.10"> }</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-// Helper function for CompareSortKeys().</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+// static Helper function for CompareSortKeys().</span>
<a href="#l6.14"></a><span id="l6.14"> // Builds a collation key for a given folder based on &quot;{sortOrder}{name}&quot;</span>
<a href="#l6.15"></a><span id="l6.15"> nsresult nsMsgDBFolder::BuildFolderSortKey(nsIMsgFolder *aFolder,</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineminus">-                                           uint32_t *aLength, uint8_t **aKey) {</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineminus">-  NS_ENSURE_ARG(aKey);</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+                                           nsTArray&lt;uint8_t&gt; &amp;aKey) {</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+  aKey.Clear();</span>
<a href="#l6.20"></a><span id="l6.20">   int32_t order;</span>
<a href="#l6.21"></a><span id="l6.21">   nsresult rv = aFolder-&gt;GetSortOrder(&amp;order);</span>
<a href="#l6.22"></a><span id="l6.22">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l6.23"></a><span id="l6.23">   nsAutoString orderString;</span>
<a href="#l6.24"></a><span id="l6.24">   orderString.AppendInt(order);</span>
<a href="#l6.25"></a><span id="l6.25">   nsString folderName;</span>
<a href="#l6.26"></a><span id="l6.26">   rv = aFolder-&gt;GetName(folderName);</span>
<a href="#l6.27"></a><span id="l6.27">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l6.28"></a><span id="l6.28">   orderString.Append(folderName);</span>
<a href="#l6.29"></a><span id="l6.29">   NS_ENSURE_TRUE(gCollationKeyGenerator, NS_ERROR_NULL_POINTER);</span>
<a href="#l6.30"></a><span id="l6.30">   return gCollationKeyGenerator-&gt;AllocateRawSortKey(</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-      nsICollation::kCollationCaseInSensitive, orderString, aKey, aLength);</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+      nsICollation::kCollationCaseInSensitive, orderString, aKey);</span>
<a href="#l6.33"></a><span id="l6.33"> }</span>
<a href="#l6.34"></a><span id="l6.34"> </span>
<a href="#l6.35"></a><span id="l6.35"> NS_IMETHODIMP nsMsgDBFolder::CompareSortKeys(nsIMsgFolder *aFolder,</span>
<a href="#l6.36"></a><span id="l6.36">                                              int32_t *sortOrder) {</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineminus">-  // nsICollation interface will likely change to use nsTArray&lt;&gt; at some point.</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineminus">-  // So this can be simplified then (see Bug 1509981).</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineminus">-  uint8_t *sortKey1 = nullptr;</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineminus">-  uint8_t *sortKey2 = nullptr;</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineminus">-  uint32_t sortKey1Length;</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineminus">-  uint32_t sortKey2Length;</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineminus">-  nsresult rv = BuildFolderSortKey(this, &amp;sortKey1Length, &amp;sortKey1);</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+  nsTArray&lt;uint8_t&gt; sortKey1;</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+  nsTArray&lt;uint8_t&gt; sortKey2;</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+  nsresult rv = BuildFolderSortKey(this, sortKey1);</span>
<a href="#l6.47"></a><span id="l6.47">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineminus">-  rv = BuildFolderSortKey(aFolder, &amp;sortKey2Length, &amp;sortKey2);</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+  rv = BuildFolderSortKey(aFolder, sortKey2);</span>
<a href="#l6.50"></a><span id="l6.50">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineminus">-  rv = gCollationKeyGenerator-&gt;CompareRawSortKey(</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineminus">-      sortKey1, sortKey1Length, sortKey2, sortKey2Length, sortOrder);</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineminus">-  PR_Free(sortKey1);</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineminus">-  PR_Free(sortKey2);</span>
<a href="#l6.55"></a><span id="l6.55" class="difflineplus">+  rv = gCollationKeyGenerator-&gt;CompareRawSortKey(sortKey1, sortKey2, sortOrder);</span>
<a href="#l6.56"></a><span id="l6.56">   return rv;</span>
<a href="#l6.57"></a><span id="l6.57"> }</span>
<a href="#l6.58"></a><span id="l6.58"> </span>
<a href="#l6.59"></a><span id="l6.59"> NS_IMETHODIMP nsMsgDBFolder::FetchMsgPreviewText(nsMsgKey *aKeysToFetch,</span>
<a href="#l6.60"></a><span id="l6.60">                                                  uint32_t aNumKeys,</span>
<a href="#l6.61"></a><span id="l6.61">                                                  bool aLocalOnly,</span>
<a href="#l6.62"></a><span id="l6.62">                                                  nsIUrlListener *aUrlListener,</span>
<a href="#l6.63"></a><span id="l6.63">                                                  bool *aAsyncResults) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -197,18 +197,18 @@ class NS_MSG_BASE nsMsgDBFolder : public</span>
<a href="#l7.4"></a><span id="l7.4">   void SetMRMTime();</span>
<a href="#l7.5"></a><span id="l7.5">   /**</span>
<a href="#l7.6"></a><span id="l7.6">    * Clear all processing flags, presumably because message keys are no longer</span>
<a href="#l7.7"></a><span id="l7.7">    * valid.</span>
<a href="#l7.8"></a><span id="l7.8">    */</span>
<a href="#l7.9"></a><span id="l7.9">   void ClearProcessingFlags();</span>
<a href="#l7.10"></a><span id="l7.10"> </span>
<a href="#l7.11"></a><span id="l7.11">   nsresult NotifyHdrsNotBeingClassified();</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-  nsresult BuildFolderSortKey(nsIMsgFolder *aFolder, uint32_t *aLength,</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineminus">-                              uint8_t **aKey);</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+  static nsresult BuildFolderSortKey(nsIMsgFolder *aFolder,</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+                                     nsTArray&lt;uint8_t&gt; &amp;aKey);</span>
<a href="#l7.16"></a><span id="l7.16">   /**</span>
<a href="#l7.17"></a><span id="l7.17">    * Produce an array of messages ordered like the input keys.</span>
<a href="#l7.18"></a><span id="l7.18">    */</span>
<a href="#l7.19"></a><span id="l7.19">   nsresult MessagesInKeyOrder(nsTArray&lt;nsMsgKey&gt; &amp;aKeyArray,</span>
<a href="#l7.20"></a><span id="l7.20">                               nsIMsgFolder *srcFolder,</span>
<a href="#l7.21"></a><span id="l7.21">                               nsIMutableArray *messages);</span>
<a href="#l7.22"></a><span id="l7.22">   nsCString mURI;</span>
<a href="#l7.23"></a><span id="l7.23"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/db/msgdb/public/nsIMsgDatabase.idl</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/db/msgdb/public/nsIMsgDatabase.idl</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -524,22 +524,18 @@ interface nsIMsgDatabase : nsIDBChangeAn</span>
<a href="#l8.4"></a><span id="l8.4">    */</span>
<a href="#l8.5"></a><span id="l8.5">   void updatePendingAttributes(in nsIMsgDBHdr aNewHdr);</span>
<a href="#l8.6"></a><span id="l8.6"> </span>
<a href="#l8.7"></a><span id="l8.7">   readonly attribute nsMsgKey lowWaterArticleNum;</span>
<a href="#l8.8"></a><span id="l8.8">   readonly attribute nsMsgKey highWaterArticleNum;</span>
<a href="#l8.9"></a><span id="l8.9">   attribute nsMsgKey nextPseudoMsgKey;   //for undo-redo of move pop-&gt;imap</span>
<a href="#l8.10"></a><span id="l8.10">   readonly attribute nsMsgKey nextFakeOfflineMsgKey; // for saving &quot;fake&quot; offline msg hdrs</span>
<a href="#l8.11"></a><span id="l8.11">   // for sorting</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  void createCollationKey(in AString sourceString, out unsigned long aCount,</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">-                          [array, size_is(aCount)] out octet aKey);</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineminus">-  long compareCollationKeys(in unsigned long aLen1,</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineminus">-                            [array, size_is(aLen1)] in octet key1,</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineminus">-                            in unsigned long aLen2,</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineminus">-                            [array, size_is(aLen2)] in octet key2);</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineplus">+  Array&lt;octet&gt; createCollationKey(in AString sourceString);</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+  long compareCollationKeys(in Array&lt;octet&gt; key1, in Array&lt;octet&gt; key2);</span>
<a href="#l8.20"></a><span id="l8.20"> </span>
<a href="#l8.21"></a><span id="l8.21">   // when creating a view, the default sort order and view flags</span>
<a href="#l8.22"></a><span id="l8.22">   // use these for the default.  (this allows news to override, so that</span>
<a href="#l8.23"></a><span id="l8.23">   // news can be threaded by default)</span>
<a href="#l8.24"></a><span id="l8.24">   readonly attribute nsMsgViewFlagsTypeValue defaultViewFlags;</span>
<a href="#l8.25"></a><span id="l8.25">   readonly attribute nsMsgViewSortTypeValue  defaultSortType;</span>
<a href="#l8.26"></a><span id="l8.26">   readonly attribute nsMsgViewSortOrderValue defaultSortOrder;</span>
<a href="#l8.27"></a><span id="l8.27"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/db/msgdb/public/nsMsgDatabase.h</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/db/msgdb/public/nsMsgDatabase.h</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -194,22 +194,22 @@ class nsMsgDatabase : public nsIMsgDatab</span>
<a href="#l9.4"></a><span id="l9.4">                                  uint32_t defaultValue = 0);</span>
<a href="#l9.5"></a><span id="l9.5">   nsresult RowCellColumnToUInt64(nsIMdbRow *row, mdb_token columnToken,</span>
<a href="#l9.6"></a><span id="l9.6">                                  uint64_t *uint64Result,</span>
<a href="#l9.7"></a><span id="l9.7">                                  uint64_t defaultValue = 0);</span>
<a href="#l9.8"></a><span id="l9.8">   nsresult RowCellColumnToMime2DecodedString(nsIMdbRow *row,</span>
<a href="#l9.9"></a><span id="l9.9">                                              mdb_token columnToken,</span>
<a href="#l9.10"></a><span id="l9.10">                                              nsAString &amp;resultStr);</span>
<a href="#l9.11"></a><span id="l9.11">   nsresult RowCellColumnToCollationKey(nsIMdbRow *row, mdb_token columnToken,</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-                                       uint8_t **result, uint32_t *len);</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+                                       nsTArray&lt;uint8_t&gt; &amp;result);</span>
<a href="#l9.14"></a><span id="l9.14">   nsresult RowCellColumnToConstCharPtr(nsIMdbRow *row, mdb_token columnToken,</span>
<a href="#l9.15"></a><span id="l9.15">                                        const char **ptr);</span>
<a href="#l9.16"></a><span id="l9.16">   nsresult RowCellColumnToAddressCollationKey(nsIMdbRow *row,</span>
<a href="#l9.17"></a><span id="l9.17">                                               mdb_token colToken,</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineminus">-                                              uint8_t **result, uint32_t *len);</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+                                              nsTArray&lt;uint8_t&gt; &amp;result);</span>
<a href="#l9.20"></a><span id="l9.20"> </span>
<a href="#l9.21"></a><span id="l9.21">   nsresult GetEffectiveCharset(nsIMdbRow *row, nsACString &amp;resultCharset);</span>
<a href="#l9.22"></a><span id="l9.22"> </span>
<a href="#l9.23"></a><span id="l9.23">   // these methods take the property name as a string, not a token.</span>
<a href="#l9.24"></a><span id="l9.24">   // they should be used when the properties aren't accessed a lot</span>
<a href="#l9.25"></a><span id="l9.25">   nsresult GetProperty(nsIMdbRow *row, const char *propertyName, char **result);</span>
<a href="#l9.26"></a><span id="l9.26">   nsresult SetProperty(nsIMdbRow *row, const char *propertyName,</span>
<a href="#l9.27"></a><span id="l9.27">                        const char *propertyVal);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -3255,27 +3255,25 @@ nsresult nsMsgDatabase::RowCellColumnToM</span>
<a href="#l10.4"></a><span id="l10.4"> </span>
<a href="#l10.5"></a><span id="l10.5">       err = m_mimeConverter-&gt;DecodeMimeHeader(nakedString, charSet.get(), false,</span>
<a href="#l10.6"></a><span id="l10.6">                                               true, resultStr);</span>
<a href="#l10.7"></a><span id="l10.7">     }</span>
<a href="#l10.8"></a><span id="l10.8">   }</span>
<a href="#l10.9"></a><span id="l10.9">   return err;</span>
<a href="#l10.10"></a><span id="l10.10"> }</span>
<a href="#l10.11"></a><span id="l10.11"> </span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-nsresult nsMsgDatabase::RowCellColumnToAddressCollationKey(nsIMdbRow *row,</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineminus">-                                                           mdb_token colToken,</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineminus">-                                                           uint8_t **result,</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineminus">-                                                           uint32_t *len) {</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+nsresult nsMsgDatabase::RowCellColumnToAddressCollationKey(</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+    nsIMdbRow *row, mdb_token colToken, nsTArray&lt;uint8_t&gt; &amp;result) {</span>
<a href="#l10.18"></a><span id="l10.18">   nsString sender;</span>
<a href="#l10.19"></a><span id="l10.19">   nsresult rv = RowCellColumnToMime2DecodedString(row, colToken, sender);</span>
<a href="#l10.20"></a><span id="l10.20">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l10.21"></a><span id="l10.21"> </span>
<a href="#l10.22"></a><span id="l10.22">   nsString name;</span>
<a href="#l10.23"></a><span id="l10.23">   ExtractName(DecodedHeader(sender), name);</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineminus">-  return CreateCollationKey(name, len, result);</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineplus">+  return CreateCollationKey(name, result);</span>
<a href="#l10.26"></a><span id="l10.26"> }</span>
<a href="#l10.27"></a><span id="l10.27"> </span>
<a href="#l10.28"></a><span id="l10.28"> nsresult nsMsgDatabase::GetCollationKeyGenerator() {</span>
<a href="#l10.29"></a><span id="l10.29">   nsresult err = NS_OK;</span>
<a href="#l10.30"></a><span id="l10.30">   if (!m_collationKeyGenerator) {</span>
<a href="#l10.31"></a><span id="l10.31">     nsCOMPtr&lt;nsICollationFactory&gt; f =</span>
<a href="#l10.32"></a><span id="l10.32">         do_CreateInstance(NS_COLLATIONFACTORY_CONTRACTID, &amp;err);</span>
<a href="#l10.33"></a><span id="l10.33">     if (NS_SUCCEEDED(err) &amp;&amp; f) {</span>
<a href="#l10.34"></a><span id="l10.34" class="difflineat">@@ -3283,63 +3281,61 @@ nsresult nsMsgDatabase::GetCollationKeyG</span>
<a href="#l10.35"></a><span id="l10.35">       err = f-&gt;CreateCollation(getter_AddRefs(m_collationKeyGenerator));</span>
<a href="#l10.36"></a><span id="l10.36">     }</span>
<a href="#l10.37"></a><span id="l10.37">   }</span>
<a href="#l10.38"></a><span id="l10.38">   return err;</span>
<a href="#l10.39"></a><span id="l10.39"> }</span>
<a href="#l10.40"></a><span id="l10.40"> </span>
<a href="#l10.41"></a><span id="l10.41"> nsresult nsMsgDatabase::RowCellColumnToCollationKey(nsIMdbRow *row,</span>
<a href="#l10.42"></a><span id="l10.42">                                                     mdb_token columnToken,</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineminus">-                                                    uint8_t **result,</span>
<a href="#l10.44"></a><span id="l10.44" class="difflineminus">-                                                    uint32_t *len) {</span>
<a href="#l10.45"></a><span id="l10.45" class="difflineplus">+                                                    nsTArray&lt;uint8_t&gt; &amp;result) {</span>
<a href="#l10.46"></a><span id="l10.46">   const char *nakedString = nullptr;</span>
<a href="#l10.47"></a><span id="l10.47">   nsresult err;</span>
<a href="#l10.48"></a><span id="l10.48"> </span>
<a href="#l10.49"></a><span id="l10.49">   err = RowCellColumnToConstCharPtr(row, columnToken, &amp;nakedString);</span>
<a href="#l10.50"></a><span id="l10.50">   if (!nakedString) nakedString = &quot;&quot;;</span>
<a href="#l10.51"></a><span id="l10.51">   if (NS_SUCCEEDED(err)) {</span>
<a href="#l10.52"></a><span id="l10.52">     GetMimeConverter();</span>
<a href="#l10.53"></a><span id="l10.53">     if (m_mimeConverter) {</span>
<a href="#l10.54"></a><span id="l10.54">       nsCString decodedStr;</span>
<a href="#l10.55"></a><span id="l10.55">       nsCString charSet;</span>
<a href="#l10.56"></a><span id="l10.56">       GetEffectiveCharset(row, charSet);</span>
<a href="#l10.57"></a><span id="l10.57"> </span>
<a href="#l10.58"></a><span id="l10.58">       err = m_mimeConverter-&gt;DecodeMimeHeaderToUTF8(</span>
<a href="#l10.59"></a><span id="l10.59">           nsDependentCString(nakedString), charSet.get(), false, true,</span>
<a href="#l10.60"></a><span id="l10.60">           decodedStr);</span>
<a href="#l10.61"></a><span id="l10.61">       if (NS_SUCCEEDED(err))</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineminus">-        err =</span>
<a href="#l10.63"></a><span id="l10.63" class="difflineminus">-            CreateCollationKey(NS_ConvertUTF8toUTF16(decodedStr), len, result);</span>
<a href="#l10.64"></a><span id="l10.64" class="difflineplus">+        err = CreateCollationKey(NS_ConvertUTF8toUTF16(decodedStr), result);</span>
<a href="#l10.65"></a><span id="l10.65">     }</span>
<a href="#l10.66"></a><span id="l10.66">   }</span>
<a href="#l10.67"></a><span id="l10.67">   return err;</span>
<a href="#l10.68"></a><span id="l10.68"> }</span>
<a href="#l10.69"></a><span id="l10.69"> </span>
<a href="#l10.70"></a><span id="l10.70"> NS_IMETHODIMP</span>
<a href="#l10.71"></a><span id="l10.71" class="difflineminus">-nsMsgDatabase::CompareCollationKeys(uint32_t len1, uint8_t *key1, uint32_t len2,</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineminus">-                                    uint8_t *key2, int32_t *result) {</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineplus">+nsMsgDatabase::CompareCollationKeys(const nsTArray&lt;uint8_t&gt; &amp;key1,</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineplus">+                                    const nsTArray&lt;uint8_t&gt; &amp;key2,</span>
<a href="#l10.75"></a><span id="l10.75" class="difflineplus">+                                    int32_t *result) {</span>
<a href="#l10.76"></a><span id="l10.76">   nsresult rv = GetCollationKeyGenerator();</span>
<a href="#l10.77"></a><span id="l10.77">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l10.78"></a><span id="l10.78">   if (!m_collationKeyGenerator) return NS_ERROR_FAILURE;</span>
<a href="#l10.79"></a><span id="l10.79"> </span>
<a href="#l10.80"></a><span id="l10.80" class="difflineminus">-  rv = m_collationKeyGenerator-&gt;CompareRawSortKey(key1, len1, key2, len2,</span>
<a href="#l10.81"></a><span id="l10.81" class="difflineminus">-                                                  result);</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineplus">+  rv = m_collationKeyGenerator-&gt;CompareRawSortKey(key1, key2, result);</span>
<a href="#l10.83"></a><span id="l10.83">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l10.84"></a><span id="l10.84">   return rv;</span>
<a href="#l10.85"></a><span id="l10.85"> }</span>
<a href="#l10.86"></a><span id="l10.86"> </span>
<a href="#l10.87"></a><span id="l10.87"> NS_IMETHODIMP</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineminus">-nsMsgDatabase::CreateCollationKey(const nsAString &amp;sourceString, uint32_t *len,</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineminus">-                                  uint8_t **result) {</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineplus">+nsMsgDatabase::CreateCollationKey(const nsAString &amp;sourceString,</span>
<a href="#l10.91"></a><span id="l10.91" class="difflineplus">+                                  nsTArray&lt;uint8_t&gt; &amp;result) {</span>
<a href="#l10.92"></a><span id="l10.92">   nsresult err = GetCollationKeyGenerator();</span>
<a href="#l10.93"></a><span id="l10.93">   NS_ENSURE_SUCCESS(err, err);</span>
<a href="#l10.94"></a><span id="l10.94">   if (!m_collationKeyGenerator) return NS_ERROR_FAILURE;</span>
<a href="#l10.95"></a><span id="l10.95"> </span>
<a href="#l10.96"></a><span id="l10.96">   err = m_collationKeyGenerator-&gt;AllocateRawSortKey(</span>
<a href="#l10.97"></a><span id="l10.97" class="difflineminus">-      nsICollation::kCollationCaseInSensitive, sourceString, result, len);</span>
<a href="#l10.98"></a><span id="l10.98" class="difflineplus">+      nsICollation::kCollationCaseInSensitive, sourceString, result);</span>
<a href="#l10.99"></a><span id="l10.99">   NS_ENSURE_SUCCESS(err, err);</span>
<a href="#l10.100"></a><span id="l10.100">   return err;</span>
<a href="#l10.101"></a><span id="l10.101"> }</span>
<a href="#l10.102"></a><span id="l10.102"> </span>
<a href="#l10.103"></a><span id="l10.103"> nsresult nsMsgDatabase::RowCellColumnToUInt32(nsIMdbRow *hdrRow,</span>
<a href="#l10.104"></a><span id="l10.104">                                               mdb_token columnToken,</span>
<a href="#l10.105"></a><span id="l10.105">                                               uint32_t &amp;uint32Result,</span>
<a href="#l10.106"></a><span id="l10.106">                                               uint32_t defaultValue) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/db/msgdb/src/nsMsgHdr.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/db/msgdb/src/nsMsgHdr.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -509,32 +509,31 @@ NS_IMETHODIMP nsMsgHdr::GetMime2DecodedS</span>
<a href="#l11.4"></a><span id="l11.4">       GetMDBRow(), m_mdb-&gt;m_subjectColumnToken, resultSubject);</span>
<a href="#l11.5"></a><span id="l11.5"> }</span>
<a href="#l11.6"></a><span id="l11.6"> </span>
<a href="#l11.7"></a><span id="l11.7"> NS_IMETHODIMP nsMsgHdr::GetMime2DecodedRecipients(nsAString &amp;resultRecipients) {</span>
<a href="#l11.8"></a><span id="l11.8">   return m_mdb-&gt;RowCellColumnToMime2DecodedString(</span>
<a href="#l11.9"></a><span id="l11.9">       GetMDBRow(), m_mdb-&gt;m_recipientsColumnToken, resultRecipients);</span>
<a href="#l11.10"></a><span id="l11.10"> }</span>
<a href="#l11.11"></a><span id="l11.11"> </span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-NS_IMETHODIMP nsMsgHdr::GetAuthorCollationKey(uint32_t *len,</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineminus">-                                              uint8_t **resultAuthor) {</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+NS_IMETHODIMP nsMsgHdr::GetAuthorCollationKey(nsTArray&lt;uint8_t&gt; &amp;resultAuthor) {</span>
<a href="#l11.15"></a><span id="l11.15">   return m_mdb-&gt;RowCellColumnToAddressCollationKey(</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineminus">-      GetMDBRow(), m_mdb-&gt;m_senderColumnToken, resultAuthor, len);</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineplus">+      GetMDBRow(), m_mdb-&gt;m_senderColumnToken, resultAuthor);</span>
<a href="#l11.18"></a><span id="l11.18"> }</span>
<a href="#l11.19"></a><span id="l11.19"> </span>
<a href="#l11.20"></a><span id="l11.20" class="difflineminus">-NS_IMETHODIMP nsMsgHdr::GetSubjectCollationKey(uint32_t *len,</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineminus">-                                               uint8_t **resultSubject) {</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+NS_IMETHODIMP nsMsgHdr::GetSubjectCollationKey(</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineplus">+    nsTArray&lt;uint8_t&gt; &amp;resultSubject) {</span>
<a href="#l11.24"></a><span id="l11.24">   return m_mdb-&gt;RowCellColumnToCollationKey(</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineminus">-      GetMDBRow(), m_mdb-&gt;m_subjectColumnToken, resultSubject, len);</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineplus">+      GetMDBRow(), m_mdb-&gt;m_subjectColumnToken, resultSubject);</span>
<a href="#l11.27"></a><span id="l11.27"> }</span>
<a href="#l11.28"></a><span id="l11.28"> </span>
<a href="#l11.29"></a><span id="l11.29" class="difflineminus">-NS_IMETHODIMP nsMsgHdr::GetRecipientsCollationKey(uint32_t *len,</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineminus">-                                                  uint8_t **resultRecipients) {</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineplus">+NS_IMETHODIMP nsMsgHdr::GetRecipientsCollationKey(</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+    nsTArray&lt;uint8_t&gt; &amp;resultRecipients) {</span>
<a href="#l11.33"></a><span id="l11.33">   return m_mdb-&gt;RowCellColumnToCollationKey(</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineminus">-      GetMDBRow(), m_mdb-&gt;m_recipientsColumnToken, resultRecipients, len);</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineplus">+      GetMDBRow(), m_mdb-&gt;m_recipientsColumnToken, resultRecipients);</span>
<a href="#l11.36"></a><span id="l11.36"> }</span>
<a href="#l11.37"></a><span id="l11.37"> </span>
<a href="#l11.38"></a><span id="l11.38"> NS_IMETHODIMP nsMsgHdr::GetCharset(char **aCharset) {</span>
<a href="#l11.39"></a><span id="l11.39">   return m_mdb-&gt;RowCellColumnToCharPtr(</span>
<a href="#l11.40"></a><span id="l11.40">       GetMDBRow(), m_mdb-&gt;m_messageCharSetColumnToken, aCharset);</span>
<a href="#l11.41"></a><span id="l11.41"> }</span>
<a href="#l11.42"></a><span id="l11.42"> </span>
<a href="#l11.43"></a><span id="l11.43"> NS_IMETHODIMP nsMsgHdr::SetCharset(const char *aCharset) {</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:31Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

