<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 6986:afa759fe196cc5123b68d82753128ced2ba089eb</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ afa759fe196cc5123b68d82753128ced2ba089eb" />
<meta property="og:url" content="/comm-central/rev/afa759fe196cc5123b68d82753128ced2ba089eb" />
<meta property="og:description" content="Bug 534449 - Gloda should index sent messages right away instead of waiting for me to open the sent folder. r=bienvenu" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / afa759fe196cc5123b68d82753128ced2ba089eb 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/afa759fe196cc5123b68d82753128ced2ba089eb">shortlog</a> |
<a href="/comm-central/log/afa759fe196cc5123b68d82753128ced2ba089eb">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/afa759fe196cc5123b68d82753128ced2ba089eb">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/afa759fe196cc5123b68d82753128ced2ba089eb">files</a> |
changeset |
<a href="/comm-central/raw-rev/afa759fe196cc5123b68d82753128ced2ba089eb">raw</a>  | <a href="/comm-central/archive/afa759fe196cc5123b68d82753128ced2ba089eb.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=534449">Bug 534449</a> - Gloda should index sent messages right away instead of waiting for me to open the sent folder. r=bienvenu
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Wed, 19 Jan 2011 16:49:12 -0800</td></tr>

<tr>
 <td>changeset 6986</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/afa759fe196cc5123b68d82753128ced2ba089eb">afa759fe196cc5123b68d82753128ced2ba089eb</a></td>
</tr>



<tr>
<td>parent 6985</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/fefbbf03688aa4c322f3630c072c27f27c9c9f1d">fefbbf03688aa4c322f3630c072c27f27c9c9f1d</a>
</td>
</tr>

<tr>
<td>child 6987</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/be18bde0f11cb9d08b31d1c8ff5399469321d8c2">be18bde0f11cb9d08b31d1c8ff5399469321d8c2</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=afa759fe196cc5123b68d82753128ced2ba089eb">5356</a></td></tr>
<tr><td>push user</td><td>bugmail@asutherland.org</td></tr>
<tr><td>push date</td><td class="date age">Thu, 20 Jan 2011 00:49:29 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@afa759fe196c [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=afa759fe196cc5123b68d82753128ced2ba089eb">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=afa759fe196cc5123b68d82753128ced2ba089eb&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=afa759fe196cc5123b68d82753128ced2ba089eb&newProject=comm-central&newRevision=afa759fe196cc5123b68d82753128ced2ba089eb&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=afa759fe196cc5123b68d82753128ced2ba089eb&newProject=comm-central&newRevision=afa759fe196cc5123b68d82753128ced2ba089eb&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=afa759fe196cc5123b68d82753128ced2ba089eb&newProject=comm-central&newRevision=afa759fe196cc5123b68d82753128ced2ba089eb&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28bienvenu%29&revcount=50">bienvenu</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=534449">534449</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=534449">Bug 534449</a> - Gloda should index sent messages right away instead of waiting for me to open the sent folder. r=bienvenu</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/collection.js">mailnews/db/gloda/modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/collection.js">file</a> |
<a href="/comm-central/annotate/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/collection.js">comparison</a> |
<a href="/comm-central/log/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/datastore.js">mailnews/db/gloda/modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/index_msg.js">mailnews/db/gloda/modules/index_msg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/index_msg.js">file</a> |
<a href="/comm-central/annotate/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/index_msg.js">annotate</a> |
<a href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/index_msg.js">diff</a> |
<a href="/comm-central/comparison/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/index_msg.js">comparison</a> |
<a href="/comm-central/log/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/modules/index_msg.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/base_index_messages.js">mailnews/db/gloda/test/unit/base_index_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/base_index_messages.js">file</a> |
<a href="/comm-central/annotate/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/base_index_messages.js">annotate</a> |
<a href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/base_index_messages.js">diff</a> |
<a href="/comm-central/comparison/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/base_index_messages.js">comparison</a> |
<a href="/comm-central/log/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/base_index_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/folderEventLogHelper.js">mailnews/test/resources/folderEventLogHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/folderEventLogHelper.js">file</a> |
<a href="/comm-central/annotate/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/folderEventLogHelper.js">annotate</a> |
<a href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/folderEventLogHelper.js">diff</a> |
<a href="/comm-central/comparison/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/folderEventLogHelper.js">comparison</a> |
<a href="/comm-central/log/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/folderEventLogHelper.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/messageInjection.js">mailnews/test/resources/messageInjection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/messageInjection.js">file</a> |
<a href="/comm-central/annotate/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/messageInjection.js">annotate</a> |
<a href="/comm-central/diff/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/messageInjection.js">diff</a> |
<a href="/comm-central/comparison/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/messageInjection.js">comparison</a> |
<a href="/comm-central/log/afa759fe196cc5123b68d82753128ced2ba089eb/mailnews/test/resources/messageInjection.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/db/gloda/modules/collection.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/collection.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -132,17 +132,31 @@ var GlodaCollectionManager = {</span>
<a href="#l1.4"></a><span id="l1.4">       }</span>
<a href="#l1.5"></a><span id="l1.5">     }</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7">     return null;</span>
<a href="#l1.8"></a><span id="l1.8">   },</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10">   /**</span>
<a href="#l1.11"></a><span id="l1.11">    * Lookup multiple nouns by ID from the cache/existing collections.</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-   * @return [The number that were found, the number that were not found.]</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+   *</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+   * @param aNounID The kind of noun identified by its ID.</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+   * @param aIDMap A dictionary/map whose keys must be gloda noun ids for the</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+   *     given noun type and whose values are ignored.</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+   * @param aTargetMap An object to hold the noun id's (key) and noun instances</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+   *     (value) for the noun instances that were found available in memory</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+   *     because they were cached or in existing query collections.</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+   * @param [aDoCache=true] Should we add any items to the cache that we found</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+   *     in collections that were in memory but not in the cache?  You would</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineplus">+   *     likely want to pass false if you are only updating in-memory</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+   *     representations rather than performing a new query.</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+   *</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+   * @return [The number that were found, the number that were not found,</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+   *          a dictionary whose keys are the ids of noun instances that</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+   *          were not found.]</span>
<a href="#l1.28"></a><span id="l1.28">    */</span>
<a href="#l1.29"></a><span id="l1.29">   cacheLookupMany: function gloda_colm_cacheLookupMany(aNounID, aIDMap,</span>
<a href="#l1.30"></a><span id="l1.30">       aTargetMap, aDoCache) {</span>
<a href="#l1.31"></a><span id="l1.31">     let foundCount = 0, notFoundCount = 0, notFound = {};</span>
<a href="#l1.32"></a><span id="l1.32"> </span>
<a href="#l1.33"></a><span id="l1.33">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l1.34"></a><span id="l1.34"> </span>
<a href="#l1.35"></a><span id="l1.35">     if (cache) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -2495,44 +2495,91 @@ var GlodaDatastore = {</span>
<a href="#l2.4"></a><span id="l2.4">    *  database locations.  Also, update the in-memory representations.</span>
<a href="#l2.5"></a><span id="l2.5">    */</span>
<a href="#l2.6"></a><span id="l2.6">   updateMessageLocations: function gloda_ds_updateMessageLocations(aMessageIds,</span>
<a href="#l2.7"></a><span id="l2.7">       aNewMessageKeys, aDestFolder, aDoNotNotify) {</span>
<a href="#l2.8"></a><span id="l2.8">     let statement = this._updateMessageLocationStatement;</span>
<a href="#l2.9"></a><span id="l2.9">     let destFolderID = (typeof(aDestFolder) == &quot;number&quot;) ? aDestFolder :</span>
<a href="#l2.10"></a><span id="l2.10">                          this._mapFolder(aDestFolder).id;</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-    let modifiedItems = [];</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+    // map gloda id to the new message key for in-memory rep transform below</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+    let cacheLookupMap = {};</span>
<a href="#l2.15"></a><span id="l2.15"> </span>
<a href="#l2.16"></a><span id="l2.16">     for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineminus">-      let id = aMessageIds[iMsg];</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+      let id = aMessageIds[iMsg], msgKey = aNewMessageKeys[iMsg];</span>
<a href="#l2.19"></a><span id="l2.19">       statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineminus">-      statement.bindInt64Parameter(1, aNewMessageKeys[iMsg]);</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+      statement.bindInt64Parameter(1, msgKey);</span>
<a href="#l2.22"></a><span id="l2.22">       statement.bindInt64Parameter(2, id);</span>
<a href="#l2.23"></a><span id="l2.23">       statement.executeAsync(this.trackAsync());</span>
<a href="#l2.24"></a><span id="l2.24"> </span>
<a href="#l2.25"></a><span id="l2.25" class="difflineminus">-      // so, if the message is currently loaded, we also need to change it up...</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineminus">-      // XXX we should be using cacheLookupMany.</span>
<a href="#l2.27"></a><span id="l2.27" class="difflineminus">-      let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineminus">-        GlodaMessage.prototype.NOUN_ID, id);</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineminus">-      if (message) {</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineminus">-        message._folderID = destFolderID;</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-        message._messageKey = aNewMessageKeys[iMsg];</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineminus">-        modifiedItems.push(message);</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineminus">-      }</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+      cacheLookupMap[id] = msgKey;</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+    }</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+    // - perform the cache lookup so we can update in-memory representations</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+    // found in memory items, and converted to list form for notification</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+    let inMemoryItems = {}, modifiedItems = [];</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+    GlodaCollectionManager.cacheLookupMany(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+                                           cacheLookupMap,</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+                                           inMemoryItems,</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+                                           /* do not cache */ false);</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+    for each (let [glodaId, glodaMsg] in Iterator(inMemoryItems)) {</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+      glodaMsg._folderID = destFolderID;</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+      glodaMsg._messageKey = cacheLookupMap[glodaId];</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+      modifiedItems.push(glodaMsg);</span>
<a href="#l2.48"></a><span id="l2.48">     }</span>
<a href="#l2.49"></a><span id="l2.49"> </span>
<a href="#l2.50"></a><span id="l2.50">     // tell the collection manager about the modified messages so it can update</span>
<a href="#l2.51"></a><span id="l2.51">     //  any existing views...</span>
<a href="#l2.52"></a><span id="l2.52">     if (!aDoNotNotify &amp;&amp; modifiedItems.length) {</span>
<a href="#l2.53"></a><span id="l2.53">       GlodaCollectionManager.itemsModified(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l2.54"></a><span id="l2.54">                                            modifiedItems);</span>
<a href="#l2.55"></a><span id="l2.55">     }</span>
<a href="#l2.56"></a><span id="l2.56">   },</span>
<a href="#l2.57"></a><span id="l2.57"> </span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+  get _updateMessageKeyStatement() {</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+      &quot;UPDATE messages SET messageKey = ?1 WHERE id = ?2&quot;);</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+    this.__defineGetter__(&quot;_updateMessageKeyStatement&quot;,</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+                          function() statement);</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+    return this._updateMessageKeyStatement;</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+  },</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineplus">+  /**</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+   * Update the message keys for the gloda messages with the given id's.  This</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+   *  is to be used in response to msgKeyChanged notifications and is similar to</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+   *  `updateMessageLocations` except that we do not update the folder and we</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+   *  do not perform itemsModified notifications (because message keys are not</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+   *  intended to be relevant to the gloda message abstraction).</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+   */</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+  updateMessageKeys: function(aMessageIds, aNewMessageKeys) {</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+    let statement = this._updateMessageKeyStatement;</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+    // map gloda id to the new message key for in-memory rep transform below</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+    let cacheLookupMap = {};</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+    for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+      let id = aMessageIds[iMsg], msgKey = aNewMessageKeys[iMsg];</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+      statement.bindInt64Parameter(0, msgKey);</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+      statement.bindInt64Parameter(1, id);</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+      statement.executeAsync(this.trackAsync());</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+      cacheLookupMap[id] = msgKey;</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+    }</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+    // - perform the cache lookup so we can update in-memory representations</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+    let inMemoryItems = {};</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineplus">+    GlodaCollectionManager.cacheLookupMany(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineplus">+                                           cacheLookupMap,</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineplus">+                                           inMemoryItems,</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineplus">+                                           /* do not cache */ false);</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineplus">+    for each (let [glodaId, glodaMsg] in Iterator(inMemoryItems)) {</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineplus">+      glodaMsg._messageKey = cacheLookupMap[glodaId];</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineplus">+    }</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineplus">+  },</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineplus">+</span>
<a href="#l2.99"></a><span id="l2.99">   /**</span>
<a href="#l2.100"></a><span id="l2.100">    * Asynchronously mutate message folder id/message keys for the given</span>
<a href="#l2.101"></a><span id="l2.101">    *  messages, indicating that we are moving them to the target folder, but</span>
<a href="#l2.102"></a><span id="l2.102">    *  don't yet know their target message keys.</span>
<a href="#l2.103"></a><span id="l2.103">    *</span>
<a href="#l2.104"></a><span id="l2.104">    * Updates in-memory representations too.</span>
<a href="#l2.105"></a><span id="l2.105">    */</span>
<a href="#l2.106"></a><span id="l2.106">   updateMessageFoldersByKeyPurging:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -122,16 +122,22 @@ function range(begin, end) {</span>
<a href="#l3.4"></a><span id="l3.4"> /**</span>
<a href="#l3.5"></a><span id="l3.5">  * We do not set properties on the messages until we perform a DB commit; this</span>
<a href="#l3.6"></a><span id="l3.6">  *  helper class tracks messages that we have indexed but are not yet marked</span>
<a href="#l3.7"></a><span id="l3.7">  *  as such on their header.</span>
<a href="#l3.8"></a><span id="l3.8">  */</span>
<a href="#l3.9"></a><span id="l3.9"> var PendingCommitTracker = {</span>
<a href="#l3.10"></a><span id="l3.10">   /**</span>
<a href="#l3.11"></a><span id="l3.11">    * Maps message URIs to their gloda ids.</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+   *</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+   * I am not entirely sure why I chose the URI for the key rather than</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+   *  gloda folder ID + message key.  Most likely it was to simplify debugging</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+   *  since the gloda folder ID is opaque while the URI is very informative.  It</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+   *  is also possible I was afraid of IMAP folder renaming triggering a UID</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+   *  renumbering?</span>
<a href="#l3.18"></a><span id="l3.18">    */</span>
<a href="#l3.19"></a><span id="l3.19">   _indexedMessagesPendingCommitByKey: {},</span>
<a href="#l3.20"></a><span id="l3.20">   /**</span>
<a href="#l3.21"></a><span id="l3.21">    * Map from the pending commit gloda id to a tuple of [the corresponding</span>
<a href="#l3.22"></a><span id="l3.22">    *  message header, dirtyState].</span>
<a href="#l3.23"></a><span id="l3.23">    */</span>
<a href="#l3.24"></a><span id="l3.24">   _indexedMessagesPendingCommitByGlodaId: {},</span>
<a href="#l3.25"></a><span id="l3.25">   /**</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineat">@@ -268,20 +274,23 @@ var PendingCommitTracker = {</span>
<a href="#l3.27"></a><span id="l3.27">     this._indexedMessagesPendingCommitByKey[newKey] = glodaId;</span>
<a href="#l3.28"></a><span id="l3.28"> </span>
<a href="#l3.29"></a><span id="l3.29">     // only clobber the header, not the dirty state</span>
<a href="#l3.30"></a><span id="l3.30">     this._indexedMessagesPendingCommitByGlodaId[glodaId][0] = aNewHdr;</span>
<a href="#l3.31"></a><span id="l3.31">   },</span>
<a href="#l3.32"></a><span id="l3.32"> </span>
<a href="#l3.33"></a><span id="l3.33">   /**</span>
<a href="#l3.34"></a><span id="l3.34">    * A blind move is one where we have the source header but not the destination</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineminus">-   *  header.  This happens for IMAP messages.</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+   *  header.  This happens for IMAP messages that do not involve offline fake</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+   *  headers.</span>
<a href="#l3.38"></a><span id="l3.38">    * XXX Since IMAP moves will propagate the gloda-id/gloda-dirty bits for us,</span>
<a href="#l3.39"></a><span id="l3.39">    *  we could detect the other side of the move when it shows up as a</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineminus">-   *  msgsClassified event and restore the mapping information.</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+   *  msgsClassified event and restore the mapping information.  Since the</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+   *  offline fake header case should now cover the bulk of IMAP move</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+   *  operations, we probably do not need to pursue this.</span>
<a href="#l3.44"></a><span id="l3.44">    *</span>
<a href="#l3.45"></a><span id="l3.45">    * We just re-dispatch to noteDirtyHeader because we can't do anything more</span>
<a href="#l3.46"></a><span id="l3.46">    *  clever.</span>
<a href="#l3.47"></a><span id="l3.47">    */</span>
<a href="#l3.48"></a><span id="l3.48">   noteBlindMove: function PendingCommitTracker_noteBlindMove(aOldHdr) {</span>
<a href="#l3.49"></a><span id="l3.49">     this.noteDirtyHeader(aOldHdr);</span>
<a href="#l3.50"></a><span id="l3.50">   },</span>
<a href="#l3.51"></a><span id="l3.51"> </span>
<a href="#l3.52"></a><span id="l3.52" class="difflineat">@@ -1883,40 +1892,106 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.53"></a><span id="l3.53">     let [glodaId, glodaDirty] = PendingCommitTracker.getGlodaState(aMsgHdr);</span>
<a href="#l3.54"></a><span id="l3.54">     return glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l3.55"></a><span id="l3.55">            glodaDirty != GlodaMsgIndexer.kMessageFilthy &amp;&amp;</span>
<a href="#l3.56"></a><span id="l3.56">            glodaFolder &amp;&amp;</span>
<a href="#l3.57"></a><span id="l3.57">            glodaFolder.dirtyStatus != glodaFolder.kFolderFilthy;</span>
<a href="#l3.58"></a><span id="l3.58">   },</span>
<a href="#l3.59"></a><span id="l3.59"> </span>
<a href="#l3.60"></a><span id="l3.60">   /* *********** Event Processing *********** */</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+  /**</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+   * Tracks messages we have received msgKeyChanged notifications for in order</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+   *  to provide batching and to suppress needless reindexing when we receive</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+   *  the expected follow-up msgsClassified notification.</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+   *</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+   * The entries in this dictionary should be extremely short-lived as we</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+   *  receive the msgKeyChanged notification as the offline fake header is</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+   *  converted into a real header (which is accompanied by a msgAdded</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+   *  notification we don't pay attention to).  Once the headers finish</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+   *  updating, the message classifier will get its at-bat and should likely</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+   *  find that the messages have already been classified and so fast-path</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+   *  them.</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+   *</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+   * The keys in this dictionary are chosen to be consistent with those of</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+   *  PendingCommitTracker: the folder.URI + &quot;#&quot; + the (new) message key.</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+   * The values in the dictionary are either an object with &quot;id&quot; (the gloda</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+   *  id), &quot;key&quot; (the new message key), and &quot;dirty&quot; (is it dirty and so</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+   *  should still be queued for indexing) attributes, or null indicating that</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+   *  no change in message key occurred and so no database changes are required.</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+   */</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+  _keyChangedBatchInfo: {},</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+</span>
<a href="#l3.84"></a><span id="l3.84">   /**</span>
<a href="#l3.85"></a><span id="l3.85">    * Common logic for things that want to feed event-driven indexing.  This gets</span>
<a href="#l3.86"></a><span id="l3.86">    *  called by both |_msgFolderListener.msgsClassified| when we are first</span>
<a href="#l3.87"></a><span id="l3.87">    *  seeing a message as well as by |_folderListener| when things happen to</span>
<a href="#l3.88"></a><span id="l3.88">    *  existing messages.  Although we could slightly specialize for the</span>
<a href="#l3.89"></a><span id="l3.89">    *  new-to-us case, it works out to be cleaner to just treat them the same</span>
<a href="#l3.90"></a><span id="l3.90">    *  and take a very small performance hit.</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+   *</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+   * @param aMsgHdrs Something fixIterator will work on to return an iterator</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+   *     on the set of messages that we should treat as potentially changed.</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+   * @param aDirtyingEvent Is this event inherently dirtying?  Receiving a</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+   *     msgsClassified notification is not inherently dirtying because it is</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+   *     just telling us that a message exists.  We use this knowledge to</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+   *     ignore the msgsClassified notifications for messages we have received</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+   *     msgKeyChanged notifications for and fast-pathed.  Since it is possible</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+   *     for user action to do something that dirties the message between the</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+   *     time we get the msgKeyChanged notification and when we receive the</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+   *     msgsClassified notification, we want to make sure we don't get</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+   *     confused.  (Although since we remove the message from our ignore-set</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+   *     after the first notification, we would likely just mistakenly treat</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+   *     the msgsClassified notification as something dirtying, so it would</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+   *     still work out...)</span>
<a href="#l3.106"></a><span id="l3.106">    */</span>
<a href="#l3.107"></a><span id="l3.107">   _reindexChangedMessages: function gloda_indexer_reindexChangedMessage(</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineminus">-    aMsgHdrs) {</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+                                      aMsgHdrs, aDirtyingEvent) {</span>
<a href="#l3.110"></a><span id="l3.110">     let glodaIdsNeedingDeletion = null;</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineplus">+    let messageKeyChangedIds = null, messageKeyChangedNewKeys = null;</span>
<a href="#l3.112"></a><span id="l3.112">     for each (let msgHdr in fixIterator(aMsgHdrs, nsIMsgDBHdr)) {</span>
<a href="#l3.113"></a><span id="l3.113">       // -- Index this folder?</span>
<a href="#l3.114"></a><span id="l3.114">       let msgFolder = msgHdr.folder;</span>
<a href="#l3.115"></a><span id="l3.115">       if (!this.shouldIndexFolder(msgFolder)) {</span>
<a href="#l3.116"></a><span id="l3.116">         continue;</span>
<a href="#l3.117"></a><span id="l3.117">       }</span>
<a href="#l3.118"></a><span id="l3.118">       // -- Ignore messages in filthy folders!</span>
<a href="#l3.119"></a><span id="l3.119">       // A filthy folder can only be processed by an indexing sweep, and at</span>
<a href="#l3.120"></a><span id="l3.120">       //  that point the message will get indexed.</span>
<a href="#l3.121"></a><span id="l3.121">       let glodaFolder = GlodaDatastore._mapFolder(msgHdr.folder);</span>
<a href="#l3.122"></a><span id="l3.122">       if (glodaFolder.dirtyStatus == glodaFolder.kFolderFilthy)</span>
<a href="#l3.123"></a><span id="l3.123">         continue;</span>
<a href="#l3.124"></a><span id="l3.124"> </span>
<a href="#l3.125"></a><span id="l3.125" class="difflineplus">+      // -- msgKeyChanged event follow-up</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineplus">+      if (!aDirtyingEvent) {</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineplus">+        let keyChangedKey = msgHdr.folder.URI + &quot;#&quot; + msgHdr.messageKey;</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineplus">+        if (keyChangedKey in this._keyChangedBatchInfo) {</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+          var keyChangedInfo = this._keyChangedBatchInfo[keyChangedKey];</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+          delete this._keyChangedBatchInfo[keyChangedKey];</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+          // Null means to ignore this message because the key did not change</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineplus">+          //  (and the message was not dirty so it is safe to ignore.)</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+          if (keyChangedInfo == null)</span>
<a href="#l3.135"></a><span id="l3.135" class="difflineplus">+            continue;</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineplus">+          // (the key may be null if we only generated the entry because the</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineplus">+          //  message was dirty)</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineplus">+          if (keyChangedInfo.key !== null) {</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+            if (messageKeyChangedIds == null) {</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+              messageKeyChangedIds = [];</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineplus">+              messageKeyChangedNewKeys = [];</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineplus">+            }</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+            messageKeyChangedIds.push(keyChangedInfo.id);</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineplus">+            messageKeyChangedNewKeys.push(keyChangedInfo.key);</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineplus">+          }</span>
<a href="#l3.146"></a><span id="l3.146" class="difflineplus">+          // ignore the message because it was not dirty</span>
<a href="#l3.147"></a><span id="l3.147" class="difflineplus">+          if (!keyChangedInfo.isDirty)</span>
<a href="#l3.148"></a><span id="l3.148" class="difflineplus">+            continue;</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineplus">+        }</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+      }</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+</span>
<a href="#l3.152"></a><span id="l3.152">       // -- Index this message?</span>
<a href="#l3.153"></a><span id="l3.153">       // We index local messages, IMAP messages that are offline, and IMAP</span>
<a href="#l3.154"></a><span id="l3.154">       // messages that aren't offline but whose folders aren't offline either</span>
<a href="#l3.155"></a><span id="l3.155">       let isFolderLocal = msgFolder instanceof nsIMsgLocalMailFolder;</span>
<a href="#l3.156"></a><span id="l3.156">       if (!isFolderLocal) {</span>
<a href="#l3.157"></a><span id="l3.157">         if (!(msgHdr.flags &amp; nsMsgMessageFlags.Offline) &amp;&amp;</span>
<a href="#l3.158"></a><span id="l3.158">             (msgFolder.flags &amp; nsMsgFolderFlags.Offline)) {</span>
<a href="#l3.159"></a><span id="l3.159">           continue;</span>
<a href="#l3.160"></a><span id="l3.160" class="difflineat">@@ -1978,16 +2053,21 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.161"></a><span id="l3.161">         this._pendingAddJob.items.push(</span>
<a href="#l3.162"></a><span id="l3.162">           [GlodaDatastore._mapFolder(msgFolder).id, msgHdr.messageKey]);</span>
<a href="#l3.163"></a><span id="l3.163">       }</span>
<a href="#l3.164"></a><span id="l3.164">       else {</span>
<a href="#l3.165"></a><span id="l3.165">         this.indexingSweepNeeded = true;</span>
<a href="#l3.166"></a><span id="l3.166">       }</span>
<a href="#l3.167"></a><span id="l3.167">     }</span>
<a href="#l3.168"></a><span id="l3.168"> </span>
<a href="#l3.169"></a><span id="l3.169" class="difflineplus">+    // Process any message key changes (from earlier msgKeyChanged events)</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+    if (messageKeyChangedIds != null)</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineplus">+      GlodaDatastore.updateMessageKeys(messageKeyChangedIds,</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+                                       messageKeyChangedNewKeys);</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+</span>
<a href="#l3.174"></a><span id="l3.174">     // If we accumulated any deletions in there, batch them off now.</span>
<a href="#l3.175"></a><span id="l3.175">     if (glodaIdsNeedingDeletion) {</span>
<a href="#l3.176"></a><span id="l3.176">       GlodaDatastore.markMessagesDeletedByIDs(glodaIdsNeedingDeletion);</span>
<a href="#l3.177"></a><span id="l3.177">       this.pendingDeletions = true;</span>
<a href="#l3.178"></a><span id="l3.178">     }</span>
<a href="#l3.179"></a><span id="l3.179">   },</span>
<a href="#l3.180"></a><span id="l3.180"> </span>
<a href="#l3.181"></a><span id="l3.181"> </span>
<a href="#l3.182"></a><span id="l3.182" class="difflineat">@@ -2010,26 +2090,32 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.183"></a><span id="l3.183">      *  junk/trait classification has run (or decided not to run) and all</span>
<a href="#l3.184"></a><span id="l3.184">      *  filters have run.  The msgsClassified notification provides that for us.</span>
<a href="#l3.185"></a><span id="l3.185">      */</span>
<a href="#l3.186"></a><span id="l3.186">     msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l3.187"></a><span id="l3.187">       // we are never called! we do not enable this bit!</span>
<a href="#l3.188"></a><span id="l3.188">     },</span>
<a href="#l3.189"></a><span id="l3.189"> </span>
<a href="#l3.190"></a><span id="l3.190">     /**</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineminus">-     * XXX We treat all messages we see as if they have undergone a dirtying</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineminus">-     *  event.  However, we should really be leveraging the hard work of the</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineminus">-     *  mailnews IMAP subsystem to fast-path the IMAP move case and just</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineminus">-     *  update the location information.</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+     * Process (apparently newly added) messages that have been looked at by</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+     *  the message classifier.  This ensures that if the message was going</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+     *  to get marked as spam, this will have already happened.</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+     *</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+     * Besides truly new (to us) messages, We will also receive this event for</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+     *  messages that are the result of IMAP message move/copy operations,</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+     *  including both moves that generated offline fake headers and those that</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+     *  did not.  In the offline fake header case, however, we are able to</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+     *  ignore their msgsClassified events because we will have received a</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+     *  msgKeyChanged notification sometime in the recent past.</span>
<a href="#l3.205"></a><span id="l3.205">      */</span>
<a href="#l3.206"></a><span id="l3.206">     msgsClassified: function gloda_indexer_msgsClassified(</span>
<a href="#l3.207"></a><span id="l3.207">                       aMsgHdrs, aJunkClassified, aTraitClassified) {</span>
<a href="#l3.208"></a><span id="l3.208">       this.indexer._log.debug(&quot;msgsClassified notification&quot;);</span>
<a href="#l3.209"></a><span id="l3.209">       try {</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineminus">-        GlodaMsgIndexer._reindexChangedMessages(aMsgHdrs.enumerate());</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+        GlodaMsgIndexer._reindexChangedMessages(aMsgHdrs.enumerate(), false);</span>
<a href="#l3.212"></a><span id="l3.212">       }</span>
<a href="#l3.213"></a><span id="l3.213">       catch (ex) {</span>
<a href="#l3.214"></a><span id="l3.214">         this.indexer._log.error(&quot;Explosion in msgsClassified handling: &quot; +</span>
<a href="#l3.215"></a><span id="l3.215">                                 ex.stack);</span>
<a href="#l3.216"></a><span id="l3.216">       }</span>
<a href="#l3.217"></a><span id="l3.217">     },</span>
<a href="#l3.218"></a><span id="l3.218"> </span>
<a href="#l3.219"></a><span id="l3.219">     /**</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineat">@@ -2061,33 +2147,33 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.221"></a><span id="l3.221">         GlodaMsgIndexer._datastore.markMessagesDeletedByIDs(glodaMessageIds);</span>
<a href="#l3.222"></a><span id="l3.222">         GlodaMsgIndexer.pendingDeletions = true;</span>
<a href="#l3.223"></a><span id="l3.223">       }</span>
<a href="#l3.224"></a><span id="l3.224">     },</span>
<a href="#l3.225"></a><span id="l3.225"> </span>
<a href="#l3.226"></a><span id="l3.226">     /**</span>
<a href="#l3.227"></a><span id="l3.227">      * Process a move or copy.</span>
<a href="#l3.228"></a><span id="l3.228">      *</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineminus">-     * Moves to a local folder are dealt with efficiently because we get both</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineminus">-     *  the source and destination headers.  The only non-obvious thing is that</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineminus">-     *  we need to make sure that we deal with the impact of filthy folders and</span>
<a href="#l3.232"></a><span id="l3.232" class="difflineminus">-     *  messages on gloda-id's (they invalidate the gloda-id).</span>
<a href="#l3.233"></a><span id="l3.233" class="difflineplus">+     * Moves to a local folder or an IMAP folder where we are generating offline</span>
<a href="#l3.234"></a><span id="l3.234" class="difflineplus">+     *  fake headers are dealt with efficiently because we get both the source</span>
<a href="#l3.235"></a><span id="l3.235" class="difflineplus">+     *  and destination headers.  The main ingredient to having offline fake</span>
<a href="#l3.236"></a><span id="l3.236" class="difflineplus">+     *  headers is that allowUndo was true when the operation was performance.</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineplus">+     *  The only non-obvious thing is that we need to make sure that we deal</span>
<a href="#l3.238"></a><span id="l3.238" class="difflineplus">+     *  with the impact of filthy folders and messages on gloda-id's (they</span>
<a href="#l3.239"></a><span id="l3.239" class="difflineplus">+     *  invalidate the gloda-id).</span>
<a href="#l3.240"></a><span id="l3.240">      *</span>
<a href="#l3.241"></a><span id="l3.241" class="difflineminus">-     * Moves to an IMAP folder do not provide us with the target header, but the</span>
<a href="#l3.242"></a><span id="l3.242" class="difflineminus">-     *  IMAP code does have support for propagating properties on the message</span>
<a href="#l3.243"></a><span id="l3.243" class="difflineminus">-     *  header so when we see it in the msgsClassified (or msgAdded if we used</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineminus">-     *  that anymore), it should have the properties of the source message</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineminus">-     *  copied over.</span>
<a href="#l3.246"></a><span id="l3.246" class="difflineplus">+     * Moves to an IMAP folder that do not generate offline fake headers do not</span>
<a href="#l3.247"></a><span id="l3.247" class="difflineplus">+     *  provide us with the target header, but the IMAP SetPendingAttributes</span>
<a href="#l3.248"></a><span id="l3.248" class="difflineplus">+     *  logic will still attempt to propagate the properties on the message</span>
<a href="#l3.249"></a><span id="l3.249" class="difflineplus">+     *  header so when we eventually see it in the msgsClassified notification,</span>
<a href="#l3.250"></a><span id="l3.250" class="difflineplus">+     *  it should have the properties of the source message copied over.</span>
<a href="#l3.251"></a><span id="l3.251">      * We make sure that gloda-id's do not get propagated when messages are</span>
<a href="#l3.252"></a><span id="l3.252">      *  moved from IMAP folders that are marked filthy or are marked as not</span>
<a href="#l3.253"></a><span id="l3.253">      *  supposed to be indexed by clearing the pending attributes for the header</span>
<a href="#l3.254"></a><span id="l3.254">      *  being tracked by the destination IMAP folder.</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineminus">-     * XXX We will receive a msgsClassified event for each message, so the</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineminus">-     *  main thing we need to do is provide a hint to the indexing logic that</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineminus">-     *  the gloda message in question should be reused and is not a duplicate.</span>
<a href="#l3.258"></a><span id="l3.258">      * We could fast-path the IMAP move case in msgsClassified by noticing that</span>
<a href="#l3.259"></a><span id="l3.259">      *  a message is showing up with a gloda-id header already and just</span>
<a href="#l3.260"></a><span id="l3.260">      *  performing an async location update.</span>
<a href="#l3.261"></a><span id="l3.261">      *</span>
<a href="#l3.262"></a><span id="l3.262">      * Moves that occur involving 'compacted' folders are fine and do not</span>
<a href="#l3.263"></a><span id="l3.263">      *  require special handling here.  The one tricky super-edge-case that</span>
<a href="#l3.264"></a><span id="l3.264">      *  can happen (and gets handled by the compaction pass) is the move of a</span>
<a href="#l3.265"></a><span id="l3.265">      *  message that got gloda indexed that did not already have a gloda-id and</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineat">@@ -2299,20 +2385,55 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.267"></a><span id="l3.267">           this.indexer.indexingSweepNeeded = true;</span>
<a href="#l3.268"></a><span id="l3.268">         }</span>
<a href="#l3.269"></a><span id="l3.269">       } catch (ex) {</span>
<a href="#l3.270"></a><span id="l3.270">         this.indexer._log.error(&quot;Problem encountered during message move/copy&quot; +</span>
<a href="#l3.271"></a><span id="l3.271">           &quot;: &quot; + ex + &quot;\n\n&quot; + ex.stack + &quot;\n\n&quot;);</span>
<a href="#l3.272"></a><span id="l3.272">       }</span>
<a href="#l3.273"></a><span id="l3.273">     },</span>
<a href="#l3.274"></a><span id="l3.274"> </span>
<a href="#l3.275"></a><span id="l3.275" class="difflineplus">+    /**</span>
<a href="#l3.276"></a><span id="l3.276" class="difflineplus">+     * Queue up message key changes that are a result of offline fake headers</span>
<a href="#l3.277"></a><span id="l3.277" class="difflineplus">+     *  being made real for the actual update during the msgsClassified</span>
<a href="#l3.278"></a><span id="l3.278" class="difflineplus">+     *  notification that is expected after this.  We defer the</span>
<a href="#l3.279"></a><span id="l3.279" class="difflineplus">+     *  actual work (if there is any to be done; the fake header might have</span>
<a href="#l3.280"></a><span id="l3.280" class="difflineplus">+     *  guessed the right UID correctly) so that we can batch our work.</span>
<a href="#l3.281"></a><span id="l3.281" class="difflineplus">+     *</span>
<a href="#l3.282"></a><span id="l3.282" class="difflineplus">+     * The expectation is that there will be no meaningful time window between</span>
<a href="#l3.283"></a><span id="l3.283" class="difflineplus">+     *  this notification and the msgsClassified notification since the message</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineplus">+     *  classifier should not actually need to classify the messages (they</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineplus">+     *  should already have been classified) and so can fast-path them.</span>
<a href="#l3.286"></a><span id="l3.286" class="difflineplus">+     */</span>
<a href="#l3.287"></a><span id="l3.287">     msgKeyChanged: function gloda_indexer_msgKeyChangeded(aOldMsgKey,</span>
<a href="#l3.288"></a><span id="l3.288">                              aNewMsgHdr) {</span>
<a href="#l3.289"></a><span id="l3.289" class="difflineminus">-      this.indexer._log.debug(&quot;MsgKeyChanged notification. &quot; + aOldMsgKey +</span>
<a href="#l3.290"></a><span id="l3.290" class="difflineminus">-                              &quot; to &quot; + aNewMsgHdr.msgKey);</span>
<a href="#l3.291"></a><span id="l3.291" class="difflineplus">+      try {</span>
<a href="#l3.292"></a><span id="l3.292" class="difflineplus">+        let val = null, newKey = aNewMsgHdr.messageKey;</span>
<a href="#l3.293"></a><span id="l3.293" class="difflineplus">+        let [glodaId, glodaDirty] =</span>
<a href="#l3.294"></a><span id="l3.294" class="difflineplus">+          PendingCommitTracker.getGlodaState(aNewMsgHdr);</span>
<a href="#l3.295"></a><span id="l3.295" class="difflineplus">+        // take no action on filthy messages,</span>
<a href="#l3.296"></a><span id="l3.296" class="difflineplus">+        // generate an entry if dirty or the keys don't match.</span>
<a href="#l3.297"></a><span id="l3.297" class="difflineplus">+        if ((glodaDirty !== GlodaMsgIndexer.kMessageFilthy) &amp;&amp;</span>
<a href="#l3.298"></a><span id="l3.298" class="difflineplus">+            ((glodaDirty === GlodaMsgIndexer.kMessageDirty) ||</span>
<a href="#l3.299"></a><span id="l3.299" class="difflineplus">+             (aOldMsgKey !== newKey))) {</span>
<a href="#l3.300"></a><span id="l3.300" class="difflineplus">+          val = {</span>
<a href="#l3.301"></a><span id="l3.301" class="difflineplus">+            id: glodaId,</span>
<a href="#l3.302"></a><span id="l3.302" class="difflineplus">+            key: (aOldMsgKey !== newKey) ? newKey : null,</span>
<a href="#l3.303"></a><span id="l3.303" class="difflineplus">+            isDirty: glodaDirty === GlodaMsgIndexer.kMessageDirty,</span>
<a href="#l3.304"></a><span id="l3.304" class="difflineplus">+          };</span>
<a href="#l3.305"></a><span id="l3.305" class="difflineplus">+        }</span>
<a href="#l3.306"></a><span id="l3.306" class="difflineplus">+</span>
<a href="#l3.307"></a><span id="l3.307" class="difflineplus">+        let key = aNewMsgHdr.folder.URI + &quot;#&quot; + aNewMsgHdr.messageKey;</span>
<a href="#l3.308"></a><span id="l3.308" class="difflineplus">+        this.indexer._keyChangedBatchInfo[key] = val;</span>
<a href="#l3.309"></a><span id="l3.309" class="difflineplus">+      }</span>
<a href="#l3.310"></a><span id="l3.310" class="difflineplus">+      // this is more for the unit test to fail rather than user error reporting</span>
<a href="#l3.311"></a><span id="l3.311" class="difflineplus">+      catch (ex) {</span>
<a href="#l3.312"></a><span id="l3.312" class="difflineplus">+        this.indexer._log.error(&quot;Problem encountered during msgKeyChanged&quot; +</span>
<a href="#l3.313"></a><span id="l3.313" class="difflineplus">+                                &quot; notification handling: &quot; + ex + &quot;\n\n&quot; +</span>
<a href="#l3.314"></a><span id="l3.314" class="difflineplus">+                                ex.stack + &quot; \n\n&quot;);</span>
<a href="#l3.315"></a><span id="l3.315" class="difflineplus">+      }</span>
<a href="#l3.316"></a><span id="l3.316">     },</span>
<a href="#l3.317"></a><span id="l3.317">     /**</span>
<a href="#l3.318"></a><span id="l3.318">      * Handles folder no-longer-exists-ence.  We mark all messages as deleted</span>
<a href="#l3.319"></a><span id="l3.319">      *  and remove the folder from our URI table.  Currently, if a folder that</span>
<a href="#l3.320"></a><span id="l3.320">      *  contains other folders is deleted, we may either receive one</span>
<a href="#l3.321"></a><span id="l3.321">      *  notification for the folder that is deleted, or a notification for the</span>
<a href="#l3.322"></a><span id="l3.322">      *  folder and one for each of its descendents.  This depends upon the</span>
<a href="#l3.323"></a><span id="l3.323">      *  underlying account implementation, so we explicitly handle each case.</span>
<a href="#l3.324"></a><span id="l3.324" class="difflineat">@@ -2494,17 +2615,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.325"></a><span id="l3.325">         //  indexing sweep queued or active, and if it's already active that</span>
<a href="#l3.326"></a><span id="l3.326">         //  this folder is in the queue to be processed.)</span>
<a href="#l3.327"></a><span id="l3.327">         if (glodaFolder.dirtyStatus == glodaFolder.kFolderDirty)</span>
<a href="#l3.328"></a><span id="l3.328">           GlodaIndexer.indexJob(new IndexingJob(&quot;folder&quot;, glodaFolder.id));</span>
<a href="#l3.329"></a><span id="l3.329">       }</span>
<a href="#l3.330"></a><span id="l3.330">       else if (aEvent == &quot;JunkStatusChanged&quot;) {</span>
<a href="#l3.331"></a><span id="l3.331">         this.indexer._log.debug(&quot;JunkStatusChanged notification&quot;);</span>
<a href="#l3.332"></a><span id="l3.332">         aItem.QueryInterface(Ci.nsIArray);</span>
<a href="#l3.333"></a><span id="l3.333" class="difflineminus">-        GlodaMsgIndexer._reindexChangedMessages(aItem.enumerate());</span>
<a href="#l3.334"></a><span id="l3.334" class="difflineplus">+        GlodaMsgIndexer._reindexChangedMessages(aItem.enumerate(), true);</span>
<a href="#l3.335"></a><span id="l3.335">       }</span>
<a href="#l3.336"></a><span id="l3.336">     },</span>
<a href="#l3.337"></a><span id="l3.337">   },</span>
<a href="#l3.338"></a><span id="l3.338"> </span>
<a href="#l3.339"></a><span id="l3.339">   /**</span>
<a href="#l3.340"></a><span id="l3.340">    * A nsIFolderListener (listening on nsIMsgMailSession so we get all of</span>
<a href="#l3.341"></a><span id="l3.341">    *  these events) PRIMARILY to get folder loaded notifications.  Because of</span>
<a href="#l3.342"></a><span id="l3.342">    *  deficiencies in the nsIMsgFolderListener's events at this time, we also</span>
<a href="#l3.343"></a><span id="l3.343" class="difflineat">@@ -2553,17 +2674,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.344"></a><span id="l3.344">       if (aProperty == this._kKeywordsAtom ||</span>
<a href="#l3.345"></a><span id="l3.345">           // We could care less about the new flag changing.</span>
<a href="#l3.346"></a><span id="l3.346">           (aProperty == this._kStatusAtom &amp;&amp;</span>
<a href="#l3.347"></a><span id="l3.347">            (aOldValue ^ aNewValue) != nsMsgMessageFlags.New &amp;&amp;</span>
<a href="#l3.348"></a><span id="l3.348">            // We do care about IMAP deletion, but msgsDeleted tells us that, so</span>
<a href="#l3.349"></a><span id="l3.349">            //  ignore IMAPDeleted too...</span>
<a href="#l3.350"></a><span id="l3.350">            (aOldValue ^ aNewValue) != nsMsgMessageFlags.IMAPDeleted) ||</span>
<a href="#l3.351"></a><span id="l3.351">           aProperty == this._kFlaggedAtom) {</span>
<a href="#l3.352"></a><span id="l3.352" class="difflineminus">-        GlodaMsgIndexer._reindexChangedMessages([aMsgHdr]);</span>
<a href="#l3.353"></a><span id="l3.353" class="difflineplus">+        GlodaMsgIndexer._reindexChangedMessages([aMsgHdr], true);</span>
<a href="#l3.354"></a><span id="l3.354">       }</span>
<a href="#l3.355"></a><span id="l3.355">     },</span>
<a href="#l3.356"></a><span id="l3.356"> </span>
<a href="#l3.357"></a><span id="l3.357">     /**</span>
<a href="#l3.358"></a><span id="l3.358">      * Get folder loaded notifications for folders that had to do some</span>
<a href="#l3.359"></a><span id="l3.359">      *  (asynchronous) processing before they could be opened.</span>
<a href="#l3.360"></a><span id="l3.360">      */</span>
<a href="#l3.361"></a><span id="l3.361">     OnItemEvent: function gloda_indexer_OnItemEvent(aFolder, aEvent) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -893,60 +893,70 @@ function test_imap_add_unread_to_folder(</span>
<a href="#l4.4"></a><span id="l4.4">   yield wait_for_message_injection();</span>
<a href="#l4.5"></a><span id="l4.5">   yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l4.6"></a><span id="l4.6"> }</span>
<a href="#l4.7"></a><span id="l4.7"> </span>
<a href="#l4.8"></a><span id="l4.8"> /* ===== Message Moving ===== */</span>
<a href="#l4.9"></a><span id="l4.9"> </span>
<a href="#l4.10"></a><span id="l4.10"> /**</span>
<a href="#l4.11"></a><span id="l4.11">  * Moving a message between folders should result in us knowing that the message</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">- *  is in the target location.  In the case of local moves, this happens</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">- *  automatically.  In the case of IMAP moves, we need to force the target folder</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineminus">- *  to be updated.</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineminus">- *</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">- * @todo Implication of UIDPLUS on IMAP are not understood / tested.</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+ *  is in the target location.</span>
<a href="#l4.18"></a><span id="l4.18">  */</span>
<a href="#l4.19"></a><span id="l4.19"> function test_message_moving() {</span>
<a href="#l4.20"></a><span id="l4.20">   // - inject and insert</span>
<a href="#l4.21"></a><span id="l4.21">   // source folder with the message we care about</span>
<a href="#l4.22"></a><span id="l4.22">   let [srcFolder, msgSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l4.23"></a><span id="l4.23">   yield wait_for_message_injection();</span>
<a href="#l4.24"></a><span id="l4.24">   // dest folder with some messages in it to test some wacky local folder moving</span>
<a href="#l4.25"></a><span id="l4.25">   //  logic.  (Local moves try and update the correspondence immediately.)</span>
<a href="#l4.26"></a><span id="l4.26">   let [destFolder, ignoreSet] = make_folder_with_sets([{count: 2}]);</span>
<a href="#l4.27"></a><span id="l4.27">   yield wait_for_message_injection();</span>
<a href="#l4.28"></a><span id="l4.28"> </span>
<a href="#l4.29"></a><span id="l4.29" class="difflineminus">-</span>
<a href="#l4.30"></a><span id="l4.30">   // (we want the gloda message mapping...)</span>
<a href="#l4.31"></a><span id="l4.31">   yield wait_for_gloda_indexer([msgSet, ignoreSet], {augment: true});</span>
<a href="#l4.32"></a><span id="l4.32">   let gmsg = msgSet.glodaMessages[0];</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+  // save off the message key so we can make sure it changes.</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+  let oldMessageKey = msgSet.getMsgHdr(0).messageKey;</span>
<a href="#l4.35"></a><span id="l4.35"> </span>
<a href="#l4.36"></a><span id="l4.36" class="difflineminus">-  // - move it to a new folder</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+  // - fastpath (offline) move it to a new folder</span>
<a href="#l4.38"></a><span id="l4.38">   mark_sub_test_start(&quot;initial move&quot;);</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineminus">-  yield async_move_messages(msgSet, destFolder);</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+  yield async_move_messages(msgSet, destFolder, true);</span>
<a href="#l4.41"></a><span id="l4.41"> </span>
<a href="#l4.42"></a><span id="l4.42">   // - make sure gloda sees it in the new folder</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineminus">-  // (In the local case, tThe move generates an itemsModified notification, so</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineminus">-  //  we see it as indexing traffic even if the indexer never goes active.)</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineminus">-  // (In the IMAP case, the message actually gets reindexed in the target</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineminus">-  //  folder.)</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineminus">-  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+  // Since we are doing offline IMAP moves, the fast-path should be taken and</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+  //  so we should receive an itemsModified notification without a call to</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+  //  Gloda.grokNounItem.</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet, {fullyIndexed: 0});</span>
<a href="#l4.52"></a><span id="l4.52"> </span>
<a href="#l4.53"></a><span id="l4.53">   do_check_eq(gmsg.folderURI,</span>
<a href="#l4.54"></a><span id="l4.54">               get_real_injection_folder(destFolder).URI);</span>
<a href="#l4.55"></a><span id="l4.55"> </span>
<a href="#l4.56"></a><span id="l4.56">   // - make sure the message key is correct!</span>
<a href="#l4.57"></a><span id="l4.57">   do_check_eq(gmsg.messageKey, msgSet.getMsgHdr(0).messageKey);</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineplus">+  // (sanity check that the messageKey actually changed for the message...)</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineplus">+  do_check_neq(gmsg.messageKey, oldMessageKey);</span>
<a href="#l4.60"></a><span id="l4.60"> </span>
<a href="#l4.61"></a><span id="l4.61" class="difflineminus">-  // - move it back to its origin folder</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+  // - make sure the indexer's _keyChangedBatchInfo dict is empty</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+  for each (let [evilKey, evilValue] in</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+              Iterator(GlodaMsgIndexer._keyChangedBatchInfo)) {</span>
<a href="#l4.65"></a><span id="l4.65" class="difflineplus">+    mark_failure([&quot;GlodaMsgIndexer._keyChangedBatchInfo should be empty but&quot;,</span>
<a href="#l4.66"></a><span id="l4.66" class="difflineplus">+                  &quot;has key:&quot;,  evilKey, &quot;and value:&quot;, evilValue, &quot;.&quot;]);</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineplus">+  }</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineplus">+</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+  // - slowpath (IMAP online) move it back to its origin folder</span>
<a href="#l4.70"></a><span id="l4.70">   mark_sub_test_start(&quot;move it back&quot;);</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineminus">-  yield async_move_messages(msgSet, srcFolder);</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineminus">-  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineplus">+  yield async_move_messages(msgSet, srcFolder, false);</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineplus">+  // In the IMAP case we will end up reindexing the message because we will</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineplus">+  //  not be able to fast-path, but the local case will still be fast-pathed.</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet,</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineplus">+                               {fullyIndexed: message_injection_is_local() ?</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+                                                0 : 1});</span>
<a href="#l4.79"></a><span id="l4.79">   do_check_eq(gmsg.folderURI,</span>
<a href="#l4.80"></a><span id="l4.80">               get_real_injection_folder(srcFolder).URI);</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineplus">+  do_check_eq(gmsg.messageKey, msgSet.getMsgHdr(0).messageKey);</span>
<a href="#l4.82"></a><span id="l4.82"> }</span>
<a href="#l4.83"></a><span id="l4.83"> </span>
<a href="#l4.84"></a><span id="l4.84"> /**</span>
<a href="#l4.85"></a><span id="l4.85">  * Moving a gloda-indexed message out of a filthy folder should result in the</span>
<a href="#l4.86"></a><span id="l4.86">  *  destination message not having a gloda-id.</span>
<a href="#l4.87"></a><span id="l4.87">  */</span>
<a href="#l4.88"></a><span id="l4.88"> </span>
<a href="#l4.89"></a><span id="l4.89"> /* ===== Message Copying ===== */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -254,16 +254,17 @@ if (logHelperHasInterestedListeners) {</span>
<a href="#l5.4"></a><span id="l5.4">     return rv;</span>
<a href="#l5.5"></a><span id="l5.5">   };</span>
<a href="#l5.6"></a><span id="l5.6"> }</span>
<a href="#l5.7"></a><span id="l5.7"> </span>
<a href="#l5.8"></a><span id="l5.8"> const _wait_for_gloda_indexer_defaults = {</span>
<a href="#l5.9"></a><span id="l5.9">   verifier: null,</span>
<a href="#l5.10"></a><span id="l5.10">   augment: false,</span>
<a href="#l5.11"></a><span id="l5.11">   deleted: null,</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+  fullyIndexed: null,</span>
<a href="#l5.13"></a><span id="l5.13"> </span>
<a href="#l5.14"></a><span id="l5.14">   // Things should not be recovering or failing and cleaning up unless the test</span>
<a href="#l5.15"></a><span id="l5.15">   //  is expecting it.</span>
<a href="#l5.16"></a><span id="l5.16">   recovered: 0,</span>
<a href="#l5.17"></a><span id="l5.17">   failedToRecover: 0,</span>
<a href="#l5.18"></a><span id="l5.18">   cleanedUp: 0,</span>
<a href="#l5.19"></a><span id="l5.19">   hadNoCleanUp: 0,</span>
<a href="#l5.20"></a><span id="l5.20"> };</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineat">@@ -291,16 +292,21 @@ const _wait_for_gloda_indexer_defaults =</span>
<a href="#l5.22"></a><span id="l5.22">  *     verifier function for this given set of messages, or undefined if it is</span>
<a href="#l5.23"></a><span id="l5.23">  *     the first message.)</span>
<a href="#l5.24"></a><span id="l5.24">  * @param [aConfig.augment=false] Should we augment the synthetic message sets</span>
<a href="#l5.25"></a><span id="l5.25">  *     with references to their corresponding gloda messages?  The messages</span>
<a href="#l5.26"></a><span id="l5.26">  *     will show up in a 'glodaMessages' list on the syn set.</span>
<a href="#l5.27"></a><span id="l5.27">  * @param [aConfig.deleted] A single SyntheticMessageSet or list of them</span>
<a href="#l5.28"></a><span id="l5.28">  *     containing messages that should be recognized as deleted by the gloda</span>
<a href="#l5.29"></a><span id="l5.29">  *     indexer in this pass.</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+ * @param [aConfig.fullyIndexed] A count of the number of messages we expect</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+ *     to observe being fully indexed.  This is relevant because in the case</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+ *     of message moves, gloda may generate an onItemsModified notification but</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+ *     not reindex the message.  This attribute allows the tests to distinguish</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+ *     between the two cases.</span>
<a href="#l5.35"></a><span id="l5.35">  */</span>
<a href="#l5.36"></a><span id="l5.36"> function wait_for_gloda_indexer(aSynMessageSets, aConfig) {</span>
<a href="#l5.37"></a><span id="l5.37">   let ims = _indexMessageState;</span>
<a href="#l5.38"></a><span id="l5.38"> </span>
<a href="#l5.39"></a><span id="l5.39">   if (aSynMessageSets == null)</span>
<a href="#l5.40"></a><span id="l5.40">     aSynMessageSets = [];</span>
<a href="#l5.41"></a><span id="l5.41">   else if (!Array.isArray(aSynMessageSets))</span>
<a href="#l5.42"></a><span id="l5.42">     aSynMessageSets = [aSynMessageSets];</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineat">@@ -320,16 +326,18 @@ function wait_for_gloda_indexer(aSynMess</span>
<a href="#l5.44"></a><span id="l5.44">   if (ims.deletionSynSets &amp;&amp; !Array.isArray(ims.deletionSynSets))</span>
<a href="#l5.45"></a><span id="l5.45">     ims.deletionSynSets = [ims.deletionSynSets];</span>
<a href="#l5.46"></a><span id="l5.46"> </span>
<a href="#l5.47"></a><span id="l5.47">   ims.expectedWorkerRecoveredCount = get_val(&quot;recovered&quot;);</span>
<a href="#l5.48"></a><span id="l5.48">   ims.expectedFailedToRecoverCount = get_val(&quot;failedToRecover&quot;);</span>
<a href="#l5.49"></a><span id="l5.49">   ims.expectedCleanedUpCount = get_val(&quot;cleanedUp&quot;);</span>
<a href="#l5.50"></a><span id="l5.50">   ims.expectedHadNoCleanUpCount = get_val(&quot;hadNoCleanUp&quot;);</span>
<a href="#l5.51"></a><span id="l5.51"> </span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+  ims.expectedNumFullIndexed = get_val(&quot;fullyIndexed&quot;);</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+</span>
<a href="#l5.54"></a><span id="l5.54">   // If we are waiting on certain events to occur first, block on those.</span>
<a href="#l5.55"></a><span id="l5.55">   if (ims.interestingEvents.length) {</span>
<a href="#l5.56"></a><span id="l5.56">     ims.waitingForEvents = true;</span>
<a href="#l5.57"></a><span id="l5.57">     mark_action(&quot;glodaTestHelper&quot;, &quot;waiting for events&quot;, ims.interestingEvents);</span>
<a href="#l5.58"></a><span id="l5.58">     return false;</span>
<a href="#l5.59"></a><span id="l5.59">   }</span>
<a href="#l5.60"></a><span id="l5.60"> </span>
<a href="#l5.61"></a><span id="l5.61">   // if we are still indexing, there is nothing to do right now; save off</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineat">@@ -352,16 +360,21 @@ var _indexMessageState = {</span>
<a href="#l5.63"></a><span id="l5.63">   _init: function _indexMessageState_init() {</span>
<a href="#l5.64"></a><span id="l5.64">     if (this._inited)</span>
<a href="#l5.65"></a><span id="l5.65">       return;</span>
<a href="#l5.66"></a><span id="l5.66"> </span>
<a href="#l5.67"></a><span id="l5.67">     Gloda.addIndexerListener(this.onIndexNotification);</span>
<a href="#l5.68"></a><span id="l5.68">     this.catchAllCollection = Gloda._wildcardCollection(Gloda.NOUN_MESSAGE);</span>
<a href="#l5.69"></a><span id="l5.69">     this.catchAllCollection.listener = this;</span>
<a href="#l5.70"></a><span id="l5.70"> </span>
<a href="#l5.71"></a><span id="l5.71" class="difflineplus">+    // Register us with gloda as an attribute provider so that we can</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+    //  distinguish between fully reindexed messages and fastpath indexed</span>
<a href="#l5.73"></a><span id="l5.73" class="difflineplus">+    //  messages.</span>
<a href="#l5.74"></a><span id="l5.74" class="difflineplus">+    Gloda._attrProviderOrderByNoun[Gloda.NOUN_MESSAGE].push(this);</span>
<a href="#l5.75"></a><span id="l5.75" class="difflineplus">+</span>
<a href="#l5.76"></a><span id="l5.76">     // waitingForEvents support</span>
<a href="#l5.77"></a><span id="l5.77">     // (we want this to happen after gloda registers its own listener, and it</span>
<a href="#l5.78"></a><span id="l5.78">     //  does.)</span>
<a href="#l5.79"></a><span id="l5.79">     let notificationService =</span>
<a href="#l5.80"></a><span id="l5.80">       Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l5.81"></a><span id="l5.81">       getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l5.82"></a><span id="l5.82">     notificationService.addListener(this,</span>
<a href="#l5.83"></a><span id="l5.83">       Ci.nsIMsgFolderNotificationService.msgsClassified);</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineat">@@ -383,16 +396,18 @@ var _indexMessageState = {</span>
<a href="#l5.85"></a><span id="l5.85">   /** Expected value of |_workerRecoveredCount| at assertion time */</span>
<a href="#l5.86"></a><span id="l5.86">   expectedWorkerRecoveredCount: null,</span>
<a href="#l5.87"></a><span id="l5.87">   /** Expected value of |_workerFailedToRecoverCount| at assertion time */</span>
<a href="#l5.88"></a><span id="l5.88">   expectedFailedToRecoverCount: null,</span>
<a href="#l5.89"></a><span id="l5.89">   /** Expected value of |_workerCleanedUpCount| at assertion time */</span>
<a href="#l5.90"></a><span id="l5.90">   expectedCleanedUpCount: null,</span>
<a href="#l5.91"></a><span id="l5.91">   /** Expected value of |_workerHadNoCleanUpCount| at assertion time */</span>
<a href="#l5.92"></a><span id="l5.92">   expectedHadNoCleanUpCount: null,</span>
<a href="#l5.93"></a><span id="l5.93" class="difflineplus">+  /** Exepected value of |_numFullIndexed| at assertion time */</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineplus">+  expectedNumFullIndexed: null,</span>
<a href="#l5.95"></a><span id="l5.95"> </span>
<a href="#l5.96"></a><span id="l5.96">   /** The number of times a worker had a recover helper and it recovered. */</span>
<a href="#l5.97"></a><span id="l5.97">   _workerRecoveredCount: 0,</span>
<a href="#l5.98"></a><span id="l5.98">   /**</span>
<a href="#l5.99"></a><span id="l5.99">    * The number of times a worker had a recover helper and it did not recover.</span>
<a href="#l5.100"></a><span id="l5.100">    */</span>
<a href="#l5.101"></a><span id="l5.101">   _workerFailedToRecoverCount: 0,</span>
<a href="#l5.102"></a><span id="l5.102">   /**</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineat">@@ -553,24 +568,32 @@ var _indexMessageState = {</span>
<a href="#l5.104"></a><span id="l5.104">                     &quot;Expected&quot;, this.expectedCleanedUpCount,</span>
<a href="#l5.105"></a><span id="l5.105">                     &quot;actual&quot;, this._workerCleanedUpCount]);</span>
<a href="#l5.106"></a><span id="l5.106">     if (this.expectedHadNoCleanUpCount != null &amp;&amp;</span>
<a href="#l5.107"></a><span id="l5.107">         this.expectedHadNoCleanUpCount != this._workerHadNoCleanUpCount)</span>
<a href="#l5.108"></a><span id="l5.108">       mark_failure([&quot;Expected worker-had-no-cleanup count did not match actual!&quot;,</span>
<a href="#l5.109"></a><span id="l5.109">                     &quot;Expected&quot;, this.expectedHadNoCleanUpCount,</span>
<a href="#l5.110"></a><span id="l5.110">                     &quot;actual&quot;, this._workerHadNoCleanUpCount]);</span>
<a href="#l5.111"></a><span id="l5.111"> </span>
<a href="#l5.112"></a><span id="l5.112" class="difflineplus">+    if (this.expectedNumFullIndexed != null &amp;&amp;</span>
<a href="#l5.113"></a><span id="l5.113" class="difflineplus">+        this.expectedNumFullIndexed != this._numFullIndexed)</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineplus">+      mark_failure([&quot;Expected number of fully indexed messages did not match.&quot;,</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineplus">+                    &quot;Expected&quot;, this.expectedNumFullIndexed,</span>
<a href="#l5.116"></a><span id="l5.116" class="difflineplus">+                    &quot;actual&quot;, this._numFullIndexed]);</span>
<a href="#l5.117"></a><span id="l5.117" class="difflineplus">+</span>
<a href="#l5.118"></a><span id="l5.118">     this._glodaMessagesByMessageId = {};</span>
<a href="#l5.119"></a><span id="l5.119">     this._glodaDeletionsByMessageId = {};</span>
<a href="#l5.120"></a><span id="l5.120"> </span>
<a href="#l5.121"></a><span id="l5.121">     this._workerRecoveredCount = 0;</span>
<a href="#l5.122"></a><span id="l5.122">     this._workerFailedToRecoverCount = 0;</span>
<a href="#l5.123"></a><span id="l5.123">     this._workerCleanedUpCount = 0;</span>
<a href="#l5.124"></a><span id="l5.124">     this._workerHadNoCleanUpCount = 0;</span>
<a href="#l5.125"></a><span id="l5.125"> </span>
<a href="#l5.126"></a><span id="l5.126" class="difflineplus">+    this._numFullIndexed = 0;</span>
<a href="#l5.127"></a><span id="l5.127" class="difflineplus">+</span>
<a href="#l5.128"></a><span id="l5.128">     // make sure xpcshell head.js knows we tested something</span>
<a href="#l5.129"></a><span id="l5.129">     _passedChecks++;</span>
<a href="#l5.130"></a><span id="l5.130">   },</span>
<a href="#l5.131"></a><span id="l5.131"> </span>
<a href="#l5.132"></a><span id="l5.132">   /*</span>
<a href="#l5.133"></a><span id="l5.133">    * Our catch-all collection listener.  Any time a new message gets indexed,</span>
<a href="#l5.134"></a><span id="l5.134">    *  we should receive an onItemsAdded call.  Any time an existing message</span>
<a href="#l5.135"></a><span id="l5.135">    *  gets reindexed, we should receive an onItemsModified call.  Any time an</span>
<a href="#l5.136"></a><span id="l5.136" class="difflineat">@@ -616,16 +639,33 @@ var _indexMessageState = {</span>
<a href="#l5.137"></a><span id="l5.137">         mark_failure(</span>
<a href="#l5.138"></a><span id="l5.138">           [&quot;Gloda message&quot;, item, &quot;already deleted once since the last&quot; +</span>
<a href="#l5.139"></a><span id="l5.139">             &quot;wait_for_gloda_indexer call!&quot;]);</span>
<a href="#l5.140"></a><span id="l5.140"> </span>
<a href="#l5.141"></a><span id="l5.141">       this._glodaDeletionsByMessageId[item.headerMessageID] = item;</span>
<a href="#l5.142"></a><span id="l5.142">     }</span>
<a href="#l5.143"></a><span id="l5.143">   },</span>
<a href="#l5.144"></a><span id="l5.144"> </span>
<a href="#l5.145"></a><span id="l5.145" class="difflineplus">+  /**</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineplus">+   * The number of messages that were fully (re)indexed using</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineplus">+   *  Gloda.grokNounItem.</span>
<a href="#l5.148"></a><span id="l5.148" class="difflineplus">+   */</span>
<a href="#l5.149"></a><span id="l5.149" class="difflineplus">+  _numFullIndexed: 0,</span>
<a href="#l5.150"></a><span id="l5.150" class="difflineplus">+</span>
<a href="#l5.151"></a><span id="l5.151" class="difflineplus">+  providerName: &quot;glodaTestHelper:fakeProvider&quot;,</span>
<a href="#l5.152"></a><span id="l5.152" class="difflineplus">+  /**</span>
<a href="#l5.153"></a><span id="l5.153" class="difflineplus">+   * Fake attribute provider processing function so we can distinguish</span>
<a href="#l5.154"></a><span id="l5.154" class="difflineplus">+   *  between fully reindexed messages and fast-path modified messages.</span>
<a href="#l5.155"></a><span id="l5.155" class="difflineplus">+   */</span>
<a href="#l5.156"></a><span id="l5.156" class="difflineplus">+  process: function(aItem, aRawReps, aIsConceptuallyNew, aCallbackHandle) {</span>
<a href="#l5.157"></a><span id="l5.157" class="difflineplus">+    this._numFullIndexed++;</span>
<a href="#l5.158"></a><span id="l5.158" class="difflineplus">+</span>
<a href="#l5.159"></a><span id="l5.159" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l5.160"></a><span id="l5.160" class="difflineplus">+  },</span>
<a href="#l5.161"></a><span id="l5.161" class="difflineplus">+</span>
<a href="#l5.162"></a><span id="l5.162">   _numItemsAdded : 0,</span>
<a href="#l5.163"></a><span id="l5.163"> </span>
<a href="#l5.164"></a><span id="l5.164">   /**</span>
<a href="#l5.165"></a><span id="l5.165">    * Gloda indexer listener, used to know when all active indexing jobs have</span>
<a href="#l5.166"></a><span id="l5.166">    *  completed so that we can try and process all the things that should have</span>
<a href="#l5.167"></a><span id="l5.167">    *  been processed.</span>
<a href="#l5.168"></a><span id="l5.168">    */</span>
<a href="#l5.169"></a><span id="l5.169">   onIndexNotification: function(aStatus, aPrettyName, aJobIndex,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/test/resources/folderEventLogHelper.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/test/resources/folderEventLogHelper.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -57,16 +57,17 @@ function registerFolderEventLogHelper() </span>
<a href="#l6.4"></a><span id="l6.4">   let notificationService =</span>
<a href="#l6.5"></a><span id="l6.5">     Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;]</span>
<a href="#l6.6"></a><span id="l6.6">       .getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l6.7"></a><span id="l6.7">   notificationService.addListener(_folderEventLogHelper_msgFolderListener,</span>
<a href="#l6.8"></a><span id="l6.8">         Ci.nsIMsgFolderNotificationService.msgAdded |</span>
<a href="#l6.9"></a><span id="l6.9">         Ci.nsIMsgFolderNotificationService.msgsClassified |</span>
<a href="#l6.10"></a><span id="l6.10">         Ci.nsIMsgFolderNotificationService.msgsDeleted |</span>
<a href="#l6.11"></a><span id="l6.11">         Ci.nsIMsgFolderNotificationService.msgsMoveCopyCompleted |</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.msgKeyChanged |</span>
<a href="#l6.13"></a><span id="l6.13">         Ci.nsIMsgFolderNotificationService.folderDeleted |</span>
<a href="#l6.14"></a><span id="l6.14">         Ci.nsIMsgFolderNotificationService.folderMoveCopyCompleted |</span>
<a href="#l6.15"></a><span id="l6.15">         Ci.nsIMsgFolderNotificationService.folderRenamed |</span>
<a href="#l6.16"></a><span id="l6.16">         Ci.nsIMsgFolderNotificationService.itemEvent);</span>
<a href="#l6.17"></a><span id="l6.17"> }</span>
<a href="#l6.18"></a><span id="l6.18"> </span>
<a href="#l6.19"></a><span id="l6.19"> /**</span>
<a href="#l6.20"></a><span id="l6.20">  * nsIMsgFolderListener implementation to logHelper events that gloda cares</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineat">@@ -114,16 +115,21 @@ let _folderEventLogHelper_msgFolderListe</span>
<a href="#l6.22"></a><span id="l6.22">       for each (let msgHdr in fixIterator(aDestMsgs.enumerate(),</span>
<a href="#l6.23"></a><span id="l6.23">                                           Components.interfaces.nsIMsgDBHdr)) {</span>
<a href="#l6.24"></a><span id="l6.24">         args.push(msgHdr);</span>
<a href="#l6.25"></a><span id="l6.25">       }</span>
<a href="#l6.26"></a><span id="l6.26">     }</span>
<a href="#l6.27"></a><span id="l6.27">     mark_action(&quot;msgEvent&quot;, &quot;msgsMoveCopyCompleted&quot;, args);</span>
<a href="#l6.28"></a><span id="l6.28">   },</span>
<a href="#l6.29"></a><span id="l6.29"> </span>
<a href="#l6.30"></a><span id="l6.30" class="difflineplus">+  msgKeyChanged: function felh_msgKeyChanged(aOldMsgKey, aNewMsgHdr) {</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineplus">+    let args = [&quot;old key&quot;, aOldMsgKey, &quot;new header&quot;, aNewMsgHdr];</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;msgKeyChanged&quot;, args);</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineplus">+  },</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineplus">+</span>
<a href="#l6.35"></a><span id="l6.35">   folderAdded: function felh_folderAdded(aFolder) {</span>
<a href="#l6.36"></a><span id="l6.36">     mark_action(&quot;msgEvent&quot;, &quot;folderAdded&quot;, [aFolder]);</span>
<a href="#l6.37"></a><span id="l6.37">   },</span>
<a href="#l6.38"></a><span id="l6.38"> </span>
<a href="#l6.39"></a><span id="l6.39">   folderDeleted: function felh_folderDeleted(aFolder) {</span>
<a href="#l6.40"></a><span id="l6.40">     mark_action(&quot;msgEvent&quot;, &quot;folderDeleted&quot;, [aFolder]);</span>
<a href="#l6.41"></a><span id="l6.41">   },</span>
<a href="#l6.42"></a><span id="l6.42"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/test/resources/messageInjection.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/test/resources/messageInjection.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -857,23 +857,31 @@ function wait_for_message_injection() {</span>
<a href="#l7.4"></a><span id="l7.4">     return false;</span>
<a href="#l7.5"></a><span id="l7.5">   else</span>
<a href="#l7.6"></a><span id="l7.6">     return true;</span>
<a href="#l7.7"></a><span id="l7.7"> }</span>
<a href="#l7.8"></a><span id="l7.8"> </span>
<a href="#l7.9"></a><span id="l7.9"> /**</span>
<a href="#l7.10"></a><span id="l7.10">  * Asynchronously move messages in the given set to the destination folder.</span>
<a href="#l7.11"></a><span id="l7.11">  *</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">- * The IMAP case is much more complex, at least in the unit testing world:</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineminus">- * XXX We have to force an update of the source folder because the fake</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineminus">- *  server only allows one connection and that one connection currently</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineminus">- *  is focused on destFolder; we have to force an update of srcFolder to</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineminus">- *  get the move to actually hit the IMAP server.</span>
<a href="#l7.17"></a><span id="l7.17" class="difflineplus">+ * For IMAP moves we force an update of the source folder and then the</span>
<a href="#l7.18"></a><span id="l7.18" class="difflineplus">+ *  destination folder.  This ensures that any (pseudo-)offline operations in</span>
<a href="#l7.19"></a><span id="l7.19" class="difflineplus">+ *  the source folder have had a chance to run and that we have seen the changes</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineplus">+ *  in the target folder.</span>
<a href="#l7.21"></a><span id="l7.21" class="difflineplus">+ * We additionally cause all of the message bodies to be downloaded in the</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineplus">+ *  target folder if the folder has the Offline flag set.</span>
<a href="#l7.23"></a><span id="l7.23" class="difflineplus">+ *</span>
<a href="#l7.24"></a><span id="l7.24" class="difflineplus">+ * @param aSynMessageSet The messages to move.</span>
<a href="#l7.25"></a><span id="l7.25" class="difflineplus">+ * @param aDestFolder The target folder.</span>
<a href="#l7.26"></a><span id="l7.26" class="difflineplus">+ * @param [aAllowUndo=false] Should we generate undo operations and, as a</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineplus">+ *     side-effect, offline operations?  (The code uses undo operations as</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineplus">+ *     a proxy-indicator for it coming from the UI and therefore performing</span>
<a href="#l7.29"></a><span id="l7.29" class="difflineplus">+ *     pseudo-offline operations instead of trying to do things online.)</span>
<a href="#l7.30"></a><span id="l7.30">  */</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-function async_move_messages(aSynMessageSet, aDestFolder) {</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+function async_move_messages(aSynMessageSet, aDestFolder, aAllowUndo) {</span>
<a href="#l7.33"></a><span id="l7.33">   mark_action(&quot;messageInjection&quot;, &quot;moving messages&quot;, aSynMessageSet.msgHdrList);</span>
<a href="#l7.34"></a><span id="l7.34">   return async_run({func: function () {</span>
<a href="#l7.35"></a><span id="l7.35">       // we need to make sure all folder promises are fulfilled</span>
<a href="#l7.36"></a><span id="l7.36">       yield wait_for_async_promises();</span>
<a href="#l7.37"></a><span id="l7.37">       // and then we can make sure we have the actual folder</span>
<a href="#l7.38"></a><span id="l7.38">       let realDestFolder = get_real_injection_folder(aDestFolder);</span>
<a href="#l7.39"></a><span id="l7.39"> </span>
<a href="#l7.40"></a><span id="l7.40">       let copyService = Cc[&quot;@mozilla.org/messenger/messagecopyservice;1&quot;]</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineat">@@ -888,17 +896,17 @@ function async_move_messages(aSynMessage</span>
<a href="#l7.42"></a><span id="l7.42">         //  destination headers.</span>
<a href="#l7.43"></a><span id="l7.43">         if (!message_injection_is_local())</span>
<a href="#l7.44"></a><span id="l7.44">           _messageInjectionSetup.notifyListeners(</span>
<a href="#l7.45"></a><span id="l7.45">             &quot;onMovingMessagesWithoutDestHeaders&quot;, [realDestFolder]);</span>
<a href="#l7.46"></a><span id="l7.46"> </span>
<a href="#l7.47"></a><span id="l7.47">         copyService.CopyMessages(folder, xpcomHdrArray,</span>
<a href="#l7.48"></a><span id="l7.48">                                  realDestFolder, /* move */ true,</span>
<a href="#l7.49"></a><span id="l7.49">                                  asyncCopyListener, null,</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineminus">-                                 /* do not allow undo, leaks */ false);</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+                                 Boolean(aAllowUndo));</span>
<a href="#l7.52"></a><span id="l7.52">         // update the synthetic message set's folder entry...</span>
<a href="#l7.53"></a><span id="l7.53">         aSynMessageSet._folderSwap(folder, realDestFolder);</span>
<a href="#l7.54"></a><span id="l7.54">         yield false;</span>
<a href="#l7.55"></a><span id="l7.55"> </span>
<a href="#l7.56"></a><span id="l7.56">         // IMAP special case per function doc...</span>
<a href="#l7.57"></a><span id="l7.57">         if (!message_injection_is_local()) {</span>
<a href="#l7.58"></a><span id="l7.58">           mark_action(&quot;messageInjection&quot;,</span>
<a href="#l7.59"></a><span id="l7.59">                       &quot;forcing update of folder so IMAP move issued&quot;,</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

