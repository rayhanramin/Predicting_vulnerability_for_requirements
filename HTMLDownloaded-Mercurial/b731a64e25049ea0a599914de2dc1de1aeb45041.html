<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 6509:b731a64e25049ea0a599914de2dc1de1aeb45041</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ b731a64e25049ea0a599914de2dc1de1aeb45041" />
<meta property="og:url" content="/comm-central/rev/b731a64e25049ea0a599914de2dc1de1aeb45041" />
<meta property="og:description" content="fix bug 351224, r=bienvenu, detach of grandchildren with mime multipart alternative" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / b731a64e25049ea0a599914de2dc1de1aeb45041 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/b731a64e25049ea0a599914de2dc1de1aeb45041">shortlog</a> |
<a href="/comm-central/log/b731a64e25049ea0a599914de2dc1de1aeb45041">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/b731a64e25049ea0a599914de2dc1de1aeb45041">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/b731a64e25049ea0a599914de2dc1de1aeb45041">files</a> |
changeset |
<a href="/comm-central/raw-rev/b731a64e25049ea0a599914de2dc1de1aeb45041">raw</a>  | <a href="/comm-central/archive/b731a64e25049ea0a599914de2dc1de1aeb45041.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
fix <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=351224">bug 351224</a>, r=bienvenu, detach of grandchildren with mime multipart alternative
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#110;&#97;&#116;&#104;&#97;&#110;&#32;&#75;&#97;&#109;&#101;&#110;&#115;&#32;&#60;&#106;&#105;&#107;&#64;&#107;&#97;&#109;&#101;&#110;&#115;&#46;&#98;&#114;&#111;&#111;&#107;&#108;&#105;&#110;&#101;&#46;&#109;&#97;&#46;&#117;&#115;&#62;</td></tr>
<tr><td></td><td class="date age">Wed, 06 Oct 2010 13:42:41 -0700</td></tr>

<tr>
 <td>changeset 6509</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/b731a64e25049ea0a599914de2dc1de1aeb45041">b731a64e25049ea0a599914de2dc1de1aeb45041</a></td>
</tr>



<tr>
<td>parent 6508</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/8c523f3c00fb61f08e54a69c254269a3c282d519">8c523f3c00fb61f08e54a69c254269a3c282d519</a>
</td>
</tr>

<tr>
<td>child 6510</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/afb7f32df77e548ab456805ed9f210eb1ddfb0ee">afb7f32df77e548ab456805ed9f210eb1ddfb0ee</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=b731a64e25049ea0a599914de2dc1de1aeb45041">5026</a></td></tr>
<tr><td>push user</td><td>bienvenu@nventure.com</td></tr>
<tr><td>push date</td><td class="date age">Wed, 06 Oct 2010 20:41:53 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@b731a64e2504 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=b731a64e25049ea0a599914de2dc1de1aeb45041">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=b731a64e25049ea0a599914de2dc1de1aeb45041&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=b731a64e25049ea0a599914de2dc1de1aeb45041&newProject=comm-central&newRevision=b731a64e25049ea0a599914de2dc1de1aeb45041&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=b731a64e25049ea0a599914de2dc1de1aeb45041&newProject=comm-central&newRevision=b731a64e25049ea0a599914de2dc1de1aeb45041&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=b731a64e25049ea0a599914de2dc1de1aeb45041&newProject=comm-central&newRevision=b731a64e25049ea0a599914de2dc1de1aeb45041&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28bienvenu%29&revcount=50">bienvenu</a>, <a href="/comm-central/log?rev=reviewer%28detach%29&revcount=50">detach</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=351224">351224</a></td></tr>




</table></div>

<div class="page_body description">fix <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=351224">bug 351224</a>, r=bienvenu, detach of grandchildren with mime multipart alternative</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimei.h">mailnews/mime/src/mimei.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimei.h">file</a> |
<a href="/comm-central/annotate/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimei.h">annotate</a> |
<a href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimei.h">diff</a> |
<a href="/comm-central/comparison/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimei.h">comparison</a> |
<a href="/comm-central/log/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimei.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.cpp">mailnews/mime/src/mimemalt.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.cpp">file</a> |
<a href="/comm-central/annotate/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.cpp">annotate</a> |
<a href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.cpp">diff</a> |
<a href="/comm-central/comparison/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.cpp">comparison</a> |
<a href="/comm-central/log/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.h">mailnews/mime/src/mimemalt.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.h">file</a> |
<a href="/comm-central/annotate/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.h">annotate</a> |
<a href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.h">diff</a> |
<a href="/comm-central/comparison/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.h">comparison</a> |
<a href="/comm-central/log/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemalt.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemoz2.cpp">mailnews/mime/src/mimemoz2.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemoz2.cpp">file</a> |
<a href="/comm-central/annotate/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemoz2.cpp">annotate</a> |
<a href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemoz2.cpp">diff</a> |
<a href="/comm-central/comparison/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemoz2.cpp">comparison</a> |
<a href="/comm-central/log/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemoz2.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.cpp">mailnews/mime/src/mimemult.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.cpp">file</a> |
<a href="/comm-central/annotate/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.cpp">annotate</a> |
<a href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.cpp">diff</a> |
<a href="/comm-central/comparison/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.cpp">comparison</a> |
<a href="/comm-central/log/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.h">mailnews/mime/src/mimemult.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.h">file</a> |
<a href="/comm-central/annotate/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.h">annotate</a> |
<a href="/comm-central/diff/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.h">diff</a> |
<a href="/comm-central/comparison/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.h">comparison</a> |
<a href="/comm-central/log/b731a64e25049ea0a599914de2dc1de1aeb45041/mailnews/mime/src/mimemult.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/mime/src/mimei.h</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/mime/src/mimei.h</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -425,18 +425,17 @@ extern int MimeObject_write(MimeObject *</span>
<a href="#l1.4"></a><span id="l1.4">                             PRBool user_visible_p);</span>
<a href="#l1.5"></a><span id="l1.5"> extern int MimeOptions_write(MimeDisplayOptions *, nsCString &amp;name,</span>
<a href="#l1.6"></a><span id="l1.6">                              const char *data, PRInt32 length,</span>
<a href="#l1.7"></a><span id="l1.7">                              PRBool user_visible_p);</span>
<a href="#l1.8"></a><span id="l1.8"> </span>
<a href="#l1.9"></a><span id="l1.9"> /* Writes out the right kind of HR (or rather, queues it for writing.) */</span>
<a href="#l1.10"></a><span id="l1.10"> extern int MimeObject_write_separator(MimeObject *);</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-extern PRBool MimeObjectChildIsMessageBody(MimeObject *obj,</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-                                           PRBool *isAlterOrRelated);</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+extern PRBool MimeObjectIsMessageBody(MimeObject *obj);</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16"> /* This is the data tagged to contexts and the declaration needs to be</span>
<a href="#l1.17"></a><span id="l1.17">    in a header file since more than mimemoz.c needs to see it now...</span>
<a href="#l1.18"></a><span id="l1.18">    */</span>
<a href="#l1.19"></a><span id="l1.19"> #ifdef HAVE_MIME_DATA_SLOT</span>
<a href="#l1.20"></a><span id="l1.20"> # define LOCK_LAST_CACHED_MESSAGE</span>
<a href="#l1.21"></a><span id="l1.21"> #endif</span>
<a href="#l1.22"></a><span id="l1.22"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/mime/src/mimemalt.cpp</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/mime/src/mimemalt.cpp</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -16,31 +16,114 @@</span>
<a href="#l2.4"></a><span id="l2.4">  *</span>
<a href="#l2.5"></a><span id="l2.5">  * The Initial Developer of the Original Code is</span>
<a href="#l2.6"></a><span id="l2.6">  * Netscape Communications Corporation.</span>
<a href="#l2.7"></a><span id="l2.7">  * Portions created by the Initial Developer are Copyright (C) 1998</span>
<a href="#l2.8"></a><span id="l2.8">  * the Initial Developer. All Rights Reserved.</span>
<a href="#l2.9"></a><span id="l2.9">  *</span>
<a href="#l2.10"></a><span id="l2.10">  * Contributor(s):</span>
<a href="#l2.11"></a><span id="l2.11">  *   Ben Bucksch &lt;mozilla@bucksch.org&gt;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+ *   Jonathan Kamens &lt;jik@kamens.us&gt;</span>
<a href="#l2.13"></a><span id="l2.13">  *</span>
<a href="#l2.14"></a><span id="l2.14">  * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l2.15"></a><span id="l2.15">  * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l2.16"></a><span id="l2.16">  * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l2.17"></a><span id="l2.17">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l2.18"></a><span id="l2.18">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l2.19"></a><span id="l2.19">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l2.20"></a><span id="l2.20">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l2.21"></a><span id="l2.21">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l2.22"></a><span id="l2.22">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l2.23"></a><span id="l2.23">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l2.24"></a><span id="l2.24">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l2.25"></a><span id="l2.25">  *</span>
<a href="#l2.26"></a><span id="l2.26">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l2.27"></a><span id="l2.27"> </span>
<a href="#l2.28"></a><span id="l2.28" class="difflineplus">+/*</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+  BACKGROUND</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+  ----------</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+  At the simplest level, multipart/alternative means &quot;pick one of these and</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+  display it.&quot; However, it's actually a lot more complicated than that.</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+  The alternatives are in preference order, and counterintuitively, they go</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+  from *least* to *most* preferred rather than the reverse. Therefore, when</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+  we're parsing, we can't just take the first one we like and throw the rest</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+  away -- we have to parse through the whole thing, discarding the n'th part if</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+  we are capable of displaying the n+1'th.</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+  Adding a wrinkle to that is the fact that we give the user the option of</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+  demanding the plain-text alternative even though we are perfectly capable of</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+  displaying the HTML, and it is almost always the preferred format, i.e., it</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+  almost always comes after the plain-text alternative.</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+  Speaking of which, you can't assume that each of the alternatives is just a</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+  basic text/[whatever]. There may be, for example, a text/plain followed by a</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+  multipart/related which contains text/html and associated embedded</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+  images. Yikes!</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+  You also can't assume that there will be just two parts. There can be an</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+  arbitrary number, and the ones we are capable of displaying and the ones we</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+  aren't could be interspersed in any order by the producer of the MIME.</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+  We can't just throw away the parts we're not displaying when we're processing</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+  the MIME for display. If we were to do that, then the MIME parts that</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+  remained wouldn't get numbered properly, and that would mean, for example,</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+  that deleting attachments wouldn't work in some messages. Indeed, that very</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+  problem is what prompted a rewrite of this file into its current</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+  architecture.</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+  We need to be capable of streaming the entire MIME part in raw format when</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+  nsMimeMessageAttach is set.</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+  ARCHITECTURE</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineplus">+  ------------</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+  Normal (not nsMimeMessageAttach mode):</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+  Parts are read and queued until we know whether we're going to display</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+  them. If the first pending part is one we don't know how to display, then we</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+  can add it to the MIME structure immediatelly, with output_p disabled. If the</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+  first pending part is one we know how to display, then we can't add it to the</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+  in-memory MIME structure until either (a) we encounter a later, more</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+  preferred part we know how to display, or (b) we reach the end of the</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+  parts. A display-capable part of the queue may be followed by one or more</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+  display-incapable parts. We can't add them to the in-memory structure until</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+  we figure out what to do with the first, display-capable pending part,</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+  because otherwise the order and numbering will be wrong. All of the logic in</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+  this paragraph is implemented in the flush_children function.</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+  The display_cached_part function is what actually adds a MIME part to the</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+  in-memory MIME structure. There is one complication there which forces us to</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+  violate abstrations... Even if we set output_p on a child before adding it to</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+  the parent, the parse_begin function resets it. The kluge I came up with to</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+  prevent that was to give the child a separate options object and set</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+  output_fn to nsnull in it, because that causes parse_begin to set output_p to</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+  false. This seemed like the least onerous way to accomplish this, although I</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+  can't say it's a solution I'm particularly fond of.</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineplus">+</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineplus">+  Another complication in display_cached_part is that if we were just a normal</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineplus">+  multipart type, we could rely on MimeMultipart_parse_line to notify emitters</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineplus">+  about content types, character sets, part numbers, etc. as our new children</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineplus">+  get created. However, since we defer creation of some children, the</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineplus">+  notification doesn't happen there, so we have to handle it</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineplus">+  ourselves. Unfortunately, this requires a small abstraction violation in</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineplus">+  MimeMultipart_parse_line -- we have to check there if the entity is</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineplus">+  multipart/alternative and if so not notify emitters there because</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineplus">+  MimeMultipartAlternative_create_child handles it.</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineplus">+</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineplus">+  In nsMimeMessageAttach mode:</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineplus">+</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineplus">+  When raw MIME is being output, rather than doing any of our special-case</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineplus">+  logic, we simply invoke our superclass functions for everything, which causes</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineplus">+  us to be be output in correct multipart format.</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineplus">+</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+  - Jonathan Kamens, 2010-07-23</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+*/</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+</span>
<a href="#l2.110"></a><span id="l2.110"> #include &quot;mimemalt.h&quot;</span>
<a href="#l2.111"></a><span id="l2.111"> #include &quot;prmem.h&quot;</span>
<a href="#l2.112"></a><span id="l2.112"> #include &quot;plstr.h&quot;</span>
<a href="#l2.113"></a><span id="l2.113"> #include &quot;prlog.h&quot;</span>
<a href="#l2.114"></a><span id="l2.114"> #include &quot;nsMimeTypes.h&quot;</span>
<a href="#l2.115"></a><span id="l2.115"> #include &quot;nsMimeStringResources.h&quot;</span>
<a href="#l2.116"></a><span id="l2.116"> #include &quot;nsIPrefBranch.h&quot;</span>
<a href="#l2.117"></a><span id="l2.117"> #include &quot;mimemoz2.h&quot; // for prefs</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineat">@@ -54,20 +137,23 @@ MimeDefClass(MimeMultipartAlternative, M</span>
<a href="#l2.119"></a><span id="l2.119"> static int MimeMultipartAlternative_initialize (MimeObject *);</span>
<a href="#l2.120"></a><span id="l2.120"> static void MimeMultipartAlternative_finalize (MimeObject *);</span>
<a href="#l2.121"></a><span id="l2.121"> static int MimeMultipartAlternative_parse_eof (MimeObject *, PRBool);</span>
<a href="#l2.122"></a><span id="l2.122"> static int MimeMultipartAlternative_create_child(MimeObject *);</span>
<a href="#l2.123"></a><span id="l2.123"> static int MimeMultipartAlternative_parse_child_line (MimeObject *, const char *,</span>
<a href="#l2.124"></a><span id="l2.124">                             PRInt32, PRBool);</span>
<a href="#l2.125"></a><span id="l2.125"> static int MimeMultipartAlternative_close_child(MimeObject *);</span>
<a href="#l2.126"></a><span id="l2.126"> </span>
<a href="#l2.127"></a><span id="l2.127" class="difflineplus">+static int MimeMultipartAlternative_flush_children(MimeObject *, PRBool, PRBool);</span>
<a href="#l2.128"></a><span id="l2.128"> static PRBool MimeMultipartAlternative_display_part_p(MimeObject *self,</span>
<a href="#l2.129"></a><span id="l2.129">                              MimeHeaders *sub_hdrs);</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineminus">-static int MimeMultipartAlternative_discard_cached_part(MimeObject *);</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineminus">-static int MimeMultipartAlternative_display_cached_part(MimeObject *);</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineplus">+static int MimeMultipartAlternative_display_cached_part(MimeObject *,</span>
<a href="#l2.133"></a><span id="l2.133" class="difflineplus">+                                                        MimeHeaders *,</span>
<a href="#l2.134"></a><span id="l2.134" class="difflineplus">+                                                        MimePartBufferData *,</span>
<a href="#l2.135"></a><span id="l2.135" class="difflineplus">+                                                        PRBool);</span>
<a href="#l2.136"></a><span id="l2.136"> </span>
<a href="#l2.137"></a><span id="l2.137"> static int</span>
<a href="#l2.138"></a><span id="l2.138"> MimeMultipartAlternativeClassInitialize(MimeMultipartAlternativeClass *clazz)</span>
<a href="#l2.139"></a><span id="l2.139"> {</span>
<a href="#l2.140"></a><span id="l2.140">   MimeObjectClass    *oclass = (MimeObjectClass *)    clazz;</span>
<a href="#l2.141"></a><span id="l2.141">   MimeMultipartClass *mclass = (MimeMultipartClass *) clazz;</span>
<a href="#l2.142"></a><span id="l2.142">   PR_ASSERT(!oclass-&gt;class_initialized);</span>
<a href="#l2.143"></a><span id="l2.143">   oclass-&gt;initialize       = MimeMultipartAlternative_initialize;</span>
<a href="#l2.144"></a><span id="l2.144" class="difflineat">@@ -80,144 +166,251 @@ MimeMultipartAlternativeClassInitialize(</span>
<a href="#l2.145"></a><span id="l2.145"> }</span>
<a href="#l2.146"></a><span id="l2.146"> </span>
<a href="#l2.147"></a><span id="l2.147"> </span>
<a href="#l2.148"></a><span id="l2.148"> static int</span>
<a href="#l2.149"></a><span id="l2.149"> MimeMultipartAlternative_initialize (MimeObject *obj)</span>
<a href="#l2.150"></a><span id="l2.150"> {</span>
<a href="#l2.151"></a><span id="l2.151">   MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.152"></a><span id="l2.152"> </span>
<a href="#l2.153"></a><span id="l2.153" class="difflineminus">-  PR_ASSERT(!malt-&gt;part_buffer);</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineminus">-  malt-&gt;part_buffer = MimePartBufferCreate();</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineminus">-  if (!malt-&gt;part_buffer)</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineminus">-  return MIME_OUT_OF_MEMORY;</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineminus">-</span>
<a href="#l2.158"></a><span id="l2.158" class="difflineplus">+  NS_ASSERTION(!malt-&gt;part_buffers, &quot;object initialized multiple times&quot;);</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineplus">+  NS_ASSERTION(!malt-&gt;buffered_hdrs, &quot;object initialized multiple times&quot;);</span>
<a href="#l2.160"></a><span id="l2.160" class="difflineplus">+  malt-&gt;pending_parts = 0;</span>
<a href="#l2.161"></a><span id="l2.161" class="difflineplus">+  malt-&gt;max_parts = 0;</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineplus">+  malt-&gt;buffered_hdrs = nsnull;</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineplus">+  malt-&gt;part_buffers = nsnull;</span>
<a href="#l2.164"></a><span id="l2.164" class="difflineplus">+  </span>
<a href="#l2.165"></a><span id="l2.165">   return ((MimeObjectClass*)&amp;MIME_SUPERCLASS)-&gt;initialize(obj);</span>
<a href="#l2.166"></a><span id="l2.166"> }</span>
<a href="#l2.167"></a><span id="l2.167"> </span>
<a href="#l2.168"></a><span id="l2.168"> static void</span>
<a href="#l2.169"></a><span id="l2.169"> MimeMultipartAlternative_cleanup(MimeObject *obj)</span>
<a href="#l2.170"></a><span id="l2.170"> {</span>
<a href="#l2.171"></a><span id="l2.171">   MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.172"></a><span id="l2.172" class="difflineminus">-  if (malt-&gt;buffered_hdrs)</span>
<a href="#l2.173"></a><span id="l2.173" class="difflineminus">-  {</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineminus">-    MimeHeaders_free(malt-&gt;buffered_hdrs);</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineminus">-    malt-&gt;buffered_hdrs = 0;</span>
<a href="#l2.176"></a><span id="l2.176" class="difflineplus">+  PRInt32 i;</span>
<a href="#l2.177"></a><span id="l2.177" class="difflineplus">+</span>
<a href="#l2.178"></a><span id="l2.178" class="difflineplus">+  for (i = 0; i &lt; malt-&gt;pending_parts; i++) {</span>
<a href="#l2.179"></a><span id="l2.179" class="difflineplus">+    MimeHeaders_free(malt-&gt;buffered_hdrs[i]);</span>
<a href="#l2.180"></a><span id="l2.180" class="difflineplus">+    MimePartBufferDestroy(malt-&gt;part_buffers[i]);</span>
<a href="#l2.181"></a><span id="l2.181">   }</span>
<a href="#l2.182"></a><span id="l2.182" class="difflineminus">-  if (malt-&gt;part_buffer)</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineminus">-  {</span>
<a href="#l2.184"></a><span id="l2.184" class="difflineminus">-    MimePartBufferDestroy(malt-&gt;part_buffer);</span>
<a href="#l2.185"></a><span id="l2.185" class="difflineminus">-    malt-&gt;part_buffer = 0;</span>
<a href="#l2.186"></a><span id="l2.186" class="difflineminus">-  }</span>
<a href="#l2.187"></a><span id="l2.187" class="difflineplus">+  PR_FREEIF(malt-&gt;buffered_hdrs);</span>
<a href="#l2.188"></a><span id="l2.188" class="difflineplus">+  PR_FREEIF(malt-&gt;part_buffers);</span>
<a href="#l2.189"></a><span id="l2.189" class="difflineplus">+  malt-&gt;pending_parts = 0;</span>
<a href="#l2.190"></a><span id="l2.190"> }</span>
<a href="#l2.191"></a><span id="l2.191"> </span>
<a href="#l2.192"></a><span id="l2.192"> </span>
<a href="#l2.193"></a><span id="l2.193"> static void</span>
<a href="#l2.194"></a><span id="l2.194"> MimeMultipartAlternative_finalize (MimeObject *obj)</span>
<a href="#l2.195"></a><span id="l2.195"> {</span>
<a href="#l2.196"></a><span id="l2.196">   MimeMultipartAlternative_cleanup(obj);</span>
<a href="#l2.197"></a><span id="l2.197">   ((MimeObjectClass*)&amp;MIME_SUPERCLASS)-&gt;finalize(obj);</span>
<a href="#l2.198"></a><span id="l2.198"> }</span>
<a href="#l2.199"></a><span id="l2.199"> </span>
<a href="#l2.200"></a><span id="l2.200"> </span>
<a href="#l2.201"></a><span id="l2.201"> static int</span>
<a href="#l2.202"></a><span id="l2.202" class="difflineplus">+MimeMultipartAlternative_flush_children(MimeObject *obj,</span>
<a href="#l2.203"></a><span id="l2.203" class="difflineplus">+                                        PRBool finished,</span>
<a href="#l2.204"></a><span id="l2.204" class="difflineplus">+                                        PRBool next_is_displayable)</span>
<a href="#l2.205"></a><span id="l2.205" class="difflineplus">+{</span>
<a href="#l2.206"></a><span id="l2.206" class="difflineplus">+  /*</span>
<a href="#l2.207"></a><span id="l2.207" class="difflineplus">+    Possible states:</span>
<a href="#l2.208"></a><span id="l2.208" class="difflineplus">+</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineplus">+    1. Cache contains nothing: do nothing.</span>
<a href="#l2.210"></a><span id="l2.210" class="difflineplus">+</span>
<a href="#l2.211"></a><span id="l2.211" class="difflineplus">+    2. Finished, and the cache contains one displayable body followed</span>
<a href="#l2.212"></a><span id="l2.212" class="difflineplus">+       by zero or more non-displayable bodies, and we're not in</span>
<a href="#l2.213"></a><span id="l2.213" class="difflineplus">+       nsMimeMessageAttach mode: create the first body with output on</span>
<a href="#l2.214"></a><span id="l2.214" class="difflineplus">+       and the others with output off.</span>
<a href="#l2.215"></a><span id="l2.215" class="difflineplus">+</span>
<a href="#l2.216"></a><span id="l2.216" class="difflineplus">+    3. Finished, and the cache contains one displayable body followed</span>
<a href="#l2.217"></a><span id="l2.217" class="difflineplus">+       by zero or more non-displayable bodies, and we're in</span>
<a href="#l2.218"></a><span id="l2.218" class="difflineplus">+       nsMimeMessageAttach mode: create all cached bodies with output</span>
<a href="#l2.219"></a><span id="l2.219" class="difflineplus">+       output off.</span>
<a href="#l2.220"></a><span id="l2.220" class="difflineplus">+</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineplus">+    4. Finished, and the cache contains one non-displayable body:</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineplus">+       create it with output off.</span>
<a href="#l2.223"></a><span id="l2.223" class="difflineplus">+</span>
<a href="#l2.224"></a><span id="l2.224" class="difflineplus">+    5. Not finished, and the cache contains one displayable body</span>
<a href="#l2.225"></a><span id="l2.225" class="difflineplus">+       followed by zero or more non-displayable bodies, and the new</span>
<a href="#l2.226"></a><span id="l2.226" class="difflineplus">+       body we're about to create is displayable: create all cached</span>
<a href="#l2.227"></a><span id="l2.227" class="difflineplus">+       bodies with output off.</span>
<a href="#l2.228"></a><span id="l2.228" class="difflineplus">+</span>
<a href="#l2.229"></a><span id="l2.229" class="difflineplus">+    6. Not finished, and the cache contains one displayable body</span>
<a href="#l2.230"></a><span id="l2.230" class="difflineplus">+       followed by zero or more non-displayable bodies, and the new</span>
<a href="#l2.231"></a><span id="l2.231" class="difflineplus">+       body we're about to create is non-displayable: do nothing.</span>
<a href="#l2.232"></a><span id="l2.232" class="difflineplus">+</span>
<a href="#l2.233"></a><span id="l2.233" class="difflineplus">+    7. Not finished, and the cache contains one non-displayable body:</span>
<a href="#l2.234"></a><span id="l2.234" class="difflineplus">+       create it with output off.</span>
<a href="#l2.235"></a><span id="l2.235" class="difflineplus">+  */</span>
<a href="#l2.236"></a><span id="l2.236" class="difflineplus">+  MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.237"></a><span id="l2.237" class="difflineplus">+  PRBool have_displayable, do_flush, do_display, in_attach;</span>
<a href="#l2.238"></a><span id="l2.238" class="difflineplus">+</span>
<a href="#l2.239"></a><span id="l2.239" class="difflineplus">+  /* Case 1 */</span>
<a href="#l2.240"></a><span id="l2.240" class="difflineplus">+  if (! malt-&gt;pending_parts)</span>
<a href="#l2.241"></a><span id="l2.241" class="difflineplus">+    return NS_OK;</span>
<a href="#l2.242"></a><span id="l2.242" class="difflineplus">+</span>
<a href="#l2.243"></a><span id="l2.243" class="difflineplus">+  have_displayable =</span>
<a href="#l2.244"></a><span id="l2.244" class="difflineplus">+    MimeMultipartAlternative_display_part_p(obj, malt-&gt;buffered_hdrs[0]);</span>
<a href="#l2.245"></a><span id="l2.245" class="difflineplus">+  in_attach = obj-&gt;options-&gt;format_out == nsMimeOutput::nsMimeMessageAttach;</span>
<a href="#l2.246"></a><span id="l2.246" class="difflineplus">+  </span>
<a href="#l2.247"></a><span id="l2.247" class="difflineplus">+  if (finished &amp;&amp; have_displayable &amp;&amp; ! in_attach) {</span>
<a href="#l2.248"></a><span id="l2.248" class="difflineplus">+    /* Case 2 */</span>
<a href="#l2.249"></a><span id="l2.249" class="difflineplus">+    do_flush = PR_TRUE;</span>
<a href="#l2.250"></a><span id="l2.250" class="difflineplus">+    do_display = PR_TRUE;</span>
<a href="#l2.251"></a><span id="l2.251" class="difflineplus">+  }</span>
<a href="#l2.252"></a><span id="l2.252" class="difflineplus">+  else if (finished &amp;&amp; have_displayable &amp;&amp; in_attach) {</span>
<a href="#l2.253"></a><span id="l2.253" class="difflineplus">+    /* Case 3 */</span>
<a href="#l2.254"></a><span id="l2.254" class="difflineplus">+    do_flush = PR_TRUE;</span>
<a href="#l2.255"></a><span id="l2.255" class="difflineplus">+    do_display = PR_FALSE;</span>
<a href="#l2.256"></a><span id="l2.256" class="difflineplus">+  }</span>
<a href="#l2.257"></a><span id="l2.257" class="difflineplus">+  else if (finished &amp;&amp; ! have_displayable) {</span>
<a href="#l2.258"></a><span id="l2.258" class="difflineplus">+    /* Case 4 */</span>
<a href="#l2.259"></a><span id="l2.259" class="difflineplus">+    do_flush = PR_TRUE;</span>
<a href="#l2.260"></a><span id="l2.260" class="difflineplus">+    do_display = PR_FALSE;</span>
<a href="#l2.261"></a><span id="l2.261" class="difflineplus">+  }</span>
<a href="#l2.262"></a><span id="l2.262" class="difflineplus">+  else if (! finished &amp;&amp; have_displayable &amp;&amp; next_is_displayable) {</span>
<a href="#l2.263"></a><span id="l2.263" class="difflineplus">+    /* Case 5 */</span>
<a href="#l2.264"></a><span id="l2.264" class="difflineplus">+    do_flush = PR_TRUE;</span>
<a href="#l2.265"></a><span id="l2.265" class="difflineplus">+    do_display = PR_FALSE;</span>
<a href="#l2.266"></a><span id="l2.266" class="difflineplus">+  }</span>
<a href="#l2.267"></a><span id="l2.267" class="difflineplus">+  else if (! finished &amp;&amp; have_displayable &amp;&amp; ! next_is_displayable) {</span>
<a href="#l2.268"></a><span id="l2.268" class="difflineplus">+    /* Case 6 */</span>
<a href="#l2.269"></a><span id="l2.269" class="difflineplus">+    do_flush = PR_FALSE;</span>
<a href="#l2.270"></a><span id="l2.270" class="difflineplus">+    do_display = PR_FALSE;</span>
<a href="#l2.271"></a><span id="l2.271" class="difflineplus">+  }</span>
<a href="#l2.272"></a><span id="l2.272" class="difflineplus">+  else if (! finished &amp;&amp; ! have_displayable) {</span>
<a href="#l2.273"></a><span id="l2.273" class="difflineplus">+    /* Case 7 */</span>
<a href="#l2.274"></a><span id="l2.274" class="difflineplus">+    do_flush = PR_TRUE;</span>
<a href="#l2.275"></a><span id="l2.275" class="difflineplus">+    do_display = PR_FALSE;</span>
<a href="#l2.276"></a><span id="l2.276" class="difflineplus">+  }</span>
<a href="#l2.277"></a><span id="l2.277" class="difflineplus">+  else {</span>
<a href="#l2.278"></a><span id="l2.278" class="difflineplus">+    NS_ERROR(&quot;mimemalt.cpp: logic error in flush_children&quot;);</span>
<a href="#l2.279"></a><span id="l2.279" class="difflineplus">+    return NS_ERROR_FAILURE;</span>
<a href="#l2.280"></a><span id="l2.280" class="difflineplus">+  }</span>
<a href="#l2.281"></a><span id="l2.281" class="difflineplus">+  </span>
<a href="#l2.282"></a><span id="l2.282" class="difflineplus">+  if (do_flush) {</span>
<a href="#l2.283"></a><span id="l2.283" class="difflineplus">+    PRInt32 i;</span>
<a href="#l2.284"></a><span id="l2.284" class="difflineplus">+    for (i = 0; i &lt; malt-&gt;pending_parts; i++) {</span>
<a href="#l2.285"></a><span id="l2.285" class="difflineplus">+      MimeMultipartAlternative_display_cached_part(obj,</span>
<a href="#l2.286"></a><span id="l2.286" class="difflineplus">+                                                   malt-&gt;buffered_hdrs[i],</span>
<a href="#l2.287"></a><span id="l2.287" class="difflineplus">+                                                   malt-&gt;part_buffers[i],</span>
<a href="#l2.288"></a><span id="l2.288" class="difflineplus">+                                                   do_display &amp;&amp; (i == 0));</span>
<a href="#l2.289"></a><span id="l2.289" class="difflineplus">+      MimeHeaders_free(malt-&gt;buffered_hdrs[i]);</span>
<a href="#l2.290"></a><span id="l2.290" class="difflineplus">+      MimePartBufferDestroy(malt-&gt;part_buffers[i]);</span>
<a href="#l2.291"></a><span id="l2.291" class="difflineplus">+    }</span>
<a href="#l2.292"></a><span id="l2.292" class="difflineplus">+    malt-&gt;pending_parts = 0;</span>
<a href="#l2.293"></a><span id="l2.293" class="difflineplus">+  }</span>
<a href="#l2.294"></a><span id="l2.294" class="difflineplus">+  return NS_OK;</span>
<a href="#l2.295"></a><span id="l2.295" class="difflineplus">+}</span>
<a href="#l2.296"></a><span id="l2.296" class="difflineplus">+</span>
<a href="#l2.297"></a><span id="l2.297" class="difflineplus">+static int</span>
<a href="#l2.298"></a><span id="l2.298"> MimeMultipartAlternative_parse_eof (MimeObject *obj, PRBool abort_p)</span>
<a href="#l2.299"></a><span id="l2.299"> {</span>
<a href="#l2.300"></a><span id="l2.300" class="difflineminus">-  MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.301"></a><span id="l2.301">   int status = 0;</span>
<a href="#l2.302"></a><span id="l2.302"> </span>
<a href="#l2.303"></a><span id="l2.303" class="difflineplus">+  if (obj-&gt;options-&gt;format_out == nsMimeOutput::nsMimeMessageAttach)</span>
<a href="#l2.304"></a><span id="l2.304" class="difflineplus">+    return ((MimeObjectClass*)&amp;MIME_SUPERCLASS)-&gt;parse_eof(obj, abort_p);</span>
<a href="#l2.305"></a><span id="l2.305" class="difflineplus">+</span>
<a href="#l2.306"></a><span id="l2.306">   if (obj-&gt;closed_p) return 0;</span>
<a href="#l2.307"></a><span id="l2.307"> </span>
<a href="#l2.308"></a><span id="l2.308">   status = ((MimeObjectClass*)&amp;MIME_SUPERCLASS)-&gt;parse_eof(obj, abort_p);</span>
<a href="#l2.309"></a><span id="l2.309">   if (status &lt; 0) return status;</span>
<a href="#l2.310"></a><span id="l2.310"> </span>
<a href="#l2.311"></a><span id="l2.311" class="difflineminus">-  /* If there's a cached part we haven't written out yet, do it now.</span>
<a href="#l2.312"></a><span id="l2.312" class="difflineminus">-   */</span>
<a href="#l2.313"></a><span id="l2.313" class="difflineminus">-  if (malt-&gt;buffered_hdrs &amp;&amp; !abort_p &amp;&amp;</span>
<a href="#l2.314"></a><span id="l2.314" class="difflineminus">-      obj-&gt;options-&gt;format_out != nsMimeOutput::nsMimeMessageAttach)</span>
<a href="#l2.315"></a><span id="l2.315" class="difflineminus">-  {</span>
<a href="#l2.316"></a><span id="l2.316" class="difflineminus">-    status = MimeMultipartAlternative_display_cached_part(obj);</span>
<a href="#l2.317"></a><span id="l2.317" class="difflineminus">-    if (status &lt; 0) return status;</span>
<a href="#l2.318"></a><span id="l2.318" class="difflineminus">-  }</span>
<a href="#l2.319"></a><span id="l2.319" class="difflineplus">+</span>
<a href="#l2.320"></a><span id="l2.320" class="difflineplus">+  status = MimeMultipartAlternative_flush_children(obj, PR_TRUE, PR_FALSE);</span>
<a href="#l2.321"></a><span id="l2.321" class="difflineplus">+  if (status &lt; 0)</span>
<a href="#l2.322"></a><span id="l2.322" class="difflineplus">+    return status;</span>
<a href="#l2.323"></a><span id="l2.323"> </span>
<a href="#l2.324"></a><span id="l2.324">   MimeMultipartAlternative_cleanup(obj);</span>
<a href="#l2.325"></a><span id="l2.325"> </span>
<a href="#l2.326"></a><span id="l2.326">   return status;</span>
<a href="#l2.327"></a><span id="l2.327"> }</span>
<a href="#l2.328"></a><span id="l2.328"> </span>
<a href="#l2.329"></a><span id="l2.329"> </span>
<a href="#l2.330"></a><span id="l2.330"> static int</span>
<a href="#l2.331"></a><span id="l2.331"> MimeMultipartAlternative_create_child(MimeObject *obj)</span>
<a href="#l2.332"></a><span id="l2.332"> {</span>
<a href="#l2.333"></a><span id="l2.333">   MimeMultipart *mult = (MimeMultipart *) obj;</span>
<a href="#l2.334"></a><span id="l2.334">   MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.335"></a><span id="l2.335"> </span>
<a href="#l2.336"></a><span id="l2.336" class="difflineminus">-  if (MimeMultipartAlternative_display_part_p (obj, mult-&gt;hdrs))</span>
<a href="#l2.337"></a><span id="l2.337" class="difflineminus">-  {</span>
<a href="#l2.338"></a><span id="l2.338" class="difflineminus">-    /* If this part is potentially displayable, begin populating the cache</span>
<a href="#l2.339"></a><span id="l2.339" class="difflineminus">-     with it.  If there's something in the cache already, discard it</span>
<a href="#l2.340"></a><span id="l2.340" class="difflineminus">-     first.  (Just because this part is displayable doesn't mean we will</span>
<a href="#l2.341"></a><span id="l2.341" class="difflineminus">-     display it -- of two consecutive displayable parts, it is the second</span>
<a href="#l2.342"></a><span id="l2.342" class="difflineminus">-     one that gets displayed.)</span>
<a href="#l2.343"></a><span id="l2.343" class="difflineminus">-     */</span>
<a href="#l2.344"></a><span id="l2.344" class="difflineminus">-    int status;</span>
<a href="#l2.345"></a><span id="l2.345" class="difflineminus">-    mult-&gt;state = MimeMultipartPartFirstLine;</span>
<a href="#l2.346"></a><span id="l2.346" class="difflineplus">+  if (obj-&gt;options-&gt;format_out == nsMimeOutput::nsMimeMessageAttach)</span>
<a href="#l2.347"></a><span id="l2.347" class="difflineplus">+    return ((MimeMultipartClass*)&amp;MIME_SUPERCLASS)-&gt;create_child(obj);</span>
<a href="#l2.348"></a><span id="l2.348" class="difflineplus">+</span>
<a href="#l2.349"></a><span id="l2.349" class="difflineplus">+  PRBool displayable =</span>
<a href="#l2.350"></a><span id="l2.350" class="difflineplus">+    MimeMultipartAlternative_display_part_p (obj, mult-&gt;hdrs);</span>
<a href="#l2.351"></a><span id="l2.351"> </span>
<a href="#l2.352"></a><span id="l2.352" class="difflineminus">-    status = MimeMultipartAlternative_discard_cached_part(obj);</span>
<a href="#l2.353"></a><span id="l2.353" class="difflineminus">-    if (status &lt; 0) return status;</span>
<a href="#l2.354"></a><span id="l2.354" class="difflineminus">-</span>
<a href="#l2.355"></a><span id="l2.355" class="difflineminus">-    PR_ASSERT(!malt-&gt;buffered_hdrs);</span>
<a href="#l2.356"></a><span id="l2.356" class="difflineminus">-    malt-&gt;buffered_hdrs = MimeHeaders_copy(mult-&gt;hdrs);</span>
<a href="#l2.357"></a><span id="l2.357" class="difflineminus">-    if (!malt-&gt;buffered_hdrs) return MIME_OUT_OF_MEMORY;</span>
<a href="#l2.358"></a><span id="l2.358" class="difflineminus">-    return 0;</span>
<a href="#l2.359"></a><span id="l2.359" class="difflineplus">+  MimeMultipartAlternative_flush_children(obj, PR_FALSE, displayable);</span>
<a href="#l2.360"></a><span id="l2.360" class="difflineplus">+  </span>
<a href="#l2.361"></a><span id="l2.361" class="difflineplus">+  mult-&gt;state = MimeMultipartPartFirstLine;</span>
<a href="#l2.362"></a><span id="l2.362" class="difflineplus">+  PRInt32 i = malt-&gt;pending_parts++;</span>
<a href="#l2.363"></a><span id="l2.363" class="difflineplus">+  if (malt-&gt;pending_parts &gt; malt-&gt;max_parts) {</span>
<a href="#l2.364"></a><span id="l2.364" class="difflineplus">+    malt-&gt;max_parts = malt-&gt;pending_parts;</span>
<a href="#l2.365"></a><span id="l2.365" class="difflineplus">+    malt-&gt;buffered_hdrs = (MimeHeaders **)</span>
<a href="#l2.366"></a><span id="l2.366" class="difflineplus">+      PR_REALLOC(malt-&gt;buffered_hdrs, malt-&gt;max_parts *</span>
<a href="#l2.367"></a><span id="l2.367" class="difflineplus">+                 sizeof *malt-&gt;buffered_hdrs);</span>
<a href="#l2.368"></a><span id="l2.368" class="difflineplus">+    if (! malt-&gt;buffered_hdrs)</span>
<a href="#l2.369"></a><span id="l2.369" class="difflineplus">+      return MIME_OUT_OF_MEMORY;</span>
<a href="#l2.370"></a><span id="l2.370" class="difflineplus">+    malt-&gt;part_buffers = (MimePartBufferData **)</span>
<a href="#l2.371"></a><span id="l2.371" class="difflineplus">+      PR_REALLOC(malt-&gt;part_buffers, malt-&gt;max_parts *</span>
<a href="#l2.372"></a><span id="l2.372" class="difflineplus">+                 sizeof *malt-&gt;part_buffers);</span>
<a href="#l2.373"></a><span id="l2.373" class="difflineplus">+    if (! malt-&gt;part_buffers)</span>
<a href="#l2.374"></a><span id="l2.374" class="difflineplus">+      return MIME_OUT_OF_MEMORY;</span>
<a href="#l2.375"></a><span id="l2.375">   }</span>
<a href="#l2.376"></a><span id="l2.376" class="difflineminus">-  else</span>
<a href="#l2.377"></a><span id="l2.377" class="difflineminus">-  {</span>
<a href="#l2.378"></a><span id="l2.378" class="difflineminus">-    /* If this part is not displayable, then skip it. maybe the next one will be...</span>
<a href="#l2.379"></a><span id="l2.379" class="difflineminus">-     */</span>
<a href="#l2.380"></a><span id="l2.380" class="difflineminus">-    mult-&gt;state = MimeMultipartSkipPartLine;</span>
<a href="#l2.381"></a><span id="l2.381" class="difflineminus">-    return 0;</span>
<a href="#l2.382"></a><span id="l2.382" class="difflineminus">-  }</span>
<a href="#l2.383"></a><span id="l2.383" class="difflineplus">+  </span>
<a href="#l2.384"></a><span id="l2.384" class="difflineplus">+  malt-&gt;buffered_hdrs[i] = MimeHeaders_copy(mult-&gt;hdrs);</span>
<a href="#l2.385"></a><span id="l2.385" class="difflineplus">+  if (!malt-&gt;buffered_hdrs[i])</span>
<a href="#l2.386"></a><span id="l2.386" class="difflineplus">+    return MIME_OUT_OF_MEMORY;</span>
<a href="#l2.387"></a><span id="l2.387" class="difflineplus">+  malt-&gt;part_buffers[i] = MimePartBufferCreate();</span>
<a href="#l2.388"></a><span id="l2.388" class="difflineplus">+  if (!malt-&gt;part_buffers[i])</span>
<a href="#l2.389"></a><span id="l2.389" class="difflineplus">+    return MIME_OUT_OF_MEMORY;</span>
<a href="#l2.390"></a><span id="l2.390" class="difflineplus">+  return 0;</span>
<a href="#l2.391"></a><span id="l2.391"> }</span>
<a href="#l2.392"></a><span id="l2.392"> </span>
<a href="#l2.393"></a><span id="l2.393"> </span>
<a href="#l2.394"></a><span id="l2.394"> static int</span>
<a href="#l2.395"></a><span id="l2.395"> MimeMultipartAlternative_parse_child_line (MimeObject *obj,</span>
<a href="#l2.396"></a><span id="l2.396">                        const char *line, PRInt32 length,</span>
<a href="#l2.397"></a><span id="l2.397">                        PRBool first_line_p)</span>
<a href="#l2.398"></a><span id="l2.398"> {</span>
<a href="#l2.399"></a><span id="l2.399">   MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.400"></a><span id="l2.400"> </span>
<a href="#l2.401"></a><span id="l2.401" class="difflineminus">-  PR_ASSERT(malt-&gt;part_buffer);</span>
<a href="#l2.402"></a><span id="l2.402" class="difflineminus">-  if (!malt-&gt;part_buffer) return -1;</span>
<a href="#l2.403"></a><span id="l2.403" class="difflineplus">+  if (obj-&gt;options-&gt;format_out == nsMimeOutput::nsMimeMessageAttach)</span>
<a href="#l2.404"></a><span id="l2.404" class="difflineplus">+    return ((MimeMultipartClass*)&amp;MIME_SUPERCLASS)-&gt;parse_child_line(obj, line, length, first_line_p);</span>
<a href="#l2.405"></a><span id="l2.405"> </span>
<a href="#l2.406"></a><span id="l2.406" class="difflineminus">-  if (!obj-&gt;options-&gt;state-&gt;strippingPart &amp;&amp; obj-&gt;options-&gt;format_out == nsMimeOutput::nsMimeMessageAttach)</span>
<a href="#l2.407"></a><span id="l2.407" class="difflineminus">-    MimeObject_write(obj, line, length, PR_FALSE);</span>
<a href="#l2.408"></a><span id="l2.408" class="difflineplus">+  NS_ASSERTION(malt-&gt;pending_parts, &quot;should be pending parts, but there aren't&quot;);</span>
<a href="#l2.409"></a><span id="l2.409" class="difflineplus">+  if (!malt-&gt;pending_parts)</span>
<a href="#l2.410"></a><span id="l2.410" class="difflineplus">+    return -1;</span>
<a href="#l2.411"></a><span id="l2.411" class="difflineplus">+  PRInt32 i = malt-&gt;pending_parts - 1;</span>
<a href="#l2.412"></a><span id="l2.412"> </span>
<a href="#l2.413"></a><span id="l2.413">   /* Push this line into the buffer for later retrieval. */</span>
<a href="#l2.414"></a><span id="l2.414" class="difflineminus">-  return MimePartBufferWrite (malt-&gt;part_buffer, line, length);</span>
<a href="#l2.415"></a><span id="l2.415" class="difflineplus">+  return MimePartBufferWrite (malt-&gt;part_buffers[i], line, length);</span>
<a href="#l2.416"></a><span id="l2.416"> }</span>
<a href="#l2.417"></a><span id="l2.417"> </span>
<a href="#l2.418"></a><span id="l2.418"> </span>
<a href="#l2.419"></a><span id="l2.419"> static int</span>
<a href="#l2.420"></a><span id="l2.420"> MimeMultipartAlternative_close_child(MimeObject *obj)</span>
<a href="#l2.421"></a><span id="l2.421"> {</span>
<a href="#l2.422"></a><span id="l2.422" class="difflineplus">+  MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.423"></a><span id="l2.423">   MimeMultipart *mult = (MimeMultipart *) obj;</span>
<a href="#l2.424"></a><span id="l2.424" class="difflineminus">-  MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.425"></a><span id="l2.425" class="difflineplus">+</span>
<a href="#l2.426"></a><span id="l2.426" class="difflineplus">+  if (obj-&gt;options-&gt;format_out == nsMimeOutput::nsMimeMessageAttach)</span>
<a href="#l2.427"></a><span id="l2.427" class="difflineplus">+    return ((MimeMultipartClass*)&amp;MIME_SUPERCLASS)-&gt;close_child(obj);</span>
<a href="#l2.428"></a><span id="l2.428"> </span>
<a href="#l2.429"></a><span id="l2.429">   /* PR_ASSERT(malt-&gt;part_buffer);      Some Mac brokenness trips this...</span>
<a href="#l2.430"></a><span id="l2.430">   if (!malt-&gt;part_buffer) return -1; */</span>
<a href="#l2.431"></a><span id="l2.431"> </span>
<a href="#l2.432"></a><span id="l2.432" class="difflineminus">-  if (malt-&gt;part_buffer)</span>
<a href="#l2.433"></a><span id="l2.433" class="difflineminus">-  MimePartBufferClose(malt-&gt;part_buffer);</span>
<a href="#l2.434"></a><span id="l2.434" class="difflineplus">+  if (malt-&gt;pending_parts)</span>
<a href="#l2.435"></a><span id="l2.435" class="difflineplus">+    MimePartBufferClose(malt-&gt;part_buffers[malt-&gt;pending_parts-1]);</span>
<a href="#l2.436"></a><span id="l2.436"> </span>
<a href="#l2.437"></a><span id="l2.437">   /* PR_ASSERT(mult-&gt;hdrs);         I expect the Mac trips this too */</span>
<a href="#l2.438"></a><span id="l2.438" class="difflineminus">-  if (mult-&gt;hdrs)</span>
<a href="#l2.439"></a><span id="l2.439" class="difflineminus">-  MimeHeaders_free(mult-&gt;hdrs);</span>
<a href="#l2.440"></a><span id="l2.440" class="difflineminus">-  mult-&gt;hdrs = 0;</span>
<a href="#l2.441"></a><span id="l2.441" class="difflineplus">+</span>
<a href="#l2.442"></a><span id="l2.442" class="difflineplus">+  if (mult-&gt;hdrs) {</span>
<a href="#l2.443"></a><span id="l2.443" class="difflineplus">+    MimeHeaders_free(mult-&gt;hdrs);</span>
<a href="#l2.444"></a><span id="l2.444" class="difflineplus">+    mult-&gt;hdrs = 0;</span>
<a href="#l2.445"></a><span id="l2.445" class="difflineplus">+  }</span>
<a href="#l2.446"></a><span id="l2.446"> </span>
<a href="#l2.447"></a><span id="l2.447">   return 0;</span>
<a href="#l2.448"></a><span id="l2.448"> }</span>
<a href="#l2.449"></a><span id="l2.449"> </span>
<a href="#l2.450"></a><span id="l2.450"> </span>
<a href="#l2.451"></a><span id="l2.451"> static PRBool</span>
<a href="#l2.452"></a><span id="l2.452"> MimeMultipartAlternative_display_part_p(MimeObject *self,</span>
<a href="#l2.453"></a><span id="l2.453">                     MimeHeaders *sub_hdrs)</span>
<a href="#l2.454"></a><span id="l2.454" class="difflineat">@@ -259,107 +452,117 @@ MimeMultipartAlternative_display_part_p(</span>
<a href="#l2.455"></a><span id="l2.455">   PRBool result = (clazz</span>
<a href="#l2.456"></a><span id="l2.456">           ? clazz-&gt;displayable_inline_p(clazz, sub_hdrs)</span>
<a href="#l2.457"></a><span id="l2.457">           : PR_FALSE);</span>
<a href="#l2.458"></a><span id="l2.458">   PR_FREEIF(ct);</span>
<a href="#l2.459"></a><span id="l2.459">   return result;</span>
<a href="#l2.460"></a><span id="l2.460"> }</span>
<a href="#l2.461"></a><span id="l2.461"> </span>
<a href="#l2.462"></a><span id="l2.462"> static int</span>
<a href="#l2.463"></a><span id="l2.463" class="difflineminus">-MimeMultipartAlternative_discard_cached_part(MimeObject *obj)</span>
<a href="#l2.464"></a><span id="l2.464" class="difflineplus">+MimeMultipartAlternative_display_cached_part(MimeObject *obj,</span>
<a href="#l2.465"></a><span id="l2.465" class="difflineplus">+                                             MimeHeaders *hdrs,</span>
<a href="#l2.466"></a><span id="l2.466" class="difflineplus">+                                             MimePartBufferData *buffer,</span>
<a href="#l2.467"></a><span id="l2.467" class="difflineplus">+                                             PRBool do_display)</span>
<a href="#l2.468"></a><span id="l2.468"> {</span>
<a href="#l2.469"></a><span id="l2.469" class="difflineminus">-  MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.470"></a><span id="l2.470" class="difflineminus">-</span>
<a href="#l2.471"></a><span id="l2.471" class="difflineminus">-  if (malt-&gt;buffered_hdrs)</span>
<a href="#l2.472"></a><span id="l2.472" class="difflineminus">-  {</span>
<a href="#l2.473"></a><span id="l2.473" class="difflineminus">-    MimeHeaders_free(malt-&gt;buffered_hdrs);</span>
<a href="#l2.474"></a><span id="l2.474" class="difflineminus">-    malt-&gt;buffered_hdrs = 0;</span>
<a href="#l2.475"></a><span id="l2.475" class="difflineminus">-  }</span>
<a href="#l2.476"></a><span id="l2.476" class="difflineminus">-  if (malt-&gt;part_buffer)</span>
<a href="#l2.477"></a><span id="l2.477" class="difflineminus">-  MimePartBufferReset (malt-&gt;part_buffer);</span>
<a href="#l2.478"></a><span id="l2.478" class="difflineminus">-</span>
<a href="#l2.479"></a><span id="l2.479" class="difflineminus">-  return 0;</span>
<a href="#l2.480"></a><span id="l2.480" class="difflineminus">-}</span>
<a href="#l2.481"></a><span id="l2.481" class="difflineminus">-</span>
<a href="#l2.482"></a><span id="l2.482" class="difflineminus">-static int</span>
<a href="#l2.483"></a><span id="l2.483" class="difflineminus">-MimeMultipartAlternative_display_cached_part(MimeObject *obj)</span>
<a href="#l2.484"></a><span id="l2.484" class="difflineminus">-{</span>
<a href="#l2.485"></a><span id="l2.485" class="difflineminus">-  MimeMultipartAlternative *malt = (MimeMultipartAlternative *) obj;</span>
<a href="#l2.486"></a><span id="l2.486">   int status;</span>
<a href="#l2.487"></a><span id="l2.487"> </span>
<a href="#l2.488"></a><span id="l2.488" class="difflineminus">-  char *ct = (malt-&gt;buffered_hdrs</span>
<a href="#l2.489"></a><span id="l2.489" class="difflineminus">-        ? MimeHeaders_get (malt-&gt;buffered_hdrs, HEADER_CONTENT_TYPE,</span>
<a href="#l2.490"></a><span id="l2.490" class="difflineminus">-                 PR_TRUE, PR_FALSE)</span>
<a href="#l2.491"></a><span id="l2.491" class="difflineplus">+  char *ct = (hdrs</span>
<a href="#l2.492"></a><span id="l2.492" class="difflineplus">+        ? MimeHeaders_get (hdrs, HEADER_CONTENT_TYPE, PR_TRUE, PR_FALSE)</span>
<a href="#l2.493"></a><span id="l2.493">         : 0);</span>
<a href="#l2.494"></a><span id="l2.494">   const char *dct = (((MimeMultipartClass *) obj-&gt;clazz)-&gt;default_part_type);</span>
<a href="#l2.495"></a><span id="l2.495">   MimeObject *body;</span>
<a href="#l2.496"></a><span id="l2.496" class="difflineminus">-</span>
<a href="#l2.497"></a><span id="l2.497" class="difflineplus">+  const char *uct = (ct &amp;&amp; *ct) ? ct : (dct ? dct: TEXT_PLAIN);</span>
<a href="#l2.498"></a><span id="l2.498" class="difflineplus">+  </span>
<a href="#l2.499"></a><span id="l2.499">   /* Don't pass in NULL as the content-type (this means that the</span>
<a href="#l2.500"></a><span id="l2.500">    auto-uudecode-hack won't ever be done for subparts of a</span>
<a href="#l2.501"></a><span id="l2.501">    multipart, but only for untyped children of message/rfc822.</span>
<a href="#l2.502"></a><span id="l2.502">    */</span>
<a href="#l2.503"></a><span id="l2.503" class="difflineminus">-  body = mime_create(((ct &amp;&amp; *ct) ? ct : (dct ? dct: TEXT_PLAIN)),</span>
<a href="#l2.504"></a><span id="l2.504" class="difflineminus">-           malt-&gt;buffered_hdrs, obj-&gt;options);</span>
<a href="#l2.505"></a><span id="l2.505" class="difflineminus">-</span>
<a href="#l2.506"></a><span id="l2.506" class="difflineplus">+  body = mime_create(uct, hdrs, obj-&gt;options);</span>
<a href="#l2.507"></a><span id="l2.507">   PR_FREEIF(ct);</span>
<a href="#l2.508"></a><span id="l2.508">   if (!body) return MIME_OUT_OF_MEMORY;</span>
<a href="#l2.509"></a><span id="l2.509" class="difflineplus">+  body-&gt;output_p = do_display;</span>
<a href="#l2.510"></a><span id="l2.510"> </span>
<a href="#l2.511"></a><span id="l2.511">   status = ((MimeContainerClass *) obj-&gt;clazz)-&gt;add_child(obj, body);</span>
<a href="#l2.512"></a><span id="l2.512">   if (status &lt; 0)</span>
<a href="#l2.513"></a><span id="l2.513">   {</span>
<a href="#l2.514"></a><span id="l2.514">     mime_free(body);</span>
<a href="#l2.515"></a><span id="l2.515">     return status;</span>
<a href="#l2.516"></a><span id="l2.516">   }</span>
<a href="#l2.517"></a><span id="l2.517" class="difflineplus">+  /* We need to muck around with the options to prevent output when</span>
<a href="#l2.518"></a><span id="l2.518" class="difflineplus">+     do_display is false. More about this below. */</span>
<a href="#l2.519"></a><span id="l2.519" class="difflineplus">+  /* add_child assigns body-&gt;options from obj-&gt;options, but that's</span>
<a href="#l2.520"></a><span id="l2.520" class="difflineplus">+     just a pointer so if we muck with it in the child it'll modify</span>
<a href="#l2.521"></a><span id="l2.521" class="difflineplus">+     the parent as well, which we definitely don't want. Therefore we</span>
<a href="#l2.522"></a><span id="l2.522" class="difflineplus">+     need to make a copy. */</span>
<a href="#l2.523"></a><span id="l2.523" class="difflineplus">+  body-&gt;options = new MimeDisplayOptions;</span>
<a href="#l2.524"></a><span id="l2.524" class="difflineplus">+  *body-&gt;options = *obj-&gt;options;</span>
<a href="#l2.525"></a><span id="l2.525" class="difflineplus">+  /* But we have to be careful about getting into a situation where</span>
<a href="#l2.526"></a><span id="l2.526" class="difflineplus">+     memory could be double-freed. All of this is a gross abstraction</span>
<a href="#l2.527"></a><span id="l2.527" class="difflineplus">+     violation which could be avoided if it were possible to tell</span>
<a href="#l2.528"></a><span id="l2.528" class="difflineplus">+     parse_begin what output_p should be. */</span>
<a href="#l2.529"></a><span id="l2.529" class="difflineplus">+  if (body-&gt;options-&gt;part_to_load)</span>
<a href="#l2.530"></a><span id="l2.530" class="difflineplus">+    body-&gt;options-&gt;part_to_load = strdup(body-&gt;options-&gt;part_to_load);</span>
<a href="#l2.531"></a><span id="l2.531" class="difflineplus">+  if (body-&gt;options-&gt;default_charset)</span>
<a href="#l2.532"></a><span id="l2.532" class="difflineplus">+    body-&gt;options-&gt;default_charset = strdup(body-&gt;options-&gt;default_charset);</span>
<a href="#l2.533"></a><span id="l2.533" class="difflineplus">+  </span>
<a href="#l2.534"></a><span id="l2.534" class="difflineplus">+  /* parse_begin resets output_p. This is quite annoying. To convince</span>
<a href="#l2.535"></a><span id="l2.535" class="difflineplus">+     it that we mean business, we set output_fn to null if we don't</span>
<a href="#l2.536"></a><span id="l2.536" class="difflineplus">+     want output. */</span>
<a href="#l2.537"></a><span id="l2.537" class="difflineplus">+  if (! do_display)</span>
<a href="#l2.538"></a><span id="l2.538" class="difflineplus">+    body-&gt;options-&gt;output_fn = nsnull;</span>
<a href="#l2.539"></a><span id="l2.539"> </span>
<a href="#l2.540"></a><span id="l2.540"> #ifdef MIME_DRAFTS</span>
<a href="#l2.541"></a><span id="l2.541">   /* if this object is a child of a multipart/related object, the parent is</span>
<a href="#l2.542"></a><span id="l2.542">      taking care of decomposing the whole part, don't need to do it at this level.</span>
<a href="#l2.543"></a><span id="l2.543">      However, we still have to call decompose_file_init_fn and decompose_file_close_fn</span>
<a href="#l2.544"></a><span id="l2.544">      in order to set the correct content-type. But don't call MimePartBufferRead</span>
<a href="#l2.545"></a><span id="l2.545">   */</span>
<a href="#l2.546"></a><span id="l2.546">   PRBool multipartRelatedChild = mime_typep(obj-&gt;parent,(MimeObjectClass*)&amp;mimeMultipartRelatedClass);</span>
<a href="#l2.547"></a><span id="l2.547" class="difflineminus">-  PRBool decomposeFile = obj-&gt;options &amp;&amp;</span>
<a href="#l2.548"></a><span id="l2.548" class="difflineplus">+  PRBool decomposeFile = do_display &amp;&amp; obj-&gt;options &amp;&amp;</span>
<a href="#l2.549"></a><span id="l2.549">                   obj-&gt;options-&gt;decompose_file_p &amp;&amp;</span>
<a href="#l2.550"></a><span id="l2.550">                   obj-&gt;options-&gt;decompose_file_init_fn &amp;&amp;</span>
<a href="#l2.551"></a><span id="l2.551">                   !mime_typep(body, (MimeObjectClass *) &amp;mimeMultipartClass);</span>
<a href="#l2.552"></a><span id="l2.552"> </span>
<a href="#l2.553"></a><span id="l2.553">   if (decomposeFile)</span>
<a href="#l2.554"></a><span id="l2.554">   {</span>
<a href="#l2.555"></a><span id="l2.555">     status = obj-&gt;options-&gt;decompose_file_init_fn (</span>
<a href="#l2.556"></a><span id="l2.556" class="difflineminus">-                        obj-&gt;options-&gt;stream_closure,</span>
<a href="#l2.557"></a><span id="l2.557" class="difflineminus">-                        malt-&gt;buffered_hdrs);</span>
<a href="#l2.558"></a><span id="l2.558" class="difflineplus">+                        obj-&gt;options-&gt;stream_closure, hdrs);</span>
<a href="#l2.559"></a><span id="l2.559">     if (status &lt; 0) return status;</span>
<a href="#l2.560"></a><span id="l2.560">   }</span>
<a href="#l2.561"></a><span id="l2.561"> #endif /* MIME_DRAFTS */</span>
<a href="#l2.562"></a><span id="l2.562"> </span>
<a href="#l2.563"></a><span id="l2.563" class="difflineplus">+  /* Now that we've added this new object to our list of children,</span>
<a href="#l2.564"></a><span id="l2.564" class="difflineplus">+   notify emitters and start its parser going. */</span>
<a href="#l2.565"></a><span id="l2.565" class="difflineplus">+  MimeMultipart_notify_emitter(body);</span>
<a href="#l2.566"></a><span id="l2.566"> </span>
<a href="#l2.567"></a><span id="l2.567" class="difflineminus">-  /* Now that we've added this new object to our list of children,</span>
<a href="#l2.568"></a><span id="l2.568" class="difflineminus">-   start its parser going. */</span>
<a href="#l2.569"></a><span id="l2.569">   status = body-&gt;clazz-&gt;parse_begin(body);</span>
<a href="#l2.570"></a><span id="l2.570">   if (status &lt; 0) return status;</span>
<a href="#l2.571"></a><span id="l2.571" class="difflineplus">+  /* Now that parse_begin is done mucking with output_p, we can put</span>
<a href="#l2.572"></a><span id="l2.572" class="difflineplus">+     body-&gt;options back to what it's supposed to be. Avoids a memory</span>
<a href="#l2.573"></a><span id="l2.573" class="difflineplus">+     leak. */</span>
<a href="#l2.574"></a><span id="l2.574" class="difflineplus">+  delete body-&gt;options;</span>
<a href="#l2.575"></a><span id="l2.575" class="difflineplus">+  body-&gt;options = obj-&gt;options;</span>
<a href="#l2.576"></a><span id="l2.576"> </span>
<a href="#l2.577"></a><span id="l2.577"> #ifdef MIME_DRAFTS</span>
<a href="#l2.578"></a><span id="l2.578">   if (decomposeFile &amp;&amp; !multipartRelatedChild)</span>
<a href="#l2.579"></a><span id="l2.579" class="difflineminus">-    status = MimePartBufferRead (malt-&gt;part_buffer,</span>
<a href="#l2.580"></a><span id="l2.580" class="difflineplus">+    status = MimePartBufferRead (buffer,</span>
<a href="#l2.581"></a><span id="l2.581">                   obj-&gt;options-&gt;decompose_file_output_fn,</span>
<a href="#l2.582"></a><span id="l2.582">                   obj-&gt;options-&gt;stream_closure);</span>
<a href="#l2.583"></a><span id="l2.583">   else</span>
<a href="#l2.584"></a><span id="l2.584"> #endif /* MIME_DRAFTS */</span>
<a href="#l2.585"></a><span id="l2.585"> </span>
<a href="#l2.586"></a><span id="l2.586" class="difflineminus">-  status = MimePartBufferRead (malt-&gt;part_buffer,</span>
<a href="#l2.587"></a><span id="l2.587" class="difflineplus">+  status = MimePartBufferRead (buffer,</span>
<a href="#l2.588"></a><span id="l2.588">                   /* The (nsresult (*) ...) cast is to turn the</span>
<a href="#l2.589"></a><span id="l2.589">                    `void' argument into `MimeObject'. */</span>
<a href="#l2.590"></a><span id="l2.590">                   ((nsresult (*) (const char *, PRInt32, void *))</span>
<a href="#l2.591"></a><span id="l2.591">                   body-&gt;clazz-&gt;parse_buffer),</span>
<a href="#l2.592"></a><span id="l2.592">                   body);</span>
<a href="#l2.593"></a><span id="l2.593"> </span>
<a href="#l2.594"></a><span id="l2.594">   if (status &lt; 0) return status;</span>
<a href="#l2.595"></a><span id="l2.595"> </span>
<a href="#l2.596"></a><span id="l2.596" class="difflineminus">-  MimeMultipartAlternative_cleanup(obj);</span>
<a href="#l2.597"></a><span id="l2.597" class="difflineminus">-</span>
<a href="#l2.598"></a><span id="l2.598">   /* Done parsing. */</span>
<a href="#l2.599"></a><span id="l2.599">   status = body-&gt;clazz-&gt;parse_eof(body, PR_FALSE);</span>
<a href="#l2.600"></a><span id="l2.600">   if (status &lt; 0) return status;</span>
<a href="#l2.601"></a><span id="l2.601">   status = body-&gt;clazz-&gt;parse_end(body, PR_FALSE);</span>
<a href="#l2.602"></a><span id="l2.602">   if (status &lt; 0) return status;</span>
<a href="#l2.603"></a><span id="l2.603"> </span>
<a href="#l2.604"></a><span id="l2.604"> #ifdef MIME_DRAFTS</span>
<a href="#l2.605"></a><span id="l2.605">   if (decomposeFile)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/mime/src/mimemalt.h</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/mime/src/mimemalt.h</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -53,15 +53,16 @@ struct MimeMultipartAlternativeClass {</span>
<a href="#l3.4"></a><span id="l3.4">   MimeMultipartClass multipart;</span>
<a href="#l3.5"></a><span id="l3.5"> };</span>
<a href="#l3.6"></a><span id="l3.6"> </span>
<a href="#l3.7"></a><span id="l3.7"> extern &quot;C&quot; MimeMultipartAlternativeClass mimeMultipartAlternativeClass;</span>
<a href="#l3.8"></a><span id="l3.8"> </span>
<a href="#l3.9"></a><span id="l3.9"> struct MimeMultipartAlternative {</span>
<a href="#l3.10"></a><span id="l3.10">   MimeMultipart multipart;      /* superclass variables */</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-  MimeHeaders *buffered_hdrs;    /* The headers of the currently-pending</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-                     part. */</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-  MimePartBufferData *part_buffer;  /* The data of the current-pending part</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">-                     (see mimepbuf.h) */</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+  MimeHeaders **buffered_hdrs;    /* The headers of pending parts */</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+  MimePartBufferData **part_buffers;  /* The data of pending parts</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+                                         (see mimepbuf.h) */</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+  PRInt32 pending_parts;</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+  PRInt32 max_parts;</span>
<a href="#l3.21"></a><span id="l3.21"> };</span>
<a href="#l3.22"></a><span id="l3.22"> </span>
<a href="#l3.23"></a><span id="l3.23"> #endif /* _MIMEMALT_H_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/mime/src/mimemoz2.cpp</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/mime/src/mimemoz2.cpp</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -472,27 +472,34 @@ GenerateAttachmentData(MimeObject *objec</span>
<a href="#l4.4"></a><span id="l4.4"> }</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6"> nsresult</span>
<a href="#l4.7"></a><span id="l4.7"> BuildAttachmentList(MimeObject *anObject, nsMsgAttachmentData *aAttachData, const char *aMessageURL)</span>
<a href="#l4.8"></a><span id="l4.8"> {</span>
<a href="#l4.9"></a><span id="l4.9">   nsresult              rv;</span>
<a href="#l4.10"></a><span id="l4.10">   PRInt32               i;</span>
<a href="#l4.11"></a><span id="l4.11">   MimeContainer         *cobj = (MimeContainer *) anObject;</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+  PRBool                found_output = PR_FALSE;</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+  </span>
<a href="#l4.15"></a><span id="l4.15">   if ( (!anObject) || (!cobj-&gt;children) || (!cobj-&gt;nchildren) ||</span>
<a href="#l4.16"></a><span id="l4.16">        (mime_typep(anObject, (MimeObjectClass *)&amp;mimeExternalBodyClass)))</span>
<a href="#l4.17"></a><span id="l4.17">     return NS_OK;</span>
<a href="#l4.18"></a><span id="l4.18"> </span>
<a href="#l4.19"></a><span id="l4.19">   for (i = 0; i &lt; cobj-&gt;nchildren ; i++)</span>
<a href="#l4.20"></a><span id="l4.20">   {</span>
<a href="#l4.21"></a><span id="l4.21">     MimeObject    *child = cobj-&gt;children[i];</span>
<a href="#l4.22"></a><span id="l4.22"> </span>
<a href="#l4.23"></a><span id="l4.23" class="difflineminus">-    // Skip the first child if it's in fact a message body</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineminus">-    if (i == 0)                                         // it's the first child</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+    // Skip attachments that are not being output</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+    if (! child-&gt;output_p)</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+      continue;</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+    </span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+    // Skip the first child that's being output if it's in fact a message body</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+    PRBool first_output = !found_output;</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+    found_output = PR_TRUE;</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+    if (first_output)                                   // it's the first child being output</span>
<a href="#l4.33"></a><span id="l4.33">       if (child-&gt;content_type)                          // and it's content-type is one of folowing...</span>
<a href="#l4.34"></a><span id="l4.34">         if (!PL_strcasecmp (child-&gt;content_type, TEXT_PLAIN) ||</span>
<a href="#l4.35"></a><span id="l4.35">             !PL_strcasecmp (child-&gt;content_type, TEXT_HTML) ||</span>
<a href="#l4.36"></a><span id="l4.36">             !PL_strcasecmp (child-&gt;content_type, TEXT_MDL))</span>
<a href="#l4.37"></a><span id="l4.37">         {</span>
<a href="#l4.38"></a><span id="l4.38">                               // and it doesn't have a filename</span>
<a href="#l4.39"></a><span id="l4.39">           if (child-&gt;headers) // and finally, be sure it doesn't have a content-disposition: attachment</span>
<a href="#l4.40"></a><span id="l4.40">           {</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineat">@@ -1296,74 +1303,69 @@ mime_get_main_object(MimeObject* obj)</span>
<a href="#l4.42"></a><span id="l4.42">         // return the given child object.</span>
<a href="#l4.43"></a><span id="l4.43">         return obj;</span>
<a href="#l4.44"></a><span id="l4.44">       }</span>
<a href="#l4.45"></a><span id="l4.45">     }</span>
<a href="#l4.46"></a><span id="l4.46">   }</span>
<a href="#l4.47"></a><span id="l4.47">   return nsnull;</span>
<a href="#l4.48"></a><span id="l4.48"> }</span>
<a href="#l4.49"></a><span id="l4.49"> </span>
<a href="#l4.50"></a><span id="l4.50" class="difflineminus">-PRBool MimeObjectChildIsMessageBody(MimeObject *obj,</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineminus">-                   PRBool *isAlternativeOrRelated)</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineplus">+static</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineplus">+PRBool MimeObjectIsMessageBodyNoClimb(MimeObject *parent,</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+                                      MimeObject *looking_for,</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+                                      PRBool *stop)</span>
<a href="#l4.56"></a><span id="l4.56"> {</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineminus">-  char *disp = 0;</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineminus">-  PRBool bRet = PR_FALSE;</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineminus">-  MimeObject *firstChild = 0;</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineminus">-  MimeContainer *container = (MimeContainer*) obj;</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineplus">+  MimeContainer *container = (MimeContainer *)parent;</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+  PRInt32 i;</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+  char *disp;</span>
<a href="#l4.64"></a><span id="l4.64"> </span>
<a href="#l4.65"></a><span id="l4.65" class="difflineminus">-  if (isAlternativeOrRelated)</span>
<a href="#l4.66"></a><span id="l4.66" class="difflineminus">-    *isAlternativeOrRelated = PR_FALSE;</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineplus">+  NS_ASSERTION(stop, &quot;NULL stop to MimeObjectIsMessageBodyNoClimb&quot;);</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineplus">+</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+  for (i = 0; i &lt; container-&gt;nchildren; i++) {</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+    MimeObject *child = container-&gt;children[i];</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineplus">+    PRBool is_body = PR_FALSE;</span>
<a href="#l4.72"></a><span id="l4.72"> </span>
<a href="#l4.73"></a><span id="l4.73" class="difflineminus">-  if (!container ||</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineminus">-    !mime_subclass_p(obj-&gt;clazz,</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineminus">-             (MimeObjectClass*) &amp;mimeContainerClass))</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineminus">-  {</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineminus">-    return bRet;</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineminus">-  }</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineminus">-  else if (mime_subclass_p(obj-&gt;clazz, (MimeObjectClass*)</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineminus">-               &amp;mimeMultipartRelatedClass))</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineminus">-  {</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineminus">-    if (isAlternativeOrRelated)</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineminus">-      *isAlternativeOrRelated = PR_TRUE;</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineminus">-    return bRet;</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+    // The body can't be something we're not displaying.</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineplus">+    if (! child-&gt;output_p)</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineplus">+      is_body = PR_FALSE;</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineplus">+    else if ((disp = MimeHeaders_get (child-&gt;headers, HEADER_CONTENT_DISPOSITION,</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineplus">+                                      PR_TRUE, PR_FALSE))) {</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+      PR_Free(disp);</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+      is_body = PR_FALSE;</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+    }</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+    else if (PL_strcasecmp (child-&gt;content_type, TEXT_PLAIN) &amp;&amp;</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+             PL_strcasecmp (child-&gt;content_type, TEXT_HTML) &amp;&amp;</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+             PL_strcasecmp (child-&gt;content_type, TEXT_MDL) &amp;&amp;</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+             PL_strcasecmp (child-&gt;content_type, MESSAGE_NEWS) &amp;&amp;</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+             PL_strcasecmp (child-&gt;content_type, MESSAGE_RFC822))</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineplus">+      is_body = PR_FALSE;</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineplus">+</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+    if (is_body || child == looking_for) {</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+      *stop = PR_TRUE;</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineplus">+      return child == looking_for;</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineplus">+    }</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+    // The body could be down inside a multipart child, so search recursively.</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+    if (mime_subclass_p(child-&gt;clazz, (MimeObjectClass*) &amp;mimeContainerClass)) {</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+      is_body = MimeObjectIsMessageBodyNoClimb(child, looking_for, stop);</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+      if (is_body || *stop)</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+        return is_body;</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+    }</span>
<a href="#l4.111"></a><span id="l4.111">   }</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineminus">-  else if (mime_subclass_p(obj-&gt;clazz, (MimeObjectClass*)</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineminus">-               &amp;mimeMultipartAlternativeClass))</span>
<a href="#l4.114"></a><span id="l4.114" class="difflineminus">-  {</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineminus">-    if (isAlternativeOrRelated)</span>
<a href="#l4.116"></a><span id="l4.116" class="difflineminus">-      *isAlternativeOrRelated = PR_TRUE;</span>
<a href="#l4.117"></a><span id="l4.117" class="difflineminus">-    return bRet;</span>
<a href="#l4.118"></a><span id="l4.118" class="difflineminus">-  }</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineminus">-</span>
<a href="#l4.120"></a><span id="l4.120" class="difflineminus">-  if (container-&gt;children)</span>
<a href="#l4.121"></a><span id="l4.121" class="difflineminus">-    firstChild = container-&gt;children[0];</span>
<a href="#l4.122"></a><span id="l4.122" class="difflineminus">-</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineminus">-  if (!firstChild ||</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineminus">-    !firstChild-&gt;content_type ||</span>
<a href="#l4.125"></a><span id="l4.125" class="difflineminus">-    !firstChild-&gt;headers)</span>
<a href="#l4.126"></a><span id="l4.126" class="difflineminus">-    return bRet;</span>
<a href="#l4.127"></a><span id="l4.127" class="difflineplus">+  return PR_FALSE;</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineplus">+}</span>
<a href="#l4.129"></a><span id="l4.129"> </span>
<a href="#l4.130"></a><span id="l4.130" class="difflineminus">-  disp = MimeHeaders_get (firstChild-&gt;headers,</span>
<a href="#l4.131"></a><span id="l4.131" class="difflineminus">-              HEADER_CONTENT_DISPOSITION,</span>
<a href="#l4.132"></a><span id="l4.132" class="difflineminus">-              PR_TRUE,</span>
<a href="#l4.133"></a><span id="l4.133" class="difflineminus">-              PR_FALSE);</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineminus">-  if (disp /* &amp;&amp; !PL_strcasecmp (disp, &quot;attachment&quot;) */)</span>
<a href="#l4.135"></a><span id="l4.135" class="difflineminus">-    bRet = PR_FALSE;</span>
<a href="#l4.136"></a><span id="l4.136" class="difflineminus">-  else if (!PL_strcasecmp (firstChild-&gt;content_type, TEXT_PLAIN) ||</span>
<a href="#l4.137"></a><span id="l4.137" class="difflineminus">-       !PL_strcasecmp (firstChild-&gt;content_type, TEXT_HTML) ||</span>
<a href="#l4.138"></a><span id="l4.138" class="difflineminus">-       !PL_strcasecmp (firstChild-&gt;content_type, TEXT_MDL) ||</span>
<a href="#l4.139"></a><span id="l4.139" class="difflineminus">-       !PL_strcasecmp (firstChild-&gt;content_type, MULTIPART_ALTERNATIVE) ||</span>
<a href="#l4.140"></a><span id="l4.140" class="difflineminus">-       !PL_strcasecmp (firstChild-&gt;content_type, MULTIPART_RELATED) ||</span>
<a href="#l4.141"></a><span id="l4.141" class="difflineminus">-       !PL_strcasecmp (firstChild-&gt;content_type, MESSAGE_NEWS) ||</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineminus">-       !PL_strcasecmp (firstChild-&gt;content_type, MESSAGE_RFC822))</span>
<a href="#l4.143"></a><span id="l4.143" class="difflineminus">-    bRet = PR_TRUE;</span>
<a href="#l4.144"></a><span id="l4.144" class="difflineminus">-  else</span>
<a href="#l4.145"></a><span id="l4.145" class="difflineminus">-    bRet = PR_FALSE;</span>
<a href="#l4.146"></a><span id="l4.146" class="difflineminus">-  PR_FREEIF(disp);</span>
<a href="#l4.147"></a><span id="l4.147" class="difflineminus">-  return bRet;</span>
<a href="#l4.148"></a><span id="l4.148" class="difflineplus">+/* Should this be static in mimemult.cpp? */</span>
<a href="#l4.149"></a><span id="l4.149" class="difflineplus">+PRBool MimeObjectIsMessageBody(MimeObject *looking_for)</span>
<a href="#l4.150"></a><span id="l4.150" class="difflineplus">+{</span>
<a href="#l4.151"></a><span id="l4.151" class="difflineplus">+  PRBool stop = PR_FALSE;</span>
<a href="#l4.152"></a><span id="l4.152" class="difflineplus">+  MimeObject *root = looking_for;</span>
<a href="#l4.153"></a><span id="l4.153" class="difflineplus">+  while (root-&gt;parent)</span>
<a href="#l4.154"></a><span id="l4.154" class="difflineplus">+    root = root-&gt;parent;</span>
<a href="#l4.155"></a><span id="l4.155" class="difflineplus">+  return MimeObjectIsMessageBodyNoClimb(root, looking_for, &amp;stop);</span>
<a href="#l4.156"></a><span id="l4.156"> }</span>
<a href="#l4.157"></a><span id="l4.157"> </span>
<a href="#l4.158"></a><span id="l4.158"> //</span>
<a href="#l4.159"></a><span id="l4.159"> // New Stream Converter Interface</span>
<a href="#l4.160"></a><span id="l4.160"> //</span>
<a href="#l4.161"></a><span id="l4.161"> </span>
<a href="#l4.162"></a><span id="l4.162"> // Get the connnection to prefs service manager</span>
<a href="#l4.163"></a><span id="l4.163"> nsIPrefBranch *</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/mime/src/mimemult.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/mime/src/mimemult.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -15,16 +15,17 @@</span>
<a href="#l5.4"></a><span id="l5.4">  * The Original Code is mozilla.org code.</span>
<a href="#l5.5"></a><span id="l5.5">  *</span>
<a href="#l5.6"></a><span id="l5.6">  * The Initial Developer of the Original Code is</span>
<a href="#l5.7"></a><span id="l5.7">  * Netscape Communications Corporation.</span>
<a href="#l5.8"></a><span id="l5.8">  * Portions created by the Initial Developer are Copyright (C) 1998</span>
<a href="#l5.9"></a><span id="l5.9">  * the Initial Developer. All Rights Reserved.</span>
<a href="#l5.10"></a><span id="l5.10">  *</span>
<a href="#l5.11"></a><span id="l5.11">  * Contributor(s):</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+ *   Jonathan Kamens &lt;jik@kamens.us&gt;</span>
<a href="#l5.13"></a><span id="l5.13">  *</span>
<a href="#l5.14"></a><span id="l5.14">  * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l5.15"></a><span id="l5.15">  * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l5.16"></a><span id="l5.16">  * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l5.17"></a><span id="l5.17">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l5.18"></a><span id="l5.18">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l5.19"></a><span id="l5.19">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l5.20"></a><span id="l5.20">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineat">@@ -144,16 +145,17 @@ int MimeWriteAString(MimeObject *obj, co</span>
<a href="#l5.22"></a><span id="l5.22">   const nsCString &amp;flatString = PromiseFlatCString(string);</span>
<a href="#l5.23"></a><span id="l5.23">   return MimeObject_write(obj, flatString.get(), flatString.Length(), PR_TRUE);</span>
<a href="#l5.24"></a><span id="l5.24"> }</span>
<a href="#l5.25"></a><span id="l5.25"> </span>
<a href="#l5.26"></a><span id="l5.26"> static int</span>
<a href="#l5.27"></a><span id="l5.27"> MimeMultipart_parse_line (const char *line, PRInt32 length, MimeObject *obj)</span>
<a href="#l5.28"></a><span id="l5.28"> {</span>
<a href="#l5.29"></a><span id="l5.29">   MimeMultipart *mult = (MimeMultipart *) obj;</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+  MimeContainer *container = (MimeContainer*) obj; </span>
<a href="#l5.31"></a><span id="l5.31">   int status = 0;</span>
<a href="#l5.32"></a><span id="l5.32">   MimeMultipartBoundaryType boundary;</span>
<a href="#l5.33"></a><span id="l5.33"> </span>
<a href="#l5.34"></a><span id="l5.34">   NS_ASSERTION(line &amp;&amp; *line, &quot;empty line in multipart parse_line&quot;);</span>
<a href="#l5.35"></a><span id="l5.35">   if (!line || !*line) return -1;</span>
<a href="#l5.36"></a><span id="l5.36"> </span>
<a href="#l5.37"></a><span id="l5.37">   NS_ASSERTION(!obj-&gt;closed_p, &quot;obj shouldn't already be closed&quot;);</span>
<a href="#l5.38"></a><span id="l5.38">   if (obj-&gt;closed_p) return -1;</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineat">@@ -196,17 +198,16 @@ MimeMultipart_parse_line (const char *li</span>
<a href="#l5.40"></a><span id="l5.40">         MimeHeaders_free(mult-&gt;hdrs);</span>
<a href="#l5.41"></a><span id="l5.41">       mult-&gt;hdrs = MimeHeaders_new();</span>
<a href="#l5.42"></a><span id="l5.42">       if (!mult-&gt;hdrs)</span>
<a href="#l5.43"></a><span id="l5.43">         return MIME_OUT_OF_MEMORY;</span>
<a href="#l5.44"></a><span id="l5.44">       if (obj-&gt;options &amp;&amp; obj-&gt;options-&gt;state &amp;&amp;</span>
<a href="#l5.45"></a><span id="l5.45">           obj-&gt;options-&gt;state-&gt;partsToStrip.Length() &gt; 0)</span>
<a href="#l5.46"></a><span id="l5.46">       {</span>
<a href="#l5.47"></a><span id="l5.47">         nsCAutoString newPart(mime_part_address(obj));</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineminus">-        MimeContainer *container = (MimeContainer*) obj; </span>
<a href="#l5.49"></a><span id="l5.49">         newPart.Append('.');</span>
<a href="#l5.50"></a><span id="l5.50">         newPart.AppendInt(container-&gt;nchildren + 1);</span>
<a href="#l5.51"></a><span id="l5.51">         obj-&gt;options-&gt;state-&gt;strippingPart = PR_FALSE;</span>
<a href="#l5.52"></a><span id="l5.52">         // check if this is a sub-part of a part we're stripping.</span>
<a href="#l5.53"></a><span id="l5.53">         for (PRUint32 partIndex = 0; partIndex &lt; obj-&gt;options-&gt;state-&gt;partsToStrip.Length(); partIndex++)</span>
<a href="#l5.54"></a><span id="l5.54">         {</span>
<a href="#l5.55"></a><span id="l5.55">           nsCString &amp;curPartToStrip = obj-&gt;options-&gt;state-&gt;partsToStrip[partIndex];</span>
<a href="#l5.56"></a><span id="l5.56">           if (newPart.Find(curPartToStrip) == 0 &amp;&amp; (newPart.Length() == curPartToStrip.Length() || newPart.CharAt(curPartToStrip.Length()) == '.'))</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineat">@@ -245,26 +246,29 @@ MimeMultipart_parse_line (const char *li</span>
<a href="#l5.58"></a><span id="l5.58">     case MimeMultipartEpilogue:</span>
<a href="#l5.59"></a><span id="l5.59">       /* Ignore this line. */</span>
<a href="#l5.60"></a><span id="l5.60">       break;</span>
<a href="#l5.61"></a><span id="l5.61"> </span>
<a href="#l5.62"></a><span id="l5.62">     case MimeMultipartHeaders:</span>
<a href="#l5.63"></a><span id="l5.63">     /* Parse this line as a header for the sub-part. */</span>
<a href="#l5.64"></a><span id="l5.64">     {</span>
<a href="#l5.65"></a><span id="l5.65">       status = MimeHeaders_parse_line(line, length, mult-&gt;hdrs);</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+      PRBool stripping = PR_FALSE;</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+</span>
<a href="#l5.68"></a><span id="l5.68">       if (status &lt; 0) return status;</span>
<a href="#l5.69"></a><span id="l5.69">       </span>
<a href="#l5.70"></a><span id="l5.70">       // If this line is blank, we're now done parsing headers, and should</span>
<a href="#l5.71"></a><span id="l5.71">       // now examine the content-type to create this &quot;body&quot; part.</span>
<a href="#l5.72"></a><span id="l5.72">       //</span>
<a href="#l5.73"></a><span id="l5.73">       if (*line == '\r' || *line == '\n')</span>
<a href="#l5.74"></a><span id="l5.74">       {</span>
<a href="#l5.75"></a><span id="l5.75">         if (obj-&gt;options &amp;&amp; obj-&gt;options-&gt;state &amp;&amp;</span>
<a href="#l5.76"></a><span id="l5.76">             obj-&gt;options-&gt;state-&gt;strippingPart)</span>
<a href="#l5.77"></a><span id="l5.77">         {</span>
<a href="#l5.78"></a><span id="l5.78" class="difflineplus">+          stripping = PR_TRUE;</span>
<a href="#l5.79"></a><span id="l5.79">           PRBool detachingPart = obj-&gt;options-&gt;state-&gt;detachedFilePath.Length() &gt; 0;</span>
<a href="#l5.80"></a><span id="l5.80"> </span>
<a href="#l5.81"></a><span id="l5.81">           nsCAutoString fileName;</span>
<a href="#l5.82"></a><span id="l5.82">           fileName.Adopt(MimeHeaders_get_name(mult-&gt;hdrs, obj-&gt;options));</span>
<a href="#l5.83"></a><span id="l5.83">           if (detachingPart)</span>
<a href="#l5.84"></a><span id="l5.84">           {</span>
<a href="#l5.85"></a><span id="l5.85">             char *contentType = MimeHeaders_get(mult-&gt;hdrs, &quot;Content-Type&quot;, PR_FALSE, PR_FALSE);</span>
<a href="#l5.86"></a><span id="l5.86">             if (contentType)</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineat">@@ -301,117 +305,27 @@ MimeMultipart_parse_line (const char *li</span>
<a href="#l5.88"></a><span id="l5.88">           PR_FormatTimeUSEnglish(timeBuffer, sizeof(timeBuffer),</span>
<a href="#l5.89"></a><span id="l5.89">                                  &quot;%a %b %d %H:%M:%S %Y&quot;,</span>
<a href="#l5.90"></a><span id="l5.90">                                  &amp;now);</span>
<a href="#l5.91"></a><span id="l5.91">           MimeWriteAString(obj, nsDependentCString(timeBuffer));</span>
<a href="#l5.92"></a><span id="l5.92">           MimeWriteAString(obj, NS_LITERAL_CSTRING(&quot;\&quot;&quot;MSG_LINEBREAK));</span>
<a href="#l5.93"></a><span id="l5.93">           MimeWriteAString(obj, NS_LITERAL_CSTRING(MSG_LINEBREAK&quot;You deleted an attachment from this message. The original MIME headers for the attachment were:&quot;MSG_LINEBREAK));</span>
<a href="#l5.94"></a><span id="l5.94">           MimeHeaders_write_raw_headers(mult-&gt;hdrs, obj-&gt;options, PR_FALSE);</span>
<a href="#l5.95"></a><span id="l5.95">         }</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+        PRInt32 old_nchildren = container-&gt;nchildren;</span>
<a href="#l5.97"></a><span id="l5.97">         status = ((MimeMultipartClass *) obj-&gt;clazz)-&gt;create_child(obj);</span>
<a href="#l5.98"></a><span id="l5.98">         if (status &lt; 0) return status;</span>
<a href="#l5.99"></a><span id="l5.99">         NS_ASSERTION(mult-&gt;state != MimeMultipartHeaders,</span>
<a href="#l5.100"></a><span id="l5.100">                      &quot;mult-&gt;state shouldn't be MimeMultipartHeaders&quot;);</span>
<a href="#l5.101"></a><span id="l5.101"> </span>
<a href="#l5.102"></a><span id="l5.102" class="difflineminus">-        // Ok, at this point, we need to examine the headers and see if there</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineminus">-        // is a special charset (i.e. non US-ASCII) for this message. If so, </span>
<a href="#l5.104"></a><span id="l5.104" class="difflineminus">-        // we need to tell the emitter that this is the case for use in in any</span>
<a href="#l5.105"></a><span id="l5.105" class="difflineminus">-        // possible reply or forward operation.</span>
<a href="#l5.106"></a><span id="l5.106" class="difflineminus">-        //</span>
<a href="#l5.107"></a><span id="l5.107" class="difflineminus">-        PRBool isBody = PR_FALSE;</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineminus">-        PRBool isAlternative = PR_FALSE;</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineminus">-</span>
<a href="#l5.110"></a><span id="l5.110" class="difflineminus">-        MimeContainer *container = (MimeContainer*) obj; </span>
<a href="#l5.111"></a><span id="l5.111" class="difflineminus">-        // check if we're stripping the part of this newly created child.</span>
<a href="#l5.112"></a><span id="l5.112" class="difflineminus">-        if (container-&gt;children &amp;&amp; container-&gt;nchildren &gt; 0)</span>
<a href="#l5.113"></a><span id="l5.113" class="difflineminus">-        {</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineplus">+        if (!stripping &amp;&amp; container-&gt;nchildren &gt; old_nchildren &amp;&amp; obj-&gt;options &amp;&amp;</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineplus">+            !mime_typep(obj, (MimeObjectClass*)&amp;mimeMultipartAlternativeClass)) {</span>
<a href="#l5.116"></a><span id="l5.116" class="difflineplus">+          // Notify emitter about content type and part path.</span>
<a href="#l5.117"></a><span id="l5.117">           MimeObject *kid = container-&gt;children[container-&gt;nchildren-1];</span>
<a href="#l5.118"></a><span id="l5.118" class="difflineminus">-          if (kid-&gt;output_p)</span>
<a href="#l5.119"></a><span id="l5.119" class="difflineminus">-            kid-&gt;output_p = !(obj-&gt;options &amp;&amp; obj-&gt;options-&gt;state &amp;&amp;</span>
<a href="#l5.120"></a><span id="l5.120" class="difflineminus">-                              obj-&gt;options-&gt;state-&gt;strippingPart);</span>
<a href="#l5.121"></a><span id="l5.121" class="difflineminus">-        }</span>
<a href="#l5.122"></a><span id="l5.122" class="difflineminus">-        if (container-&gt;children &amp;&amp; container-&gt;nchildren == 1)</span>
<a href="#l5.123"></a><span id="l5.123" class="difflineminus">-        {</span>
<a href="#l5.124"></a><span id="l5.124" class="difflineminus">-          PRBool isAlternativeOrRelated = PR_FALSE;</span>
<a href="#l5.125"></a><span id="l5.125" class="difflineminus">-          isBody = MimeObjectChildIsMessageBody(obj, &amp;isAlternativeOrRelated);</span>
<a href="#l5.126"></a><span id="l5.126" class="difflineminus">-</span>
<a href="#l5.127"></a><span id="l5.127" class="difflineminus">-          // MimeObjectChildIsMessageBody returns false for &quot;multipart/related&quot;</span>
<a href="#l5.128"></a><span id="l5.128" class="difflineminus">-          // but we want to use the first part charset if that's a body.</span>
<a href="#l5.129"></a><span id="l5.129" class="difflineminus">-          // I don't want to change the behavior of MimeObjectChildIsMessageBody</span>
<a href="#l5.130"></a><span id="l5.130" class="difflineminus">-          // which is used by other places, so do the body check here.</span>
<a href="#l5.131"></a><span id="l5.131" class="difflineminus">-          if (!isBody &amp;&amp; </span>
<a href="#l5.132"></a><span id="l5.132" class="difflineminus">-              isAlternativeOrRelated &amp;&amp;</span>
<a href="#l5.133"></a><span id="l5.133" class="difflineminus">-              mime_subclass_p(obj-&gt;clazz, (MimeObjectClass*) &amp;mimeMultipartRelatedClass))</span>
<a href="#l5.134"></a><span id="l5.134" class="difflineminus">-          {</span>
<a href="#l5.135"></a><span id="l5.135" class="difflineminus">-            MimeObject *firstChild = container-&gt;children[0];</span>
<a href="#l5.136"></a><span id="l5.136" class="difflineminus">-            char *disposition = MimeHeaders_get (firstChild-&gt;headers,</span>
<a href="#l5.137"></a><span id="l5.137" class="difflineminus">-                                                 HEADER_CONTENT_DISPOSITION, </span>
<a href="#l5.138"></a><span id="l5.138" class="difflineminus">-                                                 PR_TRUE,</span>
<a href="#l5.139"></a><span id="l5.139" class="difflineminus">-                                                 PR_FALSE);</span>
<a href="#l5.140"></a><span id="l5.140" class="difflineminus">-            if (!disposition)</span>
<a href="#l5.141"></a><span id="l5.141" class="difflineminus">-            {</span>
<a href="#l5.142"></a><span id="l5.142" class="difflineminus">-              if (!PL_strcasecmp (firstChild-&gt;content_type, TEXT_PLAIN) ||</span>
<a href="#l5.143"></a><span id="l5.143" class="difflineminus">-                  !PL_strcasecmp (firstChild-&gt;content_type, TEXT_HTML) ||</span>
<a href="#l5.144"></a><span id="l5.144" class="difflineminus">-                  !PL_strcasecmp (firstChild-&gt;content_type, TEXT_MDL) ||</span>
<a href="#l5.145"></a><span id="l5.145" class="difflineminus">-                  !PL_strcasecmp (firstChild-&gt;content_type, MULTIPART_ALTERNATIVE) ||</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineminus">-                  !PL_strcasecmp (firstChild-&gt;content_type, MULTIPART_RELATED) ||</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineminus">-                  !PL_strcasecmp (firstChild-&gt;content_type, MESSAGE_NEWS) ||</span>
<a href="#l5.148"></a><span id="l5.148" class="difflineminus">-                  !PL_strcasecmp (firstChild-&gt;content_type, MESSAGE_RFC822))</span>
<a href="#l5.149"></a><span id="l5.149" class="difflineminus">-                isBody = PR_TRUE;</span>
<a href="#l5.150"></a><span id="l5.150" class="difflineminus">-            }</span>
<a href="#l5.151"></a><span id="l5.151" class="difflineminus">-          }</span>
<a href="#l5.152"></a><span id="l5.152" class="difflineminus">-        }</span>
<a href="#l5.153"></a><span id="l5.153" class="difflineminus">-        else </span>
<a href="#l5.154"></a><span id="l5.154" class="difflineminus">-          isAlternative = mime_subclass_p(obj-&gt;clazz, (MimeObjectClass*) &amp;mimeMultipartAlternativeClass);</span>
<a href="#l5.155"></a><span id="l5.155" class="difflineminus">-</span>
<a href="#l5.156"></a><span id="l5.156" class="difflineminus">-        // If &quot;multipart/alternative&quot; or the first part is a message body</span>
<a href="#l5.157"></a><span id="l5.157" class="difflineminus">-        // then we should check for a charset and notify the emitter  </span>
<a href="#l5.158"></a><span id="l5.158" class="difflineminus">-        // if one exists.</span>
<a href="#l5.159"></a><span id="l5.159" class="difflineminus">-        if (obj-&gt;options &amp;&amp;</span>
<a href="#l5.160"></a><span id="l5.160" class="difflineminus">-            ((isAlternative &amp;&amp; mult-&gt;state != MimeMultipartSkipPartLine) ||</span>
<a href="#l5.161"></a><span id="l5.161" class="difflineminus">-             isBody || obj-&gt;options-&gt;notify_nested_bodies))</span>
<a href="#l5.162"></a><span id="l5.162" class="difflineminus">-        {</span>
<a href="#l5.163"></a><span id="l5.163" class="difflineminus">-          {</span>
<a href="#l5.164"></a><span id="l5.164" class="difflineminus">-            char *ct = MimeHeaders_get(mult-&gt;hdrs, HEADER_CONTENT_TYPE, PR_FALSE, PR_FALSE);</span>
<a href="#l5.165"></a><span id="l5.165" class="difflineminus">-            if (ct)</span>
<a href="#l5.166"></a><span id="l5.166" class="difflineminus">-            {</span>
<a href="#l5.167"></a><span id="l5.167" class="difflineminus">-              if (obj-&gt;options-&gt;notify_nested_bodies)</span>
<a href="#l5.168"></a><span id="l5.168" class="difflineminus">-                mimeEmitterAddHeaderField(obj-&gt;options, HEADER_CONTENT_TYPE,</span>
<a href="#l5.169"></a><span id="l5.169" class="difflineminus">-                                          ct);</span>
<a href="#l5.170"></a><span id="l5.170" class="difflineminus">-             char *cset = MimeHeaders_get_parameter (ct, &quot;charset&quot;, NULL, NULL);</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineminus">-             if (cset)</span>
<a href="#l5.172"></a><span id="l5.172" class="difflineminus">-             {</span>
<a href="#l5.173"></a><span id="l5.173" class="difflineminus">-                mimeEmitterUpdateCharacterSet(obj-&gt;options, cset);</span>
<a href="#l5.174"></a><span id="l5.174" class="difflineminus">-                if (!(obj-&gt;options-&gt;override_charset))</span>
<a href="#l5.175"></a><span id="l5.175" class="difflineminus">-                  // Also set this charset to msgWindow</span>
<a href="#l5.176"></a><span id="l5.176" class="difflineminus">-                  SetMailCharacterSetToMsgWindow(obj, cset);</span>
<a href="#l5.177"></a><span id="l5.177" class="difflineminus">-              }</span>
<a href="#l5.178"></a><span id="l5.178" class="difflineminus">-</span>
<a href="#l5.179"></a><span id="l5.179" class="difflineminus">-              PR_FREEIF(ct);</span>
<a href="#l5.180"></a><span id="l5.180" class="difflineminus">-              PR_FREEIF(cset);</span>
<a href="#l5.181"></a><span id="l5.181" class="difflineminus">-            }</span>
<a href="#l5.182"></a><span id="l5.182" class="difflineminus">-            // no content type means text/plain.</span>
<a href="#l5.183"></a><span id="l5.183" class="difflineminus">-            else if (obj-&gt;options-&gt;notify_nested_bodies)</span>
<a href="#l5.184"></a><span id="l5.184" class="difflineminus">-            {</span>
<a href="#l5.185"></a><span id="l5.185" class="difflineminus">-              mimeEmitterAddHeaderField(obj-&gt;options, HEADER_CONTENT_TYPE,</span>
<a href="#l5.186"></a><span id="l5.186" class="difflineminus">-                                        &quot;text/plain&quot;);</span>
<a href="#l5.187"></a><span id="l5.187" class="difflineminus">-            }</span>
<a href="#l5.188"></a><span id="l5.188" class="difflineminus">-            if (obj-&gt;options-&gt;notify_nested_bodies &amp;&amp; container-&gt;nchildren)</span>
<a href="#l5.189"></a><span id="l5.189" class="difflineminus">-            {</span>
<a href="#l5.190"></a><span id="l5.190" class="difflineminus">-              MimeObject *kid = container-&gt;children[container-&gt;nchildren-1];</span>
<a href="#l5.191"></a><span id="l5.191" class="difflineminus">-              char *part_path = mime_part_address(kid);</span>
<a href="#l5.192"></a><span id="l5.192" class="difflineminus">-              if (part_path)</span>
<a href="#l5.193"></a><span id="l5.193" class="difflineminus">-              {</span>
<a href="#l5.194"></a><span id="l5.194" class="difflineminus">-                mimeEmitterAddHeaderField(obj-&gt;options,</span>
<a href="#l5.195"></a><span id="l5.195" class="difflineminus">-                                          &quot;x-jsemitter-part-path&quot;,</span>
<a href="#l5.196"></a><span id="l5.196" class="difflineminus">-                                          part_path);</span>
<a href="#l5.197"></a><span id="l5.197" class="difflineminus">-                PR_Free(part_path);</span>
<a href="#l5.198"></a><span id="l5.198" class="difflineminus">-              }</span>
<a href="#l5.199"></a><span id="l5.199" class="difflineminus">-            }</span>
<a href="#l5.200"></a><span id="l5.200" class="difflineminus">-          }</span>
<a href="#l5.201"></a><span id="l5.201" class="difflineplus">+          MimeMultipart_notify_emitter(kid);</span>
<a href="#l5.202"></a><span id="l5.202">         }</span>
<a href="#l5.203"></a><span id="l5.203">       }</span>
<a href="#l5.204"></a><span id="l5.204">       break;</span>
<a href="#l5.205"></a><span id="l5.205">     }</span>
<a href="#l5.206"></a><span id="l5.206"> </span>
<a href="#l5.207"></a><span id="l5.207">     case MimeMultipartPartFirstLine:</span>
<a href="#l5.208"></a><span id="l5.208">       /* Hand this line off to the sub-part. */</span>
<a href="#l5.209"></a><span id="l5.209">       status = (((MimeMultipartClass *) obj-&gt;clazz)-&gt;parse_child_line(obj,</span>
<a href="#l5.210"></a><span id="l5.210" class="difflineat">@@ -422,33 +336,68 @@ MimeMultipart_parse_line (const char *li</span>
<a href="#l5.211"></a><span id="l5.211"> </span>
<a href="#l5.212"></a><span id="l5.212">     case MimeMultipartPartLine:</span>
<a href="#l5.213"></a><span id="l5.213">       /* Hand this line off to the sub-part. */</span>
<a href="#l5.214"></a><span id="l5.214">       status = (((MimeMultipartClass *) obj-&gt;clazz)-&gt;parse_child_line(obj,</span>
<a href="#l5.215"></a><span id="l5.215">                   line, length, PR_FALSE));</span>
<a href="#l5.216"></a><span id="l5.216">       if (status &lt; 0) return status;</span>
<a href="#l5.217"></a><span id="l5.217">       break;</span>
<a href="#l5.218"></a><span id="l5.218"> </span>
<a href="#l5.219"></a><span id="l5.219" class="difflineminus">-    case MimeMultipartSkipPartLine:</span>
<a href="#l5.220"></a><span id="l5.220" class="difflineminus">-      /* we are skipping that part, therefore just ignore the line */</span>
<a href="#l5.221"></a><span id="l5.221" class="difflineminus">-      break;</span>
<a href="#l5.222"></a><span id="l5.222" class="difflineminus">-</span>
<a href="#l5.223"></a><span id="l5.223">     default:</span>
<a href="#l5.224"></a><span id="l5.224">       NS_ERROR(&quot;unexpected state in parse line&quot;);</span>
<a href="#l5.225"></a><span id="l5.225">       return -1;</span>
<a href="#l5.226"></a><span id="l5.226">   }</span>
<a href="#l5.227"></a><span id="l5.227"> </span>
<a href="#l5.228"></a><span id="l5.228">   if (obj-&gt;options &amp;&amp;</span>
<a href="#l5.229"></a><span id="l5.229">       obj-&gt;options-&gt;format_out == nsMimeOutput::nsMimeMessageAttach &amp;&amp;</span>
<a href="#l5.230"></a><span id="l5.230">       (!(obj-&gt;options-&gt;state &amp;&amp; obj-&gt;options-&gt;state-&gt;strippingPart) &amp;&amp;</span>
<a href="#l5.231"></a><span id="l5.231">       mult-&gt;state != MimeMultipartPartLine))</span>
<a href="#l5.232"></a><span id="l5.232">       return MimeObject_write(obj, line, length, PR_FALSE);</span>
<a href="#l5.233"></a><span id="l5.233">   return 0;</span>
<a href="#l5.234"></a><span id="l5.234"> }</span>
<a href="#l5.235"></a><span id="l5.235"> </span>
<a href="#l5.236"></a><span id="l5.236" class="difflineplus">+void MimeMultipart_notify_emitter(MimeObject *obj)</span>
<a href="#l5.237"></a><span id="l5.237" class="difflineplus">+{</span>
<a href="#l5.238"></a><span id="l5.238" class="difflineplus">+  char *ct = nsnull;</span>
<a href="#l5.239"></a><span id="l5.239" class="difflineplus">+</span>
<a href="#l5.240"></a><span id="l5.240" class="difflineplus">+  NS_ASSERTION(obj-&gt;options, &quot;MimeMultipart_notify_emitter called with null options&quot;);</span>
<a href="#l5.241"></a><span id="l5.241" class="difflineplus">+  if (! obj-&gt;options)</span>
<a href="#l5.242"></a><span id="l5.242" class="difflineplus">+    return;</span>
<a href="#l5.243"></a><span id="l5.243" class="difflineplus">+</span>
<a href="#l5.244"></a><span id="l5.244" class="difflineplus">+  ct = MimeHeaders_get(obj-&gt;headers, HEADER_CONTENT_TYPE,</span>
<a href="#l5.245"></a><span id="l5.245" class="difflineplus">+                       PR_FALSE, PR_FALSE);</span>
<a href="#l5.246"></a><span id="l5.246" class="difflineplus">+  if (obj-&gt;options-&gt;notify_nested_bodies) {</span>
<a href="#l5.247"></a><span id="l5.247" class="difflineplus">+    mimeEmitterAddHeaderField(obj-&gt;options, HEADER_CONTENT_TYPE,</span>
<a href="#l5.248"></a><span id="l5.248" class="difflineplus">+                              ct ? ct : TEXT_PLAIN);</span>
<a href="#l5.249"></a><span id="l5.249" class="difflineplus">+    char *part_path = mime_part_address(obj);</span>
<a href="#l5.250"></a><span id="l5.250" class="difflineplus">+    if (part_path) {</span>
<a href="#l5.251"></a><span id="l5.251" class="difflineplus">+      mimeEmitterAddHeaderField(obj-&gt;options, &quot;x-jsemitter-part-path&quot;,</span>
<a href="#l5.252"></a><span id="l5.252" class="difflineplus">+                                part_path);</span>
<a href="#l5.253"></a><span id="l5.253" class="difflineplus">+      PR_Free(part_path);</span>
<a href="#l5.254"></a><span id="l5.254" class="difflineplus">+    }</span>
<a href="#l5.255"></a><span id="l5.255" class="difflineplus">+  }</span>
<a href="#l5.256"></a><span id="l5.256" class="difflineplus">+</span>
<a href="#l5.257"></a><span id="l5.257" class="difflineplus">+  // Examine the headers and see if there is a special charset</span>
<a href="#l5.258"></a><span id="l5.258" class="difflineplus">+  // (i.e. non US-ASCII) for this message. If so, we need to</span>
<a href="#l5.259"></a><span id="l5.259" class="difflineplus">+  // tell the emitter that this is the case for use in any</span>
<a href="#l5.260"></a><span id="l5.260" class="difflineplus">+  // possible reply or forward operation.</span>
<a href="#l5.261"></a><span id="l5.261" class="difflineplus">+  if (ct &amp;&amp; (obj-&gt;options-&gt;notify_nested_bodies ||</span>
<a href="#l5.262"></a><span id="l5.262" class="difflineplus">+             MimeObjectIsMessageBody(obj))) {</span>
<a href="#l5.263"></a><span id="l5.263" class="difflineplus">+    char *cset = MimeHeaders_get_parameter(ct, &quot;charset&quot;, NULL, NULL);</span>
<a href="#l5.264"></a><span id="l5.264" class="difflineplus">+    if (cset) {</span>
<a href="#l5.265"></a><span id="l5.265" class="difflineplus">+      mimeEmitterUpdateCharacterSet(obj-&gt;options, cset);</span>
<a href="#l5.266"></a><span id="l5.266" class="difflineplus">+      if (!obj-&gt;options-&gt;override_charset)</span>
<a href="#l5.267"></a><span id="l5.267" class="difflineplus">+        // Also set this charset to msgWindow</span>
<a href="#l5.268"></a><span id="l5.268" class="difflineplus">+        SetMailCharacterSetToMsgWindow(obj, cset);</span>
<a href="#l5.269"></a><span id="l5.269" class="difflineplus">+      PR_Free(cset);</span>
<a href="#l5.270"></a><span id="l5.270" class="difflineplus">+    }</span>
<a href="#l5.271"></a><span id="l5.271" class="difflineplus">+  }</span>
<a href="#l5.272"></a><span id="l5.272" class="difflineplus">+</span>
<a href="#l5.273"></a><span id="l5.273" class="difflineplus">+  PR_FREEIF(ct);</span>
<a href="#l5.274"></a><span id="l5.274" class="difflineplus">+}</span>
<a href="#l5.275"></a><span id="l5.275"> </span>
<a href="#l5.276"></a><span id="l5.276"> static MimeMultipartBoundaryType</span>
<a href="#l5.277"></a><span id="l5.277"> MimeMultipart_check_boundary(MimeObject *obj, const char *line, PRInt32 length)</span>
<a href="#l5.278"></a><span id="l5.278"> {</span>
<a href="#l5.279"></a><span id="l5.279">   MimeMultipart *mult = (MimeMultipart *) obj;</span>
<a href="#l5.280"></a><span id="l5.280">   PRInt32 blen;</span>
<a href="#l5.281"></a><span id="l5.281">   PRBool term_p;</span>
<a href="#l5.282"></a><span id="l5.282"> </span>
<a href="#l5.283"></a><span id="l5.283" class="difflineat">@@ -588,16 +537,19 @@ MimeMultipart_create_child(MimeObject *o</span>
<a href="#l5.284"></a><span id="l5.284"> </span>
<a href="#l5.285"></a><span id="l5.285">   return 0;</span>
<a href="#l5.286"></a><span id="l5.286"> }</span>
<a href="#l5.287"></a><span id="l5.287"> </span>
<a href="#l5.288"></a><span id="l5.288"> </span>
<a href="#l5.289"></a><span id="l5.289"> static PRBool</span>
<a href="#l5.290"></a><span id="l5.290"> MimeMultipart_output_child_p(MimeObject *obj, MimeObject *child)</span>
<a href="#l5.291"></a><span id="l5.291"> {</span>
<a href="#l5.292"></a><span id="l5.292" class="difflineplus">+  /* We don't output a child if we're stripping it. */</span>
<a href="#l5.293"></a><span id="l5.293" class="difflineplus">+  if (obj-&gt;options &amp;&amp; obj-&gt;options-&gt;state &amp;&amp; obj-&gt;options-&gt;state-&gt;strippingPart)</span>
<a href="#l5.294"></a><span id="l5.294" class="difflineplus">+    return PR_FALSE;</span>
<a href="#l5.295"></a><span id="l5.295">   /* if we are saving an apple double attachment, ignore the appledouble wrapper part */</span>
<a href="#l5.296"></a><span id="l5.296">   return (obj-&gt;options &amp;&amp; obj-&gt;options-&gt;write_html_p) ||</span>
<a href="#l5.297"></a><span id="l5.297">           PL_strcasecmp(child-&gt;content_type, MULTIPART_APPLEDOUBLE);</span>
<a href="#l5.298"></a><span id="l5.298"> }</span>
<a href="#l5.299"></a><span id="l5.299"> </span>
<a href="#l5.300"></a><span id="l5.300"> </span>
<a href="#l5.301"></a><span id="l5.301"> </span>
<a href="#l5.302"></a><span id="l5.302"> static int</span>
<a href="#l5.303"></a><span id="l5.303" class="difflineat">@@ -743,25 +695,25 @@ MimeMultipart_parse_child_line (MimeObje</span>
<a href="#l5.304"></a><span id="l5.304"> static int</span>
<a href="#l5.305"></a><span id="l5.305"> MimeMultipart_parse_eof (MimeObject *obj, PRBool abort_p)</span>
<a href="#l5.306"></a><span id="l5.306"> {</span>
<a href="#l5.307"></a><span id="l5.307">   MimeMultipart *mult = (MimeMultipart *) obj;</span>
<a href="#l5.308"></a><span id="l5.308">   MimeContainer *cont = (MimeContainer *) obj;</span>
<a href="#l5.309"></a><span id="l5.309"> </span>
<a href="#l5.310"></a><span id="l5.310">   if (obj-&gt;closed_p) return 0;</span>
<a href="#l5.311"></a><span id="l5.311"> </span>
<a href="#l5.312"></a><span id="l5.312" class="difflineminus">-  /* Push out one last newline if part of the last line is still in the</span>
<a href="#l5.313"></a><span id="l5.313" class="difflineminus">-   ibuffer.  If this happens, this object does not end in a trailing newline</span>
<a href="#l5.314"></a><span id="l5.314" class="difflineminus">-   (and the parse_line method will be called with a string with no trailing</span>
<a href="#l5.315"></a><span id="l5.315" class="difflineplus">+  /* Push out the last trailing line if there's one in the buffer.  If</span>
<a href="#l5.316"></a><span id="l5.316" class="difflineplus">+   this happens, this object does not end in a trailing newline (and</span>
<a href="#l5.317"></a><span id="l5.317" class="difflineplus">+   the parse_line method will be called with a string with no trailing</span>
<a href="#l5.318"></a><span id="l5.318">    newline, which isn't the usual case.)</span>
<a href="#l5.319"></a><span id="l5.319">    */</span>
<a href="#l5.320"></a><span id="l5.320">   if (!abort_p &amp;&amp; obj-&gt;ibuffer_fp &gt; 0)</span>
<a href="#l5.321"></a><span id="l5.321">   {</span>
<a href="#l5.322"></a><span id="l5.322" class="difflineminus">-    int status = obj-&gt;clazz-&gt;parse_buffer (obj-&gt;ibuffer, obj-&gt;ibuffer_fp,</span>
<a href="#l5.323"></a><span id="l5.323" class="difflineminus">-                       obj);</span>
<a href="#l5.324"></a><span id="l5.324" class="difflineplus">+    /* There is leftover data without a terminating newline. */</span>
<a href="#l5.325"></a><span id="l5.325" class="difflineplus">+    int status = obj-&gt;clazz-&gt;parse_line(obj-&gt;ibuffer, obj-&gt;ibuffer_fp,obj);</span>
<a href="#l5.326"></a><span id="l5.326">     obj-&gt;ibuffer_fp = 0;</span>
<a href="#l5.327"></a><span id="l5.327">     if (status &lt; 0)</span>
<a href="#l5.328"></a><span id="l5.328">     {</span>
<a href="#l5.329"></a><span id="l5.329">       obj-&gt;closed_p = PR_TRUE;</span>
<a href="#l5.330"></a><span id="l5.330">       return status;</span>
<a href="#l5.331"></a><span id="l5.331">     }</span>
<a href="#l5.332"></a><span id="l5.332">   }</span>
<a href="#l5.333"></a><span id="l5.333"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/mime/src/mimemult.h</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/mime/src/mimemult.h</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -88,17 +88,16 @@</span>
<a href="#l6.4"></a><span id="l6.4"> typedef struct MimeMultipartClass MimeMultipartClass;</span>
<a href="#l6.5"></a><span id="l6.5"> typedef struct MimeMultipart      MimeMultipart;</span>
<a href="#l6.6"></a><span id="l6.6"> </span>
<a href="#l6.7"></a><span id="l6.7"> typedef enum {</span>
<a href="#l6.8"></a><span id="l6.8">   MimeMultipartPreamble,</span>
<a href="#l6.9"></a><span id="l6.9">   MimeMultipartHeaders,</span>
<a href="#l6.10"></a><span id="l6.10">   MimeMultipartPartFirstLine,</span>
<a href="#l6.11"></a><span id="l6.11">   MimeMultipartPartLine,</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-  MimeMultipartSkipPartLine,</span>
<a href="#l6.13"></a><span id="l6.13">   MimeMultipartEpilogue</span>
<a href="#l6.14"></a><span id="l6.14"> } MimeMultipartParseState;</span>
<a href="#l6.15"></a><span id="l6.15"> </span>
<a href="#l6.16"></a><span id="l6.16"> typedef enum {</span>
<a href="#l6.17"></a><span id="l6.17">   MimeMultipartBoundaryTypeNone,</span>
<a href="#l6.18"></a><span id="l6.18">   MimeMultipartBoundaryTypeSeparator,</span>
<a href="#l6.19"></a><span id="l6.19">   MimeMultipartBoundaryTypeTerminator</span>
<a href="#l6.20"></a><span id="l6.20"> } MimeMultipartBoundaryType;</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineat">@@ -122,9 +121,10 @@ extern MimeMultipartClass mimeMultipartC</span>
<a href="#l6.22"></a><span id="l6.22"> struct MimeMultipart {</span>
<a href="#l6.23"></a><span id="l6.23">   MimeContainer container;      /* superclass variables */</span>
<a href="#l6.24"></a><span id="l6.24">   char *boundary;          /* Inter-part delimiter string */</span>
<a href="#l6.25"></a><span id="l6.25">   MimeHeaders *hdrs;        /* headers of the part currently</span>
<a href="#l6.26"></a><span id="l6.26">                      being parsed, if any */</span>
<a href="#l6.27"></a><span id="l6.27">   MimeMultipartParseState state;  /* State of parser */</span>
<a href="#l6.28"></a><span id="l6.28"> };</span>
<a href="#l6.29"></a><span id="l6.29"> </span>
<a href="#l6.30"></a><span id="l6.30" class="difflineplus">+extern void MimeMultipart_notify_emitter(MimeObject *);</span>
<a href="#l6.31"></a><span id="l6.31"> #endif /* _MIMEMULT_H_ */</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

