<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 17932:d294256abf7b7301ee224dbf1d30cdedaad0f536</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ d294256abf7b7301ee224dbf1d30cdedaad0f536" />
<meta property="og:url" content="/comm-central/rev/d294256abf7b7301ee224dbf1d30cdedaad0f536" />
<meta property="og:description" content="Bug 777770 - get rid of nsVoidArray from /mailnews, r=rkent, a=rkent CLOSED TREE" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / d294256abf7b7301ee224dbf1d30cdedaad0f536 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/d294256abf7b7301ee224dbf1d30cdedaad0f536">shortlog</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/d294256abf7b7301ee224dbf1d30cdedaad0f536">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536">files</a> |
changeset |
<a href="/comm-central/raw-rev/d294256abf7b7301ee224dbf1d30cdedaad0f536">raw</a>  | <a href="/comm-central/archive/d294256abf7b7301ee224dbf1d30cdedaad0f536.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=777770">Bug 777770</a> - get rid of nsVoidArray from /mailnews, r=rkent, a=rkent CLOSED TREE
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#83;&#116;&#101;&#102;&#97;&#110;&#32;&#83;&#105;&#116;&#116;&#101;&#114;&#32;&#60;&#115;&#115;&#105;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Wed, 13 May 2015 11:09:45 -0700</td></tr>

<tr>
 <td>changeset 17932</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/d294256abf7b7301ee224dbf1d30cdedaad0f536">d294256abf7b7301ee224dbf1d30cdedaad0f536</a></td>
</tr>



<tr>
<td>parent 17931</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/d1979f04df5a1f0007d9ee285d11731cc749b0d2">d1979f04df5a1f0007d9ee285d11731cc749b0d2</a>
</td>
</tr>

<tr>
<td>child 17933</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/68f9b79c4fa70d7daade2831d79df1302b9c996b">68f9b79c4fa70d7daade2831d79df1302b9c996b</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=d294256abf7b7301ee224dbf1d30cdedaad0f536">11025</a></td></tr>
<tr><td>push user</td><td>kent@caspia.com</td></tr>
<tr><td>push date</td><td class="date age">Wed, 13 May 2015 18:10:13 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@d294256abf7b [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=d294256abf7b7301ee224dbf1d30cdedaad0f536">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=d294256abf7b7301ee224dbf1d30cdedaad0f536&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d294256abf7b7301ee224dbf1d30cdedaad0f536&newProject=comm-central&newRevision=d294256abf7b7301ee224dbf1d30cdedaad0f536&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d294256abf7b7301ee224dbf1d30cdedaad0f536&newProject=comm-central&newRevision=d294256abf7b7301ee224dbf1d30cdedaad0f536&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=d294256abf7b7301ee224dbf1d30cdedaad0f536&newProject=comm-central&newRevision=d294256abf7b7301ee224dbf1d30cdedaad0f536&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28rkent%29&revcount=50">rkent</a>, <a href="/comm-central/log?rev=reviewer%28rkent%29&revcount=50">rkent</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=777770">777770</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=777770">Bug 777770</a> - get rid of nsVoidArray from /mailnews, r=rkent, a=rkent CLOSED TREE</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbBSDirectory.cpp">mailnews/addrbook/src/nsAbBSDirectory.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbBSDirectory.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbBSDirectory.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbBSDirectory.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbBSDirectory.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbBSDirectory.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbLDAPChangeLogData.h">mailnews/addrbook/src/nsAbLDAPChangeLogData.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbLDAPChangeLogData.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbLDAPChangeLogData.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbLDAPChangeLogData.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbLDAPChangeLogData.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbLDAPChangeLogData.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.cpp">mailnews/addrbook/src/nsAbView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.h">mailnews/addrbook/src/nsAbView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsAbView.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.cpp">mailnews/addrbook/src/nsDirPrefs.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.h">mailnews/addrbook/src/nsDirPrefs.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/addrbook/src/nsDirPrefs.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.cpp">mailnews/base/src/nsMsgDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.h">mailnews/base/src/nsMsgDBView.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/base/src/nsMsgDBView.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.cpp">mailnews/imap/src/nsIMAPBodyShell.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.h">mailnews/imap/src/nsIMAPBodyShell.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPBodyShell.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.cpp">mailnews/imap/src/nsIMAPNamespace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.h">mailnews/imap/src/nsIMAPNamespace.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsIMAPNamespace.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.cpp">mailnews/imap/src/nsImapIncomingServer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.h">mailnews/imap/src/nsImapIncomingServer.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapIncomingServer.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.cpp">mailnews/imap/src/nsImapProtocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.h">mailnews/imap/src/nsImapProtocol.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapProtocol.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.cpp">mailnews/imap/src/nsImapSearchResults.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.h">mailnews/imap/src/nsImapSearchResults.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/imap/src/nsImapSearchResults.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.cpp">mailnews/import/eudora/src/nsEudoraAddress.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.h">mailnews/import/eudora/src/nsEudoraAddress.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraAddress.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.cpp">mailnews/import/eudora/src/nsEudoraCompose.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.h">mailnews/import/eudora/src/nsEudoraCompose.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraCompose.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.cpp">mailnews/import/eudora/src/nsEudoraMailbox.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.h">mailnews/import/eudora/src/nsEudoraMailbox.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/eudora/src/nsEudoraMailbox.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.cpp">mailnews/import/oexpress/nsOEScanBoxes.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.h">mailnews/import/oexpress/nsOEScanBoxes.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/oexpress/nsOEScanBoxes.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.cpp">mailnews/import/outlook/src/MapiApi.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.h">mailnews/import/outlook/src/MapiApi.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/outlook/src/MapiApi.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.cpp">mailnews/import/src/nsImportFieldMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.h">mailnews/import/src/nsImportFieldMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/import/src/nsImportFieldMap.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/public/nsIPop3Protocol.idl">mailnews/local/public/nsIPop3Protocol.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/public/nsIPop3Protocol.idl">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/public/nsIPop3Protocol.idl">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/public/nsIPop3Protocol.idl">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/public/nsIPop3Protocol.idl">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/public/nsIPop3Protocol.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.cpp">mailnews/local/src/nsParseMailbox.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.h">mailnews/local/src/nsParseMailbox.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsParseMailbox.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.cpp">mailnews/local/src/nsPop3IncomingServer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.h">mailnews/local/src/nsPop3IncomingServer.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3IncomingServer.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.cpp">mailnews/local/src/nsPop3Protocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.h">mailnews/local/src/nsPop3Protocol.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/local/src/nsPop3Protocol.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.cpp">mailnews/mime/emitters/nsMimeBaseEmitter.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.h">mailnews/mime/emitters/nsMimeBaseEmitter.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.h">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.h">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.h">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.h">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeBaseEmitter.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">mailnews/mime/emitters/nsMimeHtmlEmitter.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/src/mimei.cpp">mailnews/mime/src/mimei.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/src/mimei.cpp">file</a> |
<a href="/comm-central/annotate/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/src/mimei.cpp">annotate</a> |
<a href="/comm-central/diff/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/src/mimei.cpp">diff</a> |
<a href="/comm-central/comparison/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/src/mimei.cpp">comparison</a> |
<a href="/comm-central/log/d294256abf7b7301ee224dbf1d30cdedaad0f536/mailnews/mime/src/mimei.cpp">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbBSDirectory.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbBSDirectory.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -10,17 +10,16 @@</span>
<a href="#l1.4"></a><span id="l1.4"> #include &quot;nsAbBaseCID.h&quot;</span>
<a href="#l1.5"></a><span id="l1.5"> #include &quot;nsAddrDatabase.h&quot;</span>
<a href="#l1.6"></a><span id="l1.6"> #include &quot;nsIAbManager.h&quot;</span>
<a href="#l1.7"></a><span id="l1.7"> #include &quot;nsIAbMDBDirectory.h&quot;</span>
<a href="#l1.8"></a><span id="l1.8"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l1.9"></a><span id="l1.9"> #include &quot;nsAbDirFactoryService.h&quot;</span>
<a href="#l1.10"></a><span id="l1.10"> #include &quot;nsAbMDBDirFactory.h&quot;</span>
<a href="#l1.11"></a><span id="l1.11"> #include &quot;nsArrayEnumerator.h&quot;</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l1.13"></a><span id="l1.13"> </span>
<a href="#l1.14"></a><span id="l1.14"> #include &quot;nsCRTGlue.h&quot;</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16"> nsAbBSDirectory::nsAbBSDirectory()</span>
<a href="#l1.17"></a><span id="l1.17"> : mInitialized(false)</span>
<a href="#l1.18"></a><span id="l1.18"> , mServers(13)</span>
<a href="#l1.19"></a><span id="l1.19"> {</span>
<a href="#l1.20"></a><span id="l1.20"> }</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineat">@@ -103,24 +102,24 @@ nsresult nsAbBSDirectory::EnsureInitiali</span>
<a href="#l1.22"></a><span id="l1.22">   if (mInitialized)</span>
<a href="#l1.23"></a><span id="l1.23">     return NS_OK;</span>
<a href="#l1.24"></a><span id="l1.24"> </span>
<a href="#l1.25"></a><span id="l1.25">   nsresult rv;</span>
<a href="#l1.26"></a><span id="l1.26">   nsCOMPtr&lt;nsIAbDirFactoryService&gt; dirFactoryService = </span>
<a href="#l1.27"></a><span id="l1.27">     do_GetService(NS_ABDIRFACTORYSERVICE_CONTRACTID,&amp;rv);</span>
<a href="#l1.28"></a><span id="l1.28">   NS_ENSURE_SUCCESS (rv, rv);</span>
<a href="#l1.29"></a><span id="l1.29">     </span>
<a href="#l1.30"></a><span id="l1.30" class="difflineminus">-  nsVoidArray *directories = DIR_GetDirectories();</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+  nsTArray&lt;DIR_Server*&gt; *directories = DIR_GetDirectories();</span>
<a href="#l1.32"></a><span id="l1.32">   if (!directories)</span>
<a href="#l1.33"></a><span id="l1.33">     return NS_ERROR_FAILURE;</span>
<a href="#l1.34"></a><span id="l1.34">     </span>
<a href="#l1.35"></a><span id="l1.35" class="difflineminus">-  int32_t count = directories-&gt;Count();</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+  int32_t count = directories-&gt;Length();</span>
<a href="#l1.37"></a><span id="l1.37">   for (int32_t i = 0; i &lt; count; i++)</span>
<a href="#l1.38"></a><span id="l1.38">   {</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineminus">-    DIR_Server *server = (DIR_Server *)(directories-&gt;ElementAt(i));</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+    DIR_Server *server = directories-&gt;ElementAt(i);</span>
<a href="#l1.41"></a><span id="l1.41">       </span>
<a href="#l1.42"></a><span id="l1.42">     // if this is a 4.x, local .na2 addressbook (PABDirectory)</span>
<a href="#l1.43"></a><span id="l1.43">     // we must skip it.</span>
<a href="#l1.44"></a><span id="l1.44">     // mozilla can't handle 4.x .na2 addressbooks</span>
<a href="#l1.45"></a><span id="l1.45">     // note, the filename might be na2 for 4.x LDAP directories</span>
<a href="#l1.46"></a><span id="l1.46">     // (we used the .na2 file for replication), and we don't want to skip</span>
<a href="#l1.47"></a><span id="l1.47">     // those.  see bug #127007</span>
<a href="#l1.48"></a><span id="l1.48">     uint32_t fileNameLen = strlen(server-&gt;fileName);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbLDAPChangeLogData.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbLDAPChangeLogData.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -3,17 +3,16 @@</span>
<a href="#l2.4"></a><span id="l2.4">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l2.5"></a><span id="l2.5"> </span>
<a href="#l2.6"></a><span id="l2.6"> #ifndef nsAbLDAPChangeLogData_h__</span>
<a href="#l2.7"></a><span id="l2.7"> #define nsAbLDAPChangeLogData_h__</span>
<a href="#l2.8"></a><span id="l2.8"> </span>
<a href="#l2.9"></a><span id="l2.9"> #include &quot;mozilla/Attributes.h&quot;</span>
<a href="#l2.10"></a><span id="l2.10"> #include &quot;nsAbLDAPReplicationData.h&quot;</span>
<a href="#l2.11"></a><span id="l2.11"> #include &quot;nsAbLDAPChangeLogQuery.h&quot;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l2.13"></a><span id="l2.13"> </span>
<a href="#l2.14"></a><span id="l2.14"> typedef struct {</span>
<a href="#l2.15"></a><span id="l2.15">   nsCString     changeLogDN;</span>
<a href="#l2.16"></a><span id="l2.16">   int32_t       firstChangeNumber;</span>
<a href="#l2.17"></a><span id="l2.17">   int32_t       lastChangeNumber;</span>
<a href="#l2.18"></a><span id="l2.18">   nsCString     dataVersion;</span>
<a href="#l2.19"></a><span id="l2.19"> } RootDSEChangeLogEntry;</span>
<a href="#l2.20"></a><span id="l2.20"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbView.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbView.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -82,17 +82,17 @@ NS_IMETHODIMP nsAbView::ClearView()</span>
<a href="#l3.4"></a><span id="l3.4">     nsCOMPtr&lt;nsIAbManager&gt; abManager(do_GetService(NS_ABMANAGER_CONTRACTID,</span>
<a href="#l3.5"></a><span id="l3.5">                                                    &amp;rv));</span>
<a href="#l3.6"></a><span id="l3.6">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8">     rv = abManager-&gt;RemoveAddressBookListener(this);</span>
<a href="#l3.9"></a><span id="l3.9">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.10"></a><span id="l3.10">   }</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-  int32_t i = mCards.Count();</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+  int32_t i = mCards.Length();</span>
<a href="#l3.14"></a><span id="l3.14">   while(i-- &gt; 0)</span>
<a href="#l3.15"></a><span id="l3.15">     NS_ASSERTION(NS_SUCCEEDED(RemoveCardAt(i)), &quot;remove card failed\n&quot;);</span>
<a href="#l3.16"></a><span id="l3.16"> </span>
<a href="#l3.17"></a><span id="l3.17">   return NS_OK;</span>
<a href="#l3.18"></a><span id="l3.18"> }</span>
<a href="#l3.19"></a><span id="l3.19"> </span>
<a href="#l3.20"></a><span id="l3.20"> nsresult nsAbView::RemoveCardAt(int32_t row)</span>
<a href="#l3.21"></a><span id="l3.21"> {</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -108,17 +108,17 @@ nsresult nsAbView::RemoveCardAt(int32_t </span>
<a href="#l3.23"></a><span id="l3.23">   </span>
<a href="#l3.24"></a><span id="l3.24">   // This needs to happen after we remove the card, as RowCountChanged() will call GetRowCount()</span>
<a href="#l3.25"></a><span id="l3.25">   if (mTree) {</span>
<a href="#l3.26"></a><span id="l3.26">     rv = mTree-&gt;RowCountChanged(row, -1);</span>
<a href="#l3.27"></a><span id="l3.27">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.28"></a><span id="l3.28">   }</span>
<a href="#l3.29"></a><span id="l3.29"> </span>
<a href="#l3.30"></a><span id="l3.30">   if (mAbViewListener &amp;&amp; !mSuppressCountChange) {</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-    rv = mAbViewListener-&gt;OnCountChanged(mCards.Count());</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+    rv = mAbViewListener-&gt;OnCountChanged(mCards.Length());</span>
<a href="#l3.33"></a><span id="l3.33">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.34"></a><span id="l3.34">   }</span>
<a href="#l3.35"></a><span id="l3.35">   return NS_OK;</span>
<a href="#l3.36"></a><span id="l3.36"> }</span>
<a href="#l3.37"></a><span id="l3.37"> </span>
<a href="#l3.38"></a><span id="l3.38"> nsresult nsAbView::SetGeneratedNameFormatFromPrefs()</span>
<a href="#l3.39"></a><span id="l3.39"> {</span>
<a href="#l3.40"></a><span id="l3.40">   nsresult rv;</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineat">@@ -174,17 +174,17 @@ NS_IMETHODIMP nsAbView::SetView(nsIAbDir</span>
<a href="#l3.42"></a><span id="l3.42">   if (mTree)</span>
<a href="#l3.43"></a><span id="l3.43">   {</span>
<a href="#l3.44"></a><span id="l3.44">     // Try and speed deletion of old cards by disconnecting the tree from us.</span>
<a href="#l3.45"></a><span id="l3.45">     mTreeSelection-&gt;ClearSelection();</span>
<a href="#l3.46"></a><span id="l3.46">     mTree-&gt;SetView(nullptr);</span>
<a href="#l3.47"></a><span id="l3.47">   }</span>
<a href="#l3.48"></a><span id="l3.48"> </span>
<a href="#l3.49"></a><span id="l3.49">   // Clear out old cards</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineminus">-  int32_t i = mCards.Count();</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+  int32_t i = mCards.Length();</span>
<a href="#l3.52"></a><span id="l3.52">   while(i-- &gt; 0)</span>
<a href="#l3.53"></a><span id="l3.53">   {</span>
<a href="#l3.54"></a><span id="l3.54">     rv = RemoveCardAt(i);</span>
<a href="#l3.55"></a><span id="l3.55">     NS_ASSERTION(NS_SUCCEEDED(rv), &quot;remove card failed\n&quot;);</span>
<a href="#l3.56"></a><span id="l3.56">   }</span>
<a href="#l3.57"></a><span id="l3.57"> </span>
<a href="#l3.58"></a><span id="l3.58">   // We replace all cards so any sorting is no longer valid.</span>
<a href="#l3.59"></a><span id="l3.59">   mSortColumn.AssignLiteral(&quot;&quot;);</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineat">@@ -243,18 +243,18 @@ NS_IMETHODIMP nsAbView::SetView(nsIAbDir</span>
<a href="#l3.61"></a><span id="l3.61">   }</span>
<a href="#l3.62"></a><span id="l3.62"> </span>
<a href="#l3.63"></a><span id="l3.63">   NS_NAMED_LITERAL_STRING(generatedNameColumnId, GENERATED_NAME_COLUMN_ID);</span>
<a href="#l3.64"></a><span id="l3.64"> </span>
<a href="#l3.65"></a><span id="l3.65">   // See if the persisted sortColumn is valid.</span>
<a href="#l3.66"></a><span id="l3.66">   // It may not be, if you migrated from older versions, or switched between</span>
<a href="#l3.67"></a><span id="l3.67">   // a mozilla build and a commercial build, which have different columns.</span>
<a href="#l3.68"></a><span id="l3.68">   nsAutoString actualSortColumn;</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-  if (!generatedNameColumnId.Equals(aSortColumn) &amp;&amp; mCards.Count()) {</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-    nsIAbCard *card = ((AbCard *)(mCards.ElementAt(0)))-&gt;card;</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+  if (!generatedNameColumnId.Equals(aSortColumn) &amp;&amp; mCards.Length()) {</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+    nsIAbCard *card = mCards.ElementAt(0)-&gt;card;</span>
<a href="#l3.73"></a><span id="l3.73">     nsString value;</span>
<a href="#l3.74"></a><span id="l3.74">     // XXX todo</span>
<a href="#l3.75"></a><span id="l3.75">     // Need to check if _Generic is valid.  GetCardValue() will always return NS_OK for _Generic</span>
<a href="#l3.76"></a><span id="l3.76">     // We're going to have to ask mDirectory if it is.</span>
<a href="#l3.77"></a><span id="l3.77">     // It might not be.  example:  _ScreenName is valid in Netscape, but not Mozilla.</span>
<a href="#l3.78"></a><span id="l3.78">     rv = GetCardValue(card, PromiseFlatString(aSortColumn).get(), value);</span>
<a href="#l3.79"></a><span id="l3.79">     if (NS_FAILED(rv))</span>
<a href="#l3.80"></a><span id="l3.80">       actualSortColumn = generatedNameColumnId;</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineat">@@ -264,17 +264,17 @@ NS_IMETHODIMP nsAbView::SetView(nsIAbDir</span>
<a href="#l3.82"></a><span id="l3.82">   else</span>
<a href="#l3.83"></a><span id="l3.83">     actualSortColumn = aSortColumn;</span>
<a href="#l3.84"></a><span id="l3.84"> </span>
<a href="#l3.85"></a><span id="l3.85">   rv = SortBy(actualSortColumn.get(), PromiseFlatString(aSortDirection).get(), false);</span>
<a href="#l3.86"></a><span id="l3.86">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.87"></a><span id="l3.87"> </span>
<a href="#l3.88"></a><span id="l3.88">   mAbViewListener = aAbViewListener;</span>
<a href="#l3.89"></a><span id="l3.89">   if (mAbViewListener &amp;&amp; !mSuppressCountChange) {</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineminus">-    rv = mAbViewListener-&gt;OnCountChanged(mCards.Count());</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+    rv = mAbViewListener-&gt;OnCountChanged(mCards.Length());</span>
<a href="#l3.92"></a><span id="l3.92">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.93"></a><span id="l3.93">   }</span>
<a href="#l3.94"></a><span id="l3.94"> </span>
<a href="#l3.95"></a><span id="l3.95">   aResult = actualSortColumn;</span>
<a href="#l3.96"></a><span id="l3.96">   return NS_OK;</span>
<a href="#l3.97"></a><span id="l3.97"> }</span>
<a href="#l3.98"></a><span id="l3.98"> </span>
<a href="#l3.99"></a><span id="l3.99"> NS_IMETHODIMP nsAbView::GetDirectory(nsIAbDirectory **aDirectory)</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineat">@@ -313,28 +313,28 @@ nsresult nsAbView::EnumerateCards()</span>
<a href="#l3.101"></a><span id="l3.101">         NS_IF_ADDREF(abcard-&gt;card);</span>
<a href="#l3.102"></a><span id="l3.102"> </span>
<a href="#l3.103"></a><span id="l3.103">         // XXX todo</span>
<a href="#l3.104"></a><span id="l3.104">         // Would it be better to do an insertion sort, than append and sort?</span>
<a href="#l3.105"></a><span id="l3.105">         // XXX todo</span>
<a href="#l3.106"></a><span id="l3.106">         // If we knew how many cards there was going to be</span>
<a href="#l3.107"></a><span id="l3.107">         // we could allocate an array of the size,</span>
<a href="#l3.108"></a><span id="l3.108">         // instead of growing and copying as we append.</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineminus">-        DebugOnly&lt;bool&gt; didAppend = mCards.AppendElement((void *)abcard);</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+        DebugOnly&lt;bool&gt; didAppend = mCards.AppendElement(abcard);</span>
<a href="#l3.111"></a><span id="l3.111">         NS_ASSERTION(didAppend, &quot;failed to append card&quot;);</span>
<a href="#l3.112"></a><span id="l3.112">       }</span>
<a href="#l3.113"></a><span id="l3.113">     }</span>
<a href="#l3.114"></a><span id="l3.114">   }</span>
<a href="#l3.115"></a><span id="l3.115"> </span>
<a href="#l3.116"></a><span id="l3.116">   return NS_OK;</span>
<a href="#l3.117"></a><span id="l3.117"> }</span>
<a href="#l3.118"></a><span id="l3.118"> </span>
<a href="#l3.119"></a><span id="l3.119"> NS_IMETHODIMP nsAbView::GetRowCount(int32_t *aRowCount)</span>
<a href="#l3.120"></a><span id="l3.120"> {</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineminus">-  *aRowCount = mCards.Count();</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineplus">+  *aRowCount = mCards.Length();</span>
<a href="#l3.123"></a><span id="l3.123">   return NS_OK;</span>
<a href="#l3.124"></a><span id="l3.124"> }</span>
<a href="#l3.125"></a><span id="l3.125"> </span>
<a href="#l3.126"></a><span id="l3.126"> NS_IMETHODIMP nsAbView::GetSelection(nsITreeSelection * *aSelection)</span>
<a href="#l3.127"></a><span id="l3.127"> {</span>
<a href="#l3.128"></a><span id="l3.128">   NS_IF_ADDREF(*aSelection = mTreeSelection);</span>
<a href="#l3.129"></a><span id="l3.129">   return NS_OK;</span>
<a href="#l3.130"></a><span id="l3.130"> }</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineat">@@ -349,26 +349,26 @@ NS_IMETHODIMP nsAbView::GetRowProperties</span>
<a href="#l3.132"></a><span id="l3.132"> {</span>
<a href="#l3.133"></a><span id="l3.133">     return NS_OK;</span>
<a href="#l3.134"></a><span id="l3.134"> }</span>
<a href="#l3.135"></a><span id="l3.135"> </span>
<a href="#l3.136"></a><span id="l3.136"> NS_IMETHODIMP nsAbView::GetCellProperties(int32_t row, nsITreeColumn* col, nsAString&amp; properties)</span>
<a href="#l3.137"></a><span id="l3.137"> {</span>
<a href="#l3.138"></a><span id="l3.138">   NS_ENSURE_TRUE(row &gt;= 0, NS_ERROR_UNEXPECTED);</span>
<a href="#l3.139"></a><span id="l3.139"> </span>
<a href="#l3.140"></a><span id="l3.140" class="difflineminus">-  if (mCards.Count() &lt;= row)</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineplus">+  if (mCards.Length() &lt;= row)</span>
<a href="#l3.142"></a><span id="l3.142">     return NS_OK;</span>
<a href="#l3.143"></a><span id="l3.143"> </span>
<a href="#l3.144"></a><span id="l3.144">   const char16_t* colID;</span>
<a href="#l3.145"></a><span id="l3.145">   col-&gt;GetIdConst(&amp;colID);</span>
<a href="#l3.146"></a><span id="l3.146">   // &quot;G&quot; == &quot;GeneratedName&quot;</span>
<a href="#l3.147"></a><span id="l3.147">   if (colID[0] != char16_t('G'))</span>
<a href="#l3.148"></a><span id="l3.148">     return NS_OK;</span>
<a href="#l3.149"></a><span id="l3.149"> </span>
<a href="#l3.150"></a><span id="l3.150" class="difflineminus">-  nsIAbCard *card = ((AbCard *)(mCards.ElementAt(row)))-&gt;card;</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+  nsIAbCard *card = mCards.ElementAt(row)-&gt;card;</span>
<a href="#l3.152"></a><span id="l3.152"> </span>
<a href="#l3.153"></a><span id="l3.153">   bool isMailList;</span>
<a href="#l3.154"></a><span id="l3.154">   nsresult rv = card-&gt;GetIsMailList(&amp;isMailList);</span>
<a href="#l3.155"></a><span id="l3.155">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.156"></a><span id="l3.156"> </span>
<a href="#l3.157"></a><span id="l3.157">   if (isMailList)</span>
<a href="#l3.158"></a><span id="l3.158">     properties.AssignLiteral(&quot;MailList&quot;);</span>
<a href="#l3.159"></a><span id="l3.159"> </span>
<a href="#l3.160"></a><span id="l3.160" class="difflineat">@@ -520,19 +520,19 @@ nsresult nsAbView::RefreshTree()</span>
<a href="#l3.161"></a><span id="l3.161">     SelectionChanged();</span>
<a href="#l3.162"></a><span id="l3.162">   }</span>
<a href="#l3.163"></a><span id="l3.163"> </span>
<a href="#l3.164"></a><span id="l3.164">   return rv;</span>
<a href="#l3.165"></a><span id="l3.165"> }</span>
<a href="#l3.166"></a><span id="l3.166"> </span>
<a href="#l3.167"></a><span id="l3.167"> NS_IMETHODIMP nsAbView::GetCellText(int32_t row, nsITreeColumn* col, nsAString&amp; _retval)</span>
<a href="#l3.168"></a><span id="l3.168"> {</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineminus">-  NS_ENSURE_TRUE(row &gt;= 0 &amp;&amp; row &lt; mCards.Count(), NS_ERROR_UNEXPECTED);</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+  NS_ENSURE_TRUE(row &gt;= 0 &amp;&amp; row &lt; mCards.Length(), NS_ERROR_UNEXPECTED);</span>
<a href="#l3.171"></a><span id="l3.171"> </span>
<a href="#l3.172"></a><span id="l3.172" class="difflineminus">-  nsIAbCard *card = ((AbCard *)(mCards.ElementAt(row)))-&gt;card;</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+  nsIAbCard *card = mCards.ElementAt(row)-&gt;card;</span>
<a href="#l3.174"></a><span id="l3.174">   const char16_t* colID;</span>
<a href="#l3.175"></a><span id="l3.175">   col-&gt;GetIdConst(&amp;colID);</span>
<a href="#l3.176"></a><span id="l3.176">   return GetCardValue(card, colID, _retval);</span>
<a href="#l3.177"></a><span id="l3.177"> }</span>
<a href="#l3.178"></a><span id="l3.178"> </span>
<a href="#l3.179"></a><span id="l3.179"> NS_IMETHODIMP nsAbView::SetTree(nsITreeBoxObject *tree)</span>
<a href="#l3.180"></a><span id="l3.180"> {</span>
<a href="#l3.181"></a><span id="l3.181">   mTree = tree;</span>
<a href="#l3.182"></a><span id="l3.182" class="difflineat">@@ -607,23 +607,23 @@ NS_IMETHODIMP nsAbView::PerformActionOnR</span>
<a href="#l3.183"></a><span id="l3.183"> NS_IMETHODIMP nsAbView::PerformActionOnCell(const char16_t *action, int32_t row, nsITreeColumn* col)</span>
<a href="#l3.184"></a><span id="l3.184"> {</span>
<a href="#l3.185"></a><span id="l3.185">     return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l3.186"></a><span id="l3.186"> }</span>
<a href="#l3.187"></a><span id="l3.187"> </span>
<a href="#l3.188"></a><span id="l3.188"> NS_IMETHODIMP nsAbView::GetCardFromRow(int32_t row, nsIAbCard **aCard)</span>
<a href="#l3.189"></a><span id="l3.189"> {</span>
<a href="#l3.190"></a><span id="l3.190">   *aCard = nullptr;  </span>
<a href="#l3.191"></a><span id="l3.191" class="difflineminus">-  if (mCards.Count() &lt;= row) {</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+  if (mCards.Length() &lt;= row) {</span>
<a href="#l3.193"></a><span id="l3.193">     return NS_OK;</span>
<a href="#l3.194"></a><span id="l3.194">   }</span>
<a href="#l3.195"></a><span id="l3.195"> </span>
<a href="#l3.196"></a><span id="l3.196">   NS_ENSURE_TRUE(row &gt;= 0, NS_ERROR_UNEXPECTED);</span>
<a href="#l3.197"></a><span id="l3.197"> </span>
<a href="#l3.198"></a><span id="l3.198" class="difflineminus">-  AbCard *a = ((AbCard *)(mCards.ElementAt(row)));</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+  AbCard *a = mCards.ElementAt(row);</span>
<a href="#l3.200"></a><span id="l3.200">   if (!a)</span>
<a href="#l3.201"></a><span id="l3.201">       return NS_OK;</span>
<a href="#l3.202"></a><span id="l3.202"> </span>
<a href="#l3.203"></a><span id="l3.203">   NS_IF_ADDREF(*aCard = a-&gt;card);</span>
<a href="#l3.204"></a><span id="l3.204">   return NS_OK;</span>
<a href="#l3.205"></a><span id="l3.205"> }</span>
<a href="#l3.206"></a><span id="l3.206"> </span>
<a href="#l3.207"></a><span id="l3.207"> #define DESCENDING_SORT_FACTOR -1</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineat">@@ -674,21 +674,36 @@ static void SetSortClosure(const char16_</span>
<a href="#l3.209"></a><span id="l3.209">     closure-&gt;factor = DESCENDING_SORT_FACTOR;</span>
<a href="#l3.210"></a><span id="l3.210">   else </span>
<a href="#l3.211"></a><span id="l3.211">     closure-&gt;factor = ASCENDING_SORT_FACTOR;</span>
<a href="#l3.212"></a><span id="l3.212"> </span>
<a href="#l3.213"></a><span id="l3.213">   closure-&gt;abView = abView;</span>
<a href="#l3.214"></a><span id="l3.214">   return;</span>
<a href="#l3.215"></a><span id="l3.215"> }</span>
<a href="#l3.216"></a><span id="l3.216"> </span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+class CardComparator {</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+  private:</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineplus">+    SortClosure *m_closure;</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+</span>
<a href="#l3.221"></a><span id="l3.221" class="difflineplus">+  public:</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+    void SetClosure(SortClosure *closure) { m_closure = closure; };</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineplus">+    /** @return True if the elements are equals; false otherise. */</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineplus">+    bool Equals(const AbCard* a, const AbCard* b) const {</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineplus">+      return inplaceSortCallback(a, b, m_closure) == 0;</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineplus">+    }</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineplus">+    bool LessThan(const AbCard* a, const AbCard* b) const{</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineplus">+      return inplaceSortCallback(a, b, m_closure) &lt; 0;</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineplus">+    }</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineplus">+};</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineplus">+</span>
<a href="#l3.232"></a><span id="l3.232"> NS_IMETHODIMP nsAbView::SortBy(const char16_t *colID, const char16_t *sortDir, bool aResort = false)</span>
<a href="#l3.233"></a><span id="l3.233"> {</span>
<a href="#l3.234"></a><span id="l3.234">   nsresult rv;</span>
<a href="#l3.235"></a><span id="l3.235"> </span>
<a href="#l3.236"></a><span id="l3.236" class="difflineminus">-  int32_t count = mCards.Count();</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineplus">+  int32_t count = mCards.Length();</span>
<a href="#l3.238"></a><span id="l3.238"> </span>
<a href="#l3.239"></a><span id="l3.239">   nsAutoString sortColumn;</span>
<a href="#l3.240"></a><span id="l3.240">   if (!colID)</span>
<a href="#l3.241"></a><span id="l3.241">     sortColumn = NS_LITERAL_STRING(GENERATED_NAME_COLUMN_ID);  // default sort column</span>
<a href="#l3.242"></a><span id="l3.242">   else</span>
<a href="#l3.243"></a><span id="l3.243">     sortColumn = colID;</span>
<a href="#l3.244"></a><span id="l3.244"> </span>
<a href="#l3.245"></a><span id="l3.245">   nsAutoString sortDirection;</span>
<a href="#l3.246"></a><span id="l3.246" class="difflineat">@@ -702,28 +717,28 @@ NS_IMETHODIMP nsAbView::SortBy(const cha</span>
<a href="#l3.247"></a><span id="l3.247">       // If sortColumn and sortDirection are identical since the last call, do nothing.</span>
<a href="#l3.248"></a><span id="l3.248">       return NS_OK;</span>
<a href="#l3.249"></a><span id="l3.249">     } else {</span>
<a href="#l3.250"></a><span id="l3.250">       // If we are sorting by how we are already sorted,</span>
<a href="#l3.251"></a><span id="l3.251">       // and just the sort direction changes, just reverse.</span>
<a href="#l3.252"></a><span id="l3.252">       int32_t halfPoint = count / 2;</span>
<a href="#l3.253"></a><span id="l3.253">       for (int32_t i = 0; i &lt; halfPoint; i++) {</span>
<a href="#l3.254"></a><span id="l3.254">         // Swap the elements.</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineminus">-        void *ptr1 = mCards.ElementAt(i);</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineminus">-        void *ptr2 = mCards.ElementAt(count - i - 1);</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineminus">-        mCards.ReplaceElementAt(ptr2, i);</span>
<a href="#l3.258"></a><span id="l3.258" class="difflineminus">-        mCards.ReplaceElementAt(ptr1, count - i - 1);</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineplus">+        AbCard *ptr1 = mCards.ElementAt(i);</span>
<a href="#l3.260"></a><span id="l3.260" class="difflineplus">+        AbCard *ptr2 = mCards.ElementAt(count - i - 1);</span>
<a href="#l3.261"></a><span id="l3.261" class="difflineplus">+        mCards.ReplaceElementAt(i, ptr2);</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineplus">+        mCards.ReplaceElementAt(count - i - 1, ptr1);</span>
<a href="#l3.263"></a><span id="l3.263">       }</span>
<a href="#l3.264"></a><span id="l3.264">       mSortDirection = sortDir;</span>
<a href="#l3.265"></a><span id="l3.265">     }</span>
<a href="#l3.266"></a><span id="l3.266">   }</span>
<a href="#l3.267"></a><span id="l3.267">   else {</span>
<a href="#l3.268"></a><span id="l3.268">     // Generate collation keys</span>
<a href="#l3.269"></a><span id="l3.269">     for (int32_t i = 0; i &lt; count; i++) {</span>
<a href="#l3.270"></a><span id="l3.270" class="difflineminus">-      AbCard *abcard = (AbCard *)(mCards.ElementAt(i));</span>
<a href="#l3.271"></a><span id="l3.271" class="difflineplus">+      AbCard *abcard = mCards.ElementAt(i);</span>
<a href="#l3.272"></a><span id="l3.272"> </span>
<a href="#l3.273"></a><span id="l3.273">       rv = GenerateCollationKeysForCard(sortColumn.get(), abcard);</span>
<a href="#l3.274"></a><span id="l3.274">       NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.275"></a><span id="l3.275">     }</span>
<a href="#l3.276"></a><span id="l3.276"> </span>
<a href="#l3.277"></a><span id="l3.277">     // We need to do full sort.</span>
<a href="#l3.278"></a><span id="l3.278">     SortClosure closure;</span>
<a href="#l3.279"></a><span id="l3.279">     SetSortClosure(sortColumn.get(), sortDirection.get(), this, &amp;closure);</span>
<a href="#l3.280"></a><span id="l3.280" class="difflineat">@@ -743,18 +758,20 @@ NS_IMETHODIMP nsAbView::SortBy(const cha</span>
<a href="#l3.281"></a><span id="l3.281">       NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.282"></a><span id="l3.282"> </span>
<a href="#l3.283"></a><span id="l3.283">       if (currentIndex != -1) {</span>
<a href="#l3.284"></a><span id="l3.284">         rv = GetCardFromRow(currentIndex, getter_AddRefs(indexCard));</span>
<a href="#l3.285"></a><span id="l3.285">         NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.286"></a><span id="l3.286">       }</span>
<a href="#l3.287"></a><span id="l3.287">     }</span>
<a href="#l3.288"></a><span id="l3.288"> </span>
<a href="#l3.289"></a><span id="l3.289" class="difflineminus">-    mCards.Sort(inplaceSortCallback, (void *)(&amp;closure));</span>
<a href="#l3.290"></a><span id="l3.290" class="difflineminus">-    </span>
<a href="#l3.291"></a><span id="l3.291" class="difflineplus">+    CardComparator cardComparator;</span>
<a href="#l3.292"></a><span id="l3.292" class="difflineplus">+    cardComparator.SetClosure(&amp;closure);</span>
<a href="#l3.293"></a><span id="l3.293" class="difflineplus">+    mCards.Sort(cardComparator);</span>
<a href="#l3.294"></a><span id="l3.294" class="difflineplus">+</span>
<a href="#l3.295"></a><span id="l3.295">     rv = ReselectCards(selectedCards, indexCard);</span>
<a href="#l3.296"></a><span id="l3.296">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.297"></a><span id="l3.297"> </span>
<a href="#l3.298"></a><span id="l3.298">     mSortColumn = sortColumn;</span>
<a href="#l3.299"></a><span id="l3.299">     mSortDirection = sortDirection;</span>
<a href="#l3.300"></a><span id="l3.300">   }</span>
<a href="#l3.301"></a><span id="l3.301"> </span>
<a href="#l3.302"></a><span id="l3.302">   rv = InvalidateTree(ALL_ROWS);</span>
<a href="#l3.303"></a><span id="l3.303" class="difflineat">@@ -905,50 +922,50 @@ NS_IMETHODIMP nsAbView::Observe(nsISuppo</span>
<a href="#l3.304"></a><span id="l3.304"> }</span>
<a href="#l3.305"></a><span id="l3.305"> </span>
<a href="#l3.306"></a><span id="l3.306"> nsresult nsAbView::AddCard(AbCard *abcard, bool selectCardAfterAdding, int32_t *index)</span>
<a href="#l3.307"></a><span id="l3.307"> {</span>
<a href="#l3.308"></a><span id="l3.308">   nsresult rv = NS_OK;</span>
<a href="#l3.309"></a><span id="l3.309">   NS_ENSURE_ARG_POINTER(abcard);</span>
<a href="#l3.310"></a><span id="l3.310">   </span>
<a href="#l3.311"></a><span id="l3.311">   *index = FindIndexForInsert(abcard);</span>
<a href="#l3.312"></a><span id="l3.312" class="difflineminus">-  mCards.InsertElementAt((void *)abcard, *index);</span>
<a href="#l3.313"></a><span id="l3.313" class="difflineplus">+  mCards.InsertElementAt(*index, abcard);</span>
<a href="#l3.314"></a><span id="l3.314"> </span>
<a href="#l3.315"></a><span id="l3.315">   // This needs to happen after we insert the card, as RowCountChanged() will call GetRowCount()</span>
<a href="#l3.316"></a><span id="l3.316">   if (mTree)</span>
<a href="#l3.317"></a><span id="l3.317">     rv = mTree-&gt;RowCountChanged(*index, 1);</span>
<a href="#l3.318"></a><span id="l3.318"> </span>
<a href="#l3.319"></a><span id="l3.319">   // Checking for mTree here works around core bug 399227</span>
<a href="#l3.320"></a><span id="l3.320">   if (selectCardAfterAdding &amp;&amp; mTreeSelection &amp;&amp; mTree) {</span>
<a href="#l3.321"></a><span id="l3.321">     mTreeSelection-&gt;SetCurrentIndex(*index);</span>
<a href="#l3.322"></a><span id="l3.322">     mTreeSelection-&gt;RangedSelect(*index, *index, false /* augment */);</span>
<a href="#l3.323"></a><span id="l3.323">   }</span>
<a href="#l3.324"></a><span id="l3.324"> </span>
<a href="#l3.325"></a><span id="l3.325">   if (mAbViewListener &amp;&amp; !mSuppressCountChange) {</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineminus">-    rv = mAbViewListener-&gt;OnCountChanged(mCards.Count());</span>
<a href="#l3.327"></a><span id="l3.327" class="difflineplus">+    rv = mAbViewListener-&gt;OnCountChanged(mCards.Length());</span>
<a href="#l3.328"></a><span id="l3.328">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.329"></a><span id="l3.329">   }</span>
<a href="#l3.330"></a><span id="l3.330"> </span>
<a href="#l3.331"></a><span id="l3.331">   return rv;</span>
<a href="#l3.332"></a><span id="l3.332"> }</span>
<a href="#l3.333"></a><span id="l3.333"> </span>
<a href="#l3.334"></a><span id="l3.334"> int32_t nsAbView::FindIndexForInsert(AbCard *abcard)</span>
<a href="#l3.335"></a><span id="l3.335"> {</span>
<a href="#l3.336"></a><span id="l3.336" class="difflineminus">-  int32_t count = mCards.Count();</span>
<a href="#l3.337"></a><span id="l3.337" class="difflineplus">+  int32_t count = mCards.Length();</span>
<a href="#l3.338"></a><span id="l3.338">   int32_t i;</span>
<a href="#l3.339"></a><span id="l3.339"> </span>
<a href="#l3.340"></a><span id="l3.340">   void *item = (void *)abcard;</span>
<a href="#l3.341"></a><span id="l3.341">   </span>
<a href="#l3.342"></a><span id="l3.342">   SortClosure closure;</span>
<a href="#l3.343"></a><span id="l3.343">   SetSortClosure(mSortColumn.get(), mSortDirection.get(), this, &amp;closure);</span>
<a href="#l3.344"></a><span id="l3.344">   </span>
<a href="#l3.345"></a><span id="l3.345">   // XXX todo</span>
<a href="#l3.346"></a><span id="l3.346">   // Make this a binary search</span>
<a href="#l3.347"></a><span id="l3.347">   for (i=0; i &lt; count; i++) {</span>
<a href="#l3.348"></a><span id="l3.348" class="difflineminus">-    void *current = mCards.ElementAt(i);</span>
<a href="#l3.349"></a><span id="l3.349" class="difflineplus">+    void *current = (void *)mCards.ElementAt(i);</span>
<a href="#l3.350"></a><span id="l3.350">     int32_t value = inplaceSortCallback(item, current, (void *)(&amp;closure));</span>
<a href="#l3.351"></a><span id="l3.351">     // XXX Fix me, this is not right for both ascending and descending</span>
<a href="#l3.352"></a><span id="l3.352">     if (value &lt;= 0) </span>
<a href="#l3.353"></a><span id="l3.353">       break;</span>
<a href="#l3.354"></a><span id="l3.354">   }</span>
<a href="#l3.355"></a><span id="l3.355">   return i;</span>
<a href="#l3.356"></a><span id="l3.356"> }</span>
<a href="#l3.357"></a><span id="l3.357"> </span>
<a href="#l3.358"></a><span id="l3.358" class="difflineat">@@ -1000,34 +1017,34 @@ nsresult nsAbView::RemoveCardAndSelectNe</span>
<a href="#l3.359"></a><span id="l3.359">         if (index == selectedIndex)</span>
<a href="#l3.360"></a><span id="l3.360">           selectNextCard = true;</span>
<a href="#l3.361"></a><span id="l3.361">       }</span>
<a href="#l3.362"></a><span id="l3.362"> </span>
<a href="#l3.363"></a><span id="l3.363">       rv = RemoveCardAt(index);</span>
<a href="#l3.364"></a><span id="l3.364">       NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.365"></a><span id="l3.365"> </span>
<a href="#l3.366"></a><span id="l3.366">       if (selectNextCard) {</span>
<a href="#l3.367"></a><span id="l3.367" class="difflineminus">-      int32_t count = mCards.Count();</span>
<a href="#l3.368"></a><span id="l3.368" class="difflineplus">+      int32_t count = mCards.Length();</span>
<a href="#l3.369"></a><span id="l3.369">       if (count &amp;&amp; mTreeSelection) {</span>
<a href="#l3.370"></a><span id="l3.370">         // If we deleted the last card, adjust so we select the new &quot;last&quot; card</span>
<a href="#l3.371"></a><span id="l3.371">         if (index &gt;= (count - 1)) {</span>
<a href="#l3.372"></a><span id="l3.372">           index = count -1;</span>
<a href="#l3.373"></a><span id="l3.373">         }</span>
<a href="#l3.374"></a><span id="l3.374">         mTreeSelection-&gt;SetCurrentIndex(index);</span>
<a href="#l3.375"></a><span id="l3.375">         mTreeSelection-&gt;RangedSelect(index, index, false /* augment */);</span>
<a href="#l3.376"></a><span id="l3.376">       }</span>
<a href="#l3.377"></a><span id="l3.377">     }</span>
<a href="#l3.378"></a><span id="l3.378">   }</span>
<a href="#l3.379"></a><span id="l3.379">   }</span>
<a href="#l3.380"></a><span id="l3.380">   return rv;</span>
<a href="#l3.381"></a><span id="l3.381"> }</span>
<a href="#l3.382"></a><span id="l3.382"> </span>
<a href="#l3.383"></a><span id="l3.383"> int32_t nsAbView::FindIndexForCard(nsIAbCard *card)</span>
<a href="#l3.384"></a><span id="l3.384"> {</span>
<a href="#l3.385"></a><span id="l3.385" class="difflineminus">-  int32_t count = mCards.Count();</span>
<a href="#l3.386"></a><span id="l3.386" class="difflineplus">+  int32_t count = mCards.Length();</span>
<a href="#l3.387"></a><span id="l3.387">   int32_t i;</span>
<a href="#l3.388"></a><span id="l3.388">  </span>
<a href="#l3.389"></a><span id="l3.389">   // You can't implement the binary search here, as all you have is the nsIAbCard</span>
<a href="#l3.390"></a><span id="l3.390">   // you might be here because one of the card properties has changed, and that property</span>
<a href="#l3.391"></a><span id="l3.391">   // could be the collation key.</span>
<a href="#l3.392"></a><span id="l3.392">   for (i=0; i &lt; count; i++) {</span>
<a href="#l3.393"></a><span id="l3.393">     AbCard *abcard = (AbCard*) (mCards.ElementAt(i));</span>
<a href="#l3.394"></a><span id="l3.394">     bool equals;</span>
<a href="#l3.395"></a><span id="l3.395" class="difflineat">@@ -1211,17 +1228,17 @@ nsresult nsAbView::GetSelectedCards(nsCO</span>
<a href="#l3.396"></a><span id="l3.396">     return NS_OK;</span>
<a href="#l3.397"></a><span id="l3.397"> </span>
<a href="#l3.398"></a><span id="l3.398">   for (int32_t i = 0; i &lt; selectionCount; i++)</span>
<a href="#l3.399"></a><span id="l3.399">   {</span>
<a href="#l3.400"></a><span id="l3.400">     int32_t startRange;</span>
<a href="#l3.401"></a><span id="l3.401">     int32_t endRange;</span>
<a href="#l3.402"></a><span id="l3.402">     rv = mTreeSelection-&gt;GetRangeAt(i, &amp;startRange, &amp;endRange);</span>
<a href="#l3.403"></a><span id="l3.403">     NS_ENSURE_SUCCESS(rv, NS_OK); </span>
<a href="#l3.404"></a><span id="l3.404" class="difflineminus">-    int32_t totalCards = mCards.Count();</span>
<a href="#l3.405"></a><span id="l3.405" class="difflineplus">+    int32_t totalCards = mCards.Length();</span>
<a href="#l3.406"></a><span id="l3.406">     if (startRange &gt;= 0 &amp;&amp; startRange &lt; totalCards)</span>
<a href="#l3.407"></a><span id="l3.407">     {</span>
<a href="#l3.408"></a><span id="l3.408">       for (int32_t rangeIndex = startRange; rangeIndex &lt;= endRange &amp;&amp; rangeIndex &lt; totalCards; rangeIndex++) {</span>
<a href="#l3.409"></a><span id="l3.409">         nsCOMPtr&lt;nsIAbCard&gt; abCard;</span>
<a href="#l3.410"></a><span id="l3.410">         rv = GetCardFromRow(rangeIndex, getter_AddRefs(abCard));</span>
<a href="#l3.411"></a><span id="l3.411">         NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l3.412"></a><span id="l3.412">         </span>
<a href="#l3.413"></a><span id="l3.413">         rv = aSelectedCards-&gt;AppendElement(abCard, false);</span>
<a href="#l3.414"></a><span id="l3.414" class="difflineat">@@ -1277,17 +1294,17 @@ NS_IMETHODIMP nsAbView::SwapFirstNameLas</span>
<a href="#l3.415"></a><span id="l3.415">   }</span>
<a href="#l3.416"></a><span id="l3.416"> </span>
<a href="#l3.417"></a><span id="l3.417">   for (int32_t i = 0; i &lt; selectionCount; i++)</span>
<a href="#l3.418"></a><span id="l3.418">   {</span>
<a href="#l3.419"></a><span id="l3.419">     int32_t startRange;</span>
<a href="#l3.420"></a><span id="l3.420">     int32_t endRange;</span>
<a href="#l3.421"></a><span id="l3.421">     rv = mTreeSelection-&gt;GetRangeAt(i, &amp;startRange, &amp;endRange);</span>
<a href="#l3.422"></a><span id="l3.422">     NS_ENSURE_SUCCESS(rv, NS_OK); </span>
<a href="#l3.423"></a><span id="l3.423" class="difflineminus">-    int32_t totalCards = mCards.Count();</span>
<a href="#l3.424"></a><span id="l3.424" class="difflineplus">+    int32_t totalCards = mCards.Length();</span>
<a href="#l3.425"></a><span id="l3.425">     if (startRange &gt;= 0 &amp;&amp; startRange &lt; totalCards)</span>
<a href="#l3.426"></a><span id="l3.426">     {</span>
<a href="#l3.427"></a><span id="l3.427">       for (int32_t rangeIndex = startRange; rangeIndex &lt;= endRange &amp;&amp; rangeIndex &lt; totalCards; rangeIndex++) {</span>
<a href="#l3.428"></a><span id="l3.428">         nsCOMPtr&lt;nsIAbCard&gt; abCard;</span>
<a href="#l3.429"></a><span id="l3.429">         rv = GetCardFromRow(rangeIndex, getter_AddRefs(abCard));</span>
<a href="#l3.430"></a><span id="l3.430">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.431"></a><span id="l3.431"> </span>
<a href="#l3.432"></a><span id="l3.432">         // Swap FN/LN</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbView.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbView.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -7,17 +7,17 @@</span>
<a href="#l4.4"></a><span id="l4.4"> #define _nsAbView_H_</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6"> #include &quot;nsISupports.h&quot;</span>
<a href="#l4.7"></a><span id="l4.7"> #include &quot;nsStringGlue.h&quot;</span>
<a href="#l4.8"></a><span id="l4.8"> #include &quot;nsIAbView.h&quot;</span>
<a href="#l4.9"></a><span id="l4.9"> #include &quot;nsITreeView.h&quot;</span>
<a href="#l4.10"></a><span id="l4.10"> #include &quot;nsITreeBoxObject.h&quot;</span>
<a href="#l4.11"></a><span id="l4.11"> #include &quot;nsITreeSelection.h&quot;</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l4.14"></a><span id="l4.14"> #include &quot;nsIAbDirectory.h&quot;</span>
<a href="#l4.15"></a><span id="l4.15"> #include &quot;nsIAtom.h&quot;</span>
<a href="#l4.16"></a><span id="l4.16"> #include &quot;nsICollation.h&quot;</span>
<a href="#l4.17"></a><span id="l4.17"> #include &quot;nsIAbListener.h&quot;</span>
<a href="#l4.18"></a><span id="l4.18"> #include &quot;nsIObserver.h&quot;</span>
<a href="#l4.19"></a><span id="l4.19"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l4.20"></a><span id="l4.20"> #include &quot;nsComponentManagerUtils.h&quot;</span>
<a href="#l4.21"></a><span id="l4.21"> #include &quot;nsMemory.h&quot;</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineat">@@ -61,17 +61,17 @@ private:</span>
<a href="#l4.23"></a><span id="l4.23">   nsresult GetSelectedCards(nsCOMPtr&lt;nsIMutableArray&gt; &amp;aSelectedCards);</span>
<a href="#l4.24"></a><span id="l4.24">   nsresult ReselectCards(nsIArray *aCards, nsIAbCard *aIndexCard);</span>
<a href="#l4.25"></a><span id="l4.25">   nsresult GetCardValue(nsIAbCard *card, const char16_t *colID, nsAString &amp;_retval);</span>
<a href="#l4.26"></a><span id="l4.26">   nsresult RefreshTree();</span>
<a href="#l4.27"></a><span id="l4.27"> </span>
<a href="#l4.28"></a><span id="l4.28">   nsCOMPtr&lt;nsITreeBoxObject&gt; mTree;</span>
<a href="#l4.29"></a><span id="l4.29">   nsCOMPtr&lt;nsITreeSelection&gt; mTreeSelection;</span>
<a href="#l4.30"></a><span id="l4.30">   nsCOMPtr &lt;nsIAbDirectory&gt; mDirectory;</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">-  nsVoidArray mCards;</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+  nsTArray&lt;AbCard*&gt; mCards;</span>
<a href="#l4.33"></a><span id="l4.33">   nsString mSortColumn;</span>
<a href="#l4.34"></a><span id="l4.34">   nsString mSortDirection;</span>
<a href="#l4.35"></a><span id="l4.35">   nsCOMPtr&lt;nsICollation&gt; mCollationKeyGenerator;</span>
<a href="#l4.36"></a><span id="l4.36">   nsCOMPtr&lt;nsIAbViewListener&gt; mAbViewListener;</span>
<a href="#l4.37"></a><span id="l4.37">   nsCOMPtr&lt;nsIStringBundle&gt; mABBundle;</span>
<a href="#l4.38"></a><span id="l4.38"> </span>
<a href="#l4.39"></a><span id="l4.39">   bool mInitialized;</span>
<a href="#l4.40"></a><span id="l4.40">   bool mIsAllDirectoryRootView;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/addrbook/src/nsDirPrefs.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsDirPrefs.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -5,17 +5,17 @@</span>
<a href="#l5.4"></a><span id="l5.4"> </span>
<a href="#l5.5"></a><span id="l5.5"> /* directory server preferences (used to be dirprefs.c in 4.x) */</span>
<a href="#l5.6"></a><span id="l5.6"> </span>
<a href="#l5.7"></a><span id="l5.7"> #include &quot;nsIPrefService.h&quot;</span>
<a href="#l5.8"></a><span id="l5.8"> #include &quot;nsIPrefBranch.h&quot;</span>
<a href="#l5.9"></a><span id="l5.9"> #include &quot;nsDirPrefs.h&quot;</span>
<a href="#l5.10"></a><span id="l5.10"> #include &quot;nsIPrefLocalizedString.h&quot;</span>
<a href="#l5.11"></a><span id="l5.11"> #include &quot;nsIObserver.h&quot;</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l5.14"></a><span id="l5.14"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l5.15"></a><span id="l5.15"> #include &quot;nsMemory.h&quot;</span>
<a href="#l5.16"></a><span id="l5.16"> #include &quot;nsIAddrDatabase.h&quot;</span>
<a href="#l5.17"></a><span id="l5.17"> #include &quot;nsAbBaseCID.h&quot;</span>
<a href="#l5.18"></a><span id="l5.18"> #include &quot;nsIAbManager.h&quot;</span>
<a href="#l5.19"></a><span id="l5.19"> #include &quot;nsIFile.h&quot;</span>
<a href="#l5.20"></a><span id="l5.20"> #include &quot;nsWeakReference.h&quot;</span>
<a href="#l5.21"></a><span id="l5.21"> #include &quot;nsIAbMDBDirectory.h&quot;</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineat">@@ -43,38 +43,38 @@ static bool dir_IsServerDeleted(DIR_Serv</span>
<a href="#l5.23"></a><span id="l5.23"> static char *DIR_GetStringPref(const char *prefRoot, const char *prefLeaf, const char *defaultValue);</span>
<a href="#l5.24"></a><span id="l5.24"> static int32_t DIR_GetIntPref(const char *prefRoot, const char *prefLeaf, int32_t defaultValue);</span>
<a href="#l5.25"></a><span id="l5.25"> static char *DIR_GetLocalizedStringPref(const char *prefRoot, const char *prefLeaf);</span>
<a href="#l5.26"></a><span id="l5.26"> </span>
<a href="#l5.27"></a><span id="l5.27"> static char * dir_ConvertDescriptionToPrefName(DIR_Server * server);</span>
<a href="#l5.28"></a><span id="l5.28"> </span>
<a href="#l5.29"></a><span id="l5.29"> void DIR_SetFileName(char** filename, const char* leafName);</span>
<a href="#l5.30"></a><span id="l5.30"> static void DIR_SetIntPref(const char *prefRoot, const char *prefLeaf, int32_t value, int32_t defaultValue);</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineminus">-static DIR_Server *dir_MatchServerPrefToServer(nsVoidArray *wholeList, const char *pref);</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineminus">-static bool dir_ValidateAndAddNewServer(nsVoidArray *wholeList, const char *fullprefname);</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineminus">-static void DIR_DeleteServerList(nsVoidArray *wholeList);</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+static DIR_Server *dir_MatchServerPrefToServer(nsTArray&lt;DIR_Server*&gt; *wholeList, const char *pref);</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+static bool dir_ValidateAndAddNewServer(nsTArray&lt;DIR_Server*&gt; *wholeList, const char *fullprefname);</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+static void DIR_DeleteServerList(nsTArray&lt;DIR_Server*&gt; *wholeList);</span>
<a href="#l5.37"></a><span id="l5.37"> </span>
<a href="#l5.38"></a><span id="l5.38"> static char *dir_CreateServerPrefName(DIR_Server *server);</span>
<a href="#l5.39"></a><span id="l5.39"> static void DIR_GetPrefsForOneServer(DIR_Server *server);</span>
<a href="#l5.40"></a><span id="l5.40"> </span>
<a href="#l5.41"></a><span id="l5.41"> static void DIR_InitServer(DIR_Server *server, DirectoryType dirType = (DirectoryType)0);</span>
<a href="#l5.42"></a><span id="l5.42"> static DIR_PrefId  DIR_AtomizePrefName(const char *prefname);</span>
<a href="#l5.43"></a><span id="l5.43"> </span>
<a href="#l5.44"></a><span id="l5.44"> const int32_t DIR_POS_APPEND = -1;</span>
<a href="#l5.45"></a><span id="l5.45"> const int32_t DIR_POS_DELETE = -2;</span>
<a href="#l5.46"></a><span id="l5.46" class="difflineminus">-static bool DIR_SetServerPosition(nsVoidArray *wholeList, DIR_Server *server, int32_t position);</span>
<a href="#l5.47"></a><span id="l5.47" class="difflineplus">+static bool DIR_SetServerPosition(nsTArray&lt;DIR_Server*&gt; *wholeList, DIR_Server *server, int32_t position);</span>
<a href="#l5.48"></a><span id="l5.48"> </span>
<a href="#l5.49"></a><span id="l5.49"> /* These two routines should be called to initialize and save </span>
<a href="#l5.50"></a><span id="l5.50">  * directory preferences from the XP Java Script preferences</span>
<a href="#l5.51"></a><span id="l5.51">  */</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineminus">-static nsresult DIR_GetServerPreferences(nsVoidArray** list);</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineminus">-static void DIR_SaveServerPreferences(nsVoidArray *wholeList);</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+static nsresult DIR_GetServerPreferences(nsTArray&lt;DIR_Server*&gt;** list);</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+static void DIR_SaveServerPreferences(nsTArray&lt;DIR_Server*&gt; *wholeList);</span>
<a href="#l5.56"></a><span id="l5.56"> </span>
<a href="#l5.57"></a><span id="l5.57"> static int32_t dir_UserId = 0;</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineminus">-nsVoidArray *dir_ServerList = nullptr;</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+nsTArray&lt;DIR_Server*&gt; *dir_ServerList = nullptr;</span>
<a href="#l5.60"></a><span id="l5.60"> </span>
<a href="#l5.61"></a><span id="l5.61"> /*****************************************************************************</span>
<a href="#l5.62"></a><span id="l5.62">  * Functions for creating the new back end managed DIR_Server list.</span>
<a href="#l5.63"></a><span id="l5.63">  */</span>
<a href="#l5.64"></a><span id="l5.64"> class DirPrefObserver final : public nsSupportsWeakReference,</span>
<a href="#l5.65"></a><span id="l5.65">                               public nsIObserver</span>
<a href="#l5.66"></a><span id="l5.66"> {</span>
<a href="#l5.67"></a><span id="l5.67"> public:</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineat">@@ -174,33 +174,33 @@ static nsresult DIR_GetDirServers()</span>
<a href="#l5.69"></a><span id="l5.69">       NS_ADDREF(prefObserver);</span>
<a href="#l5.70"></a><span id="l5.70"> </span>
<a href="#l5.71"></a><span id="l5.71">       pbi-&gt;AddObserver(PREF_LDAP_SERVER_TREE_NAME, prefObserver, true);</span>
<a href="#l5.72"></a><span id="l5.72">     }</span>
<a href="#l5.73"></a><span id="l5.73">   }</span>
<a href="#l5.74"></a><span id="l5.74">   return rv;</span>
<a href="#l5.75"></a><span id="l5.75"> }</span>
<a href="#l5.76"></a><span id="l5.76"> </span>
<a href="#l5.77"></a><span id="l5.77" class="difflineminus">-nsVoidArray* DIR_GetDirectories()</span>
<a href="#l5.78"></a><span id="l5.78" class="difflineplus">+nsTArray&lt;DIR_Server*&gt;* DIR_GetDirectories()</span>
<a href="#l5.79"></a><span id="l5.79"> {</span>
<a href="#l5.80"></a><span id="l5.80">     if (!dir_ServerList)</span>
<a href="#l5.81"></a><span id="l5.81">         DIR_GetDirServers();</span>
<a href="#l5.82"></a><span id="l5.82">   return dir_ServerList;</span>
<a href="#l5.83"></a><span id="l5.83"> }</span>
<a href="#l5.84"></a><span id="l5.84"> </span>
<a href="#l5.85"></a><span id="l5.85"> DIR_Server* DIR_GetServerFromList(const char* prefName)</span>
<a href="#l5.86"></a><span id="l5.86"> {</span>
<a href="#l5.87"></a><span id="l5.87">   DIR_Server* result = nullptr;</span>
<a href="#l5.88"></a><span id="l5.88"> </span>
<a href="#l5.89"></a><span id="l5.89">   if (!dir_ServerList)</span>
<a href="#l5.90"></a><span id="l5.90">     DIR_GetDirServers();</span>
<a href="#l5.91"></a><span id="l5.91"> </span>
<a href="#l5.92"></a><span id="l5.92">   if (dir_ServerList)</span>
<a href="#l5.93"></a><span id="l5.93">   {</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineminus">-    int32_t count = dir_ServerList-&gt;Count();</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineplus">+    int32_t count = dir_ServerList-&gt;Length();</span>
<a href="#l5.96"></a><span id="l5.96">     int32_t i;</span>
<a href="#l5.97"></a><span id="l5.97">     for (i = 0; i &lt; count; ++i)</span>
<a href="#l5.98"></a><span id="l5.98">     {</span>
<a href="#l5.99"></a><span id="l5.99">       DIR_Server *server = (DIR_Server *)dir_ServerList-&gt;ElementAt(i);</span>
<a href="#l5.100"></a><span id="l5.100"> </span>
<a href="#l5.101"></a><span id="l5.101">       if (server &amp;&amp; strcmp(server-&gt;prefName, prefName) == 0)</span>
<a href="#l5.102"></a><span id="l5.102">       {</span>
<a href="#l5.103"></a><span id="l5.103">         result = server;</span>
<a href="#l5.104"></a><span id="l5.104" class="difflineat">@@ -240,17 +240,17 @@ nsresult DIR_ShutDown()  /* FEs should c</span>
<a href="#l5.105"></a><span id="l5.105">   </span>
<a href="#l5.106"></a><span id="l5.106">   return NS_OK;</span>
<a href="#l5.107"></a><span id="l5.107"> }</span>
<a href="#l5.108"></a><span id="l5.108"> </span>
<a href="#l5.109"></a><span id="l5.109"> nsresult DIR_ContainsServer(DIR_Server* pServer, bool *hasDir)</span>
<a href="#l5.110"></a><span id="l5.110"> {</span>
<a href="#l5.111"></a><span id="l5.111">   if (dir_ServerList)</span>
<a href="#l5.112"></a><span id="l5.112">   {</span>
<a href="#l5.113"></a><span id="l5.113" class="difflineminus">-    int32_t count = dir_ServerList-&gt;Count();</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineplus">+    int32_t count = dir_ServerList-&gt;Length();</span>
<a href="#l5.115"></a><span id="l5.115">     int32_t i;</span>
<a href="#l5.116"></a><span id="l5.116">     for (i = 0; i &lt; count; i++)</span>
<a href="#l5.117"></a><span id="l5.117">     {</span>
<a href="#l5.118"></a><span id="l5.118">       DIR_Server* server = (DIR_Server *)(dir_ServerList-&gt;ElementAt(i));</span>
<a href="#l5.119"></a><span id="l5.119">       if (server == pServer)</span>
<a href="#l5.120"></a><span id="l5.120">       {</span>
<a href="#l5.121"></a><span id="l5.121">         *hasDir = true;</span>
<a href="#l5.122"></a><span id="l5.122">         return NS_OK;</span>
<a href="#l5.123"></a><span id="l5.123" class="difflineat">@@ -333,30 +333,30 @@ static void DIR_InitServer(DIR_Server *s</span>
<a href="#l5.124"></a><span id="l5.124">  * are supported:</span>
<a href="#l5.125"></a><span id="l5.125">  *   DIR_POS_APPEND - Appends the server to the end of the list.  If the server</span>
<a href="#l5.126"></a><span id="l5.126">  *                    is already in the list, does nothing.</span>
<a href="#l5.127"></a><span id="l5.127">  *   DIR_POS_DELETE - Deletes the given server from the list.  Note that this</span>
<a href="#l5.128"></a><span id="l5.128">  *                    does not cause the server structure to be freed.</span>
<a href="#l5.129"></a><span id="l5.129">  *</span>
<a href="#l5.130"></a><span id="l5.130">  * Returns true if the server list was re-sorted.</span>
<a href="#l5.131"></a><span id="l5.131">  */</span>
<a href="#l5.132"></a><span id="l5.132" class="difflineminus">-static bool DIR_SetServerPosition(nsVoidArray *wholeList, DIR_Server *server, int32_t position)</span>
<a href="#l5.133"></a><span id="l5.133" class="difflineplus">+static bool DIR_SetServerPosition(nsTArray&lt;DIR_Server*&gt; *wholeList, DIR_Server *server, int32_t position)</span>
<a href="#l5.134"></a><span id="l5.134">  {</span>
<a href="#l5.135"></a><span id="l5.135">    NS_ENSURE_TRUE(wholeList, false);</span>
<a href="#l5.136"></a><span id="l5.136"> </span>
<a href="#l5.137"></a><span id="l5.137">    int32_t    i, count, num;</span>
<a href="#l5.138"></a><span id="l5.138">    bool       resort = false;</span>
<a href="#l5.139"></a><span id="l5.139">    DIR_Server *s=nullptr;</span>
<a href="#l5.140"></a><span id="l5.140">    </span>
<a href="#l5.141"></a><span id="l5.141">    switch (position) {</span>
<a href="#l5.142"></a><span id="l5.142">    case DIR_POS_APPEND:</span>
<a href="#l5.143"></a><span id="l5.143">    /* Do nothing if the request is to append a server that is already</span>
<a href="#l5.144"></a><span id="l5.144">      * in the list.</span>
<a href="#l5.145"></a><span id="l5.145">      */</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineminus">-     count = wholeList-&gt;Count();</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineplus">+     count = wholeList-&gt;Length();</span>
<a href="#l5.148"></a><span id="l5.148">      for (i= 0; i &lt; count; i++)</span>
<a href="#l5.149"></a><span id="l5.149">      {</span>
<a href="#l5.150"></a><span id="l5.150">        if  ((s = (DIR_Server *)wholeList-&gt;ElementAt(i)) != nullptr)</span>
<a href="#l5.151"></a><span id="l5.151">          if (s == server)</span>
<a href="#l5.152"></a><span id="l5.152">            return false;</span>
<a href="#l5.153"></a><span id="l5.153">      }</span>
<a href="#l5.154"></a><span id="l5.154">      /* In general, if there are any servers already in the list, set the</span>
<a href="#l5.155"></a><span id="l5.155">      * position to the position of the last server plus one.  If there</span>
<a href="#l5.156"></a><span id="l5.156" class="difflineat">@@ -394,33 +394,33 @@ static bool DIR_SetServerPosition(nsVoid</span>
<a href="#l5.157"></a><span id="l5.157">      /* If the server is in the server list, remove it.</span>
<a href="#l5.158"></a><span id="l5.158">      */</span>
<a href="#l5.159"></a><span id="l5.159">      num = wholeList-&gt;IndexOf(server);</span>
<a href="#l5.160"></a><span id="l5.160">      if (num &gt;= 0)</span>
<a href="#l5.161"></a><span id="l5.161">      {</span>
<a href="#l5.162"></a><span id="l5.162">      /* The list does not need to be re-sorted if the server is the</span>
<a href="#l5.163"></a><span id="l5.163">      * last one in the list.</span>
<a href="#l5.164"></a><span id="l5.164">        */</span>
<a href="#l5.165"></a><span id="l5.165" class="difflineminus">-       count = wholeList-&gt;Count();</span>
<a href="#l5.166"></a><span id="l5.166" class="difflineplus">+       count = wholeList-&gt;Length();</span>
<a href="#l5.167"></a><span id="l5.167">        if (num == count - 1)</span>
<a href="#l5.168"></a><span id="l5.168">        {</span>
<a href="#l5.169"></a><span id="l5.169">          wholeList-&gt;RemoveElementAt(num);</span>
<a href="#l5.170"></a><span id="l5.170">        }</span>
<a href="#l5.171"></a><span id="l5.171">        else</span>
<a href="#l5.172"></a><span id="l5.172">        {</span>
<a href="#l5.173"></a><span id="l5.173">          resort = true;</span>
<a href="#l5.174"></a><span id="l5.174">          wholeList-&gt;RemoveElement(server);</span>
<a href="#l5.175"></a><span id="l5.175">        }</span>
<a href="#l5.176"></a><span id="l5.176">      }</span>
<a href="#l5.177"></a><span id="l5.177">      break;</span>
<a href="#l5.178"></a><span id="l5.178">      </span>
<a href="#l5.179"></a><span id="l5.179">    default:</span>
<a href="#l5.180"></a><span id="l5.180">    /* See if the server is already in the list.</span>
<a href="#l5.181"></a><span id="l5.181">      */</span>
<a href="#l5.182"></a><span id="l5.182" class="difflineminus">-     count = wholeList-&gt;Count();</span>
<a href="#l5.183"></a><span id="l5.183" class="difflineplus">+     count = wholeList-&gt;Length();</span>
<a href="#l5.184"></a><span id="l5.184">      for (i= 0; i &lt; count; i++)</span>
<a href="#l5.185"></a><span id="l5.185">      {</span>
<a href="#l5.186"></a><span id="l5.186">        if  ((s = (DIR_Server *)wholeList-&gt;ElementAt(i)) != nullptr)</span>
<a href="#l5.187"></a><span id="l5.187">          if (s == server)</span>
<a href="#l5.188"></a><span id="l5.188">            break;</span>
<a href="#l5.189"></a><span id="l5.189">      }</span>
<a href="#l5.190"></a><span id="l5.190">      </span>
<a href="#l5.191"></a><span id="l5.191">      /* If the server is not in the list, add it to the beginning and re-sort.</span>
<a href="#l5.192"></a><span id="l5.192" class="difflineat">@@ -455,21 +455,21 @@ static bool DIR_SetServerPosition(nsVoid</span>
<a href="#l5.193"></a><span id="l5.193">  * DIR_Server Callback Notification Functions</span>
<a href="#l5.194"></a><span id="l5.194">  */</span>
<a href="#l5.195"></a><span id="l5.195"> </span>
<a href="#l5.196"></a><span id="l5.196"> /* dir_matchServerPrefToServer</span>
<a href="#l5.197"></a><span id="l5.197">  *</span>
<a href="#l5.198"></a><span id="l5.198">  * This function finds the DIR_Server in the unified DIR_Server list to which</span>
<a href="#l5.199"></a><span id="l5.199">  * the given preference string belongs.</span>
<a href="#l5.200"></a><span id="l5.200">  */</span>
<a href="#l5.201"></a><span id="l5.201" class="difflineminus">-static DIR_Server *dir_MatchServerPrefToServer(nsVoidArray *wholeList, const char *pref)</span>
<a href="#l5.202"></a><span id="l5.202" class="difflineplus">+static DIR_Server *dir_MatchServerPrefToServer(nsTArray&lt;DIR_Server*&gt; *wholeList, const char *pref)</span>
<a href="#l5.203"></a><span id="l5.203"> {</span>
<a href="#l5.204"></a><span id="l5.204">   DIR_Server *server;</span>
<a href="#l5.205"></a><span id="l5.205"> </span>
<a href="#l5.206"></a><span id="l5.206" class="difflineminus">-  int32_t count = wholeList-&gt;Count();</span>
<a href="#l5.207"></a><span id="l5.207" class="difflineplus">+  int32_t count = wholeList-&gt;Length();</span>
<a href="#l5.208"></a><span id="l5.208">   int32_t i;</span>
<a href="#l5.209"></a><span id="l5.209">   for (i = 0; i &lt; count; i++)</span>
<a href="#l5.210"></a><span id="l5.210">   {</span>
<a href="#l5.211"></a><span id="l5.211">     if ((server = (DIR_Server *)wholeList-&gt;ElementAt(i)) != nullptr)</span>
<a href="#l5.212"></a><span id="l5.212">     {</span>
<a href="#l5.213"></a><span id="l5.213">       if (server-&gt;prefName &amp;&amp; PL_strstr(pref, server-&gt;prefName) == pref)</span>
<a href="#l5.214"></a><span id="l5.214">       {</span>
<a href="#l5.215"></a><span id="l5.215">         char c = pref[PL_strlen(server-&gt;prefName)];</span>
<a href="#l5.216"></a><span id="l5.216" class="difflineat">@@ -482,17 +482,17 @@ static DIR_Server *dir_MatchServerPrefTo</span>
<a href="#l5.217"></a><span id="l5.217"> }</span>
<a href="#l5.218"></a><span id="l5.218"> </span>
<a href="#l5.219"></a><span id="l5.219"> /* dir_ValidateAndAddNewServer</span>
<a href="#l5.220"></a><span id="l5.220">  *</span>
<a href="#l5.221"></a><span id="l5.221">  * This function verifies that the position, serverName and description values</span>
<a href="#l5.222"></a><span id="l5.222">  * are set for the given prefName.  If they are then it adds the server to the</span>
<a href="#l5.223"></a><span id="l5.223">  * unified server list.</span>
<a href="#l5.224"></a><span id="l5.224">  */</span>
<a href="#l5.225"></a><span id="l5.225" class="difflineminus">-static bool dir_ValidateAndAddNewServer(nsVoidArray *wholeList, const char *fullprefname)</span>
<a href="#l5.226"></a><span id="l5.226" class="difflineplus">+static bool dir_ValidateAndAddNewServer(nsTArray&lt;DIR_Server*&gt; *wholeList, const char *fullprefname)</span>
<a href="#l5.227"></a><span id="l5.227"> {</span>
<a href="#l5.228"></a><span id="l5.228">   bool rc = false;</span>
<a href="#l5.229"></a><span id="l5.229"> </span>
<a href="#l5.230"></a><span id="l5.230">   const char *endname = PL_strchr(&amp;fullprefname[PL_strlen(PREF_LDAP_SERVER_TREE_NAME) + 1], '.');</span>
<a href="#l5.231"></a><span id="l5.231">   if (endname)</span>
<a href="#l5.232"></a><span id="l5.232">   {</span>
<a href="#l5.233"></a><span id="l5.233">     char *prefname = (char *)PR_Malloc(endname - fullprefname + 1);</span>
<a href="#l5.234"></a><span id="l5.234">     if (prefname)</span>
<a href="#l5.235"></a><span id="l5.235" class="difflineat">@@ -655,34 +655,34 @@ nsresult DIR_DeleteServerFromList(DIR_Se</span>
<a href="#l5.236"></a><span id="l5.236">       if (database)  /* database exists */</span>
<a href="#l5.237"></a><span id="l5.237">       {</span>
<a href="#l5.238"></a><span id="l5.238">         database-&gt;ForceClosed();</span>
<a href="#l5.239"></a><span id="l5.239">         rv = dbPath-&gt;Remove(false);</span>
<a href="#l5.240"></a><span id="l5.240">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l5.241"></a><span id="l5.241">       }</span>
<a href="#l5.242"></a><span id="l5.242">     }</span>
<a href="#l5.243"></a><span id="l5.243"> </span>
<a href="#l5.244"></a><span id="l5.244" class="difflineminus">-    nsVoidArray *dirList = DIR_GetDirectories();</span>
<a href="#l5.245"></a><span id="l5.245" class="difflineplus">+    nsTArray&lt;DIR_Server*&gt; *dirList = DIR_GetDirectories();</span>
<a href="#l5.246"></a><span id="l5.246">     DIR_SetServerPosition(dirList, server, DIR_POS_DELETE);</span>
<a href="#l5.247"></a><span id="l5.247">     DIR_DeleteServer(server);</span>
<a href="#l5.248"></a><span id="l5.248"> </span>
<a href="#l5.249"></a><span id="l5.249">     return SavePrefsFile();</span>
<a href="#l5.250"></a><span id="l5.250">   }</span>
<a href="#l5.251"></a><span id="l5.251"> </span>
<a href="#l5.252"></a><span id="l5.252">   return NS_ERROR_NULL_POINTER;</span>
<a href="#l5.253"></a><span id="l5.253"> }</span>
<a href="#l5.254"></a><span id="l5.254"> </span>
<a href="#l5.255"></a><span id="l5.255" class="difflineminus">-static void DIR_DeleteServerList(nsVoidArray *wholeList)</span>
<a href="#l5.256"></a><span id="l5.256" class="difflineplus">+static void DIR_DeleteServerList(nsTArray&lt;DIR_Server*&gt; *wholeList)</span>
<a href="#l5.257"></a><span id="l5.257"> {</span>
<a href="#l5.258"></a><span id="l5.258">   if (wholeList)</span>
<a href="#l5.259"></a><span id="l5.259">   {</span>
<a href="#l5.260"></a><span id="l5.260">     DIR_Server *server = nullptr;</span>
<a href="#l5.261"></a><span id="l5.261">   </span>
<a href="#l5.262"></a><span id="l5.262">     /* TBD: Send notifications? */</span>
<a href="#l5.263"></a><span id="l5.263" class="difflineminus">-    int32_t count = wholeList-&gt;Count();</span>
<a href="#l5.264"></a><span id="l5.264" class="difflineplus">+    int32_t count = wholeList-&gt;Length();</span>
<a href="#l5.265"></a><span id="l5.265">     int32_t i;</span>
<a href="#l5.266"></a><span id="l5.266">     for (i = count - 1; i &gt;=0; i--)</span>
<a href="#l5.267"></a><span id="l5.267">     {</span>
<a href="#l5.268"></a><span id="l5.268">       server = (DIR_Server *)wholeList-&gt;ElementAt(i);</span>
<a href="#l5.269"></a><span id="l5.269">       if (server != nullptr)</span>
<a href="#l5.270"></a><span id="l5.270">         DIR_DeleteServer(server);</span>
<a href="#l5.271"></a><span id="l5.271">     }</span>
<a href="#l5.272"></a><span id="l5.272">     delete wholeList;</span>
<a href="#l5.273"></a><span id="l5.273" class="difflineat">@@ -1115,24 +1115,24 @@ static void DIR_GetPrefsForOneServer(DIR</span>
<a href="#l5.274"></a><span id="l5.274"> #else</span>
<a href="#l5.275"></a><span id="l5.275">     // Fallback to the all directory root in the non-ldap enabled case.</span>
<a href="#l5.276"></a><span id="l5.276">     kMDBDirectoryRoot : kAllDirectoryRoot);</span>
<a href="#l5.277"></a><span id="l5.277"> #endif</span>
<a href="#l5.278"></a><span id="l5.278">   s.Append (server-&gt;fileName);</span>
<a href="#l5.279"></a><span id="l5.279">   server-&gt;uri = DIR_GetStringPref (prefstring, &quot;uri&quot;, s.get ());</span>
<a href="#l5.280"></a><span id="l5.280"> }</span>
<a href="#l5.281"></a><span id="l5.281"> </span>
<a href="#l5.282"></a><span id="l5.282" class="difflineminus">-static nsresult dir_GetPrefs(nsVoidArray **list)</span>
<a href="#l5.283"></a><span id="l5.283" class="difflineplus">+static nsresult dir_GetPrefs(nsTArray&lt;DIR_Server*&gt; **list)</span>
<a href="#l5.284"></a><span id="l5.284"> {</span>
<a href="#l5.285"></a><span id="l5.285">     nsresult rv;</span>
<a href="#l5.286"></a><span id="l5.286">     nsCOMPtr&lt;nsIPrefBranch&gt; pPref(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l5.287"></a><span id="l5.287">     if (NS_FAILED(rv))</span>
<a href="#l5.288"></a><span id="l5.288">         return rv;</span>
<a href="#l5.289"></a><span id="l5.289"> </span>
<a href="#l5.290"></a><span id="l5.290" class="difflineminus">-    (*list) = new nsVoidArray();</span>
<a href="#l5.291"></a><span id="l5.291" class="difflineplus">+    (*list) = new nsTArray&lt;DIR_Server*&gt;();</span>
<a href="#l5.292"></a><span id="l5.292">     if (!(*list))</span>
<a href="#l5.293"></a><span id="l5.293">         return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l5.294"></a><span id="l5.294"> </span>
<a href="#l5.295"></a><span id="l5.295">     char **children;</span>
<a href="#l5.296"></a><span id="l5.296">     uint32_t prefCount;</span>
<a href="#l5.297"></a><span id="l5.297"> </span>
<a href="#l5.298"></a><span id="l5.298">     rv = dir_GetChildList(NS_LITERAL_CSTRING(PREF_LDAP_SERVER_TREE_NAME &quot;.&quot;),</span>
<a href="#l5.299"></a><span id="l5.299">                           &amp;prefCount, &amp;children);</span>
<a href="#l5.300"></a><span id="l5.300" class="difflineat">@@ -1176,45 +1176,45 @@ static nsresult dir_GetPrefs(nsVoidArray</span>
<a href="#l5.301"></a><span id="l5.301">     }</span>
<a href="#l5.302"></a><span id="l5.302"> </span>
<a href="#l5.303"></a><span id="l5.303">     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, children);</span>
<a href="#l5.304"></a><span id="l5.304"> </span>
<a href="#l5.305"></a><span id="l5.305">     return NS_OK;</span>
<a href="#l5.306"></a><span id="l5.306"> }</span>
<a href="#l5.307"></a><span id="l5.307"> </span>
<a href="#l5.308"></a><span id="l5.308"> // I don't think we care about locked positions, etc.</span>
<a href="#l5.309"></a><span id="l5.309" class="difflineminus">-void DIR_SortServersByPosition(nsVoidArray *serverList)</span>
<a href="#l5.310"></a><span id="l5.310" class="difflineplus">+void DIR_SortServersByPosition(nsTArray&lt;DIR_Server*&gt; *serverList)</span>
<a href="#l5.311"></a><span id="l5.311"> {</span>
<a href="#l5.312"></a><span id="l5.312">   int i, j;</span>
<a href="#l5.313"></a><span id="l5.313">   DIR_Server *server;</span>
<a href="#l5.314"></a><span id="l5.314">   </span>
<a href="#l5.315"></a><span id="l5.315" class="difflineminus">-  int count = serverList-&gt;Count();</span>
<a href="#l5.316"></a><span id="l5.316" class="difflineplus">+  int count = serverList-&gt;Length();</span>
<a href="#l5.317"></a><span id="l5.317">   for (i = 0; i &lt; count - 1; i++)</span>
<a href="#l5.318"></a><span id="l5.318">   {</span>
<a href="#l5.319"></a><span id="l5.319">     for (j = i + 1; j &lt; count; j++)</span>
<a href="#l5.320"></a><span id="l5.320">     {</span>
<a href="#l5.321"></a><span id="l5.321">       if (((DIR_Server *) serverList-&gt;ElementAt(j))-&gt;position &lt; ((DIR_Server *) serverList-&gt;ElementAt(i))-&gt;position)</span>
<a href="#l5.322"></a><span id="l5.322">       {</span>
<a href="#l5.323"></a><span id="l5.323">         server        = (DIR_Server *) serverList-&gt;ElementAt(i);</span>
<a href="#l5.324"></a><span id="l5.324" class="difflineminus">-        serverList-&gt;ReplaceElementAt(serverList-&gt;ElementAt(j), i);</span>
<a href="#l5.325"></a><span id="l5.325" class="difflineminus">-        serverList-&gt;ReplaceElementAt(server, j);</span>
<a href="#l5.326"></a><span id="l5.326" class="difflineplus">+        serverList-&gt;ReplaceElementAt(i, serverList-&gt;ElementAt(j));</span>
<a href="#l5.327"></a><span id="l5.327" class="difflineplus">+        serverList-&gt;ReplaceElementAt(j, server);</span>
<a href="#l5.328"></a><span id="l5.328">       }</span>
<a href="#l5.329"></a><span id="l5.329">     }</span>
<a href="#l5.330"></a><span id="l5.330">   }</span>
<a href="#l5.331"></a><span id="l5.331"> }</span>
<a href="#l5.332"></a><span id="l5.332"> </span>
<a href="#l5.333"></a><span id="l5.333" class="difflineminus">-static nsresult DIR_GetServerPreferences(nsVoidArray** list)</span>
<a href="#l5.334"></a><span id="l5.334" class="difflineplus">+static nsresult DIR_GetServerPreferences(nsTArray&lt;DIR_Server*&gt;** list)</span>
<a href="#l5.335"></a><span id="l5.335"> {</span>
<a href="#l5.336"></a><span id="l5.336">   nsresult err;</span>
<a href="#l5.337"></a><span id="l5.337">   nsCOMPtr&lt;nsIPrefBranch&gt; pPref(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;err));</span>
<a href="#l5.338"></a><span id="l5.338">   if (NS_FAILED(err))</span>
<a href="#l5.339"></a><span id="l5.339">     return err;</span>
<a href="#l5.340"></a><span id="l5.340"> </span>
<a href="#l5.341"></a><span id="l5.341">   int32_t version = -1;</span>
<a href="#l5.342"></a><span id="l5.342" class="difflineminus">-  nsVoidArray *newList = nullptr;</span>
<a href="#l5.343"></a><span id="l5.343" class="difflineplus">+  nsTArray&lt;DIR_Server*&gt; *newList = nullptr;</span>
<a href="#l5.344"></a><span id="l5.344">   </span>
<a href="#l5.345"></a><span id="l5.345">   /* Update the ldap list version and see if there are old prefs to migrate. */</span>
<a href="#l5.346"></a><span id="l5.346">   err = pPref-&gt;GetIntPref(PREF_LDAP_VERSION_NAME, &amp;version);</span>
<a href="#l5.347"></a><span id="l5.347">   NS_ENSURE_SUCCESS(err, err);</span>
<a href="#l5.348"></a><span id="l5.348"> </span>
<a href="#l5.349"></a><span id="l5.349">   /* Find the new-style &quot;ldap_2.servers&quot; tree in prefs */</span>
<a href="#l5.350"></a><span id="l5.350">   err = dir_GetPrefs(&amp;newList);</span>
<a href="#l5.351"></a><span id="l5.351"> </span>
<a href="#l5.352"></a><span id="l5.352" class="difflineat">@@ -1421,29 +1421,29 @@ void DIR_SavePrefsForOneServer(DIR_Serve</span>
<a href="#l5.353"></a><span id="l5.353">   DIR_SetIntPref(prefstring, &quot;dirType&quot;, server-&gt;dirType, LDAPDirectory);</span>
<a href="#l5.354"></a><span id="l5.354"> </span>
<a href="#l5.355"></a><span id="l5.355">   if (server-&gt;dirType != PABDirectory)</span>
<a href="#l5.356"></a><span id="l5.356">     DIR_SetStringPref(prefstring, &quot;uri&quot;, server-&gt;uri, &quot;&quot;);</span>
<a href="#l5.357"></a><span id="l5.357"> </span>
<a href="#l5.358"></a><span id="l5.358">   server-&gt;savingServer = false;</span>
<a href="#l5.359"></a><span id="l5.359"> }</span>
<a href="#l5.360"></a><span id="l5.360"> </span>
<a href="#l5.361"></a><span id="l5.361" class="difflineminus">-static void DIR_SaveServerPreferences(nsVoidArray *wholeList)</span>
<a href="#l5.362"></a><span id="l5.362" class="difflineplus">+static void DIR_SaveServerPreferences(nsTArray&lt;DIR_Server*&gt; *wholeList)</span>
<a href="#l5.363"></a><span id="l5.363"> {</span>
<a href="#l5.364"></a><span id="l5.364">   if (wholeList)</span>
<a href="#l5.365"></a><span id="l5.365">   {</span>
<a href="#l5.366"></a><span id="l5.366">     nsresult rv;</span>
<a href="#l5.367"></a><span id="l5.367">     nsCOMPtr&lt;nsIPrefBranch&gt; pPref(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv)); </span>
<a href="#l5.368"></a><span id="l5.368">     if (NS_FAILED(rv)) {</span>
<a href="#l5.369"></a><span id="l5.369">       NS_WARNING(&quot;DIR_SaveServerPreferences: Failed to get the pref service\n&quot;);</span>
<a href="#l5.370"></a><span id="l5.370">       return;</span>
<a href="#l5.371"></a><span id="l5.371">     }</span>
<a href="#l5.372"></a><span id="l5.372"> </span>
<a href="#l5.373"></a><span id="l5.373">     int32_t  i;</span>
<a href="#l5.374"></a><span id="l5.374" class="difflineminus">-    int32_t  count = wholeList-&gt;Count();</span>
<a href="#l5.375"></a><span id="l5.375" class="difflineplus">+    int32_t  count = wholeList-&gt;Length();</span>
<a href="#l5.376"></a><span id="l5.376">     DIR_Server *server;</span>
<a href="#l5.377"></a><span id="l5.377"> </span>
<a href="#l5.378"></a><span id="l5.378">     for (i = 0; i &lt; count; i++)</span>
<a href="#l5.379"></a><span id="l5.379">     {</span>
<a href="#l5.380"></a><span id="l5.380">       server = (DIR_Server *) wholeList-&gt;ElementAt(i);</span>
<a href="#l5.381"></a><span id="l5.381">       if (server)</span>
<a href="#l5.382"></a><span id="l5.382">         DIR_SavePrefsForOneServer(server);</span>
<a href="#l5.383"></a><span id="l5.383">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/addrbook/src/nsDirPrefs.h</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsDirPrefs.h</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -6,17 +6,17 @@</span>
<a href="#l6.4"></a><span id="l6.4"> #ifndef _NSDIRPREFS_H_</span>
<a href="#l6.5"></a><span id="l6.5"> #define _NSDIRPREFS_H_</span>
<a href="#l6.6"></a><span id="l6.6"> </span>
<a href="#l6.7"></a><span id="l6.7"> //</span>
<a href="#l6.8"></a><span id="l6.8"> // XXX nsDirPrefs is being greatly reduced if not removed altogether. Directory</span>
<a href="#l6.9"></a><span id="l6.9"> // Prefs etc. should be handled via their appropriate nsAb*Directory classes.</span>
<a href="#l6.10"></a><span id="l6.10"> //</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-class nsVoidArray;</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+template &lt;class&gt; class nsTArray;</span>
<a href="#l6.14"></a><span id="l6.14"> </span>
<a href="#l6.15"></a><span id="l6.15"> #define kPreviousListVersion   2</span>
<a href="#l6.16"></a><span id="l6.16"> #define kCurrentListVersion    3</span>
<a href="#l6.17"></a><span id="l6.17"> #define PREF_LDAP_GLOBAL_TREE_NAME &quot;ldap_2&quot;</span>
<a href="#l6.18"></a><span id="l6.18"> #define PREF_LDAP_VERSION_NAME     &quot;ldap_2.version&quot;</span>
<a href="#l6.19"></a><span id="l6.19"> #define PREF_LDAP_SERVER_TREE_NAME &quot;ldap_2.servers&quot;</span>
<a href="#l6.20"></a><span id="l6.20"> </span>
<a href="#l6.21"></a><span id="l6.21"> #define kMainLdapAddressBook &quot;ldap.mab&quot;   /* v3 main ldap address book file */</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineat">@@ -60,17 +60,17 @@ typedef struct DIR_Server</span>
<a href="#l6.23"></a><span id="l6.23">   bool savingServer;</span>
<a href="#l6.24"></a><span id="l6.24"> } DIR_Server;</span>
<a href="#l6.25"></a><span id="l6.25"> </span>
<a href="#l6.26"></a><span id="l6.26"> /* We are developing a new model for managing DIR_Servers. In the 4.0x world, the FEs managed each list. </span>
<a href="#l6.27"></a><span id="l6.27"> 	Calls to FE_GetDirServer caused the FEs to manage and return the DIR_Server list. In our new view of the</span>
<a href="#l6.28"></a><span id="l6.28"> 	world, the back end does most of the list management so we are going to have the back end create and </span>
<a href="#l6.29"></a><span id="l6.29"> 	manage the list. Replace calls to FE_GetDirServers() with DIR_GetDirServers(). */</span>
<a href="#l6.30"></a><span id="l6.30"> </span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-nsVoidArray* DIR_GetDirectories();</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+nsTArray&lt;DIR_Server*&gt;* DIR_GetDirectories();</span>
<a href="#l6.33"></a><span id="l6.33"> DIR_Server* DIR_GetServerFromList(const char* prefName);</span>
<a href="#l6.34"></a><span id="l6.34"> nsresult DIR_ShutDown(void);  /* FEs should call this when the app is shutting down. It frees all DIR_Servers regardless of ref count values! */</span>
<a href="#l6.35"></a><span id="l6.35"> </span>
<a href="#l6.36"></a><span id="l6.36"> nsresult DIR_AddNewAddressBook(const nsAString &amp;dirName,</span>
<a href="#l6.37"></a><span id="l6.37">                                const nsACString &amp;fileName,</span>
<a href="#l6.38"></a><span id="l6.38">                                const nsACString &amp;uri, </span>
<a href="#l6.39"></a><span id="l6.39">                                DirectoryType dirType,</span>
<a href="#l6.40"></a><span id="l6.40">                                const nsACString &amp;prefName,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -44,17 +44,17 @@</span>
<a href="#l7.4"></a><span id="l7.4"> #include &quot;nsComponentManagerUtils.h&quot;</span>
<a href="#l7.5"></a><span id="l7.5"> #include &quot;nsMemory.h&quot;</span>
<a href="#l7.6"></a><span id="l7.6"> #include &quot;nsAlgorithm.h&quot;</span>
<a href="#l7.7"></a><span id="l7.7"> #include &quot;nsIAbManager.h&quot;</span>
<a href="#l7.8"></a><span id="l7.8"> #include &quot;nsIAbDirectory.h&quot;</span>
<a href="#l7.9"></a><span id="l7.9"> #include &quot;nsIAbCard.h&quot;</span>
<a href="#l7.10"></a><span id="l7.10"> #include &quot;mozilla/Services.h&quot;</span>
<a href="#l7.11"></a><span id="l7.11"> #include &quot;mozilla/mailnews/MimeHeaderParser.h&quot;</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l7.14"></a><span id="l7.14"> #include &lt;algorithm&gt;</span>
<a href="#l7.15"></a><span id="l7.15"> </span>
<a href="#l7.16"></a><span id="l7.16"> using namespace mozilla::mailnews;</span>
<a href="#l7.17"></a><span id="l7.17"> nsrefcnt nsMsgDBView::gInstanceCount  = 0;</span>
<a href="#l7.18"></a><span id="l7.18"> </span>
<a href="#l7.19"></a><span id="l7.19"> nsIAtom * nsMsgDBView::kJunkMsgAtom = nullptr;</span>
<a href="#l7.20"></a><span id="l7.20"> nsIAtom * nsMsgDBView::kNotJunkMsgAtom = nullptr;</span>
<a href="#l7.21"></a><span id="l7.21"> </span>
<a href="#l7.22"></a><span id="l7.22" class="difflineat">@@ -4468,17 +4468,17 @@ NS_IMETHODIMP nsMsgDBView::Sort(nsMsgVie</span>
<a href="#l7.23"></a><span id="l7.23">   // If we did not obtain proper fieldType, it needs to be checked</span>
<a href="#l7.24"></a><span id="l7.24">   // because the subsequent code does not handle it very well.</span>
<a href="#l7.25"></a><span id="l7.25">   rv = GetFieldTypeAndLenForSort(sortType, &amp;maxLen, &amp;fieldType);</span>
<a href="#l7.26"></a><span id="l7.26"> </span>
<a href="#l7.27"></a><span id="l7.27">   // Don't sort if the field type is not supported: Bug 901948</span>
<a href="#l7.28"></a><span id="l7.28">   if (NS_FAILED(rv))</span>
<a href="#l7.29"></a><span id="l7.29">     return NS_OK;</span>
<a href="#l7.30"></a><span id="l7.30"> </span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-  nsVoidArray ptrs;</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+  nsTArray&lt;void*&gt; ptrs;</span>
<a href="#l7.33"></a><span id="l7.33">   uint32_t arraySize = GetSize();</span>
<a href="#l7.34"></a><span id="l7.34"> </span>
<a href="#l7.35"></a><span id="l7.35">   if (!arraySize)</span>
<a href="#l7.36"></a><span id="l7.36">     return NS_OK;</span>
<a href="#l7.37"></a><span id="l7.37"> </span>
<a href="#l7.38"></a><span id="l7.38">   nsCOMArray&lt;nsIMsgFolder&gt; *folders = GetFolders();</span>
<a href="#l7.39"></a><span id="l7.39"> </span>
<a href="#l7.40"></a><span id="l7.40">   IdKey** pPtrBase = (IdKey**)PR_Malloc(arraySize * sizeof(IdKey*));</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineat">@@ -4640,20 +4640,20 @@ NS_IMETHODIMP nsMsgDBView::Sort(nsMsgVie</span>
<a href="#l7.42"></a><span id="l7.42">   FreeAll(&amp;ptrs);</span>
<a href="#l7.43"></a><span id="l7.43"> </span>
<a href="#l7.44"></a><span id="l7.44">   m_sortValid = true;</span>
<a href="#l7.45"></a><span id="l7.45">   //m_db-&gt;SetSortInfo(sortType, sortOrder);</span>
<a href="#l7.46"></a><span id="l7.46"> </span>
<a href="#l7.47"></a><span id="l7.47">   return NS_OK;</span>
<a href="#l7.48"></a><span id="l7.48"> }</span>
<a href="#l7.49"></a><span id="l7.49"> </span>
<a href="#l7.50"></a><span id="l7.50" class="difflineminus">-void nsMsgDBView::FreeAll(nsVoidArray *ptrs)</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+void nsMsgDBView::FreeAll(nsTArray&lt;void*&gt; *ptrs)</span>
<a href="#l7.52"></a><span id="l7.52"> {</span>
<a href="#l7.53"></a><span id="l7.53">   int32_t i;</span>
<a href="#l7.54"></a><span id="l7.54" class="difflineminus">-  int32_t count = (int32_t) ptrs-&gt;Count();</span>
<a href="#l7.55"></a><span id="l7.55" class="difflineplus">+  int32_t count = (int32_t) ptrs-&gt;Length();</span>
<a href="#l7.56"></a><span id="l7.56">   if (count == 0)</span>
<a href="#l7.57"></a><span id="l7.57">     return;</span>
<a href="#l7.58"></a><span id="l7.58"> </span>
<a href="#l7.59"></a><span id="l7.59">   for (i=(count - 1);i&gt;=0;i--)</span>
<a href="#l7.60"></a><span id="l7.60">     PR_Free((void *) ptrs-&gt;ElementAt(i));</span>
<a href="#l7.61"></a><span id="l7.61">   ptrs-&gt;Clear();</span>
<a href="#l7.62"></a><span id="l7.62"> }</span>
<a href="#l7.63"></a><span id="l7.63"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.h</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.h</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -31,18 +31,16 @@</span>
<a href="#l8.4"></a><span id="l8.4"> #include &quot;nsTArray.h&quot;</span>
<a href="#l8.5"></a><span id="l8.5"> #include &quot;nsTHashtable.h&quot;</span>
<a href="#l8.6"></a><span id="l8.6"> #include &quot;nsHashKeys.h&quot;</span>
<a href="#l8.7"></a><span id="l8.7"> #include &quot;nsIMsgCustomColumnHandler.h&quot;</span>
<a href="#l8.8"></a><span id="l8.8"> #include &quot;nsAutoPtr.h&quot;</span>
<a href="#l8.9"></a><span id="l8.9"> #include &quot;nsIWeakReferenceUtils.h&quot;</span>
<a href="#l8.10"></a><span id="l8.10"> #define MESSENGER_STRING_URL       &quot;chrome://messenger/locale/messenger.properties&quot;</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-class nsVoidArray;</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">-</span>
<a href="#l8.14"></a><span id="l8.14"> typedef nsAutoTArray&lt;nsMsgViewIndex, 1&gt; nsMsgViewIndexArray;</span>
<a href="#l8.15"></a><span id="l8.15"> static_assert(nsMsgViewIndex(nsMsgViewIndexArray::NoIndex) ==</span>
<a href="#l8.16"></a><span id="l8.16">   nsMsgViewIndex_None, &quot;These need to be the same value.&quot;);</span>
<a href="#l8.17"></a><span id="l8.17"> </span>
<a href="#l8.18"></a><span id="l8.18"> enum eFieldType {</span>
<a href="#l8.19"></a><span id="l8.19">     kCollationKey,</span>
<a href="#l8.20"></a><span id="l8.20">     kU32</span>
<a href="#l8.21"></a><span id="l8.21"> };</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineat">@@ -361,17 +359,17 @@ protected:</span>
<a href="#l8.23"></a><span id="l8.23">   nsresult CopyDBView(nsMsgDBView *aNewMsgDBView, nsIMessenger *aMessengerInstance, nsIMsgWindow *aMsgWindow, nsIMsgDBViewCommandUpdater *aCmdUpdater);</span>
<a href="#l8.24"></a><span id="l8.24">   void InitializeAtomsAndLiterals();</span>
<a href="#l8.25"></a><span id="l8.25">   virtual int32_t FindLevelInThread(nsIMsgDBHdr *msgHdr, nsMsgViewIndex startOfThread, nsMsgViewIndex viewIndex);</span>
<a href="#l8.26"></a><span id="l8.26">   nsresult GetImapDeleteModel(nsIMsgFolder *folder);</span>
<a href="#l8.27"></a><span id="l8.27">   nsresult UpdateDisplayMessage(nsMsgViewIndex viewPosition);</span>
<a href="#l8.28"></a><span id="l8.28">   nsresult GetDBForHeader(nsIMsgDBHdr *msgHdr, nsIMsgDatabase **db);</span>
<a href="#l8.29"></a><span id="l8.29"> </span>
<a href="#l8.30"></a><span id="l8.30">   bool AdjustReadFlag(nsIMsgDBHdr *msgHdr, uint32_t *msgFlags);</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineminus">-  void FreeAll(nsVoidArray *ptrs);</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+  void FreeAll(nsTArray&lt;void*&gt; *ptrs);</span>
<a href="#l8.33"></a><span id="l8.33">   void ClearHdrCache();</span>
<a href="#l8.34"></a><span id="l8.34">   nsTArray&lt;nsMsgKey&gt; m_keys;</span>
<a href="#l8.35"></a><span id="l8.35">   nsTArray&lt;uint32_t&gt; m_flags;</span>
<a href="#l8.36"></a><span id="l8.36">   nsTArray&lt;uint8_t&gt; m_levels;</span>
<a href="#l8.37"></a><span id="l8.37">   nsMsgImapDeleteModel mDeleteModel;</span>
<a href="#l8.38"></a><span id="l8.38"> </span>
<a href="#l8.39"></a><span id="l8.39">   // cache the most recently asked for header and corresponding msgKey.</span>
<a href="#l8.40"></a><span id="l8.40">   nsCOMPtr &lt;nsIMsgDBHdr&gt;  m_cachedHdr;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPBodyShell.cpp</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPBodyShell.cpp</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -758,19 +758,19 @@ bool nsIMAPBodypartLeaf::ShouldFetchInli</span>
<a href="#l9.4"></a><span id="l9.4"> }</span>
<a href="#l9.5"></a><span id="l9.5"> </span>
<a href="#l9.6"></a><span id="l9.6"> </span>
<a href="#l9.7"></a><span id="l9.7"> </span>
<a href="#l9.8"></a><span id="l9.8"> bool nsIMAPBodypartMultipart::IsLastTextPart(const char *partNumberString)</span>
<a href="#l9.9"></a><span id="l9.9"> {</span>
<a href="#l9.10"></a><span id="l9.10">  // iterate backwards over the parent's part list and if the part is</span>
<a href="#l9.11"></a><span id="l9.11">   // text, compare it to the part number string</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-  for (int i = m_partList-&gt;Count() - 1; i &gt;= 0; i--)</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+  for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--)</span>
<a href="#l9.14"></a><span id="l9.14">   {</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineminus">-      nsIMAPBodypart *part = (nsIMAPBodypart *)(m_partList-&gt;ElementAt(i));</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+      nsIMAPBodypart *part = m_partList-&gt;ElementAt(i);</span>
<a href="#l9.17"></a><span id="l9.17">       if (!PL_strcasecmp(part-&gt;GetBodyType(), &quot;text&quot;))</span>
<a href="#l9.18"></a><span id="l9.18">         return !PL_strcasecmp(part-&gt;GetPartNumberString(), partNumberString);</span>
<a href="#l9.19"></a><span id="l9.19">   }</span>
<a href="#l9.20"></a><span id="l9.20">   return false;</span>
<a href="#l9.21"></a><span id="l9.21"> }</span>
<a href="#l9.22"></a><span id="l9.22"> </span>
<a href="#l9.23"></a><span id="l9.23"> bool nsIMAPBodypartLeaf::PreflightCheckAllInline(nsIMAPBodyShell *aShell)</span>
<a href="#l9.24"></a><span id="l9.24"> {</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineat">@@ -952,34 +952,34 @@ nsIMAPBodypart(partNum, parentPart)</span>
<a href="#l9.26"></a><span id="l9.26">     PR_FREEIF(m_partNumberString);</span>
<a href="#l9.27"></a><span id="l9.27">     if (!m_parentPart)</span>
<a href="#l9.28"></a><span id="l9.28">     {</span>
<a href="#l9.29"></a><span id="l9.29">       m_partNumberString = PR_smprintf(&quot;0&quot;);</span>
<a href="#l9.30"></a><span id="l9.30">     }</span>
<a href="#l9.31"></a><span id="l9.31">     else</span>
<a href="#l9.32"></a><span id="l9.32">       m_partNumberString = NS_strdup(m_parentPart-&gt;GetPartNumberString());</span>
<a href="#l9.33"></a><span id="l9.33">   }</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineminus">-  m_partList = new nsVoidArray();</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineplus">+  m_partList = new nsTArray&lt;nsIMAPBodypart*&gt;();</span>
<a href="#l9.36"></a><span id="l9.36">   m_bodyType = NS_strdup(&quot;multipart&quot;);</span>
<a href="#l9.37"></a><span id="l9.37">   if (m_partList &amp;&amp; m_parentPart &amp;&amp; m_bodyType)</span>
<a href="#l9.38"></a><span id="l9.38">     SetIsValid(true);</span>
<a href="#l9.39"></a><span id="l9.39">   else</span>
<a href="#l9.40"></a><span id="l9.40">     SetIsValid(false);</span>
<a href="#l9.41"></a><span id="l9.41"> }</span>
<a href="#l9.42"></a><span id="l9.42"> </span>
<a href="#l9.43"></a><span id="l9.43"> nsIMAPBodypartType nsIMAPBodypartMultipart::GetType()</span>
<a href="#l9.44"></a><span id="l9.44"> {</span>
<a href="#l9.45"></a><span id="l9.45">   return IMAP_BODY_MULTIPART;</span>
<a href="#l9.46"></a><span id="l9.46"> }</span>
<a href="#l9.47"></a><span id="l9.47"> </span>
<a href="#l9.48"></a><span id="l9.48"> nsIMAPBodypartMultipart::~nsIMAPBodypartMultipart()</span>
<a href="#l9.49"></a><span id="l9.49"> {</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineminus">-  for (int i = m_partList-&gt;Count() - 1; i &gt;= 0; i--)</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineplus">+  for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--)</span>
<a href="#l9.52"></a><span id="l9.52">   {</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineminus">-    delete (nsIMAPBodypart *)(m_partList-&gt;ElementAt(i));</span>
<a href="#l9.54"></a><span id="l9.54" class="difflineplus">+    delete m_partList-&gt;ElementAt(i);</span>
<a href="#l9.55"></a><span id="l9.55">   }</span>
<a href="#l9.56"></a><span id="l9.56">   delete m_partList;</span>
<a href="#l9.57"></a><span id="l9.57"> }</span>
<a href="#l9.58"></a><span id="l9.58"> </span>
<a href="#l9.59"></a><span id="l9.59"> void</span>
<a href="#l9.60"></a><span id="l9.60"> nsIMAPBodypartMultipart::SetBodySubType(char *bodySubType)</span>
<a href="#l9.61"></a><span id="l9.61"> {</span>
<a href="#l9.62"></a><span id="l9.62">   PR_FREEIF(m_bodySubType);</span>
<a href="#l9.63"></a><span id="l9.63" class="difflineat">@@ -1008,22 +1008,22 @@ int32_t nsIMAPBodypartMultipart::Generat</span>
<a href="#l9.64"></a><span id="l9.64">     bool needMIMEHeader = !parentIsMessageType;  // !PL_strcasecmp(m_bodySubType, &quot;signed&quot;) ? true : !parentIsMessageType;</span>
<a href="#l9.65"></a><span id="l9.65">     if (needMIMEHeader &amp;&amp; !aShell-&gt;GetPseudoInterrupted())  // not a message body's type</span>
<a href="#l9.66"></a><span id="l9.66">     {</span>
<a href="#l9.67"></a><span id="l9.67">       len += GenerateMIMEHeader(aShell, stream, prefetch);</span>
<a href="#l9.68"></a><span id="l9.68">     }</span>
<a href="#l9.69"></a><span id="l9.69">     </span>
<a href="#l9.70"></a><span id="l9.70">     if (ShouldFetchInline(aShell))</span>
<a href="#l9.71"></a><span id="l9.71">     {</span>
<a href="#l9.72"></a><span id="l9.72" class="difflineminus">-      for (int i = 0; i &lt; m_partList-&gt;Count(); i++)</span>
<a href="#l9.73"></a><span id="l9.73" class="difflineplus">+      for (int i = 0; i &lt; m_partList-&gt;Length(); i++)</span>
<a href="#l9.74"></a><span id="l9.74">       {</span>
<a href="#l9.75"></a><span id="l9.75">         if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l9.76"></a><span id="l9.76">           len += GenerateBoundary(aShell, stream, prefetch, false);</span>
<a href="#l9.77"></a><span id="l9.77">         if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l9.78"></a><span id="l9.78" class="difflineminus">-          len += ((nsIMAPBodypart *)(m_partList-&gt;ElementAt(i)))-&gt;Generate(aShell, stream, prefetch);</span>
<a href="#l9.79"></a><span id="l9.79" class="difflineplus">+          len += m_partList-&gt;ElementAt(i)-&gt;Generate(aShell, stream, prefetch);</span>
<a href="#l9.80"></a><span id="l9.80">       }</span>
<a href="#l9.81"></a><span id="l9.81">       if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l9.82"></a><span id="l9.82">         len += GenerateBoundary(aShell, stream, prefetch, true);</span>
<a href="#l9.83"></a><span id="l9.83">     }</span>
<a href="#l9.84"></a><span id="l9.84">     else</span>
<a href="#l9.85"></a><span id="l9.85">     {</span>
<a href="#l9.86"></a><span id="l9.86">       // fill in the filling within the empty part</span>
<a href="#l9.87"></a><span id="l9.87">       if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l9.88"></a><span id="l9.88" class="difflineat">@@ -1082,37 +1082,37 @@ bool nsIMAPBodypartMultipart::ShouldFetc</span>
<a href="#l9.89"></a><span id="l9.89">   }</span>
<a href="#l9.90"></a><span id="l9.90"> }</span>
<a href="#l9.91"></a><span id="l9.91"> </span>
<a href="#l9.92"></a><span id="l9.92"> bool nsIMAPBodypartMultipart::PreflightCheckAllInline(nsIMAPBodyShell *aShell)</span>
<a href="#l9.93"></a><span id="l9.93"> {</span>
<a href="#l9.94"></a><span id="l9.94">   bool rv = ShouldFetchInline(aShell);</span>
<a href="#l9.95"></a><span id="l9.95">   </span>
<a href="#l9.96"></a><span id="l9.96">   int i = 0;</span>
<a href="#l9.97"></a><span id="l9.97" class="difflineminus">-  while (rv &amp;&amp; (i &lt; m_partList-&gt;Count()))</span>
<a href="#l9.98"></a><span id="l9.98" class="difflineplus">+  while (rv &amp;&amp; (i &lt; m_partList-&gt;Length()))</span>
<a href="#l9.99"></a><span id="l9.99">   {</span>
<a href="#l9.100"></a><span id="l9.100" class="difflineminus">-    rv = ((nsIMAPBodypart *)(m_partList-&gt;ElementAt(i)))-&gt;PreflightCheckAllInline(aShell);</span>
<a href="#l9.101"></a><span id="l9.101" class="difflineplus">+    rv = m_partList-&gt;ElementAt(i)-&gt;PreflightCheckAllInline(aShell);</span>
<a href="#l9.102"></a><span id="l9.102">     i++;</span>
<a href="#l9.103"></a><span id="l9.103">   }</span>
<a href="#l9.104"></a><span id="l9.104">   </span>
<a href="#l9.105"></a><span id="l9.105">   return rv;</span>
<a href="#l9.106"></a><span id="l9.106"> }</span>
<a href="#l9.107"></a><span id="l9.107"> </span>
<a href="#l9.108"></a><span id="l9.108"> nsIMAPBodypart	*nsIMAPBodypartMultipart::FindPartWithNumber(const char *partNum)</span>
<a href="#l9.109"></a><span id="l9.109"> {</span>
<a href="#l9.110"></a><span id="l9.110">   NS_ASSERTION(partNum, &quot;null part passed into FindPartWithNumber&quot;);</span>
<a href="#l9.111"></a><span id="l9.111">   </span>
<a href="#l9.112"></a><span id="l9.112">   // check this</span>
<a href="#l9.113"></a><span id="l9.113">   if (!PL_strcmp(partNum, m_partNumberString))</span>
<a href="#l9.114"></a><span id="l9.114">     return this;</span>
<a href="#l9.115"></a><span id="l9.115">   </span>
<a href="#l9.116"></a><span id="l9.116">   // check children</span>
<a href="#l9.117"></a><span id="l9.117" class="difflineminus">-  for (int i = m_partList-&gt;Count() - 1; i &gt;= 0; i--)</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineplus">+  for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--)</span>
<a href="#l9.119"></a><span id="l9.119">   {</span>
<a href="#l9.120"></a><span id="l9.120" class="difflineminus">-    nsIMAPBodypart *foundPart = ((nsIMAPBodypart *)(m_partList-&gt;ElementAt(i)))-&gt;FindPartWithNumber(partNum);</span>
<a href="#l9.121"></a><span id="l9.121" class="difflineplus">+    nsIMAPBodypart *foundPart = m_partList-&gt;ElementAt(i)-&gt;FindPartWithNumber(partNum);</span>
<a href="#l9.122"></a><span id="l9.122">     if (foundPart)</span>
<a href="#l9.123"></a><span id="l9.123">       return foundPart;</span>
<a href="#l9.124"></a><span id="l9.124">   }</span>
<a href="#l9.125"></a><span id="l9.125">   </span>
<a href="#l9.126"></a><span id="l9.126">   // not this, or any of this's children</span>
<a href="#l9.127"></a><span id="l9.127">   return NULL;</span>
<a href="#l9.128"></a><span id="l9.128"> }</span>
<a href="#l9.129"></a><span id="l9.129"> </span>
<a href="#l9.130"></a><span id="l9.130" class="difflineat">@@ -1196,17 +1196,17 @@ imap_shell_cache_strcmp (const void *a, </span>
<a href="#l9.131"></a><span id="l9.131"> {</span>
<a href="#l9.132"></a><span id="l9.132">   return PL_strcmp ((const char *) a, (const char *) b);</span>
<a href="#l9.133"></a><span id="l9.133"> }</span>
<a href="#l9.134"></a><span id="l9.134"> #endif</span>
<a href="#l9.135"></a><span id="l9.135"> </span>
<a href="#l9.136"></a><span id="l9.136"> nsIMAPBodyShellCache::nsIMAPBodyShellCache()</span>
<a href="#l9.137"></a><span id="l9.137"> : m_shellHash(20)</span>
<a href="#l9.138"></a><span id="l9.138"> {</span>
<a href="#l9.139"></a><span id="l9.139" class="difflineminus">-  m_shellList = new nsVoidArray();</span>
<a href="#l9.140"></a><span id="l9.140" class="difflineplus">+  m_shellList = new nsTArray&lt;nsIMAPBodyShell*&gt;();</span>
<a href="#l9.141"></a><span id="l9.141"> }</span>
<a href="#l9.142"></a><span id="l9.142"> </span>
<a href="#l9.143"></a><span id="l9.143"> /* static */ nsIMAPBodyShellCache *nsIMAPBodyShellCache::Create()</span>
<a href="#l9.144"></a><span id="l9.144"> {</span>
<a href="#l9.145"></a><span id="l9.145">   nsIMAPBodyShellCache *cache = new nsIMAPBodyShellCache();</span>
<a href="#l9.146"></a><span id="l9.146">   if (!cache || !cache-&gt;m_shellList)</span>
<a href="#l9.147"></a><span id="l9.147">     return NULL;</span>
<a href="#l9.148"></a><span id="l9.148">   </span>
<a href="#l9.149"></a><span id="l9.149" class="difflineat">@@ -1219,20 +1219,20 @@ nsIMAPBodyShellCache::~nsIMAPBodyShellCa</span>
<a href="#l9.150"></a><span id="l9.150">   delete m_shellList;</span>
<a href="#l9.151"></a><span id="l9.151"> }</span>
<a href="#l9.152"></a><span id="l9.152"> </span>
<a href="#l9.153"></a><span id="l9.153"> // We'll use an LRU scheme here.</span>
<a href="#l9.154"></a><span id="l9.154"> // We will add shells in numerical order, so the</span>
<a href="#l9.155"></a><span id="l9.155"> // least recently used one will be in slot 0.</span>
<a href="#l9.156"></a><span id="l9.156"> bool nsIMAPBodyShellCache::EjectEntry()</span>
<a href="#l9.157"></a><span id="l9.157"> {</span>
<a href="#l9.158"></a><span id="l9.158" class="difflineminus">-  if (m_shellList-&gt;Count() &lt; 1)</span>
<a href="#l9.159"></a><span id="l9.159" class="difflineplus">+  if (m_shellList-&gt;Length() &lt; 1)</span>
<a href="#l9.160"></a><span id="l9.160">     return false;</span>
<a href="#l9.161"></a><span id="l9.161"> </span>
<a href="#l9.162"></a><span id="l9.162" class="difflineminus">-  nsIMAPBodyShell *removedShell = (nsIMAPBodyShell *) (m_shellList-&gt;ElementAt(0));</span>
<a href="#l9.163"></a><span id="l9.163" class="difflineplus">+  nsIMAPBodyShell *removedShell = m_shellList-&gt;ElementAt(0);</span>
<a href="#l9.164"></a><span id="l9.164"> </span>
<a href="#l9.165"></a><span id="l9.165">   m_shellList-&gt;RemoveElementAt(0);</span>
<a href="#l9.166"></a><span id="l9.166">   m_shellHash.Remove(removedShell-&gt;GetUID());</span>
<a href="#l9.167"></a><span id="l9.167"> </span>
<a href="#l9.168"></a><span id="l9.168">   return true;</span>
<a href="#l9.169"></a><span id="l9.169"> }</span>
<a href="#l9.170"></a><span id="l9.170"> </span>
<a href="#l9.171"></a><span id="l9.171"> void nsIMAPBodyShellCache::Clear()</span>
<a href="#l9.172"></a><span id="l9.172" class="difflineat">@@ -1318,16 +1318,16 @@ nsIMAPMessagePartIDArray::nsIMAPMessageP</span>
<a href="#l9.173"></a><span id="l9.173"> </span>
<a href="#l9.174"></a><span id="l9.174"> nsIMAPMessagePartIDArray::~nsIMAPMessagePartIDArray()</span>
<a href="#l9.175"></a><span id="l9.175"> {</span>
<a href="#l9.176"></a><span id="l9.176"> 	RemoveAndFreeAll();</span>
<a href="#l9.177"></a><span id="l9.177"> }</span>
<a href="#l9.178"></a><span id="l9.178"> </span>
<a href="#l9.179"></a><span id="l9.179"> void nsIMAPMessagePartIDArray::RemoveAndFreeAll()</span>
<a href="#l9.180"></a><span id="l9.180"> {</span>
<a href="#l9.181"></a><span id="l9.181" class="difflineminus">-    int n = Count();</span>
<a href="#l9.182"></a><span id="l9.182" class="difflineplus">+    int n = Length();</span>
<a href="#l9.183"></a><span id="l9.183"> 	for (int i = 0; i &lt; n; i++)</span>
<a href="#l9.184"></a><span id="l9.184"> 	{</span>
<a href="#l9.185"></a><span id="l9.185"> 		nsIMAPMessagePartID *part = GetPart(i);</span>
<a href="#l9.186"></a><span id="l9.186"> 		delete part;</span>
<a href="#l9.187"></a><span id="l9.187"> 	}</span>
<a href="#l9.188"></a><span id="l9.188">     Clear();</span>
<a href="#l9.189"></a><span id="l9.189"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPBodyShell.h</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPBodyShell.h</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -9,17 +9,17 @@ nsIMAPBodyShell and associated classes</span>
<a href="#l10.4"></a><span id="l10.4"> </span>
<a href="#l10.5"></a><span id="l10.5"> #ifndef IMAPBODY_H</span>
<a href="#l10.6"></a><span id="l10.6"> #define IMAPBODY_H</span>
<a href="#l10.7"></a><span id="l10.7"> </span>
<a href="#l10.8"></a><span id="l10.8"> #include &quot;mozilla/Attributes.h&quot;</span>
<a href="#l10.9"></a><span id="l10.9"> #include &quot;nsImapCore.h&quot;</span>
<a href="#l10.10"></a><span id="l10.10"> #include &quot;nsStringGlue.h&quot;</span>
<a href="#l10.11"></a><span id="l10.11"> #include &quot;nsRefPtrHashtable.h&quot;</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l10.14"></a><span id="l10.14"> </span>
<a href="#l10.15"></a><span id="l10.15"> class nsImapProtocol;</span>
<a href="#l10.16"></a><span id="l10.16"> </span>
<a href="#l10.17"></a><span id="l10.17"> typedef enum _nsIMAPBodypartType {</span>
<a href="#l10.18"></a><span id="l10.18"> 	IMAP_BODY_MESSAGE_RFC822,</span>
<a href="#l10.19"></a><span id="l10.19"> 	IMAP_BODY_MESSAGE_HEADER,</span>
<a href="#l10.20"></a><span id="l10.20"> 	IMAP_BODY_LEAF,</span>
<a href="#l10.21"></a><span id="l10.21"> 	IMAP_BODY_MULTIPART</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineat">@@ -138,17 +138,17 @@ public:</span>
<a href="#l10.23"></a><span id="l10.23">     // Returns the part object with the given number</span>
<a href="#l10.24"></a><span id="l10.24"> 	virtual nsIMAPBodypart	*FindPartWithNumber(const char *partNum</span>
<a href="#l10.25"></a><span id="l10.25">                                                 ) override;</span>
<a href="#l10.26"></a><span id="l10.26">     virtual bool IsLastTextPart(const char *partNumberString) override;</span>
<a href="#l10.27"></a><span id="l10.27">     void AppendPart(nsIMAPBodypart *part)  { m_partList-&gt;AppendElement(part); }</span>
<a href="#l10.28"></a><span id="l10.28">     void SetBodySubType(char *bodySubType);</span>
<a href="#l10.29"></a><span id="l10.29"> </span>
<a href="#l10.30"></a><span id="l10.30"> protected:</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineminus">-	nsVoidArray			*m_partList;			// An ordered list of top-level body parts for this shell</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+    nsTArray&lt;nsIMAPBodypart*&gt;  *m_partList;  // An ordered list of top-level body parts for this shell</span>
<a href="#l10.33"></a><span id="l10.33"> };</span>
<a href="#l10.34"></a><span id="l10.34"> </span>
<a href="#l10.35"></a><span id="l10.35"> </span>
<a href="#l10.36"></a><span id="l10.36"> // The name &quot;leaf&quot; is somewhat misleading, since a part of type message/rfc822 is technically</span>
<a href="#l10.37"></a><span id="l10.37"> // a leaf, even though it can contain other parts within it.</span>
<a href="#l10.38"></a><span id="l10.38"> class nsIMAPBodypartLeaf : public nsIMAPBodypart</span>
<a href="#l10.39"></a><span id="l10.39"> {</span>
<a href="#l10.40"></a><span id="l10.40"> public:</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineat">@@ -316,19 +316,19 @@ public:</span>
<a href="#l10.42"></a><span id="l10.42">   void Clear();</span>
<a href="#l10.43"></a><span id="l10.43"> </span>
<a href="#l10.44"></a><span id="l10.44"> protected:</span>
<a href="#l10.45"></a><span id="l10.45">   nsIMAPBodyShellCache();</span>
<a href="#l10.46"></a><span id="l10.46">   // Chooses an entry to eject;  deletes that entry;  and ejects it from the</span>
<a href="#l10.47"></a><span id="l10.47">   // cache, clearing up a new space.  Returns true if it found an entry</span>
<a href="#l10.48"></a><span id="l10.48">   // to eject, false otherwise.</span>
<a href="#l10.49"></a><span id="l10.49">   bool EjectEntry();</span>
<a href="#l10.50"></a><span id="l10.50" class="difflineminus">-  uint32_t GetSize() { return m_shellList-&gt;Count(); }</span>
<a href="#l10.51"></a><span id="l10.51" class="difflineplus">+  uint32_t GetSize() { return m_shellList-&gt;Length(); }</span>
<a href="#l10.52"></a><span id="l10.52">   uint32_t GetMaxSize() { return 20; }</span>
<a href="#l10.53"></a><span id="l10.53" class="difflineminus">-  nsVoidArray *m_shellList; // For maintenance</span>
<a href="#l10.54"></a><span id="l10.54" class="difflineplus">+  nsTArray&lt;nsIMAPBodyShell*&gt; *m_shellList; // For maintenance</span>
<a href="#l10.55"></a><span id="l10.55">   // For quick lookup based on UID</span>
<a href="#l10.56"></a><span id="l10.56">   nsRefPtrHashtable &lt;nsCStringHashKey, nsIMAPBodyShell&gt; m_shellHash;</span>
<a href="#l10.57"></a><span id="l10.57"> };</span>
<a href="#l10.58"></a><span id="l10.58"> </span>
<a href="#l10.59"></a><span id="l10.59"> // MessagePartID and MessagePartIDArray are used for pipelining prefetches.</span>
<a href="#l10.60"></a><span id="l10.60"> </span>
<a href="#l10.61"></a><span id="l10.61"> class nsIMAPMessagePartID</span>
<a href="#l10.62"></a><span id="l10.62"> {</span>
<a href="#l10.63"></a><span id="l10.63" class="difflineat">@@ -339,24 +339,24 @@ public:</span>
<a href="#l10.64"></a><span id="l10.64"> </span>
<a href="#l10.65"></a><span id="l10.65"> </span>
<a href="#l10.66"></a><span id="l10.66"> protected:</span>
<a href="#l10.67"></a><span id="l10.67"> 	const char *m_partNumberString;</span>
<a href="#l10.68"></a><span id="l10.68"> 	nsIMAPeFetchFields m_fields;</span>
<a href="#l10.69"></a><span id="l10.69"> };</span>
<a href="#l10.70"></a><span id="l10.70"> </span>
<a href="#l10.71"></a><span id="l10.71"> </span>
<a href="#l10.72"></a><span id="l10.72" class="difflineminus">-class nsIMAPMessagePartIDArray : public nsVoidArray {</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineplus">+class nsIMAPMessagePartIDArray : public nsTArray&lt;nsIMAPMessagePartID*&gt; {</span>
<a href="#l10.74"></a><span id="l10.74"> public:</span>
<a href="#l10.75"></a><span id="l10.75"> 	nsIMAPMessagePartIDArray();</span>
<a href="#l10.76"></a><span id="l10.76"> 	~nsIMAPMessagePartIDArray();</span>
<a href="#l10.77"></a><span id="l10.77"> </span>
<a href="#l10.78"></a><span id="l10.78"> 	void				RemoveAndFreeAll();</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineminus">-	int					GetNumParts() {return Count();}</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineplus">+	int					GetNumParts() {return Length();}</span>
<a href="#l10.81"></a><span id="l10.81"> 	nsIMAPMessagePartID	*GetPart(int i) </span>
<a href="#l10.82"></a><span id="l10.82"> 	{</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineminus">-		NS_ASSERTION(i &gt;= 0 &amp;&amp; i &lt; Count(), &quot;invalid message part #&quot;);</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineminus">-		return (nsIMAPMessagePartID *) ElementAt(i);</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineplus">+		NS_ASSERTION(i &gt;= 0 &amp;&amp; i &lt; Length(), &quot;invalid message part #&quot;);</span>
<a href="#l10.86"></a><span id="l10.86" class="difflineplus">+		return ElementAt(i);</span>
<a href="#l10.87"></a><span id="l10.87"> 	}</span>
<a href="#l10.88"></a><span id="l10.88"> };</span>
<a href="#l10.89"></a><span id="l10.89"> </span>
<a href="#l10.90"></a><span id="l10.90"> </span>
<a href="#l10.91"></a><span id="l10.91"> #endif // IMAPBODY_H</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPNamespace.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPNamespace.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -66,17 +66,17 @@ nsIMAPNamespaceList *nsIMAPNamespaceList</span>
<a href="#l11.4"></a><span id="l11.4"> }</span>
<a href="#l11.5"></a><span id="l11.5"> </span>
<a href="#l11.6"></a><span id="l11.6"> nsIMAPNamespaceList::nsIMAPNamespaceList()</span>
<a href="#l11.7"></a><span id="l11.7"> {</span>
<a href="#l11.8"></a><span id="l11.8"> }</span>
<a href="#l11.9"></a><span id="l11.9"> </span>
<a href="#l11.10"></a><span id="l11.10"> int nsIMAPNamespaceList::GetNumberOfNamespaces()</span>
<a href="#l11.11"></a><span id="l11.11"> {</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-	return m_NamespaceList.Count();</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+	return m_NamespaceList.Length();</span>
<a href="#l11.14"></a><span id="l11.14"> }</span>
<a href="#l11.15"></a><span id="l11.15"> </span>
<a href="#l11.16"></a><span id="l11.16"> </span>
<a href="#l11.17"></a><span id="l11.17"> nsresult nsIMAPNamespaceList::InitFromString(const char *nameSpaceString, EIMAPNamespaceType nstype)</span>
<a href="#l11.18"></a><span id="l11.18"> {</span>
<a href="#l11.19"></a><span id="l11.19"> 	nsresult rv = NS_OK;</span>
<a href="#l11.20"></a><span id="l11.20"> 	if (nameSpaceString)</span>
<a href="#l11.21"></a><span id="l11.21"> 	{</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineat">@@ -109,17 +109,17 @@ nsresult nsIMAPNamespaceList::OutputToSt</span>
<a href="#l11.23"></a><span id="l11.23"> </span>
<a href="#l11.24"></a><span id="l11.24"> 	return rv;</span>
<a href="#l11.25"></a><span id="l11.25"> }</span>
<a href="#l11.26"></a><span id="l11.26"> </span>
<a href="#l11.27"></a><span id="l11.27"> </span>
<a href="#l11.28"></a><span id="l11.28"> int nsIMAPNamespaceList::GetNumberOfNamespaces(EIMAPNamespaceType type)</span>
<a href="#l11.29"></a><span id="l11.29"> {</span>
<a href="#l11.30"></a><span id="l11.30"> 	int nodeIndex = 0, count = 0;</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineminus">-	for (nodeIndex=m_NamespaceList.Count()-1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+	for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l11.33"></a><span id="l11.33"> 	{</span>
<a href="#l11.34"></a><span id="l11.34"> 		nsIMAPNamespace *nspace = (nsIMAPNamespace *) m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l11.35"></a><span id="l11.35"> 		if (nspace-&gt;GetType() == type)</span>
<a href="#l11.36"></a><span id="l11.36"> 		{</span>
<a href="#l11.37"></a><span id="l11.37"> 			count++;</span>
<a href="#l11.38"></a><span id="l11.38"> 		}</span>
<a href="#l11.39"></a><span id="l11.39"> 	}</span>
<a href="#l11.40"></a><span id="l11.40"> 	return count;</span>
<a href="#l11.41"></a><span id="l11.41" class="difflineat">@@ -129,17 +129,17 @@ int nsIMAPNamespaceList::AddNewNamespace</span>
<a href="#l11.42"></a><span id="l11.42"> {</span>
<a href="#l11.43"></a><span id="l11.43"> 	// If the namespace is from the NAMESPACE response, then we should see if there</span>
<a href="#l11.44"></a><span id="l11.44"> 	// are any namespaces previously set by the preferences, or the default namespace.  If so, remove these.</span>
<a href="#l11.45"></a><span id="l11.45"> </span>
<a href="#l11.46"></a><span id="l11.46"> 	if (!ns-&gt;GetIsNamespaceFromPrefs())</span>
<a href="#l11.47"></a><span id="l11.47"> 	{</span>
<a href="#l11.48"></a><span id="l11.48"> 		int nodeIndex;</span>
<a href="#l11.49"></a><span id="l11.49">         // iterate backwards because we delete elements</span>
<a href="#l11.50"></a><span id="l11.50" class="difflineminus">-		for (nodeIndex=m_NamespaceList.Count()-1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l11.51"></a><span id="l11.51" class="difflineplus">+		for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l11.52"></a><span id="l11.52"> 		{</span>
<a href="#l11.53"></a><span id="l11.53"> 			nsIMAPNamespace *nspace = (nsIMAPNamespace *) m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l11.54"></a><span id="l11.54"> 			// if we find existing namespace(s) that matches the </span>
<a href="#l11.55"></a><span id="l11.55"> 			// new one, we'll just remove the old ones and let the</span>
<a href="#l11.56"></a><span id="l11.56"> 			// new one get added when we've finished checking for</span>
<a href="#l11.57"></a><span id="l11.57"> 			// matching namespaces or namespaces that came from prefs.</span>
<a href="#l11.58"></a><span id="l11.58"> 			if (nspace &amp;&amp;</span>
<a href="#l11.59"></a><span id="l11.59">                             (nspace-&gt;GetIsNamespaceFromPrefs() ||</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineat">@@ -161,17 +161,17 @@ int nsIMAPNamespaceList::AddNewNamespace</span>
<a href="#l11.61"></a><span id="l11.61"> }</span>
<a href="#l11.62"></a><span id="l11.62"> </span>
<a href="#l11.63"></a><span id="l11.63"> </span>
<a href="#l11.64"></a><span id="l11.64"> // chrisf - later, fix this to know the real concept of &quot;default&quot; namespace of a given type</span>
<a href="#l11.65"></a><span id="l11.65"> nsIMAPNamespace *nsIMAPNamespaceList::GetDefaultNamespaceOfType(EIMAPNamespaceType type)</span>
<a href="#l11.66"></a><span id="l11.66"> {</span>
<a href="#l11.67"></a><span id="l11.67"> 	nsIMAPNamespace *rv = 0, *firstOfType = 0;</span>
<a href="#l11.68"></a><span id="l11.68"> </span>
<a href="#l11.69"></a><span id="l11.69" class="difflineminus">-	int nodeIndex, count = m_NamespaceList.Count();</span>
<a href="#l11.70"></a><span id="l11.70" class="difflineplus">+	int nodeIndex, count = m_NamespaceList.Length();</span>
<a href="#l11.71"></a><span id="l11.71"> 	for (nodeIndex= 0; nodeIndex &lt; count &amp;&amp; !rv; nodeIndex++)</span>
<a href="#l11.72"></a><span id="l11.72"> 	{</span>
<a href="#l11.73"></a><span id="l11.73"> 		nsIMAPNamespace *ns = (nsIMAPNamespace *) m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l11.74"></a><span id="l11.74"> 		if (ns-&gt;GetType() == type)</span>
<a href="#l11.75"></a><span id="l11.75"> 		{</span>
<a href="#l11.76"></a><span id="l11.76"> 			if (!firstOfType)</span>
<a href="#l11.77"></a><span id="l11.77"> 				firstOfType = ns;</span>
<a href="#l11.78"></a><span id="l11.78"> 			if (!(*(ns-&gt;GetPrefix())))</span>
<a href="#l11.79"></a><span id="l11.79" class="difflineat">@@ -193,17 +193,17 @@ nsIMAPNamespaceList::~nsIMAPNamespaceLis</span>
<a href="#l11.80"></a><span id="l11.80"> }</span>
<a href="#l11.81"></a><span id="l11.81"> </span>
<a href="#l11.82"></a><span id="l11.82"> // ClearNamespaces removes and deletes the namespaces specified, and if there are no namespaces left,</span>
<a href="#l11.83"></a><span id="l11.83"> void nsIMAPNamespaceList::ClearNamespaces(bool deleteFromPrefsNamespaces, bool deleteServerAdvertisedNamespaces, bool reallyDelete)</span>
<a href="#l11.84"></a><span id="l11.84"> {</span>
<a href="#l11.85"></a><span id="l11.85"> 	int nodeIndex;</span>
<a href="#l11.86"></a><span id="l11.86"> 	</span>
<a href="#l11.87"></a><span id="l11.87">     // iterate backwards because we delete elements</span>
<a href="#l11.88"></a><span id="l11.88" class="difflineminus">-	for (nodeIndex=m_NamespaceList.Count()-1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineplus">+	for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l11.90"></a><span id="l11.90"> 	{</span>
<a href="#l11.91"></a><span id="l11.91"> 		nsIMAPNamespace *ns = (nsIMAPNamespace *) m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l11.92"></a><span id="l11.92"> 		if (ns-&gt;GetIsNamespaceFromPrefs())</span>
<a href="#l11.93"></a><span id="l11.93"> 		{</span>
<a href="#l11.94"></a><span id="l11.94"> 			if (deleteFromPrefsNamespaces)</span>
<a href="#l11.95"></a><span id="l11.95"> 			{</span>
<a href="#l11.96"></a><span id="l11.96"> 				m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l11.97"></a><span id="l11.97"> 				if (reallyDelete)</span>
<a href="#l11.98"></a><span id="l11.98" class="difflineat">@@ -226,17 +226,17 @@ nsIMAPNamespace *nsIMAPNamespaceList::Ge</span>
<a href="#l11.99"></a><span id="l11.99"> </span>
<a href="#l11.100"></a><span id="l11.100">   // XXX really could be just ElementAt; that's why we have the assertion</span>
<a href="#l11.101"></a><span id="l11.101">   return 	(nsIMAPNamespace *) m_NamespaceList.SafeElementAt(nodeIndex);</span>
<a href="#l11.102"></a><span id="l11.102"> }</span>
<a href="#l11.103"></a><span id="l11.103"> </span>
<a href="#l11.104"></a><span id="l11.104"> nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceNumber(int nodeIndex, EIMAPNamespaceType type)</span>
<a href="#l11.105"></a><span id="l11.105"> {</span>
<a href="#l11.106"></a><span id="l11.106">   int nodeCount, count = 0;</span>
<a href="#l11.107"></a><span id="l11.107" class="difflineminus">-  for (nodeCount=m_NamespaceList.Count()-1; nodeCount &gt;= 0; nodeCount--)</span>
<a href="#l11.108"></a><span id="l11.108" class="difflineplus">+  for (nodeCount=m_NamespaceList.Length() - 1; nodeCount &gt;= 0; nodeCount--)</span>
<a href="#l11.109"></a><span id="l11.109">   {</span>
<a href="#l11.110"></a><span id="l11.110">     nsIMAPNamespace *nspace = (nsIMAPNamespace *) m_NamespaceList.ElementAt(nodeCount);</span>
<a href="#l11.111"></a><span id="l11.111">     if (nspace-&gt;GetType() == type)</span>
<a href="#l11.112"></a><span id="l11.112">     {</span>
<a href="#l11.113"></a><span id="l11.113">       count++;</span>
<a href="#l11.114"></a><span id="l11.114">       if (count == nodeIndex)</span>
<a href="#l11.115"></a><span id="l11.115">         return nspace;</span>
<a href="#l11.116"></a><span id="l11.116">     }</span>
<a href="#l11.117"></a><span id="l11.117" class="difflineat">@@ -258,17 +258,17 @@ nsIMAPNamespace *nsIMAPNamespaceList::Ge</span>
<a href="#l11.118"></a><span id="l11.118">   int lengthMatched = -1;</span>
<a href="#l11.119"></a><span id="l11.119">   int currentMatchedLength = -1;</span>
<a href="#l11.120"></a><span id="l11.120">   nsIMAPNamespace *rv = nullptr;</span>
<a href="#l11.121"></a><span id="l11.121">   int nodeIndex = 0;</span>
<a href="#l11.122"></a><span id="l11.122">   </span>
<a href="#l11.123"></a><span id="l11.123">   if (!PL_strcasecmp(boxname, &quot;INBOX&quot;))</span>
<a href="#l11.124"></a><span id="l11.124">     return GetDefaultNamespaceOfType(kPersonalNamespace);</span>
<a href="#l11.125"></a><span id="l11.125">   </span>
<a href="#l11.126"></a><span id="l11.126" class="difflineminus">-  for (nodeIndex=m_NamespaceList.Count()-1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l11.127"></a><span id="l11.127" class="difflineplus">+  for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l11.128"></a><span id="l11.128">   {</span>
<a href="#l11.129"></a><span id="l11.129">     nsIMAPNamespace *nspace = (nsIMAPNamespace *) m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l11.130"></a><span id="l11.130">     currentMatchedLength = nspace-&gt;MailboxMatchesNamespace(boxname);</span>
<a href="#l11.131"></a><span id="l11.131">     if (currentMatchedLength &gt; lengthMatched)</span>
<a href="#l11.132"></a><span id="l11.132">     {</span>
<a href="#l11.133"></a><span id="l11.133">       rv = nspace;</span>
<a href="#l11.134"></a><span id="l11.134">       lengthMatched = currentMatchedLength;</span>
<a href="#l11.135"></a><span id="l11.135">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPNamespace.h</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPNamespace.h</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -1,17 +1,17 @@</span>
<a href="#l12.4"></a><span id="l12.4"> /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l12.5"></a><span id="l12.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l12.6"></a><span id="l12.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l12.7"></a><span id="l12.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l12.8"></a><span id="l12.8"> </span>
<a href="#l12.9"></a><span id="l12.9"> #ifndef _nsIMAPNamespace_H_</span>
<a href="#l12.10"></a><span id="l12.10"> #define _nsIMAPNamespace_H_</span>
<a href="#l12.11"></a><span id="l12.11"> </span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l12.14"></a><span id="l12.14"> </span>
<a href="#l12.15"></a><span id="l12.15"> class nsIMAPNamespace</span>
<a href="#l12.16"></a><span id="l12.16"> {</span>
<a href="#l12.17"></a><span id="l12.17">   </span>
<a href="#l12.18"></a><span id="l12.18"> public:</span>
<a href="#l12.19"></a><span id="l12.19">   nsIMAPNamespace(EIMAPNamespaceType type, const char *prefix, char delimiter, bool from_prefs);</span>
<a href="#l12.20"></a><span id="l12.20">   </span>
<a href="#l12.21"></a><span id="l12.21">   ~nsIMAPNamespace();</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineat">@@ -74,14 +74,14 @@ public:</span>
<a href="#l12.23"></a><span id="l12.23">                                                                                 const char *canonicalFolderName,</span>
<a href="#l12.24"></a><span id="l12.24">                                                                                 const char *owner,</span>
<a href="#l12.25"></a><span id="l12.25">                                                                                 EIMAPNamespaceType nsType,</span>
<a href="#l12.26"></a><span id="l12.26">                                                                                 nsIMAPNamespace **nsUsed);</span>
<a href="#l12.27"></a><span id="l12.27"> </span>
<a href="#l12.28"></a><span id="l12.28"> protected:</span>
<a href="#l12.29"></a><span id="l12.29">   nsIMAPNamespaceList();	// use CreatensIMAPNamespaceList to create one</span>
<a href="#l12.30"></a><span id="l12.30">   </span>
<a href="#l12.31"></a><span id="l12.31" class="difflineminus">-  nsVoidArray m_NamespaceList;</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+  nsTArray&lt;nsIMAPNamespace*&gt; m_NamespaceList;</span>
<a href="#l12.33"></a><span id="l12.33">   </span>
<a href="#l12.34"></a><span id="l12.34"> };</span>
<a href="#l12.35"></a><span id="l12.35"> </span>
<a href="#l12.36"></a><span id="l12.36"> </span>
<a href="#l12.37"></a><span id="l12.37"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -451,17 +451,17 @@ nsImapIncomingServer::GetImapConnectionA</span>
<a href="#l13.4"></a><span id="l13.4">     }</span>
<a href="#l13.5"></a><span id="l13.5">   }</span>
<a href="#l13.6"></a><span id="l13.6">   else</span>
<a href="#l13.7"></a><span id="l13.7">   {   // unable to get an imap connection to run the url; add to the url</span>
<a href="#l13.8"></a><span id="l13.8">      // queue</span>
<a href="#l13.9"></a><span id="l13.9">     nsImapProtocol::LogImapUrl(&quot;queuing url&quot;, aImapUrl);</span>
<a href="#l13.10"></a><span id="l13.10">     PR_CEnterMonitor(this);</span>
<a href="#l13.11"></a><span id="l13.11">     m_urlQueue.AppendObject(aImapUrl);</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-    m_urlConsumers.AppendElement((void*)aConsumer);</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+    m_urlConsumers.AppendElement(aConsumer);</span>
<a href="#l13.14"></a><span id="l13.14">     NS_IF_ADDREF(aConsumer);</span>
<a href="#l13.15"></a><span id="l13.15">     PR_CExitMonitor(this);</span>
<a href="#l13.16"></a><span id="l13.16">     // let's try running it now - maybe the connection is free now.</span>
<a href="#l13.17"></a><span id="l13.17">     bool urlRun;</span>
<a href="#l13.18"></a><span id="l13.18">     rv = LoadNextQueuedUrl(nullptr, &amp;urlRun);</span>
<a href="#l13.19"></a><span id="l13.19">   }</span>
<a href="#l13.20"></a><span id="l13.20"> </span>
<a href="#l13.21"></a><span id="l13.21">   return rv;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.h</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.h</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -11,17 +11,17 @@</span>
<a href="#l14.4"></a><span id="l14.4"> #include &quot;nsIImapIncomingServer.h&quot;</span>
<a href="#l14.5"></a><span id="l14.5"> #include &quot;nsMsgIncomingServer.h&quot;</span>
<a href="#l14.6"></a><span id="l14.6"> #include &quot;nsIImapServerSink.h&quot;</span>
<a href="#l14.7"></a><span id="l14.7"> #include &quot;nsIStringBundle.h&quot;</span>
<a href="#l14.8"></a><span id="l14.8"> #include &quot;nsISubscribableServer.h&quot;</span>
<a href="#l14.9"></a><span id="l14.9"> #include &quot;nsIUrlListener.h&quot;</span>
<a href="#l14.10"></a><span id="l14.10"> #include &quot;nsIMsgImapMailFolder.h&quot;</span>
<a href="#l14.11"></a><span id="l14.11"> #include &quot;nsCOMArray.h&quot;</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l14.14"></a><span id="l14.14"> #include &quot;mozilla/Mutex.h&quot;</span>
<a href="#l14.15"></a><span id="l14.15"> </span>
<a href="#l14.16"></a><span id="l14.16"> class nsIRDFService;</span>
<a href="#l14.17"></a><span id="l14.17"> </span>
<a href="#l14.18"></a><span id="l14.18"> /* get some implementation from nsMsgIncomingServer */</span>
<a href="#l14.19"></a><span id="l14.19"> class nsImapIncomingServer : public nsMsgIncomingServer,</span>
<a href="#l14.20"></a><span id="l14.20">                              public nsIImapIncomingServer,</span>
<a href="#l14.21"></a><span id="l14.21">                              public nsIImapServerSink,</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineat">@@ -105,17 +105,17 @@ private:</span>
<a href="#l14.23"></a><span id="l14.23">   bool CheckSpecialFolder(nsIRDFService *rdf, nsCString &amp;folderUri,</span>
<a href="#l14.24"></a><span id="l14.24">                             uint32_t folderFlag, nsCString &amp;existingUri);</span>
<a href="#l14.25"></a><span id="l14.25"> </span>
<a href="#l14.26"></a><span id="l14.26">   nsCOMArray&lt;nsIImapProtocol&gt; m_connectionCache;</span>
<a href="#l14.27"></a><span id="l14.27">   nsCOMArray&lt;nsIImapUrl&gt; m_urlQueue;</span>
<a href="#l14.28"></a><span id="l14.28">   nsCOMPtr&lt;nsIStringBundle&gt;	m_stringBundle;</span>
<a href="#l14.29"></a><span id="l14.29">   nsCOMArray&lt;nsIMsgFolder&gt; m_subscribeFolders; // used to keep folder resources around while subscribe UI is up.</span>
<a href="#l14.30"></a><span id="l14.30">   nsCOMArray&lt;nsIMsgImapMailFolder&gt; m_foldersToStat; // folders to check for new mail with Status</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineminus">-  nsVoidArray       m_urlConsumers;</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+  nsTArray&lt;nsISupports*&gt; m_urlConsumers;</span>
<a href="#l14.33"></a><span id="l14.33">   eIMAPCapabilityFlags          m_capability;</span>
<a href="#l14.34"></a><span id="l14.34">   nsCString         m_manageMailAccountUrl;</span>
<a href="#l14.35"></a><span id="l14.35">   bool              m_userAuthenticated;</span>
<a href="#l14.36"></a><span id="l14.36">   bool              mDoingSubscribeDialog;</span>
<a href="#l14.37"></a><span id="l14.37">   bool              mDoingLsub;</span>
<a href="#l14.38"></a><span id="l14.38">   bool              m_shuttingDown;</span>
<a href="#l14.39"></a><span id="l14.39"> </span>
<a href="#l14.40"></a><span id="l14.40">   mozilla::Mutex mLock;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -4973,42 +4973,42 @@ nsImapProtocol::DiscoverMailboxSpec(nsIm</span>
<a href="#l15.4"></a><span id="l15.4">           else if (GetMailboxDiscoveryStatus() == eContinueNew)</span>
<a href="#l15.5"></a><span id="l15.5">           {</span>
<a href="#l15.6"></a><span id="l15.6">             if (m_hierarchyNameState == kListingForInfoAndDiscovery &amp;&amp;</span>
<a href="#l15.7"></a><span id="l15.7">                 !adoptedBoxSpec-&gt;mAllocatedPathName.IsEmpty() &amp;&amp;</span>
<a href="#l15.8"></a><span id="l15.8">                 !(adoptedBoxSpec-&gt;mBoxFlags &amp; kNameSpace))</span>
<a href="#l15.9"></a><span id="l15.9">             {</span>
<a href="#l15.10"></a><span id="l15.10">               // remember the info here also</span>
<a href="#l15.11"></a><span id="l15.11">               nsIMAPMailboxInfo *mb = new nsIMAPMailboxInfo(adoptedBoxSpec-&gt;mAllocatedPathName, adoptedBoxSpec-&gt;mHierarchySeparator);</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-              m_listedMailboxList.AppendElement((void*) mb);</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+              m_listedMailboxList.AppendElement(mb);</span>
<a href="#l15.14"></a><span id="l15.14">             }</span>
<a href="#l15.15"></a><span id="l15.15">             SetMailboxDiscoveryStatus(eContinue);</span>
<a href="#l15.16"></a><span id="l15.16">           }</span>
<a href="#l15.17"></a><span id="l15.17">         }</span>
<a href="#l15.18"></a><span id="l15.18">       }</span>
<a href="#l15.19"></a><span id="l15.19">       }</span>
<a href="#l15.20"></a><span id="l15.20">       NS_IF_RELEASE( adoptedBoxSpec);</span>
<a href="#l15.21"></a><span id="l15.21">       break;</span>
<a href="#l15.22"></a><span id="l15.22">     case kDiscoverBaseFolderInProgress:</span>
<a href="#l15.23"></a><span id="l15.23">       break;</span>
<a href="#l15.24"></a><span id="l15.24">     case kDeleteSubFoldersInProgress:</span>
<a href="#l15.25"></a><span id="l15.25">       {</span>
<a href="#l15.26"></a><span id="l15.26">         NS_ASSERTION(m_deletableChildren, &quot;Oops .. null m_deletableChildren\n&quot;);</span>
<a href="#l15.27"></a><span id="l15.27" class="difflineminus">-        m_deletableChildren-&gt;AppendElement((void *)ToNewCString(adoptedBoxSpec-&gt;mAllocatedPathName));</span>
<a href="#l15.28"></a><span id="l15.28" class="difflineplus">+        m_deletableChildren-&gt;AppendElement(ToNewCString(adoptedBoxSpec-&gt;mAllocatedPathName));</span>
<a href="#l15.29"></a><span id="l15.29">         NS_IF_RELEASE(adoptedBoxSpec);</span>
<a href="#l15.30"></a><span id="l15.30">       }</span>
<a href="#l15.31"></a><span id="l15.31">       break;</span>
<a href="#l15.32"></a><span id="l15.32">     case kListingForInfoOnly:</span>
<a href="#l15.33"></a><span id="l15.33">       {</span>
<a href="#l15.34"></a><span id="l15.34">         //UpdateProgressWindowForUpgrade(adoptedBoxSpec-&gt;allocatedPathName);</span>
<a href="#l15.35"></a><span id="l15.35">         ProgressEventFunctionUsingNameWithString(&quot;imapDiscoveringMailbox&quot;,</span>
<a href="#l15.36"></a><span id="l15.36">           adoptedBoxSpec-&gt;mAllocatedPathName.get());</span>
<a href="#l15.37"></a><span id="l15.37">         nsIMAPMailboxInfo *mb = new nsIMAPMailboxInfo(adoptedBoxSpec-&gt;mAllocatedPathName,</span>
<a href="#l15.38"></a><span id="l15.38">                                                       adoptedBoxSpec-&gt;mHierarchySeparator);</span>
<a href="#l15.39"></a><span id="l15.39" class="difflineminus">-        m_listedMailboxList.AppendElement((void*) mb);</span>
<a href="#l15.40"></a><span id="l15.40" class="difflineplus">+        m_listedMailboxList.AppendElement(mb);</span>
<a href="#l15.41"></a><span id="l15.41">         NS_IF_RELEASE(adoptedBoxSpec);</span>
<a href="#l15.42"></a><span id="l15.42">       }</span>
<a href="#l15.43"></a><span id="l15.43">       break;</span>
<a href="#l15.44"></a><span id="l15.44">     case kDiscoveringNamespacesOnly:</span>
<a href="#l15.45"></a><span id="l15.45">       {</span>
<a href="#l15.46"></a><span id="l15.46">         NS_IF_RELEASE(adoptedBoxSpec);</span>
<a href="#l15.47"></a><span id="l15.47">       }</span>
<a href="#l15.48"></a><span id="l15.48">       break;</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineat">@@ -6398,21 +6398,21 @@ void nsImapProtocol::GetACLForFolder(con</span>
<a href="#l15.50"></a><span id="l15.50"> void nsImapProtocol::OnRefreshAllACLs()</span>
<a href="#l15.51"></a><span id="l15.51"> {</span>
<a href="#l15.52"></a><span id="l15.52">   m_hierarchyNameState = kListingForInfoOnly;</span>
<a href="#l15.53"></a><span id="l15.53">   nsIMAPMailboxInfo *mb = NULL;</span>
<a href="#l15.54"></a><span id="l15.54"> </span>
<a href="#l15.55"></a><span id="l15.55">   // This will fill in the list</span>
<a href="#l15.56"></a><span id="l15.56">   List(&quot;*&quot;, true);</span>
<a href="#l15.57"></a><span id="l15.57"> </span>
<a href="#l15.58"></a><span id="l15.58" class="difflineminus">-  int32_t total = m_listedMailboxList.Count(), count = 0;</span>
<a href="#l15.59"></a><span id="l15.59" class="difflineplus">+  int32_t total = m_listedMailboxList.Length(), count = 0;</span>
<a href="#l15.60"></a><span id="l15.60">   GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l15.61"></a><span id="l15.61">   for (int32_t i = 0; i &lt; total; i++)</span>
<a href="#l15.62"></a><span id="l15.62">   {</span>
<a href="#l15.63"></a><span id="l15.63" class="difflineminus">-    mb = (nsIMAPMailboxInfo *) m_listedMailboxList.ElementAt(i);</span>
<a href="#l15.64"></a><span id="l15.64" class="difflineplus">+    mb = m_listedMailboxList.ElementAt(i);</span>
<a href="#l15.65"></a><span id="l15.65">     if (mb) // paranoia</span>
<a href="#l15.66"></a><span id="l15.66">     {</span>
<a href="#l15.67"></a><span id="l15.67">       char *onlineName = nullptr;</span>
<a href="#l15.68"></a><span id="l15.68">       m_runningUrl-&gt;AllocateServerPath(PromiseFlatCString(mb-&gt;GetMailboxName()).get(), mb-&gt;GetDelimiter(), &amp;onlineName);</span>
<a href="#l15.69"></a><span id="l15.69">       if (onlineName)</span>
<a href="#l15.70"></a><span id="l15.70">       {</span>
<a href="#l15.71"></a><span id="l15.71">         RefreshACLForFolder(onlineName);</span>
<a href="#l15.72"></a><span id="l15.72">         NS_Free(onlineName);</span>
<a href="#l15.73"></a><span id="l15.73" class="difflineat">@@ -6728,17 +6728,17 @@ bool nsImapProtocol::RenameMailboxRespec</span>
<a href="#l15.74"></a><span id="l15.74">   return (rv);</span>
<a href="#l15.75"></a><span id="l15.75"> }</span>
<a href="#l15.76"></a><span id="l15.76"> </span>
<a href="#l15.77"></a><span id="l15.77"> bool nsImapProtocol::RenameHierarchyByHand(const char *oldParentMailboxName,</span>
<a href="#l15.78"></a><span id="l15.78">                                              const char *newParentMailboxName)</span>
<a href="#l15.79"></a><span id="l15.79"> {</span>
<a href="#l15.80"></a><span id="l15.80">   bool renameSucceeded = true;</span>
<a href="#l15.81"></a><span id="l15.81">     char onlineDirSeparator = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l15.82"></a><span id="l15.82" class="difflineminus">-  m_deletableChildren = new nsVoidArray();</span>
<a href="#l15.83"></a><span id="l15.83" class="difflineplus">+  m_deletableChildren = new nsTArray&lt;char*&gt;();</span>
<a href="#l15.84"></a><span id="l15.84"> </span>
<a href="#l15.85"></a><span id="l15.85">   bool nonHierarchicalRename =</span>
<a href="#l15.86"></a><span id="l15.86">         ((GetServerStateParser().GetCapabilityFlag() &amp; kNoHierarchyRename)</span>
<a href="#l15.87"></a><span id="l15.87">          || MailboxIsNoSelectMailbox(oldParentMailboxName));</span>
<a href="#l15.88"></a><span id="l15.88"> </span>
<a href="#l15.89"></a><span id="l15.89">   if (m_deletableChildren)</span>
<a href="#l15.90"></a><span id="l15.90">   {</span>
<a href="#l15.91"></a><span id="l15.91">     m_hierarchyNameState = kDeleteSubFoldersInProgress;</span>
<a href="#l15.92"></a><span id="l15.92" class="difflineat">@@ -6769,17 +6769,17 @@ bool nsImapProtocol::RenameHierarchyByHa</span>
<a href="#l15.93"></a><span id="l15.93">     }</span>
<a href="#l15.94"></a><span id="l15.94">     m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l15.95"></a><span id="l15.95"> </span>
<a href="#l15.96"></a><span id="l15.96">     if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l15.97"></a><span id="l15.97">       renameSucceeded = // rename this, and move subscriptions</span>
<a href="#l15.98"></a><span id="l15.98">                 RenameMailboxRespectingSubscriptions(oldParentMailboxName,</span>
<a href="#l15.99"></a><span id="l15.99">                                                      newParentMailboxName, true);</span>
<a href="#l15.100"></a><span id="l15.100"> </span>
<a href="#l15.101"></a><span id="l15.101" class="difflineminus">-    int32_t numberToDelete = m_deletableChildren-&gt;Count();</span>
<a href="#l15.102"></a><span id="l15.102" class="difflineplus">+    int32_t numberToDelete = m_deletableChildren-&gt;Length();</span>
<a href="#l15.103"></a><span id="l15.103">         int32_t childIndex;</span>
<a href="#l15.104"></a><span id="l15.104"> </span>
<a href="#l15.105"></a><span id="l15.105">     for (childIndex = 0;</span>
<a href="#l15.106"></a><span id="l15.106">              (childIndex &lt; numberToDelete) &amp;&amp; renameSucceeded; childIndex++)</span>
<a href="#l15.107"></a><span id="l15.107">     {</span>
<a href="#l15.108"></a><span id="l15.108">       // the imap parser has already converted to a non UTF7 string in the canonical</span>
<a href="#l15.109"></a><span id="l15.109">       // format so convert it back</span>
<a href="#l15.110"></a><span id="l15.110">         char *currentName = (char *) m_deletableChildren-&gt;ElementAt(childIndex);</span>
<a href="#l15.111"></a><span id="l15.111" class="difflineat">@@ -6810,17 +6810,17 @@ bool nsImapProtocol::RenameHierarchyByHa</span>
<a href="#l15.112"></a><span id="l15.112">   }</span>
<a href="#l15.113"></a><span id="l15.113"> </span>
<a href="#l15.114"></a><span id="l15.114">   return renameSucceeded;</span>
<a href="#l15.115"></a><span id="l15.115"> }</span>
<a href="#l15.116"></a><span id="l15.116"> </span>
<a href="#l15.117"></a><span id="l15.117"> bool nsImapProtocol::DeleteSubFolders(const char* selectedMailbox, bool &amp;aDeleteSelf)</span>
<a href="#l15.118"></a><span id="l15.118"> {</span>
<a href="#l15.119"></a><span id="l15.119">   bool deleteSucceeded = true;</span>
<a href="#l15.120"></a><span id="l15.120" class="difflineminus">-  m_deletableChildren = new nsVoidArray();</span>
<a href="#l15.121"></a><span id="l15.121" class="difflineplus">+  m_deletableChildren = new nsTArray&lt;char*&gt;();</span>
<a href="#l15.122"></a><span id="l15.122"> </span>
<a href="#l15.123"></a><span id="l15.123">   if (m_deletableChildren)</span>
<a href="#l15.124"></a><span id="l15.124">   {</span>
<a href="#l15.125"></a><span id="l15.125">     bool folderDeleted = false;</span>
<a href="#l15.126"></a><span id="l15.126"> </span>
<a href="#l15.127"></a><span id="l15.127">     m_hierarchyNameState = kDeleteSubFoldersInProgress;</span>
<a href="#l15.128"></a><span id="l15.128">         nsCString pattern(selectedMailbox);</span>
<a href="#l15.129"></a><span id="l15.129">         char onlineDirSeparator = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l15.130"></a><span id="l15.130" class="difflineat">@@ -6833,17 +6833,17 @@ bool nsImapProtocol::DeleteSubFolders(co</span>
<a href="#l15.131"></a><span id="l15.131">       List(pattern.get(), false);</span>
<a href="#l15.132"></a><span id="l15.132">     }</span>
<a href="#l15.133"></a><span id="l15.133">     m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l15.134"></a><span id="l15.134"> </span>
<a href="#l15.135"></a><span id="l15.135">     // this should be a short list so perform a sequential search for the</span>
<a href="#l15.136"></a><span id="l15.136">     // longest name mailbox.  Deleting the longest first will hopefully</span>
<a href="#l15.137"></a><span id="l15.137">         // prevent the server from having problems about deleting parents</span>
<a href="#l15.138"></a><span id="l15.138">         // ** jt - why? I don't understand this.</span>
<a href="#l15.139"></a><span id="l15.139" class="difflineminus">-    int32_t numberToDelete = m_deletableChildren-&gt;Count();</span>
<a href="#l15.140"></a><span id="l15.140" class="difflineplus">+    int32_t numberToDelete = m_deletableChildren-&gt;Length();</span>
<a href="#l15.141"></a><span id="l15.141">     int32_t outerIndex, innerIndex;</span>
<a href="#l15.142"></a><span id="l15.142"> </span>
<a href="#l15.143"></a><span id="l15.143">     // intelligently decide if myself(either plain format or following the dir-separator)</span>
<a href="#l15.144"></a><span id="l15.144">     // is in the sub-folder list</span>
<a href="#l15.145"></a><span id="l15.145">     bool folderInSubfolderList = false; // For Performance</span>
<a href="#l15.146"></a><span id="l15.146">     char *selectedMailboxDir = nullptr;</span>
<a href="#l15.147"></a><span id="l15.147">     {</span>
<a href="#l15.148"></a><span id="l15.148">         int32_t length = strlen(selectedMailbox);</span>
<a href="#l15.149"></a><span id="l15.149" class="difflineat">@@ -6851,36 +6851,35 @@ bool nsImapProtocol::DeleteSubFolders(co</span>
<a href="#l15.150"></a><span id="l15.150">         if( selectedMailboxDir )    // only do the intelligent test if there is enough memory</span>
<a href="#l15.151"></a><span id="l15.151">         {</span>
<a href="#l15.152"></a><span id="l15.152">             strcpy(selectedMailboxDir, selectedMailbox);</span>
<a href="#l15.153"></a><span id="l15.153">             selectedMailboxDir[length] = onlineDirSeparator;</span>
<a href="#l15.154"></a><span id="l15.154">             selectedMailboxDir[length+1] = '\0';</span>
<a href="#l15.155"></a><span id="l15.155">             int32_t i;</span>
<a href="#l15.156"></a><span id="l15.156">             for( i=0; i&lt;numberToDelete &amp;&amp; !folderInSubfolderList; i++ )</span>
<a href="#l15.157"></a><span id="l15.157">             {</span>
<a href="#l15.158"></a><span id="l15.158" class="difflineminus">-                char *currentName = (char *) m_deletableChildren-&gt;ElementAt(i);</span>
<a href="#l15.159"></a><span id="l15.159" class="difflineplus">+                char *currentName = m_deletableChildren-&gt;ElementAt(i);</span>
<a href="#l15.160"></a><span id="l15.160">                 if( !strcmp(currentName, selectedMailbox) || !strcmp(currentName, selectedMailboxDir) )</span>
<a href="#l15.161"></a><span id="l15.161">                     folderInSubfolderList = true;</span>
<a href="#l15.162"></a><span id="l15.162">             }</span>
<a href="#l15.163"></a><span id="l15.163">         }</span>
<a href="#l15.164"></a><span id="l15.164">     }</span>
<a href="#l15.165"></a><span id="l15.165"> </span>
<a href="#l15.166"></a><span id="l15.166">     deleteSucceeded = GetServerStateParser().LastCommandSuccessful();</span>
<a href="#l15.167"></a><span id="l15.167">     for (outerIndex = 0;</span>
<a href="#l15.168"></a><span id="l15.168">          (outerIndex &lt; numberToDelete) &amp;&amp; deleteSucceeded;</span>
<a href="#l15.169"></a><span id="l15.169">          outerIndex++)</span>
<a href="#l15.170"></a><span id="l15.170">     {</span>
<a href="#l15.171"></a><span id="l15.171">         char* longestName = nullptr;</span>
<a href="#l15.172"></a><span id="l15.172">         int32_t longestIndex = 0; // fix bogus warning by initializing</span>
<a href="#l15.173"></a><span id="l15.173">         for (innerIndex = 0;</span>
<a href="#l15.174"></a><span id="l15.174" class="difflineminus">-             innerIndex &lt; m_deletableChildren-&gt;Count();</span>
<a href="#l15.175"></a><span id="l15.175" class="difflineplus">+             innerIndex &lt; m_deletableChildren-&gt;Length();</span>
<a href="#l15.176"></a><span id="l15.176">              innerIndex++)</span>
<a href="#l15.177"></a><span id="l15.177">         {</span>
<a href="#l15.178"></a><span id="l15.178" class="difflineminus">-            char *currentName =</span>
<a href="#l15.179"></a><span id="l15.179" class="difflineminus">-                (char *) m_deletableChildren-&gt;ElementAt(innerIndex);</span>
<a href="#l15.180"></a><span id="l15.180" class="difflineplus">+            char *currentName = m_deletableChildren-&gt;ElementAt(innerIndex);</span>
<a href="#l15.181"></a><span id="l15.181">             if (!longestName || strlen(longestName) &lt; strlen(currentName))</span>
<a href="#l15.182"></a><span id="l15.182">             {</span>
<a href="#l15.183"></a><span id="l15.183">                 longestName = currentName;</span>
<a href="#l15.184"></a><span id="l15.184">                 longestIndex = innerIndex;</span>
<a href="#l15.185"></a><span id="l15.185">             }</span>
<a href="#l15.186"></a><span id="l15.186">         }</span>
<a href="#l15.187"></a><span id="l15.187">         // the imap parser has already converted to a non UTF7 string in</span>
<a href="#l15.188"></a><span id="l15.188">         // the canonical format so convert it back</span>
<a href="#l15.189"></a><span id="l15.189" class="difflineat">@@ -6921,17 +6920,17 @@ bool nsImapProtocol::DeleteSubFolders(co</span>
<a href="#l15.190"></a><span id="l15.190">           else</span>
<a href="#l15.191"></a><span id="l15.191">           {</span>
<a href="#l15.192"></a><span id="l15.192">               nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer = do_QueryReferent(m_server);</span>
<a href="#l15.193"></a><span id="l15.193">               if (imapServer)</span>
<a href="#l15.194"></a><span id="l15.194">                   imapServer-&gt;ResetConnection(nsDependentCString(longestName));</span>
<a href="#l15.195"></a><span id="l15.195">               bool deleted = false;</span>
<a href="#l15.196"></a><span id="l15.196">               if( folderInSubfolderList )	// for performance</span>
<a href="#l15.197"></a><span id="l15.197">               {</span>
<a href="#l15.198"></a><span id="l15.198" class="difflineminus">-                  nsVoidArray* pDeletableChildren = m_deletableChildren;</span>
<a href="#l15.199"></a><span id="l15.199" class="difflineplus">+                  nsTArray&lt;char*&gt; *pDeletableChildren = m_deletableChildren;</span>
<a href="#l15.200"></a><span id="l15.200">                   m_deletableChildren = nullptr;</span>
<a href="#l15.201"></a><span id="l15.201">                   bool folderDeleted = true;</span>
<a href="#l15.202"></a><span id="l15.202">                   deleted = DeleteSubFolders(longestName, folderDeleted);</span>
<a href="#l15.203"></a><span id="l15.203">                   // longestName may have subfolder list including itself</span>
<a href="#l15.204"></a><span id="l15.204">                   if( !folderDeleted )</span>
<a href="#l15.205"></a><span id="l15.205">                   {</span>
<a href="#l15.206"></a><span id="l15.206">                       if (deleted)</span>
<a href="#l15.207"></a><span id="l15.207">                       deleted = DeleteMailboxRespectingSubscriptions(longestName);</span>
<a href="#l15.208"></a><span id="l15.208" class="difflineat">@@ -7375,29 +7374,29 @@ void nsImapProtocol::DiscoverMailboxList</span>
<a href="#l15.209"></a><span id="l15.209"> </span>
<a href="#l15.210"></a><span id="l15.210">   m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l15.211"></a><span id="l15.211"> </span>
<a href="#l15.212"></a><span id="l15.212">   MailboxDiscoveryFinished();</span>
<a href="#l15.213"></a><span id="l15.213"> </span>
<a href="#l15.214"></a><span id="l15.214">   // Get the ACLs for newly discovered folders</span>
<a href="#l15.215"></a><span id="l15.215">   if (GetServerStateParser().ServerHasACLCapability())</span>
<a href="#l15.216"></a><span id="l15.216">   {</span>
<a href="#l15.217"></a><span id="l15.217" class="difflineminus">-    int32_t total = m_listedMailboxList.Count(), cnt = 0;</span>
<a href="#l15.218"></a><span id="l15.218" class="difflineplus">+    int32_t total = m_listedMailboxList.Length(), cnt = 0;</span>
<a href="#l15.219"></a><span id="l15.219">     // Let's not turn this off here, since we don't turn it on after</span>
<a href="#l15.220"></a><span id="l15.220">     // GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l15.221"></a><span id="l15.221">     if (total)</span>
<a href="#l15.222"></a><span id="l15.222">     {</span>
<a href="#l15.223"></a><span id="l15.223">       ProgressEventFunctionUsingName(&quot;imapGettingACLForFolder&quot;);</span>
<a href="#l15.224"></a><span id="l15.224">       nsIMAPMailboxInfo * mb = nullptr;</span>
<a href="#l15.225"></a><span id="l15.225">       do</span>
<a href="#l15.226"></a><span id="l15.226">       {</span>
<a href="#l15.227"></a><span id="l15.227" class="difflineminus">-        if (m_listedMailboxList.Count() == 0)</span>
<a href="#l15.228"></a><span id="l15.228" class="difflineplus">+        if (m_listedMailboxList.Length() == 0)</span>
<a href="#l15.229"></a><span id="l15.229">             break;</span>
<a href="#l15.230"></a><span id="l15.230"> </span>
<a href="#l15.231"></a><span id="l15.231" class="difflineminus">-        mb = (nsIMAPMailboxInfo *) m_listedMailboxList[0]; // get top element</span>
<a href="#l15.232"></a><span id="l15.232" class="difflineplus">+        mb = m_listedMailboxList[0]; // get top element</span>
<a href="#l15.233"></a><span id="l15.233">         m_listedMailboxList.RemoveElementAt(0); // XP_ListRemoveTopObject(fListedMailboxList);</span>
<a href="#l15.234"></a><span id="l15.234">         if (mb)</span>
<a href="#l15.235"></a><span id="l15.235">         {</span>
<a href="#l15.236"></a><span id="l15.236">           if (FolderNeedsACLInitialized(PromiseFlatCString(mb-&gt;GetMailboxName()).get()))</span>
<a href="#l15.237"></a><span id="l15.237">           {</span>
<a href="#l15.238"></a><span id="l15.238">             char *onlineName = nullptr;</span>
<a href="#l15.239"></a><span id="l15.239">             m_runningUrl-&gt;AllocateServerPath(PromiseFlatCString(mb-&gt;GetMailboxName()).get(),</span>
<a href="#l15.240"></a><span id="l15.240">                                              mb-&gt;GetDelimiter(), &amp;onlineName);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -28,17 +28,16 @@</span>
<a href="#l16.4"></a><span id="l16.4"> #include &quot;nsIImapMessageSink.h&quot;</span>
<a href="#l16.5"></a><span id="l16.5"> </span>
<a href="#l16.6"></a><span id="l16.6"> // UI Thread proxy helper</span>
<a href="#l16.7"></a><span id="l16.7"> #include &quot;nsIImapProtocolSink.h&quot;</span>
<a href="#l16.8"></a><span id="l16.8"> </span>
<a href="#l16.9"></a><span id="l16.9"> #include &quot;nsImapServerResponseParser.h&quot;</span>
<a href="#l16.10"></a><span id="l16.10"> #include &quot;nsImapFlagAndUidState.h&quot;</span>
<a href="#l16.11"></a><span id="l16.11"> #include &quot;nsIMAPNamespace.h&quot;</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l16.13"></a><span id="l16.13"> #include &quot;nsTArray.h&quot;</span>
<a href="#l16.14"></a><span id="l16.14"> #include &quot;nsWeakPtr.h&quot;</span>
<a href="#l16.15"></a><span id="l16.15"> #include &quot;nsMsgLineBuffer.h&quot; // we need this to use the nsMsgLineStreamBuffer helper class...</span>
<a href="#l16.16"></a><span id="l16.16"> #include &quot;nsIInputStream.h&quot;</span>
<a href="#l16.17"></a><span id="l16.17"> #include &quot;nsIMsgIncomingServer.h&quot;</span>
<a href="#l16.18"></a><span id="l16.18"> #include &quot;nsCOMArray.h&quot;</span>
<a href="#l16.19"></a><span id="l16.19"> #include &quot;nsIThread.h&quot;</span>
<a href="#l16.20"></a><span id="l16.20"> #include &quot;nsIRunnable.h&quot;</span>
<a href="#l16.21"></a><span id="l16.21" class="difflineat">@@ -56,16 +55,17 @@</span>
<a href="#l16.22"></a><span id="l16.22"> #include &quot;nsIMsgFolder.h&quot;</span>
<a href="#l16.23"></a><span id="l16.23"> #include &quot;nsIMsgAsyncPrompter.h&quot;</span>
<a href="#l16.24"></a><span id="l16.24"> #include &quot;mozilla/ReentrantMonitor.h&quot;</span>
<a href="#l16.25"></a><span id="l16.25"> #include &quot;nsSyncRunnableHelpers.h&quot;</span>
<a href="#l16.26"></a><span id="l16.26"> </span>
<a href="#l16.27"></a><span id="l16.27"> class nsIMAPMessagePartIDArray;</span>
<a href="#l16.28"></a><span id="l16.28"> class nsIMsgIncomingServer;</span>
<a href="#l16.29"></a><span id="l16.29"> class nsIPrefBranch;</span>
<a href="#l16.30"></a><span id="l16.30" class="difflineplus">+class nsIMAPMailboxInfo;</span>
<a href="#l16.31"></a><span id="l16.31"> </span>
<a href="#l16.32"></a><span id="l16.32"> #define kDownLoadCacheSize 16000 // was 1536 - try making it bigger</span>
<a href="#l16.33"></a><span id="l16.33"> </span>
<a href="#l16.34"></a><span id="l16.34"> </span>
<a href="#l16.35"></a><span id="l16.35"> typedef struct _msg_line_info {</span>
<a href="#l16.36"></a><span id="l16.36">     const char   *adoptedMessageLine;</span>
<a href="#l16.37"></a><span id="l16.37">     uint32_t uidOfMessage;</span>
<a href="#l16.38"></a><span id="l16.38"> } msg_line_info;</span>
<a href="#l16.39"></a><span id="l16.39" class="difflineat">@@ -658,18 +658,18 @@ private:</span>
<a href="#l16.40"></a><span id="l16.40">       kListingForInfoAndDiscovery,</span>
<a href="#l16.41"></a><span id="l16.41">       kDiscoveringNamespacesOnly,</span>
<a href="#l16.42"></a><span id="l16.42">       kXListing,</span>
<a href="#l16.43"></a><span id="l16.43">       kListingForFolderFlags,</span>
<a href="#l16.44"></a><span id="l16.44">       kListingForCreate</span>
<a href="#l16.45"></a><span id="l16.45">   };</span>
<a href="#l16.46"></a><span id="l16.46">   EMailboxHierarchyNameState  m_hierarchyNameState;</span>
<a href="#l16.47"></a><span id="l16.47">   EMailboxDiscoverStatus      m_discoveryStatus;</span>
<a href="#l16.48"></a><span id="l16.48" class="difflineminus">-  nsVoidArray                 m_listedMailboxList;</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineminus">-  nsVoidArray*                m_deletableChildren;</span>
<a href="#l16.50"></a><span id="l16.50" class="difflineplus">+  nsTArray&lt;nsIMAPMailboxInfo*&gt; m_listedMailboxList;</span>
<a href="#l16.51"></a><span id="l16.51" class="difflineplus">+  nsTArray&lt;char*&gt; *            m_deletableChildren;</span>
<a href="#l16.52"></a><span id="l16.52">   uint32_t                    m_flagChangeCount;</span>
<a href="#l16.53"></a><span id="l16.53">   PRTime                      m_lastCheckTime;</span>
<a href="#l16.54"></a><span id="l16.54"> </span>
<a href="#l16.55"></a><span id="l16.55">   bool CheckNeeded();</span>
<a href="#l16.56"></a><span id="l16.56"> </span>
<a href="#l16.57"></a><span id="l16.57">   nsString m_emptyMimePartString;</span>
<a href="#l16.58"></a><span id="l16.58"> </span>
<a href="#l16.59"></a><span id="l16.59">   nsRefPtr&lt;mozilla::mailnews::OAuth2ThreadHelper&gt; mOAuth2Support;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/imap/src/nsImapSearchResults.cpp</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapSearchResults.cpp</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -16,26 +16,23 @@ nsImapSearchResultSequence::nsImapSearch</span>
<a href="#l17.4"></a><span id="l17.4"> </span>
<a href="#l17.5"></a><span id="l17.5"> nsImapSearchResultSequence *nsImapSearchResultSequence::CreateSearchResultSequence()</span>
<a href="#l17.6"></a><span id="l17.6"> {</span>
<a href="#l17.7"></a><span id="l17.7">   return new nsImapSearchResultSequence;</span>
<a href="#l17.8"></a><span id="l17.8"> }</span>
<a href="#l17.9"></a><span id="l17.9"> </span>
<a href="#l17.10"></a><span id="l17.10"> void nsImapSearchResultSequence::Clear(void)</span>
<a href="#l17.11"></a><span id="l17.11"> {</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-  if (mImpl) </span>
<a href="#l17.13"></a><span id="l17.13" class="difflineminus">-  {</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineminus">-    int32_t i = mImpl-&gt;mCount;</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineplus">+    int32_t i = Length();</span>
<a href="#l17.16"></a><span id="l17.16">     while (0 &lt;= --i) </span>
<a href="#l17.17"></a><span id="l17.17">     {</span>
<a href="#l17.18"></a><span id="l17.18" class="difflineminus">-      char* string = (char*)mImpl-&gt;mArray[i];</span>
<a href="#l17.19"></a><span id="l17.19" class="difflineplus">+      char* string = ElementAt(i);</span>
<a href="#l17.20"></a><span id="l17.20">       PR_Free(string);</span>
<a href="#l17.21"></a><span id="l17.21">     }</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineminus">-    nsVoidArray::Clear();</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineminus">-  }</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineplus">+    nsTArray&lt;char*&gt;::Clear();</span>
<a href="#l17.25"></a><span id="l17.25"> }</span>
<a href="#l17.26"></a><span id="l17.26"> </span>
<a href="#l17.27"></a><span id="l17.27"> nsImapSearchResultSequence::~nsImapSearchResultSequence()</span>
<a href="#l17.28"></a><span id="l17.28"> {</span>
<a href="#l17.29"></a><span id="l17.29">   Clear();</span>
<a href="#l17.30"></a><span id="l17.30"> }</span>
<a href="#l17.31"></a><span id="l17.31"> </span>
<a href="#l17.32"></a><span id="l17.32"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/imap/src/nsImapSearchResults.h</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapSearchResults.h</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -1,19 +1,19 @@</span>
<a href="#l18.4"></a><span id="l18.4"> /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l18.5"></a><span id="l18.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l18.6"></a><span id="l18.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l18.7"></a><span id="l18.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l18.8"></a><span id="l18.8"> </span>
<a href="#l18.9"></a><span id="l18.9"> #ifndef nsImapSearchResults_h___</span>
<a href="#l18.10"></a><span id="l18.10"> #define nsImapSearchResults_h___</span>
<a href="#l18.11"></a><span id="l18.11"> </span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l18.14"></a><span id="l18.14"> </span>
<a href="#l18.15"></a><span id="l18.15" class="difflineminus">-class nsImapSearchResultSequence : public nsVoidArray</span>
<a href="#l18.16"></a><span id="l18.16" class="difflineplus">+class nsImapSearchResultSequence : public nsTArray&lt;char*&gt;</span>
<a href="#l18.17"></a><span id="l18.17"> {</span>
<a href="#l18.18"></a><span id="l18.18"> public:</span>
<a href="#l18.19"></a><span id="l18.19">     virtual ~nsImapSearchResultSequence();</span>
<a href="#l18.20"></a><span id="l18.20">     static nsImapSearchResultSequence *CreateSearchResultSequence();</span>
<a href="#l18.21"></a><span id="l18.21">     </span>
<a href="#l18.22"></a><span id="l18.22">     virtual void AddSearchResultLine(const char *searchLine);</span>
<a href="#l18.23"></a><span id="l18.23">     virtual void ResetSequence();</span>
<a href="#l18.24"></a><span id="l18.24">     void  Clear();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/import/eudora/src/nsEudoraAddress.cpp</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/import/eudora/src/nsEudoraAddress.cpp</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -32,17 +32,17 @@</span>
<a href="#l19.4"></a><span id="l19.4">   }</span>
<a href="#l19.5"></a><span id="l19.5"> </span>
<a href="#l19.6"></a><span id="l19.6"> </span>
<a href="#l19.7"></a><span id="l19.7"> // If we get a line longer than 16K it's just toooooo bad!</span>
<a href="#l19.8"></a><span id="l19.8"> #define kEudoraAddressBufferSz  (16 * 1024)</span>
<a href="#l19.9"></a><span id="l19.9"> </span>
<a href="#l19.10"></a><span id="l19.10"> </span>
<a href="#l19.11"></a><span id="l19.11"> #ifdef IMPORT_DEBUG</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-void DumpAliasArray(nsVoidArray&amp; a);</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+void DumpAliasArray(nsTArray&lt;CAliasEntry*&gt;&amp; a);</span>
<a href="#l19.14"></a><span id="l19.14"> #endif</span>
<a href="#l19.15"></a><span id="l19.15"> </span>
<a href="#l19.16"></a><span id="l19.16"> class CAliasData {</span>
<a href="#l19.17"></a><span id="l19.17"> public:</span>
<a href="#l19.18"></a><span id="l19.18">   CAliasData() {}</span>
<a href="#l19.19"></a><span id="l19.19">   ~CAliasData() {}</span>
<a href="#l19.20"></a><span id="l19.20"> </span>
<a href="#l19.21"></a><span id="l19.21">   bool Process(const char *pLine, int32_t len);</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineat">@@ -56,26 +56,26 @@ public:</span>
<a href="#l19.23"></a><span id="l19.23"> </span>
<a href="#l19.24"></a><span id="l19.24"> class CAliasEntry {</span>
<a href="#l19.25"></a><span id="l19.25"> public:</span>
<a href="#l19.26"></a><span id="l19.26">   CAliasEntry(nsCString&amp; name) { m_name = name;}</span>
<a href="#l19.27"></a><span id="l19.27">   ~CAliasEntry() { EmptyList();}</span>
<a href="#l19.28"></a><span id="l19.28"> </span>
<a href="#l19.29"></a><span id="l19.29">   void EmptyList(void) {</span>
<a href="#l19.30"></a><span id="l19.30">     CAliasData *pData;</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineminus">-    for (int32_t i = 0; i &lt; m_list.Count(); i++) {</span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+    for (int32_t i = 0; i &lt; m_list.Length(); i++) {</span>
<a href="#l19.33"></a><span id="l19.33">       pData = (CAliasData *)m_list.ElementAt(i);</span>
<a href="#l19.34"></a><span id="l19.34">       delete pData;</span>
<a href="#l19.35"></a><span id="l19.35">     }</span>
<a href="#l19.36"></a><span id="l19.36">     m_list.Clear();</span>
<a href="#l19.37"></a><span id="l19.37">   }</span>
<a href="#l19.38"></a><span id="l19.38"> </span>
<a href="#l19.39"></a><span id="l19.39"> public:</span>
<a href="#l19.40"></a><span id="l19.40">   nsCString  m_name;</span>
<a href="#l19.41"></a><span id="l19.41" class="difflineminus">-  nsVoidArray  m_list;</span>
<a href="#l19.42"></a><span id="l19.42" class="difflineplus">+  nsTArray&lt;CAliasData*&gt;  m_list;</span>
<a href="#l19.43"></a><span id="l19.43">   nsCString  m_notes;</span>
<a href="#l19.44"></a><span id="l19.44"> };</span>
<a href="#l19.45"></a><span id="l19.45"> </span>
<a href="#l19.46"></a><span id="l19.46"> nsEudoraAddress::nsEudoraAddress()</span>
<a href="#l19.47"></a><span id="l19.47"> {</span>
<a href="#l19.48"></a><span id="l19.48"> }</span>
<a href="#l19.49"></a><span id="l19.49"> </span>
<a href="#l19.50"></a><span id="l19.50"> nsEudoraAddress::~nsEudoraAddress()</span>
<a href="#l19.51"></a><span id="l19.51" class="difflineat">@@ -152,18 +152,18 @@ int32_t nsEudoraAddress::CountWhiteSpace</span>
<a href="#l19.52"></a><span id="l19.52">   }</span>
<a href="#l19.53"></a><span id="l19.53"> </span>
<a href="#l19.54"></a><span id="l19.54">   return cnt;</span>
<a href="#l19.55"></a><span id="l19.55"> }</span>
<a href="#l19.56"></a><span id="l19.56"> </span>
<a href="#l19.57"></a><span id="l19.57"> void nsEudoraAddress::EmptyAliases(void)</span>
<a href="#l19.58"></a><span id="l19.58"> {</span>
<a href="#l19.59"></a><span id="l19.59">   CAliasEntry *pData;</span>
<a href="#l19.60"></a><span id="l19.60" class="difflineminus">-  for (int32_t i = 0; i &lt; m_alias.Count(); i++) {</span>
<a href="#l19.61"></a><span id="l19.61" class="difflineminus">-    pData = (CAliasEntry *)m_alias.ElementAt(i);</span>
<a href="#l19.62"></a><span id="l19.62" class="difflineplus">+  for (int32_t i = 0; i &lt; m_alias.Length(); i++) {</span>
<a href="#l19.63"></a><span id="l19.63" class="difflineplus">+    pData = m_alias.ElementAt(i);</span>
<a href="#l19.64"></a><span id="l19.64">     delete pData;</span>
<a href="#l19.65"></a><span id="l19.65">   }</span>
<a href="#l19.66"></a><span id="l19.66">   m_alias.Clear();</span>
<a href="#l19.67"></a><span id="l19.67"> }</span>
<a href="#l19.68"></a><span id="l19.68"> </span>
<a href="#l19.69"></a><span id="l19.69"> void nsEudoraAddress::ProcessLine(const char *pLine, int32_t len, nsString&amp; errors)</span>
<a href="#l19.70"></a><span id="l19.70"> {</span>
<a href="#l19.71"></a><span id="l19.71">   if (len &lt; 6)</span>
<a href="#l19.72"></a><span id="l19.72" class="difflineat">@@ -326,17 +326,17 @@ void nsEudoraAddress::ProcessNote(const </span>
<a href="#l19.73"></a><span id="l19.73">     return;</span>
<a href="#l19.74"></a><span id="l19.74"> </span>
<a href="#l19.75"></a><span id="l19.75">   // Find the alias for this note and store the note data there!</span>
<a href="#l19.76"></a><span id="l19.76">   CAliasEntry *pEntry = nullptr;</span>
<a href="#l19.77"></a><span id="l19.77">   int32_t  idx = FindAlias(name);</span>
<a href="#l19.78"></a><span id="l19.78">   if (idx == -1)</span>
<a href="#l19.79"></a><span id="l19.79">     return;</span>
<a href="#l19.80"></a><span id="l19.80"> </span>
<a href="#l19.81"></a><span id="l19.81" class="difflineminus">-  pEntry = (CAliasEntry *) m_alias.ElementAt(idx);</span>
<a href="#l19.82"></a><span id="l19.82" class="difflineplus">+  pEntry = m_alias.ElementAt(idx);</span>
<a href="#l19.83"></a><span id="l19.83">   pEntry-&gt;m_notes.Append(pLine, len);</span>
<a href="#l19.84"></a><span id="l19.84">   pEntry-&gt;m_notes.Trim(kWhitespace);</span>
<a href="#l19.85"></a><span id="l19.85"> }</span>
<a href="#l19.86"></a><span id="l19.86"> </span>
<a href="#l19.87"></a><span id="l19.87"> </span>
<a href="#l19.88"></a><span id="l19.88"> </span>
<a href="#l19.89"></a><span id="l19.89"> int32_t nsEudoraAddress::CountQuote(const char *pLine, int32_t len)</span>
<a href="#l19.90"></a><span id="l19.90"> {</span>
<a href="#l19.91"></a><span id="l19.91" class="difflineat">@@ -528,68 +528,68 @@ bool CAliasData::Process(const char *pLi</span>
<a href="#l19.92"></a><span id="l19.92">   m_realName = StringHead(str, tCnt);</span>
<a href="#l19.93"></a><span id="l19.93">   m_realName.Trim(kWhitespace);</span>
<a href="#l19.94"></a><span id="l19.94">   m_email.Trim(kWhitespace);</span>
<a href="#l19.95"></a><span id="l19.95"> </span>
<a href="#l19.96"></a><span id="l19.96">   return !m_email.IsEmpty();</span>
<a href="#l19.97"></a><span id="l19.97"> }</span>
<a href="#l19.98"></a><span id="l19.98"> </span>
<a href="#l19.99"></a><span id="l19.99"> #ifdef IMPORT_DEBUG</span>
<a href="#l19.100"></a><span id="l19.100" class="difflineminus">-void DumpAliasArray(nsVoidArray&amp; a)</span>
<a href="#l19.101"></a><span id="l19.101" class="difflineplus">+void DumpAliasArray(nsTArray&lt;CAliasEntry*&gt;&amp; a)</span>
<a href="#l19.102"></a><span id="l19.102"> {</span>
<a href="#l19.103"></a><span id="l19.103">   CAliasEntry *pEntry;</span>
<a href="#l19.104"></a><span id="l19.104">   CAliasData *pData;</span>
<a href="#l19.105"></a><span id="l19.105"> </span>
<a href="#l19.106"></a><span id="l19.106" class="difflineminus">-  int32_t cnt = a.Count();</span>
<a href="#l19.107"></a><span id="l19.107" class="difflineplus">+  int32_t cnt = a.Length();</span>
<a href="#l19.108"></a><span id="l19.108">   IMPORT_LOG1(&quot;Alias list size: %ld\n&quot;, cnt);</span>
<a href="#l19.109"></a><span id="l19.109">   for (int32_t i = 0; i &lt; cnt; i++) {</span>
<a href="#l19.110"></a><span id="l19.110" class="difflineminus">-    pEntry = (CAliasEntry *)a.ElementAt(i);</span>
<a href="#l19.111"></a><span id="l19.111" class="difflineplus">+    pEntry = a.ElementAt(i);</span>
<a href="#l19.112"></a><span id="l19.112">     IMPORT_LOG1(&quot;\tAlias: %s\n&quot;, pEntry-&gt;m_name.get());</span>
<a href="#l19.113"></a><span id="l19.113" class="difflineminus">-    if (pEntry-&gt;m_list.Count() &gt; 1) {</span>
<a href="#l19.114"></a><span id="l19.114" class="difflineminus">-      IMPORT_LOG1(&quot;\tList count #%ld\n&quot;, pEntry-&gt;m_list.Count());</span>
<a href="#l19.115"></a><span id="l19.115" class="difflineminus">-      for (int32_t j = 0; j &lt; pEntry-&gt;m_list.Count(); j++) {</span>
<a href="#l19.116"></a><span id="l19.116" class="difflineplus">+    if (pEntry-&gt;m_list.Length() &gt; 1) {</span>
<a href="#l19.117"></a><span id="l19.117" class="difflineplus">+      IMPORT_LOG1(&quot;\tList count #%ld\n&quot;, pEntry-&gt;m_list.Length());</span>
<a href="#l19.118"></a><span id="l19.118" class="difflineplus">+      for (int32_t j = 0; j &lt; pEntry-&gt;m_list.Length(); j++) {</span>
<a href="#l19.119"></a><span id="l19.119">         pData = (CAliasData *) pEntry-&gt;m_list.ElementAt(j);</span>
<a href="#l19.120"></a><span id="l19.120">         IMPORT_LOG0(&quot;\t\t--------\n&quot;);</span>
<a href="#l19.121"></a><span id="l19.121">         IMPORT_LOG1(&quot;\t\temail: %s\n&quot;, pData-&gt;m_email.get());</span>
<a href="#l19.122"></a><span id="l19.122">         IMPORT_LOG1(&quot;\t\trealName: %s\n&quot;, pData-&gt;m_realName.get());</span>
<a href="#l19.123"></a><span id="l19.123">         IMPORT_LOG1(&quot;\t\tnickName: %s\n&quot;, pData-&gt;m_nickName.get());</span>
<a href="#l19.124"></a><span id="l19.124">       }</span>
<a href="#l19.125"></a><span id="l19.125">     }</span>
<a href="#l19.126"></a><span id="l19.126" class="difflineminus">-    else if (pEntry-&gt;m_list.Count()) {</span>
<a href="#l19.127"></a><span id="l19.127" class="difflineplus">+    else if (pEntry-&gt;m_list.Length()) {</span>
<a href="#l19.128"></a><span id="l19.128">       pData = (CAliasData *) pEntry-&gt;m_list.ElementAt(0);</span>
<a href="#l19.129"></a><span id="l19.129">       IMPORT_LOG1(&quot;\t\temail: %s\n&quot;, pData-&gt;m_email.get());</span>
<a href="#l19.130"></a><span id="l19.130">       IMPORT_LOG1(&quot;\t\trealName: %s\n&quot;, pData-&gt;m_realName.get());</span>
<a href="#l19.131"></a><span id="l19.131">       IMPORT_LOG1(&quot;\t\tnickName: %s\n&quot;, pData-&gt;m_nickName.get());</span>
<a href="#l19.132"></a><span id="l19.132">     }</span>
<a href="#l19.133"></a><span id="l19.133">   }</span>
<a href="#l19.134"></a><span id="l19.134"> }</span>
<a href="#l19.135"></a><span id="l19.135"> #endif</span>
<a href="#l19.136"></a><span id="l19.136"> </span>
<a href="#l19.137"></a><span id="l19.137"> CAliasEntry *nsEudoraAddress::ResolveAlias(nsCString&amp; name)</span>
<a href="#l19.138"></a><span id="l19.138"> {</span>
<a href="#l19.139"></a><span id="l19.139" class="difflineminus">-  int32_t  max = m_alias.Count();</span>
<a href="#l19.140"></a><span id="l19.140" class="difflineplus">+  int32_t  max = m_alias.Length();</span>
<a href="#l19.141"></a><span id="l19.141">   CAliasEntry *pEntry;</span>
<a href="#l19.142"></a><span id="l19.142">   for (int32_t i = 0; i &lt; max; i++) {</span>
<a href="#l19.143"></a><span id="l19.143" class="difflineminus">-    pEntry = (CAliasEntry *) m_alias.ElementAt(i);</span>
<a href="#l19.144"></a><span id="l19.144" class="difflineplus">+    pEntry = m_alias.ElementAt(i);</span>
<a href="#l19.145"></a><span id="l19.145">     if (name.Equals(pEntry-&gt;m_name, nsCaseInsensitiveCStringComparator()))</span>
<a href="#l19.146"></a><span id="l19.146">       return pEntry;</span>
<a href="#l19.147"></a><span id="l19.147">   }</span>
<a href="#l19.148"></a><span id="l19.148"> </span>
<a href="#l19.149"></a><span id="l19.149">   return nullptr;</span>
<a href="#l19.150"></a><span id="l19.150"> }</span>
<a href="#l19.151"></a><span id="l19.151"> </span>
<a href="#l19.152"></a><span id="l19.152" class="difflineminus">-void nsEudoraAddress::ResolveEntries(nsCString&amp; name, nsVoidArray&amp; list,</span>
<a href="#l19.153"></a><span id="l19.153" class="difflineminus">-                                     nsVoidArray&amp; result, bool addResolvedEntries,</span>
<a href="#l19.154"></a><span id="l19.154" class="difflineplus">+void nsEudoraAddress::ResolveEntries(nsCString&amp; name, nsTArray&lt;CAliasData*&gt;&amp; list,</span>
<a href="#l19.155"></a><span id="l19.155" class="difflineplus">+                                     nsTArray&lt;CAliasData*&gt;&amp; result, bool addResolvedEntries,</span>
<a href="#l19.156"></a><span id="l19.156">                                      bool wasResolved, int32_t&amp; numResolved)</span>
<a href="#l19.157"></a><span id="l19.157"> {</span>
<a href="#l19.158"></a><span id="l19.158">     /* a safe-guard against recursive entries */</span>
<a href="#l19.159"></a><span id="l19.159" class="difflineminus">-    if (result.Count() &gt; m_alias.Count())</span>
<a href="#l19.160"></a><span id="l19.160" class="difflineplus">+    if (result.Length() &gt; m_alias.Length())</span>
<a href="#l19.161"></a><span id="l19.161">         return;</span>
<a href="#l19.162"></a><span id="l19.162"> </span>
<a href="#l19.163"></a><span id="l19.163" class="difflineminus">-    int32_t         max = list.Count();</span>
<a href="#l19.164"></a><span id="l19.164" class="difflineplus">+    int32_t         max = list.Length();</span>
<a href="#l19.165"></a><span id="l19.165">     int32_t         i;</span>
<a href="#l19.166"></a><span id="l19.166">     CAliasData *    pData;</span>
<a href="#l19.167"></a><span id="l19.167">     CAliasEntry *   pEntry;</span>
<a href="#l19.168"></a><span id="l19.168">     for (i = 0; i &lt; max; i++) {</span>
<a href="#l19.169"></a><span id="l19.169">         pData = (CAliasData *)list.ElementAt(i);</span>
<a href="#l19.170"></a><span id="l19.170">         // resolve the email to an existing alias!</span>
<a href="#l19.171"></a><span id="l19.171">         if (!name.Equals(pData-&gt;m_email, nsCaseInsensitiveCStringComparator()) &amp;&amp;</span>
<a href="#l19.172"></a><span id="l19.172">              ((pEntry = ResolveAlias(pData-&gt;m_fullEntry)) != nullptr)) {</span>
<a href="#l19.173"></a><span id="l19.173" class="difflineat">@@ -612,54 +612,54 @@ void nsEudoraAddress::ResolveEntries(nsC</span>
<a href="#l19.174"></a><span id="l19.174">             result.AppendElement(pData);</span>
<a href="#l19.175"></a><span id="l19.175">         }</span>
<a href="#l19.176"></a><span id="l19.176">     }</span>
<a href="#l19.177"></a><span id="l19.177"> }</span>
<a href="#l19.178"></a><span id="l19.178"> </span>
<a href="#l19.179"></a><span id="l19.179"> int32_t nsEudoraAddress::FindAlias(nsCString&amp; name)</span>
<a href="#l19.180"></a><span id="l19.180"> {</span>
<a href="#l19.181"></a><span id="l19.181">   CAliasEntry *  pEntry;</span>
<a href="#l19.182"></a><span id="l19.182" class="difflineminus">-  int32_t      max = m_alias.Count();</span>
<a href="#l19.183"></a><span id="l19.183" class="difflineplus">+  int32_t      max = m_alias.Length();</span>
<a href="#l19.184"></a><span id="l19.184">   int32_t      i;</span>
<a href="#l19.185"></a><span id="l19.185"> </span>
<a href="#l19.186"></a><span id="l19.186">   for (i = 0; i &lt; max; i++) {</span>
<a href="#l19.187"></a><span id="l19.187" class="difflineminus">-    pEntry = (CAliasEntry *) m_alias.ElementAt(i);</span>
<a href="#l19.188"></a><span id="l19.188" class="difflineplus">+    pEntry = m_alias.ElementAt(i);</span>
<a href="#l19.189"></a><span id="l19.189">     if (pEntry-&gt;m_name == name)</span>
<a href="#l19.190"></a><span id="l19.190">       return i;</span>
<a href="#l19.191"></a><span id="l19.191">   }</span>
<a href="#l19.192"></a><span id="l19.192"> </span>
<a href="#l19.193"></a><span id="l19.193">   return -1;</span>
<a href="#l19.194"></a><span id="l19.194"> }</span>
<a href="#l19.195"></a><span id="l19.195"> </span>
<a href="#l19.196"></a><span id="l19.196"> void nsEudoraAddress::BuildABCards(uint32_t *pBytes, nsIAddrDatabase *pDb)</span>
<a href="#l19.197"></a><span id="l19.197"> {</span>
<a href="#l19.198"></a><span id="l19.198">   CAliasEntry *  pEntry;</span>
<a href="#l19.199"></a><span id="l19.199" class="difflineminus">-  int32_t      max = m_alias.Count();</span>
<a href="#l19.200"></a><span id="l19.200" class="difflineplus">+  int32_t      max = m_alias.Length();</span>
<a href="#l19.201"></a><span id="l19.201">   int32_t      i;</span>
<a href="#l19.202"></a><span id="l19.202" class="difflineminus">-  nsVoidArray    emailList;</span>
<a href="#l19.203"></a><span id="l19.203" class="difflineminus">-  nsVoidArray membersArray;// Remember group members.</span>
<a href="#l19.204"></a><span id="l19.204" class="difflineminus">-  nsVoidArray groupsArray; // Remember groups.</span>
<a href="#l19.205"></a><span id="l19.205" class="difflineplus">+  nsTArray&lt;CAliasData*&gt;    emailList;</span>
<a href="#l19.206"></a><span id="l19.206" class="difflineplus">+  nsTArray&lt;CAliasData*&gt; membersArray; // Remember group members.</span>
<a href="#l19.207"></a><span id="l19.207" class="difflineplus">+  nsTArray&lt;CAliasEntry*&gt; groupsArray; // Remember groups.</span>
<a href="#l19.208"></a><span id="l19.208"> </span>
<a href="#l19.209"></a><span id="l19.209">   // First off, run through the list and build person cards - groups/lists have to be done later</span>
<a href="#l19.210"></a><span id="l19.210">   for (i = 0; i &lt; max; i++) {</span>
<a href="#l19.211"></a><span id="l19.211">     int32_t   numResolved = 0;</span>
<a href="#l19.212"></a><span id="l19.212" class="difflineminus">-    pEntry = (CAliasEntry *) m_alias.ElementAt(i);</span>
<a href="#l19.213"></a><span id="l19.213" class="difflineplus">+    pEntry = m_alias.ElementAt(i);</span>
<a href="#l19.214"></a><span id="l19.214"> </span>
<a href="#l19.215"></a><span id="l19.215">     // false for 4th parameter tells ResolveEntries not to add resolved entries (avoids</span>
<a href="#l19.216"></a><span id="l19.216">     // duplicates as mailing lists are being resolved to other cards - the other cards that</span>
<a href="#l19.217"></a><span id="l19.217">     // are found have already been added and don't need to be added again).</span>
<a href="#l19.218"></a><span id="l19.218">     //</span>
<a href="#l19.219"></a><span id="l19.219">     // false for 5th parameter tells ResolveEntries that we're calling it - it's not being</span>
<a href="#l19.220"></a><span id="l19.220">     // called recursively by itself.</span>
<a href="#l19.221"></a><span id="l19.221">     ResolveEntries(pEntry-&gt;m_name, pEntry-&gt;m_list, emailList, false, false, numResolved);</span>
<a href="#l19.222"></a><span id="l19.222"> </span>
<a href="#l19.223"></a><span id="l19.223">     // Treat it as a group if there's more than one email address or if we</span>
<a href="#l19.224"></a><span id="l19.224">     // needed to resolve one or more aliases. We treat single aliases to</span>
<a href="#l19.225"></a><span id="l19.225">     // other aliases as a mailing list because there's no better equivalent.</span>
<a href="#l19.226"></a><span id="l19.226" class="difflineminus">-    if ((emailList.Count() &gt; 1) || (numResolved &gt; 0))</span>
<a href="#l19.227"></a><span id="l19.227" class="difflineplus">+    if ((emailList.Length() &gt; 1) || (numResolved &gt; 0))</span>
<a href="#l19.228"></a><span id="l19.228">     {</span>
<a href="#l19.229"></a><span id="l19.229">       // Remember group members uniquely and add them to db later.</span>
<a href="#l19.230"></a><span id="l19.230">       RememberGroupMembers(membersArray, emailList);</span>
<a href="#l19.231"></a><span id="l19.231">       // Remember groups and add them to db later.</span>
<a href="#l19.232"></a><span id="l19.232">       groupsArray.AppendElement(pEntry);</span>
<a href="#l19.233"></a><span id="l19.233">     }</span>
<a href="#l19.234"></a><span id="l19.234">     else</span>
<a href="#l19.235"></a><span id="l19.235">       AddSingleCard(pEntry, emailList, pDb);</span>
<a href="#l19.236"></a><span id="l19.236" class="difflineat">@@ -673,21 +673,21 @@ void nsEudoraAddress::BuildABCards(uint3</span>
<a href="#l19.237"></a><span id="l19.237">   }</span>
<a href="#l19.238"></a><span id="l19.238"> </span>
<a href="#l19.239"></a><span id="l19.239">   // Make sure group members exists before adding groups.</span>
<a href="#l19.240"></a><span id="l19.240">   nsresult rv = AddGroupMembersAsCards(membersArray, pDb);</span>
<a href="#l19.241"></a><span id="l19.241">   if (NS_FAILED(rv))</span>
<a href="#l19.242"></a><span id="l19.242">     return;</span>
<a href="#l19.243"></a><span id="l19.243"> </span>
<a href="#l19.244"></a><span id="l19.244">   // Now add the lists/groups (now that all cards have been added).</span>
<a href="#l19.245"></a><span id="l19.245" class="difflineminus">-  max = groupsArray.Count();</span>
<a href="#l19.246"></a><span id="l19.246" class="difflineplus">+  max = groupsArray.Length();</span>
<a href="#l19.247"></a><span id="l19.247">   for (i = 0; i &lt; max; i++)</span>
<a href="#l19.248"></a><span id="l19.248">   {</span>
<a href="#l19.249"></a><span id="l19.249">     int32_t   numResolved = 0;</span>
<a href="#l19.250"></a><span id="l19.250" class="difflineminus">-    pEntry = (CAliasEntry *) groupsArray.ElementAt(i);</span>
<a href="#l19.251"></a><span id="l19.251" class="difflineplus">+    pEntry = groupsArray.ElementAt(i);</span>
<a href="#l19.252"></a><span id="l19.252"> </span>
<a href="#l19.253"></a><span id="l19.253">     // false for 4th parameter tells ResolveEntries to add resolved entries so that we</span>
<a href="#l19.254"></a><span id="l19.254">     // can create the mailing list with references to all entries correctly.</span>
<a href="#l19.255"></a><span id="l19.255">     //</span>
<a href="#l19.256"></a><span id="l19.256">     // false for 5th parameter tells ResolveEntries that we're calling it - it's not being</span>
<a href="#l19.257"></a><span id="l19.257">     // called recursively by itself.</span>
<a href="#l19.258"></a><span id="l19.258">     ResolveEntries(pEntry-&gt;m_name, pEntry-&gt;m_list, emailList, true, false, numResolved);</span>
<a href="#l19.259"></a><span id="l19.259">     AddSingleList(pEntry, emailList, pDb);</span>
<a href="#l19.260"></a><span id="l19.260" class="difflineat">@@ -751,17 +751,17 @@ void nsEudoraAddress::SplitString(nsCStr</span>
<a href="#l19.261"></a><span id="l19.261">     idx= val1.RFindChar(10);</span>
<a href="#l19.262"></a><span id="l19.262">   if (idx != -1) {</span>
<a href="#l19.263"></a><span id="l19.263">     val2 = Substring(val1, idx + cnt);</span>
<a href="#l19.264"></a><span id="l19.264">     val1.SetLength(idx);</span>
<a href="#l19.265"></a><span id="l19.265">     SanitizeValue(val1);</span>
<a href="#l19.266"></a><span id="l19.266">   }</span>
<a href="#l19.267"></a><span id="l19.267"> }</span>
<a href="#l19.268"></a><span id="l19.268"> </span>
<a href="#l19.269"></a><span id="l19.269" class="difflineminus">-void nsEudoraAddress::AddSingleCard(CAliasEntry *pEntry, nsVoidArray &amp;emailList, nsIAddrDatabase *pDb)</span>
<a href="#l19.270"></a><span id="l19.270" class="difflineplus">+void nsEudoraAddress::AddSingleCard(CAliasEntry *pEntry, nsTArray&lt;CAliasData*&gt; &amp;emailList, nsIAddrDatabase *pDb)</span>
<a href="#l19.271"></a><span id="l19.271"> {</span>
<a href="#l19.272"></a><span id="l19.272">   // We always have a nickname and everything else is optional.</span>
<a href="#l19.273"></a><span id="l19.273">   // Map both home and work related fields to our address card. Eudora</span>
<a href="#l19.274"></a><span id="l19.274">   // fields that can't be mapped will be left in the 'note' field!</span>
<a href="#l19.275"></a><span id="l19.275">   nsIMdbRow* newRow = nullptr;</span>
<a href="#l19.276"></a><span id="l19.276">   pDb-&gt;GetNewRow(&amp;newRow);</span>
<a href="#l19.277"></a><span id="l19.277">   if (!newRow)</span>
<a href="#l19.278"></a><span id="l19.278">     return;</span>
<a href="#l19.279"></a><span id="l19.279" class="difflineat">@@ -858,17 +858,17 @@ void nsEudoraAddress::AddSingleCard(CAli</span>
<a href="#l19.280"></a><span id="l19.280">         // Store other web sites in the notes field, labeled nicely</span>
<a href="#l19.281"></a><span id="l19.281">         FormatExtraDataInNoteField(EUDORAIMPORT_ADDRESS_LABEL_OTHERWEB, otherWeb, noteUTF16);</span>
<a href="#l19.282"></a><span id="l19.282">       }</span>
<a href="#l19.283"></a><span id="l19.283"> </span>
<a href="#l19.284"></a><span id="l19.284">       noteUTF16.Append(NS_ConvertASCIItoUTF16(note));</span>
<a href="#l19.285"></a><span id="l19.285">     }</span>
<a href="#l19.286"></a><span id="l19.286">   }</span>
<a href="#l19.287"></a><span id="l19.287"> </span>
<a href="#l19.288"></a><span id="l19.288" class="difflineminus">-  CAliasData *pData = emailList.Count() ? (CAliasData *)emailList.ElementAt(0) : nullptr;</span>
<a href="#l19.289"></a><span id="l19.289" class="difflineplus">+  CAliasData *pData = emailList.Length() ? (CAliasData *)emailList.ElementAt(0) : nullptr;</span>
<a href="#l19.290"></a><span id="l19.290"> </span>
<a href="#l19.291"></a><span id="l19.291">   if (pData &amp;&amp; !pData-&gt;m_realName.IsEmpty())</span>
<a href="#l19.292"></a><span id="l19.292">     displayName = pData-&gt;m_realName;</span>
<a href="#l19.293"></a><span id="l19.293">   else if (!name.IsEmpty())</span>
<a href="#l19.294"></a><span id="l19.294">     displayName = name;</span>
<a href="#l19.295"></a><span id="l19.295">   else</span>
<a href="#l19.296"></a><span id="l19.296">     displayName = pEntry-&gt;m_name;</span>
<a href="#l19.297"></a><span id="l19.297"> </span>
<a href="#l19.298"></a><span id="l19.298" class="difflineat">@@ -1002,42 +1002,42 @@ void nsEudoraAddress::AddSingleCard(CAli</span>
<a href="#l19.299"></a><span id="l19.299">   }</span>
<a href="#l19.300"></a><span id="l19.300"> }</span>
<a href="#l19.301"></a><span id="l19.301"> </span>
<a href="#l19.302"></a><span id="l19.302"> //</span>
<a href="#l19.303"></a><span id="l19.303"> // Since there is no way to check if a card for a given email address already exists,</span>
<a href="#l19.304"></a><span id="l19.304"> // elements in 'membersArray' are make unique. So for each email address in 'emailList'</span>
<a href="#l19.305"></a><span id="l19.305"> // we check it in 'membersArray' and if it's not there then we add it to 'membersArray'.</span>
<a href="#l19.306"></a><span id="l19.306"> //</span>
<a href="#l19.307"></a><span id="l19.307" class="difflineminus">-void nsEudoraAddress::RememberGroupMembers(nsVoidArray &amp;membersArray, nsVoidArray &amp;emailList)</span>
<a href="#l19.308"></a><span id="l19.308" class="difflineplus">+void nsEudoraAddress::RememberGroupMembers(nsTArray&lt;CAliasData*&gt; &amp;membersArray, nsTArray&lt;CAliasData*&gt; &amp;emailList)</span>
<a href="#l19.309"></a><span id="l19.309"> {</span>
<a href="#l19.310"></a><span id="l19.310" class="difflineminus">-  int32_t cnt = emailList.Count();</span>
<a href="#l19.311"></a><span id="l19.311" class="difflineplus">+  int32_t cnt = emailList.Length();</span>
<a href="#l19.312"></a><span id="l19.312">   CAliasData *pData;</span>
<a href="#l19.313"></a><span id="l19.313"> </span>
<a href="#l19.314"></a><span id="l19.314">   for (int32_t i = 0; i &lt; cnt; i++)</span>
<a href="#l19.315"></a><span id="l19.315">   {</span>
<a href="#l19.316"></a><span id="l19.316">     pData = (CAliasData *)emailList.ElementAt(i);</span>
<a href="#l19.317"></a><span id="l19.317">     if (!pData)</span>
<a href="#l19.318"></a><span id="l19.318">       continue;</span>
<a href="#l19.319"></a><span id="l19.319"> </span>
<a href="#l19.320"></a><span id="l19.320" class="difflineminus">-    int32_t memberCnt = membersArray.Count();</span>
<a href="#l19.321"></a><span id="l19.321" class="difflineplus">+    int32_t memberCnt = membersArray.Length();</span>
<a href="#l19.322"></a><span id="l19.322">     int32_t j = 0;</span>
<a href="#l19.323"></a><span id="l19.323">     for (j = 0; j &lt; memberCnt; j++)</span>
<a href="#l19.324"></a><span id="l19.324">     {</span>
<a href="#l19.325"></a><span id="l19.325">       if (pData == membersArray.ElementAt(j))</span>
<a href="#l19.326"></a><span id="l19.326">         break;</span>
<a href="#l19.327"></a><span id="l19.327">     }</span>
<a href="#l19.328"></a><span id="l19.328">     if (j &gt;= memberCnt)</span>
<a href="#l19.329"></a><span id="l19.329">       membersArray.AppendElement(pData); // add to member list</span>
<a href="#l19.330"></a><span id="l19.330">   }</span>
<a href="#l19.331"></a><span id="l19.331"> }</span>
<a href="#l19.332"></a><span id="l19.332"> </span>
<a href="#l19.333"></a><span id="l19.333" class="difflineminus">-nsresult nsEudoraAddress::AddGroupMembersAsCards(nsVoidArray &amp;membersArray, nsIAddrDatabase *pDb)</span>
<a href="#l19.334"></a><span id="l19.334" class="difflineplus">+nsresult nsEudoraAddress::AddGroupMembersAsCards(nsTArray&lt;CAliasData*&gt; &amp;membersArray, nsIAddrDatabase *pDb)</span>
<a href="#l19.335"></a><span id="l19.335"> {</span>
<a href="#l19.336"></a><span id="l19.336" class="difflineminus">-  int32_t max = membersArray.Count();</span>
<a href="#l19.337"></a><span id="l19.337" class="difflineplus">+  int32_t max = membersArray.Length();</span>
<a href="#l19.338"></a><span id="l19.338">   CAliasData *pData;</span>
<a href="#l19.339"></a><span id="l19.339">   nsresult rv = NS_OK;</span>
<a href="#l19.340"></a><span id="l19.340">   nsCOMPtr &lt;nsIMdbRow&gt; newRow;</span>
<a href="#l19.341"></a><span id="l19.341">   nsAutoString uniStr;</span>
<a href="#l19.342"></a><span id="l19.342">   nsAutoCString  displayName;</span>
<a href="#l19.343"></a><span id="l19.343"> </span>
<a href="#l19.344"></a><span id="l19.344">   for (int32_t i = 0; i &lt; max; i++)</span>
<a href="#l19.345"></a><span id="l19.345">   {</span>
<a href="#l19.346"></a><span id="l19.346" class="difflineat">@@ -1060,17 +1060,17 @@ nsresult nsEudoraAddress::AddGroupMember</span>
<a href="#l19.347"></a><span id="l19.347">     ADD_FIELD_TO_DB_ROW(pDb, AddDisplayName, newRow, displayName, uniStr);</span>
<a href="#l19.348"></a><span id="l19.348">     ADD_FIELD_TO_DB_ROW(pDb, AddPrimaryEmail, newRow, pData-&gt;m_email, uniStr);</span>
<a href="#l19.349"></a><span id="l19.349">     rv = pDb-&gt;AddCardRowToDB(newRow);</span>
<a href="#l19.350"></a><span id="l19.350">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l19.351"></a><span id="l19.351">   }</span>
<a href="#l19.352"></a><span id="l19.352">   return rv;</span>
<a href="#l19.353"></a><span id="l19.353"> }</span>
<a href="#l19.354"></a><span id="l19.354"> </span>
<a href="#l19.355"></a><span id="l19.355" class="difflineminus">-nsresult nsEudoraAddress::AddSingleList(CAliasEntry *pEntry, nsVoidArray &amp;emailList, nsIAddrDatabase *pDb)</span>
<a href="#l19.356"></a><span id="l19.356" class="difflineplus">+nsresult nsEudoraAddress::AddSingleList(CAliasEntry *pEntry, nsTArray&lt;CAliasData*&gt; &amp;emailList, nsIAddrDatabase *pDb)</span>
<a href="#l19.357"></a><span id="l19.357"> {</span>
<a href="#l19.358"></a><span id="l19.358">   // Create a list.</span>
<a href="#l19.359"></a><span id="l19.359">   nsCOMPtr &lt;nsIMdbRow&gt; newRow;</span>
<a href="#l19.360"></a><span id="l19.360">   nsresult rv = pDb-&gt;GetNewListRow(getter_AddRefs(newRow));</span>
<a href="#l19.361"></a><span id="l19.361">   if (NS_FAILED(rv) || !newRow)</span>
<a href="#l19.362"></a><span id="l19.362">       return rv;</span>
<a href="#l19.363"></a><span id="l19.363"> </span>
<a href="#l19.364"></a><span id="l19.364">   // Extract name from notes, if any</span>
<a href="#l19.365"></a><span id="l19.365" class="difflineat">@@ -1087,17 +1087,17 @@ nsresult nsEudoraAddress::AddSingleList(</span>
<a href="#l19.366"></a><span id="l19.366">   rv = pDb-&gt;AddListName(newRow, name.IsEmpty() ? pEntry-&gt;m_name.get() : name.get());</span>
<a href="#l19.367"></a><span id="l19.367">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l19.368"></a><span id="l19.368"> </span>
<a href="#l19.369"></a><span id="l19.369">   // Add the name in pEntry as the list nickname, because it was the Eudora nickname</span>
<a href="#l19.370"></a><span id="l19.370">   rv = pDb-&gt;AddListNickName(newRow, pEntry-&gt;m_name.get());</span>
<a href="#l19.371"></a><span id="l19.371">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l19.372"></a><span id="l19.372"> </span>
<a href="#l19.373"></a><span id="l19.373">   // Now add the members.</span>
<a href="#l19.374"></a><span id="l19.374" class="difflineminus">-  int32_t max = emailList.Count();</span>
<a href="#l19.375"></a><span id="l19.375" class="difflineplus">+  int32_t max = emailList.Length();</span>
<a href="#l19.376"></a><span id="l19.376">   for (int32_t i = 0; i &lt; max; i++)</span>
<a href="#l19.377"></a><span id="l19.377">   {</span>
<a href="#l19.378"></a><span id="l19.378">     CAliasData *pData = (CAliasData *)emailList.ElementAt(i);</span>
<a href="#l19.379"></a><span id="l19.379">     nsAutoCString ldifValue(&quot;mail&quot;);</span>
<a href="#l19.380"></a><span id="l19.380">     ldifValue.Append(pData-&gt;m_email);</span>
<a href="#l19.381"></a><span id="l19.381">     rv = pDb-&gt;AddLdifListMember(newRow, ldifValue.get());</span>
<a href="#l19.382"></a><span id="l19.382">   }</span>
<a href="#l19.383"></a><span id="l19.383"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/import/eudora/src/nsEudoraAddress.h</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/import/eudora/src/nsEudoraAddress.h</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -4,17 +4,17 @@</span>
<a href="#l20.4"></a><span id="l20.4">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l20.5"></a><span id="l20.5">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l20.6"></a><span id="l20.6"> </span>
<a href="#l20.7"></a><span id="l20.7"> #ifndef nsEudoraAddress_h__</span>
<a href="#l20.8"></a><span id="l20.8"> #define nsEudoraAddress_h__</span>
<a href="#l20.9"></a><span id="l20.9"> </span>
<a href="#l20.10"></a><span id="l20.10"> #include &quot;nscore.h&quot;</span>
<a href="#l20.11"></a><span id="l20.11"> #include &quot;nsStringGlue.h&quot;</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l20.14"></a><span id="l20.14"> #include &quot;nsIFile.h&quot;</span>
<a href="#l20.15"></a><span id="l20.15"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l20.16"></a><span id="l20.16"> #include &quot;nsIImportService.h&quot;</span>
<a href="#l20.17"></a><span id="l20.17"> </span>
<a href="#l20.18"></a><span id="l20.18"> </span>
<a href="#l20.19"></a><span id="l20.19"> class nsIAddrDatabase;</span>
<a href="#l20.20"></a><span id="l20.20"> class CAliasEntry;</span>
<a href="#l20.21"></a><span id="l20.21"> class CAliasData;</span>
<a href="#l20.22"></a><span id="l20.22" class="difflineat">@@ -44,33 +44,33 @@ public:</span>
<a href="#l20.23"></a><span id="l20.23"> private:</span>
<a href="#l20.24"></a><span id="l20.24">   void       EmptyAliases(void);</span>
<a href="#l20.25"></a><span id="l20.25">   void      ProcessLine(const char *pLine, int32_t len, nsString&amp; errors);</span>
<a href="#l20.26"></a><span id="l20.26">   int32_t     CountWhiteSpace(const char *pLine, int32_t len);</span>
<a href="#l20.27"></a><span id="l20.27">   CAliasEntry  *  ProcessAlias(const char *pLine, int32_t len, nsString&amp; errors);</span>
<a href="#l20.28"></a><span id="l20.28">   void      ProcessNote(const char *pLine, int32_t len, nsString&amp; errors);</span>
<a href="#l20.29"></a><span id="l20.29">   int32_t      GetAliasName(const char *pLine, int32_t len, nsCString&amp; name);</span>
<a href="#l20.30"></a><span id="l20.30">   CAliasEntry *  ResolveAlias(nsCString&amp; name);</span>
<a href="#l20.31"></a><span id="l20.31" class="difflineminus">-  void       ResolveEntries(nsCString&amp; name, nsVoidArray&amp; list, nsVoidArray&amp; result, bool addResolvedEntries, bool wasResolved, int32_t&amp; numResolved);</span>
<a href="#l20.32"></a><span id="l20.32" class="difflineplus">+  void       ResolveEntries(nsCString&amp; name, nsTArray&lt;CAliasData*&gt;&amp; list, nsTArray&lt;CAliasData*&gt;&amp; result, bool addResolvedEntries, bool wasResolved, int32_t&amp; numResolved);</span>
<a href="#l20.33"></a><span id="l20.33">   void      BuildABCards(uint32_t *pBytes, nsIAddrDatabase *pDb);</span>
<a href="#l20.34"></a><span id="l20.34" class="difflineminus">-  void      AddSingleCard(CAliasEntry *pEntry, nsVoidArray &amp;emailList, nsIAddrDatabase *pDb);</span>
<a href="#l20.35"></a><span id="l20.35" class="difflineminus">-  nsresult  AddSingleList(CAliasEntry *pEntry, nsVoidArray &amp;emailList, nsIAddrDatabase *pDb);</span>
<a href="#l20.36"></a><span id="l20.36" class="difflineminus">-  nsresult  AddGroupMembersAsCards(nsVoidArray &amp;membersArray, nsIAddrDatabase *pDb);</span>
<a href="#l20.37"></a><span id="l20.37" class="difflineminus">-  void      RememberGroupMembers(nsVoidArray &amp;membersArray, nsVoidArray &amp;emailList);</span>
<a href="#l20.38"></a><span id="l20.38" class="difflineplus">+  void      AddSingleCard(CAliasEntry *pEntry, nsTArray&lt;CAliasData*&gt; &amp;emailList, nsIAddrDatabase *pDb);</span>
<a href="#l20.39"></a><span id="l20.39" class="difflineplus">+  nsresult  AddSingleList(CAliasEntry *pEntry, nsTArray&lt;CAliasData*&gt; &amp;emailList, nsIAddrDatabase *pDb);</span>
<a href="#l20.40"></a><span id="l20.40" class="difflineplus">+  nsresult  AddGroupMembersAsCards(nsTArray&lt;CAliasData*&gt; &amp;membersArray, nsIAddrDatabase *pDb);</span>
<a href="#l20.41"></a><span id="l20.41" class="difflineplus">+  void      RememberGroupMembers(nsTArray&lt;CAliasData*&gt; &amp;membersArray, nsTArray&lt;CAliasData*&gt; &amp;emailList);</span>
<a href="#l20.42"></a><span id="l20.42">   int32_t      FindAlias(nsCString&amp; name);</span>
<a href="#l20.43"></a><span id="l20.43">   void      ExtractNoteField(nsCString&amp; note, nsCString&amp; field, const char *pFieldName);</span>
<a href="#l20.44"></a><span id="l20.44">   void FormatExtraDataInNoteField(int32_t labelStringID, nsCString&amp; extraData, nsString&amp; noteUTF16);</span>
<a href="#l20.45"></a><span id="l20.45">   void      SanitizeValue(nsCString&amp; val);</span>
<a href="#l20.46"></a><span id="l20.46">   void      SplitString(nsCString&amp; val1, nsCString&amp; val2);</span>
<a href="#l20.47"></a><span id="l20.47"> </span>
<a href="#l20.48"></a><span id="l20.48"> public:</span>
<a href="#l20.49"></a><span id="l20.49">   static int32_t     CountQuote(const char *pLine, int32_t len);</span>
<a href="#l20.50"></a><span id="l20.50">   static int32_t     CountComment(const char *pLine, int32_t len);</span>
<a href="#l20.51"></a><span id="l20.51">   static int32_t     CountAngle(const char *pLine, int32_t len);</span>
<a href="#l20.52"></a><span id="l20.52"> </span>
<a href="#l20.53"></a><span id="l20.53"> private:</span>
<a href="#l20.54"></a><span id="l20.54" class="difflineminus">-  nsVoidArray    m_alias;</span>
<a href="#l20.55"></a><span id="l20.55" class="difflineplus">+  nsTArray&lt;CAliasEntry*&gt;  m_alias;</span>
<a href="#l20.56"></a><span id="l20.56"> };</span>
<a href="#l20.57"></a><span id="l20.57"> </span>
<a href="#l20.58"></a><span id="l20.58"> </span>
<a href="#l20.59"></a><span id="l20.59"> </span>
<a href="#l20.60"></a><span id="l20.60"> #endif /* nsEudoraAddress_h__ */</span>
<a href="#l20.61"></a><span id="l20.61"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/import/eudora/src/nsEudoraCompose.cpp</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/import/eudora/src/nsEudoraCompose.cpp</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -503,17 +503,17 @@ nsresult nsEudoraCompose::GetLocalAttach</span>
<a href="#l21.4"></a><span id="l21.4">   nsIURI      *url = nullptr;</span>
<a href="#l21.5"></a><span id="l21.5">   */</span>
<a href="#l21.6"></a><span id="l21.6">   nsresult rv;</span>
<a href="#l21.7"></a><span id="l21.7">   nsCOMPtr&lt;nsIMutableArray&gt; attachments (do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l21.8"></a><span id="l21.8">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l21.9"></a><span id="l21.9">   NS_IF_ADDREF(*aArray = attachments);</span>
<a href="#l21.10"></a><span id="l21.10">   int32_t count = 0;</span>
<a href="#l21.11"></a><span id="l21.11">   if (m_pAttachments)</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-    count = m_pAttachments-&gt;Count();</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+    count = m_pAttachments-&gt;Length();</span>
<a href="#l21.14"></a><span id="l21.14">   if (!count)</span>
<a href="#l21.15"></a><span id="l21.15">     return NS_OK;</span>
<a href="#l21.16"></a><span id="l21.16"> </span>
<a href="#l21.17"></a><span id="l21.17">   nsCString urlStr;</span>
<a href="#l21.18"></a><span id="l21.18">   ImportAttachment * pAttach;</span>
<a href="#l21.19"></a><span id="l21.19"> </span>
<a href="#l21.20"></a><span id="l21.20">   for (int32_t i = 0; i &lt; count; i++) {</span>
<a href="#l21.21"></a><span id="l21.21">     nsCOMPtr&lt;nsIMsgAttachedFile&gt; a(do_CreateInstance(NS_MSGATTACHEDFILE_CONTRACTID, &amp;rv));</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/import/eudora/src/nsEudoraCompose.h</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/import/eudora/src/nsEudoraCompose.h</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -8,17 +8,17 @@</span>
<a href="#l22.4"></a><span id="l22.4"> #define nsEudoraCompose_h__</span>
<a href="#l22.5"></a><span id="l22.5"> </span>
<a href="#l22.6"></a><span id="l22.6"> #include &quot;nscore.h&quot;</span>
<a href="#l22.7"></a><span id="l22.7"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l22.8"></a><span id="l22.8"> #include &quot;nsStringGlue.h&quot;</span>
<a href="#l22.9"></a><span id="l22.9"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l22.10"></a><span id="l22.10"> #include &quot;nsIFile.h&quot;</span>
<a href="#l22.11"></a><span id="l22.11"> #include &quot;nsIInputStream.h&quot;</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l22.14"></a><span id="l22.14"> #include &quot;nsIImportService.h&quot;</span>
<a href="#l22.15"></a><span id="l22.15"> </span>
<a href="#l22.16"></a><span id="l22.16"> #ifdef MOZILLA_INTERNAL_API</span>
<a href="#l22.17"></a><span id="l22.17"> #include &quot;nsNativeCharsetUtils.h&quot;</span>
<a href="#l22.18"></a><span id="l22.18"> #else</span>
<a href="#l22.19"></a><span id="l22.19"> #include &quot;nsMsgI18N.h&quot;</span>
<a href="#l22.20"></a><span id="l22.20"> #define NS_CopyNativeToUnicode(source, dest) \</span>
<a href="#l22.21"></a><span id="l22.21">         nsMsgI18NConvertToUnicode(nsMsgI18NFileSystemCharset(), source, dest)</span>
<a href="#l22.22"></a><span id="l22.22" class="difflineat">@@ -112,17 +112,17 @@ class nsEudoraCompose {</span>
<a href="#l22.23"></a><span id="l22.23"> public:</span>
<a href="#l22.24"></a><span id="l22.24">   nsEudoraCompose();</span>
<a href="#l22.25"></a><span id="l22.25">   ~nsEudoraCompose();</span>
<a href="#l22.26"></a><span id="l22.26"> </span>
<a href="#l22.27"></a><span id="l22.27">   nsresult  SendTheMessage(nsIFile *pMailImportLocation, nsIFile **pMsg);</span>
<a href="#l22.28"></a><span id="l22.28"> </span>
<a href="#l22.29"></a><span id="l22.29">   void    SetBody(const char *pBody, int32_t len, nsCString &amp;bodyType) { m_pBody = pBody; m_bodyLen = len; m_bodyType = bodyType;}</span>
<a href="#l22.30"></a><span id="l22.30">   void    SetHeaders(const char *pHeaders, int32_t len) { m_pHeaders = pHeaders; m_headerLen = len;}</span>
<a href="#l22.31"></a><span id="l22.31" class="difflineminus">-  void    SetAttachments(nsVoidArray *pAttachments) { m_pAttachments = pAttachments;}</span>
<a href="#l22.32"></a><span id="l22.32" class="difflineplus">+  void    SetAttachments(nsTArray&lt;ImportAttachment*&gt; *pAttachments) { m_pAttachments = pAttachments;}</span>
<a href="#l22.33"></a><span id="l22.33">   void    SetDefaultDate(nsCString date) { m_defaultDate = date;}</span>
<a href="#l22.34"></a><span id="l22.34"> </span>
<a href="#l22.35"></a><span id="l22.35">   nsresult  CopyComposedMessage(nsCString&amp; fromLine, nsIFile *pSrc, nsIOutputStream *pDst, SimpleBufferTonyRCopiedOnce&amp; copy);</span>
<a href="#l22.36"></a><span id="l22.36"> </span>
<a href="#l22.37"></a><span id="l22.37">   static nsresult  FillMailBuffer(ReadFileState *pState, SimpleBufferTonyRCopiedOnce&amp; read);</span>
<a href="#l22.38"></a><span id="l22.38">   static nsresult CreateIdentity(void);</span>
<a href="#l22.39"></a><span id="l22.39">   static void    ReleaseIdentity(void);</span>
<a href="#l22.40"></a><span id="l22.40"> </span>
<a href="#l22.41"></a><span id="l22.41" class="difflineat">@@ -147,17 +147,17 @@ private:</span>
<a href="#l22.42"></a><span id="l22.42">   int32_t    IsEndHeaders(SimpleBufferTonyRCopiedOnce&amp; data);</span>
<a href="#l22.43"></a><span id="l22.43">   int32_t    IsSpecialHeader(const char *pHeader);</span>
<a href="#l22.44"></a><span id="l22.44">   nsresult  WriteHeaders(nsIOutputStream *pDst, SimpleBufferTonyRCopiedOnce&amp; newHeaders);</span>
<a href="#l22.45"></a><span id="l22.45">   bool      IsReplaceHeader(const char *pHeader);</span>
<a href="#l22.46"></a><span id="l22.46"> </span>
<a href="#l22.47"></a><span id="l22.47"> private:</span>
<a href="#l22.48"></a><span id="l22.48">   static nsIMsgIdentity *    s_pIdentity;</span>
<a href="#l22.49"></a><span id="l22.49"> </span>
<a href="#l22.50"></a><span id="l22.50" class="difflineminus">-  nsVoidArray *      m_pAttachments;</span>
<a href="#l22.51"></a><span id="l22.51" class="difflineplus">+  nsTArray&lt;ImportAttachment*&gt; *  m_pAttachments;</span>
<a href="#l22.52"></a><span id="l22.52">   nsIMsgSendListener *  m_pListener;</span>
<a href="#l22.53"></a><span id="l22.53">   nsIMsgCompFields *    m_pMsgFields;</span>
<a href="#l22.54"></a><span id="l22.54">   nsCOMPtr&lt;nsIIOService&gt; m_pIOService;</span>
<a href="#l22.55"></a><span id="l22.55">   int32_t          m_headerLen;</span>
<a href="#l22.56"></a><span id="l22.56">   const char *      m_pHeaders;</span>
<a href="#l22.57"></a><span id="l22.57">   int32_t          m_bodyLen;</span>
<a href="#l22.58"></a><span id="l22.58">   const char *      m_pBody;</span>
<a href="#l22.59"></a><span id="l22.59">   nsCString        m_bodyType;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mailnews/import/eudora/src/nsEudoraMailbox.cpp</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mailnews/import/eudora/src/nsEudoraMailbox.cpp</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -1211,17 +1211,17 @@ nsresult nsEudoraMailbox::WriteFromSep(n</span>
<a href="#l23.4"></a><span id="l23.4">   nsresult rv = pDst-&gt;Write(eudoraFromLine, m_fromLen, &amp;written);</span>
<a href="#l23.5"></a><span id="l23.5">   if (NS_SUCCEEDED(rv) &amp;&amp; (written != m_fromLen))</span>
<a href="#l23.6"></a><span id="l23.6">     return NS_ERROR_FAILURE;</span>
<a href="#l23.7"></a><span id="l23.7">   return rv;</span>
<a href="#l23.8"></a><span id="l23.8"> }</span>
<a href="#l23.9"></a><span id="l23.9"> </span>
<a href="#l23.10"></a><span id="l23.10"> void nsEudoraMailbox::EmptyAttachments(void)</span>
<a href="#l23.11"></a><span id="l23.11"> {</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-  int32_t max = m_attachments.Count();</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+  int32_t max = m_attachments.Length();</span>
<a href="#l23.14"></a><span id="l23.14">   ImportAttachment *  pAttach;</span>
<a href="#l23.15"></a><span id="l23.15">   for (int32_t i = 0; i &lt; max; i++) {</span>
<a href="#l23.16"></a><span id="l23.16">     pAttach = (ImportAttachment *) m_attachments.ElementAt(i);</span>
<a href="#l23.17"></a><span id="l23.17">     if (pAttach) {</span>
<a href="#l23.18"></a><span id="l23.18">       NS_Free(pAttach-&gt;description);</span>
<a href="#l23.19"></a><span id="l23.19">       NS_Free(pAttach-&gt;mimeType);</span>
<a href="#l23.20"></a><span id="l23.20">       delete pAttach;</span>
<a href="#l23.21"></a><span id="l23.21">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mailnews/import/eudora/src/nsEudoraMailbox.h</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mailnews/import/eudora/src/nsEudoraMailbox.h</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -4,17 +4,17 @@</span>
<a href="#l24.4"></a><span id="l24.4">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l24.5"></a><span id="l24.5">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l24.6"></a><span id="l24.6"> </span>
<a href="#l24.7"></a><span id="l24.7"> #ifndef nsEudoraMailbox_h__</span>
<a href="#l24.8"></a><span id="l24.8"> #define nsEudoraMailbox_h__</span>
<a href="#l24.9"></a><span id="l24.9"> </span>
<a href="#l24.10"></a><span id="l24.10"> #include &quot;nscore.h&quot;</span>
<a href="#l24.11"></a><span id="l24.11"> #include &quot;nsStringGlue.h&quot;</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l24.14"></a><span id="l24.14"> #include &quot;nsIFile.h&quot;</span>
<a href="#l24.15"></a><span id="l24.15"> #include &quot;nsEudoraCompose.h&quot;</span>
<a href="#l24.16"></a><span id="l24.16"> </span>
<a href="#l24.17"></a><span id="l24.17"> class nsIOutputStream;</span>
<a href="#l24.18"></a><span id="l24.18"> class nsIMutableArray;</span>
<a href="#l24.19"></a><span id="l24.19"> </span>
<a href="#l24.20"></a><span id="l24.20"> /////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l24.21"></a><span id="l24.21"> /////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineat">@@ -187,15 +187,15 @@ private:</span>
<a href="#l24.23"></a><span id="l24.23">   static int      IsMonthStr(const char *pStr);</span>
<a href="#l24.24"></a><span id="l24.24"> </span>
<a href="#l24.25"></a><span id="l24.25"> protected:</span>
<a href="#l24.26"></a><span id="l24.26">   nsCOMPtr &lt;nsIFile&gt;    m_mailImportLocation;</span>
<a href="#l24.27"></a><span id="l24.27"> </span>
<a href="#l24.28"></a><span id="l24.28"> private:</span>
<a href="#l24.29"></a><span id="l24.29">   int64_t    m_mailSize;</span>
<a href="#l24.30"></a><span id="l24.30">   uint32_t      m_fromLen;</span>
<a href="#l24.31"></a><span id="l24.31" class="difflineminus">-  nsVoidArray    m_attachments;</span>
<a href="#l24.32"></a><span id="l24.32" class="difflineplus">+  nsTArray&lt;ImportAttachment*&gt;  m_attachments;</span>
<a href="#l24.33"></a><span id="l24.33"> };</span>
<a href="#l24.34"></a><span id="l24.34"> </span>
<a href="#l24.35"></a><span id="l24.35"> </span>
<a href="#l24.36"></a><span id="l24.36"> </span>
<a href="#l24.37"></a><span id="l24.37"> #endif /* nsEudoraMailbox_h__ */</span>
<a href="#l24.38"></a><span id="l24.38"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/import/oexpress/nsOEScanBoxes.cpp</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/import/oexpress/nsOEScanBoxes.cpp</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -42,24 +42,24 @@ nsOEScanBoxes::nsOEScanBoxes()</span>
<a href="#l25.4"></a><span id="l25.4"> {</span>
<a href="#l25.5"></a><span id="l25.5">   m_pFirst = nullptr;</span>
<a href="#l25.6"></a><span id="l25.6"> }</span>
<a href="#l25.7"></a><span id="l25.7"> </span>
<a href="#l25.8"></a><span id="l25.8"> nsOEScanBoxes::~nsOEScanBoxes()</span>
<a href="#l25.9"></a><span id="l25.9"> {</span>
<a href="#l25.10"></a><span id="l25.10">   int i, max;</span>
<a href="#l25.11"></a><span id="l25.11">   MailboxEntry *pEntry;</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-  for (i = 0, max = m_entryArray.Count(); i &lt; max; i++) {</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineminus">-    pEntry = (MailboxEntry *) m_entryArray.ElementAt(i);</span>
<a href="#l25.14"></a><span id="l25.14" class="difflineplus">+  for (i = 0, max = m_entryArray.Length(); i &lt; max; i++) {</span>
<a href="#l25.15"></a><span id="l25.15" class="difflineplus">+    pEntry = m_entryArray.ElementAt(i);</span>
<a href="#l25.16"></a><span id="l25.16">     delete pEntry;</span>
<a href="#l25.17"></a><span id="l25.17">   }</span>
<a href="#l25.18"></a><span id="l25.18">   // Now free the unprocessed child entries (ie, those without parents for some reason).</span>
<a href="#l25.19"></a><span id="l25.19" class="difflineminus">-  for (i = 0, max = m_pendingChildArray.Count(); i &lt; max; i++)</span>
<a href="#l25.20"></a><span id="l25.20" class="difflineplus">+  for (i = 0, max = m_pendingChildArray.Length(); i &lt; max; i++)</span>
<a href="#l25.21"></a><span id="l25.21">   {</span>
<a href="#l25.22"></a><span id="l25.22" class="difflineminus">-    pEntry = (MailboxEntry *) m_pendingChildArray.ElementAt(i);</span>
<a href="#l25.23"></a><span id="l25.23" class="difflineplus">+    pEntry = m_pendingChildArray.ElementAt(i);</span>
<a href="#l25.24"></a><span id="l25.24">     if (!pEntry-&gt;processed)</span>
<a href="#l25.25"></a><span id="l25.25">       delete pEntry;</span>
<a href="#l25.26"></a><span id="l25.26">   }</span>
<a href="#l25.27"></a><span id="l25.27"> }</span>
<a href="#l25.28"></a><span id="l25.28"> </span>
<a href="#l25.29"></a><span id="l25.29"> /*</span>
<a href="#l25.30"></a><span id="l25.30">  3.x &amp; 4.x registry</span>
<a href="#l25.31"></a><span id="l25.31">   Software/Microsoft/Outlook Express/</span>
<a href="#l25.32"></a><span id="l25.32" class="difflineat">@@ -179,19 +179,19 @@ bool nsOEScanBoxes::GetMailboxes(nsIFile</span>
<a href="#l25.33"></a><span id="l25.33"> </span>
<a href="#l25.34"></a><span id="l25.34">   return result;</span>
<a href="#l25.35"></a><span id="l25.35"> }</span>
<a href="#l25.36"></a><span id="l25.36"> </span>
<a href="#l25.37"></a><span id="l25.37"> </span>
<a href="#l25.38"></a><span id="l25.38"> </span>
<a href="#l25.39"></a><span id="l25.39"> void nsOEScanBoxes::Reset(void)</span>
<a href="#l25.40"></a><span id="l25.40"> {</span>
<a href="#l25.41"></a><span id="l25.41" class="difflineminus">-  int max = m_entryArray.Count();</span>
<a href="#l25.42"></a><span id="l25.42" class="difflineplus">+  int max = m_entryArray.Length();</span>
<a href="#l25.43"></a><span id="l25.43">   for (int i = 0; i &lt; max; i++) {</span>
<a href="#l25.44"></a><span id="l25.44" class="difflineminus">-    MailboxEntry *pEntry = (MailboxEntry *) m_entryArray.ElementAt(i);</span>
<a href="#l25.45"></a><span id="l25.45" class="difflineplus">+    MailboxEntry *pEntry = m_entryArray.ElementAt(i);</span>
<a href="#l25.46"></a><span id="l25.46">     delete pEntry;</span>
<a href="#l25.47"></a><span id="l25.47">   }</span>
<a href="#l25.48"></a><span id="l25.48">   m_entryArray.Clear();</span>
<a href="#l25.49"></a><span id="l25.49">   m_pFirst = nullptr;</span>
<a href="#l25.50"></a><span id="l25.50"> }</span>
<a href="#l25.51"></a><span id="l25.51"> </span>
<a href="#l25.52"></a><span id="l25.52"> </span>
<a href="#l25.53"></a><span id="l25.53"> bool nsOEScanBoxes::FindMailBoxes(nsIFile* descFile)</span>
<a href="#l25.54"></a><span id="l25.54" class="difflineat">@@ -265,17 +265,17 @@ bool nsOEScanBoxes::FindMailBoxes(nsIFil</span>
<a href="#l25.55"></a><span id="l25.55">     if (!next)</span>
<a href="#l25.56"></a><span id="l25.56">       done = true;</span>
<a href="#l25.57"></a><span id="l25.57">   }</span>
<a href="#l25.58"></a><span id="l25.58"> </span>
<a href="#l25.59"></a><span id="l25.59">   MailboxEntry *pZero = GetIndexEntry(0);</span>
<a href="#l25.60"></a><span id="l25.60">   if (pZero)</span>
<a href="#l25.61"></a><span id="l25.61">     m_pFirst = GetIndexEntry(pZero-&gt;child);</span>
<a href="#l25.62"></a><span id="l25.62"> </span>
<a href="#l25.63"></a><span id="l25.63" class="difflineminus">-  IMPORT_LOG1(&quot;Read the folders.nch file, found %ld mailboxes\n&quot;, (long) m_entryArray.Count());</span>
<a href="#l25.64"></a><span id="l25.64" class="difflineplus">+  IMPORT_LOG1(&quot;Read the folders.nch file, found %ld mailboxes\n&quot;, (long) m_entryArray.Length());</span>
<a href="#l25.65"></a><span id="l25.65"> </span>
<a href="#l25.66"></a><span id="l25.66">   return true;</span>
<a href="#l25.67"></a><span id="l25.67"> }</span>
<a href="#l25.68"></a><span id="l25.68"> </span>
<a href="#l25.69"></a><span id="l25.69"> bool nsOEScanBoxes::Find50MailBoxes(nsIFile* descFile)</span>
<a href="#l25.70"></a><span id="l25.70"> {</span>
<a href="#l25.71"></a><span id="l25.71">   Reset();</span>
<a href="#l25.72"></a><span id="l25.72"> </span>
<a href="#l25.73"></a><span id="l25.73" class="difflineat">@@ -422,17 +422,17 @@ bool nsOEScanBoxes::Find50MailBoxes(nsIF</span>
<a href="#l25.74"></a><span id="l25.74">     }</span>
<a href="#l25.75"></a><span id="l25.75"> </span>
<a href="#l25.76"></a><span id="l25.76">     delete [] pBytes;</span>
<a href="#l25.77"></a><span id="l25.77">   }</span>
<a href="#l25.78"></a><span id="l25.78"> </span>
<a href="#l25.79"></a><span id="l25.79"> </span>
<a href="#l25.80"></a><span id="l25.80">   delete [] pIndex;</span>
<a href="#l25.81"></a><span id="l25.81"> </span>
<a href="#l25.82"></a><span id="l25.82" class="difflineminus">-  return m_entryArray.Count();</span>
<a href="#l25.83"></a><span id="l25.83" class="difflineplus">+  return m_entryArray.Length();</span>
<a href="#l25.84"></a><span id="l25.84"> }</span>
<a href="#l25.85"></a><span id="l25.85"> </span>
<a href="#l25.86"></a><span id="l25.86"> nsOEScanBoxes::MailboxEntry *nsOEScanBoxes::NewMailboxEntry(uint32_t id, uint32_t parent, const char *prettyName, char *pFileName)</span>
<a href="#l25.87"></a><span id="l25.87"> {</span>
<a href="#l25.88"></a><span id="l25.88">   MailboxEntry *pEntry = new MailboxEntry();</span>
<a href="#l25.89"></a><span id="l25.89">   if (!pEntry)</span>
<a href="#l25.90"></a><span id="l25.90">     return nullptr;</span>
<a href="#l25.91"></a><span id="l25.91"> </span>
<a href="#l25.92"></a><span id="l25.92" class="difflineat">@@ -443,23 +443,23 @@ nsOEScanBoxes::MailboxEntry *nsOEScanBox</span>
<a href="#l25.93"></a><span id="l25.93">   pEntry-&gt;sibling = -1;</span>
<a href="#l25.94"></a><span id="l25.94">   pEntry-&gt;processed =  false;</span>
<a href="#l25.95"></a><span id="l25.95">   NS_CopyNativeToUnicode(nsDependentCString(prettyName), pEntry-&gt;mailName);</span>
<a href="#l25.96"></a><span id="l25.96">   if (pFileName)</span>
<a href="#l25.97"></a><span id="l25.97">     pEntry-&gt;fileName = pFileName;</span>
<a href="#l25.98"></a><span id="l25.98">   return pEntry;</span>
<a href="#l25.99"></a><span id="l25.99"> }</span>
<a href="#l25.100"></a><span id="l25.100"> </span>
<a href="#l25.101"></a><span id="l25.101" class="difflineminus">-void nsOEScanBoxes::ProcessPendingChildEntries(uint32_t parent, uint32_t rootIndex, nsVoidArray  &amp;childArray)</span>
<a href="#l25.102"></a><span id="l25.102" class="difflineplus">+void nsOEScanBoxes::ProcessPendingChildEntries(uint32_t parent, uint32_t rootIndex, nsTArray&lt;MailboxEntry*&gt;  &amp;childArray)</span>
<a href="#l25.103"></a><span id="l25.103"> {</span>
<a href="#l25.104"></a><span id="l25.104">   int32_t i, max;</span>
<a href="#l25.105"></a><span id="l25.105">   MailboxEntry *pEntry;</span>
<a href="#l25.106"></a><span id="l25.106" class="difflineminus">-  for (i = 0, max = childArray.Count(); i &lt; max; i++)</span>
<a href="#l25.107"></a><span id="l25.107" class="difflineplus">+  for (i = 0, max = childArray.Length(); i &lt; max; i++)</span>
<a href="#l25.108"></a><span id="l25.108">   {</span>
<a href="#l25.109"></a><span id="l25.109" class="difflineminus">-    pEntry = (MailboxEntry *) childArray.ElementAt(i);</span>
<a href="#l25.110"></a><span id="l25.110" class="difflineplus">+    pEntry = childArray.ElementAt(i);</span>
<a href="#l25.111"></a><span id="l25.111">     if ((!pEntry-&gt;processed) &amp;&amp; (pEntry-&gt;parent == parent))</span>
<a href="#l25.112"></a><span id="l25.112">     {</span>
<a href="#l25.113"></a><span id="l25.113">       AddChildEntry(pEntry, rootIndex);</span>
<a href="#l25.114"></a><span id="l25.114">       pEntry-&gt;processed =  true; // indicate it's been processed.</span>
<a href="#l25.115"></a><span id="l25.115">       // See if there are unprocessed child folders for this child in the</span>
<a href="#l25.116"></a><span id="l25.116">       // array as well (ie, both child and grand-child are on the list).</span>
<a href="#l25.117"></a><span id="l25.117">       ProcessPendingChildEntries(pEntry-&gt;index, rootIndex, childArray);</span>
<a href="#l25.118"></a><span id="l25.118">     }</span>
<a href="#l25.119"></a><span id="l25.119" class="difflineat">@@ -467,19 +467,19 @@ void nsOEScanBoxes::ProcessPendingChildE</span>
<a href="#l25.120"></a><span id="l25.120"> }</span>
<a href="#l25.121"></a><span id="l25.121"> </span>
<a href="#l25.122"></a><span id="l25.122"> void nsOEScanBoxes::RemoveProcessedChildEntries()</span>
<a href="#l25.123"></a><span id="l25.123"> {</span>
<a href="#l25.124"></a><span id="l25.124">   // Remove already processed entries from the pending list. Note that these entries are also</span>
<a href="#l25.125"></a><span id="l25.125">   // on 'm_entryArray' list so we don't want to deallocate the space for the entries now.</span>
<a href="#l25.126"></a><span id="l25.126">   MailboxEntry * pEntry;</span>
<a href="#l25.127"></a><span id="l25.127">   int32_t i;</span>
<a href="#l25.128"></a><span id="l25.128" class="difflineminus">-  for (i = m_pendingChildArray.Count()-1; i &gt;= 0; i--)</span>
<a href="#l25.129"></a><span id="l25.129" class="difflineplus">+  for (i = m_pendingChildArray.Length()-1; i &gt;= 0; i--)</span>
<a href="#l25.130"></a><span id="l25.130">   {</span>
<a href="#l25.131"></a><span id="l25.131" class="difflineminus">-    pEntry = (MailboxEntry *) m_pendingChildArray.ElementAt(i);</span>
<a href="#l25.132"></a><span id="l25.132" class="difflineplus">+    pEntry = m_pendingChildArray.ElementAt(i);</span>
<a href="#l25.133"></a><span id="l25.133">     if (pEntry-&gt;processed)</span>
<a href="#l25.134"></a><span id="l25.134">       m_pendingChildArray.RemoveElementAt(i);</span>
<a href="#l25.135"></a><span id="l25.135">   }</span>
<a href="#l25.136"></a><span id="l25.136"> }</span>
<a href="#l25.137"></a><span id="l25.137"> </span>
<a href="#l25.138"></a><span id="l25.138"> void nsOEScanBoxes::AddChildEntry(MailboxEntry *pEntry, uint32_t rootIndex)</span>
<a href="#l25.139"></a><span id="l25.139"> {</span>
<a href="#l25.140"></a><span id="l25.140">   if (!m_pFirst) {</span>
<a href="#l25.141"></a><span id="l25.141" class="difflineat">@@ -574,18 +574,18 @@ bool nsOEScanBoxes::Scan50MailboxDir(nsI</span>
<a href="#l25.142"></a><span id="l25.142">             pEntry-&gt;fileName = fName.get();</span>
<a href="#l25.143"></a><span id="l25.143">             NS_CopyNativeToUnicode(fName, pEntry-&gt;mailName);</span>
<a href="#l25.144"></a><span id="l25.144">             m_entryArray.AppendElement(pEntry);</span>
<a href="#l25.145"></a><span id="l25.145">           }</span>
<a href="#l25.146"></a><span id="l25.146">       }</span>
<a href="#l25.147"></a><span id="l25.147">     }</span>
<a href="#l25.148"></a><span id="l25.148">   }</span>
<a href="#l25.149"></a><span id="l25.149"> </span>
<a href="#l25.150"></a><span id="l25.150" class="difflineminus">-  if (m_entryArray.Count() &gt; 0) {</span>
<a href="#l25.151"></a><span id="l25.151" class="difflineminus">-    pEntry = (MailboxEntry *)m_entryArray.ElementAt(m_entryArray.Count() - 1);</span>
<a href="#l25.152"></a><span id="l25.152" class="difflineplus">+  if (m_entryArray.Length() &gt; 0) {</span>
<a href="#l25.153"></a><span id="l25.153" class="difflineplus">+    pEntry = m_entryArray.ElementAt(m_entryArray.Length() - 1);</span>
<a href="#l25.154"></a><span id="l25.154">     pEntry-&gt;sibling = -1;</span>
<a href="#l25.155"></a><span id="l25.155">     return true;</span>
<a href="#l25.156"></a><span id="l25.156">   }</span>
<a href="#l25.157"></a><span id="l25.157"> </span>
<a href="#l25.158"></a><span id="l25.158">   return false;</span>
<a href="#l25.159"></a><span id="l25.159"> }</span>
<a href="#l25.160"></a><span id="l25.160"> </span>
<a href="#l25.161"></a><span id="l25.161"> void nsOEScanBoxes::ScanMailboxDir(nsIFile * srcDir)</span>
<a href="#l25.162"></a><span id="l25.162" class="difflineat">@@ -639,30 +639,30 @@ void nsOEScanBoxes::ScanMailboxDir(nsIFi</span>
<a href="#l25.163"></a><span id="l25.163">           pEntry-&gt;fileName = pLeaf;</span>
<a href="#l25.164"></a><span id="l25.164">           pLeaf.SetLength(sLen - 4);</span>
<a href="#l25.165"></a><span id="l25.165">           NS_CopyNativeToUnicode(pLeaf, pEntry-&gt;mailName);</span>
<a href="#l25.166"></a><span id="l25.166">           m_entryArray.AppendElement(pEntry);</span>
<a href="#l25.167"></a><span id="l25.167">       }</span>
<a href="#l25.168"></a><span id="l25.168">     }</span>
<a href="#l25.169"></a><span id="l25.169">   }</span>
<a href="#l25.170"></a><span id="l25.170"> </span>
<a href="#l25.171"></a><span id="l25.171" class="difflineminus">-  if (m_entryArray.Count() &gt; 0) {</span>
<a href="#l25.172"></a><span id="l25.172" class="difflineminus">-    pEntry = (MailboxEntry *)m_entryArray.ElementAt(m_entryArray.Count() - 1);</span>
<a href="#l25.173"></a><span id="l25.173" class="difflineplus">+  if (m_entryArray.Length() &gt; 0) {</span>
<a href="#l25.174"></a><span id="l25.174" class="difflineplus">+    pEntry = m_entryArray.ElementAt(m_entryArray.Length() - 1);</span>
<a href="#l25.175"></a><span id="l25.175">     pEntry-&gt;sibling = -1;</span>
<a href="#l25.176"></a><span id="l25.176">   }</span>
<a href="#l25.177"></a><span id="l25.177"> }</span>
<a href="#l25.178"></a><span id="l25.178"> </span>
<a href="#l25.179"></a><span id="l25.179"> uint32_t nsOEScanBoxes::CountMailboxes(MailboxEntry *pBox)</span>
<a href="#l25.180"></a><span id="l25.180"> {</span>
<a href="#l25.181"></a><span id="l25.181">   if (pBox == nullptr) {</span>
<a href="#l25.182"></a><span id="l25.182">     if (m_pFirst != nullptr)</span>
<a href="#l25.183"></a><span id="l25.183">       pBox = m_pFirst;</span>
<a href="#l25.184"></a><span id="l25.184">     else {</span>
<a href="#l25.185"></a><span id="l25.185" class="difflineminus">-      if (m_entryArray.Count() &gt; 0)</span>
<a href="#l25.186"></a><span id="l25.186" class="difflineminus">-        pBox = (MailboxEntry *) m_entryArray.ElementAt(0);</span>
<a href="#l25.187"></a><span id="l25.187" class="difflineplus">+      if (m_entryArray.Length() &gt; 0)</span>
<a href="#l25.188"></a><span id="l25.188" class="difflineplus">+        pBox = m_entryArray.ElementAt(0);</span>
<a href="#l25.189"></a><span id="l25.189">     }</span>
<a href="#l25.190"></a><span id="l25.190">   }</span>
<a href="#l25.191"></a><span id="l25.191">   uint32_t    count = 0;</span>
<a href="#l25.192"></a><span id="l25.192"> </span>
<a href="#l25.193"></a><span id="l25.193">   MailboxEntry *  pChild;</span>
<a href="#l25.194"></a><span id="l25.194">   while (pBox) {</span>
<a href="#l25.195"></a><span id="l25.195">     count++;</span>
<a href="#l25.196"></a><span id="l25.196">     if (pBox-&gt;child) {</span>
<a href="#l25.197"></a><span id="l25.197" class="difflineat">@@ -699,18 +699,18 @@ void nsOEScanBoxes::BuildMailboxList(Mai</span>
<a href="#l25.198"></a><span id="l25.198"> {</span>
<a href="#l25.199"></a><span id="l25.199">   if (pBox == nullptr) {</span>
<a href="#l25.200"></a><span id="l25.200">     if (m_pFirst != nullptr) {</span>
<a href="#l25.201"></a><span id="l25.201">       pBox = m_pFirst;</span>
<a href="#l25.202"></a><span id="l25.202"> </span>
<a href="#l25.203"></a><span id="l25.203">       IMPORT_LOG0(&quot;Assigning start of mailbox list to m_pFirst\n&quot;);</span>
<a href="#l25.204"></a><span id="l25.204">     }</span>
<a href="#l25.205"></a><span id="l25.205">     else {</span>
<a href="#l25.206"></a><span id="l25.206" class="difflineminus">-      if (m_entryArray.Count() &gt; 0) {</span>
<a href="#l25.207"></a><span id="l25.207" class="difflineminus">-        pBox = (MailboxEntry *) m_entryArray.ElementAt(0);</span>
<a href="#l25.208"></a><span id="l25.208" class="difflineplus">+      if (m_entryArray.Length() &gt; 0) {</span>
<a href="#l25.209"></a><span id="l25.209" class="difflineplus">+        pBox = m_entryArray.ElementAt(0);</span>
<a href="#l25.210"></a><span id="l25.210"> </span>
<a href="#l25.211"></a><span id="l25.211">         IMPORT_LOG0(&quot;Assigning start of mailbox list to entry at index 0\n&quot;);</span>
<a href="#l25.212"></a><span id="l25.212">       }</span>
<a href="#l25.213"></a><span id="l25.213">     }</span>
<a href="#l25.214"></a><span id="l25.214"> </span>
<a href="#l25.215"></a><span id="l25.215">     if (pBox == nullptr) {</span>
<a href="#l25.216"></a><span id="l25.216">       IMPORT_LOG0(&quot;ERROR ASSIGNING STARTING MAILBOX\n&quot;);</span>
<a href="#l25.217"></a><span id="l25.217">     }</span>
<a href="#l25.218"></a><span id="l25.218" class="difflineat">@@ -758,19 +758,19 @@ void nsOEScanBoxes::BuildMailboxList(Mai</span>
<a href="#l25.219"></a><span id="l25.219">     else</span>
<a href="#l25.220"></a><span id="l25.220">       pBox = nullptr;</span>
<a href="#l25.221"></a><span id="l25.221">   }</span>
<a href="#l25.222"></a><span id="l25.222"> </span>
<a href="#l25.223"></a><span id="l25.223"> }</span>
<a href="#l25.224"></a><span id="l25.224"> </span>
<a href="#l25.225"></a><span id="l25.225"> nsOEScanBoxes::MailboxEntry * nsOEScanBoxes::GetIndexEntry(uint32_t index)</span>
<a href="#l25.226"></a><span id="l25.226"> {</span>
<a href="#l25.227"></a><span id="l25.227" class="difflineminus">-  int32_t max = m_entryArray.Count();</span>
<a href="#l25.228"></a><span id="l25.228" class="difflineplus">+  int32_t max = m_entryArray.Length();</span>
<a href="#l25.229"></a><span id="l25.229">   for (int32_t i = 0; i &lt; max; i++) {</span>
<a href="#l25.230"></a><span id="l25.230" class="difflineminus">-    MailboxEntry *pEntry = (MailboxEntry *) m_entryArray.ElementAt(i);</span>
<a href="#l25.231"></a><span id="l25.231" class="difflineplus">+    MailboxEntry *pEntry = m_entryArray.ElementAt(i);</span>
<a href="#l25.232"></a><span id="l25.232">     if (pEntry-&gt;index == index)</span>
<a href="#l25.233"></a><span id="l25.233">       return pEntry;</span>
<a href="#l25.234"></a><span id="l25.234">   }</span>
<a href="#l25.235"></a><span id="l25.235"> </span>
<a href="#l25.236"></a><span id="l25.236">   return nullptr;</span>
<a href="#l25.237"></a><span id="l25.237"> }</span>
<a href="#l25.238"></a><span id="l25.238"> </span>
<a href="#l25.239"></a><span id="l25.239"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/import/oexpress/nsOEScanBoxes.h</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/import/oexpress/nsOEScanBoxes.h</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -3,17 +3,17 @@</span>
<a href="#l26.4"></a><span id="l26.4">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l26.5"></a><span id="l26.5">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l26.6"></a><span id="l26.6"> </span>
<a href="#l26.7"></a><span id="l26.7"> #ifndef nsOEScanBoxes_h___</span>
<a href="#l26.8"></a><span id="l26.8"> #define nsOEScanBoxes_h___</span>
<a href="#l26.9"></a><span id="l26.9"> </span>
<a href="#l26.10"></a><span id="l26.10"> #include &quot;nsStringGlue.h&quot;</span>
<a href="#l26.11"></a><span id="l26.11"> #include &quot;nsIImportModule.h&quot;</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l26.14"></a><span id="l26.14"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l26.15"></a><span id="l26.15"> #include &quot;nsIArray.h&quot;</span>
<a href="#l26.16"></a><span id="l26.16"> #include &quot;nsIMutableArray.h&quot;</span>
<a href="#l26.17"></a><span id="l26.17"> #include &quot;nsIFile.h&quot;</span>
<a href="#l26.18"></a><span id="l26.18"> #include &quot;nsIImportService.h&quot;</span>
<a href="#l26.19"></a><span id="l26.19"> </span>
<a href="#l26.20"></a><span id="l26.20"> class nsIInputStream;</span>
<a href="#l26.21"></a><span id="l26.21"> </span>
<a href="#l26.22"></a><span id="l26.22" class="difflineat">@@ -47,30 +47,30 @@ private:</span>
<a href="#l26.23"></a><span id="l26.23"> </span>
<a href="#l26.24"></a><span id="l26.24">   // If find mailboxes fails you can use this routine to get the raw mailbox file names</span>
<a href="#l26.25"></a><span id="l26.25">   void  ScanMailboxDir(nsIFile * srcDir);</span>
<a href="#l26.26"></a><span id="l26.26">   bool    Scan50MailboxDir(nsIFile * srcDir);</span>
<a href="#l26.27"></a><span id="l26.27"> </span>
<a href="#l26.28"></a><span id="l26.28">   MailboxEntry *  GetIndexEntry(uint32_t index);</span>
<a href="#l26.29"></a><span id="l26.29">   void      AddChildEntry(MailboxEntry *pEntry, uint32_t rootIndex);</span>
<a href="#l26.30"></a><span id="l26.30">   MailboxEntry *  NewMailboxEntry(uint32_t id, uint32_t parent, const char *prettyName, char *pFileName);</span>
<a href="#l26.31"></a><span id="l26.31" class="difflineminus">-  void        ProcessPendingChildEntries(uint32_t parent, uint32_t rootIndex, nsVoidArray &amp;childArray);</span>
<a href="#l26.32"></a><span id="l26.32" class="difflineplus">+  void        ProcessPendingChildEntries(uint32_t parent, uint32_t rootIndex, nsTArray&lt;MailboxEntry*&gt; &amp;childArray);</span>
<a href="#l26.33"></a><span id="l26.33">   void        RemoveProcessedChildEntries();</span>
<a href="#l26.34"></a><span id="l26.34"> </span>
<a href="#l26.35"></a><span id="l26.35"> </span>
<a href="#l26.36"></a><span id="l26.36">   bool        ReadLong(nsIInputStream * stream, int32_t&amp; val, uint32_t offset);</span>
<a href="#l26.37"></a><span id="l26.37">   bool        ReadLong(nsIInputStream * stream, uint32_t&amp; val, uint32_t offset);</span>
<a href="#l26.38"></a><span id="l26.38">   bool        ReadString(nsIInputStream * stream, nsString&amp; str, uint32_t offset);</span>
<a href="#l26.39"></a><span id="l26.39">   bool        ReadString(nsIInputStream * stream, nsCString&amp; str, uint32_t offset);</span>
<a href="#l26.40"></a><span id="l26.40">   uint32_t     CountMailboxes(MailboxEntry *pBox);</span>
<a href="#l26.41"></a><span id="l26.41"> </span>
<a href="#l26.42"></a><span id="l26.42">   void       BuildMailboxList(MailboxEntry *pBox, nsIFile * root, int32_t depth, nsIMutableArray *pArray);</span>
<a href="#l26.43"></a><span id="l26.43">   bool         GetMailboxList(nsIFile * root, nsIArray **pArray);</span>
<a href="#l26.44"></a><span id="l26.44"> </span>
<a href="#l26.45"></a><span id="l26.45"> private:</span>
<a href="#l26.46"></a><span id="l26.46">   MailboxEntry *        m_pFirst;</span>
<a href="#l26.47"></a><span id="l26.47" class="difflineminus">-  nsVoidArray          m_entryArray;</span>
<a href="#l26.48"></a><span id="l26.48" class="difflineminus">-  nsVoidArray          m_pendingChildArray; // contains child folders whose parent folders have not showed up.</span>
<a href="#l26.49"></a><span id="l26.49" class="difflineplus">+  nsTArray&lt;MailboxEntry*&gt;  m_entryArray;</span>
<a href="#l26.50"></a><span id="l26.50" class="difflineplus">+  nsTArray&lt;MailboxEntry*&gt;  m_pendingChildArray; // contains child folders whose parent folders have not showed up.</span>
<a href="#l26.51"></a><span id="l26.51"> </span>
<a href="#l26.52"></a><span id="l26.52">   nsCOMPtr&lt;nsIImportService&gt;  mService;</span>
<a href="#l26.53"></a><span id="l26.53"> };</span>
<a href="#l26.54"></a><span id="l26.54"> </span>
<a href="#l26.55"></a><span id="l26.55"> #endif // nsOEScanBoxes_h__</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/mailnews/import/outlook/src/MapiApi.cpp</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/mailnews/import/outlook/src/MapiApi.cpp</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -11,17 +11,17 @@</span>
<a href="#l27.4"></a><span id="l27.4"> </span>
<a href="#l27.5"></a><span id="l27.5"> #include &quot;prprf.h&quot;</span>
<a href="#l27.6"></a><span id="l27.6"> #include &quot;nsMemory.h&quot;</span>
<a href="#l27.7"></a><span id="l27.7"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l27.8"></a><span id="l27.8"> #include &quot;nsUnicharUtils.h&quot;</span>
<a href="#l27.9"></a><span id="l27.9"> </span>
<a href="#l27.10"></a><span id="l27.10"> int      CMapiApi::m_clients = 0;</span>
<a href="#l27.11"></a><span id="l27.11"> BOOL    CMapiApi::m_initialized = false;</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-nsVoidArray  *CMapiApi::m_pStores = NULL;</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+nsTArray&lt;CMsgStore*&gt;  *CMapiApi::m_pStores = NULL;</span>
<a href="#l27.14"></a><span id="l27.14"> LPMAPISESSION CMapiApi::m_lpSession = NULL;</span>
<a href="#l27.15"></a><span id="l27.15"> LPMDB    CMapiApi::m_lpMdb = NULL;</span>
<a href="#l27.16"></a><span id="l27.16"> HRESULT    CMapiApi::m_lastError;</span>
<a href="#l27.17"></a><span id="l27.17"> char16_t *  CMapiApi::m_pUniBuff = NULL;</span>
<a href="#l27.18"></a><span id="l27.18"> int      CMapiApi::m_uniBuffLen = 0;</span>
<a href="#l27.19"></a><span id="l27.19"> /*</span>
<a href="#l27.20"></a><span id="l27.20"> Type: 1, name: Calendar, class: IPF.Appointment</span>
<a href="#l27.21"></a><span id="l27.21"> Type: 1, name: Contacts, class: IPF.Contact</span>
<a href="#l27.22"></a><span id="l27.22" class="difflineat">@@ -250,17 +250,17 @@ void CMapiApi::UnloadMapi(void)</span>
<a href="#l27.23"></a><span id="l27.23">   m_hMapi32 = NULL;</span>
<a href="#l27.24"></a><span id="l27.24"> }</span>
<a href="#l27.25"></a><span id="l27.25"> </span>
<a href="#l27.26"></a><span id="l27.26"> CMapiApi::CMapiApi()</span>
<a href="#l27.27"></a><span id="l27.27"> {</span>
<a href="#l27.28"></a><span id="l27.28">   m_clients++;</span>
<a href="#l27.29"></a><span id="l27.29">   LoadMapi();</span>
<a href="#l27.30"></a><span id="l27.30">   if (!m_pStores)</span>
<a href="#l27.31"></a><span id="l27.31" class="difflineminus">-    m_pStores = new nsVoidArray();</span>
<a href="#l27.32"></a><span id="l27.32" class="difflineplus">+    m_pStores = new nsTArray&lt;CMsgStore*&gt;();</span>
<a href="#l27.33"></a><span id="l27.33"> }</span>
<a href="#l27.34"></a><span id="l27.34"> </span>
<a href="#l27.35"></a><span id="l27.35"> CMapiApi::~CMapiApi()</span>
<a href="#l27.36"></a><span id="l27.36"> {</span>
<a href="#l27.37"></a><span id="l27.37">   m_clients--;</span>
<a href="#l27.38"></a><span id="l27.38">   if (!m_clients) {</span>
<a href="#l27.39"></a><span id="l27.39">     HRESULT  hr;</span>
<a href="#l27.40"></a><span id="l27.40"> </span>
<a href="#l27.41"></a><span id="l27.41" class="difflineat">@@ -1101,18 +1101,18 @@ void CMapiApi::GetStoreInfo(CMapiFolder </span>
<a href="#l27.42"></a><span id="l27.42">   }</span>
<a href="#l27.43"></a><span id="l27.43"> }</span>
<a href="#l27.44"></a><span id="l27.44"> </span>
<a href="#l27.45"></a><span id="l27.45"> </span>
<a href="#l27.46"></a><span id="l27.46"> void CMapiApi::ClearMessageStores(void)</span>
<a href="#l27.47"></a><span id="l27.47"> {</span>
<a href="#l27.48"></a><span id="l27.48">   if (m_pStores) {</span>
<a href="#l27.49"></a><span id="l27.49">     CMsgStore *  pStore;</span>
<a href="#l27.50"></a><span id="l27.50" class="difflineminus">-    for (int i = 0; i &lt; m_pStores-&gt;Count(); i++) {</span>
<a href="#l27.51"></a><span id="l27.51" class="difflineminus">-      pStore = (CMsgStore *) m_pStores-&gt;ElementAt(i);</span>
<a href="#l27.52"></a><span id="l27.52" class="difflineplus">+    for (int i = 0; i &lt; m_pStores-&gt;Length(); i++) {</span>
<a href="#l27.53"></a><span id="l27.53" class="difflineplus">+      pStore = m_pStores-&gt;ElementAt(i);</span>
<a href="#l27.54"></a><span id="l27.54">       delete pStore;</span>
<a href="#l27.55"></a><span id="l27.55">     }</span>
<a href="#l27.56"></a><span id="l27.56">     m_pStores-&gt;Clear();</span>
<a href="#l27.57"></a><span id="l27.57">   }</span>
<a href="#l27.58"></a><span id="l27.58"> }</span>
<a href="#l27.59"></a><span id="l27.59"> </span>
<a href="#l27.60"></a><span id="l27.60"> void CMapiApi::AddMessageStore(CMsgStore *pStore)</span>
<a href="#l27.61"></a><span id="l27.61"> {</span>
<a href="#l27.62"></a><span id="l27.62" class="difflineat">@@ -1126,18 +1126,18 @@ CMsgStore *  CMapiApi::FindMessageStore(</span>
<a href="#l27.63"></a><span id="l27.63">     MAPI_TRACE0(&quot;FindMessageStore called before session is open\n&quot;);</span>
<a href="#l27.64"></a><span id="l27.64">     m_lastError = -1;</span>
<a href="#l27.65"></a><span id="l27.65">     return NULL;</span>
<a href="#l27.66"></a><span id="l27.66">   }</span>
<a href="#l27.67"></a><span id="l27.67"> </span>
<a href="#l27.68"></a><span id="l27.68">   ULONG    result;</span>
<a href="#l27.69"></a><span id="l27.69">   HRESULT    hr;</span>
<a href="#l27.70"></a><span id="l27.70">   CMsgStore *  pStore;</span>
<a href="#l27.71"></a><span id="l27.71" class="difflineminus">-  for (int i = 0; i &lt; m_pStores-&gt;Count(); i++) {</span>
<a href="#l27.72"></a><span id="l27.72" class="difflineminus">-    pStore = (CMsgStore *) m_pStores-&gt;ElementAt(i);</span>
<a href="#l27.73"></a><span id="l27.73" class="difflineplus">+  for (int i = 0; i &lt; m_pStores-&gt;Length(); i++) {</span>
<a href="#l27.74"></a><span id="l27.74" class="difflineplus">+    pStore = m_pStores-&gt;ElementAt(i);</span>
<a href="#l27.75"></a><span id="l27.75">     hr = m_lpSession-&gt;CompareEntryIDs(cbEid, lpEid, pStore-&gt;GetCBEntryID(), pStore-&gt;GetLPEntryID(),</span>
<a href="#l27.76"></a><span id="l27.76">                       0, &amp;result);</span>
<a href="#l27.77"></a><span id="l27.77">     if (HR_FAILED(hr)) {</span>
<a href="#l27.78"></a><span id="l27.78">       MAPI_TRACE2(&quot;CompareEntryIDs failed: 0x%lx, %d\n&quot;, (long)hr, (int)hr);</span>
<a href="#l27.79"></a><span id="l27.79">       m_lastError = hr;</span>
<a href="#l27.80"></a><span id="l27.80">       return NULL;</span>
<a href="#l27.81"></a><span id="l27.81">     }</span>
<a href="#l27.82"></a><span id="l27.82">     if (result) {</span>
<a href="#l27.83"></a><span id="l27.83" class="difflineat">@@ -1579,19 +1579,19 @@ void CMapiFolderList::EnsureUniqueName(C</span>
<a href="#l27.84"></a><span id="l27.84">   int        i;</span>
<a href="#l27.85"></a><span id="l27.85">   BOOL      done;</span>
<a href="#l27.86"></a><span id="l27.86">   nsString    name;</span>
<a href="#l27.87"></a><span id="l27.87">   nsString    cName;</span>
<a href="#l27.88"></a><span id="l27.88"> </span>
<a href="#l27.89"></a><span id="l27.89">   pFolder-&gt;GetDisplayName(name);</span>
<a href="#l27.90"></a><span id="l27.90">   do {</span>
<a href="#l27.91"></a><span id="l27.91">     done = TRUE;</span>
<a href="#l27.92"></a><span id="l27.92" class="difflineminus">-    i = m_array.Count() - 1;</span>
<a href="#l27.93"></a><span id="l27.93" class="difflineplus">+    i = m_array.Length() - 1;</span>
<a href="#l27.94"></a><span id="l27.94">     while (i &gt;= 0) {</span>
<a href="#l27.95"></a><span id="l27.95" class="difflineminus">-      pCurrent = (CMapiFolder *)GetAt(i);</span>
<a href="#l27.96"></a><span id="l27.96" class="difflineplus">+      pCurrent = GetAt(i);</span>
<a href="#l27.97"></a><span id="l27.97">       if (pCurrent-&gt;GetDepth() == pFolder-&gt;GetDepth()) {</span>
<a href="#l27.98"></a><span id="l27.98">         pCurrent-&gt;GetDisplayName(cName);</span>
<a href="#l27.99"></a><span id="l27.99">         if (cName.Equals(name, nsCaseInsensitiveStringComparator())) {</span>
<a href="#l27.100"></a><span id="l27.100">           ChangeName(name);</span>
<a href="#l27.101"></a><span id="l27.101">           pFolder-&gt;SetDisplayName(name.get());</span>
<a href="#l27.102"></a><span id="l27.102">           done = FALSE;</span>
<a href="#l27.103"></a><span id="l27.103">           break;</span>
<a href="#l27.104"></a><span id="l27.104">         }</span>
<a href="#l27.105"></a><span id="l27.105" class="difflineat">@@ -1610,19 +1610,19 @@ void CMapiFolderList::GenerateFilePath(C</span>
<a href="#l27.106"></a><span id="l27.106">   nsString    path;</span>
<a href="#l27.107"></a><span id="l27.107">   if (!pFolder-&gt;GetDepth()) {</span>
<a href="#l27.108"></a><span id="l27.108">     pFolder-&gt;GetDisplayName(name);</span>
<a href="#l27.109"></a><span id="l27.109">     pFolder-&gt;SetFilePath(name.get());</span>
<a href="#l27.110"></a><span id="l27.110">     return;</span>
<a href="#l27.111"></a><span id="l27.111">   }</span>
<a href="#l27.112"></a><span id="l27.112"> </span>
<a href="#l27.113"></a><span id="l27.113">   CMapiFolder *  pCurrent;</span>
<a href="#l27.114"></a><span id="l27.114" class="difflineminus">-  int        i = m_array.Count() - 1;</span>
<a href="#l27.115"></a><span id="l27.115" class="difflineplus">+  int        i = m_array.Length() - 1;</span>
<a href="#l27.116"></a><span id="l27.116">   while (i &gt;= 0) {</span>
<a href="#l27.117"></a><span id="l27.117" class="difflineminus">-    pCurrent = (CMapiFolder *) GetAt(i);</span>
<a href="#l27.118"></a><span id="l27.118" class="difflineplus">+    pCurrent = GetAt(i);</span>
<a href="#l27.119"></a><span id="l27.119">     if (pCurrent-&gt;GetDepth() == (pFolder-&gt;GetDepth() - 1)) {</span>
<a href="#l27.120"></a><span id="l27.120">       pCurrent-&gt;GetFilePath(path);</span>
<a href="#l27.121"></a><span id="l27.121">       path.AppendLiteral(&quot;.sbd\\&quot;);</span>
<a href="#l27.122"></a><span id="l27.122">       pFolder-&gt;GetDisplayName(name);</span>
<a href="#l27.123"></a><span id="l27.123">       path += name;</span>
<a href="#l27.124"></a><span id="l27.124">       pFolder-&gt;SetFilePath(path.get());</span>
<a href="#l27.125"></a><span id="l27.125">       return;</span>
<a href="#l27.126"></a><span id="l27.126">     }</span>
<a href="#l27.127"></a><span id="l27.127" class="difflineat">@@ -1630,33 +1630,33 @@ void CMapiFolderList::GenerateFilePath(C</span>
<a href="#l27.128"></a><span id="l27.128">   }</span>
<a href="#l27.129"></a><span id="l27.129">   pFolder-&gt;GetDisplayName(name);</span>
<a href="#l27.130"></a><span id="l27.130">   pFolder-&gt;SetFilePath(name.get());</span>
<a href="#l27.131"></a><span id="l27.131"> }</span>
<a href="#l27.132"></a><span id="l27.132"> </span>
<a href="#l27.133"></a><span id="l27.133"> void CMapiFolderList::ClearAll(void)</span>
<a href="#l27.134"></a><span id="l27.134"> {</span>
<a href="#l27.135"></a><span id="l27.135">   CMapiFolder *pFolder;</span>
<a href="#l27.136"></a><span id="l27.136" class="difflineminus">-  for (int i = 0; i &lt; m_array.Count(); i++) {</span>
<a href="#l27.137"></a><span id="l27.137" class="difflineminus">-    pFolder = (CMapiFolder *)GetAt(i);</span>
<a href="#l27.138"></a><span id="l27.138" class="difflineplus">+  for (int i = 0; i &lt; m_array.Length(); i++) {</span>
<a href="#l27.139"></a><span id="l27.139" class="difflineplus">+    pFolder = GetAt(i);</span>
<a href="#l27.140"></a><span id="l27.140">     delete pFolder;</span>
<a href="#l27.141"></a><span id="l27.141">   }</span>
<a href="#l27.142"></a><span id="l27.142">   m_array.Clear();</span>
<a href="#l27.143"></a><span id="l27.143"> }</span>
<a href="#l27.144"></a><span id="l27.144"> </span>
<a href="#l27.145"></a><span id="l27.145"> void CMapiFolderList::DumpList(void)</span>
<a href="#l27.146"></a><span id="l27.146"> {</span>
<a href="#l27.147"></a><span id="l27.147">   CMapiFolder *pFolder;</span>
<a href="#l27.148"></a><span id="l27.148">   nsString  str;</span>
<a href="#l27.149"></a><span id="l27.149">   int      depth;</span>
<a href="#l27.150"></a><span id="l27.150">   char    prefix[256];</span>
<a href="#l27.151"></a><span id="l27.151"> </span>
<a href="#l27.152"></a><span id="l27.152">   MAPI_TRACE0(&quot;Folder List ---------------------------------\n&quot;);</span>
<a href="#l27.153"></a><span id="l27.153" class="difflineminus">-  for (int i = 0; i &lt; m_array.Count(); i++) {</span>
<a href="#l27.154"></a><span id="l27.154" class="difflineminus">-    pFolder = (CMapiFolder *)GetAt(i);</span>
<a href="#l27.155"></a><span id="l27.155" class="difflineplus">+  for (int i = 0; i &lt; m_array.Length(); i++) {</span>
<a href="#l27.156"></a><span id="l27.156" class="difflineplus">+    pFolder = GetAt(i);</span>
<a href="#l27.157"></a><span id="l27.157">     depth = pFolder-&gt;GetDepth();</span>
<a href="#l27.158"></a><span id="l27.158">     pFolder-&gt;GetDisplayName(str);</span>
<a href="#l27.159"></a><span id="l27.159">     depth *= 2;</span>
<a href="#l27.160"></a><span id="l27.160">     if (depth &gt; 255)</span>
<a href="#l27.161"></a><span id="l27.161">       depth = 255;</span>
<a href="#l27.162"></a><span id="l27.162">     memset(prefix, ' ', depth);</span>
<a href="#l27.163"></a><span id="l27.163">     prefix[depth] = 0;</span>
<a href="#l27.164"></a><span id="l27.164"> #ifdef MAPI_DEBUG</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/mailnews/import/outlook/src/MapiApi.h</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/mailnews/import/outlook/src/MapiApi.h</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -2,17 +2,17 @@</span>
<a href="#l28.4"></a><span id="l28.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l28.5"></a><span id="l28.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l28.6"></a><span id="l28.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l28.7"></a><span id="l28.7"> #ifndef MapiApi_h___</span>
<a href="#l28.8"></a><span id="l28.8"> #define MapiApi_h___</span>
<a href="#l28.9"></a><span id="l28.9"> </span>
<a href="#l28.10"></a><span id="l28.10"> #include &quot;nscore.h&quot;</span>
<a href="#l28.11"></a><span id="l28.11"> #include &quot;nsStringGlue.h&quot;</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l28.14"></a><span id="l28.14"> </span>
<a href="#l28.15"></a><span id="l28.15"> #include &lt;stdio.h&gt;</span>
<a href="#l28.16"></a><span id="l28.16"> </span>
<a href="#l28.17"></a><span id="l28.17"> #include &lt;windows.h&gt;</span>
<a href="#l28.18"></a><span id="l28.18"> #include &lt;mapi.h&gt;</span>
<a href="#l28.19"></a><span id="l28.19"> #include &lt;mapix.h&gt;</span>
<a href="#l28.20"></a><span id="l28.20"> #include &lt;mapidefs.h&gt;</span>
<a href="#l28.21"></a><span id="l28.21"> #include &lt;mapicode.h&gt;</span>
<a href="#l28.22"></a><span id="l28.22" class="difflineat">@@ -141,17 +141,17 @@ protected:</span>
<a href="#l28.23"></a><span id="l28.23">   static void      ReportStringProp(const char *pTag, LPSPropValue pVal);</span>
<a href="#l28.24"></a><span id="l28.24">   static void      ReportUIDProp(const char *pTag, LPSPropValue pVal);</span>
<a href="#l28.25"></a><span id="l28.25">   static void      ReportLongProp(const char *pTag, LPSPropValue pVal);</span>
<a href="#l28.26"></a><span id="l28.26"> </span>
<a href="#l28.27"></a><span id="l28.27"> </span>
<a href="#l28.28"></a><span id="l28.28"> private:</span>
<a href="#l28.29"></a><span id="l28.29">   static int        m_clients;</span>
<a href="#l28.30"></a><span id="l28.30">   static BOOL        m_initialized;</span>
<a href="#l28.31"></a><span id="l28.31" class="difflineminus">-  static nsVoidArray *  m_pStores;</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+  static nsTArray&lt;CMsgStore*&gt; *  m_pStores;</span>
<a href="#l28.33"></a><span id="l28.33">   static LPMAPISESSION  m_lpSession;</span>
<a href="#l28.34"></a><span id="l28.34">   static LPMDB      m_lpMdb;</span>
<a href="#l28.35"></a><span id="l28.35">   static HRESULT      m_lastError;</span>
<a href="#l28.36"></a><span id="l28.36">   static char16_t *    m_pUniBuff;</span>
<a href="#l28.37"></a><span id="l28.37">   static int        m_uniBuffLen;</span>
<a href="#l28.38"></a><span id="l28.38"> </span>
<a href="#l28.39"></a><span id="l28.39">   static BOOL      GetLargeProperty(LPMAPIPROP pProp, ULONG tag, void** result);</span>
<a href="#l28.40"></a><span id="l28.40"> };</span>
<a href="#l28.41"></a><span id="l28.41" class="difflineat">@@ -193,32 +193,32 @@ private:</span>
<a href="#l28.42"></a><span id="l28.42"> };</span>
<a href="#l28.43"></a><span id="l28.43"> </span>
<a href="#l28.44"></a><span id="l28.44"> class CMapiFolderList {</span>
<a href="#l28.45"></a><span id="l28.45"> public:</span>
<a href="#l28.46"></a><span id="l28.46">   CMapiFolderList();</span>
<a href="#l28.47"></a><span id="l28.47">   ~CMapiFolderList();</span>
<a href="#l28.48"></a><span id="l28.48"> </span>
<a href="#l28.49"></a><span id="l28.49">   void      AddItem(CMapiFolder *pFolder);</span>
<a href="#l28.50"></a><span id="l28.50" class="difflineminus">-  CMapiFolder *  GetItem(int index) { if ((index &gt;= 0) &amp;&amp; (index &lt; m_array.Count())) return (CMapiFolder *)GetAt(index); else return NULL;}</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineplus">+  CMapiFolder *  GetItem(int index) { if ((index &gt;= 0) &amp;&amp; (index &lt; m_array.Length())) return GetAt(index); else return NULL;}</span>
<a href="#l28.52"></a><span id="l28.52">   void      ClearAll(void);</span>
<a href="#l28.53"></a><span id="l28.53"> </span>
<a href="#l28.54"></a><span id="l28.54">   // Debugging and reporting</span>
<a href="#l28.55"></a><span id="l28.55">   void      DumpList(void);</span>
<a href="#l28.56"></a><span id="l28.56"> </span>
<a href="#l28.57"></a><span id="l28.57" class="difflineminus">-  void *      GetAt(int index) { return m_array.ElementAt(index);}</span>
<a href="#l28.58"></a><span id="l28.58" class="difflineminus">-  int        GetSize(void) { return m_array.Count();}</span>
<a href="#l28.59"></a><span id="l28.59" class="difflineplus">+  CMapiFolder *  GetAt(int index) { return m_array.ElementAt(index);}</span>
<a href="#l28.60"></a><span id="l28.60" class="difflineplus">+  int        GetSize(void) { return m_array.Length();}</span>
<a href="#l28.61"></a><span id="l28.61"> </span>
<a href="#l28.62"></a><span id="l28.62"> protected:</span>
<a href="#l28.63"></a><span id="l28.63">   void  EnsureUniqueName(CMapiFolder *pFolder);</span>
<a href="#l28.64"></a><span id="l28.64">   void  GenerateFilePath(CMapiFolder *pFolder);</span>
<a href="#l28.65"></a><span id="l28.65">   void  ChangeName(nsString&amp; name);</span>
<a href="#l28.66"></a><span id="l28.66"> </span>
<a href="#l28.67"></a><span id="l28.67"> private:</span>
<a href="#l28.68"></a><span id="l28.68" class="difflineminus">-  nsVoidArray    m_array;</span>
<a href="#l28.69"></a><span id="l28.69" class="difflineplus">+  nsTArray&lt;CMapiFolder*&gt;    m_array;</span>
<a href="#l28.70"></a><span id="l28.70"> };</span>
<a href="#l28.71"></a><span id="l28.71"> </span>
<a href="#l28.72"></a><span id="l28.72"> </span>
<a href="#l28.73"></a><span id="l28.73"> class CMsgStore {</span>
<a href="#l28.74"></a><span id="l28.74"> public:</span>
<a href="#l28.75"></a><span id="l28.75">   CMsgStore(ULONG cbEid = 0, LPENTRYID lpEid = NULL);</span>
<a href="#l28.76"></a><span id="l28.76">   ~CMsgStore();</span>
<a href="#l28.77"></a><span id="l28.77"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/mailnews/import/src/nsImportFieldMap.cpp</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/mailnews/import/src/nsImportFieldMap.cpp</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -58,17 +58,17 @@ nsImportFieldMap::nsImportFieldMap(nsISt</span>
<a href="#l29.4"></a><span id="l29.4">   nsString *pStr;</span>
<a href="#l29.5"></a><span id="l29.5">   for (int32_t i = IMPORT_FIELD_DESC_START; i &lt;= IMPORT_FIELD_DESC_END; i++, m_mozFieldCount++) {</span>
<a href="#l29.6"></a><span id="l29.6">     pStr = new nsString();</span>
<a href="#l29.7"></a><span id="l29.7">     if (pBundle) {</span>
<a href="#l29.8"></a><span id="l29.8">       nsImportStringBundle::GetStringByID(i, pBundle, *pStr);</span>
<a href="#l29.9"></a><span id="l29.9">     }</span>
<a href="#l29.10"></a><span id="l29.10">     else</span>
<a href="#l29.11"></a><span id="l29.11">       pStr-&gt;AppendInt(i);</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-    m_descriptions.AppendElement((void *)pStr);</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+    m_descriptions.AppendElement(pStr);</span>
<a href="#l29.14"></a><span id="l29.14">   }</span>
<a href="#l29.15"></a><span id="l29.15"> }</span>
<a href="#l29.16"></a><span id="l29.16"> </span>
<a href="#l29.17"></a><span id="l29.17"> nsImportFieldMap::~nsImportFieldMap()</span>
<a href="#l29.18"></a><span id="l29.18"> {</span>
<a href="#l29.19"></a><span id="l29.19">   if (m_pFields)</span>
<a href="#l29.20"></a><span id="l29.20">     delete [] m_pFields;</span>
<a href="#l29.21"></a><span id="l29.21">   if (m_pActive)</span>
<a href="#l29.22"></a><span id="l29.22" class="difflineat">@@ -105,17 +105,17 @@ NS_IMETHODIMP nsImportFieldMap::GetMapSi</span>
<a href="#l29.23"></a><span id="l29.23"> </span>
<a href="#l29.24"></a><span id="l29.24"> NS_IMETHODIMP nsImportFieldMap::GetFieldDescription(int32_t index, char16_t **_retval)</span>
<a href="#l29.25"></a><span id="l29.25"> {</span>
<a href="#l29.26"></a><span id="l29.26">     NS_PRECONDITION(_retval != nullptr, &quot;null ptr&quot;);</span>
<a href="#l29.27"></a><span id="l29.27">   if (!_retval)</span>
<a href="#l29.28"></a><span id="l29.28">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l29.29"></a><span id="l29.29"> </span>
<a href="#l29.30"></a><span id="l29.30">   *_retval = nullptr;</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineminus">-  if ((index &lt; 0) || (index &gt;= m_descriptions.Count()))</span>
<a href="#l29.32"></a><span id="l29.32" class="difflineplus">+  if ((index &lt; 0) || (index &gt;= m_descriptions.Length()))</span>
<a href="#l29.33"></a><span id="l29.33">     return NS_ERROR_FAILURE;</span>
<a href="#l29.34"></a><span id="l29.34"> </span>
<a href="#l29.35"></a><span id="l29.35">   *_retval = ToNewUnicode(*((nsString *)m_descriptions.ElementAt(index)));</span>
<a href="#l29.36"></a><span id="l29.36">   return NS_OK;</span>
<a href="#l29.37"></a><span id="l29.37"> }</span>
<a href="#l29.38"></a><span id="l29.38"> </span>
<a href="#l29.39"></a><span id="l29.39"> NS_IMETHODIMP nsImportFieldMap::SetFieldMapSize(int32_t size)</span>
<a href="#l29.40"></a><span id="l29.40"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/mailnews/import/src/nsImportFieldMap.h</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/mailnews/import/src/nsImportFieldMap.h</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -4,17 +4,18 @@</span>
<a href="#l30.4"></a><span id="l30.4">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l30.5"></a><span id="l30.5"> </span>
<a href="#l30.6"></a><span id="l30.6"> #ifndef nsImportFieldMap_h___</span>
<a href="#l30.7"></a><span id="l30.7"> #define nsImportFieldMap_h___</span>
<a href="#l30.8"></a><span id="l30.8"> </span>
<a href="#l30.9"></a><span id="l30.9"> #include &quot;nscore.h&quot;</span>
<a href="#l30.10"></a><span id="l30.10"> #include &quot;nsIImportFieldMap.h&quot;</span>
<a href="#l30.11"></a><span id="l30.11"> #include &quot;nsIAddrDatabase.h&quot;</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l30.14"></a><span id="l30.14" class="difflineplus">+#include &quot;nsString.h&quot;</span>
<a href="#l30.15"></a><span id="l30.15"> </span>
<a href="#l30.16"></a><span id="l30.16"> </span>
<a href="#l30.17"></a><span id="l30.17"> ////////////////////////////////////////////////////////////////////////</span>
<a href="#l30.18"></a><span id="l30.18"> </span>
<a href="#l30.19"></a><span id="l30.19"> class nsIStringBundle;</span>
<a href="#l30.20"></a><span id="l30.20"> </span>
<a href="#l30.21"></a><span id="l30.21"> class nsImportFieldMap : public nsIImportFieldMap</span>
<a href="#l30.22"></a><span id="l30.22"> {</span>
<a href="#l30.23"></a><span id="l30.23" class="difflineat">@@ -31,15 +32,15 @@ private:</span>
<a href="#l30.24"></a><span id="l30.24">   virtual ~nsImportFieldMap();</span>
<a href="#l30.25"></a><span id="l30.25">   nsresult  Allocate(int32_t newSize);</span>
<a href="#l30.26"></a><span id="l30.26"> </span>
<a href="#l30.27"></a><span id="l30.27"> private:</span>
<a href="#l30.28"></a><span id="l30.28">   int32_t    m_numFields;</span>
<a href="#l30.29"></a><span id="l30.29">   int32_t  *  m_pFields;</span>
<a href="#l30.30"></a><span id="l30.30">   bool *  m_pActive;</span>
<a href="#l30.31"></a><span id="l30.31">   int32_t    m_allocated;</span>
<a href="#l30.32"></a><span id="l30.32" class="difflineminus">-  nsVoidArray  m_descriptions;</span>
<a href="#l30.33"></a><span id="l30.33" class="difflineplus">+  nsTArray&lt;nsString*&gt;  m_descriptions;</span>
<a href="#l30.34"></a><span id="l30.34">   int32_t    m_mozFieldCount;</span>
<a href="#l30.35"></a><span id="l30.35">   bool        m_skipFirstRecord;</span>
<a href="#l30.36"></a><span id="l30.36"> };</span>
<a href="#l30.37"></a><span id="l30.37"> </span>
<a href="#l30.38"></a><span id="l30.38"> </span>
<a href="#l30.39"></a><span id="l30.39"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/mailnews/local/public/nsIPop3Protocol.idl</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/mailnews/local/public/nsIPop3Protocol.idl</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -1,24 +1,25 @@</span>
<a href="#l31.4"></a><span id="l31.4"> /* -*- Mode: IDL; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a href="#l31.5"></a><span id="l31.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l31.6"></a><span id="l31.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l31.7"></a><span id="l31.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l31.8"></a><span id="l31.8"> </span>
<a href="#l31.9"></a><span id="l31.9"> #include &quot;nsISupports.idl&quot;</span>
<a href="#l31.10"></a><span id="l31.10"> </span>
<a href="#l31.11"></a><span id="l31.11" class="difflineminus">-[ptr] native nsVoidArray(nsVoidArray);</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineplus">+[ptr] native nsPop3UidlEntryArrayRef(nsTArray&lt;Pop3UidlEntry*&gt;);</span>
<a href="#l31.13"></a><span id="l31.13"> </span>
<a href="#l31.14"></a><span id="l31.14"> %{C++</span>
<a href="#l31.15"></a><span id="l31.15" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l31.16"></a><span id="l31.16" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l31.17"></a><span id="l31.17" class="difflineplus">+struct Pop3UidlEntry;</span>
<a href="#l31.18"></a><span id="l31.18"> %}</span>
<a href="#l31.19"></a><span id="l31.19"> </span>
<a href="#l31.20"></a><span id="l31.20" class="difflineminus">-[scriptable, uuid(aebda729-c423-4113-ae36-2229fdc3b699)]</span>
<a href="#l31.21"></a><span id="l31.21" class="difflineplus">+[scriptable, uuid(f3e1c1e8-3005-4554-9d46-595b1713a3a6)]</span>
<a href="#l31.22"></a><span id="l31.22"> interface nsIPop3Protocol : nsISupports {</span>
<a href="#l31.23"></a><span id="l31.23">   /* aUidl is an array of pointers to Pop3UidlEntry's. That structure is</span>
<a href="#l31.24"></a><span id="l31.24">    * currently defined in nsPop3Protocol.h, perhaps it should be here</span>
<a href="#l31.25"></a><span id="l31.25">    * instead...</span>
<a href="#l31.26"></a><span id="l31.26">    */</span>
<a href="#l31.27"></a><span id="l31.27" class="difflineminus">-  [noscript] void markMessages(in nsVoidArray aUidl);</span>
<a href="#l31.28"></a><span id="l31.28" class="difflineplus">+  [noscript] void markMessages(in nsPop3UidlEntryArrayRef aUidl);</span>
<a href="#l31.29"></a><span id="l31.29">   boolean checkMessage(in string aUidl);</span>
<a href="#l31.30"></a><span id="l31.30"> };</span>
<a href="#l31.31"></a><span id="l31.31"> </span>
<a href="#l31.32"></a><span id="l31.32"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/mailnews/local/src/nsParseMailbox.cpp</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/mailnews/local/src/nsParseMailbox.cpp</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -842,77 +842,77 @@ NS_IMETHODIMP nsParseMailMessageState::G</span>
<a href="#l32.4"></a><span id="l32.4">     int32_t headerLen = strlen(curHeader);</span>
<a href="#l32.5"></a><span id="l32.5">     curHeader += headerLen + 1;</span>
<a href="#l32.6"></a><span id="l32.6">     headerPos += headerLen + 1;</span>
<a href="#l32.7"></a><span id="l32.7">   }</span>
<a href="#l32.8"></a><span id="l32.8">   *pHeaders = ToNewCString(crlfHeaders);</span>
<a href="#l32.9"></a><span id="l32.9">   return NS_OK;</span>
<a href="#l32.10"></a><span id="l32.10"> }</span>
<a href="#l32.11"></a><span id="l32.11"> </span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-struct message_header *nsParseMailMessageState::GetNextHeaderInAggregate (nsVoidArray &amp;list)</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineplus">+struct message_header *nsParseMailMessageState::GetNextHeaderInAggregate (nsTArray&lt;struct message_header*&gt; &amp;list)</span>
<a href="#l32.14"></a><span id="l32.14"> {</span>
<a href="#l32.15"></a><span id="l32.15">   // When parsing a message with multiple To or CC header lines, we're storing each line in a</span>
<a href="#l32.16"></a><span id="l32.16">   // list, where the list represents the &quot;aggregate&quot; total of all the header. Here we get a new</span>
<a href="#l32.17"></a><span id="l32.17">   // line for the list</span>
<a href="#l32.18"></a><span id="l32.18"> </span>
<a href="#l32.19"></a><span id="l32.19">   struct message_header *header = (struct message_header*) PR_Calloc (1, sizeof(struct message_header));</span>
<a href="#l32.20"></a><span id="l32.20">   list.AppendElement (header);</span>
<a href="#l32.21"></a><span id="l32.21">   return header;</span>
<a href="#l32.22"></a><span id="l32.22"> }</span>
<a href="#l32.23"></a><span id="l32.23"> </span>
<a href="#l32.24"></a><span id="l32.24" class="difflineminus">-void nsParseMailMessageState::GetAggregateHeader (nsVoidArray &amp;list, struct message_header *outHeader)</span>
<a href="#l32.25"></a><span id="l32.25" class="difflineplus">+void nsParseMailMessageState::GetAggregateHeader (nsTArray&lt;struct message_header*&gt; &amp;list, struct message_header *outHeader)</span>
<a href="#l32.26"></a><span id="l32.26"> {</span>
<a href="#l32.27"></a><span id="l32.27">   // When parsing a message with multiple To or CC header lines, we're storing each line in a</span>
<a href="#l32.28"></a><span id="l32.28">   // list, where the list represents the &quot;aggregate&quot; total of all the header. Here we combine</span>
<a href="#l32.29"></a><span id="l32.29">   // all the lines together, as though they were really all found on the same line</span>
<a href="#l32.30"></a><span id="l32.30"> </span>
<a href="#l32.31"></a><span id="l32.31">   struct message_header *header = nullptr;</span>
<a href="#l32.32"></a><span id="l32.32">   int length = 0;</span>
<a href="#l32.33"></a><span id="l32.33">   int i;</span>
<a href="#l32.34"></a><span id="l32.34"> </span>
<a href="#l32.35"></a><span id="l32.35">   // Count up the bytes required to allocate the aggregated header</span>
<a href="#l32.36"></a><span id="l32.36" class="difflineminus">-  for (i = 0; i &lt; list.Count(); i++)</span>
<a href="#l32.37"></a><span id="l32.37" class="difflineplus">+  for (i = 0; i &lt; list.Length(); i++)</span>
<a href="#l32.38"></a><span id="l32.38">   {</span>
<a href="#l32.39"></a><span id="l32.39" class="difflineminus">-    header = (struct message_header*) list.ElementAt(i);</span>
<a href="#l32.40"></a><span id="l32.40" class="difflineplus">+    header = list.ElementAt(i);</span>
<a href="#l32.41"></a><span id="l32.41">     length += (header-&gt;length + 1); //+ for &quot;,&quot;</span>
<a href="#l32.42"></a><span id="l32.42">   }</span>
<a href="#l32.43"></a><span id="l32.43"> </span>
<a href="#l32.44"></a><span id="l32.44">   if (length &gt; 0)</span>
<a href="#l32.45"></a><span id="l32.45">   {</span>
<a href="#l32.46"></a><span id="l32.46">     char *value = (char*) PR_CALLOC (length + 1); //+1 for null term</span>
<a href="#l32.47"></a><span id="l32.47">     if (value)</span>
<a href="#l32.48"></a><span id="l32.48">     {</span>
<a href="#l32.49"></a><span id="l32.49">       // Catenate all the To lines together, separated by commas</span>
<a href="#l32.50"></a><span id="l32.50">       value[0] = '\0';</span>
<a href="#l32.51"></a><span id="l32.51" class="difflineminus">-      int size = list.Count();</span>
<a href="#l32.52"></a><span id="l32.52" class="difflineplus">+      int size = list.Length();</span>
<a href="#l32.53"></a><span id="l32.53">       for (i = 0; i &lt; size; i++)</span>
<a href="#l32.54"></a><span id="l32.54">       {</span>
<a href="#l32.55"></a><span id="l32.55" class="difflineminus">-        header = (struct message_header*) list.ElementAt(i);</span>
<a href="#l32.56"></a><span id="l32.56" class="difflineplus">+        header = list.ElementAt(i);</span>
<a href="#l32.57"></a><span id="l32.57">         PL_strncat (value, header-&gt;value, header-&gt;length);</span>
<a href="#l32.58"></a><span id="l32.58">         if (i + 1 &lt; size)</span>
<a href="#l32.59"></a><span id="l32.59">           PL_strcat (value, &quot;,&quot;);</span>
<a href="#l32.60"></a><span id="l32.60">       }</span>
<a href="#l32.61"></a><span id="l32.61">       outHeader-&gt;length = length;</span>
<a href="#l32.62"></a><span id="l32.62">       outHeader-&gt;value = value;</span>
<a href="#l32.63"></a><span id="l32.63">     }</span>
<a href="#l32.64"></a><span id="l32.64">   }</span>
<a href="#l32.65"></a><span id="l32.65">   else</span>
<a href="#l32.66"></a><span id="l32.66">   {</span>
<a href="#l32.67"></a><span id="l32.67">     outHeader-&gt;length = 0;</span>
<a href="#l32.68"></a><span id="l32.68">     outHeader-&gt;value = nullptr;</span>
<a href="#l32.69"></a><span id="l32.69">   }</span>
<a href="#l32.70"></a><span id="l32.70"> }</span>
<a href="#l32.71"></a><span id="l32.71"> </span>
<a href="#l32.72"></a><span id="l32.72" class="difflineminus">-void nsParseMailMessageState::ClearAggregateHeader (nsVoidArray &amp;list)</span>
<a href="#l32.73"></a><span id="l32.73" class="difflineplus">+void nsParseMailMessageState::ClearAggregateHeader (nsTArray&lt;struct message_header*&gt; &amp;list)</span>
<a href="#l32.74"></a><span id="l32.74"> {</span>
<a href="#l32.75"></a><span id="l32.75">   // Reset the aggregate headers. Free only the message_header struct since</span>
<a href="#l32.76"></a><span id="l32.76">   // we don't own the value pointer</span>
<a href="#l32.77"></a><span id="l32.77"> </span>
<a href="#l32.78"></a><span id="l32.78" class="difflineminus">-  for (int i = 0; i &lt; list.Count(); i++)</span>
<a href="#l32.79"></a><span id="l32.79" class="difflineminus">-    PR_Free ((struct message_header*) list.ElementAt(i));</span>
<a href="#l32.80"></a><span id="l32.80" class="difflineplus">+  for (int i = 0; i &lt; list.Length(); i++)</span>
<a href="#l32.81"></a><span id="l32.81" class="difflineplus">+    PR_Free (list.ElementAt(i));</span>
<a href="#l32.82"></a><span id="l32.82">   list.Clear();</span>
<a href="#l32.83"></a><span id="l32.83"> }</span>
<a href="#l32.84"></a><span id="l32.84"> </span>
<a href="#l32.85"></a><span id="l32.85"> // We've found a new envelope to parse.</span>
<a href="#l32.86"></a><span id="l32.86"> nsresult nsParseMailMessageState::StartNewEnvelope(const char *line, uint32_t lineLength)</span>
<a href="#l32.87"></a><span id="l32.87"> {</span>
<a href="#l32.88"></a><span id="l32.88">   m_envelope_pos = m_position;</span>
<a href="#l32.89"></a><span id="l32.89">   m_state = nsIMsgParseMailMsgState::ParseHeadersState;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/mailnews/local/src/nsParseMailbox.h</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/mailnews/local/src/nsParseMailbox.h</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -21,17 +21,17 @@</span>
<a href="#l33.4"></a><span id="l33.4"> #include &quot;nsIWeakReferenceUtils.h&quot;</span>
<a href="#l33.5"></a><span id="l33.5"> #include &quot;nsIMsgWindow.h&quot;</span>
<a href="#l33.6"></a><span id="l33.6"> #include &quot;nsImapMoveCoalescer.h&quot;</span>
<a href="#l33.7"></a><span id="l33.7"> #include &quot;nsAutoPtr.h&quot;</span>
<a href="#l33.8"></a><span id="l33.8"> #include &quot;nsStringGlue.h&quot;</span>
<a href="#l33.9"></a><span id="l33.9"> #include &quot;nsIMsgFilterList.h&quot;</span>
<a href="#l33.10"></a><span id="l33.10"> #include &quot;nsIMsgFilterHitNotify.h&quot;</span>
<a href="#l33.11"></a><span id="l33.11"> #include &quot;nsIMsgFolderNotificationService.h&quot;</span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l33.14"></a><span id="l33.14"> </span>
<a href="#l33.15"></a><span id="l33.15"> class nsByteArray;</span>
<a href="#l33.16"></a><span id="l33.16"> class nsOutputFileStream;</span>
<a href="#l33.17"></a><span id="l33.17"> class nsIOFileStream;</span>
<a href="#l33.18"></a><span id="l33.18"> class nsInputFileStream;</span>
<a href="#l33.19"></a><span id="l33.19"> class nsIMsgFilter;</span>
<a href="#l33.20"></a><span id="l33.20"> class MSG_FolderInfoMail;</span>
<a href="#l33.21"></a><span id="l33.21"> class nsIMsgFilterList;</span>
<a href="#l33.22"></a><span id="l33.22" class="difflineat">@@ -90,21 +90,21 @@ public:</span>
<a href="#l33.23"></a><span id="l33.23">   struct message_header m_mozstatus;</span>
<a href="#l33.24"></a><span id="l33.24">   struct message_header m_mozstatus2;</span>
<a href="#l33.25"></a><span id="l33.25">   struct message_header m_in_reply_to;</span>
<a href="#l33.26"></a><span id="l33.26">   struct message_header m_replyTo;</span>
<a href="#l33.27"></a><span id="l33.27">   struct message_header m_content_type;</span>
<a href="#l33.28"></a><span id="l33.28">   struct message_header m_bccList;</span>
<a href="#l33.29"></a><span id="l33.29"> </span>
<a href="#l33.30"></a><span id="l33.30">   // Support for having multiple To or Cc header lines in a message</span>
<a href="#l33.31"></a><span id="l33.31" class="difflineminus">-  nsVoidArray m_toList;</span>
<a href="#l33.32"></a><span id="l33.32" class="difflineminus">-  nsVoidArray m_ccList;</span>
<a href="#l33.33"></a><span id="l33.33" class="difflineminus">-  struct message_header *GetNextHeaderInAggregate (nsVoidArray &amp;list);</span>
<a href="#l33.34"></a><span id="l33.34" class="difflineminus">-  void GetAggregateHeader (nsVoidArray &amp;list, struct message_header *);</span>
<a href="#l33.35"></a><span id="l33.35" class="difflineminus">-  void ClearAggregateHeader (nsVoidArray &amp;list);</span>
<a href="#l33.36"></a><span id="l33.36" class="difflineplus">+  nsTArray&lt;struct message_header*&gt; m_toList;</span>
<a href="#l33.37"></a><span id="l33.37" class="difflineplus">+  nsTArray&lt;struct message_header*&gt; m_ccList;</span>
<a href="#l33.38"></a><span id="l33.38" class="difflineplus">+  struct message_header *GetNextHeaderInAggregate (nsTArray&lt;struct message_header*&gt; &amp;list);</span>
<a href="#l33.39"></a><span id="l33.39" class="difflineplus">+  void GetAggregateHeader (nsTArray&lt;struct message_header*&gt; &amp;list, struct message_header *);</span>
<a href="#l33.40"></a><span id="l33.40" class="difflineplus">+  void ClearAggregateHeader (nsTArray&lt;struct message_header*&gt; &amp;list);</span>
<a href="#l33.41"></a><span id="l33.41"> </span>
<a href="#l33.42"></a><span id="l33.42">   struct message_header m_envelope_from;</span>
<a href="#l33.43"></a><span id="l33.43">   struct message_header m_envelope_date;</span>
<a href="#l33.44"></a><span id="l33.44">   struct message_header m_priority;</span>
<a href="#l33.45"></a><span id="l33.45">   struct message_header m_account_key;</span>
<a href="#l33.46"></a><span id="l33.46">   struct message_header m_keywords;</span>
<a href="#l33.47"></a><span id="l33.47">   // Mdn support</span>
<a href="#l33.48"></a><span id="l33.48">   struct message_header m_mdn_original_recipient;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/mailnews/local/src/nsPop3IncomingServer.cpp</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/mailnews/local/src/nsPop3IncomingServer.cpp</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -643,20 +643,20 @@ NS_IMETHODIMP nsPop3IncomingServer::Mark</span>
<a href="#l34.4"></a><span id="l34.4"> </span>
<a href="#l34.5"></a><span id="l34.5">     GetLocalPath(getter_AddRefs(localPath));</span>
<a href="#l34.6"></a><span id="l34.6"> </span>
<a href="#l34.7"></a><span id="l34.7">     GetHostName(hostName);</span>
<a href="#l34.8"></a><span id="l34.8">     GetUsername(userName);</span>
<a href="#l34.9"></a><span id="l34.9">     // do it all in one fell swoop</span>
<a href="#l34.10"></a><span id="l34.10">     rv = nsPop3Protocol::MarkMsgForHost(hostName.get(), userName.get(), localPath, m_uidlsToMark);</span>
<a href="#l34.11"></a><span id="l34.11">   }</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-  uint32_t count = m_uidlsToMark.Count();</span>
<a href="#l34.13"></a><span id="l34.13" class="difflineplus">+  uint32_t count = m_uidlsToMark.Length();</span>
<a href="#l34.14"></a><span id="l34.14">   for (uint32_t i = 0; i &lt; count; i++)</span>
<a href="#l34.15"></a><span id="l34.15">   {</span>
<a href="#l34.16"></a><span id="l34.16" class="difflineminus">-    Pop3UidlEntry *ue = static_cast&lt;Pop3UidlEntry*&gt;(m_uidlsToMark[i]);</span>
<a href="#l34.17"></a><span id="l34.17" class="difflineplus">+    Pop3UidlEntry *ue = m_uidlsToMark[i];</span>
<a href="#l34.18"></a><span id="l34.18">     PR_Free(ue-&gt;uidl);</span>
<a href="#l34.19"></a><span id="l34.19">     PR_Free(ue);</span>
<a href="#l34.20"></a><span id="l34.20">   }</span>
<a href="#l34.21"></a><span id="l34.21">   m_uidlsToMark.Clear();</span>
<a href="#l34.22"></a><span id="l34.22">   return rv;</span>
<a href="#l34.23"></a><span id="l34.23"> }</span>
<a href="#l34.24"></a><span id="l34.24"> </span>
<a href="#l34.25"></a><span id="l34.25"> NS_IMPL_ISUPPORTS(nsPop3GetMailChainer, nsIUrlListener)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/mailnews/local/src/nsPop3IncomingServer.h</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/mailnews/local/src/nsPop3IncomingServer.h</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -46,12 +46,12 @@ protected:</span>
<a href="#l35.4"></a><span id="l35.4">   virtual ~nsPop3IncomingServer();</span>
<a href="#l35.5"></a><span id="l35.5">   nsresult GetInbox(nsIMsgWindow *msgWindow, nsIMsgFolder **inbox);</span>
<a href="#l35.6"></a><span id="l35.6"> </span>
<a href="#l35.7"></a><span id="l35.7"> private:</span>
<a href="#l35.8"></a><span id="l35.8">   uint32_t m_capabilityFlags;</span>
<a href="#l35.9"></a><span id="l35.9">   bool m_authenticated;</span>
<a href="#l35.10"></a><span id="l35.10">   nsCOMPtr &lt;nsIPop3Protocol&gt; m_runningProtocol;</span>
<a href="#l35.11"></a><span id="l35.11">   nsCOMPtr &lt;nsIMsgFolder&gt; m_rootMsgFolder;</span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-  nsVoidArray m_uidlsToMark;</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+  nsTArray&lt;Pop3UidlEntry*&gt; m_uidlsToMark;</span>
<a href="#l35.14"></a><span id="l35.14"> };</span>
<a href="#l35.15"></a><span id="l35.15"> </span>
<a href="#l35.16"></a><span id="l35.16"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/mailnews/local/src/nsPop3Protocol.cpp</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/mailnews/local/src/nsPop3Protocol.cpp</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -396,32 +396,31 @@ void nsPop3Protocol::MarkMsgInHashTable(</span>
<a href="#l36.4"></a><span id="l36.4">     }</span>
<a href="#l36.5"></a><span id="l36.5">   }</span>
<a href="#l36.6"></a><span id="l36.6"> }</span>
<a href="#l36.7"></a><span id="l36.7"> </span>
<a href="#l36.8"></a><span id="l36.8"> /* static */</span>
<a href="#l36.9"></a><span id="l36.9"> nsresult</span>
<a href="#l36.10"></a><span id="l36.10"> nsPop3Protocol::MarkMsgForHost(const char *hostName, const char *userName,</span>
<a href="#l36.11"></a><span id="l36.11">                                       nsIFile *mailDirectory,</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineminus">-                                       nsVoidArray &amp;UIDLArray)</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+                                       nsTArray&lt;Pop3UidlEntry*&gt; &amp;UIDLArray)</span>
<a href="#l36.14"></a><span id="l36.14"> {</span>
<a href="#l36.15"></a><span id="l36.15">   if (!hostName || !userName || !mailDirectory)</span>
<a href="#l36.16"></a><span id="l36.16">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l36.17"></a><span id="l36.17"> </span>
<a href="#l36.18"></a><span id="l36.18">   Pop3UidlHost *uidlHost = net_pop3_load_state(hostName, userName, mailDirectory);</span>
<a href="#l36.19"></a><span id="l36.19">   if (!uidlHost)</span>
<a href="#l36.20"></a><span id="l36.20">     return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l36.21"></a><span id="l36.21"> </span>
<a href="#l36.22"></a><span id="l36.22">   bool changed = false;</span>
<a href="#l36.23"></a><span id="l36.23"> </span>
<a href="#l36.24"></a><span id="l36.24" class="difflineminus">-  uint32_t count = UIDLArray.Count();</span>
<a href="#l36.25"></a><span id="l36.25" class="difflineplus">+  uint32_t count = UIDLArray.Length();</span>
<a href="#l36.26"></a><span id="l36.26">   for (uint32_t i = 0; i &lt; count; i++)</span>
<a href="#l36.27"></a><span id="l36.27">   {</span>
<a href="#l36.28"></a><span id="l36.28" class="difflineminus">-    MarkMsgInHashTable(uidlHost-&gt;hash,</span>
<a href="#l36.29"></a><span id="l36.29" class="difflineminus">-      static_cast&lt;Pop3UidlEntry*&gt;(UIDLArray[i]), &amp;changed);</span>
<a href="#l36.30"></a><span id="l36.30" class="difflineplus">+    MarkMsgInHashTable(uidlHost-&gt;hash, UIDLArray[i], &amp;changed);</span>
<a href="#l36.31"></a><span id="l36.31">   }</span>
<a href="#l36.32"></a><span id="l36.32"> </span>
<a href="#l36.33"></a><span id="l36.33">   if (changed)</span>
<a href="#l36.34"></a><span id="l36.34">     net_pop3_write_state(uidlHost, mailDirectory);</span>
<a href="#l36.35"></a><span id="l36.35">   net_pop3_free_state(uidlHost);</span>
<a href="#l36.36"></a><span id="l36.36">   return NS_OK;</span>
<a href="#l36.37"></a><span id="l36.37"> }</span>
<a href="#l36.38"></a><span id="l36.38"> </span>
<a href="#l36.39"></a><span id="l36.39" class="difflineat">@@ -4074,28 +4073,28 @@ nsresult nsPop3Protocol::ProcessProtocol</span>
<a href="#l36.40"></a><span id="l36.40">     }</span>
<a href="#l36.41"></a><span id="l36.41"> </span>
<a href="#l36.42"></a><span id="l36.42">   }  /* end while */</span>
<a href="#l36.43"></a><span id="l36.43"> </span>
<a href="#l36.44"></a><span id="l36.44">   return NS_OK;</span>
<a href="#l36.45"></a><span id="l36.45"> </span>
<a href="#l36.46"></a><span id="l36.46"> }</span>
<a href="#l36.47"></a><span id="l36.47"> </span>
<a href="#l36.48"></a><span id="l36.48" class="difflineminus">-NS_IMETHODIMP nsPop3Protocol::MarkMessages(nsVoidArray *aUIDLArray)</span>
<a href="#l36.49"></a><span id="l36.49" class="difflineplus">+NS_IMETHODIMP nsPop3Protocol::MarkMessages(nsTArray&lt;Pop3UidlEntry*&gt; *aUIDLArray)</span>
<a href="#l36.50"></a><span id="l36.50"> {</span>
<a href="#l36.51"></a><span id="l36.51">   NS_ENSURE_ARG_POINTER(aUIDLArray);</span>
<a href="#l36.52"></a><span id="l36.52" class="difflineminus">-  uint32_t count = aUIDLArray-&gt;Count();</span>
<a href="#l36.53"></a><span id="l36.53" class="difflineplus">+  uint32_t count = aUIDLArray-&gt;Length();</span>
<a href="#l36.54"></a><span id="l36.54"> </span>
<a href="#l36.55"></a><span id="l36.55">   for (uint32_t i = 0; i &lt; count; i++)</span>
<a href="#l36.56"></a><span id="l36.56">   {</span>
<a href="#l36.57"></a><span id="l36.57">     bool changed;</span>
<a href="#l36.58"></a><span id="l36.58">     if (m_pop3ConData-&gt;newuidl)</span>
<a href="#l36.59"></a><span id="l36.59" class="difflineminus">-      MarkMsgInHashTable(m_pop3ConData-&gt;newuidl, static_cast&lt;Pop3UidlEntry*&gt;(aUIDLArray-&gt;ElementAt(i)), &amp;changed);</span>
<a href="#l36.60"></a><span id="l36.60" class="difflineplus">+      MarkMsgInHashTable(m_pop3ConData-&gt;newuidl, aUIDLArray-&gt;ElementAt(i), &amp;changed);</span>
<a href="#l36.61"></a><span id="l36.61">     if (m_pop3ConData-&gt;uidlinfo)</span>
<a href="#l36.62"></a><span id="l36.62" class="difflineminus">-      MarkMsgInHashTable(m_pop3ConData-&gt;uidlinfo-&gt;hash, static_cast&lt;Pop3UidlEntry*&gt;(aUIDLArray-&gt;ElementAt(i)), &amp;changed);</span>
<a href="#l36.63"></a><span id="l36.63" class="difflineplus">+      MarkMsgInHashTable(m_pop3ConData-&gt;uidlinfo-&gt;hash, aUIDLArray-&gt;ElementAt(i), &amp;changed);</span>
<a href="#l36.64"></a><span id="l36.64">   }</span>
<a href="#l36.65"></a><span id="l36.65">   return NS_OK;</span>
<a href="#l36.66"></a><span id="l36.66"> }</span>
<a href="#l36.67"></a><span id="l36.67"> </span>
<a href="#l36.68"></a><span id="l36.68"> NS_IMETHODIMP nsPop3Protocol::CheckMessage(const char *aUidl, bool *aBool)</span>
<a href="#l36.69"></a><span id="l36.69"> {</span>
<a href="#l36.70"></a><span id="l36.70">   Pop3UidlEntry *uidlEntry = nullptr;</span>
<a href="#l36.71"></a><span id="l36.71"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/mailnews/local/src/nsPop3Protocol.h</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/mailnews/local/src/nsPop3Protocol.h</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -273,17 +273,17 @@ public:</span>
<a href="#l37.4"></a><span id="l37.4">   NS_IMETHOD OnStopRequest(nsIRequest *request, nsISupports * aContext, nsresult aStatus) override;</span>
<a href="#l37.5"></a><span id="l37.5">   NS_IMETHOD Cancel(nsresult status) override;</span>
<a href="#l37.6"></a><span id="l37.6"> </span>
<a href="#l37.7"></a><span id="l37.7">   static void MarkMsgInHashTable(PLHashTable *hashTable, const Pop3UidlEntry *uidl,</span>
<a href="#l37.8"></a><span id="l37.8">                                   bool *changed);</span>
<a href="#l37.9"></a><span id="l37.9"> </span>
<a href="#l37.10"></a><span id="l37.10">   static nsresult MarkMsgForHost(const char *hostName, const char *userName,</span>
<a href="#l37.11"></a><span id="l37.11">                                       nsIFile *mailDirectory,</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineminus">-                                      nsVoidArray  &amp;UIDLArray);</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+                                      nsTArray&lt;Pop3UidlEntry*&gt; &amp;UIDLArray);</span>
<a href="#l37.14"></a><span id="l37.14"> private:</span>
<a href="#l37.15"></a><span id="l37.15">   virtual ~nsPop3Protocol();</span>
<a href="#l37.16"></a><span id="l37.16">   nsCString m_ApopTimestamp;</span>
<a href="#l37.17"></a><span id="l37.17">   nsCOMPtr&lt;nsIStringBundle&gt; mLocalBundle;</span>
<a href="#l37.18"></a><span id="l37.18"> </span>
<a href="#l37.19"></a><span id="l37.19">   nsCString m_username;</span>
<a href="#l37.20"></a><span id="l37.20">   nsCString m_senderInfo;</span>
<a href="#l37.21"></a><span id="l37.21">   nsCString m_commandResponse;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1" class="difflineminus">--- a/mailnews/mime/emitters/nsMimeBaseEmitter.cpp</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineplus">+++ b/mailnews/mime/emitters/nsMimeBaseEmitter.cpp</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineat">@@ -55,21 +55,21 @@ nsMimeBaseEmitter::nsMimeBaseEmitter()</span>
<a href="#l38.4"></a><span id="l38.4">   // Display output control vars...</span>
<a href="#l38.5"></a><span id="l38.5">   mDocHeader = false;</span>
<a href="#l38.6"></a><span id="l38.6">   m_stringBundle = nullptr;</span>
<a href="#l38.7"></a><span id="l38.7">   mURL = nullptr;</span>
<a href="#l38.8"></a><span id="l38.8">   mHeaderDisplayType = nsMimeHeaderDisplayTypes::NormalHeaders;</span>
<a href="#l38.9"></a><span id="l38.9"> </span>
<a href="#l38.10"></a><span id="l38.10">   // Setup array for attachments</span>
<a href="#l38.11"></a><span id="l38.11">   mAttachCount = 0;</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineminus">-  mAttachArray = new nsVoidArray();</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineplus">+  mAttachArray = new nsTArray&lt;attachmentInfoType*&gt;();</span>
<a href="#l38.14"></a><span id="l38.14">   mCurrentAttachment = nullptr;</span>
<a href="#l38.15"></a><span id="l38.15"> </span>
<a href="#l38.16"></a><span id="l38.16">   // Header cache...</span>
<a href="#l38.17"></a><span id="l38.17" class="difflineminus">-  mHeaderArray = new nsVoidArray();</span>
<a href="#l38.18"></a><span id="l38.18" class="difflineplus">+  mHeaderArray = new nsTArray&lt;headerInfoType*&gt;();</span>
<a href="#l38.19"></a><span id="l38.19"> </span>
<a href="#l38.20"></a><span id="l38.20">   // Embedded Header Cache...</span>
<a href="#l38.21"></a><span id="l38.21">   mEmbeddedHeaderArray = nullptr;</span>
<a href="#l38.22"></a><span id="l38.22"> </span>
<a href="#l38.23"></a><span id="l38.23">   // HTML Header Data...</span>
<a href="#l38.24"></a><span id="l38.24"> //  mHTMLHeaders = &quot;&quot;;</span>
<a href="#l38.25"></a><span id="l38.25"> //  mCharset = &quot;&quot;;</span>
<a href="#l38.26"></a><span id="l38.26"> </span>
<a href="#l38.27"></a><span id="l38.27" class="difflineat">@@ -98,17 +98,17 @@ nsMimeBaseEmitter::~nsMimeBaseEmitter(vo</span>
<a href="#l38.28"></a><span id="l38.28">   {</span>
<a href="#l38.29"></a><span id="l38.29">     delete mBufferMgr;</span>
<a href="#l38.30"></a><span id="l38.30">     mBufferMgr = nullptr;</span>
<a href="#l38.31"></a><span id="l38.31">   }</span>
<a href="#l38.32"></a><span id="l38.32"> </span>
<a href="#l38.33"></a><span id="l38.33">   // Clean up the attachment array structures...</span>
<a href="#l38.34"></a><span id="l38.34">   if (mAttachArray)</span>
<a href="#l38.35"></a><span id="l38.35">   {</span>
<a href="#l38.36"></a><span id="l38.36" class="difflineminus">-    for (i=0; i&lt;mAttachArray-&gt;Count(); i++)</span>
<a href="#l38.37"></a><span id="l38.37" class="difflineplus">+    for (i=0; i&lt;mAttachArray-&gt;Length(); i++)</span>
<a href="#l38.38"></a><span id="l38.38">     {</span>
<a href="#l38.39"></a><span id="l38.39">       attachmentInfoType *attachInfo = (attachmentInfoType *)mAttachArray-&gt;ElementAt(i);</span>
<a href="#l38.40"></a><span id="l38.40">       if (!attachInfo)</span>
<a href="#l38.41"></a><span id="l38.41">         continue;</span>
<a href="#l38.42"></a><span id="l38.42"> </span>
<a href="#l38.43"></a><span id="l38.43">       PR_FREEIF(attachInfo-&gt;contentType);</span>
<a href="#l38.44"></a><span id="l38.44">       if (attachInfo-&gt;displayName)</span>
<a href="#l38.45"></a><span id="l38.45">         NS_Free(attachInfo-&gt;displayName);</span>
<a href="#l38.46"></a><span id="l38.46" class="difflineat">@@ -128,24 +128,24 @@ nsMimeBaseEmitter::~nsMimeBaseEmitter(vo</span>
<a href="#l38.47"></a><span id="l38.47"> </span>
<a href="#l38.48"></a><span id="l38.48"> NS_IMETHODIMP nsMimeBaseEmitter::GetInterface(const nsIID &amp; aIID, void * *aInstancePtr)</span>
<a href="#l38.49"></a><span id="l38.49"> {</span>
<a href="#l38.50"></a><span id="l38.50">   NS_ENSURE_ARG_POINTER(aInstancePtr);</span>
<a href="#l38.51"></a><span id="l38.51">   return QueryInterface(aIID, aInstancePtr);</span>
<a href="#l38.52"></a><span id="l38.52"> }</span>
<a href="#l38.53"></a><span id="l38.53"> </span>
<a href="#l38.54"></a><span id="l38.54"> void</span>
<a href="#l38.55"></a><span id="l38.55" class="difflineminus">-nsMimeBaseEmitter::CleanupHeaderArray(nsVoidArray *aArray)</span>
<a href="#l38.56"></a><span id="l38.56" class="difflineplus">+nsMimeBaseEmitter::CleanupHeaderArray(nsTArray&lt;headerInfoType*&gt; *aArray)</span>
<a href="#l38.57"></a><span id="l38.57"> {</span>
<a href="#l38.58"></a><span id="l38.58">   if (!aArray)</span>
<a href="#l38.59"></a><span id="l38.59">     return;</span>
<a href="#l38.60"></a><span id="l38.60"> </span>
<a href="#l38.61"></a><span id="l38.61" class="difflineminus">-  for (int32_t i=0; i&lt;aArray-&gt;Count(); i++)</span>
<a href="#l38.62"></a><span id="l38.62" class="difflineplus">+  for (int32_t i=0; i&lt;aArray-&gt;Length(); i++)</span>
<a href="#l38.63"></a><span id="l38.63">   {</span>
<a href="#l38.64"></a><span id="l38.64" class="difflineminus">-    headerInfoType *headerInfo = (headerInfoType *)aArray-&gt;ElementAt(i);</span>
<a href="#l38.65"></a><span id="l38.65" class="difflineplus">+    headerInfoType *headerInfo = aArray-&gt;ElementAt(i);</span>
<a href="#l38.66"></a><span id="l38.66">     if (!headerInfo)</span>
<a href="#l38.67"></a><span id="l38.67">       continue;</span>
<a href="#l38.68"></a><span id="l38.68"> </span>
<a href="#l38.69"></a><span id="l38.69">     PR_FREEIF(headerInfo-&gt;name);</span>
<a href="#l38.70"></a><span id="l38.70">     PR_FREEIF(headerInfo-&gt;value);</span>
<a href="#l38.71"></a><span id="l38.71">     PR_FREEIF(headerInfo);</span>
<a href="#l38.72"></a><span id="l38.72">   }</span>
<a href="#l38.73"></a><span id="l38.73"> </span>
<a href="#l38.74"></a><span id="l38.74" class="difflineat">@@ -497,24 +497,24 @@ nsMimeBaseEmitter::WriteHelper(const nsA</span>
<a href="#l38.75"></a><span id="l38.75"> //</span>
<a href="#l38.76"></a><span id="l38.76"> // Find a cached header! Note: Do NOT free this value!</span>
<a href="#l38.77"></a><span id="l38.77"> //</span>
<a href="#l38.78"></a><span id="l38.78"> const char *</span>
<a href="#l38.79"></a><span id="l38.79"> nsMimeBaseEmitter::GetHeaderValue(const char  *aHeaderName)</span>
<a href="#l38.80"></a><span id="l38.80"> {</span>
<a href="#l38.81"></a><span id="l38.81">   int32_t     i;</span>
<a href="#l38.82"></a><span id="l38.82">   char        *retVal = nullptr;</span>
<a href="#l38.83"></a><span id="l38.83" class="difflineminus">-  nsVoidArray *array = mDocHeader? mHeaderArray : mEmbeddedHeaderArray;</span>
<a href="#l38.84"></a><span id="l38.84" class="difflineplus">+  nsTArray&lt;headerInfoType*&gt; *array = mDocHeader? mHeaderArray : mEmbeddedHeaderArray;</span>
<a href="#l38.85"></a><span id="l38.85"> </span>
<a href="#l38.86"></a><span id="l38.86">   if (!array)</span>
<a href="#l38.87"></a><span id="l38.87">     return nullptr;</span>
<a href="#l38.88"></a><span id="l38.88"> </span>
<a href="#l38.89"></a><span id="l38.89" class="difflineminus">-  for (i = 0; i &lt; array-&gt;Count(); i++)</span>
<a href="#l38.90"></a><span id="l38.90" class="difflineplus">+  for (i = 0; i &lt; array-&gt;Length(); i++)</span>
<a href="#l38.91"></a><span id="l38.91">   {</span>
<a href="#l38.92"></a><span id="l38.92" class="difflineminus">-    headerInfoType *headerInfo = (headerInfoType *)array-&gt;ElementAt(i);</span>
<a href="#l38.93"></a><span id="l38.93" class="difflineplus">+    headerInfoType *headerInfo = array-&gt;ElementAt(i);</span>
<a href="#l38.94"></a><span id="l38.94">     if ( (!headerInfo) || (!headerInfo-&gt;name) || (!(*headerInfo-&gt;name)) )</span>
<a href="#l38.95"></a><span id="l38.95">       continue;</span>
<a href="#l38.96"></a><span id="l38.96"> </span>
<a href="#l38.97"></a><span id="l38.97">     if (!PL_strcasecmp(aHeaderName, headerInfo-&gt;name))</span>
<a href="#l38.98"></a><span id="l38.98">     {</span>
<a href="#l38.99"></a><span id="l38.99">       retVal = headerInfo-&gt;value;</span>
<a href="#l38.100"></a><span id="l38.100">       break;</span>
<a href="#l38.101"></a><span id="l38.101">     }</span>
<a href="#l38.102"></a><span id="l38.102" class="difflineat">@@ -542,17 +542,17 @@ nsMimeBaseEmitter::StartHeader(bool root</span>
<a href="#l38.103"></a><span id="l38.103">   // If this is not the mail messages header, then we need to create</span>
<a href="#l38.104"></a><span id="l38.104">   // the mEmbeddedHeaderArray structure for use with this internal header</span>
<a href="#l38.105"></a><span id="l38.105">   // structure.</span>
<a href="#l38.106"></a><span id="l38.106">   if (!mDocHeader)</span>
<a href="#l38.107"></a><span id="l38.107">   {</span>
<a href="#l38.108"></a><span id="l38.108">     if (mEmbeddedHeaderArray)</span>
<a href="#l38.109"></a><span id="l38.109">       CleanupHeaderArray(mEmbeddedHeaderArray);</span>
<a href="#l38.110"></a><span id="l38.110"> </span>
<a href="#l38.111"></a><span id="l38.111" class="difflineminus">-    mEmbeddedHeaderArray = new nsVoidArray();</span>
<a href="#l38.112"></a><span id="l38.112" class="difflineplus">+    mEmbeddedHeaderArray = new nsTArray&lt;headerInfoType*&gt;();</span>
<a href="#l38.113"></a><span id="l38.113">     NS_ENSURE_TRUE(mEmbeddedHeaderArray, NS_ERROR_OUT_OF_MEMORY);</span>
<a href="#l38.114"></a><span id="l38.114">   }</span>
<a href="#l38.115"></a><span id="l38.115"> </span>
<a href="#l38.116"></a><span id="l38.116">   // If the main doc, check on updated character set</span>
<a href="#l38.117"></a><span id="l38.117">   if (mDocHeader)</span>
<a href="#l38.118"></a><span id="l38.118">     UpdateCharacterSet(outCharset);</span>
<a href="#l38.119"></a><span id="l38.119">   CopyASCIItoUTF16(nsDependentCString(outCharset), mCharset);</span>
<a href="#l38.120"></a><span id="l38.120">   return NS_OK;</span>
<a href="#l38.121"></a><span id="l38.121" class="difflineat">@@ -610,17 +610,17 @@ nsMimeBaseEmitter::UpdateCharacterSet(co</span>
<a href="#l38.122"></a><span id="l38.122"> // internal body or the outer message.</span>
<a href="#l38.123"></a><span id="l38.123"> //</span>
<a href="#l38.124"></a><span id="l38.124"> NS_IMETHODIMP</span>
<a href="#l38.125"></a><span id="l38.125"> nsMimeBaseEmitter::AddHeaderField(const char *field, const char *value)</span>
<a href="#l38.126"></a><span id="l38.126"> {</span>
<a href="#l38.127"></a><span id="l38.127">   if ( (!field) || (!value) )</span>
<a href="#l38.128"></a><span id="l38.128">     return NS_OK;</span>
<a href="#l38.129"></a><span id="l38.129"> </span>
<a href="#l38.130"></a><span id="l38.130" class="difflineminus">-  nsVoidArray   *tPtr;</span>
<a href="#l38.131"></a><span id="l38.131" class="difflineplus">+  nsTArray&lt;headerInfoType*&gt;  *tPtr;</span>
<a href="#l38.132"></a><span id="l38.132">   if (mDocHeader)</span>
<a href="#l38.133"></a><span id="l38.133">     tPtr = mHeaderArray;</span>
<a href="#l38.134"></a><span id="l38.134">   else</span>
<a href="#l38.135"></a><span id="l38.135">     tPtr = mEmbeddedHeaderArray;</span>
<a href="#l38.136"></a><span id="l38.136"> </span>
<a href="#l38.137"></a><span id="l38.137">   // This is a header so we need to cache and output later.</span>
<a href="#l38.138"></a><span id="l38.138">   // Ok, now we will setup the header info for the header array!</span>
<a href="#l38.139"></a><span id="l38.139">   headerInfoType  *ptr = (headerInfoType *) PR_NEWZAP(headerInfoType);</span>
<a href="#l38.140"></a><span id="l38.140" class="difflineat">@@ -981,23 +981,23 @@ nsMimeBaseEmitter::DumpToCC()</span>
<a href="#l38.141"></a><span id="l38.141"> </span>
<a href="#l38.142"></a><span id="l38.142">   return NS_OK;</span>
<a href="#l38.143"></a><span id="l38.143"> }</span>
<a href="#l38.144"></a><span id="l38.144"> </span>
<a href="#l38.145"></a><span id="l38.145"> nsresult</span>
<a href="#l38.146"></a><span id="l38.146"> nsMimeBaseEmitter::DumpRestOfHeaders()</span>
<a href="#l38.147"></a><span id="l38.147"> {</span>
<a href="#l38.148"></a><span id="l38.148">   int32_t     i;</span>
<a href="#l38.149"></a><span id="l38.149" class="difflineminus">-  nsVoidArray *array = mDocHeader? mHeaderArray : mEmbeddedHeaderArray;</span>
<a href="#l38.150"></a><span id="l38.150" class="difflineplus">+  nsTArray&lt;headerInfoType*&gt; *array = mDocHeader? mHeaderArray : mEmbeddedHeaderArray;</span>
<a href="#l38.151"></a><span id="l38.151"> </span>
<a href="#l38.152"></a><span id="l38.152">   mHTMLHeaders.Append(&quot;&lt;table border=0 cellspacing=0 cellpadding=0 width=\&quot;100%\&quot; class=\&quot;header-part3\&quot;&gt;&quot;);</span>
<a href="#l38.153"></a><span id="l38.153"> </span>
<a href="#l38.154"></a><span id="l38.154" class="difflineminus">-  for (i = 0; i &lt; array-&gt;Count(); i++)</span>
<a href="#l38.155"></a><span id="l38.155" class="difflineplus">+  for (i = 0; i &lt; array-&gt;Length(); i++)</span>
<a href="#l38.156"></a><span id="l38.156">   {</span>
<a href="#l38.157"></a><span id="l38.157" class="difflineminus">-    headerInfoType *headerInfo = (headerInfoType *)array-&gt;ElementAt(i);</span>
<a href="#l38.158"></a><span id="l38.158" class="difflineplus">+    headerInfoType *headerInfo = array-&gt;ElementAt(i);</span>
<a href="#l38.159"></a><span id="l38.159">     if ( (!headerInfo) || (!headerInfo-&gt;name) || (!(*headerInfo-&gt;name)) ||</span>
<a href="#l38.160"></a><span id="l38.160">       (!headerInfo-&gt;value) || (!(*headerInfo-&gt;value)))</span>
<a href="#l38.161"></a><span id="l38.161">       continue;</span>
<a href="#l38.162"></a><span id="l38.162"> </span>
<a href="#l38.163"></a><span id="l38.163">     if ( (!PL_strcasecmp(HEADER_SUBJECT, headerInfo-&gt;name)) ||</span>
<a href="#l38.164"></a><span id="l38.164">       (!PL_strcasecmp(HEADER_DATE, headerInfo-&gt;name)) ||</span>
<a href="#l38.165"></a><span id="l38.165">       (!PL_strcasecmp(HEADER_FROM, headerInfo-&gt;name)) ||</span>
<a href="#l38.166"></a><span id="l38.166">       (!PL_strcasecmp(HEADER_TO, headerInfo-&gt;name)) ||</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1" class="difflineminus">--- a/mailnews/mime/emitters/nsMimeBaseEmitter.h</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineplus">+++ b/mailnews/mime/emitters/nsMimeBaseEmitter.h</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineat">@@ -13,17 +13,17 @@</span>
<a href="#l39.4"></a><span id="l39.4"> #include &quot;nsIOutputStream.h&quot;</span>
<a href="#l39.5"></a><span id="l39.5"> #include &quot;nsIAsyncInputStream.h&quot;</span>
<a href="#l39.6"></a><span id="l39.6"> #include &quot;nsIURI.h&quot;</span>
<a href="#l39.7"></a><span id="l39.7"> #include &quot;nsIChannel.h&quot;</span>
<a href="#l39.8"></a><span id="l39.8"> #include &quot;nsIMimeMiscStatus.h&quot;</span>
<a href="#l39.9"></a><span id="l39.9"> #include &quot;nsIPipe.h&quot;</span>
<a href="#l39.10"></a><span id="l39.10"> #include &quot;nsIStringBundle.h&quot;</span>
<a href="#l39.11"></a><span id="l39.11"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l39.12"></a><span id="l39.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l39.13"></a><span id="l39.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l39.14"></a><span id="l39.14"> #include &quot;nsIMimeConverter.h&quot;</span>
<a href="#l39.15"></a><span id="l39.15"> #include &quot;nsIInterfaceRequestor.h&quot;</span>
<a href="#l39.16"></a><span id="l39.16"> #include &quot;nsIInterfaceRequestorUtils.h&quot;</span>
<a href="#l39.17"></a><span id="l39.17"> #include &quot;nsIDateTimeFormat.h&quot;</span>
<a href="#l39.18"></a><span id="l39.18"> </span>
<a href="#l39.19"></a><span id="l39.19"> //</span>
<a href="#l39.20"></a><span id="l39.20"> // The base emitter will serve as the place to do all of the caching,</span>
<a href="#l39.21"></a><span id="l39.21"> // sorting, etc... of mail headers and bodies for this internally developed</span>
<a href="#l39.22"></a><span id="l39.22" class="difflineat">@@ -76,17 +76,17 @@ public:</span>
<a href="#l39.23"></a><span id="l39.23">   // To write out a stored header array as HTML</span>
<a href="#l39.24"></a><span id="l39.24">   virtual nsresult            WriteHeaderFieldHTMLPrefix(const nsACString &amp;name);</span>
<a href="#l39.25"></a><span id="l39.25">   virtual nsresult            WriteHeaderFieldHTML(const char *field, const char *value);</span>
<a href="#l39.26"></a><span id="l39.26">   virtual nsresult            WriteHeaderFieldHTMLPostfix();</span>
<a href="#l39.27"></a><span id="l39.27"> </span>
<a href="#l39.28"></a><span id="l39.28"> protected:</span>
<a href="#l39.29"></a><span id="l39.29">   virtual ~nsMimeBaseEmitter();</span>
<a href="#l39.30"></a><span id="l39.30">   // Internal methods...</span>
<a href="#l39.31"></a><span id="l39.31" class="difflineminus">-  void                CleanupHeaderArray(nsVoidArray *aArray);</span>
<a href="#l39.32"></a><span id="l39.32" class="difflineplus">+  void                CleanupHeaderArray(nsTArray&lt;headerInfoType*&gt; *aArray);</span>
<a href="#l39.33"></a><span id="l39.33"> </span>
<a href="#l39.34"></a><span id="l39.34">   // For header output...</span>
<a href="#l39.35"></a><span id="l39.35">   nsresult            DumpSubjectFromDate();</span>
<a href="#l39.36"></a><span id="l39.36">   nsresult            DumpToCC();</span>
<a href="#l39.37"></a><span id="l39.37">   nsresult            DumpRestOfHeaders();</span>
<a href="#l39.38"></a><span id="l39.38">   nsresult            OutputGenericHeader(const char *aHeaderVal);</span>
<a href="#l39.39"></a><span id="l39.39"> </span>
<a href="#l39.40"></a><span id="l39.40">   nsresult            WriteHelper(const nsACString &amp;buf, uint32_t *countWritten);</span>
<a href="#l39.41"></a><span id="l39.41" class="difflineat">@@ -114,22 +114,22 @@ protected:</span>
<a href="#l39.42"></a><span id="l39.42">   // Output control and info...</span>
<a href="#l39.43"></a><span id="l39.43">   bool                mDocHeader;         // For header determination...</span>
<a href="#l39.44"></a><span id="l39.44">   nsIURI              *mURL;              // the url for the data being processed...</span>
<a href="#l39.45"></a><span id="l39.45">   int32_t             mHeaderDisplayType; // The setting for header output...</span>
<a href="#l39.46"></a><span id="l39.46">   nsCString           mHTMLHeaders;       // HTML Header Data...</span>
<a href="#l39.47"></a><span id="l39.47"> </span>
<a href="#l39.48"></a><span id="l39.48">   // For attachment processing...</span>
<a href="#l39.49"></a><span id="l39.49">   int32_t             mAttachCount;</span>
<a href="#l39.50"></a><span id="l39.50" class="difflineminus">-  nsVoidArray         *mAttachArray;</span>
<a href="#l39.51"></a><span id="l39.51" class="difflineplus">+  nsTArray&lt;attachmentInfoType*&gt;  *mAttachArray;</span>
<a href="#l39.52"></a><span id="l39.52">   attachmentInfoType  *mCurrentAttachment;</span>
<a href="#l39.53"></a><span id="l39.53"> </span>
<a href="#l39.54"></a><span id="l39.54">   // For header caching...</span>
<a href="#l39.55"></a><span id="l39.55" class="difflineminus">-  nsVoidArray         *mHeaderArray;</span>
<a href="#l39.56"></a><span id="l39.56" class="difflineminus">-  nsVoidArray         *mEmbeddedHeaderArray;</span>
<a href="#l39.57"></a><span id="l39.57" class="difflineplus">+  nsTArray&lt;headerInfoType*&gt;  *mHeaderArray;</span>
<a href="#l39.58"></a><span id="l39.58" class="difflineplus">+  nsTArray&lt;headerInfoType*&gt;  *mEmbeddedHeaderArray;</span>
<a href="#l39.59"></a><span id="l39.59"> </span>
<a href="#l39.60"></a><span id="l39.60">   // For body caching...</span>
<a href="#l39.61"></a><span id="l39.61">   bool                mBodyStarted;</span>
<a href="#l39.62"></a><span id="l39.62">   nsCString           mBody;</span>
<a href="#l39.63"></a><span id="l39.63">   bool                mFirstHeaders;</span>
<a href="#l39.64"></a><span id="l39.64"> </span>
<a href="#l39.65"></a><span id="l39.65">   // For the format being used...</span>
<a href="#l39.66"></a><span id="l39.66">   int32_t             mFormat;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1" class="difflineminus">--- a/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineplus">+++ b/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineat">@@ -179,19 +179,19 @@ nsresult nsMimeHtmlDisplayEmitter::Broad</span>
<a href="#l40.4"></a><span id="l40.4">     // todo - should make this upper case</span>
<a href="#l40.5"></a><span id="l40.5">     if (!extraExpandedHeaders.IsEmpty())</span>
<a href="#l40.6"></a><span id="l40.6">     {</span>
<a href="#l40.7"></a><span id="l40.7">       ToLowerCase(extraExpandedHeaders);</span>
<a href="#l40.8"></a><span id="l40.8">       ParseString(extraExpandedHeaders, ' ', extraExpandedHeadersArray);</span>
<a href="#l40.9"></a><span id="l40.9">     }</span>
<a href="#l40.10"></a><span id="l40.10">   }</span>
<a href="#l40.11"></a><span id="l40.11"> </span>
<a href="#l40.12"></a><span id="l40.12" class="difflineminus">-  for (int32_t i=0; i&lt;mHeaderArray-&gt;Count(); i++)</span>
<a href="#l40.13"></a><span id="l40.13" class="difflineplus">+  for (int32_t i=0; i&lt;mHeaderArray-&gt;Length(); i++)</span>
<a href="#l40.14"></a><span id="l40.14">   {</span>
<a href="#l40.15"></a><span id="l40.15" class="difflineminus">-    headerInfoType * headerInfo = (headerInfoType *) mHeaderArray-&gt;ElementAt(i);</span>
<a href="#l40.16"></a><span id="l40.16" class="difflineplus">+    headerInfoType * headerInfo = mHeaderArray-&gt;ElementAt(i);</span>
<a href="#l40.17"></a><span id="l40.17">     if ( (!headerInfo) || (!headerInfo-&gt;name) || (!(*headerInfo-&gt;name)) || (!headerInfo-&gt;value) || (!(*headerInfo-&gt;value)))</span>
<a href="#l40.18"></a><span id="l40.18">       continue;</span>
<a href="#l40.19"></a><span id="l40.19"> </span>
<a href="#l40.20"></a><span id="l40.20">     const char * headerValue = headerInfo-&gt;value;</span>
<a href="#l40.21"></a><span id="l40.21"> </span>
<a href="#l40.22"></a><span id="l40.22">     // optimization: if we aren't in view all header view mode, we only show a small set of the total # of headers.</span>
<a href="#l40.23"></a><span id="l40.23">     // don't waste time sending those out to the UI since the UI is going to ignore them anyway.</span>
<a href="#l40.24"></a><span id="l40.24">     if (aHeaderMode != VIEW_ALL_HEADERS &amp;&amp; (mFormat != nsMimeOutput::nsMimeMessageFilterSniffer))</span>
<a href="#l40.25"></a><span id="l40.25" class="difflineat">@@ -246,19 +246,19 @@ NS_IMETHODIMP nsMimeHtmlDisplayEmitter::</span>
<a href="#l40.26"></a><span id="l40.26">       mFormat = nsMimeOutput::nsMimeMessagePrintOutput;</span>
<a href="#l40.27"></a><span id="l40.27"> </span>
<a href="#l40.28"></a><span id="l40.28">     return nsMimeBaseEmitter::WriteHTMLHeaders(name);</span>
<a href="#l40.29"></a><span id="l40.29">   }</span>
<a href="#l40.30"></a><span id="l40.30">   else</span>
<a href="#l40.31"></a><span id="l40.31">     mFirstHeaders = false;</span>
<a href="#l40.32"></a><span id="l40.32"> </span>
<a href="#l40.33"></a><span id="l40.33">   bool bFromNewsgroups = false;</span>
<a href="#l40.34"></a><span id="l40.34" class="difflineminus">-  for (int32_t j=0; j &lt; mHeaderArray-&gt;Count(); j++)</span>
<a href="#l40.35"></a><span id="l40.35" class="difflineplus">+  for (int32_t j=0; j &lt; mHeaderArray-&gt;Length(); j++)</span>
<a href="#l40.36"></a><span id="l40.36">   {</span>
<a href="#l40.37"></a><span id="l40.37" class="difflineminus">-    headerInfoType *headerInfo = (headerInfoType *)mHeaderArray-&gt;ElementAt(j);</span>
<a href="#l40.38"></a><span id="l40.38" class="difflineplus">+    headerInfoType *headerInfo = mHeaderArray-&gt;ElementAt(j);</span>
<a href="#l40.39"></a><span id="l40.39">     if (!(headerInfo &amp;&amp; headerInfo-&gt;name &amp;&amp; *headerInfo-&gt;name))</span>
<a href="#l40.40"></a><span id="l40.40">       continue;</span>
<a href="#l40.41"></a><span id="l40.41"> </span>
<a href="#l40.42"></a><span id="l40.42">     if (!PL_strcasecmp(&quot;Newsgroups&quot;, headerInfo-&gt;name))</span>
<a href="#l40.43"></a><span id="l40.43">     {</span>
<a href="#l40.44"></a><span id="l40.44">       bFromNewsgroups = true;</span>
<a href="#l40.45"></a><span id="l40.45">       break;</span>
<a href="#l40.46"></a><span id="l40.46">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1" class="difflineminus">--- a/mailnews/mime/src/mimei.cpp</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineplus">+++ b/mailnews/mime/src/mimei.cpp</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineat">@@ -57,17 +57,17 @@</span>
<a href="#l41.4"></a><span id="l41.4"> #include &quot;nsIServiceManager.h&quot;</span>
<a href="#l41.5"></a><span id="l41.5"> #include &quot;mimemoz2.h&quot;</span>
<a href="#l41.6"></a><span id="l41.6"> #include &quot;nsIMimeContentTypeHandler.h&quot;</span>
<a href="#l41.7"></a><span id="l41.7"> #include &quot;nsIComponentManager.h&quot;</span>
<a href="#l41.8"></a><span id="l41.8"> #include &quot;nsCategoryManagerUtils.h&quot;</span>
<a href="#l41.9"></a><span id="l41.9"> #include &quot;nsXPCOMCID.h&quot;</span>
<a href="#l41.10"></a><span id="l41.10"> #include &quot;nsISimpleMimeConverter.h&quot;</span>
<a href="#l41.11"></a><span id="l41.11"> #include &quot;nsSimpleMimeConverterStub.h&quot;</span>
<a href="#l41.12"></a><span id="l41.12" class="difflineminus">-#include &quot;nsVoidArray.h&quot;</span>
<a href="#l41.13"></a><span id="l41.13" class="difflineplus">+#include &quot;nsTArray.h&quot;</span>
<a href="#l41.14"></a><span id="l41.14"> #include &quot;nsMimeStringResources.h&quot;</span>
<a href="#l41.15"></a><span id="l41.15"> #include &quot;nsMimeTypes.h&quot;</span>
<a href="#l41.16"></a><span id="l41.16"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l41.17"></a><span id="l41.17"> #include &quot;nsIPrefBranch.h&quot;</span>
<a href="#l41.18"></a><span id="l41.18"> #include &quot;imgLoader.h&quot;</span>
<a href="#l41.19"></a><span id="l41.19"> </span>
<a href="#l41.20"></a><span id="l41.20"> #include &quot;nsIMsgMailNewsUrl.h&quot;</span>
<a href="#l41.21"></a><span id="l41.21"> #include &quot;nsIMsgHdr.h&quot;</span>
<a href="#l41.22"></a><span id="l41.22" class="difflineat">@@ -88,75 +88,58 @@ static int mime_classinit(MimeObjectClas</span>
<a href="#l41.23"></a><span id="l41.23">  * These are the necessary defines/variables for doing</span>
<a href="#l41.24"></a><span id="l41.24">  * content type handlers in external plugins.</span>
<a href="#l41.25"></a><span id="l41.25">  */</span>
<a href="#l41.26"></a><span id="l41.26"> typedef struct {</span>
<a href="#l41.27"></a><span id="l41.27">   char        content_type[128];</span>
<a href="#l41.28"></a><span id="l41.28">   bool        force_inline_display;</span>
<a href="#l41.29"></a><span id="l41.29"> } cthandler_struct;</span>
<a href="#l41.30"></a><span id="l41.30"> </span>
<a href="#l41.31"></a><span id="l41.31" class="difflineminus">-nsVoidArray         *ctHandlerList = NULL;</span>
<a href="#l41.32"></a><span id="l41.32" class="difflineminus">-bool                foundIt = false;</span>
<a href="#l41.33"></a><span id="l41.33" class="difflineminus">-bool                force_display = false;</span>
<a href="#l41.34"></a><span id="l41.34" class="difflineminus">-</span>
<a href="#l41.35"></a><span id="l41.35" class="difflineminus">-bool</span>
<a href="#l41.36"></a><span id="l41.36" class="difflineminus">-EnumFunction(void* aElement, void *aData)</span>
<a href="#l41.37"></a><span id="l41.37" class="difflineminus">-{</span>
<a href="#l41.38"></a><span id="l41.38" class="difflineminus">-  cthandler_struct    *ptr = (cthandler_struct *) aElement;</span>
<a href="#l41.39"></a><span id="l41.39" class="difflineminus">-  char                *ctPtr = (char *)aData;</span>
<a href="#l41.40"></a><span id="l41.40" class="difflineminus">-</span>
<a href="#l41.41"></a><span id="l41.41" class="difflineminus">-  if ( (!aElement) || (!aData) )</span>
<a href="#l41.42"></a><span id="l41.42" class="difflineminus">-    return true;</span>
<a href="#l41.43"></a><span id="l41.43" class="difflineminus">-</span>
<a href="#l41.44"></a><span id="l41.44" class="difflineminus">-  if (PL_strcasecmp(ctPtr, ptr-&gt;content_type) == 0)</span>
<a href="#l41.45"></a><span id="l41.45" class="difflineminus">-  {</span>
<a href="#l41.46"></a><span id="l41.46" class="difflineminus">-    foundIt = true;</span>
<a href="#l41.47"></a><span id="l41.47" class="difflineminus">-    force_display = ptr-&gt;force_inline_display;</span>
<a href="#l41.48"></a><span id="l41.48" class="difflineminus">-    return false;</span>
<a href="#l41.49"></a><span id="l41.49" class="difflineminus">-  }</span>
<a href="#l41.50"></a><span id="l41.50" class="difflineminus">-</span>
<a href="#l41.51"></a><span id="l41.51" class="difflineminus">-  return true;</span>
<a href="#l41.52"></a><span id="l41.52" class="difflineminus">-}</span>
<a href="#l41.53"></a><span id="l41.53" class="difflineplus">+nsTArray&lt;cthandler_struct*&gt; *ctHandlerList = NULL;</span>
<a href="#l41.54"></a><span id="l41.54"> </span>
<a href="#l41.55"></a><span id="l41.55"> /*</span>
<a href="#l41.56"></a><span id="l41.56">  * This will return TRUE if the content_type is found in the</span>
<a href="#l41.57"></a><span id="l41.57">  * list, FALSE if it is not found.</span>
<a href="#l41.58"></a><span id="l41.58">  */</span>
<a href="#l41.59"></a><span id="l41.59"> bool</span>
<a href="#l41.60"></a><span id="l41.60"> find_content_type_attribs(const char *content_type,</span>
<a href="#l41.61"></a><span id="l41.61">                           bool       *force_inline_display)</span>
<a href="#l41.62"></a><span id="l41.62"> {</span>
<a href="#l41.63"></a><span id="l41.63">   *force_inline_display = false;</span>
<a href="#l41.64"></a><span id="l41.64">   if (!ctHandlerList)</span>
<a href="#l41.65"></a><span id="l41.65">     return false;</span>
<a href="#l41.66"></a><span id="l41.66"> </span>
<a href="#l41.67"></a><span id="l41.67" class="difflineminus">-  foundIt = false;</span>
<a href="#l41.68"></a><span id="l41.68" class="difflineminus">-  force_display = false;</span>
<a href="#l41.69"></a><span id="l41.69" class="difflineminus">-  ctHandlerList-&gt;EnumerateForwards(EnumFunction, (void *)content_type);</span>
<a href="#l41.70"></a><span id="l41.70" class="difflineminus">-  if (foundIt)</span>
<a href="#l41.71"></a><span id="l41.71" class="difflineminus">-    *force_inline_display = force_display;</span>
<a href="#l41.72"></a><span id="l41.72" class="difflineplus">+  for (size_t i = 0; i &lt; ctHandlerList-&gt;Length(); i++) </span>
<a href="#l41.73"></a><span id="l41.73" class="difflineplus">+  {</span>
<a href="#l41.74"></a><span id="l41.74" class="difflineplus">+    cthandler_struct *ptr = ctHandlerList-&gt;ElementAt(i);</span>
<a href="#l41.75"></a><span id="l41.75" class="difflineplus">+    if (PL_strcasecmp(content_type, ptr-&gt;content_type) == 0)</span>
<a href="#l41.76"></a><span id="l41.76" class="difflineplus">+    {</span>
<a href="#l41.77"></a><span id="l41.77" class="difflineplus">+      *force_inline_display = ptr-&gt;force_inline_display;</span>
<a href="#l41.78"></a><span id="l41.78" class="difflineplus">+      return true;</span>
<a href="#l41.79"></a><span id="l41.79" class="difflineplus">+    }</span>
<a href="#l41.80"></a><span id="l41.80" class="difflineplus">+  }</span>
<a href="#l41.81"></a><span id="l41.81"> </span>
<a href="#l41.82"></a><span id="l41.82" class="difflineminus">-  return (foundIt);</span>
<a href="#l41.83"></a><span id="l41.83" class="difflineplus">+  return false;</span>
<a href="#l41.84"></a><span id="l41.84"> }</span>
<a href="#l41.85"></a><span id="l41.85"> </span>
<a href="#l41.86"></a><span id="l41.86"> void</span>
<a href="#l41.87"></a><span id="l41.87"> add_content_type_attribs(const char *content_type,</span>
<a href="#l41.88"></a><span id="l41.88">                          contentTypeHandlerInitStruct  *ctHandlerInfo)</span>
<a href="#l41.89"></a><span id="l41.89"> {</span>
<a href="#l41.90"></a><span id="l41.90">   cthandler_struct    *ptr = NULL;</span>
<a href="#l41.91"></a><span id="l41.91">   bool                force_inline_display;</span>
<a href="#l41.92"></a><span id="l41.92"> </span>
<a href="#l41.93"></a><span id="l41.93">   if (find_content_type_attribs(content_type, &amp;force_inline_display))</span>
<a href="#l41.94"></a><span id="l41.94">     return;</span>
<a href="#l41.95"></a><span id="l41.95"> </span>
<a href="#l41.96"></a><span id="l41.96">   if ( (!content_type) || (!ctHandlerInfo) )</span>
<a href="#l41.97"></a><span id="l41.97">     return;</span>
<a href="#l41.98"></a><span id="l41.98"> </span>
<a href="#l41.99"></a><span id="l41.99">   if (!ctHandlerList)</span>
<a href="#l41.100"></a><span id="l41.100" class="difflineminus">-    ctHandlerList = new nsVoidArray();</span>
<a href="#l41.101"></a><span id="l41.101" class="difflineplus">+    ctHandlerList = new nsTArray&lt;cthandler_struct*&gt;();</span>
<a href="#l41.102"></a><span id="l41.102"> </span>
<a href="#l41.103"></a><span id="l41.103">   if (!ctHandlerList)</span>
<a href="#l41.104"></a><span id="l41.104">     return;</span>
<a href="#l41.105"></a><span id="l41.105"> </span>
<a href="#l41.106"></a><span id="l41.106">   ptr = (cthandler_struct *) PR_MALLOC(sizeof(cthandler_struct));</span>
<a href="#l41.107"></a><span id="l41.107">   if (!ptr)</span>
<a href="#l41.108"></a><span id="l41.108">     return;</span>
<a href="#l41.109"></a><span id="l41.109"> </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

