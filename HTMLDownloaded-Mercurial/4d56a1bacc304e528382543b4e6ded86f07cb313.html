<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 18688:4d56a1bacc304e528382543b4e6ded86f07cb313</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 4d56a1bacc304e528382543b4e6ded86f07cb313" />
<meta property="og:url" content="/comm-central/rev/4d56a1bacc304e528382543b4e6ded86f07cb313" />
<meta property="og:description" content="Bug 824104 - Part 3: Remove for-each from mailnews/. r=jcranmer" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 4d56a1bacc304e528382543b4e6ded86f07cb313 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/4d56a1bacc304e528382543b4e6ded86f07cb313">shortlog</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/4d56a1bacc304e528382543b4e6ded86f07cb313">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313">files</a> |
changeset |
<a href="/comm-central/raw-rev/4d56a1bacc304e528382543b4e6ded86f07cb313">raw</a>  | <a href="/comm-central/archive/4d56a1bacc304e528382543b4e6ded86f07cb313.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=824104">Bug 824104</a> - Part 3: Remove for-each from mailnews/. r=jcranmer
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#84;&#111;&#111;&#114;&#117;&#32;&#70;&#117;&#106;&#105;&#115;&#97;&#119;&#97;&#32;&#60;&#97;&#114;&#97;&#105;&#95;&#97;&#64;&#109;&#97;&#99;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Sat, 05 Dec 2015 14:27:43 +0900</td></tr>

<tr>
 <td>changeset 18688</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/4d56a1bacc304e528382543b4e6ded86f07cb313">4d56a1bacc304e528382543b4e6ded86f07cb313</a></td>
</tr>



<tr>
<td>parent 18687</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/9692c8c255faf011c9a878e3b1c9a401d5ba55da">9692c8c255faf011c9a878e3b1c9a401d5ba55da</a>
</td>
</tr>

<tr>
<td>child 18689</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/fbbb6917b2cdf1db323334709c7646abddda778e">fbbb6917b2cdf1db323334709c7646abddda778e</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=4d56a1bacc304e528382543b4e6ded86f07cb313">11448</a></td></tr>
<tr><td>push user</td><td>arai_a@mac.com</td></tr>
<tr><td>push date</td><td class="date age">Sat, 05 Dec 2015 05:32:05 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@4d56a1bacc30 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=4d56a1bacc304e528382543b4e6ded86f07cb313">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=4d56a1bacc304e528382543b4e6ded86f07cb313&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4d56a1bacc304e528382543b4e6ded86f07cb313&newProject=comm-central&newRevision=6d3320934b32ca12c389756c61732256810f18d7&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4d56a1bacc304e528382543b4e6ded86f07cb313&newProject=comm-central&newRevision=6d3320934b32ca12c389756c61732256810f18d7&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4d56a1bacc304e528382543b4e6ded86f07cb313&newProject=comm-central&newRevision=6d3320934b32ca12c389756c61732256810f18d7&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28jcranmer%29&revcount=50">jcranmer</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=824104">824104</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=824104">Bug 824104</a> - Part 3: Remove for-each from mailnews/. r=jcranmer</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/src/nsAbLDAPAttributeMap.js">mailnews/addrbook/src/nsAbLDAPAttributeMap.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/src/nsAbLDAPAttributeMap.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/src/nsAbLDAPAttributeMap.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/src/nsAbLDAPAttributeMap.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/src/nsAbLDAPAttributeMap.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/src/nsAbLDAPAttributeMap.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/test/unit/test_uuid.js">mailnews/addrbook/test/unit/test_uuid.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/test/unit/test_uuid.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/test/unit/test_uuid.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/test/unit/test_uuid.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/test/unit/test_uuid.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/addrbook/test/unit/test_uuid.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/content/folderWidgets.xml">mailnews/base/content/folderWidgets.xml</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/content/folderWidgets.xml">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/content/folderWidgets.xml">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/content/folderWidgets.xml">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/content/folderWidgets.xml">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/content/folderWidgets.xml">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/search/content/searchWidgets.xml">mailnews/base/search/content/searchWidgets.xml</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/search/content/searchWidgets.xml">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/search/content/searchWidgets.xml">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/search/content/searchWidgets.xml">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/search/content/searchWidgets.xml">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/search/content/searchWidgets.xml">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/msgAsyncPrompter.js">mailnews/base/src/msgAsyncPrompter.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/msgAsyncPrompter.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/msgAsyncPrompter.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/msgAsyncPrompter.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/msgAsyncPrompter.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/msgAsyncPrompter.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/virtualFolderWrapper.js">mailnews/base/src/virtualFolderWrapper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/virtualFolderWrapper.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/virtualFolderWrapper.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/virtualFolderWrapper.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/virtualFolderWrapper.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/src/virtualFolderWrapper.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_gmail.js">mailnews/base/test/unit/test_testsuite_fakeserver_imapd_gmail.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_gmail.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_gmail.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_gmail.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_gmail.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_gmail.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_list-extended.js">mailnews/base/test/unit/test_testsuite_fakeserver_imapd_list-extended.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_list-extended.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_list-extended.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_list-extended.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_list-extended.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_list-extended.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/StringBundle.js">mailnews/base/util/StringBundle.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/StringBundle.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/StringBundle.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/StringBundle.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/StringBundle.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/StringBundle.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/jsTreeSelection.js">mailnews/base/util/jsTreeSelection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/jsTreeSelection.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/jsTreeSelection.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/jsTreeSelection.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/jsTreeSelection.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/jsTreeSelection.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/traceHelper.js">mailnews/base/util/traceHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/traceHelper.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/traceHelper.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/traceHelper.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/traceHelper.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/base/util/traceHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/components/glautocomp.js">mailnews/db/gloda/components/glautocomp.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/components/glautocomp.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/components/glautocomp.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/components/glautocomp.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/components/glautocomp.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/components/glautocomp.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/content/glodacomplete.xml">mailnews/db/gloda/content/glodacomplete.xml</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/content/glodacomplete.xml">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/content/glodacomplete.xml">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/content/glodacomplete.xml">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/content/glodacomplete.xml">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/content/glodacomplete.xml">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/collection.js">mailnews/db/gloda/modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/collection.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/collection.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/connotent.js">mailnews/db/gloda/modules/connotent.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/connotent.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/connotent.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/connotent.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/connotent.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/connotent.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/databind.js">mailnews/db/gloda/modules/databind.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/databind.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/databind.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/databind.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/databind.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/databind.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datamodel.js">mailnews/db/gloda/modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datastore.js">mailnews/db/gloda/modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/dbview.js">mailnews/db/gloda/modules/dbview.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/dbview.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/dbview.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/dbview.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/dbview.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/dbview.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/facet.js">mailnews/db/gloda/modules/facet.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/facet.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/facet.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/facet.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/facet.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/facet.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/fundattr.js">mailnews/db/gloda/modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/gloda.js">mailnews/db/gloda/modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_ab.js">mailnews/db/gloda/modules/index_ab.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_ab.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_ab.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_ab.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_ab.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_ab.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_msg.js">mailnews/db/gloda/modules/index_msg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_msg.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_msg.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_msg.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_msg.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/index_msg.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/indexer.js">mailnews/db/gloda/modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/log4moz.js">mailnews/db/gloda/modules/log4moz.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/log4moz.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/log4moz.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/log4moz.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/log4moz.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/log4moz.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/mimemsg.js">mailnews/db/gloda/modules/mimemsg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/mimemsg.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/mimemsg.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/mimemsg.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/mimemsg.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/mimemsg.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/msg_search.js">mailnews/db/gloda/modules/msg_search.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/msg_search.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/msg_search.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/msg_search.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/msg_search.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/msg_search.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_freetag.js">mailnews/db/gloda/modules/noun_freetag.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_freetag.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_freetag.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_freetag.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_freetag.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_freetag.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_mimetype.js">mailnews/db/gloda/modules/noun_mimetype.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_mimetype.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_mimetype.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_mimetype.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_mimetype.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/noun_mimetype.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/query.js">mailnews/db/gloda/modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/query.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/query.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/query.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/query.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/query.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/suffixtree.js">mailnews/db/gloda/modules/suffixtree.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/suffixtree.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/suffixtree.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/suffixtree.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/suffixtree.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/modules/suffixtree.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_gloda_content.js">mailnews/db/gloda/test/unit/base_gloda_content.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_gloda_content.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_gloda_content.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_gloda_content.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_gloda_content.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_gloda_content.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_index_messages.js">mailnews/db/gloda/test/unit/base_index_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_index_messages.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_index_messages.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_index_messages.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_index_messages.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_index_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_query_messages.js">mailnews/db/gloda/test/unit/base_query_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_query_messages.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_query_messages.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_query_messages.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_query_messages.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/base_query_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_fts3_tokenizer.js">mailnews/db/gloda/test/unit/test_fts3_tokenizer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_fts3_tokenizer.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_fts3_tokenizer.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_fts3_tokenizer.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_fts3_tokenizer.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_fts3_tokenizer.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_compaction.js">mailnews/db/gloda/test/unit/test_index_compaction.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_compaction.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_compaction.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_compaction.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_compaction.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_compaction.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">mailnews/db/gloda/test/unit/test_index_sweep_folder.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_intl.js">mailnews/db/gloda/test/unit/test_intl.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_intl.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_intl.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_intl.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_intl.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_intl.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_migration.js">mailnews/db/gloda/test/unit/test_migration.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_migration.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_migration.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_migration.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_migration.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_migration.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_attachments_size.js">mailnews/db/gloda/test/unit/test_mime_attachments_size.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_attachments_size.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_attachments_size.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_attachments_size.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_attachments_size.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_attachments_size.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_emitter.js">mailnews/db/gloda/test/unit/test_mime_emitter.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_emitter.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_emitter.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_emitter.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_emitter.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_mime_emitter.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_query_core.js">mailnews/db/gloda/test/unit/test_query_core.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_query_core.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_query_core.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_query_core.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_query_core.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/db/gloda/test/unit/test_query_core.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/extensions/bayesian-spam-filter/test/unit/test_customTokenization.js">mailnews/extensions/bayesian-spam-filter/test/unit/test_customTokenization.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/extensions/bayesian-spam-filter/test/unit/test_customTokenization.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/extensions/bayesian-spam-filter/test/unit/test_customTokenization.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/extensions/bayesian-spam-filter/test/unit/test_customTokenization.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/extensions/bayesian-spam-filter/test/unit/test_customTokenization.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/extensions/bayesian-spam-filter/test/unit/test_customTokenization.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/head_server.js">mailnews/imap/test/unit/head_server.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/head_server.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/head_server.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/head_server.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/head_server.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/head_server.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_listSubscribed.js">mailnews/imap/test/unit/test_listSubscribed.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_listSubscribed.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_listSubscribed.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_listSubscribed.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_listSubscribed.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_listSubscribed.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_lsub.js">mailnews/imap/test/unit/test_lsub.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_lsub.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_lsub.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_lsub.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_lsub.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_lsub.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/local/test/unit/test_pop3DownloadTempFileHandling.js">mailnews/local/test/unit/test_pop3DownloadTempFileHandling.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/local/test/unit/test_pop3DownloadTempFileHandling.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/local/test/unit/test_pop3DownloadTempFileHandling.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/local/test/unit/test_pop3DownloadTempFileHandling.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/local/test/unit/test_pop3DownloadTempFileHandling.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/local/test/unit/test_pop3DownloadTempFileHandling.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_hidden_attachments.js">mailnews/mime/test/unit/test_hidden_attachments.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_hidden_attachments.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_hidden_attachments.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_hidden_attachments.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_hidden_attachments.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_hidden_attachments.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_mimeStreaming.js">mailnews/mime/test/unit/test_mimeStreaming.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_mimeStreaming.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_mimeStreaming.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_mimeStreaming.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_mimeStreaming.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/mime/test/unit/test_mimeStreaming.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/head_server_setup.js">mailnews/news/test/unit/head_server_setup.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/head_server_setup.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/head_server_setup.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/head_server_setup.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/head_server_setup.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/head_server_setup.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/test_uriParser.js">mailnews/news/test/unit/test_uriParser.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/test_uriParser.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/test_uriParser.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/test_uriParser.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/test_uriParser.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/news/test/unit/test_uriParser.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/fakeserver/imapd.js">mailnews/test/fakeserver/imapd.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/fakeserver/imapd.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/fakeserver/imapd.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/fakeserver/imapd.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/fakeserver/imapd.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/fakeserver/imapd.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/IMAPpump.js">mailnews/test/resources/IMAPpump.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/IMAPpump.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/IMAPpump.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/IMAPpump.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/IMAPpump.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/IMAPpump.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/MockFactory.js">mailnews/test/resources/MockFactory.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/MockFactory.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/MockFactory.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/MockFactory.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/MockFactory.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/MockFactory.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/asyncTestUtils.js">mailnews/test/resources/asyncTestUtils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/asyncTestUtils.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/asyncTestUtils.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/asyncTestUtils.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/asyncTestUtils.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/asyncTestUtils.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/logHelper.js">mailnews/test/resources/logHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/logHelper.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/logHelper.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/logHelper.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/logHelper.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/logHelper.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageGenerator.js">mailnews/test/resources/messageGenerator.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageGenerator.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageGenerator.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageGenerator.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageGenerator.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageGenerator.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageInjection.js">mailnews/test/resources/messageInjection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageInjection.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageInjection.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageInjection.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageInjection.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageInjection.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageModifier.js">mailnews/test/resources/messageModifier.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageModifier.js">file</a> |
<a href="/comm-central/annotate/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageModifier.js">annotate</a> |
<a href="/comm-central/diff/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageModifier.js">diff</a> |
<a href="/comm-central/comparison/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageModifier.js">comparison</a> |
<a href="/comm-central/log/4d56a1bacc304e528382543b4e6ded86f07cb313/mailnews/test/resources/messageModifier.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/addrbook/src/nsAbLDAPAttributeMap.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/addrbook/src/nsAbLDAPAttributeMap.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -53,32 +53,32 @@ nsAbLDAPAttributeMap.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">   setAttributeList: function setAttributeList(aProperty, aAttributeList,</span>
<a href="#l1.5"></a><span id="l1.5">                                               aAllowInconsistencies) {</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7">     var attrs = aAttributeList.split(&quot;,&quot;);</span>
<a href="#l1.8"></a><span id="l1.8"> </span>
<a href="#l1.9"></a><span id="l1.9">     // check to make sure this call won't allow multiple mappings to be</span>
<a href="#l1.10"></a><span id="l1.10">     // created, if requested</span>
<a href="#l1.11"></a><span id="l1.11">     if (!aAllowInconsistencies) {</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-      for each (var attr in attrs) {</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+      for (var attr of attrs) {</span>
<a href="#l1.14"></a><span id="l1.14">         if (attr in this.mAttrMap &amp;&amp; this.mAttrMap[attr] != aProperty) {</span>
<a href="#l1.15"></a><span id="l1.15">           throw Components.results.NS_ERROR_FAILURE;</span>
<a href="#l1.16"></a><span id="l1.16">         }</span>
<a href="#l1.17"></a><span id="l1.17">       }</span>
<a href="#l1.18"></a><span id="l1.18">     }</span>
<a href="#l1.19"></a><span id="l1.19"> </span>
<a href="#l1.20"></a><span id="l1.20">     // delete any attr mappings created by the existing property map entry</span>
<a href="#l1.21"></a><span id="l1.21">     if (aProperty in this.mPropertyMap) {</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineminus">-      for each (attr in this.mPropertyMap[aProperty]) {</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+      for (attr of this.mPropertyMap[aProperty]) {</span>
<a href="#l1.24"></a><span id="l1.24">         delete this.mAttrMap[attr];</span>
<a href="#l1.25"></a><span id="l1.25">       }</span>
<a href="#l1.26"></a><span id="l1.26">     }</span>
<a href="#l1.27"></a><span id="l1.27"> </span>
<a href="#l1.28"></a><span id="l1.28">     // add these attrs to the attrmap</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineminus">-    for each (attr in attrs) {</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+    for (attr of attrs) {</span>
<a href="#l1.31"></a><span id="l1.31">       this.mAttrMap[attr] = aProperty;</span>
<a href="#l1.32"></a><span id="l1.32">     }</span>
<a href="#l1.33"></a><span id="l1.33"> </span>
<a href="#l1.34"></a><span id="l1.34">     // add them to the property map</span>
<a href="#l1.35"></a><span id="l1.35">     this.mPropertyMap[aProperty] = attrs;</span>
<a href="#l1.36"></a><span id="l1.36">   },</span>
<a href="#l1.37"></a><span id="l1.37"> </span>
<a href="#l1.38"></a><span id="l1.38">   getProperty: function getProperty(aAttribute) {</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineat">@@ -87,17 +87,18 @@ nsAbLDAPAttributeMap.prototype = {</span>
<a href="#l1.40"></a><span id="l1.40">       return null;</span>
<a href="#l1.41"></a><span id="l1.41">     }</span>
<a href="#l1.42"></a><span id="l1.42"> </span>
<a href="#l1.43"></a><span id="l1.43">     return this.mAttrMap[aAttribute];</span>
<a href="#l1.44"></a><span id="l1.44">   },</span>
<a href="#l1.45"></a><span id="l1.45"> </span>
<a href="#l1.46"></a><span id="l1.46">   getAllCardAttributes: function getAllCardAttributes() {</span>
<a href="#l1.47"></a><span id="l1.47">     var attrs = [];</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineminus">-    for each (var attrArray in this.mPropertyMap) {</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+    for (var prop in this.mPropertyMap) {</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+      let attrArray = this.mPropertyMap[prop];</span>
<a href="#l1.51"></a><span id="l1.51">       attrs = attrs.concat(attrArray);</span>
<a href="#l1.52"></a><span id="l1.52">     }</span>
<a href="#l1.53"></a><span id="l1.53"> </span>
<a href="#l1.54"></a><span id="l1.54">     if (!attrs.length) {</span>
<a href="#l1.55"></a><span id="l1.55">       throw Components.results.NS_ERROR_FAILURE;</span>
<a href="#l1.56"></a><span id="l1.56">     }</span>
<a href="#l1.57"></a><span id="l1.57"> </span>
<a href="#l1.58"></a><span id="l1.58">     return attrs.join(&quot;,&quot;);</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineat">@@ -118,17 +119,17 @@ nsAbLDAPAttributeMap.prototype = {</span>
<a href="#l1.60"></a><span id="l1.60">     // get the right pref branch</span>
<a href="#l1.61"></a><span id="l1.61">     let branch = Services.prefs.getBranch(aPrefBranchName + &quot;.&quot;);</span>
<a href="#l1.62"></a><span id="l1.62"> </span>
<a href="#l1.63"></a><span id="l1.63">     // get the list of children</span>
<a href="#l1.64"></a><span id="l1.64">     var childCount = {};</span>
<a href="#l1.65"></a><span id="l1.65">     var children = branch.getChildList(&quot;&quot;, childCount);</span>
<a href="#l1.66"></a><span id="l1.66"> </span>
<a href="#l1.67"></a><span id="l1.67">     // do the actual sets</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineminus">-    for each (var child in children) {</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+    for (var child of children) {</span>
<a href="#l1.70"></a><span id="l1.70">       this.setAttributeList(child, branch.getCharPref(child), true);</span>
<a href="#l1.71"></a><span id="l1.71">     }</span>
<a href="#l1.72"></a><span id="l1.72"> </span>
<a href="#l1.73"></a><span id="l1.73">     // ensure that everything is kosher</span>
<a href="#l1.74"></a><span id="l1.74">     this.checkState();</span>
<a href="#l1.75"></a><span id="l1.75">   },</span>
<a href="#l1.76"></a><span id="l1.76"> </span>
<a href="#l1.77"></a><span id="l1.77">   setCardPropertiesFromLDAPMessage: function</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineat">@@ -142,17 +143,17 @@ nsAbLDAPAttributeMap.prototype = {</span>
<a href="#l1.79"></a><span id="l1.79">     // downcase the array for comparison</span>
<a href="#l1.80"></a><span id="l1.80">     function toLower(a) { return a.toLowerCase(); }</span>
<a href="#l1.81"></a><span id="l1.81">     msgAttrs = msgAttrs.map(toLower);</span>
<a href="#l1.82"></a><span id="l1.82"> </span>
<a href="#l1.83"></a><span id="l1.83">     // deal with each addressbook property</span>
<a href="#l1.84"></a><span id="l1.84">     for (var prop in this.mPropertyMap) {</span>
<a href="#l1.85"></a><span id="l1.85"> </span>
<a href="#l1.86"></a><span id="l1.86">       // go through the list of possible attrs in precedence order</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineminus">-      for each (var attr in this.mPropertyMap[prop]) {</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineplus">+      for (var attr of this.mPropertyMap[prop]) {</span>
<a href="#l1.89"></a><span id="l1.89"> </span>
<a href="#l1.90"></a><span id="l1.90">         attr = attr.toLowerCase();</span>
<a href="#l1.91"></a><span id="l1.91"> </span>
<a href="#l1.92"></a><span id="l1.92">         // find the first attr that exists in this message</span>
<a href="#l1.93"></a><span id="l1.93">         if (msgAttrs.indexOf(attr) != -1) {</span>
<a href="#l1.94"></a><span id="l1.94"> </span>
<a href="#l1.95"></a><span id="l1.95">           try {</span>
<a href="#l1.96"></a><span id="l1.96">             var values = aMessage.getValues(attr, {});</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineat">@@ -179,19 +180,19 @@ nsAbLDAPAttributeMap.prototype = {</span>
<a href="#l1.98"></a><span id="l1.98"> </span>
<a href="#l1.99"></a><span id="l1.99">     return;</span>
<a href="#l1.100"></a><span id="l1.100">   },</span>
<a href="#l1.101"></a><span id="l1.101"> </span>
<a href="#l1.102"></a><span id="l1.102">   checkState: function checkState() {</span>
<a href="#l1.103"></a><span id="l1.103"> </span>
<a href="#l1.104"></a><span id="l1.104">     var attrsSeen = [];</span>
<a href="#l1.105"></a><span id="l1.105"> </span>
<a href="#l1.106"></a><span id="l1.106" class="difflineminus">-    for each (var attrArray in this.mPropertyMap) {</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineminus">-</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineminus">-      for each (var attr in attrArray) {</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+    for (var prop in this.mPropertyMap) {</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+      let attrArray = this.mPropertyMap[prop];</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+      for (var attr of attrArray) {</span>
<a href="#l1.112"></a><span id="l1.112"> </span>
<a href="#l1.113"></a><span id="l1.113">         // multiple attributes that mapped to the empty string are permitted</span>
<a href="#l1.114"></a><span id="l1.114">         if (!attr.length) {</span>
<a href="#l1.115"></a><span id="l1.115">           continue;</span>
<a href="#l1.116"></a><span id="l1.116">         }</span>
<a href="#l1.117"></a><span id="l1.117"> </span>
<a href="#l1.118"></a><span id="l1.118">         // if we've seen this before, there's a problem</span>
<a href="#l1.119"></a><span id="l1.119">         if (attrsSeen.indexOf(attr) != -1) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/addrbook/test/unit/test_uuid.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/addrbook/test/unit/test_uuid.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -78,17 +78,17 @@ function check_directory(directory) {</span>
<a href="#l2.4"></a><span id="l2.4"> </span>
<a href="#l2.5"></a><span id="l2.5">   // Remove the new card to be stable!</span>
<a href="#l2.6"></a><span id="l2.6">   var array = Cc[&quot;@mozilla.org/array;1&quot;].createInstance(Ci.nsIMutableArray);</span>
<a href="#l2.7"></a><span id="l2.7">   array.appendElement(newCard, false);</span>
<a href="#l2.8"></a><span id="l2.8">   directory.deleteCards(array);</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10">   // We need to iterate over the array of cards to avoid any problems if someone</span>
<a href="#l2.11"></a><span id="l2.11">   // makes the childCards enumerator reflect changes to directory...</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  for each (var card in cards) {</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  for (var card of cards) {</span>
<a href="#l2.14"></a><span id="l2.14">     // Question 5.1: Does deleting a card properly set the uids?</span>
<a href="#l2.15"></a><span id="l2.15">     var localId = card.localId;</span>
<a href="#l2.16"></a><span id="l2.16">     array.clear();</span>
<a href="#l2.17"></a><span id="l2.17">     array.appendElement(card, false);</span>
<a href="#l2.18"></a><span id="l2.18">     directory.deleteCards(array);</span>
<a href="#l2.19"></a><span id="l2.19">     do_check_eq(card.directoryId, &quot;&quot;);</span>
<a href="#l2.20"></a><span id="l2.20">     do_check_eq(card.localId, localId);</span>
<a href="#l2.21"></a><span id="l2.21"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/base/content/folderWidgets.xml</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/base/content/folderWidgets.xml</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -658,17 +658,17 @@</span>
<a href="#l3.4"></a><span id="l3.4">         &lt;parameter name=&quot;aMenuNode&quot;/&gt;</span>
<a href="#l3.5"></a><span id="l3.5">         &lt;body&gt;&lt;![CDATA[</span>
<a href="#l3.6"></a><span id="l3.6"> </span>
<a href="#l3.7"></a><span id="l3.7">           // First set the SpecialFolder attribute</span>
<a href="#l3.8"></a><span id="l3.8">           aMenuNode.setAttribute(&quot;SpecialFolder&quot;, this.getSpecialFolderString(aFolder));</span>
<a href="#l3.9"></a><span id="l3.9"> </span>
<a href="#l3.10"></a><span id="l3.10">           // Now set the biffState</span>
<a href="#l3.11"></a><span id="l3.11">           let biffStates = [&quot;NewMail&quot;, &quot;NoMail&quot;, &quot;UnknownMail&quot;];</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-          for each (let state in biffStates) {</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+          for (let state of biffStates) {</span>
<a href="#l3.14"></a><span id="l3.14">             if (aFolder.biffState ==</span>
<a href="#l3.15"></a><span id="l3.15">                 Components.interfaces.nsIMsgFolder[&quot;nsMsgBiffState_&quot; + state]) {</span>
<a href="#l3.16"></a><span id="l3.16">               aMenuNode.setAttribute(&quot;BiffState&quot;, state);</span>
<a href="#l3.17"></a><span id="l3.17">               break;</span>
<a href="#l3.18"></a><span id="l3.18">             }</span>
<a href="#l3.19"></a><span id="l3.19">           }</span>
<a href="#l3.20"></a><span id="l3.20"> </span>
<a href="#l3.21"></a><span id="l3.21">           aMenuNode.setAttribute(&quot;IsServer&quot;, aFolder.isServer);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/base/search/content/searchWidgets.xml</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/base/search/content/searchWidgets.xml</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -227,17 +227,17 @@</span>
<a href="#l4.4"></a><span id="l4.4">                               Components.interfaces.nsIMsgIdentity))];</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6">             if (!identities.length) // typically if this is Local Folders</span>
<a href="#l4.7"></a><span id="l4.7">               identities.push(MailServices.accounts.defaultAccount.defaultIdentity);</span>
<a href="#l4.8"></a><span id="l4.8"> </span>
<a href="#l4.9"></a><span id="l4.9">             let templateFound = false;</span>
<a href="#l4.10"></a><span id="l4.10">             let foldersScanned = [];</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-            for each (let identity in identities) {</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+            for (let identity of identities) {</span>
<a href="#l4.14"></a><span id="l4.14">               let enumerator = null;</span>
<a href="#l4.15"></a><span id="l4.15">               let msgFolder;</span>
<a href="#l4.16"></a><span id="l4.16">               try {</span>
<a href="#l4.17"></a><span id="l4.17">                 msgFolder = Components.classes[&quot;@mozilla.org/rdf/rdf-service;1&quot;]</span>
<a href="#l4.18"></a><span id="l4.18">                                       .getService(Components.interfaces.nsIRDFService)</span>
<a href="#l4.19"></a><span id="l4.19">                                       .GetResource(identity.stationeryFolder)</span>
<a href="#l4.20"></a><span id="l4.20">                                       .QueryInterface(Components.interfaces.nsIMsgFolder);</span>
<a href="#l4.21"></a><span id="l4.21">                 // If we already processed this folder, do not set enumerator</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/base/src/msgAsyncPrompter.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/base/src/msgAsyncPrompter.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -28,17 +28,17 @@ runnablePrompter.prototype = {</span>
<a href="#l5.4"></a><span id="l5.4">       ok = prompter.first.onPromptStart();</span>
<a href="#l5.5"></a><span id="l5.5">     }</span>
<a href="#l5.6"></a><span id="l5.6">     catch (ex) {</span>
<a href="#l5.7"></a><span id="l5.7">       Components.utils.reportError(&quot;runnablePrompter:run: &quot; + ex + &quot;\n&quot;);</span>
<a href="#l5.8"></a><span id="l5.8">     }</span>
<a href="#l5.9"></a><span id="l5.9"> </span>
<a href="#l5.10"></a><span id="l5.10">     delete this._asyncPrompter._pendingPrompts[this._hashKey];</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-    for each (var consumer in prompter.consumers) {</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+    for (var consumer of prompter.consumers) {</span>
<a href="#l5.14"></a><span id="l5.14">       try {</span>
<a href="#l5.15"></a><span id="l5.15">         if (ok)</span>
<a href="#l5.16"></a><span id="l5.16">           consumer.onPromptAuthAvailable();</span>
<a href="#l5.17"></a><span id="l5.17">         else</span>
<a href="#l5.18"></a><span id="l5.18">           consumer.onPromptCanceled();</span>
<a href="#l5.19"></a><span id="l5.19">       }</span>
<a href="#l5.20"></a><span id="l5.20">       catch (ex) {</span>
<a href="#l5.21"></a><span id="l5.21">         // Log the error for extension devs and others to pick up.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/base/src/virtualFolderWrapper.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/base/src/virtualFolderWrapper.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -117,17 +117,17 @@ VirtualFolderWrapper.prototype = {</span>
<a href="#l6.4"></a><span id="l6.4">    *     search over.</span>
<a href="#l6.5"></a><span id="l6.5">    */</span>
<a href="#l6.6"></a><span id="l6.6">   get searchFolders() {</span>
<a href="#l6.7"></a><span id="l6.7">     let rdfService = Cc['@mozilla.org/rdf/rdf-service;1']</span>
<a href="#l6.8"></a><span id="l6.8">                        .getService(Ci.nsIRDFService);</span>
<a href="#l6.9"></a><span id="l6.9">     let virtualFolderUris =</span>
<a href="#l6.10"></a><span id="l6.10">       this.dbFolderInfo.getCharProperty(&quot;searchFolderUri&quot;).split(&quot;|&quot;);</span>
<a href="#l6.11"></a><span id="l6.11">     let folders = [];</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-    for each (let [, folderURI] in Iterator(virtualFolderUris)) {</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+    for (let folderURI of virtualFolderUris) {</span>
<a href="#l6.14"></a><span id="l6.14">       if (folderURI)</span>
<a href="#l6.15"></a><span id="l6.15">         folders.push(rdfService.GetResource(folderURI)</span>
<a href="#l6.16"></a><span id="l6.16">                                .QueryInterface(Ci.nsIMsgFolder));</span>
<a href="#l6.17"></a><span id="l6.17">     }</span>
<a href="#l6.18"></a><span id="l6.18">     return folders;</span>
<a href="#l6.19"></a><span id="l6.19">   },</span>
<a href="#l6.20"></a><span id="l6.20">   /**</span>
<a href="#l6.21"></a><span id="l6.21">    * Set the search folders that back this virtual folder.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_gmail.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_gmail.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -81,13 +81,13 @@ function run_test()</span>
<a href="#l7.4"></a><span id="l7.4"> }</span>
<a href="#l7.5"></a><span id="l7.5"> </span>
<a href="#l7.6"></a><span id="l7.6"> /*</span>
<a href="#l7.7"></a><span id="l7.7">  * helper functions</span>
<a href="#l7.8"></a><span id="l7.8">  */</span>
<a href="#l7.9"></a><span id="l7.9"> </span>
<a href="#l7.10"></a><span id="l7.10"> function recursiveDeleteMailboxes(aMailbox)</span>
<a href="#l7.11"></a><span id="l7.11"> {</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-  for each (var child in aMailbox.allChildren) {</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+  for (var child of aMailbox.allChildren) {</span>
<a href="#l7.14"></a><span id="l7.14">     recursiveDeleteMailboxes(child);</span>
<a href="#l7.15"></a><span id="l7.15">   }</span>
<a href="#l7.16"></a><span id="l7.16">   IMAPPump.daemon.deleteMailbox(aMailbox);</span>
<a href="#l7.17"></a><span id="l7.17"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_list-extended.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/base/test/unit/test_testsuite_fakeserver_imapd_list-extended.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -160,13 +160,13 @@ function run_test()</span>
<a href="#l8.4"></a><span id="l8.4"> }</span>
<a href="#l8.5"></a><span id="l8.5"> </span>
<a href="#l8.6"></a><span id="l8.6"> /*</span>
<a href="#l8.7"></a><span id="l8.7">  * helper functions</span>
<a href="#l8.8"></a><span id="l8.8">  */</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10"> function recursiveDeleteMailboxes(aMailbox)</span>
<a href="#l8.11"></a><span id="l8.11"> {</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  for each (var child in aMailbox.allChildren) {</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+  for (var child of aMailbox.allChildren) {</span>
<a href="#l8.14"></a><span id="l8.14">     recursiveDeleteMailboxes(child);</span>
<a href="#l8.15"></a><span id="l8.15">   }</span>
<a href="#l8.16"></a><span id="l8.16">   IMAPPump.daemon.deleteMailbox(aMailbox);</span>
<a href="#l8.17"></a><span id="l8.17"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/base/util/StringBundle.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/base/util/StringBundle.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -19,17 +19,17 @@ Components.utils.import(&quot;resource://gre/</span>
<a href="#l9.4"></a><span id="l9.4">  * To use this module, import it, create a new instance of StringBundle,</span>
<a href="#l9.5"></a><span id="l9.5">  * and then use the instance's |get| and |getAll| methods to retrieve strings</span>
<a href="#l9.6"></a><span id="l9.6">  * (you can get both plain and formatted strings with |get|):</span>
<a href="#l9.7"></a><span id="l9.7">  *</span>
<a href="#l9.8"></a><span id="l9.8">  *   let strings =</span>
<a href="#l9.9"></a><span id="l9.9">  *     new StringBundle(&quot;chrome://example/locale/strings.properties&quot;);</span>
<a href="#l9.10"></a><span id="l9.10">  *   let foo = strings.get(&quot;foo&quot;);</span>
<a href="#l9.11"></a><span id="l9.11">  *   let barFormatted = strings.get(&quot;bar&quot;, [arg1, arg2]);</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">- *   for each (let string in strings.getAll())</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+ *   for (let string of strings.getAll())</span>
<a href="#l9.14"></a><span id="l9.14">  *     dump (string.key + &quot; = &quot; + string.value + &quot;\n&quot;);</span>
<a href="#l9.15"></a><span id="l9.15">  *</span>
<a href="#l9.16"></a><span id="l9.16">  * @param url {String}</span>
<a href="#l9.17"></a><span id="l9.17">  *        the URL of the string bundle</span>
<a href="#l9.18"></a><span id="l9.18">  */</span>
<a href="#l9.19"></a><span id="l9.19"> function StringBundle(url) {</span>
<a href="#l9.20"></a><span id="l9.20">   this.url = url;</span>
<a href="#l9.21"></a><span id="l9.21"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/base/util/jsTreeSelection.js</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/base/util/jsTreeSelection.js</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -107,27 +107,27 @@ JSTreeSelection.prototype = {</span>
<a href="#l10.4"></a><span id="l10.4">    * @return false because we don't support single-selection.</span>
<a href="#l10.5"></a><span id="l10.5">    */</span>
<a href="#l10.6"></a><span id="l10.6">   get single() {</span>
<a href="#l10.7"></a><span id="l10.7">     return false;</span>
<a href="#l10.8"></a><span id="l10.8">   },</span>
<a href="#l10.9"></a><span id="l10.9"> </span>
<a href="#l10.10"></a><span id="l10.10">   _updateCount: function JSTreeSelection__updateCount() {</span>
<a href="#l10.11"></a><span id="l10.11">     this._count = 0;</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-    for each (let [, [low, high]] in Iterator(this._ranges)) {</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+    for (let [low, high] of this._ranges) {</span>
<a href="#l10.14"></a><span id="l10.14">       this._count += high - low + 1;</span>
<a href="#l10.15"></a><span id="l10.15">     }</span>
<a href="#l10.16"></a><span id="l10.16">   },</span>
<a href="#l10.17"></a><span id="l10.17"> </span>
<a href="#l10.18"></a><span id="l10.18">   get count() {</span>
<a href="#l10.19"></a><span id="l10.19">     return this._count;</span>
<a href="#l10.20"></a><span id="l10.20">   },</span>
<a href="#l10.21"></a><span id="l10.21"> </span>
<a href="#l10.22"></a><span id="l10.22">   isSelected: function JSTreeSelection_isSelected(aViewIndex) {</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineminus">-    for each (let [,[low, high]] in Iterator(this._ranges)) {</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+    for (let [low, high] of this._ranges) {</span>
<a href="#l10.25"></a><span id="l10.25">       if (aViewIndex &gt;= low &amp;&amp; aViewIndex &lt;= high)</span>
<a href="#l10.26"></a><span id="l10.26">         return true;</span>
<a href="#l10.27"></a><span id="l10.27">     }</span>
<a href="#l10.28"></a><span id="l10.28">     return false;</span>
<a href="#l10.29"></a><span id="l10.29">   },</span>
<a href="#l10.30"></a><span id="l10.30"> </span>
<a href="#l10.31"></a><span id="l10.31">   /**</span>
<a href="#l10.32"></a><span id="l10.32">    * Select the given row.  It does nothing if that row was already selected.</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineat">@@ -155,17 +155,17 @@ JSTreeSelection.prototype = {</span>
<a href="#l10.34"></a><span id="l10.34"> </span>
<a href="#l10.35"></a><span id="l10.35">   toggleSelect: function JSTreeSelection_toggleSelect(aIndex) {</span>
<a href="#l10.36"></a><span id="l10.36">     this.currentIndex = aIndex;</span>
<a href="#l10.37"></a><span id="l10.37">     // If nothing's selected, select aIndex</span>
<a href="#l10.38"></a><span id="l10.38">     if (this._count == 0) {</span>
<a href="#l10.39"></a><span id="l10.39">       this._count = 1;</span>
<a href="#l10.40"></a><span id="l10.40">       this._ranges = [[aIndex, aIndex]];</span>
<a href="#l10.41"></a><span id="l10.41">     }</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineminus">-    else for each (let [iTupe, [low, high]] in Iterator(this._ranges)) {</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+    else for (let [iTupe, [low, high]] of this._ranges.entries()) {</span>
<a href="#l10.44"></a><span id="l10.44">       // below the range? add it to the existing range or create a new one</span>
<a href="#l10.45"></a><span id="l10.45">       if (aIndex &lt; low) {</span>
<a href="#l10.46"></a><span id="l10.46">         this._count++;</span>
<a href="#l10.47"></a><span id="l10.47">         // is it just below an existing range? (range fusion only happens in the</span>
<a href="#l10.48"></a><span id="l10.48">         //  high case, not here.)</span>
<a href="#l10.49"></a><span id="l10.49">         if (aIndex == low - 1) {</span>
<a href="#l10.50"></a><span id="l10.50">           this._ranges[iTupe][0] = aIndex;</span>
<a href="#l10.51"></a><span id="l10.51">           break;</span>
<a href="#l10.52"></a><span id="l10.52" class="difflineat">@@ -256,17 +256,17 @@ JSTreeSelection.prototype = {</span>
<a href="#l10.53"></a><span id="l10.53">     // Iterate over our existing set of ranges, finding the 'range' of ranges</span>
<a href="#l10.54"></a><span id="l10.54">     //  that our new range overlaps or simply obviates.</span>
<a href="#l10.55"></a><span id="l10.55">     // Overlap variables track blocks we need to keep some part of, Nuke</span>
<a href="#l10.56"></a><span id="l10.56">     //  variables are for blocks that get spliced out.  For our purposes, all</span>
<a href="#l10.57"></a><span id="l10.57">     //  overlap blocks are also nuke blocks.</span>
<a href="#l10.58"></a><span id="l10.58">     let lowOverlap, lowNuke, highNuke, highOverlap;</span>
<a href="#l10.59"></a><span id="l10.59">     // in case there is no overlap, also figure an insertionPoint</span>
<a href="#l10.60"></a><span id="l10.60">     let insertionPoint = this._ranges.length; // default to the end</span>
<a href="#l10.61"></a><span id="l10.61" class="difflineminus">-    for each (let [iTupe, [low, high]] in Iterator(this._ranges)) {</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineplus">+    for (let [iTupe, [low, high]] of this._ranges.entries()) {</span>
<a href="#l10.63"></a><span id="l10.63">       // If it's completely include the range, it should be nuked</span>
<a href="#l10.64"></a><span id="l10.64">       if (aRangeStart &lt;= low &amp;&amp; aRangeEnd &gt;= high) {</span>
<a href="#l10.65"></a><span id="l10.65">         if (lowNuke == null) // only the first one we see is the low one</span>
<a href="#l10.66"></a><span id="l10.66">           lowNuke = iTupe;</span>
<a href="#l10.67"></a><span id="l10.67">         highNuke = iTupe;</span>
<a href="#l10.68"></a><span id="l10.68">       }</span>
<a href="#l10.69"></a><span id="l10.69">       // If our new range start is inside a range or is adjacent, it's overlap</span>
<a href="#l10.70"></a><span id="l10.70">       if (aRangeStart &gt;= low - 1 &amp;&amp; aRangeStart &lt;= high + 1 &amp;&amp;</span>
<a href="#l10.71"></a><span id="l10.71" class="difflineat">@@ -309,17 +309,17 @@ JSTreeSelection.prototype = {</span>
<a href="#l10.72"></a><span id="l10.72">    */</span>
<a href="#l10.73"></a><span id="l10.73">   clearRange: function JSTreeSelection_clearRange(aRangeStart, aRangeEnd) {</span>
<a href="#l10.74"></a><span id="l10.74">     // Iterate over our existing set of ranges, finding the 'range' of ranges</span>
<a href="#l10.75"></a><span id="l10.75">     //  that our clear range overlaps or simply obviates.</span>
<a href="#l10.76"></a><span id="l10.76">     // Overlap variables track blocks we need to keep some part of, Nuke</span>
<a href="#l10.77"></a><span id="l10.77">     //  variables are for blocks that get spliced out.  For our purposes, all</span>
<a href="#l10.78"></a><span id="l10.78">     //  overlap blocks are also nuke blocks.</span>
<a href="#l10.79"></a><span id="l10.79">     let lowOverlap, lowNuke, highNuke, highOverlap;</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineminus">-    for each (let [iTupe, [low, high]] in Iterator(this._ranges)) {</span>
<a href="#l10.81"></a><span id="l10.81" class="difflineplus">+    for (let [iTupe, [low, high]] of this._ranges.entries()) {</span>
<a href="#l10.82"></a><span id="l10.82">       // If we completely include the range, it should be nuked</span>
<a href="#l10.83"></a><span id="l10.83">       if (aRangeStart &lt;= low &amp;&amp; aRangeEnd &gt;= high) {</span>
<a href="#l10.84"></a><span id="l10.84">         if (lowNuke == null) // only the first one we see is the low one</span>
<a href="#l10.85"></a><span id="l10.85">           lowNuke = iTupe;</span>
<a href="#l10.86"></a><span id="l10.86">         highNuke = iTupe;</span>
<a href="#l10.87"></a><span id="l10.87">       }</span>
<a href="#l10.88"></a><span id="l10.88">       // If our new range start is inside a range, it's nuke and maybe overlap</span>
<a href="#l10.89"></a><span id="l10.89">       if (aRangeStart &gt;= low &amp;&amp; aRangeStart &lt;= high &amp;&amp; lowNuke == null) {</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineat">@@ -441,17 +441,17 @@ JSTreeSelection.prototype = {</span>
<a href="#l10.91"></a><span id="l10.91">    * Find the index of the range, if any, that contains the given index, and</span>
<a href="#l10.92"></a><span id="l10.92">    *  the index at which to insert a range if one does not exist.</span>
<a href="#l10.93"></a><span id="l10.93">    *</span>
<a href="#l10.94"></a><span id="l10.94">    * @return A tuple containing: 1) the index if there is one, null otherwise,</span>
<a href="#l10.95"></a><span id="l10.95">    *     2) the index at which to insert a range that would contain the point.</span>
<a href="#l10.96"></a><span id="l10.96">    */</span>
<a href="#l10.97"></a><span id="l10.97">   _findRangeContainingRow:</span>
<a href="#l10.98"></a><span id="l10.98">       function JSTreeSelection__findRangeContainingRow(aIndex) {</span>
<a href="#l10.99"></a><span id="l10.99" class="difflineminus">-    for each (let [iTupe, [low, high]] in Iterator(this._ranges)) {</span>
<a href="#l10.100"></a><span id="l10.100" class="difflineplus">+    for (let [iTupe, [low, high]] of this._ranges.entries()) {</span>
<a href="#l10.101"></a><span id="l10.101">       if (aIndex &gt;= low &amp;&amp; aIndex &lt;= high)</span>
<a href="#l10.102"></a><span id="l10.102">         return [iTupe, iTupe];</span>
<a href="#l10.103"></a><span id="l10.103">       if (aIndex &lt; low)</span>
<a href="#l10.104"></a><span id="l10.104">         return [null, iTupe];</span>
<a href="#l10.105"></a><span id="l10.105">     }</span>
<a href="#l10.106"></a><span id="l10.106">     return [null, this._ranges.length];</span>
<a href="#l10.107"></a><span id="l10.107">   },</span>
<a href="#l10.108"></a><span id="l10.108"> </span>
<a href="#l10.109"></a><span id="l10.109" class="difflineat">@@ -481,17 +481,17 @@ JSTreeSelection.prototype = {</span>
<a href="#l10.110"></a><span id="l10.110">    */</span>
<a href="#l10.111"></a><span id="l10.111">   replayAdjustSelectionLog:</span>
<a href="#l10.112"></a><span id="l10.112">       function JSTreeSelection_replayAdjustSelectionLog(aSelection) {</span>
<a href="#l10.113"></a><span id="l10.113">     if (this._adjustSelectionLog.length) {</span>
<a href="#l10.114"></a><span id="l10.114">       // Temporarily disable selection events because adjustSelection is going</span>
<a href="#l10.115"></a><span id="l10.115">       //  to generate an event each time otherwise, and better 1 event than</span>
<a href="#l10.116"></a><span id="l10.116">       //  many.</span>
<a href="#l10.117"></a><span id="l10.117">       aSelection.selectEventsSuppressed = true;</span>
<a href="#l10.118"></a><span id="l10.118" class="difflineminus">-      for each (let [, [index, count]] in Iterator(this._adjustSelectionLog)) {</span>
<a href="#l10.119"></a><span id="l10.119" class="difflineplus">+      for (let [index, count] of this._adjustSelectionLog) {</span>
<a href="#l10.120"></a><span id="l10.120">         aSelection.adjustSelection(index, count);</span>
<a href="#l10.121"></a><span id="l10.121">       }</span>
<a href="#l10.122"></a><span id="l10.122">       aSelection.selectEventsSuppressed = false;</span>
<a href="#l10.123"></a><span id="l10.123">     }</span>
<a href="#l10.124"></a><span id="l10.124">     this._adjustSelectionLog = null;</span>
<a href="#l10.125"></a><span id="l10.125">   },</span>
<a href="#l10.126"></a><span id="l10.126"> </span>
<a href="#l10.127"></a><span id="l10.127">   adjustSelection: function JSTreeSelection_adjustSelection(aIndex, aCount) {</span>
<a href="#l10.128"></a><span id="l10.128" class="difflineat">@@ -639,16 +639,16 @@ JSTreeSelection.prototype = {</span>
<a href="#l10.129"></a><span id="l10.129">    * @note We don't transfer the correct shiftSelectPivot over.</span>
<a href="#l10.130"></a><span id="l10.130">    * @note This will fire a selectionChanged event on the tree view.</span>
<a href="#l10.131"></a><span id="l10.131">    *</span>
<a href="#l10.132"></a><span id="l10.132">    * @param aSelection an nsITreeSelection to duplicate this selection onto</span>
<a href="#l10.133"></a><span id="l10.133">    */</span>
<a href="#l10.134"></a><span id="l10.134">   duplicateSelection: function JSTreeSelection_duplicateSelection(aSelection) {</span>
<a href="#l10.135"></a><span id="l10.135">     aSelection.selectEventsSuppressed = true;</span>
<a href="#l10.136"></a><span id="l10.136">     aSelection.clearSelection();</span>
<a href="#l10.137"></a><span id="l10.137" class="difflineminus">-    for each (let [iTupe, [low, high]] in Iterator(this._ranges))</span>
<a href="#l10.138"></a><span id="l10.138" class="difflineplus">+    for (let [iTupe, [low, high]] of this._ranges.entries())</span>
<a href="#l10.139"></a><span id="l10.139">       aSelection.rangedSelect(low, high, iTupe &gt; 0);</span>
<a href="#l10.140"></a><span id="l10.140"> </span>
<a href="#l10.141"></a><span id="l10.141">     aSelection.currentIndex = this.currentIndex;</span>
<a href="#l10.142"></a><span id="l10.142">     // This will fire a selectionChanged event</span>
<a href="#l10.143"></a><span id="l10.143">     aSelection.selectEventsSuppressed = false;</span>
<a href="#l10.144"></a><span id="l10.144">   },</span>
<a href="#l10.145"></a><span id="l10.145"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/base/util/traceHelper.js</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/base/util/traceHelper.js</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -52,17 +52,17 @@ var STOP_COLORS = &quot;\x1b[0m&quot;;</span>
<a href="#l11.4"></a><span id="l11.4">  *                          &quot;JSTreeSelection&quot;, /.+/, {color: &quot;yellow&quot;});</span>
<a href="#l11.5"></a><span id="l11.5">  */</span>
<a href="#l11.6"></a><span id="l11.6"> var DebugTraceHelper = {</span>
<a href="#l11.7"></a><span id="l11.7">   tracify: function(aObj, aDesc, aPat, aContext, aSettings) {</span>
<a href="#l11.8"></a><span id="l11.8">     aContext.depth = 0;</span>
<a href="#l11.9"></a><span id="l11.9">     let color = aSettings.color || &quot;cyan&quot;;</span>
<a href="#l11.10"></a><span id="l11.10">     aSettings.introCode = BRIGHT_COLORS[color];</span>
<a href="#l11.11"></a><span id="l11.11">     aSettings.outroCode = DARK_COLORS[color];</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-    for each (let key in Iterator(aObj, true)) {</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+    for (let key in aObj) {</span>
<a href="#l11.14"></a><span id="l11.14">       if (aPat.test(key)) {</span>
<a href="#l11.15"></a><span id="l11.15">         // ignore properties!</span>
<a href="#l11.16"></a><span id="l11.16">         if (aObj.__lookupGetter__(key) || aObj.__lookupSetter__(key))</span>
<a href="#l11.17"></a><span id="l11.17">           continue;</span>
<a href="#l11.18"></a><span id="l11.18">         // ignore non-functions!</span>
<a href="#l11.19"></a><span id="l11.19">         if (typeof(aObj[key]) != &quot;function&quot;)</span>
<a href="#l11.20"></a><span id="l11.20">           continue;</span>
<a href="#l11.21"></a><span id="l11.21">         let name = key;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/db/gloda/components/glautocomp.js</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/db/gloda/components/glautocomp.js</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -49,17 +49,17 @@ function ResultRowMulti(aNounID, aCriter</span>
<a href="#l12.4"></a><span id="l12.4">   this.renderer = null;</span>
<a href="#l12.5"></a><span id="l12.5"> }</span>
<a href="#l12.6"></a><span id="l12.6"> ResultRowMulti.prototype = {</span>
<a href="#l12.7"></a><span id="l12.7">   multi: true,</span>
<a href="#l12.8"></a><span id="l12.8">   typeForStyle: &quot;gloda-multi&quot;,</span>
<a href="#l12.9"></a><span id="l12.9">   fullText: false,</span>
<a href="#l12.10"></a><span id="l12.10">   onItemsAdded: function(aItems) {</span>
<a href="#l12.11"></a><span id="l12.11">     if (this.renderer) {</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-      for each (let [iItem, item] in Iterator(aItems)) {</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+      for (let [iItem, item] of aItems.entries()) {</span>
<a href="#l12.14"></a><span id="l12.14">         this.renderer.renderItem(item);</span>
<a href="#l12.15"></a><span id="l12.15">       }</span>
<a href="#l12.16"></a><span id="l12.16">     }</span>
<a href="#l12.17"></a><span id="l12.17">   },</span>
<a href="#l12.18"></a><span id="l12.18">   onItemsModified: function(aItems) {</span>
<a href="#l12.19"></a><span id="l12.19">   },</span>
<a href="#l12.20"></a><span id="l12.20">   onItemsRemoved: function(aItems) {</span>
<a href="#l12.21"></a><span id="l12.21">   },</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineat">@@ -212,21 +212,21 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l12.23"></a><span id="l12.23">       let thing = matches[iMatch];</span>
<a href="#l12.24"></a><span id="l12.24">       if (thing.NOUN_ID == Gloda.NOUN_CONTACT &amp;&amp; !(thing.id in contactToThing))</span>
<a href="#l12.25"></a><span id="l12.25">         contactToThing[thing.id] = thing;</span>
<a href="#l12.26"></a><span id="l12.26">       else if (thing.NOUN_ID == Gloda.NOUN_IDENTITY)</span>
<a href="#l12.27"></a><span id="l12.27">         contactToThing[thing.contactID] = thing;</span>
<a href="#l12.28"></a><span id="l12.28">     }</span>
<a href="#l12.29"></a><span id="l12.29">     // and since we can now map from contacts down to identities, map contacts</span>
<a href="#l12.30"></a><span id="l12.30">     //  to the first identity for them that we find...</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineminus">-    matches = [val.NOUN_ID == Gloda.NOUN_IDENTITY ? val : val.identities[0]</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineminus">-               for each ([iVal, val] in Iterator(contactToThing))];</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+    matches = Object.keys(contactToThing).map(id =&gt; contactToThing[id]).</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+      map(val =&gt; val.NOUN_ID == Gloda.NOUN_IDENTITY ? val : val.identities[0]);</span>
<a href="#l12.35"></a><span id="l12.35"> </span>
<a href="#l12.36"></a><span id="l12.36" class="difflineminus">-    let rows = [new ResultRowSingle(match, &quot;text&quot;, aResult.searchString)</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineminus">-                for each ([iMatch, match] in Iterator(matches))];</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+    let rows = matches.</span>
<a href="#l12.39"></a><span id="l12.39" class="difflineplus">+      map(match =&gt; new ResultRowSingle(match, &quot;text&quot;, aResult.searchString));</span>
<a href="#l12.40"></a><span id="l12.40">     aResult.addRows(rows);</span>
<a href="#l12.41"></a><span id="l12.41"> </span>
<a href="#l12.42"></a><span id="l12.42">     // - match against database contacts / identities</span>
<a href="#l12.43"></a><span id="l12.43">     let pending = {contactToThing: contactToThing, pendingCount: 2};</span>
<a href="#l12.44"></a><span id="l12.44"> </span>
<a href="#l12.45"></a><span id="l12.45">     let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l12.46"></a><span id="l12.46">     contactQuery.nameLike(contactQuery.WILDCARD, aString,</span>
<a href="#l12.47"></a><span id="l12.47"> 	contactQuery.WILDCARD);</span>
<a href="#l12.48"></a><span id="l12.48" class="difflineat">@@ -258,23 +258,23 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l12.49"></a><span id="l12.49">         this.contactCollection._onItemsAdded([Gloda.myContact]);</span>
<a href="#l12.50"></a><span id="l12.50"> </span>
<a href="#l12.51"></a><span id="l12.51">       // the set of identities owned by the contacts is automatically loaded as part</span>
<a href="#l12.52"></a><span id="l12.52">       //  of the contact loading...</span>
<a href="#l12.53"></a><span id="l12.53">       // (but only if we actually have any contacts)</span>
<a href="#l12.54"></a><span id="l12.54">       this.identityCollection =</span>
<a href="#l12.55"></a><span id="l12.55">         this.contactCollection.subCollections[Gloda.NOUN_IDENTITY];</span>
<a href="#l12.56"></a><span id="l12.56"> </span>
<a href="#l12.57"></a><span id="l12.57" class="difflineminus">-      let contactNames = [(c.name.replace(&quot; &quot;, &quot;&quot;).toLowerCase() || &quot;x&quot;) for each</span>
<a href="#l12.58"></a><span id="l12.58" class="difflineminus">-                          ([, c] in Iterator(this.contactCollection.items))];</span>
<a href="#l12.59"></a><span id="l12.59" class="difflineplus">+      let contactNames = this.contactCollection.items.</span>
<a href="#l12.60"></a><span id="l12.60" class="difflineplus">+        map(c =&gt; c.name.replace(&quot; &quot;, &quot;&quot;).toLowerCase() || &quot;x&quot;);</span>
<a href="#l12.61"></a><span id="l12.61">       // if we had no contacts, we will have no identity collection!</span>
<a href="#l12.62"></a><span id="l12.62">       let identityMails;</span>
<a href="#l12.63"></a><span id="l12.63">       if (this.identityCollection)</span>
<a href="#l12.64"></a><span id="l12.64" class="difflineminus">-        identityMails = [i.value.toLowerCase() for each</span>
<a href="#l12.65"></a><span id="l12.65" class="difflineminus">-                         ([, i] in Iterator(this.identityCollection.items))];</span>
<a href="#l12.66"></a><span id="l12.66" class="difflineplus">+        identityMails = this.identityCollection.items.</span>
<a href="#l12.67"></a><span id="l12.67" class="difflineplus">+          map(i =&gt; i.value.toLowerCase());</span>
<a href="#l12.68"></a><span id="l12.68"> </span>
<a href="#l12.69"></a><span id="l12.69">       // The suffix tree takes two parallel lists; the first contains strings</span>
<a href="#l12.70"></a><span id="l12.70">       //  while the second contains objects that correspond to those strings.</span>
<a href="#l12.71"></a><span id="l12.71">       // In the degenerate case where identityCollection does not exist, it will</span>
<a href="#l12.72"></a><span id="l12.72">       //  be undefined.  Calling concat with an argument of undefined simply</span>
<a href="#l12.73"></a><span id="l12.73">       //  duplicates the list we called concat on, and is thus harmless.  Our</span>
<a href="#l12.74"></a><span id="l12.74">       //  use of &amp;&amp; on identityCollection allows its undefined value to be</span>
<a href="#l12.75"></a><span id="l12.75">       //  passed through to concat.  identityMails will likewise be undefined.</span>
<a href="#l12.76"></a><span id="l12.76" class="difflineat">@@ -314,18 +314,18 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l12.77"></a><span id="l12.77">         if (!(contact.id in contactToThing)) {</span>
<a href="#l12.78"></a><span id="l12.78">           contactToThing[contact.id] = contact;</span>
<a href="#l12.79"></a><span id="l12.79">           possibleDudes.push(contact.identities[0]);</span>
<a href="#l12.80"></a><span id="l12.80">         }</span>
<a href="#l12.81"></a><span id="l12.81">       }</span>
<a href="#l12.82"></a><span id="l12.82"> </span>
<a href="#l12.83"></a><span id="l12.83">       // sort in order of descending popularity</span>
<a href="#l12.84"></a><span id="l12.84">       possibleDudes.sort(this._popularitySorter);</span>
<a href="#l12.85"></a><span id="l12.85" class="difflineminus">-      let rows = [new ResultRowSingle(dude, &quot;text&quot;, result.searchString)</span>
<a href="#l12.86"></a><span id="l12.86" class="difflineminus">-                  for each ([iDude, dude] in Iterator(possibleDudes))];</span>
<a href="#l12.87"></a><span id="l12.87" class="difflineplus">+      let rows = possibleDudes.</span>
<a href="#l12.88"></a><span id="l12.88" class="difflineplus">+        map(dude =&gt; new ResultRowSingle(dude, &quot;text&quot;, result.searchString));</span>
<a href="#l12.89"></a><span id="l12.89">       result.addRows(rows);</span>
<a href="#l12.90"></a><span id="l12.90">       result.markCompleted(this);</span>
<a href="#l12.91"></a><span id="l12.91"> </span>
<a href="#l12.92"></a><span id="l12.92">       // the collections no longer care about the result, make it clear.</span>
<a href="#l12.93"></a><span id="l12.93">       delete pending.identityColl.data;</span>
<a href="#l12.94"></a><span id="l12.94">       delete pending.contactColl.data;</span>
<a href="#l12.95"></a><span id="l12.95">       // the result object no longer needs us or our data</span>
<a href="#l12.96"></a><span id="l12.96">       delete result._contactCompleterPending;</span>
<a href="#l12.97"></a><span id="l12.97" class="difflineat">@@ -359,17 +359,17 @@ ContactTagCompleter.prototype = {</span>
<a href="#l12.98"></a><span id="l12.98">     if (this._suffixTreeDirty)</span>
<a href="#l12.99"></a><span id="l12.99">       this._buildSuffixTree();</span>
<a href="#l12.100"></a><span id="l12.100"> </span>
<a href="#l12.101"></a><span id="l12.101">     if (aString.length &lt; 2)</span>
<a href="#l12.102"></a><span id="l12.102">       return false; // no async mechanism that will add new rows</span>
<a href="#l12.103"></a><span id="l12.103"> </span>
<a href="#l12.104"></a><span id="l12.104">     let tags = this._suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l12.105"></a><span id="l12.105">     let rows = [];</span>
<a href="#l12.106"></a><span id="l12.106" class="difflineminus">-    for each (let [iTag, tag] in Iterator(tags)) {</span>
<a href="#l12.107"></a><span id="l12.107" class="difflineplus">+    for (let tag of tags) {</span>
<a href="#l12.108"></a><span id="l12.108">       let query = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l12.109"></a><span id="l12.109">       query.freeTags(tag);</span>
<a href="#l12.110"></a><span id="l12.110">       let resRow = new ResultRowMulti(Gloda.NOUN_CONTACT, &quot;tag&quot;, tag.name,</span>
<a href="#l12.111"></a><span id="l12.111">                                       query);</span>
<a href="#l12.112"></a><span id="l12.112">       rows.push(resRow);</span>
<a href="#l12.113"></a><span id="l12.113">     }</span>
<a href="#l12.114"></a><span id="l12.114">     aResult.addRows(rows);</span>
<a href="#l12.115"></a><span id="l12.115"> </span>
<a href="#l12.116"></a><span id="l12.116" class="difflineat">@@ -396,17 +396,17 @@ MessageTagCompleter.prototype = {</span>
<a href="#l12.117"></a><span id="l12.117">     this._suffixTreeDirty = false;</span>
<a href="#l12.118"></a><span id="l12.118">   },</span>
<a href="#l12.119"></a><span id="l12.119">   complete: function MessageTagCompleter_complete(aResult, aString) {</span>
<a href="#l12.120"></a><span id="l12.120">     if (aString.length &lt; 2)</span>
<a href="#l12.121"></a><span id="l12.121">       return false;</span>
<a href="#l12.122"></a><span id="l12.122"> </span>
<a href="#l12.123"></a><span id="l12.123">     let tags = this._suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l12.124"></a><span id="l12.124">     let rows = [];</span>
<a href="#l12.125"></a><span id="l12.125" class="difflineminus">-    for each (let [, tag] in Iterator(tags)) {</span>
<a href="#l12.126"></a><span id="l12.126" class="difflineplus">+    for (let tag of tags) {</span>
<a href="#l12.127"></a><span id="l12.127">       let resRow = new ResultRowSingle(tag, &quot;tag&quot;, tag.tag, TagNoun.id);</span>
<a href="#l12.128"></a><span id="l12.128">       rows.push(resRow);</span>
<a href="#l12.129"></a><span id="l12.129">     }</span>
<a href="#l12.130"></a><span id="l12.130">     aResult.addRows(rows);</span>
<a href="#l12.131"></a><span id="l12.131"> </span>
<a href="#l12.132"></a><span id="l12.132">     return false; // no async mechanism that will add new rows</span>
<a href="#l12.133"></a><span id="l12.133">   }</span>
<a href="#l12.134"></a><span id="l12.134"> };</span>
<a href="#l12.135"></a><span id="l12.135" class="difflineat">@@ -507,17 +507,17 @@ nsAutoCompleteGloda.prototype = {</span>
<a href="#l12.136"></a><span id="l12.136">   startSearch: function(aString, aParam, aResult, aListener) {</span>
<a href="#l12.137"></a><span id="l12.137">     try {</span>
<a href="#l12.138"></a><span id="l12.138">       let result = new nsAutoCompleteGlodaResult(aListener, this, aString);</span>
<a href="#l12.139"></a><span id="l12.139">       // save this for hacky access to the search.  I somewhat suspect we simply</span>
<a href="#l12.140"></a><span id="l12.140">       //  should not be using the formal autocomplete mechanism at all.</span>
<a href="#l12.141"></a><span id="l12.141">       this.curResult = result;</span>
<a href="#l12.142"></a><span id="l12.142"> </span>
<a href="#l12.143"></a><span id="l12.143">       if (aParam == &quot;global&quot;) {</span>
<a href="#l12.144"></a><span id="l12.144" class="difflineminus">-        for each (let [iCompleter, completer] in Iterator(this.completers)) {</span>
<a href="#l12.145"></a><span id="l12.145" class="difflineplus">+        for (let completer of this.completers) {</span>
<a href="#l12.146"></a><span id="l12.146">           // they will return true if they have something pending.</span>
<a href="#l12.147"></a><span id="l12.147">           if (completer.complete(result, aString))</span>
<a href="#l12.148"></a><span id="l12.148">             result.markPending(completer);</span>
<a href="#l12.149"></a><span id="l12.149">         }</span>
<a href="#l12.150"></a><span id="l12.150">       //} else {</span>
<a href="#l12.151"></a><span id="l12.151">       //   It'd be nice to do autocomplete in the quicksearch modes based</span>
<a href="#l12.152"></a><span id="l12.152">       //   on the specific values for that mode in the current view.</span>
<a href="#l12.153"></a><span id="l12.153">       //   But we don't do that yet.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/db/gloda/content/glodacomplete.xml</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/db/gloda/content/glodacomplete.xml</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -109,17 +109,17 @@</span>
<a href="#l13.4"></a><span id="l13.4">         &lt;body&gt;</span>
<a href="#l13.5"></a><span id="l13.5">           &lt;![CDATA[</span>
<a href="#l13.6"></a><span id="l13.6">           // Short circuit for empty search ([&quot;&quot;] == &quot;&quot;)</span>
<a href="#l13.7"></a><span id="l13.7">           if (aSearchTokens == &quot;&quot;)</span>
<a href="#l13.8"></a><span id="l13.8">             return [0, aText.length];</span>
<a href="#l13.9"></a><span id="l13.9"> </span>
<a href="#l13.10"></a><span id="l13.10">           // Find which regions of text match the search terms</span>
<a href="#l13.11"></a><span id="l13.11">           let regions = [];</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-          for each (let search in aSearchTokens) {</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+          for (let search of aSearchTokens) {</span>
<a href="#l13.14"></a><span id="l13.14">             let matchIndex;</span>
<a href="#l13.15"></a><span id="l13.15">             let startIndex = 0;</span>
<a href="#l13.16"></a><span id="l13.16">             let searchLen = search.length;</span>
<a href="#l13.17"></a><span id="l13.17"> </span>
<a href="#l13.18"></a><span id="l13.18">             // Find all matches of the search terms, but stop early for perf</span>
<a href="#l13.19"></a><span id="l13.19">             let lowerText = aText.toLowerCase().substr(0, this.boundaryCutoff);</span>
<a href="#l13.20"></a><span id="l13.20">             while ((matchIndex = lowerText.indexOf(search, startIndex)) &gt;= 0) {</span>
<a href="#l13.21"></a><span id="l13.21">               // Start the next search from where this one finished</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineat">@@ -624,17 +624,17 @@</span>
<a href="#l13.23"></a><span id="l13.23">           var row = this.row;</span>
<a href="#l13.24"></a><span id="l13.24">           if (row == null)</span>
<a href="#l13.25"></a><span id="l13.25">             return;</span>
<a href="#l13.26"></a><span id="l13.26">           </span>
<a href="#l13.27"></a><span id="l13.27">           this._explanation.value = row.nounDef.name + &quot;s &quot; +</span>
<a href="#l13.28"></a><span id="l13.28">             row.criteriaType + &quot;ed &quot; + row.criteria;</span>
<a href="#l13.29"></a><span id="l13.29">           </span>
<a href="#l13.30"></a><span id="l13.30">           // render anyone already in there</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineminus">-          for each (let item in row.collection.items) {</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+          for (let item of row.collection.items) {</span>
<a href="#l13.33"></a><span id="l13.33">             this.renderItem(item);</span>
<a href="#l13.34"></a><span id="l13.34">           }</span>
<a href="#l13.35"></a><span id="l13.35">           // listen up, yo.</span>
<a href="#l13.36"></a><span id="l13.36">           row.renderer = this;</span>
<a href="#l13.37"></a><span id="l13.37">           ]]&gt;</span>
<a href="#l13.38"></a><span id="l13.38">         &lt;/body&gt;</span>
<a href="#l13.39"></a><span id="l13.39">       &lt;/method&gt;</span>
<a href="#l13.40"></a><span id="l13.40">     &lt;/implementation&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/db/gloda/modules/collection.js</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/collection.js</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -84,18 +84,17 @@ var GlodaCollectionManager = {</span>
<a href="#l14.4"></a><span id="l14.4">         let item = cache._idMap[aID];</span>
<a href="#l14.5"></a><span id="l14.5">         return cache.hit(item);</span>
<a href="#l14.6"></a><span id="l14.6">       }</span>
<a href="#l14.7"></a><span id="l14.7">     }</span>
<a href="#l14.8"></a><span id="l14.8"> </span>
<a href="#l14.9"></a><span id="l14.9">     if (aDoCache === false)</span>
<a href="#l14.10"></a><span id="l14.10">       cache = null;</span>
<a href="#l14.11"></a><span id="l14.11"> </span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-    for each (let [iCollection, collection] in</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineminus">-              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineplus">+    for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l14.15"></a><span id="l14.15">       if (aID in collection._idMap) {</span>
<a href="#l14.16"></a><span id="l14.16">         let item = collection._idMap[aID];</span>
<a href="#l14.17"></a><span id="l14.17">         if (cache)</span>
<a href="#l14.18"></a><span id="l14.18">           cache.add([item]);</span>
<a href="#l14.19"></a><span id="l14.19">         return item;</span>
<a href="#l14.20"></a><span id="l14.20">       }</span>
<a href="#l14.21"></a><span id="l14.21">     }</span>
<a href="#l14.22"></a><span id="l14.22"> </span>
<a href="#l14.23"></a><span id="l14.23" class="difflineat">@@ -139,18 +138,17 @@ var GlodaCollectionManager = {</span>
<a href="#l14.24"></a><span id="l14.24">           cache.hit(cacheValue);</span>
<a href="#l14.25"></a><span id="l14.25">         }</span>
<a href="#l14.26"></a><span id="l14.26">       }</span>
<a href="#l14.27"></a><span id="l14.27">     }</span>
<a href="#l14.28"></a><span id="l14.28"> </span>
<a href="#l14.29"></a><span id="l14.29">     if (aDoCache === false)</span>
<a href="#l14.30"></a><span id="l14.30">       cache = null;</span>
<a href="#l14.31"></a><span id="l14.31"> </span>
<a href="#l14.32"></a><span id="l14.32" class="difflineminus">-    for each (let [iCollection, collection] in</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineminus">-              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+    for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l14.35"></a><span id="l14.35">       for (let key in notFound) {</span>
<a href="#l14.36"></a><span id="l14.36">         let collValue = collection._idMap[key];</span>
<a href="#l14.37"></a><span id="l14.37">         if (collValue !== undefined) {</span>
<a href="#l14.38"></a><span id="l14.38">           aTargetMap[key] = collValue;</span>
<a href="#l14.39"></a><span id="l14.39">           delete notFound[key];</span>
<a href="#l14.40"></a><span id="l14.40">           foundCount++;</span>
<a href="#l14.41"></a><span id="l14.41">           notFoundCount--;</span>
<a href="#l14.42"></a><span id="l14.42">           if (cache)</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineat">@@ -166,17 +164,17 @@ var GlodaCollectionManager = {</span>
<a href="#l14.44"></a><span id="l14.44">    * Friendlier version of |cacheLookupMany|; takes a list of ids and returns</span>
<a href="#l14.45"></a><span id="l14.45">    *  an object whose keys and values are the gloda id's and instances of the</span>
<a href="#l14.46"></a><span id="l14.46">    *  instances that were found.  We don't tell you who we didn't find.  The</span>
<a href="#l14.47"></a><span id="l14.47">    *  assumption is this is being used for in-memory updates where we only need</span>
<a href="#l14.48"></a><span id="l14.48">    *  to tweak what is in memory.</span>
<a href="#l14.49"></a><span id="l14.49">    */</span>
<a href="#l14.50"></a><span id="l14.50">   cacheLookupManyList: function gloda_colm_cacheLookupManyList(aNounID, aIds) {</span>
<a href="#l14.51"></a><span id="l14.51">     let checkMap = {}, targetMap = {};</span>
<a href="#l14.52"></a><span id="l14.52" class="difflineminus">-    for each (let [, id] in Iterator(aIds)) {</span>
<a href="#l14.53"></a><span id="l14.53" class="difflineplus">+    for (let id of aIds) {</span>
<a href="#l14.54"></a><span id="l14.54">       checkMap[id] = null;</span>
<a href="#l14.55"></a><span id="l14.55">     }</span>
<a href="#l14.56"></a><span id="l14.56">     // do not promote found items into the cache</span>
<a href="#l14.57"></a><span id="l14.57">     this.cacheLookupMany(aNounID, checkMap, targetMap, false);</span>
<a href="#l14.58"></a><span id="l14.58">     return targetMap;</span>
<a href="#l14.59"></a><span id="l14.59">   },</span>
<a href="#l14.60"></a><span id="l14.60"> </span>
<a href="#l14.61"></a><span id="l14.61">   /**</span>
<a href="#l14.62"></a><span id="l14.62" class="difflineat">@@ -194,18 +192,17 @@ var GlodaCollectionManager = {</span>
<a href="#l14.63"></a><span id="l14.63">         let item = cache._uniqueValueMap[aUniqueValue];</span>
<a href="#l14.64"></a><span id="l14.64">         return cache.hit(item);</span>
<a href="#l14.65"></a><span id="l14.65">       }</span>
<a href="#l14.66"></a><span id="l14.66">     }</span>
<a href="#l14.67"></a><span id="l14.67"> </span>
<a href="#l14.68"></a><span id="l14.68">     if (aDoCache === false)</span>
<a href="#l14.69"></a><span id="l14.69">       cache = null;</span>
<a href="#l14.70"></a><span id="l14.70"> </span>
<a href="#l14.71"></a><span id="l14.71" class="difflineminus">-    for each (let [iCollection, collection] in</span>
<a href="#l14.72"></a><span id="l14.72" class="difflineminus">-              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l14.73"></a><span id="l14.73" class="difflineplus">+    for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l14.74"></a><span id="l14.74">       if (aUniqueValue in collection._uniqueValueMap) {</span>
<a href="#l14.75"></a><span id="l14.75">         let item = collection._uniqueValueMap[aUniqueValue];</span>
<a href="#l14.76"></a><span id="l14.76">         if (cache)</span>
<a href="#l14.77"></a><span id="l14.77">           cache.add([item]);</span>
<a href="#l14.78"></a><span id="l14.78">         return item;</span>
<a href="#l14.79"></a><span id="l14.79">       }</span>
<a href="#l14.80"></a><span id="l14.80">     }</span>
<a href="#l14.81"></a><span id="l14.81"> </span>
<a href="#l14.82"></a><span id="l14.82" class="difflineat">@@ -270,18 +267,17 @@ var GlodaCollectionManager = {</span>
<a href="#l14.83"></a><span id="l14.83">       for (let iItem = 0; iItem &lt; aItems.length; iItem++) {</span>
<a href="#l14.84"></a><span id="l14.84">         unresolvedIndexToItem[iItem] = aItems[iItem];</span>
<a href="#l14.85"></a><span id="l14.85">       }</span>
<a href="#l14.86"></a><span id="l14.86">       numUnresolved = aItems.length;</span>
<a href="#l14.87"></a><span id="l14.87">     }</span>
<a href="#l14.88"></a><span id="l14.88"> </span>
<a href="#l14.89"></a><span id="l14.89">     let needToCache = [];</span>
<a href="#l14.90"></a><span id="l14.90">     // next, let's fall back to our collections</span>
<a href="#l14.91"></a><span id="l14.91" class="difflineminus">-    for each (let [iCollection, collection] in</span>
<a href="#l14.92"></a><span id="l14.92" class="difflineminus">-              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l14.93"></a><span id="l14.93" class="difflineplus">+    for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l14.94"></a><span id="l14.94">       for (let [iItem, item] in Iterator(unresolvedIndexToItem)) {</span>
<a href="#l14.95"></a><span id="l14.95">         if (item.id in collection._idMap) {</span>
<a href="#l14.96"></a><span id="l14.96">           let realItem = collection._idMap[item.id];</span>
<a href="#l14.97"></a><span id="l14.97">           // update the caller's array to now have the 'real' object</span>
<a href="#l14.98"></a><span id="l14.98">           aItems[iItem] = realItem;</span>
<a href="#l14.99"></a><span id="l14.99">           // flag that we need to cache this guy (we use an inclusive cache)</span>
<a href="#l14.100"></a><span id="l14.100">           needToCache.push(realItem);</span>
<a href="#l14.101"></a><span id="l14.101">           // we no longer need to resolve this item...</span>
<a href="#l14.102"></a><span id="l14.102" class="difflineat">@@ -291,25 +287,26 @@ var GlodaCollectionManager = {</span>
<a href="#l14.103"></a><span id="l14.103">             break;</span>
<a href="#l14.104"></a><span id="l14.104">         }</span>
<a href="#l14.105"></a><span id="l14.105">       }</span>
<a href="#l14.106"></a><span id="l14.106">     }</span>
<a href="#l14.107"></a><span id="l14.107"> </span>
<a href="#l14.108"></a><span id="l14.108">     // anything left in unresolvedIndexToItem should be added to the cache</span>
<a href="#l14.109"></a><span id="l14.109">     //  unless !aCacheIfMissing.  plus, we already have 'needToCache'</span>
<a href="#l14.110"></a><span id="l14.110">     if (cache &amp;&amp; aCacheIfMissing) {</span>
<a href="#l14.111"></a><span id="l14.111" class="difflineminus">-      cache.add(needToCache.concat([val for each</span>
<a href="#l14.112"></a><span id="l14.112" class="difflineminus">-                                    (val in unresolvedIndexToItem)]));</span>
<a href="#l14.113"></a><span id="l14.113" class="difflineplus">+      cache.add(needToCache.concat(Object.keys(unresolvedIndexToItem).</span>
<a href="#l14.114"></a><span id="l14.114" class="difflineplus">+                                   map(key =&gt; unresolvedIndexToItem[key])));</span>
<a href="#l14.115"></a><span id="l14.115">     }</span>
<a href="#l14.116"></a><span id="l14.116"> </span>
<a href="#l14.117"></a><span id="l14.117">     return aItems;</span>
<a href="#l14.118"></a><span id="l14.118">   },</span>
<a href="#l14.119"></a><span id="l14.119"> </span>
<a href="#l14.120"></a><span id="l14.120">   cacheCommitDirty: function glod_colm_cacheCommitDirty() {</span>
<a href="#l14.121"></a><span id="l14.121" class="difflineminus">-    for each (let cache in this._cachesByNoun) {</span>
<a href="#l14.122"></a><span id="l14.122" class="difflineplus">+    for (let id in this._cachesByNoun) {</span>
<a href="#l14.123"></a><span id="l14.123" class="difflineplus">+      let cache = this._cachesByNoun[id];</span>
<a href="#l14.124"></a><span id="l14.124">       cache.commitDirty();</span>
<a href="#l14.125"></a><span id="l14.125">     }</span>
<a href="#l14.126"></a><span id="l14.126">   },</span>
<a href="#l14.127"></a><span id="l14.127"> </span>
<a href="#l14.128"></a><span id="l14.128">   /**</span>
<a href="#l14.129"></a><span id="l14.129">    * Notifies the collection manager that an item has been loaded and should</span>
<a href="#l14.130"></a><span id="l14.130">    *  be cached, assuming caching is active.</span>
<a href="#l14.131"></a><span id="l14.131">    */</span>
<a href="#l14.132"></a><span id="l14.132" class="difflineat">@@ -339,40 +336,37 @@ var GlodaCollectionManager = {</span>
<a href="#l14.133"></a><span id="l14.133">    *  to the collection if the item meets the query that defines the collection.</span>
<a href="#l14.134"></a><span id="l14.134">    */</span>
<a href="#l14.135"></a><span id="l14.135">   itemsAdded: function gloda_colm_itemsAdded(aNounID, aItems) {</span>
<a href="#l14.136"></a><span id="l14.136">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l14.137"></a><span id="l14.137">     if (cache) {</span>
<a href="#l14.138"></a><span id="l14.138">       cache.add(aItems);</span>
<a href="#l14.139"></a><span id="l14.139">     }</span>
<a href="#l14.140"></a><span id="l14.140"> </span>
<a href="#l14.141"></a><span id="l14.141" class="difflineminus">-    for each (let [iCollection, collection] in</span>
<a href="#l14.142"></a><span id="l14.142" class="difflineminus">-              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l14.143"></a><span id="l14.143" class="difflineminus">-      let addItems = [item for each ([i, item] in Iterator(aItems))</span>
<a href="#l14.144"></a><span id="l14.144" class="difflineminus">-                      if (collection.query.test(item))];</span>
<a href="#l14.145"></a><span id="l14.145" class="difflineplus">+    for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l14.146"></a><span id="l14.146" class="difflineplus">+      let addItems = aItems.filter(item =&gt; collection.query.test(item));</span>
<a href="#l14.147"></a><span id="l14.147">       if (addItems.length)</span>
<a href="#l14.148"></a><span id="l14.148">         collection._onItemsAdded(addItems);</span>
<a href="#l14.149"></a><span id="l14.149">     }</span>
<a href="#l14.150"></a><span id="l14.150">   },</span>
<a href="#l14.151"></a><span id="l14.151">   /**</span>
<a href="#l14.152"></a><span id="l14.152">    * This should be called when items in the global database are modified.  For</span>
<a href="#l14.153"></a><span id="l14.153">    *  example, as a result of indexing.  This should generally only be called</span>
<a href="#l14.154"></a><span id="l14.154">    *  by indexers or by attribute providers.</span>
<a href="#l14.155"></a><span id="l14.155">    * We walk all existing collections for the given noun type.  For items</span>
<a href="#l14.156"></a><span id="l14.156">    *  currently included in each collection but should no longer be (per the</span>
<a href="#l14.157"></a><span id="l14.157">    *  collection's defining query) we generate onItemsRemoved events.  For items</span>
<a href="#l14.158"></a><span id="l14.158">    *  not currently included in the collection but should now be, we generate</span>
<a href="#l14.159"></a><span id="l14.159">    *  onItemsAdded events.  For items included that still match the query, we</span>
<a href="#l14.160"></a><span id="l14.160">    *  generate onItemsModified events.</span>
<a href="#l14.161"></a><span id="l14.161">    */</span>
<a href="#l14.162"></a><span id="l14.162">   itemsModified: function gloda_colm_itemsModified(aNounID, aItems) {</span>
<a href="#l14.163"></a><span id="l14.163" class="difflineminus">-    for each (let [iCollection, collection] in</span>
<a href="#l14.164"></a><span id="l14.164" class="difflineminus">-              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l14.165"></a><span id="l14.165" class="difflineplus">+    for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l14.166"></a><span id="l14.166">       let added = [], modified = [], removed = [];</span>
<a href="#l14.167"></a><span id="l14.167" class="difflineminus">-      for each (let [iItem, item] in Iterator(aItems)) {</span>
<a href="#l14.168"></a><span id="l14.168" class="difflineplus">+      for (let item of aItems) {</span>
<a href="#l14.169"></a><span id="l14.169">         if (item.id in collection._idMap) {</span>
<a href="#l14.170"></a><span id="l14.170">           // currently in... but should it still be there?</span>
<a href="#l14.171"></a><span id="l14.171">           if (collection.query.test(item))</span>
<a href="#l14.172"></a><span id="l14.172">             modified.push(item); // yes, keep it</span>
<a href="#l14.173"></a><span id="l14.173">           // oy, so null queries really don't want any notifications, and they</span>
<a href="#l14.174"></a><span id="l14.174">           //  sorta fit into our existing model, except for the removal bit.</span>
<a href="#l14.175"></a><span id="l14.175">           //  so we need a specialized check for them, and we're using the</span>
<a href="#l14.176"></a><span id="l14.176">           //  frozen attribute to this end.</span>
<a href="#l14.177"></a><span id="l14.177" class="difflineat">@@ -400,28 +394,26 @@ var GlodaCollectionManager = {</span>
<a href="#l14.178"></a><span id="l14.178">    *  currently in the collection, we generate onItemsRemoved events.</span>
<a href="#l14.179"></a><span id="l14.179">    * </span>
<a href="#l14.180"></a><span id="l14.180">    * @param aItemIds A list of item ids that are being deleted.</span>
<a href="#l14.181"></a><span id="l14.181">    */</span>
<a href="#l14.182"></a><span id="l14.182">   itemsDeleted: function gloda_colm_itemsDeleted(aNounID, aItemIds) {</span>
<a href="#l14.183"></a><span id="l14.183">     // cache</span>
<a href="#l14.184"></a><span id="l14.184">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l14.185"></a><span id="l14.185">     if (cache) {</span>
<a href="#l14.186"></a><span id="l14.186" class="difflineminus">-      for each (let [, itemId] in Iterator(aItemIds)) {</span>
<a href="#l14.187"></a><span id="l14.187" class="difflineplus">+      for (let itemId of aItemIds) {</span>
<a href="#l14.188"></a><span id="l14.188">         if (itemId in cache._idMap)</span>
<a href="#l14.189"></a><span id="l14.189">           cache.deleted(cache._idMap[itemId]);</span>
<a href="#l14.190"></a><span id="l14.190">       }</span>
<a href="#l14.191"></a><span id="l14.191">     }</span>
<a href="#l14.192"></a><span id="l14.192"> </span>
<a href="#l14.193"></a><span id="l14.193">     // collections</span>
<a href="#l14.194"></a><span id="l14.194" class="difflineminus">-    for each (let [iCollection, collection] in</span>
<a href="#l14.195"></a><span id="l14.195" class="difflineminus">-              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l14.196"></a><span id="l14.196" class="difflineminus">-      let removeItems = [collection._idMap[itemId]</span>
<a href="#l14.197"></a><span id="l14.197" class="difflineminus">-                         for each ([, itemId] in Iterator(aItemIds))</span>
<a href="#l14.198"></a><span id="l14.198" class="difflineminus">-                         if (itemId in collection._idMap)];</span>
<a href="#l14.199"></a><span id="l14.199" class="difflineplus">+    for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l14.200"></a><span id="l14.200" class="difflineplus">+      let removeItems = aItemIds.filter(itemId =&gt; itemId in collection._idMap).</span>
<a href="#l14.201"></a><span id="l14.201" class="difflineplus">+        map(itemId =&gt; collection._idMap[itemId]);</span>
<a href="#l14.202"></a><span id="l14.202">       if (removeItems.length)</span>
<a href="#l14.203"></a><span id="l14.203">         collection._onItemsRemoved(removeItems);</span>
<a href="#l14.204"></a><span id="l14.204">     }</span>
<a href="#l14.205"></a><span id="l14.205">   },</span>
<a href="#l14.206"></a><span id="l14.206">   /**</span>
<a href="#l14.207"></a><span id="l14.207">    * Like |itemsDeleted| but for the case where the deletion is based on an</span>
<a href="#l14.208"></a><span id="l14.208">    *  attribute that SQLite can more efficiently check than we can and where the</span>
<a href="#l14.209"></a><span id="l14.209">    *  cost of scanning the in-memory items is presumably much cheaper than</span>
<a href="#l14.210"></a><span id="l14.210" class="difflineat">@@ -438,28 +430,26 @@ var GlodaCollectionManager = {</span>
<a href="#l14.211"></a><span id="l14.211">    *     thought of as deleted, or false if the item is still good.  Screw this</span>
<a href="#l14.212"></a><span id="l14.212">    *     up and you will get some seriously wacky bugs, yo.</span>
<a href="#l14.213"></a><span id="l14.213">    */</span>
<a href="#l14.214"></a><span id="l14.214">   itemsDeletedByAttribute: function gloda_colm_itemsDeletedByAttribute(</span>
<a href="#l14.215"></a><span id="l14.215">       aNounID, aFilter) {</span>
<a href="#l14.216"></a><span id="l14.216">     // cache</span>
<a href="#l14.217"></a><span id="l14.217">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l14.218"></a><span id="l14.218">     if (cache) {</span>
<a href="#l14.219"></a><span id="l14.219" class="difflineminus">-      for each (let [, item] in Iterator(cache._idMap)) {</span>
<a href="#l14.220"></a><span id="l14.220" class="difflineplus">+      for (let id in cache._idMap) {</span>
<a href="#l14.221"></a><span id="l14.221" class="difflineplus">+        let item = cache._idMap[id];</span>
<a href="#l14.222"></a><span id="l14.222">         if (aFilter(item))</span>
<a href="#l14.223"></a><span id="l14.223">           cache.deleted(item);</span>
<a href="#l14.224"></a><span id="l14.224">       }</span>
<a href="#l14.225"></a><span id="l14.225">     }</span>
<a href="#l14.226"></a><span id="l14.226"> </span>
<a href="#l14.227"></a><span id="l14.227">     // collections</span>
<a href="#l14.228"></a><span id="l14.228" class="difflineminus">-    for each (let [, collection] in</span>
<a href="#l14.229"></a><span id="l14.229" class="difflineminus">-              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l14.230"></a><span id="l14.230" class="difflineminus">-      let removeItems = [item</span>
<a href="#l14.231"></a><span id="l14.231" class="difflineminus">-                         for each ([, item] in Iterator(collection.items))</span>
<a href="#l14.232"></a><span id="l14.232" class="difflineminus">-                         if (aFilter(item))];</span>
<a href="#l14.233"></a><span id="l14.233" class="difflineplus">+    for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l14.234"></a><span id="l14.234" class="difflineplus">+      let removeItems = collection.items.filter(aFilter);</span>
<a href="#l14.235"></a><span id="l14.235">       if (removeItems.length)</span>
<a href="#l14.236"></a><span id="l14.236">         collection._onItemsRemoved(removeItems);</span>
<a href="#l14.237"></a><span id="l14.237">     }</span>
<a href="#l14.238"></a><span id="l14.238">   },</span>
<a href="#l14.239"></a><span id="l14.239"> };</span>
<a href="#l14.240"></a><span id="l14.240"> </span>
<a href="#l14.241"></a><span id="l14.241"> /**</span>
<a href="#l14.242"></a><span id="l14.242">  * @class A current view of the set of first-class nouns meeting a given query.</span>
<a href="#l14.243"></a><span id="l14.243" class="difflineat">@@ -559,23 +549,23 @@ GlodaCollection.prototype = {</span>
<a href="#l14.244"></a><span id="l14.244">     if (this._uniqueValueMap)</span>
<a href="#l14.245"></a><span id="l14.245">       this._uniqueValueMap = {};</span>
<a href="#l14.246"></a><span id="l14.246">     this.items = [];</span>
<a href="#l14.247"></a><span id="l14.247">   },</span>
<a href="#l14.248"></a><span id="l14.248"> </span>
<a href="#l14.249"></a><span id="l14.249">   _onItemsAdded: function gloda_coll_onItemsAdded(aItems) {</span>
<a href="#l14.250"></a><span id="l14.250">     this.items.push.apply(this.items, aItems);</span>
<a href="#l14.251"></a><span id="l14.251">     if (this._uniqueValueMap) {</span>
<a href="#l14.252"></a><span id="l14.252" class="difflineminus">-      for each (let [iItem, item] in Iterator(this.items)) {</span>
<a href="#l14.253"></a><span id="l14.253" class="difflineplus">+      for (let item of this.items) {</span>
<a href="#l14.254"></a><span id="l14.254">         this._idMap[item.id] = item;</span>
<a href="#l14.255"></a><span id="l14.255">         this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l14.256"></a><span id="l14.256">       }</span>
<a href="#l14.257"></a><span id="l14.257">     }</span>
<a href="#l14.258"></a><span id="l14.258">     else {</span>
<a href="#l14.259"></a><span id="l14.259" class="difflineminus">-      for each (let [iItem, item] in Iterator(this.items)) {</span>
<a href="#l14.260"></a><span id="l14.260" class="difflineplus">+      for (let item of this.items) {</span>
<a href="#l14.261"></a><span id="l14.261">         this._idMap[item.id] = item;</span>
<a href="#l14.262"></a><span id="l14.262">       }</span>
<a href="#l14.263"></a><span id="l14.263">     }</span>
<a href="#l14.264"></a><span id="l14.264">     if (this._listener) {</span>
<a href="#l14.265"></a><span id="l14.265">       try {</span>
<a href="#l14.266"></a><span id="l14.266">         this._listener.onItemsAdded(aItems, this);</span>
<a href="#l14.267"></a><span id="l14.267">       }</span>
<a href="#l14.268"></a><span id="l14.268">       catch (ex) {</span>
<a href="#l14.269"></a><span id="l14.269" class="difflineat">@@ -603,17 +593,17 @@ GlodaCollection.prototype = {</span>
<a href="#l14.270"></a><span id="l14.270">    *  part is that we need to remove the deleted items from our list of items.</span>
<a href="#l14.271"></a><span id="l14.271">    */</span>
<a href="#l14.272"></a><span id="l14.272">   _onItemsRemoved: function gloda_coll_onItemsRemoved(aItems) {</span>
<a href="#l14.273"></a><span id="l14.273">     // we want to avoid the O(n^2) deletion performance case, and deletion</span>
<a href="#l14.274"></a><span id="l14.274">     //  should be rare enough that the extra cost of building the deletion map</span>
<a href="#l14.275"></a><span id="l14.275">     //  should never be a real problem.</span>
<a href="#l14.276"></a><span id="l14.276">     let deleteMap = {};</span>
<a href="#l14.277"></a><span id="l14.277">     // build the delete map while also nuking from our id map/unique value map</span>
<a href="#l14.278"></a><span id="l14.278" class="difflineminus">-    for each (let [iItem, item] in Iterator(aItems)) {</span>
<a href="#l14.279"></a><span id="l14.279" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l14.280"></a><span id="l14.280">       deleteMap[item.id] = true;</span>
<a href="#l14.281"></a><span id="l14.281">       delete this._idMap[item.id];</span>
<a href="#l14.282"></a><span id="l14.282">       if (this._uniqueValueMap)</span>
<a href="#l14.283"></a><span id="l14.283">         delete this._uniqueValueMap[item.uniqueValue];</span>
<a href="#l14.284"></a><span id="l14.284">     }</span>
<a href="#l14.285"></a><span id="l14.285">     let items = this.items;</span>
<a href="#l14.286"></a><span id="l14.286">     // in-place filter.  probably needless optimization.</span>
<a href="#l14.287"></a><span id="l14.287">     let iWrite=0;</span>
<a href="#l14.288"></a><span id="l14.288" class="difflineat">@@ -661,17 +651,17 @@ function GlodaLRUCacheCollection(aNounDe</span>
<a href="#l14.289"></a><span id="l14.289">  * @class A LRU-discard cache.  We use a doubly linked-list for the eviction</span>
<a href="#l14.290"></a><span id="l14.290">  *  tracking.  Since we require that there is at most one LRU-discard cache per</span>
<a href="#l14.291"></a><span id="l14.291">  *  noun class, we simplify our lives by adding our own attributes to the</span>
<a href="#l14.292"></a><span id="l14.292">  *  cached objects.</span>
<a href="#l14.293"></a><span id="l14.293">  * @augments GlodaCollection</span>
<a href="#l14.294"></a><span id="l14.294">  */</span>
<a href="#l14.295"></a><span id="l14.295"> GlodaLRUCacheCollection.prototype = new GlodaCollection;</span>
<a href="#l14.296"></a><span id="l14.296"> GlodaLRUCacheCollection.prototype.add = function cache_add(aItems) {</span>
<a href="#l14.297"></a><span id="l14.297" class="difflineminus">-  for each (let [iItem, item] in Iterator(aItems)) {</span>
<a href="#l14.298"></a><span id="l14.298" class="difflineplus">+  for (let item of aItems) {</span>
<a href="#l14.299"></a><span id="l14.299">     if (item.id in this._idMap) {</span>
<a href="#l14.300"></a><span id="l14.300">       // DEBUGME so, we're dealing with this, but it shouldn't happen.  need</span>
<a href="#l14.301"></a><span id="l14.301">       //  trace-debuggage.</span>
<a href="#l14.302"></a><span id="l14.302">       continue;</span>
<a href="#l14.303"></a><span id="l14.303">     }</span>
<a href="#l14.304"></a><span id="l14.304">     this._idMap[item.id] = item;</span>
<a href="#l14.305"></a><span id="l14.305">     if (this._uniqueValueMap)</span>
<a href="#l14.306"></a><span id="l14.306">       this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l14.307"></a><span id="l14.307" class="difflineat">@@ -766,16 +756,16 @@ GlodaLRUCacheCollection.prototype.delete</span>
<a href="#l14.308"></a><span id="l14.308">  * If any of the cached items are dirty, commit them, and make them no longer</span>
<a href="#l14.309"></a><span id="l14.309">  *  dirty.</span>
<a href="#l14.310"></a><span id="l14.310">  */</span>
<a href="#l14.311"></a><span id="l14.311"> GlodaLRUCacheCollection.prototype.commitDirty = function cache_commitDirty() {</span>
<a href="#l14.312"></a><span id="l14.312">   // we can only do this if there is an update method available...</span>
<a href="#l14.313"></a><span id="l14.313">   if (!this._nounDef.objUpdate)</span>
<a href="#l14.314"></a><span id="l14.314">     return;</span>
<a href="#l14.315"></a><span id="l14.315"> </span>
<a href="#l14.316"></a><span id="l14.316" class="difflineminus">-  for each (let [iItem, item] in Iterator(this._idMap)) {</span>
<a href="#l14.317"></a><span id="l14.317" class="difflineplus">+  for (let item of this._idMap) {</span>
<a href="#l14.318"></a><span id="l14.318">     if (item.dirty) {</span>
<a href="#l14.319"></a><span id="l14.319">       LOG.debug(&quot;flushing dirty: &quot; + item);</span>
<a href="#l14.320"></a><span id="l14.320">       this._nounDef.objUpdate.call(this._nounDef.datastore, item);</span>
<a href="#l14.321"></a><span id="l14.321">       delete item.dirty;</span>
<a href="#l14.322"></a><span id="l14.322">     }</span>
<a href="#l14.323"></a><span id="l14.323">   }</span>
<a href="#l14.324"></a><span id="l14.324"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/db/gloda/modules/connotent.js</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/connotent.js</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -25,17 +25,17 @@ var LOG = Log4Moz.repository.getLogger(&quot;</span>
<a href="#l15.4"></a><span id="l15.4">  * that the Gloda content providers may have filled with useful data.</span>
<a href="#l15.5"></a><span id="l15.5">  */</span>
<a href="#l15.6"></a><span id="l15.6"> </span>
<a href="#l15.7"></a><span id="l15.7"> function mimeMsgToContentAndMeta(aMimeMsg, folder) {</span>
<a href="#l15.8"></a><span id="l15.8">   let content = new GlodaContent();</span>
<a href="#l15.9"></a><span id="l15.9">   let meta = {subject: aMimeMsg.get(&quot;subject&quot;)};</span>
<a href="#l15.10"></a><span id="l15.10">   let bodyLines = aMimeMsg.coerceBodyToPlaintext(folder).split(/\r?\n/);</span>
<a href="#l15.11"></a><span id="l15.11"> </span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-  for each (let [, whittler] in Iterator(whittlerRegistry.getWhittlers()))</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+  for (let whittler of whittlerRegistry.getWhittlers())</span>
<a href="#l15.14"></a><span id="l15.14">     whittler.contentWhittle(meta, bodyLines, content);</span>
<a href="#l15.15"></a><span id="l15.15"> </span>
<a href="#l15.16"></a><span id="l15.16">   return [content, meta];</span>
<a href="#l15.17"></a><span id="l15.17"> }</span>
<a href="#l15.18"></a><span id="l15.18"> </span>
<a href="#l15.19"></a><span id="l15.19"> </span>
<a href="#l15.20"></a><span id="l15.20"> /**</span>
<a href="#l15.21"></a><span id="l15.21">  * Given a MimeMsg, return the whittled content string, suitable for summarizing</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineat">@@ -126,33 +126,33 @@ GlodaContent.prototype = {</span>
<a href="#l15.23"></a><span id="l15.23">     let content = this.getContentString();</span>
<a href="#l15.24"></a><span id="l15.24">     if (aMaxLength)</span>
<a href="#l15.25"></a><span id="l15.25">       content = content.substring(0, aMaxLength);</span>
<a href="#l15.26"></a><span id="l15.26">     return content;</span>
<a href="#l15.27"></a><span id="l15.27">   },</span>
<a href="#l15.28"></a><span id="l15.28"> </span>
<a href="#l15.29"></a><span id="l15.29">   getContentString: function gloda_content_getContent(aIndexingPurposes) {</span>
<a href="#l15.30"></a><span id="l15.30">     let data = &quot;&quot;;</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineminus">-    for each (let [, hunk] in Iterator(this._hunks)) {</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+    for (let hunk of this._hunks) {</span>
<a href="#l15.33"></a><span id="l15.33">       if (hunk.hunkType == this.kHunkContent) {</span>
<a href="#l15.34"></a><span id="l15.34">         if (data)</span>
<a href="#l15.35"></a><span id="l15.35">           data += &quot;\n&quot; + hunk.data;</span>
<a href="#l15.36"></a><span id="l15.36">         else</span>
<a href="#l15.37"></a><span id="l15.37">           data = hunk.data;</span>
<a href="#l15.38"></a><span id="l15.38">       }</span>
<a href="#l15.39"></a><span id="l15.39">     }</span>
<a href="#l15.40"></a><span id="l15.40"> </span>
<a href="#l15.41"></a><span id="l15.41">     if (aIndexingPurposes) {</span>
<a href="#l15.42"></a><span id="l15.42">       // append the values for indexing.  we assume the keywords are cruft.</span>
<a href="#l15.43"></a><span id="l15.43">       // this may be crazy, but things that aren't a science aren't an exact</span>
<a href="#l15.44"></a><span id="l15.44">       // science.</span>
<a href="#l15.45"></a><span id="l15.45" class="difflineminus">-      for each (let [, kv] in Iterator(this._keysAndValues)) {</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineplus">+      for (let kv of this._keysAndValues) {</span>
<a href="#l15.47"></a><span id="l15.47">         data += &quot;\n&quot; + kv[1];</span>
<a href="#l15.48"></a><span id="l15.48">       }</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineminus">-      for each (let [, kon] in Iterator(this._keysAndValues)) {</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineplus">+      for (let kon of this._keysAndValues) {</span>
<a href="#l15.51"></a><span id="l15.51">         data += &quot;\n&quot; + kon[1] + &quot;\n&quot; + kon[2];</span>
<a href="#l15.52"></a><span id="l15.52">       }</span>
<a href="#l15.53"></a><span id="l15.53">     }</span>
<a href="#l15.54"></a><span id="l15.54"> </span>
<a href="#l15.55"></a><span id="l15.55">     return data;</span>
<a href="#l15.56"></a><span id="l15.56">   },</span>
<a href="#l15.57"></a><span id="l15.57"> </span>
<a href="#l15.58"></a><span id="l15.58">   /* ===== Producer API ===== */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/db/gloda/modules/databind.js</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/databind.js</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -16,17 +16,17 @@ var DBC_LOG = Log4Moz.repository.getLogg</span>
<a href="#l16.4"></a><span id="l16.4"> function GlodaDatabind(aNounDef, aDatastore) {</span>
<a href="#l16.5"></a><span id="l16.5">   this._nounDef = aNounDef;</span>
<a href="#l16.6"></a><span id="l16.6">   this._tableName = aNounDef.tableName;</span>
<a href="#l16.7"></a><span id="l16.7">   this._tableDef = aNounDef.schema;</span>
<a href="#l16.8"></a><span id="l16.8">   this._datastore = aDatastore;</span>
<a href="#l16.9"></a><span id="l16.9">   this._log = Log4Moz.repository.getLogger(&quot;gloda.databind.&quot; + this._tableName);</span>
<a href="#l16.10"></a><span id="l16.10"> </span>
<a href="#l16.11"></a><span id="l16.11">   // process the column definitions and make sure they have an attribute mapping</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-  for each (let [iColDef, coldef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+  for (let [iColDef, coldef] of this._tableDef.columns.entries()) {</span>
<a href="#l16.14"></a><span id="l16.14">     // default to the other dude's thing.</span>
<a href="#l16.15"></a><span id="l16.15">     if (coldef.length &lt; 3)</span>
<a href="#l16.16"></a><span id="l16.16">       coldef[2] = coldef[0];</span>
<a href="#l16.17"></a><span id="l16.17">     if (coldef[0] == &quot;id&quot;)</span>
<a href="#l16.18"></a><span id="l16.18">       this._idAttr = coldef[2];</span>
<a href="#l16.19"></a><span id="l16.19">     // colDef[3] is the index of us in our SQL bindings, storage-numbering</span>
<a href="#l16.20"></a><span id="l16.20">     coldef[3] = iColDef;</span>
<a href="#l16.21"></a><span id="l16.21">   }</span>
<a href="#l16.22"></a><span id="l16.22" class="difflineat">@@ -43,60 +43,69 @@ function GlodaDatabind(aNounDef, aDatast</span>
<a href="#l16.23"></a><span id="l16.23">   this._nextId = 1;</span>
<a href="#l16.24"></a><span id="l16.24">   let stmt = this._datastore._createSyncStatement(</span>
<a href="#l16.25"></a><span id="l16.25">     &quot;SELECT MAX(id) FROM &quot; + this._tableName, true);</span>
<a href="#l16.26"></a><span id="l16.26">   if (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l16.27"></a><span id="l16.27">     this._nextId = stmt.getInt64(0) + 1;</span>
<a href="#l16.28"></a><span id="l16.28">   }</span>
<a href="#l16.29"></a><span id="l16.29">   stmt.finalize();</span>
<a href="#l16.30"></a><span id="l16.30"> </span>
<a href="#l16.31"></a><span id="l16.31" class="difflineplus">+  let insertColumns = [];</span>
<a href="#l16.32"></a><span id="l16.32" class="difflineplus">+  let insertValues = [];</span>
<a href="#l16.33"></a><span id="l16.33" class="difflineplus">+  let updateItems = [];</span>
<a href="#l16.34"></a><span id="l16.34" class="difflineplus">+  for (let [iColDef, coldef] of this._tableDef.columns.entries()) {</span>
<a href="#l16.35"></a><span id="l16.35" class="difflineplus">+    let column = coldef[0];</span>
<a href="#l16.36"></a><span id="l16.36" class="difflineplus">+    let placeholder = &quot;?&quot; + (iColDef + 1);</span>
<a href="#l16.37"></a><span id="l16.37" class="difflineplus">+    insertColumns.push(column);</span>
<a href="#l16.38"></a><span id="l16.38" class="difflineplus">+    insertValues.push(placeholder);</span>
<a href="#l16.39"></a><span id="l16.39" class="difflineplus">+    if (column != &quot;id&quot;) {</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineplus">+      updateItems.push(column + &quot; = &quot; + placeholder);</span>
<a href="#l16.41"></a><span id="l16.41" class="difflineplus">+    }</span>
<a href="#l16.42"></a><span id="l16.42" class="difflineplus">+  }</span>
<a href="#l16.43"></a><span id="l16.43" class="difflineplus">+</span>
<a href="#l16.44"></a><span id="l16.44">   let insertSql = &quot;INSERT INTO &quot; + this._tableName + &quot; (&quot; +</span>
<a href="#l16.45"></a><span id="l16.45" class="difflineminus">-    [coldef[0] for each</span>
<a href="#l16.46"></a><span id="l16.46" class="difflineminus">-     ([, coldef] in Iterator(this._tableDef.columns))].join(&quot;, &quot;) +</span>
<a href="#l16.47"></a><span id="l16.47" class="difflineminus">-    &quot;) VALUES (&quot; +</span>
<a href="#l16.48"></a><span id="l16.48" class="difflineminus">-    [(&quot;?&quot; + (iColDef + 1)) for each</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineminus">-     ([iColDef, coldef] in Iterator(this._tableDef.columns))].join(&quot;, &quot;) +</span>
<a href="#l16.50"></a><span id="l16.50" class="difflineminus">-    &quot;)&quot;;</span>
<a href="#l16.51"></a><span id="l16.51" class="difflineplus">+    insertColumns.join(&quot;, &quot;) + &quot;) VALUES (&quot; + insertValues.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l16.52"></a><span id="l16.52"> </span>
<a href="#l16.53"></a><span id="l16.53">   // For the update, we want the 'id' to be a constraint and not a value</span>
<a href="#l16.54"></a><span id="l16.54">   //  that gets set...</span>
<a href="#l16.55"></a><span id="l16.55">   let updateSql = &quot;UPDATE &quot; + this._tableName + &quot; SET &quot; +</span>
<a href="#l16.56"></a><span id="l16.56" class="difflineminus">-    [(coldef[0] + &quot; = ?&quot; + (iColDef + 1)) for each</span>
<a href="#l16.57"></a><span id="l16.57" class="difflineminus">-     ([iColDef, coldef] in Iterator(this._tableDef.columns)) if</span>
<a href="#l16.58"></a><span id="l16.58" class="difflineminus">-     (coldef[0] != &quot;id&quot;)].join(&quot;, &quot;) +</span>
<a href="#l16.59"></a><span id="l16.59" class="difflineminus">-    &quot; WHERE id = ?1&quot;;</span>
<a href="#l16.60"></a><span id="l16.60" class="difflineplus">+    updateItems.join(&quot;, &quot;) + &quot; WHERE id = ?1&quot;;</span>
<a href="#l16.61"></a><span id="l16.61">   this._insertStmt = aDatastore._createAsyncStatement(insertSql);</span>
<a href="#l16.62"></a><span id="l16.62">   this._updateStmt = aDatastore._createAsyncStatement(updateSql);</span>
<a href="#l16.63"></a><span id="l16.63"> </span>
<a href="#l16.64"></a><span id="l16.64">   if (this._tableDef.fulltextColumns) {</span>
<a href="#l16.65"></a><span id="l16.65" class="difflineminus">-    for each (let [iColDef, coldef] in</span>
<a href="#l16.66"></a><span id="l16.66" class="difflineminus">-              Iterator(this._tableDef.fulltextColumns)) {</span>
<a href="#l16.67"></a><span id="l16.67" class="difflineplus">+    for (let [iColDef, coldef] of this._tableDef.fulltextColumns.entries()) {</span>
<a href="#l16.68"></a><span id="l16.68">       if (coldef.length &lt; 3)</span>
<a href="#l16.69"></a><span id="l16.69">         coldef[2] = coldef[0];</span>
<a href="#l16.70"></a><span id="l16.70">       // colDef[3] is the index of us in our SQL bindings, storage-numbering</span>
<a href="#l16.71"></a><span id="l16.71">       coldef[3] = iColDef + 1;</span>
<a href="#l16.72"></a><span id="l16.72">     }</span>
<a href="#l16.73"></a><span id="l16.73"> </span>
<a href="#l16.74"></a><span id="l16.74" class="difflineplus">+    let insertColumns = [];</span>
<a href="#l16.75"></a><span id="l16.75" class="difflineplus">+    let insertValues = [];</span>
<a href="#l16.76"></a><span id="l16.76" class="difflineplus">+    let updateItems = [];</span>
<a href="#l16.77"></a><span id="l16.77" class="difflineplus">+    for (var [iColDef, coldef] of this._tableDef.fulltextColumns.entries()) {</span>
<a href="#l16.78"></a><span id="l16.78" class="difflineplus">+      let column = coldef[0];</span>
<a href="#l16.79"></a><span id="l16.79" class="difflineplus">+      // +2 instead of +1 because docid is implied</span>
<a href="#l16.80"></a><span id="l16.80" class="difflineplus">+      let placeholder = &quot;?&quot; + (iColDef + 2);</span>
<a href="#l16.81"></a><span id="l16.81" class="difflineplus">+      insertColumns.push(column);</span>
<a href="#l16.82"></a><span id="l16.82" class="difflineplus">+      insertValues.push(placeholder);</span>
<a href="#l16.83"></a><span id="l16.83" class="difflineplus">+      if (column != &quot;id&quot;) {</span>
<a href="#l16.84"></a><span id="l16.84" class="difflineplus">+        updateItems.push(column + &quot; = &quot; + placeholder);</span>
<a href="#l16.85"></a><span id="l16.85" class="difflineplus">+      }</span>
<a href="#l16.86"></a><span id="l16.86" class="difflineplus">+    }</span>
<a href="#l16.87"></a><span id="l16.87" class="difflineplus">+</span>
<a href="#l16.88"></a><span id="l16.88">     let insertFulltextSql = &quot;INSERT INTO &quot; + this._tableName + &quot;Text (docid,&quot; +</span>
<a href="#l16.89"></a><span id="l16.89" class="difflineminus">-      [coldef[0] for each</span>
<a href="#l16.90"></a><span id="l16.90" class="difflineminus">-       ([, coldef] in Iterator(this._tableDef.fulltextColumns))].join(&quot;, &quot;) +</span>
<a href="#l16.91"></a><span id="l16.91" class="difflineminus">-      &quot;) VALUES (?1,&quot; +</span>
<a href="#l16.92"></a><span id="l16.92" class="difflineminus">-      // +2 instead of +1 because docid is implied</span>
<a href="#l16.93"></a><span id="l16.93" class="difflineminus">-      [(&quot;?&quot; + (i + 2)) for each</span>
<a href="#l16.94"></a><span id="l16.94" class="difflineminus">-       ([i, coldef] in Iterator(this._tableDef.fulltextColumns))].join(&quot;, &quot;) +</span>
<a href="#l16.95"></a><span id="l16.95" class="difflineplus">+      insertColumns.join(&quot;, &quot;) + &quot;) VALUES (?1,&quot; + insertValues.join(&quot;, &quot;) +</span>
<a href="#l16.96"></a><span id="l16.96">       &quot;)&quot;;</span>
<a href="#l16.97"></a><span id="l16.97"> </span>
<a href="#l16.98"></a><span id="l16.98">     // For the update, we want the 'id' to be a constraint and not a value</span>
<a href="#l16.99"></a><span id="l16.99">     //  that gets set...</span>
<a href="#l16.100"></a><span id="l16.100">     let updateFulltextSql = &quot;UPDATE &quot; + this._tableName + &quot;Text SET &quot; +</span>
<a href="#l16.101"></a><span id="l16.101" class="difflineminus">-      // +2 instead of +1 because docid is implied</span>
<a href="#l16.102"></a><span id="l16.102" class="difflineminus">-      [(coldef[0] + &quot;= ?&quot; + (iColDef + 2)) for each</span>
<a href="#l16.103"></a><span id="l16.103" class="difflineminus">-       ([iColDef, coldef] in Iterator(this._tableDef.fulltextColumns)) if</span>
<a href="#l16.104"></a><span id="l16.104" class="difflineminus">-       (coldef[0] != &quot;id&quot;)].join(&quot;, &quot;) +</span>
<a href="#l16.105"></a><span id="l16.105" class="difflineminus">-      &quot; WHERE docid = ?1&quot;;</span>
<a href="#l16.106"></a><span id="l16.106" class="difflineplus">+      updateItems.join(&quot;, &quot;) + &quot; WHERE docid = ?1&quot;;</span>
<a href="#l16.107"></a><span id="l16.107"> </span>
<a href="#l16.108"></a><span id="l16.108">     this._insertFulltextStmt =</span>
<a href="#l16.109"></a><span id="l16.109">       aDatastore._createAsyncStatement(insertFulltextSql);</span>
<a href="#l16.110"></a><span id="l16.110">     this._updateFulltextStmt =</span>
<a href="#l16.111"></a><span id="l16.111">       aDatastore._createAsyncStatement(updateFulltextSql);</span>
<a href="#l16.112"></a><span id="l16.112">   }</span>
<a href="#l16.113"></a><span id="l16.113"> }</span>
<a href="#l16.114"></a><span id="l16.114"> </span>
<a href="#l16.115"></a><span id="l16.115" class="difflineat">@@ -116,61 +125,59 @@ GlodaDatabind.prototype = {</span>
<a href="#l16.116"></a><span id="l16.116">       aStmt.bindStringParameter(aColDef[3], aValue);</span>
<a href="#l16.117"></a><span id="l16.117">     else</span>
<a href="#l16.118"></a><span id="l16.118">       aStmt.bindInt64Parameter(aColDef[3], aValue);</span>
<a href="#l16.119"></a><span id="l16.119">   },</span>
<a href="#l16.120"></a><span id="l16.120"> </span>
<a href="#l16.121"></a><span id="l16.121">   objFromRow: function(aRow) {</span>
<a href="#l16.122"></a><span id="l16.122">     let getVariant = this._datastore._getVariant;</span>
<a href="#l16.123"></a><span id="l16.123">     let obj = new this._nounDef.class();</span>
<a href="#l16.124"></a><span id="l16.124" class="difflineminus">-    for each (let [iCol, colDef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l16.125"></a><span id="l16.125" class="difflineplus">+    for (let [iCol, colDef] of this._tableDef.columns.entries()) {</span>
<a href="#l16.126"></a><span id="l16.126">       obj[colDef[2]] = getVariant(aRow, iCol);</span>
<a href="#l16.127"></a><span id="l16.127">     }</span>
<a href="#l16.128"></a><span id="l16.128">     return obj;</span>
<a href="#l16.129"></a><span id="l16.129">   },</span>
<a href="#l16.130"></a><span id="l16.130"> </span>
<a href="#l16.131"></a><span id="l16.131">   objInsert: function(aThing) {</span>
<a href="#l16.132"></a><span id="l16.132">     let bindByType = this.bindByType;</span>
<a href="#l16.133"></a><span id="l16.133">     if (!aThing[this._idAttr])</span>
<a href="#l16.134"></a><span id="l16.134">       aThing[this._idAttr] = this._nextId++;</span>
<a href="#l16.135"></a><span id="l16.135"> </span>
<a href="#l16.136"></a><span id="l16.136">     let stmt = this._insertStmt;</span>
<a href="#l16.137"></a><span id="l16.137" class="difflineminus">-    for each (let [iColDef, colDef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l16.138"></a><span id="l16.138" class="difflineplus">+    for (let colDef of this._tableDef.columns) {</span>
<a href="#l16.139"></a><span id="l16.139">       bindByType(stmt, colDef, aThing[colDef[2]]);</span>
<a href="#l16.140"></a><span id="l16.140">     }</span>
<a href="#l16.141"></a><span id="l16.141"> </span>
<a href="#l16.142"></a><span id="l16.142">     stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l16.143"></a><span id="l16.143"> </span>
<a href="#l16.144"></a><span id="l16.144">     if (this._insertFulltextStmt) {</span>
<a href="#l16.145"></a><span id="l16.145">       stmt = this._insertFulltextStmt;</span>
<a href="#l16.146"></a><span id="l16.146">       stmt.bindInt64Parameter(0, aThing[this._idAttr]);</span>
<a href="#l16.147"></a><span id="l16.147" class="difflineminus">-      for each (let [iColDef, colDef] in</span>
<a href="#l16.148"></a><span id="l16.148" class="difflineminus">-                Iterator(this._tableDef.fulltextColumns)) {</span>
<a href="#l16.149"></a><span id="l16.149" class="difflineplus">+      for (let colDef of this._tableDef.fulltextColumns) {</span>
<a href="#l16.150"></a><span id="l16.150">         bindByType(stmt, colDef, aThing[colDef[2]]);</span>
<a href="#l16.151"></a><span id="l16.151">       }</span>
<a href="#l16.152"></a><span id="l16.152">       stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l16.153"></a><span id="l16.153">     }</span>
<a href="#l16.154"></a><span id="l16.154">   },</span>
<a href="#l16.155"></a><span id="l16.155"> </span>
<a href="#l16.156"></a><span id="l16.156">   objUpdate: function(aThing) {</span>
<a href="#l16.157"></a><span id="l16.157">     let bindByType = this.bindByType;</span>
<a href="#l16.158"></a><span id="l16.158">     let stmt = this._updateStmt;</span>
<a href="#l16.159"></a><span id="l16.159">     // note, we specially bound the location of 'id' for the insert, but since</span>
<a href="#l16.160"></a><span id="l16.160">     //  we're using named bindings, there is nothing special about setting it</span>
<a href="#l16.161"></a><span id="l16.161" class="difflineminus">-    for each (let [iColDef, colDef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l16.162"></a><span id="l16.162" class="difflineplus">+    for (let colDef of this._tableDef.columns) {</span>
<a href="#l16.163"></a><span id="l16.163">       bindByType(stmt, colDef, aThing[colDef[2]]);</span>
<a href="#l16.164"></a><span id="l16.164">     }</span>
<a href="#l16.165"></a><span id="l16.165">     stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l16.166"></a><span id="l16.166"> </span>
<a href="#l16.167"></a><span id="l16.167">     if (this._updateFulltextStmt) {</span>
<a href="#l16.168"></a><span id="l16.168">       stmt = this._updateFulltextStmt;</span>
<a href="#l16.169"></a><span id="l16.169">       // fulltextColumns doesn't include id/docid, need to explicitly set it</span>
<a href="#l16.170"></a><span id="l16.170">       stmt.bindInt64Parameter(0, aThing[this._idAttr]);</span>
<a href="#l16.171"></a><span id="l16.171" class="difflineminus">-      for each (let [iColDef, colDef] in</span>
<a href="#l16.172"></a><span id="l16.172" class="difflineminus">-                Iterator(this._tableDef.fulltextColumns)) {</span>
<a href="#l16.173"></a><span id="l16.173" class="difflineplus">+      for (let colDef of this._tableDef.fulltextColumns) {</span>
<a href="#l16.174"></a><span id="l16.174">         bindByType(stmt, colDef, aThing[colDef[2]]);</span>
<a href="#l16.175"></a><span id="l16.175">       }</span>
<a href="#l16.176"></a><span id="l16.176">       stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l16.177"></a><span id="l16.177">     }</span>
<a href="#l16.178"></a><span id="l16.178">   },</span>
<a href="#l16.179"></a><span id="l16.179"> </span>
<a href="#l16.180"></a><span id="l16.180">   adjustAttributes: function() {</span>
<a href="#l16.181"></a><span id="l16.181">     // just proxy the call over to the datastore... we have to do this for</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -88,44 +88,45 @@ GlodaAttributeDBDef.prototype = {</span>
<a href="#l17.4"></a><span id="l17.4">    * @param {Array} aInstanceValues An array of instance values regardless of</span>
<a href="#l17.5"></a><span id="l17.5">    *     whether or not the attribute is singular.</span>
<a href="#l17.6"></a><span id="l17.6">    */</span>
<a href="#l17.7"></a><span id="l17.7">   convertValuesToDBAttributes:</span>
<a href="#l17.8"></a><span id="l17.8">       function gloda_attr_convertValuesToDBAttributes(aInstanceValues) {</span>
<a href="#l17.9"></a><span id="l17.9">     let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l17.10"></a><span id="l17.10">     let dbAttributes = [];</span>
<a href="#l17.11"></a><span id="l17.11">     if (nounDef.usesParameter) {</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-      for each (let [, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+      for (let instanceValue of aInstanceValues) {</span>
<a href="#l17.14"></a><span id="l17.14">         let [param, dbValue] = nounDef.toParamAndValue(instanceValue);</span>
<a href="#l17.15"></a><span id="l17.15">         dbAttributes.push([this.bindParameter(param), dbValue]);</span>
<a href="#l17.16"></a><span id="l17.16">       }</span>
<a href="#l17.17"></a><span id="l17.17">     }</span>
<a href="#l17.18"></a><span id="l17.18">     else {</span>
<a href="#l17.19"></a><span id="l17.19">       // Not generating any attributes is ok. This basically means the noun is</span>
<a href="#l17.20"></a><span id="l17.20">       // just an informative property on the Gloda Message and has no real</span>
<a href="#l17.21"></a><span id="l17.21">       // indexing purposes.</span>
<a href="#l17.22"></a><span id="l17.22">       if (&quot;toParamAndValue&quot; in nounDef) {</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineminus">-        for each (let [, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineplus">+        for (let instanceValue of aInstanceValues) {</span>
<a href="#l17.25"></a><span id="l17.25">           dbAttributes.push([this._id,</span>
<a href="#l17.26"></a><span id="l17.26">                              nounDef.toParamAndValue(instanceValue)[1]]);</span>
<a href="#l17.27"></a><span id="l17.27">         }</span>
<a href="#l17.28"></a><span id="l17.28">       }</span>
<a href="#l17.29"></a><span id="l17.29">     }</span>
<a href="#l17.30"></a><span id="l17.30">     return dbAttributes;</span>
<a href="#l17.31"></a><span id="l17.31">   },</span>
<a href="#l17.32"></a><span id="l17.32"> </span>
<a href="#l17.33"></a><span id="l17.33">   toString: function() {</span>
<a href="#l17.34"></a><span id="l17.34">     return this._compoundName;</span>
<a href="#l17.35"></a><span id="l17.35">   }</span>
<a href="#l17.36"></a><span id="l17.36"> };</span>
<a href="#l17.37"></a><span id="l17.37"> </span>
<a href="#l17.38"></a><span id="l17.38"> var GlodaHasAttributesMixIn = {</span>
<a href="#l17.39"></a><span id="l17.39">   enumerateAttributes: function gloda_attrix_enumerateAttributes() {</span>
<a href="#l17.40"></a><span id="l17.40">     let nounDef = this.NOUN_DEF;</span>
<a href="#l17.41"></a><span id="l17.41" class="difflineminus">-    for each (let [key, value] in Iterator(this)) {</span>
<a href="#l17.42"></a><span id="l17.42" class="difflineplus">+    for (let key in this) {</span>
<a href="#l17.43"></a><span id="l17.43" class="difflineplus">+      let value = this[key];</span>
<a href="#l17.44"></a><span id="l17.44">       let attrDef = nounDef.attribsByBoundName[key];</span>
<a href="#l17.45"></a><span id="l17.45">       // we expect to not have attributes for underscore prefixed values (those</span>
<a href="#l17.46"></a><span id="l17.46">       //  are managed by the instance's logic.  we also want to not explode</span>
<a href="#l17.47"></a><span id="l17.47">       //  should someone crap other values in there, we get both birds with this</span>
<a href="#l17.48"></a><span id="l17.48">       //  one stone.</span>
<a href="#l17.49"></a><span id="l17.49">       if (attrDef === undefined)</span>
<a href="#l17.50"></a><span id="l17.50">         continue;</span>
<a href="#l17.51"></a><span id="l17.51">       if (attrDef.singular) {</span>
<a href="#l17.52"></a><span id="l17.52" class="difflineat">@@ -138,18 +139,18 @@ var GlodaHasAttributesMixIn = {</span>
<a href="#l17.53"></a><span id="l17.53">         if (value.length)</span>
<a href="#l17.54"></a><span id="l17.54">           yield [attrDef, value];</span>
<a href="#l17.55"></a><span id="l17.55">       }</span>
<a href="#l17.56"></a><span id="l17.56">     }</span>
<a href="#l17.57"></a><span id="l17.57">   },</span>
<a href="#l17.58"></a><span id="l17.58"> </span>
<a href="#l17.59"></a><span id="l17.59">   domContribute: function gloda_attrix_domContribute(aDomNode) {</span>
<a href="#l17.60"></a><span id="l17.60">     let nounDef = this.NOUN_DEF;</span>
<a href="#l17.61"></a><span id="l17.61" class="difflineminus">-    for each (let [attrName, attr] in</span>
<a href="#l17.62"></a><span id="l17.62" class="difflineminus">-        Iterator(nounDef.domExposeAttribsByBoundName)) {</span>
<a href="#l17.63"></a><span id="l17.63" class="difflineplus">+    for (let attrName in nounDef.domExposeAttribsByBoundName) {</span>
<a href="#l17.64"></a><span id="l17.64" class="difflineplus">+      let attr = nounDef.domExposeAttribsByBoundName[attrName];</span>
<a href="#l17.65"></a><span id="l17.65">       if (this[attrName])</span>
<a href="#l17.66"></a><span id="l17.66">         aDomNode.setAttribute(attr.domExpose, this[attrName]);</span>
<a href="#l17.67"></a><span id="l17.67">     }</span>
<a href="#l17.68"></a><span id="l17.68">   },</span>
<a href="#l17.69"></a><span id="l17.69"> };</span>
<a href="#l17.70"></a><span id="l17.70"> </span>
<a href="#l17.71"></a><span id="l17.71"> function MixIn(aConstructor, aMixIn) {</span>
<a href="#l17.72"></a><span id="l17.72">   let proto = aConstructor.prototype;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -47,17 +47,17 @@ PostCommitHandler.prototype = {</span>
<a href="#l18.4"></a><span id="l18.4">   },</span>
<a href="#l18.5"></a><span id="l18.5"> </span>
<a href="#l18.6"></a><span id="l18.6">   handleCompletion: function gloda_ds_pch_handleCompletion(aReason) {</span>
<a href="#l18.7"></a><span id="l18.7">     // just outright bail if we are shutdown</span>
<a href="#l18.8"></a><span id="l18.8">     if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l18.9"></a><span id="l18.9">       return;</span>
<a href="#l18.10"></a><span id="l18.10"> </span>
<a href="#l18.11"></a><span id="l18.11">     if (aReason == Ci.mozIStorageStatementCallback.REASON_FINISHED) {</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-      for each (let [iCallback, callback] in Iterator(this.callbacks)) {</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+      for (let callback of this.callbacks) {</span>
<a href="#l18.14"></a><span id="l18.14">         try {</span>
<a href="#l18.15"></a><span id="l18.15">           callback();</span>
<a href="#l18.16"></a><span id="l18.16">         }</span>
<a href="#l18.17"></a><span id="l18.17">         catch (ex) {</span>
<a href="#l18.18"></a><span id="l18.18">           PCH_LOG.error(&quot;PostCommitHandler callback (&quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l18.19"></a><span id="l18.19">                ex.lineNumber + &quot;) threw: &quot; + ex);</span>
<a href="#l18.20"></a><span id="l18.20">         }</span>
<a href="#l18.21"></a><span id="l18.21">       }</span>
<a href="#l18.22"></a><span id="l18.22" class="difflineat">@@ -277,17 +277,18 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l18.23"></a><span id="l18.23"> </span>
<a href="#l18.24"></a><span id="l18.24">         // just outright bail if we are shutdown</span>
<a href="#l18.25"></a><span id="l18.25">         if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l18.26"></a><span id="l18.26">           return;</span>
<a href="#l18.27"></a><span id="l18.27"> </span>
<a href="#l18.28"></a><span id="l18.28">         //QFQ_LOG.debug(&quot;handleCompletion: &quot; + this.collection._nounDef.name);</span>
<a href="#l18.29"></a><span id="l18.29"> </span>
<a href="#l18.30"></a><span id="l18.30">         if (this.needsLoads) {</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineminus">-          for each (let [nounID, references] in Iterator(this.referencesByNounID)) {</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+          for (let nounID in this.referencesByNounID) {</span>
<a href="#l18.33"></a><span id="l18.33" class="difflineplus">+            let references = this.referencesByNounID[nounID];</span>
<a href="#l18.34"></a><span id="l18.34">             if (nounID == this.nounDef.id)</span>
<a href="#l18.35"></a><span id="l18.35">               continue;</span>
<a href="#l18.36"></a><span id="l18.36">             let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l18.37"></a><span id="l18.37">             //QFQ_LOG.debug(&quot;  have references for noun: &quot; + nounDef.name);</span>
<a href="#l18.38"></a><span id="l18.38">             // try and load them out of the cache/existing collections.  items in the</span>
<a href="#l18.39"></a><span id="l18.39">             //  cache will be fully formed, which is nice for us.</span>
<a href="#l18.40"></a><span id="l18.40">             // XXX this mechanism will get dubious when we have multiple paths to a</span>
<a href="#l18.41"></a><span id="l18.41">             //  single noun-type.  For example, a -&gt; b -&gt; c, a-&gt; c; two paths to c</span>
<a href="#l18.42"></a><span id="l18.42" class="difflineat">@@ -311,17 +312,18 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l18.43"></a><span id="l18.43">               let inverseReferences;</span>
<a href="#l18.44"></a><span id="l18.44">               if (nounDef.id in this.masterInverseReferencesByNounID)</span>
<a href="#l18.45"></a><span id="l18.45">                 inverseReferences =</span>
<a href="#l18.46"></a><span id="l18.46">                   this.masterInverseReferencesByNounID[nounDef.id];</span>
<a href="#l18.47"></a><span id="l18.47">               else</span>
<a href="#l18.48"></a><span id="l18.48">                 inverseReferences =</span>
<a href="#l18.49"></a><span id="l18.49">                   this.masterInverseReferencesByNounID[nounDef.id] = {};</span>
<a href="#l18.50"></a><span id="l18.50"> </span>
<a href="#l18.51"></a><span id="l18.51" class="difflineminus">-              for each (let item in outReferences) {</span>
<a href="#l18.52"></a><span id="l18.52" class="difflineplus">+              for (let key in outReferences) {</span>
<a href="#l18.53"></a><span id="l18.53" class="difflineplus">+                let item = outReferences[key];</span>
<a href="#l18.54"></a><span id="l18.54">                 masterReferences[item.id] = item;</span>
<a href="#l18.55"></a><span id="l18.55">                 let parentID = item[nounDef.parentColumnAttr.idStorageAttributeName];</span>
<a href="#l18.56"></a><span id="l18.56">                 let childrenList = inverseReferences[parentID];</span>
<a href="#l18.57"></a><span id="l18.57">                 if (childrenList === undefined)</span>
<a href="#l18.58"></a><span id="l18.58">                   childrenList = inverseReferences[parentID] = [];</span>
<a href="#l18.59"></a><span id="l18.59">                 childrenList.push(item);</span>
<a href="#l18.60"></a><span id="l18.60">               }</span>
<a href="#l18.61"></a><span id="l18.61">             }</span>
<a href="#l18.62"></a><span id="l18.62" class="difflineat">@@ -340,18 +342,18 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l18.63"></a><span id="l18.63">                   this.collection,</span>
<a href="#l18.64"></a><span id="l18.64">                   // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l18.65"></a><span id="l18.65">                   this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l18.66"></a><span id="l18.66">                   this.collection.masterCollection,</span>
<a href="#l18.67"></a><span id="l18.67">                   {becomeExplicit: true});</span>
<a href="#l18.68"></a><span id="l18.68">             }</span>
<a href="#l18.69"></a><span id="l18.69">           }</span>
<a href="#l18.70"></a><span id="l18.70"> </span>
<a href="#l18.71"></a><span id="l18.71" class="difflineminus">-          for each (let [nounID, inverseReferences] in</span>
<a href="#l18.72"></a><span id="l18.72" class="difflineminus">-              Iterator(this.inverseReferencesByNounID)) {</span>
<a href="#l18.73"></a><span id="l18.73" class="difflineplus">+          for (let nounID in this.inverseReferencesByNounID) {</span>
<a href="#l18.74"></a><span id="l18.74" class="difflineplus">+            let inverseReferences = this.inverseReferencesByNounID[nounID];</span>
<a href="#l18.75"></a><span id="l18.75">             this.collection.deferredCount++;</span>
<a href="#l18.76"></a><span id="l18.76">             let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l18.77"></a><span id="l18.77"> </span>
<a href="#l18.78"></a><span id="l18.78">             //QFQ_LOG.debug(&quot;Want to load inverse via &quot; + nounDef.parentColumnAttr.boundName);</span>
<a href="#l18.79"></a><span id="l18.79"> </span>
<a href="#l18.80"></a><span id="l18.80">             let query = new nounDef.queryClass();</span>
<a href="#l18.81"></a><span id="l18.81">             // we want to constrain using the parent column</span>
<a href="#l18.82"></a><span id="l18.82">             let queryConstrainer = query[nounDef.parentColumnAttr.boundName];</span>
<a href="#l18.83"></a><span id="l18.83" class="difflineat">@@ -1337,34 +1339,38 @@ var GlodaDatastore = {</span>
<a href="#l18.84"></a><span id="l18.84"> </span>
<a href="#l18.85"></a><span id="l18.85">     return dbConnection;</span>
<a href="#l18.86"></a><span id="l18.86">   },</span>
<a href="#l18.87"></a><span id="l18.87"> </span>
<a href="#l18.88"></a><span id="l18.88">   _createTableSchema: function gloda_ds_createTableSchema(aDBConnection,</span>
<a href="#l18.89"></a><span id="l18.89">       aTableName, aTableDef) {</span>
<a href="#l18.90"></a><span id="l18.90">     // - Create the table</span>
<a href="#l18.91"></a><span id="l18.91">     this._log.info(&quot;Creating table: &quot; + aTableName);</span>
<a href="#l18.92"></a><span id="l18.92" class="difflineminus">-    aDBConnection.createTable(aTableName,</span>
<a href="#l18.93"></a><span id="l18.93" class="difflineminus">-      [(coldef[0] + &quot; &quot; + coldef[1]) for each</span>
<a href="#l18.94"></a><span id="l18.94" class="difflineminus">-       ([i, coldef] in Iterator(aTableDef.columns))].join(&quot;, &quot;));</span>
<a href="#l18.95"></a><span id="l18.95" class="difflineplus">+    let columnDefs = [];</span>
<a href="#l18.96"></a><span id="l18.96" class="difflineplus">+    for (let [column, type] of aTableDef.columns) {</span>
<a href="#l18.97"></a><span id="l18.97" class="difflineplus">+      columnDefs.push(column + &quot; &quot; + type);</span>
<a href="#l18.98"></a><span id="l18.98" class="difflineplus">+    }</span>
<a href="#l18.99"></a><span id="l18.99" class="difflineplus">+    aDBConnection.createTable(aTableName, columnDefs.join(&quot;, &quot;));</span>
<a href="#l18.100"></a><span id="l18.100"> </span>
<a href="#l18.101"></a><span id="l18.101">     // - Create the fulltext table if applicable</span>
<a href="#l18.102"></a><span id="l18.102">     if (aTableDef.fulltextColumns) {</span>
<a href="#l18.103"></a><span id="l18.103" class="difflineplus">+      let columnDefs = [];</span>
<a href="#l18.104"></a><span id="l18.104" class="difflineplus">+      for (let [column, type] of aTableDef.fulltextColumns) {</span>
<a href="#l18.105"></a><span id="l18.105" class="difflineplus">+        columnDefs.push(column + &quot; &quot; + type);</span>
<a href="#l18.106"></a><span id="l18.106" class="difflineplus">+      }</span>
<a href="#l18.107"></a><span id="l18.107">       let createFulltextSQL = &quot;CREATE VIRTUAL TABLE &quot; + aTableName + &quot;Text&quot; +</span>
<a href="#l18.108"></a><span id="l18.108" class="difflineminus">-        &quot; USING fts3(tokenize mozporter, &quot; +</span>
<a href="#l18.109"></a><span id="l18.109" class="difflineminus">-        [(coldef[0] + &quot; &quot; + coldef[1]) for each</span>
<a href="#l18.110"></a><span id="l18.110" class="difflineminus">-         ([i, coldef] in Iterator(aTableDef.fulltextColumns))].join(&quot;, &quot;) +</span>
<a href="#l18.111"></a><span id="l18.111" class="difflineminus">-        &quot;)&quot;;</span>
<a href="#l18.112"></a><span id="l18.112" class="difflineplus">+        &quot; USING fts3(tokenize mozporter, &quot; + columnDefs.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l18.113"></a><span id="l18.113">       this._log.info(&quot;Creating fulltext table: &quot; + createFulltextSQL);</span>
<a href="#l18.114"></a><span id="l18.114">       aDBConnection.executeSimpleSQL(createFulltextSQL);</span>
<a href="#l18.115"></a><span id="l18.115">     }</span>
<a href="#l18.116"></a><span id="l18.116"> </span>
<a href="#l18.117"></a><span id="l18.117">     // - Create its indices</span>
<a href="#l18.118"></a><span id="l18.118">     if (aTableDef.indices) {</span>
<a href="#l18.119"></a><span id="l18.119" class="difflineminus">-      for each (let [indexName, indexColumns] in Iterator(aTableDef.indices)) {</span>
<a href="#l18.120"></a><span id="l18.120" class="difflineplus">+      for (let indexName in aTableDef.indices) {</span>
<a href="#l18.121"></a><span id="l18.121" class="difflineplus">+        let indexColumns = aTableDef.indices[indexName];</span>
<a href="#l18.122"></a><span id="l18.122">         aDBConnection.executeSimpleSQL(</span>
<a href="#l18.123"></a><span id="l18.123">           &quot;CREATE INDEX &quot; + indexName + &quot; ON &quot; + aTableName +</span>
<a href="#l18.124"></a><span id="l18.124">           &quot;(&quot; + indexColumns.join(&quot;, &quot;) + &quot;)&quot;);</span>
<a href="#l18.125"></a><span id="l18.125">       }</span>
<a href="#l18.126"></a><span id="l18.126">     }</span>
<a href="#l18.127"></a><span id="l18.127"> </span>
<a href="#l18.128"></a><span id="l18.128">     // - Create the attributes table if applicable</span>
<a href="#l18.129"></a><span id="l18.129">     if (aTableDef.genericAttributes) {</span>
<a href="#l18.130"></a><span id="l18.130" class="difflineat">@@ -1387,17 +1393,18 @@ var GlodaDatastore = {</span>
<a href="#l18.131"></a><span id="l18.131"> </span>
<a href="#l18.132"></a><span id="l18.132">   /**</span>
<a href="#l18.133"></a><span id="l18.133">    * Create our database schema assuming a newly created database.  This</span>
<a href="#l18.134"></a><span id="l18.134">    *  comes down to creating normal tables, their full-text variants (if</span>
<a href="#l18.135"></a><span id="l18.135">    *  applicable), and their indices.</span>
<a href="#l18.136"></a><span id="l18.136">    */</span>
<a href="#l18.137"></a><span id="l18.137">   _createSchema: function gloda_ds_createSchema(aDBConnection) {</span>
<a href="#l18.138"></a><span id="l18.138">     // -- For each table...</span>
<a href="#l18.139"></a><span id="l18.139" class="difflineminus">-    for each (let [tableName, tableDef] in Iterator(this._schema.tables)) {</span>
<a href="#l18.140"></a><span id="l18.140" class="difflineplus">+    for (let tableName in this._schema.tables) {</span>
<a href="#l18.141"></a><span id="l18.141" class="difflineplus">+      let tableDef = this._schema.tables[tableName];</span>
<a href="#l18.142"></a><span id="l18.142">       this._createTableSchema(aDBConnection, tableName, tableDef);</span>
<a href="#l18.143"></a><span id="l18.143">     }</span>
<a href="#l18.144"></a><span id="l18.144"> </span>
<a href="#l18.145"></a><span id="l18.145">     aDBConnection.schemaVersion = this._actualSchemaVersion =</span>
<a href="#l18.146"></a><span id="l18.146">       this._schemaVersion;</span>
<a href="#l18.147"></a><span id="l18.147">   },</span>
<a href="#l18.148"></a><span id="l18.148"> </span>
<a href="#l18.149"></a><span id="l18.149">   /**</span>
<a href="#l18.150"></a><span id="l18.150" class="difflineat">@@ -1577,18 +1584,17 @@ var GlodaDatastore = {</span>
<a href="#l18.151"></a><span id="l18.151">     let explainSQL = &quot;EXPLAIN &quot; + aSQLString;</span>
<a href="#l18.152"></a><span id="l18.152">     let explainStatement = this._realCreateAsyncStatement(explainSQL);</span>
<a href="#l18.153"></a><span id="l18.153"> </span>
<a href="#l18.154"></a><span id="l18.154">     return new ExplainedStatementWrapper(realStatement, explainStatement,</span>
<a href="#l18.155"></a><span id="l18.155">                                          aSQLString, this._explainProcessor);</span>
<a href="#l18.156"></a><span id="l18.156">   },</span>
<a href="#l18.157"></a><span id="l18.157"> </span>
<a href="#l18.158"></a><span id="l18.158">   _cleanupAsyncStatements: function gloda_ds_cleanupAsyncStatements() {</span>
<a href="#l18.159"></a><span id="l18.159" class="difflineminus">-    [stmt.finalize() for each</span>
<a href="#l18.160"></a><span id="l18.160" class="difflineminus">-     ([i, stmt] in Iterator(this._outstandingAsyncStatements))];</span>
<a href="#l18.161"></a><span id="l18.161" class="difflineplus">+    this._outstandingAsyncStatements.forEach(stmt =&gt; stmt.finalize());</span>
<a href="#l18.162"></a><span id="l18.162">   },</span>
<a href="#l18.163"></a><span id="l18.163"> </span>
<a href="#l18.164"></a><span id="l18.164">   _outstandingSyncStatements: [],</span>
<a href="#l18.165"></a><span id="l18.165"> </span>
<a href="#l18.166"></a><span id="l18.166">   _createSyncStatement: function gloda_ds_createSyncStatement(aSQLString,</span>
<a href="#l18.167"></a><span id="l18.167">                                                               aWillFinalize) {</span>
<a href="#l18.168"></a><span id="l18.168">     let statement = null;</span>
<a href="#l18.169"></a><span id="l18.169">     try {</span>
<a href="#l18.170"></a><span id="l18.170" class="difflineat">@@ -1602,18 +1608,17 @@ var GlodaDatastore = {</span>
<a href="#l18.171"></a><span id="l18.171"> </span>
<a href="#l18.172"></a><span id="l18.172">     if (!aWillFinalize)</span>
<a href="#l18.173"></a><span id="l18.173">       this._outstandingSyncStatements.push(statement);</span>
<a href="#l18.174"></a><span id="l18.174"> </span>
<a href="#l18.175"></a><span id="l18.175">     return statement;</span>
<a href="#l18.176"></a><span id="l18.176">   },</span>
<a href="#l18.177"></a><span id="l18.177"> </span>
<a href="#l18.178"></a><span id="l18.178">   _cleanupSyncStatements: function gloda_ds_cleanupSyncStatements() {</span>
<a href="#l18.179"></a><span id="l18.179" class="difflineminus">-    [stmt.finalize() for each</span>
<a href="#l18.180"></a><span id="l18.180" class="difflineminus">-     ([i, stmt] in Iterator(this._outstandingSyncStatements))];</span>
<a href="#l18.181"></a><span id="l18.181" class="difflineplus">+    this._outstandingSyncStatements.forEach(stmt =&gt; stmt.finalize());</span>
<a href="#l18.182"></a><span id="l18.182">   },</span>
<a href="#l18.183"></a><span id="l18.183"> </span>
<a href="#l18.184"></a><span id="l18.184">   /**</span>
<a href="#l18.185"></a><span id="l18.185">    * Perform a synchronous executeStep on the statement, handling any</span>
<a href="#l18.186"></a><span id="l18.186">    *  SQLITE_BUSY fallout that could conceivably happen from a collision on our</span>
<a href="#l18.187"></a><span id="l18.187">    *  read with the async writes.</span>
<a href="#l18.188"></a><span id="l18.188">    * Basically we keep trying until we succeed or run out of tries.</span>
<a href="#l18.189"></a><span id="l18.189">    * We believe this to be a reasonable course of action because we don't</span>
<a href="#l18.190"></a><span id="l18.190" class="difflineat">@@ -2257,17 +2262,18 @@ var GlodaDatastore = {</span>
<a href="#l18.191"></a><span id="l18.191">    *  _liveGlodaFolders, we call their forgetFolderIfUnused method each time</span>
<a href="#l18.192"></a><span id="l18.192">    *  until they return true indicating they have cleaned themselves up.</span>
<a href="#l18.193"></a><span id="l18.193">    * This method is called without a 'this' context!</span>
<a href="#l18.194"></a><span id="l18.194">    */</span>
<a href="#l18.195"></a><span id="l18.195">   _performFolderCleanup: function gloda_ds_performFolderCleanup() {</span>
<a href="#l18.196"></a><span id="l18.196">     // we only need to keep going if there is at least one folder in the table</span>
<a href="#l18.197"></a><span id="l18.197">     //  that is still alive after this pass.</span>
<a href="#l18.198"></a><span id="l18.198">     let keepGoing = false;</span>
<a href="#l18.199"></a><span id="l18.199" class="difflineminus">-    for each (let glodaFolder in GlodaDatastore._liveGlodaFolders) {</span>
<a href="#l18.200"></a><span id="l18.200" class="difflineplus">+    for (let id in GlodaDatastore._liveGlodaFolders) {</span>
<a href="#l18.201"></a><span id="l18.201" class="difflineplus">+      let glodaFolder = GlodaDatastore._liveGlodaFolders[id];</span>
<a href="#l18.202"></a><span id="l18.202">       // returns true if it is now 'dead' and doesn't need this heartbeat check</span>
<a href="#l18.203"></a><span id="l18.203">       if (glodaFolder.forgetFolderIfUnused())</span>
<a href="#l18.204"></a><span id="l18.204">         delete GlodaDatastore._liveGlodaFolders[glodaFolder.id];</span>
<a href="#l18.205"></a><span id="l18.205">       else</span>
<a href="#l18.206"></a><span id="l18.206">         keepGoing = true;</span>
<a href="#l18.207"></a><span id="l18.207">     }</span>
<a href="#l18.208"></a><span id="l18.208"> </span>
<a href="#l18.209"></a><span id="l18.209">     if (!keepGoing) {</span>
<a href="#l18.210"></a><span id="l18.210" class="difflineat">@@ -2678,17 +2684,18 @@ var GlodaDatastore = {</span>
<a href="#l18.211"></a><span id="l18.211"> </span>
<a href="#l18.212"></a><span id="l18.212">     // - perform the cache lookup so we can update in-memory representations</span>
<a href="#l18.213"></a><span id="l18.213">     // found in memory items, and converted to list form for notification</span>
<a href="#l18.214"></a><span id="l18.214">     let inMemoryItems = {}, modifiedItems = [];</span>
<a href="#l18.215"></a><span id="l18.215">     GlodaCollectionManager.cacheLookupMany(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l18.216"></a><span id="l18.216">                                            cacheLookupMap,</span>
<a href="#l18.217"></a><span id="l18.217">                                            inMemoryItems,</span>
<a href="#l18.218"></a><span id="l18.218">                                            /* do not cache */ false);</span>
<a href="#l18.219"></a><span id="l18.219" class="difflineminus">-    for each (let [glodaId, glodaMsg] in Iterator(inMemoryItems)) {</span>
<a href="#l18.220"></a><span id="l18.220" class="difflineplus">+    for (let glodaId in inMemoryItems) {</span>
<a href="#l18.221"></a><span id="l18.221" class="difflineplus">+      let glodaMsg = inMemoryItems[glodaId];</span>
<a href="#l18.222"></a><span id="l18.222">       glodaMsg._folderID = destFolderID;</span>
<a href="#l18.223"></a><span id="l18.223">       glodaMsg._messageKey = cacheLookupMap[glodaId];</span>
<a href="#l18.224"></a><span id="l18.224">       modifiedItems.push(glodaMsg);</span>
<a href="#l18.225"></a><span id="l18.225">     }</span>
<a href="#l18.226"></a><span id="l18.226"> </span>
<a href="#l18.227"></a><span id="l18.227">     // tell the collection manager about the modified messages so it can update</span>
<a href="#l18.228"></a><span id="l18.228">     //  any existing views...</span>
<a href="#l18.229"></a><span id="l18.229">     if (!aDoNotNotify &amp;&amp; modifiedItems.length) {</span>
<a href="#l18.230"></a><span id="l18.230" class="difflineat">@@ -2728,17 +2735,18 @@ var GlodaDatastore = {</span>
<a href="#l18.231"></a><span id="l18.231">     }</span>
<a href="#l18.232"></a><span id="l18.232"> </span>
<a href="#l18.233"></a><span id="l18.233">     // - perform the cache lookup so we can update in-memory representations</span>
<a href="#l18.234"></a><span id="l18.234">     let inMemoryItems = {};</span>
<a href="#l18.235"></a><span id="l18.235">     GlodaCollectionManager.cacheLookupMany(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l18.236"></a><span id="l18.236">                                            cacheLookupMap,</span>
<a href="#l18.237"></a><span id="l18.237">                                            inMemoryItems,</span>
<a href="#l18.238"></a><span id="l18.238">                                            /* do not cache */ false);</span>
<a href="#l18.239"></a><span id="l18.239" class="difflineminus">-    for each (let [glodaId, glodaMsg] in Iterator(inMemoryItems)) {</span>
<a href="#l18.240"></a><span id="l18.240" class="difflineplus">+    for (let glodaId in inMemoryItems) {</span>
<a href="#l18.241"></a><span id="l18.241" class="difflineplus">+      let glodaMsg = inMemoryItems[glodaId];</span>
<a href="#l18.242"></a><span id="l18.242">       glodaMsg._messageKey = cacheLookupMap[glodaId];</span>
<a href="#l18.243"></a><span id="l18.243">     }</span>
<a href="#l18.244"></a><span id="l18.244">   },</span>
<a href="#l18.245"></a><span id="l18.245"> </span>
<a href="#l18.246"></a><span id="l18.246">   /**</span>
<a href="#l18.247"></a><span id="l18.247">    * Asynchronously mutate message folder id/message keys for the given</span>
<a href="#l18.248"></a><span id="l18.248">    *  messages, indicating that we are moving them to the target folder, but</span>
<a href="#l18.249"></a><span id="l18.249">    *  don't yet know their target message keys.</span>
<a href="#l18.250"></a><span id="l18.250" class="difflineat">@@ -2757,17 +2765,18 @@ var GlodaDatastore = {</span>
<a href="#l18.251"></a><span id="l18.251">     statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l18.252"></a><span id="l18.252">     statement.bindNullParameter(1);</span>
<a href="#l18.253"></a><span id="l18.253">     statement.executeAsync(this.trackAsync());</span>
<a href="#l18.254"></a><span id="l18.254">     statement.finalize();</span>
<a href="#l18.255"></a><span id="l18.255"> </span>
<a href="#l18.256"></a><span id="l18.256">     let cached =</span>
<a href="#l18.257"></a><span id="l18.257">       GlodaCollectionManager.cacheLookupManyList(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l18.258"></a><span id="l18.258">                                                  aGlodaIds);</span>
<a href="#l18.259"></a><span id="l18.259" class="difflineminus">-    for each (let [, glodaMsg] in Iterator(cached)) {</span>
<a href="#l18.260"></a><span id="l18.260" class="difflineplus">+    for (let id in cached) {</span>
<a href="#l18.261"></a><span id="l18.261" class="difflineplus">+      let glodaMsg = cached[id];</span>
<a href="#l18.262"></a><span id="l18.262">       glodaMsg._folderID = destFolderID;</span>
<a href="#l18.263"></a><span id="l18.263">       glodaMsg._messageKey = null;</span>
<a href="#l18.264"></a><span id="l18.264">     }</span>
<a href="#l18.265"></a><span id="l18.265">   },</span>
<a href="#l18.266"></a><span id="l18.266"> </span>
<a href="#l18.267"></a><span id="l18.267">   _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l18.268"></a><span id="l18.268">     let folderId, messageKey, date, jsonText, subject, indexedBodyText,</span>
<a href="#l18.269"></a><span id="l18.269">         attachmentNames;</span>
<a href="#l18.270"></a><span id="l18.270" class="difflineat">@@ -3352,79 +3361,79 @@ var GlodaDatastore = {</span>
<a href="#l18.271"></a><span id="l18.271">           // SELECT * FROM blah WHERE id IN (a INTERSECT b INTERSECT c)</span>
<a href="#l18.272"></a><span id="l18.272">           //  but if we only have 'a', then that becomes &quot;...IN (a)&quot;, and if</span>
<a href="#l18.273"></a><span id="l18.273">           //  'a' is not a select but a list of id's... tricky, no?</span>
<a href="#l18.274"></a><span id="l18.274">           select = constraintValues.join(&quot;,&quot;);</span>
<a href="#l18.275"></a><span id="l18.275">         }</span>
<a href="#l18.276"></a><span id="l18.276">         // @testpoint gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l18.277"></a><span id="l18.277">         else if (constraintType === this.kConstraintIn) {</span>
<a href="#l18.278"></a><span id="l18.278">           let clauses = [];</span>
<a href="#l18.279"></a><span id="l18.279" class="difflineminus">-          for each (let [attrID, values] in</span>
<a href="#l18.280"></a><span id="l18.280" class="difflineplus">+          for (let [attrID, values] of</span>
<a href="#l18.281"></a><span id="l18.281">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l18.282"></a><span id="l18.282">                                                            constraintValues)) {</span>
<a href="#l18.283"></a><span id="l18.283">             let clausePart;</span>
<a href="#l18.284"></a><span id="l18.284">             if (attrID !== undefined)</span>
<a href="#l18.285"></a><span id="l18.285">               clausePart = &quot;(attributeID = &quot; + attrID +</span>
<a href="#l18.286"></a><span id="l18.286">                 (values.length ? &quot; AND &quot; : &quot;&quot;);</span>
<a href="#l18.287"></a><span id="l18.287">             else</span>
<a href="#l18.288"></a><span id="l18.288">               clausePart = &quot;(&quot;;</span>
<a href="#l18.289"></a><span id="l18.289">             if (values.length) {</span>
<a href="#l18.290"></a><span id="l18.290">               // strings need to be escaped, we would use ? binding, except</span>
<a href="#l18.291"></a><span id="l18.291">               //  that gets mad if we have too many strings... so we use our</span>
<a href="#l18.292"></a><span id="l18.292">               //  own escaping logic.  correctly escaping is easy, but it still</span>
<a href="#l18.293"></a><span id="l18.293">               //  feels wrong to do it. (just double the quote character...)</span>
<a href="#l18.294"></a><span id="l18.294">               if (attrDef.special == this.kSpecialString)</span>
<a href="#l18.295"></a><span id="l18.295">                 clausePart += valueColumnName + &quot; IN (&quot; +</span>
<a href="#l18.296"></a><span id="l18.296" class="difflineminus">-                  [(&quot;'&quot; + v.replace(/\'/g, &quot;''&quot;) + &quot;'&quot;) for each</span>
<a href="#l18.297"></a><span id="l18.297" class="difflineminus">-                   ([, v] in Iterator(values))].join(&quot;,&quot;) + &quot;))&quot;;</span>
<a href="#l18.298"></a><span id="l18.298" class="difflineplus">+                  values.map(v =&gt; &quot;'&quot; + v.replace(/\'/g, &quot;''&quot;) + &quot;'&quot;).</span>
<a href="#l18.299"></a><span id="l18.299" class="difflineplus">+                  join(&quot;,&quot;) + &quot;))&quot;;</span>
<a href="#l18.300"></a><span id="l18.300">               else</span>
<a href="#l18.301"></a><span id="l18.301">                 clausePart += valueColumnName + &quot; IN (&quot; + values.join(&quot;,&quot;) +</span>
<a href="#l18.302"></a><span id="l18.302">                               &quot;))&quot;;</span>
<a href="#l18.303"></a><span id="l18.303">             }</span>
<a href="#l18.304"></a><span id="l18.304">             else</span>
<a href="#l18.305"></a><span id="l18.305">               clausePart += &quot;)&quot;;</span>
<a href="#l18.306"></a><span id="l18.306">             clauses.push(clausePart);</span>
<a href="#l18.307"></a><span id="l18.307">           }</span>
<a href="#l18.308"></a><span id="l18.308">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l18.309"></a><span id="l18.309">         }</span>
<a href="#l18.310"></a><span id="l18.310">         // @testpoint gloda.datastore.sqlgen.kConstraintRanges</span>
<a href="#l18.311"></a><span id="l18.311">         else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l18.312"></a><span id="l18.312">           let clauses = [];</span>
<a href="#l18.313"></a><span id="l18.313" class="difflineminus">-          for each (let [attrID, dbStrings] in</span>
<a href="#l18.314"></a><span id="l18.314" class="difflineplus">+          for (let [attrID, dbStrings] of</span>
<a href="#l18.315"></a><span id="l18.315">               this._convertRangesToDBStringsAndGroupByAttributeID(attrDef,</span>
<a href="#l18.316"></a><span id="l18.316">                               constraintValues, valueColumnName)) {</span>
<a href="#l18.317"></a><span id="l18.317">             if (attrID !== undefined)</span>
<a href="#l18.318"></a><span id="l18.318">               clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l18.319"></a><span id="l18.319">                            &quot; AND (&quot; + dbStrings.join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l18.320"></a><span id="l18.320">             else</span>
<a href="#l18.321"></a><span id="l18.321">               clauses.push(&quot;(&quot; + dbStrings.join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l18.322"></a><span id="l18.322">           }</span>
<a href="#l18.323"></a><span id="l18.323">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l18.324"></a><span id="l18.324">         }</span>
<a href="#l18.325"></a><span id="l18.325">         // @testpoint gloda.datastore.sqlgen.kConstraintEquals</span>
<a href="#l18.326"></a><span id="l18.326">         else if (constraintType === this.kConstraintEquals) {</span>
<a href="#l18.327"></a><span id="l18.327">           let clauses = [];</span>
<a href="#l18.328"></a><span id="l18.328" class="difflineminus">-          for each (let [attrID, values] in</span>
<a href="#l18.329"></a><span id="l18.329" class="difflineplus">+          for (let [attrID, values] of</span>
<a href="#l18.330"></a><span id="l18.330">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l18.331"></a><span id="l18.331">                                                            constraintValues)) {</span>
<a href="#l18.332"></a><span id="l18.332">             if (attrID !== undefined)</span>
<a href="#l18.333"></a><span id="l18.333">               clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l18.334"></a><span id="l18.334" class="difflineminus">-                  &quot; AND (&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l18.335"></a><span id="l18.335" class="difflineminus">-                  (value in values)].join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l18.336"></a><span id="l18.336" class="difflineplus">+                  &quot; AND (&quot; + values.map(_ =&gt; valueColumnName + &quot; = ?&quot;).</span>
<a href="#l18.337"></a><span id="l18.337" class="difflineplus">+                  join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l18.338"></a><span id="l18.338">             else</span>
<a href="#l18.339"></a><span id="l18.339" class="difflineminus">-              clauses.push(&quot;(&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l18.340"></a><span id="l18.340" class="difflineminus">-                  (value in values)].join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l18.341"></a><span id="l18.341" class="difflineplus">+              clauses.push(&quot;(&quot; + values.map(_ =&gt; valueColumnName + &quot; = ?&quot;).</span>
<a href="#l18.342"></a><span id="l18.342" class="difflineplus">+                           join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l18.343"></a><span id="l18.343">             boundArgs.push.apply(boundArgs, values);</span>
<a href="#l18.344"></a><span id="l18.344">           }</span>
<a href="#l18.345"></a><span id="l18.345">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l18.346"></a><span id="l18.346">         }</span>
<a href="#l18.347"></a><span id="l18.347">         // @testpoint gloda.datastore.sqlgen.kConstraintStringLike</span>
<a href="#l18.348"></a><span id="l18.348">         else if (constraintType === this.kConstraintStringLike) {</span>
<a href="#l18.349"></a><span id="l18.349">           let likePayload = '';</span>
<a href="#l18.350"></a><span id="l18.350" class="difflineminus">-          for each (let [iValuePart, valuePart] in Iterator(constraintValues)) {</span>
<a href="#l18.351"></a><span id="l18.351" class="difflineplus">+          for (let valuePart of constraintValues) {</span>
<a href="#l18.352"></a><span id="l18.352">             if (typeof valuePart == &quot;string&quot;)</span>
<a href="#l18.353"></a><span id="l18.353">               likePayload += this._escapeLikeStatement.escapeStringForLIKE(</span>
<a href="#l18.354"></a><span id="l18.354">                 valuePart, &quot;/&quot;);</span>
<a href="#l18.355"></a><span id="l18.355">             else</span>
<a href="#l18.356"></a><span id="l18.356">               likePayload += &quot;%&quot;;</span>
<a href="#l18.357"></a><span id="l18.357">           }</span>
<a href="#l18.358"></a><span id="l18.358">           test = valueColumnName + &quot; LIKE ? ESCAPE '/'&quot;;</span>
<a href="#l18.359"></a><span id="l18.359">           boundArgs.push(likePayload);</span>
<a href="#l18.360"></a><span id="l18.360" class="difflineat">@@ -3558,17 +3567,17 @@ var GlodaDatastore = {</span>
<a href="#l18.361"></a><span id="l18.361"> </span>
<a href="#l18.362"></a><span id="l18.362">     let hadDeps = aItem._deps != null;</span>
<a href="#l18.363"></a><span id="l18.363">     let deps = aItem._deps || {};</span>
<a href="#l18.364"></a><span id="l18.364">     let hasDeps = false;</span>
<a href="#l18.365"></a><span id="l18.365"> </span>
<a href="#l18.366"></a><span id="l18.366">     //this._log.debug(&quot;  hadDeps: &quot; + hadDeps + &quot; deps: &quot; +</span>
<a href="#l18.367"></a><span id="l18.367">     //    Log4Moz.enumerateProperties(deps).join(&quot;,&quot;));</span>
<a href="#l18.368"></a><span id="l18.368"> </span>
<a href="#l18.369"></a><span id="l18.369" class="difflineminus">-    for each (let [, attrib] in Iterator(aItem.NOUN_DEF.specialLoadAttribs)) {</span>
<a href="#l18.370"></a><span id="l18.370" class="difflineplus">+    for (let attrib of aItem.NOUN_DEF.specialLoadAttribs) {</span>
<a href="#l18.371"></a><span id="l18.371">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l18.372"></a><span id="l18.372"> </span>
<a href="#l18.373"></a><span id="l18.373">       if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l18.374"></a><span id="l18.374">         let invReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l18.375"></a><span id="l18.375">         if (invReferences === undefined)</span>
<a href="#l18.376"></a><span id="l18.376">           invReferences = aInverseReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l18.377"></a><span id="l18.377">         // only contribute if it's not already pending or there</span>
<a href="#l18.378"></a><span id="l18.378">         if (!(attrib.id in deps) &amp;&amp; aItem[attrib.storageAttributeName] == null){</span>
<a href="#l18.379"></a><span id="l18.379" class="difflineat">@@ -3609,17 +3618,18 @@ var GlodaDatastore = {</span>
<a href="#l18.380"></a><span id="l18.380">       return hasDeps;</span>
<a href="#l18.381"></a><span id="l18.381">     }</span>
<a href="#l18.382"></a><span id="l18.382"> </span>
<a href="#l18.383"></a><span id="l18.383">     //this._log.debug(&quot; load json: &quot; + aItem._jsonText);</span>
<a href="#l18.384"></a><span id="l18.384">     let jsonDict = JSON.parse(aItem._jsonText);</span>
<a href="#l18.385"></a><span id="l18.385">     delete aItem._jsonText;</span>
<a href="#l18.386"></a><span id="l18.386"> </span>
<a href="#l18.387"></a><span id="l18.387">     // Iterate over the attributes on the item</span>
<a href="#l18.388"></a><span id="l18.388" class="difflineminus">-    for each (let [attribId, jsonValue] in Iterator(jsonDict)) {</span>
<a href="#l18.389"></a><span id="l18.389" class="difflineplus">+    for (let attribId in jsonDict) {</span>
<a href="#l18.390"></a><span id="l18.390" class="difflineplus">+      let jsonValue = jsonDict[attribId];</span>
<a href="#l18.391"></a><span id="l18.391">       // It is technically impossible for attribute ids to go away at this</span>
<a href="#l18.392"></a><span id="l18.392">       //  point in time.  This would require someone to monkey around with</span>
<a href="#l18.393"></a><span id="l18.393">       //  our schema.  But we will introduce this functionality one day, so</span>
<a href="#l18.394"></a><span id="l18.394">       //  prepare for it now.</span>
<a href="#l18.395"></a><span id="l18.395">       if (!(attribId in attribIDToDBDefAndParam))</span>
<a href="#l18.396"></a><span id="l18.396">         continue;</span>
<a href="#l18.397"></a><span id="l18.397">       // find the attribute definition that corresponds to this key</span>
<a href="#l18.398"></a><span id="l18.398">       let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l18.399"></a><span id="l18.399" class="difflineat">@@ -3646,17 +3656,18 @@ var GlodaDatastore = {</span>
<a href="#l18.400"></a><span id="l18.400">         if (references === undefined)</span>
<a href="#l18.401"></a><span id="l18.401">           references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l18.402"></a><span id="l18.402"> </span>
<a href="#l18.403"></a><span id="l18.403">         if (attrib.singular) {</span>
<a href="#l18.404"></a><span id="l18.404">           if (!(jsonValue in references))</span>
<a href="#l18.405"></a><span id="l18.405">             references[jsonValue] = null;</span>
<a href="#l18.406"></a><span id="l18.406">         }</span>
<a href="#l18.407"></a><span id="l18.407">         else {</span>
<a href="#l18.408"></a><span id="l18.408" class="difflineminus">-          for each (let [, anID] in Iterator(jsonValue)) {</span>
<a href="#l18.409"></a><span id="l18.409" class="difflineplus">+          for (let key in jsonValue) {</span>
<a href="#l18.410"></a><span id="l18.410" class="difflineplus">+            let anID = jsonValue[key];</span>
<a href="#l18.411"></a><span id="l18.411">             if (!(anID in references))</span>
<a href="#l18.412"></a><span id="l18.412">             references[anID] = null;</span>
<a href="#l18.413"></a><span id="l18.413">           }</span>
<a href="#l18.414"></a><span id="l18.414">         }</span>
<a href="#l18.415"></a><span id="l18.415"> </span>
<a href="#l18.416"></a><span id="l18.416">         deps[attribId] = jsonValue;</span>
<a href="#l18.417"></a><span id="l18.417">         hasDeps = true;</span>
<a href="#l18.418"></a><span id="l18.418">       }</span>
<a href="#l18.419"></a><span id="l18.419" class="difflineat">@@ -3678,17 +3689,18 @@ var GlodaDatastore = {</span>
<a href="#l18.420"></a><span id="l18.420">           let deserialized = objectNounDef.fromJSON(jsonValue, aItem);</span>
<a href="#l18.421"></a><span id="l18.421">           if (deserialized !== undefined)</span>
<a href="#l18.422"></a><span id="l18.422">             aItem[attrib.boundName] = deserialized;</span>
<a href="#l18.423"></a><span id="l18.423">         }</span>
<a href="#l18.424"></a><span id="l18.424">         else {</span>
<a href="#l18.425"></a><span id="l18.425">           // Convert all the entries in the list filtering out any undefined</span>
<a href="#l18.426"></a><span id="l18.426">           //  values. (TagNoun will do this if the tag is now dead.)</span>
<a href="#l18.427"></a><span id="l18.427">           let outList = [];</span>
<a href="#l18.428"></a><span id="l18.428" class="difflineminus">-          for each (let [, val] in Iterator(jsonValue)) {</span>
<a href="#l18.429"></a><span id="l18.429" class="difflineplus">+          for (let key in jsonValue) {</span>
<a href="#l18.430"></a><span id="l18.430" class="difflineplus">+            let val = jsonValue[key];</span>
<a href="#l18.431"></a><span id="l18.431">             let deserialized = objectNounDef.fromJSON(val, aItem);</span>
<a href="#l18.432"></a><span id="l18.432">             if (deserialized !== undefined)</span>
<a href="#l18.433"></a><span id="l18.433">               outList.push(deserialized);</span>
<a href="#l18.434"></a><span id="l18.434">           }</span>
<a href="#l18.435"></a><span id="l18.435">           // Note: It's possible if we filtered things out that this is an empty</span>
<a href="#l18.436"></a><span id="l18.436">           //  list.  This is acceptable because this is somewhat of an unusual</span>
<a href="#l18.437"></a><span id="l18.437">           //  case and I don't think we want to further complicate our</span>
<a href="#l18.438"></a><span id="l18.438">           //  semantics.</span>
<a href="#l18.439"></a><span id="l18.439" class="difflineat">@@ -3737,18 +3749,18 @@ var GlodaDatastore = {</span>
<a href="#l18.440"></a><span id="l18.440">         }</span>
<a href="#l18.441"></a><span id="l18.441">       }</span>
<a href="#l18.442"></a><span id="l18.442">       else if (objectNounDef.tableName) {</span>
<a href="#l18.443"></a><span id="l18.443">         //this._log.info(&quot;trying to load: &quot; + objectNounDef.id + &quot; refs: &quot; +</span>
<a href="#l18.444"></a><span id="l18.444">         //    jsonValue + &quot;: &quot; + Log4Moz.enumerateProperties(jsonValue).join(&quot;,&quot;));</span>
<a href="#l18.445"></a><span id="l18.445">         if (attrib.singular)</span>
<a href="#l18.446"></a><span id="l18.446">           aItem[attrib.boundName] = references[jsonValue];</span>
<a href="#l18.447"></a><span id="l18.447">         else</span>
<a href="#l18.448"></a><span id="l18.448" class="difflineminus">-          aItem[attrib.boundName] = [references[val] for each</span>
<a href="#l18.449"></a><span id="l18.449" class="difflineminus">-                                     ([, val] in Iterator(jsonValue))];</span>
<a href="#l18.450"></a><span id="l18.450" class="difflineplus">+          aItem[attrib.boundName] = Object.keys(jsonValue).</span>
<a href="#l18.451"></a><span id="l18.451" class="difflineplus">+            map(key =&gt; references[jsonValue[key]]);</span>
<a href="#l18.452"></a><span id="l18.452">       }</span>
<a href="#l18.453"></a><span id="l18.453">       else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l18.454"></a><span id="l18.454">         aItem[attrib.boundName] =</span>
<a href="#l18.455"></a><span id="l18.455">           objectNounDef.resolveObjDependencies(jsonValue, aReferencesByNounID,</span>
<a href="#l18.456"></a><span id="l18.456">             aInverseReferencesByNounID);</span>
<a href="#l18.457"></a><span id="l18.457">       }</span>
<a href="#l18.458"></a><span id="l18.458">       // there is no other case</span>
<a href="#l18.459"></a><span id="l18.459">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/db/gloda/modules/dbview.js</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/dbview.js</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -82,29 +82,29 @@ GlodaSyntheticView.prototype = {</span>
<a href="#l19.4"></a><span id="l19.4">       this.searchListener.onSearchDone(Cr.NS_OK);</span>
<a href="#l19.5"></a><span id="l19.5">     if (this.completionCallback)</span>
<a href="#l19.6"></a><span id="l19.6">       this.completionCallback();</span>
<a href="#l19.7"></a><span id="l19.7">     this.searchListener = null;</span>
<a href="#l19.8"></a><span id="l19.8">     this.completionCallback = null;</span>
<a href="#l19.9"></a><span id="l19.9">   },</span>
<a href="#l19.10"></a><span id="l19.10"> </span>
<a href="#l19.11"></a><span id="l19.11">   reportResults: function(aItems) {</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l19.14"></a><span id="l19.14">       let hdr = item.folderMessage;</span>
<a href="#l19.15"></a><span id="l19.15">       if (hdr)</span>
<a href="#l19.16"></a><span id="l19.16">         this.searchListener.onSearchHit(hdr, hdr.folder);</span>
<a href="#l19.17"></a><span id="l19.17">     }</span>
<a href="#l19.18"></a><span id="l19.18">   },</span>
<a href="#l19.19"></a><span id="l19.19"> </span>
<a href="#l19.20"></a><span id="l19.20">   /**</span>
<a href="#l19.21"></a><span id="l19.21">    * Helper function used by |DBViewWrapper.getMsgHdrForMessageID| since there</span>
<a href="#l19.22"></a><span id="l19.22">    *  are no actual backing folders for it to check.</span>
<a href="#l19.23"></a><span id="l19.23">    */</span>
<a href="#l19.24"></a><span id="l19.24">   getMsgHdrForMessageID: function(aMessageId) {</span>
<a href="#l19.25"></a><span id="l19.25" class="difflineminus">-    for each (let [, item] in Iterator(this.collection.items)) {</span>
<a href="#l19.26"></a><span id="l19.26" class="difflineplus">+    for (let item of this.collection.items) {</span>
<a href="#l19.27"></a><span id="l19.27">       if (item.headerMessageID == aMessageId) {</span>
<a href="#l19.28"></a><span id="l19.28">         let hdr = item.folderMessage;</span>
<a href="#l19.29"></a><span id="l19.29">         if (hdr)</span>
<a href="#l19.30"></a><span id="l19.30">           return hdr;</span>
<a href="#l19.31"></a><span id="l19.31">       }</span>
<a href="#l19.32"></a><span id="l19.32">     }</span>
<a href="#l19.33"></a><span id="l19.33">     return null;</span>
<a href="#l19.34"></a><span id="l19.34">   },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/db/gloda/modules/facet.js</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/facet.js</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -52,25 +52,26 @@ FacetDriver.prototype = {</span>
<a href="#l20.4"></a><span id="l20.4">       else {</span>
<a href="#l20.5"></a><span id="l20.5">         if (facetType == &quot;nonempty?&quot;)</span>
<a href="#l20.6"></a><span id="l20.6">           faceters.push(new NonEmptySetFaceter(aAttrDef, aFacetDef));</span>
<a href="#l20.7"></a><span id="l20.7">         else</span>
<a href="#l20.8"></a><span id="l20.8">           faceters.push(new DiscreteSetFaceter(aAttrDef, aFacetDef));</span>
<a href="#l20.9"></a><span id="l20.9">       }</span>
<a href="#l20.10"></a><span id="l20.10">     }</span>
<a href="#l20.11"></a><span id="l20.11"> </span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-    for each (let [, attrDef] in Iterator(this.nounDef.attribsByBoundName)) {</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+    for (let key in this.nounDef.attribsByBoundName) {</span>
<a href="#l20.14"></a><span id="l20.14" class="difflineplus">+      let attrDef = this.nounDef.attribsByBoundName[key];</span>
<a href="#l20.15"></a><span id="l20.15">       // ignore attributes that do not want to be faceted</span>
<a href="#l20.16"></a><span id="l20.16">       if (!attrDef.facet)</span>
<a href="#l20.17"></a><span id="l20.17">         continue;</span>
<a href="#l20.18"></a><span id="l20.18"> </span>
<a href="#l20.19"></a><span id="l20.19">       makeFaceter(attrDef, attrDef.facet);</span>
<a href="#l20.20"></a><span id="l20.20"> </span>
<a href="#l20.21"></a><span id="l20.21">       if (&quot;extraFacets&quot; in attrDef) {</span>
<a href="#l20.22"></a><span id="l20.22" class="difflineminus">-        for each (let [, facetDef] in Iterator(attrDef.extraFacets)) {</span>
<a href="#l20.23"></a><span id="l20.23" class="difflineplus">+        for (let facetDef of attrDef.extraFacets) {</span>
<a href="#l20.24"></a><span id="l20.24">           makeFaceter(attrDef, facetDef);</span>
<a href="#l20.25"></a><span id="l20.25">         }</span>
<a href="#l20.26"></a><span id="l20.26">       }</span>
<a href="#l20.27"></a><span id="l20.27">     }</span>
<a href="#l20.28"></a><span id="l20.28">   },</span>
<a href="#l20.29"></a><span id="l20.29">   /**</span>
<a href="#l20.30"></a><span id="l20.30">    * Asynchronously facet the provided items, calling the provided callback when</span>
<a href="#l20.31"></a><span id="l20.31">    *  completed.</span>
<a href="#l20.32"></a><span id="l20.32" class="difflineat">@@ -176,17 +177,17 @@ DiscreteFaceter.prototype = {</span>
<a href="#l20.33"></a><span id="l20.33">     let attrKey = this.attrDef.boundName;</span>
<a href="#l20.34"></a><span id="l20.34">     let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l20.35"></a><span id="l20.35">     let filter = this.facetDef.filter;</span>
<a href="#l20.36"></a><span id="l20.36"> </span>
<a href="#l20.37"></a><span id="l20.37">     let valStrToVal = {};</span>
<a href="#l20.38"></a><span id="l20.38">     let groups = this.groups = {};</span>
<a href="#l20.39"></a><span id="l20.39">     this.groupCount = 0;</span>
<a href="#l20.40"></a><span id="l20.40"> </span>
<a href="#l20.41"></a><span id="l20.41" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l20.42"></a><span id="l20.42" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l20.43"></a><span id="l20.43">       let val = (attrKey in item) ? item[attrKey] : null;</span>
<a href="#l20.44"></a><span id="l20.44">       if (val === Gloda.IGNORE_FACET)</span>
<a href="#l20.45"></a><span id="l20.45">         continue;</span>
<a href="#l20.46"></a><span id="l20.46"> </span>
<a href="#l20.47"></a><span id="l20.47">       // skip items the filter tells us to ignore</span>
<a href="#l20.48"></a><span id="l20.48">       if (filter &amp;&amp; !filter(val))</span>
<a href="#l20.49"></a><span id="l20.49">         continue;</span>
<a href="#l20.50"></a><span id="l20.50"> </span>
<a href="#l20.51"></a><span id="l20.51" class="difflineat">@@ -196,18 +197,18 @@ DiscreteFaceter.prototype = {</span>
<a href="#l20.52"></a><span id="l20.52">         groups[val].push(item);</span>
<a href="#l20.53"></a><span id="l20.53">       else {</span>
<a href="#l20.54"></a><span id="l20.54">         groups[val] = [item];</span>
<a href="#l20.55"></a><span id="l20.55">         valStrToVal[val] = val;</span>
<a href="#l20.56"></a><span id="l20.56">         this.groupCount++;</span>
<a href="#l20.57"></a><span id="l20.57">       }</span>
<a href="#l20.58"></a><span id="l20.58">     }</span>
<a href="#l20.59"></a><span id="l20.59"> </span>
<a href="#l20.60"></a><span id="l20.60" class="difflineminus">-    let orderedGroups = [[valStrToVal[key], items] for each</span>
<a href="#l20.61"></a><span id="l20.61" class="difflineminus">-                         ([key, items] in Iterator(groups))];</span>
<a href="#l20.62"></a><span id="l20.62" class="difflineplus">+    let orderedGroups = Object.keys(groups).</span>
<a href="#l20.63"></a><span id="l20.63" class="difflineplus">+      map(key =&gt; [valStrToVal[key], groups[key]]);</span>
<a href="#l20.64"></a><span id="l20.64">     let comparator = this.facetDef.groupComparator;</span>
<a href="#l20.65"></a><span id="l20.65">     function comparatorHelper(a, b) {</span>
<a href="#l20.66"></a><span id="l20.66">       return comparator(a[0], b[0]);</span>
<a href="#l20.67"></a><span id="l20.67">     }</span>
<a href="#l20.68"></a><span id="l20.68">     orderedGroups.sort(comparatorHelper);</span>
<a href="#l20.69"></a><span id="l20.69">     this.orderedGroups = orderedGroups;</span>
<a href="#l20.70"></a><span id="l20.70">   },</span>
<a href="#l20.71"></a><span id="l20.71">   /**</span>
<a href="#l20.72"></a><span id="l20.72" class="difflineat">@@ -220,17 +221,17 @@ DiscreteFaceter.prototype = {</span>
<a href="#l20.73"></a><span id="l20.73">     let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l20.74"></a><span id="l20.74">     let filter = this.facetDef.filter;</span>
<a href="#l20.75"></a><span id="l20.75">     let idAttr = this.facetDef.groupIdAttr;</span>
<a href="#l20.76"></a><span id="l20.76"> </span>
<a href="#l20.77"></a><span id="l20.77">     let groups = this.groups = {};</span>
<a href="#l20.78"></a><span id="l20.78">     let groupMap = this.groupMap = {};</span>
<a href="#l20.79"></a><span id="l20.79">     this.groupCount = 0;</span>
<a href="#l20.80"></a><span id="l20.80"> </span>
<a href="#l20.81"></a><span id="l20.81" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l20.82"></a><span id="l20.82" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l20.83"></a><span id="l20.83">       let val = (attrKey in item) ? item[attrKey] : null;</span>
<a href="#l20.84"></a><span id="l20.84">       if (val === Gloda.IGNORE_FACET)</span>
<a href="#l20.85"></a><span id="l20.85">         continue;</span>
<a href="#l20.86"></a><span id="l20.86"> </span>
<a href="#l20.87"></a><span id="l20.87">       // skip items the filter tells us to ignore</span>
<a href="#l20.88"></a><span id="l20.88">       if (filter &amp;&amp; !filter(val))</span>
<a href="#l20.89"></a><span id="l20.89">         continue;</span>
<a href="#l20.90"></a><span id="l20.90"> </span>
<a href="#l20.91"></a><span id="l20.91" class="difflineat">@@ -244,18 +245,18 @@ DiscreteFaceter.prototype = {</span>
<a href="#l20.92"></a><span id="l20.92">       }</span>
<a href="#l20.93"></a><span id="l20.93">       else {</span>
<a href="#l20.94"></a><span id="l20.94">         groupMap[valId] = val;</span>
<a href="#l20.95"></a><span id="l20.95">         groups[valId] = [item];</span>
<a href="#l20.96"></a><span id="l20.96">         this.groupCount++;</span>
<a href="#l20.97"></a><span id="l20.97">       }</span>
<a href="#l20.98"></a><span id="l20.98">     }</span>
<a href="#l20.99"></a><span id="l20.99"> </span>
<a href="#l20.100"></a><span id="l20.100" class="difflineminus">-    let orderedGroups = [[groupMap[key], items] for each</span>
<a href="#l20.101"></a><span id="l20.101" class="difflineminus">-                         ([key, items] in Iterator(groups))];</span>
<a href="#l20.102"></a><span id="l20.102" class="difflineplus">+    let orderedGroups = Object.keys(groups).</span>
<a href="#l20.103"></a><span id="l20.103" class="difflineplus">+      map(key =&gt; [groupMap[key], groups[key]]);</span>
<a href="#l20.104"></a><span id="l20.104">     let comparator = this.facetDef.groupComparator;</span>
<a href="#l20.105"></a><span id="l20.105">     function comparatorHelper(a, b) {</span>
<a href="#l20.106"></a><span id="l20.106">       return comparator(a[0], b[0]);</span>
<a href="#l20.107"></a><span id="l20.107">     }</span>
<a href="#l20.108"></a><span id="l20.108">     orderedGroups.sort(comparatorHelper);</span>
<a href="#l20.109"></a><span id="l20.109">     this.orderedGroups = orderedGroups;</span>
<a href="#l20.110"></a><span id="l20.110">   },</span>
<a href="#l20.111"></a><span id="l20.111"> };</span>
<a href="#l20.112"></a><span id="l20.112" class="difflineat">@@ -291,25 +292,25 @@ DiscreteSetFaceter.prototype = {</span>
<a href="#l20.113"></a><span id="l20.113">     let attrKey = this.attrDef.boundName;</span>
<a href="#l20.114"></a><span id="l20.114">     let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l20.115"></a><span id="l20.115">     let filter = this.facetDef.filter;</span>
<a href="#l20.116"></a><span id="l20.116"> </span>
<a href="#l20.117"></a><span id="l20.117">     let groups = this.groups = {};</span>
<a href="#l20.118"></a><span id="l20.118">     let valStrToVal = {};</span>
<a href="#l20.119"></a><span id="l20.119">     this.groupCount = 0;</span>
<a href="#l20.120"></a><span id="l20.120"> </span>
<a href="#l20.121"></a><span id="l20.121" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l20.122"></a><span id="l20.122" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l20.123"></a><span id="l20.123">       let vals = (attrKey in item) ? item[attrKey] : null;</span>
<a href="#l20.124"></a><span id="l20.124">       if (vals === Gloda.IGNORE_FACET)</span>
<a href="#l20.125"></a><span id="l20.125">         continue;</span>
<a href="#l20.126"></a><span id="l20.126"> </span>
<a href="#l20.127"></a><span id="l20.127">       if (vals == null || vals.length == 0) {</span>
<a href="#l20.128"></a><span id="l20.128">         vals = [null];</span>
<a href="#l20.129"></a><span id="l20.129">       }</span>
<a href="#l20.130"></a><span id="l20.130" class="difflineminus">-      for each (let [, val] in Iterator(vals)) {</span>
<a href="#l20.131"></a><span id="l20.131" class="difflineplus">+      for (let val of vals) {</span>
<a href="#l20.132"></a><span id="l20.132">         // skip items the filter tells us to ignore</span>
<a href="#l20.133"></a><span id="l20.133">         if (filter &amp;&amp; !filter(val))</span>
<a href="#l20.134"></a><span id="l20.134">           continue;</span>
<a href="#l20.135"></a><span id="l20.135"> </span>
<a href="#l20.136"></a><span id="l20.136">         // We need to use hasOwnProperty because we cannot guarantee that the</span>
<a href="#l20.137"></a><span id="l20.137">         //  contents of val won't collide with the attributes in</span>
<a href="#l20.138"></a><span id="l20.138">         //  Object.prototype.</span>
<a href="#l20.139"></a><span id="l20.139">         if (groups.hasOwnProperty(val))</span>
<a href="#l20.140"></a><span id="l20.140" class="difflineat">@@ -317,18 +318,18 @@ DiscreteSetFaceter.prototype = {</span>
<a href="#l20.141"></a><span id="l20.141">         else {</span>
<a href="#l20.142"></a><span id="l20.142">           groups[val] = [item];</span>
<a href="#l20.143"></a><span id="l20.143">           valStrToVal[val] = val;</span>
<a href="#l20.144"></a><span id="l20.144">           this.groupCount++;</span>
<a href="#l20.145"></a><span id="l20.145">         }</span>
<a href="#l20.146"></a><span id="l20.146">       }</span>
<a href="#l20.147"></a><span id="l20.147">     }</span>
<a href="#l20.148"></a><span id="l20.148"> </span>
<a href="#l20.149"></a><span id="l20.149" class="difflineminus">-    let orderedGroups = [[valStrToVal[key], items] for each</span>
<a href="#l20.150"></a><span id="l20.150" class="difflineminus">-                         ([key, items] in Iterator(groups))];</span>
<a href="#l20.151"></a><span id="l20.151" class="difflineplus">+    let orderedGroups = Object.keys(groups).</span>
<a href="#l20.152"></a><span id="l20.152" class="difflineplus">+      map(key =&gt; [valStrToVal[key], groups[key]]);</span>
<a href="#l20.153"></a><span id="l20.153">     let comparator = this.facetDef.groupComparator;</span>
<a href="#l20.154"></a><span id="l20.154">     function comparatorHelper(a, b) {</span>
<a href="#l20.155"></a><span id="l20.155">       return comparator(a[0], b[0]);</span>
<a href="#l20.156"></a><span id="l20.156">     }</span>
<a href="#l20.157"></a><span id="l20.157">     orderedGroups.sort(comparatorHelper);</span>
<a href="#l20.158"></a><span id="l20.158">     this.orderedGroups = orderedGroups;</span>
<a href="#l20.159"></a><span id="l20.159">   },</span>
<a href="#l20.160"></a><span id="l20.160">   /**</span>
<a href="#l20.161"></a><span id="l20.161" class="difflineat">@@ -341,25 +342,25 @@ DiscreteSetFaceter.prototype = {</span>
<a href="#l20.162"></a><span id="l20.162">     let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l20.163"></a><span id="l20.163">     let filter = this.facetDef.filter;</span>
<a href="#l20.164"></a><span id="l20.164">     let idAttr = this.facetDef.groupIdAttr;</span>
<a href="#l20.165"></a><span id="l20.165"> </span>
<a href="#l20.166"></a><span id="l20.166">     let groups = this.groups = {};</span>
<a href="#l20.167"></a><span id="l20.167">     let groupMap = this.groupMap = {};</span>
<a href="#l20.168"></a><span id="l20.168">     this.groupCount = 0;</span>
<a href="#l20.169"></a><span id="l20.169"> </span>
<a href="#l20.170"></a><span id="l20.170" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l20.171"></a><span id="l20.171" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l20.172"></a><span id="l20.172">       let vals = (attrKey in item) ? item[attrKey] : null;</span>
<a href="#l20.173"></a><span id="l20.173">       if (vals === Gloda.IGNORE_FACET)</span>
<a href="#l20.174"></a><span id="l20.174">         continue;</span>
<a href="#l20.175"></a><span id="l20.175"> </span>
<a href="#l20.176"></a><span id="l20.176">       if (vals == null || vals.length == 0) {</span>
<a href="#l20.177"></a><span id="l20.177">         vals = [null];</span>
<a href="#l20.178"></a><span id="l20.178">       }</span>
<a href="#l20.179"></a><span id="l20.179" class="difflineminus">-      for each (let [, val] in Iterator(vals)) {</span>
<a href="#l20.180"></a><span id="l20.180" class="difflineplus">+      for (let val of vals) {</span>
<a href="#l20.181"></a><span id="l20.181">         // skip items the filter tells us to ignore</span>
<a href="#l20.182"></a><span id="l20.182">         if (filter &amp;&amp; !filter(val))</span>
<a href="#l20.183"></a><span id="l20.183">           continue;</span>
<a href="#l20.184"></a><span id="l20.184"> </span>
<a href="#l20.185"></a><span id="l20.185">         let valId = (val == null) ? null : val[idAttr];</span>
<a href="#l20.186"></a><span id="l20.186">         // We need to use hasOwnProperty because tag nouns are complex objects</span>
<a href="#l20.187"></a><span id="l20.187">         //  with id's that are non-numeric and so can collide with the contents</span>
<a href="#l20.188"></a><span id="l20.188">         //  of Object.prototype.</span>
<a href="#l20.189"></a><span id="l20.189" class="difflineat">@@ -369,18 +370,18 @@ DiscreteSetFaceter.prototype = {</span>
<a href="#l20.190"></a><span id="l20.190">         else {</span>
<a href="#l20.191"></a><span id="l20.191">           groupMap[valId] = val;</span>
<a href="#l20.192"></a><span id="l20.192">           groups[valId] = [item];</span>
<a href="#l20.193"></a><span id="l20.193">           this.groupCount++;</span>
<a href="#l20.194"></a><span id="l20.194">         }</span>
<a href="#l20.195"></a><span id="l20.195">       }</span>
<a href="#l20.196"></a><span id="l20.196">     }</span>
<a href="#l20.197"></a><span id="l20.197"> </span>
<a href="#l20.198"></a><span id="l20.198" class="difflineminus">-    let orderedGroups = [[groupMap[key], items] for each</span>
<a href="#l20.199"></a><span id="l20.199" class="difflineminus">-                         ([key, items] in Iterator(groups))];</span>
<a href="#l20.200"></a><span id="l20.200" class="difflineplus">+    let orderedGroups = Object.keys(groups).</span>
<a href="#l20.201"></a><span id="l20.201" class="difflineplus">+      map(key =&gt; [groupMap[key], groups[key]]);</span>
<a href="#l20.202"></a><span id="l20.202">     let comparator = this.facetDef.groupComparator;</span>
<a href="#l20.203"></a><span id="l20.203">     function comparatorHelper(a, b) {</span>
<a href="#l20.204"></a><span id="l20.204">       return comparator(a[0], b[0]);</span>
<a href="#l20.205"></a><span id="l20.205">     }</span>
<a href="#l20.206"></a><span id="l20.206">     orderedGroups.sort(comparatorHelper);</span>
<a href="#l20.207"></a><span id="l20.207">     this.orderedGroups = orderedGroups;</span>
<a href="#l20.208"></a><span id="l20.208">   },</span>
<a href="#l20.209"></a><span id="l20.209"> };</span>
<a href="#l20.210"></a><span id="l20.210" class="difflineat">@@ -403,17 +404,17 @@ NonEmptySetFaceter.prototype = {</span>
<a href="#l20.211"></a><span id="l20.211">     let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l20.212"></a><span id="l20.212"> </span>
<a href="#l20.213"></a><span id="l20.213">     let trueValues = [];</span>
<a href="#l20.214"></a><span id="l20.214">     let falseValues = [];</span>
<a href="#l20.215"></a><span id="l20.215"> </span>
<a href="#l20.216"></a><span id="l20.216">     let groups = this.groups = {};</span>
<a href="#l20.217"></a><span id="l20.217">     this.groupCount = 0;</span>
<a href="#l20.218"></a><span id="l20.218"> </span>
<a href="#l20.219"></a><span id="l20.219" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l20.220"></a><span id="l20.220" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l20.221"></a><span id="l20.221">       let vals = (attrKey in item) ? item[attrKey] : null;</span>
<a href="#l20.222"></a><span id="l20.222">       if (vals == null || vals.length == 0)</span>
<a href="#l20.223"></a><span id="l20.223">         falseValues.push(item);</span>
<a href="#l20.224"></a><span id="l20.224">       else</span>
<a href="#l20.225"></a><span id="l20.225">         trueValues.push(item);</span>
<a href="#l20.226"></a><span id="l20.226">     }</span>
<a href="#l20.227"></a><span id="l20.227"> </span>
<a href="#l20.228"></a><span id="l20.228">     this.orderedGroups = [];</span>
<a href="#l20.229"></a><span id="l20.229" class="difflineat">@@ -485,17 +486,17 @@ DateFaceter.prototype = {</span>
<a href="#l20.230"></a><span id="l20.230">      *  these unreasonable messages.</span>
<a href="#l20.231"></a><span id="l20.231">      */</span>
<a href="#l20.232"></a><span id="l20.232">     this.unreasonable = 0;</span>
<a href="#l20.233"></a><span id="l20.233">     // feb 1, 1970</span>
<a href="#l20.234"></a><span id="l20.234">     let tooOld = new Date(1970, 1, 1);</span>
<a href="#l20.235"></a><span id="l20.235">     // 3 days from now</span>
<a href="#l20.236"></a><span id="l20.236">     let tooNew = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000);</span>
<a href="#l20.237"></a><span id="l20.237"> </span>
<a href="#l20.238"></a><span id="l20.238" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l20.239"></a><span id="l20.239" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l20.240"></a><span id="l20.240">       let val = (attrKey in item) ? item[attrKey] : null;</span>
<a href="#l20.241"></a><span id="l20.241">       // -- missing</span>
<a href="#l20.242"></a><span id="l20.242">       if (val == null) {</span>
<a href="#l20.243"></a><span id="l20.243">         this.missing++;</span>
<a href="#l20.244"></a><span id="l20.244">         continue;</span>
<a href="#l20.245"></a><span id="l20.245">       }</span>
<a href="#l20.246"></a><span id="l20.246"> </span>
<a href="#l20.247"></a><span id="l20.247">       // -- unreasonable</span>
<a href="#l20.248"></a><span id="l20.248" class="difflineat">@@ -554,26 +555,28 @@ DateFaceter.prototype = {</span>
<a href="#l20.249"></a><span id="l20.249">     }</span>
<a href="#l20.250"></a><span id="l20.250"> </span>
<a href="#l20.251"></a><span id="l20.251">     this.oldest = oldest;</span>
<a href="#l20.252"></a><span id="l20.252">     this.newest = newest;</span>
<a href="#l20.253"></a><span id="l20.253">   },</span>
<a href="#l20.254"></a><span id="l20.254"> </span>
<a href="#l20.255"></a><span id="l20.255">   _unionMonth: function(aMonthObj) {</span>
<a href="#l20.256"></a><span id="l20.256">     let dayItemLists = [];</span>
<a href="#l20.257"></a><span id="l20.257" class="difflineminus">-    for each (let [key, dayItemList] in Iterator(aMonthObj)) {</span>
<a href="#l20.258"></a><span id="l20.258" class="difflineplus">+    for (let key in aMonthObj) {</span>
<a href="#l20.259"></a><span id="l20.259" class="difflineplus">+      let dayItemList = aMonthObj[key];</span>
<a href="#l20.260"></a><span id="l20.260">       if (typeof(key) == &quot;string&quot; &amp;&amp; key.startsWith('_'))</span>
<a href="#l20.261"></a><span id="l20.261">         continue;</span>
<a href="#l20.262"></a><span id="l20.262">       dayItemLists.push(dayItemList);</span>
<a href="#l20.263"></a><span id="l20.263">     }</span>
<a href="#l20.264"></a><span id="l20.264">     return Array.concat.apply([], dayItemLists);</span>
<a href="#l20.265"></a><span id="l20.265">   },</span>
<a href="#l20.266"></a><span id="l20.266"> </span>
<a href="#l20.267"></a><span id="l20.267">   _unionYear: function(aYearObj) {</span>
<a href="#l20.268"></a><span id="l20.268">     let monthItemLists = [];</span>
<a href="#l20.269"></a><span id="l20.269" class="difflineminus">-    for each (let [key, monthObj] in Iterator(aYearObj)) {</span>
<a href="#l20.270"></a><span id="l20.270" class="difflineplus">+    for (let key in aYearObj) {</span>
<a href="#l20.271"></a><span id="l20.271" class="difflineplus">+      let monthObj = aYearObj[key];</span>
<a href="#l20.272"></a><span id="l20.272">       if (typeof(key) == &quot;string&quot; &amp;&amp; key.startsWith('_'))</span>
<a href="#l20.273"></a><span id="l20.273">         continue;</span>
<a href="#l20.274"></a><span id="l20.274">       monthItemLists.push(this._unionMonth(monthObj));</span>
<a href="#l20.275"></a><span id="l20.275">     }</span>
<a href="#l20.276"></a><span id="l20.276">     return Array.concat.apply([], monthItemLists);</span>
<a href="#l20.277"></a><span id="l20.277">   }</span>
<a href="#l20.278"></a><span id="l20.278"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -534,17 +534,17 @@ var GlodaFundAttr = {</span>
<a href="#l21.4"></a><span id="l21.4">     if (aMimeMsg) {</span>
<a href="#l21.5"></a><span id="l21.5">       // nsParseMailbox.cpp puts the attachment flag on msgHdrs as soon as it</span>
<a href="#l21.6"></a><span id="l21.6">       // finds a multipart/mixed part. This is a good heuristic, but if it turns</span>
<a href="#l21.7"></a><span id="l21.7">       // out the part has no filename, then we don't treat it as an attachment.</span>
<a href="#l21.8"></a><span id="l21.8">       // We just streamed the message, and we have all the information to figure</span>
<a href="#l21.9"></a><span id="l21.9">       // that out, so now is a good place to clear the flag if needed.</span>
<a href="#l21.10"></a><span id="l21.10">       let foundRealAttachment = false;</span>
<a href="#l21.11"></a><span id="l21.11">       let attachmentTypes = [];</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-      for each (let [, attachment] in Iterator(aMimeMsg.allAttachments)) {</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+      for (let attachment of aMimeMsg.allAttachments) {</span>
<a href="#l21.14"></a><span id="l21.14">         // We don't care about would-be attachments that are not user-intended</span>
<a href="#l21.15"></a><span id="l21.15">         //  attachments but rather artifacts of the message content.</span>
<a href="#l21.16"></a><span id="l21.16">         // We also want to avoid dealing with obviously bogus mime types.</span>
<a href="#l21.17"></a><span id="l21.17">         //  (If you don't have a &quot;/&quot;, you are probably bogus.)</span>
<a href="#l21.18"></a><span id="l21.18">         if (attachment.isRealAttachment &amp;&amp;</span>
<a href="#l21.19"></a><span id="l21.19">             attachment.contentType.includes(&quot;/&quot;)) {</span>
<a href="#l21.20"></a><span id="l21.20">           attachmentTypes.push(MimeTypeNoun.getMimeType(attachment.contentType));</span>
<a href="#l21.21"></a><span id="l21.21">         }</span>
<a href="#l21.22"></a><span id="l21.22" class="difflineat">@@ -568,17 +568,17 @@ var GlodaFundAttr = {</span>
<a href="#l21.23"></a><span id="l21.23">         aMsgHdr.markHasAttachments(false);</span>
<a href="#l21.24"></a><span id="l21.24"> </span>
<a href="#l21.25"></a><span id="l21.25">       // This is not the same kind of attachments as above. Now, we want to</span>
<a href="#l21.26"></a><span id="l21.26">       // provide convenience attributes to Gloda consumers, so that they can run</span>
<a href="#l21.27"></a><span id="l21.27">       // through the list of attachments of a given message, to possibly build a</span>
<a href="#l21.28"></a><span id="l21.28">       // visualization on top of it. We still reject bogus mime types, which</span>
<a href="#l21.29"></a><span id="l21.29">       // means yencode won't be supported. Oh, I feel really bad.</span>
<a href="#l21.30"></a><span id="l21.30">       let attachmentInfos = [];</span>
<a href="#l21.31"></a><span id="l21.31" class="difflineminus">-      for each (let [, att] in Iterator(aMimeMsg.allUserAttachments)) {</span>
<a href="#l21.32"></a><span id="l21.32" class="difflineplus">+      for (let att of aMimeMsg.allUserAttachments) {</span>
<a href="#l21.33"></a><span id="l21.33">         attachmentInfos.push(this.glodaAttFromMimeAtt(aRawReps.trueGlodaRep,</span>
<a href="#l21.34"></a><span id="l21.34">                                                       att));</span>
<a href="#l21.35"></a><span id="l21.35">       }</span>
<a href="#l21.36"></a><span id="l21.36">       aGlodaMessage.attachmentInfos = attachmentInfos;</span>
<a href="#l21.37"></a><span id="l21.37">     }</span>
<a href="#l21.38"></a><span id="l21.38"> </span>
<a href="#l21.39"></a><span id="l21.39">     // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l21.40"></a><span id="l21.40">     //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l21.41"></a><span id="l21.41" class="difflineat">@@ -650,17 +650,17 @@ var GlodaFundAttr = {</span>
<a href="#l21.42"></a><span id="l21.42">       }</span>
<a href="#l21.43"></a><span id="l21.43">     }</span>
<a href="#l21.44"></a><span id="l21.44"> </span>
<a href="#l21.45"></a><span id="l21.45">     involves.push(authorIdentity);</span>
<a href="#l21.46"></a><span id="l21.46">     involvesIdentities[authorIdentity.id] = true;</span>
<a href="#l21.47"></a><span id="l21.47"> </span>
<a href="#l21.48"></a><span id="l21.48">     let involvedAddrBookCount = 0;</span>
<a href="#l21.49"></a><span id="l21.49"> </span>
<a href="#l21.50"></a><span id="l21.50" class="difflineminus">-    for each (let [,toIdentity] in Iterator(aGlodaMessage.to)) {</span>
<a href="#l21.51"></a><span id="l21.51" class="difflineplus">+    for (let toIdentity of aGlodaMessage.to) {</span>
<a href="#l21.52"></a><span id="l21.52">       if (!(toIdentity.id in involvesIdentities)) {</span>
<a href="#l21.53"></a><span id="l21.53">         involves.push(toIdentity);</span>
<a href="#l21.54"></a><span id="l21.54">         recipients.push(toIdentity);</span>
<a href="#l21.55"></a><span id="l21.55">         involvesIdentities[toIdentity.id] = true;</span>
<a href="#l21.56"></a><span id="l21.56">         let toCard = toIdentity.abCard;</span>
<a href="#l21.57"></a><span id="l21.57">         if (toCard) {</span>
<a href="#l21.58"></a><span id="l21.58">           involvedAddrBookCount++;</span>
<a href="#l21.59"></a><span id="l21.59">           // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l21.60"></a><span id="l21.60" class="difflineat">@@ -677,17 +677,17 @@ var GlodaFundAttr = {</span>
<a href="#l21.61"></a><span id="l21.61">       // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l21.62"></a><span id="l21.62">       if (isFromMe) {</span>
<a href="#l21.63"></a><span id="l21.63">         fromMe.push([authorIdentity, toIdentity]);</span>
<a href="#l21.64"></a><span id="l21.64">         // also, popularity</span>
<a href="#l21.65"></a><span id="l21.65">         if (aIsNew)</span>
<a href="#l21.66"></a><span id="l21.66">           toIdentity.contact.popularity += this.POPULARITY_FROM_ME_TO;</span>
<a href="#l21.67"></a><span id="l21.67">       }</span>
<a href="#l21.68"></a><span id="l21.68">     }</span>
<a href="#l21.69"></a><span id="l21.69" class="difflineminus">-    for each (let [,ccIdentity] in Iterator(aGlodaMessage.cc)) {</span>
<a href="#l21.70"></a><span id="l21.70" class="difflineplus">+    for (let ccIdentity of aGlodaMessage.cc) {</span>
<a href="#l21.71"></a><span id="l21.71">       if (!(ccIdentity.id in involvesIdentities)) {</span>
<a href="#l21.72"></a><span id="l21.72">         involves.push(ccIdentity);</span>
<a href="#l21.73"></a><span id="l21.73">         recipients.push(ccIdentity);</span>
<a href="#l21.74"></a><span id="l21.74">         involvesIdentities[ccIdentity.id] = true;</span>
<a href="#l21.75"></a><span id="l21.75">         let ccCard = ccIdentity.abCard;</span>
<a href="#l21.76"></a><span id="l21.76">         if (ccCard) {</span>
<a href="#l21.77"></a><span id="l21.77">           involvedAddrBookCount++;</span>
<a href="#l21.78"></a><span id="l21.78">           // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l21.79"></a><span id="l21.79" class="difflineat">@@ -705,17 +705,17 @@ var GlodaFundAttr = {</span>
<a href="#l21.80"></a><span id="l21.80">         fromMe.push([authorIdentity, ccIdentity]);</span>
<a href="#l21.81"></a><span id="l21.81">         // also, popularity</span>
<a href="#l21.82"></a><span id="l21.82">         if (aIsNew)</span>
<a href="#l21.83"></a><span id="l21.83">           ccIdentity.contact.popularity += this.POPULARITY_FROM_ME_CC;</span>
<a href="#l21.84"></a><span id="l21.84">       }</span>
<a href="#l21.85"></a><span id="l21.85">     }</span>
<a href="#l21.86"></a><span id="l21.86">     // just treat bcc like cc; the intent is the same although the exact</span>
<a href="#l21.87"></a><span id="l21.87">     //  semantics differ.</span>
<a href="#l21.88"></a><span id="l21.88" class="difflineminus">-    for each (let [,bccIdentity] in Iterator(aGlodaMessage.bcc)) {</span>
<a href="#l21.89"></a><span id="l21.89" class="difflineplus">+    for (let bccIdentity of aGlodaMessage.bcc) {</span>
<a href="#l21.90"></a><span id="l21.90">       if (!(bccIdentity.id in involvesIdentities)) {</span>
<a href="#l21.91"></a><span id="l21.91">         involves.push(bccIdentity);</span>
<a href="#l21.92"></a><span id="l21.92">         recipients.push(bccIdentity);</span>
<a href="#l21.93"></a><span id="l21.93">         involvesIdentities[bccIdentity.id] = true;</span>
<a href="#l21.94"></a><span id="l21.94">         let bccCard = bccIdentity.abCard;</span>
<a href="#l21.95"></a><span id="l21.95">         if (bccCard) {</span>
<a href="#l21.96"></a><span id="l21.96">           involvedAddrBookCount++;</span>
<a href="#l21.97"></a><span id="l21.97">           // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l21.98"></a><span id="l21.98" class="difflineat">@@ -835,17 +835,17 @@ var GlodaFundAttr = {</span>
<a href="#l21.99"></a><span id="l21.99">     //  quoted and un-quoted text.  (We keep blank lines within the same</span>
<a href="#l21.100"></a><span id="l21.100">     //  'block' of quoted or non-quoted text.)</span>
<a href="#l21.101"></a><span id="l21.101">     // Because we now have two goals for it, and we still want to suppress blank</span>
<a href="#l21.102"></a><span id="l21.102">     //  lines when there is a 'wrote' line involved, we introduce...</span>
<a href="#l21.103"></a><span id="l21.103">     //  prevLastNonBlankLine!  This arguably suggests refactoring should be the</span>
<a href="#l21.104"></a><span id="l21.104">     //  next step, but things work for now.</span>
<a href="#l21.105"></a><span id="l21.105">     let rangeStart = 0, lastNonBlankLine = null, prevLastNonBlankLine = null;</span>
<a href="#l21.106"></a><span id="l21.106">     let inQuoteDepth = 0;</span>
<a href="#l21.107"></a><span id="l21.107" class="difflineminus">-    for each (let [iLine, line] in Iterator(bodyLines)) {</span>
<a href="#l21.108"></a><span id="l21.108" class="difflineplus">+    for (let [iLine, line] of bodyLines.entries()) {</span>
<a href="#l21.109"></a><span id="l21.109">       if (!line || (line == &quot;\xa0&quot;)) /* unicode non breaking space */</span>
<a href="#l21.110"></a><span id="l21.110">         continue;</span>
<a href="#l21.111"></a><span id="l21.111"> </span>
<a href="#l21.112"></a><span id="l21.112">       if (line.startsWith(&quot;&gt;&quot;)) {</span>
<a href="#l21.113"></a><span id="l21.113">         if (!inQuoteDepth) {</span>
<a href="#l21.114"></a><span id="l21.114">           let rangeEnd = iLine - 1;</span>
<a href="#l21.115"></a><span id="l21.115">           let quoteRangeStart = iLine;</span>
<a href="#l21.116"></a><span id="l21.116">           // see if the last non-blank-line was a lead-in...</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -319,26 +319,27 @@ var Gloda = {</span>
<a href="#l22.4"></a><span id="l22.4">         headersByFolder[folderURI] = [header];</span>
<a href="#l22.5"></a><span id="l22.5">       else</span>
<a href="#l22.6"></a><span id="l22.6">         headersForFolder.push(header);</span>
<a href="#l22.7"></a><span id="l22.7">     }</span>
<a href="#l22.8"></a><span id="l22.8"> </span>
<a href="#l22.9"></a><span id="l22.9">     let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l22.10"></a><span id="l22.10">     let clause;</span>
<a href="#l22.11"></a><span id="l22.11">     // build a query, using a separate union clause for each folder.</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-    for each (let [folderURI, headersForFolder] in Iterator(headersByFolder)) {</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+    for (let folderURI in headersByFolder) {</span>
<a href="#l22.14"></a><span id="l22.14" class="difflineplus">+      let headersForFolder = headersByFolder[folderURI];</span>
<a href="#l22.15"></a><span id="l22.15">       let folder = this.getFolderForFolder(headersForFolder[0].folder);</span>
<a href="#l22.16"></a><span id="l22.16">       // if this is the first or clause, just use the query itself</span>
<a href="#l22.17"></a><span id="l22.17">       if (!clause)</span>
<a href="#l22.18"></a><span id="l22.18">         clause = query;</span>
<a href="#l22.19"></a><span id="l22.19">       else // create a new query clause via the 'or' command</span>
<a href="#l22.20"></a><span id="l22.20">         clause = query.or();</span>
<a href="#l22.21"></a><span id="l22.21"> </span>
<a href="#l22.22"></a><span id="l22.22">       clause.folder(folder);</span>
<a href="#l22.23"></a><span id="l22.23" class="difflineminus">-      let messageKeys = [hdr.messageKey for each (hdr in headersForFolder)];</span>
<a href="#l22.24"></a><span id="l22.24" class="difflineplus">+      let messageKeys = headersForFolder.map(hdr =&gt; hdr.messageKey);</span>
<a href="#l22.25"></a><span id="l22.25">       clause.messageKey.apply(clause, messageKeys);</span>
<a href="#l22.26"></a><span id="l22.26">     }</span>
<a href="#l22.27"></a><span id="l22.27"> </span>
<a href="#l22.28"></a><span id="l22.28">     return query.getCollection(aListener, aData);</span>
<a href="#l22.29"></a><span id="l22.29">   },</span>
<a href="#l22.30"></a><span id="l22.30"> </span>
<a href="#l22.31"></a><span id="l22.31">   /**</span>
<a href="#l22.32"></a><span id="l22.32">    * @testpoint gloda.ns.getMessageContent</span>
<a href="#l22.33"></a><span id="l22.33" class="difflineat">@@ -411,29 +412,30 @@ var Gloda = {</span>
<a href="#l22.34"></a><span id="l22.34"> </span>
<a href="#l22.35"></a><span id="l22.35">     let query = this.newQuery(this.NOUN_IDENTITY);</span>
<a href="#l22.36"></a><span id="l22.36">     query.kind(&quot;email&quot;);</span>
<a href="#l22.37"></a><span id="l22.37">     query.value.apply(query, addressList);</span>
<a href="#l22.38"></a><span id="l22.38">     let collection = query.getCollection(aCallbackHandle);</span>
<a href="#l22.39"></a><span id="l22.39">     yield this.kWorkAsync;</span>
<a href="#l22.40"></a><span id="l22.40"> </span>
<a href="#l22.41"></a><span id="l22.41">     // put the identities in the appropriate result lists</span>
<a href="#l22.42"></a><span id="l22.42" class="difflineminus">-    for each (let [, identity] in Iterator(collection.items)) {</span>
<a href="#l22.43"></a><span id="l22.43" class="difflineplus">+    for (let identity of collection.items) {</span>
<a href="#l22.44"></a><span id="l22.44">       let nameAndResultLists = addresses[identity.value];</span>
<a href="#l22.45"></a><span id="l22.45">       this._log.debug(&quot; found identity for '&quot; + nameAndResultLists[0] + &quot;' (&quot; +</span>
<a href="#l22.46"></a><span id="l22.46">                       identity.value + &quot;)&quot;);</span>
<a href="#l22.47"></a><span id="l22.47">       // index 0 is the name, skip it</span>
<a href="#l22.48"></a><span id="l22.48">       for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++) {</span>
<a href="#l22.49"></a><span id="l22.49">         nameAndResultLists[iResList].push(identity);</span>
<a href="#l22.50"></a><span id="l22.50">       }</span>
<a href="#l22.51"></a><span id="l22.51">       delete addresses[identity.value];</span>
<a href="#l22.52"></a><span id="l22.52">     }</span>
<a href="#l22.53"></a><span id="l22.53"> </span>
<a href="#l22.54"></a><span id="l22.54">     // create the identities that did not exist yet</span>
<a href="#l22.55"></a><span id="l22.55" class="difflineminus">-    for each (let [address, nameAndResultLists] in Iterator(addresses)) {</span>
<a href="#l22.56"></a><span id="l22.56" class="difflineplus">+    for (let address in addresses) {</span>
<a href="#l22.57"></a><span id="l22.57" class="difflineplus">+      let nameAndResultLists = addresses[address];</span>
<a href="#l22.58"></a><span id="l22.58">       let name = nameAndResultLists[0];</span>
<a href="#l22.59"></a><span id="l22.59"> </span>
<a href="#l22.60"></a><span id="l22.60">       this._log.debug(&quot; creating contact for '&quot; + name + &quot;' (&quot; + address + &quot;)&quot;);</span>
<a href="#l22.61"></a><span id="l22.61"> </span>
<a href="#l22.62"></a><span id="l22.62">       // try and find an existing address book contact.</span>
<a href="#l22.63"></a><span id="l22.63">       let card = GlodaUtils.getCardForEmail(address);</span>
<a href="#l22.64"></a><span id="l22.64">       // XXX when we have the address book GUID stuff, we need to use that to</span>
<a href="#l22.65"></a><span id="l22.65">       //  find existing contacts... (this will introduce a new query phase</span>
<a href="#l22.66"></a><span id="l22.66" class="difflineat">@@ -554,17 +556,17 @@ var Gloda = {</span>
<a href="#l22.67"></a><span id="l22.67">           else</span>
<a href="#l22.68"></a><span id="l22.68">             identitiesToCreate.push(parsed.addresses[0]);</span>
<a href="#l22.69"></a><span id="l22.69">           myEmailAddresses[parsed.addresses[0]] = true;</span>
<a href="#l22.70"></a><span id="l22.70">         }</span>
<a href="#l22.71"></a><span id="l22.71">       }</span>
<a href="#l22.72"></a><span id="l22.72">     }</span>
<a href="#l22.73"></a><span id="l22.73"> </span>
<a href="#l22.74"></a><span id="l22.74">     // we need to establish the identity.contact portions of the relationship</span>
<a href="#l22.75"></a><span id="l22.75" class="difflineminus">-    for each (let [,identity] in Iterator(existingIdentities)) {</span>
<a href="#l22.76"></a><span id="l22.76" class="difflineplus">+    for (let identity of existingIdentities) {</span>
<a href="#l22.77"></a><span id="l22.77">       identity._contact = GlodaDatastore.getContactByID(identity.contactID);</span>
<a href="#l22.78"></a><span id="l22.78">     }</span>
<a href="#l22.79"></a><span id="l22.79"> </span>
<a href="#l22.80"></a><span id="l22.80">     if (existingIdentities.length) {</span>
<a href="#l22.81"></a><span id="l22.81">       // just use the first guy's contact</span>
<a href="#l22.82"></a><span id="l22.82">       myContact = existingIdentities[0].contact;</span>
<a href="#l22.83"></a><span id="l22.83">     }</span>
<a href="#l22.84"></a><span id="l22.84">     else {</span>
<a href="#l22.85"></a><span id="l22.85" class="difflineat">@@ -593,17 +595,18 @@ var Gloda = {</span>
<a href="#l22.86"></a><span id="l22.86">     for (let iIdentity = 0; iIdentity &lt; existingIdentities.length;</span>
<a href="#l22.87"></a><span id="l22.87">         iIdentity++) {</span>
<a href="#l22.88"></a><span id="l22.88">       let identity = existingIdentities[iIdentity];</span>
<a href="#l22.89"></a><span id="l22.89">       myIdentities[identity.id] = identity;</span>
<a href="#l22.90"></a><span id="l22.90">     }</span>
<a href="#l22.91"></a><span id="l22.91"> </span>
<a href="#l22.92"></a><span id="l22.92">     this.myContact = myContact;</span>
<a href="#l22.93"></a><span id="l22.93">     this.myIdentities = myIdentities;</span>
<a href="#l22.94"></a><span id="l22.94" class="difflineminus">-    myContact._identities = [identity for each (identity in myIdentities)];</span>
<a href="#l22.95"></a><span id="l22.95" class="difflineplus">+    myContact._identities = Object.keys(myIdentities).</span>
<a href="#l22.96"></a><span id="l22.96" class="difflineplus">+      map(id =&gt; myIdentities[id]);</span>
<a href="#l22.97"></a><span id="l22.97"> </span>
<a href="#l22.98"></a><span id="l22.98">     // we need contacts to make these objects reachable via the collection</span>
<a href="#l22.99"></a><span id="l22.99">     //  manager.</span>
<a href="#l22.100"></a><span id="l22.100">     this._myContactCollection = this.explicitCollection(this.NOUN_CONTACT,</span>
<a href="#l22.101"></a><span id="l22.101">                                                         [this.myContact]);</span>
<a href="#l22.102"></a><span id="l22.102">     this._myIdentitiesCollection =</span>
<a href="#l22.103"></a><span id="l22.103">       this.explicitCollection(this.NOUN_IDENTITY, this.myContact._identities);</span>
<a href="#l22.104"></a><span id="l22.104">   },</span>
<a href="#l22.105"></a><span id="l22.105" class="difflineat">@@ -1024,18 +1027,18 @@ var Gloda = {</span>
<a href="#l22.106"></a><span id="l22.106">   /**</span>
<a href="#l22.107"></a><span id="l22.107">    * Retrieve all of the actions (as defined using defineNounAction) for the</span>
<a href="#l22.108"></a><span id="l22.108">    *  given noun type (via noun ID) with the given action type (ex: filter).</span>
<a href="#l22.109"></a><span id="l22.109">    */</span>
<a href="#l22.110"></a><span id="l22.110">   getNounActions: function gloda_ns_getNounActions(aNounID, aActionType) {</span>
<a href="#l22.111"></a><span id="l22.111">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l22.112"></a><span id="l22.112">     if (!nounDef)</span>
<a href="#l22.113"></a><span id="l22.113">       return [];</span>
<a href="#l22.114"></a><span id="l22.114" class="difflineminus">-    return [action for each ([i, action] in Iterator(nounDef.actions))</span>
<a href="#l22.115"></a><span id="l22.115" class="difflineminus">-            if (!aActionType || (action.actionType == aActionType))];</span>
<a href="#l22.116"></a><span id="l22.116" class="difflineplus">+    return nounDef.actions.</span>
<a href="#l22.117"></a><span id="l22.117" class="difflineplus">+      filter(action =&gt; !aActionType || (action.actionType == aActionType));</span>
<a href="#l22.118"></a><span id="l22.118">   },</span>
<a href="#l22.119"></a><span id="l22.119"> </span>
<a href="#l22.120"></a><span id="l22.120">   /** Attribute providers in the sequence to process them. */</span>
<a href="#l22.121"></a><span id="l22.121">   _attrProviderOrderByNoun: {},</span>
<a href="#l22.122"></a><span id="l22.122">   /** Attribute providers that provide optimizers, in the sequence to proc. */</span>
<a href="#l22.123"></a><span id="l22.123">   _attrOptimizerOrderByNoun: {},</span>
<a href="#l22.124"></a><span id="l22.124">   /** Maps attribute providers to the list of attributes they provide */</span>
<a href="#l22.125"></a><span id="l22.125">   _attrProviders: {},</span>
<a href="#l22.126"></a><span id="l22.126" class="difflineat">@@ -1413,35 +1416,36 @@ var Gloda = {</span>
<a href="#l22.127"></a><span id="l22.127">         if (fic)</span>
<a href="#l22.128"></a><span id="l22.128">           return fic;</span>
<a href="#l22.129"></a><span id="l22.129">         // Next compare the second identity in the tuple, but use the contact</span>
<a href="#l22.130"></a><span id="l22.130">         //  this time to be consistent with our identity comparator.</span>
<a href="#l22.131"></a><span id="l22.131">         return a[1].contact.name.localeCompare(b[1].contact.name);</span>
<a href="#l22.132"></a><span id="l22.132">       },</span>
<a href="#l22.133"></a><span id="l22.133">       computeDelta: function(aCurValues, aOldValues) {</span>
<a href="#l22.134"></a><span id="l22.134">         let oldMap = {};</span>
<a href="#l22.135"></a><span id="l22.135" class="difflineminus">-        for each (let [, tupe] in Iterator(aOldValues)) {</span>
<a href="#l22.136"></a><span id="l22.136" class="difflineplus">+        for (let tupe of aOldValues) {</span>
<a href="#l22.137"></a><span id="l22.137">           let [originIdentity, targetIdentity] = tupe;</span>
<a href="#l22.138"></a><span id="l22.138">           let targets = oldMap[originIdentity];</span>
<a href="#l22.139"></a><span id="l22.139">           if (targets === undefined)</span>
<a href="#l22.140"></a><span id="l22.140">             targets = oldMap[originIdentity] = {};</span>
<a href="#l22.141"></a><span id="l22.141">           targets[targetIdentity] = true;</span>
<a href="#l22.142"></a><span id="l22.142">         }</span>
<a href="#l22.143"></a><span id="l22.143"> </span>
<a href="#l22.144"></a><span id="l22.144">         let added = [], removed = [];</span>
<a href="#l22.145"></a><span id="l22.145" class="difflineminus">-        for each (let [, tupe] in Iterator(aCurValues)) {</span>
<a href="#l22.146"></a><span id="l22.146" class="difflineplus">+        for (let tupe of aCurValues) {</span>
<a href="#l22.147"></a><span id="l22.147">           let [originIdentity, targetIdentity] = tupe;</span>
<a href="#l22.148"></a><span id="l22.148">           let targets = oldMap[originIdentity];</span>
<a href="#l22.149"></a><span id="l22.149">           if ((targets === undefined) || !(targetIdentity in targets))</span>
<a href="#l22.150"></a><span id="l22.150">             added.push(tupe);</span>
<a href="#l22.151"></a><span id="l22.151">           else</span>
<a href="#l22.152"></a><span id="l22.152">             delete targets[targetIdentity];</span>
<a href="#l22.153"></a><span id="l22.153">         }</span>
<a href="#l22.154"></a><span id="l22.154"> </span>
<a href="#l22.155"></a><span id="l22.155" class="difflineminus">-        for each (let [originIdentity, targets] in Iterator(oldMap)) {</span>
<a href="#l22.156"></a><span id="l22.156" class="difflineplus">+        for (let originIdentity in oldMap) {</span>
<a href="#l22.157"></a><span id="l22.157" class="difflineplus">+          let targets = oldMap[originIdentity];</span>
<a href="#l22.158"></a><span id="l22.158">           for (let targetIdentity in targets) {</span>
<a href="#l22.159"></a><span id="l22.159">             removed.push([originIdentity, targetIdentity]);</span>
<a href="#l22.160"></a><span id="l22.160">           }</span>
<a href="#l22.161"></a><span id="l22.161">         }</span>
<a href="#l22.162"></a><span id="l22.162"> </span>
<a href="#l22.163"></a><span id="l22.163">         return [added, removed];</span>
<a href="#l22.164"></a><span id="l22.164">       },</span>
<a href="#l22.165"></a><span id="l22.165">       contributeObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l22.166"></a><span id="l22.166" class="difflineat">@@ -1450,33 +1454,33 @@ var Gloda = {</span>
<a href="#l22.167"></a><span id="l22.167">         if (aJsonValues.length == 0)</span>
<a href="#l22.168"></a><span id="l22.168">           return false;</span>
<a href="#l22.169"></a><span id="l22.169"> </span>
<a href="#l22.170"></a><span id="l22.170">         let nounIdentityDef = Gloda._nounIDToDef[Gloda.NOUN_IDENTITY];</span>
<a href="#l22.171"></a><span id="l22.171">         let references = aReferencesByNounID[nounIdentityDef.id];</span>
<a href="#l22.172"></a><span id="l22.172">         if (references === undefined)</span>
<a href="#l22.173"></a><span id="l22.173">           references = aReferencesByNounID[nounIdentityDef.id] = {};</span>
<a href="#l22.174"></a><span id="l22.174"> </span>
<a href="#l22.175"></a><span id="l22.175" class="difflineminus">-        for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l22.176"></a><span id="l22.176" class="difflineplus">+        for (let tupe of aJsonValues) {</span>
<a href="#l22.177"></a><span id="l22.177">           let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l22.178"></a><span id="l22.178">           if (!(originIdentityID in references))</span>
<a href="#l22.179"></a><span id="l22.179">             references[originIdentityID] = null;</span>
<a href="#l22.180"></a><span id="l22.180">           if (!(targetIdentityID in references))</span>
<a href="#l22.181"></a><span id="l22.181">             references[targetIdentityID] = null;</span>
<a href="#l22.182"></a><span id="l22.182">         }</span>
<a href="#l22.183"></a><span id="l22.183"> </span>
<a href="#l22.184"></a><span id="l22.184">         return true;</span>
<a href="#l22.185"></a><span id="l22.185">       },</span>
<a href="#l22.186"></a><span id="l22.186">       resolveObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l22.187"></a><span id="l22.187">           aInverseReferencesByNounID) {</span>
<a href="#l22.188"></a><span id="l22.188">         let references =</span>
<a href="#l22.189"></a><span id="l22.189">           aReferencesByNounID[Gloda.NOUN_IDENTITY];</span>
<a href="#l22.190"></a><span id="l22.190"> </span>
<a href="#l22.191"></a><span id="l22.191">         let results = [];</span>
<a href="#l22.192"></a><span id="l22.192" class="difflineminus">-        for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l22.193"></a><span id="l22.193" class="difflineplus">+        for (let tupe of aJsonValues) {</span>
<a href="#l22.194"></a><span id="l22.194">           let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l22.195"></a><span id="l22.195">           results.push([references[originIdentityID],</span>
<a href="#l22.196"></a><span id="l22.196">                         references[targetIdentityID]]);</span>
<a href="#l22.197"></a><span id="l22.197">         }</span>
<a href="#l22.198"></a><span id="l22.198"> </span>
<a href="#l22.199"></a><span id="l22.199">         return results;</span>
<a href="#l22.200"></a><span id="l22.200">       },</span>
<a href="#l22.201"></a><span id="l22.201">       toJSON: function (aIdentityTuple) {</span>
<a href="#l22.202"></a><span id="l22.202" class="difflineat">@@ -1573,17 +1577,18 @@ var Gloda = {</span>
<a href="#l22.203"></a><span id="l22.203">         };</span>
<a href="#l22.204"></a><span id="l22.204"> </span>
<a href="#l22.205"></a><span id="l22.205">         aSubjectNounDef.queryClass.prototype[aAttrDef.boundName + &quot;Like&quot;] =</span>
<a href="#l22.206"></a><span id="l22.206">           likeConstrainer;</span>
<a href="#l22.207"></a><span id="l22.207">       }</span>
<a href="#l22.208"></a><span id="l22.208"> </span>
<a href="#l22.209"></a><span id="l22.209">       // - Custom helpers provided by the noun type...</span>
<a href="#l22.210"></a><span id="l22.210">       if (&quot;queryHelpers&quot; in objectNounDef) {</span>
<a href="#l22.211"></a><span id="l22.211" class="difflineminus">-        for each (let [name, helper] in Iterator(objectNounDef.queryHelpers)) {</span>
<a href="#l22.212"></a><span id="l22.212" class="difflineplus">+        for (let name in objectNounDef.queryHelpers) {</span>
<a href="#l22.213"></a><span id="l22.213" class="difflineplus">+          let helper = objectNounDef.queryHelpers[name];</span>
<a href="#l22.214"></a><span id="l22.214">           // we need a new closure...</span>
<a href="#l22.215"></a><span id="l22.215">           let helperFunc = helper;</span>
<a href="#l22.216"></a><span id="l22.216">           aSubjectNounDef.queryClass.prototype[aAttrDef.boundName + name] =</span>
<a href="#l22.217"></a><span id="l22.217">             function() {</span>
<a href="#l22.218"></a><span id="l22.218">               return helperFunc.call(this, aAttrDef, arguments);</span>
<a href="#l22.219"></a><span id="l22.219">             };</span>
<a href="#l22.220"></a><span id="l22.220">         }</span>
<a href="#l22.221"></a><span id="l22.221">       }</span>
<a href="#l22.222"></a><span id="l22.222" class="difflineat">@@ -1746,24 +1751,24 @@ var Gloda = {</span>
<a href="#l22.223"></a><span id="l22.223">           filter: null,</span>
<a href="#l22.224"></a><span id="l22.224">         };</span>
<a href="#l22.225"></a><span id="l22.225">       }</span>
<a href="#l22.226"></a><span id="l22.226">       else {</span>
<a href="#l22.227"></a><span id="l22.227">         normalizeFacetDef(aAttrDef.facet);</span>
<a href="#l22.228"></a><span id="l22.228">       }</span>
<a href="#l22.229"></a><span id="l22.229">     }</span>
<a href="#l22.230"></a><span id="l22.230">     if (&quot;extraFacets&quot; in aAttrDef) {</span>
<a href="#l22.231"></a><span id="l22.231" class="difflineminus">-      for each (let [, facetDef] in Iterator(aAttrDef.extraFacets)) {</span>
<a href="#l22.232"></a><span id="l22.232" class="difflineplus">+      for (let facetDef of aAttrDef.extraFacets) {</span>
<a href="#l22.233"></a><span id="l22.233">         normalizeFacetDef(facetDef);</span>
<a href="#l22.234"></a><span id="l22.234">       }</span>
<a href="#l22.235"></a><span id="l22.235">     }</span>
<a href="#l22.236"></a><span id="l22.236"> </span>
<a href="#l22.237"></a><span id="l22.237">     function gatherLocalizedStrings(aBundle, aPropRoot, aStickIn) {</span>
<a href="#l22.238"></a><span id="l22.238" class="difflineminus">-      for each (let [propName, attrName] in</span>
<a href="#l22.239"></a><span id="l22.239" class="difflineminus">-                Iterator(Gloda._ATTR_LOCALIZED_STRINGS)) {</span>
<a href="#l22.240"></a><span id="l22.240" class="difflineplus">+      for (let propName in Gloda._ATTR_LOCALIZED_STRINGS) {</span>
<a href="#l22.241"></a><span id="l22.241" class="difflineplus">+        let attrName = Gloda._ATTR_LOCALIZED_STRINGS[propName];</span>
<a href="#l22.242"></a><span id="l22.242">         try {</span>
<a href="#l22.243"></a><span id="l22.243">           aStickIn[attrName] = aBundle.get(aPropRoot + propName);</span>
<a href="#l22.244"></a><span id="l22.244">         }</span>
<a href="#l22.245"></a><span id="l22.245">         catch (ex) {</span>
<a href="#l22.246"></a><span id="l22.246">           // do nothing.  nsIStringBundle throws exceptions because it is a</span>
<a href="#l22.247"></a><span id="l22.247">           //  standard nsresult type of API and our helper buddy does nothing</span>
<a href="#l22.248"></a><span id="l22.248">           //  to help us.  (StringBundle.js, that is.)</span>
<a href="#l22.249"></a><span id="l22.249">         }</span>
<a href="#l22.250"></a><span id="l22.250" class="difflineat">@@ -1784,17 +1789,17 @@ var Gloda = {</span>
<a href="#l22.251"></a><span id="l22.251">       //  multiple noun types via the UI.  (Just messages right now.)</span>
<a href="#l22.252"></a><span id="l22.252">       let canonicalSubject = this._nounIDToDef[aAttrDef.subjectNouns[0]];</span>
<a href="#l22.253"></a><span id="l22.253">       let propRoot = &quot;gloda.&quot; + canonicalSubject.name + &quot;.attr.&quot; +</span>
<a href="#l22.254"></a><span id="l22.254">                        aAttrDef.attributeName + &quot;.&quot;;</span>
<a href="#l22.255"></a><span id="l22.255">       gatherLocalizedStrings(bundle, propRoot, attrStrings);</span>
<a href="#l22.256"></a><span id="l22.256"> </span>
<a href="#l22.257"></a><span id="l22.257">       // -- alias strings for synthetic facets</span>
<a href="#l22.258"></a><span id="l22.258">       if (&quot;extraFacets&quot; in aAttrDef) {</span>
<a href="#l22.259"></a><span id="l22.259" class="difflineminus">-        for each (let [, facetDef] in Iterator(aAttrDef.extraFacets)) {</span>
<a href="#l22.260"></a><span id="l22.260" class="difflineplus">+        for (let facetDef of aAttrDef.extraFacets) {</span>
<a href="#l22.261"></a><span id="l22.261">           facetDef.strings = {};</span>
<a href="#l22.262"></a><span id="l22.262">           let aliasPropRoot = &quot;gloda.&quot; + canonicalSubject.name + &quot;.attr.&quot; +</span>
<a href="#l22.263"></a><span id="l22.263">                                 facetDef.alias + &quot;.&quot;;</span>
<a href="#l22.264"></a><span id="l22.264">           gatherLocalizedStrings(bundle, aliasPropRoot, facetDef.strings);</span>
<a href="#l22.265"></a><span id="l22.265">         }</span>
<a href="#l22.266"></a><span id="l22.266">       }</span>
<a href="#l22.267"></a><span id="l22.267">     }</span>
<a href="#l22.268"></a><span id="l22.268"> </span>
<a href="#l22.269"></a><span id="l22.269" class="difflineat">@@ -2016,17 +2021,18 @@ var Gloda = {</span>
<a href="#l22.270"></a><span id="l22.270">       this._log.info(&quot;  * optimizer: &quot; + attrOptimizers[iProvider].providerName);</span>
<a href="#l22.271"></a><span id="l22.271">       yield aCallbackHandle.pushAndGo(</span>
<a href="#l22.272"></a><span id="l22.272">         attrOptimizers[iProvider].optimize(aItem, aRawReps, aIsConceptuallyNew,</span>
<a href="#l22.273"></a><span id="l22.273">                                            aCallbackHandle));</span>
<a href="#l22.274"></a><span id="l22.274">     }</span>
<a href="#l22.275"></a><span id="l22.275">     this._log.info(&quot; ** done with providers.&quot;);</span>
<a href="#l22.276"></a><span id="l22.276"> </span>
<a href="#l22.277"></a><span id="l22.277">     // Iterate over the attributes on the item</span>
<a href="#l22.278"></a><span id="l22.278" class="difflineminus">-    for each (let [key, value] in Iterator(aItem)) {</span>
<a href="#l22.279"></a><span id="l22.279" class="difflineplus">+    for (let key of Object.keys(aItem)) {</span>
<a href="#l22.280"></a><span id="l22.280" class="difflineplus">+      let value = aItem[key];</span>
<a href="#l22.281"></a><span id="l22.281">       // ignore keys that start with underscores, they are private and not</span>
<a href="#l22.282"></a><span id="l22.282">       //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l22.283"></a><span id="l22.283">       //  the object implementation.)</span>
<a href="#l22.284"></a><span id="l22.284">       if (key.startsWith(&quot;_&quot;))</span>
<a href="#l22.285"></a><span id="l22.285">         continue;</span>
<a href="#l22.286"></a><span id="l22.286">       // find the attribute definition that corresponds to this key</span>
<a href="#l22.287"></a><span id="l22.287">       let attrib = attribsByBoundName[key];</span>
<a href="#l22.288"></a><span id="l22.288">       // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l22.289"></a><span id="l22.289" class="difflineat">@@ -2043,17 +2049,17 @@ var Gloda = {</span>
<a href="#l22.290"></a><span id="l22.290">         if (objectNounDef.toJSON)</span>
<a href="#l22.291"></a><span id="l22.291">           jsonDict[attrib.id] = objectNounDef.toJSON(value);</span>
<a href="#l22.292"></a><span id="l22.292">         else</span>
<a href="#l22.293"></a><span id="l22.293">           jsonDict[attrib.id] = value;</span>
<a href="#l22.294"></a><span id="l22.294">       }</span>
<a href="#l22.295"></a><span id="l22.295">       else {</span>
<a href="#l22.296"></a><span id="l22.296">         if (objectNounDef.toJSON) {</span>
<a href="#l22.297"></a><span id="l22.297">           let toJSON = objectNounDef.toJSON;</span>
<a href="#l22.298"></a><span id="l22.298" class="difflineminus">-          jsonDict[attrib.id] = [toJSON(subValue) for each</span>
<a href="#l22.299"></a><span id="l22.299" class="difflineplus">+          jsonDict[attrib.id] = [toJSON(subValue) for</span>
<a href="#l22.300"></a><span id="l22.300">                            ([, subValue] in Iterator(value))] ;</span>
<a href="#l22.301"></a><span id="l22.301">         }</span>
<a href="#l22.302"></a><span id="l22.302">         else</span>
<a href="#l22.303"></a><span id="l22.303">           jsonDict[attrib.id] = value;</span>
<a href="#l22.304"></a><span id="l22.304">       }</span>
<a href="#l22.305"></a><span id="l22.305"> </span>
<a href="#l22.306"></a><span id="l22.306">       let oldValue = aOldItem[key];</span>
<a href="#l22.307"></a><span id="l22.307"> </span>
<a href="#l22.308"></a><span id="l22.308" class="difflineat">@@ -2101,31 +2107,32 @@ var Gloda = {</span>
<a href="#l22.309"></a><span id="l22.309">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l22.310"></a><span id="l22.310">             attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l22.311"></a><span id="l22.311">         }</span>
<a href="#l22.312"></a><span id="l22.312">         else {</span>
<a href="#l22.313"></a><span id="l22.313">           // build a map of the previous values; we will delete the values as</span>
<a href="#l22.314"></a><span id="l22.314">           //  we see them so that we will know what old values are no longer</span>
<a href="#l22.315"></a><span id="l22.315">           //  present in the current set of values.</span>
<a href="#l22.316"></a><span id="l22.316">           let oldValueMap = {};</span>
<a href="#l22.317"></a><span id="l22.317" class="difflineminus">-          for each (let [, anOldValue] in Iterator(oldValue)) {</span>
<a href="#l22.318"></a><span id="l22.318" class="difflineplus">+          for (let anOldValue of oldValue) {</span>
<a href="#l22.319"></a><span id="l22.319">             // remember, the key is just the toString'ed value, so we need to</span>
<a href="#l22.320"></a><span id="l22.320">             //  store and use the actual value as the value!</span>
<a href="#l22.321"></a><span id="l22.321">             oldValueMap[anOldValue] = anOldValue;</span>
<a href="#l22.322"></a><span id="l22.322">           }</span>
<a href="#l22.323"></a><span id="l22.323">           // traverse the current values...</span>
<a href="#l22.324"></a><span id="l22.324">           let valuesAdded = [];</span>
<a href="#l22.325"></a><span id="l22.325" class="difflineminus">-          for each (let [, curValue] in Iterator(value)) {</span>
<a href="#l22.326"></a><span id="l22.326" class="difflineplus">+          for (let curValue of value) {</span>
<a href="#l22.327"></a><span id="l22.327">             if (curValue in oldValueMap)</span>
<a href="#l22.328"></a><span id="l22.328">               delete oldValueMap[curValue];</span>
<a href="#l22.329"></a><span id="l22.329">             else</span>
<a href="#l22.330"></a><span id="l22.330">               valuesAdded.push(curValue);</span>
<a href="#l22.331"></a><span id="l22.331">           }</span>
<a href="#l22.332"></a><span id="l22.332">           // anything still on oldValueMap was removed.</span>
<a href="#l22.333"></a><span id="l22.333" class="difflineminus">-          let valuesRemoved = [val for each (val in oldValueMap)];</span>
<a href="#l22.334"></a><span id="l22.334" class="difflineplus">+          let valuesRemoved = Object.keys(oldValueMap).</span>
<a href="#l22.335"></a><span id="l22.335" class="difflineplus">+            map(key =&gt; oldValueMap[key]);</span>
<a href="#l22.336"></a><span id="l22.336">           // convert the values to database-style attribute rows</span>
<a href="#l22.337"></a><span id="l22.337">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l22.338"></a><span id="l22.338">             attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l22.339"></a><span id="l22.339">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l22.340"></a><span id="l22.340">             attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l22.341"></a><span id="l22.341">         }</span>
<a href="#l22.342"></a><span id="l22.342"> </span>
<a href="#l22.343"></a><span id="l22.343">         // Add/remove the empty set indicator as appropriate.</span>
<a href="#l22.344"></a><span id="l22.344" class="difflineat">@@ -2147,17 +2154,18 @@ var Gloda = {</span>
<a href="#l22.345"></a><span id="l22.345">                                 attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l22.346"></a><span id="l22.346">         // Add the empty set indicator for the attribute id if appropriate.</span>
<a href="#l22.347"></a><span id="l22.347">         if (!value.length &amp;&amp; attrib.emptySetIsSignificant)</span>
<a href="#l22.348"></a><span id="l22.348">           addDBAttribs.push([GlodaDatastore.kEmptySetAttrId, attribDB.id]);</span>
<a href="#l22.349"></a><span id="l22.349">       }</span>
<a href="#l22.350"></a><span id="l22.350">     }</span>
<a href="#l22.351"></a><span id="l22.351"> </span>
<a href="#l22.352"></a><span id="l22.352">     // Iterate over any remaining values in old items for purge purposes.</span>
<a href="#l22.353"></a><span id="l22.353" class="difflineminus">-    for each (let [key, value] in Iterator(aOldItem)) {</span>
<a href="#l22.354"></a><span id="l22.354" class="difflineplus">+    for (let key of Object.keys(aOldItem)) {</span>
<a href="#l22.355"></a><span id="l22.355" class="difflineplus">+      let value = aOldItem[key];</span>
<a href="#l22.356"></a><span id="l22.356">       // ignore keys that start with underscores, they are private and not</span>
<a href="#l22.357"></a><span id="l22.357">       //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l22.358"></a><span id="l22.358">       //  the object implementation.)</span>
<a href="#l22.359"></a><span id="l22.359">       if (key.startsWith(&quot;_&quot;))</span>
<a href="#l22.360"></a><span id="l22.360">         continue;</span>
<a href="#l22.361"></a><span id="l22.361">       // ignore things we saw in the new guy</span>
<a href="#l22.362"></a><span id="l22.362">       if (key in aItem)</span>
<a href="#l22.363"></a><span id="l22.363">         continue;</span>
<a href="#l22.364"></a><span id="l22.364" class="difflineat">@@ -2239,17 +2247,17 @@ var Gloda = {</span>
<a href="#l22.365"></a><span id="l22.365">     // bail if there is nothing to score</span>
<a href="#l22.366"></a><span id="l22.366">     if (!aItems.length)</span>
<a href="#l22.367"></a><span id="l22.367">       return scores;</span>
<a href="#l22.368"></a><span id="l22.368"> </span>
<a href="#l22.369"></a><span id="l22.369">     let itemNounDef = aItems[0].NOUN_DEF;</span>
<a href="#l22.370"></a><span id="l22.370">     if (aExtraScoreFuncs == null)</span>
<a href="#l22.371"></a><span id="l22.371">       aExtraScoreFuncs = [];</span>
<a href="#l22.372"></a><span id="l22.372"> </span>
<a href="#l22.373"></a><span id="l22.373" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l22.374"></a><span id="l22.374" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l22.375"></a><span id="l22.375">       let score = 0;</span>
<a href="#l22.376"></a><span id="l22.376">       let attrProviders = this._attrProviderOrderByNoun[itemNounDef.id];</span>
<a href="#l22.377"></a><span id="l22.377">       for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l22.378"></a><span id="l22.378">         let provider = attrProviders[iProvider];</span>
<a href="#l22.379"></a><span id="l22.379">         if (provider.score)</span>
<a href="#l22.380"></a><span id="l22.380">           score += provider.score(item);</span>
<a href="#l22.381"></a><span id="l22.381">       }</span>
<a href="#l22.382"></a><span id="l22.382">       for (let [, extraScoreFunc] in Iterator(aExtraScoreFuncs))</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mailnews/db/gloda/modules/index_ab.js</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_ab.js</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -269,17 +269,17 @@ var GlodaABAttrs = {</span>
<a href="#l23.4"></a><span id="l23.4"> </span>
<a href="#l23.5"></a><span id="l23.5">     let tags = null;</span>
<a href="#l23.6"></a><span id="l23.6">     try {</span>
<a href="#l23.7"></a><span id="l23.7">       tags = card.getProperty(&quot;Categories&quot;, null);</span>
<a href="#l23.8"></a><span id="l23.8">     } catch (ex) {</span>
<a href="#l23.9"></a><span id="l23.9">       this._log.error(&quot;Problem accessing property: &quot; + ex);</span>
<a href="#l23.10"></a><span id="l23.10">     }</span>
<a href="#l23.11"></a><span id="l23.11">     if (tags) {</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-      for each (let [iTagName, tagName] in Iterator(tags.split(&quot;,&quot;))) {</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+      for (let tagName of tags.split(&quot;,&quot;)) {</span>
<a href="#l23.14"></a><span id="l23.14">         tagName = tagName.trim();</span>
<a href="#l23.15"></a><span id="l23.15">         if (tagName) {</span>
<a href="#l23.16"></a><span id="l23.16">           aContact.freeTags.push(FreeTagNoun.getFreeTag(tagName));</span>
<a href="#l23.17"></a><span id="l23.17">         }</span>
<a href="#l23.18"></a><span id="l23.18">       }</span>
<a href="#l23.19"></a><span id="l23.19">     }</span>
<a href="#l23.20"></a><span id="l23.20"> </span>
<a href="#l23.21"></a><span id="l23.21">     yield Gloda.kWorkDone;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -141,19 +141,20 @@ var PendingCommitTracker = {</span>
<a href="#l24.4"></a><span id="l24.4">    *  header we could do that and call commit directly.  We don't track</span>
<a href="#l24.5"></a><span id="l24.5">    *  databases along with the headers since the headers can change because of</span>
<a href="#l24.6"></a><span id="l24.6">    *  moves and that would increase the number of moving parts.</span>
<a href="#l24.7"></a><span id="l24.7">    */</span>
<a href="#l24.8"></a><span id="l24.8">   _commitCallback: function PendingCommitTracker_commitCallback() {</span>
<a href="#l24.9"></a><span id="l24.9">     let foldersByURI = {};</span>
<a href="#l24.10"></a><span id="l24.10">     let lastFolder = null;</span>
<a href="#l24.11"></a><span id="l24.11"> </span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-    for each (let [glodaId, [msgHdr, dirtyState]] in</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineminus">-              Iterator(</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineminus">-                PendingCommitTracker._indexedMessagesPendingCommitByGlodaId)) {</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineplus">+    for (let glodaId in</span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+         PendingCommitTracker._indexedMessagesPendingCommitByGlodaId) {</span>
<a href="#l24.17"></a><span id="l24.17" class="difflineplus">+     let [msgHdr, dirtyState] =</span>
<a href="#l24.18"></a><span id="l24.18" class="difflineplus">+       PendingCommitTracker._indexedMessagesPendingCommitByGlodaId[glodaId];</span>
<a href="#l24.19"></a><span id="l24.19">       // Mark this message as indexed.</span>
<a href="#l24.20"></a><span id="l24.20">       // It's conceivable the database could have gotten blown away, in which</span>
<a href="#l24.21"></a><span id="l24.21">       //  case the message headers are going to throw exceptions when we try</span>
<a href="#l24.22"></a><span id="l24.22">       //  and touch them.  So we wrap this in a try block that complains about</span>
<a href="#l24.23"></a><span id="l24.23">       //  this unforeseen circumstance.  (noteFolderDatabaseGettingBlownAway</span>
<a href="#l24.24"></a><span id="l24.24">       //  should have been called and avoided this situation in all known</span>
<a href="#l24.25"></a><span id="l24.25">       //  situations.)</span>
<a href="#l24.26"></a><span id="l24.26">       try {</span>
<a href="#l24.27"></a><span id="l24.27" class="difflineat">@@ -175,17 +176,18 @@ var PendingCommitTracker = {</span>
<a href="#l24.28"></a><span id="l24.28">       catch (ex) {</span>
<a href="#l24.29"></a><span id="l24.29">         GlodaMsgIndexer._log.error(</span>
<a href="#l24.30"></a><span id="l24.30">           &quot;Exception while attempting to mark message with gloda state after&quot; +</span>
<a href="#l24.31"></a><span id="l24.31">           &quot;db commit&quot;, ex);</span>
<a href="#l24.32"></a><span id="l24.32">       }</span>
<a href="#l24.33"></a><span id="l24.33">     }</span>
<a href="#l24.34"></a><span id="l24.34"> </span>
<a href="#l24.35"></a><span id="l24.35">     // it is vitally important to do this before we forget about the headers!</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineminus">-    for each (let [, folder] in Iterator(foldersByURI)) {</span>
<a href="#l24.37"></a><span id="l24.37" class="difflineplus">+    for (let uri in foldersByURI) {</span>
<a href="#l24.38"></a><span id="l24.38" class="difflineplus">+      let folder = foldersByURI[uri];</span>
<a href="#l24.39"></a><span id="l24.39">       // This will not cause a parse.  The database is in-memory since we have</span>
<a href="#l24.40"></a><span id="l24.40">       //  a header that belongs to it.  This just causes the folder to</span>
<a href="#l24.41"></a><span id="l24.41">       //  re-acquire a reference from the database manager.</span>
<a href="#l24.42"></a><span id="l24.42">       let ignoredDb = folder.msgDatabase;</span>
<a href="#l24.43"></a><span id="l24.43">       // And this will cause a commit.  (And must be done since we don't want</span>
<a href="#l24.44"></a><span id="l24.44">       //  to cause a leak.)</span>
<a href="#l24.45"></a><span id="l24.45">       folder.msgDatabase = null;</span>
<a href="#l24.46"></a><span id="l24.46">     }</span>
<a href="#l24.47"></a><span id="l24.47" class="difflineat">@@ -340,17 +342,17 @@ MessagesByMessageIdCallback.prototype = </span>
<a href="#l24.48"></a><span id="l24.48">   _log: Log4Moz.repository.getLogger(&quot;gloda.index_msg.mbm&quot;),</span>
<a href="#l24.49"></a><span id="l24.49"> </span>
<a href="#l24.50"></a><span id="l24.50">   onItemsAdded: function gloda_ds_mbmi_onItemsAdded(aItems, aCollection) {</span>
<a href="#l24.51"></a><span id="l24.51">     // just outright bail if we are shutdown</span>
<a href="#l24.52"></a><span id="l24.52">     if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l24.53"></a><span id="l24.53">       return;</span>
<a href="#l24.54"></a><span id="l24.54"> </span>
<a href="#l24.55"></a><span id="l24.55">     this._log.debug(&quot;getting results...&quot;);</span>
<a href="#l24.56"></a><span id="l24.56" class="difflineminus">-    for each (let [, message] in Iterator(aItems)) {</span>
<a href="#l24.57"></a><span id="l24.57" class="difflineplus">+    for (let message of aItems) {</span>
<a href="#l24.58"></a><span id="l24.58">       this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l24.59"></a><span id="l24.59">     }</span>
<a href="#l24.60"></a><span id="l24.60">   },</span>
<a href="#l24.61"></a><span id="l24.61">   onItemsModified: function () {},</span>
<a href="#l24.62"></a><span id="l24.62">   onItemsRemoved: function () {},</span>
<a href="#l24.63"></a><span id="l24.63">   onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l24.64"></a><span id="l24.64">     // just outright bail if we are shutdown</span>
<a href="#l24.65"></a><span id="l24.65">     if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l24.66"></a><span id="l24.66" class="difflineat">@@ -1649,17 +1651,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l24.67"></a><span id="l24.67">                                  noDbQueryValidityConstraints: true,</span>
<a href="#l24.68"></a><span id="l24.68">                                });</span>
<a href="#l24.69"></a><span id="l24.69">     query._deleted(1);</span>
<a href="#l24.70"></a><span id="l24.70">     query.limit(this.DELETED_MESSAGE_BLOCK_SIZE);</span>
<a href="#l24.71"></a><span id="l24.71">     let deletedCollection = query.getCollection(aCallbackHandle);</span>
<a href="#l24.72"></a><span id="l24.72">     yield this.kWorkAsync;</span>
<a href="#l24.73"></a><span id="l24.73"> </span>
<a href="#l24.74"></a><span id="l24.74">     while (deletedCollection.items.length) {</span>
<a href="#l24.75"></a><span id="l24.75" class="difflineminus">-      for each (let [, message] in Iterator(deletedCollection.items)) {</span>
<a href="#l24.76"></a><span id="l24.76" class="difflineplus">+      for (let message of deletedCollection.items) {</span>
<a href="#l24.77"></a><span id="l24.77">         // If it turns out our count is wrong (because some new deletions</span>
<a href="#l24.78"></a><span id="l24.78">         //  happened since we entered this worker), let's issue a new count</span>
<a href="#l24.79"></a><span id="l24.79">         //  and use that to accurately update our goal.</span>
<a href="#l24.80"></a><span id="l24.80">         if (aJob.offset &gt;= aJob.goal) {</span>
<a href="#l24.81"></a><span id="l24.81">           this._datastore.countDeletedMessages(aCallbackHandle.wrappedCallback);</span>
<a href="#l24.82"></a><span id="l24.82">           aJob.goal += yield this.kWorkAsync;</span>
<a href="#l24.83"></a><span id="l24.83">         }</span>
<a href="#l24.84"></a><span id="l24.84"> </span>
<a href="#l24.85"></a><span id="l24.85" class="difflineat">@@ -1939,36 +1941,36 @@ var GlodaMsgIndexer = {</span>
<a href="#l24.86"></a><span id="l24.86"> </span>
<a href="#l24.87"></a><span id="l24.87">   /**</span>
<a href="#l24.88"></a><span id="l24.88">    * Queue a list of messages for indexing.</span>
<a href="#l24.89"></a><span id="l24.89">    *</span>
<a href="#l24.90"></a><span id="l24.90">    * @param aFoldersAndMessages List of [nsIMsgFolder, message key] tuples.</span>
<a href="#l24.91"></a><span id="l24.91">    */</span>
<a href="#l24.92"></a><span id="l24.92">   indexMessages: function gloda_index_indexMessages(aFoldersAndMessages) {</span>
<a href="#l24.93"></a><span id="l24.93">     let job = new IndexingJob(&quot;message&quot;, null);</span>
<a href="#l24.94"></a><span id="l24.94" class="difflineminus">-    job.items = [[GlodaDatastore._mapFolder(fm[0]).id, fm[1]] for each</span>
<a href="#l24.95"></a><span id="l24.95" class="difflineminus">-                 ([i, fm] in Iterator(aFoldersAndMessages))];</span>
<a href="#l24.96"></a><span id="l24.96" class="difflineplus">+    job.items = aFoldersAndMessages.</span>
<a href="#l24.97"></a><span id="l24.97" class="difflineplus">+      map(fm =&gt; [GlodaDatastore._mapFolder(fm[0]).id, fm[1]]);</span>
<a href="#l24.98"></a><span id="l24.98">     GlodaIndexer.indexJob(job);</span>
<a href="#l24.99"></a><span id="l24.99">   },</span>
<a href="#l24.100"></a><span id="l24.100"> </span>
<a href="#l24.101"></a><span id="l24.101">   /**</span>
<a href="#l24.102"></a><span id="l24.102">    * Mark all known folders as dirty so that the next indexing sweep goes</span>
<a href="#l24.103"></a><span id="l24.103">    *  into all folders and checks their contents to see if they need to be</span>
<a href="#l24.104"></a><span id="l24.104">    *  indexed.</span>
<a href="#l24.105"></a><span id="l24.105">    *</span>
<a href="#l24.106"></a><span id="l24.106">    * This is being added for the migration case where we want to try and reindex</span>
<a href="#l24.107"></a><span id="l24.107">    *  all of the messages that had been marked with GLODA_BAD_MESSAGE_ID but</span>
<a href="#l24.108"></a><span id="l24.108">    *  which is now GLODA_OLD_BAD_MESSAGE_ID and so we should attempt to reindex</span>
<a href="#l24.109"></a><span id="l24.109">    *  them.</span>
<a href="#l24.110"></a><span id="l24.110">    */</span>
<a href="#l24.111"></a><span id="l24.111">   dirtyAllKnownFolders: function gloda_index_msg_dirtyAllKnownFolders() {</span>
<a href="#l24.112"></a><span id="l24.112">     // Just iterate over the datastore's folder map and tell each folder to</span>
<a href="#l24.113"></a><span id="l24.113">     //  be dirty if its priority is not disabled.</span>
<a href="#l24.114"></a><span id="l24.114" class="difflineminus">-    for each (let [folderID, glodaFolder] in</span>
<a href="#l24.115"></a><span id="l24.115" class="difflineminus">-              Iterator(GlodaDatastore._folderByID)) {</span>
<a href="#l24.116"></a><span id="l24.116" class="difflineplus">+    for (let folderID in GlodaDatastore._folderByID) {</span>
<a href="#l24.117"></a><span id="l24.117" class="difflineplus">+      let glodaFolder = GlodaDatastore._folderByID[folderID];</span>
<a href="#l24.118"></a><span id="l24.118">       if (glodaFolder.indexingPriority !== glodaFolder.kIndexingNeverPriority)</span>
<a href="#l24.119"></a><span id="l24.119">         glodaFolder._ensureFolderDirty();</span>
<a href="#l24.120"></a><span id="l24.120">     }</span>
<a href="#l24.121"></a><span id="l24.121">   },</span>
<a href="#l24.122"></a><span id="l24.122"> </span>
<a href="#l24.123"></a><span id="l24.123">   /**</span>
<a href="#l24.124"></a><span id="l24.124">    * Given a message header, return whether this message is likely to have</span>
<a href="#l24.125"></a><span id="l24.125">    * been indexed or not.</span>
<a href="#l24.126"></a><span id="l24.126" class="difflineat">@@ -2984,18 +2986,18 @@ var GlodaMsgIndexer = {</span>
<a href="#l24.127"></a><span id="l24.127">     }</span>
<a href="#l24.128"></a><span id="l24.128"> </span>
<a href="#l24.129"></a><span id="l24.129">     // -- Find/create the conversation the message belongs to.</span>
<a href="#l24.130"></a><span id="l24.130">     // Our invariant is that all messages that exist in the database belong to</span>
<a href="#l24.131"></a><span id="l24.131">     //  a conversation.</span>
<a href="#l24.132"></a><span id="l24.132"> </span>
<a href="#l24.133"></a><span id="l24.133">     // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l24.134"></a><span id="l24.134">     // (references are ordered from old [0] to new [n-1])</span>
<a href="#l24.135"></a><span id="l24.135" class="difflineminus">-    let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l24.136"></a><span id="l24.136" class="difflineminus">-                      (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l24.137"></a><span id="l24.137" class="difflineplus">+    let references = Array.from(range(0, aMsgHdr.numReferences)).</span>
<a href="#l24.138"></a><span id="l24.138" class="difflineplus">+      map(i =&gt; aMsgHdr.getStringReference(i));</span>
<a href="#l24.139"></a><span id="l24.139">     // also see if we already know about the message...</span>
<a href="#l24.140"></a><span id="l24.140">     references.push(aMsgHdr.messageId);</span>
<a href="#l24.141"></a><span id="l24.141"> </span>
<a href="#l24.142"></a><span id="l24.142">     this.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l24.143"></a><span id="l24.143">                                 aCallbackHandle.callbackThis);</span>
<a href="#l24.144"></a><span id="l24.144">     // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l24.145"></a><span id="l24.145">     let ancestorLists = yield this.kWorkAsync;</span>
<a href="#l24.146"></a><span id="l24.146"> </span>
<a href="#l24.147"></a><span id="l24.147" class="difflineat">@@ -3120,19 +3122,18 @@ var GlodaMsgIndexer = {</span>
<a href="#l24.148"></a><span id="l24.148">       // a ghost/deleted message is fine</span>
<a href="#l24.149"></a><span id="l24.149">       else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l24.150"></a><span id="l24.150">         curMsg = candMsg;</span>
<a href="#l24.151"></a><span id="l24.151">       }</span>
<a href="#l24.152"></a><span id="l24.152">     }</span>
<a href="#l24.153"></a><span id="l24.153"> </span>
<a href="#l24.154"></a><span id="l24.154">     let attachmentNames = null;</span>
<a href="#l24.155"></a><span id="l24.155">     if (aMimeMsg) {</span>
<a href="#l24.156"></a><span id="l24.156" class="difflineminus">-      attachmentNames = [att.name for each</span>
<a href="#l24.157"></a><span id="l24.157" class="difflineminus">-                         ([i, att] in Iterator(aMimeMsg.allAttachments))</span>
<a href="#l24.158"></a><span id="l24.158" class="difflineminus">-                         if (att.isRealAttachment)];</span>
<a href="#l24.159"></a><span id="l24.159" class="difflineplus">+      attachmentNames = aMimeMsg.allAttachments.</span>
<a href="#l24.160"></a><span id="l24.160" class="difflineplus">+        filter(att =&gt; att.isRealAttachment).map(att =&gt; att.name);</span>
<a href="#l24.161"></a><span id="l24.161">     }</span>
<a href="#l24.162"></a><span id="l24.162"> </span>
<a href="#l24.163"></a><span id="l24.163">     let isConceptuallyNew, isRecordNew, insertFulltext;</span>
<a href="#l24.164"></a><span id="l24.164">     if (curMsg === null) {</span>
<a href="#l24.165"></a><span id="l24.165">       curMsg = this._datastore.createMessage(aMsgHdr.folder,</span>
<a href="#l24.166"></a><span id="l24.166">                                              aMsgHdr.messageKey,</span>
<a href="#l24.167"></a><span id="l24.167">                                              conversationID,</span>
<a href="#l24.168"></a><span id="l24.168">                                              aMsgHdr.date,</span>
<a href="#l24.169"></a><span id="l24.169" class="difflineat">@@ -3248,17 +3249,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l24.170"></a><span id="l24.170">     yield this.kWorkAsync;</span>
<a href="#l24.171"></a><span id="l24.171"> </span>
<a href="#l24.172"></a><span id="l24.172">     let conversationMsgs = conversationCollection.items;</span>
<a href="#l24.173"></a><span id="l24.173"> </span>
<a href="#l24.174"></a><span id="l24.174">     // Count the number of ghosts messages we see to determine if we are</span>
<a href="#l24.175"></a><span id="l24.175">     //  the last message alive.</span>
<a href="#l24.176"></a><span id="l24.176">     let ghostCount = 0;</span>
<a href="#l24.177"></a><span id="l24.177">     let twinMessageExists = false;</span>
<a href="#l24.178"></a><span id="l24.178" class="difflineminus">-    for each (let [, convMsg] in Iterator(conversationMsgs)) {</span>
<a href="#l24.179"></a><span id="l24.179" class="difflineplus">+    for (let convMsg of conversationMsgs) {</span>
<a href="#l24.180"></a><span id="l24.180">       // ignore our own message</span>
<a href="#l24.181"></a><span id="l24.181">       if (convMsg.id == aMessage.id)</span>
<a href="#l24.182"></a><span id="l24.182">         continue;</span>
<a href="#l24.183"></a><span id="l24.183"> </span>
<a href="#l24.184"></a><span id="l24.184">       if (convMsg._isGhost)</span>
<a href="#l24.185"></a><span id="l24.185">         ghostCount++;</span>
<a href="#l24.186"></a><span id="l24.186">       // This message is our (living) twin if it is not a ghost, not deleted,</span>
<a href="#l24.187"></a><span id="l24.187">       //  and has the same message-id header.</span>
<a href="#l24.188"></a><span id="l24.188" class="difflineat">@@ -3268,17 +3269,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l24.189"></a><span id="l24.189">     }</span>
<a href="#l24.190"></a><span id="l24.190"> </span>
<a href="#l24.191"></a><span id="l24.191">     // -- If everyone else is a ghost, blow away the conversation.</span>
<a href="#l24.192"></a><span id="l24.192">     // If there are messages still alive or deleted but we have not yet gotten</span>
<a href="#l24.193"></a><span id="l24.193">     //  to them yet _deleteMessage, then do not do this.  (We will eventually</span>
<a href="#l24.194"></a><span id="l24.194">     //  hit this case if they are all deleted.)</span>
<a href="#l24.195"></a><span id="l24.195">     if ((conversationMsgs.length - 1) == ghostCount) {</span>
<a href="#l24.196"></a><span id="l24.196">       // - Obliterate each message</span>
<a href="#l24.197"></a><span id="l24.197" class="difflineminus">-      for each (let [, msg] in Iterator(conversationMsgs)) {</span>
<a href="#l24.198"></a><span id="l24.198" class="difflineplus">+      for (let msg of conversationMsgs) {</span>
<a href="#l24.199"></a><span id="l24.199">         GlodaDatastore.deleteMessageByID(msg.id);</span>
<a href="#l24.200"></a><span id="l24.200">       }</span>
<a href="#l24.201"></a><span id="l24.201">       // - Obliterate the conversation</span>
<a href="#l24.202"></a><span id="l24.202">       GlodaDatastore.deleteConversationByID(aMessage.conversationID);</span>
<a href="#l24.203"></a><span id="l24.203">       // *no one* should hold a reference or use aMessage after this point,</span>
<a href="#l24.204"></a><span id="l24.204">       //  trash it so such ne'er do'wells are made plain.</span>
<a href="#l24.205"></a><span id="l24.205">       aMessage._objectPurgedMakeYourselfUnpleasant();</span>
<a href="#l24.206"></a><span id="l24.206">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -446,17 +446,17 @@ var GlodaIndexer = {</span>
<a href="#l25.4"></a><span id="l25.4">    *     sure they are indexed.  Right now we just call everyone at the same</span>
<a href="#l25.5"></a><span id="l25.5">    *     time and hope that their jobs don't fight too much.</span>
<a href="#l25.6"></a><span id="l25.6">    */</span>
<a href="#l25.7"></a><span id="l25.7">   registerIndexer: function gloda_index_registerIndexer(aIndexer) {</span>
<a href="#l25.8"></a><span id="l25.8">     this._log.info(&quot;Registering indexer: &quot; + aIndexer.name);</span>
<a href="#l25.9"></a><span id="l25.9">     this._indexers.push(aIndexer);</span>
<a href="#l25.10"></a><span id="l25.10"> </span>
<a href="#l25.11"></a><span id="l25.11">     try {</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-      for each (let [iWorker, workerInfo] in Iterator(aIndexer.workers)) {</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+      for (let workerInfo of aIndexer.workers) {</span>
<a href="#l25.14"></a><span id="l25.14">         let workerCode = workerInfo[0];</span>
<a href="#l25.15"></a><span id="l25.15">         let workerDef = workerInfo[1];</span>
<a href="#l25.16"></a><span id="l25.16">         workerDef.name = workerCode;</span>
<a href="#l25.17"></a><span id="l25.17">         workerDef.indexer = aIndexer;</span>
<a href="#l25.18"></a><span id="l25.18">         this._indexerWorkerDefs[workerCode] = workerDef;</span>
<a href="#l25.19"></a><span id="l25.19">         if (!(&quot;recover&quot; in workerDef))</span>
<a href="#l25.20"></a><span id="l25.20">           workerDef.recover = null;</span>
<a href="#l25.21"></a><span id="l25.21">         if (!(&quot;cleanup&quot; in workerDef))</span>
<a href="#l25.22"></a><span id="l25.22" class="difflineat">@@ -490,17 +490,17 @@ var GlodaIndexer = {</span>
<a href="#l25.23"></a><span id="l25.23">       // register for offline notifications</span>
<a href="#l25.24"></a><span id="l25.24">       Services.obs.addObserver(this, &quot;network:offline-status-changed&quot;, false);</span>
<a href="#l25.25"></a><span id="l25.25"> </span>
<a href="#l25.26"></a><span id="l25.26">       // register for idle notification</span>
<a href="#l25.27"></a><span id="l25.27">       this._idleService.addIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l25.28"></a><span id="l25.28"> </span>
<a href="#l25.29"></a><span id="l25.29">       this._enabled = true;</span>
<a href="#l25.30"></a><span id="l25.30"> </span>
<a href="#l25.31"></a><span id="l25.31" class="difflineminus">-      for each (let [iIndexer, indexer] in Iterator(this._indexers)) {</span>
<a href="#l25.32"></a><span id="l25.32" class="difflineplus">+      for (let indexer of this._indexers) {</span>
<a href="#l25.33"></a><span id="l25.33">         try {</span>
<a href="#l25.34"></a><span id="l25.34">           indexer.enable();</span>
<a href="#l25.35"></a><span id="l25.35">         } catch (ex) {</span>
<a href="#l25.36"></a><span id="l25.36">           this._log.warn(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l25.37"></a><span id="l25.37">         }</span>
<a href="#l25.38"></a><span id="l25.38">       }</span>
<a href="#l25.39"></a><span id="l25.39"> </span>
<a href="#l25.40"></a><span id="l25.40">       // if we have an accumulated desire to index things, kick it off again.</span>
<a href="#l25.41"></a><span id="l25.41" class="difflineat">@@ -511,17 +511,17 @@ var GlodaIndexer = {</span>
<a href="#l25.42"></a><span id="l25.42"> </span>
<a href="#l25.43"></a><span id="l25.43">       // if we have not done an initial sweep, schedule scheduling one.</span>
<a href="#l25.44"></a><span id="l25.44">       if (!this._initialSweepPerformed) {</span>
<a href="#l25.45"></a><span id="l25.45">         this._longTimer.initWithCallback(this._scheduleInitialSweep,</span>
<a href="#l25.46"></a><span id="l25.46">           this._INITIAL_SWEEP_DELAY, Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l25.47"></a><span id="l25.47">       }</span>
<a href="#l25.48"></a><span id="l25.48">     }</span>
<a href="#l25.49"></a><span id="l25.49">     else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l25.50"></a><span id="l25.50" class="difflineminus">-      for each (let [iIndexer, indexer] in Iterator(this._indexers)) {</span>
<a href="#l25.51"></a><span id="l25.51" class="difflineplus">+      for (let indexer of this._indexers) {</span>
<a href="#l25.52"></a><span id="l25.52">         try {</span>
<a href="#l25.53"></a><span id="l25.53">           indexer.disable();</span>
<a href="#l25.54"></a><span id="l25.54">         } catch (ex) {</span>
<a href="#l25.55"></a><span id="l25.55">           this._log.warn(&quot;Helper indexer threw exception on disable: &quot; + ex);</span>
<a href="#l25.56"></a><span id="l25.56">         }</span>
<a href="#l25.57"></a><span id="l25.57">       }</span>
<a href="#l25.58"></a><span id="l25.58"> </span>
<a href="#l25.59"></a><span id="l25.59">       // remove offline observer</span>
<a href="#l25.60"></a><span id="l25.60" class="difflineat">@@ -610,17 +610,17 @@ var GlodaIndexer = {</span>
<a href="#l25.61"></a><span id="l25.61">    *  we need to check whether an initial sweep is still desired before trying</span>
<a href="#l25.62"></a><span id="l25.62">    *  to schedule one.  We don't need to worry about whether one is active</span>
<a href="#l25.63"></a><span id="l25.63">    *  because the indexingSweepNeeded takes care of that.</span>
<a href="#l25.64"></a><span id="l25.64">    */</span>
<a href="#l25.65"></a><span id="l25.65">   _scheduleInitialSweep: function gloda_index_scheduleInitialSweep() {</span>
<a href="#l25.66"></a><span id="l25.66">     if (GlodaIndexer._initialSweepPerformed)</span>
<a href="#l25.67"></a><span id="l25.67">       return;</span>
<a href="#l25.68"></a><span id="l25.68">     GlodaIndexer._initialSweepPerformed = true;</span>
<a href="#l25.69"></a><span id="l25.69" class="difflineminus">-    for each (let [, indexer] in Iterator(GlodaIndexer._indexers)) {</span>
<a href="#l25.70"></a><span id="l25.70" class="difflineplus">+    for (let indexer of GlodaIndexer._indexers) {</span>
<a href="#l25.71"></a><span id="l25.71">       indexer.initialSweep();</span>
<a href="#l25.72"></a><span id="l25.72">     }</span>
<a href="#l25.73"></a><span id="l25.73">   },</span>
<a href="#l25.74"></a><span id="l25.74"> </span>
<a href="#l25.75"></a><span id="l25.75">   kWorkSync: Gloda.kWorkSync,</span>
<a href="#l25.76"></a><span id="l25.76">   kWorkAsync: Gloda.kWorkAsync,</span>
<a href="#l25.77"></a><span id="l25.77">   kWorkDone: Gloda.kWorkDone,</span>
<a href="#l25.78"></a><span id="l25.78">   kWorkPause: Gloda.kWorkPause,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/db/gloda/modules/log4moz.js</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/log4moz.js</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -494,19 +494,17 @@ BasicFormatter.prototype = {</span>
<a href="#l26.4"></a><span id="l26.4">   set dateFormat(format) {</span>
<a href="#l26.5"></a><span id="l26.5">     this._dateFormat = format;</span>
<a href="#l26.6"></a><span id="l26.6">   },</span>
<a href="#l26.7"></a><span id="l26.7"> </span>
<a href="#l26.8"></a><span id="l26.8">   format: function BF_format(message) {</span>
<a href="#l26.9"></a><span id="l26.9">     let date = new Date(message.time);</span>
<a href="#l26.10"></a><span id="l26.10">     // The trick below prevents errors further down because mo is null or</span>
<a href="#l26.11"></a><span id="l26.11">     //  undefined.</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-    let messageString = [</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineminus">-      (&quot;&quot; + mo) for each</span>
<a href="#l26.14"></a><span id="l26.14" class="difflineminus">-      ([,mo] in Iterator(message.messageObjects))].join(&quot; &quot;);</span>
<a href="#l26.15"></a><span id="l26.15" class="difflineplus">+    let messageString = message.messageObjects.map(mo =&gt; &quot;&quot; + mo).join(&quot; &quot;);</span>
<a href="#l26.16"></a><span id="l26.16">     return date.toLocaleFormat(this.dateFormat) + &quot;\t&quot; +</span>
<a href="#l26.17"></a><span id="l26.17">       message.loggerName + &quot;\t&quot; + message.levelDesc + &quot;\t&quot; +</span>
<a href="#l26.18"></a><span id="l26.18">       messageString + &quot;\n&quot;;</span>
<a href="#l26.19"></a><span id="l26.19">   }</span>
<a href="#l26.20"></a><span id="l26.20"> };</span>
<a href="#l26.21"></a><span id="l26.21"> </span>
<a href="#l26.22"></a><span id="l26.22"> /*</span>
<a href="#l26.23"></a><span id="l26.23">  * XMLFormatter</span>
<a href="#l26.24"></a><span id="l26.24" class="difflineat">@@ -518,18 +516,18 @@ BasicFormatter.prototype = {</span>
<a href="#l26.25"></a><span id="l26.25">  */</span>
<a href="#l26.26"></a><span id="l26.26"> </span>
<a href="#l26.27"></a><span id="l26.27"> function XMLFormatter() {}</span>
<a href="#l26.28"></a><span id="l26.28"> XMLFormatter.prototype = {</span>
<a href="#l26.29"></a><span id="l26.29">   __proto__: Formatter.prototype,</span>
<a href="#l26.30"></a><span id="l26.30"> </span>
<a href="#l26.31"></a><span id="l26.31">   format: function XF_format(message) {</span>
<a href="#l26.32"></a><span id="l26.32">     let cdataEscapedMessage =</span>
<a href="#l26.33"></a><span id="l26.33" class="difflineminus">-      [((typeof(mo) == &quot;object&quot;) ? mo.toString() : mo) for each</span>
<a href="#l26.34"></a><span id="l26.34" class="difflineminus">-       ([,mo] in Iterator(message.messageObjects))]</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineplus">+      message.messageObjects</span>
<a href="#l26.36"></a><span id="l26.36" class="difflineplus">+        .map(mo =&gt; (typeof(mo) == &quot;object&quot;) ? mo.toString() : mo)</span>
<a href="#l26.37"></a><span id="l26.37">         .join(&quot; &quot;)</span>
<a href="#l26.38"></a><span id="l26.38">         .split(CDATA_END).join(CDATA_ESCAPED_END);</span>
<a href="#l26.39"></a><span id="l26.39">     return &quot;&lt;log4j:event logger='&quot; + message.loggerName + &quot;' &quot; +</span>
<a href="#l26.40"></a><span id="l26.40">                         &quot;level='&quot; + message.levelDesc + &quot;' thread='unknown' &quot; +</span>
<a href="#l26.41"></a><span id="l26.41">                         &quot;timestamp='&quot; + message.time + &quot;'&gt;&quot; +</span>
<a href="#l26.42"></a><span id="l26.42">       &quot;&lt;log4j:message&gt;&lt;![CDATA[&quot; + cdataEscapedMessage + &quot;]]&gt;&lt;/log4j:message&gt;&quot; +</span>
<a href="#l26.43"></a><span id="l26.43">       &quot;&lt;/log4j:event&gt;&quot;;</span>
<a href="#l26.44"></a><span id="l26.44">   }</span>
<a href="#l26.45"></a><span id="l26.45" class="difflineat">@@ -545,34 +543,34 @@ JSONFormatter.prototype = {</span>
<a href="#l26.46"></a><span id="l26.46">     //  resolved...</span>
<a href="#l26.47"></a><span id="l26.47">     // 1) JSON does not walk the __proto__ chain; there is no need to clobber</span>
<a href="#l26.48"></a><span id="l26.48">     //   it.</span>
<a href="#l26.49"></a><span id="l26.49">     // 2) Our net mutation is sorta redundant messageObjects alongside</span>
<a href="#l26.50"></a><span id="l26.50">     //   msgObjects, although we only serialize one.</span>
<a href="#l26.51"></a><span id="l26.51">     let origMessageObjects = message.messageObjects;</span>
<a href="#l26.52"></a><span id="l26.52">     message.messageObjects = [];</span>
<a href="#l26.53"></a><span id="l26.53">     let reProto = [];</span>
<a href="#l26.54"></a><span id="l26.54" class="difflineminus">-    for each (let [, messageObject] in Iterator(origMessageObjects)) {</span>
<a href="#l26.55"></a><span id="l26.55" class="difflineplus">+    for (let messageObject of origMessageObjects) {</span>
<a href="#l26.56"></a><span id="l26.56">       if (messageObject)</span>
<a href="#l26.57"></a><span id="l26.57">         if (messageObject._jsonMe) {</span>
<a href="#l26.58"></a><span id="l26.58">           message.messageObjects.push(messageObject);</span>
<a href="#l26.59"></a><span id="l26.59"> // FIXME: the commented out code should be fixed in a better way.</span>
<a href="#l26.60"></a><span id="l26.60"> // See bug 984539: find a good way to avoid JSONing the impl in log4moz</span>
<a href="#l26.61"></a><span id="l26.61"> //          // temporarily strip the prototype to avoid JSONing the impl.</span>
<a href="#l26.62"></a><span id="l26.62"> //          reProto.push([messageObject, messageObject.__proto__]);</span>
<a href="#l26.63"></a><span id="l26.63"> //          messageObject.__proto__ = undefined;</span>
<a href="#l26.64"></a><span id="l26.64">         }</span>
<a href="#l26.65"></a><span id="l26.65">         else</span>
<a href="#l26.66"></a><span id="l26.66">           message.messageObjects.push(messageObject.toString());</span>
<a href="#l26.67"></a><span id="l26.67">       else</span>
<a href="#l26.68"></a><span id="l26.68">         message.messageObjects.push(messageObject);</span>
<a href="#l26.69"></a><span id="l26.69">     }</span>
<a href="#l26.70"></a><span id="l26.70">     let encoded = JSON.stringify(message) + &quot;\r\n&quot;;</span>
<a href="#l26.71"></a><span id="l26.71">     message.msgObjects = origMessageObjects;</span>
<a href="#l26.72"></a><span id="l26.72" class="difflineminus">-//    for each (let [,objectAndProtoPair] in Iterator (reProto)) {</span>
<a href="#l26.73"></a><span id="l26.73" class="difflineplus">+//    for (let objectAndProtoPair of reProto) {</span>
<a href="#l26.74"></a><span id="l26.74"> //      objectAndProtoPair[0].__proto__ = objectAndProtoPair[1];</span>
<a href="#l26.75"></a><span id="l26.75"> //    }</span>
<a href="#l26.76"></a><span id="l26.76">     return encoded;</span>
<a href="#l26.77"></a><span id="l26.77">   }</span>
<a href="#l26.78"></a><span id="l26.78"> };</span>
<a href="#l26.79"></a><span id="l26.79"> </span>
<a href="#l26.80"></a><span id="l26.80"> </span>
<a href="#l26.81"></a><span id="l26.81"> /*</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/mailnews/db/gloda/modules/mimemsg.js</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/mimemsg.js</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -47,18 +47,18 @@ var shutdownCleanupObserver = {</span>
<a href="#l27.4"></a><span id="l27.4">     this._initialized = true;</span>
<a href="#l27.5"></a><span id="l27.5">   },</span>
<a href="#l27.6"></a><span id="l27.6"> </span>
<a href="#l27.7"></a><span id="l27.7">   observe: function mimemsg_shutdownCleanupObserver_observe(</span>
<a href="#l27.8"></a><span id="l27.8">       aSubject, aTopic, aData) {</span>
<a href="#l27.9"></a><span id="l27.9">     if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l27.10"></a><span id="l27.10">       Services.obs.removeObserver(this, &quot;quit-application&quot;);</span>
<a href="#l27.11"></a><span id="l27.11"> </span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-      for each (let [, streamListener] in</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineminus">-                Iterator(activeStreamListeners)) {</span>
<a href="#l27.14"></a><span id="l27.14" class="difflineplus">+      for (let uri in activeStreamListeners) {</span>
<a href="#l27.15"></a><span id="l27.15" class="difflineplus">+        let streamListener = activeStreamListeners[uri];</span>
<a href="#l27.16"></a><span id="l27.16">         if (streamListener._request)</span>
<a href="#l27.17"></a><span id="l27.17">           streamListener._request.cancel(Cr.NS_BINDING_ABORTED);</span>
<a href="#l27.18"></a><span id="l27.18">       }</span>
<a href="#l27.19"></a><span id="l27.19">     }</span>
<a href="#l27.20"></a><span id="l27.20">   }</span>
<a href="#l27.21"></a><span id="l27.21"> };</span>
<a href="#l27.22"></a><span id="l27.22"> </span>
<a href="#l27.23"></a><span id="l27.23"> function CallbackStreamListener(aMsgHdr, aCallbackThis, aCallback) {</span>
<a href="#l27.24"></a><span id="l27.24" class="difflineat">@@ -323,17 +323,18 @@ var HeaderHandlerBase = {</span>
<a href="#l27.25"></a><span id="l27.25">   has: function MimeMessage_has(aHeaderName) {</span>
<a href="#l27.26"></a><span id="l27.26">     let lowerHeader = aHeaderName.toLowerCase();</span>
<a href="#l27.27"></a><span id="l27.27">     return lowerHeader in this.headers;</span>
<a href="#l27.28"></a><span id="l27.28">   },</span>
<a href="#l27.29"></a><span id="l27.29">   _prettyHeaderString: function MimeMessage__prettyHeaderString(aIndent) {</span>
<a href="#l27.30"></a><span id="l27.30">     if (aIndent === undefined)</span>
<a href="#l27.31"></a><span id="l27.31">       aIndent = &quot;&quot;;</span>
<a href="#l27.32"></a><span id="l27.32">     let s = &quot;&quot;;</span>
<a href="#l27.33"></a><span id="l27.33" class="difflineminus">-    for each (let [header, values] in Iterator(this.headers)) {</span>
<a href="#l27.34"></a><span id="l27.34" class="difflineplus">+    for (let header in this.headers) {</span>
<a href="#l27.35"></a><span id="l27.35" class="difflineplus">+      let values = this.headers[header];</span>
<a href="#l27.36"></a><span id="l27.36">       s += &quot;\n        &quot; + aIndent + header + &quot;: &quot; + values;</span>
<a href="#l27.37"></a><span id="l27.37">     }</span>
<a href="#l27.38"></a><span id="l27.38">     return s;</span>
<a href="#l27.39"></a><span id="l27.39">   }</span>
<a href="#l27.40"></a><span id="l27.40"> };</span>
<a href="#l27.41"></a><span id="l27.41"> </span>
<a href="#l27.42"></a><span id="l27.42"> /**</span>
<a href="#l27.43"></a><span id="l27.43">  * @ivar partName The MIME part, ex &quot;1.2.2.1&quot;.  The partName of a (top-level)</span>
<a href="#l27.44"></a><span id="l27.44" class="difflineat">@@ -379,25 +380,25 @@ MimeMessage.prototype = {</span>
<a href="#l27.45"></a><span id="l27.45">    *    contained in inner messages won't be shown.</span>
<a href="#l27.46"></a><span id="l27.46">    */</span>
<a href="#l27.47"></a><span id="l27.47">   get allUserAttachments() {</span>
<a href="#l27.48"></a><span id="l27.48">     if (this.url)</span>
<a href="#l27.49"></a><span id="l27.49">       // The jsmimeemitter camouflaged us as a MimeAttachment</span>
<a href="#l27.50"></a><span id="l27.50">       return [this];</span>
<a href="#l27.51"></a><span id="l27.51">     else</span>
<a href="#l27.52"></a><span id="l27.52">       // Why is there no flatten method for arrays?</span>
<a href="#l27.53"></a><span id="l27.53" class="difflineminus">-      return [child.allUserAttachments for each ([, child] in Iterator(this.parts))]</span>
<a href="#l27.54"></a><span id="l27.54" class="difflineplus">+      return this.parts.map(child =&gt; child.allUserAttachments)</span>
<a href="#l27.55"></a><span id="l27.55">         .reduce((a, b) =&gt; a.concat(b), []);</span>
<a href="#l27.56"></a><span id="l27.56">   },</span>
<a href="#l27.57"></a><span id="l27.57"> </span>
<a href="#l27.58"></a><span id="l27.58">   /**</span>
<a href="#l27.59"></a><span id="l27.59">    * @return the total size of this message, that is, the size of all subparts</span>
<a href="#l27.60"></a><span id="l27.60">    */</span>
<a href="#l27.61"></a><span id="l27.61">   get size () {</span>
<a href="#l27.62"></a><span id="l27.62" class="difflineminus">-    return [child.size for each ([, child] in Iterator(this.parts))]</span>
<a href="#l27.63"></a><span id="l27.63" class="difflineplus">+    return this.parts.map(child =&gt; child.size)</span>
<a href="#l27.64"></a><span id="l27.64">       .reduce((a, b) =&gt; a + Math.max(b, 0), 0);</span>
<a href="#l27.65"></a><span id="l27.65">   },</span>
<a href="#l27.66"></a><span id="l27.66"> </span>
<a href="#l27.67"></a><span id="l27.67">   /**</span>
<a href="#l27.68"></a><span id="l27.68">    * In the case of attached messages, libmime considers them as attachments,</span>
<a href="#l27.69"></a><span id="l27.69">    * and if the body is, say, quoted-printable encoded, then libmime will start</span>
<a href="#l27.70"></a><span id="l27.70">    * counting bytes and notify the js mime emitter about it. The JS mime emitter</span>
<a href="#l27.71"></a><span id="l27.71">    * being a nice guy, it will try to set a size on us. While this is the</span>
<a href="#l27.72"></a><span id="l27.72" class="difflineat">@@ -416,17 +417,17 @@ MimeMessage.prototype = {</span>
<a href="#l27.73"></a><span id="l27.73">    *    as text/html are converted to plaintext form first.  In other words,</span>
<a href="#l27.74"></a><span id="l27.74">    *    if we see a multipart/alternative with a text/plain, we take the</span>
<a href="#l27.75"></a><span id="l27.75">    *    text/plain.  If we see a text/html without an alternative, we convert</span>
<a href="#l27.76"></a><span id="l27.76">    *    that to text.</span>
<a href="#l27.77"></a><span id="l27.77">    */</span>
<a href="#l27.78"></a><span id="l27.78">   coerceBodyToPlaintext:</span>
<a href="#l27.79"></a><span id="l27.79">       function MimeMessage_coerceBodyToPlaintext(aMsgFolder) {</span>
<a href="#l27.80"></a><span id="l27.80">     let bodies = [];</span>
<a href="#l27.81"></a><span id="l27.81" class="difflineminus">-    for each (let [, part] in Iterator(this.parts)) {</span>
<a href="#l27.82"></a><span id="l27.82" class="difflineplus">+    for (let part of this.parts) {</span>
<a href="#l27.83"></a><span id="l27.83">       // an undefined value for something not having the method is fine</span>
<a href="#l27.84"></a><span id="l27.84">       let body = part.coerceBodyToPlaintext &amp;&amp;</span>
<a href="#l27.85"></a><span id="l27.85">                  part.coerceBodyToPlaintext(aMsgFolder);</span>
<a href="#l27.86"></a><span id="l27.86">       if (body)</span>
<a href="#l27.87"></a><span id="l27.87">         bodies.push(body);</span>
<a href="#l27.88"></a><span id="l27.88">     }</span>
<a href="#l27.89"></a><span id="l27.89">     if (bodies)</span>
<a href="#l27.90"></a><span id="l27.90">       return bodies.join(&quot;&quot;);</span>
<a href="#l27.91"></a><span id="l27.91" class="difflineat">@@ -485,32 +486,32 @@ MimeContainer.prototype = {</span>
<a href="#l27.92"></a><span id="l27.92">     let results = [];</span>
<a href="#l27.93"></a><span id="l27.93">     for (let iChild = 0; iChild &lt; this.parts.length; iChild++) {</span>
<a href="#l27.94"></a><span id="l27.94">       let child = this.parts[iChild];</span>
<a href="#l27.95"></a><span id="l27.95">       results = results.concat(child.allAttachments);</span>
<a href="#l27.96"></a><span id="l27.96">     }</span>
<a href="#l27.97"></a><span id="l27.97">     return results;</span>
<a href="#l27.98"></a><span id="l27.98">   },</span>
<a href="#l27.99"></a><span id="l27.99">   get allUserAttachments () {</span>
<a href="#l27.100"></a><span id="l27.100" class="difflineminus">-    return [child.allUserAttachments for each ([, child] in Iterator(this.parts))]</span>
<a href="#l27.101"></a><span id="l27.101" class="difflineplus">+    return this.parts.map(child =&gt; child.allUserAttachments)</span>
<a href="#l27.102"></a><span id="l27.102">       .reduce((a, b) =&gt; a.concat(b), []);</span>
<a href="#l27.103"></a><span id="l27.103">   },</span>
<a href="#l27.104"></a><span id="l27.104">   get size () {</span>
<a href="#l27.105"></a><span id="l27.105" class="difflineminus">-    return [child.size for each ([, child] in Iterator(this.parts))]</span>
<a href="#l27.106"></a><span id="l27.106" class="difflineplus">+    return this.parts.map(child =&gt; child.size)</span>
<a href="#l27.107"></a><span id="l27.107">       .reduce((a, b) =&gt; a + Math.max(b, 0), 0);</span>
<a href="#l27.108"></a><span id="l27.108">   },</span>
<a href="#l27.109"></a><span id="l27.109">   set size (whatever) {</span>
<a href="#l27.110"></a><span id="l27.110">     // nop</span>
<a href="#l27.111"></a><span id="l27.111">   },</span>
<a href="#l27.112"></a><span id="l27.112">   coerceBodyToPlaintext:</span>
<a href="#l27.113"></a><span id="l27.113">       function MimeContainer_coerceBodyToPlaintext(aMsgFolder) {</span>
<a href="#l27.114"></a><span id="l27.114">     if (this.contentType == &quot;multipart/alternative&quot;) {</span>
<a href="#l27.115"></a><span id="l27.115">       let htmlPart;</span>
<a href="#l27.116"></a><span id="l27.116">       // pick the text/plain if we can find one, otherwise remember the HTML one</span>
<a href="#l27.117"></a><span id="l27.117" class="difflineminus">-      for each (let [, part] in Iterator(this.parts)) {</span>
<a href="#l27.118"></a><span id="l27.118" class="difflineplus">+      for (let part of this.parts) {</span>
<a href="#l27.119"></a><span id="l27.119">         if (part.contentType == &quot;text/plain&quot;)</span>
<a href="#l27.120"></a><span id="l27.120">           return part.body;</span>
<a href="#l27.121"></a><span id="l27.121">         if (part.contentType == &quot;text/html&quot;)</span>
<a href="#l27.122"></a><span id="l27.122">           htmlPart = part;</span>
<a href="#l27.123"></a><span id="l27.123">         // text/enriched gets transformed into HTML, use it if we don't already</span>
<a href="#l27.124"></a><span id="l27.124">         //  have an HTML part.</span>
<a href="#l27.125"></a><span id="l27.125">         else if (!htmlPart &amp;&amp; part.contentType == &quot;text/enriched&quot;)</span>
<a href="#l27.126"></a><span id="l27.126"> 	  htmlPart = part;</span>
<a href="#l27.127"></a><span id="l27.127" class="difflineat">@@ -625,25 +626,25 @@ function MimeUnknown(aContentType) {</span>
<a href="#l27.128"></a><span id="l27.128">   // and we need to ensure all other encrypted parts are children of this</span>
<a href="#l27.129"></a><span id="l27.129">   // topmost part.</span>
<a href="#l27.130"></a><span id="l27.130">   this.parts = [];</span>
<a href="#l27.131"></a><span id="l27.131"> }</span>
<a href="#l27.132"></a><span id="l27.132"> </span>
<a href="#l27.133"></a><span id="l27.133"> MimeUnknown.prototype = {</span>
<a href="#l27.134"></a><span id="l27.134">   __proto__: HeaderHandlerBase,</span>
<a href="#l27.135"></a><span id="l27.135">   get allAttachments() {</span>
<a href="#l27.136"></a><span id="l27.136" class="difflineminus">-    return [child.allAttachments for each ([, child] in Iterator(this.parts))]</span>
<a href="#l27.137"></a><span id="l27.137" class="difflineplus">+    return this.parts.map(child =&gt; child.allAttachments)</span>
<a href="#l27.138"></a><span id="l27.138">       .reduce((a, b) =&gt; a.concat(b), []);</span>
<a href="#l27.139"></a><span id="l27.139">   },</span>
<a href="#l27.140"></a><span id="l27.140">   get allUserAttachments() {</span>
<a href="#l27.141"></a><span id="l27.141" class="difflineminus">-    return [child.allUserAttachments for each ([, child] in Iterator(this.parts))]</span>
<a href="#l27.142"></a><span id="l27.142" class="difflineplus">+    return this.parts.map(child =&gt; child.allUserAttachments)</span>
<a href="#l27.143"></a><span id="l27.143">       .reduce((a, b) =&gt; a.concat(b), []);</span>
<a href="#l27.144"></a><span id="l27.144">   },</span>
<a href="#l27.145"></a><span id="l27.145">   get size() {</span>
<a href="#l27.146"></a><span id="l27.146" class="difflineminus">-    return this._size + [child.size for each ([, child] in Iterator(this.parts))]</span>
<a href="#l27.147"></a><span id="l27.147" class="difflineplus">+    return this._size + this.parts.map(child =&gt; child.size)</span>
<a href="#l27.148"></a><span id="l27.148">       .reduce((a, b) =&gt; a + Math.max(b, 0), 0);</span>
<a href="#l27.149"></a><span id="l27.149">   },</span>
<a href="#l27.150"></a><span id="l27.150">   set size(aSize) {</span>
<a href="#l27.151"></a><span id="l27.151">     this._size = aSize;</span>
<a href="#l27.152"></a><span id="l27.152">   },</span>
<a href="#l27.153"></a><span id="l27.153">   prettyString: function MimeUnknown_prettyString(aVerbose, aIndent,</span>
<a href="#l27.154"></a><span id="l27.154">                                                   aDumpBody) {</span>
<a href="#l27.155"></a><span id="l27.155">     let nextIndent = aIndent + &quot;  &quot;;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/mailnews/db/gloda/modules/msg_search.js</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/msg_search.js</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -138,28 +138,28 @@ var COLUMN_MULTIPLE_MATCH_SCORES = [1, 0</span>
<a href="#l28.4"></a><span id="l28.4"> var COLUMN_MULTIPLE_MATCH_LIMIT = [10, 0, 0, 0, 0];</span>
<a href="#l28.5"></a><span id="l28.5"> </span>
<a href="#l28.6"></a><span id="l28.6"> /**</span>
<a href="#l28.7"></a><span id="l28.7">  * Score the message on its offsets (from stashedColumns).</span>
<a href="#l28.8"></a><span id="l28.8">  */</span>
<a href="#l28.9"></a><span id="l28.9"> function scoreOffsets(aMessage, aContext) {</span>
<a href="#l28.10"></a><span id="l28.10">   let score = 0;</span>
<a href="#l28.11"></a><span id="l28.11"> </span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-  let termTemplate = [0 for each (term in Iterator(aContext.terms, true))];</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+  let termTemplate = aContext.terms.map(_ =&gt; 0);</span>
<a href="#l28.14"></a><span id="l28.14">   // for each column, a list of the incidence of each term</span>
<a href="#l28.15"></a><span id="l28.15">   let columnTermIncidence = [termTemplate.concat(),</span>
<a href="#l28.16"></a><span id="l28.16">                              termTemplate.concat(),</span>
<a href="#l28.17"></a><span id="l28.17">                              termTemplate.concat(),</span>
<a href="#l28.18"></a><span id="l28.18">                              termTemplate.concat(),</span>
<a href="#l28.19"></a><span id="l28.19">                              termTemplate.concat()];</span>
<a href="#l28.20"></a><span id="l28.20"> </span>
<a href="#l28.21"></a><span id="l28.21">   // we need a friendlyParseInt because otherwise the radix stuff happens</span>
<a href="#l28.22"></a><span id="l28.22">   //  because of the extra arguments map parses.  curse you, map!</span>
<a href="#l28.23"></a><span id="l28.23">   let offsetNums =</span>
<a href="#l28.24"></a><span id="l28.24" class="difflineminus">-    [parseInt(x) for each (x in aContext.stashedColumns[aMessage.id][0].split(&quot; &quot;))];</span>
<a href="#l28.25"></a><span id="l28.25" class="difflineplus">+    aContext.stashedColumns[aMessage.id][0].split(&quot; &quot;).map(x =&gt; parseInt(x));</span>
<a href="#l28.26"></a><span id="l28.26">   for (let i=0; i &lt; offsetNums.length; i += 4) {</span>
<a href="#l28.27"></a><span id="l28.27">     let columnIndex = offsetNums[i];</span>
<a href="#l28.28"></a><span id="l28.28">     let termIndex = offsetNums[i+1];</span>
<a href="#l28.29"></a><span id="l28.29">     columnTermIncidence[columnIndex][termIndex]++;</span>
<a href="#l28.30"></a><span id="l28.30">   }</span>
<a href="#l28.31"></a><span id="l28.31"> </span>
<a href="#l28.32"></a><span id="l28.32">   for (let iColumn = 0; iColumn &lt; COLUMN_ALL_MATCH_SCORES.length; iColumn++) {</span>
<a href="#l28.33"></a><span id="l28.33">     let termIncidence = columnTermIncidence[iColumn];</span>
<a href="#l28.34"></a><span id="l28.34" class="difflineat">@@ -263,17 +263,17 @@ GlodaMsgSearcher.prototype = {</span>
<a href="#l28.35"></a><span id="l28.35">       limitClauseAlreadyIncluded: true,</span>
<a href="#l28.36"></a><span id="l28.36">       // osets is 0-based column number 14 (volatile to column changes)</span>
<a href="#l28.37"></a><span id="l28.37">       // save the offset column for extra analysis</span>
<a href="#l28.38"></a><span id="l28.38">       stashColumns: [14]</span>
<a href="#l28.39"></a><span id="l28.39">     });</span>
<a href="#l28.40"></a><span id="l28.40"> </span>
<a href="#l28.41"></a><span id="l28.41">     let fulltextQueryString = &quot;&quot;;</span>
<a href="#l28.42"></a><span id="l28.42"> </span>
<a href="#l28.43"></a><span id="l28.43" class="difflineminus">-    for each (let [iTerm, term] in Iterator(this.fulltextTerms)) {</span>
<a href="#l28.44"></a><span id="l28.44" class="difflineplus">+    for (let [iTerm, term] of this.fulltextTerms.entries()) {</span>
<a href="#l28.45"></a><span id="l28.45">       if (iTerm)</span>
<a href="#l28.46"></a><span id="l28.46">         fulltextQueryString += this.andTerms ? &quot; &quot; : &quot; OR &quot;;</span>
<a href="#l28.47"></a><span id="l28.47"> </span>
<a href="#l28.48"></a><span id="l28.48">       // Put our term in quotes.  This is needed for the tokenizer to be able</span>
<a href="#l28.49"></a><span id="l28.49">       //  to do useful things.  The exception is people clever enough to use</span>
<a href="#l28.50"></a><span id="l28.50">       //  NEAR.</span>
<a href="#l28.51"></a><span id="l28.51">       if (/^NEAR(\/\d+)?$/.test(term))</span>
<a href="#l28.52"></a><span id="l28.52">         fulltextQueryString += term;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/mailnews/db/gloda/modules/noun_freetag.js</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/noun_freetag.js</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -41,30 +41,30 @@ var FreeTagNoun = {</span>
<a href="#l29.4"></a><span id="l29.4">   },</span>
<a href="#l29.5"></a><span id="l29.5">   removeListener: function(aListener) {</span>
<a href="#l29.6"></a><span id="l29.6">     let index = this._listeners.indexOf(aListener);</span>
<a href="#l29.7"></a><span id="l29.7">     if (index &gt;=0)</span>
<a href="#l29.8"></a><span id="l29.8">       this._listeners.splice(index, 1);</span>
<a href="#l29.9"></a><span id="l29.9">   },</span>
<a href="#l29.10"></a><span id="l29.10"> </span>
<a href="#l29.11"></a><span id="l29.11">   populateKnownFreeTags: function() {</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-    for each (let [,attr] in Iterator(this.objectNounOfAttributes)) {</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+    for (let attr of this.objectNounOfAttributes) {</span>
<a href="#l29.14"></a><span id="l29.14">       let attrDB = attr.dbDef;</span>
<a href="#l29.15"></a><span id="l29.15">       for (let param in attrDB.parameterBindings) {</span>
<a href="#l29.16"></a><span id="l29.16">         this.getFreeTag(param);</span>
<a href="#l29.17"></a><span id="l29.17">       }</span>
<a href="#l29.18"></a><span id="l29.18">     }</span>
<a href="#l29.19"></a><span id="l29.19">   },</span>
<a href="#l29.20"></a><span id="l29.20"> </span>
<a href="#l29.21"></a><span id="l29.21">   knownFreeTags: {},</span>
<a href="#l29.22"></a><span id="l29.22">   getFreeTag: function(aTagName) {</span>
<a href="#l29.23"></a><span id="l29.23">     let tag = this.knownFreeTags[aTagName];</span>
<a href="#l29.24"></a><span id="l29.24">     if (!tag) {</span>
<a href="#l29.25"></a><span id="l29.25">       tag = this.knownFreeTags[aTagName] = new FreeTag(aTagName);</span>
<a href="#l29.26"></a><span id="l29.26" class="difflineminus">-      for each (let [iListener, listener] in Iterator(this._listeners))</span>
<a href="#l29.27"></a><span id="l29.27" class="difflineplus">+      for (let listener of this._listeners)</span>
<a href="#l29.28"></a><span id="l29.28">         listener.onFreeTagAdded(tag);</span>
<a href="#l29.29"></a><span id="l29.29">     }</span>
<a href="#l29.30"></a><span id="l29.30">     return tag;</span>
<a href="#l29.31"></a><span id="l29.31">   },</span>
<a href="#l29.32"></a><span id="l29.32"> </span>
<a href="#l29.33"></a><span id="l29.33">   comparator: function gloda_noun_freetag_comparator(a, b) {</span>
<a href="#l29.34"></a><span id="l29.34">     if (a == null) {</span>
<a href="#l29.35"></a><span id="l29.35">       if (b == null)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/mailnews/db/gloda/modules/noun_mimetype.js</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/noun_mimetype.js</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -136,31 +136,32 @@ var MimeTypeNoun = {</span>
<a href="#l30.4"></a><span id="l30.4">     let mimecatNS = {};</span>
<a href="#l30.5"></a><span id="l30.5">     Cu.import(&quot;resource:///modules/gloda/mimeTypeCategories.js&quot;,</span>
<a href="#l30.6"></a><span id="l30.6">               mimecatNS);</span>
<a href="#l30.7"></a><span id="l30.7">     let mcm = mimecatNS.MimeCategoryMapping;</span>
<a href="#l30.8"></a><span id="l30.8"> </span>
<a href="#l30.9"></a><span id="l30.9">     let mimeTypeToCategory = this._mimeTypeToCategory;</span>
<a href="#l30.10"></a><span id="l30.10"> </span>
<a href="#l30.11"></a><span id="l30.11">     function procMapObj(aSubTree, aCategories) {</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineminus">-      for each (let [key, value] in Iterator(aSubTree)) {</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineplus">+      for (let key in aSubTree) {</span>
<a href="#l30.14"></a><span id="l30.14" class="difflineplus">+        let value = aSubTree[key];</span>
<a href="#l30.15"></a><span id="l30.15">         // Add this category to our nested categories list.  Use concat since</span>
<a href="#l30.16"></a><span id="l30.16">         //  the list will be long-lived and each list needs to be distinct.</span>
<a href="#l30.17"></a><span id="l30.17">         let categories = aCategories.concat();</span>
<a href="#l30.18"></a><span id="l30.18">         categories.push(key);</span>
<a href="#l30.19"></a><span id="l30.19"> </span>
<a href="#l30.20"></a><span id="l30.20">         if (categories.length == 1) {</span>
<a href="#l30.21"></a><span id="l30.21">           CategoryStringMap[key] =</span>
<a href="#l30.22"></a><span id="l30.22">             MimeTypeNoun._strings.get(</span>
<a href="#l30.23"></a><span id="l30.23">               &quot;gloda.mimetype.category.&quot; + key + &quot;.label&quot;);</span>
<a href="#l30.24"></a><span id="l30.24">         }</span>
<a href="#l30.25"></a><span id="l30.25"> </span>
<a href="#l30.26"></a><span id="l30.26">         // Is it an array? If so, just process this depth</span>
<a href="#l30.27"></a><span id="l30.27">         if (Array.isArray(value)) {</span>
<a href="#l30.28"></a><span id="l30.28" class="difflineminus">-          for each (let [, mimeTypeStr] in Iterator(value)) {</span>
<a href="#l30.29"></a><span id="l30.29" class="difflineplus">+          for (let mimeTypeStr of value) {</span>
<a href="#l30.30"></a><span id="l30.30">             mimeTypeToCategory[mimeTypeStr] = categories;</span>
<a href="#l30.31"></a><span id="l30.31">           }</span>
<a href="#l30.32"></a><span id="l30.32">         }</span>
<a href="#l30.33"></a><span id="l30.33">         // it's yet another sub-tree branch</span>
<a href="#l30.34"></a><span id="l30.34">         else {</span>
<a href="#l30.35"></a><span id="l30.35">           procMapObj(value, categories);</span>
<a href="#l30.36"></a><span id="l30.36">         }</span>
<a href="#l30.37"></a><span id="l30.37">       }</span>
<a href="#l30.38"></a><span id="l30.38" class="difflineat">@@ -228,17 +229,17 @@ var MimeTypeNoun = {</span>
<a href="#l30.39"></a><span id="l30.39">       new MimeType(blockBottom, &quot;!category-dummy!&quot;, aCategory,</span>
<a href="#l30.40"></a><span id="l30.40">                    &quot;!category-dummy!/&quot; + aCategory, aCategory),</span>
<a href="#l30.41"></a><span id="l30.41">       new MimeType(blockTop, &quot;!category-dummy!&quot;, aCategory,</span>
<a href="#l30.42"></a><span id="l30.42">                    &quot;!category-dummy!/&quot; + aCategory, aCategory)</span>
<a href="#l30.43"></a><span id="l30.43">     ];</span>
<a href="#l30.44"></a><span id="l30.44">   },</span>
<a href="#l30.45"></a><span id="l30.45"> </span>
<a href="#l30.46"></a><span id="l30.46">   _processMimeTypes: function MimeTypeNoun__processMimeTypes(aMimeTypes) {</span>
<a href="#l30.47"></a><span id="l30.47" class="difflineminus">-    for each (let [, mimeType] in Iterator(aMimeTypes)) {</span>
<a href="#l30.48"></a><span id="l30.48" class="difflineplus">+    for (let mimeType of aMimeTypes) {</span>
<a href="#l30.49"></a><span id="l30.49">       if (mimeType.id &gt; this._highID)</span>
<a href="#l30.50"></a><span id="l30.50">         this._highID = mimeType.id;</span>
<a href="#l30.51"></a><span id="l30.51">       this._mimeTypes[mimeType] = mimeType;</span>
<a href="#l30.52"></a><span id="l30.52">       this._mimeTypesByID[mimeType.id] = mimeType;</span>
<a href="#l30.53"></a><span id="l30.53"> </span>
<a href="#l30.54"></a><span id="l30.54">       let typeBlock = mimeType.id - (mimeType.id % this.TYPE_BLOCK_SIZE);</span>
<a href="#l30.55"></a><span id="l30.55">       let blockHighID = (mimeType.category in this._mimeTypeHighID) ?</span>
<a href="#l30.56"></a><span id="l30.56">                           this._mimeTypeHighID[mimeType.category] : undefined;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/mailnews/db/gloda/modules/query.js</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/query.js</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -183,29 +183,29 @@ GlodaQueryClass.prototype = {</span>
<a href="#l31.4"></a><span id="l31.4">                 testValues[0] != null)</span>
<a href="#l31.5"></a><span id="l31.5">               continue;</span>
<a href="#l31.6"></a><span id="l31.6"> </span>
<a href="#l31.7"></a><span id="l31.7">             // If there are no test values and the empty set is significant,</span>
<a href="#l31.8"></a><span id="l31.8">             //  then check if any of the constraint values are null (our</span>
<a href="#l31.9"></a><span id="l31.9">             //  empty indicator.)</span>
<a href="#l31.10"></a><span id="l31.10">             if (testValues.length == 0 &amp;&amp; attrDef.emptySetIsSignificant) {</span>
<a href="#l31.11"></a><span id="l31.11">               let foundEmptySetSignifier = false;</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineminus">-              for each (let [,constraintValue] in Iterator(constraintValues)) {</span>
<a href="#l31.13"></a><span id="l31.13" class="difflineplus">+              for (let constraintValue of constraintValues) {</span>
<a href="#l31.14"></a><span id="l31.14">                 if (constraintValue == null) {</span>
<a href="#l31.15"></a><span id="l31.15">                   foundEmptySetSignifier = true;</span>
<a href="#l31.16"></a><span id="l31.16">                   break;</span>
<a href="#l31.17"></a><span id="l31.17">                 }</span>
<a href="#l31.18"></a><span id="l31.18">               }</span>
<a href="#l31.19"></a><span id="l31.19">               if (foundEmptySetSignifier)</span>
<a href="#l31.20"></a><span id="l31.20">                 continue;</span>
<a href="#l31.21"></a><span id="l31.21">             }</span>
<a href="#l31.22"></a><span id="l31.22"> </span>
<a href="#l31.23"></a><span id="l31.23">             let foundMatch = false;</span>
<a href="#l31.24"></a><span id="l31.24" class="difflineminus">-            for each (let [,testValue] in Iterator(testValues)) {</span>
<a href="#l31.25"></a><span id="l31.25" class="difflineminus">-              for each (let [,value] in Iterator(constraintValues)) {</span>
<a href="#l31.26"></a><span id="l31.26" class="difflineplus">+            for (let testValue of testValues) {</span>
<a href="#l31.27"></a><span id="l31.27" class="difflineplus">+              for (let value of constraintValues) {</span>
<a href="#l31.28"></a><span id="l31.28">                 if (objectNounDef.equals(testValue, value)) {</span>
<a href="#l31.29"></a><span id="l31.29">                   foundMatch = true;</span>
<a href="#l31.30"></a><span id="l31.30">                   break;</span>
<a href="#l31.31"></a><span id="l31.31">                 }</span>
<a href="#l31.32"></a><span id="l31.32">               }</span>
<a href="#l31.33"></a><span id="l31.33">               if (foundMatch)</span>
<a href="#l31.34"></a><span id="l31.34">                 break;</span>
<a href="#l31.35"></a><span id="l31.35">             }</span>
<a href="#l31.36"></a><span id="l31.36" class="difflineat">@@ -233,30 +233,30 @@ GlodaQueryClass.prototype = {</span>
<a href="#l31.37"></a><span id="l31.37">             if (constraintValues.length == 0 &amp;&amp; testValues.length &amp;&amp;</span>
<a href="#l31.38"></a><span id="l31.38">                 testValues[0] != null)</span>
<a href="#l31.39"></a><span id="l31.39">               continue;</span>
<a href="#l31.40"></a><span id="l31.40">             // If there are no test values and the empty set is significant,</span>
<a href="#l31.41"></a><span id="l31.41">             //  then check if any of the constraint values are null (our</span>
<a href="#l31.42"></a><span id="l31.42">             //  empty indicator.)</span>
<a href="#l31.43"></a><span id="l31.43">             if (testValues.length == 0 &amp;&amp; attrDef.emptySetIsSignificant) {</span>
<a href="#l31.44"></a><span id="l31.44">               let foundEmptySetSignifier = false;</span>
<a href="#l31.45"></a><span id="l31.45" class="difflineminus">-              for each (let [,constraintValue] in Iterator(constraintValues)) {</span>
<a href="#l31.46"></a><span id="l31.46" class="difflineplus">+              for (let constraintValue of constraintValues) {</span>
<a href="#l31.47"></a><span id="l31.47">                 if (constraintValue == null) {</span>
<a href="#l31.48"></a><span id="l31.48">                   foundEmptySetSignifier = true;</span>
<a href="#l31.49"></a><span id="l31.49">                   break;</span>
<a href="#l31.50"></a><span id="l31.50">                 }</span>
<a href="#l31.51"></a><span id="l31.51">               }</span>
<a href="#l31.52"></a><span id="l31.52">               if (foundEmptySetSignifier)</span>
<a href="#l31.53"></a><span id="l31.53">                 continue;</span>
<a href="#l31.54"></a><span id="l31.54">             }</span>
<a href="#l31.55"></a><span id="l31.55"> </span>
<a href="#l31.56"></a><span id="l31.56">             let foundMatch = false;</span>
<a href="#l31.57"></a><span id="l31.57" class="difflineminus">-            for each (let [,testValue] in Iterator(testValues)) {</span>
<a href="#l31.58"></a><span id="l31.58" class="difflineplus">+            for (let testValue of testValues) {</span>
<a href="#l31.59"></a><span id="l31.59">               let [aParam, aValue] = objectNounDef.toParamAndValue(testValue);</span>
<a href="#l31.60"></a><span id="l31.60" class="difflineminus">-              for each (let [,value] in Iterator(constraintValues)) {</span>
<a href="#l31.61"></a><span id="l31.61" class="difflineplus">+              for (let value of constraintValues) {</span>
<a href="#l31.62"></a><span id="l31.62">                 // skip empty set check sentinel values</span>
<a href="#l31.63"></a><span id="l31.63">                 if (value == null &amp;&amp; attrDef.emptySetIsSignificant)</span>
<a href="#l31.64"></a><span id="l31.64">                   continue;</span>
<a href="#l31.65"></a><span id="l31.65">                 let [bParam, bValue] = objectNounDef.toParamAndValue(value);</span>
<a href="#l31.66"></a><span id="l31.66">                 if (aParam == bParam &amp;&amp; aValue == bValue) {</span>
<a href="#l31.67"></a><span id="l31.67">                   foundMatch = true;</span>
<a href="#l31.68"></a><span id="l31.68">                   break;</span>
<a href="#l31.69"></a><span id="l31.69">                 }</span>
<a href="#l31.70"></a><span id="l31.70" class="difflineat">@@ -278,19 +278,19 @@ GlodaQueryClass.prototype = {</span>
<a href="#l31.71"></a><span id="l31.71">           if (!(boundName in aObj))</span>
<a href="#l31.72"></a><span id="l31.72">               testValues = [];</span>
<a href="#l31.73"></a><span id="l31.73">           else if (attrDef.singular)</span>
<a href="#l31.74"></a><span id="l31.74">             testValues = [aObj[boundName]];</span>
<a href="#l31.75"></a><span id="l31.75">           else</span>
<a href="#l31.76"></a><span id="l31.76">             testValues = aObj[boundName];</span>
<a href="#l31.77"></a><span id="l31.77"> </span>
<a href="#l31.78"></a><span id="l31.78">           let foundMatch = false;</span>
<a href="#l31.79"></a><span id="l31.79" class="difflineminus">-          for each (let [,testValue] in Iterator(testValues)) {</span>
<a href="#l31.80"></a><span id="l31.80" class="difflineplus">+          for (let testValue of testValues) {</span>
<a href="#l31.81"></a><span id="l31.81">             let [tParam, tValue] = objectNounDef.toParamAndValue(testValue);</span>
<a href="#l31.82"></a><span id="l31.82" class="difflineminus">-            for each (let [,rangeTuple] in Iterator(constraintValues)) {</span>
<a href="#l31.83"></a><span id="l31.83" class="difflineplus">+            for (let rangeTuple of constraintValues) {</span>
<a href="#l31.84"></a><span id="l31.84">               let [lowerRValue, upperRValue] = rangeTuple;</span>
<a href="#l31.85"></a><span id="l31.85">               if (lowerRValue == null) {</span>
<a href="#l31.86"></a><span id="l31.86">                 let [upperParam, upperValue] =</span>
<a href="#l31.87"></a><span id="l31.87">                   objectNounDef.toParamAndValue(upperRValue);</span>
<a href="#l31.88"></a><span id="l31.88">                 if (tParam == upperParam &amp;&amp; tValue &lt;= upperValue) {</span>
<a href="#l31.89"></a><span id="l31.89">                   foundMatch = true;</span>
<a href="#l31.90"></a><span id="l31.90">                   break;</span>
<a href="#l31.91"></a><span id="l31.91">                 }</span>
<a href="#l31.92"></a><span id="l31.92" class="difflineat">@@ -323,17 +323,17 @@ GlodaQueryClass.prototype = {</span>
<a href="#l31.93"></a><span id="l31.93">             break;</span>
<a href="#l31.94"></a><span id="l31.94">           }</span>
<a href="#l31.95"></a><span id="l31.95">         }</span>
<a href="#l31.96"></a><span id="l31.96">         // @testpoint gloda.query.test.kConstraintStringLike</span>
<a href="#l31.97"></a><span id="l31.97">         else if (constraintType === GlodaDatastore.kConstraintStringLike) {</span>
<a href="#l31.98"></a><span id="l31.98">           let curIndex = 0;</span>
<a href="#l31.99"></a><span id="l31.99">           let value = (boundName in aObj) ? aObj[boundName] : &quot;&quot;;</span>
<a href="#l31.100"></a><span id="l31.100">           // the attribute must be singular, we don't support arrays of strings.</span>
<a href="#l31.101"></a><span id="l31.101" class="difflineminus">-          for each (let [iValuePart, valuePart] in Iterator(constraintValues)) {</span>
<a href="#l31.102"></a><span id="l31.102" class="difflineplus">+          for (let valuePart of constraintValues) {</span>
<a href="#l31.103"></a><span id="l31.103">             if (typeof valuePart == &quot;string&quot;) {</span>
<a href="#l31.104"></a><span id="l31.104">               let index = value.indexOf(valuePart);</span>
<a href="#l31.105"></a><span id="l31.105">               // if curIndex is null, we just need any match</span>
<a href="#l31.106"></a><span id="l31.106">               // if it's not null, it must match the offset of our found match</span>
<a href="#l31.107"></a><span id="l31.107">               if (curIndex === null) {</span>
<a href="#l31.108"></a><span id="l31.108">                 if (index == -1)</span>
<a href="#l31.109"></a><span id="l31.109">                   querySatisfied = false;</span>
<a href="#l31.110"></a><span id="l31.110">                 else</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/mailnews/db/gloda/modules/suffixtree.js</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/suffixtree.js</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -318,17 +318,17 @@ dump(&quot;  bailing! (bail was: &quot; + bail + &quot;</span>
<a href="#l32.4"></a><span id="l32.4">                                 Math.min(aState.end, this._str.length)); </span>
<a href="#l32.5"></a><span id="l32.5">       dump(aIndent + aKey + &quot;:&quot; + snip + &quot;(&quot; +</span>
<a href="#l32.6"></a><span id="l32.6">            aState.start + &quot;:&quot; + aState.end + &quot;)\n&quot;);</span>
<a href="#l32.7"></a><span id="l32.7">     }</span>
<a href="#l32.8"></a><span id="l32.8">     else</span>
<a href="#l32.9"></a><span id="l32.9">       dump(aIndent + aKey + &quot;: (explicit:&quot; + aState.start + &quot;:&quot; + aState.end +&quot;)\n&quot;);</span>
<a href="#l32.10"></a><span id="l32.10">     let nextIndent = aIndent + &quot;  &quot;;</span>
<a href="#l32.11"></a><span id="l32.11">     let keys = [c for (c in aState) if (c.length == 1)];</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-    for each (let [iKey, key] in Iterator(keys)) {</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineplus">+    for (let key of keys) {</span>
<a href="#l32.14"></a><span id="l32.14">       this.dump(aState[key], nextIndent, key);</span>
<a href="#l32.15"></a><span id="l32.15">     }</span>
<a href="#l32.16"></a><span id="l32.16">   }</span>
<a href="#l32.17"></a><span id="l32.17"> };</span>
<a href="#l32.18"></a><span id="l32.18"> MultiSuffixTree.prototype = SuffixTree.prototype;</span>
<a href="#l32.19"></a><span id="l32.19"> </span>
<a href="#l32.20"></a><span id="l32.20"> function examplar() {</span>
<a href="#l32.21"></a><span id="l32.21">   let names = [&quot;AndrewSmith&quot;, &quot;AndrewJones&quot;, &quot;MarkSmith&quot;, &quot;BryanClark&quot;,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/base_gloda_content.js</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_gloda_content.js</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -95,21 +95,19 @@ var messageInfos = [</span>
<a href="#l33.4"></a><span id="l33.4">            [true, &quot;cheese&quot;],</span>
<a href="#l33.5"></a><span id="l33.5">            [false, &quot;&quot;]]</span>
<a href="#l33.6"></a><span id="l33.6">   }</span>
<a href="#l33.7"></a><span id="l33.7"> ];</span>
<a href="#l33.8"></a><span id="l33.8"> </span>
<a href="#l33.9"></a><span id="l33.9"> /* ===== Tests ===== */</span>
<a href="#l33.10"></a><span id="l33.10"> </span>
<a href="#l33.11"></a><span id="l33.11"> function setup_create_message(info) {</span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">-  info.body = {body: [tupe[1] for each</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineminus">-                      ([, tupe] in Iterator(info.bode))].join(&quot;\r\n&quot;)};</span>
<a href="#l33.14"></a><span id="l33.14" class="difflineminus">-  info.expected = [tupe[1] for each</span>
<a href="#l33.15"></a><span id="l33.15" class="difflineminus">-                   ([, tupe] in Iterator(info.bode)) if</span>
<a href="#l33.16"></a><span id="l33.16" class="difflineminus">-                   (tupe[0])].join(&quot;\n&quot;);</span>
<a href="#l33.17"></a><span id="l33.17" class="difflineplus">+  info.body = {body: info.bode.map(tupe =&gt; tupe[1]).join(&quot;\r\n&quot;)};</span>
<a href="#l33.18"></a><span id="l33.18" class="difflineplus">+  info.expected = info.bode.filter(tupe =&gt; tupe[0]).map(tupe =&gt; tupe[1]).</span>
<a href="#l33.19"></a><span id="l33.19" class="difflineplus">+    join(&quot;\n&quot;);</span>
<a href="#l33.20"></a><span id="l33.20"> </span>
<a href="#l33.21"></a><span id="l33.21">   info._synMsg = msgGen.makeMessage(info);</span>
<a href="#l33.22"></a><span id="l33.22"> }</span>
<a href="#l33.23"></a><span id="l33.23"> </span>
<a href="#l33.24"></a><span id="l33.24"> /**</span>
<a href="#l33.25"></a><span id="l33.25">  * To save ourselves some lookup trouble, pretend to be a verification</span>
<a href="#l33.26"></a><span id="l33.26">  *  function so we get easy access to the gloda translations of the messages so</span>
<a href="#l33.27"></a><span id="l33.27">  *  we can cram this in various places.</span>
<a href="#l33.28"></a><span id="l33.28" class="difflineat">@@ -122,18 +120,17 @@ function glodaInfoStasher(aSynthMessage,</span>
<a href="#l33.29"></a><span id="l33.29">     }</span>
<a href="#l33.30"></a><span id="l33.30">   }</span>
<a href="#l33.31"></a><span id="l33.31"> }</span>
<a href="#l33.32"></a><span id="l33.32"> </span>
<a href="#l33.33"></a><span id="l33.33"> /**</span>
<a href="#l33.34"></a><span id="l33.34">  * Actually inject all the messages we created above.</span>
<a href="#l33.35"></a><span id="l33.35">  */</span>
<a href="#l33.36"></a><span id="l33.36"> function setup_inject_messages() {</span>
<a href="#l33.37"></a><span id="l33.37" class="difflineminus">-  let msgSet = new SyntheticMessageSet(</span>
<a href="#l33.38"></a><span id="l33.38" class="difflineminus">-                 [info._synMsg for each ([, info] in Iterator(messageInfos))]);</span>
<a href="#l33.39"></a><span id="l33.39" class="difflineplus">+  let msgSet = new SyntheticMessageSet(messageInfos.map(info =&gt; info._synMsg));</span>
<a href="#l33.40"></a><span id="l33.40">   let folder = make_empty_folder();</span>
<a href="#l33.41"></a><span id="l33.41">   yield add_sets_to_folders(folder, [msgSet]);</span>
<a href="#l33.42"></a><span id="l33.42">   yield wait_for_gloda_indexer(msgSet, {verifier: glodaInfoStasher});</span>
<a href="#l33.43"></a><span id="l33.43"> }</span>
<a href="#l33.44"></a><span id="l33.44"> </span>
<a href="#l33.45"></a><span id="l33.45"> function test_stream_message(info) {</span>
<a href="#l33.46"></a><span id="l33.46">   let msgHdr = info._glodaMsg.folderMessage;</span>
<a href="#l33.47"></a><span id="l33.47"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -420,17 +420,22 @@ function test_attributes_fundamental() {</span>
<a href="#l34.4"></a><span id="l34.4"> </span>
<a href="#l34.5"></a><span id="l34.5">   yield wait_for_gloda_indexer(msgSet, { verifier: verify_attributes_fundamental });</span>
<a href="#l34.6"></a><span id="l34.6"> </span>
<a href="#l34.7"></a><span id="l34.7"> }</span>
<a href="#l34.8"></a><span id="l34.8"> </span>
<a href="#l34.9"></a><span id="l34.9"> function verify_attributes_fundamental(smsg, gmsg) {</span>
<a href="#l34.10"></a><span id="l34.10">   // save off the message id for test_attributes_fundamental_from_disk</span>
<a href="#l34.11"></a><span id="l34.11">   fundamentalGlodaMessageId = gmsg.id;</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-  fundamentalGlodaMsgAttachmentUrls = [att.url for each (att in gmsg.attachmentInfos)];</span>
<a href="#l34.13"></a><span id="l34.13" class="difflineplus">+  if (gmsg.attachmentInfos) {</span>
<a href="#l34.14"></a><span id="l34.14" class="difflineplus">+    fundamentalGlodaMsgAttachmentUrls =</span>
<a href="#l34.15"></a><span id="l34.15" class="difflineplus">+      gmsg.attachmentInfos.map(att =&gt; att.url);</span>
<a href="#l34.16"></a><span id="l34.16" class="difflineplus">+  } else {</span>
<a href="#l34.17"></a><span id="l34.17" class="difflineplus">+    fundamentalGlodaMsgAttachmentUrls = [];</span>
<a href="#l34.18"></a><span id="l34.18" class="difflineplus">+  }</span>
<a href="#l34.19"></a><span id="l34.19"> </span>
<a href="#l34.20"></a><span id="l34.20">   do_check_eq(gmsg.folderURI,</span>
<a href="#l34.21"></a><span id="l34.21">               get_real_injection_folder(fundamentalFolderHandle).URI);</span>
<a href="#l34.22"></a><span id="l34.22"> </span>
<a href="#l34.23"></a><span id="l34.23">   // -- subject</span>
<a href="#l34.24"></a><span id="l34.24">   do_check_eq(smsg.subject, gmsg.conversation.subject);</span>
<a href="#l34.25"></a><span id="l34.25">   do_check_eq(smsg.subject, gmsg.subject);</span>
<a href="#l34.26"></a><span id="l34.26"> </span>
<a href="#l34.27"></a><span id="l34.27" class="difflineat">@@ -461,17 +466,17 @@ function verify_attributes_fundamental(s</span>
<a href="#l34.28"></a><span id="l34.28"> </span>
<a href="#l34.29"></a><span id="l34.29">     let expectedInfos = [</span>
<a href="#l34.30"></a><span id="l34.30">       // the name for that one is generated randomly</span>
<a href="#l34.31"></a><span id="l34.31">       { contentType: &quot;message/rfc822&quot; },</span>
<a href="#l34.32"></a><span id="l34.32">       { name: &quot;bob.txt&quot;, contentType: &quot;text/plain&quot; },</span>
<a href="#l34.33"></a><span id="l34.33">     ];</span>
<a href="#l34.34"></a><span id="l34.34">     let expectedSize = 14;</span>
<a href="#l34.35"></a><span id="l34.35">     do_check_eq(gmsg.attachmentInfos.length, 2);</span>
<a href="#l34.36"></a><span id="l34.36" class="difflineminus">-    for each (let [i, attInfos] in Iterator(gmsg.attachmentInfos)) {</span>
<a href="#l34.37"></a><span id="l34.37" class="difflineplus">+    for (let [i, attInfos] of gmsg.attachmentInfos.entries()) {</span>
<a href="#l34.38"></a><span id="l34.38">       for (let k in expectedInfos[i])</span>
<a href="#l34.39"></a><span id="l34.39">         do_check_eq(attInfos[k], expectedInfos[i][k]);</span>
<a href="#l34.40"></a><span id="l34.40">       // because it's unreliable and depends on the platform</span>
<a href="#l34.41"></a><span id="l34.41">       do_check_true(Math.abs(attInfos.size - expectedSize) &lt;= 2);</span>
<a href="#l34.42"></a><span id="l34.42">       // check that the attachment URLs are correct</span>
<a href="#l34.43"></a><span id="l34.43">       let channel = NetUtil.newChannel({</span>
<a href="#l34.44"></a><span id="l34.44">          uri: attInfos.url,</span>
<a href="#l34.45"></a><span id="l34.45">          loadingPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),</span>
<a href="#l34.46"></a><span id="l34.46" class="difflineat">@@ -513,17 +518,17 @@ function test_moved_message_attributes()</span>
<a href="#l34.47"></a><span id="l34.47">   // this is a fast move (third parameter set to true)</span>
<a href="#l34.48"></a><span id="l34.48">   yield async_move_messages(fundamentalMsgSet, destFolder, true);</span>
<a href="#l34.49"></a><span id="l34.49"> </span>
<a href="#l34.50"></a><span id="l34.50">   yield wait_for_gloda_indexer(fundamentalMsgSet, {</span>
<a href="#l34.51"></a><span id="l34.51">     verifier: function (newSynMsg, newGlodaMsg) {</span>
<a href="#l34.52"></a><span id="l34.52">       // verify we still have the same number of attachments</span>
<a href="#l34.53"></a><span id="l34.53">       do_check_eq(fundamentalGlodaMsgAttachmentUrls.length,</span>
<a href="#l34.54"></a><span id="l34.54">         newGlodaMsg.attachmentInfos.length);</span>
<a href="#l34.55"></a><span id="l34.55" class="difflineminus">-      for each (let [i, attInfos] in Iterator(newGlodaMsg.attachmentInfos)) {</span>
<a href="#l34.56"></a><span id="l34.56" class="difflineplus">+      for (let [i, attInfos] of newGlodaMsg.attachmentInfos.entries()) {</span>
<a href="#l34.57"></a><span id="l34.57">         // verify the url has changed</span>
<a href="#l34.58"></a><span id="l34.58">         do_check_neq(fundamentalGlodaMsgAttachmentUrls[i], attInfos.url);</span>
<a href="#l34.59"></a><span id="l34.59">         // and verify that the new url is still valid</span>
<a href="#l34.60"></a><span id="l34.60">         let channel = NetUtil.newChannel({</span>
<a href="#l34.61"></a><span id="l34.61">            uri: attInfos.url,</span>
<a href="#l34.62"></a><span id="l34.62">            loadingPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),</span>
<a href="#l34.63"></a><span id="l34.63">            securityFlags: Ci.nsILoadInfo.SEC_NORMAL,</span>
<a href="#l34.64"></a><span id="l34.64">            contentPolicyType: Ci.nsIContentPolicy.TYPE_OTHER</span>
<a href="#l34.65"></a><span id="l34.65" class="difflineat">@@ -1132,18 +1137,18 @@ function test_message_moving() {</span>
<a href="#l34.66"></a><span id="l34.66">               get_real_injection_folder(destFolder).URI);</span>
<a href="#l34.67"></a><span id="l34.67"> </span>
<a href="#l34.68"></a><span id="l34.68">   // - make sure the message key is correct!</span>
<a href="#l34.69"></a><span id="l34.69">   do_check_eq(gmsg.messageKey, msgSet.getMsgHdr(0).messageKey);</span>
<a href="#l34.70"></a><span id="l34.70">   // (sanity check that the messageKey actually changed for the message...)</span>
<a href="#l34.71"></a><span id="l34.71">   do_check_neq(gmsg.messageKey, oldMessageKey);</span>
<a href="#l34.72"></a><span id="l34.72"> </span>
<a href="#l34.73"></a><span id="l34.73">   // - make sure the indexer's _keyChangedBatchInfo dict is empty</span>
<a href="#l34.74"></a><span id="l34.74" class="difflineminus">-  for each (let [evilKey, evilValue] in</span>
<a href="#l34.75"></a><span id="l34.75" class="difflineminus">-              Iterator(GlodaMsgIndexer._keyChangedBatchInfo)) {</span>
<a href="#l34.76"></a><span id="l34.76" class="difflineplus">+  for (let evilKey in GlodaMsgIndexer._keyChangedBatchInfo) {</span>
<a href="#l34.77"></a><span id="l34.77" class="difflineplus">+    let evilValue = GlodaMsgIndexer._keyChangedBatchInfo[evilKey];</span>
<a href="#l34.78"></a><span id="l34.78">     mark_failure([&quot;GlodaMsgIndexer._keyChangedBatchInfo should be empty but&quot;,</span>
<a href="#l34.79"></a><span id="l34.79">                   &quot;has key:&quot;,  evilKey, &quot;and value:&quot;, evilValue, &quot;.&quot;]);</span>
<a href="#l34.80"></a><span id="l34.80">   }</span>
<a href="#l34.81"></a><span id="l34.81"> </span>
<a href="#l34.82"></a><span id="l34.82">   // - slowpath (IMAP online) move it back to its origin folder</span>
<a href="#l34.83"></a><span id="l34.83">   mark_sub_test_start(&quot;move it back&quot;);</span>
<a href="#l34.84"></a><span id="l34.84">   yield async_move_messages(msgSet, srcFolder, false);</span>
<a href="#l34.85"></a><span id="l34.85">   // In the IMAP case we will end up reindexing the message because we will</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/base_query_messages.js</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_query_messages.js</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -268,17 +268,17 @@ function setup_populate() {</span>
<a href="#l35.4"></a><span id="l35.4">  *  justification.</span>
<a href="#l35.5"></a><span id="l35.5">  */</span>
<a href="#l35.6"></a><span id="l35.6"> function verify_nonMatches(aQueries, aCollections) {</span>
<a href="#l35.7"></a><span id="l35.7">   for (let i = 0; i &lt; aCollections.length; i++) {</span>
<a href="#l35.8"></a><span id="l35.8">     let testQuery = aQueries[i];</span>
<a href="#l35.9"></a><span id="l35.9">     let nonmatches =</span>
<a href="#l35.10"></a><span id="l35.10">       aCollections[(i+1) % aCollections.length].items;</span>
<a href="#l35.11"></a><span id="l35.11"> </span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-    for each (let [, item] in Iterator(nonmatches)) {</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+    for (let item of nonmatches) {</span>
<a href="#l35.14"></a><span id="l35.14">       if (testQuery.test(item)) {</span>
<a href="#l35.15"></a><span id="l35.15">         logObject(item, &quot;item&quot;);</span>
<a href="#l35.16"></a><span id="l35.16">         logObject(testQuery._constraints, &quot;constraints&quot;);</span>
<a href="#l35.17"></a><span id="l35.17">         do_throw(&quot;Something should not match query.test(), but it does: &quot; +</span>
<a href="#l35.18"></a><span id="l35.18">                  item);</span>
<a href="#l35.19"></a><span id="l35.19">       }</span>
<a href="#l35.20"></a><span id="l35.20">     }</span>
<a href="#l35.21"></a><span id="l35.21">   }</span>
<a href="#l35.22"></a><span id="l35.22" class="difflineat">@@ -342,31 +342,31 @@ function test_query_messages_by_folder_n</span>
<a href="#l35.23"></a><span id="l35.23"> </span>
<a href="#l35.24"></a><span id="l35.24"> /**</span>
<a href="#l35.25"></a><span id="l35.25">  * @tests Gloda.ns.getMessageCollectionForHeader()</span>
<a href="#l35.26"></a><span id="l35.26">  */</span>
<a href="#l35.27"></a><span id="l35.27"> function test_get_message_for_header() {</span>
<a href="#l35.28"></a><span id="l35.28">   // pick an arbitrary message</span>
<a href="#l35.29"></a><span id="l35.29">   let glodaMessage = ts_convCollections[1].items[0];</span>
<a href="#l35.30"></a><span id="l35.30">   // find the synthetic message that matches (ordering must not be assumed)</span>
<a href="#l35.31"></a><span id="l35.31" class="difflineminus">-  let synthMessage = [sm for each (sm in world.conversationLists[1])</span>
<a href="#l35.32"></a><span id="l35.32" class="difflineminus">-                      if (sm.messageId == glodaMessage.headerMessageID)][0];</span>
<a href="#l35.33"></a><span id="l35.33" class="difflineplus">+  let synthMessage = world.conversationLists[1].</span>
<a href="#l35.34"></a><span id="l35.34" class="difflineplus">+    find(sm =&gt; sm.messageId == glodaMessage.headerMessageID);</span>
<a href="#l35.35"></a><span id="l35.35">   queryExpect({queryFunc: Gloda.getMessageCollectionForHeader,</span>
<a href="#l35.36"></a><span id="l35.36">                queryThis: Gloda,</span>
<a href="#l35.37"></a><span id="l35.37">                args: [glodaMessage.folderMessage], nounId: Gloda.NOUN_MESSAGE},</span>
<a href="#l35.38"></a><span id="l35.38">               [synthMessage]);</span>
<a href="#l35.39"></a><span id="l35.39">   return false; // async pend on queryExpect</span>
<a href="#l35.40"></a><span id="l35.40"> }</span>
<a href="#l35.41"></a><span id="l35.41"> </span>
<a href="#l35.42"></a><span id="l35.42"> /**</span>
<a href="#l35.43"></a><span id="l35.43">  * @tests Gloda.ns.getMessageCollectionForHeaders()</span>
<a href="#l35.44"></a><span id="l35.44">  */</span>
<a href="#l35.45"></a><span id="l35.45"> function test_get_messages_for_headers() {</span>
<a href="#l35.46"></a><span id="l35.46">   let messageCollection = ts_convCollections[0];</span>
<a href="#l35.47"></a><span id="l35.47" class="difflineminus">-  let headers = [m.folderMessage for each (m in messageCollection.items)];</span>
<a href="#l35.48"></a><span id="l35.48" class="difflineplus">+  let headers = messageCollection.items.map(m =&gt; m.folderMessage);</span>
<a href="#l35.49"></a><span id="l35.49">   queryExpect({queryFunc: Gloda.getMessageCollectionForHeaders,</span>
<a href="#l35.50"></a><span id="l35.50">                queryThis: Gloda,</span>
<a href="#l35.51"></a><span id="l35.51">                args: [headers], nounId: Gloda.NOUN_MESSAGE},</span>
<a href="#l35.52"></a><span id="l35.52">               world.conversationLists[0]);</span>
<a href="#l35.53"></a><span id="l35.53">   return false; // async pend on queryExpect</span>
<a href="#l35.54"></a><span id="l35.54"> }</span>
<a href="#l35.55"></a><span id="l35.55"> </span>
<a href="#l35.56"></a><span id="l35.56"> // at this point we go run the identity and contact tests for side-effects</span>
<a href="#l35.57"></a><span id="l35.57" class="difflineat">@@ -599,17 +599,17 @@ function test_query_contacts_by_name_non</span>
<a href="#l35.58"></a><span id="l35.58"> </span>
<a href="#l35.59"></a><span id="l35.59"> /* === identities === */</span>
<a href="#l35.60"></a><span id="l35.60"> </span>
<a href="#l35.61"></a><span id="l35.61"> var peoplesIdentityQuery;</span>
<a href="#l35.62"></a><span id="l35.62"> var peoplesIdentityCollection;</span>
<a href="#l35.63"></a><span id="l35.63"> function test_query_identities_for_peoples() {</span>
<a href="#l35.64"></a><span id="l35.64">   peoplesIdentityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l35.65"></a><span id="l35.65">   peoplesIdentityQuery.kind(&quot;email&quot;);</span>
<a href="#l35.66"></a><span id="l35.66" class="difflineminus">-  let peopleAddrs = [nameAndAddr[1] for each (nameAndAddr in world.peoples)];</span>
<a href="#l35.67"></a><span id="l35.67" class="difflineplus">+  let peopleAddrs = world.peoples.map(nameAndAddr =&gt; nameAndAddr[1]);</span>
<a href="#l35.68"></a><span id="l35.68">   peoplesIdentityQuery.value.apply(peoplesIdentityQuery, peopleAddrs);</span>
<a href="#l35.69"></a><span id="l35.69">   peoplesIdentityCollection = queryExpect(peoplesIdentityQuery, peopleAddrs);</span>
<a href="#l35.70"></a><span id="l35.70">   return false; // async pend on queryExpect</span>
<a href="#l35.71"></a><span id="l35.71"> }</span>
<a href="#l35.72"></a><span id="l35.72"> </span>
<a href="#l35.73"></a><span id="l35.73"> var outlierIdentityQuery;</span>
<a href="#l35.74"></a><span id="l35.74"> var outlierIdentityCollection;</span>
<a href="#l35.75"></a><span id="l35.75"> function test_query_identities_for_outliers() {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -75,17 +75,17 @@ var ENVIRON_MAPPINGS = [</span>
<a href="#l36.4"></a><span id="l36.4">     envVar: &quot;GLODA_DATASTORE_EXPLAIN_TO_PATH&quot;,</span>
<a href="#l36.5"></a><span id="l36.5">     prefName: &quot;mailnews.database.global.datastore.explainToPath&quot;</span>
<a href="#l36.6"></a><span id="l36.6">   }</span>
<a href="#l36.7"></a><span id="l36.7"> ];</span>
<a href="#l36.8"></a><span id="l36.8"> </span>
<a href="#l36.9"></a><span id="l36.9"> // -- Propagate environment variables to prefs as appropriate:</span>
<a href="#l36.10"></a><span id="l36.10"> var environ = Cc[&quot;@mozilla.org/process/environment;1&quot;]</span>
<a href="#l36.11"></a><span id="l36.11">                 .getService(Ci.nsIEnvironment);</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineminus">-for each (let [, {envVar, prefName}] in Iterator(ENVIRON_MAPPINGS)) {</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+for (let {envVar, prefName} of ENVIRON_MAPPINGS) {</span>
<a href="#l36.14"></a><span id="l36.14">  if (environ.exists(envVar)) {</span>
<a href="#l36.15"></a><span id="l36.15">    Services.prefs.setCharPref(prefName, environ.get(envVar));</span>
<a href="#l36.16"></a><span id="l36.16">  }</span>
<a href="#l36.17"></a><span id="l36.17"> }</span>
<a href="#l36.18"></a><span id="l36.18"> </span>
<a href="#l36.19"></a><span id="l36.19"> </span>
<a href="#l36.20"></a><span id="l36.20"> // -- Import our modules</span>
<a href="#l36.21"></a><span id="l36.21"> Components.utils.import(&quot;resource:///modules/gloda/public.js&quot;);</span>
<a href="#l36.22"></a><span id="l36.22" class="difflineat">@@ -466,20 +466,20 @@ var _indexMessageState = {</span>
<a href="#l36.23"></a><span id="l36.23">   _glodaDeletionsByMessageId: {},</span>
<a href="#l36.24"></a><span id="l36.24"> </span>
<a href="#l36.25"></a><span id="l36.25">   assertExpectedMessagesIndexed:</span>
<a href="#l36.26"></a><span id="l36.26">       function _indexMessageState_assertExpectedMessagesIndexed() {</span>
<a href="#l36.27"></a><span id="l36.27">     let verifier = this.verifier;</span>
<a href="#l36.28"></a><span id="l36.28">     let previousValue = undefined;</span>
<a href="#l36.29"></a><span id="l36.29"> </span>
<a href="#l36.30"></a><span id="l36.30">     // - Check we have a gloda message for every syn message and verify</span>
<a href="#l36.31"></a><span id="l36.31" class="difflineminus">-    for each (let [, msgSet] in Iterator(this.synMessageSets)) {</span>
<a href="#l36.32"></a><span id="l36.32" class="difflineplus">+    for (let msgSet of this.synMessageSets) {</span>
<a href="#l36.33"></a><span id="l36.33">       if (this.augmentSynSets)</span>
<a href="#l36.34"></a><span id="l36.34">         msgSet.glodaMessages = [];</span>
<a href="#l36.35"></a><span id="l36.35" class="difflineminus">-      for each (let [iSynMsg, synMsg] in Iterator(msgSet.synMessages)) {</span>
<a href="#l36.36"></a><span id="l36.36" class="difflineplus">+      for (let [iSynMsg, synMsg] of msgSet.synMessages.entries()) {</span>
<a href="#l36.37"></a><span id="l36.37">         if (!(synMsg.messageId in this._glodaMessagesByMessageId)) {</span>
<a href="#l36.38"></a><span id="l36.38">           let msgHdr = msgSet.getMsgHdr(iSynMsg);</span>
<a href="#l36.39"></a><span id="l36.39">           mark_failure(</span>
<a href="#l36.40"></a><span id="l36.40">             [&quot;Header&quot;, msgHdr, &quot;in folder&quot;, msgHdr ? msgHdr.folder: &quot;no header?&quot;,</span>
<a href="#l36.41"></a><span id="l36.41">              &quot;should have been indexed.&quot;]);</span>
<a href="#l36.42"></a><span id="l36.42">         }</span>
<a href="#l36.43"></a><span id="l36.43"> </span>
<a href="#l36.44"></a><span id="l36.44">         let glodaMsg = this._glodaMessagesByMessageId[synMsg.messageId];</span>
<a href="#l36.45"></a><span id="l36.45" class="difflineat">@@ -502,43 +502,44 @@ var _indexMessageState = {</span>
<a href="#l36.46"></a><span id="l36.46">               [&quot;Verification failure:&quot;, synMsg, &quot;is not close enough to&quot;,</span>
<a href="#l36.47"></a><span id="l36.47">                 glodaMsg, &quot;; basing this on exception:&quot;, ex]);</span>
<a href="#l36.48"></a><span id="l36.48">           }</span>
<a href="#l36.49"></a><span id="l36.49">         }</span>
<a href="#l36.50"></a><span id="l36.50">       }</span>
<a href="#l36.51"></a><span id="l36.51">     }</span>
<a href="#l36.52"></a><span id="l36.52"> </span>
<a href="#l36.53"></a><span id="l36.53">     // - Check that we don't have any extra gloda messages (lacking syn msgs)</span>
<a href="#l36.54"></a><span id="l36.54" class="difflineminus">-    for each (let [, glodaMsg] in Iterator(this._glodaMessagesByMessageId)) {</span>
<a href="#l36.55"></a><span id="l36.55" class="difflineplus">+    for (let messageId in this._glodaMessagesByMessageId) {</span>
<a href="#l36.56"></a><span id="l36.56" class="difflineplus">+      let glodaMsg = this._glodaMessagesByMessageId[messageId];</span>
<a href="#l36.57"></a><span id="l36.57">       if (glodaMsg != null) {</span>
<a href="#l36.58"></a><span id="l36.58">         // logObject is too verbose right now</span>
<a href="#l36.59"></a><span id="l36.59">         dump(&quot;gloda message: &quot; + glodaMsg + &quot;\n&quot;);</span>
<a href="#l36.60"></a><span id="l36.60">         mark_failure(</span>
<a href="#l36.61"></a><span id="l36.61">           [&quot;Gloda message&quot;, glodaMsg, &quot;should not have been indexed.&quot;,</span>
<a href="#l36.62"></a><span id="l36.62">            &quot;Source header:&quot;, glodaMsg.folderMessage]);</span>
<a href="#l36.63"></a><span id="l36.63">       }</span>
<a href="#l36.64"></a><span id="l36.64">     }</span>
<a href="#l36.65"></a><span id="l36.65"> </span>
<a href="#l36.66"></a><span id="l36.66">     if (this.deletionSynSets) {</span>
<a href="#l36.67"></a><span id="l36.67" class="difflineminus">-      for each (let [, msgSet] in Iterator(this.deletionSynSets)) {</span>
<a href="#l36.68"></a><span id="l36.68" class="difflineminus">-        for each (let [iSynMsg, synMsg] in Iterator(msgSet.synMessages)) {</span>
<a href="#l36.69"></a><span id="l36.69" class="difflineplus">+      for (let msgSet of this.deletionSynSets) {</span>
<a href="#l36.70"></a><span id="l36.70" class="difflineplus">+        for (let synMsg of msgSet.synMessages) {</span>
<a href="#l36.71"></a><span id="l36.71">           if (!(synMsg.messageId in this._glodaDeletionsByMessageId)) {</span>
<a href="#l36.72"></a><span id="l36.72">             do_throw(&quot;Synthetic message &quot; + synMsg + &quot; did not get deleted!&quot;);</span>
<a href="#l36.73"></a><span id="l36.73">           }</span>
<a href="#l36.74"></a><span id="l36.74"> </span>
<a href="#l36.75"></a><span id="l36.75">           let glodaMsg = this._glodaMessagesByMessageId[synMsg.messageId];</span>
<a href="#l36.76"></a><span id="l36.76"> </span>
<a href="#l36.77"></a><span id="l36.77">           this._glodaDeletionsByMessageId[synMsg.messageId] = null;</span>
<a href="#l36.78"></a><span id="l36.78">         }</span>
<a href="#l36.79"></a><span id="l36.79">       }</span>
<a href="#l36.80"></a><span id="l36.80">     }</span>
<a href="#l36.81"></a><span id="l36.81"> </span>
<a href="#l36.82"></a><span id="l36.82">     // - Check that we don't have unexpected deletions</span>
<a href="#l36.83"></a><span id="l36.83" class="difflineminus">-    for each (let [messageId, glodaMsg] in</span>
<a href="#l36.84"></a><span id="l36.84" class="difflineminus">-              Iterator(this._glodaDeletionsByMessageId)) {</span>
<a href="#l36.85"></a><span id="l36.85" class="difflineplus">+    for (let messageId in this._glodaDeletionsByMessageId) {</span>
<a href="#l36.86"></a><span id="l36.86" class="difflineplus">+      let  glodaMsg = this._glodaDeletionsByMessageId[messageId];</span>
<a href="#l36.87"></a><span id="l36.87">       if (glodaMsg != null) {</span>
<a href="#l36.88"></a><span id="l36.88">         logObject(glodaMsg, &quot;glodaMsg&quot;);</span>
<a href="#l36.89"></a><span id="l36.89">         do_throw(&quot;Gloda message with message id &quot; + messageId + &quot; was &quot; +</span>
<a href="#l36.90"></a><span id="l36.90">                  &quot;unexpectedly deleted!&quot;);</span>
<a href="#l36.91"></a><span id="l36.91">       }</span>
<a href="#l36.92"></a><span id="l36.92">     }</span>
<a href="#l36.93"></a><span id="l36.93"> </span>
<a href="#l36.94"></a><span id="l36.94">     if (this.expectedWorkerRecoveredCount != null &amp;&amp;</span>
<a href="#l36.95"></a><span id="l36.95" class="difflineat">@@ -588,17 +589,17 @@ var _indexMessageState = {</span>
<a href="#l36.96"></a><span id="l36.96">    *  we should receive an onItemsAdded call.  Any time an existing message</span>
<a href="#l36.97"></a><span id="l36.97">    *  gets reindexed, we should receive an onItemsModified call.  Any time an</span>
<a href="#l36.98"></a><span id="l36.98">    *  existing message actually gets purged from the system, we should receive</span>
<a href="#l36.99"></a><span id="l36.99">    *  an onItemsRemoved call.</span>
<a href="#l36.100"></a><span id="l36.100">    */</span>
<a href="#l36.101"></a><span id="l36.101">   onItemsAdded: function(aItems) {</span>
<a href="#l36.102"></a><span id="l36.102">     mark_action(&quot;glodaEvent&quot;, &quot;itemsAdded&quot;, aItems);</span>
<a href="#l36.103"></a><span id="l36.103"> </span>
<a href="#l36.104"></a><span id="l36.104" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l36.105"></a><span id="l36.105" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l36.106"></a><span id="l36.106">       if (item.headerMessageID in this._glodaMessagesByMessageId)</span>
<a href="#l36.107"></a><span id="l36.107">         mark_failure(</span>
<a href="#l36.108"></a><span id="l36.108">           [&quot;Gloda message&quot;, item.folderMessage,</span>
<a href="#l36.109"></a><span id="l36.109">             &quot;already indexed once since the last&quot; + &quot;wait_for_gloda_indexer call!&quot;</span>
<a href="#l36.110"></a><span id="l36.110">           ]);</span>
<a href="#l36.111"></a><span id="l36.111"> </span>
<a href="#l36.112"></a><span id="l36.112">       this._glodaMessagesByMessageId[item.headerMessageID] = item;</span>
<a href="#l36.113"></a><span id="l36.113">     }</span>
<a href="#l36.114"></a><span id="l36.114" class="difflineat">@@ -607,30 +608,30 @@ var _indexMessageState = {</span>
<a href="#l36.115"></a><span id="l36.115">     // cached database, which used to kill the indexer's enumerator.</span>
<a href="#l36.116"></a><span id="l36.116">     if (++this._numItemsAdded == 3)</span>
<a href="#l36.117"></a><span id="l36.117">       GlodaMsgIndexer._indexingFolder.msgDatabase = null;</span>
<a href="#l36.118"></a><span id="l36.118">   },</span>
<a href="#l36.119"></a><span id="l36.119"> </span>
<a href="#l36.120"></a><span id="l36.120">   onItemsModified: function(aItems) {</span>
<a href="#l36.121"></a><span id="l36.121">     mark_action(&quot;glodaEvent&quot;, &quot;itemsModified&quot;, aItems);</span>
<a href="#l36.122"></a><span id="l36.122"> </span>
<a href="#l36.123"></a><span id="l36.123" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l36.124"></a><span id="l36.124" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l36.125"></a><span id="l36.125">       if (item.headerMessageID in this._glodaMessagesByMessageId)</span>
<a href="#l36.126"></a><span id="l36.126">         mark_failure(</span>
<a href="#l36.127"></a><span id="l36.127">           [&quot;Gloda message&quot;, item, &quot;already indexed once since the last&quot; +</span>
<a href="#l36.128"></a><span id="l36.128">             &quot;wait_for_gloda_indexer call!&quot;]);</span>
<a href="#l36.129"></a><span id="l36.129"> </span>
<a href="#l36.130"></a><span id="l36.130">       this._glodaMessagesByMessageId[item.headerMessageID] = item;</span>
<a href="#l36.131"></a><span id="l36.131">     }</span>
<a href="#l36.132"></a><span id="l36.132">   },</span>
<a href="#l36.133"></a><span id="l36.133"> </span>
<a href="#l36.134"></a><span id="l36.134">   onItemsRemoved: function(aItems) {</span>
<a href="#l36.135"></a><span id="l36.135">     mark_action(&quot;glodaEvent&quot;, &quot;removed&quot;, aItems);</span>
<a href="#l36.136"></a><span id="l36.136"> </span>
<a href="#l36.137"></a><span id="l36.137" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l36.138"></a><span id="l36.138" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l36.139"></a><span id="l36.139">       if (item.headerMessageID in this._glodaDeletionsByMessageId)</span>
<a href="#l36.140"></a><span id="l36.140">         mark_failure(</span>
<a href="#l36.141"></a><span id="l36.141">           [&quot;Gloda message&quot;, item, &quot;already deleted once since the last&quot; +</span>
<a href="#l36.142"></a><span id="l36.142">             &quot;wait_for_gloda_indexer call!&quot;]);</span>
<a href="#l36.143"></a><span id="l36.143"> </span>
<a href="#l36.144"></a><span id="l36.144">       this._glodaDeletionsByMessageId[item.headerMessageID] = item;</span>
<a href="#l36.145"></a><span id="l36.145">     }</span>
<a href="#l36.146"></a><span id="l36.146">   },</span>
<a href="#l36.147"></a><span id="l36.147" class="difflineat">@@ -827,17 +828,17 @@ function QueryExpectationListener(aExpec</span>
<a href="#l36.148"></a><span id="l36.148">   this.callerStackFrame = aCallerStackFrame;</span>
<a href="#l36.149"></a><span id="l36.149">   // track our current 'index' in the results for the (optional) order verifier,</span>
<a href="#l36.150"></a><span id="l36.150">   //  but also so we can provide slightly more useful debug output</span>
<a href="#l36.151"></a><span id="l36.151">   this.nextIndex = 0;</span>
<a href="#l36.152"></a><span id="l36.152"> }</span>
<a href="#l36.153"></a><span id="l36.153"> </span>
<a href="#l36.154"></a><span id="l36.154"> QueryExpectationListener.prototype = {</span>
<a href="#l36.155"></a><span id="l36.155">   onItemsAdded: function query_expectation_onItemsAdded(aItems, aCollection) {</span>
<a href="#l36.156"></a><span id="l36.156" class="difflineminus">-    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l36.157"></a><span id="l36.157" class="difflineplus">+    for (let item of aItems) {</span>
<a href="#l36.158"></a><span id="l36.158">       let glodaStringRep;</span>
<a href="#l36.159"></a><span id="l36.159">       try {</span>
<a href="#l36.160"></a><span id="l36.160">         glodaStringRep = this.glodaExtractor(item);</span>
<a href="#l36.161"></a><span id="l36.161">       }</span>
<a href="#l36.162"></a><span id="l36.162">       catch (ex) {</span>
<a href="#l36.163"></a><span id="l36.163">         do_throw(&quot;Gloda extractor threw during query expectation for item: &quot; +</span>
<a href="#l36.164"></a><span id="l36.164">                  item + &quot; exception: &quot; + ex);</span>
<a href="#l36.165"></a><span id="l36.165">       }</span>
<a href="#l36.166"></a><span id="l36.166" class="difflineat">@@ -853,17 +854,17 @@ QueryExpectationListener.prototype = {</span>
<a href="#l36.167"></a><span id="l36.167">       if (this.orderVerifier) {</span>
<a href="#l36.168"></a><span id="l36.168">         try {</span>
<a href="#l36.169"></a><span id="l36.169">           this.orderVerifier(this.nextIndex, item, aCollection);</span>
<a href="#l36.170"></a><span id="l36.170">         }</span>
<a href="#l36.171"></a><span id="l36.171">         catch (ex) {</span>
<a href="#l36.172"></a><span id="l36.172">           // if the order was wrong, we could probably go for an output of what</span>
<a href="#l36.173"></a><span id="l36.173">           //  we actually got...</span>
<a href="#l36.174"></a><span id="l36.174">           dump(&quot;!!! ORDER PROBLEM, SO ORDER DUMP!\n&quot;);</span>
<a href="#l36.175"></a><span id="l36.175" class="difflineminus">-          for each (let [iThing, thing] in Iterator(aItems)) {</span>
<a href="#l36.176"></a><span id="l36.176" class="difflineplus">+          for (let [iThing, thing] of aItems.entries()) {</span>
<a href="#l36.177"></a><span id="l36.177">             dump(iThing + &quot;: &quot; + thing +</span>
<a href="#l36.178"></a><span id="l36.178">                  (aCollection.stashedColumns ?</span>
<a href="#l36.179"></a><span id="l36.179">                   (&quot;. &quot; + aCollection.stashedColumns[thing.id].join(&quot;, &quot;)) :</span>
<a href="#l36.180"></a><span id="l36.180">                   &quot;&quot;) + &quot;\n&quot;);</span>
<a href="#l36.181"></a><span id="l36.181">           }</span>
<a href="#l36.182"></a><span id="l36.182">           throw ex;</span>
<a href="#l36.183"></a><span id="l36.183">         }</span>
<a href="#l36.184"></a><span id="l36.184">       }</span>
<a href="#l36.185"></a><span id="l36.185" class="difflineat">@@ -884,17 +885,18 @@ QueryExpectationListener.prototype = {</span>
<a href="#l36.186"></a><span id="l36.186">       aCollection) {</span>
<a href="#l36.187"></a><span id="l36.187">   },</span>
<a href="#l36.188"></a><span id="l36.188">   onQueryCompleted: function query_expectation_onQueryCompleted(aCollection) {</span>
<a href="#l36.189"></a><span id="l36.189">     // we may continue to match newly added items if we leave our query as it</span>
<a href="#l36.190"></a><span id="l36.190">     //  is, so let's become explicit to avoid related troubles.</span>
<a href="#l36.191"></a><span id="l36.191">     aCollection.becomeExplicit();</span>
<a href="#l36.192"></a><span id="l36.192"> </span>
<a href="#l36.193"></a><span id="l36.193">     // expectedSet should now be empty</span>
<a href="#l36.194"></a><span id="l36.194" class="difflineminus">-    for each (let [key, value] in Iterator(this.expectedSet)) {</span>
<a href="#l36.195"></a><span id="l36.195" class="difflineplus">+    for (let key in this.expectedSet) {</span>
<a href="#l36.196"></a><span id="l36.196" class="difflineplus">+      let value = this.expectedSet[key];</span>
<a href="#l36.197"></a><span id="l36.197">       dump(&quot;I have seen &quot; + this.nextIndex + &quot; results, but not:\n&quot;);</span>
<a href="#l36.198"></a><span id="l36.198">       do_throw(&quot;Query should have returned &quot; + key + &quot; (&quot; + value + &quot;)&quot;);</span>
<a href="#l36.199"></a><span id="l36.199">     }</span>
<a href="#l36.200"></a><span id="l36.200"> </span>
<a href="#l36.201"></a><span id="l36.201">     // notify xpcshell that we did something</span>
<a href="#l36.202"></a><span id="l36.202">     let msg = &quot;query satisfied with: &quot; + aCollection.items;</span>
<a href="#l36.203"></a><span id="l36.203">     do_report_result(true, msg, Components.stack.caller);</span>
<a href="#l36.204"></a><span id="l36.204"> </span>
<a href="#l36.205"></a><span id="l36.205" class="difflineat">@@ -963,17 +965,17 @@ function queryExpect(aQuery, aExpectedSe</span>
<a href="#l36.206"></a><span id="l36.206">     if (_defaultExpectationExtractors[aQuery.nounId] !== undefined)</span>
<a href="#l36.207"></a><span id="l36.207">       aExpectedExtractor = _defaultExpectationExtractors[aQuery.nounId][1];</span>
<a href="#l36.208"></a><span id="l36.208">     else</span>
<a href="#l36.209"></a><span id="l36.209">       aExpectedExtractor = expectExtract_default_toString;</span>
<a href="#l36.210"></a><span id="l36.210">   }</span>
<a href="#l36.211"></a><span id="l36.211"> </span>
<a href="#l36.212"></a><span id="l36.212">   // - build the expected set</span>
<a href="#l36.213"></a><span id="l36.213">   let expectedSet = {};</span>
<a href="#l36.214"></a><span id="l36.214" class="difflineminus">-  for each (let [, item] in Iterator(aExpectedSet)) {</span>
<a href="#l36.215"></a><span id="l36.215" class="difflineplus">+  for (let item of aExpectedSet) {</span>
<a href="#l36.216"></a><span id="l36.216">     try {</span>
<a href="#l36.217"></a><span id="l36.217">       expectedSet[aExpectedExtractor(item)] = item;</span>
<a href="#l36.218"></a><span id="l36.218">     }</span>
<a href="#l36.219"></a><span id="l36.219">     catch (ex) {</span>
<a href="#l36.220"></a><span id="l36.220">       do_throw(&quot;Expected extractor threw during query expectation for item: &quot; +</span>
<a href="#l36.221"></a><span id="l36.221">                item + &quot; exception: &quot; + ex);</span>
<a href="#l36.222"></a><span id="l36.222">     }</span>
<a href="#l36.223"></a><span id="l36.223">   }</span>
<a href="#l36.224"></a><span id="l36.224" class="difflineat">@@ -1282,17 +1284,18 @@ function nukeGlodaCachesAndCollections()</span>
<a href="#l36.225"></a><span id="l36.225">     GlodaCollectionManager.registerCollection(</span>
<a href="#l36.226"></a><span id="l36.226">         _indexMessageState.catchAllCollection);</span>
<a href="#l36.227"></a><span id="l36.227">   }</span>
<a href="#l36.228"></a><span id="l36.228"> </span>
<a href="#l36.229"></a><span id="l36.229">   // caches aren't intended to be cleared, but we also don't want to lose our</span>
<a href="#l36.230"></a><span id="l36.230">   //  caches, so we need to create new ones from the ashes of the old ones.</span>
<a href="#l36.231"></a><span id="l36.231">   let oldCaches = GlodaCollectionManager._cachesByNoun;</span>
<a href="#l36.232"></a><span id="l36.232">   GlodaCollectionManager._cachesByNoun = {};</span>
<a href="#l36.233"></a><span id="l36.233" class="difflineminus">-  for each (let cache in oldCaches) {</span>
<a href="#l36.234"></a><span id="l36.234" class="difflineplus">+  for (let nounId in oldCaches) {</span>
<a href="#l36.235"></a><span id="l36.235" class="difflineplus">+    let cache = oldCaches[nounId];</span>
<a href="#l36.236"></a><span id="l36.236">     GlodaCollectionManager.defineCache(cache._nounDef, cache._maxCacheSize);</span>
<a href="#l36.237"></a><span id="l36.237">   }</span>
<a href="#l36.238"></a><span id="l36.238"> }</span>
<a href="#l36.239"></a><span id="l36.239"> </span>
<a href="#l36.240"></a><span id="l36.240"> </span>
<a href="#l36.241"></a><span id="l36.241"> /**</span>
<a href="#l36.242"></a><span id="l36.242">  * Add a name-and-address pair as generated by `makeNameAndAddress` to the</span>
<a href="#l36.243"></a><span id="l36.243">  *  personal address book.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -12,17 +12,17 @@</span>
<a href="#l37.4"></a><span id="l37.4"> </span>
<a href="#l37.5"></a><span id="l37.5"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l37.6"></a><span id="l37.6"> </span>
<a href="#l37.7"></a><span id="l37.7"> /**</span>
<a href="#l37.8"></a><span id="l37.8">  * @return the number of live gloda folders tracked by</span>
<a href="#l37.9"></a><span id="l37.9">  *     GlodaDatastore._liveGlodaFolders.</span>
<a href="#l37.10"></a><span id="l37.10">  */</span>
<a href="#l37.11"></a><span id="l37.11"> function getLiveFolderCount() {</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineminus">-  return [key for each (key in GlodaDatastore._liveGlodaFolders)].length;</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+  return Object.keys(GlodaDatastore._liveGlodaFolders).length;</span>
<a href="#l37.14"></a><span id="l37.14"> }</span>
<a href="#l37.15"></a><span id="l37.15"> </span>
<a href="#l37.16"></a><span id="l37.16"> /**</span>
<a href="#l37.17"></a><span id="l37.17">  * Meddle with internals of live folder tracking, create a synthetic message and</span>
<a href="#l37.18"></a><span id="l37.18">  *  index it. We do the actual work involving the headers and folders in</span>
<a href="#l37.19"></a><span id="l37.19">  *  poke_and_verify_msf_closure.</span>
<a href="#l37.20"></a><span id="l37.20">  */</span>
<a href="#l37.21"></a><span id="l37.21"> function test_msf_closure() {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_fts3_tokenizer.js</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_fts3_tokenizer.js</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineat">@@ -68,18 +68,18 @@ var intlPhrases = [</span>
<a href="#l38.4"></a><span id="l38.4">  * Stash each created synthetic message in a resultList list on the phrase so</span>
<a href="#l38.5"></a><span id="l38.5">  *  that we can use them as expected query results in</span>
<a href="#l38.6"></a><span id="l38.6">  *  |test_fulltextsearch|.</span>
<a href="#l38.7"></a><span id="l38.7">  */</span>
<a href="#l38.8"></a><span id="l38.8"> function test_index(aPhrase) {</span>
<a href="#l38.9"></a><span id="l38.9">   // create a synthetic message for each of the delightful encoding types</span>
<a href="#l38.10"></a><span id="l38.10">   let messages = [];</span>
<a href="#l38.11"></a><span id="l38.11">   aPhrase.resultList = [];</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineminus">-  for each (let [charset, encodings] in Iterator(aPhrase.encodings)) {</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineminus">-    let [quoted, bodyEncoded] = encodings;</span>
<a href="#l38.14"></a><span id="l38.14" class="difflineplus">+  for (let charset in aPhrase.encodings) {</span>
<a href="#l38.15"></a><span id="l38.15" class="difflineplus">+    let [quoted, bodyEncoded] = aPhrase.encodings[charset];</span>
<a href="#l38.16"></a><span id="l38.16"> </span>
<a href="#l38.17"></a><span id="l38.17">     let smsg = gMessageGenerator.makeMessage({</span>
<a href="#l38.18"></a><span id="l38.18">       subject: quoted,</span>
<a href="#l38.19"></a><span id="l38.19">       body: {charset: charset, encoding: &quot;8bit&quot;, body: bodyEncoded},</span>
<a href="#l38.20"></a><span id="l38.20">       attachments: [</span>
<a href="#l38.21"></a><span id="l38.21">         {filename: quoted, body: &quot;gabba gabba hey&quot;},</span>
<a href="#l38.22"></a><span id="l38.22">       ],</span>
<a href="#l38.23"></a><span id="l38.23">       // save off the actual value for checking</span>
<a href="#l38.24"></a><span id="l38.24" class="difflineat">@@ -132,17 +132,17 @@ function test_token_count() {</span>
<a href="#l38.25"></a><span id="l38.25"> }</span>
<a href="#l38.26"></a><span id="l38.26"> </span>
<a href="#l38.27"></a><span id="l38.27"> /**</span>
<a href="#l38.28"></a><span id="l38.28">  * For each phrase, make sure that all of the searchPhrases either match or fail</span>
<a href="#l38.29"></a><span id="l38.29">  *  to match as appropriate.</span>
<a href="#l38.30"></a><span id="l38.30">  */</span>
<a href="#l38.31"></a><span id="l38.31"> function test_fulltextsearch(aPhrase)</span>
<a href="#l38.32"></a><span id="l38.32"> {</span>
<a href="#l38.33"></a><span id="l38.33" class="difflineminus">-  for each (let [, searchPhrase] in Iterator(aPhrase.searchPhrases)) {</span>
<a href="#l38.34"></a><span id="l38.34" class="difflineplus">+  for (let searchPhrase of aPhrase.searchPhrases) {</span>
<a href="#l38.35"></a><span id="l38.35">     let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l38.36"></a><span id="l38.36">     query.bodyMatches(searchPhrase.body);</span>
<a href="#l38.37"></a><span id="l38.37">     queryExpect(query, searchPhrase.match ? aPhrase.resultList : []);</span>
<a href="#l38.38"></a><span id="l38.38">     yield false; // queryExpect is async</span>
<a href="#l38.39"></a><span id="l38.39">   }</span>
<a href="#l38.40"></a><span id="l38.40"> }</span>
<a href="#l38.41"></a><span id="l38.41"> </span>
<a href="#l38.42"></a><span id="l38.42"> Components.utils.import(&quot;resource:///modules/gloda/msg_search.js&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_compaction.js</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_compaction.js</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineat">@@ -40,17 +40,17 @@ Services.prefs.setCharPref(&quot;mail.serverD</span>
<a href="#l39.4"></a><span id="l39.4"> </span>
<a href="#l39.5"></a><span id="l39.5"> </span>
<a href="#l39.6"></a><span id="l39.6"> /**</span>
<a href="#l39.7"></a><span id="l39.7">  * Verify that the message keys match between the message headers and the</span>
<a href="#l39.8"></a><span id="l39.8">  *  (augmented on) gloda messages that correspond to the headers.</span>
<a href="#l39.9"></a><span id="l39.9">  */</span>
<a href="#l39.10"></a><span id="l39.10"> function verify_message_keys(aSynSet) {</span>
<a href="#l39.11"></a><span id="l39.11">   let iMsg = 0;</span>
<a href="#l39.12"></a><span id="l39.12" class="difflineminus">-  for each (let msgHdr in aSynSet.msgHdrs) {</span>
<a href="#l39.13"></a><span id="l39.13" class="difflineplus">+  for (let msgHdr of aSynSet.msgHdrs) {</span>
<a href="#l39.14"></a><span id="l39.14">     let glodaMsg = aSynSet.glodaMessages[iMsg++];</span>
<a href="#l39.15"></a><span id="l39.15">     if (msgHdr.messageKey != glodaMsg.messageKey)</span>
<a href="#l39.16"></a><span id="l39.16">       mark_failure([&quot;Message header&quot;, msgHdr,</span>
<a href="#l39.17"></a><span id="l39.17">                     &quot;should have message key &quot; + msgHdr.messageKey +</span>
<a href="#l39.18"></a><span id="l39.18">                      &quot; but has key &quot; + glodaMsg.messageKey + &quot; per gloda msg&quot;,</span>
<a href="#l39.19"></a><span id="l39.19">                     glodaMsg]);</span>
<a href="#l39.20"></a><span id="l39.20">   }</span>
<a href="#l39.21"></a><span id="l39.21">   mark_action(&quot;actual&quot;, &quot;verified message keys after compaction&quot;, []);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_sweep_folder.js</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_sweep_folder.js</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineat">@@ -77,17 +77,17 @@ var arbitraryGlodaId = 4096;</span>
<a href="#l40.4"></a><span id="l40.4">  */</span>
<a href="#l40.5"></a><span id="l40.5"> function test_propagate_filthy_from_folder_to_messages() {</span>
<a href="#l40.6"></a><span id="l40.6">   // mark the folder as filthy</span>
<a href="#l40.7"></a><span id="l40.7">   let [folder, msgSet] = make_folder_with_sets([{count: 3}]);</span>
<a href="#l40.8"></a><span id="l40.8">   let glodaFolder = Gloda.getFolderForFolder(folder);</span>
<a href="#l40.9"></a><span id="l40.9">   glodaFolder._dirtyStatus = glodaFolder.kFolderFilthy;</span>
<a href="#l40.10"></a><span id="l40.10"> </span>
<a href="#l40.11"></a><span id="l40.11">   // mark each header with a gloda-id so they can get marked filthy</span>
<a href="#l40.12"></a><span id="l40.12" class="difflineminus">-  for each (let msgHdr in msgSet.msgHdrs) {</span>
<a href="#l40.13"></a><span id="l40.13" class="difflineplus">+  for (let msgHdr of msgSet.msgHdrs) {</span>
<a href="#l40.14"></a><span id="l40.14">     msgHdr.setUint32Property(&quot;gloda-id&quot;, arbitraryGlodaId);</span>
<a href="#l40.15"></a><span id="l40.15">   }</span>
<a href="#l40.16"></a><span id="l40.16"> </span>
<a href="#l40.17"></a><span id="l40.17">   // force the database to see it as filthy so we can verify it changes</span>
<a href="#l40.18"></a><span id="l40.18">   glodaFolder._datastore.updateFolderDirtyStatus(glodaFolder);</span>
<a href="#l40.19"></a><span id="l40.19">   yield sqlExpectCount(1,</span>
<a href="#l40.20"></a><span id="l40.20">     &quot;SELECT COUNT(*) FROM folderLocations WHERE id = ? &quot; +</span>
<a href="#l40.21"></a><span id="l40.21">       &quot;AND dirtyStatus = ?&quot;, glodaFolder.id, glodaFolder.kFolderFilthy);</span>
<a href="#l40.22"></a><span id="l40.22" class="difflineat">@@ -100,17 +100,17 @@ function test_propagate_filthy_from_fold</span>
<a href="#l40.23"></a><span id="l40.23">   do_check_eq(glodaFolder.dirtyStatus, glodaFolder.kFolderDirty);</span>
<a href="#l40.24"></a><span id="l40.24">   // make sure the database sees it as dirty</span>
<a href="#l40.25"></a><span id="l40.25">   yield sqlExpectCount(1,</span>
<a href="#l40.26"></a><span id="l40.26">     &quot;SELECT COUNT(*) FROM folderLocations WHERE id = ? &quot; +</span>
<a href="#l40.27"></a><span id="l40.27">       &quot;AND dirtyStatus = ?&quot;, glodaFolder.id, glodaFolder.kFolderDirty);</span>
<a href="#l40.28"></a><span id="l40.28"> </span>
<a href="#l40.29"></a><span id="l40.29">   // The messages should be filthy per the headers (we force a commit of the</span>
<a href="#l40.30"></a><span id="l40.30">   //  database.)</span>
<a href="#l40.31"></a><span id="l40.31" class="difflineminus">-  for each (let msgHdr in msgSet.msgHdrs) {</span>
<a href="#l40.32"></a><span id="l40.32" class="difflineplus">+  for (let msgHdr of msgSet.msgHdrs) {</span>
<a href="#l40.33"></a><span id="l40.33">     do_check_eq(msgHdr.getUint32Property(&quot;gloda-dirty&quot;),</span>
<a href="#l40.34"></a><span id="l40.34">                 GlodaMsgIndexer.kMessageFilthy);</span>
<a href="#l40.35"></a><span id="l40.35">   }</span>
<a href="#l40.36"></a><span id="l40.36"> }</span>
<a href="#l40.37"></a><span id="l40.37"> </span>
<a href="#l40.38"></a><span id="l40.38"> </span>
<a href="#l40.39"></a><span id="l40.39"> /**</span>
<a href="#l40.40"></a><span id="l40.40">  * Make sure our counting pass and our indexing passes gets it right.  We test</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_intl.js</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_intl.js</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineat">@@ -193,18 +193,18 @@ var intlPhrases = [</span>
<a href="#l41.4"></a><span id="l41.4">  * Stash each created synthetic message in a resultList list on the phrase so</span>
<a href="#l41.5"></a><span id="l41.5">  *  that we can use them as expected query results in</span>
<a href="#l41.6"></a><span id="l41.6">  *  |test_fulltextsearch|.</span>
<a href="#l41.7"></a><span id="l41.7">  */</span>
<a href="#l41.8"></a><span id="l41.8"> function test_index(aPhrase) {</span>
<a href="#l41.9"></a><span id="l41.9">   // create a synthetic message for each of the delightful encoding types</span>
<a href="#l41.10"></a><span id="l41.10">   let messages = [];</span>
<a href="#l41.11"></a><span id="l41.11">   aPhrase.resultList = [];</span>
<a href="#l41.12"></a><span id="l41.12" class="difflineminus">-  for each (let [charset, encodings] in Iterator(aPhrase.encodings)) {</span>
<a href="#l41.13"></a><span id="l41.13" class="difflineminus">-    let [quoted, bodyEncoded] = encodings;</span>
<a href="#l41.14"></a><span id="l41.14" class="difflineplus">+  for (let charset in aPhrase.encodings) {</span>
<a href="#l41.15"></a><span id="l41.15" class="difflineplus">+    let [quoted, bodyEncoded] = aPhrase.encodings[charset];</span>
<a href="#l41.16"></a><span id="l41.16"> </span>
<a href="#l41.17"></a><span id="l41.17">     let smsg = gMessageGenerator.makeMessage({</span>
<a href="#l41.18"></a><span id="l41.18">       subject: quoted,</span>
<a href="#l41.19"></a><span id="l41.19">       body: {charset: charset, encoding: &quot;8bit&quot;, body: bodyEncoded},</span>
<a href="#l41.20"></a><span id="l41.20">       attachments: [</span>
<a href="#l41.21"></a><span id="l41.21">         {filename: quoted, body: &quot;gabba gabba hey&quot;},</span>
<a href="#l41.22"></a><span id="l41.22">       ],</span>
<a href="#l41.23"></a><span id="l41.23">       // save off the actual value for checking</span>
<a href="#l41.24"></a><span id="l41.24" class="difflineat">@@ -241,17 +241,17 @@ function verify_index(smsg, gmsg) {</span>
<a href="#l41.25"></a><span id="l41.25"> }</span>
<a href="#l41.26"></a><span id="l41.26"> </span>
<a href="#l41.27"></a><span id="l41.27"> /**</span>
<a href="#l41.28"></a><span id="l41.28">  * For each phrase, make sure that all of the searchPhrases either match or fail</span>
<a href="#l41.29"></a><span id="l41.29">  *  to match as appropriate.</span>
<a href="#l41.30"></a><span id="l41.30">  */</span>
<a href="#l41.31"></a><span id="l41.31"> function test_fulltextsearch(aPhrase)</span>
<a href="#l41.32"></a><span id="l41.32"> {</span>
<a href="#l41.33"></a><span id="l41.33" class="difflineminus">-  for each (let [, searchPhrase] in Iterator(aPhrase.searchPhrases)) {</span>
<a href="#l41.34"></a><span id="l41.34" class="difflineplus">+  for (let searchPhrase of aPhrase.searchPhrases) {</span>
<a href="#l41.35"></a><span id="l41.35">     let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l41.36"></a><span id="l41.36">     query.bodyMatches(searchPhrase.body);</span>
<a href="#l41.37"></a><span id="l41.37">     queryExpect(query, searchPhrase.match ? aPhrase.resultList : []);</span>
<a href="#l41.38"></a><span id="l41.38">     yield false; // queryExpect is async</span>
<a href="#l41.39"></a><span id="l41.39">   }</span>
<a href="#l41.40"></a><span id="l41.40"> }</span>
<a href="#l41.41"></a><span id="l41.41"> </span>
<a href="#l41.42"></a><span id="l41.42"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l42.1"></a><span id="l42.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_migration.js</span>
<a href="#l42.2"></a><span id="l42.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_migration.js</span>
<a href="#l42.3"></a><span id="l42.3" class="difflineat">@@ -60,17 +60,17 @@ function test_fix_missing_contacts_and_f</span>
<a href="#l42.4"></a><span id="l42.4">                yesMsgSet.glodaMessages[0].from.contact.id + &quot;, &quot; +</span>
<a href="#l42.5"></a><span id="l42.5">                yesMsgSet.glodaMessages[0].to[0].contact.id + &quot;)&quot;);</span>
<a href="#l42.6"></a><span id="l42.6"> </span>
<a href="#l42.7"></a><span id="l42.7">   // - Nuke the gloda caches so we totally forget those contact records.</span>
<a href="#l42.8"></a><span id="l42.8">   nukeGlodaCachesAndCollections();</span>
<a href="#l42.9"></a><span id="l42.9"> </span>
<a href="#l42.10"></a><span id="l42.10">   // - Manually mark the messages involving the inAB people with the _old_ bad</span>
<a href="#l42.11"></a><span id="l42.11">   //    id marker so that our scan will see them.</span>
<a href="#l42.12"></a><span id="l42.12" class="difflineminus">-  for each (let msgHdr in yesMsgSet.msgHdrs) {</span>
<a href="#l42.13"></a><span id="l42.13" class="difflineplus">+  for (let msgHdr of yesMsgSet.msgHdrs) {</span>
<a href="#l42.14"></a><span id="l42.14">     msgHdr.setUint32Property(&quot;gloda-id&quot;, GLODA_OLD_BAD_MESSAGE_ID);</span>
<a href="#l42.15"></a><span id="l42.15">   }</span>
<a href="#l42.16"></a><span id="l42.16"> </span>
<a href="#l42.17"></a><span id="l42.17">   // - mark the db schema version to the version with the bug (26)</span>
<a href="#l42.18"></a><span id="l42.18">   // sanity check that gloda actually populates the value with the current</span>
<a href="#l42.19"></a><span id="l42.19">   //  version correctly...</span>
<a href="#l42.20"></a><span id="l42.20">   do_check_eq(GlodaDatastore._actualSchemaVersion,</span>
<a href="#l42.21"></a><span id="l42.21">               GlodaDatastore._schemaVersion);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l43.1"></a><span id="l43.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_mime_attachments_size.js</span>
<a href="#l43.2"></a><span id="l43.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_mime_attachments_size.js</span>
<a href="#l43.3"></a><span id="l43.3" class="difflineat">@@ -203,17 +203,17 @@ function check_attachments(aMimeMsg, eps</span>
<a href="#l43.4"></a><span id="l43.4">    * inner contents of the attachment, you can add as many newlines as you want</span>
<a href="#l43.5"></a><span id="l43.5">    * in it, Unix or Windows, the count won't get past the bounds.</span>
<a href="#l43.6"></a><span id="l43.6">    */</span>
<a href="#l43.7"></a><span id="l43.7"> </span>
<a href="#l43.8"></a><span id="l43.8">   do_check_true(aMimeMsg.allUserAttachments.length &gt; 0);</span>
<a href="#l43.9"></a><span id="l43.9"> </span>
<a href="#l43.10"></a><span id="l43.10">   let totalSize = htmlText.length;</span>
<a href="#l43.11"></a><span id="l43.11"> </span>
<a href="#l43.12"></a><span id="l43.12" class="difflineminus">-  for each (let [i, att] in Iterator(aMimeMsg.allUserAttachments)) {</span>
<a href="#l43.13"></a><span id="l43.13" class="difflineplus">+  for (let att of aMimeMsg.allUserAttachments) {</span>
<a href="#l43.14"></a><span id="l43.14">     dump(&quot;*** Attachment now is &quot; + att.name + &quot; &quot; + att.size + &quot;\n&quot;);</span>
<a href="#l43.15"></a><span id="l43.15">     do_check_true(Math.abs(att.size - originalTextByteCount) &lt;= epsilon);</span>
<a href="#l43.16"></a><span id="l43.16">     totalSize += att.size;</span>
<a href="#l43.17"></a><span id="l43.17">   }</span>
<a href="#l43.18"></a><span id="l43.18"> </span>
<a href="#l43.19"></a><span id="l43.19">   // undefined means true</span>
<a href="#l43.20"></a><span id="l43.20">   if (checkTotalSize !== false) {</span>
<a href="#l43.21"></a><span id="l43.21">     dump(&quot;*** Total size comparison: &quot; + totalSize + &quot; vs &quot; + aMimeMsg.size + &quot;\n&quot;);</span>
<a href="#l43.22"></a><span id="l43.22" class="difflineat">@@ -287,18 +287,20 @@ function check_bogus_parts(aMimeMsg, { e</span>
<a href="#l43.23"></a><span id="l43.23">   let sep = (&quot;@mozilla.org/windows-registry-key;1&quot; in Cc) ? &quot;\r\n&quot; : &quot;\n&quot;;</span>
<a href="#l43.24"></a><span id="l43.24"> </span>
<a href="#l43.25"></a><span id="l43.25">   // dump(aMimeMsg.prettyString()+&quot;\n&quot;);</span>
<a href="#l43.26"></a><span id="l43.26"> </span>
<a href="#l43.27"></a><span id="l43.27">   if (checkSize) {</span>
<a href="#l43.28"></a><span id="l43.28">     let partSize = 0;</span>
<a href="#l43.29"></a><span id="l43.29">     // The attachment, although a MimeUnknown part, is actually plain/text that</span>
<a href="#l43.30"></a><span id="l43.30">     // contains the whole attached message, including headers. Count them.</span>
<a href="#l43.31"></a><span id="l43.31" class="difflineminus">-    for each (let [k, v] in Iterator(bogusMessage.headers))</span>
<a href="#l43.32"></a><span id="l43.32" class="difflineplus">+    for (let k in bogusMessage.headers) {</span>
<a href="#l43.33"></a><span id="l43.33" class="difflineplus">+      let v = bogusMessage.headers[k];</span>
<a href="#l43.34"></a><span id="l43.34">       partSize += (k + &quot;: &quot; + v + sep).length;</span>
<a href="#l43.35"></a><span id="l43.35" class="difflineplus">+    }</span>
<a href="#l43.36"></a><span id="l43.36">     // That's the newline between the headers and the message body.</span>
<a href="#l43.37"></a><span id="l43.37">     partSize += sep.length;</span>
<a href="#l43.38"></a><span id="l43.38">     // That's the message body.</span>
<a href="#l43.39"></a><span id="l43.39">     partSize += originalTextByteCount;</span>
<a href="#l43.40"></a><span id="l43.40">     // That's the total length that's to be returned by the MimeMessage abstraction.</span>
<a href="#l43.41"></a><span id="l43.41">     let totalSize = htmlText.length + partSize;</span>
<a href="#l43.42"></a><span id="l43.42">     dump(totalSize+&quot; vs &quot;+aMimeMsg.size+&quot;\n&quot;);</span>
<a href="#l43.43"></a><span id="l43.43">     do_check_true(Math.abs(aMimeMsg.size - totalSize) &lt;= epsilon);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l44.1"></a><span id="l44.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_mime_emitter.js</span>
<a href="#l44.2"></a><span id="l44.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_mime_emitter.js</span>
<a href="#l44.3"></a><span id="l44.3" class="difflineat">@@ -499,17 +499,17 @@ var expectedAttachmentsInfo = [</span>
<a href="#l44.4"></a><span id="l44.4">   },</span>
<a href="#l44.5"></a><span id="l44.5">   {</span>
<a href="#l44.6"></a><span id="l44.6">     allAttachmentsContentTypes: [&quot;application/x-funky&quot;, &quot;image/png&quot;, &quot;application/x-funky&quot;],</span>
<a href="#l44.7"></a><span id="l44.7">     allUserAttachmentsContentTypes: [&quot;application/x-funky&quot;, &quot;message/rfc822&quot;]</span>
<a href="#l44.8"></a><span id="l44.8">   },</span>
<a href="#l44.9"></a><span id="l44.9"> ];</span>
<a href="#l44.10"></a><span id="l44.10"> </span>
<a href="#l44.11"></a><span id="l44.11"> function test_attachments_correctness () {</span>
<a href="#l44.12"></a><span id="l44.12" class="difflineminus">-  for each (let [i, params] in Iterator(attMessagesParams)) {</span>
<a href="#l44.13"></a><span id="l44.13" class="difflineplus">+  for (let [i, params] of attMessagesParams.entries()) {</span>
<a href="#l44.14"></a><span id="l44.14">     let synMsg = gMessageGenerator.makeMessage(params);</span>
<a href="#l44.15"></a><span id="l44.15">     let synSet = new SyntheticMessageSet([synMsg]);</span>
<a href="#l44.16"></a><span id="l44.16">     yield add_sets_to_folder(gInbox, [synSet]);</span>
<a href="#l44.17"></a><span id="l44.17"> </span>
<a href="#l44.18"></a><span id="l44.18">     let msgHdr = synSet.getMsgHdr(0);</span>
<a href="#l44.19"></a><span id="l44.19">     // dump(synMsg.toMboxString()+&quot;\n\n&quot;);</span>
<a href="#l44.20"></a><span id="l44.20"> </span>
<a href="#l44.21"></a><span id="l44.21">     MsgHdrToMimeMessage(msgHdr, null, function(aMsgHdr, aMimeMsg) {</span>
<a href="#l44.22"></a><span id="l44.22" class="difflineat">@@ -518,25 +518,25 @@ function test_attachments_correctness ()</span>
<a href="#l44.23"></a><span id="l44.23">         if (&quot;firstAttachmentName&quot; in expected) {</span>
<a href="#l44.24"></a><span id="l44.24">           let att = aMimeMsg.allUserAttachments[0];</span>
<a href="#l44.25"></a><span id="l44.25">           do_check_eq(att.name.length, expected.firstAttachmentName.length);</span>
<a href="#l44.26"></a><span id="l44.26">           for (let i = 0; i &lt; att.name.length; ++i)</span>
<a href="#l44.27"></a><span id="l44.27">             do_check_eq(att.name.charCodeAt(i), expected.firstAttachmentName.charCodeAt(i));</span>
<a href="#l44.28"></a><span id="l44.28">         }</span>
<a href="#l44.29"></a><span id="l44.29"> </span>
<a href="#l44.30"></a><span id="l44.30">         do_check_eq(aMimeMsg.allAttachments.length, expected.allAttachmentsContentTypes.length);</span>
<a href="#l44.31"></a><span id="l44.31" class="difflineminus">-        for each (let [j, att] in Iterator(aMimeMsg.allAttachments))</span>
<a href="#l44.32"></a><span id="l44.32" class="difflineplus">+        for (let [j, att] of aMimeMsg.allAttachments.entries())</span>
<a href="#l44.33"></a><span id="l44.33">           do_check_eq(att.contentType, expected.allAttachmentsContentTypes[j]);</span>
<a href="#l44.34"></a><span id="l44.34"> </span>
<a href="#l44.35"></a><span id="l44.35">         do_check_eq(aMimeMsg.allUserAttachments.length, expected.allUserAttachmentsContentTypes.length);</span>
<a href="#l44.36"></a><span id="l44.36" class="difflineminus">-        for each (let [j, att] in Iterator(aMimeMsg.allUserAttachments))</span>
<a href="#l44.37"></a><span id="l44.37" class="difflineplus">+        for (let [j, att] of aMimeMsg.allUserAttachments.entries())</span>
<a href="#l44.38"></a><span id="l44.38">           do_check_eq(att.contentType, expected.allUserAttachmentsContentTypes[j]);</span>
<a href="#l44.39"></a><span id="l44.39"> </span>
<a href="#l44.40"></a><span id="l44.40">         // Test</span>
<a href="#l44.41"></a><span id="l44.41" class="difflineminus">-        for each (let [, att] in Iterator(aMimeMsg.allUserAttachments)) {</span>
<a href="#l44.42"></a><span id="l44.42" class="difflineplus">+        for (let att of aMimeMsg.allUserAttachments) {</span>
<a href="#l44.43"></a><span id="l44.43">           let uri = aMsgHdr.folder.getUriForMsg(aMsgHdr);</span>
<a href="#l44.44"></a><span id="l44.44">           let glodaAttachment =</span>
<a href="#l44.45"></a><span id="l44.45">             GlodaFundAttr.glodaAttFromMimeAtt({ folderMessageURI: uri }, att);</span>
<a href="#l44.46"></a><span id="l44.46">           // The GlodaAttachment appends the filename, which is not always</span>
<a href="#l44.47"></a><span id="l44.47">           // present</span>
<a href="#l44.48"></a><span id="l44.48">           do_check_true(glodaAttachment.url.startsWith(att.url));</span>
<a href="#l44.49"></a><span id="l44.49">         }</span>
<a href="#l44.50"></a><span id="l44.50"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l45.1"></a><span id="l45.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_core.js</span>
<a href="#l45.2"></a><span id="l45.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_core.js</span>
<a href="#l45.3"></a><span id="l45.3" class="difflineat">@@ -43,30 +43,32 @@ function Widget(inum, date, str, notabil</span>
<a href="#l45.4"></a><span id="l45.4"> }</span>
<a href="#l45.5"></a><span id="l45.5"> Widget.prototype = {</span>
<a href="#l45.6"></a><span id="l45.6">   _clone: function() {</span>
<a href="#l45.7"></a><span id="l45.7">     let clonus = new Widget(this._inum, this._date, this._str, this._notability,</span>
<a href="#l45.8"></a><span id="l45.8">                             this._text1, this._text2);</span>
<a href="#l45.9"></a><span id="l45.9">     clonus._id = this._id;</span>
<a href="#l45.10"></a><span id="l45.10">     clonus._iAmAClone = true;</span>
<a href="#l45.11"></a><span id="l45.11"> </span>
<a href="#l45.12"></a><span id="l45.12" class="difflineminus">-    for each (let [key, value] in Iterator(this)) {</span>
<a href="#l45.13"></a><span id="l45.13" class="difflineplus">+    for (let key of Object.keys(this)) {</span>
<a href="#l45.14"></a><span id="l45.14" class="difflineplus">+      let value = this[key];</span>
<a href="#l45.15"></a><span id="l45.15">       if (key.startsWith(&quot;_&quot;))</span>
<a href="#l45.16"></a><span id="l45.16">         continue;</span>
<a href="#l45.17"></a><span id="l45.17">       clonus[key] = value;</span>
<a href="#l45.18"></a><span id="l45.18">       if (key in this._indexStash) {</span>
<a href="#l45.19"></a><span id="l45.19">         this[key] = this._indexStash[key];</span>
<a href="#l45.20"></a><span id="l45.20">       }</span>
<a href="#l45.21"></a><span id="l45.21">     }</span>
<a href="#l45.22"></a><span id="l45.22"> </span>
<a href="#l45.23"></a><span id="l45.23">     return clonus;</span>
<a href="#l45.24"></a><span id="l45.24">   },</span>
<a href="#l45.25"></a><span id="l45.25">   _stash: function() {</span>
<a href="#l45.26"></a><span id="l45.26">     this._indexStash = {};</span>
<a href="#l45.27"></a><span id="l45.27" class="difflineminus">-    for each (let [key, value] in Iterator(this)) {</span>
<a href="#l45.28"></a><span id="l45.28" class="difflineplus">+    for (let key of Object.keys(this)) {</span>
<a href="#l45.29"></a><span id="l45.29" class="difflineplus">+      let value = this[key];</span>
<a href="#l45.30"></a><span id="l45.30">       if (key[0].startsWith(&quot;_&quot;))</span>
<a href="#l45.31"></a><span id="l45.31">         continue;</span>
<a href="#l45.32"></a><span id="l45.32">       this._indexStash[key] = value;</span>
<a href="#l45.33"></a><span id="l45.33">     }</span>
<a href="#l45.34"></a><span id="l45.34">   },</span>
<a href="#l45.35"></a><span id="l45.35"> </span>
<a href="#l45.36"></a><span id="l45.36">   get id() { return this._id; },</span>
<a href="#l45.37"></a><span id="l45.37">   set id(aVal) { this._id = aVal; },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l46.1"></a><span id="l46.1" class="difflineminus">--- a/mailnews/extensions/bayesian-spam-filter/test/unit/test_customTokenization.js</span>
<a href="#l46.2"></a><span id="l46.2" class="difflineplus">+++ b/mailnews/extensions/bayesian-spam-filter/test/unit/test_customTokenization.js</span>
<a href="#l46.3"></a><span id="l46.3" class="difflineat">@@ -100,24 +100,24 @@ var listener =</span>
<a href="#l46.4"></a><span id="l46.4">   onMessageTraitDetails: function(aMsgURI, aProTrait, {}, aTokenString,</span>
<a href="#l46.5"></a><span id="l46.5">                                   aTokenPercents, aRunningPercents)</span>
<a href="#l46.6"></a><span id="l46.6">   {</span>
<a href="#l46.7"></a><span id="l46.7">     print(&quot;Details for &quot; + aMsgURI);</span>
<a href="#l46.8"></a><span id="l46.8">     for (var i = 0; i &lt; aTokenString.length; i++)</span>
<a href="#l46.9"></a><span id="l46.9">       print(&quot;Token &quot; + aTokenString[i]);</span>
<a href="#l46.10"></a><span id="l46.10"> </span>
<a href="#l46.11"></a><span id="l46.11">     // we should have these tokens</span>
<a href="#l46.12"></a><span id="l46.12" class="difflineminus">-    for each (var value in gTest.tokens)</span>
<a href="#l46.13"></a><span id="l46.13" class="difflineplus">+    for (var value of gTest.tokens)</span>
<a href="#l46.14"></a><span id="l46.14">     {</span>
<a href="#l46.15"></a><span id="l46.15">       print(&quot;We should have '&quot; + value + &quot;'? &quot;);</span>
<a href="#l46.16"></a><span id="l46.16">       do_check_true(aTokenString.indexOf(value) &gt;= 0);</span>
<a href="#l46.17"></a><span id="l46.17">     }</span>
<a href="#l46.18"></a><span id="l46.18"> </span>
<a href="#l46.19"></a><span id="l46.19">     // should not have these tokens</span>
<a href="#l46.20"></a><span id="l46.20" class="difflineminus">-    for each (var value in gTest.nottokens)</span>
<a href="#l46.21"></a><span id="l46.21" class="difflineplus">+    for (var value of gTest.nottokens)</span>
<a href="#l46.22"></a><span id="l46.22">     {</span>
<a href="#l46.23"></a><span id="l46.23">       print(&quot;We should not have '&quot; + value + &quot;'? &quot;);</span>
<a href="#l46.24"></a><span id="l46.24">       do_check_true(aTokenString.indexOf(value) &lt; 0);</span>
<a href="#l46.25"></a><span id="l46.25">     }</span>
<a href="#l46.26"></a><span id="l46.26">     startCommand();</span>
<a href="#l46.27"></a><span id="l46.27">   }</span>
<a href="#l46.28"></a><span id="l46.28"> };</span>
<a href="#l46.29"></a><span id="l46.29"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l47.1"></a><span id="l47.1" class="difflineminus">--- a/mailnews/imap/test/unit/head_server.js</span>
<a href="#l47.2"></a><span id="l47.2" class="difflineplus">+++ b/mailnews/imap/test/unit/head_server.js</span>
<a href="#l47.3"></a><span id="l47.3" class="difflineat">@@ -33,17 +33,17 @@ function makeServer(daemon, infoString, </span>
<a href="#l47.4"></a><span id="l47.4">     return makeServer(daemon, configurations[infoString].join(&quot;,&quot;), otherProps);</span>
<a href="#l47.5"></a><span id="l47.5"> </span>
<a href="#l47.6"></a><span id="l47.6">   function createHandler(d) {</span>
<a href="#l47.7"></a><span id="l47.7">     var handler = new IMAP_RFC3501_handler(d);</span>
<a href="#l47.8"></a><span id="l47.8">     if (!infoString)</span>
<a href="#l47.9"></a><span id="l47.9">       infoString = &quot;RFC2195&quot;;</span>
<a href="#l47.10"></a><span id="l47.10"> </span>
<a href="#l47.11"></a><span id="l47.11">     var parts = infoString.split(/ *, */);</span>
<a href="#l47.12"></a><span id="l47.12" class="difflineminus">-    for each (var part in parts) {</span>
<a href="#l47.13"></a><span id="l47.13" class="difflineplus">+    for (var part of parts) {</span>
<a href="#l47.14"></a><span id="l47.14">       if (part.startsWith(&quot;RFC&quot;))</span>
<a href="#l47.15"></a><span id="l47.15">         mixinExtension(handler, eval(&quot;IMAP_&quot; + part + &quot;_extension&quot;));</span>
<a href="#l47.16"></a><span id="l47.16">     }</span>
<a href="#l47.17"></a><span id="l47.17">     if (otherProps) {</span>
<a href="#l47.18"></a><span id="l47.18">       for (var prop in otherProps)</span>
<a href="#l47.19"></a><span id="l47.19">         handler[prop] = otherProps[prop];</span>
<a href="#l47.20"></a><span id="l47.20">     }</span>
<a href="#l47.21"></a><span id="l47.21">     return handler;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l48.1"></a><span id="l48.1" class="difflineminus">--- a/mailnews/imap/test/unit/test_listSubscribed.js</span>
<a href="#l48.2"></a><span id="l48.2" class="difflineplus">+++ b/mailnews/imap/test/unit/test_listSubscribed.js</span>
<a href="#l48.3"></a><span id="l48.3" class="difflineat">@@ -130,13 +130,13 @@ function specForFileName(aFileName)</span>
<a href="#l48.4"></a><span id="l48.4"> {</span>
<a href="#l48.5"></a><span id="l48.5">   let file = do_get_file(&quot;../../../data/&quot; + aFileName);</span>
<a href="#l48.6"></a><span id="l48.6">   let msgfileuri = Services.io.newFileURI(file).QueryInterface(Ci.nsIFileURL);</span>
<a href="#l48.7"></a><span id="l48.7">   return msgfileuri.spec;</span>
<a href="#l48.8"></a><span id="l48.8"> }</span>
<a href="#l48.9"></a><span id="l48.9"> </span>
<a href="#l48.10"></a><span id="l48.10"> function recursiveDeleteMailboxes(aMailbox)</span>
<a href="#l48.11"></a><span id="l48.11"> {</span>
<a href="#l48.12"></a><span id="l48.12" class="difflineminus">-  for each (var child in aMailbox.allChildren) {</span>
<a href="#l48.13"></a><span id="l48.13" class="difflineplus">+  for (var child of aMailbox.allChildren) {</span>
<a href="#l48.14"></a><span id="l48.14">     recursiveDeleteMailboxes(child);</span>
<a href="#l48.15"></a><span id="l48.15">   }</span>
<a href="#l48.16"></a><span id="l48.16">   IMAPPump.daemon.deleteMailbox(aMailbox);</span>
<a href="#l48.17"></a><span id="l48.17"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l49.1"></a><span id="l49.1" class="difflineminus">--- a/mailnews/imap/test/unit/test_lsub.js</span>
<a href="#l49.2"></a><span id="l49.2" class="difflineplus">+++ b/mailnews/imap/test/unit/test_lsub.js</span>
<a href="#l49.3"></a><span id="l49.3" class="difflineat">@@ -95,13 +95,13 @@ function specForFileName(aFileName)</span>
<a href="#l49.4"></a><span id="l49.4"> {</span>
<a href="#l49.5"></a><span id="l49.5">   let file = do_get_file(&quot;../../../data/&quot; + aFileName);</span>
<a href="#l49.6"></a><span id="l49.6">   let msgfileuri = Services.io.newFileURI(file).QueryInterface(Ci.nsIFileURL);</span>
<a href="#l49.7"></a><span id="l49.7">   return msgfileuri.spec;</span>
<a href="#l49.8"></a><span id="l49.8"> }</span>
<a href="#l49.9"></a><span id="l49.9"> </span>
<a href="#l49.10"></a><span id="l49.10"> function recursiveDeleteMailboxes(aMailbox)</span>
<a href="#l49.11"></a><span id="l49.11"> {</span>
<a href="#l49.12"></a><span id="l49.12" class="difflineminus">-  for each (var child in aMailbox.allChildren) {</span>
<a href="#l49.13"></a><span id="l49.13" class="difflineplus">+  for (var child of aMailbox.allChildren) {</span>
<a href="#l49.14"></a><span id="l49.14">     recursiveDeleteMailboxes(child);</span>
<a href="#l49.15"></a><span id="l49.15">   }</span>
<a href="#l49.16"></a><span id="l49.16">   IMAPPump.daemon.deleteMailbox(aMailbox);</span>
<a href="#l49.17"></a><span id="l49.17"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l50.1"></a><span id="l50.1" class="difflineminus">--- a/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js</span>
<a href="#l50.2"></a><span id="l50.2" class="difflineplus">+++ b/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js</span>
<a href="#l50.3"></a><span id="l50.3" class="difflineat">@@ -101,17 +101,17 @@ function addMessagesToServer(messages, m</span>
<a href="#l50.4"></a><span id="l50.4">   {</span>
<a href="#l50.5"></a><span id="l50.5">     let URI =</span>
<a href="#l50.6"></a><span id="l50.6">       Services.io.newFileURI(message.file).QueryInterface(Ci.nsIFileURL);</span>
<a href="#l50.7"></a><span id="l50.7">     message.spec = URI.spec;</span>
<a href="#l50.8"></a><span id="l50.8">     // We can't get the headers again, so just pass on the message id</span>
<a href="#l50.9"></a><span id="l50.9">     gExpectedEvents.push([gMFNService.msgAdded, {expectedMessageId: message.messageId}]);</span>
<a href="#l50.10"></a><span id="l50.10">   });</span>
<a href="#l50.11"></a><span id="l50.11">   gExpectedEvents.push([gMFNService.msgsClassified,</span>
<a href="#l50.12"></a><span id="l50.12" class="difflineminus">-                        [hdr.messageId for each (hdr in messages)],</span>
<a href="#l50.13"></a><span id="l50.13" class="difflineplus">+                        messages.map(hdr =&gt; hdr.messageId),</span>
<a href="#l50.14"></a><span id="l50.14">                         false, false]);</span>
<a href="#l50.15"></a><span id="l50.15"> </span>
<a href="#l50.16"></a><span id="l50.16">   // Create the imapMessages and store them on the mailbox</span>
<a href="#l50.17"></a><span id="l50.17">   messages.forEach(function (message)</span>
<a href="#l50.18"></a><span id="l50.18">   {</span>
<a href="#l50.19"></a><span id="l50.19">     mailbox.addMessage(new imapMessage(message.spec, mailbox.uidnext++, []));</span>
<a href="#l50.20"></a><span id="l50.20">   });</span>
<a href="#l50.21"></a><span id="l50.21"> </span>
<a href="#l50.22"></a><span id="l50.22" class="difflineat">@@ -137,17 +137,17 @@ function copyMessages(messages, isMove, </span>
<a href="#l50.23"></a><span id="l50.23">     // We can't use the headers directly, because the notifications we'll</span>
<a href="#l50.24"></a><span id="l50.24">     // receive are for message headers in the destination folder</span>
<a href="#l50.25"></a><span id="l50.25">     gExpectedEvents.push([gMFNService.msgKeyChanged,</span>
<a href="#l50.26"></a><span id="l50.26">                           {expectedMessageId: message.messageId}]);</span>
<a href="#l50.27"></a><span id="l50.27">     gExpectedEvents.push([gMFNService.msgAdded,</span>
<a href="#l50.28"></a><span id="l50.28">                           {expectedMessageId: message.messageId}]);</span>
<a href="#l50.29"></a><span id="l50.29">   });</span>
<a href="#l50.30"></a><span id="l50.30">   gExpectedEvents.push([gMFNService.msgsClassified,</span>
<a href="#l50.31"></a><span id="l50.31" class="difflineminus">-                        [hdr.messageId for each (hdr in messages)],</span>
<a href="#l50.32"></a><span id="l50.32" class="difflineplus">+                        messages.map(hdr =&gt; hdr.messageId),</span>
<a href="#l50.33"></a><span id="l50.33">                         false, false]);</span>
<a href="#l50.34"></a><span id="l50.34">   gCopyService.CopyMessages(srcFolder, array, destFolder, isMove, copyListener, gMsgWindow, true);</span>
<a href="#l50.35"></a><span id="l50.35">   gCurrStatus |= kStatus.functionCallDone;</span>
<a href="#l50.36"></a><span id="l50.36"> </span>
<a href="#l50.37"></a><span id="l50.37">   gServer.performTest(&quot;COPY&quot;);</span>
<a href="#l50.38"></a><span id="l50.38"> </span>
<a href="#l50.39"></a><span id="l50.39">   gFolderBeingUpdated = destFolder;</span>
<a href="#l50.40"></a><span id="l50.40">   doUpdateFolder(gTest);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l51.1"></a><span id="l51.1" class="difflineminus">--- a/mailnews/local/test/unit/test_pop3DownloadTempFileHandling.js</span>
<a href="#l51.2"></a><span id="l51.2" class="difflineplus">+++ b/mailnews/local/test/unit/test_pop3DownloadTempFileHandling.js</span>
<a href="#l51.3"></a><span id="l51.3" class="difflineat">@@ -22,17 +22,17 @@ function run_test()</span>
<a href="#l51.4"></a><span id="l51.4">   do_test_pending();</span>
<a href="#l51.5"></a><span id="l51.5">   gPOP3Pump.run();</span>
<a href="#l51.6"></a><span id="l51.6"> }</span>
<a href="#l51.7"></a><span id="l51.7"> </span>
<a href="#l51.8"></a><span id="l51.8"> function continueTest()</span>
<a href="#l51.9"></a><span id="l51.9"> {</span>
<a href="#l51.10"></a><span id="l51.10">   dump(&quot;temp file path = &quot; + gExpectedFiles[0].path + &quot;\n&quot;);</span>
<a href="#l51.11"></a><span id="l51.11">   dump(&quot;temp file path = &quot; + gExpectedFiles[1].path + &quot;\n&quot;);</span>
<a href="#l51.12"></a><span id="l51.12" class="difflineminus">-  for each (let expectedFile in gExpectedFiles)</span>
<a href="#l51.13"></a><span id="l51.13" class="difflineplus">+  for (let expectedFile of gExpectedFiles)</span>
<a href="#l51.14"></a><span id="l51.14">     do_check_false(expectedFile.exists());</span>
<a href="#l51.15"></a><span id="l51.15"> </span>
<a href="#l51.16"></a><span id="l51.16">   // get message headers for the inbox folder</span>
<a href="#l51.17"></a><span id="l51.17">   let enumerator = localAccountUtils.inboxFolder.msgDatabase.EnumerateMessages();</span>
<a href="#l51.18"></a><span id="l51.18">   var msgCount = 0;</span>
<a href="#l51.19"></a><span id="l51.19">   while (enumerator.hasMoreElements())</span>
<a href="#l51.20"></a><span id="l51.20">   {</span>
<a href="#l51.21"></a><span id="l51.21">     let hdr = enumerator.getNext().QueryInterface(Ci.nsIMsgDBHdr);</span>
<a href="#l51.22"></a><span id="l51.22" class="difflineat">@@ -50,15 +50,15 @@ function createExpectedTemporaryFiles(nu</span>
<a href="#l51.23"></a><span id="l51.23">     file.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, 0600);</span>
<a href="#l51.24"></a><span id="l51.24">     return file;</span>
<a href="#l51.25"></a><span id="l51.25">   }</span>
<a href="#l51.26"></a><span id="l51.26"> </span>
<a href="#l51.27"></a><span id="l51.27">   let expectedFiles = [];</span>
<a href="#l51.28"></a><span id="l51.28">   for (i = 0; i &lt; numFiles; i++)</span>
<a href="#l51.29"></a><span id="l51.29">     expectedFiles.push(createTemporaryFile());</span>
<a href="#l51.30"></a><span id="l51.30"> </span>
<a href="#l51.31"></a><span id="l51.31" class="difflineminus">-  for each (let expectedFile in expectedFiles)</span>
<a href="#l51.32"></a><span id="l51.32" class="difflineplus">+  for (let expectedFile of expectedFiles)</span>
<a href="#l51.33"></a><span id="l51.33">     expectedFile.remove(false);</span>
<a href="#l51.34"></a><span id="l51.34"> </span>
<a href="#l51.35"></a><span id="l51.35">   return expectedFiles;</span>
<a href="#l51.36"></a><span id="l51.36"> }</span>
<a href="#l51.37"></a><span id="l51.37"> </span>
<a href="#l51.38"></a><span id="l51.38"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l52.1"></a><span id="l52.1" class="difflineminus">--- a/mailnews/mime/test/unit/test_hidden_attachments.js</span>
<a href="#l52.2"></a><span id="l52.2" class="difflineplus">+++ b/mailnews/mime/test/unit/test_hidden_attachments.js</span>
<a href="#l52.3"></a><span id="l52.3" class="difflineat">@@ -95,18 +95,18 @@ var messages = [</span>
<a href="#l52.4"></a><span id="l52.4"> </span>
<a href="#l52.5"></a><span id="l52.5"> var gStreamListener = {</span>
<a href="#l52.6"></a><span id="l52.6">   QueryInterface: XPCOMUtils.generateQI([Ci.nsIStreamListener]),</span>
<a href="#l52.7"></a><span id="l52.7"> </span>
<a href="#l52.8"></a><span id="l52.8">   // nsIRequestObserver part</span>
<a href="#l52.9"></a><span id="l52.9">   onStartRequest: function (aRequest, aContext) {</span>
<a href="#l52.10"></a><span id="l52.10">   },</span>
<a href="#l52.11"></a><span id="l52.11">   onStopRequest: function (aRequest, aContext, aStatusCode) {</span>
<a href="#l52.12"></a><span id="l52.12" class="difflineminus">-    let expectedAttachments = [i.filename for each (i in this.allAttachments)</span>
<a href="#l52.13"></a><span id="l52.13" class="difflineminus">-                               if (i.shouldShow)];</span>
<a href="#l52.14"></a><span id="l52.14" class="difflineplus">+    let expectedAttachments = this.allAttachments.filter(i =&gt; i.shouldShow).</span>
<a href="#l52.15"></a><span id="l52.15" class="difflineplus">+      map(i =&gt; i.filename);</span>
<a href="#l52.16"></a><span id="l52.16">     do_check_eq(expectedAttachments.length,</span>
<a href="#l52.17"></a><span id="l52.17">                 gMessageHeaderSink.attachments.length);</span>
<a href="#l52.18"></a><span id="l52.18"> </span>
<a href="#l52.19"></a><span id="l52.19">     for (let i = 0; i &lt; gMessageHeaderSink.attachments.length; i++) {</span>
<a href="#l52.20"></a><span id="l52.20">       // If the expected attachment's name is empty, we probably generated a</span>
<a href="#l52.21"></a><span id="l52.21">       // name like &quot;Part 1.2&quot;, so don't bother checking that the names match</span>
<a href="#l52.22"></a><span id="l52.22">       // (they won't).</span>
<a href="#l52.23"></a><span id="l52.23">       if (expectedAttachments[i])</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l53.1"></a><span id="l53.1" class="difflineminus">--- a/mailnews/mime/test/unit/test_mimeStreaming.js</span>
<a href="#l53.2"></a><span id="l53.2" class="difflineplus">+++ b/mailnews/mime/test/unit/test_mimeStreaming.js</span>
<a href="#l53.3"></a><span id="l53.3" class="difflineat">@@ -29,17 +29,17 @@ var gUrlListener = {</span>
<a href="#l53.4"></a><span id="l53.4"> </span>
<a href="#l53.5"></a><span id="l53.5"> </span>
<a href="#l53.6"></a><span id="l53.6"> localAccountUtils.loadLocalMailAccount();</span>
<a href="#l53.7"></a><span id="l53.7"> </span>
<a href="#l53.8"></a><span id="l53.8"> function run_test()</span>
<a href="#l53.9"></a><span id="l53.9"> {</span>
<a href="#l53.10"></a><span id="l53.10">   do_test_pending();</span>
<a href="#l53.11"></a><span id="l53.11">   localAccountUtils.inboxFolder.QueryInterface(Ci.nsIMsgLocalMailFolder);</span>
<a href="#l53.12"></a><span id="l53.12" class="difflineminus">-  for each(let fileName in gTestFiles) {</span>
<a href="#l53.13"></a><span id="l53.13" class="difflineplus">+  for (let fileName of gTestFiles) {</span>
<a href="#l53.14"></a><span id="l53.14">     localAccountUtils.inboxFolder.addMessage(IOUtils.loadFileToString(do_get_file(fileName)));</span>
<a href="#l53.15"></a><span id="l53.15">   };</span>
<a href="#l53.16"></a><span id="l53.16">   gMsgEnumerator = localAccountUtils.inboxFolder.msgDatabase.EnumerateMessages();</span>
<a href="#l53.17"></a><span id="l53.17">   doNextTest();</span>
<a href="#l53.18"></a><span id="l53.18"> }</span>
<a href="#l53.19"></a><span id="l53.19"> </span>
<a href="#l53.20"></a><span id="l53.20"> function streamMsg(msgHdr)</span>
<a href="#l53.21"></a><span id="l53.21"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l54.1"></a><span id="l54.1" class="difflineminus">--- a/mailnews/news/test/unit/head_server_setup.js</span>
<a href="#l54.2"></a><span id="l54.2" class="difflineplus">+++ b/mailnews/news/test/unit/head_server_setup.js</span>
<a href="#l54.3"></a><span id="l54.3" class="difflineat">@@ -178,17 +178,17 @@ function create_post(baseURL, file) {</span>
<a href="#l54.4"></a><span id="l54.4"> function resetFolder(folder) {</span>
<a href="#l54.5"></a><span id="l54.5">   var headerEnum = folder.messages;</span>
<a href="#l54.6"></a><span id="l54.6">   var headers = [];</span>
<a href="#l54.7"></a><span id="l54.7">   while (headerEnum.hasMoreElements())</span>
<a href="#l54.8"></a><span id="l54.8">     headers.push(headerEnum.getNext().QueryInterface(Ci.nsIMsgDBHdr));</span>
<a href="#l54.9"></a><span id="l54.9"> </span>
<a href="#l54.10"></a><span id="l54.10">   var db = folder.msgDatabase;</span>
<a href="#l54.11"></a><span id="l54.11">   db.dBFolderInfo.knownArtsSet = &quot;&quot;;</span>
<a href="#l54.12"></a><span id="l54.12" class="difflineminus">-  for each (var header in headers) {</span>
<a href="#l54.13"></a><span id="l54.13" class="difflineplus">+  for (var header of headers) {</span>
<a href="#l54.14"></a><span id="l54.14">     db.DeleteHeader(header, null, true, false);</span>
<a href="#l54.15"></a><span id="l54.15">   }</span>
<a href="#l54.16"></a><span id="l54.16">   dump(&quot;resetting folder\n&quot;);</span>
<a href="#l54.17"></a><span id="l54.17">   folder.msgDatabase = null;</span>
<a href="#l54.18"></a><span id="l54.18"> }</span>
<a href="#l54.19"></a><span id="l54.19"> </span>
<a href="#l54.20"></a><span id="l54.20"> function do_check_transaction(real, expected) {</span>
<a href="#l54.21"></a><span id="l54.21">   // real.them may have an extra QUIT on the end, where the stream is only</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l55.1"></a><span id="l55.1" class="difflineminus">--- a/mailnews/news/test/unit/test_uriParser.js</span>
<a href="#l55.2"></a><span id="l55.2" class="difflineplus">+++ b/mailnews/news/test/unit/test_uriParser.js</span>
<a href="#l55.3"></a><span id="l55.3" class="difflineat">@@ -138,29 +138,29 @@ var invalid_uris = [</span>
<a href="#l55.4"></a><span id="l55.4">   &quot;nntp:a.group&quot;</span>
<a href="#l55.5"></a><span id="l55.5"> ];</span>
<a href="#l55.6"></a><span id="l55.6"> </span>
<a href="#l55.7"></a><span id="l55.7"> function run_test() {</span>
<a href="#l55.8"></a><span id="l55.8">   // We're not running the server, just setting it up</span>
<a href="#l55.9"></a><span id="l55.9">   localserver = setupLocalServer(119);</span>
<a href="#l55.10"></a><span id="l55.10">   let nntpService = Cc[&quot;@mozilla.org/messenger/nntpservice;1&quot;]</span>
<a href="#l55.11"></a><span id="l55.11">                       .getService(Components.interfaces.nsIProtocolHandler);</span>
<a href="#l55.12"></a><span id="l55.12" class="difflineminus">-  for each (let test in tests) {</span>
<a href="#l55.13"></a><span id="l55.13" class="difflineplus">+  for (let test of tests) {</span>
<a href="#l55.14"></a><span id="l55.14">     dump(&quot;Checking URL &quot; + test.uri + &quot;\n&quot;);</span>
<a href="#l55.15"></a><span id="l55.15">     let url = nntpService.newURI(test.uri, null, null);</span>
<a href="#l55.16"></a><span id="l55.16">     url.QueryInterface(Ci.nsIMsgMailNewsUrl);</span>
<a href="#l55.17"></a><span id="l55.17">     url.QueryInterface(Ci.nsINntpUrl);</span>
<a href="#l55.18"></a><span id="l55.18">     for (let prop in test) {</span>
<a href="#l55.19"></a><span id="l55.19">       if (prop == &quot;uri&quot;)</span>
<a href="#l55.20"></a><span id="l55.20">         continue;</span>
<a href="#l55.21"></a><span id="l55.21">       do_check_eq(url[prop], test[prop]);</span>
<a href="#l55.22"></a><span id="l55.22">     }</span>
<a href="#l55.23"></a><span id="l55.23">   }</span>
<a href="#l55.24"></a><span id="l55.24"> </span>
<a href="#l55.25"></a><span id="l55.25" class="difflineminus">-  for each (let fail in invalid_uris) {</span>
<a href="#l55.26"></a><span id="l55.26" class="difflineplus">+  for (let fail of invalid_uris) {</span>
<a href="#l55.27"></a><span id="l55.27">     try {</span>
<a href="#l55.28"></a><span id="l55.28">       dump(&quot;Checking URL &quot; + fail + &quot; for failure\n&quot;);</span>
<a href="#l55.29"></a><span id="l55.29">       nntpService.newURI(fail, null, null);</span>
<a href="#l55.30"></a><span id="l55.30">       do_check_true(false);</span>
<a href="#l55.31"></a><span id="l55.31">     } catch (e) {</span>
<a href="#l55.32"></a><span id="l55.32">       do_check_eq(e.result, Components.results.NS_ERROR_MALFORMED_URI);</span>
<a href="#l55.33"></a><span id="l55.33">     }</span>
<a href="#l55.34"></a><span id="l55.34">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l56.1"></a><span id="l56.1" class="difflineminus">--- a/mailnews/test/fakeserver/imapd.js</span>
<a href="#l56.2"></a><span id="l56.2" class="difflineplus">+++ b/mailnews/test/fakeserver/imapd.js</span>
<a href="#l56.3"></a><span id="l56.3" class="difflineat">@@ -86,23 +86,23 @@ function imapDaemon(flags, syncFunc) {</span>
<a href="#l56.4"></a><span id="l56.4">   // This can be used to simulate timeouts on large copies</span>
<a href="#l56.5"></a><span id="l56.5">   this.copySleep = 0;</span>
<a href="#l56.6"></a><span id="l56.6"> }</span>
<a href="#l56.7"></a><span id="l56.7"> imapDaemon.prototype = {</span>
<a href="#l56.8"></a><span id="l56.8">   synchronize : function (mailbox, update) {</span>
<a href="#l56.9"></a><span id="l56.9">     if (this.syncFunc)</span>
<a href="#l56.10"></a><span id="l56.10">       this.syncFunc.call(null, this);</span>
<a href="#l56.11"></a><span id="l56.11">     if (update) {</span>
<a href="#l56.12"></a><span id="l56.12" class="difflineminus">-      for each (var message in mailbox._messages) {</span>
<a href="#l56.13"></a><span id="l56.13" class="difflineplus">+      for (var message of mailbox._messages) {</span>
<a href="#l56.14"></a><span id="l56.14">         message.recent = false;</span>
<a href="#l56.15"></a><span id="l56.15">       }</span>
<a href="#l56.16"></a><span id="l56.16">     }</span>
<a href="#l56.17"></a><span id="l56.17">   },</span>
<a href="#l56.18"></a><span id="l56.18">   getNamespace : function (name) {</span>
<a href="#l56.19"></a><span id="l56.19" class="difflineminus">-    for each (var namespace in this.namespaces) {</span>
<a href="#l56.20"></a><span id="l56.20" class="difflineplus">+    for (var namespace of this.namespaces) {</span>
<a href="#l56.21"></a><span id="l56.21">       if (name.indexOf(namespace.name) == 0 &amp;&amp;</span>
<a href="#l56.22"></a><span id="l56.22">           name[namespace.name.length] == namespace.delimiter)</span>
<a href="#l56.23"></a><span id="l56.23">         return namespace;</span>
<a href="#l56.24"></a><span id="l56.24">     }</span>
<a href="#l56.25"></a><span id="l56.25">     return this.root;</span>
<a href="#l56.26"></a><span id="l56.26">   },</span>
<a href="#l56.27"></a><span id="l56.27">   createNamespace : function (name, type) {</span>
<a href="#l56.28"></a><span id="l56.28">     var newbox = this.createMailbox(name, {type : type});</span>
<a href="#l56.29"></a><span id="l56.29" class="difflineat">@@ -114,41 +114,41 @@ imapDaemon.prototype = {</span>
<a href="#l56.30"></a><span id="l56.30">     // INBOX is case-insensitive, no matter what</span>
<a href="#l56.31"></a><span id="l56.31">     if (name.toUpperCase().startsWith(&quot;INBOX&quot;))</span>
<a href="#l56.32"></a><span id="l56.32">       name = &quot;INBOX&quot; + name.substr(5);</span>
<a href="#l56.33"></a><span id="l56.33">     // We want to find a child who has the same name, but we don't quite know</span>
<a href="#l56.34"></a><span id="l56.34">     // what the delimiter is. The convention is that different namespaces use a</span>
<a href="#l56.35"></a><span id="l56.35">     // name starting with '#', so that's how we'll work it out.</span>
<a href="#l56.36"></a><span id="l56.36">     if (name.startsWith('#')) {</span>
<a href="#l56.37"></a><span id="l56.37">       var root = null;</span>
<a href="#l56.38"></a><span id="l56.38" class="difflineminus">-      for each (var mailbox in this.root._children) {</span>
<a href="#l56.39"></a><span id="l56.39" class="difflineplus">+      for (var mailbox of this.root._children) {</span>
<a href="#l56.40"></a><span id="l56.40">         if (mailbox.name.indexOf(name) == 0 &amp;&amp;</span>
<a href="#l56.41"></a><span id="l56.41">             name[mailbox.name.length] == mailbox.delimiter) {</span>
<a href="#l56.42"></a><span id="l56.42">           root = mailbox;</span>
<a href="#l56.43"></a><span id="l56.43">           break;</span>
<a href="#l56.44"></a><span id="l56.44">         }</span>
<a href="#l56.45"></a><span id="l56.45">       }</span>
<a href="#l56.46"></a><span id="l56.46">       if (!mailbox)</span>
<a href="#l56.47"></a><span id="l56.47">         return null;</span>
<a href="#l56.48"></a><span id="l56.48"> </span>
<a href="#l56.49"></a><span id="l56.49">       // Now we continue like normal</span>
<a href="#l56.50"></a><span id="l56.50">       var names = name.split(mailbox.delimiter);</span>
<a href="#l56.51"></a><span id="l56.51">       names.splice(0, 1);</span>
<a href="#l56.52"></a><span id="l56.52" class="difflineminus">-      for each (var part in names) {</span>
<a href="#l56.53"></a><span id="l56.53" class="difflineplus">+      for (var part of names) {</span>
<a href="#l56.54"></a><span id="l56.54">         mailbox = mailbox.getChild(part);</span>
<a href="#l56.55"></a><span id="l56.55">         if (!mailbox || mailbox.nonExistent)</span>
<a href="#l56.56"></a><span id="l56.56">           return null;</span>
<a href="#l56.57"></a><span id="l56.57">       }</span>
<a href="#l56.58"></a><span id="l56.58">       return mailbox;</span>
<a href="#l56.59"></a><span id="l56.59">     } else {</span>
<a href="#l56.60"></a><span id="l56.60">       // This is easy, just split it up using the inbox's delimiter</span>
<a href="#l56.61"></a><span id="l56.61">       var names = name.split(this.inbox.delimiter);</span>
<a href="#l56.62"></a><span id="l56.62">       var mailbox = this.root;</span>
<a href="#l56.63"></a><span id="l56.63"> </span>
<a href="#l56.64"></a><span id="l56.64" class="difflineminus">-      for each (var part in names) {</span>
<a href="#l56.65"></a><span id="l56.65" class="difflineplus">+      for (var part of names) {</span>
<a href="#l56.66"></a><span id="l56.66">         mailbox = mailbox.getChild(part);</span>
<a href="#l56.67"></a><span id="l56.67">         if (!mailbox || mailbox.nonExistent)</span>
<a href="#l56.68"></a><span id="l56.68">           return null;</span>
<a href="#l56.69"></a><span id="l56.69">       }</span>
<a href="#l56.70"></a><span id="l56.70">       return mailbox;</span>
<a href="#l56.71"></a><span id="l56.71">     }</span>
<a href="#l56.72"></a><span id="l56.72">   },</span>
<a href="#l56.73"></a><span id="l56.73">   createMailbox : function (name, oldBox) {</span>
<a href="#l56.74"></a><span id="l56.74" class="difflineat">@@ -156,17 +156,17 @@ imapDaemon.prototype = {</span>
<a href="#l56.75"></a><span id="l56.75">     if (namespace.name != &quot;&quot;)</span>
<a href="#l56.76"></a><span id="l56.76">       name = name.substring(namespace.name.length+1);</span>
<a href="#l56.77"></a><span id="l56.77">     var prefixes = name.split(namespace.delimiter);</span>
<a href="#l56.78"></a><span id="l56.78">     if (prefixes[prefixes.length-1] == '')</span>
<a href="#l56.79"></a><span id="l56.79">       var subName = prefixes.splice(prefixes.length - 2, 2)[0];</span>
<a href="#l56.80"></a><span id="l56.80">     else</span>
<a href="#l56.81"></a><span id="l56.81">       var subName = prefixes.splice(prefixes.length - 1, 1)[0];</span>
<a href="#l56.82"></a><span id="l56.82">     var box = namespace;</span>
<a href="#l56.83"></a><span id="l56.83" class="difflineminus">-    for each (var component in prefixes) {</span>
<a href="#l56.84"></a><span id="l56.84" class="difflineplus">+    for (var component of prefixes) {</span>
<a href="#l56.85"></a><span id="l56.85">       box = box.getChild(component);</span>
<a href="#l56.86"></a><span id="l56.86">       // Yes, we won't autocreate intermediary boxes</span>
<a href="#l56.87"></a><span id="l56.87">       if (box == null || box.flags.indexOf('\\NoInferiors') != -1)</span>
<a href="#l56.88"></a><span id="l56.88">         return false;</span>
<a href="#l56.89"></a><span id="l56.89">     }</span>
<a href="#l56.90"></a><span id="l56.90">     // If this is an imapMailbox...</span>
<a href="#l56.91"></a><span id="l56.91">     if (oldBox &amp;&amp; oldBox._children) {</span>
<a href="#l56.92"></a><span id="l56.92">       // Only delete now so we don't screw ourselves up if creation fails</span>
<a href="#l56.93"></a><span id="l56.93" class="difflineat">@@ -250,29 +250,29 @@ imapMailbox.prototype = {</span>
<a href="#l56.94"></a><span id="l56.94">   setDefault : function(prop, def) {</span>
<a href="#l56.95"></a><span id="l56.95">     this[prop] = prop in this ? this[prop] : def;</span>
<a href="#l56.96"></a><span id="l56.96">   },</span>
<a href="#l56.97"></a><span id="l56.97">   addMailbox : function (mailbox) {</span>
<a href="#l56.98"></a><span id="l56.98">     this._children.push(mailbox);</span>
<a href="#l56.99"></a><span id="l56.99">   },</span>
<a href="#l56.100"></a><span id="l56.100">   getChild : function (name) {</span>
<a href="#l56.101"></a><span id="l56.101">     var equal;</span>
<a href="#l56.102"></a><span id="l56.102" class="difflineminus">-    for each (var mailbox in this._children) {</span>
<a href="#l56.103"></a><span id="l56.103" class="difflineplus">+    for (var mailbox of this._children) {</span>
<a href="#l56.104"></a><span id="l56.104">       if (name == mailbox.name)</span>
<a href="#l56.105"></a><span id="l56.105">         return mailbox;</span>
<a href="#l56.106"></a><span id="l56.106">     }</span>
<a href="#l56.107"></a><span id="l56.107">     return null;</span>
<a href="#l56.108"></a><span id="l56.108">   },</span>
<a href="#l56.109"></a><span id="l56.109">   matchKids : function (pattern) {</span>
<a href="#l56.110"></a><span id="l56.110">     if (pattern == &quot;&quot;)</span>
<a href="#l56.111"></a><span id="l56.111">       return this._parent ? this._parent.matchKids(&quot;&quot;) : [this];</span>
<a href="#l56.112"></a><span id="l56.112"> </span>
<a href="#l56.113"></a><span id="l56.113">     var portions = pattern.split(this.delimiter);</span>
<a href="#l56.114"></a><span id="l56.114">     var matching = [this];</span>
<a href="#l56.115"></a><span id="l56.115" class="difflineminus">-    for each (var folder in portions) {</span>
<a href="#l56.116"></a><span id="l56.116" class="difflineplus">+    for (var folder of portions) {</span>
<a href="#l56.117"></a><span id="l56.117">       if (folder.length == 0)</span>
<a href="#l56.118"></a><span id="l56.118">         continue;</span>
<a href="#l56.119"></a><span id="l56.119"> </span>
<a href="#l56.120"></a><span id="l56.120">       let generator = folder.indexOf(&quot;*&quot;) &gt;= 0 ? &quot;allChildren&quot; : &quot;_children&quot;;</span>
<a href="#l56.121"></a><span id="l56.121">       let possible = matching.reduce(function (arr, elem) {</span>
<a href="#l56.122"></a><span id="l56.122">         return arr.concat(elem[generator]);</span>
<a href="#l56.123"></a><span id="l56.123">       }, []);</span>
<a href="#l56.124"></a><span id="l56.124"> </span>
<a href="#l56.125"></a><span id="l56.125" class="difflineat">@@ -281,17 +281,17 @@ imapMailbox.prototype = {</span>
<a href="#l56.126"></a><span id="l56.126">         continue;</span>
<a href="#l56.127"></a><span id="l56.127">       }</span>
<a href="#l56.128"></a><span id="l56.128"> </span>
<a href="#l56.129"></a><span id="l56.129">       let parts = folder.split(/[*%]/).filter(function (str) {</span>
<a href="#l56.130"></a><span id="l56.130">           return str.length &gt; 0;</span>
<a href="#l56.131"></a><span id="l56.131">       });</span>
<a href="#l56.132"></a><span id="l56.132">       matching = possible.filter(function (mailbox) {</span>
<a href="#l56.133"></a><span id="l56.133">         let index = 0, name = mailbox.fullName;</span>
<a href="#l56.134"></a><span id="l56.134" class="difflineminus">-        for each (var part in parts) {</span>
<a href="#l56.135"></a><span id="l56.135" class="difflineplus">+        for (var part of parts) {</span>
<a href="#l56.136"></a><span id="l56.136">           index = name.indexOf(part, index);</span>
<a href="#l56.137"></a><span id="l56.137">           if (index == -1)</span>
<a href="#l56.138"></a><span id="l56.138">             return false;</span>
<a href="#l56.139"></a><span id="l56.139">         }</span>
<a href="#l56.140"></a><span id="l56.140">         return true;</span>
<a href="#l56.141"></a><span id="l56.141">       });</span>
<a href="#l56.142"></a><span id="l56.142">     }</span>
<a href="#l56.143"></a><span id="l56.143">     return matching;</span>
<a href="#l56.144"></a><span id="l56.144" class="difflineat">@@ -326,17 +326,17 @@ imapMailbox.prototype = {</span>
<a href="#l56.145"></a><span id="l56.145">       this._updates.push(&quot;EXISTS&quot;);</span>
<a href="#l56.146"></a><span id="l56.146">     if (&quot;__highestuid&quot; in this &amp;&amp; message.uid &gt; this.__highestuid)</span>
<a href="#l56.147"></a><span id="l56.147">       this.__highestuid = message.uid;</span>
<a href="#l56.148"></a><span id="l56.148">   },</span>
<a href="#l56.149"></a><span id="l56.149">   get _highestuid () {</span>
<a href="#l56.150"></a><span id="l56.150">     if (&quot;__highestuid&quot; in this)</span>
<a href="#l56.151"></a><span id="l56.151">       return this.__highestuid;</span>
<a href="#l56.152"></a><span id="l56.152">     var highest = 0;</span>
<a href="#l56.153"></a><span id="l56.153" class="difflineminus">-    for each (var message in this._messages)</span>
<a href="#l56.154"></a><span id="l56.154" class="difflineplus">+    for (var message of this._messages)</span>
<a href="#l56.155"></a><span id="l56.155">       if (message.uid &gt; highest)</span>
<a href="#l56.156"></a><span id="l56.156">         highest = message.uid;</span>
<a href="#l56.157"></a><span id="l56.157">     this.__highestuid = highest;</span>
<a href="#l56.158"></a><span id="l56.158">     return highest;</span>
<a href="#l56.159"></a><span id="l56.159">   },</span>
<a href="#l56.160"></a><span id="l56.160">   expunge : function () {</span>
<a href="#l56.161"></a><span id="l56.161">     var response = &quot;&quot;;</span>
<a href="#l56.162"></a><span id="l56.162">     for (var i = 0; i &lt; this._messages.length; i++) {</span>
<a href="#l56.163"></a><span id="l56.163" class="difflineat">@@ -833,30 +833,30 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.164"></a><span id="l56.164">         var response = e;</span>
<a href="#l56.165"></a><span id="l56.165">       }</span>
<a href="#l56.166"></a><span id="l56.166">     } else {</span>
<a href="#l56.167"></a><span id="l56.167">       var response = &quot;BAD &quot; + command  + &quot; not implemented&quot;;</span>
<a href="#l56.168"></a><span id="l56.168">     }</span>
<a href="#l56.169"></a><span id="l56.169"> </span>
<a href="#l56.170"></a><span id="l56.170">     // Add status updates</span>
<a href="#l56.171"></a><span id="l56.171">     if (this._selectedMailbox) {</span>
<a href="#l56.172"></a><span id="l56.172" class="difflineminus">-      for each (var update in this._selectedMailbox._updates) {</span>
<a href="#l56.173"></a><span id="l56.173" class="difflineplus">+      for (var update of this._selectedMailbox._updates) {</span>
<a href="#l56.174"></a><span id="l56.174">         var line;</span>
<a href="#l56.175"></a><span id="l56.175">         switch (update) {</span>
<a href="#l56.176"></a><span id="l56.176">         case &quot;EXISTS&quot;:</span>
<a href="#l56.177"></a><span id="l56.177">           line = &quot;* &quot; + this._selectedMailbox._messages.length + &quot; EXISTS&quot;;</span>
<a href="#l56.178"></a><span id="l56.178">           break;</span>
<a href="#l56.179"></a><span id="l56.179">         }</span>
<a href="#l56.180"></a><span id="l56.180">         response = line + '\0' + response;</span>
<a href="#l56.181"></a><span id="l56.181">       }</span>
<a href="#l56.182"></a><span id="l56.182">     }</span>
<a href="#l56.183"></a><span id="l56.183"> </span>
<a href="#l56.184"></a><span id="l56.184">     var lines = response.split(/\u0000/);</span>
<a href="#l56.185"></a><span id="l56.185">     response = &quot;&quot;;</span>
<a href="#l56.186"></a><span id="l56.186" class="difflineminus">-    for each (var line in lines) {</span>
<a href="#l56.187"></a><span id="l56.187" class="difflineplus">+    for (var line of lines) {</span>
<a href="#l56.188"></a><span id="l56.188">       if (!line.startsWith('+') &amp;&amp; !line.startsWith('*'))</span>
<a href="#l56.189"></a><span id="l56.189">         response += this._tag + &quot; &quot;;</span>
<a href="#l56.190"></a><span id="l56.190">       response += line + &quot;\r\n&quot;;</span>
<a href="#l56.191"></a><span id="l56.191">     }</span>
<a href="#l56.192"></a><span id="l56.192">     return response;</span>
<a href="#l56.193"></a><span id="l56.193">   },</span>
<a href="#l56.194"></a><span id="l56.194">   _treatArgs : function (args, command) {</span>
<a href="#l56.195"></a><span id="l56.195">     var format = this._argFormat[command];</span>
<a href="#l56.196"></a><span id="l56.196" class="difflineat">@@ -1062,32 +1062,32 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.197"></a><span id="l56.197"> </span>
<a href="#l56.198"></a><span id="l56.198">     let listFunctionName = &quot;_LIST&quot;;</span>
<a href="#l56.199"></a><span id="l56.199">     // check for optional list selection options argument used by LIST-EXTENDED</span>
<a href="#l56.200"></a><span id="l56.200">     // and other related RFCs</span>
<a href="#l56.201"></a><span id="l56.201">     if (args.length == 3 || (args.length &gt; 3 &amp;&amp; args[3] == &quot;RETURN&quot;)) {</span>
<a href="#l56.202"></a><span id="l56.202">       let selectionOptions = args.shift();</span>
<a href="#l56.203"></a><span id="l56.203">       selectionOptions = selectionOptions.toString().split(' ');</span>
<a href="#l56.204"></a><span id="l56.204">       selectionOptions.sort();</span>
<a href="#l56.205"></a><span id="l56.205" class="difflineminus">-      for each (let option in selectionOptions) {</span>
<a href="#l56.206"></a><span id="l56.206" class="difflineplus">+      for (let option of selectionOptions) {</span>
<a href="#l56.207"></a><span id="l56.207">         listFunctionName += &quot;_&quot; + option.replace(/-/g, &quot;_&quot;);</span>
<a href="#l56.208"></a><span id="l56.208">       }</span>
<a href="#l56.209"></a><span id="l56.209">     }</span>
<a href="#l56.210"></a><span id="l56.210">     // check for optional list return options argument used by LIST-EXTENDED</span>
<a href="#l56.211"></a><span id="l56.211">     // and other related RFCs</span>
<a href="#l56.212"></a><span id="l56.212">     if ((args.length &gt; 2 &amp;&amp; args[2] == &quot;RETURN&quot;) ||</span>
<a href="#l56.213"></a><span id="l56.213">         this.kCapabilities.indexOf(&quot;CHILDREN&quot;) &gt;= 0) {</span>
<a href="#l56.214"></a><span id="l56.214">       listFunctionName += &quot;_RETURN&quot;;</span>
<a href="#l56.215"></a><span id="l56.215">       let returnOptions = args[3] ? args[3].toString().split(' ') : [];</span>
<a href="#l56.216"></a><span id="l56.216">       if ((this.kCapabilities.indexOf(&quot;CHILDREN&quot;) &gt;= 0) &amp;&amp;</span>
<a href="#l56.217"></a><span id="l56.217">           (returnOptions.indexOf(&quot;CHILDREN&quot;) == -1)) {</span>
<a href="#l56.218"></a><span id="l56.218">         returnOptions.push(&quot;CHILDREN&quot;);</span>
<a href="#l56.219"></a><span id="l56.219">       }</span>
<a href="#l56.220"></a><span id="l56.220">       returnOptions.sort();</span>
<a href="#l56.221"></a><span id="l56.221" class="difflineminus">-      for each (let option in returnOptions) {</span>
<a href="#l56.222"></a><span id="l56.222" class="difflineplus">+      for (let option of returnOptions) {</span>
<a href="#l56.223"></a><span id="l56.223">         listFunctionName += &quot;_&quot; + option.replace(/-/g, &quot;_&quot;);</span>
<a href="#l56.224"></a><span id="l56.224">       }</span>
<a href="#l56.225"></a><span id="l56.225">     }</span>
<a href="#l56.226"></a><span id="l56.226">     if (!this[listFunctionName])</span>
<a href="#l56.227"></a><span id="l56.227">       return 'BAD unknown LIST request options';</span>
<a href="#l56.228"></a><span id="l56.228"> </span>
<a href="#l56.229"></a><span id="l56.229">     let base = this._daemon.getMailbox(args[0]);</span>
<a href="#l56.230"></a><span id="l56.230">     if (!base)</span>
<a href="#l56.231"></a><span id="l56.231" class="difflineat">@@ -1096,19 +1096,19 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.232"></a><span id="l56.232">     // check for multiple mailbox patterns used by LIST-EXTENDED</span>
<a href="#l56.233"></a><span id="l56.233">     // and other related RFCs</span>
<a href="#l56.234"></a><span id="l56.234">     if (args[1].startsWith(&quot;(&quot;)) {</span>
<a href="#l56.235"></a><span id="l56.235">       requestedBoxes = parseCommand(args[1])[0];</span>
<a href="#l56.236"></a><span id="l56.236">     } else {</span>
<a href="#l56.237"></a><span id="l56.237">       requestedBoxes = [ args[1] ];</span>
<a href="#l56.238"></a><span id="l56.238">     }</span>
<a href="#l56.239"></a><span id="l56.239">     let response = &quot;&quot;;</span>
<a href="#l56.240"></a><span id="l56.240" class="difflineminus">-    for each (let requestedBox in requestedBoxes) {</span>
<a href="#l56.241"></a><span id="l56.241" class="difflineplus">+    for (let requestedBox of requestedBoxes) {</span>
<a href="#l56.242"></a><span id="l56.242">       let people = base.matchKids(requestedBox);</span>
<a href="#l56.243"></a><span id="l56.243" class="difflineminus">-      for each (let box in people) {</span>
<a href="#l56.244"></a><span id="l56.244" class="difflineplus">+      for (let box of people) {</span>
<a href="#l56.245"></a><span id="l56.245">         response += this[listFunctionName](box);</span>
<a href="#l56.246"></a><span id="l56.246">       }</span>
<a href="#l56.247"></a><span id="l56.247">     }</span>
<a href="#l56.248"></a><span id="l56.248">     return response + &quot;OK LIST completed&quot;;</span>
<a href="#l56.249"></a><span id="l56.249">   },</span>
<a href="#l56.250"></a><span id="l56.250">   // _LIST is the standard LIST command response</span>
<a href="#l56.251"></a><span id="l56.251">   _LIST : function (aBox) {</span>
<a href="#l56.252"></a><span id="l56.252">     if (aBox.nonExistent) {</span>
<a href="#l56.253"></a><span id="l56.253" class="difflineat">@@ -1118,32 +1118,32 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.254"></a><span id="l56.254">            '&quot; &quot;' + aBox.displayName + '&quot;\0';</span>
<a href="#l56.255"></a><span id="l56.255">   },</span>
<a href="#l56.256"></a><span id="l56.256">   LSUB : function (args) {</span>
<a href="#l56.257"></a><span id="l56.257">     var base = this._daemon.getMailbox(args[0]);</span>
<a href="#l56.258"></a><span id="l56.258">     if (!base)</span>
<a href="#l56.259"></a><span id="l56.259">       return &quot;NO no such mailbox&quot;;</span>
<a href="#l56.260"></a><span id="l56.260">     var people = base.matchKids(args[1]);</span>
<a href="#l56.261"></a><span id="l56.261">     var response = &quot;&quot;;</span>
<a href="#l56.262"></a><span id="l56.262" class="difflineminus">-    for each (var box in people) {</span>
<a href="#l56.263"></a><span id="l56.263" class="difflineplus">+    for (var box of people) {</span>
<a href="#l56.264"></a><span id="l56.264">       if (box.subscribed)</span>
<a href="#l56.265"></a><span id="l56.265">         response += '* LSUB () &quot;' + box.delimiter +</span>
<a href="#l56.266"></a><span id="l56.266">                     '&quot; &quot;' + box.displayName + '&quot;\0';</span>
<a href="#l56.267"></a><span id="l56.267">     }</span>
<a href="#l56.268"></a><span id="l56.268">     return response + &quot;OK LSUB completed&quot;;</span>
<a href="#l56.269"></a><span id="l56.269">   },</span>
<a href="#l56.270"></a><span id="l56.270">   STATUS : function (args) {</span>
<a href="#l56.271"></a><span id="l56.271">     var box = this._daemon.getMailbox(args[0]);</span>
<a href="#l56.272"></a><span id="l56.272">     if (!box)</span>
<a href="#l56.273"></a><span id="l56.273">       return &quot;NO no such mailbox exists&quot;;</span>
<a href="#l56.274"></a><span id="l56.274">     for (let i = 0; i &lt; box.flags.length; i++)</span>
<a href="#l56.275"></a><span id="l56.275">       if (box.flags[i] == &quot;\\Noselect&quot;)</span>
<a href="#l56.276"></a><span id="l56.276">         return &quot;NO STATUS not allowed on Noselect folder&quot;;</span>
<a href="#l56.277"></a><span id="l56.277">     var parts = [];</span>
<a href="#l56.278"></a><span id="l56.278" class="difflineminus">-    for each (var status in args[1]) {</span>
<a href="#l56.279"></a><span id="l56.279" class="difflineplus">+    for (var status of args[1]) {</span>
<a href="#l56.280"></a><span id="l56.280">       var line = status + &quot; &quot;;</span>
<a href="#l56.281"></a><span id="l56.281">       switch (status) {</span>
<a href="#l56.282"></a><span id="l56.282">       case &quot;MESSAGES&quot;:</span>
<a href="#l56.283"></a><span id="l56.283">         line += box._messages.length;</span>
<a href="#l56.284"></a><span id="l56.284">         break;</span>
<a href="#l56.285"></a><span id="l56.285">       case &quot;RECENT&quot;:</span>
<a href="#l56.286"></a><span id="l56.286">         line += box._messages.reduce(function (count, message) {</span>
<a href="#l56.287"></a><span id="l56.287">           return count + (message.recent ? 1 : 0);</span>
<a href="#l56.288"></a><span id="l56.288" class="difflineat">@@ -1240,17 +1240,17 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.289"></a><span id="l56.289">       else</span>
<a href="#l56.290"></a><span id="l56.290">         args[1] = [args[1]];</span>
<a href="#l56.291"></a><span id="l56.291">     }</span>
<a href="#l56.292"></a><span id="l56.292">     if (uid &amp;&amp; args[1].indexOf(&quot;UID&quot;) == -1)</span>
<a href="#l56.293"></a><span id="l56.293">       args[1].push(&quot;UID&quot;);</span>
<a href="#l56.294"></a><span id="l56.294"> </span>
<a href="#l56.295"></a><span id="l56.295">     // Step 2.1: Preprocess the item fetch stack</span>
<a href="#l56.296"></a><span id="l56.296">     var items = [], prefix = undefined;</span>
<a href="#l56.297"></a><span id="l56.297" class="difflineminus">-    for each (var item in args[1]) {</span>
<a href="#l56.298"></a><span id="l56.298" class="difflineplus">+    for (var item of args[1]) {</span>
<a href="#l56.299"></a><span id="l56.299">       if (item.indexOf('[') &gt; 0 &amp;&amp; item.indexOf(']') == -1) {</span>
<a href="#l56.300"></a><span id="l56.300">         // We want to append everything into an item until we find a ']'</span>
<a href="#l56.301"></a><span id="l56.301">         prefix = item + ' ';</span>
<a href="#l56.302"></a><span id="l56.302">         continue;</span>
<a href="#l56.303"></a><span id="l56.303">       }</span>
<a href="#l56.304"></a><span id="l56.304">       if (prefix !== undefined) {</span>
<a href="#l56.305"></a><span id="l56.305">         if (typeof item != &quot;string&quot; || item.indexOf(']') == -1) {</span>
<a href="#l56.306"></a><span id="l56.306">           prefix += (typeof item == &quot;string&quot; ? item : '(' + item.join(' ') + ')')</span>
<a href="#l56.307"></a><span id="l56.307" class="difflineat">@@ -1267,17 +1267,17 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.308"></a><span id="l56.308">         items.push(item);</span>
<a href="#l56.309"></a><span id="l56.309">     }</span>
<a href="#l56.310"></a><span id="l56.310"> </span>
<a href="#l56.311"></a><span id="l56.311">     // Step 3: Fetch time!</span>
<a href="#l56.312"></a><span id="l56.312">     var response = &quot;&quot;;</span>
<a href="#l56.313"></a><span id="l56.313">     for (var i = 0; i &lt; messages.length; i++) {</span>
<a href="#l56.314"></a><span id="l56.314">       response += &quot;* &quot; + ids[i] + &quot; FETCH (&quot;;</span>
<a href="#l56.315"></a><span id="l56.315">       var parts = [];</span>
<a href="#l56.316"></a><span id="l56.316" class="difflineminus">-      for each (var item in items) {</span>
<a href="#l56.317"></a><span id="l56.317" class="difflineplus">+      for (var item of items) {</span>
<a href="#l56.318"></a><span id="l56.318"> </span>
<a href="#l56.319"></a><span id="l56.319">         // Brief explanation: an item like BODY[]&lt;&gt; can't be hardcoded easily,</span>
<a href="#l56.320"></a><span id="l56.320">         // so we go for the initial alphanumeric substring, passing in the</span>
<a href="#l56.321"></a><span id="l56.321">         // actual string as an optional second part.</span>
<a href="#l56.322"></a><span id="l56.322">         var front = item.split(/[^A-Z0-9-]/, 1)[0];</span>
<a href="#l56.323"></a><span id="l56.323">         var functionName = &quot;_FETCH_&quot; + front.replace(/-/g, &quot;_&quot;);</span>
<a href="#l56.324"></a><span id="l56.324"> </span>
<a href="#l56.325"></a><span id="l56.325">         if (!(functionName in this))</span>
<a href="#l56.326"></a><span id="l56.326" class="difflineat">@@ -1308,21 +1308,21 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.327"></a><span id="l56.327">     var response = &quot;&quot;;</span>
<a href="#l56.328"></a><span id="l56.328">     for (var i = 0; i &lt; messages.length; i++) {</span>
<a href="#l56.329"></a><span id="l56.329">       var message = messages[i];</span>
<a href="#l56.330"></a><span id="l56.330">       switch (args[1]) {</span>
<a href="#l56.331"></a><span id="l56.331">       case &quot;FLAGS&quot;:</span>
<a href="#l56.332"></a><span id="l56.332">         message.flags = args[2];</span>
<a href="#l56.333"></a><span id="l56.333">         break;</span>
<a href="#l56.334"></a><span id="l56.334">       case &quot;+FLAGS&quot;:</span>
<a href="#l56.335"></a><span id="l56.335" class="difflineminus">-        for each (var flag in args[2])</span>
<a href="#l56.336"></a><span id="l56.336" class="difflineplus">+        for (var flag of args[2])</span>
<a href="#l56.337"></a><span id="l56.337">           message.setFlag(flag);</span>
<a href="#l56.338"></a><span id="l56.338">         break;</span>
<a href="#l56.339"></a><span id="l56.339">       case &quot;-FLAGS&quot;:</span>
<a href="#l56.340"></a><span id="l56.340" class="difflineminus">-        for each (var flag in args[2]) {</span>
<a href="#l56.341"></a><span id="l56.341" class="difflineplus">+        for (var flag of args[2]) {</span>
<a href="#l56.342"></a><span id="l56.342">           var index;</span>
<a href="#l56.343"></a><span id="l56.343">           if ((index = message.flags.indexOf(flag)) != -1)</span>
<a href="#l56.344"></a><span id="l56.344">             message.flags.splice(index, 1);</span>
<a href="#l56.345"></a><span id="l56.345">         }</span>
<a href="#l56.346"></a><span id="l56.346">         break;</span>
<a href="#l56.347"></a><span id="l56.347">       default:</span>
<a href="#l56.348"></a><span id="l56.348">         return &quot;BAD change what now?&quot;;</span>
<a href="#l56.349"></a><span id="l56.349">       }</span>
<a href="#l56.350"></a><span id="l56.350" class="difflineat">@@ -1336,17 +1336,17 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.351"></a><span id="l56.351">   },</span>
<a href="#l56.352"></a><span id="l56.352">   COPY : function (args, uid) {</span>
<a href="#l56.353"></a><span id="l56.353">     var messages = this._parseSequenceSet(args[0], uid);</span>
<a href="#l56.354"></a><span id="l56.354"> </span>
<a href="#l56.355"></a><span id="l56.355">     var dest = this._daemon.getMailbox(args[1]);</span>
<a href="#l56.356"></a><span id="l56.356">     if (!dest)</span>
<a href="#l56.357"></a><span id="l56.357">       return &quot;NO [TRYCREATE] what mailbox?&quot;;</span>
<a href="#l56.358"></a><span id="l56.358"> </span>
<a href="#l56.359"></a><span id="l56.359" class="difflineminus">-    for each (var message in messages) {</span>
<a href="#l56.360"></a><span id="l56.360" class="difflineplus">+    for (var message of messages) {</span>
<a href="#l56.361"></a><span id="l56.361">       let newMessage = new imapMessage(message._URI, dest.uidnext++,</span>
<a href="#l56.362"></a><span id="l56.362">                                        message.flags);</span>
<a href="#l56.363"></a><span id="l56.363">       newMessage.recent = false;</span>
<a href="#l56.364"></a><span id="l56.364">       dest.addMessage(newMessage);</span>
<a href="#l56.365"></a><span id="l56.365">     }</span>
<a href="#l56.366"></a><span id="l56.366">     if (this._daemon.copySleep &gt; 0) {</span>
<a href="#l56.367"></a><span id="l56.367">       // spin rudely for copyTimeout milliseconds.</span>
<a href="#l56.368"></a><span id="l56.368">       let now = new Date();</span>
<a href="#l56.369"></a><span id="l56.369" class="difflineat">@@ -1425,17 +1425,17 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.370"></a><span id="l56.370">       let num = part.match(re);</span>
<a href="#l56.371"></a><span id="l56.371">       if(!num || (num.length != part.length))</span>
<a href="#l56.372"></a><span id="l56.372">         throw &quot;BAD invalid UID &quot; + part;</span>
<a href="#l56.373"></a><span id="l56.373">       return parseInt(part);</span>
<a href="#l56.374"></a><span id="l56.374">     }</span>
<a href="#l56.375"></a><span id="l56.375"> </span>
<a href="#l56.376"></a><span id="l56.376">     var elements = set.split(/,/);</span>
<a href="#l56.377"></a><span id="l56.377">     set = [];</span>
<a href="#l56.378"></a><span id="l56.378" class="difflineminus">-    for each (var part in elements) {</span>
<a href="#l56.379"></a><span id="l56.379" class="difflineplus">+    for (var part of elements) {</span>
<a href="#l56.380"></a><span id="l56.380">       if (!part.includes(':')) {</span>
<a href="#l56.381"></a><span id="l56.381">         set.push(part2num(part));</span>
<a href="#l56.382"></a><span id="l56.382">       } else {</span>
<a href="#l56.383"></a><span id="l56.383">         var range = part.split(/:/);</span>
<a href="#l56.384"></a><span id="l56.384">         range[0] = part2num(range[0]);</span>
<a href="#l56.385"></a><span id="l56.385">         range[1] = part2num(range[1]);</span>
<a href="#l56.386"></a><span id="l56.386">         if (range[0] &gt; range[1]) {</span>
<a href="#l56.387"></a><span id="l56.387">           let temp = range[1];</span>
<a href="#l56.388"></a><span id="l56.388" class="difflineat">@@ -1458,17 +1458,17 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l56.389"></a><span id="l56.389">       var messages = this._selectedMailbox._messages.filter(function (msg, i) {</span>
<a href="#l56.390"></a><span id="l56.390">         if (set.indexOf(msg.uid) == -1)</span>
<a href="#l56.391"></a><span id="l56.391">           return false;</span>
<a href="#l56.392"></a><span id="l56.392">         ids.push(i + 1);</span>
<a href="#l56.393"></a><span id="l56.393">         return true;</span>
<a href="#l56.394"></a><span id="l56.394">       });</span>
<a href="#l56.395"></a><span id="l56.395">     } else {</span>
<a href="#l56.396"></a><span id="l56.396">       var messages = [];</span>
<a href="#l56.397"></a><span id="l56.397" class="difflineminus">-      for each (var id in set) {</span>
<a href="#l56.398"></a><span id="l56.398" class="difflineplus">+      for (var id of set) {</span>
<a href="#l56.399"></a><span id="l56.399">         if (id - 1 in this._selectedMailbox._messages) {</span>
<a href="#l56.400"></a><span id="l56.400">           ids.push(id);</span>
<a href="#l56.401"></a><span id="l56.401">           messages.push(this._selectedMailbox._messages[id - 1]);</span>
<a href="#l56.402"></a><span id="l56.402">         }</span>
<a href="#l56.403"></a><span id="l56.403">       }</span>
<a href="#l56.404"></a><span id="l56.404">     }</span>
<a href="#l56.405"></a><span id="l56.405">     return messages;</span>
<a href="#l56.406"></a><span id="l56.406">   },</span>
<a href="#l56.407"></a><span id="l56.407" class="difflineat">@@ -1787,17 +1787,17 @@ var IMAP_GMAIL_extension = {</span>
<a href="#l56.408"></a><span id="l56.408"> var IMAP_MOVE_extension = {</span>
<a href="#l56.409"></a><span id="l56.409">   MOVE: function (args, uid) {</span>
<a href="#l56.410"></a><span id="l56.410">     let messages = this._parseSequenceSet(args[0], uid);</span>
<a href="#l56.411"></a><span id="l56.411"> </span>
<a href="#l56.412"></a><span id="l56.412">     let dest = this._daemon.getMailbox(args[1]);</span>
<a href="#l56.413"></a><span id="l56.413">     if (!dest)</span>
<a href="#l56.414"></a><span id="l56.414">       return &quot;NO [TRYCREATE] what mailbox?&quot;;</span>
<a href="#l56.415"></a><span id="l56.415"> </span>
<a href="#l56.416"></a><span id="l56.416" class="difflineminus">-    for each (var message in messages) {</span>
<a href="#l56.417"></a><span id="l56.417" class="difflineplus">+    for (var message of messages) {</span>
<a href="#l56.418"></a><span id="l56.418">       let newMessage = new imapMessage(message._URI, dest.uidnext++,</span>
<a href="#l56.419"></a><span id="l56.419">                                        message.flags);</span>
<a href="#l56.420"></a><span id="l56.420">       newMessage.recent = false;</span>
<a href="#l56.421"></a><span id="l56.421">       dest.addMessage(newMessage);</span>
<a href="#l56.422"></a><span id="l56.422">     }</span>
<a href="#l56.423"></a><span id="l56.423">     let mailbox = this._selectedMailbox;</span>
<a href="#l56.424"></a><span id="l56.424">     let response = &quot;&quot;;</span>
<a href="#l56.425"></a><span id="l56.425">     for (let i = messages.length - 1; i &gt;= 0; i--) {</span>
<a href="#l56.426"></a><span id="l56.426" class="difflineat">@@ -1905,49 +1905,49 @@ var IMAP_CUSTOM_extension = {</span>
<a href="#l56.427"></a><span id="l56.427">   },</span>
<a href="#l56.428"></a><span id="l56.428">   kCapabilities: [&quot;X-CUSTOM1&quot;]</span>
<a href="#l56.429"></a><span id="l56.429"> };</span>
<a href="#l56.430"></a><span id="l56.430"> </span>
<a href="#l56.431"></a><span id="l56.431"> // RFC 2197: ID</span>
<a href="#l56.432"></a><span id="l56.432"> var IMAP_RFC2197_extension = {</span>
<a href="#l56.433"></a><span id="l56.433">   ID : function (args) {</span>
<a href="#l56.434"></a><span id="l56.434">     let clientID = &quot;(&quot;;</span>
<a href="#l56.435"></a><span id="l56.435" class="difflineminus">-    for each (let i in args)</span>
<a href="#l56.436"></a><span id="l56.436" class="difflineplus">+    for (let i of args)</span>
<a href="#l56.437"></a><span id="l56.437">       clientID += &quot;\&quot;&quot; + i + &quot;\&quot;&quot;;</span>
<a href="#l56.438"></a><span id="l56.438"> </span>
<a href="#l56.439"></a><span id="l56.439">     clientID += &quot;)&quot;;</span>
<a href="#l56.440"></a><span id="l56.440">     let clientStrings = clientID.split(&quot;,&quot;);</span>
<a href="#l56.441"></a><span id="l56.441">     clientID = &quot;&quot;;</span>
<a href="#l56.442"></a><span id="l56.442" class="difflineminus">-    for each (let i in clientStrings)</span>
<a href="#l56.443"></a><span id="l56.443" class="difflineplus">+    for (let i of clientStrings)</span>
<a href="#l56.444"></a><span id="l56.444">       clientID += &quot;\&quot;&quot; + i + &quot;\&quot; &quot;</span>
<a href="#l56.445"></a><span id="l56.445">     clientID = clientID.slice(1, clientID.length - 3);</span>
<a href="#l56.446"></a><span id="l56.446">     clientID += &quot;)&quot;;</span>
<a href="#l56.447"></a><span id="l56.447">     this._daemon.clientID = clientID;</span>
<a href="#l56.448"></a><span id="l56.448">     return &quot;* ID &quot; + this._daemon.idResponse + &quot;\0OK Success&quot;;</span>
<a href="#l56.449"></a><span id="l56.449">   },</span>
<a href="#l56.450"></a><span id="l56.450">   kCapabilities: [&quot;ID&quot;],</span>
<a href="#l56.451"></a><span id="l56.451">   _argFormat: { ID: [&quot;(string)&quot;] },</span>
<a href="#l56.452"></a><span id="l56.452">   _enabledCommands : { 1 : [&quot;ID&quot;], 2 : [&quot;ID&quot;] }</span>
<a href="#l56.453"></a><span id="l56.453"> };</span>
<a href="#l56.454"></a><span id="l56.454"> </span>
<a href="#l56.455"></a><span id="l56.455"> // RFC 2342: IMAP4 Namespace (NAMESPACE)</span>
<a href="#l56.456"></a><span id="l56.456"> var IMAP_RFC2342_extension = {</span>
<a href="#l56.457"></a><span id="l56.457">   NAMESPACE : function (args) {</span>
<a href="#l56.458"></a><span id="l56.458">     var namespaces = [[], [], []];</span>
<a href="#l56.459"></a><span id="l56.459" class="difflineminus">-    for each (var namespace in this._daemon.namespaces)</span>
<a href="#l56.460"></a><span id="l56.460" class="difflineplus">+    for (var namespace of this._daemon.namespaces)</span>
<a href="#l56.461"></a><span id="l56.461">       namespaces[namespace.type].push(namespace);</span>
<a href="#l56.462"></a><span id="l56.462"> </span>
<a href="#l56.463"></a><span id="l56.463">     var response = &quot;* NAMESPACE&quot;;</span>
<a href="#l56.464"></a><span id="l56.464" class="difflineminus">-    for each (var type in namespaces) {</span>
<a href="#l56.465"></a><span id="l56.465" class="difflineplus">+    for (var type of namespaces) {</span>
<a href="#l56.466"></a><span id="l56.466">       if (type.length == 0) {</span>
<a href="#l56.467"></a><span id="l56.467">         response += &quot; NIL&quot;;</span>
<a href="#l56.468"></a><span id="l56.468">         continue;</span>
<a href="#l56.469"></a><span id="l56.469">       }</span>
<a href="#l56.470"></a><span id="l56.470">       response += &quot; (&quot;;</span>
<a href="#l56.471"></a><span id="l56.471" class="difflineminus">-      for each (var namespace in type) {</span>
<a href="#l56.472"></a><span id="l56.472" class="difflineplus">+      for (var namespace of type) {</span>
<a href="#l56.473"></a><span id="l56.473">         response += &quot;(\&quot;&quot;;</span>
<a href="#l56.474"></a><span id="l56.474">         response += namespace.displayName;</span>
<a href="#l56.475"></a><span id="l56.475">         response += &quot;\&quot; \&quot;&quot;;</span>
<a href="#l56.476"></a><span id="l56.476">         response += namespace.delimiter;</span>
<a href="#l56.477"></a><span id="l56.477">         response += &quot;\&quot;)&quot;;</span>
<a href="#l56.478"></a><span id="l56.478">       }</span>
<a href="#l56.479"></a><span id="l56.479">       response += &quot;)&quot;;</span>
<a href="#l56.480"></a><span id="l56.480">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l57.1"></a><span id="l57.1" class="difflineminus">--- a/mailnews/test/resources/IMAPpump.js</span>
<a href="#l57.2"></a><span id="l57.2" class="difflineplus">+++ b/mailnews/test/resources/IMAPpump.js</span>
<a href="#l57.3"></a><span id="l57.3" class="difflineat">@@ -49,17 +49,17 @@ function setupIMAPPump(extensions)</span>
<a href="#l57.4"></a><span id="l57.4">       return makeServer(daemon, configurations[infoString].join(&quot;,&quot;));</span>
<a href="#l57.5"></a><span id="l57.5"> </span>
<a href="#l57.6"></a><span id="l57.6">     function createHandler(d) {</span>
<a href="#l57.7"></a><span id="l57.7">       var handler = new IMAP_RFC3501_handler(d);</span>
<a href="#l57.8"></a><span id="l57.8">       if (!infoString)</span>
<a href="#l57.9"></a><span id="l57.9">         infoString = &quot;RFC2195&quot;;</span>
<a href="#l57.10"></a><span id="l57.10"> </span>
<a href="#l57.11"></a><span id="l57.11">       var parts = infoString.split(/ *, */);</span>
<a href="#l57.12"></a><span id="l57.12" class="difflineminus">-      for each (var part in parts) {</span>
<a href="#l57.13"></a><span id="l57.13" class="difflineplus">+      for (var part of parts) {</span>
<a href="#l57.14"></a><span id="l57.14">         mixinExtension(handler, eval(&quot;IMAP_&quot; + part + &quot;_extension&quot;));</span>
<a href="#l57.15"></a><span id="l57.15">       }</span>
<a href="#l57.16"></a><span id="l57.16">       return handler;</span>
<a href="#l57.17"></a><span id="l57.17">     }</span>
<a href="#l57.18"></a><span id="l57.18">     var server = new nsMailServer(createHandler, daemon);</span>
<a href="#l57.19"></a><span id="l57.19">     server.start();</span>
<a href="#l57.20"></a><span id="l57.20">     return server;</span>
<a href="#l57.21"></a><span id="l57.21">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l58.1"></a><span id="l58.1" class="difflineminus">--- a/mailnews/test/resources/MockFactory.js</span>
<a href="#l58.2"></a><span id="l58.2" class="difflineplus">+++ b/mailnews/test/resources/MockFactory.js</span>
<a href="#l58.3"></a><span id="l58.3" class="difflineat">@@ -87,12 +87,12 @@ var MockFactory = {</span>
<a href="#l58.4"></a><span id="l58.4">     Cm.QueryInterface(Ci.nsIComponentRegistrar)</span>
<a href="#l58.5"></a><span id="l58.5">       .registerFactory(this._registeredComponents[uuid].originalCID, &quot;&quot;,</span>
<a href="#l58.6"></a><span id="l58.6">                        this._registeredComponents[uuid].contractID, null);</span>
<a href="#l58.7"></a><span id="l58.7"> </span>
<a href="#l58.8"></a><span id="l58.8">     delete this._registeredComponents[uuid];</span>
<a href="#l58.9"></a><span id="l58.9">   },</span>
<a href="#l58.10"></a><span id="l58.10"> </span>
<a href="#l58.11"></a><span id="l58.11">   unregisterAll: function() {</span>
<a href="#l58.12"></a><span id="l58.12" class="difflineminus">-    for each (let id in this._registeredComponents)</span>
<a href="#l58.13"></a><span id="l58.13" class="difflineminus">-      this.unregister(id);</span>
<a href="#l58.14"></a><span id="l58.14" class="difflineplus">+    for (let uuid in this._registeredComponents)</span>
<a href="#l58.15"></a><span id="l58.15" class="difflineplus">+      this.unregister(uuid);</span>
<a href="#l58.16"></a><span id="l58.16">   }</span>
<a href="#l58.17"></a><span id="l58.17"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l59.1"></a><span id="l59.1" class="difflineminus">--- a/mailnews/test/resources/asyncTestUtils.js</span>
<a href="#l59.2"></a><span id="l59.2" class="difflineplus">+++ b/mailnews/test/resources/asyncTestUtils.js</span>
<a href="#l59.3"></a><span id="l59.3" class="difflineat">@@ -201,24 +201,24 @@ function async_test_runner_register_help</span>
<a href="#l59.4"></a><span id="l59.4">  * Functions to run after the last test has completed.</span>
<a href="#l59.5"></a><span id="l59.5">  */</span>
<a href="#l59.6"></a><span id="l59.6"> var ASYNC_TEST_RUNNER_FINAL_CLEANUP_HELPERS = [];</span>
<a href="#l59.7"></a><span id="l59.7"> function async_test_runner_register_final_cleanup_helper(aHelper) {</span>
<a href="#l59.8"></a><span id="l59.8">   ASYNC_TEST_RUNNER_FINAL_CLEANUP_HELPERS.push(aHelper);</span>
<a href="#l59.9"></a><span id="l59.9"> }</span>
<a href="#l59.10"></a><span id="l59.10"> </span>
<a href="#l59.11"></a><span id="l59.11"> function _async_test_runner_postTest() {</span>
<a href="#l59.12"></a><span id="l59.12" class="difflineminus">-  for each (let [, helper] in Iterator(ASYNC_TEST_RUNNER_HELPERS)) {</span>
<a href="#l59.13"></a><span id="l59.13" class="difflineplus">+  for (let helper of ASYNC_TEST_RUNNER_HELPERS) {</span>
<a href="#l59.14"></a><span id="l59.14">     if (helper.postTest)</span>
<a href="#l59.15"></a><span id="l59.15">       helper.postTest();</span>
<a href="#l59.16"></a><span id="l59.16">   }</span>
<a href="#l59.17"></a><span id="l59.17"> }</span>
<a href="#l59.18"></a><span id="l59.18"> </span>
<a href="#l59.19"></a><span id="l59.19"> function _async_test_runner_timeout() {</span>
<a href="#l59.20"></a><span id="l59.20" class="difflineminus">-  for each (let [, helper] in Iterator(ASYNC_TEST_RUNNER_HELPERS)) {</span>
<a href="#l59.21"></a><span id="l59.21" class="difflineplus">+  for (let helper of ASYNC_TEST_RUNNER_HELPERS) {</span>
<a href="#l59.22"></a><span id="l59.22">     try {</span>
<a href="#l59.23"></a><span id="l59.23">       if (helper.onTimeout)</span>
<a href="#l59.24"></a><span id="l59.24">         helper.onTimeout();</span>
<a href="#l59.25"></a><span id="l59.25">     }</span>
<a href="#l59.26"></a><span id="l59.26">     catch (ex) {</span>
<a href="#l59.27"></a><span id="l59.27">       dump(&quot;warning: helper failure: (&quot; + ex.fileName + &quot;:&quot; + ex.lineNumber +</span>
<a href="#l59.28"></a><span id="l59.28">            &quot;): &quot; + ex + &quot;\n&quot;);</span>
<a href="#l59.29"></a><span id="l59.29">     }</span>
<a href="#l59.30"></a><span id="l59.30" class="difflineat">@@ -250,21 +250,21 @@ function async_run_tests(aTests, aLonges</span>
<a href="#l59.31"></a><span id="l59.31">       _async_test_runner_timeout);</span>
<a href="#l59.32"></a><span id="l59.32"> </span>
<a href="#l59.33"></a><span id="l59.33">   do_test_pending();</span>
<a href="#l59.34"></a><span id="l59.34"> </span>
<a href="#l59.35"></a><span id="l59.35">   async_run({func: _async_test_runner, args: [aTests]});</span>
<a href="#l59.36"></a><span id="l59.36"> }</span>
<a href="#l59.37"></a><span id="l59.37"> </span>
<a href="#l59.38"></a><span id="l59.38"> function _async_test_runner(aTests) {</span>
<a href="#l59.39"></a><span id="l59.39" class="difflineminus">-  for each (let [, test] in Iterator(aTests)) {</span>
<a href="#l59.40"></a><span id="l59.40" class="difflineplus">+  for (let test of aTests) {</span>
<a href="#l59.41"></a><span id="l59.41">     // parameterized?</span>
<a href="#l59.42"></a><span id="l59.42">     if (test.length) {</span>
<a href="#l59.43"></a><span id="l59.43">       let [testFunc, parameters] = test;</span>
<a href="#l59.44"></a><span id="l59.44" class="difflineminus">-      for each (let [, parameter] in Iterator(parameters)) {</span>
<a href="#l59.45"></a><span id="l59.45" class="difflineplus">+      for (let parameter of parameters) {</span>
<a href="#l59.46"></a><span id="l59.46">         let paramDesc, args;</span>
<a href="#l59.47"></a><span id="l59.47">         if (typeof(parameter) == &quot;object&quot;) {</span>
<a href="#l59.48"></a><span id="l59.48">           if (parameter.length) {</span>
<a href="#l59.49"></a><span id="l59.49">             paramDesc = parameter.toString();</span>
<a href="#l59.50"></a><span id="l59.50">             args = parameter;</span>
<a href="#l59.51"></a><span id="l59.51">           }</span>
<a href="#l59.52"></a><span id="l59.52">           else {</span>
<a href="#l59.53"></a><span id="l59.53">             paramDesc = parameter.name;</span>
<a href="#l59.54"></a><span id="l59.54" class="difflineat">@@ -287,18 +287,17 @@ function _async_test_runner(aTests) {</span>
<a href="#l59.55"></a><span id="l59.55">       yield async_run({func: test});</span>
<a href="#l59.56"></a><span id="l59.56">       _async_test_runner_postTest();</span>
<a href="#l59.57"></a><span id="l59.57">       mark_test_end();</span>
<a href="#l59.58"></a><span id="l59.58">     }</span>
<a href="#l59.59"></a><span id="l59.59">   }</span>
<a href="#l59.60"></a><span id="l59.60"> </span>
<a href="#l59.61"></a><span id="l59.61">   dump(&quot;=== (Done With Tests)\n&quot;);</span>
<a href="#l59.62"></a><span id="l59.62"> </span>
<a href="#l59.63"></a><span id="l59.63" class="difflineminus">-  for each (let [, cleanupHelper] in</span>
<a href="#l59.64"></a><span id="l59.64" class="difflineminus">-            Iterator(ASYNC_TEST_RUNNER_FINAL_CLEANUP_HELPERS)) {</span>
<a href="#l59.65"></a><span id="l59.65" class="difflineplus">+  for (let cleanupHelper of ASYNC_TEST_RUNNER_FINAL_CLEANUP_HELPERS) {</span>
<a href="#l59.66"></a><span id="l59.66">     try {</span>
<a href="#l59.67"></a><span id="l59.67">       cleanupHelper();</span>
<a href="#l59.68"></a><span id="l59.68">     }</span>
<a href="#l59.69"></a><span id="l59.69">     catch (ex) {</span>
<a href="#l59.70"></a><span id="l59.70">       mark_failure([&quot;Problem during asyncTestUtils cleanup helper&quot;,</span>
<a href="#l59.71"></a><span id="l59.71">                      cleanupHelper.name, &quot;exception:&quot;, ex]);</span>
<a href="#l59.72"></a><span id="l59.72">     }</span>
<a href="#l59.73"></a><span id="l59.73">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l60.1"></a><span id="l60.1" class="difflineminus">--- a/mailnews/test/resources/logHelper.js</span>
<a href="#l60.2"></a><span id="l60.2" class="difflineplus">+++ b/mailnews/test/resources/logHelper.js</span>
<a href="#l60.3"></a><span id="l60.3" class="difflineat">@@ -166,17 +166,17 @@ function _init_log_helper() {</span>
<a href="#l60.4"></a><span id="l60.4">       testFile: _TEST_FILE,</span>
<a href="#l60.5"></a><span id="l60.5">     });</span>
<a href="#l60.6"></a><span id="l60.6">   }</span>
<a href="#l60.7"></a><span id="l60.7"> }</span>
<a href="#l60.8"></a><span id="l60.8"> _init_log_helper();</span>
<a href="#l60.9"></a><span id="l60.9"> </span>
<a href="#l60.10"></a><span id="l60.10"> function _cleanup_log_helper() {</span>
<a href="#l60.11"></a><span id="l60.11">   let rootLogger = Log4Moz.repository.rootLogger;</span>
<a href="#l60.12"></a><span id="l60.12" class="difflineminus">-  for each (let [, appender] in Iterator(rootLogger.appenders)) {</span>
<a href="#l60.13"></a><span id="l60.13" class="difflineplus">+  for (let appender of rootLogger.appenders) {</span>
<a href="#l60.14"></a><span id="l60.14">     if (&quot;closeStream&quot; in appender)</span>
<a href="#l60.15"></a><span id="l60.15">       appender.closeStream();</span>
<a href="#l60.16"></a><span id="l60.16">   }</span>
<a href="#l60.17"></a><span id="l60.17">   rootLogger._appenders = [];</span>
<a href="#l60.18"></a><span id="l60.18"> }</span>
<a href="#l60.19"></a><span id="l60.19"> </span>
<a href="#l60.20"></a><span id="l60.20"> /**</span>
<a href="#l60.21"></a><span id="l60.21">  * Mark the start of a test.  This creates nice console output as well as</span>
<a href="#l60.22"></a><span id="l60.22" class="difflineat">@@ -273,17 +273,18 @@ function mark_all_tests_run() {</span>
<a href="#l60.23"></a><span id="l60.23">   });</span>
<a href="#l60.24"></a><span id="l60.24"> </span>
<a href="#l60.25"></a><span id="l60.25">   _cleanup_log_helper();</span>
<a href="#l60.26"></a><span id="l60.26"> }</span>
<a href="#l60.27"></a><span id="l60.27"> </span>
<a href="#l60.28"></a><span id="l60.28"> function _explode_flags(aFlagWord, aFlagDefs) {</span>
<a href="#l60.29"></a><span id="l60.29">   let flagList = [];</span>
<a href="#l60.30"></a><span id="l60.30"> </span>
<a href="#l60.31"></a><span id="l60.31" class="difflineminus">-  for each (let [flagName, flagVal] in Iterator(aFlagDefs)) {</span>
<a href="#l60.32"></a><span id="l60.32" class="difflineplus">+  for (let flagName in aFlagDefs) {</span>
<a href="#l60.33"></a><span id="l60.33" class="difflineplus">+    let flagVal = aFlagDefs[flagName];</span>
<a href="#l60.34"></a><span id="l60.34">     if (flagVal &amp; aFlagWord)</span>
<a href="#l60.35"></a><span id="l60.35">       flagList.push(flagName);</span>
<a href="#l60.36"></a><span id="l60.36">   }</span>
<a href="#l60.37"></a><span id="l60.37"> </span>
<a href="#l60.38"></a><span id="l60.38">   return flagList;</span>
<a href="#l60.39"></a><span id="l60.39"> }</span>
<a href="#l60.40"></a><span id="l60.40"> </span>
<a href="#l60.41"></a><span id="l60.41"> var _registered_json_normalizers = [];</span>
<a href="#l60.42"></a><span id="l60.42" class="difflineat">@@ -303,17 +304,17 @@ function __value_copy(aObj, aDepthAllowe</span>
<a href="#l60.43"></a><span id="l60.43">  *</span>
<a href="#l60.44"></a><span id="l60.44">  * @param aObj Input object.</span>
<a href="#l60.45"></a><span id="l60.45">  * @param aDepthAllowed How many times we are allowed to recursively call</span>
<a href="#l60.46"></a><span id="l60.46">  *     ourselves.</span>
<a href="#l60.47"></a><span id="l60.47">  */</span>
<a href="#l60.48"></a><span id="l60.48"> function __simple_obj_copy(aObj, aDepthAllowed) {</span>
<a href="#l60.49"></a><span id="l60.49">   let oot = {};</span>
<a href="#l60.50"></a><span id="l60.50">   let nextDepth = aDepthAllowed - 1;</span>
<a href="#l60.51"></a><span id="l60.51" class="difflineminus">-  for each (let key in Iterator(aObj, true)) {</span>
<a href="#l60.52"></a><span id="l60.52" class="difflineplus">+  for (let key in aObj) {</span>
<a href="#l60.53"></a><span id="l60.53">     // avoid triggering getters</span>
<a href="#l60.54"></a><span id="l60.54">     if (aObj.__lookupGetter__(key)) {</span>
<a href="#l60.55"></a><span id="l60.55">       oot[key] = &quot;*getter*&quot;;</span>
<a href="#l60.56"></a><span id="l60.56">       continue;</span>
<a href="#l60.57"></a><span id="l60.57">     }</span>
<a href="#l60.58"></a><span id="l60.58">     let value = aObj[key];</span>
<a href="#l60.59"></a><span id="l60.59"> </span>
<a href="#l60.60"></a><span id="l60.60">     if (value == null) {</span>
<a href="#l60.61"></a><span id="l60.61" class="difflineat">@@ -324,18 +325,17 @@ function __simple_obj_copy(aObj, aDepthA</span>
<a href="#l60.62"></a><span id="l60.62">     }</span>
<a href="#l60.63"></a><span id="l60.63">     // steal control flow if no more depth is allowed</span>
<a href="#l60.64"></a><span id="l60.64">     else if (!aDepthAllowed) {</span>
<a href="#l60.65"></a><span id="l60.65">       oot[key] = &quot;truncated, string rep: &quot; + value.toString();</span>
<a href="#l60.66"></a><span id="l60.66">     }</span>
<a href="#l60.67"></a><span id="l60.67">     // array?  (not directly counted, but we will terminate because the</span>
<a href="#l60.68"></a><span id="l60.68">     //  child copying occurs using nextDepth...)</span>
<a href="#l60.69"></a><span id="l60.69">     else if (Array.isArray(value)) {</span>
<a href="#l60.70"></a><span id="l60.70" class="difflineminus">-      oot[key] = [__value_copy(v, nextDepth) for each</span>
<a href="#l60.71"></a><span id="l60.71" class="difflineminus">-                   ([, v] in Iterator(value))];</span>
<a href="#l60.72"></a><span id="l60.72" class="difflineplus">+      oot[key] = value.map(v =&gt; __value_copy(v, nextDepth));</span>
<a href="#l60.73"></a><span id="l60.73">     }</span>
<a href="#l60.74"></a><span id="l60.74">     // it's another object! woo!</span>
<a href="#l60.75"></a><span id="l60.75">     else {</span>
<a href="#l60.76"></a><span id="l60.76">       oot[key] = _normalize_for_json(value, nextDepth, true);</span>
<a href="#l60.77"></a><span id="l60.77">     }</span>
<a href="#l60.78"></a><span id="l60.78">   }</span>
<a href="#l60.79"></a><span id="l60.79"> </span>
<a href="#l60.80"></a><span id="l60.80">   // let's take advantage of the object's native toString now</span>
<a href="#l60.81"></a><span id="l60.81" class="difflineat">@@ -369,35 +369,34 @@ function _normalize_for_json(aObj, aDept</span>
<a href="#l60.82"></a><span id="l60.82">   // if it's a simple type just return it direct</span>
<a href="#l60.83"></a><span id="l60.83">   if (typeof(aObj) != &quot;object&quot;)</span>
<a href="#l60.84"></a><span id="l60.84">     return aObj;</span>
<a href="#l60.85"></a><span id="l60.85">   else if (aObj == null)</span>
<a href="#l60.86"></a><span id="l60.86">     return aObj;</span>
<a href="#l60.87"></a><span id="l60.87"> </span>
<a href="#l60.88"></a><span id="l60.88">   // recursively transform arrays outright</span>
<a href="#l60.89"></a><span id="l60.89">   if (Array.isArray(aObj))</span>
<a href="#l60.90"></a><span id="l60.90" class="difflineminus">-      return [__value_copy(v, aDepthAllowed - 1) for each</span>
<a href="#l60.91"></a><span id="l60.91" class="difflineminus">-              ([, v] in Iterator(aObj))];</span>
<a href="#l60.92"></a><span id="l60.92" class="difflineplus">+      return aObj.map(v =&gt; __value_copy(v, aDepthAllowed - 1));</span>
<a href="#l60.93"></a><span id="l60.93"> </span>
<a href="#l60.94"></a><span id="l60.94">   // === Mail Specific ===</span>
<a href="#l60.95"></a><span id="l60.95">   // (but common and few enough to not split out)</span>
<a href="#l60.96"></a><span id="l60.96">   if (aObj instanceof Ci.nsIMsgFolder) {</span>
<a href="#l60.97"></a><span id="l60.97">     let flags = aObj.flags;</span>
<a href="#l60.98"></a><span id="l60.98">     return {</span>
<a href="#l60.99"></a><span id="l60.99">       type: &quot;folder&quot;,</span>
<a href="#l60.100"></a><span id="l60.100">       name: aObj.prettiestName,</span>
<a href="#l60.101"></a><span id="l60.101">       uri: aObj.URI,</span>
<a href="#l60.102"></a><span id="l60.102">       flags: _explode_flags(aObj.flags,</span>
<a href="#l60.103"></a><span id="l60.103">                             Ci.nsMsgFolderFlags),</span>
<a href="#l60.104"></a><span id="l60.104">     };</span>
<a href="#l60.105"></a><span id="l60.105">   }</span>
<a href="#l60.106"></a><span id="l60.106">   else if (aObj instanceof Ci.nsIMsgDBHdr) {</span>
<a href="#l60.107"></a><span id="l60.107">     let properties = {};</span>
<a href="#l60.108"></a><span id="l60.108" class="difflineminus">-    for each (let [name, propType] in</span>
<a href="#l60.109"></a><span id="l60.109" class="difflineminus">-              Iterator(_INTERESTING_MESSAGE_HEADER_PROPERTIES)) {</span>
<a href="#l60.110"></a><span id="l60.110" class="difflineplus">+    for (let name in _INTERESTING_MESSAGE_HEADER_PROPERTIES) {</span>
<a href="#l60.111"></a><span id="l60.111" class="difflineplus">+      let propType = _INTERESTING_MESSAGE_HEADER_PROPERTIES[name];</span>
<a href="#l60.112"></a><span id="l60.112">       if (propType === 0)</span>
<a href="#l60.113"></a><span id="l60.113">         properties[name] = (aObj.getStringProperty(name) != &quot;&quot;) ?</span>
<a href="#l60.114"></a><span id="l60.114">                              aObj.getUint32Property(name) : null;</span>
<a href="#l60.115"></a><span id="l60.115">       else</span>
<a href="#l60.116"></a><span id="l60.116">         properties[name] = aObj.getStringProperty(name);</span>
<a href="#l60.117"></a><span id="l60.117">     }</span>
<a href="#l60.118"></a><span id="l60.118">     return {</span>
<a href="#l60.119"></a><span id="l60.119">       type: &quot;msgHdr&quot;,</span>
<a href="#l60.120"></a><span id="l60.120" class="difflineat">@@ -499,18 +498,17 @@ function _normalize_for_json(aObj, aDept</span>
<a href="#l60.121"></a><span id="l60.121">       type: &quot;stackFrame&quot;,</span>
<a href="#l60.122"></a><span id="l60.122">       name: aObj.errorMessage,</span>
<a href="#l60.123"></a><span id="l60.123">       category: aObj.category,</span>
<a href="#l60.124"></a><span id="l60.124">       fileName: aObj.sourceName,</span>
<a href="#l60.125"></a><span id="l60.125">       lineNumber: aObj.lineNumber,</span>
<a href="#l60.126"></a><span id="l60.126">     };</span>
<a href="#l60.127"></a><span id="l60.127">   }</span>
<a href="#l60.128"></a><span id="l60.128">   else {</span>
<a href="#l60.129"></a><span id="l60.129" class="difflineminus">-    for each (let [, [checkType, handler]] in</span>
<a href="#l60.130"></a><span id="l60.130" class="difflineminus">-              Iterator(_registered_json_normalizers)) {</span>
<a href="#l60.131"></a><span id="l60.131" class="difflineplus">+    for (let [checkType, handler] of _registered_json_normalizers) {</span>
<a href="#l60.132"></a><span id="l60.132">       if (aObj instanceof checkType)</span>
<a href="#l60.133"></a><span id="l60.133">         return handler(aObj);</span>
<a href="#l60.134"></a><span id="l60.134">     }</span>
<a href="#l60.135"></a><span id="l60.135"> </span>
<a href="#l60.136"></a><span id="l60.136">     // Do not fall into simple object walking if this is an XPCOM interface.</span>
<a href="#l60.137"></a><span id="l60.137">     //  We might run across getters and that leads to nothing good.</span>
<a href="#l60.138"></a><span id="l60.138">     if (aObj instanceof Ci.nsISupports) {</span>
<a href="#l60.139"></a><span id="l60.139">       return {</span>
<a href="#l60.140"></a><span id="l60.140" class="difflineat">@@ -541,17 +539,17 @@ function _MarkAction(aWho, aWhat, aArgs)</span>
<a href="#l60.141"></a><span id="l60.141">   this.args = aArgs;</span>
<a href="#l60.142"></a><span id="l60.142"> }</span>
<a href="#l60.143"></a><span id="l60.143"> _MarkAction.prototype = {</span>
<a href="#l60.144"></a><span id="l60.144">   _jsonMe: true,</span>
<a href="#l60.145"></a><span id="l60.145">   toString: function() {</span>
<a href="#l60.146"></a><span id="l60.146">     let argStr;</span>
<a href="#l60.147"></a><span id="l60.147">     if (this.args) {</span>
<a href="#l60.148"></a><span id="l60.148">       argStr = &quot;:&quot;;</span>
<a href="#l60.149"></a><span id="l60.149" class="difflineminus">-      for each (let [, arg] in Iterator(this.args)) {</span>
<a href="#l60.150"></a><span id="l60.150" class="difflineplus">+      for (let arg of this.args) {</span>
<a href="#l60.151"></a><span id="l60.151">         if (arg != null &amp;&amp; (typeof(arg) == &quot;object&quot;) &amp;&amp; (&quot;type&quot; in arg)) {</span>
<a href="#l60.152"></a><span id="l60.152">           if (&quot;name&quot; in arg)</span>
<a href="#l60.153"></a><span id="l60.153">             argStr += &quot; &quot; + arg.type + &quot;: &quot; + arg.name;</span>
<a href="#l60.154"></a><span id="l60.154">           else</span>
<a href="#l60.155"></a><span id="l60.155">             argStr += &quot; &quot; + arg.type;</span>
<a href="#l60.156"></a><span id="l60.156">         }</span>
<a href="#l60.157"></a><span id="l60.157">         else</span>
<a href="#l60.158"></a><span id="l60.158">           argStr += &quot; &quot; + arg;</span>
<a href="#l60.159"></a><span id="l60.159" class="difflineat">@@ -575,18 +573,17 @@ function _MarkAction(aWho, aWhat, aArgs)</span>
<a href="#l60.160"></a><span id="l60.160">  * @param aArgs A list of arguments, which could each be something like an</span>
<a href="#l60.161"></a><span id="l60.161">  *     nsIMsgFolder or nsIMsgDBHdr or something like that.  It uses</span>
<a href="#l60.162"></a><span id="l60.162">  *     |_normalize_for_json| which can handle some native objects, be extended</span>
<a href="#l60.163"></a><span id="l60.163">  *     to handle more, and does a fair job on straight JS objects.</span>
<a href="#l60.164"></a><span id="l60.164">  */</span>
<a href="#l60.165"></a><span id="l60.165"> function mark_action(aWho, aWhat, aArgs) {</span>
<a href="#l60.166"></a><span id="l60.166">   let logger = Log4Moz.repository.getLogger(&quot;test.&quot; + aWho);</span>
<a href="#l60.167"></a><span id="l60.167"> </span>
<a href="#l60.168"></a><span id="l60.168" class="difflineminus">-  aArgs = [_normalize_for_json(arg, undefined, true) for each</span>
<a href="#l60.169"></a><span id="l60.169" class="difflineminus">-           ([, arg] in Iterator(aArgs))];</span>
<a href="#l60.170"></a><span id="l60.170" class="difflineplus">+  aArgs = aArgs.map(arg =&gt; _normalize_for_json(arg, undefined, true));</span>
<a href="#l60.171"></a><span id="l60.171">   logger.info(_testLoggerActiveContext, new _MarkAction(aWho, aWhat, aArgs));</span>
<a href="#l60.172"></a><span id="l60.172"> }</span>
<a href="#l60.173"></a><span id="l60.173"> </span>
<a href="#l60.174"></a><span id="l60.174"> /*</span>
<a href="#l60.175"></a><span id="l60.175">  * Wrap the xpcshell test functions that do interesting things.  The idea is</span>
<a href="#l60.176"></a><span id="l60.176">  *  that we clobber these only if we're going to value-add; that decision</span>
<a href="#l60.177"></a><span id="l60.177">  *  gets made up top in the initialization function.</span>
<a href="#l60.178"></a><span id="l60.178">  *</span>
<a href="#l60.179"></a><span id="l60.179" class="difflineat">@@ -623,17 +620,17 @@ function _Failure(aText, aStack) {</span>
<a href="#l60.180"></a><span id="l60.180"> }</span>
<a href="#l60.181"></a><span id="l60.181"> _Failure.prototype = {</span>
<a href="#l60.182"></a><span id="l60.182">   _jsonMe: true,</span>
<a href="#l60.183"></a><span id="l60.183"> };</span>
<a href="#l60.184"></a><span id="l60.184"> </span>
<a href="#l60.185"></a><span id="l60.185"> function mark_failure(aRichString) {</span>
<a href="#l60.186"></a><span id="l60.186">   let args = [_testLoggerActiveContext];</span>
<a href="#l60.187"></a><span id="l60.187">   let text = &quot;&quot;;</span>
<a href="#l60.188"></a><span id="l60.188" class="difflineminus">-  for each (let [i, richThing] in Iterator(aRichString)) {</span>
<a href="#l60.189"></a><span id="l60.189" class="difflineplus">+  for (let [i, richThing] of aRichString.entries()) {</span>
<a href="#l60.190"></a><span id="l60.190">     text += (i ? &quot; &quot; : &quot;&quot;);</span>
<a href="#l60.191"></a><span id="l60.191">     if (richThing == null || typeof(richThing) != &quot;object&quot;) {</span>
<a href="#l60.192"></a><span id="l60.192">       text += richThing;</span>
<a href="#l60.193"></a><span id="l60.193">       args.push(richThing);</span>
<a href="#l60.194"></a><span id="l60.194">     }</span>
<a href="#l60.195"></a><span id="l60.195">     else {</span>
<a href="#l60.196"></a><span id="l60.196">       let jsonThing = _normalize_for_json(richThing);</span>
<a href="#l60.197"></a><span id="l60.197">       text += &quot;[&quot; + jsonThing.type + &quot; &quot; + jsonThing.name + &quot;]&quot;;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l61.1"></a><span id="l61.1" class="difflineminus">--- a/mailnews/test/resources/messageGenerator.js</span>
<a href="#l61.2"></a><span id="l61.2" class="difflineplus">+++ b/mailnews/test/resources/messageGenerator.js</span>
<a href="#l61.3"></a><span id="l61.3" class="difflineat">@@ -201,18 +201,20 @@ SyntheticPartMulti.prototype = {</span>
<a href="#l61.4"></a><span id="l61.4">         s += 'Content-Transfer-Encoding: ' +</span>
<a href="#l61.5"></a><span id="l61.5">              part.contentTransferEncodingHeaderValue + '\r\n';</span>
<a href="#l61.6"></a><span id="l61.6">       if (part.hasDisposition)</span>
<a href="#l61.7"></a><span id="l61.7">         s += 'Content-Disposition: ' + part.contentDispositionHeaderValue +</span>
<a href="#l61.8"></a><span id="l61.8">              '\r\n';</span>
<a href="#l61.9"></a><span id="l61.9">       if (part.hasContentId)</span>
<a href="#l61.10"></a><span id="l61.10">         s += 'Content-ID: ' + part.contentIdHeaderValue + '\r\n';</span>
<a href="#l61.11"></a><span id="l61.11">       if (part.hasExtraHeaders)</span>
<a href="#l61.12"></a><span id="l61.12" class="difflineminus">-        for each (let [k, v] in Iterator(part.extraHeaders))</span>
<a href="#l61.13"></a><span id="l61.13" class="difflineplus">+        for (let k in part.extraHeaders) {</span>
<a href="#l61.14"></a><span id="l61.14" class="difflineplus">+          let v = part.extraHeaders[k];</span>
<a href="#l61.15"></a><span id="l61.15">           s += k + ': ' + v + '\r\n';</span>
<a href="#l61.16"></a><span id="l61.16" class="difflineplus">+        }</span>
<a href="#l61.17"></a><span id="l61.17">       s += '\r\n';</span>
<a href="#l61.18"></a><span id="l61.18">       s += part.toMessageString() + '\r\n\r\n';</span>
<a href="#l61.19"></a><span id="l61.19">     }</span>
<a href="#l61.20"></a><span id="l61.20">     s += &quot;--&quot; + this._boundary + '--';</span>
<a href="#l61.21"></a><span id="l61.21">     return s;</span>
<a href="#l61.22"></a><span id="l61.22">   },</span>
<a href="#l61.23"></a><span id="l61.23">   prettyString: function(aIndent) {</span>
<a href="#l61.24"></a><span id="l61.24">     let nextIndent = (aIndent != null) ? (aIndent + &quot;  &quot;) : &quot;&quot;;</span>
<a href="#l61.25"></a><span id="l61.25" class="difflineat">@@ -360,17 +362,18 @@ var _DEFAULT_META_STATES = {</span>
<a href="#l61.26"></a><span id="l61.26">  *     relevant to the messageInjection logic and perhaps some testing logic.</span>
<a href="#l61.27"></a><span id="l61.27">  * @param [aMetaState.junk=false] Is the method junk?</span>
<a href="#l61.28"></a><span id="l61.28">  */</span>
<a href="#l61.29"></a><span id="l61.29"> function SyntheticMessage(aHeaders, aBodyPart, aMetaState) {</span>
<a href="#l61.30"></a><span id="l61.30">   // we currently do not need to call SyntheticPart's constructor...</span>
<a href="#l61.31"></a><span id="l61.31">   this.headers = aHeaders || {};</span>
<a href="#l61.32"></a><span id="l61.32">   this.bodyPart = aBodyPart || new SyntheticPartLeaf(&quot;&quot;);</span>
<a href="#l61.33"></a><span id="l61.33">   this.metaState = aMetaState || {};</span>
<a href="#l61.34"></a><span id="l61.34" class="difflineminus">-  for each (let [key, value] in Iterator(_DEFAULT_META_STATES)) {</span>
<a href="#l61.35"></a><span id="l61.35" class="difflineplus">+  for (let key in _DEFAULT_META_STATES) {</span>
<a href="#l61.36"></a><span id="l61.36" class="difflineplus">+    let value = _DEFAULT_META_STATES[key];</span>
<a href="#l61.37"></a><span id="l61.37">     if (!(key in this.metaState))</span>
<a href="#l61.38"></a><span id="l61.38">       this.metaState[key] = value;</span>
<a href="#l61.39"></a><span id="l61.39">   }</span>
<a href="#l61.40"></a><span id="l61.40"> }</span>
<a href="#l61.41"></a><span id="l61.41"> </span>
<a href="#l61.42"></a><span id="l61.42"> SyntheticMessage.prototype = {</span>
<a href="#l61.43"></a><span id="l61.43">   __proto__: SyntheticPart.prototype,</span>
<a href="#l61.44"></a><span id="l61.44">   _contentType: 'message/rfc822',</span>
<a href="#l61.45"></a><span id="l61.45" class="difflineat">@@ -511,19 +514,18 @@ SyntheticMessage.prototype = {</span>
<a href="#l61.46"></a><span id="l61.46">       for (let i = 0; i &lt; people.length; i++) {</span>
<a href="#l61.47"></a><span id="l61.47">         this._to.push(this._parseMailbox(people[i]));</span>
<a href="#l61.48"></a><span id="l61.48">       }</span>
<a href="#l61.49"></a><span id="l61.49"> </span>
<a href="#l61.50"></a><span id="l61.50">       this.headers[&quot;To&quot;] = aNameAndAddresses;</span>
<a href="#l61.51"></a><span id="l61.51">       return;</span>
<a href="#l61.52"></a><span id="l61.52">     }</span>
<a href="#l61.53"></a><span id="l61.53">     this._to = aNameAndAddresses;</span>
<a href="#l61.54"></a><span id="l61.54" class="difflineminus">-    this.headers[&quot;To&quot;] = this._commaize(</span>
<a href="#l61.55"></a><span id="l61.55" class="difflineminus">-                           [this._formatMailFromNameAndAddress(nameAndAddr)</span>
<a href="#l61.56"></a><span id="l61.56" class="difflineminus">-                            for each (nameAndAddr in aNameAndAddresses)]);</span>
<a href="#l61.57"></a><span id="l61.57" class="difflineplus">+    this.headers[&quot;To&quot;] = this._commaize(aNameAndAddresses.</span>
<a href="#l61.58"></a><span id="l61.58" class="difflineplus">+      map(nameAndAddr =&gt; this._formatMailFromNameAndAddress(nameAndAddr)));</span>
<a href="#l61.59"></a><span id="l61.59">   },</span>
<a href="#l61.60"></a><span id="l61.60">   /** @returns The display name of the first intended recipient. */</span>
<a href="#l61.61"></a><span id="l61.61">   get toName() { return this._to[0][0]; },</span>
<a href="#l61.62"></a><span id="l61.62">   /** @returns The email address (no display name) of the first recipient. */</span>
<a href="#l61.63"></a><span id="l61.63">   get toAddress() { return this._to[0][1]; },</span>
<a href="#l61.64"></a><span id="l61.64"> </span>
<a href="#l61.65"></a><span id="l61.65">   /**</span>
<a href="#l61.66"></a><span id="l61.66">    * @returns The comma-ized list of name-and-address tuples used to set the Cc</span>
<a href="#l61.67"></a><span id="l61.67" class="difflineat">@@ -546,19 +548,18 @@ SyntheticMessage.prototype = {</span>
<a href="#l61.68"></a><span id="l61.68">       let people = aNameAndAddresses.split(&quot;,&quot;);</span>
<a href="#l61.69"></a><span id="l61.69">       for (let i = 0; i &lt; people.length; i++) {</span>
<a href="#l61.70"></a><span id="l61.70">         this._cc.push(this._parseMailbox(people[i]));</span>
<a href="#l61.71"></a><span id="l61.71">       }</span>
<a href="#l61.72"></a><span id="l61.72">       this.headers[&quot;Cc&quot;] = aNameAndAddresses;</span>
<a href="#l61.73"></a><span id="l61.73">       return;</span>
<a href="#l61.74"></a><span id="l61.74">     }</span>
<a href="#l61.75"></a><span id="l61.75">     this._cc = aNameAndAddresses;</span>
<a href="#l61.76"></a><span id="l61.76" class="difflineminus">-    this.headers[&quot;Cc&quot;] = this._commaize(</span>
<a href="#l61.77"></a><span id="l61.77" class="difflineminus">-                           [this._formatMailFromNameAndAddress(nameAndAddr)</span>
<a href="#l61.78"></a><span id="l61.78" class="difflineminus">-                            for each (nameAndAddr in aNameAndAddresses)]);</span>
<a href="#l61.79"></a><span id="l61.79" class="difflineplus">+    this.headers[&quot;Cc&quot;] = this._commaize(aNameAndAddresses.</span>
<a href="#l61.80"></a><span id="l61.80" class="difflineplus">+      map(nameAndAddr =&gt; this._formatMailFromNameAndAddress(nameAndAddr)));</span>
<a href="#l61.81"></a><span id="l61.81">   },</span>
<a href="#l61.82"></a><span id="l61.82"> </span>
<a href="#l61.83"></a><span id="l61.83">   get bodyPart() {</span>
<a href="#l61.84"></a><span id="l61.84">     return this._bodyPart;</span>
<a href="#l61.85"></a><span id="l61.85">   },</span>
<a href="#l61.86"></a><span id="l61.86">   set bodyPart(aBodyPart) {</span>
<a href="#l61.87"></a><span id="l61.87">     this._bodyPart = aBodyPart;</span>
<a href="#l61.88"></a><span id="l61.88">     this.headers[&quot;Content-Type&quot;] = this._bodyPart.contentTypeHeaderValue;</span>
<a href="#l61.89"></a><span id="l61.89" class="difflineat">@@ -607,18 +608,19 @@ SyntheticMessage.prototype = {</span>
<a href="#l61.90"></a><span id="l61.90"> </span>
<a href="#l61.91"></a><span id="l61.91">     return s;</span>
<a href="#l61.92"></a><span id="l61.92">   },</span>
<a href="#l61.93"></a><span id="l61.93"> </span>
<a href="#l61.94"></a><span id="l61.94">   /**</span>
<a href="#l61.95"></a><span id="l61.95">    * @returns this messages in rfc822 format, or something close enough.</span>
<a href="#l61.96"></a><span id="l61.96">    */</span>
<a href="#l61.97"></a><span id="l61.97">   toMessageString: function() {</span>
<a href="#l61.98"></a><span id="l61.98" class="difflineminus">-    let lines = [headerKey + &quot;: &quot; + this._formatHeaderValues(headerValues)</span>
<a href="#l61.99"></a><span id="l61.99" class="difflineminus">-                 for each ([headerKey, headerValues] in Iterator(this.headers))];</span>
<a href="#l61.100"></a><span id="l61.100" class="difflineplus">+    let lines = Object.keys(this.headers).</span>
<a href="#l61.101"></a><span id="l61.101" class="difflineplus">+      map(headerKey =&gt;</span>
<a href="#l61.102"></a><span id="l61.102" class="difflineplus">+          headerKey + &quot;: &quot; + this._formatHeaderValues(this.headers[headerKey]));</span>
<a href="#l61.103"></a><span id="l61.103"> </span>
<a href="#l61.104"></a><span id="l61.104">     return lines.join(&quot;\r\n&quot;) + &quot;\r\n\r\n&quot; + this.bodyPart.toMessageString() +</span>
<a href="#l61.105"></a><span id="l61.105">       &quot;\r\n&quot;;</span>
<a href="#l61.106"></a><span id="l61.106">   },</span>
<a href="#l61.107"></a><span id="l61.107"> </span>
<a href="#l61.108"></a><span id="l61.108">   toMboxString: function() {</span>
<a href="#l61.109"></a><span id="l61.109">     return &quot;From &quot; + this._from[1] + &quot;\r\n&quot; + this.toMessageString() + &quot;\r\n&quot;;</span>
<a href="#l61.110"></a><span id="l61.110">   },</span>
<a href="#l61.111"></a><span id="l61.111" class="difflineat">@@ -917,17 +919,18 @@ MessageGenerator.prototype = {</span>
<a href="#l61.112"></a><span id="l61.112">         ts -= age.weeks * 7 * 24 * 60 * 60 * 1000;</span>
<a href="#l61.113"></a><span id="l61.113">       msg.date = new Date(ts);</span>
<a href="#l61.114"></a><span id="l61.114">     }</span>
<a href="#l61.115"></a><span id="l61.115">     else {</span>
<a href="#l61.116"></a><span id="l61.116">       msg.date = this.makeDate();</span>
<a href="#l61.117"></a><span id="l61.117">     }</span>
<a href="#l61.118"></a><span id="l61.118"> </span>
<a href="#l61.119"></a><span id="l61.119">     if (&quot;clobberHeaders&quot; in aArgs) {</span>
<a href="#l61.120"></a><span id="l61.120" class="difflineminus">-      for each (let [key, value] in Iterator(aArgs.clobberHeaders)) {</span>
<a href="#l61.121"></a><span id="l61.121" class="difflineplus">+      for (let key in aArgs.clobberHeaders) {</span>
<a href="#l61.122"></a><span id="l61.122" class="difflineplus">+        let value = aArgs.clobberHeaders[key];</span>
<a href="#l61.123"></a><span id="l61.123">         if (value === null)</span>
<a href="#l61.124"></a><span id="l61.124">           delete msg.headers[key];</span>
<a href="#l61.125"></a><span id="l61.125">         else</span>
<a href="#l61.126"></a><span id="l61.126">           msg.headers[key] = value;</span>
<a href="#l61.127"></a><span id="l61.127">         // clobber helper...</span>
<a href="#l61.128"></a><span id="l61.128">         if (key == &quot;From&quot;)</span>
<a href="#l61.129"></a><span id="l61.129">           msg._from = [&quot;&quot;, &quot;&quot;];</span>
<a href="#l61.130"></a><span id="l61.130">         if (key == &quot;To&quot;)</span>
<a href="#l61.131"></a><span id="l61.131" class="difflineat">@@ -949,17 +952,17 @@ MessageGenerator.prototype = {</span>
<a href="#l61.132"></a><span id="l61.132">       bodyPart = new SyntheticPartLeaf(aArgs.body.body, aArgs.body);</span>
<a href="#l61.133"></a><span id="l61.133">     else // different messages should have a chance at different bodies</span>
<a href="#l61.134"></a><span id="l61.134">       bodyPart = new SyntheticPartLeaf(&quot;Hello &quot; + msg.toName + &quot;!&quot;);</span>
<a href="#l61.135"></a><span id="l61.135"> </span>
<a href="#l61.136"></a><span id="l61.136">     // if it has any attachments, create a multipart/mixed to be the body and</span>
<a href="#l61.137"></a><span id="l61.137">     //  have it be the parent of the existing body and all the attachments</span>
<a href="#l61.138"></a><span id="l61.138">     if (aArgs.attachments) {</span>
<a href="#l61.139"></a><span id="l61.139">       let parts = [bodyPart];</span>
<a href="#l61.140"></a><span id="l61.140" class="difflineminus">-      for each (let [,attachDesc] in Iterator(aArgs.attachments))</span>
<a href="#l61.141"></a><span id="l61.141" class="difflineplus">+      for (let attachDesc of aArgs.attachments)</span>
<a href="#l61.142"></a><span id="l61.142">         parts.push(new SyntheticPartLeaf(attachDesc.body, attachDesc));</span>
<a href="#l61.143"></a><span id="l61.143">       bodyPart = new SyntheticPartMultiMixed(parts);</span>
<a href="#l61.144"></a><span id="l61.144">     }</span>
<a href="#l61.145"></a><span id="l61.145"> </span>
<a href="#l61.146"></a><span id="l61.146">     msg.bodyPart = bodyPart;</span>
<a href="#l61.147"></a><span id="l61.147"> </span>
<a href="#l61.148"></a><span id="l61.148">     msg.callerData = aArgs.callerData;</span>
<a href="#l61.149"></a><span id="l61.149"> </span>
<a href="#l61.150"></a><span id="l61.150" class="difflineat">@@ -1022,17 +1025,17 @@ MessageGenerator.prototype = {</span>
<a href="#l61.151"></a><span id="l61.151">     }</span>
<a href="#l61.152"></a><span id="l61.152">     // copy over the initial values from age (if present)</span>
<a href="#l61.153"></a><span id="l61.153">     if (aSetDef.age) {</span>
<a href="#l61.154"></a><span id="l61.154">       args.age = args.age || {};</span>
<a href="#l61.155"></a><span id="l61.155">       for (let [unit, value] in Iterator(aSetDef.age))</span>
<a href="#l61.156"></a><span id="l61.156">         args.age[unit] = value;</span>
<a href="#l61.157"></a><span id="l61.157">     }</span>
<a href="#l61.158"></a><span id="l61.158">     // just copy over any attributes found from MAKE_MESSAGES_PROPAGATE</span>
<a href="#l61.159"></a><span id="l61.159" class="difflineminus">-    for each (let [, propAttrName] in Iterator(this.MAKE_MESSAGES_PROPAGATE)) {</span>
<a href="#l61.160"></a><span id="l61.160" class="difflineplus">+    for (let propAttrName of this.MAKE_MESSAGES_PROPAGATE) {</span>
<a href="#l61.161"></a><span id="l61.161">       if (aSetDef[propAttrName])</span>
<a href="#l61.162"></a><span id="l61.162">         args[propAttrName] = aSetDef[propAttrName];</span>
<a href="#l61.163"></a><span id="l61.163">     }</span>
<a href="#l61.164"></a><span id="l61.164"> </span>
<a href="#l61.165"></a><span id="l61.165">     let count = aSetDef.count || this.MAKE_MESSAGES_DEFAULTS.count;</span>
<a href="#l61.166"></a><span id="l61.166">     let messagsPerThread = aSetDef.msgsPerThread || 1;</span>
<a href="#l61.167"></a><span id="l61.167">     let lastMessage = null;</span>
<a href="#l61.168"></a><span id="l61.168">     for (let iMsg = 0; iMsg &lt; count; iMsg++) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l62.1"></a><span id="l62.1" class="difflineminus">--- a/mailnews/test/resources/messageInjection.js</span>
<a href="#l62.2"></a><span id="l62.2" class="difflineplus">+++ b/mailnews/test/resources/messageInjection.js</span>
<a href="#l62.3"></a><span id="l62.3" class="difflineat">@@ -185,29 +185,29 @@ function _cleanup_message_injection() {</span>
<a href="#l62.4"></a><span id="l62.4"> </span>
<a href="#l62.5"></a><span id="l62.5">     // No more tests, let everything finish.</span>
<a href="#l62.6"></a><span id="l62.6">     // (This spins its own event loop...)</span>
<a href="#l62.7"></a><span id="l62.7">     mis.server.stop();</span>
<a href="#l62.8"></a><span id="l62.8">   }</span>
<a href="#l62.9"></a><span id="l62.9"> </span>
<a href="#l62.10"></a><span id="l62.10">   // Clean out mis; we don't just null the global because it's conceivable we</span>
<a href="#l62.11"></a><span id="l62.11">   //  might still have some closures floating about.</span>
<a href="#l62.12"></a><span id="l62.12" class="difflineminus">-  for each (let key in Iterator(mis, true))</span>
<a href="#l62.13"></a><span id="l62.13" class="difflineplus">+  for (let key in mis)</span>
<a href="#l62.14"></a><span id="l62.14">     delete mis[key];</span>
<a href="#l62.15"></a><span id="l62.15"> }</span>
<a href="#l62.16"></a><span id="l62.16"> </span>
<a href="#l62.17"></a><span id="l62.17"> var _messageInjectionSetup = {</span>
<a href="#l62.18"></a><span id="l62.18">   _nextUniqueFolderId: 0,</span>
<a href="#l62.19"></a><span id="l62.19"> </span>
<a href="#l62.20"></a><span id="l62.20">   injectionConfig: {</span>
<a href="#l62.21"></a><span id="l62.21">     mode: &quot;none&quot;,</span>
<a href="#l62.22"></a><span id="l62.22">   },</span>
<a href="#l62.23"></a><span id="l62.23">   listeners: [],</span>
<a href="#l62.24"></a><span id="l62.24">   notifyListeners: function(aHandlerName, aArgs) {</span>
<a href="#l62.25"></a><span id="l62.25" class="difflineminus">-    for each (let [, listener] in Iterator(this.listeners)) {</span>
<a href="#l62.26"></a><span id="l62.26" class="difflineplus">+    for (let listener of this.listeners) {</span>
<a href="#l62.27"></a><span id="l62.27">       if (aHandlerName in listener)</span>
<a href="#l62.28"></a><span id="l62.28">         listener[aHandlerName].apply(listener, aArgs);</span>
<a href="#l62.29"></a><span id="l62.29">     }</span>
<a href="#l62.30"></a><span id="l62.30">   },</span>
<a href="#l62.31"></a><span id="l62.31"> </span>
<a href="#l62.32"></a><span id="l62.32">   /**</span>
<a href="#l62.33"></a><span id="l62.33">    * The nsIMsgIncomingServer</span>
<a href="#l62.34"></a><span id="l62.34">    */</span>
<a href="#l62.35"></a><span id="l62.35" class="difflineat">@@ -245,18 +245,18 @@ function register_message_injection_list</span>
<a href="#l62.36"></a><span id="l62.36">   _messageInjectionSetup.listeners.push(aListener);</span>
<a href="#l62.37"></a><span id="l62.37"> }</span>
<a href="#l62.38"></a><span id="l62.38"> </span>
<a href="#l62.39"></a><span id="l62.39"> /**</span>
<a href="#l62.40"></a><span id="l62.40">  * Convert a list of synthetic messages to a form appropriate to feed to the</span>
<a href="#l62.41"></a><span id="l62.41">  *  POP3 fakeserver.</span>
<a href="#l62.42"></a><span id="l62.42">  */</span>
<a href="#l62.43"></a><span id="l62.43"> function _synthMessagesToFakeRep(aSynthMessages) {</span>
<a href="#l62.44"></a><span id="l62.44" class="difflineminus">-  return [{fileData: msg.toMessageString(), size: -1} for each</span>
<a href="#l62.45"></a><span id="l62.45" class="difflineminus">-          (msg in aSynthMessages)];</span>
<a href="#l62.46"></a><span id="l62.46" class="difflineplus">+  return aSynthMessages.</span>
<a href="#l62.47"></a><span id="l62.47" class="difflineplus">+    map(msg =&gt; ({fileData: msg.toMessageString(), size: -1}));</span>
<a href="#l62.48"></a><span id="l62.48"> }</span>
<a href="#l62.49"></a><span id="l62.49"> </span>
<a href="#l62.50"></a><span id="l62.50"> </span>
<a href="#l62.51"></a><span id="l62.51"> var SEARCH_TERM_MAP_HELPER = {</span>
<a href="#l62.52"></a><span id="l62.52">   subject: Components.interfaces.nsMsgSearchAttrib.Subject,</span>
<a href="#l62.53"></a><span id="l62.53">   body: Components.interfaces.nsMsgSearchAttrib.Body,</span>
<a href="#l62.54"></a><span id="l62.54">   from: Components.interfaces.nsMsgSearchAttrib.Sender,</span>
<a href="#l62.55"></a><span id="l62.55">   to: Components.interfaces.nsMsgSearchAttrib.To,</span>
<a href="#l62.56"></a><span id="l62.56" class="difflineat">@@ -290,17 +290,17 @@ function make_empty_folder(aFolderName, </span>
<a href="#l62.57"></a><span id="l62.57">   let mis = _messageInjectionSetup;</span>
<a href="#l62.58"></a><span id="l62.58"> </span>
<a href="#l62.59"></a><span id="l62.59">   if (mis.injectionConfig.mode == &quot;local&quot;) {</span>
<a href="#l62.60"></a><span id="l62.60">     let localRoot = mis.rootFolder.QueryInterface(Ci.nsIMsgLocalMailFolder);</span>
<a href="#l62.61"></a><span id="l62.61">     testFolder = localRoot.createLocalSubfolder(aFolderName);</span>
<a href="#l62.62"></a><span id="l62.62">     // it seems dumb that we have to set this.</span>
<a href="#l62.63"></a><span id="l62.63">     testFolder.setFlag(Ci.nsMsgFolderFlags.Mail);</span>
<a href="#l62.64"></a><span id="l62.64">     if (aSpecialFlags) {</span>
<a href="#l62.65"></a><span id="l62.65" class="difflineminus">-      for each (let [, flag] in Iterator(aSpecialFlags)) {</span>
<a href="#l62.66"></a><span id="l62.66" class="difflineplus">+      for (let flag of aSpecialFlags) {</span>
<a href="#l62.67"></a><span id="l62.67">         testFolder.setFlag(flag);</span>
<a href="#l62.68"></a><span id="l62.68">       }</span>
<a href="#l62.69"></a><span id="l62.69">     }</span>
<a href="#l62.70"></a><span id="l62.70">     _messageInjectionSetup.notifyListeners(&quot;onRealFolderCreated&quot;,</span>
<a href="#l62.71"></a><span id="l62.71">                                            [testFolder]);</span>
<a href="#l62.72"></a><span id="l62.72">   }</span>
<a href="#l62.73"></a><span id="l62.73">   else if (mis.injectionConfig.mode == &quot;imap&quot;) {</span>
<a href="#l62.74"></a><span id="l62.74">     let promise_completed = async_create_promise();</span>
<a href="#l62.75"></a><span id="l62.75" class="difflineat">@@ -318,17 +318,17 @@ function make_empty_folder(aFolderName, </span>
<a href="#l62.76"></a><span id="l62.76"> </span>
<a href="#l62.77"></a><span id="l62.77">         // XXX there is a bug that causes folders to be reported as ImapPublic</span>
<a href="#l62.78"></a><span id="l62.78">         //  when there is no namespace support by the IMAP server.  This is</span>
<a href="#l62.79"></a><span id="l62.79">         //  a temporary workaround.</span>
<a href="#l62.80"></a><span id="l62.80">         msgFolder.clearFlag(Ci.nsMsgFolderFlags.ImapPublic);</span>
<a href="#l62.81"></a><span id="l62.81">         msgFolder.setFlag(Ci.nsMsgFolderFlags.ImapPersonal);</span>
<a href="#l62.82"></a><span id="l62.82"> </span>
<a href="#l62.83"></a><span id="l62.83">         if (aSpecialFlags) {</span>
<a href="#l62.84"></a><span id="l62.84" class="difflineminus">-          for each (let [, flag] in Iterator(aSpecialFlags)) {</span>
<a href="#l62.85"></a><span id="l62.85" class="difflineplus">+          for (let flag of aSpecialFlags) {</span>
<a href="#l62.86"></a><span id="l62.86">             msgFolder.setFlag(flag);</span>
<a href="#l62.87"></a><span id="l62.87">           }</span>
<a href="#l62.88"></a><span id="l62.88">         }</span>
<a href="#l62.89"></a><span id="l62.89"> </span>
<a href="#l62.90"></a><span id="l62.90">         // get a reference to the fake server folder</span>
<a href="#l62.91"></a><span id="l62.91">         let fakeFolder = mis.daemon.getMailbox(aFolderName);</span>
<a href="#l62.92"></a><span id="l62.92">         // establish the mapping</span>
<a href="#l62.93"></a><span id="l62.93">         mis.handleUriToRealFolder[testFolder] = msgFolder;</span>
<a href="#l62.94"></a><span id="l62.94" class="difflineat">@@ -423,17 +423,18 @@ function make_virtual_folder(aFolders, a</span>
<a href="#l62.95"></a><span id="l62.95">   mark_action(&quot;messageInjection&quot;, &quot;make_virtual_folder&quot;,</span>
<a href="#l62.96"></a><span id="l62.96">               [&quot;creating folder named&quot;, name,</span>
<a href="#l62.97"></a><span id="l62.97">                &quot;from folders&quot;, aFolders, &quot;anding?&quot;, aBooleanAnd,</span>
<a href="#l62.98"></a><span id="l62.98">                &quot;using search def&quot;, aSearchDef]);</span>
<a href="#l62.99"></a><span id="l62.99"> </span>
<a href="#l62.100"></a><span id="l62.100">   let terms = [];</span>
<a href="#l62.101"></a><span id="l62.101">   let termCreator = Components.classes[&quot;@mozilla.org/messenger/searchSession;1&quot;]</span>
<a href="#l62.102"></a><span id="l62.102">                               .createInstance(Ci.nsIMsgSearchSession);</span>
<a href="#l62.103"></a><span id="l62.103" class="difflineminus">-  for each (let [key, val] in Iterator(aSearchDef)) {</span>
<a href="#l62.104"></a><span id="l62.104" class="difflineplus">+  for (let key in aSearchDef) {</span>
<a href="#l62.105"></a><span id="l62.105" class="difflineplus">+    let val = aSearchDef[key];</span>
<a href="#l62.106"></a><span id="l62.106">     let term = termCreator.createTerm();</span>
<a href="#l62.107"></a><span id="l62.107">     let value = term.value;</span>
<a href="#l62.108"></a><span id="l62.108">     value.str = val;</span>
<a href="#l62.109"></a><span id="l62.109">     term.value = value;</span>
<a href="#l62.110"></a><span id="l62.110">     term.attrib = SEARCH_TERM_MAP_HELPER[key];</span>
<a href="#l62.111"></a><span id="l62.111">     if (term.attrib == Components.interfaces.nsMsgSearchAttrib.Custom)</span>
<a href="#l62.112"></a><span id="l62.112">       term.customId = &quot;mailnews@mozilla.org#test&quot;;</span>
<a href="#l62.113"></a><span id="l62.113">     term.op = Components.interfaces.nsMsgSearchOp.Contains;</span>
<a href="#l62.114"></a><span id="l62.114" class="difflineat">@@ -545,17 +546,17 @@ function make_new_sets_in_folders(aMsgFo</span>
<a href="#l62.115"></a><span id="l62.115">     aSynSetDefs = [];</span>
<a href="#l62.116"></a><span id="l62.116">     for (let iSet = 0; iSet &lt; setCount; iSet++)</span>
<a href="#l62.117"></a><span id="l62.117">       aSynSetDefs.push({});</span>
<a href="#l62.118"></a><span id="l62.118">   }</span>
<a href="#l62.119"></a><span id="l62.119">   // now it must be a list of set descriptors</span>
<a href="#l62.120"></a><span id="l62.120"> </span>
<a href="#l62.121"></a><span id="l62.121">   // - create the synthetic message sets</span>
<a href="#l62.122"></a><span id="l62.122">   let messageSets = [];</span>
<a href="#l62.123"></a><span id="l62.123" class="difflineminus">-  for each (let [, synSetDef] in Iterator(aSynSetDefs)) {</span>
<a href="#l62.124"></a><span id="l62.124" class="difflineplus">+  for (let synSetDef of aSynSetDefs) {</span>
<a href="#l62.125"></a><span id="l62.125">     let messages = gMessageGenerator.makeMessages(synSetDef);</span>
<a href="#l62.126"></a><span id="l62.126">     messageSets.push(new SyntheticMessageSet(messages));</span>
<a href="#l62.127"></a><span id="l62.127">   }</span>
<a href="#l62.128"></a><span id="l62.128"> </span>
<a href="#l62.129"></a><span id="l62.129">   // - add the messages to the folders (interleaving them)</span>
<a href="#l62.130"></a><span id="l62.130">   add_sets_to_folders(aMsgFolders, messageSets, aDoNotForceUpdate);</span>
<a href="#l62.131"></a><span id="l62.131"> </span>
<a href="#l62.132"></a><span id="l62.132">   return messageSets;</span>
<a href="#l62.133"></a><span id="l62.133" class="difflineat">@@ -621,29 +622,29 @@ function add_sets_to_folders(aMsgFolders</span>
<a href="#l62.134"></a><span id="l62.134"> </span>
<a href="#l62.135"></a><span id="l62.135">   let iterFolders, folderList;</span>
<a href="#l62.136"></a><span id="l62.136">   let popMessages, msgHdrs;</span>
<a href="#l62.137"></a><span id="l62.137"> </span>
<a href="#l62.138"></a><span id="l62.138">   _messageInjectionSetup.notifyListeners(&quot;onInjectingMessages&quot;, []);</span>
<a href="#l62.139"></a><span id="l62.139"> </span>
<a href="#l62.140"></a><span id="l62.140">   // -- Pre-loop</span>
<a href="#l62.141"></a><span id="l62.141">   if (mis.injectionConfig.mode == &quot;local&quot;) {</span>
<a href="#l62.142"></a><span id="l62.142" class="difflineminus">-    for each (let [, folder] in Iterator(aMsgFolders)) {</span>
<a href="#l62.143"></a><span id="l62.143" class="difflineplus">+    for (let folder of aMsgFolders) {</span>
<a href="#l62.144"></a><span id="l62.144">       if (!(folder instanceof Components.interfaces.nsIMsgLocalMailFolder))</span>
<a href="#l62.145"></a><span id="l62.145">         throw Exception(&quot;All folders in aMsgFolders must be local folders!&quot;);</span>
<a href="#l62.146"></a><span id="l62.146">     }</span>
<a href="#l62.147"></a><span id="l62.147">     folderList = aMsgFolders;</span>
<a href="#l62.148"></a><span id="l62.148">   }</span>
<a href="#l62.149"></a><span id="l62.149">   else if (mis.injectionConfig.mode == &quot;imap&quot;) {</span>
<a href="#l62.150"></a><span id="l62.150">     // no protection is possible because of our dependency on promises,</span>
<a href="#l62.151"></a><span id="l62.151">     //  although we could check that the fake URL is one we handed out.</span>
<a href="#l62.152"></a><span id="l62.152">     folderList = aMsgFolders;</span>
<a href="#l62.153"></a><span id="l62.153">   }</span>
<a href="#l62.154"></a><span id="l62.154">   else if (mis.injectionConfig.mode == &quot;pop&quot;) {</span>
<a href="#l62.155"></a><span id="l62.155" class="difflineminus">-    for each (let [, folder] in Iterator(aMsgFolders)) {</span>
<a href="#l62.156"></a><span id="l62.156" class="difflineplus">+    for (let folder of aMsgFolders) {</span>
<a href="#l62.157"></a><span id="l62.157">       if (folder.URI != mis.inboxFolder.URI)</span>
<a href="#l62.158"></a><span id="l62.158">         throw new Exception(&quot;We only support the Inbox for POP injection&quot;);</span>
<a href="#l62.159"></a><span id="l62.159">     }</span>
<a href="#l62.160"></a><span id="l62.160">     folderList = aMsgFolders;</span>
<a href="#l62.161"></a><span id="l62.161"> </span>
<a href="#l62.162"></a><span id="l62.162">     // ugh, so this is really a degenerate case where everything we do is</span>
<a href="#l62.163"></a><span id="l62.163">     //  overkill, but let's try this at least.</span>
<a href="#l62.164"></a><span id="l62.164">     popMessages = [];</span>
<a href="#l62.165"></a><span id="l62.165" class="difflineat">@@ -735,17 +736,17 @@ function add_sets_to_folders(aMsgFolders</span>
<a href="#l62.166"></a><span id="l62.166">     //  one...</span>
<a href="#l62.167"></a><span id="l62.167">     return async_run({func: function() {</span>
<a href="#l62.168"></a><span id="l62.168">       yield wait_for_async_promises();</span>
<a href="#l62.169"></a><span id="l62.169"> </span>
<a href="#l62.170"></a><span id="l62.170">       let iPerSet = 0, folder = iterFolders.next();</span>
<a href="#l62.171"></a><span id="l62.171">       let didSomething;</span>
<a href="#l62.172"></a><span id="l62.172">       do {</span>
<a href="#l62.173"></a><span id="l62.173">         didSomething = false;</span>
<a href="#l62.174"></a><span id="l62.174" class="difflineminus">-        for each (let [, messageSet] in Iterator(aMessageSets)) {</span>
<a href="#l62.175"></a><span id="l62.175" class="difflineplus">+        for (let messageSet of aMessageSets) {</span>
<a href="#l62.176"></a><span id="l62.176">           if (iPerSet &lt; messageSet.synMessages.length) {</span>
<a href="#l62.177"></a><span id="l62.177">             didSomething = true;</span>
<a href="#l62.178"></a><span id="l62.178"> </span>
<a href="#l62.179"></a><span id="l62.179">             let realFolder = mis.handleUriToRealFolder[folder];</span>
<a href="#l62.180"></a><span id="l62.180">             let fakeFolder = mis.handleUriToFakeFolder[folder];</span>
<a href="#l62.181"></a><span id="l62.181">             let synMsg = messageSet._trackMessageAddition(realFolder, iPerSet);</span>
<a href="#l62.182"></a><span id="l62.182">             let msgURI =</span>
<a href="#l62.183"></a><span id="l62.183">               Services.io.newURI(&quot;data:text/plain;base64,&quot; +</span>
<a href="#l62.184"></a><span id="l62.184" class="difflineat">@@ -792,17 +793,17 @@ function add_sets_to_folders(aMsgFolders</span>
<a href="#l62.185"></a><span id="l62.185">     iterFolders = _looperator(aMsgFolders);</span>
<a href="#l62.186"></a><span id="l62.186"> </span>
<a href="#l62.187"></a><span id="l62.187">     let iPerSet = 0, folder = iterFolders.next();</span>
<a href="#l62.188"></a><span id="l62.188">     // loop, incrementing our subscript until all message sets are out of messages</span>
<a href="#l62.189"></a><span id="l62.189">     let didSomething;</span>
<a href="#l62.190"></a><span id="l62.190">     do {</span>
<a href="#l62.191"></a><span id="l62.191">       didSomething = false;</span>
<a href="#l62.192"></a><span id="l62.192">       // for each message set, if it is not out of messages, add the message</span>
<a href="#l62.193"></a><span id="l62.193" class="difflineminus">-      for each (let [, messageSet] in Iterator(aMessageSets)) {</span>
<a href="#l62.194"></a><span id="l62.194" class="difflineplus">+      for (let messageSet of aMessageSets) {</span>
<a href="#l62.195"></a><span id="l62.195">         if (iPerSet &lt; messageSet.synMessages.length) {</span>
<a href="#l62.196"></a><span id="l62.196">           popMessages.push(messageSet._trackMessageAddition(folder, iPerSet));</span>
<a href="#l62.197"></a><span id="l62.197">           didSomething = true;</span>
<a href="#l62.198"></a><span id="l62.198">         }</span>
<a href="#l62.199"></a><span id="l62.199">       }</span>
<a href="#l62.200"></a><span id="l62.200">       iPerSet++;</span>
<a href="#l62.201"></a><span id="l62.201">       folder = iterFolders.next();</span>
<a href="#l62.202"></a><span id="l62.202">     } while (didSomething);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l63.1"></a><span id="l63.1" class="difflineminus">--- a/mailnews/test/resources/messageModifier.js</span>
<a href="#l63.2"></a><span id="l63.2" class="difflineplus">+++ b/mailnews/test/resources/messageModifier.js</span>
<a href="#l63.3"></a><span id="l63.3" class="difflineat">@@ -16,17 +16,17 @@ Components.utils.import(&quot;resource:///mod</span>
<a href="#l63.4"></a><span id="l63.4">  *  mutations of the messages (in their folders) for testing purposes.</span>
<a href="#l63.5"></a><span id="l63.5">  *</span>
<a href="#l63.6"></a><span id="l63.6">  * In general, you would create a synthetic message set by passing in only a</span>
<a href="#l63.7"></a><span id="l63.7">  *  list of synthetic messages, and then add then messages to nsIMsgFolders by</span>
<a href="#l63.8"></a><span id="l63.8">  *  using one of the addMessage* methods.  This will populate the aMsgFolders</span>
<a href="#l63.9"></a><span id="l63.9">  *  and aFolderIndices values.  (They are primarily intended for reasons of</span>
<a href="#l63.10"></a><span id="l63.10">  *  slicing, but people who know what they are doing can also use them.)</span>
<a href="#l63.11"></a><span id="l63.11">  *</span>
<a href="#l63.12"></a><span id="l63.12" class="difflineminus">- * @param aSynMessage The synthetic messages that should belong to this set.</span>
<a href="#l63.13"></a><span id="l63.13" class="difflineplus">+ * @param aSynMessages The synthetic messages that should belong to this set.</span>
<a href="#l63.14"></a><span id="l63.14">  * @param aMsgFolders Optional nsIMsgDBFolder or list of folders.</span>
<a href="#l63.15"></a><span id="l63.15">  * @param aFolderIndices Optional list where each value is an index into the</span>
<a href="#l63.16"></a><span id="l63.16">  *     msgFolders attribute, specifying what folder the message can be found</span>
<a href="#l63.17"></a><span id="l63.17">  *     in.  The value may also be null if the message has not yet been</span>
<a href="#l63.18"></a><span id="l63.18">  *     inserted into a folder.</span>
<a href="#l63.19"></a><span id="l63.19">  */</span>
<a href="#l63.20"></a><span id="l63.20"> function SyntheticMessageSet(aSynMessages, aMsgFolders, aFolderIndices) {</span>
<a href="#l63.21"></a><span id="l63.21">   this.synMessages = aSynMessages;</span>
<a href="#l63.22"></a><span id="l63.22" class="difflineat">@@ -34,17 +34,17 @@ function SyntheticMessageSet(aSynMessage</span>
<a href="#l63.23"></a><span id="l63.23">   if (aMsgFolders == null)</span>
<a href="#l63.24"></a><span id="l63.24">     this.msgFolders = [];</span>
<a href="#l63.25"></a><span id="l63.25">   else if (!('length' in aMsgFolders))</span>
<a href="#l63.26"></a><span id="l63.26">     this.msgFolders = [aMsgFolders];</span>
<a href="#l63.27"></a><span id="l63.27">   else</span>
<a href="#l63.28"></a><span id="l63.28">     this.msgFolders = aMsgFolders;</span>
<a href="#l63.29"></a><span id="l63.29"> </span>
<a href="#l63.30"></a><span id="l63.30">   if (aFolderIndices == null)</span>
<a href="#l63.31"></a><span id="l63.31" class="difflineminus">-    this.folderIndices = [null for each (blah in Iterator(aSynMessages))];</span>
<a href="#l63.32"></a><span id="l63.32" class="difflineplus">+    this.folderIndices = aSynMessages.map(_ =&gt; null);</span>
<a href="#l63.33"></a><span id="l63.33">   else</span>
<a href="#l63.34"></a><span id="l63.34">     this.folderIndices = aFolderIndices;</span>
<a href="#l63.35"></a><span id="l63.35"> }</span>
<a href="#l63.36"></a><span id="l63.36"> SyntheticMessageSet.prototype = {</span>
<a href="#l63.37"></a><span id="l63.37">   /**</span>
<a href="#l63.38"></a><span id="l63.38">    * Helper method for messageInjection to use to tell us it is injecting a</span>
<a href="#l63.39"></a><span id="l63.39">    *  message in a given folder.  As a convenience, we also return the</span>
<a href="#l63.40"></a><span id="l63.40">    *  synthetic message.</span>
<a href="#l63.41"></a><span id="l63.41" class="difflineat">@@ -75,17 +75,17 @@ SyntheticMessageSet.prototype = {</span>
<a href="#l63.42"></a><span id="l63.42">    *     the other set.</span>
<a href="#l63.43"></a><span id="l63.43">    */</span>
<a href="#l63.44"></a><span id="l63.44">   union: function(aOtherSet) {</span>
<a href="#l63.45"></a><span id="l63.45">     let messages = this.synMessages.concat(aOtherSet.synMessages);</span>
<a href="#l63.46"></a><span id="l63.46">     let folders = this.msgFolders.concat();</span>
<a href="#l63.47"></a><span id="l63.47">     let indices = this.folderIndices.concat();</span>
<a href="#l63.48"></a><span id="l63.48"> </span>
<a href="#l63.49"></a><span id="l63.49">     let folderUrisToIndices = {};</span>
<a href="#l63.50"></a><span id="l63.50" class="difflineminus">-    for each (let [iFolder, folder] in Iterator(this.msgFolders)) {</span>
<a href="#l63.51"></a><span id="l63.51" class="difflineplus">+    for (let [iFolder, folder] of this.msgFolders.entries()) {</span>
<a href="#l63.52"></a><span id="l63.52">       folderUrisToIndices[folder.URI] = iFolder;</span>
<a href="#l63.53"></a><span id="l63.53">     }</span>
<a href="#l63.54"></a><span id="l63.54"> </span>
<a href="#l63.55"></a><span id="l63.55">     for (let iOther = 0; iOther &lt; aOtherSet.synMessages.length; iOther++) {</span>
<a href="#l63.56"></a><span id="l63.56">       let folderIndex = aOtherSet.folderIndices[iOther];</span>
<a href="#l63.57"></a><span id="l63.57">       if (folderIndex == null) {</span>
<a href="#l63.58"></a><span id="l63.58">         indices.push(folderIndex);</span>
<a href="#l63.59"></a><span id="l63.59">       }</span>
<a href="#l63.60"></a><span id="l63.60" class="difflineat">@@ -121,47 +121,45 @@ SyntheticMessageSet.prototype = {</span>
<a href="#l63.61"></a><span id="l63.61">   },</span>
<a href="#l63.62"></a><span id="l63.62"> </span>
<a href="#l63.63"></a><span id="l63.63">   /**</span>
<a href="#l63.64"></a><span id="l63.64">    * @return a JS iterator of the message headers for all messages inserted into</span>
<a href="#l63.65"></a><span id="l63.65">    *     a folder.</span>
<a href="#l63.66"></a><span id="l63.66">    */</span>
<a href="#l63.67"></a><span id="l63.67">   get msgHdrs() {</span>
<a href="#l63.68"></a><span id="l63.68">     // get the databases</span>
<a href="#l63.69"></a><span id="l63.69" class="difflineminus">-    let msgDatabases = [folder.msgDatabase for each</span>
<a href="#l63.70"></a><span id="l63.70" class="difflineminus">-                        ([, folder] in Iterator(this.msgFolders))];</span>
<a href="#l63.71"></a><span id="l63.71" class="difflineplus">+    let msgDatabases = this.msgFolders.map(folder =&gt; folder.msgDatabase);</span>
<a href="#l63.72"></a><span id="l63.72">     for (let [iMsg, synMsg] in Iterator(this.synMessages)) {</span>
<a href="#l63.73"></a><span id="l63.73">       let folderIndex = this.folderIndices[iMsg];</span>
<a href="#l63.74"></a><span id="l63.74">       if (folderIndex != null)</span>
<a href="#l63.75"></a><span id="l63.75">         yield msgDatabases[folderIndex].getMsgHdrForMessageID(synMsg.messageId);</span>
<a href="#l63.76"></a><span id="l63.76">     }</span>
<a href="#l63.77"></a><span id="l63.77">   },</span>
<a href="#l63.78"></a><span id="l63.78">   /**</span>
<a href="#l63.79"></a><span id="l63.79">    * @return a JS list of the message headers for all messages inserted into a</span>
<a href="#l63.80"></a><span id="l63.80">    *     folder.</span>
<a href="#l63.81"></a><span id="l63.81">    */</span>
<a href="#l63.82"></a><span id="l63.82">   get msgHdrList() {</span>
<a href="#l63.83"></a><span id="l63.83" class="difflineminus">-    return [msgHdr for each (msgHdr in this.msgHdrs)];</span>
<a href="#l63.84"></a><span id="l63.84" class="difflineplus">+    return Array.from(this.msgHdrs);</span>
<a href="#l63.85"></a><span id="l63.85">   },</span>
<a href="#l63.86"></a><span id="l63.86">   /**</span>
<a href="#l63.87"></a><span id="l63.87">    * @return an nsIMutableArray of the message headers for all messages inserted</span>
<a href="#l63.88"></a><span id="l63.88">    *     into a folder.</span>
<a href="#l63.89"></a><span id="l63.89">    */</span>
<a href="#l63.90"></a><span id="l63.90">   get xpcomHdrArray() {</span>
<a href="#l63.91"></a><span id="l63.91">     return toXPCOMArray(this.msgHdrs,</span>
<a href="#l63.92"></a><span id="l63.92">                         Components.interfaces.nsIMutableArray);</span>
<a href="#l63.93"></a><span id="l63.93">   },</span>
<a href="#l63.94"></a><span id="l63.94">   /**</span>
<a href="#l63.95"></a><span id="l63.95">    * @return a list where each item is a list with two elements; the first is</span>
<a href="#l63.96"></a><span id="l63.96">    *     an nsIMsgFolder, and the second is a list of all of the nsIMsgDBHdrs</span>
<a href="#l63.97"></a><span id="l63.97">    *     for the synthetic messages in the set inserted into that folder.</span>
<a href="#l63.98"></a><span id="l63.98">    */</span>
<a href="#l63.99"></a><span id="l63.99">   get foldersWithMsgHdrs() {</span>
<a href="#l63.100"></a><span id="l63.100" class="difflineminus">-    let results = [[folder, []] for each</span>
<a href="#l63.101"></a><span id="l63.101" class="difflineminus">-                   ([, folder] in Iterator(this.msgFolders))];</span>
<a href="#l63.102"></a><span id="l63.102" class="difflineplus">+    let results = this.msgFolders.map(folder =&gt; [folder, []]);</span>
<a href="#l63.103"></a><span id="l63.103">     for (let [iMsg, synMsg] in Iterator(this.synMessages)) {</span>
<a href="#l63.104"></a><span id="l63.104">       let folderIndex = this.folderIndices[iMsg];</span>
<a href="#l63.105"></a><span id="l63.105">       if (folderIndex != null) {</span>
<a href="#l63.106"></a><span id="l63.106">         let [folder, msgHdrs] = results[folderIndex];</span>
<a href="#l63.107"></a><span id="l63.107">         msgHdrs.push(folder.msgDatabase.getMsgHdrForMessageID(synMsg.messageId));</span>
<a href="#l63.108"></a><span id="l63.108">       }</span>
<a href="#l63.109"></a><span id="l63.109">     }</span>
<a href="#l63.110"></a><span id="l63.110">     return results;</span>
<a href="#l63.111"></a><span id="l63.111" class="difflineat">@@ -185,17 +183,17 @@ SyntheticMessageSet.prototype = {</span>
<a href="#l63.112"></a><span id="l63.112">    */</span>
<a href="#l63.113"></a><span id="l63.113">   setRead: function(aRead, aMsgHdr) {</span>
<a href="#l63.114"></a><span id="l63.114">     let msgHdrs = aMsgHdr ? [aMsgHdr] : this.msgHdrList;</span>
<a href="#l63.115"></a><span id="l63.115">     for (let msgHdr of msgHdrs) {</span>
<a href="#l63.116"></a><span id="l63.116">       msgHdr.markRead(aRead);</span>
<a href="#l63.117"></a><span id="l63.117">     }</span>
<a href="#l63.118"></a><span id="l63.118">   },</span>
<a href="#l63.119"></a><span id="l63.119">   setStarred: function(aStarred) {</span>
<a href="#l63.120"></a><span id="l63.120" class="difflineminus">-    for each (let msgHdr in this.msgHdrs) {</span>
<a href="#l63.121"></a><span id="l63.121" class="difflineplus">+    for (let msgHdr of this.msgHdrs) {</span>
<a href="#l63.122"></a><span id="l63.122">       msgHdr.markFlagged(aStarred);</span>
<a href="#l63.123"></a><span id="l63.123">     }</span>
<a href="#l63.124"></a><span id="l63.124">   },</span>
<a href="#l63.125"></a><span id="l63.125">   addTag: function(aTagName) {</span>
<a href="#l63.126"></a><span id="l63.126">     for (let [folder, xpcomHdrArray] in this.foldersWithXpcomHdrArrays) {</span>
<a href="#l63.127"></a><span id="l63.127">       folder.addKeywordsToMessages(xpcomHdrArray, aTagName);</span>
<a href="#l63.128"></a><span id="l63.128">     }</span>
<a href="#l63.129"></a><span id="l63.129">   },</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

