<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 915:2e3d9c3f370daab3329312f381ce6deaa7df3855</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 2e3d9c3f370daab3329312f381ce6deaa7df3855" />
<meta property="og:url" content="/comm-central/rev/2e3d9c3f370daab3329312f381ce6deaa7df3855" />
<meta property="og:description" content="rewrite to use async statements for all writes.  passes existing unit tests," />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 2e3d9c3f370daab3329312f381ce6deaa7df3855 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/2e3d9c3f370daab3329312f381ce6deaa7df3855">shortlog</a> |
<a href="/comm-central/log/2e3d9c3f370daab3329312f381ce6deaa7df3855">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/2e3d9c3f370daab3329312f381ce6deaa7df3855">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/2e3d9c3f370daab3329312f381ce6deaa7df3855">files</a> |
changeset |
<a href="/comm-central/raw-rev/2e3d9c3f370daab3329312f381ce6deaa7df3855">raw</a>  | <a href="/comm-central/archive/2e3d9c3f370daab3329312f381ce6deaa7df3855.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
rewrite to use async statements for all writes.  passes existing unit tests,
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 12 Sep 2008 16:24:31 -0700</td></tr>

<tr>
 <td>changeset 915</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/2e3d9c3f370daab3329312f381ce6deaa7df3855">2e3d9c3f370daab3329312f381ce6deaa7df3855</a></td>
</tr>



<tr>
<td>parent 914</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/3ac64fe0567b461f305e9f63419afb4298a790a1">3ac64fe0567b461f305e9f63419afb4298a790a1</a>
</td>
</tr>

<tr>
<td>child 916</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/0cd3d3cb5be3779a04188924d894ff70f0bf36f2">0cd3d3cb5be3779a04188924d894ff70f0bf36f2</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=2e3d9c3f370daab3329312f381ce6deaa7df3855">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">rewrite to use async statements for all writes.  passes existing unit tests,
but I probably need to add some query unit tests...</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/collection.js">file</a> |
<a href="/comm-central/annotate/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/collection.js">comparison</a> |
<a href="/comm-central/log/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/query.js">modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/query.js">file</a> |
<a href="/comm-central/annotate/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/query.js">annotate</a> |
<a href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/query.js">diff</a> |
<a href="/comm-central/comparison/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/query.js">comparison</a> |
<a href="/comm-central/log/2e3d9c3f370daab3329312f381ce6deaa7df3855/modules/query.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/resources/glodaTestHelper.js">test/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/unit/test_index_messages.js">test/unit/test_index_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/unit/test_index_messages.js">file</a> |
<a href="/comm-central/annotate/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/unit/test_index_messages.js">annotate</a> |
<a href="/comm-central/diff/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/unit/test_index_messages.js">diff</a> |
<a href="/comm-central/comparison/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/unit/test_index_messages.js">comparison</a> |
<a href="/comm-central/log/2e3d9c3f370daab3329312f381ce6deaa7df3855/test/unit/test_index_messages.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -145,18 +145,21 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4"> </span>
<a href="#l1.5"></a><span id="l1.5">   /**</span>
<a href="#l1.6"></a><span id="l1.6">    * Given a list of items, check if any of them already have duplicate,</span>
<a href="#l1.7"></a><span id="l1.7">    *  canonical, instances in the cache or collections.  Items with pre-existing</span>
<a href="#l1.8"></a><span id="l1.8">    *  instances are replaced by those instances in the provided list, and each</span>
<a href="#l1.9"></a><span id="l1.9">    *  counts as a cache hit.  Items without pre-existing instances are added</span>
<a href="#l1.10"></a><span id="l1.10">    *  to the cache and left intact.</span>
<a href="#l1.11"></a><span id="l1.11">    */</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  cacheLoadUnify: function gloda_colm_cacheLoadUnify(aNounID, aItems) {</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  cacheLoadUnify: function gloda_colm_cacheLoadUnify(aNounID, aItems,</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+      aCacheIfMissing) {</span>
<a href="#l1.15"></a><span id="l1.15">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+    if (aCacheIfMissing === undefined)</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+      aCacheIfMissing = true; </span>
<a href="#l1.18"></a><span id="l1.18">     </span>
<a href="#l1.19"></a><span id="l1.19">     // track the items we haven't yet found in a cache/collection (value) and</span>
<a href="#l1.20"></a><span id="l1.20">     //  their index in aItems (key).  We're somewhat abusing the dictionary</span>
<a href="#l1.21"></a><span id="l1.21">     //  metaphor with the intent of storing tuples here.  We also do it because</span>
<a href="#l1.22"></a><span id="l1.22">     //  it allows random-access deletion theoretically without cost.  (Since</span>
<a href="#l1.23"></a><span id="l1.23">     //  we delete during iteration, that may be wrong, but it sounds like the</span>
<a href="#l1.24"></a><span id="l1.24">     //  semantics still work?)</span>
<a href="#l1.25"></a><span id="l1.25">     let unresolvedIndexToItem = {};</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineat">@@ -203,19 +206,19 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l1.27"></a><span id="l1.27">           delete unresolvedIndexToItem[iItem];</span>
<a href="#l1.28"></a><span id="l1.28">           // stop checking collections if we got everybody</span>
<a href="#l1.29"></a><span id="l1.29">           if (--numUnresolved == 0)</span>
<a href="#l1.30"></a><span id="l1.30">             break;</span>
<a href="#l1.31"></a><span id="l1.31">         }</span>
<a href="#l1.32"></a><span id="l1.32">       }</span>
<a href="#l1.33"></a><span id="l1.33">     }</span>
<a href="#l1.34"></a><span id="l1.34">     </span>
<a href="#l1.35"></a><span id="l1.35" class="difflineminus">-    // anything left in unresolvedIndexToItem should be added to the cache...</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineminus">-    // plus, we already have 'needToCache'</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-    if (cache) {</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+    // anything left in unresolvedIndexToItem should be added to the cache</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+    //  unless !aCacheIfMissing.  plus, we already have 'needToCache'</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+    if (cache &amp;&amp; aCacheIfMissing) {</span>
<a href="#l1.41"></a><span id="l1.41">       cache.add(needToCache.concat([val for each</span>
<a href="#l1.42"></a><span id="l1.42">                                     (val in unresolvedIndexToItem)]));</span>
<a href="#l1.43"></a><span id="l1.43">     }</span>
<a href="#l1.44"></a><span id="l1.44">     </span>
<a href="#l1.45"></a><span id="l1.45">     return aItems;</span>
<a href="#l1.46"></a><span id="l1.46">   },</span>
<a href="#l1.47"></a><span id="l1.47">   </span>
<a href="#l1.48"></a><span id="l1.48">   cacheCommitDirty: function glod_colm_cacheCommitDirty() {</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineat">@@ -354,36 +357,36 @@ GlodaCollection.prototype = {</span>
<a href="#l1.50"></a><span id="l1.50">   set listener(aListener) { this._listener = aListener; },</span>
<a href="#l1.51"></a><span id="l1.51">   </span>
<a href="#l1.52"></a><span id="l1.52">   /**</span>
<a href="#l1.53"></a><span id="l1.53">    * Clear the contents of this collection.  This only makes sense for explicit</span>
<a href="#l1.54"></a><span id="l1.54">    *  collections or wildcard collections.  (Actual query-based collections</span>
<a href="#l1.55"></a><span id="l1.55">    *  should represent the state of the query, so unless we're going to delete</span>
<a href="#l1.56"></a><span id="l1.56">    *  all the items, clearing the collection would violate that constraint.)</span>
<a href="#l1.57"></a><span id="l1.57">    */</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineminus">-  clear: function() {</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+  clear: function gloda_coll_clear() {</span>
<a href="#l1.60"></a><span id="l1.60">     this._idMap = {};</span>
<a href="#l1.61"></a><span id="l1.61">     this.items = [];</span>
<a href="#l1.62"></a><span id="l1.62">   },</span>
<a href="#l1.63"></a><span id="l1.63"> </span>
<a href="#l1.64"></a><span id="l1.64" class="difflineminus">-  _onItemsAdded: function(aItems) {</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+  _onItemsAdded: function gloda_coll_onItemsAdded(aItems) {</span>
<a href="#l1.66"></a><span id="l1.66">     this.items.push.apply(this.items, aItems);</span>
<a href="#l1.67"></a><span id="l1.67">     for each (item in aItems) {</span>
<a href="#l1.68"></a><span id="l1.68">       this._idMap[item.id] = item;</span>
<a href="#l1.69"></a><span id="l1.69">     }</span>
<a href="#l1.70"></a><span id="l1.70">     if (this._listener)</span>
<a href="#l1.71"></a><span id="l1.71">       this._listener.onItemsAdded(aItems);</span>
<a href="#l1.72"></a><span id="l1.72">   },</span>
<a href="#l1.73"></a><span id="l1.73">   </span>
<a href="#l1.74"></a><span id="l1.74" class="difflineminus">-  _onItemsModified: function(aItems) {</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+  _onItemsModified: function gloda_coll_onItemsModified(aItems) {</span>
<a href="#l1.76"></a><span id="l1.76">     if (this._listener)</span>
<a href="#l1.77"></a><span id="l1.77">       this._listener.onItemsModified(aItems);</span>
<a href="#l1.78"></a><span id="l1.78">   },</span>
<a href="#l1.79"></a><span id="l1.79">   </span>
<a href="#l1.80"></a><span id="l1.80" class="difflineminus">-  _onItemsRemoved: function(aItems) {</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+  _onItemsRemoved: function gloda_coll_onItemsRemoved(aItems) {</span>
<a href="#l1.82"></a><span id="l1.82">     // we want to avoid the O(n^2) deletion performance case, and deletion</span>
<a href="#l1.83"></a><span id="l1.83">     //  should be rare enough that the extra cost of building the deletion map</span>
<a href="#l1.84"></a><span id="l1.84">     //  should never be a real problem.</span>
<a href="#l1.85"></a><span id="l1.85">     let deleteMap = {};</span>
<a href="#l1.86"></a><span id="l1.86">     for each (let item in aItems) {</span>
<a href="#l1.87"></a><span id="l1.87">       deleteMap[item.id] = true;</span>
<a href="#l1.88"></a><span id="l1.88">     }</span>
<a href="#l1.89"></a><span id="l1.89">     let items = this.items;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -177,16 +177,21 @@ function GlodaConversation(aDatastore, a</span>
<a href="#l2.4"></a><span id="l2.4"> </span>
<a href="#l2.5"></a><span id="l2.5"> GlodaConversation.prototype = {</span>
<a href="#l2.6"></a><span id="l2.6">   NOUN_ID: 101,</span>
<a href="#l2.7"></a><span id="l2.7">   get id() { return this._id; },</span>
<a href="#l2.8"></a><span id="l2.8">   get subject() { return this._subject; },</span>
<a href="#l2.9"></a><span id="l2.9">   get oldestMessageDate() { return this._oldestMessageDate; },</span>
<a href="#l2.10"></a><span id="l2.10">   get newestMessageDate() { return this._newestMessageDate; },</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+  /**</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+   * @TODO Return the collection of messages belonging to this conversation.</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+   * (And weakly store a reference to the collection.  Once the user is rid of</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+   *  it, we really don't care.)</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+   */</span>
<a href="#l2.17"></a><span id="l2.17">   get messages() {</span>
<a href="#l2.18"></a><span id="l2.18">     if (this._messages == null) {</span>
<a href="#l2.19"></a><span id="l2.19">       this._messages = this._datastore.getMessagesByConversationID(this._id,</span>
<a href="#l2.20"></a><span id="l2.20">                                                                    false);</span>
<a href="#l2.21"></a><span id="l2.21">     }</span>
<a href="#l2.22"></a><span id="l2.22">     return this._messages;</span>
<a href="#l2.23"></a><span id="l2.23">   },</span>
<a href="#l2.24"></a><span id="l2.24">   </span>
<a href="#l2.25"></a><span id="l2.25" class="difflineat">@@ -222,17 +227,17 @@ GlodaMessage.prototype = {</span>
<a href="#l2.26"></a><span id="l2.26">   get folderID() { return this._folderID; },</span>
<a href="#l2.27"></a><span id="l2.27">   get messageKey() { return this._messageKey; },</span>
<a href="#l2.28"></a><span id="l2.28">   get conversationID() { return this._conversationID; },</span>
<a href="#l2.29"></a><span id="l2.29">   // conversation is special</span>
<a href="#l2.30"></a><span id="l2.30">   get headerMessageID() { return this._headerMessageID; },</span>
<a href="#l2.31"></a><span id="l2.31">   get bodySnippet() { return this._bodySnippet; },</span>
<a href="#l2.32"></a><span id="l2.32"> </span>
<a href="#l2.33"></a><span id="l2.33">   get folderURI() {</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineminus">-    if (this._folderID)</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+    if (this._folderID != null)</span>
<a href="#l2.36"></a><span id="l2.36">       return this._datastore._mapFolderID(this._folderID);</span>
<a href="#l2.37"></a><span id="l2.37">     else</span>
<a href="#l2.38"></a><span id="l2.38">       return null;</span>
<a href="#l2.39"></a><span id="l2.39">   },</span>
<a href="#l2.40"></a><span id="l2.40">   get conversation() {</span>
<a href="#l2.41"></a><span id="l2.41">     if (this._conversation == null) {</span>
<a href="#l2.42"></a><span id="l2.42">       this._conversation = this._datastore.getConversationByID(</span>
<a href="#l2.43"></a><span id="l2.43">         this._conversationID);</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineat">@@ -355,16 +360,19 @@ GlodaMessage.prototype = {</span>
<a href="#l2.45"></a><span id="l2.45">    *  everything anew.  This is arguably wasteful; it might be better to go</span>
<a href="#l2.46"></a><span id="l2.46">    *  back to just using storage properties, possibly on a sub-object that</span>
<a href="#l2.47"></a><span id="l2.47">    *  we could just replace with a new one...</span>
<a href="#l2.48"></a><span id="l2.48">    * Note: We actually avoid doing this if the attributes weren't previously</span>
<a href="#l2.49"></a><span id="l2.49">    *  fetched.  Of course, since we do set _attributes with these new</span>
<a href="#l2.50"></a><span id="l2.50">    *  attributes, this check does not steady-state.</span>
<a href="#l2.51"></a><span id="l2.51">    *</span>
<a href="#l2.52"></a><span id="l2.52">    * @XXX Try and avoid compelling ourselves to cache every bound attribute.</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+   *  (If we stored the cached values in a sub-object, we could just trash the</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineplus">+   *   sub-object.  This would imply a return to having the getters just create</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+   *   a storage field rather than creating magic getters.)</span>
<a href="#l2.56"></a><span id="l2.56">    */</span>
<a href="#l2.57"></a><span id="l2.57">   _replaceAttributes: function gloda_message_replaceAttributes(aNewAttribs) {</span>
<a href="#l2.58"></a><span id="l2.58">     let hadAttributes = this._attributes !== null;</span>
<a href="#l2.59"></a><span id="l2.59">     this._attributes = aNewAttribs;</span>
<a href="#l2.60"></a><span id="l2.60">     // if this guy didn't already have attributes, we don't actually need to</span>
<a href="#l2.61"></a><span id="l2.61">     //  do any caching work.</span>
<a href="#l2.62"></a><span id="l2.62">     if (!hadAttributes)</span>
<a href="#l2.63"></a><span id="l2.63">       return;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -54,16 +54,110 @@ Cu.import(&quot;resource://gloda/modules/data</span>
<a href="#l3.4"></a><span id="l3.4"> Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l3.5"></a><span id="l3.5"> </span>
<a href="#l3.6"></a><span id="l3.6"> // XXX from Gloda.js.  duplicated here for dependency reasons.  bad!</span>
<a href="#l3.7"></a><span id="l3.7"> const kSpecialColumn = 1;</span>
<a href="#l3.8"></a><span id="l3.8"> const kSpecialString = 2;</span>
<a href="#l3.9"></a><span id="l3.9"> const kSpecialFulltext = 3;</span>
<a href="#l3.10"></a><span id="l3.10"> </span>
<a href="#l3.11"></a><span id="l3.11"> /**</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+ * This callback handles processing the asynchronous query results of</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+ *  GlodaDatastore.getMessagesByMessageID.  Because that method is only</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+ *  called as part of the indexing process, we are guaranteed that there will</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+ *  be no real caching ramifications.  Accordingly, we can also defer our cache</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+ *  processing (via GlodaCollectionManager) until the query completes.</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+ *</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+ * @param aMsgIDToIndex Map from message-id to the desired   </span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+ */</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+function MessagesByMessageIdCallback(aStatement, aMsgIDToIndex, aResults,</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+                                     aCallback, aCallbackThis, aCallbackArgs) {</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+  this.statement = aStatement;</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+  this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+  this.results = aResults;</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+  this.callback = aCallback;</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+  this.callbackThis = aCallbackThis;</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineplus">+  this.callbackArgs = aCallbackArgs;</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+}</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+MessagesByMessageIdCallback.prototype = {</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+  handleResult: function gloda_ds_mbmi_handleResult(aResultSet) {</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+    let row;</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+    while (row = aResultSet.getNextRow()) {</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+      let message = GlodaDatastore._messageFromRow(row);</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+      this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+    }</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+  },</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+  </span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+  handleError: function gloda_ds_mbmi_handleError(aError) {</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+    GlodaDatastore._log.error(&quot;Async getMessagesByMessageId error: &quot; +</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+      aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+  },</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+  </span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+  handleCompletion: function gloda_ds_mbmi_handleCompletion(aReason) {</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+    for (let iResult=0; iResult &lt; this.results.length; iResult++) {</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+      if (this.results[iResult].length)</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+        GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+                                              this.results[iResult]);</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+    }</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+    let args = [this.results].concat(this.callbackArgs);</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+    this.statement.finalize();</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+    this.statement = null;</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+    this.callback.apply(this.callbackThis, args);</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+  }</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+};</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+function QueryFromQueryCallback(aStatement, aNounMeta, aCollection) {</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+  this.statement = aStatement;</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+  this.nounMeta = aNounMeta;</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+  this.collection = aCollection;</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+}</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+QueryFromQueryCallback.prototype = {</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+  handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+    let newItems = [];</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+    let row;</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+    let nounMeta = this.nounMeta;</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+    while (row = aResultSet.getNextRow()) {</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+      let item = nounMeta.objFromRow.call(nounMeta.datastore, statement);</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+      newItems.push(item);</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+    }</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+    // have the collection manager attempt to replace the instances we just</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+    //  created with pre-existing instances.  there is some waste here...</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+    // XXX consider having collection manager take row objects with the</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+    //  knowledge of what index is the 'id' index and knowing what objFromRow</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+    //  method to call if it needs to realize the row.</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+    // queries have the potential to easily exceed the size of our cache, and</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+    //  will cause needless churn if so.  as such, indicate that we never want</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+    //  to have our items added to the cache.  after all, as long as our</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+    //  collection is alive, they can just be found there anyways.  (and when</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+    //  found there, they may be promoted to the cache anyways.)    </span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+    GlodaCollectionManager.cacheLoadUnify(nounMeta.id, newItems, false);</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineplus">+    </span>
<a href="#l3.87"></a><span id="l3.87" class="difflineplus">+    // just directly tell the collection about the items.  we know the query</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+    //  matches (at least until we introduce predicates that we cannot express</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+    //  in SQL.)</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+    this.collection._onItemsAdded(newItems);</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+  },</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+  </span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+  handleError: function gloda_ds_qfq_handleError(aError) {</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+    GlodaDatastore._log.error(&quot;Async queryFromQuery error: &quot; +</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+      aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+  },</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+  </span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+  handleCompletion: function gloda_ds_qfq_handleCompletion(aReason) {</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+    this.statement.finalize();</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+    this.statement = null;</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+  }</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+};</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+/**</span>
<a href="#l3.106"></a><span id="l3.106">  * Database abstraction layer.  Contains explicit SQL schemas for our</span>
<a href="#l3.107"></a><span id="l3.107">  *  fundamental representations (core 'nouns', if you will) as well as</span>
<a href="#l3.108"></a><span id="l3.108">  *  specialized functions for then dealing with each type of object.  At the</span>
<a href="#l3.109"></a><span id="l3.109">  *  same time, we are beginning to support extension-provided tables, which</span>
<a href="#l3.110"></a><span id="l3.110">  *  call into question whether we really need our hand-rolled code, or could</span>
<a href="#l3.111"></a><span id="l3.111">  *  simply improve the extension-provided table case to work for most of our</span>
<a href="#l3.112"></a><span id="l3.112">  *  hand-rolled cases.</span>
<a href="#l3.113"></a><span id="l3.113">  * For now, the argument can probably be made that our explicit schemas and code</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineat">@@ -156,28 +250,28 @@ let GlodaDatastore = {</span>
<a href="#l3.115"></a><span id="l3.115">   _schemaVersion: 5,</span>
<a href="#l3.116"></a><span id="l3.116">   _schema: {</span>
<a href="#l3.117"></a><span id="l3.117">     tables: {</span>
<a href="#l3.118"></a><span id="l3.118">       </span>
<a href="#l3.119"></a><span id="l3.119">       // ----- Messages</span>
<a href="#l3.120"></a><span id="l3.120">       folderLocations: {</span>
<a href="#l3.121"></a><span id="l3.121">         columns: [</span>
<a href="#l3.122"></a><span id="l3.122">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l3.123"></a><span id="l3.123" class="difflineminus">-          &quot;folderURI TEXT&quot;,</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineplus">+          &quot;folderURI TEXT NOT NULL&quot;,</span>
<a href="#l3.125"></a><span id="l3.125">         ],</span>
<a href="#l3.126"></a><span id="l3.126">         </span>
<a href="#l3.127"></a><span id="l3.127">         triggers: {</span>
<a href="#l3.128"></a><span id="l3.128">           delete: &quot;DELETE from messages WHERE folderID = OLD.id&quot;,</span>
<a href="#l3.129"></a><span id="l3.129">         },</span>
<a href="#l3.130"></a><span id="l3.130">       },</span>
<a href="#l3.131"></a><span id="l3.131">       </span>
<a href="#l3.132"></a><span id="l3.132">       conversations: {</span>
<a href="#l3.133"></a><span id="l3.133">         columns: [</span>
<a href="#l3.134"></a><span id="l3.134">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l3.135"></a><span id="l3.135" class="difflineminus">-          &quot;subject TEXT&quot;,</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineplus">+          &quot;subject TEXT NOT NULL&quot;,</span>
<a href="#l3.137"></a><span id="l3.137">           &quot;oldestMessageDate INTEGER&quot;,</span>
<a href="#l3.138"></a><span id="l3.138">           &quot;newestMessageDate INTEGER&quot;,</span>
<a href="#l3.139"></a><span id="l3.139">         ],</span>
<a href="#l3.140"></a><span id="l3.140">         </span>
<a href="#l3.141"></a><span id="l3.141">         indices: {</span>
<a href="#l3.142"></a><span id="l3.142">           subject: ['subject'],</span>
<a href="#l3.143"></a><span id="l3.143">           oldestMessageDate: ['oldestMessageDate'],</span>
<a href="#l3.144"></a><span id="l3.144">           newestMessageDate: ['newestMessageDate'],</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineat">@@ -228,19 +322,19 @@ let GlodaDatastore = {</span>
<a href="#l3.146"></a><span id="l3.146">           delete: &quot;DELETE FROM messageAttributes WHERE messageID = OLD.id&quot;,</span>
<a href="#l3.147"></a><span id="l3.147">         },</span>
<a href="#l3.148"></a><span id="l3.148">       },</span>
<a href="#l3.149"></a><span id="l3.149">       </span>
<a href="#l3.150"></a><span id="l3.150">       // ----- Attributes</span>
<a href="#l3.151"></a><span id="l3.151">       attributeDefinitions: {</span>
<a href="#l3.152"></a><span id="l3.152">         columns: [</span>
<a href="#l3.153"></a><span id="l3.153">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineminus">-          &quot;attributeType INTEGER&quot;,</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineminus">-          &quot;extensionName TEXT&quot;,</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineminus">-          &quot;name TEXT&quot;,</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+          &quot;attributeType INTEGER NOT NULL&quot;,</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+          &quot;extensionName TEXT NOT NULL&quot;,</span>
<a href="#l3.159"></a><span id="l3.159" class="difflineplus">+          &quot;name TEXT NOT NULL&quot;,</span>
<a href="#l3.160"></a><span id="l3.160">           &quot;parameter BLOB&quot;,</span>
<a href="#l3.161"></a><span id="l3.161">         ],</span>
<a href="#l3.162"></a><span id="l3.162">         </span>
<a href="#l3.163"></a><span id="l3.163">         triggers: {</span>
<a href="#l3.164"></a><span id="l3.164">           delete: &quot;DELETE FROM messageAttributes WHERE attributeID = OLD.id&quot;,</span>
<a href="#l3.165"></a><span id="l3.165">         },</span>
<a href="#l3.166"></a><span id="l3.166">       },</span>
<a href="#l3.167"></a><span id="l3.167">       </span>
<a href="#l3.168"></a><span id="l3.168" class="difflineat">@@ -253,17 +347,17 @@ let GlodaDatastore = {</span>
<a href="#l3.169"></a><span id="l3.169">         ],</span>
<a href="#l3.170"></a><span id="l3.170">         </span>
<a href="#l3.171"></a><span id="l3.171">         indices: {</span>
<a href="#l3.172"></a><span id="l3.172">           attribQuery: [</span>
<a href="#l3.173"></a><span id="l3.173">             &quot;attributeID&quot;, &quot;value&quot;,</span>
<a href="#l3.174"></a><span id="l3.174">             /* covering: */ &quot;conversationID&quot;, &quot;messageID&quot;],</span>
<a href="#l3.175"></a><span id="l3.175">           messageAttribFetch: [</span>
<a href="#l3.176"></a><span id="l3.176">             &quot;messageID&quot;,</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineminus">-            /* covering: */ &quot;conversationID&quot;, &quot;messageID&quot;, &quot;value&quot;],</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+            /* covering required: */ &quot;attributeID&quot;, &quot;value&quot;],</span>
<a href="#l3.179"></a><span id="l3.179">           conversationAttribFetch: [</span>
<a href="#l3.180"></a><span id="l3.180">             &quot;conversationID&quot;,</span>
<a href="#l3.181"></a><span id="l3.181">             /* covering: */ &quot;messageID&quot;, &quot;attributeID&quot;, &quot;value&quot;],</span>
<a href="#l3.182"></a><span id="l3.182">         },</span>
<a href="#l3.183"></a><span id="l3.183">       },</span>
<a href="#l3.184"></a><span id="l3.184">     </span>
<a href="#l3.185"></a><span id="l3.185">       // ----- Contacts / Identities</span>
<a href="#l3.186"></a><span id="l3.186">     </span>
<a href="#l3.187"></a><span id="l3.187" class="difflineat">@@ -290,37 +384,49 @@ let GlodaDatastore = {</span>
<a href="#l3.188"></a><span id="l3.188">       </span>
<a href="#l3.189"></a><span id="l3.189">       /**</span>
<a href="#l3.190"></a><span id="l3.190">        * Identities correspond to specific e-mail addresses, IRC nicks, etc.</span>
<a href="#l3.191"></a><span id="l3.191">        */</span>
<a href="#l3.192"></a><span id="l3.192">       identities: {</span>
<a href="#l3.193"></a><span id="l3.193">         columns: [</span>
<a href="#l3.194"></a><span id="l3.194">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l3.195"></a><span id="l3.195">           &quot;contactID INTEGER NOT NULL REFERENCES contacts(id)&quot;,</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineminus">-          &quot;kind TEXT&quot;, // ex: email, irc, etc.</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineminus">-          &quot;value TEXT&quot;, // ex: e-mail address, irc nick/handle, etc.</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineminus">-          &quot;description TEXT&quot;, // what makes this identity different from the</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+          &quot;kind TEXT NOT NULL&quot;, // ex: email, irc, etc.</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+          &quot;value TEXT NOT NULL&quot;, // ex: e-mail address, irc nick/handle, etc.</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+          &quot;description NOT NULL&quot;, // what makes this identity different from the</span>
<a href="#l3.202"></a><span id="l3.202">           // others? (ex: home, work, etc.) </span>
<a href="#l3.203"></a><span id="l3.203" class="difflineminus">-          &quot;relay INTEGER&quot;, // is the identity just a relay mechanism?</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+          &quot;relay INTEGER NOT NULL&quot;, // is the identity just a relay mechanism?</span>
<a href="#l3.205"></a><span id="l3.205">           // (ex: mailing list, twitter 'bouncer', IRC gateway, etc.)</span>
<a href="#l3.206"></a><span id="l3.206">         ],</span>
<a href="#l3.207"></a><span id="l3.207">         </span>
<a href="#l3.208"></a><span id="l3.208">         indices: {</span>
<a href="#l3.209"></a><span id="l3.209">           contactQuery: [&quot;contactID&quot;],</span>
<a href="#l3.210"></a><span id="l3.210">           valueQuery: [&quot;kind&quot;, &quot;value&quot;]</span>
<a href="#l3.211"></a><span id="l3.211">         }</span>
<a href="#l3.212"></a><span id="l3.212">       },</span>
<a href="#l3.213"></a><span id="l3.213">       </span>
<a href="#l3.214"></a><span id="l3.214">       //identityAttributes: {</span>
<a href="#l3.215"></a><span id="l3.215">       //},</span>
<a href="#l3.216"></a><span id="l3.216">     </span>
<a href="#l3.217"></a><span id="l3.217">     },</span>
<a href="#l3.218"></a><span id="l3.218">   },</span>
<a href="#l3.219"></a><span id="l3.219"> </span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+</span>
<a href="#l3.221"></a><span id="l3.221">   /* ******************* LOGIC ******************* */</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+  /**</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineplus">+   * Our synchronous connection, primarily intended for read-only use, so as to</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineplus">+   *  avoid stepping on the toes of our asynchronous connection that will do</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineplus">+   *  most/all of our updating.</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineplus">+   */</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineplus">+  syncConnection: null,</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineplus">+  /**</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineplus">+   * Our connection reused for asynchronous usage, intended for database write</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineplus">+   *  purposes.</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineplus">+   */</span>
<a href="#l3.232"></a><span id="l3.232" class="difflineplus">+  asyncConnection: null,</span>
<a href="#l3.233"></a><span id="l3.233">   </span>
<a href="#l3.234"></a><span id="l3.234">   /**</span>
<a href="#l3.235"></a><span id="l3.235">    * Initialize logging, create the database if it doesn't exist, &quot;upgrade&quot; it</span>
<a href="#l3.236"></a><span id="l3.236">    *  if it does and it's not up-to-date, fill our authoritative folder uri/id</span>
<a href="#l3.237"></a><span id="l3.237">    *  mapping.</span>
<a href="#l3.238"></a><span id="l3.238">    */</span>
<a href="#l3.239"></a><span id="l3.239">   _init: function gloda_ds_init() {</span>
<a href="#l3.240"></a><span id="l3.240">     this._log = Log4Moz.Service.getLogger(&quot;gloda.datastore&quot;);</span>
<a href="#l3.241"></a><span id="l3.241" class="difflineat">@@ -353,19 +459,32 @@ let GlodaDatastore = {</span>
<a href="#l3.242"></a><span id="l3.242">                                        dbConnection.schemaVersion,</span>
<a href="#l3.243"></a><span id="l3.243">                                        this._schemaVersion);</span>
<a href="#l3.244"></a><span id="l3.244">         }</span>
<a href="#l3.245"></a><span id="l3.245">       }</span>
<a href="#l3.246"></a><span id="l3.246">       // Handle corrupt databases, other oddities</span>
<a href="#l3.247"></a><span id="l3.247">       // ... in the future. for now, let us die</span>
<a href="#l3.248"></a><span id="l3.248">     }</span>
<a href="#l3.249"></a><span id="l3.249">     </span>
<a href="#l3.250"></a><span id="l3.250" class="difflineminus">-    this.dbConnection = dbConnection;</span>
<a href="#l3.251"></a><span id="l3.251" class="difflineplus">+    this.syncConnection = dbConnection;</span>
<a href="#l3.252"></a><span id="l3.252" class="difflineplus">+    this.asyncConnection = dbService.openUnsharedDatabase(dbFile);</span>
<a href="#l3.253"></a><span id="l3.253">     </span>
<a href="#l3.254"></a><span id="l3.254">     this._getAllFolderMappings();</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineplus">+    // we need to figure out the next id's for all of the tables where we</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineplus">+    //  manage that.</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineplus">+    this._populateAttributeDefManagedId();</span>
<a href="#l3.258"></a><span id="l3.258" class="difflineplus">+    this._populateConversationManagedId();</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineplus">+    this._populateMessageManagedId();</span>
<a href="#l3.260"></a><span id="l3.260" class="difflineplus">+    this._populateContactManagedId();</span>
<a href="#l3.261"></a><span id="l3.261" class="difflineplus">+    this._populateIdentityManagedId();</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineplus">+  },</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineplus">+  </span>
<a href="#l3.264"></a><span id="l3.264" class="difflineplus">+  shutdown: function gloda_ds_shutdown() {</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineplus">+    this._cleanupAsyncStatements();</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineplus">+    this._cleanupSyncStatements();</span>
<a href="#l3.267"></a><span id="l3.267">   },</span>
<a href="#l3.268"></a><span id="l3.268">   </span>
<a href="#l3.269"></a><span id="l3.269">   /**</span>
<a href="#l3.270"></a><span id="l3.270">    * Create our database; basically a wrapper around _createSchema.</span>
<a href="#l3.271"></a><span id="l3.271">    */</span>
<a href="#l3.272"></a><span id="l3.272">   _createDB: function gloda_ds_createDB(aDBService, aDBFile) {</span>
<a href="#l3.273"></a><span id="l3.273">     var dbConnection = aDBService.openUnsharedDatabase(aDBFile);</span>
<a href="#l3.274"></a><span id="l3.274">     </span>
<a href="#l3.275"></a><span id="l3.275" class="difflineat">@@ -419,218 +538,308 @@ let GlodaDatastore = {</span>
<a href="#l3.276"></a><span id="l3.276">   </span>
<a href="#l3.277"></a><span id="l3.277">   /**</span>
<a href="#l3.278"></a><span id="l3.278">    * Our table definition used here is slightly different from that used</span>
<a href="#l3.279"></a><span id="l3.279">    *  internally, because we are potentially creating a sort of crappy ORM and</span>
<a href="#l3.280"></a><span id="l3.280">    *  we don't want to have to parse the column names out.</span>
<a href="#l3.281"></a><span id="l3.281">    */</span>
<a href="#l3.282"></a><span id="l3.282">   createTableIfNotExists: function gloda_ds_createTableIfNotExists(aTableDef) {</span>
<a href="#l3.283"></a><span id="l3.283">     aTableDef._realName = &quot;plugin_&quot; + aTableDef.name;</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineplus">+    </span>
<a href="#l3.285"></a><span id="l3.285">     // first, check if the table exists</span>
<a href="#l3.286"></a><span id="l3.286" class="difflineminus">-    let testTableSql = &quot;SELECT * FROM sqlite_master WHERE type='table' AND &quot; +</span>
<a href="#l3.287"></a><span id="l3.287" class="difflineminus">-                       &quot;name = '&quot; + aTableDef._realName + &quot;'&quot;;</span>
<a href="#l3.288"></a><span id="l3.288" class="difflineminus">-    let testTableStmt = this._createStatement(testTableSql);</span>
<a href="#l3.289"></a><span id="l3.289" class="difflineminus">-    if (!testTableStmt.step()) {</span>
<a href="#l3.290"></a><span id="l3.290" class="difflineplus">+    if (!this.syncConnection.tableExists(aTableDef._realName)) {</span>
<a href="#l3.291"></a><span id="l3.291">       try {</span>
<a href="#l3.292"></a><span id="l3.292" class="difflineminus">-        this.dbConnection.createTable(aTableDef._realName,</span>
<a href="#l3.293"></a><span id="l3.293" class="difflineminus">-                                      [coldef.join(&quot; &quot;) for each</span>
<a href="#l3.294"></a><span id="l3.294" class="difflineplus">+        this.syncConnection.createTable(aTableDef._realName,</span>
<a href="#l3.295"></a><span id="l3.295" class="difflineplus">+                                        [coldef.join(&quot; &quot;) for each</span>
<a href="#l3.296"></a><span id="l3.296">                                      (coldef in aTableDef.columns)].join(&quot;, &quot;));</span>
<a href="#l3.297"></a><span id="l3.297">       }</span>
<a href="#l3.298"></a><span id="l3.298">       catch (ex) {</span>
<a href="#l3.299"></a><span id="l3.299">          this._log.error(&quot;Problem creating table &quot; + aTableDef.name + &quot; &quot; +</span>
<a href="#l3.300"></a><span id="l3.300">            &quot;because: &quot; + ex + &quot; at &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l3.301"></a><span id="l3.301">          return null;</span>
<a href="#l3.302"></a><span id="l3.302">       }</span>
<a href="#l3.303"></a><span id="l3.303"> </span>
<a href="#l3.304"></a><span id="l3.304">       for (let indexName in aTableDef.indices) {</span>
<a href="#l3.305"></a><span id="l3.305">         let indexColumns = aTableDef.indices[indexName];</span>
<a href="#l3.306"></a><span id="l3.306">         </span>
<a href="#l3.307"></a><span id="l3.307">         try {</span>
<a href="#l3.308"></a><span id="l3.308">           let indexSql = &quot;CREATE INDEX &quot; + indexName + &quot; ON &quot; +</span>
<a href="#l3.309"></a><span id="l3.309">             aTableDef._realName + &quot; (&quot; + indexColumns.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l3.310"></a><span id="l3.310" class="difflineminus">-          this.dbConnection.executeSimpleSQL(indexSql);</span>
<a href="#l3.311"></a><span id="l3.311" class="difflineplus">+          this.syncConnection.executeSimpleSQL(indexSql);</span>
<a href="#l3.312"></a><span id="l3.312">         }</span>
<a href="#l3.313"></a><span id="l3.313">         catch (ex) {</span>
<a href="#l3.314"></a><span id="l3.314">           this._log.error(&quot;Problem creating index &quot; + indexName + &quot; for &quot; +</span>
<a href="#l3.315"></a><span id="l3.315">             &quot;table &quot; + aTableDef.name + &quot; because &quot; + ex + &quot; at &quot; +</span>
<a href="#l3.316"></a><span id="l3.316">             ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l3.317"></a><span id="l3.317">         }</span>
<a href="#l3.318"></a><span id="l3.318">       }</span>
<a href="#l3.319"></a><span id="l3.319">     }</span>
<a href="#l3.320"></a><span id="l3.320" class="difflineminus">-    testTableStmt.reset();</span>
<a href="#l3.321"></a><span id="l3.321">     </span>
<a href="#l3.322"></a><span id="l3.322">     return new GlodaDatabind(aTableDef, this);</span>
<a href="#l3.323"></a><span id="l3.323">   },</span>
<a href="#l3.324"></a><span id="l3.324">   </span>
<a href="#l3.325"></a><span id="l3.325">   _migrate: function gloda_ds_migrate(aDBService, aDBFile, aDBConnection,</span>
<a href="#l3.326"></a><span id="l3.326">                                       aCurVersion, aNewVersion) {</span>
<a href="#l3.327"></a><span id="l3.327">     // the 4-to-5 migration is the only possible case right now, and is so</span>
<a href="#l3.328"></a><span id="l3.328">     //  significant that we want everything purged anyways.</span>
<a href="#l3.329"></a><span id="l3.329">     // generalize me in the future.</span>
<a href="#l3.330"></a><span id="l3.330">     aDBConnection.close();</span>
<a href="#l3.331"></a><span id="l3.331">     aDBFile.remove(false);</span>
<a href="#l3.332"></a><span id="l3.332">     this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l3.333"></a><span id="l3.333">     </span>
<a href="#l3.334"></a><span id="l3.334">     return this._createDB(aDBService, aDBFile);</span>
<a href="#l3.335"></a><span id="l3.335">   },</span>
<a href="#l3.336"></a><span id="l3.336">   </span>
<a href="#l3.337"></a><span id="l3.337" class="difflineminus">-  // cribbed from snowl</span>
<a href="#l3.338"></a><span id="l3.338" class="difflineminus">-  _createStatement: function gloda_ds_createStatement(aSQLString) {</span>
<a href="#l3.339"></a><span id="l3.339" class="difflineplus">+  _outstandingAsyncStatements: [],</span>
<a href="#l3.340"></a><span id="l3.340" class="difflineplus">+  </span>
<a href="#l3.341"></a><span id="l3.341" class="difflineplus">+  _createAsyncStatement: function gloda_ds_createAsyncStatement(aSQLString,</span>
<a href="#l3.342"></a><span id="l3.342" class="difflineplus">+                                                                aWillFinalize) {</span>
<a href="#l3.343"></a><span id="l3.343">     let statement = null;</span>
<a href="#l3.344"></a><span id="l3.344">     try {</span>
<a href="#l3.345"></a><span id="l3.345" class="difflineminus">-      statement = this.dbConnection.createStatement(aSQLString);</span>
<a href="#l3.346"></a><span id="l3.346" class="difflineplus">+      statement = this.asyncConnection.createStatement(aSQLString);</span>
<a href="#l3.347"></a><span id="l3.347" class="difflineplus">+    }</span>
<a href="#l3.348"></a><span id="l3.348" class="difflineplus">+    catch(ex) {</span>
<a href="#l3.349"></a><span id="l3.349" class="difflineplus">+       throw(&quot;error creating async statement &quot; + aSQLString + &quot; - &quot; +</span>
<a href="#l3.350"></a><span id="l3.350" class="difflineplus">+             this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.351"></a><span id="l3.351" class="difflineplus">+             this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.352"></a><span id="l3.352" class="difflineplus">+    }</span>
<a href="#l3.353"></a><span id="l3.353" class="difflineplus">+    </span>
<a href="#l3.354"></a><span id="l3.354" class="difflineplus">+    if (!aWillFinalize)</span>
<a href="#l3.355"></a><span id="l3.355" class="difflineplus">+      this._outstandingAsyncStatements.push(statement);</span>
<a href="#l3.356"></a><span id="l3.356" class="difflineplus">+    </span>
<a href="#l3.357"></a><span id="l3.357" class="difflineplus">+    return statement;</span>
<a href="#l3.358"></a><span id="l3.358" class="difflineplus">+  },</span>
<a href="#l3.359"></a><span id="l3.359" class="difflineplus">+  </span>
<a href="#l3.360"></a><span id="l3.360" class="difflineplus">+  _cleanupAsyncStatements: function gloda_ds_cleanupAsyncStatements() {</span>
<a href="#l3.361"></a><span id="l3.361" class="difflineplus">+    [stmt.finalize() for each (stmt in this._outstandingAsyncStatements)];</span>
<a href="#l3.362"></a><span id="l3.362" class="difflineplus">+  },</span>
<a href="#l3.363"></a><span id="l3.363" class="difflineplus">+  </span>
<a href="#l3.364"></a><span id="l3.364" class="difflineplus">+  _outstandingSyncStatements: [],</span>
<a href="#l3.365"></a><span id="l3.365" class="difflineplus">+  </span>
<a href="#l3.366"></a><span id="l3.366" class="difflineplus">+  _createSyncStatement: function gloda_ds_createSyncStatement(aSQLString,</span>
<a href="#l3.367"></a><span id="l3.367" class="difflineplus">+                                                              aWillFinalize) {</span>
<a href="#l3.368"></a><span id="l3.368" class="difflineplus">+    let statement = null;</span>
<a href="#l3.369"></a><span id="l3.369" class="difflineplus">+    try {</span>
<a href="#l3.370"></a><span id="l3.370" class="difflineplus">+      statement = this.syncConnection.createStatement(aSQLString);</span>
<a href="#l3.371"></a><span id="l3.371">     }</span>
<a href="#l3.372"></a><span id="l3.372">     catch(ex) {</span>
<a href="#l3.373"></a><span id="l3.373" class="difflineminus">-       throw(&quot;error creating statement &quot; + aSQLString + &quot; - &quot; +</span>
<a href="#l3.374"></a><span id="l3.374" class="difflineminus">-             this.dbConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.375"></a><span id="l3.375" class="difflineminus">-             this.dbConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.376"></a><span id="l3.376" class="difflineplus">+       throw(&quot;error creating sync statement &quot; + aSQLString + &quot; - &quot; +</span>
<a href="#l3.377"></a><span id="l3.377" class="difflineplus">+             this.syncConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.378"></a><span id="l3.378" class="difflineplus">+             this.syncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.379"></a><span id="l3.379">     }</span>
<a href="#l3.380"></a><span id="l3.380" class="difflineplus">+</span>
<a href="#l3.381"></a><span id="l3.381" class="difflineplus">+    if (!aWillFinalize)</span>
<a href="#l3.382"></a><span id="l3.382" class="difflineplus">+      this._outstandingSyncStatements.push(statement);</span>
<a href="#l3.383"></a><span id="l3.383">     </span>
<a href="#l3.384"></a><span id="l3.384" class="difflineminus">-    let wrappedStatement = Cc[&quot;@mozilla.org/storage/statement-wrapper;1&quot;].</span>
<a href="#l3.385"></a><span id="l3.385" class="difflineminus">-                           createInstance(Ci.mozIStorageStatementWrapper);</span>
<a href="#l3.386"></a><span id="l3.386" class="difflineminus">-    wrappedStatement.initialize(statement);</span>
<a href="#l3.387"></a><span id="l3.387" class="difflineminus">-    return wrappedStatement;</span>
<a href="#l3.388"></a><span id="l3.388" class="difflineplus">+    return statement;</span>
<a href="#l3.389"></a><span id="l3.389" class="difflineplus">+  },</span>
<a href="#l3.390"></a><span id="l3.390" class="difflineplus">+</span>
<a href="#l3.391"></a><span id="l3.391" class="difflineplus">+  _cleanupSyncStatements: function gloda_ds_cleanupSyncStatements() {</span>
<a href="#l3.392"></a><span id="l3.392" class="difflineplus">+    [stmt.finalize() for each (stmt in this._outstandingSyncStatements)];</span>
<a href="#l3.393"></a><span id="l3.393" class="difflineplus">+  },</span>
<a href="#l3.394"></a><span id="l3.394" class="difflineplus">+  </span>
<a href="#l3.395"></a><span id="l3.395" class="difflineplus">+  /**</span>
<a href="#l3.396"></a><span id="l3.396" class="difflineplus">+   * Helper to bind based on the actual type of the javascript value.  Note</span>
<a href="#l3.397"></a><span id="l3.397" class="difflineplus">+   *  that we always use int64 because under the hood sqlite just promotes the</span>
<a href="#l3.398"></a><span id="l3.398" class="difflineplus">+   *  normal 'int' call to 'int64' anyways.</span>
<a href="#l3.399"></a><span id="l3.399" class="difflineplus">+   */</span>
<a href="#l3.400"></a><span id="l3.400" class="difflineplus">+  _bindVariant: function gloda_ds_bindBlob(aStatement, aIndex, aVariant) {</span>
<a href="#l3.401"></a><span id="l3.401" class="difflineplus">+    if (aVariant == null) // catch both null and undefined</span>
<a href="#l3.402"></a><span id="l3.402" class="difflineplus">+      aStatement.bindNullParameter(aIndex);</span>
<a href="#l3.403"></a><span id="l3.403" class="difflineplus">+    else if (typeof aVariant == &quot;string&quot;)</span>
<a href="#l3.404"></a><span id="l3.404" class="difflineplus">+      aStatement.bindStringParameter(aIndex, aVariant);</span>
<a href="#l3.405"></a><span id="l3.405" class="difflineplus">+    else if (typeof aVariant == &quot;number&quot;) {</span>
<a href="#l3.406"></a><span id="l3.406" class="difflineplus">+      // we differentiate for storage representation reasons only.</span>
<a href="#l3.407"></a><span id="l3.407" class="difflineplus">+      if (Math.floor(aVariant) === aVariant)</span>
<a href="#l3.408"></a><span id="l3.408" class="difflineplus">+        aStatement.bindInt64Parameter(aIndex, aVariant);</span>
<a href="#l3.409"></a><span id="l3.409" class="difflineplus">+      else</span>
<a href="#l3.410"></a><span id="l3.410" class="difflineplus">+        aStatement.bindDoubleParameter(aIndex, aVariant);</span>
<a href="#l3.411"></a><span id="l3.411" class="difflineplus">+    }</span>
<a href="#l3.412"></a><span id="l3.412" class="difflineplus">+    else</span>
<a href="#l3.413"></a><span id="l3.413" class="difflineplus">+      throw(&quot;Attempt to bind variant with unsupported type: &quot; +</span>
<a href="#l3.414"></a><span id="l3.414" class="difflineplus">+            (typeof aVariant));</span>
<a href="#l3.415"></a><span id="l3.415" class="difflineplus">+  },</span>
<a href="#l3.416"></a><span id="l3.416" class="difflineplus">+  </span>
<a href="#l3.417"></a><span id="l3.417" class="difflineplus">+  _getVariant: function gloda_ds_getBlob(aRow, aIndex) {</span>
<a href="#l3.418"></a><span id="l3.418" class="difflineplus">+    let typeOfIndex = aRow.getTypeOfIndex(aIndex);</span>
<a href="#l3.419"></a><span id="l3.419" class="difflineplus">+    if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.420"></a><span id="l3.420" class="difflineplus">+      return null;</span>
<a href="#l3.421"></a><span id="l3.421" class="difflineplus">+    // XPConnect would just end up going through an intermediary double stage</span>
<a href="#l3.422"></a><span id="l3.422" class="difflineplus">+    //  for the int64 case anyways...</span>
<a href="#l3.423"></a><span id="l3.423" class="difflineplus">+    else if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_INTEGER ||</span>
<a href="#l3.424"></a><span id="l3.424" class="difflineplus">+             typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_DOUBLE)</span>
<a href="#l3.425"></a><span id="l3.425" class="difflineplus">+      return aRow.getDouble(aIndex);</span>
<a href="#l3.426"></a><span id="l3.426" class="difflineplus">+    else // typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_TEXT</span>
<a href="#l3.427"></a><span id="l3.427" class="difflineplus">+      return aRow.getString(aIndex);</span>
<a href="#l3.428"></a><span id="l3.428">   },</span>
<a href="#l3.429"></a><span id="l3.429"> </span>
<a href="#l3.430"></a><span id="l3.430">   /** Simple nested transaction support as a performance optimization. */  </span>
<a href="#l3.431"></a><span id="l3.431">   _transactionDepth: 0,</span>
<a href="#l3.432"></a><span id="l3.432">   _transactionGood: false,</span>
<a href="#l3.433"></a><span id="l3.433">   /**</span>
<a href="#l3.434"></a><span id="l3.434">    * Begin a potentially nested transaction; only the outermost transaction gets</span>
<a href="#l3.435"></a><span id="l3.435">    *  to be an actual transaction, and the failure of any nested transaction</span>
<a href="#l3.436"></a><span id="l3.436">    *  results in a rollback of the entire outer transaction.  If you really</span>
<a href="#l3.437"></a><span id="l3.437">    *  need an atomic transaction </span>
<a href="#l3.438"></a><span id="l3.438">    */</span>
<a href="#l3.439"></a><span id="l3.439">   _beginTransaction: function gloda_ds_beginTransaction() {</span>
<a href="#l3.440"></a><span id="l3.440">     if (this._transactionDepth == 0) {</span>
<a href="#l3.441"></a><span id="l3.441" class="difflineminus">-      this.dbConnection.beginTransaction();</span>
<a href="#l3.442"></a><span id="l3.442" class="difflineplus">+// no transactions for async for now</span>
<a href="#l3.443"></a><span id="l3.443" class="difflineplus">+//      this.dbConnection.beginTransaction();</span>
<a href="#l3.444"></a><span id="l3.444">       this._transactionGood = true;</span>
<a href="#l3.445"></a><span id="l3.445">     }</span>
<a href="#l3.446"></a><span id="l3.446">     this._transactionDepth++;</span>
<a href="#l3.447"></a><span id="l3.447">   },</span>
<a href="#l3.448"></a><span id="l3.448">   /**</span>
<a href="#l3.449"></a><span id="l3.449">    * Commit a potentially nested transaction; if we are the outer-most</span>
<a href="#l3.450"></a><span id="l3.450">    *  transaction and no sub-transaction issues a rollback</span>
<a href="#l3.451"></a><span id="l3.451">    *  (via _rollbackTransaction) then we commit, otherwise we rollback.</span>
<a href="#l3.452"></a><span id="l3.452">    */</span>
<a href="#l3.453"></a><span id="l3.453">   _commitTransaction: function gloda_ds_commitTransaction() {</span>
<a href="#l3.454"></a><span id="l3.454">     this._transactionDepth--;</span>
<a href="#l3.455"></a><span id="l3.455">     if (this._transactionDepth == 0) {</span>
<a href="#l3.456"></a><span id="l3.456">       try {</span>
<a href="#l3.457"></a><span id="l3.457" class="difflineplus">+/* no transactions for async for now      </span>
<a href="#l3.458"></a><span id="l3.458">         if (this._transactionGood)</span>
<a href="#l3.459"></a><span id="l3.459">           this.dbConnection.commitTransaction();</span>
<a href="#l3.460"></a><span id="l3.460">         else</span>
<a href="#l3.461"></a><span id="l3.461">           this.dbConnection.rollbackTransaction();</span>
<a href="#l3.462"></a><span id="l3.462" class="difflineplus">+*/</span>
<a href="#l3.463"></a><span id="l3.463">       }</span>
<a href="#l3.464"></a><span id="l3.464">       catch (ex) {</span>
<a href="#l3.465"></a><span id="l3.465">         this._log.error(&quot;Commit problem: &quot; + ex);</span>
<a href="#l3.466"></a><span id="l3.466">       }</span>
<a href="#l3.467"></a><span id="l3.467">     }</span>
<a href="#l3.468"></a><span id="l3.468">   },</span>
<a href="#l3.469"></a><span id="l3.469">   /**</span>
<a href="#l3.470"></a><span id="l3.470">    * Abort the commit of the potentially nested transaction.  If we are not the</span>
<a href="#l3.471"></a><span id="l3.471">    *  outermost transaction, we set a flag that tells the outermost transaction</span>
<a href="#l3.472"></a><span id="l3.472">    *  that it must roll back.</span>
<a href="#l3.473"></a><span id="l3.473">    */</span>
<a href="#l3.474"></a><span id="l3.474">   _rollbackTransaction: function gloda_ds_rollbackTransaction() {</span>
<a href="#l3.475"></a><span id="l3.475">     this._transactionDepth--;</span>
<a href="#l3.476"></a><span id="l3.476">     this._transactionGood = false;</span>
<a href="#l3.477"></a><span id="l3.477">     if (this._transactionDepth == 0) {</span>
<a href="#l3.478"></a><span id="l3.478">       try {</span>
<a href="#l3.479"></a><span id="l3.479" class="difflineminus">-        this.dbConnection.rollbackTransaction();</span>
<a href="#l3.480"></a><span id="l3.480" class="difflineplus">+// no transactions for async for now</span>
<a href="#l3.481"></a><span id="l3.481" class="difflineplus">+//        this.dbConnection.rollbackTransaction();</span>
<a href="#l3.482"></a><span id="l3.482">       }</span>
<a href="#l3.483"></a><span id="l3.483">       catch (ex) {</span>
<a href="#l3.484"></a><span id="l3.484">         this._log.error(&quot;Rollback problem: &quot; + ex);</span>
<a href="#l3.485"></a><span id="l3.485">       }</span>
<a href="#l3.486"></a><span id="l3.486">     }</span>
<a href="#l3.487"></a><span id="l3.487">   },</span>
<a href="#l3.488"></a><span id="l3.488">   </span>
<a href="#l3.489"></a><span id="l3.489">   /* ********** Attribute Definitions ********** */</span>
<a href="#l3.490"></a><span id="l3.490">   /** Maps (attribute def) compound names to the GlodaAttributeDef objects. */</span>
<a href="#l3.491"></a><span id="l3.491">   _attributes: {},</span>
<a href="#l3.492"></a><span id="l3.492">   /** Map attribute ID to the definition and parameter value that produce it. */</span>
<a href="#l3.493"></a><span id="l3.493">   _attributeIDToDef: {},</span>
<a href="#l3.494"></a><span id="l3.494" class="difflineplus">+  /**</span>
<a href="#l3.495"></a><span id="l3.495" class="difflineplus">+   * We maintain the attributeDefinitions next id counter mainly because we can.</span>
<a href="#l3.496"></a><span id="l3.496" class="difflineplus">+   *  Since we mediate the access, there's no real risk to doing so, and it</span>
<a href="#l3.497"></a><span id="l3.497" class="difflineplus">+   *  allows us to keep the writes on the async connection without having to</span>
<a href="#l3.498"></a><span id="l3.498" class="difflineplus">+   *  wait for a completion notification.</span>
<a href="#l3.499"></a><span id="l3.499" class="difflineplus">+   */</span>
<a href="#l3.500"></a><span id="l3.500" class="difflineplus">+  _nextAttributeId: 1,</span>
<a href="#l3.501"></a><span id="l3.501" class="difflineplus">+  </span>
<a href="#l3.502"></a><span id="l3.502" class="difflineplus">+  _populateAttributeDefManagedId: function () {</span>
<a href="#l3.503"></a><span id="l3.503" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l3.504"></a><span id="l3.504" class="difflineplus">+      &quot;SELECT MAX(id) FROM attributeDefinitions&quot;, true);</span>
<a href="#l3.505"></a><span id="l3.505" class="difflineplus">+    if (stmt.executeStep()) {</span>
<a href="#l3.506"></a><span id="l3.506" class="difflineplus">+      this._nextAttributeId = stmt.getInt64(0) + 1;</span>
<a href="#l3.507"></a><span id="l3.507" class="difflineplus">+    }</span>
<a href="#l3.508"></a><span id="l3.508" class="difflineplus">+    stmt.finalize();</span>
<a href="#l3.509"></a><span id="l3.509" class="difflineplus">+  },</span>
<a href="#l3.510"></a><span id="l3.510">   </span>
<a href="#l3.511"></a><span id="l3.511">   get _insertAttributeDefStatement() {</span>
<a href="#l3.512"></a><span id="l3.512" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.513"></a><span id="l3.513" class="difflineminus">-      &quot;INSERT INTO attributeDefinitions (attributeType, extensionName, name, \</span>
<a href="#l3.514"></a><span id="l3.514" class="difflineminus">-                                  parameter) \</span>
<a href="#l3.515"></a><span id="l3.515" class="difflineminus">-              VALUES (:attributeType, :extensionName, :name, :parameter)&quot;);</span>
<a href="#l3.516"></a><span id="l3.516" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.517"></a><span id="l3.517" class="difflineplus">+      &quot;INSERT INTO attributeDefinitions (id, attributeType, extensionName, \</span>
<a href="#l3.518"></a><span id="l3.518" class="difflineplus">+                                  name, parameter) \</span>
<a href="#l3.519"></a><span id="l3.519" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5)&quot;);</span>
<a href="#l3.520"></a><span id="l3.520">     this.__defineGetter__(&quot;_insertAttributeDefStatement&quot;, function() statement);</span>
<a href="#l3.521"></a><span id="l3.521">     return this._insertAttributeDefStatement; </span>
<a href="#l3.522"></a><span id="l3.522">   },</span>
<a href="#l3.523"></a><span id="l3.523"> </span>
<a href="#l3.524"></a><span id="l3.524">   /**</span>
<a href="#l3.525"></a><span id="l3.525">    * Create an attribute definition and return the row ID.  Special/atypical</span>
<a href="#l3.526"></a><span id="l3.526">    *  in that it doesn't directly return a GlodaAttributeDef; we leave that up</span>
<a href="#l3.527"></a><span id="l3.527">    *  to the caller since they know much more than actually needs to go in the</span>
<a href="#l3.528"></a><span id="l3.528">    *  database.</span>
<a href="#l3.529"></a><span id="l3.529" class="difflineplus">+   *</span>
<a href="#l3.530"></a><span id="l3.530" class="difflineplus">+   * @return The attribute id allocated to this attribute.</span>
<a href="#l3.531"></a><span id="l3.531">    */</span>
<a href="#l3.532"></a><span id="l3.532">   _createAttributeDef: function gloda_ds_createAttributeDef(aAttrType,</span>
<a href="#l3.533"></a><span id="l3.533">                                     aExtensionName, aAttrName, aParameter) {</span>
<a href="#l3.534"></a><span id="l3.534" class="difflineplus">+    let attributeId = this._nextAttributeId++;</span>
<a href="#l3.535"></a><span id="l3.535" class="difflineplus">+                                    </span>
<a href="#l3.536"></a><span id="l3.536">     let iads = this._insertAttributeDefStatement;</span>
<a href="#l3.537"></a><span id="l3.537" class="difflineminus">-    iads.params.attributeType = aAttrType;</span>
<a href="#l3.538"></a><span id="l3.538" class="difflineminus">-    iads.params.extensionName = aExtensionName;</span>
<a href="#l3.539"></a><span id="l3.539" class="difflineminus">-    iads.params.name = aAttrName;</span>
<a href="#l3.540"></a><span id="l3.540" class="difflineminus">-    iads.params.parameter = aParameter;</span>
<a href="#l3.541"></a><span id="l3.541" class="difflineminus">-    </span>
<a href="#l3.542"></a><span id="l3.542" class="difflineminus">-    iads.execute();</span>
<a href="#l3.543"></a><span id="l3.543" class="difflineplus">+    iads.bindInt64Parameter(0, attributeId);</span>
<a href="#l3.544"></a><span id="l3.544" class="difflineplus">+    iads.bindInt64Parameter(1, aAttrType);</span>
<a href="#l3.545"></a><span id="l3.545" class="difflineplus">+    iads.bindStringParameter(2, aExtensionName);</span>
<a href="#l3.546"></a><span id="l3.546" class="difflineplus">+    iads.bindStringParameter(3, aAttrName);</span>
<a href="#l3.547"></a><span id="l3.547" class="difflineplus">+    this._bindVariant(iads, 4, aParameter);</span>
<a href="#l3.548"></a><span id="l3.548">     </span>
<a href="#l3.549"></a><span id="l3.549" class="difflineminus">-    return this.dbConnection.lastInsertRowID;</span>
<a href="#l3.550"></a><span id="l3.550" class="difflineminus">-  },</span>
<a href="#l3.551"></a><span id="l3.551" class="difflineminus">-  </span>
<a href="#l3.552"></a><span id="l3.552" class="difflineminus">-  get _selectAttributeDefinitionsStatement() {</span>
<a href="#l3.553"></a><span id="l3.553" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.554"></a><span id="l3.554" class="difflineminus">-      &quot;SELECT * FROM attributeDefinitions&quot;);</span>
<a href="#l3.555"></a><span id="l3.555" class="difflineminus">-    this.__defineGetter__(&quot;_selectAttributeDefinitionsStatement&quot;,</span>
<a href="#l3.556"></a><span id="l3.556" class="difflineminus">-      function() statement);</span>
<a href="#l3.557"></a><span id="l3.557" class="difflineminus">-    return this._selectAttributeDefinitionsStatement;</span>
<a href="#l3.558"></a><span id="l3.558" class="difflineplus">+    iads.executeAsync();</span>
<a href="#l3.559"></a><span id="l3.559" class="difflineplus">+    </span>
<a href="#l3.560"></a><span id="l3.560" class="difflineplus">+    return attributeId;</span>
<a href="#l3.561"></a><span id="l3.561">   },</span>
<a href="#l3.562"></a><span id="l3.562">   </span>
<a href="#l3.563"></a><span id="l3.563">   /**</span>
<a href="#l3.564"></a><span id="l3.564" class="difflineminus">-   * Look-up all the attribute definitions, populating our authoritative </span>
<a href="#l3.565"></a><span id="l3.565" class="difflineplus">+   * Sync-ly look-up all the attribute definitions, populating our authoritative </span>
<a href="#l3.566"></a><span id="l3.566">    *  _attributes and _attributeIDToDef maps.  (In other words, once this method</span>
<a href="#l3.567"></a><span id="l3.567">    *  is called, those maps should always be in sync with the underlying</span>
<a href="#l3.568"></a><span id="l3.568">    *  database.)</span>
<a href="#l3.569"></a><span id="l3.569">    */</span>
<a href="#l3.570"></a><span id="l3.570">   getAllAttributes: function gloda_ds_getAllAttributes() {</span>
<a href="#l3.571"></a><span id="l3.571" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.572"></a><span id="l3.572" class="difflineplus">+      &quot;SELECT id, attributeType, extensionName, name, parameter \</span>
<a href="#l3.573"></a><span id="l3.573" class="difflineplus">+         FROM attributeDefinitions&quot;, true);</span>
<a href="#l3.574"></a><span id="l3.574" class="difflineplus">+    this.__defineGetter__(&quot;_selectAttributeDefinitionsStatement&quot;,</span>
<a href="#l3.575"></a><span id="l3.575" class="difflineplus">+      function() statement);</span>
<a href="#l3.576"></a><span id="l3.576" class="difflineplus">+    return this._selectAttributeDefinitionsStatement;</span>
<a href="#l3.577"></a><span id="l3.577" class="difflineplus">+</span>
<a href="#l3.578"></a><span id="l3.578">     // map compound name to the attribute</span>
<a href="#l3.579"></a><span id="l3.579">     let attribs = {};</span>
<a href="#l3.580"></a><span id="l3.580">     // map the attribute id to [attribute, parameter] where parameter is null</span>
<a href="#l3.581"></a><span id="l3.581">     //  in cases where parameter is unused.</span>
<a href="#l3.582"></a><span id="l3.582">     let idToAttribAndParam = {}</span>
<a href="#l3.583"></a><span id="l3.583"> </span>
<a href="#l3.584"></a><span id="l3.584">     this._log.info(&quot;loading all attribute defs&quot;);</span>
<a href="#l3.585"></a><span id="l3.585">     </span>
<a href="#l3.586"></a><span id="l3.586" class="difflineminus">-    while (this._selectAttributeDefinitionsStatement.step()) {</span>
<a href="#l3.587"></a><span id="l3.587" class="difflineminus">-      let row = this._selectAttributeDefinitionsStatement.row;</span>
<a href="#l3.588"></a><span id="l3.588" class="difflineplus">+    while (stmt.executeStep()) {</span>
<a href="#l3.589"></a><span id="l3.589" class="difflineplus">+      let rowId = stmt.getInt64(0);</span>
<a href="#l3.590"></a><span id="l3.590" class="difflineplus">+      let rowAttributeType = stmt.getInt64(1);</span>
<a href="#l3.591"></a><span id="l3.591" class="difflineplus">+      let rowExtensionName = stmt.getString(2);</span>
<a href="#l3.592"></a><span id="l3.592" class="difflineplus">+      let rowName = stmt.getString(3);</span>
<a href="#l3.593"></a><span id="l3.593" class="difflineplus">+      let rowParameter = this._getVariant(stmt, 4); </span>
<a href="#l3.594"></a><span id="l3.594">       </span>
<a href="#l3.595"></a><span id="l3.595" class="difflineminus">-      let compoundName = row[&quot;extensionName&quot;] + &quot;:&quot; + row[&quot;name&quot;];</span>
<a href="#l3.596"></a><span id="l3.596" class="difflineplus">+      let compoundName = rowExtensionName + &quot;:&quot; + rowName;</span>
<a href="#l3.597"></a><span id="l3.597">       </span>
<a href="#l3.598"></a><span id="l3.598">       let attrib;</span>
<a href="#l3.599"></a><span id="l3.599">       if (compoundName in attribs) {</span>
<a href="#l3.600"></a><span id="l3.600">         attrib = attribs[compoundName];</span>
<a href="#l3.601"></a><span id="l3.601">       } else {</span>
<a href="#l3.602"></a><span id="l3.602">         attrib = new GlodaAttributeDef(this, null,</span>
<a href="#l3.603"></a><span id="l3.603" class="difflineminus">-                                       compoundName, null, row[&quot;attributeType&quot;],</span>
<a href="#l3.604"></a><span id="l3.604" class="difflineminus">-                                       row[&quot;extensionName&quot;], row[&quot;name&quot;],</span>
<a href="#l3.605"></a><span id="l3.605" class="difflineplus">+                                       compoundName, null, rowAttributeType,</span>
<a href="#l3.606"></a><span id="l3.606" class="difflineplus">+                                       rowExtensionName, rowName,</span>
<a href="#l3.607"></a><span id="l3.607">                                        null, null, null, null);</span>
<a href="#l3.608"></a><span id="l3.608">         attribs[compoundName] = attrib;</span>
<a href="#l3.609"></a><span id="l3.609">       }</span>
<a href="#l3.610"></a><span id="l3.610">       // if the parameter is null, the id goes on the attribute def, otherwise</span>
<a href="#l3.611"></a><span id="l3.611">       //  it is a parameter binding and goes in the binding map.</span>
<a href="#l3.612"></a><span id="l3.612" class="difflineminus">-      if (row[&quot;parameter&quot;] == null) {</span>
<a href="#l3.613"></a><span id="l3.613" class="difflineminus">-        attrib._id = row[&quot;id&quot;];</span>
<a href="#l3.614"></a><span id="l3.614" class="difflineminus">-        idToAttribAndParam[row[&quot;id&quot;]] = [attrib, null];</span>
<a href="#l3.615"></a><span id="l3.615" class="difflineplus">+      if (rowParameter == null) {</span>
<a href="#l3.616"></a><span id="l3.616" class="difflineplus">+        attrib._id = rowId;</span>
<a href="#l3.617"></a><span id="l3.617" class="difflineplus">+        idToAttribAndParam[rowId] = [attrib, null];</span>
<a href="#l3.618"></a><span id="l3.618">       } else {</span>
<a href="#l3.619"></a><span id="l3.619" class="difflineminus">-        attrib._parameterBindings[row[&quot;parameter&quot;]] = row[&quot;id&quot;];</span>
<a href="#l3.620"></a><span id="l3.620" class="difflineminus">-        idToAttribAndParam[row[&quot;id&quot;]] = [attrib, row[&quot;parameter&quot;]];</span>
<a href="#l3.621"></a><span id="l3.621" class="difflineplus">+        attrib._parameterBindings[rowParameter] = rowId;</span>
<a href="#l3.622"></a><span id="l3.622" class="difflineplus">+        idToAttribAndParam[rowId] = [attrib, rowParameter];</span>
<a href="#l3.623"></a><span id="l3.623">       }</span>
<a href="#l3.624"></a><span id="l3.624">     }</span>
<a href="#l3.625"></a><span id="l3.625" class="difflineminus">-    this._selectAttributeDefinitionsStatement.reset();</span>
<a href="#l3.626"></a><span id="l3.626" class="difflineplus">+    stmt.finalize();</span>
<a href="#l3.627"></a><span id="l3.627"> </span>
<a href="#l3.628"></a><span id="l3.628">     this._log.info(&quot;done loading all attribute defs&quot;);</span>
<a href="#l3.629"></a><span id="l3.629">     </span>
<a href="#l3.630"></a><span id="l3.630">     this._attributes = attribs;</span>
<a href="#l3.631"></a><span id="l3.631">     this._attributeIDToDef = idToAttribAndParam;</span>
<a href="#l3.632"></a><span id="l3.632">   },</span>
<a href="#l3.633"></a><span id="l3.633">   </span>
<a href="#l3.634"></a><span id="l3.634">   /**</span>
<a href="#l3.635"></a><span id="l3.635" class="difflineat">@@ -639,280 +848,355 @@ let GlodaDatastore = {</span>
<a href="#l3.636"></a><span id="l3.636">    *  GlodaDatastore._createAttributeDef).  In theory, that method could take</span>
<a href="#l3.637"></a><span id="l3.637">    *  an additional argument and obviate the need for this method.</span>
<a href="#l3.638"></a><span id="l3.638">    */</span>
<a href="#l3.639"></a><span id="l3.639">   reportBinding: function gloda_ds_reportBinding(aID, aAttrDef, aParamValue) {</span>
<a href="#l3.640"></a><span id="l3.640">     this._attributeIDToDef[aID] = [aAttrDef, aParamValue];</span>
<a href="#l3.641"></a><span id="l3.641">   },</span>
<a href="#l3.642"></a><span id="l3.642">   </span>
<a href="#l3.643"></a><span id="l3.643">   /* ********** Folders ********** */</span>
<a href="#l3.644"></a><span id="l3.644" class="difflineplus">+  /** next folder (row) id to issue, populated by _getAllFolderMappings. */</span>
<a href="#l3.645"></a><span id="l3.645" class="difflineplus">+  _nextFolderId: 1,</span>
<a href="#l3.646"></a><span id="l3.646">   </span>
<a href="#l3.647"></a><span id="l3.647">   get _insertFolderLocationStatement() {</span>
<a href="#l3.648"></a><span id="l3.648" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.649"></a><span id="l3.649" class="difflineminus">-      &quot;INSERT INTO folderLocations (folderURI) VALUES (:folderURI)&quot;);</span>
<a href="#l3.650"></a><span id="l3.650" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.651"></a><span id="l3.651" class="difflineplus">+      &quot;INSERT INTO folderLocations (id, folderURI) VALUES (?1, ?2)&quot;);</span>
<a href="#l3.652"></a><span id="l3.652">     this.__defineGetter__(&quot;_insertFolderLocationStatement&quot;,</span>
<a href="#l3.653"></a><span id="l3.653">       function() statement);</span>
<a href="#l3.654"></a><span id="l3.654">     return this._insertFolderLocationStatement;</span>
<a href="#l3.655"></a><span id="l3.655">   },</span>
<a href="#l3.656"></a><span id="l3.656">   </span>
<a href="#l3.657"></a><span id="l3.657" class="difflineminus">-  // memoizing this is arguably overkill... fix along with _mapFolderID idiom.</span>
<a href="#l3.658"></a><span id="l3.658" class="difflineminus">-  get _selectAllFolderLocations() {</span>
<a href="#l3.659"></a><span id="l3.659" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.660"></a><span id="l3.660" class="difflineminus">-      &quot;SELECT id, folderURI FROM folderLocations&quot;);</span>
<a href="#l3.661"></a><span id="l3.661" class="difflineminus">-    this.__defineGetter__(&quot;_selectAllFolderLocations&quot;,</span>
<a href="#l3.662"></a><span id="l3.662" class="difflineminus">-      function() statement);</span>
<a href="#l3.663"></a><span id="l3.663" class="difflineminus">-    return this._selectAllFolderLocations;</span>
<a href="#l3.664"></a><span id="l3.664" class="difflineminus">-  },</span>
<a href="#l3.665"></a><span id="l3.665" class="difflineminus">-  </span>
<a href="#l3.666"></a><span id="l3.666">   /**</span>
<a href="#l3.667"></a><span id="l3.667">    * Authoritative map from folder URI to folder ID.  (Authoritative in the</span>
<a href="#l3.668"></a><span id="l3.668">    *  sense that this map exactly represents the state of the underlying</span>
<a href="#l3.669"></a><span id="l3.669">    *  database.  If it does not, it's a bug in updating the database.)</span>
<a href="#l3.670"></a><span id="l3.670">    */</span>
<a href="#l3.671"></a><span id="l3.671">   _folderURIs: {},</span>
<a href="#l3.672"></a><span id="l3.672">   /** Authoritative map from folder ID to folder URI */</span>
<a href="#l3.673"></a><span id="l3.673">   _folderIDs: {},</span>
<a href="#l3.674"></a><span id="l3.674">   </span>
<a href="#l3.675"></a><span id="l3.675">   /** Intialize our _folderURIs/_folderIDs mappings, called by _init(). */</span>
<a href="#l3.676"></a><span id="l3.676">   _getAllFolderMappings: function gloda_ds_getAllFolderMappings() {</span>
<a href="#l3.677"></a><span id="l3.677" class="difflineminus">-    while (this._selectAllFolderLocations.step()) {</span>
<a href="#l3.678"></a><span id="l3.678" class="difflineminus">-      let folderID = this._selectAllFolderLocations.row[&quot;id&quot;];</span>
<a href="#l3.679"></a><span id="l3.679" class="difflineminus">-      let folderURI = this._selectAllFolderLocations.row[&quot;folderURI&quot;];</span>
<a href="#l3.680"></a><span id="l3.680" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l3.681"></a><span id="l3.681" class="difflineplus">+      &quot;SELECT id, folderURI FROM folderLocations&quot;, true);</span>
<a href="#l3.682"></a><span id="l3.682" class="difflineplus">+</span>
<a href="#l3.683"></a><span id="l3.683" class="difflineplus">+    while (stmt.executeStep()) {</span>
<a href="#l3.684"></a><span id="l3.684" class="difflineplus">+      let folderID = stmt.getInt64(0);</span>
<a href="#l3.685"></a><span id="l3.685" class="difflineplus">+      let folderURI = stmt.getString(1);</span>
<a href="#l3.686"></a><span id="l3.686">       this._folderURIs[folderURI] = folderID;</span>
<a href="#l3.687"></a><span id="l3.687">       this._folderIDs[folderID] = folderURI;</span>
<a href="#l3.688"></a><span id="l3.688" class="difflineplus">+      </span>
<a href="#l3.689"></a><span id="l3.689" class="difflineplus">+      if (folderID + 1 &gt; this._nextFolderId)</span>
<a href="#l3.690"></a><span id="l3.690" class="difflineplus">+        this._nextFolderId = folderID + 1;</span>
<a href="#l3.691"></a><span id="l3.691">     }</span>
<a href="#l3.692"></a><span id="l3.692" class="difflineminus">-    this._selectAllFolderLocations.reset();</span>
<a href="#l3.693"></a><span id="l3.693" class="difflineplus">+    stmt.finalize();</span>
<a href="#l3.694"></a><span id="l3.694">   },</span>
<a href="#l3.695"></a><span id="l3.695">   </span>
<a href="#l3.696"></a><span id="l3.696">   /**</span>
<a href="#l3.697"></a><span id="l3.697">    * Map a folder URI to a folder ID, creating the mapping if it does not yet</span>
<a href="#l3.698"></a><span id="l3.698">    *  exist.</span>
<a href="#l3.699"></a><span id="l3.699">    */</span>
<a href="#l3.700"></a><span id="l3.700">   _mapFolderURI: function gloda_ds_mapFolderURI(aFolderURI) {</span>
<a href="#l3.701"></a><span id="l3.701">     if (aFolderURI in this._folderURIs) {</span>
<a href="#l3.702"></a><span id="l3.702">       return this._folderURIs[aFolderURI];</span>
<a href="#l3.703"></a><span id="l3.703">     }</span>
<a href="#l3.704"></a><span id="l3.704">     </span>
<a href="#l3.705"></a><span id="l3.705" class="difflineminus">-    this._insertFolderLocationStatement.params.folderURI = aFolderURI;</span>
<a href="#l3.706"></a><span id="l3.706" class="difflineminus">-    this._insertFolderLocationStatement.execute();</span>
<a href="#l3.707"></a><span id="l3.707" class="difflineminus">-    let folderID = this.dbConnection.lastInsertRowID;</span>
<a href="#l3.708"></a><span id="l3.708" class="difflineplus">+    let folderID = this._nextFolderId++;</span>
<a href="#l3.709"></a><span id="l3.709" class="difflineplus">+    this._insertFolderLocationStatement.bindInt64Parameter(0, folderID)</span>
<a href="#l3.710"></a><span id="l3.710" class="difflineplus">+    this._insertFolderLocationStatement.bindStringParameter(1, aFolderURI);</span>
<a href="#l3.711"></a><span id="l3.711" class="difflineplus">+    this._insertFolderLocationStatement.executeAsync();</span>
<a href="#l3.712"></a><span id="l3.712"> </span>
<a href="#l3.713"></a><span id="l3.713">     this._folderURIs[aFolderURI] = folderID;</span>
<a href="#l3.714"></a><span id="l3.714">     this._folderIDs[folderID] = aFolderURI;</span>
<a href="#l3.715"></a><span id="l3.715">     this._log.info(&quot;mapping URI &quot; + aFolderURI + &quot; to &quot; + folderID);</span>
<a href="#l3.716"></a><span id="l3.716">     return folderID;</span>
<a href="#l3.717"></a><span id="l3.717">   },</span>
<a href="#l3.718"></a><span id="l3.718">   </span>
<a href="#l3.719"></a><span id="l3.719">   _mapFolderID: function gloda_ds_mapFolderID(aFolderID) {</span>
<a href="#l3.720"></a><span id="l3.720">     if (aFolderID === null)</span>
<a href="#l3.721"></a><span id="l3.721">       return null;</span>
<a href="#l3.722"></a><span id="l3.722">     if (aFolderID in this._folderIDs)</span>
<a href="#l3.723"></a><span id="l3.723">       return this._folderIDs[aFolderID];</span>
<a href="#l3.724"></a><span id="l3.724">     throw &quot;Got impossible folder ID: &quot; + aFolderID;</span>
<a href="#l3.725"></a><span id="l3.725">   },</span>
<a href="#l3.726"></a><span id="l3.726"> </span>
<a href="#l3.727"></a><span id="l3.727">   get _updateFolderLocationStatement() {</span>
<a href="#l3.728"></a><span id="l3.728" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.729"></a><span id="l3.729" class="difflineminus">-      &quot;UPDATE folderLocations SET folderURI = :newFolderURI \</span>
<a href="#l3.730"></a><span id="l3.730" class="difflineminus">-              WHERE folderURI = :oldFolderURI&quot;);</span>
<a href="#l3.731"></a><span id="l3.731" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.732"></a><span id="l3.732" class="difflineplus">+      &quot;UPDATE folderLocations SET folderURI = ?1 \</span>
<a href="#l3.733"></a><span id="l3.733" class="difflineplus">+              WHERE folderURI = ?2&quot;);</span>
<a href="#l3.734"></a><span id="l3.734">     this.__defineGetter__(&quot;_updateFolderLocationStatement&quot;,</span>
<a href="#l3.735"></a><span id="l3.735">       function() statement);</span>
<a href="#l3.736"></a><span id="l3.736">     return this._updateFolderLocationStatement;</span>
<a href="#l3.737"></a><span id="l3.737">   },</span>
<a href="#l3.738"></a><span id="l3.738">   </span>
<a href="#l3.739"></a><span id="l3.739">   /**</span>
<a href="#l3.740"></a><span id="l3.740" class="difflineminus">-   * Non-recursive folder renaming based on the URI.</span>
<a href="#l3.741"></a><span id="l3.741" class="difflineplus">+   * Non-recursive asynchronous folder renaming based on the URI.</span>
<a href="#l3.742"></a><span id="l3.742">    *</span>
<a href="#l3.743"></a><span id="l3.743">    * @TODO provide a mechanism for recursive folder renames or have a higher</span>
<a href="#l3.744"></a><span id="l3.744">    *     layer deal with it and remove this note.</span>
<a href="#l3.745"></a><span id="l3.745">    */</span>
<a href="#l3.746"></a><span id="l3.746">   renameFolder: function gloda_ds_renameFolder(aOldURI, aNewURI) {</span>
<a href="#l3.747"></a><span id="l3.747">     let folderID = this._mapFolderURI(aOldURI); // ensure the URI is mapped...</span>
<a href="#l3.748"></a><span id="l3.748">     this._folderURIs[aNewURI] = folderID;</span>
<a href="#l3.749"></a><span id="l3.749">     this._folderIDs[folderID] = aNewURI;</span>
<a href="#l3.750"></a><span id="l3.750">     this._log.info(&quot;renaming folder URI &quot; + aOldURI + &quot; to &quot; + aNewURI);</span>
<a href="#l3.751"></a><span id="l3.751" class="difflineminus">-    this._updateFolderLocationStatement.params.oldFolderURI = aOldURI;</span>
<a href="#l3.752"></a><span id="l3.752" class="difflineminus">-    this._updateFolderLocationStatement.params.newFolderURI = aNewURI;</span>
<a href="#l3.753"></a><span id="l3.753" class="difflineminus">-    this._updateFolderLocationStatement.execute();</span>
<a href="#l3.754"></a><span id="l3.754" class="difflineplus">+    this._updateFolderLocationStatement.bindStringParameter(1, aOldURI);</span>
<a href="#l3.755"></a><span id="l3.755" class="difflineplus">+    this._updateFolderLocationStatement.bindStringParameter(0, aNewURI);</span>
<a href="#l3.756"></a><span id="l3.756" class="difflineplus">+    this._updateFolderLocationStatement.executeAsync();</span>
<a href="#l3.757"></a><span id="l3.757">     delete this._folderURIs[aOldURI];</span>
<a href="#l3.758"></a><span id="l3.758">   },</span>
<a href="#l3.759"></a><span id="l3.759">   </span>
<a href="#l3.760"></a><span id="l3.760" class="difflineplus">+  get _deleteFolderByIDStatement() {</span>
<a href="#l3.761"></a><span id="l3.761" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.762"></a><span id="l3.762" class="difflineplus">+      &quot;DELETE FROM folderLocations WHERE id = ?1&quot;);</span>
<a href="#l3.763"></a><span id="l3.763" class="difflineplus">+    this.__defineGetter__(&quot;_deleteFolderByIDStatement&quot;,</span>
<a href="#l3.764"></a><span id="l3.764" class="difflineplus">+      function() statement);</span>
<a href="#l3.765"></a><span id="l3.765" class="difflineplus">+    return this._deleteFolderByIDStatement;</span>
<a href="#l3.766"></a><span id="l3.766" class="difflineplus">+  },</span>
<a href="#l3.767"></a><span id="l3.767" class="difflineplus">+  </span>
<a href="#l3.768"></a><span id="l3.768">   deleteFolderByID: function gloda_ds_deleteFolder(aFolderID) {</span>
<a href="#l3.769"></a><span id="l3.769" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.770"></a><span id="l3.770" class="difflineminus">-      &quot;DELETE FROM folderLocations WHERE id = :id&quot;);</span>
<a href="#l3.771"></a><span id="l3.771" class="difflineminus">-    statement.params.id = aFolderID;</span>
<a href="#l3.772"></a><span id="l3.772" class="difflineminus">-    statement.execute();</span>
<a href="#l3.773"></a><span id="l3.773" class="difflineplus">+    let dfbis = this._deleteFolderByIDStatement;</span>
<a href="#l3.774"></a><span id="l3.774" class="difflineplus">+    dfbis.bindInt64Parameter(0, aFolderID);</span>
<a href="#l3.775"></a><span id="l3.775" class="difflineplus">+    dfbis.executeAsync();</span>
<a href="#l3.776"></a><span id="l3.776">   },</span>
<a href="#l3.777"></a><span id="l3.777">   </span>
<a href="#l3.778"></a><span id="l3.778">   /* ********** Conversation ********** */</span>
<a href="#l3.779"></a><span id="l3.779" class="difflineplus">+  /** The next conversation id to allocate.  Initialize at startup. */</span>
<a href="#l3.780"></a><span id="l3.780" class="difflineplus">+  _nextConversationId: 1,</span>
<a href="#l3.781"></a><span id="l3.781" class="difflineplus">+  </span>
<a href="#l3.782"></a><span id="l3.782" class="difflineplus">+  _populateConversationManagedId: function () {</span>
<a href="#l3.783"></a><span id="l3.783" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l3.784"></a><span id="l3.784" class="difflineplus">+      &quot;SELECT MAX(id) FROM conversations&quot;, true);</span>
<a href="#l3.785"></a><span id="l3.785" class="difflineplus">+    if (stmt.executeStep()) {</span>
<a href="#l3.786"></a><span id="l3.786" class="difflineplus">+      this._nextConversationId = stmt.getInt64(0) + 1;</span>
<a href="#l3.787"></a><span id="l3.787" class="difflineplus">+    }</span>
<a href="#l3.788"></a><span id="l3.788" class="difflineplus">+    stmt.finalize();</span>
<a href="#l3.789"></a><span id="l3.789" class="difflineplus">+  },</span>
<a href="#l3.790"></a><span id="l3.790" class="difflineplus">+  </span>
<a href="#l3.791"></a><span id="l3.791">   get _insertConversationStatement() {</span>
<a href="#l3.792"></a><span id="l3.792" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.793"></a><span id="l3.793" class="difflineminus">-      &quot;INSERT INTO conversations (subject, oldestMessageDate, \</span>
<a href="#l3.794"></a><span id="l3.794" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.795"></a><span id="l3.795" class="difflineplus">+      &quot;INSERT INTO conversations (id, subject, oldestMessageDate, \</span>
<a href="#l3.796"></a><span id="l3.796">                                   newestMessageDate) \</span>
<a href="#l3.797"></a><span id="l3.797" class="difflineminus">-              VALUES (:subject, :oldestMessageDate, :newestMessageDate)&quot;);</span>
<a href="#l3.798"></a><span id="l3.798" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l3.799"></a><span id="l3.799">     this.__defineGetter__(&quot;_insertConversationStatement&quot;, function() statement);</span>
<a href="#l3.800"></a><span id="l3.800">     return this._insertConversationStatement; </span>
<a href="#l3.801"></a><span id="l3.801">   }, </span>
<a href="#l3.802"></a><span id="l3.802"> </span>
<a href="#l3.803"></a><span id="l3.803">   get _insertConversationTextStatement() {</span>
<a href="#l3.804"></a><span id="l3.804" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.805"></a><span id="l3.805" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.806"></a><span id="l3.806">       &quot;INSERT INTO conversationsText (docid, subject) \</span>
<a href="#l3.807"></a><span id="l3.807" class="difflineminus">-              VALUES (:docid, :subject)&quot;);</span>
<a href="#l3.808"></a><span id="l3.808" class="difflineplus">+              VALUES (?1, ?2)&quot;);</span>
<a href="#l3.809"></a><span id="l3.809">     this.__defineGetter__(&quot;_insertConversationTextStatement&quot;,</span>
<a href="#l3.810"></a><span id="l3.810">       function() statement);</span>
<a href="#l3.811"></a><span id="l3.811">     return this._insertConversationTextStatement; </span>
<a href="#l3.812"></a><span id="l3.812">   }, </span>
<a href="#l3.813"></a><span id="l3.813" class="difflineminus">-</span>
<a href="#l3.814"></a><span id="l3.814">   </span>
<a href="#l3.815"></a><span id="l3.815">   /**</span>
<a href="#l3.816"></a><span id="l3.816" class="difflineminus">-   * Create a conversation.</span>
<a href="#l3.817"></a><span id="l3.817" class="difflineplus">+   * Asynchronously create a conversation.</span>
<a href="#l3.818"></a><span id="l3.818">    */</span>
<a href="#l3.819"></a><span id="l3.819">   createConversation: function gloda_ds_createConversation(aSubject,</span>
<a href="#l3.820"></a><span id="l3.820">         aOldestMessageDate, aNewestMessageDate) {</span>
<a href="#l3.821"></a><span id="l3.821"> </span>
<a href="#l3.822"></a><span id="l3.822">     // create the data row    </span>
<a href="#l3.823"></a><span id="l3.823" class="difflineplus">+    let conversationID = this._nextConversationId++;</span>
<a href="#l3.824"></a><span id="l3.824">     let ics = this._insertConversationStatement;</span>
<a href="#l3.825"></a><span id="l3.825" class="difflineminus">-    ics.params.subject = aSubject;</span>
<a href="#l3.826"></a><span id="l3.826" class="difflineminus">-    ics.params.oldestMessageDate = aOldestMessageDate;</span>
<a href="#l3.827"></a><span id="l3.827" class="difflineminus">-    ics.params.newestMessageDate = aNewestMessageDate;</span>
<a href="#l3.828"></a><span id="l3.828" class="difflineminus">-    ics.execute();</span>
<a href="#l3.829"></a><span id="l3.829" class="difflineminus">-    </span>
<a href="#l3.830"></a><span id="l3.830" class="difflineminus">-    let conversationID = this.dbConnection.lastInsertRowID; </span>
<a href="#l3.831"></a><span id="l3.831" class="difflineplus">+    ics.bindInt64Parameter(0, conversationID);</span>
<a href="#l3.832"></a><span id="l3.832" class="difflineplus">+    ics.bindStringParameter(1, aSubject);</span>
<a href="#l3.833"></a><span id="l3.833" class="difflineplus">+    if (aOldestMessageDate == null)</span>
<a href="#l3.834"></a><span id="l3.834" class="difflineplus">+      ics.bindNullParameter(2);</span>
<a href="#l3.835"></a><span id="l3.835" class="difflineplus">+    else</span>
<a href="#l3.836"></a><span id="l3.836" class="difflineplus">+      ics.bindInt64Parameter(2, aOldestMessageDate);</span>
<a href="#l3.837"></a><span id="l3.837" class="difflineplus">+    if (aNewestMessageDate == null)</span>
<a href="#l3.838"></a><span id="l3.838" class="difflineplus">+      ics.bindNullParameter(3);</span>
<a href="#l3.839"></a><span id="l3.839" class="difflineplus">+    else</span>
<a href="#l3.840"></a><span id="l3.840" class="difflineplus">+      ics.bindInt64Parameter(3, aNewestMessageDate);</span>
<a href="#l3.841"></a><span id="l3.841" class="difflineplus">+    ics.executeAsync();</span>
<a href="#l3.842"></a><span id="l3.842">     </span>
<a href="#l3.843"></a><span id="l3.843">     // create the fulltext row, using the same rowid/docid</span>
<a href="#l3.844"></a><span id="l3.844">     let icts = this._insertConversationTextStatement;</span>
<a href="#l3.845"></a><span id="l3.845" class="difflineminus">-    icts.params.docid = conversationID;</span>
<a href="#l3.846"></a><span id="l3.846" class="difflineminus">-    icts.params.subject = aSubject;</span>
<a href="#l3.847"></a><span id="l3.847" class="difflineminus">-    icts.execute();</span>
<a href="#l3.848"></a><span id="l3.848" class="difflineplus">+    icts.bindInt64Parameter(0, conversationID);</span>
<a href="#l3.849"></a><span id="l3.849" class="difflineplus">+    icts.bindStringParameter(1, aSubject);</span>
<a href="#l3.850"></a><span id="l3.850" class="difflineplus">+    icts.executeAsync();</span>
<a href="#l3.851"></a><span id="l3.851">     </span>
<a href="#l3.852"></a><span id="l3.852">     // create it</span>
<a href="#l3.853"></a><span id="l3.853">     let conversation = new GlodaConversation(this, conversationID,</span>
<a href="#l3.854"></a><span id="l3.854">                                  aSubject, aOldestMessageDate,</span>
<a href="#l3.855"></a><span id="l3.855">                                  aNewestMessageDate);</span>
<a href="#l3.856"></a><span id="l3.856">     // it's new! let the collection manager know about it.</span>
<a href="#l3.857"></a><span id="l3.857">     GlodaCollectionManager.itemsAdded(conversation.NOUN_ID, [conversation]);</span>
<a href="#l3.858"></a><span id="l3.858">     // return it</span>
<a href="#l3.859"></a><span id="l3.859">     return conversation;</span>
<a href="#l3.860"></a><span id="l3.860">   },</span>
<a href="#l3.861"></a><span id="l3.861"> </span>
<a href="#l3.862"></a><span id="l3.862">   get _deleteConversationByIDStatement() {</span>
<a href="#l3.863"></a><span id="l3.863" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.864"></a><span id="l3.864" class="difflineminus">-      &quot;DELETE FROM conversations WHERE id = :conversationID&quot;);</span>
<a href="#l3.865"></a><span id="l3.865" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.866"></a><span id="l3.866" class="difflineplus">+      &quot;DELETE FROM conversations WHERE id = ?1&quot;);</span>
<a href="#l3.867"></a><span id="l3.867">     this.__defineGetter__(&quot;_deleteConversationByIDStatement&quot;,</span>
<a href="#l3.868"></a><span id="l3.868">                           function() statement);</span>
<a href="#l3.869"></a><span id="l3.869">     return this._deleteConversationByIDStatement; </span>
<a href="#l3.870"></a><span id="l3.870">   },</span>
<a href="#l3.871"></a><span id="l3.871"> </span>
<a href="#l3.872"></a><span id="l3.872" class="difflineplus">+  /**</span>
<a href="#l3.873"></a><span id="l3.873" class="difflineplus">+   * Asynchronously delete a conversation given its ID.</span>
<a href="#l3.874"></a><span id="l3.874" class="difflineplus">+   */</span>
<a href="#l3.875"></a><span id="l3.875">   deleteConversationByID: function gloda_ds_deleteConversationByID(</span>
<a href="#l3.876"></a><span id="l3.876">                                       aConversationID) {</span>
<a href="#l3.877"></a><span id="l3.877">     let dcbids = this._deleteConversationByIDStatement;</span>
<a href="#l3.878"></a><span id="l3.878" class="difflineminus">-    dcbids.params.conversationID = aConversationID;</span>
<a href="#l3.879"></a><span id="l3.879" class="difflineminus">-    dcbids.execute();</span>
<a href="#l3.880"></a><span id="l3.880" class="difflineplus">+    dcbids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l3.881"></a><span id="l3.881" class="difflineplus">+    dcbids.executeAsync();</span>
<a href="#l3.882"></a><span id="l3.882">     </span>
<a href="#l3.883"></a><span id="l3.883">     // TODO: collection manager implications</span>
<a href="#l3.884"></a><span id="l3.884">     GlodaCollectionManager.removeByID()</span>
<a href="#l3.885"></a><span id="l3.885">   },</span>
<a href="#l3.886"></a><span id="l3.886"> </span>
<a href="#l3.887"></a><span id="l3.887">   get _selectConversationByIDStatement() {</span>
<a href="#l3.888"></a><span id="l3.888" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.889"></a><span id="l3.889" class="difflineminus">-      &quot;SELECT * FROM conversations WHERE id = :conversationID&quot;);</span>
<a href="#l3.890"></a><span id="l3.890" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.891"></a><span id="l3.891" class="difflineplus">+      &quot;SELECT id, subject, oldestMessageDate, newestMessageDate \</span>
<a href="#l3.892"></a><span id="l3.892" class="difflineplus">+         FROM conversations WHERE id = ?1&quot;);</span>
<a href="#l3.893"></a><span id="l3.893">     this.__defineGetter__(&quot;_selectConversationByIDStatement&quot;,</span>
<a href="#l3.894"></a><span id="l3.894">       function() statement);</span>
<a href="#l3.895"></a><span id="l3.895">     return this._selectConversationByIDStatement;</span>
<a href="#l3.896"></a><span id="l3.896">   }, </span>
<a href="#l3.897"></a><span id="l3.897"> </span>
<a href="#l3.898"></a><span id="l3.898" class="difflineminus">-  _conversationFromRow: function gloda_ds_conversationFromRow(aRow) {</span>
<a href="#l3.899"></a><span id="l3.899" class="difflineminus">-      return new GlodaConversation(this, aRow[&quot;id&quot;],</span>
<a href="#l3.900"></a><span id="l3.900" class="difflineminus">-        aRow[&quot;subject&quot;], aRow[&quot;oldestMessageDate&quot;], aRow[&quot;newestMessageDate&quot;]);  </span>
<a href="#l3.901"></a><span id="l3.901" class="difflineplus">+  _conversationFromRow: function gloda_ds_conversationFromRow(aStmt) {</span>
<a href="#l3.902"></a><span id="l3.902" class="difflineplus">+      let oldestMessageDate, newestMessageDate;</span>
<a href="#l3.903"></a><span id="l3.903" class="difflineplus">+      if (aStmt.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.904"></a><span id="l3.904" class="difflineplus">+        oldestMessageDate = null;</span>
<a href="#l3.905"></a><span id="l3.905" class="difflineplus">+      else</span>
<a href="#l3.906"></a><span id="l3.906" class="difflineplus">+        oldestMessageDate = aStmt.getInt64(2);</span>
<a href="#l3.907"></a><span id="l3.907" class="difflineplus">+      if (aStmt.getTypeOfIndex(3) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.908"></a><span id="l3.908" class="difflineplus">+        newestMessageDate = null;</span>
<a href="#l3.909"></a><span id="l3.909" class="difflineplus">+      else</span>
<a href="#l3.910"></a><span id="l3.910" class="difflineplus">+        newestMessageDate = aStmt.getInt64(3);</span>
<a href="#l3.911"></a><span id="l3.911" class="difflineplus">+      return new GlodaConversation(this, aStmt.getInt64(0),</span>
<a href="#l3.912"></a><span id="l3.912" class="difflineplus">+        aStmt.getString(1), oldestMessageDate, newestMessageDate);  </span>
<a href="#l3.913"></a><span id="l3.913">   },</span>
<a href="#l3.914"></a><span id="l3.914"> </span>
<a href="#l3.915"></a><span id="l3.915" class="difflineplus">+  /**</span>
<a href="#l3.916"></a><span id="l3.916" class="difflineplus">+   * Synchronously look up a conversation given its ID.</span>
<a href="#l3.917"></a><span id="l3.917" class="difflineplus">+   */</span>
<a href="#l3.918"></a><span id="l3.918">   getConversationByID: function gloda_ds_getConversationByID(aConversationID) {</span>
<a href="#l3.919"></a><span id="l3.919">     let conversation = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l3.920"></a><span id="l3.920">       GlodaConversation.prototype.NOUN_ID, aConversationID);</span>
<a href="#l3.921"></a><span id="l3.921"> </span>
<a href="#l3.922"></a><span id="l3.922">     if (conversation === null) {</span>
<a href="#l3.923"></a><span id="l3.923">       let scbids = this._selectConversationByIDStatement;</span>
<a href="#l3.924"></a><span id="l3.924">       </span>
<a href="#l3.925"></a><span id="l3.925" class="difflineminus">-      scbids.params.conversationID = aConversationID;</span>
<a href="#l3.926"></a><span id="l3.926" class="difflineminus">-      if (scbids.step()) {</span>
<a href="#l3.927"></a><span id="l3.927" class="difflineplus">+      scbids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l3.928"></a><span id="l3.928" class="difflineplus">+      if (scbids.executeStep()) {</span>
<a href="#l3.929"></a><span id="l3.929">         conversation = this._conversationFromRow(scbids.row);</span>
<a href="#l3.930"></a><span id="l3.930">         GlodaCollectionManager.itemLoaded(conversation);</span>
<a href="#l3.931"></a><span id="l3.931">       }</span>
<a href="#l3.932"></a><span id="l3.932">       scbids.reset();</span>
<a href="#l3.933"></a><span id="l3.933">     }</span>
<a href="#l3.934"></a><span id="l3.934">     </span>
<a href="#l3.935"></a><span id="l3.935">     return conversation;</span>
<a href="#l3.936"></a><span id="l3.936">   },</span>
<a href="#l3.937"></a><span id="l3.937">   </span>
<a href="#l3.938"></a><span id="l3.938">   /* ********** Message ********** */</span>
<a href="#l3.939"></a><span id="l3.939" class="difflineplus">+  /**</span>
<a href="#l3.940"></a><span id="l3.940" class="difflineplus">+   * Next message id, managed because of our use of asynchronous inserts.</span>
<a href="#l3.941"></a><span id="l3.941" class="difflineplus">+   * Initialized by _populateMessageManagedId called by _init.</span>
<a href="#l3.942"></a><span id="l3.942" class="difflineplus">+   */</span>
<a href="#l3.943"></a><span id="l3.943" class="difflineplus">+  _nextMessageId: 1,</span>
<a href="#l3.944"></a><span id="l3.944" class="difflineplus">+  </span>
<a href="#l3.945"></a><span id="l3.945" class="difflineplus">+  _populateMessageManagedId: function () {</span>
<a href="#l3.946"></a><span id="l3.946" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l3.947"></a><span id="l3.947" class="difflineplus">+      &quot;SELECT MAX(id) FROM messages&quot;, true);</span>
<a href="#l3.948"></a><span id="l3.948" class="difflineplus">+    if (stmt.executeStep()) {</span>
<a href="#l3.949"></a><span id="l3.949" class="difflineplus">+      this._nextMessageId = stmt.getInt64(0) + 1;</span>
<a href="#l3.950"></a><span id="l3.950" class="difflineplus">+    }</span>
<a href="#l3.951"></a><span id="l3.951" class="difflineplus">+    stmt.finalize();</span>
<a href="#l3.952"></a><span id="l3.952" class="difflineplus">+  },</span>
<a href="#l3.953"></a><span id="l3.953" class="difflineplus">+  </span>
<a href="#l3.954"></a><span id="l3.954">   get _insertMessageStatement() {</span>
<a href="#l3.955"></a><span id="l3.955" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.956"></a><span id="l3.956" class="difflineminus">-      &quot;INSERT INTO messages (folderID, messageKey, conversationID, date, \</span>
<a href="#l3.957"></a><span id="l3.957" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.958"></a><span id="l3.958" class="difflineplus">+      &quot;INSERT INTO messages (id, folderID, messageKey, conversationID, date, \</span>
<a href="#l3.959"></a><span id="l3.959">                              headerMessageID) \</span>
<a href="#l3.960"></a><span id="l3.960" class="difflineminus">-              VALUES (:folderID, :messageKey, :conversationID, :date, \</span>
<a href="#l3.961"></a><span id="l3.961" class="difflineminus">-                      :headerMessageID)&quot;);</span>
<a href="#l3.962"></a><span id="l3.962" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l3.963"></a><span id="l3.963">     this.__defineGetter__(&quot;_insertMessageStatement&quot;, function() statement);</span>
<a href="#l3.964"></a><span id="l3.964">     return this._insertMessageStatement; </span>
<a href="#l3.965"></a><span id="l3.965">   }, </span>
<a href="#l3.966"></a><span id="l3.966"> </span>
<a href="#l3.967"></a><span id="l3.967">   get _insertMessageTextStatement() {</span>
<a href="#l3.968"></a><span id="l3.968" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.969"></a><span id="l3.969" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.970"></a><span id="l3.970">       &quot;INSERT INTO messagesText (docid, body) \</span>
<a href="#l3.971"></a><span id="l3.971" class="difflineminus">-              VALUES (:docid, :body)&quot;);</span>
<a href="#l3.972"></a><span id="l3.972" class="difflineplus">+              VALUES (?1, ?2)&quot;);</span>
<a href="#l3.973"></a><span id="l3.973">     this.__defineGetter__(&quot;_insertMessageTextStatement&quot;, function() statement);</span>
<a href="#l3.974"></a><span id="l3.974">     return this._insertMessageTextStatement; </span>
<a href="#l3.975"></a><span id="l3.975">   },</span>
<a href="#l3.976"></a><span id="l3.976">   </span>
<a href="#l3.977"></a><span id="l3.977">   /**</span>
<a href="#l3.978"></a><span id="l3.978" class="difflineplus">+   * Create a GlodaMessage with the given properties.  Because this is only half</span>
<a href="#l3.979"></a><span id="l3.979" class="difflineplus">+   *  of the process of creating a message (the attributes still need to be</span>
<a href="#l3.980"></a><span id="l3.980" class="difflineplus">+   *  completed), it's on the caller's head to call GlodaCollectionManager's</span>
<a href="#l3.981"></a><span id="l3.981" class="difflineplus">+   *  itemAdded method once the message is fully created.</span>
<a href="#l3.982"></a><span id="l3.982">    *</span>
<a href="#l3.983"></a><span id="l3.983" class="difflineplus">+   * This method uses the async connection, any downstream logic that depends on</span>
<a href="#l3.984"></a><span id="l3.984" class="difflineplus">+   *  this message actually existing in the database must be done using an</span>
<a href="#l3.985"></a><span id="l3.985" class="difflineplus">+   *  async query.</span>
<a href="#l3.986"></a><span id="l3.986">    */</span>
<a href="#l3.987"></a><span id="l3.987">   createMessage: function gloda_ds_createMessage(aFolderURI, aMessageKey,</span>
<a href="#l3.988"></a><span id="l3.988">                               aConversationID, aDatePRTime, aHeaderMessageID,</span>
<a href="#l3.989"></a><span id="l3.989">                               aBody) {</span>
<a href="#l3.990"></a><span id="l3.990">     let folderID;</span>
<a href="#l3.991"></a><span id="l3.991">     if (aFolderURI != null) {</span>
<a href="#l3.992"></a><span id="l3.992">       folderID = this._mapFolderURI(aFolderURI);</span>
<a href="#l3.993"></a><span id="l3.993">     }</span>
<a href="#l3.994"></a><span id="l3.994">     else {</span>
<a href="#l3.995"></a><span id="l3.995">       folderID = null;</span>
<a href="#l3.996"></a><span id="l3.996">     }</span>
<a href="#l3.997"></a><span id="l3.997" class="difflineplus">+</span>
<a href="#l3.998"></a><span id="l3.998" class="difflineplus">+    let messageID = this._nextMessageId++;</span>
<a href="#l3.999"></a><span id="l3.999">     </span>
<a href="#l3.1000"></a><span id="l3.1000">     let ims = this._insertMessageStatement;</span>
<a href="#l3.1001"></a><span id="l3.1001" class="difflineminus">-    ims.params.folderID = folderID;</span>
<a href="#l3.1002"></a><span id="l3.1002" class="difflineminus">-    ims.params.messageKey = aMessageKey;</span>
<a href="#l3.1003"></a><span id="l3.1003" class="difflineminus">-    ims.params.conversationID = aConversationID;</span>
<a href="#l3.1004"></a><span id="l3.1004" class="difflineminus">-    ims.params.date = aDatePRTime;</span>
<a href="#l3.1005"></a><span id="l3.1005" class="difflineminus">-    ims.params.headerMessageID = aHeaderMessageID;</span>
<a href="#l3.1006"></a><span id="l3.1006" class="difflineplus">+    ims.bindInt64Parameter(0, messageID);</span>
<a href="#l3.1007"></a><span id="l3.1007" class="difflineplus">+    if (folderID === null)</span>
<a href="#l3.1008"></a><span id="l3.1008" class="difflineplus">+      ims.bindNullParameter(1);</span>
<a href="#l3.1009"></a><span id="l3.1009" class="difflineplus">+    else</span>
<a href="#l3.1010"></a><span id="l3.1010" class="difflineplus">+      ims.bindInt64Parameter(1, folderID);</span>
<a href="#l3.1011"></a><span id="l3.1011" class="difflineplus">+    if (aMessageKey === null)</span>
<a href="#l3.1012"></a><span id="l3.1012" class="difflineplus">+      ims.bindNullParameter(2);</span>
<a href="#l3.1013"></a><span id="l3.1013" class="difflineplus">+    else</span>
<a href="#l3.1014"></a><span id="l3.1014" class="difflineplus">+      ims.bindInt64Parameter(2, aMessageKey);</span>
<a href="#l3.1015"></a><span id="l3.1015" class="difflineplus">+    ims.bindInt64Parameter(3, aConversationID);</span>
<a href="#l3.1016"></a><span id="l3.1016" class="difflineplus">+    if (aDatePRTime === null)</span>
<a href="#l3.1017"></a><span id="l3.1017" class="difflineplus">+      ims.bindNullParameter(4);</span>
<a href="#l3.1018"></a><span id="l3.1018" class="difflineplus">+    else</span>
<a href="#l3.1019"></a><span id="l3.1019" class="difflineplus">+      ims.bindInt64Parameter(4, aDatePRTime);</span>
<a href="#l3.1020"></a><span id="l3.1020" class="difflineplus">+    ims.bindStringParameter(5, aHeaderMessageID);</span>
<a href="#l3.1021"></a><span id="l3.1021"> </span>
<a href="#l3.1022"></a><span id="l3.1022">     try {</span>
<a href="#l3.1023"></a><span id="l3.1023" class="difflineminus">-       ims.execute();</span>
<a href="#l3.1024"></a><span id="l3.1024" class="difflineplus">+       ims.executeAsync();</span>
<a href="#l3.1025"></a><span id="l3.1025">     }</span>
<a href="#l3.1026"></a><span id="l3.1026">     catch(ex) {</span>
<a href="#l3.1027"></a><span id="l3.1027">        throw(&quot;error executing statement... &quot; +</span>
<a href="#l3.1028"></a><span id="l3.1028" class="difflineminus">-             this.dbConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.1029"></a><span id="l3.1029" class="difflineminus">-             this.dbConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.1030"></a><span id="l3.1030" class="difflineplus">+             this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.1031"></a><span id="l3.1031" class="difflineplus">+             this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.1032"></a><span id="l3.1032">     }</span>
<a href="#l3.1033"></a><span id="l3.1033" class="difflineminus">-    </span>
<a href="#l3.1034"></a><span id="l3.1034" class="difflineminus">-    let messageID = this.dbConnection.lastInsertRowID;</span>
<a href="#l3.1035"></a><span id="l3.1035" class="difflineplus">+</span>
<a href="#l3.1036"></a><span id="l3.1036" class="difflineplus">+    this._log.debug(&quot;CreateMessage: &quot; + folderID + &quot;, &quot; + aMessageKey + &quot;, &quot; +</span>
<a href="#l3.1037"></a><span id="l3.1037" class="difflineplus">+                    aConversationID + &quot;, &quot; + aDatePRTime + &quot;, &quot; +</span>
<a href="#l3.1038"></a><span id="l3.1038" class="difflineplus">+                    aHeaderMessageID); </span>
<a href="#l3.1039"></a><span id="l3.1039">     </span>
<a href="#l3.1040"></a><span id="l3.1040">     // we only create the full-text row if the body is non-null.</span>
<a href="#l3.1041"></a><span id="l3.1041">     // so, even though body might be null, we still want to create the</span>
<a href="#l3.1042"></a><span id="l3.1042">     //  full-text search row</span>
<a href="#l3.1043"></a><span id="l3.1043">     if (aBody) {</span>
<a href="#l3.1044"></a><span id="l3.1044">       let imts = this._insertMessageTextStatement;</span>
<a href="#l3.1045"></a><span id="l3.1045" class="difflineminus">-      imts.params.docid = messageID;</span>
<a href="#l3.1046"></a><span id="l3.1046" class="difflineminus">-      imts.params.body = aBody;</span>
<a href="#l3.1047"></a><span id="l3.1047" class="difflineplus">+      imts.bindInt64Parameter(0, messageID);</span>
<a href="#l3.1048"></a><span id="l3.1048" class="difflineplus">+      imts.bindStringParameter(1, aBody);</span>
<a href="#l3.1049"></a><span id="l3.1049">       </span>
<a href="#l3.1050"></a><span id="l3.1050">       try {</span>
<a href="#l3.1051"></a><span id="l3.1051" class="difflineminus">-         imts.execute();</span>
<a href="#l3.1052"></a><span id="l3.1052" class="difflineplus">+         imts.executeAsync();</span>
<a href="#l3.1053"></a><span id="l3.1053">       }</span>
<a href="#l3.1054"></a><span id="l3.1054">       catch(ex) {</span>
<a href="#l3.1055"></a><span id="l3.1055">          throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l3.1056"></a><span id="l3.1056" class="difflineminus">-               this.dbConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.1057"></a><span id="l3.1057" class="difflineminus">-               this.dbConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.1058"></a><span id="l3.1058" class="difflineplus">+               this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l3.1059"></a><span id="l3.1059" class="difflineplus">+               this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l3.1060"></a><span id="l3.1060">       }</span>
<a href="#l3.1061"></a><span id="l3.1061">     }</span>
<a href="#l3.1062"></a><span id="l3.1062">     </span>
<a href="#l3.1063"></a><span id="l3.1063">     let message = new GlodaMessage(this, messageID, folderID,</span>
<a href="#l3.1064"></a><span id="l3.1064">                             aMessageKey, aConversationID, null,</span>
<a href="#l3.1065"></a><span id="l3.1065">                             aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l3.1066"></a><span id="l3.1066">                             aHeaderMessageID);</span>
<a href="#l3.1067"></a><span id="l3.1067">     </span>
<a href="#l3.1068"></a><span id="l3.1068" class="difflineat">@@ -920,272 +1204,277 @@ let GlodaDatastore = {</span>
<a href="#l3.1069"></a><span id="l3.1069">     //  point (at least if it's not a ghost), but we can't yet.  We need to wait</span>
<a href="#l3.1070"></a><span id="l3.1070">     //  until the attributes have been indexed, which means it's out of our</span>
<a href="#l3.1071"></a><span id="l3.1071">     //  hands.  (Gloda.processMessage does it.)</span>
<a href="#l3.1072"></a><span id="l3.1072">     </span>
<a href="#l3.1073"></a><span id="l3.1073">     return message;</span>
<a href="#l3.1074"></a><span id="l3.1074">   },</span>
<a href="#l3.1075"></a><span id="l3.1075">   </span>
<a href="#l3.1076"></a><span id="l3.1076">   get _updateMessageStatement() {</span>
<a href="#l3.1077"></a><span id="l3.1077" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1078"></a><span id="l3.1078" class="difflineminus">-      &quot;UPDATE messages SET folderID = :folderID, \</span>
<a href="#l3.1079"></a><span id="l3.1079" class="difflineminus">-                           messageKey = :messageKey, \</span>
<a href="#l3.1080"></a><span id="l3.1080" class="difflineminus">-                           conversationID = :conversationID, \</span>
<a href="#l3.1081"></a><span id="l3.1081" class="difflineminus">-                           date = :date, \</span>
<a href="#l3.1082"></a><span id="l3.1082" class="difflineminus">-                           headerMessageID = :headerMessageID \</span>
<a href="#l3.1083"></a><span id="l3.1083" class="difflineminus">-              WHERE id = :id&quot;);</span>
<a href="#l3.1084"></a><span id="l3.1084" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.1085"></a><span id="l3.1085" class="difflineplus">+      &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l3.1086"></a><span id="l3.1086" class="difflineplus">+                           messageKey = ?2, \</span>
<a href="#l3.1087"></a><span id="l3.1087" class="difflineplus">+                           conversationID = ?3, \</span>
<a href="#l3.1088"></a><span id="l3.1088" class="difflineplus">+                           date = ?4, \</span>
<a href="#l3.1089"></a><span id="l3.1089" class="difflineplus">+                           headerMessageID = ?5 \</span>
<a href="#l3.1090"></a><span id="l3.1090" class="difflineplus">+              WHERE id = ?6&quot;);</span>
<a href="#l3.1091"></a><span id="l3.1091">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l3.1092"></a><span id="l3.1092">     return this._updateMessageStatement;</span>
<a href="#l3.1093"></a><span id="l3.1093">   }, </span>
<a href="#l3.1094"></a><span id="l3.1094">   </span>
<a href="#l3.1095"></a><span id="l3.1095">   /**</span>
<a href="#l3.1096"></a><span id="l3.1096">    * Update the database row associated with the message.  If aBody is supplied,</span>
<a href="#l3.1097"></a><span id="l3.1097">    *  the associated full-text row is created; it is assumed that it did not</span>
<a href="#l3.1098"></a><span id="l3.1098">    *  previously exist.</span>
<a href="#l3.1099"></a><span id="l3.1099">    */</span>
<a href="#l3.1100"></a><span id="l3.1100">   updateMessage: function gloda_ds_updateMessage(aMessage, aBody) {</span>
<a href="#l3.1101"></a><span id="l3.1101">     let ums = this._updateMessageStatement;</span>
<a href="#l3.1102"></a><span id="l3.1102" class="difflineminus">-    ums.params.id = aMessage.id;</span>
<a href="#l3.1103"></a><span id="l3.1103" class="difflineminus">-    ums.params.folderID = aMessage.folderID;</span>
<a href="#l3.1104"></a><span id="l3.1104" class="difflineminus">-    ums.params.messageKey = aMessage.messageKey;</span>
<a href="#l3.1105"></a><span id="l3.1105" class="difflineminus">-    ums.params.conversationID = aMessage.conversationID;</span>
<a href="#l3.1106"></a><span id="l3.1106" class="difflineminus">-    ums.params.date = aMessage.date * 1000;</span>
<a href="#l3.1107"></a><span id="l3.1107" class="difflineminus">-    ums.params.headerMessageID = aMessage.headerMessageID;</span>
<a href="#l3.1108"></a><span id="l3.1108" class="difflineplus">+    ums.bindInt64Parameter(5, aMessage.id);</span>
<a href="#l3.1109"></a><span id="l3.1109" class="difflineplus">+    if (aMessage.folderID === null)</span>
<a href="#l3.1110"></a><span id="l3.1110" class="difflineplus">+      ums.bindNullParameter(0);</span>
<a href="#l3.1111"></a><span id="l3.1111" class="difflineplus">+    else</span>
<a href="#l3.1112"></a><span id="l3.1112" class="difflineplus">+      ums.bindInt64Parameter(0, aMessage.folderID);</span>
<a href="#l3.1113"></a><span id="l3.1113" class="difflineplus">+    if (aMessage.messageKey === null)</span>
<a href="#l3.1114"></a><span id="l3.1114" class="difflineplus">+      ums.bindNullParameter(1);</span>
<a href="#l3.1115"></a><span id="l3.1115" class="difflineplus">+    else</span>
<a href="#l3.1116"></a><span id="l3.1116" class="difflineplus">+      ums.bindInt64Parameter(1, aMessage.messageKey);</span>
<a href="#l3.1117"></a><span id="l3.1117" class="difflineplus">+    ums.bindInt64Parameter(2, aMessage.conversationID);</span>
<a href="#l3.1118"></a><span id="l3.1118" class="difflineplus">+    if (aMessage.date === null)</span>
<a href="#l3.1119"></a><span id="l3.1119" class="difflineplus">+      ums.bindNullParameter(3);</span>
<a href="#l3.1120"></a><span id="l3.1120" class="difflineplus">+    else</span>
<a href="#l3.1121"></a><span id="l3.1121" class="difflineplus">+      ums.bindInt64Parameter(3, aMessage.date * 1000);</span>
<a href="#l3.1122"></a><span id="l3.1122" class="difflineplus">+    ums.bindStringParameter(4, aMessage.headerMessageID);</span>
<a href="#l3.1123"></a><span id="l3.1123">     </span>
<a href="#l3.1124"></a><span id="l3.1124" class="difflineminus">-    ums.execute();</span>
<a href="#l3.1125"></a><span id="l3.1125" class="difflineplus">+    ums.executeAsync();</span>
<a href="#l3.1126"></a><span id="l3.1126">     </span>
<a href="#l3.1127"></a><span id="l3.1127">     if (aBody) {</span>
<a href="#l3.1128"></a><span id="l3.1128">       let imts = this._insertMessageTextStatement;</span>
<a href="#l3.1129"></a><span id="l3.1129" class="difflineminus">-      imts.params.docid = aMessage.id;</span>
<a href="#l3.1130"></a><span id="l3.1130" class="difflineminus">-      imts.params.body = aBody;</span>
<a href="#l3.1131"></a><span id="l3.1131" class="difflineplus">+      imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l3.1132"></a><span id="l3.1132" class="difflineplus">+      imts.bindStringParameter(1, aBody);</span>
<a href="#l3.1133"></a><span id="l3.1133">       </span>
<a href="#l3.1134"></a><span id="l3.1134" class="difflineminus">-      imts.execute();</span>
<a href="#l3.1135"></a><span id="l3.1135" class="difflineplus">+      imts.executeAsync();</span>
<a href="#l3.1136"></a><span id="l3.1136">     }</span>
<a href="#l3.1137"></a><span id="l3.1137">     </span>
<a href="#l3.1138"></a><span id="l3.1138">     // In completely abstract theory, this is where we would call</span>
<a href="#l3.1139"></a><span id="l3.1139">     //  GlodaCollectionManager.itemsModified, except that the attributes may</span>
<a href="#l3.1140"></a><span id="l3.1140">     //  also have changed, so it's out of our hands.  (Gloda.processMessage</span>
<a href="#l3.1141"></a><span id="l3.1141">     //  handles it.)</span>
<a href="#l3.1142"></a><span id="l3.1142">   },</span>
<a href="#l3.1143"></a><span id="l3.1143"> </span>
<a href="#l3.1144"></a><span id="l3.1144" class="difflineplus">+  /**</span>
<a href="#l3.1145"></a><span id="l3.1145" class="difflineplus">+   * Asynchronously mutate message folder id/message keys for the given</span>
<a href="#l3.1146"></a><span id="l3.1146" class="difflineplus">+   *  messages, indicating that we are moving them to the target folder, but</span>
<a href="#l3.1147"></a><span id="l3.1147" class="difflineplus">+   *  don't yet know their target message keys.</span>
<a href="#l3.1148"></a><span id="l3.1148" class="difflineplus">+   */</span>
<a href="#l3.1149"></a><span id="l3.1149">   updateMessageFoldersByKeyPurging:</span>
<a href="#l3.1150"></a><span id="l3.1150">       function gloda_ds_updateMessageFoldersByKeyPurging(aSrcFolderURI,</span>
<a href="#l3.1151"></a><span id="l3.1151">         aMessageKeys, aDestFolderURI) {</span>
<a href="#l3.1152"></a><span id="l3.1152">     let srcFolderID = this._mapFolderURI(aSrcFolderURI);</span>
<a href="#l3.1153"></a><span id="l3.1153">     let destFolderID = this._mapFolderURI(aDestFolderURI);</span>
<a href="#l3.1154"></a><span id="l3.1154">     </span>
<a href="#l3.1155"></a><span id="l3.1155" class="difflineminus">-    let sqlStr = &quot;UPDATE messages SET folderID = :newFolderID, \</span>
<a href="#l3.1156"></a><span id="l3.1156" class="difflineminus">-                                      messageKey = :nullMsgKey \</span>
<a href="#l3.1157"></a><span id="l3.1157" class="difflineminus">-                   WHERE folderID = :id \</span>
<a href="#l3.1158"></a><span id="l3.1158" class="difflineplus">+    let sqlStr = &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l3.1159"></a><span id="l3.1159" class="difflineplus">+                                      messageKey = ?2 \</span>
<a href="#l3.1160"></a><span id="l3.1160" class="difflineplus">+                   WHERE folderID = ?3 \</span>
<a href="#l3.1161"></a><span id="l3.1161">                      AND messageKey IN (&quot; + aMessageKeys.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l3.1162"></a><span id="l3.1162" class="difflineminus">-    let statement = this._createStatement(sqlStr);</span>
<a href="#l3.1163"></a><span id="l3.1163" class="difflineminus">-    statement.params.id = srcFolderID;</span>
<a href="#l3.1164"></a><span id="l3.1164" class="difflineminus">-    statement.params.newFolderID = destFolderID;</span>
<a href="#l3.1165"></a><span id="l3.1165" class="difflineminus">-    statement.params.nullMsgKey = null;</span>
<a href="#l3.1166"></a><span id="l3.1166" class="difflineminus">-    statement.execute();</span>
<a href="#l3.1167"></a><span id="l3.1167" class="difflineplus">+    let statement = this._createAsyncStatement(sqlStr);</span>
<a href="#l3.1168"></a><span id="l3.1168" class="difflineplus">+    statement.bindInt64Parameter(2, srcFolderID);</span>
<a href="#l3.1169"></a><span id="l3.1169" class="difflineplus">+    statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l3.1170"></a><span id="l3.1170" class="difflineplus">+    statement.bindNullParameter(1);</span>
<a href="#l3.1171"></a><span id="l3.1171" class="difflineplus">+    statement.executeAsync();</span>
<a href="#l3.1172"></a><span id="l3.1172">   },</span>
<a href="#l3.1173"></a><span id="l3.1173">   </span>
<a href="#l3.1174"></a><span id="l3.1174">   _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l3.1175"></a><span id="l3.1175" class="difflineminus">-    let datePRTime = aRow[&quot;date&quot;];</span>
<a href="#l3.1176"></a><span id="l3.1176" class="difflineminus">-    return new GlodaMessage(this, aRow[&quot;id&quot;], aRow[&quot;folderID&quot;],</span>
<a href="#l3.1177"></a><span id="l3.1177" class="difflineminus">-                            aRow[&quot;messageKey&quot;],</span>
<a href="#l3.1178"></a><span id="l3.1178" class="difflineminus">-                            aRow[&quot;conversationID&quot;], null,</span>
<a href="#l3.1179"></a><span id="l3.1179" class="difflineminus">-                            datePRTime ? new Date(datePRTime / 1000) : null,</span>
<a href="#l3.1180"></a><span id="l3.1180" class="difflineminus">-                            aRow[&quot;headerMessageID&quot;]);</span>
<a href="#l3.1181"></a><span id="l3.1181" class="difflineplus">+    let folderId, messageKey, date;</span>
<a href="#l3.1182"></a><span id="l3.1182" class="difflineplus">+    if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.1183"></a><span id="l3.1183" class="difflineplus">+      folderId = null;</span>
<a href="#l3.1184"></a><span id="l3.1184" class="difflineplus">+    else</span>
<a href="#l3.1185"></a><span id="l3.1185" class="difflineplus">+      folderId = aRow.getInt64(1);</span>
<a href="#l3.1186"></a><span id="l3.1186" class="difflineplus">+    if (aRow.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.1187"></a><span id="l3.1187" class="difflineplus">+      messageKey = null;</span>
<a href="#l3.1188"></a><span id="l3.1188" class="difflineplus">+    else</span>
<a href="#l3.1189"></a><span id="l3.1189" class="difflineplus">+      messageKey = aRow.getInt64(2);</span>
<a href="#l3.1190"></a><span id="l3.1190" class="difflineplus">+    if (aRow.getTypeOfIndex(4) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.1191"></a><span id="l3.1191" class="difflineplus">+      date = null;</span>
<a href="#l3.1192"></a><span id="l3.1192" class="difflineplus">+    else</span>
<a href="#l3.1193"></a><span id="l3.1193" class="difflineplus">+      date = new Date(aRow.getInt64(4) / 1000);</span>
<a href="#l3.1194"></a><span id="l3.1194" class="difflineplus">+    return new GlodaMessage(this, aRow.getInt64(0), folderId, messageKey,</span>
<a href="#l3.1195"></a><span id="l3.1195" class="difflineplus">+                            aRow.getInt64(3), null, date, aRow.getString(5));</span>
<a href="#l3.1196"></a><span id="l3.1196">   },</span>
<a href="#l3.1197"></a><span id="l3.1197"> </span>
<a href="#l3.1198"></a><span id="l3.1198">   get _selectMessageByIDStatement() {</span>
<a href="#l3.1199"></a><span id="l3.1199" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1200"></a><span id="l3.1200" class="difflineminus">-      &quot;SELECT * FROM messages WHERE id = :id&quot;);</span>
<a href="#l3.1201"></a><span id="l3.1201" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1202"></a><span id="l3.1202" class="difflineplus">+      &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageID \</span>
<a href="#l3.1203"></a><span id="l3.1203" class="difflineplus">+         FROM messages WHERE id = ?1&quot;);</span>
<a href="#l3.1204"></a><span id="l3.1204">     this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l3.1205"></a><span id="l3.1205">       function() statement);</span>
<a href="#l3.1206"></a><span id="l3.1206">     return this._selectMessageByIDStatement;</span>
<a href="#l3.1207"></a><span id="l3.1207">   },</span>
<a href="#l3.1208"></a><span id="l3.1208"> </span>
<a href="#l3.1209"></a><span id="l3.1209" class="difflineplus">+  /**</span>
<a href="#l3.1210"></a><span id="l3.1210" class="difflineplus">+   * Synchronously retrieve the given message given its gloda message id.</span>
<a href="#l3.1211"></a><span id="l3.1211" class="difflineplus">+   */</span>
<a href="#l3.1212"></a><span id="l3.1212">   getMessageByID: function gloda_ds_getMessageByID(aID) {</span>
<a href="#l3.1213"></a><span id="l3.1213">     let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l3.1214"></a><span id="l3.1214">       GlodaMessage.prototype.NOUN_ID, aID);</span>
<a href="#l3.1215"></a><span id="l3.1215">   </span>
<a href="#l3.1216"></a><span id="l3.1216">     if (message === null) {</span>
<a href="#l3.1217"></a><span id="l3.1217">       let smbis = this._selectMessageByIDStatement;</span>
<a href="#l3.1218"></a><span id="l3.1218">       </span>
<a href="#l3.1219"></a><span id="l3.1219" class="difflineminus">-      smbis.params.id = aID;</span>
<a href="#l3.1220"></a><span id="l3.1220" class="difflineminus">-      if (smbis.step()) {</span>
<a href="#l3.1221"></a><span id="l3.1221" class="difflineminus">-        message = this._messageFromRow(smbis.row);</span>
<a href="#l3.1222"></a><span id="l3.1222" class="difflineplus">+      smbis.bindInt64Parameter(0, aID);</span>
<a href="#l3.1223"></a><span id="l3.1223" class="difflineplus">+      if (smbis.executeStep()) {</span>
<a href="#l3.1224"></a><span id="l3.1224" class="difflineplus">+        message = this._messageFromRow(smbis);</span>
<a href="#l3.1225"></a><span id="l3.1225">         GlodaCollectionManager.itemLoaded(message);</span>
<a href="#l3.1226"></a><span id="l3.1226">       }</span>
<a href="#l3.1227"></a><span id="l3.1227">       smbis.reset();</span>
<a href="#l3.1228"></a><span id="l3.1228">     }</span>
<a href="#l3.1229"></a><span id="l3.1229">     </span>
<a href="#l3.1230"></a><span id="l3.1230">     return message;</span>
<a href="#l3.1231"></a><span id="l3.1231">   },</span>
<a href="#l3.1232"></a><span id="l3.1232"> </span>
<a href="#l3.1233"></a><span id="l3.1233">   get _selectMessageByLocationStatement() {</span>
<a href="#l3.1234"></a><span id="l3.1234" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1235"></a><span id="l3.1235" class="difflineminus">-      &quot;SELECT * FROM messages WHERE folderID = :folderID AND \</span>
<a href="#l3.1236"></a><span id="l3.1236" class="difflineminus">-                                    messageKey = :messageKey&quot;);</span>
<a href="#l3.1237"></a><span id="l3.1237" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1238"></a><span id="l3.1238" class="difflineplus">+      &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageId \</span>
<a href="#l3.1239"></a><span id="l3.1239" class="difflineplus">+       FROM messages WHERE folderID = ?1 AND messageKey = ?2&quot;);</span>
<a href="#l3.1240"></a><span id="l3.1240">     this.__defineGetter__(&quot;_selectMessageByLocationStatement&quot;,</span>
<a href="#l3.1241"></a><span id="l3.1241">       function() statement);</span>
<a href="#l3.1242"></a><span id="l3.1242">     return this._selectMessageByLocationStatement;</span>
<a href="#l3.1243"></a><span id="l3.1243">   },</span>
<a href="#l3.1244"></a><span id="l3.1244"> </span>
<a href="#l3.1245"></a><span id="l3.1245">   /**</span>
<a href="#l3.1246"></a><span id="l3.1246" class="difflineminus">-   * Retrieve the message that we believe to correspond to the given message</span>
<a href="#l3.1247"></a><span id="l3.1247" class="difflineminus">-   *  key in the given folder.</span>
<a href="#l3.1248"></a><span id="l3.1248" class="difflineplus">+   * Synchronously retrieve the message that we believe to correspond to the </span>
<a href="#l3.1249"></a><span id="l3.1249" class="difflineplus">+   *  given message key in the given folder.</span>
<a href="#l3.1250"></a><span id="l3.1250">    * @return null on failure to locate the message, the message on success.</span>
<a href="#l3.1251"></a><span id="l3.1251">    *</span>
<a href="#l3.1252"></a><span id="l3.1252">    * @XXX on failure, attempt to resolve the problem through re-indexing, etc.</span>
<a href="#l3.1253"></a><span id="l3.1253">    */</span>
<a href="#l3.1254"></a><span id="l3.1254">   getMessageFromLocation: function gloda_ds_getMessageFromLocation(aFolderURI,</span>
<a href="#l3.1255"></a><span id="l3.1255">                                                                  aMessageKey) {</span>
<a href="#l3.1256"></a><span id="l3.1256" class="difflineminus">-    this._selectMessageByLocationStatement.params.folderID =</span>
<a href="#l3.1257"></a><span id="l3.1257" class="difflineminus">-      this._mapFolderURI(aFolderURI);</span>
<a href="#l3.1258"></a><span id="l3.1258" class="difflineminus">-    this._selectMessageByLocationStatement.params.messageKey = aMessageKey;</span>
<a href="#l3.1259"></a><span id="l3.1259" class="difflineplus">+    this._selectMessageByLocationStatement.bindInt64Parameter(0,</span>
<a href="#l3.1260"></a><span id="l3.1260" class="difflineplus">+      this._mapFolderURI(aFolderURI));</span>
<a href="#l3.1261"></a><span id="l3.1261" class="difflineplus">+    this._selectMessageByLocationStatement.bindInt64Parameter(1, aMessageKey);</span>
<a href="#l3.1262"></a><span id="l3.1262">     </span>
<a href="#l3.1263"></a><span id="l3.1263">     let message = null;</span>
<a href="#l3.1264"></a><span id="l3.1264" class="difflineminus">-    if (this._selectMessageByLocationStatement.step())</span>
<a href="#l3.1265"></a><span id="l3.1265" class="difflineminus">-      message = this._messageFromRow(this._selectMessageByLocationStatement.row);</span>
<a href="#l3.1266"></a><span id="l3.1266" class="difflineplus">+    if (this._selectMessageByLocationStatement.executeStep())</span>
<a href="#l3.1267"></a><span id="l3.1267" class="difflineplus">+      message = this._messageFromRow(this._selectMessageByLocationStatement);</span>
<a href="#l3.1268"></a><span id="l3.1268">     this._selectMessageByLocationStatement.reset();</span>
<a href="#l3.1269"></a><span id="l3.1269">     </span>
<a href="#l3.1270"></a><span id="l3.1270">     if (message === null)</span>
<a href="#l3.1271"></a><span id="l3.1271">       this._log.info(&quot;Error locating message with key=&quot; + aMessageKey +</span>
<a href="#l3.1272"></a><span id="l3.1272">                      &quot; and URI &quot; + aFolderURI);</span>
<a href="#l3.1273"></a><span id="l3.1273">     </span>
<a href="#l3.1274"></a><span id="l3.1274">     return message &amp;&amp; GlodaCollectionManager.cacheLoadUnifyOne(message);</span>
<a href="#l3.1275"></a><span id="l3.1275">   },</span>
<a href="#l3.1276"></a><span id="l3.1276"> </span>
<a href="#l3.1277"></a><span id="l3.1277">   get _selectMessageIDsByFolderStatement() {</span>
<a href="#l3.1278"></a><span id="l3.1278" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1279"></a><span id="l3.1279" class="difflineminus">-      &quot;SELECT id FROM messages WHERE folderID = :folderID&quot;);</span>
<a href="#l3.1280"></a><span id="l3.1280" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1281"></a><span id="l3.1281" class="difflineplus">+      &quot;SELECT id FROM messages WHERE folderID = ?1&quot;);</span>
<a href="#l3.1282"></a><span id="l3.1282">     this.__defineGetter__(&quot;_selectMessageIDsByFolderStatement&quot;,</span>
<a href="#l3.1283"></a><span id="l3.1283">       function() statement);</span>
<a href="#l3.1284"></a><span id="l3.1284">     return this._selectMessageIDsByFolderStatement;</span>
<a href="#l3.1285"></a><span id="l3.1285">   },</span>
<a href="#l3.1286"></a><span id="l3.1286">   </span>
<a href="#l3.1287"></a><span id="l3.1287">   getMessageIDsByFolderID:</span>
<a href="#l3.1288"></a><span id="l3.1288">       function gloda_ds_getMessageIDsFromFolderID(aFolderID) {</span>
<a href="#l3.1289"></a><span id="l3.1289">     let messageIDs = [];</span>
<a href="#l3.1290"></a><span id="l3.1290">     </span>
<a href="#l3.1291"></a><span id="l3.1291">     let smidbfs = this._selectMessageIDsByFolderStatement;</span>
<a href="#l3.1292"></a><span id="l3.1292" class="difflineminus">-    smidbfs.params.folderID = aFolderID;</span>
<a href="#l3.1293"></a><span id="l3.1293" class="difflineplus">+    smidbfs.bindInt64Parameter(0, aFolderID);</span>
<a href="#l3.1294"></a><span id="l3.1294">     </span>
<a href="#l3.1295"></a><span id="l3.1295" class="difflineminus">-    while (smidbfs.step()) {</span>
<a href="#l3.1296"></a><span id="l3.1296" class="difflineplus">+    while (smidbfs.executeStep()) {</span>
<a href="#l3.1297"></a><span id="l3.1297">       messageIDs.push(smidbfs.row[&quot;id&quot;]);</span>
<a href="#l3.1298"></a><span id="l3.1298">     }</span>
<a href="#l3.1299"></a><span id="l3.1299">     smidbfs.reset();</span>
<a href="#l3.1300"></a><span id="l3.1300">     </span>
<a href="#l3.1301"></a><span id="l3.1301">     return messageIDs;</span>
<a href="#l3.1302"></a><span id="l3.1302">   },</span>
<a href="#l3.1303"></a><span id="l3.1303">   </span>
<a href="#l3.1304"></a><span id="l3.1304">   /**</span>
<a href="#l3.1305"></a><span id="l3.1305">    * Given a list of Message-ID's, return a matching list of lists of messages</span>
<a href="#l3.1306"></a><span id="l3.1306">    *  matching those Message-ID's.  So if you pass an array with three</span>
<a href="#l3.1307"></a><span id="l3.1307">    *  Message-ID's [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], you would get back an array containing</span>
<a href="#l3.1308"></a><span id="l3.1308">    *  3 lists, where the first list contains all the messages with a message-id</span>
<a href="#l3.1309"></a><span id="l3.1309">    *  of &quot;a&quot;, and so forth.  The reason a list is returned rather than null/a</span>
<a href="#l3.1310"></a><span id="l3.1310">    *  message is that we accept the reality that we have multiple copies of</span>
<a href="#l3.1311"></a><span id="l3.1311">    *  messages with the same ID.</span>
<a href="#l3.1312"></a><span id="l3.1312" class="difflineplus">+   * This call is asynchronous because it depends on previously created messages</span>
<a href="#l3.1313"></a><span id="l3.1313" class="difflineplus">+   *  to be reflected in our results, which requires us to execute on the async</span>
<a href="#l3.1314"></a><span id="l3.1314" class="difflineplus">+   *  thread where all our writes happen.  This also turns out to be a</span>
<a href="#l3.1315"></a><span id="l3.1315" class="difflineplus">+   *  reasonable thing because we could imagine pathological cases where there</span>
<a href="#l3.1316"></a><span id="l3.1316" class="difflineplus">+   *  could be a lot of message-id's and/or a lot of messages with those</span>
<a href="#l3.1317"></a><span id="l3.1317" class="difflineplus">+   *  message-id's.</span>
<a href="#l3.1318"></a><span id="l3.1318">    */</span>
<a href="#l3.1319"></a><span id="l3.1319" class="difflineminus">-  getMessagesByMessageID: function gloda_ds_getMessagesByMessageID(aMessageIDs) {</span>
<a href="#l3.1320"></a><span id="l3.1320" class="difflineplus">+  getMessagesByMessageID: function gloda_ds_getMessagesByMessageID(aMessageIDs,</span>
<a href="#l3.1321"></a><span id="l3.1321" class="difflineplus">+      aCallback, aCallbackThis, aCallbackArgs) {</span>
<a href="#l3.1322"></a><span id="l3.1322">     let msgIDToIndex = {};</span>
<a href="#l3.1323"></a><span id="l3.1323">     let results = [];</span>
<a href="#l3.1324"></a><span id="l3.1324">     for (let iID=0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l3.1325"></a><span id="l3.1325">       let msgID = aMessageIDs[iID];</span>
<a href="#l3.1326"></a><span id="l3.1326">       results.push([]);</span>
<a href="#l3.1327"></a><span id="l3.1327">       msgIDToIndex[msgID] = iID;</span>
<a href="#l3.1328"></a><span id="l3.1328">     } </span>
<a href="#l3.1329"></a><span id="l3.1329"> </span>
<a href="#l3.1330"></a><span id="l3.1330">     // Unfortunately, IN doesn't work with statement binding mechanisms, and</span>
<a href="#l3.1331"></a><span id="l3.1331">     //  a chain of ORed tests really can't be bound unless we create one per</span>
<a href="#l3.1332"></a><span id="l3.1332">     //  value of N (seems silly).</span>
<a href="#l3.1333"></a><span id="l3.1333">     let quotedIDs = [&quot;'&quot; + msgID.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot; for each</span>
<a href="#l3.1334"></a><span id="l3.1334">                      (msgID in aMessageIDs)]</span>
<a href="#l3.1335"></a><span id="l3.1335">     let sqlString = &quot;SELECT * FROM messages WHERE headerMessageID IN (&quot; +</span>
<a href="#l3.1336"></a><span id="l3.1336">                     quotedIDs + &quot;)&quot;;</span>
<a href="#l3.1337"></a><span id="l3.1337" class="difflineminus">-    let statement = this._createStatement(sqlString);</span>
<a href="#l3.1338"></a><span id="l3.1338" class="difflineminus">-    </span>
<a href="#l3.1339"></a><span id="l3.1339" class="difflineminus">-    while (statement.step()) {</span>
<a href="#l3.1340"></a><span id="l3.1340" class="difflineminus">-      results[msgIDToIndex[statement.row[&quot;headerMessageID&quot;]]].push(</span>
<a href="#l3.1341"></a><span id="l3.1341" class="difflineminus">-        this._messageFromRow(statement.row));</span>
<a href="#l3.1342"></a><span id="l3.1342" class="difflineminus">-    }</span>
<a href="#l3.1343"></a><span id="l3.1343" class="difflineminus">-    statement.reset();</span>
<a href="#l3.1344"></a><span id="l3.1344" class="difflineplus">+    let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l3.1345"></a><span id="l3.1345">     </span>
<a href="#l3.1346"></a><span id="l3.1346" class="difflineminus">-    for (let iResult=0; iResult &lt; results.length; iResult++) {</span>
<a href="#l3.1347"></a><span id="l3.1347" class="difflineminus">-      if (results[iResult].length)</span>
<a href="#l3.1348"></a><span id="l3.1348" class="difflineminus">-        GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l3.1349"></a><span id="l3.1349" class="difflineminus">-                                              results[iResult]);</span>
<a href="#l3.1350"></a><span id="l3.1350" class="difflineminus">-    }</span>
<a href="#l3.1351"></a><span id="l3.1351" class="difflineminus">-    </span>
<a href="#l3.1352"></a><span id="l3.1352" class="difflineminus">-    return results;</span>
<a href="#l3.1353"></a><span id="l3.1353" class="difflineplus">+    statement.executeAsync(new MessagesByMessageIdCallback(statement,</span>
<a href="#l3.1354"></a><span id="l3.1354" class="difflineplus">+      msgIDToIndex, results, aCallback, aCallbackThis, aCallbackArgs));</span>
<a href="#l3.1355"></a><span id="l3.1355">   },</span>
<a href="#l3.1356"></a><span id="l3.1356"> </span>
<a href="#l3.1357"></a><span id="l3.1357">   get _deleteMessageByIDStatement() {</span>
<a href="#l3.1358"></a><span id="l3.1358" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1359"></a><span id="l3.1359" class="difflineminus">-      &quot;DELETE FROM messages WHERE id = :id&quot;);</span>
<a href="#l3.1360"></a><span id="l3.1360" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.1361"></a><span id="l3.1361" class="difflineplus">+      &quot;DELETE FROM messages WHERE id = ?1&quot;);</span>
<a href="#l3.1362"></a><span id="l3.1362">     this.__defineGetter__(&quot;_deleteMessageByIDStatement&quot;,</span>
<a href="#l3.1363"></a><span id="l3.1363">                           function() statement);</span>
<a href="#l3.1364"></a><span id="l3.1364">     return this._deleteMessageByIDStatement; </span>
<a href="#l3.1365"></a><span id="l3.1365">   },</span>
<a href="#l3.1366"></a><span id="l3.1366">   </span>
<a href="#l3.1367"></a><span id="l3.1367">   deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l3.1368"></a><span id="l3.1368">     // TODO: collection manager implications</span>
<a href="#l3.1369"></a><span id="l3.1369">     let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l3.1370"></a><span id="l3.1370" class="difflineminus">-    dmbids.params.id = aMessageID;</span>
<a href="#l3.1371"></a><span id="l3.1371" class="difflineminus">-    dmbids.execute();</span>
<a href="#l3.1372"></a><span id="l3.1372" class="difflineplus">+    dmbids.bindInt64Parameter(0, aMessageID);</span>
<a href="#l3.1373"></a><span id="l3.1373" class="difflineplus">+    dmbids.executeAsync();</span>
<a href="#l3.1374"></a><span id="l3.1374">   },</span>
<a href="#l3.1375"></a><span id="l3.1375"> </span>
<a href="#l3.1376"></a><span id="l3.1376">   get _deleteMessagesByConversationIDStatement() {</span>
<a href="#l3.1377"></a><span id="l3.1377" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1378"></a><span id="l3.1378" class="difflineminus">-      &quot;DELETE FROM messages WHERE conversationID = :conversationID&quot;);</span>
<a href="#l3.1379"></a><span id="l3.1379" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.1380"></a><span id="l3.1380" class="difflineplus">+      &quot;DELETE FROM messages WHERE conversationID = ?1&quot;);</span>
<a href="#l3.1381"></a><span id="l3.1381">     this.__defineGetter__(&quot;_deleteMessagesByConversationIDStatement&quot;,</span>
<a href="#l3.1382"></a><span id="l3.1382">                           function() statement);</span>
<a href="#l3.1383"></a><span id="l3.1383">     return this._deleteMessagesByConversationIDStatement; </span>
<a href="#l3.1384"></a><span id="l3.1384">   },</span>
<a href="#l3.1385"></a><span id="l3.1385"> </span>
<a href="#l3.1386"></a><span id="l3.1386">   /**</span>
<a href="#l3.1387"></a><span id="l3.1387">    * Delete messages by conversation ID.  For use by the indexer's deletion</span>
<a href="#l3.1388"></a><span id="l3.1388">    *  logic, NOT you.</span>
<a href="#l3.1389"></a><span id="l3.1389">    */</span>
<a href="#l3.1390"></a><span id="l3.1390">   deleteMessagesByConversationID:</span>
<a href="#l3.1391"></a><span id="l3.1391">     // TODO: collection manager implications</span>
<a href="#l3.1392"></a><span id="l3.1392">       function gloda_ds_deleteMessagesByConversationID(aConversationID) {</span>
<a href="#l3.1393"></a><span id="l3.1393">     let dmbcids = this._deleteMessagesByConversationIDStatement;</span>
<a href="#l3.1394"></a><span id="l3.1394" class="difflineminus">-    dmbcids.params.conversationID = aConversationID;</span>
<a href="#l3.1395"></a><span id="l3.1395" class="difflineminus">-    dmbcids.execute();</span>
<a href="#l3.1396"></a><span id="l3.1396" class="difflineminus">-  },</span>
<a href="#l3.1397"></a><span id="l3.1397" class="difflineminus">-  </span>
<a href="#l3.1398"></a><span id="l3.1398" class="difflineminus">-  /**</span>
<a href="#l3.1399"></a><span id="l3.1399" class="difflineminus">-   * Get the first message found in the database with the given header</span>
<a href="#l3.1400"></a><span id="l3.1400" class="difflineminus">-   *  Message-ID, or null if none exists.  Because of the good chance of there</span>
<a href="#l3.1401"></a><span id="l3.1401" class="difflineminus">-   *  being more than one message with a Message-ID, you probably want a</span>
<a href="#l3.1402"></a><span id="l3.1402" class="difflineminus">-   *  different method than this one.  At the very least, a method that takes</span>
<a href="#l3.1403"></a><span id="l3.1403" class="difflineminus">-   *  a hint about what folder to look in...</span>
<a href="#l3.1404"></a><span id="l3.1404" class="difflineminus">-   */</span>
<a href="#l3.1405"></a><span id="l3.1405" class="difflineminus">-  getMessageByMessageID: function gloda_ds_getMessageByMessageID(aMessageID) {</span>
<a href="#l3.1406"></a><span id="l3.1406" class="difflineminus">-    let ids = [aMessageID];</span>
<a href="#l3.1407"></a><span id="l3.1407" class="difflineminus">-    // getMessagesByMessageID handles the collection manager cache resolution</span>
<a href="#l3.1408"></a><span id="l3.1408" class="difflineminus">-    let messagesWithID = this.getMessagesByMessageID(ids)[0];</span>
<a href="#l3.1409"></a><span id="l3.1409" class="difflineminus">-    // Just return the first one; we are a failure </span>
<a href="#l3.1410"></a><span id="l3.1410" class="difflineminus">-    if (messagesWithID.length &gt; 0)</span>
<a href="#l3.1411"></a><span id="l3.1411" class="difflineminus">-      return messagesWithID[0];</span>
<a href="#l3.1412"></a><span id="l3.1412" class="difflineminus">-    else</span>
<a href="#l3.1413"></a><span id="l3.1413" class="difflineminus">-      return null;</span>
<a href="#l3.1414"></a><span id="l3.1414" class="difflineplus">+    dmbcids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l3.1415"></a><span id="l3.1415" class="difflineplus">+    dmbcids.executeAsync();</span>
<a href="#l3.1416"></a><span id="l3.1416">   },</span>
<a href="#l3.1417"></a><span id="l3.1417"> </span>
<a href="#l3.1418"></a><span id="l3.1418">   get _selectMessagesByConversationIDStatement() {</span>
<a href="#l3.1419"></a><span id="l3.1419" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1420"></a><span id="l3.1420" class="difflineminus">-      &quot;SELECT * FROM messages WHERE conversationID = :conversationID&quot;);</span>
<a href="#l3.1421"></a><span id="l3.1421" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1422"></a><span id="l3.1422" class="difflineplus">+      &quot;SELECT * FROM messages WHERE conversationID = ?1&quot;);</span>
<a href="#l3.1423"></a><span id="l3.1423">     this.__defineGetter__(&quot;_selectMessagesByConversationIDStatement&quot;,</span>
<a href="#l3.1424"></a><span id="l3.1424">       function() statement);</span>
<a href="#l3.1425"></a><span id="l3.1425">     return this._selectMessagesByConversationIDStatement;</span>
<a href="#l3.1426"></a><span id="l3.1426">   },</span>
<a href="#l3.1427"></a><span id="l3.1427"> </span>
<a href="#l3.1428"></a><span id="l3.1428">   get _selectMessagesByConversationIDNoGhostsStatement() {</span>
<a href="#l3.1429"></a><span id="l3.1429" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1430"></a><span id="l3.1430" class="difflineminus">-      &quot;SELECT * FROM messages WHERE conversationID = :conversationID AND \</span>
<a href="#l3.1431"></a><span id="l3.1431" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1432"></a><span id="l3.1432" class="difflineplus">+      &quot;SELECT * FROM messages WHERE conversationID = ?1 AND \</span>
<a href="#l3.1433"></a><span id="l3.1433">                                     folderID IS NOT NULL&quot;);</span>
<a href="#l3.1434"></a><span id="l3.1434">     this.__defineGetter__(&quot;_selectMessagesByConversationIDNoGhostsStatement&quot;,</span>
<a href="#l3.1435"></a><span id="l3.1435">       function() statement);</span>
<a href="#l3.1436"></a><span id="l3.1436">     return this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l3.1437"></a><span id="l3.1437">   },</span>
<a href="#l3.1438"></a><span id="l3.1438"> </span>
<a href="#l3.1439"></a><span id="l3.1439">   /**</span>
<a href="#l3.1440"></a><span id="l3.1440">    * Retrieve all the messages belonging to the given conversation.  This</span>
<a href="#l3.1441"></a><span id="l3.1441" class="difflineat">@@ -1205,37 +1494,37 @@ let GlodaDatastore = {</span>
<a href="#l3.1442"></a><span id="l3.1442">    */</span>
<a href="#l3.1443"></a><span id="l3.1443">   getMessagesByConversationID: function gloda_ds_getMessagesByConversationID(</span>
<a href="#l3.1444"></a><span id="l3.1444">         aConversationID, aIncludeGhosts) {</span>
<a href="#l3.1445"></a><span id="l3.1445">     let statement;</span>
<a href="#l3.1446"></a><span id="l3.1446">     if (aIncludeGhosts)</span>
<a href="#l3.1447"></a><span id="l3.1447">       statement = this._selectMessagesByConversationIDStatement;</span>
<a href="#l3.1448"></a><span id="l3.1448">     else</span>
<a href="#l3.1449"></a><span id="l3.1449">       statement = this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l3.1450"></a><span id="l3.1450" class="difflineminus">-    statement.params.conversationID = aConversationID; </span>
<a href="#l3.1451"></a><span id="l3.1451" class="difflineplus">+    statement.bindInt64Parameter(0, aConversationID); </span>
<a href="#l3.1452"></a><span id="l3.1452">     </span>
<a href="#l3.1453"></a><span id="l3.1453">     let messages = [];</span>
<a href="#l3.1454"></a><span id="l3.1454" class="difflineminus">-    while (statement.step()) {</span>
<a href="#l3.1455"></a><span id="l3.1455" class="difflineminus">-      messages.push(this._messageFromRow(statement.row));</span>
<a href="#l3.1456"></a><span id="l3.1456" class="difflineplus">+    while (statement.executeStep()) {</span>
<a href="#l3.1457"></a><span id="l3.1457" class="difflineplus">+      messages.push(this._messageFromRow(statement));</span>
<a href="#l3.1458"></a><span id="l3.1458">     }</span>
<a href="#l3.1459"></a><span id="l3.1459">     statement.reset();</span>
<a href="#l3.1460"></a><span id="l3.1460"> </span>
<a href="#l3.1461"></a><span id="l3.1461">     if (messages.length)</span>
<a href="#l3.1462"></a><span id="l3.1462">       GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l3.1463"></a><span id="l3.1463">                                             messages);</span>
<a href="#l3.1464"></a><span id="l3.1464">     </span>
<a href="#l3.1465"></a><span id="l3.1465">     return messages;</span>
<a href="#l3.1466"></a><span id="l3.1466">   },</span>
<a href="#l3.1467"></a><span id="l3.1467">   </span>
<a href="#l3.1468"></a><span id="l3.1468">   /* ********** Message Attributes ********** */</span>
<a href="#l3.1469"></a><span id="l3.1469">   get _insertMessageAttributeStatement() {</span>
<a href="#l3.1470"></a><span id="l3.1470" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1471"></a><span id="l3.1471" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.1472"></a><span id="l3.1472">       &quot;INSERT INTO messageAttributes (conversationID, messageID, attributeID, \</span>
<a href="#l3.1473"></a><span id="l3.1473">                              value) \</span>
<a href="#l3.1474"></a><span id="l3.1474" class="difflineminus">-              VALUES (:conversationID, :messageID, :attributeID, :value)&quot;);</span>
<a href="#l3.1475"></a><span id="l3.1475" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l3.1476"></a><span id="l3.1476">     this.__defineGetter__(&quot;_insertMessageAttributeStatement&quot;,</span>
<a href="#l3.1477"></a><span id="l3.1477">       function() statement);</span>
<a href="#l3.1478"></a><span id="l3.1478">     return this._insertMessageAttributeStatement;</span>
<a href="#l3.1479"></a><span id="l3.1479">   },</span>
<a href="#l3.1480"></a><span id="l3.1480">   </span>
<a href="#l3.1481"></a><span id="l3.1481">   /**</span>
<a href="#l3.1482"></a><span id="l3.1482">    * Insert a bunch of attributes relating to a GlodaMessage.  This is performed</span>
<a href="#l3.1483"></a><span id="l3.1483">    *  inside a pseudo-transaction (we create one if we aren't in one, using</span>
<a href="#l3.1484"></a><span id="l3.1484" class="difflineat">@@ -1262,68 +1551,66 @@ let GlodaDatastore = {</span>
<a href="#l3.1485"></a><span id="l3.1485">   insertMessageAttributes: function gloda_ds_insertMessageAttributes(aMessage,</span>
<a href="#l3.1486"></a><span id="l3.1486">                                         aAttributes) {</span>
<a href="#l3.1487"></a><span id="l3.1487">     let imas = this._insertMessageAttributeStatement;</span>
<a href="#l3.1488"></a><span id="l3.1488">     this._beginTransaction();</span>
<a href="#l3.1489"></a><span id="l3.1489">     try {</span>
<a href="#l3.1490"></a><span id="l3.1490">       for (let iAttribute=0; iAttribute &lt; aAttributes.length; iAttribute++) {</span>
<a href="#l3.1491"></a><span id="l3.1491">         let attribValueTuple = aAttributes[iAttribute];</span>
<a href="#l3.1492"></a><span id="l3.1492"> </span>
<a href="#l3.1493"></a><span id="l3.1493" class="difflineminus">-        this._log.debug(&quot;inserting conv:&quot; + aMessage.conversationID +</span>
<a href="#l3.1494"></a><span id="l3.1494" class="difflineminus">-                        &quot; message:&quot; + aMessage.id + </span>
<a href="#l3.1495"></a><span id="l3.1495" class="difflineminus">-                        &quot; attributeID:&quot; + attribValueTuple[0] +</span>
<a href="#l3.1496"></a><span id="l3.1496" class="difflineminus">-                        &quot; value:&quot; + attribValueTuple[1]);</span>
<a href="#l3.1497"></a><span id="l3.1497" class="difflineminus">-        </span>
<a href="#l3.1498"></a><span id="l3.1498" class="difflineminus">-        imas.params.conversationID = aMessage.conversationID;</span>
<a href="#l3.1499"></a><span id="l3.1499" class="difflineminus">-        imas.params.messageID = aMessage.id;</span>
<a href="#l3.1500"></a><span id="l3.1500" class="difflineminus">-        imas.params.attributeID = attribValueTuple[0];</span>
<a href="#l3.1501"></a><span id="l3.1501" class="difflineplus">+        imas.bindInt64Parameter(0, aMessage.conversationID);</span>
<a href="#l3.1502"></a><span id="l3.1502" class="difflineplus">+        imas.bindInt64Parameter(1, aMessage.id);</span>
<a href="#l3.1503"></a><span id="l3.1503" class="difflineplus">+        imas.bindInt64Parameter(2, attribValueTuple[0]);</span>
<a href="#l3.1504"></a><span id="l3.1504">         // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l3.1505"></a><span id="l3.1505">         //  really care anyways.)</span>
<a href="#l3.1506"></a><span id="l3.1506">         if (attribValueTuple[1] == null)</span>
<a href="#l3.1507"></a><span id="l3.1507" class="difflineminus">-          imas.params.value = 0;</span>
<a href="#l3.1508"></a><span id="l3.1508" class="difflineplus">+          imas.bindInt64Parameter(3, 0);</span>
<a href="#l3.1509"></a><span id="l3.1509" class="difflineplus">+        else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l3.1510"></a><span id="l3.1510" class="difflineplus">+          imas.bindInt64Parameter(3, attribValueTuple[1]);</span>
<a href="#l3.1511"></a><span id="l3.1511">         else</span>
<a href="#l3.1512"></a><span id="l3.1512" class="difflineminus">-          imas.params.value = attribValueTuple[1];</span>
<a href="#l3.1513"></a><span id="l3.1513" class="difflineminus">-        imas.execute();</span>
<a href="#l3.1514"></a><span id="l3.1514" class="difflineplus">+          imas.bindDoubleParameter(3, attribValueTuple[1]);</span>
<a href="#l3.1515"></a><span id="l3.1515" class="difflineplus">+        imas.executeAsync();</span>
<a href="#l3.1516"></a><span id="l3.1516">       }</span>
<a href="#l3.1517"></a><span id="l3.1517">       </span>
<a href="#l3.1518"></a><span id="l3.1518">       this._commitTransaction();</span>
<a href="#l3.1519"></a><span id="l3.1519">     }</span>
<a href="#l3.1520"></a><span id="l3.1520">     catch (ex) {</span>
<a href="#l3.1521"></a><span id="l3.1521">       this._rollbackTransaction();</span>
<a href="#l3.1522"></a><span id="l3.1522">       throw ex;</span>
<a href="#l3.1523"></a><span id="l3.1523">     }</span>
<a href="#l3.1524"></a><span id="l3.1524">   },</span>
<a href="#l3.1525"></a><span id="l3.1525">   </span>
<a href="#l3.1526"></a><span id="l3.1526">   get _deleteMessageAttributesByMessageIDStatement() {</span>
<a href="#l3.1527"></a><span id="l3.1527" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1528"></a><span id="l3.1528" class="difflineminus">-      &quot;DELETE FROM messageAttributes WHERE messageID = :messageID&quot;);</span>
<a href="#l3.1529"></a><span id="l3.1529" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.1530"></a><span id="l3.1530" class="difflineplus">+      &quot;DELETE FROM messageAttributes WHERE messageID = ?1&quot;);</span>
<a href="#l3.1531"></a><span id="l3.1531">     this.__defineGetter__(&quot;_deleteMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l3.1532"></a><span id="l3.1532">       function() statement);</span>
<a href="#l3.1533"></a><span id="l3.1533">     return this._deleteMessageAttributesByMessageIDStatement;</span>
<a href="#l3.1534"></a><span id="l3.1534">   },</span>
<a href="#l3.1535"></a><span id="l3.1535"> </span>
<a href="#l3.1536"></a><span id="l3.1536">   /**</span>
<a href="#l3.1537"></a><span id="l3.1537">    * Clear all the message attributes for a given GlodaMessage.  No changes</span>
<a href="#l3.1538"></a><span id="l3.1538">    *  are made to the in-memory representation of the message; it is up to the</span>
<a href="#l3.1539"></a><span id="l3.1539">    *  caller to ensure that it handles things correctly.</span>
<a href="#l3.1540"></a><span id="l3.1540">    *</span>
<a href="#l3.1541"></a><span id="l3.1541">    * @param aMessage The GlodaMessage whose database attributes should be</span>
<a href="#l3.1542"></a><span id="l3.1542">    *     purged.</span>
<a href="#l3.1543"></a><span id="l3.1543">    */</span>
<a href="#l3.1544"></a><span id="l3.1544">   clearMessageAttributes: function gloda_ds_clearMessageAttributes(aMessage) {</span>
<a href="#l3.1545"></a><span id="l3.1545">     if (aMessage.id != null) {</span>
<a href="#l3.1546"></a><span id="l3.1546" class="difflineminus">-      this._deleteMessageAttributesByMessageIDStatement.params.messageID =</span>
<a href="#l3.1547"></a><span id="l3.1547" class="difflineminus">-        aMessage.id;</span>
<a href="#l3.1548"></a><span id="l3.1548" class="difflineminus">-      this._deleteMessageAttributesByMessageIDStatement.execute();</span>
<a href="#l3.1549"></a><span id="l3.1549" class="difflineplus">+      this._deleteMessageAttributesByMessageIDStatement.bindInt64Parameter(0,</span>
<a href="#l3.1550"></a><span id="l3.1550" class="difflineplus">+        aMessage.id);</span>
<a href="#l3.1551"></a><span id="l3.1551" class="difflineplus">+      this._deleteMessageAttributesByMessageIDStatement.executeAsync();</span>
<a href="#l3.1552"></a><span id="l3.1552">     }</span>
<a href="#l3.1553"></a><span id="l3.1553">   },</span>
<a href="#l3.1554"></a><span id="l3.1554">   </span>
<a href="#l3.1555"></a><span id="l3.1555">   get _selectMessageAttributesByMessageIDStatement() {</span>
<a href="#l3.1556"></a><span id="l3.1556" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1557"></a><span id="l3.1557" class="difflineminus">-      &quot;SELECT * FROM messageAttributes WHERE messageID = :messageID&quot;);</span>
<a href="#l3.1558"></a><span id="l3.1558" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1559"></a><span id="l3.1559" class="difflineplus">+      &quot;SELECT attributeID, value FROM messageAttributes \</span>
<a href="#l3.1560"></a><span id="l3.1560" class="difflineplus">+         WHERE messageID = ?1&quot;);</span>
<a href="#l3.1561"></a><span id="l3.1561">     this.__defineGetter__(&quot;_selectMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l3.1562"></a><span id="l3.1562">       function() statement);</span>
<a href="#l3.1563"></a><span id="l3.1563">     return this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l3.1564"></a><span id="l3.1564">   },</span>
<a href="#l3.1565"></a><span id="l3.1565">   </span>
<a href="#l3.1566"></a><span id="l3.1566">   /**</span>
<a href="#l3.1567"></a><span id="l3.1567">    * Look-up the attributes associated with the given GlodaMessage instance,</span>
<a href="#l3.1568"></a><span id="l3.1568">    *  returning them in APV form (a tuple of Attribute definition object,</span>
<a href="#l3.1569"></a><span id="l3.1569" class="difflineat">@@ -1333,26 +1620,24 @@ let GlodaDatastore = {</span>
<a href="#l3.1570"></a><span id="l3.1570">    * @return An APV list of the attributes.</span>
<a href="#l3.1571"></a><span id="l3.1571">    */</span>
<a href="#l3.1572"></a><span id="l3.1572">   getMessageAttributes: function gloda_ds_getMessageAttributes(aMessage) {</span>
<a href="#l3.1573"></a><span id="l3.1573">     // A list of [attribute def object, (attr) parameter value, attribute value]</span>
<a href="#l3.1574"></a><span id="l3.1574">     let attribParamVals = []</span>
<a href="#l3.1575"></a><span id="l3.1575">     </span>
<a href="#l3.1576"></a><span id="l3.1576">     let smas = this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l3.1577"></a><span id="l3.1577">     </span>
<a href="#l3.1578"></a><span id="l3.1578" class="difflineminus">-    smas.params.messageID = aMessage.id;</span>
<a href="#l3.1579"></a><span id="l3.1579" class="difflineminus">-    while (smas.step()) {</span>
<a href="#l3.1580"></a><span id="l3.1580" class="difflineminus">-      let attributeID = smas.row[&quot;attributeID&quot;];</span>
<a href="#l3.1581"></a><span id="l3.1581" class="difflineplus">+    smas.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l3.1582"></a><span id="l3.1582" class="difflineplus">+    while (smas.executeStep()) {</span>
<a href="#l3.1583"></a><span id="l3.1583" class="difflineplus">+      let attributeID = smas.getInt64(1);</span>
<a href="#l3.1584"></a><span id="l3.1584">       if (!(attributeID in this._attributeIDToDef)) {</span>
<a href="#l3.1585"></a><span id="l3.1585">         this._log.error(&quot;Attribute ID &quot; + attributeID + &quot; not in our map!&quot;);</span>
<a href="#l3.1586"></a><span id="l3.1586">       } </span>
<a href="#l3.1587"></a><span id="l3.1587">       let attribAndParam = this._attributeIDToDef[attributeID];</span>
<a href="#l3.1588"></a><span id="l3.1588" class="difflineminus">-      let val = smas.row[&quot;value&quot;];</span>
<a href="#l3.1589"></a><span id="l3.1589" class="difflineminus">-      //this._log.debug(&quot;Loading attribute: &quot; + attribAndParam[0].id + &quot; param: &quot;+</span>
<a href="#l3.1590"></a><span id="l3.1590" class="difflineminus">-      //                attribAndParam[1] + &quot; val: &quot; + val);</span>
<a href="#l3.1591"></a><span id="l3.1591" class="difflineplus">+      let val = smas.getDouble(2);</span>
<a href="#l3.1592"></a><span id="l3.1592">       attribParamVals.push([attribAndParam[0], attribAndParam[1], val]);</span>
<a href="#l3.1593"></a><span id="l3.1593">     }</span>
<a href="#l3.1594"></a><span id="l3.1594">     smas.reset();</span>
<a href="#l3.1595"></a><span id="l3.1595">     </span>
<a href="#l3.1596"></a><span id="l3.1596">     return attribParamVals;</span>
<a href="#l3.1597"></a><span id="l3.1597">   },</span>
<a href="#l3.1598"></a><span id="l3.1598">   </span>
<a href="#l3.1599"></a><span id="l3.1599">   _stringSQLQuoter: function(aString) {</span>
<a href="#l3.1600"></a><span id="l3.1600" class="difflineat">@@ -1363,24 +1648,20 @@ let GlodaDatastore = {</span>
<a href="#l3.1601"></a><span id="l3.1601">   },</span>
<a href="#l3.1602"></a><span id="l3.1602">   </span>
<a href="#l3.1603"></a><span id="l3.1603">   /**</span>
<a href="#l3.1604"></a><span id="l3.1604">    * Perform a database query given a GlodaQueryClass instance that specifies</span>
<a href="#l3.1605"></a><span id="l3.1605">    *  a set of constraints relating to the noun type associated with the query.</span>
<a href="#l3.1606"></a><span id="l3.1606">    *  A GlodaCollection is returned containing the results of the look-up.</span>
<a href="#l3.1607"></a><span id="l3.1607">    *  By default the collection is &quot;live&quot;, and will mutate (generating events to</span>
<a href="#l3.1608"></a><span id="l3.1608">    *  its listener) as the state of the database changes.</span>
<a href="#l3.1609"></a><span id="l3.1609" class="difflineminus">-   * Currently, this operation is fully synchronous, but needs to also provide</span>
<a href="#l3.1610"></a><span id="l3.1610" class="difflineminus">-   *  an asynchronous means of operation as well.</span>
<a href="#l3.1611"></a><span id="l3.1611" class="difflineminus">-   * This functionality is made user/extension visible by the Query's getAllSync</span>
<a href="#l3.1612"></a><span id="l3.1612" class="difflineminus">-   *  method.</span>
<a href="#l3.1613"></a><span id="l3.1613" class="difflineminus">-   *</span>
<a href="#l3.1614"></a><span id="l3.1614" class="difflineminus">-   * @TODO Create an asynchronous query-from-query mechanism</span>
<a href="#l3.1615"></a><span id="l3.1615" class="difflineplus">+   * This functionality is made user/extension visible by the Query's</span>
<a href="#l3.1616"></a><span id="l3.1616" class="difflineplus">+   *  getCollection (asynchronous) and getAllSync (synchronous).</span>
<a href="#l3.1617"></a><span id="l3.1617">    */</span>
<a href="#l3.1618"></a><span id="l3.1618" class="difflineminus">-  queryFromQuery: function gloda_ds_queryFromQuery(aQuery) {</span>
<a href="#l3.1619"></a><span id="l3.1619" class="difflineplus">+  queryFromQuery: function gloda_ds_queryFromQuery(aQuery, aListener, bSynchronous) {</span>
<a href="#l3.1620"></a><span id="l3.1620">     // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l3.1621"></a><span id="l3.1621">     //  likewise has its changes made.</span>
<a href="#l3.1622"></a><span id="l3.1622">     let nounMeta = aQuery._nounMeta;</span>
<a href="#l3.1623"></a><span id="l3.1623">     </span>
<a href="#l3.1624"></a><span id="l3.1624">     let whereClauses = [];</span>
<a href="#l3.1625"></a><span id="l3.1625">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l3.1626"></a><span id="l3.1626">     </span>
<a href="#l3.1627"></a><span id="l3.1627">     for (let iUnion=0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l3.1628"></a><span id="l3.1628" class="difflineat">@@ -1501,43 +1782,53 @@ let GlodaDatastore = {</span>
<a href="#l3.1629"></a><span id="l3.1629">       </span>
<a href="#l3.1630"></a><span id="l3.1630">       if (selects.length)</span>
<a href="#l3.1631"></a><span id="l3.1631">         whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot; )&quot;);</span>
<a href="#l3.1632"></a><span id="l3.1632">     }</span>
<a href="#l3.1633"></a><span id="l3.1633">     </span>
<a href="#l3.1634"></a><span id="l3.1634">     let sqlString = &quot;SELECT * FROM &quot; + nounMeta.tableName;</span>
<a href="#l3.1635"></a><span id="l3.1635">     if (whereClauses.length)</span>
<a href="#l3.1636"></a><span id="l3.1636">       sqlString += &quot; WHERE &quot; + whereClauses.join(&quot; OR &quot;);</span>
<a href="#l3.1637"></a><span id="l3.1637" class="difflineminus">-        </span>
<a href="#l3.1638"></a><span id="l3.1638" class="difflineplus">+    </span>
<a href="#l3.1639"></a><span id="l3.1639">     this._log.debug(&quot;QUERY FROM QUERY: &quot; + sqlString);</span>
<a href="#l3.1640"></a><span id="l3.1640">     </span>
<a href="#l3.1641"></a><span id="l3.1641" class="difflineminus">-    let statement = this._createStatement(sqlString);</span>
<a href="#l3.1642"></a><span id="l3.1642" class="difflineplus">+    let collection;</span>
<a href="#l3.1643"></a><span id="l3.1643" class="difflineplus">+    if (bSynchronous) {</span>
<a href="#l3.1644"></a><span id="l3.1644" class="difflineplus">+      let statement = this._createSyncStatement(sqlString, true);</span>
<a href="#l3.1645"></a><span id="l3.1645">     </span>
<a href="#l3.1646"></a><span id="l3.1646" class="difflineminus">-    let items = [];</span>
<a href="#l3.1647"></a><span id="l3.1647" class="difflineminus">-    while (statement.step()) {</span>
<a href="#l3.1648"></a><span id="l3.1648" class="difflineminus">-      items.push(nounMeta.objFromRow.call(nounMeta.datastore, statement.row));</span>
<a href="#l3.1649"></a><span id="l3.1649" class="difflineplus">+      let items = [];</span>
<a href="#l3.1650"></a><span id="l3.1650" class="difflineplus">+      while (statement.executeStep()) {</span>
<a href="#l3.1651"></a><span id="l3.1651" class="difflineplus">+        items.push(nounMeta.objFromRow.call(nounMeta.datastore, statement));</span>
<a href="#l3.1652"></a><span id="l3.1652" class="difflineplus">+      }</span>
<a href="#l3.1653"></a><span id="l3.1653" class="difflineplus">+      statement.finalize();</span>
<a href="#l3.1654"></a><span id="l3.1654" class="difflineplus">+      </span>
<a href="#l3.1655"></a><span id="l3.1655" class="difflineplus">+      // have the collection manager attempt to replace the instances we just</span>
<a href="#l3.1656"></a><span id="l3.1656" class="difflineplus">+      //  created with pre-existing instances.  if the instance didn't exist,</span>
<a href="#l3.1657"></a><span id="l3.1657" class="difflineplus">+      //  cache the newly observed ones.  We are trading off wastes here; we don't</span>
<a href="#l3.1658"></a><span id="l3.1658" class="difflineplus">+      //  want to have to ask the collection manager about every row, and we don't</span>
<a href="#l3.1659"></a><span id="l3.1659" class="difflineplus">+      //  want to invent some alternate row storage.</span>
<a href="#l3.1660"></a><span id="l3.1660" class="difflineplus">+      GlodaCollectionManager.cacheLoadUnify(nounMeta.id, items);</span>
<a href="#l3.1661"></a><span id="l3.1661" class="difflineplus">+      collection = new GlodaCollection(items, aQuery, aListener);</span>
<a href="#l3.1662"></a><span id="l3.1662" class="difflineplus">+      </span>
<a href="#l3.1663"></a><span id="l3.1663" class="difflineplus">+      GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l3.1664"></a><span id="l3.1664">     }</span>
<a href="#l3.1665"></a><span id="l3.1665" class="difflineminus">-    statement.reset();</span>
<a href="#l3.1666"></a><span id="l3.1666" class="difflineminus">-    // have the collection manager attempt to replace the instances we just</span>
<a href="#l3.1667"></a><span id="l3.1667" class="difflineminus">-    //  created with pre-existing instances.  if the instance didn't exist,</span>
<a href="#l3.1668"></a><span id="l3.1668" class="difflineminus">-    //  cache the newly observed ones.  We are trading off wastes here; we don't</span>
<a href="#l3.1669"></a><span id="l3.1669" class="difflineminus">-    //  want to have to ask the collection manager about every row, and we don't</span>
<a href="#l3.1670"></a><span id="l3.1670" class="difflineminus">-    //  want to invent some alternate row storage.</span>
<a href="#l3.1671"></a><span id="l3.1671" class="difflineminus">-    GlodaCollectionManager.cacheLoadUnify(nounMeta.id, items);</span>
<a href="#l3.1672"></a><span id="l3.1672" class="difflineminus">-    </span>
<a href="#l3.1673"></a><span id="l3.1673" class="difflineminus">-    let collection = new GlodaCollection(items, aQuery);</span>
<a href="#l3.1674"></a><span id="l3.1674" class="difflineminus">-    GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l3.1675"></a><span id="l3.1675" class="difflineplus">+    else { // async!</span>
<a href="#l3.1676"></a><span id="l3.1676" class="difflineplus">+      let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l3.1677"></a><span id="l3.1677" class="difflineplus">+      let collection = new GlodaCollection([], aQuery, aListener);    </span>
<a href="#l3.1678"></a><span id="l3.1678" class="difflineplus">+      GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l3.1679"></a><span id="l3.1679" class="difflineplus">+</span>
<a href="#l3.1680"></a><span id="l3.1680" class="difflineplus">+      statement.executeAsync(new QueryFromQueryCallback(statement, nounMeta,</span>
<a href="#l3.1681"></a><span id="l3.1681" class="difflineplus">+        collection));</span>
<a href="#l3.1682"></a><span id="l3.1682" class="difflineplus">+    }</span>
<a href="#l3.1683"></a><span id="l3.1683">     return collection;</span>
<a href="#l3.1684"></a><span id="l3.1684">   },</span>
<a href="#l3.1685"></a><span id="l3.1685">   </span>
<a href="#l3.1686"></a><span id="l3.1686">   /**</span>
<a href="#l3.1687"></a><span id="l3.1687" class="difflineminus">-   * Deprecated.  Use queries (which in turn use queryFromQuery).  This was a</span>
<a href="#l3.1688"></a><span id="l3.1688" class="difflineminus">-   *  means of querying for messages based on (normalized) attributes by</span>
<a href="#l3.1689"></a><span id="l3.1689" class="difflineminus">-   *  specifying an APV style query.  This method does not track changes in the</span>
<a href="#l3.1690"></a><span id="l3.1690" class="difflineminus">-   *  APV representation idiom for queries and may possess other shortcomings.</span>
<a href="#l3.1691"></a><span id="l3.1691" class="difflineplus">+   * Deprecated, but still in existence for the benefit of expmess code that</span>
<a href="#l3.1692"></a><span id="l3.1692" class="difflineplus">+   *  needs to go away anyways and can take this with it.</span>
<a href="#l3.1693"></a><span id="l3.1693">    */</span>
<a href="#l3.1694"></a><span id="l3.1694">   queryMessagesAPV: function gloda_ds_queryMessagesAPV(aAPVs) {</span>
<a href="#l3.1695"></a><span id="l3.1695">     let selects = [];</span>
<a href="#l3.1696"></a><span id="l3.1696">     </span>
<a href="#l3.1697"></a><span id="l3.1697">     for (let iAPV=0; iAPV &lt; aAPVs.length; iAPV++) {</span>
<a href="#l3.1698"></a><span id="l3.1698">       let APV = aAPVs[iAPV];</span>
<a href="#l3.1699"></a><span id="l3.1699">       </span>
<a href="#l3.1700"></a><span id="l3.1700">       let attributeID;</span>
<a href="#l3.1701"></a><span id="l3.1701" class="difflineat">@@ -1557,213 +1848,250 @@ let GlodaDatastore = {</span>
<a href="#l3.1702"></a><span id="l3.1702">         //  (in other words, this shouldn't hurt our use of indices)</span>
<a href="#l3.1703"></a><span id="l3.1703">         select += &quot; AND value BETWEEN &quot; + APV[2] + &quot; AND &quot; + APV[3];</span>
<a href="#l3.1704"></a><span id="l3.1704">       }</span>
<a href="#l3.1705"></a><span id="l3.1705">       selects.push(select);</span>
<a href="#l3.1706"></a><span id="l3.1706">     }</span>
<a href="#l3.1707"></a><span id="l3.1707">     </span>
<a href="#l3.1708"></a><span id="l3.1708">     let sqlString = &quot;SELECT * FROM messages WHERE id IN (&quot; +</span>
<a href="#l3.1709"></a><span id="l3.1709">                     selects.join(&quot; INTERSECT &quot;) + &quot; )&quot;;</span>
<a href="#l3.1710"></a><span id="l3.1710" class="difflineminus">-    let statement = this._createStatement(sqlString);</span>
<a href="#l3.1711"></a><span id="l3.1711" class="difflineplus">+    let statement = this._createSyncStatement(sqlString, true);</span>
<a href="#l3.1712"></a><span id="l3.1712">     </span>
<a href="#l3.1713"></a><span id="l3.1713">     let messages = [];</span>
<a href="#l3.1714"></a><span id="l3.1714" class="difflineminus">-    while (statement.step()) {</span>
<a href="#l3.1715"></a><span id="l3.1715" class="difflineminus">-      messages.push(this._messageFromRow(statement.row));</span>
<a href="#l3.1716"></a><span id="l3.1716" class="difflineplus">+    while (statement.executeStep()) {</span>
<a href="#l3.1717"></a><span id="l3.1717" class="difflineplus">+      messages.push(this._messageFromRow(statement));</span>
<a href="#l3.1718"></a><span id="l3.1718">     }</span>
<a href="#l3.1719"></a><span id="l3.1719" class="difflineminus">-    statement.reset();</span>
<a href="#l3.1720"></a><span id="l3.1720" class="difflineplus">+    statement.finalize();</span>
<a href="#l3.1721"></a><span id="l3.1721">     </span>
<a href="#l3.1722"></a><span id="l3.1722">     if (messages.length)</span>
<a href="#l3.1723"></a><span id="l3.1723">       GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l3.1724"></a><span id="l3.1724">                                             messages);</span>
<a href="#l3.1725"></a><span id="l3.1725">      </span>
<a href="#l3.1726"></a><span id="l3.1726">     return messages;</span>
<a href="#l3.1727"></a><span id="l3.1727">   },</span>
<a href="#l3.1728"></a><span id="l3.1728">   </span>
<a href="#l3.1729"></a><span id="l3.1729">   /* ********** Contact ********** */</span>
<a href="#l3.1730"></a><span id="l3.1730" class="difflineplus">+  _nextContactId: 1,</span>
<a href="#l3.1731"></a><span id="l3.1731" class="difflineplus">+</span>
<a href="#l3.1732"></a><span id="l3.1732" class="difflineplus">+  _populateContactManagedId: function () {</span>
<a href="#l3.1733"></a><span id="l3.1733" class="difflineplus">+    let stmt = this._createSyncStatement(&quot;SELECT MAX(id) FROM contacts&quot;, true);</span>
<a href="#l3.1734"></a><span id="l3.1734" class="difflineplus">+    if (stmt.executeStep()) {</span>
<a href="#l3.1735"></a><span id="l3.1735" class="difflineplus">+      this._nextContactId = stmt.getInt64(0) + 1;</span>
<a href="#l3.1736"></a><span id="l3.1736" class="difflineplus">+    }</span>
<a href="#l3.1737"></a><span id="l3.1737" class="difflineplus">+    stmt.finalize();</span>
<a href="#l3.1738"></a><span id="l3.1738" class="difflineplus">+  },</span>
<a href="#l3.1739"></a><span id="l3.1739" class="difflineplus">+  </span>
<a href="#l3.1740"></a><span id="l3.1740">   get _insertContactStatement() {</span>
<a href="#l3.1741"></a><span id="l3.1741" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1742"></a><span id="l3.1742" class="difflineminus">-      &quot;INSERT INTO contacts (directoryUUID, contactUUID, name, popularity,\</span>
<a href="#l3.1743"></a><span id="l3.1743" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.1744"></a><span id="l3.1744" class="difflineplus">+      &quot;INSERT INTO contacts (id, directoryUUID, contactUUID, name, popularity,\</span>
<a href="#l3.1745"></a><span id="l3.1745">                              frecency) \</span>
<a href="#l3.1746"></a><span id="l3.1746" class="difflineminus">-              VALUES (:directoryUUID, :contactUUID, :name, :popularity,\</span>
<a href="#l3.1747"></a><span id="l3.1747" class="difflineminus">-                      :frecency)&quot;);</span>
<a href="#l3.1748"></a><span id="l3.1748" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l3.1749"></a><span id="l3.1749">     this.__defineGetter__(&quot;_insertContactStatement&quot;, function() statement);</span>
<a href="#l3.1750"></a><span id="l3.1750">     return this._insertContactStatement; </span>
<a href="#l3.1751"></a><span id="l3.1751">   },</span>
<a href="#l3.1752"></a><span id="l3.1752">   </span>
<a href="#l3.1753"></a><span id="l3.1753">   createContact: function gloda_ds_createContact(aDirectoryUUID, aContactUUID,</span>
<a href="#l3.1754"></a><span id="l3.1754">       aName, aPopularity, aFrecency) {</span>
<a href="#l3.1755"></a><span id="l3.1755" class="difflineplus">+    let contactID = this._nextContactId++;</span>
<a href="#l3.1756"></a><span id="l3.1756">     let ics = this._insertContactStatement;</span>
<a href="#l3.1757"></a><span id="l3.1757" class="difflineminus">-    ics.params.directoryUUID = aDirectoryUUID;</span>
<a href="#l3.1758"></a><span id="l3.1758" class="difflineminus">-    ics.params.contactUUID = aContactUUID;</span>
<a href="#l3.1759"></a><span id="l3.1759" class="difflineminus">-    ics.params.name = aName;</span>
<a href="#l3.1760"></a><span id="l3.1760" class="difflineminus">-    ics.params.popularity = aPopularity;</span>
<a href="#l3.1761"></a><span id="l3.1761" class="difflineminus">-    ics.params.frecency = aFrecency;</span>
<a href="#l3.1762"></a><span id="l3.1762" class="difflineplus">+    ics.bindInt64Parameter(0, contactID);</span>
<a href="#l3.1763"></a><span id="l3.1763" class="difflineplus">+    if (aDirectoryUUID == null)</span>
<a href="#l3.1764"></a><span id="l3.1764" class="difflineplus">+      ics.bindNullParameter(1);</span>
<a href="#l3.1765"></a><span id="l3.1765" class="difflineplus">+    else</span>
<a href="#l3.1766"></a><span id="l3.1766" class="difflineplus">+      ics.bindStringParameter(1, aDirectoryUUID);</span>
<a href="#l3.1767"></a><span id="l3.1767" class="difflineplus">+    if (aContactUUID == null)</span>
<a href="#l3.1768"></a><span id="l3.1768" class="difflineplus">+      ics.bindNullParameter(2);</span>
<a href="#l3.1769"></a><span id="l3.1769" class="difflineplus">+    else</span>
<a href="#l3.1770"></a><span id="l3.1770" class="difflineplus">+      ics.bindStringParameter(2, aContactUUID);</span>
<a href="#l3.1771"></a><span id="l3.1771" class="difflineplus">+    ics.bindStringParameter(3, aName);</span>
<a href="#l3.1772"></a><span id="l3.1772" class="difflineplus">+    ics.bindInt64Parameter(4, aPopularity);</span>
<a href="#l3.1773"></a><span id="l3.1773" class="difflineplus">+    ics.bindInt64Parameter(5, aFrecency);</span>
<a href="#l3.1774"></a><span id="l3.1774">     </span>
<a href="#l3.1775"></a><span id="l3.1775" class="difflineminus">-    ics.execute();</span>
<a href="#l3.1776"></a><span id="l3.1776" class="difflineplus">+    ics.executeAsync();</span>
<a href="#l3.1777"></a><span id="l3.1777">     </span>
<a href="#l3.1778"></a><span id="l3.1778" class="difflineminus">-    let contact = new GlodaContact(this, this.dbConnection.lastInsertRowID,</span>
<a href="#l3.1779"></a><span id="l3.1779" class="difflineplus">+    let contact = new GlodaContact(this, contactID,</span>
<a href="#l3.1780"></a><span id="l3.1780">                                    aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l3.1781"></a><span id="l3.1781">                                    aPopularity, aFrecency);</span>
<a href="#l3.1782"></a><span id="l3.1782">     GlodaCollectionManager.itemsAdded(contact.NOUN_ID, [contact]);</span>
<a href="#l3.1783"></a><span id="l3.1783">     return contact;</span>
<a href="#l3.1784"></a><span id="l3.1784">   },</span>
<a href="#l3.1785"></a><span id="l3.1785"> </span>
<a href="#l3.1786"></a><span id="l3.1786">   get _updateContactStatement() {</span>
<a href="#l3.1787"></a><span id="l3.1787" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1788"></a><span id="l3.1788" class="difflineminus">-      &quot;UPDATE contacts SET directoryUUID = :directoryUUID, \</span>
<a href="#l3.1789"></a><span id="l3.1789" class="difflineminus">-                           contactUUID = :contactUUID, \</span>
<a href="#l3.1790"></a><span id="l3.1790" class="difflineminus">-                           name = :name, \</span>
<a href="#l3.1791"></a><span id="l3.1791" class="difflineminus">-                           popularity = :popularity, \</span>
<a href="#l3.1792"></a><span id="l3.1792" class="difflineminus">-                           frecency = :frecency \</span>
<a href="#l3.1793"></a><span id="l3.1793" class="difflineminus">-                       WHERE id = :id&quot;);</span>
<a href="#l3.1794"></a><span id="l3.1794" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.1795"></a><span id="l3.1795" class="difflineplus">+      &quot;UPDATE contacts SET directoryUUID = ?1, \</span>
<a href="#l3.1796"></a><span id="l3.1796" class="difflineplus">+                           contactUUID = ?2, \</span>
<a href="#l3.1797"></a><span id="l3.1797" class="difflineplus">+                           name = ?3, \</span>
<a href="#l3.1798"></a><span id="l3.1798" class="difflineplus">+                           popularity = ?4, \</span>
<a href="#l3.1799"></a><span id="l3.1799" class="difflineplus">+                           frecency = ?5 \</span>
<a href="#l3.1800"></a><span id="l3.1800" class="difflineplus">+                       WHERE id = ?6&quot;);</span>
<a href="#l3.1801"></a><span id="l3.1801">     this.__defineGetter__(&quot;_updateContactStatement&quot;, function() statement);</span>
<a href="#l3.1802"></a><span id="l3.1802">     return this._updateContactStatement; </span>
<a href="#l3.1803"></a><span id="l3.1803">   },</span>
<a href="#l3.1804"></a><span id="l3.1804"> </span>
<a href="#l3.1805"></a><span id="l3.1805">   updateContact: function gloda_ds_updateContact(aContact) {</span>
<a href="#l3.1806"></a><span id="l3.1806">     let ucs = this._updateContactStatement;</span>
<a href="#l3.1807"></a><span id="l3.1807" class="difflineminus">-    ucs.params.id = aContact.id;</span>
<a href="#l3.1808"></a><span id="l3.1808" class="difflineminus">-    ucs.params.directoryUUID = aContact.directoryUUID;</span>
<a href="#l3.1809"></a><span id="l3.1809" class="difflineminus">-    ucs.params.contactUUID = aContact.contactUUID;</span>
<a href="#l3.1810"></a><span id="l3.1810" class="difflineminus">-    ucs.params.name = aContact.name;</span>
<a href="#l3.1811"></a><span id="l3.1811" class="difflineminus">-    ucs.params.popularity = aContact.popularity;</span>
<a href="#l3.1812"></a><span id="l3.1812" class="difflineminus">-    ucs.params.frecency = aContact.frecency;</span>
<a href="#l3.1813"></a><span id="l3.1813" class="difflineplus">+    ucs.bindInt64Parameter(5, aContact.id);</span>
<a href="#l3.1814"></a><span id="l3.1814" class="difflineplus">+    ucs.bindStringParameter(0, aContact.directoryUUID);</span>
<a href="#l3.1815"></a><span id="l3.1815" class="difflineplus">+    ucs.bindStringParameter(1, aContact.contactUUID);</span>
<a href="#l3.1816"></a><span id="l3.1816" class="difflineplus">+    ucs.bindStringParameter(2, aContact.name);</span>
<a href="#l3.1817"></a><span id="l3.1817" class="difflineplus">+    ucs.bindInt64Parameter(3, aContact.popularity);</span>
<a href="#l3.1818"></a><span id="l3.1818" class="difflineplus">+    ucs.bindInt64Parameter(4, aContact.frecency);</span>
<a href="#l3.1819"></a><span id="l3.1819">     </span>
<a href="#l3.1820"></a><span id="l3.1820" class="difflineminus">-    ucs.execute();</span>
<a href="#l3.1821"></a><span id="l3.1821" class="difflineplus">+    ucs.executeAsync();</span>
<a href="#l3.1822"></a><span id="l3.1822">   },</span>
<a href="#l3.1823"></a><span id="l3.1823">   </span>
<a href="#l3.1824"></a><span id="l3.1824">   _contactFromRow: function gloda_ds_contactFromRow(aRow) {</span>
<a href="#l3.1825"></a><span id="l3.1825" class="difflineminus">-    return new GlodaContact(this, aRow[&quot;id&quot;], aRow[&quot;directoryUUID&quot;],</span>
<a href="#l3.1826"></a><span id="l3.1826" class="difflineminus">-                            aRow[&quot;contactUUID&quot;], aRow[&quot;name&quot;],</span>
<a href="#l3.1827"></a><span id="l3.1827" class="difflineminus">-                            aRow[&quot;popularity&quot;], aRow[&quot;frecency&quot;]);</span>
<a href="#l3.1828"></a><span id="l3.1828" class="difflineplus">+    let directoryUUID, contactUUID;</span>
<a href="#l3.1829"></a><span id="l3.1829" class="difflineplus">+    if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l3.1830"></a><span id="l3.1830" class="difflineplus">+      directoryUUID = null;</span>
<a href="#l3.1831"></a><span id="l3.1831" class="difflineplus">+    else</span>
<a href="#l3.1832"></a><span id="l3.1832" class="difflineplus">+      directoryUUID = aRow.getString(1);</span>
<a href="#l3.1833"></a><span id="l3.1833" class="difflineplus">+      </span>
<a href="#l3.1834"></a><span id="l3.1834" class="difflineplus">+    return new GlodaContact(this, aRow.getInt64(0), directoryUUID,</span>
<a href="#l3.1835"></a><span id="l3.1835" class="difflineplus">+                            contactUUID, aRow.getString(3),</span>
<a href="#l3.1836"></a><span id="l3.1836" class="difflineplus">+                            aRow.getInt64(4), aRow.getInt64(5));</span>
<a href="#l3.1837"></a><span id="l3.1837">   },</span>
<a href="#l3.1838"></a><span id="l3.1838">   </span>
<a href="#l3.1839"></a><span id="l3.1839">   get _selectContactByIDStatement() {</span>
<a href="#l3.1840"></a><span id="l3.1840" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1841"></a><span id="l3.1841" class="difflineminus">-      &quot;SELECT * FROM contacts WHERE id = :id&quot;);</span>
<a href="#l3.1842"></a><span id="l3.1842" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1843"></a><span id="l3.1843" class="difflineplus">+      &quot;SELECT * FROM contacts WHERE id = ?1&quot;);</span>
<a href="#l3.1844"></a><span id="l3.1844">     this.__defineGetter__(&quot;_selectContactByIDStatement&quot;,</span>
<a href="#l3.1845"></a><span id="l3.1845">       function() statement);</span>
<a href="#l3.1846"></a><span id="l3.1846">     return this._selectContactByIDStatement;</span>
<a href="#l3.1847"></a><span id="l3.1847">   },</span>
<a href="#l3.1848"></a><span id="l3.1848"> </span>
<a href="#l3.1849"></a><span id="l3.1849">   getContactByID: function gloda_ds_getContactByID(aContactID) {</span>
<a href="#l3.1850"></a><span id="l3.1850">     let contact = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l3.1851"></a><span id="l3.1851">       GlodaContact.prototype.NOUN_ID, aContactID);</span>
<a href="#l3.1852"></a><span id="l3.1852">     </span>
<a href="#l3.1853"></a><span id="l3.1853">     if (contact === null) {</span>
<a href="#l3.1854"></a><span id="l3.1854">       let scbi = this._selectContactByIDStatement;</span>
<a href="#l3.1855"></a><span id="l3.1855" class="difflineminus">-      scbi.params.id = aContactID;</span>
<a href="#l3.1856"></a><span id="l3.1856" class="difflineminus">-      if (scbi.step()) {</span>
<a href="#l3.1857"></a><span id="l3.1857" class="difflineminus">-        contact = this._contactFromRow(scbi.row);</span>
<a href="#l3.1858"></a><span id="l3.1858" class="difflineplus">+      scbi.bindInt64Parameter(0, aContactID);</span>
<a href="#l3.1859"></a><span id="l3.1859" class="difflineplus">+      if (scbi.executeStep()) {</span>
<a href="#l3.1860"></a><span id="l3.1860" class="difflineplus">+        contact = this._contactFromRow(scbi);</span>
<a href="#l3.1861"></a><span id="l3.1861">         GlodaCollectionManager.itemLoaded(contact);</span>
<a href="#l3.1862"></a><span id="l3.1862">       }</span>
<a href="#l3.1863"></a><span id="l3.1863">       scbi.reset();</span>
<a href="#l3.1864"></a><span id="l3.1864">     }</span>
<a href="#l3.1865"></a><span id="l3.1865">     </span>
<a href="#l3.1866"></a><span id="l3.1866">     return contact;</span>
<a href="#l3.1867"></a><span id="l3.1867">   },</span>
<a href="#l3.1868"></a><span id="l3.1868">   </span>
<a href="#l3.1869"></a><span id="l3.1869">   /* ********** Identity ********** */</span>
<a href="#l3.1870"></a><span id="l3.1870" class="difflineplus">+  /** next identity id, managed for async use reasons. */</span>
<a href="#l3.1871"></a><span id="l3.1871" class="difflineplus">+  _nextIdentityId: 1,</span>
<a href="#l3.1872"></a><span id="l3.1872" class="difflineplus">+  _populateIdentityManagedId: function () {</span>
<a href="#l3.1873"></a><span id="l3.1873" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l3.1874"></a><span id="l3.1874" class="difflineplus">+      &quot;SELECT MAX(id) FROM identities&quot;, true);</span>
<a href="#l3.1875"></a><span id="l3.1875" class="difflineplus">+    if (stmt.executeStep()) {</span>
<a href="#l3.1876"></a><span id="l3.1876" class="difflineplus">+      this._nextIdentityId = stmt.getInt64(0) + 1;</span>
<a href="#l3.1877"></a><span id="l3.1877" class="difflineplus">+    }</span>
<a href="#l3.1878"></a><span id="l3.1878" class="difflineplus">+    stmt.finalize();</span>
<a href="#l3.1879"></a><span id="l3.1879" class="difflineplus">+  },</span>
<a href="#l3.1880"></a><span id="l3.1880" class="difflineplus">+  </span>
<a href="#l3.1881"></a><span id="l3.1881">   get _insertIdentityStatement() {</span>
<a href="#l3.1882"></a><span id="l3.1882" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1883"></a><span id="l3.1883" class="difflineminus">-      &quot;INSERT INTO identities (contactID, kind, value, description, relay) \</span>
<a href="#l3.1884"></a><span id="l3.1884" class="difflineminus">-              VALUES (:contactID, :kind, :value, :description, :relay)&quot;);</span>
<a href="#l3.1885"></a><span id="l3.1885" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l3.1886"></a><span id="l3.1886" class="difflineplus">+      &quot;INSERT INTO identities (id, contactID, kind, value, description, relay) \</span>
<a href="#l3.1887"></a><span id="l3.1887" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l3.1888"></a><span id="l3.1888">     this.__defineGetter__(&quot;_insertIdentityStatement&quot;, function() statement);</span>
<a href="#l3.1889"></a><span id="l3.1889">     return this._insertIdentityStatement; </span>
<a href="#l3.1890"></a><span id="l3.1890">   },</span>
<a href="#l3.1891"></a><span id="l3.1891">   </span>
<a href="#l3.1892"></a><span id="l3.1892">   createIdentity: function gloda_ds_createIdentity(aContactID, aContact, aKind,</span>
<a href="#l3.1893"></a><span id="l3.1893">                                                    aValue, aDescription,</span>
<a href="#l3.1894"></a><span id="l3.1894">                                                    aIsRelay) {</span>
<a href="#l3.1895"></a><span id="l3.1895" class="difflineplus">+    let identityID = this._nextIdentityId++;</span>
<a href="#l3.1896"></a><span id="l3.1896">     let iis = this._insertIdentityStatement;</span>
<a href="#l3.1897"></a><span id="l3.1897" class="difflineminus">-    iis.params.contactID = aContactID;</span>
<a href="#l3.1898"></a><span id="l3.1898" class="difflineminus">-    iis.params.kind = aKind;</span>
<a href="#l3.1899"></a><span id="l3.1899" class="difflineminus">-    iis.params.value = aValue;</span>
<a href="#l3.1900"></a><span id="l3.1900" class="difflineminus">-    iis.params.description = aDescription;</span>
<a href="#l3.1901"></a><span id="l3.1901" class="difflineminus">-    iis.params.relay = aIsRelay ? 1 : 0;</span>
<a href="#l3.1902"></a><span id="l3.1902" class="difflineminus">-    iis.execute();</span>
<a href="#l3.1903"></a><span id="l3.1903" class="difflineplus">+    iis.bindInt64Parameter(0, identityID);</span>
<a href="#l3.1904"></a><span id="l3.1904" class="difflineplus">+    iis.bindInt64Parameter(1, aContactID);</span>
<a href="#l3.1905"></a><span id="l3.1905" class="difflineplus">+    iis.bindStringParameter(2, aKind);</span>
<a href="#l3.1906"></a><span id="l3.1906" class="difflineplus">+    iis.bindStringParameter(3, aValue);</span>
<a href="#l3.1907"></a><span id="l3.1907" class="difflineplus">+    iis.bindStringParameter(4, aDescription);</span>
<a href="#l3.1908"></a><span id="l3.1908" class="difflineplus">+    iis.bindInt64Parameter(5, aIsRelay ? 1 : 0);</span>
<a href="#l3.1909"></a><span id="l3.1909" class="difflineplus">+    iis.executeAsync();</span>
<a href="#l3.1910"></a><span id="l3.1910">   </span>
<a href="#l3.1911"></a><span id="l3.1911" class="difflineminus">-    let identity = new GlodaIdentity(this, this.dbConnection.lastInsertRowID,</span>
<a href="#l3.1912"></a><span id="l3.1912" class="difflineplus">+    let identity = new GlodaIdentity(this, identityID,</span>
<a href="#l3.1913"></a><span id="l3.1913">                                      aContactID, aContact, aKind, aValue,</span>
<a href="#l3.1914"></a><span id="l3.1914">                                      aDescription, aIsRelay);</span>
<a href="#l3.1915"></a><span id="l3.1915">     GlodaCollectionManager.itemsAdded(identity.NOUN_ID, [identity]);</span>
<a href="#l3.1916"></a><span id="l3.1916">     return identity;</span>
<a href="#l3.1917"></a><span id="l3.1917">   },</span>
<a href="#l3.1918"></a><span id="l3.1918">   </span>
<a href="#l3.1919"></a><span id="l3.1919">   _identityFromRow: function gloda_ds_identityFromRow(aRow) {</span>
<a href="#l3.1920"></a><span id="l3.1920" class="difflineminus">-    return new GlodaIdentity(this, aRow[&quot;id&quot;], aRow[&quot;contactID&quot;], null,</span>
<a href="#l3.1921"></a><span id="l3.1921" class="difflineminus">-                             aRow[&quot;kind&quot;], aRow[&quot;value&quot;], aRow[&quot;description&quot;],</span>
<a href="#l3.1922"></a><span id="l3.1922" class="difflineminus">-                             aRow[&quot;relay&quot;] ? true : false);</span>
<a href="#l3.1923"></a><span id="l3.1923" class="difflineplus">+    return new GlodaIdentity(this, aRow.getInt64(0), aRow.getInt64(1), null,</span>
<a href="#l3.1924"></a><span id="l3.1924" class="difflineplus">+                             aRow.getString(2), aRow.getString(3),</span>
<a href="#l3.1925"></a><span id="l3.1925" class="difflineplus">+                             aRow.getString(4),</span>
<a href="#l3.1926"></a><span id="l3.1926" class="difflineplus">+                             aRow.getInt32(5) ? true : false);</span>
<a href="#l3.1927"></a><span id="l3.1927">   },</span>
<a href="#l3.1928"></a><span id="l3.1928">   </span>
<a href="#l3.1929"></a><span id="l3.1929">   get _selectIdentityByKindValueStatement() {</span>
<a href="#l3.1930"></a><span id="l3.1930" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1931"></a><span id="l3.1931" class="difflineminus">-      &quot;SELECT * FROM identities WHERE kind = :kind AND value = :value&quot;);</span>
<a href="#l3.1932"></a><span id="l3.1932" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1933"></a><span id="l3.1933" class="difflineplus">+      &quot;SELECT * FROM identities WHERE kind = ?1 AND value = ?2&quot;);</span>
<a href="#l3.1934"></a><span id="l3.1934">     this.__defineGetter__(&quot;_selectIdentityByKindValueStatement&quot;,</span>
<a href="#l3.1935"></a><span id="l3.1935">       function() statement);</span>
<a href="#l3.1936"></a><span id="l3.1936">     return this._selectIdentityByKindValueStatement;</span>
<a href="#l3.1937"></a><span id="l3.1937">   },</span>
<a href="#l3.1938"></a><span id="l3.1938"> </span>
<a href="#l3.1939"></a><span id="l3.1939">   /** Lookup an identity by kind and value.  Ex: (email, foo@bar.com) */</span>
<a href="#l3.1940"></a><span id="l3.1940">   getIdentity: function gloda_ds_getIdentity(aKind, aValue) {</span>
<a href="#l3.1941"></a><span id="l3.1941">     let identity = null;</span>
<a href="#l3.1942"></a><span id="l3.1942">     </span>
<a href="#l3.1943"></a><span id="l3.1943">     let ibkv = this._selectIdentityByKindValueStatement;</span>
<a href="#l3.1944"></a><span id="l3.1944" class="difflineminus">-    ibkv.params.kind = aKind;</span>
<a href="#l3.1945"></a><span id="l3.1945" class="difflineminus">-    ibkv.params.value = aValue;</span>
<a href="#l3.1946"></a><span id="l3.1946" class="difflineminus">-    if (ibkv.step()) {</span>
<a href="#l3.1947"></a><span id="l3.1947" class="difflineminus">-      identity = this._identityFromRow(ibkv.row);</span>
<a href="#l3.1948"></a><span id="l3.1948" class="difflineplus">+    ibkv.bindStringParameter(0, aKind);</span>
<a href="#l3.1949"></a><span id="l3.1949" class="difflineplus">+    ibkv.bindStringParameter(1, aValue);</span>
<a href="#l3.1950"></a><span id="l3.1950" class="difflineplus">+    if (ibkv.executeStep()) {</span>
<a href="#l3.1951"></a><span id="l3.1951" class="difflineplus">+      identity = this._identityFromRow(ibkv);</span>
<a href="#l3.1952"></a><span id="l3.1952">     }</span>
<a href="#l3.1953"></a><span id="l3.1953">     ibkv.reset();</span>
<a href="#l3.1954"></a><span id="l3.1954">     </span>
<a href="#l3.1955"></a><span id="l3.1955">     return identity &amp;&amp; GlodaCollectionManager.cacheLoadUnifyOne(identity);</span>
<a href="#l3.1956"></a><span id="l3.1956">   },</span>
<a href="#l3.1957"></a><span id="l3.1957"> </span>
<a href="#l3.1958"></a><span id="l3.1958">   get _selectIdentityByIDStatement() {</span>
<a href="#l3.1959"></a><span id="l3.1959" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1960"></a><span id="l3.1960" class="difflineminus">-      &quot;SELECT * FROM identities WHERE id = :id&quot;);</span>
<a href="#l3.1961"></a><span id="l3.1961" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1962"></a><span id="l3.1962" class="difflineplus">+      &quot;SELECT * FROM identities WHERE id = ?1&quot;);</span>
<a href="#l3.1963"></a><span id="l3.1963">     this.__defineGetter__(&quot;_selectIdentityByIDStatement&quot;,</span>
<a href="#l3.1964"></a><span id="l3.1964">       function() statement);</span>
<a href="#l3.1965"></a><span id="l3.1965">     return this._selectIdentityByIDStatement;</span>
<a href="#l3.1966"></a><span id="l3.1966">   },</span>
<a href="#l3.1967"></a><span id="l3.1967"> </span>
<a href="#l3.1968"></a><span id="l3.1968">   getIdentityByID: function gloda_ds_getIdentityByID(aID) {</span>
<a href="#l3.1969"></a><span id="l3.1969">     let identity = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l3.1970"></a><span id="l3.1970">       GlodaIdentity.prototype.NOUN_ID, aID);</span>
<a href="#l3.1971"></a><span id="l3.1971">     </span>
<a href="#l3.1972"></a><span id="l3.1972">     if (identity === null) {</span>
<a href="#l3.1973"></a><span id="l3.1973">       let sibis = this._selectIdentityByIDStatement;</span>
<a href="#l3.1974"></a><span id="l3.1974" class="difflineminus">-      sibis.params.id = aID;</span>
<a href="#l3.1975"></a><span id="l3.1975" class="difflineminus">-      if (sibis.step()) {</span>
<a href="#l3.1976"></a><span id="l3.1976" class="difflineminus">-        identity = this._identityFromRow(sibis.row);</span>
<a href="#l3.1977"></a><span id="l3.1977" class="difflineplus">+      sibis.bindInt64Parameter(0, aID);</span>
<a href="#l3.1978"></a><span id="l3.1978" class="difflineplus">+      if (sibis.executeStep()) {</span>
<a href="#l3.1979"></a><span id="l3.1979" class="difflineplus">+        identity = this._identityFromRow(sibis);</span>
<a href="#l3.1980"></a><span id="l3.1980">         GlodaCollectionManager.itemLoaded(identity);</span>
<a href="#l3.1981"></a><span id="l3.1981">       }</span>
<a href="#l3.1982"></a><span id="l3.1982">       sibis.reset();</span>
<a href="#l3.1983"></a><span id="l3.1983">     }</span>
<a href="#l3.1984"></a><span id="l3.1984">     </span>
<a href="#l3.1985"></a><span id="l3.1985">     return identity;</span>
<a href="#l3.1986"></a><span id="l3.1986">   },</span>
<a href="#l3.1987"></a><span id="l3.1987"> </span>
<a href="#l3.1988"></a><span id="l3.1988">   get _selectIdentityByContactIDStatement() {</span>
<a href="#l3.1989"></a><span id="l3.1989" class="difflineminus">-    let statement = this._createStatement(</span>
<a href="#l3.1990"></a><span id="l3.1990" class="difflineminus">-      &quot;SELECT * FROM identities WHERE contactID = :contactID&quot;);</span>
<a href="#l3.1991"></a><span id="l3.1991" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l3.1992"></a><span id="l3.1992" class="difflineplus">+      &quot;SELECT * FROM identities WHERE contactID = ?1&quot;);</span>
<a href="#l3.1993"></a><span id="l3.1993">     this.__defineGetter__(&quot;_selectIdentityByContactIDStatement&quot;,</span>
<a href="#l3.1994"></a><span id="l3.1994">       function() statement);</span>
<a href="#l3.1995"></a><span id="l3.1995">     return this._selectIdentityByContactIDStatement;</span>
<a href="#l3.1996"></a><span id="l3.1996">   },</span>
<a href="#l3.1997"></a><span id="l3.1997"> </span>
<a href="#l3.1998"></a><span id="l3.1998">   getIdentitiesByContactID: function gloda_ds_getIdentitiesByContactID(</span>
<a href="#l3.1999"></a><span id="l3.1999">       aContactID) {</span>
<a href="#l3.2000"></a><span id="l3.2000">     let sibcs = this._selectIdentityByContactIDStatement;</span>
<a href="#l3.2001"></a><span id="l3.2001">     </span>
<a href="#l3.2002"></a><span id="l3.2002" class="difflineminus">-    sibcs.params.contactID = aContactID;</span>
<a href="#l3.2003"></a><span id="l3.2003" class="difflineplus">+    sibcs.bindInt64Parameter(0, aContactID);</span>
<a href="#l3.2004"></a><span id="l3.2004">     </span>
<a href="#l3.2005"></a><span id="l3.2005">     let identities = [];</span>
<a href="#l3.2006"></a><span id="l3.2006" class="difflineminus">-    while (sibcs.step()) {</span>
<a href="#l3.2007"></a><span id="l3.2007" class="difflineminus">-      identities.push(this._identityFromRow(sibcs.row));</span>
<a href="#l3.2008"></a><span id="l3.2008" class="difflineplus">+    while (sibcs.executeStep()) {</span>
<a href="#l3.2009"></a><span id="l3.2009" class="difflineplus">+      identities.push(this._identityFromRow(sibcs));</span>
<a href="#l3.2010"></a><span id="l3.2010">     }</span>
<a href="#l3.2011"></a><span id="l3.2011">     sibcs.reset();</span>
<a href="#l3.2012"></a><span id="l3.2012"> </span>
<a href="#l3.2013"></a><span id="l3.2013">     if (identities.length)</span>
<a href="#l3.2014"></a><span id="l3.2014">       GlodaCollectionManager.cacheLoadUnify(GlodaIdentity.prototype.NOUN_ID,</span>
<a href="#l3.2015"></a><span id="l3.2015">                                             identities);</span>
<a href="#l3.2016"></a><span id="l3.2016">     return identities;</span>
<a href="#l3.2017"></a><span id="l3.2017">   },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -180,35 +180,20 @@ let Gloda = {</span>
<a href="#l4.4"></a><span id="l4.4">   kIndexerIdle: 0,</span>
<a href="#l4.5"></a><span id="l4.5">   kIndexerIndexing: 1,</span>
<a href="#l4.6"></a><span id="l4.6">   kIndexerMoving: 2,</span>
<a href="#l4.7"></a><span id="l4.7">   kIndexerRemoving: 3,</span>
<a href="#l4.8"></a><span id="l4.8">   </span>
<a href="#l4.9"></a><span id="l4.9">   /**</span>
<a href="#l4.10"></a><span id="l4.10">    * Given an nsIMsgDBHdr, return the gloda message object that corresponds to</span>
<a href="#l4.11"></a><span id="l4.11">    *  it.  If no such message exists, null is returned.</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-   *</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">-   * Ideally, if gloda is unable to locate a gloda message corresponding to the</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineminus">-   *  header, and it has not been told to avoid indexing the message (based on</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineminus">-   *  folder or other criteria), and the message is not currently queued for</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">-   *  indexing, it should take some action to resolve the issue.  Either by</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineminus">-   *  indexing the single message, or checking if an entire folder has been</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineminus">-   *  overlooked, etc.</span>
<a href="#l4.19"></a><span id="l4.19">    */</span>
<a href="#l4.20"></a><span id="l4.20">   getMessageForHeader: function gloda_ns_getMessageForHeader(aMsgHdr) {</span>
<a href="#l4.21"></a><span id="l4.21">     let message = GlodaDatastore.getMessageFromLocation(aMsgHdr.folder.URI,</span>
<a href="#l4.22"></a><span id="l4.22">                                                         aMsgHdr.messageKey);</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineminus">-    if (message === null) {</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineminus">-      message = GlodaDatastore.getMessageByMessageID(aMsgHdr.messageId);</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineminus">-      if (message)</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineminus">-        this._log.info(&quot;Fell back to locating message by id; actual message &quot; +</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineminus">-                       &quot;key is: &quot; + aMsgHdr.messageKey + &quot; database key: &quot; +</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineminus">-                       message.messageKey);</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineminus">-    }</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineminus">-    </span>
<a href="#l4.31"></a><span id="l4.31">     return message;</span>
<a href="#l4.32"></a><span id="l4.32">   },</span>
<a href="#l4.33"></a><span id="l4.33">   </span>
<a href="#l4.34"></a><span id="l4.34">   /**</span>
<a href="#l4.35"></a><span id="l4.35">    * Given one or more full mail addresses (ex: &quot;Bob Smith&quot; &lt;bob@smith.com&gt;),</span>
<a href="#l4.36"></a><span id="l4.36">    *  return a list of the identities that corresponds to each mail address,</span>
<a href="#l4.37"></a><span id="l4.37">    *  creating them as required.</span>
<a href="#l4.38"></a><span id="l4.38">    */</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineat">@@ -1336,12 +1321,18 @@ let Gloda = {</span>
<a href="#l4.40"></a><span id="l4.40">    *  specifying the message noun id.  Still works for now, but not for long.</span>
<a href="#l4.41"></a><span id="l4.41">    */</span>
<a href="#l4.42"></a><span id="l4.42">   queryMessagesAPV: function gloda_ns_queryMessagesAPV(aAPVs) {</span>
<a href="#l4.43"></a><span id="l4.43">     return GlodaDatastore.queryMessagesAPV(aAPVs);</span>
<a href="#l4.44"></a><span id="l4.44">   },</span>
<a href="#l4.45"></a><span id="l4.45"> };</span>
<a href="#l4.46"></a><span id="l4.46"> </span>
<a href="#l4.47"></a><span id="l4.47"> /* and initialize the Gloda object/NS before we return... */</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineminus">-Gloda._init();</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+try {</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+  Gloda._init();</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+}</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineplus">+catch (ex) {</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineplus">+  Gloda._log.debug(&quot;Exception during Gloda init (&quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+                   ex.lineNumber + &quot;): &quot; + ex);</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+}</span>
<a href="#l4.56"></a><span id="l4.56"> /* but don't forget that we effectively depend on everybody.js too, and</span>
<a href="#l4.57"></a><span id="l4.57">    currently on our importer to be importing that if they need us fully armed</span>
<a href="#l4.58"></a><span id="l4.58">    and operational. */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -808,27 +808,35 @@ let GlodaIndexer = {</span>
<a href="#l5.4"></a><span id="l5.4">           this._indexingFolder.getTotalMessages(false) +&quot; messages.&quot;);</span>
<a href="#l5.5"></a><span id="l5.5">         yield kWorkSync;</span>
<a href="#l5.6"></a><span id="l5.6">       }</span>
<a href="#l5.7"></a><span id="l5.7">     }</span>
<a href="#l5.8"></a><span id="l5.8">     </span>
<a href="#l5.9"></a><span id="l5.9">     yield kWorkDone;</span>
<a href="#l5.10"></a><span id="l5.10">   },</span>
<a href="#l5.11"></a><span id="l5.11">   </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+  /**</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+   * Handle the destruction (not just moved to trash) of one or more messages.</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+   */</span>
<a href="#l5.15"></a><span id="l5.15">   _worker_messageDelete: function (aJob) {</span>
<a href="#l5.16"></a><span id="l5.16">     for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l5.17"></a><span id="l5.17">       let item = aJob.items[aJob.offset];</span>
<a href="#l5.18"></a><span id="l5.18"> </span>
<a href="#l5.19"></a><span id="l5.19">       // item is either: a message id</span>
<a href="#l5.20"></a><span id="l5.20">       //              or [folder ID, message key]</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+      // we need to load the actual message because deletion may need to cascade</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+      //  to other tables, which requires us to actually have all of the details</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+      //  on the message available to us.</span>
<a href="#l5.24"></a><span id="l5.24">       let message;</span>
<a href="#l5.25"></a><span id="l5.25">       if (item instanceof Array) {</span>
<a href="#l5.26"></a><span id="l5.26">         if (this._indexingFolderID != item[0])</span>
<a href="#l5.27"></a><span id="l5.27">           yield this._indexerEnterFolder(item[0], false);</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineminus">-        message = this_indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineplus">+        let msgHdr = this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+        let message = GlodaDatastore.getMessageFromLocation(msgHdr.folder.URI,</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+                                                            msgHdr.messageKey);</span>
<a href="#l5.32"></a><span id="l5.32">       }</span>
<a href="#l5.33"></a><span id="l5.33">       else</span>
<a href="#l5.34"></a><span id="l5.34">         message = GlodaDatastore.getMessageByID(item);</span>
<a href="#l5.35"></a><span id="l5.35"> </span>
<a href="#l5.36"></a><span id="l5.36">       // delete the message!</span>
<a href="#l5.37"></a><span id="l5.37">       if (message !== null)</span>
<a href="#l5.38"></a><span id="l5.38">         this._deleteMessage(message);</span>
<a href="#l5.39"></a><span id="l5.39">       yield kWorkSync;</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineat">@@ -1314,18 +1322,29 @@ let GlodaIndexer = {</span>
<a href="#l5.41"></a><span id="l5.41">     //  a conversation.</span>
<a href="#l5.42"></a><span id="l5.42">     </span>
<a href="#l5.43"></a><span id="l5.43">     // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l5.44"></a><span id="l5.44">     // (references are ordered from old [0] to new [n-1])</span>
<a href="#l5.45"></a><span id="l5.45">     let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l5.46"></a><span id="l5.46">                       (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l5.47"></a><span id="l5.47">     // also see if we already know about the message...</span>
<a href="#l5.48"></a><span id="l5.48">     references.push(aMsgHdr.messageId);</span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+    </span>
<a href="#l5.50"></a><span id="l5.50" class="difflineplus">+    this._datastore.getMessagesByMessageID(references,</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineplus">+      this._indexMessageWithBodyAndAncestors, this,</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+      [references, aMsgHdr, aMimeMsg]);</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+    </span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+    return kWorkAsync;</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+  },</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+  </span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+  _indexMessageWithBodyAndAncestors:</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+    function gloda_index_indexMessageWithBodyAndAncestors(ancestorLists,</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+      references, aMsgHdr, aMimeMsg) {</span>
<a href="#l5.60"></a><span id="l5.60">     // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineminus">-    let ancestorLists = this._datastore.getMessagesByMessageID(references);</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+    </span>
<a href="#l5.63"></a><span id="l5.63">     // pull our current message lookup results off</span>
<a href="#l5.64"></a><span id="l5.64">     references.pop();</span>
<a href="#l5.65"></a><span id="l5.65">     let candidateCurMsgs = ancestorLists.pop();</span>
<a href="#l5.66"></a><span id="l5.66">     </span>
<a href="#l5.67"></a><span id="l5.67">     let conversationID = null;</span>
<a href="#l5.68"></a><span id="l5.68">     // -- figure out the conversation ID</span>
<a href="#l5.69"></a><span id="l5.69">     // if we have a clone/already exist, just use his conversation ID</span>
<a href="#l5.70"></a><span id="l5.70">     if (candidateCurMsgs.length &gt; 0) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/query.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/query.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -68,18 +68,30 @@ GlodaQueryClass.prototype = {</span>
<a href="#l6.4"></a><span id="l6.4">   or: function gloda_query_or() {</span>
<a href="#l6.5"></a><span id="l6.5">     let owner = this._owner || this;</span>
<a href="#l6.6"></a><span id="l6.6">     let orQuery = new this._queryClass();</span>
<a href="#l6.7"></a><span id="l6.7">     orQuery._owner = owner;</span>
<a href="#l6.8"></a><span id="l6.8">     owner._unions.push(orQuery);</span>
<a href="#l6.9"></a><span id="l6.9">     return orQuery;</span>
<a href="#l6.10"></a><span id="l6.10">   },</span>
<a href="#l6.11"></a><span id="l6.11">   </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-  getAllSync: function gloda_query_getAllSync() {</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineminus">-    return this._nounMeta.datastore.queryFromQuery(this);</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+  /**</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+   * Return a collection asynchronously populated by this collection.  You must</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+   *  provide a listener to receive notifications from the collection as it</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+   *  receives updates.  The listener object should implement onItemsAdded,</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+   *  onItemsModified, and onItemsRemoved methods, all of which take a single</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+   *  argument which is the list of items which have been added, modified, or</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+   *  removed respectively.</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+   */</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+  getCollection: function gloda_query_getAll(aListener) {</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+    return this._nounMeta.datastore.queryFromQuery(this, aListener);</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+  },</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+  </span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+  getAllSync: function gloda_query_getAllSync(aListener) {</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineplus">+    return this._nounMeta.datastore.queryFromQuery(this, aListener, true);</span>
<a href="#l6.28"></a><span id="l6.28">   },</span>
<a href="#l6.29"></a><span id="l6.29">   </span>
<a href="#l6.30"></a><span id="l6.30">   /**</span>
<a href="#l6.31"></a><span id="l6.31">    * Test whether the given first-class noun instance satisfies this query.</span>
<a href="#l6.32"></a><span id="l6.32">    * </span>
<a href="#l6.33"></a><span id="l6.33">    */</span>
<a href="#l6.34"></a><span id="l6.34">   test: function gloda_query_test(aObj) {</span>
<a href="#l6.35"></a><span id="l6.35">     // when changing this method, be sure that GlodaDatastore's queryFromQuery</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/test/resources/glodaTestHelper.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/test/resources/glodaTestHelper.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -40,24 +40,23 @@ var ioService = Components.classes[&quot;@moz</span>
<a href="#l7.4"></a><span id="l7.4">                           .getService(Components.interfaces.nsIIOService);</span>
<a href="#l7.5"></a><span id="l7.5"> var resProt = ioService.getProtocolHandler(&quot;resource&quot;)</span>
<a href="#l7.6"></a><span id="l7.6">                        .QueryInterface(Components.interfaces.nsIResProtocolHandler);</span>
<a href="#l7.7"></a><span id="l7.7"> var glodaFile = do_get_file(&quot;../mailnews/db/global&quot;);</span>
<a href="#l7.8"></a><span id="l7.8"> </span>
<a href="#l7.9"></a><span id="l7.9"> var aliasURI = ioService.newFileURI(glodaFile);</span>
<a href="#l7.10"></a><span id="l7.10"> resProt.setSubstitution(&quot;gloda&quot;, aliasURI);</span>
<a href="#l7.11"></a><span id="l7.11"> </span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+// -- Pull in the POP3 fake-server / local account helper code</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+do_import_script(&quot;../mailnews/local/test/unit/head_maillocal.js&quot;);</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+</span>
<a href="#l7.15"></a><span id="l7.15"> // -- Use our newfound imports</span>
<a href="#l7.16"></a><span id="l7.16"> Components.utils.import(&quot;resource://gloda/modules/public.js&quot;);</span>
<a href="#l7.17"></a><span id="l7.17"> Components.utils.import(&quot;resource://gloda/modules/indexer.js&quot;);</span>
<a href="#l7.18"></a><span id="l7.18"> </span>
<a href="#l7.19"></a><span id="l7.19" class="difflineminus">-// -- Pull in the POP3 fake-server / local account helper code</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineminus">-do_import_script(&quot;../mailnews/local/test/unit/head_maillocal.js&quot;);</span>
<a href="#l7.21"></a><span id="l7.21" class="difflineminus">-</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineminus">-</span>
<a href="#l7.23"></a><span id="l7.23"> </span>
<a href="#l7.24"></a><span id="l7.24"> /**</span>
<a href="#l7.25"></a><span id="l7.25">  * Convert a list of synthetic messages to a form appropriate to feed to the</span>
<a href="#l7.26"></a><span id="l7.26">  *  POP3 fakeserver.</span>
<a href="#l7.27"></a><span id="l7.27">  */</span>
<a href="#l7.28"></a><span id="l7.28"> function _synthMessagesToFakeRep(aSynthMessages) {</span>
<a href="#l7.29"></a><span id="l7.29">   return [{fileData: msg.toMessageString(), size: -1} for each</span>
<a href="#l7.30"></a><span id="l7.30">           (msg in aSynthMessages)];</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/test/unit/test_index_messages.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/test/unit/test_index_messages.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -4,18 +4,19 @@</span>
<a href="#l8.4"></a><span id="l8.4">  * In general, if these tests pass, things are probably working quite well.</span>
<a href="#l8.5"></a><span id="l8.5">  *</span>
<a href="#l8.6"></a><span id="l8.6">  * Things we don't test that you think we might test:</span>
<a href="#l8.7"></a><span id="l8.7">  * - Full-text search.  Happens in query testing.</span>
<a href="#l8.8"></a><span id="l8.8">  */</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10"> do_import_script(&quot;../mailnews/db/global/test/resources/messageGenerator.js&quot;);</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-do_import_script(&quot;../mailnews/test/resources/mailDirService.js&quot;);</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">-do_import_script(&quot;../mailnews/test/resources/mailTestUtils.js&quot;);</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+//these are imported by glodaTestHelper's import of head_maillocal</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+// do_import_script(&quot;../mailnews/test/resources/mailDirService.js&quot;);</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+// do_import_script(&quot;../mailnews/test/resources/mailTestUtils.js&quot;);</span>
<a href="#l8.17"></a><span id="l8.17"> do_import_script(&quot;../mailnews/db/global/test/resources/glodaTestHelper.js&quot;);</span>
<a href="#l8.18"></a><span id="l8.18"> </span>
<a href="#l8.19"></a><span id="l8.19"> // Create a message generator</span>
<a href="#l8.20"></a><span id="l8.20"> var msgGen = new MessageGenerator();</span>
<a href="#l8.21"></a><span id="l8.21"> // Create a message scenario generator using that message generator</span>
<a href="#l8.22"></a><span id="l8.22"> var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l8.23"></a><span id="l8.23"> </span>
<a href="#l8.24"></a><span id="l8.24"> /* ===== Threading / Conversation Grouping ===== */</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

