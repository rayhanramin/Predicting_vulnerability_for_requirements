<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 26496:ba2c7ed2417a3fdf55359aea826272040c8b1f48</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ ba2c7ed2417a3fdf55359aea826272040c8b1f48" />
<meta property="og:url" content="/comm-central/rev/ba2c7ed2417a3fdf55359aea826272040c8b1f48" />
<meta property="og:description" content="Bug 1515877 - Turn on ESLint in mailnews/db; r=aceman" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / ba2c7ed2417a3fdf55359aea826272040c8b1f48 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/ba2c7ed2417a3fdf55359aea826272040c8b1f48">shortlog</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/ba2c7ed2417a3fdf55359aea826272040c8b1f48">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48">files</a> |
changeset |
<a href="/comm-central/raw-rev/ba2c7ed2417a3fdf55359aea826272040c8b1f48">raw</a>  | <a href="/comm-central/archive/ba2c7ed2417a3fdf55359aea826272040c8b1f48.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1515877">Bug 1515877</a> - Turn on ESLint in mailnews/db; r=aceman
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#71;&#101;&#111;&#102;&#102;&#32;&#76;&#97;&#110;&#107;&#111;&#119;&#32;&#60;&#103;&#101;&#111;&#102;&#102;&#64;&#100;&#97;&#114;&#107;&#116;&#114;&#111;&#106;&#97;&#110;&#46;&#110;&#101;&#116;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 28 Apr 2019 15:40:51 +1200</td></tr>

<tr>
 <td>changeset 26496</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/ba2c7ed2417a3fdf55359aea826272040c8b1f48">ba2c7ed2417a3fdf55359aea826272040c8b1f48</a></td>
</tr>



<tr>
<td>parent 26495</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/f5d9b79ff6c62cf3f184f5656e467c57e5995582">f5d9b79ff6c62cf3f184f5656e467c57e5995582</a>
</td>
</tr>

<tr>
<td>child 26497</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/553df5c9ee2143021b180495409f6c9d98973822">553df5c9ee2143021b180495409f6c9d98973822</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=ba2c7ed2417a3fdf55359aea826272040c8b1f48">15862</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Thu, 02 May 2019 07:16:29 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@ba2c7ed2417a [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=ba2c7ed2417a3fdf55359aea826272040c8b1f48">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=ba2c7ed2417a3fdf55359aea826272040c8b1f48&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=ba2c7ed2417a3fdf55359aea826272040c8b1f48&newProject=comm-central&newRevision=ba2c7ed2417a3fdf55359aea826272040c8b1f48&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=ba2c7ed2417a3fdf55359aea826272040c8b1f48&newProject=comm-central&newRevision=ba2c7ed2417a3fdf55359aea826272040c8b1f48&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=ba2c7ed2417a3fdf55359aea826272040c8b1f48&newProject=comm-central&newRevision=ba2c7ed2417a3fdf55359aea826272040c8b1f48&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28aceman%29&revcount=50">aceman</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1515877">1515877</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1515877">Bug 1515877</a> - Turn on ESLint in mailnews/db; r=aceman</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/.eslintignore">.eslintignore</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/.eslintignore">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/.eslintignore">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/.eslintignore">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/.eslintignore">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/.eslintignore">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mail/base/content/searchBar.js">mail/base/content/searchBar.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mail/base/content/searchBar.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mail/base/content/searchBar.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mail/base/content/searchBar.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mail/base/content/searchBar.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mail/base/content/searchBar.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/glautocomp.js">mailnews/db/gloda/components/glautocomp.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/glautocomp.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/glautocomp.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/glautocomp.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/glautocomp.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/glautocomp.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/jsmimeemitter.js">mailnews/db/gloda/components/jsmimeemitter.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/jsmimeemitter.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/jsmimeemitter.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/jsmimeemitter.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/jsmimeemitter.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/components/jsmimeemitter.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/autocomplete-richlistitem.js">mailnews/db/gloda/content/autocomplete-richlistitem.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/autocomplete-richlistitem.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/autocomplete-richlistitem.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/autocomplete-richlistitem.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/autocomplete-richlistitem.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/autocomplete-richlistitem.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/glodacomplete.xml">mailnews/db/gloda/content/glodacomplete.xml</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/glodacomplete.xml">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/glodacomplete.xml">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/glodacomplete.xml">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/glodacomplete.xml">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/content/glodacomplete.xml">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/collection.js">mailnews/db/gloda/modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/collection.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/collection.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/connotent.js">mailnews/db/gloda/modules/connotent.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/connotent.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/connotent.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/connotent.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/connotent.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/connotent.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/databind.js">mailnews/db/gloda/modules/databind.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/databind.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/databind.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/databind.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/databind.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/databind.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datamodel.js">mailnews/db/gloda/modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datastore.js">mailnews/db/gloda/modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/dbview.js">mailnews/db/gloda/modules/dbview.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/dbview.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/dbview.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/dbview.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/dbview.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/dbview.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/explattr.js">mailnews/db/gloda/modules/explattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/explattr.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/explattr.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/explattr.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/explattr.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/explattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/facet.js">mailnews/db/gloda/modules/facet.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/facet.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/facet.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/facet.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/facet.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/facet.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/fundattr.js">mailnews/db/gloda/modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/gloda.js">mailnews/db/gloda/modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_ab.js">mailnews/db/gloda/modules/index_ab.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_ab.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_ab.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_ab.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_ab.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_ab.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_msg.js">mailnews/db/gloda/modules/index_msg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_msg.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_msg.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_msg.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_msg.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/index_msg.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/indexer.js">mailnews/db/gloda/modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/log4moz.js">mailnews/db/gloda/modules/log4moz.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/log4moz.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/log4moz.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/log4moz.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/log4moz.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/log4moz.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimeTypeCategories.js">mailnews/db/gloda/modules/mimeTypeCategories.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimeTypeCategories.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimeTypeCategories.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimeTypeCategories.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimeTypeCategories.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimeTypeCategories.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimemsg.js">mailnews/db/gloda/modules/mimemsg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimemsg.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimemsg.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimemsg.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimemsg.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/mimemsg.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/msg_search.js">mailnews/db/gloda/modules/msg_search.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/msg_search.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/msg_search.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/msg_search.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/msg_search.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/msg_search.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_freetag.js">mailnews/db/gloda/modules/noun_freetag.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_freetag.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_freetag.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_freetag.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_freetag.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_freetag.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_mimetype.js">mailnews/db/gloda/modules/noun_mimetype.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_mimetype.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_mimetype.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_mimetype.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_mimetype.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_mimetype.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_tag.js">mailnews/db/gloda/modules/noun_tag.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_tag.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_tag.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_tag.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_tag.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/noun_tag.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/query.js">mailnews/db/gloda/modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/query.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/query.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/query.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/query.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/query.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/suffixtree.js">mailnews/db/gloda/modules/suffixtree.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/suffixtree.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/suffixtree.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/suffixtree.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/suffixtree.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/suffixtree.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/utils.js">mailnews/db/gloda/modules/utils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/utils.js">file</a> |
<a href="/comm-central/annotate/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/utils.js">annotate</a> |
<a href="/comm-central/diff/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/utils.js">diff</a> |
<a href="/comm-central/comparison/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/utils.js">comparison</a> |
<a href="/comm-central/log/ba2c7ed2417a3fdf55359aea826272040c8b1f48/mailnews/db/gloda/modules/utils.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/.eslintignore</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/.eslintignore</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -57,17 +57,16 @@ editor/ui/dialogs/content/EditorSaveAsCh</span>
<a href="#l1.4"></a><span id="l1.4"> editor/ui/dialogs/content/EdLinkChecker.js</span>
<a href="#l1.5"></a><span id="l1.5"> editor/ui/dialogs/content/EdLinkChecker.xul</span>
<a href="#l1.6"></a><span id="l1.6"> editor/ui/dialogs/content/EdSnapToGrid.js</span>
<a href="#l1.7"></a><span id="l1.7"> editor/ui/dialogs/content/EdSnapToGrid.xul</span>
<a href="#l1.8"></a><span id="l1.8"> editor/ui/texzilla/**</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10"> # mailnews exclusions</span>
<a href="#l1.11"></a><span id="l1.11"> mailnews/mailnews.js</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-mailnews/db/*</span>
<a href="#l1.13"></a><span id="l1.13"> mailnews/imap/*</span>
<a href="#l1.14"></a><span id="l1.14"> mailnews/import/*</span>
<a href="#l1.15"></a><span id="l1.15"> mailnews/intl/*</span>
<a href="#l1.16"></a><span id="l1.16"> mailnews/jsaccount/*</span>
<a href="#l1.17"></a><span id="l1.17"> mailnews/mime/*</span>
<a href="#l1.18"></a><span id="l1.18"> </span>
<a href="#l1.19"></a><span id="l1.19"> # mailnews/extensions exclusions</span>
<a href="#l1.20"></a><span id="l1.20"> mailnews/extensions/*</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mail/base/content/searchBar.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mail/base/content/searchBar.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -3,18 +3,16 @@</span>
<a href="#l2.4"></a><span id="l2.4">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l2.5"></a><span id="l2.5"> </span>
<a href="#l2.6"></a><span id="l2.6"> var {StringBundle} = ChromeUtils.import(&quot;resource:///modules/StringBundle.js&quot;);</span>
<a href="#l2.7"></a><span id="l2.7"> </span>
<a href="#l2.8"></a><span id="l2.8"> var gSearchBundle;</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10"> var gStatusBar = document.getElementById(&quot;statusbar-icon&quot;);</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-var gGlodaCompleteStrings = new StringBundle(&quot;chrome://messenger/locale/glodaComplete.properties&quot;);</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-</span>
<a href="#l2.14"></a><span id="l2.14"> /**</span>
<a href="#l2.15"></a><span id="l2.15">  * The glodasearch widget is a UI widget (the #searchInput textbox) which is</span>
<a href="#l2.16"></a><span id="l2.16">  * outside of the mailTabType's display panel, but acts as though it were within</span>
<a href="#l2.17"></a><span id="l2.17">  * it..  This means we need to use a tab monitor so that we can appropriately</span>
<a href="#l2.18"></a><span id="l2.18">  * update the contents of the textbox.</span>
<a href="#l2.19"></a><span id="l2.19">  *</span>
<a href="#l2.20"></a><span id="l2.20">  * Every time a tab is changed, we save the state of the text box and restore</span>
<a href="#l2.21"></a><span id="l2.21">  *  its previous value for the tab we are switching to, as well as whether this</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/db/gloda/components/glautocomp.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/db/gloda/components/glautocomp.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -20,58 +20,58 @@ var FreeTagNoun = null;</span>
<a href="#l3.4"></a><span id="l3.4"> </span>
<a href="#l3.5"></a><span id="l3.5"> function ResultRowFullText(aItem, words, typeForStyle) {</span>
<a href="#l3.6"></a><span id="l3.6">   this.item = aItem;</span>
<a href="#l3.7"></a><span id="l3.7">   this.words = words;</span>
<a href="#l3.8"></a><span id="l3.8">   this.typeForStyle = &quot;gloda-fulltext-&quot; + typeForStyle;</span>
<a href="#l3.9"></a><span id="l3.9"> }</span>
<a href="#l3.10"></a><span id="l3.10"> ResultRowFullText.prototype = {</span>
<a href="#l3.11"></a><span id="l3.11">   multi: false,</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-  fullText: true</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+  fullText: true,</span>
<a href="#l3.14"></a><span id="l3.14"> };</span>
<a href="#l3.15"></a><span id="l3.15"> </span>
<a href="#l3.16"></a><span id="l3.16"> function ResultRowSingle(aItem, aCriteriaType, aCriteria, aExplicitNounID) {</span>
<a href="#l3.17"></a><span id="l3.17">   this.nounID = aExplicitNounID || aItem.NOUN_ID;</span>
<a href="#l3.18"></a><span id="l3.18">   this.nounDef = Gloda._nounIDToDef[this.nounID];</span>
<a href="#l3.19"></a><span id="l3.19">   this.criteriaType = aCriteriaType;</span>
<a href="#l3.20"></a><span id="l3.20">   this.criteria = aCriteria;</span>
<a href="#l3.21"></a><span id="l3.21">   this.item = aItem;</span>
<a href="#l3.22"></a><span id="l3.22">   this.typeForStyle = &quot;gloda-single-&quot; + this.nounDef.name;</span>
<a href="#l3.23"></a><span id="l3.23"> }</span>
<a href="#l3.24"></a><span id="l3.24"> ResultRowSingle.prototype = {</span>
<a href="#l3.25"></a><span id="l3.25">   multi: false,</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineminus">-  fullText: false</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineplus">+  fullText: false,</span>
<a href="#l3.28"></a><span id="l3.28"> };</span>
<a href="#l3.29"></a><span id="l3.29"> </span>
<a href="#l3.30"></a><span id="l3.30"> function ResultRowMulti(aNounID, aCriteriaType, aCriteria, aQuery) {</span>
<a href="#l3.31"></a><span id="l3.31">   this.nounID = aNounID;</span>
<a href="#l3.32"></a><span id="l3.32">   this.nounDef = Gloda._nounIDToDef[aNounID];</span>
<a href="#l3.33"></a><span id="l3.33">   this.criteriaType = aCriteriaType;</span>
<a href="#l3.34"></a><span id="l3.34">   this.criteria = aCriteria;</span>
<a href="#l3.35"></a><span id="l3.35">   this.collection = aQuery.getCollection(this);</span>
<a href="#l3.36"></a><span id="l3.36">   this.collection.becomeExplicit();</span>
<a href="#l3.37"></a><span id="l3.37">   this.renderer = null;</span>
<a href="#l3.38"></a><span id="l3.38"> }</span>
<a href="#l3.39"></a><span id="l3.39"> ResultRowMulti.prototype = {</span>
<a href="#l3.40"></a><span id="l3.40">   multi: true,</span>
<a href="#l3.41"></a><span id="l3.41">   typeForStyle: &quot;gloda-multi&quot;,</span>
<a href="#l3.42"></a><span id="l3.42">   fullText: false,</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineminus">-  onItemsAdded: function(aItems) {</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+  onItemsAdded(aItems) {</span>
<a href="#l3.45"></a><span id="l3.45">     if (this.renderer) {</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineminus">-      for (let [iItem, item] of aItems.entries()) {</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+      for (let [, item] of aItems.entries()) {</span>
<a href="#l3.48"></a><span id="l3.48">         this.renderer.renderItem(item);</span>
<a href="#l3.49"></a><span id="l3.49">       }</span>
<a href="#l3.50"></a><span id="l3.50">     }</span>
<a href="#l3.51"></a><span id="l3.51">   },</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineminus">-  onItemsModified: function(aItems) {</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+  onItemsModified(aItems) {</span>
<a href="#l3.54"></a><span id="l3.54">   },</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineminus">-  onItemsRemoved: function(aItems) {</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+  onItemsRemoved(aItems) {</span>
<a href="#l3.57"></a><span id="l3.57">   },</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineminus">-  onQueryCompleted: function() {</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineminus">-  }</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+  onQueryCompleted() {</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+  },</span>
<a href="#l3.62"></a><span id="l3.62"> };</span>
<a href="#l3.63"></a><span id="l3.63"> </span>
<a href="#l3.64"></a><span id="l3.64"> function nsAutoCompleteGlodaResult(aListener, aCompleter, aString) {</span>
<a href="#l3.65"></a><span id="l3.65">   this.listener = aListener;</span>
<a href="#l3.66"></a><span id="l3.66">   this.completer = aCompleter;</span>
<a href="#l3.67"></a><span id="l3.67">   this.searchString = aString;</span>
<a href="#l3.68"></a><span id="l3.68">   this._results = [];</span>
<a href="#l3.69"></a><span id="l3.69">   this._pendingCount = 0;</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineat">@@ -79,101 +79,97 @@ function nsAutoCompleteGlodaResult(aList</span>
<a href="#l3.71"></a><span id="l3.71">   // Track whether we have reported anything to the complete controller so</span>
<a href="#l3.72"></a><span id="l3.72">   //  that we know not to send notifications to it during calls to addRows</span>
<a href="#l3.73"></a><span id="l3.73">   //  prior to that point.</span>
<a href="#l3.74"></a><span id="l3.74">   this._initiallyReported = false;</span>
<a href="#l3.75"></a><span id="l3.75"> </span>
<a href="#l3.76"></a><span id="l3.76">   this.wrappedJSObject = this;</span>
<a href="#l3.77"></a><span id="l3.77"> }</span>
<a href="#l3.78"></a><span id="l3.78"> nsAutoCompleteGlodaResult.prototype = {</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineminus">-  getObjectAt: function(aIndex) {</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+  getObjectAt(aIndex) {</span>
<a href="#l3.81"></a><span id="l3.81">     return this._results[aIndex] || null;</span>
<a href="#l3.82"></a><span id="l3.82">   },</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineminus">-  markPending: function ACGR_markPending(aCompleter) {</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+  markPending(aCompleter) {</span>
<a href="#l3.85"></a><span id="l3.85">     this._pendingCount++;</span>
<a href="#l3.86"></a><span id="l3.86">   },</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineminus">-  markCompleted: function ACGR_markCompleted(aCompleter) {</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+  markCompleted(aCompleter) {</span>
<a href="#l3.89"></a><span id="l3.89">     if (--this._pendingCount == 0 &amp;&amp; this.active) {</span>
<a href="#l3.90"></a><span id="l3.90">       this.listener.onSearchResult(this.completer, this);</span>
<a href="#l3.91"></a><span id="l3.91">     }</span>
<a href="#l3.92"></a><span id="l3.92">   },</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineminus">-  announceYourself: function ACGR_announceYourself() {</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+  announceYourself() {</span>
<a href="#l3.95"></a><span id="l3.95">     this._initiallyReported = true;</span>
<a href="#l3.96"></a><span id="l3.96">     this.listener.onSearchResult(this.completer, this);</span>
<a href="#l3.97"></a><span id="l3.97">   },</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineminus">-  addRows: function ACGR_addRows(aRows) {</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+  addRows(aRows) {</span>
<a href="#l3.100"></a><span id="l3.100">     if (!aRows.length)</span>
<a href="#l3.101"></a><span id="l3.101">       return;</span>
<a href="#l3.102"></a><span id="l3.102">     this._results.push.apply(this._results, aRows);</span>
<a href="#l3.103"></a><span id="l3.103">     if (this._initiallyReported &amp;&amp; this.active) {</span>
<a href="#l3.104"></a><span id="l3.104">       this.listener.onSearchResult(this.completer, this);</span>
<a href="#l3.105"></a><span id="l3.105">     }</span>
<a href="#l3.106"></a><span id="l3.106">   },</span>
<a href="#l3.107"></a><span id="l3.107">   // ==== nsIAutoCompleteResult</span>
<a href="#l3.108"></a><span id="l3.108">   searchString: null,</span>
<a href="#l3.109"></a><span id="l3.109">   get searchResult() {</span>
<a href="#l3.110"></a><span id="l3.110">     if (this._problem)</span>
<a href="#l3.111"></a><span id="l3.111">       return Ci.nsIAutoCompleteResult.RESULT_FAILURE;</span>
<a href="#l3.112"></a><span id="l3.112">     if (this._results.length)</span>
<a href="#l3.113"></a><span id="l3.113">       return (!this._pendingCount) ? Ci.nsIAutoCompleteResult.RESULT_SUCCESS</span>
<a href="#l3.114"></a><span id="l3.114">                           : Ci.nsIAutoCompleteResult.RESULT_SUCCESS_ONGOING;</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineminus">-    else</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineminus">-      return (!this._pendingCount) ? Ci.nsIAutoCompleteResult.RESULT_NOMATCH</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+    return (!this._pendingCount) ? Ci.nsIAutoCompleteResult.RESULT_NOMATCH</span>
<a href="#l3.118"></a><span id="l3.118">                           : Ci.nsIAutoCompleteResult.RESULT_NOMATCH_ONGOING;</span>
<a href="#l3.119"></a><span id="l3.119">   },</span>
<a href="#l3.120"></a><span id="l3.120">   active: false,</span>
<a href="#l3.121"></a><span id="l3.121">   defaultIndex: -1,</span>
<a href="#l3.122"></a><span id="l3.122">   errorDescription: null,</span>
<a href="#l3.123"></a><span id="l3.123">   get matchCount() {</span>
<a href="#l3.124"></a><span id="l3.124">     return (this._results === null) ? 0 : this._results.length;</span>
<a href="#l3.125"></a><span id="l3.125">   },</span>
<a href="#l3.126"></a><span id="l3.126">   // this is the lower text, (shows the url in firefox)</span>
<a href="#l3.127"></a><span id="l3.127">   // we try and show the contact's name here.</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineminus">-  getValueAt: function(aIndex) {</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+  getValueAt(aIndex) {</span>
<a href="#l3.130"></a><span id="l3.130">     let thing = this._results[aIndex];</span>
<a href="#l3.131"></a><span id="l3.131">     return thing.name || thing.value || thing.subject || null;</span>
<a href="#l3.132"></a><span id="l3.132">   },</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineminus">-  getLabelAt: function(aIndex) {</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+  getLabelAt(aIndex) {</span>
<a href="#l3.135"></a><span id="l3.135">     return this.getValueAt(aIndex);</span>
<a href="#l3.136"></a><span id="l3.136">   },</span>
<a href="#l3.137"></a><span id="l3.137">   // rich uses this to be the &quot;title&quot;.  it is the upper text</span>
<a href="#l3.138"></a><span id="l3.138">   // we try and show the identity here.</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineminus">-  getCommentAt: function(aIndex) {</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+  getCommentAt(aIndex) {</span>
<a href="#l3.141"></a><span id="l3.141">     let thing = this._results[aIndex];</span>
<a href="#l3.142"></a><span id="l3.142">     if (thing.value) // identity</span>
<a href="#l3.143"></a><span id="l3.143">       return thing.contact.name;</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineminus">-    else</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineminus">-      return thing.name || thing.subject;</span>
<a href="#l3.146"></a><span id="l3.146" class="difflineplus">+    return thing.name || thing.subject;</span>
<a href="#l3.147"></a><span id="l3.147">   },</span>
<a href="#l3.148"></a><span id="l3.148">   // rich uses this to be the &quot;type&quot;</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineminus">-  getStyleAt: function(aIndex) {</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+  getStyleAt(aIndex) {</span>
<a href="#l3.151"></a><span id="l3.151">     let row = this._results[aIndex];</span>
<a href="#l3.152"></a><span id="l3.152">     return row.typeForStyle;</span>
<a href="#l3.153"></a><span id="l3.153">   },</span>
<a href="#l3.154"></a><span id="l3.154">   // rich uses this to be the icon</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineminus">-  getImageAt: function(aIndex) {</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineplus">+  getImageAt(aIndex) {</span>
<a href="#l3.157"></a><span id="l3.157">     let thing = this._results[aIndex];</span>
<a href="#l3.158"></a><span id="l3.158">     if (!thing.value)</span>
<a href="#l3.159"></a><span id="l3.159">       return null;</span>
<a href="#l3.160"></a><span id="l3.160"> </span>
<a href="#l3.161"></a><span id="l3.161">     return &quot;&quot;; // we don't want to use gravatars as is.</span>
<a href="#l3.162"></a><span id="l3.162">     /*</span>
<a href="#l3.163"></a><span id="l3.163">     let md5hash = GlodaUtils.md5HashString(thing.value);</span>
<a href="#l3.164"></a><span id="l3.164">     let gravURL = &quot;http://www.gravatar.com/avatar/&quot; + md5hash +</span>
<a href="#l3.165"></a><span id="l3.165">                                 &quot;?d=identicon&amp;s=32&amp;r=g&quot;;</span>
<a href="#l3.166"></a><span id="l3.166">     return gravURL;</span>
<a href="#l3.167"></a><span id="l3.167">     */</span>
<a href="#l3.168"></a><span id="l3.168">   },</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineminus">-  getFinalCompleteValueAt: function(aIndex) {</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+  getFinalCompleteValueAt(aIndex) {</span>
<a href="#l3.171"></a><span id="l3.171">     return this.getValueAt(aIndex);</span>
<a href="#l3.172"></a><span id="l3.172">   },</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineminus">-  removeValueAt: function() {},</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineminus">-</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineminus">-  _stop: function() {</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineminus">-  }</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+  removeValueAt() {},</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+  _stop() {},</span>
<a href="#l3.179"></a><span id="l3.179"> };</span>
<a href="#l3.180"></a><span id="l3.180"> </span>
<a href="#l3.181"></a><span id="l3.181"> var MAX_POPULAR_CONTACTS = 200;</span>
<a href="#l3.182"></a><span id="l3.182"> </span>
<a href="#l3.183"></a><span id="l3.183"> /**</span>
<a href="#l3.184"></a><span id="l3.184">  * Complete contacts/identities based on name/email.  Instant phase is based on</span>
<a href="#l3.185"></a><span id="l3.185">  *  a suffix-tree built of popular contacts/identities.  Delayed phase relies</span>
<a href="#l3.186"></a><span id="l3.186">  *  on a LIKE search of all known contacts.</span>
<a href="#l3.187"></a><span id="l3.187" class="difflineat">@@ -181,36 +177,36 @@ var MAX_POPULAR_CONTACTS = 200;</span>
<a href="#l3.188"></a><span id="l3.188"> function ContactIdentityCompleter() {</span>
<a href="#l3.189"></a><span id="l3.189">   // get all the contacts</span>
<a href="#l3.190"></a><span id="l3.190">   let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l3.191"></a><span id="l3.191">   contactQuery.orderBy(&quot;-popularity&quot;).limit(MAX_POPULAR_CONTACTS);</span>
<a href="#l3.192"></a><span id="l3.192">   this.contactCollection = contactQuery.getCollection(this, null);</span>
<a href="#l3.193"></a><span id="l3.193">   this.contactCollection.becomeExplicit();</span>
<a href="#l3.194"></a><span id="l3.194"> }</span>
<a href="#l3.195"></a><span id="l3.195"> ContactIdentityCompleter.prototype = {</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineminus">-  _popularitySorter: function(a, b){ return b.popularity - a.popularity; },</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineminus">-  complete: function ContactIdentityCompleter_complete(aResult, aString) {</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+  _popularitySorter(a, b) { return b.popularity - a.popularity; },</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+  complete(aResult, aString) {</span>
<a href="#l3.200"></a><span id="l3.200">     if (aString.length &lt; 3) {</span>
<a href="#l3.201"></a><span id="l3.201">       // In CJK, first name or last name is sometime used as 1 character only.</span>
<a href="#l3.202"></a><span id="l3.202">       // So we allow autocompleted search even if 1 character.</span>
<a href="#l3.203"></a><span id="l3.203">       //</span>
<a href="#l3.204"></a><span id="l3.204">       // [U+3041 - U+9FFF ... Full-width Katakana, Hiragana</span>
<a href="#l3.205"></a><span id="l3.205">       //                      and CJK Ideograph</span>
<a href="#l3.206"></a><span id="l3.206">       // [U+AC00 - U+D7FF ... Hangul</span>
<a href="#l3.207"></a><span id="l3.207">       // [U+F900 - U+FFDC ... CJK compatibility ideograph</span>
<a href="#l3.208"></a><span id="l3.208">       if (!aString.match(/[\u3041-\u9fff\uac00-\ud7ff\uf900-\uffdc]/))</span>
<a href="#l3.209"></a><span id="l3.209">         return false;</span>
<a href="#l3.210"></a><span id="l3.210">     }</span>
<a href="#l3.211"></a><span id="l3.211"> </span>
<a href="#l3.212"></a><span id="l3.212">     let matches;</span>
<a href="#l3.213"></a><span id="l3.213">     if (this.suffixTree) {</span>
<a href="#l3.214"></a><span id="l3.214">       matches = this.suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l3.215"></a><span id="l3.215" class="difflineplus">+    } else {</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+      matches = [];</span>
<a href="#l3.217"></a><span id="l3.217">     }</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineminus">-    else</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineminus">-      matches = [];</span>
<a href="#l3.220"></a><span id="l3.220"> </span>
<a href="#l3.221"></a><span id="l3.221">     // let's filter out duplicates due to identity/contact double-hits by</span>
<a href="#l3.222"></a><span id="l3.222">     //  establishing a map based on the contact id for these guys.</span>
<a href="#l3.223"></a><span id="l3.223">     // let's also favor identities as we do it, because that gets us the</span>
<a href="#l3.224"></a><span id="l3.224">     //  most accurate gravat, potentially</span>
<a href="#l3.225"></a><span id="l3.225">     let contactToThing = {};</span>
<a href="#l3.226"></a><span id="l3.226">     for (let iMatch = 0; iMatch &lt; matches.length; iMatch++) {</span>
<a href="#l3.227"></a><span id="l3.227">       let thing = matches[iMatch];</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineat">@@ -224,17 +220,17 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l3.229"></a><span id="l3.229">     matches = Object.keys(contactToThing).map(id =&gt; contactToThing[id]).</span>
<a href="#l3.230"></a><span id="l3.230">       map(val =&gt; val.NOUN_ID == Gloda.NOUN_IDENTITY ? val : val.identities[0]);</span>
<a href="#l3.231"></a><span id="l3.231"> </span>
<a href="#l3.232"></a><span id="l3.232">     let rows = matches.</span>
<a href="#l3.233"></a><span id="l3.233">       map(match =&gt; new ResultRowSingle(match, &quot;text&quot;, aResult.searchString));</span>
<a href="#l3.234"></a><span id="l3.234">     aResult.addRows(rows);</span>
<a href="#l3.235"></a><span id="l3.235"> </span>
<a href="#l3.236"></a><span id="l3.236">     // - match against database contacts / identities</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineminus">-    let pending = {contactToThing: contactToThing, pendingCount: 2};</span>
<a href="#l3.238"></a><span id="l3.238" class="difflineplus">+    let pending = {contactToThing, pendingCount: 2};</span>
<a href="#l3.239"></a><span id="l3.239"> </span>
<a href="#l3.240"></a><span id="l3.240">     let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l3.241"></a><span id="l3.241">     contactQuery.nameLike(contactQuery.WILDCARD, aString,</span>
<a href="#l3.242"></a><span id="l3.242">                           contactQuery.WILDCARD);</span>
<a href="#l3.243"></a><span id="l3.243">     pending.contactColl = contactQuery.getCollection(this, aResult);</span>
<a href="#l3.244"></a><span id="l3.244">     pending.contactColl.becomeExplicit();</span>
<a href="#l3.245"></a><span id="l3.245"> </span>
<a href="#l3.246"></a><span id="l3.246">     let identityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l3.247"></a><span id="l3.247" class="difflineat">@@ -242,23 +238,23 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l3.248"></a><span id="l3.248">         identityQuery.WILDCARD);</span>
<a href="#l3.249"></a><span id="l3.249">     pending.identityColl = identityQuery.getCollection(this, aResult);</span>
<a href="#l3.250"></a><span id="l3.250">     pending.identityColl.becomeExplicit();</span>
<a href="#l3.251"></a><span id="l3.251"> </span>
<a href="#l3.252"></a><span id="l3.252">     aResult._contactCompleterPending = pending;</span>
<a href="#l3.253"></a><span id="l3.253"> </span>
<a href="#l3.254"></a><span id="l3.254">     return true;</span>
<a href="#l3.255"></a><span id="l3.255">   },</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineminus">-  onItemsAdded: function(aItems, aCollection) {</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineplus">+  onItemsAdded(aItems, aCollection) {</span>
<a href="#l3.258"></a><span id="l3.258">   },</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineminus">-  onItemsModified: function(aItems, aCollection) {</span>
<a href="#l3.260"></a><span id="l3.260" class="difflineplus">+  onItemsModified(aItems, aCollection) {</span>
<a href="#l3.261"></a><span id="l3.261">   },</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineminus">-  onItemsRemoved: function(aItems, aCollection) {</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineplus">+  onItemsRemoved(aItems, aCollection) {</span>
<a href="#l3.264"></a><span id="l3.264">   },</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineminus">-  onQueryCompleted: function(aCollection) {</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineplus">+  onQueryCompleted(aCollection) {</span>
<a href="#l3.267"></a><span id="l3.267">     // handle the initial setup case...</span>
<a href="#l3.268"></a><span id="l3.268">     if (aCollection.data == null) {</span>
<a href="#l3.269"></a><span id="l3.269">       // cheat and explicitly add our own contact...</span>
<a href="#l3.270"></a><span id="l3.270">       if (Gloda.myContact &amp;&amp;</span>
<a href="#l3.271"></a><span id="l3.271">           !(Gloda.myContact.id in this.contactCollection._idMap))</span>
<a href="#l3.272"></a><span id="l3.272">         this.contactCollection._onItemsAdded([Gloda.myContact]);</span>
<a href="#l3.273"></a><span id="l3.273"> </span>
<a href="#l3.274"></a><span id="l3.274">       // the set of identities owned by the contacts is automatically loaded as part</span>
<a href="#l3.275"></a><span id="l3.275" class="difflineat">@@ -298,17 +294,17 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l3.276"></a><span id="l3.276"> </span>
<a href="#l3.277"></a><span id="l3.277">       let contactToThing = pending.contactToThing;</span>
<a href="#l3.278"></a><span id="l3.278"> </span>
<a href="#l3.279"></a><span id="l3.279">       let items;</span>
<a href="#l3.280"></a><span id="l3.280"> </span>
<a href="#l3.281"></a><span id="l3.281">       // check identities first because they are better than contacts in terms</span>
<a href="#l3.282"></a><span id="l3.282">       //  of display</span>
<a href="#l3.283"></a><span id="l3.283">       items = pending.identityColl.items;</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineminus">-      for (let iIdentity = 0; iIdentity &lt; items.length; iIdentity++){</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineplus">+      for (let iIdentity = 0; iIdentity &lt; items.length; iIdentity++) {</span>
<a href="#l3.286"></a><span id="l3.286">         let identity = items[iIdentity];</span>
<a href="#l3.287"></a><span id="l3.287">         if (!(identity.contactID in contactToThing)) {</span>
<a href="#l3.288"></a><span id="l3.288">           contactToThing[identity.contactID] = identity;</span>
<a href="#l3.289"></a><span id="l3.289">           possibleDudes.push(identity);</span>
<a href="#l3.290"></a><span id="l3.290">           // augment the identity with its contact's popularity</span>
<a href="#l3.291"></a><span id="l3.291">           identity.popularity = identity.contact.popularity;</span>
<a href="#l3.292"></a><span id="l3.292">         }</span>
<a href="#l3.293"></a><span id="l3.293">       }</span>
<a href="#l3.294"></a><span id="l3.294" class="difflineat">@@ -329,41 +325,41 @@ ContactIdentityCompleter.prototype = {</span>
<a href="#l3.295"></a><span id="l3.295">       result.markCompleted(this);</span>
<a href="#l3.296"></a><span id="l3.296"> </span>
<a href="#l3.297"></a><span id="l3.297">       // the collections no longer care about the result, make it clear.</span>
<a href="#l3.298"></a><span id="l3.298">       delete pending.identityColl.data;</span>
<a href="#l3.299"></a><span id="l3.299">       delete pending.contactColl.data;</span>
<a href="#l3.300"></a><span id="l3.300">       // the result object no longer needs us or our data</span>
<a href="#l3.301"></a><span id="l3.301">       delete result._contactCompleterPending;</span>
<a href="#l3.302"></a><span id="l3.302">     }</span>
<a href="#l3.303"></a><span id="l3.303" class="difflineminus">-  }</span>
<a href="#l3.304"></a><span id="l3.304" class="difflineplus">+  },</span>
<a href="#l3.305"></a><span id="l3.305"> };</span>
<a href="#l3.306"></a><span id="l3.306"> </span>
<a href="#l3.307"></a><span id="l3.307"> /**</span>
<a href="#l3.308"></a><span id="l3.308">  * Complete tags that are used on contacts.</span>
<a href="#l3.309"></a><span id="l3.309">  */</span>
<a href="#l3.310"></a><span id="l3.310"> function ContactTagCompleter() {</span>
<a href="#l3.311"></a><span id="l3.311">   FreeTagNoun.populateKnownFreeTags();</span>
<a href="#l3.312"></a><span id="l3.312">   this._buildSuffixTree();</span>
<a href="#l3.313"></a><span id="l3.313">   FreeTagNoun.addListener(this);</span>
<a href="#l3.314"></a><span id="l3.314"> }</span>
<a href="#l3.315"></a><span id="l3.315"> ContactTagCompleter.prototype = {</span>
<a href="#l3.316"></a><span id="l3.316" class="difflineminus">-  _buildSuffixTree: function() {</span>
<a href="#l3.317"></a><span id="l3.317" class="difflineplus">+  _buildSuffixTree() {</span>
<a href="#l3.318"></a><span id="l3.318">     let tagNames = [], tags = [];</span>
<a href="#l3.319"></a><span id="l3.319">     for (let [tagName, tag] of Object.entries(FreeTagNoun.knownFreeTags)) {</span>
<a href="#l3.320"></a><span id="l3.320">       tagNames.push(tagName.toLowerCase());</span>
<a href="#l3.321"></a><span id="l3.321">       tags.push(tag);</span>
<a href="#l3.322"></a><span id="l3.322">     }</span>
<a href="#l3.323"></a><span id="l3.323">     this._suffixTree = new MultiSuffixTree(tagNames, tags);</span>
<a href="#l3.324"></a><span id="l3.324">     this._suffixTreeDirty = false;</span>
<a href="#l3.325"></a><span id="l3.325">   },</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineminus">-  onFreeTagAdded: function(aTag) {</span>
<a href="#l3.327"></a><span id="l3.327" class="difflineplus">+  onFreeTagAdded(aTag) {</span>
<a href="#l3.328"></a><span id="l3.328">     this._suffixTreeDirty = true;</span>
<a href="#l3.329"></a><span id="l3.329">   },</span>
<a href="#l3.330"></a><span id="l3.330" class="difflineminus">-  complete: function ContactTagCompleter_complete(aResult, aString) {</span>
<a href="#l3.331"></a><span id="l3.331" class="difflineplus">+  complete(aResult, aString) {</span>
<a href="#l3.332"></a><span id="l3.332">     // now is not the best time to do this; have onFreeTagAdded use a timer.</span>
<a href="#l3.333"></a><span id="l3.333">     if (this._suffixTreeDirty)</span>
<a href="#l3.334"></a><span id="l3.334">       this._buildSuffixTree();</span>
<a href="#l3.335"></a><span id="l3.335"> </span>
<a href="#l3.336"></a><span id="l3.336">     if (aString.length &lt; 2)</span>
<a href="#l3.337"></a><span id="l3.337">       return false; // no async mechanism that will add new rows</span>
<a href="#l3.338"></a><span id="l3.338"> </span>
<a href="#l3.339"></a><span id="l3.339">     let tags = this._suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l3.340"></a><span id="l3.340" class="difflineat">@@ -373,60 +369,60 @@ ContactTagCompleter.prototype = {</span>
<a href="#l3.341"></a><span id="l3.341">       query.freeTags(tag);</span>
<a href="#l3.342"></a><span id="l3.342">       let resRow = new ResultRowMulti(Gloda.NOUN_CONTACT, &quot;tag&quot;, tag.name,</span>
<a href="#l3.343"></a><span id="l3.343">                                       query);</span>
<a href="#l3.344"></a><span id="l3.344">       rows.push(resRow);</span>
<a href="#l3.345"></a><span id="l3.345">     }</span>
<a href="#l3.346"></a><span id="l3.346">     aResult.addRows(rows);</span>
<a href="#l3.347"></a><span id="l3.347"> </span>
<a href="#l3.348"></a><span id="l3.348">     return false; // no async mechanism that will add new rows</span>
<a href="#l3.349"></a><span id="l3.349" class="difflineminus">-  }</span>
<a href="#l3.350"></a><span id="l3.350" class="difflineplus">+  },</span>
<a href="#l3.351"></a><span id="l3.351"> };</span>
<a href="#l3.352"></a><span id="l3.352"> </span>
<a href="#l3.353"></a><span id="l3.353"> /**</span>
<a href="#l3.354"></a><span id="l3.354">  * Complete tags that are used on messages</span>
<a href="#l3.355"></a><span id="l3.355">  */</span>
<a href="#l3.356"></a><span id="l3.356"> function MessageTagCompleter() {</span>
<a href="#l3.357"></a><span id="l3.357">   this._buildSuffixTree();</span>
<a href="#l3.358"></a><span id="l3.358"> }</span>
<a href="#l3.359"></a><span id="l3.359"> MessageTagCompleter.prototype = {</span>
<a href="#l3.360"></a><span id="l3.360" class="difflineminus">-  _buildSuffixTree: function MessageTagCompleter__buildSufficeTree() {</span>
<a href="#l3.361"></a><span id="l3.361" class="difflineplus">+  _buildSuffixTree() {</span>
<a href="#l3.362"></a><span id="l3.362">     let tagNames = [], tags = [];</span>
<a href="#l3.363"></a><span id="l3.363">     let tagArray = TagNoun.getAllTags();</span>
<a href="#l3.364"></a><span id="l3.364">     for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l3.365"></a><span id="l3.365">       let tag = tagArray[iTag];</span>
<a href="#l3.366"></a><span id="l3.366">       tagNames.push(tag.tag.toLowerCase());</span>
<a href="#l3.367"></a><span id="l3.367">       tags.push(tag);</span>
<a href="#l3.368"></a><span id="l3.368">     }</span>
<a href="#l3.369"></a><span id="l3.369">     this._suffixTree = new MultiSuffixTree(tagNames, tags);</span>
<a href="#l3.370"></a><span id="l3.370">     this._suffixTreeDirty = false;</span>
<a href="#l3.371"></a><span id="l3.371">   },</span>
<a href="#l3.372"></a><span id="l3.372" class="difflineminus">-  complete: function MessageTagCompleter_complete(aResult, aString) {</span>
<a href="#l3.373"></a><span id="l3.373" class="difflineplus">+  complete(aResult, aString) {</span>
<a href="#l3.374"></a><span id="l3.374">     if (aString.length &lt; 2)</span>
<a href="#l3.375"></a><span id="l3.375">       return false;</span>
<a href="#l3.376"></a><span id="l3.376"> </span>
<a href="#l3.377"></a><span id="l3.377">     let tags = this._suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l3.378"></a><span id="l3.378">     let rows = [];</span>
<a href="#l3.379"></a><span id="l3.379">     for (let tag of tags) {</span>
<a href="#l3.380"></a><span id="l3.380">       let resRow = new ResultRowSingle(tag, &quot;tag&quot;, tag.tag, TagNoun.id);</span>
<a href="#l3.381"></a><span id="l3.381">       rows.push(resRow);</span>
<a href="#l3.382"></a><span id="l3.382">     }</span>
<a href="#l3.383"></a><span id="l3.383">     aResult.addRows(rows);</span>
<a href="#l3.384"></a><span id="l3.384"> </span>
<a href="#l3.385"></a><span id="l3.385">     return false; // no async mechanism that will add new rows</span>
<a href="#l3.386"></a><span id="l3.386" class="difflineminus">-  }</span>
<a href="#l3.387"></a><span id="l3.387" class="difflineplus">+  },</span>
<a href="#l3.388"></a><span id="l3.388"> };</span>
<a href="#l3.389"></a><span id="l3.389"> </span>
<a href="#l3.390"></a><span id="l3.390"> /**</span>
<a href="#l3.391"></a><span id="l3.391">  * Complete with helpful hints about full-text search</span>
<a href="#l3.392"></a><span id="l3.392">  */</span>
<a href="#l3.393"></a><span id="l3.393"> function FullTextCompleter() {</span>
<a href="#l3.394"></a><span id="l3.394"> }</span>
<a href="#l3.395"></a><span id="l3.395"> FullTextCompleter.prototype = {</span>
<a href="#l3.396"></a><span id="l3.396" class="difflineminus">-  complete: function FullTextCompleter_complete(aResult, aSearchString) {</span>
<a href="#l3.397"></a><span id="l3.397" class="difflineplus">+  complete(aResult, aSearchString) {</span>
<a href="#l3.398"></a><span id="l3.398">     if (aSearchString.length &lt; 4)</span>
<a href="#l3.399"></a><span id="l3.399">       return false;</span>
<a href="#l3.400"></a><span id="l3.400">     // We use code very similar to that in msg_search.js, except that we</span>
<a href="#l3.401"></a><span id="l3.401">     // need to detect when we found phrases, as well as strip commas.</span>
<a href="#l3.402"></a><span id="l3.402">     aSearchString = aSearchString.trim();</span>
<a href="#l3.403"></a><span id="l3.403">     let terms = [];</span>
<a href="#l3.404"></a><span id="l3.404">     let phraseFound = false;</span>
<a href="#l3.405"></a><span id="l3.405">     while (aSearchString) {</span>
<a href="#l3.406"></a><span id="l3.406" class="difflineat">@@ -450,26 +446,26 @@ FullTextCompleter.prototype = {</span>
<a href="#l3.407"></a><span id="l3.407">       if (spaceIndex == -1) {</span>
<a href="#l3.408"></a><span id="l3.408">         terms.push(aSearchString.replace(/,/g, &quot;&quot;));</span>
<a href="#l3.409"></a><span id="l3.409">         break;</span>
<a href="#l3.410"></a><span id="l3.410">       }</span>
<a href="#l3.411"></a><span id="l3.411"> </span>
<a href="#l3.412"></a><span id="l3.412">       term = aSearchString.substring(0, spaceIndex).replace(/,/g, &quot;&quot;);</span>
<a href="#l3.413"></a><span id="l3.413">       if (term)</span>
<a href="#l3.414"></a><span id="l3.414">         terms.push(term);</span>
<a href="#l3.415"></a><span id="l3.415" class="difflineminus">-      aSearchString = aSearchString.substring(spaceIndex+1);</span>
<a href="#l3.416"></a><span id="l3.416" class="difflineplus">+      aSearchString = aSearchString.substring(spaceIndex + 1);</span>
<a href="#l3.417"></a><span id="l3.417">     }</span>
<a href="#l3.418"></a><span id="l3.418"> </span>
<a href="#l3.419"></a><span id="l3.419">     if (terms.length == 1 &amp;&amp; !phraseFound)</span>
<a href="#l3.420"></a><span id="l3.420">       aResult.addRows([new ResultRowFullText(aSearchString, terms, &quot;single&quot;)]);</span>
<a href="#l3.421"></a><span id="l3.421">     else</span>
<a href="#l3.422"></a><span id="l3.422">       aResult.addRows([new ResultRowFullText(aSearchString, terms, &quot;all&quot;)]);</span>
<a href="#l3.423"></a><span id="l3.423"> </span>
<a href="#l3.424"></a><span id="l3.424">     return false; // no async mechanism that will add new rows</span>
<a href="#l3.425"></a><span id="l3.425" class="difflineminus">-  }</span>
<a href="#l3.426"></a><span id="l3.426" class="difflineplus">+  },</span>
<a href="#l3.427"></a><span id="l3.427"> };</span>
<a href="#l3.428"></a><span id="l3.428"> </span>
<a href="#l3.429"></a><span id="l3.429"> var LOG;</span>
<a href="#l3.430"></a><span id="l3.430"> </span>
<a href="#l3.431"></a><span id="l3.431"> function nsAutoCompleteGloda() {</span>
<a href="#l3.432"></a><span id="l3.432">   this.wrappedJSObject = this;</span>
<a href="#l3.433"></a><span id="l3.433">   try {</span>
<a href="#l3.434"></a><span id="l3.434">     // set up our awesome globals!</span>
<a href="#l3.435"></a><span id="l3.435" class="difflineat">@@ -482,17 +478,17 @@ function nsAutoCompleteGloda() {</span>
<a href="#l3.436"></a><span id="l3.436">       loadNS = ChromeUtils.import(&quot;resource:///modules/gloda/suffixtree.js&quot;);</span>
<a href="#l3.437"></a><span id="l3.437">       MultiSuffixTree = loadNS.MultiSuffixTree;</span>
<a href="#l3.438"></a><span id="l3.438">       loadNS = ChromeUtils.import(&quot;resource:///modules/gloda/noun_tag.js&quot;);</span>
<a href="#l3.439"></a><span id="l3.439">       TagNoun = loadNS.TagNoun;</span>
<a href="#l3.440"></a><span id="l3.440">       loadNS = ChromeUtils.import(&quot;resource:///modules/gloda/noun_freetag.js&quot;);</span>
<a href="#l3.441"></a><span id="l3.441">       FreeTagNoun = loadNS.FreeTagNoun;</span>
<a href="#l3.442"></a><span id="l3.442"> </span>
<a href="#l3.443"></a><span id="l3.443">       loadNS = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l3.444"></a><span id="l3.444" class="difflineminus">-      LOG = loadNS[&quot;Log4Moz&quot;].repository.getLogger(&quot;gloda.autocomp&quot;);</span>
<a href="#l3.445"></a><span id="l3.445" class="difflineplus">+      LOG = loadNS.Log4Moz.repository.getLogger(&quot;gloda.autocomp&quot;);</span>
<a href="#l3.446"></a><span id="l3.446">     }</span>
<a href="#l3.447"></a><span id="l3.447"> </span>
<a href="#l3.448"></a><span id="l3.448">     this.completers = [];</span>
<a href="#l3.449"></a><span id="l3.449">     this.curResult = null;</span>
<a href="#l3.450"></a><span id="l3.450"> </span>
<a href="#l3.451"></a><span id="l3.451">     this.completers.push(new FullTextCompleter());        // not async.</span>
<a href="#l3.452"></a><span id="l3.452">     this.completers.push(new ContactIdentityCompleter()); // potentially async.</span>
<a href="#l3.453"></a><span id="l3.453">     this.completers.push(new ContactTagCompleter());      // not async.</span>
<a href="#l3.454"></a><span id="l3.454" class="difflineat">@@ -502,44 +498,44 @@ function nsAutoCompleteGloda() {</span>
<a href="#l3.455"></a><span id="l3.455">   }</span>
<a href="#l3.456"></a><span id="l3.456"> }</span>
<a href="#l3.457"></a><span id="l3.457"> </span>
<a href="#l3.458"></a><span id="l3.458"> nsAutoCompleteGloda.prototype = {</span>
<a href="#l3.459"></a><span id="l3.459">   classID: Components.ID(&quot;{3bbe4d77-3f70-4252-9500-bc00c26f476d}&quot;),</span>
<a href="#l3.460"></a><span id="l3.460">   QueryInterface: ChromeUtils.generateQI([</span>
<a href="#l3.461"></a><span id="l3.461">       Ci.nsIAutoCompleteSearch]),</span>
<a href="#l3.462"></a><span id="l3.462"> </span>
<a href="#l3.463"></a><span id="l3.463" class="difflineminus">-  startSearch: function(aString, aParam, aResult, aListener) {</span>
<a href="#l3.464"></a><span id="l3.464" class="difflineplus">+  startSearch(aString, aParam, aResult, aListener) {</span>
<a href="#l3.465"></a><span id="l3.465">     try {</span>
<a href="#l3.466"></a><span id="l3.466">       let result = new nsAutoCompleteGlodaResult(aListener, this, aString);</span>
<a href="#l3.467"></a><span id="l3.467">       // save this for hacky access to the search.  I somewhat suspect we simply</span>
<a href="#l3.468"></a><span id="l3.468">       //  should not be using the formal autocomplete mechanism at all.</span>
<a href="#l3.469"></a><span id="l3.469">       // Used in glodacomplete.xml.</span>
<a href="#l3.470"></a><span id="l3.470">       this.curResult = result;</span>
<a href="#l3.471"></a><span id="l3.471"> </span>
<a href="#l3.472"></a><span id="l3.472">       // Guard against late async results being sent.</span>
<a href="#l3.473"></a><span id="l3.473">       this.curResult.active = true;</span>
<a href="#l3.474"></a><span id="l3.474"> </span>
<a href="#l3.475"></a><span id="l3.475">       if (aParam == &quot;global&quot;) {</span>
<a href="#l3.476"></a><span id="l3.476">         for (let completer of this.completers) {</span>
<a href="#l3.477"></a><span id="l3.477">           // they will return true if they have something pending.</span>
<a href="#l3.478"></a><span id="l3.478">           if (completer.complete(result, aString))</span>
<a href="#l3.479"></a><span id="l3.479">             result.markPending(completer);</span>
<a href="#l3.480"></a><span id="l3.480">         }</span>
<a href="#l3.481"></a><span id="l3.481" class="difflineminus">-      //} else {</span>
<a href="#l3.482"></a><span id="l3.482" class="difflineplus">+      // } else {</span>
<a href="#l3.483"></a><span id="l3.483">       //   It'd be nice to do autocomplete in the quicksearch modes based</span>
<a href="#l3.484"></a><span id="l3.484">       //   on the specific values for that mode in the current view.</span>
<a href="#l3.485"></a><span id="l3.485">       //   But we don't do that yet.</span>
<a href="#l3.486"></a><span id="l3.486">       }</span>
<a href="#l3.487"></a><span id="l3.487"> </span>
<a href="#l3.488"></a><span id="l3.488">       result.announceYourself();</span>
<a href="#l3.489"></a><span id="l3.489">     } catch (e) {</span>
<a href="#l3.490"></a><span id="l3.490">       logException(e);</span>
<a href="#l3.491"></a><span id="l3.491">     }</span>
<a href="#l3.492"></a><span id="l3.492">   },</span>
<a href="#l3.493"></a><span id="l3.493"> </span>
<a href="#l3.494"></a><span id="l3.494" class="difflineminus">-  stopSearch: function() {</span>
<a href="#l3.495"></a><span id="l3.495" class="difflineplus">+  stopSearch() {</span>
<a href="#l3.496"></a><span id="l3.496">     this.curResult.active = false;</span>
<a href="#l3.497"></a><span id="l3.497" class="difflineminus">-  }</span>
<a href="#l3.498"></a><span id="l3.498" class="difflineplus">+  },</span>
<a href="#l3.499"></a><span id="l3.499"> };</span>
<a href="#l3.500"></a><span id="l3.500"> </span>
<a href="#l3.501"></a><span id="l3.501"> var components = [nsAutoCompleteGloda];</span>
<a href="#l3.502"></a><span id="l3.502"> var NSGetFactory = XPCOMUtils.generateNSGetFactory(components);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/db/gloda/components/jsmimeemitter.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/db/gloda/components/jsmimeemitter.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -65,85 +65,82 @@ function MimeMessageEmitter() {</span>
<a href="#l4.4"></a><span id="l4.4"> </span>
<a href="#l4.5"></a><span id="l4.5"> var deathToNewlines = /\n/g;</span>
<a href="#l4.6"></a><span id="l4.6"> </span>
<a href="#l4.7"></a><span id="l4.7"> MimeMessageEmitter.prototype = {</span>
<a href="#l4.8"></a><span id="l4.8">   classID: Components.ID(&quot;{8cddbbbc-7ced-46b0-a936-8cddd1928c24}&quot;),</span>
<a href="#l4.9"></a><span id="l4.9"> </span>
<a href="#l4.10"></a><span id="l4.10">   QueryInterface: ChromeUtils.generateQI([Ci.nsIMimeEmitter]),</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-  initialize: function mime_emitter_initialize(aUrl, aChannel, aFormat) {</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+  initialize(aUrl, aChannel, aFormat) {</span>
<a href="#l4.14"></a><span id="l4.14">     this._url = aUrl;</span>
<a href="#l4.15"></a><span id="l4.15">     this._curPart = new this._mimeMsg.MimeMessage();</span>
<a href="#l4.16"></a><span id="l4.16">     // the partName is intentionally &quot;&quot;!  not a place-holder!</span>
<a href="#l4.17"></a><span id="l4.17">     this._curPart.partName = &quot;&quot;;</span>
<a href="#l4.18"></a><span id="l4.18">     this._curAttachment = &quot;&quot;;</span>
<a href="#l4.19"></a><span id="l4.19">     this._partMap[&quot;&quot;] = this._curPart;</span>
<a href="#l4.20"></a><span id="l4.20"> </span>
<a href="#l4.21"></a><span id="l4.21">     // pull options across...</span>
<a href="#l4.22"></a><span id="l4.22">     let options = this._mimeMsg.MsgHdrToMimeMessage.OPTION_TUNNEL;</span>
<a href="#l4.23"></a><span id="l4.23">     this._saneBodySize = (options &amp;&amp; (&quot;saneBodySize&quot; in options)) ?</span>
<a href="#l4.24"></a><span id="l4.24">                            options.saneBodySize : false;</span>
<a href="#l4.25"></a><span id="l4.25"> </span>
<a href="#l4.26"></a><span id="l4.26">     this._mimeMsg.MsgHdrToMimeMessage.RESULT_RENDEVOUZ[aUrl.spec] =</span>
<a href="#l4.27"></a><span id="l4.27">       this._curPart;</span>
<a href="#l4.28"></a><span id="l4.28">   },</span>
<a href="#l4.29"></a><span id="l4.29"> </span>
<a href="#l4.30"></a><span id="l4.30" class="difflineminus">-  complete: function mime_emitter_complete() {</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+  complete() {</span>
<a href="#l4.32"></a><span id="l4.32">     this._url = null;</span>
<a href="#l4.33"></a><span id="l4.33"> </span>
<a href="#l4.34"></a><span id="l4.34">     this._outputListener = null;</span>
<a href="#l4.35"></a><span id="l4.35"> </span>
<a href="#l4.36"></a><span id="l4.36">     this._curPart = null;</span>
<a href="#l4.37"></a><span id="l4.37">     this._curAttachment = null;</span>
<a href="#l4.38"></a><span id="l4.38">     this._partMap = null;</span>
<a href="#l4.39"></a><span id="l4.39">     this._bogusPartTranslation = null;</span>
<a href="#l4.40"></a><span id="l4.40">   },</span>
<a href="#l4.41"></a><span id="l4.41"> </span>
<a href="#l4.42"></a><span id="l4.42" class="difflineminus">-  setPipe: function mime_emitter_setPipe(aInputStream, aOutputStream) {</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+  setPipe(aInputStream, aOutputStream) {</span>
<a href="#l4.44"></a><span id="l4.44">     // we do not care about these</span>
<a href="#l4.45"></a><span id="l4.45">   },</span>
<a href="#l4.46"></a><span id="l4.46">   set outputListener(aListener) {</span>
<a href="#l4.47"></a><span id="l4.47">     this._outputListener = aListener;</span>
<a href="#l4.48"></a><span id="l4.48">   },</span>
<a href="#l4.49"></a><span id="l4.49">   get outputListener() {</span>
<a href="#l4.50"></a><span id="l4.50">     return this._outputListener;</span>
<a href="#l4.51"></a><span id="l4.51">   },</span>
<a href="#l4.52"></a><span id="l4.52"> </span>
<a href="#l4.53"></a><span id="l4.53" class="difflineminus">-  _stripParams: function mime_emitter__stripParams(aValue) {</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+  _stripParams(aValue) {</span>
<a href="#l4.55"></a><span id="l4.55">     let indexSemi = aValue.indexOf(&quot;;&quot;);</span>
<a href="#l4.56"></a><span id="l4.56">     if (indexSemi &gt;= 0)</span>
<a href="#l4.57"></a><span id="l4.57">         aValue = aValue.substring(0, indexSemi);</span>
<a href="#l4.58"></a><span id="l4.58">     return aValue;</span>
<a href="#l4.59"></a><span id="l4.59">   },</span>
<a href="#l4.60"></a><span id="l4.60"> </span>
<a href="#l4.61"></a><span id="l4.61" class="difflineminus">-  _beginPayload: function mime_emitter__beginPayload(aContentType) {</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+  _beginPayload(aContentType) {</span>
<a href="#l4.63"></a><span id="l4.63">     let contentTypeNoParams = this._stripParams(aContentType).toLowerCase();</span>
<a href="#l4.64"></a><span id="l4.64">     if (contentTypeNoParams == &quot;text/plain&quot; ||</span>
<a href="#l4.65"></a><span id="l4.65">         contentTypeNoParams == &quot;text/html&quot; ||</span>
<a href="#l4.66"></a><span id="l4.66">         contentTypeNoParams == &quot;text/enriched&quot;) {</span>
<a href="#l4.67"></a><span id="l4.67">       this._curPart = new this._mimeMsg.MimeBody(contentTypeNoParams);</span>
<a href="#l4.68"></a><span id="l4.68">       this._writeBody = true;</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineminus">-    }</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineminus">-    else if (contentTypeNoParams == &quot;message/rfc822&quot;) {</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineplus">+    } else if (contentTypeNoParams == &quot;message/rfc822&quot;) {</span>
<a href="#l4.72"></a><span id="l4.72">       // startHeader will take care of this</span>
<a href="#l4.73"></a><span id="l4.73">       this._curPart = new this._mimeMsg.MimeMessage();</span>
<a href="#l4.74"></a><span id="l4.74">       // do not fall through into the content-type setting case; this</span>
<a href="#l4.75"></a><span id="l4.75">       //  content-type needs to get clobbered by the actual content-type of</span>
<a href="#l4.76"></a><span id="l4.76">       //  the enclosed message.</span>
<a href="#l4.77"></a><span id="l4.77">       this._writeBody = false;</span>
<a href="#l4.78"></a><span id="l4.78">       return;</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineminus">-    }</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineminus">-    // this is going to fall-down with TNEF encapsulation and such, we really</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineminus">-    //  need to just be consuming the object model.</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineminus">-    else if (contentTypeNoParams.startsWith(&quot;multipart/&quot;)) {</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineplus">+    } else if (contentTypeNoParams.startsWith(&quot;multipart/&quot;)) {</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+      // this is going to fall-down with TNEF encapsulation and such, we really</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+      // need to just be consuming the object model.</span>
<a href="#l4.86"></a><span id="l4.86">       this._curPart = new this._mimeMsg.MimeContainer(contentTypeNoParams);</span>
<a href="#l4.87"></a><span id="l4.87">       this._writeBody = false;</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineminus">-    }</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineminus">-    else {</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+    } else {</span>
<a href="#l4.91"></a><span id="l4.91">       this._curPart = new this._mimeMsg.MimeUnknown(contentTypeNoParams);</span>
<a href="#l4.92"></a><span id="l4.92">       this._writeBody = false;</span>
<a href="#l4.93"></a><span id="l4.93">     }</span>
<a href="#l4.94"></a><span id="l4.94">     // put the full content-type in the headers and normalize out any newlines</span>
<a href="#l4.95"></a><span id="l4.95">     this._curPart.headers[&quot;content-type&quot;] =</span>
<a href="#l4.96"></a><span id="l4.96">       [aContentType.replace(deathToNewlines, &quot;&quot;)];</span>
<a href="#l4.97"></a><span id="l4.97">   },</span>
<a href="#l4.98"></a><span id="l4.98"> </span>
<a href="#l4.99"></a><span id="l4.99" class="difflineat">@@ -159,18 +156,17 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l4.100"></a><span id="l4.100">    *  addHeaderFields for the content-type and the x-jsemitter-part-path</span>
<a href="#l4.101"></a><span id="l4.101">    *  prior to the startHeader call.  This is because the MIME multipart</span>
<a href="#l4.102"></a><span id="l4.102">    *  container that holds the message is the one generating the notification.</span>
<a href="#l4.103"></a><span id="l4.103">    *  For that reason, we do not process them here, but instead in</span>
<a href="#l4.104"></a><span id="l4.104">    *  addHeaderField and _beginPayload.</span>
<a href="#l4.105"></a><span id="l4.105">    *</span>
<a href="#l4.106"></a><span id="l4.106">    * We do need to track our state for addHeaderField's benefit though.</span>
<a href="#l4.107"></a><span id="l4.107">    */</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineminus">-  startHeader: function mime_emitter_startHeader(aIsRootMailHeader,</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineminus">-      aIsHeaderOnly, aMsgID, aOutputCharset) {</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+  startHeader(aIsRootMailHeader, aIsHeaderOnly, aMsgID, aOutputCharset) {</span>
<a href="#l4.111"></a><span id="l4.111">     this._state = kStateInHeaders;</span>
<a href="#l4.112"></a><span id="l4.112">   },</span>
<a href="#l4.113"></a><span id="l4.113">   /**</span>
<a href="#l4.114"></a><span id="l4.114">    * Receives a header field name and value for the current MIME part, which</span>
<a href="#l4.115"></a><span id="l4.115">    *  can be an rfc822/message or one of its sub-parts.</span>
<a href="#l4.116"></a><span id="l4.116">    *</span>
<a href="#l4.117"></a><span id="l4.117">    * The emitter architecture treats rfc822/messages as special because it was</span>
<a href="#l4.118"></a><span id="l4.118">    *  architected around presentation.  In that case, the organizing concept</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineat">@@ -183,67 +179,63 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l4.120"></a><span id="l4.120">    *  odd pseudo-mime-part.  Because it has only one child, its headers are,</span>
<a href="#l4.121"></a><span id="l4.121">    *  in a way, its payload, but they also serve as the description of its</span>
<a href="#l4.122"></a><span id="l4.122">    *  MIME child part.  This introduces a complication in that we see the</span>
<a href="#l4.123"></a><span id="l4.123">    *  content-type for the message's &quot;body&quot; part before we actually see any</span>
<a href="#l4.124"></a><span id="l4.124">    *  of the headers.  To deal with this, we punt on the construction of the</span>
<a href="#l4.125"></a><span id="l4.125">    *  body part to the call to startBody() and predicate our logic on the</span>
<a href="#l4.126"></a><span id="l4.126">    *  _state field.</span>
<a href="#l4.127"></a><span id="l4.127">    */</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineminus">-  addHeaderField: function mime_emitter_addHeaderField(aField, aValue) {</span>
<a href="#l4.129"></a><span id="l4.129" class="difflineplus">+  addHeaderField(aField, aValue) {</span>
<a href="#l4.130"></a><span id="l4.130">     if (this._state == kStateInBody) {</span>
<a href="#l4.131"></a><span id="l4.131">       aField = aField.toLowerCase();</span>
<a href="#l4.132"></a><span id="l4.132" class="difflineminus">-      if (aField == &quot;content-type&quot;)</span>
<a href="#l4.133"></a><span id="l4.133" class="difflineplus">+      if (aField == &quot;content-type&quot;) {</span>
<a href="#l4.134"></a><span id="l4.134">         this._beginPayload(aValue, true);</span>
<a href="#l4.135"></a><span id="l4.135" class="difflineminus">-      else if (aField == &quot;x-jsemitter-part-path&quot;) {</span>
<a href="#l4.136"></a><span id="l4.136" class="difflineplus">+      } else if (aField == &quot;x-jsemitter-part-path&quot;) {</span>
<a href="#l4.137"></a><span id="l4.137">         // This is either naming the current part, or referring to an already</span>
<a href="#l4.138"></a><span id="l4.138">         //  existing part (in the case of multipart/related on its second pass).</span>
<a href="#l4.139"></a><span id="l4.139">         // As such, check if the name already exists in our part map.</span>
<a href="#l4.140"></a><span id="l4.140">         let partName = this._stripParams(aValue);</span>
<a href="#l4.141"></a><span id="l4.141">         // if it does, then make the already-existing part at that path current</span>
<a href="#l4.142"></a><span id="l4.142">         if (partName in this._partMap) {</span>
<a href="#l4.143"></a><span id="l4.143">           this._curPart = this._partMap[partName];</span>
<a href="#l4.144"></a><span id="l4.144">           this._writeBody = &quot;body&quot; in this._curPart;</span>
<a href="#l4.145"></a><span id="l4.145" class="difflineminus">-        }</span>
<a href="#l4.146"></a><span id="l4.146" class="difflineminus">-        // otherwise, name the part we are holding onto and place it.</span>
<a href="#l4.147"></a><span id="l4.147" class="difflineminus">-        else {</span>
<a href="#l4.148"></a><span id="l4.148" class="difflineplus">+        } else { // otherwise, name the part we are holding onto and place it.</span>
<a href="#l4.149"></a><span id="l4.149">           this._curPart.partName = partName;</span>
<a href="#l4.150"></a><span id="l4.150">           this._placePart(this._curPart);</span>
<a href="#l4.151"></a><span id="l4.151">         }</span>
<a href="#l4.152"></a><span id="l4.152" class="difflineminus">-      }</span>
<a href="#l4.153"></a><span id="l4.153" class="difflineminus">-      else if (aField == &quot;x-jsemitter-encrypted&quot; &amp;&amp; aValue == &quot;1&quot;) {</span>
<a href="#l4.154"></a><span id="l4.154" class="difflineplus">+      } else if (aField == &quot;x-jsemitter-encrypted&quot; &amp;&amp; aValue == &quot;1&quot;) {</span>
<a href="#l4.155"></a><span id="l4.155">         this._curPart.isEncrypted = true;</span>
<a href="#l4.156"></a><span id="l4.156">       }</span>
<a href="#l4.157"></a><span id="l4.157">       // There is no other field to be emitted in the body case other than the</span>
<a href="#l4.158"></a><span id="l4.158">       //  ones we just handled.  (They were explicitly added for the js</span>
<a href="#l4.159"></a><span id="l4.159">       //  emitter.)</span>
<a href="#l4.160"></a><span id="l4.160" class="difflineminus">-    }</span>
<a href="#l4.161"></a><span id="l4.161" class="difflineminus">-    else if (this._state == kStateInHeaders) {</span>
<a href="#l4.162"></a><span id="l4.162" class="difflineplus">+    } else if (this._state == kStateInHeaders) {</span>
<a href="#l4.163"></a><span id="l4.163">       let lowerField = aField.toLowerCase();</span>
<a href="#l4.164"></a><span id="l4.164">       if (lowerField in this._curPart.headers)</span>
<a href="#l4.165"></a><span id="l4.165">         this._curPart.headers[lowerField].push(aValue);</span>
<a href="#l4.166"></a><span id="l4.166">       else</span>
<a href="#l4.167"></a><span id="l4.167">         this._curPart.headers[lowerField] = [aValue];</span>
<a href="#l4.168"></a><span id="l4.168">     }</span>
<a href="#l4.169"></a><span id="l4.169">   },</span>
<a href="#l4.170"></a><span id="l4.170" class="difflineminus">-  addAllHeaders: function mime_emitter_addAllHeaders(aAllHeaders, aHeaderSize) {</span>
<a href="#l4.171"></a><span id="l4.171" class="difflineplus">+  addAllHeaders(aAllHeaders, aHeaderSize) {</span>
<a href="#l4.172"></a><span id="l4.172">     // This is called by the parsing code after the calls to AddHeaderField (or</span>
<a href="#l4.173"></a><span id="l4.173">     //  AddAttachmentField if the part is an attachment), and seems to serve</span>
<a href="#l4.174"></a><span id="l4.174">     //  a specialized, quasi-redundant purpose.  (nsMimeBaseEmitter creates a</span>
<a href="#l4.175"></a><span id="l4.175">     //  nsIMimeHeaders instance and hands it to the nsIMsgMailNewsUrl.)</span>
<a href="#l4.176"></a><span id="l4.176">     // nop</span>
<a href="#l4.177"></a><span id="l4.177">   },</span>
<a href="#l4.178"></a><span id="l4.178" class="difflineminus">-  writeHTMLHeaders: function mime_emitter_writeHTMLHeaders(aName) {</span>
<a href="#l4.179"></a><span id="l4.179" class="difflineplus">+  writeHTMLHeaders(aName) {</span>
<a href="#l4.180"></a><span id="l4.180">     // It doesn't look like this should even be part of the interface; I think</span>
<a href="#l4.181"></a><span id="l4.181">     //  only the nsMimeHtmlDisplayEmitter::EndHeader call calls this signature.</span>
<a href="#l4.182"></a><span id="l4.182">     // nop</span>
<a href="#l4.183"></a><span id="l4.183">   },</span>
<a href="#l4.184"></a><span id="l4.184" class="difflineminus">-  endHeader: function mime_emitter_endHeader(aName) {</span>
<a href="#l4.185"></a><span id="l4.185" class="difflineplus">+  endHeader(aName) {</span>
<a href="#l4.186"></a><span id="l4.186">   },</span>
<a href="#l4.187"></a><span id="l4.187" class="difflineminus">-  updateCharacterSet: function mime_emitter_updateCharacterSet(aCharset) {</span>
<a href="#l4.188"></a><span id="l4.188" class="difflineplus">+  updateCharacterSet(aCharset) {</span>
<a href="#l4.189"></a><span id="l4.189">     // we do not need to worry about this.  it turns out this notification is</span>
<a href="#l4.190"></a><span id="l4.190">     //  exclusively for the benefit of the UI.  libmime, believe it or not,</span>
<a href="#l4.191"></a><span id="l4.191">     //  is actually doing the right thing under the hood and handles all the</span>
<a href="#l4.192"></a><span id="l4.192">     //  encoding issues for us.</span>
<a href="#l4.193"></a><span id="l4.193">     // so, get ready for the only time you will ever hear this:</span>
<a href="#l4.194"></a><span id="l4.194">     //  three cheers for libmime!</span>
<a href="#l4.195"></a><span id="l4.195">   },</span>
<a href="#l4.196"></a><span id="l4.196"> </span>
<a href="#l4.197"></a><span id="l4.197" class="difflineat">@@ -254,28 +246,28 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l4.198"></a><span id="l4.198">    *  motivating use-case is multipart/related which actually does generate</span>
<a href="#l4.199"></a><span id="l4.199">    *  everything in order on its first pass, but has a wacky second pass. It</span>
<a href="#l4.200"></a><span id="l4.200">    *  does not actually trigger the out-of-order code because we have</span>
<a href="#l4.201"></a><span id="l4.201">    *  augmented the libmime code to generate its x-jsemitter-part-path info</span>
<a href="#l4.202"></a><span id="l4.202">    *  a second time, in which case we reuse the part we already created.)</span>
<a href="#l4.203"></a><span id="l4.203">    *</span>
<a href="#l4.204"></a><span id="l4.204">    * @param aPart Part to place.</span>
<a href="#l4.205"></a><span id="l4.205">    */</span>
<a href="#l4.206"></a><span id="l4.206" class="difflineminus">-  _placePart: function(aPart) {</span>
<a href="#l4.207"></a><span id="l4.207" class="difflineplus">+  _placePart(aPart) {</span>
<a href="#l4.208"></a><span id="l4.208">     let partName = aPart.partName;</span>
<a href="#l4.209"></a><span id="l4.209">     this._partMap[partName] = aPart;</span>
<a href="#l4.210"></a><span id="l4.210"> </span>
<a href="#l4.211"></a><span id="l4.211" class="difflineminus">-    let [storagePartName, parentName, parentPart] = this._findOrCreateParent(partName);</span>
<a href="#l4.212"></a><span id="l4.212" class="difflineplus">+    let [storagePartName, , parentPart] = this._findOrCreateParent(partName);</span>
<a href="#l4.213"></a><span id="l4.213">     let lastDotIndex = storagePartName.lastIndexOf(&quot;.&quot;);</span>
<a href="#l4.214"></a><span id="l4.214">     if (parentPart !== undefined) {</span>
<a href="#l4.215"></a><span id="l4.215" class="difflineminus">-      let indexInParent = parseInt(storagePartName.substring(lastDotIndex+1)) - 1;</span>
<a href="#l4.216"></a><span id="l4.216" class="difflineplus">+      let indexInParent = parseInt(storagePartName.substring(lastDotIndex + 1)) - 1;</span>
<a href="#l4.217"></a><span id="l4.217">       // handle out-of-order notification...</span>
<a href="#l4.218"></a><span id="l4.218" class="difflineminus">-      if (indexInParent &lt; parentPart.parts.length)</span>
<a href="#l4.219"></a><span id="l4.219" class="difflineplus">+      if (indexInParent &lt; parentPart.parts.length) {</span>
<a href="#l4.220"></a><span id="l4.220">         parentPart.parts[indexInParent] = aPart;</span>
<a href="#l4.221"></a><span id="l4.221" class="difflineminus">-      else {</span>
<a href="#l4.222"></a><span id="l4.222" class="difflineplus">+      } else {</span>
<a href="#l4.223"></a><span id="l4.223">         while (indexInParent &gt; parentPart.parts.length)</span>
<a href="#l4.224"></a><span id="l4.224">           parentPart.parts.push(null);</span>
<a href="#l4.225"></a><span id="l4.225">         parentPart.parts.push(aPart);</span>
<a href="#l4.226"></a><span id="l4.226">       }</span>
<a href="#l4.227"></a><span id="l4.227">     }</span>
<a href="#l4.228"></a><span id="l4.228">   },</span>
<a href="#l4.229"></a><span id="l4.229"> </span>
<a href="#l4.230"></a><span id="l4.230">   /**</span>
<a href="#l4.231"></a><span id="l4.231" class="difflineat">@@ -285,78 +277,77 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l4.232"></a><span id="l4.232">    * What happens in the case of encrypted emails (mimecryp.cpp):</span>
<a href="#l4.233"></a><span id="l4.233">    *  1. is the message</span>
<a href="#l4.234"></a><span id="l4.234">    *  1.1 doesn't exist</span>
<a href="#l4.235"></a><span id="l4.235">    *  1.1.1 is the multipart/alternative that holds the text/plain and text/html</span>
<a href="#l4.236"></a><span id="l4.236">    *  1.1.1.1 is text/plain</span>
<a href="#l4.237"></a><span id="l4.237">    *  1.1.1.2 is text/html</span>
<a href="#l4.238"></a><span id="l4.238">    * This function fills the missing bits.</span>
<a href="#l4.239"></a><span id="l4.239">    */</span>
<a href="#l4.240"></a><span id="l4.240" class="difflineminus">-  _findOrCreateParent: function (aPartName) {</span>
<a href="#l4.241"></a><span id="l4.241" class="difflineplus">+  _findOrCreateParent(aPartName) {</span>
<a href="#l4.242"></a><span id="l4.242">     let partName = aPartName + &quot;&quot;;</span>
<a href="#l4.243"></a><span id="l4.243">     let parentName = partName.substring(0, partName.lastIndexOf(&quot;.&quot;));</span>
<a href="#l4.244"></a><span id="l4.244">     let parentPart;</span>
<a href="#l4.245"></a><span id="l4.245">     if (parentName in this._partMap) {</span>
<a href="#l4.246"></a><span id="l4.246" class="difflineminus">-      parentPart = this._partMap[parentName]</span>
<a href="#l4.247"></a><span id="l4.247" class="difflineplus">+      parentPart = this._partMap[parentName];</span>
<a href="#l4.248"></a><span id="l4.248">       let lastDotIndex = partName.lastIndexOf(&quot;.&quot;);</span>
<a href="#l4.249"></a><span id="l4.249" class="difflineminus">-      let indexInParent = parseInt(partName.substring(lastDotIndex+1)) - 1;</span>
<a href="#l4.250"></a><span id="l4.250" class="difflineplus">+      let indexInParent = parseInt(partName.substring(lastDotIndex + 1)) - 1;</span>
<a href="#l4.251"></a><span id="l4.251">       if (&quot;parts&quot; in parentPart &amp;&amp; indexInParent == parentPart.parts.length - 1)</span>
<a href="#l4.252"></a><span id="l4.252">         return [partName, parentName, parentPart];</span>
<a href="#l4.253"></a><span id="l4.253" class="difflineminus">-      else</span>
<a href="#l4.254"></a><span id="l4.254" class="difflineminus">-        return this._findAnotherContainer(aPartName);</span>
<a href="#l4.255"></a><span id="l4.255" class="difflineminus">-    } else {</span>
<a href="#l4.256"></a><span id="l4.256" class="difflineminus">-      // Find the grandparent</span>
<a href="#l4.257"></a><span id="l4.257" class="difflineminus">-      let [, grandParentName, grandParentPart] = this._findOrCreateParent(parentName);</span>
<a href="#l4.258"></a><span id="l4.258" class="difflineminus">-      // Create the missing part.</span>
<a href="#l4.259"></a><span id="l4.259" class="difflineminus">-      let parentPart = new this._mimeMsg.MimeContainer(&quot;multipart/fake-container&quot;);</span>
<a href="#l4.260"></a><span id="l4.260" class="difflineminus">-      // Add it to the grandparent, remember we added it in the hierarchy.</span>
<a href="#l4.261"></a><span id="l4.261" class="difflineminus">-      grandParentPart.parts.push(parentPart);</span>
<a href="#l4.262"></a><span id="l4.262" class="difflineminus">-      this._partMap[parentName] = parentPart;</span>
<a href="#l4.263"></a><span id="l4.263" class="difflineminus">-      return [partName, parentName, parentPart];</span>
<a href="#l4.264"></a><span id="l4.264" class="difflineplus">+      return this._findAnotherContainer(aPartName);</span>
<a href="#l4.265"></a><span id="l4.265">     }</span>
<a href="#l4.266"></a><span id="l4.266" class="difflineplus">+</span>
<a href="#l4.267"></a><span id="l4.267" class="difflineplus">+    // Find the grandparent</span>
<a href="#l4.268"></a><span id="l4.268" class="difflineplus">+    let [, , grandParentPart] = this._findOrCreateParent(parentName);</span>
<a href="#l4.269"></a><span id="l4.269" class="difflineplus">+    // Create the missing part.</span>
<a href="#l4.270"></a><span id="l4.270" class="difflineplus">+    parentPart = new this._mimeMsg.MimeContainer(&quot;multipart/fake-container&quot;);</span>
<a href="#l4.271"></a><span id="l4.271" class="difflineplus">+    // Add it to the grandparent, remember we added it in the hierarchy.</span>
<a href="#l4.272"></a><span id="l4.272" class="difflineplus">+    grandParentPart.parts.push(parentPart);</span>
<a href="#l4.273"></a><span id="l4.273" class="difflineplus">+    this._partMap[parentName] = parentPart;</span>
<a href="#l4.274"></a><span id="l4.274" class="difflineplus">+    return [partName, parentName, parentPart];</span>
<a href="#l4.275"></a><span id="l4.275">   },</span>
<a href="#l4.276"></a><span id="l4.276"> </span>
<a href="#l4.277"></a><span id="l4.277">   /**</span>
<a href="#l4.278"></a><span id="l4.278">    * In the case of UUEncoded attachments, libmime tells us about the attachment</span>
<a href="#l4.279"></a><span id="l4.279">    *  as a child of a MimeBody. This obviously doesn't make us happy, so in case</span>
<a href="#l4.280"></a><span id="l4.280">    *  libmime wants us to attach an attachment to something that's not a</span>
<a href="#l4.281"></a><span id="l4.281">    *  container, we walk up the mime tree to find a suitable container to hold</span>
<a href="#l4.282"></a><span id="l4.282">    *  the attachment.</span>
<a href="#l4.283"></a><span id="l4.283">    * The results are cached so that they're consistent across calls  this</span>
<a href="#l4.284"></a><span id="l4.284">    *  ensures the call to _replacePart works fine.</span>
<a href="#l4.285"></a><span id="l4.285">    */</span>
<a href="#l4.286"></a><span id="l4.286" class="difflineminus">-  _findAnotherContainer: function(aPartName) {</span>
<a href="#l4.287"></a><span id="l4.287" class="difflineplus">+  _findAnotherContainer(aPartName) {</span>
<a href="#l4.288"></a><span id="l4.288">     if (aPartName in this._bogusPartTranslation)</span>
<a href="#l4.289"></a><span id="l4.289">       return this._bogusPartTranslation[aPartName];</span>
<a href="#l4.290"></a><span id="l4.290"> </span>
<a href="#l4.291"></a><span id="l4.291">     let parentName = aPartName + &quot;&quot;;</span>
<a href="#l4.292"></a><span id="l4.292">     let parentPart;</span>
<a href="#l4.293"></a><span id="l4.293">     while (!(parentPart &amp;&amp; &quot;parts&quot; in parentPart) &amp;&amp; parentName.length) {</span>
<a href="#l4.294"></a><span id="l4.294">       parentName = parentName.substring(0, parentName.lastIndexOf(&quot;.&quot;));</span>
<a href="#l4.295"></a><span id="l4.295">       parentPart = this._partMap[parentName];</span>
<a href="#l4.296"></a><span id="l4.296">     }</span>
<a href="#l4.297"></a><span id="l4.297">     let childIndex = parentPart.parts.length;</span>
<a href="#l4.298"></a><span id="l4.298" class="difflineminus">-    let fallbackPartName = (parentName ? parentName +&quot;.&quot; : &quot;&quot;)+(childIndex+1);</span>
<a href="#l4.299"></a><span id="l4.299" class="difflineplus">+    let fallbackPartName = (parentName ? parentName + &quot;.&quot; : &quot;&quot;) + (childIndex + 1);</span>
<a href="#l4.300"></a><span id="l4.300">     return (this._bogusPartTranslation[aPartName] = [fallbackPartName, parentName, parentPart]);</span>
<a href="#l4.301"></a><span id="l4.301">   },</span>
<a href="#l4.302"></a><span id="l4.302"> </span>
<a href="#l4.303"></a><span id="l4.303">   /**</span>
<a href="#l4.304"></a><span id="l4.304">    * In the case of attachments, we need to replace an existing part with a</span>
<a href="#l4.305"></a><span id="l4.305">    *  more representative part...</span>
<a href="#l4.306"></a><span id="l4.306">    *</span>
<a href="#l4.307"></a><span id="l4.307">    * @param aPart Part to place.</span>
<a href="#l4.308"></a><span id="l4.308">    */</span>
<a href="#l4.309"></a><span id="l4.309" class="difflineminus">-  _replacePart: function(aPart) {</span>
<a href="#l4.310"></a><span id="l4.310" class="difflineplus">+  _replacePart(aPart) {</span>
<a href="#l4.311"></a><span id="l4.311">     // _partMap always maps the libmime names to parts</span>
<a href="#l4.312"></a><span id="l4.312">     let partName = aPart.partName;</span>
<a href="#l4.313"></a><span id="l4.313">     this._partMap[partName] = aPart;</span>
<a href="#l4.314"></a><span id="l4.314"> </span>
<a href="#l4.315"></a><span id="l4.315" class="difflineminus">-    let [storagePartName, parentName, parentPart] = this._findOrCreateParent(partName);</span>
<a href="#l4.316"></a><span id="l4.316" class="difflineplus">+    let [storagePartName, , parentPart] = this._findOrCreateParent(partName);</span>
<a href="#l4.317"></a><span id="l4.317"> </span>
<a href="#l4.318"></a><span id="l4.318" class="difflineminus">-    let childNamePart = storagePartName.substring(storagePartName.lastIndexOf(&quot;.&quot;)+1);</span>
<a href="#l4.319"></a><span id="l4.319" class="difflineplus">+    let childNamePart = storagePartName.substring(storagePartName.lastIndexOf(&quot;.&quot;) + 1);</span>
<a href="#l4.320"></a><span id="l4.320">     let childIndex = parseInt(childNamePart) - 1;</span>
<a href="#l4.321"></a><span id="l4.321"> </span>
<a href="#l4.322"></a><span id="l4.322">     // The attachment has been encapsulated properly in a MIME part (most of</span>
<a href="#l4.323"></a><span id="l4.323">     // the cases). This does not hold for UUencoded-parts for instance (see</span>
<a href="#l4.324"></a><span id="l4.324">     // test_mime_attachments_size.js for instance).</span>
<a href="#l4.325"></a><span id="l4.325">     if (childIndex &lt; parentPart.parts.length) {</span>
<a href="#l4.326"></a><span id="l4.326">       let oldPart = parentPart.parts[childIndex];</span>
<a href="#l4.327"></a><span id="l4.327">       parentPart.parts[childIndex] = aPart;</span>
<a href="#l4.328"></a><span id="l4.328" class="difflineat">@@ -369,36 +360,34 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l4.329"></a><span id="l4.329">     }</span>
<a href="#l4.330"></a><span id="l4.330">   },</span>
<a href="#l4.331"></a><span id="l4.331"> </span>
<a href="#l4.332"></a><span id="l4.332">   // ----- Attachment Routines</span>
<a href="#l4.333"></a><span id="l4.333">   // The attachment processing happens after the initial streaming phase (during</span>
<a href="#l4.334"></a><span id="l4.334">   //  which time we receive the messages, both bodies and headers).  Our caller</span>
<a href="#l4.335"></a><span id="l4.335">   //  traverses the libmime child object hierarchy, emitting an attachment for</span>
<a href="#l4.336"></a><span id="l4.336">   //  each leaf object or sub-message.</span>
<a href="#l4.337"></a><span id="l4.337" class="difflineminus">-  startAttachment: function mime_emitter_startAttachment(aName, aContentType,</span>
<a href="#l4.338"></a><span id="l4.338" class="difflineminus">-      aUrl, aIsExternalAttachment) {</span>
<a href="#l4.339"></a><span id="l4.339" class="difflineplus">+  startAttachment(aName, aContentType, aUrl, aIsExternalAttachment) {</span>
<a href="#l4.340"></a><span id="l4.340">     this._state = kStateInAttachment;</span>
<a href="#l4.341"></a><span id="l4.341"> </span>
<a href="#l4.342"></a><span id="l4.342">     // we need to strip our magic flags from the URL; this regexp matches all</span>
<a href="#l4.343"></a><span id="l4.343">     // the specific flags that the jsmimeemitter understands (we abuse the URL</span>
<a href="#l4.344"></a><span id="l4.344">     // parameters to pass information all the way to here)</span>
<a href="#l4.345"></a><span id="l4.345">     aUrl = aUrl.replace(/((header=filter|emitter=js|fetchCompleteMessage=(true|false)|examineEncryptedParts=(true|false)))&amp;?/g, &quot;&quot;);</span>
<a href="#l4.346"></a><span id="l4.346">     // the url should contain a part= piece that tells us the part name, which</span>
<a href="#l4.347"></a><span id="l4.347">     // we then use to figure out where to place that part if it's a real</span>
<a href="#l4.348"></a><span id="l4.348">     // attachment.</span>
<a href="#l4.349"></a><span id="l4.349">     let partMatch, partName;</span>
<a href="#l4.350"></a><span id="l4.350">     if (aUrl.startsWith(&quot;http&quot;) || aUrl.startsWith(&quot;file&quot;)) {</span>
<a href="#l4.351"></a><span id="l4.351">       // if we have a remote url, unlike non external mail part urls, it may also</span>
<a href="#l4.352"></a><span id="l4.352">       // contain query strings starting with ?; PART_RE does not handle this.</span>
<a href="#l4.353"></a><span id="l4.353">       partMatch = aUrl.match(/[?&amp;]part=[^&amp;]+$/);</span>
<a href="#l4.354"></a><span id="l4.354">       partMatch = partMatch &amp;&amp; partMatch[0];</span>
<a href="#l4.355"></a><span id="l4.355">       partName = partMatch &amp;&amp; partMatch.split(&quot;part=&quot;)[1];</span>
<a href="#l4.356"></a><span id="l4.356" class="difflineminus">-    }</span>
<a href="#l4.357"></a><span id="l4.357" class="difflineminus">-    else {</span>
<a href="#l4.358"></a><span id="l4.358" class="difflineplus">+    } else {</span>
<a href="#l4.359"></a><span id="l4.359">       partMatch = this._partRE.exec(aUrl);</span>
<a href="#l4.360"></a><span id="l4.360">       partName = partMatch &amp;&amp; partMatch[1];</span>
<a href="#l4.361"></a><span id="l4.361">     }</span>
<a href="#l4.362"></a><span id="l4.362">     this._curAttachment = partName;</span>
<a href="#l4.363"></a><span id="l4.363"> </span>
<a href="#l4.364"></a><span id="l4.364">     if (aContentType == &quot;message/rfc822&quot;) {</span>
<a href="#l4.365"></a><span id="l4.365">       // we want to offer extension authors a way to see attachments as the</span>
<a href="#l4.366"></a><span id="l4.366">       // message readers sees them, which means attaching an extra url property</span>
<a href="#l4.367"></a><span id="l4.367" class="difflineat">@@ -406,81 +395,80 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l4.368"></a><span id="l4.368">       if (partName) {</span>
<a href="#l4.369"></a><span id="l4.369">         // we disguise this MimeMessage into something that can be used as a</span>
<a href="#l4.370"></a><span id="l4.370">         // MimeAttachment so that it is transparent for the user code</span>
<a href="#l4.371"></a><span id="l4.371">         this._partMap[partName].url = aUrl;</span>
<a href="#l4.372"></a><span id="l4.372">         this._partMap[partName].isExternal = aIsExternalAttachment;</span>
<a href="#l4.373"></a><span id="l4.373">         this._partMap[partName].name = aName;</span>
<a href="#l4.374"></a><span id="l4.374">         this._partMap[partName].isRealAttachment = true;</span>
<a href="#l4.375"></a><span id="l4.375">       }</span>
<a href="#l4.376"></a><span id="l4.376" class="difflineminus">-    }</span>
<a href="#l4.377"></a><span id="l4.377" class="difflineminus">-    else if (partName) {</span>
<a href="#l4.378"></a><span id="l4.378" class="difflineplus">+    } else if (partName) {</span>
<a href="#l4.379"></a><span id="l4.379">       let part = new this._mimeMsg.MimeMessageAttachment(partName,</span>
<a href="#l4.380"></a><span id="l4.380">           aName, aContentType, aUrl, aIsExternalAttachment);</span>
<a href="#l4.381"></a><span id="l4.381">       // replace the existing part with the attachment...</span>
<a href="#l4.382"></a><span id="l4.382">       this._replacePart(part);</span>
<a href="#l4.383"></a><span id="l4.383">     }</span>
<a href="#l4.384"></a><span id="l4.384">   },</span>
<a href="#l4.385"></a><span id="l4.385" class="difflineminus">-  addAttachmentField: function mime_emitter_addAttachmentField(aField, aValue) {</span>
<a href="#l4.386"></a><span id="l4.386" class="difflineplus">+  addAttachmentField(aField, aValue) {</span>
<a href="#l4.387"></a><span id="l4.387">     // What gets passed in here is X-Mozilla-PartURL with a value that</span>
<a href="#l4.388"></a><span id="l4.388">     //  is completely identical to aUrl from the call to startAttachment.</span>
<a href="#l4.389"></a><span id="l4.389">     //  (it's the same variable they use in each case).  As such, there is</span>
<a href="#l4.390"></a><span id="l4.390">     //  no reason to handle that here.</span>
<a href="#l4.391"></a><span id="l4.391">     // However, we also pass information about the size of the attachment, and</span>
<a href="#l4.392"></a><span id="l4.392">     //  that we want to handle</span>
<a href="#l4.393"></a><span id="l4.393">     if (aField == &quot;X-Mozilla-PartSize&quot; &amp;&amp; (this._curAttachment in this._partMap))</span>
<a href="#l4.394"></a><span id="l4.394">       this._partMap[this._curAttachment].size = parseInt(aValue);</span>
<a href="#l4.395"></a><span id="l4.395">   },</span>
<a href="#l4.396"></a><span id="l4.396" class="difflineminus">-  endAttachment: function mime_emitter_endAttachment() {</span>
<a href="#l4.397"></a><span id="l4.397" class="difflineplus">+  endAttachment() {</span>
<a href="#l4.398"></a><span id="l4.398">     // don't need to do anything here, since we don't care about the headers.</span>
<a href="#l4.399"></a><span id="l4.399">   },</span>
<a href="#l4.400"></a><span id="l4.400" class="difflineminus">-  endAllAttachments: function mime_emitter_endAllAttachments() {</span>
<a href="#l4.401"></a><span id="l4.401" class="difflineplus">+  endAllAttachments() {</span>
<a href="#l4.402"></a><span id="l4.402">     // nop</span>
<a href="#l4.403"></a><span id="l4.403">   },</span>
<a href="#l4.404"></a><span id="l4.404"> </span>
<a href="#l4.405"></a><span id="l4.405">   // ----- Body Routines</span>
<a href="#l4.406"></a><span id="l4.406">   /**</span>
<a href="#l4.407"></a><span id="l4.407">    * We don't get an x-jsemitter-part-path for the message body, and we ignored</span>
<a href="#l4.408"></a><span id="l4.408">    *  our body part's content-type in addHeaderField, so this serves as our</span>
<a href="#l4.409"></a><span id="l4.409">    *  notice to set up the part (giving it a name).</span>
<a href="#l4.410"></a><span id="l4.410">    */</span>
<a href="#l4.411"></a><span id="l4.411" class="difflineminus">-  startBody: function mime_emitter_startBody(aIsBodyOnly, aMsgID, aOutCharset) {</span>
<a href="#l4.412"></a><span id="l4.412" class="difflineplus">+  startBody(aIsBodyOnly, aMsgID, aOutCharset) {</span>
<a href="#l4.413"></a><span id="l4.413">     this._state = kStateInBody;</span>
<a href="#l4.414"></a><span id="l4.414"> </span>
<a href="#l4.415"></a><span id="l4.415">     let subPartName = (this._curPart.partName == &quot;&quot;) ?</span>
<a href="#l4.416"></a><span id="l4.416">                         &quot;1&quot; :</span>
<a href="#l4.417"></a><span id="l4.417">                         this._curPart.partName + &quot;.1&quot;;</span>
<a href="#l4.418"></a><span id="l4.418">     this._beginPayload(this._curPart.get(&quot;content-type&quot;, &quot;text/plain&quot;));</span>
<a href="#l4.419"></a><span id="l4.419">     this._curPart.partName = subPartName;</span>
<a href="#l4.420"></a><span id="l4.420">     this._placePart(this._curPart);</span>
<a href="#l4.421"></a><span id="l4.421">   },</span>
<a href="#l4.422"></a><span id="l4.422"> </span>
<a href="#l4.423"></a><span id="l4.423">   /**</span>
<a href="#l4.424"></a><span id="l4.424">    * Write to the body.  When saneBodySize is active, we stop adding if we are</span>
<a href="#l4.425"></a><span id="l4.425">    *  already at the limit for this body part.</span>
<a href="#l4.426"></a><span id="l4.426">    */</span>
<a href="#l4.427"></a><span id="l4.427" class="difflineminus">-  writeBody: function mime_emitter_writeBody(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l4.428"></a><span id="l4.428" class="difflineplus">+  writeBody(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l4.429"></a><span id="l4.429">     if (this._writeBody &amp;&amp;</span>
<a href="#l4.430"></a><span id="l4.430">         (!this._saneBodySize ||</span>
<a href="#l4.431"></a><span id="l4.431">          this._curPart.size &lt; MAX_SANE_BODY_PART_SIZE))</span>
<a href="#l4.432"></a><span id="l4.432">       this._curPart.appendBody(aBuf);</span>
<a href="#l4.433"></a><span id="l4.433">   },</span>
<a href="#l4.434"></a><span id="l4.434"> </span>
<a href="#l4.435"></a><span id="l4.435" class="difflineminus">-  endBody: function mime_emitter_endBody() {</span>
<a href="#l4.436"></a><span id="l4.436" class="difflineplus">+  endBody() {</span>
<a href="#l4.437"></a><span id="l4.437">   },</span>
<a href="#l4.438"></a><span id="l4.438"> </span>
<a href="#l4.439"></a><span id="l4.439">   // ----- Generic Write (confusing)</span>
<a href="#l4.440"></a><span id="l4.440">   // (binary data writing...)</span>
<a href="#l4.441"></a><span id="l4.441" class="difflineminus">-  write: function mime_emitter_write(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l4.442"></a><span id="l4.442" class="difflineplus">+  write(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l4.443"></a><span id="l4.443">     // we don't actually ever get called because we don't have the attachment</span>
<a href="#l4.444"></a><span id="l4.444">     //  binary payloads pass through us, but we do the following just in case</span>
<a href="#l4.445"></a><span id="l4.445">     //  we did get called (otherwise the caller gets mad and throws exceptions).</span>
<a href="#l4.446"></a><span id="l4.446">     aOutAmountWritten.value = aSize;</span>
<a href="#l4.447"></a><span id="l4.447">   },</span>
<a href="#l4.448"></a><span id="l4.448"> </span>
<a href="#l4.449"></a><span id="l4.449">   // (string writing)</span>
<a href="#l4.450"></a><span id="l4.450" class="difflineminus">-  utilityWrite: function mime_emitter_utilityWrite(aBuf) {</span>
<a href="#l4.451"></a><span id="l4.451" class="difflineplus">+  utilityWrite(aBuf) {</span>
<a href="#l4.452"></a><span id="l4.452">     this.write(aBuf, aBuf.length, {});</span>
<a href="#l4.453"></a><span id="l4.453">   },</span>
<a href="#l4.454"></a><span id="l4.454"> };</span>
<a href="#l4.455"></a><span id="l4.455"> </span>
<a href="#l4.456"></a><span id="l4.456"> var components = [MimeMessageEmitter];</span>
<a href="#l4.457"></a><span id="l4.457"> var NSGetFactory = XPCOMUtils.generateNSGetFactory(components);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/db/gloda/content/autocomplete-richlistitem.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/db/gloda/content/autocomplete-richlistitem.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -1,16 +1,20 @@</span>
<a href="#l5.4"></a><span id="l5.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l5.5"></a><span id="l5.5">   * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l5.6"></a><span id="l5.6">   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l5.7"></a><span id="l5.7"> </span>
<a href="#l5.8"></a><span id="l5.8"> &quot;use strict&quot;;</span>
<a href="#l5.9"></a><span id="l5.9"> </span>
<a href="#l5.10"></a><span id="l5.10"> /* global MozXULElement, MozElements */</span>
<a href="#l5.11"></a><span id="l5.11"> {</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+  let {Services} = ChromeUtils.import(&quot;resource://gre/modules/Services.jsm&quot;);</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+  let {StringBundle} = ChromeUtils.import(&quot;resource:///modules/StringBundle.js&quot;);</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+  let gGlodaCompleteStrings = new StringBundle(&quot;chrome://messenger/locale/glodaComplete.properties&quot;);</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+</span>
<a href="#l5.16"></a><span id="l5.16">   /**</span>
<a href="#l5.17"></a><span id="l5.17">    * The MozGlodacompleteBaseRichlistitem widget is the</span>
<a href="#l5.18"></a><span id="l5.18">    * abstract base class for all the gloda autocomplete items.</span>
<a href="#l5.19"></a><span id="l5.19">    *</span>
<a href="#l5.20"></a><span id="l5.20">    * @abstract</span>
<a href="#l5.21"></a><span id="l5.21">    * @extends {MozElements.MozRichlistitem}</span>
<a href="#l5.22"></a><span id="l5.22">    */</span>
<a href="#l5.23"></a><span id="l5.23">   class MozGlodacompleteBaseRichlistitem extends MozElements.MozRichlistitem {</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineat">@@ -47,17 +51,17 @@</span>
<a href="#l5.25"></a><span id="l5.25">         while ((matchIndex = lowerText.indexOf(search, startIndex)) &gt;= 0) {</span>
<a href="#l5.26"></a><span id="l5.26">           // Start the next search from where this one finished.</span>
<a href="#l5.27"></a><span id="l5.27">           startIndex = matchIndex + searchLen;</span>
<a href="#l5.28"></a><span id="l5.28">           regions.push([matchIndex, startIndex]);</span>
<a href="#l5.29"></a><span id="l5.29">         }</span>
<a href="#l5.30"></a><span id="l5.30">       }</span>
<a href="#l5.31"></a><span id="l5.31"> </span>
<a href="#l5.32"></a><span id="l5.32">       // Sort the regions by start position then end position.</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineminus">-      regions = regions.sort(function (a, b) {</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+      regions = regions.sort(function(a, b) {</span>
<a href="#l5.35"></a><span id="l5.35">         let start = a[0] - b[0];</span>
<a href="#l5.36"></a><span id="l5.36">         return (start == 0) ? a[1] - b[1] : start;</span>
<a href="#l5.37"></a><span id="l5.37">       });</span>
<a href="#l5.38"></a><span id="l5.38"> </span>
<a href="#l5.39"></a><span id="l5.39">       // Generate the boundary indices from each region.</span>
<a href="#l5.40"></a><span id="l5.40">       let start = 0;</span>
<a href="#l5.41"></a><span id="l5.41">       let end = 0;</span>
<a href="#l5.42"></a><span id="l5.42">       let boundaries = [];</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/db/gloda/content/glodacomplete.xml</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/db/gloda/content/glodacomplete.xml</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -17,37 +17,31 @@</span>
<a href="#l6.4"></a><span id="l6.4">           &lt;![CDATA[</span>
<a href="#l6.5"></a><span id="l6.5">           var controller = this.mInput.controller;</span>
<a href="#l6.6"></a><span id="l6.6"> </span>
<a href="#l6.7"></a><span id="l6.7">           // Process maxRows per chunk to improve performance and user experience</span>
<a href="#l6.8"></a><span id="l6.8">           for (let i = 0; i &lt; this.maxRows; i++) {</span>
<a href="#l6.9"></a><span id="l6.9">             if (this._currentIndex &gt;= this.matchCount)</span>
<a href="#l6.10"></a><span id="l6.10">               return;</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-            var existingItemsCount = this.richlistbox.childNodes.length;</span>
<a href="#l6.13"></a><span id="l6.13">             var item;</span>
<a href="#l6.14"></a><span id="l6.14"> </span>
<a href="#l6.15"></a><span id="l6.15">             // trim the leading/trailing whitespace</span>
<a href="#l6.16"></a><span id="l6.16">             var trimmedSearchString = controller.searchString.trim();</span>
<a href="#l6.17"></a><span id="l6.17"> </span>
<a href="#l6.18"></a><span id="l6.18" class="difflineminus">-            // Unescape the URI spec for showing as an entry in the popup</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineminus">-            let url = Services.textToSubURI</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineminus">-                              .unEscapeURIForUI(&quot;UTF-8&quot;, controller.getValueAt(this._currentIndex));</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineminus">-</span>
<a href="#l6.22"></a><span id="l6.22">             let glodaCompleter = Cc[&quot;@mozilla.org/autocomplete/search;1?name=gloda&quot;]</span>
<a href="#l6.23"></a><span id="l6.23">                                    .getService(Ci.nsIAutoCompleteSearch)</span>
<a href="#l6.24"></a><span id="l6.24">                                    .wrappedJSObject;</span>
<a href="#l6.25"></a><span id="l6.25">             var result = glodaCompleter.curResult;</span>
<a href="#l6.26"></a><span id="l6.26"> </span>
<a href="#l6.27"></a><span id="l6.27">             item = document.createElement(&quot;richlistitem&quot;, { is: result.getStyleAt(this._currentIndex) });</span>
<a href="#l6.28"></a><span id="l6.28"> </span>
<a href="#l6.29"></a><span id="l6.29">             // set these attributes before we set the class</span>
<a href="#l6.30"></a><span id="l6.30">             // so that we can use them from the constructor</span>
<a href="#l6.31"></a><span id="l6.31">             var row = result.getObjectAt(this._currentIndex);</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineminus">-            var obj = row.item;</span>
<a href="#l6.33"></a><span id="l6.33">             item.setAttribute(&quot;text&quot;, trimmedSearchString);</span>
<a href="#l6.34"></a><span id="l6.34">             item.setAttribute(&quot;type&quot;, result.getStyleAt(this._currentIndex));</span>
<a href="#l6.35"></a><span id="l6.35"> </span>
<a href="#l6.36"></a><span id="l6.36">             item.row = row;</span>
<a href="#l6.37"></a><span id="l6.37"> </span>
<a href="#l6.38"></a><span id="l6.38">             // set the class at the end so we can use the attributes</span>
<a href="#l6.39"></a><span id="l6.39">             // in the xbl constructor</span>
<a href="#l6.40"></a><span id="l6.40">             item.className = &quot;autocomplete-richlistitem&quot;;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/db/gloda/modules/collection.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/collection.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -1,13 +1,13 @@</span>
<a href="#l7.4"></a><span id="l7.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l7.5"></a><span id="l7.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l7.6"></a><span id="l7.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l7.7"></a><span id="l7.7"> </span>
<a href="#l7.8"></a><span id="l7.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['GlodaCollection', 'GlodaCollectionManager'];</span>
<a href="#l7.9"></a><span id="l7.9" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;GlodaCollection&quot;, &quot;GlodaCollectionManager&quot;];</span>
<a href="#l7.10"></a><span id="l7.10"> </span>
<a href="#l7.11"></a><span id="l7.11"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l7.12"></a><span id="l7.12"> </span>
<a href="#l7.13"></a><span id="l7.13"> var LOG = Log4Moz.repository.getLogger(&quot;gloda.collection&quot;);</span>
<a href="#l7.14"></a><span id="l7.14"> </span>
<a href="#l7.15"></a><span id="l7.15"> /**</span>
<a href="#l7.16"></a><span id="l7.16">  * @namespace Central registry and logic for all collections.</span>
<a href="#l7.17"></a><span id="l7.17">  *</span>
<a href="#l7.18"></a><span id="l7.18" class="difflineat">@@ -26,57 +26,56 @@ var GlodaCollectionManager = {</span>
<a href="#l7.19"></a><span id="l7.19">   _collectionsByNoun: {},</span>
<a href="#l7.20"></a><span id="l7.20">   _cachesByNoun: {},</span>
<a href="#l7.21"></a><span id="l7.21"> </span>
<a href="#l7.22"></a><span id="l7.22">   /**</span>
<a href="#l7.23"></a><span id="l7.23">    * Registers the existence of a collection with the collection manager.  This</span>
<a href="#l7.24"></a><span id="l7.24">    *  is done using a weak reference so that the collection can go away if it</span>
<a href="#l7.25"></a><span id="l7.25">    *  wants to.</span>
<a href="#l7.26"></a><span id="l7.26">    */</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineminus">-  registerCollection: function gloda_colm_registerCollection(aCollection) {</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineplus">+  registerCollection(aCollection) {</span>
<a href="#l7.29"></a><span id="l7.29">     let collections;</span>
<a href="#l7.30"></a><span id="l7.30">     let nounID = aCollection.query._nounDef.id;</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-    if (!(nounID in this._collectionsByNoun))</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+    if (!(nounID in this._collectionsByNoun)) {</span>
<a href="#l7.33"></a><span id="l7.33">       collections = this._collectionsByNoun[nounID] = [];</span>
<a href="#l7.34"></a><span id="l7.34" class="difflineminus">-    else {</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineplus">+    } else {</span>
<a href="#l7.36"></a><span id="l7.36">       // purge dead weak references while we're at it</span>
<a href="#l7.37"></a><span id="l7.37" class="difflineminus">-      collections = this._collectionsByNoun[nounID].filter(function (aRef) {</span>
<a href="#l7.38"></a><span id="l7.38" class="difflineminus">-        return aRef.get(); });</span>
<a href="#l7.39"></a><span id="l7.39" class="difflineplus">+      collections = this._collectionsByNoun[nounID].filter((aRef) =&gt; aRef.get());</span>
<a href="#l7.40"></a><span id="l7.40">       this._collectionsByNoun[nounID] = collections;</span>
<a href="#l7.41"></a><span id="l7.41">     }</span>
<a href="#l7.42"></a><span id="l7.42">     collections.push(Cu.getWeakReference(aCollection));</span>
<a href="#l7.43"></a><span id="l7.43">   },</span>
<a href="#l7.44"></a><span id="l7.44"> </span>
<a href="#l7.45"></a><span id="l7.45" class="difflineminus">-  getCollectionsForNounID: function gloda_colm_getCollectionsForNounID(aNounID){</span>
<a href="#l7.46"></a><span id="l7.46" class="difflineplus">+  getCollectionsForNounID(aNounID) {</span>
<a href="#l7.47"></a><span id="l7.47">     if (!(aNounID in this._collectionsByNoun))</span>
<a href="#l7.48"></a><span id="l7.48">       return [];</span>
<a href="#l7.49"></a><span id="l7.49"> </span>
<a href="#l7.50"></a><span id="l7.50">     // generator would be nice, but I suspect get() is too expensive to use</span>
<a href="#l7.51"></a><span id="l7.51">     //  twice (guard/predicate and value)</span>
<a href="#l7.52"></a><span id="l7.52">     let weakCollections = this._collectionsByNoun[aNounID];</span>
<a href="#l7.53"></a><span id="l7.53">     let collections = [];</span>
<a href="#l7.54"></a><span id="l7.54">     for (let iColl = 0; iColl &lt; weakCollections.length; iColl++) {</span>
<a href="#l7.55"></a><span id="l7.55">       let collection = weakCollections[iColl].get();</span>
<a href="#l7.56"></a><span id="l7.56">       if (collection)</span>
<a href="#l7.57"></a><span id="l7.57">         collections.push(collection);</span>
<a href="#l7.58"></a><span id="l7.58">     }</span>
<a href="#l7.59"></a><span id="l7.59">     return collections;</span>
<a href="#l7.60"></a><span id="l7.60">   },</span>
<a href="#l7.61"></a><span id="l7.61"> </span>
<a href="#l7.62"></a><span id="l7.62" class="difflineminus">-  defineCache: function gloda_colm_defineCache(aNounDef, aCacheSize) {</span>
<a href="#l7.63"></a><span id="l7.63" class="difflineplus">+  defineCache(aNounDef, aCacheSize) {</span>
<a href="#l7.64"></a><span id="l7.64">     this._cachesByNoun[aNounDef.id] = new GlodaLRUCacheCollection(aNounDef,</span>
<a href="#l7.65"></a><span id="l7.65">                                                                    aCacheSize);</span>
<a href="#l7.66"></a><span id="l7.66">   },</span>
<a href="#l7.67"></a><span id="l7.67"> </span>
<a href="#l7.68"></a><span id="l7.68">   /**</span>
<a href="#l7.69"></a><span id="l7.69">    * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l7.70"></a><span id="l7.70">    *  given id.  Counts as a cache hit if found.  (And if it wasn't in a cache,</span>
<a href="#l7.71"></a><span id="l7.71">    *  but rather a collection, it is added to the cache.)</span>
<a href="#l7.72"></a><span id="l7.72">    */</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineminus">-  cacheLookupOne: function gloda_colm_cacheLookupOne(aNounID, aID, aDoCache) {</span>
<a href="#l7.74"></a><span id="l7.74" class="difflineplus">+  cacheLookupOne(aNounID, aID, aDoCache) {</span>
<a href="#l7.75"></a><span id="l7.75">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l7.76"></a><span id="l7.76"> </span>
<a href="#l7.77"></a><span id="l7.77">     if (cache) {</span>
<a href="#l7.78"></a><span id="l7.78">       if (aID in cache._idMap) {</span>
<a href="#l7.79"></a><span id="l7.79">         let item = cache._idMap[aID];</span>
<a href="#l7.80"></a><span id="l7.80">         return cache.hit(item);</span>
<a href="#l7.81"></a><span id="l7.81">       }</span>
<a href="#l7.82"></a><span id="l7.82">     }</span>
<a href="#l7.83"></a><span id="l7.83" class="difflineat">@@ -109,30 +108,28 @@ var GlodaCollectionManager = {</span>
<a href="#l7.84"></a><span id="l7.84">    *     in collections that were in memory but not in the cache?  You would</span>
<a href="#l7.85"></a><span id="l7.85">    *     likely want to pass false if you are only updating in-memory</span>
<a href="#l7.86"></a><span id="l7.86">    *     representations rather than performing a new query.</span>
<a href="#l7.87"></a><span id="l7.87">    *</span>
<a href="#l7.88"></a><span id="l7.88">    * @return [The number that were found, the number that were not found,</span>
<a href="#l7.89"></a><span id="l7.89">    *          a dictionary whose keys are the ids of noun instances that</span>
<a href="#l7.90"></a><span id="l7.90">    *          were not found.]</span>
<a href="#l7.91"></a><span id="l7.91">    */</span>
<a href="#l7.92"></a><span id="l7.92" class="difflineminus">-  cacheLookupMany: function gloda_colm_cacheLookupMany(aNounID, aIDMap,</span>
<a href="#l7.93"></a><span id="l7.93" class="difflineminus">-      aTargetMap, aDoCache) {</span>
<a href="#l7.94"></a><span id="l7.94" class="difflineplus">+  cacheLookupMany(aNounID, aIDMap, aTargetMap, aDoCache) {</span>
<a href="#l7.95"></a><span id="l7.95">     let foundCount = 0, notFoundCount = 0, notFound = {};</span>
<a href="#l7.96"></a><span id="l7.96"> </span>
<a href="#l7.97"></a><span id="l7.97">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l7.98"></a><span id="l7.98"> </span>
<a href="#l7.99"></a><span id="l7.99">     if (cache) {</span>
<a href="#l7.100"></a><span id="l7.100">       for (let key in aIDMap) {</span>
<a href="#l7.101"></a><span id="l7.101">         let cacheValue = cache._idMap[key];</span>
<a href="#l7.102"></a><span id="l7.102">         if (cacheValue === undefined) {</span>
<a href="#l7.103"></a><span id="l7.103">           notFoundCount++;</span>
<a href="#l7.104"></a><span id="l7.104">           notFound[key] = null;</span>
<a href="#l7.105"></a><span id="l7.105" class="difflineminus">-        }</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineminus">-        else {</span>
<a href="#l7.107"></a><span id="l7.107" class="difflineplus">+        } else {</span>
<a href="#l7.108"></a><span id="l7.108">           foundCount++;</span>
<a href="#l7.109"></a><span id="l7.109">           aTargetMap[key] = cacheValue;</span>
<a href="#l7.110"></a><span id="l7.110">           cache.hit(cacheValue);</span>
<a href="#l7.111"></a><span id="l7.111">         }</span>
<a href="#l7.112"></a><span id="l7.112">       }</span>
<a href="#l7.113"></a><span id="l7.113">     }</span>
<a href="#l7.114"></a><span id="l7.114"> </span>
<a href="#l7.115"></a><span id="l7.115">     if (aDoCache === false)</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineat">@@ -157,34 +154,32 @@ var GlodaCollectionManager = {</span>
<a href="#l7.117"></a><span id="l7.117"> </span>
<a href="#l7.118"></a><span id="l7.118">   /**</span>
<a href="#l7.119"></a><span id="l7.119">    * Friendlier version of |cacheLookupMany|; takes a list of ids and returns</span>
<a href="#l7.120"></a><span id="l7.120">    *  an object whose keys and values are the gloda id's and instances of the</span>
<a href="#l7.121"></a><span id="l7.121">    *  instances that were found.  We don't tell you who we didn't find.  The</span>
<a href="#l7.122"></a><span id="l7.122">    *  assumption is this is being used for in-memory updates where we only need</span>
<a href="#l7.123"></a><span id="l7.123">    *  to tweak what is in memory.</span>
<a href="#l7.124"></a><span id="l7.124">    */</span>
<a href="#l7.125"></a><span id="l7.125" class="difflineminus">-  cacheLookupManyList: function gloda_colm_cacheLookupManyList(aNounID, aIds) {</span>
<a href="#l7.126"></a><span id="l7.126" class="difflineplus">+  cacheLookupManyList(aNounID, aIds) {</span>
<a href="#l7.127"></a><span id="l7.127">     let checkMap = {}, targetMap = {};</span>
<a href="#l7.128"></a><span id="l7.128">     for (let id of aIds) {</span>
<a href="#l7.129"></a><span id="l7.129">       checkMap[id] = null;</span>
<a href="#l7.130"></a><span id="l7.130">     }</span>
<a href="#l7.131"></a><span id="l7.131">     // do not promote found items into the cache</span>
<a href="#l7.132"></a><span id="l7.132">     this.cacheLookupMany(aNounID, checkMap, targetMap, false);</span>
<a href="#l7.133"></a><span id="l7.133">     return targetMap;</span>
<a href="#l7.134"></a><span id="l7.134">   },</span>
<a href="#l7.135"></a><span id="l7.135"> </span>
<a href="#l7.136"></a><span id="l7.136">   /**</span>
<a href="#l7.137"></a><span id="l7.137">    * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l7.138"></a><span id="l7.138">    *  given id.  Counts as a cache hit if found.  (And if it wasn't in a cache,</span>
<a href="#l7.139"></a><span id="l7.139">    *  but rather a collection, it is added to the cache.)</span>
<a href="#l7.140"></a><span id="l7.140">    */</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineminus">-  cacheLookupOneByUniqueValue:</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineminus">-      function gloda_colm_cacheLookupOneByUniqueValue(aNounID, aUniqueValue,</span>
<a href="#l7.143"></a><span id="l7.143" class="difflineminus">-                                                      aDoCache) {</span>
<a href="#l7.144"></a><span id="l7.144" class="difflineplus">+  cacheLookupOneByUniqueValue(aNounID, aUniqueValue, aDoCache) {</span>
<a href="#l7.145"></a><span id="l7.145">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l7.146"></a><span id="l7.146"> </span>
<a href="#l7.147"></a><span id="l7.147">     if (cache) {</span>
<a href="#l7.148"></a><span id="l7.148">       if (aUniqueValue in cache._uniqueValueMap) {</span>
<a href="#l7.149"></a><span id="l7.149">         let item = cache._uniqueValueMap[aUniqueValue];</span>
<a href="#l7.150"></a><span id="l7.150">         return cache.hit(item);</span>
<a href="#l7.151"></a><span id="l7.151">       }</span>
<a href="#l7.152"></a><span id="l7.152">     }</span>
<a href="#l7.153"></a><span id="l7.153" class="difflineat">@@ -205,31 +200,30 @@ var GlodaCollectionManager = {</span>
<a href="#l7.154"></a><span id="l7.154">   },</span>
<a href="#l7.155"></a><span id="l7.155"> </span>
<a href="#l7.156"></a><span id="l7.156">   /**</span>
<a href="#l7.157"></a><span id="l7.157">    * Checks whether the provided item with the given id is actually a duplicate</span>
<a href="#l7.158"></a><span id="l7.158">    *  of an instance that already exists in the cache/a collection.  If it is,</span>
<a href="#l7.159"></a><span id="l7.159">    *  the pre-existing instance is returned and counts as a cache hit.  If it</span>
<a href="#l7.160"></a><span id="l7.160">    *  is not, the passed-in instance is added to the cache and returned.</span>
<a href="#l7.161"></a><span id="l7.161">    */</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineminus">-  cacheLoadUnifyOne: function gloda_colm_cacheLoadUnifyOne(aItem) {</span>
<a href="#l7.163"></a><span id="l7.163" class="difflineplus">+  cacheLoadUnifyOne(aItem) {</span>
<a href="#l7.164"></a><span id="l7.164">     let items = [aItem];</span>
<a href="#l7.165"></a><span id="l7.165">     this.cacheLoadUnify(aItem.NOUN_ID, items);</span>
<a href="#l7.166"></a><span id="l7.166">     return items[0];</span>
<a href="#l7.167"></a><span id="l7.167">   },</span>
<a href="#l7.168"></a><span id="l7.168"> </span>
<a href="#l7.169"></a><span id="l7.169">   /**</span>
<a href="#l7.170"></a><span id="l7.170">    * Given a list of items, check if any of them already have duplicate,</span>
<a href="#l7.171"></a><span id="l7.171">    *  canonical, instances in the cache or collections.  Items with pre-existing</span>
<a href="#l7.172"></a><span id="l7.172">    *  instances are replaced by those instances in the provided list, and each</span>
<a href="#l7.173"></a><span id="l7.173">    *  counts as a cache hit.  Items without pre-existing instances are added</span>
<a href="#l7.174"></a><span id="l7.174">    *  to the cache and left intact.</span>
<a href="#l7.175"></a><span id="l7.175">    */</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineminus">-  cacheLoadUnify: function gloda_colm_cacheLoadUnify(aNounID, aItems,</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineminus">-      aCacheIfMissing) {</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+  cacheLoadUnify(aNounID, aItems, aCacheIfMissing) {</span>
<a href="#l7.179"></a><span id="l7.179">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l7.180"></a><span id="l7.180">     if (aCacheIfMissing === undefined)</span>
<a href="#l7.181"></a><span id="l7.181">       aCacheIfMissing = true;</span>
<a href="#l7.182"></a><span id="l7.182"> </span>
<a href="#l7.183"></a><span id="l7.183">     // track the items we haven't yet found in a cache/collection (value) and</span>
<a href="#l7.184"></a><span id="l7.184">     //  their index in aItems (key).  We're somewhat abusing the dictionary</span>
<a href="#l7.185"></a><span id="l7.185">     //  metaphor with the intent of storing tuples here.  We also do it because</span>
<a href="#l7.186"></a><span id="l7.186">     //  it allows random-access deletion theoretically without cost.  (Since</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineat">@@ -242,28 +236,26 @@ var GlodaCollectionManager = {</span>
<a href="#l7.188"></a><span id="l7.188">       for (let iItem = 0; iItem &lt; aItems.length; iItem++) {</span>
<a href="#l7.189"></a><span id="l7.189">         let item = aItems[iItem];</span>
<a href="#l7.190"></a><span id="l7.190"> </span>
<a href="#l7.191"></a><span id="l7.191">         if (item.id in cache._idMap) {</span>
<a href="#l7.192"></a><span id="l7.192">           let realItem = cache._idMap[item.id];</span>
<a href="#l7.193"></a><span id="l7.193">           // update the caller's array with the reference to the 'real' item</span>
<a href="#l7.194"></a><span id="l7.194">           aItems[iItem] = realItem;</span>
<a href="#l7.195"></a><span id="l7.195">           cache.hit(realItem);</span>
<a href="#l7.196"></a><span id="l7.196" class="difflineminus">-        }</span>
<a href="#l7.197"></a><span id="l7.197" class="difflineminus">-        else {</span>
<a href="#l7.198"></a><span id="l7.198" class="difflineplus">+        } else {</span>
<a href="#l7.199"></a><span id="l7.199">           unresolvedIndexToItem[iItem] = item;</span>
<a href="#l7.200"></a><span id="l7.200">           numUnresolved++;</span>
<a href="#l7.201"></a><span id="l7.201">         }</span>
<a href="#l7.202"></a><span id="l7.202">       }</span>
<a href="#l7.203"></a><span id="l7.203"> </span>
<a href="#l7.204"></a><span id="l7.204">       // we're done if everyone was a hit.</span>
<a href="#l7.205"></a><span id="l7.205">       if (numUnresolved == 0)</span>
<a href="#l7.206"></a><span id="l7.206">         return;</span>
<a href="#l7.207"></a><span id="l7.207" class="difflineminus">-    }</span>
<a href="#l7.208"></a><span id="l7.208" class="difflineminus">-    else {</span>
<a href="#l7.209"></a><span id="l7.209" class="difflineplus">+    } else {</span>
<a href="#l7.210"></a><span id="l7.210">       for (let iItem = 0; iItem &lt; aItems.length; iItem++) {</span>
<a href="#l7.211"></a><span id="l7.211">         unresolvedIndexToItem[iItem] = aItems[iItem];</span>
<a href="#l7.212"></a><span id="l7.212">       }</span>
<a href="#l7.213"></a><span id="l7.213">       numUnresolved = aItems.length;</span>
<a href="#l7.214"></a><span id="l7.214">     }</span>
<a href="#l7.215"></a><span id="l7.215"> </span>
<a href="#l7.216"></a><span id="l7.216">     let needToCache = [];</span>
<a href="#l7.217"></a><span id="l7.217">     // next, let's fall back to our collections</span>
<a href="#l7.218"></a><span id="l7.218" class="difflineat">@@ -285,57 +277,55 @@ var GlodaCollectionManager = {</span>
<a href="#l7.219"></a><span id="l7.219">     }</span>
<a href="#l7.220"></a><span id="l7.220"> </span>
<a href="#l7.221"></a><span id="l7.221">     // anything left in unresolvedIndexToItem should be added to the cache</span>
<a href="#l7.222"></a><span id="l7.222">     //  unless !aCacheIfMissing.  plus, we already have 'needToCache'</span>
<a href="#l7.223"></a><span id="l7.223">     if (cache &amp;&amp; aCacheIfMissing) {</span>
<a href="#l7.224"></a><span id="l7.224">       cache.add(needToCache.concat(Object.keys(unresolvedIndexToItem).</span>
<a href="#l7.225"></a><span id="l7.225">                                    map(key =&gt; unresolvedIndexToItem[key])));</span>
<a href="#l7.226"></a><span id="l7.226">     }</span>
<a href="#l7.227"></a><span id="l7.227" class="difflineminus">-</span>
<a href="#l7.228"></a><span id="l7.228" class="difflineminus">-    return aItems;</span>
<a href="#l7.229"></a><span id="l7.229">   },</span>
<a href="#l7.230"></a><span id="l7.230"> </span>
<a href="#l7.231"></a><span id="l7.231" class="difflineminus">-  cacheCommitDirty: function glod_colm_cacheCommitDirty() {</span>
<a href="#l7.232"></a><span id="l7.232" class="difflineplus">+  cacheCommitDirty() {</span>
<a href="#l7.233"></a><span id="l7.233">     for (let id in this._cachesByNoun) {</span>
<a href="#l7.234"></a><span id="l7.234">       let cache = this._cachesByNoun[id];</span>
<a href="#l7.235"></a><span id="l7.235">       cache.commitDirty();</span>
<a href="#l7.236"></a><span id="l7.236">     }</span>
<a href="#l7.237"></a><span id="l7.237">   },</span>
<a href="#l7.238"></a><span id="l7.238"> </span>
<a href="#l7.239"></a><span id="l7.239">   /**</span>
<a href="#l7.240"></a><span id="l7.240">    * Notifies the collection manager that an item has been loaded and should</span>
<a href="#l7.241"></a><span id="l7.241">    *  be cached, assuming caching is active.</span>
<a href="#l7.242"></a><span id="l7.242">    */</span>
<a href="#l7.243"></a><span id="l7.243" class="difflineminus">-  itemLoaded: function gloda_colm_itemsLoaded(aItem) {</span>
<a href="#l7.244"></a><span id="l7.244" class="difflineplus">+  itemLoaded(aItem) {</span>
<a href="#l7.245"></a><span id="l7.245">     let cache = this._cachesByNoun[aItem.NOUN_ID];</span>
<a href="#l7.246"></a><span id="l7.246">     if (cache) {</span>
<a href="#l7.247"></a><span id="l7.247">       cache.add([aItem]);</span>
<a href="#l7.248"></a><span id="l7.248">     }</span>
<a href="#l7.249"></a><span id="l7.249">   },</span>
<a href="#l7.250"></a><span id="l7.250"> </span>
<a href="#l7.251"></a><span id="l7.251">   /**</span>
<a href="#l7.252"></a><span id="l7.252">    * Notifies the collection manager that multiple items has been loaded and</span>
<a href="#l7.253"></a><span id="l7.253">    *  should be cached, assuming caching is active.</span>
<a href="#l7.254"></a><span id="l7.254">    */</span>
<a href="#l7.255"></a><span id="l7.255" class="difflineminus">-  itemsLoaded: function gloda_colm_itemsLoaded(aNounID, aItems) {</span>
<a href="#l7.256"></a><span id="l7.256" class="difflineplus">+  itemsLoaded(aNounID, aItems) {</span>
<a href="#l7.257"></a><span id="l7.257">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l7.258"></a><span id="l7.258">     if (cache) {</span>
<a href="#l7.259"></a><span id="l7.259">       cache.add(aItems);</span>
<a href="#l7.260"></a><span id="l7.260">     }</span>
<a href="#l7.261"></a><span id="l7.261">   },</span>
<a href="#l7.262"></a><span id="l7.262"> </span>
<a href="#l7.263"></a><span id="l7.263">   /**</span>
<a href="#l7.264"></a><span id="l7.264">    * This should be called when items are added to the global database.  This</span>
<a href="#l7.265"></a><span id="l7.265">    *  should generally mean during indexing by indexers or an attribute</span>
<a href="#l7.266"></a><span id="l7.266">    *  provider.</span>
<a href="#l7.267"></a><span id="l7.267">    * We walk all existing collections for the given noun type and add the items</span>
<a href="#l7.268"></a><span id="l7.268">    *  to the collection if the item meets the query that defines the collection.</span>
<a href="#l7.269"></a><span id="l7.269">    */</span>
<a href="#l7.270"></a><span id="l7.270" class="difflineminus">-  itemsAdded: function gloda_colm_itemsAdded(aNounID, aItems) {</span>
<a href="#l7.271"></a><span id="l7.271" class="difflineplus">+  itemsAdded(aNounID, aItems) {</span>
<a href="#l7.272"></a><span id="l7.272">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l7.273"></a><span id="l7.273">     if (cache) {</span>
<a href="#l7.274"></a><span id="l7.274">       cache.add(aItems);</span>
<a href="#l7.275"></a><span id="l7.275">     }</span>
<a href="#l7.276"></a><span id="l7.276"> </span>
<a href="#l7.277"></a><span id="l7.277">     for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l7.278"></a><span id="l7.278">       let addItems = aItems.filter(item =&gt; collection.query.test(item));</span>
<a href="#l7.279"></a><span id="l7.279">       if (addItems.length)</span>
<a href="#l7.280"></a><span id="l7.280" class="difflineat">@@ -348,33 +338,34 @@ var GlodaCollectionManager = {</span>
<a href="#l7.281"></a><span id="l7.281">    *  by indexers or by attribute providers.</span>
<a href="#l7.282"></a><span id="l7.282">    * We walk all existing collections for the given noun type.  For items</span>
<a href="#l7.283"></a><span id="l7.283">    *  currently included in each collection but should no longer be (per the</span>
<a href="#l7.284"></a><span id="l7.284">    *  collection's defining query) we generate onItemsRemoved events.  For items</span>
<a href="#l7.285"></a><span id="l7.285">    *  not currently included in the collection but should now be, we generate</span>
<a href="#l7.286"></a><span id="l7.286">    *  onItemsAdded events.  For items included that still match the query, we</span>
<a href="#l7.287"></a><span id="l7.287">    *  generate onItemsModified events.</span>
<a href="#l7.288"></a><span id="l7.288">    */</span>
<a href="#l7.289"></a><span id="l7.289" class="difflineminus">-  itemsModified: function gloda_colm_itemsModified(aNounID, aItems) {</span>
<a href="#l7.290"></a><span id="l7.290" class="difflineplus">+  itemsModified(aNounID, aItems) {</span>
<a href="#l7.291"></a><span id="l7.291">     for (let collection of this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l7.292"></a><span id="l7.292">       let added = [], modified = [], removed = [];</span>
<a href="#l7.293"></a><span id="l7.293">       for (let item of aItems) {</span>
<a href="#l7.294"></a><span id="l7.294">         if (item.id in collection._idMap) {</span>
<a href="#l7.295"></a><span id="l7.295">           // currently in... but should it still be there?</span>
<a href="#l7.296"></a><span id="l7.296" class="difflineminus">-          if (collection.query.test(item))</span>
<a href="#l7.297"></a><span id="l7.297" class="difflineplus">+          if (collection.query.test(item)) {</span>
<a href="#l7.298"></a><span id="l7.298">             modified.push(item); // yes, keep it</span>
<a href="#l7.299"></a><span id="l7.299" class="difflineminus">-          // oy, so null queries really don't want any notifications, and they</span>
<a href="#l7.300"></a><span id="l7.300" class="difflineminus">-          //  sorta fit into our existing model, except for the removal bit.</span>
<a href="#l7.301"></a><span id="l7.301" class="difflineminus">-          //  so we need a specialized check for them, and we're using the</span>
<a href="#l7.302"></a><span id="l7.302" class="difflineminus">-          //  frozen attribute to this end.</span>
<a href="#l7.303"></a><span id="l7.303" class="difflineminus">-          else if (!collection.query.frozen)</span>
<a href="#l7.304"></a><span id="l7.304" class="difflineplus">+          } else if (!collection.query.frozen) {</span>
<a href="#l7.305"></a><span id="l7.305" class="difflineplus">+            // oy, so null queries really don't want any notifications, and they</span>
<a href="#l7.306"></a><span id="l7.306" class="difflineplus">+            //  sorta fit into our existing model, except for the removal bit.</span>
<a href="#l7.307"></a><span id="l7.307" class="difflineplus">+            //  so we need a specialized check for them, and we're using the</span>
<a href="#l7.308"></a><span id="l7.308" class="difflineplus">+            //  frozen attribute to this end.</span>
<a href="#l7.309"></a><span id="l7.309">             removed.push(item); // no, bin it</span>
<a href="#l7.310"></a><span id="l7.310" class="difflineplus">+          }</span>
<a href="#l7.311"></a><span id="l7.311" class="difflineplus">+        } else if (collection.query.test(item)) { // not in, should it be?</span>
<a href="#l7.312"></a><span id="l7.312" class="difflineplus">+          added.push(item); // yep, add it</span>
<a href="#l7.313"></a><span id="l7.313">         }</span>
<a href="#l7.314"></a><span id="l7.314" class="difflineminus">-        else if (collection.query.test(item)) // not in, should it be?</span>
<a href="#l7.315"></a><span id="l7.315" class="difflineminus">-          added.push(item); // yep, add it</span>
<a href="#l7.316"></a><span id="l7.316">       }</span>
<a href="#l7.317"></a><span id="l7.317">       if (added.length)</span>
<a href="#l7.318"></a><span id="l7.318">         collection._onItemsAdded(added);</span>
<a href="#l7.319"></a><span id="l7.319">       if (modified.length)</span>
<a href="#l7.320"></a><span id="l7.320">         collection._onItemsModified(modified);</span>
<a href="#l7.321"></a><span id="l7.321">       if (removed.length)</span>
<a href="#l7.322"></a><span id="l7.322">         collection._onItemsRemoved(removed);</span>
<a href="#l7.323"></a><span id="l7.323">     }</span>
<a href="#l7.324"></a><span id="l7.324" class="difflineat">@@ -385,17 +376,17 @@ var GlodaCollectionManager = {</span>
<a href="#l7.325"></a><span id="l7.325">    *  involved trash folders or other modified forms of existence.  Deleted</span>
<a href="#l7.326"></a><span id="l7.326">    *  means the data is gone and if it were to come back, it would come back</span>
<a href="#l7.327"></a><span id="l7.327">    *  via an itemsAdded event.)</span>
<a href="#l7.328"></a><span id="l7.328">    * We walk all existing collections for the given noun type.  For items</span>
<a href="#l7.329"></a><span id="l7.329">    *  currently in the collection, we generate onItemsRemoved events.</span>
<a href="#l7.330"></a><span id="l7.330">    *</span>
<a href="#l7.331"></a><span id="l7.331">    * @param aItemIds A list of item ids that are being deleted.</span>
<a href="#l7.332"></a><span id="l7.332">    */</span>
<a href="#l7.333"></a><span id="l7.333" class="difflineminus">-  itemsDeleted: function gloda_colm_itemsDeleted(aNounID, aItemIds) {</span>
<a href="#l7.334"></a><span id="l7.334" class="difflineplus">+  itemsDeleted(aNounID, aItemIds) {</span>
<a href="#l7.335"></a><span id="l7.335">     // cache</span>
<a href="#l7.336"></a><span id="l7.336">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l7.337"></a><span id="l7.337">     if (cache) {</span>
<a href="#l7.338"></a><span id="l7.338">       for (let itemId of aItemIds) {</span>
<a href="#l7.339"></a><span id="l7.339">         if (itemId in cache._idMap)</span>
<a href="#l7.340"></a><span id="l7.340">           cache.deleted(cache._idMap[itemId]);</span>
<a href="#l7.341"></a><span id="l7.341">       }</span>
<a href="#l7.342"></a><span id="l7.342">     }</span>
<a href="#l7.343"></a><span id="l7.343" class="difflineat">@@ -420,18 +411,17 @@ var GlodaCollectionManager = {</span>
<a href="#l7.344"></a><span id="l7.344">    *  not going to happen all that frequently.  If these assumptions are wrong,</span>
<a href="#l7.345"></a><span id="l7.345">    *  callers are advised to re-think the whole situation.</span>
<a href="#l7.346"></a><span id="l7.346">    *</span>
<a href="#l7.347"></a><span id="l7.347">    * @param aNounID Type of noun we are talking about here.</span>
<a href="#l7.348"></a><span id="l7.348">    * @param aFilter A filter function that returns true when the item should be</span>
<a href="#l7.349"></a><span id="l7.349">    *     thought of as deleted, or false if the item is still good.  Screw this</span>
<a href="#l7.350"></a><span id="l7.350">    *     up and you will get some seriously wacky bugs, yo.</span>
<a href="#l7.351"></a><span id="l7.351">    */</span>
<a href="#l7.352"></a><span id="l7.352" class="difflineminus">-  itemsDeletedByAttribute: function gloda_colm_itemsDeletedByAttribute(</span>
<a href="#l7.353"></a><span id="l7.353" class="difflineminus">-      aNounID, aFilter) {</span>
<a href="#l7.354"></a><span id="l7.354" class="difflineplus">+  itemsDeletedByAttribute(aNounID, aFilter) {</span>
<a href="#l7.355"></a><span id="l7.355">     // cache</span>
<a href="#l7.356"></a><span id="l7.356">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l7.357"></a><span id="l7.357">     if (cache) {</span>
<a href="#l7.358"></a><span id="l7.358">       for (let id in cache._idMap) {</span>
<a href="#l7.359"></a><span id="l7.359">         let item = cache._idMap[id];</span>
<a href="#l7.360"></a><span id="l7.360">         if (aFilter(item))</span>
<a href="#l7.361"></a><span id="l7.361">           cache.deleted(item);</span>
<a href="#l7.362"></a><span id="l7.362">       }</span>
<a href="#l7.363"></a><span id="l7.363" class="difflineat">@@ -485,18 +475,17 @@ function GlodaCollection(aNounDef, aItem</span>
<a href="#l7.364"></a><span id="l7.364">   }</span>
<a href="#l7.365"></a><span id="l7.365">   this._listener = aListener || null;</span>
<a href="#l7.366"></a><span id="l7.366"> </span>
<a href="#l7.367"></a><span id="l7.367">   this.deferredCount = 0;</span>
<a href="#l7.368"></a><span id="l7.368">   this.resolvedCount = 0;</span>
<a href="#l7.369"></a><span id="l7.369"> </span>
<a href="#l7.370"></a><span id="l7.370">   if (aMasterCollection) {</span>
<a href="#l7.371"></a><span id="l7.371">     this.masterCollection = aMasterCollection.masterCollection;</span>
<a href="#l7.372"></a><span id="l7.372" class="difflineminus">-  }</span>
<a href="#l7.373"></a><span id="l7.373" class="difflineminus">-  else {</span>
<a href="#l7.374"></a><span id="l7.374" class="difflineplus">+  } else {</span>
<a href="#l7.375"></a><span id="l7.375">     this.masterCollection = this;</span>
<a href="#l7.376"></a><span id="l7.376">     /** a dictionary of dictionaries. at the top level, the keys are noun IDs.</span>
<a href="#l7.377"></a><span id="l7.377">      * each of these sub-dictionaries maps the IDs of desired noun instances to</span>
<a href="#l7.378"></a><span id="l7.378">      * the actual instance, or null if it has not yet been loaded.</span>
<a href="#l7.379"></a><span id="l7.379">      */</span>
<a href="#l7.380"></a><span id="l7.380">     this.referencesByNounID = {};</span>
<a href="#l7.381"></a><span id="l7.381">     /**</span>
<a href="#l7.382"></a><span id="l7.382">      * a dictionary of dictionaries. at the top level, the keys are noun IDs.</span>
<a href="#l7.383"></a><span id="l7.383" class="difflineat">@@ -522,114 +511,110 @@ GlodaCollection.prototype = {</span>
<a href="#l7.384"></a><span id="l7.384">    *  and replace it with an 'explicit query'.  This means that the Collection</span>
<a href="#l7.385"></a><span id="l7.385">    *  Manager will not attempt to match new items indexed to the system against</span>
<a href="#l7.386"></a><span id="l7.386">    *  our query criteria.</span>
<a href="#l7.387"></a><span id="l7.387">    * Once you call this method, your collection's listener will no longer</span>
<a href="#l7.388"></a><span id="l7.388">    *  receive onItemsAdded notifications that are not the result of your</span>
<a href="#l7.389"></a><span id="l7.389">    *  initial database query.  It will, however, receive onItemsModified</span>
<a href="#l7.390"></a><span id="l7.390">    *  notifications if items in the collection are re-indexed.</span>
<a href="#l7.391"></a><span id="l7.391">    */</span>
<a href="#l7.392"></a><span id="l7.392" class="difflineminus">-  becomeExplicit: function gloda_coll_becomeExplicit() {</span>
<a href="#l7.393"></a><span id="l7.393" class="difflineplus">+  becomeExplicit() {</span>
<a href="#l7.394"></a><span id="l7.394">     if (!(this.query instanceof this._nounDef.explicitQueryClass)) {</span>
<a href="#l7.395"></a><span id="l7.395">       this.query = new this._nounDef.explicitQueryClass(this);</span>
<a href="#l7.396"></a><span id="l7.396">     }</span>
<a href="#l7.397"></a><span id="l7.397">   },</span>
<a href="#l7.398"></a><span id="l7.398"> </span>
<a href="#l7.399"></a><span id="l7.399">   /**</span>
<a href="#l7.400"></a><span id="l7.400">    * Clear the contents of this collection.  This only makes sense for explicit</span>
<a href="#l7.401"></a><span id="l7.401">    *  collections or wildcard collections.  (Actual query-based collections</span>
<a href="#l7.402"></a><span id="l7.402">    *  should represent the state of the query, so unless we're going to delete</span>
<a href="#l7.403"></a><span id="l7.403">    *  all the items, clearing the collection would violate that constraint.)</span>
<a href="#l7.404"></a><span id="l7.404">    */</span>
<a href="#l7.405"></a><span id="l7.405" class="difflineminus">-  clear: function gloda_coll_clear() {</span>
<a href="#l7.406"></a><span id="l7.406" class="difflineplus">+  clear() {</span>
<a href="#l7.407"></a><span id="l7.407">     this._idMap = {};</span>
<a href="#l7.408"></a><span id="l7.408">     if (this._uniqueValueMap)</span>
<a href="#l7.409"></a><span id="l7.409">       this._uniqueValueMap = {};</span>
<a href="#l7.410"></a><span id="l7.410">     this.items = [];</span>
<a href="#l7.411"></a><span id="l7.411">   },</span>
<a href="#l7.412"></a><span id="l7.412"> </span>
<a href="#l7.413"></a><span id="l7.413" class="difflineminus">-  _onItemsAdded: function gloda_coll_onItemsAdded(aItems) {</span>
<a href="#l7.414"></a><span id="l7.414" class="difflineplus">+  _onItemsAdded(aItems) {</span>
<a href="#l7.415"></a><span id="l7.415">     this.items.push.apply(this.items, aItems);</span>
<a href="#l7.416"></a><span id="l7.416">     if (this._uniqueValueMap) {</span>
<a href="#l7.417"></a><span id="l7.417">       for (let item of this.items) {</span>
<a href="#l7.418"></a><span id="l7.418">         this._idMap[item.id] = item;</span>
<a href="#l7.419"></a><span id="l7.419">         this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l7.420"></a><span id="l7.420">       }</span>
<a href="#l7.421"></a><span id="l7.421" class="difflineminus">-    }</span>
<a href="#l7.422"></a><span id="l7.422" class="difflineminus">-    else {</span>
<a href="#l7.423"></a><span id="l7.423" class="difflineplus">+    } else {</span>
<a href="#l7.424"></a><span id="l7.424">       for (let item of this.items) {</span>
<a href="#l7.425"></a><span id="l7.425">         this._idMap[item.id] = item;</span>
<a href="#l7.426"></a><span id="l7.426">       }</span>
<a href="#l7.427"></a><span id="l7.427">     }</span>
<a href="#l7.428"></a><span id="l7.428">     if (this._listener) {</span>
<a href="#l7.429"></a><span id="l7.429">       try {</span>
<a href="#l7.430"></a><span id="l7.430">         this._listener.onItemsAdded(aItems, this);</span>
<a href="#l7.431"></a><span id="l7.431" class="difflineminus">-      }</span>
<a href="#l7.432"></a><span id="l7.432" class="difflineminus">-      catch (ex) {</span>
<a href="#l7.433"></a><span id="l7.433" class="difflineplus">+      } catch (ex) {</span>
<a href="#l7.434"></a><span id="l7.434">         LOG.error(&quot;caught exception from listener in onItemsAdded: &quot; +</span>
<a href="#l7.435"></a><span id="l7.435">             ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l7.436"></a><span id="l7.436">       }</span>
<a href="#l7.437"></a><span id="l7.437">     }</span>
<a href="#l7.438"></a><span id="l7.438">   },</span>
<a href="#l7.439"></a><span id="l7.439"> </span>
<a href="#l7.440"></a><span id="l7.440" class="difflineminus">-  _onItemsModified: function gloda_coll_onItemsModified(aItems) {</span>
<a href="#l7.441"></a><span id="l7.441" class="difflineplus">+  _onItemsModified(aItems) {</span>
<a href="#l7.442"></a><span id="l7.442">     if (this._listener) {</span>
<a href="#l7.443"></a><span id="l7.443">       try {</span>
<a href="#l7.444"></a><span id="l7.444">         this._listener.onItemsModified(aItems, this);</span>
<a href="#l7.445"></a><span id="l7.445" class="difflineminus">-      }</span>
<a href="#l7.446"></a><span id="l7.446" class="difflineminus">-      catch (ex) {</span>
<a href="#l7.447"></a><span id="l7.447" class="difflineplus">+      } catch (ex) {</span>
<a href="#l7.448"></a><span id="l7.448">         LOG.error(&quot;caught exception from listener in onItemsModified: &quot; +</span>
<a href="#l7.449"></a><span id="l7.449">             ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l7.450"></a><span id="l7.450">       }</span>
<a href="#l7.451"></a><span id="l7.451">     }</span>
<a href="#l7.452"></a><span id="l7.452">   },</span>
<a href="#l7.453"></a><span id="l7.453"> </span>
<a href="#l7.454"></a><span id="l7.454">   /**</span>
<a href="#l7.455"></a><span id="l7.455">    * Given a list of items that definitely no longer belong in this collection,</span>
<a href="#l7.456"></a><span id="l7.456">    *  remove them from the collection and notify the listener.  The 'tricky'</span>
<a href="#l7.457"></a><span id="l7.457">    *  part is that we need to remove the deleted items from our list of items.</span>
<a href="#l7.458"></a><span id="l7.458">    */</span>
<a href="#l7.459"></a><span id="l7.459" class="difflineminus">-  _onItemsRemoved: function gloda_coll_onItemsRemoved(aItems) {</span>
<a href="#l7.460"></a><span id="l7.460" class="difflineplus">+  _onItemsRemoved(aItems) {</span>
<a href="#l7.461"></a><span id="l7.461">     // we want to avoid the O(n^2) deletion performance case, and deletion</span>
<a href="#l7.462"></a><span id="l7.462">     //  should be rare enough that the extra cost of building the deletion map</span>
<a href="#l7.463"></a><span id="l7.463">     //  should never be a real problem.</span>
<a href="#l7.464"></a><span id="l7.464">     let deleteMap = {};</span>
<a href="#l7.465"></a><span id="l7.465">     // build the delete map while also nuking from our id map/unique value map</span>
<a href="#l7.466"></a><span id="l7.466">     for (let item of aItems) {</span>
<a href="#l7.467"></a><span id="l7.467">       deleteMap[item.id] = true;</span>
<a href="#l7.468"></a><span id="l7.468">       delete this._idMap[item.id];</span>
<a href="#l7.469"></a><span id="l7.469">       if (this._uniqueValueMap)</span>
<a href="#l7.470"></a><span id="l7.470">         delete this._uniqueValueMap[item.uniqueValue];</span>
<a href="#l7.471"></a><span id="l7.471">     }</span>
<a href="#l7.472"></a><span id="l7.472">     let items = this.items;</span>
<a href="#l7.473"></a><span id="l7.473">     // in-place filter.  probably needless optimization.</span>
<a href="#l7.474"></a><span id="l7.474" class="difflineminus">-    let iWrite=0;</span>
<a href="#l7.475"></a><span id="l7.475" class="difflineplus">+    let iWrite = 0;</span>
<a href="#l7.476"></a><span id="l7.476">     for (let iRead = 0; iRead &lt; items.length; iRead++) {</span>
<a href="#l7.477"></a><span id="l7.477">       let item = items[iRead];</span>
<a href="#l7.478"></a><span id="l7.478">       if (!(item.id in deleteMap))</span>
<a href="#l7.479"></a><span id="l7.479">         items[iWrite++] = item;</span>
<a href="#l7.480"></a><span id="l7.480">     }</span>
<a href="#l7.481"></a><span id="l7.481">     items.splice(iWrite);</span>
<a href="#l7.482"></a><span id="l7.482"> </span>
<a href="#l7.483"></a><span id="l7.483">     if (this._listener) {</span>
<a href="#l7.484"></a><span id="l7.484">       try {</span>
<a href="#l7.485"></a><span id="l7.485">         this._listener.onItemsRemoved(aItems, this);</span>
<a href="#l7.486"></a><span id="l7.486" class="difflineminus">-      }</span>
<a href="#l7.487"></a><span id="l7.487" class="difflineminus">-      catch (ex) {</span>
<a href="#l7.488"></a><span id="l7.488" class="difflineplus">+      } catch (ex) {</span>
<a href="#l7.489"></a><span id="l7.489">         LOG.error(&quot;caught exception from listener in onItemsRemoved: &quot; +</span>
<a href="#l7.490"></a><span id="l7.490">             ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l7.491"></a><span id="l7.491">       }</span>
<a href="#l7.492"></a><span id="l7.492">     }</span>
<a href="#l7.493"></a><span id="l7.493">   },</span>
<a href="#l7.494"></a><span id="l7.494"> </span>
<a href="#l7.495"></a><span id="l7.495" class="difflineminus">-  _onQueryCompleted: function gloda_coll_onQueryCompleted() {</span>
<a href="#l7.496"></a><span id="l7.496" class="difflineplus">+  _onQueryCompleted() {</span>
<a href="#l7.497"></a><span id="l7.497">     this.query.completed = true;</span>
<a href="#l7.498"></a><span id="l7.498">     if (this._listener &amp;&amp; this._listener.onQueryCompleted)</span>
<a href="#l7.499"></a><span id="l7.499">       this._listener.onQueryCompleted(this);</span>
<a href="#l7.500"></a><span id="l7.500" class="difflineminus">-  }</span>
<a href="#l7.501"></a><span id="l7.501" class="difflineplus">+  },</span>
<a href="#l7.502"></a><span id="l7.502"> };</span>
<a href="#l7.503"></a><span id="l7.503"> </span>
<a href="#l7.504"></a><span id="l7.504"> /**</span>
<a href="#l7.505"></a><span id="l7.505">  * Create an LRU cache collection for the given noun with the given size.</span>
<a href="#l7.506"></a><span id="l7.506">  * @constructor</span>
<a href="#l7.507"></a><span id="l7.507">  */</span>
<a href="#l7.508"></a><span id="l7.508"> function GlodaLRUCacheCollection(aNounDef, aCacheSize) {</span>
<a href="#l7.509"></a><span id="l7.509">   GlodaCollection.call(this, aNounDef, null, null, null);</span>
<a href="#l7.510"></a><span id="l7.510" class="difflineat">@@ -645,17 +630,17 @@ function GlodaLRUCacheCollection(aNounDe</span>
<a href="#l7.511"></a><span id="l7.511"> /**</span>
<a href="#l7.512"></a><span id="l7.512">  * @class A LRU-discard cache.  We use a doubly linked-list for the eviction</span>
<a href="#l7.513"></a><span id="l7.513">  *  tracking.  Since we require that there is at most one LRU-discard cache per</span>
<a href="#l7.514"></a><span id="l7.514">  *  noun class, we simplify our lives by adding our own attributes to the</span>
<a href="#l7.515"></a><span id="l7.515">  *  cached objects.</span>
<a href="#l7.516"></a><span id="l7.516">  * @augments GlodaCollection</span>
<a href="#l7.517"></a><span id="l7.517">  */</span>
<a href="#l7.518"></a><span id="l7.518"> GlodaLRUCacheCollection.prototype = new GlodaCollection;</span>
<a href="#l7.519"></a><span id="l7.519" class="difflineminus">-GlodaLRUCacheCollection.prototype.add = function cache_add(aItems) {</span>
<a href="#l7.520"></a><span id="l7.520" class="difflineplus">+GlodaLRUCacheCollection.prototype.add = function(aItems) {</span>
<a href="#l7.521"></a><span id="l7.521">   for (let item of aItems) {</span>
<a href="#l7.522"></a><span id="l7.522">     if (item.id in this._idMap) {</span>
<a href="#l7.523"></a><span id="l7.523">       // DEBUGME so, we're dealing with this, but it shouldn't happen.  need</span>
<a href="#l7.524"></a><span id="l7.524">       //  trace-debuggage.</span>
<a href="#l7.525"></a><span id="l7.525">       continue;</span>
<a href="#l7.526"></a><span id="l7.526">     }</span>
<a href="#l7.527"></a><span id="l7.527">     this._idMap[item.id] = item;</span>
<a href="#l7.528"></a><span id="l7.528">     if (this._uniqueValueMap)</span>
<a href="#l7.529"></a><span id="l7.529" class="difflineat">@@ -696,17 +681,17 @@ GlodaLRUCacheCollection.prototype.add = </span>
<a href="#l7.530"></a><span id="l7.530">       this._nounDef.objUpdate.call(this._nounDef.datastore, item);</span>
<a href="#l7.531"></a><span id="l7.531">       delete item.dirty;</span>
<a href="#l7.532"></a><span id="l7.532">     }</span>
<a href="#l7.533"></a><span id="l7.533"> </span>
<a href="#l7.534"></a><span id="l7.534">     this._size--;</span>
<a href="#l7.535"></a><span id="l7.535">   }</span>
<a href="#l7.536"></a><span id="l7.536"> };</span>
<a href="#l7.537"></a><span id="l7.537"> </span>
<a href="#l7.538"></a><span id="l7.538" class="difflineminus">-GlodaLRUCacheCollection.prototype.hit = function cache_hit(aItem) {</span>
<a href="#l7.539"></a><span id="l7.539" class="difflineplus">+GlodaLRUCacheCollection.prototype.hit = function(aItem) {</span>
<a href="#l7.540"></a><span id="l7.540">   // don't do anything in the 0 or 1 items case, or if we're already</span>
<a href="#l7.541"></a><span id="l7.541">   //  the last item</span>
<a href="#l7.542"></a><span id="l7.542">   if ((this._head === this._tail) || (this._tail === aItem))</span>
<a href="#l7.543"></a><span id="l7.543">     return aItem;</span>
<a href="#l7.544"></a><span id="l7.544"> </span>
<a href="#l7.545"></a><span id="l7.545">   // - unlink the item</span>
<a href="#l7.546"></a><span id="l7.546">   if (aItem._lruPrev !== null)</span>
<a href="#l7.547"></a><span id="l7.547">     aItem._lruPrev._lruNext = aItem._lruNext;</span>
<a href="#l7.548"></a><span id="l7.548" class="difflineat">@@ -719,17 +704,17 @@ GlodaLRUCacheCollection.prototype.hit = </span>
<a href="#l7.549"></a><span id="l7.549">   aItem._lruPrev = this._tail;</span>
<a href="#l7.550"></a><span id="l7.550">   aItem._lruNext = null;</span>
<a href="#l7.551"></a><span id="l7.551">   // update tail tracking</span>
<a href="#l7.552"></a><span id="l7.552">   this._tail = aItem;</span>
<a href="#l7.553"></a><span id="l7.553"> </span>
<a href="#l7.554"></a><span id="l7.554">   return aItem;</span>
<a href="#l7.555"></a><span id="l7.555"> };</span>
<a href="#l7.556"></a><span id="l7.556"> </span>
<a href="#l7.557"></a><span id="l7.557" class="difflineminus">-GlodaLRUCacheCollection.prototype.deleted = function cache_deleted(aItem) {</span>
<a href="#l7.558"></a><span id="l7.558" class="difflineplus">+GlodaLRUCacheCollection.prototype.deleted = function(aItem) {</span>
<a href="#l7.559"></a><span id="l7.559">   // unlink the item</span>
<a href="#l7.560"></a><span id="l7.560">   if (aItem._lruPrev !== null)</span>
<a href="#l7.561"></a><span id="l7.561">     aItem._lruPrev._lruNext = aItem._lruNext;</span>
<a href="#l7.562"></a><span id="l7.562">   else</span>
<a href="#l7.563"></a><span id="l7.563">     this._head = aItem._lruNext;</span>
<a href="#l7.564"></a><span id="l7.564">   if (aItem._lruNext !== null)</span>
<a href="#l7.565"></a><span id="l7.565">     aItem._lruNext._lruPrev = aItem._lruPrev;</span>
<a href="#l7.566"></a><span id="l7.566">   else</span>
<a href="#l7.567"></a><span id="l7.567" class="difflineat">@@ -746,17 +731,17 @@ GlodaLRUCacheCollection.prototype.delete</span>
<a href="#l7.568"></a><span id="l7.568"> </span>
<a href="#l7.569"></a><span id="l7.569">   this._size--;</span>
<a href="#l7.570"></a><span id="l7.570"> };</span>
<a href="#l7.571"></a><span id="l7.571"> </span>
<a href="#l7.572"></a><span id="l7.572"> /**</span>
<a href="#l7.573"></a><span id="l7.573">  * If any of the cached items are dirty, commit them, and make them no longer</span>
<a href="#l7.574"></a><span id="l7.574">  *  dirty.</span>
<a href="#l7.575"></a><span id="l7.575">  */</span>
<a href="#l7.576"></a><span id="l7.576" class="difflineminus">-GlodaLRUCacheCollection.prototype.commitDirty = function cache_commitDirty() {</span>
<a href="#l7.577"></a><span id="l7.577" class="difflineplus">+GlodaLRUCacheCollection.prototype.commitDirty = function() {</span>
<a href="#l7.578"></a><span id="l7.578">   // we can only do this if there is an update method available...</span>
<a href="#l7.579"></a><span id="l7.579">   if (!this._nounDef.objUpdate)</span>
<a href="#l7.580"></a><span id="l7.580">     return;</span>
<a href="#l7.581"></a><span id="l7.581"> </span>
<a href="#l7.582"></a><span id="l7.582">   for (let iItem in this._idMap) {</span>
<a href="#l7.583"></a><span id="l7.583">     let item = this._idMap[iItem];</span>
<a href="#l7.584"></a><span id="l7.584">     if (item.dirty) {</span>
<a href="#l7.585"></a><span id="l7.585">       LOG.debug(&quot;flushing dirty: &quot; + item);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/db/gloda/modules/connotent.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/connotent.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -1,14 +1,14 @@</span>
<a href="#l8.4"></a><span id="l8.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l8.5"></a><span id="l8.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l8.6"></a><span id="l8.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l8.7"></a><span id="l8.7"> </span>
<a href="#l8.8"></a><span id="l8.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['GlodaContent', 'whittlerRegistry',</span>
<a href="#l8.9"></a><span id="l8.9" class="difflineminus">-                          'mimeMsgToContentAndMeta', 'mimeMsgToContentSnippetAndMeta'];</span>
<a href="#l8.10"></a><span id="l8.10" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;GlodaContent&quot;, &quot;whittlerRegistry&quot;,</span>
<a href="#l8.11"></a><span id="l8.11" class="difflineplus">+                         &quot;mimeMsgToContentAndMeta&quot;, &quot;mimeMsgToContentSnippetAndMeta&quot;];</span>
<a href="#l8.12"></a><span id="l8.12"> </span>
<a href="#l8.13"></a><span id="l8.13"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l8.14"></a><span id="l8.14"> </span>
<a href="#l8.15"></a><span id="l8.15"> var LOG = Log4Moz.repository.getLogger(&quot;gloda.connotent&quot;);</span>
<a href="#l8.16"></a><span id="l8.16"> </span>
<a href="#l8.17"></a><span id="l8.17"> </span>
<a href="#l8.18"></a><span id="l8.18"> </span>
<a href="#l8.19"></a><span id="l8.19"> /**</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineat">@@ -45,17 +45,17 @@ function mimeMsgToContentAndMeta(aMimeMs</span>
<a href="#l8.21"></a><span id="l8.21">  * that the Gloda content providers may have filled with useful data.</span>
<a href="#l8.22"></a><span id="l8.22">  */</span>
<a href="#l8.23"></a><span id="l8.23"> </span>
<a href="#l8.24"></a><span id="l8.24"> function mimeMsgToContentSnippetAndMeta(aMimeMsg, folder, length) {</span>
<a href="#l8.25"></a><span id="l8.25">   let [content, meta] = mimeMsgToContentAndMeta(aMimeMsg, folder);</span>
<a href="#l8.26"></a><span id="l8.26"> </span>
<a href="#l8.27"></a><span id="l8.27">   let text = content.getContentSnippet(length + 1);</span>
<a href="#l8.28"></a><span id="l8.28">   if (length &amp;&amp; text.length &gt; length)</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineminus">-    text = text.substring(0, length-1) + &quot;\u2026&quot;; // ellipsis</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+    text = text.substring(0, length - 1) + &quot;\u2026&quot;; // ellipsis</span>
<a href="#l8.31"></a><span id="l8.31"> </span>
<a href="#l8.32"></a><span id="l8.32">   return [text, meta];</span>
<a href="#l8.33"></a><span id="l8.33"> }</span>
<a href="#l8.34"></a><span id="l8.34"> </span>
<a href="#l8.35"></a><span id="l8.35"> </span>
<a href="#l8.36"></a><span id="l8.36"> /**</span>
<a href="#l8.37"></a><span id="l8.37">  * A registry of gloda providers that have contentWhittle() functions.</span>
<a href="#l8.38"></a><span id="l8.38">  * used by mimeMsgToContentSnippet, but populated by the Gloda object as it's</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineat">@@ -64,29 +64,29 @@ function mimeMsgToContentSnippetAndMeta(</span>
<a href="#l8.40"></a><span id="l8.40"> function WhittlerRegistry() {</span>
<a href="#l8.41"></a><span id="l8.41">   this._whittlers = [];</span>
<a href="#l8.42"></a><span id="l8.42"> }</span>
<a href="#l8.43"></a><span id="l8.43"> </span>
<a href="#l8.44"></a><span id="l8.44"> WhittlerRegistry.prototype = {</span>
<a href="#l8.45"></a><span id="l8.45">   /**</span>
<a href="#l8.46"></a><span id="l8.46">    * Add a provider as a content whittler.</span>
<a href="#l8.47"></a><span id="l8.47">    */</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineminus">-  registerWhittler: function whittler_registry_registerWhittler(provider) {</span>
<a href="#l8.49"></a><span id="l8.49" class="difflineplus">+  registerWhittler(provider) {</span>
<a href="#l8.50"></a><span id="l8.50">     this._whittlers.push(provider);</span>
<a href="#l8.51"></a><span id="l8.51">   },</span>
<a href="#l8.52"></a><span id="l8.52">   /**</span>
<a href="#l8.53"></a><span id="l8.53">    * get the list of content whittlers, sorted from the most specific to</span>
<a href="#l8.54"></a><span id="l8.54">    * the most generic</span>
<a href="#l8.55"></a><span id="l8.55">    */</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineminus">-  getWhittlers: function whittler_registry_getWhittlers() {</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineplus">+  getWhittlers() {</span>
<a href="#l8.58"></a><span id="l8.58">     // Use the concat() trick to avoid mutating the internal object and</span>
<a href="#l8.59"></a><span id="l8.59">     // leaking an internal representation.</span>
<a href="#l8.60"></a><span id="l8.60">     return this._whittlers.concat().reverse();</span>
<a href="#l8.61"></a><span id="l8.61" class="difflineminus">-  }</span>
<a href="#l8.62"></a><span id="l8.62" class="difflineminus">-}</span>
<a href="#l8.63"></a><span id="l8.63" class="difflineplus">+  },</span>
<a href="#l8.64"></a><span id="l8.64" class="difflineplus">+};</span>
<a href="#l8.65"></a><span id="l8.65"> </span>
<a href="#l8.66"></a><span id="l8.66"> this.whittlerRegistry = new WhittlerRegistry();</span>
<a href="#l8.67"></a><span id="l8.67"> </span>
<a href="#l8.68"></a><span id="l8.68"> function GlodaContent() {</span>
<a href="#l8.69"></a><span id="l8.69">   this._contentPriority = null;</span>
<a href="#l8.70"></a><span id="l8.70">   this._producing = false;</span>
<a href="#l8.71"></a><span id="l8.71">   this._hunks = [];</span>
<a href="#l8.72"></a><span id="l8.72"> }</span>
<a href="#l8.73"></a><span id="l8.73" class="difflineat">@@ -94,42 +94,42 @@ function GlodaContent() {</span>
<a href="#l8.74"></a><span id="l8.74"> GlodaContent.prototype = {</span>
<a href="#l8.75"></a><span id="l8.75">   kPriorityBase: 0,</span>
<a href="#l8.76"></a><span id="l8.76">   kPriorityPerfect: 100,</span>
<a href="#l8.77"></a><span id="l8.77"> </span>
<a href="#l8.78"></a><span id="l8.78">   kHunkMeta: 1,</span>
<a href="#l8.79"></a><span id="l8.79">   kHunkQuoted: 2,</span>
<a href="#l8.80"></a><span id="l8.80">   kHunkContent: 3,</span>
<a href="#l8.81"></a><span id="l8.81"> </span>
<a href="#l8.82"></a><span id="l8.82" class="difflineminus">-  _resetContent: function gloda_content__resetContent() {</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineplus">+  _resetContent() {</span>
<a href="#l8.84"></a><span id="l8.84">     this._keysAndValues = [];</span>
<a href="#l8.85"></a><span id="l8.85">     this._keysAndDeltaValues = [];</span>
<a href="#l8.86"></a><span id="l8.86">     this._hunks = [];</span>
<a href="#l8.87"></a><span id="l8.87">     this._curHunk = null;</span>
<a href="#l8.88"></a><span id="l8.88">   },</span>
<a href="#l8.89"></a><span id="l8.89"> </span>
<a href="#l8.90"></a><span id="l8.90">   /* ===== Consumer API ===== */</span>
<a href="#l8.91"></a><span id="l8.91" class="difflineminus">-  hasContent: function gloda_content_hasContent() {</span>
<a href="#l8.92"></a><span id="l8.92" class="difflineplus">+  hasContent() {</span>
<a href="#l8.93"></a><span id="l8.93">     return (this._contentPriority != null);</span>
<a href="#l8.94"></a><span id="l8.94">   },</span>
<a href="#l8.95"></a><span id="l8.95"> </span>
<a href="#l8.96"></a><span id="l8.96">   /**</span>
<a href="#l8.97"></a><span id="l8.97">    * Return content suitable for snippet display.  This means that no quoting</span>
<a href="#l8.98"></a><span id="l8.98">    *  or meta-data should be returned.</span>
<a href="#l8.99"></a><span id="l8.99">    *</span>
<a href="#l8.100"></a><span id="l8.100">    * @param aMaxLength The maximum snippet length desired.</span>
<a href="#l8.101"></a><span id="l8.101">    */</span>
<a href="#l8.102"></a><span id="l8.102" class="difflineminus">-  getContentSnippet: function gloda_content_getContentSnippet(aMaxLength) {</span>
<a href="#l8.103"></a><span id="l8.103" class="difflineplus">+  getContentSnippet(aMaxLength) {</span>
<a href="#l8.104"></a><span id="l8.104">     let content = this.getContentString();</span>
<a href="#l8.105"></a><span id="l8.105">     if (aMaxLength)</span>
<a href="#l8.106"></a><span id="l8.106">       content = content.substring(0, aMaxLength);</span>
<a href="#l8.107"></a><span id="l8.107">     return content;</span>
<a href="#l8.108"></a><span id="l8.108">   },</span>
<a href="#l8.109"></a><span id="l8.109"> </span>
<a href="#l8.110"></a><span id="l8.110" class="difflineminus">-  getContentString: function gloda_content_getContent(aIndexingPurposes) {</span>
<a href="#l8.111"></a><span id="l8.111" class="difflineplus">+  getContentString(aIndexingPurposes) {</span>
<a href="#l8.112"></a><span id="l8.112">     let data = &quot;&quot;;</span>
<a href="#l8.113"></a><span id="l8.113">     for (let hunk of this._hunks) {</span>
<a href="#l8.114"></a><span id="l8.114">       if (hunk.hunkType == this.kHunkContent) {</span>
<a href="#l8.115"></a><span id="l8.115">         if (data)</span>
<a href="#l8.116"></a><span id="l8.116">           data += &quot;\n&quot; + hunk.data;</span>
<a href="#l8.117"></a><span id="l8.117">         else</span>
<a href="#l8.118"></a><span id="l8.118">           data = hunk.data;</span>
<a href="#l8.119"></a><span id="l8.119">       }</span>
<a href="#l8.120"></a><span id="l8.120" class="difflineat">@@ -157,35 +157,34 @@ GlodaContent.prototype = {</span>
<a href="#l8.121"></a><span id="l8.121">    *</span>
<a href="#l8.122"></a><span id="l8.122">    * @returns true if we believe the producer's interpretation will be</span>
<a href="#l8.123"></a><span id="l8.123">    *     interesting and they should go ahead and generate events.  We return</span>
<a href="#l8.124"></a><span id="l8.124">    *     false if we don't think they are interesting, in which case they should</span>
<a href="#l8.125"></a><span id="l8.125">    *     probably not issue calls to us, although we don't care.  (We will</span>
<a href="#l8.126"></a><span id="l8.126">    *     ignore their calls if we return false, this allows the simplification</span>
<a href="#l8.127"></a><span id="l8.127">    *     of code that needs to run anyways.)</span>
<a href="#l8.128"></a><span id="l8.128">    */</span>
<a href="#l8.129"></a><span id="l8.129" class="difflineminus">-  volunteerContent: function gloda_content_volunteerContent(aPriority) {</span>
<a href="#l8.130"></a><span id="l8.130" class="difflineplus">+  volunteerContent(aPriority) {</span>
<a href="#l8.131"></a><span id="l8.131">     if (this._contentPriority === null || this._contentPriority &lt; aPriority) {</span>
<a href="#l8.132"></a><span id="l8.132">       this._contentPriority = aPriority;</span>
<a href="#l8.133"></a><span id="l8.133">       this._resetContent();</span>
<a href="#l8.134"></a><span id="l8.134">       this._producing = true;</span>
<a href="#l8.135"></a><span id="l8.135">       return true;</span>
<a href="#l8.136"></a><span id="l8.136">     }</span>
<a href="#l8.137"></a><span id="l8.137">     this._producing = false;</span>
<a href="#l8.138"></a><span id="l8.138">     return false;</span>
<a href="#l8.139"></a><span id="l8.139">   },</span>
<a href="#l8.140"></a><span id="l8.140"> </span>
<a href="#l8.141"></a><span id="l8.141" class="difflineminus">-  keyValue: function gloda_content_keyValue(aKey, aValue) {</span>
<a href="#l8.142"></a><span id="l8.142" class="difflineplus">+  keyValue(aKey, aValue) {</span>
<a href="#l8.143"></a><span id="l8.143">     if (!this._producing)</span>
<a href="#l8.144"></a><span id="l8.144">       return;</span>
<a href="#l8.145"></a><span id="l8.145"> </span>
<a href="#l8.146"></a><span id="l8.146">     this._keysAndValues.push([aKey, aValue]);</span>
<a href="#l8.147"></a><span id="l8.147">   },</span>
<a href="#l8.148"></a><span id="l8.148" class="difflineminus">-  keyValueDelta: function gloda_content_keyValueDelta (aKey, aOldValue,</span>
<a href="#l8.149"></a><span id="l8.149" class="difflineminus">-      aNewValue) {</span>
<a href="#l8.150"></a><span id="l8.150" class="difflineplus">+  keyValueDelta(aKey, aOldValue, aNewValue) {</span>
<a href="#l8.151"></a><span id="l8.151">     if (!this._producing)</span>
<a href="#l8.152"></a><span id="l8.152">       return;</span>
<a href="#l8.153"></a><span id="l8.153"> </span>
<a href="#l8.154"></a><span id="l8.154">     this._keysAndDeltaValues.push([aKey, aOldValue, aNewValue]);</span>
<a href="#l8.155"></a><span id="l8.155">   },</span>
<a href="#l8.156"></a><span id="l8.156"> </span>
<a href="#l8.157"></a><span id="l8.157">   /**</span>
<a href="#l8.158"></a><span id="l8.158">    * Meta lines are lines that have to do with the content but are not the</span>
<a href="#l8.159"></a><span id="l8.159" class="difflineat">@@ -196,73 +195,72 @@ GlodaContent.prototype = {</span>
<a href="#l8.160"></a><span id="l8.160">    *  potentially interesting meta-data.</span>
<a href="#l8.161"></a><span id="l8.161">    *</span>
<a href="#l8.162"></a><span id="l8.162">    * @param aLineOrLines The line or list of lines that are meta-data.</span>
<a href="#l8.163"></a><span id="l8.163">    * @param aAttr The attribute this meta-data is associated with.</span>
<a href="#l8.164"></a><span id="l8.164">    * @param aIndex If the attribute is non-singular, indicate the specific</span>
<a href="#l8.165"></a><span id="l8.165">    *     index of the item in the attribute's bound list that the meta-data</span>
<a href="#l8.166"></a><span id="l8.166">    *     is associated with.</span>
<a href="#l8.167"></a><span id="l8.167">    */</span>
<a href="#l8.168"></a><span id="l8.168" class="difflineminus">-  meta: function gloda_content_meta(aLineOrLines, aAttr, aIndex) {</span>
<a href="#l8.169"></a><span id="l8.169" class="difflineplus">+  meta(aLineOrLines, aAttr, aIndex) {</span>
<a href="#l8.170"></a><span id="l8.170">     if (!this._producing)</span>
<a href="#l8.171"></a><span id="l8.171">       return;</span>
<a href="#l8.172"></a><span id="l8.172"> </span>
<a href="#l8.173"></a><span id="l8.173">     let data;</span>
<a href="#l8.174"></a><span id="l8.174">     if (typeof(aLineOrLines) == &quot;string&quot;)</span>
<a href="#l8.175"></a><span id="l8.175">       data = aLineOrLines;</span>
<a href="#l8.176"></a><span id="l8.176">     else</span>
<a href="#l8.177"></a><span id="l8.177">       data = aLineOrLines.join(&quot;\n&quot;);</span>
<a href="#l8.178"></a><span id="l8.178"> </span>
<a href="#l8.179"></a><span id="l8.179">     this._curHunk = {hunkType: this.kHunkMeta, attr: aAttr, index: aIndex,</span>
<a href="#l8.180"></a><span id="l8.180" class="difflineminus">-                     data: data};</span>
<a href="#l8.181"></a><span id="l8.181" class="difflineplus">+                     data};</span>
<a href="#l8.182"></a><span id="l8.182">     this._hunks.push(this._curHunk);</span>
<a href="#l8.183"></a><span id="l8.183">   },</span>
<a href="#l8.184"></a><span id="l8.184">   /**</span>
<a href="#l8.185"></a><span id="l8.185">    * Quoted lines reference previous messages or what not.</span>
<a href="#l8.186"></a><span id="l8.186">    *</span>
<a href="#l8.187"></a><span id="l8.187">    * @param aLineOrLiens The line or list of lines that are quoted.</span>
<a href="#l8.188"></a><span id="l8.188">    * @param aDepth The depth of the quoting.</span>
<a href="#l8.189"></a><span id="l8.189">    * @param aOrigin The item that originated the original content, if known.</span>
<a href="#l8.190"></a><span id="l8.190">    *     For example, perhaps a GlodaMessage?</span>
<a href="#l8.191"></a><span id="l8.191">    * @param aTarget A reference to the location in the original content, if</span>
<a href="#l8.192"></a><span id="l8.192">    *     known.  For example, the index of a line in a message or something?</span>
<a href="#l8.193"></a><span id="l8.193">    */</span>
<a href="#l8.194"></a><span id="l8.194" class="difflineminus">-  quoted: function gloda_content_quoted(aLineOrLines, aDepth, aOrigin,</span>
<a href="#l8.195"></a><span id="l8.195" class="difflineminus">-      aTarget) {</span>
<a href="#l8.196"></a><span id="l8.196" class="difflineplus">+  quoted(aLineOrLines, aDepth, aOrigin, aTarget) {</span>
<a href="#l8.197"></a><span id="l8.197">     if (!this._producing)</span>
<a href="#l8.198"></a><span id="l8.198">       return;</span>
<a href="#l8.199"></a><span id="l8.199"> </span>
<a href="#l8.200"></a><span id="l8.200">     let data;</span>
<a href="#l8.201"></a><span id="l8.201">     if (typeof(aLineOrLines) == &quot;string&quot;)</span>
<a href="#l8.202"></a><span id="l8.202">       data = aLineOrLines;</span>
<a href="#l8.203"></a><span id="l8.203">     else</span>
<a href="#l8.204"></a><span id="l8.204">       data = aLineOrLines.join(&quot;\n&quot;);</span>
<a href="#l8.205"></a><span id="l8.205"> </span>
<a href="#l8.206"></a><span id="l8.206">     if (!this._curHunk ||</span>
<a href="#l8.207"></a><span id="l8.207">         this._curHunk.hunkType != this.kHunkQuoted ||</span>
<a href="#l8.208"></a><span id="l8.208">         this._curHunk.depth != aDepth ||</span>
<a href="#l8.209"></a><span id="l8.209">         this._curHunk.origin != aOrigin || this._curHunk.target != aTarget) {</span>
<a href="#l8.210"></a><span id="l8.210" class="difflineminus">-      this._curHunk = {hunkType: this.kHunkQuoted, data: data,</span>
<a href="#l8.211"></a><span id="l8.211" class="difflineplus">+      this._curHunk = {hunkType: this.kHunkQuoted, data,</span>
<a href="#l8.212"></a><span id="l8.212">                        depth: aDepth, origin: aOrigin, target: aTarget};</span>
<a href="#l8.213"></a><span id="l8.213">       this._hunks.push(this._curHunk);</span>
<a href="#l8.214"></a><span id="l8.214" class="difflineplus">+    } else {</span>
<a href="#l8.215"></a><span id="l8.215" class="difflineplus">+      this._curHunk.data += &quot;\n&quot; + data;</span>
<a href="#l8.216"></a><span id="l8.216">     }</span>
<a href="#l8.217"></a><span id="l8.217" class="difflineminus">-    else</span>
<a href="#l8.218"></a><span id="l8.218" class="difflineminus">-      this._curHunk.data += &quot;\n&quot; + data;</span>
<a href="#l8.219"></a><span id="l8.219">   },</span>
<a href="#l8.220"></a><span id="l8.220"> </span>
<a href="#l8.221"></a><span id="l8.221" class="difflineminus">-  content: function gloda_content_content(aLineOrLines) {</span>
<a href="#l8.222"></a><span id="l8.222" class="difflineplus">+  content(aLineOrLines) {</span>
<a href="#l8.223"></a><span id="l8.223">     if (!this._producing)</span>
<a href="#l8.224"></a><span id="l8.224">       return;</span>
<a href="#l8.225"></a><span id="l8.225"> </span>
<a href="#l8.226"></a><span id="l8.226">     let data;</span>
<a href="#l8.227"></a><span id="l8.227">     if (typeof(aLineOrLines) == &quot;string&quot;)</span>
<a href="#l8.228"></a><span id="l8.228">       data = aLineOrLines;</span>
<a href="#l8.229"></a><span id="l8.229">     else</span>
<a href="#l8.230"></a><span id="l8.230">       data = aLineOrLines.join(&quot;\n&quot;);</span>
<a href="#l8.231"></a><span id="l8.231"> </span>
<a href="#l8.232"></a><span id="l8.232">     if (!this._curHunk || this._curHunk.hunkType != this.kHunkContent) {</span>
<a href="#l8.233"></a><span id="l8.233" class="difflineminus">-      this._curHunk = {hunkType: this.kHunkContent, data: data};</span>
<a href="#l8.234"></a><span id="l8.234" class="difflineplus">+      this._curHunk = {hunkType: this.kHunkContent, data};</span>
<a href="#l8.235"></a><span id="l8.235">       this._hunks.push(this._curHunk);</span>
<a href="#l8.236"></a><span id="l8.236" class="difflineplus">+    } else {</span>
<a href="#l8.237"></a><span id="l8.237" class="difflineplus">+      this._curHunk.data += &quot;\n&quot; + data;</span>
<a href="#l8.238"></a><span id="l8.238">     }</span>
<a href="#l8.239"></a><span id="l8.239" class="difflineminus">-    else</span>
<a href="#l8.240"></a><span id="l8.240" class="difflineminus">-      this._curHunk.data += &quot;\n&quot; + data;</span>
<a href="#l8.241"></a><span id="l8.241">   },</span>
<a href="#l8.242"></a><span id="l8.242"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/db/gloda/modules/databind.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/databind.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -108,30 +108,30 @@ GlodaDatabind.prototype = {</span>
<a href="#l9.4"></a><span id="l9.4">   /**</span>
<a href="#l9.5"></a><span id="l9.5">    * Perform appropriate binding coercion based on the schema provided to us.</span>
<a href="#l9.6"></a><span id="l9.6">    * Although we end up effectively coercing JS Date objects to numeric values,</span>
<a href="#l9.7"></a><span id="l9.7">    *  we should not be provided with JS Date objects!  There is no way for us</span>
<a href="#l9.8"></a><span id="l9.8">    *  to know to turn them back into JS Date objects on the way out.</span>
<a href="#l9.9"></a><span id="l9.9">    *  Additionally, there is the small matter of storage's bias towards</span>
<a href="#l9.10"></a><span id="l9.10">    *  PRTime representations which may not always be desirable.</span>
<a href="#l9.11"></a><span id="l9.11">    */</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-  bindByType: function(aStmt, aColDef, aValue) {</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+  bindByType(aStmt, aColDef, aValue) {</span>
<a href="#l9.14"></a><span id="l9.14">     aStmt.bindByIndex(aColDef[3], aValue);</span>
<a href="#l9.15"></a><span id="l9.15">   },</span>
<a href="#l9.16"></a><span id="l9.16"> </span>
<a href="#l9.17"></a><span id="l9.17" class="difflineminus">-  objFromRow: function(aRow) {</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+  objFromRow(aRow) {</span>
<a href="#l9.19"></a><span id="l9.19">     let getVariant = this._datastore._getVariant;</span>
<a href="#l9.20"></a><span id="l9.20">     let obj = new this._nounDef.class();</span>
<a href="#l9.21"></a><span id="l9.21">     for (let [iCol, colDef] of this._tableDef.columns.entries()) {</span>
<a href="#l9.22"></a><span id="l9.22">       obj[colDef[2]] = getVariant(aRow, iCol);</span>
<a href="#l9.23"></a><span id="l9.23">     }</span>
<a href="#l9.24"></a><span id="l9.24">     return obj;</span>
<a href="#l9.25"></a><span id="l9.25">   },</span>
<a href="#l9.26"></a><span id="l9.26"> </span>
<a href="#l9.27"></a><span id="l9.27" class="difflineminus">-  objInsert: function(aThing) {</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineplus">+  objInsert(aThing) {</span>
<a href="#l9.29"></a><span id="l9.29">     let bindByType = this.bindByType;</span>
<a href="#l9.30"></a><span id="l9.30">     if (!aThing[this._idAttr])</span>
<a href="#l9.31"></a><span id="l9.31">       aThing[this._idAttr] = this._nextId++;</span>
<a href="#l9.32"></a><span id="l9.32"> </span>
<a href="#l9.33"></a><span id="l9.33">     let stmt = this._insertStmt;</span>
<a href="#l9.34"></a><span id="l9.34">     for (let colDef of this._tableDef.columns) {</span>
<a href="#l9.35"></a><span id="l9.35">       bindByType(stmt, colDef, aThing[colDef[2]]);</span>
<a href="#l9.36"></a><span id="l9.36">     }</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineat">@@ -143,17 +143,17 @@ GlodaDatabind.prototype = {</span>
<a href="#l9.38"></a><span id="l9.38">       stmt.bindByIndex(0, aThing[this._idAttr]);</span>
<a href="#l9.39"></a><span id="l9.39">       for (let colDef of this._tableDef.fulltextColumns) {</span>
<a href="#l9.40"></a><span id="l9.40">         bindByType(stmt, colDef, aThing[colDef[2]]);</span>
<a href="#l9.41"></a><span id="l9.41">       }</span>
<a href="#l9.42"></a><span id="l9.42">       stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l9.43"></a><span id="l9.43">     }</span>
<a href="#l9.44"></a><span id="l9.44">   },</span>
<a href="#l9.45"></a><span id="l9.45"> </span>
<a href="#l9.46"></a><span id="l9.46" class="difflineminus">-  objUpdate: function(aThing) {</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineplus">+  objUpdate(aThing) {</span>
<a href="#l9.48"></a><span id="l9.48">     let bindByType = this.bindByType;</span>
<a href="#l9.49"></a><span id="l9.49">     let stmt = this._updateStmt;</span>
<a href="#l9.50"></a><span id="l9.50">     // note, we specially bound the location of 'id' for the insert, but since</span>
<a href="#l9.51"></a><span id="l9.51">     //  we're using named bindings, there is nothing special about setting it</span>
<a href="#l9.52"></a><span id="l9.52">     for (let colDef of this._tableDef.columns) {</span>
<a href="#l9.53"></a><span id="l9.53">       bindByType(stmt, colDef, aThing[colDef[2]]);</span>
<a href="#l9.54"></a><span id="l9.54">     }</span>
<a href="#l9.55"></a><span id="l9.55">     stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineat">@@ -164,21 +164,21 @@ GlodaDatabind.prototype = {</span>
<a href="#l9.57"></a><span id="l9.57">       stmt.bindByIndex(0, aThing[this._idAttr]);</span>
<a href="#l9.58"></a><span id="l9.58">       for (let colDef of this._tableDef.fulltextColumns) {</span>
<a href="#l9.59"></a><span id="l9.59">         bindByType(stmt, colDef, aThing[colDef[2]]);</span>
<a href="#l9.60"></a><span id="l9.60">       }</span>
<a href="#l9.61"></a><span id="l9.61">       stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l9.62"></a><span id="l9.62">     }</span>
<a href="#l9.63"></a><span id="l9.63">   },</span>
<a href="#l9.64"></a><span id="l9.64"> </span>
<a href="#l9.65"></a><span id="l9.65" class="difflineminus">-  adjustAttributes: function(...aArgs) {</span>
<a href="#l9.66"></a><span id="l9.66" class="difflineplus">+  adjustAttributes(...aArgs) {</span>
<a href="#l9.67"></a><span id="l9.67">     // just proxy the call over to the datastore... we have to do this for</span>
<a href="#l9.68"></a><span id="l9.68">     //  'this' reasons.  we don't refactor things to avoid this because it does</span>
<a href="#l9.69"></a><span id="l9.69">     //  make some sense to have all the methods exposed from a single object,</span>
<a href="#l9.70"></a><span id="l9.70">     //  even if the implementation does live elsewhere.</span>
<a href="#l9.71"></a><span id="l9.71">     return this._datastore.adjustAttributes(...aArgs);</span>
<a href="#l9.72"></a><span id="l9.72">   },</span>
<a href="#l9.73"></a><span id="l9.73"> </span>
<a href="#l9.74"></a><span id="l9.74">   // also proxied...</span>
<a href="#l9.75"></a><span id="l9.75" class="difflineminus">-  queryFromQuery: function(...aArgs) {</span>
<a href="#l9.76"></a><span id="l9.76" class="difflineplus">+  queryFromQuery(...aArgs) {</span>
<a href="#l9.77"></a><span id="l9.77">     return this._datastore.queryFromQuery(...aArgs);</span>
<a href="#l9.78"></a><span id="l9.78" class="difflineminus">-  }</span>
<a href="#l9.79"></a><span id="l9.79" class="difflineplus">+  },</span>
<a href="#l9.80"></a><span id="l9.80"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -11,17 +11,17 @@ const {MailServices} = ChromeUtils.impor</span>
<a href="#l10.4"></a><span id="l10.4"> </span>
<a href="#l10.5"></a><span id="l10.5"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l10.6"></a><span id="l10.6"> var LOG = Log4Moz.repository.getLogger(&quot;gloda.datamodel&quot;);</span>
<a href="#l10.7"></a><span id="l10.7"> </span>
<a href="#l10.8"></a><span id="l10.8"> const {GlodaUtils} = ChromeUtils.import(&quot;resource:///modules/gloda/utils.js&quot;);</span>
<a href="#l10.9"></a><span id="l10.9"> </span>
<a href="#l10.10"></a><span id="l10.10"> // Make it lazy.</span>
<a href="#l10.11"></a><span id="l10.11"> var gMessenger;</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-function getMessenger () {</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+function getMessenger() {</span>
<a href="#l10.14"></a><span id="l10.14">   if (!gMessenger)</span>
<a href="#l10.15"></a><span id="l10.15">     gMessenger = Cc[&quot;@mozilla.org/messenger;1&quot;].createInstance(Ci.nsIMessenger);</span>
<a href="#l10.16"></a><span id="l10.16">   return gMessenger;</span>
<a href="#l10.17"></a><span id="l10.17"> }</span>
<a href="#l10.18"></a><span id="l10.18"> </span>
<a href="#l10.19"></a><span id="l10.19"> /**</span>
<a href="#l10.20"></a><span id="l10.20">  * @class Represents a gloda attribute definition's DB form.  This class</span>
<a href="#l10.21"></a><span id="l10.21">  *  stores the information in the database relating to this attribute</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineat">@@ -54,17 +54,17 @@ GlodaAttributeDBDef.prototype = {</span>
<a href="#l10.23"></a><span id="l10.23">   get parameterBindings() { return this._parameterBindings; },</span>
<a href="#l10.24"></a><span id="l10.24"> </span>
<a href="#l10.25"></a><span id="l10.25">   /**</span>
<a href="#l10.26"></a><span id="l10.26">    * Bind a parameter value to the attribute definition, allowing use of the</span>
<a href="#l10.27"></a><span id="l10.27">    *  attribute-parameter as an attribute.</span>
<a href="#l10.28"></a><span id="l10.28">    *</span>
<a href="#l10.29"></a><span id="l10.29">    * @return</span>
<a href="#l10.30"></a><span id="l10.30">    */</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineminus">-  bindParameter: function gloda_attr_bindParameter(aValue) {</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+  bindParameter(aValue) {</span>
<a href="#l10.33"></a><span id="l10.33">     // people probably shouldn't call us with null, but handle it</span>
<a href="#l10.34"></a><span id="l10.34">     if (aValue == null) {</span>
<a href="#l10.35"></a><span id="l10.35">       return this._id;</span>
<a href="#l10.36"></a><span id="l10.36">     }</span>
<a href="#l10.37"></a><span id="l10.37">     if (aValue in this._parameterBindings) {</span>
<a href="#l10.38"></a><span id="l10.38">       return this._parameterBindings[aValue];</span>
<a href="#l10.39"></a><span id="l10.39">     }</span>
<a href="#l10.40"></a><span id="l10.40">     // no database entry exists if we are here, so we must create it...</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineat">@@ -79,71 +79,64 @@ GlodaAttributeDBDef.prototype = {</span>
<a href="#l10.42"></a><span id="l10.42">    * Given a list of values, return a list (regardless of plurality) of</span>
<a href="#l10.43"></a><span id="l10.43">    *  database-ready [attribute id,  value] tuples.  This is intended to be used</span>
<a href="#l10.44"></a><span id="l10.44">    *  to directly convert the value of a property on an object that corresponds</span>
<a href="#l10.45"></a><span id="l10.45">    *  to a bound attribute.</span>
<a href="#l10.46"></a><span id="l10.46">    *</span>
<a href="#l10.47"></a><span id="l10.47">    * @param {Array} aInstanceValues An array of instance values regardless of</span>
<a href="#l10.48"></a><span id="l10.48">    *     whether or not the attribute is singular.</span>
<a href="#l10.49"></a><span id="l10.49">    */</span>
<a href="#l10.50"></a><span id="l10.50" class="difflineminus">-  convertValuesToDBAttributes:</span>
<a href="#l10.51"></a><span id="l10.51" class="difflineminus">-      function gloda_attr_convertValuesToDBAttributes(aInstanceValues) {</span>
<a href="#l10.52"></a><span id="l10.52" class="difflineplus">+  convertValuesToDBAttributes(aInstanceValues) {</span>
<a href="#l10.53"></a><span id="l10.53">     let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l10.54"></a><span id="l10.54">     let dbAttributes = [];</span>
<a href="#l10.55"></a><span id="l10.55">     if (nounDef.usesParameter) {</span>
<a href="#l10.56"></a><span id="l10.56">       for (let instanceValue of aInstanceValues) {</span>
<a href="#l10.57"></a><span id="l10.57">         let [param, dbValue] = nounDef.toParamAndValue(instanceValue);</span>
<a href="#l10.58"></a><span id="l10.58">         dbAttributes.push([this.bindParameter(param), dbValue]);</span>
<a href="#l10.59"></a><span id="l10.59">       }</span>
<a href="#l10.60"></a><span id="l10.60" class="difflineminus">-    }</span>
<a href="#l10.61"></a><span id="l10.61" class="difflineminus">-    else {</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineplus">+    } else if (&quot;toParamAndValue&quot; in nounDef) {</span>
<a href="#l10.63"></a><span id="l10.63">       // Not generating any attributes is ok. This basically means the noun is</span>
<a href="#l10.64"></a><span id="l10.64">       // just an informative property on the Gloda Message and has no real</span>
<a href="#l10.65"></a><span id="l10.65">       // indexing purposes.</span>
<a href="#l10.66"></a><span id="l10.66" class="difflineminus">-      if (&quot;toParamAndValue&quot; in nounDef) {</span>
<a href="#l10.67"></a><span id="l10.67" class="difflineminus">-        for (let instanceValue of aInstanceValues) {</span>
<a href="#l10.68"></a><span id="l10.68" class="difflineminus">-          dbAttributes.push([this._id,</span>
<a href="#l10.69"></a><span id="l10.69" class="difflineminus">-                             nounDef.toParamAndValue(instanceValue)[1]]);</span>
<a href="#l10.70"></a><span id="l10.70" class="difflineminus">-        }</span>
<a href="#l10.71"></a><span id="l10.71" class="difflineplus">+      for (let instanceValue of aInstanceValues) {</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineplus">+        dbAttributes.push([this._id,</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineplus">+                           nounDef.toParamAndValue(instanceValue)[1]]);</span>
<a href="#l10.74"></a><span id="l10.74">       }</span>
<a href="#l10.75"></a><span id="l10.75">     }</span>
<a href="#l10.76"></a><span id="l10.76">     return dbAttributes;</span>
<a href="#l10.77"></a><span id="l10.77">   },</span>
<a href="#l10.78"></a><span id="l10.78"> </span>
<a href="#l10.79"></a><span id="l10.79" class="difflineminus">-  toString: function() {</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineplus">+  toString() {</span>
<a href="#l10.81"></a><span id="l10.81">     return this._compoundName;</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineminus">-  }</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineplus">+  },</span>
<a href="#l10.84"></a><span id="l10.84"> };</span>
<a href="#l10.85"></a><span id="l10.85"> </span>
<a href="#l10.86"></a><span id="l10.86"> var GlodaHasAttributesMixIn = {</span>
<a href="#l10.87"></a><span id="l10.87" class="difflineminus">-  enumerateAttributes: function* gloda_attrix_enumerateAttributes() {</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineplus">+  * enumerateAttributes() {</span>
<a href="#l10.89"></a><span id="l10.89">     let nounDef = this.NOUN_DEF;</span>
<a href="#l10.90"></a><span id="l10.90">     for (let key in this) {</span>
<a href="#l10.91"></a><span id="l10.91">       let value = this[key];</span>
<a href="#l10.92"></a><span id="l10.92">       let attrDef = nounDef.attribsByBoundName[key];</span>
<a href="#l10.93"></a><span id="l10.93">       // we expect to not have attributes for underscore prefixed values (those</span>
<a href="#l10.94"></a><span id="l10.94">       //  are managed by the instance's logic.  we also want to not explode</span>
<a href="#l10.95"></a><span id="l10.95">       //  should someone crap other values in there, we get both birds with this</span>
<a href="#l10.96"></a><span id="l10.96">       //  one stone.</span>
<a href="#l10.97"></a><span id="l10.97">       if (attrDef === undefined)</span>
<a href="#l10.98"></a><span id="l10.98">         continue;</span>
<a href="#l10.99"></a><span id="l10.99">       if (attrDef.singular) {</span>
<a href="#l10.100"></a><span id="l10.100">         // ignore attributes with null values</span>
<a href="#l10.101"></a><span id="l10.101">         if (value != null)</span>
<a href="#l10.102"></a><span id="l10.102">           yield [attrDef, [value]];</span>
<a href="#l10.103"></a><span id="l10.103" class="difflineminus">-      }</span>
<a href="#l10.104"></a><span id="l10.104" class="difflineminus">-      else {</span>
<a href="#l10.105"></a><span id="l10.105" class="difflineminus">-        // ignore attributes with no values</span>
<a href="#l10.106"></a><span id="l10.106" class="difflineminus">-        if (value.length)</span>
<a href="#l10.107"></a><span id="l10.107" class="difflineminus">-          yield [attrDef, value];</span>
<a href="#l10.108"></a><span id="l10.108" class="difflineplus">+      } else if (value.length) { // ignore attributes with no values</span>
<a href="#l10.109"></a><span id="l10.109" class="difflineplus">+        yield [attrDef, value];</span>
<a href="#l10.110"></a><span id="l10.110">       }</span>
<a href="#l10.111"></a><span id="l10.111">     }</span>
<a href="#l10.112"></a><span id="l10.112">   },</span>
<a href="#l10.113"></a><span id="l10.113"> </span>
<a href="#l10.114"></a><span id="l10.114" class="difflineminus">-  domContribute: function gloda_attrix_domContribute(aDomNode) {</span>
<a href="#l10.115"></a><span id="l10.115" class="difflineplus">+  domContribute(aDomNode) {</span>
<a href="#l10.116"></a><span id="l10.116">     let nounDef = this.NOUN_DEF;</span>
<a href="#l10.117"></a><span id="l10.117">     for (let attrName in nounDef.domExposeAttribsByBoundName) {</span>
<a href="#l10.118"></a><span id="l10.118">       let attr = nounDef.domExposeAttribsByBoundName[attrName];</span>
<a href="#l10.119"></a><span id="l10.119">       if (this[attrName])</span>
<a href="#l10.120"></a><span id="l10.120">         aDomNode.setAttribute(attr.domExpose, this[attrName]);</span>
<a href="#l10.121"></a><span id="l10.121">     }</span>
<a href="#l10.122"></a><span id="l10.122">   },</span>
<a href="#l10.123"></a><span id="l10.123"> };</span>
<a href="#l10.124"></a><span id="l10.124" class="difflineat">@@ -165,23 +158,23 @@ function GlodaAccount(aIncomingServer) {</span>
<a href="#l10.125"></a><span id="l10.125">   this._incomingServer = aIncomingServer;</span>
<a href="#l10.126"></a><span id="l10.126"> }</span>
<a href="#l10.127"></a><span id="l10.127"> </span>
<a href="#l10.128"></a><span id="l10.128"> GlodaAccount.prototype = {</span>
<a href="#l10.129"></a><span id="l10.129">   NOUN_ID: 106,</span>
<a href="#l10.130"></a><span id="l10.130">   get id() { return this._incomingServer.key; },</span>
<a href="#l10.131"></a><span id="l10.131">   get name() { return this._incomingServer.prettyName; },</span>
<a href="#l10.132"></a><span id="l10.132">   get incomingServer() { return this._incomingServer; },</span>
<a href="#l10.133"></a><span id="l10.133" class="difflineminus">-  toString: function gloda_account_toString() {</span>
<a href="#l10.134"></a><span id="l10.134" class="difflineplus">+  toString() {</span>
<a href="#l10.135"></a><span id="l10.135">     return &quot;Account: &quot; + this.id;</span>
<a href="#l10.136"></a><span id="l10.136">   },</span>
<a href="#l10.137"></a><span id="l10.137"> </span>
<a href="#l10.138"></a><span id="l10.138" class="difflineminus">-  toLocaleString: function gloda_account_toLocaleString() {</span>
<a href="#l10.139"></a><span id="l10.139" class="difflineplus">+  toLocaleString() {</span>
<a href="#l10.140"></a><span id="l10.140">     return this.name;</span>
<a href="#l10.141"></a><span id="l10.141" class="difflineminus">-  }</span>
<a href="#l10.142"></a><span id="l10.142" class="difflineplus">+  },</span>
<a href="#l10.143"></a><span id="l10.143"> };</span>
<a href="#l10.144"></a><span id="l10.144"> </span>
<a href="#l10.145"></a><span id="l10.145"> /**</span>
<a href="#l10.146"></a><span id="l10.146">  * @class A gloda conversation (thread) exists so that messages can belong.</span>
<a href="#l10.147"></a><span id="l10.147">  */</span>
<a href="#l10.148"></a><span id="l10.148"> function GlodaConversation(aDatastore, aID, aSubject, aOldestMessageDate,</span>
<a href="#l10.149"></a><span id="l10.149">                            aNewestMessageDate) {</span>
<a href="#l10.150"></a><span id="l10.150">   // _datastore is now set on the prototype by GlodaDatastore</span>
<a href="#l10.151"></a><span id="l10.151" class="difflineat">@@ -195,30 +188,29 @@ GlodaConversation.prototype = {</span>
<a href="#l10.152"></a><span id="l10.152">   NOUN_ID: 101,</span>
<a href="#l10.153"></a><span id="l10.153">   // set by GlodaDatastore</span>
<a href="#l10.154"></a><span id="l10.154">   _datastore: null,</span>
<a href="#l10.155"></a><span id="l10.155">   get id() { return this._id; },</span>
<a href="#l10.156"></a><span id="l10.156">   get subject() { return this._subject; },</span>
<a href="#l10.157"></a><span id="l10.157">   get oldestMessageDate() { return this._oldestMessageDate; },</span>
<a href="#l10.158"></a><span id="l10.158">   get newestMessageDate() { return this._newestMessageDate; },</span>
<a href="#l10.159"></a><span id="l10.159"> </span>
<a href="#l10.160"></a><span id="l10.160" class="difflineminus">-  getMessagesCollection: function gloda_conversation_getMessagesCollection(</span>
<a href="#l10.161"></a><span id="l10.161" class="difflineminus">-    aListener, aData) {</span>
<a href="#l10.162"></a><span id="l10.162" class="difflineplus">+  getMessagesCollection(aListener, aData) {</span>
<a href="#l10.163"></a><span id="l10.163">     let query = new GlodaMessage.prototype.NOUN_DEF.queryClass();</span>
<a href="#l10.164"></a><span id="l10.164">     query.conversation(this._id).orderBy(&quot;date&quot;);</span>
<a href="#l10.165"></a><span id="l10.165">     return query.getCollection(aListener, aData);</span>
<a href="#l10.166"></a><span id="l10.166">   },</span>
<a href="#l10.167"></a><span id="l10.167"> </span>
<a href="#l10.168"></a><span id="l10.168" class="difflineminus">-  toString: function gloda_conversation_toString() {</span>
<a href="#l10.169"></a><span id="l10.169" class="difflineplus">+  toString() {</span>
<a href="#l10.170"></a><span id="l10.170">     return &quot;Conversation:&quot; + this._id;</span>
<a href="#l10.171"></a><span id="l10.171">   },</span>
<a href="#l10.172"></a><span id="l10.172"> </span>
<a href="#l10.173"></a><span id="l10.173" class="difflineminus">-  toLocaleString: function gloda_conversation_toLocaleString() {</span>
<a href="#l10.174"></a><span id="l10.174" class="difflineplus">+  toLocaleString() {</span>
<a href="#l10.175"></a><span id="l10.175">     return this._subject;</span>
<a href="#l10.176"></a><span id="l10.176" class="difflineminus">-  }</span>
<a href="#l10.177"></a><span id="l10.177" class="difflineplus">+  },</span>
<a href="#l10.178"></a><span id="l10.178"> };</span>
<a href="#l10.179"></a><span id="l10.179"> </span>
<a href="#l10.180"></a><span id="l10.180"> function GlodaFolder(aDatastore, aID, aURI, aDirtyStatus, aPrettyName,</span>
<a href="#l10.181"></a><span id="l10.181">                      aIndexingPriority) {</span>
<a href="#l10.182"></a><span id="l10.182">   // _datastore is now set by GlodaDatastore</span>
<a href="#l10.183"></a><span id="l10.183">   this._id = aID;</span>
<a href="#l10.184"></a><span id="l10.184">   this._uri = aURI;</span>
<a href="#l10.185"></a><span id="l10.185">   this._dirtyStatus = aDirtyStatus;</span>
<a href="#l10.186"></a><span id="l10.186" class="difflineat">@@ -277,29 +269,28 @@ GlodaFolder.prototype = {</span>
<a href="#l10.187"></a><span id="l10.187">   get dirtyStatus() {</span>
<a href="#l10.188"></a><span id="l10.188">     return this._dirtyStatus &amp; this._kFolderDirtyStatusMask;</span>
<a href="#l10.189"></a><span id="l10.189">   },</span>
<a href="#l10.190"></a><span id="l10.190">   /**</span>
<a href="#l10.191"></a><span id="l10.191">    * Mark a folder as dirty if it was clean.  Do nothing if it was already dirty</span>
<a href="#l10.192"></a><span id="l10.192">    *  or filthy.  For use by GlodaMsgIndexer only.  And maybe rkent and his</span>
<a href="#l10.193"></a><span id="l10.193">    *  marvelous extensions.</span>
<a href="#l10.194"></a><span id="l10.194">    */</span>
<a href="#l10.195"></a><span id="l10.195" class="difflineminus">-  _ensureFolderDirty: function gloda_folder__markFolderDirty() {</span>
<a href="#l10.196"></a><span id="l10.196" class="difflineplus">+  _ensureFolderDirty() {</span>
<a href="#l10.197"></a><span id="l10.197">     if (this.dirtyStatus == this.kFolderClean) {</span>
<a href="#l10.198"></a><span id="l10.198">       this._dirtyStatus = (this.kFolderDirty &amp; this._kFolderDirtyStatusMask) |</span>
<a href="#l10.199"></a><span id="l10.199">                           (this._dirtyStatus &amp; ~this._kFolderDirtyStatusMask);</span>
<a href="#l10.200"></a><span id="l10.200">       this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l10.201"></a><span id="l10.201">     }</span>
<a href="#l10.202"></a><span id="l10.202">   },</span>
<a href="#l10.203"></a><span id="l10.203">   /**</span>
<a href="#l10.204"></a><span id="l10.204">    * Definitely for use only by GlodaMsgIndexer to downgrade the dirty status of</span>
<a href="#l10.205"></a><span id="l10.205">    *  a folder.</span>
<a href="#l10.206"></a><span id="l10.206">    */</span>
<a href="#l10.207"></a><span id="l10.207" class="difflineminus">-  _downgradeDirtyStatus: function gloda_folder__downgradeDirtyStatus(</span>
<a href="#l10.208"></a><span id="l10.208" class="difflineminus">-                           aNewStatus) {</span>
<a href="#l10.209"></a><span id="l10.209" class="difflineplus">+  _downgradeDirtyStatus(aNewStatus) {</span>
<a href="#l10.210"></a><span id="l10.210">     if (this.dirtyStatus != aNewStatus) {</span>
<a href="#l10.211"></a><span id="l10.211">       this._dirtyStatus = (aNewStatus &amp; this._kFolderDirtyStatusMask) |</span>
<a href="#l10.212"></a><span id="l10.212">                           (this._dirtyStatus &amp; ~this._kFolderDirtyStatusMask);</span>
<a href="#l10.213"></a><span id="l10.213">       this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l10.214"></a><span id="l10.214">     }</span>
<a href="#l10.215"></a><span id="l10.215">   },</span>
<a href="#l10.216"></a><span id="l10.216">   /**</span>
<a href="#l10.217"></a><span id="l10.217">    * Indicate whether this folder is currently being compacted.  The</span>
<a href="#l10.218"></a><span id="l10.218" class="difflineat">@@ -321,32 +312,32 @@ GlodaFolder.prototype = {</span>
<a href="#l10.219"></a><span id="l10.219">    */</span>
<a href="#l10.220"></a><span id="l10.220">   get compacted() {</span>
<a href="#l10.221"></a><span id="l10.221">     return Boolean(this._dirtyStatus &amp; this._kFolderCompactedFlag);</span>
<a href="#l10.222"></a><span id="l10.222">   },</span>
<a href="#l10.223"></a><span id="l10.223">   /**</span>
<a href="#l10.224"></a><span id="l10.224">    * For use only by GlodaMsgIndexer to set/clear the compaction state of this</span>
<a href="#l10.225"></a><span id="l10.225">    *  folder.</span>
<a href="#l10.226"></a><span id="l10.226">    */</span>
<a href="#l10.227"></a><span id="l10.227" class="difflineminus">-  _setCompactedState: function gloda_folder__clearCompactedState(aCompacted) {</span>
<a href="#l10.228"></a><span id="l10.228" class="difflineplus">+  _setCompactedState(aCompacted) {</span>
<a href="#l10.229"></a><span id="l10.229">     if (this.compacted != aCompacted) {</span>
<a href="#l10.230"></a><span id="l10.230">       if (aCompacted)</span>
<a href="#l10.231"></a><span id="l10.231">         this._dirtyStatus |= this._kFolderCompactedFlag;</span>
<a href="#l10.232"></a><span id="l10.232">       else</span>
<a href="#l10.233"></a><span id="l10.233">         this._dirtyStatus &amp;= ~this._kFolderCompactedFlag;</span>
<a href="#l10.234"></a><span id="l10.234">       this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l10.235"></a><span id="l10.235">     }</span>
<a href="#l10.236"></a><span id="l10.236">   },</span>
<a href="#l10.237"></a><span id="l10.237"> </span>
<a href="#l10.238"></a><span id="l10.238">   get name() { return this._prettyName; },</span>
<a href="#l10.239"></a><span id="l10.239" class="difflineminus">-  toString: function gloda_folder_toString() {</span>
<a href="#l10.240"></a><span id="l10.240" class="difflineplus">+  toString() {</span>
<a href="#l10.241"></a><span id="l10.241">     return &quot;Folder:&quot; + this._id;</span>
<a href="#l10.242"></a><span id="l10.242">   },</span>
<a href="#l10.243"></a><span id="l10.243"> </span>
<a href="#l10.244"></a><span id="l10.244" class="difflineminus">-  toLocaleString: function gloda_folder_toLocaleString() {</span>
<a href="#l10.245"></a><span id="l10.245" class="difflineplus">+  toLocaleString() {</span>
<a href="#l10.246"></a><span id="l10.246">     let xpcomFolder = this.getXPCOMFolder(this.kActivityFolderOnlyNoData);</span>
<a href="#l10.247"></a><span id="l10.247">     if (!xpcomFolder)</span>
<a href="#l10.248"></a><span id="l10.248">       return this._prettyName;</span>
<a href="#l10.249"></a><span id="l10.249">     return xpcomFolder.prettyName +</span>
<a href="#l10.250"></a><span id="l10.250">       &quot; (&quot; + xpcomFolder.rootFolder.prettyName + &quot;)&quot;;</span>
<a href="#l10.251"></a><span id="l10.251">   },</span>
<a href="#l10.252"></a><span id="l10.252"> </span>
<a href="#l10.253"></a><span id="l10.253">   get indexingPriority() {</span>
<a href="#l10.254"></a><span id="l10.254" class="difflineat">@@ -388,17 +379,17 @@ GlodaFolder.prototype = {</span>
<a href="#l10.255"></a><span id="l10.255">    * Retrieve the nsIMsgFolder instance corresponding to this folder, providing</span>
<a href="#l10.256"></a><span id="l10.256">    *  an explanation of why you are requesting it for tracking/cleanup purposes.</span>
<a href="#l10.257"></a><span id="l10.257">    *</span>
<a href="#l10.258"></a><span id="l10.258">    * @param aActivity One of the kActivity* constants.  If you pass</span>
<a href="#l10.259"></a><span id="l10.259">    *     kActivityIndexing, we will set indexing for you, but you will need to</span>
<a href="#l10.260"></a><span id="l10.260">    *     clear it when you are done.</span>
<a href="#l10.261"></a><span id="l10.261">    * @return The nsIMsgFolder if available, null on failure.</span>
<a href="#l10.262"></a><span id="l10.262">    */</span>
<a href="#l10.263"></a><span id="l10.263" class="difflineminus">-  getXPCOMFolder: function gloda_folder_getXPCOMFolder(aActivity) {</span>
<a href="#l10.264"></a><span id="l10.264" class="difflineplus">+  getXPCOMFolder(aActivity) {</span>
<a href="#l10.265"></a><span id="l10.265">     if (!this._xpcomFolder) {</span>
<a href="#l10.266"></a><span id="l10.266">       this._xpcomFolder = MailUtils.getExistingFolder(this.uri);</span>
<a href="#l10.267"></a><span id="l10.267">     }</span>
<a href="#l10.268"></a><span id="l10.268">     switch (aActivity) {</span>
<a href="#l10.269"></a><span id="l10.269">       case this.kActivityIndexing:</span>
<a href="#l10.270"></a><span id="l10.270">         // mark us as indexing, but don't bother with live tracking.  we do</span>
<a href="#l10.271"></a><span id="l10.271">         //  that independently and only for header retrieval.</span>
<a href="#l10.272"></a><span id="l10.272">         this.indexing = true;</span>
<a href="#l10.273"></a><span id="l10.273" class="difflineat">@@ -416,17 +407,17 @@ GlodaFolder.prototype = {</span>
<a href="#l10.274"></a><span id="l10.274">     return this._xpcomFolder;</span>
<a href="#l10.275"></a><span id="l10.275">   },</span>
<a href="#l10.276"></a><span id="l10.276"> </span>
<a href="#l10.277"></a><span id="l10.277">   /**</span>
<a href="#l10.278"></a><span id="l10.278">    * Retrieve a GlodaAccount instance corresponding to this folder.</span>
<a href="#l10.279"></a><span id="l10.279">    *</span>
<a href="#l10.280"></a><span id="l10.280">    * @return The GlodaAccount instance.</span>
<a href="#l10.281"></a><span id="l10.281">    */</span>
<a href="#l10.282"></a><span id="l10.282" class="difflineminus">-  getAccount: function gloda_folder_getAccount() {</span>
<a href="#l10.283"></a><span id="l10.283" class="difflineplus">+  getAccount() {</span>
<a href="#l10.284"></a><span id="l10.284">     if (!this._account) {</span>
<a href="#l10.285"></a><span id="l10.285">       let msgFolder = this.getXPCOMFolder(this.kActivityFolderOnlyNoData);</span>
<a href="#l10.286"></a><span id="l10.286">       this._account = new GlodaAccount(msgFolder.server);</span>
<a href="#l10.287"></a><span id="l10.287">     }</span>
<a href="#l10.288"></a><span id="l10.288">     return this._account;</span>
<a href="#l10.289"></a><span id="l10.289">   },</span>
<a href="#l10.290"></a><span id="l10.290"> </span>
<a href="#l10.291"></a><span id="l10.291">   /**</span>
<a href="#l10.292"></a><span id="l10.292" class="difflineat">@@ -446,17 +437,17 @@ GlodaFolder.prototype = {</span>
<a href="#l10.293"></a><span id="l10.293">    *  idempotent fashion.  (It is possible for disabling indexing's call to us</span>
<a href="#l10.294"></a><span id="l10.294">    *  to cause us to return true but for the datastore's timer call to have not</span>
<a href="#l10.295"></a><span id="l10.295">    *  yet triggered.)</span>
<a href="#l10.296"></a><span id="l10.296">    *</span>
<a href="#l10.297"></a><span id="l10.297">    * @returns true if we are cleaned up and can be considered 'dead', false if</span>
<a href="#l10.298"></a><span id="l10.298">    *     we should still be considered alive and this method should be called</span>
<a href="#l10.299"></a><span id="l10.299">    *     again in the future.</span>
<a href="#l10.300"></a><span id="l10.300">    */</span>
<a href="#l10.301"></a><span id="l10.301" class="difflineminus">-  forgetFolderIfUnused: function gloda_folder_forgetFolderIfUnused() {</span>
<a href="#l10.302"></a><span id="l10.302" class="difflineplus">+  forgetFolderIfUnused() {</span>
<a href="#l10.303"></a><span id="l10.303">     // we are not cleaning/cleaned up if we are indexing</span>
<a href="#l10.304"></a><span id="l10.304">     if (this._activeIndexing)</span>
<a href="#l10.305"></a><span id="l10.305">       return false;</span>
<a href="#l10.306"></a><span id="l10.306"> </span>
<a href="#l10.307"></a><span id="l10.307">     // set a point in the past as the threshold.  the timestamp must be older</span>
<a href="#l10.308"></a><span id="l10.308">     //  than this to be eligible for cleanup.</span>
<a href="#l10.309"></a><span id="l10.309">     let acceptablyOld = Date.now() - this.ACCEPTABLY_OLD_THRESHOLD;</span>
<a href="#l10.310"></a><span id="l10.310">     // we are not cleaning/cleaned up if we have retrieved a header more</span>
<a href="#l10.311"></a><span id="l10.311" class="difflineat">@@ -471,17 +462,17 @@ GlodaFolder.prototype = {</span>
<a href="#l10.312"></a><span id="l10.312">       this._xpcomFolder.msgDatabase = null;</span>
<a href="#l10.313"></a><span id="l10.313">       this._xpcomFolder = null;</span>
<a href="#l10.314"></a><span id="l10.314">       // since the last retrieval time tracks whether we have marked live or</span>
<a href="#l10.315"></a><span id="l10.315">       //  not, this needs to be reset to 0 too.</span>
<a href="#l10.316"></a><span id="l10.316">       this._activeHeaderRetrievalLastStamp = 0;</span>
<a href="#l10.317"></a><span id="l10.317">     }</span>
<a href="#l10.318"></a><span id="l10.318"> </span>
<a href="#l10.319"></a><span id="l10.319">     return true;</span>
<a href="#l10.320"></a><span id="l10.320" class="difflineminus">-  }</span>
<a href="#l10.321"></a><span id="l10.321" class="difflineplus">+  },</span>
<a href="#l10.322"></a><span id="l10.322"> };</span>
<a href="#l10.323"></a><span id="l10.323"> </span>
<a href="#l10.324"></a><span id="l10.324"> /**</span>
<a href="#l10.325"></a><span id="l10.325">  * @class A message representation.</span>
<a href="#l10.326"></a><span id="l10.326">  */</span>
<a href="#l10.327"></a><span id="l10.327"> function GlodaMessage(aDatastore, aID, aFolderID, aMessageKey,</span>
<a href="#l10.328"></a><span id="l10.328">                       aConversationID, aConversation, aDate,</span>
<a href="#l10.329"></a><span id="l10.329">                       aHeaderMessageID, aDeleted, aJsonText,</span>
<a href="#l10.330"></a><span id="l10.330" class="difflineat">@@ -529,85 +520,83 @@ GlodaMessage.prototype = {</span>
<a href="#l10.331"></a><span id="l10.331"> </span>
<a href="#l10.332"></a><span id="l10.332">   get folder() {</span>
<a href="#l10.333"></a><span id="l10.333">     // XXX due to a deletion bug it is currently possible to get in a state</span>
<a href="#l10.334"></a><span id="l10.334">     //  where we have an illegal folderID value.  This will result in an</span>
<a href="#l10.335"></a><span id="l10.335">     //  exception.  As a workaround, let's just return null in that case.</span>
<a href="#l10.336"></a><span id="l10.336">     try {</span>
<a href="#l10.337"></a><span id="l10.337">       if (this._folderID != null)</span>
<a href="#l10.338"></a><span id="l10.338">         return this._datastore._mapFolderID(this._folderID);</span>
<a href="#l10.339"></a><span id="l10.339" class="difflineminus">-    }</span>
<a href="#l10.340"></a><span id="l10.340" class="difflineminus">-    catch (ex) {</span>
<a href="#l10.341"></a><span id="l10.341" class="difflineplus">+    } catch (ex) {</span>
<a href="#l10.342"></a><span id="l10.342">     }</span>
<a href="#l10.343"></a><span id="l10.343">     return null;</span>
<a href="#l10.344"></a><span id="l10.344">   },</span>
<a href="#l10.345"></a><span id="l10.345">   get folderURI() {</span>
<a href="#l10.346"></a><span id="l10.346">     // XXX just like for folder, handle mapping failures and return null</span>
<a href="#l10.347"></a><span id="l10.347">     try {</span>
<a href="#l10.348"></a><span id="l10.348">       if (this._folderID != null)</span>
<a href="#l10.349"></a><span id="l10.349">         return this._datastore._mapFolderID(this._folderID).uri;</span>
<a href="#l10.350"></a><span id="l10.350" class="difflineminus">-    }</span>
<a href="#l10.351"></a><span id="l10.351" class="difflineminus">-    catch (ex) {</span>
<a href="#l10.352"></a><span id="l10.352" class="difflineplus">+    } catch (ex) {</span>
<a href="#l10.353"></a><span id="l10.353">     }</span>
<a href="#l10.354"></a><span id="l10.354">     return null;</span>
<a href="#l10.355"></a><span id="l10.355">   },</span>
<a href="#l10.356"></a><span id="l10.356">   get account() {</span>
<a href="#l10.357"></a><span id="l10.357">     // XXX due to a deletion bug it is currently possible to get in a state</span>
<a href="#l10.358"></a><span id="l10.358">     //  where we have an illegal folderID value.  This will result in an</span>
<a href="#l10.359"></a><span id="l10.359">     //  exception.  As a workaround, let's just return null in that case.</span>
<a href="#l10.360"></a><span id="l10.360">     try {</span>
<a href="#l10.361"></a><span id="l10.361">       if (this._folderID == null)</span>
<a href="#l10.362"></a><span id="l10.362">         return null;</span>
<a href="#l10.363"></a><span id="l10.363">       let folder = this._datastore._mapFolderID(this._folderID);</span>
<a href="#l10.364"></a><span id="l10.364">       return folder.getAccount();</span>
<a href="#l10.365"></a><span id="l10.365" class="difflineplus">+    } catch (ex) {</span>
<a href="#l10.366"></a><span id="l10.366">     }</span>
<a href="#l10.367"></a><span id="l10.367" class="difflineminus">-    catch (ex) { }</span>
<a href="#l10.368"></a><span id="l10.368">     return null;</span>
<a href="#l10.369"></a><span id="l10.369">   },</span>
<a href="#l10.370"></a><span id="l10.370">   get conversation() {</span>
<a href="#l10.371"></a><span id="l10.371">     return this._conversation;</span>
<a href="#l10.372"></a><span id="l10.372">   },</span>
<a href="#l10.373"></a><span id="l10.373"> </span>
<a href="#l10.374"></a><span id="l10.374" class="difflineminus">-  toString: function gloda_message_toString() {</span>
<a href="#l10.375"></a><span id="l10.375" class="difflineplus">+  toString() {</span>
<a href="#l10.376"></a><span id="l10.376">     // uh, this is a tough one...</span>
<a href="#l10.377"></a><span id="l10.377">     return &quot;Message:&quot; + this._id;</span>
<a href="#l10.378"></a><span id="l10.378">   },</span>
<a href="#l10.379"></a><span id="l10.379"> </span>
<a href="#l10.380"></a><span id="l10.380" class="difflineminus">-  _clone: function gloda_message_clone() {</span>
<a href="#l10.381"></a><span id="l10.381" class="difflineplus">+  _clone() {</span>
<a href="#l10.382"></a><span id="l10.382">     return new GlodaMessage(/* datastore */ null, this._id, this._folderID,</span>
<a href="#l10.383"></a><span id="l10.383">       this._messageKey, this._conversationID, this._conversation, this._date,</span>
<a href="#l10.384"></a><span id="l10.384">       this._headerMessageID, &quot;_deleted&quot; in this ? this._deleted : undefined,</span>
<a href="#l10.385"></a><span id="l10.385">       &quot;_jsonText&quot; in this ? this._jsonText : undefined, this._notability,</span>
<a href="#l10.386"></a><span id="l10.386">       this._subject, this._indexedBodyText, this._attachmentNames);</span>
<a href="#l10.387"></a><span id="l10.387">   },</span>
<a href="#l10.388"></a><span id="l10.388"> </span>
<a href="#l10.389"></a><span id="l10.389">   /**</span>
<a href="#l10.390"></a><span id="l10.390">    * Provide a means of propagating changed values on our clone back to</span>
<a href="#l10.391"></a><span id="l10.391">    *  ourselves.  This is required because of an object identity trick gloda</span>
<a href="#l10.392"></a><span id="l10.392">    *  does; when indexing an already existing object, all mutations happen on</span>
<a href="#l10.393"></a><span id="l10.393">    *  a clone of the existing object so that</span>
<a href="#l10.394"></a><span id="l10.394">    */</span>
<a href="#l10.395"></a><span id="l10.395" class="difflineminus">-  _declone: function gloda_message_declone(aOther) {</span>
<a href="#l10.396"></a><span id="l10.396" class="difflineplus">+  _declone(aOther) {</span>
<a href="#l10.397"></a><span id="l10.397">     if (&quot;_content&quot; in aOther)</span>
<a href="#l10.398"></a><span id="l10.398">       this._content = aOther._content;</span>
<a href="#l10.399"></a><span id="l10.399"> </span>
<a href="#l10.400"></a><span id="l10.400">     // The _indexedAuthor/_indexedRecipients fields don't get updated on</span>
<a href="#l10.401"></a><span id="l10.401">     //  fulltext update so we don't need to propagate.</span>
<a href="#l10.402"></a><span id="l10.402">     this._indexedBodyText = aOther._indexedBodyText;</span>
<a href="#l10.403"></a><span id="l10.403">     this._attachmentNames = aOther._attachmentNames;</span>
<a href="#l10.404"></a><span id="l10.404">   },</span>
<a href="#l10.405"></a><span id="l10.405"> </span>
<a href="#l10.406"></a><span id="l10.406">   /**</span>
<a href="#l10.407"></a><span id="l10.407">    * Mark this message as a ghost.  Ghosts are characterized by having no folder</span>
<a href="#l10.408"></a><span id="l10.408">    *  id and no message key.  They also are not deleted or they would be of</span>
<a href="#l10.409"></a><span id="l10.409">    *  absolutely no use to us.</span>
<a href="#l10.410"></a><span id="l10.410">    *</span>
<a href="#l10.411"></a><span id="l10.411">    * These changes are suitable for persistence.</span>
<a href="#l10.412"></a><span id="l10.412">    */</span>
<a href="#l10.413"></a><span id="l10.413" class="difflineminus">-  _ghost: function gloda_message_ghost() {</span>
<a href="#l10.414"></a><span id="l10.414" class="difflineplus">+  _ghost() {</span>
<a href="#l10.415"></a><span id="l10.415">     this._folderID = null;</span>
<a href="#l10.416"></a><span id="l10.416">     this._messageKey = null;</span>
<a href="#l10.417"></a><span id="l10.417">     if (&quot;_deleted&quot; in this)</span>
<a href="#l10.418"></a><span id="l10.418">       delete this._deleted;</span>
<a href="#l10.419"></a><span id="l10.419">   },</span>
<a href="#l10.420"></a><span id="l10.420"> </span>
<a href="#l10.421"></a><span id="l10.421">   /**</span>
<a href="#l10.422"></a><span id="l10.422">    * Are we a ghost (which implies not deleted)?  We are not a ghost if we have</span>
<a href="#l10.423"></a><span id="l10.423" class="difflineat">@@ -616,17 +605,17 @@ GlodaMessage.prototype = {</span>
<a href="#l10.424"></a><span id="l10.424">    */</span>
<a href="#l10.425"></a><span id="l10.425">   get _isGhost() {</span>
<a href="#l10.426"></a><span id="l10.426">     return this._folderID == null &amp;&amp; !this._isDeleted;</span>
<a href="#l10.427"></a><span id="l10.427">   },</span>
<a href="#l10.428"></a><span id="l10.428"> </span>
<a href="#l10.429"></a><span id="l10.429">   /**</span>
<a href="#l10.430"></a><span id="l10.430">    * If we were dead, un-dead us.</span>
<a href="#l10.431"></a><span id="l10.431">    */</span>
<a href="#l10.432"></a><span id="l10.432" class="difflineminus">-  _ensureNotDeleted: function gloda_message__ensureNotDeleted() {</span>
<a href="#l10.433"></a><span id="l10.433" class="difflineplus">+  _ensureNotDeleted() {</span>
<a href="#l10.434"></a><span id="l10.434">     if (&quot;_deleted&quot; in this)</span>
<a href="#l10.435"></a><span id="l10.435">       delete this._deleted;</span>
<a href="#l10.436"></a><span id="l10.436">   },</span>
<a href="#l10.437"></a><span id="l10.437"> </span>
<a href="#l10.438"></a><span id="l10.438">   /**</span>
<a href="#l10.439"></a><span id="l10.439">    * Are we deleted?  This is private because deleted gloda messages are not</span>
<a href="#l10.440"></a><span id="l10.440">    *  visible to non-core-gloda code.</span>
<a href="#l10.441"></a><span id="l10.441">    */</span>
<a href="#l10.442"></a><span id="l10.442" class="difflineat">@@ -634,17 +623,17 @@ GlodaMessage.prototype = {</span>
<a href="#l10.443"></a><span id="l10.443">     return (&quot;_deleted&quot; in this) &amp;&amp; this._deleted;</span>
<a href="#l10.444"></a><span id="l10.444">   },</span>
<a href="#l10.445"></a><span id="l10.445"> </span>
<a href="#l10.446"></a><span id="l10.446">   /**</span>
<a href="#l10.447"></a><span id="l10.447">    * Trash this message's in-memory representation because it should no longer</span>
<a href="#l10.448"></a><span id="l10.448">    *  be reachable by any code.  The database record is gone, it's not coming</span>
<a href="#l10.449"></a><span id="l10.449">    *  back.</span>
<a href="#l10.450"></a><span id="l10.450">    */</span>
<a href="#l10.451"></a><span id="l10.451" class="difflineminus">-  _objectPurgedMakeYourselfUnpleasant: function gloda_message_nuke() {</span>
<a href="#l10.452"></a><span id="l10.452" class="difflineplus">+  _objectPurgedMakeYourselfUnpleasant() {</span>
<a href="#l10.453"></a><span id="l10.453">     this._id = null;</span>
<a href="#l10.454"></a><span id="l10.454">     this._folderID = null;</span>
<a href="#l10.455"></a><span id="l10.455">     this._messageKey = null;</span>
<a href="#l10.456"></a><span id="l10.456">     this._conversationID = null;</span>
<a href="#l10.457"></a><span id="l10.457">     this._conversation = null;</span>
<a href="#l10.458"></a><span id="l10.458">     this.date = null;</span>
<a href="#l10.459"></a><span id="l10.459">     this._headerMessageID = null;</span>
<a href="#l10.460"></a><span id="l10.460">   },</span>
<a href="#l10.461"></a><span id="l10.461" class="difflineat">@@ -670,28 +659,26 @@ GlodaMessage.prototype = {</span>
<a href="#l10.462"></a><span id="l10.462">   get folderMessage() {</span>
<a href="#l10.463"></a><span id="l10.463">     if (this._folderID === null || this._messageKey === null)</span>
<a href="#l10.464"></a><span id="l10.464">       return null;</span>
<a href="#l10.465"></a><span id="l10.465"> </span>
<a href="#l10.466"></a><span id="l10.466">     // XXX like for folder and folderURI, return null if we can't map the folder</span>
<a href="#l10.467"></a><span id="l10.467">     let glodaFolder;</span>
<a href="#l10.468"></a><span id="l10.468">     try {</span>
<a href="#l10.469"></a><span id="l10.469">       glodaFolder = this._datastore._mapFolderID(this._folderID);</span>
<a href="#l10.470"></a><span id="l10.470" class="difflineminus">-    }</span>
<a href="#l10.471"></a><span id="l10.471" class="difflineminus">-    catch (ex) {</span>
<a href="#l10.472"></a><span id="l10.472" class="difflineplus">+    } catch (ex) {</span>
<a href="#l10.473"></a><span id="l10.473">       return null;</span>
<a href="#l10.474"></a><span id="l10.474">     }</span>
<a href="#l10.475"></a><span id="l10.475">     let folder = glodaFolder.getXPCOMFolder(</span>
<a href="#l10.476"></a><span id="l10.476">                    glodaFolder.kActivityHeaderRetrieval);</span>
<a href="#l10.477"></a><span id="l10.477">     if (folder) {</span>
<a href="#l10.478"></a><span id="l10.478">       let folderMessage;</span>
<a href="#l10.479"></a><span id="l10.479">       try {</span>
<a href="#l10.480"></a><span id="l10.480">         folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l10.481"></a><span id="l10.481" class="difflineminus">-      }</span>
<a href="#l10.482"></a><span id="l10.482" class="difflineminus">-      catch (ex) {</span>
<a href="#l10.483"></a><span id="l10.483" class="difflineplus">+      } catch (ex) {</span>
<a href="#l10.484"></a><span id="l10.484">         folderMessage = null;</span>
<a href="#l10.485"></a><span id="l10.485">       }</span>
<a href="#l10.486"></a><span id="l10.486">       if (folderMessage !== null) {</span>
<a href="#l10.487"></a><span id="l10.487">         // verify the message-id header matches what we expect...</span>
<a href="#l10.488"></a><span id="l10.488">         if (folderMessage.messageId != this._headerMessageID) {</span>
<a href="#l10.489"></a><span id="l10.489">           LOG.info(&quot;Message with message key &quot; + this._messageKey +</span>
<a href="#l10.490"></a><span id="l10.490">                    &quot; in folder '&quot; + folder.URI + &quot;' does not match expected &quot; +</span>
<a href="#l10.491"></a><span id="l10.491">                    &quot;header! (&quot; + this._headerMessageID + &quot; expected, got &quot; +</span>
<a href="#l10.492"></a><span id="l10.492" class="difflineat">@@ -708,19 +695,18 @@ GlodaMessage.prototype = {</span>
<a href="#l10.493"></a><span id="l10.493">     LOG.info(&quot;Unable to locate folder message for: &quot; + this._folderID + &quot;:&quot; +</span>
<a href="#l10.494"></a><span id="l10.494">              this._messageKey);</span>
<a href="#l10.495"></a><span id="l10.495">     return null;</span>
<a href="#l10.496"></a><span id="l10.496">   },</span>
<a href="#l10.497"></a><span id="l10.497">   get folderMessageURI() {</span>
<a href="#l10.498"></a><span id="l10.498">     let folderMessage = this.folderMessage;</span>
<a href="#l10.499"></a><span id="l10.499">     if (folderMessage)</span>
<a href="#l10.500"></a><span id="l10.500">       return folderMessage.folder.getUriForMsg(folderMessage);</span>
<a href="#l10.501"></a><span id="l10.501" class="difflineminus">-    else</span>
<a href="#l10.502"></a><span id="l10.502" class="difflineminus">-      return null;</span>
<a href="#l10.503"></a><span id="l10.503" class="difflineminus">-  }</span>
<a href="#l10.504"></a><span id="l10.504" class="difflineplus">+    return null;</span>
<a href="#l10.505"></a><span id="l10.505" class="difflineplus">+  },</span>
<a href="#l10.506"></a><span id="l10.506"> };</span>
<a href="#l10.507"></a><span id="l10.507"> MixIn(GlodaMessage, GlodaHasAttributesMixIn);</span>
<a href="#l10.508"></a><span id="l10.508"> </span>
<a href="#l10.509"></a><span id="l10.509"> /**</span>
<a href="#l10.510"></a><span id="l10.510">  * @class Contacts correspond to people (one per person), and may own multiple</span>
<a href="#l10.511"></a><span id="l10.511">  *  identities (e-mail address, IM account, etc.)</span>
<a href="#l10.512"></a><span id="l10.512">  */</span>
<a href="#l10.513"></a><span id="l10.513"> function GlodaContact(aDatastore, aID, aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l10.514"></a><span id="l10.514" class="difflineat">@@ -760,25 +746,25 @@ GlodaContact.prototype = {</span>
<a href="#l10.515"></a><span id="l10.515">     this._frecency = aFrecency;</span>
<a href="#l10.516"></a><span id="l10.516">     this.dirty = true;</span>
<a href="#l10.517"></a><span id="l10.517">   },</span>
<a href="#l10.518"></a><span id="l10.518"> </span>
<a href="#l10.519"></a><span id="l10.519">   get identities() {</span>
<a href="#l10.520"></a><span id="l10.520">     return this._identities;</span>
<a href="#l10.521"></a><span id="l10.521">   },</span>
<a href="#l10.522"></a><span id="l10.522"> </span>
<a href="#l10.523"></a><span id="l10.523" class="difflineminus">-  toString: function gloda_contact_toString() {</span>
<a href="#l10.524"></a><span id="l10.524" class="difflineplus">+  toString() {</span>
<a href="#l10.525"></a><span id="l10.525">     return &quot;Contact:&quot; + this._id;</span>
<a href="#l10.526"></a><span id="l10.526">   },</span>
<a href="#l10.527"></a><span id="l10.527"> </span>
<a href="#l10.528"></a><span id="l10.528">   get accessibleLabel() {</span>
<a href="#l10.529"></a><span id="l10.529">     return &quot;Contact: &quot; + this._name;</span>
<a href="#l10.530"></a><span id="l10.530">   },</span>
<a href="#l10.531"></a><span id="l10.531"> </span>
<a href="#l10.532"></a><span id="l10.532" class="difflineminus">-  _clone: function gloda_contact_clone() {</span>
<a href="#l10.533"></a><span id="l10.533" class="difflineplus">+  _clone() {</span>
<a href="#l10.534"></a><span id="l10.534">     return new GlodaContact(/* datastore */ null, this._id, this._directoryUUID,</span>
<a href="#l10.535"></a><span id="l10.535">       this._contactUUID, this._name, this._popularity, this._frecency);</span>
<a href="#l10.536"></a><span id="l10.536">   },</span>
<a href="#l10.537"></a><span id="l10.537"> };</span>
<a href="#l10.538"></a><span id="l10.538"> MixIn(GlodaContact, GlodaHasAttributesMixIn);</span>
<a href="#l10.539"></a><span id="l10.539"> </span>
<a href="#l10.540"></a><span id="l10.540"> </span>
<a href="#l10.541"></a><span id="l10.541"> /**</span>
<a href="#l10.542"></a><span id="l10.542" class="difflineat">@@ -789,19 +775,19 @@ function GlodaIdentity(aDatastore, aID, </span>
<a href="#l10.543"></a><span id="l10.543">   // _datastore set on the prototype by GlodaDatastore</span>
<a href="#l10.544"></a><span id="l10.544">   this._id = aID;</span>
<a href="#l10.545"></a><span id="l10.545">   this._contactID = aContactID;</span>
<a href="#l10.546"></a><span id="l10.546">   this._contact = aContact;</span>
<a href="#l10.547"></a><span id="l10.547">   this._kind = aKind;</span>
<a href="#l10.548"></a><span id="l10.548">   this._value = aValue;</span>
<a href="#l10.549"></a><span id="l10.549">   this._description = aDescription;</span>
<a href="#l10.550"></a><span id="l10.550">   this._isRelay = aIsRelay;</span>
<a href="#l10.551"></a><span id="l10.551" class="difflineminus">-  /// Cached indication of whether there is an address book card for this</span>
<a href="#l10.552"></a><span id="l10.552" class="difflineminus">-  ///  identity.  We keep this up-to-date via address book listener</span>
<a href="#l10.553"></a><span id="l10.553" class="difflineminus">-  ///  notifications in |GlodaABIndexer|.</span>
<a href="#l10.554"></a><span id="l10.554" class="difflineplus">+  // Cached indication of whether there is an address book card for this</span>
<a href="#l10.555"></a><span id="l10.555" class="difflineplus">+  //  identity.  We keep this up-to-date via address book listener</span>
<a href="#l10.556"></a><span id="l10.556" class="difflineplus">+  //  notifications in |GlodaABIndexer|.</span>
<a href="#l10.557"></a><span id="l10.557">   this._hasAddressBookCard = undefined;</span>
<a href="#l10.558"></a><span id="l10.558"> }</span>
<a href="#l10.559"></a><span id="l10.559"> </span>
<a href="#l10.560"></a><span id="l10.560"> GlodaIdentity.prototype = {</span>
<a href="#l10.561"></a><span id="l10.561">   NOUN_ID: 104,</span>
<a href="#l10.562"></a><span id="l10.562">   // set by GlodaDatastore</span>
<a href="#l10.563"></a><span id="l10.563">   _datastore: null,</span>
<a href="#l10.564"></a><span id="l10.564">   get id() { return this._id; },</span>
<a href="#l10.565"></a><span id="l10.565" class="difflineat">@@ -811,21 +797,21 @@ GlodaIdentity.prototype = {</span>
<a href="#l10.566"></a><span id="l10.566">   get value() { return this._value; },</span>
<a href="#l10.567"></a><span id="l10.567">   get description() { return this._description; },</span>
<a href="#l10.568"></a><span id="l10.568">   get isRelay() { return this._isRelay; },</span>
<a href="#l10.569"></a><span id="l10.569"> </span>
<a href="#l10.570"></a><span id="l10.570">   get uniqueValue() {</span>
<a href="#l10.571"></a><span id="l10.571">     return this._kind + &quot;@&quot; + this._value;</span>
<a href="#l10.572"></a><span id="l10.572">   },</span>
<a href="#l10.573"></a><span id="l10.573"> </span>
<a href="#l10.574"></a><span id="l10.574" class="difflineminus">-  toString: function gloda_identity_toString() {</span>
<a href="#l10.575"></a><span id="l10.575" class="difflineplus">+  toString() {</span>
<a href="#l10.576"></a><span id="l10.576">     return &quot;Identity:&quot; + this._kind + &quot;:&quot; + this._value;</span>
<a href="#l10.577"></a><span id="l10.577">   },</span>
<a href="#l10.578"></a><span id="l10.578"> </span>
<a href="#l10.579"></a><span id="l10.579" class="difflineminus">-  toLocaleString: function gloda_identity_toLocaleString() {</span>
<a href="#l10.580"></a><span id="l10.580" class="difflineplus">+  toLocaleString() {</span>
<a href="#l10.581"></a><span id="l10.581">     if (this.contact.name == this.value)</span>
<a href="#l10.582"></a><span id="l10.582">       return this.value;</span>
<a href="#l10.583"></a><span id="l10.583">     return this.contact.name + &quot; : &quot; + this.value;</span>
<a href="#l10.584"></a><span id="l10.584">   },</span>
<a href="#l10.585"></a><span id="l10.585"> </span>
<a href="#l10.586"></a><span id="l10.586">   get abCard() {</span>
<a href="#l10.587"></a><span id="l10.587">     // for our purposes, the address book only speaks email</span>
<a href="#l10.588"></a><span id="l10.588">     if (this._kind != &quot;email&quot;)</span>
<a href="#l10.589"></a><span id="l10.589" class="difflineat">@@ -841,22 +827,22 @@ GlodaIdentity.prototype = {</span>
<a href="#l10.590"></a><span id="l10.590">    *  and its notifications.</span>
<a href="#l10.591"></a><span id="l10.591">    */</span>
<a href="#l10.592"></a><span id="l10.592">   get inAddressBook() {</span>
<a href="#l10.593"></a><span id="l10.593">     if (this._hasAddressBookCard !== undefined)</span>
<a href="#l10.594"></a><span id="l10.594">       return this._hasAddressBookCard;</span>
<a href="#l10.595"></a><span id="l10.595">     return (this.abCard &amp;&amp; true) || false;</span>
<a href="#l10.596"></a><span id="l10.596">   },</span>
<a href="#l10.597"></a><span id="l10.597"> </span>
<a href="#l10.598"></a><span id="l10.598" class="difflineminus">-  pictureURL: function(aSize) {</span>
<a href="#l10.599"></a><span id="l10.599" class="difflineplus">+  pictureURL(aSize) {</span>
<a href="#l10.600"></a><span id="l10.600">     if (this.inAddressBook) {</span>
<a href="#l10.601"></a><span id="l10.601">       // XXX should get the photo if we have it.</span>
<a href="#l10.602"></a><span id="l10.602">     }</span>
<a href="#l10.603"></a><span id="l10.603">     return &quot;&quot;;</span>
<a href="#l10.604"></a><span id="l10.604" class="difflineminus">-  }</span>
<a href="#l10.605"></a><span id="l10.605" class="difflineplus">+  },</span>
<a href="#l10.606"></a><span id="l10.606"> };</span>
<a href="#l10.607"></a><span id="l10.607"> </span>
<a href="#l10.608"></a><span id="l10.608"> </span>
<a href="#l10.609"></a><span id="l10.609"> /**</span>
<a href="#l10.610"></a><span id="l10.610">  * An attachment, with as much information as we can gather on it</span>
<a href="#l10.611"></a><span id="l10.611">  */</span>
<a href="#l10.612"></a><span id="l10.612"> function GlodaAttachment(aGlodaMessage, aName, aContentType, aSize, aPart, aExternalUrl, aIsExternal) {</span>
<a href="#l10.613"></a><span id="l10.613">   // _datastore set on the prototype by GlodaDatastore</span>
<a href="#l10.614"></a><span id="l10.614" class="difflineat">@@ -873,28 +859,26 @@ GlodaAttachment.prototype = {</span>
<a href="#l10.615"></a><span id="l10.615">   NOUN_ID: 105,</span>
<a href="#l10.616"></a><span id="l10.616">   // set by GlodaDatastore</span>
<a href="#l10.617"></a><span id="l10.617">   get name() { return this._name; },</span>
<a href="#l10.618"></a><span id="l10.618">   get contentType() { return this._contentType; },</span>
<a href="#l10.619"></a><span id="l10.619">   get size() { return this._size; },</span>
<a href="#l10.620"></a><span id="l10.620">   get url() {</span>
<a href="#l10.621"></a><span id="l10.621">     if (this.isExternal)</span>
<a href="#l10.622"></a><span id="l10.622">       return this._externalUrl;</span>
<a href="#l10.623"></a><span id="l10.623" class="difflineminus">-    else {</span>
<a href="#l10.624"></a><span id="l10.624" class="difflineminus">-      let uri = this._glodaMessage.folderMessageURI;</span>
<a href="#l10.625"></a><span id="l10.625" class="difflineminus">-      if (!uri)</span>
<a href="#l10.626"></a><span id="l10.626" class="difflineminus">-        throw new Error(&quot;The message doesn't exist anymore, unable to rebuild attachment URL&quot;);</span>
<a href="#l10.627"></a><span id="l10.627" class="difflineminus">-      let neckoURL = {};</span>
<a href="#l10.628"></a><span id="l10.628" class="difflineminus">-      let msgService = getMessenger().messageServiceFromURI(uri);</span>
<a href="#l10.629"></a><span id="l10.629" class="difflineminus">-      msgService.GetUrlForUri(uri, neckoURL, null);</span>
<a href="#l10.630"></a><span id="l10.630" class="difflineminus">-      let url = neckoURL.value.spec;</span>
<a href="#l10.631"></a><span id="l10.631" class="difflineminus">-      let hasParamAlready = url.match(/\?[a-z]+=[^\/]+$/);</span>
<a href="#l10.632"></a><span id="l10.632" class="difflineminus">-      let sep = hasParamAlready ? &quot;&amp;&quot; : &quot;?&quot;;</span>
<a href="#l10.633"></a><span id="l10.633" class="difflineminus">-      return url+sep+&quot;part=&quot;+this._part+&quot;&amp;filename=&quot;+encodeURIComponent(this._name);</span>
<a href="#l10.634"></a><span id="l10.634" class="difflineminus">-    }</span>
<a href="#l10.635"></a><span id="l10.635" class="difflineplus">+</span>
<a href="#l10.636"></a><span id="l10.636" class="difflineplus">+    let uri = this._glodaMessage.folderMessageURI;</span>
<a href="#l10.637"></a><span id="l10.637" class="difflineplus">+    if (!uri)</span>
<a href="#l10.638"></a><span id="l10.638" class="difflineplus">+      throw new Error(&quot;The message doesn't exist anymore, unable to rebuild attachment URL&quot;);</span>
<a href="#l10.639"></a><span id="l10.639" class="difflineplus">+    let neckoURL = {};</span>
<a href="#l10.640"></a><span id="l10.640" class="difflineplus">+    let msgService = getMessenger().messageServiceFromURI(uri);</span>
<a href="#l10.641"></a><span id="l10.641" class="difflineplus">+    msgService.GetUrlForUri(uri, neckoURL, null);</span>
<a href="#l10.642"></a><span id="l10.642" class="difflineplus">+    let url = neckoURL.value.spec;</span>
<a href="#l10.643"></a><span id="l10.643" class="difflineplus">+    let hasParamAlready = url.match(/\?[a-z]+=[^\/]+$/);</span>
<a href="#l10.644"></a><span id="l10.644" class="difflineplus">+    let sep = hasParamAlready ? &quot;&amp;&quot; : &quot;?&quot;;</span>
<a href="#l10.645"></a><span id="l10.645" class="difflineplus">+    return url + sep + &quot;part=&quot; + this._part + &quot;&amp;filename=&quot; + encodeURIComponent(this._name);</span>
<a href="#l10.646"></a><span id="l10.646">   },</span>
<a href="#l10.647"></a><span id="l10.647">   get isExternal() { return this._isExternal; },</span>
<a href="#l10.648"></a><span id="l10.648"> </span>
<a href="#l10.649"></a><span id="l10.649" class="difflineminus">-  toString: function gloda_attachment_toString() {</span>
<a href="#l10.650"></a><span id="l10.650" class="difflineplus">+  toString() {</span>
<a href="#l10.651"></a><span id="l10.651">     return &quot;attachment: &quot; + this._name + &quot;:&quot; + this._contentType;</span>
<a href="#l10.652"></a><span id="l10.652">   },</span>
<a href="#l10.653"></a><span id="l10.653" class="difflineminus">-</span>
<a href="#l10.654"></a><span id="l10.654"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -36,47 +36,44 @@ var PCH_LOG = Log4Moz.repository.getLogg</span>
<a href="#l11.4"></a><span id="l11.4">  *  |GlodaDatastore._asyncCompleted|.</span>
<a href="#l11.5"></a><span id="l11.5">  */</span>
<a href="#l11.6"></a><span id="l11.6"> function PostCommitHandler(aCallbacks) {</span>
<a href="#l11.7"></a><span id="l11.7">   this.callbacks = aCallbacks;</span>
<a href="#l11.8"></a><span id="l11.8">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l11.9"></a><span id="l11.9"> }</span>
<a href="#l11.10"></a><span id="l11.10"> </span>
<a href="#l11.11"></a><span id="l11.11"> PostCommitHandler.prototype = {</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-  handleResult: function gloda_ds_pch_handleResult(aResultSet) {</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+  handleResult(aResultSet) {</span>
<a href="#l11.14"></a><span id="l11.14">   },</span>
<a href="#l11.15"></a><span id="l11.15"> </span>
<a href="#l11.16"></a><span id="l11.16" class="difflineminus">-  handleError: function gloda_ds_pch_handleError(aError) {</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineplus">+  handleError(aError) {</span>
<a href="#l11.18"></a><span id="l11.18">     PCH_LOG.error(&quot;database error:&quot; + aError);</span>
<a href="#l11.19"></a><span id="l11.19">   },</span>
<a href="#l11.20"></a><span id="l11.20"> </span>
<a href="#l11.21"></a><span id="l11.21" class="difflineminus">-  handleCompletion: function gloda_ds_pch_handleCompletion(aReason) {</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+  handleCompletion(aReason) {</span>
<a href="#l11.23"></a><span id="l11.23">     // just outright bail if we are shutdown</span>
<a href="#l11.24"></a><span id="l11.24">     if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l11.25"></a><span id="l11.25">       return;</span>
<a href="#l11.26"></a><span id="l11.26"> </span>
<a href="#l11.27"></a><span id="l11.27">     if (aReason == Ci.mozIStorageStatementCallback.REASON_FINISHED) {</span>
<a href="#l11.28"></a><span id="l11.28">       for (let callback of this.callbacks) {</span>
<a href="#l11.29"></a><span id="l11.29">         try {</span>
<a href="#l11.30"></a><span id="l11.30">           callback();</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineminus">-        }</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineminus">-        catch (ex) {</span>
<a href="#l11.33"></a><span id="l11.33" class="difflineplus">+        } catch (ex) {</span>
<a href="#l11.34"></a><span id="l11.34">           PCH_LOG.error(&quot;PostCommitHandler callback (&quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l11.35"></a><span id="l11.35">                ex.lineNumber + &quot;) threw: &quot; + ex);</span>
<a href="#l11.36"></a><span id="l11.36">         }</span>
<a href="#l11.37"></a><span id="l11.37">       }</span>
<a href="#l11.38"></a><span id="l11.38">     }</span>
<a href="#l11.39"></a><span id="l11.39">     try {</span>
<a href="#l11.40"></a><span id="l11.40">       GlodaDatastore._asyncCompleted();</span>
<a href="#l11.41"></a><span id="l11.41" class="difflineminus">-    }</span>
<a href="#l11.42"></a><span id="l11.42" class="difflineminus">-    catch (e) {</span>
<a href="#l11.43"></a><span id="l11.43" class="difflineplus">+    } catch (e) {</span>
<a href="#l11.44"></a><span id="l11.44">       PCH_LOG.error(&quot;Exception in handleCompletion:&quot;, e);</span>
<a href="#l11.45"></a><span id="l11.45">     }</span>
<a href="#l11.46"></a><span id="l11.46" class="difflineminus">-</span>
<a href="#l11.47"></a><span id="l11.47" class="difflineminus">-  }</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineplus">+  },</span>
<a href="#l11.49"></a><span id="l11.49"> };</span>
<a href="#l11.50"></a><span id="l11.50"> </span>
<a href="#l11.51"></a><span id="l11.51"> var QFQ_LOG = Log4Moz.repository.getLogger(&quot;gloda.ds.qfq&quot;);</span>
<a href="#l11.52"></a><span id="l11.52"> </span>
<a href="#l11.53"></a><span id="l11.53"> /**</span>
<a href="#l11.54"></a><span id="l11.54">  * Singleton collection listener used by |QueryFromQueryCallback| to assist in</span>
<a href="#l11.55"></a><span id="l11.55">  *  the loading of referenced noun instances.  Which is to say, messages have</span>
<a href="#l11.56"></a><span id="l11.56">  *  identities (specific e-mail addresses) associated with them via attributes.</span>
<a href="#l11.57"></a><span id="l11.57" class="difflineat">@@ -84,71 +81,71 @@ var QFQ_LOG = Log4Moz.repository.getLogg</span>
<a href="#l11.58"></a><span id="l11.58">  *  notion of a person).</span>
<a href="#l11.59"></a><span id="l11.59">  *</span>
<a href="#l11.60"></a><span id="l11.60">  * This listener is primarily concerned with fixing up the references in each</span>
<a href="#l11.61"></a><span id="l11.61">  *  noun instance to its referenced instances once they have been loaded.  It</span>
<a href="#l11.62"></a><span id="l11.62">  *  also deals with caching so that our identity invariant is maintained: user</span>
<a href="#l11.63"></a><span id="l11.63">  *  code should only ever see one distinct instance of a thing at a time.</span>
<a href="#l11.64"></a><span id="l11.64">  */</span>
<a href="#l11.65"></a><span id="l11.65"> var QueryFromQueryResolver = {</span>
<a href="#l11.66"></a><span id="l11.66" class="difflineminus">-  onItemsAdded: function(aIgnoredItems, aCollection, aFake) {</span>
<a href="#l11.67"></a><span id="l11.67" class="difflineplus">+  onItemsAdded(aIgnoredItems, aCollection, aFake) {</span>
<a href="#l11.68"></a><span id="l11.68">     let originColl = aCollection.dataStack ? aCollection.dataStack.pop()</span>
<a href="#l11.69"></a><span id="l11.69">                                            : aCollection.data;</span>
<a href="#l11.70"></a><span id="l11.70" class="difflineminus">-    //QFQ_LOG.debug(&quot;QFQR: originColl: &quot; + originColl);</span>
<a href="#l11.71"></a><span id="l11.71" class="difflineplus">+    // QFQ_LOG.debug(&quot;QFQR: originColl: &quot; + originColl);</span>
<a href="#l11.72"></a><span id="l11.72">     if (aCollection.completionShifter)</span>
<a href="#l11.73"></a><span id="l11.73">       aCollection.completionShifter.push(originColl);</span>
<a href="#l11.74"></a><span id="l11.74">     else</span>
<a href="#l11.75"></a><span id="l11.75">       aCollection.completionShifter = [originColl];</span>
<a href="#l11.76"></a><span id="l11.76"> </span>
<a href="#l11.77"></a><span id="l11.77">     if (!aFake) {</span>
<a href="#l11.78"></a><span id="l11.78">       originColl.deferredCount--;</span>
<a href="#l11.79"></a><span id="l11.79">       originColl.resolvedCount++;</span>
<a href="#l11.80"></a><span id="l11.80">     }</span>
<a href="#l11.81"></a><span id="l11.81"> </span>
<a href="#l11.82"></a><span id="l11.82">     // bail if we are still pending on some other load completion</span>
<a href="#l11.83"></a><span id="l11.83">     if (originColl.deferredCount &gt; 0) {</span>
<a href="#l11.84"></a><span id="l11.84" class="difflineminus">-      //QFQ_LOG.debug(&quot;QFQR: bailing &quot; + originColl._nounDef.name);</span>
<a href="#l11.85"></a><span id="l11.85" class="difflineplus">+      // QFQ_LOG.debug(&quot;QFQR: bailing &quot; + originColl._nounDef.name);</span>
<a href="#l11.86"></a><span id="l11.86">       return;</span>
<a href="#l11.87"></a><span id="l11.87">     }</span>
<a href="#l11.88"></a><span id="l11.88"> </span>
<a href="#l11.89"></a><span id="l11.89">     let referencesByNounID = originColl.masterCollection.referencesByNounID;</span>
<a href="#l11.90"></a><span id="l11.90">     let inverseReferencesByNounID =</span>
<a href="#l11.91"></a><span id="l11.91">       originColl.masterCollection.inverseReferencesByNounID;</span>
<a href="#l11.92"></a><span id="l11.92"> </span>
<a href="#l11.93"></a><span id="l11.93">     if (originColl.pendingItems) {</span>
<a href="#l11.94"></a><span id="l11.94">       for (let item of originColl.pendingItems) {</span>
<a href="#l11.95"></a><span id="l11.95" class="difflineminus">-        //QFQ_LOG.debug(&quot;QFQR: loading deferred &quot; + item.NOUN_ID + &quot;:&quot; + item.id);</span>
<a href="#l11.96"></a><span id="l11.96" class="difflineplus">+        // QFQ_LOG.debug(&quot;QFQR: loading deferred &quot; + item.NOUN_ID + &quot;:&quot; + item.id);</span>
<a href="#l11.97"></a><span id="l11.97">         GlodaDatastore.loadNounDeferredDeps(item, referencesByNounID,</span>
<a href="#l11.98"></a><span id="l11.98">             inverseReferencesByNounID);</span>
<a href="#l11.99"></a><span id="l11.99">       }</span>
<a href="#l11.100"></a><span id="l11.100"> </span>
<a href="#l11.101"></a><span id="l11.101">       // we need to consider the possibility that we are racing a collection very</span>
<a href="#l11.102"></a><span id="l11.102">       //  much like our own.  as such, this means we need to perform cache</span>
<a href="#l11.103"></a><span id="l11.103">       //  unification as our last step.</span>
<a href="#l11.104"></a><span id="l11.104">       GlodaCollectionManager.cacheLoadUnify(originColl._nounDef.id,</span>
<a href="#l11.105"></a><span id="l11.105">         originColl.pendingItems, false);</span>
<a href="#l11.106"></a><span id="l11.106"> </span>
<a href="#l11.107"></a><span id="l11.107">       // just directly tell the collection about the items.  we know the query</span>
<a href="#l11.108"></a><span id="l11.108">       //  matches (at least until we introduce predicates that we cannot express</span>
<a href="#l11.109"></a><span id="l11.109">       //  in SQL.)</span>
<a href="#l11.110"></a><span id="l11.110" class="difflineminus">-      //QFQ_LOG.debug(&quot; QFQR: about to trigger listener: &quot; + originColl._listener +</span>
<a href="#l11.111"></a><span id="l11.111" class="difflineplus">+      // QFQ_LOG.debug(&quot; QFQR: about to trigger listener: &quot; + originColl._listener +</span>
<a href="#l11.112"></a><span id="l11.112">       //    &quot;with collection: &quot; + originColl._nounDef.name);</span>
<a href="#l11.113"></a><span id="l11.113">       originColl._onItemsAdded(originColl.pendingItems);</span>
<a href="#l11.114"></a><span id="l11.114">       delete originColl.pendingItems;</span>
<a href="#l11.115"></a><span id="l11.115">       delete originColl._pendingIdMap;</span>
<a href="#l11.116"></a><span id="l11.116">     }</span>
<a href="#l11.117"></a><span id="l11.117">   },</span>
<a href="#l11.118"></a><span id="l11.118" class="difflineminus">-  onItemsModified: function() {</span>
<a href="#l11.119"></a><span id="l11.119" class="difflineplus">+  onItemsModified() {</span>
<a href="#l11.120"></a><span id="l11.120">   },</span>
<a href="#l11.121"></a><span id="l11.121" class="difflineminus">-  onItemsRemoved: function() {</span>
<a href="#l11.122"></a><span id="l11.122" class="difflineplus">+  onItemsRemoved() {</span>
<a href="#l11.123"></a><span id="l11.123">   },</span>
<a href="#l11.124"></a><span id="l11.124" class="difflineminus">-  onQueryCompleted: function(aCollection) {</span>
<a href="#l11.125"></a><span id="l11.125" class="difflineplus">+  onQueryCompleted(aCollection) {</span>
<a href="#l11.126"></a><span id="l11.126">     let originColl = aCollection.completionShifter ?</span>
<a href="#l11.127"></a><span id="l11.127">       aCollection.completionShifter.shift() : aCollection.data;</span>
<a href="#l11.128"></a><span id="l11.128" class="difflineminus">-    //QFQ_LOG.debug(&quot; QFQR about to trigger completion with collection: &quot; +</span>
<a href="#l11.129"></a><span id="l11.129" class="difflineplus">+    // QFQ_LOG.debug(&quot; QFQR about to trigger completion with collection: &quot; +</span>
<a href="#l11.130"></a><span id="l11.130">     //  originColl._nounDef.name);</span>
<a href="#l11.131"></a><span id="l11.131">     if (originColl.deferredCount &lt;= 0) {</span>
<a href="#l11.132"></a><span id="l11.132">       originColl._onQueryCompleted();</span>
<a href="#l11.133"></a><span id="l11.133">     }</span>
<a href="#l11.134"></a><span id="l11.134">   },</span>
<a href="#l11.135"></a><span id="l11.135"> };</span>
<a href="#l11.136"></a><span id="l11.136"> </span>
<a href="#l11.137"></a><span id="l11.137"> /**</span>
<a href="#l11.138"></a><span id="l11.138" class="difflineat">@@ -164,17 +161,17 @@ var QueryFromQueryResolver = {</span>
<a href="#l11.139"></a><span id="l11.139">  *  complex.  Some of the logic here 'evolved' a bit and could benefit from</span>
<a href="#l11.140"></a><span id="l11.140">  *  additional documentation and a fresh go-through.</span>
<a href="#l11.141"></a><span id="l11.141">  */</span>
<a href="#l11.142"></a><span id="l11.142"> function QueryFromQueryCallback(aStatement, aNounDef, aCollection) {</span>
<a href="#l11.143"></a><span id="l11.143">   this.statement = aStatement;</span>
<a href="#l11.144"></a><span id="l11.144">   this.nounDef = aNounDef;</span>
<a href="#l11.145"></a><span id="l11.145">   this.collection = aCollection;</span>
<a href="#l11.146"></a><span id="l11.146"> </span>
<a href="#l11.147"></a><span id="l11.147" class="difflineminus">-  //QFQ_LOG.debug(&quot;Creating QFQCallback for noun: &quot; + aNounDef.name);</span>
<a href="#l11.148"></a><span id="l11.148" class="difflineplus">+  // QFQ_LOG.debug(&quot;Creating QFQCallback for noun: &quot; + aNounDef.name);</span>
<a href="#l11.149"></a><span id="l11.149"> </span>
<a href="#l11.150"></a><span id="l11.150">   // the master collection holds the referencesByNounID</span>
<a href="#l11.151"></a><span id="l11.151">   this.referencesByNounID = {};</span>
<a href="#l11.152"></a><span id="l11.152">   this.masterReferencesByNounID =</span>
<a href="#l11.153"></a><span id="l11.153">     this.collection.masterCollection.referencesByNounID;</span>
<a href="#l11.154"></a><span id="l11.154">   this.inverseReferencesByNounID = {};</span>
<a href="#l11.155"></a><span id="l11.155">   this.masterInverseReferencesByNounID =</span>
<a href="#l11.156"></a><span id="l11.156">     this.collection.masterCollection.inverseReferencesByNounID;</span>
<a href="#l11.157"></a><span id="l11.157" class="difflineat">@@ -196,17 +193,17 @@ function QueryFromQueryCallback(aStateme</span>
<a href="#l11.158"></a><span id="l11.158">   }</span>
<a href="#l11.159"></a><span id="l11.159"> </span>
<a href="#l11.160"></a><span id="l11.160">   this.needsLoads = false;</span>
<a href="#l11.161"></a><span id="l11.161"> </span>
<a href="#l11.162"></a><span id="l11.162">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l11.163"></a><span id="l11.163"> }</span>
<a href="#l11.164"></a><span id="l11.164"> </span>
<a href="#l11.165"></a><span id="l11.165"> QueryFromQueryCallback.prototype = {</span>
<a href="#l11.166"></a><span id="l11.166" class="difflineminus">-  handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l11.167"></a><span id="l11.167" class="difflineplus">+  handleResult(aResultSet) {</span>
<a href="#l11.168"></a><span id="l11.168">     try {</span>
<a href="#l11.169"></a><span id="l11.169">       // just outright bail if we are shutdown</span>
<a href="#l11.170"></a><span id="l11.170">       if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l11.171"></a><span id="l11.171">         return;</span>
<a href="#l11.172"></a><span id="l11.172"> </span>
<a href="#l11.173"></a><span id="l11.173">       let pendingItems = this.collection.pendingItems;</span>
<a href="#l11.174"></a><span id="l11.174">       let pendingIdMap = this.collection._pendingIdMap;</span>
<a href="#l11.175"></a><span id="l11.175">       let row;</span>
<a href="#l11.176"></a><span id="l11.176" class="difflineat">@@ -223,17 +220,17 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l11.177"></a><span id="l11.177">         // try and replace the item with one from the cache, if we can</span>
<a href="#l11.178"></a><span id="l11.178">         let cachedItem = GlodaCollectionManager.cacheLookupOne(nounID, item.id,</span>
<a href="#l11.179"></a><span id="l11.179">                                                                false);</span>
<a href="#l11.180"></a><span id="l11.180"> </span>
<a href="#l11.181"></a><span id="l11.181">         // if we already have a copy in the pending id map, skip it</span>
<a href="#l11.182"></a><span id="l11.182">         if (item.id in pendingIdMap)</span>
<a href="#l11.183"></a><span id="l11.183">           continue;</span>
<a href="#l11.184"></a><span id="l11.184"> </span>
<a href="#l11.185"></a><span id="l11.185" class="difflineminus">-        //QFQ_LOG.debug(&quot;loading item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; existing: &quot; +</span>
<a href="#l11.186"></a><span id="l11.186" class="difflineplus">+        // QFQ_LOG.debug(&quot;loading item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; existing: &quot; +</span>
<a href="#l11.187"></a><span id="l11.187">         //    this.selfReferences[item.id] + &quot; cached: &quot; + cachedItem);</span>
<a href="#l11.188"></a><span id="l11.188">         if (cachedItem)</span>
<a href="#l11.189"></a><span id="l11.189">           item = cachedItem;</span>
<a href="#l11.190"></a><span id="l11.190">         // we may already have been loaded by this process</span>
<a href="#l11.191"></a><span id="l11.191">         else if (this.selfReferences[item.id] != null)</span>
<a href="#l11.192"></a><span id="l11.192">           item = this.selfReferences[item.id];</span>
<a href="#l11.193"></a><span id="l11.193">         // perform loading logic which may produce reference dependencies</span>
<a href="#l11.194"></a><span id="l11.194">         else</span>
<a href="#l11.195"></a><span id="l11.195" class="difflineat">@@ -254,63 +251,62 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l11.196"></a><span id="l11.196">           if (childrenList === undefined)</span>
<a href="#l11.197"></a><span id="l11.197">             childrenList = this.selfInverseReferences[parentID] = [];</span>
<a href="#l11.198"></a><span id="l11.198">           childrenList.push(item);</span>
<a href="#l11.199"></a><span id="l11.199">         }</span>
<a href="#l11.200"></a><span id="l11.200"> </span>
<a href="#l11.201"></a><span id="l11.201">         pendingItems.push(item);</span>
<a href="#l11.202"></a><span id="l11.202">         pendingIdMap[item.id] = item;</span>
<a href="#l11.203"></a><span id="l11.203">       }</span>
<a href="#l11.204"></a><span id="l11.204" class="difflineminus">-    }</span>
<a href="#l11.205"></a><span id="l11.205" class="difflineminus">-    catch (e) {</span>
<a href="#l11.206"></a><span id="l11.206" class="difflineplus">+    } catch (e) {</span>
<a href="#l11.207"></a><span id="l11.207">       GlodaDatastore._log.error(&quot;Exception in handleResult:&quot;, e);</span>
<a href="#l11.208"></a><span id="l11.208">     }</span>
<a href="#l11.209"></a><span id="l11.209">   },</span>
<a href="#l11.210"></a><span id="l11.210"> </span>
<a href="#l11.211"></a><span id="l11.211" class="difflineminus">-  handleError: function gloda_ds_qfq_handleError(aError) {</span>
<a href="#l11.212"></a><span id="l11.212" class="difflineplus">+  handleError(aError) {</span>
<a href="#l11.213"></a><span id="l11.213">     GlodaDatastore._log.error(&quot;Async queryFromQuery error: &quot; +</span>
<a href="#l11.214"></a><span id="l11.214">       aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l11.215"></a><span id="l11.215">   },</span>
<a href="#l11.216"></a><span id="l11.216"> </span>
<a href="#l11.217"></a><span id="l11.217" class="difflineminus">-  handleCompletion: function gloda_ds_qfq_handleCompletion(aReason) {</span>
<a href="#l11.218"></a><span id="l11.218" class="difflineplus">+  handleCompletion(aReason) {</span>
<a href="#l11.219"></a><span id="l11.219">     try {</span>
<a href="#l11.220"></a><span id="l11.220">       try {</span>
<a href="#l11.221"></a><span id="l11.221">         this.statement.finalize();</span>
<a href="#l11.222"></a><span id="l11.222">         this.statement = null;</span>
<a href="#l11.223"></a><span id="l11.223"> </span>
<a href="#l11.224"></a><span id="l11.224">         // just outright bail if we are shutdown</span>
<a href="#l11.225"></a><span id="l11.225">         if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l11.226"></a><span id="l11.226">           return;</span>
<a href="#l11.227"></a><span id="l11.227"> </span>
<a href="#l11.228"></a><span id="l11.228" class="difflineminus">-        //QFQ_LOG.debug(&quot;handleCompletion: &quot; + this.collection._nounDef.name);</span>
<a href="#l11.229"></a><span id="l11.229" class="difflineplus">+        // QFQ_LOG.debug(&quot;handleCompletion: &quot; + this.collection._nounDef.name);</span>
<a href="#l11.230"></a><span id="l11.230"> </span>
<a href="#l11.231"></a><span id="l11.231">         if (this.needsLoads) {</span>
<a href="#l11.232"></a><span id="l11.232">           for (let nounID in this.referencesByNounID) {</span>
<a href="#l11.233"></a><span id="l11.233">             let references = this.referencesByNounID[nounID];</span>
<a href="#l11.234"></a><span id="l11.234">             if (nounID == this.nounDef.id)</span>
<a href="#l11.235"></a><span id="l11.235">               continue;</span>
<a href="#l11.236"></a><span id="l11.236">             let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l11.237"></a><span id="l11.237" class="difflineminus">-            //QFQ_LOG.debug(&quot;  have references for noun: &quot; + nounDef.name);</span>
<a href="#l11.238"></a><span id="l11.238" class="difflineplus">+            // QFQ_LOG.debug(&quot;  have references for noun: &quot; + nounDef.name);</span>
<a href="#l11.239"></a><span id="l11.239">             // try and load them out of the cache/existing collections.  items in the</span>
<a href="#l11.240"></a><span id="l11.240">             //  cache will be fully formed, which is nice for us.</span>
<a href="#l11.241"></a><span id="l11.241">             // XXX this mechanism will get dubious when we have multiple paths to a</span>
<a href="#l11.242"></a><span id="l11.242">             //  single noun-type.  For example, a -&gt; b -&gt; c, a-&gt; c; two paths to c</span>
<a href="#l11.243"></a><span id="l11.243">             //  and we're looking at issuing two requests to c, the latter of which</span>
<a href="#l11.244"></a><span id="l11.244">             //  will be a superset of the first one.  This does not currently pose</span>
<a href="#l11.245"></a><span id="l11.245">             //  a problem because we only have a -&gt; b -&gt; c -&gt; b, and sequential</span>
<a href="#l11.246"></a><span id="l11.246">             //  processing means no alarms and no surprises.</span>
<a href="#l11.247"></a><span id="l11.247">             let masterReferences = this.masterReferencesByNounID[nounID];</span>
<a href="#l11.248"></a><span id="l11.248">             if (masterReferences === undefined)</span>
<a href="#l11.249"></a><span id="l11.249">               masterReferences = this.masterReferencesByNounID[nounID] = {};</span>
<a href="#l11.250"></a><span id="l11.250">             let outReferences;</span>
<a href="#l11.251"></a><span id="l11.251">             if (nounDef.parentColumnAttr)</span>
<a href="#l11.252"></a><span id="l11.252">               outReferences = {};</span>
<a href="#l11.253"></a><span id="l11.253">             else</span>
<a href="#l11.254"></a><span id="l11.254">               outReferences = masterReferences;</span>
<a href="#l11.255"></a><span id="l11.255" class="difflineminus">-            let [foundCount, notFoundCount, notFound] =</span>
<a href="#l11.256"></a><span id="l11.256" class="difflineplus">+            let [, notFoundCount, notFound] =</span>
<a href="#l11.257"></a><span id="l11.257">               GlodaCollectionManager.cacheLookupMany(nounDef.id, references,</span>
<a href="#l11.258"></a><span id="l11.258">                   outReferences);</span>
<a href="#l11.259"></a><span id="l11.259"> </span>
<a href="#l11.260"></a><span id="l11.260">             if (nounDef.parentColumnAttr) {</span>
<a href="#l11.261"></a><span id="l11.261">               let inverseReferences;</span>
<a href="#l11.262"></a><span id="l11.262">               if (nounDef.id in this.masterInverseReferencesByNounID)</span>
<a href="#l11.263"></a><span id="l11.263">                 inverseReferences =</span>
<a href="#l11.264"></a><span id="l11.264">                   this.masterInverseReferencesByNounID[nounDef.id];</span>
<a href="#l11.265"></a><span id="l11.265" class="difflineat">@@ -324,21 +320,20 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l11.266"></a><span id="l11.266">                 let parentID = item[nounDef.parentColumnAttr.idStorageAttributeName];</span>
<a href="#l11.267"></a><span id="l11.267">                 let childrenList = inverseReferences[parentID];</span>
<a href="#l11.268"></a><span id="l11.268">                 if (childrenList === undefined)</span>
<a href="#l11.269"></a><span id="l11.269">                   childrenList = inverseReferences[parentID] = [];</span>
<a href="#l11.270"></a><span id="l11.270">                 childrenList.push(item);</span>
<a href="#l11.271"></a><span id="l11.271">               }</span>
<a href="#l11.272"></a><span id="l11.272">             }</span>
<a href="#l11.273"></a><span id="l11.273"> </span>
<a href="#l11.274"></a><span id="l11.274" class="difflineminus">-            //QFQ_LOG.debug(&quot;  found: &quot; + foundCount + &quot; not found: &quot; + notFoundCount);</span>
<a href="#l11.275"></a><span id="l11.275" class="difflineplus">+            // QFQ_LOG.debug(&quot;  found: &quot; + foundCount + &quot; not found: &quot; + notFoundCount);</span>
<a href="#l11.276"></a><span id="l11.276">             if (notFoundCount === 0) {</span>
<a href="#l11.277"></a><span id="l11.277">               this.collection.resolvedCount++;</span>
<a href="#l11.278"></a><span id="l11.278" class="difflineminus">-            }</span>
<a href="#l11.279"></a><span id="l11.279" class="difflineminus">-            else {</span>
<a href="#l11.280"></a><span id="l11.280" class="difflineplus">+            } else {</span>
<a href="#l11.281"></a><span id="l11.281">               this.collection.deferredCount++;</span>
<a href="#l11.282"></a><span id="l11.282">               let query = new nounDef.queryClass();</span>
<a href="#l11.283"></a><span id="l11.283">               query.id.apply(query, Object.keys(notFound));</span>
<a href="#l11.284"></a><span id="l11.284"> </span>
<a href="#l11.285"></a><span id="l11.285">               // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l11.286"></a><span id="l11.286">               let subCollection = (nounDef.id in this.collection.masterCollection.subCollections) ?</span>
<a href="#l11.287"></a><span id="l11.287">                                   this.collection.masterCollection.subCollections[nounDef.id] : undefined;</span>
<a href="#l11.288"></a><span id="l11.288">               this.collection.masterCollection.subCollections[nounDef.id] =</span>
<a href="#l11.289"></a><span id="l11.289" class="difflineat">@@ -350,147 +345,144 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l11.290"></a><span id="l11.290">             }</span>
<a href="#l11.291"></a><span id="l11.291">           }</span>
<a href="#l11.292"></a><span id="l11.292"> </span>
<a href="#l11.293"></a><span id="l11.293">           for (let nounID in this.inverseReferencesByNounID) {</span>
<a href="#l11.294"></a><span id="l11.294">             let inverseReferences = this.inverseReferencesByNounID[nounID];</span>
<a href="#l11.295"></a><span id="l11.295">             this.collection.deferredCount++;</span>
<a href="#l11.296"></a><span id="l11.296">             let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l11.297"></a><span id="l11.297"> </span>
<a href="#l11.298"></a><span id="l11.298" class="difflineminus">-            //QFQ_LOG.debug(&quot;Want to load inverse via &quot; + nounDef.parentColumnAttr.boundName);</span>
<a href="#l11.299"></a><span id="l11.299" class="difflineplus">+            // QFQ_LOG.debug(&quot;Want to load inverse via &quot; + nounDef.parentColumnAttr.boundName);</span>
<a href="#l11.300"></a><span id="l11.300"> </span>
<a href="#l11.301"></a><span id="l11.301">             let query = new nounDef.queryClass();</span>
<a href="#l11.302"></a><span id="l11.302">             // we want to constrain using the parent column</span>
<a href="#l11.303"></a><span id="l11.303">             let queryConstrainer = query[nounDef.parentColumnAttr.boundName];</span>
<a href="#l11.304"></a><span id="l11.304">             queryConstrainer.apply(query, Object.keys(inverseReferences));</span>
<a href="#l11.305"></a><span id="l11.305">             // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l11.306"></a><span id="l11.306">             let subCollection = (nounDef.id in this.collection.masterCollection.subCollections) ?</span>
<a href="#l11.307"></a><span id="l11.307">                                 this.collection.masterCollection.subCollections[nounDef.id] : undefined;</span>
<a href="#l11.308"></a><span id="l11.308">             this.collection.masterCollection.subCollections[nounDef.id] =</span>
<a href="#l11.309"></a><span id="l11.309">               GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver,</span>
<a href="#l11.310"></a><span id="l11.310">                 this.collection,</span>
<a href="#l11.311"></a><span id="l11.311">                 subCollection,</span>
<a href="#l11.312"></a><span id="l11.312">                 this.collection.masterCollection,</span>
<a href="#l11.313"></a><span id="l11.313">                 {becomeExplicit: true});</span>
<a href="#l11.314"></a><span id="l11.314">           }</span>
<a href="#l11.315"></a><span id="l11.315" class="difflineminus">-        }</span>
<a href="#l11.316"></a><span id="l11.316" class="difflineminus">-        else {</span>
<a href="#l11.317"></a><span id="l11.317" class="difflineplus">+        } else {</span>
<a href="#l11.318"></a><span id="l11.318">           this.collection.deferredCount--;</span>
<a href="#l11.319"></a><span id="l11.319">           this.collection.resolvedCount++;</span>
<a href="#l11.320"></a><span id="l11.320">         }</span>
<a href="#l11.321"></a><span id="l11.321"> </span>
<a href="#l11.322"></a><span id="l11.322" class="difflineminus">-        //QFQ_LOG.debug(&quot;  defer: &quot; + this.collection.deferredCount +</span>
<a href="#l11.323"></a><span id="l11.323" class="difflineplus">+        // QFQ_LOG.debug(&quot;  defer: &quot; + this.collection.deferredCount +</span>
<a href="#l11.324"></a><span id="l11.324">         //              &quot; resolved: &quot; + this.collection.resolvedCount);</span>
<a href="#l11.325"></a><span id="l11.325"> </span>
<a href="#l11.326"></a><span id="l11.326">         // process immediately and kick-up to the master collection...</span>
<a href="#l11.327"></a><span id="l11.327">         if (this.collection.deferredCount &lt;= 0) {</span>
<a href="#l11.328"></a><span id="l11.328">           // this guy will resolve everyone using referencesByNounID and issue the</span>
<a href="#l11.329"></a><span id="l11.329">           //  call to this.collection._onItemsAdded to propagate things to the</span>
<a href="#l11.330"></a><span id="l11.330">           //  next concerned subCollection or the actual listener if this is the</span>
<a href="#l11.331"></a><span id="l11.331">           //  master collection.  (Also, call _onQueryCompleted).</span>
<a href="#l11.332"></a><span id="l11.332">           QueryFromQueryResolver.onItemsAdded(null, {data: this.collection}, true);</span>
<a href="#l11.333"></a><span id="l11.333">           QueryFromQueryResolver.onQueryCompleted({data: this.collection});</span>
<a href="#l11.334"></a><span id="l11.334">         }</span>
<a href="#l11.335"></a><span id="l11.335" class="difflineminus">-      }</span>
<a href="#l11.336"></a><span id="l11.336" class="difflineminus">-      catch (e) {</span>
<a href="#l11.337"></a><span id="l11.337" class="difflineplus">+      } catch (e) {</span>
<a href="#l11.338"></a><span id="l11.338">         Cu.reportError(e);</span>
<a href="#l11.339"></a><span id="l11.339">         QFQ_LOG.error(&quot;Exception:&quot;, e);</span>
<a href="#l11.340"></a><span id="l11.340">       }</span>
<a href="#l11.341"></a><span id="l11.341" class="difflineminus">-    }</span>
<a href="#l11.342"></a><span id="l11.342" class="difflineminus">-    finally {</span>
<a href="#l11.343"></a><span id="l11.343" class="difflineplus">+    } finally {</span>
<a href="#l11.344"></a><span id="l11.344">       GlodaDatastore._asyncCompleted();</span>
<a href="#l11.345"></a><span id="l11.345">     }</span>
<a href="#l11.346"></a><span id="l11.346" class="difflineminus">-  }</span>
<a href="#l11.347"></a><span id="l11.347" class="difflineplus">+  },</span>
<a href="#l11.348"></a><span id="l11.348"> };</span>
<a href="#l11.349"></a><span id="l11.349"> </span>
<a href="#l11.350"></a><span id="l11.350"> /**</span>
<a href="#l11.351"></a><span id="l11.351">  * Used by |GlodaDatastore.folderCompactionPassBlockFetch| to accumulate the</span>
<a href="#l11.352"></a><span id="l11.352">  *  results and pass them back in to the compaction process in</span>
<a href="#l11.353"></a><span id="l11.353">  *  |GlodaMsgIndexer._worker_folderCompactionPass|.</span>
<a href="#l11.354"></a><span id="l11.354">  */</span>
<a href="#l11.355"></a><span id="l11.355"> function CompactionBlockFetcherHandler(aCallback) {</span>
<a href="#l11.356"></a><span id="l11.356">   this.callback = aCallback;</span>
<a href="#l11.357"></a><span id="l11.357">   this.idsAndMessageKeys = [];</span>
<a href="#l11.358"></a><span id="l11.358">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l11.359"></a><span id="l11.359"> }</span>
<a href="#l11.360"></a><span id="l11.360"> CompactionBlockFetcherHandler.prototype = {</span>
<a href="#l11.361"></a><span id="l11.361" class="difflineminus">-  handleResult: function gloda_ds_cbfh_handleResult(aResultSet) {</span>
<a href="#l11.362"></a><span id="l11.362" class="difflineplus">+  handleResult(aResultSet) {</span>
<a href="#l11.363"></a><span id="l11.363">     let row;</span>
<a href="#l11.364"></a><span id="l11.364">     while ((row = aResultSet.getNextRow())) {</span>
<a href="#l11.365"></a><span id="l11.365">       this.idsAndMessageKeys.push([</span>
<a href="#l11.366"></a><span id="l11.366">         row.getInt64(0), // id</span>
<a href="#l11.367"></a><span id="l11.367">         row.getInt64(1), // messageKey</span>
<a href="#l11.368"></a><span id="l11.368">         row.getString(2), // headerMessageID</span>
<a href="#l11.369"></a><span id="l11.369">         ]);</span>
<a href="#l11.370"></a><span id="l11.370">     }</span>
<a href="#l11.371"></a><span id="l11.371">   },</span>
<a href="#l11.372"></a><span id="l11.372" class="difflineminus">-  handleError: function gloda_ds_cbfh_handleError(aError) {</span>
<a href="#l11.373"></a><span id="l11.373" class="difflineplus">+  handleError(aError) {</span>
<a href="#l11.374"></a><span id="l11.374">     GlodaDatastore._log.error(&quot;CompactionBlockFetcherHandler error: &quot; +</span>
<a href="#l11.375"></a><span id="l11.375">       aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l11.376"></a><span id="l11.376">   },</span>
<a href="#l11.377"></a><span id="l11.377" class="difflineminus">-  handleCompletion: function gloda_ds_cbfh_handleCompletion(aReason) {</span>
<a href="#l11.378"></a><span id="l11.378" class="difflineplus">+  handleCompletion(aReason) {</span>
<a href="#l11.379"></a><span id="l11.379">     GlodaDatastore._asyncCompleted();</span>
<a href="#l11.380"></a><span id="l11.380">     this.callback(this.idsAndMessageKeys);</span>
<a href="#l11.381"></a><span id="l11.381" class="difflineminus">-  }</span>
<a href="#l11.382"></a><span id="l11.382" class="difflineplus">+  },</span>
<a href="#l11.383"></a><span id="l11.383"> };</span>
<a href="#l11.384"></a><span id="l11.384"> </span>
<a href="#l11.385"></a><span id="l11.385"> /**</span>
<a href="#l11.386"></a><span id="l11.386">  * Use this as the callback handler when you have a SQL query that returns a</span>
<a href="#l11.387"></a><span id="l11.387">  *  single row with a single integer column value, like a COUNT() query.</span>
<a href="#l11.388"></a><span id="l11.388">  */</span>
<a href="#l11.389"></a><span id="l11.389"> function SingletonResultValueHandler(aCallback) {</span>
<a href="#l11.390"></a><span id="l11.390">   this.callback = aCallback;</span>
<a href="#l11.391"></a><span id="l11.391">   this.result = null;</span>
<a href="#l11.392"></a><span id="l11.392">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l11.393"></a><span id="l11.393"> }</span>
<a href="#l11.394"></a><span id="l11.394"> SingletonResultValueHandler.prototype = {</span>
<a href="#l11.395"></a><span id="l11.395" class="difflineminus">-  handleResult: function gloda_ds_cbfh_handleResult(aResultSet) {</span>
<a href="#l11.396"></a><span id="l11.396" class="difflineplus">+  handleResult(aResultSet) {</span>
<a href="#l11.397"></a><span id="l11.397">     let row;</span>
<a href="#l11.398"></a><span id="l11.398">     while ((row = aResultSet.getNextRow())) {</span>
<a href="#l11.399"></a><span id="l11.399">       this.result = row.getInt64(0);</span>
<a href="#l11.400"></a><span id="l11.400">     }</span>
<a href="#l11.401"></a><span id="l11.401">   },</span>
<a href="#l11.402"></a><span id="l11.402" class="difflineminus">-  handleError: function gloda_ds_cbfh_handleError(aError) {</span>
<a href="#l11.403"></a><span id="l11.403" class="difflineplus">+  handleError(aError) {</span>
<a href="#l11.404"></a><span id="l11.404">     GlodaDatastore._log.error(&quot;SingletonResultValueHandler error: &quot; +</span>
<a href="#l11.405"></a><span id="l11.405">       aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l11.406"></a><span id="l11.406">   },</span>
<a href="#l11.407"></a><span id="l11.407" class="difflineminus">-  handleCompletion: function gloda_ds_cbfh_handleCompletion(aReason) {</span>
<a href="#l11.408"></a><span id="l11.408" class="difflineplus">+  handleCompletion(aReason) {</span>
<a href="#l11.409"></a><span id="l11.409">     GlodaDatastore._asyncCompleted();</span>
<a href="#l11.410"></a><span id="l11.410">     this.callback(this.result);</span>
<a href="#l11.411"></a><span id="l11.411" class="difflineminus">-  }</span>
<a href="#l11.412"></a><span id="l11.412" class="difflineplus">+  },</span>
<a href="#l11.413"></a><span id="l11.413"> };</span>
<a href="#l11.414"></a><span id="l11.414"> </span>
<a href="#l11.415"></a><span id="l11.415"> /**</span>
<a href="#l11.416"></a><span id="l11.416">  * Wrapper that duplicates actions taken on a real statement to an explain</span>
<a href="#l11.417"></a><span id="l11.417">  *  statement.  Currently only fires an explain statement once.</span>
<a href="#l11.418"></a><span id="l11.418">  */</span>
<a href="#l11.419"></a><span id="l11.419"> function ExplainedStatementWrapper(aRealStatement, aExplainStatement,</span>
<a href="#l11.420"></a><span id="l11.420">                                    aSQLString, aExplainHandler) {</span>
<a href="#l11.421"></a><span id="l11.421">   this.real = aRealStatement;</span>
<a href="#l11.422"></a><span id="l11.422">   this.explain = aExplainStatement;</span>
<a href="#l11.423"></a><span id="l11.423">   this.sqlString = aSQLString;</span>
<a href="#l11.424"></a><span id="l11.424">   this.explainHandler = aExplainHandler;</span>
<a href="#l11.425"></a><span id="l11.425">   this.done = false;</span>
<a href="#l11.426"></a><span id="l11.426"> }</span>
<a href="#l11.427"></a><span id="l11.427"> ExplainedStatementWrapper.prototype = {</span>
<a href="#l11.428"></a><span id="l11.428" class="difflineminus">-  bindByIndex: function(aColIndex, aValue) {</span>
<a href="#l11.429"></a><span id="l11.429" class="difflineplus">+  bindByIndex(aColIndex, aValue) {</span>
<a href="#l11.430"></a><span id="l11.430">     this.real.bindByIndex(aColIndex, aValue);</span>
<a href="#l11.431"></a><span id="l11.431">     if (!this.done)</span>
<a href="#l11.432"></a><span id="l11.432">       this.explain.bindByIndex(aColIndex, aValue);</span>
<a href="#l11.433"></a><span id="l11.433">   },</span>
<a href="#l11.434"></a><span id="l11.434" class="difflineminus">-  executeAsync: function wrapped_executeAsync(aCallback) {</span>
<a href="#l11.435"></a><span id="l11.435" class="difflineplus">+  executeAsync(aCallback) {</span>
<a href="#l11.436"></a><span id="l11.436">     if (!this.done) {</span>
<a href="#l11.437"></a><span id="l11.437">       this.explainHandler.sqlEnRoute(this.sqlString);</span>
<a href="#l11.438"></a><span id="l11.438">       this.explain.executeAsync(this.explainHandler);</span>
<a href="#l11.439"></a><span id="l11.439">       this.explain.finalize();</span>
<a href="#l11.440"></a><span id="l11.440">       this.done = true;</span>
<a href="#l11.441"></a><span id="l11.441">     }</span>
<a href="#l11.442"></a><span id="l11.442">     return this.real.executeAsync(aCallback);</span>
<a href="#l11.443"></a><span id="l11.443">   },</span>
<a href="#l11.444"></a><span id="l11.444" class="difflineminus">-  finalize: function wrapped_finalize() {</span>
<a href="#l11.445"></a><span id="l11.445" class="difflineplus">+  finalize() {</span>
<a href="#l11.446"></a><span id="l11.446">     if (!this.done)</span>
<a href="#l11.447"></a><span id="l11.447">       this.explain.finalize();</span>
<a href="#l11.448"></a><span id="l11.448">     this.real.finalize();</span>
<a href="#l11.449"></a><span id="l11.449">   },</span>
<a href="#l11.450"></a><span id="l11.450"> };</span>
<a href="#l11.451"></a><span id="l11.451"> </span>
<a href="#l11.452"></a><span id="l11.452"> /**</span>
<a href="#l11.453"></a><span id="l11.453">  * Writes a single JSON document to the provide file path in a streaming</span>
<a href="#l11.454"></a><span id="l11.454" class="difflineat">@@ -511,61 +503,61 @@ function ExplainedStatementProcessor(aDu</span>
<a href="#l11.455"></a><span id="l11.455">   this._ostream = Cc[&quot;@mozilla.org/network/file-output-stream;1&quot;]</span>
<a href="#l11.456"></a><span id="l11.456">                  .createInstance(Ci.nsIFileOutputStream);</span>
<a href="#l11.457"></a><span id="l11.457">   this._ostream.init(filePath, -1, -1, 0);</span>
<a href="#l11.458"></a><span id="l11.458"> </span>
<a href="#l11.459"></a><span id="l11.459">   let s = '{&quot;queries&quot;: [';</span>
<a href="#l11.460"></a><span id="l11.460">   this._ostream.write(s, s.length);</span>
<a href="#l11.461"></a><span id="l11.461"> }</span>
<a href="#l11.462"></a><span id="l11.462"> ExplainedStatementProcessor.prototype = {</span>
<a href="#l11.463"></a><span id="l11.463" class="difflineminus">-  sqlEnRoute: function esp_sqlEnRoute(aSQLString) {</span>
<a href="#l11.464"></a><span id="l11.464" class="difflineplus">+  sqlEnRoute(aSQLString) {</span>
<a href="#l11.465"></a><span id="l11.465">     this._sqlStack.push(aSQLString);</span>
<a href="#l11.466"></a><span id="l11.466">   },</span>
<a href="#l11.467"></a><span id="l11.467" class="difflineminus">-  handleResult: function esp_handleResult(aResultSet) {</span>
<a href="#l11.468"></a><span id="l11.468" class="difflineplus">+  handleResult(aResultSet) {</span>
<a href="#l11.469"></a><span id="l11.469">     let row;</span>
<a href="#l11.470"></a><span id="l11.470">     // addr  opcode (s)      p1    p2    p3    p4 (s)   p5   comment (s)</span>
<a href="#l11.471"></a><span id="l11.471">     while ((row = aResultSet.getNextRow())) {</span>
<a href="#l11.472"></a><span id="l11.472">       this._curOps.push([</span>
<a href="#l11.473"></a><span id="l11.473">         row.getInt64(0),  // addr</span>
<a href="#l11.474"></a><span id="l11.474">         row.getString(1), // opcode</span>
<a href="#l11.475"></a><span id="l11.475">         row.getInt64(2),  // p1</span>
<a href="#l11.476"></a><span id="l11.476">         row.getInt64(3),  // p2</span>
<a href="#l11.477"></a><span id="l11.477">         row.getInt64(4),  // p3</span>
<a href="#l11.478"></a><span id="l11.478">         row.getString(5), // p4</span>
<a href="#l11.479"></a><span id="l11.479">         row.getString(6), // p5</span>
<a href="#l11.480"></a><span id="l11.480" class="difflineminus">-        row.getString(7)  // comment</span>
<a href="#l11.481"></a><span id="l11.481" class="difflineplus">+        row.getString(7), // comment</span>
<a href="#l11.482"></a><span id="l11.482">       ]);</span>
<a href="#l11.483"></a><span id="l11.483">     }</span>
<a href="#l11.484"></a><span id="l11.484">   },</span>
<a href="#l11.485"></a><span id="l11.485" class="difflineminus">-  handleError: function esp_handleError(aError) {</span>
<a href="#l11.486"></a><span id="l11.486" class="difflineplus">+  handleError(aError) {</span>
<a href="#l11.487"></a><span id="l11.487">     Cu.reportError(&quot;Unexpected error in EXPLAIN handler: &quot; + aError);</span>
<a href="#l11.488"></a><span id="l11.488">   },</span>
<a href="#l11.489"></a><span id="l11.489" class="difflineminus">-  handleCompletion: function esp_handleCompletion(aReason) {</span>
<a href="#l11.490"></a><span id="l11.490" class="difflineplus">+  handleCompletion(aReason) {</span>
<a href="#l11.491"></a><span id="l11.491">     let obj = {</span>
<a href="#l11.492"></a><span id="l11.492">       sql: this._sqlStack.shift(),</span>
<a href="#l11.493"></a><span id="l11.493">       operations: this._curOps,</span>
<a href="#l11.494"></a><span id="l11.494">     };</span>
<a href="#l11.495"></a><span id="l11.495">     let s = (this._objsWritten++ ? &quot;, &quot; : &quot;&quot;) + JSON.stringify(obj, null, 2);</span>
<a href="#l11.496"></a><span id="l11.496">     this._ostream.write(s, s.length);</span>
<a href="#l11.497"></a><span id="l11.497"> </span>
<a href="#l11.498"></a><span id="l11.498">     this._curOps = [];</span>
<a href="#l11.499"></a><span id="l11.499">   },</span>
<a href="#l11.500"></a><span id="l11.500"> </span>
<a href="#l11.501"></a><span id="l11.501" class="difflineminus">-  observe: function esp_observe(aSubject, aTopic, aData) {</span>
<a href="#l11.502"></a><span id="l11.502" class="difflineplus">+  observe(aSubject, aTopic, aData) {</span>
<a href="#l11.503"></a><span id="l11.503">     if (aTopic == &quot;quit-application&quot;)</span>
<a href="#l11.504"></a><span id="l11.504">       this.shutdown();</span>
<a href="#l11.505"></a><span id="l11.505">   },</span>
<a href="#l11.506"></a><span id="l11.506"> </span>
<a href="#l11.507"></a><span id="l11.507" class="difflineminus">-  shutdown: function esp_shutdown() {</span>
<a href="#l11.508"></a><span id="l11.508" class="difflineplus">+  shutdown() {</span>
<a href="#l11.509"></a><span id="l11.509">     let s = &quot;]}&quot;;</span>
<a href="#l11.510"></a><span id="l11.510">     this._ostream.write(s, s.length);</span>
<a href="#l11.511"></a><span id="l11.511">     this._ostream.close();</span>
<a href="#l11.512"></a><span id="l11.512"> </span>
<a href="#l11.513"></a><span id="l11.513">     Services.obs.removeObserver(this, &quot;quit-application&quot;);</span>
<a href="#l11.514"></a><span id="l11.514" class="difflineminus">-  }</span>
<a href="#l11.515"></a><span id="l11.515" class="difflineplus">+  },</span>
<a href="#l11.516"></a><span id="l11.516"> };</span>
<a href="#l11.517"></a><span id="l11.517"> </span>
<a href="#l11.518"></a><span id="l11.518"> // See the documentation on GlodaDatastore._schemaVersion to understand these:</span>
<a href="#l11.519"></a><span id="l11.519"> var DB_SCHEMA_ACCEPT_LEAVE_LOW = 31,</span>
<a href="#l11.520"></a><span id="l11.520">       DB_SCHEMA_ACCEPT_LEAVE_HIGH = 34,</span>
<a href="#l11.521"></a><span id="l11.521">       DB_SCHEMA_ACCEPT_DOWNGRADE_LOW = 35,</span>
<a href="#l11.522"></a><span id="l11.522">       DB_SCHEMA_ACCEPT_DOWNGRADE_HIGH = 39,</span>
<a href="#l11.523"></a><span id="l11.523">       DB_SCHEMA_DOWNGRADE_DELTA = 5;</span>
<a href="#l11.524"></a><span id="l11.524" class="difflineat">@@ -662,18 +654,18 @@ var DB_SCHEMA_ACCEPT_LEAVE_LOW = 31,</span>
<a href="#l11.525"></a><span id="l11.525">  * @namespace</span>
<a href="#l11.526"></a><span id="l11.526">  */</span>
<a href="#l11.527"></a><span id="l11.527"> var GlodaDatastore = {</span>
<a href="#l11.528"></a><span id="l11.528">   _log: null,</span>
<a href="#l11.529"></a><span id="l11.529"> </span>
<a href="#l11.530"></a><span id="l11.530">   /* see Gloda's documentation for these constants */</span>
<a href="#l11.531"></a><span id="l11.531">   kSpecialNotAtAll: 0,</span>
<a href="#l11.532"></a><span id="l11.532">   kSpecialColumn: 16,</span>
<a href="#l11.533"></a><span id="l11.533" class="difflineminus">-  kSpecialColumnChildren: 16|1,</span>
<a href="#l11.534"></a><span id="l11.534" class="difflineminus">-  kSpecialColumnParent: 16|2,</span>
<a href="#l11.535"></a><span id="l11.535" class="difflineplus">+  kSpecialColumnChildren: 16 | 1,</span>
<a href="#l11.536"></a><span id="l11.536" class="difflineplus">+  kSpecialColumnParent: 16 | 2,</span>
<a href="#l11.537"></a><span id="l11.537">   kSpecialString: 32,</span>
<a href="#l11.538"></a><span id="l11.538">   kSpecialFulltext: 64,</span>
<a href="#l11.539"></a><span id="l11.539">   IGNORE_FACET: {},</span>
<a href="#l11.540"></a><span id="l11.540"> </span>
<a href="#l11.541"></a><span id="l11.541">   kConstraintIdIn: 0,</span>
<a href="#l11.542"></a><span id="l11.542">   kConstraintIn: 1,</span>
<a href="#l11.543"></a><span id="l11.543">   kConstraintRanges: 2,</span>
<a href="#l11.544"></a><span id="l11.544">   kConstraintEquals: 3,</span>
<a href="#l11.545"></a><span id="l11.545" class="difflineat">@@ -785,19 +777,19 @@ var GlodaDatastore = {</span>
<a href="#l11.546"></a><span id="l11.546">         columns: [</span>
<a href="#l11.547"></a><span id="l11.547">           [&quot;id&quot;, &quot;INTEGER PRIMARY KEY&quot;],</span>
<a href="#l11.548"></a><span id="l11.548">           [&quot;subject&quot;, &quot;TEXT NOT NULL&quot;],</span>
<a href="#l11.549"></a><span id="l11.549">           [&quot;oldestMessageDate&quot;, &quot;INTEGER&quot;],</span>
<a href="#l11.550"></a><span id="l11.550">           [&quot;newestMessageDate&quot;, &quot;INTEGER&quot;],</span>
<a href="#l11.551"></a><span id="l11.551">         ],</span>
<a href="#l11.552"></a><span id="l11.552"> </span>
<a href="#l11.553"></a><span id="l11.553">         indices: {</span>
<a href="#l11.554"></a><span id="l11.554" class="difflineminus">-          subject: ['subject'],</span>
<a href="#l11.555"></a><span id="l11.555" class="difflineminus">-          oldestMessageDate: ['oldestMessageDate'],</span>
<a href="#l11.556"></a><span id="l11.556" class="difflineminus">-          newestMessageDate: ['newestMessageDate'],</span>
<a href="#l11.557"></a><span id="l11.557" class="difflineplus">+          subject: [&quot;subject&quot;],</span>
<a href="#l11.558"></a><span id="l11.558" class="difflineplus">+          oldestMessageDate: [&quot;oldestMessageDate&quot;],</span>
<a href="#l11.559"></a><span id="l11.559" class="difflineplus">+          newestMessageDate: [&quot;newestMessageDate&quot;],</span>
<a href="#l11.560"></a><span id="l11.560">         },</span>
<a href="#l11.561"></a><span id="l11.561"> </span>
<a href="#l11.562"></a><span id="l11.562">         fulltextColumns: [</span>
<a href="#l11.563"></a><span id="l11.563">           [&quot;subject&quot;, &quot;TEXT&quot;],</span>
<a href="#l11.564"></a><span id="l11.564">         ],</span>
<a href="#l11.565"></a><span id="l11.565"> </span>
<a href="#l11.566"></a><span id="l11.566">         triggers: {</span>
<a href="#l11.567"></a><span id="l11.567">           delete: &quot;DELETE from messages WHERE conversationID = OLD.id&quot;,</span>
<a href="#l11.568"></a><span id="l11.568" class="difflineat">@@ -830,21 +822,21 @@ var GlodaDatastore = {</span>
<a href="#l11.569"></a><span id="l11.569">           // Notability attempts to capture the static 'interestingness' of a</span>
<a href="#l11.570"></a><span id="l11.570">           //  message as a result of being starred/flagged, labeled, read</span>
<a href="#l11.571"></a><span id="l11.571">           //  multiple times, authored by someone in your address book or that</span>
<a href="#l11.572"></a><span id="l11.572">           //  you converse with a lot, etc.</span>
<a href="#l11.573"></a><span id="l11.573">           [&quot;notability&quot;, &quot;INTEGER NOT NULL default 0&quot;],</span>
<a href="#l11.574"></a><span id="l11.574">         ],</span>
<a href="#l11.575"></a><span id="l11.575"> </span>
<a href="#l11.576"></a><span id="l11.576">         indices: {</span>
<a href="#l11.577"></a><span id="l11.577" class="difflineminus">-          messageLocation: ['folderID', 'messageKey'],</span>
<a href="#l11.578"></a><span id="l11.578" class="difflineminus">-          headerMessageID: ['headerMessageID'],</span>
<a href="#l11.579"></a><span id="l11.579" class="difflineminus">-          conversationID: ['conversationID'],</span>
<a href="#l11.580"></a><span id="l11.580" class="difflineminus">-          date: ['date'],</span>
<a href="#l11.581"></a><span id="l11.581" class="difflineminus">-          deleted: ['deleted'],</span>
<a href="#l11.582"></a><span id="l11.582" class="difflineplus">+          messageLocation: [&quot;folderID&quot;, &quot;messageKey&quot;],</span>
<a href="#l11.583"></a><span id="l11.583" class="difflineplus">+          headerMessageID: [&quot;headerMessageID&quot;],</span>
<a href="#l11.584"></a><span id="l11.584" class="difflineplus">+          conversationID: [&quot;conversationID&quot;],</span>
<a href="#l11.585"></a><span id="l11.585" class="difflineplus">+          date: [&quot;date&quot;],</span>
<a href="#l11.586"></a><span id="l11.586" class="difflineplus">+          deleted: [&quot;deleted&quot;],</span>
<a href="#l11.587"></a><span id="l11.587">         },</span>
<a href="#l11.588"></a><span id="l11.588"> </span>
<a href="#l11.589"></a><span id="l11.589">         // note: if reordering the columns, you need to change this file's</span>
<a href="#l11.590"></a><span id="l11.590">         //  row-loading logic, msg_search.js's ranking usages and also the</span>
<a href="#l11.591"></a><span id="l11.591">         //  column saturations in nsGlodaRankerFunction</span>
<a href="#l11.592"></a><span id="l11.592">         fulltextColumns: [</span>
<a href="#l11.593"></a><span id="l11.593">           [&quot;body&quot;, &quot;TEXT&quot;],</span>
<a href="#l11.594"></a><span id="l11.594">           [&quot;subject&quot;, &quot;TEXT&quot;],</span>
<a href="#l11.595"></a><span id="l11.595" class="difflineat">@@ -929,25 +921,24 @@ var GlodaDatastore = {</span>
<a href="#l11.596"></a><span id="l11.596">           popularity: [&quot;popularity&quot;],</span>
<a href="#l11.597"></a><span id="l11.597">           frecency: [&quot;frecency&quot;],</span>
<a href="#l11.598"></a><span id="l11.598">         },</span>
<a href="#l11.599"></a><span id="l11.599">       },</span>
<a href="#l11.600"></a><span id="l11.600"> </span>
<a href="#l11.601"></a><span id="l11.601">       contactAttributes: {</span>
<a href="#l11.602"></a><span id="l11.602">         columns: [</span>
<a href="#l11.603"></a><span id="l11.603">           [&quot;contactID&quot;, &quot;INTEGER NOT NULL&quot;],</span>
<a href="#l11.604"></a><span id="l11.604" class="difflineminus">-          [&quot;attributeID&quot;,</span>
<a href="#l11.605"></a><span id="l11.605" class="difflineminus">-           &quot;INTEGER NOT NULL&quot;],</span>
<a href="#l11.606"></a><span id="l11.606" class="difflineminus">-          [&quot;value&quot;, &quot;NUMERIC&quot;]</span>
<a href="#l11.607"></a><span id="l11.607" class="difflineplus">+          [&quot;attributeID&quot;, &quot;INTEGER NOT NULL&quot;],</span>
<a href="#l11.608"></a><span id="l11.608" class="difflineplus">+          [&quot;value&quot;, &quot;NUMERIC&quot;],</span>
<a href="#l11.609"></a><span id="l11.609">         ],</span>
<a href="#l11.610"></a><span id="l11.610">         indices: {</span>
<a href="#l11.611"></a><span id="l11.611">           contactAttribQuery: [</span>
<a href="#l11.612"></a><span id="l11.612">             &quot;attributeID&quot;, &quot;value&quot;,</span>
<a href="#l11.613"></a><span id="l11.613">             /* covering: */ &quot;contactID&quot;],</span>
<a href="#l11.614"></a><span id="l11.614" class="difflineminus">-        }</span>
<a href="#l11.615"></a><span id="l11.615" class="difflineplus">+        },</span>
<a href="#l11.616"></a><span id="l11.616">       },</span>
<a href="#l11.617"></a><span id="l11.617"> </span>
<a href="#l11.618"></a><span id="l11.618">       /**</span>
<a href="#l11.619"></a><span id="l11.619">        * Identities correspond to specific e-mail addresses, IRC nicks, etc.</span>
<a href="#l11.620"></a><span id="l11.620">        */</span>
<a href="#l11.621"></a><span id="l11.621">       identities: {</span>
<a href="#l11.622"></a><span id="l11.622">         columns: [</span>
<a href="#l11.623"></a><span id="l11.623">           [&quot;id&quot;, &quot;INTEGER PRIMARY KEY&quot;],</span>
<a href="#l11.624"></a><span id="l11.624" class="difflineat">@@ -957,18 +948,18 @@ var GlodaDatastore = {</span>
<a href="#l11.625"></a><span id="l11.625">           [&quot;description&quot;, &quot;NOT NULL&quot;], // what makes this identity different</span>
<a href="#l11.626"></a><span id="l11.626">           // from the others? (ex: home, work, etc.)</span>
<a href="#l11.627"></a><span id="l11.627">           [&quot;relay&quot;, &quot;INTEGER NOT NULL&quot;], // is the identity just a relay</span>
<a href="#l11.628"></a><span id="l11.628">           // mechanism? (ex: mailing list, twitter 'bouncer', IRC gateway, etc.)</span>
<a href="#l11.629"></a><span id="l11.629">         ],</span>
<a href="#l11.630"></a><span id="l11.630"> </span>
<a href="#l11.631"></a><span id="l11.631">         indices: {</span>
<a href="#l11.632"></a><span id="l11.632">           contactQuery: [&quot;contactID&quot;],</span>
<a href="#l11.633"></a><span id="l11.633" class="difflineminus">-          valueQuery: [&quot;kind&quot;, &quot;value&quot;]</span>
<a href="#l11.634"></a><span id="l11.634" class="difflineminus">-        }</span>
<a href="#l11.635"></a><span id="l11.635" class="difflineplus">+          valueQuery: [&quot;kind&quot;, &quot;value&quot;],</span>
<a href="#l11.636"></a><span id="l11.636" class="difflineplus">+        },</span>
<a href="#l11.637"></a><span id="l11.637">       },</span>
<a href="#l11.638"></a><span id="l11.638">     },</span>
<a href="#l11.639"></a><span id="l11.639">   },</span>
<a href="#l11.640"></a><span id="l11.640"> </span>
<a href="#l11.641"></a><span id="l11.641"> </span>
<a href="#l11.642"></a><span id="l11.642">   /* ******************* LOGIC ******************* */</span>
<a href="#l11.643"></a><span id="l11.643">   /**</span>
<a href="#l11.644"></a><span id="l11.644">    * We only have one connection; this name exists for legacy reasons but helps</span>
<a href="#l11.645"></a><span id="l11.645" class="difflineat">@@ -994,17 +985,17 @@ var GlodaDatastore = {</span>
<a href="#l11.646"></a><span id="l11.646">    */</span>
<a href="#l11.647"></a><span id="l11.647">   _datastoreID: null,</span>
<a href="#l11.648"></a><span id="l11.648"> </span>
<a href="#l11.649"></a><span id="l11.649">   /**</span>
<a href="#l11.650"></a><span id="l11.650">    * Initialize logging, create the database if it doesn't exist, &quot;upgrade&quot; it</span>
<a href="#l11.651"></a><span id="l11.651">    *  if it does and it's not up-to-date, fill our authoritative folder uri/id</span>
<a href="#l11.652"></a><span id="l11.652">    *  mapping.</span>
<a href="#l11.653"></a><span id="l11.653">    */</span>
<a href="#l11.654"></a><span id="l11.654" class="difflineminus">-  _init: function gloda_ds_init(aNounIDToDef) {</span>
<a href="#l11.655"></a><span id="l11.655" class="difflineplus">+  _init(aNounIDToDef) {</span>
<a href="#l11.656"></a><span id="l11.656">     this._log = Log4Moz.repository.getLogger(&quot;gloda.datastore&quot;);</span>
<a href="#l11.657"></a><span id="l11.657">     this._log.debug(&quot;Beginning datastore initialization.&quot;);</span>
<a href="#l11.658"></a><span id="l11.658"> </span>
<a href="#l11.659"></a><span id="l11.659">     this._nounIDToDef = aNounIDToDef;</span>
<a href="#l11.660"></a><span id="l11.660"> </span>
<a href="#l11.661"></a><span id="l11.661">     let branch = Services.prefs.getBranch(&quot;mailnews.database.global.datastore.&quot;);</span>
<a href="#l11.662"></a><span id="l11.662">     this._prefBranch = branch;</span>
<a href="#l11.663"></a><span id="l11.663"> </span>
<a href="#l11.664"></a><span id="l11.664" class="difflineat">@@ -1020,67 +1011,61 @@ var GlodaDatastore = {</span>
<a href="#l11.665"></a><span id="l11.665"> </span>
<a href="#l11.666"></a><span id="l11.666">     var dbConnection;</span>
<a href="#l11.667"></a><span id="l11.667"> </span>
<a href="#l11.668"></a><span id="l11.668">     // Report about the size of the database through telemetry (if there's a</span>
<a href="#l11.669"></a><span id="l11.669">     // database, naturally).</span>
<a href="#l11.670"></a><span id="l11.670">     if (dbFile.exists()) {</span>
<a href="#l11.671"></a><span id="l11.671">       try {</span>
<a href="#l11.672"></a><span id="l11.672">         let h = Services.telemetry.getHistogramById(&quot;THUNDERBIRD_GLODA_SIZE_MB&quot;);</span>
<a href="#l11.673"></a><span id="l11.673" class="difflineminus">-        h.add(dbFile.fileSize/1048576);</span>
<a href="#l11.674"></a><span id="l11.674" class="difflineplus">+        h.add(dbFile.fileSize / 1048576);</span>
<a href="#l11.675"></a><span id="l11.675">       } catch (e) {</span>
<a href="#l11.676"></a><span id="l11.676">         this._log.warn(&quot;Couldn't report telemetry&quot;, e);</span>
<a href="#l11.677"></a><span id="l11.677">       }</span>
<a href="#l11.678"></a><span id="l11.678">     }</span>
<a href="#l11.679"></a><span id="l11.679"> </span>
<a href="#l11.680"></a><span id="l11.680">     // Create the file if it does not exist</span>
<a href="#l11.681"></a><span id="l11.681">     if (!dbFile.exists()) {</span>
<a href="#l11.682"></a><span id="l11.682">       this._log.debug(&quot;Creating database because it doesn't exist.&quot;);</span>
<a href="#l11.683"></a><span id="l11.683">       dbConnection = this._createDB(dbFile);</span>
<a href="#l11.684"></a><span id="l11.684" class="difflineminus">-    }</span>
<a href="#l11.685"></a><span id="l11.685" class="difflineminus">-    // It does exist, but we (someday) might need to upgrade the schema</span>
<a href="#l11.686"></a><span id="l11.686" class="difflineminus">-    else {</span>
<a href="#l11.687"></a><span id="l11.687" class="difflineplus">+    } else { // It does exist, but we (someday) might need to upgrade the schema</span>
<a href="#l11.688"></a><span id="l11.688">       // (Exceptions may be thrown if the database is corrupt)</span>
<a href="#l11.689"></a><span id="l11.689">       try {</span>
<a href="#l11.690"></a><span id="l11.690">         dbConnection = Services.storage.openUnsharedDatabase(dbFile);</span>
<a href="#l11.691"></a><span id="l11.691">         let cacheSize = this._determineCachePages(dbConnection);</span>
<a href="#l11.692"></a><span id="l11.692">         // see _createDB...</span>
<a href="#l11.693"></a><span id="l11.693" class="difflineminus">-        dbConnection.executeSimpleSQL(&quot;PRAGMA cache_size = &quot;+cacheSize);</span>
<a href="#l11.694"></a><span id="l11.694" class="difflineplus">+        dbConnection.executeSimpleSQL(&quot;PRAGMA cache_size = &quot; + cacheSize);</span>
<a href="#l11.695"></a><span id="l11.695">         dbConnection.executeSimpleSQL(&quot;PRAGMA synchronous = FULL&quot;);</span>
<a href="#l11.696"></a><span id="l11.696"> </span>
<a href="#l11.697"></a><span id="l11.697">         // Register custom tokenizer to index all language text</span>
<a href="#l11.698"></a><span id="l11.698">         var tokenizer = Cc[&quot;@mozilla.org/messenger/fts3tokenizer;1&quot;].</span>
<a href="#l11.699"></a><span id="l11.699">                           getService(Ci.nsIFts3Tokenizer);</span>
<a href="#l11.700"></a><span id="l11.700">         tokenizer.registerTokenizer(dbConnection);</span>
<a href="#l11.701"></a><span id="l11.701"> </span>
<a href="#l11.702"></a><span id="l11.702">         // -- database schema changes</span>
<a href="#l11.703"></a><span id="l11.703">         let dbSchemaVersion = this._actualSchemaVersion =</span>
<a href="#l11.704"></a><span id="l11.704">           dbConnection.schemaVersion;</span>
<a href="#l11.705"></a><span id="l11.705">         // - database from the future!</span>
<a href="#l11.706"></a><span id="l11.706">         if (dbSchemaVersion &gt; this._schemaVersion) {</span>
<a href="#l11.707"></a><span id="l11.707">           if (dbSchemaVersion &gt;= DB_SCHEMA_ACCEPT_LEAVE_LOW &amp;&amp;</span>
<a href="#l11.708"></a><span id="l11.708">               dbSchemaVersion &lt;= DB_SCHEMA_ACCEPT_LEAVE_HIGH) {</span>
<a href="#l11.709"></a><span id="l11.709">             this._log.debug(&quot;db from the future in acceptable range; leaving &quot; +</span>
<a href="#l11.710"></a><span id="l11.710">                             &quot;version at: &quot; + dbSchemaVersion);</span>
<a href="#l11.711"></a><span id="l11.711" class="difflineminus">-          }</span>
<a href="#l11.712"></a><span id="l11.712" class="difflineminus">-          else if (dbSchemaVersion &gt;= DB_SCHEMA_ACCEPT_DOWNGRADE_LOW &amp;&amp;</span>
<a href="#l11.713"></a><span id="l11.713" class="difflineminus">-                   dbSchemaVersion &lt;= DB_SCHEMA_ACCEPT_DOWNGRADE_HIGH) {</span>
<a href="#l11.714"></a><span id="l11.714" class="difflineplus">+          } else if (dbSchemaVersion &gt;= DB_SCHEMA_ACCEPT_DOWNGRADE_LOW &amp;&amp;</span>
<a href="#l11.715"></a><span id="l11.715" class="difflineplus">+                     dbSchemaVersion &lt;= DB_SCHEMA_ACCEPT_DOWNGRADE_HIGH) {</span>
<a href="#l11.716"></a><span id="l11.716">             let newVersion = dbSchemaVersion - DB_SCHEMA_DOWNGRADE_DELTA;</span>
<a href="#l11.717"></a><span id="l11.717">             this._log.debug(&quot;db from the future in downgrade range; setting &quot; +</span>
<a href="#l11.718"></a><span id="l11.718">                             &quot;version to &quot; + newVersion + &quot; down from &quot; +</span>
<a href="#l11.719"></a><span id="l11.719">                             dbSchemaVersion);</span>
<a href="#l11.720"></a><span id="l11.720">             dbConnection.schemaVersion = this._actualSchemaVersion = newVersion;</span>
<a href="#l11.721"></a><span id="l11.721" class="difflineminus">-          }</span>
<a href="#l11.722"></a><span id="l11.722" class="difflineminus">-          // too far from the future, nuke it.</span>
<a href="#l11.723"></a><span id="l11.723" class="difflineminus">-          else {</span>
<a href="#l11.724"></a><span id="l11.724" class="difflineplus">+          } else { // too far from the future, nuke it.</span>
<a href="#l11.725"></a><span id="l11.725">             dbConnection = this._nukeMigration(dbFile, dbConnection);</span>
<a href="#l11.726"></a><span id="l11.726">           }</span>
<a href="#l11.727"></a><span id="l11.727" class="difflineminus">-        }</span>
<a href="#l11.728"></a><span id="l11.728" class="difflineminus">-        // - database from the past!  migrate it, possibly.</span>
<a href="#l11.729"></a><span id="l11.729" class="difflineminus">-        else if (dbSchemaVersion &lt; this._schemaVersion) {</span>
<a href="#l11.730"></a><span id="l11.730" class="difflineplus">+        } else if (dbSchemaVersion &lt; this._schemaVersion) {</span>
<a href="#l11.731"></a><span id="l11.731" class="difflineplus">+          // - database from the past!  migrate it, possibly.</span>
<a href="#l11.732"></a><span id="l11.732">           this._log.debug(&quot;Need to migrate database.  (DB version: &quot; +</span>
<a href="#l11.733"></a><span id="l11.733">             this._actualSchemaVersion + &quot; desired version: &quot; +</span>
<a href="#l11.734"></a><span id="l11.734">             this._schemaVersion);</span>
<a href="#l11.735"></a><span id="l11.735">           dbConnection = this._migrate(dbFile,</span>
<a href="#l11.736"></a><span id="l11.736">                                        dbConnection,</span>
<a href="#l11.737"></a><span id="l11.737">                                        this._actualSchemaVersion,</span>
<a href="#l11.738"></a><span id="l11.738">                                        this._schemaVersion);</span>
<a href="#l11.739"></a><span id="l11.739">           this._log.debug(&quot;Migration call completed.&quot;);</span>
<a href="#l11.740"></a><span id="l11.740" class="difflineat">@@ -1089,26 +1074,23 @@ var GlodaDatastore = {</span>
<a href="#l11.741"></a><span id="l11.741"> </span>
<a href="#l11.742"></a><span id="l11.742">         // If we never had a datastore ID, make sure to create one now.</span>
<a href="#l11.743"></a><span id="l11.743">         if (!this._prefBranch.prefHasUserValue(&quot;id&quot;)) {</span>
<a href="#l11.744"></a><span id="l11.744">           this._datastoreID = this._generateDatastoreID();</span>
<a href="#l11.745"></a><span id="l11.745">           this._prefBranch.setCharPref(&quot;id&quot;, this._datastoreID);</span>
<a href="#l11.746"></a><span id="l11.746">         } else {</span>
<a href="#l11.747"></a><span id="l11.747">           this._datastoreID = this._prefBranch.getCharPref(&quot;id&quot;);</span>
<a href="#l11.748"></a><span id="l11.748">         }</span>
<a href="#l11.749"></a><span id="l11.749" class="difflineminus">-      }</span>
<a href="#l11.750"></a><span id="l11.750" class="difflineminus">-      // Handle corrupt databases, other oddities</span>
<a href="#l11.751"></a><span id="l11.751" class="difflineminus">-      catch (ex) {</span>
<a href="#l11.752"></a><span id="l11.752" class="difflineplus">+      } catch (ex) { // Handle corrupt databases, other oddities</span>
<a href="#l11.753"></a><span id="l11.753">         if (ex.result == Cr.NS_ERROR_FILE_CORRUPTED) {</span>
<a href="#l11.754"></a><span id="l11.754">           this._log.warn(&quot;Database was corrupt, removing the old one.&quot;);</span>
<a href="#l11.755"></a><span id="l11.755">           dbFile.remove(false);</span>
<a href="#l11.756"></a><span id="l11.756">           this._log.warn(&quot;Removed old database, creating a new one.&quot;);</span>
<a href="#l11.757"></a><span id="l11.757">           dbConnection = this._createDB(dbFile);</span>
<a href="#l11.758"></a><span id="l11.758" class="difflineminus">-        }</span>
<a href="#l11.759"></a><span id="l11.759" class="difflineminus">-        else {</span>
<a href="#l11.760"></a><span id="l11.760" class="difflineplus">+        } else {</span>
<a href="#l11.761"></a><span id="l11.761">           this._log.error(&quot;Unexpected error when trying to open the database:&quot;,</span>
<a href="#l11.762"></a><span id="l11.762">                           ex);</span>
<a href="#l11.763"></a><span id="l11.763">           throw ex;</span>
<a href="#l11.764"></a><span id="l11.764">         }</span>
<a href="#l11.765"></a><span id="l11.765">       }</span>
<a href="#l11.766"></a><span id="l11.766">     }</span>
<a href="#l11.767"></a><span id="l11.767"> </span>
<a href="#l11.768"></a><span id="l11.768">     this.syncConnection = dbConnection;</span>
<a href="#l11.769"></a><span id="l11.769" class="difflineat">@@ -1129,55 +1111,53 @@ var GlodaDatastore = {</span>
<a href="#l11.770"></a><span id="l11.770">     //  we no longer need XPCOM references to (or more significantly, their</span>
<a href="#l11.771"></a><span id="l11.771">     //  message databases.)</span>
<a href="#l11.772"></a><span id="l11.772">     this._folderCleanupTimer =</span>
<a href="#l11.773"></a><span id="l11.773">       Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l11.774"></a><span id="l11.774"> </span>
<a href="#l11.775"></a><span id="l11.775">     this._log.debug(&quot;Completed datastore initialization.&quot;);</span>
<a href="#l11.776"></a><span id="l11.776">   },</span>
<a href="#l11.777"></a><span id="l11.777"> </span>
<a href="#l11.778"></a><span id="l11.778" class="difflineminus">-  observe: function gloda_ds_observe(aSubject, aTopic, aData) {</span>
<a href="#l11.779"></a><span id="l11.779" class="difflineminus">-    if(aTopic != &quot;nsPref:changed&quot;)</span>
<a href="#l11.780"></a><span id="l11.780" class="difflineplus">+  observe(aSubject, aTopic, aData) {</span>
<a href="#l11.781"></a><span id="l11.781" class="difflineplus">+    if (aTopic != &quot;nsPref:changed&quot;)</span>
<a href="#l11.782"></a><span id="l11.782">       return;</span>
<a href="#l11.783"></a><span id="l11.783"> </span>
<a href="#l11.784"></a><span id="l11.784">     if (aData == &quot;explainToPath&quot;) {</span>
<a href="#l11.785"></a><span id="l11.785">       let explainToPath = null;</span>
<a href="#l11.786"></a><span id="l11.786">       try {</span>
<a href="#l11.787"></a><span id="l11.787">         explainToPath = this._prefBranch.getCharPref(&quot;explainToPath&quot;);</span>
<a href="#l11.788"></a><span id="l11.788">         if (explainToPath.trim() == &quot;&quot;)</span>
<a href="#l11.789"></a><span id="l11.789">           explainToPath = null;</span>
<a href="#l11.790"></a><span id="l11.790" class="difflineminus">-      }</span>
<a href="#l11.791"></a><span id="l11.791" class="difflineminus">-      catch (ex) {</span>
<a href="#l11.792"></a><span id="l11.792" class="difflineplus">+      } catch (ex) {</span>
<a href="#l11.793"></a><span id="l11.793">         // don't care if the pref is not there.</span>
<a href="#l11.794"></a><span id="l11.794">       }</span>
<a href="#l11.795"></a><span id="l11.795"> </span>
<a href="#l11.796"></a><span id="l11.796">       // It is conceivable that the name is changing and this isn't a boolean</span>
<a href="#l11.797"></a><span id="l11.797">       // toggle, so always clean out the explain processor.</span>
<a href="#l11.798"></a><span id="l11.798">       if (this._explainProcessor) {</span>
<a href="#l11.799"></a><span id="l11.799">         this._explainProcessor.shutdown();</span>
<a href="#l11.800"></a><span id="l11.800">         this._explainProcessor = null;</span>
<a href="#l11.801"></a><span id="l11.801">       }</span>
<a href="#l11.802"></a><span id="l11.802"> </span>
<a href="#l11.803"></a><span id="l11.803">       if (explainToPath) {</span>
<a href="#l11.804"></a><span id="l11.804">         this._createAsyncStatement = this._createExplainedAsyncStatement;</span>
<a href="#l11.805"></a><span id="l11.805">         this._explainProcessor = new ExplainedStatementProcessor(</span>
<a href="#l11.806"></a><span id="l11.806">                                        explainToPath);</span>
<a href="#l11.807"></a><span id="l11.807" class="difflineminus">-      }</span>
<a href="#l11.808"></a><span id="l11.808" class="difflineminus">-      else {</span>
<a href="#l11.809"></a><span id="l11.809" class="difflineplus">+      } else {</span>
<a href="#l11.810"></a><span id="l11.810">         this._createAsyncStatement = this._realCreateAsyncStatement;</span>
<a href="#l11.811"></a><span id="l11.811">       }</span>
<a href="#l11.812"></a><span id="l11.812">     }</span>
<a href="#l11.813"></a><span id="l11.813">   },</span>
<a href="#l11.814"></a><span id="l11.814"> </span>
<a href="#l11.815"></a><span id="l11.815">   datastoreIsShutdown: false,</span>
<a href="#l11.816"></a><span id="l11.816"> </span>
<a href="#l11.817"></a><span id="l11.817">   /**</span>
<a href="#l11.818"></a><span id="l11.818">    * Perform datastore shutdown.</span>
<a href="#l11.819"></a><span id="l11.819">    */</span>
<a href="#l11.820"></a><span id="l11.820" class="difflineminus">-  shutdown: function gloda_ds_shutdown() {</span>
<a href="#l11.821"></a><span id="l11.821" class="difflineplus">+  shutdown() {</span>
<a href="#l11.822"></a><span id="l11.822">     // Clear out any pending transaction by committing it.</span>
<a href="#l11.823"></a><span id="l11.823">     // The indexer has been shutdown by this point; it no longer has any active</span>
<a href="#l11.824"></a><span id="l11.824">     //  indexing logic and it no longer has active event listeners capable of</span>
<a href="#l11.825"></a><span id="l11.825">     //  generating new activity.</span>
<a href="#l11.826"></a><span id="l11.826">     // Semantic consistency of the database is guaranteed by the indexer's</span>
<a href="#l11.827"></a><span id="l11.827">     //  strategy of only yielding control at coherent times.  Although it takes</span>
<a href="#l11.828"></a><span id="l11.828">     //  multiple calls and multiple SQL operations to update the state of our</span>
<a href="#l11.829"></a><span id="l11.829">     //  database representations, the generator does not yield until it has</span>
<a href="#l11.830"></a><span id="l11.830" class="difflineat">@@ -1200,18 +1180,17 @@ var GlodaDatastore = {</span>
<a href="#l11.831"></a><span id="l11.831"> </span>
<a href="#l11.832"></a><span id="l11.832">     this._log.info(&quot;Closing db connection&quot;);</span>
<a href="#l11.833"></a><span id="l11.833"> </span>
<a href="#l11.834"></a><span id="l11.834">     // we do not expect exceptions, but it's a good idea to avoid having our</span>
<a href="#l11.835"></a><span id="l11.835">     //  shutdown process explode.</span>
<a href="#l11.836"></a><span id="l11.836">     try {</span>
<a href="#l11.837"></a><span id="l11.837">       this._cleanupAsyncStatements();</span>
<a href="#l11.838"></a><span id="l11.838">       this._cleanupSyncStatements();</span>
<a href="#l11.839"></a><span id="l11.839" class="difflineminus">-    }</span>
<a href="#l11.840"></a><span id="l11.840" class="difflineminus">-    catch (ex) {</span>
<a href="#l11.841"></a><span id="l11.841" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.842"></a><span id="l11.842">       this._log.debug(&quot;Unexpected exception during statement cleanup: &quot; + ex);</span>
<a href="#l11.843"></a><span id="l11.843">     }</span>
<a href="#l11.844"></a><span id="l11.844"> </span>
<a href="#l11.845"></a><span id="l11.845">     // it's conceivable we might get a spurious exception here, but we really</span>
<a href="#l11.846"></a><span id="l11.846">     //  shouldn't get one.  again, we want to ensure shutdown runs to completion</span>
<a href="#l11.847"></a><span id="l11.847">     //  and doesn't break our caller.</span>
<a href="#l11.848"></a><span id="l11.848">     try {</span>
<a href="#l11.849"></a><span id="l11.849">       // This currently causes all pending asynchronous operations to be run to</span>
<a href="#l11.850"></a><span id="l11.850" class="difflineat">@@ -1226,40 +1205,39 @@ var GlodaDatastore = {</span>
<a href="#l11.851"></a><span id="l11.851">       // However, the potential for multiple pending expensive queries does</span>
<a href="#l11.852"></a><span id="l11.852">       //  exist, and it may be advisable to attempt to track and cancel those.</span>
<a href="#l11.853"></a><span id="l11.853">       //  For simplicity we don't currently do this, and I expect this should</span>
<a href="#l11.854"></a><span id="l11.854">       //  not pose a major problem, but those are famous last words.</span>
<a href="#l11.855"></a><span id="l11.855">       // Note: asyncClose does not spin a nested event loop, but the thread</span>
<a href="#l11.856"></a><span id="l11.856">       //  manager shutdown code will spin the async thread's event loop, so it</span>
<a href="#l11.857"></a><span id="l11.857">       //  nets out to be the same.</span>
<a href="#l11.858"></a><span id="l11.858">       this.asyncConnection.asyncClose();</span>
<a href="#l11.859"></a><span id="l11.859" class="difflineminus">-    }</span>
<a href="#l11.860"></a><span id="l11.860" class="difflineminus">-    catch (ex) {</span>
<a href="#l11.861"></a><span id="l11.861" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.862"></a><span id="l11.862">       this._log.debug(&quot;Potentially expected exception during connection &quot; +</span>
<a href="#l11.863"></a><span id="l11.863">                       &quot;closure: &quot; + ex);</span>
<a href="#l11.864"></a><span id="l11.864">     }</span>
<a href="#l11.865"></a><span id="l11.865"> </span>
<a href="#l11.866"></a><span id="l11.866">     this.asyncConnection = null;</span>
<a href="#l11.867"></a><span id="l11.867">     this.syncConnection = null;</span>
<a href="#l11.868"></a><span id="l11.868">   },</span>
<a href="#l11.869"></a><span id="l11.869"> </span>
<a href="#l11.870"></a><span id="l11.870">   /**</span>
<a href="#l11.871"></a><span id="l11.871">    * Generates and returns a UUID.</span>
<a href="#l11.872"></a><span id="l11.872">    *</span>
<a href="#l11.873"></a><span id="l11.873">    * @return a UUID as a string, ex: &quot;c4dd0159-9287-480f-a648-a4613e147fdb&quot;</span>
<a href="#l11.874"></a><span id="l11.874">    */</span>
<a href="#l11.875"></a><span id="l11.875" class="difflineminus">-  _generateDatastoreID: function gloda_ds_generateDatastoreID() {</span>
<a href="#l11.876"></a><span id="l11.876" class="difflineplus">+  _generateDatastoreID() {</span>
<a href="#l11.877"></a><span id="l11.877">     let uuidGen = Cc[&quot;@mozilla.org/uuid-generator;1&quot;]</span>
<a href="#l11.878"></a><span id="l11.878">                     .getService(Ci.nsIUUIDGenerator);</span>
<a href="#l11.879"></a><span id="l11.879">     let uuid = uuidGen.generateUUID().toString();</span>
<a href="#l11.880"></a><span id="l11.880">     // We snip off the { and } from each end of the UUID.</span>
<a href="#l11.881"></a><span id="l11.881">     return uuid.substring(1, uuid.length - 2);</span>
<a href="#l11.882"></a><span id="l11.882">   },</span>
<a href="#l11.883"></a><span id="l11.883"> </span>
<a href="#l11.884"></a><span id="l11.884" class="difflineminus">-  _determineCachePages: function gloda_ds_determineCachePages(aDBConn) {</span>
<a href="#l11.885"></a><span id="l11.885" class="difflineplus">+  _determineCachePages(aDBConn) {</span>
<a href="#l11.886"></a><span id="l11.886">     try {</span>
<a href="#l11.887"></a><span id="l11.887">       // For the details of the computations, one should read</span>
<a href="#l11.888"></a><span id="l11.888">       //  nsNavHistory::InitDB. We're slightly diverging from them in the sense</span>
<a href="#l11.889"></a><span id="l11.889">       //  that we won't allow gloda to use insane amounts of memory cache, and</span>
<a href="#l11.890"></a><span id="l11.890">       //  we start with 1% instead of 6% like them.</span>
<a href="#l11.891"></a><span id="l11.891">       let pageStmt = aDBConn.createStatement(&quot;PRAGMA page_size&quot;);</span>
<a href="#l11.892"></a><span id="l11.892">       pageStmt.executeStep();</span>
<a href="#l11.893"></a><span id="l11.893">       let pageSize = pageStmt.row.page_size;</span>
<a href="#l11.894"></a><span id="l11.894" class="difflineat">@@ -1281,27 +1259,27 @@ var GlodaDatastore = {</span>
<a href="#l11.895"></a><span id="l11.895">       // A little bit lower than on my personal machine, will result in ~40M.</span>
<a href="#l11.896"></a><span id="l11.896">       return 1000;</span>
<a href="#l11.897"></a><span id="l11.897">     }</span>
<a href="#l11.898"></a><span id="l11.898">   },</span>
<a href="#l11.899"></a><span id="l11.899"> </span>
<a href="#l11.900"></a><span id="l11.900">   /**</span>
<a href="#l11.901"></a><span id="l11.901">    * Create our database; basically a wrapper around _createSchema.</span>
<a href="#l11.902"></a><span id="l11.902">    */</span>
<a href="#l11.903"></a><span id="l11.903" class="difflineminus">-  _createDB: function gloda_ds_createDB(aDBFile) {</span>
<a href="#l11.904"></a><span id="l11.904" class="difflineplus">+  _createDB(aDBFile) {</span>
<a href="#l11.905"></a><span id="l11.905">     var dbConnection = Services.storage.openUnsharedDatabase(aDBFile);</span>
<a href="#l11.906"></a><span id="l11.906">     // We now follow the Firefox strategy for places, which mainly consists in</span>
<a href="#l11.907"></a><span id="l11.907">     //  picking a default 32k page size, and then figuring out the amount of</span>
<a href="#l11.908"></a><span id="l11.908">     //  cache accordingly. The default 32k come from mozilla/toolkit/storage,</span>
<a href="#l11.909"></a><span id="l11.909">     //  but let's get it directly from sqlite in case they change it.</span>
<a href="#l11.910"></a><span id="l11.910">     let cachePages = this._determineCachePages(dbConnection);</span>
<a href="#l11.911"></a><span id="l11.911">     // This is a maximum number of pages to be used.  If the database does not</span>
<a href="#l11.912"></a><span id="l11.912">     //  get this large, then the memory does not get used.</span>
<a href="#l11.913"></a><span id="l11.913">     // Do not forget to update the code in _init if you change this value.</span>
<a href="#l11.914"></a><span id="l11.914" class="difflineminus">-    dbConnection.executeSimpleSQL(&quot;PRAGMA cache_size = &quot;+cachePages);</span>
<a href="#l11.915"></a><span id="l11.915" class="difflineplus">+    dbConnection.executeSimpleSQL(&quot;PRAGMA cache_size = &quot; + cachePages);</span>
<a href="#l11.916"></a><span id="l11.916">     // The mozStorage default is NORMAL which shaves off some fsyncs in the</span>
<a href="#l11.917"></a><span id="l11.917">     //  interest of performance.  Since everything we do after bootstrap is</span>
<a href="#l11.918"></a><span id="l11.918">     //  async, we do not care about the performance, but we really want the</span>
<a href="#l11.919"></a><span id="l11.919">     //  correctness.  Bug reports and support avenues indicate a non-zero number</span>
<a href="#l11.920"></a><span id="l11.920">     //  of corrupt databases.  Note that this may not fix everything; OS X</span>
<a href="#l11.921"></a><span id="l11.921">     //  also supports an F_FULLSYNC flag enabled by PRAGMA fullfsync that we are</span>
<a href="#l11.922"></a><span id="l11.922">     //  not enabling that is much more comprehensive.  We can think about</span>
<a href="#l11.923"></a><span id="l11.923">     //  turning that on after we've seen how this reduces our corruption count.</span>
<a href="#l11.924"></a><span id="l11.924" class="difflineat">@@ -1316,27 +1294,25 @@ var GlodaDatastore = {</span>
<a href="#l11.925"></a><span id="l11.925">     // has been rebuilt in the event that they need to rebuild dependent data.</span>
<a href="#l11.926"></a><span id="l11.926">     this._datastoreID = this._generateDatastoreID();</span>
<a href="#l11.927"></a><span id="l11.927">     this._prefBranch.setCharPref(&quot;id&quot;, this._datastoreID);</span>
<a href="#l11.928"></a><span id="l11.928"> </span>
<a href="#l11.929"></a><span id="l11.929">     dbConnection.beginTransaction();</span>
<a href="#l11.930"></a><span id="l11.930">     try {</span>
<a href="#l11.931"></a><span id="l11.931">       this._createSchema(dbConnection);</span>
<a href="#l11.932"></a><span id="l11.932">       dbConnection.commitTransaction();</span>
<a href="#l11.933"></a><span id="l11.933" class="difflineminus">-    }</span>
<a href="#l11.934"></a><span id="l11.934" class="difflineminus">-    catch(ex) {</span>
<a href="#l11.935"></a><span id="l11.935" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.936"></a><span id="l11.936">       dbConnection.rollbackTransaction();</span>
<a href="#l11.937"></a><span id="l11.937">       throw ex;</span>
<a href="#l11.938"></a><span id="l11.938">     }</span>
<a href="#l11.939"></a><span id="l11.939"> </span>
<a href="#l11.940"></a><span id="l11.940">     return dbConnection;</span>
<a href="#l11.941"></a><span id="l11.941">   },</span>
<a href="#l11.942"></a><span id="l11.942"> </span>
<a href="#l11.943"></a><span id="l11.943" class="difflineminus">-  _createTableSchema: function gloda_ds_createTableSchema(aDBConnection,</span>
<a href="#l11.944"></a><span id="l11.944" class="difflineminus">-      aTableName, aTableDef) {</span>
<a href="#l11.945"></a><span id="l11.945" class="difflineplus">+  _createTableSchema(aDBConnection, aTableName, aTableDef) {</span>
<a href="#l11.946"></a><span id="l11.946">     // - Create the table</span>
<a href="#l11.947"></a><span id="l11.947">     this._log.info(&quot;Creating table: &quot; + aTableName);</span>
<a href="#l11.948"></a><span id="l11.948">     let columnDefs = [];</span>
<a href="#l11.949"></a><span id="l11.949">     for (let [column, type] of aTableDef.columns) {</span>
<a href="#l11.950"></a><span id="l11.950">       columnDefs.push(column + &quot; &quot; + type);</span>
<a href="#l11.951"></a><span id="l11.951">     }</span>
<a href="#l11.952"></a><span id="l11.952">     aDBConnection.createTable(aTableName, columnDefs.join(&quot;, &quot;));</span>
<a href="#l11.953"></a><span id="l11.953"> </span>
<a href="#l11.954"></a><span id="l11.954" class="difflineat">@@ -1363,60 +1339,59 @@ var GlodaDatastore = {</span>
<a href="#l11.955"></a><span id="l11.955">     }</span>
<a href="#l11.956"></a><span id="l11.956"> </span>
<a href="#l11.957"></a><span id="l11.957">     // - Create the attributes table if applicable</span>
<a href="#l11.958"></a><span id="l11.958">     if (aTableDef.genericAttributes) {</span>
<a href="#l11.959"></a><span id="l11.959">       aTableDef.genericAttributes = {</span>
<a href="#l11.960"></a><span id="l11.960">         columns: [</span>
<a href="#l11.961"></a><span id="l11.961">           [&quot;nounID&quot;, &quot;INTEGER NOT NULL&quot;],</span>
<a href="#l11.962"></a><span id="l11.962">           [&quot;attributeID&quot;, &quot;INTEGER NOT NULL&quot;],</span>
<a href="#l11.963"></a><span id="l11.963" class="difflineminus">-          [&quot;value&quot;, &quot;NUMERIC&quot;]</span>
<a href="#l11.964"></a><span id="l11.964" class="difflineplus">+          [&quot;value&quot;, &quot;NUMERIC&quot;],</span>
<a href="#l11.965"></a><span id="l11.965">         ],</span>
<a href="#l11.966"></a><span id="l11.966" class="difflineminus">-        indices: {}</span>
<a href="#l11.967"></a><span id="l11.967" class="difflineplus">+        indices: {},</span>
<a href="#l11.968"></a><span id="l11.968">       };</span>
<a href="#l11.969"></a><span id="l11.969">       aTableDef.genericAttributes.indices[aTableName + &quot;AttribQuery&quot;] =</span>
<a href="#l11.970"></a><span id="l11.970">         [&quot;attributeID&quot;, &quot;value&quot;, /* covering: */ &quot;nounID&quot;];</span>
<a href="#l11.971"></a><span id="l11.971">       // let's use this very function!  (since we created genericAttributes,</span>
<a href="#l11.972"></a><span id="l11.972">       //  explodey recursion is avoided.)</span>
<a href="#l11.973"></a><span id="l11.973">       this._createTableSchema(aDBConnection, aTableName + &quot;Attributes&quot;,</span>
<a href="#l11.974"></a><span id="l11.974">                               aTableDef.genericAttributes);</span>
<a href="#l11.975"></a><span id="l11.975">     }</span>
<a href="#l11.976"></a><span id="l11.976">   },</span>
<a href="#l11.977"></a><span id="l11.977"> </span>
<a href="#l11.978"></a><span id="l11.978">   /**</span>
<a href="#l11.979"></a><span id="l11.979">    * Create our database schema assuming a newly created database.  This</span>
<a href="#l11.980"></a><span id="l11.980">    *  comes down to creating normal tables, their full-text variants (if</span>
<a href="#l11.981"></a><span id="l11.981">    *  applicable), and their indices.</span>
<a href="#l11.982"></a><span id="l11.982">    */</span>
<a href="#l11.983"></a><span id="l11.983" class="difflineminus">-  _createSchema: function gloda_ds_createSchema(aDBConnection) {</span>
<a href="#l11.984"></a><span id="l11.984" class="difflineplus">+  _createSchema(aDBConnection) {</span>
<a href="#l11.985"></a><span id="l11.985">     // -- For each table...</span>
<a href="#l11.986"></a><span id="l11.986">     for (let tableName in this._schema.tables) {</span>
<a href="#l11.987"></a><span id="l11.987">       let tableDef = this._schema.tables[tableName];</span>
<a href="#l11.988"></a><span id="l11.988">       this._createTableSchema(aDBConnection, tableName, tableDef);</span>
<a href="#l11.989"></a><span id="l11.989">     }</span>
<a href="#l11.990"></a><span id="l11.990"> </span>
<a href="#l11.991"></a><span id="l11.991">     aDBConnection.schemaVersion = this._actualSchemaVersion =</span>
<a href="#l11.992"></a><span id="l11.992">       this._schemaVersion;</span>
<a href="#l11.993"></a><span id="l11.993">   },</span>
<a href="#l11.994"></a><span id="l11.994"> </span>
<a href="#l11.995"></a><span id="l11.995">   /**</span>
<a href="#l11.996"></a><span id="l11.996">    * Create a table for a noun, replete with data binding.</span>
<a href="#l11.997"></a><span id="l11.997">    */</span>
<a href="#l11.998"></a><span id="l11.998" class="difflineminus">-  createNounTable: function gloda_ds_createTableIfNotExists(aNounDef) {</span>
<a href="#l11.999"></a><span id="l11.999" class="difflineplus">+  createNounTable(aNounDef) {</span>
<a href="#l11.1000"></a><span id="l11.1000">     // give it a _jsonText attribute if appropriate...</span>
<a href="#l11.1001"></a><span id="l11.1001">     if (aNounDef.allowsArbitraryAttrs)</span>
<a href="#l11.1002"></a><span id="l11.1002" class="difflineminus">-      aNounDef.schema.columns.push(['jsonAttributes', 'STRING', '_jsonText']);</span>
<a href="#l11.1003"></a><span id="l11.1003" class="difflineplus">+      aNounDef.schema.columns.push([&quot;jsonAttributes&quot;, &quot;STRING&quot;, &quot;_jsonText&quot;]);</span>
<a href="#l11.1004"></a><span id="l11.1004">     // check if the table exists</span>
<a href="#l11.1005"></a><span id="l11.1005">     if (!this.asyncConnection.tableExists(aNounDef.tableName)) {</span>
<a href="#l11.1006"></a><span id="l11.1006">       // it doesn't! create it (and its potentially many variants)</span>
<a href="#l11.1007"></a><span id="l11.1007">       try {</span>
<a href="#l11.1008"></a><span id="l11.1008">         this._createTableSchema(this.asyncConnection, aNounDef.tableName,</span>
<a href="#l11.1009"></a><span id="l11.1009">                                 aNounDef.schema);</span>
<a href="#l11.1010"></a><span id="l11.1010" class="difflineminus">-      }</span>
<a href="#l11.1011"></a><span id="l11.1011" class="difflineminus">-      catch (ex) {</span>
<a href="#l11.1012"></a><span id="l11.1012" class="difflineplus">+      } catch (ex) {</span>
<a href="#l11.1013"></a><span id="l11.1013">          this._log.error(&quot;Problem creating table &quot; + aNounDef.tableName + &quot; &quot; +</span>
<a href="#l11.1014"></a><span id="l11.1014">            &quot;because: &quot; + ex + &quot; at &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l11.1015"></a><span id="l11.1015">          return;</span>
<a href="#l11.1016"></a><span id="l11.1016">       }</span>
<a href="#l11.1017"></a><span id="l11.1017">     }</span>
<a href="#l11.1018"></a><span id="l11.1018"> </span>
<a href="#l11.1019"></a><span id="l11.1019">     aNounDef._dataBinder = new GlodaDatabind(aNounDef, this);</span>
<a href="#l11.1020"></a><span id="l11.1020">     aNounDef.datastore = aNounDef._dataBinder;</span>
<a href="#l11.1021"></a><span id="l11.1021" class="difflineat">@@ -1426,34 +1401,32 @@ var GlodaDatastore = {</span>
<a href="#l11.1022"></a><span id="l11.1022">     aNounDef.dbAttribAdjuster = aNounDef._dataBinder.adjustAttributes;</span>
<a href="#l11.1023"></a><span id="l11.1023"> </span>
<a href="#l11.1024"></a><span id="l11.1024">     if (aNounDef.schema.genericAttributes) {</span>
<a href="#l11.1025"></a><span id="l11.1025">       aNounDef.attrTableName = aNounDef.tableName + &quot;Attributes&quot;;</span>
<a href="#l11.1026"></a><span id="l11.1026">       aNounDef.attrIDColumnName = &quot;nounID&quot;;</span>
<a href="#l11.1027"></a><span id="l11.1027">     }</span>
<a href="#l11.1028"></a><span id="l11.1028">   },</span>
<a href="#l11.1029"></a><span id="l11.1029"> </span>
<a href="#l11.1030"></a><span id="l11.1030" class="difflineminus">-  _nukeMigration: function gloda_ds_nukeMigration(aDBFile, aDBConnection) {</span>
<a href="#l11.1031"></a><span id="l11.1031" class="difflineplus">+  _nukeMigration(aDBFile, aDBConnection) {</span>
<a href="#l11.1032"></a><span id="l11.1032">     aDBConnection.close();</span>
<a href="#l11.1033"></a><span id="l11.1033">     aDBFile.remove(false);</span>
<a href="#l11.1034"></a><span id="l11.1034">     this._log.warn(&quot;Global database has been purged due to schema change.  &quot; +</span>
<a href="#l11.1035"></a><span id="l11.1035">                    &quot;old version was &quot; + this._actualSchemaVersion +</span>
<a href="#l11.1036"></a><span id="l11.1036">                    &quot;, new version is: &quot; + this._schemaVersion);</span>
<a href="#l11.1037"></a><span id="l11.1037">     return this._createDB(aDBFile);</span>
<a href="#l11.1038"></a><span id="l11.1038">   },</span>
<a href="#l11.1039"></a><span id="l11.1039"> </span>
<a href="#l11.1040"></a><span id="l11.1040">   /**</span>
<a href="#l11.1041"></a><span id="l11.1041">    * Migrate the database _to the latest version_ from an older version.  We</span>
<a href="#l11.1042"></a><span id="l11.1042">    *  only keep enough logic around to get us to the recent version.  This code</span>
<a href="#l11.1043"></a><span id="l11.1043">    *  is not a time machine!  If we need to blow away the database to get to the</span>
<a href="#l11.1044"></a><span id="l11.1044">    *  most recent version, then that's the sum total of the migration!</span>
<a href="#l11.1045"></a><span id="l11.1045">    */</span>
<a href="#l11.1046"></a><span id="l11.1046" class="difflineminus">-  _migrate: function gloda_ds_migrate(aDBFile, aDBConnection,</span>
<a href="#l11.1047"></a><span id="l11.1047" class="difflineminus">-                                      aCurVersion, aNewVersion) {</span>
<a href="#l11.1048"></a><span id="l11.1048" class="difflineminus">-</span>
<a href="#l11.1049"></a><span id="l11.1049" class="difflineplus">+  _migrate(aDBFile, aDBConnection, aCurVersion, aNewVersion) {</span>
<a href="#l11.1050"></a><span id="l11.1050">     // version 12:</span>
<a href="#l11.1051"></a><span id="l11.1051">     // - notability column added</span>
<a href="#l11.1052"></a><span id="l11.1052">     // version 13:</span>
<a href="#l11.1053"></a><span id="l11.1053">     // - we are adding a new fulltext index column. blow away!</span>
<a href="#l11.1054"></a><span id="l11.1054">     // - note that I screwed up and failed to mark the schema change; apparently</span>
<a href="#l11.1055"></a><span id="l11.1055">     //   no database will claim to be version 13...</span>
<a href="#l11.1056"></a><span id="l11.1056">     // version 14ish, still labeled 13?:</span>
<a href="#l11.1057"></a><span id="l11.1057">     // - new attributes: forwarded, repliedTo, bcc, recipients</span>
<a href="#l11.1058"></a><span id="l11.1058" class="difflineat">@@ -1506,17 +1479,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1059"></a><span id="l11.1059">    * Asynchronously update the schema version; only for use by in-tree callers</span>
<a href="#l11.1060"></a><span id="l11.1060">    *  who asynchronously perform migration work triggered by their initial</span>
<a href="#l11.1061"></a><span id="l11.1061">    *  indexing sweep and who have properly updated the schema version in all</span>
<a href="#l11.1062"></a><span id="l11.1062">    *  the appropriate locations in this file.</span>
<a href="#l11.1063"></a><span id="l11.1063">    *</span>
<a href="#l11.1064"></a><span id="l11.1064">    * This is done without doing anything about the current transaction state,</span>
<a href="#l11.1065"></a><span id="l11.1065">    *  which is desired.</span>
<a href="#l11.1066"></a><span id="l11.1066">    */</span>
<a href="#l11.1067"></a><span id="l11.1067" class="difflineminus">-  _updateSchemaVersion: function(newSchemaVersion) {</span>
<a href="#l11.1068"></a><span id="l11.1068" class="difflineplus">+  _updateSchemaVersion(newSchemaVersion) {</span>
<a href="#l11.1069"></a><span id="l11.1069">     this._actualSchemaVersion = newSchemaVersion;</span>
<a href="#l11.1070"></a><span id="l11.1070">     let stmt = this._createAsyncStatement(</span>
<a href="#l11.1071"></a><span id="l11.1071">       // we need to concat; pragmas don't like &quot;?1&quot; binds</span>
<a href="#l11.1072"></a><span id="l11.1072">       &quot;PRAGMA user_version = &quot; + newSchemaVersion, true);</span>
<a href="#l11.1073"></a><span id="l11.1073">     stmt.executeAsync(this.trackAsync());</span>
<a href="#l11.1074"></a><span id="l11.1074">     stmt.finalize();</span>
<a href="#l11.1075"></a><span id="l11.1075">   },</span>
<a href="#l11.1076"></a><span id="l11.1076"> </span>
<a href="#l11.1077"></a><span id="l11.1077" class="difflineat">@@ -1524,23 +1497,21 @@ var GlodaDatastore = {</span>
<a href="#l11.1078"></a><span id="l11.1078"> </span>
<a href="#l11.1079"></a><span id="l11.1079">   /**</span>
<a href="#l11.1080"></a><span id="l11.1080">    * Unless debugging, this is just _realCreateAsyncStatement, but in some</span>
<a href="#l11.1081"></a><span id="l11.1081">    *  debugging modes this is instead the helpful wrapper</span>
<a href="#l11.1082"></a><span id="l11.1082">    *  _createExplainedAsyncStatement.</span>
<a href="#l11.1083"></a><span id="l11.1083">    */</span>
<a href="#l11.1084"></a><span id="l11.1084">   _createAsyncStatement: null,</span>
<a href="#l11.1085"></a><span id="l11.1085"> </span>
<a href="#l11.1086"></a><span id="l11.1086" class="difflineminus">-  _realCreateAsyncStatement: function gloda_ds_createAsyncStatement(aSQLString,</span>
<a href="#l11.1087"></a><span id="l11.1087" class="difflineminus">-                                                                aWillFinalize) {</span>
<a href="#l11.1088"></a><span id="l11.1088" class="difflineplus">+  _realCreateAsyncStatement(aSQLString, aWillFinalize) {</span>
<a href="#l11.1089"></a><span id="l11.1089">     let statement = null;</span>
<a href="#l11.1090"></a><span id="l11.1090">     try {</span>
<a href="#l11.1091"></a><span id="l11.1091">       statement = this.asyncConnection.createAsyncStatement(aSQLString);</span>
<a href="#l11.1092"></a><span id="l11.1092" class="difflineminus">-    }</span>
<a href="#l11.1093"></a><span id="l11.1093" class="difflineminus">-    catch(ex) {</span>
<a href="#l11.1094"></a><span id="l11.1094" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.1095"></a><span id="l11.1095">        throw new Error(&quot;error creating async statement &quot; + aSQLString + &quot; - &quot; +</span>
<a href="#l11.1096"></a><span id="l11.1096">              this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l11.1097"></a><span id="l11.1097">              this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l11.1098"></a><span id="l11.1098">     }</span>
<a href="#l11.1099"></a><span id="l11.1099"> </span>
<a href="#l11.1100"></a><span id="l11.1100">     if (!aWillFinalize)</span>
<a href="#l11.1101"></a><span id="l11.1101">       this._outstandingAsyncStatements.push(statement);</span>
<a href="#l11.1102"></a><span id="l11.1102"> </span>
<a href="#l11.1103"></a><span id="l11.1103" class="difflineat">@@ -1555,77 +1526,72 @@ var GlodaDatastore = {</span>
<a href="#l11.1104"></a><span id="l11.1104">   _explainProcessor: null,</span>
<a href="#l11.1105"></a><span id="l11.1105"> </span>
<a href="#l11.1106"></a><span id="l11.1106">   /**</span>
<a href="#l11.1107"></a><span id="l11.1107">    * Wrapped version of _createAsyncStatement that EXPLAINs the statement.  When</span>
<a href="#l11.1108"></a><span id="l11.1108">    *  used this decorates _createAsyncStatement, in which case we are found at</span>
<a href="#l11.1109"></a><span id="l11.1109">    *  that name and the original is at _orig_createAsyncStatement.  This is</span>
<a href="#l11.1110"></a><span id="l11.1110">    *  controlled by the explainToPath preference (see |_init|).</span>
<a href="#l11.1111"></a><span id="l11.1111">    */</span>
<a href="#l11.1112"></a><span id="l11.1112" class="difflineminus">-  _createExplainedAsyncStatement:</span>
<a href="#l11.1113"></a><span id="l11.1113" class="difflineminus">-      function gloda_ds__createExplainedAsyncStatement(aSQLString,</span>
<a href="#l11.1114"></a><span id="l11.1114" class="difflineminus">-                                                       aWillFinalize) {</span>
<a href="#l11.1115"></a><span id="l11.1115" class="difflineplus">+  _createExplainedAsyncStatement(aSQLString, aWillFinalize) {</span>
<a href="#l11.1116"></a><span id="l11.1116">     let realStatement = this._realCreateAsyncStatement(aSQLString,</span>
<a href="#l11.1117"></a><span id="l11.1117">                                                        aWillFinalize);</span>
<a href="#l11.1118"></a><span id="l11.1118">     // don't wrap transaction control statements.</span>
<a href="#l11.1119"></a><span id="l11.1119">     if (aSQLString == &quot;COMMIT&quot; ||</span>
<a href="#l11.1120"></a><span id="l11.1120">         aSQLString == &quot;BEGIN TRANSACTION&quot; ||</span>
<a href="#l11.1121"></a><span id="l11.1121">         aSQLString == &quot;ROLLBACK&quot;)</span>
<a href="#l11.1122"></a><span id="l11.1122">       return realStatement;</span>
<a href="#l11.1123"></a><span id="l11.1123"> </span>
<a href="#l11.1124"></a><span id="l11.1124">     let explainSQL = &quot;EXPLAIN &quot; + aSQLString;</span>
<a href="#l11.1125"></a><span id="l11.1125">     let explainStatement = this._realCreateAsyncStatement(explainSQL);</span>
<a href="#l11.1126"></a><span id="l11.1126"> </span>
<a href="#l11.1127"></a><span id="l11.1127">     return new ExplainedStatementWrapper(realStatement, explainStatement,</span>
<a href="#l11.1128"></a><span id="l11.1128">                                          aSQLString, this._explainProcessor);</span>
<a href="#l11.1129"></a><span id="l11.1129">   },</span>
<a href="#l11.1130"></a><span id="l11.1130"> </span>
<a href="#l11.1131"></a><span id="l11.1131" class="difflineminus">-  _cleanupAsyncStatements: function gloda_ds_cleanupAsyncStatements() {</span>
<a href="#l11.1132"></a><span id="l11.1132" class="difflineplus">+  _cleanupAsyncStatements() {</span>
<a href="#l11.1133"></a><span id="l11.1133">     this._outstandingAsyncStatements.forEach(stmt =&gt; stmt.finalize());</span>
<a href="#l11.1134"></a><span id="l11.1134">   },</span>
<a href="#l11.1135"></a><span id="l11.1135"> </span>
<a href="#l11.1136"></a><span id="l11.1136">   _outstandingSyncStatements: [],</span>
<a href="#l11.1137"></a><span id="l11.1137"> </span>
<a href="#l11.1138"></a><span id="l11.1138" class="difflineminus">-  _createSyncStatement: function gloda_ds_createSyncStatement(aSQLString,</span>
<a href="#l11.1139"></a><span id="l11.1139" class="difflineminus">-                                                              aWillFinalize) {</span>
<a href="#l11.1140"></a><span id="l11.1140" class="difflineplus">+  _createSyncStatement(aSQLString, aWillFinalize) {</span>
<a href="#l11.1141"></a><span id="l11.1141">     let statement = null;</span>
<a href="#l11.1142"></a><span id="l11.1142">     try {</span>
<a href="#l11.1143"></a><span id="l11.1143">       statement = this.syncConnection.createStatement(aSQLString);</span>
<a href="#l11.1144"></a><span id="l11.1144" class="difflineminus">-    }</span>
<a href="#l11.1145"></a><span id="l11.1145" class="difflineminus">-    catch(ex) {</span>
<a href="#l11.1146"></a><span id="l11.1146" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.1147"></a><span id="l11.1147">        throw new Error(&quot;error creating sync statement &quot; + aSQLString + &quot; - &quot; +</span>
<a href="#l11.1148"></a><span id="l11.1148">              this.syncConnection.lastError + &quot;: &quot; +</span>
<a href="#l11.1149"></a><span id="l11.1149">              this.syncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l11.1150"></a><span id="l11.1150">     }</span>
<a href="#l11.1151"></a><span id="l11.1151"> </span>
<a href="#l11.1152"></a><span id="l11.1152">     if (!aWillFinalize)</span>
<a href="#l11.1153"></a><span id="l11.1153">       this._outstandingSyncStatements.push(statement);</span>
<a href="#l11.1154"></a><span id="l11.1154"> </span>
<a href="#l11.1155"></a><span id="l11.1155">     return statement;</span>
<a href="#l11.1156"></a><span id="l11.1156">   },</span>
<a href="#l11.1157"></a><span id="l11.1157"> </span>
<a href="#l11.1158"></a><span id="l11.1158" class="difflineminus">-  _cleanupSyncStatements: function gloda_ds_cleanupSyncStatements() {</span>
<a href="#l11.1159"></a><span id="l11.1159" class="difflineplus">+  _cleanupSyncStatements() {</span>
<a href="#l11.1160"></a><span id="l11.1160">     this._outstandingSyncStatements.forEach(stmt =&gt; stmt.finalize());</span>
<a href="#l11.1161"></a><span id="l11.1161">   },</span>
<a href="#l11.1162"></a><span id="l11.1162"> </span>
<a href="#l11.1163"></a><span id="l11.1163">   /**</span>
<a href="#l11.1164"></a><span id="l11.1164">    * Perform a synchronous executeStep on the statement, handling any</span>
<a href="#l11.1165"></a><span id="l11.1165">    *  SQLITE_BUSY fallout that could conceivably happen from a collision on our</span>
<a href="#l11.1166"></a><span id="l11.1166">    *  read with the async writes.</span>
<a href="#l11.1167"></a><span id="l11.1167">    * Basically we keep trying until we succeed or run out of tries.</span>
<a href="#l11.1168"></a><span id="l11.1168">    * We believe this to be a reasonable course of action because we don't</span>
<a href="#l11.1169"></a><span id="l11.1169">    *  expect this to happen much.</span>
<a href="#l11.1170"></a><span id="l11.1170">    */</span>
<a href="#l11.1171"></a><span id="l11.1171" class="difflineminus">-  _syncStep: function gloda_ds_syncStep(aStatement) {</span>
<a href="#l11.1172"></a><span id="l11.1172" class="difflineplus">+  _syncStep(aStatement) {</span>
<a href="#l11.1173"></a><span id="l11.1173">     let tries = 0;</span>
<a href="#l11.1174"></a><span id="l11.1174">     while (tries &lt; 32000) {</span>
<a href="#l11.1175"></a><span id="l11.1175">       try {</span>
<a href="#l11.1176"></a><span id="l11.1176">         return aStatement.executeStep();</span>
<a href="#l11.1177"></a><span id="l11.1177" class="difflineminus">-      }</span>
<a href="#l11.1178"></a><span id="l11.1178" class="difflineminus">-      catch (e) {</span>
<a href="#l11.1179"></a><span id="l11.1179" class="difflineplus">+      } catch (e) {</span>
<a href="#l11.1180"></a><span id="l11.1180">         // SQLITE_BUSY becomes NS_ERROR_FAILURE</span>
<a href="#l11.1181"></a><span id="l11.1181">         if (e.result == Cr.NS_ERROR_FAILURE) {</span>
<a href="#l11.1182"></a><span id="l11.1182">           tries++;</span>
<a href="#l11.1183"></a><span id="l11.1183">           // we really need to delay here, somehow.  unfortunately, we can't</span>
<a href="#l11.1184"></a><span id="l11.1184">           //  allow event processing to happen, and most of the things we could</span>
<a href="#l11.1185"></a><span id="l11.1185">           //  do to delay ourselves result in event processing happening.  (Use</span>
<a href="#l11.1186"></a><span id="l11.1186">           //  of a timer, a synchronous dispatch, etc.)</span>
<a href="#l11.1187"></a><span id="l11.1187">           // in theory, nsIThreadEventFilter could allow us to stop other events</span>
<a href="#l11.1188"></a><span id="l11.1188" class="difflineat">@@ -1635,37 +1601,38 @@ var GlodaDatastore = {</span>
<a href="#l11.1189"></a><span id="l11.1189">           //  on makes us more likely to yield to the other thread so it can</span>
<a href="#l11.1190"></a><span id="l11.1190">           //  finish what it is doing...</span>
<a href="#l11.1191"></a><span id="l11.1191">         } else {</span>
<a href="#l11.1192"></a><span id="l11.1192">           throw e;</span>
<a href="#l11.1193"></a><span id="l11.1193">         }</span>
<a href="#l11.1194"></a><span id="l11.1194">       }</span>
<a href="#l11.1195"></a><span id="l11.1195">     }</span>
<a href="#l11.1196"></a><span id="l11.1196">     this._log.error(&quot;Synchronous step gave up after &quot; + tries + &quot; tries.&quot;);</span>
<a href="#l11.1197"></a><span id="l11.1197" class="difflineplus">+    return false;</span>
<a href="#l11.1198"></a><span id="l11.1198">   },</span>
<a href="#l11.1199"></a><span id="l11.1199"> </span>
<a href="#l11.1200"></a><span id="l11.1200" class="difflineminus">-  _bindVariant: function gloda_ds_bindBlob(aStatement, aIndex, aVariant) {</span>
<a href="#l11.1201"></a><span id="l11.1201" class="difflineplus">+  _bindVariant(aStatement, aIndex, aVariant) {</span>
<a href="#l11.1202"></a><span id="l11.1202">     aStatement.bindByIndex(aIndex, aVariant);</span>
<a href="#l11.1203"></a><span id="l11.1203">   },</span>
<a href="#l11.1204"></a><span id="l11.1204"> </span>
<a href="#l11.1205"></a><span id="l11.1205">   /**</span>
<a href="#l11.1206"></a><span id="l11.1206">    * Helper that uses the appropriate getter given the data type; should be</span>
<a href="#l11.1207"></a><span id="l11.1207">    *  mooted once we move to 1.9.2 and can use built-in variant support.</span>
<a href="#l11.1208"></a><span id="l11.1208">    */</span>
<a href="#l11.1209"></a><span id="l11.1209" class="difflineminus">-  _getVariant: function gloda_ds_getBlob(aRow, aIndex) {</span>
<a href="#l11.1210"></a><span id="l11.1210" class="difflineplus">+  _getVariant(aRow, aIndex) {</span>
<a href="#l11.1211"></a><span id="l11.1211">     let typeOfIndex = aRow.getTypeOfIndex(aIndex);</span>
<a href="#l11.1212"></a><span id="l11.1212">     if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.1213"></a><span id="l11.1213">       return null;</span>
<a href="#l11.1214"></a><span id="l11.1214">     // XPConnect would just end up going through an intermediary double stage</span>
<a href="#l11.1215"></a><span id="l11.1215">     //  for the int64 case anyways...</span>
<a href="#l11.1216"></a><span id="l11.1216">     else if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_INTEGER ||</span>
<a href="#l11.1217"></a><span id="l11.1217">              typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_DOUBLE)</span>
<a href="#l11.1218"></a><span id="l11.1218">       return aRow.getDouble(aIndex);</span>
<a href="#l11.1219"></a><span id="l11.1219" class="difflineminus">-    else // typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_TEXT</span>
<a href="#l11.1220"></a><span id="l11.1220" class="difflineminus">-      return aRow.getString(aIndex);</span>
<a href="#l11.1221"></a><span id="l11.1221" class="difflineplus">+    // typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_TEXT</span>
<a href="#l11.1222"></a><span id="l11.1222" class="difflineplus">+    return aRow.getString(aIndex);</span>
<a href="#l11.1223"></a><span id="l11.1223">   },</span>
<a href="#l11.1224"></a><span id="l11.1224"> </span>
<a href="#l11.1225"></a><span id="l11.1225">   /** Simple nested transaction support as a performance optimization. */</span>
<a href="#l11.1226"></a><span id="l11.1226">   _transactionDepth: 0,</span>
<a href="#l11.1227"></a><span id="l11.1227">   _transactionGood: false,</span>
<a href="#l11.1228"></a><span id="l11.1228"> </span>
<a href="#l11.1229"></a><span id="l11.1229">   /**</span>
<a href="#l11.1230"></a><span id="l11.1230">    * Self-memoizing BEGIN TRANSACTION statement.</span>
<a href="#l11.1231"></a><span id="l11.1231" class="difflineat">@@ -1694,107 +1661,104 @@ var GlodaDatastore = {</span>
<a href="#l11.1232"></a><span id="l11.1232">     return this._rollbackTransactionStatement;</span>
<a href="#l11.1233"></a><span id="l11.1233">   },</span>
<a href="#l11.1234"></a><span id="l11.1234"> </span>
<a href="#l11.1235"></a><span id="l11.1235">   _pendingPostCommitCallbacks: null,</span>
<a href="#l11.1236"></a><span id="l11.1236">   /**</span>
<a href="#l11.1237"></a><span id="l11.1237">    * Register a callback to be invoked when the current transaction's commit</span>
<a href="#l11.1238"></a><span id="l11.1238">    *  completes.</span>
<a href="#l11.1239"></a><span id="l11.1239">    */</span>
<a href="#l11.1240"></a><span id="l11.1240" class="difflineminus">-  runPostCommit: function gloda_ds_runPostCommit(aCallback) {</span>
<a href="#l11.1241"></a><span id="l11.1241" class="difflineplus">+  runPostCommit(aCallback) {</span>
<a href="#l11.1242"></a><span id="l11.1242">     this._pendingPostCommitCallbacks.push(aCallback);</span>
<a href="#l11.1243"></a><span id="l11.1243">   },</span>
<a href="#l11.1244"></a><span id="l11.1244"> </span>
<a href="#l11.1245"></a><span id="l11.1245">   /**</span>
<a href="#l11.1246"></a><span id="l11.1246">    * Begin a potentially nested transaction; only the outermost transaction gets</span>
<a href="#l11.1247"></a><span id="l11.1247">    *  to be an actual transaction, and the failure of any nested transaction</span>
<a href="#l11.1248"></a><span id="l11.1248">    *  results in a rollback of the entire outer transaction.  If you really</span>
<a href="#l11.1249"></a><span id="l11.1249">    *  need an atomic transaction</span>
<a href="#l11.1250"></a><span id="l11.1250">    */</span>
<a href="#l11.1251"></a><span id="l11.1251" class="difflineminus">-  _beginTransaction: function gloda_ds_beginTransaction() {</span>
<a href="#l11.1252"></a><span id="l11.1252" class="difflineplus">+  _beginTransaction() {</span>
<a href="#l11.1253"></a><span id="l11.1253">     if (this._transactionDepth == 0) {</span>
<a href="#l11.1254"></a><span id="l11.1254">       this._pendingPostCommitCallbacks = [];</span>
<a href="#l11.1255"></a><span id="l11.1255">       this._beginTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l11.1256"></a><span id="l11.1256">       this._transactionGood = true;</span>
<a href="#l11.1257"></a><span id="l11.1257">     }</span>
<a href="#l11.1258"></a><span id="l11.1258">     this._transactionDepth++;</span>
<a href="#l11.1259"></a><span id="l11.1259">   },</span>
<a href="#l11.1260"></a><span id="l11.1260">   /**</span>
<a href="#l11.1261"></a><span id="l11.1261">    * Commit a potentially nested transaction; if we are the outer-most</span>
<a href="#l11.1262"></a><span id="l11.1262">    *  transaction and no sub-transaction issues a rollback</span>
<a href="#l11.1263"></a><span id="l11.1263">    *  (via _rollbackTransaction) then we commit, otherwise we rollback.</span>
<a href="#l11.1264"></a><span id="l11.1264">    */</span>
<a href="#l11.1265"></a><span id="l11.1265" class="difflineminus">-  _commitTransaction: function gloda_ds_commitTransaction() {</span>
<a href="#l11.1266"></a><span id="l11.1266" class="difflineplus">+  _commitTransaction() {</span>
<a href="#l11.1267"></a><span id="l11.1267">     this._transactionDepth--;</span>
<a href="#l11.1268"></a><span id="l11.1268">     if (this._transactionDepth == 0) {</span>
<a href="#l11.1269"></a><span id="l11.1269">       try {</span>
<a href="#l11.1270"></a><span id="l11.1270">         if (this._transactionGood)</span>
<a href="#l11.1271"></a><span id="l11.1271">           this._commitTransactionStatement.executeAsync(</span>
<a href="#l11.1272"></a><span id="l11.1272">             new PostCommitHandler(this._pendingPostCommitCallbacks));</span>
<a href="#l11.1273"></a><span id="l11.1273">         else</span>
<a href="#l11.1274"></a><span id="l11.1274">           this._rollbackTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l11.1275"></a><span id="l11.1275" class="difflineminus">-      }</span>
<a href="#l11.1276"></a><span id="l11.1276" class="difflineminus">-      catch (ex) {</span>
<a href="#l11.1277"></a><span id="l11.1277" class="difflineplus">+      } catch (ex) {</span>
<a href="#l11.1278"></a><span id="l11.1278">         this._log.error(&quot;Commit problem:&quot;, ex);</span>
<a href="#l11.1279"></a><span id="l11.1279">       }</span>
<a href="#l11.1280"></a><span id="l11.1280">       this._pendingPostCommitCallbacks = [];</span>
<a href="#l11.1281"></a><span id="l11.1281">     }</span>
<a href="#l11.1282"></a><span id="l11.1282">   },</span>
<a href="#l11.1283"></a><span id="l11.1283">   /**</span>
<a href="#l11.1284"></a><span id="l11.1284">    * Abort the commit of the potentially nested transaction.  If we are not the</span>
<a href="#l11.1285"></a><span id="l11.1285">    *  outermost transaction, we set a flag that tells the outermost transaction</span>
<a href="#l11.1286"></a><span id="l11.1286">    *  that it must roll back.</span>
<a href="#l11.1287"></a><span id="l11.1287">    */</span>
<a href="#l11.1288"></a><span id="l11.1288" class="difflineminus">-  _rollbackTransaction: function gloda_ds_rollbackTransaction() {</span>
<a href="#l11.1289"></a><span id="l11.1289" class="difflineplus">+  _rollbackTransaction() {</span>
<a href="#l11.1290"></a><span id="l11.1290">     this._transactionDepth--;</span>
<a href="#l11.1291"></a><span id="l11.1291">     this._transactionGood = false;</span>
<a href="#l11.1292"></a><span id="l11.1292">     if (this._transactionDepth == 0) {</span>
<a href="#l11.1293"></a><span id="l11.1293">       try {</span>
<a href="#l11.1294"></a><span id="l11.1294">         this._rollbackTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l11.1295"></a><span id="l11.1295" class="difflineminus">-      }</span>
<a href="#l11.1296"></a><span id="l11.1296" class="difflineminus">-      catch (ex) {</span>
<a href="#l11.1297"></a><span id="l11.1297" class="difflineplus">+      } catch (ex) {</span>
<a href="#l11.1298"></a><span id="l11.1298">         this._log.error(&quot;Rollback problem:&quot;, ex);</span>
<a href="#l11.1299"></a><span id="l11.1299">       }</span>
<a href="#l11.1300"></a><span id="l11.1300">     }</span>
<a href="#l11.1301"></a><span id="l11.1301">   },</span>
<a href="#l11.1302"></a><span id="l11.1302"> </span>
<a href="#l11.1303"></a><span id="l11.1303">   _pendingAsyncStatements: 0,</span>
<a href="#l11.1304"></a><span id="l11.1304">   /**</span>
<a href="#l11.1305"></a><span id="l11.1305">    * The function to call, if any, when we hit 0 pending async statements.</span>
<a href="#l11.1306"></a><span id="l11.1306">    */</span>
<a href="#l11.1307"></a><span id="l11.1307">   _pendingAsyncCompletedListener: null,</span>
<a href="#l11.1308"></a><span id="l11.1308" class="difflineminus">-  _asyncCompleted: function () {</span>
<a href="#l11.1309"></a><span id="l11.1309" class="difflineplus">+  _asyncCompleted() {</span>
<a href="#l11.1310"></a><span id="l11.1310">     if (--this._pendingAsyncStatements == 0) {</span>
<a href="#l11.1311"></a><span id="l11.1311">       if (this._pendingAsyncCompletedListener !== null) {</span>
<a href="#l11.1312"></a><span id="l11.1312">         this._pendingAsyncCompletedListener();</span>
<a href="#l11.1313"></a><span id="l11.1313">         this._pendingAsyncCompletedListener = null;</span>
<a href="#l11.1314"></a><span id="l11.1314">       }</span>
<a href="#l11.1315"></a><span id="l11.1315">     }</span>
<a href="#l11.1316"></a><span id="l11.1316">   },</span>
<a href="#l11.1317"></a><span id="l11.1317">   _asyncTrackerListener: {</span>
<a href="#l11.1318"></a><span id="l11.1318" class="difflineminus">-    handleResult: function () {},</span>
<a href="#l11.1319"></a><span id="l11.1319" class="difflineminus">-    handleError: function(aError) {</span>
<a href="#l11.1320"></a><span id="l11.1320" class="difflineplus">+    handleResult() {},</span>
<a href="#l11.1321"></a><span id="l11.1321" class="difflineplus">+    handleError(aError) {</span>
<a href="#l11.1322"></a><span id="l11.1322">         GlodaDatastore._log.error(&quot;got error in _asyncTrackerListener.handleError(): &quot; +</span>
<a href="#l11.1323"></a><span id="l11.1323">                         aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l11.1324"></a><span id="l11.1324">     },</span>
<a href="#l11.1325"></a><span id="l11.1325" class="difflineminus">-    handleCompletion: function () {</span>
<a href="#l11.1326"></a><span id="l11.1326" class="difflineplus">+    handleCompletion() {</span>
<a href="#l11.1327"></a><span id="l11.1327">       try {</span>
<a href="#l11.1328"></a><span id="l11.1328">         // the helper method exists because the other classes need to call it too</span>
<a href="#l11.1329"></a><span id="l11.1329">         GlodaDatastore._asyncCompleted();</span>
<a href="#l11.1330"></a><span id="l11.1330" class="difflineminus">-      }</span>
<a href="#l11.1331"></a><span id="l11.1331" class="difflineminus">-      catch (e) {</span>
<a href="#l11.1332"></a><span id="l11.1332" class="difflineplus">+      } catch (e) {</span>
<a href="#l11.1333"></a><span id="l11.1333">         this._log.error(&quot;Exception in handleCompletion:&quot;, e);</span>
<a href="#l11.1334"></a><span id="l11.1334">       }</span>
<a href="#l11.1335"></a><span id="l11.1335" class="difflineminus">-    }</span>
<a href="#l11.1336"></a><span id="l11.1336" class="difflineplus">+    },</span>
<a href="#l11.1337"></a><span id="l11.1337">   },</span>
<a href="#l11.1338"></a><span id="l11.1338">   /**</span>
<a href="#l11.1339"></a><span id="l11.1339">    * Increments _pendingAsyncStatements and returns a listener that will</span>
<a href="#l11.1340"></a><span id="l11.1340">    *  decrement the value when the statement completes.</span>
<a href="#l11.1341"></a><span id="l11.1341">    */</span>
<a href="#l11.1342"></a><span id="l11.1342" class="difflineminus">-  trackAsync: function() {</span>
<a href="#l11.1343"></a><span id="l11.1343" class="difflineplus">+  trackAsync() {</span>
<a href="#l11.1344"></a><span id="l11.1344">     this._pendingAsyncStatements++;</span>
<a href="#l11.1345"></a><span id="l11.1345">     return this._asyncTrackerListener;</span>
<a href="#l11.1346"></a><span id="l11.1346">   },</span>
<a href="#l11.1347"></a><span id="l11.1347"> </span>
<a href="#l11.1348"></a><span id="l11.1348">   /* ********** Attribute Definitions ********** */</span>
<a href="#l11.1349"></a><span id="l11.1349">   /** Maps (attribute def) compound names to the GlodaAttributeDBDef objects. */</span>
<a href="#l11.1350"></a><span id="l11.1350">   _attributeDBDefs: {},</span>
<a href="#l11.1351"></a><span id="l11.1351">   /** Map attribute ID to the definition and parameter value that produce it. */</span>
<a href="#l11.1352"></a><span id="l11.1352" class="difflineat">@@ -1812,17 +1776,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1353"></a><span id="l11.1353">    *  Since we mediate the access, there's no real risk to doing so, and it</span>
<a href="#l11.1354"></a><span id="l11.1354">    *  allows us to keep the writes on the async connection without having to</span>
<a href="#l11.1355"></a><span id="l11.1355">    *  wait for a completion notification.</span>
<a href="#l11.1356"></a><span id="l11.1356">    *</span>
<a href="#l11.1357"></a><span id="l11.1357">    * Start from 32 so we can have a number of sentinel values.</span>
<a href="#l11.1358"></a><span id="l11.1358">    */</span>
<a href="#l11.1359"></a><span id="l11.1359">   _nextAttributeId: 32,</span>
<a href="#l11.1360"></a><span id="l11.1360"> </span>
<a href="#l11.1361"></a><span id="l11.1361" class="difflineminus">-  _populateAttributeDefManagedId: function () {</span>
<a href="#l11.1362"></a><span id="l11.1362" class="difflineplus">+  _populateAttributeDefManagedId() {</span>
<a href="#l11.1363"></a><span id="l11.1363">     let stmt = this._createSyncStatement(</span>
<a href="#l11.1364"></a><span id="l11.1364">       &quot;SELECT MAX(id) FROM attributeDefinitions&quot;, true);</span>
<a href="#l11.1365"></a><span id="l11.1365">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l11.1366"></a><span id="l11.1366">       // 0 gets returned even if there are no messages...</span>
<a href="#l11.1367"></a><span id="l11.1367">       let highestSeen = stmt.getInt64(0);</span>
<a href="#l11.1368"></a><span id="l11.1368">       if (highestSeen != 0)</span>
<a href="#l11.1369"></a><span id="l11.1369">         this._nextAttributeId = highestSeen + 1;</span>
<a href="#l11.1370"></a><span id="l11.1370">     }</span>
<a href="#l11.1371"></a><span id="l11.1371" class="difflineat">@@ -1841,18 +1805,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1372"></a><span id="l11.1372">   /**</span>
<a href="#l11.1373"></a><span id="l11.1373">    * Create an attribute definition and return the row ID.  Special/atypical</span>
<a href="#l11.1374"></a><span id="l11.1374">    *  in that it doesn't directly return a GlodaAttributeDBDef; we leave that up</span>
<a href="#l11.1375"></a><span id="l11.1375">    *  to the caller since they know much more than actually needs to go in the</span>
<a href="#l11.1376"></a><span id="l11.1376">    *  database.</span>
<a href="#l11.1377"></a><span id="l11.1377">    *</span>
<a href="#l11.1378"></a><span id="l11.1378">    * @return The attribute id allocated to this attribute.</span>
<a href="#l11.1379"></a><span id="l11.1379">    */</span>
<a href="#l11.1380"></a><span id="l11.1380" class="difflineminus">-  _createAttributeDef: function gloda_ds_createAttributeDef(aAttrType,</span>
<a href="#l11.1381"></a><span id="l11.1381" class="difflineminus">-                                    aExtensionName, aAttrName, aParameter) {</span>
<a href="#l11.1382"></a><span id="l11.1382" class="difflineplus">+  _createAttributeDef(aAttrType, aExtensionName, aAttrName, aParameter) {</span>
<a href="#l11.1383"></a><span id="l11.1383">     let attributeId = this._nextAttributeId++;</span>
<a href="#l11.1384"></a><span id="l11.1384"> </span>
<a href="#l11.1385"></a><span id="l11.1385">     let iads = this._insertAttributeDefStatement;</span>
<a href="#l11.1386"></a><span id="l11.1386">     iads.bindByIndex(0, attributeId);</span>
<a href="#l11.1387"></a><span id="l11.1387">     iads.bindByIndex(1, aAttrType);</span>
<a href="#l11.1388"></a><span id="l11.1388">     iads.bindByIndex(2, aExtensionName);</span>
<a href="#l11.1389"></a><span id="l11.1389">     iads.bindByIndex(3, aAttrName);</span>
<a href="#l11.1390"></a><span id="l11.1390">     this._bindVariant(iads, 4, aParameter);</span>
<a href="#l11.1391"></a><span id="l11.1391" class="difflineat">@@ -1863,17 +1826,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1392"></a><span id="l11.1392">   },</span>
<a href="#l11.1393"></a><span id="l11.1393"> </span>
<a href="#l11.1394"></a><span id="l11.1394">   /**</span>
<a href="#l11.1395"></a><span id="l11.1395">    * Sync-ly look-up all the attribute definitions, populating our authoritative</span>
<a href="#l11.1396"></a><span id="l11.1396">    *  _attributeDBDefss and _attributeIDToDBDefAndParam maps.  (In other words,</span>
<a href="#l11.1397"></a><span id="l11.1397">    *  once this method is called, those maps should always be in sync with the</span>
<a href="#l11.1398"></a><span id="l11.1398">    *  underlying database.)</span>
<a href="#l11.1399"></a><span id="l11.1399">    */</span>
<a href="#l11.1400"></a><span id="l11.1400" class="difflineminus">-  getAllAttributes: function gloda_ds_getAllAttributes() {</span>
<a href="#l11.1401"></a><span id="l11.1401" class="difflineplus">+  getAllAttributes() {</span>
<a href="#l11.1402"></a><span id="l11.1402">     let stmt = this._createSyncStatement(</span>
<a href="#l11.1403"></a><span id="l11.1403">       &quot;SELECT id, attributeType, extensionName, name, parameter \</span>
<a href="#l11.1404"></a><span id="l11.1404">          FROM attributeDefinitions&quot;, true);</span>
<a href="#l11.1405"></a><span id="l11.1405"> </span>
<a href="#l11.1406"></a><span id="l11.1406">     // map compound name to the attribute</span>
<a href="#l11.1407"></a><span id="l11.1407">     let attribs = {};</span>
<a href="#l11.1408"></a><span id="l11.1408">     // map the attribute id to [attribute, parameter] where parameter is null</span>
<a href="#l11.1409"></a><span id="l11.1409">     //  in cases where parameter is unused.</span>
<a href="#l11.1410"></a><span id="l11.1410" class="difflineat">@@ -1920,17 +1883,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1411"></a><span id="l11.1411">   },</span>
<a href="#l11.1412"></a><span id="l11.1412"> </span>
<a href="#l11.1413"></a><span id="l11.1413">   /**</span>
<a href="#l11.1414"></a><span id="l11.1414">    * Helper method for GlodaAttributeDBDef to tell us when their bindParameter</span>
<a href="#l11.1415"></a><span id="l11.1415">    *  method is called and they have created a new binding (using</span>
<a href="#l11.1416"></a><span id="l11.1416">    *  GlodaDatastore._createAttributeDef).  In theory, that method could take</span>
<a href="#l11.1417"></a><span id="l11.1417">    *  an additional argument and obviate the need for this method.</span>
<a href="#l11.1418"></a><span id="l11.1418">    */</span>
<a href="#l11.1419"></a><span id="l11.1419" class="difflineminus">-  reportBinding: function gloda_ds_reportBinding(aID, aAttrDef, aParamValue) {</span>
<a href="#l11.1420"></a><span id="l11.1420" class="difflineplus">+  reportBinding(aID, aAttrDef, aParamValue) {</span>
<a href="#l11.1421"></a><span id="l11.1421">     this._attributeIDToDBDefAndParam[aID] = [aAttrDef, aParamValue];</span>
<a href="#l11.1422"></a><span id="l11.1422">   },</span>
<a href="#l11.1423"></a><span id="l11.1423"> </span>
<a href="#l11.1424"></a><span id="l11.1424">   /* ********** Folders ********** */</span>
<a href="#l11.1425"></a><span id="l11.1425">   /** next folder (row) id to issue, populated by _getAllFolderMappings. */</span>
<a href="#l11.1426"></a><span id="l11.1426">   _nextFolderId: 1,</span>
<a href="#l11.1427"></a><span id="l11.1427"> </span>
<a href="#l11.1428"></a><span id="l11.1428">   get _insertFolderLocationStatement() {</span>
<a href="#l11.1429"></a><span id="l11.1429" class="difflineat">@@ -1948,17 +1911,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1430"></a><span id="l11.1430">    *  sense that this map exactly represents the state of the underlying</span>
<a href="#l11.1431"></a><span id="l11.1431">    *  database.  If it does not, it's a bug in updating the database.)</span>
<a href="#l11.1432"></a><span id="l11.1432">    */</span>
<a href="#l11.1433"></a><span id="l11.1433">   _folderByURI: {},</span>
<a href="#l11.1434"></a><span id="l11.1434">   /** Authoritative map from folder ID to folder URI */</span>
<a href="#l11.1435"></a><span id="l11.1435">   _folderByID: {},</span>
<a href="#l11.1436"></a><span id="l11.1436"> </span>
<a href="#l11.1437"></a><span id="l11.1437">   /** Initialize our _folderByURI/_folderByID mappings, called by _init(). */</span>
<a href="#l11.1438"></a><span id="l11.1438" class="difflineminus">-  _getAllFolderMappings: function gloda_ds_getAllFolderMappings() {</span>
<a href="#l11.1439"></a><span id="l11.1439" class="difflineplus">+  _getAllFolderMappings() {</span>
<a href="#l11.1440"></a><span id="l11.1440">     let stmt = this._createSyncStatement(</span>
<a href="#l11.1441"></a><span id="l11.1441">       &quot;SELECT id, folderURI, dirtyStatus, name, indexingPriority \</span>
<a href="#l11.1442"></a><span id="l11.1442">         FROM folderLocations&quot;, true);</span>
<a href="#l11.1443"></a><span id="l11.1443"> </span>
<a href="#l11.1444"></a><span id="l11.1444">     while (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l11.1445"></a><span id="l11.1445">       let folderID = stmt.getInt64(0);</span>
<a href="#l11.1446"></a><span id="l11.1446">       let folderURI = stmt.getString(1);</span>
<a href="#l11.1447"></a><span id="l11.1447">       let dirtyStatus = stmt.getInt32(2);</span>
<a href="#l11.1448"></a><span id="l11.1448" class="difflineat">@@ -1972,36 +1935,35 @@ var GlodaDatastore = {</span>
<a href="#l11.1449"></a><span id="l11.1449">       this._folderByID[folderID] = folder;</span>
<a href="#l11.1450"></a><span id="l11.1450"> </span>
<a href="#l11.1451"></a><span id="l11.1451">       if (folderID &gt;= this._nextFolderId)</span>
<a href="#l11.1452"></a><span id="l11.1452">         this._nextFolderId = folderID + 1;</span>
<a href="#l11.1453"></a><span id="l11.1453">     }</span>
<a href="#l11.1454"></a><span id="l11.1454">     stmt.finalize();</span>
<a href="#l11.1455"></a><span id="l11.1455">   },</span>
<a href="#l11.1456"></a><span id="l11.1456"> </span>
<a href="#l11.1457"></a><span id="l11.1457" class="difflineminus">-  _folderKnown: function gloda_ds_folderKnown(aFolder) {</span>
<a href="#l11.1458"></a><span id="l11.1458" class="difflineplus">+  _folderKnown(aFolder) {</span>
<a href="#l11.1459"></a><span id="l11.1459">     let folderURI = aFolder.URI;</span>
<a href="#l11.1460"></a><span id="l11.1460">     return folderURI in this._folderByURI;</span>
<a href="#l11.1461"></a><span id="l11.1461">   },</span>
<a href="#l11.1462"></a><span id="l11.1462"> </span>
<a href="#l11.1463"></a><span id="l11.1463" class="difflineminus">-  _folderIdKnown: function gloda_ds_folderIdKnown(aFolderID) {</span>
<a href="#l11.1464"></a><span id="l11.1464" class="difflineplus">+  _folderIdKnown(aFolderID) {</span>
<a href="#l11.1465"></a><span id="l11.1465">     return (aFolderID in this._folderByID);</span>
<a href="#l11.1466"></a><span id="l11.1466">   },</span>
<a href="#l11.1467"></a><span id="l11.1467"> </span>
<a href="#l11.1468"></a><span id="l11.1468">   /**</span>
<a href="#l11.1469"></a><span id="l11.1469">    * Return the default messaging priority for a folder of this type, based</span>
<a href="#l11.1470"></a><span id="l11.1470">    * on the folder's flags. If aAllowSpecialFolderIndexing is true, then</span>
<a href="#l11.1471"></a><span id="l11.1471">    * folders suchs as Trash and Junk will be indexed.</span>
<a href="#l11.1472"></a><span id="l11.1472">    *</span>
<a href="#l11.1473"></a><span id="l11.1473">    * @param {nsIMsgFolder} aFolder</span>
<a href="#l11.1474"></a><span id="l11.1474">    * @param {boolean} aAllowSpecialFolderIndexing</span>
<a href="#l11.1475"></a><span id="l11.1475">    * @returns {Number}</span>
<a href="#l11.1476"></a><span id="l11.1476">    */</span>
<a href="#l11.1477"></a><span id="l11.1477" class="difflineminus">-  getDefaultIndexingPriority: function gloda_ds_getDefaultIndexingPriority(aFolder, aAllowSpecialFolderIndexing) {</span>
<a href="#l11.1478"></a><span id="l11.1478" class="difflineminus">-</span>
<a href="#l11.1479"></a><span id="l11.1479" class="difflineplus">+  getDefaultIndexingPriority(aFolder, aAllowSpecialFolderIndexing) {</span>
<a href="#l11.1480"></a><span id="l11.1480">     let indexingPriority = GlodaFolder.prototype.kIndexingDefaultPriority;</span>
<a href="#l11.1481"></a><span id="l11.1481">     // Do not walk into trash/junk folders, unless the user is explicitly</span>
<a href="#l11.1482"></a><span id="l11.1482">     //  telling us to do so.</span>
<a href="#l11.1483"></a><span id="l11.1483">     let specialFolderFlags = Ci.nsMsgFolderFlags.Trash | Ci.nsMsgFolderFlags.Junk;</span>
<a href="#l11.1484"></a><span id="l11.1484">     if (aFolder.isSpecialFolder(specialFolderFlags, true))</span>
<a href="#l11.1485"></a><span id="l11.1485">       indexingPriority = aAllowSpecialFolderIndexing ?</span>
<a href="#l11.1486"></a><span id="l11.1486">                            GlodaFolder.prototype.kIndexingDefaultPriority :</span>
<a href="#l11.1487"></a><span id="l11.1487">                            GlodaFolder.prototype.kIndexingNeverPriority;</span>
<a href="#l11.1488"></a><span id="l11.1488" class="difflineat">@@ -2011,18 +1973,18 @@ var GlodaDatastore = {</span>
<a href="#l11.1489"></a><span id="l11.1489">     // Other user IMAP folders should be ignored because it's not this user's</span>
<a href="#l11.1490"></a><span id="l11.1490">     //  mail.</span>
<a href="#l11.1491"></a><span id="l11.1491">     else if (aFolder.flags &amp; (Ci.nsMsgFolderFlags.Queue</span>
<a href="#l11.1492"></a><span id="l11.1492">                               | Ci.nsMsgFolderFlags.Newsgroup</span>
<a href="#l11.1493"></a><span id="l11.1493">                               // In unit testing at least folders can be</span>
<a href="#l11.1494"></a><span id="l11.1494">                               // confusingly labeled ImapPublic when they</span>
<a href="#l11.1495"></a><span id="l11.1495">                               // should not be.  Or at least I don't think they</span>
<a href="#l11.1496"></a><span id="l11.1496">                               // should be.  So they're legit for now.</span>
<a href="#l11.1497"></a><span id="l11.1497" class="difflineminus">-                              //| Ci.nsMsgFolderFlags.ImapPublic</span>
<a href="#l11.1498"></a><span id="l11.1498" class="difflineminus">-                              //| Ci.nsMsgFolderFlags.ImapOtherUser</span>
<a href="#l11.1499"></a><span id="l11.1499" class="difflineplus">+                              // | Ci.nsMsgFolderFlags.ImapPublic</span>
<a href="#l11.1500"></a><span id="l11.1500" class="difflineplus">+                              // | Ci.nsMsgFolderFlags.ImapOtherUser</span>
<a href="#l11.1501"></a><span id="l11.1501">                              ))</span>
<a href="#l11.1502"></a><span id="l11.1502">       indexingPriority = GlodaFolder.prototype.kIndexingNeverPriority;</span>
<a href="#l11.1503"></a><span id="l11.1503">     else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.Inbox)</span>
<a href="#l11.1504"></a><span id="l11.1504">       indexingPriority = GlodaFolder.prototype.kIndexingInboxPriority;</span>
<a href="#l11.1505"></a><span id="l11.1505">     else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.SentMail)</span>
<a href="#l11.1506"></a><span id="l11.1506">       indexingPriority = GlodaFolder.prototype.kIndexingSentMailPriority;</span>
<a href="#l11.1507"></a><span id="l11.1507">     else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.Favorite)</span>
<a href="#l11.1508"></a><span id="l11.1508">       indexingPriority = GlodaFolder.prototype.kIndexingFavoritePriority;</span>
<a href="#l11.1509"></a><span id="l11.1509" class="difflineat">@@ -2035,17 +1997,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1510"></a><span id="l11.1510">   /**</span>
<a href="#l11.1511"></a><span id="l11.1511">    * Map a folder URI to a GlodaFolder instance, creating the mapping if it does</span>
<a href="#l11.1512"></a><span id="l11.1512">    *  not yet exist.</span>
<a href="#l11.1513"></a><span id="l11.1513">    *</span>
<a href="#l11.1514"></a><span id="l11.1514">    * @param aFolder The nsIMsgFolder instance you would like the GlodaFolder</span>
<a href="#l11.1515"></a><span id="l11.1515">    *     instance for.</span>
<a href="#l11.1516"></a><span id="l11.1516">    * @returns The existing or newly created GlodaFolder instance.</span>
<a href="#l11.1517"></a><span id="l11.1517">    */</span>
<a href="#l11.1518"></a><span id="l11.1518" class="difflineminus">-  _mapFolder: function gloda_ds_mapFolderURI(aFolder) {</span>
<a href="#l11.1519"></a><span id="l11.1519" class="difflineplus">+  _mapFolder(aFolder) {</span>
<a href="#l11.1520"></a><span id="l11.1520">     let folderURI = aFolder.URI;</span>
<a href="#l11.1521"></a><span id="l11.1521">     if (folderURI in this._folderByURI) {</span>
<a href="#l11.1522"></a><span id="l11.1522">       return this._folderByURI[folderURI];</span>
<a href="#l11.1523"></a><span id="l11.1523">     }</span>
<a href="#l11.1524"></a><span id="l11.1524"> </span>
<a href="#l11.1525"></a><span id="l11.1525">     let folderID = this._nextFolderId++;</span>
<a href="#l11.1526"></a><span id="l11.1526"> </span>
<a href="#l11.1527"></a><span id="l11.1527">     // if there's an indexingPriority stored on the folder, just use that</span>
<a href="#l11.1528"></a><span id="l11.1528" class="difflineat">@@ -2083,64 +2045,63 @@ var GlodaDatastore = {</span>
<a href="#l11.1529"></a><span id="l11.1529">   /**</span>
<a href="#l11.1530"></a><span id="l11.1530">    * Map an integer gloda folder ID to the corresponding GlodaFolder instance.</span>
<a href="#l11.1531"></a><span id="l11.1531">    *</span>
<a href="#l11.1532"></a><span id="l11.1532">    * @param aFolderID The known valid gloda folder ID for which you would like</span>
<a href="#l11.1533"></a><span id="l11.1533">    *     a GlodaFolder instance.</span>
<a href="#l11.1534"></a><span id="l11.1534">    * @return The GlodaFolder instance with the given id.  If no such instance</span>
<a href="#l11.1535"></a><span id="l11.1535">    *     exists, we will throw an exception.</span>
<a href="#l11.1536"></a><span id="l11.1536">    */</span>
<a href="#l11.1537"></a><span id="l11.1537" class="difflineminus">-  _mapFolderID: function gloda_ds_mapFolderID(aFolderID) {</span>
<a href="#l11.1538"></a><span id="l11.1538" class="difflineplus">+  _mapFolderID(aFolderID) {</span>
<a href="#l11.1539"></a><span id="l11.1539">     if (aFolderID === null)</span>
<a href="#l11.1540"></a><span id="l11.1540">       return null;</span>
<a href="#l11.1541"></a><span id="l11.1541">     if (aFolderID in this._folderByID)</span>
<a href="#l11.1542"></a><span id="l11.1542">       return this._folderByID[aFolderID];</span>
<a href="#l11.1543"></a><span id="l11.1543">     throw new Error(&quot;Got impossible folder ID: &quot; + aFolderID);</span>
<a href="#l11.1544"></a><span id="l11.1544">   },</span>
<a href="#l11.1545"></a><span id="l11.1545"> </span>
<a href="#l11.1546"></a><span id="l11.1546">   /**</span>
<a href="#l11.1547"></a><span id="l11.1547">    * Mark the gloda folder as deleted for any outstanding references to it and</span>
<a href="#l11.1548"></a><span id="l11.1548">    *  remove it from our tables so we don't hand out any new references.  The</span>
<a href="#l11.1549"></a><span id="l11.1549">    *  latter is especially important in the case a folder with the same name</span>
<a href="#l11.1550"></a><span id="l11.1550">    *  is created afterwards; we don't want to confuse the new one with the old</span>
<a href="#l11.1551"></a><span id="l11.1551">    *  one!</span>
<a href="#l11.1552"></a><span id="l11.1552">    */</span>
<a href="#l11.1553"></a><span id="l11.1553" class="difflineminus">-  _killGlodaFolderIntoTombstone:</span>
<a href="#l11.1554"></a><span id="l11.1554" class="difflineminus">-      function gloda_ds__killGlodaFolderIntoTombstone(aGlodaFolder) {</span>
<a href="#l11.1555"></a><span id="l11.1555" class="difflineplus">+  _killGlodaFolderIntoTombstone(aGlodaFolder) {</span>
<a href="#l11.1556"></a><span id="l11.1556">     aGlodaFolder._deleted = true;</span>
<a href="#l11.1557"></a><span id="l11.1557">     delete this._folderByURI[aGlodaFolder.uri];</span>
<a href="#l11.1558"></a><span id="l11.1558">     delete this._folderByID[aGlodaFolder.id];</span>
<a href="#l11.1559"></a><span id="l11.1559">   },</span>
<a href="#l11.1560"></a><span id="l11.1560"> </span>
<a href="#l11.1561"></a><span id="l11.1561">   get _updateFolderDirtyStatusStatement() {</span>
<a href="#l11.1562"></a><span id="l11.1562">     let statement = this._createAsyncStatement(</span>
<a href="#l11.1563"></a><span id="l11.1563">       &quot;UPDATE folderLocations SET dirtyStatus = ?1 \</span>
<a href="#l11.1564"></a><span id="l11.1564">               WHERE id = ?2&quot;);</span>
<a href="#l11.1565"></a><span id="l11.1565">     this.__defineGetter__(&quot;_updateFolderDirtyStatusStatement&quot;,</span>
<a href="#l11.1566"></a><span id="l11.1566">       () =&gt; statement);</span>
<a href="#l11.1567"></a><span id="l11.1567">     return this._updateFolderDirtyStatusStatement;</span>
<a href="#l11.1568"></a><span id="l11.1568">   },</span>
<a href="#l11.1569"></a><span id="l11.1569"> </span>
<a href="#l11.1570"></a><span id="l11.1570" class="difflineminus">-  updateFolderDirtyStatus: function gloda_ds_updateFolderDirtyStatus(aFolder) {</span>
<a href="#l11.1571"></a><span id="l11.1571" class="difflineplus">+  updateFolderDirtyStatus(aFolder) {</span>
<a href="#l11.1572"></a><span id="l11.1572">     let ufds = this._updateFolderDirtyStatusStatement;</span>
<a href="#l11.1573"></a><span id="l11.1573">     ufds.bindByIndex(1, aFolder.id);</span>
<a href="#l11.1574"></a><span id="l11.1574">     ufds.bindByIndex(0, aFolder.dirtyStatus);</span>
<a href="#l11.1575"></a><span id="l11.1575">     ufds.executeAsync(this.trackAsync());</span>
<a href="#l11.1576"></a><span id="l11.1576">   },</span>
<a href="#l11.1577"></a><span id="l11.1577"> </span>
<a href="#l11.1578"></a><span id="l11.1578">   get _updateFolderIndexingPriorityStatement() {</span>
<a href="#l11.1579"></a><span id="l11.1579">     let statement = this._createAsyncStatement(</span>
<a href="#l11.1580"></a><span id="l11.1580">       &quot;UPDATE folderLocations SET indexingPriority = ?1 \</span>
<a href="#l11.1581"></a><span id="l11.1581">               WHERE id = ?2&quot;);</span>
<a href="#l11.1582"></a><span id="l11.1582">     this.__defineGetter__(&quot;_updateFolderIndexingPriorityStatement&quot;,</span>
<a href="#l11.1583"></a><span id="l11.1583">       () =&gt; statement);</span>
<a href="#l11.1584"></a><span id="l11.1584">     return this._updateFolderIndexingPriorityStatement;</span>
<a href="#l11.1585"></a><span id="l11.1585">   },</span>
<a href="#l11.1586"></a><span id="l11.1586"> </span>
<a href="#l11.1587"></a><span id="l11.1587" class="difflineminus">-  updateFolderIndexingPriority: function gloda_ds_updateFolderIndexingPriority(aFolder) {</span>
<a href="#l11.1588"></a><span id="l11.1588" class="difflineplus">+  updateFolderIndexingPriority(aFolder) {</span>
<a href="#l11.1589"></a><span id="l11.1589">     let ufip = this._updateFolderIndexingPriorityStatement;</span>
<a href="#l11.1590"></a><span id="l11.1590">     ufip.bindByIndex(1, aFolder.id);</span>
<a href="#l11.1591"></a><span id="l11.1591">     ufip.bindByIndex(0, aFolder.indexingPriority);</span>
<a href="#l11.1592"></a><span id="l11.1592">     ufip.executeAsync(this.trackAsync());</span>
<a href="#l11.1593"></a><span id="l11.1593">   },</span>
<a href="#l11.1594"></a><span id="l11.1594"> </span>
<a href="#l11.1595"></a><span id="l11.1595">   get _updateFolderLocationStatement() {</span>
<a href="#l11.1596"></a><span id="l11.1596">     let statement = this._createAsyncStatement(</span>
<a href="#l11.1597"></a><span id="l11.1597" class="difflineat">@@ -2152,17 +2113,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1598"></a><span id="l11.1598">   },</span>
<a href="#l11.1599"></a><span id="l11.1599"> </span>
<a href="#l11.1600"></a><span id="l11.1600">   /**</span>
<a href="#l11.1601"></a><span id="l11.1601">    * Non-recursive asynchronous folder renaming based on the URI.</span>
<a href="#l11.1602"></a><span id="l11.1602">    *</span>
<a href="#l11.1603"></a><span id="l11.1603">    * @TODO provide a mechanism for recursive folder renames or have a higher</span>
<a href="#l11.1604"></a><span id="l11.1604">    *     layer deal with it and remove this note.</span>
<a href="#l11.1605"></a><span id="l11.1605">    */</span>
<a href="#l11.1606"></a><span id="l11.1606" class="difflineminus">-  renameFolder: function gloda_ds_renameFolder(aOldFolder, aNewURI) {</span>
<a href="#l11.1607"></a><span id="l11.1607" class="difflineplus">+  renameFolder(aOldFolder, aNewURI) {</span>
<a href="#l11.1608"></a><span id="l11.1608">     if (!(aOldFolder.URI in this._folderByURI))</span>
<a href="#l11.1609"></a><span id="l11.1609">       return;</span>
<a href="#l11.1610"></a><span id="l11.1610">     let folder = this._mapFolder(aOldFolder); // ensure the folder is mapped</span>
<a href="#l11.1611"></a><span id="l11.1611">     let oldURI = folder.uri;</span>
<a href="#l11.1612"></a><span id="l11.1612">     this._folderByURI[aNewURI] = folder;</span>
<a href="#l11.1613"></a><span id="l11.1613">     folder._uri = aNewURI;</span>
<a href="#l11.1614"></a><span id="l11.1614">     this._log.info(&quot;renaming folder URI &quot; + oldURI + &quot; to &quot; + aNewURI);</span>
<a href="#l11.1615"></a><span id="l11.1615">     this._updateFolderLocationStatement.bindByIndex(1, folder.id);</span>
<a href="#l11.1616"></a><span id="l11.1616" class="difflineat">@@ -2175,17 +2136,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1617"></a><span id="l11.1617">   get _deleteFolderByIDStatement() {</span>
<a href="#l11.1618"></a><span id="l11.1618">     let statement = this._createAsyncStatement(</span>
<a href="#l11.1619"></a><span id="l11.1619">       &quot;DELETE FROM folderLocations WHERE id = ?1&quot;);</span>
<a href="#l11.1620"></a><span id="l11.1620">     this.__defineGetter__(&quot;_deleteFolderByIDStatement&quot;,</span>
<a href="#l11.1621"></a><span id="l11.1621">       () =&gt; statement);</span>
<a href="#l11.1622"></a><span id="l11.1622">     return this._deleteFolderByIDStatement;</span>
<a href="#l11.1623"></a><span id="l11.1623">   },</span>
<a href="#l11.1624"></a><span id="l11.1624"> </span>
<a href="#l11.1625"></a><span id="l11.1625" class="difflineminus">-  deleteFolderByID: function gloda_ds_deleteFolder(aFolderID) {</span>
<a href="#l11.1626"></a><span id="l11.1626" class="difflineplus">+  deleteFolderByID(aFolderID) {</span>
<a href="#l11.1627"></a><span id="l11.1627">     let dfbis = this._deleteFolderByIDStatement;</span>
<a href="#l11.1628"></a><span id="l11.1628">     dfbis.bindByIndex(0, aFolderID);</span>
<a href="#l11.1629"></a><span id="l11.1629">     dfbis.executeAsync(this.trackAsync());</span>
<a href="#l11.1630"></a><span id="l11.1630">   },</span>
<a href="#l11.1631"></a><span id="l11.1631"> </span>
<a href="#l11.1632"></a><span id="l11.1632">   /**</span>
<a href="#l11.1633"></a><span id="l11.1633">    * This timer drives our folder cleanup logic that is in charge of dropping</span>
<a href="#l11.1634"></a><span id="l11.1634">    *  our folder references and more importantly the folder's msgDatabase</span>
<a href="#l11.1635"></a><span id="l11.1635" class="difflineat">@@ -2219,32 +2180,32 @@ var GlodaDatastore = {</span>
<a href="#l11.1636"></a><span id="l11.1636"> </span>
<a href="#l11.1637"></a><span id="l11.1637">   /**</span>
<a href="#l11.1638"></a><span id="l11.1638">    * Mark a GlodaFolder as having a live reference to its nsIMsgFolder with an</span>
<a href="#l11.1639"></a><span id="l11.1639">    *  implied opened associated message database.  GlodaFolder calls this when</span>
<a href="#l11.1640"></a><span id="l11.1640">    *  it first acquires its reference.  It is removed from the list of live</span>
<a href="#l11.1641"></a><span id="l11.1641">    *  folders only when our timer check calls the GlodaFolder's</span>
<a href="#l11.1642"></a><span id="l11.1642">    *  forgetFolderIfUnused method and that method returns true.</span>
<a href="#l11.1643"></a><span id="l11.1643">    */</span>
<a href="#l11.1644"></a><span id="l11.1644" class="difflineminus">-  markFolderLive: function gloda_ds_markFolderLive(aGlodaFolder) {</span>
<a href="#l11.1645"></a><span id="l11.1645" class="difflineplus">+  markFolderLive(aGlodaFolder) {</span>
<a href="#l11.1646"></a><span id="l11.1646">     this._liveGlodaFolders[aGlodaFolder.id] = aGlodaFolder;</span>
<a href="#l11.1647"></a><span id="l11.1647">     if (!this._folderCleanupActive) {</span>
<a href="#l11.1648"></a><span id="l11.1648">       this._folderCleanupTimer.initWithCallback(this._performFolderCleanup,</span>
<a href="#l11.1649"></a><span id="l11.1649">         this._folderCleanupTimerInterval, Ci.nsITimer.TYPE_REPEATING_SLACK);</span>
<a href="#l11.1650"></a><span id="l11.1650">       this._folderCleanupActive = true;</span>
<a href="#l11.1651"></a><span id="l11.1651">     }</span>
<a href="#l11.1652"></a><span id="l11.1652">   },</span>
<a href="#l11.1653"></a><span id="l11.1653"> </span>
<a href="#l11.1654"></a><span id="l11.1654">   /**</span>
<a href="#l11.1655"></a><span id="l11.1655">    * Timer-driven folder cleanup logic.  For every live folder tracked in</span>
<a href="#l11.1656"></a><span id="l11.1656">    *  _liveGlodaFolders, we call their forgetFolderIfUnused method each time</span>
<a href="#l11.1657"></a><span id="l11.1657">    *  until they return true indicating they have cleaned themselves up.</span>
<a href="#l11.1658"></a><span id="l11.1658">    * This method is called without a 'this' context!</span>
<a href="#l11.1659"></a><span id="l11.1659">    */</span>
<a href="#l11.1660"></a><span id="l11.1660" class="difflineminus">-  _performFolderCleanup: function gloda_ds_performFolderCleanup() {</span>
<a href="#l11.1661"></a><span id="l11.1661" class="difflineplus">+  _performFolderCleanup() {</span>
<a href="#l11.1662"></a><span id="l11.1662">     // we only need to keep going if there is at least one folder in the table</span>
<a href="#l11.1663"></a><span id="l11.1663">     //  that is still alive after this pass.</span>
<a href="#l11.1664"></a><span id="l11.1664">     let keepGoing = false;</span>
<a href="#l11.1665"></a><span id="l11.1665">     for (let id in GlodaDatastore._liveGlodaFolders) {</span>
<a href="#l11.1666"></a><span id="l11.1666">       let glodaFolder = GlodaDatastore._liveGlodaFolders[id];</span>
<a href="#l11.1667"></a><span id="l11.1667">       // returns true if it is now 'dead' and doesn't need this heartbeat check</span>
<a href="#l11.1668"></a><span id="l11.1668">       if (glodaFolder.forgetFolderIfUnused())</span>
<a href="#l11.1669"></a><span id="l11.1669">         delete GlodaDatastore._liveGlodaFolders[glodaFolder.id];</span>
<a href="#l11.1670"></a><span id="l11.1670" class="difflineat">@@ -2257,17 +2218,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1671"></a><span id="l11.1671">       GlodaDatastore._folderCleanupActive = false;</span>
<a href="#l11.1672"></a><span id="l11.1672">     }</span>
<a href="#l11.1673"></a><span id="l11.1673">   },</span>
<a href="#l11.1674"></a><span id="l11.1674"> </span>
<a href="#l11.1675"></a><span id="l11.1675">   /* ********** Conversation ********** */</span>
<a href="#l11.1676"></a><span id="l11.1676">   /** The next conversation id to allocate.  Initialize at startup. */</span>
<a href="#l11.1677"></a><span id="l11.1677">   _nextConversationId: 1,</span>
<a href="#l11.1678"></a><span id="l11.1678"> </span>
<a href="#l11.1679"></a><span id="l11.1679" class="difflineminus">-  _populateConversationManagedId: function () {</span>
<a href="#l11.1680"></a><span id="l11.1680" class="difflineplus">+  _populateConversationManagedId() {</span>
<a href="#l11.1681"></a><span id="l11.1681">     let stmt = this._createSyncStatement(</span>
<a href="#l11.1682"></a><span id="l11.1682">       &quot;SELECT MAX(id) FROM conversations&quot;, true);</span>
<a href="#l11.1683"></a><span id="l11.1683">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l11.1684"></a><span id="l11.1684">       this._nextConversationId = stmt.getInt64(0) + 1;</span>
<a href="#l11.1685"></a><span id="l11.1685">     }</span>
<a href="#l11.1686"></a><span id="l11.1686">     stmt.finalize();</span>
<a href="#l11.1687"></a><span id="l11.1687">   },</span>
<a href="#l11.1688"></a><span id="l11.1688"> </span>
<a href="#l11.1689"></a><span id="l11.1689" class="difflineat">@@ -2287,19 +2248,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1690"></a><span id="l11.1690">     this.__defineGetter__(&quot;_insertConversationTextStatement&quot;,</span>
<a href="#l11.1691"></a><span id="l11.1691">       () =&gt; statement);</span>
<a href="#l11.1692"></a><span id="l11.1692">     return this._insertConversationTextStatement;</span>
<a href="#l11.1693"></a><span id="l11.1693">   },</span>
<a href="#l11.1694"></a><span id="l11.1694"> </span>
<a href="#l11.1695"></a><span id="l11.1695">   /**</span>
<a href="#l11.1696"></a><span id="l11.1696">    * Asynchronously create a conversation.</span>
<a href="#l11.1697"></a><span id="l11.1697">    */</span>
<a href="#l11.1698"></a><span id="l11.1698" class="difflineminus">-  createConversation: function gloda_ds_createConversation(aSubject,</span>
<a href="#l11.1699"></a><span id="l11.1699" class="difflineminus">-        aOldestMessageDate, aNewestMessageDate) {</span>
<a href="#l11.1700"></a><span id="l11.1700" class="difflineminus">-</span>
<a href="#l11.1701"></a><span id="l11.1701" class="difflineplus">+  createConversation(aSubject, aOldestMessageDate, aNewestMessageDate) {</span>
<a href="#l11.1702"></a><span id="l11.1702">     // create the data row</span>
<a href="#l11.1703"></a><span id="l11.1703">     let conversationID = this._nextConversationId++;</span>
<a href="#l11.1704"></a><span id="l11.1704">     let ics = this._insertConversationStatement;</span>
<a href="#l11.1705"></a><span id="l11.1705">     ics.bindByIndex(0, conversationID);</span>
<a href="#l11.1706"></a><span id="l11.1706">     ics.bindByIndex(1, aSubject);</span>
<a href="#l11.1707"></a><span id="l11.1707">     if (aOldestMessageDate == null)</span>
<a href="#l11.1708"></a><span id="l11.1708">       ics.bindByIndex(2, null);</span>
<a href="#l11.1709"></a><span id="l11.1709">     else</span>
<a href="#l11.1710"></a><span id="l11.1710" class="difflineat">@@ -2332,27 +2291,26 @@ var GlodaDatastore = {</span>
<a href="#l11.1711"></a><span id="l11.1711">     this.__defineGetter__(&quot;_deleteConversationByIDStatement&quot;,</span>
<a href="#l11.1712"></a><span id="l11.1712">                           () =&gt; statement);</span>
<a href="#l11.1713"></a><span id="l11.1713">     return this._deleteConversationByIDStatement;</span>
<a href="#l11.1714"></a><span id="l11.1714">   },</span>
<a href="#l11.1715"></a><span id="l11.1715"> </span>
<a href="#l11.1716"></a><span id="l11.1716">   /**</span>
<a href="#l11.1717"></a><span id="l11.1717">    * Asynchronously delete a conversation given its ID.</span>
<a href="#l11.1718"></a><span id="l11.1718">    */</span>
<a href="#l11.1719"></a><span id="l11.1719" class="difflineminus">-  deleteConversationByID: function gloda_ds_deleteConversationByID(</span>
<a href="#l11.1720"></a><span id="l11.1720" class="difflineminus">-                                      aConversationID) {</span>
<a href="#l11.1721"></a><span id="l11.1721" class="difflineplus">+  deleteConversationByID(aConversationID) {</span>
<a href="#l11.1722"></a><span id="l11.1722">     let dcbids = this._deleteConversationByIDStatement;</span>
<a href="#l11.1723"></a><span id="l11.1723">     dcbids.bindByIndex(0, aConversationID);</span>
<a href="#l11.1724"></a><span id="l11.1724">     dcbids.executeAsync(this.trackAsync());</span>
<a href="#l11.1725"></a><span id="l11.1725"> </span>
<a href="#l11.1726"></a><span id="l11.1726">     GlodaCollectionManager.itemsDeleted(GlodaConversation.prototype.NOUN_ID,</span>
<a href="#l11.1727"></a><span id="l11.1727">                                         [aConversationID]);</span>
<a href="#l11.1728"></a><span id="l11.1728">   },</span>
<a href="#l11.1729"></a><span id="l11.1729"> </span>
<a href="#l11.1730"></a><span id="l11.1730" class="difflineminus">-  _conversationFromRow: function gloda_ds_conversationFromRow(aStmt) {</span>
<a href="#l11.1731"></a><span id="l11.1731" class="difflineplus">+  _conversationFromRow(aStmt) {</span>
<a href="#l11.1732"></a><span id="l11.1732">       let oldestMessageDate, newestMessageDate;</span>
<a href="#l11.1733"></a><span id="l11.1733">       if (aStmt.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.1734"></a><span id="l11.1734">         oldestMessageDate = null;</span>
<a href="#l11.1735"></a><span id="l11.1735">       else</span>
<a href="#l11.1736"></a><span id="l11.1736">         oldestMessageDate = aStmt.getInt64(2);</span>
<a href="#l11.1737"></a><span id="l11.1737">       if (aStmt.getTypeOfIndex(3) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.1738"></a><span id="l11.1738">         newestMessageDate = null;</span>
<a href="#l11.1739"></a><span id="l11.1739">       else</span>
<a href="#l11.1740"></a><span id="l11.1740" class="difflineat">@@ -2366,17 +2324,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1741"></a><span id="l11.1741">    * Next message id, managed because of our use of asynchronous inserts.</span>
<a href="#l11.1742"></a><span id="l11.1742">    * Initialized by _populateMessageManagedId called by _init.</span>
<a href="#l11.1743"></a><span id="l11.1743">    *</span>
<a href="#l11.1744"></a><span id="l11.1744">    * Start from 32 to leave us all kinds of magical sentinel values at the</span>
<a href="#l11.1745"></a><span id="l11.1745">    *  bottom.</span>
<a href="#l11.1746"></a><span id="l11.1746">    */</span>
<a href="#l11.1747"></a><span id="l11.1747">   _nextMessageId: 32,</span>
<a href="#l11.1748"></a><span id="l11.1748"> </span>
<a href="#l11.1749"></a><span id="l11.1749" class="difflineminus">-  _populateMessageManagedId: function () {</span>
<a href="#l11.1750"></a><span id="l11.1750" class="difflineplus">+  _populateMessageManagedId() {</span>
<a href="#l11.1751"></a><span id="l11.1751">     let stmt = this._createSyncStatement(</span>
<a href="#l11.1752"></a><span id="l11.1752">       &quot;SELECT MAX(id) FROM messages&quot;, true);</span>
<a href="#l11.1753"></a><span id="l11.1753">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l11.1754"></a><span id="l11.1754">       // 0 gets returned even if there are no messages...</span>
<a href="#l11.1755"></a><span id="l11.1755">       let highestSeen = stmt.getInt64(0);</span>
<a href="#l11.1756"></a><span id="l11.1756">       if (highestSeen != 0)</span>
<a href="#l11.1757"></a><span id="l11.1757">         this._nextMessageId = highestSeen + 1;</span>
<a href="#l11.1758"></a><span id="l11.1758">     }</span>
<a href="#l11.1759"></a><span id="l11.1759" class="difflineat">@@ -2406,23 +2364,21 @@ var GlodaDatastore = {</span>
<a href="#l11.1760"></a><span id="l11.1760">    *  of the process of creating a message (the attributes still need to be</span>
<a href="#l11.1761"></a><span id="l11.1761">    *  completed), it's on the caller's head to call GlodaCollectionManager's</span>
<a href="#l11.1762"></a><span id="l11.1762">    *  itemAdded method once the message is fully created.</span>
<a href="#l11.1763"></a><span id="l11.1763">    *</span>
<a href="#l11.1764"></a><span id="l11.1764">    * This method uses the async connection, any downstream logic that depends on</span>
<a href="#l11.1765"></a><span id="l11.1765">    *  this message actually existing in the database must be done using an</span>
<a href="#l11.1766"></a><span id="l11.1766">    *  async query.</span>
<a href="#l11.1767"></a><span id="l11.1767">    */</span>
<a href="#l11.1768"></a><span id="l11.1768" class="difflineminus">-  createMessage: function gloda_ds_createMessage(aFolder, aMessageKey,</span>
<a href="#l11.1769"></a><span id="l11.1769" class="difflineminus">-                              aConversationID, aDatePRTime, aHeaderMessageID) {</span>
<a href="#l11.1770"></a><span id="l11.1770" class="difflineplus">+  createMessage(aFolder, aMessageKey, aConversationID, aDatePRTime, aHeaderMessageID) {</span>
<a href="#l11.1771"></a><span id="l11.1771">     let folderID;</span>
<a href="#l11.1772"></a><span id="l11.1772">     if (aFolder != null) {</span>
<a href="#l11.1773"></a><span id="l11.1773">       folderID = this._mapFolder(aFolder).id;</span>
<a href="#l11.1774"></a><span id="l11.1774" class="difflineminus">-    }</span>
<a href="#l11.1775"></a><span id="l11.1775" class="difflineminus">-    else {</span>
<a href="#l11.1776"></a><span id="l11.1776" class="difflineplus">+    } else {</span>
<a href="#l11.1777"></a><span id="l11.1777">       folderID = null;</span>
<a href="#l11.1778"></a><span id="l11.1778">     }</span>
<a href="#l11.1779"></a><span id="l11.1779"> </span>
<a href="#l11.1780"></a><span id="l11.1780">     let messageID = this._nextMessageId++;</span>
<a href="#l11.1781"></a><span id="l11.1781"> </span>
<a href="#l11.1782"></a><span id="l11.1782">     let message = new GlodaMessage(</span>
<a href="#l11.1783"></a><span id="l11.1783">       this, messageID, folderID,</span>
<a href="#l11.1784"></a><span id="l11.1784">       aMessageKey,</span>
<a href="#l11.1785"></a><span id="l11.1785" class="difflineat">@@ -2434,17 +2390,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1786"></a><span id="l11.1786">     // We would love to notify the collection manager about the message at this</span>
<a href="#l11.1787"></a><span id="l11.1787">     //  point (at least if it's not a ghost), but we can't yet.  We need to wait</span>
<a href="#l11.1788"></a><span id="l11.1788">     //  until the attributes have been indexed, which means it's out of our</span>
<a href="#l11.1789"></a><span id="l11.1789">     //  hands.  (Gloda.processMessage does it.)</span>
<a href="#l11.1790"></a><span id="l11.1790"> </span>
<a href="#l11.1791"></a><span id="l11.1791">     return message;</span>
<a href="#l11.1792"></a><span id="l11.1792">   },</span>
<a href="#l11.1793"></a><span id="l11.1793"> </span>
<a href="#l11.1794"></a><span id="l11.1794" class="difflineminus">-  insertMessage: function gloda_ds_insertMessage(aMessage) {</span>
<a href="#l11.1795"></a><span id="l11.1795" class="difflineplus">+  insertMessage(aMessage) {</span>
<a href="#l11.1796"></a><span id="l11.1796">     let ims = this._insertMessageStatement;</span>
<a href="#l11.1797"></a><span id="l11.1797">     ims.bindByIndex(0, aMessage.id);</span>
<a href="#l11.1798"></a><span id="l11.1798">     if (aMessage.folderID == null)</span>
<a href="#l11.1799"></a><span id="l11.1799">       ims.bindByIndex(1, null);</span>
<a href="#l11.1800"></a><span id="l11.1800">     else</span>
<a href="#l11.1801"></a><span id="l11.1801">       ims.bindByIndex(1, aMessage.folderID);</span>
<a href="#l11.1802"></a><span id="l11.1802">     if (aMessage.messageKey == null)</span>
<a href="#l11.1803"></a><span id="l11.1803">       ims.bindByIndex(2, null);</span>
<a href="#l11.1804"></a><span id="l11.1804" class="difflineat">@@ -2459,34 +2415,33 @@ var GlodaDatastore = {</span>
<a href="#l11.1805"></a><span id="l11.1805">     if (aMessage._jsonText)</span>
<a href="#l11.1806"></a><span id="l11.1806">       ims.bindByIndex(6, aMessage._jsonText);</span>
<a href="#l11.1807"></a><span id="l11.1807">     else</span>
<a href="#l11.1808"></a><span id="l11.1808">       ims.bindByIndex(6, null);</span>
<a href="#l11.1809"></a><span id="l11.1809">     ims.bindByIndex(7, aMessage.notability);</span>
<a href="#l11.1810"></a><span id="l11.1810"> </span>
<a href="#l11.1811"></a><span id="l11.1811">     try {</span>
<a href="#l11.1812"></a><span id="l11.1812">        ims.executeAsync(this.trackAsync());</span>
<a href="#l11.1813"></a><span id="l11.1813" class="difflineminus">-    }</span>
<a href="#l11.1814"></a><span id="l11.1814" class="difflineminus">-    catch(ex) {</span>
<a href="#l11.1815"></a><span id="l11.1815" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.1816"></a><span id="l11.1816">        throw new Error(&quot;error executing statement... &quot; +</span>
<a href="#l11.1817"></a><span id="l11.1817">              this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l11.1818"></a><span id="l11.1818">              this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l11.1819"></a><span id="l11.1819">     }</span>
<a href="#l11.1820"></a><span id="l11.1820"> </span>
<a href="#l11.1821"></a><span id="l11.1821">     // we create the full-text row for any message that isn't a ghost,</span>
<a href="#l11.1822"></a><span id="l11.1822">     // whether we have the body or not</span>
<a href="#l11.1823"></a><span id="l11.1823">     if (aMessage.folderID !== null)</span>
<a href="#l11.1824"></a><span id="l11.1824">       this._insertMessageText(aMessage);</span>
<a href="#l11.1825"></a><span id="l11.1825">   },</span>
<a href="#l11.1826"></a><span id="l11.1826"> </span>
<a href="#l11.1827"></a><span id="l11.1827">   /**</span>
<a href="#l11.1828"></a><span id="l11.1828">    * Inserts a full-text row. This should only be called if you're sure you want</span>
<a href="#l11.1829"></a><span id="l11.1829">    * to insert a row into the table.</span>
<a href="#l11.1830"></a><span id="l11.1830">    */</span>
<a href="#l11.1831"></a><span id="l11.1831" class="difflineminus">-  _insertMessageText: function gloda_ds__insertMessageText(aMessage) {</span>
<a href="#l11.1832"></a><span id="l11.1832" class="difflineplus">+  _insertMessageText(aMessage) {</span>
<a href="#l11.1833"></a><span id="l11.1833">     if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l11.1834"></a><span id="l11.1834">       aMessage._indexedBodyText = aMessage._content.getContentString(true);</span>
<a href="#l11.1835"></a><span id="l11.1835">     else if (aMessage._bodyLines)</span>
<a href="#l11.1836"></a><span id="l11.1836">       aMessage._indexedBodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l11.1837"></a><span id="l11.1837">     else</span>
<a href="#l11.1838"></a><span id="l11.1838">       aMessage._indexedBodyText = null;</span>
<a href="#l11.1839"></a><span id="l11.1839"> </span>
<a href="#l11.1840"></a><span id="l11.1840">     let imts = this._insertMessageTextStatement;</span>
<a href="#l11.1841"></a><span id="l11.1841" class="difflineat">@@ -2496,25 +2451,24 @@ var GlodaDatastore = {</span>
<a href="#l11.1842"></a><span id="l11.1842">       imts.bindByIndex(2, null);</span>
<a href="#l11.1843"></a><span id="l11.1843">     else</span>
<a href="#l11.1844"></a><span id="l11.1844">       imts.bindByIndex(2, aMessage._indexedBodyText);</span>
<a href="#l11.1845"></a><span id="l11.1845">     if (aMessage._attachmentNames === null)</span>
<a href="#l11.1846"></a><span id="l11.1846">       imts.bindByIndex(3, null);</span>
<a href="#l11.1847"></a><span id="l11.1847">     else</span>
<a href="#l11.1848"></a><span id="l11.1848">       imts.bindByIndex(3, aMessage._attachmentNames.join(&quot;\n&quot;));</span>
<a href="#l11.1849"></a><span id="l11.1849"> </span>
<a href="#l11.1850"></a><span id="l11.1850" class="difflineminus">-//if (aMessage._indexAuthor)</span>
<a href="#l11.1851"></a><span id="l11.1851" class="difflineplus">+    // if (aMessage._indexAuthor)</span>
<a href="#l11.1852"></a><span id="l11.1852">     imts.bindByIndex(4, aMessage._indexAuthor);</span>
<a href="#l11.1853"></a><span id="l11.1853" class="difflineminus">-//if (aMessage._indexRecipients)</span>
<a href="#l11.1854"></a><span id="l11.1854" class="difflineplus">+    // if (aMessage._indexRecipients)</span>
<a href="#l11.1855"></a><span id="l11.1855">     imts.bindByIndex(5, aMessage._indexRecipients);</span>
<a href="#l11.1856"></a><span id="l11.1856"> </span>
<a href="#l11.1857"></a><span id="l11.1857">     try {</span>
<a href="#l11.1858"></a><span id="l11.1858">       imts.executeAsync(this.trackAsync());</span>
<a href="#l11.1859"></a><span id="l11.1859" class="difflineminus">-    }</span>
<a href="#l11.1860"></a><span id="l11.1860" class="difflineminus">-    catch(ex) {</span>
<a href="#l11.1861"></a><span id="l11.1861" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.1862"></a><span id="l11.1862">       throw new Error(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l11.1863"></a><span id="l11.1863">             this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l11.1864"></a><span id="l11.1864">             this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l11.1865"></a><span id="l11.1865">     }</span>
<a href="#l11.1866"></a><span id="l11.1866">   },</span>
<a href="#l11.1867"></a><span id="l11.1867"> </span>
<a href="#l11.1868"></a><span id="l11.1868">   get _updateMessageStatement() {</span>
<a href="#l11.1869"></a><span id="l11.1869">     let statement = this._createAsyncStatement(</span>
<a href="#l11.1870"></a><span id="l11.1870" class="difflineat">@@ -2545,17 +2499,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1871"></a><span id="l11.1871">    * Update the database row associated with the message. If the message is</span>
<a href="#l11.1872"></a><span id="l11.1872">    * not a ghost and has _isNew defined, messagesText is affected.</span>
<a href="#l11.1873"></a><span id="l11.1873">    *</span>
<a href="#l11.1874"></a><span id="l11.1874">    * aMessage._isNew is currently equivalent to the fact that there is no</span>
<a href="#l11.1875"></a><span id="l11.1875">    * full-text row associated with this message, and we work with this</span>
<a href="#l11.1876"></a><span id="l11.1876">    * assumption here. Note that if aMessage._isNew is not defined, then</span>
<a href="#l11.1877"></a><span id="l11.1877">    * we don't do anything.</span>
<a href="#l11.1878"></a><span id="l11.1878">    */</span>
<a href="#l11.1879"></a><span id="l11.1879" class="difflineminus">-  updateMessage: function gloda_ds_updateMessage(aMessage) {</span>
<a href="#l11.1880"></a><span id="l11.1880" class="difflineplus">+  updateMessage(aMessage) {</span>
<a href="#l11.1881"></a><span id="l11.1881">     let ums = this._updateMessageStatement;</span>
<a href="#l11.1882"></a><span id="l11.1882">     ums.bindByIndex(8, aMessage.id);</span>
<a href="#l11.1883"></a><span id="l11.1883">     if (aMessage.folderID === null)</span>
<a href="#l11.1884"></a><span id="l11.1884">       ums.bindByIndex(0, null);</span>
<a href="#l11.1885"></a><span id="l11.1885">     else</span>
<a href="#l11.1886"></a><span id="l11.1886">       ums.bindByIndex(0, aMessage.folderID);</span>
<a href="#l11.1887"></a><span id="l11.1887">     if (aMessage.messageKey === null)</span>
<a href="#l11.1888"></a><span id="l11.1888">       ums.bindByIndex(1, null);</span>
<a href="#l11.1889"></a><span id="l11.1889" class="difflineat">@@ -2584,17 +2538,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1890"></a><span id="l11.1890">     }</span>
<a href="#l11.1891"></a><span id="l11.1891">   },</span>
<a href="#l11.1892"></a><span id="l11.1892"> </span>
<a href="#l11.1893"></a><span id="l11.1893">   /**</span>
<a href="#l11.1894"></a><span id="l11.1894">    * Updates the full-text row associated with this message. This only performs</span>
<a href="#l11.1895"></a><span id="l11.1895">    * the UPDATE query if the indexed body text has changed, which means that if</span>
<a href="#l11.1896"></a><span id="l11.1896">    * the body hasn't changed but the attachments have, we don't update.</span>
<a href="#l11.1897"></a><span id="l11.1897">    */</span>
<a href="#l11.1898"></a><span id="l11.1898" class="difflineminus">-  _updateMessageText: function gloda_ds__updateMessageText(aMessage) {</span>
<a href="#l11.1899"></a><span id="l11.1899" class="difflineplus">+  _updateMessageText(aMessage) {</span>
<a href="#l11.1900"></a><span id="l11.1900">     let newIndexedBodyText;</span>
<a href="#l11.1901"></a><span id="l11.1901">     if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l11.1902"></a><span id="l11.1902">       newIndexedBodyText = aMessage._content.getContentString(true);</span>
<a href="#l11.1903"></a><span id="l11.1903">     else if (aMessage._bodyLines)</span>
<a href="#l11.1904"></a><span id="l11.1904">       newIndexedBodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l11.1905"></a><span id="l11.1905">     else</span>
<a href="#l11.1906"></a><span id="l11.1906">       newIndexedBodyText = null;</span>
<a href="#l11.1907"></a><span id="l11.1907"> </span>
<a href="#l11.1908"></a><span id="l11.1908" class="difflineat">@@ -2615,18 +2569,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1909"></a><span id="l11.1909"> </span>
<a href="#l11.1910"></a><span id="l11.1910">     if (aMessage._attachmentNames == null)</span>
<a href="#l11.1911"></a><span id="l11.1911">       umts.bindByIndex(1, null);</span>
<a href="#l11.1912"></a><span id="l11.1912">     else</span>
<a href="#l11.1913"></a><span id="l11.1913">       umts.bindByIndex(1, aMessage._attachmentNames.join(&quot;\n&quot;));</span>
<a href="#l11.1914"></a><span id="l11.1914"> </span>
<a href="#l11.1915"></a><span id="l11.1915">     try {</span>
<a href="#l11.1916"></a><span id="l11.1916">       umts.executeAsync(this.trackAsync());</span>
<a href="#l11.1917"></a><span id="l11.1917" class="difflineminus">-    }</span>
<a href="#l11.1918"></a><span id="l11.1918" class="difflineminus">-    catch(ex) {</span>
<a href="#l11.1919"></a><span id="l11.1919" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.1920"></a><span id="l11.1920">       throw new Error(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l11.1921"></a><span id="l11.1921">             this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l11.1922"></a><span id="l11.1922">             this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l11.1923"></a><span id="l11.1923">     }</span>
<a href="#l11.1924"></a><span id="l11.1924">   },</span>
<a href="#l11.1925"></a><span id="l11.1925"> </span>
<a href="#l11.1926"></a><span id="l11.1926">   get _updateMessageLocationStatement() {</span>
<a href="#l11.1927"></a><span id="l11.1927">     let statement = this._createAsyncStatement(</span>
<a href="#l11.1928"></a><span id="l11.1928" class="difflineat">@@ -2636,18 +2589,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1929"></a><span id="l11.1929">     return this._updateMessageLocationStatement;</span>
<a href="#l11.1930"></a><span id="l11.1930">   },</span>
<a href="#l11.1931"></a><span id="l11.1931"> </span>
<a href="#l11.1932"></a><span id="l11.1932">   /**</span>
<a href="#l11.1933"></a><span id="l11.1933">    * Given a list of gloda message ids, and a list of their new message keys in</span>
<a href="#l11.1934"></a><span id="l11.1934">    *  the given new folder location, asynchronously update the message's</span>
<a href="#l11.1935"></a><span id="l11.1935">    *  database locations.  Also, update the in-memory representations.</span>
<a href="#l11.1936"></a><span id="l11.1936">    */</span>
<a href="#l11.1937"></a><span id="l11.1937" class="difflineminus">-  updateMessageLocations: function gloda_ds_updateMessageLocations(aMessageIds,</span>
<a href="#l11.1938"></a><span id="l11.1938" class="difflineminus">-      aNewMessageKeys, aDestFolder, aDoNotNotify) {</span>
<a href="#l11.1939"></a><span id="l11.1939" class="difflineplus">+  updateMessageLocations(aMessageIds, aNewMessageKeys, aDestFolder, aDoNotNotify) {</span>
<a href="#l11.1940"></a><span id="l11.1940">     let statement = this._updateMessageLocationStatement;</span>
<a href="#l11.1941"></a><span id="l11.1941">     let destFolderID = (typeof(aDestFolder) == &quot;number&quot;) ? aDestFolder :</span>
<a href="#l11.1942"></a><span id="l11.1942">                          this._mapFolder(aDestFolder).id;</span>
<a href="#l11.1943"></a><span id="l11.1943"> </span>
<a href="#l11.1944"></a><span id="l11.1944">     // map gloda id to the new message key for in-memory rep transform below</span>
<a href="#l11.1945"></a><span id="l11.1945">     let cacheLookupMap = {};</span>
<a href="#l11.1946"></a><span id="l11.1946"> </span>
<a href="#l11.1947"></a><span id="l11.1947">     for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l11.1948"></a><span id="l11.1948" class="difflineat">@@ -2692,17 +2644,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1949"></a><span id="l11.1949"> </span>
<a href="#l11.1950"></a><span id="l11.1950">   /**</span>
<a href="#l11.1951"></a><span id="l11.1951">    * Update the message keys for the gloda messages with the given id's.  This</span>
<a href="#l11.1952"></a><span id="l11.1952">    *  is to be used in response to msgKeyChanged notifications and is similar to</span>
<a href="#l11.1953"></a><span id="l11.1953">    *  `updateMessageLocations` except that we do not update the folder and we</span>
<a href="#l11.1954"></a><span id="l11.1954">    *  do not perform itemsModified notifications (because message keys are not</span>
<a href="#l11.1955"></a><span id="l11.1955">    *  intended to be relevant to the gloda message abstraction).</span>
<a href="#l11.1956"></a><span id="l11.1956">    */</span>
<a href="#l11.1957"></a><span id="l11.1957" class="difflineminus">-  updateMessageKeys: function(aMessageIds, aNewMessageKeys) {</span>
<a href="#l11.1958"></a><span id="l11.1958" class="difflineplus">+  updateMessageKeys(aMessageIds, aNewMessageKeys) {</span>
<a href="#l11.1959"></a><span id="l11.1959">     let statement = this._updateMessageKeyStatement;</span>
<a href="#l11.1960"></a><span id="l11.1960"> </span>
<a href="#l11.1961"></a><span id="l11.1961">     // map gloda id to the new message key for in-memory rep transform below</span>
<a href="#l11.1962"></a><span id="l11.1962">     let cacheLookupMap = {};</span>
<a href="#l11.1963"></a><span id="l11.1963"> </span>
<a href="#l11.1964"></a><span id="l11.1964">     for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l11.1965"></a><span id="l11.1965">       let id = aMessageIds[iMsg], msgKey = aNewMessageKeys[iMsg];</span>
<a href="#l11.1966"></a><span id="l11.1966">       statement.bindByIndex(0, msgKey);</span>
<a href="#l11.1967"></a><span id="l11.1967" class="difflineat">@@ -2726,19 +2678,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1968"></a><span id="l11.1968"> </span>
<a href="#l11.1969"></a><span id="l11.1969">   /**</span>
<a href="#l11.1970"></a><span id="l11.1970">    * Asynchronously mutate message folder id/message keys for the given</span>
<a href="#l11.1971"></a><span id="l11.1971">    *  messages, indicating that we are moving them to the target folder, but</span>
<a href="#l11.1972"></a><span id="l11.1972">    *  don't yet know their target message keys.</span>
<a href="#l11.1973"></a><span id="l11.1973">    *</span>
<a href="#l11.1974"></a><span id="l11.1974">    * Updates in-memory representations too.</span>
<a href="#l11.1975"></a><span id="l11.1975">    */</span>
<a href="#l11.1976"></a><span id="l11.1976" class="difflineminus">-  updateMessageFoldersByKeyPurging:</span>
<a href="#l11.1977"></a><span id="l11.1977" class="difflineminus">-      function gloda_ds_updateMessageFoldersByKeyPurging(aGlodaIds,</span>
<a href="#l11.1978"></a><span id="l11.1978" class="difflineminus">-                                                         aDestFolder) {</span>
<a href="#l11.1979"></a><span id="l11.1979" class="difflineplus">+  updateMessageFoldersByKeyPurging(aGlodaIds, aDestFolder) {</span>
<a href="#l11.1980"></a><span id="l11.1980">     let destFolderID = this._mapFolder(aDestFolder).id;</span>
<a href="#l11.1981"></a><span id="l11.1981"> </span>
<a href="#l11.1982"></a><span id="l11.1982">     let sqlStr = &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l11.1983"></a><span id="l11.1983">                                       messageKey = ?2 \</span>
<a href="#l11.1984"></a><span id="l11.1984">                    WHERE id IN (&quot; + aGlodaIds.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l11.1985"></a><span id="l11.1985">     let statement = this._createAsyncStatement(sqlStr, true);</span>
<a href="#l11.1986"></a><span id="l11.1986">     statement.bindByIndex(0, destFolderID);</span>
<a href="#l11.1987"></a><span id="l11.1987">     statement.bindByIndex(1, null);</span>
<a href="#l11.1988"></a><span id="l11.1988" class="difflineat">@@ -2750,17 +2700,17 @@ var GlodaDatastore = {</span>
<a href="#l11.1989"></a><span id="l11.1989">                                                  aGlodaIds);</span>
<a href="#l11.1990"></a><span id="l11.1990">     for (let id in cached) {</span>
<a href="#l11.1991"></a><span id="l11.1991">       let glodaMsg = cached[id];</span>
<a href="#l11.1992"></a><span id="l11.1992">       glodaMsg._folderID = destFolderID;</span>
<a href="#l11.1993"></a><span id="l11.1993">       glodaMsg._messageKey = null;</span>
<a href="#l11.1994"></a><span id="l11.1994">     }</span>
<a href="#l11.1995"></a><span id="l11.1995">   },</span>
<a href="#l11.1996"></a><span id="l11.1996"> </span>
<a href="#l11.1997"></a><span id="l11.1997" class="difflineminus">-  _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l11.1998"></a><span id="l11.1998" class="difflineplus">+  _messageFromRow(aRow) {</span>
<a href="#l11.1999"></a><span id="l11.1999">     let folderId, messageKey, date, jsonText, subject, indexedBodyText,</span>
<a href="#l11.2000"></a><span id="l11.2000">         attachmentNames;</span>
<a href="#l11.2001"></a><span id="l11.2001">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.2002"></a><span id="l11.2002">       folderId = null;</span>
<a href="#l11.2003"></a><span id="l11.2003">     else</span>
<a href="#l11.2004"></a><span id="l11.2004">       folderId = aRow.getInt64(1);</span>
<a href="#l11.2005"></a><span id="l11.2005">     if (aRow.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.2006"></a><span id="l11.2006">       messageKey = null;</span>
<a href="#l11.2007"></a><span id="l11.2007" class="difflineat">@@ -2779,19 +2729,19 @@ var GlodaDatastore = {</span>
<a href="#l11.2008"></a><span id="l11.2008">       if (aRow.getTypeOfIndex(10) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.2009"></a><span id="l11.2009">         subject = undefined;</span>
<a href="#l11.2010"></a><span id="l11.2010">       else</span>
<a href="#l11.2011"></a><span id="l11.2011">         subject = aRow.getString(10);</span>
<a href="#l11.2012"></a><span id="l11.2012">       if (aRow.getTypeOfIndex(9) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.2013"></a><span id="l11.2013">         indexedBodyText = undefined;</span>
<a href="#l11.2014"></a><span id="l11.2014">       else</span>
<a href="#l11.2015"></a><span id="l11.2015">         indexedBodyText = aRow.getString(9);</span>
<a href="#l11.2016"></a><span id="l11.2016" class="difflineminus">-      if (aRow.getTypeOfIndex(11) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.2017"></a><span id="l11.2017" class="difflineplus">+      if (aRow.getTypeOfIndex(11) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL) {</span>
<a href="#l11.2018"></a><span id="l11.2018">         attachmentNames = null;</span>
<a href="#l11.2019"></a><span id="l11.2019" class="difflineminus">-      else {</span>
<a href="#l11.2020"></a><span id="l11.2020" class="difflineplus">+      } else {</span>
<a href="#l11.2021"></a><span id="l11.2021">         attachmentNames = aRow.getString(11);</span>
<a href="#l11.2022"></a><span id="l11.2022">         if (attachmentNames)</span>
<a href="#l11.2023"></a><span id="l11.2023">           attachmentNames = attachmentNames.split(&quot;\n&quot;);</span>
<a href="#l11.2024"></a><span id="l11.2024">         else</span>
<a href="#l11.2025"></a><span id="l11.2025">           attachmentNames = null;</span>
<a href="#l11.2026"></a><span id="l11.2026">       }</span>
<a href="#l11.2027"></a><span id="l11.2027">       // we ignore 12, author</span>
<a href="#l11.2028"></a><span id="l11.2028">       // we ignore 13, recipients</span>
<a href="#l11.2029"></a><span id="l11.2029" class="difflineat">@@ -2818,36 +2768,34 @@ var GlodaDatastore = {</span>
<a href="#l11.2030"></a><span id="l11.2030">    *  we obviously do not know the id's of the messages affected by this which</span>
<a href="#l11.2031"></a><span id="l11.2031">    *  complicates in-memory updates.  The options are sending out to the SQL</span>
<a href="#l11.2032"></a><span id="l11.2032">    *  database for a list of the message id's or some form of in-memory</span>
<a href="#l11.2033"></a><span id="l11.2033">    *  traversal.  I/O costs being what they are, users having a propensity to</span>
<a href="#l11.2034"></a><span id="l11.2034">    *  have folders with tens of thousands of messages, and the unlikeliness</span>
<a href="#l11.2035"></a><span id="l11.2035">    *  of all of those messages being gloda-memory-resident, we go with the</span>
<a href="#l11.2036"></a><span id="l11.2036">    *  in-memory traversal.</span>
<a href="#l11.2037"></a><span id="l11.2037">    */</span>
<a href="#l11.2038"></a><span id="l11.2038" class="difflineminus">-  markMessagesDeletedByFolderID:</span>
<a href="#l11.2039"></a><span id="l11.2039" class="difflineminus">-      function gloda_ds_markMessagesDeletedByFolderID(aFolderID) {</span>
<a href="#l11.2040"></a><span id="l11.2040" class="difflineplus">+  markMessagesDeletedByFolderID(aFolderID) {</span>
<a href="#l11.2041"></a><span id="l11.2041">     let statement = this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l11.2042"></a><span id="l11.2042">     statement.bindByIndex(0, aFolderID);</span>
<a href="#l11.2043"></a><span id="l11.2043">     statement.executeAsync(this.trackAsync());</span>
<a href="#l11.2044"></a><span id="l11.2044"> </span>
<a href="#l11.2045"></a><span id="l11.2045">     // Have the collection manager generate itemsRemoved events for any</span>
<a href="#l11.2046"></a><span id="l11.2046">     //  in-memory messages in that folder.</span>
<a href="#l11.2047"></a><span id="l11.2047">     GlodaCollectionManager.itemsDeletedByAttribute(</span>
<a href="#l11.2048"></a><span id="l11.2048">       GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l11.2049"></a><span id="l11.2049">       aMsg =&gt; aMsg._folderID == aFolderID);</span>
<a href="#l11.2050"></a><span id="l11.2050">   },</span>
<a href="#l11.2051"></a><span id="l11.2051"> </span>
<a href="#l11.2052"></a><span id="l11.2052">   /**</span>
<a href="#l11.2053"></a><span id="l11.2053">    * Mark all the gloda messages as deleted blind-fire.  Check if any of the</span>
<a href="#l11.2054"></a><span id="l11.2054">    *  messages are known to the collection manager and update them to be deleted</span>
<a href="#l11.2055"></a><span id="l11.2055">    *  along with the requisite collection notifications.</span>
<a href="#l11.2056"></a><span id="l11.2056">    */</span>
<a href="#l11.2057"></a><span id="l11.2057" class="difflineminus">-  markMessagesDeletedByIDs: function gloda_ds_markMessagesDeletedByIDs(</span>
<a href="#l11.2058"></a><span id="l11.2058" class="difflineminus">-      aMessageIDs) {</span>
<a href="#l11.2059"></a><span id="l11.2059" class="difflineplus">+  markMessagesDeletedByIDs(aMessageIDs) {</span>
<a href="#l11.2060"></a><span id="l11.2060">     // When marking deleted clear the folderID and messageKey so that the</span>
<a href="#l11.2061"></a><span id="l11.2061">     //  indexing process can reuse it without any location constraints.</span>
<a href="#l11.2062"></a><span id="l11.2062">     let sqlString = &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, &quot; +</span>
<a href="#l11.2063"></a><span id="l11.2063">                      &quot;deleted = 1 WHERE id IN (&quot; +</span>
<a href="#l11.2064"></a><span id="l11.2064">                      aMessageIDs.join(&quot;,&quot;) + &quot;)&quot;;</span>
<a href="#l11.2065"></a><span id="l11.2065"> </span>
<a href="#l11.2066"></a><span id="l11.2066">     let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l11.2067"></a><span id="l11.2067">     statement.executeAsync(this.trackAsync());</span>
<a href="#l11.2068"></a><span id="l11.2068" class="difflineat">@@ -2863,17 +2811,17 @@ var GlodaDatastore = {</span>
<a href="#l11.2069"></a><span id="l11.2069">     this.__defineGetter__(&quot;_countDeletedMessagesStatement&quot;,</span>
<a href="#l11.2070"></a><span id="l11.2070">                           () =&gt; statement);</span>
<a href="#l11.2071"></a><span id="l11.2071">     return this._countDeletedMessagesStatement;</span>
<a href="#l11.2072"></a><span id="l11.2072">   },</span>
<a href="#l11.2073"></a><span id="l11.2073"> </span>
<a href="#l11.2074"></a><span id="l11.2074">   /**</span>
<a href="#l11.2075"></a><span id="l11.2075">    * Count how many messages are currently marked as deleted in the database.</span>
<a href="#l11.2076"></a><span id="l11.2076">    */</span>
<a href="#l11.2077"></a><span id="l11.2077" class="difflineminus">-  countDeletedMessages: function gloda_ds_countDeletedMessages(aCallback) {</span>
<a href="#l11.2078"></a><span id="l11.2078" class="difflineplus">+  countDeletedMessages(aCallback) {</span>
<a href="#l11.2079"></a><span id="l11.2079">     let cms = this._countDeletedMessagesStatement;</span>
<a href="#l11.2080"></a><span id="l11.2080">     cms.executeAsync(new SingletonResultValueHandler(aCallback));</span>
<a href="#l11.2081"></a><span id="l11.2081">   },</span>
<a href="#l11.2082"></a><span id="l11.2082"> </span>
<a href="#l11.2083"></a><span id="l11.2083">   get _deleteMessageByIDStatement() {</span>
<a href="#l11.2084"></a><span id="l11.2084">     let statement = this._createAsyncStatement(</span>
<a href="#l11.2085"></a><span id="l11.2085">       &quot;DELETE FROM messages WHERE id = ?1&quot;);</span>
<a href="#l11.2086"></a><span id="l11.2086">     this.__defineGetter__(&quot;_deleteMessageByIDStatement&quot;,</span>
<a href="#l11.2087"></a><span id="l11.2087" class="difflineat">@@ -2889,43 +2837,41 @@ var GlodaDatastore = {</span>
<a href="#l11.2088"></a><span id="l11.2088">     return this._deleteMessageTextByIDStatement;</span>
<a href="#l11.2089"></a><span id="l11.2089">   },</span>
<a href="#l11.2090"></a><span id="l11.2090"> </span>
<a href="#l11.2091"></a><span id="l11.2091">   /**</span>
<a href="#l11.2092"></a><span id="l11.2092">    * Delete a message and its fulltext from the database.  It is assumed that</span>
<a href="#l11.2093"></a><span id="l11.2093">    *  the message was already marked as deleted and so is not visible to the</span>
<a href="#l11.2094"></a><span id="l11.2094">    *  collection manager and so nothing needs to be done about that.</span>
<a href="#l11.2095"></a><span id="l11.2095">    */</span>
<a href="#l11.2096"></a><span id="l11.2096" class="difflineminus">-  deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l11.2097"></a><span id="l11.2097" class="difflineplus">+  deleteMessageByID(aMessageID) {</span>
<a href="#l11.2098"></a><span id="l11.2098">     let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l11.2099"></a><span id="l11.2099">     dmbids.bindByIndex(0, aMessageID);</span>
<a href="#l11.2100"></a><span id="l11.2100">     dmbids.executeAsync(this.trackAsync());</span>
<a href="#l11.2101"></a><span id="l11.2101"> </span>
<a href="#l11.2102"></a><span id="l11.2102">     this.deleteMessageTextByID(aMessageID);</span>
<a href="#l11.2103"></a><span id="l11.2103">   },</span>
<a href="#l11.2104"></a><span id="l11.2104"> </span>
<a href="#l11.2105"></a><span id="l11.2105" class="difflineminus">-  deleteMessageTextByID: function gloda_ds_deleteMessageTextByID(aMessageID) {</span>
<a href="#l11.2106"></a><span id="l11.2106" class="difflineplus">+  deleteMessageTextByID(aMessageID) {</span>
<a href="#l11.2107"></a><span id="l11.2107">     let dmt = this._deleteMessageTextByIDStatement;</span>
<a href="#l11.2108"></a><span id="l11.2108">     dmt.bindByIndex(0, aMessageID);</span>
<a href="#l11.2109"></a><span id="l11.2109">     dmt.executeAsync(this.trackAsync());</span>
<a href="#l11.2110"></a><span id="l11.2110">   },</span>
<a href="#l11.2111"></a><span id="l11.2111"> </span>
<a href="#l11.2112"></a><span id="l11.2112">   get _folderCompactionStatement() {</span>
<a href="#l11.2113"></a><span id="l11.2113">     let statement = this._createAsyncStatement(</span>
<a href="#l11.2114"></a><span id="l11.2114">       &quot;SELECT id, messageKey, headerMessageID FROM messages \</span>
<a href="#l11.2115"></a><span id="l11.2115">         WHERE folderID = ?1 AND \</span>
<a href="#l11.2116"></a><span id="l11.2116">           messageKey &gt;= ?2 AND +deleted = 0 ORDER BY messageKey LIMIT ?3&quot;);</span>
<a href="#l11.2117"></a><span id="l11.2117">     this.__defineGetter__(&quot;_folderCompactionStatement&quot;,</span>
<a href="#l11.2118"></a><span id="l11.2118">                           () =&gt; statement);</span>
<a href="#l11.2119"></a><span id="l11.2119">     return this._folderCompactionStatement;</span>
<a href="#l11.2120"></a><span id="l11.2120">   },</span>
<a href="#l11.2121"></a><span id="l11.2121"> </span>
<a href="#l11.2122"></a><span id="l11.2122" class="difflineminus">-  folderCompactionPassBlockFetch:</span>
<a href="#l11.2123"></a><span id="l11.2123" class="difflineminus">-      function gloda_ds_folderCompactionPassBlockFetch(</span>
<a href="#l11.2124"></a><span id="l11.2124" class="difflineminus">-        aFolderID, aStartingMessageKey, aLimit, aCallback) {</span>
<a href="#l11.2125"></a><span id="l11.2125" class="difflineplus">+  folderCompactionPassBlockFetch(aFolderID, aStartingMessageKey, aLimit, aCallback) {</span>
<a href="#l11.2126"></a><span id="l11.2126">     let fcs = this._folderCompactionStatement;</span>
<a href="#l11.2127"></a><span id="l11.2127">     fcs.bindByIndex(0, aFolderID);</span>
<a href="#l11.2128"></a><span id="l11.2128">     fcs.bindByIndex(1, aStartingMessageKey);</span>
<a href="#l11.2129"></a><span id="l11.2129">     fcs.bindByIndex(2, aLimit);</span>
<a href="#l11.2130"></a><span id="l11.2130">     fcs.executeAsync(new CompactionBlockFetcherHandler(aCallback));</span>
<a href="#l11.2131"></a><span id="l11.2131">   },</span>
<a href="#l11.2132"></a><span id="l11.2132"> </span>
<a href="#l11.2133"></a><span id="l11.2133">   /* ********** Message Attributes ********** */</span>
<a href="#l11.2134"></a><span id="l11.2134" class="difflineat">@@ -2963,18 +2909,17 @@ var GlodaDatastore = {</span>
<a href="#l11.2135"></a><span id="l11.2135">    * @param aAddDBAttributes A list of attribute tuples to add, where each tuple</span>
<a href="#l11.2136"></a><span id="l11.2136">    *     contains an attribute ID and a value.  Lest you forget, an attribute ID</span>
<a href="#l11.2137"></a><span id="l11.2137">    *     corresponds to a row in the attribute definition table.  The attribute</span>
<a href="#l11.2138"></a><span id="l11.2138">    *     definition table stores the 'parameter' for the attribute, if any.</span>
<a href="#l11.2139"></a><span id="l11.2139">    *     (Which is to say, our frequent Attribute-Parameter-Value triple has</span>
<a href="#l11.2140"></a><span id="l11.2140">    *     the Attribute-Parameter part distilled to a single attribute id.)</span>
<a href="#l11.2141"></a><span id="l11.2141">    * @param aRemoveDBAttributes A list of attribute tuples to remove.</span>
<a href="#l11.2142"></a><span id="l11.2142">    */</span>
<a href="#l11.2143"></a><span id="l11.2143" class="difflineminus">-  adjustMessageAttributes: function gloda_ds_adjustMessageAttributes(aMessage,</span>
<a href="#l11.2144"></a><span id="l11.2144" class="difflineminus">-                                        aAddDBAttributes, aRemoveDBAttributes) {</span>
<a href="#l11.2145"></a><span id="l11.2145" class="difflineplus">+  adjustMessageAttributes(aMessage, aAddDBAttributes, aRemoveDBAttributes) {</span>
<a href="#l11.2146"></a><span id="l11.2146">     let imas = this._insertMessageAttributeStatement;</span>
<a href="#l11.2147"></a><span id="l11.2147">     let dmas = this._deleteMessageAttributeStatement;</span>
<a href="#l11.2148"></a><span id="l11.2148">     this._beginTransaction();</span>
<a href="#l11.2149"></a><span id="l11.2149">     try {</span>
<a href="#l11.2150"></a><span id="l11.2150">       for (let iAttrib = 0; iAttrib &lt; aAddDBAttributes.length; iAttrib++) {</span>
<a href="#l11.2151"></a><span id="l11.2151">         let attribValueTuple = aAddDBAttributes[iAttrib];</span>
<a href="#l11.2152"></a><span id="l11.2152"> </span>
<a href="#l11.2153"></a><span id="l11.2153">         imas.bindByIndex(0, aMessage.conversationID);</span>
<a href="#l11.2154"></a><span id="l11.2154" class="difflineat">@@ -3004,18 +2949,17 @@ var GlodaDatastore = {</span>
<a href="#l11.2155"></a><span id="l11.2155">         else</span>
<a href="#l11.2156"></a><span id="l11.2156">           dmas.bindByIndex(1, attribValueTuple[1]);</span>
<a href="#l11.2157"></a><span id="l11.2157">         dmas.bindByIndex(2, aMessage.conversationID);</span>
<a href="#l11.2158"></a><span id="l11.2158">         dmas.bindByIndex(3, aMessage.id);</span>
<a href="#l11.2159"></a><span id="l11.2159">         dmas.executeAsync(this.trackAsync());</span>
<a href="#l11.2160"></a><span id="l11.2160">       }</span>
<a href="#l11.2161"></a><span id="l11.2161"> </span>
<a href="#l11.2162"></a><span id="l11.2162">       this._commitTransaction();</span>
<a href="#l11.2163"></a><span id="l11.2163" class="difflineminus">-    }</span>
<a href="#l11.2164"></a><span id="l11.2164" class="difflineminus">-    catch (ex) {</span>
<a href="#l11.2165"></a><span id="l11.2165" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.2166"></a><span id="l11.2166">       this._log.error(&quot;adjustMessageAttributes:&quot;, ex);</span>
<a href="#l11.2167"></a><span id="l11.2167">       this._rollbackTransaction();</span>
<a href="#l11.2168"></a><span id="l11.2168">       throw ex;</span>
<a href="#l11.2169"></a><span id="l11.2169">     }</span>
<a href="#l11.2170"></a><span id="l11.2170">   },</span>
<a href="#l11.2171"></a><span id="l11.2171"> </span>
<a href="#l11.2172"></a><span id="l11.2172">   get _deleteMessageAttributesByMessageIDStatement() {</span>
<a href="#l11.2173"></a><span id="l11.2173">     let statement = this._createAsyncStatement(</span>
<a href="#l11.2174"></a><span id="l11.2174" class="difflineat">@@ -3028,35 +2972,34 @@ var GlodaDatastore = {</span>
<a href="#l11.2175"></a><span id="l11.2175">   /**</span>
<a href="#l11.2176"></a><span id="l11.2176">    * Clear all the message attributes for a given GlodaMessage.  No changes</span>
<a href="#l11.2177"></a><span id="l11.2177">    *  are made to the in-memory representation of the message; it is up to the</span>
<a href="#l11.2178"></a><span id="l11.2178">    *  caller to ensure that it handles things correctly.</span>
<a href="#l11.2179"></a><span id="l11.2179">    *</span>
<a href="#l11.2180"></a><span id="l11.2180">    * @param aMessage The GlodaMessage whose database attributes should be</span>
<a href="#l11.2181"></a><span id="l11.2181">    *     purged.</span>
<a href="#l11.2182"></a><span id="l11.2182">    */</span>
<a href="#l11.2183"></a><span id="l11.2183" class="difflineminus">-  clearMessageAttributes: function gloda_ds_clearMessageAttributes(aMessage) {</span>
<a href="#l11.2184"></a><span id="l11.2184" class="difflineplus">+  clearMessageAttributes(aMessage) {</span>
<a href="#l11.2185"></a><span id="l11.2185">     if (aMessage.id != null) {</span>
<a href="#l11.2186"></a><span id="l11.2186">       this._deleteMessageAttributesByMessageIDStatement.bindByIndex(0,</span>
<a href="#l11.2187"></a><span id="l11.2187">         aMessage.id);</span>
<a href="#l11.2188"></a><span id="l11.2188">       this._deleteMessageAttributesByMessageIDStatement.executeAsync(</span>
<a href="#l11.2189"></a><span id="l11.2189">         this.trackAsync());</span>
<a href="#l11.2190"></a><span id="l11.2190">     }</span>
<a href="#l11.2191"></a><span id="l11.2191">   },</span>
<a href="#l11.2192"></a><span id="l11.2192"> </span>
<a href="#l11.2193"></a><span id="l11.2193" class="difflineminus">-  _stringSQLQuoter: function(aString) {</span>
<a href="#l11.2194"></a><span id="l11.2194" class="difflineplus">+  _stringSQLQuoter(aString) {</span>
<a href="#l11.2195"></a><span id="l11.2195">     return &quot;'&quot; + aString.replace(/\'/g, &quot;''&quot;) + &quot;'&quot;;</span>
<a href="#l11.2196"></a><span id="l11.2196">   },</span>
<a href="#l11.2197"></a><span id="l11.2197" class="difflineminus">-  _numberQuoter: function(aNum) {</span>
<a href="#l11.2198"></a><span id="l11.2198" class="difflineplus">+  _numberQuoter(aNum) {</span>
<a href="#l11.2199"></a><span id="l11.2199">     return aNum;</span>
<a href="#l11.2200"></a><span id="l11.2200">   },</span>
<a href="#l11.2201"></a><span id="l11.2201"> </span>
<a href="#l11.2202"></a><span id="l11.2202">   /* ===== Generic Attribute Support ===== */</span>
<a href="#l11.2203"></a><span id="l11.2203" class="difflineminus">-  adjustAttributes: function gloda_ds_adjustAttributes(aItem, aAddDBAttributes,</span>
<a href="#l11.2204"></a><span id="l11.2204" class="difflineminus">-      aRemoveDBAttributes) {</span>
<a href="#l11.2205"></a><span id="l11.2205" class="difflineplus">+  adjustAttributes(aItem, aAddDBAttributes, aRemoveDBAttributes) {</span>
<a href="#l11.2206"></a><span id="l11.2206">     let nounDef = aItem.NOUN_DEF;</span>
<a href="#l11.2207"></a><span id="l11.2207">     let dbMeta = nounDef._dbMeta;</span>
<a href="#l11.2208"></a><span id="l11.2208">     if (dbMeta.insertAttrStatement === undefined) {</span>
<a href="#l11.2209"></a><span id="l11.2209">       dbMeta.insertAttrStatement = this._createAsyncStatement(</span>
<a href="#l11.2210"></a><span id="l11.2210">         &quot;INSERT INTO &quot; + nounDef.attrTableName +</span>
<a href="#l11.2211"></a><span id="l11.2211">         &quot; (&quot; + nounDef.attrIDColumnName + &quot;, attributeID, value) &quot; +</span>
<a href="#l11.2212"></a><span id="l11.2212">         &quot; VALUES (?1, ?2, ?3)&quot;);</span>
<a href="#l11.2213"></a><span id="l11.2213">       // we always create this at the same time (right here), no need to check</span>
<a href="#l11.2214"></a><span id="l11.2214" class="difflineat">@@ -3098,27 +3041,26 @@ var GlodaDatastore = {</span>
<a href="#l11.2215"></a><span id="l11.2215">           das.bindByIndex(1, attribValueTuple[1]);</span>
<a href="#l11.2216"></a><span id="l11.2216">         else</span>
<a href="#l11.2217"></a><span id="l11.2217">           das.bindByIndex(1, attribValueTuple[1]);</span>
<a href="#l11.2218"></a><span id="l11.2218">         das.bindByIndex(2, aItem.id);</span>
<a href="#l11.2219"></a><span id="l11.2219">         das.executeAsync(this.trackAsync());</span>
<a href="#l11.2220"></a><span id="l11.2220">       }</span>
<a href="#l11.2221"></a><span id="l11.2221"> </span>
<a href="#l11.2222"></a><span id="l11.2222">       this._commitTransaction();</span>
<a href="#l11.2223"></a><span id="l11.2223" class="difflineminus">-    }</span>
<a href="#l11.2224"></a><span id="l11.2224" class="difflineminus">-    catch (ex) {</span>
<a href="#l11.2225"></a><span id="l11.2225" class="difflineplus">+    } catch (ex) {</span>
<a href="#l11.2226"></a><span id="l11.2226">       this._log.error(&quot;adjustAttributes:&quot;, ex);</span>
<a href="#l11.2227"></a><span id="l11.2227">       this._rollbackTransaction();</span>
<a href="#l11.2228"></a><span id="l11.2228">       throw ex;</span>
<a href="#l11.2229"></a><span id="l11.2229">     }</span>
<a href="#l11.2230"></a><span id="l11.2230">   },</span>
<a href="#l11.2231"></a><span id="l11.2231"> </span>
<a href="#l11.2232"></a><span id="l11.2232" class="difflineminus">-  clearAttributes: function gloda_ds_clearAttributes(aItem) {</span>
<a href="#l11.2233"></a><span id="l11.2233" class="difflineplus">+  clearAttributes(aItem) {</span>
<a href="#l11.2234"></a><span id="l11.2234">     let nounDef = aItem.NOUN_DEF;</span>
<a href="#l11.2235"></a><span id="l11.2235" class="difflineminus">-    let dbMeta = nounMeta._dbMeta;</span>
<a href="#l11.2236"></a><span id="l11.2236" class="difflineplus">+    let dbMeta = nounDef._dbMeta;</span>
<a href="#l11.2237"></a><span id="l11.2237">     if (dbMeta.clearAttrStatement === undefined) {</span>
<a href="#l11.2238"></a><span id="l11.2238">       dbMeta.clearAttrStatement = this._createAsyncStatement(</span>
<a href="#l11.2239"></a><span id="l11.2239">         &quot;DELETE FROM &quot; + nounDef.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l11.2240"></a><span id="l11.2240">         nounDef.attrIDColumnName + &quot; = ?1&quot;);</span>
<a href="#l11.2241"></a><span id="l11.2241">     }</span>
<a href="#l11.2242"></a><span id="l11.2242"> </span>
<a href="#l11.2243"></a><span id="l11.2243">     if (aItem.id != null) {</span>
<a href="#l11.2244"></a><span id="l11.2244">       dbMeta.clearAttrstatement.bindByIndex(0, aItem.id);</span>
<a href="#l11.2245"></a><span id="l11.2245" class="difflineat">@@ -3132,19 +3074,17 @@ var GlodaDatastore = {</span>
<a href="#l11.2246"></a><span id="l11.2246">    *  for this reason.</span>
<a href="#l11.2247"></a><span id="l11.2247">    */</span>
<a href="#l11.2248"></a><span id="l11.2248">   get _escapeLikeStatement() {</span>
<a href="#l11.2249"></a><span id="l11.2249">     let statement = this._createAsyncStatement(&quot;SELECT 0&quot;);</span>
<a href="#l11.2250"></a><span id="l11.2250">     this.__defineGetter__(&quot;_escapeLikeStatement&quot;, () =&gt; statement);</span>
<a href="#l11.2251"></a><span id="l11.2251">     return this._escapeLikeStatement;</span>
<a href="#l11.2252"></a><span id="l11.2252">   },</span>
<a href="#l11.2253"></a><span id="l11.2253"> </span>
<a href="#l11.2254"></a><span id="l11.2254" class="difflineminus">-  _convertToDBValuesAndGroupByAttributeID:</span>
<a href="#l11.2255"></a><span id="l11.2255" class="difflineminus">-    function* gloda_ds__convertToDBValuesAndGroupByAttributeID(aAttrDef,</span>
<a href="#l11.2256"></a><span id="l11.2256" class="difflineminus">-                                                               aValues) {</span>
<a href="#l11.2257"></a><span id="l11.2257" class="difflineplus">+  * _convertToDBValuesAndGroupByAttributeID(aAttrDef, aValues) {</span>
<a href="#l11.2258"></a><span id="l11.2258">     let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l11.2259"></a><span id="l11.2259">     if (!objectNounDef.usesParameter) {</span>
<a href="#l11.2260"></a><span id="l11.2260">       let dbValues = [];</span>
<a href="#l11.2261"></a><span id="l11.2261">       for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l11.2262"></a><span id="l11.2262">         let value = aValues[iValue];</span>
<a href="#l11.2263"></a><span id="l11.2263">         // If the empty set is significant and it's an empty signifier, emit</span>
<a href="#l11.2264"></a><span id="l11.2264">         //  the appropriate dbvalue.</span>
<a href="#l11.2265"></a><span id="l11.2265">         if (value == null &amp;&amp; aAttrDef.emptySetIsSignificant) {</span>
<a href="#l11.2266"></a><span id="l11.2266" class="difflineat">@@ -3180,38 +3120,34 @@ var GlodaDatastore = {</span>
<a href="#l11.2267"></a><span id="l11.2267">       let [dbParam, dbValue] = objectNounDef.toParamAndValue(value);</span>
<a href="#l11.2268"></a><span id="l11.2268">       if (curParam === undefined) {</span>
<a href="#l11.2269"></a><span id="l11.2269">         curParam = dbParam;</span>
<a href="#l11.2270"></a><span id="l11.2270">         attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l11.2271"></a><span id="l11.2271">         if (dbValue != null)</span>
<a href="#l11.2272"></a><span id="l11.2272">           dbValues = [dbValue];</span>
<a href="#l11.2273"></a><span id="l11.2273">         else</span>
<a href="#l11.2274"></a><span id="l11.2274">           dbValues = [];</span>
<a href="#l11.2275"></a><span id="l11.2275" class="difflineminus">-      }</span>
<a href="#l11.2276"></a><span id="l11.2276" class="difflineminus">-      else if (curParam == dbParam) {</span>
<a href="#l11.2277"></a><span id="l11.2277" class="difflineplus">+      } else if (curParam == dbParam) {</span>
<a href="#l11.2278"></a><span id="l11.2278">         if (dbValue != null)</span>
<a href="#l11.2279"></a><span id="l11.2279">           dbValues.push(dbValue);</span>
<a href="#l11.2280"></a><span id="l11.2280" class="difflineminus">-      }</span>
<a href="#l11.2281"></a><span id="l11.2281" class="difflineminus">-      else {</span>
<a href="#l11.2282"></a><span id="l11.2282" class="difflineplus">+      } else {</span>
<a href="#l11.2283"></a><span id="l11.2283">         yield [attrID, dbValues];</span>
<a href="#l11.2284"></a><span id="l11.2284">         curParam = dbParam;</span>
<a href="#l11.2285"></a><span id="l11.2285">         attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l11.2286"></a><span id="l11.2286">         if (dbValue != null)</span>
<a href="#l11.2287"></a><span id="l11.2287">           dbValues = [dbValue];</span>
<a href="#l11.2288"></a><span id="l11.2288">         else</span>
<a href="#l11.2289"></a><span id="l11.2289">           dbValues = [];</span>
<a href="#l11.2290"></a><span id="l11.2290">       }</span>
<a href="#l11.2291"></a><span id="l11.2291">     }</span>
<a href="#l11.2292"></a><span id="l11.2292">     if (dbValues !== undefined)</span>
<a href="#l11.2293"></a><span id="l11.2293">       yield [attrID, dbValues];</span>
<a href="#l11.2294"></a><span id="l11.2294">   },</span>
<a href="#l11.2295"></a><span id="l11.2295"> </span>
<a href="#l11.2296"></a><span id="l11.2296" class="difflineminus">-  _convertRangesToDBStringsAndGroupByAttributeID:</span>
<a href="#l11.2297"></a><span id="l11.2297" class="difflineminus">-    function* gloda_ds__convertRangesToDBStringsAndGroupByAttributeID(aAttrDef,</span>
<a href="#l11.2298"></a><span id="l11.2298" class="difflineminus">-      aValues, aValueColumnName) {</span>
<a href="#l11.2299"></a><span id="l11.2299" class="difflineplus">+  * _convertRangesToDBStringsAndGroupByAttributeID(aAttrDef, aValues, aValueColumnName) {</span>
<a href="#l11.2300"></a><span id="l11.2300">     let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l11.2301"></a><span id="l11.2301">     if (!objectNounDef.usesParameter) {</span>
<a href="#l11.2302"></a><span id="l11.2302">       let dbStrings = [];</span>
<a href="#l11.2303"></a><span id="l11.2303">       for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l11.2304"></a><span id="l11.2304">         let [lowerVal, upperVal] = aValues[iValue];</span>
<a href="#l11.2305"></a><span id="l11.2305">         // they both can't be null.  that is the law.</span>
<a href="#l11.2306"></a><span id="l11.2306">         if (lowerVal == null)</span>
<a href="#l11.2307"></a><span id="l11.2307">           dbStrings.push(aValueColumnName + &quot; &lt;= &quot; +</span>
<a href="#l11.2308"></a><span id="l11.2308" class="difflineat">@@ -3233,59 +3169,55 @@ var GlodaDatastore = {</span>
<a href="#l11.2309"></a><span id="l11.2309">     for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l11.2310"></a><span id="l11.2310">       let [lowerVal, upperVal] = aValues[iValue];</span>
<a href="#l11.2311"></a><span id="l11.2311"> </span>
<a href="#l11.2312"></a><span id="l11.2312">       let dbString, dbParam, lowerDBVal, upperDBVal;</span>
<a href="#l11.2313"></a><span id="l11.2313">       // they both can't be null.  that is the law.</span>
<a href="#l11.2314"></a><span id="l11.2314">       if (lowerVal == null) {</span>
<a href="#l11.2315"></a><span id="l11.2315">         [dbParam, upperDBVal] = objectNounDef.toParamAndValue(upperVal);</span>
<a href="#l11.2316"></a><span id="l11.2316">         dbString = aValueColumnName + &quot; &lt;= &quot; + upperDBVal;</span>
<a href="#l11.2317"></a><span id="l11.2317" class="difflineminus">-      }</span>
<a href="#l11.2318"></a><span id="l11.2318" class="difflineminus">-      else if (upperVal == null) {</span>
<a href="#l11.2319"></a><span id="l11.2319" class="difflineplus">+      } else if (upperVal == null) {</span>
<a href="#l11.2320"></a><span id="l11.2320">         [dbParam, lowerDBVal] = objectNounDef.toParamAndValue(lowerVal);</span>
<a href="#l11.2321"></a><span id="l11.2321">         dbString = aValueColumnName + &quot; &gt;= &quot; + lowerDBVal;</span>
<a href="#l11.2322"></a><span id="l11.2322" class="difflineminus">-      }</span>
<a href="#l11.2323"></a><span id="l11.2323" class="difflineminus">-      else { // no one is null!</span>
<a href="#l11.2324"></a><span id="l11.2324" class="difflineplus">+      } else { // no one is null!</span>
<a href="#l11.2325"></a><span id="l11.2325">         [dbParam, lowerDBVal] = objectNounDef.toParamAndValue(lowerVal);</span>
<a href="#l11.2326"></a><span id="l11.2326">         dbString = aValueColumnName + &quot; BETWEEN &quot; + lowerDBVal + &quot; AND &quot; +</span>
<a href="#l11.2327"></a><span id="l11.2327">                    objectNounDef.toParamAndValue(upperVal)[1];</span>
<a href="#l11.2328"></a><span id="l11.2328">       }</span>
<a href="#l11.2329"></a><span id="l11.2329"> </span>
<a href="#l11.2330"></a><span id="l11.2330">       if (curParam === undefined) {</span>
<a href="#l11.2331"></a><span id="l11.2331">         curParam = dbParam;</span>
<a href="#l11.2332"></a><span id="l11.2332">         attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l11.2333"></a><span id="l11.2333">         dbStrings = [dbString];</span>
<a href="#l11.2334"></a><span id="l11.2334" class="difflineminus">-      }</span>
<a href="#l11.2335"></a><span id="l11.2335" class="difflineminus">-      else if (curParam === dbParam) {</span>
<a href="#l11.2336"></a><span id="l11.2336" class="difflineplus">+      } else if (curParam === dbParam) {</span>
<a href="#l11.2337"></a><span id="l11.2337">         dbStrings.push(dbString);</span>
<a href="#l11.2338"></a><span id="l11.2338" class="difflineminus">-      }</span>
<a href="#l11.2339"></a><span id="l11.2339" class="difflineminus">-      else {</span>
<a href="#l11.2340"></a><span id="l11.2340" class="difflineplus">+      } else {</span>
<a href="#l11.2341"></a><span id="l11.2341">         yield [attrID, dbStrings];</span>
<a href="#l11.2342"></a><span id="l11.2342">         curParam = dbParam;</span>
<a href="#l11.2343"></a><span id="l11.2343">         attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l11.2344"></a><span id="l11.2344">         dbStrings = [dbString];</span>
<a href="#l11.2345"></a><span id="l11.2345">       }</span>
<a href="#l11.2346"></a><span id="l11.2346">     }</span>
<a href="#l11.2347"></a><span id="l11.2347">     if (dbStrings !== undefined)</span>
<a href="#l11.2348"></a><span id="l11.2348">       yield [attrID, dbStrings];</span>
<a href="#l11.2349"></a><span id="l11.2349">   },</span>
<a href="#l11.2350"></a><span id="l11.2350"> </span>
<a href="#l11.2351"></a><span id="l11.2351" class="difflineplus">+  /* eslint-disable complexity */</span>
<a href="#l11.2352"></a><span id="l11.2352">   /**</span>
<a href="#l11.2353"></a><span id="l11.2353">    * Perform a database query given a GlodaQueryClass instance that specifies</span>
<a href="#l11.2354"></a><span id="l11.2354">    *  a set of constraints relating to the noun type associated with the query.</span>
<a href="#l11.2355"></a><span id="l11.2355">    *  A GlodaCollection is returned containing the results of the look-up.</span>
<a href="#l11.2356"></a><span id="l11.2356">    *  By default the collection is &quot;live&quot;, and will mutate (generating events to</span>
<a href="#l11.2357"></a><span id="l11.2357">    *  its listener) as the state of the database changes.</span>
<a href="#l11.2358"></a><span id="l11.2358">    * This functionality is made user/extension visible by the Query's</span>
<a href="#l11.2359"></a><span id="l11.2359">    *  getCollection (asynchronous).</span>
<a href="#l11.2360"></a><span id="l11.2360">    *</span>
<a href="#l11.2361"></a><span id="l11.2361">    * @param [aArgs] See |GlodaQuery.getCollection| for info.</span>
<a href="#l11.2362"></a><span id="l11.2362">    */</span>
<a href="#l11.2363"></a><span id="l11.2363" class="difflineminus">-  queryFromQuery: function gloda_ds_queryFromQuery(aQuery, aListener,</span>
<a href="#l11.2364"></a><span id="l11.2364" class="difflineminus">-      aListenerData, aExistingCollection, aMasterCollection, aArgs) {</span>
<a href="#l11.2365"></a><span id="l11.2365" class="difflineplus">+  queryFromQuery(aQuery, aListener, aListenerData, aExistingCollection, aMasterCollection, aArgs) {</span>
<a href="#l11.2366"></a><span id="l11.2366">     // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l11.2367"></a><span id="l11.2367">     //  likewise has its changes made.</span>
<a href="#l11.2368"></a><span id="l11.2368">     let nounDef = aQuery._nounDef;</span>
<a href="#l11.2369"></a><span id="l11.2369"> </span>
<a href="#l11.2370"></a><span id="l11.2370">     let whereClauses = [];</span>
<a href="#l11.2371"></a><span id="l11.2371">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l11.2372"></a><span id="l11.2372">     let boundArgs = [];</span>
<a href="#l11.2373"></a><span id="l11.2373"> </span>
<a href="#l11.2374"></a><span id="l11.2374" class="difflineat">@@ -3309,45 +3241,42 @@ var GlodaDatastore = {</span>
<a href="#l11.2375"></a><span id="l11.2375">       let curConstraintIsSpecial;</span>
<a href="#l11.2376"></a><span id="l11.2376"> </span>
<a href="#l11.2377"></a><span id="l11.2377">       for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length;</span>
<a href="#l11.2378"></a><span id="l11.2378">            iConstraint++) {</span>
<a href="#l11.2379"></a><span id="l11.2379">         let constraint = curQuery._constraints[iConstraint];</span>
<a href="#l11.2380"></a><span id="l11.2380">         let [constraintType, attrDef] = constraint;</span>
<a href="#l11.2381"></a><span id="l11.2381">         let constraintValues = constraint.slice(2);</span>
<a href="#l11.2382"></a><span id="l11.2382"> </span>
<a href="#l11.2383"></a><span id="l11.2383" class="difflineminus">-        let tableName, idColumnName, tableColumnName, valueColumnName;</span>
<a href="#l11.2384"></a><span id="l11.2384" class="difflineplus">+        let tableName, idColumnName, valueColumnName;</span>
<a href="#l11.2385"></a><span id="l11.2385">         if (constraintType == this.kConstraintIdIn) {</span>
<a href="#l11.2386"></a><span id="l11.2386">           // we don't need any of the next cases' setup code, and we especially</span>
<a href="#l11.2387"></a><span id="l11.2387">           //  would prefer that attrDef isn't accessed since it's null for us.</span>
<a href="#l11.2388"></a><span id="l11.2388" class="difflineminus">-        }</span>
<a href="#l11.2389"></a><span id="l11.2389" class="difflineminus">-        else if (attrDef.special) {</span>
<a href="#l11.2390"></a><span id="l11.2390" class="difflineplus">+        } else if (attrDef.special) {</span>
<a href="#l11.2391"></a><span id="l11.2391">           tableName = nounDef.tableName;</span>
<a href="#l11.2392"></a><span id="l11.2392">           idColumnName = &quot;id&quot;; // canonical id for a table is &quot;id&quot;.</span>
<a href="#l11.2393"></a><span id="l11.2393">           valueColumnName = attrDef.specialColumnName;</span>
<a href="#l11.2394"></a><span id="l11.2394">           curConstraintIsSpecial = true;</span>
<a href="#l11.2395"></a><span id="l11.2395" class="difflineminus">-        }</span>
<a href="#l11.2396"></a><span id="l11.2396" class="difflineminus">-        else {</span>
<a href="#l11.2397"></a><span id="l11.2397" class="difflineplus">+        } else {</span>
<a href="#l11.2398"></a><span id="l11.2398">           tableName = nounDef.attrTableName;</span>
<a href="#l11.2399"></a><span id="l11.2399">           idColumnName = nounDef.attrIDColumnName;</span>
<a href="#l11.2400"></a><span id="l11.2400">           valueColumnName = &quot;value&quot;;</span>
<a href="#l11.2401"></a><span id="l11.2401">           curConstraintIsSpecial = false;</span>
<a href="#l11.2402"></a><span id="l11.2402">         }</span>
<a href="#l11.2403"></a><span id="l11.2403"> </span>
<a href="#l11.2404"></a><span id="l11.2404" class="difflineminus">-        let select = null, test = null, bindArgs = null;</span>
<a href="#l11.2405"></a><span id="l11.2405" class="difflineplus">+        let select = null, test = null;</span>
<a href="#l11.2406"></a><span id="l11.2406">         if (constraintType === this.kConstraintIdIn) {</span>
<a href="#l11.2407"></a><span id="l11.2407">           // this is somewhat of a trick.  this does mean that this can be the</span>
<a href="#l11.2408"></a><span id="l11.2408">           //  only constraint.  Namely, our idiom is:</span>
<a href="#l11.2409"></a><span id="l11.2409">           // SELECT * FROM blah WHERE id IN (a INTERSECT b INTERSECT c)</span>
<a href="#l11.2410"></a><span id="l11.2410">           //  but if we only have 'a', then that becomes &quot;...IN (a)&quot;, and if</span>
<a href="#l11.2411"></a><span id="l11.2411">           //  'a' is not a select but a list of id's... tricky, no?</span>
<a href="#l11.2412"></a><span id="l11.2412">           select = constraintValues.join(&quot;,&quot;);</span>
<a href="#l11.2413"></a><span id="l11.2413" class="difflineminus">-        }</span>
<a href="#l11.2414"></a><span id="l11.2414" class="difflineminus">-        // @testpoint gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l11.2415"></a><span id="l11.2415" class="difflineminus">-        else if (constraintType === this.kConstraintIn) {</span>
<a href="#l11.2416"></a><span id="l11.2416" class="difflineplus">+        } else if (constraintType === this.kConstraintIn) {</span>
<a href="#l11.2417"></a><span id="l11.2417" class="difflineplus">+          // @testpoint gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l11.2418"></a><span id="l11.2418">           let clauses = [];</span>
<a href="#l11.2419"></a><span id="l11.2419">           for (let [attrID, values] of</span>
<a href="#l11.2420"></a><span id="l11.2420">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l11.2421"></a><span id="l11.2421">                                                            constraintValues)) {</span>
<a href="#l11.2422"></a><span id="l11.2422">             let clausePart;</span>
<a href="#l11.2423"></a><span id="l11.2423">             if (attrID !== undefined)</span>
<a href="#l11.2424"></a><span id="l11.2424">               clausePart = &quot;(attributeID = &quot; + attrID +</span>
<a href="#l11.2425"></a><span id="l11.2425">                 (values.length ? &quot; AND &quot; : &quot;&quot;);</span>
<a href="#l11.2426"></a><span id="l11.2426" class="difflineat">@@ -3361,88 +3290,83 @@ var GlodaDatastore = {</span>
<a href="#l11.2427"></a><span id="l11.2427">               if ((&quot;special&quot; in attrDef) &amp;&amp; (attrDef.special == this.kSpecialString)) {</span>
<a href="#l11.2428"></a><span id="l11.2428">                 clausePart += valueColumnName + &quot; IN (&quot; +</span>
<a href="#l11.2429"></a><span id="l11.2429">                   values.map(v =&gt; &quot;'&quot; + v.replace(/\'/g, &quot;''&quot;) + &quot;'&quot;).</span>
<a href="#l11.2430"></a><span id="l11.2430">                   join(&quot;,&quot;) + &quot;))&quot;;</span>
<a href="#l11.2431"></a><span id="l11.2431">               } else {</span>
<a href="#l11.2432"></a><span id="l11.2432">                 clausePart += valueColumnName + &quot; IN (&quot; + values.join(&quot;,&quot;) +</span>
<a href="#l11.2433"></a><span id="l11.2433">                               &quot;))&quot;;</span>
<a href="#l11.2434"></a><span id="l11.2434">               }</span>
<a href="#l11.2435"></a><span id="l11.2435" class="difflineplus">+            } else {</span>
<a href="#l11.2436"></a><span id="l11.2436" class="difflineplus">+              clausePart += &quot;)&quot;;</span>
<a href="#l11.2437"></a><span id="l11.2437">             }</span>
<a href="#l11.2438"></a><span id="l11.2438" class="difflineminus">-            else</span>
<a href="#l11.2439"></a><span id="l11.2439" class="difflineminus">-              clausePart += &quot;)&quot;;</span>
<a href="#l11.2440"></a><span id="l11.2440">             clauses.push(clausePart);</span>
<a href="#l11.2441"></a><span id="l11.2441">           }</span>
<a href="#l11.2442"></a><span id="l11.2442">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l11.2443"></a><span id="l11.2443" class="difflineminus">-        }</span>
<a href="#l11.2444"></a><span id="l11.2444" class="difflineminus">-        // @testpoint gloda.datastore.sqlgen.kConstraintRanges</span>
<a href="#l11.2445"></a><span id="l11.2445" class="difflineminus">-        else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l11.2446"></a><span id="l11.2446" class="difflineplus">+        } else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l11.2447"></a><span id="l11.2447" class="difflineplus">+          // @testpoint gloda.datastore.sqlgen.kConstraintRanges</span>
<a href="#l11.2448"></a><span id="l11.2448">           let clauses = [];</span>
<a href="#l11.2449"></a><span id="l11.2449">           for (let [attrID, dbStrings] of</span>
<a href="#l11.2450"></a><span id="l11.2450">               this._convertRangesToDBStringsAndGroupByAttributeID(attrDef,</span>
<a href="#l11.2451"></a><span id="l11.2451">                               constraintValues, valueColumnName)) {</span>
<a href="#l11.2452"></a><span id="l11.2452">             if (attrID !== undefined)</span>
<a href="#l11.2453"></a><span id="l11.2453">               clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l11.2454"></a><span id="l11.2454">                            &quot; AND (&quot; + dbStrings.join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l11.2455"></a><span id="l11.2455">             else</span>
<a href="#l11.2456"></a><span id="l11.2456">               clauses.push(&quot;(&quot; + dbStrings.join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l11.2457"></a><span id="l11.2457">           }</span>
<a href="#l11.2458"></a><span id="l11.2458">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l11.2459"></a><span id="l11.2459" class="difflineminus">-        }</span>
<a href="#l11.2460"></a><span id="l11.2460" class="difflineminus">-        // @testpoint gloda.datastore.sqlgen.kConstraintEquals</span>
<a href="#l11.2461"></a><span id="l11.2461" class="difflineminus">-        else if (constraintType === this.kConstraintEquals) {</span>
<a href="#l11.2462"></a><span id="l11.2462" class="difflineplus">+        } else if (constraintType === this.kConstraintEquals) {</span>
<a href="#l11.2463"></a><span id="l11.2463" class="difflineplus">+          // @testpoint gloda.datastore.sqlgen.kConstraintEquals</span>
<a href="#l11.2464"></a><span id="l11.2464">           let clauses = [];</span>
<a href="#l11.2465"></a><span id="l11.2465">           for (let [attrID, values] of</span>
<a href="#l11.2466"></a><span id="l11.2466">               this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l11.2467"></a><span id="l11.2467">                                                            constraintValues)) {</span>
<a href="#l11.2468"></a><span id="l11.2468">             if (attrID !== undefined)</span>
<a href="#l11.2469"></a><span id="l11.2469">               clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l11.2470"></a><span id="l11.2470">                   &quot; AND (&quot; + values.map(_ =&gt; valueColumnName + &quot; = ?&quot;).</span>
<a href="#l11.2471"></a><span id="l11.2471">                   join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l11.2472"></a><span id="l11.2472">             else</span>
<a href="#l11.2473"></a><span id="l11.2473">               clauses.push(&quot;(&quot; + values.map(_ =&gt; valueColumnName + &quot; = ?&quot;).</span>
<a href="#l11.2474"></a><span id="l11.2474">                            join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l11.2475"></a><span id="l11.2475">             boundArgs.push.apply(boundArgs, values);</span>
<a href="#l11.2476"></a><span id="l11.2476">           }</span>
<a href="#l11.2477"></a><span id="l11.2477">           test = clauses.join(&quot; OR &quot;);</span>
<a href="#l11.2478"></a><span id="l11.2478" class="difflineminus">-        }</span>
<a href="#l11.2479"></a><span id="l11.2479" class="difflineminus">-        // @testpoint gloda.datastore.sqlgen.kConstraintStringLike</span>
<a href="#l11.2480"></a><span id="l11.2480" class="difflineminus">-        else if (constraintType === this.kConstraintStringLike) {</span>
<a href="#l11.2481"></a><span id="l11.2481" class="difflineminus">-          let likePayload = '';</span>
<a href="#l11.2482"></a><span id="l11.2482" class="difflineplus">+        } else if (constraintType === this.kConstraintStringLike) {</span>
<a href="#l11.2483"></a><span id="l11.2483" class="difflineplus">+          // @testpoint gloda.datastore.sqlgen.kConstraintStringLike</span>
<a href="#l11.2484"></a><span id="l11.2484" class="difflineplus">+          let likePayload = &quot;&quot;;</span>
<a href="#l11.2485"></a><span id="l11.2485">           for (let valuePart of constraintValues) {</span>
<a href="#l11.2486"></a><span id="l11.2486">             if (typeof valuePart == &quot;string&quot;)</span>
<a href="#l11.2487"></a><span id="l11.2487">               likePayload += this._escapeLikeStatement.escapeStringForLIKE(</span>
<a href="#l11.2488"></a><span id="l11.2488">                 valuePart, &quot;/&quot;);</span>
<a href="#l11.2489"></a><span id="l11.2489">             else</span>
<a href="#l11.2490"></a><span id="l11.2490">               likePayload += &quot;%&quot;;</span>
<a href="#l11.2491"></a><span id="l11.2491">           }</span>
<a href="#l11.2492"></a><span id="l11.2492">           test = valueColumnName + &quot; LIKE ? ESCAPE '/'&quot;;</span>
<a href="#l11.2493"></a><span id="l11.2493">           boundArgs.push(likePayload);</span>
<a href="#l11.2494"></a><span id="l11.2494" class="difflineminus">-        }</span>
<a href="#l11.2495"></a><span id="l11.2495" class="difflineminus">-        // @testpoint gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l11.2496"></a><span id="l11.2496" class="difflineminus">-        else if (constraintType === this.kConstraintFulltext) {</span>
<a href="#l11.2497"></a><span id="l11.2497" class="difflineplus">+        } else if (constraintType === this.kConstraintFulltext) {</span>
<a href="#l11.2498"></a><span id="l11.2498" class="difflineplus">+          // @testpoint gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l11.2499"></a><span id="l11.2499">           let matchStr = constraintValues[0];</span>
<a href="#l11.2500"></a><span id="l11.2500">           select = &quot;SELECT docid FROM &quot; + nounDef.tableName + &quot;Text&quot; +</span>
<a href="#l11.2501"></a><span id="l11.2501">             &quot; WHERE &quot; + attrDef.specialColumnName + &quot; MATCH ?&quot;;</span>
<a href="#l11.2502"></a><span id="l11.2502">           boundArgs.push(matchStr);</span>
<a href="#l11.2503"></a><span id="l11.2503">         }</span>
<a href="#l11.2504"></a><span id="l11.2504"> </span>
<a href="#l11.2505"></a><span id="l11.2505">         if (curConstraintIsSpecial &amp;&amp; lastConstraintWasSpecial &amp;&amp; test) {</span>
<a href="#l11.2506"></a><span id="l11.2506" class="difflineminus">-          selects[selects.length-1] += &quot; AND &quot; + test;</span>
<a href="#l11.2507"></a><span id="l11.2507" class="difflineminus">-        }</span>
<a href="#l11.2508"></a><span id="l11.2508" class="difflineminus">-        else if (select)</span>
<a href="#l11.2509"></a><span id="l11.2509" class="difflineplus">+          selects[selects.length - 1] += &quot; AND &quot; + test;</span>
<a href="#l11.2510"></a><span id="l11.2510" class="difflineplus">+        } else if (select) {</span>
<a href="#l11.2511"></a><span id="l11.2511">           selects.push(select);</span>
<a href="#l11.2512"></a><span id="l11.2512" class="difflineminus">-        else if (test) {</span>
<a href="#l11.2513"></a><span id="l11.2513" class="difflineplus">+        } else if (test) {</span>
<a href="#l11.2514"></a><span id="l11.2514">           select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName + &quot; WHERE &quot; +</span>
<a href="#l11.2515"></a><span id="l11.2515">               test;</span>
<a href="#l11.2516"></a><span id="l11.2516">           selects.push(select);</span>
<a href="#l11.2517"></a><span id="l11.2517" class="difflineminus">-        }</span>
<a href="#l11.2518"></a><span id="l11.2518" class="difflineminus">-        else</span>
<a href="#l11.2519"></a><span id="l11.2519" class="difflineplus">+        } else {</span>
<a href="#l11.2520"></a><span id="l11.2520">           this._log.warn(&quot;Unable to translate constraint of type &quot; +</span>
<a href="#l11.2521"></a><span id="l11.2521">             constraintType + &quot; on attribute bound as &quot; + nounDef.name);</span>
<a href="#l11.2522"></a><span id="l11.2522" class="difflineplus">+        }</span>
<a href="#l11.2523"></a><span id="l11.2523"> </span>
<a href="#l11.2524"></a><span id="l11.2524">         lastConstraintWasSpecial = curConstraintIsSpecial;</span>
<a href="#l11.2525"></a><span id="l11.2525">       }</span>
<a href="#l11.2526"></a><span id="l11.2526"> </span>
<a href="#l11.2527"></a><span id="l11.2527">       if (selects.length)</span>
<a href="#l11.2528"></a><span id="l11.2528">         whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot;)&quot; +</span>
<a href="#l11.2529"></a><span id="l11.2529">                           validityConstraintSuffix);</span>
<a href="#l11.2530"></a><span id="l11.2530">     }</span>
<a href="#l11.2531"></a><span id="l11.2531" class="difflineat">@@ -3496,29 +3420,30 @@ var GlodaDatastore = {</span>
<a href="#l11.2532"></a><span id="l11.2532">     if (aArgs &amp;&amp; (&quot;becomeExplicit&quot; in aArgs) &amp;&amp; aArgs.becomeExplicit)</span>
<a href="#l11.2533"></a><span id="l11.2533">       aQuery = new nounDef.explicitQueryClass();</span>
<a href="#l11.2534"></a><span id="l11.2534">     else if (aArgs &amp;&amp; (&quot;becomeNull&quot; in aArgs) &amp;&amp; aArgs.becomeNull)</span>
<a href="#l11.2535"></a><span id="l11.2535">       aQuery = new nounDef.nullQueryClass();</span>
<a href="#l11.2536"></a><span id="l11.2536"> </span>
<a href="#l11.2537"></a><span id="l11.2537">     return this._queryFromSQLString(sqlString, boundArgs, nounDef, aQuery,</span>
<a href="#l11.2538"></a><span id="l11.2538">         aListener, aListenerData, aExistingCollection, aMasterCollection);</span>
<a href="#l11.2539"></a><span id="l11.2539">   },</span>
<a href="#l11.2540"></a><span id="l11.2540" class="difflineminus">-</span>
<a href="#l11.2541"></a><span id="l11.2541" class="difflineminus">-  _queryFromSQLString: function gloda_ds__queryFromSQLString(aSqlString,</span>
<a href="#l11.2542"></a><span id="l11.2542" class="difflineplus">+  /* eslint-enable complexity */</span>
<a href="#l11.2543"></a><span id="l11.2543" class="difflineplus">+</span>
<a href="#l11.2544"></a><span id="l11.2544" class="difflineplus">+  _queryFromSQLString(aSqlString,</span>
<a href="#l11.2545"></a><span id="l11.2545">       aBoundArgs, aNounDef, aQuery, aListener, aListenerData,</span>
<a href="#l11.2546"></a><span id="l11.2546">       aExistingCollection, aMasterCollection) {</span>
<a href="#l11.2547"></a><span id="l11.2547">     let statement = this._createAsyncStatement(aSqlString, true);</span>
<a href="#l11.2548"></a><span id="l11.2548">     for (let [iBinding, bindingValue] of aBoundArgs.entries()) {</span>
<a href="#l11.2549"></a><span id="l11.2549">       this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l11.2550"></a><span id="l11.2550">     }</span>
<a href="#l11.2551"></a><span id="l11.2551"> </span>
<a href="#l11.2552"></a><span id="l11.2552">     let collection;</span>
<a href="#l11.2553"></a><span id="l11.2553" class="difflineminus">-    if (aExistingCollection)</span>
<a href="#l11.2554"></a><span id="l11.2554" class="difflineplus">+    if (aExistingCollection) {</span>
<a href="#l11.2555"></a><span id="l11.2555">       collection = aExistingCollection;</span>
<a href="#l11.2556"></a><span id="l11.2556" class="difflineminus">-    else {</span>
<a href="#l11.2557"></a><span id="l11.2557" class="difflineplus">+    } else {</span>
<a href="#l11.2558"></a><span id="l11.2558">       collection = new GlodaCollection(aNounDef, [], aQuery, aListener,</span>
<a href="#l11.2559"></a><span id="l11.2559">                                        aMasterCollection);</span>
<a href="#l11.2560"></a><span id="l11.2560">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l11.2561"></a><span id="l11.2561">       // we don't want to overwrite the existing listener or its data, but this</span>
<a href="#l11.2562"></a><span id="l11.2562">       //  does raise the question about what should happen if we get passed in</span>
<a href="#l11.2563"></a><span id="l11.2563">       //  a different listener and/or data.</span>
<a href="#l11.2564"></a><span id="l11.2564">       if (aListenerData !== undefined)</span>
<a href="#l11.2565"></a><span id="l11.2565">         collection.data = aListenerData;</span>
<a href="#l11.2566"></a><span id="l11.2566" class="difflineat">@@ -3531,78 +3456,72 @@ var GlodaDatastore = {</span>
<a href="#l11.2567"></a><span id="l11.2567">     }</span>
<a href="#l11.2568"></a><span id="l11.2568"> </span>
<a href="#l11.2569"></a><span id="l11.2569">     statement.executeAsync(new QueryFromQueryCallback(statement, aNounDef,</span>
<a href="#l11.2570"></a><span id="l11.2570">       collection));</span>
<a href="#l11.2571"></a><span id="l11.2571">     statement.finalize();</span>
<a href="#l11.2572"></a><span id="l11.2572">     return collection;</span>
<a href="#l11.2573"></a><span id="l11.2573">   },</span>
<a href="#l11.2574"></a><span id="l11.2574"> </span>
<a href="#l11.2575"></a><span id="l11.2575" class="difflineminus">-  /**</span>
<a href="#l11.2576"></a><span id="l11.2576" class="difflineminus">-   *</span>
<a href="#l11.2577"></a><span id="l11.2577" class="difflineminus">-   *</span>
<a href="#l11.2578"></a><span id="l11.2578" class="difflineminus">-   */</span>
<a href="#l11.2579"></a><span id="l11.2579" class="difflineminus">-  loadNounItem: function gloda_ds_loadNounItem(aItem, aReferencesByNounID,</span>
<a href="#l11.2580"></a><span id="l11.2580" class="difflineminus">-      aInverseReferencesByNounID) {</span>
<a href="#l11.2581"></a><span id="l11.2581" class="difflineplus">+  /* eslint-disable complexity */</span>
<a href="#l11.2582"></a><span id="l11.2582" class="difflineplus">+  loadNounItem(aItem, aReferencesByNounID, aInverseReferencesByNounID) {</span>
<a href="#l11.2583"></a><span id="l11.2583">     let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l11.2584"></a><span id="l11.2584"> </span>
<a href="#l11.2585"></a><span id="l11.2585">     let hadDeps = aItem._deps != null;</span>
<a href="#l11.2586"></a><span id="l11.2586">     let deps = aItem._deps || {};</span>
<a href="#l11.2587"></a><span id="l11.2587">     let hasDeps = false;</span>
<a href="#l11.2588"></a><span id="l11.2588"> </span>
<a href="#l11.2589"></a><span id="l11.2589" class="difflineminus">-    //this._log.debug(&quot;  hadDeps: &quot; + hadDeps + &quot; deps: &quot; +</span>
<a href="#l11.2590"></a><span id="l11.2590" class="difflineplus">+    // this._log.debug(&quot;  hadDeps: &quot; + hadDeps + &quot; deps: &quot; +</span>
<a href="#l11.2591"></a><span id="l11.2591">     //    Log4Moz.enumerateProperties(deps).join(&quot;,&quot;));</span>
<a href="#l11.2592"></a><span id="l11.2592"> </span>
<a href="#l11.2593"></a><span id="l11.2593">     for (let attrib of aItem.NOUN_DEF.specialLoadAttribs) {</span>
<a href="#l11.2594"></a><span id="l11.2594">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l11.2595"></a><span id="l11.2595"> </span>
<a href="#l11.2596"></a><span id="l11.2596">       if ((&quot;special&quot; in attrib) &amp;&amp; (attrib.special === this.kSpecialColumnChildren)) {</span>
<a href="#l11.2597"></a><span id="l11.2597">         let invReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l11.2598"></a><span id="l11.2598">         if (invReferences === undefined)</span>
<a href="#l11.2599"></a><span id="l11.2599">           invReferences = aInverseReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l11.2600"></a><span id="l11.2600">         // only contribute if it's not already pending or there</span>
<a href="#l11.2601"></a><span id="l11.2601" class="difflineminus">-        if (!(attrib.id in deps) &amp;&amp; aItem[attrib.storageAttributeName] == null){</span>
<a href="#l11.2602"></a><span id="l11.2602" class="difflineminus">-          //this._log.debug(&quot;   Adding inv ref for: &quot; + aItem.id);</span>
<a href="#l11.2603"></a><span id="l11.2603" class="difflineplus">+        if (!(attrib.id in deps) &amp;&amp; aItem[attrib.storageAttributeName] == null) {</span>
<a href="#l11.2604"></a><span id="l11.2604" class="difflineplus">+          // this._log.debug(&quot;   Adding inv ref for: &quot; + aItem.id);</span>
<a href="#l11.2605"></a><span id="l11.2605">           if (!(aItem.id in invReferences))</span>
<a href="#l11.2606"></a><span id="l11.2606">             invReferences[aItem.id] = null;</span>
<a href="#l11.2607"></a><span id="l11.2607">           deps[attrib.id] = null;</span>
<a href="#l11.2608"></a><span id="l11.2608">           hasDeps = true;</span>
<a href="#l11.2609"></a><span id="l11.2609">         }</span>
<a href="#l11.2610"></a><span id="l11.2610" class="difflineminus">-      }</span>
<a href="#l11.2611"></a><span id="l11.2611" class="difflineminus">-      else if ((&quot;special&quot; in attrib) &amp;&amp; (attrib.special === this.kSpecialColumnParent)) {</span>
<a href="#l11.2612"></a><span id="l11.2612" class="difflineplus">+      } else if ((&quot;special&quot; in attrib) &amp;&amp; (attrib.special === this.kSpecialColumnParent)) {</span>
<a href="#l11.2613"></a><span id="l11.2613">         let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l11.2614"></a><span id="l11.2614">         if (references === undefined)</span>
<a href="#l11.2615"></a><span id="l11.2615">           references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l11.2616"></a><span id="l11.2616">         // nothing to contribute if it's already there</span>
<a href="#l11.2617"></a><span id="l11.2617">         if (!(attrib.id in deps) &amp;&amp;</span>
<a href="#l11.2618"></a><span id="l11.2618">             aItem[attrib.valueStorageAttributeName] == null) {</span>
<a href="#l11.2619"></a><span id="l11.2619">           let parentID = aItem[attrib.idStorageAttributeName];</span>
<a href="#l11.2620"></a><span id="l11.2620">           if (!(parentID in references))</span>
<a href="#l11.2621"></a><span id="l11.2621">             references[parentID] = null;</span>
<a href="#l11.2622"></a><span id="l11.2622" class="difflineminus">-          //this._log.debug(&quot;   Adding parent ref for: &quot; +</span>
<a href="#l11.2623"></a><span id="l11.2623" class="difflineplus">+          // this._log.debug(&quot;   Adding parent ref for: &quot; +</span>
<a href="#l11.2624"></a><span id="l11.2624">           //  aItem[attrib.idStorageAttributeName]);</span>
<a href="#l11.2625"></a><span id="l11.2625">           deps[attrib.id] = null;</span>
<a href="#l11.2626"></a><span id="l11.2626">           hasDeps = true;</span>
<a href="#l11.2627"></a><span id="l11.2627" class="difflineminus">-        }</span>
<a href="#l11.2628"></a><span id="l11.2628" class="difflineminus">-        else {</span>
<a href="#l11.2629"></a><span id="l11.2629" class="difflineplus">+        } else {</span>
<a href="#l11.2630"></a><span id="l11.2630">           this._log.debug(&quot;  paranoia value storage: &quot; + aItem[attrib.valueStorageAttributeName]);</span>
<a href="#l11.2631"></a><span id="l11.2631">         }</span>
<a href="#l11.2632"></a><span id="l11.2632">       }</span>
<a href="#l11.2633"></a><span id="l11.2633">     }</span>
<a href="#l11.2634"></a><span id="l11.2634"> </span>
<a href="#l11.2635"></a><span id="l11.2635">     // bail here if arbitrary values are not allowed, there just is no</span>
<a href="#l11.2636"></a><span id="l11.2636">     //  encoded json, or we already had dependencies for this guy, implying</span>
<a href="#l11.2637"></a><span id="l11.2637">     //  the json pass has already been performed</span>
<a href="#l11.2638"></a><span id="l11.2638">     if (!aItem.NOUN_DEF.allowsArbitraryAttrs || !aItem._jsonText || hadDeps) {</span>
<a href="#l11.2639"></a><span id="l11.2639">       if (hasDeps)</span>
<a href="#l11.2640"></a><span id="l11.2640">         aItem._deps = deps;</span>
<a href="#l11.2641"></a><span id="l11.2641">       return hasDeps;</span>
<a href="#l11.2642"></a><span id="l11.2642">     }</span>
<a href="#l11.2643"></a><span id="l11.2643"> </span>
<a href="#l11.2644"></a><span id="l11.2644" class="difflineminus">-    //this._log.debug(&quot; load json: &quot; + aItem._jsonText);</span>
<a href="#l11.2645"></a><span id="l11.2645" class="difflineplus">+    // this._log.debug(&quot; load json: &quot; + aItem._jsonText);</span>
<a href="#l11.2646"></a><span id="l11.2646">     let jsonDict = JSON.parse(aItem._jsonText);</span>
<a href="#l11.2647"></a><span id="l11.2647">     delete aItem._jsonText;</span>
<a href="#l11.2648"></a><span id="l11.2648"> </span>
<a href="#l11.2649"></a><span id="l11.2649">     // Iterate over the attributes on the item</span>
<a href="#l11.2650"></a><span id="l11.2650">     for (let attribId in jsonDict) {</span>
<a href="#l11.2651"></a><span id="l11.2651">       let jsonValue = jsonDict[attribId];</span>
<a href="#l11.2652"></a><span id="l11.2652">       // It is technically impossible for attribute ids to go away at this</span>
<a href="#l11.2653"></a><span id="l11.2653">       //  point in time.  This would require someone to monkey around with</span>
<a href="#l11.2654"></a><span id="l11.2654" class="difflineat">@@ -3633,155 +3552,146 @@ var GlodaDatastore = {</span>
<a href="#l11.2655"></a><span id="l11.2655">       if (objectNounDef.tableName &amp;&amp; !objectNounDef.fromJSON) {</span>
<a href="#l11.2656"></a><span id="l11.2656">         let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l11.2657"></a><span id="l11.2657">         if (references === undefined)</span>
<a href="#l11.2658"></a><span id="l11.2658">           references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l11.2659"></a><span id="l11.2659"> </span>
<a href="#l11.2660"></a><span id="l11.2660">         if (attrib.singular) {</span>
<a href="#l11.2661"></a><span id="l11.2661">           if (!(jsonValue in references))</span>
<a href="#l11.2662"></a><span id="l11.2662">             references[jsonValue] = null;</span>
<a href="#l11.2663"></a><span id="l11.2663" class="difflineminus">-        }</span>
<a href="#l11.2664"></a><span id="l11.2664" class="difflineminus">-        else {</span>
<a href="#l11.2665"></a><span id="l11.2665" class="difflineplus">+        } else {</span>
<a href="#l11.2666"></a><span id="l11.2666">           for (let key in jsonValue) {</span>
<a href="#l11.2667"></a><span id="l11.2667">             let anID = jsonValue[key];</span>
<a href="#l11.2668"></a><span id="l11.2668">             if (!(anID in references))</span>
<a href="#l11.2669"></a><span id="l11.2669">             references[anID] = null;</span>
<a href="#l11.2670"></a><span id="l11.2670">           }</span>
<a href="#l11.2671"></a><span id="l11.2671">         }</span>
<a href="#l11.2672"></a><span id="l11.2672"> </span>
<a href="#l11.2673"></a><span id="l11.2673">         deps[attribId] = jsonValue;</span>
<a href="#l11.2674"></a><span id="l11.2674">         hasDeps = true;</span>
<a href="#l11.2675"></a><span id="l11.2675" class="difflineminus">-      }</span>
<a href="#l11.2676"></a><span id="l11.2676" class="difflineminus">-      /* if it has custom contribution logic, use it */</span>
<a href="#l11.2677"></a><span id="l11.2677" class="difflineminus">-      else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l11.2678"></a><span id="l11.2678" class="difflineplus">+      } else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l11.2679"></a><span id="l11.2679" class="difflineplus">+        /* if it has custom contribution logic, use it */</span>
<a href="#l11.2680"></a><span id="l11.2680">         if (objectNounDef.contributeObjDependencies(jsonValue,</span>
<a href="#l11.2681"></a><span id="l11.2681">                              aReferencesByNounID, aInverseReferencesByNounID)) {</span>
<a href="#l11.2682"></a><span id="l11.2682">           deps[attribId] = jsonValue;</span>
<a href="#l11.2683"></a><span id="l11.2683">           hasDeps = true;</span>
<a href="#l11.2684"></a><span id="l11.2684" class="difflineminus">-        }</span>
<a href="#l11.2685"></a><span id="l11.2685" class="difflineminus">-        else // just propagate the value, it's some form of simple sentinel</span>
<a href="#l11.2686"></a><span id="l11.2686" class="difflineplus">+        } else { // just propagate the value, it's some form of simple sentinel</span>
<a href="#l11.2687"></a><span id="l11.2687">           aItem[attrib.boundName] = jsonValue;</span>
<a href="#l11.2688"></a><span id="l11.2688" class="difflineminus">-      }</span>
<a href="#l11.2689"></a><span id="l11.2689" class="difflineminus">-      // otherwise, the value just needs to be de-persisted, or...</span>
<a href="#l11.2690"></a><span id="l11.2690" class="difflineminus">-      else if (objectNounDef.fromJSON) {</span>
<a href="#l11.2691"></a><span id="l11.2691" class="difflineplus">+        }</span>
<a href="#l11.2692"></a><span id="l11.2692" class="difflineplus">+      } else if (objectNounDef.fromJSON) {</span>
<a href="#l11.2693"></a><span id="l11.2693" class="difflineplus">+        // otherwise, the value just needs to be de-persisted, or...</span>
<a href="#l11.2694"></a><span id="l11.2694">         if (attrib.singular) {</span>
<a href="#l11.2695"></a><span id="l11.2695">           // For consistency with the non-singular case, we don't assign the</span>
<a href="#l11.2696"></a><span id="l11.2696">           //  attribute if undefined is returned.</span>
<a href="#l11.2697"></a><span id="l11.2697">           let deserialized = objectNounDef.fromJSON(jsonValue, aItem);</span>
<a href="#l11.2698"></a><span id="l11.2698">           if (deserialized !== undefined)</span>
<a href="#l11.2699"></a><span id="l11.2699">             aItem[attrib.boundName] = deserialized;</span>
<a href="#l11.2700"></a><span id="l11.2700" class="difflineminus">-        }</span>
<a href="#l11.2701"></a><span id="l11.2701" class="difflineminus">-        else {</span>
<a href="#l11.2702"></a><span id="l11.2702" class="difflineplus">+        } else {</span>
<a href="#l11.2703"></a><span id="l11.2703">           // Convert all the entries in the list filtering out any undefined</span>
<a href="#l11.2704"></a><span id="l11.2704">           //  values. (TagNoun will do this if the tag is now dead.)</span>
<a href="#l11.2705"></a><span id="l11.2705">           let outList = [];</span>
<a href="#l11.2706"></a><span id="l11.2706">           for (let key in jsonValue) {</span>
<a href="#l11.2707"></a><span id="l11.2707">             let val = jsonValue[key];</span>
<a href="#l11.2708"></a><span id="l11.2708">             let deserialized = objectNounDef.fromJSON(val, aItem);</span>
<a href="#l11.2709"></a><span id="l11.2709">             if (deserialized !== undefined)</span>
<a href="#l11.2710"></a><span id="l11.2710">               outList.push(deserialized);</span>
<a href="#l11.2711"></a><span id="l11.2711">           }</span>
<a href="#l11.2712"></a><span id="l11.2712">           // Note: It's possible if we filtered things out that this is an empty</span>
<a href="#l11.2713"></a><span id="l11.2713">           //  list.  This is acceptable because this is somewhat of an unusual</span>
<a href="#l11.2714"></a><span id="l11.2714">           //  case and I don't think we want to further complicate our</span>
<a href="#l11.2715"></a><span id="l11.2715">           //  semantics.</span>
<a href="#l11.2716"></a><span id="l11.2716">           aItem[attrib.boundName] = outList;</span>
<a href="#l11.2717"></a><span id="l11.2717">         }</span>
<a href="#l11.2718"></a><span id="l11.2718" class="difflineplus">+      } else { // it's fine as is</span>
<a href="#l11.2719"></a><span id="l11.2719" class="difflineplus">+        aItem[attrib.boundName] = jsonValue;</span>
<a href="#l11.2720"></a><span id="l11.2720">       }</span>
<a href="#l11.2721"></a><span id="l11.2721" class="difflineminus">-      // it's fine as is</span>
<a href="#l11.2722"></a><span id="l11.2722" class="difflineminus">-      else</span>
<a href="#l11.2723"></a><span id="l11.2723" class="difflineminus">-        aItem[attrib.boundName] = jsonValue;</span>
<a href="#l11.2724"></a><span id="l11.2724">     }</span>
<a href="#l11.2725"></a><span id="l11.2725"> </span>
<a href="#l11.2726"></a><span id="l11.2726">     if (hasDeps)</span>
<a href="#l11.2727"></a><span id="l11.2727">       aItem._deps = deps;</span>
<a href="#l11.2728"></a><span id="l11.2728">     return hasDeps;</span>
<a href="#l11.2729"></a><span id="l11.2729">   },</span>
<a href="#l11.2730"></a><span id="l11.2730" class="difflineminus">-</span>
<a href="#l11.2731"></a><span id="l11.2731" class="difflineminus">-  loadNounDeferredDeps: function gloda_ds_loadNounDeferredDeps(aItem,</span>
<a href="#l11.2732"></a><span id="l11.2732" class="difflineminus">-      aReferencesByNounID, aInverseReferencesByNounID) {</span>
<a href="#l11.2733"></a><span id="l11.2733" class="difflineplus">+  /* eslint-enable complexity */</span>
<a href="#l11.2734"></a><span id="l11.2734" class="difflineplus">+</span>
<a href="#l11.2735"></a><span id="l11.2735" class="difflineplus">+  loadNounDeferredDeps(aItem, aReferencesByNounID, aInverseReferencesByNounID) {</span>
<a href="#l11.2736"></a><span id="l11.2736">     if (aItem._deps === undefined)</span>
<a href="#l11.2737"></a><span id="l11.2737">       return;</span>
<a href="#l11.2738"></a><span id="l11.2738"> </span>
<a href="#l11.2739"></a><span id="l11.2739" class="difflineminus">-    //this._log.debug(&quot;  loading deferred, deps: &quot; +</span>
<a href="#l11.2740"></a><span id="l11.2740" class="difflineplus">+    // this._log.debug(&quot;  loading deferred, deps: &quot; +</span>
<a href="#l11.2741"></a><span id="l11.2741">     //    Log4Moz.enumerateProperties(aItem._deps).join(&quot;,&quot;));</span>
<a href="#l11.2742"></a><span id="l11.2742"> </span>
<a href="#l11.2743"></a><span id="l11.2743"> </span>
<a href="#l11.2744"></a><span id="l11.2744">     let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l11.2745"></a><span id="l11.2745"> </span>
<a href="#l11.2746"></a><span id="l11.2746">     for (let [attribId, jsonValue] of Object.entries(aItem._deps)) {</span>
<a href="#l11.2747"></a><span id="l11.2747">       let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l11.2748"></a><span id="l11.2748">       let attrib = dbAttrib.attrDef;</span>
<a href="#l11.2749"></a><span id="l11.2749"> </span>
<a href="#l11.2750"></a><span id="l11.2750">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l11.2751"></a><span id="l11.2751">       let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l11.2752"></a><span id="l11.2752">       if (attrib.special) {</span>
<a href="#l11.2753"></a><span id="l11.2753">         if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l11.2754"></a><span id="l11.2754">           let inverseReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l11.2755"></a><span id="l11.2755" class="difflineminus">-          //this._log.info(&quot;inverse assignment: &quot; + objectNounDef.id +</span>
<a href="#l11.2756"></a><span id="l11.2756" class="difflineplus">+          // this._log.info(&quot;inverse assignment: &quot; + objectNounDef.id +</span>
<a href="#l11.2757"></a><span id="l11.2757">           //    &quot; of &quot; + aItem.id)</span>
<a href="#l11.2758"></a><span id="l11.2758">           aItem[attrib.storageAttributeName] = inverseReferences[aItem.id];</span>
<a href="#l11.2759"></a><span id="l11.2759" class="difflineminus">-        }</span>
<a href="#l11.2760"></a><span id="l11.2760" class="difflineminus">-        else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l11.2761"></a><span id="l11.2761" class="difflineminus">-          //this._log.info(&quot;parent column load: &quot; + objectNounDef.id +</span>
<a href="#l11.2762"></a><span id="l11.2762" class="difflineplus">+        } else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l11.2763"></a><span id="l11.2763" class="difflineplus">+          // this._log.info(&quot;parent column load: &quot; + objectNounDef.id +</span>
<a href="#l11.2764"></a><span id="l11.2764">           //    &quot; storage value: &quot; + aItem[attrib.idStorageAttributeName]);</span>
<a href="#l11.2765"></a><span id="l11.2765">           aItem[attrib.valueStorageAttributeName] =</span>
<a href="#l11.2766"></a><span id="l11.2766">             references[aItem[attrib.idStorageAttributeName]];</span>
<a href="#l11.2767"></a><span id="l11.2767">         }</span>
<a href="#l11.2768"></a><span id="l11.2768" class="difflineminus">-      }</span>
<a href="#l11.2769"></a><span id="l11.2769" class="difflineminus">-      else if (objectNounDef.tableName) {</span>
<a href="#l11.2770"></a><span id="l11.2770" class="difflineminus">-        //this._log.info(&quot;trying to load: &quot; + objectNounDef.id + &quot; refs: &quot; +</span>
<a href="#l11.2771"></a><span id="l11.2771" class="difflineplus">+      } else if (objectNounDef.tableName) {</span>
<a href="#l11.2772"></a><span id="l11.2772" class="difflineplus">+        // this._log.info(&quot;trying to load: &quot; + objectNounDef.id + &quot; refs: &quot; +</span>
<a href="#l11.2773"></a><span id="l11.2773">         //    jsonValue + &quot;: &quot; + Log4Moz.enumerateProperties(jsonValue).join(&quot;,&quot;));</span>
<a href="#l11.2774"></a><span id="l11.2774">         if (attrib.singular)</span>
<a href="#l11.2775"></a><span id="l11.2775">           aItem[attrib.boundName] = references[jsonValue];</span>
<a href="#l11.2776"></a><span id="l11.2776">         else</span>
<a href="#l11.2777"></a><span id="l11.2777">           aItem[attrib.boundName] = Object.keys(jsonValue).</span>
<a href="#l11.2778"></a><span id="l11.2778">             map(key =&gt; references[jsonValue[key]]);</span>
<a href="#l11.2779"></a><span id="l11.2779" class="difflineminus">-      }</span>
<a href="#l11.2780"></a><span id="l11.2780" class="difflineminus">-      else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l11.2781"></a><span id="l11.2781" class="difflineplus">+      } else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l11.2782"></a><span id="l11.2782">         aItem[attrib.boundName] =</span>
<a href="#l11.2783"></a><span id="l11.2783">           objectNounDef.resolveObjDependencies(jsonValue, aReferencesByNounID,</span>
<a href="#l11.2784"></a><span id="l11.2784">             aInverseReferencesByNounID);</span>
<a href="#l11.2785"></a><span id="l11.2785">       }</span>
<a href="#l11.2786"></a><span id="l11.2786">       // there is no other case</span>
<a href="#l11.2787"></a><span id="l11.2787">     }</span>
<a href="#l11.2788"></a><span id="l11.2788"> </span>
<a href="#l11.2789"></a><span id="l11.2789">     delete aItem._deps;</span>
<a href="#l11.2790"></a><span id="l11.2790">   },</span>
<a href="#l11.2791"></a><span id="l11.2791"> </span>
<a href="#l11.2792"></a><span id="l11.2792">   /* ********** Contact ********** */</span>
<a href="#l11.2793"></a><span id="l11.2793">   _nextContactId: 1,</span>
<a href="#l11.2794"></a><span id="l11.2794"> </span>
<a href="#l11.2795"></a><span id="l11.2795" class="difflineminus">-  _populateContactManagedId: function () {</span>
<a href="#l11.2796"></a><span id="l11.2796" class="difflineplus">+  _populateContactManagedId() {</span>
<a href="#l11.2797"></a><span id="l11.2797">     let stmt = this._createSyncStatement(&quot;SELECT MAX(id) FROM contacts&quot;, true);</span>
<a href="#l11.2798"></a><span id="l11.2798">     if (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l11.2799"></a><span id="l11.2799">       this._nextContactId = stmt.getInt64(0) + 1;</span>
<a href="#l11.2800"></a><span id="l11.2800">     }</span>
<a href="#l11.2801"></a><span id="l11.2801">     stmt.finalize();</span>
<a href="#l11.2802"></a><span id="l11.2802">   },</span>
<a href="#l11.2803"></a><span id="l11.2803"> </span>
<a href="#l11.2804"></a><span id="l11.2804">   get _insertContactStatement() {</span>
<a href="#l11.2805"></a><span id="l11.2805">     let statement = this._createAsyncStatement(</span>
<a href="#l11.2806"></a><span id="l11.2806">       &quot;INSERT INTO contacts (id, directoryUUID, contactUUID, name, popularity,\</span>
<a href="#l11.2807"></a><span id="l11.2807">                              frecency, jsonAttributes) \</span>
<a href="#l11.2808"></a><span id="l11.2808">               VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)&quot;);</span>
<a href="#l11.2809"></a><span id="l11.2809">     this.__defineGetter__(&quot;_insertContactStatement&quot;, () =&gt; statement);</span>
<a href="#l11.2810"></a><span id="l11.2810">     return this._insertContactStatement;</span>
<a href="#l11.2811"></a><span id="l11.2811">   },</span>
<a href="#l11.2812"></a><span id="l11.2812"> </span>
<a href="#l11.2813"></a><span id="l11.2813" class="difflineminus">-  createContact: function gloda_ds_createContact(aDirectoryUUID, aContactUUID,</span>
<a href="#l11.2814"></a><span id="l11.2814" class="difflineminus">-      aName, aPopularity, aFrecency) {</span>
<a href="#l11.2815"></a><span id="l11.2815" class="difflineplus">+  createContact(aDirectoryUUID, aContactUUID, aName, aPopularity, aFrecency) {</span>
<a href="#l11.2816"></a><span id="l11.2816">     let contactID = this._nextContactId++;</span>
<a href="#l11.2817"></a><span id="l11.2817">     let contact = new GlodaContact(this, contactID,</span>
<a href="#l11.2818"></a><span id="l11.2818">                                    aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l11.2819"></a><span id="l11.2819">                                    aPopularity, aFrecency);</span>
<a href="#l11.2820"></a><span id="l11.2820">     return contact;</span>
<a href="#l11.2821"></a><span id="l11.2821">   },</span>
<a href="#l11.2822"></a><span id="l11.2822"> </span>
<a href="#l11.2823"></a><span id="l11.2823" class="difflineminus">-  insertContact: function gloda_ds_insertContact(aContact) {</span>
<a href="#l11.2824"></a><span id="l11.2824" class="difflineplus">+  insertContact(aContact) {</span>
<a href="#l11.2825"></a><span id="l11.2825">     let ics = this._insertContactStatement;</span>
<a href="#l11.2826"></a><span id="l11.2826">     ics.bindByIndex(0, aContact.id);</span>
<a href="#l11.2827"></a><span id="l11.2827">     if (aContact.directoryUUID == null)</span>
<a href="#l11.2828"></a><span id="l11.2828">       ics.bindByIndex(1, null);</span>
<a href="#l11.2829"></a><span id="l11.2829">     else</span>
<a href="#l11.2830"></a><span id="l11.2830">       ics.bindByIndex(1, aContact.directoryUUID);</span>
<a href="#l11.2831"></a><span id="l11.2831">     if (aContact.contactUUID == null)</span>
<a href="#l11.2832"></a><span id="l11.2832">       ics.bindByIndex(2, null);</span>
<a href="#l11.2833"></a><span id="l11.2833" class="difflineat">@@ -3808,33 +3718,33 @@ var GlodaDatastore = {</span>
<a href="#l11.2834"></a><span id="l11.2834">                            popularity = ?4, \</span>
<a href="#l11.2835"></a><span id="l11.2835">                            frecency = ?5, \</span>
<a href="#l11.2836"></a><span id="l11.2836">                            jsonAttributes = ?6 \</span>
<a href="#l11.2837"></a><span id="l11.2837">                        WHERE id = ?7&quot;);</span>
<a href="#l11.2838"></a><span id="l11.2838">     this.__defineGetter__(&quot;_updateContactStatement&quot;, () =&gt; statement);</span>
<a href="#l11.2839"></a><span id="l11.2839">     return this._updateContactStatement;</span>
<a href="#l11.2840"></a><span id="l11.2840">   },</span>
<a href="#l11.2841"></a><span id="l11.2841"> </span>
<a href="#l11.2842"></a><span id="l11.2842" class="difflineminus">-  updateContact: function gloda_ds_updateContact(aContact) {</span>
<a href="#l11.2843"></a><span id="l11.2843" class="difflineplus">+  updateContact(aContact) {</span>
<a href="#l11.2844"></a><span id="l11.2844">     let ucs = this._updateContactStatement;</span>
<a href="#l11.2845"></a><span id="l11.2845">     ucs.bindByIndex(6, aContact.id);</span>
<a href="#l11.2846"></a><span id="l11.2846">     ucs.bindByIndex(0, aContact.directoryUUID);</span>
<a href="#l11.2847"></a><span id="l11.2847">     ucs.bindByIndex(1, aContact.contactUUID);</span>
<a href="#l11.2848"></a><span id="l11.2848">     ucs.bindByIndex(2, aContact.name);</span>
<a href="#l11.2849"></a><span id="l11.2849">     ucs.bindByIndex(3, aContact.popularity);</span>
<a href="#l11.2850"></a><span id="l11.2850">     ucs.bindByIndex(4, aContact.frecency);</span>
<a href="#l11.2851"></a><span id="l11.2851">     if (aContact._jsonText)</span>
<a href="#l11.2852"></a><span id="l11.2852">       ucs.bindByIndex(5, aContact._jsonText);</span>
<a href="#l11.2853"></a><span id="l11.2853">     else</span>
<a href="#l11.2854"></a><span id="l11.2854">       ucs.bindByIndex(5, null);</span>
<a href="#l11.2855"></a><span id="l11.2855"> </span>
<a href="#l11.2856"></a><span id="l11.2856">     ucs.executeAsync(this.trackAsync());</span>
<a href="#l11.2857"></a><span id="l11.2857">   },</span>
<a href="#l11.2858"></a><span id="l11.2858"> </span>
<a href="#l11.2859"></a><span id="l11.2859" class="difflineminus">-  _contactFromRow: function gloda_ds_contactFromRow(aRow) {</span>
<a href="#l11.2860"></a><span id="l11.2860" class="difflineplus">+  _contactFromRow(aRow) {</span>
<a href="#l11.2861"></a><span id="l11.2861">     let directoryUUID, contactUUID, jsonText;</span>
<a href="#l11.2862"></a><span id="l11.2862">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.2863"></a><span id="l11.2863">       directoryUUID = null;</span>
<a href="#l11.2864"></a><span id="l11.2864">     else</span>
<a href="#l11.2865"></a><span id="l11.2865">       directoryUUID = aRow.getString(1);</span>
<a href="#l11.2866"></a><span id="l11.2866">     if (aRow.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l11.2867"></a><span id="l11.2867">       contactUUID = null;</span>
<a href="#l11.2868"></a><span id="l11.2868">     else</span>
<a href="#l11.2869"></a><span id="l11.2869" class="difflineat">@@ -3858,17 +3768,17 @@ var GlodaDatastore = {</span>
<a href="#l11.2870"></a><span id="l11.2870">   },</span>
<a href="#l11.2871"></a><span id="l11.2871"> </span>
<a href="#l11.2872"></a><span id="l11.2872">   /**</span>
<a href="#l11.2873"></a><span id="l11.2873">    * Synchronous contact lookup currently only for use by gloda's creation</span>
<a href="#l11.2874"></a><span id="l11.2874">    *  of the concept of &quot;me&quot;.  It is okay for it to be doing synchronous work</span>
<a href="#l11.2875"></a><span id="l11.2875">    *  because it is part of the startup process before any user code could</span>
<a href="#l11.2876"></a><span id="l11.2876">    *  have gotten a reference to Gloda, but no one else should do this.</span>
<a href="#l11.2877"></a><span id="l11.2877">    */</span>
<a href="#l11.2878"></a><span id="l11.2878" class="difflineminus">-  getContactByID: function gloda_ds_getContactByID(aContactID) {</span>
<a href="#l11.2879"></a><span id="l11.2879" class="difflineplus">+  getContactByID(aContactID) {</span>
<a href="#l11.2880"></a><span id="l11.2880">     let contact = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l11.2881"></a><span id="l11.2881">       GlodaContact.prototype.NOUN_ID, aContactID);</span>
<a href="#l11.2882"></a><span id="l11.2882"> </span>
<a href="#l11.2883"></a><span id="l11.2883">     if (contact === null) {</span>
<a href="#l11.2884"></a><span id="l11.2884">       let scbi = this._selectContactByIDStatement;</span>
<a href="#l11.2885"></a><span id="l11.2885">       scbi.bindByIndex(0, aContactID);</span>
<a href="#l11.2886"></a><span id="l11.2886">       if (this._syncStep(scbi)) {</span>
<a href="#l11.2887"></a><span id="l11.2887">         contact = this._contactFromRow(scbi);</span>
<a href="#l11.2888"></a><span id="l11.2888" class="difflineat">@@ -3878,36 +3788,34 @@ var GlodaDatastore = {</span>
<a href="#l11.2889"></a><span id="l11.2889">     }</span>
<a href="#l11.2890"></a><span id="l11.2890"> </span>
<a href="#l11.2891"></a><span id="l11.2891">     return contact;</span>
<a href="#l11.2892"></a><span id="l11.2892">   },</span>
<a href="#l11.2893"></a><span id="l11.2893"> </span>
<a href="#l11.2894"></a><span id="l11.2894">   /* ********** Identity ********** */</span>
<a href="#l11.2895"></a><span id="l11.2895">   /** next identity id, managed for async use reasons. */</span>
<a href="#l11.2896"></a><span id="l11.2896">   _nextIdentityId: 1,</span>
<a href="#l11.2897"></a><span id="l11.2897" class="difflineminus">-  _populateIdentityManagedId: function () {</span>
<a href="#l11.2898"></a><span id="l11.2898" class="difflineplus">+  _populateIdentityManagedId() {</span>
<a href="#l11.2899"></a><span id="l11.2899">     let stmt = this._createSyncStatement(</span>
<a href="#l11.2900"></a><span id="l11.2900">       &quot;SELECT MAX(id) FROM identities&quot;, true);</span>
<a href="#l11.2901"></a><span id="l11.2901">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l11.2902"></a><span id="l11.2902">       this._nextIdentityId = stmt.getInt64(0) + 1;</span>
<a href="#l11.2903"></a><span id="l11.2903">     }</span>
<a href="#l11.2904"></a><span id="l11.2904">     stmt.finalize();</span>
<a href="#l11.2905"></a><span id="l11.2905">   },</span>
<a href="#l11.2906"></a><span id="l11.2906"> </span>
<a href="#l11.2907"></a><span id="l11.2907">   get _insertIdentityStatement() {</span>
<a href="#l11.2908"></a><span id="l11.2908">     let statement = this._createAsyncStatement(</span>
<a href="#l11.2909"></a><span id="l11.2909">       &quot;INSERT INTO identities (id, contactID, kind, value, description, relay) \</span>
<a href="#l11.2910"></a><span id="l11.2910">               VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l11.2911"></a><span id="l11.2911">     this.__defineGetter__(&quot;_insertIdentityStatement&quot;, () =&gt; statement);</span>
<a href="#l11.2912"></a><span id="l11.2912">     return this._insertIdentityStatement;</span>
<a href="#l11.2913"></a><span id="l11.2913">   },</span>
<a href="#l11.2914"></a><span id="l11.2914"> </span>
<a href="#l11.2915"></a><span id="l11.2915" class="difflineminus">-  createIdentity: function gloda_ds_createIdentity(aContactID, aContact, aKind,</span>
<a href="#l11.2916"></a><span id="l11.2916" class="difflineminus">-                                                   aValue, aDescription,</span>
<a href="#l11.2917"></a><span id="l11.2917" class="difflineminus">-                                                   aIsRelay) {</span>
<a href="#l11.2918"></a><span id="l11.2918" class="difflineplus">+  createIdentity(aContactID, aContact, aKind, aValue, aDescription, aIsRelay) {</span>
<a href="#l11.2919"></a><span id="l11.2919">     let identityID = this._nextIdentityId++;</span>
<a href="#l11.2920"></a><span id="l11.2920">     let iis = this._insertIdentityStatement;</span>
<a href="#l11.2921"></a><span id="l11.2921">     iis.bindByIndex(0, identityID);</span>
<a href="#l11.2922"></a><span id="l11.2922">     iis.bindByIndex(1, aContactID);</span>
<a href="#l11.2923"></a><span id="l11.2923">     iis.bindByIndex(2, aKind);</span>
<a href="#l11.2924"></a><span id="l11.2924">     iis.bindByIndex(3, aValue);</span>
<a href="#l11.2925"></a><span id="l11.2925">     iis.bindByIndex(4, aDescription);</span>
<a href="#l11.2926"></a><span id="l11.2926">     iis.bindByIndex(5, aIsRelay ? 1 : 0);</span>
<a href="#l11.2927"></a><span id="l11.2927" class="difflineat">@@ -3927,49 +3835,49 @@ var GlodaDatastore = {</span>
<a href="#l11.2928"></a><span id="l11.2928">                              value = ?3, \</span>
<a href="#l11.2929"></a><span id="l11.2929">                              description = ?4, \</span>
<a href="#l11.2930"></a><span id="l11.2930">                              relay = ?5 \</span>
<a href="#l11.2931"></a><span id="l11.2931">                          WHERE id = ?6&quot;);</span>
<a href="#l11.2932"></a><span id="l11.2932">     this.__defineGetter__(&quot;_updateIdentityStatement&quot;, () =&gt; statement);</span>
<a href="#l11.2933"></a><span id="l11.2933">     return this._updateIdentityStatement;</span>
<a href="#l11.2934"></a><span id="l11.2934">   },</span>
<a href="#l11.2935"></a><span id="l11.2935"> </span>
<a href="#l11.2936"></a><span id="l11.2936" class="difflineminus">-  updateIdentity: function gloda_ds_updateIdentity(aIdentity) {</span>
<a href="#l11.2937"></a><span id="l11.2937" class="difflineplus">+  updateIdentity(aIdentity) {</span>
<a href="#l11.2938"></a><span id="l11.2938">     let ucs = this._updateIdentityStatement;</span>
<a href="#l11.2939"></a><span id="l11.2939">     ucs.bindByIndex(5, aIdentity.id);</span>
<a href="#l11.2940"></a><span id="l11.2940">     ucs.bindByIndex(0, aIdentity.contactID);</span>
<a href="#l11.2941"></a><span id="l11.2941">     ucs.bindByIndex(1, aIdentity.kind);</span>
<a href="#l11.2942"></a><span id="l11.2942">     ucs.bindByIndex(2, aIdentity.value);</span>
<a href="#l11.2943"></a><span id="l11.2943">     ucs.bindByIndex(3, aIdentity.description);</span>
<a href="#l11.2944"></a><span id="l11.2944">     ucs.bindByIndex(4, aIdentity.relay ? 1 : 0);</span>
<a href="#l11.2945"></a><span id="l11.2945"> </span>
<a href="#l11.2946"></a><span id="l11.2946">     ucs.executeAsync(this.trackAsync());</span>
<a href="#l11.2947"></a><span id="l11.2947">   },</span>
<a href="#l11.2948"></a><span id="l11.2948"> </span>
<a href="#l11.2949"></a><span id="l11.2949" class="difflineminus">-  _identityFromRow: function gloda_ds_identityFromRow(aRow) {</span>
<a href="#l11.2950"></a><span id="l11.2950" class="difflineplus">+  _identityFromRow(aRow) {</span>
<a href="#l11.2951"></a><span id="l11.2951">     return new GlodaIdentity(this, aRow.getInt64(0), aRow.getInt64(1), null,</span>
<a href="#l11.2952"></a><span id="l11.2952">                              aRow.getString(2), aRow.getString(3),</span>
<a href="#l11.2953"></a><span id="l11.2953">                              aRow.getString(4),</span>
<a href="#l11.2954"></a><span id="l11.2954" class="difflineminus">-                             aRow.getInt32(5) ? true : false);</span>
<a href="#l11.2955"></a><span id="l11.2955" class="difflineplus">+                             !!aRow.getInt32(5));</span>
<a href="#l11.2956"></a><span id="l11.2956">   },</span>
<a href="#l11.2957"></a><span id="l11.2957"> </span>
<a href="#l11.2958"></a><span id="l11.2958">   get _selectIdentityByKindValueStatement() {</span>
<a href="#l11.2959"></a><span id="l11.2959">     let statement = this._createSyncStatement(</span>
<a href="#l11.2960"></a><span id="l11.2960">       &quot;SELECT * FROM identities WHERE kind = ?1 AND value = ?2&quot;);</span>
<a href="#l11.2961"></a><span id="l11.2961">     this.__defineGetter__(&quot;_selectIdentityByKindValueStatement&quot;,</span>
<a href="#l11.2962"></a><span id="l11.2962">       () =&gt; statement);</span>
<a href="#l11.2963"></a><span id="l11.2963">     return this._selectIdentityByKindValueStatement;</span>
<a href="#l11.2964"></a><span id="l11.2964">   },</span>
<a href="#l11.2965"></a><span id="l11.2965"> </span>
<a href="#l11.2966"></a><span id="l11.2966">   /**</span>
<a href="#l11.2967"></a><span id="l11.2967">    * Synchronous lookup of an identity by kind and value, only for use by</span>
<a href="#l11.2968"></a><span id="l11.2968">    *  the legacy gloda core code that creates a concept of &quot;me&quot;.</span>
<a href="#l11.2969"></a><span id="l11.2969">    *  Ex: (email, foo@example.com)</span>
<a href="#l11.2970"></a><span id="l11.2970">    */</span>
<a href="#l11.2971"></a><span id="l11.2971" class="difflineminus">-  getIdentity: function gloda_ds_getIdentity(aKind, aValue) {</span>
<a href="#l11.2972"></a><span id="l11.2972" class="difflineplus">+  getIdentity(aKind, aValue) {</span>
<a href="#l11.2973"></a><span id="l11.2973">     let identity = GlodaCollectionManager.cacheLookupOneByUniqueValue(</span>
<a href="#l11.2974"></a><span id="l11.2974">       GlodaIdentity.prototype.NOUN_ID, aKind + &quot;@&quot; + aValue);</span>
<a href="#l11.2975"></a><span id="l11.2975"> </span>
<a href="#l11.2976"></a><span id="l11.2976">     let ibkv = this._selectIdentityByKindValueStatement;</span>
<a href="#l11.2977"></a><span id="l11.2977">     ibkv.bindByIndex(0, aKind);</span>
<a href="#l11.2978"></a><span id="l11.2978">     ibkv.bindByIndex(1, aValue);</span>
<a href="#l11.2979"></a><span id="l11.2979">     if (this._syncStep(ibkv)) {</span>
<a href="#l11.2980"></a><span id="l11.2980">       identity = this._identityFromRow(ibkv);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/db/gloda/modules/dbview.js</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/dbview.js</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -26,78 +26,74 @@ const {GlodaMsgSearcher} = ChromeUtils.i</span>
<a href="#l12.4"></a><span id="l12.4">  *     you want to display.</span>
<a href="#l12.5"></a><span id="l12.5">  */</span>
<a href="#l12.6"></a><span id="l12.6"> function GlodaSyntheticView(aArgs) {</span>
<a href="#l12.7"></a><span id="l12.7">   if (&quot;query&quot; in aArgs) {</span>
<a href="#l12.8"></a><span id="l12.8">     this.query = aArgs.query;</span>
<a href="#l12.9"></a><span id="l12.9">     this.collection = this.query.getCollection(this);</span>
<a href="#l12.10"></a><span id="l12.10">     this.completed = false;</span>
<a href="#l12.11"></a><span id="l12.11">     this.viewType = &quot;global&quot;;</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-  }</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineminus">-  else if (&quot;collection&quot; in aArgs) {</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineplus">+  } else if (&quot;collection&quot; in aArgs) {</span>
<a href="#l12.15"></a><span id="l12.15">     this.query = null;</span>
<a href="#l12.16"></a><span id="l12.16">     this.collection = aArgs.collection;</span>
<a href="#l12.17"></a><span id="l12.17">     this.completed = true;</span>
<a href="#l12.18"></a><span id="l12.18">     this.viewType = &quot;global&quot;;</span>
<a href="#l12.19"></a><span id="l12.19" class="difflineminus">-  }</span>
<a href="#l12.20"></a><span id="l12.20" class="difflineminus">-  else if (&quot;conversation&quot; in aArgs) {</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineplus">+  } else if (&quot;conversation&quot; in aArgs) {</span>
<a href="#l12.22"></a><span id="l12.22">     this.collection = aArgs.conversation.getMessagesCollection(this);</span>
<a href="#l12.23"></a><span id="l12.23">     this.query = this.collection.query;</span>
<a href="#l12.24"></a><span id="l12.24">     this.completed = false;</span>
<a href="#l12.25"></a><span id="l12.25">     this.viewType = &quot;conversation&quot;;</span>
<a href="#l12.26"></a><span id="l12.26" class="difflineminus">-  }</span>
<a href="#l12.27"></a><span id="l12.27" class="difflineminus">-  else {</span>
<a href="#l12.28"></a><span id="l12.28" class="difflineplus">+  } else {</span>
<a href="#l12.29"></a><span id="l12.29">     throw new Error(&quot;You need to pass a query or collection&quot;);</span>
<a href="#l12.30"></a><span id="l12.30">   }</span>
<a href="#l12.31"></a><span id="l12.31"> </span>
<a href="#l12.32"></a><span id="l12.32">   this.customColumns = [];</span>
<a href="#l12.33"></a><span id="l12.33"> }</span>
<a href="#l12.34"></a><span id="l12.34"> GlodaSyntheticView.prototype = {</span>
<a href="#l12.35"></a><span id="l12.35">   defaultSort: [[Ci.nsMsgViewSortType.byDate, Ci.nsMsgViewSortOrder.descending]],</span>
<a href="#l12.36"></a><span id="l12.36"> </span>
<a href="#l12.37"></a><span id="l12.37">   /**</span>
<a href="#l12.38"></a><span id="l12.38">    * Request the search be performed and notification provided to</span>
<a href="#l12.39"></a><span id="l12.39">    *  aSearchListener.  If results are already available, they should</span>
<a href="#l12.40"></a><span id="l12.40">    *  be provided to aSearchListener without re-performing the search.</span>
<a href="#l12.41"></a><span id="l12.41">    */</span>
<a href="#l12.42"></a><span id="l12.42" class="difflineminus">-  search: function(aSearchListener, aCompletionCallback) {</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineplus">+  search(aSearchListener, aCompletionCallback) {</span>
<a href="#l12.44"></a><span id="l12.44">     this.searchListener = aSearchListener;</span>
<a href="#l12.45"></a><span id="l12.45">     this.completionCallback = aCompletionCallback;</span>
<a href="#l12.46"></a><span id="l12.46"> </span>
<a href="#l12.47"></a><span id="l12.47">     this.searchListener.onNewSearch();</span>
<a href="#l12.48"></a><span id="l12.48">     if (this.completed) {</span>
<a href="#l12.49"></a><span id="l12.49">       this.reportResults(this.collection.items);</span>
<a href="#l12.50"></a><span id="l12.50">       // we're not really aborting, but it closes things out nicely</span>
<a href="#l12.51"></a><span id="l12.51">       this.abortSearch();</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineminus">-      return;</span>
<a href="#l12.53"></a><span id="l12.53">     }</span>
<a href="#l12.54"></a><span id="l12.54">   },</span>
<a href="#l12.55"></a><span id="l12.55"> </span>
<a href="#l12.56"></a><span id="l12.56" class="difflineminus">-  abortSearch: function() {</span>
<a href="#l12.57"></a><span id="l12.57" class="difflineplus">+  abortSearch() {</span>
<a href="#l12.58"></a><span id="l12.58">     if (this.searchListener)</span>
<a href="#l12.59"></a><span id="l12.59">       this.searchListener.onSearchDone(Cr.NS_OK);</span>
<a href="#l12.60"></a><span id="l12.60">     if (this.completionCallback)</span>
<a href="#l12.61"></a><span id="l12.61">       this.completionCallback();</span>
<a href="#l12.62"></a><span id="l12.62">     this.searchListener = null;</span>
<a href="#l12.63"></a><span id="l12.63">     this.completionCallback = null;</span>
<a href="#l12.64"></a><span id="l12.64">   },</span>
<a href="#l12.65"></a><span id="l12.65"> </span>
<a href="#l12.66"></a><span id="l12.66" class="difflineminus">-  reportResults: function(aItems) {</span>
<a href="#l12.67"></a><span id="l12.67" class="difflineplus">+  reportResults(aItems) {</span>
<a href="#l12.68"></a><span id="l12.68">     for (let item of aItems) {</span>
<a href="#l12.69"></a><span id="l12.69">       let hdr = item.folderMessage;</span>
<a href="#l12.70"></a><span id="l12.70">       if (hdr)</span>
<a href="#l12.71"></a><span id="l12.71">         this.searchListener.onSearchHit(hdr, hdr.folder);</span>
<a href="#l12.72"></a><span id="l12.72">     }</span>
<a href="#l12.73"></a><span id="l12.73">   },</span>
<a href="#l12.74"></a><span id="l12.74"> </span>
<a href="#l12.75"></a><span id="l12.75">   /**</span>
<a href="#l12.76"></a><span id="l12.76">    * Helper function used by |DBViewWrapper.getMsgHdrForMessageID| since there</span>
<a href="#l12.77"></a><span id="l12.77">    *  are no actual backing folders for it to check.</span>
<a href="#l12.78"></a><span id="l12.78">    */</span>
<a href="#l12.79"></a><span id="l12.79" class="difflineminus">-  getMsgHdrForMessageID: function(aMessageId) {</span>
<a href="#l12.80"></a><span id="l12.80" class="difflineplus">+  getMsgHdrForMessageID(aMessageId) {</span>
<a href="#l12.81"></a><span id="l12.81">     for (let item of this.collection.items) {</span>
<a href="#l12.82"></a><span id="l12.82">       if (item.headerMessageID == aMessageId) {</span>
<a href="#l12.83"></a><span id="l12.83">         let hdr = item.folderMessage;</span>
<a href="#l12.84"></a><span id="l12.84">         if (hdr)</span>
<a href="#l12.85"></a><span id="l12.85">           return hdr;</span>
<a href="#l12.86"></a><span id="l12.86">       }</span>
<a href="#l12.87"></a><span id="l12.87">     }</span>
<a href="#l12.88"></a><span id="l12.88">     return null;</span>
<a href="#l12.89"></a><span id="l12.89" class="difflineat">@@ -126,47 +122,45 @@ GlodaSyntheticView.prototype = {</span>
<a href="#l12.90"></a><span id="l12.90">       visible: true,</span>
<a href="#l12.91"></a><span id="l12.91">     },</span>
<a href="#l12.92"></a><span id="l12.92">     locationCol: {</span>
<a href="#l12.93"></a><span id="l12.93">       visible: true,</span>
<a href="#l12.94"></a><span id="l12.94">     },</span>
<a href="#l12.95"></a><span id="l12.95">   },</span>
<a href="#l12.96"></a><span id="l12.96"> </span>
<a href="#l12.97"></a><span id="l12.97">   // --- settings persistence</span>
<a href="#l12.98"></a><span id="l12.98" class="difflineminus">-  getPersistedSetting: function(aSetting) {</span>
<a href="#l12.99"></a><span id="l12.99" class="difflineplus">+  getPersistedSetting(aSetting) {</span>
<a href="#l12.100"></a><span id="l12.100">     try {</span>
<a href="#l12.101"></a><span id="l12.101">       return JSON.parse(Services.prefs.getCharPref(</span>
<a href="#l12.102"></a><span id="l12.102">         &quot;mailnews.database.global.views.&quot; + this.viewType + &quot;.&quot; + aSetting</span>
<a href="#l12.103"></a><span id="l12.103">       ));</span>
<a href="#l12.104"></a><span id="l12.104" class="difflineminus">-    }</span>
<a href="#l12.105"></a><span id="l12.105" class="difflineminus">-    catch (e) {</span>
<a href="#l12.106"></a><span id="l12.106" class="difflineplus">+    } catch (e) {</span>
<a href="#l12.107"></a><span id="l12.107">       return this.getDefaultSetting(aSetting);</span>
<a href="#l12.108"></a><span id="l12.108">     }</span>
<a href="#l12.109"></a><span id="l12.109">   },</span>
<a href="#l12.110"></a><span id="l12.110" class="difflineminus">-  setPersistedSetting: function(aSetting, aValue) {</span>
<a href="#l12.111"></a><span id="l12.111" class="difflineplus">+  setPersistedSetting(aSetting, aValue) {</span>
<a href="#l12.112"></a><span id="l12.112">     Services.prefs.setCharPref(</span>
<a href="#l12.113"></a><span id="l12.113">       &quot;mailnews.database.global.views.&quot; + this.viewType + &quot;.&quot; + aSetting,</span>
<a href="#l12.114"></a><span id="l12.114">       JSON.stringify(aValue)</span>
<a href="#l12.115"></a><span id="l12.115">     );</span>
<a href="#l12.116"></a><span id="l12.116">   },</span>
<a href="#l12.117"></a><span id="l12.117" class="difflineminus">-  getDefaultSetting: function(aSetting) {</span>
<a href="#l12.118"></a><span id="l12.118" class="difflineplus">+  getDefaultSetting(aSetting) {</span>
<a href="#l12.119"></a><span id="l12.119">     if (aSetting == &quot;columns&quot;)</span>
<a href="#l12.120"></a><span id="l12.120">       return this.DEFAULT_COLUMN_STATES;</span>
<a href="#l12.121"></a><span id="l12.121" class="difflineminus">-    else</span>
<a href="#l12.122"></a><span id="l12.122" class="difflineminus">-      return undefined;</span>
<a href="#l12.123"></a><span id="l12.123" class="difflineplus">+    return undefined;</span>
<a href="#l12.124"></a><span id="l12.124">   },</span>
<a href="#l12.125"></a><span id="l12.125"> </span>
<a href="#l12.126"></a><span id="l12.126">   // --- collection listener</span>
<a href="#l12.127"></a><span id="l12.127" class="difflineminus">-  onItemsAdded: function(aItems, aCollection) {</span>
<a href="#l12.128"></a><span id="l12.128" class="difflineplus">+  onItemsAdded(aItems, aCollection) {</span>
<a href="#l12.129"></a><span id="l12.129">     if (this.searchListener)</span>
<a href="#l12.130"></a><span id="l12.130">       this.reportResults(aItems);</span>
<a href="#l12.131"></a><span id="l12.131">   },</span>
<a href="#l12.132"></a><span id="l12.132" class="difflineminus">-  onItemsModified: function(aItems, aCollection) {</span>
<a href="#l12.133"></a><span id="l12.133" class="difflineplus">+  onItemsModified(aItems, aCollection) {</span>
<a href="#l12.134"></a><span id="l12.134">   },</span>
<a href="#l12.135"></a><span id="l12.135" class="difflineminus">-  onItemsRemoved: function(aItems, aCollection) {</span>
<a href="#l12.136"></a><span id="l12.136" class="difflineplus">+  onItemsRemoved(aItems, aCollection) {</span>
<a href="#l12.137"></a><span id="l12.137">   },</span>
<a href="#l12.138"></a><span id="l12.138" class="difflineminus">-  onQueryCompleted: function(aCollection) {</span>
<a href="#l12.139"></a><span id="l12.139" class="difflineplus">+  onQueryCompleted(aCollection) {</span>
<a href="#l12.140"></a><span id="l12.140">     this.completed = true;</span>
<a href="#l12.141"></a><span id="l12.141">     this.searchListener.onSearchDone(Cr.NS_OK);</span>
<a href="#l12.142"></a><span id="l12.142">     if (this.completionCallback)</span>
<a href="#l12.143"></a><span id="l12.143">       this.completionCallback();</span>
<a href="#l12.144"></a><span id="l12.144">   },</span>
<a href="#l12.145"></a><span id="l12.145"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/db/gloda/modules/explattr.js</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/explattr.js</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -4,17 +4,17 @@</span>
<a href="#l13.4"></a><span id="l13.4"> </span>
<a href="#l13.5"></a><span id="l13.5"> /*</span>
<a href="#l13.6"></a><span id="l13.6">  * This file provides the &quot;explicit attribute&quot; provider for messages.  It is</span>
<a href="#l13.7"></a><span id="l13.7">  *  concerned with attributes that are the result of user actions.  For example,</span>
<a href="#l13.8"></a><span id="l13.8">  *  whether a message is starred (flagged), message tags, whether it is</span>
<a href="#l13.9"></a><span id="l13.9">  *  read/unread, etc.</span>
<a href="#l13.10"></a><span id="l13.10">  */</span>
<a href="#l13.11"></a><span id="l13.11"> </span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-this.EXPORTED_SYMBOLS = ['GlodaExplicitAttr'];</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;GlodaExplicitAttr&quot;];</span>
<a href="#l13.14"></a><span id="l13.14"> </span>
<a href="#l13.15"></a><span id="l13.15"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l13.16"></a><span id="l13.16"> const {StringBundle} = ChromeUtils.import(&quot;resource:///modules/StringBundle.js&quot;);</span>
<a href="#l13.17"></a><span id="l13.17"> </span>
<a href="#l13.18"></a><span id="l13.18"> const {GlodaUtils} = ChromeUtils.import(&quot;resource:///modules/gloda/utils.js&quot;);</span>
<a href="#l13.19"></a><span id="l13.19"> const {Gloda} = ChromeUtils.import(&quot;resource:///modules/gloda/gloda.js&quot;);</span>
<a href="#l13.20"></a><span id="l13.20"> const {TagNoun} = ChromeUtils.import(&quot;resource:///modules/gloda/noun_tag.js&quot;);</span>
<a href="#l13.21"></a><span id="l13.21"> const {MailServices} = ChromeUtils.import(&quot;resource:///modules/MailServices.jsm&quot;);</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineat">@@ -27,38 +27,37 @@ var EXT_BUILTIN = &quot;built-in&quot;;</span>
<a href="#l13.23"></a><span id="l13.23">  *  message as read.</span>
<a href="#l13.24"></a><span id="l13.24">  */</span>
<a href="#l13.25"></a><span id="l13.25"> var GlodaExplicitAttr = {</span>
<a href="#l13.26"></a><span id="l13.26">   providerName: &quot;gloda.explattr&quot;,</span>
<a href="#l13.27"></a><span id="l13.27">   strings: new StringBundle(&quot;chrome://messenger/locale/gloda.properties&quot;),</span>
<a href="#l13.28"></a><span id="l13.28">   _log: null,</span>
<a href="#l13.29"></a><span id="l13.29">   _msgTagService: null,</span>
<a href="#l13.30"></a><span id="l13.30"> </span>
<a href="#l13.31"></a><span id="l13.31" class="difflineminus">-  init: function gloda_explattr_init() {</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+  init() {</span>
<a href="#l13.33"></a><span id="l13.33">     this._log =  Log4Moz.repository.getLogger(&quot;gloda.explattr&quot;);</span>
<a href="#l13.34"></a><span id="l13.34"> </span>
<a href="#l13.35"></a><span id="l13.35">     this._msgTagService = MailServices.tags;</span>
<a href="#l13.36"></a><span id="l13.36"> </span>
<a href="#l13.37"></a><span id="l13.37">     try {</span>
<a href="#l13.38"></a><span id="l13.38">       this.defineAttributes();</span>
<a href="#l13.39"></a><span id="l13.39" class="difflineminus">-    }</span>
<a href="#l13.40"></a><span id="l13.40" class="difflineminus">-    catch (ex) {</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineplus">+    } catch (ex) {</span>
<a href="#l13.42"></a><span id="l13.42">       this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l13.43"></a><span id="l13.43">       throw ex;</span>
<a href="#l13.44"></a><span id="l13.44">     }</span>
<a href="#l13.45"></a><span id="l13.45">   },</span>
<a href="#l13.46"></a><span id="l13.46"> </span>
<a href="#l13.47"></a><span id="l13.47">   /** Boost for starred messages. */</span>
<a href="#l13.48"></a><span id="l13.48">   NOTABILITY_STARRED: 16,</span>
<a href="#l13.49"></a><span id="l13.49">   /** Boost for tagged messages, first tag. */</span>
<a href="#l13.50"></a><span id="l13.50">   NOTABILITY_TAGGED_FIRST: 8,</span>
<a href="#l13.51"></a><span id="l13.51">   /** Boost for tagged messages, each additional tag. */</span>
<a href="#l13.52"></a><span id="l13.52">   NOTABILITY_TAGGED_ADDL: 1,</span>
<a href="#l13.53"></a><span id="l13.53"> </span>
<a href="#l13.54"></a><span id="l13.54" class="difflineminus">-  defineAttributes: function() {</span>
<a href="#l13.55"></a><span id="l13.55" class="difflineplus">+  defineAttributes() {</span>
<a href="#l13.56"></a><span id="l13.56">     // Tag</span>
<a href="#l13.57"></a><span id="l13.57">     this._attrTag = Gloda.defineAttribute({</span>
<a href="#l13.58"></a><span id="l13.58">                         provider: this,</span>
<a href="#l13.59"></a><span id="l13.59">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l13.60"></a><span id="l13.60">                         attributeType: Gloda.kAttrExplicit,</span>
<a href="#l13.61"></a><span id="l13.61">                         attributeName: &quot;tag&quot;,</span>
<a href="#l13.62"></a><span id="l13.62">                         bindName: &quot;tags&quot;,</span>
<a href="#l13.63"></a><span id="l13.63">                         singular: false,</span>
<a href="#l13.64"></a><span id="l13.64" class="difflineat">@@ -120,18 +119,17 @@ var GlodaExplicitAttr = {</span>
<a href="#l13.65"></a><span id="l13.65">       attributeName: &quot;forwarded&quot;,</span>
<a href="#l13.66"></a><span id="l13.66">       singular: true,</span>
<a href="#l13.67"></a><span id="l13.67">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l13.68"></a><span id="l13.68">       objectNoun: Gloda.NOUN_BOOLEAN,</span>
<a href="#l13.69"></a><span id="l13.69">       parameterNoun: null,</span>
<a href="#l13.70"></a><span id="l13.70">     }); // tested-by: test_attributes_explicit</span>
<a href="#l13.71"></a><span id="l13.71">   },</span>
<a href="#l13.72"></a><span id="l13.72"> </span>
<a href="#l13.73"></a><span id="l13.73" class="difflineminus">-  process: function* Gloda_explattr_process(aGlodaMessage, aRawReps, aIsNew,</span>
<a href="#l13.74"></a><span id="l13.74" class="difflineminus">-                                            aCallbackHandle) {</span>
<a href="#l13.75"></a><span id="l13.75" class="difflineplus">+  * process(aGlodaMessage, aRawReps, aIsNew, aCallbackHandle) {</span>
<a href="#l13.76"></a><span id="l13.76">     let aMsgHdr = aRawReps.header;</span>
<a href="#l13.77"></a><span id="l13.77"> </span>
<a href="#l13.78"></a><span id="l13.78">     aGlodaMessage.starred = aMsgHdr.isFlagged;</span>
<a href="#l13.79"></a><span id="l13.79">     if (aGlodaMessage.starred)</span>
<a href="#l13.80"></a><span id="l13.80">       aGlodaMessage.notability += this.NOTABILITY_STARRED;</span>
<a href="#l13.81"></a><span id="l13.81"> </span>
<a href="#l13.82"></a><span id="l13.82">     aGlodaMessage.read = aMsgHdr.isRead;</span>
<a href="#l13.83"></a><span id="l13.83"> </span>
<a href="#l13.84"></a><span id="l13.84" class="difflineat">@@ -139,17 +137,17 @@ var GlodaExplicitAttr = {</span>
<a href="#l13.85"></a><span id="l13.85">     aGlodaMessage.repliedTo = Boolean(flags &amp; Ci.nsMsgMessageFlags.Replied);</span>
<a href="#l13.86"></a><span id="l13.86">     aGlodaMessage.forwarded = Boolean(flags &amp; Ci.nsMsgMessageFlags.Forwarded);</span>
<a href="#l13.87"></a><span id="l13.87"> </span>
<a href="#l13.88"></a><span id="l13.88">     let tags = aGlodaMessage.tags = [];</span>
<a href="#l13.89"></a><span id="l13.89"> </span>
<a href="#l13.90"></a><span id="l13.90">     // -- Tag</span>
<a href="#l13.91"></a><span id="l13.91">     // build a map of the keywords</span>
<a href="#l13.92"></a><span id="l13.92">     let keywords = aMsgHdr.getStringProperty(&quot;keywords&quot;);</span>
<a href="#l13.93"></a><span id="l13.93" class="difflineminus">-    let keywordList = keywords.split(' ');</span>
<a href="#l13.94"></a><span id="l13.94" class="difflineplus">+    let keywordList = keywords.split(&quot; &quot;);</span>
<a href="#l13.95"></a><span id="l13.95">     let keywordMap = {};</span>
<a href="#l13.96"></a><span id="l13.96">     for (let iKeyword = 0; iKeyword &lt; keywordList.length; iKeyword++) {</span>
<a href="#l13.97"></a><span id="l13.97">       let keyword = keywordList[iKeyword];</span>
<a href="#l13.98"></a><span id="l13.98">       keywordMap[keyword] = true;</span>
<a href="#l13.99"></a><span id="l13.99">     }</span>
<a href="#l13.100"></a><span id="l13.100"> </span>
<a href="#l13.101"></a><span id="l13.101">     let tagArray = TagNoun.getAllTags();</span>
<a href="#l13.102"></a><span id="l13.102">     for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l13.103"></a><span id="l13.103" class="difflineat">@@ -165,17 +163,17 @@ var GlodaExplicitAttr = {</span>
<a href="#l13.104"></a><span id="l13.104">     yield Gloda.kWorkDone;</span>
<a href="#l13.105"></a><span id="l13.105">   },</span>
<a href="#l13.106"></a><span id="l13.106"> </span>
<a href="#l13.107"></a><span id="l13.107">   /**</span>
<a href="#l13.108"></a><span id="l13.108">    * Duplicates the notability logic from process().  Arguably process should</span>
<a href="#l13.109"></a><span id="l13.109">    *  be factored to call us, grokNounItem should be factored to call us, or we</span>
<a href="#l13.110"></a><span id="l13.110">    *  should get sufficiently fancy that our code wildly diverges.</span>
<a href="#l13.111"></a><span id="l13.111">    */</span>
<a href="#l13.112"></a><span id="l13.112" class="difflineminus">-  score: function Gloda_explattr_score(aMessage, aContext) {</span>
<a href="#l13.113"></a><span id="l13.113" class="difflineplus">+  score(aMessage, aContext) {</span>
<a href="#l13.114"></a><span id="l13.114">     let score = 0;</span>
<a href="#l13.115"></a><span id="l13.115">     if (aMessage.starred)</span>
<a href="#l13.116"></a><span id="l13.116">       score += this.NOTABILITY_STARRED;</span>
<a href="#l13.117"></a><span id="l13.117">     if (aMessage.tags.length)</span>
<a href="#l13.118"></a><span id="l13.118">       score += this.NOTABILITY_TAGGED_FIRST +</span>
<a href="#l13.119"></a><span id="l13.119">         (aMessage.tags.length - 1) * this.NOTABILITY_TAGGED_ADDL;</span>
<a href="#l13.120"></a><span id="l13.120">     return score;</span>
<a href="#l13.121"></a><span id="l13.121">   },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/db/gloda/modules/facet.js</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/facet.js</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -27,33 +27,31 @@ function FacetDriver(aNounDef, aWindow) </span>
<a href="#l14.4"></a><span id="l14.4"> </span>
<a href="#l14.5"></a><span id="l14.5">   this._makeFaceters();</span>
<a href="#l14.6"></a><span id="l14.6"> }</span>
<a href="#l14.7"></a><span id="l14.7"> FacetDriver.prototype = {</span>
<a href="#l14.8"></a><span id="l14.8">   /**</span>
<a href="#l14.9"></a><span id="l14.9">    * Populate |this.faceters| with a set of faceters appropriate to the noun</span>
<a href="#l14.10"></a><span id="l14.10">    *  definition associated with this instance.</span>
<a href="#l14.11"></a><span id="l14.11">    */</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-  _makeFaceters: function() {</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+  _makeFaceters() {</span>
<a href="#l14.14"></a><span id="l14.14">     let faceters = this.faceters = [];</span>
<a href="#l14.15"></a><span id="l14.15"> </span>
<a href="#l14.16"></a><span id="l14.16">     function makeFaceter(aAttrDef, aFacetDef) {</span>
<a href="#l14.17"></a><span id="l14.17">       let facetType = aFacetDef.type;</span>
<a href="#l14.18"></a><span id="l14.18"> </span>
<a href="#l14.19"></a><span id="l14.19">       if (aAttrDef.singular) {</span>
<a href="#l14.20"></a><span id="l14.20">         if (facetType == &quot;date&quot;)</span>
<a href="#l14.21"></a><span id="l14.21">           faceters.push(new DateFaceter(aAttrDef, aFacetDef));</span>
<a href="#l14.22"></a><span id="l14.22">         else</span>
<a href="#l14.23"></a><span id="l14.23">           faceters.push(new DiscreteFaceter(aAttrDef, aFacetDef));</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineminus">-      }</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineminus">-      else {</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineminus">-        if (facetType == &quot;nonempty?&quot;)</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineminus">-          faceters.push(new NonEmptySetFaceter(aAttrDef, aFacetDef));</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineminus">-        else</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineminus">-          faceters.push(new DiscreteSetFaceter(aAttrDef, aFacetDef));</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+      } else if (facetType == &quot;nonempty?&quot;) {</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineplus">+        faceters.push(new NonEmptySetFaceter(aAttrDef, aFacetDef));</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+      } else {</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+        faceters.push(new DiscreteSetFaceter(aAttrDef, aFacetDef));</span>
<a href="#l14.34"></a><span id="l14.34">       }</span>
<a href="#l14.35"></a><span id="l14.35">     }</span>
<a href="#l14.36"></a><span id="l14.36"> </span>
<a href="#l14.37"></a><span id="l14.37">     for (let key in this.nounDef.attribsByBoundName) {</span>
<a href="#l14.38"></a><span id="l14.38">       let attrDef = this.nounDef.attribsByBoundName[key];</span>
<a href="#l14.39"></a><span id="l14.39">       // ignore attributes that do not want to be faceted</span>
<a href="#l14.40"></a><span id="l14.40">       if (!attrDef.facet)</span>
<a href="#l14.41"></a><span id="l14.41">         continue;</span>
<a href="#l14.42"></a><span id="l14.42" class="difflineat">@@ -66,31 +64,31 @@ FacetDriver.prototype = {</span>
<a href="#l14.43"></a><span id="l14.43">         }</span>
<a href="#l14.44"></a><span id="l14.44">       }</span>
<a href="#l14.45"></a><span id="l14.45">     }</span>
<a href="#l14.46"></a><span id="l14.46">   },</span>
<a href="#l14.47"></a><span id="l14.47">   /**</span>
<a href="#l14.48"></a><span id="l14.48">    * Asynchronously facet the provided items, calling the provided callback when</span>
<a href="#l14.49"></a><span id="l14.49">    *  completed.</span>
<a href="#l14.50"></a><span id="l14.50">    */</span>
<a href="#l14.51"></a><span id="l14.51" class="difflineminus">-  go: function FacetDriver_go(aItems, aCallback, aCallbackThis) {</span>
<a href="#l14.52"></a><span id="l14.52" class="difflineplus">+  go(aItems, aCallback, aCallbackThis) {</span>
<a href="#l14.53"></a><span id="l14.53">     this.items = aItems;</span>
<a href="#l14.54"></a><span id="l14.54">     this.callback = aCallback;</span>
<a href="#l14.55"></a><span id="l14.55">     this.callbackThis = aCallbackThis;</span>
<a href="#l14.56"></a><span id="l14.56"> </span>
<a href="#l14.57"></a><span id="l14.57">     this._nextFaceter = 0;</span>
<a href="#l14.58"></a><span id="l14.58">     this._drive();</span>
<a href="#l14.59"></a><span id="l14.59">   },</span>
<a href="#l14.60"></a><span id="l14.60"> </span>
<a href="#l14.61"></a><span id="l14.61">   _MAX_FACETING_TIMESLICE_MS: 100,</span>
<a href="#l14.62"></a><span id="l14.62">   _FACETING_YIELD_DURATION_MS: 0,</span>
<a href="#l14.63"></a><span id="l14.63" class="difflineminus">-  _driveWrapper: function(aThis) {</span>
<a href="#l14.64"></a><span id="l14.64" class="difflineplus">+  _driveWrapper(aThis) {</span>
<a href="#l14.65"></a><span id="l14.65">     aThis._drive();</span>
<a href="#l14.66"></a><span id="l14.66">   },</span>
<a href="#l14.67"></a><span id="l14.67" class="difflineminus">-  _drive: function() {</span>
<a href="#l14.68"></a><span id="l14.68" class="difflineplus">+  _drive() {</span>
<a href="#l14.69"></a><span id="l14.69">     let start = Date.now();</span>
<a href="#l14.70"></a><span id="l14.70"> </span>
<a href="#l14.71"></a><span id="l14.71">     while (this._nextFaceter &lt; this.faceters.length) {</span>
<a href="#l14.72"></a><span id="l14.72">       let faceter = this.faceters[this._nextFaceter++];</span>
<a href="#l14.73"></a><span id="l14.73">       // for now we facet in one go, but the long-term plan allows for them to</span>
<a href="#l14.74"></a><span id="l14.74">       //  be generators.</span>
<a href="#l14.75"></a><span id="l14.75">       faceter.facetItems(this.items);</span>
<a href="#l14.76"></a><span id="l14.76"> </span>
<a href="#l14.77"></a><span id="l14.77" class="difflineat">@@ -100,82 +98,79 @@ FacetDriver.prototype = {</span>
<a href="#l14.78"></a><span id="l14.78">                                 this._FACETING_YIELD_DURATION_MS,</span>
<a href="#l14.79"></a><span id="l14.79">                                 this);</span>
<a href="#l14.80"></a><span id="l14.80">         return;</span>
<a href="#l14.81"></a><span id="l14.81">       }</span>
<a href="#l14.82"></a><span id="l14.82">     }</span>
<a href="#l14.83"></a><span id="l14.83"> </span>
<a href="#l14.84"></a><span id="l14.84">     // we only get here once we are done with the faceters</span>
<a href="#l14.85"></a><span id="l14.85">     this.callback.call(this.callbackThis);</span>
<a href="#l14.86"></a><span id="l14.86" class="difflineminus">-  }</span>
<a href="#l14.87"></a><span id="l14.87" class="difflineplus">+  },</span>
<a href="#l14.88"></a><span id="l14.88"> };</span>
<a href="#l14.89"></a><span id="l14.89"> </span>
<a href="#l14.90"></a><span id="l14.90"> var FacetUtils = {</span>
<a href="#l14.91"></a><span id="l14.91" class="difflineminus">-  _groupSizeComparator: function(a, b) {</span>
<a href="#l14.92"></a><span id="l14.92" class="difflineplus">+  _groupSizeComparator(a, b) {</span>
<a href="#l14.93"></a><span id="l14.93">     return b[1].length - a[1].length;</span>
<a href="#l14.94"></a><span id="l14.94">   },</span>
<a href="#l14.95"></a><span id="l14.95"> </span>
<a href="#l14.96"></a><span id="l14.96">   /**</span>
<a href="#l14.97"></a><span id="l14.97">    * Given a list where each entry is a tuple of [group object, list of items</span>
<a href="#l14.98"></a><span id="l14.98">    *  belonging to that group], produce a new list of the top grouped items.  We</span>
<a href="#l14.99"></a><span id="l14.99">    *  used to also produce an &quot;other&quot; aggregation, but that turned out to be</span>
<a href="#l14.100"></a><span id="l14.100">    *  conceptually difficult to deal with, so that's gone, leaving this method</span>
<a href="#l14.101"></a><span id="l14.101">    *  with much less to do.</span>
<a href="#l14.102"></a><span id="l14.102">    *</span>
<a href="#l14.103"></a><span id="l14.103">    * @param aAttrDef The attribute for the facet we are working with.</span>
<a href="#l14.104"></a><span id="l14.104">    * @param aGroups The list of groups built for the facet.</span>
<a href="#l14.105"></a><span id="l14.105">    * @param aMaxCount The number of result rows you want back.</span>
<a href="#l14.106"></a><span id="l14.106">    */</span>
<a href="#l14.107"></a><span id="l14.107" class="difflineminus">-  makeTopGroups: function FacetUtils_makeTopGroups(aAttrDef, aGroups,</span>
<a href="#l14.108"></a><span id="l14.108" class="difflineminus">-                                                   aMaxCount) {</span>
<a href="#l14.109"></a><span id="l14.109" class="difflineplus">+  makeTopGroups(aAttrDef, aGroups, aMaxCount) {</span>
<a href="#l14.110"></a><span id="l14.110">     let nounDef = aAttrDef.objectNounDef;</span>
<a href="#l14.111"></a><span id="l14.111">     let realGroupsToUse = aMaxCount;</span>
<a href="#l14.112"></a><span id="l14.112"> </span>
<a href="#l14.113"></a><span id="l14.113">     let orderedBySize = aGroups.concat();</span>
<a href="#l14.114"></a><span id="l14.114">     orderedBySize.sort(this._groupSizeComparator);</span>
<a href="#l14.115"></a><span id="l14.115"> </span>
<a href="#l14.116"></a><span id="l14.116">     // - get the real groups to use and order them by the attribute comparator</span>
<a href="#l14.117"></a><span id="l14.117">     let outGroups = orderedBySize.slice(0, realGroupsToUse);</span>
<a href="#l14.118"></a><span id="l14.118">     let comparator = nounDef.comparator;</span>
<a href="#l14.119"></a><span id="l14.119">     function comparatorHelper(a, b) {</span>
<a href="#l14.120"></a><span id="l14.120">       return comparator(a[0], b[0]);</span>
<a href="#l14.121"></a><span id="l14.121">     }</span>
<a href="#l14.122"></a><span id="l14.122">     outGroups.sort(comparatorHelper);</span>
<a href="#l14.123"></a><span id="l14.123"> </span>
<a href="#l14.124"></a><span id="l14.124">     return outGroups;</span>
<a href="#l14.125"></a><span id="l14.125" class="difflineminus">-  }</span>
<a href="#l14.126"></a><span id="l14.126" class="difflineplus">+  },</span>
<a href="#l14.127"></a><span id="l14.127"> };</span>
<a href="#l14.128"></a><span id="l14.128"> </span>
<a href="#l14.129"></a><span id="l14.129"> /**</span>
<a href="#l14.130"></a><span id="l14.130">  * Facet discrete things like message authors, boolean values, etc.  Only</span>
<a href="#l14.131"></a><span id="l14.131">  *  appropriate for use on singular values.  Use |DiscreteSetFaceter| for</span>
<a href="#l14.132"></a><span id="l14.132">  *  non-singular values.</span>
<a href="#l14.133"></a><span id="l14.133">  */</span>
<a href="#l14.134"></a><span id="l14.134"> function DiscreteFaceter(aAttrDef, aFacetDef) {</span>
<a href="#l14.135"></a><span id="l14.135">   this.attrDef = aAttrDef;</span>
<a href="#l14.136"></a><span id="l14.136">   this.facetDef = aFacetDef;</span>
<a href="#l14.137"></a><span id="l14.137"> }</span>
<a href="#l14.138"></a><span id="l14.138"> DiscreteFaceter.prototype = {</span>
<a href="#l14.139"></a><span id="l14.139">   type: &quot;discrete&quot;,</span>
<a href="#l14.140"></a><span id="l14.140">   /**</span>
<a href="#l14.141"></a><span id="l14.141">    * Facet the given set of items, deferring to the appropriate helper method</span>
<a href="#l14.142"></a><span id="l14.142">    */</span>
<a href="#l14.143"></a><span id="l14.143" class="difflineminus">-  facetItems: function(aItems) {</span>
<a href="#l14.144"></a><span id="l14.144" class="difflineplus">+  facetItems(aItems) {</span>
<a href="#l14.145"></a><span id="l14.145">     if (this.attrDef.objectNounDef.isPrimitive)</span>
<a href="#l14.146"></a><span id="l14.146">       return this.facetPrimitiveItems(aItems);</span>
<a href="#l14.147"></a><span id="l14.147" class="difflineminus">-    else</span>
<a href="#l14.148"></a><span id="l14.148" class="difflineminus">-      return this.facetComplexItems(aItems);</span>
<a href="#l14.149"></a><span id="l14.149" class="difflineplus">+    return this.facetComplexItems(aItems);</span>
<a href="#l14.150"></a><span id="l14.150">   },</span>
<a href="#l14.151"></a><span id="l14.151">   /**</span>
<a href="#l14.152"></a><span id="l14.152">    * Facet an attribute whose value is primitive, meaning that it is a raw</span>
<a href="#l14.153"></a><span id="l14.153">    *  numeric value or string, rather than a complex object.</span>
<a href="#l14.154"></a><span id="l14.154">    */</span>
<a href="#l14.155"></a><span id="l14.155" class="difflineminus">-  facetPrimitiveItems: function(aItems) {</span>
<a href="#l14.156"></a><span id="l14.156" class="difflineplus">+  facetPrimitiveItems(aItems) {</span>
<a href="#l14.157"></a><span id="l14.157">     let attrKey = this.attrDef.boundName;</span>
<a href="#l14.158"></a><span id="l14.158" class="difflineminus">-    let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l14.159"></a><span id="l14.159">     let filter = this.facetDef.filter;</span>
<a href="#l14.160"></a><span id="l14.160"> </span>
<a href="#l14.161"></a><span id="l14.161">     let valStrToVal = {};</span>
<a href="#l14.162"></a><span id="l14.162">     let groups = this.groups = {};</span>
<a href="#l14.163"></a><span id="l14.163">     this.groupCount = 0;</span>
<a href="#l14.164"></a><span id="l14.164"> </span>
<a href="#l14.165"></a><span id="l14.165">     for (let item of aItems) {</span>
<a href="#l14.166"></a><span id="l14.166">       let val = (attrKey in item) ? item[attrKey] : null;</span>
<a href="#l14.167"></a><span id="l14.167" class="difflineat">@@ -183,19 +178,19 @@ DiscreteFaceter.prototype = {</span>
<a href="#l14.168"></a><span id="l14.168">         continue;</span>
<a href="#l14.169"></a><span id="l14.169"> </span>
<a href="#l14.170"></a><span id="l14.170">       // skip items the filter tells us to ignore</span>
<a href="#l14.171"></a><span id="l14.171">       if (filter &amp;&amp; !filter(val))</span>
<a href="#l14.172"></a><span id="l14.172">         continue;</span>
<a href="#l14.173"></a><span id="l14.173"> </span>
<a href="#l14.174"></a><span id="l14.174">       // We need to use hasOwnProperty because we cannot guarantee that the</span>
<a href="#l14.175"></a><span id="l14.175">       //  contents of val won't collide with the attributes in Object.prototype.</span>
<a href="#l14.176"></a><span id="l14.176" class="difflineminus">-      if (groups.hasOwnProperty(val))</span>
<a href="#l14.177"></a><span id="l14.177" class="difflineplus">+      if (groups.hasOwnProperty(val)) {</span>
<a href="#l14.178"></a><span id="l14.178">         groups[val].push(item);</span>
<a href="#l14.179"></a><span id="l14.179" class="difflineminus">-      else {</span>
<a href="#l14.180"></a><span id="l14.180" class="difflineplus">+      } else {</span>
<a href="#l14.181"></a><span id="l14.181">         groups[val] = [item];</span>
<a href="#l14.182"></a><span id="l14.182">         valStrToVal[val] = val;</span>
<a href="#l14.183"></a><span id="l14.183">         this.groupCount++;</span>
<a href="#l14.184"></a><span id="l14.184">       }</span>
<a href="#l14.185"></a><span id="l14.185">     }</span>
<a href="#l14.186"></a><span id="l14.186"> </span>
<a href="#l14.187"></a><span id="l14.187">     let orderedGroups = Object.keys(groups).</span>
<a href="#l14.188"></a><span id="l14.188">       map(key =&gt; [valStrToVal[key], groups[key]]);</span>
<a href="#l14.189"></a><span id="l14.189" class="difflineat">@@ -206,19 +201,18 @@ DiscreteFaceter.prototype = {</span>
<a href="#l14.190"></a><span id="l14.190">     orderedGroups.sort(comparatorHelper);</span>
<a href="#l14.191"></a><span id="l14.191">     this.orderedGroups = orderedGroups;</span>
<a href="#l14.192"></a><span id="l14.192">   },</span>
<a href="#l14.193"></a><span id="l14.193">   /**</span>
<a href="#l14.194"></a><span id="l14.194">    * Facet an attribute whose value is a complex object that can be identified</span>
<a href="#l14.195"></a><span id="l14.195">    *  by its 'id' attribute.  This is the case where the value is itself a noun</span>
<a href="#l14.196"></a><span id="l14.196">    *  instance.</span>
<a href="#l14.197"></a><span id="l14.197">    */</span>
<a href="#l14.198"></a><span id="l14.198" class="difflineminus">-  facetComplexItems: function(aItems) {</span>
<a href="#l14.199"></a><span id="l14.199" class="difflineplus">+  facetComplexItems(aItems) {</span>
<a href="#l14.200"></a><span id="l14.200">     let attrKey = this.attrDef.boundName;</span>
<a href="#l14.201"></a><span id="l14.201" class="difflineminus">-    let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l14.202"></a><span id="l14.202">     let filter = this.facetDef.filter;</span>
<a href="#l14.203"></a><span id="l14.203">     let idAttr = this.facetDef.groupIdAttr;</span>
<a href="#l14.204"></a><span id="l14.204"> </span>
<a href="#l14.205"></a><span id="l14.205">     let groups = this.groups = {};</span>
<a href="#l14.206"></a><span id="l14.206">     let groupMap = this.groupMap = {};</span>
<a href="#l14.207"></a><span id="l14.207">     this.groupCount = 0;</span>
<a href="#l14.208"></a><span id="l14.208"> </span>
<a href="#l14.209"></a><span id="l14.209">     for (let item of aItems) {</span>
<a href="#l14.210"></a><span id="l14.210" class="difflineat">@@ -232,18 +226,17 @@ DiscreteFaceter.prototype = {</span>
<a href="#l14.211"></a><span id="l14.211"> </span>
<a href="#l14.212"></a><span id="l14.212">       let valId = (val == null) ? null : val[idAttr];</span>
<a href="#l14.213"></a><span id="l14.213">       // We need to use hasOwnProperty because tag nouns are complex objects</span>
<a href="#l14.214"></a><span id="l14.214">       //  with id's that are non-numeric and so can collide with the contents</span>
<a href="#l14.215"></a><span id="l14.215">       //  of Object.prototype.  (Note: the &quot;tags&quot; attribute is actually handled</span>
<a href="#l14.216"></a><span id="l14.216">       //  by the DiscreteSetFaceter.)</span>
<a href="#l14.217"></a><span id="l14.217">       if (groupMap.hasOwnProperty(valId)) {</span>
<a href="#l14.218"></a><span id="l14.218">         groups[valId].push(item);</span>
<a href="#l14.219"></a><span id="l14.219" class="difflineminus">-      }</span>
<a href="#l14.220"></a><span id="l14.220" class="difflineminus">-      else {</span>
<a href="#l14.221"></a><span id="l14.221" class="difflineplus">+      } else {</span>
<a href="#l14.222"></a><span id="l14.222">         groupMap[valId] = val;</span>
<a href="#l14.223"></a><span id="l14.223">         groups[valId] = [item];</span>
<a href="#l14.224"></a><span id="l14.224">         this.groupCount++;</span>
<a href="#l14.225"></a><span id="l14.225">       }</span>
<a href="#l14.226"></a><span id="l14.226">     }</span>
<a href="#l14.227"></a><span id="l14.227"> </span>
<a href="#l14.228"></a><span id="l14.228">     let orderedGroups = Object.keys(groups).</span>
<a href="#l14.229"></a><span id="l14.229">       map(key =&gt; [groupMap[key], groups[key]]);</span>
<a href="#l14.230"></a><span id="l14.230" class="difflineat">@@ -268,29 +261,27 @@ function DiscreteSetFaceter(aAttrDef, aF</span>
<a href="#l14.231"></a><span id="l14.231">   this.attrDef = aAttrDef;</span>
<a href="#l14.232"></a><span id="l14.232">   this.facetDef = aFacetDef;</span>
<a href="#l14.233"></a><span id="l14.233"> }</span>
<a href="#l14.234"></a><span id="l14.234"> DiscreteSetFaceter.prototype = {</span>
<a href="#l14.235"></a><span id="l14.235">   type: &quot;discrete&quot;,</span>
<a href="#l14.236"></a><span id="l14.236">   /**</span>
<a href="#l14.237"></a><span id="l14.237">    * Facet the given set of items, deferring to the appropriate helper method</span>
<a href="#l14.238"></a><span id="l14.238">    */</span>
<a href="#l14.239"></a><span id="l14.239" class="difflineminus">-  facetItems: function(aItems) {</span>
<a href="#l14.240"></a><span id="l14.240" class="difflineplus">+  facetItems(aItems) {</span>
<a href="#l14.241"></a><span id="l14.241">     if (this.attrDef.objectNounDef.isPrimitive)</span>
<a href="#l14.242"></a><span id="l14.242">       return this.facetPrimitiveItems(aItems);</span>
<a href="#l14.243"></a><span id="l14.243" class="difflineminus">-    else</span>
<a href="#l14.244"></a><span id="l14.244" class="difflineminus">-      return this.facetComplexItems(aItems);</span>
<a href="#l14.245"></a><span id="l14.245" class="difflineplus">+    return this.facetComplexItems(aItems);</span>
<a href="#l14.246"></a><span id="l14.246">   },</span>
<a href="#l14.247"></a><span id="l14.247">   /**</span>
<a href="#l14.248"></a><span id="l14.248">    * Facet an attribute whose value is primitive, meaning that it is a raw</span>
<a href="#l14.249"></a><span id="l14.249">    *  numeric value or string, rather than a complex object.</span>
<a href="#l14.250"></a><span id="l14.250">    */</span>
<a href="#l14.251"></a><span id="l14.251" class="difflineminus">-  facetPrimitiveItems: function(aItems) {</span>
<a href="#l14.252"></a><span id="l14.252" class="difflineplus">+  facetPrimitiveItems(aItems) {</span>
<a href="#l14.253"></a><span id="l14.253">     let attrKey = this.attrDef.boundName;</span>
<a href="#l14.254"></a><span id="l14.254" class="difflineminus">-    let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l14.255"></a><span id="l14.255">     let filter = this.facetDef.filter;</span>
<a href="#l14.256"></a><span id="l14.256"> </span>
<a href="#l14.257"></a><span id="l14.257">     let groups = this.groups = {};</span>
<a href="#l14.258"></a><span id="l14.258">     let valStrToVal = {};</span>
<a href="#l14.259"></a><span id="l14.259">     this.groupCount = 0;</span>
<a href="#l14.260"></a><span id="l14.260"> </span>
<a href="#l14.261"></a><span id="l14.261">     for (let item of aItems) {</span>
<a href="#l14.262"></a><span id="l14.262">       let vals = (attrKey in item) ? item[attrKey] : null;</span>
<a href="#l14.263"></a><span id="l14.263" class="difflineat">@@ -303,19 +294,19 @@ DiscreteSetFaceter.prototype = {</span>
<a href="#l14.264"></a><span id="l14.264">       for (let val of vals) {</span>
<a href="#l14.265"></a><span id="l14.265">         // skip items the filter tells us to ignore</span>
<a href="#l14.266"></a><span id="l14.266">         if (filter &amp;&amp; !filter(val))</span>
<a href="#l14.267"></a><span id="l14.267">           continue;</span>
<a href="#l14.268"></a><span id="l14.268"> </span>
<a href="#l14.269"></a><span id="l14.269">         // We need to use hasOwnProperty because we cannot guarantee that the</span>
<a href="#l14.270"></a><span id="l14.270">         //  contents of val won't collide with the attributes in</span>
<a href="#l14.271"></a><span id="l14.271">         //  Object.prototype.</span>
<a href="#l14.272"></a><span id="l14.272" class="difflineminus">-        if (groups.hasOwnProperty(val))</span>
<a href="#l14.273"></a><span id="l14.273" class="difflineplus">+        if (groups.hasOwnProperty(val)) {</span>
<a href="#l14.274"></a><span id="l14.274">           groups[val].push(item);</span>
<a href="#l14.275"></a><span id="l14.275" class="difflineminus">-        else {</span>
<a href="#l14.276"></a><span id="l14.276" class="difflineplus">+        } else {</span>
<a href="#l14.277"></a><span id="l14.277">           groups[val] = [item];</span>
<a href="#l14.278"></a><span id="l14.278">           valStrToVal[val] = val;</span>
<a href="#l14.279"></a><span id="l14.279">           this.groupCount++;</span>
<a href="#l14.280"></a><span id="l14.280">         }</span>
<a href="#l14.281"></a><span id="l14.281">       }</span>
<a href="#l14.282"></a><span id="l14.282">     }</span>
<a href="#l14.283"></a><span id="l14.283"> </span>
<a href="#l14.284"></a><span id="l14.284">     let orderedGroups = Object.keys(groups).</span>
<a href="#l14.285"></a><span id="l14.285" class="difflineat">@@ -327,19 +318,18 @@ DiscreteSetFaceter.prototype = {</span>
<a href="#l14.286"></a><span id="l14.286">     orderedGroups.sort(comparatorHelper);</span>
<a href="#l14.287"></a><span id="l14.287">     this.orderedGroups = orderedGroups;</span>
<a href="#l14.288"></a><span id="l14.288">   },</span>
<a href="#l14.289"></a><span id="l14.289">   /**</span>
<a href="#l14.290"></a><span id="l14.290">    * Facet an attribute whose value is a complex object that can be identified</span>
<a href="#l14.291"></a><span id="l14.291">    *  by its 'id' attribute.  This is the case where the value is itself a noun</span>
<a href="#l14.292"></a><span id="l14.292">    *  instance.</span>
<a href="#l14.293"></a><span id="l14.293">    */</span>
<a href="#l14.294"></a><span id="l14.294" class="difflineminus">-  facetComplexItems: function(aItems) {</span>
<a href="#l14.295"></a><span id="l14.295" class="difflineplus">+  facetComplexItems(aItems) {</span>
<a href="#l14.296"></a><span id="l14.296">     let attrKey = this.attrDef.boundName;</span>
<a href="#l14.297"></a><span id="l14.297" class="difflineminus">-    let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l14.298"></a><span id="l14.298">     let filter = this.facetDef.filter;</span>
<a href="#l14.299"></a><span id="l14.299">     let idAttr = this.facetDef.groupIdAttr;</span>
<a href="#l14.300"></a><span id="l14.300"> </span>
<a href="#l14.301"></a><span id="l14.301">     let groups = this.groups = {};</span>
<a href="#l14.302"></a><span id="l14.302">     let groupMap = this.groupMap = {};</span>
<a href="#l14.303"></a><span id="l14.303">     this.groupCount = 0;</span>
<a href="#l14.304"></a><span id="l14.304"> </span>
<a href="#l14.305"></a><span id="l14.305">     for (let item of aItems) {</span>
<a href="#l14.306"></a><span id="l14.306" class="difflineat">@@ -356,18 +346,17 @@ DiscreteSetFaceter.prototype = {</span>
<a href="#l14.307"></a><span id="l14.307">           continue;</span>
<a href="#l14.308"></a><span id="l14.308"> </span>
<a href="#l14.309"></a><span id="l14.309">         let valId = (val == null) ? null : val[idAttr];</span>
<a href="#l14.310"></a><span id="l14.310">         // We need to use hasOwnProperty because tag nouns are complex objects</span>
<a href="#l14.311"></a><span id="l14.311">         //  with id's that are non-numeric and so can collide with the contents</span>
<a href="#l14.312"></a><span id="l14.312">         //  of Object.prototype.</span>
<a href="#l14.313"></a><span id="l14.313">         if (groupMap.hasOwnProperty(valId)) {</span>
<a href="#l14.314"></a><span id="l14.314">           groups[valId].push(item);</span>
<a href="#l14.315"></a><span id="l14.315" class="difflineminus">-        }</span>
<a href="#l14.316"></a><span id="l14.316" class="difflineminus">-        else {</span>
<a href="#l14.317"></a><span id="l14.317" class="difflineplus">+        } else {</span>
<a href="#l14.318"></a><span id="l14.318">           groupMap[valId] = val;</span>
<a href="#l14.319"></a><span id="l14.319">           groups[valId] = [item];</span>
<a href="#l14.320"></a><span id="l14.320">           this.groupCount++;</span>
<a href="#l14.321"></a><span id="l14.321">         }</span>
<a href="#l14.322"></a><span id="l14.322">       }</span>
<a href="#l14.323"></a><span id="l14.323">     }</span>
<a href="#l14.324"></a><span id="l14.324"> </span>
<a href="#l14.325"></a><span id="l14.325">     let orderedGroups = Object.keys(groups).</span>
<a href="#l14.326"></a><span id="l14.326" class="difflineat">@@ -389,24 +378,22 @@ function NonEmptySetFaceter(aAttrDef, aF</span>
<a href="#l14.327"></a><span id="l14.327">   this.attrDef = aAttrDef;</span>
<a href="#l14.328"></a><span id="l14.328">   this.facetDef = aFacetDef;</span>
<a href="#l14.329"></a><span id="l14.329"> }</span>
<a href="#l14.330"></a><span id="l14.330"> NonEmptySetFaceter.prototype = {</span>
<a href="#l14.331"></a><span id="l14.331">   type: &quot;boolean&quot;,</span>
<a href="#l14.332"></a><span id="l14.332">   /**</span>
<a href="#l14.333"></a><span id="l14.333">    * Facet the given set of items, deferring to the appropriate helper method</span>
<a href="#l14.334"></a><span id="l14.334">    */</span>
<a href="#l14.335"></a><span id="l14.335" class="difflineminus">-  facetItems: function(aItems) {</span>
<a href="#l14.336"></a><span id="l14.336" class="difflineplus">+  facetItems(aItems) {</span>
<a href="#l14.337"></a><span id="l14.337">     let attrKey = this.attrDef.boundName;</span>
<a href="#l14.338"></a><span id="l14.338" class="difflineminus">-    let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l14.339"></a><span id="l14.339"> </span>
<a href="#l14.340"></a><span id="l14.340">     let trueValues = [];</span>
<a href="#l14.341"></a><span id="l14.341">     let falseValues = [];</span>
<a href="#l14.342"></a><span id="l14.342"> </span>
<a href="#l14.343"></a><span id="l14.343" class="difflineminus">-    let groups = this.groups = {};</span>
<a href="#l14.344"></a><span id="l14.344">     this.groupCount = 0;</span>
<a href="#l14.345"></a><span id="l14.345"> </span>
<a href="#l14.346"></a><span id="l14.346">     for (let item of aItems) {</span>
<a href="#l14.347"></a><span id="l14.347">       let vals = (attrKey in item) ? item[attrKey] : null;</span>
<a href="#l14.348"></a><span id="l14.348">       if (vals == null || vals.length == 0)</span>
<a href="#l14.349"></a><span id="l14.349">         falseValues.push(item);</span>
<a href="#l14.350"></a><span id="l14.350">       else</span>
<a href="#l14.351"></a><span id="l14.351">         trueValues.push(item);</span>
<a href="#l14.352"></a><span id="l14.352" class="difflineat">@@ -414,28 +401,28 @@ NonEmptySetFaceter.prototype = {</span>
<a href="#l14.353"></a><span id="l14.353"> </span>
<a href="#l14.354"></a><span id="l14.354">     this.orderedGroups = [];</span>
<a href="#l14.355"></a><span id="l14.355">     if (trueValues.length)</span>
<a href="#l14.356"></a><span id="l14.356">       this.orderedGroups.push([true, trueValues]);</span>
<a href="#l14.357"></a><span id="l14.357">     if (falseValues.length)</span>
<a href="#l14.358"></a><span id="l14.358">       this.orderedGroups.push([false, falseValues]);</span>
<a href="#l14.359"></a><span id="l14.359">     this.groupCount = this.orderedGroups.length;</span>
<a href="#l14.360"></a><span id="l14.360">   },</span>
<a href="#l14.361"></a><span id="l14.361" class="difflineminus">-  makeQuery: function(aGroupValues, aInclusive) {</span>
<a href="#l14.362"></a><span id="l14.362" class="difflineplus">+  makeQuery(aGroupValues, aInclusive) {</span>
<a href="#l14.363"></a><span id="l14.363">     let query = this.query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l14.364"></a><span id="l14.364"> </span>
<a href="#l14.365"></a><span id="l14.365">     let constraintFunc = query[this.attrDef.boundName];</span>
<a href="#l14.366"></a><span id="l14.366">     constraintFunc.call(query);</span>
<a href="#l14.367"></a><span id="l14.367"> </span>
<a href="#l14.368"></a><span id="l14.368">     // Our query is always for non-empty lists (at this time), so we want to</span>
<a href="#l14.369"></a><span id="l14.369">     //  invert if they're excluding 'true' or including 'false', which means !=.</span>
<a href="#l14.370"></a><span id="l14.370">     let invert = aGroupValues[0] != aInclusive;</span>
<a href="#l14.371"></a><span id="l14.371"> </span>
<a href="#l14.372"></a><span id="l14.372">     return [query, invert];</span>
<a href="#l14.373"></a><span id="l14.373" class="difflineminus">-  }</span>
<a href="#l14.374"></a><span id="l14.374" class="difflineplus">+  },</span>
<a href="#l14.375"></a><span id="l14.375"> };</span>
<a href="#l14.376"></a><span id="l14.376"> </span>
<a href="#l14.377"></a><span id="l14.377"> </span>
<a href="#l14.378"></a><span id="l14.378"> /**</span>
<a href="#l14.379"></a><span id="l14.379">  * Facet dates.  We build a hierarchical nested structure of year, month, and</span>
<a href="#l14.380"></a><span id="l14.380">  *  day nesting levels.  This decision was made speculatively in the hopes that</span>
<a href="#l14.381"></a><span id="l14.381">  *  it would allow us to do clustered analysis and that there might be a benefit</span>
<a href="#l14.382"></a><span id="l14.382">  *  for that.  For example, if you search for &quot;Christmas&quot;, we might notice</span>
<a href="#l14.383"></a><span id="l14.383" class="difflineat">@@ -448,25 +435,24 @@ function DateFaceter(aAttrDef, aFacetDef</span>
<a href="#l14.384"></a><span id="l14.384">   this.attrDef = aAttrDef;</span>
<a href="#l14.385"></a><span id="l14.385">   this.facetDef = aFacetDef;</span>
<a href="#l14.386"></a><span id="l14.386"> }</span>
<a href="#l14.387"></a><span id="l14.387"> DateFaceter.prototype = {</span>
<a href="#l14.388"></a><span id="l14.388">   type: &quot;date&quot;,</span>
<a href="#l14.389"></a><span id="l14.389">   /**</span>
<a href="#l14.390"></a><span id="l14.390">    *</span>
<a href="#l14.391"></a><span id="l14.391">    */</span>
<a href="#l14.392"></a><span id="l14.392" class="difflineminus">-  facetItems: function(aItems) {</span>
<a href="#l14.393"></a><span id="l14.393" class="difflineplus">+  facetItems(aItems) {</span>
<a href="#l14.394"></a><span id="l14.394">     let attrKey = this.attrDef.boundName;</span>
<a href="#l14.395"></a><span id="l14.395" class="difflineminus">-    let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l14.396"></a><span id="l14.396"> </span>
<a href="#l14.397"></a><span id="l14.397">     let years = this.years = {_subCount: 0};</span>
<a href="#l14.398"></a><span id="l14.398">     // generally track the time range</span>
<a href="#l14.399"></a><span id="l14.399">     let oldest = null, newest = null;</span>
<a href="#l14.400"></a><span id="l14.400"> </span>
<a href="#l14.401"></a><span id="l14.401" class="difflineminus">-    let validItems = this.validItems = [];</span>
<a href="#l14.402"></a><span id="l14.402" class="difflineplus">+    this.validItems = [];</span>
<a href="#l14.403"></a><span id="l14.403"> </span>
<a href="#l14.404"></a><span id="l14.404">     // just cheat and put us at the front...</span>
<a href="#l14.405"></a><span id="l14.405">     this.groupCount = aItems.length ? 1000 : 0;</span>
<a href="#l14.406"></a><span id="l14.406">     this.orderedGroups = null;</span>
<a href="#l14.407"></a><span id="l14.407"> </span>
<a href="#l14.408"></a><span id="l14.408">     /** The number of items with a null/missing attribute. */</span>
<a href="#l14.409"></a><span id="l14.409">     this.missing = 0;</span>
<a href="#l14.410"></a><span id="l14.410"> </span>
<a href="#l14.411"></a><span id="l14.411" class="difflineat">@@ -511,67 +497,64 @@ DateFaceter.prototype = {</span>
<a href="#l14.412"></a><span id="l14.412">         newest = val;</span>
<a href="#l14.413"></a><span id="l14.413"> </span>
<a href="#l14.414"></a><span id="l14.414">       // -- bucket</span>
<a href="#l14.415"></a><span id="l14.415">       // - year</span>
<a href="#l14.416"></a><span id="l14.416">       let year, valYear = val.getYear();</span>
<a href="#l14.417"></a><span id="l14.417">       if (valYear in years) {</span>
<a href="#l14.418"></a><span id="l14.418">         year = years[valYear];</span>
<a href="#l14.419"></a><span id="l14.419">         year._dateCount++;</span>
<a href="#l14.420"></a><span id="l14.420" class="difflineminus">-      }</span>
<a href="#l14.421"></a><span id="l14.421" class="difflineminus">-      else {</span>
<a href="#l14.422"></a><span id="l14.422" class="difflineplus">+      } else {</span>
<a href="#l14.423"></a><span id="l14.423">         year = years[valYear] = {</span>
<a href="#l14.424"></a><span id="l14.424">           _dateCount: 1,</span>
<a href="#l14.425"></a><span id="l14.425" class="difflineminus">-          _subCount: 0</span>
<a href="#l14.426"></a><span id="l14.426" class="difflineplus">+          _subCount: 0,</span>
<a href="#l14.427"></a><span id="l14.427">         };</span>
<a href="#l14.428"></a><span id="l14.428">         years._subCount++;</span>
<a href="#l14.429"></a><span id="l14.429">       }</span>
<a href="#l14.430"></a><span id="l14.430"> </span>
<a href="#l14.431"></a><span id="l14.431">       // - month</span>
<a href="#l14.432"></a><span id="l14.432">       let month, valMonth = val.getMonth();</span>
<a href="#l14.433"></a><span id="l14.433">       if (valMonth in year) {</span>
<a href="#l14.434"></a><span id="l14.434">         month = year[valMonth];</span>
<a href="#l14.435"></a><span id="l14.435">         month._dateCount++;</span>
<a href="#l14.436"></a><span id="l14.436" class="difflineminus">-      }</span>
<a href="#l14.437"></a><span id="l14.437" class="difflineminus">-      else {</span>
<a href="#l14.438"></a><span id="l14.438" class="difflineplus">+      } else {</span>
<a href="#l14.439"></a><span id="l14.439">         month = year[valMonth] = {</span>
<a href="#l14.440"></a><span id="l14.440">           _dateCount: 1,</span>
<a href="#l14.441"></a><span id="l14.441" class="difflineminus">-          _subCount: 0</span>
<a href="#l14.442"></a><span id="l14.442" class="difflineplus">+          _subCount: 0,</span>
<a href="#l14.443"></a><span id="l14.443">         };</span>
<a href="#l14.444"></a><span id="l14.444">         year._subCount++;</span>
<a href="#l14.445"></a><span id="l14.445">       }</span>
<a href="#l14.446"></a><span id="l14.446"> </span>
<a href="#l14.447"></a><span id="l14.447">       // - day</span>
<a href="#l14.448"></a><span id="l14.448">       let valDate = val.getDate();</span>
<a href="#l14.449"></a><span id="l14.449">       if (valDate in month) {</span>
<a href="#l14.450"></a><span id="l14.450">         month[valDate].push(item);</span>
<a href="#l14.451"></a><span id="l14.451" class="difflineminus">-      }</span>
<a href="#l14.452"></a><span id="l14.452" class="difflineminus">-      else {</span>
<a href="#l14.453"></a><span id="l14.453" class="difflineplus">+      } else {</span>
<a href="#l14.454"></a><span id="l14.454">         month[valDate] = [item];</span>
<a href="#l14.455"></a><span id="l14.455">       }</span>
<a href="#l14.456"></a><span id="l14.456">     }</span>
<a href="#l14.457"></a><span id="l14.457"> </span>
<a href="#l14.458"></a><span id="l14.458">     this.oldest = oldest;</span>
<a href="#l14.459"></a><span id="l14.459">     this.newest = newest;</span>
<a href="#l14.460"></a><span id="l14.460">   },</span>
<a href="#l14.461"></a><span id="l14.461"> </span>
<a href="#l14.462"></a><span id="l14.462" class="difflineminus">-  _unionMonth: function(aMonthObj) {</span>
<a href="#l14.463"></a><span id="l14.463" class="difflineplus">+  _unionMonth(aMonthObj) {</span>
<a href="#l14.464"></a><span id="l14.464">     let dayItemLists = [];</span>
<a href="#l14.465"></a><span id="l14.465">     for (let key in aMonthObj) {</span>
<a href="#l14.466"></a><span id="l14.466">       let dayItemList = aMonthObj[key];</span>
<a href="#l14.467"></a><span id="l14.467" class="difflineminus">-      if (typeof(key) == &quot;string&quot; &amp;&amp; key.startsWith('_'))</span>
<a href="#l14.468"></a><span id="l14.468" class="difflineplus">+      if (typeof(key) == &quot;string&quot; &amp;&amp; key.startsWith(&quot;_&quot;))</span>
<a href="#l14.469"></a><span id="l14.469">         continue;</span>
<a href="#l14.470"></a><span id="l14.470">       dayItemLists.push(dayItemList);</span>
<a href="#l14.471"></a><span id="l14.471">     }</span>
<a href="#l14.472"></a><span id="l14.472">     return dayItemLists;</span>
<a href="#l14.473"></a><span id="l14.473">   },</span>
<a href="#l14.474"></a><span id="l14.474"> </span>
<a href="#l14.475"></a><span id="l14.475" class="difflineminus">-  _unionYear: function(aYearObj) {</span>
<a href="#l14.476"></a><span id="l14.476" class="difflineplus">+  _unionYear(aYearObj) {</span>
<a href="#l14.477"></a><span id="l14.477">     let monthItemLists = [];</span>
<a href="#l14.478"></a><span id="l14.478">     for (let key in aYearObj) {</span>
<a href="#l14.479"></a><span id="l14.479">       let monthObj = aYearObj[key];</span>
<a href="#l14.480"></a><span id="l14.480" class="difflineminus">-      if (typeof(key) == &quot;string&quot; &amp;&amp; key.startsWith('_'))</span>
<a href="#l14.481"></a><span id="l14.481" class="difflineplus">+      if (typeof(key) == &quot;string&quot; &amp;&amp; key.startsWith(&quot;_&quot;))</span>
<a href="#l14.482"></a><span id="l14.482">         continue;</span>
<a href="#l14.483"></a><span id="l14.483">       monthItemLists.push(this._unionMonth(monthObj));</span>
<a href="#l14.484"></a><span id="l14.484">     }</span>
<a href="#l14.485"></a><span id="l14.485">     return monthItemLists;</span>
<a href="#l14.486"></a><span id="l14.486" class="difflineminus">-  }</span>
<a href="#l14.487"></a><span id="l14.487" class="difflineplus">+  },</span>
<a href="#l14.488"></a><span id="l14.488"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -1,13 +1,13 @@</span>
<a href="#l15.4"></a><span id="l15.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l15.5"></a><span id="l15.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l15.6"></a><span id="l15.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l15.7"></a><span id="l15.7"> </span>
<a href="#l15.8"></a><span id="l15.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['GlodaFundAttr'];</span>
<a href="#l15.9"></a><span id="l15.9" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;GlodaFundAttr&quot;];</span>
<a href="#l15.10"></a><span id="l15.10"> </span>
<a href="#l15.11"></a><span id="l15.11"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l15.12"></a><span id="l15.12"> const {StringBundle} = ChromeUtils.import(&quot;resource:///modules/StringBundle.js&quot;);</span>
<a href="#l15.13"></a><span id="l15.13"> </span>
<a href="#l15.14"></a><span id="l15.14"> const {GlodaUtils} = ChromeUtils.import(&quot;resource:///modules/gloda/utils.js&quot;);</span>
<a href="#l15.15"></a><span id="l15.15"> const {Gloda} = ChromeUtils.import(&quot;resource:///modules/gloda/gloda.js&quot;);</span>
<a href="#l15.16"></a><span id="l15.16"> const {GlodaDatastore} = ChromeUtils.import(&quot;resource:///modules/gloda/datastore.js&quot;);</span>
<a href="#l15.17"></a><span id="l15.17"> const {GlodaAttachment} = ChromeUtils.import(&quot;resource:///modules/gloda/datamodel.js&quot;);</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineat">@@ -21,23 +21,22 @@ const {GlodaContent} = ChromeUtils.impor</span>
<a href="#l15.19"></a><span id="l15.19">  *  than most extension providers should do.  In summary, don't mimic this code</span>
<a href="#l15.20"></a><span id="l15.20">  *  unless you won't complain when your code breaks.</span>
<a href="#l15.21"></a><span id="l15.21">  */</span>
<a href="#l15.22"></a><span id="l15.22"> var GlodaFundAttr = {</span>
<a href="#l15.23"></a><span id="l15.23">   providerName: &quot;gloda.fundattr&quot;,</span>
<a href="#l15.24"></a><span id="l15.24">   strings: new StringBundle(&quot;chrome://messenger/locale/gloda.properties&quot;),</span>
<a href="#l15.25"></a><span id="l15.25">   _log: null,</span>
<a href="#l15.26"></a><span id="l15.26"> </span>
<a href="#l15.27"></a><span id="l15.27" class="difflineminus">-  init: function gloda_explattr_init() {</span>
<a href="#l15.28"></a><span id="l15.28" class="difflineplus">+  init() {</span>
<a href="#l15.29"></a><span id="l15.29">     this._log =  Log4Moz.repository.getLogger(&quot;gloda.fundattr&quot;);</span>
<a href="#l15.30"></a><span id="l15.30"> </span>
<a href="#l15.31"></a><span id="l15.31">     try {</span>
<a href="#l15.32"></a><span id="l15.32">       this.defineAttributes();</span>
<a href="#l15.33"></a><span id="l15.33" class="difflineminus">-    }</span>
<a href="#l15.34"></a><span id="l15.34" class="difflineminus">-    catch (ex) {</span>
<a href="#l15.35"></a><span id="l15.35" class="difflineplus">+    } catch (ex) {</span>
<a href="#l15.36"></a><span id="l15.36">       this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l15.37"></a><span id="l15.37">       throw ex;</span>
<a href="#l15.38"></a><span id="l15.38">     }</span>
<a href="#l15.39"></a><span id="l15.39">   },</span>
<a href="#l15.40"></a><span id="l15.40"> </span>
<a href="#l15.41"></a><span id="l15.41">   POPULARITY_FROM_ME_TO: 10,</span>
<a href="#l15.42"></a><span id="l15.42">   POPULARITY_FROM_ME_CC: 4,</span>
<a href="#l15.43"></a><span id="l15.43">   POPULARITY_FROM_ME_BCC: 3,</span>
<a href="#l15.44"></a><span id="l15.44" class="difflineat">@@ -51,169 +50,169 @@ var GlodaFundAttr = {</span>
<a href="#l15.45"></a><span id="l15.45">   NOTABILITY_INVOLVING_ME: 1,</span>
<a href="#l15.46"></a><span id="l15.46">   /** Boost for message from someone in 'my' address book. */</span>
<a href="#l15.47"></a><span id="l15.47">   NOTABILITY_FROM_IN_ADDR_BOOK: 10,</span>
<a href="#l15.48"></a><span id="l15.48">   /** Boost for the first person involved in my address book. */</span>
<a href="#l15.49"></a><span id="l15.49">   NOTABILITY_INVOLVING_ADDR_BOOK_FIRST: 8,</span>
<a href="#l15.50"></a><span id="l15.50">   /** Boost for each additional person involved in my address book. */</span>
<a href="#l15.51"></a><span id="l15.51">   NOTABILITY_INVOLVING_ADDR_BOOK_ADDL: 2,</span>
<a href="#l15.52"></a><span id="l15.52"> </span>
<a href="#l15.53"></a><span id="l15.53" class="difflineminus">-  defineAttributes: function gloda_fundattr_defineAttributes() {</span>
<a href="#l15.54"></a><span id="l15.54" class="difflineplus">+  defineAttributes() {</span>
<a href="#l15.55"></a><span id="l15.55">     /* ***** Conversations ***** */</span>
<a href="#l15.56"></a><span id="l15.56">     // conversation: subjectMatches</span>
<a href="#l15.57"></a><span id="l15.57">     this._attrConvSubject = Gloda.defineAttribute({</span>
<a href="#l15.58"></a><span id="l15.58">       provider: this,</span>
<a href="#l15.59"></a><span id="l15.59">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.60"></a><span id="l15.60">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l15.61"></a><span id="l15.61">       attributeName: &quot;subjectMatches&quot;,</span>
<a href="#l15.62"></a><span id="l15.62">       singular: true,</span>
<a href="#l15.63"></a><span id="l15.63">       special: Gloda.kSpecialFulltext,</span>
<a href="#l15.64"></a><span id="l15.64">       specialColumnName: &quot;subject&quot;,</span>
<a href="#l15.65"></a><span id="l15.65">       subjectNouns: [Gloda.NOUN_CONVERSATION],</span>
<a href="#l15.66"></a><span id="l15.66">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l15.67"></a><span id="l15.67" class="difflineminus">-      });</span>
<a href="#l15.68"></a><span id="l15.68" class="difflineplus">+    });</span>
<a href="#l15.69"></a><span id="l15.69"> </span>
<a href="#l15.70"></a><span id="l15.70">     /* ***** Messages ***** */</span>
<a href="#l15.71"></a><span id="l15.71">     // folder</span>
<a href="#l15.72"></a><span id="l15.72">     this._attrFolder = Gloda.defineAttribute({</span>
<a href="#l15.73"></a><span id="l15.73">       provider: this,</span>
<a href="#l15.74"></a><span id="l15.74">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.75"></a><span id="l15.75">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.76"></a><span id="l15.76">       attributeName: &quot;folder&quot;,</span>
<a href="#l15.77"></a><span id="l15.77">       singular: true,</span>
<a href="#l15.78"></a><span id="l15.78">       facet: true,</span>
<a href="#l15.79"></a><span id="l15.79">       special: Gloda.kSpecialColumn,</span>
<a href="#l15.80"></a><span id="l15.80">       specialColumnName: &quot;folderID&quot;,</span>
<a href="#l15.81"></a><span id="l15.81">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.82"></a><span id="l15.82">       objectNoun: Gloda.NOUN_FOLDER,</span>
<a href="#l15.83"></a><span id="l15.83" class="difflineminus">-      }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.84"></a><span id="l15.84" class="difflineplus">+    }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.85"></a><span id="l15.85">     this._attrAccount = Gloda.defineAttribute({</span>
<a href="#l15.86"></a><span id="l15.86">       provider: this,</span>
<a href="#l15.87"></a><span id="l15.87">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.88"></a><span id="l15.88">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l15.89"></a><span id="l15.89">       attributeName: &quot;account&quot;,</span>
<a href="#l15.90"></a><span id="l15.90">       canQuery: &quot;memory&quot;,</span>
<a href="#l15.91"></a><span id="l15.91">       singular: true,</span>
<a href="#l15.92"></a><span id="l15.92">       facet: true,</span>
<a href="#l15.93"></a><span id="l15.93">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.94"></a><span id="l15.94" class="difflineminus">-      objectNoun: Gloda.NOUN_ACCOUNT</span>
<a href="#l15.95"></a><span id="l15.95" class="difflineminus">-      });</span>
<a href="#l15.96"></a><span id="l15.96" class="difflineplus">+      objectNoun: Gloda.NOUN_ACCOUNT,</span>
<a href="#l15.97"></a><span id="l15.97" class="difflineplus">+    });</span>
<a href="#l15.98"></a><span id="l15.98">     this._attrMessageKey = Gloda.defineAttribute({</span>
<a href="#l15.99"></a><span id="l15.99">       provider: this,</span>
<a href="#l15.100"></a><span id="l15.100">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.101"></a><span id="l15.101">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.102"></a><span id="l15.102">       attributeName: &quot;messageKey&quot;,</span>
<a href="#l15.103"></a><span id="l15.103">       singular: true,</span>
<a href="#l15.104"></a><span id="l15.104">       special: Gloda.kSpecialColumn,</span>
<a href="#l15.105"></a><span id="l15.105">       specialColumnName: &quot;messageKey&quot;,</span>
<a href="#l15.106"></a><span id="l15.106">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.107"></a><span id="l15.107">       objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l15.108"></a><span id="l15.108">       canQuery: true,</span>
<a href="#l15.109"></a><span id="l15.109" class="difflineminus">-      }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.110"></a><span id="l15.110" class="difflineplus">+    }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.111"></a><span id="l15.111"> </span>
<a href="#l15.112"></a><span id="l15.112">     // We need to surface the deleted attribute for querying, but there is no</span>
<a href="#l15.113"></a><span id="l15.113">     //  reason for user code, so let's call it &quot;_deleted&quot; rather than deleted.</span>
<a href="#l15.114"></a><span id="l15.114">     // (In fact, our validity constraints require a special query formulation</span>
<a href="#l15.115"></a><span id="l15.115">     //  that user code should have no clue exists.  That's right user code,</span>
<a href="#l15.116"></a><span id="l15.116">     //  that's a dare.)</span>
<a href="#l15.117"></a><span id="l15.117">     Gloda.defineAttribute({</span>
<a href="#l15.118"></a><span id="l15.118">       provider: this,</span>
<a href="#l15.119"></a><span id="l15.119">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.120"></a><span id="l15.120">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.121"></a><span id="l15.121">       attributeName: &quot;_deleted&quot;,</span>
<a href="#l15.122"></a><span id="l15.122">       singular: true,</span>
<a href="#l15.123"></a><span id="l15.123">       special: Gloda.kSpecialColumn,</span>
<a href="#l15.124"></a><span id="l15.124">       specialColumnName: &quot;deleted&quot;,</span>
<a href="#l15.125"></a><span id="l15.125">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.126"></a><span id="l15.126">       objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l15.127"></a><span id="l15.127" class="difflineminus">-      });</span>
<a href="#l15.128"></a><span id="l15.128" class="difflineplus">+    });</span>
<a href="#l15.129"></a><span id="l15.129"> </span>
<a href="#l15.130"></a><span id="l15.130"> </span>
<a href="#l15.131"></a><span id="l15.131">     // -- fulltext search helpers</span>
<a href="#l15.132"></a><span id="l15.132">     // fulltextMatches.  Match over message subject, body, and attachments</span>
<a href="#l15.133"></a><span id="l15.133">     // @testpoint gloda.noun.message.attr.fulltextMatches</span>
<a href="#l15.134"></a><span id="l15.134">     this._attrFulltext = Gloda.defineAttribute({</span>
<a href="#l15.135"></a><span id="l15.135">       provider: this,</span>
<a href="#l15.136"></a><span id="l15.136">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.137"></a><span id="l15.137">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l15.138"></a><span id="l15.138">       attributeName: &quot;fulltextMatches&quot;,</span>
<a href="#l15.139"></a><span id="l15.139">       singular: true,</span>
<a href="#l15.140"></a><span id="l15.140">       special: Gloda.kSpecialFulltext,</span>
<a href="#l15.141"></a><span id="l15.141">       specialColumnName: &quot;messagesText&quot;,</span>
<a href="#l15.142"></a><span id="l15.142">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.143"></a><span id="l15.143">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l15.144"></a><span id="l15.144" class="difflineminus">-      });</span>
<a href="#l15.145"></a><span id="l15.145" class="difflineplus">+    });</span>
<a href="#l15.146"></a><span id="l15.146"> </span>
<a href="#l15.147"></a><span id="l15.147">     // subjectMatches.  Fulltext match on subject</span>
<a href="#l15.148"></a><span id="l15.148">     // @testpoint gloda.noun.message.attr.subjectMatches</span>
<a href="#l15.149"></a><span id="l15.149">     this._attrSubjectText = Gloda.defineAttribute({</span>
<a href="#l15.150"></a><span id="l15.150">       provider: this,</span>
<a href="#l15.151"></a><span id="l15.151">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.152"></a><span id="l15.152">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l15.153"></a><span id="l15.153">       attributeName: &quot;subjectMatches&quot;,</span>
<a href="#l15.154"></a><span id="l15.154">       singular: true,</span>
<a href="#l15.155"></a><span id="l15.155">       special: Gloda.kSpecialFulltext,</span>
<a href="#l15.156"></a><span id="l15.156">       specialColumnName: &quot;subject&quot;,</span>
<a href="#l15.157"></a><span id="l15.157">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.158"></a><span id="l15.158">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l15.159"></a><span id="l15.159" class="difflineminus">-      });</span>
<a href="#l15.160"></a><span id="l15.160" class="difflineplus">+    });</span>
<a href="#l15.161"></a><span id="l15.161"> </span>
<a href="#l15.162"></a><span id="l15.162">     // bodyMatches. super-synthetic full-text matching...</span>
<a href="#l15.163"></a><span id="l15.163">     // @testpoint gloda.noun.message.attr.bodyMatches</span>
<a href="#l15.164"></a><span id="l15.164">     this._attrBody = Gloda.defineAttribute({</span>
<a href="#l15.165"></a><span id="l15.165">       provider: this,</span>
<a href="#l15.166"></a><span id="l15.166">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.167"></a><span id="l15.167">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l15.168"></a><span id="l15.168">       attributeName: &quot;bodyMatches&quot;,</span>
<a href="#l15.169"></a><span id="l15.169">       singular: true,</span>
<a href="#l15.170"></a><span id="l15.170">       special: Gloda.kSpecialFulltext,</span>
<a href="#l15.171"></a><span id="l15.171">       specialColumnName: &quot;body&quot;,</span>
<a href="#l15.172"></a><span id="l15.172">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.173"></a><span id="l15.173">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l15.174"></a><span id="l15.174" class="difflineminus">-      });</span>
<a href="#l15.175"></a><span id="l15.175" class="difflineplus">+    });</span>
<a href="#l15.176"></a><span id="l15.176"> </span>
<a href="#l15.177"></a><span id="l15.177">     // attachmentNamesMatch</span>
<a href="#l15.178"></a><span id="l15.178">     // @testpoint gloda.noun.message.attr.attachmentNamesMatch</span>
<a href="#l15.179"></a><span id="l15.179">     this._attrAttachmentNames = Gloda.defineAttribute({</span>
<a href="#l15.180"></a><span id="l15.180">       provider: this,</span>
<a href="#l15.181"></a><span id="l15.181">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.182"></a><span id="l15.182">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l15.183"></a><span id="l15.183">       attributeName: &quot;attachmentNamesMatch&quot;,</span>
<a href="#l15.184"></a><span id="l15.184">       singular: true,</span>
<a href="#l15.185"></a><span id="l15.185">       special: Gloda.kSpecialFulltext,</span>
<a href="#l15.186"></a><span id="l15.186">       specialColumnName: &quot;attachmentNames&quot;,</span>
<a href="#l15.187"></a><span id="l15.187">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.188"></a><span id="l15.188">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l15.189"></a><span id="l15.189" class="difflineminus">-      });</span>
<a href="#l15.190"></a><span id="l15.190" class="difflineplus">+    });</span>
<a href="#l15.191"></a><span id="l15.191"> </span>
<a href="#l15.192"></a><span id="l15.192">     // @testpoint gloda.noun.message.attr.authorMatches</span>
<a href="#l15.193"></a><span id="l15.193">     this._attrAuthorFulltext = Gloda.defineAttribute({</span>
<a href="#l15.194"></a><span id="l15.194">       provider: this,</span>
<a href="#l15.195"></a><span id="l15.195">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.196"></a><span id="l15.196">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l15.197"></a><span id="l15.197">       attributeName: &quot;authorMatches&quot;,</span>
<a href="#l15.198"></a><span id="l15.198">       singular: true,</span>
<a href="#l15.199"></a><span id="l15.199">       special: Gloda.kSpecialFulltext,</span>
<a href="#l15.200"></a><span id="l15.200">       specialColumnName: &quot;author&quot;,</span>
<a href="#l15.201"></a><span id="l15.201">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.202"></a><span id="l15.202">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l15.203"></a><span id="l15.203" class="difflineminus">-      });</span>
<a href="#l15.204"></a><span id="l15.204" class="difflineplus">+    });</span>
<a href="#l15.205"></a><span id="l15.205"> </span>
<a href="#l15.206"></a><span id="l15.206">     // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l15.207"></a><span id="l15.207">     this._attrRecipientsFulltext = Gloda.defineAttribute({</span>
<a href="#l15.208"></a><span id="l15.208">       provider: this,</span>
<a href="#l15.209"></a><span id="l15.209">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.210"></a><span id="l15.210">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l15.211"></a><span id="l15.211">       attributeName: &quot;recipientsMatch&quot;,</span>
<a href="#l15.212"></a><span id="l15.212">       singular: true,</span>
<a href="#l15.213"></a><span id="l15.213">       special: Gloda.kSpecialFulltext,</span>
<a href="#l15.214"></a><span id="l15.214">       specialColumnName: &quot;recipients&quot;,</span>
<a href="#l15.215"></a><span id="l15.215">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.216"></a><span id="l15.216">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l15.217"></a><span id="l15.217" class="difflineminus">-      });</span>
<a href="#l15.218"></a><span id="l15.218" class="difflineplus">+    });</span>
<a href="#l15.219"></a><span id="l15.219"> </span>
<a href="#l15.220"></a><span id="l15.220">     // --- synthetic stuff for some reason</span>
<a href="#l15.221"></a><span id="l15.221">     // conversation</span>
<a href="#l15.222"></a><span id="l15.222">     // @testpoint gloda.noun.message.attr.conversation</span>
<a href="#l15.223"></a><span id="l15.223">     this._attrConversation = Gloda.defineAttribute({</span>
<a href="#l15.224"></a><span id="l15.224">       provider: this,</span>
<a href="#l15.225"></a><span id="l15.225">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.226"></a><span id="l15.226">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.227"></a><span id="l15.227" class="difflineat">@@ -221,49 +220,49 @@ var GlodaFundAttr = {</span>
<a href="#l15.228"></a><span id="l15.228">       singular: true,</span>
<a href="#l15.229"></a><span id="l15.229">       special: Gloda.kSpecialColumnParent,</span>
<a href="#l15.230"></a><span id="l15.230">       specialColumnName: &quot;conversationID&quot;,</span>
<a href="#l15.231"></a><span id="l15.231">       idStorageAttributeName: &quot;_conversationID&quot;,</span>
<a href="#l15.232"></a><span id="l15.232">       valueStorageAttributeName: &quot;_conversation&quot;,</span>
<a href="#l15.233"></a><span id="l15.233">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.234"></a><span id="l15.234">       objectNoun: Gloda.NOUN_CONVERSATION,</span>
<a href="#l15.235"></a><span id="l15.235">       canQuery: true,</span>
<a href="#l15.236"></a><span id="l15.236" class="difflineminus">-      });</span>
<a href="#l15.237"></a><span id="l15.237" class="difflineplus">+    });</span>
<a href="#l15.238"></a><span id="l15.238"> </span>
<a href="#l15.239"></a><span id="l15.239">     // --- Fundamental</span>
<a href="#l15.240"></a><span id="l15.240">     // From</span>
<a href="#l15.241"></a><span id="l15.241">     this._attrFrom = Gloda.defineAttribute({</span>
<a href="#l15.242"></a><span id="l15.242">                         provider: this,</span>
<a href="#l15.243"></a><span id="l15.243">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.244"></a><span id="l15.244">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.245"></a><span id="l15.245">                         attributeName: &quot;from&quot;,</span>
<a href="#l15.246"></a><span id="l15.246">                         singular: true,</span>
<a href="#l15.247"></a><span id="l15.247">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.248"></a><span id="l15.248">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l15.249"></a><span id="l15.249" class="difflineminus">-                        }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.250"></a><span id="l15.250" class="difflineplus">+                      }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.251"></a><span id="l15.251">     // To</span>
<a href="#l15.252"></a><span id="l15.252">     this._attrTo = Gloda.defineAttribute({</span>
<a href="#l15.253"></a><span id="l15.253">                         provider: this,</span>
<a href="#l15.254"></a><span id="l15.254">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.255"></a><span id="l15.255">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.256"></a><span id="l15.256">                         attributeName: &quot;to&quot;,</span>
<a href="#l15.257"></a><span id="l15.257">                         singular: false,</span>
<a href="#l15.258"></a><span id="l15.258">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.259"></a><span id="l15.259">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l15.260"></a><span id="l15.260" class="difflineminus">-                        }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.261"></a><span id="l15.261" class="difflineplus">+                      }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.262"></a><span id="l15.262">     // Cc</span>
<a href="#l15.263"></a><span id="l15.263">     this._attrCc = Gloda.defineAttribute({</span>
<a href="#l15.264"></a><span id="l15.264">                         provider: this,</span>
<a href="#l15.265"></a><span id="l15.265">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.266"></a><span id="l15.266">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.267"></a><span id="l15.267">                         attributeName: &quot;cc&quot;,</span>
<a href="#l15.268"></a><span id="l15.268">                         singular: false,</span>
<a href="#l15.269"></a><span id="l15.269">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.270"></a><span id="l15.270">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l15.271"></a><span id="l15.271" class="difflineminus">-                        }); // not-tested</span>
<a href="#l15.272"></a><span id="l15.272" class="difflineplus">+                      }); // not-tested</span>
<a href="#l15.273"></a><span id="l15.273">     /**</span>
<a href="#l15.274"></a><span id="l15.274">      * Bcc'ed recipients; only makes sense for sent messages.</span>
<a href="#l15.275"></a><span id="l15.275">      */</span>
<a href="#l15.276"></a><span id="l15.276">     this._attrBcc = Gloda.defineAttribute({</span>
<a href="#l15.277"></a><span id="l15.277">       provider: this,</span>
<a href="#l15.278"></a><span id="l15.278">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.279"></a><span id="l15.279">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.280"></a><span id="l15.280">       attributeName: &quot;bcc&quot;,</span>
<a href="#l15.281"></a><span id="l15.281" class="difflineat">@@ -281,31 +280,31 @@ var GlodaFundAttr = {</span>
<a href="#l15.282"></a><span id="l15.282">                         singular: true,</span>
<a href="#l15.283"></a><span id="l15.283">                         facet: {</span>
<a href="#l15.284"></a><span id="l15.284">                           type: &quot;date&quot;,</span>
<a href="#l15.285"></a><span id="l15.285">                         },</span>
<a href="#l15.286"></a><span id="l15.286">                         special: Gloda.kSpecialColumn,</span>
<a href="#l15.287"></a><span id="l15.287">                         specialColumnName: &quot;date&quot;,</span>
<a href="#l15.288"></a><span id="l15.288">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.289"></a><span id="l15.289">                         objectNoun: Gloda.NOUN_DATE,</span>
<a href="#l15.290"></a><span id="l15.290" class="difflineminus">-                        }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.291"></a><span id="l15.291" class="difflineplus">+                      }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.292"></a><span id="l15.292"> </span>
<a href="#l15.293"></a><span id="l15.293">     // Header message ID.</span>
<a href="#l15.294"></a><span id="l15.294">     this._attrHeaderMessageID = Gloda.defineAttribute({</span>
<a href="#l15.295"></a><span id="l15.295">                         provider: this,</span>
<a href="#l15.296"></a><span id="l15.296">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.297"></a><span id="l15.297">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.298"></a><span id="l15.298">                         attributeName: &quot;headerMessageID&quot;,</span>
<a href="#l15.299"></a><span id="l15.299">                         singular: true,</span>
<a href="#l15.300"></a><span id="l15.300">                         special: Gloda.kSpecialString,</span>
<a href="#l15.301"></a><span id="l15.301">                         specialColumnName: &quot;headerMessageID&quot;,</span>
<a href="#l15.302"></a><span id="l15.302">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.303"></a><span id="l15.303">                         objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l15.304"></a><span id="l15.304">                         canQuery: true,</span>
<a href="#l15.305"></a><span id="l15.305" class="difflineminus">-                        }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.306"></a><span id="l15.306" class="difflineplus">+                      }); // tested-by: test_attributes_fundamental</span>
<a href="#l15.307"></a><span id="l15.307"> </span>
<a href="#l15.308"></a><span id="l15.308">     // Attachment MIME Types</span>
<a href="#l15.309"></a><span id="l15.309">     this._attrAttachmentTypes = Gloda.defineAttribute({</span>
<a href="#l15.310"></a><span id="l15.310">       provider: this,</span>
<a href="#l15.311"></a><span id="l15.311">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.312"></a><span id="l15.312">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.313"></a><span id="l15.313">       attributeName: &quot;attachmentTypes&quot;,</span>
<a href="#l15.314"></a><span id="l15.314">       singular: false,</span>
<a href="#l15.315"></a><span id="l15.315" class="difflineat">@@ -313,41 +312,41 @@ var GlodaFundAttr = {</span>
<a href="#l15.316"></a><span id="l15.316">       facet: {</span>
<a href="#l15.317"></a><span id="l15.317">         type: &quot;default&quot;,</span>
<a href="#l15.318"></a><span id="l15.318">         // This will group the MIME types by their category.</span>
<a href="#l15.319"></a><span id="l15.319">         groupIdAttr: &quot;category&quot;,</span>
<a href="#l15.320"></a><span id="l15.320">         queryHelper: &quot;Category&quot;,</span>
<a href="#l15.321"></a><span id="l15.321">       },</span>
<a href="#l15.322"></a><span id="l15.322">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.323"></a><span id="l15.323">       objectNoun: Gloda.NOUN_MIME_TYPE,</span>
<a href="#l15.324"></a><span id="l15.324" class="difflineminus">-      });</span>
<a href="#l15.325"></a><span id="l15.325" class="difflineplus">+    });</span>
<a href="#l15.326"></a><span id="l15.326"> </span>
<a href="#l15.327"></a><span id="l15.327">     // Attachment infos</span>
<a href="#l15.328"></a><span id="l15.328">     this._attrIsEncrypted = Gloda.defineAttribute({</span>
<a href="#l15.329"></a><span id="l15.329">       provider: this,</span>
<a href="#l15.330"></a><span id="l15.330">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.331"></a><span id="l15.331">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.332"></a><span id="l15.332">       attributeName: &quot;isEncrypted&quot;,</span>
<a href="#l15.333"></a><span id="l15.333">       singular: true,</span>
<a href="#l15.334"></a><span id="l15.334">       emptySetIsSignificant: false,</span>
<a href="#l15.335"></a><span id="l15.335">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.336"></a><span id="l15.336">       objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l15.337"></a><span id="l15.337" class="difflineminus">-      });</span>
<a href="#l15.338"></a><span id="l15.338" class="difflineplus">+    });</span>
<a href="#l15.339"></a><span id="l15.339"> </span>
<a href="#l15.340"></a><span id="l15.340">     // Attachment infos</span>
<a href="#l15.341"></a><span id="l15.341">     this._attrAttachmentInfos = Gloda.defineAttribute({</span>
<a href="#l15.342"></a><span id="l15.342">       provider: this,</span>
<a href="#l15.343"></a><span id="l15.343">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.344"></a><span id="l15.344">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.345"></a><span id="l15.345">       attributeName: &quot;attachmentInfos&quot;,</span>
<a href="#l15.346"></a><span id="l15.346">       singular: false,</span>
<a href="#l15.347"></a><span id="l15.347">       emptySetIsSignificant: false,</span>
<a href="#l15.348"></a><span id="l15.348">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.349"></a><span id="l15.349">       objectNoun: Gloda.NOUN_ATTACHMENT,</span>
<a href="#l15.350"></a><span id="l15.350" class="difflineminus">-      });</span>
<a href="#l15.351"></a><span id="l15.351" class="difflineplus">+    });</span>
<a href="#l15.352"></a><span id="l15.352"> </span>
<a href="#l15.353"></a><span id="l15.353">     // --- Optimization</span>
<a href="#l15.354"></a><span id="l15.354">     /**</span>
<a href="#l15.355"></a><span id="l15.355">      * Involves means any of from/to/cc/bcc.  The queries get ugly enough</span>
<a href="#l15.356"></a><span id="l15.356">      *  without this that it seems to justify the cost, especially given the</span>
<a href="#l15.357"></a><span id="l15.357">      *  frequent use case.  (In fact, post-filtering for the specific from/to/cc</span>
<a href="#l15.358"></a><span id="l15.358">      *  is probably justifiable rather than losing this attribute...)</span>
<a href="#l15.359"></a><span id="l15.359">      */</span>
<a href="#l15.360"></a><span id="l15.360" class="difflineat">@@ -361,65 +360,65 @@ var GlodaFundAttr = {</span>
<a href="#l15.361"></a><span id="l15.361">         type: &quot;default&quot;,</span>
<a href="#l15.362"></a><span id="l15.362">         /**</span>
<a href="#l15.363"></a><span id="l15.363">          * Filter out 'me', as we have other facets that deal with that, and the</span>
<a href="#l15.364"></a><span id="l15.364">          *  'me' identities are so likely that they distort things.</span>
<a href="#l15.365"></a><span id="l15.365">          *</span>
<a href="#l15.366"></a><span id="l15.366">          * @return true if the identity is not one of my identities, false if it</span>
<a href="#l15.367"></a><span id="l15.367">          *   is.</span>
<a href="#l15.368"></a><span id="l15.368">          */</span>
<a href="#l15.369"></a><span id="l15.369" class="difflineminus">-        filter: function gloda_explattr_involves_filter(aItem) {</span>
<a href="#l15.370"></a><span id="l15.370" class="difflineplus">+        filter(aItem) {</span>
<a href="#l15.371"></a><span id="l15.371">           return (!(aItem.id in Gloda.myIdentities));</span>
<a href="#l15.372"></a><span id="l15.372" class="difflineminus">-        }</span>
<a href="#l15.373"></a><span id="l15.373" class="difflineplus">+        },</span>
<a href="#l15.374"></a><span id="l15.374">       },</span>
<a href="#l15.375"></a><span id="l15.375">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.376"></a><span id="l15.376">       objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l15.377"></a><span id="l15.377" class="difflineminus">-      }); // not-tested</span>
<a href="#l15.378"></a><span id="l15.378" class="difflineplus">+    }); // not-tested</span>
<a href="#l15.379"></a><span id="l15.379"> </span>
<a href="#l15.380"></a><span id="l15.380">     /**</span>
<a href="#l15.381"></a><span id="l15.381">      * Any of to/cc/bcc.</span>
<a href="#l15.382"></a><span id="l15.382">      */</span>
<a href="#l15.383"></a><span id="l15.383">     this._attrRecipients = Gloda.defineAttribute({</span>
<a href="#l15.384"></a><span id="l15.384">       provider: this,</span>
<a href="#l15.385"></a><span id="l15.385">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.386"></a><span id="l15.386">       attributeType: Gloda.kAttrOptimization,</span>
<a href="#l15.387"></a><span id="l15.387">       attributeName: &quot;recipients&quot;,</span>
<a href="#l15.388"></a><span id="l15.388">       singular: false,</span>
<a href="#l15.389"></a><span id="l15.389">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.390"></a><span id="l15.390">       objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l15.391"></a><span id="l15.391" class="difflineminus">-      }); // not-tested</span>
<a href="#l15.392"></a><span id="l15.392" class="difflineplus">+    }); // not-tested</span>
<a href="#l15.393"></a><span id="l15.393"> </span>
<a href="#l15.394"></a><span id="l15.394">     // From Me (To/Cc/Bcc)</span>
<a href="#l15.395"></a><span id="l15.395">     this._attrFromMe = Gloda.defineAttribute({</span>
<a href="#l15.396"></a><span id="l15.396">       provider: this,</span>
<a href="#l15.397"></a><span id="l15.397">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.398"></a><span id="l15.398">       attributeType: Gloda.kAttrOptimization,</span>
<a href="#l15.399"></a><span id="l15.399">       attributeName: &quot;fromMe&quot;,</span>
<a href="#l15.400"></a><span id="l15.400">       singular: false,</span>
<a href="#l15.401"></a><span id="l15.401">       // The interesting thing to a facet is whether the message is from me.</span>
<a href="#l15.402"></a><span id="l15.402">       facet: {</span>
<a href="#l15.403"></a><span id="l15.403" class="difflineminus">-        type: &quot;nonempty?&quot;</span>
<a href="#l15.404"></a><span id="l15.404" class="difflineplus">+        type: &quot;nonempty?&quot;,</span>
<a href="#l15.405"></a><span id="l15.405">       },</span>
<a href="#l15.406"></a><span id="l15.406">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.407"></a><span id="l15.407">       objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l15.408"></a><span id="l15.408" class="difflineminus">-      }); // not-tested</span>
<a href="#l15.409"></a><span id="l15.409" class="difflineplus">+    }); // not-tested</span>
<a href="#l15.410"></a><span id="l15.410">     // To/Cc/Bcc Me</span>
<a href="#l15.411"></a><span id="l15.411">     this._attrToMe = Gloda.defineAttribute({</span>
<a href="#l15.412"></a><span id="l15.412">       provider: this,</span>
<a href="#l15.413"></a><span id="l15.413">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l15.414"></a><span id="l15.414">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.415"></a><span id="l15.415">       attributeName: &quot;toMe&quot;,</span>
<a href="#l15.416"></a><span id="l15.416">       // The interesting thing to a facet is whether the message is to me.</span>
<a href="#l15.417"></a><span id="l15.417">       facet: {</span>
<a href="#l15.418"></a><span id="l15.418" class="difflineminus">-        type: &quot;nonempty?&quot;</span>
<a href="#l15.419"></a><span id="l15.419" class="difflineplus">+        type: &quot;nonempty?&quot;,</span>
<a href="#l15.420"></a><span id="l15.420">       },</span>
<a href="#l15.421"></a><span id="l15.421">       singular: false,</span>
<a href="#l15.422"></a><span id="l15.422">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.423"></a><span id="l15.423">       objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l15.424"></a><span id="l15.424" class="difflineminus">-      }); // not-tested</span>
<a href="#l15.425"></a><span id="l15.425" class="difflineplus">+    }); // not-tested</span>
<a href="#l15.426"></a><span id="l15.426"> </span>
<a href="#l15.427"></a><span id="l15.427"> </span>
<a href="#l15.428"></a><span id="l15.428">     // -- Mailing List</span>
<a href="#l15.429"></a><span id="l15.429">     // Non-singular, but a hard call.  Namely, it is obvious that a message can</span>
<a href="#l15.430"></a><span id="l15.430">     //  be addressed to multiple mailing lists.  However, I don't see how you</span>
<a href="#l15.431"></a><span id="l15.431">     //  could receive a message with more than one set of List-* headers,</span>
<a href="#l15.432"></a><span id="l15.432">     //  since each list-serve would each send you a copy.  Based on our current</span>
<a href="#l15.433"></a><span id="l15.433">     //  decision to treat each physical message as separate, it almost seems</span>
<a href="#l15.434"></a><span id="l15.434" class="difflineat">@@ -439,33 +438,32 @@ var GlodaFundAttr = {</span>
<a href="#l15.435"></a><span id="l15.435">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l15.436"></a><span id="l15.436">                         attributeName: &quot;mailing-list&quot;,</span>
<a href="#l15.437"></a><span id="l15.437">                         bindName: &quot;mailingLists&quot;,</span>
<a href="#l15.438"></a><span id="l15.438">                         singular: false,</span>
<a href="#l15.439"></a><span id="l15.439">                         emptySetIsSignificant: true,</span>
<a href="#l15.440"></a><span id="l15.440">                         facet: true,</span>
<a href="#l15.441"></a><span id="l15.441">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l15.442"></a><span id="l15.442">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l15.443"></a><span id="l15.443" class="difflineminus">-                        }); // not-tested, not-implemented</span>
<a href="#l15.444"></a><span id="l15.444" class="difflineplus">+                      }); // not-tested, not-implemented</span>
<a href="#l15.445"></a><span id="l15.445">   },</span>
<a href="#l15.446"></a><span id="l15.446"> </span>
<a href="#l15.447"></a><span id="l15.447">   RE_LIST_POST: /&lt;mailto:([^&gt;]+)&gt;/,</span>
<a href="#l15.448"></a><span id="l15.448"> </span>
<a href="#l15.449"></a><span id="l15.449">   /**</span>
<a href="#l15.450"></a><span id="l15.450">    *</span>
<a href="#l15.451"></a><span id="l15.451">    * Specializations:</span>
<a href="#l15.452"></a><span id="l15.452">    * - Mailing Lists.  Replies to a message on a mailing list frequently only</span>
<a href="#l15.453"></a><span id="l15.453">    *   have the list-serve as the 'to', so we try to generate a synthetic 'to'</span>
<a href="#l15.454"></a><span id="l15.454">    *   based on the author of the parent message when possible.  (The 'possible'</span>
<a href="#l15.455"></a><span id="l15.455">    *   part is that we may not have a copy of the parent message at the time of</span>
<a href="#l15.456"></a><span id="l15.456">    *   processing.)</span>
<a href="#l15.457"></a><span id="l15.457">    * - Newsgroups.  Same deal as mailing lists.</span>
<a href="#l15.458"></a><span id="l15.458">    */</span>
<a href="#l15.459"></a><span id="l15.459" class="difflineminus">-  process: function* gloda_fundattr_process(aGlodaMessage, aRawReps,</span>
<a href="#l15.460"></a><span id="l15.460" class="difflineminus">-                                            aIsNew, aCallbackHandle) {</span>
<a href="#l15.461"></a><span id="l15.461" class="difflineplus">+  * process(aGlodaMessage, aRawReps, aIsNew, aCallbackHandle) {</span>
<a href="#l15.462"></a><span id="l15.462">     let aMsgHdr = aRawReps.header;</span>
<a href="#l15.463"></a><span id="l15.463">     let aMimeMsg = aRawReps.mime;</span>
<a href="#l15.464"></a><span id="l15.464"> </span>
<a href="#l15.465"></a><span id="l15.465">     // -- From</span>
<a href="#l15.466"></a><span id="l15.466">     // Let's use replyTo if available.</span>
<a href="#l15.467"></a><span id="l15.467">     // er, since we are just dealing with mailing lists for now, forget the</span>
<a href="#l15.468"></a><span id="l15.468">     //  reply-to...</span>
<a href="#l15.469"></a><span id="l15.469">     // TODO: deal with default charset issues</span>
<a href="#l15.470"></a><span id="l15.470" class="difflineat">@@ -577,18 +575,17 @@ var GlodaFundAttr = {</span>
<a href="#l15.471"></a><span id="l15.471">     // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l15.472"></a><span id="l15.472">     //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l15.473"></a><span id="l15.473">     //  available.  (which we'll simply pass to everyone... it can help body</span>
<a href="#l15.474"></a><span id="l15.474">     //  logic for quoting purposes, etc. too.)</span>
<a href="#l15.475"></a><span id="l15.475"> </span>
<a href="#l15.476"></a><span id="l15.476">     yield Gloda.kWorkDone;</span>
<a href="#l15.477"></a><span id="l15.477">   },</span>
<a href="#l15.478"></a><span id="l15.478"> </span>
<a href="#l15.479"></a><span id="l15.479" class="difflineminus">-  glodaAttFromMimeAtt:</span>
<a href="#l15.480"></a><span id="l15.480" class="difflineminus">-      function gloda_fundattr_glodaAttFromMimeAtt(aGlodaMessage, aAtt) {</span>
<a href="#l15.481"></a><span id="l15.481" class="difflineplus">+  glodaAttFromMimeAtt(aGlodaMessage, aAtt) {</span>
<a href="#l15.482"></a><span id="l15.482">     // So we don't want to store the URL because it can change over time if</span>
<a href="#l15.483"></a><span id="l15.483">     // the message is moved. What we do is store the full URL if it's a</span>
<a href="#l15.484"></a><span id="l15.484">     // detached attachment, otherwise just keep the part information, and</span>
<a href="#l15.485"></a><span id="l15.485">     // rebuild the URL according to where the message is sitting.</span>
<a href="#l15.486"></a><span id="l15.486">     let part, externalUrl;</span>
<a href="#l15.487"></a><span id="l15.487">     if (aAtt.isExternal) {</span>
<a href="#l15.488"></a><span id="l15.488">       externalUrl = aAtt.url;</span>
<a href="#l15.489"></a><span id="l15.489">     } else {</span>
<a href="#l15.490"></a><span id="l15.490" class="difflineat">@@ -602,19 +599,17 @@ var GlodaFundAttr = {</span>
<a href="#l15.491"></a><span id="l15.491">                                aAtt.name,</span>
<a href="#l15.492"></a><span id="l15.492">                                aAtt.contentType,</span>
<a href="#l15.493"></a><span id="l15.493">                                aAtt.size,</span>
<a href="#l15.494"></a><span id="l15.494">                                part,</span>
<a href="#l15.495"></a><span id="l15.495">                                externalUrl,</span>
<a href="#l15.496"></a><span id="l15.496">                                aAtt.isExternal);</span>
<a href="#l15.497"></a><span id="l15.497">   },</span>
<a href="#l15.498"></a><span id="l15.498"> </span>
<a href="#l15.499"></a><span id="l15.499" class="difflineminus">-  optimize: function* gloda_fundattr_optimize(aGlodaMessage, aRawReps,</span>
<a href="#l15.500"></a><span id="l15.500" class="difflineminus">-                                              aIsNew, aCallbackHandle) {</span>
<a href="#l15.501"></a><span id="l15.501" class="difflineminus">-</span>
<a href="#l15.502"></a><span id="l15.502" class="difflineplus">+  * optimize(aGlodaMessage, aRawReps, aIsNew, aCallbackHandle) {</span>
<a href="#l15.503"></a><span id="l15.503">     let aMsgHdr = aRawReps.header;</span>
<a href="#l15.504"></a><span id="l15.504"> </span>
<a href="#l15.505"></a><span id="l15.505">     // for simplicity this is used for both involves and recipients</span>
<a href="#l15.506"></a><span id="l15.506">     let involvesIdentities = {};</span>
<a href="#l15.507"></a><span id="l15.507">     let involves = aGlodaMessage.involves || [];</span>
<a href="#l15.508"></a><span id="l15.508">     let recipients = aGlodaMessage.recipients || [];</span>
<a href="#l15.509"></a><span id="l15.509"> </span>
<a href="#l15.510"></a><span id="l15.510">     // 'me' specialization optimizations</span>
<a href="#l15.511"></a><span id="l15.511" class="difflineat">@@ -628,24 +623,24 @@ var GlodaFundAttr = {</span>
<a href="#l15.512"></a><span id="l15.512">     // The fulltext search column for the author.  We want to have in here:</span>
<a href="#l15.513"></a><span id="l15.513">     // - The e-mail address and display name as enclosed on the message.</span>
<a href="#l15.514"></a><span id="l15.514">     // - The name per the address book card for this e-mail address, if we have</span>
<a href="#l15.515"></a><span id="l15.515">     //   one.</span>
<a href="#l15.516"></a><span id="l15.516">     aGlodaMessage._indexAuthor = aMsgHdr.mime2DecodedAuthor;</span>
<a href="#l15.517"></a><span id="l15.517">     // The fulltext search column for the recipients. (same deal)</span>
<a href="#l15.518"></a><span id="l15.518">     aGlodaMessage._indexRecipients = aMsgHdr.mime2DecodedRecipients;</span>
<a href="#l15.519"></a><span id="l15.519"> </span>
<a href="#l15.520"></a><span id="l15.520" class="difflineminus">-    if (isFromMe)</span>
<a href="#l15.521"></a><span id="l15.521" class="difflineplus">+    if (isFromMe) {</span>
<a href="#l15.522"></a><span id="l15.522">       aGlodaMessage.notability += this.NOTABILITY_FROM_ME;</span>
<a href="#l15.523"></a><span id="l15.523" class="difflineminus">-    else {</span>
<a href="#l15.524"></a><span id="l15.524" class="difflineplus">+    } else {</span>
<a href="#l15.525"></a><span id="l15.525">       let authorCard = authorIdentity.abCard;</span>
<a href="#l15.526"></a><span id="l15.526">       if (authorCard) {</span>
<a href="#l15.527"></a><span id="l15.527">         aGlodaMessage.notability += this.NOTABILITY_FROM_IN_ADDR_BOOK;</span>
<a href="#l15.528"></a><span id="l15.528">         // @testpoint gloda.noun.message.attr.authorMatches</span>
<a href="#l15.529"></a><span id="l15.529" class="difflineminus">-        aGlodaMessage._indexAuthor += ' ' + authorCard.displayName;</span>
<a href="#l15.530"></a><span id="l15.530" class="difflineplus">+        aGlodaMessage._indexAuthor += &quot; &quot; + authorCard.displayName;</span>
<a href="#l15.531"></a><span id="l15.531">       }</span>
<a href="#l15.532"></a><span id="l15.532">     }</span>
<a href="#l15.533"></a><span id="l15.533"> </span>
<a href="#l15.534"></a><span id="l15.534">     involves.push(authorIdentity);</span>
<a href="#l15.535"></a><span id="l15.535">     involvesIdentities[authorIdentity.id] = true;</span>
<a href="#l15.536"></a><span id="l15.536"> </span>
<a href="#l15.537"></a><span id="l15.537">     let involvedAddrBookCount = 0;</span>
<a href="#l15.538"></a><span id="l15.538"> </span>
<a href="#l15.539"></a><span id="l15.539" class="difflineat">@@ -653,17 +648,17 @@ var GlodaFundAttr = {</span>
<a href="#l15.540"></a><span id="l15.540">       if (!(toIdentity.id in involvesIdentities)) {</span>
<a href="#l15.541"></a><span id="l15.541">         involves.push(toIdentity);</span>
<a href="#l15.542"></a><span id="l15.542">         recipients.push(toIdentity);</span>
<a href="#l15.543"></a><span id="l15.543">         involvesIdentities[toIdentity.id] = true;</span>
<a href="#l15.544"></a><span id="l15.544">         let toCard = toIdentity.abCard;</span>
<a href="#l15.545"></a><span id="l15.545">         if (toCard) {</span>
<a href="#l15.546"></a><span id="l15.546">           involvedAddrBookCount++;</span>
<a href="#l15.547"></a><span id="l15.547">           // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l15.548"></a><span id="l15.548" class="difflineminus">-          aGlodaMessage._indexRecipients += ' ' + toCard.displayName;</span>
<a href="#l15.549"></a><span id="l15.549" class="difflineplus">+          aGlodaMessage._indexRecipients += &quot; &quot; + toCard.displayName;</span>
<a href="#l15.550"></a><span id="l15.550">         }</span>
<a href="#l15.551"></a><span id="l15.551">       }</span>
<a href="#l15.552"></a><span id="l15.552"> </span>
<a href="#l15.553"></a><span id="l15.553">       // optimization attribute to-me ('I' am the parameter)</span>
<a href="#l15.554"></a><span id="l15.554">       if (toIdentity.id in myIdentities) {</span>
<a href="#l15.555"></a><span id="l15.555">         toMe.push([toIdentity, authorIdentity]);</span>
<a href="#l15.556"></a><span id="l15.556">         if (aIsNew)</span>
<a href="#l15.557"></a><span id="l15.557">           authorIdentity.contact.popularity += this.POPULARITY_TO_ME;</span>
<a href="#l15.558"></a><span id="l15.558" class="difflineat">@@ -680,17 +675,17 @@ var GlodaFundAttr = {</span>
<a href="#l15.559"></a><span id="l15.559">       if (!(ccIdentity.id in involvesIdentities)) {</span>
<a href="#l15.560"></a><span id="l15.560">         involves.push(ccIdentity);</span>
<a href="#l15.561"></a><span id="l15.561">         recipients.push(ccIdentity);</span>
<a href="#l15.562"></a><span id="l15.562">         involvesIdentities[ccIdentity.id] = true;</span>
<a href="#l15.563"></a><span id="l15.563">         let ccCard = ccIdentity.abCard;</span>
<a href="#l15.564"></a><span id="l15.564">         if (ccCard) {</span>
<a href="#l15.565"></a><span id="l15.565">           involvedAddrBookCount++;</span>
<a href="#l15.566"></a><span id="l15.566">           // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l15.567"></a><span id="l15.567" class="difflineminus">-          aGlodaMessage._indexRecipients += ' ' + ccCard.displayName;</span>
<a href="#l15.568"></a><span id="l15.568" class="difflineplus">+          aGlodaMessage._indexRecipients += &quot; &quot; + ccCard.displayName;</span>
<a href="#l15.569"></a><span id="l15.569">         }</span>
<a href="#l15.570"></a><span id="l15.570">       }</span>
<a href="#l15.571"></a><span id="l15.571">       // optimization attribute cc-me ('I' am the parameter)</span>
<a href="#l15.572"></a><span id="l15.572">       if (ccIdentity.id in myIdentities) {</span>
<a href="#l15.573"></a><span id="l15.573">         toMe.push([ccIdentity, authorIdentity]);</span>
<a href="#l15.574"></a><span id="l15.574">         if (aIsNew)</span>
<a href="#l15.575"></a><span id="l15.575">           authorIdentity.contact.popularity += this.POPULARITY_CC_ME;</span>
<a href="#l15.576"></a><span id="l15.576">       }</span>
<a href="#l15.577"></a><span id="l15.577" class="difflineat">@@ -708,17 +703,17 @@ var GlodaFundAttr = {</span>
<a href="#l15.578"></a><span id="l15.578">       if (!(bccIdentity.id in involvesIdentities)) {</span>
<a href="#l15.579"></a><span id="l15.579">         involves.push(bccIdentity);</span>
<a href="#l15.580"></a><span id="l15.580">         recipients.push(bccIdentity);</span>
<a href="#l15.581"></a><span id="l15.581">         involvesIdentities[bccIdentity.id] = true;</span>
<a href="#l15.582"></a><span id="l15.582">         let bccCard = bccIdentity.abCard;</span>
<a href="#l15.583"></a><span id="l15.583">         if (bccCard) {</span>
<a href="#l15.584"></a><span id="l15.584">           involvedAddrBookCount++;</span>
<a href="#l15.585"></a><span id="l15.585">           // @testpoint gloda.noun.message.attr.recipientsMatch</span>
<a href="#l15.586"></a><span id="l15.586" class="difflineminus">-          aGlodaMessage._indexRecipients += ' ' + bccCard.displayName;</span>
<a href="#l15.587"></a><span id="l15.587" class="difflineplus">+          aGlodaMessage._indexRecipients += &quot; &quot; + bccCard.displayName;</span>
<a href="#l15.588"></a><span id="l15.588">         }</span>
<a href="#l15.589"></a><span id="l15.589">       }</span>
<a href="#l15.590"></a><span id="l15.590">       // optimization attribute cc-me ('I' am the parameter)</span>
<a href="#l15.591"></a><span id="l15.591">       if (bccIdentity.id in myIdentities) {</span>
<a href="#l15.592"></a><span id="l15.592">         toMe.push([bccIdentity, authorIdentity]);</span>
<a href="#l15.593"></a><span id="l15.593">         if (aIsNew)</span>
<a href="#l15.594"></a><span id="l15.594">           authorIdentity.contact.popularity += this.POPULARITY_BCC_ME;</span>
<a href="#l15.595"></a><span id="l15.595">       }</span>
<a href="#l15.596"></a><span id="l15.596" class="difflineat">@@ -745,30 +740,29 @@ var GlodaFundAttr = {</span>
<a href="#l15.597"></a><span id="l15.597">       aGlodaMessage.fromMe = fromMe;</span>
<a href="#l15.598"></a><span id="l15.598"> </span>
<a href="#l15.599"></a><span id="l15.599">     // Content</span>
<a href="#l15.600"></a><span id="l15.600">     if (aRawReps.bodyLines) {</span>
<a href="#l15.601"></a><span id="l15.601">       aGlodaMessage._content = aRawReps.content = new GlodaContent();</span>
<a href="#l15.602"></a><span id="l15.602">       if (this.contentWhittle({}, aRawReps.bodyLines, aGlodaMessage._content)) {</span>
<a href="#l15.603"></a><span id="l15.603">         // we were going to do something here?</span>
<a href="#l15.604"></a><span id="l15.604">       }</span>
<a href="#l15.605"></a><span id="l15.605" class="difflineminus">-    }</span>
<a href="#l15.606"></a><span id="l15.606" class="difflineminus">-    else {</span>
<a href="#l15.607"></a><span id="l15.607" class="difflineplus">+    } else {</span>
<a href="#l15.608"></a><span id="l15.608">       aRawReps.content = null;</span>
<a href="#l15.609"></a><span id="l15.609">     }</span>
<a href="#l15.610"></a><span id="l15.610"> </span>
<a href="#l15.611"></a><span id="l15.611">     yield Gloda.kWorkDone;</span>
<a href="#l15.612"></a><span id="l15.612">   },</span>
<a href="#l15.613"></a><span id="l15.613"> </span>
<a href="#l15.614"></a><span id="l15.614">   /**</span>
<a href="#l15.615"></a><span id="l15.615">    * Duplicates the notability logic from optimize().  Arguably optimize should</span>
<a href="#l15.616"></a><span id="l15.616">    *  be factored to call us, grokNounItem should be factored to call us, or we</span>
<a href="#l15.617"></a><span id="l15.617">    *  should get sufficiently fancy that our code wildly diverges.</span>
<a href="#l15.618"></a><span id="l15.618">    */</span>
<a href="#l15.619"></a><span id="l15.619" class="difflineminus">-  score: function gloda_fundattr_score(aMessage, aContext) {</span>
<a href="#l15.620"></a><span id="l15.620" class="difflineplus">+  score(aMessage, aContext) {</span>
<a href="#l15.621"></a><span id="l15.621">     let score = 0;</span>
<a href="#l15.622"></a><span id="l15.622"> </span>
<a href="#l15.623"></a><span id="l15.623">     let authorIdentity = aMessage.from;</span>
<a href="#l15.624"></a><span id="l15.624">     if (authorIdentity.id in Gloda.myIdentities)</span>
<a href="#l15.625"></a><span id="l15.625">       score += this.NOTABILITY_FROM_ME;</span>
<a href="#l15.626"></a><span id="l15.626">     else if (authorIdentity.inAddressBook)</span>
<a href="#l15.627"></a><span id="l15.627">       score += this.NOTABILITY_FROM_IN_ADDR_BOOK;</span>
<a href="#l15.628"></a><span id="l15.628">     if (aMessage.toMe)</span>
<a href="#l15.629"></a><span id="l15.629" class="difflineat">@@ -782,46 +776,41 @@ var GlodaFundAttr = {</span>
<a href="#l15.630"></a><span id="l15.630">       if (identity.inAddressBook)</span>
<a href="#l15.631"></a><span id="l15.631">         involvedAddrBookCount++;</span>
<a href="#l15.632"></a><span id="l15.632">     if (involvedAddrBookCount)</span>
<a href="#l15.633"></a><span id="l15.633">       score += this.NOTABILITY_INVOLVING_ADDR_BOOK_FIRST +</span>
<a href="#l15.634"></a><span id="l15.634">         (involvedAddrBookCount - 1) * this.NOTABILITY_INVOLVING_ADDR_BOOK_ADDL;</span>
<a href="#l15.635"></a><span id="l15.635">     return score;</span>
<a href="#l15.636"></a><span id="l15.636">   },</span>
<a href="#l15.637"></a><span id="l15.637"> </span>
<a href="#l15.638"></a><span id="l15.638" class="difflineminus">-  _countQuoteDepthAndNormalize:</span>
<a href="#l15.639"></a><span id="l15.639" class="difflineminus">-    function gloda_fundattr__countQuoteDepthAndNormalize(aLine) {</span>
<a href="#l15.640"></a><span id="l15.640" class="difflineplus">+  _countQuoteDepthAndNormalize(aLine) {</span>
<a href="#l15.641"></a><span id="l15.641">     let count = 0;</span>
<a href="#l15.642"></a><span id="l15.642">     let lastStartOffset = 0;</span>
<a href="#l15.643"></a><span id="l15.643"> </span>
<a href="#l15.644"></a><span id="l15.644">     for (let i = 0; i &lt; aLine.length; i++) {</span>
<a href="#l15.645"></a><span id="l15.645">       let c = aLine[i];</span>
<a href="#l15.646"></a><span id="l15.646">       if (c == &quot;&gt;&quot;) {</span>
<a href="#l15.647"></a><span id="l15.647">         count++;</span>
<a href="#l15.648"></a><span id="l15.648" class="difflineminus">-        lastStartOffset = i+1;</span>
<a href="#l15.649"></a><span id="l15.649" class="difflineminus">-      }</span>
<a href="#l15.650"></a><span id="l15.650" class="difflineminus">-      else if (c == &quot; &quot;) {</span>
<a href="#l15.651"></a><span id="l15.651" class="difflineminus">-      }</span>
<a href="#l15.652"></a><span id="l15.652" class="difflineminus">-      else {</span>
<a href="#l15.653"></a><span id="l15.653" class="difflineplus">+        lastStartOffset = i + 1;</span>
<a href="#l15.654"></a><span id="l15.654" class="difflineplus">+      } else if (c != &quot; &quot;) {</span>
<a href="#l15.655"></a><span id="l15.655">         return [count,</span>
<a href="#l15.656"></a><span id="l15.656">                 lastStartOffset ? aLine.substring(lastStartOffset) : aLine];</span>
<a href="#l15.657"></a><span id="l15.657">       }</span>
<a href="#l15.658"></a><span id="l15.658">     }</span>
<a href="#l15.659"></a><span id="l15.659"> </span>
<a href="#l15.660"></a><span id="l15.660">     return [count, lastStartOffset ? aLine.substring(lastStartOffset) : aLine];</span>
<a href="#l15.661"></a><span id="l15.661">   },</span>
<a href="#l15.662"></a><span id="l15.662"> </span>
<a href="#l15.663"></a><span id="l15.663">   /**</span>
<a href="#l15.664"></a><span id="l15.664">    * Attempt to understand simple quoting constructs that use &quot;&gt;&quot; with</span>
<a href="#l15.665"></a><span id="l15.665">    * obvious phrases to enter the quoting block.  No support for other types</span>
<a href="#l15.666"></a><span id="l15.666">    * of quoting at this time.  Also no support for piercing the wrapper of</span>
<a href="#l15.667"></a><span id="l15.667">    * forwarded messages to actually be the content of the forwarded message.</span>
<a href="#l15.668"></a><span id="l15.668">    */</span>
<a href="#l15.669"></a><span id="l15.669" class="difflineminus">-  contentWhittle: function gloda_fundattr_contentWhittle(aMeta,</span>
<a href="#l15.670"></a><span id="l15.670" class="difflineminus">-      aBodyLines, aContent) {</span>
<a href="#l15.671"></a><span id="l15.671" class="difflineplus">+  contentWhittle(aMeta, aBodyLines, aContent) {</span>
<a href="#l15.672"></a><span id="l15.672">     if (!aContent.volunteerContent(aContent.kPriorityBase))</span>
<a href="#l15.673"></a><span id="l15.673">       return false;</span>
<a href="#l15.674"></a><span id="l15.674"> </span>
<a href="#l15.675"></a><span id="l15.675">     // duplicate the list; we mutate somewhat...</span>
<a href="#l15.676"></a><span id="l15.676">     let bodyLines = aBodyLines.concat();</span>
<a href="#l15.677"></a><span id="l15.677"> </span>
<a href="#l15.678"></a><span id="l15.678">     // lastNonBlankLine originally was just for detecting quoting idioms where</span>
<a href="#l15.679"></a><span id="l15.679">     //  the &quot;wrote&quot; line was separated from the quoted block by a blank line.</span>
<a href="#l15.680"></a><span id="l15.680" class="difflineat">@@ -852,50 +841,45 @@ var GlodaFundAttr = {</span>
<a href="#l15.681"></a><span id="l15.681">               //  be the new lastNonBlankLine for the next logic block</span>
<a href="#l15.682"></a><span id="l15.682">               lastNonBlankLine = prevLastNonBlankLine;</span>
<a href="#l15.683"></a><span id="l15.683">             }</span>
<a href="#l15.684"></a><span id="l15.684">             // eat the trailing whitespace...</span>
<a href="#l15.685"></a><span id="l15.685">             if (lastNonBlankLine != null)</span>
<a href="#l15.686"></a><span id="l15.686">               rangeEnd = Math.min(rangeEnd, lastNonBlankLine);</span>
<a href="#l15.687"></a><span id="l15.687">           }</span>
<a href="#l15.688"></a><span id="l15.688">           if (rangeEnd &gt;= rangeStart)</span>
<a href="#l15.689"></a><span id="l15.689" class="difflineminus">-            aContent.content(aBodyLines.slice(rangeStart, rangeEnd+1));</span>
<a href="#l15.690"></a><span id="l15.690" class="difflineplus">+            aContent.content(aBodyLines.slice(rangeStart, rangeEnd + 1));</span>
<a href="#l15.691"></a><span id="l15.691"> </span>
<a href="#l15.692"></a><span id="l15.692">           [inQuoteDepth, line] = this._countQuoteDepthAndNormalize(line);</span>
<a href="#l15.693"></a><span id="l15.693">           bodyLines[iLine] = line;</span>
<a href="#l15.694"></a><span id="l15.694">           rangeStart = quoteRangeStart;</span>
<a href="#l15.695"></a><span id="l15.695" class="difflineminus">-        }</span>
<a href="#l15.696"></a><span id="l15.696" class="difflineminus">-        else {</span>
<a href="#l15.697"></a><span id="l15.697" class="difflineplus">+        } else {</span>
<a href="#l15.698"></a><span id="l15.698">           let curQuoteDepth;</span>
<a href="#l15.699"></a><span id="l15.699">           [curQuoteDepth, line] = this._countQuoteDepthAndNormalize(line);</span>
<a href="#l15.700"></a><span id="l15.700">           bodyLines[iLine] = line;</span>
<a href="#l15.701"></a><span id="l15.701"> </span>
<a href="#l15.702"></a><span id="l15.702">           if (curQuoteDepth != inQuoteDepth) {</span>
<a href="#l15.703"></a><span id="l15.703">             // we could do some &quot;wrote&quot; compensation here, but it's not really</span>
<a href="#l15.704"></a><span id="l15.704">             //  as important.  let's wait for a more clever algorithm.</span>
<a href="#l15.705"></a><span id="l15.705">             aContent.quoted(aBodyLines.slice(rangeStart, iLine), inQuoteDepth);</span>
<a href="#l15.706"></a><span id="l15.706">             inQuoteDepth = curQuoteDepth;</span>
<a href="#l15.707"></a><span id="l15.707">             rangeStart = iLine;</span>
<a href="#l15.708"></a><span id="l15.708">           }</span>
<a href="#l15.709"></a><span id="l15.709">         }</span>
<a href="#l15.710"></a><span id="l15.710" class="difflineminus">-      }</span>
<a href="#l15.711"></a><span id="l15.711" class="difflineminus">-      else {</span>
<a href="#l15.712"></a><span id="l15.712" class="difflineminus">-        if (inQuoteDepth) {</span>
<a href="#l15.713"></a><span id="l15.713" class="difflineminus">-          aContent.quoted(aBodyLines.slice(rangeStart, iLine), inQuoteDepth);</span>
<a href="#l15.714"></a><span id="l15.714" class="difflineminus">-          inQuoteDepth = 0;</span>
<a href="#l15.715"></a><span id="l15.715" class="difflineminus">-          rangeStart = iLine;</span>
<a href="#l15.716"></a><span id="l15.716" class="difflineminus">-        }</span>
<a href="#l15.717"></a><span id="l15.717" class="difflineplus">+      } else if (inQuoteDepth) {</span>
<a href="#l15.718"></a><span id="l15.718" class="difflineplus">+        aContent.quoted(aBodyLines.slice(rangeStart, iLine), inQuoteDepth);</span>
<a href="#l15.719"></a><span id="l15.719" class="difflineplus">+        inQuoteDepth = 0;</span>
<a href="#l15.720"></a><span id="l15.720" class="difflineplus">+        rangeStart = iLine;</span>
<a href="#l15.721"></a><span id="l15.721">       }</span>
<a href="#l15.722"></a><span id="l15.722"> </span>
<a href="#l15.723"></a><span id="l15.723">       prevLastNonBlankLine = lastNonBlankLine;</span>
<a href="#l15.724"></a><span id="l15.724">       lastNonBlankLine = iLine;</span>
<a href="#l15.725"></a><span id="l15.725">     }</span>
<a href="#l15.726"></a><span id="l15.726"> </span>
<a href="#l15.727"></a><span id="l15.727">     if (inQuoteDepth) {</span>
<a href="#l15.728"></a><span id="l15.728">       aContent.quoted(aBodyLines.slice(rangeStart), inQuoteDepth);</span>
<a href="#l15.729"></a><span id="l15.729" class="difflineminus">-    }</span>
<a href="#l15.730"></a><span id="l15.730" class="difflineminus">-    else {</span>
<a href="#l15.731"></a><span id="l15.731" class="difflineminus">-      aContent.content(aBodyLines.slice(rangeStart, lastNonBlankLine+1));</span>
<a href="#l15.732"></a><span id="l15.732" class="difflineplus">+    } else {</span>
<a href="#l15.733"></a><span id="l15.733" class="difflineplus">+      aContent.content(aBodyLines.slice(rangeStart, lastNonBlankLine + 1));</span>
<a href="#l15.734"></a><span id="l15.734">     }</span>
<a href="#l15.735"></a><span id="l15.735"> </span>
<a href="#l15.736"></a><span id="l15.736">     return true;</span>
<a href="#l15.737"></a><span id="l15.737">   },</span>
<a href="#l15.738"></a><span id="l15.738"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -1,13 +1,13 @@</span>
<a href="#l16.4"></a><span id="l16.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l16.5"></a><span id="l16.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l16.6"></a><span id="l16.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l16.7"></a><span id="l16.7"> </span>
<a href="#l16.8"></a><span id="l16.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['Gloda'];</span>
<a href="#l16.9"></a><span id="l16.9" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;Gloda&quot;];</span>
<a href="#l16.10"></a><span id="l16.10"> </span>
<a href="#l16.11"></a><span id="l16.11"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l16.12"></a><span id="l16.12"> </span>
<a href="#l16.13"></a><span id="l16.13"> const {GlodaDatastore} = ChromeUtils.import(&quot;resource:///modules/gloda/datastore.js&quot;);</span>
<a href="#l16.14"></a><span id="l16.14"> const {</span>
<a href="#l16.15"></a><span id="l16.15">   GlodaAttributeDBDef,</span>
<a href="#l16.16"></a><span id="l16.16">   GlodaAccount,</span>
<a href="#l16.17"></a><span id="l16.17">   GlodaConversation,</span>
<a href="#l16.18"></a><span id="l16.18" class="difflineat">@@ -30,19 +30,19 @@ const {MailServices} = ChromeUtils.impor</span>
<a href="#l16.19"></a><span id="l16.19"> </span>
<a href="#l16.20"></a><span id="l16.20"> /**</span>
<a href="#l16.21"></a><span id="l16.21">  * @see |Gloda.BadItemContentsError|</span>
<a href="#l16.22"></a><span id="l16.22">  */</span>
<a href="#l16.23"></a><span id="l16.23"> function BadItemContentsError(aMessage) {</span>
<a href="#l16.24"></a><span id="l16.24">   this.message = aMessage;</span>
<a href="#l16.25"></a><span id="l16.25"> }</span>
<a href="#l16.26"></a><span id="l16.26"> BadItemContentsError.prototype = {</span>
<a href="#l16.27"></a><span id="l16.27" class="difflineminus">-  toString: function BadItemContentsError_toString() {</span>
<a href="#l16.28"></a><span id="l16.28" class="difflineplus">+  toString() {</span>
<a href="#l16.29"></a><span id="l16.29">     return this.message;</span>
<a href="#l16.30"></a><span id="l16.30" class="difflineminus">-  }</span>
<a href="#l16.31"></a><span id="l16.31" class="difflineplus">+  },</span>
<a href="#l16.32"></a><span id="l16.32"> };</span>
<a href="#l16.33"></a><span id="l16.33"> </span>
<a href="#l16.34"></a><span id="l16.34"> </span>
<a href="#l16.35"></a><span id="l16.35"> /**</span>
<a href="#l16.36"></a><span id="l16.36">  * Provides the user-visible (and extension visible) global database</span>
<a href="#l16.37"></a><span id="l16.37">  *  functionality.  There is currently a dependency/ordering</span>
<a href="#l16.38"></a><span id="l16.38">  *  problem in that the concept of 'gloda' also includes some logic that is</span>
<a href="#l16.39"></a><span id="l16.39">  *  contributed by built-in extensions, if you will.  Those built-in extensions</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineat">@@ -135,29 +135,29 @@ var Gloda = {</span>
<a href="#l16.41"></a><span id="l16.41">    * Initialize logging, the datastore (SQLite database), the core nouns and</span>
<a href="#l16.42"></a><span id="l16.42">    *  attributes, and the contact and identities that belong to the presumed</span>
<a href="#l16.43"></a><span id="l16.43">    *  current user (based on accounts).</span>
<a href="#l16.44"></a><span id="l16.44">    *</span>
<a href="#l16.45"></a><span id="l16.45">    * Additional nouns and the core attribute providers are initialized by the</span>
<a href="#l16.46"></a><span id="l16.46">    *  everybody.js module which ensures all of those dependencies are loaded</span>
<a href="#l16.47"></a><span id="l16.47">    *  (and initialized).</span>
<a href="#l16.48"></a><span id="l16.48">    */</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineminus">-  _init: function gloda_ns_init() {</span>
<a href="#l16.50"></a><span id="l16.50" class="difflineplus">+  _init() {</span>
<a href="#l16.51"></a><span id="l16.51">     this._initLogging();</span>
<a href="#l16.52"></a><span id="l16.52">     GlodaDatastore._init(this._nounIDToDef);</span>
<a href="#l16.53"></a><span id="l16.53">     this._initAttributes();</span>
<a href="#l16.54"></a><span id="l16.54">     this._initMyIdentities();</span>
<a href="#l16.55"></a><span id="l16.55">   },</span>
<a href="#l16.56"></a><span id="l16.56"> </span>
<a href="#l16.57"></a><span id="l16.57">   _log: null,</span>
<a href="#l16.58"></a><span id="l16.58">   /**</span>
<a href="#l16.59"></a><span id="l16.59">    * Initialize logging; the error console window gets Warning/Error, and stdout</span>
<a href="#l16.60"></a><span id="l16.60">    *  (via dump) gets everything.</span>
<a href="#l16.61"></a><span id="l16.61">    */</span>
<a href="#l16.62"></a><span id="l16.62" class="difflineminus">-  _initLogging: function gloda_ns_initLogging() {</span>
<a href="#l16.63"></a><span id="l16.63" class="difflineplus">+  _initLogging() {</span>
<a href="#l16.64"></a><span id="l16.64">     let formatter = new Log4Moz.BasicFormatter();</span>
<a href="#l16.65"></a><span id="l16.65">     Log4Moz.repository.rootLogger.level = Log4Moz.Level.Debug;</span>
<a href="#l16.66"></a><span id="l16.66"> </span>
<a href="#l16.67"></a><span id="l16.67">     let enableConsoleLogging = false;</span>
<a href="#l16.68"></a><span id="l16.68">     let enableDumpLogging = false;</span>
<a href="#l16.69"></a><span id="l16.69">     // should we assume there is someone else consuming our log4moz stream?</span>
<a href="#l16.70"></a><span id="l16.70">     let enableUpstreamLogging = false;</span>
<a href="#l16.71"></a><span id="l16.71">     let considerNetLogging = false;</span>
<a href="#l16.72"></a><span id="l16.72" class="difflineat">@@ -280,18 +280,17 @@ var Gloda = {</span>
<a href="#l16.73"></a><span id="l16.73">    * @param aListener The listener that should be registered with the collection</span>
<a href="#l16.74"></a><span id="l16.74">    * @param aData The (optional) value to set as the data attribute on the</span>
<a href="#l16.75"></a><span id="l16.75">    *     collection.</span>
<a href="#l16.76"></a><span id="l16.76">    *</span>
<a href="#l16.77"></a><span id="l16.77">    * @return The collection that will receive the results.</span>
<a href="#l16.78"></a><span id="l16.78">    *</span>
<a href="#l16.79"></a><span id="l16.79">    * @testpoint gloda.ns.getMessageCollectionForHeader()</span>
<a href="#l16.80"></a><span id="l16.80">    */</span>
<a href="#l16.81"></a><span id="l16.81" class="difflineminus">-  getMessageCollectionForHeader: function gloda_ns_getMessageForHeader(aMsgHdr,</span>
<a href="#l16.82"></a><span id="l16.82" class="difflineminus">-      aListener, aData) {</span>
<a href="#l16.83"></a><span id="l16.83" class="difflineplus">+  getMessageCollectionForHeader(aMsgHdr, aListener, aData) {</span>
<a href="#l16.84"></a><span id="l16.84">     let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l16.85"></a><span id="l16.85">     query.folder(aMsgHdr.folder).messageKey(aMsgHdr.messageKey);</span>
<a href="#l16.86"></a><span id="l16.86">     return query.getCollection(aListener, aData);</span>
<a href="#l16.87"></a><span id="l16.87">   },</span>
<a href="#l16.88"></a><span id="l16.88"> </span>
<a href="#l16.89"></a><span id="l16.89">   /**</span>
<a href="#l16.90"></a><span id="l16.90">    * Given a list of message headers, return a collection containing the gloda</span>
<a href="#l16.91"></a><span id="l16.91">    *  messages that correspond to those headers.  Keep in mind that gloda may</span>
<a href="#l16.92"></a><span id="l16.92" class="difflineat">@@ -306,21 +305,19 @@ var Gloda = {</span>
<a href="#l16.93"></a><span id="l16.93">    * @param aListener The listener that should be registered with the collection</span>
<a href="#l16.94"></a><span id="l16.94">    * @param aData The (optional) value to set as the data attribute on the</span>
<a href="#l16.95"></a><span id="l16.95">    *     collection.</span>
<a href="#l16.96"></a><span id="l16.96">    *</span>
<a href="#l16.97"></a><span id="l16.97">    * @return The collection that will receive the results.</span>
<a href="#l16.98"></a><span id="l16.98">    *</span>
<a href="#l16.99"></a><span id="l16.99">    * @testpoint gloda.ns.getMessageCollectionForHeaders()</span>
<a href="#l16.100"></a><span id="l16.100">    */</span>
<a href="#l16.101"></a><span id="l16.101" class="difflineminus">-  getMessageCollectionForHeaders: function gloda_ns_getMessagesForHeaders(</span>
<a href="#l16.102"></a><span id="l16.102" class="difflineminus">-      aHeaders, aListener, aData) {</span>
<a href="#l16.103"></a><span id="l16.103" class="difflineplus">+  getMessageCollectionForHeaders(aHeaders, aListener, aData) {</span>
<a href="#l16.104"></a><span id="l16.104">     // group the headers by the folder they are found in</span>
<a href="#l16.105"></a><span id="l16.105">     let headersByFolder = {};</span>
<a href="#l16.106"></a><span id="l16.106" class="difflineminus">-    let iter;</span>
<a href="#l16.107"></a><span id="l16.107">     for (let header of fixIterator(aHeaders)) {</span>
<a href="#l16.108"></a><span id="l16.108">       let folderURI = header.folder.URI;</span>
<a href="#l16.109"></a><span id="l16.109">       let headersForFolder = headersByFolder[folderURI];</span>
<a href="#l16.110"></a><span id="l16.110">       if (headersForFolder === undefined)</span>
<a href="#l16.111"></a><span id="l16.111">         headersByFolder[folderURI] = [header];</span>
<a href="#l16.112"></a><span id="l16.112">       else</span>
<a href="#l16.113"></a><span id="l16.113">         headersForFolder.push(header);</span>
<a href="#l16.114"></a><span id="l16.114">     }</span>
<a href="#l16.115"></a><span id="l16.115" class="difflineat">@@ -343,21 +340,21 @@ var Gloda = {</span>
<a href="#l16.116"></a><span id="l16.116">     }</span>
<a href="#l16.117"></a><span id="l16.117"> </span>
<a href="#l16.118"></a><span id="l16.118">     return query.getCollection(aListener, aData);</span>
<a href="#l16.119"></a><span id="l16.119">   },</span>
<a href="#l16.120"></a><span id="l16.120"> </span>
<a href="#l16.121"></a><span id="l16.121">   /**</span>
<a href="#l16.122"></a><span id="l16.122">    * @testpoint gloda.ns.getMessageContent</span>
<a href="#l16.123"></a><span id="l16.123">    */</span>
<a href="#l16.124"></a><span id="l16.124" class="difflineminus">-  getMessageContent: function gloda_ns_getMessageContent(aGlodaMessage, aMimeMsg) {</span>
<a href="#l16.125"></a><span id="l16.125" class="difflineplus">+  getMessageContent(aGlodaMessage, aMimeMsg) {</span>
<a href="#l16.126"></a><span id="l16.126">     return mimeMsgToContentAndMeta(aMimeMsg, aGlodaMessage.folderMessage.folder)[0];</span>
<a href="#l16.127"></a><span id="l16.127">   },</span>
<a href="#l16.128"></a><span id="l16.128"> </span>
<a href="#l16.129"></a><span id="l16.129" class="difflineminus">-  getFolderForFolder: function gloda_ns_getFolderForFolder(aMsgFolder) {</span>
<a href="#l16.130"></a><span id="l16.130" class="difflineplus">+  getFolderForFolder(aMsgFolder) {</span>
<a href="#l16.131"></a><span id="l16.131">     return GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l16.132"></a><span id="l16.132">   },</span>
<a href="#l16.133"></a><span id="l16.133"> </span>
<a href="#l16.134"></a><span id="l16.134">   /**</span>
<a href="#l16.135"></a><span id="l16.135">    * Takes one or more strings containing lists of comma-delimited e-mail</span>
<a href="#l16.136"></a><span id="l16.136">    *  addresses with optional display names, and returns a list of sub-lists of</span>
<a href="#l16.137"></a><span id="l16.137">    *  identities, where each sub-list corresponds to each of the strings passed</span>
<a href="#l16.138"></a><span id="l16.138">    *  as arguments.  These identities are loaded from the database if they</span>
<a href="#l16.139"></a><span id="l16.139" class="difflineat">@@ -379,29 +376,27 @@ var Gloda = {</span>
<a href="#l16.140"></a><span id="l16.140">    *   they should be comma-delimited.  For example</span>
<a href="#l16.141"></a><span id="l16.141">    *   '&quot;Bob Smith&quot; &lt;bob@example.com&gt;' is an address with display name.  Mime</span>
<a href="#l16.142"></a><span id="l16.142">    *   header decoding is performed, but is ignorant of any folder-level</span>
<a href="#l16.143"></a><span id="l16.143">    *   character set overrides.</span>
<a href="#l16.144"></a><span id="l16.144">    * @returns via the callback handle mechanism, a list containing one sub-list</span>
<a href="#l16.145"></a><span id="l16.145">    *   for each string argument passed.  Each sub-list contains zero or more</span>
<a href="#l16.146"></a><span id="l16.146">    *   GlodaIdentity instances corresponding to the addresses provided.</span>
<a href="#l16.147"></a><span id="l16.147">    */</span>
<a href="#l16.148"></a><span id="l16.148" class="difflineminus">-  getOrCreateMailIdentities:</span>
<a href="#l16.149"></a><span id="l16.149" class="difflineminus">-      function* gloda_ns_getOrCreateMailIdentities(aCallbackHandle, ...aAddrGroups) {</span>
<a href="#l16.150"></a><span id="l16.150" class="difflineplus">+  * getOrCreateMailIdentities(aCallbackHandle, ...aAddrGroups) {</span>
<a href="#l16.151"></a><span id="l16.151">     let addresses = {};</span>
<a href="#l16.152"></a><span id="l16.152">     let resultLists = [];</span>
<a href="#l16.153"></a><span id="l16.153"> </span>
<a href="#l16.154"></a><span id="l16.154">     // parse the strings</span>
<a href="#l16.155"></a><span id="l16.155">     for (let aMailAddresses of aAddrGroups) {</span>
<a href="#l16.156"></a><span id="l16.156">       let parsed = GlodaUtils.parseMailAddresses(aMailAddresses);</span>
<a href="#l16.157"></a><span id="l16.157"> </span>
<a href="#l16.158"></a><span id="l16.158">       let resultList = [];</span>
<a href="#l16.159"></a><span id="l16.159">       resultLists.push(resultList);</span>
<a href="#l16.160"></a><span id="l16.160"> </span>
<a href="#l16.161"></a><span id="l16.161" class="difflineminus">-      let identities = [];</span>
<a href="#l16.162"></a><span id="l16.162">       for (let iAddress = 0; iAddress &lt; parsed.count; iAddress++) {</span>
<a href="#l16.163"></a><span id="l16.163">         let address = parsed.addresses[iAddress].toLowerCase();</span>
<a href="#l16.164"></a><span id="l16.164">         if (address in addresses)</span>
<a href="#l16.165"></a><span id="l16.165">           addresses[address].push(resultList);</span>
<a href="#l16.166"></a><span id="l16.166">         else</span>
<a href="#l16.167"></a><span id="l16.167">           addresses[address] = [parsed.names[iAddress], resultList];</span>
<a href="#l16.168"></a><span id="l16.168">       }</span>
<a href="#l16.169"></a><span id="l16.169">     }</span>
<a href="#l16.170"></a><span id="l16.170" class="difflineat">@@ -467,18 +462,17 @@ var Gloda = {</span>
<a href="#l16.171"></a><span id="l16.171">       let identity = GlodaDatastore.createIdentity(contact.id, contact,</span>
<a href="#l16.172"></a><span id="l16.172">         &quot;email&quot;, address, /* description */ &quot;&quot;, /* relay? */ false);</span>
<a href="#l16.173"></a><span id="l16.173">       contact._identities = [identity];</span>
<a href="#l16.174"></a><span id="l16.174"> </span>
<a href="#l16.175"></a><span id="l16.175">       // give the address book indexer a chance if we have a card.</span>
<a href="#l16.176"></a><span id="l16.176">       // (it will fix-up the name based on the card as appropriate)</span>
<a href="#l16.177"></a><span id="l16.177">       if (card)</span>
<a href="#l16.178"></a><span id="l16.178">         yield aCallbackHandle.pushAndGo(</span>
<a href="#l16.179"></a><span id="l16.179" class="difflineminus">-          Gloda.grokNounItem(contact, {card: card}, true, true,</span>
<a href="#l16.180"></a><span id="l16.180" class="difflineminus">-                             aCallbackHandle));</span>
<a href="#l16.181"></a><span id="l16.181" class="difflineplus">+          Gloda.grokNounItem(contact, {card}, true, true, aCallbackHandle));</span>
<a href="#l16.182"></a><span id="l16.182">       else // grokNounItem will issue the insert for us...</span>
<a href="#l16.183"></a><span id="l16.183">         GlodaDatastore.insertContact(contact);</span>
<a href="#l16.184"></a><span id="l16.184"> </span>
<a href="#l16.185"></a><span id="l16.185">       for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++) {</span>
<a href="#l16.186"></a><span id="l16.186">         nameAndResultLists[iResList].push(identity);</span>
<a href="#l16.187"></a><span id="l16.187">       }</span>
<a href="#l16.188"></a><span id="l16.188">     }</span>
<a href="#l16.189"></a><span id="l16.189"> </span>
<a href="#l16.190"></a><span id="l16.190" class="difflineat">@@ -814,17 +808,17 @@ var Gloda = {</span>
<a href="#l16.191"></a><span id="l16.191">   _nounNameToNounID: {},</span>
<a href="#l16.192"></a><span id="l16.192">   /**</span>
<a href="#l16.193"></a><span id="l16.193">    * Maps noun IDs to noun definition dictionaries.  (Noun definition</span>
<a href="#l16.194"></a><span id="l16.194">    *  dictionaries provided to us at the time a noun was defined, plus some</span>
<a href="#l16.195"></a><span id="l16.195">    *  additional stuff we put in there.)</span>
<a href="#l16.196"></a><span id="l16.196">    */</span>
<a href="#l16.197"></a><span id="l16.197">   _nounIDToDef: {},</span>
<a href="#l16.198"></a><span id="l16.198"> </span>
<a href="#l16.199"></a><span id="l16.199" class="difflineminus">-  _managedToJSON: function gloda_ns_managedToJSON(aItem) {</span>
<a href="#l16.200"></a><span id="l16.200" class="difflineplus">+  _managedToJSON(aItem) {</span>
<a href="#l16.201"></a><span id="l16.201">     return aItem.id;</span>
<a href="#l16.202"></a><span id="l16.202">   },</span>
<a href="#l16.203"></a><span id="l16.203"> </span>
<a href="#l16.204"></a><span id="l16.204">   /**</span>
<a href="#l16.205"></a><span id="l16.205">    * Define a noun.  Takes a dictionary with the following keys/values:</span>
<a href="#l16.206"></a><span id="l16.206">    *</span>
<a href="#l16.207"></a><span id="l16.207">    * @param aNounDef.name The name of the noun.  This is not a display name</span>
<a href="#l16.208"></a><span id="l16.208">    *     (anything being displayed needs to be localized, after all), but simply</span>
<a href="#l16.209"></a><span id="l16.209" class="difflineat">@@ -875,17 +869,17 @@ var Gloda = {</span>
<a href="#l16.210"></a><span id="l16.210">    *       how the attributes are poked into your object (for example, you want</span>
<a href="#l16.211"></a><span id="l16.211">    *       underscores used for some of them because the attributes should be</span>
<a href="#l16.212"></a><span id="l16.212">    *       immutable), then you can include a third string that is the name of</span>
<a href="#l16.213"></a><span id="l16.213">    *       the attribute to use.</span>
<a href="#l16.214"></a><span id="l16.214">    *     - indices A dictionary of lists of column names, where the key name</span>
<a href="#l16.215"></a><span id="l16.215">    *       becomes the index name.  Ex: {foo: [&quot;bar&quot;]} results in an index on</span>
<a href="#l16.216"></a><span id="l16.216">    *       the column &quot;bar&quot; where the index is named &quot;foo&quot;.</span>
<a href="#l16.217"></a><span id="l16.217">   */</span>
<a href="#l16.218"></a><span id="l16.218" class="difflineminus">-  defineNoun: function gloda_ns_defineNoun(aNounDef, aNounID) {</span>
<a href="#l16.219"></a><span id="l16.219" class="difflineplus">+  defineNoun(aNounDef, aNounID) {</span>
<a href="#l16.220"></a><span id="l16.220">     this._log.info(&quot;Defining noun: &quot; + aNounDef.name);</span>
<a href="#l16.221"></a><span id="l16.221">     if (aNounID === undefined)</span>
<a href="#l16.222"></a><span id="l16.222">       aNounID = this._nextNounID++;</span>
<a href="#l16.223"></a><span id="l16.223">     aNounDef.id = aNounID;</span>
<a href="#l16.224"></a><span id="l16.224"> </span>
<a href="#l16.225"></a><span id="l16.225">     // Let people whose editors get angry about illegal attribute names use</span>
<a href="#l16.226"></a><span id="l16.226">     //  clazz instead of class.</span>
<a href="#l16.227"></a><span id="l16.227">     if (aNounDef.clazz)</span>
<a href="#l16.228"></a><span id="l16.228" class="difflineat">@@ -909,21 +903,21 @@ var Gloda = {</span>
<a href="#l16.229"></a><span id="l16.229">           aNounDef.tableName = &quot;ext_&quot; + aNounDef.schema.name;</span>
<a href="#l16.230"></a><span id="l16.230">         else</span>
<a href="#l16.231"></a><span id="l16.231">           aNounDef.tableName = &quot;ext_&quot; + aNounDef.name;</span>
<a href="#l16.232"></a><span id="l16.232">       }</span>
<a href="#l16.233"></a><span id="l16.233">       // this creates the data table and binder and hooks everything up</span>
<a href="#l16.234"></a><span id="l16.234">       GlodaDatastore.createNounTable(aNounDef);</span>
<a href="#l16.235"></a><span id="l16.235"> </span>
<a href="#l16.236"></a><span id="l16.236">       if (!aNounDef.toParamAndValue)</span>
<a href="#l16.237"></a><span id="l16.237" class="difflineminus">-        aNounDef.toParamAndValue = function (aThing) {</span>
<a href="#l16.238"></a><span id="l16.238" class="difflineplus">+        aNounDef.toParamAndValue = function(aThing) {</span>
<a href="#l16.239"></a><span id="l16.239">           if (aThing instanceof aNounDef.class)</span>
<a href="#l16.240"></a><span id="l16.240">             return [null, aThing.id];</span>
<a href="#l16.241"></a><span id="l16.241" class="difflineminus">-          else // assume they're just passing the id directly</span>
<a href="#l16.242"></a><span id="l16.242" class="difflineminus">-            return [null, aThing];</span>
<a href="#l16.243"></a><span id="l16.243" class="difflineplus">+          // assume they're just passing the id directly</span>
<a href="#l16.244"></a><span id="l16.244" class="difflineplus">+          return [null, aThing];</span>
<a href="#l16.245"></a><span id="l16.245">         };</span>
<a href="#l16.246"></a><span id="l16.246">     }</span>
<a href="#l16.247"></a><span id="l16.247"> </span>
<a href="#l16.248"></a><span id="l16.248">     // if it has a table, you can query on it.  seems straight-forward.</span>
<a href="#l16.249"></a><span id="l16.249">     if (aNounDef.tableName) {</span>
<a href="#l16.250"></a><span id="l16.250">       [aNounDef.queryClass, aNounDef.nullQueryClass,</span>
<a href="#l16.251"></a><span id="l16.251">        aNounDef.explicitQueryClass, aNounDef.wildcardQueryClass] =</span>
<a href="#l16.252"></a><span id="l16.252">           GlodaQueryClassFactory(aNounDef);</span>
<a href="#l16.253"></a><span id="l16.253" class="difflineat">@@ -965,29 +959,29 @@ var Gloda = {</span>
<a href="#l16.254"></a><span id="l16.254">     return aNounDef;</span>
<a href="#l16.255"></a><span id="l16.255">   },</span>
<a href="#l16.256"></a><span id="l16.256"> </span>
<a href="#l16.257"></a><span id="l16.257">   /**</span>
<a href="#l16.258"></a><span id="l16.258">    * Lookup a noun (ID) suitable for passing to defineAttribute's various</span>
<a href="#l16.259"></a><span id="l16.259">    *  noun arguments.  Throws an exception if the noun with the given name</span>
<a href="#l16.260"></a><span id="l16.260">    *  cannot be found; the assumption is that you can't live without the noun.</span>
<a href="#l16.261"></a><span id="l16.261">    */</span>
<a href="#l16.262"></a><span id="l16.262" class="difflineminus">-  lookupNoun: function gloda_ns_lookupNoun(aNounName) {</span>
<a href="#l16.263"></a><span id="l16.263" class="difflineplus">+  lookupNoun(aNounName) {</span>
<a href="#l16.264"></a><span id="l16.264">     if (aNounName in this._nounNameToNounID)</span>
<a href="#l16.265"></a><span id="l16.265">       return this._nounNameToNounID[aNounName];</span>
<a href="#l16.266"></a><span id="l16.266"> </span>
<a href="#l16.267"></a><span id="l16.267">     throw Error(&quot;Unable to locate noun with name '&quot; + aNounName + &quot;', but I &quot; +</span>
<a href="#l16.268"></a><span id="l16.268">                 &quot;do know about: &quot; +</span>
<a href="#l16.269"></a><span id="l16.269">                 Object.keys(this._nounNameToNounID).join(&quot;, &quot;));</span>
<a href="#l16.270"></a><span id="l16.270">   },</span>
<a href="#l16.271"></a><span id="l16.271"> </span>
<a href="#l16.272"></a><span id="l16.272">   /**</span>
<a href="#l16.273"></a><span id="l16.273">    * Lookup a noun def given a name.</span>
<a href="#l16.274"></a><span id="l16.274">    */</span>
<a href="#l16.275"></a><span id="l16.275" class="difflineminus">-  lookupNounDef: function gloda_ns_lookupNoun(aNounName) {</span>
<a href="#l16.276"></a><span id="l16.276" class="difflineplus">+  lookupNounDef(aNounName) {</span>
<a href="#l16.277"></a><span id="l16.277">     return this._nounIDToDef[this.lookupNoun(aNounName)];</span>
<a href="#l16.278"></a><span id="l16.278">   },</span>
<a href="#l16.279"></a><span id="l16.279"> </span>
<a href="#l16.280"></a><span id="l16.280"> </span>
<a href="#l16.281"></a><span id="l16.281">   /**</span>
<a href="#l16.282"></a><span id="l16.282">    * Define an action on a noun.  During the prototype stage, this was conceived</span>
<a href="#l16.283"></a><span id="l16.283">    *  of as a way to expose all the constraints possible given a noun.  For</span>
<a href="#l16.284"></a><span id="l16.284">    *  example, if you have an identity or a contact, you could use this to</span>
<a href="#l16.285"></a><span id="l16.285" class="difflineat">@@ -1020,26 +1014,26 @@ var Gloda = {</span>
<a href="#l16.286"></a><span id="l16.286">    *   example, a checkbox-heavy UI might display a checkbox for each constraint</span>
<a href="#l16.287"></a><span id="l16.287">    *   using shortName as the label.</span>
<a href="#l16.288"></a><span id="l16.288">    * - makeConstraint: A function that takes the attribute that is the source</span>
<a href="#l16.289"></a><span id="l16.289">    *   of the noun and the noun instance as arguments, and returns APV-style</span>
<a href="#l16.290"></a><span id="l16.290">    *   constraints.  Since the APV-style query mechanism is now deprecated,</span>
<a href="#l16.291"></a><span id="l16.291">    *   this signature is deprecated.  Probably the way to update this would be</span>
<a href="#l16.292"></a><span id="l16.292">    *   to pass in the query instance that constraints should be contributed to.</span>
<a href="#l16.293"></a><span id="l16.293">    */</span>
<a href="#l16.294"></a><span id="l16.294" class="difflineminus">-  defineNounAction: function gloda_ns_defineNounAction(aNounID, aActionMeta) {</span>
<a href="#l16.295"></a><span id="l16.295" class="difflineplus">+  defineNounAction(aNounID, aActionMeta) {</span>
<a href="#l16.296"></a><span id="l16.296">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l16.297"></a><span id="l16.297">     nounDef.actions.push(aActionMeta);</span>
<a href="#l16.298"></a><span id="l16.298">   },</span>
<a href="#l16.299"></a><span id="l16.299"> </span>
<a href="#l16.300"></a><span id="l16.300">   /**</span>
<a href="#l16.301"></a><span id="l16.301">    * Retrieve all of the actions (as defined using defineNounAction) for the</span>
<a href="#l16.302"></a><span id="l16.302">    *  given noun type (via noun ID) with the given action type (ex: filter).</span>
<a href="#l16.303"></a><span id="l16.303">    */</span>
<a href="#l16.304"></a><span id="l16.304" class="difflineminus">-  getNounActions: function gloda_ns_getNounActions(aNounID, aActionType) {</span>
<a href="#l16.305"></a><span id="l16.305" class="difflineplus">+  getNounActions(aNounID, aActionType) {</span>
<a href="#l16.306"></a><span id="l16.306">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l16.307"></a><span id="l16.307">     if (!nounDef)</span>
<a href="#l16.308"></a><span id="l16.308">       return [];</span>
<a href="#l16.309"></a><span id="l16.309">     return nounDef.actions.</span>
<a href="#l16.310"></a><span id="l16.310">       filter(action =&gt; !aActionType || (action.actionType == aActionType));</span>
<a href="#l16.311"></a><span id="l16.311">   },</span>
<a href="#l16.312"></a><span id="l16.312"> </span>
<a href="#l16.313"></a><span id="l16.313">   /** Attribute providers in the sequence to process them. */</span>
<a href="#l16.314"></a><span id="l16.314" class="difflineat">@@ -1060,104 +1054,96 @@ var Gloda = {</span>
<a href="#l16.315"></a><span id="l16.315">    *  issues are resolved via the everybody.js mechanism or something else.</span>
<a href="#l16.316"></a><span id="l16.316">    *  Right now, noun_tag defines the tag noun.  If we broke more of these out,</span>
<a href="#l16.317"></a><span id="l16.317">    *  we would probably want to move the 'class' code from datamodel.js, the</span>
<a href="#l16.318"></a><span id="l16.318">    *  SQL table def and helper code from datastore.js (and this code) to their</span>
<a href="#l16.319"></a><span id="l16.319">    *  own noun_*.js files.  There are some trade-offs to be made, and I think</span>
<a href="#l16.320"></a><span id="l16.320">    *  we can deal with those once we start to integrate lightning/calendar and</span>
<a href="#l16.321"></a><span id="l16.321">    *  our noun space gets large and more heterogeneous.</span>
<a href="#l16.322"></a><span id="l16.322">    */</span>
<a href="#l16.323"></a><span id="l16.323" class="difflineminus">-  _initAttributes: function gloda_ns_initAttributes() {</span>
<a href="#l16.324"></a><span id="l16.324" class="difflineplus">+  _initAttributes() {</span>
<a href="#l16.325"></a><span id="l16.325">     this.defineNoun({</span>
<a href="#l16.326"></a><span id="l16.326">       name: &quot;bool&quot;,</span>
<a href="#l16.327"></a><span id="l16.327">       clazz: Boolean, allowsArbitraryAttrs: false,</span>
<a href="#l16.328"></a><span id="l16.328">       isPrimitive: true,</span>
<a href="#l16.329"></a><span id="l16.329">       // favor true before false</span>
<a href="#l16.330"></a><span id="l16.330" class="difflineminus">-      comparator: function gloda_bool_comparator(a, b) {</span>
<a href="#l16.331"></a><span id="l16.331" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.332"></a><span id="l16.332">         if (a == null) {</span>
<a href="#l16.333"></a><span id="l16.333">           if (b == null)</span>
<a href="#l16.334"></a><span id="l16.334">             return 0;</span>
<a href="#l16.335"></a><span id="l16.335" class="difflineminus">-          else</span>
<a href="#l16.336"></a><span id="l16.336" class="difflineminus">-            return 1;</span>
<a href="#l16.337"></a><span id="l16.337" class="difflineminus">-        }</span>
<a href="#l16.338"></a><span id="l16.338" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.339"></a><span id="l16.339" class="difflineplus">+          return 1;</span>
<a href="#l16.340"></a><span id="l16.340" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.341"></a><span id="l16.341">           return -1;</span>
<a href="#l16.342"></a><span id="l16.342">         }</span>
<a href="#l16.343"></a><span id="l16.343">         return b - a;</span>
<a href="#l16.344"></a><span id="l16.344">       },</span>
<a href="#l16.345"></a><span id="l16.345" class="difflineminus">-      toParamAndValue: function(aBool) {</span>
<a href="#l16.346"></a><span id="l16.346" class="difflineplus">+      toParamAndValue(aBool) {</span>
<a href="#l16.347"></a><span id="l16.347">         return [null, aBool ? 1 : 0];</span>
<a href="#l16.348"></a><span id="l16.348">       }}, this.NOUN_BOOLEAN);</span>
<a href="#l16.349"></a><span id="l16.349">     this.defineNoun({</span>
<a href="#l16.350"></a><span id="l16.350">       name: &quot;number&quot;,</span>
<a href="#l16.351"></a><span id="l16.351">       clazz: Number, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l16.352"></a><span id="l16.352">       isPrimitive: true,</span>
<a href="#l16.353"></a><span id="l16.353" class="difflineminus">-      comparator: function gloda_number_comparator(a, b) {</span>
<a href="#l16.354"></a><span id="l16.354" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.355"></a><span id="l16.355">         if (a == null) {</span>
<a href="#l16.356"></a><span id="l16.356">           if (b == null)</span>
<a href="#l16.357"></a><span id="l16.357">             return 0;</span>
<a href="#l16.358"></a><span id="l16.358" class="difflineminus">-          else</span>
<a href="#l16.359"></a><span id="l16.359" class="difflineminus">-            return 1;</span>
<a href="#l16.360"></a><span id="l16.360" class="difflineminus">-        }</span>
<a href="#l16.361"></a><span id="l16.361" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.362"></a><span id="l16.362" class="difflineplus">+          return 1;</span>
<a href="#l16.363"></a><span id="l16.363" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.364"></a><span id="l16.364">           return -1;</span>
<a href="#l16.365"></a><span id="l16.365">         }</span>
<a href="#l16.366"></a><span id="l16.366">         return a - b;</span>
<a href="#l16.367"></a><span id="l16.367">       },</span>
<a href="#l16.368"></a><span id="l16.368" class="difflineminus">-      toParamAndValue: function(aNum) {</span>
<a href="#l16.369"></a><span id="l16.369" class="difflineplus">+      toParamAndValue(aNum) {</span>
<a href="#l16.370"></a><span id="l16.370">         return [null, aNum];</span>
<a href="#l16.371"></a><span id="l16.371">       }}, this.NOUN_NUMBER);</span>
<a href="#l16.372"></a><span id="l16.372">     this.defineNoun({</span>
<a href="#l16.373"></a><span id="l16.373">       name: &quot;string&quot;,</span>
<a href="#l16.374"></a><span id="l16.374">       clazz: String, allowsArbitraryAttrs: false,</span>
<a href="#l16.375"></a><span id="l16.375">       isPrimitive: true,</span>
<a href="#l16.376"></a><span id="l16.376" class="difflineminus">-      comparator: function gloda_string_comparator(a, b) {</span>
<a href="#l16.377"></a><span id="l16.377" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.378"></a><span id="l16.378">         if (a == null) {</span>
<a href="#l16.379"></a><span id="l16.379">           if (b == null)</span>
<a href="#l16.380"></a><span id="l16.380">             return 0;</span>
<a href="#l16.381"></a><span id="l16.381" class="difflineminus">-          else</span>
<a href="#l16.382"></a><span id="l16.382" class="difflineminus">-            return 1;</span>
<a href="#l16.383"></a><span id="l16.383" class="difflineminus">-        }</span>
<a href="#l16.384"></a><span id="l16.384" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.385"></a><span id="l16.385" class="difflineplus">+          return 1;</span>
<a href="#l16.386"></a><span id="l16.386" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.387"></a><span id="l16.387">           return -1;</span>
<a href="#l16.388"></a><span id="l16.388">         }</span>
<a href="#l16.389"></a><span id="l16.389">         return a.localeCompare(b);</span>
<a href="#l16.390"></a><span id="l16.390">       },</span>
<a href="#l16.391"></a><span id="l16.391" class="difflineminus">-      toParamAndValue: function(aString) {</span>
<a href="#l16.392"></a><span id="l16.392" class="difflineplus">+      toParamAndValue(aString) {</span>
<a href="#l16.393"></a><span id="l16.393">         return [null, aString];</span>
<a href="#l16.394"></a><span id="l16.394">       }}, this.NOUN_STRING);</span>
<a href="#l16.395"></a><span id="l16.395">     this.defineNoun({</span>
<a href="#l16.396"></a><span id="l16.396">       name: &quot;date&quot;,</span>
<a href="#l16.397"></a><span id="l16.397">       clazz: Date, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l16.398"></a><span id="l16.398">       isPrimitive: true,</span>
<a href="#l16.399"></a><span id="l16.399" class="difflineminus">-      comparator: function gloda_data_comparator(a, b) {</span>
<a href="#l16.400"></a><span id="l16.400" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.401"></a><span id="l16.401">         if (a == null) {</span>
<a href="#l16.402"></a><span id="l16.402">           if (b == null)</span>
<a href="#l16.403"></a><span id="l16.403">             return 0;</span>
<a href="#l16.404"></a><span id="l16.404" class="difflineminus">-          else</span>
<a href="#l16.405"></a><span id="l16.405" class="difflineminus">-            return 1;</span>
<a href="#l16.406"></a><span id="l16.406" class="difflineminus">-        }</span>
<a href="#l16.407"></a><span id="l16.407" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.408"></a><span id="l16.408" class="difflineplus">+          return 1;</span>
<a href="#l16.409"></a><span id="l16.409" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.410"></a><span id="l16.410">           return -1;</span>
<a href="#l16.411"></a><span id="l16.411">         }</span>
<a href="#l16.412"></a><span id="l16.412">         return a - b;</span>
<a href="#l16.413"></a><span id="l16.413">       },</span>
<a href="#l16.414"></a><span id="l16.414" class="difflineminus">-      toParamAndValue: function(aDate) {</span>
<a href="#l16.415"></a><span id="l16.415" class="difflineplus">+      toParamAndValue(aDate) {</span>
<a href="#l16.416"></a><span id="l16.416">         return [null, aDate.valueOf() * 1000];</span>
<a href="#l16.417"></a><span id="l16.417">       }}, this.NOUN_DATE);</span>
<a href="#l16.418"></a><span id="l16.418">     this.defineNoun({</span>
<a href="#l16.419"></a><span id="l16.419">       name: &quot;fulltext&quot;,</span>
<a href="#l16.420"></a><span id="l16.420">       clazz: String, allowsArbitraryAttrs: false, continuous: false,</span>
<a href="#l16.421"></a><span id="l16.421">       isPrimitive: true,</span>
<a href="#l16.422"></a><span id="l16.422" class="difflineminus">-      comparator: function gloda_fulltext_comparator(a, b) {</span>
<a href="#l16.423"></a><span id="l16.423" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.424"></a><span id="l16.424">         throw new Error(&quot;Fulltext nouns are not comparable!&quot;);</span>
<a href="#l16.425"></a><span id="l16.425">       },</span>
<a href="#l16.426"></a><span id="l16.426">       // as noted on NOUN_FULLTEXT, we just pass the string around.  it never</span>
<a href="#l16.427"></a><span id="l16.427">       //  hits the database, so it's okay.</span>
<a href="#l16.428"></a><span id="l16.428" class="difflineminus">-      toParamAndValue: function(aString) {</span>
<a href="#l16.429"></a><span id="l16.429" class="difflineplus">+      toParamAndValue(aString) {</span>
<a href="#l16.430"></a><span id="l16.430">         return [null, aString];</span>
<a href="#l16.431"></a><span id="l16.431">       }}, this.NOUN_FULLTEXT);</span>
<a href="#l16.432"></a><span id="l16.432"> </span>
<a href="#l16.433"></a><span id="l16.433">     this.defineNoun({</span>
<a href="#l16.434"></a><span id="l16.434">       name: &quot;folder&quot;,</span>
<a href="#l16.435"></a><span id="l16.435">       clazz: GlodaFolder,</span>
<a href="#l16.436"></a><span id="l16.436">       allowsArbitraryAttrs: false,</span>
<a href="#l16.437"></a><span id="l16.437">       isPrimitive: false,</span>
<a href="#l16.438"></a><span id="l16.438" class="difflineat">@@ -1168,17 +1154,17 @@ var Gloda = {</span>
<a href="#l16.439"></a><span id="l16.439">          *  the list of folders that match if gloda would index them.  This is</span>
<a href="#l16.440"></a><span id="l16.440">          *  unsuitable for producing a persistable constraint since it does not</span>
<a href="#l16.441"></a><span id="l16.441">          *  adapt for added/deleted folders.  However, it is sufficient for</span>
<a href="#l16.442"></a><span id="l16.442">          *  faceting.  Also, we don't persist constraints yet.</span>
<a href="#l16.443"></a><span id="l16.443">          *</span>
<a href="#l16.444"></a><span id="l16.444">          * @TODO The long-term solution is to move towards using arithmetic</span>
<a href="#l16.445"></a><span id="l16.445">          *     encoding on folder-id's like we use for MIME types and friends.</span>
<a href="#l16.446"></a><span id="l16.446">          */</span>
<a href="#l16.447"></a><span id="l16.447" class="difflineminus">-        Account: function(aAttrDef, aArguments) {</span>
<a href="#l16.448"></a><span id="l16.448" class="difflineplus">+        Account(aAttrDef, aArguments) {</span>
<a href="#l16.449"></a><span id="l16.449">           let folderValues = [];</span>
<a href="#l16.450"></a><span id="l16.450">           let seenRootFolders = {};</span>
<a href="#l16.451"></a><span id="l16.451">           for (let iArg = 0; iArg &lt; aArguments.length; iArg++) {</span>
<a href="#l16.452"></a><span id="l16.452">             let givenFolder = aArguments[iArg];</span>
<a href="#l16.453"></a><span id="l16.453">             let givenMsgFolder = givenFolder.getXPCOMFolder(</span>
<a href="#l16.454"></a><span id="l16.454">                                    givenFolder.kActivityFolderOnlyNoData);</span>
<a href="#l16.455"></a><span id="l16.455">             let rootFolder = givenMsgFolder.rootFolder;</span>
<a href="#l16.456"></a><span id="l16.456"> </span>
<a href="#l16.457"></a><span id="l16.457" class="difflineat">@@ -1203,87 +1189,80 @@ var Gloda = {</span>
<a href="#l16.458"></a><span id="l16.458">                 !(folder instanceof Ci.nsIMsgImapMailFolder))</span>
<a href="#l16.459"></a><span id="l16.459">                 continue;</span>
<a href="#l16.460"></a><span id="l16.460"> </span>
<a href="#l16.461"></a><span id="l16.461">               let glodaFolder = Gloda.getFolderForFolder(folder);</span>
<a href="#l16.462"></a><span id="l16.462">               folderValues.push(glodaFolder);</span>
<a href="#l16.463"></a><span id="l16.463">             }</span>
<a href="#l16.464"></a><span id="l16.464">           }</span>
<a href="#l16.465"></a><span id="l16.465">           return this._inConstraintHelper(aAttrDef, folderValues);</span>
<a href="#l16.466"></a><span id="l16.466" class="difflineminus">-        }</span>
<a href="#l16.467"></a><span id="l16.467" class="difflineplus">+        },</span>
<a href="#l16.468"></a><span id="l16.468">       },</span>
<a href="#l16.469"></a><span id="l16.469" class="difflineminus">-      comparator: function gloda_folder_comparator(a, b) {</span>
<a href="#l16.470"></a><span id="l16.470" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.471"></a><span id="l16.471">         if (a == null) {</span>
<a href="#l16.472"></a><span id="l16.472">           if (b == null)</span>
<a href="#l16.473"></a><span id="l16.473">             return 0;</span>
<a href="#l16.474"></a><span id="l16.474" class="difflineminus">-          else</span>
<a href="#l16.475"></a><span id="l16.475" class="difflineminus">-            return 1;</span>
<a href="#l16.476"></a><span id="l16.476" class="difflineminus">-        }</span>
<a href="#l16.477"></a><span id="l16.477" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.478"></a><span id="l16.478" class="difflineplus">+          return 1;</span>
<a href="#l16.479"></a><span id="l16.479" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.480"></a><span id="l16.480">           return -1;</span>
<a href="#l16.481"></a><span id="l16.481">         }</span>
<a href="#l16.482"></a><span id="l16.482">         return a.name.localeCompare(b.name);</span>
<a href="#l16.483"></a><span id="l16.483">       },</span>
<a href="#l16.484"></a><span id="l16.484" class="difflineminus">-      toParamAndValue: function(aFolderOrGlodaFolder) {</span>
<a href="#l16.485"></a><span id="l16.485" class="difflineplus">+      toParamAndValue(aFolderOrGlodaFolder) {</span>
<a href="#l16.486"></a><span id="l16.486">         if (aFolderOrGlodaFolder instanceof GlodaFolder)</span>
<a href="#l16.487"></a><span id="l16.487">           return [null, aFolderOrGlodaFolder.id];</span>
<a href="#l16.488"></a><span id="l16.488" class="difflineminus">-        else</span>
<a href="#l16.489"></a><span id="l16.489" class="difflineminus">-          return [null, GlodaDatastore._mapFolder(aFolderOrGlodaFolder).id];</span>
<a href="#l16.490"></a><span id="l16.490" class="difflineplus">+        return [null, GlodaDatastore._mapFolder(aFolderOrGlodaFolder).id];</span>
<a href="#l16.491"></a><span id="l16.491">       }}, this.NOUN_FOLDER);</span>
<a href="#l16.492"></a><span id="l16.492">     this.defineNoun({</span>
<a href="#l16.493"></a><span id="l16.493">       name: &quot;account&quot;,</span>
<a href="#l16.494"></a><span id="l16.494">       clazz: GlodaAccount,</span>
<a href="#l16.495"></a><span id="l16.495">       allowsArbitraryAttrs: false,</span>
<a href="#l16.496"></a><span id="l16.496">       isPrimitive: false,</span>
<a href="#l16.497"></a><span id="l16.497" class="difflineminus">-      equals: function(a, b) {</span>
<a href="#l16.498"></a><span id="l16.498" class="difflineplus">+      equals(a, b) {</span>
<a href="#l16.499"></a><span id="l16.499">         if (a &amp;&amp; !b || !a &amp;&amp; b)</span>
<a href="#l16.500"></a><span id="l16.500">           return false;</span>
<a href="#l16.501"></a><span id="l16.501">         if (!a &amp;&amp; !b)</span>
<a href="#l16.502"></a><span id="l16.502">           return true;</span>
<a href="#l16.503"></a><span id="l16.503">         return a.id == b.id;</span>
<a href="#l16.504"></a><span id="l16.504">       },</span>
<a href="#l16.505"></a><span id="l16.505" class="difflineminus">-      comparator: function gloda_account_comparator(a, b) {</span>
<a href="#l16.506"></a><span id="l16.506" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.507"></a><span id="l16.507">         if (a == null) {</span>
<a href="#l16.508"></a><span id="l16.508">           if (b == null)</span>
<a href="#l16.509"></a><span id="l16.509">             return 0;</span>
<a href="#l16.510"></a><span id="l16.510" class="difflineminus">-          else</span>
<a href="#l16.511"></a><span id="l16.511" class="difflineminus">-            return 1;</span>
<a href="#l16.512"></a><span id="l16.512" class="difflineminus">-        }</span>
<a href="#l16.513"></a><span id="l16.513" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.514"></a><span id="l16.514" class="difflineplus">+          return 1;</span>
<a href="#l16.515"></a><span id="l16.515" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.516"></a><span id="l16.516">           return -1;</span>
<a href="#l16.517"></a><span id="l16.517">         }</span>
<a href="#l16.518"></a><span id="l16.518">         return a.name.localeCompare(b.name);</span>
<a href="#l16.519"></a><span id="l16.519">       }}, this.NOUN_ACCOUNT);</span>
<a href="#l16.520"></a><span id="l16.520">     this.defineNoun({</span>
<a href="#l16.521"></a><span id="l16.521">       name: &quot;conversation&quot;,</span>
<a href="#l16.522"></a><span id="l16.522">       clazz: GlodaConversation,</span>
<a href="#l16.523"></a><span id="l16.523">       allowsArbitraryAttrs: false,</span>
<a href="#l16.524"></a><span id="l16.524">       isPrimitive: false,</span>
<a href="#l16.525"></a><span id="l16.525">       cache: true, cacheCost: 512,</span>
<a href="#l16.526"></a><span id="l16.526">       tableName: &quot;conversations&quot;,</span>
<a href="#l16.527"></a><span id="l16.527">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;conversationID&quot;,</span>
<a href="#l16.528"></a><span id="l16.528">       datastore: GlodaDatastore,</span>
<a href="#l16.529"></a><span id="l16.529">       objFromRow: GlodaDatastore._conversationFromRow,</span>
<a href="#l16.530"></a><span id="l16.530" class="difflineminus">-      comparator: function gloda_conversation_comparator(a, b) {</span>
<a href="#l16.531"></a><span id="l16.531" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.532"></a><span id="l16.532">         if (a == null) {</span>
<a href="#l16.533"></a><span id="l16.533">           if (b == null)</span>
<a href="#l16.534"></a><span id="l16.534">             return 0;</span>
<a href="#l16.535"></a><span id="l16.535" class="difflineminus">-          else</span>
<a href="#l16.536"></a><span id="l16.536" class="difflineminus">-            return 1;</span>
<a href="#l16.537"></a><span id="l16.537" class="difflineminus">-        }</span>
<a href="#l16.538"></a><span id="l16.538" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.539"></a><span id="l16.539" class="difflineplus">+          return 1;</span>
<a href="#l16.540"></a><span id="l16.540" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.541"></a><span id="l16.541">           return -1;</span>
<a href="#l16.542"></a><span id="l16.542">         }</span>
<a href="#l16.543"></a><span id="l16.543">         return a.subject.localeCompare(b.subject);</span>
<a href="#l16.544"></a><span id="l16.544">       },</span>
<a href="#l16.545"></a><span id="l16.545" class="difflineminus">-      toParamAndValue: function(aConversation) {</span>
<a href="#l16.546"></a><span id="l16.546" class="difflineplus">+      toParamAndValue(aConversation) {</span>
<a href="#l16.547"></a><span id="l16.547">         if (aConversation instanceof GlodaConversation)</span>
<a href="#l16.548"></a><span id="l16.548">           return [null, aConversation.id];</span>
<a href="#l16.549"></a><span id="l16.549" class="difflineminus">-        else // assume they're just passing the id directly</span>
<a href="#l16.550"></a><span id="l16.550" class="difflineminus">-          return [null, aConversation];</span>
<a href="#l16.551"></a><span id="l16.551" class="difflineplus">+        // assume they're just passing the id directly</span>
<a href="#l16.552"></a><span id="l16.552" class="difflineplus">+        return [null, aConversation];</span>
<a href="#l16.553"></a><span id="l16.553">       }}, this.NOUN_CONVERSATION);</span>
<a href="#l16.554"></a><span id="l16.554">     this.defineNoun({</span>
<a href="#l16.555"></a><span id="l16.555">       name: &quot;message&quot;,</span>
<a href="#l16.556"></a><span id="l16.556">       clazz: GlodaMessage,</span>
<a href="#l16.557"></a><span id="l16.557">       allowsArbitraryAttrs: true,</span>
<a href="#l16.558"></a><span id="l16.558">       isPrimitive: false,</span>
<a href="#l16.559"></a><span id="l16.559">       cache: true, cacheCost: 2048,</span>
<a href="#l16.560"></a><span id="l16.560">       tableName: &quot;messages&quot;,</span>
<a href="#l16.561"></a><span id="l16.561" class="difflineat">@@ -1297,140 +1276,134 @@ var Gloda = {</span>
<a href="#l16.562"></a><span id="l16.562">       dbQueryValidityConstraintSuffix:</span>
<a href="#l16.563"></a><span id="l16.563">         &quot; AND +deleted = 0 AND +folderID IS NOT NULL AND +messageKey IS NOT NULL&quot;,</span>
<a href="#l16.564"></a><span id="l16.564">       // This is what's used when we have no validity constraints, i.e. we allow</span>
<a href="#l16.565"></a><span id="l16.565">       // for ghost messages, which do not have a row in the messagesText table.</span>
<a href="#l16.566"></a><span id="l16.566">       dbQueryJoinMagicWithNoValidityConstraints:</span>
<a href="#l16.567"></a><span id="l16.567">         &quot; LEFT JOIN messagesText ON messages.id = messagesText.rowid&quot;,</span>
<a href="#l16.568"></a><span id="l16.568">       objInsert: GlodaDatastore.insertMessage,</span>
<a href="#l16.569"></a><span id="l16.569">       objUpdate: GlodaDatastore.updateMessage,</span>
<a href="#l16.570"></a><span id="l16.570" class="difflineminus">-      toParamAndValue: function(aMessage) {</span>
<a href="#l16.571"></a><span id="l16.571" class="difflineplus">+      toParamAndValue(aMessage) {</span>
<a href="#l16.572"></a><span id="l16.572">         if (aMessage instanceof GlodaMessage)</span>
<a href="#l16.573"></a><span id="l16.573">           return [null, aMessage.id];</span>
<a href="#l16.574"></a><span id="l16.574" class="difflineminus">-        else // assume they're just passing the id directly</span>
<a href="#l16.575"></a><span id="l16.575" class="difflineminus">-          return [null, aMessage];</span>
<a href="#l16.576"></a><span id="l16.576" class="difflineplus">+        // assume they're just passing the id directly</span>
<a href="#l16.577"></a><span id="l16.577" class="difflineplus">+        return [null, aMessage];</span>
<a href="#l16.578"></a><span id="l16.578">       }}, this.NOUN_MESSAGE);</span>
<a href="#l16.579"></a><span id="l16.579">     this.defineNoun({</span>
<a href="#l16.580"></a><span id="l16.580">       name: &quot;contact&quot;,</span>
<a href="#l16.581"></a><span id="l16.581">       clazz: GlodaContact,</span>
<a href="#l16.582"></a><span id="l16.582">       allowsArbitraryAttrs: true,</span>
<a href="#l16.583"></a><span id="l16.583">       isPrimitive: false,</span>
<a href="#l16.584"></a><span id="l16.584">       cache: true, cacheCost: 128,</span>
<a href="#l16.585"></a><span id="l16.585">       tableName: &quot;contacts&quot;,</span>
<a href="#l16.586"></a><span id="l16.586">       attrTableName: &quot;contactAttributes&quot;, attrIDColumnName: &quot;contactID&quot;,</span>
<a href="#l16.587"></a><span id="l16.587">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._contactFromRow,</span>
<a href="#l16.588"></a><span id="l16.588">       dbAttribAdjuster: GlodaDatastore.adjustAttributes,</span>
<a href="#l16.589"></a><span id="l16.589">       objInsert: GlodaDatastore.insertContact,</span>
<a href="#l16.590"></a><span id="l16.590">       objUpdate: GlodaDatastore.updateContact,</span>
<a href="#l16.591"></a><span id="l16.591" class="difflineminus">-      comparator: function gloda_contact_comparator(a, b) {</span>
<a href="#l16.592"></a><span id="l16.592" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.593"></a><span id="l16.593">         if (a == null) {</span>
<a href="#l16.594"></a><span id="l16.594">           if (b == null)</span>
<a href="#l16.595"></a><span id="l16.595">             return 0;</span>
<a href="#l16.596"></a><span id="l16.596" class="difflineminus">-          else</span>
<a href="#l16.597"></a><span id="l16.597" class="difflineminus">-            return 1;</span>
<a href="#l16.598"></a><span id="l16.598" class="difflineminus">-        }</span>
<a href="#l16.599"></a><span id="l16.599" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.600"></a><span id="l16.600" class="difflineplus">+          return 1;</span>
<a href="#l16.601"></a><span id="l16.601" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.602"></a><span id="l16.602">           return -1;</span>
<a href="#l16.603"></a><span id="l16.603">         }</span>
<a href="#l16.604"></a><span id="l16.604">         return a.name.localeCompare(b.name);</span>
<a href="#l16.605"></a><span id="l16.605">       },</span>
<a href="#l16.606"></a><span id="l16.606" class="difflineminus">-      toParamAndValue: function(aContact) {</span>
<a href="#l16.607"></a><span id="l16.607" class="difflineplus">+      toParamAndValue(aContact) {</span>
<a href="#l16.608"></a><span id="l16.608">         if (aContact instanceof GlodaContact)</span>
<a href="#l16.609"></a><span id="l16.609">           return [null, aContact.id];</span>
<a href="#l16.610"></a><span id="l16.610" class="difflineminus">-        else // assume they're just passing the id directly</span>
<a href="#l16.611"></a><span id="l16.611" class="difflineminus">-          return [null, aContact];</span>
<a href="#l16.612"></a><span id="l16.612" class="difflineplus">+        // assume they're just passing the id directly</span>
<a href="#l16.613"></a><span id="l16.613" class="difflineplus">+        return [null, aContact];</span>
<a href="#l16.614"></a><span id="l16.614">       }}, this.NOUN_CONTACT);</span>
<a href="#l16.615"></a><span id="l16.615">     this.defineNoun({</span>
<a href="#l16.616"></a><span id="l16.616">       name: &quot;identity&quot;,</span>
<a href="#l16.617"></a><span id="l16.617">       clazz: GlodaIdentity,</span>
<a href="#l16.618"></a><span id="l16.618">       allowsArbitraryAttrs: false,</span>
<a href="#l16.619"></a><span id="l16.619">       isPrimitive: false,</span>
<a href="#l16.620"></a><span id="l16.620">       cache: true, cacheCost: 128,</span>
<a href="#l16.621"></a><span id="l16.621">       usesUniqueValue: true,</span>
<a href="#l16.622"></a><span id="l16.622">       tableName: &quot;identities&quot;,</span>
<a href="#l16.623"></a><span id="l16.623">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._identityFromRow,</span>
<a href="#l16.624"></a><span id="l16.624">       /**</span>
<a href="#l16.625"></a><span id="l16.625">        * Short string is the contact name, long string includes the identity</span>
<a href="#l16.626"></a><span id="l16.626">        *  value too, delimited by a colon.  Not tremendously localizable.</span>
<a href="#l16.627"></a><span id="l16.627">        */</span>
<a href="#l16.628"></a><span id="l16.628" class="difflineminus">-      userVisibleString: function(aIdentity, aLong) {</span>
<a href="#l16.629"></a><span id="l16.629" class="difflineplus">+      userVisibleString(aIdentity, aLong) {</span>
<a href="#l16.630"></a><span id="l16.630">         if (!aLong)</span>
<a href="#l16.631"></a><span id="l16.631">           return aIdentity.contact.name;</span>
<a href="#l16.632"></a><span id="l16.632">         if (aIdentity.contact.name == aIdentity.value)</span>
<a href="#l16.633"></a><span id="l16.633">           return aIdentity.value;</span>
<a href="#l16.634"></a><span id="l16.634">         return aIdentity.contact.name + &quot; (&quot; + aIdentity.value + &quot;)&quot;;</span>
<a href="#l16.635"></a><span id="l16.635">       },</span>
<a href="#l16.636"></a><span id="l16.636" class="difflineminus">-      comparator: function gloda_identity_comparator(a, b) {</span>
<a href="#l16.637"></a><span id="l16.637" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.638"></a><span id="l16.638">         if (a == null) {</span>
<a href="#l16.639"></a><span id="l16.639">           if (b == null)</span>
<a href="#l16.640"></a><span id="l16.640">             return 0;</span>
<a href="#l16.641"></a><span id="l16.641" class="difflineminus">-          else</span>
<a href="#l16.642"></a><span id="l16.642" class="difflineminus">-            return 1;</span>
<a href="#l16.643"></a><span id="l16.643" class="difflineminus">-        }</span>
<a href="#l16.644"></a><span id="l16.644" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.645"></a><span id="l16.645" class="difflineplus">+          return 1;</span>
<a href="#l16.646"></a><span id="l16.646" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.647"></a><span id="l16.647">           return -1;</span>
<a href="#l16.648"></a><span id="l16.648">         }</span>
<a href="#l16.649"></a><span id="l16.649">         return a.contact.name.localeCompare(b.contact.name);</span>
<a href="#l16.650"></a><span id="l16.650">       },</span>
<a href="#l16.651"></a><span id="l16.651" class="difflineminus">-      toParamAndValue: function(aIdentity) {</span>
<a href="#l16.652"></a><span id="l16.652" class="difflineplus">+      toParamAndValue(aIdentity) {</span>
<a href="#l16.653"></a><span id="l16.653">         if (aIdentity instanceof GlodaIdentity)</span>
<a href="#l16.654"></a><span id="l16.654">           return [null, aIdentity.id];</span>
<a href="#l16.655"></a><span id="l16.655" class="difflineminus">-        else // assume they're just passing the id directly</span>
<a href="#l16.656"></a><span id="l16.656" class="difflineminus">-          return [null, aIdentity];</span>
<a href="#l16.657"></a><span id="l16.657" class="difflineplus">+        // assume they're just passing the id directly</span>
<a href="#l16.658"></a><span id="l16.658" class="difflineplus">+        return [null, aIdentity];</span>
<a href="#l16.659"></a><span id="l16.659">       }}, this.NOUN_IDENTITY);</span>
<a href="#l16.660"></a><span id="l16.660">     this.defineNoun({</span>
<a href="#l16.661"></a><span id="l16.661">       name: &quot;attachment-infos&quot;,</span>
<a href="#l16.662"></a><span id="l16.662">       clazz: GlodaAttachment,</span>
<a href="#l16.663"></a><span id="l16.663">       allowsArbitraryAttrs: false,</span>
<a href="#l16.664"></a><span id="l16.664">       isPrimitive: false,</span>
<a href="#l16.665"></a><span id="l16.665" class="difflineminus">-      toJSON: function (x) {</span>
<a href="#l16.666"></a><span id="l16.666" class="difflineplus">+      toJSON(x) {</span>
<a href="#l16.667"></a><span id="l16.667">           return [</span>
<a href="#l16.668"></a><span id="l16.668">             x._name,</span>
<a href="#l16.669"></a><span id="l16.669">             x._contentType,</span>
<a href="#l16.670"></a><span id="l16.670">             x._size,</span>
<a href="#l16.671"></a><span id="l16.671">             x._part,</span>
<a href="#l16.672"></a><span id="l16.672">             x._externalUrl,</span>
<a href="#l16.673"></a><span id="l16.673" class="difflineminus">-            x._isExternal</span>
<a href="#l16.674"></a><span id="l16.674" class="difflineminus">-          ]</span>
<a href="#l16.675"></a><span id="l16.675" class="difflineplus">+            x._isExternal,</span>
<a href="#l16.676"></a><span id="l16.676" class="difflineplus">+          ];</span>
<a href="#l16.677"></a><span id="l16.677">         },</span>
<a href="#l16.678"></a><span id="l16.678" class="difflineminus">-      fromJSON: function (x, aGlodaMessage) {</span>
<a href="#l16.679"></a><span id="l16.679" class="difflineplus">+      fromJSON(x, aGlodaMessage) {</span>
<a href="#l16.680"></a><span id="l16.680">           let [name, contentType, size, _part, _externalUrl, isExternal] = x;</span>
<a href="#l16.681"></a><span id="l16.681">           return new GlodaAttachment(aGlodaMessage, name, contentType, size, _part, _externalUrl, isExternal);</span>
<a href="#l16.682"></a><span id="l16.682">         },</span>
<a href="#l16.683"></a><span id="l16.683">       }, this.NOUN_ATTACHMENT);</span>
<a href="#l16.684"></a><span id="l16.684"> </span>
<a href="#l16.685"></a><span id="l16.685">     // parameterized identity is just two identities; we store the first one</span>
<a href="#l16.686"></a><span id="l16.686">     //  (whose value set must be very constrainted, like the 'me' identities)</span>
<a href="#l16.687"></a><span id="l16.687">     //  as the parameter, the second (which does not need to be constrained)</span>
<a href="#l16.688"></a><span id="l16.688">     //  as the value.</span>
<a href="#l16.689"></a><span id="l16.689">     this.defineNoun({</span>
<a href="#l16.690"></a><span id="l16.690">       name: &quot;parameterized-identity&quot;,</span>
<a href="#l16.691"></a><span id="l16.691">       clazz: null,</span>
<a href="#l16.692"></a><span id="l16.692">       allowsArbitraryAttrs: false,</span>
<a href="#l16.693"></a><span id="l16.693" class="difflineminus">-      comparator: function gloda_fulltext_comparator(a, b) {</span>
<a href="#l16.694"></a><span id="l16.694" class="difflineplus">+      comparator(a, b) {</span>
<a href="#l16.695"></a><span id="l16.695">         if (a == null) {</span>
<a href="#l16.696"></a><span id="l16.696">           if (b == null)</span>
<a href="#l16.697"></a><span id="l16.697">             return 0;</span>
<a href="#l16.698"></a><span id="l16.698" class="difflineminus">-          else</span>
<a href="#l16.699"></a><span id="l16.699" class="difflineminus">-            return 1;</span>
<a href="#l16.700"></a><span id="l16.700" class="difflineminus">-        }</span>
<a href="#l16.701"></a><span id="l16.701" class="difflineminus">-        else if (b == null) {</span>
<a href="#l16.702"></a><span id="l16.702" class="difflineplus">+          return 1;</span>
<a href="#l16.703"></a><span id="l16.703" class="difflineplus">+        } else if (b == null) {</span>
<a href="#l16.704"></a><span id="l16.704">           return -1;</span>
<a href="#l16.705"></a><span id="l16.705">         }</span>
<a href="#l16.706"></a><span id="l16.706">         // First sort by the first identity in the tuple</span>
<a href="#l16.707"></a><span id="l16.707">         // Since our general use-case is for the first guy to be &quot;me&quot;, we only</span>
<a href="#l16.708"></a><span id="l16.708">         //  compare the identity value, not the name.</span>
<a href="#l16.709"></a><span id="l16.709">         let fic = a[0].value.localeCompare(b[0].value);</span>
<a href="#l16.710"></a><span id="l16.710">         if (fic)</span>
<a href="#l16.711"></a><span id="l16.711">           return fic;</span>
<a href="#l16.712"></a><span id="l16.712">         // Next compare the second identity in the tuple, but use the contact</span>
<a href="#l16.713"></a><span id="l16.713">         //  this time to be consistent with our identity comparator.</span>
<a href="#l16.714"></a><span id="l16.714">         return a[1].contact.name.localeCompare(b[1].contact.name);</span>
<a href="#l16.715"></a><span id="l16.715">       },</span>
<a href="#l16.716"></a><span id="l16.716" class="difflineminus">-      computeDelta: function(aCurValues, aOldValues) {</span>
<a href="#l16.717"></a><span id="l16.717" class="difflineplus">+      computeDelta(aCurValues, aOldValues) {</span>
<a href="#l16.718"></a><span id="l16.718">         let oldMap = {};</span>
<a href="#l16.719"></a><span id="l16.719">         for (let tupe of aOldValues) {</span>
<a href="#l16.720"></a><span id="l16.720">           let [originIdentity, targetIdentity] = tupe;</span>
<a href="#l16.721"></a><span id="l16.721">           let targets = oldMap[originIdentity];</span>
<a href="#l16.722"></a><span id="l16.722">           if (targets === undefined)</span>
<a href="#l16.723"></a><span id="l16.723">             targets = oldMap[originIdentity] = {};</span>
<a href="#l16.724"></a><span id="l16.724">           targets[targetIdentity] = true;</span>
<a href="#l16.725"></a><span id="l16.725">         }</span>
<a href="#l16.726"></a><span id="l16.726" class="difflineat">@@ -1449,17 +1422,17 @@ var Gloda = {</span>
<a href="#l16.727"></a><span id="l16.727">           let targets = oldMap[originIdentity];</span>
<a href="#l16.728"></a><span id="l16.728">           for (let targetIdentity in targets) {</span>
<a href="#l16.729"></a><span id="l16.729">             removed.push([originIdentity, targetIdentity]);</span>
<a href="#l16.730"></a><span id="l16.730">           }</span>
<a href="#l16.731"></a><span id="l16.731">         }</span>
<a href="#l16.732"></a><span id="l16.732"> </span>
<a href="#l16.733"></a><span id="l16.733">         return [added, removed];</span>
<a href="#l16.734"></a><span id="l16.734">       },</span>
<a href="#l16.735"></a><span id="l16.735" class="difflineminus">-      contributeObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l16.736"></a><span id="l16.736" class="difflineplus">+      contributeObjDependencies(aJsonValues, aReferencesByNounID,</span>
<a href="#l16.737"></a><span id="l16.737">           aInverseReferencesByNounID) {</span>
<a href="#l16.738"></a><span id="l16.738">         // nothing to do with a zero-length list</span>
<a href="#l16.739"></a><span id="l16.739">         if (aJsonValues.length == 0)</span>
<a href="#l16.740"></a><span id="l16.740">           return false;</span>
<a href="#l16.741"></a><span id="l16.741"> </span>
<a href="#l16.742"></a><span id="l16.742">         let nounIdentityDef = Gloda._nounIDToDef[Gloda.NOUN_IDENTITY];</span>
<a href="#l16.743"></a><span id="l16.743">         let references = aReferencesByNounID[nounIdentityDef.id];</span>
<a href="#l16.744"></a><span id="l16.744">         if (references === undefined)</span>
<a href="#l16.745"></a><span id="l16.745" class="difflineat">@@ -1470,78 +1443,77 @@ var Gloda = {</span>
<a href="#l16.746"></a><span id="l16.746">           if (!(originIdentityID in references))</span>
<a href="#l16.747"></a><span id="l16.747">             references[originIdentityID] = null;</span>
<a href="#l16.748"></a><span id="l16.748">           if (!(targetIdentityID in references))</span>
<a href="#l16.749"></a><span id="l16.749">             references[targetIdentityID] = null;</span>
<a href="#l16.750"></a><span id="l16.750">         }</span>
<a href="#l16.751"></a><span id="l16.751"> </span>
<a href="#l16.752"></a><span id="l16.752">         return true;</span>
<a href="#l16.753"></a><span id="l16.753">       },</span>
<a href="#l16.754"></a><span id="l16.754" class="difflineminus">-      resolveObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l16.755"></a><span id="l16.755" class="difflineplus">+      resolveObjDependencies(aJsonValues, aReferencesByNounID,</span>
<a href="#l16.756"></a><span id="l16.756">           aInverseReferencesByNounID) {</span>
<a href="#l16.757"></a><span id="l16.757">         let references =</span>
<a href="#l16.758"></a><span id="l16.758">           aReferencesByNounID[Gloda.NOUN_IDENTITY];</span>
<a href="#l16.759"></a><span id="l16.759"> </span>
<a href="#l16.760"></a><span id="l16.760">         let results = [];</span>
<a href="#l16.761"></a><span id="l16.761">         for (let tupe of aJsonValues) {</span>
<a href="#l16.762"></a><span id="l16.762">           let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l16.763"></a><span id="l16.763">           results.push([references[originIdentityID],</span>
<a href="#l16.764"></a><span id="l16.764">                         references[targetIdentityID]]);</span>
<a href="#l16.765"></a><span id="l16.765">         }</span>
<a href="#l16.766"></a><span id="l16.766"> </span>
<a href="#l16.767"></a><span id="l16.767">         return results;</span>
<a href="#l16.768"></a><span id="l16.768">       },</span>
<a href="#l16.769"></a><span id="l16.769" class="difflineminus">-      toJSON: function (aIdentityTuple) {</span>
<a href="#l16.770"></a><span id="l16.770" class="difflineplus">+      toJSON(aIdentityTuple) {</span>
<a href="#l16.771"></a><span id="l16.771">         return [aIdentityTuple[0].id, aIdentityTuple[1].id];</span>
<a href="#l16.772"></a><span id="l16.772">       },</span>
<a href="#l16.773"></a><span id="l16.773" class="difflineminus">-      toParamAndValue: function(aIdentityTuple) {</span>
<a href="#l16.774"></a><span id="l16.774" class="difflineplus">+      toParamAndValue(aIdentityTuple) {</span>
<a href="#l16.775"></a><span id="l16.775">         return [aIdentityTuple[0].id, aIdentityTuple[1].id];</span>
<a href="#l16.776"></a><span id="l16.776">       }}, this.NOUN_PARAM_IDENTITY);</span>
<a href="#l16.777"></a><span id="l16.777"> </span>
<a href="#l16.778"></a><span id="l16.778">     GlodaDatastore.getAllAttributes();</span>
<a href="#l16.779"></a><span id="l16.779">   },</span>
<a href="#l16.780"></a><span id="l16.780"> </span>
<a href="#l16.781"></a><span id="l16.781">   /**</span>
<a href="#l16.782"></a><span id="l16.782">    * Create accessor functions to 'bind' an attribute to underlying normalized</span>
<a href="#l16.783"></a><span id="l16.783">    *  attribute storage, as well as creating the appropriate query object</span>
<a href="#l16.784"></a><span id="l16.784">    *  constraint helper functions.  This name is somewhat of a misnomer because</span>
<a href="#l16.785"></a><span id="l16.785">    *  special attributes are not 'bound' (because specific/non-generic per-class</span>
<a href="#l16.786"></a><span id="l16.786">    *  code provides the properties) but still depend on this method to</span>
<a href="#l16.787"></a><span id="l16.787">    *  establish their constraint helper methods.</span>
<a href="#l16.788"></a><span id="l16.788">    *</span>
<a href="#l16.789"></a><span id="l16.789">    * @XXX potentially rename to not suggest binding is required.</span>
<a href="#l16.790"></a><span id="l16.790">    */</span>
<a href="#l16.791"></a><span id="l16.791" class="difflineminus">-  _bindAttribute: function gloda_ns_bindAttr(aAttrDef, aSubjectNounDef) {</span>
<a href="#l16.792"></a><span id="l16.792" class="difflineplus">+  _bindAttribute(aAttrDef, aSubjectNounDef) {</span>
<a href="#l16.793"></a><span id="l16.793">     let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l16.794"></a><span id="l16.794"> </span>
<a href="#l16.795"></a><span id="l16.795">     // -- the query constraint helpers</span>
<a href="#l16.796"></a><span id="l16.796">     if (aSubjectNounDef.queryClass !== undefined) {</span>
<a href="#l16.797"></a><span id="l16.797">       let constrainer;</span>
<a href="#l16.798"></a><span id="l16.798">       let canQuery = true;</span>
<a href="#l16.799"></a><span id="l16.799">       if ((&quot;special&quot; in aAttrDef) &amp;&amp; (aAttrDef.special == this.kSpecialFulltext)) {</span>
<a href="#l16.800"></a><span id="l16.800">         constrainer = function(...aArgs) {</span>
<a href="#l16.801"></a><span id="l16.801">           let constraint = [GlodaDatastore.kConstraintFulltext, aAttrDef, ...aArgs];</span>
<a href="#l16.802"></a><span id="l16.802">           this._constraints.push(constraint);</span>
<a href="#l16.803"></a><span id="l16.803">           return this;</span>
<a href="#l16.804"></a><span id="l16.804">         };</span>
<a href="#l16.805"></a><span id="l16.805" class="difflineminus">-      }</span>
<a href="#l16.806"></a><span id="l16.806" class="difflineminus">-      else if (aAttrDef.canQuery || aAttrDef.attributeName.startsWith(&quot;_&quot;)) {</span>
<a href="#l16.807"></a><span id="l16.807" class="difflineplus">+      } else if (aAttrDef.canQuery || aAttrDef.attributeName.startsWith(&quot;_&quot;)) {</span>
<a href="#l16.808"></a><span id="l16.808">         constrainer = function(...aArgs) {</span>
<a href="#l16.809"></a><span id="l16.809">           let constraint = [GlodaDatastore.kConstraintIn, aAttrDef, ...aArgs];</span>
<a href="#l16.810"></a><span id="l16.810">           this._constraints.push(constraint);</span>
<a href="#l16.811"></a><span id="l16.811">           return this;</span>
<a href="#l16.812"></a><span id="l16.812">         };</span>
<a href="#l16.813"></a><span id="l16.813">       } else {</span>
<a href="#l16.814"></a><span id="l16.814">         constrainer = function() {</span>
<a href="#l16.815"></a><span id="l16.815">           throw new Error(</span>
<a href="#l16.816"></a><span id="l16.816" class="difflineminus">-              &quot;Cannot query on attribute &quot;+aAttrDef.attributeName</span>
<a href="#l16.817"></a><span id="l16.817" class="difflineplus">+              &quot;Cannot query on attribute &quot; + aAttrDef.attributeName</span>
<a href="#l16.818"></a><span id="l16.818">             + &quot; because its canQuery parameter hasn't been set to true.&quot;</span>
<a href="#l16.819"></a><span id="l16.819">             + &quot; Reading the comments about Gloda.defineAttribute may be a&quot;</span>
<a href="#l16.820"></a><span id="l16.820">             + &quot; sensible thing to do now.&quot;);</span>
<a href="#l16.821"></a><span id="l16.821" class="difflineminus">-        }</span>
<a href="#l16.822"></a><span id="l16.822" class="difflineplus">+        };</span>
<a href="#l16.823"></a><span id="l16.823">         canQuery = false;</span>
<a href="#l16.824"></a><span id="l16.824">       }</span>
<a href="#l16.825"></a><span id="l16.825"> </span>
<a href="#l16.826"></a><span id="l16.826">       aSubjectNounDef.queryClass.prototype[aAttrDef.boundName] = constrainer;</span>
<a href="#l16.827"></a><span id="l16.827"> </span>
<a href="#l16.828"></a><span id="l16.828">       // Don't bind extra query-able attributes if we're unable to perform a</span>
<a href="#l16.829"></a><span id="l16.829">       // search on the attribute.</span>
<a href="#l16.830"></a><span id="l16.830">       if (!canQuery)</span>
<a href="#l16.831"></a><span id="l16.831" class="difflineat">@@ -1647,17 +1619,17 @@ var Gloda = {</span>
<a href="#l16.832"></a><span id="l16.832">    *     NOUN_* constants or a dynamically registered noun type.</span>
<a href="#l16.833"></a><span id="l16.833">    * @param aAttrDef.objectNoun The object type (one of the NOUN_* constants or</span>
<a href="#l16.834"></a><span id="l16.834">    *     a dynamically registered noun types) that is the 'object' in the</span>
<a href="#l16.835"></a><span id="l16.835">    *     traditional RDF triple.  More pragmatically, in the database row used</span>
<a href="#l16.836"></a><span id="l16.836">    *     to represent an attribute, we store the subject (ex: message ID),</span>
<a href="#l16.837"></a><span id="l16.837">    *     attribute ID, and an integer which is the integer representation of the</span>
<a href="#l16.838"></a><span id="l16.838">    *     'object' whose type you are defining right here.</span>
<a href="#l16.839"></a><span id="l16.839">    */</span>
<a href="#l16.840"></a><span id="l16.840" class="difflineminus">-  defineAttribute: function gloda_ns_defineAttribute(aAttrDef) {</span>
<a href="#l16.841"></a><span id="l16.841" class="difflineplus">+  defineAttribute(aAttrDef) {</span>
<a href="#l16.842"></a><span id="l16.842">     // ensure required properties exist on aAttrDef</span>
<a href="#l16.843"></a><span id="l16.843">     if (!(&quot;provider&quot; in aAttrDef) ||</span>
<a href="#l16.844"></a><span id="l16.844">         !(&quot;extensionName&quot; in aAttrDef) ||</span>
<a href="#l16.845"></a><span id="l16.845">         !(&quot;attributeType&quot; in aAttrDef) ||</span>
<a href="#l16.846"></a><span id="l16.846">         !(&quot;attributeName&quot; in aAttrDef) ||</span>
<a href="#l16.847"></a><span id="l16.847">         !(&quot;singular&quot; in aAttrDef) ||</span>
<a href="#l16.848"></a><span id="l16.848">         !(&quot;subjectNouns&quot; in aAttrDef) ||</span>
<a href="#l16.849"></a><span id="l16.849">         !(&quot;objectNoun&quot; in aAttrDef))</span>
<a href="#l16.850"></a><span id="l16.850" class="difflineat">@@ -1666,17 +1638,17 @@ var Gloda = {</span>
<a href="#l16.851"></a><span id="l16.851">       throw Error(&quot;You omitted a required attribute defining property, please&quot; +</span>
<a href="#l16.852"></a><span id="l16.852">                   &quot; consult the documentation as penance.&quot;);</span>
<a href="#l16.853"></a><span id="l16.853"> </span>
<a href="#l16.854"></a><span id="l16.854">     // -- Fill in defaults</span>
<a href="#l16.855"></a><span id="l16.855">     if (!(&quot;emptySetIsSignificant&quot; in aAttrDef))</span>
<a href="#l16.856"></a><span id="l16.856">       aAttrDef.emptySetIsSignificant = false;</span>
<a href="#l16.857"></a><span id="l16.857"> </span>
<a href="#l16.858"></a><span id="l16.858">     if (!(&quot;canQuery&quot; in aAttrDef))</span>
<a href="#l16.859"></a><span id="l16.859" class="difflineminus">-      aAttrDef.canQuery = aAttrDef.facet ? true : false;</span>
<a href="#l16.860"></a><span id="l16.860" class="difflineplus">+      aAttrDef.canQuery = !!aAttrDef.facet;</span>
<a href="#l16.861"></a><span id="l16.861"> </span>
<a href="#l16.862"></a><span id="l16.862">     // return if the attribute has already been defined</span>
<a href="#l16.863"></a><span id="l16.863">     if (aAttrDef.dbDef)</span>
<a href="#l16.864"></a><span id="l16.864">       return aAttrDef;</span>
<a href="#l16.865"></a><span id="l16.865"> </span>
<a href="#l16.866"></a><span id="l16.866">     // - first time we've seen a provider init logic</span>
<a href="#l16.867"></a><span id="l16.867">     if (!(aAttrDef.provider.providerName in this._attrProviders)) {</span>
<a href="#l16.868"></a><span id="l16.868">       this._attrProviders[aAttrDef.provider.providerName] = [];</span>
<a href="#l16.869"></a><span id="l16.869" class="difflineat">@@ -1688,19 +1660,17 @@ var Gloda = {</span>
<a href="#l16.870"></a><span id="l16.870">     // -- Database Definition</span>
<a href="#l16.871"></a><span id="l16.871">     let attrDBDef;</span>
<a href="#l16.872"></a><span id="l16.872">     if (compoundName in GlodaDatastore._attributeDBDefs) {</span>
<a href="#l16.873"></a><span id="l16.873">       // the existence of the GlodaAttributeDBDef means that either it has</span>
<a href="#l16.874"></a><span id="l16.874">       //  already been fully defined, or has been loaded from the database but</span>
<a href="#l16.875"></a><span id="l16.875">       //  not yet 'bound' to a provider (and had important meta-info that</span>
<a href="#l16.876"></a><span id="l16.876">       //  doesn't go in the db copied over)</span>
<a href="#l16.877"></a><span id="l16.877">       attrDBDef = GlodaDatastore._attributeDBDefs[compoundName];</span>
<a href="#l16.878"></a><span id="l16.878" class="difflineminus">-    }</span>
<a href="#l16.879"></a><span id="l16.879" class="difflineminus">-    // we need to create the attribute definition in the database</span>
<a href="#l16.880"></a><span id="l16.880" class="difflineminus">-    else {</span>
<a href="#l16.881"></a><span id="l16.881" class="difflineplus">+    } else { // we need to create the attribute definition in the database</span>
<a href="#l16.882"></a><span id="l16.882">       let attrID = null;</span>
<a href="#l16.883"></a><span id="l16.883">       attrID = GlodaDatastore._createAttributeDef(aAttrDef.attributeType,</span>
<a href="#l16.884"></a><span id="l16.884">                                                   aAttrDef.extensionName,</span>
<a href="#l16.885"></a><span id="l16.885">                                                   aAttrDef.attributeName,</span>
<a href="#l16.886"></a><span id="l16.886">                                                   null);</span>
<a href="#l16.887"></a><span id="l16.887"> </span>
<a href="#l16.888"></a><span id="l16.888">       attrDBDef = new GlodaAttributeDBDef(GlodaDatastore, attrID, compoundName,</span>
<a href="#l16.889"></a><span id="l16.889">         aAttrDef.attributeType, aAttrDef.extensionName, aAttrDef.attributeName);</span>
<a href="#l16.890"></a><span id="l16.890" class="difflineat">@@ -1727,46 +1697,42 @@ var Gloda = {</span>
<a href="#l16.891"></a><span id="l16.891">         aFacetDef.groupIdAttr = aAttrDef.objectNounDef.idAttr;</span>
<a href="#l16.892"></a><span id="l16.892">       if (!(&quot;groupComparator&quot; in aFacetDef))</span>
<a href="#l16.893"></a><span id="l16.893">         aFacetDef.groupComparator = aAttrDef.objectNounDef.comparator;</span>
<a href="#l16.894"></a><span id="l16.894">       if (!(&quot;filter&quot; in aFacetDef))</span>
<a href="#l16.895"></a><span id="l16.895">         aFacetDef.filter = null;</span>
<a href="#l16.896"></a><span id="l16.896">     }</span>
<a href="#l16.897"></a><span id="l16.897">     // No facet attribute means no facet desired; set an explicit null so that</span>
<a href="#l16.898"></a><span id="l16.898">     //  code can check without doing an &quot;in&quot; check.</span>
<a href="#l16.899"></a><span id="l16.899" class="difflineminus">-    if (!(&quot;facet&quot; in aAttrDef))</span>
<a href="#l16.900"></a><span id="l16.900" class="difflineplus">+    if (!(&quot;facet&quot; in aAttrDef)) {</span>
<a href="#l16.901"></a><span id="l16.901">       aAttrDef.facet = null;</span>
<a href="#l16.902"></a><span id="l16.902" class="difflineminus">-    // Promote &quot;true&quot; facet values to the defaults.  Where attributes have</span>
<a href="#l16.903"></a><span id="l16.903" class="difflineminus">-    //  specified values, make sure we fill in any missing defaults.</span>
<a href="#l16.904"></a><span id="l16.904" class="difflineminus">-    else {</span>
<a href="#l16.905"></a><span id="l16.905" class="difflineminus">-      if (aAttrDef.facet == true) {</span>
<a href="#l16.906"></a><span id="l16.906" class="difflineminus">-        aAttrDef.facet = {</span>
<a href="#l16.907"></a><span id="l16.907" class="difflineminus">-          type: &quot;default&quot;,</span>
<a href="#l16.908"></a><span id="l16.908" class="difflineminus">-          groupIdAttr: aAttrDef.objectNounDef.idAttr,</span>
<a href="#l16.909"></a><span id="l16.909" class="difflineminus">-          groupComparator: aAttrDef.objectNounDef.comparator,</span>
<a href="#l16.910"></a><span id="l16.910" class="difflineminus">-          filter: null,</span>
<a href="#l16.911"></a><span id="l16.911" class="difflineminus">-        };</span>
<a href="#l16.912"></a><span id="l16.912" class="difflineminus">-      }</span>
<a href="#l16.913"></a><span id="l16.913" class="difflineminus">-      else {</span>
<a href="#l16.914"></a><span id="l16.914" class="difflineminus">-        normalizeFacetDef(aAttrDef.facet);</span>
<a href="#l16.915"></a><span id="l16.915" class="difflineminus">-      }</span>
<a href="#l16.916"></a><span id="l16.916" class="difflineplus">+    } else if (aAttrDef.facet === true) {</span>
<a href="#l16.917"></a><span id="l16.917" class="difflineplus">+      // Promote &quot;true&quot; facet values to the defaults.  Where attributes have</span>
<a href="#l16.918"></a><span id="l16.918" class="difflineplus">+      //  specified values, make sure we fill in any missing defaults.</span>
<a href="#l16.919"></a><span id="l16.919" class="difflineplus">+      aAttrDef.facet = {</span>
<a href="#l16.920"></a><span id="l16.920" class="difflineplus">+        type: &quot;default&quot;,</span>
<a href="#l16.921"></a><span id="l16.921" class="difflineplus">+        groupIdAttr: aAttrDef.objectNounDef.idAttr,</span>
<a href="#l16.922"></a><span id="l16.922" class="difflineplus">+        groupComparator: aAttrDef.objectNounDef.comparator,</span>
<a href="#l16.923"></a><span id="l16.923" class="difflineplus">+        filter: null,</span>
<a href="#l16.924"></a><span id="l16.924" class="difflineplus">+      };</span>
<a href="#l16.925"></a><span id="l16.925" class="difflineplus">+    } else {</span>
<a href="#l16.926"></a><span id="l16.926" class="difflineplus">+      normalizeFacetDef(aAttrDef.facet);</span>
<a href="#l16.927"></a><span id="l16.927">     }</span>
<a href="#l16.928"></a><span id="l16.928">     if (&quot;extraFacets&quot; in aAttrDef) {</span>
<a href="#l16.929"></a><span id="l16.929">       for (let facetDef of aAttrDef.extraFacets) {</span>
<a href="#l16.930"></a><span id="l16.930">         normalizeFacetDef(facetDef);</span>
<a href="#l16.931"></a><span id="l16.931">       }</span>
<a href="#l16.932"></a><span id="l16.932">     }</span>
<a href="#l16.933"></a><span id="l16.933"> </span>
<a href="#l16.934"></a><span id="l16.934">     function gatherLocalizedStrings(aBundle, aPropRoot, aStickIn) {</span>
<a href="#l16.935"></a><span id="l16.935">       for (let propName in Gloda._ATTR_LOCALIZED_STRINGS) {</span>
<a href="#l16.936"></a><span id="l16.936">         let attrName = Gloda._ATTR_LOCALIZED_STRINGS[propName];</span>
<a href="#l16.937"></a><span id="l16.937">         try {</span>
<a href="#l16.938"></a><span id="l16.938">           aStickIn[attrName] = aBundle.get(aPropRoot + propName);</span>
<a href="#l16.939"></a><span id="l16.939" class="difflineminus">-        }</span>
<a href="#l16.940"></a><span id="l16.940" class="difflineminus">-        catch (ex) {</span>
<a href="#l16.941"></a><span id="l16.941" class="difflineplus">+        } catch (ex) {</span>
<a href="#l16.942"></a><span id="l16.942">           // do nothing.  nsIStringBundle throws exceptions because it is a</span>
<a href="#l16.943"></a><span id="l16.943">           //  standard nsresult type of API and our helper buddy does nothing</span>
<a href="#l16.944"></a><span id="l16.944">           //  to help us.  (StringBundle.js, that is.)</span>
<a href="#l16.945"></a><span id="l16.945">         }</span>
<a href="#l16.946"></a><span id="l16.946">       }</span>
<a href="#l16.947"></a><span id="l16.947">     }</span>
<a href="#l16.948"></a><span id="l16.948"> </span>
<a href="#l16.949"></a><span id="l16.949">     // -- L10n.</span>
<a href="#l16.950"></a><span id="l16.950" class="difflineat">@@ -1800,18 +1766,17 @@ var Gloda = {</span>
<a href="#l16.951"></a><span id="l16.951">     // -- Subject Noun Binding</span>
<a href="#l16.952"></a><span id="l16.952">     for (let iSubject = 0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l16.953"></a><span id="l16.953">            iSubject++) {</span>
<a href="#l16.954"></a><span id="l16.954">       let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l16.955"></a><span id="l16.955">       let subjectNounDef = this._nounIDToDef[subjectType];</span>
<a href="#l16.956"></a><span id="l16.956">       this._bindAttribute(aAttrDef, subjectNounDef);</span>
<a href="#l16.957"></a><span id="l16.957"> </span>
<a href="#l16.958"></a><span id="l16.958">       // update the provider maps...</span>
<a href="#l16.959"></a><span id="l16.959" class="difflineminus">-      if (this._attrProviderOrderByNoun[subjectType]</span>
<a href="#l16.960"></a><span id="l16.960" class="difflineminus">-              .indexOf(aAttrDef.provider) == -1) {</span>
<a href="#l16.961"></a><span id="l16.961" class="difflineplus">+      if (!this._attrProviderOrderByNoun[subjectType].includes(aAttrDef.provider)) {</span>
<a href="#l16.962"></a><span id="l16.962">         this._attrProviderOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l16.963"></a><span id="l16.963">         if (aAttrDef.provider.optimize)</span>
<a href="#l16.964"></a><span id="l16.964">           this._attrOptimizerOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l16.965"></a><span id="l16.965">         this._attrProvidersByNoun[subjectType][aAttrDef.provider.providerName] = [];</span>
<a href="#l16.966"></a><span id="l16.966">       }</span>
<a href="#l16.967"></a><span id="l16.967">       this._attrProvidersByNoun[subjectType][aAttrDef.provider.providerName].push(aAttrDef);</span>
<a href="#l16.968"></a><span id="l16.968"> </span>
<a href="#l16.969"></a><span id="l16.969">       subjectNounDef.attribsByBoundName[aAttrDef.boundName] = aAttrDef;</span>
<a href="#l16.970"></a><span id="l16.970" class="difflineat">@@ -1843,17 +1808,17 @@ var Gloda = {</span>
<a href="#l16.971"></a><span id="l16.971">    * Retrieve the attribute provided by the given extension with the given</span>
<a href="#l16.972"></a><span id="l16.972">    *  attribute name.  The original idea was that plugins would effectively</span>
<a href="#l16.973"></a><span id="l16.973">    *  name-space attributes, helping avoid collisions.  Since we are leaning</span>
<a href="#l16.974"></a><span id="l16.974">    *  towards using binding heavily, this doesn't really help, as the collisions</span>
<a href="#l16.975"></a><span id="l16.975">    *  will just occur on the attribute name instead.  Also, this can turn</span>
<a href="#l16.976"></a><span id="l16.976">    *  extensions into liars as name changes/moves to core/etc. happen.</span>
<a href="#l16.977"></a><span id="l16.977">    * @TODO consider removing the extension name argument parameter requirement</span>
<a href="#l16.978"></a><span id="l16.978">    */</span>
<a href="#l16.979"></a><span id="l16.979" class="difflineminus">-  getAttrDef: function gloda_ns_getAttrDef(aPluginName, aAttrName) {</span>
<a href="#l16.980"></a><span id="l16.980" class="difflineplus">+  getAttrDef(aPluginName, aAttrName) {</span>
<a href="#l16.981"></a><span id="l16.981">     let compoundName = aPluginName + &quot;:&quot; + aAttrName;</span>
<a href="#l16.982"></a><span id="l16.982">     return GlodaDatastore._attributeDBDefs[compoundName];</span>
<a href="#l16.983"></a><span id="l16.983">   },</span>
<a href="#l16.984"></a><span id="l16.984"> </span>
<a href="#l16.985"></a><span id="l16.985">   /**</span>
<a href="#l16.986"></a><span id="l16.986">    * Create a new query instance for the given noun-type.  This provides</span>
<a href="#l16.987"></a><span id="l16.987">    *  a generic way to provide constraint-based queries of any first-class</span>
<a href="#l16.988"></a><span id="l16.988">    *  nouns supported by the system.</span>
<a href="#l16.989"></a><span id="l16.989" class="difflineat">@@ -1886,27 +1851,27 @@ var Gloda = {</span>
<a href="#l16.990"></a><span id="l16.990">    * There are also full-text constraint columns.  In a nutshell, their</span>
<a href="#l16.991"></a><span id="l16.991">    *  arguments are the strings that should be passed to the SQLite FTS3</span>
<a href="#l16.992"></a><span id="l16.992">    *  MATCH clause.</span>
<a href="#l16.993"></a><span id="l16.993">    *</span>
<a href="#l16.994"></a><span id="l16.994">    * @param aNounID The (integer) noun-id of the noun you want to query on.</span>
<a href="#l16.995"></a><span id="l16.995">    * @param aOptions an optional dictionary of query options, see the GlodaQuery</span>
<a href="#l16.996"></a><span id="l16.996">    *     class documentation.</span>
<a href="#l16.997"></a><span id="l16.997">    */</span>
<a href="#l16.998"></a><span id="l16.998" class="difflineminus">-  newQuery: function gloda_ns_newQuery(aNounID, aOptions) {</span>
<a href="#l16.999"></a><span id="l16.999" class="difflineplus">+  newQuery(aNounID, aOptions) {</span>
<a href="#l16.1000"></a><span id="l16.1000">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l16.1001"></a><span id="l16.1001">     return new nounDef.queryClass(aOptions);</span>
<a href="#l16.1002"></a><span id="l16.1002">   },</span>
<a href="#l16.1003"></a><span id="l16.1003"> </span>
<a href="#l16.1004"></a><span id="l16.1004">   /**</span>
<a href="#l16.1005"></a><span id="l16.1005">    * Create a collection/query for the given noun-type that only matches the</span>
<a href="#l16.1006"></a><span id="l16.1006">    *  provided items.  This is to be used when you have an explicit set of items</span>
<a href="#l16.1007"></a><span id="l16.1007">    *  that you would still like to receive updates for.</span>
<a href="#l16.1008"></a><span id="l16.1008">    */</span>
<a href="#l16.1009"></a><span id="l16.1009" class="difflineminus">-  explicitCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l16.1010"></a><span id="l16.1010" class="difflineplus">+  explicitCollection(aNounID, aItems) {</span>
<a href="#l16.1011"></a><span id="l16.1011">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l16.1012"></a><span id="l16.1012">     let collection = new GlodaCollection(nounDef, aItems, null, null);</span>
<a href="#l16.1013"></a><span id="l16.1013">     let query = new nounDef.explicitQueryClass(collection);</span>
<a href="#l16.1014"></a><span id="l16.1014">     collection.query = query;</span>
<a href="#l16.1015"></a><span id="l16.1015">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l16.1016"></a><span id="l16.1016">     return collection;</span>
<a href="#l16.1017"></a><span id="l16.1017">   },</span>
<a href="#l16.1018"></a><span id="l16.1018"> </span>
<a href="#l16.1019"></a><span id="l16.1019" class="difflineat">@@ -1916,34 +1881,35 @@ var Gloda = {</span>
<a href="#l16.1020"></a><span id="l16.1020">    *  as new.  The result is that it allows you to be notified as new items</span>
<a href="#l16.1021"></a><span id="l16.1021">    *  as they are indexed, existing items as they are loaded from the database,</span>
<a href="#l16.1022"></a><span id="l16.1022">    *  etc.</span>
<a href="#l16.1023"></a><span id="l16.1023">    * Because the items are added to the collection without limit, this will</span>
<a href="#l16.1024"></a><span id="l16.1024">    *  result in a leak if you don't do something to clean up after the</span>
<a href="#l16.1025"></a><span id="l16.1025">    *  collection.  (Forgetting about the collection will suffice, as it is still</span>
<a href="#l16.1026"></a><span id="l16.1026">    *  weakly held.)</span>
<a href="#l16.1027"></a><span id="l16.1027">    */</span>
<a href="#l16.1028"></a><span id="l16.1028" class="difflineminus">-  _wildcardCollection: function gloda_ns_wildcardCollection(aNounID, aItems) {</span>
<a href="#l16.1029"></a><span id="l16.1029" class="difflineplus">+  _wildcardCollection(aNounID, aItems) {</span>
<a href="#l16.1030"></a><span id="l16.1030">     let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l16.1031"></a><span id="l16.1031">     let collection = new GlodaCollection(nounDef, aItems, null, null);</span>
<a href="#l16.1032"></a><span id="l16.1032">     let query = new nounDef.wildcardQueryClass(collection);</span>
<a href="#l16.1033"></a><span id="l16.1033">     collection.query = query;</span>
<a href="#l16.1034"></a><span id="l16.1034">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l16.1035"></a><span id="l16.1035">     return collection;</span>
<a href="#l16.1036"></a><span id="l16.1036">   },</span>
<a href="#l16.1037"></a><span id="l16.1037"> </span>
<a href="#l16.1038"></a><span id="l16.1038">   /**</span>
<a href="#l16.1039"></a><span id="l16.1039">    * Attribute providers attempting to index something that experience a fatal</span>
<a href="#l16.1040"></a><span id="l16.1040">    *  problem should throw one of these.  For example:</span>
<a href="#l16.1041"></a><span id="l16.1041">    *  &quot;throw new Gloda.BadItemContentsError('Message lacks an author.');&quot;.</span>
<a href="#l16.1042"></a><span id="l16.1042">    *</span>
<a href="#l16.1043"></a><span id="l16.1043">    * We're not really taking advantage of this yet, but it's a good idea.</span>
<a href="#l16.1044"></a><span id="l16.1044">    */</span>
<a href="#l16.1045"></a><span id="l16.1045" class="difflineminus">-  BadItemContentsError: BadItemContentsError,</span>
<a href="#l16.1046"></a><span id="l16.1046" class="difflineplus">+  BadItemContentsError,</span>
<a href="#l16.1047"></a><span id="l16.1047"> </span>
<a href="#l16.1048"></a><span id="l16.1048" class="difflineplus">+  /* eslint-disable complexity */</span>
<a href="#l16.1049"></a><span id="l16.1049">   /**</span>
<a href="#l16.1050"></a><span id="l16.1050">    * Populate a gloda representation of an item given the thus-far built</span>
<a href="#l16.1051"></a><span id="l16.1051">    *  representation, the previous representation, and one or more raw</span>
<a href="#l16.1052"></a><span id="l16.1052">    *  representations.  The attribute providers/optimizers for the given noun</span>
<a href="#l16.1053"></a><span id="l16.1053">    *  type are invoked, allowing them to contribute/alter things.  Following</span>
<a href="#l16.1054"></a><span id="l16.1054">    *  that, we build and persist our attribute representations.</span>
<a href="#l16.1055"></a><span id="l16.1055">    *</span>
<a href="#l16.1056"></a><span id="l16.1056">    * The result of the processing ends up with attributes in 3 different forms:</span>
<a href="#l16.1057"></a><span id="l16.1057" class="difflineat">@@ -1973,33 +1939,32 @@ var Gloda = {</span>
<a href="#l16.1058"></a><span id="l16.1058">    *     with messages where we may have a ghost, the ghost message is not a</span>
<a href="#l16.1059"></a><span id="l16.1059">    *     new record, but is conceptually new.</span>
<a href="#l16.1060"></a><span id="l16.1060">    * @param aCallbackHandle The GlodaIndexer-style callback handle that is being</span>
<a href="#l16.1061"></a><span id="l16.1061">    *     used to drive this processing in an async fashion.  (See</span>
<a href="#l16.1062"></a><span id="l16.1062">    *     GlodaIndexer._callbackHandle).</span>
<a href="#l16.1063"></a><span id="l16.1063">    * @param aDoCache Should we allow this item to be contributed to its noun</span>
<a href="#l16.1064"></a><span id="l16.1064">    *     cache?</span>
<a href="#l16.1065"></a><span id="l16.1065">    */</span>
<a href="#l16.1066"></a><span id="l16.1066" class="difflineminus">-  grokNounItem: function* gloda_ns_grokNounItem(aItem, aRawReps,</span>
<a href="#l16.1067"></a><span id="l16.1067" class="difflineminus">-      aIsConceptuallyNew, aIsRecordNew, aCallbackHandle, aDoCache) {</span>
<a href="#l16.1068"></a><span id="l16.1068" class="difflineplus">+  * grokNounItem(aItem, aRawReps, aIsConceptuallyNew, aIsRecordNew, aCallbackHandle, aDoCache) {</span>
<a href="#l16.1069"></a><span id="l16.1069">     let itemNounDef = aItem.NOUN_DEF;</span>
<a href="#l16.1070"></a><span id="l16.1070">     let attribsByBoundName = itemNounDef.attribsByBoundName;</span>
<a href="#l16.1071"></a><span id="l16.1071"> </span>
<a href="#l16.1072"></a><span id="l16.1072">     this._log.info(&quot; ** grokNounItem: &quot; + itemNounDef.name);</span>
<a href="#l16.1073"></a><span id="l16.1073"> </span>
<a href="#l16.1074"></a><span id="l16.1074">     let addDBAttribs = [];</span>
<a href="#l16.1075"></a><span id="l16.1075">     let removeDBAttribs = [];</span>
<a href="#l16.1076"></a><span id="l16.1076"> </span>
<a href="#l16.1077"></a><span id="l16.1077">     let jsonDict = {};</span>
<a href="#l16.1078"></a><span id="l16.1078"> </span>
<a href="#l16.1079"></a><span id="l16.1079">     let aOldItem;</span>
<a href="#l16.1080"></a><span id="l16.1080">     aRawReps.trueGlodaRep = aItem;</span>
<a href="#l16.1081"></a><span id="l16.1081" class="difflineminus">-    if (aIsConceptuallyNew) // there is no old item if we are new.</span>
<a href="#l16.1082"></a><span id="l16.1082" class="difflineplus">+    if (aIsConceptuallyNew) { // there is no old item if we are new.</span>
<a href="#l16.1083"></a><span id="l16.1083">       aOldItem = {};</span>
<a href="#l16.1084"></a><span id="l16.1084" class="difflineminus">-    else {</span>
<a href="#l16.1085"></a><span id="l16.1085" class="difflineplus">+    } else {</span>
<a href="#l16.1086"></a><span id="l16.1086">       aOldItem = aItem;</span>
<a href="#l16.1087"></a><span id="l16.1087">       // we want to create a clone of the existing item so that we can know the</span>
<a href="#l16.1088"></a><span id="l16.1088">       //  deltas that happened for indexing purposes</span>
<a href="#l16.1089"></a><span id="l16.1089">       aItem = aItem._clone();</span>
<a href="#l16.1090"></a><span id="l16.1090">     }</span>
<a href="#l16.1091"></a><span id="l16.1091"> </span>
<a href="#l16.1092"></a><span id="l16.1092">     // Have the attribute providers directly set properties on the aItem</span>
<a href="#l16.1093"></a><span id="l16.1093">     let attrProviders = this._attrProviderOrderByNoun[itemNounDef.id];</span>
<a href="#l16.1094"></a><span id="l16.1094" class="difflineat">@@ -2039,27 +2004,24 @@ var Gloda = {</span>
<a href="#l16.1095"></a><span id="l16.1095">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l16.1096"></a><span id="l16.1096"> </span>
<a href="#l16.1097"></a><span id="l16.1097">       // - translate for our JSON rep</span>
<a href="#l16.1098"></a><span id="l16.1098">       if (attrib.singular) {</span>
<a href="#l16.1099"></a><span id="l16.1099">         if (objectNounDef.toJSON)</span>
<a href="#l16.1100"></a><span id="l16.1100">           jsonDict[attrib.id] = objectNounDef.toJSON(value);</span>
<a href="#l16.1101"></a><span id="l16.1101">         else</span>
<a href="#l16.1102"></a><span id="l16.1102">           jsonDict[attrib.id] = value;</span>
<a href="#l16.1103"></a><span id="l16.1103" class="difflineminus">-      }</span>
<a href="#l16.1104"></a><span id="l16.1104" class="difflineminus">-      else {</span>
<a href="#l16.1105"></a><span id="l16.1105" class="difflineminus">-        if (objectNounDef.toJSON) {</span>
<a href="#l16.1106"></a><span id="l16.1106" class="difflineminus">-          let toJSON = objectNounDef.toJSON;</span>
<a href="#l16.1107"></a><span id="l16.1107" class="difflineminus">-          jsonDict[attrib.id] = [];</span>
<a href="#l16.1108"></a><span id="l16.1108" class="difflineminus">-          for (let subValue of value) {</span>
<a href="#l16.1109"></a><span id="l16.1109" class="difflineminus">-            jsonDict[attrib.id].push(toJSON(subValue));</span>
<a href="#l16.1110"></a><span id="l16.1110" class="difflineminus">-          }</span>
<a href="#l16.1111"></a><span id="l16.1111" class="difflineplus">+      } else if (objectNounDef.toJSON) {</span>
<a href="#l16.1112"></a><span id="l16.1112" class="difflineplus">+        let toJSON = objectNounDef.toJSON;</span>
<a href="#l16.1113"></a><span id="l16.1113" class="difflineplus">+        jsonDict[attrib.id] = [];</span>
<a href="#l16.1114"></a><span id="l16.1114" class="difflineplus">+        for (let subValue of value) {</span>
<a href="#l16.1115"></a><span id="l16.1115" class="difflineplus">+          jsonDict[attrib.id].push(toJSON(subValue));</span>
<a href="#l16.1116"></a><span id="l16.1116">         }</span>
<a href="#l16.1117"></a><span id="l16.1117" class="difflineminus">-        else</span>
<a href="#l16.1118"></a><span id="l16.1118" class="difflineminus">-          jsonDict[attrib.id] = value;</span>
<a href="#l16.1119"></a><span id="l16.1119" class="difflineplus">+      } else {</span>
<a href="#l16.1120"></a><span id="l16.1120" class="difflineplus">+        jsonDict[attrib.id] = value;</span>
<a href="#l16.1121"></a><span id="l16.1121">       }</span>
<a href="#l16.1122"></a><span id="l16.1122"> </span>
<a href="#l16.1123"></a><span id="l16.1123">       let oldValue = aOldItem[key];</span>
<a href="#l16.1124"></a><span id="l16.1124"> </span>
<a href="#l16.1125"></a><span id="l16.1125">       // the 'old' item is still the canonical one; update it</span>
<a href="#l16.1126"></a><span id="l16.1126">       // do the update now, because we may skip operations on addDBAttribs and</span>
<a href="#l16.1127"></a><span id="l16.1127">       //  removeDBattribs, if the attribute is not to generate entries in</span>
<a href="#l16.1128"></a><span id="l16.1128">       //  messageAttributes</span>
<a href="#l16.1129"></a><span id="l16.1129" class="difflineat">@@ -2083,32 +2045,30 @@ var Gloda = {</span>
<a href="#l16.1130"></a><span id="l16.1130">           // test for identicality, failing that, see if they have explicit</span>
<a href="#l16.1131"></a><span id="l16.1131">           //  equals support.</span>
<a href="#l16.1132"></a><span id="l16.1132">           if ((value !== oldValue) &amp;&amp;</span>
<a href="#l16.1133"></a><span id="l16.1133">               (!value.equals || !value.equals(oldValue))) {</span>
<a href="#l16.1134"></a><span id="l16.1134">             addDBAttribs.push(attribDB.convertValuesToDBAttributes([value])[0]);</span>
<a href="#l16.1135"></a><span id="l16.1135">             removeDBAttribs.push(</span>
<a href="#l16.1136"></a><span id="l16.1136">               attribDB.convertValuesToDBAttributes([oldValue])[0]);</span>
<a href="#l16.1137"></a><span id="l16.1137">           }</span>
<a href="#l16.1138"></a><span id="l16.1138" class="difflineminus">-        }</span>
<a href="#l16.1139"></a><span id="l16.1139" class="difflineminus">-        // in the plural case, we have to figure the deltas accounting for</span>
<a href="#l16.1140"></a><span id="l16.1140" class="difflineminus">-        //  possible changes in ordering (which is insignificant from an</span>
<a href="#l16.1141"></a><span id="l16.1141" class="difflineminus">-        //  indexing perspective)</span>
<a href="#l16.1142"></a><span id="l16.1142" class="difflineminus">-        // some nouns may not meet === equivalence needs, so must provide a</span>
<a href="#l16.1143"></a><span id="l16.1143" class="difflineminus">-        //  custom computeDelta method to help us out</span>
<a href="#l16.1144"></a><span id="l16.1144" class="difflineminus">-        else if (objectNounDef.computeDelta) {</span>
<a href="#l16.1145"></a><span id="l16.1145" class="difflineplus">+        } else if (objectNounDef.computeDelta) {</span>
<a href="#l16.1146"></a><span id="l16.1146" class="difflineplus">+          // in the plural case, we have to figure the deltas accounting for</span>
<a href="#l16.1147"></a><span id="l16.1147" class="difflineplus">+          //  possible changes in ordering (which is insignificant from an</span>
<a href="#l16.1148"></a><span id="l16.1148" class="difflineplus">+          //  indexing perspective)</span>
<a href="#l16.1149"></a><span id="l16.1149" class="difflineplus">+          // some nouns may not meet === equivalence needs, so must provide a</span>
<a href="#l16.1150"></a><span id="l16.1150" class="difflineplus">+          //  custom computeDelta method to help us out</span>
<a href="#l16.1151"></a><span id="l16.1151">           let [valuesAdded, valuesRemoved] =</span>
<a href="#l16.1152"></a><span id="l16.1152">             objectNounDef.computeDelta(value, oldValue);</span>
<a href="#l16.1153"></a><span id="l16.1153">           // convert the values to database-style attribute rows</span>
<a href="#l16.1154"></a><span id="l16.1154">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l16.1155"></a><span id="l16.1155">             attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l16.1156"></a><span id="l16.1156">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l16.1157"></a><span id="l16.1157">             attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l16.1158"></a><span id="l16.1158" class="difflineminus">-        }</span>
<a href="#l16.1159"></a><span id="l16.1159" class="difflineminus">-        else {</span>
<a href="#l16.1160"></a><span id="l16.1160" class="difflineplus">+        } else {</span>
<a href="#l16.1161"></a><span id="l16.1161">           // build a map of the previous values; we will delete the values as</span>
<a href="#l16.1162"></a><span id="l16.1162">           //  we see them so that we will know what old values are no longer</span>
<a href="#l16.1163"></a><span id="l16.1163">           //  present in the current set of values.</span>
<a href="#l16.1164"></a><span id="l16.1164">           let oldValueMap = {};</span>
<a href="#l16.1165"></a><span id="l16.1165">           for (let anOldValue of oldValue) {</span>
<a href="#l16.1166"></a><span id="l16.1166">             // remember, the key is just the toString'ed value, so we need to</span>
<a href="#l16.1167"></a><span id="l16.1167">             //  store and use the actual value as the value!</span>
<a href="#l16.1168"></a><span id="l16.1168">             oldValueMap[anOldValue] = anOldValue;</span>
<a href="#l16.1169"></a><span id="l16.1169" class="difflineat">@@ -2135,19 +2095,17 @@ var Gloda = {</span>
<a href="#l16.1170"></a><span id="l16.1170">         if (attrib.emptySetIsSignificant) {</span>
<a href="#l16.1171"></a><span id="l16.1171">           // if we are now non-zero but previously were zero, remove.</span>
<a href="#l16.1172"></a><span id="l16.1172">           if (value.length &amp;&amp; !oldValue.length)</span>
<a href="#l16.1173"></a><span id="l16.1173">             removeDBAttribs.push([GlodaDatastore.kEmptySetAttrId, attribDB.id]);</span>
<a href="#l16.1174"></a><span id="l16.1174">           // if we are now zero length but previously were not, add</span>
<a href="#l16.1175"></a><span id="l16.1175">           else if (!value.length &amp;&amp; oldValue.length)</span>
<a href="#l16.1176"></a><span id="l16.1176">             addDBAttribs.push([GlodaDatastore.kEmptySetAttrId, attribDB.id]);</span>
<a href="#l16.1177"></a><span id="l16.1177">         }</span>
<a href="#l16.1178"></a><span id="l16.1178" class="difflineminus">-      }</span>
<a href="#l16.1179"></a><span id="l16.1179" class="difflineminus">-      // no old value, all values are new</span>
<a href="#l16.1180"></a><span id="l16.1180" class="difflineminus">-      else {</span>
<a href="#l16.1181"></a><span id="l16.1181" class="difflineplus">+      } else { // no old value, all values are new</span>
<a href="#l16.1182"></a><span id="l16.1182">         // add the db reps on the new values</span>
<a href="#l16.1183"></a><span id="l16.1183">         if (attrib.singular)</span>
<a href="#l16.1184"></a><span id="l16.1184">           value = [value];</span>
<a href="#l16.1185"></a><span id="l16.1185">         addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l16.1186"></a><span id="l16.1186">                                 attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l16.1187"></a><span id="l16.1187">         // Add the empty set indicator for the attribute id if appropriate.</span>
<a href="#l16.1188"></a><span id="l16.1188">         if (!value.length &amp;&amp; attrib.emptySetIsSignificant)</span>
<a href="#l16.1189"></a><span id="l16.1189">           addDBAttribs.push([GlodaDatastore.kEmptySetAttrId, attribDB.id]);</span>
<a href="#l16.1190"></a><span id="l16.1190" class="difflineat">@@ -2173,18 +2131,18 @@ var Gloda = {</span>
<a href="#l16.1191"></a><span id="l16.1191">         continue;</span>
<a href="#l16.1192"></a><span id="l16.1192">       }</span>
<a href="#l16.1193"></a><span id="l16.1193"> </span>
<a href="#l16.1194"></a><span id="l16.1194">       // delete these from the old item, as the old item is canonical, and</span>
<a href="#l16.1195"></a><span id="l16.1195">       //  should no longer have these values</span>
<a href="#l16.1196"></a><span id="l16.1196">       delete aOldItem[key];</span>
<a href="#l16.1197"></a><span id="l16.1197"> </span>
<a href="#l16.1198"></a><span id="l16.1198">       if (attrib.canQuery !== true) {</span>
<a href="#l16.1199"></a><span id="l16.1199" class="difflineminus">-        this._log.debug(&quot;Not inserting attribute &quot;+attrib.attributeName</span>
<a href="#l16.1200"></a><span id="l16.1200" class="difflineminus">-            +&quot; into the db, since we don't plan on querying on it&quot;);</span>
<a href="#l16.1201"></a><span id="l16.1201" class="difflineplus">+        this._log.debug(&quot;Not inserting attribute &quot; + attrib.attributeName</span>
<a href="#l16.1202"></a><span id="l16.1202" class="difflineplus">+          + &quot; into the db, since we don't plan on querying on it&quot;);</span>
<a href="#l16.1203"></a><span id="l16.1203">         continue;</span>
<a href="#l16.1204"></a><span id="l16.1204">       }</span>
<a href="#l16.1205"></a><span id="l16.1205"> </span>
<a href="#l16.1206"></a><span id="l16.1206">       if (attrib.singular)</span>
<a href="#l16.1207"></a><span id="l16.1207">         value = [value];</span>
<a href="#l16.1208"></a><span id="l16.1208">       let attribDB = attrib.dbDef;</span>
<a href="#l16.1209"></a><span id="l16.1209">       removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l16.1210"></a><span id="l16.1210">                                  attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l16.1211"></a><span id="l16.1211" class="difflineat">@@ -2194,18 +2152,17 @@ var Gloda = {</span>
<a href="#l16.1212"></a><span id="l16.1212">     }</span>
<a href="#l16.1213"></a><span id="l16.1213"> </span>
<a href="#l16.1214"></a><span id="l16.1214">     aItem._jsonText = JSON.stringify(jsonDict);</span>
<a href="#l16.1215"></a><span id="l16.1215">     this._log.debug(&quot;  json text: &quot; + aItem._jsonText);</span>
<a href="#l16.1216"></a><span id="l16.1216"> </span>
<a href="#l16.1217"></a><span id="l16.1217">     if (aIsRecordNew) {</span>
<a href="#l16.1218"></a><span id="l16.1218">       this._log.debug(&quot; inserting item&quot;);</span>
<a href="#l16.1219"></a><span id="l16.1219">       itemNounDef.objInsert.call(itemNounDef.datastore, aItem);</span>
<a href="#l16.1220"></a><span id="l16.1220" class="difflineminus">-    }</span>
<a href="#l16.1221"></a><span id="l16.1221" class="difflineminus">-    else {</span>
<a href="#l16.1222"></a><span id="l16.1222" class="difflineplus">+    } else {</span>
<a href="#l16.1223"></a><span id="l16.1223">       this._log.debug(&quot; updating item&quot;);</span>
<a href="#l16.1224"></a><span id="l16.1224">       itemNounDef.objUpdate.call(itemNounDef.datastore, aItem);</span>
<a href="#l16.1225"></a><span id="l16.1225">     }</span>
<a href="#l16.1226"></a><span id="l16.1226"> </span>
<a href="#l16.1227"></a><span id="l16.1227">     this._log.debug(&quot; adjusting attributes, add: &quot; + addDBAttribs + &quot; rem: &quot; +</span>
<a href="#l16.1228"></a><span id="l16.1228">         removeDBAttribs);</span>
<a href="#l16.1229"></a><span id="l16.1229">     itemNounDef.dbAttribAdjuster.call(itemNounDef.datastore, aItem,</span>
<a href="#l16.1230"></a><span id="l16.1230">       addDBAttribs, removeDBAttribs);</span>
<a href="#l16.1231"></a><span id="l16.1231" class="difflineat">@@ -2220,30 +2177,30 @@ var Gloda = {</span>
<a href="#l16.1232"></a><span id="l16.1232">       else</span>
<a href="#l16.1233"></a><span id="l16.1233">         GlodaCollectionManager.itemsModified(aOldItem.NOUN_ID, [aOldItem]);</span>
<a href="#l16.1234"></a><span id="l16.1234">     }</span>
<a href="#l16.1235"></a><span id="l16.1235"> </span>
<a href="#l16.1236"></a><span id="l16.1236">     this._log.debug(&quot; done grokking.&quot;);</span>
<a href="#l16.1237"></a><span id="l16.1237"> </span>
<a href="#l16.1238"></a><span id="l16.1238">     yield this.kWorkDone;</span>
<a href="#l16.1239"></a><span id="l16.1239">   },</span>
<a href="#l16.1240"></a><span id="l16.1240" class="difflineplus">+  /* eslint-enable complexity */</span>
<a href="#l16.1241"></a><span id="l16.1241"> </span>
<a href="#l16.1242"></a><span id="l16.1242">   /**</span>
<a href="#l16.1243"></a><span id="l16.1243">    * Processes a list of noun instances for their score within a given context.</span>
<a href="#l16.1244"></a><span id="l16.1244">    *  This is primarily intended for use by search ranking mechanisms, but could</span>
<a href="#l16.1245"></a><span id="l16.1245">    *  be used elsewhere too.  (It does, however, depend on the complicity of the</span>
<a href="#l16.1246"></a><span id="l16.1246">    *  score method implementations to not get confused.)</span>
<a href="#l16.1247"></a><span id="l16.1247">    *</span>
<a href="#l16.1248"></a><span id="l16.1248">    * @param aItems The non-empty list of items to score.</span>
<a href="#l16.1249"></a><span id="l16.1249">    * @param aContext A noun-specific dictionary that we just pass to the funcs.</span>
<a href="#l16.1250"></a><span id="l16.1250">    * @param aExtraScoreFuncs A list of extra scoring functions to apply.</span>
<a href="#l16.1251"></a><span id="l16.1251">    * @returns A list of integer scores equal in length to aItems.</span>
<a href="#l16.1252"></a><span id="l16.1252">    */</span>
<a href="#l16.1253"></a><span id="l16.1253" class="difflineminus">-  scoreNounItems: function gloda_ns_grokNounItem(aItems, aContext,</span>
<a href="#l16.1254"></a><span id="l16.1254" class="difflineminus">-                                                 aExtraScoreFuncs) {</span>
<a href="#l16.1255"></a><span id="l16.1255" class="difflineplus">+  scoreNounItems(aItems, aContext, aExtraScoreFuncs) {</span>
<a href="#l16.1256"></a><span id="l16.1256">     let scores = [];</span>
<a href="#l16.1257"></a><span id="l16.1257">     // bail if there is nothing to score</span>
<a href="#l16.1258"></a><span id="l16.1258">     if (!aItems.length)</span>
<a href="#l16.1259"></a><span id="l16.1259">       return scores;</span>
<a href="#l16.1260"></a><span id="l16.1260"> </span>
<a href="#l16.1261"></a><span id="l16.1261">     let itemNounDef = aItems[0].NOUN_DEF;</span>
<a href="#l16.1262"></a><span id="l16.1262">     if (aExtraScoreFuncs == null)</span>
<a href="#l16.1263"></a><span id="l16.1263">       aExtraScoreFuncs = [];</span>
<a href="#l16.1264"></a><span id="l16.1264" class="difflineat">@@ -2257,22 +2214,21 @@ var Gloda = {</span>
<a href="#l16.1265"></a><span id="l16.1265">           score += provider.score(item);</span>
<a href="#l16.1266"></a><span id="l16.1266">       }</span>
<a href="#l16.1267"></a><span id="l16.1267">       for (let extraScoreFunc of aExtraScoreFuncs)</span>
<a href="#l16.1268"></a><span id="l16.1268">         score += extraScoreFunc(item, aContext);</span>
<a href="#l16.1269"></a><span id="l16.1269">       scores.push(score);</span>
<a href="#l16.1270"></a><span id="l16.1270">     }</span>
<a href="#l16.1271"></a><span id="l16.1271"> </span>
<a href="#l16.1272"></a><span id="l16.1272">     return scores;</span>
<a href="#l16.1273"></a><span id="l16.1273" class="difflineminus">-  }</span>
<a href="#l16.1274"></a><span id="l16.1274" class="difflineplus">+  },</span>
<a href="#l16.1275"></a><span id="l16.1275"> };</span>
<a href="#l16.1276"></a><span id="l16.1276"> </span>
<a href="#l16.1277"></a><span id="l16.1277"> /* and initialize the Gloda object/NS before we return... */</span>
<a href="#l16.1278"></a><span id="l16.1278"> try {</span>
<a href="#l16.1279"></a><span id="l16.1279">   Gloda._init();</span>
<a href="#l16.1280"></a><span id="l16.1280" class="difflineminus">-}</span>
<a href="#l16.1281"></a><span id="l16.1281" class="difflineminus">-catch (ex) {</span>
<a href="#l16.1282"></a><span id="l16.1282" class="difflineplus">+} catch (ex) {</span>
<a href="#l16.1283"></a><span id="l16.1283">   Gloda._log.debug(&quot;Exception during Gloda init (&quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l16.1284"></a><span id="l16.1284">                    ex.lineNumber + &quot;): &quot; + ex);</span>
<a href="#l16.1285"></a><span id="l16.1285" class="difflineminus">-};</span>
<a href="#l16.1286"></a><span id="l16.1286" class="difflineplus">+}</span>
<a href="#l16.1287"></a><span id="l16.1287"> /* but don't forget that we effectively depend on everybody.js too, and</span>
<a href="#l16.1288"></a><span id="l16.1288">    currently on our importer to be importing that if they need us fully armed</span>
<a href="#l16.1289"></a><span id="l16.1289">    and operational. */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/db/gloda/modules/index_ab.js</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_ab.js</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -1,52 +1,52 @@</span>
<a href="#l17.4"></a><span id="l17.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l17.5"></a><span id="l17.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l17.6"></a><span id="l17.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l17.7"></a><span id="l17.7"> </span>
<a href="#l17.8"></a><span id="l17.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['GlodaABIndexer', 'GlodaABAttrs'];</span>
<a href="#l17.9"></a><span id="l17.9" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;GlodaABIndexer&quot;, &quot;GlodaABAttrs&quot;];</span>
<a href="#l17.10"></a><span id="l17.10"> </span>
<a href="#l17.11"></a><span id="l17.11"> const {GlodaCollectionManager} = ChromeUtils.import(&quot;resource:///modules/gloda/collection.js&quot;);</span>
<a href="#l17.12"></a><span id="l17.12"> const {GlodaDatastore} = ChromeUtils.import(&quot;resource:///modules/gloda/datastore.js&quot;);</span>
<a href="#l17.13"></a><span id="l17.13"> const {Gloda} = ChromeUtils.import(&quot;resource:///modules/gloda/gloda.js&quot;);</span>
<a href="#l17.14"></a><span id="l17.14"> const {GlodaIndexer, IndexingJob} = ChromeUtils.import(&quot;resource:///modules/gloda/indexer.js&quot;);</span>
<a href="#l17.15"></a><span id="l17.15"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l17.16"></a><span id="l17.16"> const {FreeTagNoun} = ChromeUtils.import(&quot;resource:///modules/gloda/noun_freetag.js&quot;);</span>
<a href="#l17.17"></a><span id="l17.17"> const {GlodaUtils} = ChromeUtils.import(&quot;resource:///modules/gloda/utils.js&quot;);</span>
<a href="#l17.18"></a><span id="l17.18"> const {MailServices} = ChromeUtils.import(&quot;resource:///modules/MailServices.jsm&quot;);</span>
<a href="#l17.19"></a><span id="l17.19"> </span>
<a href="#l17.20"></a><span id="l17.20"> </span>
<a href="#l17.21"></a><span id="l17.21"> var GlodaABIndexer = {</span>
<a href="#l17.22"></a><span id="l17.22">   _log: null,</span>
<a href="#l17.23"></a><span id="l17.23"> </span>
<a href="#l17.24"></a><span id="l17.24">   name: &quot;index_ab&quot;,</span>
<a href="#l17.25"></a><span id="l17.25" class="difflineminus">-  enable: function() {</span>
<a href="#l17.26"></a><span id="l17.26" class="difflineplus">+  enable() {</span>
<a href="#l17.27"></a><span id="l17.27">     if (this._log == null)</span>
<a href="#l17.28"></a><span id="l17.28">       this._log =  Log4Moz.repository.getLogger(&quot;gloda.index_ab&quot;);</span>
<a href="#l17.29"></a><span id="l17.29"> </span>
<a href="#l17.30"></a><span id="l17.30">     MailServices.ab.addAddressBookListener(this,</span>
<a href="#l17.31"></a><span id="l17.31">                                            Ci.nsIAbListener.itemAdded |</span>
<a href="#l17.32"></a><span id="l17.32">                                            Ci.nsIAbListener.itemChanged |</span>
<a href="#l17.33"></a><span id="l17.33">                                            Ci.nsIAbListener.directoryItemRemoved);</span>
<a href="#l17.34"></a><span id="l17.34">   },</span>
<a href="#l17.35"></a><span id="l17.35"> </span>
<a href="#l17.36"></a><span id="l17.36" class="difflineminus">-  disable: function() {</span>
<a href="#l17.37"></a><span id="l17.37" class="difflineplus">+  disable() {</span>
<a href="#l17.38"></a><span id="l17.38">     MailServices.ab.removeAddressBookListener(this);</span>
<a href="#l17.39"></a><span id="l17.39">   },</span>
<a href="#l17.40"></a><span id="l17.40"> </span>
<a href="#l17.41"></a><span id="l17.41">   // it's a getter so we can reference 'this'</span>
<a href="#l17.42"></a><span id="l17.42">   get workers() {</span>
<a href="#l17.43"></a><span id="l17.43">     return [</span>
<a href="#l17.44"></a><span id="l17.44">       [&quot;ab-card&quot;, {</span>
<a href="#l17.45"></a><span id="l17.45">          worker: this._worker_index_card,</span>
<a href="#l17.46"></a><span id="l17.46">        }],</span>
<a href="#l17.47"></a><span id="l17.47">     ];</span>
<a href="#l17.48"></a><span id="l17.48">   },</span>
<a href="#l17.49"></a><span id="l17.49"> </span>
<a href="#l17.50"></a><span id="l17.50" class="difflineminus">-  _worker_index_card: function*(aJob, aCallbackHandle) {</span>
<a href="#l17.51"></a><span id="l17.51" class="difflineplus">+  * _worker_index_card(aJob, aCallbackHandle) {</span>
<a href="#l17.52"></a><span id="l17.52">     let card = aJob.id;</span>
<a href="#l17.53"></a><span id="l17.53"> </span>
<a href="#l17.54"></a><span id="l17.54">     if (card.primaryEmail) {</span>
<a href="#l17.55"></a><span id="l17.55">       // load the identity</span>
<a href="#l17.56"></a><span id="l17.56">       let query = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l17.57"></a><span id="l17.57">       query.kind(&quot;email&quot;);</span>
<a href="#l17.58"></a><span id="l17.58">       // we currently normalize all e-mail addresses to be lowercase</span>
<a href="#l17.59"></a><span id="l17.59">       query.value(card.primaryEmail.toLowerCase());</span>
<a href="#l17.60"></a><span id="l17.60" class="difflineat">@@ -55,97 +55,94 @@ var GlodaABIndexer = {</span>
<a href="#l17.61"></a><span id="l17.61"> </span>
<a href="#l17.62"></a><span id="l17.62">       if (identityCollection.items.length) {</span>
<a href="#l17.63"></a><span id="l17.63">         let identity = identityCollection.items[0];</span>
<a href="#l17.64"></a><span id="l17.64">         // force the identity to know it has an associated ab card.</span>
<a href="#l17.65"></a><span id="l17.65">         identity._hasAddressBookCard = true;</span>
<a href="#l17.66"></a><span id="l17.66"> </span>
<a href="#l17.67"></a><span id="l17.67">         this._log.debug(&quot;Found identity, processing card.&quot;);</span>
<a href="#l17.68"></a><span id="l17.68">         yield aCallbackHandle.pushAndGo(</span>
<a href="#l17.69"></a><span id="l17.69" class="difflineminus">-            Gloda.grokNounItem(identity.contact, {card: card}, false, false,</span>
<a href="#l17.70"></a><span id="l17.70" class="difflineminus">-                               aCallbackHandle));</span>
<a href="#l17.71"></a><span id="l17.71" class="difflineplus">+          Gloda.grokNounItem(identity.contact, {card}, false, false,</span>
<a href="#l17.72"></a><span id="l17.72" class="difflineplus">+                             aCallbackHandle));</span>
<a href="#l17.73"></a><span id="l17.73">         this._log.debug(&quot;Done processing card.&quot;);</span>
<a href="#l17.74"></a><span id="l17.74">       }</span>
<a href="#l17.75"></a><span id="l17.75">     }</span>
<a href="#l17.76"></a><span id="l17.76"> </span>
<a href="#l17.77"></a><span id="l17.77">     yield GlodaIndexer.kWorkDone;</span>
<a href="#l17.78"></a><span id="l17.78">   },</span>
<a href="#l17.79"></a><span id="l17.79"> </span>
<a href="#l17.80"></a><span id="l17.80" class="difflineminus">-  initialSweep: function() {</span>
<a href="#l17.81"></a><span id="l17.81" class="difflineplus">+  initialSweep() {</span>
<a href="#l17.82"></a><span id="l17.82">   },</span>
<a href="#l17.83"></a><span id="l17.83"> </span>
<a href="#l17.84"></a><span id="l17.84">   /* ------ nsIAbListener ------ */</span>
<a href="#l17.85"></a><span id="l17.85">   /**</span>
<a href="#l17.86"></a><span id="l17.86">    * When an address book card is added, update the cached GlodaIdentity</span>
<a href="#l17.87"></a><span id="l17.87">    *  object's cached idea of whether the identity has an ab card.</span>
<a href="#l17.88"></a><span id="l17.88">    */</span>
<a href="#l17.89"></a><span id="l17.89" class="difflineminus">-  onItemAdded: function ab_indexer_onItemAdded(aParentDir, aItem) {</span>
<a href="#l17.90"></a><span id="l17.90" class="difflineplus">+  onItemAdded(aParentDir, aItem) {</span>
<a href="#l17.91"></a><span id="l17.91">     if (!(aItem instanceof Ci.nsIAbCard))</span>
<a href="#l17.92"></a><span id="l17.92">       return;</span>
<a href="#l17.93"></a><span id="l17.93"> </span>
<a href="#l17.94"></a><span id="l17.94">     this._log.debug(&quot;Received Card Add Notification&quot;);</span>
<a href="#l17.95"></a><span id="l17.95">     let identity = GlodaCollectionManager.cacheLookupOneByUniqueValue(</span>
<a href="#l17.96"></a><span id="l17.96">       Gloda.NOUN_IDENTITY, &quot;email@&quot; + aItem.primaryEmail.toLowerCase());</span>
<a href="#l17.97"></a><span id="l17.97">     if (identity)</span>
<a href="#l17.98"></a><span id="l17.98">       identity._hasAddressBookCard = true;</span>
<a href="#l17.99"></a><span id="l17.99">   },</span>
<a href="#l17.100"></a><span id="l17.100">   /**</span>
<a href="#l17.101"></a><span id="l17.101">    * When an address book card is added, update the cached GlodaIdentity</span>
<a href="#l17.102"></a><span id="l17.102">    *  object's cached idea of whether the identity has an ab card.</span>
<a href="#l17.103"></a><span id="l17.103">    */</span>
<a href="#l17.104"></a><span id="l17.104" class="difflineminus">-  onItemRemoved: function ab_indexer_onItemRemoved(aParentDir, aItem) {</span>
<a href="#l17.105"></a><span id="l17.105" class="difflineplus">+  onItemRemoved(aParentDir, aItem) {</span>
<a href="#l17.106"></a><span id="l17.106">     if (!(aItem instanceof Ci.nsIAbCard))</span>
<a href="#l17.107"></a><span id="l17.107">       return;</span>
<a href="#l17.108"></a><span id="l17.108"> </span>
<a href="#l17.109"></a><span id="l17.109">     this._log.debug(&quot;Received Card Removal Notification&quot;);</span>
<a href="#l17.110"></a><span id="l17.110">     let identity = GlodaCollectionManager.cacheLookupOneByUniqueValue(</span>
<a href="#l17.111"></a><span id="l17.111">       Gloda.NOUN_IDENTITY, &quot;email@&quot; + aItem.primaryEmail.toLowerCase());</span>
<a href="#l17.112"></a><span id="l17.112">     if (identity)</span>
<a href="#l17.113"></a><span id="l17.113">       identity._hasAddressBookCard = false;</span>
<a href="#l17.114"></a><span id="l17.114" class="difflineminus">-</span>
<a href="#l17.115"></a><span id="l17.115">   },</span>
<a href="#l17.116"></a><span id="l17.116" class="difflineminus">-  onItemPropertyChanged: function ab_indexer_onItemPropertyChanged(aItem,</span>
<a href="#l17.117"></a><span id="l17.117" class="difflineminus">-      aProperty, aOldValue, aNewValue) {</span>
<a href="#l17.118"></a><span id="l17.118" class="difflineplus">+  onItemPropertyChanged(aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l17.119"></a><span id="l17.119">     if (aProperty == null &amp;&amp; aItem instanceof Ci.nsIAbCard) {</span>
<a href="#l17.120"></a><span id="l17.120">       this._log.debug(&quot;Received Card Change Notification&quot;);</span>
<a href="#l17.121"></a><span id="l17.121"> </span>
<a href="#l17.122"></a><span id="l17.122">       let card = aItem; // instanceof already QueryInterface'd for us.</span>
<a href="#l17.123"></a><span id="l17.123">       let job = new IndexingJob(&quot;ab-card&quot;, card);</span>
<a href="#l17.124"></a><span id="l17.124">       GlodaIndexer.indexJob(job);</span>
<a href="#l17.125"></a><span id="l17.125">     }</span>
<a href="#l17.126"></a><span id="l17.126" class="difflineminus">-  }</span>
<a href="#l17.127"></a><span id="l17.127" class="difflineplus">+  },</span>
<a href="#l17.128"></a><span id="l17.128"> };</span>
<a href="#l17.129"></a><span id="l17.129"> GlodaIndexer.registerIndexer(GlodaABIndexer);</span>
<a href="#l17.130"></a><span id="l17.130"> </span>
<a href="#l17.131"></a><span id="l17.131"> var GlodaABAttrs = {</span>
<a href="#l17.132"></a><span id="l17.132">   providerName: &quot;gloda.ab_attr&quot;,</span>
<a href="#l17.133"></a><span id="l17.133">   _log: null,</span>
<a href="#l17.134"></a><span id="l17.134"> </span>
<a href="#l17.135"></a><span id="l17.135" class="difflineminus">-  init: function() {</span>
<a href="#l17.136"></a><span id="l17.136" class="difflineplus">+  init() {</span>
<a href="#l17.137"></a><span id="l17.137">     this._log =  Log4Moz.repository.getLogger(&quot;gloda.abattrs&quot;);</span>
<a href="#l17.138"></a><span id="l17.138"> </span>
<a href="#l17.139"></a><span id="l17.139">     try {</span>
<a href="#l17.140"></a><span id="l17.140">       this.defineAttributes();</span>
<a href="#l17.141"></a><span id="l17.141" class="difflineminus">-    }</span>
<a href="#l17.142"></a><span id="l17.142" class="difflineminus">-    catch (ex) {</span>
<a href="#l17.143"></a><span id="l17.143" class="difflineplus">+    } catch (ex) {</span>
<a href="#l17.144"></a><span id="l17.144">       this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l17.145"></a><span id="l17.145">       throw ex;</span>
<a href="#l17.146"></a><span id="l17.146">     }</span>
<a href="#l17.147"></a><span id="l17.147">   },</span>
<a href="#l17.148"></a><span id="l17.148"> </span>
<a href="#l17.149"></a><span id="l17.149" class="difflineminus">-  defineAttributes: function() {</span>
<a href="#l17.150"></a><span id="l17.150" class="difflineplus">+  defineAttributes() {</span>
<a href="#l17.151"></a><span id="l17.151">     /* ***** Contacts ***** */</span>
<a href="#l17.152"></a><span id="l17.152">     this._attrIdentityContact = Gloda.defineAttribute({</span>
<a href="#l17.153"></a><span id="l17.153">       provider: this,</span>
<a href="#l17.154"></a><span id="l17.154">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l17.155"></a><span id="l17.155">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l17.156"></a><span id="l17.156">       attributeName: &quot;identities&quot;,</span>
<a href="#l17.157"></a><span id="l17.157">       singular: false,</span>
<a href="#l17.158"></a><span id="l17.158">       special: Gloda.kSpecialColumnChildren,</span>
<a href="#l17.159"></a><span id="l17.159" class="difflineminus">-      //specialColumnName: &quot;contactID&quot;,</span>
<a href="#l17.160"></a><span id="l17.160" class="difflineplus">+      // specialColumnName: &quot;contactID&quot;,</span>
<a href="#l17.161"></a><span id="l17.161">       storageAttributeName: &quot;_identities&quot;,</span>
<a href="#l17.162"></a><span id="l17.162">       subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l17.163"></a><span id="l17.163">       objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l17.164"></a><span id="l17.164">       }); // tested-by: test_attributes_fundamental</span>
<a href="#l17.165"></a><span id="l17.165">     this._attrContactName = Gloda.defineAttribute({</span>
<a href="#l17.166"></a><span id="l17.166">       provider: this,</span>
<a href="#l17.167"></a><span id="l17.167">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l17.168"></a><span id="l17.168">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l17.169"></a><span id="l17.169" class="difflineat">@@ -244,17 +241,17 @@ var GlodaABAttrs = {</span>
<a href="#l17.170"></a><span id="l17.170">     if (&quot;parameterBindings&quot; in this._attrFreeTag) {</span>
<a href="#l17.171"></a><span id="l17.171">       for (let freeTagName in this._attrFreeTag.parameterBindings) {</span>
<a href="#l17.172"></a><span id="l17.172">         this._log.debug(&quot;Telling FreeTagNoun about: &quot; + freeTagName);</span>
<a href="#l17.173"></a><span id="l17.173">         FreeTagNoun.getFreeTag(freeTagName);</span>
<a href="#l17.174"></a><span id="l17.174">       }</span>
<a href="#l17.175"></a><span id="l17.175">     }</span>
<a href="#l17.176"></a><span id="l17.176">   },</span>
<a href="#l17.177"></a><span id="l17.177"> </span>
<a href="#l17.178"></a><span id="l17.178" class="difflineminus">-  process: function*(aContact, aRawReps, aIsNew, aCallbackHandle) {</span>
<a href="#l17.179"></a><span id="l17.179" class="difflineplus">+  * process(aContact, aRawReps, aIsNew, aCallbackHandle) {</span>
<a href="#l17.180"></a><span id="l17.180">     let card = aRawReps.card;</span>
<a href="#l17.181"></a><span id="l17.181">     if (aContact.NOUN_ID != Gloda.NOUN_CONTACT) {</span>
<a href="#l17.182"></a><span id="l17.182">       this._log.warn(&quot;Somehow got a non-contact: &quot; + aContact);</span>
<a href="#l17.183"></a><span id="l17.183">       return; // this will produce an exception; we like.</span>
<a href="#l17.184"></a><span id="l17.184">     }</span>
<a href="#l17.185"></a><span id="l17.185"> </span>
<a href="#l17.186"></a><span id="l17.186">     // update the name</span>
<a href="#l17.187"></a><span id="l17.187">     if (card.displayName &amp;&amp; card.displayName != aContact.name)</span>
<a href="#l17.188"></a><span id="l17.188" class="difflineat">@@ -273,10 +270,10 @@ var GlodaABAttrs = {</span>
<a href="#l17.189"></a><span id="l17.189">         tagName = tagName.trim();</span>
<a href="#l17.190"></a><span id="l17.190">         if (tagName) {</span>
<a href="#l17.191"></a><span id="l17.191">           aContact.freeTags.push(FreeTagNoun.getFreeTag(tagName));</span>
<a href="#l17.192"></a><span id="l17.192">         }</span>
<a href="#l17.193"></a><span id="l17.193">       }</span>
<a href="#l17.194"></a><span id="l17.194">     }</span>
<a href="#l17.195"></a><span id="l17.195"> </span>
<a href="#l17.196"></a><span id="l17.196">     yield Gloda.kWorkDone;</span>
<a href="#l17.197"></a><span id="l17.197" class="difflineminus">-  }</span>
<a href="#l17.198"></a><span id="l17.198" class="difflineplus">+  },</span>
<a href="#l17.199"></a><span id="l17.199"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -7,17 +7,17 @@</span>
<a href="#l18.4"></a><span id="l18.4"> /*</span>
<a href="#l18.5"></a><span id="l18.5">  * This file currently contains a fairly general implementation of asynchronous</span>
<a href="#l18.6"></a><span id="l18.6">  *  indexing with a very explicit message indexing implementation.  As gloda</span>
<a href="#l18.7"></a><span id="l18.7">  *  will eventually want to index more than just messages, the message-specific</span>
<a href="#l18.8"></a><span id="l18.8">  *  things should ideally lose their special hold on this file.  This will</span>
<a href="#l18.9"></a><span id="l18.9">  *  benefit readability/size as well.</span>
<a href="#l18.10"></a><span id="l18.10">  */</span>
<a href="#l18.11"></a><span id="l18.11"> </span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-this.EXPORTED_SYMBOLS = ['GlodaMsgIndexer'];</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;GlodaMsgIndexer&quot;];</span>
<a href="#l18.14"></a><span id="l18.14"> </span>
<a href="#l18.15"></a><span id="l18.15"> const {XPCOMUtils} = ChromeUtils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l18.16"></a><span id="l18.16"> const {fixIterator} = ChromeUtils.import(&quot;resource:///modules/iteratorUtils.jsm&quot;);</span>
<a href="#l18.17"></a><span id="l18.17"> const {MailServices} = ChromeUtils.import(&quot;resource:///modules/MailServices.jsm&quot;);</span>
<a href="#l18.18"></a><span id="l18.18"> const {MailUtils} = ChromeUtils.import(&quot;resource:///modules/MailUtils.jsm&quot;);</span>
<a href="#l18.19"></a><span id="l18.19"> </span>
<a href="#l18.20"></a><span id="l18.20"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l18.21"></a><span id="l18.21"> </span>
<a href="#l18.22"></a><span id="l18.22" class="difflineat">@@ -120,17 +120,17 @@ var PendingCommitTracker = {</span>
<a href="#l18.23"></a><span id="l18.23">    * Accordingly, we make a list of all the folders that the headers belong to</span>
<a href="#l18.24"></a><span id="l18.24">    *  as we iterate, make sure to re-attach their msgDatabase before forgetting</span>
<a href="#l18.25"></a><span id="l18.25">    *  the headers, then make sure to zero the msgDatabase again, triggering a</span>
<a href="#l18.26"></a><span id="l18.26">    *  commit.  If there were a way to directly get the nsIMsgDatabase from the</span>
<a href="#l18.27"></a><span id="l18.27">    *  header we could do that and call commit directly.  We don't track</span>
<a href="#l18.28"></a><span id="l18.28">    *  databases along with the headers since the headers can change because of</span>
<a href="#l18.29"></a><span id="l18.29">    *  moves and that would increase the number of moving parts.</span>
<a href="#l18.30"></a><span id="l18.30">    */</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineminus">-  _commitCallback: function PendingCommitTracker_commitCallback() {</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+  _commitCallback() {</span>
<a href="#l18.33"></a><span id="l18.33">     let foldersByURI = {};</span>
<a href="#l18.34"></a><span id="l18.34">     let lastFolder = null;</span>
<a href="#l18.35"></a><span id="l18.35"> </span>
<a href="#l18.36"></a><span id="l18.36">     for (let glodaId in</span>
<a href="#l18.37"></a><span id="l18.37">          PendingCommitTracker._indexedMessagesPendingCommitByGlodaId) {</span>
<a href="#l18.38"></a><span id="l18.38">      let [msgHdr, dirtyState] =</span>
<a href="#l18.39"></a><span id="l18.39">        PendingCommitTracker._indexedMessagesPendingCommitByGlodaId[glodaId];</span>
<a href="#l18.40"></a><span id="l18.40">       // Mark this message as indexed.</span>
<a href="#l18.41"></a><span id="l18.41" class="difflineat">@@ -150,47 +150,46 @@ var PendingCommitTracker = {</span>
<a href="#l18.42"></a><span id="l18.42"> </span>
<a href="#l18.43"></a><span id="l18.43">         // Make sure this folder is in our foldersByURI map.</span>
<a href="#l18.44"></a><span id="l18.44">         if (lastFolder == msgHdr.folder)</span>
<a href="#l18.45"></a><span id="l18.45">           continue;</span>
<a href="#l18.46"></a><span id="l18.46">         lastFolder = msgHdr.folder;</span>
<a href="#l18.47"></a><span id="l18.47">         let folderURI = lastFolder.URI;</span>
<a href="#l18.48"></a><span id="l18.48">         if (!(folderURI in foldersByURI))</span>
<a href="#l18.49"></a><span id="l18.49">           foldersByURI[folderURI] = lastFolder;</span>
<a href="#l18.50"></a><span id="l18.50" class="difflineminus">-      }</span>
<a href="#l18.51"></a><span id="l18.51" class="difflineminus">-      catch (ex) {</span>
<a href="#l18.52"></a><span id="l18.52" class="difflineplus">+      } catch (ex) {</span>
<a href="#l18.53"></a><span id="l18.53">         GlodaMsgIndexer._log.error(</span>
<a href="#l18.54"></a><span id="l18.54">           &quot;Exception while attempting to mark message with gloda state after&quot; +</span>
<a href="#l18.55"></a><span id="l18.55">           &quot;db commit&quot;, ex);</span>
<a href="#l18.56"></a><span id="l18.56">       }</span>
<a href="#l18.57"></a><span id="l18.57">     }</span>
<a href="#l18.58"></a><span id="l18.58"> </span>
<a href="#l18.59"></a><span id="l18.59">     // it is vitally important to do this before we forget about the headers!</span>
<a href="#l18.60"></a><span id="l18.60">     for (let uri in foldersByURI) {</span>
<a href="#l18.61"></a><span id="l18.61">       let folder = foldersByURI[uri];</span>
<a href="#l18.62"></a><span id="l18.62">       // This will not cause a parse.  The database is in-memory since we have</span>
<a href="#l18.63"></a><span id="l18.63">       //  a header that belongs to it.  This just causes the folder to</span>
<a href="#l18.64"></a><span id="l18.64">       //  re-acquire a reference from the database manager.</span>
<a href="#l18.65"></a><span id="l18.65" class="difflineminus">-      let ignoredDb = folder.msgDatabase;</span>
<a href="#l18.66"></a><span id="l18.66" class="difflineplus">+      folder.msgDatabase;</span>
<a href="#l18.67"></a><span id="l18.67">       // And this will cause a commit.  (And must be done since we don't want</span>
<a href="#l18.68"></a><span id="l18.68">       //  to cause a leak.)</span>
<a href="#l18.69"></a><span id="l18.69">       folder.msgDatabase = null;</span>
<a href="#l18.70"></a><span id="l18.70">     }</span>
<a href="#l18.71"></a><span id="l18.71"> </span>
<a href="#l18.72"></a><span id="l18.72">     PendingCommitTracker._indexedMessagesPendingCommitByGlodaId = {};</span>
<a href="#l18.73"></a><span id="l18.73">     PendingCommitTracker._indexedMessagesPendingCommitByKey = {};</span>
<a href="#l18.74"></a><span id="l18.74"> </span>
<a href="#l18.75"></a><span id="l18.75">     PendingCommitTracker._pendingCommit = false;</span>
<a href="#l18.76"></a><span id="l18.76">   },</span>
<a href="#l18.77"></a><span id="l18.77"> </span>
<a href="#l18.78"></a><span id="l18.78">   /**</span>
<a href="#l18.79"></a><span id="l18.79">    * Track a message header that should be marked with the given gloda id when</span>
<a href="#l18.80"></a><span id="l18.80">    *  the database commits.</span>
<a href="#l18.81"></a><span id="l18.81">    */</span>
<a href="#l18.82"></a><span id="l18.82" class="difflineminus">-  track: function PendingCommitTracker_track(aMsgHdr, aGlodaId) {</span>
<a href="#l18.83"></a><span id="l18.83" class="difflineplus">+  track(aMsgHdr, aGlodaId) {</span>
<a href="#l18.84"></a><span id="l18.84">     let pendingKey = aMsgHdr.folder.URI + &quot;#&quot; + aMsgHdr.messageKey;</span>
<a href="#l18.85"></a><span id="l18.85">     this._indexedMessagesPendingCommitByKey[pendingKey] = aGlodaId;</span>
<a href="#l18.86"></a><span id="l18.86">     this._indexedMessagesPendingCommitByGlodaId[aGlodaId] =</span>
<a href="#l18.87"></a><span id="l18.87">       [aMsgHdr, GlodaMsgIndexer.kMessageClean];</span>
<a href="#l18.88"></a><span id="l18.88"> </span>
<a href="#l18.89"></a><span id="l18.89">     if (!this._pendingCommit) {</span>
<a href="#l18.90"></a><span id="l18.90">       GlodaDatastore.runPostCommit(this._commitCallback);</span>
<a href="#l18.91"></a><span id="l18.91">       this._pendingCommit = true;</span>
<a href="#l18.92"></a><span id="l18.92" class="difflineat">@@ -199,41 +198,39 @@ var PendingCommitTracker = {</span>
<a href="#l18.93"></a><span id="l18.93"> </span>
<a href="#l18.94"></a><span id="l18.94">   /**</span>
<a href="#l18.95"></a><span id="l18.95">    * Get the current state of a message header given that we cannot rely on just</span>
<a href="#l18.96"></a><span id="l18.96">    *  looking at the header's properties because we defer setting those</span>
<a href="#l18.97"></a><span id="l18.97">    *  until the SQLite commit happens.</span>
<a href="#l18.98"></a><span id="l18.98">    *</span>
<a href="#l18.99"></a><span id="l18.99">    * @return Tuple of [gloda id, dirty status].</span>
<a href="#l18.100"></a><span id="l18.100">    */</span>
<a href="#l18.101"></a><span id="l18.101" class="difflineminus">-  getGlodaState:</span>
<a href="#l18.102"></a><span id="l18.102" class="difflineminus">-      function PendingCommitTracker_getGlodaState(aMsgHdr) {</span>
<a href="#l18.103"></a><span id="l18.103" class="difflineplus">+  getGlodaState(aMsgHdr) {</span>
<a href="#l18.104"></a><span id="l18.104">     // If it's in the pending commit table, then the message is basically</span>
<a href="#l18.105"></a><span id="l18.105">     //  clean.  Return that info.</span>
<a href="#l18.106"></a><span id="l18.106">     let pendingKey = aMsgHdr.folder.URI + &quot;#&quot; + aMsgHdr.messageKey;</span>
<a href="#l18.107"></a><span id="l18.107">     if (pendingKey in this._indexedMessagesPendingCommitByKey) {</span>
<a href="#l18.108"></a><span id="l18.108">       let glodaId =</span>
<a href="#l18.109"></a><span id="l18.109">         PendingCommitTracker._indexedMessagesPendingCommitByKey[pendingKey];</span>
<a href="#l18.110"></a><span id="l18.110">       return [glodaId, this._indexedMessagesPendingCommitByGlodaId[glodaId][1]];</span>
<a href="#l18.111"></a><span id="l18.111">     }</span>
<a href="#l18.112"></a><span id="l18.112" class="difflineminus">-    else {</span>
<a href="#l18.113"></a><span id="l18.113" class="difflineminus">-      // Otherwise the header's concept of state is correct.</span>
<a href="#l18.114"></a><span id="l18.114" class="difflineminus">-      let glodaId = aMsgHdr.getUint32Property(GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l18.115"></a><span id="l18.115" class="difflineminus">-      let glodaDirty = aMsgHdr.getUint32Property(GLODA_DIRTY_PROPERTY);</span>
<a href="#l18.116"></a><span id="l18.116" class="difflineminus">-      return [glodaId, glodaDirty];</span>
<a href="#l18.117"></a><span id="l18.117" class="difflineminus">-    }</span>
<a href="#l18.118"></a><span id="l18.118" class="difflineplus">+</span>
<a href="#l18.119"></a><span id="l18.119" class="difflineplus">+    // Otherwise the header's concept of state is correct.</span>
<a href="#l18.120"></a><span id="l18.120" class="difflineplus">+    let glodaId = aMsgHdr.getUint32Property(GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l18.121"></a><span id="l18.121" class="difflineplus">+    let glodaDirty = aMsgHdr.getUint32Property(GLODA_DIRTY_PROPERTY);</span>
<a href="#l18.122"></a><span id="l18.122" class="difflineplus">+    return [glodaId, glodaDirty];</span>
<a href="#l18.123"></a><span id="l18.123">   },</span>
<a href="#l18.124"></a><span id="l18.124"> </span>
<a href="#l18.125"></a><span id="l18.125">   /**</span>
<a href="#l18.126"></a><span id="l18.126">    * Update our structure to reflect moved headers.  Moves are currently</span>
<a href="#l18.127"></a><span id="l18.127">    *  treated as weakly interesting and do not require a reindexing</span>
<a href="#l18.128"></a><span id="l18.128">    *  although collections will get notified.  So our job is to to fix-up</span>
<a href="#l18.129"></a><span id="l18.129">    *  the pending commit information if the message has a pending commit.</span>
<a href="#l18.130"></a><span id="l18.130">    */</span>
<a href="#l18.131"></a><span id="l18.131" class="difflineminus">-  noteMove: function PendingCommitTracker_noteMove(aOldHdr, aNewHdr) {</span>
<a href="#l18.132"></a><span id="l18.132" class="difflineplus">+  noteMove(aOldHdr, aNewHdr) {</span>
<a href="#l18.133"></a><span id="l18.133">     let oldKey = aOldHdr.folder.URI + &quot;#&quot; + aOldHdr.messageKey;</span>
<a href="#l18.134"></a><span id="l18.134">     if (!(oldKey in this._indexedMessagesPendingCommitByKey))</span>
<a href="#l18.135"></a><span id="l18.135">       return;</span>
<a href="#l18.136"></a><span id="l18.136"> </span>
<a href="#l18.137"></a><span id="l18.137">     let glodaId = this._indexedMessagesPendingCommitByKey[oldKey];</span>
<a href="#l18.138"></a><span id="l18.138">     delete this._indexedMessagesPendingCommitByKey[oldKey];</span>
<a href="#l18.139"></a><span id="l18.139"> </span>
<a href="#l18.140"></a><span id="l18.140">     let newKey = aNewHdr.folder.URI + &quot;#&quot; + aNewHdr.messageKey;</span>
<a href="#l18.141"></a><span id="l18.141" class="difflineat">@@ -251,29 +248,29 @@ var PendingCommitTracker = {</span>
<a href="#l18.142"></a><span id="l18.142">    *  we could detect the other side of the move when it shows up as a</span>
<a href="#l18.143"></a><span id="l18.143">    *  msgsClassified event and restore the mapping information.  Since the</span>
<a href="#l18.144"></a><span id="l18.144">    *  offline fake header case should now cover the bulk of IMAP move</span>
<a href="#l18.145"></a><span id="l18.145">    *  operations, we probably do not need to pursue this.</span>
<a href="#l18.146"></a><span id="l18.146">    *</span>
<a href="#l18.147"></a><span id="l18.147">    * We just re-dispatch to noteDirtyHeader because we can't do anything more</span>
<a href="#l18.148"></a><span id="l18.148">    *  clever.</span>
<a href="#l18.149"></a><span id="l18.149">    */</span>
<a href="#l18.150"></a><span id="l18.150" class="difflineminus">-  noteBlindMove: function PendingCommitTracker_noteBlindMove(aOldHdr) {</span>
<a href="#l18.151"></a><span id="l18.151" class="difflineplus">+  noteBlindMove(aOldHdr) {</span>
<a href="#l18.152"></a><span id="l18.152">     this.noteDirtyHeader(aOldHdr);</span>
<a href="#l18.153"></a><span id="l18.153">   },</span>
<a href="#l18.154"></a><span id="l18.154"> </span>
<a href="#l18.155"></a><span id="l18.155">   /**</span>
<a href="#l18.156"></a><span id="l18.156">    * If a message is dirty we should stop tracking it for post-commit</span>
<a href="#l18.157"></a><span id="l18.157">    *  purposes.  This is not because we don't want to write to its header</span>
<a href="#l18.158"></a><span id="l18.158">    *  when we commit as much as that we want to avoid |getHeaderGlodaState|</span>
<a href="#l18.159"></a><span id="l18.159">    *  reporting that the message is clean.  We could complicate our state</span>
<a href="#l18.160"></a><span id="l18.160">    *  by storing that information, but this is easier and ends up the same</span>
<a href="#l18.161"></a><span id="l18.161">    *  in the end.</span>
<a href="#l18.162"></a><span id="l18.162">    */</span>
<a href="#l18.163"></a><span id="l18.163" class="difflineminus">-  noteDirtyHeader: function PendingCommitTracker_noteDirtyHeader(aMsgHdr) {</span>
<a href="#l18.164"></a><span id="l18.164" class="difflineplus">+  noteDirtyHeader(aMsgHdr) {</span>
<a href="#l18.165"></a><span id="l18.165">     let pendingKey = aMsgHdr.folder.URI + &quot;#&quot; + aMsgHdr.messageKey;</span>
<a href="#l18.166"></a><span id="l18.166">     if (!(pendingKey in this._indexedMessagesPendingCommitByKey))</span>
<a href="#l18.167"></a><span id="l18.167">       return;</span>
<a href="#l18.168"></a><span id="l18.168"> </span>
<a href="#l18.169"></a><span id="l18.169">     // (It is important that we get the gloda id from our own structure!)</span>
<a href="#l18.170"></a><span id="l18.170">     let glodaId = this._indexedMessagesPendingCommitByKey[pendingKey];</span>
<a href="#l18.171"></a><span id="l18.171">     this._indexedMessagesPendingCommitByGlodaId[glodaId][1] =</span>
<a href="#l18.172"></a><span id="l18.172">       GlodaMsgIndexer.kMessageDirty;</span>
<a href="#l18.173"></a><span id="l18.173" class="difflineat">@@ -289,19 +286,17 @@ var PendingCommitTracker = {</span>
<a href="#l18.174"></a><span id="l18.174">    * When this happens, we are basically out of luck and need to discard</span>
<a href="#l18.175"></a><span id="l18.175">    *  everything about the folder.  The good news is that the folder compaction</span>
<a href="#l18.176"></a><span id="l18.176">    *  pass is clever enough to re-establish the linkages that are being lost</span>
<a href="#l18.177"></a><span id="l18.177">    *  when we drop these things on the floor.  Reindexing of a folder is not</span>
<a href="#l18.178"></a><span id="l18.178">    *  clever enough to deal with this but is an exceptional case of last resort</span>
<a href="#l18.179"></a><span id="l18.179">    *  (the user should not normally be performing a reindex as part of daily</span>
<a href="#l18.180"></a><span id="l18.180">    *  operation), so we accept that messages may be redundantly indexed.</span>
<a href="#l18.181"></a><span id="l18.181">    */</span>
<a href="#l18.182"></a><span id="l18.182" class="difflineminus">-  noteFolderDatabaseGettingBlownAway:</span>
<a href="#l18.183"></a><span id="l18.183" class="difflineminus">-      function PendingCommitTracker_noteFolderDatabaseGettingBlownAway(</span>
<a href="#l18.184"></a><span id="l18.184" class="difflineminus">-                 aMsgFolder) {</span>
<a href="#l18.185"></a><span id="l18.185" class="difflineplus">+  noteFolderDatabaseGettingBlownAway(aMsgFolder) {</span>
<a href="#l18.186"></a><span id="l18.186">     let uri = aMsgFolder.URI + &quot;#&quot;;</span>
<a href="#l18.187"></a><span id="l18.187">     for (let key of Object.keys(this._indexedMessagesPendingCommitByKey)) {</span>
<a href="#l18.188"></a><span id="l18.188">       // this is not as efficient as it could be, but compaction is relatively</span>
<a href="#l18.189"></a><span id="l18.189">       //  rare and the number of pending headers is generally going to be</span>
<a href="#l18.190"></a><span id="l18.190">       //  small.</span>
<a href="#l18.191"></a><span id="l18.191">       if (key.indexOf(uri) == 0) {</span>
<a href="#l18.192"></a><span id="l18.192">         delete this._indexedMessagesPendingCommitByKey[key];</span>
<a href="#l18.193"></a><span id="l18.193">       }</span>
<a href="#l18.194"></a><span id="l18.194" class="difflineat">@@ -319,38 +314,38 @@ function MessagesByMessageIdCallback(aMs</span>
<a href="#l18.195"></a><span id="l18.195">   this.results = aResults;</span>
<a href="#l18.196"></a><span id="l18.196">   this.callback = aCallback;</span>
<a href="#l18.197"></a><span id="l18.197">   this.callbackThis = aCallbackThis;</span>
<a href="#l18.198"></a><span id="l18.198"> }</span>
<a href="#l18.199"></a><span id="l18.199"> </span>
<a href="#l18.200"></a><span id="l18.200"> MessagesByMessageIdCallback.prototype = {</span>
<a href="#l18.201"></a><span id="l18.201">   _log: Log4Moz.repository.getLogger(&quot;gloda.index_msg.mbm&quot;),</span>
<a href="#l18.202"></a><span id="l18.202"> </span>
<a href="#l18.203"></a><span id="l18.203" class="difflineminus">-  onItemsAdded: function gloda_ds_mbmi_onItemsAdded(aItems, aCollection) {</span>
<a href="#l18.204"></a><span id="l18.204" class="difflineplus">+  onItemsAdded(aItems, aCollection) {</span>
<a href="#l18.205"></a><span id="l18.205">     // just outright bail if we are shutdown</span>
<a href="#l18.206"></a><span id="l18.206">     if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l18.207"></a><span id="l18.207">       return;</span>
<a href="#l18.208"></a><span id="l18.208"> </span>
<a href="#l18.209"></a><span id="l18.209">     this._log.debug(&quot;getting results...&quot;);</span>
<a href="#l18.210"></a><span id="l18.210">     for (let message of aItems) {</span>
<a href="#l18.211"></a><span id="l18.211">       this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l18.212"></a><span id="l18.212">     }</span>
<a href="#l18.213"></a><span id="l18.213">   },</span>
<a href="#l18.214"></a><span id="l18.214" class="difflineminus">-  onItemsModified: function () {},</span>
<a href="#l18.215"></a><span id="l18.215" class="difflineminus">-  onItemsRemoved: function () {},</span>
<a href="#l18.216"></a><span id="l18.216" class="difflineminus">-  onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l18.217"></a><span id="l18.217" class="difflineplus">+  onItemsModified() {},</span>
<a href="#l18.218"></a><span id="l18.218" class="difflineplus">+  onItemsRemoved() {},</span>
<a href="#l18.219"></a><span id="l18.219" class="difflineplus">+  onQueryCompleted(aCollection) {</span>
<a href="#l18.220"></a><span id="l18.220">     // just outright bail if we are shutdown</span>
<a href="#l18.221"></a><span id="l18.221">     if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l18.222"></a><span id="l18.222">       return;</span>
<a href="#l18.223"></a><span id="l18.223"> </span>
<a href="#l18.224"></a><span id="l18.224">     if (this._log.level &lt;= Log4Moz.Level.Debug)</span>
<a href="#l18.225"></a><span id="l18.225">       this._log.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l18.226"></a><span id="l18.226"> </span>
<a href="#l18.227"></a><span id="l18.227">     this.callback.call(this.callbackThis, this.results);</span>
<a href="#l18.228"></a><span id="l18.228" class="difflineminus">-  }</span>
<a href="#l18.229"></a><span id="l18.229" class="difflineplus">+  },</span>
<a href="#l18.230"></a><span id="l18.230"> };</span>
<a href="#l18.231"></a><span id="l18.231"> </span>
<a href="#l18.232"></a><span id="l18.232"> </span>
<a href="#l18.233"></a><span id="l18.233"> /**</span>
<a href="#l18.234"></a><span id="l18.234">  * The message indexer!</span>
<a href="#l18.235"></a><span id="l18.235">  *</span>
<a href="#l18.236"></a><span id="l18.236">  * === Message Indexing Strategy</span>
<a href="#l18.237"></a><span id="l18.237">  * To these ends, we implement things like so:</span>
<a href="#l18.238"></a><span id="l18.238" class="difflineat">@@ -424,17 +419,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.239"></a><span id="l18.239"> </span>
<a href="#l18.240"></a><span id="l18.240">   name: &quot;index_msg&quot;,</span>
<a href="#l18.241"></a><span id="l18.241">   /**</span>
<a href="#l18.242"></a><span id="l18.242">    * Are we enabled, read: are we processing change events?</span>
<a href="#l18.243"></a><span id="l18.243">    */</span>
<a href="#l18.244"></a><span id="l18.244">   _enabled: false,</span>
<a href="#l18.245"></a><span id="l18.245">   get enabled() { return this._enabled; },</span>
<a href="#l18.246"></a><span id="l18.246"> </span>
<a href="#l18.247"></a><span id="l18.247" class="difflineminus">-  enable: function msg_indexer_enable() {</span>
<a href="#l18.248"></a><span id="l18.248" class="difflineplus">+  enable() {</span>
<a href="#l18.249"></a><span id="l18.249">     // initialize our listeners' this pointers</span>
<a href="#l18.250"></a><span id="l18.250">     this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l18.251"></a><span id="l18.251">     this._msgFolderListener.indexer = this;</span>
<a href="#l18.252"></a><span id="l18.252"> </span>
<a href="#l18.253"></a><span id="l18.253">     // register for:</span>
<a href="#l18.254"></a><span id="l18.254">     // - folder loaded events, so we know when getDatabaseWithReparse has</span>
<a href="#l18.255"></a><span id="l18.255">     //   finished updating the index/what not (if it wasn't immediately</span>
<a href="#l18.256"></a><span id="l18.256">     //   available)</span>
<a href="#l18.257"></a><span id="l18.257" class="difflineat">@@ -459,17 +454,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.258"></a><span id="l18.258">         Ci.nsIMsgFolderNotificationService.itemEvent);</span>
<a href="#l18.259"></a><span id="l18.259"> </span>
<a href="#l18.260"></a><span id="l18.260">     this._enabled = true;</span>
<a href="#l18.261"></a><span id="l18.261"> </span>
<a href="#l18.262"></a><span id="l18.262">     this._considerSchemaMigration();</span>
<a href="#l18.263"></a><span id="l18.263"> </span>
<a href="#l18.264"></a><span id="l18.264">     this._log.info(&quot;Event-Driven Indexing is now &quot; + this._enabled);</span>
<a href="#l18.265"></a><span id="l18.265">   },</span>
<a href="#l18.266"></a><span id="l18.266" class="difflineminus">-  disable: function msg_indexer_disable() {</span>
<a href="#l18.267"></a><span id="l18.267" class="difflineplus">+  disable() {</span>
<a href="#l18.268"></a><span id="l18.268">     // remove FolderLoaded notification listener</span>
<a href="#l18.269"></a><span id="l18.269">     MailServices.mailSession.RemoveFolderListener(this._folderListener);</span>
<a href="#l18.270"></a><span id="l18.270"> </span>
<a href="#l18.271"></a><span id="l18.271">     MailServices.mfn.removeListener(this._msgFolderListener);</span>
<a href="#l18.272"></a><span id="l18.272"> </span>
<a href="#l18.273"></a><span id="l18.273">     this._indexerLeaveFolder(); // nop if we aren't &quot;in&quot; a folder</span>
<a href="#l18.274"></a><span id="l18.274"> </span>
<a href="#l18.275"></a><span id="l18.275">     this._enabled = false;</span>
<a href="#l18.276"></a><span id="l18.276" class="difflineat">@@ -569,17 +564,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.277"></a><span id="l18.277">    *  cutting down on duplicate code, this ensures that we are listening on</span>
<a href="#l18.278"></a><span id="l18.278">    *  the folder in case it tries to go away when we are using it.</span>
<a href="#l18.279"></a><span id="l18.279">    *</span>
<a href="#l18.280"></a><span id="l18.280">    * @return true when the folder was successfully entered, false when we need</span>
<a href="#l18.281"></a><span id="l18.281">    *     to pend on notification of updating of the folder (due to re-parsing</span>
<a href="#l18.282"></a><span id="l18.282">    *     or what have you).  In the event of an actual problem, an exception</span>
<a href="#l18.283"></a><span id="l18.283">    *     will escape.</span>
<a href="#l18.284"></a><span id="l18.284">    */</span>
<a href="#l18.285"></a><span id="l18.285" class="difflineminus">-  _indexerEnterFolder: function gloda_index_indexerEnterFolder(aFolderID) {</span>
<a href="#l18.286"></a><span id="l18.286" class="difflineplus">+  _indexerEnterFolder(aFolderID) {</span>
<a href="#l18.287"></a><span id="l18.287">     // leave the folder if we haven't explicitly left it.</span>
<a href="#l18.288"></a><span id="l18.288">     if (this._indexingFolder !== null) {</span>
<a href="#l18.289"></a><span id="l18.289">       this._indexerLeaveFolder();</span>
<a href="#l18.290"></a><span id="l18.290">     }</span>
<a href="#l18.291"></a><span id="l18.291"> </span>
<a href="#l18.292"></a><span id="l18.292">     this._indexingGlodaFolder = GlodaDatastore._mapFolderID(aFolderID);</span>
<a href="#l18.293"></a><span id="l18.293">     this._indexingFolder = this._indexingGlodaFolder.getXPCOMFolder(</span>
<a href="#l18.294"></a><span id="l18.294">                              this._indexingGlodaFolder.kActivityIndexing);</span>
<a href="#l18.295"></a><span id="l18.295" class="difflineat">@@ -592,43 +587,40 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.296"></a><span id="l18.296">       // This may require yielding until such time as the msf has been created.</span>
<a href="#l18.297"></a><span id="l18.297">       try {</span>
<a href="#l18.298"></a><span id="l18.298">         if (this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l18.299"></a><span id="l18.299">           this._indexingDatabase =</span>
<a href="#l18.300"></a><span id="l18.300">             this._indexingFolder.getDatabaseWithReparse(null,</span>
<a href="#l18.301"></a><span id="l18.301">                                                         null);</span>
<a href="#l18.302"></a><span id="l18.302">         }</span>
<a href="#l18.303"></a><span id="l18.303">         // we need do nothing special for IMAP, news, or other</span>
<a href="#l18.304"></a><span id="l18.304" class="difflineminus">-      }</span>
<a href="#l18.305"></a><span id="l18.305" class="difflineminus">-      // getDatabaseWithReparse can return either NS_ERROR_NOT_INITIALIZED or</span>
<a href="#l18.306"></a><span id="l18.306" class="difflineminus">-      //  NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE if the net result is that it</span>
<a href="#l18.307"></a><span id="l18.307" class="difflineminus">-      //  is going to send us a notification when the reparse has completed.</span>
<a href="#l18.308"></a><span id="l18.308" class="difflineminus">-      // (note that although internally NS_MSG_ERROR_FOLDER_SUMMARY_MISSING</span>
<a href="#l18.309"></a><span id="l18.309" class="difflineminus">-      //  might get flung around, it won't make it out to us, and will instead</span>
<a href="#l18.310"></a><span id="l18.310" class="difflineminus">-      //  be permuted into an NS_ERROR_NOT_INITIALIZED.)</span>
<a href="#l18.311"></a><span id="l18.311" class="difflineminus">-      catch (e) {</span>
<a href="#l18.312"></a><span id="l18.312" class="difflineplus">+      } catch (e) {</span>
<a href="#l18.313"></a><span id="l18.313" class="difflineplus">+        // getDatabaseWithReparse can return either NS_ERROR_NOT_INITIALIZED or</span>
<a href="#l18.314"></a><span id="l18.314" class="difflineplus">+        //  NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE if the net result is that it</span>
<a href="#l18.315"></a><span id="l18.315" class="difflineplus">+        //  is going to send us a notification when the reparse has completed.</span>
<a href="#l18.316"></a><span id="l18.316" class="difflineplus">+        // (note that although internally NS_MSG_ERROR_FOLDER_SUMMARY_MISSING</span>
<a href="#l18.317"></a><span id="l18.317" class="difflineplus">+        //  might get flung around, it won't make it out to us, and will instead</span>
<a href="#l18.318"></a><span id="l18.318" class="difflineplus">+        //  be permuted into an NS_ERROR_NOT_INITIALIZED.)</span>
<a href="#l18.319"></a><span id="l18.319">         if ((e.result == Cr.NS_ERROR_NOT_INITIALIZED) ||</span>
<a href="#l18.320"></a><span id="l18.320">             (e.result == NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE)) {</span>
<a href="#l18.321"></a><span id="l18.321">           // this means that we need to pend on the update; the listener for</span>
<a href="#l18.322"></a><span id="l18.322">           //  FolderLoaded events will call _indexerCompletePendingFolderEntry.</span>
<a href="#l18.323"></a><span id="l18.323">           this._log.debug(&quot;Pending on folder load...&quot;);</span>
<a href="#l18.324"></a><span id="l18.324">           this._pendingFolderEntry = this._indexingFolder;</span>
<a href="#l18.325"></a><span id="l18.325">           return this.kWorkAsync;</span>
<a href="#l18.326"></a><span id="l18.326" class="difflineminus">-        } else {</span>
<a href="#l18.327"></a><span id="l18.327" class="difflineminus">-          throw e;</span>
<a href="#l18.328"></a><span id="l18.328">         }</span>
<a href="#l18.329"></a><span id="l18.329" class="difflineplus">+        throw e;</span>
<a href="#l18.330"></a><span id="l18.330">       }</span>
<a href="#l18.331"></a><span id="l18.331">       // we get an nsIMsgDatabase out of this (unsurprisingly) which</span>
<a href="#l18.332"></a><span id="l18.332">       //  explicitly inherits from nsIDBChangeAnnouncer, which has the</span>
<a href="#l18.333"></a><span id="l18.333">       //  AddListener call we want.</span>
<a href="#l18.334"></a><span id="l18.334">       if (this._indexingDatabase == null)</span>
<a href="#l18.335"></a><span id="l18.335">         this._indexingDatabase = this._indexingFolder.msgDatabase;</span>
<a href="#l18.336"></a><span id="l18.336">       this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l18.337"></a><span id="l18.337" class="difflineminus">-    }</span>
<a href="#l18.338"></a><span id="l18.338" class="difflineminus">-    catch (ex) {</span>
<a href="#l18.339"></a><span id="l18.339" class="difflineplus">+    } catch (ex) {</span>
<a href="#l18.340"></a><span id="l18.340">       this._log.error(&quot;Problem entering folder: &quot; +</span>
<a href="#l18.341"></a><span id="l18.341">                       (this._indexingFolder ?</span>
<a href="#l18.342"></a><span id="l18.342">                          this._indexingFolder.prettyName : &quot;unknown&quot;) +</span>
<a href="#l18.343"></a><span id="l18.343">                       &quot;, skipping. Error was: &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l18.344"></a><span id="l18.344">                       ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l18.345"></a><span id="l18.345">       this._indexingGlodaFolder.indexing = false;</span>
<a href="#l18.346"></a><span id="l18.346">       this._indexingFolder = null;</span>
<a href="#l18.347"></a><span id="l18.347">       this._indexingGlodaFolder = null;</span>
<a href="#l18.348"></a><span id="l18.348" class="difflineat">@@ -644,18 +636,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.349"></a><span id="l18.349">   },</span>
<a href="#l18.350"></a><span id="l18.350"> </span>
<a href="#l18.351"></a><span id="l18.351">   /**</span>
<a href="#l18.352"></a><span id="l18.352">    * If the folder was still parsing/updating when we tried to enter, then this</span>
<a href="#l18.353"></a><span id="l18.353">    *  handler will get called by the listener who got the FolderLoaded message.</span>
<a href="#l18.354"></a><span id="l18.354">    * All we need to do is get the database reference, register a listener on</span>
<a href="#l18.355"></a><span id="l18.355">    *  the db, and retrieve an iterator if desired.</span>
<a href="#l18.356"></a><span id="l18.356">    */</span>
<a href="#l18.357"></a><span id="l18.357" class="difflineminus">-  _indexerCompletePendingFolderEntry:</span>
<a href="#l18.358"></a><span id="l18.358" class="difflineminus">-      function gloda_indexer_indexerCompletePendingFolderEntry() {</span>
<a href="#l18.359"></a><span id="l18.359" class="difflineplus">+  _indexerCompletePendingFolderEntry() {</span>
<a href="#l18.360"></a><span id="l18.360">     this._indexingDatabase = this._indexingFolder.msgDatabase;</span>
<a href="#l18.361"></a><span id="l18.361">     this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l18.362"></a><span id="l18.362">     this._log.debug(&quot;...Folder Loaded!&quot;);</span>
<a href="#l18.363"></a><span id="l18.363"> </span>
<a href="#l18.364"></a><span id="l18.364">     // the load is no longer pending; we certainly don't want more notifications</span>
<a href="#l18.365"></a><span id="l18.365">     this._pendingFolderEntry = null;</span>
<a href="#l18.366"></a><span id="l18.366">     // indexerEnterFolder returned kWorkAsync, which means we need to notify</span>
<a href="#l18.367"></a><span id="l18.367">     //  the callback driver to get things going again.</span>
<a href="#l18.368"></a><span id="l18.368" class="difflineat">@@ -680,18 +671,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.369"></a><span id="l18.369">    *  in |_indexingFolder|.</span>
<a href="#l18.370"></a><span id="l18.370">    *</span>
<a href="#l18.371"></a><span id="l18.371">    * @param aEnumKind One of |kEnumAllMsgs|, |kEnumMsgsToIndex|, or</span>
<a href="#l18.372"></a><span id="l18.372">    *     |kEnumIndexedMsgs|.</span>
<a href="#l18.373"></a><span id="l18.373">    * @param [aAllowPreBadIds=false] Only valid for |kEnumIndexedMsgs|, tells us</span>
<a href="#l18.374"></a><span id="l18.374">    *     that we should treat message with any gloda-id as dirty, not just</span>
<a href="#l18.375"></a><span id="l18.375">    *     messages that have non-bad message id's.</span>
<a href="#l18.376"></a><span id="l18.376">    */</span>
<a href="#l18.377"></a><span id="l18.377" class="difflineminus">-  _indexerGetEnumerator: function gloda_indexer_indexerGetEnumerator(</span>
<a href="#l18.378"></a><span id="l18.378" class="difflineminus">-      aEnumKind, aAllowPreBadIds) {</span>
<a href="#l18.379"></a><span id="l18.379" class="difflineplus">+  _indexerGetEnumerator(aEnumKind, aAllowPreBadIds) {</span>
<a href="#l18.380"></a><span id="l18.380">     if (aEnumKind == this.kEnumMsgsToIndex) {</span>
<a href="#l18.381"></a><span id="l18.381">       // We need to create search terms for messages to index. Messages should</span>
<a href="#l18.382"></a><span id="l18.382">       //  be indexed if they're indexable (local or offline and not expunged)</span>
<a href="#l18.383"></a><span id="l18.383">       //  and either: haven't been indexed, are dirty, or are marked with with</span>
<a href="#l18.384"></a><span id="l18.384">       //  a former GLODA_BAD_MESSAGE_ID that is no longer our bad marker.  (Our</span>
<a href="#l18.385"></a><span id="l18.385">       //  bad marker can change on minor schema revs so that we can try and</span>
<a href="#l18.386"></a><span id="l18.386">       //  reindex those messages exactly once and without needing to go through</span>
<a href="#l18.387"></a><span id="l18.387">       //  a pass to mark them as needing one more try.)</span>
<a href="#l18.388"></a><span id="l18.388" class="difflineat">@@ -762,18 +752,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.389"></a><span id="l18.389">       searchTerm.op = nsMsgSearchOp.Isnt;</span>
<a href="#l18.390"></a><span id="l18.390">       value = searchTerm.value;</span>
<a href="#l18.391"></a><span id="l18.391">       value.attrib = searchTerm.attrib;</span>
<a href="#l18.392"></a><span id="l18.392">       value.str = JUNK_SPAM_SCORE_STR;</span>
<a href="#l18.393"></a><span id="l18.393">       searchTerm.value = value;</span>
<a href="#l18.394"></a><span id="l18.394">       searchTerm.hdrProperty = JUNK_SCORE_PROPERTY;</span>
<a href="#l18.395"></a><span id="l18.395">       searchTerms.appendElement(searchTerm);</span>
<a href="#l18.396"></a><span id="l18.396"> </span>
<a href="#l18.397"></a><span id="l18.397" class="difflineminus">-      if (!isLocal)</span>
<a href="#l18.398"></a><span id="l18.398" class="difflineminus">-      {</span>
<a href="#l18.399"></a><span id="l18.399" class="difflineplus">+      if (!isLocal) {</span>
<a href="#l18.400"></a><span id="l18.400">         // If the folder is offline, then the message should be too</span>
<a href="#l18.401"></a><span id="l18.401">         if (this._indexingFolder.getFlag(Ci.nsMsgFolderFlags.Offline)) {</span>
<a href="#l18.402"></a><span id="l18.402">           // third term: &amp;&amp; Status Is nsMsgMessageFlags.Offline</span>
<a href="#l18.403"></a><span id="l18.403">           searchTerm = searchSession.createTerm();</span>
<a href="#l18.404"></a><span id="l18.404">           searchTerm.booleanAnd = true;</span>
<a href="#l18.405"></a><span id="l18.405">           searchTerm.attrib = nsMsgSearchAttrib.MsgStatus;</span>
<a href="#l18.406"></a><span id="l18.406">           searchTerm.op = nsMsgSearchOp.Is;</span>
<a href="#l18.407"></a><span id="l18.407">           value = searchTerm.value;</span>
<a href="#l18.408"></a><span id="l18.408" class="difflineat">@@ -792,18 +781,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.409"></a><span id="l18.409">         value.attrib = searchTerm.attrib;</span>
<a href="#l18.410"></a><span id="l18.410">         value.status = Ci.nsMsgMessageFlags.Expunged;</span>
<a href="#l18.411"></a><span id="l18.411">         searchTerm.value = value;</span>
<a href="#l18.412"></a><span id="l18.412">         searchTerms.appendElement(searchTerm);</span>
<a href="#l18.413"></a><span id="l18.413">       }</span>
<a href="#l18.414"></a><span id="l18.414"> </span>
<a href="#l18.415"></a><span id="l18.415">       this._indexingEnumerator =</span>
<a href="#l18.416"></a><span id="l18.416">         this._indexingDatabase.getFilterEnumerator(searchTerms, true);</span>
<a href="#l18.417"></a><span id="l18.417" class="difflineminus">-    }</span>
<a href="#l18.418"></a><span id="l18.418" class="difflineminus">-    else if (aEnumKind == this.kEnumIndexedMsgs) {</span>
<a href="#l18.419"></a><span id="l18.419" class="difflineplus">+    } else if (aEnumKind == this.kEnumIndexedMsgs) {</span>
<a href="#l18.420"></a><span id="l18.420">       // Enumerate only messages that are already indexed.  This comes out to:</span>
<a href="#l18.421"></a><span id="l18.421">       //  ((GLODA_MESSAGE_ID_PROPERTY &gt; GLODA_FIRST_VALID_MESSAGE_ID-1) &amp;&amp;</span>
<a href="#l18.422"></a><span id="l18.422">       //   (GLODA_DIRTY_PROPERTY Isnt kMessageFilthy))</span>
<a href="#l18.423"></a><span id="l18.423">       // In English, a message is indexed if (by clause):</span>
<a href="#l18.424"></a><span id="l18.424">       // 1) The message has a gloda-id and that gloda-id is in the valid range</span>
<a href="#l18.425"></a><span id="l18.425">       //    (and not in the bad message marker range).</span>
<a href="#l18.426"></a><span id="l18.426">       // 2) The message has not been marked filthy (which invalidates the</span>
<a href="#l18.427"></a><span id="l18.427">       //    gloda-id.)  We also assume that the folder would not have been</span>
<a href="#l18.428"></a><span id="l18.428" class="difflineat">@@ -845,27 +833,25 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.429"></a><span id="l18.429">       searchTerm.value = value;</span>
<a href="#l18.430"></a><span id="l18.430">       searchTerm.hdrProperty = GLODA_DIRTY_PROPERTY;</span>
<a href="#l18.431"></a><span id="l18.431">       searchTerms.appendElement(searchTerm);</span>
<a href="#l18.432"></a><span id="l18.432"> </span>
<a href="#l18.433"></a><span id="l18.433">       // The use-case of already indexed messages does not want them reversed;</span>
<a href="#l18.434"></a><span id="l18.434">       //  we care about seeing the message keys in order.</span>
<a href="#l18.435"></a><span id="l18.435">       this._indexingEnumerator =</span>
<a href="#l18.436"></a><span id="l18.436">         this._indexingDatabase.getFilterEnumerator(searchTerms, false);</span>
<a href="#l18.437"></a><span id="l18.437" class="difflineminus">-    }</span>
<a href="#l18.438"></a><span id="l18.438" class="difflineminus">-    else if (aEnumKind == this.kEnumAllMsgs) {</span>
<a href="#l18.439"></a><span id="l18.439" class="difflineplus">+    } else if (aEnumKind == this.kEnumAllMsgs) {</span>
<a href="#l18.440"></a><span id="l18.440">       this._indexingEnumerator =</span>
<a href="#l18.441"></a><span id="l18.441">         this._indexingDatabase.ReverseEnumerateMessages();</span>
<a href="#l18.442"></a><span id="l18.442" class="difflineminus">-    }</span>
<a href="#l18.443"></a><span id="l18.443" class="difflineminus">-    else {</span>
<a href="#l18.444"></a><span id="l18.444" class="difflineplus">+    } else {</span>
<a href="#l18.445"></a><span id="l18.445">       throw new Error(&quot;Unknown enumerator type requested:&quot; + aEnumKind);</span>
<a href="#l18.446"></a><span id="l18.446">     }</span>
<a href="#l18.447"></a><span id="l18.447">   },</span>
<a href="#l18.448"></a><span id="l18.448"> </span>
<a href="#l18.449"></a><span id="l18.449" class="difflineminus">-  _indexerLeaveFolder: function gloda_index_indexerLeaveFolder() {</span>
<a href="#l18.450"></a><span id="l18.450" class="difflineplus">+  _indexerLeaveFolder() {</span>
<a href="#l18.451"></a><span id="l18.451">     if (this._indexingFolder !== null) {</span>
<a href="#l18.452"></a><span id="l18.452">       if (this._indexingDatabase) {</span>
<a href="#l18.453"></a><span id="l18.453">         this._indexingDatabase.Commit(Ci.nsMsgDBCommitType.kLargeCommit);</span>
<a href="#l18.454"></a><span id="l18.454">         // remove our listener!</span>
<a href="#l18.455"></a><span id="l18.455">         this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l18.456"></a><span id="l18.456">       }</span>
<a href="#l18.457"></a><span id="l18.457">       // let the gloda folder know we are done indexing</span>
<a href="#l18.458"></a><span id="l18.458">       this._indexingGlodaFolder.indexing = false;</span>
<a href="#l18.459"></a><span id="l18.459" class="difflineat">@@ -880,17 +866,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.460"></a><span id="l18.460">   /**</span>
<a href="#l18.461"></a><span id="l18.461">    * Event fed to us by our nsIFolderListener when a folder is loaded.  We use</span>
<a href="#l18.462"></a><span id="l18.462">    *  this event to know when a folder we were trying to open to index is</span>
<a href="#l18.463"></a><span id="l18.463">    *  actually ready to be indexed.  (The summary may have not existed, may have</span>
<a href="#l18.464"></a><span id="l18.464">    *  been out of date, or otherwise.)</span>
<a href="#l18.465"></a><span id="l18.465">    *</span>
<a href="#l18.466"></a><span id="l18.466">    * @param aFolder An nsIMsgFolder, already QI'd.</span>
<a href="#l18.467"></a><span id="l18.467">    */</span>
<a href="#l18.468"></a><span id="l18.468" class="difflineminus">-  _onFolderLoaded: function gloda_index_onFolderLoaded(aFolder) {</span>
<a href="#l18.469"></a><span id="l18.469" class="difflineplus">+  _onFolderLoaded(aFolder) {</span>
<a href="#l18.470"></a><span id="l18.470">     if ((this._pendingFolderEntry !== null) &amp;&amp;</span>
<a href="#l18.471"></a><span id="l18.471">         (aFolder.URI == this._pendingFolderEntry.URI))</span>
<a href="#l18.472"></a><span id="l18.472">       this._indexerCompletePendingFolderEntry();</span>
<a href="#l18.473"></a><span id="l18.473">   },</span>
<a href="#l18.474"></a><span id="l18.474"> </span>
<a href="#l18.475"></a><span id="l18.475">   // it's a getter so we can reference 'this'.  we could memoize.</span>
<a href="#l18.476"></a><span id="l18.476">   get workers() {</span>
<a href="#l18.477"></a><span id="l18.477">     return [</span>
<a href="#l18.478"></a><span id="l18.478" class="difflineat">@@ -922,26 +908,26 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.479"></a><span id="l18.479"> </span>
<a href="#l18.480"></a><span id="l18.480">       [&quot;fixMissingContacts&quot;, {</span>
<a href="#l18.481"></a><span id="l18.481">         worker: this._worker_fixMissingContacts,</span>
<a href="#l18.482"></a><span id="l18.482">        }],</span>
<a href="#l18.483"></a><span id="l18.483">     ];</span>
<a href="#l18.484"></a><span id="l18.484">   },</span>
<a href="#l18.485"></a><span id="l18.485"> </span>
<a href="#l18.486"></a><span id="l18.486">   _schemaMigrationInitiated: false,</span>
<a href="#l18.487"></a><span id="l18.487" class="difflineminus">-  _considerSchemaMigration: function() {</span>
<a href="#l18.488"></a><span id="l18.488" class="difflineplus">+  _considerSchemaMigration() {</span>
<a href="#l18.489"></a><span id="l18.489">     if (!this._schemaMigrationInitiated &amp;&amp;</span>
<a href="#l18.490"></a><span id="l18.490">         GlodaDatastore._actualSchemaVersion === 26) {</span>
<a href="#l18.491"></a><span id="l18.491">       let job = new IndexingJob(&quot;fixMissingContacts&quot;, null);</span>
<a href="#l18.492"></a><span id="l18.492">       GlodaIndexer.indexJob(job);</span>
<a href="#l18.493"></a><span id="l18.493">       this._schemaMigrationInitiated = true;</span>
<a href="#l18.494"></a><span id="l18.494">     }</span>
<a href="#l18.495"></a><span id="l18.495">   },</span>
<a href="#l18.496"></a><span id="l18.496"> </span>
<a href="#l18.497"></a><span id="l18.497" class="difflineminus">-  initialSweep: function() {</span>
<a href="#l18.498"></a><span id="l18.498" class="difflineplus">+  initialSweep() {</span>
<a href="#l18.499"></a><span id="l18.499">     this.indexingSweepNeeded = true;</span>
<a href="#l18.500"></a><span id="l18.500">   },</span>
<a href="#l18.501"></a><span id="l18.501"> </span>
<a href="#l18.502"></a><span id="l18.502">   _indexingSweepActive: false,</span>
<a href="#l18.503"></a><span id="l18.503">   /**</span>
<a href="#l18.504"></a><span id="l18.504">    * Indicate that an indexing sweep is desired.  We kick-off an indexing</span>
<a href="#l18.505"></a><span id="l18.505">    *  sweep at start-up and whenever we receive an event-based notification</span>
<a href="#l18.506"></a><span id="l18.506">    *  that we either can't process as an event or that we normally handle</span>
<a href="#l18.507"></a><span id="l18.507" class="difflineat">@@ -967,31 +953,31 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.508"></a><span id="l18.508">    *  retrieve the list of servers and folders each time want to find a new</span>
<a href="#l18.509"></a><span id="l18.509">    *  folder to index.  This avoids needing to maintain a perfect model of the</span>
<a href="#l18.510"></a><span id="l18.510">    *  folder hierarchy at all times.  (We may eventually want to do that, but</span>
<a href="#l18.511"></a><span id="l18.511">    *  this is sufficient and safe for now.)  Although our use of dirty flags on</span>
<a href="#l18.512"></a><span id="l18.512">    *  the folders allows us to avoid tracking the 'last folder' we processed,</span>
<a href="#l18.513"></a><span id="l18.513">    *  we do so to avoid getting 'trapped' in a folder with a high rate of</span>
<a href="#l18.514"></a><span id="l18.514">    *  changes.</span>
<a href="#l18.515"></a><span id="l18.515">    */</span>
<a href="#l18.516"></a><span id="l18.516" class="difflineminus">-  _worker_indexingSweep: function* gloda_worker_indexingSweep(aJob) {</span>
<a href="#l18.517"></a><span id="l18.517" class="difflineplus">+  * _worker_indexingSweep(aJob) {</span>
<a href="#l18.518"></a><span id="l18.518">     if (!aJob.mappedFolders) {</span>
<a href="#l18.519"></a><span id="l18.519">       // Walk the folders and make sure all the folders we would want to index</span>
<a href="#l18.520"></a><span id="l18.520">       //  are mapped.  Build up a list of GlodaFolders as we go, so that we can</span>
<a href="#l18.521"></a><span id="l18.521">       //  sort them by their indexing priority.</span>
<a href="#l18.522"></a><span id="l18.522">       let foldersToProcess = aJob.foldersToProcess = [];</span>
<a href="#l18.523"></a><span id="l18.523"> </span>
<a href="#l18.524"></a><span id="l18.524">       let allFolders = MailServices.accounts.allFolders;</span>
<a href="#l18.525"></a><span id="l18.525">       for (let folder of fixIterator(allFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l18.526"></a><span id="l18.526">         if (this.shouldIndexFolder(folder))</span>
<a href="#l18.527"></a><span id="l18.527">           foldersToProcess.push(Gloda.getFolderForFolder(folder));</span>
<a href="#l18.528"></a><span id="l18.528">       }</span>
<a href="#l18.529"></a><span id="l18.529"> </span>
<a href="#l18.530"></a><span id="l18.530">       // sort the folders by priority (descending)</span>
<a href="#l18.531"></a><span id="l18.531" class="difflineminus">-      foldersToProcess.sort(function (a, b) {</span>
<a href="#l18.532"></a><span id="l18.532" class="difflineplus">+      foldersToProcess.sort(function(a, b) {</span>
<a href="#l18.533"></a><span id="l18.533">         return b.indexingPriority - a.indexingPriority;</span>
<a href="#l18.534"></a><span id="l18.534">       });</span>
<a href="#l18.535"></a><span id="l18.535"> </span>
<a href="#l18.536"></a><span id="l18.536">       aJob.mappedFolders = true;</span>
<a href="#l18.537"></a><span id="l18.537">     }</span>
<a href="#l18.538"></a><span id="l18.538"> </span>
<a href="#l18.539"></a><span id="l18.539">     // -- process the folders (in sorted order)</span>
<a href="#l18.540"></a><span id="l18.540">     while (aJob.foldersToProcess.length) {</span>
<a href="#l18.541"></a><span id="l18.541" class="difflineat">@@ -1026,17 +1012,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.542"></a><span id="l18.542">     this._indexingSweepActive = false;</span>
<a href="#l18.543"></a><span id="l18.543">     yield this.kWorkDone;</span>
<a href="#l18.544"></a><span id="l18.544">   },</span>
<a href="#l18.545"></a><span id="l18.545"> </span>
<a href="#l18.546"></a><span id="l18.546">   /**</span>
<a href="#l18.547"></a><span id="l18.547">    * The only state we need to cleanup is that there is no longer an active</span>
<a href="#l18.548"></a><span id="l18.548">    *  indexing sweep.</span>
<a href="#l18.549"></a><span id="l18.549">    */</span>
<a href="#l18.550"></a><span id="l18.550" class="difflineminus">-  _cleanup_indexingSweep: function gloda_canceled_indexingSweep(aJob) {</span>
<a href="#l18.551"></a><span id="l18.551" class="difflineplus">+  _cleanup_indexingSweep(aJob) {</span>
<a href="#l18.552"></a><span id="l18.552">     this._indexingSweepActive = false;</span>
<a href="#l18.553"></a><span id="l18.553">   },</span>
<a href="#l18.554"></a><span id="l18.554"> </span>
<a href="#l18.555"></a><span id="l18.555">   /**</span>
<a href="#l18.556"></a><span id="l18.556">    * The number of headers to look at before yielding with kWorkSync.  This</span>
<a href="#l18.557"></a><span id="l18.557">    *  is for time-slicing purposes so we still yield to the UI periodically.</span>
<a href="#l18.558"></a><span id="l18.558">    */</span>
<a href="#l18.559"></a><span id="l18.559">   HEADER_CHECK_SYNC_BLOCK_SIZE: 25,</span>
<a href="#l18.560"></a><span id="l18.560" class="difflineat">@@ -1105,18 +1091,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.561"></a><span id="l18.561">    *  actually deal with multiple chunks that we don't step on our own feet with</span>
<a href="#l18.562"></a><span id="l18.562">    *  our database updates.  Since compaction of message key K results in a new</span>
<a href="#l18.563"></a><span id="l18.563">    *  message key K' such that K' &lt;= K, we can reliably issue database</span>
<a href="#l18.564"></a><span id="l18.564">    *  updates for all values &lt;= K.  Which means our feet are safe no matter</span>
<a href="#l18.565"></a><span id="l18.565">    *  when we issue the update command.  For maximum cache benefit, we issue</span>
<a href="#l18.566"></a><span id="l18.566">    *  our updates prior to our new query since they should still be maximally</span>
<a href="#l18.567"></a><span id="l18.567">    *  hot at that point.</span>
<a href="#l18.568"></a><span id="l18.568">    */</span>
<a href="#l18.569"></a><span id="l18.569" class="difflineminus">-  _worker_folderCompactionPass:</span>
<a href="#l18.570"></a><span id="l18.570" class="difflineminus">-      function* gloda_worker_folderCompactionPass(aJob, aCallbackHandle) {</span>
<a href="#l18.571"></a><span id="l18.571" class="difflineplus">+  * _worker_folderCompactionPass(aJob, aCallbackHandle) {</span>
<a href="#l18.572"></a><span id="l18.572">     yield this._indexerEnterFolder(aJob.id);</span>
<a href="#l18.573"></a><span id="l18.573"> </span>
<a href="#l18.574"></a><span id="l18.574">     // It's conceivable that with a folder sweep we might end up trying to</span>
<a href="#l18.575"></a><span id="l18.575">     //  compact a folder twice.  Bail early in this case.</span>
<a href="#l18.576"></a><span id="l18.576">     if (!this._indexingGlodaFolder.compacted)</span>
<a href="#l18.577"></a><span id="l18.577">       yield this.kWorkDone;</span>
<a href="#l18.578"></a><span id="l18.578"> </span>
<a href="#l18.579"></a><span id="l18.579">     // this is a forward enumeration (sometimes we reverse enumerate; not here)</span>
<a href="#l18.580"></a><span id="l18.580" class="difflineat">@@ -1134,17 +1119,16 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.581"></a><span id="l18.581">     // (Initialize oldMessageKey because we use it to kickstart our query.)</span>
<a href="#l18.582"></a><span id="l18.582">     let oldGlodaId, oldMessageKey = -1, oldHeaderMessageId;</span>
<a href="#l18.583"></a><span id="l18.583">     // parallel lists of gloda ids and message keys to pass to</span>
<a href="#l18.584"></a><span id="l18.584">     //  GlodaDatastore.updateMessageLocations</span>
<a href="#l18.585"></a><span id="l18.585">     let updateGlodaIds = [];</span>
<a href="#l18.586"></a><span id="l18.586">     let updateMessageKeys = [];</span>
<a href="#l18.587"></a><span id="l18.587">     // list of gloda id's to mark deleted</span>
<a href="#l18.588"></a><span id="l18.588">     let deleteGlodaIds = [];</span>
<a href="#l18.589"></a><span id="l18.589" class="difflineminus">-    let exceptionalMessages = {};</span>
<a href="#l18.590"></a><span id="l18.590"> </span>
<a href="#l18.591"></a><span id="l18.591">     // for GC reasons we need to track the number of headers seen</span>
<a href="#l18.592"></a><span id="l18.592">     let numHeadersSeen = 0;</span>
<a href="#l18.593"></a><span id="l18.593"> </span>
<a href="#l18.594"></a><span id="l18.594">     // We are consuming two lists; our loop structure has to reflect that.</span>
<a href="#l18.595"></a><span id="l18.595">     let headerIter = this._indexingEnumerator[Symbol.iterator]();</span>
<a href="#l18.596"></a><span id="l18.596">     let mayHaveMoreGlodaMessages = true;</span>
<a href="#l18.597"></a><span id="l18.597">     let keepIterHeader = false;</span>
<a href="#l18.598"></a><span id="l18.598" class="difflineat">@@ -1216,71 +1200,64 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.599"></a><span id="l18.599">       }</span>
<a href="#l18.600"></a><span id="l18.600"> </span>
<a href="#l18.601"></a><span id="l18.601">       if (!keepGlodaTuple) {</span>
<a href="#l18.602"></a><span id="l18.602">         if (mayHaveMoreGlodaMessages)</span>
<a href="#l18.603"></a><span id="l18.603">           [oldGlodaId, oldMessageKey, oldHeaderMessageId] =</span>
<a href="#l18.604"></a><span id="l18.604">             glodaIdsMsgKeysHeaderIds.pop();</span>
<a href="#l18.605"></a><span id="l18.605">         else</span>
<a href="#l18.606"></a><span id="l18.606">           oldGlodaId = oldMessageKey = oldHeaderMessageId = null;</span>
<a href="#l18.607"></a><span id="l18.607" class="difflineminus">-      }</span>
<a href="#l18.608"></a><span id="l18.608" class="difflineminus">-      else {</span>
<a href="#l18.609"></a><span id="l18.609" class="difflineplus">+      } else {</span>
<a href="#l18.610"></a><span id="l18.610">         keepGlodaTuple = false;</span>
<a href="#l18.611"></a><span id="l18.611">       }</span>
<a href="#l18.612"></a><span id="l18.612"> </span>
<a href="#l18.613"></a><span id="l18.613">       // -- normal expected case</span>
<a href="#l18.614"></a><span id="l18.614">       if (glodaId == oldGlodaId) {</span>
<a href="#l18.615"></a><span id="l18.615">         // only need to do something if the key is not right</span>
<a href="#l18.616"></a><span id="l18.616">         if (msgHdr.messageKey != oldMessageKey) {</span>
<a href="#l18.617"></a><span id="l18.617">           updateGlodaIds.push(glodaId);</span>
<a href="#l18.618"></a><span id="l18.618">           updateMessageKeys.push(msgHdr.messageKey);</span>
<a href="#l18.619"></a><span id="l18.619">         }</span>
<a href="#l18.620"></a><span id="l18.620" class="difflineminus">-      }</span>
<a href="#l18.621"></a><span id="l18.621" class="difflineminus">-      // -- exceptional cases</span>
<a href="#l18.622"></a><span id="l18.622" class="difflineminus">-      else {</span>
<a href="#l18.623"></a><span id="l18.623" class="difflineplus">+      } else { // -- exceptional cases</span>
<a href="#l18.624"></a><span id="l18.624">         // This should always return a value unless something is very wrong.</span>
<a href="#l18.625"></a><span id="l18.625">         //  We do not want to catch the exception if one happens.</span>
<a href="#l18.626"></a><span id="l18.626">         let idBasedHeader = oldHeaderMessageId ?</span>
<a href="#l18.627"></a><span id="l18.627">           this._indexingDatabase.getMsgHdrForMessageID(oldHeaderMessageId) :</span>
<a href="#l18.628"></a><span id="l18.628">           false;</span>
<a href="#l18.629"></a><span id="l18.629">         // - Case 1b.</span>
<a href="#l18.630"></a><span id="l18.630">         // We want to mark the message as deleted.</span>
<a href="#l18.631"></a><span id="l18.631">         if (idBasedHeader == null) {</span>
<a href="#l18.632"></a><span id="l18.632">           deleteGlodaIds.push(oldGlodaId);</span>
<a href="#l18.633"></a><span id="l18.633" class="difflineminus">-        }</span>
<a href="#l18.634"></a><span id="l18.634" class="difflineminus">-        // - Case 1a</span>
<a href="#l18.635"></a><span id="l18.635" class="difflineminus">-        // The expected case is that the message referenced by the gloda</span>
<a href="#l18.636"></a><span id="l18.636" class="difflineminus">-        //  database precedes the header the enumerator told us about.  This</span>
<a href="#l18.637"></a><span id="l18.637" class="difflineminus">-        //  is expected because if PendingCommitTracker did not mark the</span>
<a href="#l18.638"></a><span id="l18.638" class="difflineminus">-        //  message as indexed/clean then the enumerator would not tell us</span>
<a href="#l18.639"></a><span id="l18.639" class="difflineminus">-        //  about it.</span>
<a href="#l18.640"></a><span id="l18.640" class="difflineminus">-        // Also, if we ran out of headers from the enumerator, this is a dead</span>
<a href="#l18.641"></a><span id="l18.641" class="difflineminus">-        //  giveaway that this is the expected case.</span>
<a href="#l18.642"></a><span id="l18.642" class="difflineminus">-        else if (idBasedHeader &amp;&amp;</span>
<a href="#l18.643"></a><span id="l18.643" class="difflineminus">-             ((msgHdr &amp;&amp;</span>
<a href="#l18.644"></a><span id="l18.644" class="difflineminus">-               idBasedHeader.messageKey &lt; msgHdr.messageKey) ||</span>
<a href="#l18.645"></a><span id="l18.645" class="difflineminus">-              !msgHdr)) {</span>
<a href="#l18.646"></a><span id="l18.646" class="difflineplus">+        } else if (idBasedHeader &amp;&amp;</span>
<a href="#l18.647"></a><span id="l18.647" class="difflineplus">+             ((msgHdr &amp;&amp; idBasedHeader.messageKey &lt; msgHdr.messageKey) || !msgHdr)) {</span>
<a href="#l18.648"></a><span id="l18.648" class="difflineplus">+          // - Case 1a</span>
<a href="#l18.649"></a><span id="l18.649" class="difflineplus">+          // The expected case is that the message referenced by the gloda</span>
<a href="#l18.650"></a><span id="l18.650" class="difflineplus">+          //  database precedes the header the enumerator told us about.  This</span>
<a href="#l18.651"></a><span id="l18.651" class="difflineplus">+          //  is expected because if PendingCommitTracker did not mark the</span>
<a href="#l18.652"></a><span id="l18.652" class="difflineplus">+          //  message as indexed/clean then the enumerator would not tell us</span>
<a href="#l18.653"></a><span id="l18.653" class="difflineplus">+          //  about it.</span>
<a href="#l18.654"></a><span id="l18.654" class="difflineplus">+          // Also, if we ran out of headers from the enumerator, this is a dead</span>
<a href="#l18.655"></a><span id="l18.655" class="difflineplus">+          //  giveaway that this is the expected case.</span>
<a href="#l18.656"></a><span id="l18.656">           // tell the pending commit tracker about the gloda database one</span>
<a href="#l18.657"></a><span id="l18.657">           PendingCommitTracker.track(idBasedHeader, oldGlodaId);</span>
<a href="#l18.658"></a><span id="l18.658">           // and we might need to update the message key too</span>
<a href="#l18.659"></a><span id="l18.659">           if (idBasedHeader.messageKey != oldMessageKey) {</span>
<a href="#l18.660"></a><span id="l18.660">             updateGlodaIds.push(oldGlodaId);</span>
<a href="#l18.661"></a><span id="l18.661">             updateMessageKeys.push(idBasedHeader.messageKey);</span>
<a href="#l18.662"></a><span id="l18.662">           }</span>
<a href="#l18.663"></a><span id="l18.663">           // Take another pass through the loop so that we check the</span>
<a href="#l18.664"></a><span id="l18.664">           //  enumerator header against the next message in the gloda</span>
<a href="#l18.665"></a><span id="l18.665">           //  database.</span>
<a href="#l18.666"></a><span id="l18.666">           keepIterHeader = true;</span>
<a href="#l18.667"></a><span id="l18.667" class="difflineminus">-        }</span>
<a href="#l18.668"></a><span id="l18.668" class="difflineminus">-        // - Case 2</span>
<a href="#l18.669"></a><span id="l18.669" class="difflineminus">-        // Whereas if the message referenced by gloda has a message key</span>
<a href="#l18.670"></a><span id="l18.670" class="difflineminus">-        //  greater than the one returned by the enumerator, then we have a</span>
<a href="#l18.671"></a><span id="l18.671" class="difflineminus">-        //  header claiming to be indexed by gloda that gloda does not</span>
<a href="#l18.672"></a><span id="l18.672" class="difflineminus">-        //  actually know about.  This is exceptional and gets a warning.</span>
<a href="#l18.673"></a><span id="l18.673" class="difflineminus">-        else if (msgHdr) {</span>
<a href="#l18.674"></a><span id="l18.674" class="difflineplus">+        } else if (msgHdr) {</span>
<a href="#l18.675"></a><span id="l18.675" class="difflineplus">+          // - Case 2</span>
<a href="#l18.676"></a><span id="l18.676" class="difflineplus">+          // Whereas if the message referenced by gloda has a message key</span>
<a href="#l18.677"></a><span id="l18.677" class="difflineplus">+          //  greater than the one returned by the enumerator, then we have a</span>
<a href="#l18.678"></a><span id="l18.678" class="difflineplus">+          //  header claiming to be indexed by gloda that gloda does not</span>
<a href="#l18.679"></a><span id="l18.679" class="difflineplus">+          //  actually know about.  This is exceptional and gets a warning.</span>
<a href="#l18.680"></a><span id="l18.680">           this._log.warn(&quot;Observed header that claims to be gloda indexed &quot; +</span>
<a href="#l18.681"></a><span id="l18.681">                          &quot;but that gloda has never heard of during &quot; +</span>
<a href="#l18.682"></a><span id="l18.682">                          &quot;compaction.&quot; +</span>
<a href="#l18.683"></a><span id="l18.683">                          &quot; In folder: &quot; + msgHdr.folder.URI +</span>
<a href="#l18.684"></a><span id="l18.684">                          &quot; sketchy key: &quot; + msgHdr.messageKey +</span>
<a href="#l18.685"></a><span id="l18.685">                          &quot; subject: &quot; + msgHdr.mime2DecodedSubject);</span>
<a href="#l18.686"></a><span id="l18.686">           // Keep this tuple around for the next enumerator provided header</span>
<a href="#l18.687"></a><span id="l18.687">           keepGlodaTuple = true;</span>
<a href="#l18.688"></a><span id="l18.688" class="difflineat">@@ -1299,18 +1276,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.689"></a><span id="l18.689"> </span>
<a href="#l18.690"></a><span id="l18.690">     this._indexerLeaveFolder();</span>
<a href="#l18.691"></a><span id="l18.691">     yield this.kWorkDone;</span>
<a href="#l18.692"></a><span id="l18.692">   },</span>
<a href="#l18.693"></a><span id="l18.693"> </span>
<a href="#l18.694"></a><span id="l18.694">   /**</span>
<a href="#l18.695"></a><span id="l18.695">    * Index the contents of a folder.</span>
<a href="#l18.696"></a><span id="l18.696">    */</span>
<a href="#l18.697"></a><span id="l18.697" class="difflineminus">-  _worker_folderIndex:</span>
<a href="#l18.698"></a><span id="l18.698" class="difflineminus">-      function* gloda_worker_folderIndex(aJob, aCallbackHandle) {</span>
<a href="#l18.699"></a><span id="l18.699" class="difflineplus">+  * _worker_folderIndex(aJob, aCallbackHandle) {</span>
<a href="#l18.700"></a><span id="l18.700">     let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l18.701"></a><span id="l18.701">     yield this._indexerEnterFolder(aJob.id);</span>
<a href="#l18.702"></a><span id="l18.702"> </span>
<a href="#l18.703"></a><span id="l18.703">     if (!this.shouldIndexFolder(this._indexingFolder)) {</span>
<a href="#l18.704"></a><span id="l18.704">       aJob.safelyInvokeCallback(true);</span>
<a href="#l18.705"></a><span id="l18.705">       yield this.kWorkDone;</span>
<a href="#l18.706"></a><span id="l18.706">     }</span>
<a href="#l18.707"></a><span id="l18.707"> </span>
<a href="#l18.708"></a><span id="l18.708" class="difflineat">@@ -1426,17 +1402,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.709"></a><span id="l18.709">             glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l18.710"></a><span id="l18.710">             glodaDirty == this.kMessageClean)</span>
<a href="#l18.711"></a><span id="l18.711">           continue;</span>
<a href="#l18.712"></a><span id="l18.712"> </span>
<a href="#l18.713"></a><span id="l18.713">         if (logDebug)</span>
<a href="#l18.714"></a><span id="l18.714">           this._log.debug(&quot;&gt;&gt;&gt;  calling _indexMessage&quot;);</span>
<a href="#l18.715"></a><span id="l18.715">         yield aCallbackHandle.pushAndGo(</span>
<a href="#l18.716"></a><span id="l18.716">           this._indexMessage(msgHdr, aCallbackHandle),</span>
<a href="#l18.717"></a><span id="l18.717" class="difflineminus">-          {what: &quot;indexMessage&quot;, msgHdr: msgHdr});</span>
<a href="#l18.718"></a><span id="l18.718" class="difflineplus">+          {what: &quot;indexMessage&quot;, msgHdr});</span>
<a href="#l18.719"></a><span id="l18.719">         GlodaIndexer._indexedMessageCount++;</span>
<a href="#l18.720"></a><span id="l18.720">         if (logDebug)</span>
<a href="#l18.721"></a><span id="l18.721">           this._log.debug(&quot;&lt;&lt;&lt;  back from _indexMessage&quot;);</span>
<a href="#l18.722"></a><span id="l18.722">       }</span>
<a href="#l18.723"></a><span id="l18.723">     }</span>
<a href="#l18.724"></a><span id="l18.724"> </span>
<a href="#l18.725"></a><span id="l18.725">     // This will trigger an (async) db update which cannot hit the disk prior to</span>
<a href="#l18.726"></a><span id="l18.726">     //  the actual database records that constitute the clean state.</span>
<a href="#l18.727"></a><span id="l18.727" class="difflineat">@@ -1454,40 +1430,39 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.728"></a><span id="l18.728">     yield this.kWorkDone;</span>
<a href="#l18.729"></a><span id="l18.729">   },</span>
<a href="#l18.730"></a><span id="l18.730"> </span>
<a href="#l18.731"></a><span id="l18.731">   /**</span>
<a href="#l18.732"></a><span id="l18.732">    * Invoked when a &quot;message&quot; job is scheduled so that we can clear</span>
<a href="#l18.733"></a><span id="l18.733">    *  _pendingAddJob if that is the job.  We do this so that work items are not</span>
<a href="#l18.734"></a><span id="l18.734">    *  added to _pendingAddJob while it is being processed.</span>
<a href="#l18.735"></a><span id="l18.735">    */</span>
<a href="#l18.736"></a><span id="l18.736" class="difflineminus">-  _schedule_messageIndex: function(aJob, aCallbackHandle) {</span>
<a href="#l18.737"></a><span id="l18.737" class="difflineplus">+  _schedule_messageIndex(aJob, aCallbackHandle) {</span>
<a href="#l18.738"></a><span id="l18.738">     // we do not want new work items to be added as we are processing, so</span>
<a href="#l18.739"></a><span id="l18.739">     //  clear _pendingAddJob.  A new job will be created as needed.</span>
<a href="#l18.740"></a><span id="l18.740">     if (aJob === this._pendingAddJob)</span>
<a href="#l18.741"></a><span id="l18.741">       this._pendingAddJob = null;</span>
<a href="#l18.742"></a><span id="l18.742">     // update our goal from the items length</span>
<a href="#l18.743"></a><span id="l18.743">     aJob.goal = aJob.items.length;</span>
<a href="#l18.744"></a><span id="l18.744">   },</span>
<a href="#l18.745"></a><span id="l18.745">   /**</span>
<a href="#l18.746"></a><span id="l18.746">    * If the job gets canceled, we need to make sure that we clear out pending</span>
<a href="#l18.747"></a><span id="l18.747">    *  add job or our state will get wonky.</span>
<a href="#l18.748"></a><span id="l18.748">    */</span>
<a href="#l18.749"></a><span id="l18.749" class="difflineminus">-  _canceled_messageIndex: function gloda_index_msg_canceled_messageIndex(aJob) {</span>
<a href="#l18.750"></a><span id="l18.750" class="difflineplus">+  _canceled_messageIndex(aJob) {</span>
<a href="#l18.751"></a><span id="l18.751">     if (aJob === this._pendingAddJob)</span>
<a href="#l18.752"></a><span id="l18.752">       this._pendingAddJob = null;</span>
<a href="#l18.753"></a><span id="l18.753">   },</span>
<a href="#l18.754"></a><span id="l18.754"> </span>
<a href="#l18.755"></a><span id="l18.755"> </span>
<a href="#l18.756"></a><span id="l18.756">   /**</span>
<a href="#l18.757"></a><span id="l18.757">    * Index a specific list of messages that we know to index from</span>
<a href="#l18.758"></a><span id="l18.758">    *  event-notification hints.</span>
<a href="#l18.759"></a><span id="l18.759">    */</span>
<a href="#l18.760"></a><span id="l18.760" class="difflineminus">-  _worker_messageIndex:</span>
<a href="#l18.761"></a><span id="l18.761" class="difflineminus">-      function* gloda_worker_messageIndex(aJob, aCallbackHandle) {</span>
<a href="#l18.762"></a><span id="l18.762" class="difflineplus">+  * _worker_messageIndex(aJob, aCallbackHandle) {</span>
<a href="#l18.763"></a><span id="l18.763">     // if we are already in the correct folder, our &quot;get in the folder&quot; clause</span>
<a href="#l18.764"></a><span id="l18.764">     //  will not execute, so we need to make sure this value is accurate in</span>
<a href="#l18.765"></a><span id="l18.765">     //  that case.  (and we want to avoid multiple checks...)</span>
<a href="#l18.766"></a><span id="l18.766">     for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l18.767"></a><span id="l18.767">       let item = aJob.items[aJob.offset];</span>
<a href="#l18.768"></a><span id="l18.768">       // item is either [folder ID, message key] or</span>
<a href="#l18.769"></a><span id="l18.769">       //                [folder ID, message ID]</span>
<a href="#l18.770"></a><span id="l18.770"> </span>
<a href="#l18.771"></a><span id="l18.771" class="difflineat">@@ -1525,17 +1500,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.772"></a><span id="l18.772">       else</span>
<a href="#l18.773"></a><span id="l18.773">         // same deal as in move processing.</span>
<a href="#l18.774"></a><span id="l18.774">         // TODO fixme to not assume singular message-id's.</span>
<a href="#l18.775"></a><span id="l18.775">         msgHdr = this._indexingDatabase.getMsgHdrForMessageID(item[1]);</span>
<a href="#l18.776"></a><span id="l18.776"> </span>
<a href="#l18.777"></a><span id="l18.777">       if (msgHdr)</span>
<a href="#l18.778"></a><span id="l18.778">         yield aCallbackHandle.pushAndGo(</span>
<a href="#l18.779"></a><span id="l18.779">           this._indexMessage(msgHdr, aCallbackHandle),</span>
<a href="#l18.780"></a><span id="l18.780" class="difflineminus">-          {what: &quot;indexMessage&quot;, msgHdr: msgHdr});</span>
<a href="#l18.781"></a><span id="l18.781" class="difflineplus">+          {what: &quot;indexMessage&quot;, msgHdr});</span>
<a href="#l18.782"></a><span id="l18.782">       else</span>
<a href="#l18.783"></a><span id="l18.783">         yield this.kWorkSync;</span>
<a href="#l18.784"></a><span id="l18.784">     }</span>
<a href="#l18.785"></a><span id="l18.785"> </span>
<a href="#l18.786"></a><span id="l18.786">     // There is no real reason to stay 'in' the folder.  If we are going to get</span>
<a href="#l18.787"></a><span id="l18.787">     //  more events from the folder, its database would have to be open for us</span>
<a href="#l18.788"></a><span id="l18.788">     //  to get the events, so it's not like we're creating an efficiency</span>
<a href="#l18.789"></a><span id="l18.789">     //  problem where we unload a folder just to load it again in 2 seconds.</span>
<a href="#l18.790"></a><span id="l18.790" class="difflineat">@@ -1557,19 +1532,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.791"></a><span id="l18.791">    *     invoke pushAndGo for _indexMessage we put something in so we can</span>
<a href="#l18.792"></a><span id="l18.792">    *     detect when it is on the async stack.</span>
<a href="#l18.793"></a><span id="l18.793">    * @param aException The exception that is necessitating we attempt to</span>
<a href="#l18.794"></a><span id="l18.794">    *     recover.</span>
<a href="#l18.795"></a><span id="l18.795">    *</span>
<a href="#l18.796"></a><span id="l18.796">    * @return 1 if we were able to recover (because we want the call stack</span>
<a href="#l18.797"></a><span id="l18.797">    *     popped down to our worker), false if we can't.</span>
<a href="#l18.798"></a><span id="l18.798">    */</span>
<a href="#l18.799"></a><span id="l18.799" class="difflineminus">-  _recover_indexMessage:</span>
<a href="#l18.800"></a><span id="l18.800" class="difflineminus">-      function gloda_index_recover_indexMessage(aJob, aContextStack,</span>
<a href="#l18.801"></a><span id="l18.801" class="difflineminus">-                                                aException) {</span>
<a href="#l18.802"></a><span id="l18.802" class="difflineplus">+  _recover_indexMessage(aJob, aContextStack, aException) {</span>
<a href="#l18.803"></a><span id="l18.803">     // See if indexMessage is on the stack...</span>
<a href="#l18.804"></a><span id="l18.804">     if (aContextStack.length &gt;= 2 &amp;&amp;</span>
<a href="#l18.805"></a><span id="l18.805">         aContextStack[1] &amp;&amp;</span>
<a href="#l18.806"></a><span id="l18.806">         (&quot;what&quot; in aContextStack[1]) &amp;&amp;</span>
<a href="#l18.807"></a><span id="l18.807">         aContextStack[1].what == &quot;indexMessage&quot;) {</span>
<a href="#l18.808"></a><span id="l18.808">       // it is, so this is probably recoverable.</span>
<a href="#l18.809"></a><span id="l18.809"> </span>
<a href="#l18.810"></a><span id="l18.810">       this._log.debug(</span>
<a href="#l18.811"></a><span id="l18.811" class="difflineat">@@ -1580,18 +1553,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.812"></a><span id="l18.812">       // (In the worst case, the header is no longer valid, which will result in</span>
<a href="#l18.813"></a><span id="l18.813">       //  exceptions.  We need to be prepared for that.)</span>
<a href="#l18.814"></a><span id="l18.814">       try {</span>
<a href="#l18.815"></a><span id="l18.815">         msgHdr.setUint32Property(GLODA_MESSAGE_ID_PROPERTY,</span>
<a href="#l18.816"></a><span id="l18.816">                                  GLODA_BAD_MESSAGE_ID);</span>
<a href="#l18.817"></a><span id="l18.817">         // clear the dirty bit if it has one</span>
<a href="#l18.818"></a><span id="l18.818">         if (msgHdr.getUint32Property(GLODA_DIRTY_PROPERTY))</span>
<a href="#l18.819"></a><span id="l18.819">           msgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l18.820"></a><span id="l18.820" class="difflineminus">-      }</span>
<a href="#l18.821"></a><span id="l18.821" class="difflineminus">-      catch (ex) {</span>
<a href="#l18.822"></a><span id="l18.822" class="difflineplus">+      } catch (ex) {</span>
<a href="#l18.823"></a><span id="l18.823">         // If we are indexing a folder and the message header is no longer</span>
<a href="#l18.824"></a><span id="l18.824">         //  valid, then it's quite likely the whole folder is no longer valid.</span>
<a href="#l18.825"></a><span id="l18.825">         //  But since in the event-driven message indexing case we could have</span>
<a href="#l18.826"></a><span id="l18.826">         //  other valid things to look at, let's try and recover.  The folder</span>
<a href="#l18.827"></a><span id="l18.827">         //  indexing case will come back to us shortly and we will indicate</span>
<a href="#l18.828"></a><span id="l18.828">         //  recovery is not possible at that point.</span>
<a href="#l18.829"></a><span id="l18.829">         // So do nothing here since by popping the indexing of the specific</span>
<a href="#l18.830"></a><span id="l18.830">         //  message out of existence we are recovering.</span>
<a href="#l18.831"></a><span id="l18.831" class="difflineat">@@ -1599,33 +1571,31 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.832"></a><span id="l18.832">       return 1;</span>
<a href="#l18.833"></a><span id="l18.833">     }</span>
<a href="#l18.834"></a><span id="l18.834">     return false;</span>
<a href="#l18.835"></a><span id="l18.835">   },</span>
<a href="#l18.836"></a><span id="l18.836"> </span>
<a href="#l18.837"></a><span id="l18.837">   /**</span>
<a href="#l18.838"></a><span id="l18.838">    * Cleanup after an aborted &quot;folder&quot; or &quot;message&quot; job.</span>
<a href="#l18.839"></a><span id="l18.839">    */</span>
<a href="#l18.840"></a><span id="l18.840" class="difflineminus">-  _cleanup_indexing: function gloda_index_cleanup_indexing(aJob) {</span>
<a href="#l18.841"></a><span id="l18.841" class="difflineplus">+  _cleanup_indexing(aJob) {</span>
<a href="#l18.842"></a><span id="l18.842">     this._indexerLeaveFolder();</span>
<a href="#l18.843"></a><span id="l18.843">     aJob.safelyInvokeCallback(false);</span>
<a href="#l18.844"></a><span id="l18.844">   },</span>
<a href="#l18.845"></a><span id="l18.845"> </span>
<a href="#l18.846"></a><span id="l18.846">   /**</span>
<a href="#l18.847"></a><span id="l18.847">    * Maximum number of deleted messages to process at a time.  Arbitrary; there</span>
<a href="#l18.848"></a><span id="l18.848">    *  are no real known performance constraints at this point.</span>
<a href="#l18.849"></a><span id="l18.849">    */</span>
<a href="#l18.850"></a><span id="l18.850">   DELETED_MESSAGE_BLOCK_SIZE: 32,</span>
<a href="#l18.851"></a><span id="l18.851"> </span>
<a href="#l18.852"></a><span id="l18.852">   /**</span>
<a href="#l18.853"></a><span id="l18.853">    * Process pending deletes...</span>
<a href="#l18.854"></a><span id="l18.854">    */</span>
<a href="#l18.855"></a><span id="l18.855" class="difflineminus">-  _worker_processDeletes: function* gloda_worker_processDeletes(aJob,</span>
<a href="#l18.856"></a><span id="l18.856" class="difflineminus">-      aCallbackHandle) {</span>
<a href="#l18.857"></a><span id="l18.857" class="difflineminus">-</span>
<a href="#l18.858"></a><span id="l18.858" class="difflineplus">+  * _worker_processDeletes(aJob, aCallbackHandle) {</span>
<a href="#l18.859"></a><span id="l18.859">     // Count the number of messages we will eventually process.  People freak</span>
<a href="#l18.860"></a><span id="l18.860">     //  out when the number is constantly increasing because they think gloda</span>
<a href="#l18.861"></a><span id="l18.861">     //  has gone rogue.  (Note: new deletions can still accumulate during</span>
<a href="#l18.862"></a><span id="l18.862">     //  our execution, so we may 'expand' our count a little still.)</span>
<a href="#l18.863"></a><span id="l18.863">     this._datastore.countDeletedMessages(aCallbackHandle.wrappedCallback);</span>
<a href="#l18.864"></a><span id="l18.864">     aJob.goal = yield this.kWorkAsync;</span>
<a href="#l18.865"></a><span id="l18.865">     this._log.debug(&quot;There are currently &quot; + aJob.goal + &quot; messages awaiting&quot; +</span>
<a href="#l18.866"></a><span id="l18.866">                     &quot; deletion processing.&quot;);</span>
<a href="#l18.867"></a><span id="l18.867" class="difflineat">@@ -1658,43 +1628,43 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.868"></a><span id="l18.868">       deletedCollection = query.getCollection(aCallbackHandle);</span>
<a href="#l18.869"></a><span id="l18.869">       yield this.kWorkAsync;</span>
<a href="#l18.870"></a><span id="l18.870">     }</span>
<a href="#l18.871"></a><span id="l18.871">     this.pendingDeletions = false;</span>
<a href="#l18.872"></a><span id="l18.872"> </span>
<a href="#l18.873"></a><span id="l18.873">     yield this.kWorkDone;</span>
<a href="#l18.874"></a><span id="l18.874">   },</span>
<a href="#l18.875"></a><span id="l18.875"> </span>
<a href="#l18.876"></a><span id="l18.876" class="difflineminus">-  _worker_fixMissingContacts: function*(aJob, aCallbackHandle) {</span>
<a href="#l18.877"></a><span id="l18.877" class="difflineminus">-    let identityContactInfos = [], fixedContacts = {};</span>
<a href="#l18.878"></a><span id="l18.878" class="difflineplus">+  * _worker_fixMissingContacts(aJob, aCallbackHandle) {</span>
<a href="#l18.879"></a><span id="l18.879" class="difflineplus">+    let identityContactInfos = [];</span>
<a href="#l18.880"></a><span id="l18.880"> </span>
<a href="#l18.881"></a><span id="l18.881">     // -- asynchronously get a list of all identities without contacts</span>
<a href="#l18.882"></a><span id="l18.882">     // The upper bound on the number of messed up contacts is the number of</span>
<a href="#l18.883"></a><span id="l18.883">     //  contacts in the user's address book.  This should be small enough</span>
<a href="#l18.884"></a><span id="l18.884">     //  (and the data size small enough) that this won't explode thunderbird.</span>
<a href="#l18.885"></a><span id="l18.885">     let queryStmt = GlodaDatastore._createAsyncStatement(</span>
<a href="#l18.886"></a><span id="l18.886">       &quot;SELECT identities.id, identities.contactID, identities.value &quot; +</span>
<a href="#l18.887"></a><span id="l18.887">         &quot;FROM identities &quot; +</span>
<a href="#l18.888"></a><span id="l18.888">         &quot;LEFT JOIN contacts ON identities.contactID = contacts.id &quot; +</span>
<a href="#l18.889"></a><span id="l18.889">         &quot;WHERE identities.kind = 'email' AND contacts.id IS NULL&quot;,</span>
<a href="#l18.890"></a><span id="l18.890">       true);</span>
<a href="#l18.891"></a><span id="l18.891">     queryStmt.executeAsync({</span>
<a href="#l18.892"></a><span id="l18.892" class="difflineminus">-      handleResult: function(aResultSet) {</span>
<a href="#l18.893"></a><span id="l18.893" class="difflineplus">+      handleResult(aResultSet) {</span>
<a href="#l18.894"></a><span id="l18.894">         let row;</span>
<a href="#l18.895"></a><span id="l18.895">         while ((row = aResultSet.getNextRow())) {</span>
<a href="#l18.896"></a><span id="l18.896">           identityContactInfos.push({</span>
<a href="#l18.897"></a><span id="l18.897">             identityId: row.getInt64(0),</span>
<a href="#l18.898"></a><span id="l18.898">             contactId: row.getInt64(1),</span>
<a href="#l18.899"></a><span id="l18.899" class="difflineminus">-            email: row.getString(2)</span>
<a href="#l18.900"></a><span id="l18.900" class="difflineplus">+            email: row.getString(2),</span>
<a href="#l18.901"></a><span id="l18.901">           });</span>
<a href="#l18.902"></a><span id="l18.902">         }</span>
<a href="#l18.903"></a><span id="l18.903">       },</span>
<a href="#l18.904"></a><span id="l18.904" class="difflineminus">-      handleError: function(aError) {</span>
<a href="#l18.905"></a><span id="l18.905" class="difflineplus">+      handleError(aError) {</span>
<a href="#l18.906"></a><span id="l18.906">       },</span>
<a href="#l18.907"></a><span id="l18.907" class="difflineminus">-      handleCompletion: function(aReason) {</span>
<a href="#l18.908"></a><span id="l18.908" class="difflineplus">+      handleCompletion(aReason) {</span>
<a href="#l18.909"></a><span id="l18.909">         GlodaDatastore._asyncCompleted();</span>
<a href="#l18.910"></a><span id="l18.910">         aCallbackHandle.wrappedCallback();</span>
<a href="#l18.911"></a><span id="l18.911">       },</span>
<a href="#l18.912"></a><span id="l18.912">     });</span>
<a href="#l18.913"></a><span id="l18.913">     queryStmt.finalize();</span>
<a href="#l18.914"></a><span id="l18.914">     GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l18.915"></a><span id="l18.915">     yield this.kWorkAsync;</span>
<a href="#l18.916"></a><span id="l18.916"> </span>
<a href="#l18.917"></a><span id="l18.917" class="difflineat">@@ -1758,17 +1728,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.918"></a><span id="l18.918">   /**</span>
<a href="#l18.919"></a><span id="l18.919">    * Determine whether a folder is suitable for indexing.</span>
<a href="#l18.920"></a><span id="l18.920">    *</span>
<a href="#l18.921"></a><span id="l18.921">    * @param aMsgFolder An nsIMsgFolder you want to see if we should index.</span>
<a href="#l18.922"></a><span id="l18.922">    *</span>
<a href="#l18.923"></a><span id="l18.923">    * @returns true if we want to index messages in this type of folder, false if</span>
<a href="#l18.924"></a><span id="l18.924">    *     we do not.</span>
<a href="#l18.925"></a><span id="l18.925">    */</span>
<a href="#l18.926"></a><span id="l18.926" class="difflineminus">-  shouldIndexFolder: function(aMsgFolder) {</span>
<a href="#l18.927"></a><span id="l18.927" class="difflineplus">+  shouldIndexFolder(aMsgFolder) {</span>
<a href="#l18.928"></a><span id="l18.928">     let folderFlags = aMsgFolder.flags;</span>
<a href="#l18.929"></a><span id="l18.929">     // Completely ignore non-mail and virtual folders.  They should never even</span>
<a href="#l18.930"></a><span id="l18.930">     //  get to be GlodaFolder instances.</span>
<a href="#l18.931"></a><span id="l18.931">     if (!(folderFlags &amp; Ci.nsMsgFolderFlags.Mail) ||</span>
<a href="#l18.932"></a><span id="l18.932">         (folderFlags &amp; Ci.nsMsgFolderFlags.Virtual))</span>
<a href="#l18.933"></a><span id="l18.933">       return false;</span>
<a href="#l18.934"></a><span id="l18.934"> </span>
<a href="#l18.935"></a><span id="l18.935">     // Some folders do not really exist; we can detect this by getStringProperty</span>
<a href="#l18.936"></a><span id="l18.936" class="difflineat">@@ -1794,18 +1764,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.937"></a><span id="l18.937">    * and, for backup purposes, to the nsIMsgFolder via string property as well.</span>
<a href="#l18.938"></a><span id="l18.938">    *</span>
<a href="#l18.939"></a><span id="l18.939">    * Setting this priority may cause the indexer to either reindex this folder,</span>
<a href="#l18.940"></a><span id="l18.940">    * or remove this folder from the existing index.</span>
<a href="#l18.941"></a><span id="l18.941">    *</span>
<a href="#l18.942"></a><span id="l18.942">    * @param {nsIMsgFolder} aFolder</span>
<a href="#l18.943"></a><span id="l18.943">    * @param {Number} aPriority (one of the priority constants from GlodaFolder)</span>
<a href="#l18.944"></a><span id="l18.944">    */</span>
<a href="#l18.945"></a><span id="l18.945" class="difflineminus">-  setFolderIndexingPriority: function glodaSetFolderIndexingPriority(aFolder, aPriority) {</span>
<a href="#l18.946"></a><span id="l18.946" class="difflineminus">-</span>
<a href="#l18.947"></a><span id="l18.947" class="difflineplus">+  setFolderIndexingPriority(aFolder, aPriority) {</span>
<a href="#l18.948"></a><span id="l18.948">     let glodaFolder = GlodaDatastore._mapFolder(aFolder);</span>
<a href="#l18.949"></a><span id="l18.949"> </span>
<a href="#l18.950"></a><span id="l18.950">     // if there's been no change, we're done</span>
<a href="#l18.951"></a><span id="l18.951">     if (aPriority == glodaFolder.indexingPriority) {</span>
<a href="#l18.952"></a><span id="l18.952">       return;</span>
<a href="#l18.953"></a><span id="l18.953">     }</span>
<a href="#l18.954"></a><span id="l18.954"> </span>
<a href="#l18.955"></a><span id="l18.955">     // save off the old priority, and set the new one</span>
<a href="#l18.956"></a><span id="l18.956" class="difflineat">@@ -1813,102 +1782,97 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.957"></a><span id="l18.957">     glodaFolder._indexingPriority = aPriority;</span>
<a href="#l18.958"></a><span id="l18.958"> </span>
<a href="#l18.959"></a><span id="l18.959">     // persist the new priority</span>
<a href="#l18.960"></a><span id="l18.960">     GlodaDatastore.updateFolderIndexingPriority(glodaFolder);</span>
<a href="#l18.961"></a><span id="l18.961">     aFolder.setStringProperty(&quot;indexingPriority&quot;, Number(aPriority).toString());</span>
<a href="#l18.962"></a><span id="l18.962"> </span>
<a href="#l18.963"></a><span id="l18.963">     // if we've been told never to index this folder...</span>
<a href="#l18.964"></a><span id="l18.964">     if (aPriority == glodaFolder.kIndexingNeverPriority) {</span>
<a href="#l18.965"></a><span id="l18.965" class="difflineminus">-</span>
<a href="#l18.966"></a><span id="l18.966">       // stop doing so</span>
<a href="#l18.967"></a><span id="l18.967">       if (this._indexingFolder == aFolder)</span>
<a href="#l18.968"></a><span id="l18.968">           GlodaIndexer.killActiveJob();</span>
<a href="#l18.969"></a><span id="l18.969"> </span>
<a href="#l18.970"></a><span id="l18.970">       // mark all existing messages as deleted</span>
<a href="#l18.971"></a><span id="l18.971">       GlodaDatastore.markMessagesDeletedByFolderID(glodaFolder.id);</span>
<a href="#l18.972"></a><span id="l18.972"> </span>
<a href="#l18.973"></a><span id="l18.973">       // re-index</span>
<a href="#l18.974"></a><span id="l18.974">       GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l18.975"></a><span id="l18.975" class="difflineminus">-</span>
<a href="#l18.976"></a><span id="l18.976">     } else if (previousPrio == glodaFolder.kIndexingNeverPriority) {</span>
<a href="#l18.977"></a><span id="l18.977" class="difflineminus">-</span>
<a href="#l18.978"></a><span id="l18.978">       // there's no existing index, but the user now wants one</span>
<a href="#l18.979"></a><span id="l18.979">       glodaFolder._dirtyStatus = glodaFolder.kFolderFilthy;</span>
<a href="#l18.980"></a><span id="l18.980" class="difflineminus">-      GlodaDatastore.updateFolderDirtyStatus(glodaFolder)</span>
<a href="#l18.981"></a><span id="l18.981" class="difflineplus">+      GlodaDatastore.updateFolderDirtyStatus(glodaFolder);</span>
<a href="#l18.982"></a><span id="l18.982">       GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l18.983"></a><span id="l18.983">     }</span>
<a href="#l18.984"></a><span id="l18.984">   },</span>
<a href="#l18.985"></a><span id="l18.985"> </span>
<a href="#l18.986"></a><span id="l18.986">   /**</span>
<a href="#l18.987"></a><span id="l18.987">    * Resets the indexing priority on the given folder to whatever the default</span>
<a href="#l18.988"></a><span id="l18.988">    * is for folders of that type.</span>
<a href="#l18.989"></a><span id="l18.989">    *</span>
<a href="#l18.990"></a><span id="l18.990">    * @note Calls setFolderIndexingPriority under the hood, so has identical</span>
<a href="#l18.991"></a><span id="l18.991">    *       potential reindexing side-effects</span>
<a href="#l18.992"></a><span id="l18.992">    *</span>
<a href="#l18.993"></a><span id="l18.993">    * @param {nsIMsgFolder} aFolder</span>
<a href="#l18.994"></a><span id="l18.994">    * @param {boolean} aAllowSpecialFolderIndexing</span>
<a href="#l18.995"></a><span id="l18.995">    */</span>
<a href="#l18.996"></a><span id="l18.996" class="difflineminus">-  resetFolderIndexingPriority: function glodaResetFolderIndexingPriority(aFolder, aAllowSpecialFolderIndexing) {</span>
<a href="#l18.997"></a><span id="l18.997" class="difflineplus">+  resetFolderIndexingPriority(aFolder, aAllowSpecialFolderIndexing) {</span>
<a href="#l18.998"></a><span id="l18.998">     this.setFolderIndexingPriority(aFolder,</span>
<a href="#l18.999"></a><span id="l18.999">       GlodaDatastore.getDefaultIndexingPriority(aFolder,</span>
<a href="#l18.1000"></a><span id="l18.1000">                                                 aAllowSpecialFolderIndexing));</span>
<a href="#l18.1001"></a><span id="l18.1001">   },</span>
<a href="#l18.1002"></a><span id="l18.1002"> </span>
<a href="#l18.1003"></a><span id="l18.1003">   /**</span>
<a href="#l18.1004"></a><span id="l18.1004">    * Queue all of the folders of all of the accounts of the current profile</span>
<a href="#l18.1005"></a><span id="l18.1005">    *  for indexing.  We traverse all folders and queue them immediately to try</span>
<a href="#l18.1006"></a><span id="l18.1006">    *  and have an accurate estimate of the number of folders that need to be</span>
<a href="#l18.1007"></a><span id="l18.1007">    *  indexed.  (We previously queued accounts rather than immediately</span>
<a href="#l18.1008"></a><span id="l18.1008">    *  walking their list of folders.)</span>
<a href="#l18.1009"></a><span id="l18.1009">    */</span>
<a href="#l18.1010"></a><span id="l18.1010" class="difflineminus">-  indexEverything: function glodaIndexEverything() {</span>
<a href="#l18.1011"></a><span id="l18.1011" class="difflineplus">+  indexEverything() {</span>
<a href="#l18.1012"></a><span id="l18.1012">     this._log.info(&quot;Queueing all accounts for indexing.&quot;);</span>
<a href="#l18.1013"></a><span id="l18.1013"> </span>
<a href="#l18.1014"></a><span id="l18.1014">     GlodaDatastore._beginTransaction();</span>
<a href="#l18.1015"></a><span id="l18.1015">     for (let account of fixIterator(MailServices.accounts.accounts,</span>
<a href="#l18.1016"></a><span id="l18.1016">                                     Ci.nsIMsgAccount)) {</span>
<a href="#l18.1017"></a><span id="l18.1017">       this.indexAccount(account);</span>
<a href="#l18.1018"></a><span id="l18.1018">     }</span>
<a href="#l18.1019"></a><span id="l18.1019">     GlodaDatastore._commitTransaction();</span>
<a href="#l18.1020"></a><span id="l18.1020">   },</span>
<a href="#l18.1021"></a><span id="l18.1021"> </span>
<a href="#l18.1022"></a><span id="l18.1022">   /**</span>
<a href="#l18.1023"></a><span id="l18.1023">    * Queue all of the folders belonging to an account for indexing.</span>
<a href="#l18.1024"></a><span id="l18.1024">    */</span>
<a href="#l18.1025"></a><span id="l18.1025" class="difflineminus">-  indexAccount: function glodaIndexAccount(aAccount) {</span>
<a href="#l18.1026"></a><span id="l18.1026" class="difflineplus">+  indexAccount(aAccount) {</span>
<a href="#l18.1027"></a><span id="l18.1027">     let rootFolder = aAccount.incomingServer.rootFolder;</span>
<a href="#l18.1028"></a><span id="l18.1028">     if (rootFolder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l18.1029"></a><span id="l18.1029">       this._log.info(&quot;Queueing account folders for indexing: &quot; + aAccount.key);</span>
<a href="#l18.1030"></a><span id="l18.1030"> </span>
<a href="#l18.1031"></a><span id="l18.1031">       let allFolders = rootFolder.descendants;</span>
<a href="#l18.1032"></a><span id="l18.1032" class="difflineminus">-      let folderJobs = [];</span>
<a href="#l18.1033"></a><span id="l18.1033">       for (let folder of fixIterator(allFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l18.1034"></a><span id="l18.1034">         if (this.shouldIndexFolder(folder))</span>
<a href="#l18.1035"></a><span id="l18.1035">           GlodaIndexer.indexJob(</span>
<a href="#l18.1036"></a><span id="l18.1036">             new IndexingJob(&quot;folder&quot;, GlodaDatastore._mapFolder(folder).id));</span>
<a href="#l18.1037"></a><span id="l18.1037">       }</span>
<a href="#l18.1038"></a><span id="l18.1038" class="difflineminus">-    }</span>
<a href="#l18.1039"></a><span id="l18.1039" class="difflineminus">-    else {</span>
<a href="#l18.1040"></a><span id="l18.1040" class="difflineplus">+    } else {</span>
<a href="#l18.1041"></a><span id="l18.1041">       this._log.info(&quot;Skipping Account, root folder not nsIMsgFolder&quot;);</span>
<a href="#l18.1042"></a><span id="l18.1042">     }</span>
<a href="#l18.1043"></a><span id="l18.1043">   },</span>
<a href="#l18.1044"></a><span id="l18.1044"> </span>
<a href="#l18.1045"></a><span id="l18.1045">   /**</span>
<a href="#l18.1046"></a><span id="l18.1046">    * Queue a single folder for indexing given an nsIMsgFolder.</span>
<a href="#l18.1047"></a><span id="l18.1047">    *</span>
<a href="#l18.1048"></a><span id="l18.1048">    * @param [aOptions.callback] A callback to invoke when the folder finishes</span>
<a href="#l18.1049"></a><span id="l18.1049">    *     indexing.  First argument is true if the task ran to completion</span>
<a href="#l18.1050"></a><span id="l18.1050">    *     successfully, false if we had to abort for some reason.</span>
<a href="#l18.1051"></a><span id="l18.1051">    * @param [aOptions.force=false] Should we force the indexing of all messages</span>
<a href="#l18.1052"></a><span id="l18.1052">    *     in the folder (true) or just index what hasn't been indexed (false).</span>
<a href="#l18.1053"></a><span id="l18.1053">    * @return true if we are going to index the folder, false if not.</span>
<a href="#l18.1054"></a><span id="l18.1054">    */</span>
<a href="#l18.1055"></a><span id="l18.1055" class="difflineminus">-  indexFolder: function glodaIndexFolder(aMsgFolder, aOptions) {</span>
<a href="#l18.1056"></a><span id="l18.1056" class="difflineplus">+  indexFolder(aMsgFolder, aOptions) {</span>
<a href="#l18.1057"></a><span id="l18.1057">     if (!this.shouldIndexFolder(aMsgFolder))</span>
<a href="#l18.1058"></a><span id="l18.1058">       return false;</span>
<a href="#l18.1059"></a><span id="l18.1059">     let glodaFolder = GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l18.1060"></a><span id="l18.1060">     // stay out of compacting/compacted folders</span>
<a href="#l18.1061"></a><span id="l18.1061">     if (glodaFolder.compacting || glodaFolder.compacted)</span>
<a href="#l18.1062"></a><span id="l18.1062">       return false;</span>
<a href="#l18.1063"></a><span id="l18.1063"> </span>
<a href="#l18.1064"></a><span id="l18.1064">     this._log.info(&quot;Queue-ing folder for indexing: &quot; +</span>
<a href="#l18.1065"></a><span id="l18.1065" class="difflineat">@@ -1924,34 +1888,34 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1066"></a><span id="l18.1066">     return true;</span>
<a href="#l18.1067"></a><span id="l18.1067">   },</span>
<a href="#l18.1068"></a><span id="l18.1068"> </span>
<a href="#l18.1069"></a><span id="l18.1069">   /**</span>
<a href="#l18.1070"></a><span id="l18.1070">    * Queue a list of messages for indexing.</span>
<a href="#l18.1071"></a><span id="l18.1071">    *</span>
<a href="#l18.1072"></a><span id="l18.1072">    * @param aFoldersAndMessages List of [nsIMsgFolder, message key] tuples.</span>
<a href="#l18.1073"></a><span id="l18.1073">    */</span>
<a href="#l18.1074"></a><span id="l18.1074" class="difflineminus">-  indexMessages: function gloda_index_indexMessages(aFoldersAndMessages) {</span>
<a href="#l18.1075"></a><span id="l18.1075" class="difflineplus">+  indexMessages(aFoldersAndMessages) {</span>
<a href="#l18.1076"></a><span id="l18.1076">     let job = new IndexingJob(&quot;message&quot;, null);</span>
<a href="#l18.1077"></a><span id="l18.1077">     job.items = aFoldersAndMessages.</span>
<a href="#l18.1078"></a><span id="l18.1078">       map(fm =&gt; [GlodaDatastore._mapFolder(fm[0]).id, fm[1]]);</span>
<a href="#l18.1079"></a><span id="l18.1079">     GlodaIndexer.indexJob(job);</span>
<a href="#l18.1080"></a><span id="l18.1080">   },</span>
<a href="#l18.1081"></a><span id="l18.1081"> </span>
<a href="#l18.1082"></a><span id="l18.1082">   /**</span>
<a href="#l18.1083"></a><span id="l18.1083">    * Mark all known folders as dirty so that the next indexing sweep goes</span>
<a href="#l18.1084"></a><span id="l18.1084">    *  into all folders and checks their contents to see if they need to be</span>
<a href="#l18.1085"></a><span id="l18.1085">    *  indexed.</span>
<a href="#l18.1086"></a><span id="l18.1086">    *</span>
<a href="#l18.1087"></a><span id="l18.1087">    * This is being added for the migration case where we want to try and reindex</span>
<a href="#l18.1088"></a><span id="l18.1088">    *  all of the messages that had been marked with GLODA_BAD_MESSAGE_ID but</span>
<a href="#l18.1089"></a><span id="l18.1089">    *  which is now GLODA_OLD_BAD_MESSAGE_ID and so we should attempt to reindex</span>
<a href="#l18.1090"></a><span id="l18.1090">    *  them.</span>
<a href="#l18.1091"></a><span id="l18.1091">    */</span>
<a href="#l18.1092"></a><span id="l18.1092" class="difflineminus">-  dirtyAllKnownFolders: function gloda_index_msg_dirtyAllKnownFolders() {</span>
<a href="#l18.1093"></a><span id="l18.1093" class="difflineplus">+  dirtyAllKnownFolders() {</span>
<a href="#l18.1094"></a><span id="l18.1094">     // Just iterate over the datastore's folder map and tell each folder to</span>
<a href="#l18.1095"></a><span id="l18.1095">     //  be dirty if its priority is not disabled.</span>
<a href="#l18.1096"></a><span id="l18.1096">     for (let folderID in GlodaDatastore._folderByID) {</span>
<a href="#l18.1097"></a><span id="l18.1097">       let glodaFolder = GlodaDatastore._folderByID[folderID];</span>
<a href="#l18.1098"></a><span id="l18.1098">       if (glodaFolder.indexingPriority !== glodaFolder.kIndexingNeverPriority)</span>
<a href="#l18.1099"></a><span id="l18.1099">         glodaFolder._ensureFolderDirty();</span>
<a href="#l18.1100"></a><span id="l18.1100">     }</span>
<a href="#l18.1101"></a><span id="l18.1101">   },</span>
<a href="#l18.1102"></a><span id="l18.1102" class="difflineat">@@ -1963,17 +1927,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1103"></a><span id="l18.1103">    * This means the message must:</span>
<a href="#l18.1104"></a><span id="l18.1104">    * - Be in a folder eligible for gloda indexing. (Not News, etc.)</span>
<a href="#l18.1105"></a><span id="l18.1105">    * - Be in a non-filthy folder.</span>
<a href="#l18.1106"></a><span id="l18.1106">    * - Be gloda-indexed and non-filthy.</span>
<a href="#l18.1107"></a><span id="l18.1107">    *</span>
<a href="#l18.1108"></a><span id="l18.1108">    * @param aMsgHdr A message header.</span>
<a href="#l18.1109"></a><span id="l18.1109">    * @returns true if the message is likely to have been indexed.</span>
<a href="#l18.1110"></a><span id="l18.1110">    */</span>
<a href="#l18.1111"></a><span id="l18.1111" class="difflineminus">-  isMessageIndexed: function gloda_index_isMessageIndexed(aMsgHdr) {</span>
<a href="#l18.1112"></a><span id="l18.1112" class="difflineplus">+  isMessageIndexed(aMsgHdr) {</span>
<a href="#l18.1113"></a><span id="l18.1113">     // If it's in a folder that we flat out do not index, say no.</span>
<a href="#l18.1114"></a><span id="l18.1114">     if (!this.shouldIndexFolder(aMsgHdr.folder))</span>
<a href="#l18.1115"></a><span id="l18.1115">       return false;</span>
<a href="#l18.1116"></a><span id="l18.1116">     let glodaFolder = GlodaDatastore._mapFolder(aMsgHdr.folder);</span>
<a href="#l18.1117"></a><span id="l18.1117">     let [glodaId, glodaDirty] = PendingCommitTracker.getGlodaState(aMsgHdr);</span>
<a href="#l18.1118"></a><span id="l18.1118">     return glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l18.1119"></a><span id="l18.1119">            glodaDirty != GlodaMsgIndexer.kMessageFilthy &amp;&amp;</span>
<a href="#l18.1120"></a><span id="l18.1120">            glodaFolder &amp;&amp;</span>
<a href="#l18.1121"></a><span id="l18.1121" class="difflineat">@@ -2022,18 +1986,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1122"></a><span id="l18.1122">    *     for user action to do something that dirties the message between the</span>
<a href="#l18.1123"></a><span id="l18.1123">    *     time we get the msgKeyChanged notification and when we receive the</span>
<a href="#l18.1124"></a><span id="l18.1124">    *     msgsClassified notification, we want to make sure we don't get</span>
<a href="#l18.1125"></a><span id="l18.1125">    *     confused.  (Although since we remove the message from our ignore-set</span>
<a href="#l18.1126"></a><span id="l18.1126">    *     after the first notification, we would likely just mistakenly treat</span>
<a href="#l18.1127"></a><span id="l18.1127">    *     the msgsClassified notification as something dirtying, so it would</span>
<a href="#l18.1128"></a><span id="l18.1128">    *     still work out...)</span>
<a href="#l18.1129"></a><span id="l18.1129">    */</span>
<a href="#l18.1130"></a><span id="l18.1130" class="difflineminus">-  _reindexChangedMessages: function gloda_indexer_reindexChangedMessage(</span>
<a href="#l18.1131"></a><span id="l18.1131" class="difflineminus">-                                      aMsgHdrs, aDirtyingEvent) {</span>
<a href="#l18.1132"></a><span id="l18.1132" class="difflineplus">+  _reindexChangedMessages(aMsgHdrs, aDirtyingEvent) {</span>
<a href="#l18.1133"></a><span id="l18.1133">     let glodaIdsNeedingDeletion = null;</span>
<a href="#l18.1134"></a><span id="l18.1134">     let messageKeyChangedIds = null, messageKeyChangedNewKeys = null;</span>
<a href="#l18.1135"></a><span id="l18.1135">     for (let msgHdr of fixIterator(aMsgHdrs, Ci.nsIMsgDBHdr)) {</span>
<a href="#l18.1136"></a><span id="l18.1136">       // -- Index this folder?</span>
<a href="#l18.1137"></a><span id="l18.1137">       let msgFolder = msgHdr.folder;</span>
<a href="#l18.1138"></a><span id="l18.1138">       if (!this.shouldIndexFolder(msgFolder)) {</span>
<a href="#l18.1139"></a><span id="l18.1139">         continue;</span>
<a href="#l18.1140"></a><span id="l18.1140">       }</span>
<a href="#l18.1141"></a><span id="l18.1141" class="difflineat">@@ -2112,37 +2075,34 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1142"></a><span id="l18.1142">         //  indexing sweep takes care of things if we don't process this in</span>
<a href="#l18.1143"></a><span id="l18.1143">         //  an event-driven fashion.  If the message has no gloda-id or does</span>
<a href="#l18.1144"></a><span id="l18.1144">         //  and it's already dirty or filthy, it is already marked for</span>
<a href="#l18.1145"></a><span id="l18.1145">         //  indexing.)</span>
<a href="#l18.1146"></a><span id="l18.1146">         if (glodaDirty == this.kMessageClean)</span>
<a href="#l18.1147"></a><span id="l18.1147">           msgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, this.kMessageDirty);</span>
<a href="#l18.1148"></a><span id="l18.1148">         // if the message is pending clean, this change invalidates that.</span>
<a href="#l18.1149"></a><span id="l18.1149">         PendingCommitTracker.noteDirtyHeader(msgHdr);</span>
<a href="#l18.1150"></a><span id="l18.1150" class="difflineminus">-      }</span>
<a href="#l18.1151"></a><span id="l18.1151" class="difflineminus">-      // If it's not indexed but is spam, ignore it.</span>
<a href="#l18.1152"></a><span id="l18.1152" class="difflineminus">-      else if (isSpam) {</span>
<a href="#l18.1153"></a><span id="l18.1153" class="difflineplus">+      } else if (isSpam) { // If it's not indexed but is spam, ignore it.</span>
<a href="#l18.1154"></a><span id="l18.1154">         continue;</span>
<a href="#l18.1155"></a><span id="l18.1155">       }</span>
<a href="#l18.1156"></a><span id="l18.1156">       // (we want to index the message if we are here)</span>
<a href="#l18.1157"></a><span id="l18.1157"> </span>
<a href="#l18.1158"></a><span id="l18.1158">       // mark the folder dirty too, so we know to look inside</span>
<a href="#l18.1159"></a><span id="l18.1159">       glodaFolder._ensureFolderDirty();</span>
<a href="#l18.1160"></a><span id="l18.1160"> </span>
<a href="#l18.1161"></a><span id="l18.1161">       if (this._pendingAddJob == null) {</span>
<a href="#l18.1162"></a><span id="l18.1162">         this._pendingAddJob = new IndexingJob(&quot;message&quot;, null);</span>
<a href="#l18.1163"></a><span id="l18.1163">         GlodaIndexer.indexJob(this._pendingAddJob);</span>
<a href="#l18.1164"></a><span id="l18.1164">       }</span>
<a href="#l18.1165"></a><span id="l18.1165">       // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l18.1166"></a><span id="l18.1166">       if (this._pendingAddJob.items.length &lt;</span>
<a href="#l18.1167"></a><span id="l18.1167">           this._indexMaxEventQueueMessages) {</span>
<a href="#l18.1168"></a><span id="l18.1168">         this._pendingAddJob.items.push(</span>
<a href="#l18.1169"></a><span id="l18.1169">           [GlodaDatastore._mapFolder(msgFolder).id, msgHdr.messageKey]);</span>
<a href="#l18.1170"></a><span id="l18.1170" class="difflineminus">-      }</span>
<a href="#l18.1171"></a><span id="l18.1171" class="difflineminus">-      else {</span>
<a href="#l18.1172"></a><span id="l18.1172" class="difflineplus">+      } else {</span>
<a href="#l18.1173"></a><span id="l18.1173">         this.indexingSweepNeeded = true;</span>
<a href="#l18.1174"></a><span id="l18.1174">       }</span>
<a href="#l18.1175"></a><span id="l18.1175">     }</span>
<a href="#l18.1176"></a><span id="l18.1176"> </span>
<a href="#l18.1177"></a><span id="l18.1177">     // Process any message key changes (from earlier msgKeyChanged events)</span>
<a href="#l18.1178"></a><span id="l18.1178">     if (messageKeyChangedIds != null)</span>
<a href="#l18.1179"></a><span id="l18.1179">       GlodaDatastore.updateMessageKeys(messageKeyChangedIds,</span>
<a href="#l18.1180"></a><span id="l18.1180">                                        messageKeyChangedNewKeys);</span>
<a href="#l18.1181"></a><span id="l18.1181" class="difflineat">@@ -2169,39 +2129,37 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1182"></a><span id="l18.1182">   _msgFolderListener: {</span>
<a href="#l18.1183"></a><span id="l18.1183">     indexer: null,</span>
<a href="#l18.1184"></a><span id="l18.1184"> </span>
<a href="#l18.1185"></a><span id="l18.1185">     /**</span>
<a href="#l18.1186"></a><span id="l18.1186">      * We no longer use the msgAdded notification, instead opting to wait until</span>
<a href="#l18.1187"></a><span id="l18.1187">      *  junk/trait classification has run (or decided not to run) and all</span>
<a href="#l18.1188"></a><span id="l18.1188">      *  filters have run.  The msgsClassified notification provides that for us.</span>
<a href="#l18.1189"></a><span id="l18.1189">      */</span>
<a href="#l18.1190"></a><span id="l18.1190" class="difflineminus">-    msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l18.1191"></a><span id="l18.1191" class="difflineplus">+    msgAdded(aMsgHdr) {</span>
<a href="#l18.1192"></a><span id="l18.1192">       // we are never called! we do not enable this bit!</span>
<a href="#l18.1193"></a><span id="l18.1193">     },</span>
<a href="#l18.1194"></a><span id="l18.1194"> </span>
<a href="#l18.1195"></a><span id="l18.1195">     /**</span>
<a href="#l18.1196"></a><span id="l18.1196">      * Process (apparently newly added) messages that have been looked at by</span>
<a href="#l18.1197"></a><span id="l18.1197">      *  the message classifier.  This ensures that if the message was going</span>
<a href="#l18.1198"></a><span id="l18.1198">      *  to get marked as spam, this will have already happened.</span>
<a href="#l18.1199"></a><span id="l18.1199">      *</span>
<a href="#l18.1200"></a><span id="l18.1200">      * Besides truly new (to us) messages, We will also receive this event for</span>
<a href="#l18.1201"></a><span id="l18.1201">      *  messages that are the result of IMAP message move/copy operations,</span>
<a href="#l18.1202"></a><span id="l18.1202">      *  including both moves that generated offline fake headers and those that</span>
<a href="#l18.1203"></a><span id="l18.1203">      *  did not.  In the offline fake header case, however, we are able to</span>
<a href="#l18.1204"></a><span id="l18.1204">      *  ignore their msgsClassified events because we will have received a</span>
<a href="#l18.1205"></a><span id="l18.1205">      *  msgKeyChanged notification sometime in the recent past.</span>
<a href="#l18.1206"></a><span id="l18.1206">      */</span>
<a href="#l18.1207"></a><span id="l18.1207" class="difflineminus">-    msgsClassified: function gloda_indexer_msgsClassified(</span>
<a href="#l18.1208"></a><span id="l18.1208" class="difflineminus">-                      aMsgHdrs, aJunkClassified, aTraitClassified) {</span>
<a href="#l18.1209"></a><span id="l18.1209" class="difflineplus">+    msgsClassified(aMsgHdrs, aJunkClassified, aTraitClassified) {</span>
<a href="#l18.1210"></a><span id="l18.1210">       this.indexer._log.debug(&quot;msgsClassified notification&quot;);</span>
<a href="#l18.1211"></a><span id="l18.1211">       try {</span>
<a href="#l18.1212"></a><span id="l18.1212">         GlodaMsgIndexer._reindexChangedMessages(aMsgHdrs.enumerate(), false);</span>
<a href="#l18.1213"></a><span id="l18.1213" class="difflineminus">-      }</span>
<a href="#l18.1214"></a><span id="l18.1214" class="difflineminus">-      catch (ex) {</span>
<a href="#l18.1215"></a><span id="l18.1215" class="difflineplus">+      } catch (ex) {</span>
<a href="#l18.1216"></a><span id="l18.1216">         this.indexer._log.error(&quot;Explosion in msgsClassified handling:&quot;, ex);</span>
<a href="#l18.1217"></a><span id="l18.1217">       }</span>
<a href="#l18.1218"></a><span id="l18.1218">     },</span>
<a href="#l18.1219"></a><span id="l18.1219"> </span>
<a href="#l18.1220"></a><span id="l18.1220">     /**</span>
<a href="#l18.1221"></a><span id="l18.1221">      * Handle real, actual deletion (move to trash and IMAP deletion model</span>
<a href="#l18.1222"></a><span id="l18.1222">      *  don't count); we only see the deletion here when it becomes forever,</span>
<a href="#l18.1223"></a><span id="l18.1223">      *  or rather _just before_ it becomes forever.  Because the header is</span>
<a href="#l18.1224"></a><span id="l18.1224" class="difflineat">@@ -2209,17 +2167,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1225"></a><span id="l18.1225">      *  information required to purge it later without the header.</span>
<a href="#l18.1226"></a><span id="l18.1226">      * To this end, we mark all messages that were indexed in the gloda message</span>
<a href="#l18.1227"></a><span id="l18.1227">      *  database as deleted.  We set our pending deletions flag to let our</span>
<a href="#l18.1228"></a><span id="l18.1228">      *  indexing logic know that after its next wave of folder traversal, it</span>
<a href="#l18.1229"></a><span id="l18.1229">      *  should perform a deletion pass.  If it turns out the messages are coming</span>
<a href="#l18.1230"></a><span id="l18.1230">      *  back, the fact that deletion is thus deferred can be handy, as we can</span>
<a href="#l18.1231"></a><span id="l18.1231">      *  reuse the existing gloda message.</span>
<a href="#l18.1232"></a><span id="l18.1232">      */</span>
<a href="#l18.1233"></a><span id="l18.1233" class="difflineminus">-    msgsDeleted: function gloda_indexer_msgsDeleted(aMsgHdrs) {</span>
<a href="#l18.1234"></a><span id="l18.1234" class="difflineplus">+    msgsDeleted(aMsgHdrs) {</span>
<a href="#l18.1235"></a><span id="l18.1235">       this.indexer._log.debug(&quot;msgsDeleted notification&quot;);</span>
<a href="#l18.1236"></a><span id="l18.1236">       let glodaMessageIds = [];</span>
<a href="#l18.1237"></a><span id="l18.1237"> </span>
<a href="#l18.1238"></a><span id="l18.1238">       for (let iMsgHdr = 0; iMsgHdr &lt; aMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l18.1239"></a><span id="l18.1239">         let msgHdr = aMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l18.1240"></a><span id="l18.1240">         let [glodaId, glodaDirty] = PendingCommitTracker.getGlodaState(msgHdr);</span>
<a href="#l18.1241"></a><span id="l18.1241">         if (glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l18.1242"></a><span id="l18.1242">             glodaDirty != GlodaMsgIndexer.kMessageFilthy)</span>
<a href="#l18.1243"></a><span id="l18.1243" class="difflineat">@@ -2273,18 +2231,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1244"></a><span id="l18.1244">      * Because copied messages are, by their nature, duplicate messages, we</span>
<a href="#l18.1245"></a><span id="l18.1245">      *  do not particularly care about them.  As such, we defer their processing</span>
<a href="#l18.1246"></a><span id="l18.1246">      *  to the automatic sync logic that will happen much later on.  This is</span>
<a href="#l18.1247"></a><span id="l18.1247">      *  potentially desirable in case the user deletes some of the original</span>
<a href="#l18.1248"></a><span id="l18.1248">      *  messages, allowing us to reuse the gloda message representations when</span>
<a href="#l18.1249"></a><span id="l18.1249">      *  we finally get around to indexing the messages.  We do need to mark the</span>
<a href="#l18.1250"></a><span id="l18.1250">      *  folder as dirty, though, to clue in the sync logic.</span>
<a href="#l18.1251"></a><span id="l18.1251">      */</span>
<a href="#l18.1252"></a><span id="l18.1252" class="difflineminus">-    msgsMoveCopyCompleted: function gloda_indexer_msgsMoveCopyCompleted(aMove,</span>
<a href="#l18.1253"></a><span id="l18.1253" class="difflineminus">-                             aSrcMsgHdrs, aDestFolder, aDestMsgHdrs) {</span>
<a href="#l18.1254"></a><span id="l18.1254" class="difflineplus">+    msgsMoveCopyCompleted(aMove, aSrcMsgHdrs, aDestFolder, aDestMsgHdrs) {</span>
<a href="#l18.1255"></a><span id="l18.1255">       this.indexer._log.debug(&quot;MoveCopy notification.  Move: &quot; + aMove);</span>
<a href="#l18.1256"></a><span id="l18.1256">       try {</span>
<a href="#l18.1257"></a><span id="l18.1257">         // ---- Move</span>
<a href="#l18.1258"></a><span id="l18.1258">         if (aMove) {</span>
<a href="#l18.1259"></a><span id="l18.1259">           // -- Effectively a deletion?</span>
<a href="#l18.1260"></a><span id="l18.1260">           // If the destination folder is not indexed, it's like these messages</span>
<a href="#l18.1261"></a><span id="l18.1261">           //  are being deleted.</span>
<a href="#l18.1262"></a><span id="l18.1262">           if (!GlodaMsgIndexer.shouldIndexFolder(aDestFolder)) {</span>
<a href="#l18.1263"></a><span id="l18.1263" class="difflineat">@@ -2316,49 +2273,47 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1264"></a><span id="l18.1264">               }</span>
<a href="#l18.1265"></a><span id="l18.1265"> </span>
<a href="#l18.1266"></a><span id="l18.1266">               // Since we are moving messages from a folder where they were</span>
<a href="#l18.1267"></a><span id="l18.1267">               //  effectively not indexed, it is up to us to make sure the</span>
<a href="#l18.1268"></a><span id="l18.1268">               //  messages now get indexed.</span>
<a href="#l18.1269"></a><span id="l18.1269">               this.indexer._reindexChangedMessages(aDestMsgHdrs.enumerate());</span>
<a href="#l18.1270"></a><span id="l18.1270">               return;</span>
<a href="#l18.1271"></a><span id="l18.1271">             }</span>
<a href="#l18.1272"></a><span id="l18.1272" class="difflineplus">+</span>
<a href="#l18.1273"></a><span id="l18.1273">             // IMAP move case, we need to operate on the pending headers using</span>
<a href="#l18.1274"></a><span id="l18.1274">             //  the source header to get the pending header and as the</span>
<a href="#l18.1275"></a><span id="l18.1275">             //  indication of what has been already set on the pending header.</span>
<a href="#l18.1276"></a><span id="l18.1276" class="difflineminus">-            else {</span>
<a href="#l18.1277"></a><span id="l18.1277" class="difflineminus">-              let destDb;</span>
<a href="#l18.1278"></a><span id="l18.1278" class="difflineminus">-              // so, this can fail, and there's not much we can do about it.</span>
<a href="#l18.1279"></a><span id="l18.1279" class="difflineminus">-              try {</span>
<a href="#l18.1280"></a><span id="l18.1280" class="difflineminus">-                destDb = aDestFolder.msgDatabase;</span>
<a href="#l18.1281"></a><span id="l18.1281" class="difflineminus">-              } catch (ex) {</span>
<a href="#l18.1282"></a><span id="l18.1282" class="difflineminus">-                this.indexer._log.warn(&quot;Destination database for &quot; +</span>
<a href="#l18.1283"></a><span id="l18.1283" class="difflineminus">-                                       aDestFolder.prettyName +</span>
<a href="#l18.1284"></a><span id="l18.1284" class="difflineminus">-                                       &quot; not ready on IMAP move.&quot; +</span>
<a href="#l18.1285"></a><span id="l18.1285" class="difflineminus">-                                       &quot; Gloda corruption possible.&quot;);</span>
<a href="#l18.1286"></a><span id="l18.1286" class="difflineminus">-                return;</span>
<a href="#l18.1287"></a><span id="l18.1287" class="difflineminus">-              }</span>
<a href="#l18.1288"></a><span id="l18.1288" class="difflineminus">-              for (let srcMsgHdr of fixIterator(aSrcMsgHdrs, Ci.nsIMsgDBHdr)) {</span>
<a href="#l18.1289"></a><span id="l18.1289" class="difflineminus">-                // zero it out if it exists</span>
<a href="#l18.1290"></a><span id="l18.1290" class="difflineminus">-                // (no need to deal with pending commit issues here; a filthy</span>
<a href="#l18.1291"></a><span id="l18.1291" class="difflineminus">-                //  folder by definition has nothing indexed in it.)</span>
<a href="#l18.1292"></a><span id="l18.1292" class="difflineminus">-                let glodaId = srcMsgHdr.getUint32Property(</span>
<a href="#l18.1293"></a><span id="l18.1293" class="difflineminus">-                                GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l18.1294"></a><span id="l18.1294" class="difflineminus">-                if (glodaId)</span>
<a href="#l18.1295"></a><span id="l18.1295" class="difflineminus">-                  destDb.setUint32AttributeOnPendingHdr(</span>
<a href="#l18.1296"></a><span id="l18.1296" class="difflineminus">-                    srcMsgHdr, GLODA_MESSAGE_ID_PROPERTY, 0);</span>
<a href="#l18.1297"></a><span id="l18.1297" class="difflineminus">-              }</span>
<a href="#l18.1298"></a><span id="l18.1298" class="difflineminus">-</span>
<a href="#l18.1299"></a><span id="l18.1299" class="difflineminus">-              // Nothing remains to be done.  The msgClassified event will take</span>
<a href="#l18.1300"></a><span id="l18.1300" class="difflineminus">-              //  care of making sure the message gets indexed.</span>
<a href="#l18.1301"></a><span id="l18.1301" class="difflineplus">+            let destDb;</span>
<a href="#l18.1302"></a><span id="l18.1302" class="difflineplus">+            // so, this can fail, and there's not much we can do about it.</span>
<a href="#l18.1303"></a><span id="l18.1303" class="difflineplus">+            try {</span>
<a href="#l18.1304"></a><span id="l18.1304" class="difflineplus">+              destDb = aDestFolder.msgDatabase;</span>
<a href="#l18.1305"></a><span id="l18.1305" class="difflineplus">+            } catch (ex) {</span>
<a href="#l18.1306"></a><span id="l18.1306" class="difflineplus">+              this.indexer._log.warn(&quot;Destination database for &quot; +</span>
<a href="#l18.1307"></a><span id="l18.1307" class="difflineplus">+                                     aDestFolder.prettyName +</span>
<a href="#l18.1308"></a><span id="l18.1308" class="difflineplus">+                                     &quot; not ready on IMAP move.&quot; +</span>
<a href="#l18.1309"></a><span id="l18.1309" class="difflineplus">+                                     &quot; Gloda corruption possible.&quot;);</span>
<a href="#l18.1310"></a><span id="l18.1310">               return;</span>
<a href="#l18.1311"></a><span id="l18.1311">             }</span>
<a href="#l18.1312"></a><span id="l18.1312" class="difflineplus">+            for (let srcMsgHdr of fixIterator(aSrcMsgHdrs, Ci.nsIMsgDBHdr)) {</span>
<a href="#l18.1313"></a><span id="l18.1313" class="difflineplus">+              // zero it out if it exists</span>
<a href="#l18.1314"></a><span id="l18.1314" class="difflineplus">+              // (no need to deal with pending commit issues here; a filthy</span>
<a href="#l18.1315"></a><span id="l18.1315" class="difflineplus">+              //  folder by definition has nothing indexed in it.)</span>
<a href="#l18.1316"></a><span id="l18.1316" class="difflineplus">+              let glodaId = srcMsgHdr.getUint32Property(</span>
<a href="#l18.1317"></a><span id="l18.1317" class="difflineplus">+                              GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l18.1318"></a><span id="l18.1318" class="difflineplus">+              if (glodaId)</span>
<a href="#l18.1319"></a><span id="l18.1319" class="difflineplus">+                destDb.setUint32AttributeOnPendingHdr(</span>
<a href="#l18.1320"></a><span id="l18.1320" class="difflineplus">+                  srcMsgHdr, GLODA_MESSAGE_ID_PROPERTY, 0);</span>
<a href="#l18.1321"></a><span id="l18.1321" class="difflineplus">+            }</span>
<a href="#l18.1322"></a><span id="l18.1322" class="difflineplus">+</span>
<a href="#l18.1323"></a><span id="l18.1323" class="difflineplus">+            // Nothing remains to be done.  The msgClassified event will take</span>
<a href="#l18.1324"></a><span id="l18.1324" class="difflineplus">+            //  care of making sure the message gets indexed.</span>
<a href="#l18.1325"></a><span id="l18.1325" class="difflineplus">+            return;</span>
<a href="#l18.1326"></a><span id="l18.1326">           }</span>
<a href="#l18.1327"></a><span id="l18.1327"> </span>
<a href="#l18.1328"></a><span id="l18.1328" class="difflineminus">-</span>
<a href="#l18.1329"></a><span id="l18.1329">           // --- Have destination headers (local case):</span>
<a href="#l18.1330"></a><span id="l18.1330">           if (aDestMsgHdrs) {</span>
<a href="#l18.1331"></a><span id="l18.1331">             // -- Update message keys for valid gloda-id's.</span>
<a href="#l18.1332"></a><span id="l18.1332">             // (Which means ignore filthy gloda-id's.)</span>
<a href="#l18.1333"></a><span id="l18.1333">             let glodaIds = [];</span>
<a href="#l18.1334"></a><span id="l18.1334">             let newMessageKeys = [];</span>
<a href="#l18.1335"></a><span id="l18.1335">             aSrcMsgHdrs.QueryInterface(Ci.nsIArray);</span>
<a href="#l18.1336"></a><span id="l18.1336">             aDestMsgHdrs.QueryInterface(Ci.nsIArray);</span>
<a href="#l18.1337"></a><span id="l18.1337" class="difflineat">@@ -2373,18 +2328,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1338"></a><span id="l18.1338">                 PendingCommitTracker.getGlodaState(srcMsgHdr);</span>
<a href="#l18.1339"></a><span id="l18.1339">               if (glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l18.1340"></a><span id="l18.1340">                   dirtyStatus != GlodaMsgIndexer.kMessageFilthy) {</span>
<a href="#l18.1341"></a><span id="l18.1341">                 // we may need to update the pending commit map (it checks)</span>
<a href="#l18.1342"></a><span id="l18.1342">                 PendingCommitTracker.noteMove(srcMsgHdr, destMsgHdr);</span>
<a href="#l18.1343"></a><span id="l18.1343">                 // but we always need to update our database</span>
<a href="#l18.1344"></a><span id="l18.1344">                 glodaIds.push(glodaId);</span>
<a href="#l18.1345"></a><span id="l18.1345">                 newMessageKeys.push(destMsgHdr.messageKey);</span>
<a href="#l18.1346"></a><span id="l18.1346" class="difflineminus">-              }</span>
<a href="#l18.1347"></a><span id="l18.1347" class="difflineminus">-              else {</span>
<a href="#l18.1348"></a><span id="l18.1348" class="difflineplus">+              } else {</span>
<a href="#l18.1349"></a><span id="l18.1349">                 sawNonGlodaMessage = true;</span>
<a href="#l18.1350"></a><span id="l18.1350">               }</span>
<a href="#l18.1351"></a><span id="l18.1351">             }</span>
<a href="#l18.1352"></a><span id="l18.1352"> </span>
<a href="#l18.1353"></a><span id="l18.1353">             // this method takes care to update the in-memory representations</span>
<a href="#l18.1354"></a><span id="l18.1354">             //  too; we don't need to do anything</span>
<a href="#l18.1355"></a><span id="l18.1355">             if (glodaIds.length)</span>
<a href="#l18.1356"></a><span id="l18.1356">               GlodaDatastore.updateMessageLocations(glodaIds, newMessageKeys,</span>
<a href="#l18.1357"></a><span id="l18.1357" class="difflineat">@@ -2392,22 +2346,21 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1358"></a><span id="l18.1358"> </span>
<a href="#l18.1359"></a><span id="l18.1359">             // Mark the destination folder dirty if we saw any messages that</span>
<a href="#l18.1360"></a><span id="l18.1360">             //  were not already gloda indexed.</span>
<a href="#l18.1361"></a><span id="l18.1361">             if (sawNonGlodaMessage) {</span>
<a href="#l18.1362"></a><span id="l18.1362">               let destGlodaFolder = GlodaDatastore._mapFolder(aDestFolder);</span>
<a href="#l18.1363"></a><span id="l18.1363">               destGlodaFolder._ensureFolderDirty();</span>
<a href="#l18.1364"></a><span id="l18.1364">               this.indexer.indexingSweepNeeded = true;</span>
<a href="#l18.1365"></a><span id="l18.1365">             }</span>
<a href="#l18.1366"></a><span id="l18.1366" class="difflineminus">-          }</span>
<a href="#l18.1367"></a><span id="l18.1367" class="difflineminus">-          // --- No dest headers (IMAP case):</span>
<a href="#l18.1368"></a><span id="l18.1368" class="difflineminus">-          // Update any valid gloda indexed messages into their new folder to</span>
<a href="#l18.1369"></a><span id="l18.1369" class="difflineminus">-          //  make the indexer's life easier when it sees the messages in their</span>
<a href="#l18.1370"></a><span id="l18.1370" class="difflineminus">-          //  new folder.</span>
<a href="#l18.1371"></a><span id="l18.1371" class="difflineminus">-          else {</span>
<a href="#l18.1372"></a><span id="l18.1372" class="difflineplus">+          } else {</span>
<a href="#l18.1373"></a><span id="l18.1373" class="difflineplus">+            // --- No dest headers (IMAP case):</span>
<a href="#l18.1374"></a><span id="l18.1374" class="difflineplus">+            // Update any valid gloda indexed messages into their new folder to</span>
<a href="#l18.1375"></a><span id="l18.1375" class="difflineplus">+            //  make the indexer's life easier when it sees the messages in their</span>
<a href="#l18.1376"></a><span id="l18.1376" class="difflineplus">+            //  new folder.</span>
<a href="#l18.1377"></a><span id="l18.1377">             let glodaIds = [];</span>
<a href="#l18.1378"></a><span id="l18.1378"> </span>
<a href="#l18.1379"></a><span id="l18.1379">             let srcFolderIsLocal =</span>
<a href="#l18.1380"></a><span id="l18.1380">               (srcMsgFolder instanceof Ci.nsIMsgLocalMailFolder);</span>
<a href="#l18.1381"></a><span id="l18.1381">             for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l18.1382"></a><span id="l18.1382">               let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l18.1383"></a><span id="l18.1383"> </span>
<a href="#l18.1384"></a><span id="l18.1384">               let [glodaId, dirtyStatus] =</span>
<a href="#l18.1385"></a><span id="l18.1385" class="difflineat">@@ -2440,19 +2393,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1386"></a><span id="l18.1386">             }</span>
<a href="#l18.1387"></a><span id="l18.1387"> </span>
<a href="#l18.1388"></a><span id="l18.1388">             // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l18.1389"></a><span id="l18.1389">             GlodaDatastore.updateMessageFoldersByKeyPurging(glodaIds,</span>
<a href="#l18.1390"></a><span id="l18.1390">                                                             aDestFolder);</span>
<a href="#l18.1391"></a><span id="l18.1391">             // we _do not_ need to mark the folder as dirty, because the</span>
<a href="#l18.1392"></a><span id="l18.1392">             //  message added events will cause that to happen.</span>
<a href="#l18.1393"></a><span id="l18.1393">           }</span>
<a href="#l18.1394"></a><span id="l18.1394" class="difflineminus">-        }</span>
<a href="#l18.1395"></a><span id="l18.1395" class="difflineminus">-        // ---- Copy case</span>
<a href="#l18.1396"></a><span id="l18.1396" class="difflineminus">-        else {</span>
<a href="#l18.1397"></a><span id="l18.1397" class="difflineplus">+        } else { // ---- Copy case</span>
<a href="#l18.1398"></a><span id="l18.1398">           // -- Do not propagate gloda-id's for copies</span>
<a href="#l18.1399"></a><span id="l18.1399">           // (Only applies if we have the destination header, which means local)</span>
<a href="#l18.1400"></a><span id="l18.1400">           if (aDestMsgHdrs) {</span>
<a href="#l18.1401"></a><span id="l18.1401">             for (let destMsgHdr of fixIterator(aDestMsgHdrs, Ci.nsIMsgDBHdr)) {</span>
<a href="#l18.1402"></a><span id="l18.1402">               let glodaId = destMsgHdr.getUint32Property(</span>
<a href="#l18.1403"></a><span id="l18.1403">                 GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l18.1404"></a><span id="l18.1404">               if (glodaId)</span>
<a href="#l18.1405"></a><span id="l18.1405">                 destMsgHdr.setUint32Property(GLODA_MESSAGE_ID_PROPERTY, 0);</span>
<a href="#l18.1406"></a><span id="l18.1406" class="difflineat">@@ -2477,18 +2428,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1407"></a><span id="l18.1407">      *  actual work (if there is any to be done; the fake header might have</span>
<a href="#l18.1408"></a><span id="l18.1408">      *  guessed the right UID correctly) so that we can batch our work.</span>
<a href="#l18.1409"></a><span id="l18.1409">      *</span>
<a href="#l18.1410"></a><span id="l18.1410">      * The expectation is that there will be no meaningful time window between</span>
<a href="#l18.1411"></a><span id="l18.1411">      *  this notification and the msgsClassified notification since the message</span>
<a href="#l18.1412"></a><span id="l18.1412">      *  classifier should not actually need to classify the messages (they</span>
<a href="#l18.1413"></a><span id="l18.1413">      *  should already have been classified) and so can fast-path them.</span>
<a href="#l18.1414"></a><span id="l18.1414">      */</span>
<a href="#l18.1415"></a><span id="l18.1415" class="difflineminus">-    msgKeyChanged: function gloda_indexer_msgKeyChangeded(aOldMsgKey,</span>
<a href="#l18.1416"></a><span id="l18.1416" class="difflineminus">-                             aNewMsgHdr) {</span>
<a href="#l18.1417"></a><span id="l18.1417" class="difflineplus">+    msgKeyChanged(aOldMsgKey, aNewMsgHdr) {</span>
<a href="#l18.1418"></a><span id="l18.1418">       try {</span>
<a href="#l18.1419"></a><span id="l18.1419">         let val = null, newKey = aNewMsgHdr.messageKey;</span>
<a href="#l18.1420"></a><span id="l18.1420">         let [glodaId, glodaDirty] =</span>
<a href="#l18.1421"></a><span id="l18.1421">           PendingCommitTracker.getGlodaState(aNewMsgHdr);</span>
<a href="#l18.1422"></a><span id="l18.1422">         // If we haven't indexed this message yet, take no action, and leave it</span>
<a href="#l18.1423"></a><span id="l18.1423">         // up to msgsClassified to take proper action.</span>
<a href="#l18.1424"></a><span id="l18.1424">         if (glodaId &lt; GLODA_FIRST_VALID_MESSAGE_ID)</span>
<a href="#l18.1425"></a><span id="l18.1425">           return;</span>
<a href="#l18.1426"></a><span id="l18.1426" class="difflineat">@@ -2501,60 +2451,58 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1427"></a><span id="l18.1427">             id: glodaId,</span>
<a href="#l18.1428"></a><span id="l18.1428">             key: (aOldMsgKey !== newKey) ? newKey : null,</span>
<a href="#l18.1429"></a><span id="l18.1429">             isDirty: glodaDirty === GlodaMsgIndexer.kMessageDirty,</span>
<a href="#l18.1430"></a><span id="l18.1430">           };</span>
<a href="#l18.1431"></a><span id="l18.1431">         }</span>
<a href="#l18.1432"></a><span id="l18.1432"> </span>
<a href="#l18.1433"></a><span id="l18.1433">         let key = aNewMsgHdr.folder.URI + &quot;#&quot; + aNewMsgHdr.messageKey;</span>
<a href="#l18.1434"></a><span id="l18.1434">         this.indexer._keyChangedBatchInfo[key] = val;</span>
<a href="#l18.1435"></a><span id="l18.1435" class="difflineminus">-      }</span>
<a href="#l18.1436"></a><span id="l18.1436" class="difflineminus">-      // this is more for the unit test to fail rather than user error reporting</span>
<a href="#l18.1437"></a><span id="l18.1437" class="difflineminus">-      catch (ex) {</span>
<a href="#l18.1438"></a><span id="l18.1438" class="difflineplus">+      } catch (ex) {</span>
<a href="#l18.1439"></a><span id="l18.1439" class="difflineplus">+        // this is more for the unit test to fail rather than user error reporting</span>
<a href="#l18.1440"></a><span id="l18.1440">         this.indexer._log.error(&quot;Problem encountered during msgKeyChanged&quot; +</span>
<a href="#l18.1441"></a><span id="l18.1441">                                 &quot; notification handling: &quot; + ex + &quot;\n\n&quot; +</span>
<a href="#l18.1442"></a><span id="l18.1442">                                 ex.stack + &quot; \n\n&quot;);</span>
<a href="#l18.1443"></a><span id="l18.1443">       }</span>
<a href="#l18.1444"></a><span id="l18.1444">     },</span>
<a href="#l18.1445"></a><span id="l18.1445"> </span>
<a href="#l18.1446"></a><span id="l18.1446">     /**</span>
<a href="#l18.1447"></a><span id="l18.1447">      * Detect newly added folders before they get messages so we map them before</span>
<a href="#l18.1448"></a><span id="l18.1448">      * they get any messages added to them.  If we only hear about them after</span>
<a href="#l18.1449"></a><span id="l18.1449">      * they get their 1st message, then we will mark them filthy, but if we mark</span>
<a href="#l18.1450"></a><span id="l18.1450">      * them before that, they get marked clean.</span>
<a href="#l18.1451"></a><span id="l18.1451">      */</span>
<a href="#l18.1452"></a><span id="l18.1452" class="difflineminus">-    folderAdded: function gloda_indexer_folderAdded(aMsgFolder) {</span>
<a href="#l18.1453"></a><span id="l18.1453" class="difflineplus">+    folderAdded(aMsgFolder) {</span>
<a href="#l18.1454"></a><span id="l18.1454">       // This is invoked for its side-effect of invoking _mapFolder and doing so</span>
<a href="#l18.1455"></a><span id="l18.1455">       // only after filtering out folders we don't care about.</span>
<a href="#l18.1456"></a><span id="l18.1456">       GlodaMsgIndexer.shouldIndexFolder(aMsgFolder);</span>
<a href="#l18.1457"></a><span id="l18.1457">     },</span>
<a href="#l18.1458"></a><span id="l18.1458"> </span>
<a href="#l18.1459"></a><span id="l18.1459">     /**</span>
<a href="#l18.1460"></a><span id="l18.1460">      * Handles folder no-longer-exists-ence.  We mark all messages as deleted</span>
<a href="#l18.1461"></a><span id="l18.1461">      *  and remove the folder from our URI table.  Currently, if a folder that</span>
<a href="#l18.1462"></a><span id="l18.1462">      *  contains other folders is deleted, we may either receive one</span>
<a href="#l18.1463"></a><span id="l18.1463">      *  notification for the folder that is deleted, or a notification for the</span>
<a href="#l18.1464"></a><span id="l18.1464">      *  folder and one for each of its descendents.  This depends upon the</span>
<a href="#l18.1465"></a><span id="l18.1465">      *  underlying account implementation, so we explicitly handle each case.</span>
<a href="#l18.1466"></a><span id="l18.1466">      *  Namely, we treat it as if we're only planning on getting one, but we</span>
<a href="#l18.1467"></a><span id="l18.1467">      *  handle if the children are already gone for some reason.</span>
<a href="#l18.1468"></a><span id="l18.1468">      */</span>
<a href="#l18.1469"></a><span id="l18.1469" class="difflineminus">-    folderDeleted: function gloda_indexer_folderDeleted(aFolder) {</span>
<a href="#l18.1470"></a><span id="l18.1470" class="difflineplus">+    folderDeleted(aFolder) {</span>
<a href="#l18.1471"></a><span id="l18.1471">       this.indexer._log.debug(&quot;folderDeleted notification&quot;);</span>
<a href="#l18.1472"></a><span id="l18.1472">       try {</span>
<a href="#l18.1473"></a><span id="l18.1473">         let delFunc = function(aFolder, indexer) {</span>
<a href="#l18.1474"></a><span id="l18.1474">           if (indexer._datastore._folderKnown(aFolder)) {</span>
<a href="#l18.1475"></a><span id="l18.1475">             indexer._log.info(&quot;Processing deletion of folder &quot; +</span>
<a href="#l18.1476"></a><span id="l18.1476">                               aFolder.prettyName + &quot;.&quot;);</span>
<a href="#l18.1477"></a><span id="l18.1477">             let glodaFolder = GlodaDatastore._mapFolder(aFolder);</span>
<a href="#l18.1478"></a><span id="l18.1478">             indexer._datastore.markMessagesDeletedByFolderID(glodaFolder.id);</span>
<a href="#l18.1479"></a><span id="l18.1479">             indexer._datastore.deleteFolderByID(glodaFolder.id);</span>
<a href="#l18.1480"></a><span id="l18.1480">             GlodaDatastore._killGlodaFolderIntoTombstone(glodaFolder);</span>
<a href="#l18.1481"></a><span id="l18.1481" class="difflineminus">-          }</span>
<a href="#l18.1482"></a><span id="l18.1482" class="difflineminus">-          else {</span>
<a href="#l18.1483"></a><span id="l18.1483" class="difflineplus">+          } else {</span>
<a href="#l18.1484"></a><span id="l18.1484">             indexer._log.info(&quot;Ignoring deletion of folder &quot; +</span>
<a href="#l18.1485"></a><span id="l18.1485">                               aFolder.prettyName +</span>
<a href="#l18.1486"></a><span id="l18.1486">                               &quot; because it is unknown to gloda.&quot;);</span>
<a href="#l18.1487"></a><span id="l18.1487">           }</span>
<a href="#l18.1488"></a><span id="l18.1488">         };</span>
<a href="#l18.1489"></a><span id="l18.1489"> </span>
<a href="#l18.1490"></a><span id="l18.1490">         let descendentFolders = aFolder.descendants;</span>
<a href="#l18.1491"></a><span id="l18.1491">         // (the order of operations does not matter; child, non-child, whatever.)</span>
<a href="#l18.1492"></a><span id="l18.1492" class="difflineat">@@ -2576,41 +2524,38 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1493"></a><span id="l18.1493">      * Handle a folder being copied or moved.</span>
<a href="#l18.1494"></a><span id="l18.1494">      * Moves are handled by a helper function shared with _folderRenameHelper</span>
<a href="#l18.1495"></a><span id="l18.1495">      *  (which takes care of any nesting involved).</span>
<a href="#l18.1496"></a><span id="l18.1496">      * Copies are actually ignored, because our periodic indexing traversal</span>
<a href="#l18.1497"></a><span id="l18.1497">      *  should discover these automatically.  We could hint ourselves into</span>
<a href="#l18.1498"></a><span id="l18.1498">      *  action, but arguably a set of completely duplicate messages is not</span>
<a href="#l18.1499"></a><span id="l18.1499">      *  a high priority for indexing.</span>
<a href="#l18.1500"></a><span id="l18.1500">      */</span>
<a href="#l18.1501"></a><span id="l18.1501" class="difflineminus">-    folderMoveCopyCompleted: function gloda_indexer_folderMoveCopyCompleted(</span>
<a href="#l18.1502"></a><span id="l18.1502" class="difflineminus">-                               aMove, aSrcFolder, aDestFolder) {</span>
<a href="#l18.1503"></a><span id="l18.1503" class="difflineplus">+    folderMoveCopyCompleted(aMove, aSrcFolder, aDestFolder) {</span>
<a href="#l18.1504"></a><span id="l18.1504">       this.indexer._log.debug(&quot;folderMoveCopy notification (Move: &quot; + aMove</span>
<a href="#l18.1505"></a><span id="l18.1505">                               + &quot;)&quot;);</span>
<a href="#l18.1506"></a><span id="l18.1506">       if (aMove) {</span>
<a href="#l18.1507"></a><span id="l18.1507">         let srcURI = aSrcFolder.URI;</span>
<a href="#l18.1508"></a><span id="l18.1508">         let targetURI = aDestFolder.URI +</span>
<a href="#l18.1509"></a><span id="l18.1509">                         srcURI.substring(srcURI.lastIndexOf(&quot;/&quot;));</span>
<a href="#l18.1510"></a><span id="l18.1510">         this._folderRenameHelper(aSrcFolder, targetURI);</span>
<a href="#l18.1511"></a><span id="l18.1511" class="difflineminus">-      }</span>
<a href="#l18.1512"></a><span id="l18.1512" class="difflineminus">-      else {</span>
<a href="#l18.1513"></a><span id="l18.1513" class="difflineplus">+      } else {</span>
<a href="#l18.1514"></a><span id="l18.1514">         this.indexer.indexingSweepNeeded = true;</span>
<a href="#l18.1515"></a><span id="l18.1515">       }</span>
<a href="#l18.1516"></a><span id="l18.1516">     },</span>
<a href="#l18.1517"></a><span id="l18.1517"> </span>
<a href="#l18.1518"></a><span id="l18.1518">     /**</span>
<a href="#l18.1519"></a><span id="l18.1519">      * We just need to update the URI &lt;-&gt; ID maps and the row in the database,</span>
<a href="#l18.1520"></a><span id="l18.1520">      *  all of which is actually done by the datastore for us.</span>
<a href="#l18.1521"></a><span id="l18.1521">      * This method needs to deal with the complexity where local folders will</span>
<a href="#l18.1522"></a><span id="l18.1522">      *  generate a rename notification for each sub-folder, but IMAP folders</span>
<a href="#l18.1523"></a><span id="l18.1523">      *  will generate only a single notification.  Our logic primarily handles</span>
<a href="#l18.1524"></a><span id="l18.1524">      *  this by not exploding if the original folder no longer exists.</span>
<a href="#l18.1525"></a><span id="l18.1525">      */</span>
<a href="#l18.1526"></a><span id="l18.1526" class="difflineminus">-    _folderRenameHelper: function gloda_indexer_folderRenameHelper(aOrigFolder,</span>
<a href="#l18.1527"></a><span id="l18.1527" class="difflineminus">-                                                                   aNewURI) {</span>
<a href="#l18.1528"></a><span id="l18.1528" class="difflineplus">+    _folderRenameHelper(aOrigFolder, aNewURI) {</span>
<a href="#l18.1529"></a><span id="l18.1529">       let newFolder = MailUtils.getOrCreateFolder(aNewURI);</span>
<a href="#l18.1530"></a><span id="l18.1530">       let specialFolderFlags = Ci.nsMsgFolderFlags.Trash | Ci.nsMsgFolderFlags.Junk;</span>
<a href="#l18.1531"></a><span id="l18.1531">       if (newFolder.isSpecialFolder(specialFolderFlags, true)) {</span>
<a href="#l18.1532"></a><span id="l18.1532">         let descendentFolders = newFolder.descendants;</span>
<a href="#l18.1533"></a><span id="l18.1533"> </span>
<a href="#l18.1534"></a><span id="l18.1534">         // First thing to do: make sure we don't index the resulting folder and</span>
<a href="#l18.1535"></a><span id="l18.1535">         //  its descendents.</span>
<a href="#l18.1536"></a><span id="l18.1536">         GlodaMsgIndexer.resetFolderIndexingPriority(newFolder);</span>
<a href="#l18.1537"></a><span id="l18.1537" class="difflineat">@@ -2639,18 +2584,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1538"></a><span id="l18.1538">         this.indexer._log.debug(&quot;folder renamed: &quot; + origURI + &quot; to &quot; + aNewURI);</span>
<a href="#l18.1539"></a><span id="l18.1539">       }</span>
<a href="#l18.1540"></a><span id="l18.1540">     },</span>
<a href="#l18.1541"></a><span id="l18.1541"> </span>
<a href="#l18.1542"></a><span id="l18.1542">     /**</span>
<a href="#l18.1543"></a><span id="l18.1543">      * Handle folder renames, dispatching to our rename helper (which also</span>
<a href="#l18.1544"></a><span id="l18.1544">      *  takes care of any nested folder issues.)</span>
<a href="#l18.1545"></a><span id="l18.1545">      */</span>
<a href="#l18.1546"></a><span id="l18.1546" class="difflineminus">-    folderRenamed: function gloda_indexer_folderRenamed(aOrigFolder,</span>
<a href="#l18.1547"></a><span id="l18.1547" class="difflineminus">-                                                        aNewFolder) {</span>
<a href="#l18.1548"></a><span id="l18.1548" class="difflineplus">+    folderRenamed(aOrigFolder, aNewFolder) {</span>
<a href="#l18.1549"></a><span id="l18.1549">       this._folderRenameHelper(aOrigFolder, aNewFolder.URI);</span>
<a href="#l18.1550"></a><span id="l18.1550">     },</span>
<a href="#l18.1551"></a><span id="l18.1551"> </span>
<a href="#l18.1552"></a><span id="l18.1552">     /**</span>
<a href="#l18.1553"></a><span id="l18.1553">      * This tells us about many exciting things.  What they are and what we do:</span>
<a href="#l18.1554"></a><span id="l18.1554">      *</span>
<a href="#l18.1555"></a><span id="l18.1555">      * - FolderCompactStart: Mark the folder as compacting in our in-memory</span>
<a href="#l18.1556"></a><span id="l18.1556">      *    representation.  This should keep any new indexing out of the folder</span>
<a href="#l18.1557"></a><span id="l18.1557" class="difflineat">@@ -2661,32 +2605,32 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1558"></a><span id="l18.1558">      *    not marked filthy, queue a compaction job.</span>
<a href="#l18.1559"></a><span id="l18.1559">      *</span>
<a href="#l18.1560"></a><span id="l18.1560">      * - FolderReindexTriggered: We do the same thing as FolderCompactStart</span>
<a href="#l18.1561"></a><span id="l18.1561">      *    but don't mark the folder as compacting.</span>
<a href="#l18.1562"></a><span id="l18.1562">      *</span>
<a href="#l18.1563"></a><span id="l18.1563">      * - JunkStatusChanged: We mark the messages that have had their junk</span>
<a href="#l18.1564"></a><span id="l18.1564">      *    state change to be reindexed.</span>
<a href="#l18.1565"></a><span id="l18.1565">      */</span>
<a href="#l18.1566"></a><span id="l18.1566" class="difflineminus">-    itemEvent: function gloda_indexer_itemEvent(aItem, aEvent, aData, aString) {</span>
<a href="#l18.1567"></a><span id="l18.1567" class="difflineplus">+    itemEvent(aItem, aEvent, aData, aString) {</span>
<a href="#l18.1568"></a><span id="l18.1568">       // Compact and Reindex are close enough that we can reuse the same code</span>
<a href="#l18.1569"></a><span id="l18.1569">       //  with one minor difference.</span>
<a href="#l18.1570"></a><span id="l18.1570">       if (aEvent == &quot;FolderCompactStart&quot; ||</span>
<a href="#l18.1571"></a><span id="l18.1571">           aEvent == &quot;FolderReindexTriggered&quot;) {</span>
<a href="#l18.1572"></a><span id="l18.1572">         let aMsgFolder = aItem.QueryInterface(Ci.nsIMsgFolder);</span>
<a href="#l18.1573"></a><span id="l18.1573">         // ignore folders we ignore...</span>
<a href="#l18.1574"></a><span id="l18.1574">         if (!GlodaMsgIndexer.shouldIndexFolder(aMsgFolder))</span>
<a href="#l18.1575"></a><span id="l18.1575">           return;</span>
<a href="#l18.1576"></a><span id="l18.1576"> </span>
<a href="#l18.1577"></a><span id="l18.1577">         let glodaFolder = GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l18.1578"></a><span id="l18.1578">         if (aEvent == &quot;FolderCompactStart&quot;)</span>
<a href="#l18.1579"></a><span id="l18.1579">           glodaFolder.compacting = true;</span>
<a href="#l18.1580"></a><span id="l18.1580"> </span>
<a href="#l18.1581"></a><span id="l18.1581">         // Purge any explicit indexing of said folder.</span>
<a href="#l18.1582"></a><span id="l18.1582" class="difflineminus">-        GlodaIndexer.purgeJobsUsingFilter(function (aJob) {</span>
<a href="#l18.1583"></a><span id="l18.1583" class="difflineplus">+        GlodaIndexer.purgeJobsUsingFilter(function(aJob) {</span>
<a href="#l18.1584"></a><span id="l18.1584">           return (aJob.jobType == &quot;folder&quot; &amp;&amp;</span>
<a href="#l18.1585"></a><span id="l18.1585">                   aJob.id == aMsgFolder.id);</span>
<a href="#l18.1586"></a><span id="l18.1586">         });</span>
<a href="#l18.1587"></a><span id="l18.1587"> </span>
<a href="#l18.1588"></a><span id="l18.1588">         // Abort the active job if it's in the folder (this covers both</span>
<a href="#l18.1589"></a><span id="l18.1589">         //  event-driven indexing that happens to be in the folder as well</span>
<a href="#l18.1590"></a><span id="l18.1590">         //  explicit folder indexing of the folder).</span>
<a href="#l18.1591"></a><span id="l18.1591">         if (GlodaMsgIndexer._indexingFolder == aMsgFolder)</span>
<a href="#l18.1592"></a><span id="l18.1592" class="difflineat">@@ -2694,18 +2638,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1593"></a><span id="l18.1593"> </span>
<a href="#l18.1594"></a><span id="l18.1594">         // Tell the PendingCommitTracker to throw away anything it is tracking</span>
<a href="#l18.1595"></a><span id="l18.1595">         //  about the folder.  We will pick up the pieces in the compaction</span>
<a href="#l18.1596"></a><span id="l18.1596">         //  pass.</span>
<a href="#l18.1597"></a><span id="l18.1597">         PendingCommitTracker.noteFolderDatabaseGettingBlownAway(aMsgFolder);</span>
<a href="#l18.1598"></a><span id="l18.1598"> </span>
<a href="#l18.1599"></a><span id="l18.1599">         // (We do not need to mark the folder dirty because if we were indexing</span>
<a href="#l18.1600"></a><span id="l18.1600">         //  it, it already must have been marked dirty.)</span>
<a href="#l18.1601"></a><span id="l18.1601" class="difflineminus">-      }</span>
<a href="#l18.1602"></a><span id="l18.1602" class="difflineminus">-      else if (aEvent == &quot;FolderCompactFinish&quot;) {</span>
<a href="#l18.1603"></a><span id="l18.1603" class="difflineplus">+      } else if (aEvent == &quot;FolderCompactFinish&quot;) {</span>
<a href="#l18.1604"></a><span id="l18.1604">         let aMsgFolder = aItem.QueryInterface(Ci.nsIMsgFolder);</span>
<a href="#l18.1605"></a><span id="l18.1605">         // ignore folders we ignore...</span>
<a href="#l18.1606"></a><span id="l18.1606">         if (!GlodaMsgIndexer.shouldIndexFolder(aMsgFolder))</span>
<a href="#l18.1607"></a><span id="l18.1607">           return;</span>
<a href="#l18.1608"></a><span id="l18.1608"> </span>
<a href="#l18.1609"></a><span id="l18.1609">         let glodaFolder = GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l18.1610"></a><span id="l18.1610">         glodaFolder.compacting = false;</span>
<a href="#l18.1611"></a><span id="l18.1611">         glodaFolder._setCompactedState(true);</span>
<a href="#l18.1612"></a><span id="l18.1612" class="difflineat">@@ -2719,18 +2662,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1613"></a><span id="l18.1613">         // Queue indexing of the folder if it is dirty.  We are doing this</span>
<a href="#l18.1614"></a><span id="l18.1614">         //  mainly in case we were indexing it before the compaction started.</span>
<a href="#l18.1615"></a><span id="l18.1615">         //  It should be reasonably harmless if we weren't.</span>
<a href="#l18.1616"></a><span id="l18.1616">         // (It would probably be better to just make sure that there is an</span>
<a href="#l18.1617"></a><span id="l18.1617">         //  indexing sweep queued or active, and if it's already active that</span>
<a href="#l18.1618"></a><span id="l18.1618">         //  this folder is in the queue to be processed.)</span>
<a href="#l18.1619"></a><span id="l18.1619">         if (glodaFolder.dirtyStatus == glodaFolder.kFolderDirty)</span>
<a href="#l18.1620"></a><span id="l18.1620">           GlodaIndexer.indexJob(new IndexingJob(&quot;folder&quot;, glodaFolder.id));</span>
<a href="#l18.1621"></a><span id="l18.1621" class="difflineminus">-      }</span>
<a href="#l18.1622"></a><span id="l18.1622" class="difflineminus">-      else if (aEvent == &quot;JunkStatusChanged&quot;) {</span>
<a href="#l18.1623"></a><span id="l18.1623" class="difflineplus">+      } else if (aEvent == &quot;JunkStatusChanged&quot;) {</span>
<a href="#l18.1624"></a><span id="l18.1624">         this.indexer._log.debug(&quot;JunkStatusChanged notification&quot;);</span>
<a href="#l18.1625"></a><span id="l18.1625">         aItem.QueryInterface(Ci.nsIArray);</span>
<a href="#l18.1626"></a><span id="l18.1626">         GlodaMsgIndexer._reindexChangedMessages(aItem.enumerate(), true);</span>
<a href="#l18.1627"></a><span id="l18.1627">       }</span>
<a href="#l18.1628"></a><span id="l18.1628">     },</span>
<a href="#l18.1629"></a><span id="l18.1629">   },</span>
<a href="#l18.1630"></a><span id="l18.1630"> </span>
<a href="#l18.1631"></a><span id="l18.1631">   /**</span>
<a href="#l18.1632"></a><span id="l18.1632" class="difflineat">@@ -2738,75 +2680,68 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1633"></a><span id="l18.1633">    *  these events) PRIMARILY to get folder loaded notifications.  Because of</span>
<a href="#l18.1634"></a><span id="l18.1634">    *  deficiencies in the nsIMsgFolderListener's events at this time, we also</span>
<a href="#l18.1635"></a><span id="l18.1635">    *  get our folder-added and newsgroup notifications from here for now.  (This</span>
<a href="#l18.1636"></a><span id="l18.1636">    *  will be rectified.)</span>
<a href="#l18.1637"></a><span id="l18.1637">    */</span>
<a href="#l18.1638"></a><span id="l18.1638">   _folderListener: {</span>
<a href="#l18.1639"></a><span id="l18.1639">     indexer: null,</span>
<a href="#l18.1640"></a><span id="l18.1640"> </span>
<a href="#l18.1641"></a><span id="l18.1641" class="difflineminus">-    _init: function gloda_indexer_fl_init(aIndexer) {</span>
<a href="#l18.1642"></a><span id="l18.1642" class="difflineplus">+    _init(aIndexer) {</span>
<a href="#l18.1643"></a><span id="l18.1643">       this.indexer = aIndexer;</span>
<a href="#l18.1644"></a><span id="l18.1644">     },</span>
<a href="#l18.1645"></a><span id="l18.1645"> </span>
<a href="#l18.1646"></a><span id="l18.1646" class="difflineminus">-    OnItemAdded: function gloda_indexer_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l18.1647"></a><span id="l18.1647" class="difflineplus">+    OnItemAdded(aParentItem, aItem) {</span>
<a href="#l18.1648"></a><span id="l18.1648">     },</span>
<a href="#l18.1649"></a><span id="l18.1649" class="difflineminus">-    OnItemRemoved: function gloda_indexer_OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l18.1650"></a><span id="l18.1650" class="difflineplus">+    OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l18.1651"></a><span id="l18.1651">     },</span>
<a href="#l18.1652"></a><span id="l18.1652" class="difflineminus">-    OnItemPropertyChanged: function gloda_indexer_OnItemPropertyChanged(</span>
<a href="#l18.1653"></a><span id="l18.1653" class="difflineminus">-                             aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1654"></a><span id="l18.1654" class="difflineplus">+    OnItemPropertyChanged(aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1655"></a><span id="l18.1655">     },</span>
<a href="#l18.1656"></a><span id="l18.1656">     /**</span>
<a href="#l18.1657"></a><span id="l18.1657">      * Detect changes to folder flags and reset our indexing priority.  This</span>
<a href="#l18.1658"></a><span id="l18.1658">      * is important because (all?) folders start out without any flags and</span>
<a href="#l18.1659"></a><span id="l18.1659">      * then get their flags added to them.</span>
<a href="#l18.1660"></a><span id="l18.1660">      */</span>
<a href="#l18.1661"></a><span id="l18.1661" class="difflineminus">-    OnItemIntPropertyChanged: function gloda_indexer_OnItemIntPropertyChanged(</span>
<a href="#l18.1662"></a><span id="l18.1662" class="difflineminus">-                                aFolderItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1663"></a><span id="l18.1663" class="difflineplus">+    OnItemIntPropertyChanged(aFolderItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1664"></a><span id="l18.1664">       if (aProperty !== &quot;FolderFlag&quot;)</span>
<a href="#l18.1665"></a><span id="l18.1665">         return;</span>
<a href="#l18.1666"></a><span id="l18.1666">       if (!GlodaMsgIndexer.shouldIndexFolder(aFolderItem))</span>
<a href="#l18.1667"></a><span id="l18.1667">         return;</span>
<a href="#l18.1668"></a><span id="l18.1668">       // Only reset priority if folder Special Use changes.</span>
<a href="#l18.1669"></a><span id="l18.1669">       if ((aOldValue &amp; Ci.nsMsgFolderFlags.SpecialUse) ==</span>
<a href="#l18.1670"></a><span id="l18.1670">           (aNewValue &amp; Ci.nsMsgFolderFlags.SpecialUse))</span>
<a href="#l18.1671"></a><span id="l18.1671">         return;</span>
<a href="#l18.1672"></a><span id="l18.1672">       GlodaMsgIndexer.resetFolderIndexingPriority(aFolderItem);</span>
<a href="#l18.1673"></a><span id="l18.1673">     },</span>
<a href="#l18.1674"></a><span id="l18.1674" class="difflineminus">-    OnItemBoolPropertyChanged: function gloda_indexer_OnItemBoolPropertyChanged(</span>
<a href="#l18.1675"></a><span id="l18.1675" class="difflineminus">-                                aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1676"></a><span id="l18.1676" class="difflineplus">+    OnItemBoolPropertyChanged(aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1677"></a><span id="l18.1677">     },</span>
<a href="#l18.1678"></a><span id="l18.1678" class="difflineminus">-    OnItemUnicharPropertyChanged:</span>
<a href="#l18.1679"></a><span id="l18.1679" class="difflineminus">-        function gloda_indexer_OnItemUnicharPropertyChanged(</span>
<a href="#l18.1680"></a><span id="l18.1680" class="difflineminus">-          aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1681"></a><span id="l18.1681" class="difflineminus">-</span>
<a href="#l18.1682"></a><span id="l18.1682" class="difflineplus">+    OnItemUnicharPropertyChanged(aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1683"></a><span id="l18.1683">     },</span>
<a href="#l18.1684"></a><span id="l18.1684">     /**</span>
<a href="#l18.1685"></a><span id="l18.1685">      * Notice when user activity adds/removes tags or changes a message's</span>
<a href="#l18.1686"></a><span id="l18.1686">      *  status.</span>
<a href="#l18.1687"></a><span id="l18.1687">      */</span>
<a href="#l18.1688"></a><span id="l18.1688" class="difflineminus">-    OnItemPropertyFlagChanged: function gloda_indexer_OnItemPropertyFlagChanged(</span>
<a href="#l18.1689"></a><span id="l18.1689" class="difflineminus">-                                aMsgHdr, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1690"></a><span id="l18.1690" class="difflineplus">+    OnItemPropertyFlagChanged(aMsgHdr, aProperty, aOldValue, aNewValue) {</span>
<a href="#l18.1691"></a><span id="l18.1691">       if (aProperty == &quot;Keywords&quot; ||</span>
<a href="#l18.1692"></a><span id="l18.1692">           // We could care less about the new flag changing.</span>
<a href="#l18.1693"></a><span id="l18.1693">           (aProperty == &quot;Status&quot; &amp;&amp;</span>
<a href="#l18.1694"></a><span id="l18.1694">            (aOldValue ^ aNewValue) != Ci.nsMsgMessageFlags.New &amp;&amp;</span>
<a href="#l18.1695"></a><span id="l18.1695">            // We do care about IMAP deletion, but msgsDeleted tells us that, so</span>
<a href="#l18.1696"></a><span id="l18.1696">            //  ignore IMAPDeleted too...</span>
<a href="#l18.1697"></a><span id="l18.1697">            (aOldValue ^ aNewValue) != Ci.nsMsgMessageFlags.IMAPDeleted) ||</span>
<a href="#l18.1698"></a><span id="l18.1698">           aProperty == &quot;Flagged&quot;) {</span>
<a href="#l18.1699"></a><span id="l18.1699">         GlodaMsgIndexer._reindexChangedMessages([aMsgHdr], true);</span>
<a href="#l18.1700"></a><span id="l18.1700">       }</span>
<a href="#l18.1701"></a><span id="l18.1701">     },</span>
<a href="#l18.1702"></a><span id="l18.1702"> </span>
<a href="#l18.1703"></a><span id="l18.1703">     /**</span>
<a href="#l18.1704"></a><span id="l18.1704">      * Get folder loaded notifications for folders that had to do some</span>
<a href="#l18.1705"></a><span id="l18.1705">      *  (asynchronous) processing before they could be opened.</span>
<a href="#l18.1706"></a><span id="l18.1706">      */</span>
<a href="#l18.1707"></a><span id="l18.1707" class="difflineminus">-    OnItemEvent: function gloda_indexer_OnItemEvent(aFolder, aEvent) {</span>
<a href="#l18.1708"></a><span id="l18.1708" class="difflineplus">+    OnItemEvent(aFolder, aEvent) {</span>
<a href="#l18.1709"></a><span id="l18.1709">       if (aEvent == &quot;FolderLoaded&quot;)</span>
<a href="#l18.1710"></a><span id="l18.1710">         this.indexer._onFolderLoaded(aFolder);</span>
<a href="#l18.1711"></a><span id="l18.1711">     },</span>
<a href="#l18.1712"></a><span id="l18.1712">   },</span>
<a href="#l18.1713"></a><span id="l18.1713"> </span>
<a href="#l18.1714"></a><span id="l18.1714">   /* ***** Rebuilding / Reindexing ***** */</span>
<a href="#l18.1715"></a><span id="l18.1715">   /**</span>
<a href="#l18.1716"></a><span id="l18.1716">    * Allow us to invalidate an outstanding folder traversal because the</span>
<a href="#l18.1717"></a><span id="l18.1717" class="difflineat">@@ -2832,39 +2767,36 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1718"></a><span id="l18.1718">      * The fact that we already have the database open when getting this means</span>
<a href="#l18.1719"></a><span id="l18.1719">      *  that it had to be valid before we opened it, which hopefully rules out</span>
<a href="#l18.1720"></a><span id="l18.1720">      *  modification of the mbox file by an external process (since that is</span>
<a href="#l18.1721"></a><span id="l18.1721">      *  forbidden when we are running) and many other exotic things.</span>
<a href="#l18.1722"></a><span id="l18.1722">      *</span>
<a href="#l18.1723"></a><span id="l18.1723">      * So this really ends up just being a correctness / safety protection</span>
<a href="#l18.1724"></a><span id="l18.1724">      *  mechanism.  At least now that we have better compaction support.</span>
<a href="#l18.1725"></a><span id="l18.1725">      */</span>
<a href="#l18.1726"></a><span id="l18.1726" class="difflineminus">-    onAnnouncerGoingAway: function gloda_indexer_dbGoingAway(</span>
<a href="#l18.1727"></a><span id="l18.1727" class="difflineminus">-                                         aDBChangeAnnouncer) {</span>
<a href="#l18.1728"></a><span id="l18.1728" class="difflineplus">+    onAnnouncerGoingAway(aDBChangeAnnouncer) {</span>
<a href="#l18.1729"></a><span id="l18.1729">       // The fact that we are getting called means we have an active folder and</span>
<a href="#l18.1730"></a><span id="l18.1730">       //  that we therefore are the active job.  As such, we must kill the</span>
<a href="#l18.1731"></a><span id="l18.1731">       //  active job.</span>
<a href="#l18.1732"></a><span id="l18.1732">       // XXX In the future, when we support interleaved event-driven indexing</span>
<a href="#l18.1733"></a><span id="l18.1733">       //  that bumps long-running indexing tasks, the semantics of this will</span>
<a href="#l18.1734"></a><span id="l18.1734">       //  have to change a bit since we will want to maintain being active in a</span>
<a href="#l18.1735"></a><span id="l18.1735">       //  folder even when bumped.  However, we will probably have a more</span>
<a href="#l18.1736"></a><span id="l18.1736">       //  complex notion of indexing contexts on a per-job basis.</span>
<a href="#l18.1737"></a><span id="l18.1737">       GlodaIndexer.killActiveJob();</span>
<a href="#l18.1738"></a><span id="l18.1738">     },</span>
<a href="#l18.1739"></a><span id="l18.1739"> </span>
<a href="#l18.1740"></a><span id="l18.1740" class="difflineminus">-    onHdrFlagsChanged: function(aHdrChanged, aOldFlags, aNewFlags, aInstigator) {},</span>
<a href="#l18.1741"></a><span id="l18.1741" class="difflineminus">-    onHdrDeleted: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l18.1742"></a><span id="l18.1742" class="difflineminus">-    onHdrAdded: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l18.1743"></a><span id="l18.1743" class="difflineminus">-    onParentChanged: function(aKeyChanged, aOldParent, aNewParent,</span>
<a href="#l18.1744"></a><span id="l18.1744" class="difflineminus">-                              aInstigator) {},</span>
<a href="#l18.1745"></a><span id="l18.1745" class="difflineminus">-    onReadChanged: function(aInstigator) {},</span>
<a href="#l18.1746"></a><span id="l18.1746" class="difflineminus">-    onJunkScoreChanged: function(aInstigator) {},</span>
<a href="#l18.1747"></a><span id="l18.1747" class="difflineminus">-    onHdrPropertyChanged: function (aHdrToChange, aPreChange, aStatus,</span>
<a href="#l18.1748"></a><span id="l18.1748" class="difflineminus">-                                    aInstigator) {},</span>
<a href="#l18.1749"></a><span id="l18.1749" class="difflineminus">-    onEvent: function (aDB, aEvent) {},</span>
<a href="#l18.1750"></a><span id="l18.1750" class="difflineplus">+    onHdrFlagsChanged(aHdrChanged, aOldFlags, aNewFlags, aInstigator) {},</span>
<a href="#l18.1751"></a><span id="l18.1751" class="difflineplus">+    onHdrDeleted(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l18.1752"></a><span id="l18.1752" class="difflineplus">+    onHdrAdded(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l18.1753"></a><span id="l18.1753" class="difflineplus">+    onParentChanged(aKeyChanged, aOldParent, aNewParent, aInstigator) {},</span>
<a href="#l18.1754"></a><span id="l18.1754" class="difflineplus">+    onReadChanged(aInstigator) {},</span>
<a href="#l18.1755"></a><span id="l18.1755" class="difflineplus">+    onJunkScoreChanged(aInstigator) {},</span>
<a href="#l18.1756"></a><span id="l18.1756" class="difflineplus">+    onHdrPropertyChanged(aHdrToChange, aPreChange, aStatus, aInstigator) {},</span>
<a href="#l18.1757"></a><span id="l18.1757" class="difflineplus">+    onEvent(aDB, aEvent) {},</span>
<a href="#l18.1758"></a><span id="l18.1758">   },</span>
<a href="#l18.1759"></a><span id="l18.1759"> </span>
<a href="#l18.1760"></a><span id="l18.1760">   /**</span>
<a href="#l18.1761"></a><span id="l18.1761">    * Given a list of Message-ID's, return a matching list of lists of messages</span>
<a href="#l18.1762"></a><span id="l18.1762">    *  matching those Message-ID's.  So if you pass an array with three</span>
<a href="#l18.1763"></a><span id="l18.1763">    *  Message-ID's [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], you would get back an array containing</span>
<a href="#l18.1764"></a><span id="l18.1764">    *  3 lists, where the first list contains all the messages with a message-id</span>
<a href="#l18.1765"></a><span id="l18.1765">    *  of &quot;a&quot;, and so forth.  The reason a list is returned rather than null/a</span>
<a href="#l18.1766"></a><span id="l18.1766" class="difflineat">@@ -2877,18 +2809,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1767"></a><span id="l18.1767">    *  could be a lot of message-id's and/or a lot of messages with those</span>
<a href="#l18.1768"></a><span id="l18.1768">    *  message-id's.</span>
<a href="#l18.1769"></a><span id="l18.1769">    *</span>
<a href="#l18.1770"></a><span id="l18.1770">    * The returned collection will include both 'ghost' messages (messages</span>
<a href="#l18.1771"></a><span id="l18.1771">    *  that exist for conversation-threading purposes only) as well as deleted</span>
<a href="#l18.1772"></a><span id="l18.1772">    *  messages in addition to the normal 'live' messages that non-privileged</span>
<a href="#l18.1773"></a><span id="l18.1773">    *  queries might return.</span>
<a href="#l18.1774"></a><span id="l18.1774">    */</span>
<a href="#l18.1775"></a><span id="l18.1775" class="difflineminus">-  getMessagesByMessageID: function gloda_ns_getMessagesByMessageID(aMessageIDs,</span>
<a href="#l18.1776"></a><span id="l18.1776" class="difflineminus">-      aCallback, aCallbackThis) {</span>
<a href="#l18.1777"></a><span id="l18.1777" class="difflineplus">+  getMessagesByMessageID(aMessageIDs, aCallback, aCallbackThis) {</span>
<a href="#l18.1778"></a><span id="l18.1778">     let msgIDToIndex = {};</span>
<a href="#l18.1779"></a><span id="l18.1779">     let results = [];</span>
<a href="#l18.1780"></a><span id="l18.1780">     for (let iID = 0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l18.1781"></a><span id="l18.1781">       let msgID = aMessageIDs[iID];</span>
<a href="#l18.1782"></a><span id="l18.1782">       results.push([]);</span>
<a href="#l18.1783"></a><span id="l18.1783">       msgIDToIndex[msgID] = iID;</span>
<a href="#l18.1784"></a><span id="l18.1784">     }</span>
<a href="#l18.1785"></a><span id="l18.1785"> </span>
<a href="#l18.1786"></a><span id="l18.1786" class="difflineat">@@ -2925,35 +2856,31 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1787"></a><span id="l18.1787">    *</span>
<a href="#l18.1788"></a><span id="l18.1788">    * Prior to calling this method, the caller must have invoked</span>
<a href="#l18.1789"></a><span id="l18.1789">    *  |_indexerEnterFolder|, leaving us with the following true invariants</span>
<a href="#l18.1790"></a><span id="l18.1790">    *  below.</span>
<a href="#l18.1791"></a><span id="l18.1791">    *</span>
<a href="#l18.1792"></a><span id="l18.1792">    * @pre aMsgHdr.folder == this._indexingFolder</span>
<a href="#l18.1793"></a><span id="l18.1793">    * @pre aMsgHdr.folder.msgDatabase == this._indexingDatabase</span>
<a href="#l18.1794"></a><span id="l18.1794">    */</span>
<a href="#l18.1795"></a><span id="l18.1795" class="difflineminus">-  _indexMessage: function* gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l18.1796"></a><span id="l18.1796" class="difflineplus">+  * _indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l18.1797"></a><span id="l18.1797">     let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l18.1798"></a><span id="l18.1798">     if (logDebug)</span>
<a href="#l18.1799"></a><span id="l18.1799">       this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l18.1800"></a><span id="l18.1800">                       aMsgHdr.subject);</span>
<a href="#l18.1801"></a><span id="l18.1801"> </span>
<a href="#l18.1802"></a><span id="l18.1802">     // If the message is offline, then get the message body as well</span>
<a href="#l18.1803"></a><span id="l18.1803" class="difflineminus">-    let isMsgOffline = false;</span>
<a href="#l18.1804"></a><span id="l18.1804">     let aMimeMsg;</span>
<a href="#l18.1805"></a><span id="l18.1805">     if ((aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) ||</span>
<a href="#l18.1806"></a><span id="l18.1806">         (aMsgHdr.folder instanceof Ci.nsIMsgLocalMailFolder)) {</span>
<a href="#l18.1807"></a><span id="l18.1807" class="difflineminus">-      isMsgOffline = true;</span>
<a href="#l18.1808"></a><span id="l18.1808">       this._MsgHdrToMimeMessageFunc(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l18.1809"></a><span id="l18.1809">           aCallbackHandle.callback, false, {saneBodySize: true});</span>
<a href="#l18.1810"></a><span id="l18.1810">       aMimeMsg = (yield this.kWorkAsync)[1];</span>
<a href="#l18.1811"></a><span id="l18.1811" class="difflineminus">-    }</span>
<a href="#l18.1812"></a><span id="l18.1812" class="difflineminus">-    else {</span>
<a href="#l18.1813"></a><span id="l18.1813" class="difflineminus">-      if (logDebug)</span>
<a href="#l18.1814"></a><span id="l18.1814" class="difflineminus">-        this._log.debug(&quot;  * Message is not offline -- only headers indexed&quot;);</span>
<a href="#l18.1815"></a><span id="l18.1815" class="difflineplus">+    } else if (logDebug) {</span>
<a href="#l18.1816"></a><span id="l18.1816" class="difflineplus">+      this._log.debug(&quot;  * Message is not offline -- only headers indexed&quot;);</span>
<a href="#l18.1817"></a><span id="l18.1817">     }</span>
<a href="#l18.1818"></a><span id="l18.1818"> </span>
<a href="#l18.1819"></a><span id="l18.1819">     if (logDebug)</span>
<a href="#l18.1820"></a><span id="l18.1820">       this._log.debug(&quot;  * Got message, subject &quot; + aMsgHdr.subject);</span>
<a href="#l18.1821"></a><span id="l18.1821"> </span>
<a href="#l18.1822"></a><span id="l18.1822">     if (this._unitTestSuperVerbose) {</span>
<a href="#l18.1823"></a><span id="l18.1823">       if (aMimeMsg)</span>
<a href="#l18.1824"></a><span id="l18.1824">         this._log.debug(&quot;  * Got Mime &quot; + aMimeMsg.prettyString());</span>
<a href="#l18.1825"></a><span id="l18.1825" class="difflineat">@@ -2993,37 +2920,34 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1826"></a><span id="l18.1826"> </span>
<a href="#l18.1827"></a><span id="l18.1827">     let conversationID = null;</span>
<a href="#l18.1828"></a><span id="l18.1828">     let conversation = null;</span>
<a href="#l18.1829"></a><span id="l18.1829">     // -- figure out the conversation ID</span>
<a href="#l18.1830"></a><span id="l18.1830">     // if we have a clone/already exist, just use his conversation ID</span>
<a href="#l18.1831"></a><span id="l18.1831">     if (candidateCurMsgs.length &gt; 0) {</span>
<a href="#l18.1832"></a><span id="l18.1832">       conversationID = candidateCurMsgs[0].conversationID;</span>
<a href="#l18.1833"></a><span id="l18.1833">       conversation = candidateCurMsgs[0].conversation;</span>
<a href="#l18.1834"></a><span id="l18.1834" class="difflineminus">-    }</span>
<a href="#l18.1835"></a><span id="l18.1835" class="difflineminus">-    // otherwise check out our ancestors</span>
<a href="#l18.1836"></a><span id="l18.1836" class="difflineminus">-    else {</span>
<a href="#l18.1837"></a><span id="l18.1837" class="difflineplus">+    } else { // otherwise check out our ancestors</span>
<a href="#l18.1838"></a><span id="l18.1838">       // (walk from closest to furthest ancestor)</span>
<a href="#l18.1839"></a><span id="l18.1839" class="difflineminus">-      for (let iAncestor = ancestorLists.length-1; iAncestor &gt;= 0;</span>
<a href="#l18.1840"></a><span id="l18.1840" class="difflineplus">+      for (let iAncestor = ancestorLists.length - 1; iAncestor &gt;= 0;</span>
<a href="#l18.1841"></a><span id="l18.1841">           --iAncestor) {</span>
<a href="#l18.1842"></a><span id="l18.1842">         let ancestorList = ancestorLists[iAncestor];</span>
<a href="#l18.1843"></a><span id="l18.1843"> </span>
<a href="#l18.1844"></a><span id="l18.1844">         if (ancestorList.length &gt; 0) {</span>
<a href="#l18.1845"></a><span id="l18.1845">           // we only care about the first instance of the message because we are</span>
<a href="#l18.1846"></a><span id="l18.1846">           //  able to guarantee the invariant that all messages with the same</span>
<a href="#l18.1847"></a><span id="l18.1847">           //  message id belong to the same conversation.</span>
<a href="#l18.1848"></a><span id="l18.1848">           let ancestor = ancestorList[0];</span>
<a href="#l18.1849"></a><span id="l18.1849">           if (conversationID === null) {</span>
<a href="#l18.1850"></a><span id="l18.1850">             conversationID = ancestor.conversationID;</span>
<a href="#l18.1851"></a><span id="l18.1851">             conversation = ancestor.conversation;</span>
<a href="#l18.1852"></a><span id="l18.1852" class="difflineminus">-          }</span>
<a href="#l18.1853"></a><span id="l18.1853" class="difflineminus">-          else if (conversationID != ancestor.conversationID) {</span>
<a href="#l18.1854"></a><span id="l18.1854" class="difflineplus">+          } else if (conversationID != ancestor.conversationID) {</span>
<a href="#l18.1855"></a><span id="l18.1855">             // XXX this inconsistency is known and understood and tracked by</span>
<a href="#l18.1856"></a><span id="l18.1856">             //  bug 478162 https://bugzilla.mozilla.org/show_bug.cgi?id=478162</span>
<a href="#l18.1857"></a><span id="l18.1857" class="difflineminus">-            //this._log.error(&quot;Inconsistency in conversations invariant on &quot; +</span>
<a href="#l18.1858"></a><span id="l18.1858" class="difflineplus">+            // this._log.error(&quot;Inconsistency in conversations invariant on &quot; +</span>
<a href="#l18.1859"></a><span id="l18.1859">             //                ancestor.headerMessageID + &quot;.  It has conv id &quot; +</span>
<a href="#l18.1860"></a><span id="l18.1860">             //                ancestor.conversationID + &quot; but expected &quot; +</span>
<a href="#l18.1861"></a><span id="l18.1861">             //                conversationID + &quot;. ID: &quot; + ancestor.id);</span>
<a href="#l18.1862"></a><span id="l18.1862">           }</span>
<a href="#l18.1863"></a><span id="l18.1863">         }</span>
<a href="#l18.1864"></a><span id="l18.1864">       }</span>
<a href="#l18.1865"></a><span id="l18.1865">     }</span>
<a href="#l18.1866"></a><span id="l18.1866"> </span>
<a href="#l18.1867"></a><span id="l18.1867" class="difflineat">@@ -3089,19 +3013,18 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1868"></a><span id="l18.1868">           curMsg = candMsg;</span>
<a href="#l18.1869"></a><span id="l18.1869">         // if (we are in the same folder and) the candidate message's underlying</span>
<a href="#l18.1870"></a><span id="l18.1870">         //  message no longer exists/matches, we'll assume we are the same but</span>
<a href="#l18.1871"></a><span id="l18.1871">         //  were betrayed by a re-indexing or something, but we have to make</span>
<a href="#l18.1872"></a><span id="l18.1872">         //  sure a perfect match doesn't turn up.</span>
<a href="#l18.1873"></a><span id="l18.1873">         else if ((curMsg === null) &amp;&amp;</span>
<a href="#l18.1874"></a><span id="l18.1874">                  !this._indexingDatabase.ContainsKey(candMsg.messageKey))</span>
<a href="#l18.1875"></a><span id="l18.1875">           curMsg = candMsg;</span>
<a href="#l18.1876"></a><span id="l18.1876" class="difflineminus">-      }</span>
<a href="#l18.1877"></a><span id="l18.1877" class="difflineminus">-      // a ghost/deleted message is fine</span>
<a href="#l18.1878"></a><span id="l18.1878" class="difflineminus">-      else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l18.1879"></a><span id="l18.1879" class="difflineplus">+      } else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l18.1880"></a><span id="l18.1880" class="difflineplus">+        // a ghost/deleted message is fine</span>
<a href="#l18.1881"></a><span id="l18.1881">         curMsg = candMsg;</span>
<a href="#l18.1882"></a><span id="l18.1882">       }</span>
<a href="#l18.1883"></a><span id="l18.1883">     }</span>
<a href="#l18.1884"></a><span id="l18.1884"> </span>
<a href="#l18.1885"></a><span id="l18.1885">     let attachmentNames = null;</span>
<a href="#l18.1886"></a><span id="l18.1886">     if (aMimeMsg) {</span>
<a href="#l18.1887"></a><span id="l18.1887">       attachmentNames = aMimeMsg.allAttachments.</span>
<a href="#l18.1888"></a><span id="l18.1888">         filter(att =&gt; att.isRealAttachment).map(att =&gt; att.name);</span>
<a href="#l18.1889"></a><span id="l18.1889" class="difflineat">@@ -3111,18 +3034,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1890"></a><span id="l18.1890">     if (curMsg === null) {</span>
<a href="#l18.1891"></a><span id="l18.1891">       curMsg = this._datastore.createMessage(aMsgHdr.folder,</span>
<a href="#l18.1892"></a><span id="l18.1892">                                              aMsgHdr.messageKey,</span>
<a href="#l18.1893"></a><span id="l18.1893">                                              conversationID,</span>
<a href="#l18.1894"></a><span id="l18.1894">                                              aMsgHdr.date,</span>
<a href="#l18.1895"></a><span id="l18.1895">                                              aMsgHdr.messageId);</span>
<a href="#l18.1896"></a><span id="l18.1896">       curMsg._conversation = conversation;</span>
<a href="#l18.1897"></a><span id="l18.1897">       isConceptuallyNew = isRecordNew = insertFulltext = true;</span>
<a href="#l18.1898"></a><span id="l18.1898" class="difflineminus">-    }</span>
<a href="#l18.1899"></a><span id="l18.1899" class="difflineminus">-    else {</span>
<a href="#l18.1900"></a><span id="l18.1900" class="difflineplus">+    } else {</span>
<a href="#l18.1901"></a><span id="l18.1901">       isRecordNew = false;</span>
<a href="#l18.1902"></a><span id="l18.1902">       // the message is conceptually new if it was a ghost or dead.</span>
<a href="#l18.1903"></a><span id="l18.1903">       isConceptuallyNew = curMsg._isGhost || curMsg._isDeleted;</span>
<a href="#l18.1904"></a><span id="l18.1904">       // insert fulltext if it was a ghost</span>
<a href="#l18.1905"></a><span id="l18.1905">       insertFulltext = curMsg._isGhost;</span>
<a href="#l18.1906"></a><span id="l18.1906">       curMsg._folderID = this._datastore._mapFolder(aMsgHdr.folder).id;</span>
<a href="#l18.1907"></a><span id="l18.1907">       curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l18.1908"></a><span id="l18.1908">       curMsg.date = new Date(aMsgHdr.date / 1000);</span>
<a href="#l18.1909"></a><span id="l18.1909" class="difflineat">@@ -3192,18 +3114,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1910"></a><span id="l18.1910">    *  collecting up all the attributes that accept a message as their object</span>
<a href="#l18.1911"></a><span id="l18.1911">    *  type and issuing a delete against that.  For example, delete (*, [1,2,3],</span>
<a href="#l18.1912"></a><span id="l18.1912">    *  message id).</span>
<a href="#l18.1913"></a><span id="l18.1913">    * (We are punting because we haven't implemented support for generating</span>
<a href="#l18.1914"></a><span id="l18.1914">    *  attributes like that yet.)</span>
<a href="#l18.1915"></a><span id="l18.1915">    *</span>
<a href="#l18.1916"></a><span id="l18.1916">    * @TODO: implement deletion of attributes that reference (deleted) messages</span>
<a href="#l18.1917"></a><span id="l18.1917">    */</span>
<a href="#l18.1918"></a><span id="l18.1918" class="difflineminus">-  _deleteMessage: function* gloda_index_deleteMessage(aMessage,</span>
<a href="#l18.1919"></a><span id="l18.1919" class="difflineminus">-                                                      aCallbackHandle) {</span>
<a href="#l18.1920"></a><span id="l18.1920" class="difflineplus">+  * _deleteMessage(aMessage, aCallbackHandle) {</span>
<a href="#l18.1921"></a><span id="l18.1921">     let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l18.1922"></a><span id="l18.1922">     if (logDebug)</span>
<a href="#l18.1923"></a><span id="l18.1923">       this._log.debug(&quot;*** Deleting message: &quot; + aMessage);</span>
<a href="#l18.1924"></a><span id="l18.1924"> </span>
<a href="#l18.1925"></a><span id="l18.1925">     // -- delete our attributes</span>
<a href="#l18.1926"></a><span id="l18.1926">     // delete the message's attributes (if we implement the cascade delete, that</span>
<a href="#l18.1927"></a><span id="l18.1927">     //  could do the honors for us... right now we define the trigger in our</span>
<a href="#l18.1928"></a><span id="l18.1928">     //  schema but the back-end ignores it)</span>
<a href="#l18.1929"></a><span id="l18.1929" class="difflineat">@@ -3253,31 +3174,26 @@ var GlodaMsgIndexer = {</span>
<a href="#l18.1930"></a><span id="l18.1930">       for (let msg of conversationMsgs) {</span>
<a href="#l18.1931"></a><span id="l18.1931">         GlodaDatastore.deleteMessageByID(msg.id);</span>
<a href="#l18.1932"></a><span id="l18.1932">       }</span>
<a href="#l18.1933"></a><span id="l18.1933">       // - Obliterate the conversation</span>
<a href="#l18.1934"></a><span id="l18.1934">       GlodaDatastore.deleteConversationByID(aMessage.conversationID);</span>
<a href="#l18.1935"></a><span id="l18.1935">       // *no one* should hold a reference or use aMessage after this point,</span>
<a href="#l18.1936"></a><span id="l18.1936">       //  trash it so such ne'er do'wells are made plain.</span>
<a href="#l18.1937"></a><span id="l18.1937">       aMessage._objectPurgedMakeYourselfUnpleasant();</span>
<a href="#l18.1938"></a><span id="l18.1938" class="difflineminus">-    }</span>
<a href="#l18.1939"></a><span id="l18.1939" class="difflineminus">-    // -- Ghost or purge us as appropriate</span>
<a href="#l18.1940"></a><span id="l18.1940" class="difflineminus">-    else {</span>
<a href="#l18.1941"></a><span id="l18.1941" class="difflineplus">+    } else if (twinMessageExists) { // -- Ghost or purge us as appropriate</span>
<a href="#l18.1942"></a><span id="l18.1942">       // Purge us if we have a (living) twin; no ghost required.</span>
<a href="#l18.1943"></a><span id="l18.1943" class="difflineminus">-      if (twinMessageExists) {</span>
<a href="#l18.1944"></a><span id="l18.1944" class="difflineminus">-        GlodaDatastore.deleteMessageByID(aMessage.id);</span>
<a href="#l18.1945"></a><span id="l18.1945" class="difflineminus">-        // *no one* should hold a reference or use aMessage after this point,</span>
<a href="#l18.1946"></a><span id="l18.1946" class="difflineminus">-        //  trash it so such ne'er do'wells are made plain.</span>
<a href="#l18.1947"></a><span id="l18.1947" class="difflineminus">-        aMessage._objectPurgedMakeYourselfUnpleasant();</span>
<a href="#l18.1948"></a><span id="l18.1948" class="difflineminus">-      }</span>
<a href="#l18.1949"></a><span id="l18.1949" class="difflineplus">+      GlodaDatastore.deleteMessageByID(aMessage.id);</span>
<a href="#l18.1950"></a><span id="l18.1950" class="difflineplus">+      // *no one* should hold a reference or use aMessage after this point,</span>
<a href="#l18.1951"></a><span id="l18.1951" class="difflineplus">+      //  trash it so such ne'er do'wells are made plain.</span>
<a href="#l18.1952"></a><span id="l18.1952" class="difflineplus">+      aMessage._objectPurgedMakeYourselfUnpleasant();</span>
<a href="#l18.1953"></a><span id="l18.1953" class="difflineplus">+    } else {</span>
<a href="#l18.1954"></a><span id="l18.1954">       // No twin, a ghost is required, we become the ghost.</span>
<a href="#l18.1955"></a><span id="l18.1955" class="difflineminus">-      else {</span>
<a href="#l18.1956"></a><span id="l18.1956" class="difflineminus">-        aMessage._ghost();</span>
<a href="#l18.1957"></a><span id="l18.1957" class="difflineminus">-        GlodaDatastore.updateMessage(aMessage);</span>
<a href="#l18.1958"></a><span id="l18.1958" class="difflineminus">-        // ghosts don't have fulltext. purge it.</span>
<a href="#l18.1959"></a><span id="l18.1959" class="difflineminus">-        GlodaDatastore.deleteMessageTextByID(aMessage.id);</span>
<a href="#l18.1960"></a><span id="l18.1960" class="difflineminus">-      }</span>
<a href="#l18.1961"></a><span id="l18.1961" class="difflineplus">+      aMessage._ghost();</span>
<a href="#l18.1962"></a><span id="l18.1962" class="difflineplus">+      GlodaDatastore.updateMessage(aMessage);</span>
<a href="#l18.1963"></a><span id="l18.1963" class="difflineplus">+      // ghosts don't have fulltext. purge it.</span>
<a href="#l18.1964"></a><span id="l18.1964" class="difflineplus">+      GlodaDatastore.deleteMessageTextByID(aMessage.id);</span>
<a href="#l18.1965"></a><span id="l18.1965">     }</span>
<a href="#l18.1966"></a><span id="l18.1966"> </span>
<a href="#l18.1967"></a><span id="l18.1967">     yield this.kWorkDone;</span>
<a href="#l18.1968"></a><span id="l18.1968">   },</span>
<a href="#l18.1969"></a><span id="l18.1969"> };</span>
<a href="#l18.1970"></a><span id="l18.1970"> GlodaIndexer.registerIndexer(GlodaMsgIndexer);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -5,17 +5,17 @@</span>
<a href="#l19.4"></a><span id="l19.4"> /*</span>
<a href="#l19.5"></a><span id="l19.5">  * This file currently contains a fairly general implementation of asynchronous</span>
<a href="#l19.6"></a><span id="l19.6">  *  indexing with a very explicit message indexing implementation.  As gloda</span>
<a href="#l19.7"></a><span id="l19.7">  *  will eventually want to index more than just messages, the message-specific</span>
<a href="#l19.8"></a><span id="l19.8">  *  things should ideally lose their special hold on this file.  This will</span>
<a href="#l19.9"></a><span id="l19.9">  *  benefit readability/size as well.</span>
<a href="#l19.10"></a><span id="l19.10">  */</span>
<a href="#l19.11"></a><span id="l19.11"> </span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-this.EXPORTED_SYMBOLS = ['GlodaIndexer', 'IndexingJob'];</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;GlodaIndexer&quot;, &quot;IndexingJob&quot;];</span>
<a href="#l19.14"></a><span id="l19.14"> </span>
<a href="#l19.15"></a><span id="l19.15"> const {XPCOMUtils} = ChromeUtils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l19.16"></a><span id="l19.16"> const {Services} = ChromeUtils.import(&quot;resource://gre/modules/Services.jsm&quot;);</span>
<a href="#l19.17"></a><span id="l19.17"> </span>
<a href="#l19.18"></a><span id="l19.18"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l19.19"></a><span id="l19.19"> </span>
<a href="#l19.20"></a><span id="l19.20"> const {GlodaUtils} = ChromeUtils.import(&quot;resource:///modules/gloda/utils.js&quot;);</span>
<a href="#l19.21"></a><span id="l19.21"> const {GlodaDatastore} = ChromeUtils.import(&quot;resource:///modules/gloda/datastore.js&quot;);</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineat">@@ -53,31 +53,30 @@ function IndexingJob(aJobType, aID, aIte</span>
<a href="#l19.23"></a><span id="l19.23">   this.callback = null;</span>
<a href="#l19.24"></a><span id="l19.24">   this.callbackThis = null;</span>
<a href="#l19.25"></a><span id="l19.25"> }</span>
<a href="#l19.26"></a><span id="l19.26"> IndexingJob.prototype = {</span>
<a href="#l19.27"></a><span id="l19.27">   /**</span>
<a href="#l19.28"></a><span id="l19.28">    * Invoke the callback associated with this job, passing through all arguments</span>
<a href="#l19.29"></a><span id="l19.29">    *  received by this function to the callback function.</span>
<a href="#l19.30"></a><span id="l19.30">    */</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineminus">-  safelyInvokeCallback: function(...aArgs) {</span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+  safelyInvokeCallback(...aArgs) {</span>
<a href="#l19.33"></a><span id="l19.33">     if (!this.callback)</span>
<a href="#l19.34"></a><span id="l19.34">       return;</span>
<a href="#l19.35"></a><span id="l19.35">     try {</span>
<a href="#l19.36"></a><span id="l19.36">       this.callback.apply(this.callbackThis, aArgs);</span>
<a href="#l19.37"></a><span id="l19.37" class="difflineminus">-    }</span>
<a href="#l19.38"></a><span id="l19.38" class="difflineminus">-    catch(ex) {</span>
<a href="#l19.39"></a><span id="l19.39" class="difflineplus">+    } catch (ex) {</span>
<a href="#l19.40"></a><span id="l19.40">       GlodaIndexer._log.warn(&quot;job callback invocation problem:&quot;, ex);</span>
<a href="#l19.41"></a><span id="l19.41">     }</span>
<a href="#l19.42"></a><span id="l19.42">   },</span>
<a href="#l19.43"></a><span id="l19.43" class="difflineminus">-  toString: function IndexingJob_toString() {</span>
<a href="#l19.44"></a><span id="l19.44" class="difflineplus">+  toString() {</span>
<a href="#l19.45"></a><span id="l19.45">     return &quot;[job:&quot; + this.jobType +</span>
<a href="#l19.46"></a><span id="l19.46">       &quot; id:&quot; + this.id + &quot; items:&quot; + (this.items ? this.items.length : &quot;no&quot;) +</span>
<a href="#l19.47"></a><span id="l19.47">       &quot; offset:&quot; + this.offset + &quot; goal:&quot; + this.goal + &quot;]&quot;;</span>
<a href="#l19.48"></a><span id="l19.48" class="difflineminus">-  }</span>
<a href="#l19.49"></a><span id="l19.49" class="difflineplus">+  },</span>
<a href="#l19.50"></a><span id="l19.50"> };</span>
<a href="#l19.51"></a><span id="l19.51"> </span>
<a href="#l19.52"></a><span id="l19.52"> /**</span>
<a href="#l19.53"></a><span id="l19.53">  * @namespace Core indexing logic, plus message-specific indexing logic.</span>
<a href="#l19.54"></a><span id="l19.54">  *</span>
<a href="#l19.55"></a><span id="l19.55">  * === Indexing Goals</span>
<a href="#l19.56"></a><span id="l19.56">  * We have the following goals:</span>
<a href="#l19.57"></a><span id="l19.57">  *</span>
<a href="#l19.58"></a><span id="l19.58" class="difflineat">@@ -289,17 +288,17 @@ var GlodaIndexer = {</span>
<a href="#l19.59"></a><span id="l19.59">    * Last commit time.  Tracked to try and only commit at reasonable intervals.</span>
<a href="#l19.60"></a><span id="l19.60">    */</span>
<a href="#l19.61"></a><span id="l19.61">   _lastCommitTime: Date.now(),</span>
<a href="#l19.62"></a><span id="l19.62"> </span>
<a href="#l19.63"></a><span id="l19.63">   _inited: false,</span>
<a href="#l19.64"></a><span id="l19.64">   /**</span>
<a href="#l19.65"></a><span id="l19.65">    * Initialize the indexer.</span>
<a href="#l19.66"></a><span id="l19.66">    */</span>
<a href="#l19.67"></a><span id="l19.67" class="difflineminus">-  _init: function gloda_index_init() {</span>
<a href="#l19.68"></a><span id="l19.68" class="difflineplus">+  _init() {</span>
<a href="#l19.69"></a><span id="l19.69">     if (this._inited)</span>
<a href="#l19.70"></a><span id="l19.70">       return;</span>
<a href="#l19.71"></a><span id="l19.71"> </span>
<a href="#l19.72"></a><span id="l19.72">     this._inited = true;</span>
<a href="#l19.73"></a><span id="l19.73"> </span>
<a href="#l19.74"></a><span id="l19.74">     this._callbackHandle.init();</span>
<a href="#l19.75"></a><span id="l19.75"> </span>
<a href="#l19.76"></a><span id="l19.76">     if (Services.io.offline)</span>
<a href="#l19.77"></a><span id="l19.77" class="difflineat">@@ -314,37 +313,27 @@ var GlodaIndexer = {</span>
<a href="#l19.78"></a><span id="l19.78">                           .getService(Ci.nsIIdleService);</span>
<a href="#l19.79"></a><span id="l19.79"> </span>
<a href="#l19.80"></a><span id="l19.80">     // create our performance stopwatches</span>
<a href="#l19.81"></a><span id="l19.81">     try {</span>
<a href="#l19.82"></a><span id="l19.82">       this._perfIndexStopwatch = Cc[&quot;@mozilla.org/stopwatch;1&quot;]</span>
<a href="#l19.83"></a><span id="l19.83">                                    .createInstance(Ci.nsIStopwatch);</span>
<a href="#l19.84"></a><span id="l19.84">       this._perfPauseStopwatch = Cc[&quot;@mozilla.org/stopwatch;1&quot;]</span>
<a href="#l19.85"></a><span id="l19.85">                                    .createInstance(Ci.nsIStopwatch);</span>
<a href="#l19.86"></a><span id="l19.86" class="difflineminus">-</span>
<a href="#l19.87"></a><span id="l19.87">     } catch (ex) {</span>
<a href="#l19.88"></a><span id="l19.88">       this._log.error(&quot;problem creating stopwatch!: &quot; + ex);</span>
<a href="#l19.89"></a><span id="l19.89">     }</span>
<a href="#l19.90"></a><span id="l19.90"> </span>
<a href="#l19.91"></a><span id="l19.91">     // register for shutdown notifications</span>
<a href="#l19.92"></a><span id="l19.92">     Services.obs.addObserver(this, &quot;quit-application&quot;);</span>
<a href="#l19.93"></a><span id="l19.93"> </span>
<a href="#l19.94"></a><span id="l19.94">     // figure out if event-driven indexing should be enabled...</span>
<a href="#l19.95"></a><span id="l19.95">     let branch = Services.prefs.getBranch(&quot;mailnews.database.global.indexer.&quot;);</span>
<a href="#l19.96"></a><span id="l19.96" class="difflineminus">-    let eventDrivenEnabled = false; // default</span>
<a href="#l19.97"></a><span id="l19.97" class="difflineminus">-    let performInitialSweep = true; // default</span>
<a href="#l19.98"></a><span id="l19.98" class="difflineminus">-    try {</span>
<a href="#l19.99"></a><span id="l19.99" class="difflineminus">-      eventDrivenEnabled = branch.getBoolPref(&quot;enabled&quot;);</span>
<a href="#l19.100"></a><span id="l19.100" class="difflineminus">-    } catch (ex) {</span>
<a href="#l19.101"></a><span id="l19.101" class="difflineminus">-      dump(&quot;%%% annoying exception on pref access: &quot; + ex);</span>
<a href="#l19.102"></a><span id="l19.102" class="difflineminus">-    }</span>
<a href="#l19.103"></a><span id="l19.103" class="difflineminus">-    // this is a secret preference mainly intended for testing purposes.</span>
<a href="#l19.104"></a><span id="l19.104" class="difflineminus">-    try {</span>
<a href="#l19.105"></a><span id="l19.105" class="difflineminus">-      performInitialSweep = branch.getBoolPref(&quot;perform_initial_sweep&quot;);</span>
<a href="#l19.106"></a><span id="l19.106" class="difflineminus">-    } catch (ex) {}</span>
<a href="#l19.107"></a><span id="l19.107" class="difflineplus">+    let eventDrivenEnabled = branch.getBoolPref(&quot;enabled&quot;, false);</span>
<a href="#l19.108"></a><span id="l19.108" class="difflineplus">+    let performInitialSweep = branch.getBoolPref(&quot;perform_initial_sweep&quot;, true);</span>
<a href="#l19.109"></a><span id="l19.109">     // pretend we have already performed an initial sweep...</span>
<a href="#l19.110"></a><span id="l19.110">     if (!performInitialSweep)</span>
<a href="#l19.111"></a><span id="l19.111">       this._initialSweepPerformed = true;</span>
<a href="#l19.112"></a><span id="l19.112"> </span>
<a href="#l19.113"></a><span id="l19.113">     this.enabled = eventDrivenEnabled;</span>
<a href="#l19.114"></a><span id="l19.114">   },</span>
<a href="#l19.115"></a><span id="l19.115"> </span>
<a href="#l19.116"></a><span id="l19.116">   /**</span>
<a href="#l19.117"></a><span id="l19.117" class="difflineat">@@ -353,17 +342,17 @@ var GlodaIndexer = {</span>
<a href="#l19.118"></a><span id="l19.118">    *  in this state is a destructive thing from whence we cannot recover.</span>
<a href="#l19.119"></a><span id="l19.119">    */</span>
<a href="#l19.120"></a><span id="l19.120">   _indexerIsShutdown: false,</span>
<a href="#l19.121"></a><span id="l19.121"> </span>
<a href="#l19.122"></a><span id="l19.122">   /**</span>
<a href="#l19.123"></a><span id="l19.123">    * Shutdown the indexing process and datastore as quickly as possible in</span>
<a href="#l19.124"></a><span id="l19.124">    *  a synchronous fashion.</span>
<a href="#l19.125"></a><span id="l19.125">    */</span>
<a href="#l19.126"></a><span id="l19.126" class="difflineminus">-  _shutdown: function gloda_index_shutdown() {</span>
<a href="#l19.127"></a><span id="l19.127" class="difflineplus">+  _shutdown() {</span>
<a href="#l19.128"></a><span id="l19.128">     // no more timer events, please</span>
<a href="#l19.129"></a><span id="l19.129">     try {</span>
<a href="#l19.130"></a><span id="l19.130">       this._timer.cancel();</span>
<a href="#l19.131"></a><span id="l19.131">     } catch (ex) {}</span>
<a href="#l19.132"></a><span id="l19.132">     this._timer = null;</span>
<a href="#l19.133"></a><span id="l19.133">     try {</span>
<a href="#l19.134"></a><span id="l19.134">       this._longTimer.cancel();</span>
<a href="#l19.135"></a><span id="l19.135">     } catch (ex) {}</span>
<a href="#l19.136"></a><span id="l19.136" class="difflineat">@@ -385,18 +374,17 @@ var GlodaIndexer = {</span>
<a href="#l19.137"></a><span id="l19.137">     this.suppressIndexing = true;</span>
<a href="#l19.138"></a><span id="l19.138"> </span>
<a href="#l19.139"></a><span id="l19.139">     // If there is an active job and it has a cleanup handler, run it.</span>
<a href="#l19.140"></a><span id="l19.140">     if (this._curIndexingJob) {</span>
<a href="#l19.141"></a><span id="l19.141">       let workerDef = this._curIndexingJob._workerDef;</span>
<a href="#l19.142"></a><span id="l19.142">       try {</span>
<a href="#l19.143"></a><span id="l19.143">         if (workerDef.cleanup)</span>
<a href="#l19.144"></a><span id="l19.144">           workerDef.cleanup.call(workerDef.indexer, this._curIndexingJob);</span>
<a href="#l19.145"></a><span id="l19.145" class="difflineminus">-      }</span>
<a href="#l19.146"></a><span id="l19.146" class="difflineminus">-      catch (ex) {</span>
<a href="#l19.147"></a><span id="l19.147" class="difflineplus">+      } catch (ex) {</span>
<a href="#l19.148"></a><span id="l19.148">         this._log.error(&quot;problem during worker cleanup during shutdown.&quot;);</span>
<a href="#l19.149"></a><span id="l19.149">       }</span>
<a href="#l19.150"></a><span id="l19.150">     }</span>
<a href="#l19.151"></a><span id="l19.151">     // Definitely clean out the async call stack and any associated data</span>
<a href="#l19.152"></a><span id="l19.152">     this._callbackHandle.cleanup();</span>
<a href="#l19.153"></a><span id="l19.153">     this._workBatchData = undefined;</span>
<a href="#l19.154"></a><span id="l19.154"> </span>
<a href="#l19.155"></a><span id="l19.155">     // disable ourselves and all of the specific indexers</span>
<a href="#l19.156"></a><span id="l19.156" class="difflineat">@@ -434,17 +422,17 @@ var GlodaIndexer = {</span>
<a href="#l19.157"></a><span id="l19.157">    *     finalization required on the job.  Most workers should not need to use</span>
<a href="#l19.158"></a><span id="l19.158">    *     the trigger function.</span>
<a href="#l19.159"></a><span id="l19.159">    * @param aIndexer.initialSweep We call this to tell each indexer when it is</span>
<a href="#l19.160"></a><span id="l19.160">    *     its turn to run its indexing sweep.  The idea of the indexing sweep is</span>
<a href="#l19.161"></a><span id="l19.161">    *     that this is when you traverse things eligible for indexing to make</span>
<a href="#l19.162"></a><span id="l19.162">    *     sure they are indexed.  Right now we just call everyone at the same</span>
<a href="#l19.163"></a><span id="l19.163">    *     time and hope that their jobs don't fight too much.</span>
<a href="#l19.164"></a><span id="l19.164">    */</span>
<a href="#l19.165"></a><span id="l19.165" class="difflineminus">-  registerIndexer: function gloda_index_registerIndexer(aIndexer) {</span>
<a href="#l19.166"></a><span id="l19.166" class="difflineplus">+  registerIndexer(aIndexer) {</span>
<a href="#l19.167"></a><span id="l19.167">     this._log.info(&quot;Registering indexer: &quot; + aIndexer.name);</span>
<a href="#l19.168"></a><span id="l19.168">     this._indexers.push(aIndexer);</span>
<a href="#l19.169"></a><span id="l19.169"> </span>
<a href="#l19.170"></a><span id="l19.170">     try {</span>
<a href="#l19.171"></a><span id="l19.171">       for (let workerInfo of aIndexer.workers) {</span>
<a href="#l19.172"></a><span id="l19.172">         let workerCode = workerInfo[0];</span>
<a href="#l19.173"></a><span id="l19.173">         let workerDef = workerInfo[1];</span>
<a href="#l19.174"></a><span id="l19.174">         workerDef.name = workerCode;</span>
<a href="#l19.175"></a><span id="l19.175" class="difflineat">@@ -454,18 +442,17 @@ var GlodaIndexer = {</span>
<a href="#l19.176"></a><span id="l19.176">           workerDef.recover = null;</span>
<a href="#l19.177"></a><span id="l19.177">         if (!(&quot;cleanup&quot; in workerDef))</span>
<a href="#l19.178"></a><span id="l19.178">           workerDef.cleanup = null;</span>
<a href="#l19.179"></a><span id="l19.179">         if (!(&quot;onSchedule&quot; in workerDef))</span>
<a href="#l19.180"></a><span id="l19.180">           workerDef.onSchedule = null;</span>
<a href="#l19.181"></a><span id="l19.181">         if (!(&quot;jobCanceled&quot; in workerDef))</span>
<a href="#l19.182"></a><span id="l19.182">           workerDef.jobCanceled = null;</span>
<a href="#l19.183"></a><span id="l19.183">       }</span>
<a href="#l19.184"></a><span id="l19.184" class="difflineminus">-    }</span>
<a href="#l19.185"></a><span id="l19.185" class="difflineminus">-    catch (ex) {</span>
<a href="#l19.186"></a><span id="l19.186" class="difflineplus">+    } catch (ex) {</span>
<a href="#l19.187"></a><span id="l19.187">       this._log.warn(&quot;Helper indexer threw exception on worker enum.&quot;);</span>
<a href="#l19.188"></a><span id="l19.188">     }</span>
<a href="#l19.189"></a><span id="l19.189"> </span>
<a href="#l19.190"></a><span id="l19.190">     if (this._enabled) {</span>
<a href="#l19.191"></a><span id="l19.191">       try {</span>
<a href="#l19.192"></a><span id="l19.192">         aIndexer.enable();</span>
<a href="#l19.193"></a><span id="l19.193">       } catch (ex) {</span>
<a href="#l19.194"></a><span id="l19.194">         this._log.warn(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l19.195"></a><span id="l19.195" class="difflineat">@@ -502,35 +489,33 @@ var GlodaIndexer = {</span>
<a href="#l19.196"></a><span id="l19.196">         this.indexing = true;</span>
<a href="#l19.197"></a><span id="l19.197">       }</span>
<a href="#l19.198"></a><span id="l19.198"> </span>
<a href="#l19.199"></a><span id="l19.199">       // if we have not done an initial sweep, schedule scheduling one.</span>
<a href="#l19.200"></a><span id="l19.200">       if (!this._initialSweepPerformed) {</span>
<a href="#l19.201"></a><span id="l19.201">         this._longTimer.initWithCallback(this._scheduleInitialSweep,</span>
<a href="#l19.202"></a><span id="l19.202">           this._INITIAL_SWEEP_DELAY, Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l19.203"></a><span id="l19.203">       }</span>
<a href="#l19.204"></a><span id="l19.204" class="difflineminus">-    }</span>
<a href="#l19.205"></a><span id="l19.205" class="difflineminus">-    else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l19.206"></a><span id="l19.206" class="difflineplus">+    } else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l19.207"></a><span id="l19.207">       for (let indexer of this._indexers) {</span>
<a href="#l19.208"></a><span id="l19.208">         try {</span>
<a href="#l19.209"></a><span id="l19.209">           indexer.disable();</span>
<a href="#l19.210"></a><span id="l19.210">         } catch (ex) {</span>
<a href="#l19.211"></a><span id="l19.211">           this._log.warn(&quot;Helper indexer threw exception on disable: &quot; + ex);</span>
<a href="#l19.212"></a><span id="l19.212">         }</span>
<a href="#l19.213"></a><span id="l19.213">       }</span>
<a href="#l19.214"></a><span id="l19.214"> </span>
<a href="#l19.215"></a><span id="l19.215">       // remove offline observer</span>
<a href="#l19.216"></a><span id="l19.216">       Services.obs.removeObserver(this, &quot;network:offline-status-changed&quot;);</span>
<a href="#l19.217"></a><span id="l19.217"> </span>
<a href="#l19.218"></a><span id="l19.218">       // remove idle</span>
<a href="#l19.219"></a><span id="l19.219">       this._idleService.removeIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l19.220"></a><span id="l19.220"> </span>
<a href="#l19.221"></a><span id="l19.221">       this._enabled = false;</span>
<a href="#l19.222"></a><span id="l19.222">     }</span>
<a href="#l19.223"></a><span id="l19.223" class="difflineminus">-</span>
<a href="#l19.224"></a><span id="l19.224">   },</span>
<a href="#l19.225"></a><span id="l19.225"> </span>
<a href="#l19.226"></a><span id="l19.226">   /** Track whether indexing is desired (we have jobs to prosecute). */</span>
<a href="#l19.227"></a><span id="l19.227">   _indexingDesired: false,</span>
<a href="#l19.228"></a><span id="l19.228">   /**</span>
<a href="#l19.229"></a><span id="l19.229">    * Track whether we have an actively pending callback or timer event.  We do</span>
<a href="#l19.230"></a><span id="l19.230">    *  this so we don't experience a transient suppression and accidentally</span>
<a href="#l19.231"></a><span id="l19.231">    *  get multiple event-chains driving indexing at the same time (which the</span>
<a href="#l19.232"></a><span id="l19.232" class="difflineat">@@ -599,17 +584,17 @@ var GlodaIndexer = {</span>
<a href="#l19.233"></a><span id="l19.233">    * Our timer-driven callback to schedule our first initial indexing sweep.</span>
<a href="#l19.234"></a><span id="l19.234">    *  Because it is invoked by an nsITimer it operates without the benefit of</span>
<a href="#l19.235"></a><span id="l19.235">    *  a 'this' context and must use GlodaIndexer instead of this.</span>
<a href="#l19.236"></a><span id="l19.236">    * Since an initial sweep could have been performed before we get invoked,</span>
<a href="#l19.237"></a><span id="l19.237">    *  we need to check whether an initial sweep is still desired before trying</span>
<a href="#l19.238"></a><span id="l19.238">    *  to schedule one.  We don't need to worry about whether one is active</span>
<a href="#l19.239"></a><span id="l19.239">    *  because the indexingSweepNeeded takes care of that.</span>
<a href="#l19.240"></a><span id="l19.240">    */</span>
<a href="#l19.241"></a><span id="l19.241" class="difflineminus">-  _scheduleInitialSweep: function gloda_index_scheduleInitialSweep() {</span>
<a href="#l19.242"></a><span id="l19.242" class="difflineplus">+  _scheduleInitialSweep() {</span>
<a href="#l19.243"></a><span id="l19.243">     if (GlodaIndexer._initialSweepPerformed)</span>
<a href="#l19.244"></a><span id="l19.244">       return;</span>
<a href="#l19.245"></a><span id="l19.245">     GlodaIndexer._initialSweepPerformed = true;</span>
<a href="#l19.246"></a><span id="l19.246">     for (let indexer of GlodaIndexer._indexers) {</span>
<a href="#l19.247"></a><span id="l19.247">       indexer.initialSweep();</span>
<a href="#l19.248"></a><span id="l19.248">     }</span>
<a href="#l19.249"></a><span id="l19.249">   },</span>
<a href="#l19.250"></a><span id="l19.250"> </span>
<a href="#l19.251"></a><span id="l19.251" class="difflineat">@@ -655,103 +640,101 @@ var GlodaIndexer = {</span>
<a href="#l19.252"></a><span id="l19.252">    *     kIndexer*), the folder name if a folder is involved (string or null),</span>
<a href="#l19.253"></a><span id="l19.253">    *     current zero-based job number (int),</span>
<a href="#l19.254"></a><span id="l19.254">    *     current item number being indexed in this job (int), total number</span>
<a href="#l19.255"></a><span id="l19.255">    *     of items in this job to be indexed (int).</span>
<a href="#l19.256"></a><span id="l19.256">    *</span>
<a href="#l19.257"></a><span id="l19.257">    * @TODO should probably allow for a 'this' value to be provided</span>
<a href="#l19.258"></a><span id="l19.258">    * @TODO generalize to not be folder/message specific.  use nouns!</span>
<a href="#l19.259"></a><span id="l19.259">    */</span>
<a href="#l19.260"></a><span id="l19.260" class="difflineminus">-  addListener: function gloda_index_addListener(aListener) {</span>
<a href="#l19.261"></a><span id="l19.261" class="difflineplus">+  addListener(aListener) {</span>
<a href="#l19.262"></a><span id="l19.262">     // should we weakify?</span>
<a href="#l19.263"></a><span id="l19.263" class="difflineminus">-    if (this._indexListeners.indexOf(aListener) == -1)</span>
<a href="#l19.264"></a><span id="l19.264" class="difflineplus">+    if (!this._indexListeners.includes(aListener))</span>
<a href="#l19.265"></a><span id="l19.265">       this._indexListeners.push(aListener);</span>
<a href="#l19.266"></a><span id="l19.266">     // if we aren't indexing, give them an idle indicator, otherwise they can</span>
<a href="#l19.267"></a><span id="l19.267">     //  just be happy when we hit the next actual status point.</span>
<a href="#l19.268"></a><span id="l19.268">     if (!this.indexing)</span>
<a href="#l19.269"></a><span id="l19.269">       aListener(Gloda.kIndexerIdle, null, 0, 0, 1);</span>
<a href="#l19.270"></a><span id="l19.270">     return aListener;</span>
<a href="#l19.271"></a><span id="l19.271">   },</span>
<a href="#l19.272"></a><span id="l19.272">   /**</span>
<a href="#l19.273"></a><span id="l19.273">    * Remove the given listener so that it no longer receives indexing progress</span>
<a href="#l19.274"></a><span id="l19.274">    *  updates.</span>
<a href="#l19.275"></a><span id="l19.275">    */</span>
<a href="#l19.276"></a><span id="l19.276" class="difflineminus">-  removeListener: function gloda_index_removeListener(aListener) {</span>
<a href="#l19.277"></a><span id="l19.277" class="difflineplus">+  removeListener(aListener) {</span>
<a href="#l19.278"></a><span id="l19.278">     let index = this._indexListeners.indexOf(aListener);</span>
<a href="#l19.279"></a><span id="l19.279">     if (index != -1)</span>
<a href="#l19.280"></a><span id="l19.280">       this._indexListeners.splice(index, 1);</span>
<a href="#l19.281"></a><span id="l19.281">   },</span>
<a href="#l19.282"></a><span id="l19.282">   /**</span>
<a href="#l19.283"></a><span id="l19.283">    * Helper method to tell listeners what we're up to.  For code simplicity,</span>
<a href="#l19.284"></a><span id="l19.284">    *  the caller is just deciding when to send this update (preferably at</span>
<a href="#l19.285"></a><span id="l19.285">    *  reasonable intervals), and doesn't need to provide any indication of</span>
<a href="#l19.286"></a><span id="l19.286">    *  state... we figure that out ourselves.</span>
<a href="#l19.287"></a><span id="l19.287">    *</span>
<a href="#l19.288"></a><span id="l19.288">    * This was not pretty but got ugly once we moved the message indexing out</span>
<a href="#l19.289"></a><span id="l19.289">    *  to its own indexer.  Some generalization is required but will likely</span>
<a href="#l19.290"></a><span id="l19.290">    *  require string hooks.</span>
<a href="#l19.291"></a><span id="l19.291">    */</span>
<a href="#l19.292"></a><span id="l19.292" class="difflineminus">-  _notifyListeners: function gloda_index_notifyListeners() {</span>
<a href="#l19.293"></a><span id="l19.293" class="difflineplus">+  _notifyListeners() {</span>
<a href="#l19.294"></a><span id="l19.294">     let status, prettyName, jobIndex, jobItemIndex, jobItemGoal, jobType;</span>
<a href="#l19.295"></a><span id="l19.295"> </span>
<a href="#l19.296"></a><span id="l19.296">     if (this.indexing &amp;&amp; this._curIndexingJob) {</span>
<a href="#l19.297"></a><span id="l19.297">       let job = this._curIndexingJob;</span>
<a href="#l19.298"></a><span id="l19.298">       status = Gloda.kIndexerIndexing;</span>
<a href="#l19.299"></a><span id="l19.299"> </span>
<a href="#l19.300"></a><span id="l19.300">       let indexer = this._indexerWorkerDefs[job.jobType].indexer;</span>
<a href="#l19.301"></a><span id="l19.301">       if (&quot;_indexingFolder&quot; in indexer)</span>
<a href="#l19.302"></a><span id="l19.302">         prettyName = (indexer._indexingFolder != null) ?</span>
<a href="#l19.303"></a><span id="l19.303">                      indexer._indexingFolder.prettyName : null;</span>
<a href="#l19.304"></a><span id="l19.304">       else</span>
<a href="#l19.305"></a><span id="l19.305">         prettyName = null;</span>
<a href="#l19.306"></a><span id="l19.306"> </span>
<a href="#l19.307"></a><span id="l19.307" class="difflineminus">-      jobIndex = this._indexingJobCount-1;</span>
<a href="#l19.308"></a><span id="l19.308" class="difflineplus">+      jobIndex = this._indexingJobCount - 1;</span>
<a href="#l19.309"></a><span id="l19.309">       jobItemIndex = job.offset;</span>
<a href="#l19.310"></a><span id="l19.310">       jobItemGoal  = job.goal;</span>
<a href="#l19.311"></a><span id="l19.311">       jobType = job.jobType;</span>
<a href="#l19.312"></a><span id="l19.312" class="difflineminus">-    }</span>
<a href="#l19.313"></a><span id="l19.313" class="difflineminus">-    else {</span>
<a href="#l19.314"></a><span id="l19.314" class="difflineplus">+    } else {</span>
<a href="#l19.315"></a><span id="l19.315">       status = Gloda.kIndexerIdle;</span>
<a href="#l19.316"></a><span id="l19.316">       prettyName = null;</span>
<a href="#l19.317"></a><span id="l19.317">       jobIndex = 0;</span>
<a href="#l19.318"></a><span id="l19.318">       jobItemIndex = 0;</span>
<a href="#l19.319"></a><span id="l19.319">       jobItemGoal = 1;</span>
<a href="#l19.320"></a><span id="l19.320">       jobType = null;</span>
<a href="#l19.321"></a><span id="l19.321">     }</span>
<a href="#l19.322"></a><span id="l19.322"> </span>
<a href="#l19.323"></a><span id="l19.323">     // Some people ascribe to the belief that the most you can give is 100%.</span>
<a href="#l19.324"></a><span id="l19.324">     // We know better, but let's humor them.</span>
<a href="#l19.325"></a><span id="l19.325">     if (jobItemIndex &gt; jobItemGoal)</span>
<a href="#l19.326"></a><span id="l19.326">       jobItemGoal = jobItemIndex;</span>
<a href="#l19.327"></a><span id="l19.327"> </span>
<a href="#l19.328"></a><span id="l19.328" class="difflineminus">-    for (let iListener = this._indexListeners.length-1; iListener &gt;= 0;</span>
<a href="#l19.329"></a><span id="l19.329" class="difflineplus">+    for (let iListener = this._indexListeners.length - 1; iListener &gt;= 0;</span>
<a href="#l19.330"></a><span id="l19.330">          iListener--) {</span>
<a href="#l19.331"></a><span id="l19.331">       let listener = this._indexListeners[iListener];</span>
<a href="#l19.332"></a><span id="l19.332">       try {</span>
<a href="#l19.333"></a><span id="l19.333">         listener(status, prettyName, jobIndex, jobItemIndex, jobItemGoal,</span>
<a href="#l19.334"></a><span id="l19.334">                  jobType);</span>
<a href="#l19.335"></a><span id="l19.335" class="difflineminus">-      }</span>
<a href="#l19.336"></a><span id="l19.336" class="difflineminus">-      catch(ex) {</span>
<a href="#l19.337"></a><span id="l19.337" class="difflineplus">+      } catch (ex) {</span>
<a href="#l19.338"></a><span id="l19.338">         this._log.error(ex);</span>
<a href="#l19.339"></a><span id="l19.339">       }</span>
<a href="#l19.340"></a><span id="l19.340">     }</span>
<a href="#l19.341"></a><span id="l19.341">   },</span>
<a href="#l19.342"></a><span id="l19.342"> </span>
<a href="#l19.343"></a><span id="l19.343">   /**</span>
<a href="#l19.344"></a><span id="l19.344">    * A wrapped callback driver intended to be used by timers that provide</span>
<a href="#l19.345"></a><span id="l19.345">    *  arguments we really do not care about.</span>
<a href="#l19.346"></a><span id="l19.346">    */</span>
<a href="#l19.347"></a><span id="l19.347" class="difflineminus">-  _timerCallbackDriver: function gloda_index_timerCallbackDriver() {</span>
<a href="#l19.348"></a><span id="l19.348" class="difflineplus">+  _timerCallbackDriver() {</span>
<a href="#l19.349"></a><span id="l19.349">     GlodaIndexer.callbackDriver();</span>
<a href="#l19.350"></a><span id="l19.350">   },</span>
<a href="#l19.351"></a><span id="l19.351"> </span>
<a href="#l19.352"></a><span id="l19.352">   /**</span>
<a href="#l19.353"></a><span id="l19.353">    * A simple callback driver wrapper to provide 'this'.</span>
<a href="#l19.354"></a><span id="l19.354">    */</span>
<a href="#l19.355"></a><span id="l19.355" class="difflineminus">-  _wrapCallbackDriver: function gloda_index_wrapCallbackDriver(...aArgs) {</span>
<a href="#l19.356"></a><span id="l19.356" class="difflineplus">+  _wrapCallbackDriver(...aArgs) {</span>
<a href="#l19.357"></a><span id="l19.357">     GlodaIndexer.callbackDriver(...aArgs);</span>
<a href="#l19.358"></a><span id="l19.358">   },</span>
<a href="#l19.359"></a><span id="l19.359"> </span>
<a href="#l19.360"></a><span id="l19.360">   /**</span>
<a href="#l19.361"></a><span id="l19.361">    * The current processing 'batch' generator, produced by a call to workBatch()</span>
<a href="#l19.362"></a><span id="l19.362">    *  and used by callbackDriver to drive execution.</span>
<a href="#l19.363"></a><span id="l19.363">    */</span>
<a href="#l19.364"></a><span id="l19.364">   _batch: null,</span>
<a href="#l19.365"></a><span id="l19.365" class="difflineat">@@ -762,17 +745,17 @@ var GlodaIndexer = {</span>
<a href="#l19.366"></a><span id="l19.366">    *  (stored in _batch) which run until they are done (kWorkDone) or they</span>
<a href="#l19.367"></a><span id="l19.367">    *  (really the embedded activeIterator) encounter something asynchronous.</span>
<a href="#l19.368"></a><span id="l19.368">    *  The convention is that all the callback handlers end up calling us,</span>
<a href="#l19.369"></a><span id="l19.369">    *  ensuring that control-flow properly resumes.  If the batch completes,</span>
<a href="#l19.370"></a><span id="l19.370">    *  we re-schedule ourselves after a time delay (controlled by _INDEX_INTERVAL)</span>
<a href="#l19.371"></a><span id="l19.371">    *  and return.  (We use one-shot timers because repeating-slack does not</span>
<a href="#l19.372"></a><span id="l19.372">    *  know enough to deal with our (current) asynchronous nature.)</span>
<a href="#l19.373"></a><span id="l19.373">    */</span>
<a href="#l19.374"></a><span id="l19.374" class="difflineminus">-  callbackDriver: function gloda_index_callbackDriver(...aArgs) {</span>
<a href="#l19.375"></a><span id="l19.375" class="difflineplus">+  callbackDriver(...aArgs) {</span>
<a href="#l19.376"></a><span id="l19.376">     // just bail if we are shutdown</span>
<a href="#l19.377"></a><span id="l19.377">     if (this._indexerIsShutdown)</span>
<a href="#l19.378"></a><span id="l19.378">       return;</span>
<a href="#l19.379"></a><span id="l19.379"> </span>
<a href="#l19.380"></a><span id="l19.380">     // it is conceivable that someone we call will call something that in some</span>
<a href="#l19.381"></a><span id="l19.381">     //  cases might be asynchronous, and in other cases immediately generate</span>
<a href="#l19.382"></a><span id="l19.382">     //  events without returning.  In the interest of (stack-depth) sanity,</span>
<a href="#l19.383"></a><span id="l19.383">     //  let's handle this by performing a minimal time-delay callback.</span>
<a href="#l19.384"></a><span id="l19.384" class="difflineat">@@ -799,19 +782,19 @@ var GlodaIndexer = {</span>
<a href="#l19.385"></a><span id="l19.385">       // On kWorkDone, we want to schedule another timer to fire on us if we are</span>
<a href="#l19.386"></a><span id="l19.386">       //  not done indexing.  (On kWorkAsync, we don't care what happens, because</span>
<a href="#l19.387"></a><span id="l19.387">       //  someone else will be receiving the callback, and they will call us when</span>
<a href="#l19.388"></a><span id="l19.388">       //  they are done doing their thing.</span>
<a href="#l19.389"></a><span id="l19.389">       let args;</span>
<a href="#l19.390"></a><span id="l19.390">       if (this._savedCallbackArgs != null) {</span>
<a href="#l19.391"></a><span id="l19.391">         args = this._savedCallbackArgs;</span>
<a href="#l19.392"></a><span id="l19.392">         this._savedCallbackArgs = null;</span>
<a href="#l19.393"></a><span id="l19.393" class="difflineplus">+      } else {</span>
<a href="#l19.394"></a><span id="l19.394" class="difflineplus">+        args = aArgs;</span>
<a href="#l19.395"></a><span id="l19.395">       }</span>
<a href="#l19.396"></a><span id="l19.396" class="difflineminus">-      else</span>
<a href="#l19.397"></a><span id="l19.397" class="difflineminus">-        args = aArgs;</span>
<a href="#l19.398"></a><span id="l19.398"> </span>
<a href="#l19.399"></a><span id="l19.399">       let result;</span>
<a href="#l19.400"></a><span id="l19.400">       if (args.length == 0)</span>
<a href="#l19.401"></a><span id="l19.401">         result = this._batch.next().value;</span>
<a href="#l19.402"></a><span id="l19.402">       else if (args.length == 1)</span>
<a href="#l19.403"></a><span id="l19.403">         result = this._batch.next(args[0]).value;</span>
<a href="#l19.404"></a><span id="l19.404">       else // arguments works with destructuring assignment</span>
<a href="#l19.405"></a><span id="l19.405">         result = this._batch.next(args).value;</span>
<a href="#l19.406"></a><span id="l19.406" class="difflineat">@@ -819,37 +802,36 @@ var GlodaIndexer = {</span>
<a href="#l19.407"></a><span id="l19.407">         // job's done, close the batch and re-schedule ourselves if there's more</span>
<a href="#l19.408"></a><span id="l19.408">         //  to do.</span>
<a href="#l19.409"></a><span id="l19.409">         case this.kWorkDone:</span>
<a href="#l19.410"></a><span id="l19.410">           this._batch.return();</span>
<a href="#l19.411"></a><span id="l19.411">           this._batch = null;</span>
<a href="#l19.412"></a><span id="l19.412">           // (intentional fall-through to re-scheduling logic)</span>
<a href="#l19.413"></a><span id="l19.413">         // the batch wants to get re-scheduled, do so.</span>
<a href="#l19.414"></a><span id="l19.414">         case this.kWorkPause:</span>
<a href="#l19.415"></a><span id="l19.415" class="difflineminus">-          if (this.indexing)</span>
<a href="#l19.416"></a><span id="l19.416" class="difflineplus">+          if (this.indexing) {</span>
<a href="#l19.417"></a><span id="l19.417">             this._timer.initWithCallback(this._timerCallbackDriver,</span>
<a href="#l19.418"></a><span id="l19.418">                                          this._INDEX_INTERVAL,</span>
<a href="#l19.419"></a><span id="l19.419">                                          Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l19.420"></a><span id="l19.420" class="difflineminus">-          else { // it's important to indicate no more callbacks are in flight</span>
<a href="#l19.421"></a><span id="l19.421" class="difflineplus">+          } else { // it's important to indicate no more callbacks are in flight</span>
<a href="#l19.422"></a><span id="l19.422">             this._indexingActive = false;</span>
<a href="#l19.423"></a><span id="l19.423">           }</span>
<a href="#l19.424"></a><span id="l19.424">           break;</span>
<a href="#l19.425"></a><span id="l19.425">         case this.kWorkAsync:</span>
<a href="#l19.426"></a><span id="l19.426">           // there is nothing to do.  some other code is now responsible for</span>
<a href="#l19.427"></a><span id="l19.427">           //  calling us.</span>
<a href="#l19.428"></a><span id="l19.428">           break;</span>
<a href="#l19.429"></a><span id="l19.429">       }</span>
<a href="#l19.430"></a><span id="l19.430" class="difflineminus">-    }</span>
<a href="#l19.431"></a><span id="l19.431" class="difflineminus">-    finally {</span>
<a href="#l19.432"></a><span id="l19.432" class="difflineplus">+    } finally {</span>
<a href="#l19.433"></a><span id="l19.433">       this._inCallback = false;</span>
<a href="#l19.434"></a><span id="l19.434">     }</span>
<a href="#l19.435"></a><span id="l19.435">   },</span>
<a href="#l19.436"></a><span id="l19.436"> </span>
<a href="#l19.437"></a><span id="l19.437">   _callbackHandle: {</span>
<a href="#l19.438"></a><span id="l19.438" class="difflineminus">-    init: function gloda_index_callbackhandle_init() {</span>
<a href="#l19.439"></a><span id="l19.439" class="difflineplus">+    init() {</span>
<a href="#l19.440"></a><span id="l19.440">       this.wrappedCallback = GlodaIndexer._wrapCallbackDriver;</span>
<a href="#l19.441"></a><span id="l19.441">       this.callbackThis = GlodaIndexer;</span>
<a href="#l19.442"></a><span id="l19.442">       this.callback = GlodaIndexer.callbackDriver;</span>
<a href="#l19.443"></a><span id="l19.443">     },</span>
<a href="#l19.444"></a><span id="l19.444">     /**</span>
<a href="#l19.445"></a><span id="l19.445">      * The stack of generators we are processing.  The (numerically) last one is</span>
<a href="#l19.446"></a><span id="l19.446">      *  also the |activeIterator|.</span>
<a href="#l19.447"></a><span id="l19.447">      */</span>
<a href="#l19.448"></a><span id="l19.448" class="difflineat">@@ -861,108 +843,107 @@ var GlodaIndexer = {</span>
<a href="#l19.449"></a><span id="l19.449">     activeIterator: null,</span>
<a href="#l19.450"></a><span id="l19.450">     /**</span>
<a href="#l19.451"></a><span id="l19.451">      * Meta-information about the generators at each level of the stack.</span>
<a href="#l19.452"></a><span id="l19.452">      */</span>
<a href="#l19.453"></a><span id="l19.453">     contextStack: [],</span>
<a href="#l19.454"></a><span id="l19.454">     /**</span>
<a href="#l19.455"></a><span id="l19.455">      * Push a new generator onto the stack.  It becomes the active generator.</span>
<a href="#l19.456"></a><span id="l19.456">      */</span>
<a href="#l19.457"></a><span id="l19.457" class="difflineminus">-    push: function gloda_index_callbackhandle_push(aIterator, aContext) {</span>
<a href="#l19.458"></a><span id="l19.458" class="difflineplus">+    push(aIterator, aContext) {</span>
<a href="#l19.459"></a><span id="l19.459">       this.activeStack.push(aIterator);</span>
<a href="#l19.460"></a><span id="l19.460">       this.contextStack.push(aContext);</span>
<a href="#l19.461"></a><span id="l19.461">       this.activeIterator = aIterator;</span>
<a href="#l19.462"></a><span id="l19.462">     },</span>
<a href="#l19.463"></a><span id="l19.463">     /**</span>
<a href="#l19.464"></a><span id="l19.464">      * For use by generators that want to call another asynchronous process</span>
<a href="#l19.465"></a><span id="l19.465">      *  implemented as a generator.  They should do</span>
<a href="#l19.466"></a><span id="l19.466">      *  &quot;yield aCallbackHandle.pushAndGo(someGenerator(arg1, arg2));&quot;.</span>
<a href="#l19.467"></a><span id="l19.467">      *</span>
<a href="#l19.468"></a><span id="l19.468">      * @public</span>
<a href="#l19.469"></a><span id="l19.469">      */</span>
<a href="#l19.470"></a><span id="l19.470" class="difflineminus">-    pushAndGo: function gloda_index_callbackhandle_pushAndGo(aIterator,</span>
<a href="#l19.471"></a><span id="l19.471" class="difflineminus">-                                                             aContext) {</span>
<a href="#l19.472"></a><span id="l19.472" class="difflineplus">+    pushAndGo(aIterator, aContext) {</span>
<a href="#l19.473"></a><span id="l19.473">       this.push(aIterator, aContext);</span>
<a href="#l19.474"></a><span id="l19.474">       return GlodaIndexer.kWorkSync;</span>
<a href="#l19.475"></a><span id="l19.475">     },</span>
<a href="#l19.476"></a><span id="l19.476">     /**</span>
<a href="#l19.477"></a><span id="l19.477">      * Pop the active generator off the stack.</span>
<a href="#l19.478"></a><span id="l19.478">      */</span>
<a href="#l19.479"></a><span id="l19.479" class="difflineminus">-    pop: function gloda_index_callbackhandle_pop() {</span>
<a href="#l19.480"></a><span id="l19.480" class="difflineplus">+    pop() {</span>
<a href="#l19.481"></a><span id="l19.481">       this.activeIterator.return();</span>
<a href="#l19.482"></a><span id="l19.482">       this.activeStack.pop();</span>
<a href="#l19.483"></a><span id="l19.483">       this.contextStack.pop();</span>
<a href="#l19.484"></a><span id="l19.484">       if (this.activeStack.length)</span>
<a href="#l19.485"></a><span id="l19.485">         this.activeIterator = this.activeStack[this.activeStack.length - 1];</span>
<a href="#l19.486"></a><span id="l19.486">       else</span>
<a href="#l19.487"></a><span id="l19.487">         this.activeIterator = null;</span>
<a href="#l19.488"></a><span id="l19.488">     },</span>
<a href="#l19.489"></a><span id="l19.489">     /**</span>
<a href="#l19.490"></a><span id="l19.490">      * Someone propagated an exception and we need to clean-up all the active</span>
<a href="#l19.491"></a><span id="l19.491">      *  logic as best we can.  Which is not really all that well.</span>
<a href="#l19.492"></a><span id="l19.492">      *</span>
<a href="#l19.493"></a><span id="l19.493">      * @param [aOptionalStopAtDepth=0] The length the stack should be when this</span>
<a href="#l19.494"></a><span id="l19.494">      *     method completes.  Pass 0 or omit for us to clear everything out.</span>
<a href="#l19.495"></a><span id="l19.495">      *     Pass 1 to leave just the top-level generator intact.</span>
<a href="#l19.496"></a><span id="l19.496">      */</span>
<a href="#l19.497"></a><span id="l19.497" class="difflineminus">-    cleanup: function gloda_index_callbackhandle_cleanup(aOptionalStopAtDepth) {</span>
<a href="#l19.498"></a><span id="l19.498" class="difflineplus">+    cleanup(aOptionalStopAtDepth) {</span>
<a href="#l19.499"></a><span id="l19.499">       if (aOptionalStopAtDepth === undefined)</span>
<a href="#l19.500"></a><span id="l19.500">         aOptionalStopAtDepth = 0;</span>
<a href="#l19.501"></a><span id="l19.501">       while (this.activeStack.length &gt; aOptionalStopAtDepth) {</span>
<a href="#l19.502"></a><span id="l19.502">         this.pop();</span>
<a href="#l19.503"></a><span id="l19.503">       }</span>
<a href="#l19.504"></a><span id="l19.504">     },</span>
<a href="#l19.505"></a><span id="l19.505">     /**</span>
<a href="#l19.506"></a><span id="l19.506">      * For use when a generator finishes up by calling |doneWithResult| on us;</span>
<a href="#l19.507"></a><span id="l19.507">      *  the async driver calls this to pop that generator off the stack</span>
<a href="#l19.508"></a><span id="l19.508">      *  and get the result it passed in to its call to |doneWithResult|.</span>
<a href="#l19.509"></a><span id="l19.509">      *</span>
<a href="#l19.510"></a><span id="l19.510">      * @protected</span>
<a href="#l19.511"></a><span id="l19.511">      */</span>
<a href="#l19.512"></a><span id="l19.512" class="difflineminus">-    popWithResult: function gloda_index_callbackhandle_popWithResult() {</span>
<a href="#l19.513"></a><span id="l19.513" class="difflineplus">+    popWithResult() {</span>
<a href="#l19.514"></a><span id="l19.514">       this.pop();</span>
<a href="#l19.515"></a><span id="l19.515">       let result = this._result;</span>
<a href="#l19.516"></a><span id="l19.516">       this._result = null;</span>
<a href="#l19.517"></a><span id="l19.517">       return result;</span>
<a href="#l19.518"></a><span id="l19.518">     },</span>
<a href="#l19.519"></a><span id="l19.519">     _result: null,</span>
<a href="#l19.520"></a><span id="l19.520">     /**</span>
<a href="#l19.521"></a><span id="l19.521">      * For use by generators that want to return a result to the calling</span>
<a href="#l19.522"></a><span id="l19.522">      *  asynchronous generator.  Specifically, they should do</span>
<a href="#l19.523"></a><span id="l19.523">      *  &quot;yield aCallbackHandle.doneWithResult(RESULT);&quot;.</span>
<a href="#l19.524"></a><span id="l19.524">      *</span>
<a href="#l19.525"></a><span id="l19.525">      * @public</span>
<a href="#l19.526"></a><span id="l19.526">      */</span>
<a href="#l19.527"></a><span id="l19.527" class="difflineminus">-    doneWithResult: function gloda_index_callbackhandle_doneWithResult(aResult){</span>
<a href="#l19.528"></a><span id="l19.528" class="difflineplus">+    doneWithResult(aResult) {</span>
<a href="#l19.529"></a><span id="l19.529">       this._result = aResult;</span>
<a href="#l19.530"></a><span id="l19.530">       return Gloda.kWorkDoneWithResult;</span>
<a href="#l19.531"></a><span id="l19.531">     },</span>
<a href="#l19.532"></a><span id="l19.532"> </span>
<a href="#l19.533"></a><span id="l19.533">     /* be able to serve as a collection listener, resuming the active iterator's</span>
<a href="#l19.534"></a><span id="l19.534">        last yield kWorkAsync */</span>
<a href="#l19.535"></a><span id="l19.535" class="difflineminus">-    onItemsAdded: function() {},</span>
<a href="#l19.536"></a><span id="l19.536" class="difflineminus">-    onItemsModified: function() {},</span>
<a href="#l19.537"></a><span id="l19.537" class="difflineminus">-    onItemsRemoved: function() {},</span>
<a href="#l19.538"></a><span id="l19.538" class="difflineminus">-    onQueryCompleted: function(aCollection) {</span>
<a href="#l19.539"></a><span id="l19.539" class="difflineplus">+    onItemsAdded() {},</span>
<a href="#l19.540"></a><span id="l19.540" class="difflineplus">+    onItemsModified() {},</span>
<a href="#l19.541"></a><span id="l19.541" class="difflineplus">+    onItemsRemoved() {},</span>
<a href="#l19.542"></a><span id="l19.542" class="difflineplus">+    onQueryCompleted(aCollection) {</span>
<a href="#l19.543"></a><span id="l19.543">       GlodaIndexer.callbackDriver();</span>
<a href="#l19.544"></a><span id="l19.544" class="difflineminus">-    }</span>
<a href="#l19.545"></a><span id="l19.545" class="difflineplus">+    },</span>
<a href="#l19.546"></a><span id="l19.546">   },</span>
<a href="#l19.547"></a><span id="l19.547">   _workBatchData: undefined,</span>
<a href="#l19.548"></a><span id="l19.548" class="difflineplus">+  /* eslint-disable complexity */</span>
<a href="#l19.549"></a><span id="l19.549">   /**</span>
<a href="#l19.550"></a><span id="l19.550">    * The workBatch generator handles a single 'batch' of processing, managing</span>
<a href="#l19.551"></a><span id="l19.551">    *  the database transaction and keeping track of &quot;tokens&quot;.  It drives the</span>
<a href="#l19.552"></a><span id="l19.552">    *  activeIterator generator which is doing the work.</span>
<a href="#l19.553"></a><span id="l19.553">    * workBatch will only produce kWorkAsync, kWorkPause, and kWorkDone</span>
<a href="#l19.554"></a><span id="l19.554">    *  notifications.  If activeIterator returns kWorkSync and there are still</span>
<a href="#l19.555"></a><span id="l19.555">    *  tokens available, workBatch will keep driving the activeIterator until it</span>
<a href="#l19.556"></a><span id="l19.556">    *  encounters a kWorkAsync (which workBatch will yield to callbackDriver), or</span>
<a href="#l19.557"></a><span id="l19.557">    *  it runs out of tokens and yields a kWorkPause or kWorkDone.</span>
<a href="#l19.558"></a><span id="l19.558">    */</span>
<a href="#l19.559"></a><span id="l19.559" class="difflineminus">-  workBatch: function* gloda_index_workBatch() {</span>
<a href="#l19.560"></a><span id="l19.560" class="difflineminus">-</span>
<a href="#l19.561"></a><span id="l19.561" class="difflineplus">+  * workBatch() {</span>
<a href="#l19.562"></a><span id="l19.562">     // Do we still have an open transaction? If not, start a new one.</span>
<a href="#l19.563"></a><span id="l19.563">     if (!this._idleToCommit)</span>
<a href="#l19.564"></a><span id="l19.564">       GlodaDatastore._beginTransaction();</span>
<a href="#l19.565"></a><span id="l19.565">     else</span>
<a href="#l19.566"></a><span id="l19.566">       // We'll manage commit ourself while this routine is active.</span>
<a href="#l19.567"></a><span id="l19.567">       this._idleToCommit = false;</span>
<a href="#l19.568"></a><span id="l19.568"> </span>
<a href="#l19.569"></a><span id="l19.569">     this._perfIndexStopwatch.start();</span>
<a href="#l19.570"></a><span id="l19.570" class="difflineat">@@ -1030,30 +1011,28 @@ var GlodaIndexer = {</span>
<a href="#l19.571"></a><span id="l19.571">               this._workBatchData = undefined;</span>
<a href="#l19.572"></a><span id="l19.572">               break;</span>
<a href="#l19.573"></a><span id="l19.573">             case this.kWorkDoneWithResult:</span>
<a href="#l19.574"></a><span id="l19.574">               this._workBatchData = this._callbackHandle.popWithResult();</span>
<a href="#l19.575"></a><span id="l19.575">               break;</span>
<a href="#l19.576"></a><span id="l19.576">             default:</span>
<a href="#l19.577"></a><span id="l19.577">               break;</span>
<a href="#l19.578"></a><span id="l19.578">           }</span>
<a href="#l19.579"></a><span id="l19.579" class="difflineminus">-        }</span>
<a href="#l19.580"></a><span id="l19.580" class="difflineminus">-        catch (ex) {</span>
<a href="#l19.581"></a><span id="l19.581" class="difflineplus">+        } catch (ex) {</span>
<a href="#l19.582"></a><span id="l19.582">           this._log.debug(&quot;Exception in batch processing:&quot;, ex);</span>
<a href="#l19.583"></a><span id="l19.583">           let workerDef = this._curIndexingJob._workerDef;</span>
<a href="#l19.584"></a><span id="l19.584">           if (workerDef.recover) {</span>
<a href="#l19.585"></a><span id="l19.585">             let recoverToDepth;</span>
<a href="#l19.586"></a><span id="l19.586">             try {</span>
<a href="#l19.587"></a><span id="l19.587">               recoverToDepth =</span>
<a href="#l19.588"></a><span id="l19.588">               workerDef.recover.call(workerDef.indexer,</span>
<a href="#l19.589"></a><span id="l19.589">                                      this._curIndexingJob,</span>
<a href="#l19.590"></a><span id="l19.590">                                        this._callbackHandle.contextStack,</span>
<a href="#l19.591"></a><span id="l19.591">                                        ex);</span>
<a href="#l19.592"></a><span id="l19.592" class="difflineminus">-            }</span>
<a href="#l19.593"></a><span id="l19.593" class="difflineminus">-            catch (ex2) {</span>
<a href="#l19.594"></a><span id="l19.594" class="difflineplus">+            } catch (ex2) {</span>
<a href="#l19.595"></a><span id="l19.595">               this._log.error(&quot;Worker '&quot; + workerDef.name +</span>
<a href="#l19.596"></a><span id="l19.596">                               &quot;' recovery function itself failed:&quot;, ex2);</span>
<a href="#l19.597"></a><span id="l19.597">             }</span>
<a href="#l19.598"></a><span id="l19.598">             if (this._unitTestHookRecover)</span>
<a href="#l19.599"></a><span id="l19.599">               this._unitTestHookRecover(recoverToDepth, ex,</span>
<a href="#l19.600"></a><span id="l19.600">                                         this._curIndexingJob,</span>
<a href="#l19.601"></a><span id="l19.601">                                         this._callbackHandle);</span>
<a href="#l19.602"></a><span id="l19.602"> </span>
<a href="#l19.603"></a><span id="l19.603" class="difflineat">@@ -1062,29 +1041,26 @@ var GlodaIndexer = {</span>
<a href="#l19.604"></a><span id="l19.604">               continue;</span>
<a href="#l19.605"></a><span id="l19.605">             }</span>
<a href="#l19.606"></a><span id="l19.606">           }</span>
<a href="#l19.607"></a><span id="l19.607">           // (we either did not have a recover handler or it couldn't recover)</span>
<a href="#l19.608"></a><span id="l19.608">           // call the cleanup helper if there is one</span>
<a href="#l19.609"></a><span id="l19.609">           if (workerDef.cleanup) {</span>
<a href="#l19.610"></a><span id="l19.610">             try {</span>
<a href="#l19.611"></a><span id="l19.611">             workerDef.cleanup.call(workerDef.indexer, this._curIndexingJob);</span>
<a href="#l19.612"></a><span id="l19.612" class="difflineminus">-            }</span>
<a href="#l19.613"></a><span id="l19.613" class="difflineminus">-            catch (ex2) {</span>
<a href="#l19.614"></a><span id="l19.614" class="difflineplus">+            } catch (ex2) {</span>
<a href="#l19.615"></a><span id="l19.615">               this._log.error(&quot;Worker '&quot; + workerDef.name +</span>
<a href="#l19.616"></a><span id="l19.616">                               &quot;' cleanup function itself failed:&quot;, ex2);</span>
<a href="#l19.617"></a><span id="l19.617">             }</span>
<a href="#l19.618"></a><span id="l19.618">             if (this._unitTestHookCleanup)</span>
<a href="#l19.619"></a><span id="l19.619">               this._unitTestHookCleanup(true, ex, this._curIndexingJob,</span>
<a href="#l19.620"></a><span id="l19.620">                                         this._callbackHandle);</span>
<a href="#l19.621"></a><span id="l19.621" class="difflineminus">-          }</span>
<a href="#l19.622"></a><span id="l19.622" class="difflineminus">-          else {</span>
<a href="#l19.623"></a><span id="l19.623" class="difflineminus">-            if (this._unitTestHookCleanup)</span>
<a href="#l19.624"></a><span id="l19.624" class="difflineminus">-              this._unitTestHookCleanup(false, ex, this._curIndexingJob,</span>
<a href="#l19.625"></a><span id="l19.625" class="difflineminus">-                                        this._callbackHandle);</span>
<a href="#l19.626"></a><span id="l19.626" class="difflineplus">+          } else if (this._unitTestHookCleanup) {</span>
<a href="#l19.627"></a><span id="l19.627" class="difflineplus">+            this._unitTestHookCleanup(false, ex, this._curIndexingJob,</span>
<a href="#l19.628"></a><span id="l19.628" class="difflineplus">+                                      this._callbackHandle);</span>
<a href="#l19.629"></a><span id="l19.629">           }</span>
<a href="#l19.630"></a><span id="l19.630"> </span>
<a href="#l19.631"></a><span id="l19.631">           // Clean out everything on the async stack, warn about the job, kill.</span>
<a href="#l19.632"></a><span id="l19.632">           // We do not log this warning lightly; it will break unit tests and</span>
<a href="#l19.633"></a><span id="l19.633">           //  be visible to users.  Anything expected should likely have a</span>
<a href="#l19.634"></a><span id="l19.634">           //  recovery function or the cleanup logic should be extended to</span>
<a href="#l19.635"></a><span id="l19.635">           //  indicate that the failure is acceptable.</span>
<a href="#l19.636"></a><span id="l19.636">           this._callbackHandle.cleanup();</span>
<a href="#l19.637"></a><span id="l19.637" class="difflineat">@@ -1101,23 +1077,21 @@ var GlodaIndexer = {</span>
<a href="#l19.638"></a><span id="l19.638">       //  X session without the relevant extensions available.  In this case</span>
<a href="#l19.639"></a><span id="l19.639">       //  we assume that the user is never idle.</span>
<a href="#l19.640"></a><span id="l19.640">       try {</span>
<a href="#l19.641"></a><span id="l19.641">         // We want to stop ASAP when leaving idle, so we can't rely on the</span>
<a href="#l19.642"></a><span id="l19.642">         // standard polled callback. We do the polling ourselves.</span>
<a href="#l19.643"></a><span id="l19.643">         if (this._idleService.idleTime &lt; this._INDEX_IDLE_ADJUSTMENT_TIME) {</span>
<a href="#l19.644"></a><span id="l19.644">           inIdle = false;</span>
<a href="#l19.645"></a><span id="l19.645">           this._cpuTargetIndexTime = this._CPU_TARGET_INDEX_TIME_ACTIVE;</span>
<a href="#l19.646"></a><span id="l19.646" class="difflineminus">-        }</span>
<a href="#l19.647"></a><span id="l19.647" class="difflineminus">-        else {</span>
<a href="#l19.648"></a><span id="l19.648" class="difflineplus">+        } else {</span>
<a href="#l19.649"></a><span id="l19.649">           inIdle = true;</span>
<a href="#l19.650"></a><span id="l19.650">           this._cpuTargetIndexTime = this._CPU_TARGET_INDEX_TIME_IDLE;</span>
<a href="#l19.651"></a><span id="l19.651">         }</span>
<a href="#l19.652"></a><span id="l19.652" class="difflineminus">-      }</span>
<a href="#l19.653"></a><span id="l19.653" class="difflineminus">-      catch (ex) {</span>
<a href="#l19.654"></a><span id="l19.654" class="difflineplus">+      } catch (ex) {</span>
<a href="#l19.655"></a><span id="l19.655">         inIdle = false;</span>
<a href="#l19.656"></a><span id="l19.656">       }</span>
<a href="#l19.657"></a><span id="l19.657"> </span>
<a href="#l19.658"></a><span id="l19.658">       // take a breather by having the caller re-schedule us sometime in the</span>
<a href="#l19.659"></a><span id="l19.659">       //  future, but only if we're going to perform another loop iteration.</span>
<a href="#l19.660"></a><span id="l19.660">       if (haveMoreWork) {</span>
<a href="#l19.661"></a><span id="l19.661">         notifyDecimator = (notifyDecimator + 1) % 32;</span>
<a href="#l19.662"></a><span id="l19.662">         if (!notifyDecimator)</span>
<a href="#l19.663"></a><span id="l19.663" class="difflineat">@@ -1142,18 +1116,18 @@ var GlodaIndexer = {</span>
<a href="#l19.664"></a><span id="l19.664">             break;</span>
<a href="#l19.665"></a><span id="l19.665">         }</span>
<a href="#l19.666"></a><span id="l19.666">       }</span>
<a href="#l19.667"></a><span id="l19.667"> </span>
<a href="#l19.668"></a><span id="l19.668">       // All pauses have been taken, how effective were we? Report!</span>
<a href="#l19.669"></a><span id="l19.669">       // XXX: there's possibly a lot of fluctuation since we go through here</span>
<a href="#l19.670"></a><span id="l19.670">       // every 5 messages or even less</span>
<a href="#l19.671"></a><span id="l19.671">       if (this._indexedMessageCount &gt; 0) {</span>
<a href="#l19.672"></a><span id="l19.672" class="difflineminus">-        let delta = (Date.now() - t0)/1000; // in seconds</span>
<a href="#l19.673"></a><span id="l19.673" class="difflineminus">-        let v = Math.round(this._indexedMessageCount/delta);</span>
<a href="#l19.674"></a><span id="l19.674" class="difflineplus">+        let delta = (Date.now() - t0) / 1000; // in seconds</span>
<a href="#l19.675"></a><span id="l19.675" class="difflineplus">+        let v = Math.round(this._indexedMessageCount / delta);</span>
<a href="#l19.676"></a><span id="l19.676">         try {</span>
<a href="#l19.677"></a><span id="l19.677">           let h = Services.telemetry</span>
<a href="#l19.678"></a><span id="l19.678">             .getHistogramById(&quot;THUNDERBIRD_INDEXING_RATE_MSG_PER_S&quot;);</span>
<a href="#l19.679"></a><span id="l19.679">           h.add(v);</span>
<a href="#l19.680"></a><span id="l19.680">         } catch (e) {</span>
<a href="#l19.681"></a><span id="l19.681">           this._log.warn(&quot;Couldn't report telemetry&quot;, e, v);</span>
<a href="#l19.682"></a><span id="l19.682">         }</span>
<a href="#l19.683"></a><span id="l19.683">       }</span>
<a href="#l19.684"></a><span id="l19.684" class="difflineat">@@ -1215,33 +1189,34 @@ var GlodaIndexer = {</span>
<a href="#l19.685"></a><span id="l19.685"> </span>
<a href="#l19.686"></a><span id="l19.686">     // If we still have a transaction to commit, tell idle to do the commit</span>
<a href="#l19.687"></a><span id="l19.687">     //  when it gets around to it.</span>
<a href="#l19.688"></a><span id="l19.688">     if (transactionToCommit)</span>
<a href="#l19.689"></a><span id="l19.689">       this._idleToCommit = true;</span>
<a href="#l19.690"></a><span id="l19.690"> </span>
<a href="#l19.691"></a><span id="l19.691">     yield this.kWorkDone;</span>
<a href="#l19.692"></a><span id="l19.692">   },</span>
<a href="#l19.693"></a><span id="l19.693" class="difflineplus">+  /* eslint-enable complexity */</span>
<a href="#l19.694"></a><span id="l19.694"> </span>
<a href="#l19.695"></a><span id="l19.695">   /**</span>
<a href="#l19.696"></a><span id="l19.696">    * Maps indexing job type names to a worker definition.</span>
<a href="#l19.697"></a><span id="l19.697">    * The worker definition is an object with the following attributes where</span>
<a href="#l19.698"></a><span id="l19.698">    *  only worker is required:</span>
<a href="#l19.699"></a><span id="l19.699">    * - worker:</span>
<a href="#l19.700"></a><span id="l19.700">    * - onSchedule: A function to be invoked when the worker is scheduled.  The</span>
<a href="#l19.701"></a><span id="l19.701">    *    job is passed as an argument.</span>
<a href="#l19.702"></a><span id="l19.702">    * - recover:</span>
<a href="#l19.703"></a><span id="l19.703">    * - cleanup:</span>
<a href="#l19.704"></a><span id="l19.704">    */</span>
<a href="#l19.705"></a><span id="l19.705">   _indexerWorkerDefs: {},</span>
<a href="#l19.706"></a><span id="l19.706">   /**</span>
<a href="#l19.707"></a><span id="l19.707">    * Perform the initialization step and return a generator if there is any</span>
<a href="#l19.708"></a><span id="l19.708">    *  steady-state processing to be had.</span>
<a href="#l19.709"></a><span id="l19.709">    */</span>
<a href="#l19.710"></a><span id="l19.710" class="difflineminus">-  _hireJobWorker: function gloda_index_hireJobWorker() {</span>
<a href="#l19.711"></a><span id="l19.711" class="difflineplus">+  _hireJobWorker() {</span>
<a href="#l19.712"></a><span id="l19.712">     // In no circumstances should there be data bouncing around from previous</span>
<a href="#l19.713"></a><span id="l19.713">     //  calls if we are here.  |killActiveJob| depends on this.</span>
<a href="#l19.714"></a><span id="l19.714">     this._workBatchData = undefined;</span>
<a href="#l19.715"></a><span id="l19.715"> </span>
<a href="#l19.716"></a><span id="l19.716">     if (this._indexQueue.length == 0) {</span>
<a href="#l19.717"></a><span id="l19.717">       this._log.info(&quot;--- Done indexing, disabling timer renewal.&quot;);</span>
<a href="#l19.718"></a><span id="l19.718"> </span>
<a href="#l19.719"></a><span id="l19.719">       this._curIndexingJob = null;</span>
<a href="#l19.720"></a><span id="l19.720" class="difflineat">@@ -1264,41 +1239,39 @@ var GlodaIndexer = {</span>
<a href="#l19.721"></a><span id="l19.721">       //  initial use case is event-driven message indexing that accumulates</span>
<a href="#l19.722"></a><span id="l19.722">       //  a list of messages to index but wants it locked down once we start</span>
<a href="#l19.723"></a><span id="l19.723">       //  processing the list.</span>
<a href="#l19.724"></a><span id="l19.724">       if (workerDef.onSchedule)</span>
<a href="#l19.725"></a><span id="l19.725">         workerDef.onSchedule.call(workerDef.indexer, job);</span>
<a href="#l19.726"></a><span id="l19.726"> </span>
<a href="#l19.727"></a><span id="l19.727">       generator = workerDef.worker.call(workerDef.indexer, job,</span>
<a href="#l19.728"></a><span id="l19.728">                                         this._callbackHandle);</span>
<a href="#l19.729"></a><span id="l19.729" class="difflineminus">-    }</span>
<a href="#l19.730"></a><span id="l19.730" class="difflineminus">-    else {</span>
<a href="#l19.731"></a><span id="l19.731" class="difflineplus">+    } else {</span>
<a href="#l19.732"></a><span id="l19.732">       // Nothing we can do about this.  Be loud about it and try to schedule</span>
<a href="#l19.733"></a><span id="l19.733">       //  something else.</span>
<a href="#l19.734"></a><span id="l19.734">       this._log.error(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l19.735"></a><span id="l19.735">       return this._hireJobWorker();</span>
<a href="#l19.736"></a><span id="l19.736">     }</span>
<a href="#l19.737"></a><span id="l19.737"> </span>
<a href="#l19.738"></a><span id="l19.738">     if (this._unitTestSuperVerbose)</span>
<a href="#l19.739"></a><span id="l19.739">       this._log.debug(&quot;Hired job of type: &quot; + job.jobType);</span>
<a href="#l19.740"></a><span id="l19.740"> </span>
<a href="#l19.741"></a><span id="l19.741">     this._notifyListeners();</span>
<a href="#l19.742"></a><span id="l19.742"> </span>
<a href="#l19.743"></a><span id="l19.743">     if (generator) {</span>
<a href="#l19.744"></a><span id="l19.744">       this._callbackHandle.push(generator);</span>
<a href="#l19.745"></a><span id="l19.745">       return true;</span>
<a href="#l19.746"></a><span id="l19.746">     }</span>
<a href="#l19.747"></a><span id="l19.747" class="difflineminus">-    else</span>
<a href="#l19.748"></a><span id="l19.748" class="difflineminus">-      return false;</span>
<a href="#l19.749"></a><span id="l19.749" class="difflineplus">+    return false;</span>
<a href="#l19.750"></a><span id="l19.750">   },</span>
<a href="#l19.751"></a><span id="l19.751"> </span>
<a href="#l19.752"></a><span id="l19.752">   /**</span>
<a href="#l19.753"></a><span id="l19.753">    * Schedule a job for indexing.</span>
<a href="#l19.754"></a><span id="l19.754">    */</span>
<a href="#l19.755"></a><span id="l19.755" class="difflineminus">-  indexJob: function glodaIndexJob(aJob) {</span>
<a href="#l19.756"></a><span id="l19.756" class="difflineplus">+  indexJob(aJob) {</span>
<a href="#l19.757"></a><span id="l19.757">     this._log.info(&quot;Queue-ing job for indexing: &quot; + aJob.jobType);</span>
<a href="#l19.758"></a><span id="l19.758"> </span>
<a href="#l19.759"></a><span id="l19.759">     this._indexQueue.push(aJob);</span>
<a href="#l19.760"></a><span id="l19.760">     this.indexing = true;</span>
<a href="#l19.761"></a><span id="l19.761">   },</span>
<a href="#l19.762"></a><span id="l19.762"> </span>
<a href="#l19.763"></a><span id="l19.763">   /**</span>
<a href="#l19.764"></a><span id="l19.764">    * Kill the active job.  This means a few things:</span>
<a href="#l19.765"></a><span id="l19.765" class="difflineat">@@ -1313,27 +1286,27 @@ var GlodaIndexer = {</span>
<a href="#l19.766"></a><span id="l19.766">    *  The only issue is to make sure that _workBatchData does not end up with</span>
<a href="#l19.767"></a><span id="l19.767">    *  the data.  We compel |_hireJobWorker| to erase it to this end.</span>
<a href="#l19.768"></a><span id="l19.768">    *</span>
<a href="#l19.769"></a><span id="l19.769">    * @note You MUST NOT call this function from inside a job or an async function</span>
<a href="#l19.770"></a><span id="l19.770">    *    on the callbackHandle's stack of generators.  If you are in that</span>
<a href="#l19.771"></a><span id="l19.771">    *    situation, you should just throw an exception.  At the very least,</span>
<a href="#l19.772"></a><span id="l19.772">    *    use a timeout to trigger us.</span>
<a href="#l19.773"></a><span id="l19.773">    */</span>
<a href="#l19.774"></a><span id="l19.774" class="difflineminus">-  killActiveJob: function() {</span>
<a href="#l19.775"></a><span id="l19.775" class="difflineplus">+  killActiveJob() {</span>
<a href="#l19.776"></a><span id="l19.776">     // There is nothing to do if we have no job</span>
<a href="#l19.777"></a><span id="l19.777">     if (!this._curIndexingJob)</span>
<a href="#l19.778"></a><span id="l19.778">       return;</span>
<a href="#l19.779"></a><span id="l19.779"> </span>
<a href="#l19.780"></a><span id="l19.780">     // -- Blow away the stack with cleanup.</span>
<a href="#l19.781"></a><span id="l19.781">     let workerDef = this._curIndexingJob._workerDef;</span>
<a href="#l19.782"></a><span id="l19.782">     if (this._unitTestSuperVerbose)</span>
<a href="#l19.783"></a><span id="l19.783">       this._log.debug(&quot;Killing job of type: &quot; + this._curIndexingJob.jobType);</span>
<a href="#l19.784"></a><span id="l19.784">     if (this._unitTestHookCleanup)</span>
<a href="#l19.785"></a><span id="l19.785" class="difflineminus">-      this._unitTestHookCleanup(workerDef.cleanup ? true : false,</span>
<a href="#l19.786"></a><span id="l19.786" class="difflineplus">+      this._unitTestHookCleanup(!!workerDef.cleanup,</span>
<a href="#l19.787"></a><span id="l19.787">                                 &quot;no exception, this was killActiveJob&quot;,</span>
<a href="#l19.788"></a><span id="l19.788">                                 this._curIndexingJob,</span>
<a href="#l19.789"></a><span id="l19.789">                                 this._callbackHandle);</span>
<a href="#l19.790"></a><span id="l19.790">     this._callbackHandle.cleanup();</span>
<a href="#l19.791"></a><span id="l19.791">     if (workerDef.cleanup)</span>
<a href="#l19.792"></a><span id="l19.792">       workerDef.cleanup.call(workerDef.indexer, this._curIndexingJob);</span>
<a href="#l19.793"></a><span id="l19.793"> </span>
<a href="#l19.794"></a><span id="l19.794">     // Eliminate the job.</span>
<a href="#l19.795"></a><span id="l19.795" class="difflineat">@@ -1345,17 +1318,17 @@ var GlodaIndexer = {</span>
<a href="#l19.796"></a><span id="l19.796">    *  kill the active job, use |killActiveJob| to do that.</span>
<a href="#l19.797"></a><span id="l19.797">    *</span>
<a href="#l19.798"></a><span id="l19.798">    * Make sure to call this function before killActiveJob</span>
<a href="#l19.799"></a><span id="l19.799">    *</span>
<a href="#l19.800"></a><span id="l19.800">    * @param aFilterElimFunc A filter function that takes an |IndexingJob| and</span>
<a href="#l19.801"></a><span id="l19.801">    *     returns true if the job should be purged, false if it should not be.</span>
<a href="#l19.802"></a><span id="l19.802">    *     The filter sees the jobs in the order they are scheduled.</span>
<a href="#l19.803"></a><span id="l19.803">    */</span>
<a href="#l19.804"></a><span id="l19.804" class="difflineminus">-  purgeJobsUsingFilter: function(aFilterElimFunc) {</span>
<a href="#l19.805"></a><span id="l19.805" class="difflineplus">+  purgeJobsUsingFilter(aFilterElimFunc) {</span>
<a href="#l19.806"></a><span id="l19.806">     for (let iJob = 0; iJob &lt; this._indexQueue.length; iJob++) {</span>
<a href="#l19.807"></a><span id="l19.807">       let job = this._indexQueue[iJob];</span>
<a href="#l19.808"></a><span id="l19.808"> </span>
<a href="#l19.809"></a><span id="l19.809">       // If the filter says to, splice the job out of existence (and make sure</span>
<a href="#l19.810"></a><span id="l19.810">       //  to fixup iJob to compensate.)</span>
<a href="#l19.811"></a><span id="l19.811">       if (aFilterElimFunc(job)) {</span>
<a href="#l19.812"></a><span id="l19.812">         if (this._unitTestSuperVerbose)</span>
<a href="#l19.813"></a><span id="l19.813">           this._log.debug(&quot;Purging job of type: &quot; + job.jobType);</span>
<a href="#l19.814"></a><span id="l19.814" class="difflineat">@@ -1363,39 +1336,34 @@ var GlodaIndexer = {</span>
<a href="#l19.815"></a><span id="l19.815">         let workerDef = this._indexerWorkerDefs[job.jobType];</span>
<a href="#l19.816"></a><span id="l19.816">         if (workerDef.jobCanceled)</span>
<a href="#l19.817"></a><span id="l19.817">           workerDef.jobCanceled.call(workerDef.indexer, job);</span>
<a href="#l19.818"></a><span id="l19.818">       }</span>
<a href="#l19.819"></a><span id="l19.819">     }</span>
<a href="#l19.820"></a><span id="l19.820">   },</span>
<a href="#l19.821"></a><span id="l19.821"> </span>
<a href="#l19.822"></a><span id="l19.822">   /* *********** Event Processing *********** */</span>
<a href="#l19.823"></a><span id="l19.823" class="difflineminus">-  observe: function gloda_indexer_observe(aSubject, aTopic, aData) {</span>
<a href="#l19.824"></a><span id="l19.824" class="difflineplus">+  observe(aSubject, aTopic, aData) {</span>
<a href="#l19.825"></a><span id="l19.825">     // idle</span>
<a href="#l19.826"></a><span id="l19.826">     if (aTopic == &quot;idle&quot;) {</span>
<a href="#l19.827"></a><span id="l19.827">       // Do we need to commit an indexer transaction?</span>
<a href="#l19.828"></a><span id="l19.828">       if (this._idleToCommit) {</span>
<a href="#l19.829"></a><span id="l19.829">         this._idleToCommit = false;</span>
<a href="#l19.830"></a><span id="l19.830">         GlodaCollectionManager.cacheCommitDirty();</span>
<a href="#l19.831"></a><span id="l19.831">         GlodaDatastore._commitTransaction();</span>
<a href="#l19.832"></a><span id="l19.832">         this._lastCommitTime = Date.now();</span>
<a href="#l19.833"></a><span id="l19.833">         this._notifyListeners();</span>
<a href="#l19.834"></a><span id="l19.834">       }</span>
<a href="#l19.835"></a><span id="l19.835" class="difflineminus">-    }</span>
<a href="#l19.836"></a><span id="l19.836" class="difflineminus">-    // offline status</span>
<a href="#l19.837"></a><span id="l19.837" class="difflineminus">-    else if (aTopic == &quot;network:offline-status-changed&quot;) {</span>
<a href="#l19.838"></a><span id="l19.838" class="difflineplus">+    } else if (aTopic == &quot;network:offline-status-changed&quot;) { // offline status</span>
<a href="#l19.839"></a><span id="l19.839">       if (aData == &quot;offline&quot;) {</span>
<a href="#l19.840"></a><span id="l19.840">         this.suppressIndexing = true;</span>
<a href="#l19.841"></a><span id="l19.841" class="difflineminus">-      }</span>
<a href="#l19.842"></a><span id="l19.842" class="difflineminus">-      else { // online</span>
<a href="#l19.843"></a><span id="l19.843" class="difflineplus">+      } else { // online</span>
<a href="#l19.844"></a><span id="l19.844">         this.suppressIndexing = false;</span>
<a href="#l19.845"></a><span id="l19.845">       }</span>
<a href="#l19.846"></a><span id="l19.846" class="difflineminus">-    }</span>
<a href="#l19.847"></a><span id="l19.847" class="difflineminus">-    // shutdown fallback</span>
<a href="#l19.848"></a><span id="l19.848" class="difflineminus">-    else if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l19.849"></a><span id="l19.849" class="difflineplus">+    } else if (aTopic == &quot;quit-application&quot;) { // shutdown fallback</span>
<a href="#l19.850"></a><span id="l19.850">       this._shutdown();</span>
<a href="#l19.851"></a><span id="l19.851">     }</span>
<a href="#l19.852"></a><span id="l19.852">   },</span>
<a href="#l19.853"></a><span id="l19.853"> </span>
<a href="#l19.854"></a><span id="l19.854"> </span>
<a href="#l19.855"></a><span id="l19.855"> };</span>
<a href="#l19.856"></a><span id="l19.856"> // we used to initialize here; now we have public.js do it for us after the</span>
<a href="#l19.857"></a><span id="l19.857"> //  indexers register themselves so we know about all our built-in indexers</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/db/gloda/modules/log4moz.js</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/log4moz.js</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -1,13 +1,13 @@</span>
<a href="#l20.4"></a><span id="l20.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l20.5"></a><span id="l20.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l20.6"></a><span id="l20.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l20.7"></a><span id="l20.7"> </span>
<a href="#l20.8"></a><span id="l20.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['Log4Moz'];</span>
<a href="#l20.9"></a><span id="l20.9" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;Log4Moz&quot;];</span>
<a href="#l20.10"></a><span id="l20.10"> </span>
<a href="#l20.11"></a><span id="l20.11"> const {Services} = ChromeUtils.import(&quot;resource://gre/modules/Services.jsm&quot;);</span>
<a href="#l20.12"></a><span id="l20.12"> </span>
<a href="#l20.13"></a><span id="l20.13"> var MODE_RDONLY   = 0x01;</span>
<a href="#l20.14"></a><span id="l20.14"> var MODE_WRONLY   = 0x02;</span>
<a href="#l20.15"></a><span id="l20.15"> var MODE_CREATE   = 0x08;</span>
<a href="#l20.16"></a><span id="l20.16"> var MODE_APPEND   = 0x10;</span>
<a href="#l20.17"></a><span id="l20.17"> var MODE_TRUNCATE = 0x20;</span>
<a href="#l20.18"></a><span id="l20.18" class="difflineat">@@ -38,18 +38,18 @@ var Log4Moz = {</span>
<a href="#l20.19"></a><span id="l20.19">     Desc: {</span>
<a href="#l20.20"></a><span id="l20.20">       70: &quot;FATAL&quot;,</span>
<a href="#l20.21"></a><span id="l20.21">       60: &quot;ERROR&quot;,</span>
<a href="#l20.22"></a><span id="l20.22">       50: &quot;WARN&quot;,</span>
<a href="#l20.23"></a><span id="l20.23">       40: &quot;INFO&quot;,</span>
<a href="#l20.24"></a><span id="l20.24">       30: &quot;CONFIG&quot;,</span>
<a href="#l20.25"></a><span id="l20.25">       20: &quot;DEBUG&quot;,</span>
<a href="#l20.26"></a><span id="l20.26">       10: &quot;TRACE&quot;,</span>
<a href="#l20.27"></a><span id="l20.27" class="difflineminus">-      0:  &quot;ALL&quot;</span>
<a href="#l20.28"></a><span id="l20.28" class="difflineminus">-    }</span>
<a href="#l20.29"></a><span id="l20.29" class="difflineplus">+      0:  &quot;ALL&quot;,</span>
<a href="#l20.30"></a><span id="l20.30" class="difflineplus">+    },</span>
<a href="#l20.31"></a><span id="l20.31">   },</span>
<a href="#l20.32"></a><span id="l20.32"> </span>
<a href="#l20.33"></a><span id="l20.33">   /**</span>
<a href="#l20.34"></a><span id="l20.34">    * Create a logger and configure it with dump and console appenders as</span>
<a href="#l20.35"></a><span id="l20.35">    * specified by prefs based on the logger name.</span>
<a href="#l20.36"></a><span id="l20.36">    *</span>
<a href="#l20.37"></a><span id="l20.37">    * E.g., if the loggername is foo, then look for prefs</span>
<a href="#l20.38"></a><span id="l20.38">    *   foo.logging.console</span>
<a href="#l20.39"></a><span id="l20.39" class="difflineat">@@ -64,50 +64,49 @@ var Log4Moz = {</span>
<a href="#l20.40"></a><span id="l20.40">    * @param loggername The name of the logger</span>
<a href="#l20.41"></a><span id="l20.41">    * @param level (optional) the level of the logger itself</span>
<a href="#l20.42"></a><span id="l20.42">    * @param consoleLevel (optional) the level of the console appender</span>
<a href="#l20.43"></a><span id="l20.43">    * @param dumpLevel (optional) the level of the dump appender</span>
<a href="#l20.44"></a><span id="l20.44">    *</span>
<a href="#l20.45"></a><span id="l20.45">    * As described above, well-named prefs override the last two parameters</span>
<a href="#l20.46"></a><span id="l20.46">    **/</span>
<a href="#l20.47"></a><span id="l20.47"> </span>
<a href="#l20.48"></a><span id="l20.48" class="difflineminus">-  getConfiguredLogger: function(loggername, level, consoleLevel, dumpLevel) {</span>
<a href="#l20.49"></a><span id="l20.49" class="difflineplus">+  getConfiguredLogger(loggername, level, consoleLevel, dumpLevel) {</span>
<a href="#l20.50"></a><span id="l20.50">     let log = Log4Moz.repository.getLogger(loggername);</span>
<a href="#l20.51"></a><span id="l20.51">     if (log._configured)</span>
<a href="#l20.52"></a><span id="l20.52" class="difflineminus">-      return log</span>
<a href="#l20.53"></a><span id="l20.53" class="difflineplus">+      return log;</span>
<a href="#l20.54"></a><span id="l20.54"> </span>
<a href="#l20.55"></a><span id="l20.55">     let formatter = new Log4Moz.BasicFormatter();</span>
<a href="#l20.56"></a><span id="l20.56"> </span>
<a href="#l20.57"></a><span id="l20.57">     level = level || Log4Moz.Level.Error;</span>
<a href="#l20.58"></a><span id="l20.58"> </span>
<a href="#l20.59"></a><span id="l20.59">     consoleLevel = consoleLevel || -1;</span>
<a href="#l20.60"></a><span id="l20.60">     dumpLevel = dumpLevel || -1;</span>
<a href="#l20.61"></a><span id="l20.61">     let branch = Services.prefs.getBranch(loggername + &quot;.logging.&quot;);</span>
<a href="#l20.62"></a><span id="l20.62" class="difflineminus">-    if (branch)</span>
<a href="#l20.63"></a><span id="l20.63" class="difflineminus">-    {</span>
<a href="#l20.64"></a><span id="l20.64" class="difflineplus">+    if (branch) {</span>
<a href="#l20.65"></a><span id="l20.65">       try {</span>
<a href="#l20.66"></a><span id="l20.66">         // figure out if event-driven indexing should be enabled...</span>
<a href="#l20.67"></a><span id="l20.67">         let consoleLevelString = branch.getCharPref(&quot;console&quot;);</span>
<a href="#l20.68"></a><span id="l20.68">         if (consoleLevelString) {</span>
<a href="#l20.69"></a><span id="l20.69">           // capitalize to fit with Log4Moz.Level expectations</span>
<a href="#l20.70"></a><span id="l20.70">           consoleLevelString = consoleLevelString.charAt(0).toUpperCase() +</span>
<a href="#l20.71"></a><span id="l20.71">              consoleLevelString.substr(1).toLowerCase();</span>
<a href="#l20.72"></a><span id="l20.72" class="difflineminus">-          consoleLevel = (consoleLevelString == 'None') ?</span>
<a href="#l20.73"></a><span id="l20.73" class="difflineplus">+          consoleLevel = (consoleLevelString == &quot;None&quot;) ?</span>
<a href="#l20.74"></a><span id="l20.74">                           100 : Log4Moz.Level[consoleLevelString];</span>
<a href="#l20.75"></a><span id="l20.75">         }</span>
<a href="#l20.76"></a><span id="l20.76">       } catch (ex) {</span>
<a href="#l20.77"></a><span id="l20.77">         // Ignore if preference is not found</span>
<a href="#l20.78"></a><span id="l20.78">       }</span>
<a href="#l20.79"></a><span id="l20.79">       try {</span>
<a href="#l20.80"></a><span id="l20.80">         let dumpLevelString = branch.getCharPref(&quot;dump&quot;);</span>
<a href="#l20.81"></a><span id="l20.81">         if (dumpLevelString) {</span>
<a href="#l20.82"></a><span id="l20.82">           // capitalize to fit with Log4Moz.Level expectations</span>
<a href="#l20.83"></a><span id="l20.83">           dumpLevelString = dumpLevelString.charAt(0).toUpperCase() +</span>
<a href="#l20.84"></a><span id="l20.84">              dumpLevelString.substr(1).toLowerCase();</span>
<a href="#l20.85"></a><span id="l20.85" class="difflineminus">-          dumpLevel = (dumpLevelString == 'None') ?</span>
<a href="#l20.86"></a><span id="l20.86" class="difflineplus">+          dumpLevel = (dumpLevelString == &quot;None&quot;) ?</span>
<a href="#l20.87"></a><span id="l20.87">                        100 : Log4Moz.Level[dumpLevelString];</span>
<a href="#l20.88"></a><span id="l20.88">         }</span>
<a href="#l20.89"></a><span id="l20.89">       } catch (ex) {</span>
<a href="#l20.90"></a><span id="l20.90">         // Ignore if preference is not found</span>
<a href="#l20.91"></a><span id="l20.91">       }</span>
<a href="#l20.92"></a><span id="l20.92">     }</span>
<a href="#l20.93"></a><span id="l20.93"> </span>
<a href="#l20.94"></a><span id="l20.94">     if (consoleLevel != 100) {</span>
<a href="#l20.95"></a><span id="l20.95" class="difflineat">@@ -158,109 +157,106 @@ var Log4Moz = {</span>
<a href="#l20.96"></a><span id="l20.96">   get FileAppender() { return FileAppender; },</span>
<a href="#l20.97"></a><span id="l20.97">   get SocketAppender() { return SocketAppender; },</span>
<a href="#l20.98"></a><span id="l20.98">   get RotatingFileAppender() { return RotatingFileAppender; },</span>
<a href="#l20.99"></a><span id="l20.99">   get ThrowingAppender() { return ThrowingAppender; },</span>
<a href="#l20.100"></a><span id="l20.100"> </span>
<a href="#l20.101"></a><span id="l20.101">   // Logging helper:</span>
<a href="#l20.102"></a><span id="l20.102">   // let logger = Log4Moz.repository.getLogger(&quot;foo&quot;);</span>
<a href="#l20.103"></a><span id="l20.103">   // logger.info(Log4Moz.enumerateInterfaces(someObject).join(&quot;,&quot;));</span>
<a href="#l20.104"></a><span id="l20.104" class="difflineminus">-  enumerateInterfaces: function Log4Moz_enumerateInterfaces(aObject) {</span>
<a href="#l20.105"></a><span id="l20.105" class="difflineplus">+  enumerateInterfaces(aObject) {</span>
<a href="#l20.106"></a><span id="l20.106">     let interfaces = [];</span>
<a href="#l20.107"></a><span id="l20.107"> </span>
<a href="#l20.108"></a><span id="l20.108" class="difflineminus">-    for (i in Ci) {</span>
<a href="#l20.109"></a><span id="l20.109" class="difflineplus">+    for (let i in Ci) {</span>
<a href="#l20.110"></a><span id="l20.110">       try {</span>
<a href="#l20.111"></a><span id="l20.111">         aObject.QueryInterface(Ci[i]);</span>
<a href="#l20.112"></a><span id="l20.112">         interfaces.push(i);</span>
<a href="#l20.113"></a><span id="l20.113" class="difflineminus">-      }</span>
<a href="#l20.114"></a><span id="l20.114" class="difflineminus">-      catch(ex) {}</span>
<a href="#l20.115"></a><span id="l20.115" class="difflineplus">+      } catch (ex) {}</span>
<a href="#l20.116"></a><span id="l20.116">     }</span>
<a href="#l20.117"></a><span id="l20.117"> </span>
<a href="#l20.118"></a><span id="l20.118">     return interfaces;</span>
<a href="#l20.119"></a><span id="l20.119">   },</span>
<a href="#l20.120"></a><span id="l20.120"> </span>
<a href="#l20.121"></a><span id="l20.121">   // Logging helper:</span>
<a href="#l20.122"></a><span id="l20.122">   // let logger = Log4Moz.repository.getLogger(&quot;foo&quot;);</span>
<a href="#l20.123"></a><span id="l20.123">   // logger.info(Log4Moz.enumerateProperties(someObject).join(&quot;,&quot;));</span>
<a href="#l20.124"></a><span id="l20.124" class="difflineminus">-  enumerateProperties: function Log4Moz_enumerateProps(aObject,</span>
<a href="#l20.125"></a><span id="l20.125" class="difflineminus">-                                                       aExcludeComplexTypes) {</span>
<a href="#l20.126"></a><span id="l20.126" class="difflineplus">+  enumerateProperties(aObject, aExcludeComplexTypes) {</span>
<a href="#l20.127"></a><span id="l20.127">     let properties = [];</span>
<a href="#l20.128"></a><span id="l20.128"> </span>
<a href="#l20.129"></a><span id="l20.129">     for (var p in aObject) {</span>
<a href="#l20.130"></a><span id="l20.130">       try {</span>
<a href="#l20.131"></a><span id="l20.131">         if (aExcludeComplexTypes &amp;&amp;</span>
<a href="#l20.132"></a><span id="l20.132">             (typeof aObject[p] == &quot;object&quot; || typeof aObject[p] == &quot;function&quot;))</span>
<a href="#l20.133"></a><span id="l20.133">           continue;</span>
<a href="#l20.134"></a><span id="l20.134">         properties.push(p + &quot; = &quot; + aObject[p]);</span>
<a href="#l20.135"></a><span id="l20.135" class="difflineminus">-      }</span>
<a href="#l20.136"></a><span id="l20.136" class="difflineminus">-      catch(ex) {</span>
<a href="#l20.137"></a><span id="l20.137" class="difflineplus">+      } catch (ex) {</span>
<a href="#l20.138"></a><span id="l20.138">         properties.push(p + &quot; = &quot; + ex);</span>
<a href="#l20.139"></a><span id="l20.139">       }</span>
<a href="#l20.140"></a><span id="l20.140">     }</span>
<a href="#l20.141"></a><span id="l20.141"> </span>
<a href="#l20.142"></a><span id="l20.142">     return properties;</span>
<a href="#l20.143"></a><span id="l20.143" class="difflineminus">-  }</span>
<a href="#l20.144"></a><span id="l20.144" class="difflineplus">+  },</span>
<a href="#l20.145"></a><span id="l20.145"> };</span>
<a href="#l20.146"></a><span id="l20.146"> </span>
<a href="#l20.147"></a><span id="l20.147"> function LoggerContext() {</span>
<a href="#l20.148"></a><span id="l20.148">   this._started = this._lastStateChange = Date.now();</span>
<a href="#l20.149"></a><span id="l20.149">   this._state = &quot;started&quot;;</span>
<a href="#l20.150"></a><span id="l20.150"> }</span>
<a href="#l20.151"></a><span id="l20.151"> LoggerContext.prototype = {</span>
<a href="#l20.152"></a><span id="l20.152">   _jsonMe: true,</span>
<a href="#l20.153"></a><span id="l20.153">   _id: &quot;unknown&quot;,</span>
<a href="#l20.154"></a><span id="l20.154" class="difflineminus">-  setState: function LoggerContext_state(aState) {</span>
<a href="#l20.155"></a><span id="l20.155" class="difflineplus">+  setState(aState) {</span>
<a href="#l20.156"></a><span id="l20.156">     this._state = aState;</span>
<a href="#l20.157"></a><span id="l20.157">     this._lastStateChange = Date.now();</span>
<a href="#l20.158"></a><span id="l20.158">     return this;</span>
<a href="#l20.159"></a><span id="l20.159">   },</span>
<a href="#l20.160"></a><span id="l20.160" class="difflineminus">-  finish: function LoggerContext_finish() {</span>
<a href="#l20.161"></a><span id="l20.161" class="difflineplus">+  finish() {</span>
<a href="#l20.162"></a><span id="l20.162">     this._finished = Date.now();</span>
<a href="#l20.163"></a><span id="l20.163">     this._state = &quot;finished&quot;;</span>
<a href="#l20.164"></a><span id="l20.164">     return this;</span>
<a href="#l20.165"></a><span id="l20.165">   },</span>
<a href="#l20.166"></a><span id="l20.166" class="difflineminus">-  toString: function LoggerContext_toString() {</span>
<a href="#l20.167"></a><span id="l20.167" class="difflineplus">+  toString() {</span>
<a href="#l20.168"></a><span id="l20.168">     return &quot;[Context: &quot; + this._id + &quot; state: &quot; + this._state + &quot;]&quot;;</span>
<a href="#l20.169"></a><span id="l20.169" class="difflineminus">-  }</span>
<a href="#l20.170"></a><span id="l20.170" class="difflineplus">+  },</span>
<a href="#l20.171"></a><span id="l20.171"> };</span>
<a href="#l20.172"></a><span id="l20.172"> </span>
<a href="#l20.173"></a><span id="l20.173"> </span>
<a href="#l20.174"></a><span id="l20.174"> /*</span>
<a href="#l20.175"></a><span id="l20.175">  * LogMessage</span>
<a href="#l20.176"></a><span id="l20.176">  * Encapsulates a single log event's data</span>
<a href="#l20.177"></a><span id="l20.177">  */</span>
<a href="#l20.178"></a><span id="l20.178" class="difflineminus">-function LogMessage(loggerName, level, messageObjects){</span>
<a href="#l20.179"></a><span id="l20.179" class="difflineplus">+function LogMessage(loggerName, level, messageObjects) {</span>
<a href="#l20.180"></a><span id="l20.180">   this.loggerName = loggerName;</span>
<a href="#l20.181"></a><span id="l20.181">   this.messageObjects = messageObjects;</span>
<a href="#l20.182"></a><span id="l20.182">   this.level = level;</span>
<a href="#l20.183"></a><span id="l20.183">   this.time = Date.now();</span>
<a href="#l20.184"></a><span id="l20.184"> }</span>
<a href="#l20.185"></a><span id="l20.185"> LogMessage.prototype = {</span>
<a href="#l20.186"></a><span id="l20.186">   get levelDesc() {</span>
<a href="#l20.187"></a><span id="l20.187">     if (this.level in Log4Moz.Level.Desc)</span>
<a href="#l20.188"></a><span id="l20.188">       return Log4Moz.Level.Desc[this.level];</span>
<a href="#l20.189"></a><span id="l20.189">     return &quot;UNKNOWN&quot;;</span>
<a href="#l20.190"></a><span id="l20.190">   },</span>
<a href="#l20.191"></a><span id="l20.191"> </span>
<a href="#l20.192"></a><span id="l20.192" class="difflineminus">-  toString: function LogMsg_toString(){</span>
<a href="#l20.193"></a><span id="l20.193" class="difflineplus">+  toString() {</span>
<a href="#l20.194"></a><span id="l20.194">     return &quot;LogMessage [&quot; + this.time + &quot; &quot; + this.level + &quot; &quot; +</span>
<a href="#l20.195"></a><span id="l20.195">       this.messageObjects + &quot;]&quot;;</span>
<a href="#l20.196"></a><span id="l20.196" class="difflineminus">-  }</span>
<a href="#l20.197"></a><span id="l20.197" class="difflineplus">+  },</span>
<a href="#l20.198"></a><span id="l20.198"> };</span>
<a href="#l20.199"></a><span id="l20.199"> </span>
<a href="#l20.200"></a><span id="l20.200"> /*</span>
<a href="#l20.201"></a><span id="l20.201">  * Logger</span>
<a href="#l20.202"></a><span id="l20.202">  * Hierarchical version.  Logs to all appenders, assigned or inherited</span>
<a href="#l20.203"></a><span id="l20.203">  */</span>
<a href="#l20.204"></a><span id="l20.204"> </span>
<a href="#l20.205"></a><span id="l20.205"> function Logger(name, repository) {</span>
<a href="#l20.206"></a><span id="l20.206">   this._init(name, repository);</span>
<a href="#l20.207"></a><span id="l20.207"> }</span>
<a href="#l20.208"></a><span id="l20.208"> Logger.prototype = {</span>
<a href="#l20.209"></a><span id="l20.209" class="difflineminus">-  _init: function Logger__init(name, repository) {</span>
<a href="#l20.210"></a><span id="l20.210" class="difflineplus">+  _init(name, repository) {</span>
<a href="#l20.211"></a><span id="l20.211">     if (!repository)</span>
<a href="#l20.212"></a><span id="l20.212">       repository = Log4Moz.repository;</span>
<a href="#l20.213"></a><span id="l20.213">     this._name = name;</span>
<a href="#l20.214"></a><span id="l20.214">     this.children = [];</span>
<a href="#l20.215"></a><span id="l20.215">     this.ownAppenders = [];</span>
<a href="#l20.216"></a><span id="l20.216">     this.appenders = [];</span>
<a href="#l20.217"></a><span id="l20.217">     this._repository = repository;</span>
<a href="#l20.218"></a><span id="l20.218">   },</span>
<a href="#l20.219"></a><span id="l20.219" class="difflineat">@@ -295,112 +291,103 @@ Logger.prototype = {</span>
<a href="#l20.220"></a><span id="l20.220">         this._parent.children.splice(index, 1);</span>
<a href="#l20.221"></a><span id="l20.221">       }</span>
<a href="#l20.222"></a><span id="l20.222">     }</span>
<a href="#l20.223"></a><span id="l20.223">     this._parent = parent;</span>
<a href="#l20.224"></a><span id="l20.224">     parent.children.push(this);</span>
<a href="#l20.225"></a><span id="l20.225">     this.updateAppenders();</span>
<a href="#l20.226"></a><span id="l20.226">   },</span>
<a href="#l20.227"></a><span id="l20.227"> </span>
<a href="#l20.228"></a><span id="l20.228" class="difflineminus">-  updateAppenders: function updateAppenders() {</span>
<a href="#l20.229"></a><span id="l20.229" class="difflineplus">+  updateAppenders() {</span>
<a href="#l20.230"></a><span id="l20.230">     if (this._parent) {</span>
<a href="#l20.231"></a><span id="l20.231">       let notOwnAppenders = this._parent.appenders.filter(function(appender) {</span>
<a href="#l20.232"></a><span id="l20.232" class="difflineminus">-        return this.ownAppenders.indexOf(appender) == -1;</span>
<a href="#l20.233"></a><span id="l20.233" class="difflineplus">+        return !this.ownAppenders.includes(appender);</span>
<a href="#l20.234"></a><span id="l20.234">       }, this);</span>
<a href="#l20.235"></a><span id="l20.235">       this.appenders = notOwnAppenders.concat(this.ownAppenders);</span>
<a href="#l20.236"></a><span id="l20.236">     } else {</span>
<a href="#l20.237"></a><span id="l20.237">       this.appenders = this.ownAppenders.slice();</span>
<a href="#l20.238"></a><span id="l20.238">     }</span>
<a href="#l20.239"></a><span id="l20.239"> </span>
<a href="#l20.240"></a><span id="l20.240">     // Update children's appenders.</span>
<a href="#l20.241"></a><span id="l20.241">     for (let i = 0; i &lt; this.children.length; i++) {</span>
<a href="#l20.242"></a><span id="l20.242">       this.children[i].updateAppenders();</span>
<a href="#l20.243"></a><span id="l20.243">     }</span>
<a href="#l20.244"></a><span id="l20.244">   },</span>
<a href="#l20.245"></a><span id="l20.245"> </span>
<a href="#l20.246"></a><span id="l20.246" class="difflineminus">-  addAppender: function Logger_addAppender(appender) {</span>
<a href="#l20.247"></a><span id="l20.247" class="difflineminus">-    if (this.ownAppenders.indexOf(appender) != -1) {</span>
<a href="#l20.248"></a><span id="l20.248" class="difflineplus">+  addAppender(appender) {</span>
<a href="#l20.249"></a><span id="l20.249" class="difflineplus">+    if (this.ownAppenders.includes(appender)) {</span>
<a href="#l20.250"></a><span id="l20.250">       return;</span>
<a href="#l20.251"></a><span id="l20.251">     }</span>
<a href="#l20.252"></a><span id="l20.252">     this.ownAppenders.push(appender);</span>
<a href="#l20.253"></a><span id="l20.253">     this.updateAppenders();</span>
<a href="#l20.254"></a><span id="l20.254">   },</span>
<a href="#l20.255"></a><span id="l20.255"> </span>
<a href="#l20.256"></a><span id="l20.256">   _nextContextId: 0,</span>
<a href="#l20.257"></a><span id="l20.257" class="difflineminus">-  newContext: function Logger_newContext(objWithProps) {</span>
<a href="#l20.258"></a><span id="l20.258" class="difflineplus">+  newContext(objWithProps) {</span>
<a href="#l20.259"></a><span id="l20.259">     if (!(&quot;_id&quot; in objWithProps))</span>
<a href="#l20.260"></a><span id="l20.260">       objWithProps._id = this._name + &quot;:&quot; + (++this._nextContextId);</span>
<a href="#l20.261"></a><span id="l20.261"> </span>
<a href="#l20.262"></a><span id="l20.262">     let c = new LoggerContext();</span>
<a href="#l20.263"></a><span id="l20.263">     c._isContext = true;</span>
<a href="#l20.264"></a><span id="l20.264">     for (let key in objWithProps) {</span>
<a href="#l20.265"></a><span id="l20.265">       c[key] = objWithProps[key];</span>
<a href="#l20.266"></a><span id="l20.266">     }</span>
<a href="#l20.267"></a><span id="l20.267">     return c;</span>
<a href="#l20.268"></a><span id="l20.268">   },</span>
<a href="#l20.269"></a><span id="l20.269"> </span>
<a href="#l20.270"></a><span id="l20.270" class="difflineminus">-  log: function Logger_log(message) {</span>
<a href="#l20.271"></a><span id="l20.271" class="difflineminus">-    if (this.level &gt; message.level)</span>
<a href="#l20.272"></a><span id="l20.272" class="difflineminus">-      return;</span>
<a href="#l20.273"></a><span id="l20.273" class="difflineminus">-    let appenders = this.appenders;</span>
<a href="#l20.274"></a><span id="l20.274" class="difflineminus">-    for (let i = 0; i &lt; appenders.length; i++){</span>
<a href="#l20.275"></a><span id="l20.275" class="difflineminus">-      appenders[i].append(message);</span>
<a href="#l20.276"></a><span id="l20.276" class="difflineminus">-    }</span>
<a href="#l20.277"></a><span id="l20.277" class="difflineminus">-  },</span>
<a href="#l20.278"></a><span id="l20.278" class="difflineminus">-</span>
<a href="#l20.279"></a><span id="l20.279" class="difflineminus">-  removeAppender: function Logger_removeAppender(appender) {</span>
<a href="#l20.280"></a><span id="l20.280" class="difflineplus">+  removeAppender(appender) {</span>
<a href="#l20.281"></a><span id="l20.281">     let index = this.ownAppenders.indexOf(appender);</span>
<a href="#l20.282"></a><span id="l20.282">     if (index == -1) {</span>
<a href="#l20.283"></a><span id="l20.283">       return;</span>
<a href="#l20.284"></a><span id="l20.284">     }</span>
<a href="#l20.285"></a><span id="l20.285">     this.ownAppenders.splice(index, 1);</span>
<a href="#l20.286"></a><span id="l20.286">     this.updateAppenders();</span>
<a href="#l20.287"></a><span id="l20.287">   },</span>
<a href="#l20.288"></a><span id="l20.288"> </span>
<a href="#l20.289"></a><span id="l20.289" class="difflineminus">-  log: function Logger_log(level, args) {</span>
<a href="#l20.290"></a><span id="l20.290" class="difflineplus">+  log(level, args) {</span>
<a href="#l20.291"></a><span id="l20.291">     if (this.level &gt; level)</span>
<a href="#l20.292"></a><span id="l20.292">       return;</span>
<a href="#l20.293"></a><span id="l20.293"> </span>
<a href="#l20.294"></a><span id="l20.294">     // Hold off on creating the message object until we actually have</span>
<a href="#l20.295"></a><span id="l20.295">     // an appender that's responsible.</span>
<a href="#l20.296"></a><span id="l20.296">     let message;</span>
<a href="#l20.297"></a><span id="l20.297">     let appenders = this.appenders;</span>
<a href="#l20.298"></a><span id="l20.298" class="difflineminus">-    for (let i = 0; i &lt; appenders.length; i++){</span>
<a href="#l20.299"></a><span id="l20.299" class="difflineplus">+    for (let i = 0; i &lt; appenders.length; i++) {</span>
<a href="#l20.300"></a><span id="l20.300">       let appender = appenders[i];</span>
<a href="#l20.301"></a><span id="l20.301">       if (appender.level &gt; level)</span>
<a href="#l20.302"></a><span id="l20.302">         continue;</span>
<a href="#l20.303"></a><span id="l20.303"> </span>
<a href="#l20.304"></a><span id="l20.304">       if (!message)</span>
<a href="#l20.305"></a><span id="l20.305">         message = new LogMessage(this._name, level, args);</span>
<a href="#l20.306"></a><span id="l20.306"> </span>
<a href="#l20.307"></a><span id="l20.307">       appender.append(message);</span>
<a href="#l20.308"></a><span id="l20.308">     }</span>
<a href="#l20.309"></a><span id="l20.309">   },</span>
<a href="#l20.310"></a><span id="l20.310"> </span>
<a href="#l20.311"></a><span id="l20.311" class="difflineminus">-  fatal: function Logger_fatal(...aArgs) {</span>
<a href="#l20.312"></a><span id="l20.312" class="difflineplus">+  fatal(...aArgs) {</span>
<a href="#l20.313"></a><span id="l20.313">     this.log(Log4Moz.Level.Fatal, aArgs);</span>
<a href="#l20.314"></a><span id="l20.314">   },</span>
<a href="#l20.315"></a><span id="l20.315" class="difflineminus">-  error: function Logger_error(...aArgs) {</span>
<a href="#l20.316"></a><span id="l20.316" class="difflineplus">+  error(...aArgs) {</span>
<a href="#l20.317"></a><span id="l20.317">     this.log(Log4Moz.Level.Error, aArgs);</span>
<a href="#l20.318"></a><span id="l20.318">   },</span>
<a href="#l20.319"></a><span id="l20.319" class="difflineminus">-  warn: function Logger_warn(...aArgs) {</span>
<a href="#l20.320"></a><span id="l20.320" class="difflineplus">+  warn(...aArgs) {</span>
<a href="#l20.321"></a><span id="l20.321">     this.log(Log4Moz.Level.Warn, aArgs);</span>
<a href="#l20.322"></a><span id="l20.322">   },</span>
<a href="#l20.323"></a><span id="l20.323" class="difflineminus">-  info: function Logger_info(...aArgs) {</span>
<a href="#l20.324"></a><span id="l20.324" class="difflineplus">+  info(...aArgs) {</span>
<a href="#l20.325"></a><span id="l20.325">     this.log(Log4Moz.Level.Info, aArgs);</span>
<a href="#l20.326"></a><span id="l20.326">   },</span>
<a href="#l20.327"></a><span id="l20.327" class="difflineminus">-  config: function Logger_config(...aArgs) {</span>
<a href="#l20.328"></a><span id="l20.328" class="difflineplus">+  config(...aArgs) {</span>
<a href="#l20.329"></a><span id="l20.329">     this.log(Log4Moz.Level.Config, aArgs);</span>
<a href="#l20.330"></a><span id="l20.330">   },</span>
<a href="#l20.331"></a><span id="l20.331" class="difflineminus">-  debug: function Logger_debug(...aArgs) {</span>
<a href="#l20.332"></a><span id="l20.332" class="difflineplus">+  debug(...aArgs) {</span>
<a href="#l20.333"></a><span id="l20.333">     this.log(Log4Moz.Level.Debug, aArgs);</span>
<a href="#l20.334"></a><span id="l20.334">   },</span>
<a href="#l20.335"></a><span id="l20.335" class="difflineminus">-  trace: function Logger_trace(...aArgs) {</span>
<a href="#l20.336"></a><span id="l20.336" class="difflineplus">+  trace(...aArgs) {</span>
<a href="#l20.337"></a><span id="l20.337">     this.log(Log4Moz.Level.Trace, aArgs);</span>
<a href="#l20.338"></a><span id="l20.338" class="difflineminus">-  }</span>
<a href="#l20.339"></a><span id="l20.339" class="difflineplus">+  },</span>
<a href="#l20.340"></a><span id="l20.340"> };</span>
<a href="#l20.341"></a><span id="l20.341"> </span>
<a href="#l20.342"></a><span id="l20.342"> /*</span>
<a href="#l20.343"></a><span id="l20.343">  * LoggerRepository</span>
<a href="#l20.344"></a><span id="l20.344">  * Implements a hierarchy of Loggers</span>
<a href="#l20.345"></a><span id="l20.345">  */</span>
<a href="#l20.346"></a><span id="l20.346"> </span>
<a href="#l20.347"></a><span id="l20.347"> function LoggerRepository() {}</span>
<a href="#l20.348"></a><span id="l20.348" class="difflineat">@@ -411,29 +398,29 @@ LoggerRepository.prototype = {</span>
<a href="#l20.349"></a><span id="l20.349">   get rootLogger() {</span>
<a href="#l20.350"></a><span id="l20.350">     if (!this._rootLogger) {</span>
<a href="#l20.351"></a><span id="l20.351">       this._rootLogger = new Logger(&quot;root&quot;, this);</span>
<a href="#l20.352"></a><span id="l20.352">       this._rootLogger.level = Log4Moz.Level.All;</span>
<a href="#l20.353"></a><span id="l20.353">     }</span>
<a href="#l20.354"></a><span id="l20.354">     return this._rootLogger;</span>
<a href="#l20.355"></a><span id="l20.355">   },</span>
<a href="#l20.356"></a><span id="l20.356">   set rootLogger(logger) {</span>
<a href="#l20.357"></a><span id="l20.357" class="difflineminus">-    throw &quot;Cannot change the root logger&quot;;</span>
<a href="#l20.358"></a><span id="l20.358" class="difflineplus">+    throw new Error(&quot;Cannot change the root logger&quot;);</span>
<a href="#l20.359"></a><span id="l20.359">   },</span>
<a href="#l20.360"></a><span id="l20.360"> </span>
<a href="#l20.361"></a><span id="l20.361" class="difflineminus">-  _updateParents: function LogRep__updateParents(name) {</span>
<a href="#l20.362"></a><span id="l20.362" class="difflineminus">-    let pieces = name.split('.');</span>
<a href="#l20.363"></a><span id="l20.363" class="difflineplus">+  _updateParents(name) {</span>
<a href="#l20.364"></a><span id="l20.364" class="difflineplus">+    let pieces = name.split(&quot;.&quot;);</span>
<a href="#l20.365"></a><span id="l20.365">     let cur, parent;</span>
<a href="#l20.366"></a><span id="l20.366"> </span>
<a href="#l20.367"></a><span id="l20.367">     // find the closest parent</span>
<a href="#l20.368"></a><span id="l20.368">     // don't test for the logger name itself, as there's a chance it's already</span>
<a href="#l20.369"></a><span id="l20.369">     // there in this._loggers</span>
<a href="#l20.370"></a><span id="l20.370">     for (let i = 0; i &lt; pieces.length - 1; i++) {</span>
<a href="#l20.371"></a><span id="l20.371">       if (cur)</span>
<a href="#l20.372"></a><span id="l20.372" class="difflineminus">-        cur += '.' + pieces[i];</span>
<a href="#l20.373"></a><span id="l20.373" class="difflineplus">+        cur += &quot;.&quot; + pieces[i];</span>
<a href="#l20.374"></a><span id="l20.374">       else</span>
<a href="#l20.375"></a><span id="l20.375">         cur = pieces[i];</span>
<a href="#l20.376"></a><span id="l20.376">       if (cur in this._loggers)</span>
<a href="#l20.377"></a><span id="l20.377">         parent = cur;</span>
<a href="#l20.378"></a><span id="l20.378">     }</span>
<a href="#l20.379"></a><span id="l20.379"> </span>
<a href="#l20.380"></a><span id="l20.380">     // if we didn't assign a parent above, there is no parent</span>
<a href="#l20.381"></a><span id="l20.381">     if (!parent)</span>
<a href="#l20.382"></a><span id="l20.382" class="difflineat">@@ -443,168 +430,167 @@ LoggerRepository.prototype = {</span>
<a href="#l20.383"></a><span id="l20.383"> </span>
<a href="#l20.384"></a><span id="l20.384">     // trigger updates for any possible descendants of this logger</span>
<a href="#l20.385"></a><span id="l20.385">     for (let logger in this._loggers) {</span>
<a href="#l20.386"></a><span id="l20.386">       if (logger != name &amp;&amp; logger.indexOf(name) == 0)</span>
<a href="#l20.387"></a><span id="l20.387">         this._updateParents(logger);</span>
<a href="#l20.388"></a><span id="l20.388">     }</span>
<a href="#l20.389"></a><span id="l20.389">   },</span>
<a href="#l20.390"></a><span id="l20.390"> </span>
<a href="#l20.391"></a><span id="l20.391" class="difflineminus">-  getLogger: function LogRep_getLogger(name) {</span>
<a href="#l20.392"></a><span id="l20.392" class="difflineplus">+  getLogger(name) {</span>
<a href="#l20.393"></a><span id="l20.393">     if (name in this._loggers)</span>
<a href="#l20.394"></a><span id="l20.394">       return this._loggers[name];</span>
<a href="#l20.395"></a><span id="l20.395">     this._loggers[name] = new Logger(name, this);</span>
<a href="#l20.396"></a><span id="l20.396">     this._updateParents(name);</span>
<a href="#l20.397"></a><span id="l20.397">     return this._loggers[name];</span>
<a href="#l20.398"></a><span id="l20.398" class="difflineminus">-  }</span>
<a href="#l20.399"></a><span id="l20.399" class="difflineplus">+  },</span>
<a href="#l20.400"></a><span id="l20.400"> };</span>
<a href="#l20.401"></a><span id="l20.401"> </span>
<a href="#l20.402"></a><span id="l20.402"> /*</span>
<a href="#l20.403"></a><span id="l20.403">  * Formatters</span>
<a href="#l20.404"></a><span id="l20.404">  * These massage a LogMessage into whatever output is desired</span>
<a href="#l20.405"></a><span id="l20.405">  * Only the BasicFormatter is currently implemented</span>
<a href="#l20.406"></a><span id="l20.406">  */</span>
<a href="#l20.407"></a><span id="l20.407"> </span>
<a href="#l20.408"></a><span id="l20.408"> // Abstract formatter</span>
<a href="#l20.409"></a><span id="l20.409"> function Formatter() {}</span>
<a href="#l20.410"></a><span id="l20.410"> Formatter.prototype = {</span>
<a href="#l20.411"></a><span id="l20.411" class="difflineminus">-  format: function Formatter_format(message) {}</span>
<a href="#l20.412"></a><span id="l20.412" class="difflineplus">+  format(message) {},</span>
<a href="#l20.413"></a><span id="l20.413"> };</span>
<a href="#l20.414"></a><span id="l20.414"> </span>
<a href="#l20.415"></a><span id="l20.415"> // services' log4moz lost the date formatting default...</span>
<a href="#l20.416"></a><span id="l20.416"> function BasicFormatter() {</span>
<a href="#l20.417"></a><span id="l20.417"> }</span>
<a href="#l20.418"></a><span id="l20.418"> BasicFormatter.prototype = {</span>
<a href="#l20.419"></a><span id="l20.419">   __proto__: Formatter.prototype,</span>
<a href="#l20.420"></a><span id="l20.420"> </span>
<a href="#l20.421"></a><span id="l20.421" class="difflineminus">-  format: function BF_format(message) {</span>
<a href="#l20.422"></a><span id="l20.422" class="difflineplus">+  format(message) {</span>
<a href="#l20.423"></a><span id="l20.423">     let date = new Date(message.time);</span>
<a href="#l20.424"></a><span id="l20.424">     // Format timestamp as: &quot;%Y-%m-%d %H:%M:%S&quot;</span>
<a href="#l20.425"></a><span id="l20.425">     let year = date.getFullYear().toString();</span>
<a href="#l20.426"></a><span id="l20.426">     let month = (date.getMonth() + 1).toString().padStart(2, &quot;0&quot;);</span>
<a href="#l20.427"></a><span id="l20.427">     let day = date.getDate().toString().padStart(2, &quot;0&quot;);</span>
<a href="#l20.428"></a><span id="l20.428">     let hours = date.getHours().toString().padStart(2, &quot;0&quot;);</span>
<a href="#l20.429"></a><span id="l20.429">     let minutes = date.getMinutes().toString().padStart(2, &quot;0&quot;);</span>
<a href="#l20.430"></a><span id="l20.430">     let seconds = date.getSeconds().toString().padStart(2, &quot;0&quot;);</span>
<a href="#l20.431"></a><span id="l20.431"> </span>
<a href="#l20.432"></a><span id="l20.432">     let timeStamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;</span>
<a href="#l20.433"></a><span id="l20.433">     // The trick below prevents errors further down because mo is null or</span>
<a href="#l20.434"></a><span id="l20.434">     //  undefined.</span>
<a href="#l20.435"></a><span id="l20.435">     let messageString = message.messageObjects.map(mo =&gt; &quot;&quot; + mo).join(&quot; &quot;);</span>
<a href="#l20.436"></a><span id="l20.436">     return timeStamp + &quot;\t&quot; +</span>
<a href="#l20.437"></a><span id="l20.437">       message.loggerName + &quot;\t&quot; + message.levelDesc + &quot;\t&quot; +</span>
<a href="#l20.438"></a><span id="l20.438">       messageString + &quot;\n&quot;;</span>
<a href="#l20.439"></a><span id="l20.439" class="difflineminus">-  }</span>
<a href="#l20.440"></a><span id="l20.440" class="difflineplus">+  },</span>
<a href="#l20.441"></a><span id="l20.441"> };</span>
<a href="#l20.442"></a><span id="l20.442"> </span>
<a href="#l20.443"></a><span id="l20.443"> /*</span>
<a href="#l20.444"></a><span id="l20.444">  * XMLFormatter</span>
<a href="#l20.445"></a><span id="l20.445">  * Format like log4j's XMLLayout.  The intent is that you can hook this up to</span>
<a href="#l20.446"></a><span id="l20.446">  * a SocketAppender and point them at a Chainsaw GUI running with an</span>
<a href="#l20.447"></a><span id="l20.447">  * XMLSocketReceiver running.  Then your output comes out in Chainsaw.</span>
<a href="#l20.448"></a><span id="l20.448">  * (Chainsaw is log4j's GUI that displays log output with niceties such as</span>
<a href="#l20.449"></a><span id="l20.449">  * filtering and conditional coloring.)</span>
<a href="#l20.450"></a><span id="l20.450">  */</span>
<a href="#l20.451"></a><span id="l20.451"> </span>
<a href="#l20.452"></a><span id="l20.452"> function XMLFormatter() {}</span>
<a href="#l20.453"></a><span id="l20.453"> XMLFormatter.prototype = {</span>
<a href="#l20.454"></a><span id="l20.454">   __proto__: Formatter.prototype,</span>
<a href="#l20.455"></a><span id="l20.455"> </span>
<a href="#l20.456"></a><span id="l20.456" class="difflineminus">-  format: function XF_format(message) {</span>
<a href="#l20.457"></a><span id="l20.457" class="difflineplus">+  format(message) {</span>
<a href="#l20.458"></a><span id="l20.458">     let cdataEscapedMessage =</span>
<a href="#l20.459"></a><span id="l20.459">       message.messageObjects</span>
<a href="#l20.460"></a><span id="l20.460">         .map(mo =&gt; (typeof(mo) == &quot;object&quot;) ? mo.toString() : mo)</span>
<a href="#l20.461"></a><span id="l20.461">         .join(&quot; &quot;)</span>
<a href="#l20.462"></a><span id="l20.462">         .split(CDATA_END).join(CDATA_ESCAPED_END);</span>
<a href="#l20.463"></a><span id="l20.463">     return &quot;&lt;log4j:event logger='&quot; + message.loggerName + &quot;' &quot; +</span>
<a href="#l20.464"></a><span id="l20.464">                         &quot;level='&quot; + message.levelDesc + &quot;' thread='unknown' &quot; +</span>
<a href="#l20.465"></a><span id="l20.465">                         &quot;timestamp='&quot; + message.time + &quot;'&gt;&quot; +</span>
<a href="#l20.466"></a><span id="l20.466">       &quot;&lt;log4j:message&gt;&lt;![CDATA[&quot; + cdataEscapedMessage + &quot;]]&gt;&lt;/log4j:message&gt;&quot; +</span>
<a href="#l20.467"></a><span id="l20.467">       &quot;&lt;/log4j:event&gt;&quot;;</span>
<a href="#l20.468"></a><span id="l20.468" class="difflineminus">-  }</span>
<a href="#l20.469"></a><span id="l20.469" class="difflineplus">+  },</span>
<a href="#l20.470"></a><span id="l20.470"> };</span>
<a href="#l20.471"></a><span id="l20.471"> </span>
<a href="#l20.472"></a><span id="l20.472"> function JSONFormatter() {</span>
<a href="#l20.473"></a><span id="l20.473"> }</span>
<a href="#l20.474"></a><span id="l20.474"> JSONFormatter.prototype = {</span>
<a href="#l20.475"></a><span id="l20.475">   __proto__: Formatter.prototype,</span>
<a href="#l20.476"></a><span id="l20.476"> </span>
<a href="#l20.477"></a><span id="l20.477" class="difflineminus">-  format: function JF_format(message) {</span>
<a href="#l20.478"></a><span id="l20.478" class="difflineplus">+  format(message) {</span>
<a href="#l20.479"></a><span id="l20.479">     // XXX I did all kinds of questionable things in here; they should be</span>
<a href="#l20.480"></a><span id="l20.480">     //  resolved...</span>
<a href="#l20.481"></a><span id="l20.481">     // 1) JSON does not walk the __proto__ chain; there is no need to clobber</span>
<a href="#l20.482"></a><span id="l20.482">     //   it.</span>
<a href="#l20.483"></a><span id="l20.483">     // 2) Our net mutation is sorta redundant messageObjects alongside</span>
<a href="#l20.484"></a><span id="l20.484">     //   msgObjects, although we only serialize one.</span>
<a href="#l20.485"></a><span id="l20.485">     let origMessageObjects = message.messageObjects;</span>
<a href="#l20.486"></a><span id="l20.486">     message.messageObjects = [];</span>
<a href="#l20.487"></a><span id="l20.487" class="difflineminus">-    let reProto = [];</span>
<a href="#l20.488"></a><span id="l20.488">     for (let messageObject of origMessageObjects) {</span>
<a href="#l20.489"></a><span id="l20.489">       if (messageObject)</span>
<a href="#l20.490"></a><span id="l20.490">         if (messageObject._jsonMe) {</span>
<a href="#l20.491"></a><span id="l20.491">           message.messageObjects.push(messageObject);</span>
<a href="#l20.492"></a><span id="l20.492" class="difflineminus">-// FIXME: the commented out code should be fixed in a better way.</span>
<a href="#l20.493"></a><span id="l20.493" class="difflineminus">-// See bug 984539: find a good way to avoid JSONing the impl in log4moz</span>
<a href="#l20.494"></a><span id="l20.494" class="difflineminus">-//          // temporarily strip the prototype to avoid JSONing the impl.</span>
<a href="#l20.495"></a><span id="l20.495" class="difflineminus">-//          reProto.push([messageObject, messageObject.__proto__]);</span>
<a href="#l20.496"></a><span id="l20.496" class="difflineminus">-//          messageObject.__proto__ = undefined;</span>
<a href="#l20.497"></a><span id="l20.497" class="difflineplus">+          // FIXME: the commented out code should be fixed in a better way.</span>
<a href="#l20.498"></a><span id="l20.498" class="difflineplus">+          // See bug 984539: find a good way to avoid JSONing the impl in log4moz</span>
<a href="#l20.499"></a><span id="l20.499" class="difflineplus">+          // // temporarily strip the prototype to avoid JSONing the impl.</span>
<a href="#l20.500"></a><span id="l20.500" class="difflineplus">+          // reProto.push([messageObject, messageObject.__proto__]);</span>
<a href="#l20.501"></a><span id="l20.501" class="difflineplus">+          // messageObject.__proto__ = undefined;</span>
<a href="#l20.502"></a><span id="l20.502" class="difflineplus">+        } else {</span>
<a href="#l20.503"></a><span id="l20.503" class="difflineplus">+          message.messageObjects.push(messageObject.toString());</span>
<a href="#l20.504"></a><span id="l20.504">         }</span>
<a href="#l20.505"></a><span id="l20.505" class="difflineminus">-        else</span>
<a href="#l20.506"></a><span id="l20.506" class="difflineminus">-          message.messageObjects.push(messageObject.toString());</span>
<a href="#l20.507"></a><span id="l20.507">       else</span>
<a href="#l20.508"></a><span id="l20.508">         message.messageObjects.push(messageObject);</span>
<a href="#l20.509"></a><span id="l20.509">     }</span>
<a href="#l20.510"></a><span id="l20.510">     let encoded = JSON.stringify(message) + &quot;\r\n&quot;;</span>
<a href="#l20.511"></a><span id="l20.511">     message.msgObjects = origMessageObjects;</span>
<a href="#l20.512"></a><span id="l20.512" class="difflineminus">-//    for (let objectAndProtoPair of reProto) {</span>
<a href="#l20.513"></a><span id="l20.513" class="difflineminus">-//      objectAndProtoPair[0].__proto__ = objectAndProtoPair[1];</span>
<a href="#l20.514"></a><span id="l20.514" class="difflineminus">-//    }</span>
<a href="#l20.515"></a><span id="l20.515" class="difflineplus">+    // for (let objectAndProtoPair of reProto) {</span>
<a href="#l20.516"></a><span id="l20.516" class="difflineplus">+    //   objectAndProtoPair[0].__proto__ = objectAndProtoPair[1];</span>
<a href="#l20.517"></a><span id="l20.517" class="difflineplus">+    // }</span>
<a href="#l20.518"></a><span id="l20.518">     return encoded;</span>
<a href="#l20.519"></a><span id="l20.519" class="difflineminus">-  }</span>
<a href="#l20.520"></a><span id="l20.520" class="difflineplus">+  },</span>
<a href="#l20.521"></a><span id="l20.521"> };</span>
<a href="#l20.522"></a><span id="l20.522"> </span>
<a href="#l20.523"></a><span id="l20.523"> </span>
<a href="#l20.524"></a><span id="l20.524"> /*</span>
<a href="#l20.525"></a><span id="l20.525">  * Appenders</span>
<a href="#l20.526"></a><span id="l20.526">  * These can be attached to Loggers to log to different places</span>
<a href="#l20.527"></a><span id="l20.527">  * Simply subclass and override doAppend to implement a new one</span>
<a href="#l20.528"></a><span id="l20.528">  */</span>
<a href="#l20.529"></a><span id="l20.529"> </span>
<a href="#l20.530"></a><span id="l20.530"> function Appender(formatter) {</span>
<a href="#l20.531"></a><span id="l20.531">   this._name = &quot;Appender&quot;;</span>
<a href="#l20.532"></a><span id="l20.532" class="difflineminus">-  this._formatter = formatter? formatter : new BasicFormatter();</span>
<a href="#l20.533"></a><span id="l20.533" class="difflineplus">+  this._formatter = formatter ? formatter : new BasicFormatter();</span>
<a href="#l20.534"></a><span id="l20.534"> }</span>
<a href="#l20.535"></a><span id="l20.535"> Appender.prototype = {</span>
<a href="#l20.536"></a><span id="l20.536">   _level: Log4Moz.Level.All,</span>
<a href="#l20.537"></a><span id="l20.537"> </span>
<a href="#l20.538"></a><span id="l20.538" class="difflineminus">-  append: function App_append(message) {</span>
<a href="#l20.539"></a><span id="l20.539" class="difflineplus">+  append(message) {</span>
<a href="#l20.540"></a><span id="l20.540">     this.doAppend(this._formatter.format(message));</span>
<a href="#l20.541"></a><span id="l20.541">   },</span>
<a href="#l20.542"></a><span id="l20.542" class="difflineminus">-  toString: function App_toString() {</span>
<a href="#l20.543"></a><span id="l20.543" class="difflineplus">+  toString() {</span>
<a href="#l20.544"></a><span id="l20.544">     return this._name + &quot; [level=&quot; + this._level +</span>
<a href="#l20.545"></a><span id="l20.545">       &quot;, formatter=&quot; + this._formatter + &quot;]&quot;;</span>
<a href="#l20.546"></a><span id="l20.546">   },</span>
<a href="#l20.547"></a><span id="l20.547" class="difflineminus">-  doAppend: function App_doAppend(message) {}</span>
<a href="#l20.548"></a><span id="l20.548" class="difflineplus">+  doAppend(message) {},</span>
<a href="#l20.549"></a><span id="l20.549"> };</span>
<a href="#l20.550"></a><span id="l20.550"> </span>
<a href="#l20.551"></a><span id="l20.551"> /*</span>
<a href="#l20.552"></a><span id="l20.552">  * DumpAppender</span>
<a href="#l20.553"></a><span id="l20.553">  * Logs to standard out</span>
<a href="#l20.554"></a><span id="l20.554">  */</span>
<a href="#l20.555"></a><span id="l20.555"> </span>
<a href="#l20.556"></a><span id="l20.556"> function DumpAppender(formatter) {</span>
<a href="#l20.557"></a><span id="l20.557">   this._name = &quot;DumpAppender&quot;;</span>
<a href="#l20.558"></a><span id="l20.558" class="difflineminus">-  this._formatter = formatter? formatter : new BasicFormatter();</span>
<a href="#l20.559"></a><span id="l20.559" class="difflineplus">+  this._formatter = formatter ? formatter : new BasicFormatter();</span>
<a href="#l20.560"></a><span id="l20.560"> }</span>
<a href="#l20.561"></a><span id="l20.561"> DumpAppender.prototype = {</span>
<a href="#l20.562"></a><span id="l20.562">   __proto__: Appender.prototype,</span>
<a href="#l20.563"></a><span id="l20.563"> </span>
<a href="#l20.564"></a><span id="l20.564" class="difflineminus">-  doAppend: function DApp_doAppend(message) {</span>
<a href="#l20.565"></a><span id="l20.565" class="difflineplus">+  doAppend(message) {</span>
<a href="#l20.566"></a><span id="l20.566">     dump(message);</span>
<a href="#l20.567"></a><span id="l20.567" class="difflineminus">-  }</span>
<a href="#l20.568"></a><span id="l20.568" class="difflineplus">+  },</span>
<a href="#l20.569"></a><span id="l20.569"> };</span>
<a href="#l20.570"></a><span id="l20.570"> </span>
<a href="#l20.571"></a><span id="l20.571"> /**</span>
<a href="#l20.572"></a><span id="l20.572">  * An in-memory appender that always logs to its in-memory bucket and associates</span>
<a href="#l20.573"></a><span id="l20.573">  * each message with a timestamp.  Whoever creates us is responsible for causing</span>
<a href="#l20.574"></a><span id="l20.574">  * us to switch to a new bucket using whatever criteria is appropriate.</span>
<a href="#l20.575"></a><span id="l20.575">  *</span>
<a href="#l20.576"></a><span id="l20.576">  * This is intended to be used roughly like an in-memory circular buffer.  The</span>
<a href="#l20.577"></a><span id="l20.577" class="difflineat">@@ -622,46 +608,46 @@ function TimeAwareMemoryBucketAppender()</span>
<a href="#l20.578"></a><span id="l20.578">   //  are the message objects.</span>
<a href="#l20.579"></a><span id="l20.579">   this._curBucket = [];</span>
<a href="#l20.580"></a><span id="l20.580">   this._curBucketStartedAt = Date.now();</span>
<a href="#l20.581"></a><span id="l20.581"> }</span>
<a href="#l20.582"></a><span id="l20.582"> TimeAwareMemoryBucketAppender.prototype = {</span>
<a href="#l20.583"></a><span id="l20.583">   get level() { return this._level; },</span>
<a href="#l20.584"></a><span id="l20.584">   set level(level) { this._level = level; },</span>
<a href="#l20.585"></a><span id="l20.585"> </span>
<a href="#l20.586"></a><span id="l20.586" class="difflineminus">-  append: function TAMBA_append(message) {</span>
<a href="#l20.587"></a><span id="l20.587" class="difflineplus">+  append(message) {</span>
<a href="#l20.588"></a><span id="l20.588">     if (this._level &lt;= message.level)</span>
<a href="#l20.589"></a><span id="l20.589">       this._curBucket.push(message);</span>
<a href="#l20.590"></a><span id="l20.590">   },</span>
<a href="#l20.591"></a><span id="l20.591"> </span>
<a href="#l20.592"></a><span id="l20.592" class="difflineminus">-  newBucket: function() {</span>
<a href="#l20.593"></a><span id="l20.593" class="difflineplus">+  newBucket() {</span>
<a href="#l20.594"></a><span id="l20.594">     this._lastBucket = this._curBucket;</span>
<a href="#l20.595"></a><span id="l20.595">     this._curBucketStartedAt = Date.now();</span>
<a href="#l20.596"></a><span id="l20.596">     this._curBucket = [];</span>
<a href="#l20.597"></a><span id="l20.597">   },</span>
<a href="#l20.598"></a><span id="l20.598"> </span>
<a href="#l20.599"></a><span id="l20.599" class="difflineminus">-  getPreviousBucketEvents: function(aNumMS) {</span>
<a href="#l20.600"></a><span id="l20.600" class="difflineplus">+  getPreviousBucketEvents(aNumMS) {</span>
<a href="#l20.601"></a><span id="l20.601">     let lastBucket = this._lastBucket;</span>
<a href="#l20.602"></a><span id="l20.602">     if (lastBucket == null || !lastBucket.length)</span>
<a href="#l20.603"></a><span id="l20.603">       return [];</span>
<a href="#l20.604"></a><span id="l20.604">     let timeBound = this._curBucketStartedAt - aNumMS;</span>
<a href="#l20.605"></a><span id="l20.605">     // seek backwards through the list...</span>
<a href="#l20.606"></a><span id="l20.606">     let i;</span>
<a href="#l20.607"></a><span id="l20.607" class="difflineminus">-    for (i = lastBucket.length - 1; i &gt;= 0; i --) {</span>
<a href="#l20.608"></a><span id="l20.608" class="difflineplus">+    for (i = lastBucket.length - 1; i &gt;= 0; i--) {</span>
<a href="#l20.609"></a><span id="l20.609">       if (lastBucket[i].time &lt; timeBound)</span>
<a href="#l20.610"></a><span id="l20.610">         break;</span>
<a href="#l20.611"></a><span id="l20.611">     }</span>
<a href="#l20.612"></a><span id="l20.612" class="difflineminus">-    return lastBucket.slice(i+1);</span>
<a href="#l20.613"></a><span id="l20.613" class="difflineplus">+    return lastBucket.slice(i + 1);</span>
<a href="#l20.614"></a><span id="l20.614">   },</span>
<a href="#l20.615"></a><span id="l20.615"> </span>
<a href="#l20.616"></a><span id="l20.616" class="difflineminus">-  getBucketEvents: function() {</span>
<a href="#l20.617"></a><span id="l20.617" class="difflineplus">+  getBucketEvents() {</span>
<a href="#l20.618"></a><span id="l20.618">     return this._curBucket.concat();</span>
<a href="#l20.619"></a><span id="l20.619">   },</span>
<a href="#l20.620"></a><span id="l20.620"> </span>
<a href="#l20.621"></a><span id="l20.621" class="difflineminus">-  toString: function() {</span>
<a href="#l20.622"></a><span id="l20.622" class="difflineplus">+  toString() {</span>
<a href="#l20.623"></a><span id="l20.623">     return &quot;[TimeAwareMemoryBucketAppender]&quot;;</span>
<a href="#l20.624"></a><span id="l20.624">   },</span>
<a href="#l20.625"></a><span id="l20.625"> };</span>
<a href="#l20.626"></a><span id="l20.626"> </span>
<a href="#l20.627"></a><span id="l20.627"> /*</span>
<a href="#l20.628"></a><span id="l20.628">  * ConsoleAppender</span>
<a href="#l20.629"></a><span id="l20.629">  * Logs to the javascript console</span>
<a href="#l20.630"></a><span id="l20.630">  */</span>
<a href="#l20.631"></a><span id="l20.631" class="difflineat">@@ -669,166 +655,165 @@ TimeAwareMemoryBucketAppender.prototype </span>
<a href="#l20.632"></a><span id="l20.632"> function ConsoleAppender(formatter) {</span>
<a href="#l20.633"></a><span id="l20.633">   this._name = &quot;ConsoleAppender&quot;;</span>
<a href="#l20.634"></a><span id="l20.634">   this._formatter = formatter;</span>
<a href="#l20.635"></a><span id="l20.635"> }</span>
<a href="#l20.636"></a><span id="l20.636"> ConsoleAppender.prototype = {</span>
<a href="#l20.637"></a><span id="l20.637">   __proto__: Appender.prototype,</span>
<a href="#l20.638"></a><span id="l20.638"> </span>
<a href="#l20.639"></a><span id="l20.639">   // override to send Error and higher level messages to Cu.reportError()</span>
<a href="#l20.640"></a><span id="l20.640" class="difflineminus">-  append: function CApp_append(message) {</span>
<a href="#l20.641"></a><span id="l20.641" class="difflineplus">+  append(message) {</span>
<a href="#l20.642"></a><span id="l20.642">     let stringMessage = this._formatter.format(message);</span>
<a href="#l20.643"></a><span id="l20.643">     if (message.level &gt; Log4Moz.Level.Warn) {</span>
<a href="#l20.644"></a><span id="l20.644">       Cu.reportError(stringMessage);</span>
<a href="#l20.645"></a><span id="l20.645">     }</span>
<a href="#l20.646"></a><span id="l20.646">     this.doAppend(stringMessage);</span>
<a href="#l20.647"></a><span id="l20.647">   },</span>
<a href="#l20.648"></a><span id="l20.648"> </span>
<a href="#l20.649"></a><span id="l20.649" class="difflineminus">-  doAppend: function CApp_doAppend(message) {</span>
<a href="#l20.650"></a><span id="l20.650" class="difflineplus">+  doAppend(message) {</span>
<a href="#l20.651"></a><span id="l20.651">     Services.console.logStringMessage(message);</span>
<a href="#l20.652"></a><span id="l20.652" class="difflineminus">-  }</span>
<a href="#l20.653"></a><span id="l20.653" class="difflineplus">+  },</span>
<a href="#l20.654"></a><span id="l20.654"> };</span>
<a href="#l20.655"></a><span id="l20.655"> </span>
<a href="#l20.656"></a><span id="l20.656"> /*</span>
<a href="#l20.657"></a><span id="l20.657">  * FileAppender</span>
<a href="#l20.658"></a><span id="l20.658">  * Logs to a file</span>
<a href="#l20.659"></a><span id="l20.659">  */</span>
<a href="#l20.660"></a><span id="l20.660"> </span>
<a href="#l20.661"></a><span id="l20.661"> function FileAppender(file, formatter) {</span>
<a href="#l20.662"></a><span id="l20.662">   this._name = &quot;FileAppender&quot;;</span>
<a href="#l20.663"></a><span id="l20.663">   this._file = file; // nsIFile</span>
<a href="#l20.664"></a><span id="l20.664" class="difflineminus">-  this._formatter = formatter? formatter : new BasicFormatter();</span>
<a href="#l20.665"></a><span id="l20.665" class="difflineplus">+  this._formatter = formatter ? formatter : new BasicFormatter();</span>
<a href="#l20.666"></a><span id="l20.666"> }</span>
<a href="#l20.667"></a><span id="l20.667"> FileAppender.prototype = {</span>
<a href="#l20.668"></a><span id="l20.668">   __proto__: Appender.prototype,</span>
<a href="#l20.669"></a><span id="l20.669"> </span>
<a href="#l20.670"></a><span id="l20.670">   __fos: null,</span>
<a href="#l20.671"></a><span id="l20.671">   get _fos() {</span>
<a href="#l20.672"></a><span id="l20.672">     if (!this.__fos)</span>
<a href="#l20.673"></a><span id="l20.673">       this.openStream();</span>
<a href="#l20.674"></a><span id="l20.674">     return this.__fos;</span>
<a href="#l20.675"></a><span id="l20.675">   },</span>
<a href="#l20.676"></a><span id="l20.676"> </span>
<a href="#l20.677"></a><span id="l20.677" class="difflineminus">-  openStream: function FApp_openStream() {</span>
<a href="#l20.678"></a><span id="l20.678" class="difflineplus">+  openStream() {</span>
<a href="#l20.679"></a><span id="l20.679">     this.__fos = Cc[&quot;@mozilla.org/network/file-output-stream;1&quot;].</span>
<a href="#l20.680"></a><span id="l20.680">       createInstance(Ci.nsIFileOutputStream);</span>
<a href="#l20.681"></a><span id="l20.681">     let flags = MODE_WRONLY | MODE_CREATE | MODE_APPEND;</span>
<a href="#l20.682"></a><span id="l20.682">     this.__fos.init(this._file, flags, PERMS_FILE, 0);</span>
<a href="#l20.683"></a><span id="l20.683">   },</span>
<a href="#l20.684"></a><span id="l20.684"> </span>
<a href="#l20.685"></a><span id="l20.685" class="difflineminus">-  closeStream: function FApp_closeStream() {</span>
<a href="#l20.686"></a><span id="l20.686" class="difflineplus">+  closeStream() {</span>
<a href="#l20.687"></a><span id="l20.687">     if (!this.__fos)</span>
<a href="#l20.688"></a><span id="l20.688">       return;</span>
<a href="#l20.689"></a><span id="l20.689">     try {</span>
<a href="#l20.690"></a><span id="l20.690">       this.__fos.close();</span>
<a href="#l20.691"></a><span id="l20.691">       this.__fos = null;</span>
<a href="#l20.692"></a><span id="l20.692" class="difflineminus">-    } catch(e) {</span>
<a href="#l20.693"></a><span id="l20.693" class="difflineplus">+    } catch (e) {</span>
<a href="#l20.694"></a><span id="l20.694">       dump(&quot;Failed to close file output stream\n&quot; + e);</span>
<a href="#l20.695"></a><span id="l20.695">     }</span>
<a href="#l20.696"></a><span id="l20.696">   },</span>
<a href="#l20.697"></a><span id="l20.697"> </span>
<a href="#l20.698"></a><span id="l20.698" class="difflineminus">-  doAppend: function FApp_doAppend(message) {</span>
<a href="#l20.699"></a><span id="l20.699" class="difflineplus">+  doAppend(message) {</span>
<a href="#l20.700"></a><span id="l20.700">     if (message === null || message.length &lt;= 0)</span>
<a href="#l20.701"></a><span id="l20.701">       return;</span>
<a href="#l20.702"></a><span id="l20.702">     try {</span>
<a href="#l20.703"></a><span id="l20.703">       this._fos.write(message, message.length);</span>
<a href="#l20.704"></a><span id="l20.704" class="difflineminus">-    } catch(e) {</span>
<a href="#l20.705"></a><span id="l20.705" class="difflineplus">+    } catch (e) {</span>
<a href="#l20.706"></a><span id="l20.706">       dump(&quot;Error writing file:\n&quot; + e);</span>
<a href="#l20.707"></a><span id="l20.707">     }</span>
<a href="#l20.708"></a><span id="l20.708">   },</span>
<a href="#l20.709"></a><span id="l20.709"> </span>
<a href="#l20.710"></a><span id="l20.710" class="difflineminus">-  clear: function FApp_clear() {</span>
<a href="#l20.711"></a><span id="l20.711" class="difflineplus">+  clear() {</span>
<a href="#l20.712"></a><span id="l20.712">     this.closeStream();</span>
<a href="#l20.713"></a><span id="l20.713">     this._file.remove(false);</span>
<a href="#l20.714"></a><span id="l20.714" class="difflineminus">-  }</span>
<a href="#l20.715"></a><span id="l20.715" class="difflineplus">+  },</span>
<a href="#l20.716"></a><span id="l20.716"> };</span>
<a href="#l20.717"></a><span id="l20.717"> </span>
<a href="#l20.718"></a><span id="l20.718"> /*</span>
<a href="#l20.719"></a><span id="l20.719">  * RotatingFileAppender</span>
<a href="#l20.720"></a><span id="l20.720">  * Similar to FileAppender, but rotates logs when they become too large</span>
<a href="#l20.721"></a><span id="l20.721">  */</span>
<a href="#l20.722"></a><span id="l20.722"> </span>
<a href="#l20.723"></a><span id="l20.723"> function RotatingFileAppender(file, formatter, maxSize, maxBackups) {</span>
<a href="#l20.724"></a><span id="l20.724">   if (maxSize === undefined)</span>
<a href="#l20.725"></a><span id="l20.725">     maxSize = ONE_MEGABYTE * 2;</span>
<a href="#l20.726"></a><span id="l20.726"> </span>
<a href="#l20.727"></a><span id="l20.727">   if (maxBackups === undefined)</span>
<a href="#l20.728"></a><span id="l20.728">     maxBackups = 0;</span>
<a href="#l20.729"></a><span id="l20.729"> </span>
<a href="#l20.730"></a><span id="l20.730">   this._name = &quot;RotatingFileAppender&quot;;</span>
<a href="#l20.731"></a><span id="l20.731">   this._file = file; // nsIFile</span>
<a href="#l20.732"></a><span id="l20.732" class="difflineminus">-  this._formatter = formatter? formatter : new BasicFormatter();</span>
<a href="#l20.733"></a><span id="l20.733" class="difflineplus">+  this._formatter = formatter ? formatter : new BasicFormatter();</span>
<a href="#l20.734"></a><span id="l20.734">   this._maxSize = maxSize;</span>
<a href="#l20.735"></a><span id="l20.735">   this._maxBackups = maxBackups;</span>
<a href="#l20.736"></a><span id="l20.736"> }</span>
<a href="#l20.737"></a><span id="l20.737"> RotatingFileAppender.prototype = {</span>
<a href="#l20.738"></a><span id="l20.738">   __proto__: FileAppender.prototype,</span>
<a href="#l20.739"></a><span id="l20.739"> </span>
<a href="#l20.740"></a><span id="l20.740" class="difflineminus">-  doAppend: function RFApp_doAppend(message) {</span>
<a href="#l20.741"></a><span id="l20.741" class="difflineplus">+  doAppend(message) {</span>
<a href="#l20.742"></a><span id="l20.742">     if (message === null || message.length &lt;= 0)</span>
<a href="#l20.743"></a><span id="l20.743">       return;</span>
<a href="#l20.744"></a><span id="l20.744">     try {</span>
<a href="#l20.745"></a><span id="l20.745">       this.rotateLogs();</span>
<a href="#l20.746"></a><span id="l20.746">       this._fos.write(message, message.length);</span>
<a href="#l20.747"></a><span id="l20.747" class="difflineminus">-    } catch(e) {</span>
<a href="#l20.748"></a><span id="l20.748" class="difflineplus">+    } catch (e) {</span>
<a href="#l20.749"></a><span id="l20.749">       dump(&quot;Error writing file:\n&quot; + e);</span>
<a href="#l20.750"></a><span id="l20.750">     }</span>
<a href="#l20.751"></a><span id="l20.751">   },</span>
<a href="#l20.752"></a><span id="l20.752" class="difflineminus">-  rotateLogs: function RFApp_rotateLogs() {</span>
<a href="#l20.753"></a><span id="l20.753" class="difflineminus">-    if(this._file.exists() &amp;&amp;</span>
<a href="#l20.754"></a><span id="l20.754" class="difflineminus">-       this._file.fileSize &lt; this._maxSize)</span>
<a href="#l20.755"></a><span id="l20.755" class="difflineplus">+  rotateLogs() {</span>
<a href="#l20.756"></a><span id="l20.756" class="difflineplus">+    if (this._file.exists() &amp;&amp; this._file.fileSize &lt; this._maxSize)</span>
<a href="#l20.757"></a><span id="l20.757">       return;</span>
<a href="#l20.758"></a><span id="l20.758"> </span>
<a href="#l20.759"></a><span id="l20.759">     this.closeStream();</span>
<a href="#l20.760"></a><span id="l20.760"> </span>
<a href="#l20.761"></a><span id="l20.761" class="difflineminus">-    for (let i = this.maxBackups - 1; i &gt; 0; i--){</span>
<a href="#l20.762"></a><span id="l20.762" class="difflineplus">+    for (let i = this.maxBackups - 1; i &gt; 0; i--) {</span>
<a href="#l20.763"></a><span id="l20.763">       let backup = this._file.parent.clone();</span>
<a href="#l20.764"></a><span id="l20.764">       backup.append(this._file.leafName + &quot;.&quot; + i);</span>
<a href="#l20.765"></a><span id="l20.765">       if (backup.exists())</span>
<a href="#l20.766"></a><span id="l20.766">         backup.moveTo(this._file.parent, this._file.leafName + &quot;.&quot; + (i + 1));</span>
<a href="#l20.767"></a><span id="l20.767">     }</span>
<a href="#l20.768"></a><span id="l20.768"> </span>
<a href="#l20.769"></a><span id="l20.769">     let cur = this._file.clone();</span>
<a href="#l20.770"></a><span id="l20.770">     if (cur.exists())</span>
<a href="#l20.771"></a><span id="l20.771">       cur.moveTo(cur.parent, cur.leafName + &quot;.1&quot;);</span>
<a href="#l20.772"></a><span id="l20.772"> </span>
<a href="#l20.773"></a><span id="l20.773">     // Note: this._file still points to the same file</span>
<a href="#l20.774"></a><span id="l20.774" class="difflineminus">-  }</span>
<a href="#l20.775"></a><span id="l20.775" class="difflineplus">+  },</span>
<a href="#l20.776"></a><span id="l20.776"> };</span>
<a href="#l20.777"></a><span id="l20.777"> </span>
<a href="#l20.778"></a><span id="l20.778"> /*</span>
<a href="#l20.779"></a><span id="l20.779">  * SocketAppender</span>
<a href="#l20.780"></a><span id="l20.780">  * Logs via TCP to a given host and port.  Attempts to automatically reconnect</span>
<a href="#l20.781"></a><span id="l20.781">  * when the connection drops or cannot be initially re-established.  Connection</span>
<a href="#l20.782"></a><span id="l20.782">  * attempts will happen at most every timeoutDelay seconds (has a sane default</span>
<a href="#l20.783"></a><span id="l20.783">  * if left blank).  Messages are dropped when there is no connection.</span>
<a href="#l20.784"></a><span id="l20.784">  */</span>
<a href="#l20.785"></a><span id="l20.785"> </span>
<a href="#l20.786"></a><span id="l20.786"> function SocketAppender(host, port, formatter, timeoutDelay) {</span>
<a href="#l20.787"></a><span id="l20.787">   this._name = &quot;SocketAppender&quot;;</span>
<a href="#l20.788"></a><span id="l20.788">   this._host = host;</span>
<a href="#l20.789"></a><span id="l20.789">   this._port = port;</span>
<a href="#l20.790"></a><span id="l20.790" class="difflineminus">-  this._formatter = formatter? formatter : new BasicFormatter();</span>
<a href="#l20.791"></a><span id="l20.791" class="difflineplus">+  this._formatter = formatter ? formatter : new BasicFormatter();</span>
<a href="#l20.792"></a><span id="l20.792">   this._timeout_delay = timeoutDelay || DEFAULT_NETWORK_TIMEOUT_DELAY;</span>
<a href="#l20.793"></a><span id="l20.793"> </span>
<a href="#l20.794"></a><span id="l20.794">   this._socketService = Cc[&quot;@mozilla.org/network/socket-transport-service;1&quot;]</span>
<a href="#l20.795"></a><span id="l20.795">                           .getService(Ci.nsISocketTransportService);</span>
<a href="#l20.796"></a><span id="l20.796">   this._mainThread = Services.tm.mainThread;</span>
<a href="#l20.797"></a><span id="l20.797"> }</span>
<a href="#l20.798"></a><span id="l20.798"> SocketAppender.prototype = {</span>
<a href="#l20.799"></a><span id="l20.799">   __proto__: Appender.prototype,</span>
<a href="#l20.800"></a><span id="l20.800"> </span>
<a href="#l20.801"></a><span id="l20.801">   __nos: null,</span>
<a href="#l20.802"></a><span id="l20.802">   get _nos() {</span>
<a href="#l20.803"></a><span id="l20.803">     if (!this.__nos)</span>
<a href="#l20.804"></a><span id="l20.804">       this.openStream();</span>
<a href="#l20.805"></a><span id="l20.805">     return this.__nos;</span>
<a href="#l20.806"></a><span id="l20.806">   },</span>
<a href="#l20.807"></a><span id="l20.807">   _nextCheck: 0,</span>
<a href="#l20.808"></a><span id="l20.808" class="difflineminus">-  openStream: function SApp_openStream() {</span>
<a href="#l20.809"></a><span id="l20.809" class="difflineplus">+  openStream() {</span>
<a href="#l20.810"></a><span id="l20.810">     let now = Date.now();</span>
<a href="#l20.811"></a><span id="l20.811">     if (now &lt;= this._nextCheck) {</span>
<a href="#l20.812"></a><span id="l20.812">       return;</span>
<a href="#l20.813"></a><span id="l20.813">     }</span>
<a href="#l20.814"></a><span id="l20.814">     this._nextCheck = now + this._timeout_delay * 1000;</span>
<a href="#l20.815"></a><span id="l20.815">     try {</span>
<a href="#l20.816"></a><span id="l20.816">       this._transport = this._socketService.createTransport(</span>
<a href="#l20.817"></a><span id="l20.817">         null, 0, // default socket type</span>
<a href="#l20.818"></a><span id="l20.818" class="difflineat">@@ -854,68 +839,67 @@ SocketAppender.prototype = {</span>
<a href="#l20.819"></a><span id="l20.819"> </span>
<a href="#l20.820"></a><span id="l20.820">       this.__nos = uniOutputStream;</span>
<a href="#l20.821"></a><span id="l20.821">     } catch (ex) {</span>
<a href="#l20.822"></a><span id="l20.822">       dump(&quot;Unexpected SocketAppender connection problem: &quot; +</span>
<a href="#l20.823"></a><span id="l20.823">            ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex + &quot;\n&quot;);</span>
<a href="#l20.824"></a><span id="l20.824">     }</span>
<a href="#l20.825"></a><span id="l20.825">   },</span>
<a href="#l20.826"></a><span id="l20.826"> </span>
<a href="#l20.827"></a><span id="l20.827" class="difflineminus">-  closeStream: function SApp_closeStream() {</span>
<a href="#l20.828"></a><span id="l20.828" class="difflineplus">+  closeStream() {</span>
<a href="#l20.829"></a><span id="l20.829">     if (!this._transport)</span>
<a href="#l20.830"></a><span id="l20.830">       return;</span>
<a href="#l20.831"></a><span id="l20.831">     try {</span>
<a href="#l20.832"></a><span id="l20.832">       this._connected = false;</span>
<a href="#l20.833"></a><span id="l20.833">       this._transport = null;</span>
<a href="#l20.834"></a><span id="l20.834">       let nos = this.__nos;</span>
<a href="#l20.835"></a><span id="l20.835">       this.__nos = null;</span>
<a href="#l20.836"></a><span id="l20.836">       nos.close();</span>
<a href="#l20.837"></a><span id="l20.837" class="difflineminus">-    } catch(e) {</span>
<a href="#l20.838"></a><span id="l20.838" class="difflineplus">+    } catch (e) {</span>
<a href="#l20.839"></a><span id="l20.839">       // this shouldn't happen, but no one cares</span>
<a href="#l20.840"></a><span id="l20.840">     }</span>
<a href="#l20.841"></a><span id="l20.841">   },</span>
<a href="#l20.842"></a><span id="l20.842"> </span>
<a href="#l20.843"></a><span id="l20.843" class="difflineminus">-  doAppend: function SApp_doAppend(message) {</span>
<a href="#l20.844"></a><span id="l20.844" class="difflineplus">+  doAppend(message) {</span>
<a href="#l20.845"></a><span id="l20.845">     if (message === null || message.length &lt;= 0)</span>
<a href="#l20.846"></a><span id="l20.846">       return;</span>
<a href="#l20.847"></a><span id="l20.847">     try {</span>
<a href="#l20.848"></a><span id="l20.848">       let nos = this._nos;</span>
<a href="#l20.849"></a><span id="l20.849">       if (nos)</span>
<a href="#l20.850"></a><span id="l20.850">         nos.writeString(message);</span>
<a href="#l20.851"></a><span id="l20.851" class="difflineminus">-    } catch(e) {</span>
<a href="#l20.852"></a><span id="l20.852" class="difflineplus">+    } catch (e) {</span>
<a href="#l20.853"></a><span id="l20.853">       if (this._transport &amp;&amp; !this._transport.isAlive()) {</span>
<a href="#l20.854"></a><span id="l20.854">         this.closeStream();</span>
<a href="#l20.855"></a><span id="l20.855">       }</span>
<a href="#l20.856"></a><span id="l20.856">     }</span>
<a href="#l20.857"></a><span id="l20.857">   },</span>
<a href="#l20.858"></a><span id="l20.858"> </span>
<a href="#l20.859"></a><span id="l20.859" class="difflineminus">-  clear: function SApp_clear() {</span>
<a href="#l20.860"></a><span id="l20.860" class="difflineplus">+  clear() {</span>
<a href="#l20.861"></a><span id="l20.861">     this.closeStream();</span>
<a href="#l20.862"></a><span id="l20.862">   },</span>
<a href="#l20.863"></a><span id="l20.863"> </span>
<a href="#l20.864"></a><span id="l20.864">   /* nsITransportEventSink */</span>
<a href="#l20.865"></a><span id="l20.865" class="difflineminus">-  onTransportStatus: function SApp_onTransportStatus(aTransport, aStatus,</span>
<a href="#l20.866"></a><span id="l20.866" class="difflineminus">-      aProgress, aProgressMax) {</span>
<a href="#l20.867"></a><span id="l20.867" class="difflineplus">+  onTransportStatus(aTransport, aStatus, aProgress, aProgressMax) {</span>
<a href="#l20.868"></a><span id="l20.868">     if (aStatus == Ci.nsISocketTransport.STATUS_CONNECTED_TO)</span>
<a href="#l20.869"></a><span id="l20.869">       this._connected = true;</span>
<a href="#l20.870"></a><span id="l20.870">   },</span>
<a href="#l20.871"></a><span id="l20.871"> };</span>
<a href="#l20.872"></a><span id="l20.872"> </span>
<a href="#l20.873"></a><span id="l20.873"> /**</span>
<a href="#l20.874"></a><span id="l20.874">  * Throws an exception whenever it gets a message.  Intended to be used in</span>
<a href="#l20.875"></a><span id="l20.875">  * automated testing situations where the code would normally log an error but</span>
<a href="#l20.876"></a><span id="l20.876">  * not die in a fatal manner.</span>
<a href="#l20.877"></a><span id="l20.877">  */</span>
<a href="#l20.878"></a><span id="l20.878"> function ThrowingAppender(thrower, formatter) {</span>
<a href="#l20.879"></a><span id="l20.879">   this._name = &quot;ThrowingAppender&quot;;</span>
<a href="#l20.880"></a><span id="l20.880" class="difflineminus">-  this._formatter = formatter? formatter : new BasicFormatter();</span>
<a href="#l20.881"></a><span id="l20.881" class="difflineplus">+  this._formatter = formatter ? formatter : new BasicFormatter();</span>
<a href="#l20.882"></a><span id="l20.882">   this._thrower = thrower;</span>
<a href="#l20.883"></a><span id="l20.883"> }</span>
<a href="#l20.884"></a><span id="l20.884"> ThrowingAppender.prototype = {</span>
<a href="#l20.885"></a><span id="l20.885">   __proto__: Appender.prototype,</span>
<a href="#l20.886"></a><span id="l20.886"> </span>
<a href="#l20.887"></a><span id="l20.887" class="difflineminus">-  doAppend: function TApp_doAppend(message) {</span>
<a href="#l20.888"></a><span id="l20.888" class="difflineplus">+  doAppend(message) {</span>
<a href="#l20.889"></a><span id="l20.889">     if (this._thrower)</span>
<a href="#l20.890"></a><span id="l20.890">       this._thrower(message);</span>
<a href="#l20.891"></a><span id="l20.891">     else</span>
<a href="#l20.892"></a><span id="l20.892">       throw message;</span>
<a href="#l20.893"></a><span id="l20.893" class="difflineminus">-  }</span>
<a href="#l20.894"></a><span id="l20.894" class="difflineplus">+  },</span>
<a href="#l20.895"></a><span id="l20.895"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/db/gloda/modules/mimeTypeCategories.js</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/mimeTypeCategories.js</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -2,17 +2,17 @@</span>
<a href="#l21.4"></a><span id="l21.4">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l21.5"></a><span id="l21.5">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l21.6"></a><span id="l21.6"> </span>
<a href="#l21.7"></a><span id="l21.7"> /*</span>
<a href="#l21.8"></a><span id="l21.8">  * This file wants to be a data file of some sort.  It might do better as a real</span>
<a href="#l21.9"></a><span id="l21.9">  *  raw JSON file.  It is trying to be one right now, but it obviously is not.</span>
<a href="#l21.10"></a><span id="l21.10">  */</span>
<a href="#l21.11"></a><span id="l21.11"> </span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-var EXPORTED_SYMBOLS = ['MimeCategoryMapping'];</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+var EXPORTED_SYMBOLS = [&quot;MimeCategoryMapping&quot;];</span>
<a href="#l21.14"></a><span id="l21.14"> </span>
<a href="#l21.15"></a><span id="l21.15"> /**</span>
<a href="#l21.16"></a><span id="l21.16">  * Input data structure to allow us to build a fast mapping from mime type to</span>
<a href="#l21.17"></a><span id="l21.17">  *  category name.  The keys in MimeCategoryMapping are the top-level</span>
<a href="#l21.18"></a><span id="l21.18">  *  categories.  Each value can either be a list of MIME types or a nested</span>
<a href="#l21.19"></a><span id="l21.19">  *  object which recursively defines sub-categories.  We currently do not use</span>
<a href="#l21.20"></a><span id="l21.20">  *  the sub-categories.  They are just there to try and organize the MIME types</span>
<a href="#l21.21"></a><span id="l21.21">  *  a little and open the door to future enhancements.</span>
<a href="#l21.22"></a><span id="l21.22" class="difflineat">@@ -104,17 +104,17 @@ var MimeCategoryMapping = {</span>
<a href="#l21.23"></a><span id="l21.23">       &quot;application/vnd.ms-powerpoint&quot;,</span>
<a href="#l21.24"></a><span id="l21.24">       &quot;application/powerpoint&quot;,</span>
<a href="#l21.25"></a><span id="l21.25">       &quot;application/mspowerpoint&quot;,</span>
<a href="#l21.26"></a><span id="l21.26">       &quot;application/x-mspowerpoint&quot;,</span>
<a href="#l21.27"></a><span id="l21.27">       &quot;application/vnd.openxmlformats-officedocument.presentationml.presentation&quot;,</span>
<a href="#l21.28"></a><span id="l21.28">       &quot;application/vnd.openxmlformats-officedocument.presentationml.template&quot;,</span>
<a href="#l21.29"></a><span id="l21.29"> </span>
<a href="#l21.30"></a><span id="l21.30">       &quot;application/vnd.oasis.opendocument.presentation&quot;,</span>
<a href="#l21.31"></a><span id="l21.31" class="difflineminus">-      &quot;application/vnd.oasis.opendocument.presentation-template&quot;</span>
<a href="#l21.32"></a><span id="l21.32" class="difflineplus">+      &quot;application/vnd.oasis.opendocument.presentation-template&quot;,</span>
<a href="#l21.33"></a><span id="l21.33">     ],</span>
<a href="#l21.34"></a><span id="l21.34">     spreadsheet: [</span>
<a href="#l21.35"></a><span id="l21.35">       &quot;application/vnd.lotus-1-2-3&quot;,</span>
<a href="#l21.36"></a><span id="l21.36">       &quot;application/x-lotus123&quot;,</span>
<a href="#l21.37"></a><span id="l21.37">       &quot;application/x-123&quot;,</span>
<a href="#l21.38"></a><span id="l21.38">       &quot;application/lotus123&quot;,</span>
<a href="#l21.39"></a><span id="l21.39">       &quot;application/wk1&quot;,</span>
<a href="#l21.40"></a><span id="l21.40"> </span>
<a href="#l21.41"></a><span id="l21.41" class="difflineat">@@ -160,21 +160,21 @@ var MimeCategoryMapping = {</span>
<a href="#l21.42"></a><span id="l21.42">       &quot;application/vnd.oasis.opendocument.text-web&quot;,</span>
<a href="#l21.43"></a><span id="l21.43"> </span>
<a href="#l21.44"></a><span id="l21.44">       &quot;application/vnd.wordperfect&quot;,</span>
<a href="#l21.45"></a><span id="l21.45"> </span>
<a href="#l21.46"></a><span id="l21.46">       &quot;application/x-abiword&quot;,</span>
<a href="#l21.47"></a><span id="l21.47">       &quot;application/x-amipro&quot;,</span>
<a href="#l21.48"></a><span id="l21.48">     ],</span>
<a href="#l21.49"></a><span id="l21.49">     suite: [</span>
<a href="#l21.50"></a><span id="l21.50" class="difflineminus">-      &quot;application/vnd.ms-works&quot;</span>
<a href="#l21.51"></a><span id="l21.51" class="difflineplus">+      &quot;application/vnd.ms-works&quot;,</span>
<a href="#l21.52"></a><span id="l21.52">     ],</span>
<a href="#l21.53"></a><span id="l21.53">   },</span>
<a href="#l21.54"></a><span id="l21.54">   images: [</span>
<a href="#l21.55"></a><span id="l21.55" class="difflineminus">-    &quot;image/*&quot;</span>
<a href="#l21.56"></a><span id="l21.56" class="difflineplus">+    &quot;image/*&quot;,</span>
<a href="#l21.57"></a><span id="l21.57">   ],</span>
<a href="#l21.58"></a><span id="l21.58">   media: {</span>
<a href="#l21.59"></a><span id="l21.59">     audio: [</span>
<a href="#l21.60"></a><span id="l21.60">       &quot;audio/*&quot;,</span>
<a href="#l21.61"></a><span id="l21.61">     ],</span>
<a href="#l21.62"></a><span id="l21.62">     video: [</span>
<a href="#l21.63"></a><span id="l21.63">       &quot;video/*&quot;,</span>
<a href="#l21.64"></a><span id="l21.64">     ],</span>
<a href="#l21.65"></a><span id="l21.65" class="difflineat">@@ -182,23 +182,23 @@ var MimeCategoryMapping = {</span>
<a href="#l21.66"></a><span id="l21.66">       &quot;application/ogg&quot;,</span>
<a href="#l21.67"></a><span id="l21.67"> </span>
<a href="#l21.68"></a><span id="l21.68">       &quot;application/smil&quot;,</span>
<a href="#l21.69"></a><span id="l21.69">       &quot;application/vnd.ms-asf&quot;,</span>
<a href="#l21.70"></a><span id="l21.70">       &quot;application/vnd.rn-realmedia&quot;,</span>
<a href="#l21.71"></a><span id="l21.71">       &quot;application/x-matroska&quot;,</span>
<a href="#l21.72"></a><span id="l21.72">       &quot;application/x-quicktime-media-link&quot;,</span>
<a href="#l21.73"></a><span id="l21.73">       &quot;application/x-quicktimeplayer&quot;,</span>
<a href="#l21.74"></a><span id="l21.74" class="difflineminus">-    ]</span>
<a href="#l21.75"></a><span id="l21.75" class="difflineplus">+    ],</span>
<a href="#l21.76"></a><span id="l21.76">   },</span>
<a href="#l21.77"></a><span id="l21.77">   other: [</span>
<a href="#l21.78"></a><span id="l21.78" class="difflineminus">-    &quot;*&quot;</span>
<a href="#l21.79"></a><span id="l21.79" class="difflineplus">+    &quot;*&quot;,</span>
<a href="#l21.80"></a><span id="l21.80">   ],</span>
<a href="#l21.81"></a><span id="l21.81">   pdf: [</span>
<a href="#l21.82"></a><span id="l21.82">     &quot;application/pdf&quot;,</span>
<a href="#l21.83"></a><span id="l21.83">     &quot;application/x-pdf&quot;,</span>
<a href="#l21.84"></a><span id="l21.84">     &quot;image/pdf&quot;,</span>
<a href="#l21.85"></a><span id="l21.85">     &quot;file/pdf&quot;,</span>
<a href="#l21.86"></a><span id="l21.86"> </span>
<a href="#l21.87"></a><span id="l21.87">     &quot;application/x-bzpdf&quot;,</span>
<a href="#l21.88"></a><span id="l21.88">     &quot;application/x-gzpdf&quot;,</span>
<a href="#l21.89"></a><span id="l21.89">   ],</span>
<a href="#l21.90"></a><span id="l21.90" class="difflineminus">-}</span>
<a href="#l21.91"></a><span id="l21.91" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/db/gloda/modules/mimemsg.js</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/mimemsg.js</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -1,90 +1,87 @@</span>
<a href="#l22.4"></a><span id="l22.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l22.5"></a><span id="l22.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l22.6"></a><span id="l22.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l22.7"></a><span id="l22.7"> </span>
<a href="#l22.8"></a><span id="l22.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['MsgHdrToMimeMessage',</span>
<a href="#l22.9"></a><span id="l22.9" class="difflineminus">-                          'MimeMessage', 'MimeContainer',</span>
<a href="#l22.10"></a><span id="l22.10" class="difflineminus">-                          'MimeBody', 'MimeUnknown',</span>
<a href="#l22.11"></a><span id="l22.11" class="difflineminus">-                          'MimeMessageAttachment'];</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;MsgHdrToMimeMessage&quot;, &quot;MimeMessage&quot;, &quot;MimeContainer&quot;,</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+                         &quot;MimeBody&quot;, &quot;MimeUnknown&quot;, &quot;MimeMessageAttachment&quot;];</span>
<a href="#l22.14"></a><span id="l22.14"> </span>
<a href="#l22.15"></a><span id="l22.15"> const {Services} = ChromeUtils.import(&quot;resource://gre/modules/Services.jsm&quot;);</span>
<a href="#l22.16"></a><span id="l22.16"> const {XPCOMUtils} = ChromeUtils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l22.17"></a><span id="l22.17"> </span>
<a href="#l22.18"></a><span id="l22.18"> var EMITTER_MIME_CODE = &quot;application/x-js-mime-message&quot;;</span>
<a href="#l22.19"></a><span id="l22.19"> </span>
<a href="#l22.20"></a><span id="l22.20"> /**</span>
<a href="#l22.21"></a><span id="l22.21">  * The URL listener is surplus because the CallbackStreamListener ends up</span>
<a href="#l22.22"></a><span id="l22.22">  *  getting the same set of events, effectively.</span>
<a href="#l22.23"></a><span id="l22.23">  */</span>
<a href="#l22.24"></a><span id="l22.24"> var dumbUrlListener = {</span>
<a href="#l22.25"></a><span id="l22.25" class="difflineminus">-  OnStartRunningUrl: function (aUrl) {</span>
<a href="#l22.26"></a><span id="l22.26" class="difflineplus">+  OnStartRunningUrl(aUrl) {</span>
<a href="#l22.27"></a><span id="l22.27">   },</span>
<a href="#l22.28"></a><span id="l22.28" class="difflineminus">-  OnStopRunningUrl: function (aUrl, aExitCode) {</span>
<a href="#l22.29"></a><span id="l22.29" class="difflineplus">+  OnStopRunningUrl(aUrl, aExitCode) {</span>
<a href="#l22.30"></a><span id="l22.30">   },</span>
<a href="#l22.31"></a><span id="l22.31"> };</span>
<a href="#l22.32"></a><span id="l22.32"> </span>
<a href="#l22.33"></a><span id="l22.33"> /**</span>
<a href="#l22.34"></a><span id="l22.34">  * Maintain a list of all active stream listeners so that we can cancel them all</span>
<a href="#l22.35"></a><span id="l22.35">  *  during shutdown.  If we don't cancel them, we risk calls into javascript</span>
<a href="#l22.36"></a><span id="l22.36">  *  from C++ after the various XPConnect contexts have already begun their</span>
<a href="#l22.37"></a><span id="l22.37">  *  teardown process.</span>
<a href="#l22.38"></a><span id="l22.38">  */</span>
<a href="#l22.39"></a><span id="l22.39"> var activeStreamListeners = {};</span>
<a href="#l22.40"></a><span id="l22.40"> </span>
<a href="#l22.41"></a><span id="l22.41"> var shutdownCleanupObserver = {</span>
<a href="#l22.42"></a><span id="l22.42">   _initialized: false,</span>
<a href="#l22.43"></a><span id="l22.43" class="difflineminus">-  ensureInitialized: function mimemsg_shutdownCleanupObserver_init() {</span>
<a href="#l22.44"></a><span id="l22.44" class="difflineplus">+  ensureInitialized() {</span>
<a href="#l22.45"></a><span id="l22.45">     if (this._initialized)</span>
<a href="#l22.46"></a><span id="l22.46">       return;</span>
<a href="#l22.47"></a><span id="l22.47"> </span>
<a href="#l22.48"></a><span id="l22.48">     Services.obs.addObserver(this, &quot;quit-application&quot;);</span>
<a href="#l22.49"></a><span id="l22.49"> </span>
<a href="#l22.50"></a><span id="l22.50">     this._initialized = true;</span>
<a href="#l22.51"></a><span id="l22.51">   },</span>
<a href="#l22.52"></a><span id="l22.52"> </span>
<a href="#l22.53"></a><span id="l22.53" class="difflineminus">-  observe: function mimemsg_shutdownCleanupObserver_observe(</span>
<a href="#l22.54"></a><span id="l22.54" class="difflineplus">+  observe(</span>
<a href="#l22.55"></a><span id="l22.55">       aSubject, aTopic, aData) {</span>
<a href="#l22.56"></a><span id="l22.56">     if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l22.57"></a><span id="l22.57">       Services.obs.removeObserver(this, &quot;quit-application&quot;);</span>
<a href="#l22.58"></a><span id="l22.58"> </span>
<a href="#l22.59"></a><span id="l22.59">       for (let uri in activeStreamListeners) {</span>
<a href="#l22.60"></a><span id="l22.60">         let streamListener = activeStreamListeners[uri];</span>
<a href="#l22.61"></a><span id="l22.61">         if (streamListener._request)</span>
<a href="#l22.62"></a><span id="l22.62">           streamListener._request.cancel(Cr.NS_BINDING_ABORTED);</span>
<a href="#l22.63"></a><span id="l22.63">       }</span>
<a href="#l22.64"></a><span id="l22.64">     }</span>
<a href="#l22.65"></a><span id="l22.65" class="difflineminus">-  }</span>
<a href="#l22.66"></a><span id="l22.66" class="difflineplus">+  },</span>
<a href="#l22.67"></a><span id="l22.67"> };</span>
<a href="#l22.68"></a><span id="l22.68"> </span>
<a href="#l22.69"></a><span id="l22.69"> function CallbackStreamListener(aMsgHdr, aCallbackThis, aCallback) {</span>
<a href="#l22.70"></a><span id="l22.70">   this._msgHdr = aMsgHdr;</span>
<a href="#l22.71"></a><span id="l22.71">   let hdrURI = aMsgHdr.folder.getUriForMsg(aMsgHdr);</span>
<a href="#l22.72"></a><span id="l22.72">   this._request = null;</span>
<a href="#l22.73"></a><span id="l22.73">   this._stream = null;</span>
<a href="#l22.74"></a><span id="l22.74">   if (aCallback === undefined) {</span>
<a href="#l22.75"></a><span id="l22.75">     this._callbacksThis = [null];</span>
<a href="#l22.76"></a><span id="l22.76">     this._callbacks = [aCallbackThis];</span>
<a href="#l22.77"></a><span id="l22.77" class="difflineminus">-  }</span>
<a href="#l22.78"></a><span id="l22.78" class="difflineminus">-  else {</span>
<a href="#l22.79"></a><span id="l22.79" class="difflineplus">+  } else {</span>
<a href="#l22.80"></a><span id="l22.80">     this._callbacksThis = [aCallbackThis];</span>
<a href="#l22.81"></a><span id="l22.81" class="difflineminus">-    this._callbacks =[aCallback];</span>
<a href="#l22.82"></a><span id="l22.82" class="difflineplus">+    this._callbacks = [aCallback];</span>
<a href="#l22.83"></a><span id="l22.83">   }</span>
<a href="#l22.84"></a><span id="l22.84">   activeStreamListeners[hdrURI] = this;</span>
<a href="#l22.85"></a><span id="l22.85"> }</span>
<a href="#l22.86"></a><span id="l22.86"> </span>
<a href="#l22.87"></a><span id="l22.87"> CallbackStreamListener.prototype = {</span>
<a href="#l22.88"></a><span id="l22.88">   QueryInterface: ChromeUtils.generateQI([Ci.nsIStreamListener]),</span>
<a href="#l22.89"></a><span id="l22.89"> </span>
<a href="#l22.90"></a><span id="l22.90">   // nsIRequestObserver part</span>
<a href="#l22.91"></a><span id="l22.91" class="difflineminus">-  onStartRequest: function (aRequest) {</span>
<a href="#l22.92"></a><span id="l22.92" class="difflineplus">+  onStartRequest(aRequest) {</span>
<a href="#l22.93"></a><span id="l22.93">     this._request = aRequest;</span>
<a href="#l22.94"></a><span id="l22.94">   },</span>
<a href="#l22.95"></a><span id="l22.95" class="difflineminus">-  onStopRequest: function (aRequest, aStatusCode) {</span>
<a href="#l22.96"></a><span id="l22.96" class="difflineplus">+  onStopRequest(aRequest, aStatusCode) {</span>
<a href="#l22.97"></a><span id="l22.97">     let msgURI = this._msgHdr.folder.getUriForMsg(this._msgHdr);</span>
<a href="#l22.98"></a><span id="l22.98">     delete activeStreamListeners[msgURI];</span>
<a href="#l22.99"></a><span id="l22.99"> </span>
<a href="#l22.100"></a><span id="l22.100">     aRequest.QueryInterface(Ci.nsIChannel);</span>
<a href="#l22.101"></a><span id="l22.101">     let message = MsgHdrToMimeMessage.RESULT_RENDEVOUZ[aRequest.URI.spec];</span>
<a href="#l22.102"></a><span id="l22.102">     if (message === undefined)</span>
<a href="#l22.103"></a><span id="l22.103">       message = null;</span>
<a href="#l22.104"></a><span id="l22.104"> </span>
<a href="#l22.105"></a><span id="l22.105" class="difflineat">@@ -92,42 +89,41 @@ CallbackStreamListener.prototype = {</span>
<a href="#l22.106"></a><span id="l22.106"> </span>
<a href="#l22.107"></a><span id="l22.107">     for (let i = 0; i &lt; this._callbacksThis.length; i++) {</span>
<a href="#l22.108"></a><span id="l22.108">       try {</span>
<a href="#l22.109"></a><span id="l22.109">         this._callbacks[i].call(this._callbacksThis[i], this._msgHdr, message);</span>
<a href="#l22.110"></a><span id="l22.110">       } catch (e) {</span>
<a href="#l22.111"></a><span id="l22.111">         // Most of the time, exceptions will silently disappear into the endless</span>
<a href="#l22.112"></a><span id="l22.112">         // deeps of XPConnect, and never reach the surface ever again. At least</span>
<a href="#l22.113"></a><span id="l22.113">         // warn the user if he has dump enabled.</span>
<a href="#l22.114"></a><span id="l22.114" class="difflineminus">-        dump(&quot;The MsgHdrToMimeMessage callback threw an exception: &quot;+e+&quot;\n&quot;);</span>
<a href="#l22.115"></a><span id="l22.115" class="difflineplus">+        dump(&quot;The MsgHdrToMimeMessage callback threw an exception: &quot; + e + &quot;\n&quot;);</span>
<a href="#l22.116"></a><span id="l22.116">         // That one will probably never make it to the original caller.</span>
<a href="#l22.117"></a><span id="l22.117" class="difflineminus">-        throw(e);</span>
<a href="#l22.118"></a><span id="l22.118" class="difflineplus">+        throw e;</span>
<a href="#l22.119"></a><span id="l22.119">       }</span>
<a href="#l22.120"></a><span id="l22.120">     }</span>
<a href="#l22.121"></a><span id="l22.121"> </span>
<a href="#l22.122"></a><span id="l22.122">     this._msgHdr = null;</span>
<a href="#l22.123"></a><span id="l22.123">     this._request = null;</span>
<a href="#l22.124"></a><span id="l22.124">     this._stream = null;</span>
<a href="#l22.125"></a><span id="l22.125">     this._callbacksThis = null;</span>
<a href="#l22.126"></a><span id="l22.126">     this._callbacks = null;</span>
<a href="#l22.127"></a><span id="l22.127">   },</span>
<a href="#l22.128"></a><span id="l22.128"> </span>
<a href="#l22.129"></a><span id="l22.129">   /* okay, our onDataAvailable should actually never be called.  the stream</span>
<a href="#l22.130"></a><span id="l22.130">      converter is actually eating everything except the start and stop</span>
<a href="#l22.131"></a><span id="l22.131">      notification. */</span>
<a href="#l22.132"></a><span id="l22.132">   // nsIStreamListener part</span>
<a href="#l22.133"></a><span id="l22.133" class="difflineminus">-  onDataAvailable: function (aRequest,aInputStream,aOffset,aCount) {</span>
<a href="#l22.134"></a><span id="l22.134" class="difflineplus">+  onDataAvailable(aRequest, aInputStream, aOffset, aCount) {</span>
<a href="#l22.135"></a><span id="l22.135">     dump(&quot;this should not be happening! arrgggggh!\n&quot;);</span>
<a href="#l22.136"></a><span id="l22.136">     if (this._stream === null) {</span>
<a href="#l22.137"></a><span id="l22.137">       this._stream = Cc[&quot;@mozilla.org/scriptableinputstream;1&quot;].</span>
<a href="#l22.138"></a><span id="l22.138">                     createInstance(Ci.nsIScriptableInputStream);</span>
<a href="#l22.139"></a><span id="l22.139">       this._stream.init(aInputStream);</span>
<a href="#l22.140"></a><span id="l22.140">     }</span>
<a href="#l22.141"></a><span id="l22.141">     this._stream.read(aCount);</span>
<a href="#l22.142"></a><span id="l22.142" class="difflineminus">-</span>
<a href="#l22.143"></a><span id="l22.143">   },</span>
<a href="#l22.144"></a><span id="l22.144"> };</span>
<a href="#l22.145"></a><span id="l22.145"> </span>
<a href="#l22.146"></a><span id="l22.146"> var gMessenger = Cc[&quot;@mozilla.org/messenger;1&quot;].</span>
<a href="#l22.147"></a><span id="l22.147">                    createInstance(Ci.nsIMessenger);</span>
<a href="#l22.148"></a><span id="l22.148"> </span>
<a href="#l22.149"></a><span id="l22.149"> function stripEncryptedParts(aPart) {</span>
<a href="#l22.150"></a><span id="l22.150">   if (aPart.parts &amp;&amp; aPart.isEncrypted) {</span>
<a href="#l22.151"></a><span id="l22.151" class="difflineat">@@ -191,23 +187,22 @@ function MsgHdrToMimeMessage(aMsgHdr, aC</span>
<a href="#l22.152"></a><span id="l22.152">     ? &quot;&amp;examineEncryptedParts=true&quot;</span>
<a href="#l22.153"></a><span id="l22.153">     : &quot;&quot;;</span>
<a href="#l22.154"></a><span id="l22.154"> </span>
<a href="#l22.155"></a><span id="l22.155">   // S/MIME, our other encryption backend, is not that smart, and always</span>
<a href="#l22.156"></a><span id="l22.156">   // decrypts data. In order to protect sensitive data (e.g. not index it in</span>
<a href="#l22.157"></a><span id="l22.157">   // Gloda), unless the client asked for encrypted data, we pass to the client</span>
<a href="#l22.158"></a><span id="l22.158">   // callback a stripped-down version of the MIME structure where encrypted</span>
<a href="#l22.159"></a><span id="l22.159">   // parts have been removed.</span>
<a href="#l22.160"></a><span id="l22.160" class="difflineminus">-  let wrapCallback = function (aCallback, aCallbackThis) {</span>
<a href="#l22.161"></a><span id="l22.161" class="difflineplus">+  let wrapCallback = function(aCallback, aCallbackThis) {</span>
<a href="#l22.162"></a><span id="l22.162">     if (aOptions &amp;&amp; aOptions.examineEncryptedParts)</span>
<a href="#l22.163"></a><span id="l22.163">       return aCallback;</span>
<a href="#l22.164"></a><span id="l22.164" class="difflineminus">-    else</span>
<a href="#l22.165"></a><span id="l22.165" class="difflineminus">-      return ((aMsgHdr, aMimeMsg) =&gt;</span>
<a href="#l22.166"></a><span id="l22.166" class="difflineminus">-        aCallback.call(aCallbackThis, aMsgHdr, stripEncryptedParts(aMimeMsg))</span>
<a href="#l22.167"></a><span id="l22.167" class="difflineminus">-      );</span>
<a href="#l22.168"></a><span id="l22.168" class="difflineplus">+    return ((aMsgHdr, aMimeMsg) =&gt;</span>
<a href="#l22.169"></a><span id="l22.169" class="difflineplus">+      aCallback.call(aCallbackThis, aMsgHdr, stripEncryptedParts(aMimeMsg))</span>
<a href="#l22.170"></a><span id="l22.170" class="difflineplus">+    );</span>
<a href="#l22.171"></a><span id="l22.171">   };</span>
<a href="#l22.172"></a><span id="l22.172"> </span>
<a href="#l22.173"></a><span id="l22.173">   // Apparently there used to be an old syntax where the callback was the second</span>
<a href="#l22.174"></a><span id="l22.174">   // argument...</span>
<a href="#l22.175"></a><span id="l22.175">   let callback = aCallback ? aCallback : aCallbackThis;</span>
<a href="#l22.176"></a><span id="l22.176">   let callbackThis = aCallback ? aCallbackThis : null;</span>
<a href="#l22.177"></a><span id="l22.177"> </span>
<a href="#l22.178"></a><span id="l22.178">   // if we're already streaming this msg, just add the callback</span>
<a href="#l22.179"></a><span id="l22.179" class="difflineat">@@ -220,34 +215,34 @@ function MsgHdrToMimeMessage(aMsgHdr, aC</span>
<a href="#l22.180"></a><span id="l22.180">   }</span>
<a href="#l22.181"></a><span id="l22.181">   let streamListener = new CallbackStreamListener(</span>
<a href="#l22.182"></a><span id="l22.182">     aMsgHdr,</span>
<a href="#l22.183"></a><span id="l22.183">     callbackThis,</span>
<a href="#l22.184"></a><span id="l22.184">     wrapCallback(callback, callbackThis)</span>
<a href="#l22.185"></a><span id="l22.185">   );</span>
<a href="#l22.186"></a><span id="l22.186"> </span>
<a href="#l22.187"></a><span id="l22.187">   try {</span>
<a href="#l22.188"></a><span id="l22.188" class="difflineminus">-    let streamURI = msgService.streamMessage(</span>
<a href="#l22.189"></a><span id="l22.189" class="difflineplus">+    msgService.streamMessage(</span>
<a href="#l22.190"></a><span id="l22.190">       msgURI,</span>
<a href="#l22.191"></a><span id="l22.191">       streamListener, // consumer</span>
<a href="#l22.192"></a><span id="l22.192">       null, // nsIMsgWindow</span>
<a href="#l22.193"></a><span id="l22.193">       dumbUrlListener, // nsIUrlListener</span>
<a href="#l22.194"></a><span id="l22.194">       true, // have them create the converter</span>
<a href="#l22.195"></a><span id="l22.195">       // additional uri payload, note that &quot;header=&quot; is prepended automatically</span>
<a href="#l22.196"></a><span id="l22.196" class="difflineminus">-      &quot;filter&amp;emitter=js&quot;+partsOnDemandStr+encryptedStr,</span>
<a href="#l22.197"></a><span id="l22.197" class="difflineplus">+      &quot;filter&amp;emitter=js&quot; + partsOnDemandStr + encryptedStr,</span>
<a href="#l22.198"></a><span id="l22.198">       requireOffline);</span>
<a href="#l22.199"></a><span id="l22.199">   } catch (ex) {</span>
<a href="#l22.200"></a><span id="l22.200">     // If streamMessage throws an exception, we should make sure to clear the</span>
<a href="#l22.201"></a><span id="l22.201">     // activeStreamListener, or any subsequent attempt at sreaming this URI</span>
<a href="#l22.202"></a><span id="l22.202">     // will silently fail</span>
<a href="#l22.203"></a><span id="l22.203">     if (activeStreamListeners[msgURI]) {</span>
<a href="#l22.204"></a><span id="l22.204">       delete activeStreamListeners[msgURI];</span>
<a href="#l22.205"></a><span id="l22.205">     }</span>
<a href="#l22.206"></a><span id="l22.206">     MsgHdrToMimeMessage.OPTION_TUNNEL = null;</span>
<a href="#l22.207"></a><span id="l22.207" class="difflineminus">-    throw(ex);</span>
<a href="#l22.208"></a><span id="l22.208" class="difflineplus">+    throw ex;</span>
<a href="#l22.209"></a><span id="l22.209">   }</span>
<a href="#l22.210"></a><span id="l22.210"> </span>
<a href="#l22.211"></a><span id="l22.211">   MsgHdrToMimeMessage.OPTION_TUNNEL = null;</span>
<a href="#l22.212"></a><span id="l22.212"> }</span>
<a href="#l22.213"></a><span id="l22.213"> </span>
<a href="#l22.214"></a><span id="l22.214"> /**</span>
<a href="#l22.215"></a><span id="l22.215">  * Let the jsmimeemitter provide us with results.  The poor emitter (if I am</span>
<a href="#l22.216"></a><span id="l22.216">  *  understanding things correctly) is evaluated outside of the C.u.import</span>
<a href="#l22.217"></a><span id="l22.217" class="difflineat">@@ -279,61 +274,59 @@ var HeaderHandlerBase = {</span>
<a href="#l22.218"></a><span id="l22.218">    * @param aHeaderName The header name to retrieve, case does not matter.</span>
<a href="#l22.219"></a><span id="l22.219">    * @param aDefaultValue The value to return if the header was not found, null</span>
<a href="#l22.220"></a><span id="l22.220">    *     if left unspecified.</span>
<a href="#l22.221"></a><span id="l22.221">    * @return the value of the header if present, and the default value if not</span>
<a href="#l22.222"></a><span id="l22.222">    *  (defaults to null).  If the header was present multiple times, the first</span>
<a href="#l22.223"></a><span id="l22.223">    *  instance of the header is returned.  Use getAll if you want all of the</span>
<a href="#l22.224"></a><span id="l22.224">    *  values for the multiply-defined header.</span>
<a href="#l22.225"></a><span id="l22.225">    */</span>
<a href="#l22.226"></a><span id="l22.226" class="difflineminus">-  get: function MimeMessage_get(aHeaderName, aDefaultValue) {</span>
<a href="#l22.227"></a><span id="l22.227" class="difflineplus">+  get(aHeaderName, aDefaultValue) {</span>
<a href="#l22.228"></a><span id="l22.228">     if (aDefaultValue === undefined) {</span>
<a href="#l22.229"></a><span id="l22.229">       aDefaultValue = null;</span>
<a href="#l22.230"></a><span id="l22.230">     }</span>
<a href="#l22.231"></a><span id="l22.231">     let lowerHeader = aHeaderName.toLowerCase();</span>
<a href="#l22.232"></a><span id="l22.232">     if (lowerHeader in this.headers)</span>
<a href="#l22.233"></a><span id="l22.233">       // we require that the list cannot be empty if present</span>
<a href="#l22.234"></a><span id="l22.234">       return this.headers[lowerHeader][0];</span>
<a href="#l22.235"></a><span id="l22.235" class="difflineminus">-    else</span>
<a href="#l22.236"></a><span id="l22.236" class="difflineminus">-      return aDefaultValue;</span>
<a href="#l22.237"></a><span id="l22.237" class="difflineplus">+    return aDefaultValue;</span>
<a href="#l22.238"></a><span id="l22.238">   },</span>
<a href="#l22.239"></a><span id="l22.239">   /**</span>
<a href="#l22.240"></a><span id="l22.240">    * Look-up a header that can be present multiple times.  Use get for headers</span>
<a href="#l22.241"></a><span id="l22.241">    *  that you only expect to be present at most once.</span>
<a href="#l22.242"></a><span id="l22.242">    *</span>
<a href="#l22.243"></a><span id="l22.243">    * @param aHeaderName The header name to retrieve, case does not matter.</span>
<a href="#l22.244"></a><span id="l22.244">    * @return An array containing the values observed, which may mean a zero</span>
<a href="#l22.245"></a><span id="l22.245">    *     length array.</span>
<a href="#l22.246"></a><span id="l22.246">    */</span>
<a href="#l22.247"></a><span id="l22.247" class="difflineminus">-  getAll: function MimeMessage_getAll(aHeaderName) {</span>
<a href="#l22.248"></a><span id="l22.248" class="difflineplus">+  getAll(aHeaderName) {</span>
<a href="#l22.249"></a><span id="l22.249">     let lowerHeader = aHeaderName.toLowerCase();</span>
<a href="#l22.250"></a><span id="l22.250">     if (lowerHeader in this.headers)</span>
<a href="#l22.251"></a><span id="l22.251">       return this.headers[lowerHeader];</span>
<a href="#l22.252"></a><span id="l22.252" class="difflineminus">-    else</span>
<a href="#l22.253"></a><span id="l22.253" class="difflineminus">-      return [];</span>
<a href="#l22.254"></a><span id="l22.254" class="difflineplus">+    return [];</span>
<a href="#l22.255"></a><span id="l22.255">   },</span>
<a href="#l22.256"></a><span id="l22.256">   /**</span>
<a href="#l22.257"></a><span id="l22.257">    * @param aHeaderName Header name to test for its presence.</span>
<a href="#l22.258"></a><span id="l22.258">    * @return true if the message has (at least one value for) the given header</span>
<a href="#l22.259"></a><span id="l22.259">    *     name.</span>
<a href="#l22.260"></a><span id="l22.260">    */</span>
<a href="#l22.261"></a><span id="l22.261" class="difflineminus">-  has: function MimeMessage_has(aHeaderName) {</span>
<a href="#l22.262"></a><span id="l22.262" class="difflineplus">+  has(aHeaderName) {</span>
<a href="#l22.263"></a><span id="l22.263">     let lowerHeader = aHeaderName.toLowerCase();</span>
<a href="#l22.264"></a><span id="l22.264">     return lowerHeader in this.headers;</span>
<a href="#l22.265"></a><span id="l22.265">   },</span>
<a href="#l22.266"></a><span id="l22.266" class="difflineminus">-  _prettyHeaderString: function MimeMessage__prettyHeaderString(aIndent) {</span>
<a href="#l22.267"></a><span id="l22.267" class="difflineplus">+  _prettyHeaderString(aIndent) {</span>
<a href="#l22.268"></a><span id="l22.268">     if (aIndent === undefined)</span>
<a href="#l22.269"></a><span id="l22.269">       aIndent = &quot;&quot;;</span>
<a href="#l22.270"></a><span id="l22.270">     let s = &quot;&quot;;</span>
<a href="#l22.271"></a><span id="l22.271">     for (let header in this.headers) {</span>
<a href="#l22.272"></a><span id="l22.272">       let values = this.headers[header];</span>
<a href="#l22.273"></a><span id="l22.273">       s += &quot;\n        &quot; + aIndent + header + &quot;: &quot; + values;</span>
<a href="#l22.274"></a><span id="l22.274">     }</span>
<a href="#l22.275"></a><span id="l22.275">     return s;</span>
<a href="#l22.276"></a><span id="l22.276" class="difflineminus">-  }</span>
<a href="#l22.277"></a><span id="l22.277" class="difflineplus">+  },</span>
<a href="#l22.278"></a><span id="l22.278"> };</span>
<a href="#l22.279"></a><span id="l22.279"> </span>
<a href="#l22.280"></a><span id="l22.280"> /**</span>
<a href="#l22.281"></a><span id="l22.281">  * @ivar partName The MIME part, ex &quot;1.2.2.1&quot;.  The partName of a (top-level)</span>
<a href="#l22.282"></a><span id="l22.282">  *     message is &quot;1&quot;, its first child is &quot;1.1&quot;, its second child is &quot;1.2&quot;,</span>
<a href="#l22.283"></a><span id="l22.283">  *     its first child's first child is &quot;1.1.1&quot;, etc.</span>
<a href="#l22.284"></a><span id="l22.284">  * @ivar headers Maps lower-cased header field names to a list of the values</span>
<a href="#l22.285"></a><span id="l22.285">  *     seen for the given header.  Use get or getAll as convenience helpers.</span>
<a href="#l22.286"></a><span id="l22.286" class="difflineat">@@ -373,92 +366,87 @@ MimeMessage.prototype = {</span>
<a href="#l22.287"></a><span id="l22.287">    * @return a list of all attachments contained in this message, with</span>
<a href="#l22.288"></a><span id="l22.288">    *    included/forwarded messages treated as real attachments. Attachments</span>
<a href="#l22.289"></a><span id="l22.289">    *    contained in inner messages won't be shown.</span>
<a href="#l22.290"></a><span id="l22.290">    */</span>
<a href="#l22.291"></a><span id="l22.291">   get allUserAttachments() {</span>
<a href="#l22.292"></a><span id="l22.292">     if (this.url)</span>
<a href="#l22.293"></a><span id="l22.293">       // The jsmimeemitter camouflaged us as a MimeAttachment</span>
<a href="#l22.294"></a><span id="l22.294">       return [this];</span>
<a href="#l22.295"></a><span id="l22.295" class="difflineminus">-    else</span>
<a href="#l22.296"></a><span id="l22.296" class="difflineminus">-      // Why is there no flatten method for arrays?</span>
<a href="#l22.297"></a><span id="l22.297" class="difflineminus">-      return this.parts.map(child =&gt; child.allUserAttachments)</span>
<a href="#l22.298"></a><span id="l22.298" class="difflineminus">-        .reduce((a, b) =&gt; a.concat(b), []);</span>
<a href="#l22.299"></a><span id="l22.299" class="difflineplus">+    return this.parts.map(child =&gt; child.allUserAttachments)</span>
<a href="#l22.300"></a><span id="l22.300" class="difflineplus">+                     .reduce((a, b) =&gt; a.concat(b), []);</span>
<a href="#l22.301"></a><span id="l22.301">   },</span>
<a href="#l22.302"></a><span id="l22.302"> </span>
<a href="#l22.303"></a><span id="l22.303">   /**</span>
<a href="#l22.304"></a><span id="l22.304">    * @return the total size of this message, that is, the size of all subparts</span>
<a href="#l22.305"></a><span id="l22.305">    */</span>
<a href="#l22.306"></a><span id="l22.306" class="difflineminus">-  get size () {</span>
<a href="#l22.307"></a><span id="l22.307" class="difflineplus">+  get size() {</span>
<a href="#l22.308"></a><span id="l22.308">     return this.parts.map(child =&gt; child.size)</span>
<a href="#l22.309"></a><span id="l22.309" class="difflineminus">-      .reduce((a, b) =&gt; a + Math.max(b, 0), 0);</span>
<a href="#l22.310"></a><span id="l22.310" class="difflineplus">+                     .reduce((a, b) =&gt; a + Math.max(b, 0), 0);</span>
<a href="#l22.311"></a><span id="l22.311">   },</span>
<a href="#l22.312"></a><span id="l22.312"> </span>
<a href="#l22.313"></a><span id="l22.313">   /**</span>
<a href="#l22.314"></a><span id="l22.314">    * In the case of attached messages, libmime considers them as attachments,</span>
<a href="#l22.315"></a><span id="l22.315">    * and if the body is, say, quoted-printable encoded, then libmime will start</span>
<a href="#l22.316"></a><span id="l22.316">    * counting bytes and notify the js mime emitter about it. The JS mime emitter</span>
<a href="#l22.317"></a><span id="l22.317">    * being a nice guy, it will try to set a size on us. While this is the</span>
<a href="#l22.318"></a><span id="l22.318">    * expected behavior for MimeMsgAttachments, we must make sure we can handle</span>
<a href="#l22.319"></a><span id="l22.319">    * that (failing to write a setter results in exceptions being thrown).</span>
<a href="#l22.320"></a><span id="l22.320">    */</span>
<a href="#l22.321"></a><span id="l22.321" class="difflineminus">-  set size (whatever) {</span>
<a href="#l22.322"></a><span id="l22.322" class="difflineplus">+  set size(whatever) {</span>
<a href="#l22.323"></a><span id="l22.323">     // nop</span>
<a href="#l22.324"></a><span id="l22.324">   },</span>
<a href="#l22.325"></a><span id="l22.325"> </span>
<a href="#l22.326"></a><span id="l22.326">   /**</span>
<a href="#l22.327"></a><span id="l22.327">    * @param aMsgFolder A message folder, any message folder.  Because this is</span>
<a href="#l22.328"></a><span id="l22.328">    *    a hack.</span>
<a href="#l22.329"></a><span id="l22.329">    * @return The concatenation of all of the body parts where parts</span>
<a href="#l22.330"></a><span id="l22.330">    *    available as text/plain are pulled as-is, and parts only available</span>
<a href="#l22.331"></a><span id="l22.331">    *    as text/html are converted to plaintext form first.  In other words,</span>
<a href="#l22.332"></a><span id="l22.332">    *    if we see a multipart/alternative with a text/plain, we take the</span>
<a href="#l22.333"></a><span id="l22.333">    *    text/plain.  If we see a text/html without an alternative, we convert</span>
<a href="#l22.334"></a><span id="l22.334">    *    that to text.</span>
<a href="#l22.335"></a><span id="l22.335">    */</span>
<a href="#l22.336"></a><span id="l22.336" class="difflineminus">-  coerceBodyToPlaintext:</span>
<a href="#l22.337"></a><span id="l22.337" class="difflineminus">-      function MimeMessage_coerceBodyToPlaintext(aMsgFolder) {</span>
<a href="#l22.338"></a><span id="l22.338" class="difflineplus">+  coerceBodyToPlaintext(aMsgFolder) {</span>
<a href="#l22.339"></a><span id="l22.339">     let bodies = [];</span>
<a href="#l22.340"></a><span id="l22.340">     for (let part of this.parts) {</span>
<a href="#l22.341"></a><span id="l22.341">       // an undefined value for something not having the method is fine</span>
<a href="#l22.342"></a><span id="l22.342">       let body = part.coerceBodyToPlaintext &amp;&amp;</span>
<a href="#l22.343"></a><span id="l22.343">                  part.coerceBodyToPlaintext(aMsgFolder);</span>
<a href="#l22.344"></a><span id="l22.344">       if (body)</span>
<a href="#l22.345"></a><span id="l22.345">         bodies.push(body);</span>
<a href="#l22.346"></a><span id="l22.346">     }</span>
<a href="#l22.347"></a><span id="l22.347">     if (bodies)</span>
<a href="#l22.348"></a><span id="l22.348">       return bodies.join(&quot;&quot;);</span>
<a href="#l22.349"></a><span id="l22.349" class="difflineminus">-    else</span>
<a href="#l22.350"></a><span id="l22.350" class="difflineminus">-      return &quot;&quot;;</span>
<a href="#l22.351"></a><span id="l22.351" class="difflineplus">+    return &quot;&quot;;</span>
<a href="#l22.352"></a><span id="l22.352">   },</span>
<a href="#l22.353"></a><span id="l22.353"> </span>
<a href="#l22.354"></a><span id="l22.354">   /**</span>
<a href="#l22.355"></a><span id="l22.355">    * Convert the message and its hierarchy into a &quot;pretty string&quot;.  The message</span>
<a href="#l22.356"></a><span id="l22.356">    *  and each MIME part get their own line.  The string never ends with a</span>
<a href="#l22.357"></a><span id="l22.357">    *  newline.  For a non-multi-part message, only a single line will be</span>
<a href="#l22.358"></a><span id="l22.358">    *  returned.</span>
<a href="#l22.359"></a><span id="l22.359">    * Messages have their subject displayed, attachments have their filename and</span>
<a href="#l22.360"></a><span id="l22.360">    *  content-type (ex: image/jpeg) displayed.  &quot;Filler&quot; classes simply have</span>
<a href="#l22.361"></a><span id="l22.361">    *  their class displayed.</span>
<a href="#l22.362"></a><span id="l22.362">    */</span>
<a href="#l22.363"></a><span id="l22.363" class="difflineminus">-  prettyString: function MimeMessage_prettyString(aVerbose, aIndent,</span>
<a href="#l22.364"></a><span id="l22.364" class="difflineminus">-                                                  aDumpBody) {</span>
<a href="#l22.365"></a><span id="l22.365" class="difflineplus">+  prettyString(aVerbose, aIndent, aDumpBody) {</span>
<a href="#l22.366"></a><span id="l22.366">     if (aIndent === undefined)</span>
<a href="#l22.367"></a><span id="l22.367">       aIndent = &quot;&quot;;</span>
<a href="#l22.368"></a><span id="l22.368">     let nextIndent = aIndent + &quot;  &quot;;</span>
<a href="#l22.369"></a><span id="l22.369"> </span>
<a href="#l22.370"></a><span id="l22.370" class="difflineminus">-    let s = &quot;Message &quot;+(this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;) +</span>
<a href="#l22.371"></a><span id="l22.371" class="difflineplus">+    let s = &quot;Message &quot; + (this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;) +</span>
<a href="#l22.372"></a><span id="l22.372">       &quot;(&quot; + this.size + &quot; bytes): &quot; +</span>
<a href="#l22.373"></a><span id="l22.373">       &quot;subject&quot; in this.headers ? this.headers.subject : &quot;&quot;;</span>
<a href="#l22.374"></a><span id="l22.374">     if (aVerbose)</span>
<a href="#l22.375"></a><span id="l22.375">       s += this._prettyHeaderString(nextIndent);</span>
<a href="#l22.376"></a><span id="l22.376"> </span>
<a href="#l22.377"></a><span id="l22.377">     for (let iPart = 0; iPart &lt; this.parts.length; iPart++) {</span>
<a href="#l22.378"></a><span id="l22.378">       let part = this.parts[iPart];</span>
<a href="#l22.379"></a><span id="l22.379" class="difflineminus">-      s += &quot;\n&quot; + nextIndent + (iPart+1) + &quot; &quot; +</span>
<a href="#l22.380"></a><span id="l22.380" class="difflineplus">+      s += &quot;\n&quot; + nextIndent + (iPart + 1) + &quot; &quot; +</span>
<a href="#l22.381"></a><span id="l22.381">         part.prettyString(aVerbose, nextIndent, aDumpBody);</span>
<a href="#l22.382"></a><span id="l22.382">     }</span>
<a href="#l22.383"></a><span id="l22.383"> </span>
<a href="#l22.384"></a><span id="l22.384">     return s;</span>
<a href="#l22.385"></a><span id="l22.385">   },</span>
<a href="#l22.386"></a><span id="l22.386"> };</span>
<a href="#l22.387"></a><span id="l22.387"> </span>
<a href="#l22.388"></a><span id="l22.388"> </span>
<a href="#l22.389"></a><span id="l22.389" class="difflineat">@@ -480,29 +468,28 @@ MimeContainer.prototype = {</span>
<a href="#l22.390"></a><span id="l22.390">   get allAttachments() {</span>
<a href="#l22.391"></a><span id="l22.391">     let results = [];</span>
<a href="#l22.392"></a><span id="l22.392">     for (let iChild = 0; iChild &lt; this.parts.length; iChild++) {</span>
<a href="#l22.393"></a><span id="l22.393">       let child = this.parts[iChild];</span>
<a href="#l22.394"></a><span id="l22.394">       results = results.concat(child.allAttachments);</span>
<a href="#l22.395"></a><span id="l22.395">     }</span>
<a href="#l22.396"></a><span id="l22.396">     return results;</span>
<a href="#l22.397"></a><span id="l22.397">   },</span>
<a href="#l22.398"></a><span id="l22.398" class="difflineminus">-  get allUserAttachments () {</span>
<a href="#l22.399"></a><span id="l22.399" class="difflineplus">+  get allUserAttachments() {</span>
<a href="#l22.400"></a><span id="l22.400">     return this.parts.map(child =&gt; child.allUserAttachments)</span>
<a href="#l22.401"></a><span id="l22.401">       .reduce((a, b) =&gt; a.concat(b), []);</span>
<a href="#l22.402"></a><span id="l22.402">   },</span>
<a href="#l22.403"></a><span id="l22.403" class="difflineminus">-  get size () {</span>
<a href="#l22.404"></a><span id="l22.404" class="difflineplus">+  get size() {</span>
<a href="#l22.405"></a><span id="l22.405">     return this.parts.map(child =&gt; child.size)</span>
<a href="#l22.406"></a><span id="l22.406">       .reduce((a, b) =&gt; a + Math.max(b, 0), 0);</span>
<a href="#l22.407"></a><span id="l22.407">   },</span>
<a href="#l22.408"></a><span id="l22.408" class="difflineminus">-  set size (whatever) {</span>
<a href="#l22.409"></a><span id="l22.409" class="difflineplus">+  set size(whatever) {</span>
<a href="#l22.410"></a><span id="l22.410">     // nop</span>
<a href="#l22.411"></a><span id="l22.411">   },</span>
<a href="#l22.412"></a><span id="l22.412" class="difflineminus">-  coerceBodyToPlaintext:</span>
<a href="#l22.413"></a><span id="l22.413" class="difflineminus">-      function MimeContainer_coerceBodyToPlaintext(aMsgFolder) {</span>
<a href="#l22.414"></a><span id="l22.414" class="difflineplus">+  coerceBodyToPlaintext(aMsgFolder) {</span>
<a href="#l22.415"></a><span id="l22.415">     if (this.contentType == &quot;multipart/alternative&quot;) {</span>
<a href="#l22.416"></a><span id="l22.416">       let htmlPart;</span>
<a href="#l22.417"></a><span id="l22.417">       // pick the text/plain if we can find one, otherwise remember the HTML one</span>
<a href="#l22.418"></a><span id="l22.418">       for (let part of this.parts) {</span>
<a href="#l22.419"></a><span id="l22.419">         if (part.contentType == &quot;text/plain&quot;)</span>
<a href="#l22.420"></a><span id="l22.420">           return part.body;</span>
<a href="#l22.421"></a><span id="l22.421">         if (part.contentType == &quot;text/html&quot;)</span>
<a href="#l22.422"></a><span id="l22.422">           htmlPart = part;</span>
<a href="#l22.423"></a><span id="l22.423" class="difflineat">@@ -513,36 +500,35 @@ MimeContainer.prototype = {</span>
<a href="#l22.424"></a><span id="l22.424">       }</span>
<a href="#l22.425"></a><span id="l22.425">       // convert the HTML part if we have one</span>
<a href="#l22.426"></a><span id="l22.426">       if (htmlPart)</span>
<a href="#l22.427"></a><span id="l22.427">         return aMsgFolder.convertMsgSnippetToPlainText(htmlPart.body);</span>
<a href="#l22.428"></a><span id="l22.428">     }</span>
<a href="#l22.429"></a><span id="l22.429">     // if it's not alternative, recurse/aggregate using MimeMessage logic</span>
<a href="#l22.430"></a><span id="l22.430">     return MimeMessage.prototype.coerceBodyToPlaintext.call(this, aMsgFolder);</span>
<a href="#l22.431"></a><span id="l22.431">   },</span>
<a href="#l22.432"></a><span id="l22.432" class="difflineminus">-  prettyString: function MimeContainer_prettyString(aVerbose, aIndent,</span>
<a href="#l22.433"></a><span id="l22.433" class="difflineminus">-                                                    aDumpBody) {</span>
<a href="#l22.434"></a><span id="l22.434" class="difflineplus">+  prettyString(aVerbose, aIndent, aDumpBody) {</span>
<a href="#l22.435"></a><span id="l22.435">     let nextIndent = aIndent + &quot;  &quot;;</span>
<a href="#l22.436"></a><span id="l22.436"> </span>
<a href="#l22.437"></a><span id="l22.437" class="difflineminus">-    let s = &quot;Container &quot;+(this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;)+</span>
<a href="#l22.438"></a><span id="l22.438" class="difflineplus">+    let s = &quot;Container &quot; + (this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;) +</span>
<a href="#l22.439"></a><span id="l22.439">       &quot;(&quot; + this.size + &quot; bytes): &quot; + this.contentType;</span>
<a href="#l22.440"></a><span id="l22.440">     if (aVerbose)</span>
<a href="#l22.441"></a><span id="l22.441">       s += this._prettyHeaderString(nextIndent);</span>
<a href="#l22.442"></a><span id="l22.442"> </span>
<a href="#l22.443"></a><span id="l22.443">     for (let iPart = 0; iPart &lt; this.parts.length; iPart++) {</span>
<a href="#l22.444"></a><span id="l22.444">       let part = this.parts[iPart];</span>
<a href="#l22.445"></a><span id="l22.445" class="difflineminus">-      s += &quot;\n&quot; + nextIndent + (iPart+1) + &quot; &quot; +</span>
<a href="#l22.446"></a><span id="l22.446" class="difflineplus">+      s += &quot;\n&quot; + nextIndent + (iPart + 1) + &quot; &quot; +</span>
<a href="#l22.447"></a><span id="l22.447">         part.prettyString(aVerbose, nextIndent, aDumpBody);</span>
<a href="#l22.448"></a><span id="l22.448">     }</span>
<a href="#l22.449"></a><span id="l22.449"> </span>
<a href="#l22.450"></a><span id="l22.450">     return s;</span>
<a href="#l22.451"></a><span id="l22.451">   },</span>
<a href="#l22.452"></a><span id="l22.452" class="difflineminus">-  toString: function MimeContainer_toString() {</span>
<a href="#l22.453"></a><span id="l22.453" class="difflineplus">+  toString() {</span>
<a href="#l22.454"></a><span id="l22.454">     return &quot;Container: &quot; + this.contentType;</span>
<a href="#l22.455"></a><span id="l22.455" class="difflineminus">-  }</span>
<a href="#l22.456"></a><span id="l22.456" class="difflineplus">+  },</span>
<a href="#l22.457"></a><span id="l22.457"> };</span>
<a href="#l22.458"></a><span id="l22.458"> </span>
<a href="#l22.459"></a><span id="l22.459"> /**</span>
<a href="#l22.460"></a><span id="l22.460">  * @class Represents a body portion that we understand and do not believe to be</span>
<a href="#l22.461"></a><span id="l22.461">  *  a proper attachment.  This means text/plain or text/html and it has no</span>
<a href="#l22.462"></a><span id="l22.462">  *  filename.  (A filename suggests an attachment.)</span>
<a href="#l22.463"></a><span id="l22.463">  *</span>
<a href="#l22.464"></a><span id="l22.464">  * @ivar contentType The content type of this body materal; text/plain or</span>
<a href="#l22.465"></a><span id="l22.465" class="difflineat">@@ -563,43 +549,42 @@ MimeBody.prototype = {</span>
<a href="#l22.466"></a><span id="l22.466">     return []; // we are a leaf</span>
<a href="#l22.467"></a><span id="l22.467">   },</span>
<a href="#l22.468"></a><span id="l22.468">   get allUserAttachments() {</span>
<a href="#l22.469"></a><span id="l22.469">     return []; // we are a leaf</span>
<a href="#l22.470"></a><span id="l22.470">   },</span>
<a href="#l22.471"></a><span id="l22.471">   get size() {</span>
<a href="#l22.472"></a><span id="l22.472">     return this.body.length;</span>
<a href="#l22.473"></a><span id="l22.473">   },</span>
<a href="#l22.474"></a><span id="l22.474" class="difflineminus">-  set size (whatever) {</span>
<a href="#l22.475"></a><span id="l22.475" class="difflineplus">+  set size(whatever) {</span>
<a href="#l22.476"></a><span id="l22.476">     // nop</span>
<a href="#l22.477"></a><span id="l22.477">   },</span>
<a href="#l22.478"></a><span id="l22.478" class="difflineminus">-  appendBody: function MimeBody_append(aBuf) {</span>
<a href="#l22.479"></a><span id="l22.479" class="difflineplus">+  appendBody(aBuf) {</span>
<a href="#l22.480"></a><span id="l22.480">     this.body += aBuf;</span>
<a href="#l22.481"></a><span id="l22.481">   },</span>
<a href="#l22.482"></a><span id="l22.482" class="difflineminus">-  coerceBodyToPlaintext:</span>
<a href="#l22.483"></a><span id="l22.483" class="difflineminus">-      function MimeBody_coerceBodyToPlaintext(aMsgFolder) {</span>
<a href="#l22.484"></a><span id="l22.484" class="difflineplus">+  coerceBodyToPlaintext(aMsgFolder) {</span>
<a href="#l22.485"></a><span id="l22.485">     if (this.contentType == &quot;text/plain&quot;)</span>
<a href="#l22.486"></a><span id="l22.486">       return this.body;</span>
<a href="#l22.487"></a><span id="l22.487">     // text/enriched gets transformed into HTML by libmime</span>
<a href="#l22.488"></a><span id="l22.488">     if (this.contentType == &quot;text/html&quot; ||</span>
<a href="#l22.489"></a><span id="l22.489">         this.contentType == &quot;text/enriched&quot;)</span>
<a href="#l22.490"></a><span id="l22.490">       return aMsgFolder.convertMsgSnippetToPlainText(this.body);</span>
<a href="#l22.491"></a><span id="l22.491">     return &quot;&quot;;</span>
<a href="#l22.492"></a><span id="l22.492">   },</span>
<a href="#l22.493"></a><span id="l22.493" class="difflineminus">-  prettyString: function MimeBody_prettyString(aVerbose, aIndent, aDumpBody) {</span>
<a href="#l22.494"></a><span id="l22.494" class="difflineminus">-    let s = &quot;Body: &quot;+(this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;)+</span>
<a href="#l22.495"></a><span id="l22.495" class="difflineplus">+  prettyString(aVerbose, aIndent, aDumpBody) {</span>
<a href="#l22.496"></a><span id="l22.496" class="difflineplus">+    let s = &quot;Body: &quot; + (this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;) +</span>
<a href="#l22.497"></a><span id="l22.497">       &quot;&quot; + this.contentType + &quot; (&quot; + this.body.length + &quot; bytes&quot; +</span>
<a href="#l22.498"></a><span id="l22.498">       (aDumpBody ? (&quot;: '&quot; + this.body + &quot;'&quot;) : &quot;&quot;) + &quot;)&quot;;</span>
<a href="#l22.499"></a><span id="l22.499">     if (aVerbose)</span>
<a href="#l22.500"></a><span id="l22.500">       s += this._prettyHeaderString(aIndent + &quot;  &quot;);</span>
<a href="#l22.501"></a><span id="l22.501">     return s;</span>
<a href="#l22.502"></a><span id="l22.502">   },</span>
<a href="#l22.503"></a><span id="l22.503" class="difflineminus">-  toString: function MimeBody_toString() {</span>
<a href="#l22.504"></a><span id="l22.504" class="difflineplus">+  toString() {</span>
<a href="#l22.505"></a><span id="l22.505">     return &quot;Body: &quot; + this.contentType + &quot; (&quot; + this.body.length + &quot; bytes)&quot;;</span>
<a href="#l22.506"></a><span id="l22.506" class="difflineminus">-  }</span>
<a href="#l22.507"></a><span id="l22.507" class="difflineplus">+  },</span>
<a href="#l22.508"></a><span id="l22.508"> };</span>
<a href="#l22.509"></a><span id="l22.509"> </span>
<a href="#l22.510"></a><span id="l22.510"> /**</span>
<a href="#l22.511"></a><span id="l22.511">  * @class A MIME Leaf node that doesn't have a filename so we assume it's not</span>
<a href="#l22.512"></a><span id="l22.512">  *  intended to be an attachment proper.  This is probably meant for inline</span>
<a href="#l22.513"></a><span id="l22.513">  *  display or is the result of someone amusing themselves by composing messages</span>
<a href="#l22.514"></a><span id="l22.514">  *  by hand or a bad client.  This class should probably be renamed or we should</span>
<a href="#l22.515"></a><span id="l22.515">  *  introduce a better named class that we try and use in preference to this</span>
<a href="#l22.516"></a><span id="l22.516" class="difflineat">@@ -635,35 +620,34 @@ MimeUnknown.prototype = {</span>
<a href="#l22.517"></a><span id="l22.517">   },</span>
<a href="#l22.518"></a><span id="l22.518">   get size() {</span>
<a href="#l22.519"></a><span id="l22.519">     return this._size + this.parts.map(child =&gt; child.size)</span>
<a href="#l22.520"></a><span id="l22.520">       .reduce((a, b) =&gt; a + Math.max(b, 0), 0);</span>
<a href="#l22.521"></a><span id="l22.521">   },</span>
<a href="#l22.522"></a><span id="l22.522">   set size(aSize) {</span>
<a href="#l22.523"></a><span id="l22.523">     this._size = aSize;</span>
<a href="#l22.524"></a><span id="l22.524">   },</span>
<a href="#l22.525"></a><span id="l22.525" class="difflineminus">-  prettyString: function MimeUnknown_prettyString(aVerbose, aIndent,</span>
<a href="#l22.526"></a><span id="l22.526" class="difflineminus">-                                                  aDumpBody) {</span>
<a href="#l22.527"></a><span id="l22.527" class="difflineplus">+  prettyString(aVerbose, aIndent, aDumpBody) {</span>
<a href="#l22.528"></a><span id="l22.528">     let nextIndent = aIndent + &quot;  &quot;;</span>
<a href="#l22.529"></a><span id="l22.529"> </span>
<a href="#l22.530"></a><span id="l22.530" class="difflineminus">-    let s = &quot;Unknown: &quot;+(this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;)+</span>
<a href="#l22.531"></a><span id="l22.531" class="difflineplus">+    let s = &quot;Unknown: &quot; + (this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;) +</span>
<a href="#l22.532"></a><span id="l22.532">       &quot;&quot; + this.contentType + &quot; (&quot; + this.size + &quot; bytes)&quot;;</span>
<a href="#l22.533"></a><span id="l22.533">     if (aVerbose)</span>
<a href="#l22.534"></a><span id="l22.534">       s += this._prettyHeaderString(aIndent + &quot;  &quot;);</span>
<a href="#l22.535"></a><span id="l22.535"> </span>
<a href="#l22.536"></a><span id="l22.536">     for (let iPart = 0; iPart &lt; this.parts.length; iPart++) {</span>
<a href="#l22.537"></a><span id="l22.537">       let part = this.parts[iPart];</span>
<a href="#l22.538"></a><span id="l22.538" class="difflineminus">-      s += &quot;\n&quot; + nextIndent + (iPart+1) + &quot; &quot; +</span>
<a href="#l22.539"></a><span id="l22.539" class="difflineplus">+      s += &quot;\n&quot; + nextIndent + (iPart + 1) + &quot; &quot; +</span>
<a href="#l22.540"></a><span id="l22.540">         (part ? part.prettyString(aVerbose, nextIndent, aDumpBody) : &quot;NULL&quot;);</span>
<a href="#l22.541"></a><span id="l22.541">     }</span>
<a href="#l22.542"></a><span id="l22.542">     return s;</span>
<a href="#l22.543"></a><span id="l22.543">   },</span>
<a href="#l22.544"></a><span id="l22.544" class="difflineminus">-  toString: function MimeUnknown_toString() {</span>
<a href="#l22.545"></a><span id="l22.545" class="difflineplus">+  toString() {</span>
<a href="#l22.546"></a><span id="l22.546">     return &quot;Unknown: &quot; + this.contentType;</span>
<a href="#l22.547"></a><span id="l22.547" class="difflineminus">-  }</span>
<a href="#l22.548"></a><span id="l22.548" class="difflineplus">+  },</span>
<a href="#l22.549"></a><span id="l22.549"> };</span>
<a href="#l22.550"></a><span id="l22.550"> </span>
<a href="#l22.551"></a><span id="l22.551"> /**</span>
<a href="#l22.552"></a><span id="l22.552">  * @class An attachment proper.  We think it's an attachment because it has a</span>
<a href="#l22.553"></a><span id="l22.553">  *  filename that libmime was able to figure out.</span>
<a href="#l22.554"></a><span id="l22.554">  *</span>
<a href="#l22.555"></a><span id="l22.555">  * @ivar partName @see{MimeMessage.partName}</span>
<a href="#l22.556"></a><span id="l22.556">  * @ivar name The filename of this attachment.</span>
<a href="#l22.557"></a><span id="l22.557" class="difflineat">@@ -694,21 +678,19 @@ MimeMessageAttachment.prototype = {</span>
<a href="#l22.558"></a><span id="l22.558">     return true;</span>
<a href="#l22.559"></a><span id="l22.559">   },</span>
<a href="#l22.560"></a><span id="l22.560">   get allAttachments() {</span>
<a href="#l22.561"></a><span id="l22.561">     return [this]; // we are a leaf, so just us.</span>
<a href="#l22.562"></a><span id="l22.562">   },</span>
<a href="#l22.563"></a><span id="l22.563">   get allUserAttachments() {</span>
<a href="#l22.564"></a><span id="l22.564">     return [this];</span>
<a href="#l22.565"></a><span id="l22.565">   },</span>
<a href="#l22.566"></a><span id="l22.566" class="difflineminus">-  prettyString: function MimeMessageAttachment_prettyString(aVerbose, aIndent,</span>
<a href="#l22.567"></a><span id="l22.567" class="difflineminus">-                                                            aDumpBody) {</span>
<a href="#l22.568"></a><span id="l22.568" class="difflineminus">-    let s = &quot;Attachment &quot;+(this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;)+</span>
<a href="#l22.569"></a><span id="l22.569" class="difflineminus">-      &quot;(&quot; + this.size+&quot; bytes): &quot;</span>
<a href="#l22.570"></a><span id="l22.570" class="difflineminus">-      + this.name + &quot;, &quot; + this.contentType;</span>
<a href="#l22.571"></a><span id="l22.571" class="difflineplus">+  prettyString(aVerbose, aIndent, aDumpBody) {</span>
<a href="#l22.572"></a><span id="l22.572" class="difflineplus">+    let s = &quot;Attachment &quot; + (this.isEncrypted ? &quot;[encrypted] &quot; : &quot;&quot;) +</span>
<a href="#l22.573"></a><span id="l22.573" class="difflineplus">+      &quot;(&quot; + this.size + &quot; bytes): &quot; + this.name + &quot;, &quot; + this.contentType;</span>
<a href="#l22.574"></a><span id="l22.574">     if (aVerbose)</span>
<a href="#l22.575"></a><span id="l22.575">       s += this._prettyHeaderString(aIndent + &quot;  &quot;);</span>
<a href="#l22.576"></a><span id="l22.576">     return s;</span>
<a href="#l22.577"></a><span id="l22.577">   },</span>
<a href="#l22.578"></a><span id="l22.578" class="difflineminus">-  toString: function MimeMessageAttachment_toString() {</span>
<a href="#l22.579"></a><span id="l22.579" class="difflineplus">+  toString() {</span>
<a href="#l22.580"></a><span id="l22.580">     return this.prettyString(false, &quot;&quot;);</span>
<a href="#l22.581"></a><span id="l22.581">   },</span>
<a href="#l22.582"></a><span id="l22.582"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mailnews/db/gloda/modules/msg_search.js</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/msg_search.js</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -87,18 +87,17 @@ var NUEVO_FULLTEXT_SQL =</span>
<a href="#l23.4"></a><span id="l23.4"> </span>
<a href="#l23.5"></a><span id="l23.5"> function identityFunc(x) {</span>
<a href="#l23.6"></a><span id="l23.6">   return x;</span>
<a href="#l23.7"></a><span id="l23.7"> }</span>
<a href="#l23.8"></a><span id="l23.8"> </span>
<a href="#l23.9"></a><span id="l23.9"> function oneLessMaxZero(x) {</span>
<a href="#l23.10"></a><span id="l23.10">   if (x &lt;= 1)</span>
<a href="#l23.11"></a><span id="l23.11">     return 0;</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-  else</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineminus">-    return x - 1;</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineplus">+  return x - 1;</span>
<a href="#l23.15"></a><span id="l23.15"> }</span>
<a href="#l23.16"></a><span id="l23.16"> </span>
<a href="#l23.17"></a><span id="l23.17"> function reduceSum(accum, curValue) {</span>
<a href="#l23.18"></a><span id="l23.18">   return accum + curValue;</span>
<a href="#l23.19"></a><span id="l23.19"> }</span>
<a href="#l23.20"></a><span id="l23.20"> </span>
<a href="#l23.21"></a><span id="l23.21"> /*</span>
<a href="#l23.22"></a><span id="l23.22">  * Columns are: body, subject, attachment names, author, recipients</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineat">@@ -145,19 +144,19 @@ function scoreOffsets(aMessage, aContext</span>
<a href="#l23.24"></a><span id="l23.24">                              termTemplate.concat(),</span>
<a href="#l23.25"></a><span id="l23.25">                              termTemplate.concat(),</span>
<a href="#l23.26"></a><span id="l23.26">                              termTemplate.concat()];</span>
<a href="#l23.27"></a><span id="l23.27"> </span>
<a href="#l23.28"></a><span id="l23.28">   // we need a friendlyParseInt because otherwise the radix stuff happens</span>
<a href="#l23.29"></a><span id="l23.29">   //  because of the extra arguments map parses.  curse you, map!</span>
<a href="#l23.30"></a><span id="l23.30">   let offsetNums =</span>
<a href="#l23.31"></a><span id="l23.31">     aContext.stashedColumns[aMessage.id][0].split(&quot; &quot;).map(x =&gt; parseInt(x));</span>
<a href="#l23.32"></a><span id="l23.32" class="difflineminus">-  for (let i=0; i &lt; offsetNums.length; i += 4) {</span>
<a href="#l23.33"></a><span id="l23.33" class="difflineplus">+  for (let i = 0; i &lt; offsetNums.length; i += 4) {</span>
<a href="#l23.34"></a><span id="l23.34">     let columnIndex = offsetNums[i];</span>
<a href="#l23.35"></a><span id="l23.35" class="difflineminus">-    let termIndex = offsetNums[i+1];</span>
<a href="#l23.36"></a><span id="l23.36" class="difflineplus">+    let termIndex = offsetNums[i + 1];</span>
<a href="#l23.37"></a><span id="l23.37">     columnTermIncidence[columnIndex][termIndex]++;</span>
<a href="#l23.38"></a><span id="l23.38">   }</span>
<a href="#l23.39"></a><span id="l23.39"> </span>
<a href="#l23.40"></a><span id="l23.40">   for (let iColumn = 0; iColumn &lt; COLUMN_ALL_MATCH_SCORES.length; iColumn++) {</span>
<a href="#l23.41"></a><span id="l23.41">     let termIncidence = columnTermIncidence[iColumn];</span>
<a href="#l23.42"></a><span id="l23.42">     // bestow all match credit</span>
<a href="#l23.43"></a><span id="l23.43">     if (termIncidence.every(identityFunc))</span>
<a href="#l23.44"></a><span id="l23.44">       score += COLUMN_ALL_MATCH_SCORES[iColumn];</span>
<a href="#l23.45"></a><span id="l23.45" class="difflineat">@@ -205,17 +204,17 @@ GlodaMsgSearcher.prototype = {</span>
<a href="#l23.46"></a><span id="l23.46">     return Services.prefs.getIntPref(</span>
<a href="#l23.47"></a><span id="l23.47">       &quot;mailnews.database.global.search.msg.limit&quot;</span>
<a href="#l23.48"></a><span id="l23.48">     );</span>
<a href="#l23.49"></a><span id="l23.49">   },</span>
<a href="#l23.50"></a><span id="l23.50"> </span>
<a href="#l23.51"></a><span id="l23.51">   /**</span>
<a href="#l23.52"></a><span id="l23.52">    * Parse the string into terms/phrases by finding matching double-quotes.</span>
<a href="#l23.53"></a><span id="l23.53">    */</span>
<a href="#l23.54"></a><span id="l23.54" class="difflineminus">-  parseSearchString: function GlodaMsgSearcher_parseSearchString(aSearchString) {</span>
<a href="#l23.55"></a><span id="l23.55" class="difflineplus">+  parseSearchString(aSearchString) {</span>
<a href="#l23.56"></a><span id="l23.56">     aSearchString = aSearchString.trim();</span>
<a href="#l23.57"></a><span id="l23.57">     let terms = [];</span>
<a href="#l23.58"></a><span id="l23.58"> </span>
<a href="#l23.59"></a><span id="l23.59">     /*</span>
<a href="#l23.60"></a><span id="l23.60">      * Add the term as long as the trim on the way in didn't obliterate it.</span>
<a href="#l23.61"></a><span id="l23.61">      *</span>
<a href="#l23.62"></a><span id="l23.62">      * In the future this might have other helper logic; it did once before.</span>
<a href="#l23.63"></a><span id="l23.63">      */</span>
<a href="#l23.64"></a><span id="l23.64" class="difflineat">@@ -240,30 +239,30 @@ GlodaMsgSearcher.prototype = {</span>
<a href="#l23.65"></a><span id="l23.65"> </span>
<a href="#l23.66"></a><span id="l23.66">       let spaceIndex = aSearchString.indexOf(&quot; &quot;);</span>
<a href="#l23.67"></a><span id="l23.67">       if (spaceIndex == -1) {</span>
<a href="#l23.68"></a><span id="l23.68">         addTerm(aSearchString);</span>
<a href="#l23.69"></a><span id="l23.69">         break;</span>
<a href="#l23.70"></a><span id="l23.70">       }</span>
<a href="#l23.71"></a><span id="l23.71"> </span>
<a href="#l23.72"></a><span id="l23.72">       addTerm(aSearchString.substring(0, spaceIndex));</span>
<a href="#l23.73"></a><span id="l23.73" class="difflineminus">-      aSearchString = aSearchString.substring(spaceIndex+1);</span>
<a href="#l23.74"></a><span id="l23.74" class="difflineplus">+      aSearchString = aSearchString.substring(spaceIndex + 1);</span>
<a href="#l23.75"></a><span id="l23.75">     }</span>
<a href="#l23.76"></a><span id="l23.76"> </span>
<a href="#l23.77"></a><span id="l23.77">     return terms;</span>
<a href="#l23.78"></a><span id="l23.78">   },</span>
<a href="#l23.79"></a><span id="l23.79"> </span>
<a href="#l23.80"></a><span id="l23.80" class="difflineminus">-  buildFulltextQuery: function GlodaMsgSearcher_buildFulltextQuery() {</span>
<a href="#l23.81"></a><span id="l23.81" class="difflineplus">+  buildFulltextQuery() {</span>
<a href="#l23.82"></a><span id="l23.82">     let query = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l23.83"></a><span id="l23.83">       noMagic: true,</span>
<a href="#l23.84"></a><span id="l23.84">       explicitSQL: NUEVO_FULLTEXT_SQL,</span>
<a href="#l23.85"></a><span id="l23.85">       limitClauseAlreadyIncluded: true,</span>
<a href="#l23.86"></a><span id="l23.86">       // osets is 0-based column number 14 (volatile to column changes)</span>
<a href="#l23.87"></a><span id="l23.87">       // save the offset column for extra analysis</span>
<a href="#l23.88"></a><span id="l23.88" class="difflineminus">-      stashColumns: [14]</span>
<a href="#l23.89"></a><span id="l23.89" class="difflineplus">+      stashColumns: [14],</span>
<a href="#l23.90"></a><span id="l23.90">     });</span>
<a href="#l23.91"></a><span id="l23.91"> </span>
<a href="#l23.92"></a><span id="l23.92">     let fulltextQueryString = &quot;&quot;;</span>
<a href="#l23.93"></a><span id="l23.93"> </span>
<a href="#l23.94"></a><span id="l23.94">     for (let [iTerm, term] of this.fulltextTerms.entries()) {</span>
<a href="#l23.95"></a><span id="l23.95">       if (iTerm)</span>
<a href="#l23.96"></a><span id="l23.96">         fulltextQueryString += this.andTerms ? &quot; &quot; : &quot; OR &quot;;</span>
<a href="#l23.97"></a><span id="l23.97"> </span>
<a href="#l23.98"></a><span id="l23.98" class="difflineat">@@ -279,63 +278,59 @@ GlodaMsgSearcher.prototype = {</span>
<a href="#l23.99"></a><span id="l23.99">         fulltextQueryString += term + &quot;*&quot;;</span>
<a href="#l23.100"></a><span id="l23.100">       else if (</span>
<a href="#l23.101"></a><span id="l23.101">           term.length == 2 &amp;&amp;</span>
<a href="#l23.102"></a><span id="l23.102">             term.charCodeAt(0) &gt;= 0x2000 &amp;&amp;</span>
<a href="#l23.103"></a><span id="l23.103">             term.charCodeAt(1) &gt;= 0x2000</span>
<a href="#l23.104"></a><span id="l23.104">           || term.length &gt;= 3</span>
<a href="#l23.105"></a><span id="l23.105">       )</span>
<a href="#l23.106"></a><span id="l23.106">         fulltextQueryString += '&quot;' + term + '&quot;';</span>
<a href="#l23.107"></a><span id="l23.107" class="difflineminus">-</span>
<a href="#l23.108"></a><span id="l23.108">     }</span>
<a href="#l23.109"></a><span id="l23.109"> </span>
<a href="#l23.110"></a><span id="l23.110">     query.fulltextMatches(fulltextQueryString);</span>
<a href="#l23.111"></a><span id="l23.111">     query.limit(this.retrievalLimit);</span>
<a href="#l23.112"></a><span id="l23.112"> </span>
<a href="#l23.113"></a><span id="l23.113">     return query;</span>
<a href="#l23.114"></a><span id="l23.114">   },</span>
<a href="#l23.115"></a><span id="l23.115"> </span>
<a href="#l23.116"></a><span id="l23.116" class="difflineminus">-  getCollection: function GlodaMsgSearcher_getCollection(</span>
<a href="#l23.117"></a><span id="l23.117" class="difflineminus">-      aListenerOverride, aData) {</span>
<a href="#l23.118"></a><span id="l23.118" class="difflineplus">+  getCollection(aListenerOverride, aData) {</span>
<a href="#l23.119"></a><span id="l23.119">     if (aListenerOverride)</span>
<a href="#l23.120"></a><span id="l23.120">       this.listener = aListenerOverride;</span>
<a href="#l23.121"></a><span id="l23.121"> </span>
<a href="#l23.122"></a><span id="l23.122">     this.query = this.buildFulltextQuery();</span>
<a href="#l23.123"></a><span id="l23.123">     this.collection = this.query.getCollection(this, aData);</span>
<a href="#l23.124"></a><span id="l23.124">     this.completed = false;</span>
<a href="#l23.125"></a><span id="l23.125"> </span>
<a href="#l23.126"></a><span id="l23.126">     return this.collection;</span>
<a href="#l23.127"></a><span id="l23.127">   },</span>
<a href="#l23.128"></a><span id="l23.128"> </span>
<a href="#l23.129"></a><span id="l23.129" class="difflineminus">-  sortBy: '-dascore',</span>
<a href="#l23.130"></a><span id="l23.130" class="difflineplus">+  sortBy: &quot;-dascore&quot;,</span>
<a href="#l23.131"></a><span id="l23.131"> </span>
<a href="#l23.132"></a><span id="l23.132" class="difflineminus">-  onItemsAdded: function GlodaMsgSearcher_onItemsAdded(aItems, aCollection) {</span>
<a href="#l23.133"></a><span id="l23.133" class="difflineplus">+  onItemsAdded(aItems, aCollection) {</span>
<a href="#l23.134"></a><span id="l23.134">     let newScores = Gloda.scoreNounItems(</span>
<a href="#l23.135"></a><span id="l23.135">       aItems,</span>
<a href="#l23.136"></a><span id="l23.136">       {</span>
<a href="#l23.137"></a><span id="l23.137">         terms: this.fulltextTerms,</span>
<a href="#l23.138"></a><span id="l23.138" class="difflineminus">-        stashedColumns: aCollection.stashedColumns</span>
<a href="#l23.139"></a><span id="l23.139" class="difflineplus">+        stashedColumns: aCollection.stashedColumns,</span>
<a href="#l23.140"></a><span id="l23.140">       },</span>
<a href="#l23.141"></a><span id="l23.141">       [scoreOffsets]);</span>
<a href="#l23.142"></a><span id="l23.142">     if (this.scores)</span>
<a href="#l23.143"></a><span id="l23.143">       this.scores = this.scores.concat(newScores);</span>
<a href="#l23.144"></a><span id="l23.144">     else</span>
<a href="#l23.145"></a><span id="l23.145">       this.scores = newScores;</span>
<a href="#l23.146"></a><span id="l23.146"> </span>
<a href="#l23.147"></a><span id="l23.147">     if (this.listener)</span>
<a href="#l23.148"></a><span id="l23.148">       this.listener.onItemsAdded(aItems, aCollection);</span>
<a href="#l23.149"></a><span id="l23.149">   },</span>
<a href="#l23.150"></a><span id="l23.150" class="difflineminus">-  onItemsModified: function GlodaMsgSearcher_onItemsModified(aItems,</span>
<a href="#l23.151"></a><span id="l23.151" class="difflineminus">-                                                             aCollection) {</span>
<a href="#l23.152"></a><span id="l23.152" class="difflineplus">+  onItemsModified(aItems, aCollection) {</span>
<a href="#l23.153"></a><span id="l23.153">     if (this.listener)</span>
<a href="#l23.154"></a><span id="l23.154">       this.listener.onItemsModified(aItems, aCollection);</span>
<a href="#l23.155"></a><span id="l23.155">   },</span>
<a href="#l23.156"></a><span id="l23.156" class="difflineminus">-  onItemsRemoved: function GlodaMsgSearcher_onItemsRemoved(aItems,</span>
<a href="#l23.157"></a><span id="l23.157" class="difflineminus">-                                                           aCollection) {</span>
<a href="#l23.158"></a><span id="l23.158" class="difflineplus">+  onItemsRemoved(aItems, aCollection) {</span>
<a href="#l23.159"></a><span id="l23.159">     if (this.listener)</span>
<a href="#l23.160"></a><span id="l23.160">       this.listener.onItemsRemoved(aItems, aCollection);</span>
<a href="#l23.161"></a><span id="l23.161">   },</span>
<a href="#l23.162"></a><span id="l23.162" class="difflineminus">-  onQueryCompleted: function GlodaMsgSearcher_onQueryCompleted(aCollection) {</span>
<a href="#l23.163"></a><span id="l23.163" class="difflineplus">+  onQueryCompleted(aCollection) {</span>
<a href="#l23.164"></a><span id="l23.164">     this.completed = true;</span>
<a href="#l23.165"></a><span id="l23.165">     if (this.listener)</span>
<a href="#l23.166"></a><span id="l23.166">       this.listener.onQueryCompleted(aCollection);</span>
<a href="#l23.167"></a><span id="l23.167">   },</span>
<a href="#l23.168"></a><span id="l23.168"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mailnews/db/gloda/modules/noun_freetag.js</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/noun_freetag.js</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -1,88 +1,86 @@</span>
<a href="#l24.4"></a><span id="l24.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l24.5"></a><span id="l24.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l24.6"></a><span id="l24.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l24.7"></a><span id="l24.7"> </span>
<a href="#l24.8"></a><span id="l24.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['FreeTag', 'FreeTagNoun'];</span>
<a href="#l24.9"></a><span id="l24.9" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;FreeTag&quot;, &quot;FreeTagNoun&quot;];</span>
<a href="#l24.10"></a><span id="l24.10"> </span>
<a href="#l24.11"></a><span id="l24.11"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l24.12"></a><span id="l24.12"> </span>
<a href="#l24.13"></a><span id="l24.13"> const {Gloda} = ChromeUtils.import(&quot;resource:///modules/gloda/gloda.js&quot;);</span>
<a href="#l24.14"></a><span id="l24.14"> </span>
<a href="#l24.15"></a><span id="l24.15"> function FreeTag(aTagName) {</span>
<a href="#l24.16"></a><span id="l24.16">   this.name = aTagName;</span>
<a href="#l24.17"></a><span id="l24.17"> }</span>
<a href="#l24.18"></a><span id="l24.18"> </span>
<a href="#l24.19"></a><span id="l24.19"> FreeTag.prototype = {</span>
<a href="#l24.20"></a><span id="l24.20" class="difflineminus">-  toString: function () {</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineplus">+  toString() {</span>
<a href="#l24.22"></a><span id="l24.22">     return this.name;</span>
<a href="#l24.23"></a><span id="l24.23" class="difflineminus">-  }</span>
<a href="#l24.24"></a><span id="l24.24" class="difflineplus">+  },</span>
<a href="#l24.25"></a><span id="l24.25"> };</span>
<a href="#l24.26"></a><span id="l24.26"> </span>
<a href="#l24.27"></a><span id="l24.27"> /**</span>
<a href="#l24.28"></a><span id="l24.28">  * @namespace Tag noun provider.  Since the tag unique value is stored as a</span>
<a href="#l24.29"></a><span id="l24.29">  *  parameter, we are an odd case and semantically confused.</span>
<a href="#l24.30"></a><span id="l24.30">  */</span>
<a href="#l24.31"></a><span id="l24.31"> var FreeTagNoun = {</span>
<a href="#l24.32"></a><span id="l24.32">   _log: Log4Moz.repository.getLogger(&quot;gloda.noun.freetag&quot;),</span>
<a href="#l24.33"></a><span id="l24.33"> </span>
<a href="#l24.34"></a><span id="l24.34">   name: &quot;freetag&quot;,</span>
<a href="#l24.35"></a><span id="l24.35">   clazz: FreeTag,</span>
<a href="#l24.36"></a><span id="l24.36">   allowsArbitraryAttrs: false,</span>
<a href="#l24.37"></a><span id="l24.37">   usesParameter: true,</span>
<a href="#l24.38"></a><span id="l24.38"> </span>
<a href="#l24.39"></a><span id="l24.39">   _listeners: [],</span>
<a href="#l24.40"></a><span id="l24.40" class="difflineminus">-  addListener: function(aListener) {</span>
<a href="#l24.41"></a><span id="l24.41" class="difflineplus">+  addListener(aListener) {</span>
<a href="#l24.42"></a><span id="l24.42">     this._listeners.push(aListener);</span>
<a href="#l24.43"></a><span id="l24.43">   },</span>
<a href="#l24.44"></a><span id="l24.44" class="difflineminus">-  removeListener: function(aListener) {</span>
<a href="#l24.45"></a><span id="l24.45" class="difflineplus">+  removeListener(aListener) {</span>
<a href="#l24.46"></a><span id="l24.46">     let index = this._listeners.indexOf(aListener);</span>
<a href="#l24.47"></a><span id="l24.47" class="difflineminus">-    if (index &gt;=0)</span>
<a href="#l24.48"></a><span id="l24.48" class="difflineplus">+    if (index &gt;= 0)</span>
<a href="#l24.49"></a><span id="l24.49">       this._listeners.splice(index, 1);</span>
<a href="#l24.50"></a><span id="l24.50">   },</span>
<a href="#l24.51"></a><span id="l24.51"> </span>
<a href="#l24.52"></a><span id="l24.52" class="difflineminus">-  populateKnownFreeTags: function() {</span>
<a href="#l24.53"></a><span id="l24.53" class="difflineplus">+  populateKnownFreeTags() {</span>
<a href="#l24.54"></a><span id="l24.54">     for (let attr of this.objectNounOfAttributes) {</span>
<a href="#l24.55"></a><span id="l24.55">       let attrDB = attr.dbDef;</span>
<a href="#l24.56"></a><span id="l24.56">       for (let param in attrDB.parameterBindings) {</span>
<a href="#l24.57"></a><span id="l24.57">         this.getFreeTag(param);</span>
<a href="#l24.58"></a><span id="l24.58">       }</span>
<a href="#l24.59"></a><span id="l24.59">     }</span>
<a href="#l24.60"></a><span id="l24.60">   },</span>
<a href="#l24.61"></a><span id="l24.61"> </span>
<a href="#l24.62"></a><span id="l24.62">   knownFreeTags: {},</span>
<a href="#l24.63"></a><span id="l24.63" class="difflineminus">-  getFreeTag: function(aTagName) {</span>
<a href="#l24.64"></a><span id="l24.64" class="difflineplus">+  getFreeTag(aTagName) {</span>
<a href="#l24.65"></a><span id="l24.65">     let tag = this.knownFreeTags[aTagName];</span>
<a href="#l24.66"></a><span id="l24.66">     if (!tag) {</span>
<a href="#l24.67"></a><span id="l24.67">       tag = this.knownFreeTags[aTagName] = new FreeTag(aTagName);</span>
<a href="#l24.68"></a><span id="l24.68">       for (let listener of this._listeners)</span>
<a href="#l24.69"></a><span id="l24.69">         listener.onFreeTagAdded(tag);</span>
<a href="#l24.70"></a><span id="l24.70">     }</span>
<a href="#l24.71"></a><span id="l24.71">     return tag;</span>
<a href="#l24.72"></a><span id="l24.72">   },</span>
<a href="#l24.73"></a><span id="l24.73"> </span>
<a href="#l24.74"></a><span id="l24.74" class="difflineminus">-  comparator: function gloda_noun_freetag_comparator(a, b) {</span>
<a href="#l24.75"></a><span id="l24.75" class="difflineplus">+  comparator(a, b) {</span>
<a href="#l24.76"></a><span id="l24.76">     if (a == null) {</span>
<a href="#l24.77"></a><span id="l24.77">       if (b == null)</span>
<a href="#l24.78"></a><span id="l24.78">         return 0;</span>
<a href="#l24.79"></a><span id="l24.79" class="difflineminus">-      else</span>
<a href="#l24.80"></a><span id="l24.80" class="difflineminus">-        return 1;</span>
<a href="#l24.81"></a><span id="l24.81" class="difflineminus">-    }</span>
<a href="#l24.82"></a><span id="l24.82" class="difflineminus">-    else if (b == null) {</span>
<a href="#l24.83"></a><span id="l24.83" class="difflineplus">+      return 1;</span>
<a href="#l24.84"></a><span id="l24.84" class="difflineplus">+    } else if (b == null) {</span>
<a href="#l24.85"></a><span id="l24.85">       return -1;</span>
<a href="#l24.86"></a><span id="l24.86">     }</span>
<a href="#l24.87"></a><span id="l24.87">     return a.name.localeCompare(b.name);</span>
<a href="#l24.88"></a><span id="l24.88">   },</span>
<a href="#l24.89"></a><span id="l24.89"> </span>
<a href="#l24.90"></a><span id="l24.90" class="difflineminus">-  toParamAndValue: function gloda_noun_freetag_toParamAndValue(aTag) {</span>
<a href="#l24.91"></a><span id="l24.91" class="difflineplus">+  toParamAndValue(aTag) {</span>
<a href="#l24.92"></a><span id="l24.92">     return [aTag.name, null];</span>
<a href="#l24.93"></a><span id="l24.93">   },</span>
<a href="#l24.94"></a><span id="l24.94"> </span>
<a href="#l24.95"></a><span id="l24.95" class="difflineminus">-  toJSON: function gloda_noun_freetag_toJSON(aTag) {</span>
<a href="#l24.96"></a><span id="l24.96" class="difflineplus">+  toJSON(aTag) {</span>
<a href="#l24.97"></a><span id="l24.97">     return aTag.name;</span>
<a href="#l24.98"></a><span id="l24.98">   },</span>
<a href="#l24.99"></a><span id="l24.99" class="difflineminus">-  fromJSON: function gloda_noun_freetag_fromJSON(aTagName) {</span>
<a href="#l24.100"></a><span id="l24.100" class="difflineplus">+  fromJSON(aTagName) {</span>
<a href="#l24.101"></a><span id="l24.101">     return this.getFreeTag(aTagName);</span>
<a href="#l24.102"></a><span id="l24.102">   },</span>
<a href="#l24.103"></a><span id="l24.103"> };</span>
<a href="#l24.104"></a><span id="l24.104"> </span>
<a href="#l24.105"></a><span id="l24.105"> Gloda.defineNoun(FreeTagNoun);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/db/gloda/modules/noun_mimetype.js</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/noun_mimetype.js</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -1,13 +1,13 @@</span>
<a href="#l25.4"></a><span id="l25.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l25.5"></a><span id="l25.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l25.6"></a><span id="l25.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l25.7"></a><span id="l25.7"> </span>
<a href="#l25.8"></a><span id="l25.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['MimeType', 'MimeTypeNoun'];</span>
<a href="#l25.9"></a><span id="l25.9" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;MimeType&quot;, &quot;MimeTypeNoun&quot;];</span>
<a href="#l25.10"></a><span id="l25.10"> </span>
<a href="#l25.11"></a><span id="l25.11"> const {StringBundle} = ChromeUtils.import(&quot;resource:///modules/StringBundle.js&quot;);</span>
<a href="#l25.12"></a><span id="l25.12"> const {Log4Moz} = ChromeUtils.import(&quot;resource:///modules/gloda/log4moz.js&quot;);</span>
<a href="#l25.13"></a><span id="l25.13"> var LOG = Log4Moz.repository.getLogger(&quot;gloda.noun.mimetype&quot;);</span>
<a href="#l25.14"></a><span id="l25.14"> </span>
<a href="#l25.15"></a><span id="l25.15"> const {Gloda} = ChromeUtils.import(&quot;resource:///modules/gloda/gloda.js&quot;);</span>
<a href="#l25.16"></a><span id="l25.16"> </span>
<a href="#l25.17"></a><span id="l25.17"> var CategoryStringMap = {};</span>
<a href="#l25.18"></a><span id="l25.18" class="difflineat">@@ -50,17 +50,17 @@ MimeType.prototype = {</span>
<a href="#l25.19"></a><span id="l25.19">   /**</span>
<a href="#l25.20"></a><span id="l25.20">    * If the |fullType| is &quot;text/plain&quot;, subType is &quot;plain&quot;.</span>
<a href="#l25.21"></a><span id="l25.21">    */</span>
<a href="#l25.22"></a><span id="l25.22">   get subType() { return this._subType; },</span>
<a href="#l25.23"></a><span id="l25.23">   /**</span>
<a href="#l25.24"></a><span id="l25.24">    * The full MIME type; &quot;text/plain&quot; returns &quot;text/plain&quot;.</span>
<a href="#l25.25"></a><span id="l25.25">    */</span>
<a href="#l25.26"></a><span id="l25.26">   get fullType() { return this._fullType; },</span>
<a href="#l25.27"></a><span id="l25.27" class="difflineminus">-  toString: function () {</span>
<a href="#l25.28"></a><span id="l25.28" class="difflineplus">+  toString() {</span>
<a href="#l25.29"></a><span id="l25.29">     return this.fullType;</span>
<a href="#l25.30"></a><span id="l25.30">   },</span>
<a href="#l25.31"></a><span id="l25.31"> </span>
<a href="#l25.32"></a><span id="l25.32">   /**</span>
<a href="#l25.33"></a><span id="l25.33">    * @return the category we believe this mime type belongs to.  This category</span>
<a href="#l25.34"></a><span id="l25.34">    *     name should never be shown directly to the user.  Instead, use</span>
<a href="#l25.35"></a><span id="l25.35">    *     |categoryLabel| to get the localized name for the category.  The</span>
<a href="#l25.36"></a><span id="l25.36">    *     category mapping comes from mimeTypesCategories.js.</span>
<a href="#l25.37"></a><span id="l25.37" class="difflineat">@@ -70,17 +70,17 @@ MimeType.prototype = {</span>
<a href="#l25.38"></a><span id="l25.38">   },</span>
<a href="#l25.39"></a><span id="l25.39">   /**</span>
<a href="#l25.40"></a><span id="l25.40">    * @return The localized label for the category from gloda.properties in the</span>
<a href="#l25.41"></a><span id="l25.41">    *     &quot;gloda.mimetype.category.CATEGORY.label&quot; definition using the value</span>
<a href="#l25.42"></a><span id="l25.42">    *     from |category|.</span>
<a href="#l25.43"></a><span id="l25.43">    */</span>
<a href="#l25.44"></a><span id="l25.44">   get categoryLabel() {</span>
<a href="#l25.45"></a><span id="l25.45">     return CategoryStringMap[this._category];</span>
<a href="#l25.46"></a><span id="l25.46" class="difflineminus">-  }</span>
<a href="#l25.47"></a><span id="l25.47" class="difflineplus">+  },</span>
<a href="#l25.48"></a><span id="l25.48"> };</span>
<a href="#l25.49"></a><span id="l25.49"> </span>
<a href="#l25.50"></a><span id="l25.50"> /**</span>
<a href="#l25.51"></a><span id="l25.51">  * Mime type noun provider.</span>
<a href="#l25.52"></a><span id="l25.52">  *</span>
<a href="#l25.53"></a><span id="l25.53">  * The set of MIME Types is sufficiently limited that we can keep them all in</span>
<a href="#l25.54"></a><span id="l25.54">  *  memory.  In theory it is also sufficiently limited that we could use the</span>
<a href="#l25.55"></a><span id="l25.55">  *  parameter mechanism in the database.  However, it is more efficient, for</span>
<a href="#l25.56"></a><span id="l25.56" class="difflineat">@@ -103,39 +103,38 @@ var MimeTypeNoun = {</span>
<a href="#l25.57"></a><span id="l25.57">   TYPE_BLOCK_SIZE: 16384,</span>
<a href="#l25.58"></a><span id="l25.58">   _mimeTypeHighID: {},</span>
<a href="#l25.59"></a><span id="l25.59">   _mimeTypeRangeDummyObjects: {},</span>
<a href="#l25.60"></a><span id="l25.60">   _highID: 0,</span>
<a href="#l25.61"></a><span id="l25.61"> </span>
<a href="#l25.62"></a><span id="l25.62">   // we now use the exciting 'schema' mechanism of defineNoun to get our table</span>
<a href="#l25.63"></a><span id="l25.63">   //  created for us, plus some helper methods that we simply don't use.</span>
<a href="#l25.64"></a><span id="l25.64">   schema: {</span>
<a href="#l25.65"></a><span id="l25.65" class="difflineminus">-    name: 'mimeTypes',</span>
<a href="#l25.66"></a><span id="l25.66" class="difflineminus">-    columns: [['id', 'INTEGER PRIMARY KEY', '_id'],</span>
<a href="#l25.67"></a><span id="l25.67" class="difflineminus">-              ['mimeType', 'TEXT', 'fullType']],</span>
<a href="#l25.68"></a><span id="l25.68" class="difflineplus">+    name: &quot;mimeTypes&quot;,</span>
<a href="#l25.69"></a><span id="l25.69" class="difflineplus">+    columns: [[&quot;id&quot;, &quot;INTEGER PRIMARY KEY&quot;, &quot;_id&quot;],</span>
<a href="#l25.70"></a><span id="l25.70" class="difflineplus">+              [&quot;mimeType&quot;, &quot;TEXT&quot;, &quot;fullType&quot;]],</span>
<a href="#l25.71"></a><span id="l25.71">   },</span>
<a href="#l25.72"></a><span id="l25.72"> </span>
<a href="#l25.73"></a><span id="l25.73" class="difflineminus">-  _init: function() {</span>
<a href="#l25.74"></a><span id="l25.74" class="difflineplus">+  _init() {</span>
<a href="#l25.75"></a><span id="l25.75">     LOG.debug(&quot;loading MIME types&quot;);</span>
<a href="#l25.76"></a><span id="l25.76">     this._loadCategoryMapping();</span>
<a href="#l25.77"></a><span id="l25.77">     this._loadMimeTypes();</span>
<a href="#l25.78"></a><span id="l25.78">   },</span>
<a href="#l25.79"></a><span id="l25.79"> </span>
<a href="#l25.80"></a><span id="l25.80">   /**</span>
<a href="#l25.81"></a><span id="l25.81">    * A map from MIME type to category name.</span>
<a href="#l25.82"></a><span id="l25.82">    */</span>
<a href="#l25.83"></a><span id="l25.83">   _mimeTypeToCategory: {},</span>
<a href="#l25.84"></a><span id="l25.84">   /**</span>
<a href="#l25.85"></a><span id="l25.85">    * Load the contents of mimeTypeCategories.js and populate</span>
<a href="#l25.86"></a><span id="l25.86">    */</span>
<a href="#l25.87"></a><span id="l25.87" class="difflineminus">-  _loadCategoryMapping: function MimeTypeNoun__loadCategoryMapping() {</span>
<a href="#l25.88"></a><span id="l25.88" class="difflineminus">-    let mimecatNS = {};</span>
<a href="#l25.89"></a><span id="l25.89" class="difflineminus">-    ChromeUtils.import(&quot;resource:///modules/gloda/mimeTypeCategories.js&quot;,</span>
<a href="#l25.90"></a><span id="l25.90" class="difflineminus">-              mimecatNS);</span>
<a href="#l25.91"></a><span id="l25.91" class="difflineminus">-    let mcm = mimecatNS.MimeCategoryMapping;</span>
<a href="#l25.92"></a><span id="l25.92" class="difflineplus">+  _loadCategoryMapping() {</span>
<a href="#l25.93"></a><span id="l25.93" class="difflineplus">+    let {</span>
<a href="#l25.94"></a><span id="l25.94" class="difflineplus">+      MimeCategoryMapping,</span>
<a href="#l25.95"></a><span id="l25.95" class="difflineplus">+    } = ChromeUtils.import(&quot;resource:///modules/gloda/mimeTypeCategories.js&quot;);</span>
<a href="#l25.96"></a><span id="l25.96"> </span>
<a href="#l25.97"></a><span id="l25.97">     let mimeTypeToCategory = this._mimeTypeToCategory;</span>
<a href="#l25.98"></a><span id="l25.98"> </span>
<a href="#l25.99"></a><span id="l25.99">     function procMapObj(aSubTree, aCategories) {</span>
<a href="#l25.100"></a><span id="l25.100">       for (let key in aSubTree) {</span>
<a href="#l25.101"></a><span id="l25.101">         let value = aSubTree[key];</span>
<a href="#l25.102"></a><span id="l25.102">         // Add this category to our nested categories list.  Use concat since</span>
<a href="#l25.103"></a><span id="l25.103">         //  the list will be long-lived and each list needs to be distinct.</span>
<a href="#l25.104"></a><span id="l25.104" class="difflineat">@@ -148,33 +147,30 @@ var MimeTypeNoun = {</span>
<a href="#l25.105"></a><span id="l25.105">               &quot;gloda.mimetype.category.&quot; + key + &quot;.label&quot;);</span>
<a href="#l25.106"></a><span id="l25.106">         }</span>
<a href="#l25.107"></a><span id="l25.107"> </span>
<a href="#l25.108"></a><span id="l25.108">         // Is it an array? If so, just process this depth</span>
<a href="#l25.109"></a><span id="l25.109">         if (Array.isArray(value)) {</span>
<a href="#l25.110"></a><span id="l25.110">           for (let mimeTypeStr of value) {</span>
<a href="#l25.111"></a><span id="l25.111">             mimeTypeToCategory[mimeTypeStr] = categories;</span>
<a href="#l25.112"></a><span id="l25.112">           }</span>
<a href="#l25.113"></a><span id="l25.113" class="difflineminus">-        }</span>
<a href="#l25.114"></a><span id="l25.114" class="difflineminus">-        // it's yet another sub-tree branch</span>
<a href="#l25.115"></a><span id="l25.115" class="difflineminus">-        else {</span>
<a href="#l25.116"></a><span id="l25.116" class="difflineplus">+        } else { // it's yet another sub-tree branch</span>
<a href="#l25.117"></a><span id="l25.117">           procMapObj(value, categories);</span>
<a href="#l25.118"></a><span id="l25.118">         }</span>
<a href="#l25.119"></a><span id="l25.119">       }</span>
<a href="#l25.120"></a><span id="l25.120">     }</span>
<a href="#l25.121"></a><span id="l25.121"> </span>
<a href="#l25.122"></a><span id="l25.122" class="difflineminus">-    procMapObj(mimecatNS.MimeCategoryMapping, []);</span>
<a href="#l25.123"></a><span id="l25.123" class="difflineplus">+    procMapObj(MimeCategoryMapping, []);</span>
<a href="#l25.124"></a><span id="l25.124">   },</span>
<a href="#l25.125"></a><span id="l25.125"> </span>
<a href="#l25.126"></a><span id="l25.126">   /**</span>
<a href="#l25.127"></a><span id="l25.127">    * Lookup the category associated with a MIME type given its full type and</span>
<a href="#l25.128"></a><span id="l25.128">    *  type.  (So, &quot;foo/bar&quot; and &quot;foo&quot; for &quot;foo/bar&quot;.)</span>
<a href="#l25.129"></a><span id="l25.129">    */</span>
<a href="#l25.130"></a><span id="l25.130" class="difflineminus">-  _getCategoryForMimeType:</span>
<a href="#l25.131"></a><span id="l25.131" class="difflineminus">-      function MimeTypeNoun__getCategoryForMimeType(aFullType, aType) {</span>
<a href="#l25.132"></a><span id="l25.132" class="difflineplus">+  _getCategoryForMimeType(aFullType, aType) {</span>
<a href="#l25.133"></a><span id="l25.133">     if (aFullType in this._mimeTypeToCategory)</span>
<a href="#l25.134"></a><span id="l25.134">       return this._mimeTypeToCategory[aFullType][0];</span>
<a href="#l25.135"></a><span id="l25.135">     let wildType = aType + &quot;/*&quot;;</span>
<a href="#l25.136"></a><span id="l25.136">     if (wildType in this._mimeTypeToCategory)</span>
<a href="#l25.137"></a><span id="l25.137">       return this._mimeTypeToCategory[wildType][0];</span>
<a href="#l25.138"></a><span id="l25.138">     return this._mimeTypeToCategory[&quot;*&quot;][0];</span>
<a href="#l25.139"></a><span id="l25.139">   },</span>
<a href="#l25.140"></a><span id="l25.140"> </span>
<a href="#l25.141"></a><span id="l25.141" class="difflineat">@@ -187,70 +183,69 @@ var MimeTypeNoun = {</span>
<a href="#l25.142"></a><span id="l25.142">    *  MIME types are created, we add them to the collection.</span>
<a href="#l25.143"></a><span id="l25.143">    */</span>
<a href="#l25.144"></a><span id="l25.144">   _universalCollection: null,</span>
<a href="#l25.145"></a><span id="l25.145"> </span>
<a href="#l25.146"></a><span id="l25.146">   /**</span>
<a href="#l25.147"></a><span id="l25.147">    * Kick off a query of all the mime types in our database, leaving</span>
<a href="#l25.148"></a><span id="l25.148">    *  |_processMimeTypes| to actually do the legwork.</span>
<a href="#l25.149"></a><span id="l25.149">    */</span>
<a href="#l25.150"></a><span id="l25.150" class="difflineminus">-  _loadMimeTypes: function MimeTypeNoun__loadMimeTypes() {</span>
<a href="#l25.151"></a><span id="l25.151" class="difflineplus">+  _loadMimeTypes() {</span>
<a href="#l25.152"></a><span id="l25.152">     // get all the existing mime types!</span>
<a href="#l25.153"></a><span id="l25.153">     let query = Gloda.newQuery(this.id);</span>
<a href="#l25.154"></a><span id="l25.154">     let nullFunc = function() {};</span>
<a href="#l25.155"></a><span id="l25.155">     this._universalCollection = query.getCollection({</span>
<a href="#l25.156"></a><span id="l25.156">       onItemsAdded: nullFunc, onItemsModified: nullFunc,</span>
<a href="#l25.157"></a><span id="l25.157">       onItemsRemoved: nullFunc,</span>
<a href="#l25.158"></a><span id="l25.158" class="difflineminus">-      onQueryCompleted: function (aCollection) {</span>
<a href="#l25.159"></a><span id="l25.159" class="difflineplus">+      onQueryCompleted(aCollection) {</span>
<a href="#l25.160"></a><span id="l25.160">         MimeTypeNoun._processMimeTypes(aCollection.items);</span>
<a href="#l25.161"></a><span id="l25.161" class="difflineminus">-      }</span>
<a href="#l25.162"></a><span id="l25.162" class="difflineplus">+      },</span>
<a href="#l25.163"></a><span id="l25.163">     }, null);</span>
<a href="#l25.164"></a><span id="l25.164">   },</span>
<a href="#l25.165"></a><span id="l25.165"> </span>
<a href="#l25.166"></a><span id="l25.166">   /**</span>
<a href="#l25.167"></a><span id="l25.167">    * For the benefit of our Category queryHelper, we need dummy ranged objects</span>
<a href="#l25.168"></a><span id="l25.168">    *  that cover the numerical address space allocated to the category.  We</span>
<a href="#l25.169"></a><span id="l25.169">    *  can't use a real object for the upper-bound because the upper-bound is</span>
<a href="#l25.170"></a><span id="l25.170">    *  constantly growing and there is the chance the query might get persisted,</span>
<a href="#l25.171"></a><span id="l25.171">    *  which means these values need to be long-lived.  Unfortunately, our</span>
<a href="#l25.172"></a><span id="l25.172">    *  solution to this problem (dummy objects) complicates the second case,</span>
<a href="#l25.173"></a><span id="l25.173">    *  should it ever occur.  (Because the dummy objects cannot be persisted</span>
<a href="#l25.174"></a><span id="l25.174">    *  on their own... but there are other issues that will come up that we will</span>
<a href="#l25.175"></a><span id="l25.175">    *  just have to deal with then.)</span>
<a href="#l25.176"></a><span id="l25.176">    */</span>
<a href="#l25.177"></a><span id="l25.177" class="difflineminus">-  _createCategoryDummies: function (aId, aCategory) {</span>
<a href="#l25.178"></a><span id="l25.178" class="difflineplus">+  _createCategoryDummies(aId, aCategory) {</span>
<a href="#l25.179"></a><span id="l25.179">     let blockBottom = aId - (aId % this.TYPE_BLOCK_SIZE);</span>
<a href="#l25.180"></a><span id="l25.180">     let blockTop = blockBottom + this.TYPE_BLOCK_SIZE - 1;</span>
<a href="#l25.181"></a><span id="l25.181">     this._mimeTypeRangeDummyObjects[aCategory] = [</span>
<a href="#l25.182"></a><span id="l25.182">       new MimeType(blockBottom, &quot;!category-dummy!&quot;, aCategory,</span>
<a href="#l25.183"></a><span id="l25.183">                    &quot;!category-dummy!/&quot; + aCategory, aCategory),</span>
<a href="#l25.184"></a><span id="l25.184">       new MimeType(blockTop, &quot;!category-dummy!&quot;, aCategory,</span>
<a href="#l25.185"></a><span id="l25.185" class="difflineminus">-                   &quot;!category-dummy!/&quot; + aCategory, aCategory)</span>
<a href="#l25.186"></a><span id="l25.186" class="difflineplus">+                   &quot;!category-dummy!/&quot; + aCategory, aCategory),</span>
<a href="#l25.187"></a><span id="l25.187">     ];</span>
<a href="#l25.188"></a><span id="l25.188">   },</span>
<a href="#l25.189"></a><span id="l25.189"> </span>
<a href="#l25.190"></a><span id="l25.190" class="difflineminus">-  _processMimeTypes: function MimeTypeNoun__processMimeTypes(aMimeTypes) {</span>
<a href="#l25.191"></a><span id="l25.191" class="difflineplus">+  _processMimeTypes(aMimeTypes) {</span>
<a href="#l25.192"></a><span id="l25.192">     for (let mimeType of aMimeTypes) {</span>
<a href="#l25.193"></a><span id="l25.193">       if (mimeType.id &gt; this._highID)</span>
<a href="#l25.194"></a><span id="l25.194">         this._highID = mimeType.id;</span>
<a href="#l25.195"></a><span id="l25.195">       this._mimeTypes[mimeType] = mimeType;</span>
<a href="#l25.196"></a><span id="l25.196">       this._mimeTypesByID[mimeType.id] = mimeType;</span>
<a href="#l25.197"></a><span id="l25.197"> </span>
<a href="#l25.198"></a><span id="l25.198" class="difflineminus">-      let typeBlock = mimeType.id - (mimeType.id % this.TYPE_BLOCK_SIZE);</span>
<a href="#l25.199"></a><span id="l25.199">       let blockHighID = (mimeType.category in this._mimeTypeHighID) ?</span>
<a href="#l25.200"></a><span id="l25.200">                           this._mimeTypeHighID[mimeType.category] : undefined;</span>
<a href="#l25.201"></a><span id="l25.201">       // create the dummy range objects</span>
<a href="#l25.202"></a><span id="l25.202">       if (blockHighID === undefined)</span>
<a href="#l25.203"></a><span id="l25.203">         this._createCategoryDummies(mimeType.id, mimeType.category);</span>
<a href="#l25.204"></a><span id="l25.204">       if ((blockHighID === undefined) || mimeType.id &gt; blockHighID)</span>
<a href="#l25.205"></a><span id="l25.205">         this._mimeTypeHighID[mimeType.category] = mimeType.id;</span>
<a href="#l25.206"></a><span id="l25.206">     }</span>
<a href="#l25.207"></a><span id="l25.207">   },</span>
<a href="#l25.208"></a><span id="l25.208"> </span>
<a href="#l25.209"></a><span id="l25.209" class="difflineminus">-  _addNewMimeType: function MimeTypeNoun__addNewMimeType(aMimeTypeName) {</span>
<a href="#l25.210"></a><span id="l25.210" class="difflineplus">+  _addNewMimeType(aMimeTypeName) {</span>
<a href="#l25.211"></a><span id="l25.211">     let [typeName, subTypeName] = aMimeTypeName.split(&quot;/&quot;);</span>
<a href="#l25.212"></a><span id="l25.212">     let category = this._getCategoryForMimeType(aMimeTypeName, typeName);</span>
<a href="#l25.213"></a><span id="l25.213"> </span>
<a href="#l25.214"></a><span id="l25.214">     if (!(category in this._mimeTypeHighID)) {</span>
<a href="#l25.215"></a><span id="l25.215">       let nextID = this._highID - (this._highID % this.TYPE_BLOCK_SIZE) +</span>
<a href="#l25.216"></a><span id="l25.216">         this.TYPE_BLOCK_SIZE;</span>
<a href="#l25.217"></a><span id="l25.217">       this._mimeTypeHighID[category] = nextID;</span>
<a href="#l25.218"></a><span id="l25.218">       this._createCategoryDummies(nextID, category);</span>
<a href="#l25.219"></a><span id="l25.219" class="difflineat">@@ -280,27 +275,26 @@ var MimeTypeNoun = {</span>
<a href="#l25.220"></a><span id="l25.220"> </span>
<a href="#l25.221"></a><span id="l25.221">   /**</span>
<a href="#l25.222"></a><span id="l25.222">    * Map a mime type to a |MimeType| instance, creating it if necessary.</span>
<a href="#l25.223"></a><span id="l25.223">    *</span>
<a href="#l25.224"></a><span id="l25.224">    * @param aMimeTypeName The mime type.  It may optionally include parameters</span>
<a href="#l25.225"></a><span id="l25.225">    *     (which will be ignored).  A mime type is of the form &quot;type/subtype&quot;.</span>
<a href="#l25.226"></a><span id="l25.226">    *     A type with parameters would look like 'type/subtype; param=&quot;value&quot;'.</span>
<a href="#l25.227"></a><span id="l25.227">    */</span>
<a href="#l25.228"></a><span id="l25.228" class="difflineminus">-  getMimeType: function MimeTypeNoun_getMimeType(aMimeTypeName) {</span>
<a href="#l25.229"></a><span id="l25.229" class="difflineplus">+  getMimeType(aMimeTypeName) {</span>
<a href="#l25.230"></a><span id="l25.230">     // first, lose any parameters</span>
<a href="#l25.231"></a><span id="l25.231">     let semiIndex = aMimeTypeName.indexOf(&quot;;&quot;);</span>
<a href="#l25.232"></a><span id="l25.232">     if (semiIndex &gt;= 0)</span>
<a href="#l25.233"></a><span id="l25.233">       aMimeTypeName = aMimeTypeName.substring(0, semiIndex);</span>
<a href="#l25.234"></a><span id="l25.234">     aMimeTypeName = aMimeTypeName.trim().toLowerCase();</span>
<a href="#l25.235"></a><span id="l25.235"> </span>
<a href="#l25.236"></a><span id="l25.236">     if (aMimeTypeName in this._mimeTypes)</span>
<a href="#l25.237"></a><span id="l25.237">       return this._mimeTypes[aMimeTypeName];</span>
<a href="#l25.238"></a><span id="l25.238" class="difflineminus">-    else</span>
<a href="#l25.239"></a><span id="l25.239" class="difflineminus">-      return this._addNewMimeType(aMimeTypeName);</span>
<a href="#l25.240"></a><span id="l25.240" class="difflineplus">+    return this._addNewMimeType(aMimeTypeName);</span>
<a href="#l25.241"></a><span id="l25.241">   },</span>
<a href="#l25.242"></a><span id="l25.242"> </span>
<a href="#l25.243"></a><span id="l25.243">   /**</span>
<a href="#l25.244"></a><span id="l25.244">    * Query helpers contribute additional functions to the query object for the</span>
<a href="#l25.245"></a><span id="l25.245">    *  attributes that use the noun type.  For example, we define Category, so</span>
<a href="#l25.246"></a><span id="l25.246">    *  for the &quot;attachmentTypes&quot; attribute, &quot;attachmentTypesCategory&quot; would be</span>
<a href="#l25.247"></a><span id="l25.247">    *  exposed.</span>
<a href="#l25.248"></a><span id="l25.248">    */</span>
<a href="#l25.249"></a><span id="l25.249" class="difflineat">@@ -308,51 +302,49 @@ var MimeTypeNoun = {</span>
<a href="#l25.250"></a><span id="l25.250">     /**</span>
<a href="#l25.251"></a><span id="l25.251">      * Query for MIME type categories based on one or more MIME type objects</span>
<a href="#l25.252"></a><span id="l25.252">      *  passed in.  We want the range to span the entire block allocated to the</span>
<a href="#l25.253"></a><span id="l25.253">      *  category.</span>
<a href="#l25.254"></a><span id="l25.254">      *</span>
<a href="#l25.255"></a><span id="l25.255">      * @param aAttrDef The attribute that is using us.</span>
<a href="#l25.256"></a><span id="l25.256">      * @param aArguments The actual arguments object that</span>
<a href="#l25.257"></a><span id="l25.257">      */</span>
<a href="#l25.258"></a><span id="l25.258" class="difflineminus">-    Category: function(aAttrDef, aArguments) {</span>
<a href="#l25.259"></a><span id="l25.259" class="difflineplus">+    Category(aAttrDef, aArguments) {</span>
<a href="#l25.260"></a><span id="l25.260">       let rangePairs = [];</span>
<a href="#l25.261"></a><span id="l25.261">       // If there are no arguments then we want to fall back to the 'in'</span>
<a href="#l25.262"></a><span id="l25.262">       //  constraint which matches on any attachment.</span>
<a href="#l25.263"></a><span id="l25.263">       if (!aArguments || aArguments.length == 0)</span>
<a href="#l25.264"></a><span id="l25.264">         return this._inConstraintHelper(aAttrDef, []);</span>
<a href="#l25.265"></a><span id="l25.265"> </span>
<a href="#l25.266"></a><span id="l25.266">       for (let iArg = 0; iArg &lt; aArguments.length; iArg++) {</span>
<a href="#l25.267"></a><span id="l25.267">         let arg = aArguments[iArg];</span>
<a href="#l25.268"></a><span id="l25.268">         rangePairs.push(MimeTypeNoun._mimeTypeRangeDummyObjects[arg.category]);</span>
<a href="#l25.269"></a><span id="l25.269">       }</span>
<a href="#l25.270"></a><span id="l25.270">       return this._rangedConstraintHelper(aAttrDef, rangePairs);</span>
<a href="#l25.271"></a><span id="l25.271" class="difflineminus">-    }</span>
<a href="#l25.272"></a><span id="l25.272" class="difflineplus">+    },</span>
<a href="#l25.273"></a><span id="l25.273">   },</span>
<a href="#l25.274"></a><span id="l25.274"> </span>
<a href="#l25.275"></a><span id="l25.275" class="difflineminus">-  comparator: function gloda_noun_mimeType_comparator(a, b) {</span>
<a href="#l25.276"></a><span id="l25.276" class="difflineplus">+  comparator(a, b) {</span>
<a href="#l25.277"></a><span id="l25.277">     if (a == null) {</span>
<a href="#l25.278"></a><span id="l25.278">       if (b == null)</span>
<a href="#l25.279"></a><span id="l25.279">         return 0;</span>
<a href="#l25.280"></a><span id="l25.280" class="difflineminus">-      else</span>
<a href="#l25.281"></a><span id="l25.281" class="difflineminus">-        return 1;</span>
<a href="#l25.282"></a><span id="l25.282" class="difflineminus">-    }</span>
<a href="#l25.283"></a><span id="l25.283" class="difflineminus">-    else if (b == null) {</span>
<a href="#l25.284"></a><span id="l25.284" class="difflineplus">+      return 1;</span>
<a href="#l25.285"></a><span id="l25.285" class="difflineplus">+    } else if (b == null) {</span>
<a href="#l25.286"></a><span id="l25.286">       return -1;</span>
<a href="#l25.287"></a><span id="l25.287">     }</span>
<a href="#l25.288"></a><span id="l25.288">     return a.fullType.localeCompare(b.fullType);</span>
<a href="#l25.289"></a><span id="l25.289">   },</span>
<a href="#l25.290"></a><span id="l25.290"> </span>
<a href="#l25.291"></a><span id="l25.291" class="difflineminus">-  toParamAndValue: function gloda_noun_mimeType_toParamAndValue(aMimeType) {</span>
<a href="#l25.292"></a><span id="l25.292" class="difflineplus">+  toParamAndValue(aMimeType) {</span>
<a href="#l25.293"></a><span id="l25.293">     return [null, aMimeType.id];</span>
<a href="#l25.294"></a><span id="l25.294">   },</span>
<a href="#l25.295"></a><span id="l25.295" class="difflineminus">-  toJSON: function gloda_noun_mimeType_toJSON(aMimeType) {</span>
<a href="#l25.296"></a><span id="l25.296" class="difflineplus">+  toJSON(aMimeType) {</span>
<a href="#l25.297"></a><span id="l25.297">     return aMimeType.id;</span>
<a href="#l25.298"></a><span id="l25.298">   },</span>
<a href="#l25.299"></a><span id="l25.299" class="difflineminus">-  fromJSON: function gloda_noun_mimeType_fromJSON(aMimeTypeID) {</span>
<a href="#l25.300"></a><span id="l25.300" class="difflineplus">+  fromJSON(aMimeTypeID) {</span>
<a href="#l25.301"></a><span id="l25.301">     return this._mimeTypesByID[aMimeTypeID];</span>
<a href="#l25.302"></a><span id="l25.302">   },</span>
<a href="#l25.303"></a><span id="l25.303"> };</span>
<a href="#l25.304"></a><span id="l25.304"> Gloda.defineNoun(MimeTypeNoun, Gloda.NOUN_MIME_TYPE);</span>
<a href="#l25.305"></a><span id="l25.305"> try {</span>
<a href="#l25.306"></a><span id="l25.306"> MimeTypeNoun._init();</span>
<a href="#l25.307"></a><span id="l25.307"> } catch (ex) {</span>
<a href="#l25.308"></a><span id="l25.308">   LOG.error(&quot;problem init-ing: &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/db/gloda/modules/noun_tag.js</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/noun_tag.js</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -1,13 +1,13 @@</span>
<a href="#l26.4"></a><span id="l26.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l26.5"></a><span id="l26.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l26.6"></a><span id="l26.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l26.7"></a><span id="l26.7"> </span>
<a href="#l26.8"></a><span id="l26.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['TagNoun'];</span>
<a href="#l26.9"></a><span id="l26.9" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;TagNoun&quot;];</span>
<a href="#l26.10"></a><span id="l26.10"> </span>
<a href="#l26.11"></a><span id="l26.11"> const {MailServices} = ChromeUtils.import(&quot;resource:///modules/MailServices.jsm&quot;);</span>
<a href="#l26.12"></a><span id="l26.12"> </span>
<a href="#l26.13"></a><span id="l26.13"> const {Gloda} = ChromeUtils.import(&quot;resource:///modules/gloda/gloda.js&quot;);</span>
<a href="#l26.14"></a><span id="l26.14"> </span>
<a href="#l26.15"></a><span id="l26.15"> /**</span>
<a href="#l26.16"></a><span id="l26.16">  * @namespace Tag noun provider.</span>
<a href="#l26.17"></a><span id="l26.17">  */</span>
<a href="#l26.18"></a><span id="l26.18" class="difflineat">@@ -16,75 +16,73 @@ var TagNoun = {</span>
<a href="#l26.19"></a><span id="l26.19">   clazz: Ci.nsIMsgTag,</span>
<a href="#l26.20"></a><span id="l26.20">   usesParameter: true,</span>
<a href="#l26.21"></a><span id="l26.21">   allowsArbitraryAttrs: false,</span>
<a href="#l26.22"></a><span id="l26.22">   idAttr: &quot;key&quot;,</span>
<a href="#l26.23"></a><span id="l26.23">   _msgTagService: null,</span>
<a href="#l26.24"></a><span id="l26.24">   _tagMap: null,</span>
<a href="#l26.25"></a><span id="l26.25">   _tagList: null,</span>
<a href="#l26.26"></a><span id="l26.26"> </span>
<a href="#l26.27"></a><span id="l26.27" class="difflineminus">-  _init: function () {</span>
<a href="#l26.28"></a><span id="l26.28" class="difflineplus">+  _init() {</span>
<a href="#l26.29"></a><span id="l26.29">     this._msgTagService = MailServices.tags;</span>
<a href="#l26.30"></a><span id="l26.30">     this._updateTagMap();</span>
<a href="#l26.31"></a><span id="l26.31">   },</span>
<a href="#l26.32"></a><span id="l26.32"> </span>
<a href="#l26.33"></a><span id="l26.33" class="difflineminus">-  getAllTags: function gloda_noun_tag_getAllTags() {</span>
<a href="#l26.34"></a><span id="l26.34" class="difflineplus">+  getAllTags() {</span>
<a href="#l26.35"></a><span id="l26.35">     if (this._tagList == null)</span>
<a href="#l26.36"></a><span id="l26.36">       this._updateTagMap();</span>
<a href="#l26.37"></a><span id="l26.37">     return this._tagList;</span>
<a href="#l26.38"></a><span id="l26.38">   },</span>
<a href="#l26.39"></a><span id="l26.39"> </span>
<a href="#l26.40"></a><span id="l26.40" class="difflineminus">-  _updateTagMap: function gloda_noun_tag_updateTagMap() {</span>
<a href="#l26.41"></a><span id="l26.41" class="difflineplus">+  _updateTagMap() {</span>
<a href="#l26.42"></a><span id="l26.42">     this._tagMap = {};</span>
<a href="#l26.43"></a><span id="l26.43">     let tagArray = this._tagList = this._msgTagService.getAllTags({});</span>
<a href="#l26.44"></a><span id="l26.44">     for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l26.45"></a><span id="l26.45">       let tag = tagArray[iTag];</span>
<a href="#l26.46"></a><span id="l26.46">       this._tagMap[tag.key] = tag;</span>
<a href="#l26.47"></a><span id="l26.47">     }</span>
<a href="#l26.48"></a><span id="l26.48">   },</span>
<a href="#l26.49"></a><span id="l26.49"> </span>
<a href="#l26.50"></a><span id="l26.50" class="difflineminus">-  comparator: function gloda_noun_tag_comparator(a, b) {</span>
<a href="#l26.51"></a><span id="l26.51" class="difflineplus">+  comparator(a, b) {</span>
<a href="#l26.52"></a><span id="l26.52">     if (a == null) {</span>
<a href="#l26.53"></a><span id="l26.53">       if (b == null)</span>
<a href="#l26.54"></a><span id="l26.54">         return 0;</span>
<a href="#l26.55"></a><span id="l26.55" class="difflineminus">-      else</span>
<a href="#l26.56"></a><span id="l26.56" class="difflineminus">-        return 1;</span>
<a href="#l26.57"></a><span id="l26.57" class="difflineminus">-    }</span>
<a href="#l26.58"></a><span id="l26.58" class="difflineminus">-    else if (b == null) {</span>
<a href="#l26.59"></a><span id="l26.59" class="difflineplus">+      return 1;</span>
<a href="#l26.60"></a><span id="l26.60" class="difflineplus">+    } else if (b == null) {</span>
<a href="#l26.61"></a><span id="l26.61">       return -1;</span>
<a href="#l26.62"></a><span id="l26.62">     }</span>
<a href="#l26.63"></a><span id="l26.63">     return a.tag.localeCompare(b.tag);</span>
<a href="#l26.64"></a><span id="l26.64">   },</span>
<a href="#l26.65"></a><span id="l26.65" class="difflineminus">-  userVisibleString: function gloda_noun_tag_userVisibleString(aTag) {</span>
<a href="#l26.66"></a><span id="l26.66" class="difflineplus">+  userVisibleString(aTag) {</span>
<a href="#l26.67"></a><span id="l26.67">     return aTag.tag;</span>
<a href="#l26.68"></a><span id="l26.68">   },</span>
<a href="#l26.69"></a><span id="l26.69"> </span>
<a href="#l26.70"></a><span id="l26.70">   // we cannot be an attribute value</span>
<a href="#l26.71"></a><span id="l26.71"> </span>
<a href="#l26.72"></a><span id="l26.72" class="difflineminus">-  toParamAndValue: function gloda_noun_tag_toParamAndValue(aTag) {</span>
<a href="#l26.73"></a><span id="l26.73" class="difflineplus">+  toParamAndValue(aTag) {</span>
<a href="#l26.74"></a><span id="l26.74">     return [aTag.key, null];</span>
<a href="#l26.75"></a><span id="l26.75">   },</span>
<a href="#l26.76"></a><span id="l26.76" class="difflineminus">-  toJSON: function gloda_noun_tag_toJSON(aTag) {</span>
<a href="#l26.77"></a><span id="l26.77" class="difflineplus">+  toJSON(aTag) {</span>
<a href="#l26.78"></a><span id="l26.78">     return aTag.key;</span>
<a href="#l26.79"></a><span id="l26.79">   },</span>
<a href="#l26.80"></a><span id="l26.80" class="difflineminus">-  fromJSON: function gloda_noun_tag_fromJSON(aTagKey, aIgnored) {</span>
<a href="#l26.81"></a><span id="l26.81" class="difflineplus">+  fromJSON(aTagKey, aIgnored) {</span>
<a href="#l26.82"></a><span id="l26.82">     let tag = this._tagMap.hasOwnProperty(aTagKey) ? this._tagMap[aTagKey]</span>
<a href="#l26.83"></a><span id="l26.83">                 : undefined;</span>
<a href="#l26.84"></a><span id="l26.84">     // you will note that if a tag is removed, we are unable to aggressively</span>
<a href="#l26.85"></a><span id="l26.85">     //  deal with this.  we are okay with this, but it would be nice to be able</span>
<a href="#l26.86"></a><span id="l26.86">     //  to listen to the message tag service to know when we should rebuild.</span>
<a href="#l26.87"></a><span id="l26.87">     if ((tag === undefined) &amp;&amp; this._msgTagService.isValidKey(aTagKey)) {</span>
<a href="#l26.88"></a><span id="l26.88">       this._updateTagMap();</span>
<a href="#l26.89"></a><span id="l26.89">       tag = this._tagMap[aTagKey];</span>
<a href="#l26.90"></a><span id="l26.90">     }</span>
<a href="#l26.91"></a><span id="l26.91">     // we intentionally are returning undefined if the tag doesn't exist</span>
<a href="#l26.92"></a><span id="l26.92">     return tag;</span>
<a href="#l26.93"></a><span id="l26.93">   },</span>
<a href="#l26.94"></a><span id="l26.94">   /**</span>
<a href="#l26.95"></a><span id="l26.95">    * Convenience helper to turn a tag key into a tag name.</span>
<a href="#l26.96"></a><span id="l26.96">    */</span>
<a href="#l26.97"></a><span id="l26.97" class="difflineminus">-  getTag: function gloda_noun_tag_getTag(aTagKey) {</span>
<a href="#l26.98"></a><span id="l26.98" class="difflineplus">+  getTag(aTagKey) {</span>
<a href="#l26.99"></a><span id="l26.99">     return this.fromJSON(aTagKey);</span>
<a href="#l26.100"></a><span id="l26.100" class="difflineminus">-  }</span>
<a href="#l26.101"></a><span id="l26.101" class="difflineplus">+  },</span>
<a href="#l26.102"></a><span id="l26.102"> };</span>
<a href="#l26.103"></a><span id="l26.103"> </span>
<a href="#l26.104"></a><span id="l26.104"> TagNoun._init();</span>
<a href="#l26.105"></a><span id="l26.105"> Gloda.defineNoun(TagNoun, Gloda.NOUN_TAG);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/mailnews/db/gloda/modules/query.js</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/query.js</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -63,30 +63,30 @@ function GlodaQueryClass(aOptions) {</span>
<a href="#l27.4"></a><span id="l27.4"> </span>
<a href="#l27.5"></a><span id="l27.5"> GlodaQueryClass.prototype = {</span>
<a href="#l27.6"></a><span id="l27.6">   WILDCARD: {},</span>
<a href="#l27.7"></a><span id="l27.7"> </span>
<a href="#l27.8"></a><span id="l27.8">   get constraintCount() {</span>
<a href="#l27.9"></a><span id="l27.9">     return this._constraints.length;</span>
<a href="#l27.10"></a><span id="l27.10">   },</span>
<a href="#l27.11"></a><span id="l27.11"> </span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-  or: function gloda_query_or() {</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+  or() {</span>
<a href="#l27.14"></a><span id="l27.14">     let owner = this._owner || this;</span>
<a href="#l27.15"></a><span id="l27.15">     let orQuery = new this._queryClass();</span>
<a href="#l27.16"></a><span id="l27.16">     orQuery._owner = owner;</span>
<a href="#l27.17"></a><span id="l27.17">     owner._unions.push(orQuery);</span>
<a href="#l27.18"></a><span id="l27.18">     return orQuery;</span>
<a href="#l27.19"></a><span id="l27.19">   },</span>
<a href="#l27.20"></a><span id="l27.20"> </span>
<a href="#l27.21"></a><span id="l27.21" class="difflineminus">-  orderBy: function gloda_query_orderBy(...aArgs) {</span>
<a href="#l27.22"></a><span id="l27.22" class="difflineplus">+  orderBy(...aArgs) {</span>
<a href="#l27.23"></a><span id="l27.23">     this._order.push(...aArgs);</span>
<a href="#l27.24"></a><span id="l27.24">     return this;</span>
<a href="#l27.25"></a><span id="l27.25">   },</span>
<a href="#l27.26"></a><span id="l27.26"> </span>
<a href="#l27.27"></a><span id="l27.27" class="difflineminus">-  limit: function gloda_query_limit(aLimit) {</span>
<a href="#l27.28"></a><span id="l27.28" class="difflineplus">+  limit(aLimit) {</span>
<a href="#l27.29"></a><span id="l27.29">     this._limit = aLimit;</span>
<a href="#l27.30"></a><span id="l27.30">     return this;</span>
<a href="#l27.31"></a><span id="l27.31">   },</span>
<a href="#l27.32"></a><span id="l27.32"> </span>
<a href="#l27.33"></a><span id="l27.33">   /**</span>
<a href="#l27.34"></a><span id="l27.34">    * Return a collection asynchronously populated by this collection.  You must</span>
<a href="#l27.35"></a><span id="l27.35">    *  provide a listener to receive notifications from the collection as it</span>
<a href="#l27.36"></a><span id="l27.36">    *  receives updates.  The listener object should implement onItemsAdded,</span>
<a href="#l27.37"></a><span id="l27.37" class="difflineat">@@ -103,29 +103,30 @@ GlodaQueryClass.prototype = {</span>
<a href="#l27.38"></a><span id="l27.38">    * @param [aArgs.becomeNull] Change the collection's query to a null query so</span>
<a href="#l27.39"></a><span id="l27.39">    *     that it will never receive any additional added/modified/removed events</span>
<a href="#l27.40"></a><span id="l27.40">    *     apart from the underlying database query.  This is really only intended</span>
<a href="#l27.41"></a><span id="l27.41">    *     for gloda internal use but may be acceptable for non-gloda use.  Please</span>
<a href="#l27.42"></a><span id="l27.42">    *     ask on mozilla.dev.apps.thunderbird first to make sure there isn't a</span>
<a href="#l27.43"></a><span id="l27.43">    *     better solution for your use-case.  (Note: removals will still happen</span>
<a href="#l27.44"></a><span id="l27.44">    *     when things get fully deleted.)</span>
<a href="#l27.45"></a><span id="l27.45">    */</span>
<a href="#l27.46"></a><span id="l27.46" class="difflineminus">-  getCollection: function gloda_query_getCollection(aListener, aData, aArgs) {</span>
<a href="#l27.47"></a><span id="l27.47" class="difflineplus">+  getCollection(aListener, aData, aArgs) {</span>
<a href="#l27.48"></a><span id="l27.48">     this.completed = false;</span>
<a href="#l27.49"></a><span id="l27.49">     return this._nounDef.datastore.queryFromQuery(this, aListener, aData,</span>
<a href="#l27.50"></a><span id="l27.50">              /* aExistingCollection */ null, /* aMasterCollection */ null,</span>
<a href="#l27.51"></a><span id="l27.51">              aArgs);</span>
<a href="#l27.52"></a><span id="l27.52">   },</span>
<a href="#l27.53"></a><span id="l27.53"> </span>
<a href="#l27.54"></a><span id="l27.54" class="difflineplus">+  /* eslint-disable complexity */</span>
<a href="#l27.55"></a><span id="l27.55">   /**</span>
<a href="#l27.56"></a><span id="l27.56">    * Test whether the given first-class noun instance satisfies this query.</span>
<a href="#l27.57"></a><span id="l27.57">    *</span>
<a href="#l27.58"></a><span id="l27.58">    * @testpoint gloda.query.test</span>
<a href="#l27.59"></a><span id="l27.59">    */</span>
<a href="#l27.60"></a><span id="l27.60" class="difflineminus">-  test: function gloda_query_test(aObj) {</span>
<a href="#l27.61"></a><span id="l27.61" class="difflineplus">+  test(aObj) {</span>
<a href="#l27.62"></a><span id="l27.62">     // when changing this method, be sure that GlodaDatastore's queryFromQuery</span>
<a href="#l27.63"></a><span id="l27.63">     //  method likewise has any required changes made.</span>
<a href="#l27.64"></a><span id="l27.64">     let unionQueries = [this].concat(this._unions);</span>
<a href="#l27.65"></a><span id="l27.65"> </span>
<a href="#l27.66"></a><span id="l27.66">     for (let iUnion = 0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l27.67"></a><span id="l27.67">       let curQuery = unionQueries[iUnion];</span>
<a href="#l27.68"></a><span id="l27.68"> </span>
<a href="#l27.69"></a><span id="l27.69">       // assume success until a specific (or) constraint proves us wrong</span>
<a href="#l27.70"></a><span id="l27.70" class="difflineat">@@ -139,24 +140,23 @@ GlodaQueryClass.prototype = {</span>
<a href="#l27.71"></a><span id="l27.71">             aObj[boundName] === GlodaDatastore.IGNORE_FACET) {</span>
<a href="#l27.72"></a><span id="l27.72">           querySatisfied = false;</span>
<a href="#l27.73"></a><span id="l27.73">           break;</span>
<a href="#l27.74"></a><span id="l27.74">         }</span>
<a href="#l27.75"></a><span id="l27.75"> </span>
<a href="#l27.76"></a><span id="l27.76">         let constraintValues = constraint.slice(2);</span>
<a href="#l27.77"></a><span id="l27.77"> </span>
<a href="#l27.78"></a><span id="l27.78">         if (constraintType === GlodaDatastore.kConstraintIdIn) {</span>
<a href="#l27.79"></a><span id="l27.79" class="difflineminus">-          if (constraintValues.indexOf(aObj.id) == -1) {</span>
<a href="#l27.80"></a><span id="l27.80" class="difflineplus">+          if (!constraintValues.includes(aObj.id)) {</span>
<a href="#l27.81"></a><span id="l27.81">             querySatisfied = false;</span>
<a href="#l27.82"></a><span id="l27.82">             break;</span>
<a href="#l27.83"></a><span id="l27.83">           }</span>
<a href="#l27.84"></a><span id="l27.84" class="difflineminus">-        }</span>
<a href="#l27.85"></a><span id="l27.85" class="difflineminus">-        // @testpoint gloda.query.test.kConstraintIn</span>
<a href="#l27.86"></a><span id="l27.86" class="difflineminus">-        else if ((constraintType === GlodaDatastore.kConstraintIn) ||</span>
<a href="#l27.87"></a><span id="l27.87" class="difflineminus">-                 (constraintType === GlodaDatastore.kConstraintEquals)) {</span>
<a href="#l27.88"></a><span id="l27.88" class="difflineplus">+        } else if ((constraintType === GlodaDatastore.kConstraintIn) ||</span>
<a href="#l27.89"></a><span id="l27.89" class="difflineplus">+                   (constraintType === GlodaDatastore.kConstraintEquals)) {</span>
<a href="#l27.90"></a><span id="l27.90" class="difflineplus">+          // @testpoint gloda.query.test.kConstraintIn</span>
<a href="#l27.91"></a><span id="l27.91">           let objectNounDef = attrDef.objectNounDef;</span>
<a href="#l27.92"></a><span id="l27.92"> </span>
<a href="#l27.93"></a><span id="l27.93">           // if they provide an equals comparator, use that.</span>
<a href="#l27.94"></a><span id="l27.94">           // (note: the next case has better optimization possibilities than</span>
<a href="#l27.95"></a><span id="l27.95">           //  this mechanism, but of course has higher initialization costs or</span>
<a href="#l27.96"></a><span id="l27.96">           //  code complexity costs...)</span>
<a href="#l27.97"></a><span id="l27.97">           if (objectNounDef.equals) {</span>
<a href="#l27.98"></a><span id="l27.98">             let testValues;</span>
<a href="#l27.99"></a><span id="l27.99" class="difflineat">@@ -198,20 +198,19 @@ GlodaQueryClass.prototype = {</span>
<a href="#l27.100"></a><span id="l27.100">               }</span>
<a href="#l27.101"></a><span id="l27.101">               if (foundMatch)</span>
<a href="#l27.102"></a><span id="l27.102">                 break;</span>
<a href="#l27.103"></a><span id="l27.103">             }</span>
<a href="#l27.104"></a><span id="l27.104">             if (!foundMatch) {</span>
<a href="#l27.105"></a><span id="l27.105">               querySatisfied = false;</span>
<a href="#l27.106"></a><span id="l27.106">               break;</span>
<a href="#l27.107"></a><span id="l27.107">             }</span>
<a href="#l27.108"></a><span id="l27.108" class="difflineminus">-          }</span>
<a href="#l27.109"></a><span id="l27.109" class="difflineminus">-          // otherwise, we need to convert everyone to their param/value form</span>
<a href="#l27.110"></a><span id="l27.110" class="difflineminus">-          //  in order to test for equality</span>
<a href="#l27.111"></a><span id="l27.111" class="difflineminus">-          else {</span>
<a href="#l27.112"></a><span id="l27.112" class="difflineplus">+          } else {</span>
<a href="#l27.113"></a><span id="l27.113" class="difflineplus">+            // otherwise, we need to convert everyone to their param/value form</span>
<a href="#l27.114"></a><span id="l27.114" class="difflineplus">+            //  in order to test for equality</span>
<a href="#l27.115"></a><span id="l27.115">             // let's just do the simple, obvious thing for now.  which is</span>
<a href="#l27.116"></a><span id="l27.116">             //  what we did in the prior case but exploding values using</span>
<a href="#l27.117"></a><span id="l27.117">             //  toParamAndValue, and then comparing.</span>
<a href="#l27.118"></a><span id="l27.118">             let testValues;</span>
<a href="#l27.119"></a><span id="l27.119">             if (!(boundName in aObj))</span>
<a href="#l27.120"></a><span id="l27.120">               testValues = [];</span>
<a href="#l27.121"></a><span id="l27.121">             else if (attrDef.singular)</span>
<a href="#l27.122"></a><span id="l27.122">               testValues = [aObj[boundName]];</span>
<a href="#l27.123"></a><span id="l27.123" class="difflineat">@@ -254,19 +253,18 @@ GlodaQueryClass.prototype = {</span>
<a href="#l27.124"></a><span id="l27.124">               if (foundMatch)</span>
<a href="#l27.125"></a><span id="l27.125">                 break;</span>
<a href="#l27.126"></a><span id="l27.126">             }</span>
<a href="#l27.127"></a><span id="l27.127">             if (!foundMatch) {</span>
<a href="#l27.128"></a><span id="l27.128">               querySatisfied = false;</span>
<a href="#l27.129"></a><span id="l27.129">               break;</span>
<a href="#l27.130"></a><span id="l27.130">             }</span>
<a href="#l27.131"></a><span id="l27.131">           }</span>
<a href="#l27.132"></a><span id="l27.132" class="difflineminus">-        }</span>
<a href="#l27.133"></a><span id="l27.133" class="difflineminus">-        // @testpoint gloda.query.test.kConstraintRanges</span>
<a href="#l27.134"></a><span id="l27.134" class="difflineminus">-        else if (constraintType === GlodaDatastore.kConstraintRanges) {</span>
<a href="#l27.135"></a><span id="l27.135" class="difflineplus">+        } else if (constraintType === GlodaDatastore.kConstraintRanges) {</span>
<a href="#l27.136"></a><span id="l27.136" class="difflineplus">+          // @testpoint gloda.query.test.kConstraintRanges</span>
<a href="#l27.137"></a><span id="l27.137">           let objectNounDef = attrDef.objectNounDef;</span>
<a href="#l27.138"></a><span id="l27.138"> </span>
<a href="#l27.139"></a><span id="l27.139">           let testValues;</span>
<a href="#l27.140"></a><span id="l27.140">           if (!(boundName in aObj))</span>
<a href="#l27.141"></a><span id="l27.141">               testValues = [];</span>
<a href="#l27.142"></a><span id="l27.142">           else if (attrDef.singular)</span>
<a href="#l27.143"></a><span id="l27.143">             testValues = [aObj[boundName]];</span>
<a href="#l27.144"></a><span id="l27.144">           else</span>
<a href="#l27.145"></a><span id="l27.145" class="difflineat">@@ -279,26 +277,24 @@ GlodaQueryClass.prototype = {</span>
<a href="#l27.146"></a><span id="l27.146">               let [lowerRValue, upperRValue] = rangeTuple;</span>
<a href="#l27.147"></a><span id="l27.147">               if (lowerRValue == null) {</span>
<a href="#l27.148"></a><span id="l27.148">                 let [upperParam, upperValue] =</span>
<a href="#l27.149"></a><span id="l27.149">                   objectNounDef.toParamAndValue(upperRValue);</span>
<a href="#l27.150"></a><span id="l27.150">                 if (tParam == upperParam &amp;&amp; tValue &lt;= upperValue) {</span>
<a href="#l27.151"></a><span id="l27.151">                   foundMatch = true;</span>
<a href="#l27.152"></a><span id="l27.152">                   break;</span>
<a href="#l27.153"></a><span id="l27.153">                 }</span>
<a href="#l27.154"></a><span id="l27.154" class="difflineminus">-              }</span>
<a href="#l27.155"></a><span id="l27.155" class="difflineminus">-              else if (upperRValue == null) {</span>
<a href="#l27.156"></a><span id="l27.156" class="difflineplus">+              } else if (upperRValue == null) {</span>
<a href="#l27.157"></a><span id="l27.157">                 let [lowerParam, lowerValue] =</span>
<a href="#l27.158"></a><span id="l27.158">                   objectNounDef.toParamAndValue(lowerRValue);</span>
<a href="#l27.159"></a><span id="l27.159">                 if (tParam == lowerParam &amp;&amp; tValue &gt;= lowerValue) {</span>
<a href="#l27.160"></a><span id="l27.160">                   foundMatch = true;</span>
<a href="#l27.161"></a><span id="l27.161">                   break;</span>
<a href="#l27.162"></a><span id="l27.162">                 }</span>
<a href="#l27.163"></a><span id="l27.163" class="difflineminus">-              }</span>
<a href="#l27.164"></a><span id="l27.164" class="difflineminus">-              else { // no one is null</span>
<a href="#l27.165"></a><span id="l27.165" class="difflineplus">+              } else { // no one is null</span>
<a href="#l27.166"></a><span id="l27.166">                 let [upperParam, upperValue] =</span>
<a href="#l27.167"></a><span id="l27.167">                   objectNounDef.toParamAndValue(upperRValue);</span>
<a href="#l27.168"></a><span id="l27.168">                 let [lowerParam, lowerValue] =</span>
<a href="#l27.169"></a><span id="l27.169">                   objectNounDef.toParamAndValue(lowerRValue);</span>
<a href="#l27.170"></a><span id="l27.170">                 if ((tParam == lowerParam) &amp;&amp; (tValue &gt;= lowerValue) &amp;&amp;</span>
<a href="#l27.171"></a><span id="l27.171">                     (tParam == upperParam) &amp;&amp; (tValue &lt;= upperValue)) {</span>
<a href="#l27.172"></a><span id="l27.172">                   foundMatch = true;</span>
<a href="#l27.173"></a><span id="l27.173">                   break;</span>
<a href="#l27.174"></a><span id="l27.174" class="difflineat">@@ -307,51 +303,47 @@ GlodaQueryClass.prototype = {</span>
<a href="#l27.175"></a><span id="l27.175">             }</span>
<a href="#l27.176"></a><span id="l27.176">             if (foundMatch)</span>
<a href="#l27.177"></a><span id="l27.177">               break;</span>
<a href="#l27.178"></a><span id="l27.178">           }</span>
<a href="#l27.179"></a><span id="l27.179">           if (!foundMatch) {</span>
<a href="#l27.180"></a><span id="l27.180">             querySatisfied = false;</span>
<a href="#l27.181"></a><span id="l27.181">             break;</span>
<a href="#l27.182"></a><span id="l27.182">           }</span>
<a href="#l27.183"></a><span id="l27.183" class="difflineminus">-        }</span>
<a href="#l27.184"></a><span id="l27.184" class="difflineminus">-        // @testpoint gloda.query.test.kConstraintStringLike</span>
<a href="#l27.185"></a><span id="l27.185" class="difflineminus">-        else if (constraintType === GlodaDatastore.kConstraintStringLike) {</span>
<a href="#l27.186"></a><span id="l27.186" class="difflineplus">+        } else if (constraintType === GlodaDatastore.kConstraintStringLike) {</span>
<a href="#l27.187"></a><span id="l27.187" class="difflineplus">+          // @testpoint gloda.query.test.kConstraintStringLike</span>
<a href="#l27.188"></a><span id="l27.188">           let curIndex = 0;</span>
<a href="#l27.189"></a><span id="l27.189">           let value = (boundName in aObj) ? aObj[boundName] : &quot;&quot;;</span>
<a href="#l27.190"></a><span id="l27.190">           // the attribute must be singular, we don't support arrays of strings.</span>
<a href="#l27.191"></a><span id="l27.191">           for (let valuePart of constraintValues) {</span>
<a href="#l27.192"></a><span id="l27.192">             if (typeof valuePart == &quot;string&quot;) {</span>
<a href="#l27.193"></a><span id="l27.193">               let index = value.indexOf(valuePart);</span>
<a href="#l27.194"></a><span id="l27.194">               // if curIndex is null, we just need any match</span>
<a href="#l27.195"></a><span id="l27.195">               // if it's not null, it must match the offset of our found match</span>
<a href="#l27.196"></a><span id="l27.196">               if (curIndex === null) {</span>
<a href="#l27.197"></a><span id="l27.197">                 if (index == -1)</span>
<a href="#l27.198"></a><span id="l27.198">                   querySatisfied = false;</span>
<a href="#l27.199"></a><span id="l27.199">                 else</span>
<a href="#l27.200"></a><span id="l27.200">                   curIndex = index + valuePart.length;</span>
<a href="#l27.201"></a><span id="l27.201" class="difflineminus">-              }</span>
<a href="#l27.202"></a><span id="l27.202" class="difflineminus">-              else {</span>
<a href="#l27.203"></a><span id="l27.203" class="difflineminus">-                if (index != curIndex)</span>
<a href="#l27.204"></a><span id="l27.204" class="difflineminus">-                  querySatisfied = false;</span>
<a href="#l27.205"></a><span id="l27.205" class="difflineminus">-                else</span>
<a href="#l27.206"></a><span id="l27.206" class="difflineminus">-                  curIndex = index + valuePart.length;</span>
<a href="#l27.207"></a><span id="l27.207" class="difflineplus">+              } else if (index != curIndex) {</span>
<a href="#l27.208"></a><span id="l27.208" class="difflineplus">+                querySatisfied = false;</span>
<a href="#l27.209"></a><span id="l27.209" class="difflineplus">+              } else {</span>
<a href="#l27.210"></a><span id="l27.210" class="difflineplus">+                curIndex = index + valuePart.length;</span>
<a href="#l27.211"></a><span id="l27.211">               }</span>
<a href="#l27.212"></a><span id="l27.212">               if (!querySatisfied)</span>
<a href="#l27.213"></a><span id="l27.213">                 break;</span>
<a href="#l27.214"></a><span id="l27.214" class="difflineplus">+            } else { // wild!</span>
<a href="#l27.215"></a><span id="l27.215" class="difflineplus">+              curIndex = null;</span>
<a href="#l27.216"></a><span id="l27.216">             }</span>
<a href="#l27.217"></a><span id="l27.217" class="difflineminus">-            else // wild!</span>
<a href="#l27.218"></a><span id="l27.218" class="difflineminus">-              curIndex = null;</span>
<a href="#l27.219"></a><span id="l27.219">           }</span>
<a href="#l27.220"></a><span id="l27.220">           // curIndex must be null or equal to the length of the string</span>
<a href="#l27.221"></a><span id="l27.221">           if (querySatisfied &amp;&amp; curIndex !== null &amp;&amp; curIndex != value.length)</span>
<a href="#l27.222"></a><span id="l27.222">             querySatisfied = false;</span>
<a href="#l27.223"></a><span id="l27.223" class="difflineminus">-        }</span>
<a href="#l27.224"></a><span id="l27.224" class="difflineminus">-        // @testpoint gloda.query.test.kConstraintFulltext</span>
<a href="#l27.225"></a><span id="l27.225" class="difflineminus">-        else if (constraintType === GlodaDatastore.kConstraintFulltext) {</span>
<a href="#l27.226"></a><span id="l27.226" class="difflineplus">+        } else if (constraintType === GlodaDatastore.kConstraintFulltext) {</span>
<a href="#l27.227"></a><span id="l27.227" class="difflineplus">+          // @testpoint gloda.query.test.kConstraintFulltext</span>
<a href="#l27.228"></a><span id="l27.228">           // this is beyond our powers. Even if we have the fulltext content in</span>
<a href="#l27.229"></a><span id="l27.229">           //  memory, which we may not, the tokenization and such to perform</span>
<a href="#l27.230"></a><span id="l27.230">           //  the testing gets very complicated in the face of i18n, etc.</span>
<a href="#l27.231"></a><span id="l27.231">           // so, let's fail if the item is not already in the collection, and</span>
<a href="#l27.232"></a><span id="l27.232">           //  let the testing continue if it is.  (some other constraint may no</span>
<a href="#l27.233"></a><span id="l27.233">           //  longer apply...)</span>
<a href="#l27.234"></a><span id="l27.234">           if (!(aObj.id in this.collection._idMap))</span>
<a href="#l27.235"></a><span id="l27.235">             querySatisfied = false;</span>
<a href="#l27.236"></a><span id="l27.236" class="difflineat">@@ -361,47 +353,46 @@ GlodaQueryClass.prototype = {</span>
<a href="#l27.237"></a><span id="l27.237">           break;</span>
<a href="#l27.238"></a><span id="l27.238">       }</span>
<a href="#l27.239"></a><span id="l27.239"> </span>
<a href="#l27.240"></a><span id="l27.240">       if (querySatisfied)</span>
<a href="#l27.241"></a><span id="l27.241">         return true;</span>
<a href="#l27.242"></a><span id="l27.242">     }</span>
<a href="#l27.243"></a><span id="l27.243">     return false;</span>
<a href="#l27.244"></a><span id="l27.244">   },</span>
<a href="#l27.245"></a><span id="l27.245" class="difflineplus">+  /* eslint-enable complexity */</span>
<a href="#l27.246"></a><span id="l27.246"> </span>
<a href="#l27.247"></a><span id="l27.247">   /**</span>
<a href="#l27.248"></a><span id="l27.248">    * Helper code for noun definitions of queryHelpers that want to build a</span>
<a href="#l27.249"></a><span id="l27.249">    *  traditional in/equals constraint.  The goal is to let them build a range</span>
<a href="#l27.250"></a><span id="l27.250">    *  without having to know how we structure |_constraints|.</span>
<a href="#l27.251"></a><span id="l27.251">    *</span>
<a href="#l27.252"></a><span id="l27.252">    * @protected</span>
<a href="#l27.253"></a><span id="l27.253">    */</span>
<a href="#l27.254"></a><span id="l27.254" class="difflineminus">-  _inConstraintHelper:</span>
<a href="#l27.255"></a><span id="l27.255" class="difflineminus">-      function gloda_query__discreteConstraintHelper(aAttrDef, aValues) {</span>
<a href="#l27.256"></a><span id="l27.256" class="difflineplus">+  _inConstraintHelper(aAttrDef, aValues) {</span>
<a href="#l27.257"></a><span id="l27.257">     let constraint =</span>
<a href="#l27.258"></a><span id="l27.258">       [GlodaDatastore.kConstraintIn, aAttrDef].concat(aValues);</span>
<a href="#l27.259"></a><span id="l27.259">     this._constraints.push(constraint);</span>
<a href="#l27.260"></a><span id="l27.260">     return this;</span>
<a href="#l27.261"></a><span id="l27.261">   },</span>
<a href="#l27.262"></a><span id="l27.262"> </span>
<a href="#l27.263"></a><span id="l27.263">   /**</span>
<a href="#l27.264"></a><span id="l27.264">    * Helper code for noun definitions of queryHelpers that want to build a</span>
<a href="#l27.265"></a><span id="l27.265">    *  range.  The goal is to let them build a range without having to know how</span>
<a href="#l27.266"></a><span id="l27.266">    *  we structure |_constraints| or requiring them to mark themselves as</span>
<a href="#l27.267"></a><span id="l27.267">    *  continuous to get a &quot;Range&quot;.</span>
<a href="#l27.268"></a><span id="l27.268">    *</span>
<a href="#l27.269"></a><span id="l27.269">    * @protected</span>
<a href="#l27.270"></a><span id="l27.270">    */</span>
<a href="#l27.271"></a><span id="l27.271" class="difflineminus">-  _rangedConstraintHelper:</span>
<a href="#l27.272"></a><span id="l27.272" class="difflineminus">-      function gloda_query__rangedConstraintHelper(aAttrDef, aRanges) {</span>
<a href="#l27.273"></a><span id="l27.273" class="difflineplus">+  _rangedConstraintHelper(aAttrDef, aRanges) {</span>
<a href="#l27.274"></a><span id="l27.274">     let constraint =</span>
<a href="#l27.275"></a><span id="l27.275">       [GlodaDatastore.kConstraintRanges, aAttrDef].concat(aRanges);</span>
<a href="#l27.276"></a><span id="l27.276">     this._constraints.push(constraint);</span>
<a href="#l27.277"></a><span id="l27.277">     return this;</span>
<a href="#l27.278"></a><span id="l27.278" class="difflineminus">-  }</span>
<a href="#l27.279"></a><span id="l27.279" class="difflineplus">+  },</span>
<a href="#l27.280"></a><span id="l27.280"> };</span>
<a href="#l27.281"></a><span id="l27.281"> </span>
<a href="#l27.282"></a><span id="l27.282"> /**</span>
<a href="#l27.283"></a><span id="l27.283">  * @class A query that never matches anything.</span>
<a href="#l27.284"></a><span id="l27.284">  *</span>
<a href="#l27.285"></a><span id="l27.285">  * Collections corresponding to this query are intentionally frozen in time and</span>
<a href="#l27.286"></a><span id="l27.286">  *  do not want to be notified of any updates.  We need the collection to be</span>
<a href="#l27.287"></a><span id="l27.287">  *  registered with the collection manager so that the noun instances in the</span>
<a href="#l27.288"></a><span id="l27.288" class="difflineat">@@ -438,46 +429,46 @@ GlodaNullQueryClass.prototype = {</span>
<a href="#l27.289"></a><span id="l27.289">   frozen: true,</span>
<a href="#l27.290"></a><span id="l27.290"> </span>
<a href="#l27.291"></a><span id="l27.291">   /**</span>
<a href="#l27.292"></a><span id="l27.292">    * Since our query never matches anything, it doesn't make sense to let</span>
<a href="#l27.293"></a><span id="l27.293">    *  someone attempt to construct a boolean OR involving us.</span>
<a href="#l27.294"></a><span id="l27.294">    *</span>
<a href="#l27.295"></a><span id="l27.295">    * @returns null</span>
<a href="#l27.296"></a><span id="l27.296">    */</span>
<a href="#l27.297"></a><span id="l27.297" class="difflineminus">-  or: function() {</span>
<a href="#l27.298"></a><span id="l27.298" class="difflineplus">+  or() {</span>
<a href="#l27.299"></a><span id="l27.299">     return null;</span>
<a href="#l27.300"></a><span id="l27.300">   },</span>
<a href="#l27.301"></a><span id="l27.301"> </span>
<a href="#l27.302"></a><span id="l27.302">   /**</span>
<a href="#l27.303"></a><span id="l27.303">    * Return nothing (null) because it does not make sense to create a collection</span>
<a href="#l27.304"></a><span id="l27.304">    *  based on a null query.  This method is normally used (on a normal query)</span>
<a href="#l27.305"></a><span id="l27.305">    *  to return a collection populated by the constraints of the query.  We</span>
<a href="#l27.306"></a><span id="l27.306">    *  match nothing, so we should return nothing.  More importantly, you are</span>
<a href="#l27.307"></a><span id="l27.307">    *  currently doing something wrong if you try and do this, so null is</span>
<a href="#l27.308"></a><span id="l27.308">    *  appropriate.  It may turn out that it makes sense for us to return an</span>
<a href="#l27.309"></a><span id="l27.309">    *  empty collection in the future for sentinel value purposes, but we'll</span>
<a href="#l27.310"></a><span id="l27.310">    *  cross that bridge when we come to it.</span>
<a href="#l27.311"></a><span id="l27.311">    *</span>
<a href="#l27.312"></a><span id="l27.312">    * @returns null</span>
<a href="#l27.313"></a><span id="l27.313">    */</span>
<a href="#l27.314"></a><span id="l27.314" class="difflineminus">-  getCollection: function() {</span>
<a href="#l27.315"></a><span id="l27.315" class="difflineplus">+  getCollection() {</span>
<a href="#l27.316"></a><span id="l27.316">     return null;</span>
<a href="#l27.317"></a><span id="l27.317">   },</span>
<a href="#l27.318"></a><span id="l27.318"> </span>
<a href="#l27.319"></a><span id="l27.319">   /**</span>
<a href="#l27.320"></a><span id="l27.320">    * Never matches anything.</span>
<a href="#l27.321"></a><span id="l27.321">    *</span>
<a href="#l27.322"></a><span id="l27.322">    * @param aObj The object someone wants us to test for relevance to our</span>
<a href="#l27.323"></a><span id="l27.323">    *     associated collection.  But we don't care!  Not a fig!</span>
<a href="#l27.324"></a><span id="l27.324">    * @returns false</span>
<a href="#l27.325"></a><span id="l27.325">    */</span>
<a href="#l27.326"></a><span id="l27.326" class="difflineminus">-  test: function gloda_query_null_test(aObj) {</span>
<a href="#l27.327"></a><span id="l27.327" class="difflineplus">+  test(aObj) {</span>
<a href="#l27.328"></a><span id="l27.328">     return false;</span>
<a href="#l27.329"></a><span id="l27.329" class="difflineminus">-  }</span>
<a href="#l27.330"></a><span id="l27.330" class="difflineplus">+  },</span>
<a href="#l27.331"></a><span id="l27.331"> };</span>
<a href="#l27.332"></a><span id="l27.332"> </span>
<a href="#l27.333"></a><span id="l27.333"> /**</span>
<a href="#l27.334"></a><span id="l27.334">  * @class A query that only 'tests' for already belonging to the collection.</span>
<a href="#l27.335"></a><span id="l27.335">  *</span>
<a href="#l27.336"></a><span id="l27.336">  * This type of collection is useful for when you (or rather your listener)</span>
<a href="#l27.337"></a><span id="l27.337">  *  are interested in hearing about modifications to your collection or removals</span>
<a href="#l27.338"></a><span id="l27.338">  *  from your collection because of deletion, but do not want to be notified</span>
<a href="#l27.339"></a><span id="l27.339" class="difflineat">@@ -500,74 +491,74 @@ GlodaExplicitQueryClass.prototype = {</span>
<a href="#l27.340"></a><span id="l27.340"> </span>
<a href="#l27.341"></a><span id="l27.341">   /**</span>
<a href="#l27.342"></a><span id="l27.342">    * Since our query is intended to only match the contents of our collection,</span>
<a href="#l27.343"></a><span id="l27.343">    *  it doesn't make sense to let someone attempt to construct a boolean OR</span>
<a href="#l27.344"></a><span id="l27.344">    *  involving us.</span>
<a href="#l27.345"></a><span id="l27.345">    *</span>
<a href="#l27.346"></a><span id="l27.346">    * @returns null</span>
<a href="#l27.347"></a><span id="l27.347">    */</span>
<a href="#l27.348"></a><span id="l27.348" class="difflineminus">-  or: function() {</span>
<a href="#l27.349"></a><span id="l27.349" class="difflineplus">+  or() {</span>
<a href="#l27.350"></a><span id="l27.350">     return null;</span>
<a href="#l27.351"></a><span id="l27.351">   },</span>
<a href="#l27.352"></a><span id="l27.352"> </span>
<a href="#l27.353"></a><span id="l27.353">   /**</span>
<a href="#l27.354"></a><span id="l27.354">    * Return nothing (null) because it does not make sense to create a collection</span>
<a href="#l27.355"></a><span id="l27.355">    *  based on an explicit query.  This method is normally used (on a normal</span>
<a href="#l27.356"></a><span id="l27.356">    *  query) to return a collection populated by the constraints of the query.</span>
<a href="#l27.357"></a><span id="l27.357">    *  In the case of an explicit query, we expect it will be associated with</span>
<a href="#l27.358"></a><span id="l27.358">    *  either a hand-created collection or the results of a normal query that is</span>
<a href="#l27.359"></a><span id="l27.359">    *  immediately converted into an explicit query.  In all likelihood, calling</span>
<a href="#l27.360"></a><span id="l27.360">    *  this method on an instance of this type is an error, so it is helpful to</span>
<a href="#l27.361"></a><span id="l27.361">    *  return null because people will error hard.</span>
<a href="#l27.362"></a><span id="l27.362">    *</span>
<a href="#l27.363"></a><span id="l27.363">    * @returns null</span>
<a href="#l27.364"></a><span id="l27.364">    */</span>
<a href="#l27.365"></a><span id="l27.365" class="difflineminus">-  getCollection: function() {</span>
<a href="#l27.366"></a><span id="l27.366" class="difflineplus">+  getCollection() {</span>
<a href="#l27.367"></a><span id="l27.367">     return null;</span>
<a href="#l27.368"></a><span id="l27.368">   },</span>
<a href="#l27.369"></a><span id="l27.369"> </span>
<a href="#l27.370"></a><span id="l27.370">   /**</span>
<a href="#l27.371"></a><span id="l27.371">    * Matches only items that are already in the collection associated with this</span>
<a href="#l27.372"></a><span id="l27.372">    *  query (by id).</span>
<a href="#l27.373"></a><span id="l27.373">    *</span>
<a href="#l27.374"></a><span id="l27.374">    * @param aObj The object/item to test for already being in the associated</span>
<a href="#l27.375"></a><span id="l27.375">    *     collection.</span>
<a href="#l27.376"></a><span id="l27.376">    * @returns true when the object is in the associated collection, otherwise</span>
<a href="#l27.377"></a><span id="l27.377">    *     false.</span>
<a href="#l27.378"></a><span id="l27.378">    */</span>
<a href="#l27.379"></a><span id="l27.379" class="difflineminus">-  test: function gloda_query_explicit_test(aObj) {</span>
<a href="#l27.380"></a><span id="l27.380" class="difflineplus">+  test(aObj) {</span>
<a href="#l27.381"></a><span id="l27.381">     return (aObj.id in this.collection._idMap);</span>
<a href="#l27.382"></a><span id="l27.382" class="difflineminus">-  }</span>
<a href="#l27.383"></a><span id="l27.383" class="difflineplus">+  },</span>
<a href="#l27.384"></a><span id="l27.384"> };</span>
<a href="#l27.385"></a><span id="l27.385"> </span>
<a href="#l27.386"></a><span id="l27.386"> /**</span>
<a href="#l27.387"></a><span id="l27.387">  * @class A query that 'tests' true for everything.  Intended for debugging purposes</span>
<a href="#l27.388"></a><span id="l27.388">  *  only.</span>
<a href="#l27.389"></a><span id="l27.389">  */</span>
<a href="#l27.390"></a><span id="l27.390"> function GlodaWildcardQueryClass() {</span>
<a href="#l27.391"></a><span id="l27.391"> }</span>
<a href="#l27.392"></a><span id="l27.392"> </span>
<a href="#l27.393"></a><span id="l27.393"> GlodaWildcardQueryClass.prototype = {</span>
<a href="#l27.394"></a><span id="l27.394">   /**</span>
<a href="#l27.395"></a><span id="l27.395">    * No options; they are currently only needed for SQL query generation.</span>
<a href="#l27.396"></a><span id="l27.396">    */</span>
<a href="#l27.397"></a><span id="l27.397">   options: {},</span>
<a href="#l27.398"></a><span id="l27.398"> </span>
<a href="#l27.399"></a><span id="l27.399">   // don't let people try and mess with us</span>
<a href="#l27.400"></a><span id="l27.400" class="difflineminus">-  or: function() { return null; },</span>
<a href="#l27.401"></a><span id="l27.401" class="difflineplus">+  or() { return null; },</span>
<a href="#l27.402"></a><span id="l27.402">   // don't let people try and query on us (until we have a real use case for</span>
<a href="#l27.403"></a><span id="l27.403">   //  that...)</span>
<a href="#l27.404"></a><span id="l27.404" class="difflineminus">-  getCollection: function() { return null; },</span>
<a href="#l27.405"></a><span id="l27.405" class="difflineplus">+  getCollection() { return null; },</span>
<a href="#l27.406"></a><span id="l27.406">   /**</span>
<a href="#l27.407"></a><span id="l27.407">    * Everybody wins!</span>
<a href="#l27.408"></a><span id="l27.408">    */</span>
<a href="#l27.409"></a><span id="l27.409" class="difflineminus">-  test: function gloda_query_explicit_test(aObj) {</span>
<a href="#l27.410"></a><span id="l27.410" class="difflineplus">+  test(aObj) {</span>
<a href="#l27.411"></a><span id="l27.411">     return true;</span>
<a href="#l27.412"></a><span id="l27.412" class="difflineminus">-  }</span>
<a href="#l27.413"></a><span id="l27.413" class="difflineplus">+  },</span>
<a href="#l27.414"></a><span id="l27.414"> };</span>
<a href="#l27.415"></a><span id="l27.415"> </span>
<a href="#l27.416"></a><span id="l27.416"> /**</span>
<a href="#l27.417"></a><span id="l27.417">  * Factory method to effectively create per-noun subclasses of GlodaQueryClass,</span>
<a href="#l27.418"></a><span id="l27.418">  *  GlodaNullQueryClass, GlodaExplicitQueryClass, and GlodaWildcardQueryClass.</span>
<a href="#l27.419"></a><span id="l27.419">  *  For GlodaQueryClass this allows us to add per-noun helpers.  For the others,</span>
<a href="#l27.420"></a><span id="l27.420">  *  this is merely a means of allowing us to attach the (per-noun) nounDef to</span>
<a href="#l27.421"></a><span id="l27.421">  *  the 'class'.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/mailnews/db/gloda/modules/suffixtree.js</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/suffixtree.js</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -7,17 +7,17 @@ this.EXPORTED_SYMBOLS = [&quot;SuffixTree&quot;, &quot;</span>
<a href="#l28.4"></a><span id="l28.4"> /**</span>
<a href="#l28.5"></a><span id="l28.5">  * Given a list of strings and a corresponding map of items that those strings</span>
<a href="#l28.6"></a><span id="l28.6">  *  correspond to, build a suffix tree.</span>
<a href="#l28.7"></a><span id="l28.7">  */</span>
<a href="#l28.8"></a><span id="l28.8"> function MultiSuffixTree(aStrings, aItems) {</span>
<a href="#l28.9"></a><span id="l28.9">   if (aStrings.length != aItems.length)</span>
<a href="#l28.10"></a><span id="l28.10">     throw new Error(&quot;Array lengths need to be the same.&quot;);</span>
<a href="#l28.11"></a><span id="l28.11"> </span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-  let s = '';</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+  let s = &quot;&quot;;</span>
<a href="#l28.14"></a><span id="l28.14">   let offsetsToItems = [];</span>
<a href="#l28.15"></a><span id="l28.15">   let lastLength = 0;</span>
<a href="#l28.16"></a><span id="l28.16">   for (let i = 0; i &lt; aStrings.length; i++) {</span>
<a href="#l28.17"></a><span id="l28.17">     s += aStrings[i];</span>
<a href="#l28.18"></a><span id="l28.18">     offsetsToItems.push(lastLength, s.length, aItems[i]);</span>
<a href="#l28.19"></a><span id="l28.19">     lastLength = s.length;</span>
<a href="#l28.20"></a><span id="l28.20">   }</span>
<a href="#l28.21"></a><span id="l28.21"> </span>
<a href="#l28.22"></a><span id="l28.22" class="difflineat">@@ -59,20 +59,20 @@ State.prototype = {</span>
<a href="#l28.23"></a><span id="l28.23">     // our end is not inclusive...</span>
<a href="#l28.24"></a><span id="l28.24">     return (this.end &gt; this.start);</span>
<a href="#l28.25"></a><span id="l28.25">   },</span>
<a href="#l28.26"></a><span id="l28.26"> </span>
<a href="#l28.27"></a><span id="l28.27">   get length() {</span>
<a href="#l28.28"></a><span id="l28.28">     return this.end - this.start;</span>
<a href="#l28.29"></a><span id="l28.29">   },</span>
<a href="#l28.30"></a><span id="l28.30"> </span>
<a href="#l28.31"></a><span id="l28.31" class="difflineminus">-  toString: function State_toString() {</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+  toString() {</span>
<a href="#l28.33"></a><span id="l28.33">     return &quot;[Start: &quot; + this.start + &quot; End: &quot; + this.end +</span>
<a href="#l28.34"></a><span id="l28.34">            (this.suffix ? &quot; non-null suffix]&quot; : &quot; null suffix]&quot;);</span>
<a href="#l28.35"></a><span id="l28.35" class="difflineminus">-  }</span>
<a href="#l28.36"></a><span id="l28.36" class="difflineplus">+  },</span>
<a href="#l28.37"></a><span id="l28.37"> };</span>
<a href="#l28.38"></a><span id="l28.38"> </span>
<a href="#l28.39"></a><span id="l28.39"> /**</span>
<a href="#l28.40"></a><span id="l28.40">  * Suffix tree implemented using Ukkonen's algorithm.</span>
<a href="#l28.41"></a><span id="l28.41">  * @constructor</span>
<a href="#l28.42"></a><span id="l28.42">  */</span>
<a href="#l28.43"></a><span id="l28.43"> function SuffixTree(aStr) {</span>
<a href="#l28.44"></a><span id="l28.44">   this._construct(aStr);</span>
<a href="#l28.45"></a><span id="l28.45" class="difflineat">@@ -80,22 +80,22 @@ function SuffixTree(aStr) {</span>
<a href="#l28.46"></a><span id="l28.46"> </span>
<a href="#l28.47"></a><span id="l28.47"> /**</span>
<a href="#l28.48"></a><span id="l28.48">  * States are</span>
<a href="#l28.49"></a><span id="l28.49">  */</span>
<a href="#l28.50"></a><span id="l28.50"> SuffixTree.prototype = {</span>
<a href="#l28.51"></a><span id="l28.51">   /**</span>
<a href="#l28.52"></a><span id="l28.52">    * Find all items matching the provided substring.</span>
<a href="#l28.53"></a><span id="l28.53">    */</span>
<a href="#l28.54"></a><span id="l28.54" class="difflineminus">-  findMatches: function findMatches(aSubstring) {</span>
<a href="#l28.55"></a><span id="l28.55" class="difflineplus">+  findMatches(aSubstring) {</span>
<a href="#l28.56"></a><span id="l28.56">     let results = [];</span>
<a href="#l28.57"></a><span id="l28.57">     let state = this._root;</span>
<a href="#l28.58"></a><span id="l28.58" class="difflineminus">-    let index=0;</span>
<a href="#l28.59"></a><span id="l28.59" class="difflineplus">+    let index = 0;</span>
<a href="#l28.60"></a><span id="l28.60">     let end = aSubstring.length;</span>
<a href="#l28.61"></a><span id="l28.61" class="difflineminus">-    while(index &lt; end) {</span>
<a href="#l28.62"></a><span id="l28.62" class="difflineplus">+    while (index &lt; end) {</span>
<a href="#l28.63"></a><span id="l28.63">       state = state[aSubstring[index]];</span>
<a href="#l28.64"></a><span id="l28.64">       // bail if there was no edge</span>
<a href="#l28.65"></a><span id="l28.65">       if (state === undefined)</span>
<a href="#l28.66"></a><span id="l28.66">         return results;</span>
<a href="#l28.67"></a><span id="l28.67">       // bail if the portion of the edge we traversed is not equal to that</span>
<a href="#l28.68"></a><span id="l28.68">       //  portion of our pattern</span>
<a href="#l28.69"></a><span id="l28.69">       let actualTraverseLength = Math.min(state.length,</span>
<a href="#l28.70"></a><span id="l28.70">                                           end - index);</span>
<a href="#l28.71"></a><span id="l28.71" class="difflineat">@@ -122,38 +122,37 @@ SuffixTree.prototype = {</span>
<a href="#l28.72"></a><span id="l28.72">       delta = end - (index - state.length);</span>
<a href="#l28.73"></a><span id="l28.73">     else */</span>
<a href="#l28.74"></a><span id="l28.74">     delta = index - state.length - end + 1;</span>
<a href="#l28.75"></a><span id="l28.75"> </span>
<a href="#l28.76"></a><span id="l28.76">     this._resultGather(state, results, {}, end, delta, true);</span>
<a href="#l28.77"></a><span id="l28.77">     return results;</span>
<a href="#l28.78"></a><span id="l28.78">   },</span>
<a href="#l28.79"></a><span id="l28.79"> </span>
<a href="#l28.80"></a><span id="l28.80" class="difflineminus">-  _resultGather: function resultGather(aState, aResults, aPresence,</span>
<a href="#l28.81"></a><span id="l28.81" class="difflineminus">-                                       aPatLength, aDelta, alreadyAdjusted) {</span>
<a href="#l28.82"></a><span id="l28.82" class="difflineplus">+  _resultGather(aState, aResults, aPresence, aPatLength, aDelta, alreadyAdjusted) {</span>
<a href="#l28.83"></a><span id="l28.83">     // find the item that this state originated from based on the state's</span>
<a href="#l28.84"></a><span id="l28.84">     //  start character.  offsetToItem holds [string start index, string end</span>
<a href="#l28.85"></a><span id="l28.85">     //  index (exclusive), item reference].  So we want to binary search to</span>
<a href="#l28.86"></a><span id="l28.86">     //  find the string whose start/end index contains the state's start index.</span>
<a href="#l28.87"></a><span id="l28.87">     let low = 0;</span>
<a href="#l28.88"></a><span id="l28.88" class="difflineminus">-    let high = this._numItems-1;</span>
<a href="#l28.89"></a><span id="l28.89" class="difflineplus">+    let high = this._numItems - 1;</span>
<a href="#l28.90"></a><span id="l28.90">     let mid, stringStart, stringEnd;</span>
<a href="#l28.91"></a><span id="l28.91"> </span>
<a href="#l28.92"></a><span id="l28.92">     let patternLast = aState.start - aDelta;</span>
<a href="#l28.93"></a><span id="l28.93">     while (low &lt;= high) {</span>
<a href="#l28.94"></a><span id="l28.94">       mid = low + Math.floor((high - low) / 2); // excessive, especially with js nums</span>
<a href="#l28.95"></a><span id="l28.95" class="difflineminus">-      stringStart = this._offsetsToItems[mid*3];</span>
<a href="#l28.96"></a><span id="l28.96" class="difflineplus">+      stringStart = this._offsetsToItems[mid * 3];</span>
<a href="#l28.97"></a><span id="l28.97">       let startDelta = stringStart - patternLast;</span>
<a href="#l28.98"></a><span id="l28.98" class="difflineminus">-      stringEnd = this._offsetsToItems[mid*3+1];</span>
<a href="#l28.99"></a><span id="l28.99" class="difflineplus">+      stringEnd = this._offsetsToItems[mid * 3 + 1];</span>
<a href="#l28.100"></a><span id="l28.100">       let endDelta = stringEnd - patternLast;</span>
<a href="#l28.101"></a><span id="l28.101" class="difflineminus">-      if (startDelta &gt; 0)</span>
<a href="#l28.102"></a><span id="l28.102" class="difflineplus">+      if (startDelta &gt; 0) {</span>
<a href="#l28.103"></a><span id="l28.103">         high = mid - 1;</span>
<a href="#l28.104"></a><span id="l28.104" class="difflineminus">-      else if (endDelta &lt;= 0)</span>
<a href="#l28.105"></a><span id="l28.105" class="difflineplus">+      } else if (endDelta &lt;= 0) {</span>
<a href="#l28.106"></a><span id="l28.106">         low = mid + 1;</span>
<a href="#l28.107"></a><span id="l28.107" class="difflineminus">-      else {</span>
<a href="#l28.108"></a><span id="l28.108" class="difflineplus">+      } else {</span>
<a href="#l28.109"></a><span id="l28.109">         break;</span>
<a href="#l28.110"></a><span id="l28.110">       }</span>
<a href="#l28.111"></a><span id="l28.111">     }</span>
<a href="#l28.112"></a><span id="l28.112"> </span>
<a href="#l28.113"></a><span id="l28.113">     // - The match occurred completely inside a source string.  Success.</span>
<a href="#l28.114"></a><span id="l28.114">     // - The match spans more than one source strings, and is therefore not</span>
<a href="#l28.115"></a><span id="l28.115">     //   a match.</span>
<a href="#l28.116"></a><span id="l28.116"> </span>
<a href="#l28.117"></a><span id="l28.117" class="difflineat">@@ -164,17 +163,17 @@ SuffixTree.prototype = {</span>
<a href="#l28.118"></a><span id="l28.118">     //   serving as a unique terminal.</span>
<a href="#l28.119"></a><span id="l28.119">     // - The</span>
<a href="#l28.120"></a><span id="l28.120"> </span>
<a href="#l28.121"></a><span id="l28.121">   let patternFirst = patternLast - (aPatLength - 1);</span>
<a href="#l28.122"></a><span id="l28.122"> </span>
<a href="#l28.123"></a><span id="l28.123">   if (patternFirst &gt;= stringStart) {</span>
<a href="#l28.124"></a><span id="l28.124">     if (!(stringStart in aPresence)) {</span>
<a href="#l28.125"></a><span id="l28.125">       aPresence[stringStart] = true;</span>
<a href="#l28.126"></a><span id="l28.126" class="difflineminus">-      aResults.push(this._offsetsToItems[mid*3+2]);</span>
<a href="#l28.127"></a><span id="l28.127" class="difflineplus">+      aResults.push(this._offsetsToItems[mid * 3 + 2]);</span>
<a href="#l28.128"></a><span id="l28.128">     }</span>
<a href="#l28.129"></a><span id="l28.129">   }</span>
<a href="#l28.130"></a><span id="l28.130"> </span>
<a href="#l28.131"></a><span id="l28.131">     // bail if we had it coming OR</span>
<a href="#l28.132"></a><span id="l28.132">     // if the result terminates at/part-way through this state, meaning any</span>
<a href="#l28.133"></a><span id="l28.133">     //  of its children are not going to be actual results, just hangers</span>
<a href="#l28.134"></a><span id="l28.134">     //  on.</span>
<a href="#l28.135"></a><span id="l28.135"> /*</span>
<a href="#l28.136"></a><span id="l28.136" class="difflineat">@@ -184,33 +183,33 @@ dump(&quot;  bailing! (bail was: &quot; + bail + &quot;</span>
<a href="#l28.137"></a><span id="l28.137">     }</span>
<a href="#l28.138"></a><span id="l28.138"> */</span>
<a href="#l28.139"></a><span id="l28.139">     // process our children...</span>
<a href="#l28.140"></a><span id="l28.140">     for (let key in aState) {</span>
<a href="#l28.141"></a><span id="l28.141">       // edges have attributes of length 1...</span>
<a href="#l28.142"></a><span id="l28.142">       if (key.length == 1) {</span>
<a href="#l28.143"></a><span id="l28.143">         let statePrime = aState[key];</span>
<a href="#l28.144"></a><span id="l28.144">         this._resultGather(statePrime, aResults, aPresence, aPatLength,</span>
<a href="#l28.145"></a><span id="l28.145" class="difflineminus">-                           aDelta + aState.length, //(alreadyAdjusted ? 0 : aState.length),</span>
<a href="#l28.146"></a><span id="l28.146" class="difflineplus">+                           aDelta + aState.length, // (alreadyAdjusted ? 0 : aState.length),</span>
<a href="#l28.147"></a><span id="l28.147">                            false);</span>
<a href="#l28.148"></a><span id="l28.148">       }</span>
<a href="#l28.149"></a><span id="l28.149">     }</span>
<a href="#l28.150"></a><span id="l28.150">   },</span>
<a href="#l28.151"></a><span id="l28.151"> </span>
<a href="#l28.152"></a><span id="l28.152">   /**</span>
<a href="#l28.153"></a><span id="l28.153">    * Given a reference 'pair' of a state and a string (may be 'empty'=explicit,</span>
<a href="#l28.154"></a><span id="l28.154">    *  which means no work to do and we return immediately) follow that state</span>
<a href="#l28.155"></a><span id="l28.155">    *  (and then the successive states)'s transitions until we run out of</span>
<a href="#l28.156"></a><span id="l28.156">    *  transitions.  This happens either when we find an explicit state, or</span>
<a href="#l28.157"></a><span id="l28.157">    *  find ourselves partially along an edge (conceptually speaking).  In</span>
<a href="#l28.158"></a><span id="l28.158">    *  the partial case, we return the state prior to the edge traversal.</span>
<a href="#l28.159"></a><span id="l28.159">    * (The information about the 'edge' is contained on its target State;</span>
<a href="#l28.160"></a><span id="l28.160">    *  we can do this because a state is only referenced by one other state.)</span>
<a href="#l28.161"></a><span id="l28.161">    */</span>
<a href="#l28.162"></a><span id="l28.162" class="difflineminus">-  _canonize: function canonize(aState, aStart, aEnd) {</span>
<a href="#l28.163"></a><span id="l28.163" class="difflineplus">+  _canonize(aState, aStart, aEnd) {</span>
<a href="#l28.164"></a><span id="l28.164">     if (aEnd &lt;= aStart) {</span>
<a href="#l28.165"></a><span id="l28.165">       return [aState, aStart];</span>
<a href="#l28.166"></a><span id="l28.166">     }</span>
<a href="#l28.167"></a><span id="l28.167"> </span>
<a href="#l28.168"></a><span id="l28.168">     let statePrime;</span>
<a href="#l28.169"></a><span id="l28.169">     // we treat an aState of null as 'bottom', which has transitions for every</span>
<a href="#l28.170"></a><span id="l28.170">     //  letter in the alphabet to 'root'.  rather than create all those</span>
<a href="#l28.171"></a><span id="l28.171">     //  transitions, we special-case here.</span>
<a href="#l28.172"></a><span id="l28.172" class="difflineat">@@ -231,47 +230,45 @@ dump(&quot;  bailing! (bail was: &quot; + bail + &quot;</span>
<a href="#l28.173"></a><span id="l28.173">   /**</span>
<a href="#l28.174"></a><span id="l28.174">    * Given a reference 'pair' whose state may or may not be explicit (and for</span>
<a href="#l28.175"></a><span id="l28.175">    *  which we will perform the required splitting to make it explicit), test</span>
<a href="#l28.176"></a><span id="l28.176">    *  whether it already possesses a transition corresponding to the provided</span>
<a href="#l28.177"></a><span id="l28.177">    *  character.</span>
<a href="#l28.178"></a><span id="l28.178">    * @return A list of: whether we had to make it explicit, the (potentially)</span>
<a href="#l28.179"></a><span id="l28.179">    *    new explicit state.</span>
<a href="#l28.180"></a><span id="l28.180">    */</span>
<a href="#l28.181"></a><span id="l28.181" class="difflineminus">-  _testAndSplit: function testAndSplit(aState, aStart, aEnd, aChar) {</span>
<a href="#l28.182"></a><span id="l28.182" class="difflineplus">+  _testAndSplit(aState, aStart, aEnd, aChar) {</span>
<a href="#l28.183"></a><span id="l28.183">     if (aStart &lt; aEnd) { // it's not explicit</span>
<a href="#l28.184"></a><span id="l28.184">       let statePrime = aState[this._str[aStart]];</span>
<a href="#l28.185"></a><span id="l28.185">       let length = aEnd - aStart;</span>
<a href="#l28.186"></a><span id="l28.186">       if (aChar == this._str[statePrime.start + length]) {</span>
<a href="#l28.187"></a><span id="l28.187">         return [true, aState];</span>
<a href="#l28.188"></a><span id="l28.188">       }</span>
<a href="#l28.189"></a><span id="l28.189" class="difflineminus">-      else {</span>
<a href="#l28.190"></a><span id="l28.190" class="difflineminus">-        // do splitting... aState -&gt; rState -&gt; statePrime</span>
<a href="#l28.191"></a><span id="l28.191" class="difflineminus">-        let rState = new State(statePrime.start, statePrime.start + length);</span>
<a href="#l28.192"></a><span id="l28.192" class="difflineminus">-        aState[this._str[statePrime.start]] = rState;</span>
<a href="#l28.193"></a><span id="l28.193" class="difflineminus">-        statePrime.start += length;</span>
<a href="#l28.194"></a><span id="l28.194" class="difflineminus">-        rState[this._str[statePrime.start]] = statePrime;</span>
<a href="#l28.195"></a><span id="l28.195" class="difflineminus">-        return [false, rState];</span>
<a href="#l28.196"></a><span id="l28.196" class="difflineminus">-      }</span>
<a href="#l28.197"></a><span id="l28.197" class="difflineminus">-    }</span>
<a href="#l28.198"></a><span id="l28.198" class="difflineminus">-    else { // it's already explicit</span>
<a href="#l28.199"></a><span id="l28.199" class="difflineminus">-      if (aState === null) { // bottom case... shouldn't happen, but hey.</span>
<a href="#l28.200"></a><span id="l28.200" class="difflineminus">-        return [true, aState];</span>
<a href="#l28.201"></a><span id="l28.201" class="difflineminus">-      }</span>
<a href="#l28.202"></a><span id="l28.202" class="difflineminus">-      return [(aChar in aState), aState];</span>
<a href="#l28.203"></a><span id="l28.203" class="difflineplus">+</span>
<a href="#l28.204"></a><span id="l28.204" class="difflineplus">+      // do splitting... aState -&gt; rState -&gt; statePrime</span>
<a href="#l28.205"></a><span id="l28.205" class="difflineplus">+      let rState = new State(statePrime.start, statePrime.start + length);</span>
<a href="#l28.206"></a><span id="l28.206" class="difflineplus">+      aState[this._str[statePrime.start]] = rState;</span>
<a href="#l28.207"></a><span id="l28.207" class="difflineplus">+      statePrime.start += length;</span>
<a href="#l28.208"></a><span id="l28.208" class="difflineplus">+      rState[this._str[statePrime.start]] = statePrime;</span>
<a href="#l28.209"></a><span id="l28.209" class="difflineplus">+      return [false, rState];</span>
<a href="#l28.210"></a><span id="l28.210">     }</span>
<a href="#l28.211"></a><span id="l28.211"> </span>
<a href="#l28.212"></a><span id="l28.212" class="difflineplus">+    // it's already explicit</span>
<a href="#l28.213"></a><span id="l28.213" class="difflineplus">+    if (aState === null) { // bottom case... shouldn't happen, but hey.</span>
<a href="#l28.214"></a><span id="l28.214" class="difflineplus">+      return [true, aState];</span>
<a href="#l28.215"></a><span id="l28.215" class="difflineplus">+    }</span>
<a href="#l28.216"></a><span id="l28.216" class="difflineplus">+    return [(aChar in aState), aState];</span>
<a href="#l28.217"></a><span id="l28.217">   },</span>
<a href="#l28.218"></a><span id="l28.218"> </span>
<a href="#l28.219"></a><span id="l28.219" class="difflineminus">-  _update: function update(aState, aStart, aIndex) {</span>
<a href="#l28.220"></a><span id="l28.220" class="difflineplus">+  _update(aState, aStart, aIndex) {</span>
<a href="#l28.221"></a><span id="l28.221">     let oldR = this._root;</span>
<a href="#l28.222"></a><span id="l28.222">     let textAtIndex = this._str[aIndex]; // T sub i (0-based corrected...)</span>
<a href="#l28.223"></a><span id="l28.223">     // because of the way we store the 'end' value as a one-past form, we do</span>
<a href="#l28.224"></a><span id="l28.224">     //  not need to subtract 1 off of aIndex.</span>
<a href="#l28.225"></a><span id="l28.225" class="difflineminus">-    let [endPoint, rState] = this._testAndSplit(aState, aStart, aIndex, //no -1</span>
<a href="#l28.226"></a><span id="l28.226" class="difflineplus">+    let [endPoint, rState] = this._testAndSplit(aState, aStart, aIndex, // no -1</span>
<a href="#l28.227"></a><span id="l28.227">                                                 textAtIndex);</span>
<a href="#l28.228"></a><span id="l28.228">     while (!endPoint) {</span>
<a href="#l28.229"></a><span id="l28.229">       let rPrime = new State(aIndex, this._infinity);</span>
<a href="#l28.230"></a><span id="l28.230">       rState[textAtIndex] = rPrime;</span>
<a href="#l28.231"></a><span id="l28.231">       if (oldR !== this._root)</span>
<a href="#l28.232"></a><span id="l28.232">         oldR.suffix = rState;</span>
<a href="#l28.233"></a><span id="l28.233">       oldR = rState;</span>
<a href="#l28.234"></a><span id="l28.234">       [aState, aStart] = this._canonize(aState.suffix, aStart, aIndex); // no -1</span>
<a href="#l28.235"></a><span id="l28.235" class="difflineat">@@ -279,59 +276,60 @@ dump(&quot;  bailing! (bail was: &quot; + bail + &quot;</span>
<a href="#l28.236"></a><span id="l28.236">                                               textAtIndex);</span>
<a href="#l28.237"></a><span id="l28.237">     }</span>
<a href="#l28.238"></a><span id="l28.238">     if (oldR !== this._root)</span>
<a href="#l28.239"></a><span id="l28.239">       oldR.suffix = aState;</span>
<a href="#l28.240"></a><span id="l28.240"> </span>
<a href="#l28.241"></a><span id="l28.241">     return [aState, aStart];</span>
<a href="#l28.242"></a><span id="l28.242">   },</span>
<a href="#l28.243"></a><span id="l28.243"> </span>
<a href="#l28.244"></a><span id="l28.244" class="difflineminus">-  _construct: function construct(aStr) {</span>
<a href="#l28.245"></a><span id="l28.245" class="difflineplus">+  _construct(aStr) {</span>
<a href="#l28.246"></a><span id="l28.246">     this._str = aStr;</span>
<a href="#l28.247"></a><span id="l28.247">     // just needs to be longer than the string.</span>
<a href="#l28.248"></a><span id="l28.248">     this._infinity = aStr.length + 1;</span>
<a href="#l28.249"></a><span id="l28.249"> </span>
<a href="#l28.250"></a><span id="l28.250" class="difflineminus">-    //this._bottom = new State(0, -1, null);</span>
<a href="#l28.251"></a><span id="l28.251" class="difflineplus">+    // this._bottom = new State(0, -1, null);</span>
<a href="#l28.252"></a><span id="l28.252">     this._root = new State(-1, 0, null); // null === bottom</span>
<a href="#l28.253"></a><span id="l28.253">     let state = this._root;</span>
<a href="#l28.254"></a><span id="l28.254">     let start = 0;</span>
<a href="#l28.255"></a><span id="l28.255"> </span>
<a href="#l28.256"></a><span id="l28.256">     for (let i = 0; i &lt; aStr.length; i++) {</span>
<a href="#l28.257"></a><span id="l28.257">       [state, start] = this._update(state, start, i); // treat as flowing -1...</span>
<a href="#l28.258"></a><span id="l28.258" class="difflineminus">-      [state, start] = this._canonize(state, start, i+1); // 1-length string</span>
<a href="#l28.259"></a><span id="l28.259" class="difflineplus">+      [state, start] = this._canonize(state, start, i + 1); // 1-length string</span>
<a href="#l28.260"></a><span id="l28.260">     }</span>
<a href="#l28.261"></a><span id="l28.261">   },</span>
<a href="#l28.262"></a><span id="l28.262"> </span>
<a href="#l28.263"></a><span id="l28.263" class="difflineminus">-  dump: function SuffixTree_show(aState, aIndent, aKey) {</span>
<a href="#l28.264"></a><span id="l28.264" class="difflineplus">+  dump(aState, aIndent, aKey) {</span>
<a href="#l28.265"></a><span id="l28.265">     if (aState === undefined)</span>
<a href="#l28.266"></a><span id="l28.266">       aState = this._root;</span>
<a href="#l28.267"></a><span id="l28.267">     if (aIndent === undefined) {</span>
<a href="#l28.268"></a><span id="l28.268">       aIndent = &quot;&quot;;</span>
<a href="#l28.269"></a><span id="l28.269">       aKey = &quot;.&quot;;</span>
<a href="#l28.270"></a><span id="l28.270">     }</span>
<a href="#l28.271"></a><span id="l28.271"> </span>
<a href="#l28.272"></a><span id="l28.272">     if (aState.isImplicit) {</span>
<a href="#l28.273"></a><span id="l28.273">       let snip;</span>
<a href="#l28.274"></a><span id="l28.274" class="difflineminus">-      if (aState.length &gt; 10)</span>
<a href="#l28.275"></a><span id="l28.275" class="difflineplus">+      if (aState.length &gt; 10) {</span>
<a href="#l28.276"></a><span id="l28.276">         snip = this._str.slice(aState.start,</span>
<a href="#l28.277"></a><span id="l28.277" class="difflineminus">-                           Math.min(aState.start+10, this._str.length)) + &quot;...&quot;;</span>
<a href="#l28.278"></a><span id="l28.278" class="difflineminus">-      else</span>
<a href="#l28.279"></a><span id="l28.279" class="difflineplus">+                               Math.min(aState.start + 10, this._str.length)) + &quot;...&quot;;</span>
<a href="#l28.280"></a><span id="l28.280" class="difflineplus">+      } else {</span>
<a href="#l28.281"></a><span id="l28.281">         snip =  this._str.slice(aState.start,</span>
<a href="#l28.282"></a><span id="l28.282">                                 Math.min(aState.end, this._str.length));</span>
<a href="#l28.283"></a><span id="l28.283" class="difflineplus">+      }</span>
<a href="#l28.284"></a><span id="l28.284">       dump(aIndent + aKey + &quot;:&quot; + snip + &quot;(&quot; +</span>
<a href="#l28.285"></a><span id="l28.285">            aState.start + &quot;:&quot; + aState.end + &quot;)\n&quot;);</span>
<a href="#l28.286"></a><span id="l28.286" class="difflineplus">+    } else {</span>
<a href="#l28.287"></a><span id="l28.287" class="difflineplus">+      dump(aIndent + aKey + &quot;: (explicit:&quot; + aState.start + &quot;:&quot; + aState.end + &quot;)\n&quot;);</span>
<a href="#l28.288"></a><span id="l28.288">     }</span>
<a href="#l28.289"></a><span id="l28.289" class="difflineminus">-    else</span>
<a href="#l28.290"></a><span id="l28.290" class="difflineminus">-      dump(aIndent + aKey + &quot;: (explicit:&quot; + aState.start + &quot;:&quot; + aState.end +&quot;)\n&quot;);</span>
<a href="#l28.291"></a><span id="l28.291">     let nextIndent = aIndent + &quot;  &quot;;</span>
<a href="#l28.292"></a><span id="l28.292">     let keys = Object.keys(aState).filter(c =&gt; c.length == 1);</span>
<a href="#l28.293"></a><span id="l28.293">     for (let key of keys) {</span>
<a href="#l28.294"></a><span id="l28.294">       this.dump(aState[key], nextIndent, key);</span>
<a href="#l28.295"></a><span id="l28.295">     }</span>
<a href="#l28.296"></a><span id="l28.296" class="difflineminus">-  }</span>
<a href="#l28.297"></a><span id="l28.297" class="difflineplus">+  },</span>
<a href="#l28.298"></a><span id="l28.298"> };</span>
<a href="#l28.299"></a><span id="l28.299"> MultiSuffixTree.prototype = SuffixTree.prototype;</span>
<a href="#l28.300"></a><span id="l28.300"> </span>
<a href="#l28.301"></a><span id="l28.301"> function examplar() {</span>
<a href="#l28.302"></a><span id="l28.302">   let names = [&quot;AndrewSmith&quot;, &quot;AndrewJones&quot;, &quot;MarkSmith&quot;, &quot;BryanClark&quot;,</span>
<a href="#l28.303"></a><span id="l28.303">                &quot;MarthaJones&quot;, &quot;DavidAscher&quot;, &quot;DanMosedale&quot;, &quot;DavidBienvenu&quot;,</span>
<a href="#l28.304"></a><span id="l28.304">                &quot;JanetDavis&quot;, &quot;JosephBryant&quot;];</span>
<a href="#l28.305"></a><span id="l28.305">   let b = new MultiSuffixTree(names, names);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/mailnews/db/gloda/modules/utils.js</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/utils.js</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -1,29 +1,29 @@</span>
<a href="#l29.4"></a><span id="l29.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l29.5"></a><span id="l29.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l29.6"></a><span id="l29.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l29.7"></a><span id="l29.7"> </span>
<a href="#l29.8"></a><span id="l29.8" class="difflineminus">-this.EXPORTED_SYMBOLS = ['GlodaUtils'];</span>
<a href="#l29.9"></a><span id="l29.9" class="difflineplus">+this.EXPORTED_SYMBOLS = [&quot;GlodaUtils&quot;];</span>
<a href="#l29.10"></a><span id="l29.10"> </span>
<a href="#l29.11"></a><span id="l29.11"> const {MailServices} = ChromeUtils.import(&quot;resource:///modules/MailServices.jsm&quot;);</span>
<a href="#l29.12"></a><span id="l29.12"> </span>
<a href="#l29.13"></a><span id="l29.13"> /**</span>
<a href="#l29.14"></a><span id="l29.14">  * @namespace A holding place for logic that is not gloda-specific and should</span>
<a href="#l29.15"></a><span id="l29.15">  *  reside elsewhere.</span>
<a href="#l29.16"></a><span id="l29.16">  */</span>
<a href="#l29.17"></a><span id="l29.17"> var GlodaUtils = {</span>
<a href="#l29.18"></a><span id="l29.18"> </span>
<a href="#l29.19"></a><span id="l29.19">   /**</span>
<a href="#l29.20"></a><span id="l29.20">    * This Regexp is super-complicated and used at least in two different parts of</span>
<a href="#l29.21"></a><span id="l29.21">    * the code, so let's expose it from one single location.</span>
<a href="#l29.22"></a><span id="l29.22">    */</span>
<a href="#l29.23"></a><span id="l29.23">   PART_RE: new RegExp(&quot;^[^?]+\\?(?:/;section=\\d+\\?)?(?:[^&amp;]+&amp;)*part=([^&amp;]+)(?:&amp;[^&amp;]+)*$&quot;),</span>
<a href="#l29.24"></a><span id="l29.24"> </span>
<a href="#l29.25"></a><span id="l29.25" class="difflineminus">-  deMime: function gloda_utils_deMime(aString) {</span>
<a href="#l29.26"></a><span id="l29.26" class="difflineplus">+  deMime(aString) {</span>
<a href="#l29.27"></a><span id="l29.27">     return MailServices.mimeConverter.decodeMimeHeader(aString, null, false, true);</span>
<a href="#l29.28"></a><span id="l29.28">   },</span>
<a href="#l29.29"></a><span id="l29.29"> </span>
<a href="#l29.30"></a><span id="l29.30">   _headerParser: MailServices.headerParser,</span>
<a href="#l29.31"></a><span id="l29.31"> </span>
<a href="#l29.32"></a><span id="l29.32">   /**</span>
<a href="#l29.33"></a><span id="l29.33">    * Parses an RFC 2822 list of e-mail addresses and returns an object with</span>
<a href="#l29.34"></a><span id="l29.34">    *  4 attributes, as described below.  We will use the example of the user</span>
<a href="#l29.35"></a><span id="l29.35" class="difflineat">@@ -35,62 +35,60 @@ var GlodaUtils = {</span>
<a href="#l29.36"></a><span id="l29.36">    * count: the number of addresses parsed. (ex: 1)</span>
<a href="#l29.37"></a><span id="l29.37">    * addresses: a list of e-mail addresses (ex: [&quot;bob@example.com&quot;])</span>
<a href="#l29.38"></a><span id="l29.38">    * names: a list of names (ex: [&quot;Bob Smith&quot;])</span>
<a href="#l29.39"></a><span id="l29.39">    * fullAddresses: aka the list of name and e-mail together (ex: ['&quot;Bob Smith&quot;</span>
<a href="#l29.40"></a><span id="l29.40">    *  &lt;bob@example.com&gt;']).</span>
<a href="#l29.41"></a><span id="l29.41">    *</span>
<a href="#l29.42"></a><span id="l29.42">    * This method is a convenience wrapper around nsIMsgHeaderParser.</span>
<a href="#l29.43"></a><span id="l29.43">    */</span>
<a href="#l29.44"></a><span id="l29.44" class="difflineminus">-  parseMailAddresses: function gloda_utils_parseMailAddresses(aMailAddresses) {</span>
<a href="#l29.45"></a><span id="l29.45" class="difflineplus">+  parseMailAddresses(aMailAddresses) {</span>
<a href="#l29.46"></a><span id="l29.46">     let addresses = {}, names = {}, fullAddresses = {};</span>
<a href="#l29.47"></a><span id="l29.47">     this._headerParser.parseHeadersWithArray(aMailAddresses, addresses,</span>
<a href="#l29.48"></a><span id="l29.48">                                              names, fullAddresses);</span>
<a href="#l29.49"></a><span id="l29.49">     return {names: names.value, addresses: addresses.value,</span>
<a href="#l29.50"></a><span id="l29.50">             fullAddresses: fullAddresses.value,</span>
<a href="#l29.51"></a><span id="l29.51">             count: names.value.length};</span>
<a href="#l29.52"></a><span id="l29.52">   },</span>
<a href="#l29.53"></a><span id="l29.53"> </span>
<a href="#l29.54"></a><span id="l29.54">   /**</span>
<a href="#l29.55"></a><span id="l29.55">    * MD5 hash a string and return the hex-string result. Impl from nsICryptoHash</span>
<a href="#l29.56"></a><span id="l29.56">    *  docs.</span>
<a href="#l29.57"></a><span id="l29.57">    */</span>
<a href="#l29.58"></a><span id="l29.58" class="difflineminus">-  md5HashString: function gloda_utils_md5hash(aString) {</span>
<a href="#l29.59"></a><span id="l29.59" class="difflineminus">-    let converter = Cc[&quot;@mozilla.org/intl/scriptableunicodeconverter&quot;].</span>
<a href="#l29.60"></a><span id="l29.60" class="difflineminus">-                    createInstance(Ci.nsIScriptableUnicodeConverter);</span>
<a href="#l29.61"></a><span id="l29.61" class="difflineplus">+  md5HashString(aString) {</span>
<a href="#l29.62"></a><span id="l29.62" class="difflineplus">+    let converter = Cc[&quot;@mozilla.org/intl/scriptableunicodeconverter&quot;]</span>
<a href="#l29.63"></a><span id="l29.63" class="difflineplus">+                      .createInstance(Ci.nsIScriptableUnicodeConverter);</span>
<a href="#l29.64"></a><span id="l29.64">     let trash = {};</span>
<a href="#l29.65"></a><span id="l29.65">     converter.charset = &quot;UTF-8&quot;;</span>
<a href="#l29.66"></a><span id="l29.66">     let data = converter.convertToByteArray(aString, trash);</span>
<a href="#l29.67"></a><span id="l29.67"> </span>
<a href="#l29.68"></a><span id="l29.68" class="difflineminus">-    let hasher = Cc['@mozilla.org/security/hash;1'].</span>
<a href="#l29.69"></a><span id="l29.69" class="difflineminus">-                 createInstance(Ci.nsICryptoHash);</span>
<a href="#l29.70"></a><span id="l29.70" class="difflineplus">+    let hasher = Cc[&quot;@mozilla.org/security/hash;1&quot;]</span>
<a href="#l29.71"></a><span id="l29.71" class="difflineplus">+                   .createInstance(Ci.nsICryptoHash);</span>
<a href="#l29.72"></a><span id="l29.72">     hasher.init(Ci.nsICryptoHash.MD5);</span>
<a href="#l29.73"></a><span id="l29.73">     hasher.update(data, data.length);</span>
<a href="#l29.74"></a><span id="l29.74">     let hash = hasher.finish(false);</span>
<a href="#l29.75"></a><span id="l29.75"> </span>
<a href="#l29.76"></a><span id="l29.76">      // return the two-digit hexadecimal code for a byte</span>
<a href="#l29.77"></a><span id="l29.77">     function toHexString(charCode) {</span>
<a href="#l29.78"></a><span id="l29.78">       return (&quot;0&quot; + charCode.toString(16)).slice(-2);</span>
<a href="#l29.79"></a><span id="l29.79">     }</span>
<a href="#l29.80"></a><span id="l29.80"> </span>
<a href="#l29.81"></a><span id="l29.81">     // convert the binary hash data to a hex string.</span>
<a href="#l29.82"></a><span id="l29.82">     let hex = Object.keys(hash).map(i =&gt; toHexString(hash.charCodeAt(i)));</span>
<a href="#l29.83"></a><span id="l29.83">     return hex.join(&quot;&quot;);</span>
<a href="#l29.84"></a><span id="l29.84">   },</span>
<a href="#l29.85"></a><span id="l29.85"> </span>
<a href="#l29.86"></a><span id="l29.86" class="difflineminus">-  getCardForEmail: function gloda_utils_getCardForEmail(aAddress) {</span>
<a href="#l29.87"></a><span id="l29.87" class="difflineplus">+  getCardForEmail(aAddress) {</span>
<a href="#l29.88"></a><span id="l29.88">     // search through all of our local address books looking for a match.</span>
<a href="#l29.89"></a><span id="l29.89">     let enumerator = MailServices.ab.directories;</span>
<a href="#l29.90"></a><span id="l29.90">     let cardForEmailAddress;</span>
<a href="#l29.91"></a><span id="l29.91">     let addrbook;</span>
<a href="#l29.92"></a><span id="l29.92" class="difflineminus">-    while (!cardForEmailAddress &amp;&amp; enumerator.hasMoreElements())</span>
<a href="#l29.93"></a><span id="l29.93" class="difflineminus">-    {</span>
<a href="#l29.94"></a><span id="l29.94" class="difflineplus">+    while (!cardForEmailAddress &amp;&amp; enumerator.hasMoreElements()) {</span>
<a href="#l29.95"></a><span id="l29.95">       addrbook = enumerator.getNext().QueryInterface(Ci.nsIAbDirectory);</span>
<a href="#l29.96"></a><span id="l29.96" class="difflineminus">-      try</span>
<a href="#l29.97"></a><span id="l29.97" class="difflineminus">-      {</span>
<a href="#l29.98"></a><span id="l29.98" class="difflineplus">+      try {</span>
<a href="#l29.99"></a><span id="l29.99">         cardForEmailAddress = addrbook.cardForEmailAddress(aAddress);</span>
<a href="#l29.100"></a><span id="l29.100">         if (cardForEmailAddress)</span>
<a href="#l29.101"></a><span id="l29.101">           return cardForEmailAddress;</span>
<a href="#l29.102"></a><span id="l29.102">       } catch (ex) {}</span>
<a href="#l29.103"></a><span id="l29.103">     }</span>
<a href="#l29.104"></a><span id="l29.104"> </span>
<a href="#l29.105"></a><span id="l29.105">     return null;</span>
<a href="#l29.106"></a><span id="l29.106">   },</span>
<a href="#l29.107"></a><span id="l29.107" class="difflineat">@@ -112,17 +110,17 @@ var GlodaUtils = {</span>
<a href="#l29.108"></a><span id="l29.108">    *  so we are informed by the indexer's GC triggering.</span>
<a href="#l29.109"></a><span id="l29.109">    *</span>
<a href="#l29.110"></a><span id="l29.110">    * And of course, we don't want to trigger collections willy nilly because</span>
<a href="#l29.111"></a><span id="l29.111">    *  they have a cost even if there is no garbage.</span>
<a href="#l29.112"></a><span id="l29.112">    *</span>
<a href="#l29.113"></a><span id="l29.113">    * @param aNumHeadersSeen The number of headers code has seen.  A granularity</span>
<a href="#l29.114"></a><span id="l29.114">    *     of hundreds of messages should be fine.</span>
<a href="#l29.115"></a><span id="l29.115">    */</span>
<a href="#l29.116"></a><span id="l29.116" class="difflineminus">-  considerHeaderBasedGC: function(aNumHeadersSeen) {</span>
<a href="#l29.117"></a><span id="l29.117" class="difflineplus">+  considerHeaderBasedGC(aNumHeadersSeen) {</span>
<a href="#l29.118"></a><span id="l29.118">     this._headersSeen += aNumHeadersSeen;</span>
<a href="#l29.119"></a><span id="l29.119">     if (this._headersSeen &gt;= this._FORCE_GC_AFTER_NUM_HEADERS)</span>
<a href="#l29.120"></a><span id="l29.120">       this.forceGarbageCollection();</span>
<a href="#l29.121"></a><span id="l29.121">   },</span>
<a href="#l29.122"></a><span id="l29.122"> </span>
<a href="#l29.123"></a><span id="l29.123">   /**</span>
<a href="#l29.124"></a><span id="l29.124">    * Force a garbage-collection sweep.  Gloda has to force garbage collection</span>
<a href="#l29.125"></a><span id="l29.125">    *  periodically because XPConnect's XPCJSRuntime::DeferredRelease mechanism</span>
<a href="#l29.126"></a><span id="l29.126" class="difflineat">@@ -137,14 +135,13 @@ var GlodaUtils = {</span>
<a href="#l29.127"></a><span id="l29.127">    * This method exists mainly to centralize our GC activities and because if</span>
<a href="#l29.128"></a><span id="l29.128">    *  we do start involving the cycle collector, that is a non-trivial block of</span>
<a href="#l29.129"></a><span id="l29.129">    *  code to copy-and-paste all over the place (at least in a module).</span>
<a href="#l29.130"></a><span id="l29.130">    *</span>
<a href="#l29.131"></a><span id="l29.131">    * @param aCycleCollecting Do we need the cycle collector to run?  Currently</span>
<a href="#l29.132"></a><span id="l29.132">    *     unused / unimplemented, but we would use</span>
<a href="#l29.133"></a><span id="l29.133">    *     nsIDOMWindowUtils.garbageCollect() to do so.</span>
<a href="#l29.134"></a><span id="l29.134">    */</span>
<a href="#l29.135"></a><span id="l29.135" class="difflineminus">-  forceGarbageCollection:</span>
<a href="#l29.136"></a><span id="l29.136" class="difflineminus">-      function gloda_utils_garbageCollection(aCycleCollecting) {</span>
<a href="#l29.137"></a><span id="l29.137" class="difflineplus">+  forceGarbageCollection(aCycleCollecting) {</span>
<a href="#l29.138"></a><span id="l29.138">     Cu.forceGC();</span>
<a href="#l29.139"></a><span id="l29.139">     this._headersSeen = 0;</span>
<a href="#l29.140"></a><span id="l29.140" class="difflineminus">-  }</span>
<a href="#l29.141"></a><span id="l29.141" class="difflineplus">+  },</span>
<a href="#l29.142"></a><span id="l29.142"> };</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:31Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

