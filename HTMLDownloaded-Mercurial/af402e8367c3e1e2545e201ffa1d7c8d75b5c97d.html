<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 23357:af402e8367c3e1e2545e201ffa1d7c8d75b5c97d</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ af402e8367c3e1e2545e201ffa1d7c8d75b5c97d" />
<meta property="og:url" content="/comm-central/rev/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d" />
<meta property="og:description" content="Bug 1399756 - remove trailing spaces in mailnews/imap. rs=white-space-only" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / af402e8367c3e1e2545e201ffa1d7c8d75b5c97d 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d">shortlog</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d">files</a> |
changeset |
<a href="/comm-central/raw-rev/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d">raw</a>  | <a href="/comm-central/archive/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399756">Bug 1399756</a> - remove trailing spaces in mailnews/imap. rs=white-space-only
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#114;&#103;&#32;&#75;&#32;&#60;&#106;&#111;&#114;&#103;&#107;&#64;&#106;&#111;&#114;&#103;&#107;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Wed, 21 Feb 2018 23:57:43 +0100</td></tr>

<tr>
 <td>changeset 23357</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d">af402e8367c3e1e2545e201ffa1d7c8d75b5c97d</a></td>
</tr>



<tr>
<td>parent 23356</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/d2ebf88f37f15a4210df79b71f35a96216002696">d2ebf88f37f15a4210df79b71f35a96216002696</a>
</td>
</tr>

<tr>
<td>child 23358</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/c52f5776e940a74c9ee3519a65b92525e557b209">c52f5776e940a74c9ee3519a65b92525e557b209</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=af402e8367c3e1e2545e201ffa1d7c8d75b5c97d">14111</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Wed, 21 Feb 2018 22:59:51 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@af402e8367c3 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=af402e8367c3e1e2545e201ffa1d7c8d75b5c97d">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=af402e8367c3e1e2545e201ffa1d7c8d75b5c97d&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=af402e8367c3e1e2545e201ffa1d7c8d75b5c97d&newProject=comm-central&newRevision=af402e8367c3e1e2545e201ffa1d7c8d75b5c97d&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=af402e8367c3e1e2545e201ffa1d7c8d75b5c97d&newProject=comm-central&newRevision=af402e8367c3e1e2545e201ffa1d7c8d75b5c97d&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=af402e8367c3e1e2545e201ffa1d7c8d75b5c97d&newProject=comm-central&newRevision=af402e8367c3e1e2545e201ffa1d7c8d75b5c97d&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28white-space-only%29&revcount=50">white-space-only</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399756">1399756</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399756">Bug 1399756</a> - remove trailing spaces in mailnews/imap. rs=white-space-only
[skip-blame]</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/public/nsIIMAPHostSessionList.h">mailnews/imap/public/nsIIMAPHostSessionList.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/public/nsIIMAPHostSessionList.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/public/nsIIMAPHostSessionList.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/public/nsIIMAPHostSessionList.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/public/nsIIMAPHostSessionList.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/public/nsIIMAPHostSessionList.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.cpp">mailnews/imap/src/nsAutoSyncManager.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.h">mailnews/imap/src/nsAutoSyncManager.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncManager.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.cpp">mailnews/imap/src/nsAutoSyncState.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.h">mailnews/imap/src/nsAutoSyncState.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsAutoSyncState.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.cpp">mailnews/imap/src/nsIMAPBodyShell.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.h">mailnews/imap/src/nsIMAPBodyShell.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPBodyShell.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.cpp">mailnews/imap/src/nsIMAPGenericParser.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.h">mailnews/imap/src/nsIMAPGenericParser.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPGenericParser.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.cpp">mailnews/imap/src/nsIMAPHostSessionList.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.h">mailnews/imap/src/nsIMAPHostSessionList.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPHostSessionList.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.cpp">mailnews/imap/src/nsIMAPNamespace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.h">mailnews/imap/src/nsIMAPNamespace.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsIMAPNamespace.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapCore.h">mailnews/imap/src/nsImapCore.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapCore.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapCore.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapCore.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapCore.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapCore.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.cpp">mailnews/imap/src/nsImapFlagAndUidState.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.h">mailnews/imap/src/nsImapFlagAndUidState.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapFlagAndUidState.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapIncomingServer.cpp">mailnews/imap/src/nsImapIncomingServer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapIncomingServer.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapIncomingServer.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapIncomingServer.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapIncomingServer.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapIncomingServer.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.cpp">mailnews/imap/src/nsImapMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.h">mailnews/imap/src/nsImapMailFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapMailFolder.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapOfflineSync.h">mailnews/imap/src/nsImapOfflineSync.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapOfflineSync.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapOfflineSync.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapOfflineSync.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapOfflineSync.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapOfflineSync.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapProtocol.h">mailnews/imap/src/nsImapProtocol.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapProtocol.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapProtocol.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapProtocol.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapProtocol.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapProtocol.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.cpp">mailnews/imap/src/nsImapSearchResults.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.h">mailnews/imap/src/nsImapSearchResults.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapSearchResults.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapServerResponseParser.h">mailnews/imap/src/nsImapServerResponseParser.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapServerResponseParser.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapServerResponseParser.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapServerResponseParser.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapServerResponseParser.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapServerResponseParser.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.cpp">mailnews/imap/src/nsImapService.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.h">mailnews/imap/src/nsImapService.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapService.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapStringBundle.cpp">mailnews/imap/src/nsImapStringBundle.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapStringBundle.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapStringBundle.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapStringBundle.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapStringBundle.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapStringBundle.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUndoTxn.cpp">mailnews/imap/src/nsImapUndoTxn.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUndoTxn.cpp">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUndoTxn.cpp">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUndoTxn.cpp">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUndoTxn.cpp">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUndoTxn.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUtils.h">mailnews/imap/src/nsImapUtils.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUtils.h">file</a> |
<a href="/comm-central/annotate/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUtils.h">annotate</a> |
<a href="/comm-central/diff/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUtils.h">diff</a> |
<a href="/comm-central/comparison/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUtils.h">comparison</a> |
<a href="/comm-central/log/af402e8367c3e1e2545e201ffa1d7c8d75b5c97d/mailnews/imap/src/nsImapUtils.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/imap/public/nsIIMAPHostSessionList.h</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/imap/public/nsIIMAPHostSessionList.h</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -12,17 +12,17 @@</span>
<a href="#l1.4"></a><span id="l1.4"> class nsIMAPBodyShellCache;</span>
<a href="#l1.5"></a><span id="l1.5"> class nsIMAPBodyShell;</span>
<a href="#l1.6"></a><span id="l1.6"> class nsIImapIncomingServer;</span>
<a href="#l1.7"></a><span id="l1.7"> </span>
<a href="#l1.8"></a><span id="l1.8"> // f4d89e3e-77da-492c-962b-7835f0742c22</span>
<a href="#l1.9"></a><span id="l1.9"> #define NS_IIMAPHOSTSESSIONLIST_IID \</span>
<a href="#l1.10"></a><span id="l1.10"> { 0xf4d89e3e, 0x77da, 0x492c, {0x96, 0x2b, 0x78, 0x35, 0xf0, 0x74, 0x2c, 0x22 } }</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-// this is an interface to a linked list of host info's    </span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+// this is an interface to a linked list of host info's</span>
<a href="#l1.14"></a><span id="l1.14"> class nsIImapHostSessionList : public nsISupports</span>
<a href="#l1.15"></a><span id="l1.15"> {</span>
<a href="#l1.16"></a><span id="l1.16"> public:</span>
<a href="#l1.17"></a><span id="l1.17">   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IIMAPHOSTSESSIONLIST_IID)</span>
<a href="#l1.18"></a><span id="l1.18"> </span>
<a href="#l1.19"></a><span id="l1.19">   // Host List</span>
<a href="#l1.20"></a><span id="l1.20">   NS_IMETHOD  AddHostToList(const char *serverKey, nsIImapIncomingServer *server) = 0;</span>
<a href="#l1.21"></a><span id="l1.21">   NS_IMETHOD ResetAll() = 0;</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -59,17 +59,17 @@ public:</span>
<a href="#l1.23"></a><span id="l1.23"> </span>
<a href="#l1.24"></a><span id="l1.24">   // Folders</span>
<a href="#l1.25"></a><span id="l1.25">   NS_IMETHOD SetHaveWeEverDiscoveredFoldersForHost(const char *serverKey, bool discovered) = 0;</span>
<a href="#l1.26"></a><span id="l1.26">   NS_IMETHOD GetHaveWeEverDiscoveredFoldersForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.27"></a><span id="l1.27"> </span>
<a href="#l1.28"></a><span id="l1.28">   // Trash Folder</span>
<a href="#l1.29"></a><span id="l1.29">   NS_IMETHOD SetOnlineTrashFolderExistsForHost(const char *serverKey, bool exists) = 0;</span>
<a href="#l1.30"></a><span id="l1.30">   NS_IMETHOD GetOnlineTrashFolderExistsForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-  </span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+</span>
<a href="#l1.33"></a><span id="l1.33">   // INBOX</span>
<a href="#l1.34"></a><span id="l1.34">   NS_IMETHOD  GetOnlineInboxPathForHost(const char *serverKey, nsString &amp;result) = 0;</span>
<a href="#l1.35"></a><span id="l1.35">   NS_IMETHOD  GetShouldAlwaysListInboxForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.36"></a><span id="l1.36">   NS_IMETHOD  SetShouldAlwaysListInboxForHost(const char *serverKey, bool shouldList) = 0;</span>
<a href="#l1.37"></a><span id="l1.37"> </span>
<a href="#l1.38"></a><span id="l1.38">   // Namespaces</span>
<a href="#l1.39"></a><span id="l1.39">   NS_IMETHOD  GetNamespaceForMailboxForHost(const char *serverKey, const char *mailbox_name, nsIMAPNamespace * &amp; result) = 0;</span>
<a href="#l1.40"></a><span id="l1.40">   NS_IMETHOD  SetNamespaceFromPrefForHost(const char *serverKey, const char *namespacePref, EIMAPNamespaceType type) = 0;</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineat">@@ -79,17 +79,17 @@ public:</span>
<a href="#l1.42"></a><span id="l1.42">   NS_IMETHOD  GetDefaultNamespaceOfTypeForHost(const char *serverKey, EIMAPNamespaceType type, nsIMAPNamespace * &amp; result) = 0;</span>
<a href="#l1.43"></a><span id="l1.43">   NS_IMETHOD  SetNamespacesOverridableForHost(const char *serverKey, bool overridable) = 0;</span>
<a href="#l1.44"></a><span id="l1.44">   NS_IMETHOD  GetNamespacesOverridableForHost(const char *serverKey,bool &amp;result) = 0;</span>
<a href="#l1.45"></a><span id="l1.45">   NS_IMETHOD  GetNumberOfNamespacesForHost(const char *serverKey, uint32_t &amp;result) = 0;</span>
<a href="#l1.46"></a><span id="l1.46">   NS_IMETHOD  GetNamespaceNumberForHost(const char *serverKey, int32_t n, nsIMAPNamespace * &amp;result) = 0;</span>
<a href="#l1.47"></a><span id="l1.47">   // ### dmb hoo boy, how are we going to do this?</span>
<a href="#l1.48"></a><span id="l1.48">   NS_IMETHOD  CommitNamespacesForHost(nsIImapIncomingServer *server) = 0;</span>
<a href="#l1.49"></a><span id="l1.49">   NS_IMETHOD  FlushUncommittedNamespacesForHost(const char *serverKey, bool &amp;result) = 0;</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-  </span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+</span>
<a href="#l1.52"></a><span id="l1.52">   // Hierarchy Delimiters</span>
<a href="#l1.53"></a><span id="l1.53">   NS_IMETHOD  SetNamespaceHierarchyDelimiterFromMailboxForHost(const char *serverKey, const char *boxName, char delimiter) = 0;</span>
<a href="#l1.54"></a><span id="l1.54"> </span>
<a href="#l1.55"></a><span id="l1.55">   // Message Body Shells</span>
<a href="#l1.56"></a><span id="l1.56">   NS_IMETHOD  AddShellToCacheForHost(const char *serverKey, nsIMAPBodyShell *shell) = 0;</span>
<a href="#l1.57"></a><span id="l1.57">   NS_IMETHOD  FindShellInCacheForHost(const char *serverKey, const char *mailboxName, const char *UID, IMAP_ContentModifiedType modType, nsIMAPBodyShell **result) = 0;</span>
<a href="#l1.58"></a><span id="l1.58">   NS_IMETHOD  ClearShellCacheForHost(const char *serverKey) = 0;</span>
<a href="#l1.59"></a><span id="l1.59"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncManager.cpp</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncManager.cpp</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -1,12 +1,12 @@</span>
<a href="#l2.4"></a><span id="l2.4"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l2.5"></a><span id="l2.5">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l2.6"></a><span id="l2.6">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l2.7"></a><span id="l2.7" class="difflineminus">- </span>
<a href="#l2.8"></a><span id="l2.8" class="difflineplus">+</span>
<a href="#l2.9"></a><span id="l2.9"> #include &quot;nsAutoSyncManager.h&quot;</span>
<a href="#l2.10"></a><span id="l2.10"> #include &quot;nsAutoSyncState.h&quot;</span>
<a href="#l2.11"></a><span id="l2.11"> #include &quot;nsIIdleService.h&quot;</span>
<a href="#l2.12"></a><span id="l2.12"> #include &quot;nsImapMailFolder.h&quot;</span>
<a href="#l2.13"></a><span id="l2.13"> #include &quot;nsMsgImapCID.h&quot;</span>
<a href="#l2.14"></a><span id="l2.14"> #include &quot;nsIObserverService.h&quot;</span>
<a href="#l2.15"></a><span id="l2.15"> #include &quot;nsIMsgMailNewsUrl.h&quot;</span>
<a href="#l2.16"></a><span id="l2.16"> #include &quot;nsIMsgAccountManager.h&quot;</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineat">@@ -36,66 +36,66 @@ static const uint32_t kDefaultGroupSize </span>
<a href="#l2.18"></a><span id="l2.18"> nsDefaultAutoSyncMsgStrategy::nsDefaultAutoSyncMsgStrategy()</span>
<a href="#l2.19"></a><span id="l2.19"> {</span>
<a href="#l2.20"></a><span id="l2.20"> }</span>
<a href="#l2.21"></a><span id="l2.21"> </span>
<a href="#l2.22"></a><span id="l2.22"> nsDefaultAutoSyncMsgStrategy::~nsDefaultAutoSyncMsgStrategy()</span>
<a href="#l2.23"></a><span id="l2.23"> {</span>
<a href="#l2.24"></a><span id="l2.24"> }</span>
<a href="#l2.25"></a><span id="l2.25"> </span>
<a href="#l2.26"></a><span id="l2.26" class="difflineminus">-NS_IMETHODIMP nsDefaultAutoSyncMsgStrategy::Sort(nsIMsgFolder *aFolder, </span>
<a href="#l2.27"></a><span id="l2.27" class="difflineplus">+NS_IMETHODIMP nsDefaultAutoSyncMsgStrategy::Sort(nsIMsgFolder *aFolder,</span>
<a href="#l2.28"></a><span id="l2.28">   nsIMsgDBHdr *aMsgHdr1, nsIMsgDBHdr *aMsgHdr2, nsAutoSyncStrategyDecisionType *aDecision)</span>
<a href="#l2.29"></a><span id="l2.29"> {</span>
<a href="#l2.30"></a><span id="l2.30">   NS_ENSURE_ARG_POINTER(aDecision);</span>
<a href="#l2.31"></a><span id="l2.31"> </span>
<a href="#l2.32"></a><span id="l2.32">   uint32_t msgSize1 = 0, msgSize2 = 0;</span>
<a href="#l2.33"></a><span id="l2.33">   PRTime msgDate1 = 0, msgDate2 = 0;</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineminus">-  </span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+</span>
<a href="#l2.36"></a><span id="l2.36">   if (!aMsgHdr1 || !aMsgHdr2)</span>
<a href="#l2.37"></a><span id="l2.37">   {</span>
<a href="#l2.38"></a><span id="l2.38">     *aDecision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l2.39"></a><span id="l2.39">     return NS_OK;</span>
<a href="#l2.40"></a><span id="l2.40">   }</span>
<a href="#l2.41"></a><span id="l2.41"> </span>
<a href="#l2.42"></a><span id="l2.42">   aMsgHdr1-&gt;GetMessageSize(&amp;msgSize1);</span>
<a href="#l2.43"></a><span id="l2.43">   aMsgHdr1-&gt;GetDate(&amp;msgDate1);</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineminus">-  </span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+</span>
<a href="#l2.46"></a><span id="l2.46">   aMsgHdr2-&gt;GetMessageSize(&amp;msgSize2);</span>
<a href="#l2.47"></a><span id="l2.47">   aMsgHdr2-&gt;GetDate(&amp;msgDate2);</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineminus">-  </span>
<a href="#l2.49"></a><span id="l2.49" class="difflineminus">-  //Special case: if message size is larger than a </span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+  //Special case: if message size is larger than a</span>
<a href="#l2.52"></a><span id="l2.52">   // certain size, then place it to the bottom of the q</span>
<a href="#l2.53"></a><span id="l2.53">   if (msgSize2 &gt; kFirstPassMessageSize &amp;&amp; msgSize1 &gt; kFirstPassMessageSize)</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineminus">-    *aDecision = msgSize2 &gt; msgSize1 ? </span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+    *aDecision = msgSize2 &gt; msgSize1 ?</span>
<a href="#l2.56"></a><span id="l2.56">         nsAutoSyncStrategyDecisions::Lower : nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l2.57"></a><span id="l2.57">   else if (msgSize2 &gt; kFirstPassMessageSize)</span>
<a href="#l2.58"></a><span id="l2.58">     *aDecision = nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l2.59"></a><span id="l2.59">   else if (msgSize1 &gt; kFirstPassMessageSize)</span>
<a href="#l2.60"></a><span id="l2.60">     *aDecision = nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l2.61"></a><span id="l2.61">   else</span>
<a href="#l2.62"></a><span id="l2.62">   {</span>
<a href="#l2.63"></a><span id="l2.63">     // Most recent and smallest first</span>
<a href="#l2.64"></a><span id="l2.64">     if (msgDate1 &lt; msgDate2)</span>
<a href="#l2.65"></a><span id="l2.65">       *aDecision = nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l2.66"></a><span id="l2.66">     else if (msgDate1 &gt; msgDate2)</span>
<a href="#l2.67"></a><span id="l2.67">       *aDecision = nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineminus">-    else </span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+    else</span>
<a href="#l2.70"></a><span id="l2.70">     {</span>
<a href="#l2.71"></a><span id="l2.71">       if (msgSize1 &gt; msgSize2)</span>
<a href="#l2.72"></a><span id="l2.72">         *aDecision = nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l2.73"></a><span id="l2.73">       else if (msgSize1 &lt; msgSize2)</span>
<a href="#l2.74"></a><span id="l2.74">         *aDecision = nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l2.75"></a><span id="l2.75">       else</span>
<a href="#l2.76"></a><span id="l2.76">         *aDecision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l2.77"></a><span id="l2.77">     }</span>
<a href="#l2.78"></a><span id="l2.78">   }</span>
<a href="#l2.79"></a><span id="l2.79">   return NS_OK;</span>
<a href="#l2.80"></a><span id="l2.80"> }</span>
<a href="#l2.81"></a><span id="l2.81"> </span>
<a href="#l2.82"></a><span id="l2.82" class="difflineminus">-NS_IMETHODIMP nsDefaultAutoSyncMsgStrategy::IsExcluded(nsIMsgFolder *aFolder, </span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+NS_IMETHODIMP nsDefaultAutoSyncMsgStrategy::IsExcluded(nsIMsgFolder *aFolder,</span>
<a href="#l2.84"></a><span id="l2.84">   nsIMsgDBHdr *aMsgHdr, bool *aDecision)</span>
<a href="#l2.85"></a><span id="l2.85"> {</span>
<a href="#l2.86"></a><span id="l2.86">   NS_ENSURE_ARG_POINTER(aDecision);</span>
<a href="#l2.87"></a><span id="l2.87">   NS_ENSURE_ARG_POINTER(aMsgHdr);</span>
<a href="#l2.88"></a><span id="l2.88">   NS_ENSURE_ARG_POINTER(aFolder);</span>
<a href="#l2.89"></a><span id="l2.89">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l2.90"></a><span id="l2.90"> </span>
<a href="#l2.91"></a><span id="l2.91">   nsresult rv = aFolder-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineat">@@ -116,76 +116,76 @@ NS_IMPL_ISUPPORTS(nsDefaultAutoSyncFolde</span>
<a href="#l2.93"></a><span id="l2.93"> nsDefaultAutoSyncFolderStrategy::nsDefaultAutoSyncFolderStrategy()</span>
<a href="#l2.94"></a><span id="l2.94"> {</span>
<a href="#l2.95"></a><span id="l2.95"> }</span>
<a href="#l2.96"></a><span id="l2.96"> </span>
<a href="#l2.97"></a><span id="l2.97"> nsDefaultAutoSyncFolderStrategy::~nsDefaultAutoSyncFolderStrategy()</span>
<a href="#l2.98"></a><span id="l2.98"> {</span>
<a href="#l2.99"></a><span id="l2.99"> }</span>
<a href="#l2.100"></a><span id="l2.100"> </span>
<a href="#l2.101"></a><span id="l2.101" class="difflineminus">-NS_IMETHODIMP nsDefaultAutoSyncFolderStrategy::Sort(nsIMsgFolder *aFolderA, </span>
<a href="#l2.102"></a><span id="l2.102" class="difflineplus">+NS_IMETHODIMP nsDefaultAutoSyncFolderStrategy::Sort(nsIMsgFolder *aFolderA,</span>
<a href="#l2.103"></a><span id="l2.103">   nsIMsgFolder *aFolderB, nsAutoSyncStrategyDecisionType *aDecision)</span>
<a href="#l2.104"></a><span id="l2.104"> {</span>
<a href="#l2.105"></a><span id="l2.105">   NS_ENSURE_ARG_POINTER(aDecision);</span>
<a href="#l2.106"></a><span id="l2.106"> </span>
<a href="#l2.107"></a><span id="l2.107">   if (!aFolderA || !aFolderB)</span>
<a href="#l2.108"></a><span id="l2.108">   {</span>
<a href="#l2.109"></a><span id="l2.109">     *aDecision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l2.110"></a><span id="l2.110">     return NS_OK;</span>
<a href="#l2.111"></a><span id="l2.111">   }</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineminus">-  </span>
<a href="#l2.113"></a><span id="l2.113" class="difflineplus">+</span>
<a href="#l2.114"></a><span id="l2.114">   bool isInbox1, isInbox2, isDrafts1, isDrafts2, isTrash1, isTrash2;</span>
<a href="#l2.115"></a><span id="l2.115">   aFolderA-&gt;GetFlag(nsMsgFolderFlags::Inbox, &amp;isInbox1);</span>
<a href="#l2.116"></a><span id="l2.116">   aFolderB-&gt;GetFlag(nsMsgFolderFlags::Inbox, &amp;isInbox2);</span>
<a href="#l2.117"></a><span id="l2.117">   //</span>
<a href="#l2.118"></a><span id="l2.118">   aFolderA-&gt;GetFlag(nsMsgFolderFlags::Drafts, &amp;isDrafts1);</span>
<a href="#l2.119"></a><span id="l2.119">   aFolderB-&gt;GetFlag(nsMsgFolderFlags::Drafts, &amp;isDrafts2);</span>
<a href="#l2.120"></a><span id="l2.120">   //</span>
<a href="#l2.121"></a><span id="l2.121">   aFolderA-&gt;GetFlag(nsMsgFolderFlags::Trash, &amp;isTrash1);</span>
<a href="#l2.122"></a><span id="l2.122">   aFolderB-&gt;GetFlag(nsMsgFolderFlags::Trash, &amp;isTrash2);</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineminus">-  </span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+</span>
<a href="#l2.125"></a><span id="l2.125">   //Follow this order;</span>
<a href="#l2.126"></a><span id="l2.126">   // INBOX &gt; DRAFTS &gt; SUBFOLDERS &gt; TRASH</span>
<a href="#l2.127"></a><span id="l2.127"> </span>
<a href="#l2.128"></a><span id="l2.128">   // test whether the folder is opened by the user.</span>
<a href="#l2.129"></a><span id="l2.129" class="difflineminus">-  // we give high priority to the folders explicitly opened by </span>
<a href="#l2.130"></a><span id="l2.130" class="difflineplus">+  // we give high priority to the folders explicitly opened by</span>
<a href="#l2.131"></a><span id="l2.131">   // the user.</span>
<a href="#l2.132"></a><span id="l2.132">   nsresult rv;</span>
<a href="#l2.133"></a><span id="l2.133">   bool folderAOpen = false;</span>
<a href="#l2.134"></a><span id="l2.134">   bool folderBOpen = false;</span>
<a href="#l2.135"></a><span id="l2.135">   nsCOMPtr&lt;nsIMsgMailSession&gt; session =</span>
<a href="#l2.136"></a><span id="l2.136">            do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l2.137"></a><span id="l2.137" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; session) </span>
<a href="#l2.138"></a><span id="l2.138" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; session)</span>
<a href="#l2.139"></a><span id="l2.139">   {</span>
<a href="#l2.140"></a><span id="l2.140">     session-&gt;IsFolderOpenInWindow(aFolderA, &amp;folderAOpen);</span>
<a href="#l2.141"></a><span id="l2.141">     session-&gt;IsFolderOpenInWindow(aFolderB, &amp;folderBOpen);</span>
<a href="#l2.142"></a><span id="l2.142">   }</span>
<a href="#l2.143"></a><span id="l2.143"> </span>
<a href="#l2.144"></a><span id="l2.144">   if (folderAOpen == folderBOpen)</span>
<a href="#l2.145"></a><span id="l2.145">   {</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineminus">-    // if both of them or none of them are opened by the user </span>
<a href="#l2.147"></a><span id="l2.147" class="difflineplus">+    // if both of them or none of them are opened by the user</span>
<a href="#l2.148"></a><span id="l2.148">     // make your decision based on the folder type</span>
<a href="#l2.149"></a><span id="l2.149">     if (isInbox2 || (isDrafts2 &amp;&amp; !isInbox1) || isTrash1)</span>
<a href="#l2.150"></a><span id="l2.150">       *aDecision = nsAutoSyncStrategyDecisions::Higher;</span>
<a href="#l2.151"></a><span id="l2.151">     else if (isInbox1 || (isDrafts1 &amp;&amp; !isDrafts2) || isTrash2)</span>
<a href="#l2.152"></a><span id="l2.152">       *aDecision = nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l2.153"></a><span id="l2.153">     else</span>
<a href="#l2.154"></a><span id="l2.154">       *aDecision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l2.155"></a><span id="l2.155">   }</span>
<a href="#l2.156"></a><span id="l2.156">   else</span>
<a href="#l2.157"></a><span id="l2.157">   {</span>
<a href="#l2.158"></a><span id="l2.158">     // otherwise give higher priority to opened one</span>
<a href="#l2.159"></a><span id="l2.159">     *aDecision = folderBOpen ? nsAutoSyncStrategyDecisions::Higher :</span>
<a href="#l2.160"></a><span id="l2.160">                                nsAutoSyncStrategyDecisions::Lower;</span>
<a href="#l2.161"></a><span id="l2.161">   }</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineminus">-    </span>
<a href="#l2.163"></a><span id="l2.163" class="difflineplus">+</span>
<a href="#l2.164"></a><span id="l2.164">   return NS_OK;</span>
<a href="#l2.165"></a><span id="l2.165"> }</span>
<a href="#l2.166"></a><span id="l2.166"> </span>
<a href="#l2.167"></a><span id="l2.167" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l2.168"></a><span id="l2.168" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.169"></a><span id="l2.169"> nsDefaultAutoSyncFolderStrategy::IsExcluded(nsIMsgFolder *aFolder, bool *aDecision)</span>
<a href="#l2.170"></a><span id="l2.170"> {</span>
<a href="#l2.171"></a><span id="l2.171">   NS_ENSURE_ARG_POINTER(aDecision);</span>
<a href="#l2.172"></a><span id="l2.172">   NS_ENSURE_ARG_POINTER(aFolder);</span>
<a href="#l2.173"></a><span id="l2.173">   uint32_t folderFlags;</span>
<a href="#l2.174"></a><span id="l2.174">   aFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l2.175"></a><span id="l2.175">   // exclude saved search</span>
<a href="#l2.176"></a><span id="l2.176">   *aDecision = (folderFlags &amp; nsMsgFolderFlags::Virtual);</span>
<a href="#l2.177"></a><span id="l2.177" class="difflineat">@@ -318,208 +318,208 @@ void nsAutoSyncManager::TimerCallback(ns</span>
<a href="#l2.178"></a><span id="l2.178">       nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(autoSyncMgr-&gt;mUpdateQ[0]);</span>
<a href="#l2.179"></a><span id="l2.179">       if (autoSyncStateObj)</span>
<a href="#l2.180"></a><span id="l2.180">       {</span>
<a href="#l2.181"></a><span id="l2.181">         int32_t state;</span>
<a href="#l2.182"></a><span id="l2.182">         nsresult rv = autoSyncStateObj-&gt;GetState(&amp;state);</span>
<a href="#l2.183"></a><span id="l2.183">         if (NS_SUCCEEDED(rv) &amp;&amp; (state == nsAutoSyncState::stCompletedIdle ||</span>
<a href="#l2.184"></a><span id="l2.184">                                  state == nsAutoSyncState::stUpdateNeeded))</span>
<a href="#l2.185"></a><span id="l2.185">         {</span>
<a href="#l2.186"></a><span id="l2.186" class="difflineminus">-          nsCOMPtr&lt;nsIMsgFolder&gt; folder; </span>
<a href="#l2.187"></a><span id="l2.187" class="difflineplus">+          nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l2.188"></a><span id="l2.188">           autoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l2.189"></a><span id="l2.189">           if (folder)</span>
<a href="#l2.190"></a><span id="l2.190">           {</span>
<a href="#l2.191"></a><span id="l2.191">             nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(folder, &amp;rv);</span>
<a href="#l2.192"></a><span id="l2.192">             NS_ENSURE_SUCCESS_VOID(rv);</span>
<a href="#l2.193"></a><span id="l2.193">             rv = imapFolder-&gt;InitiateAutoSync(autoSyncMgr);</span>
<a href="#l2.194"></a><span id="l2.194">             if (NS_SUCCEEDED(rv))</span>
<a href="#l2.195"></a><span id="l2.195">             {</span>
<a href="#l2.196"></a><span id="l2.196">               autoSyncMgr-&gt;mUpdateState = initiated;</span>
<a href="#l2.197"></a><span id="l2.197">               NOTIFY_LISTENERS_STATIC(autoSyncMgr, OnAutoSyncInitiated, (folder));</span>
<a href="#l2.198"></a><span id="l2.198">             }</span>
<a href="#l2.199"></a><span id="l2.199">           }</span>
<a href="#l2.200"></a><span id="l2.200">         }</span>
<a href="#l2.201"></a><span id="l2.201" class="difflineminus">-      } </span>
<a href="#l2.202"></a><span id="l2.202" class="difflineplus">+      }</span>
<a href="#l2.203"></a><span id="l2.203">     }</span>
<a href="#l2.204"></a><span id="l2.204" class="difflineminus">-    // if initiation is not successful for some reason, or </span>
<a href="#l2.205"></a><span id="l2.205" class="difflineminus">-    // if there is an on going download for this folder, </span>
<a href="#l2.206"></a><span id="l2.206" class="difflineminus">-    // remove it from q and continue with the next one  </span>
<a href="#l2.207"></a><span id="l2.207" class="difflineplus">+    // if initiation is not successful for some reason, or</span>
<a href="#l2.208"></a><span id="l2.208" class="difflineplus">+    // if there is an on going download for this folder,</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineplus">+    // remove it from q and continue with the next one</span>
<a href="#l2.210"></a><span id="l2.210">     if (autoSyncMgr-&gt;mUpdateState != initiated)</span>
<a href="#l2.211"></a><span id="l2.211">     {</span>
<a href="#l2.212"></a><span id="l2.212">       nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l2.213"></a><span id="l2.213">       autoSyncMgr-&gt;mUpdateQ[0]-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l2.214"></a><span id="l2.214" class="difflineminus">-      </span>
<a href="#l2.215"></a><span id="l2.215" class="difflineplus">+</span>
<a href="#l2.216"></a><span id="l2.216">       autoSyncMgr-&gt;mUpdateQ.RemoveObjectAt(0);</span>
<a href="#l2.217"></a><span id="l2.217" class="difflineminus">-      </span>
<a href="#l2.218"></a><span id="l2.218" class="difflineplus">+</span>
<a href="#l2.219"></a><span id="l2.219">       if (folder)</span>
<a href="#l2.220"></a><span id="l2.220">         NOTIFY_LISTENERS_STATIC(autoSyncMgr, OnFolderRemovedFromQ, (nsIAutoSyncMgrListener::UpdateQueue, folder));</span>
<a href="#l2.221"></a><span id="l2.221">     }</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineminus">-      </span>
<a href="#l2.223"></a><span id="l2.223" class="difflineplus">+</span>
<a href="#l2.224"></a><span id="l2.224">   }//endif</span>
<a href="#l2.225"></a><span id="l2.225"> </span>
<a href="#l2.226"></a><span id="l2.226"> }</span>
<a href="#l2.227"></a><span id="l2.227"> </span>
<a href="#l2.228"></a><span id="l2.228"> /**</span>
<a href="#l2.229"></a><span id="l2.229" class="difflineminus">- * Populates aChainedQ with the auto-sync state objects that are not owned by </span>
<a href="#l2.230"></a><span id="l2.230" class="difflineminus">- * the same imap server. </span>
<a href="#l2.231"></a><span id="l2.231" class="difflineplus">+ * Populates aChainedQ with the auto-sync state objects that are not owned by</span>
<a href="#l2.232"></a><span id="l2.232" class="difflineplus">+ * the same imap server.</span>
<a href="#l2.233"></a><span id="l2.233">  * Assumes that aChainedQ initially empty.</span>
<a href="#l2.234"></a><span id="l2.234">  */</span>
<a href="#l2.235"></a><span id="l2.235"> void nsAutoSyncManager::ChainFoldersInQ(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l2.236"></a><span id="l2.236">       nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aChainedQ)</span>
<a href="#l2.237"></a><span id="l2.237"> {</span>
<a href="#l2.238"></a><span id="l2.238">   if (aQueue.Count() &gt; 0)</span>
<a href="#l2.239"></a><span id="l2.239">     aChainedQ.AppendObject(aQueue[0]);</span>
<a href="#l2.240"></a><span id="l2.240" class="difflineminus">-  </span>
<a href="#l2.241"></a><span id="l2.241" class="difflineplus">+</span>
<a href="#l2.242"></a><span id="l2.242">   int32_t pqElemCount = aQueue.Count();</span>
<a href="#l2.243"></a><span id="l2.243">   for (int32_t pqidx = 1; pqidx &lt; pqElemCount; pqidx++)</span>
<a href="#l2.244"></a><span id="l2.244">   {</span>
<a href="#l2.245"></a><span id="l2.245">     bool chained = false;</span>
<a href="#l2.246"></a><span id="l2.246">     int32_t needToBeReplacedWith = -1;</span>
<a href="#l2.247"></a><span id="l2.247">     int32_t elemCount = aChainedQ.Count();</span>
<a href="#l2.248"></a><span id="l2.248">     for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l2.249"></a><span id="l2.249">     {</span>
<a href="#l2.250"></a><span id="l2.250">       bool isSibling;</span>
<a href="#l2.251"></a><span id="l2.251">       nsresult rv = aChainedQ[idx]-&gt;IsSibling(aQueue[pqidx], &amp;isSibling);</span>
<a href="#l2.252"></a><span id="l2.252" class="difflineminus">-      </span>
<a href="#l2.253"></a><span id="l2.253" class="difflineplus">+</span>
<a href="#l2.254"></a><span id="l2.254">       if (NS_SUCCEEDED(rv) &amp;&amp; isSibling)</span>
<a href="#l2.255"></a><span id="l2.255">       {</span>
<a href="#l2.256"></a><span id="l2.256">         // this prevent us to overwrite a lower priority sibling in</span>
<a href="#l2.257"></a><span id="l2.257" class="difflineminus">-        // download-in-progress state with a higher priority one. </span>
<a href="#l2.258"></a><span id="l2.258" class="difflineminus">-        // we have to wait until its download is completed before </span>
<a href="#l2.259"></a><span id="l2.259" class="difflineminus">-        // switching to new one. </span>
<a href="#l2.260"></a><span id="l2.260" class="difflineplus">+        // download-in-progress state with a higher priority one.</span>
<a href="#l2.261"></a><span id="l2.261" class="difflineplus">+        // we have to wait until its download is completed before</span>
<a href="#l2.262"></a><span id="l2.262" class="difflineplus">+        // switching to new one.</span>
<a href="#l2.263"></a><span id="l2.263">         int32_t state;</span>
<a href="#l2.264"></a><span id="l2.264">         aQueue[pqidx]-&gt;GetState(&amp;state);</span>
<a href="#l2.265"></a><span id="l2.265" class="difflineminus">-        if (aQueue[pqidx] != aChainedQ[idx] &amp;&amp; </span>
<a href="#l2.266"></a><span id="l2.266" class="difflineplus">+        if (aQueue[pqidx] != aChainedQ[idx] &amp;&amp;</span>
<a href="#l2.267"></a><span id="l2.267">             state == nsAutoSyncState::stDownloadInProgress)</span>
<a href="#l2.268"></a><span id="l2.268">           needToBeReplacedWith = idx;</span>
<a href="#l2.269"></a><span id="l2.269">         else</span>
<a href="#l2.270"></a><span id="l2.270">           chained = true;</span>
<a href="#l2.271"></a><span id="l2.271" class="difflineminus">-          </span>
<a href="#l2.272"></a><span id="l2.272" class="difflineplus">+</span>
<a href="#l2.273"></a><span id="l2.273">         break;</span>
<a href="#l2.274"></a><span id="l2.274">       }</span>
<a href="#l2.275"></a><span id="l2.275">     }//endfor</span>
<a href="#l2.276"></a><span id="l2.276" class="difflineminus">-    </span>
<a href="#l2.277"></a><span id="l2.277" class="difflineplus">+</span>
<a href="#l2.278"></a><span id="l2.278">     if (needToBeReplacedWith &gt; -1)</span>
<a href="#l2.279"></a><span id="l2.279">       aChainedQ.ReplaceObjectAt(aQueue[pqidx], needToBeReplacedWith);</span>
<a href="#l2.280"></a><span id="l2.280">     else if (!chained)</span>
<a href="#l2.281"></a><span id="l2.281">       aChainedQ.AppendObject(aQueue[pqidx]);</span>
<a href="#l2.282"></a><span id="l2.282" class="difflineminus">-      </span>
<a href="#l2.283"></a><span id="l2.283" class="difflineplus">+</span>
<a href="#l2.284"></a><span id="l2.284">   }//endfor</span>
<a href="#l2.285"></a><span id="l2.285"> }</span>
<a href="#l2.286"></a><span id="l2.286"> </span>
<a href="#l2.287"></a><span id="l2.287"> /**</span>
<a href="#l2.288"></a><span id="l2.288">  * Searches the given queue for another folder owned by the same imap server.</span>
<a href="#l2.289"></a><span id="l2.289">  */</span>
<a href="#l2.290"></a><span id="l2.290" class="difflineminus">-nsIAutoSyncState* </span>
<a href="#l2.291"></a><span id="l2.291" class="difflineminus">-nsAutoSyncManager::SearchQForSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue, </span>
<a href="#l2.292"></a><span id="l2.292" class="difflineplus">+nsIAutoSyncState*</span>
<a href="#l2.293"></a><span id="l2.293" class="difflineplus">+nsAutoSyncManager::SearchQForSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l2.294"></a><span id="l2.294">                           nsIAutoSyncState *aAutoSyncStateObj, int32_t aStartIdx, int32_t *aIndex)</span>
<a href="#l2.295"></a><span id="l2.295"> {</span>
<a href="#l2.296"></a><span id="l2.296">   if (aIndex)</span>
<a href="#l2.297"></a><span id="l2.297">     *aIndex = -1;</span>
<a href="#l2.298"></a><span id="l2.298" class="difflineminus">-  </span>
<a href="#l2.299"></a><span id="l2.299" class="difflineplus">+</span>
<a href="#l2.300"></a><span id="l2.300">   if (aAutoSyncStateObj)</span>
<a href="#l2.301"></a><span id="l2.301">   {</span>
<a href="#l2.302"></a><span id="l2.302">     bool isSibling;</span>
<a href="#l2.303"></a><span id="l2.303">     int32_t elemCount = aQueue.Count();</span>
<a href="#l2.304"></a><span id="l2.304">     for (int32_t idx = aStartIdx; idx &lt; elemCount; idx++)</span>
<a href="#l2.305"></a><span id="l2.305">     {</span>
<a href="#l2.306"></a><span id="l2.306">       nsresult rv = aAutoSyncStateObj-&gt;IsSibling(aQueue[idx], &amp;isSibling);</span>
<a href="#l2.307"></a><span id="l2.307" class="difflineminus">-      </span>
<a href="#l2.308"></a><span id="l2.308" class="difflineplus">+</span>
<a href="#l2.309"></a><span id="l2.309">       if (NS_SUCCEEDED(rv) &amp;&amp; isSibling &amp;&amp; aAutoSyncStateObj != aQueue[idx])</span>
<a href="#l2.310"></a><span id="l2.310">       {</span>
<a href="#l2.311"></a><span id="l2.311" class="difflineminus">-        if (aIndex) </span>
<a href="#l2.312"></a><span id="l2.312" class="difflineplus">+        if (aIndex)</span>
<a href="#l2.313"></a><span id="l2.313">           *aIndex = idx;</span>
<a href="#l2.314"></a><span id="l2.314" class="difflineminus">-        </span>
<a href="#l2.315"></a><span id="l2.315" class="difflineplus">+</span>
<a href="#l2.316"></a><span id="l2.316">         return aQueue[idx];</span>
<a href="#l2.317"></a><span id="l2.317">       }</span>
<a href="#l2.318"></a><span id="l2.318">     }</span>
<a href="#l2.319"></a><span id="l2.319">   }</span>
<a href="#l2.320"></a><span id="l2.320" class="difflineminus">-  return nullptr;  </span>
<a href="#l2.321"></a><span id="l2.321" class="difflineplus">+  return nullptr;</span>
<a href="#l2.322"></a><span id="l2.322"> }</span>
<a href="#l2.323"></a><span id="l2.323"> </span>
<a href="#l2.324"></a><span id="l2.324"> /**</span>
<a href="#l2.325"></a><span id="l2.325">  * Searches for the next folder owned by the same imap server in the given queue,</span>
<a href="#l2.326"></a><span id="l2.326">  * starting from the index of the given folder.</span>
<a href="#l2.327"></a><span id="l2.327">  */</span>
<a href="#l2.328"></a><span id="l2.328" class="difflineminus">-nsIAutoSyncState* </span>
<a href="#l2.329"></a><span id="l2.329" class="difflineminus">-nsAutoSyncManager::GetNextSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue, </span>
<a href="#l2.330"></a><span id="l2.330" class="difflineplus">+nsIAutoSyncState*</span>
<a href="#l2.331"></a><span id="l2.331" class="difflineplus">+nsAutoSyncManager::GetNextSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l2.332"></a><span id="l2.332">                                           nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex)</span>
<a href="#l2.333"></a><span id="l2.333" class="difflineminus">-{ </span>
<a href="#l2.334"></a><span id="l2.334" class="difflineplus">+{</span>
<a href="#l2.335"></a><span id="l2.335"> </span>
<a href="#l2.336"></a><span id="l2.336">   if (aIndex)</span>
<a href="#l2.337"></a><span id="l2.337">     *aIndex = -1;</span>
<a href="#l2.338"></a><span id="l2.338" class="difflineminus">-  </span>
<a href="#l2.339"></a><span id="l2.339" class="difflineplus">+</span>
<a href="#l2.340"></a><span id="l2.340">   if (aAutoSyncStateObj)</span>
<a href="#l2.341"></a><span id="l2.341">   {</span>
<a href="#l2.342"></a><span id="l2.342">     bool located = false;</span>
<a href="#l2.343"></a><span id="l2.343">     bool isSibling;</span>
<a href="#l2.344"></a><span id="l2.344">     int32_t elemCount = aQueue.Count();</span>
<a href="#l2.345"></a><span id="l2.345">     for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l2.346"></a><span id="l2.346">     {</span>
<a href="#l2.347"></a><span id="l2.347">       if (!located)</span>
<a href="#l2.348"></a><span id="l2.348">       {</span>
<a href="#l2.349"></a><span id="l2.349">         located = (aAutoSyncStateObj == aQueue[idx]);</span>
<a href="#l2.350"></a><span id="l2.350">         continue;</span>
<a href="#l2.351"></a><span id="l2.351">       }</span>
<a href="#l2.352"></a><span id="l2.352" class="difflineminus">-      </span>
<a href="#l2.353"></a><span id="l2.353" class="difflineplus">+</span>
<a href="#l2.354"></a><span id="l2.354">       nsresult rv = aAutoSyncStateObj-&gt;IsSibling(aQueue[idx], &amp;isSibling);</span>
<a href="#l2.355"></a><span id="l2.355">       if (NS_SUCCEEDED(rv) &amp;&amp; isSibling)</span>
<a href="#l2.356"></a><span id="l2.356">       {</span>
<a href="#l2.357"></a><span id="l2.357" class="difflineminus">-        if (aIndex) </span>
<a href="#l2.358"></a><span id="l2.358" class="difflineplus">+        if (aIndex)</span>
<a href="#l2.359"></a><span id="l2.359">           *aIndex = idx;</span>
<a href="#l2.360"></a><span id="l2.360" class="difflineminus">-        </span>
<a href="#l2.361"></a><span id="l2.361" class="difflineplus">+</span>
<a href="#l2.362"></a><span id="l2.362">         return aQueue[idx];</span>
<a href="#l2.363"></a><span id="l2.363">       }</span>
<a href="#l2.364"></a><span id="l2.364">     }</span>
<a href="#l2.365"></a><span id="l2.365">   }</span>
<a href="#l2.366"></a><span id="l2.366" class="difflineminus">-  return nullptr;  </span>
<a href="#l2.367"></a><span id="l2.367" class="difflineplus">+  return nullptr;</span>
<a href="#l2.368"></a><span id="l2.368"> }</span>
<a href="#l2.369"></a><span id="l2.369"> </span>
<a href="#l2.370"></a><span id="l2.370" class="difflineminus">-/** </span>
<a href="#l2.371"></a><span id="l2.371" class="difflineminus">- * Checks whether there is another folder in the given q that is owned </span>
<a href="#l2.372"></a><span id="l2.372" class="difflineplus">+/**</span>
<a href="#l2.373"></a><span id="l2.373" class="difflineplus">+ * Checks whether there is another folder in the given q that is owned</span>
<a href="#l2.374"></a><span id="l2.374">  * by the same imap server or not.</span>
<a href="#l2.375"></a><span id="l2.375">  *</span>
<a href="#l2.376"></a><span id="l2.376">  * @param aQueue the queue that will be searched for a sibling</span>
<a href="#l2.377"></a><span id="l2.377">  * @param aAutoSyncStateObj the auto-sync state object that we are looking</span>
<a href="#l2.378"></a><span id="l2.378">  *                          a sibling for</span>
<a href="#l2.379"></a><span id="l2.379">  * @param aState the state of the sibling. -1 means &quot;any state&quot;</span>
<a href="#l2.380"></a><span id="l2.380">  * @param aIndex [out] the index of the found sibling, if it is provided by the</span>
<a href="#l2.381"></a><span id="l2.381">  *               caller (not null)</span>
<a href="#l2.382"></a><span id="l2.382">  * @return true if found, false otherwise</span>
<a href="#l2.383"></a><span id="l2.383">  */</span>
<a href="#l2.384"></a><span id="l2.384" class="difflineminus">-bool nsAutoSyncManager::DoesQContainAnySiblingOf(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue, </span>
<a href="#l2.385"></a><span id="l2.385" class="difflineplus">+bool nsAutoSyncManager::DoesQContainAnySiblingOf(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l2.386"></a><span id="l2.386">                                                    nsIAutoSyncState *aAutoSyncStateObj,</span>
<a href="#l2.387"></a><span id="l2.387">                                                    const int32_t aState, int32_t *aIndex)</span>
<a href="#l2.388"></a><span id="l2.388"> {</span>
<a href="#l2.389"></a><span id="l2.389">   if (aState == -1)</span>
<a href="#l2.390"></a><span id="l2.390">     return (nullptr != SearchQForSibling(aQueue, aAutoSyncStateObj, 0, aIndex));</span>
<a href="#l2.391"></a><span id="l2.391" class="difflineminus">-    </span>
<a href="#l2.392"></a><span id="l2.392" class="difflineplus">+</span>
<a href="#l2.393"></a><span id="l2.393">   int32_t offset = 0;</span>
<a href="#l2.394"></a><span id="l2.394">   nsIAutoSyncState *autoSyncState;</span>
<a href="#l2.395"></a><span id="l2.395">   while ((autoSyncState = SearchQForSibling(aQueue, aAutoSyncStateObj, offset, &amp;offset)))</span>
<a href="#l2.396"></a><span id="l2.396">   {</span>
<a href="#l2.397"></a><span id="l2.397">     int32_t state;</span>
<a href="#l2.398"></a><span id="l2.398">     nsresult rv = autoSyncState-&gt;GetState(&amp;state);</span>
<a href="#l2.399"></a><span id="l2.399">     if (NS_SUCCEEDED(rv) &amp;&amp; aState == state)</span>
<a href="#l2.400"></a><span id="l2.400">       break;</span>
<a href="#l2.401"></a><span id="l2.401"> </span>
<a href="#l2.402"></a><span id="l2.402">     offset++;</span>
<a href="#l2.403"></a><span id="l2.403">   }</span>
<a href="#l2.404"></a><span id="l2.404">   if (aIndex)</span>
<a href="#l2.405"></a><span id="l2.405">     *aIndex = offset;</span>
<a href="#l2.406"></a><span id="l2.406" class="difflineminus">-    </span>
<a href="#l2.407"></a><span id="l2.407" class="difflineplus">+</span>
<a href="#l2.408"></a><span id="l2.408">   return (nullptr != autoSyncState);</span>
<a href="#l2.409"></a><span id="l2.409"> }</span>
<a href="#l2.410"></a><span id="l2.410"> </span>
<a href="#l2.411"></a><span id="l2.411"> /**</span>
<a href="#l2.412"></a><span id="l2.412">  * Searches the given queue for the highest priority folder owned by the</span>
<a href="#l2.413"></a><span id="l2.413">  * same imap server.</span>
<a href="#l2.414"></a><span id="l2.414">  */</span>
<a href="#l2.415"></a><span id="l2.415" class="difflineminus">-nsIAutoSyncState* </span>
<a href="#l2.416"></a><span id="l2.416" class="difflineminus">-nsAutoSyncManager::GetHighestPrioSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue, </span>
<a href="#l2.417"></a><span id="l2.417" class="difflineplus">+nsIAutoSyncState*</span>
<a href="#l2.418"></a><span id="l2.418" class="difflineplus">+nsAutoSyncManager::GetHighestPrioSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l2.419"></a><span id="l2.419">                                       nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex)</span>
<a href="#l2.420"></a><span id="l2.420"> {</span>
<a href="#l2.421"></a><span id="l2.421">   return SearchQForSibling(aQueue, aAutoSyncStateObj, 0, aIndex);</span>
<a href="#l2.422"></a><span id="l2.422"> }</span>
<a href="#l2.423"></a><span id="l2.423"> </span>
<a href="#l2.424"></a><span id="l2.424"> // to chain update folder actions</span>
<a href="#l2.425"></a><span id="l2.425"> NS_IMETHODIMP nsAutoSyncManager::OnStartRunningUrl(nsIURI* aUrl)</span>
<a href="#l2.426"></a><span id="l2.426"> {</span>
<a href="#l2.427"></a><span id="l2.427" class="difflineat">@@ -577,17 +577,17 @@ NS_IMETHODIMP nsAutoSyncManager::Observe</span>
<a href="#l2.428"></a><span id="l2.428">     if (mIdleService)</span>
<a href="#l2.429"></a><span id="l2.429">        mIdleService-&gt;RemoveIdleObserver(this, kIdleTimeInSec);</span>
<a href="#l2.430"></a><span id="l2.430"> </span>
<a href="#l2.431"></a><span id="l2.431">     return NS_OK;</span>
<a href="#l2.432"></a><span id="l2.432">   }</span>
<a href="#l2.433"></a><span id="l2.433"> </span>
<a href="#l2.434"></a><span id="l2.434">   if (!PL_strcmp(aTopic, kStartupDoneNotification))</span>
<a href="#l2.435"></a><span id="l2.435">   {</span>
<a href="#l2.436"></a><span id="l2.436" class="difflineminus">-    mStartupDone = true; </span>
<a href="#l2.437"></a><span id="l2.437" class="difflineplus">+    mStartupDone = true;</span>
<a href="#l2.438"></a><span id="l2.438">   }</span>
<a href="#l2.439"></a><span id="l2.439">   else if (!PL_strcmp(aTopic, kAppIdleNotification))</span>
<a href="#l2.440"></a><span id="l2.440">   {</span>
<a href="#l2.441"></a><span id="l2.441">     if (nsDependentString(aSomeData).EqualsLiteral(&quot;idle&quot;))</span>
<a href="#l2.442"></a><span id="l2.442">     {</span>
<a href="#l2.443"></a><span id="l2.443">       IdleState prevIdleState = GetIdleState();</span>
<a href="#l2.444"></a><span id="l2.444"> </span>
<a href="#l2.445"></a><span id="l2.445">       // we were already idle (either system or app), so</span>
<a href="#l2.446"></a><span id="l2.446" class="difflineat">@@ -648,91 +648,91 @@ NS_IMETHODIMP nsAutoSyncManager::Observe</span>
<a href="#l2.447"></a><span id="l2.447">   }</span>
<a href="#l2.448"></a><span id="l2.448">   return NS_OK;</span>
<a href="#l2.449"></a><span id="l2.449"> }</span>
<a href="#l2.450"></a><span id="l2.450"> </span>
<a href="#l2.451"></a><span id="l2.451"> nsresult nsAutoSyncManager::StartIdleProcessing()</span>
<a href="#l2.452"></a><span id="l2.452"> {</span>
<a href="#l2.453"></a><span id="l2.453">   if (mPaused)</span>
<a href="#l2.454"></a><span id="l2.454">     return NS_OK;</span>
<a href="#l2.455"></a><span id="l2.455" class="difflineminus">-    </span>
<a href="#l2.456"></a><span id="l2.456" class="difflineplus">+</span>
<a href="#l2.457"></a><span id="l2.457">   StartTimerIfNeeded();</span>
<a href="#l2.458"></a><span id="l2.458" class="difflineminus">-  </span>
<a href="#l2.459"></a><span id="l2.459" class="difflineplus">+</span>
<a href="#l2.460"></a><span id="l2.460">   // Ignore idle events sent during the startup</span>
<a href="#l2.461"></a><span id="l2.461">   if (!mStartupDone)</span>
<a href="#l2.462"></a><span id="l2.462">     return NS_OK;</span>
<a href="#l2.463"></a><span id="l2.463" class="difflineminus">-    </span>
<a href="#l2.464"></a><span id="l2.464" class="difflineplus">+</span>
<a href="#l2.465"></a><span id="l2.465">   // notify listeners that auto-sync is running</span>
<a href="#l2.466"></a><span id="l2.466">   NOTIFY_LISTENERS(OnStateChanged, (true));</span>
<a href="#l2.467"></a><span id="l2.467" class="difflineminus">-    </span>
<a href="#l2.468"></a><span id="l2.468" class="difflineplus">+</span>
<a href="#l2.469"></a><span id="l2.469">   nsCOMArray&lt;nsIAutoSyncState&gt; chainedQ;</span>
<a href="#l2.470"></a><span id="l2.470">   nsCOMArray&lt;nsIAutoSyncState&gt; *queue = &amp;mPriorityQ;</span>
<a href="#l2.471"></a><span id="l2.471" class="difflineminus">-  if (mDownloadModel == dmChained) </span>
<a href="#l2.472"></a><span id="l2.472" class="difflineplus">+  if (mDownloadModel == dmChained)</span>
<a href="#l2.473"></a><span id="l2.473">   {</span>
<a href="#l2.474"></a><span id="l2.474">     ChainFoldersInQ(mPriorityQ, chainedQ);</span>
<a href="#l2.475"></a><span id="l2.475">     queue = &amp;chainedQ;</span>
<a href="#l2.476"></a><span id="l2.476">   }</span>
<a href="#l2.477"></a><span id="l2.477" class="difflineminus">-  </span>
<a href="#l2.478"></a><span id="l2.478" class="difflineplus">+</span>
<a href="#l2.479"></a><span id="l2.479">   // to store the folders that should be removed from the priority</span>
<a href="#l2.480"></a><span id="l2.480">   // queue at the end of the iteration.</span>
<a href="#l2.481"></a><span id="l2.481">   nsCOMArray&lt;nsIAutoSyncState&gt; foldersToBeRemoved;</span>
<a href="#l2.482"></a><span id="l2.482" class="difflineminus">-  </span>
<a href="#l2.483"></a><span id="l2.483" class="difflineminus">-  // process folders in the priority queue </span>
<a href="#l2.484"></a><span id="l2.484" class="difflineplus">+</span>
<a href="#l2.485"></a><span id="l2.485" class="difflineplus">+  // process folders in the priority queue</span>
<a href="#l2.486"></a><span id="l2.486">   int32_t elemCount = queue-&gt;Count();</span>
<a href="#l2.487"></a><span id="l2.487">   for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l2.488"></a><span id="l2.488">   {</span>
<a href="#l2.489"></a><span id="l2.489">     nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj((*queue)[idx]);</span>
<a href="#l2.490"></a><span id="l2.490">     if (!autoSyncStateObj)</span>
<a href="#l2.491"></a><span id="l2.491">       continue;</span>
<a href="#l2.492"></a><span id="l2.492" class="difflineminus">-    </span>
<a href="#l2.493"></a><span id="l2.493" class="difflineplus">+</span>
<a href="#l2.494"></a><span id="l2.494">     int32_t state;</span>
<a href="#l2.495"></a><span id="l2.495">     autoSyncStateObj-&gt;GetState(&amp;state);</span>
<a href="#l2.496"></a><span id="l2.496" class="difflineminus">-    </span>
<a href="#l2.497"></a><span id="l2.497" class="difflineplus">+</span>
<a href="#l2.498"></a><span id="l2.498">     //TODO: Test cached-connection availability in parallel mode</span>
<a href="#l2.499"></a><span id="l2.499">     // and do not exceed (cached-connection count - 1)</span>
<a href="#l2.500"></a><span id="l2.500" class="difflineminus">-    </span>
<a href="#l2.501"></a><span id="l2.501" class="difflineplus">+</span>
<a href="#l2.502"></a><span id="l2.502">     if (state != nsAutoSyncState::stReadyToDownload)</span>
<a href="#l2.503"></a><span id="l2.503">       continue;</span>
<a href="#l2.504"></a><span id="l2.504" class="difflineminus">-    </span>
<a href="#l2.505"></a><span id="l2.505" class="difflineplus">+</span>
<a href="#l2.506"></a><span id="l2.506">     nsresult rv = DownloadMessagesForOffline(autoSyncStateObj);</span>
<a href="#l2.507"></a><span id="l2.507">     if (NS_FAILED(rv))</span>
<a href="#l2.508"></a><span id="l2.508">     {</span>
<a href="#l2.509"></a><span id="l2.509">       // special case: this folder does not have any message to download</span>
<a href="#l2.510"></a><span id="l2.510">       // (see bug 457342), remove it explicitly from the queue when iteration</span>
<a href="#l2.511"></a><span id="l2.511">       // is over.</span>
<a href="#l2.512"></a><span id="l2.512">       // Note that in normal execution flow, folders are removed from priority</span>
<a href="#l2.513"></a><span id="l2.513">       // queue only in OnDownloadCompleted when all messages are downloaded</span>
<a href="#l2.514"></a><span id="l2.514">       // successfully. This is the only place we change this flow.</span>
<a href="#l2.515"></a><span id="l2.515">       if (NS_ERROR_NOT_AVAILABLE == rv)</span>
<a href="#l2.516"></a><span id="l2.516">         foldersToBeRemoved.AppendObject(autoSyncStateObj);</span>
<a href="#l2.517"></a><span id="l2.517" class="difflineminus">-      </span>
<a href="#l2.518"></a><span id="l2.518" class="difflineplus">+</span>
<a href="#l2.519"></a><span id="l2.519">       HandleDownloadErrorFor(autoSyncStateObj, rv);</span>
<a href="#l2.520"></a><span id="l2.520">     }// endif</span>
<a href="#l2.521"></a><span id="l2.521">   }//endfor</span>
<a href="#l2.522"></a><span id="l2.522" class="difflineminus">-  </span>
<a href="#l2.523"></a><span id="l2.523" class="difflineplus">+</span>
<a href="#l2.524"></a><span id="l2.524">   // remove folders with no pending messages from the priority queue</span>
<a href="#l2.525"></a><span id="l2.525">   elemCount = foldersToBeRemoved.Count();</span>
<a href="#l2.526"></a><span id="l2.526">   for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l2.527"></a><span id="l2.527">   {</span>
<a href="#l2.528"></a><span id="l2.528">     nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(foldersToBeRemoved[idx]);</span>
<a href="#l2.529"></a><span id="l2.529">     if (!autoSyncStateObj)</span>
<a href="#l2.530"></a><span id="l2.530">       continue;</span>
<a href="#l2.531"></a><span id="l2.531" class="difflineminus">-    </span>
<a href="#l2.532"></a><span id="l2.532" class="difflineplus">+</span>
<a href="#l2.533"></a><span id="l2.533">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l2.534"></a><span id="l2.534">     autoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l2.535"></a><span id="l2.535">     if (folder)</span>
<a href="#l2.536"></a><span id="l2.536">       NOTIFY_LISTENERS(OnDownloadCompleted, (folder));</span>
<a href="#l2.537"></a><span id="l2.537"> </span>
<a href="#l2.538"></a><span id="l2.538">     autoSyncStateObj-&gt;SetState(nsAutoSyncState::stCompletedIdle);</span>
<a href="#l2.539"></a><span id="l2.539"> </span>
<a href="#l2.540"></a><span id="l2.540">     if (mPriorityQ.RemoveObject(autoSyncStateObj))</span>
<a href="#l2.541"></a><span id="l2.541">       NOTIFY_LISTENERS(OnFolderRemovedFromQ,</span>
<a href="#l2.542"></a><span id="l2.542">                       (nsIAutoSyncMgrListener::PriorityQueue, folder));</span>
<a href="#l2.543"></a><span id="l2.543">   }</span>
<a href="#l2.544"></a><span id="l2.544" class="difflineminus">-    </span>
<a href="#l2.545"></a><span id="l2.545" class="difflineplus">+</span>
<a href="#l2.546"></a><span id="l2.546">   return AutoUpdateFolders();</span>
<a href="#l2.547"></a><span id="l2.547"> }</span>
<a href="#l2.548"></a><span id="l2.548"> </span>
<a href="#l2.549"></a><span id="l2.549"> /**</span>
<a href="#l2.550"></a><span id="l2.550">  * Updates offline imap folders that are not synchronized recently. This is</span>
<a href="#l2.551"></a><span id="l2.551">  * called whenever we're idle.</span>
<a href="#l2.552"></a><span id="l2.552">  */</span>
<a href="#l2.553"></a><span id="l2.553"> nsresult nsAutoSyncManager::AutoUpdateFolders()</span>
<a href="#l2.554"></a><span id="l2.554" class="difflineat">@@ -746,17 +746,17 @@ nsresult nsAutoSyncManager::AutoUpdateFo</span>
<a href="#l2.555"></a><span id="l2.555"> </span>
<a href="#l2.556"></a><span id="l2.556">   nsCOMPtr&lt;nsIArray&gt; accounts;</span>
<a href="#l2.557"></a><span id="l2.557">   rv = accountManager-&gt;GetAccounts(getter_AddRefs(accounts));</span>
<a href="#l2.558"></a><span id="l2.558">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l2.559"></a><span id="l2.559"> </span>
<a href="#l2.560"></a><span id="l2.560">   uint32_t accountCount;</span>
<a href="#l2.561"></a><span id="l2.561">   accounts-&gt;GetLength(&amp;accountCount);</span>
<a href="#l2.562"></a><span id="l2.562"> </span>
<a href="#l2.563"></a><span id="l2.563" class="difflineminus">-  for (uint32_t i = 0; i &lt; accountCount; ++i) </span>
<a href="#l2.564"></a><span id="l2.564" class="difflineplus">+  for (uint32_t i = 0; i &lt; accountCount; ++i)</span>
<a href="#l2.565"></a><span id="l2.565">   {</span>
<a href="#l2.566"></a><span id="l2.566">     nsCOMPtr&lt;nsIMsgAccount&gt; account(do_QueryElementAt(accounts, i, &amp;rv));</span>
<a href="#l2.567"></a><span id="l2.567">     if (!account)</span>
<a href="#l2.568"></a><span id="l2.568">       continue;</span>
<a href="#l2.569"></a><span id="l2.569"> </span>
<a href="#l2.570"></a><span id="l2.570">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; incomingServer;</span>
<a href="#l2.571"></a><span id="l2.571">     rv = account-&gt;GetIncomingServer(getter_AddRefs(incomingServer));</span>
<a href="#l2.572"></a><span id="l2.572">     if (!incomingServer)</span>
<a href="#l2.573"></a><span id="l2.573" class="difflineat">@@ -836,17 +836,17 @@ nsresult nsAutoSyncManager::AutoUpdateFo</span>
<a href="#l2.574"></a><span id="l2.574">         if (NS_SUCCEEDED(rv) &amp;&amp; nsAutoSyncState::stCompletedIdle == state)</span>
<a href="#l2.575"></a><span id="l2.575">         {</span>
<a href="#l2.576"></a><span id="l2.576">           // ensure that we wait for at least nsMsgIncomingServer::BiffMinutes between</span>
<a href="#l2.577"></a><span id="l2.577">           // each update of the same folder</span>
<a href="#l2.578"></a><span id="l2.578">           PRTime lastUpdateTime;</span>
<a href="#l2.579"></a><span id="l2.579">           rv = autoSyncState-&gt;GetLastUpdateTime(&amp;lastUpdateTime);</span>
<a href="#l2.580"></a><span id="l2.580">           PRTime span = GetUpdateIntervalFor(autoSyncState) * (PR_USEC_PER_SEC * 60UL);</span>
<a href="#l2.581"></a><span id="l2.581">           if ( NS_SUCCEEDED(rv) &amp;&amp; ((lastUpdateTime + span) &lt; PR_Now()) )</span>
<a href="#l2.582"></a><span id="l2.582" class="difflineminus">-          {          </span>
<a href="#l2.583"></a><span id="l2.583" class="difflineplus">+          {</span>
<a href="#l2.584"></a><span id="l2.584">             if (mUpdateQ.IndexOf(autoSyncState) == -1)</span>
<a href="#l2.585"></a><span id="l2.585">             {</span>
<a href="#l2.586"></a><span id="l2.586">               mUpdateQ.AppendObject(autoSyncState);</span>
<a href="#l2.587"></a><span id="l2.587">               if (folder)</span>
<a href="#l2.588"></a><span id="l2.588">                 NOTIFY_LISTENERS(OnFolderAddedIntoQ, (nsIAutoSyncMgrListener::UpdateQueue, folder));</span>
<a href="#l2.589"></a><span id="l2.589">             }</span>
<a href="#l2.590"></a><span id="l2.590">           }</span>
<a href="#l2.591"></a><span id="l2.591">         }</span>
<a href="#l2.592"></a><span id="l2.592" class="difflineat">@@ -867,17 +867,17 @@ nsresult nsAutoSyncManager::AutoUpdateFo</span>
<a href="#l2.593"></a><span id="l2.593">         }</span>
<a href="#l2.594"></a><span id="l2.594">       }//endfor</span>
<a href="#l2.595"></a><span id="l2.595">     }//endif</span>
<a href="#l2.596"></a><span id="l2.596">   }//endfor</span>
<a href="#l2.597"></a><span id="l2.597"> </span>
<a href="#l2.598"></a><span id="l2.598">   // lazily create the timer if there is something to process in the queue</span>
<a href="#l2.599"></a><span id="l2.599">   // when timer is done, it will self destruct</span>
<a href="#l2.600"></a><span id="l2.600">   StartTimerIfNeeded();</span>
<a href="#l2.601"></a><span id="l2.601" class="difflineminus">-  </span>
<a href="#l2.602"></a><span id="l2.602" class="difflineplus">+</span>
<a href="#l2.603"></a><span id="l2.603">   return rv;</span>
<a href="#l2.604"></a><span id="l2.604"> }</span>
<a href="#l2.605"></a><span id="l2.605"> </span>
<a href="#l2.606"></a><span id="l2.606"> /**</span>
<a href="#l2.607"></a><span id="l2.607">  * Places the given folder into the priority queue based on active</span>
<a href="#l2.608"></a><span id="l2.608">  * strategy function.</span>
<a href="#l2.609"></a><span id="l2.609">  */</span>
<a href="#l2.610"></a><span id="l2.610"> void nsAutoSyncManager::ScheduleFolderForOfflineDownload(nsIAutoSyncState *aAutoSyncStateObj)</span>
<a href="#l2.611"></a><span id="l2.611" class="difflineat">@@ -902,26 +902,26 @@ void nsAutoSyncManager::ScheduleFolderFo</span>
<a href="#l2.612"></a><span id="l2.612">         {</span>
<a href="#l2.613"></a><span id="l2.613">           mPriorityQ.AppendObject(aAutoSyncStateObj); // insert into the first spot</span>
<a href="#l2.614"></a><span id="l2.614">           NOTIFY_LISTENERS(OnFolderAddedIntoQ, (nsIAutoSyncMgrListener::PriorityQueue, folder));</span>
<a href="#l2.615"></a><span id="l2.615">         }</span>
<a href="#l2.616"></a><span id="l2.616">       }</span>
<a href="#l2.617"></a><span id="l2.617">     }</span>
<a href="#l2.618"></a><span id="l2.618">     else</span>
<a href="#l2.619"></a><span id="l2.619">     {</span>
<a href="#l2.620"></a><span id="l2.620" class="difflineminus">-      // find the right spot for the given folder      </span>
<a href="#l2.621"></a><span id="l2.621" class="difflineplus">+      // find the right spot for the given folder</span>
<a href="#l2.622"></a><span id="l2.622">       uint32_t qidx = mPriorityQ.Count();</span>
<a href="#l2.623"></a><span id="l2.623" class="difflineminus">-      while (qidx &gt; 0) </span>
<a href="#l2.624"></a><span id="l2.624" class="difflineplus">+      while (qidx &gt; 0)</span>
<a href="#l2.625"></a><span id="l2.625">       {</span>
<a href="#l2.626"></a><span id="l2.626">         --qidx;</span>
<a href="#l2.627"></a><span id="l2.627"> </span>
<a href="#l2.628"></a><span id="l2.628">         nsCOMPtr&lt;nsIMsgFolder&gt; folderA, folderB;</span>
<a href="#l2.629"></a><span id="l2.629">         mPriorityQ[qidx]-&gt;GetOwnerFolder(getter_AddRefs(folderA));</span>
<a href="#l2.630"></a><span id="l2.630">         aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folderB));</span>
<a href="#l2.631"></a><span id="l2.631" class="difflineminus">-        </span>
<a href="#l2.632"></a><span id="l2.632" class="difflineplus">+</span>
<a href="#l2.633"></a><span id="l2.633">         bool excluded = false;</span>
<a href="#l2.634"></a><span id="l2.634">         if (folderB &amp;&amp; folStrategy)</span>
<a href="#l2.635"></a><span id="l2.635">           folStrategy-&gt;IsExcluded(folderB, &amp;excluded);</span>
<a href="#l2.636"></a><span id="l2.636"> </span>
<a href="#l2.637"></a><span id="l2.637">         if (excluded)</span>
<a href="#l2.638"></a><span id="l2.638">           break;</span>
<a href="#l2.639"></a><span id="l2.639"> </span>
<a href="#l2.640"></a><span id="l2.640">         nsAutoSyncStrategyDecisionType decision = nsAutoSyncStrategyDecisions::Same;</span>
<a href="#l2.641"></a><span id="l2.641" class="difflineat">@@ -940,17 +940,17 @@ void nsAutoSyncManager::ScheduleFolderFo</span>
<a href="#l2.642"></a><span id="l2.642">         NOTIFY_LISTENERS(OnFolderAddedIntoQ, (nsIAutoSyncMgrListener::PriorityQueue, folderB));</span>
<a href="#l2.643"></a><span id="l2.643">         break;</span>
<a href="#l2.644"></a><span id="l2.644">       }//endwhile</span>
<a href="#l2.645"></a><span id="l2.645">     }</span>
<a href="#l2.646"></a><span id="l2.646">   }//endif</span>
<a href="#l2.647"></a><span id="l2.647"> }</span>
<a href="#l2.648"></a><span id="l2.648"> </span>
<a href="#l2.649"></a><span id="l2.649"> /**</span>
<a href="#l2.650"></a><span id="l2.650" class="difflineminus">- * Zero aSizeLimit means no limit </span>
<a href="#l2.651"></a><span id="l2.651" class="difflineplus">+ * Zero aSizeLimit means no limit</span>
<a href="#l2.652"></a><span id="l2.652">  */</span>
<a href="#l2.653"></a><span id="l2.653"> nsresult nsAutoSyncManager::DownloadMessagesForOffline(nsIAutoSyncState *aAutoSyncStateObj, uint32_t aSizeLimit)</span>
<a href="#l2.654"></a><span id="l2.654"> {</span>
<a href="#l2.655"></a><span id="l2.655">   if (!aAutoSyncStateObj)</span>
<a href="#l2.656"></a><span id="l2.656">     return NS_ERROR_INVALID_ARG;</span>
<a href="#l2.657"></a><span id="l2.657"> </span>
<a href="#l2.658"></a><span id="l2.658">   int32_t count;</span>
<a href="#l2.659"></a><span id="l2.659">   nsresult rv = aAutoSyncStateObj-&gt;GetPendingMessageCount(&amp;count);</span>
<a href="#l2.660"></a><span id="l2.660" class="difflineat">@@ -995,54 +995,54 @@ nsresult nsAutoSyncManager::DownloadMess</span>
<a href="#l2.661"></a><span id="l2.661">     if (NS_SUCCEEDED(rv) &amp;&amp; folder)</span>
<a href="#l2.662"></a><span id="l2.662">       NOTIFY_LISTENERS(OnDownloadStarted, (folder, length, totalCount));</span>
<a href="#l2.663"></a><span id="l2.663">   }</span>
<a href="#l2.664"></a><span id="l2.664"> </span>
<a href="#l2.665"></a><span id="l2.665">   return rv;</span>
<a href="#l2.666"></a><span id="l2.666"> }</span>
<a href="#l2.667"></a><span id="l2.667"> </span>
<a href="#l2.668"></a><span id="l2.668"> /**</span>
<a href="#l2.669"></a><span id="l2.669" class="difflineminus">- * Assuming that the download operation on the given folder has been failed at least once, </span>
<a href="#l2.670"></a><span id="l2.670" class="difflineplus">+ * Assuming that the download operation on the given folder has been failed at least once,</span>
<a href="#l2.671"></a><span id="l2.671">  * execute these steps:</span>
<a href="#l2.672"></a><span id="l2.672">  *  - put the auto-sync state into ready-to-download mode</span>
<a href="#l2.673"></a><span id="l2.673">  *  - rollback the message offset so we can try the same group again (unless the retry</span>
<a href="#l2.674"></a><span id="l2.674">  *     count is reached to the given limit)</span>
<a href="#l2.675"></a><span id="l2.675">  *  - if parallel model is active, wait to be resumed by the next idle</span>
<a href="#l2.676"></a><span id="l2.676" class="difflineminus">- *  - if chained model is active, search the priority queue to find a sibling to continue </span>
<a href="#l2.677"></a><span id="l2.677" class="difflineplus">+ *  - if chained model is active, search the priority queue to find a sibling to continue</span>
<a href="#l2.678"></a><span id="l2.678">  *    with.</span>
<a href="#l2.679"></a><span id="l2.679">  */</span>
<a href="#l2.680"></a><span id="l2.680"> nsresult nsAutoSyncManager::HandleDownloadErrorFor(nsIAutoSyncState *aAutoSyncStateObj,</span>
<a href="#l2.681"></a><span id="l2.681">                                                    const nsresult error)</span>
<a href="#l2.682"></a><span id="l2.682"> {</span>
<a href="#l2.683"></a><span id="l2.683">   if (!aAutoSyncStateObj)</span>
<a href="#l2.684"></a><span id="l2.684">     return NS_ERROR_INVALID_ARG;</span>
<a href="#l2.685"></a><span id="l2.685" class="difflineminus">-  </span>
<a href="#l2.686"></a><span id="l2.686" class="difflineplus">+</span>
<a href="#l2.687"></a><span id="l2.687">   // ensure that an error occured</span>
<a href="#l2.688"></a><span id="l2.688">   if (NS_SUCCEEDED(error))</span>
<a href="#l2.689"></a><span id="l2.689">     return NS_OK;</span>
<a href="#l2.690"></a><span id="l2.690" class="difflineminus">-    </span>
<a href="#l2.691"></a><span id="l2.691" class="difflineplus">+</span>
<a href="#l2.692"></a><span id="l2.692">   // NS_ERROR_NOT_AVAILABLE is a special case/error happens when the queued folder</span>
<a href="#l2.693"></a><span id="l2.693">   // doesn't have any message to download (see bug 457342). In such case we shouldn't</span>
<a href="#l2.694"></a><span id="l2.694">   // retry the current message group, nor notify listeners. Simply continuing with the</span>
<a href="#l2.695"></a><span id="l2.695">   // next sibling in the priority queue would suffice.</span>
<a href="#l2.696"></a><span id="l2.696" class="difflineminus">-    </span>
<a href="#l2.697"></a><span id="l2.697" class="difflineplus">+</span>
<a href="#l2.698"></a><span id="l2.698">   if (NS_ERROR_NOT_AVAILABLE != error)</span>
<a href="#l2.699"></a><span id="l2.699">   {</span>
<a href="#l2.700"></a><span id="l2.700">     // force the auto-sync state to try downloading the same group at least</span>
<a href="#l2.701"></a><span id="l2.701">     // kGroupRetryCount times before it moves to the next one</span>
<a href="#l2.702"></a><span id="l2.702">     aAutoSyncStateObj-&gt;TryCurrentGroupAgain(kGroupRetryCount);</span>
<a href="#l2.703"></a><span id="l2.703" class="difflineminus">-    </span>
<a href="#l2.704"></a><span id="l2.704" class="difflineplus">+</span>
<a href="#l2.705"></a><span id="l2.705">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l2.706"></a><span id="l2.706">     aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l2.707"></a><span id="l2.707">     if (folder)</span>
<a href="#l2.708"></a><span id="l2.708">       NOTIFY_LISTENERS(OnDownloadError, (folder));</span>
<a href="#l2.709"></a><span id="l2.709">   }</span>
<a href="#l2.710"></a><span id="l2.710" class="difflineminus">-  </span>
<a href="#l2.711"></a><span id="l2.711" class="difflineplus">+</span>
<a href="#l2.712"></a><span id="l2.712">   // if parallel model, don't do anything else</span>
<a href="#l2.713"></a><span id="l2.713" class="difflineminus">-  </span>
<a href="#l2.714"></a><span id="l2.714" class="difflineplus">+</span>
<a href="#l2.715"></a><span id="l2.715">   if (mDownloadModel == dmChained)</span>
<a href="#l2.716"></a><span id="l2.716">   {</span>
<a href="#l2.717"></a><span id="l2.717">     // switch to the next folder in the chain and continue downloading</span>
<a href="#l2.718"></a><span id="l2.718">     nsIAutoSyncState *autoSyncStateObj = aAutoSyncStateObj;</span>
<a href="#l2.719"></a><span id="l2.719">     nsIAutoSyncState *nextAutoSyncStateObj = nullptr;</span>
<a href="#l2.720"></a><span id="l2.720">     while ( (nextAutoSyncStateObj = GetNextSibling(mPriorityQ, autoSyncStateObj)) )</span>
<a href="#l2.721"></a><span id="l2.721">     {</span>
<a href="#l2.722"></a><span id="l2.722">       autoSyncStateObj = nextAutoSyncStateObj;</span>
<a href="#l2.723"></a><span id="l2.723" class="difflineat">@@ -1051,37 +1051,37 @@ nsresult nsAutoSyncManager::HandleDownlo</span>
<a href="#l2.724"></a><span id="l2.724">         break;</span>
<a href="#l2.725"></a><span id="l2.725">       if (rv == NS_ERROR_NOT_AVAILABLE)</span>
<a href="#l2.726"></a><span id="l2.726">         // next folder in the chain also doesn't have any message to download</span>
<a href="#l2.727"></a><span id="l2.727">         // switch to next one if any</span>
<a href="#l2.728"></a><span id="l2.728">         continue;</span>
<a href="#l2.729"></a><span id="l2.729">       autoSyncStateObj-&gt;TryCurrentGroupAgain(kGroupRetryCount);</span>
<a href="#l2.730"></a><span id="l2.730">     }</span>
<a href="#l2.731"></a><span id="l2.731">   }</span>
<a href="#l2.732"></a><span id="l2.732" class="difflineminus">-  </span>
<a href="#l2.733"></a><span id="l2.733" class="difflineplus">+</span>
<a href="#l2.734"></a><span id="l2.734">   return NS_OK;</span>
<a href="#l2.735"></a><span id="l2.735"> }</span>
<a href="#l2.736"></a><span id="l2.736"> </span>
<a href="#l2.737"></a><span id="l2.737"> uint32_t nsAutoSyncManager::GetUpdateIntervalFor(nsIAutoSyncState *aAutoSyncStateObj)</span>
<a href="#l2.738"></a><span id="l2.738"> {</span>
<a href="#l2.739"></a><span id="l2.739">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l2.740"></a><span id="l2.740">   nsresult rv = aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l2.741"></a><span id="l2.741">   if (NS_FAILED(rv))</span>
<a href="#l2.742"></a><span id="l2.742">     return kDefaultUpdateInterval;</span>
<a href="#l2.743"></a><span id="l2.743" class="difflineminus">-  </span>
<a href="#l2.744"></a><span id="l2.744" class="difflineplus">+</span>
<a href="#l2.745"></a><span id="l2.745">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l2.746"></a><span id="l2.746">   rv = folder-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l2.747"></a><span id="l2.747">   if (NS_FAILED(rv))</span>
<a href="#l2.748"></a><span id="l2.748">     return kDefaultUpdateInterval;</span>
<a href="#l2.749"></a><span id="l2.749"> </span>
<a href="#l2.750"></a><span id="l2.750">   if (server)</span>
<a href="#l2.751"></a><span id="l2.751">   {</span>
<a href="#l2.752"></a><span id="l2.752">     int32_t interval;</span>
<a href="#l2.753"></a><span id="l2.753">     rv = server-&gt;GetBiffMinutes(&amp;interval);</span>
<a href="#l2.754"></a><span id="l2.754" class="difflineminus">-    </span>
<a href="#l2.755"></a><span id="l2.755" class="difflineplus">+</span>
<a href="#l2.756"></a><span id="l2.756">     if (NS_SUCCEEDED(rv))</span>
<a href="#l2.757"></a><span id="l2.757">       return (uint32_t)interval;</span>
<a href="#l2.758"></a><span id="l2.758">   }</span>
<a href="#l2.759"></a><span id="l2.759"> </span>
<a href="#l2.760"></a><span id="l2.760">   return kDefaultUpdateInterval;</span>
<a href="#l2.761"></a><span id="l2.761"> }</span>
<a href="#l2.762"></a><span id="l2.762"> </span>
<a href="#l2.763"></a><span id="l2.763"> NS_IMETHODIMP nsAutoSyncManager::GetGroupSize(uint32_t *aGroupSize)</span>
<a href="#l2.764"></a><span id="l2.764" class="difflineat">@@ -1094,64 +1094,64 @@ NS_IMETHODIMP nsAutoSyncManager::SetGrou</span>
<a href="#l2.765"></a><span id="l2.765"> {</span>
<a href="#l2.766"></a><span id="l2.766">   mGroupSize = aGroupSize ? aGroupSize : kDefaultGroupSize;</span>
<a href="#l2.767"></a><span id="l2.767">   return NS_OK;</span>
<a href="#l2.768"></a><span id="l2.768"> }</span>
<a href="#l2.769"></a><span id="l2.769"> </span>
<a href="#l2.770"></a><span id="l2.770"> NS_IMETHODIMP nsAutoSyncManager::GetMsgStrategy(nsIAutoSyncMsgStrategy * *aMsgStrategy)</span>
<a href="#l2.771"></a><span id="l2.771"> {</span>
<a href="#l2.772"></a><span id="l2.772">   NS_ENSURE_ARG_POINTER(aMsgStrategy);</span>
<a href="#l2.773"></a><span id="l2.773" class="difflineminus">-  </span>
<a href="#l2.774"></a><span id="l2.774" class="difflineplus">+</span>
<a href="#l2.775"></a><span id="l2.775">   // lazily create if it is not done already</span>
<a href="#l2.776"></a><span id="l2.776">   if (!mMsgStrategyImpl)</span>
<a href="#l2.777"></a><span id="l2.777">   {</span>
<a href="#l2.778"></a><span id="l2.778">     mMsgStrategyImpl = new nsDefaultAutoSyncMsgStrategy;</span>
<a href="#l2.779"></a><span id="l2.779">     if (!mMsgStrategyImpl)</span>
<a href="#l2.780"></a><span id="l2.780">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l2.781"></a><span id="l2.781">   }</span>
<a href="#l2.782"></a><span id="l2.782" class="difflineminus">-  </span>
<a href="#l2.783"></a><span id="l2.783" class="difflineplus">+</span>
<a href="#l2.784"></a><span id="l2.784">   NS_IF_ADDREF(*aMsgStrategy = mMsgStrategyImpl);</span>
<a href="#l2.785"></a><span id="l2.785">   return NS_OK;</span>
<a href="#l2.786"></a><span id="l2.786"> }</span>
<a href="#l2.787"></a><span id="l2.787"> NS_IMETHODIMP nsAutoSyncManager::SetMsgStrategy(nsIAutoSyncMsgStrategy * aMsgStrategy)</span>
<a href="#l2.788"></a><span id="l2.788"> {</span>
<a href="#l2.789"></a><span id="l2.789">   mMsgStrategyImpl = aMsgStrategy;</span>
<a href="#l2.790"></a><span id="l2.790">   return NS_OK;</span>
<a href="#l2.791"></a><span id="l2.791"> }</span>
<a href="#l2.792"></a><span id="l2.792"> </span>
<a href="#l2.793"></a><span id="l2.793"> NS_IMETHODIMP nsAutoSyncManager::GetFolderStrategy(nsIAutoSyncFolderStrategy * *aFolderStrategy)</span>
<a href="#l2.794"></a><span id="l2.794"> {</span>
<a href="#l2.795"></a><span id="l2.795">   NS_ENSURE_ARG_POINTER(aFolderStrategy);</span>
<a href="#l2.796"></a><span id="l2.796" class="difflineminus">-  </span>
<a href="#l2.797"></a><span id="l2.797" class="difflineplus">+</span>
<a href="#l2.798"></a><span id="l2.798">   // lazily create if it is not done already</span>
<a href="#l2.799"></a><span id="l2.799">   if (!mFolderStrategyImpl)</span>
<a href="#l2.800"></a><span id="l2.800">   {</span>
<a href="#l2.801"></a><span id="l2.801">     mFolderStrategyImpl = new nsDefaultAutoSyncFolderStrategy;</span>
<a href="#l2.802"></a><span id="l2.802">     if (!mFolderStrategyImpl)</span>
<a href="#l2.803"></a><span id="l2.803">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l2.804"></a><span id="l2.804">   }</span>
<a href="#l2.805"></a><span id="l2.805" class="difflineminus">-    </span>
<a href="#l2.806"></a><span id="l2.806" class="difflineplus">+</span>
<a href="#l2.807"></a><span id="l2.807">   NS_IF_ADDREF(*aFolderStrategy = mFolderStrategyImpl);</span>
<a href="#l2.808"></a><span id="l2.808">   return NS_OK;</span>
<a href="#l2.809"></a><span id="l2.809"> }</span>
<a href="#l2.810"></a><span id="l2.810"> NS_IMETHODIMP nsAutoSyncManager::SetFolderStrategy(nsIAutoSyncFolderStrategy * aFolderStrategy)</span>
<a href="#l2.811"></a><span id="l2.811"> {</span>
<a href="#l2.812"></a><span id="l2.812">   mFolderStrategyImpl = aFolderStrategy;</span>
<a href="#l2.813"></a><span id="l2.813">   return NS_OK;</span>
<a href="#l2.814"></a><span id="l2.814"> }</span>
<a href="#l2.815"></a><span id="l2.815"> </span>
<a href="#l2.816"></a><span id="l2.816" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l2.817"></a><span id="l2.817" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.818"></a><span id="l2.818"> nsAutoSyncManager::DoesMsgFitDownloadCriteria(nsIMsgDBHdr *aMsgHdr, bool *aResult)</span>
<a href="#l2.819"></a><span id="l2.819"> {</span>
<a href="#l2.820"></a><span id="l2.820">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l2.821"></a><span id="l2.821"> </span>
<a href="#l2.822"></a><span id="l2.822">   uint32_t msgFlags = 0;</span>
<a href="#l2.823"></a><span id="l2.823">   aMsgHdr-&gt;GetFlags(&amp;msgFlags);</span>
<a href="#l2.824"></a><span id="l2.824"> </span>
<a href="#l2.825"></a><span id="l2.825" class="difflineminus">-  // check whether this message is marked imap deleted or not </span>
<a href="#l2.826"></a><span id="l2.826" class="difflineplus">+  // check whether this message is marked imap deleted or not</span>
<a href="#l2.827"></a><span id="l2.827">   *aResult = !(msgFlags &amp; nsMsgMessageFlags::IMAPDeleted);</span>
<a href="#l2.828"></a><span id="l2.828">   if (!(*aResult))</span>
<a href="#l2.829"></a><span id="l2.829">     return NS_OK;</span>
<a href="#l2.830"></a><span id="l2.830"> </span>
<a href="#l2.831"></a><span id="l2.831">   bool shouldStoreMsgOffline = true;</span>
<a href="#l2.832"></a><span id="l2.832">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l2.833"></a><span id="l2.833">   aMsgHdr-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l2.834"></a><span id="l2.834">   if (folder)</span>
<a href="#l2.835"></a><span id="l2.835" class="difflineat">@@ -1197,121 +1197,121 @@ NS_IMETHODIMP nsAutoSyncManager::OnDownl</span>
<a href="#l2.836"></a><span id="l2.836">     ScheduleFolderForOfflineDownload(autoSyncStateObj);</span>
<a href="#l2.837"></a><span id="l2.837"> </span>
<a href="#l2.838"></a><span id="l2.838">     // If we operate in parallel mode or if there is no sibling downloading messages at the moment,</span>
<a href="#l2.839"></a><span id="l2.839">     // we can download the first group of the messages for this folder</span>
<a href="#l2.840"></a><span id="l2.840">     if (mDownloadModel == dmParallel ||</span>
<a href="#l2.841"></a><span id="l2.841">         !DoesQContainAnySiblingOf(mPriorityQ, autoSyncStateObj, nsAutoSyncState::stDownloadInProgress))</span>
<a href="#l2.842"></a><span id="l2.842">     {</span>
<a href="#l2.843"></a><span id="l2.843">       // this will download the first group of messages immediately;</span>
<a href="#l2.844"></a><span id="l2.844" class="difflineminus">-      // to ensure that we don't end up downloading a large single message in not-idle time, </span>
<a href="#l2.845"></a><span id="l2.845" class="difflineminus">-      // we enforce a limit. If there is no message fits into this limit we postpone the </span>
<a href="#l2.846"></a><span id="l2.846" class="difflineplus">+      // to ensure that we don't end up downloading a large single message in not-idle time,</span>
<a href="#l2.847"></a><span id="l2.847" class="difflineplus">+      // we enforce a limit. If there is no message fits into this limit we postpone the</span>
<a href="#l2.848"></a><span id="l2.848">       // download until the next idle.</span>
<a href="#l2.849"></a><span id="l2.849">       if (GetIdleState() == notIdle)</span>
<a href="#l2.850"></a><span id="l2.850">         rv =  DownloadMessagesForOffline(autoSyncStateObj, kFirstGroupSizeLimit);</span>
<a href="#l2.851"></a><span id="l2.851">       else</span>
<a href="#l2.852"></a><span id="l2.852">         rv = DownloadMessagesForOffline(autoSyncStateObj);</span>
<a href="#l2.853"></a><span id="l2.853" class="difflineminus">-      </span>
<a href="#l2.854"></a><span id="l2.854" class="difflineplus">+</span>
<a href="#l2.855"></a><span id="l2.855">       if (NS_FAILED(rv))</span>
<a href="#l2.856"></a><span id="l2.856">         autoSyncStateObj-&gt;TryCurrentGroupAgain(kGroupRetryCount);</span>
<a href="#l2.857"></a><span id="l2.857">     }</span>
<a href="#l2.858"></a><span id="l2.858">   }</span>
<a href="#l2.859"></a><span id="l2.859">   return rv;</span>
<a href="#l2.860"></a><span id="l2.860"> }</span>
<a href="#l2.861"></a><span id="l2.861"> </span>
<a href="#l2.862"></a><span id="l2.862" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l2.863"></a><span id="l2.863" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.864"></a><span id="l2.864"> nsAutoSyncManager::OnDownloadStarted(nsIAutoSyncState *aAutoSyncStateObj, nsresult aStartCode)</span>
<a href="#l2.865"></a><span id="l2.865"> {</span>
<a href="#l2.866"></a><span id="l2.866">   nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(aAutoSyncStateObj);</span>
<a href="#l2.867"></a><span id="l2.867">   if (!autoSyncStateObj)</span>
<a href="#l2.868"></a><span id="l2.868">     return NS_ERROR_INVALID_ARG;</span>
<a href="#l2.869"></a><span id="l2.869"> </span>
<a href="#l2.870"></a><span id="l2.870">   // resume downloads during next idle time</span>
<a href="#l2.871"></a><span id="l2.871">   if (NS_FAILED(aStartCode))</span>
<a href="#l2.872"></a><span id="l2.872" class="difflineminus">-    autoSyncStateObj-&gt;SetState(nsAutoSyncState::stReadyToDownload);  </span>
<a href="#l2.873"></a><span id="l2.873" class="difflineminus">-  </span>
<a href="#l2.874"></a><span id="l2.874" class="difflineplus">+    autoSyncStateObj-&gt;SetState(nsAutoSyncState::stReadyToDownload);</span>
<a href="#l2.875"></a><span id="l2.875" class="difflineplus">+</span>
<a href="#l2.876"></a><span id="l2.876">   return aStartCode;</span>
<a href="#l2.877"></a><span id="l2.877"> }</span>
<a href="#l2.878"></a><span id="l2.878"> </span>
<a href="#l2.879"></a><span id="l2.879" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l2.880"></a><span id="l2.880" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l2.881"></a><span id="l2.881"> nsAutoSyncManager::OnDownloadCompleted(nsIAutoSyncState *aAutoSyncStateObj, nsresult aExitCode)</span>
<a href="#l2.882"></a><span id="l2.882"> {</span>
<a href="#l2.883"></a><span id="l2.883">   nsCOMPtr&lt;nsIAutoSyncState&gt; autoSyncStateObj(aAutoSyncStateObj);</span>
<a href="#l2.884"></a><span id="l2.884">   if (!autoSyncStateObj)</span>
<a href="#l2.885"></a><span id="l2.885" class="difflineminus">-    return NS_ERROR_INVALID_ARG;    </span>
<a href="#l2.886"></a><span id="l2.886" class="difflineplus">+    return NS_ERROR_INVALID_ARG;</span>
<a href="#l2.887"></a><span id="l2.887"> </span>
<a href="#l2.888"></a><span id="l2.888">   nsresult rv = aExitCode;</span>
<a href="#l2.889"></a><span id="l2.889"> </span>
<a href="#l2.890"></a><span id="l2.890">   if (NS_FAILED(aExitCode))</span>
<a href="#l2.891"></a><span id="l2.891">   {</span>
<a href="#l2.892"></a><span id="l2.892">     // retry the same group kGroupRetryCount times</span>
<a href="#l2.893"></a><span id="l2.893">     // try again if TB still idle, otherwise wait for the next idle time</span>
<a href="#l2.894"></a><span id="l2.894">     autoSyncStateObj-&gt;TryCurrentGroupAgain(kGroupRetryCount);</span>
<a href="#l2.895"></a><span id="l2.895">     if (GetIdleState() != notIdle)</span>
<a href="#l2.896"></a><span id="l2.896">     {</span>
<a href="#l2.897"></a><span id="l2.897">       rv = DownloadMessagesForOffline(autoSyncStateObj);</span>
<a href="#l2.898"></a><span id="l2.898">       if (NS_FAILED(rv))</span>
<a href="#l2.899"></a><span id="l2.899">         rv = HandleDownloadErrorFor(autoSyncStateObj, rv);</span>
<a href="#l2.900"></a><span id="l2.900">     }</span>
<a href="#l2.901"></a><span id="l2.901">     return rv;</span>
<a href="#l2.902"></a><span id="l2.902">   }</span>
<a href="#l2.903"></a><span id="l2.903" class="difflineminus">-      </span>
<a href="#l2.904"></a><span id="l2.904" class="difflineplus">+</span>
<a href="#l2.905"></a><span id="l2.905">   // download is successful, reset the retry counter of the folder</span>
<a href="#l2.906"></a><span id="l2.906">   autoSyncStateObj-&gt;ResetRetryCounter();</span>
<a href="#l2.907"></a><span id="l2.907" class="difflineminus">-  </span>
<a href="#l2.908"></a><span id="l2.908" class="difflineplus">+</span>
<a href="#l2.909"></a><span id="l2.909">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l2.910"></a><span id="l2.910">   aAutoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l2.911"></a><span id="l2.911">   if (folder)</span>
<a href="#l2.912"></a><span id="l2.912">     NOTIFY_LISTENERS(OnDownloadCompleted, (folder));</span>
<a href="#l2.913"></a><span id="l2.913" class="difflineminus">-      </span>
<a href="#l2.914"></a><span id="l2.914" class="difflineplus">+</span>
<a href="#l2.915"></a><span id="l2.915">   int32_t count;</span>
<a href="#l2.916"></a><span id="l2.916">   rv = autoSyncStateObj-&gt;GetPendingMessageCount(&amp;count);</span>
<a href="#l2.917"></a><span id="l2.917">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l2.918"></a><span id="l2.918" class="difflineminus">-  </span>
<a href="#l2.919"></a><span id="l2.919" class="difflineplus">+</span>
<a href="#l2.920"></a><span id="l2.920">   nsIAutoSyncState *nextFolderToDownload = nullptr;</span>
<a href="#l2.921"></a><span id="l2.921">   if (count &gt; 0)</span>
<a href="#l2.922"></a><span id="l2.922">   {</span>
<a href="#l2.923"></a><span id="l2.923">     autoSyncStateObj-&gt;SetState(nsAutoSyncState::stReadyToDownload);</span>
<a href="#l2.924"></a><span id="l2.924" class="difflineminus">-    </span>
<a href="#l2.925"></a><span id="l2.925" class="difflineplus">+</span>
<a href="#l2.926"></a><span id="l2.926">     // in parallel model, we continue downloading the same folder as long as it has</span>
<a href="#l2.927"></a><span id="l2.927">     // more pending messages</span>
<a href="#l2.928"></a><span id="l2.928">     nextFolderToDownload = autoSyncStateObj;</span>
<a href="#l2.929"></a><span id="l2.929" class="difflineminus">-    </span>
<a href="#l2.930"></a><span id="l2.930" class="difflineminus">-    // in chained model, ensure that we are always downloading the highest priority </span>
<a href="#l2.931"></a><span id="l2.931" class="difflineminus">-    // folder first </span>
<a href="#l2.932"></a><span id="l2.932" class="difflineplus">+</span>
<a href="#l2.933"></a><span id="l2.933" class="difflineplus">+    // in chained model, ensure that we are always downloading the highest priority</span>
<a href="#l2.934"></a><span id="l2.934" class="difflineplus">+    // folder first</span>
<a href="#l2.935"></a><span id="l2.935">     if (mDownloadModel == dmChained)</span>
<a href="#l2.936"></a><span id="l2.936">     {</span>
<a href="#l2.937"></a><span id="l2.937" class="difflineminus">-      // switch to higher priority folder and continue to download, </span>
<a href="#l2.938"></a><span id="l2.938" class="difflineplus">+      // switch to higher priority folder and continue to download,</span>
<a href="#l2.939"></a><span id="l2.939">       // if any added recently</span>
<a href="#l2.940"></a><span id="l2.940">       int32_t myIndex = mPriorityQ.IndexOf(autoSyncStateObj);</span>
<a href="#l2.941"></a><span id="l2.941" class="difflineminus">-      </span>
<a href="#l2.942"></a><span id="l2.942" class="difflineplus">+</span>
<a href="#l2.943"></a><span id="l2.943">       int32_t siblingIndex;</span>
<a href="#l2.944"></a><span id="l2.944">       nsIAutoSyncState *sibling = GetHighestPrioSibling(mPriorityQ, autoSyncStateObj, &amp;siblingIndex);</span>
<a href="#l2.945"></a><span id="l2.945" class="difflineminus">-      </span>
<a href="#l2.946"></a><span id="l2.946" class="difflineplus">+</span>
<a href="#l2.947"></a><span id="l2.947">       // lesser index = higher priority</span>
<a href="#l2.948"></a><span id="l2.948" class="difflineminus">-      if (sibling &amp;&amp; myIndex &gt; -1 &amp;&amp; siblingIndex &lt; myIndex) </span>
<a href="#l2.949"></a><span id="l2.949" class="difflineplus">+      if (sibling &amp;&amp; myIndex &gt; -1 &amp;&amp; siblingIndex &lt; myIndex)</span>
<a href="#l2.950"></a><span id="l2.950">         nextFolderToDownload = sibling;</span>
<a href="#l2.951"></a><span id="l2.951">     }</span>
<a href="#l2.952"></a><span id="l2.952">   }</span>
<a href="#l2.953"></a><span id="l2.953" class="difflineminus">-  else </span>
<a href="#l2.954"></a><span id="l2.954" class="difflineplus">+  else</span>
<a href="#l2.955"></a><span id="l2.955">   {</span>
<a href="#l2.956"></a><span id="l2.956">     autoSyncStateObj-&gt;SetState(nsAutoSyncState::stCompletedIdle);</span>
<a href="#l2.957"></a><span id="l2.957" class="difflineminus">-    </span>
<a href="#l2.958"></a><span id="l2.958" class="difflineplus">+</span>
<a href="#l2.959"></a><span id="l2.959">     nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l2.960"></a><span id="l2.960">     nsresult rv = autoSyncStateObj-&gt;GetOwnerFolder(getter_AddRefs(folder));</span>
<a href="#l2.961"></a><span id="l2.961" class="difflineminus">-    </span>
<a href="#l2.962"></a><span id="l2.962" class="difflineplus">+</span>
<a href="#l2.963"></a><span id="l2.963">     if (NS_SUCCEEDED(rv) &amp;&amp; mPriorityQ.RemoveObject(autoSyncStateObj))</span>
<a href="#l2.964"></a><span id="l2.964">       NOTIFY_LISTENERS(OnFolderRemovedFromQ, (nsIAutoSyncMgrListener::PriorityQueue, folder));</span>
<a href="#l2.965"></a><span id="l2.965"> </span>
<a href="#l2.966"></a><span id="l2.966">     //find the next folder owned by the same server in the queue and continue downloading</span>
<a href="#l2.967"></a><span id="l2.967">     if (mDownloadModel == dmChained)</span>
<a href="#l2.968"></a><span id="l2.968">       nextFolderToDownload = GetHighestPrioSibling(mPriorityQ, autoSyncStateObj);</span>
<a href="#l2.969"></a><span id="l2.969" class="difflineminus">-      </span>
<a href="#l2.970"></a><span id="l2.970" class="difflineplus">+</span>
<a href="#l2.971"></a><span id="l2.971">   }//endif</span>
<a href="#l2.972"></a><span id="l2.972" class="difflineminus">-  </span>
<a href="#l2.973"></a><span id="l2.973" class="difflineplus">+</span>
<a href="#l2.974"></a><span id="l2.974">   // continue downloading if TB is still in idle state</span>
<a href="#l2.975"></a><span id="l2.975">   if (nextFolderToDownload &amp;&amp; GetIdleState() != notIdle)</span>
<a href="#l2.976"></a><span id="l2.976">   {</span>
<a href="#l2.977"></a><span id="l2.977">     rv = DownloadMessagesForOffline(nextFolderToDownload);</span>
<a href="#l2.978"></a><span id="l2.978">     if (NS_FAILED(rv))</span>
<a href="#l2.979"></a><span id="l2.979">       rv = HandleDownloadErrorFor(nextFolderToDownload, rv);</span>
<a href="#l2.980"></a><span id="l2.980">   }</span>
<a href="#l2.981"></a><span id="l2.981"> </span>
<a href="#l2.982"></a><span id="l2.982" class="difflineat">@@ -1396,19 +1396,19 @@ nsAutoSyncManager::OnFolderHasPendingMsg</span>
<a href="#l2.983"></a><span id="l2.983">         NOTIFY_LISTENERS(OnFolderAddedIntoQ,</span>
<a href="#l2.984"></a><span id="l2.984">                         (nsIAutoSyncMgrListener::UpdateQueue, folder));</span>
<a href="#l2.985"></a><span id="l2.985">       }</span>
<a href="#l2.986"></a><span id="l2.986">     }</span>
<a href="#l2.987"></a><span id="l2.987">   }</span>
<a href="#l2.988"></a><span id="l2.988">   return NS_OK;</span>
<a href="#l2.989"></a><span id="l2.989"> }</span>
<a href="#l2.990"></a><span id="l2.990"> </span>
<a href="#l2.991"></a><span id="l2.991" class="difflineminus">-void nsAutoSyncManager::SetIdleState(IdleState st) </span>
<a href="#l2.992"></a><span id="l2.992" class="difflineminus">-{ </span>
<a href="#l2.993"></a><span id="l2.993" class="difflineplus">+void nsAutoSyncManager::SetIdleState(IdleState st)</span>
<a href="#l2.994"></a><span id="l2.994" class="difflineplus">+{</span>
<a href="#l2.995"></a><span id="l2.995">   mIdleState = st;</span>
<a href="#l2.996"></a><span id="l2.996"> }</span>
<a href="#l2.997"></a><span id="l2.997"> </span>
<a href="#l2.998"></a><span id="l2.998" class="difflineminus">-nsAutoSyncManager::IdleState nsAutoSyncManager::GetIdleState() const </span>
<a href="#l2.999"></a><span id="l2.999" class="difflineminus">-{ </span>
<a href="#l2.1000"></a><span id="l2.1000" class="difflineminus">-  return mIdleState; </span>
<a href="#l2.1001"></a><span id="l2.1001" class="difflineplus">+nsAutoSyncManager::IdleState nsAutoSyncManager::GetIdleState() const</span>
<a href="#l2.1002"></a><span id="l2.1002" class="difflineplus">+{</span>
<a href="#l2.1003"></a><span id="l2.1003" class="difflineplus">+  return mIdleState;</span>
<a href="#l2.1004"></a><span id="l2.1004"> }</span>
<a href="#l2.1005"></a><span id="l2.1005"> </span>
<a href="#l2.1006"></a><span id="l2.1006"> NS_IMPL_ISUPPORTS(nsAutoSyncManager, nsIObserver, nsIUrlListener, nsIAutoSyncManager)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncManager.h</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncManager.h</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -31,19 +31,19 @@ class nsIMsgFolder;</span>
<a href="#l3.4"></a><span id="l3.4">  *  process for already queued folders.</span>
<a href="#l3.5"></a><span id="l3.5">  *</span>
<a href="#l3.6"></a><span id="l3.6">  * Auto-Sync policy:</span>
<a href="#l3.7"></a><span id="l3.7">  *  o It kicks in during system idle time, and tries to download as much messages</span>
<a href="#l3.8"></a><span id="l3.8">  *    as possible based on given folder and message prioritization strategies/rules.</span>
<a href="#l3.9"></a><span id="l3.9">  *    Default folder prioritization strategy dictates to sort the folders based on the</span>
<a href="#l3.10"></a><span id="l3.10">  *    following order:  INBOX &gt; DRAFTS &gt; SUBFOLDERS &gt; TRASH.</span>
<a href="#l3.11"></a><span id="l3.11">  *    Similarly, default message prioritization strategy dictates to download the most</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">- *    recent and smallest message first. Also, by sorting the messages by size in the </span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+ *    recent and smallest message first. Also, by sorting the messages by size in the</span>
<a href="#l3.14"></a><span id="l3.14">  *    queue, it tries to maximize the number of messages downloaded.</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">- *  o It downloads the messages in groups. Default groups size is defined by |kDefaultGroupSize|. </span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+ *  o It downloads the messages in groups. Default groups size is defined by |kDefaultGroupSize|.</span>
<a href="#l3.17"></a><span id="l3.17">  *  o It downloads the messages larger than the group size one-by-one.</span>
<a href="#l3.18"></a><span id="l3.18">  *  o If new messages arrive when not idle, it downloads the messages that do fit into</span>
<a href="#l3.19"></a><span id="l3.19">  *    |kFirstGroupSizeLimit| size limit immediately, without waiting for idle time, unless there is</span>
<a href="#l3.20"></a><span id="l3.20">  *    a sibling (a folder owned by the same imap server) in stDownloadInProgress state in the q</span>
<a href="#l3.21"></a><span id="l3.21">  *  o If new messages arrive when idle, it downloads all the messages without any restriction.</span>
<a href="#l3.22"></a><span id="l3.22">  *  o If new messages arrive into a folder while auto-sync is downloading other messages of the</span>
<a href="#l3.23"></a><span id="l3.23">  *    same folder, it simply puts the new messages into the folder's download queue, and</span>
<a href="#l3.24"></a><span id="l3.24">  *    re-prioritize the messages. That behavior makes sure that the high priority</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineat">@@ -53,17 +53,17 @@ class nsIMsgFolder;</span>
<a href="#l3.26"></a><span id="l3.26">  *    messages of the higher priority folder next time it downloads a message group.</span>
<a href="#l3.27"></a><span id="l3.27">  *  o Currently there is no way to stop/pause/cancel a message download. The smallest</span>
<a href="#l3.28"></a><span id="l3.28">  *    granularity is the message group size.</span>
<a href="#l3.29"></a><span id="l3.29">  *  o Auto-Sync manager periodically (kAutoSyncFreq) checks folder for existing messages</span>
<a href="#l3.30"></a><span id="l3.30">  *    w/o bodies. It persists the last time the folder is checked in the local database of the</span>
<a href="#l3.31"></a><span id="l3.31">  *    folder. We call this process 'Discovery'. This process is asynchronous and processes</span>
<a href="#l3.32"></a><span id="l3.32">  *    |kNumberOfHeadersToProcess| number of headers at each cycle. Since it works on local data,</span>
<a href="#l3.33"></a><span id="l3.33">  *    it doesn't consume lots of system resources, it does its job fast.</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineminus">- *  o Discovery is necessary especially when the user makes a transition from not-offline </span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+ *  o Discovery is necessary especially when the user makes a transition from not-offline</span>
<a href="#l3.36"></a><span id="l3.36">  *    to offline mode.</span>
<a href="#l3.37"></a><span id="l3.37">  *  o Update frequency is defined by nsMsgIncomingServer::BiffMinutes.</span>
<a href="#l3.38"></a><span id="l3.38">  *</span>
<a href="#l3.39"></a><span id="l3.39">  * Error Handling:</span>
<a href="#l3.40"></a><span id="l3.40">  *  o if the user moves/deletes/filters all messages of a folder already queued, auto-sync</span>
<a href="#l3.41"></a><span id="l3.41">  *    deals with that situation by skipping the folder in question, and continuing with the</span>
<a href="#l3.42"></a><span id="l3.42">  *    next in chain.</span>
<a href="#l3.43"></a><span id="l3.43">  *  o If the message size is zero, auto-sync ignores the message.</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineat">@@ -74,108 +74,108 @@ class nsIMsgFolder;</span>
<a href="#l3.45"></a><span id="l3.45">  * Download Model:</span>
<a href="#l3.46"></a><span id="l3.46">  *  Parallel model should be used with the imap servers that do not have any &quot;max number of sessions</span>
<a href="#l3.47"></a><span id="l3.47">  *  per IP&quot; limit, and when the bandwidth is significantly large.</span>
<a href="#l3.48"></a><span id="l3.48">  *</span>
<a href="#l3.49"></a><span id="l3.49">  * How it really works:</span>
<a href="#l3.50"></a><span id="l3.50">  * The AutoSyncManager gets an idle notification. First it processes any</span>
<a href="#l3.51"></a><span id="l3.51">  * folders in the discovery queue (which means it schedules message download</span>
<a href="#l3.52"></a><span id="l3.52">  * for any messages it previously determined it should download). Then it sets</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineminus">- * a timer, and in the timer callback, it processes the update q, by calling </span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+ * a timer, and in the timer callback, it processes the update q, by calling</span>
<a href="#l3.55"></a><span id="l3.55">  * InitiateAutoSync on the first folder in the update q.</span>
<a href="#l3.56"></a><span id="l3.56">  */</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineminus">- </span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+</span>
<a href="#l3.59"></a><span id="l3.59"> /**</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineminus">- * Default strategy implementation to prioritize messages in the download queue.   </span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+ * Default strategy implementation to prioritize messages in the download queue.</span>
<a href="#l3.62"></a><span id="l3.62">  */</span>
<a href="#l3.63"></a><span id="l3.63"> class nsDefaultAutoSyncMsgStrategy final : public nsIAutoSyncMsgStrategy</span>
<a href="#l3.64"></a><span id="l3.64"> {</span>
<a href="#l3.65"></a><span id="l3.65">   static const uint32_t kFirstPassMessageSize = 60U*1024U; // 60K</span>
<a href="#l3.66"></a><span id="l3.66"> </span>
<a href="#l3.67"></a><span id="l3.67">   public:</span>
<a href="#l3.68"></a><span id="l3.68">     NS_DECL_ISUPPORTS</span>
<a href="#l3.69"></a><span id="l3.69">     NS_DECL_NSIAUTOSYNCMSGSTRATEGY</span>
<a href="#l3.70"></a><span id="l3.70"> </span>
<a href="#l3.71"></a><span id="l3.71">     nsDefaultAutoSyncMsgStrategy();</span>
<a href="#l3.72"></a><span id="l3.72"> </span>
<a href="#l3.73"></a><span id="l3.73">   private:</span>
<a href="#l3.74"></a><span id="l3.74">     ~nsDefaultAutoSyncMsgStrategy();</span>
<a href="#l3.75"></a><span id="l3.75"> };</span>
<a href="#l3.76"></a><span id="l3.76"> </span>
<a href="#l3.77"></a><span id="l3.77"> /**</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineminus">- * Default strategy implementation to prioritize folders in the download queue.  </span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+ * Default strategy implementation to prioritize folders in the download queue.</span>
<a href="#l3.80"></a><span id="l3.80">  */</span>
<a href="#l3.81"></a><span id="l3.81"> class nsDefaultAutoSyncFolderStrategy final : public nsIAutoSyncFolderStrategy</span>
<a href="#l3.82"></a><span id="l3.82"> {</span>
<a href="#l3.83"></a><span id="l3.83">   public:</span>
<a href="#l3.84"></a><span id="l3.84">     NS_DECL_ISUPPORTS</span>
<a href="#l3.85"></a><span id="l3.85">     NS_DECL_NSIAUTOSYNCFOLDERSTRATEGY</span>
<a href="#l3.86"></a><span id="l3.86"> </span>
<a href="#l3.87"></a><span id="l3.87">     nsDefaultAutoSyncFolderStrategy();</span>
<a href="#l3.88"></a><span id="l3.88"> </span>
<a href="#l3.89"></a><span id="l3.89">   private:</span>
<a href="#l3.90"></a><span id="l3.90">     ~nsDefaultAutoSyncFolderStrategy();</span>
<a href="#l3.91"></a><span id="l3.91"> };</span>
<a href="#l3.92"></a><span id="l3.92"> </span>
<a href="#l3.93"></a><span id="l3.93"> // see the end of the page for auto-sync internals</span>
<a href="#l3.94"></a><span id="l3.94"> </span>
<a href="#l3.95"></a><span id="l3.95"> /**</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineminus">- * Manages background message download operations for offline imap folders. </span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+ * Manages background message download operations for offline imap folders.</span>
<a href="#l3.98"></a><span id="l3.98">  */</span>
<a href="#l3.99"></a><span id="l3.99"> class nsAutoSyncManager final : public nsIObserver,</span>
<a href="#l3.100"></a><span id="l3.100">                                 public nsIUrlListener,</span>
<a href="#l3.101"></a><span id="l3.101">                                 public nsIAutoSyncManager</span>
<a href="#l3.102"></a><span id="l3.102"> {</span>
<a href="#l3.103"></a><span id="l3.103">   static const PRTime kAutoSyncFreq = 60UL * (PR_USEC_PER_SEC * 60UL);  // 1hr</span>
<a href="#l3.104"></a><span id="l3.104">   static const uint32_t kDefaultUpdateInterval = 10UL;                  // 10min</span>
<a href="#l3.105"></a><span id="l3.105">   static const int32_t kTimerIntervalInMs = 400;</span>
<a href="#l3.106"></a><span id="l3.106">   static const uint32_t kNumberOfHeadersToProcess = 250U;</span>
<a href="#l3.107"></a><span id="l3.107">   // enforced size of the first group that will be downloaded before idle time</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineminus">-  static const uint32_t kFirstGroupSizeLimit = 60U*1024U /* 60K */; </span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+  static const uint32_t kFirstGroupSizeLimit = 60U*1024U /* 60K */;</span>
<a href="#l3.110"></a><span id="l3.110">   static const int32_t kIdleTimeInSec = 10;</span>
<a href="#l3.111"></a><span id="l3.111">   static const uint32_t kGroupRetryCount = 3;</span>
<a href="#l3.112"></a><span id="l3.112"> </span>
<a href="#l3.113"></a><span id="l3.113">   enum IdleState { systemIdle, appIdle, notIdle };</span>
<a href="#l3.114"></a><span id="l3.114">   enum UpdateState { initiated, completed };</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineminus">-      </span>
<a href="#l3.116"></a><span id="l3.116" class="difflineplus">+</span>
<a href="#l3.117"></a><span id="l3.117">   public:</span>
<a href="#l3.118"></a><span id="l3.118">     NS_DECL_ISUPPORTS</span>
<a href="#l3.119"></a><span id="l3.119">     NS_DECL_NSIOBSERVER</span>
<a href="#l3.120"></a><span id="l3.120">     NS_DECL_NSIURLLISTENER</span>
<a href="#l3.121"></a><span id="l3.121">     NS_DECL_NSIAUTOSYNCMANAGER</span>
<a href="#l3.122"></a><span id="l3.122"> </span>
<a href="#l3.123"></a><span id="l3.123">     nsAutoSyncManager();</span>
<a href="#l3.124"></a><span id="l3.124"> </span>
<a href="#l3.125"></a><span id="l3.125">   private:</span>
<a href="#l3.126"></a><span id="l3.126">     ~nsAutoSyncManager();</span>
<a href="#l3.127"></a><span id="l3.127"> </span>
<a href="#l3.128"></a><span id="l3.128">     void SetIdleState(IdleState st);</span>
<a href="#l3.129"></a><span id="l3.129">     IdleState GetIdleState() const;</span>
<a href="#l3.130"></a><span id="l3.130">     nsresult StartIdleProcessing();</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineminus">-    nsresult AutoUpdateFolders(); </span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+    nsresult AutoUpdateFolders();</span>
<a href="#l3.133"></a><span id="l3.133">     void ScheduleFolderForOfflineDownload(nsIAutoSyncState *aAutoSyncStateObj);</span>
<a href="#l3.134"></a><span id="l3.134">     nsresult DownloadMessagesForOffline(nsIAutoSyncState *aAutoSyncStateObj, uint32_t aSizeLimit = 0);</span>
<a href="#l3.135"></a><span id="l3.135">     nsresult HandleDownloadErrorFor(nsIAutoSyncState *aAutoSyncStateObj, const nsresult error);</span>
<a href="#l3.136"></a><span id="l3.136"> </span>
<a href="#l3.137"></a><span id="l3.137">     // Helper methods for priority Q operations</span>
<a href="#l3.138"></a><span id="l3.138">     static</span>
<a href="#l3.139"></a><span id="l3.139">     void ChainFoldersInQ(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.140"></a><span id="l3.140">                           nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aChainedQ);</span>
<a href="#l3.141"></a><span id="l3.141">     static</span>
<a href="#l3.142"></a><span id="l3.142">     nsIAutoSyncState* SearchQForSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.143"></a><span id="l3.143">                           nsIAutoSyncState *aAutoSyncStateObj, int32_t aStartIdx, int32_t *aIndex = nullptr);</span>
<a href="#l3.144"></a><span id="l3.144">     static</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineminus">-    bool DoesQContainAnySiblingOf(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue, </span>
<a href="#l3.146"></a><span id="l3.146" class="difflineminus">-                          nsIAutoSyncState *aAutoSyncStateObj, const int32_t aState, </span>
<a href="#l3.147"></a><span id="l3.147" class="difflineplus">+    bool DoesQContainAnySiblingOf(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.148"></a><span id="l3.148" class="difflineplus">+                          nsIAutoSyncState *aAutoSyncStateObj, const int32_t aState,</span>
<a href="#l3.149"></a><span id="l3.149">                           int32_t *aIndex = nullptr);</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineminus">-    static </span>
<a href="#l3.151"></a><span id="l3.151" class="difflineminus">-    nsIAutoSyncState* GetNextSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue, </span>
<a href="#l3.152"></a><span id="l3.152" class="difflineplus">+    static</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineplus">+    nsIAutoSyncState* GetNextSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.154"></a><span id="l3.154">                           nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex = nullptr);</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineminus">-    static </span>
<a href="#l3.156"></a><span id="l3.156" class="difflineminus">-    nsIAutoSyncState* GetHighestPrioSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue, </span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+    static</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+    nsIAutoSyncState* GetHighestPrioSibling(const nsCOMArray&lt;nsIAutoSyncState&gt; &amp;aQueue,</span>
<a href="#l3.159"></a><span id="l3.159">                           nsIAutoSyncState *aAutoSyncStateObj, int32_t *aIndex = nullptr);</span>
<a href="#l3.160"></a><span id="l3.160"> </span>
<a href="#l3.161"></a><span id="l3.161">     /// timer to process existing keys and updates</span>
<a href="#l3.162"></a><span id="l3.162">     void InitTimer();</span>
<a href="#l3.163"></a><span id="l3.163">     static void TimerCallback(nsITimer *aTimer, void *aClosure);</span>
<a href="#l3.164"></a><span id="l3.164">     void StopTimer();</span>
<a href="#l3.165"></a><span id="l3.165">     void StartTimerIfNeeded();</span>
<a href="#l3.166"></a><span id="l3.166"> </span>
<a href="#l3.167"></a><span id="l3.167" class="difflineat">@@ -215,51 +215,51 @@ class nsAutoSyncManager final : public n</span>
<a href="#l3.168"></a><span id="l3.168"> #endif</span>
<a href="#l3.169"></a><span id="l3.169"> </span>
<a href="#l3.170"></a><span id="l3.170"> /*</span>
<a href="#l3.171"></a><span id="l3.171"> How queues inter-relate:</span>
<a href="#l3.172"></a><span id="l3.172"> </span>
<a href="#l3.173"></a><span id="l3.173"> nsAutoSyncState has an internal priority queue to store messages waiting to be</span>
<a href="#l3.174"></a><span id="l3.174"> downloaded. nsAutoSyncMsgStrategy object determines the order in this queue,</span>
<a href="#l3.175"></a><span id="l3.175"> nsAutoSyncManager uses this queue to manage downloads. Two events cause a</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineminus">-change in this queue: </span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+change in this queue:</span>
<a href="#l3.178"></a><span id="l3.178"> </span>
<a href="#l3.179"></a><span id="l3.179"> 1) nsImapMailFolder::HeaderFetchCompleted: is triggered when TB notices that</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineminus">-there are pending messages on the server -- via IDLE command from the server, </span>
<a href="#l3.181"></a><span id="l3.181" class="difflineminus">-via explicit select from the user, or via automatic Update during idle time. If </span>
<a href="#l3.182"></a><span id="l3.182" class="difflineminus">-it turns out that there are pending messages on the server, it adds them into </span>
<a href="#l3.183"></a><span id="l3.183" class="difflineplus">+there are pending messages on the server -- via IDLE command from the server,</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineplus">+via explicit select from the user, or via automatic Update during idle time. If</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineplus">+it turns out that there are pending messages on the server, it adds them into</span>
<a href="#l3.186"></a><span id="l3.186"> nsAutoSyncState's download queue.</span>
<a href="#l3.187"></a><span id="l3.187"> </span>
<a href="#l3.188"></a><span id="l3.188" class="difflineminus">-2) nsAutoSyncState::ProcessExistingHeaders: is triggered for every imap folder </span>
<a href="#l3.189"></a><span id="l3.189" class="difflineminus">-every hour or so (see kAutoSyncFreq). nsAutoSyncManager uses an internal queue called Discovery </span>
<a href="#l3.190"></a><span id="l3.190" class="difflineminus">-queue to keep track of this task. The purpose of ProcessExistingHeaders() </span>
<a href="#l3.191"></a><span id="l3.191" class="difflineminus">-method is to check existing headers of a given folder in batches and discover </span>
<a href="#l3.192"></a><span id="l3.192" class="difflineminus">-the messages without bodies, in asynchronous fashion. This process is </span>
<a href="#l3.193"></a><span id="l3.193" class="difflineminus">-sequential, one and only one folder at any given time, very similar to </span>
<a href="#l3.194"></a><span id="l3.194" class="difflineminus">-indexing. Again, if it turns out that the folder in hand has messages w/o </span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+2) nsAutoSyncState::ProcessExistingHeaders: is triggered for every imap folder</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+every hour or so (see kAutoSyncFreq). nsAutoSyncManager uses an internal queue called Discovery</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+queue to keep track of this task. The purpose of ProcessExistingHeaders()</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+method is to check existing headers of a given folder in batches and discover</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+the messages without bodies, in asynchronous fashion. This process is</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+sequential, one and only one folder at any given time, very similar to</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+indexing. Again, if it turns out that the folder in hand has messages w/o</span>
<a href="#l3.202"></a><span id="l3.202"> bodies, ProcessExistingHeaders adds them into nsAutoSyncState's download queue.</span>
<a href="#l3.203"></a><span id="l3.203"> </span>
<a href="#l3.204"></a><span id="l3.204" class="difflineminus">-Any change in nsAutoSyncState's download queue, notifies nsAutoSyncManager and </span>
<a href="#l3.205"></a><span id="l3.205" class="difflineminus">-nsAutoSyncManager puts the requesting  nsAutoSyncState into its internal </span>
<a href="#l3.206"></a><span id="l3.206" class="difflineminus">-priority queue (called mPriorityQ) -- if the folder is not already there. </span>
<a href="#l3.207"></a><span id="l3.207" class="difflineminus">-nsAutoSyncFolderStrategy object determines the order in this queue. This queue </span>
<a href="#l3.208"></a><span id="l3.208" class="difflineminus">-is processed in two modes: chained and parallel. </span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+Any change in nsAutoSyncState's download queue, notifies nsAutoSyncManager and</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+nsAutoSyncManager puts the requesting  nsAutoSyncState into its internal</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+priority queue (called mPriorityQ) -- if the folder is not already there.</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+nsAutoSyncFolderStrategy object determines the order in this queue. This queue</span>
<a href="#l3.213"></a><span id="l3.213" class="difflineplus">+is processed in two modes: chained and parallel.</span>
<a href="#l3.214"></a><span id="l3.214"> </span>
<a href="#l3.215"></a><span id="l3.215" class="difflineminus">-i) Chained: One folder per imap server any given time. Folders owned by </span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+i) Chained: One folder per imap server any given time. Folders owned by</span>
<a href="#l3.217"></a><span id="l3.217"> different imap servers are simultaneous.</span>
<a href="#l3.218"></a><span id="l3.218"> </span>
<a href="#l3.219"></a><span id="l3.219" class="difflineminus">-ii) Parallel: All folders at the same time, using all cached-connections - </span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+ii) Parallel: All folders at the same time, using all cached-connections -</span>
<a href="#l3.221"></a><span id="l3.221"> a.k.a 'Folders gone wild' mode.</span>
<a href="#l3.222"></a><span id="l3.222"> </span>
<a href="#l3.223"></a><span id="l3.223"> The order the folders are added into the mPriorityQ doesn't matter since every</span>
<a href="#l3.224"></a><span id="l3.224"> time a batch completed for an imap server, nsAutoSyncManager adjusts the order.</span>
<a href="#l3.225"></a><span id="l3.225"> So, lets say that updating a sub-folder starts downloading message immediately,</span>
<a href="#l3.226"></a><span id="l3.226"> when an higher priority folder is added into the queue, nsAutoSyncManager</span>
<a href="#l3.227"></a><span id="l3.227"> switches to this higher priority folder instead of processing the next group of</span>
<a href="#l3.228"></a><span id="l3.228"> messages of the lower priority one. Setting group size too high might delay</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineminus">-this switch at worst. </span>
<a href="#l3.230"></a><span id="l3.230" class="difflineplus">+this switch at worst.</span>
<a href="#l3.231"></a><span id="l3.231"> </span>
<a href="#l3.232"></a><span id="l3.232" class="difflineminus">-And finally, Update queue helps nsAutoSyncManager to keep track of folders </span>
<a href="#l3.233"></a><span id="l3.233" class="difflineplus">+And finally, Update queue helps nsAutoSyncManager to keep track of folders</span>
<a href="#l3.234"></a><span id="l3.234"> waiting to be updated. With the latest change, we update one and only one</span>
<a href="#l3.235"></a><span id="l3.235" class="difflineminus">-folder at any given time. Default frequency of updating is 10 min (kDefaultUpdateInterval). </span>
<a href="#l3.236"></a><span id="l3.236" class="difflineplus">+folder at any given time. Default frequency of updating is 10 min (kDefaultUpdateInterval).</span>
<a href="#l3.237"></a><span id="l3.237"> We add folders into the update queue during idle time, if they are not in mPriorityQ already.</span>
<a href="#l3.238"></a><span id="l3.238"> </span>
<a href="#l3.239"></a><span id="l3.239"> */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncState.cpp</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncState.cpp</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -17,18 +17,18 @@</span>
<a href="#l4.4"></a><span id="l4.4"> #include &quot;nsIMutableArray.h&quot;</span>
<a href="#l4.5"></a><span id="l4.5"> #include &quot;nsArrayUtils.h&quot;</span>
<a href="#l4.6"></a><span id="l4.6"> #include &quot;mozilla/Logging.h&quot;</span>
<a href="#l4.7"></a><span id="l4.7"> </span>
<a href="#l4.8"></a><span id="l4.8"> using namespace mozilla;</span>
<a href="#l4.9"></a><span id="l4.9"> </span>
<a href="#l4.10"></a><span id="l4.10"> extern LazyLogModule gAutoSyncLog; // defined in nsAutoSyncManager.cpp</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-MsgStrategyComparatorAdaptor::MsgStrategyComparatorAdaptor(nsIAutoSyncMsgStrategy* aStrategy, </span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">-  nsIMsgFolder *aFolder, nsIMsgDatabase *aDatabase) : mStrategy(aStrategy), mFolder(aFolder), </span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+MsgStrategyComparatorAdaptor::MsgStrategyComparatorAdaptor(nsIAutoSyncMsgStrategy* aStrategy,</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+  nsIMsgFolder *aFolder, nsIMsgDatabase *aDatabase) : mStrategy(aStrategy), mFolder(aFolder),</span>
<a href="#l4.16"></a><span id="l4.16">     mDatabase(aDatabase)</span>
<a href="#l4.17"></a><span id="l4.17"> {</span>
<a href="#l4.18"></a><span id="l4.18"> }</span>
<a href="#l4.19"></a><span id="l4.19"> </span>
<a href="#l4.20"></a><span id="l4.20"> /** @return True if the elements are equals; false otherwise. */</span>
<a href="#l4.21"></a><span id="l4.21"> bool MsgStrategyComparatorAdaptor::Equals(const nsMsgKey&amp; a, const nsMsgKey&amp; b) const</span>
<a href="#l4.22"></a><span id="l4.22"> {</span>
<a href="#l4.23"></a><span id="l4.23">   nsCOMPtr&lt;nsIMsgDBHdr&gt; hdrA;</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineat">@@ -100,70 +100,70 @@ nsresult nsAutoSyncState::ManageStorageS</span>
<a href="#l4.25"></a><span id="l4.25"> </span>
<a href="#l4.26"></a><span id="l4.26"> nsresult nsAutoSyncState::PlaceIntoDownloadQ(const nsTArray&lt;nsMsgKey&gt; &amp;aMsgKeyList)</span>
<a href="#l4.27"></a><span id="l4.27"> {</span>
<a href="#l4.28"></a><span id="l4.28">   nsresult rv = NS_OK;</span>
<a href="#l4.29"></a><span id="l4.29">   if (!aMsgKeyList.IsEmpty())</span>
<a href="#l4.30"></a><span id="l4.30">   {</span>
<a href="#l4.31"></a><span id="l4.31">     nsCOMPtr &lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l4.32"></a><span id="l4.32">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineminus">-        </span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+</span>
<a href="#l4.35"></a><span id="l4.35">     nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l4.36"></a><span id="l4.36">     rv = folder-&gt;GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l4.37"></a><span id="l4.37">     if (!database)</span>
<a href="#l4.38"></a><span id="l4.38">       return NS_ERROR_FAILURE;</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineminus">-    </span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+</span>
<a href="#l4.41"></a><span id="l4.41">     nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l4.42"></a><span id="l4.42">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineminus">-    </span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+</span>
<a href="#l4.45"></a><span id="l4.45">     nsCOMPtr&lt;nsIAutoSyncMsgStrategy&gt; msgStrategy;</span>
<a href="#l4.46"></a><span id="l4.46">     autoSyncMgr-&gt;GetMsgStrategy(getter_AddRefs(msgStrategy));</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineminus">-    </span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+</span>
<a href="#l4.49"></a><span id="l4.49">     // increase the array size</span>
<a href="#l4.50"></a><span id="l4.50">     mDownloadQ.SetCapacity(mDownloadQ.Length() + aMsgKeyList.Length());</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineminus">-    </span>
<a href="#l4.52"></a><span id="l4.52" class="difflineplus">+</span>
<a href="#l4.53"></a><span id="l4.53">     // remove excluded messages</span>
<a href="#l4.54"></a><span id="l4.54">     int32_t elemCount = aMsgKeyList.Length();</span>
<a href="#l4.55"></a><span id="l4.55">     for (int32_t idx = 0; idx &lt; elemCount; idx++)</span>
<a href="#l4.56"></a><span id="l4.56">     {</span>
<a href="#l4.57"></a><span id="l4.57">       nsCOMPtr&lt;nsIMsgDBHdr&gt; hdr;</span>
<a href="#l4.58"></a><span id="l4.58">       bool containsKey;</span>
<a href="#l4.59"></a><span id="l4.59">       database-&gt;ContainsKey(aMsgKeyList[idx], &amp;containsKey);</span>
<a href="#l4.60"></a><span id="l4.60">       if (!containsKey)</span>
<a href="#l4.61"></a><span id="l4.61">         continue;</span>
<a href="#l4.62"></a><span id="l4.62">       rv = database-&gt;GetMsgHdrForKey(aMsgKeyList[idx], getter_AddRefs(hdr));</span>
<a href="#l4.63"></a><span id="l4.63">       if(!hdr)</span>
<a href="#l4.64"></a><span id="l4.64">         continue; // can't get message header, continue with the next one</span>
<a href="#l4.65"></a><span id="l4.65" class="difflineminus">-      </span>
<a href="#l4.66"></a><span id="l4.66" class="difflineplus">+</span>
<a href="#l4.67"></a><span id="l4.67">       bool doesFit = true;</span>
<a href="#l4.68"></a><span id="l4.68">       rv = autoSyncMgr-&gt;DoesMsgFitDownloadCriteria(hdr, &amp;doesFit);</span>
<a href="#l4.69"></a><span id="l4.69">       if (NS_SUCCEEDED(rv) &amp;&amp; !mDownloadSet.Contains(aMsgKeyList[idx]) &amp;&amp; doesFit)</span>
<a href="#l4.70"></a><span id="l4.70">       {</span>
<a href="#l4.71"></a><span id="l4.71">         bool excluded = false;</span>
<a href="#l4.72"></a><span id="l4.72">         if (msgStrategy)</span>
<a href="#l4.73"></a><span id="l4.73">         {</span>
<a href="#l4.74"></a><span id="l4.74">           rv = msgStrategy-&gt;IsExcluded(folder, hdr, &amp;excluded);</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineminus">-          </span>
<a href="#l4.76"></a><span id="l4.76" class="difflineplus">+</span>
<a href="#l4.77"></a><span id="l4.77">           if (NS_SUCCEEDED(rv) &amp;&amp; !excluded)</span>
<a href="#l4.78"></a><span id="l4.78">           {</span>
<a href="#l4.79"></a><span id="l4.79">             mIsDownloadQChanged = true;</span>
<a href="#l4.80"></a><span id="l4.80">             mDownloadSet.PutEntry(aMsgKeyList[idx]);</span>
<a href="#l4.81"></a><span id="l4.81">             mDownloadQ.AppendElement(aMsgKeyList[idx]);</span>
<a href="#l4.82"></a><span id="l4.82">           }</span>
<a href="#l4.83"></a><span id="l4.83">         }</span>
<a href="#l4.84"></a><span id="l4.84">       }</span>
<a href="#l4.85"></a><span id="l4.85">     }//endfor</span>
<a href="#l4.86"></a><span id="l4.86"> </span>
<a href="#l4.87"></a><span id="l4.87">     if (mIsDownloadQChanged)</span>
<a href="#l4.88"></a><span id="l4.88">     {</span>
<a href="#l4.89"></a><span id="l4.89">       LogOwnerFolderName(&quot;Download Q is created for &quot;);</span>
<a href="#l4.90"></a><span id="l4.90">       LogQWithSize(mDownloadQ, 0);</span>
<a href="#l4.91"></a><span id="l4.91">       rv = autoSyncMgr-&gt;OnDownloadQChanged(this);</span>
<a href="#l4.92"></a><span id="l4.92">     }</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineminus">-    </span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+</span>
<a href="#l4.95"></a><span id="l4.95">   }</span>
<a href="#l4.96"></a><span id="l4.96">   return rv;</span>
<a href="#l4.97"></a><span id="l4.97"> }</span>
<a href="#l4.98"></a><span id="l4.98"> </span>
<a href="#l4.99"></a><span id="l4.99"> nsresult nsAutoSyncState::SortQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue)</span>
<a href="#l4.100"></a><span id="l4.100"> {</span>
<a href="#l4.101"></a><span id="l4.101">   nsresult rv;</span>
<a href="#l4.102"></a><span id="l4.102">   nsCOMPtr &lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineat">@@ -183,17 +183,17 @@ nsresult nsAutoSyncState::SortQueueBased</span>
<a href="#l4.104"></a><span id="l4.104"> </span>
<a href="#l4.105"></a><span id="l4.105">   MsgStrategyComparatorAdaptor strategyComp(msgStrategy, folder, database);</span>
<a href="#l4.106"></a><span id="l4.106">   aQueue.Sort(strategyComp);</span>
<a href="#l4.107"></a><span id="l4.107"> </span>
<a href="#l4.108"></a><span id="l4.108">   return rv;</span>
<a href="#l4.109"></a><span id="l4.109"> }</span>
<a href="#l4.110"></a><span id="l4.110"> </span>
<a href="#l4.111"></a><span id="l4.111"> // This method is a hack to prioritize newly inserted messages,</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineminus">-// without changing the size of the queue. It is required since </span>
<a href="#l4.113"></a><span id="l4.113" class="difflineplus">+// without changing the size of the queue. It is required since</span>
<a href="#l4.114"></a><span id="l4.114"> // we cannot sort ranges in nsTArray.</span>
<a href="#l4.115"></a><span id="l4.115"> nsresult nsAutoSyncState::SortSubQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue,</span>
<a href="#l4.116"></a><span id="l4.116">                                                       uint32_t aStartingOffset)</span>
<a href="#l4.117"></a><span id="l4.117"> {</span>
<a href="#l4.118"></a><span id="l4.118">   NS_ASSERTION(aStartingOffset &lt; aQueue.Length(), &quot;*** Starting offset is out of range&quot;);</span>
<a href="#l4.119"></a><span id="l4.119"> </span>
<a href="#l4.120"></a><span id="l4.120">   // Copy already downloaded messages into a temporary queue,</span>
<a href="#l4.121"></a><span id="l4.121">   // we want to exclude them from the sort.</span>
<a href="#l4.122"></a><span id="l4.122" class="difflineat">@@ -206,18 +206,18 @@ nsresult nsAutoSyncState::SortSubQueueBa</span>
<a href="#l4.123"></a><span id="l4.123">   nsresult rv = SortQueueBasedOnStrategy(aQueue);</span>
<a href="#l4.124"></a><span id="l4.124"> </span>
<a href="#l4.125"></a><span id="l4.125">   // copy excluded messages back</span>
<a href="#l4.126"></a><span id="l4.126">   aQueue.InsertElementsAt(0, tmpQ);</span>
<a href="#l4.127"></a><span id="l4.127"> </span>
<a href="#l4.128"></a><span id="l4.128">   return rv;</span>
<a href="#l4.129"></a><span id="l4.129"> }</span>
<a href="#l4.130"></a><span id="l4.130"> </span>
<a href="#l4.131"></a><span id="l4.131" class="difflineminus">-NS_IMETHODIMP nsAutoSyncState::GetNextGroupOfMessages(uint32_t aSuggestedGroupSizeLimit, </span>
<a href="#l4.132"></a><span id="l4.132" class="difflineminus">-                                                      uint32_t *aActualGroupSize, </span>
<a href="#l4.133"></a><span id="l4.133" class="difflineplus">+NS_IMETHODIMP nsAutoSyncState::GetNextGroupOfMessages(uint32_t aSuggestedGroupSizeLimit,</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineplus">+                                                      uint32_t *aActualGroupSize,</span>
<a href="#l4.135"></a><span id="l4.135">                                                       nsIMutableArray **aMessagesList)</span>
<a href="#l4.136"></a><span id="l4.136"> {</span>
<a href="#l4.137"></a><span id="l4.137">   NS_ENSURE_ARG_POINTER(aMessagesList);</span>
<a href="#l4.138"></a><span id="l4.138">   NS_ENSURE_ARG_POINTER(aActualGroupSize);</span>
<a href="#l4.139"></a><span id="l4.139"> </span>
<a href="#l4.140"></a><span id="l4.140">   *aActualGroupSize = 0;</span>
<a href="#l4.141"></a><span id="l4.141"> </span>
<a href="#l4.142"></a><span id="l4.142">   nsresult rv;</span>
<a href="#l4.143"></a><span id="l4.143" class="difflineat">@@ -285,22 +285,22 @@ NS_IMETHODIMP nsAutoSyncState::GetNextGr</span>
<a href="#l4.144"></a><span id="l4.144">         {</span>
<a href="#l4.145"></a><span id="l4.145">           bool excluded = false;</span>
<a href="#l4.146"></a><span id="l4.146">           if (NS_SUCCEEDED(msgStrategy-&gt;IsExcluded(folder, qhdr, &amp;excluded)) &amp;&amp; excluded)</span>
<a href="#l4.147"></a><span id="l4.147">             continue;</span>
<a href="#l4.148"></a><span id="l4.148">         }</span>
<a href="#l4.149"></a><span id="l4.149"> </span>
<a href="#l4.150"></a><span id="l4.150">         uint32_t msgSize;</span>
<a href="#l4.151"></a><span id="l4.151">         qhdr-&gt;GetMessageSize(&amp;msgSize);</span>
<a href="#l4.152"></a><span id="l4.152" class="difflineminus">-        // ignore 0 byte messages; the imap parser asserts when we try </span>
<a href="#l4.153"></a><span id="l4.153" class="difflineplus">+        // ignore 0 byte messages; the imap parser asserts when we try</span>
<a href="#l4.154"></a><span id="l4.154">         // to download them, and there's no point anyway.</span>
<a href="#l4.155"></a><span id="l4.155">         if (!msgSize)</span>
<a href="#l4.156"></a><span id="l4.156">           continue;</span>
<a href="#l4.157"></a><span id="l4.157"> </span>
<a href="#l4.158"></a><span id="l4.158" class="difflineminus">-        if (!*aActualGroupSize &amp;&amp; msgSize &gt;= aSuggestedGroupSizeLimit) </span>
<a href="#l4.159"></a><span id="l4.159" class="difflineplus">+        if (!*aActualGroupSize &amp;&amp; msgSize &gt;= aSuggestedGroupSizeLimit)</span>
<a href="#l4.160"></a><span id="l4.160">         {</span>
<a href="#l4.161"></a><span id="l4.161">           *aActualGroupSize = msgSize;</span>
<a href="#l4.162"></a><span id="l4.162">           group-&gt;AppendElement(qhdr);</span>
<a href="#l4.163"></a><span id="l4.163">           idx++;</span>
<a href="#l4.164"></a><span id="l4.164">           break;</span>
<a href="#l4.165"></a><span id="l4.165">         }</span>
<a href="#l4.166"></a><span id="l4.166">         if ((*aActualGroupSize) + msgSize &gt; aSuggestedGroupSizeLimit)</span>
<a href="#l4.167"></a><span id="l4.167">           break;</span>
<a href="#l4.168"></a><span id="l4.168" class="difflineat">@@ -405,28 +405,28 @@ NS_IMETHODIMP nsAutoSyncState::UpdateFol</span>
<a href="#l4.169"></a><span id="l4.169">   nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l4.170"></a><span id="l4.170">   SetState(nsAutoSyncState::stUpdateIssued);</span>
<a href="#l4.171"></a><span id="l4.171">   return imapFolder-&gt;UpdateFolderWithListener(nullptr, autoSyncMgrListener);</span>
<a href="#l4.172"></a><span id="l4.172"> }</span>
<a href="#l4.173"></a><span id="l4.173"> </span>
<a href="#l4.174"></a><span id="l4.174"> NS_IMETHODIMP nsAutoSyncState::OnStartRunningUrl(nsIURI* aUrl)</span>
<a href="#l4.175"></a><span id="l4.175"> {</span>
<a href="#l4.176"></a><span id="l4.176">   nsresult rv = NS_OK;</span>
<a href="#l4.177"></a><span id="l4.177" class="difflineminus">-    </span>
<a href="#l4.178"></a><span id="l4.178" class="difflineplus">+</span>
<a href="#l4.179"></a><span id="l4.179">   // if there is a problem to start the download, set rv with the</span>
<a href="#l4.180"></a><span id="l4.180">   // corresponding error code. In that case, AutoSyncManager is going to</span>
<a href="#l4.181"></a><span id="l4.181">   // set the autosync state to nsAutoSyncState::stReadyToDownload</span>
<a href="#l4.182"></a><span id="l4.182">   // to resume downloading another time</span>
<a href="#l4.183"></a><span id="l4.183" class="difflineminus">-  </span>
<a href="#l4.184"></a><span id="l4.184" class="difflineplus">+</span>
<a href="#l4.185"></a><span id="l4.185">   // TODO: is there a way to make sure that download started without</span>
<a href="#l4.186"></a><span id="l4.186">   // problem through nsIURI interface?</span>
<a href="#l4.187"></a><span id="l4.187"> </span>
<a href="#l4.188"></a><span id="l4.188">   nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l4.189"></a><span id="l4.189">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.190"></a><span id="l4.190" class="difflineminus">-  </span>
<a href="#l4.191"></a><span id="l4.191" class="difflineplus">+</span>
<a href="#l4.192"></a><span id="l4.192">   return autoSyncMgr-&gt;OnDownloadStarted(this, rv);</span>
<a href="#l4.193"></a><span id="l4.193"> }</span>
<a href="#l4.194"></a><span id="l4.194"> </span>
<a href="#l4.195"></a><span id="l4.195"> NS_IMETHODIMP nsAutoSyncState::OnStopRunningUrl(nsIURI* aUrl, nsresult aExitCode)</span>
<a href="#l4.196"></a><span id="l4.196"> {</span>
<a href="#l4.197"></a><span id="l4.197">   nsresult rv;</span>
<a href="#l4.198"></a><span id="l4.198">   nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l4.199"></a><span id="l4.199">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.200"></a><span id="l4.200" class="difflineat">@@ -525,17 +525,17 @@ NS_IMETHODIMP nsAutoSyncState::TryCurren</span>
<a href="#l4.201"></a><span id="l4.201">   nsresult rv;</span>
<a href="#l4.202"></a><span id="l4.202">   if (++mRetryCounter &gt; aRetryCount)</span>
<a href="#l4.203"></a><span id="l4.203">   {</span>
<a href="#l4.204"></a><span id="l4.204">     ResetRetryCounter();</span>
<a href="#l4.205"></a><span id="l4.205">     rv = NS_ERROR_FAILURE;</span>
<a href="#l4.206"></a><span id="l4.206">   }</span>
<a href="#l4.207"></a><span id="l4.207">   else</span>
<a href="#l4.208"></a><span id="l4.208">     rv = Rollback();</span>
<a href="#l4.209"></a><span id="l4.209" class="difflineminus">-    </span>
<a href="#l4.210"></a><span id="l4.210" class="difflineplus">+</span>
<a href="#l4.211"></a><span id="l4.211">   return rv;</span>
<a href="#l4.212"></a><span id="l4.212"> }</span>
<a href="#l4.213"></a><span id="l4.213"> </span>
<a href="#l4.214"></a><span id="l4.214"> NS_IMETHODIMP nsAutoSyncState::ResetRetryCounter()</span>
<a href="#l4.215"></a><span id="l4.215"> {</span>
<a href="#l4.216"></a><span id="l4.216">   mRetryCounter = 0;</span>
<a href="#l4.217"></a><span id="l4.217">   return NS_OK;</span>
<a href="#l4.218"></a><span id="l4.218"> }</span>
<a href="#l4.219"></a><span id="l4.219" class="difflineat">@@ -552,17 +552,17 @@ NS_IMETHODIMP nsAutoSyncState::GetTotalM</span>
<a href="#l4.220"></a><span id="l4.220">   NS_ENSURE_ARG_POINTER(aMsgCount);</span>
<a href="#l4.221"></a><span id="l4.221">   *aMsgCount = mDownloadQ.Length();</span>
<a href="#l4.222"></a><span id="l4.222">   return NS_OK;</span>
<a href="#l4.223"></a><span id="l4.223"> }</span>
<a href="#l4.224"></a><span id="l4.224"> </span>
<a href="#l4.225"></a><span id="l4.225"> NS_IMETHODIMP nsAutoSyncState::GetOwnerFolder(nsIMsgFolder **aFolder)</span>
<a href="#l4.226"></a><span id="l4.226"> {</span>
<a href="#l4.227"></a><span id="l4.227">   NS_ENSURE_ARG_POINTER(aFolder);</span>
<a href="#l4.228"></a><span id="l4.228" class="difflineminus">-  </span>
<a href="#l4.229"></a><span id="l4.229" class="difflineplus">+</span>
<a href="#l4.230"></a><span id="l4.230">   nsresult rv;</span>
<a href="#l4.231"></a><span id="l4.231">   nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l4.232"></a><span id="l4.232">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.233"></a><span id="l4.233"> </span>
<a href="#l4.234"></a><span id="l4.234">   ownerFolder.forget(aFolder);</span>
<a href="#l4.235"></a><span id="l4.235">   return NS_OK;</span>
<a href="#l4.236"></a><span id="l4.236"> }</span>
<a href="#l4.237"></a><span id="l4.237"> </span>
<a href="#l4.238"></a><span id="l4.238" class="difflineat">@@ -573,90 +573,90 @@ NS_IMETHODIMP nsAutoSyncState::Rollback(</span>
<a href="#l4.239"></a><span id="l4.239"> }</span>
<a href="#l4.240"></a><span id="l4.240"> </span>
<a href="#l4.241"></a><span id="l4.241"> NS_IMETHODIMP nsAutoSyncState::ResetDownloadQ()</span>
<a href="#l4.242"></a><span id="l4.242"> {</span>
<a href="#l4.243"></a><span id="l4.243">   mOffset = mLastOffset = 0;</span>
<a href="#l4.244"></a><span id="l4.244">   mDownloadSet.Clear();</span>
<a href="#l4.245"></a><span id="l4.245">   mDownloadQ.Clear();</span>
<a href="#l4.246"></a><span id="l4.246">   mDownloadQ.Compact();</span>
<a href="#l4.247"></a><span id="l4.247" class="difflineminus">-  </span>
<a href="#l4.248"></a><span id="l4.248" class="difflineplus">+</span>
<a href="#l4.249"></a><span id="l4.249">   return NS_OK;</span>
<a href="#l4.250"></a><span id="l4.250"> }</span>
<a href="#l4.251"></a><span id="l4.251"> </span>
<a href="#l4.252"></a><span id="l4.252"> /**</span>
<a href="#l4.253"></a><span id="l4.253">  * Tests whether the given folder is owned by the same imap server</span>
<a href="#l4.254"></a><span id="l4.254">  * or not.</span>
<a href="#l4.255"></a><span id="l4.255">  */</span>
<a href="#l4.256"></a><span id="l4.256"> NS_IMETHODIMP nsAutoSyncState::IsSibling(nsIAutoSyncState *aAnotherStateObj, bool *aResult)</span>
<a href="#l4.257"></a><span id="l4.257"> {</span>
<a href="#l4.258"></a><span id="l4.258">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l4.259"></a><span id="l4.259">   *aResult = false;</span>
<a href="#l4.260"></a><span id="l4.260"> </span>
<a href="#l4.261"></a><span id="l4.261">   nsresult rv;</span>
<a href="#l4.262"></a><span id="l4.262">   nsCOMPtr&lt;nsIMsgFolder&gt; folderA, folderB;</span>
<a href="#l4.263"></a><span id="l4.263" class="difflineminus">-  </span>
<a href="#l4.264"></a><span id="l4.264" class="difflineplus">+</span>
<a href="#l4.265"></a><span id="l4.265">   rv = GetOwnerFolder(getter_AddRefs(folderA));</span>
<a href="#l4.266"></a><span id="l4.266">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l4.267"></a><span id="l4.267" class="difflineminus">-  </span>
<a href="#l4.268"></a><span id="l4.268" class="difflineplus">+</span>
<a href="#l4.269"></a><span id="l4.269">   rv = aAnotherStateObj-&gt;GetOwnerFolder(getter_AddRefs(folderB));</span>
<a href="#l4.270"></a><span id="l4.270">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l4.271"></a><span id="l4.271" class="difflineminus">-  </span>
<a href="#l4.272"></a><span id="l4.272" class="difflineplus">+</span>
<a href="#l4.273"></a><span id="l4.273">   nsCOMPtr &lt;nsIMsgIncomingServer&gt; serverA, serverB;</span>
<a href="#l4.274"></a><span id="l4.274">   rv = folderA-&gt;GetServer(getter_AddRefs(serverA));</span>
<a href="#l4.275"></a><span id="l4.275">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l4.276"></a><span id="l4.276">   rv = folderB-&gt;GetServer(getter_AddRefs(serverB));</span>
<a href="#l4.277"></a><span id="l4.277">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l4.278"></a><span id="l4.278" class="difflineminus">-  </span>
<a href="#l4.279"></a><span id="l4.279" class="difflineplus">+</span>
<a href="#l4.280"></a><span id="l4.280">   bool isSibling;</span>
<a href="#l4.281"></a><span id="l4.281">   rv = serverA-&gt;Equals(serverB, &amp;isSibling);</span>
<a href="#l4.282"></a><span id="l4.282" class="difflineminus">-  </span>
<a href="#l4.283"></a><span id="l4.283" class="difflineplus">+</span>
<a href="#l4.284"></a><span id="l4.284">   if (NS_SUCCEEDED(rv))</span>
<a href="#l4.285"></a><span id="l4.285">     *aResult = isSibling;</span>
<a href="#l4.286"></a><span id="l4.286" class="difflineminus">-  </span>
<a href="#l4.287"></a><span id="l4.287" class="difflineplus">+</span>
<a href="#l4.288"></a><span id="l4.288">   return rv;</span>
<a href="#l4.289"></a><span id="l4.289"> }</span>
<a href="#l4.290"></a><span id="l4.290"> </span>
<a href="#l4.291"></a><span id="l4.291"> </span>
<a href="#l4.292"></a><span id="l4.292"> NS_IMETHODIMP nsAutoSyncState::DownloadMessagesForOffline(nsIArray *aMessagesList)</span>
<a href="#l4.293"></a><span id="l4.293"> {</span>
<a href="#l4.294"></a><span id="l4.294">   NS_ENSURE_ARG_POINTER(aMessagesList);</span>
<a href="#l4.295"></a><span id="l4.295" class="difflineminus">-  </span>
<a href="#l4.296"></a><span id="l4.296" class="difflineplus">+</span>
<a href="#l4.297"></a><span id="l4.297">   uint32_t count;</span>
<a href="#l4.298"></a><span id="l4.298">   nsresult rv = aMessagesList-&gt;GetLength(&amp;count);</span>
<a href="#l4.299"></a><span id="l4.299">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l4.300"></a><span id="l4.300" class="difflineminus">-  </span>
<a href="#l4.301"></a><span id="l4.301" class="difflineplus">+</span>
<a href="#l4.302"></a><span id="l4.302">   nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l4.303"></a><span id="l4.303">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l4.304"></a><span id="l4.304" class="difflineminus">-  </span>
<a href="#l4.305"></a><span id="l4.305" class="difflineplus">+</span>
<a href="#l4.306"></a><span id="l4.306">   nsAutoCString messageIds;</span>
<a href="#l4.307"></a><span id="l4.307">   nsTArray&lt;nsMsgKey&gt; msgKeys;</span>
<a href="#l4.308"></a><span id="l4.308" class="difflineminus">-  </span>
<a href="#l4.309"></a><span id="l4.309" class="difflineminus">-  rv = nsImapMailFolder::BuildIdsAndKeyArray(aMessagesList, messageIds, msgKeys);  </span>
<a href="#l4.310"></a><span id="l4.310" class="difflineminus">-  if (NS_FAILED(rv) || messageIds.IsEmpty()) </span>
<a href="#l4.311"></a><span id="l4.311" class="difflineplus">+</span>
<a href="#l4.312"></a><span id="l4.312" class="difflineplus">+  rv = nsImapMailFolder::BuildIdsAndKeyArray(aMessagesList, messageIds, msgKeys);</span>
<a href="#l4.313"></a><span id="l4.313" class="difflineplus">+  if (NS_FAILED(rv) || messageIds.IsEmpty())</span>
<a href="#l4.314"></a><span id="l4.314">     return rv;</span>
<a href="#l4.315"></a><span id="l4.315"> </span>
<a href="#l4.316"></a><span id="l4.316">   // acquire semaphore for offline store. If it fails, we won't download</span>
<a href="#l4.317"></a><span id="l4.317">   nsCOMPtr &lt;nsIMsgFolder&gt; folder = do_QueryReferent(mOwnerFolder, &amp;rv);</span>
<a href="#l4.318"></a><span id="l4.318">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.319"></a><span id="l4.319" class="difflineminus">-  </span>
<a href="#l4.320"></a><span id="l4.320" class="difflineplus">+</span>
<a href="#l4.321"></a><span id="l4.321">   rv = folder-&gt;AcquireSemaphore(folder);</span>
<a href="#l4.322"></a><span id="l4.322">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l4.323"></a><span id="l4.323"> </span>
<a href="#l4.324"></a><span id="l4.324">   nsCString folderName;</span>
<a href="#l4.325"></a><span id="l4.325">   folder-&gt;GetURI(folderName);</span>
<a href="#l4.326"></a><span id="l4.326">   MOZ_LOG(gAutoSyncLog, LogLevel::Debug, (&quot;downloading %s for %s&quot;, messageIds.get(),</span>
<a href="#l4.327"></a><span id="l4.327">            folderName.get()));</span>
<a href="#l4.328"></a><span id="l4.328">   // start downloading</span>
<a href="#l4.329"></a><span id="l4.329" class="difflineminus">-  rv = imapService-&gt;DownloadMessagesForOffline(messageIds, </span>
<a href="#l4.330"></a><span id="l4.330" class="difflineminus">-                                               folder, </span>
<a href="#l4.331"></a><span id="l4.331" class="difflineminus">-                                               this, </span>
<a href="#l4.332"></a><span id="l4.332" class="difflineplus">+  rv = imapService-&gt;DownloadMessagesForOffline(messageIds,</span>
<a href="#l4.333"></a><span id="l4.333" class="difflineplus">+                                               folder,</span>
<a href="#l4.334"></a><span id="l4.334" class="difflineplus">+                                               this,</span>
<a href="#l4.335"></a><span id="l4.335">                                                nullptr);</span>
<a href="#l4.336"></a><span id="l4.336">   if (NS_SUCCEEDED(rv))</span>
<a href="#l4.337"></a><span id="l4.337" class="difflineminus">-    SetState(stDownloadInProgress);                                              </span>
<a href="#l4.338"></a><span id="l4.338" class="difflineplus">+    SetState(stDownloadInProgress);</span>
<a href="#l4.339"></a><span id="l4.339"> </span>
<a href="#l4.340"></a><span id="l4.340">   return rv;</span>
<a href="#l4.341"></a><span id="l4.341"> }</span>
<a href="#l4.342"></a><span id="l4.342"> </span>
<a href="#l4.343"></a><span id="l4.343"> NS_IMETHODIMP nsAutoSyncState::GetLastSyncTime(PRTime *aLastSyncTime)</span>
<a href="#l4.344"></a><span id="l4.344"> {</span>
<a href="#l4.345"></a><span id="l4.345">   NS_ENSURE_ARG_POINTER(aLastSyncTime);</span>
<a href="#l4.346"></a><span id="l4.346">   *aLastSyncTime = mLastSyncTime;</span>
<a href="#l4.347"></a><span id="l4.347" class="difflineat">@@ -696,19 +696,19 @@ NS_IMPL_ISUPPORTS(nsAutoSyncState, nsIAu</span>
<a href="#l4.348"></a><span id="l4.348"> </span>
<a href="#l4.349"></a><span id="l4.349"> void nsAutoSyncState::LogQWithSize(nsTArray&lt;nsMsgKey&gt;&amp; q, uint32_t toOffset)</span>
<a href="#l4.350"></a><span id="l4.350"> {</span>
<a href="#l4.351"></a><span id="l4.351">   nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder);</span>
<a href="#l4.352"></a><span id="l4.352">   if (ownerFolder)</span>
<a href="#l4.353"></a><span id="l4.353">   {</span>
<a href="#l4.354"></a><span id="l4.354">     nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l4.355"></a><span id="l4.355">     ownerFolder-&gt;GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l4.356"></a><span id="l4.356" class="difflineminus">-    </span>
<a href="#l4.357"></a><span id="l4.357" class="difflineplus">+</span>
<a href="#l4.358"></a><span id="l4.358">     uint32_t x = q.Length();</span>
<a href="#l4.359"></a><span id="l4.359" class="difflineminus">-    while (x &gt; toOffset &amp;&amp; database) </span>
<a href="#l4.360"></a><span id="l4.360" class="difflineplus">+    while (x &gt; toOffset &amp;&amp; database)</span>
<a href="#l4.361"></a><span id="l4.361">     {</span>
<a href="#l4.362"></a><span id="l4.362">       x--;</span>
<a href="#l4.363"></a><span id="l4.363">       nsCOMPtr&lt;nsIMsgDBHdr&gt; h;</span>
<a href="#l4.364"></a><span id="l4.364">       database-&gt;GetMsgHdrForKey(q[x], getter_AddRefs(h));</span>
<a href="#l4.365"></a><span id="l4.365">       uint32_t s;</span>
<a href="#l4.366"></a><span id="l4.366">       if (h)</span>
<a href="#l4.367"></a><span id="l4.367">       {</span>
<a href="#l4.368"></a><span id="l4.368">         h-&gt;GetMessageSize(&amp;s);</span>
<a href="#l4.369"></a><span id="l4.369" class="difflineat">@@ -726,17 +726,17 @@ void nsAutoSyncState::LogQWithSize(nsIMu</span>
<a href="#l4.370"></a><span id="l4.370">   nsCOMPtr &lt;nsIMsgFolder&gt; ownerFolder = do_QueryReferent(mOwnerFolder);</span>
<a href="#l4.371"></a><span id="l4.371">   if (ownerFolder)</span>
<a href="#l4.372"></a><span id="l4.372">   {</span>
<a href="#l4.373"></a><span id="l4.373">     nsCOMPtr&lt;nsIMsgDatabase&gt; database;</span>
<a href="#l4.374"></a><span id="l4.374">     ownerFolder-&gt;GetMsgDatabase(getter_AddRefs(database));</span>
<a href="#l4.375"></a><span id="l4.375"> </span>
<a href="#l4.376"></a><span id="l4.376">     uint32_t x;</span>
<a href="#l4.377"></a><span id="l4.377">     q-&gt;GetLength(&amp;x);</span>
<a href="#l4.378"></a><span id="l4.378" class="difflineminus">-    while (x &gt; toOffset &amp;&amp; database) </span>
<a href="#l4.379"></a><span id="l4.379" class="difflineplus">+    while (x &gt; toOffset &amp;&amp; database)</span>
<a href="#l4.380"></a><span id="l4.380">     {</span>
<a href="#l4.381"></a><span id="l4.381">       x--;</span>
<a href="#l4.382"></a><span id="l4.382">       nsCOMPtr&lt;nsIMsgDBHdr&gt; h = do_QueryElementAt(q, x);</span>
<a href="#l4.383"></a><span id="l4.383">       if (h)</span>
<a href="#l4.384"></a><span id="l4.384">       {</span>
<a href="#l4.385"></a><span id="l4.385">         uint32_t s;</span>
<a href="#l4.386"></a><span id="l4.386">         h-&gt;GetMessageSize(&amp;s);</span>
<a href="#l4.387"></a><span id="l4.387">         MOZ_LOG(gAutoSyncLog, LogLevel::Debug,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/imap/src/nsAutoSyncState.h</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/imap/src/nsAutoSyncState.h</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -2,48 +2,48 @@</span>
<a href="#l5.4"></a><span id="l5.4">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l5.5"></a><span id="l5.5">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l5.6"></a><span id="l5.6"> </span>
<a href="#l5.7"></a><span id="l5.7"> #ifndef nsAutoSyncState_h__</span>
<a href="#l5.8"></a><span id="l5.8"> #define nsAutoSyncState_h__</span>
<a href="#l5.9"></a><span id="l5.9"> </span>
<a href="#l5.10"></a><span id="l5.10"> #include &quot;MailNewsTypes.h&quot;</span>
<a href="#l5.11"></a><span id="l5.11"> #include &quot;nsIAutoSyncState.h&quot;</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-#include &quot;nsIAutoSyncManager.h&quot; </span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+#include &quot;nsIAutoSyncManager.h&quot;</span>
<a href="#l5.14"></a><span id="l5.14"> #include &quot;nsIUrlListener.h&quot;</span>
<a href="#l5.15"></a><span id="l5.15"> #include &quot;nsWeakPtr.h&quot;</span>
<a href="#l5.16"></a><span id="l5.16"> #include &quot;nsTHashtable.h&quot;</span>
<a href="#l5.17"></a><span id="l5.17"> #include &quot;nsHashKeys.h&quot;</span>
<a href="#l5.18"></a><span id="l5.18"> #include &quot;nsTArray.h&quot;</span>
<a href="#l5.19"></a><span id="l5.19"> #include &quot;prlog.h&quot;</span>
<a href="#l5.20"></a><span id="l5.20"> #include &quot;nsIWeakReferenceUtils.h&quot;</span>
<a href="#l5.21"></a><span id="l5.21"> </span>
<a href="#l5.22"></a><span id="l5.22"> class nsImapMailFolder;</span>
<a href="#l5.23"></a><span id="l5.23"> class nsIAutoSyncMsgStrategy;</span>
<a href="#l5.24"></a><span id="l5.24"> class nsIMsgDatabase;</span>
<a href="#l5.25"></a><span id="l5.25"> </span>
<a href="#l5.26"></a><span id="l5.26"> /**</span>
<a href="#l5.27"></a><span id="l5.27">  * An adaptor class to make msg strategy nsTArray.Sort()</span>
<a href="#l5.28"></a><span id="l5.28">  * compatible.</span>
<a href="#l5.29"></a><span id="l5.29">  */</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineminus">-class MsgStrategyComparatorAdaptor </span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+class MsgStrategyComparatorAdaptor</span>
<a href="#l5.32"></a><span id="l5.32"> {</span>
<a href="#l5.33"></a><span id="l5.33">  public:</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineminus">-  MsgStrategyComparatorAdaptor(nsIAutoSyncMsgStrategy* aStrategy, </span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+  MsgStrategyComparatorAdaptor(nsIAutoSyncMsgStrategy* aStrategy,</span>
<a href="#l5.36"></a><span id="l5.36">     nsIMsgFolder *aFolder, nsIMsgDatabase *aDatabase);</span>
<a href="#l5.37"></a><span id="l5.37"> </span>
<a href="#l5.38"></a><span id="l5.38">   /** @return True if the elements are equals; false otherwise. */</span>
<a href="#l5.39"></a><span id="l5.39">   bool Equals(const nsMsgKey&amp; a, const nsMsgKey&amp; b) const;</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineminus">-  </span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+</span>
<a href="#l5.42"></a><span id="l5.42">   /** @return True if (a &lt; b); false otherwise. */</span>
<a href="#l5.43"></a><span id="l5.43">   bool LessThan(const nsMsgKey&amp; a, const nsMsgKey&amp; b) const;</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineminus">-  </span>
<a href="#l5.45"></a><span id="l5.45" class="difflineplus">+</span>
<a href="#l5.46"></a><span id="l5.46">  private:</span>
<a href="#l5.47"></a><span id="l5.47">   MsgStrategyComparatorAdaptor();</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineminus">-  </span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+</span>
<a href="#l5.50"></a><span id="l5.50">  private:</span>
<a href="#l5.51"></a><span id="l5.51">   nsIAutoSyncMsgStrategy *mStrategy;</span>
<a href="#l5.52"></a><span id="l5.52">   nsIMsgFolder *mFolder;</span>
<a href="#l5.53"></a><span id="l5.53">   nsIMsgDatabase *mDatabase;</span>
<a href="#l5.54"></a><span id="l5.54"> };</span>
<a href="#l5.55"></a><span id="l5.55"> </span>
<a href="#l5.56"></a><span id="l5.56"> </span>
<a href="#l5.57"></a><span id="l5.57"> /**</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineat">@@ -59,28 +59,28 @@ public:</span>
<a href="#l5.59"></a><span id="l5.59">   nsAutoSyncState(nsImapMailFolder *aOwnerFolder, PRTime aLastSyncTime = 0UL);</span>
<a href="#l5.60"></a><span id="l5.60"> </span>
<a href="#l5.61"></a><span id="l5.61">   /// Called by owner folder when new headers are fetched from the server</span>
<a href="#l5.62"></a><span id="l5.62">   void OnNewHeaderFetchCompleted(const nsTArray&lt;nsMsgKey&gt; &amp;aMsgKeyList);</span>
<a href="#l5.63"></a><span id="l5.63"> </span>
<a href="#l5.64"></a><span id="l5.64">   /// Sets the last sync time in lower precision (seconds)</span>
<a href="#l5.65"></a><span id="l5.65">   void SetLastSyncTimeInSec(int32_t aLastSyncTime);</span>
<a href="#l5.66"></a><span id="l5.66"> </span>
<a href="#l5.67"></a><span id="l5.67" class="difflineminus">-  /// Manages storage space for auto-sync operations </span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+  /// Manages storage space for auto-sync operations</span>
<a href="#l5.69"></a><span id="l5.69">   nsresult ManageStorageSpace();</span>
<a href="#l5.70"></a><span id="l5.70"> </span>
<a href="#l5.71"></a><span id="l5.71">   void SetServerCounts(int32_t total, int32_t recent, int32_t unseen,</span>
<a href="#l5.72"></a><span id="l5.72">                        int32_t nextUID);</span>
<a href="#l5.73"></a><span id="l5.73"> </span>
<a href="#l5.74"></a><span id="l5.74">  private:</span>
<a href="#l5.75"></a><span id="l5.75">   ~nsAutoSyncState();</span>
<a href="#l5.76"></a><span id="l5.76" class="difflineminus">-  </span>
<a href="#l5.77"></a><span id="l5.77" class="difflineplus">+</span>
<a href="#l5.78"></a><span id="l5.78">   nsresult PlaceIntoDownloadQ(const nsTArray&lt;nsMsgKey&gt; &amp;aMsgKeyList);</span>
<a href="#l5.79"></a><span id="l5.79">   nsresult SortQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue);</span>
<a href="#l5.80"></a><span id="l5.80" class="difflineminus">-  nsresult SortSubQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue, </span>
<a href="#l5.81"></a><span id="l5.81" class="difflineplus">+  nsresult SortSubQueueBasedOnStrategy(nsTArray&lt;nsMsgKey&gt; &amp;aQueue,</span>
<a href="#l5.82"></a><span id="l5.82">                                     uint32_t aStartingOffset);</span>
<a href="#l5.83"></a><span id="l5.83"> </span>
<a href="#l5.84"></a><span id="l5.84">   void LogOwnerFolderName(const char *s);</span>
<a href="#l5.85"></a><span id="l5.85">   void LogQWithSize(nsTArray&lt;nsMsgKey&gt;&amp; q, uint32_t toOffset = 0);</span>
<a href="#l5.86"></a><span id="l5.86">   void LogQWithSize(nsIMutableArray *q, uint32_t toOffset = 0);</span>
<a href="#l5.87"></a><span id="l5.87"> </span>
<a href="#l5.88"></a><span id="l5.88">  private:</span>
<a href="#l5.89"></a><span id="l5.89">   int32_t mSyncState;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPBodyShell.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPBodyShell.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -64,17 +64,17 @@ nsIMAPBodyShell::nsIMAPBodyShell(nsImapP</span>
<a href="#l6.4"></a><span id="l6.4"> #ifdef DEBUG_chrisf</span>
<a href="#l6.5"></a><span id="l6.5">   NS_ASSERTION(folderName);</span>
<a href="#l6.6"></a><span id="l6.6"> #endif</span>
<a href="#l6.7"></a><span id="l6.7">   if (!folderName)</span>
<a href="#l6.8"></a><span id="l6.8">     return;</span>
<a href="#l6.9"></a><span id="l6.9">   m_folderName = NS_strdup(folderName);</span>
<a href="#l6.10"></a><span id="l6.10">   if (!m_folderName)</span>
<a href="#l6.11"></a><span id="l6.11">     return;</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-  </span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+</span>
<a href="#l6.14"></a><span id="l6.14">   SetContentModified(GetShowAttachmentsInline() ? IMAP_CONTENT_MODIFIED_VIEW_INLINE : IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS);</span>
<a href="#l6.15"></a><span id="l6.15"> </span>
<a href="#l6.16"></a><span id="l6.16">   SetIsValid(m_message != nullptr);</span>
<a href="#l6.17"></a><span id="l6.17"> }</span>
<a href="#l6.18"></a><span id="l6.18"> </span>
<a href="#l6.19"></a><span id="l6.19"> nsIMAPBodyShell::~nsIMAPBodyShell()</span>
<a href="#l6.20"></a><span id="l6.20"> {</span>
<a href="#l6.21"></a><span id="l6.21">   delete m_message;</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineat">@@ -89,29 +89,29 @@ void nsIMAPBodyShell::SetIsValid(bool va</span>
<a href="#l6.23"></a><span id="l6.23"> </span>
<a href="#l6.24"></a><span id="l6.24"> bool nsIMAPBodyShell::GetShowAttachmentsInline()</span>
<a href="#l6.25"></a><span id="l6.25"> {</span>
<a href="#l6.26"></a><span id="l6.26">   if (!m_gotAttachmentPref)</span>
<a href="#l6.27"></a><span id="l6.27">   {</span>
<a href="#l6.28"></a><span id="l6.28">     m_showAttachmentsInline = !m_protocolConnection || m_protocolConnection-&gt;GetShowAttachmentsInline();</span>
<a href="#l6.29"></a><span id="l6.29">     m_gotAttachmentPref = true;</span>
<a href="#l6.30"></a><span id="l6.30">   }</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-  </span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+</span>
<a href="#l6.33"></a><span id="l6.33">   return m_showAttachmentsInline;</span>
<a href="#l6.34"></a><span id="l6.34"> }</span>
<a href="#l6.35"></a><span id="l6.35"> </span>
<a href="#l6.36"></a><span id="l6.36"> // Fills in buffer (and adopts storage) for header object</span>
<a href="#l6.37"></a><span id="l6.37"> void nsIMAPBodyShell::AdoptMessageHeaders(char *headers, const char *partNum)</span>
<a href="#l6.38"></a><span id="l6.38"> {</span>
<a href="#l6.39"></a><span id="l6.39">   if (!GetIsValid())</span>
<a href="#l6.40"></a><span id="l6.40">     return;</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineminus">-  </span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+</span>
<a href="#l6.43"></a><span id="l6.43">   if (!partNum)</span>
<a href="#l6.44"></a><span id="l6.44">     partNum = &quot;0&quot;;</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineminus">-  </span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+</span>
<a href="#l6.47"></a><span id="l6.47">   // we are going to say that a message header object only has</span>
<a href="#l6.48"></a><span id="l6.48">   // part data, and no header data.</span>
<a href="#l6.49"></a><span id="l6.49">   nsIMAPBodypart *foundPart = m_message-&gt;FindPartWithNumber(partNum);</span>
<a href="#l6.50"></a><span id="l6.50">   if (foundPart)</span>
<a href="#l6.51"></a><span id="l6.51">   {</span>
<a href="#l6.52"></a><span id="l6.52">     nsIMAPBodypartMessage *messageObj = foundPart-&gt;GetnsIMAPBodypartMessage();</span>
<a href="#l6.53"></a><span id="l6.53">     if (messageObj)</span>
<a href="#l6.54"></a><span id="l6.54">     {</span>
<a href="#l6.55"></a><span id="l6.55" class="difflineat">@@ -133,21 +133,21 @@ void nsIMAPBodyShell::AdoptMessageHeader</span>
<a href="#l6.56"></a><span id="l6.56"> }</span>
<a href="#l6.57"></a><span id="l6.57"> </span>
<a href="#l6.58"></a><span id="l6.58"> // Fills in buffer (and adopts storage) for MIME headers in appropriate object.</span>
<a href="#l6.59"></a><span id="l6.59"> // If object can't be found, sets isValid to false.</span>
<a href="#l6.60"></a><span id="l6.60"> void nsIMAPBodyShell::AdoptMimeHeader(const char *partNum, char *mimeHeader)</span>
<a href="#l6.61"></a><span id="l6.61"> {</span>
<a href="#l6.62"></a><span id="l6.62">   if (!GetIsValid())</span>
<a href="#l6.63"></a><span id="l6.63">     return;</span>
<a href="#l6.64"></a><span id="l6.64" class="difflineminus">-  </span>
<a href="#l6.65"></a><span id="l6.65" class="difflineplus">+</span>
<a href="#l6.66"></a><span id="l6.66">   NS_ASSERTION(partNum, &quot;null partnum in body shell&quot;);</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineminus">-  </span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+</span>
<a href="#l6.69"></a><span id="l6.69">   nsIMAPBodypart *foundPart = m_message-&gt;FindPartWithNumber(partNum);</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineminus">-  </span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+</span>
<a href="#l6.72"></a><span id="l6.72">   if (foundPart)</span>
<a href="#l6.73"></a><span id="l6.73">   {</span>
<a href="#l6.74"></a><span id="l6.74">     foundPart-&gt;AdoptHeaderDataBuffer(mimeHeader);</span>
<a href="#l6.75"></a><span id="l6.75">     if (!foundPart-&gt;GetIsValid())</span>
<a href="#l6.76"></a><span id="l6.76">       SetIsValid(false);</span>
<a href="#l6.77"></a><span id="l6.77">   }</span>
<a href="#l6.78"></a><span id="l6.78">   else</span>
<a href="#l6.79"></a><span id="l6.79">   {</span>
<a href="#l6.80"></a><span id="l6.80" class="difflineat">@@ -195,27 +195,27 @@ bool nsIMAPBodyShell::PreflightCheckAllI</span>
<a href="#l6.81"></a><span id="l6.81"> // Ok, here's how we're going to do this.  Essentially, this</span>
<a href="#l6.82"></a><span id="l6.82"> // will be the mirror image of the &quot;normal&quot; generation.</span>
<a href="#l6.83"></a><span id="l6.83"> // All parts will be left out except a single part which is</span>
<a href="#l6.84"></a><span id="l6.84"> // explicitly specified.  All relevant headers will be included.</span>
<a href="#l6.85"></a><span id="l6.85"> // Libmime will extract only the part of interest, so we don't</span>
<a href="#l6.86"></a><span id="l6.86"> // have to worry about the other parts.  This also has the</span>
<a href="#l6.87"></a><span id="l6.87"> // advantage that it looks like it will be more workable for</span>
<a href="#l6.88"></a><span id="l6.88"> // nested parts.  For instance, if a user clicks on a link to</span>
<a href="#l6.89"></a><span id="l6.89" class="difflineminus">-// a forwarded message, then that forwarded message may be </span>
<a href="#l6.90"></a><span id="l6.90" class="difflineplus">+// a forwarded message, then that forwarded message may be</span>
<a href="#l6.91"></a><span id="l6.91"> // generated along with any images that the forwarded message</span>
<a href="#l6.92"></a><span id="l6.92"> // contains, for instance.</span>
<a href="#l6.93"></a><span id="l6.93"> </span>
<a href="#l6.94"></a><span id="l6.94"> </span>
<a href="#l6.95"></a><span id="l6.95"> int32_t nsIMAPBodyShell::Generate(char *partNum)</span>
<a href="#l6.96"></a><span id="l6.96"> {</span>
<a href="#l6.97"></a><span id="l6.97">   m_isBeingGenerated = true;</span>
<a href="#l6.98"></a><span id="l6.98">   m_generatingPart = partNum;</span>
<a href="#l6.99"></a><span id="l6.99">   int32_t contentLength = 0;</span>
<a href="#l6.100"></a><span id="l6.100" class="difflineminus">-  </span>
<a href="#l6.101"></a><span id="l6.101" class="difflineplus">+</span>
<a href="#l6.102"></a><span id="l6.102">   if (!GetIsValid() || PreflightCheckAllInline())</span>
<a href="#l6.103"></a><span id="l6.103">   {</span>
<a href="#l6.104"></a><span id="l6.104">     // We don't have a valid shell, or all parts are going to be inline anyway.  Fall back to fetching the whole message.</span>
<a href="#l6.105"></a><span id="l6.105"> #ifdef DEBUG_chrisf</span>
<a href="#l6.106"></a><span id="l6.106">     NS_ASSERTION(GetIsValid());</span>
<a href="#l6.107"></a><span id="l6.107"> #endif</span>
<a href="#l6.108"></a><span id="l6.108">     m_generatingWholeMessage = true;</span>
<a href="#l6.109"></a><span id="l6.109">     uint32_t messageSize = m_protocolConnection-&gt;GetMessageSize(GetUID().get(), true);</span>
<a href="#l6.110"></a><span id="l6.110" class="difflineat">@@ -224,58 +224,58 @@ int32_t nsIMAPBodyShell::Generate(char *</span>
<a href="#l6.111"></a><span id="l6.111">       m_protocolConnection-&gt;FallbackToFetchWholeMsg(GetUID(), messageSize);</span>
<a href="#l6.112"></a><span id="l6.112">     contentLength = (int32_t) messageSize;	// ugh</span>
<a href="#l6.113"></a><span id="l6.113">   }</span>
<a href="#l6.114"></a><span id="l6.114">   else</span>
<a href="#l6.115"></a><span id="l6.115">   {</span>
<a href="#l6.116"></a><span id="l6.116">     // We have a valid shell.</span>
<a href="#l6.117"></a><span id="l6.117">     bool streamCreated = false;</span>
<a href="#l6.118"></a><span id="l6.118">     m_generatingWholeMessage = false;</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineminus">-    </span>
<a href="#l6.120"></a><span id="l6.120" class="difflineplus">+</span>
<a href="#l6.121"></a><span id="l6.121">     ////// PASS 1 : PREFETCH ///////</span>
<a href="#l6.122"></a><span id="l6.122">     // First, prefetch any additional headers/data that we need</span>
<a href="#l6.123"></a><span id="l6.123">     if (!GetPseudoInterrupted())</span>
<a href="#l6.124"></a><span id="l6.124">       m_message-&gt;Generate(this, false, true); // This queues up everything we need to prefetch</span>
<a href="#l6.125"></a><span id="l6.125">     // Now, run a single pipelined prefetch  (neato!)</span>
<a href="#l6.126"></a><span id="l6.126">     FlushPrefetchQueue();</span>
<a href="#l6.127"></a><span id="l6.127" class="difflineminus">-    </span>
<a href="#l6.128"></a><span id="l6.128" class="difflineplus">+</span>
<a href="#l6.129"></a><span id="l6.129">     ////// PASS 2 : COMPUTE STREAM SIZE ///////</span>
<a href="#l6.130"></a><span id="l6.130">     // Next, figure out the size from the parts that we're going to fill in,</span>
<a href="#l6.131"></a><span id="l6.131">     // plus all of the MIME headers, plus the message header itself</span>
<a href="#l6.132"></a><span id="l6.132">     if (!GetPseudoInterrupted())</span>
<a href="#l6.133"></a><span id="l6.133">       contentLength = m_message-&gt;Generate(this, false, false);</span>
<a href="#l6.134"></a><span id="l6.134" class="difflineminus">-    </span>
<a href="#l6.135"></a><span id="l6.135" class="difflineplus">+</span>
<a href="#l6.136"></a><span id="l6.136">     // Setup the stream</span>
<a href="#l6.137"></a><span id="l6.137">     if (!GetPseudoInterrupted() &amp;&amp; !DeathSignalReceived())</span>
<a href="#l6.138"></a><span id="l6.138">     {</span>
<a href="#l6.139"></a><span id="l6.139" class="difflineminus">-      nsresult rv = </span>
<a href="#l6.140"></a><span id="l6.140" class="difflineplus">+      nsresult rv =</span>
<a href="#l6.141"></a><span id="l6.141">         m_protocolConnection-&gt;BeginMessageDownLoad(contentLength, MESSAGE_RFC822);</span>
<a href="#l6.142"></a><span id="l6.142">       if (NS_FAILED(rv))</span>
<a href="#l6.143"></a><span id="l6.143">       {</span>
<a href="#l6.144"></a><span id="l6.144">         m_generatingPart = nullptr;</span>
<a href="#l6.145"></a><span id="l6.145">         m_protocolConnection-&gt;AbortMessageDownLoad();</span>
<a href="#l6.146"></a><span id="l6.146">         return 0;</span>
<a href="#l6.147"></a><span id="l6.147">       }</span>
<a href="#l6.148"></a><span id="l6.148">       streamCreated = true;</span>
<a href="#l6.149"></a><span id="l6.149">     }</span>
<a href="#l6.150"></a><span id="l6.150"> </span>
<a href="#l6.151"></a><span id="l6.151">     ////// PASS 3 : GENERATE ///////</span>
<a href="#l6.152"></a><span id="l6.152">     // Generate the message</span>
<a href="#l6.153"></a><span id="l6.153">     if (!GetPseudoInterrupted() &amp;&amp; !DeathSignalReceived())</span>
<a href="#l6.154"></a><span id="l6.154">       m_message-&gt;Generate(this, true, false);</span>
<a href="#l6.155"></a><span id="l6.155" class="difflineminus">-    </span>
<a href="#l6.156"></a><span id="l6.156" class="difflineplus">+</span>
<a href="#l6.157"></a><span id="l6.157">     // Close the stream here - normal.  If pseudointerrupted, the connection will abort the download stream</span>
<a href="#l6.158"></a><span id="l6.158">     if (!GetPseudoInterrupted() &amp;&amp; !DeathSignalReceived())</span>
<a href="#l6.159"></a><span id="l6.159">       m_protocolConnection-&gt;NormalMessageEndDownload();</span>
<a href="#l6.160"></a><span id="l6.160">     else if (streamCreated)</span>
<a href="#l6.161"></a><span id="l6.161">       m_protocolConnection-&gt;AbortMessageDownLoad();</span>
<a href="#l6.162"></a><span id="l6.162" class="difflineminus">-    </span>
<a href="#l6.163"></a><span id="l6.163" class="difflineplus">+</span>
<a href="#l6.164"></a><span id="l6.164">     m_generatingPart = NULL;</span>
<a href="#l6.165"></a><span id="l6.165">   }</span>
<a href="#l6.166"></a><span id="l6.166" class="difflineminus">-  </span>
<a href="#l6.167"></a><span id="l6.167" class="difflineplus">+</span>
<a href="#l6.168"></a><span id="l6.168">   m_isBeingGenerated = false;</span>
<a href="#l6.169"></a><span id="l6.169">   return contentLength;</span>
<a href="#l6.170"></a><span id="l6.170"> }</span>
<a href="#l6.171"></a><span id="l6.171"> </span>
<a href="#l6.172"></a><span id="l6.172"> bool nsIMAPBodyShell::GetPseudoInterrupted()</span>
<a href="#l6.173"></a><span id="l6.173"> {</span>
<a href="#l6.174"></a><span id="l6.174">   bool rv = m_protocolConnection-&gt;GetPseudoInterrupted();</span>
<a href="#l6.175"></a><span id="l6.175">   return rv;</span>
<a href="#l6.176"></a><span id="l6.176" class="difflineat">@@ -295,17 +295,17 @@ nsIMAPBodypart::nsIMAPBodypart(char *par</span>
<a href="#l6.177"></a><span id="l6.177">   SetIsValid(true);</span>
<a href="#l6.178"></a><span id="l6.178">   m_parentPart = parentPart;</span>
<a href="#l6.179"></a><span id="l6.179">   m_partNumberString = partNumber;	// storage adopted</span>
<a href="#l6.180"></a><span id="l6.180">   m_partData = NULL;</span>
<a href="#l6.181"></a><span id="l6.181">   m_headerData = NULL;</span>
<a href="#l6.182"></a><span id="l6.182">   m_boundaryData = NULL;	// initialize from parsed BODYSTRUCTURE</span>
<a href="#l6.183"></a><span id="l6.183">   m_contentLength = 0;</span>
<a href="#l6.184"></a><span id="l6.184">   m_partLength = 0;</span>
<a href="#l6.185"></a><span id="l6.185" class="difflineminus">-  </span>
<a href="#l6.186"></a><span id="l6.186" class="difflineplus">+</span>
<a href="#l6.187"></a><span id="l6.187">   m_contentType = NULL;</span>
<a href="#l6.188"></a><span id="l6.188">   m_bodyType = NULL;</span>
<a href="#l6.189"></a><span id="l6.189">   m_bodySubType = NULL;</span>
<a href="#l6.190"></a><span id="l6.190">   m_bodyID = NULL;</span>
<a href="#l6.191"></a><span id="l6.191">   m_bodyDescription = NULL;</span>
<a href="#l6.192"></a><span id="l6.192">   m_bodyEncoding = NULL;</span>
<a href="#l6.193"></a><span id="l6.193"> }</span>
<a href="#l6.194"></a><span id="l6.194"> </span>
<a href="#l6.195"></a><span id="l6.195" class="difflineat">@@ -354,23 +354,23 @@ void nsIMAPBodypart::AdoptHeaderDataBuff</span>
<a href="#l6.196"></a><span id="l6.196"> </span>
<a href="#l6.197"></a><span id="l6.197"> // Finds the part with given part number</span>
<a href="#l6.198"></a><span id="l6.198"> // Returns a nsIMAPBodystructure of the matched part if it is this</span>
<a href="#l6.199"></a><span id="l6.199"> // or one of its children.  Returns NULL otherwise.</span>
<a href="#l6.200"></a><span id="l6.200"> nsIMAPBodypart *nsIMAPBodypart::FindPartWithNumber(const char *partNum)</span>
<a href="#l6.201"></a><span id="l6.201"> {</span>
<a href="#l6.202"></a><span id="l6.202">   // either brute force, or do it the smart way - look at the number.</span>
<a href="#l6.203"></a><span id="l6.203">   // (the parts should be ordered, and hopefully indexed by their number)</span>
<a href="#l6.204"></a><span id="l6.204" class="difflineminus">-  </span>
<a href="#l6.205"></a><span id="l6.205" class="difflineplus">+</span>
<a href="#l6.206"></a><span id="l6.206">   if (m_partNumberString &amp;&amp; !PL_strcasecmp(partNum, m_partNumberString))</span>
<a href="#l6.207"></a><span id="l6.207">     return this;</span>
<a href="#l6.208"></a><span id="l6.208" class="difflineminus">-  </span>
<a href="#l6.209"></a><span id="l6.209" class="difflineplus">+</span>
<a href="#l6.210"></a><span id="l6.210">   //if (!m_partNumberString &amp;&amp; !PL_strcasecmp(partNum, &quot;1&quot;))</span>
<a href="#l6.211"></a><span id="l6.211">   //	return this;</span>
<a href="#l6.212"></a><span id="l6.212" class="difflineminus">-  </span>
<a href="#l6.213"></a><span id="l6.213" class="difflineplus">+</span>
<a href="#l6.214"></a><span id="l6.214">   return NULL;</span>
<a href="#l6.215"></a><span id="l6.215"> }</span>
<a href="#l6.216"></a><span id="l6.216"> </span>
<a href="#l6.217"></a><span id="l6.217"> /*</span>
<a href="#l6.218"></a><span id="l6.218"> void nsIMAPBodypart::PrefetchMIMEHeader()</span>
<a href="#l6.219"></a><span id="l6.219"> {</span>
<a href="#l6.220"></a><span id="l6.220"> if (!m_headerData &amp;&amp; !m_shell-&gt;DeathSignalReceived())</span>
<a href="#l6.221"></a><span id="l6.221"> {</span>
<a href="#l6.222"></a><span id="l6.222" class="difflineat">@@ -394,52 +394,52 @@ int32_t nsIMAPBodypart::GenerateMIMEHead</span>
<a href="#l6.223"></a><span id="l6.223">   if (prefetch &amp;&amp; !m_headerData)</span>
<a href="#l6.224"></a><span id="l6.224">   {</span>
<a href="#l6.225"></a><span id="l6.225">     QueuePrefetchMIMEHeader(aShell);</span>
<a href="#l6.226"></a><span id="l6.226">     return 0;</span>
<a href="#l6.227"></a><span id="l6.227">   }</span>
<a href="#l6.228"></a><span id="l6.228">   if (m_headerData)</span>
<a href="#l6.229"></a><span id="l6.229">   {</span>
<a href="#l6.230"></a><span id="l6.230">     int32_t mimeHeaderLength = 0;</span>
<a href="#l6.231"></a><span id="l6.231" class="difflineminus">-    </span>
<a href="#l6.232"></a><span id="l6.232" class="difflineplus">+</span>
<a href="#l6.233"></a><span id="l6.233">     if (!ShouldFetchInline(aShell))</span>
<a href="#l6.234"></a><span id="l6.234">     {</span>
<a href="#l6.235"></a><span id="l6.235">       // if this part isn't inline, add the X-Mozilla-IMAP-Part header</span>
<a href="#l6.236"></a><span id="l6.236">       char *xPartHeader = PR_smprintf(&quot;%s: %s&quot;, IMAP_EXTERNAL_CONTENT_HEADER, m_partNumberString);</span>
<a href="#l6.237"></a><span id="l6.237">       if (xPartHeader)</span>
<a href="#l6.238"></a><span id="l6.238">       {</span>
<a href="#l6.239"></a><span id="l6.239">         if (stream)</span>
<a href="#l6.240"></a><span id="l6.240">         {</span>
<a href="#l6.241"></a><span id="l6.241">           aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-XHeader&quot;,m_partNumberString);</span>
<a href="#l6.242"></a><span id="l6.242">           aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(xPartHeader, false);</span>
<a href="#l6.243"></a><span id="l6.243">         }</span>
<a href="#l6.244"></a><span id="l6.244">         mimeHeaderLength += PL_strlen(xPartHeader);</span>
<a href="#l6.245"></a><span id="l6.245">         PR_Free(xPartHeader);</span>
<a href="#l6.246"></a><span id="l6.246">       }</span>
<a href="#l6.247"></a><span id="l6.247">     }</span>
<a href="#l6.248"></a><span id="l6.248" class="difflineminus">-    </span>
<a href="#l6.249"></a><span id="l6.249" class="difflineplus">+</span>
<a href="#l6.250"></a><span id="l6.250">     mimeHeaderLength += PL_strlen(m_headerData);</span>
<a href="#l6.251"></a><span id="l6.251">     if (stream)</span>
<a href="#l6.252"></a><span id="l6.252">     {</span>
<a href="#l6.253"></a><span id="l6.253">       aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-MIMEHeader&quot;,m_partNumberString);</span>
<a href="#l6.254"></a><span id="l6.254">       aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(m_headerData, false);  // all one line?  Can we do that?</span>
<a href="#l6.255"></a><span id="l6.255">     }</span>
<a href="#l6.256"></a><span id="l6.256" class="difflineminus">-    </span>
<a href="#l6.257"></a><span id="l6.257" class="difflineplus">+</span>
<a href="#l6.258"></a><span id="l6.258">     return mimeHeaderLength;</span>
<a href="#l6.259"></a><span id="l6.259">   }</span>
<a href="#l6.260"></a><span id="l6.260"> </span>
<a href="#l6.261"></a><span id="l6.261">   SetIsValid(false);	// prefetch didn't adopt a MIME header</span>
<a href="#l6.262"></a><span id="l6.262">   return 0;</span>
<a href="#l6.263"></a><span id="l6.263"> }</span>
<a href="#l6.264"></a><span id="l6.264"> </span>
<a href="#l6.265"></a><span id="l6.265"> int32_t nsIMAPBodypart::GeneratePart(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l6.266"></a><span id="l6.266"> {</span>
<a href="#l6.267"></a><span id="l6.267">   if (prefetch)</span>
<a href="#l6.268"></a><span id="l6.268">     return 0;	// don't need to prefetch anything</span>
<a href="#l6.269"></a><span id="l6.269" class="difflineminus">-  </span>
<a href="#l6.270"></a><span id="l6.270" class="difflineplus">+</span>
<a href="#l6.271"></a><span id="l6.271">   if (m_partData)	// we have prefetched the part data</span>
<a href="#l6.272"></a><span id="l6.272">   {</span>
<a href="#l6.273"></a><span id="l6.273">     if (stream)</span>
<a href="#l6.274"></a><span id="l6.274">     {</span>
<a href="#l6.275"></a><span id="l6.275">       aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Part-Prefetched&quot;,m_partNumberString);</span>
<a href="#l6.276"></a><span id="l6.276">       aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(m_partData, false);</span>
<a href="#l6.277"></a><span id="l6.277">     }</span>
<a href="#l6.278"></a><span id="l6.278">     return PL_strlen(m_partData);</span>
<a href="#l6.279"></a><span id="l6.279" class="difflineat">@@ -456,17 +456,17 @@ int32_t nsIMAPBodypart::GeneratePart(nsI</span>
<a href="#l6.280"></a><span id="l6.280">   }</span>
<a href="#l6.281"></a><span id="l6.281">   return m_partLength;	// the part length has been filled in from the BODYSTRUCTURE response</span>
<a href="#l6.282"></a><span id="l6.282"> }</span>
<a href="#l6.283"></a><span id="l6.283"> </span>
<a href="#l6.284"></a><span id="l6.284"> int32_t nsIMAPBodypart::GenerateBoundary(nsIMAPBodyShell *aShell, bool stream, bool prefetch, bool lastBoundary)</span>
<a href="#l6.285"></a><span id="l6.285"> {</span>
<a href="#l6.286"></a><span id="l6.286">   if (prefetch)</span>
<a href="#l6.287"></a><span id="l6.287">     return 0;	// don't need to prefetch anything</span>
<a href="#l6.288"></a><span id="l6.288" class="difflineminus">-  </span>
<a href="#l6.289"></a><span id="l6.289" class="difflineplus">+</span>
<a href="#l6.290"></a><span id="l6.290">   if (m_boundaryData)</span>
<a href="#l6.291"></a><span id="l6.291">   {</span>
<a href="#l6.292"></a><span id="l6.292">     if (!lastBoundary)</span>
<a href="#l6.293"></a><span id="l6.293">     {</span>
<a href="#l6.294"></a><span id="l6.294">       if (stream)</span>
<a href="#l6.295"></a><span id="l6.295">       {</span>
<a href="#l6.296"></a><span id="l6.296">         aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Boundary&quot;,m_partNumberString);</span>
<a href="#l6.297"></a><span id="l6.297">         aShell-&gt;GetConnection()-&gt;HandleMessageDownLoadLine(m_boundaryData, false);</span>
<a href="#l6.298"></a><span id="l6.298" class="difflineat">@@ -555,34 +555,34 @@ nsIMAPBodypartLeaf::nsIMAPBodypartLeaf(c</span>
<a href="#l6.299"></a><span id="l6.299"> nsIMAPBodypartType nsIMAPBodypartLeaf::GetType()</span>
<a href="#l6.300"></a><span id="l6.300"> {</span>
<a href="#l6.301"></a><span id="l6.301">   return IMAP_BODY_LEAF;</span>
<a href="#l6.302"></a><span id="l6.302"> }</span>
<a href="#l6.303"></a><span id="l6.303"> </span>
<a href="#l6.304"></a><span id="l6.304"> int32_t nsIMAPBodypartLeaf::Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l6.305"></a><span id="l6.305"> {</span>
<a href="#l6.306"></a><span id="l6.306">   int32_t len = 0;</span>
<a href="#l6.307"></a><span id="l6.307" class="difflineminus">-  </span>
<a href="#l6.308"></a><span id="l6.308" class="difflineplus">+</span>
<a href="#l6.309"></a><span id="l6.309">   if (GetIsValid())</span>
<a href="#l6.310"></a><span id="l6.310">   {</span>
<a href="#l6.311"></a><span id="l6.311" class="difflineminus">-    </span>
<a href="#l6.312"></a><span id="l6.312" class="difflineplus">+</span>
<a href="#l6.313"></a><span id="l6.313">     if (stream &amp;&amp; !prefetch)</span>
<a href="#l6.314"></a><span id="l6.314">       aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Leaf&quot;,m_partNumberString);</span>
<a href="#l6.315"></a><span id="l6.315" class="difflineminus">-    </span>
<a href="#l6.316"></a><span id="l6.316" class="difflineplus">+</span>
<a href="#l6.317"></a><span id="l6.317">     // Stream out the MIME part boundary</span>
<a href="#l6.318"></a><span id="l6.318">     //GenerateBoundary();</span>
<a href="#l6.319"></a><span id="l6.319">     NS_ASSERTION(m_parentPart, &quot;part has no parent&quot;);</span>
<a href="#l6.320"></a><span id="l6.320">     //nsIMAPBodypartMessage *parentMessage = m_parentPart ? m_parentPart-&gt;GetnsIMAPBodypartMessage() : NULL;</span>
<a href="#l6.321"></a><span id="l6.321" class="difflineminus">-    </span>
<a href="#l6.322"></a><span id="l6.322" class="difflineplus">+</span>
<a href="#l6.323"></a><span id="l6.323">     // Stream out the MIME header of this part, if this isn't the only body part of a message</span>
<a href="#l6.324"></a><span id="l6.324">     //if (parentMessage ? !parentMessage-&gt;GetIsTopLevelMessage() : true)</span>
<a href="#l6.325"></a><span id="l6.325">     if ((m_parentPart-&gt;GetType() != IMAP_BODY_MESSAGE_RFC822)</span>
<a href="#l6.326"></a><span id="l6.326">       &amp;&amp; !aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l6.327"></a><span id="l6.327">       len += GenerateMIMEHeader(aShell, stream, prefetch);</span>
<a href="#l6.328"></a><span id="l6.328" class="difflineminus">-    </span>
<a href="#l6.329"></a><span id="l6.329" class="difflineplus">+</span>
<a href="#l6.330"></a><span id="l6.330">     if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l6.331"></a><span id="l6.331">     {</span>
<a href="#l6.332"></a><span id="l6.332">       if (ShouldFetchInline(aShell))</span>
<a href="#l6.333"></a><span id="l6.333">       {</span>
<a href="#l6.334"></a><span id="l6.334">         // Fetch and stream the content of this part</span>
<a href="#l6.335"></a><span id="l6.335">         len += GeneratePart(aShell, stream, prefetch);</span>
<a href="#l6.336"></a><span id="l6.336">       }</span>
<a href="#l6.337"></a><span id="l6.337">       else</span>
<a href="#l6.338"></a><span id="l6.338" class="difflineat">@@ -804,22 +804,22 @@ nsIMAPBodypartMessage::~nsIMAPBodypartMe</span>
<a href="#l6.339"></a><span id="l6.339">   delete m_headers;</span>
<a href="#l6.340"></a><span id="l6.340">   delete m_body;</span>
<a href="#l6.341"></a><span id="l6.341"> }</span>
<a href="#l6.342"></a><span id="l6.342"> </span>
<a href="#l6.343"></a><span id="l6.343"> int32_t nsIMAPBodypartMessage::Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l6.344"></a><span id="l6.344"> {</span>
<a href="#l6.345"></a><span id="l6.345">   if (!GetIsValid())</span>
<a href="#l6.346"></a><span id="l6.346">     return 0;</span>
<a href="#l6.347"></a><span id="l6.347" class="difflineminus">-  </span>
<a href="#l6.348"></a><span id="l6.348" class="difflineplus">+</span>
<a href="#l6.349"></a><span id="l6.349">   m_contentLength = 0;</span>
<a href="#l6.350"></a><span id="l6.350" class="difflineminus">-  </span>
<a href="#l6.351"></a><span id="l6.351" class="difflineplus">+</span>
<a href="#l6.352"></a><span id="l6.352">   if (stream &amp;&amp; !prefetch)</span>
<a href="#l6.353"></a><span id="l6.353">     aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-MessageRFC822&quot;,m_partNumberString);</span>
<a href="#l6.354"></a><span id="l6.354" class="difflineminus">-  </span>
<a href="#l6.355"></a><span id="l6.355" class="difflineplus">+</span>
<a href="#l6.356"></a><span id="l6.356">   if (!m_topLevelMessage &amp;&amp; !aShell-&gt;GetPseudoInterrupted())  // not the top-level message - we need the MIME header as well as the message header</span>
<a href="#l6.357"></a><span id="l6.357">   {</span>
<a href="#l6.358"></a><span id="l6.358">     // but we don't need the MIME headers of a message/rfc822 part if this content</span>
<a href="#l6.359"></a><span id="l6.359">     // type is in (part of) the main msg header. In other words, we still need</span>
<a href="#l6.360"></a><span id="l6.360">     // these MIME headers if this message/rfc822 body part is enclosed in the msg</span>
<a href="#l6.361"></a><span id="l6.361">     // body (most likely as a body part of a multipart/mixed msg).</span>
<a href="#l6.362"></a><span id="l6.362">     //       Don't fetch (bug 128888)              Do fetch (bug 168097)</span>
<a href="#l6.363"></a><span id="l6.363">     //  ----------------------------------  -----------------------------------</span>
<a href="#l6.364"></a><span id="l6.364" class="difflineat">@@ -830,30 +830,30 @@ int32_t nsIMAPBodypartMessage::Generate(</span>
<a href="#l6.365"></a><span id="l6.365">     //     text/plain  (attachment)             text/html   (body text)</span>
<a href="#l6.366"></a><span id="l6.366">     //     application/msword (attachment)      text/plain  (attachment)</span>
<a href="#l6.367"></a><span id="l6.367">     //                                          application/msword (attachment)</span>
<a href="#l6.368"></a><span id="l6.368">     // &quot;&lt;&lt;&lt;---&quot; points to the part we're examining here.</span>
<a href="#l6.369"></a><span id="l6.369">     if ( PL_strcasecmp(m_bodyType, &quot;message&quot;) || PL_strcasecmp(m_bodySubType, &quot;rfc822&quot;) ||</span>
<a href="#l6.370"></a><span id="l6.370">       PL_strcasecmp(m_parentPart-&gt;GetBodyType(), &quot;message&quot;) || PL_strcasecmp(m_parentPart-&gt;GetBodySubType(), &quot;rfc822&quot;) )</span>
<a href="#l6.371"></a><span id="l6.371">       m_contentLength += GenerateMIMEHeader(aShell, stream, prefetch);</span>
<a href="#l6.372"></a><span id="l6.372">   }</span>
<a href="#l6.373"></a><span id="l6.373" class="difflineminus">-  </span>
<a href="#l6.374"></a><span id="l6.374" class="difflineplus">+</span>
<a href="#l6.375"></a><span id="l6.375">   if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l6.376"></a><span id="l6.376">     m_contentLength += m_headers-&gt;Generate(aShell, stream, prefetch);</span>
<a href="#l6.377"></a><span id="l6.377">   if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l6.378"></a><span id="l6.378">     m_contentLength += m_body-&gt;Generate(aShell, stream, prefetch);</span>
<a href="#l6.379"></a><span id="l6.379" class="difflineminus">-  </span>
<a href="#l6.380"></a><span id="l6.380" class="difflineplus">+</span>
<a href="#l6.381"></a><span id="l6.381">   return m_contentLength;</span>
<a href="#l6.382"></a><span id="l6.382"> }</span>
<a href="#l6.383"></a><span id="l6.383"> </span>
<a href="#l6.384"></a><span id="l6.384"> bool nsIMAPBodypartMessage::ShouldFetchInline(nsIMAPBodyShell *aShell)</span>
<a href="#l6.385"></a><span id="l6.385"> {</span>
<a href="#l6.386"></a><span id="l6.386">   if (m_topLevelMessage)	// the main message should always be defined as &quot;inline&quot;</span>
<a href="#l6.387"></a><span id="l6.387">     return true;</span>
<a href="#l6.388"></a><span id="l6.388" class="difflineminus">-  </span>
<a href="#l6.389"></a><span id="l6.389" class="difflineplus">+</span>
<a href="#l6.390"></a><span id="l6.390">   char *generatingPart = aShell-&gt;GetGeneratingPart();</span>
<a href="#l6.391"></a><span id="l6.391">   if (generatingPart)</span>
<a href="#l6.392"></a><span id="l6.392">   {</span>
<a href="#l6.393"></a><span id="l6.393">     // If we are generating a specific part</span>
<a href="#l6.394"></a><span id="l6.394">     // Always generate containers (just don't fill them in)</span>
<a href="#l6.395"></a><span id="l6.395">     // because it is low cost (everything is cached)</span>
<a href="#l6.396"></a><span id="l6.396">     // and it gives the message its full MIME structure,</span>
<a href="#l6.397"></a><span id="l6.397">     // to avoid any potential mishap.</span>
<a href="#l6.398"></a><span id="l6.398" class="difflineat">@@ -870,50 +870,50 @@ bool nsIMAPBodypartMessage::ShouldFetchI</span>
<a href="#l6.399"></a><span id="l6.399">   return true;</span>
<a href="#l6.400"></a><span id="l6.400"> </span>
<a href="#l6.401"></a><span id="l6.401"> }</span>
<a href="#l6.402"></a><span id="l6.402"> </span>
<a href="#l6.403"></a><span id="l6.403"> bool nsIMAPBodypartMessage::PreflightCheckAllInline(nsIMAPBodyShell *aShell)</span>
<a href="#l6.404"></a><span id="l6.404"> {</span>
<a href="#l6.405"></a><span id="l6.405">   if (!ShouldFetchInline(aShell))</span>
<a href="#l6.406"></a><span id="l6.406">     return false;</span>
<a href="#l6.407"></a><span id="l6.407" class="difflineminus">-  </span>
<a href="#l6.408"></a><span id="l6.408" class="difflineplus">+</span>
<a href="#l6.409"></a><span id="l6.409">   return m_body-&gt;PreflightCheckAllInline(aShell);</span>
<a href="#l6.410"></a><span id="l6.410"> }</span>
<a href="#l6.411"></a><span id="l6.411"> </span>
<a href="#l6.412"></a><span id="l6.412"> // Fills in buffer (and adopts storage) for header object</span>
<a href="#l6.413"></a><span id="l6.413"> void nsIMAPBodypartMessage::AdoptMessageHeaders(char *headers)</span>
<a href="#l6.414"></a><span id="l6.414"> {</span>
<a href="#l6.415"></a><span id="l6.415">   if (!GetIsValid())</span>
<a href="#l6.416"></a><span id="l6.416">     return;</span>
<a href="#l6.417"></a><span id="l6.417" class="difflineminus">-  </span>
<a href="#l6.418"></a><span id="l6.418" class="difflineplus">+</span>
<a href="#l6.419"></a><span id="l6.419">   // we are going to say that the message headers only have</span>
<a href="#l6.420"></a><span id="l6.420">   // part data, and no header data.</span>
<a href="#l6.421"></a><span id="l6.421">   m_headers-&gt;AdoptPartDataBuffer(headers);</span>
<a href="#l6.422"></a><span id="l6.422">   if (!m_headers-&gt;GetIsValid())</span>
<a href="#l6.423"></a><span id="l6.423">     SetIsValid(false);</span>
<a href="#l6.424"></a><span id="l6.424"> }</span>
<a href="#l6.425"></a><span id="l6.425"> </span>
<a href="#l6.426"></a><span id="l6.426"> // Finds the part with given part number</span>
<a href="#l6.427"></a><span id="l6.427"> // Returns a nsIMAPBodystructure of the matched part if it is this</span>
<a href="#l6.428"></a><span id="l6.428"> // or one of its children.  Returns NULL otherwise.</span>
<a href="#l6.429"></a><span id="l6.429"> nsIMAPBodypart *nsIMAPBodypartMessage::FindPartWithNumber(const char *partNum)</span>
<a href="#l6.430"></a><span id="l6.430"> {</span>
<a href="#l6.431"></a><span id="l6.431">   // either brute force, or do it the smart way - look at the number.</span>
<a href="#l6.432"></a><span id="l6.432">   // (the parts should be ordered, and hopefully indexed by their number)</span>
<a href="#l6.433"></a><span id="l6.433" class="difflineminus">-  </span>
<a href="#l6.434"></a><span id="l6.434" class="difflineplus">+</span>
<a href="#l6.435"></a><span id="l6.435">   if (!PL_strcasecmp(partNum, m_partNumberString))</span>
<a href="#l6.436"></a><span id="l6.436">     return this;</span>
<a href="#l6.437"></a><span id="l6.437" class="difflineminus">-  </span>
<a href="#l6.438"></a><span id="l6.438" class="difflineplus">+</span>
<a href="#l6.439"></a><span id="l6.439">   return m_body-&gt;FindPartWithNumber(partNum);</span>
<a href="#l6.440"></a><span id="l6.440"> }</span>
<a href="#l6.441"></a><span id="l6.441"> </span>
<a href="#l6.442"></a><span id="l6.442"> ///////////// nsIMAPBodypartMultipart ////////////////////////</span>
<a href="#l6.443"></a><span id="l6.443"> </span>
<a href="#l6.444"></a><span id="l6.444" class="difflineminus">-nsIMAPBodypartMultipart::nsIMAPBodypartMultipart(char *partNum, nsIMAPBodypart *parentPart) : </span>
<a href="#l6.445"></a><span id="l6.445" class="difflineplus">+nsIMAPBodypartMultipart::nsIMAPBodypartMultipart(char *partNum, nsIMAPBodypart *parentPart) :</span>
<a href="#l6.446"></a><span id="l6.446"> nsIMAPBodypart(partNum, parentPart)</span>
<a href="#l6.447"></a><span id="l6.447"> {</span>
<a href="#l6.448"></a><span id="l6.448">   if (!m_parentPart  || (m_parentPart-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822))</span>
<a href="#l6.449"></a><span id="l6.449">   {</span>
<a href="#l6.450"></a><span id="l6.450">     // the multipart (this) will inherit the part number of its parent</span>
<a href="#l6.451"></a><span id="l6.451">     PR_FREEIF(m_partNumberString);</span>
<a href="#l6.452"></a><span id="l6.452">     if (!m_parentPart)</span>
<a href="#l6.453"></a><span id="l6.453">     {</span>
<a href="#l6.454"></a><span id="l6.454" class="difflineat">@@ -952,34 +952,34 @@ nsIMAPBodypartMultipart::SetBodySubType(</span>
<a href="#l6.455"></a><span id="l6.455">   m_bodySubType = bodySubType;</span>
<a href="#l6.456"></a><span id="l6.456">   if (m_bodyType &amp;&amp; m_bodySubType)</span>
<a href="#l6.457"></a><span id="l6.457">     m_contentType = PR_smprintf(&quot;%s/%s&quot;, m_bodyType, m_bodySubType);</span>
<a href="#l6.458"></a><span id="l6.458"> }</span>
<a href="#l6.459"></a><span id="l6.459"> </span>
<a href="#l6.460"></a><span id="l6.460"> int32_t nsIMAPBodypartMultipart::Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l6.461"></a><span id="l6.461"> {</span>
<a href="#l6.462"></a><span id="l6.462">   int32_t len = 0;</span>
<a href="#l6.463"></a><span id="l6.463" class="difflineminus">-  </span>
<a href="#l6.464"></a><span id="l6.464" class="difflineplus">+</span>
<a href="#l6.465"></a><span id="l6.465">   if (GetIsValid())</span>
<a href="#l6.466"></a><span id="l6.466">   {</span>
<a href="#l6.467"></a><span id="l6.467">     if (stream &amp;&amp; !prefetch)</span>
<a href="#l6.468"></a><span id="l6.468">       aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-Multipart&quot;,m_partNumberString);</span>
<a href="#l6.469"></a><span id="l6.469" class="difflineminus">-    </span>
<a href="#l6.470"></a><span id="l6.470" class="difflineplus">+</span>
<a href="#l6.471"></a><span id="l6.471">     // Stream out the MIME header of this part</span>
<a href="#l6.472"></a><span id="l6.472" class="difflineminus">-    </span>
<a href="#l6.473"></a><span id="l6.473" class="difflineplus">+</span>
<a href="#l6.474"></a><span id="l6.474">     bool parentIsMessageType = GetParentPart() ? (GetParentPart()-&gt;GetType() == IMAP_BODY_MESSAGE_RFC822) : true;</span>
<a href="#l6.475"></a><span id="l6.475" class="difflineminus">-    </span>
<a href="#l6.476"></a><span id="l6.476" class="difflineplus">+</span>
<a href="#l6.477"></a><span id="l6.477">     // If this is multipart/signed, then we always want to generate the MIME headers of this multipart.</span>
<a href="#l6.478"></a><span id="l6.478">     // Otherwise, we only want to do it if the parent is not of type &quot;message&quot;</span>
<a href="#l6.479"></a><span id="l6.479">     bool needMIMEHeader = !parentIsMessageType;  // !PL_strcasecmp(m_bodySubType, &quot;signed&quot;) ? true : !parentIsMessageType;</span>
<a href="#l6.480"></a><span id="l6.480">     if (needMIMEHeader &amp;&amp; !aShell-&gt;GetPseudoInterrupted())  // not a message body's type</span>
<a href="#l6.481"></a><span id="l6.481">     {</span>
<a href="#l6.482"></a><span id="l6.482">       len += GenerateMIMEHeader(aShell, stream, prefetch);</span>
<a href="#l6.483"></a><span id="l6.483">     }</span>
<a href="#l6.484"></a><span id="l6.484" class="difflineminus">-    </span>
<a href="#l6.485"></a><span id="l6.485" class="difflineplus">+</span>
<a href="#l6.486"></a><span id="l6.486">     if (ShouldFetchInline(aShell))</span>
<a href="#l6.487"></a><span id="l6.487">     {</span>
<a href="#l6.488"></a><span id="l6.488">       for (size_t i = 0; i &lt; m_partList-&gt;Length(); i++)</span>
<a href="#l6.489"></a><span id="l6.489">       {</span>
<a href="#l6.490"></a><span id="l6.490">         if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l6.491"></a><span id="l6.491">           len += GenerateBoundary(aShell, stream, prefetch, false);</span>
<a href="#l6.492"></a><span id="l6.492">         if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l6.493"></a><span id="l6.493">           len += m_partList-&gt;ElementAt(i)-&gt;Generate(aShell, stream, prefetch);</span>
<a href="#l6.494"></a><span id="l6.494" class="difflineat">@@ -1040,51 +1040,51 @@ bool nsIMAPBodypartMultipart::ShouldFetc</span>
<a href="#l6.495"></a><span id="l6.495">   // multiparts are always inline (even multipart/appledouble)</span>
<a href="#l6.496"></a><span id="l6.496">   // (their children might not be, though)</span>
<a href="#l6.497"></a><span id="l6.497">   return true;</span>
<a href="#l6.498"></a><span id="l6.498"> }</span>
<a href="#l6.499"></a><span id="l6.499"> </span>
<a href="#l6.500"></a><span id="l6.500"> bool nsIMAPBodypartMultipart::PreflightCheckAllInline(nsIMAPBodyShell *aShell)</span>
<a href="#l6.501"></a><span id="l6.501"> {</span>
<a href="#l6.502"></a><span id="l6.502">   bool rv = ShouldFetchInline(aShell);</span>
<a href="#l6.503"></a><span id="l6.503" class="difflineminus">-  </span>
<a href="#l6.504"></a><span id="l6.504" class="difflineplus">+</span>
<a href="#l6.505"></a><span id="l6.505">   size_t i = 0;</span>
<a href="#l6.506"></a><span id="l6.506">   while (rv &amp;&amp; (i &lt; m_partList-&gt;Length()))</span>
<a href="#l6.507"></a><span id="l6.507">   {</span>
<a href="#l6.508"></a><span id="l6.508">     rv = m_partList-&gt;ElementAt(i)-&gt;PreflightCheckAllInline(aShell);</span>
<a href="#l6.509"></a><span id="l6.509">     i++;</span>
<a href="#l6.510"></a><span id="l6.510">   }</span>
<a href="#l6.511"></a><span id="l6.511" class="difflineminus">-  </span>
<a href="#l6.512"></a><span id="l6.512" class="difflineplus">+</span>
<a href="#l6.513"></a><span id="l6.513">   return rv;</span>
<a href="#l6.514"></a><span id="l6.514"> }</span>
<a href="#l6.515"></a><span id="l6.515"> </span>
<a href="#l6.516"></a><span id="l6.516"> nsIMAPBodypart	*nsIMAPBodypartMultipart::FindPartWithNumber(const char *partNum)</span>
<a href="#l6.517"></a><span id="l6.517"> {</span>
<a href="#l6.518"></a><span id="l6.518">   NS_ASSERTION(partNum, &quot;null part passed into FindPartWithNumber&quot;);</span>
<a href="#l6.519"></a><span id="l6.519" class="difflineminus">-  </span>
<a href="#l6.520"></a><span id="l6.520" class="difflineplus">+</span>
<a href="#l6.521"></a><span id="l6.521">   // check this</span>
<a href="#l6.522"></a><span id="l6.522">   if (!PL_strcmp(partNum, m_partNumberString))</span>
<a href="#l6.523"></a><span id="l6.523">     return this;</span>
<a href="#l6.524"></a><span id="l6.524" class="difflineminus">-  </span>
<a href="#l6.525"></a><span id="l6.525" class="difflineplus">+</span>
<a href="#l6.526"></a><span id="l6.526">   // check children</span>
<a href="#l6.527"></a><span id="l6.527">   for (int i = m_partList-&gt;Length() - 1; i &gt;= 0; i--)</span>
<a href="#l6.528"></a><span id="l6.528">   {</span>
<a href="#l6.529"></a><span id="l6.529">     nsIMAPBodypart *foundPart = m_partList-&gt;ElementAt(i)-&gt;FindPartWithNumber(partNum);</span>
<a href="#l6.530"></a><span id="l6.530">     if (foundPart)</span>
<a href="#l6.531"></a><span id="l6.531">       return foundPart;</span>
<a href="#l6.532"></a><span id="l6.532">   }</span>
<a href="#l6.533"></a><span id="l6.533" class="difflineminus">-  </span>
<a href="#l6.534"></a><span id="l6.534" class="difflineplus">+</span>
<a href="#l6.535"></a><span id="l6.535">   // not this, or any of this's children</span>
<a href="#l6.536"></a><span id="l6.536">   return NULL;</span>
<a href="#l6.537"></a><span id="l6.537"> }</span>
<a href="#l6.538"></a><span id="l6.538"> </span>
<a href="#l6.539"></a><span id="l6.539"> </span>
<a href="#l6.540"></a><span id="l6.540"> ///////////// nsIMAPMessageHeaders ////////////////////////////////////</span>
<a href="#l6.541"></a><span id="l6.541"> </span>
<a href="#l6.542"></a><span id="l6.542" class="difflineminus">-nsIMAPMessageHeaders::nsIMAPMessageHeaders(char *partNum, nsIMAPBodypart *parentPart) : </span>
<a href="#l6.543"></a><span id="l6.543" class="difflineplus">+nsIMAPMessageHeaders::nsIMAPMessageHeaders(char *partNum, nsIMAPBodypart *parentPart) :</span>
<a href="#l6.544"></a><span id="l6.544"> nsIMAPBodypart(partNum, parentPart)</span>
<a href="#l6.545"></a><span id="l6.545"> {</span>
<a href="#l6.546"></a><span id="l6.546">   if (!partNum)</span>
<a href="#l6.547"></a><span id="l6.547">   {</span>
<a href="#l6.548"></a><span id="l6.548">     SetIsValid(false);</span>
<a href="#l6.549"></a><span id="l6.549">     return;</span>
<a href="#l6.550"></a><span id="l6.550">   }</span>
<a href="#l6.551"></a><span id="l6.551">   m_partNumberString = NS_strdup(partNum);</span>
<a href="#l6.552"></a><span id="l6.552" class="difflineat">@@ -1103,34 +1103,34 @@ nsIMAPBodypart(partNum, parentPart)</span>
<a href="#l6.553"></a><span id="l6.553"> </span>
<a href="#l6.554"></a><span id="l6.554"> nsIMAPBodypartType nsIMAPMessageHeaders::GetType()</span>
<a href="#l6.555"></a><span id="l6.555"> {</span>
<a href="#l6.556"></a><span id="l6.556">   return IMAP_BODY_MESSAGE_HEADER;</span>
<a href="#l6.557"></a><span id="l6.557"> }</span>
<a href="#l6.558"></a><span id="l6.558"> </span>
<a href="#l6.559"></a><span id="l6.559"> void nsIMAPMessageHeaders::QueuePrefetchMessageHeaders(nsIMAPBodyShell *aShell)</span>
<a href="#l6.560"></a><span id="l6.560"> {</span>
<a href="#l6.561"></a><span id="l6.561" class="difflineminus">-  </span>
<a href="#l6.562"></a><span id="l6.562" class="difflineplus">+</span>
<a href="#l6.563"></a><span id="l6.563">   if (!m_parentPart-&gt;GetnsIMAPBodypartMessage()-&gt;GetIsTopLevelMessage())	// not top-level headers</span>
<a href="#l6.564"></a><span id="l6.564">     aShell-&gt;AddPrefetchToQueue(kRFC822HeadersOnly, m_partNumberString);</span>
<a href="#l6.565"></a><span id="l6.565">   else</span>
<a href="#l6.566"></a><span id="l6.566">     aShell-&gt;AddPrefetchToQueue(kRFC822HeadersOnly, NULL);</span>
<a href="#l6.567"></a><span id="l6.567"> }</span>
<a href="#l6.568"></a><span id="l6.568"> </span>
<a href="#l6.569"></a><span id="l6.569"> int32_t nsIMAPMessageHeaders::Generate(nsIMAPBodyShell *aShell, bool stream, bool prefetch)</span>
<a href="#l6.570"></a><span id="l6.570"> {</span>
<a href="#l6.571"></a><span id="l6.571">   // prefetch the header</span>
<a href="#l6.572"></a><span id="l6.572">   if (prefetch &amp;&amp; !m_partData &amp;&amp; !aShell-&gt;DeathSignalReceived())</span>
<a href="#l6.573"></a><span id="l6.573">   {</span>
<a href="#l6.574"></a><span id="l6.574">     QueuePrefetchMessageHeaders(aShell);</span>
<a href="#l6.575"></a><span id="l6.575">   }</span>
<a href="#l6.576"></a><span id="l6.576" class="difflineminus">-  </span>
<a href="#l6.577"></a><span id="l6.577" class="difflineplus">+</span>
<a href="#l6.578"></a><span id="l6.578">   if (stream &amp;&amp; !prefetch)</span>
<a href="#l6.579"></a><span id="l6.579">     aShell-&gt;GetConnection()-&gt;Log(&quot;SHELL&quot;,&quot;GENERATE-MessageHeaders&quot;,m_partNumberString);</span>
<a href="#l6.580"></a><span id="l6.580" class="difflineminus">-  </span>
<a href="#l6.581"></a><span id="l6.581" class="difflineplus">+</span>
<a href="#l6.582"></a><span id="l6.582">   // stream out the part data</span>
<a href="#l6.583"></a><span id="l6.583">   if (ShouldFetchInline(aShell))</span>
<a href="#l6.584"></a><span id="l6.584">   {</span>
<a href="#l6.585"></a><span id="l6.585">     if (!aShell-&gt;GetPseudoInterrupted())</span>
<a href="#l6.586"></a><span id="l6.586">       m_contentLength = GeneratePart(aShell, stream, prefetch);</span>
<a href="#l6.587"></a><span id="l6.587">   }</span>
<a href="#l6.588"></a><span id="l6.588">   else</span>
<a href="#l6.589"></a><span id="l6.589">   {</span>
<a href="#l6.590"></a><span id="l6.590" class="difflineat">@@ -1161,17 +1161,17 @@ nsIMAPBodyShellCache::nsIMAPBodyShellCac</span>
<a href="#l6.591"></a><span id="l6.591">   m_shellList = new nsTArray&lt;nsIMAPBodyShell*&gt;();</span>
<a href="#l6.592"></a><span id="l6.592"> }</span>
<a href="#l6.593"></a><span id="l6.593"> </span>
<a href="#l6.594"></a><span id="l6.594"> /* static */ nsIMAPBodyShellCache *nsIMAPBodyShellCache::Create()</span>
<a href="#l6.595"></a><span id="l6.595"> {</span>
<a href="#l6.596"></a><span id="l6.596">   nsIMAPBodyShellCache *cache = new nsIMAPBodyShellCache();</span>
<a href="#l6.597"></a><span id="l6.597">   if (!cache || !cache-&gt;m_shellList)</span>
<a href="#l6.598"></a><span id="l6.598">     return NULL;</span>
<a href="#l6.599"></a><span id="l6.599" class="difflineminus">-  </span>
<a href="#l6.600"></a><span id="l6.600" class="difflineplus">+</span>
<a href="#l6.601"></a><span id="l6.601">   return cache;</span>
<a href="#l6.602"></a><span id="l6.602"> }</span>
<a href="#l6.603"></a><span id="l6.603"> </span>
<a href="#l6.604"></a><span id="l6.604"> nsIMAPBodyShellCache::~nsIMAPBodyShellCache()</span>
<a href="#l6.605"></a><span id="l6.605"> {</span>
<a href="#l6.606"></a><span id="l6.606">   while (EjectEntry()) ;</span>
<a href="#l6.607"></a><span id="l6.607">   delete m_shellList;</span>
<a href="#l6.608"></a><span id="l6.608"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPBodyShell.h</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPBodyShell.h</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l7.4"></a><span id="l7.4"> /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l7.5"></a><span id="l7.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l7.6"></a><span id="l7.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l7.7"></a><span id="l7.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l7.8"></a><span id="l7.8"> </span>
<a href="#l7.9"></a><span id="l7.9" class="difflineminus">-/* </span>
<a href="#l7.10"></a><span id="l7.10" class="difflineplus">+/*</span>
<a href="#l7.11"></a><span id="l7.11"> nsIMAPBodyShell and associated classes</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-*/ </span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+*/</span>
<a href="#l7.14"></a><span id="l7.14"> </span>
<a href="#l7.15"></a><span id="l7.15"> #ifndef IMAPBODY_H</span>
<a href="#l7.16"></a><span id="l7.16"> #define IMAPBODY_H</span>
<a href="#l7.17"></a><span id="l7.17"> </span>
<a href="#l7.18"></a><span id="l7.18"> #include &quot;mozilla/Attributes.h&quot;</span>
<a href="#l7.19"></a><span id="l7.19"> #include &quot;nsImapCore.h&quot;</span>
<a href="#l7.20"></a><span id="l7.20"> #include &quot;nsString.h&quot;</span>
<a href="#l7.21"></a><span id="l7.21"> #include &quot;nsRefPtrHashtable.h&quot;</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineat">@@ -48,17 +48,17 @@ public:</span>
<a href="#l7.23"></a><span id="l7.23"> 	virtual bool ShouldExplicitlyNotFetchInline();</span>
<a href="#l7.24"></a><span id="l7.24">         virtual bool IsLastTextPart(const char *partNumberString) {return true;}</span>
<a href="#l7.25"></a><span id="l7.25"> </span>
<a href="#l7.26"></a><span id="l7.26"> protected:</span>
<a href="#l7.27"></a><span id="l7.27">     // If stream is false, simply returns the content length that will be generated</span>
<a href="#l7.28"></a><span id="l7.28">     // the body of the part itself</span>
<a href="#l7.29"></a><span id="l7.29">     virtual int32_t GeneratePart(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l7.30"></a><span id="l7.30">     // the MIME headers of the part</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-    virtual int32_t GenerateMIMEHeader(nsIMAPBodyShell *aShell, bool stream, bool prefetch); </span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+    virtual int32_t GenerateMIMEHeader(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l7.33"></a><span id="l7.33">     // Generates the MIME boundary wrapper for this part.</span>
<a href="#l7.34"></a><span id="l7.34">     virtual int32_t GenerateBoundary(nsIMAPBodyShell *aShell, bool stream, bool prefetch, bool lastBoundary);</span>
<a href="#l7.35"></a><span id="l7.35">     // lastBoundary indicates whether or not this should be the boundary for the</span>
<a href="#l7.36"></a><span id="l7.36">     // final MIME part of the multipart message.</span>
<a href="#l7.37"></a><span id="l7.37">     // Generates (possibly empty) filling for a part that won't be filled in inline.</span>
<a href="#l7.38"></a><span id="l7.38">     virtual int32_t GenerateEmptyFilling(nsIMAPBodyShell *aShell, bool stream, bool prefetch);</span>
<a href="#l7.39"></a><span id="l7.39"> </span>
<a href="#l7.40"></a><span id="l7.40"> 	// Part Numbers / Hierarchy</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineat">@@ -274,24 +274,24 @@ protected:</span>
<a href="#l7.42"></a><span id="l7.42">   nsIMAPMessagePartIDArray        *m_prefetchQueue; // array of pipelined part prefetches.  Ok, so it's not really a queue.</span>
<a href="#l7.43"></a><span id="l7.43"> </span>
<a href="#l7.44"></a><span id="l7.44">   bool                            m_isValid;</span>
<a href="#l7.45"></a><span id="l7.45">   nsImapProtocol                  *m_protocolConnection;  // Connection, for filling in parts</span>
<a href="#l7.46"></a><span id="l7.46">   nsCString                       m_UID;                  // UID of this message</span>
<a href="#l7.47"></a><span id="l7.47">   char                            *m_folderName;          // folder that contains this message</span>
<a href="#l7.48"></a><span id="l7.48">   char                            *m_generatingPart;      // If a specific part is being generated, this is it.  Otherwise, NULL.</span>
<a href="#l7.49"></a><span id="l7.49">   bool                            m_isBeingGenerated;     // true if this body shell is in the process of being generated</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineminus">-  bool                            m_gotAttachmentPref;    // Whether or not m_showAttachmentsInline has been initialized </span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+  bool                            m_gotAttachmentPref;    // Whether or not m_showAttachmentsInline has been initialized</span>
<a href="#l7.52"></a><span id="l7.52">   bool                            m_showAttachmentsInline; // Whether or not we should display attachment inline</span>
<a href="#l7.53"></a><span id="l7.53">   bool                            m_cached;                 // Whether or not this shell is cached</span>
<a href="#l7.54"></a><span id="l7.54">   bool                            m_generatingWholeMessage; // whether or not we are generating the whole (non-MPOD) message</span>
<a href="#l7.55"></a><span id="l7.55">                                                           // Set to false if we are generating by parts</span>
<a href="#l7.56"></a><span id="l7.56">   // under what conditions the content has been modified.</span>
<a href="#l7.57"></a><span id="l7.57">   // Either IMAP_CONTENT_MODIFIED_VIEW_INLINE or IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS</span>
<a href="#l7.58"></a><span id="l7.58" class="difflineminus">-  IMAP_ContentModifiedType        m_contentModified; </span>
<a href="#l7.59"></a><span id="l7.59" class="difflineplus">+  IMAP_ContentModifiedType        m_contentModified;</span>
<a href="#l7.60"></a><span id="l7.60"> };</span>
<a href="#l7.61"></a><span id="l7.61"> </span>
<a href="#l7.62"></a><span id="l7.62"> </span>
<a href="#l7.63"></a><span id="l7.63"> </span>
<a href="#l7.64"></a><span id="l7.64"> // This class caches shells, so we don't have to always go and re-fetch them.</span>
<a href="#l7.65"></a><span id="l7.65"> // This does not cache any of the filled-in inline parts;  those are cached individually</span>
<a href="#l7.66"></a><span id="l7.66"> // in the libnet memory cache.  (ugh, how will we do that?)</span>
<a href="#l7.67"></a><span id="l7.67"> // Since we'll only be retrieving shells for messages over a given size, and since the</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPGenericParser.cpp</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPGenericParser.cpp</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -34,17 +34,17 @@ void nsIMAPGenericParser::HandleMemoryFa</span>
<a href="#l8.4"></a><span id="l8.4"> {</span>
<a href="#l8.5"></a><span id="l8.5">   SetConnected(false);</span>
<a href="#l8.6"></a><span id="l8.6"> }</span>
<a href="#l8.7"></a><span id="l8.7"> </span>
<a href="#l8.8"></a><span id="l8.8"> void nsIMAPGenericParser::ResetLexAnalyzer()</span>
<a href="#l8.9"></a><span id="l8.9"> {</span>
<a href="#l8.10"></a><span id="l8.10">   PR_FREEIF( fCurrentLine );</span>
<a href="#l8.11"></a><span id="l8.11">   PR_FREEIF( fStartOfLineOfTokens );</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  </span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+</span>
<a href="#l8.14"></a><span id="l8.14">   fNextToken = fCurrentLine = fLineOfTokens = fStartOfLineOfTokens = fCurrentTokenPlaceHolder = nullptr;</span>
<a href="#l8.15"></a><span id="l8.15">   fAtEndOfLine = false;</span>
<a href="#l8.16"></a><span id="l8.16"> }</span>
<a href="#l8.17"></a><span id="l8.17"> </span>
<a href="#l8.18"></a><span id="l8.18"> bool nsIMAPGenericParser::LastCommandSuccessful()</span>
<a href="#l8.19"></a><span id="l8.19"> {</span>
<a href="#l8.20"></a><span id="l8.20">   return fParserState == stateOK;</span>
<a href="#l8.21"></a><span id="l8.21"> }</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineat">@@ -96,17 +96,17 @@ void nsIMAPGenericParser::skip_to_close_</span>
<a href="#l8.23"></a><span id="l8.23">         {</span>
<a href="#l8.24"></a><span id="l8.24">           fNextToken = loc + 1;</span>
<a href="#l8.25"></a><span id="l8.25">           if (!fNextToken || !*fNextToken)</span>
<a href="#l8.26"></a><span id="l8.26">             AdvanceToNextToken();</span>
<a href="#l8.27"></a><span id="l8.27">           return;</span>
<a href="#l8.28"></a><span id="l8.28">         }</span>
<a href="#l8.29"></a><span id="l8.29">       }</span>
<a href="#l8.30"></a><span id="l8.30">       else if (*loc == '{' || *loc == '&quot;') {</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineminus">-        // quoted or literal  </span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+        // quoted or literal</span>
<a href="#l8.33"></a><span id="l8.33">         fNextToken = loc;</span>
<a href="#l8.34"></a><span id="l8.34">         char *a = CreateString();</span>
<a href="#l8.35"></a><span id="l8.35">         PR_FREEIF(a);</span>
<a href="#l8.36"></a><span id="l8.36">         break; // move to next token</span>
<a href="#l8.37"></a><span id="l8.37">       }</span>
<a href="#l8.38"></a><span id="l8.38">     }</span>
<a href="#l8.39"></a><span id="l8.39">     if (ContinueParse())</span>
<a href="#l8.40"></a><span id="l8.40">       AdvanceToNextToken();</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineat">@@ -139,17 +139,17 @@ void nsIMAPGenericParser::AdvanceToNextT</span>
<a href="#l8.42"></a><span id="l8.42">     }</span>
<a href="#l8.43"></a><span id="l8.43">   }</span>
<a href="#l8.44"></a><span id="l8.44"> }</span>
<a href="#l8.45"></a><span id="l8.45"> </span>
<a href="#l8.46"></a><span id="l8.46"> void nsIMAPGenericParser::AdvanceToNextLine()</span>
<a href="#l8.47"></a><span id="l8.47"> {</span>
<a href="#l8.48"></a><span id="l8.48">   PR_FREEIF( fCurrentLine );</span>
<a href="#l8.49"></a><span id="l8.49">   PR_FREEIF( fStartOfLineOfTokens);</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineminus">-  </span>
<a href="#l8.51"></a><span id="l8.51" class="difflineplus">+</span>
<a href="#l8.52"></a><span id="l8.52">   bool ok = GetNextLineForParser(&amp;fCurrentLine);</span>
<a href="#l8.53"></a><span id="l8.53">   if (!ok)</span>
<a href="#l8.54"></a><span id="l8.54">   {</span>
<a href="#l8.55"></a><span id="l8.55">     SetConnected(false);</span>
<a href="#l8.56"></a><span id="l8.56">     fStartOfLineOfTokens = nullptr;</span>
<a href="#l8.57"></a><span id="l8.57">     fLineOfTokens = nullptr;</span>
<a href="#l8.58"></a><span id="l8.58">     fCurrentTokenPlaceHolder = nullptr;</span>
<a href="#l8.59"></a><span id="l8.59">     fAtEndOfLine = true;</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineat">@@ -178,17 +178,17 @@ void nsIMAPGenericParser::AdvanceTokeniz</span>
<a href="#l8.61"></a><span id="l8.61"> {</span>
<a href="#l8.62"></a><span id="l8.62">   NS_PRECONDITION(bytesToAdvance&gt;=0, &quot;bytesToAdvance must not be negative&quot;);</span>
<a href="#l8.63"></a><span id="l8.63">   if (!fStartOfLineOfTokens)</span>
<a href="#l8.64"></a><span id="l8.64">   {</span>
<a href="#l8.65"></a><span id="l8.65">     AdvanceToNextToken();  // the tokenizer was not yet initialized, do it now</span>
<a href="#l8.66"></a><span id="l8.66">     if (!fStartOfLineOfTokens)</span>
<a href="#l8.67"></a><span id="l8.67">       return;</span>
<a href="#l8.68"></a><span id="l8.68">   }</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineminus">-    </span>
<a href="#l8.70"></a><span id="l8.70" class="difflineplus">+</span>
<a href="#l8.71"></a><span id="l8.71">   if(!fStartOfLineOfTokens)</span>
<a href="#l8.72"></a><span id="l8.72">       return;</span>
<a href="#l8.73"></a><span id="l8.73">   // The last call to AdvanceToNextToken() cleared the token separator to '\0'</span>
<a href="#l8.74"></a><span id="l8.74">   // iff |fCurrentTokenPlaceHolder|.  We must recover this token separator now.</span>
<a href="#l8.75"></a><span id="l8.75">   if (fCurrentTokenPlaceHolder)</span>
<a href="#l8.76"></a><span id="l8.76">   {</span>
<a href="#l8.77"></a><span id="l8.77">     int endTokenOffset = fCurrentTokenPlaceHolder - fStartOfLineOfTokens - 1;</span>
<a href="#l8.78"></a><span id="l8.78">     if (endTokenOffset &gt;= 0)</span>
<a href="#l8.79"></a><span id="l8.79" class="difflineat">@@ -244,17 +244,17 @@ char *nsIMAPGenericParser::CreateAtom(bo</span>
<a href="#l8.80"></a><span id="l8.80">      c = *++last;</span>
<a href="#l8.81"></a><span id="l8.81">   if (rv == last) {</span>
<a href="#l8.82"></a><span id="l8.82">      SetSyntaxError(true, &quot;no atom characters found&quot;);</span>
<a href="#l8.83"></a><span id="l8.83">      PL_strfree(rv);</span>
<a href="#l8.84"></a><span id="l8.84">      return nullptr;</span>
<a href="#l8.85"></a><span id="l8.85">   }</span>
<a href="#l8.86"></a><span id="l8.86">   if (*last)</span>
<a href="#l8.87"></a><span id="l8.87">   {</span>
<a href="#l8.88"></a><span id="l8.88" class="difflineminus">-    // not the whole token was consumed  </span>
<a href="#l8.89"></a><span id="l8.89" class="difflineplus">+    // not the whole token was consumed</span>
<a href="#l8.90"></a><span id="l8.90">     *last = '\0';</span>
<a href="#l8.91"></a><span id="l8.91">     AdvanceTokenizerStartingPoint((fNextToken - fLineOfTokens) + (last-rv));</span>
<a href="#l8.92"></a><span id="l8.92">   }</span>
<a href="#l8.93"></a><span id="l8.93">   return rv;</span>
<a href="#l8.94"></a><span id="l8.94"> }</span>
<a href="#l8.95"></a><span id="l8.95"> </span>
<a href="#l8.96"></a><span id="l8.96"> // CreateNilString return either NULL (for &quot;NIL&quot;) or a string</span>
<a href="#l8.97"></a><span id="l8.97"> // Call with fNextToken pointing to the thing which we think is the nilstring.</span>
<a href="#l8.98"></a><span id="l8.98" class="difflineat">@@ -298,23 +298,23 @@ char *nsIMAPGenericParser::CreateString(</span>
<a href="#l8.99"></a><span id="l8.99"> }</span>
<a href="#l8.100"></a><span id="l8.100"> </span>
<a href="#l8.101"></a><span id="l8.101"> // This function sets fCurrentTokenPlaceHolder immediately after the end of the</span>
<a href="#l8.102"></a><span id="l8.102"> // closing quote.  Call AdvanceToNextToken() to get the token after it.</span>
<a href="#l8.103"></a><span id="l8.103"> // QUOTED_CHAR     ::= &lt;any TEXT_CHAR except quoted_specials&gt; /</span>
<a href="#l8.104"></a><span id="l8.104"> //                     &quot;\&quot; quoted_specials</span>
<a href="#l8.105"></a><span id="l8.105"> // TEXT_CHAR       ::= &lt;any CHAR except CR and LF&gt;</span>
<a href="#l8.106"></a><span id="l8.106"> // quoted_specials ::= &lt;&quot;&gt; / &quot;\&quot;</span>
<a href="#l8.107"></a><span id="l8.107" class="difflineminus">-// Note that according to RFC 1064 and RFC 2060, CRs and LFs are not allowed </span>
<a href="#l8.108"></a><span id="l8.108" class="difflineplus">+// Note that according to RFC 1064 and RFC 2060, CRs and LFs are not allowed</span>
<a href="#l8.109"></a><span id="l8.109"> // inside a quoted string.  It is sufficient to read from the current line only.</span>
<a href="#l8.110"></a><span id="l8.110"> char *nsIMAPGenericParser::CreateQuoted(bool /*skipToEnd*/)</span>
<a href="#l8.111"></a><span id="l8.111"> {</span>
<a href="#l8.112"></a><span id="l8.112">   // one char past opening '&quot;'</span>
<a href="#l8.113"></a><span id="l8.113">   char *currentChar = fCurrentLine + (fNextToken - fStartOfLineOfTokens) + 1;</span>
<a href="#l8.114"></a><span id="l8.114" class="difflineminus">-  </span>
<a href="#l8.115"></a><span id="l8.115" class="difflineplus">+</span>
<a href="#l8.116"></a><span id="l8.116">   int escapeCharsCut = 0;</span>
<a href="#l8.117"></a><span id="l8.117">   nsCString returnString(currentChar);</span>
<a href="#l8.118"></a><span id="l8.118">   int charIndex;</span>
<a href="#l8.119"></a><span id="l8.119">   for (charIndex = 0; returnString.CharAt(charIndex) != '&quot;'; charIndex++)</span>
<a href="#l8.120"></a><span id="l8.120">   {</span>
<a href="#l8.121"></a><span id="l8.121">     if (!returnString.CharAt(charIndex))</span>
<a href="#l8.122"></a><span id="l8.122">     {</span>
<a href="#l8.123"></a><span id="l8.123">       SetSyntaxError(true, &quot;no closing '\&quot;' found in quoted&quot;);</span>
<a href="#l8.124"></a><span id="l8.124" class="difflineat">@@ -360,74 +360,74 @@ char *nsIMAPGenericParser::CreateLiteral</span>
<a href="#l8.125"></a><span id="l8.125">   int32_t currentLineLength = 0;</span>
<a href="#l8.126"></a><span id="l8.126">   int32_t charsReadSoFar = 0;</span>
<a href="#l8.127"></a><span id="l8.127">   int32_t bytesToCopy = 0;</span>
<a href="#l8.128"></a><span id="l8.128">   while (charsReadSoFar &lt; numberOfCharsInMessage)</span>
<a href="#l8.129"></a><span id="l8.129">   {</span>
<a href="#l8.130"></a><span id="l8.130">     AdvanceToNextLine();</span>
<a href="#l8.131"></a><span id="l8.131">     if (!ContinueParse())</span>
<a href="#l8.132"></a><span id="l8.132">       break;</span>
<a href="#l8.133"></a><span id="l8.133" class="difflineminus">-    </span>
<a href="#l8.134"></a><span id="l8.134" class="difflineplus">+</span>
<a href="#l8.135"></a><span id="l8.135">     currentLineLength = strlen(fCurrentLine);</span>
<a href="#l8.136"></a><span id="l8.136">     bytesToCopy = (currentLineLength &gt; numberOfCharsInMessage - charsReadSoFar ?</span>
<a href="#l8.137"></a><span id="l8.137">                    numberOfCharsInMessage - charsReadSoFar : currentLineLength);</span>
<a href="#l8.138"></a><span id="l8.138">     NS_ASSERTION(bytesToCopy, &quot;zero-length line?&quot;);</span>
<a href="#l8.139"></a><span id="l8.139" class="difflineminus">-    memcpy(returnString + charsReadSoFar, fCurrentLine, bytesToCopy); </span>
<a href="#l8.140"></a><span id="l8.140" class="difflineplus">+    memcpy(returnString + charsReadSoFar, fCurrentLine, bytesToCopy);</span>
<a href="#l8.141"></a><span id="l8.141">     charsReadSoFar += bytesToCopy;</span>
<a href="#l8.142"></a><span id="l8.142">   }</span>
<a href="#l8.143"></a><span id="l8.143" class="difflineminus">-  </span>
<a href="#l8.144"></a><span id="l8.144" class="difflineplus">+</span>
<a href="#l8.145"></a><span id="l8.145">   if (ContinueParse())</span>
<a href="#l8.146"></a><span id="l8.146">   {</span>
<a href="#l8.147"></a><span id="l8.147">     if (currentLineLength == bytesToCopy)</span>
<a href="#l8.148"></a><span id="l8.148">     {</span>
<a href="#l8.149"></a><span id="l8.149">       // We have consumed the entire line.</span>
<a href="#l8.150"></a><span id="l8.150">       // Consider the input  &quot;{4}\r\n&quot;  &quot;L1\r\n&quot;  &quot; A2\r\n&quot;  which is read</span>
<a href="#l8.151"></a><span id="l8.151">       // line-by-line.  Reading an Astring, this should result in &quot;L1\r\n&quot;.</span>
<a href="#l8.152"></a><span id="l8.152">       // Note that the second line is &quot;L1\r\n&quot;, where the &quot;\r\n&quot; is part of</span>
<a href="#l8.153"></a><span id="l8.153">       // the literal.  Hence, we now read the next line to ensure that the</span>
<a href="#l8.154"></a><span id="l8.154">       // next call to AdvanceToNextToken() leads to fNextToken==&quot;A2&quot; in our</span>
<a href="#l8.155"></a><span id="l8.155">       // example.</span>
<a href="#l8.156"></a><span id="l8.156">       AdvanceToNextLine();</span>
<a href="#l8.157"></a><span id="l8.157">     }</span>
<a href="#l8.158"></a><span id="l8.158">     else</span>
<a href="#l8.159"></a><span id="l8.159">       AdvanceTokenizerStartingPoint(bytesToCopy);</span>
<a href="#l8.160"></a><span id="l8.160">   }</span>
<a href="#l8.161"></a><span id="l8.161" class="difflineminus">-  </span>
<a href="#l8.162"></a><span id="l8.162" class="difflineplus">+</span>
<a href="#l8.163"></a><span id="l8.163">   returnString[charsReadSoFar] = 0;</span>
<a href="#l8.164"></a><span id="l8.164">   return returnString;</span>
<a href="#l8.165"></a><span id="l8.165"> }</span>
<a href="#l8.166"></a><span id="l8.166"> </span>
<a href="#l8.167"></a><span id="l8.167"> </span>
<a href="#l8.168"></a><span id="l8.168"> // Call this to create a buffer containing all characters within</span>
<a href="#l8.169"></a><span id="l8.169"> // a given set of parentheses.</span>
<a href="#l8.170"></a><span id="l8.170"> // Call this with fNextToken[0]=='(', that is, the open paren</span>
<a href="#l8.171"></a><span id="l8.171"> // of the group.</span>
<a href="#l8.172"></a><span id="l8.172"> // It will allocate and return all characters up to and including the corresponding</span>
<a href="#l8.173"></a><span id="l8.173"> // closing paren, and leave the parser in the right place afterwards.</span>
<a href="#l8.174"></a><span id="l8.174"> char *nsIMAPGenericParser::CreateParenGroup()</span>
<a href="#l8.175"></a><span id="l8.175"> {</span>
<a href="#l8.176"></a><span id="l8.176">   NS_ASSERTION(fNextToken[0] == '(', &quot;we don't have a paren group!&quot;);</span>
<a href="#l8.177"></a><span id="l8.177" class="difflineminus">-  </span>
<a href="#l8.178"></a><span id="l8.178" class="difflineplus">+</span>
<a href="#l8.179"></a><span id="l8.179">   int numOpenParens = 0;</span>
<a href="#l8.180"></a><span id="l8.180">   AdvanceTokenizerStartingPoint(fNextToken - fLineOfTokens);</span>
<a href="#l8.181"></a><span id="l8.181" class="difflineminus">-  </span>
<a href="#l8.182"></a><span id="l8.182" class="difflineplus">+</span>
<a href="#l8.183"></a><span id="l8.183">   // Build up a buffer containing the paren group.</span>
<a href="#l8.184"></a><span id="l8.184">   nsCString returnString;</span>
<a href="#l8.185"></a><span id="l8.185">   char *parenGroupStart = fCurrentTokenPlaceHolder;</span>
<a href="#l8.186"></a><span id="l8.186">   NS_ASSERTION(parenGroupStart[0] == '(', &quot;we don't have a paren group (2)!&quot;);</span>
<a href="#l8.187"></a><span id="l8.187">   while (*fCurrentTokenPlaceHolder)</span>
<a href="#l8.188"></a><span id="l8.188">   {</span>
<a href="#l8.189"></a><span id="l8.189">     if (*fCurrentTokenPlaceHolder == '{')  // literal</span>
<a href="#l8.190"></a><span id="l8.190">     {</span>
<a href="#l8.191"></a><span id="l8.191">       // Ensure it is a properly formatted literal.</span>
<a href="#l8.192"></a><span id="l8.192">       NS_ASSERTION(!strcmp(&quot;}\r\n&quot;, fCurrentTokenPlaceHolder + strlen(fCurrentTokenPlaceHolder) - 3), &quot;not a literal&quot;);</span>
<a href="#l8.193"></a><span id="l8.193" class="difflineminus">-      </span>
<a href="#l8.194"></a><span id="l8.194" class="difflineplus">+</span>
<a href="#l8.195"></a><span id="l8.195">       // Append previous characters and the &quot;{xx}\r\n&quot; to buffer.</span>
<a href="#l8.196"></a><span id="l8.196">       returnString.Append(parenGroupStart);</span>
<a href="#l8.197"></a><span id="l8.197" class="difflineminus">-      </span>
<a href="#l8.198"></a><span id="l8.198" class="difflineplus">+</span>
<a href="#l8.199"></a><span id="l8.199">       // Append literal itself.</span>
<a href="#l8.200"></a><span id="l8.200">       AdvanceToNextToken();</span>
<a href="#l8.201"></a><span id="l8.201">       if (!ContinueParse())</span>
<a href="#l8.202"></a><span id="l8.202">         break;</span>
<a href="#l8.203"></a><span id="l8.203">       char *lit = CreateLiteral();</span>
<a href="#l8.204"></a><span id="l8.204">       NS_ASSERTION(lit, &quot;syntax error or out of memory&quot;);</span>
<a href="#l8.205"></a><span id="l8.205">       if (!lit)</span>
<a href="#l8.206"></a><span id="l8.206">         break;</span>
<a href="#l8.207"></a><span id="l8.207" class="difflineat">@@ -460,20 +460,20 @@ char *nsIMAPGenericParser::CreateParenGr</span>
<a href="#l8.208"></a><span id="l8.208">       else if (c == ')')</span>
<a href="#l8.209"></a><span id="l8.209">       {</span>
<a href="#l8.210"></a><span id="l8.210">         numOpenParens--;</span>
<a href="#l8.211"></a><span id="l8.211">         if (numOpenParens == 0)</span>
<a href="#l8.212"></a><span id="l8.212">           break;</span>
<a href="#l8.213"></a><span id="l8.213">       }</span>
<a href="#l8.214"></a><span id="l8.214">     }</span>
<a href="#l8.215"></a><span id="l8.215">   }</span>
<a href="#l8.216"></a><span id="l8.216" class="difflineminus">-  </span>
<a href="#l8.217"></a><span id="l8.217" class="difflineplus">+</span>
<a href="#l8.218"></a><span id="l8.218">   if (numOpenParens != 0 || !ContinueParse())</span>
<a href="#l8.219"></a><span id="l8.219">   {</span>
<a href="#l8.220"></a><span id="l8.220">     SetSyntaxError(true, &quot;closing ')' not found in paren group&quot;);</span>
<a href="#l8.221"></a><span id="l8.221">     return nullptr;</span>
<a href="#l8.222"></a><span id="l8.222">   }</span>
<a href="#l8.223"></a><span id="l8.223"> </span>
<a href="#l8.224"></a><span id="l8.224">   returnString.Append(parenGroupStart, fCurrentTokenPlaceHolder - parenGroupStart);</span>
<a href="#l8.225"></a><span id="l8.225" class="difflineminus">-  AdvanceToNextToken();  </span>
<a href="#l8.226"></a><span id="l8.226" class="difflineplus">+  AdvanceToNextToken();</span>
<a href="#l8.227"></a><span id="l8.227">   return ToNewCString(returnString);</span>
<a href="#l8.228"></a><span id="l8.228"> }</span>
<a href="#l8.229"></a><span id="l8.229"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPGenericParser.h</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPGenericParser.h</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -1,40 +1,40 @@</span>
<a href="#l9.4"></a><span id="l9.4"> /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l9.5"></a><span id="l9.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l9.6"></a><span id="l9.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l9.7"></a><span id="l9.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l9.8"></a><span id="l9.8"> </span>
<a href="#l9.9"></a><span id="l9.9" class="difflineminus">-/* </span>
<a href="#l9.10"></a><span id="l9.10" class="difflineplus">+/*</span>
<a href="#l9.11"></a><span id="l9.11"> nsIMAPGenericParser is the base parser class used by the server parser and body shell parser</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-*/ </span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+*/</span>
<a href="#l9.14"></a><span id="l9.14"> </span>
<a href="#l9.15"></a><span id="l9.15"> #ifndef nsIMAPGenericParser_H</span>
<a href="#l9.16"></a><span id="l9.16"> #define nsIMAPGenericParser_H</span>
<a href="#l9.17"></a><span id="l9.17"> </span>
<a href="#l9.18"></a><span id="l9.18"> #include &quot;nsImapCore.h&quot;</span>
<a href="#l9.19"></a><span id="l9.19"> </span>
<a href="#l9.20"></a><span id="l9.20" class="difflineminus">-#define WHITESPACE &quot; \015\012&quot;     // token delimiter </span>
<a href="#l9.21"></a><span id="l9.21" class="difflineplus">+#define WHITESPACE &quot; \015\012&quot;     // token delimiter</span>
<a href="#l9.22"></a><span id="l9.22"> </span>
<a href="#l9.23"></a><span id="l9.23"> </span>
<a href="#l9.24"></a><span id="l9.24" class="difflineminus">-class nsIMAPGenericParser </span>
<a href="#l9.25"></a><span id="l9.25" class="difflineplus">+class nsIMAPGenericParser</span>
<a href="#l9.26"></a><span id="l9.26"> {</span>
<a href="#l9.27"></a><span id="l9.27"> </span>
<a href="#l9.28"></a><span id="l9.28"> public:</span>
<a href="#l9.29"></a><span id="l9.29"> 	nsIMAPGenericParser();</span>
<a href="#l9.30"></a><span id="l9.30"> 	virtual ~nsIMAPGenericParser();</span>
<a href="#l9.31"></a><span id="l9.31"> </span>
<a href="#l9.32"></a><span id="l9.32">   // Add any specific stuff in the derived class</span>
<a href="#l9.33"></a><span id="l9.33">   virtual bool       LastCommandSuccessful();</span>
<a href="#l9.34"></a><span id="l9.34"> </span>
<a href="#l9.35"></a><span id="l9.35">   bool SyntaxError() { return (fParserState &amp; stateSyntaxErrorFlag) != 0; }</span>
<a href="#l9.36"></a><span id="l9.36">   bool ContinueParse() { return fParserState == stateOK; }</span>
<a href="#l9.37"></a><span id="l9.37">   bool Connected() { return !(fParserState &amp; stateDisconnectedFlag); }</span>
<a href="#l9.38"></a><span id="l9.38">   void SetConnected(bool error);</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineminus">-    </span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+</span>
<a href="#l9.41"></a><span id="l9.41"> protected:</span>
<a href="#l9.42"></a><span id="l9.42"> </span>
<a href="#l9.43"></a><span id="l9.43"> 	// This is a pure virtual member which must be overridden in the derived class</span>
<a href="#l9.44"></a><span id="l9.44"> 	// for each different implementation of a nsIMAPGenericParser.</span>
<a href="#l9.45"></a><span id="l9.45"> 	// For instance, one implementation (the nsIMAPServerState) might get the next line</span>
<a href="#l9.46"></a><span id="l9.46"> 	// from an open socket, whereas another implementation might just get it from a buffer somewhere.</span>
<a href="#l9.47"></a><span id="l9.47"> 	// This fills in nextLine with the buffer, and returns true if everything is OK.</span>
<a href="#l9.48"></a><span id="l9.48"> 	// Returns false if there was some error encountered.  In that case, we reset the parser.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPHostSessionList.cpp</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPHostSessionList.cpp</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -677,17 +677,17 @@ NS_IMETHODIMP nsIMAPHostSessionList::Fin</span>
<a href="#l10.4"></a><span id="l10.4">   if (host &amp;&amp; host-&gt;fShellCache)</span>
<a href="#l10.5"></a><span id="l10.5">     NS_IF_ADDREF(*shell = host-&gt;fShellCache-&gt;FindShellForUID(uidString,</span>
<a href="#l10.6"></a><span id="l10.6">                                                              mailboxName,</span>
<a href="#l10.7"></a><span id="l10.7">                                                              modType));</span>
<a href="#l10.8"></a><span id="l10.8">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l10.9"></a><span id="l10.9">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span>
<a href="#l10.10"></a><span id="l10.10"> }</span>
<a href="#l10.11"></a><span id="l10.11"> </span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l10.14"></a><span id="l10.14"> nsIMAPHostSessionList::ClearShellCacheForHost(const char *serverKey)</span>
<a href="#l10.15"></a><span id="l10.15"> {</span>
<a href="#l10.16"></a><span id="l10.16">   PR_EnterMonitor(gCachedHostInfoMonitor);</span>
<a href="#l10.17"></a><span id="l10.17">   nsIMAPHostInfo *host = FindHost(serverKey);</span>
<a href="#l10.18"></a><span id="l10.18">   if (host &amp;&amp; host-&gt;fShellCache)</span>
<a href="#l10.19"></a><span id="l10.19">     host-&gt;fShellCache-&gt;Clear();</span>
<a href="#l10.20"></a><span id="l10.20">   PR_ExitMonitor(gCachedHostInfoMonitor);</span>
<a href="#l10.21"></a><span id="l10.21">   return (host == NULL) ? NS_ERROR_ILLEGAL_VALUE : NS_OK;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPHostSessionList.h</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPHostSessionList.h</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -40,27 +40,27 @@ protected:</span>
<a href="#l11.4"></a><span id="l11.4">   bool fHaveAdminURL;</span>
<a href="#l11.5"></a><span id="l11.5">   bool fPasswordVerifiedOnline;</span>
<a href="#l11.6"></a><span id="l11.6">   bool fDeleteIsMoveToTrash;</span>
<a href="#l11.7"></a><span id="l11.7">   bool fShowDeletedMessages;</span>
<a href="#l11.8"></a><span id="l11.8">   bool fGotNamespaces;</span>
<a href="#l11.9"></a><span id="l11.9">   nsIMAPBodyShellCache *fShellCache;</span>
<a href="#l11.10"></a><span id="l11.10"> };</span>
<a href="#l11.11"></a><span id="l11.11"> </span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-// this is an interface to a linked list of host info's    </span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+// this is an interface to a linked list of host info's</span>
<a href="#l11.14"></a><span id="l11.14"> class nsIMAPHostSessionList : public nsIImapHostSessionList, public nsIObserver, public nsSupportsWeakReference</span>
<a href="#l11.15"></a><span id="l11.15"> {</span>
<a href="#l11.16"></a><span id="l11.16"> public:</span>
<a href="#l11.17"></a><span id="l11.17">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineminus">-  NS_DECL_NSIOBSERVER  </span>
<a href="#l11.19"></a><span id="l11.19" class="difflineplus">+  NS_DECL_NSIOBSERVER</span>
<a href="#l11.20"></a><span id="l11.20"> </span>
<a href="#l11.21"></a><span id="l11.21">   nsIMAPHostSessionList();</span>
<a href="#l11.22"></a><span id="l11.22">   nsresult Init();</span>
<a href="#l11.23"></a><span id="l11.23">   // Host List</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineminus">-  NS_IMETHOD AddHostToList(const char *serverKey, </span>
<a href="#l11.25"></a><span id="l11.25" class="difflineplus">+  NS_IMETHOD AddHostToList(const char *serverKey,</span>
<a href="#l11.26"></a><span id="l11.26">                             nsIImapIncomingServer *server) override;</span>
<a href="#l11.27"></a><span id="l11.27">   NS_IMETHOD ResetAll() override;</span>
<a href="#l11.28"></a><span id="l11.28"> </span>
<a href="#l11.29"></a><span id="l11.29">   // Capabilities</span>
<a href="#l11.30"></a><span id="l11.30">   NS_IMETHOD GetHostHasAdminURL(const char *serverKey, bool &amp;result) override;</span>
<a href="#l11.31"></a><span id="l11.31">   NS_IMETHOD SetHostHasAdminURL(const char *serverKey, bool hasAdminUrl) override;</span>
<a href="#l11.32"></a><span id="l11.32">   // Subscription</span>
<a href="#l11.33"></a><span id="l11.33">   NS_IMETHOD GetHostIsUsingSubscription(const char *serverKey, bool &amp;result) override;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPNamespace.cpp</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPNamespace.cpp</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -132,28 +132,28 @@ int nsIMAPNamespaceList::AddNewNamespace</span>
<a href="#l12.4"></a><span id="l12.4"> </span>
<a href="#l12.5"></a><span id="l12.5"> 	if (!ns-&gt;GetIsNamespaceFromPrefs())</span>
<a href="#l12.6"></a><span id="l12.6"> 	{</span>
<a href="#l12.7"></a><span id="l12.7"> 		int nodeIndex;</span>
<a href="#l12.8"></a><span id="l12.8">         // iterate backwards because we delete elements</span>
<a href="#l12.9"></a><span id="l12.9"> 		for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l12.10"></a><span id="l12.10"> 		{</span>
<a href="#l12.11"></a><span id="l12.11"> 			nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-			// if we find existing namespace(s) that matches the </span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+			// if we find existing namespace(s) that matches the</span>
<a href="#l12.14"></a><span id="l12.14"> 			// new one, we'll just remove the old ones and let the</span>
<a href="#l12.15"></a><span id="l12.15"> 			// new one get added when we've finished checking for</span>
<a href="#l12.16"></a><span id="l12.16"> 			// matching namespaces or namespaces that came from prefs.</span>
<a href="#l12.17"></a><span id="l12.17"> 			if (nspace &amp;&amp;</span>
<a href="#l12.18"></a><span id="l12.18">                             (nspace-&gt;GetIsNamespaceFromPrefs() ||</span>
<a href="#l12.19"></a><span id="l12.19">                             (!PL_strcmp(ns-&gt;GetPrefix(), nspace-&gt;GetPrefix()) &amp;&amp;</span>
<a href="#l12.20"></a><span id="l12.20"> 			     ns-&gt;GetType() == nspace-&gt;GetType() &amp;&amp;</span>
<a href="#l12.21"></a><span id="l12.21"> 			     ns-&gt;GetDelimiter() == nspace-&gt;GetDelimiter())))</span>
<a href="#l12.22"></a><span id="l12.22"> 			{</span>
<a href="#l12.23"></a><span id="l12.23"> 				m_NamespaceList.RemoveElementAt(nodeIndex);</span>
<a href="#l12.24"></a><span id="l12.24" class="difflineminus">-				delete nspace; </span>
<a href="#l12.25"></a><span id="l12.25" class="difflineplus">+				delete nspace;</span>
<a href="#l12.26"></a><span id="l12.26"> 			}</span>
<a href="#l12.27"></a><span id="l12.27"> 		}</span>
<a href="#l12.28"></a><span id="l12.28"> 	}</span>
<a href="#l12.29"></a><span id="l12.29"> </span>
<a href="#l12.30"></a><span id="l12.30"> 	// Add the new namespace to the list.  This must come after the removing code,</span>
<a href="#l12.31"></a><span id="l12.31"> 	// or else we could never add the initial kDefaultNamespace type to the list.</span>
<a href="#l12.32"></a><span id="l12.32"> 	m_NamespaceList.AppendElement(ns);</span>
<a href="#l12.33"></a><span id="l12.33"> </span>
<a href="#l12.34"></a><span id="l12.34" class="difflineat">@@ -243,42 +243,42 @@ nsIMAPNamespace *nsIMAPNamespaceList::Ge</span>
<a href="#l12.35"></a><span id="l12.35">   }</span>
<a href="#l12.36"></a><span id="l12.36">   return nullptr;</span>
<a href="#l12.37"></a><span id="l12.37"> }</span>
<a href="#l12.38"></a><span id="l12.38"> </span>
<a href="#l12.39"></a><span id="l12.39"> nsIMAPNamespace *nsIMAPNamespaceList::GetNamespaceForMailbox(const char *boxname)</span>
<a href="#l12.40"></a><span id="l12.40"> {</span>
<a href="#l12.41"></a><span id="l12.41">   // We want to find the LONGEST substring that matches the beginning of this mailbox's path.</span>
<a href="#l12.42"></a><span id="l12.42">   // This accounts for nested namespaces  (i.e. &quot;Public/&quot; and &quot;Public/Users/&quot;)</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineminus">-  </span>
<a href="#l12.44"></a><span id="l12.44" class="difflineplus">+</span>
<a href="#l12.45"></a><span id="l12.45">   // Also, we want to match the namespace's mailbox to that namespace also:</span>
<a href="#l12.46"></a><span id="l12.46">   // The Personal box will match the Personal/ namespace, etc.</span>
<a href="#l12.47"></a><span id="l12.47" class="difflineminus">-  </span>
<a href="#l12.48"></a><span id="l12.48" class="difflineplus">+</span>
<a href="#l12.49"></a><span id="l12.49">   // these lists shouldn't be too long (99% chance there won't be more than 3 or 4)</span>
<a href="#l12.50"></a><span id="l12.50">   // so just do a linear search</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineminus">-  </span>
<a href="#l12.52"></a><span id="l12.52" class="difflineplus">+</span>
<a href="#l12.53"></a><span id="l12.53">   int lengthMatched = -1;</span>
<a href="#l12.54"></a><span id="l12.54">   int currentMatchedLength = -1;</span>
<a href="#l12.55"></a><span id="l12.55">   nsIMAPNamespace *rv = nullptr;</span>
<a href="#l12.56"></a><span id="l12.56">   int nodeIndex = 0;</span>
<a href="#l12.57"></a><span id="l12.57" class="difflineminus">-  </span>
<a href="#l12.58"></a><span id="l12.58" class="difflineplus">+</span>
<a href="#l12.59"></a><span id="l12.59">   if (!PL_strcasecmp(boxname, &quot;INBOX&quot;))</span>
<a href="#l12.60"></a><span id="l12.60">     return GetDefaultNamespaceOfType(kPersonalNamespace);</span>
<a href="#l12.61"></a><span id="l12.61" class="difflineminus">-  </span>
<a href="#l12.62"></a><span id="l12.62" class="difflineplus">+</span>
<a href="#l12.63"></a><span id="l12.63">   for (nodeIndex = m_NamespaceList.Length() - 1; nodeIndex &gt;= 0; nodeIndex--)</span>
<a href="#l12.64"></a><span id="l12.64">   {</span>
<a href="#l12.65"></a><span id="l12.65">     nsIMAPNamespace *nspace = m_NamespaceList.ElementAt(nodeIndex);</span>
<a href="#l12.66"></a><span id="l12.66">     currentMatchedLength = nspace-&gt;MailboxMatchesNamespace(boxname);</span>
<a href="#l12.67"></a><span id="l12.67">     if (currentMatchedLength &gt; lengthMatched)</span>
<a href="#l12.68"></a><span id="l12.68">     {</span>
<a href="#l12.69"></a><span id="l12.69">       rv = nspace;</span>
<a href="#l12.70"></a><span id="l12.70">       lengthMatched = currentMatchedLength;</span>
<a href="#l12.71"></a><span id="l12.71">     }</span>
<a href="#l12.72"></a><span id="l12.72">   }</span>
<a href="#l12.73"></a><span id="l12.73" class="difflineminus">-  </span>
<a href="#l12.74"></a><span id="l12.74" class="difflineplus">+</span>
<a href="#l12.75"></a><span id="l12.75">   return rv;</span>
<a href="#l12.76"></a><span id="l12.76"> }</span>
<a href="#l12.77"></a><span id="l12.77"> </span>
<a href="#l12.78"></a><span id="l12.78"> #define SERIALIZER_SEPARATORS &quot;,&quot;</span>
<a href="#l12.79"></a><span id="l12.79"> </span>
<a href="#l12.80"></a><span id="l12.80"> /**</span>
<a href="#l12.81"></a><span id="l12.81">  * If len is one, copies the first element of prefixes into serializedNamespaces.</span>
<a href="#l12.82"></a><span id="l12.82">  * If len &gt; 1, copies len strings from prefixes into serializedNamespaces</span>
<a href="#l12.83"></a><span id="l12.83" class="difflineat">@@ -369,28 +369,28 @@ int nsIMAPNamespaceList::UnserializeName</span>
<a href="#l12.84"></a><span id="l12.84"> </span>
<a href="#l12.85"></a><span id="l12.85"> char *nsIMAPNamespaceList::AllocateCanonicalFolderName(const char *onlineFolderName, char delimiter)</span>
<a href="#l12.86"></a><span id="l12.86"> {</span>
<a href="#l12.87"></a><span id="l12.87">   char *canonicalPath = nullptr;</span>
<a href="#l12.88"></a><span id="l12.88">   if (delimiter)</span>
<a href="#l12.89"></a><span id="l12.89">     canonicalPath = nsImapUrl::ReplaceCharsInCopiedString(onlineFolderName, delimiter , '/');</span>
<a href="#l12.90"></a><span id="l12.90">   else</span>
<a href="#l12.91"></a><span id="l12.91">     canonicalPath = PL_strdup(onlineFolderName);</span>
<a href="#l12.92"></a><span id="l12.92" class="difflineminus">-  </span>
<a href="#l12.93"></a><span id="l12.93" class="difflineplus">+</span>
<a href="#l12.94"></a><span id="l12.94">   // eat any escape characters for escaped dir separators</span>
<a href="#l12.95"></a><span id="l12.95">   if (canonicalPath)</span>
<a href="#l12.96"></a><span id="l12.96">   {</span>
<a href="#l12.97"></a><span id="l12.97">     char *currentEscapeSequence = strstr(canonicalPath, &quot;\\/&quot;);</span>
<a href="#l12.98"></a><span id="l12.98">     while (currentEscapeSequence)</span>
<a href="#l12.99"></a><span id="l12.99">     {</span>
<a href="#l12.100"></a><span id="l12.100">       strcpy(currentEscapeSequence, currentEscapeSequence+1);</span>
<a href="#l12.101"></a><span id="l12.101">       currentEscapeSequence = strstr(currentEscapeSequence+1, &quot;\\/&quot;);</span>
<a href="#l12.102"></a><span id="l12.102">     }</span>
<a href="#l12.103"></a><span id="l12.103">   }</span>
<a href="#l12.104"></a><span id="l12.104" class="difflineminus">-  </span>
<a href="#l12.105"></a><span id="l12.105" class="difflineplus">+</span>
<a href="#l12.106"></a><span id="l12.106">   return canonicalPath;</span>
<a href="#l12.107"></a><span id="l12.107"> }</span>
<a href="#l12.108"></a><span id="l12.108"> </span>
<a href="#l12.109"></a><span id="l12.109"> /*</span>
<a href="#l12.110"></a><span id="l12.110">   GetFolderNameWithoutNamespace takes as input a folder name</span>
<a href="#l12.111"></a><span id="l12.111">   in canonical form, and the namespace for the given folder.  It returns an allocated</span>
<a href="#l12.112"></a><span id="l12.112">   string of the folder's path with the namespace string stripped out.  For instance,</span>
<a href="#l12.113"></a><span id="l12.113">   when passed the folder Folders/a/b where the namespace is &quot;Folders/&quot;, it will return</span>
<a href="#l12.114"></a><span id="l12.114" class="difflineat">@@ -399,66 +399,66 @@ char *nsIMAPNamespaceList::AllocateCanon</span>
<a href="#l12.115"></a><span id="l12.115">   The return value is always in canonical form.</span>
<a href="#l12.116"></a><span id="l12.116"> */</span>
<a href="#l12.117"></a><span id="l12.117"> char* nsIMAPNamespaceList::GetFolderNameWithoutNamespace(nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName)</span>
<a href="#l12.118"></a><span id="l12.118"> {</span>
<a href="#l12.119"></a><span id="l12.119">   NS_ASSERTION(canonicalFolderName, &quot;null folder name&quot;);</span>
<a href="#l12.120"></a><span id="l12.120"> #ifdef DEBUG</span>
<a href="#l12.121"></a><span id="l12.121">   NS_ASSERTION(namespaceForFolder || !PL_strcasecmp(canonicalFolderName, &quot;INBOX&quot;), &quot;need namespace or INBOX&quot;);</span>
<a href="#l12.122"></a><span id="l12.122"> #endif</span>
<a href="#l12.123"></a><span id="l12.123" class="difflineminus">-  </span>
<a href="#l12.124"></a><span id="l12.124" class="difflineplus">+</span>
<a href="#l12.125"></a><span id="l12.125">   char *retFolderName = nullptr;</span>
<a href="#l12.126"></a><span id="l12.126" class="difflineminus">-  </span>
<a href="#l12.127"></a><span id="l12.127" class="difflineplus">+</span>
<a href="#l12.128"></a><span id="l12.128">   if (!PL_strcasecmp(canonicalFolderName, &quot;INBOX&quot;))</span>
<a href="#l12.129"></a><span id="l12.129">     return PL_strdup(canonicalFolderName);</span>
<a href="#l12.130"></a><span id="l12.130" class="difflineminus">-  </span>
<a href="#l12.131"></a><span id="l12.131" class="difflineplus">+</span>
<a href="#l12.132"></a><span id="l12.132">   // convert the canonical path to the online path</span>
<a href="#l12.133"></a><span id="l12.133">   char *convertedFolderName = nsIMAPNamespaceList::AllocateServerFolderName(canonicalFolderName, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l12.134"></a><span id="l12.134">   if (convertedFolderName)</span>
<a href="#l12.135"></a><span id="l12.135">   {</span>
<a href="#l12.136"></a><span id="l12.136">     char *beginFolderPath = nullptr;</span>
<a href="#l12.137"></a><span id="l12.137">     if (strlen(convertedFolderName) &lt;= strlen(namespaceForFolder-&gt;GetPrefix()))</span>
<a href="#l12.138"></a><span id="l12.138">       beginFolderPath = convertedFolderName;</span>
<a href="#l12.139"></a><span id="l12.139">     else</span>
<a href="#l12.140"></a><span id="l12.140">       beginFolderPath = convertedFolderName + strlen(namespaceForFolder-&gt;GetPrefix());</span>
<a href="#l12.141"></a><span id="l12.141">     NS_ASSERTION(beginFolderPath, &quot;empty folder path&quot;);</span>
<a href="#l12.142"></a><span id="l12.142">     retFolderName = nsIMAPNamespaceList::AllocateCanonicalFolderName(beginFolderPath, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l12.143"></a><span id="l12.143">     PR_Free(convertedFolderName);</span>
<a href="#l12.144"></a><span id="l12.144">   }</span>
<a href="#l12.145"></a><span id="l12.145" class="difflineminus">-  </span>
<a href="#l12.146"></a><span id="l12.146" class="difflineplus">+</span>
<a href="#l12.147"></a><span id="l12.147">   NS_ASSERTION(retFolderName, &quot;returning null folder name&quot;);</span>
<a href="#l12.148"></a><span id="l12.148">   return retFolderName;</span>
<a href="#l12.149"></a><span id="l12.149"> }</span>
<a href="#l12.150"></a><span id="l12.150"> </span>
<a href="#l12.151"></a><span id="l12.151"> </span>
<a href="#l12.152"></a><span id="l12.152"> nsIMAPNamespace* nsIMAPNamespaceList::GetNamespaceForFolder(const char *hostName,</span>
<a href="#l12.153"></a><span id="l12.153">                                                     const char *canonicalFolderName,</span>
<a href="#l12.154"></a><span id="l12.154">                                                     char delimiter)</span>
<a href="#l12.155"></a><span id="l12.155"> {</span>
<a href="#l12.156"></a><span id="l12.156">   if (!hostName || !canonicalFolderName)</span>
<a href="#l12.157"></a><span id="l12.157">     return nullptr;</span>
<a href="#l12.158"></a><span id="l12.158" class="difflineminus">-  </span>
<a href="#l12.159"></a><span id="l12.159" class="difflineplus">+</span>
<a href="#l12.160"></a><span id="l12.160">   nsIMAPNamespace *resultNamespace = nullptr;</span>
<a href="#l12.161"></a><span id="l12.161">   nsresult rv;</span>
<a href="#l12.162"></a><span id="l12.162">   char *convertedFolderName = nsIMAPNamespaceList::AllocateServerFolderName(canonicalFolderName, delimiter);</span>
<a href="#l12.163"></a><span id="l12.163"> </span>
<a href="#l12.164"></a><span id="l12.164">   if (convertedFolderName)</span>
<a href="#l12.165"></a><span id="l12.165">   {</span>
<a href="#l12.166"></a><span id="l12.166" class="difflineminus">-    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSessionList = </span>
<a href="#l12.167"></a><span id="l12.167" class="difflineplus">+    nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSessionList =</span>
<a href="#l12.168"></a><span id="l12.168">              do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l12.169"></a><span id="l12.169" class="difflineminus">-    if (NS_FAILED(rv)) </span>
<a href="#l12.170"></a><span id="l12.170" class="difflineplus">+    if (NS_FAILED(rv))</span>
<a href="#l12.171"></a><span id="l12.171">       return nullptr;</span>
<a href="#l12.172"></a><span id="l12.172">     hostSessionList-&gt;GetNamespaceForMailboxForHost(hostName, convertedFolderName, resultNamespace);</span>
<a href="#l12.173"></a><span id="l12.173">     PR_Free(convertedFolderName);</span>
<a href="#l12.174"></a><span id="l12.174">   }</span>
<a href="#l12.175"></a><span id="l12.175">   else</span>
<a href="#l12.176"></a><span id="l12.176">   {</span>
<a href="#l12.177"></a><span id="l12.177">     NS_ASSERTION(false, &quot;couldn't get converted folder name&quot;);</span>
<a href="#l12.178"></a><span id="l12.178">   }</span>
<a href="#l12.179"></a><span id="l12.179" class="difflineminus">-  </span>
<a href="#l12.180"></a><span id="l12.180" class="difflineplus">+</span>
<a href="#l12.181"></a><span id="l12.181">   return resultNamespace;</span>
<a href="#l12.182"></a><span id="l12.182"> }</span>
<a href="#l12.183"></a><span id="l12.183"> </span>
<a href="#l12.184"></a><span id="l12.184"> /* static */</span>
<a href="#l12.185"></a><span id="l12.185"> char *nsIMAPNamespaceList::AllocateServerFolderName(const char *canonicalFolderName, char delimiter)</span>
<a href="#l12.186"></a><span id="l12.186"> {</span>
<a href="#l12.187"></a><span id="l12.187">   if (delimiter)</span>
<a href="#l12.188"></a><span id="l12.188">     return nsImapUrl::ReplaceCharsInCopiedString(canonicalFolderName, '/', delimiter);</span>
<a href="#l12.189"></a><span id="l12.189" class="difflineat">@@ -475,19 +475,19 @@ char *nsIMAPNamespaceList::AllocateServe</span>
<a href="#l12.190"></a><span id="l12.190"> /* static */</span>
<a href="#l12.191"></a><span id="l12.191"> char *nsIMAPNamespaceList::GetFolderOwnerNameFromPath(nsIMAPNamespace *namespaceForFolder, const char *canonicalFolderName)</span>
<a href="#l12.192"></a><span id="l12.192"> {</span>
<a href="#l12.193"></a><span id="l12.193">   if (!namespaceForFolder || !canonicalFolderName)</span>
<a href="#l12.194"></a><span id="l12.194">   {</span>
<a href="#l12.195"></a><span id="l12.195">     NS_ASSERTION(false,&quot;null namespace or canonical folder name&quot;);</span>
<a href="#l12.196"></a><span id="l12.196">     return nullptr;</span>
<a href="#l12.197"></a><span id="l12.197">   }</span>
<a href="#l12.198"></a><span id="l12.198" class="difflineminus">-  </span>
<a href="#l12.199"></a><span id="l12.199" class="difflineplus">+</span>
<a href="#l12.200"></a><span id="l12.200">   char *rv = nullptr;</span>
<a href="#l12.201"></a><span id="l12.201" class="difflineminus">-  </span>
<a href="#l12.202"></a><span id="l12.202" class="difflineplus">+</span>
<a href="#l12.203"></a><span id="l12.203">   // convert the canonical path to the online path</span>
<a href="#l12.204"></a><span id="l12.204">   char *convertedFolderName = AllocateServerFolderName(canonicalFolderName, namespaceForFolder-&gt;GetDelimiter());</span>
<a href="#l12.205"></a><span id="l12.205">   if (convertedFolderName)</span>
<a href="#l12.206"></a><span id="l12.206">   {</span>
<a href="#l12.207"></a><span id="l12.207"> #ifdef DEBUG</span>
<a href="#l12.208"></a><span id="l12.208">     NS_ASSERTION(strlen(convertedFolderName) &gt; strlen(namespaceForFolder-&gt;GetPrefix()), &quot;server folder name invalid&quot;);</span>
<a href="#l12.209"></a><span id="l12.209"> #endif</span>
<a href="#l12.210"></a><span id="l12.210">     if (strlen(convertedFolderName) &gt; strlen(namespaceForFolder-&gt;GetPrefix()))</span>
<a href="#l12.211"></a><span id="l12.211" class="difflineat">@@ -503,60 +503,60 @@ char *nsIMAPNamespaceList::GetFolderOwne</span>
<a href="#l12.212"></a><span id="l12.212">       rv = PL_strdup(owner);</span>
<a href="#l12.213"></a><span id="l12.213">     }</span>
<a href="#l12.214"></a><span id="l12.214">     PR_Free(convertedFolderName);</span>
<a href="#l12.215"></a><span id="l12.215">   }</span>
<a href="#l12.216"></a><span id="l12.216">   else</span>
<a href="#l12.217"></a><span id="l12.217">   {</span>
<a href="#l12.218"></a><span id="l12.218">     NS_ASSERTION(false, &quot;couldn't allocate server folder name&quot;);</span>
<a href="#l12.219"></a><span id="l12.219">   }</span>
<a href="#l12.220"></a><span id="l12.220" class="difflineminus">-  </span>
<a href="#l12.221"></a><span id="l12.221" class="difflineplus">+</span>
<a href="#l12.222"></a><span id="l12.222">   return rv;</span>
<a href="#l12.223"></a><span id="l12.223"> }</span>
<a href="#l12.224"></a><span id="l12.224"> </span>
<a href="#l12.225"></a><span id="l12.225"> /*</span>
<a href="#l12.226"></a><span id="l12.226"> GetFolderIsNamespace returns TRUE if the given folder is the folder representing</span>
<a href="#l12.227"></a><span id="l12.227"> a namespace.</span>
<a href="#l12.228"></a><span id="l12.228"> */</span>
<a href="#l12.229"></a><span id="l12.229"> </span>
<a href="#l12.230"></a><span id="l12.230"> bool nsIMAPNamespaceList::GetFolderIsNamespace(const char *hostName,</span>
<a href="#l12.231"></a><span id="l12.231">                                                  const char *canonicalFolderName,</span>
<a href="#l12.232"></a><span id="l12.232">                                                  char delimiter,nsIMAPNamespace *namespaceForFolder)</span>
<a href="#l12.233"></a><span id="l12.233"> {</span>
<a href="#l12.234"></a><span id="l12.234">   NS_ASSERTION(namespaceForFolder, &quot;null namespace&quot;);</span>
<a href="#l12.235"></a><span id="l12.235" class="difflineminus">-  </span>
<a href="#l12.236"></a><span id="l12.236" class="difflineplus">+</span>
<a href="#l12.237"></a><span id="l12.237">   bool rv = false;</span>
<a href="#l12.238"></a><span id="l12.238" class="difflineminus">-  </span>
<a href="#l12.239"></a><span id="l12.239" class="difflineplus">+</span>
<a href="#l12.240"></a><span id="l12.240">   const char *prefix = namespaceForFolder-&gt;GetPrefix();</span>
<a href="#l12.241"></a><span id="l12.241">   NS_ASSERTION(prefix, &quot;namespace has no prefix&quot;);</span>
<a href="#l12.242"></a><span id="l12.242">   if (!prefix || !*prefix)	// empty namespace prefix</span>
<a href="#l12.243"></a><span id="l12.243">     return false;</span>
<a href="#l12.244"></a><span id="l12.244" class="difflineminus">-  </span>
<a href="#l12.245"></a><span id="l12.245" class="difflineplus">+</span>
<a href="#l12.246"></a><span id="l12.246">   char *convertedFolderName = AllocateServerFolderName(canonicalFolderName, delimiter);</span>
<a href="#l12.247"></a><span id="l12.247">   if (convertedFolderName)</span>
<a href="#l12.248"></a><span id="l12.248">   {</span>
<a href="#l12.249"></a><span id="l12.249">     bool lastCharIsDelimiter = (prefix[strlen(prefix) - 1] == delimiter);</span>
<a href="#l12.250"></a><span id="l12.250" class="difflineminus">-    </span>
<a href="#l12.251"></a><span id="l12.251" class="difflineplus">+</span>
<a href="#l12.252"></a><span id="l12.252">     if (lastCharIsDelimiter)</span>
<a href="#l12.253"></a><span id="l12.253">     {</span>
<a href="#l12.254"></a><span id="l12.254">       rv = ((strncmp(convertedFolderName, prefix, strlen(convertedFolderName)) == 0) &amp;&amp;</span>
<a href="#l12.255"></a><span id="l12.255">         (strlen(convertedFolderName) == strlen(prefix) - 1));</span>
<a href="#l12.256"></a><span id="l12.256">     }</span>
<a href="#l12.257"></a><span id="l12.257">     else</span>
<a href="#l12.258"></a><span id="l12.258">     {</span>
<a href="#l12.259"></a><span id="l12.259">       rv = (strcmp(convertedFolderName, prefix) == 0);</span>
<a href="#l12.260"></a><span id="l12.260">     }</span>
<a href="#l12.261"></a><span id="l12.261" class="difflineminus">-    </span>
<a href="#l12.262"></a><span id="l12.262" class="difflineplus">+</span>
<a href="#l12.263"></a><span id="l12.263">     PR_Free(convertedFolderName);</span>
<a href="#l12.264"></a><span id="l12.264">   }</span>
<a href="#l12.265"></a><span id="l12.265">   else</span>
<a href="#l12.266"></a><span id="l12.266">   {</span>
<a href="#l12.267"></a><span id="l12.267">     NS_ASSERTION(false, &quot;couldn't allocate server folder name&quot;);</span>
<a href="#l12.268"></a><span id="l12.268">   }</span>
<a href="#l12.269"></a><span id="l12.269" class="difflineminus">-  </span>
<a href="#l12.270"></a><span id="l12.270" class="difflineplus">+</span>
<a href="#l12.271"></a><span id="l12.271">   return rv;</span>
<a href="#l12.272"></a><span id="l12.272"> }</span>
<a href="#l12.273"></a><span id="l12.273"> </span>
<a href="#l12.274"></a><span id="l12.274"> /*</span>
<a href="#l12.275"></a><span id="l12.275">   SuggestHierarchySeparatorForNamespace takes a namespace from libmsg</span>
<a href="#l12.276"></a><span id="l12.276">   and a hierarchy delimiter.  If the namespace has not been filled in from</span>
<a href="#l12.277"></a><span id="l12.277">   online NAMESPACE command yet, it fills in the suggested delimiter to be</span>
<a href="#l12.278"></a><span id="l12.278">   used from then on (until it is overridden by an online response).</span>
<a href="#l12.279"></a><span id="l12.279" class="difflineat">@@ -584,17 +584,17 @@ void nsIMAPNamespaceList::SuggestHierarc</span>
<a href="#l12.280"></a><span id="l12.280"> char *nsIMAPNamespaceList::GenerateFullFolderNameWithDefaultNamespace(const char *hostName,</span>
<a href="#l12.281"></a><span id="l12.281">                                                                                 const char *canonicalFolderName,</span>
<a href="#l12.282"></a><span id="l12.282">                                                                                 const char *owner,</span>
<a href="#l12.283"></a><span id="l12.283">                                                                                 EIMAPNamespaceType nsType,</span>
<a href="#l12.284"></a><span id="l12.284">                                                                                 nsIMAPNamespace **nsUsed)</span>
<a href="#l12.285"></a><span id="l12.285"> {</span>
<a href="#l12.286"></a><span id="l12.286">   nsresult rv = NS_OK;</span>
<a href="#l12.287"></a><span id="l12.287"> </span>
<a href="#l12.288"></a><span id="l12.288" class="difflineminus">-  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession = </span>
<a href="#l12.289"></a><span id="l12.289" class="difflineplus">+  nsCOMPtr&lt;nsIImapHostSessionList&gt; hostSession =</span>
<a href="#l12.290"></a><span id="l12.290">            do_GetService(kCImapHostSessionListCID, &amp;rv);</span>
<a href="#l12.291"></a><span id="l12.291">   NS_ENSURE_SUCCESS(rv, nullptr);</span>
<a href="#l12.292"></a><span id="l12.292">   nsIMAPNamespace *ns;</span>
<a href="#l12.293"></a><span id="l12.293">   char *fullFolderName = nullptr;</span>
<a href="#l12.294"></a><span id="l12.294">   rv = hostSession-&gt;GetDefaultNamespaceOfTypeForHost(hostName, nsType, ns);</span>
<a href="#l12.295"></a><span id="l12.295">   NS_ENSURE_SUCCESS(rv, nullptr);</span>
<a href="#l12.296"></a><span id="l12.296">   if (ns)</span>
<a href="#l12.297"></a><span id="l12.297">   {</span>
<a href="#l12.298"></a><span id="l12.298" class="difflineat">@@ -608,17 +608,17 @@ char *nsIMAPNamespaceList::GenerateFullF</span>
<a href="#l12.299"></a><span id="l12.299">       if (owner)</span>
<a href="#l12.300"></a><span id="l12.300">       {</span>
<a href="#l12.301"></a><span id="l12.301">         convertedReturnName = PR_smprintf(&quot;%s%s%c%s&quot;, prefix, owner, ns-&gt;GetDelimiter(), convertedFolderName);</span>
<a href="#l12.302"></a><span id="l12.302">       }</span>
<a href="#l12.303"></a><span id="l12.303">       else</span>
<a href="#l12.304"></a><span id="l12.304">       {</span>
<a href="#l12.305"></a><span id="l12.305">         convertedReturnName = PR_smprintf(&quot;%s%s&quot;, prefix, convertedFolderName);</span>
<a href="#l12.306"></a><span id="l12.306">       }</span>
<a href="#l12.307"></a><span id="l12.307" class="difflineminus">-      </span>
<a href="#l12.308"></a><span id="l12.308" class="difflineplus">+</span>
<a href="#l12.309"></a><span id="l12.309">       if (convertedReturnName)</span>
<a href="#l12.310"></a><span id="l12.310">       {</span>
<a href="#l12.311"></a><span id="l12.311">         fullFolderName = AllocateCanonicalFolderName(convertedReturnName, ns-&gt;GetDelimiter());</span>
<a href="#l12.312"></a><span id="l12.312">         PR_Free(convertedReturnName);</span>
<a href="#l12.313"></a><span id="l12.313">       }</span>
<a href="#l12.314"></a><span id="l12.314">       PR_Free(convertedFolderName);</span>
<a href="#l12.315"></a><span id="l12.315">     }</span>
<a href="#l12.316"></a><span id="l12.316">     else</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/imap/src/nsIMAPNamespace.h</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/imap/src/nsIMAPNamespace.h</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -5,62 +5,62 @@</span>
<a href="#l13.4"></a><span id="l13.4"> </span>
<a href="#l13.5"></a><span id="l13.5"> #ifndef _nsIMAPNamespace_H_</span>
<a href="#l13.6"></a><span id="l13.6"> #define _nsIMAPNamespace_H_</span>
<a href="#l13.7"></a><span id="l13.7"> </span>
<a href="#l13.8"></a><span id="l13.8"> #include &quot;nsTArray.h&quot;</span>
<a href="#l13.9"></a><span id="l13.9"> </span>
<a href="#l13.10"></a><span id="l13.10"> class nsIMAPNamespace</span>
<a href="#l13.11"></a><span id="l13.11"> {</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-  </span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+</span>
<a href="#l13.14"></a><span id="l13.14"> public:</span>
<a href="#l13.15"></a><span id="l13.15">   nsIMAPNamespace(EIMAPNamespaceType type, const char *prefix, char delimiter, bool from_prefs);</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineminus">-  </span>
<a href="#l13.17"></a><span id="l13.17" class="difflineplus">+</span>
<a href="#l13.18"></a><span id="l13.18">   ~nsIMAPNamespace();</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineminus">-  </span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+</span>
<a href="#l13.21"></a><span id="l13.21">   EIMAPNamespaceType    GetType() { return m_namespaceType; }</span>
<a href="#l13.22"></a><span id="l13.22">   const char *          GetPrefix() { return m_prefix; }</span>
<a href="#l13.23"></a><span id="l13.23">   char                  GetDelimiter() { return m_delimiter; }</span>
<a href="#l13.24"></a><span id="l13.24">   void                  SetDelimiter(char delimiter, bool delimiterFilledIn);</span>
<a href="#l13.25"></a><span id="l13.25">   bool                  GetIsDelimiterFilledIn() { return m_delimiterFilledIn; }</span>
<a href="#l13.26"></a><span id="l13.26">   bool                  GetIsNamespaceFromPrefs() { return m_fromPrefs; }</span>
<a href="#l13.27"></a><span id="l13.27" class="difflineminus">-  </span>
<a href="#l13.28"></a><span id="l13.28" class="difflineplus">+</span>
<a href="#l13.29"></a><span id="l13.29">   // returns -1 if this box is not part of this namespace,</span>
<a href="#l13.30"></a><span id="l13.30">   // or the length of the prefix if it is part of this namespace</span>
<a href="#l13.31"></a><span id="l13.31">   int                   MailboxMatchesNamespace(const char *boxname);</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineminus">-  </span>
<a href="#l13.33"></a><span id="l13.33" class="difflineplus">+</span>
<a href="#l13.34"></a><span id="l13.34"> protected:</span>
<a href="#l13.35"></a><span id="l13.35">   EIMAPNamespaceType m_namespaceType;</span>
<a href="#l13.36"></a><span id="l13.36">   char    *m_prefix;</span>
<a href="#l13.37"></a><span id="l13.37">   char    m_delimiter;</span>
<a href="#l13.38"></a><span id="l13.38">   bool    m_fromPrefs;</span>
<a href="#l13.39"></a><span id="l13.39">   bool    m_delimiterFilledIn;</span>
<a href="#l13.40"></a><span id="l13.40" class="difflineminus">-  </span>
<a href="#l13.41"></a><span id="l13.41" class="difflineplus">+</span>
<a href="#l13.42"></a><span id="l13.42"> };</span>
<a href="#l13.43"></a><span id="l13.43"> </span>
<a href="#l13.44"></a><span id="l13.44"> </span>
<a href="#l13.45"></a><span id="l13.45"> // represents an array of namespaces for a given host</span>
<a href="#l13.46"></a><span id="l13.46"> class nsIMAPNamespaceList</span>
<a href="#l13.47"></a><span id="l13.47"> {</span>
<a href="#l13.48"></a><span id="l13.48"> public:</span>
<a href="#l13.49"></a><span id="l13.49">   ~nsIMAPNamespaceList();</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineminus">-  </span>
<a href="#l13.51"></a><span id="l13.51" class="difflineplus">+</span>
<a href="#l13.52"></a><span id="l13.52">   static nsIMAPNamespaceList *CreatensIMAPNamespaceList();</span>
<a href="#l13.53"></a><span id="l13.53" class="difflineminus">-  </span>
<a href="#l13.54"></a><span id="l13.54" class="difflineplus">+</span>
<a href="#l13.55"></a><span id="l13.55">   nsresult InitFromString(const char *nameSpaceString, EIMAPNamespaceType nstype);</span>
<a href="#l13.56"></a><span id="l13.56">   nsresult OutputToString(nsCString &amp;OutputString);</span>
<a href="#l13.57"></a><span id="l13.57">   int UnserializeNamespaces(const char *str, char **prefixes, int len);</span>
<a href="#l13.58"></a><span id="l13.58">   nsresult SerializeNamespaces(char **prefixes, int len, nsCString &amp;serializedNamespace);</span>
<a href="#l13.59"></a><span id="l13.59" class="difflineminus">-  </span>
<a href="#l13.60"></a><span id="l13.60" class="difflineplus">+</span>
<a href="#l13.61"></a><span id="l13.61">   void ClearNamespaces(bool deleteFromPrefsNamespaces, bool deleteServerAdvertisedNamespaces, bool reallyDelete);</span>
<a href="#l13.62"></a><span id="l13.62">   int	GetNumberOfNamespaces();</span>
<a href="#l13.63"></a><span id="l13.63">   int	GetNumberOfNamespaces(EIMAPNamespaceType);</span>
<a href="#l13.64"></a><span id="l13.64">   nsIMAPNamespace *GetNamespaceNumber(int nodeIndex);</span>
<a href="#l13.65"></a><span id="l13.65">   nsIMAPNamespace *GetNamespaceNumber(int nodeIndex, EIMAPNamespaceType);</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineminus">-  </span>
<a href="#l13.67"></a><span id="l13.67" class="difflineplus">+</span>
<a href="#l13.68"></a><span id="l13.68">   nsIMAPNamespace *GetDefaultNamespaceOfType(EIMAPNamespaceType type);</span>
<a href="#l13.69"></a><span id="l13.69">   int AddNewNamespace(nsIMAPNamespace *ns);</span>
<a href="#l13.70"></a><span id="l13.70">   nsIMAPNamespace *GetNamespaceForMailbox(const char *boxname);</span>
<a href="#l13.71"></a><span id="l13.71">   static nsIMAPNamespace* GetNamespaceForFolder(const char *hostName,</span>
<a href="#l13.72"></a><span id="l13.72">                                            const char *canonicalFolderName,</span>
<a href="#l13.73"></a><span id="l13.73">                                            char delimiter);</span>
<a href="#l13.74"></a><span id="l13.74">   static bool GetFolderIsNamespace(const char *hostName,</span>
<a href="#l13.75"></a><span id="l13.75">                               const char *canonicalFolderName,</span>
<a href="#l13.76"></a><span id="l13.76" class="difflineat">@@ -73,15 +73,15 @@ public:</span>
<a href="#l13.77"></a><span id="l13.77">   static char *GenerateFullFolderNameWithDefaultNamespace(const char *hostName,</span>
<a href="#l13.78"></a><span id="l13.78">                                                                                 const char *canonicalFolderName,</span>
<a href="#l13.79"></a><span id="l13.79">                                                                                 const char *owner,</span>
<a href="#l13.80"></a><span id="l13.80">                                                                                 EIMAPNamespaceType nsType,</span>
<a href="#l13.81"></a><span id="l13.81">                                                                                 nsIMAPNamespace **nsUsed);</span>
<a href="#l13.82"></a><span id="l13.82"> </span>
<a href="#l13.83"></a><span id="l13.83"> protected:</span>
<a href="#l13.84"></a><span id="l13.84">   nsIMAPNamespaceList();	// use CreatensIMAPNamespaceList to create one</span>
<a href="#l13.85"></a><span id="l13.85" class="difflineminus">-  </span>
<a href="#l13.86"></a><span id="l13.86" class="difflineplus">+</span>
<a href="#l13.87"></a><span id="l13.87">   nsTArray&lt;nsIMAPNamespace*&gt; m_NamespaceList;</span>
<a href="#l13.88"></a><span id="l13.88" class="difflineminus">-  </span>
<a href="#l13.89"></a><span id="l13.89" class="difflineplus">+</span>
<a href="#l13.90"></a><span id="l13.90"> };</span>
<a href="#l13.91"></a><span id="l13.91"> </span>
<a href="#l13.92"></a><span id="l13.92"> </span>
<a href="#l13.93"></a><span id="l13.93"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/imap/src/nsImapCore.h</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapCore.h</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -145,17 +145,17 @@ const eIMAPCapabilityFlag kHasMoveCapabi</span>
<a href="#l14.4"></a><span id="l14.4"> const eIMAPCapabilityFlag kHasHighestModSeqCapability = 0x80000000;  /* Subset of RFC 3551 */</span>
<a href="#l14.5"></a><span id="l14.5"> // above are 32bit; below start the uint64_t bits 33-64</span>
<a href="#l14.6"></a><span id="l14.6"> const eIMAPCapabilityFlag kHasListExtendedCapability = 0x100000000LL;  /* RFC 5258 */</span>
<a href="#l14.7"></a><span id="l14.7"> const eIMAPCapabilityFlag kHasSpecialUseCapability = 0x200000000LL;  /* RFC 6154: Sent, Draft etc. folders */</span>
<a href="#l14.8"></a><span id="l14.8"> const eIMAPCapabilityFlag kGmailImapCapability = 0x400000000LL;  /* X-GM-EXT-1 capability extension for gmail */</span>
<a href="#l14.9"></a><span id="l14.9"> const eIMAPCapabilityFlag kHasXOAuth2Capability = 0x800000000LL;  /* AUTH XOAUTH2 extension */</span>
<a href="#l14.10"></a><span id="l14.10"> </span>
<a href="#l14.11"></a><span id="l14.11"> </span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-// this used to be part of the connection object class - maybe we should move it into </span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+// this used to be part of the connection object class - maybe we should move it into</span>
<a href="#l14.14"></a><span id="l14.14"> // something similar</span>
<a href="#l14.15"></a><span id="l14.15"> typedef enum {</span>
<a href="#l14.16"></a><span id="l14.16">     kEveryThingRFC822,</span>
<a href="#l14.17"></a><span id="l14.17">     kEveryThingRFC822Peek,</span>
<a href="#l14.18"></a><span id="l14.18">     kHeadersRFC822andUid,</span>
<a href="#l14.19"></a><span id="l14.19">     kUid,</span>
<a href="#l14.20"></a><span id="l14.20">     kFlags,</span>
<a href="#l14.21"></a><span id="l14.21">     kRFC822Size,</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineat">@@ -177,12 +177,12 @@ typedef struct _ProgressInfo {</span>
<a href="#l14.23"></a><span id="l14.23">   int32_t maxProgress;</span>
<a href="#l14.24"></a><span id="l14.24"> } ProgressInfo;</span>
<a href="#l14.25"></a><span id="l14.25"> </span>
<a href="#l14.26"></a><span id="l14.26"> typedef enum {</span>
<a href="#l14.27"></a><span id="l14.27">     eContinue,</span>
<a href="#l14.28"></a><span id="l14.28">     eContinueNew,</span>
<a href="#l14.29"></a><span id="l14.29">     eListMyChildren,</span>
<a href="#l14.30"></a><span id="l14.30">     eNewServerDirectory,</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineminus">-    eCancelled </span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+    eCancelled</span>
<a href="#l14.33"></a><span id="l14.33"> } EMailboxDiscoverStatus;</span>
<a href="#l14.34"></a><span id="l14.34"> </span>
<a href="#l14.35"></a><span id="l14.35"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/imap/src/nsImapFlagAndUidState.cpp</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapFlagAndUidState.cpp</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -46,30 +46,30 @@ NS_IMETHODIMP nsImapFlagAndUidState::Set</span>
<a href="#l15.4"></a><span id="l15.4">     fFlags[zeroBasedIndex] = flags;</span>
<a href="#l15.5"></a><span id="l15.5">   return NS_OK;</span>
<a href="#l15.6"></a><span id="l15.6"> }</span>
<a href="#l15.7"></a><span id="l15.7"> </span>
<a href="#l15.8"></a><span id="l15.8"> NS_IMETHODIMP nsImapFlagAndUidState::GetNumberOfRecentMessages(int32_t *result)</span>
<a href="#l15.9"></a><span id="l15.9"> {</span>
<a href="#l15.10"></a><span id="l15.10">   if (!result)</span>
<a href="#l15.11"></a><span id="l15.11">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-  </span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+</span>
<a href="#l15.14"></a><span id="l15.14">   PR_CEnterMonitor(this);</span>
<a href="#l15.15"></a><span id="l15.15">   uint32_t counter = 0;</span>
<a href="#l15.16"></a><span id="l15.16">   int32_t numUnseenMessages = 0;</span>
<a href="#l15.17"></a><span id="l15.17" class="difflineminus">-  </span>
<a href="#l15.18"></a><span id="l15.18" class="difflineplus">+</span>
<a href="#l15.19"></a><span id="l15.19">   for (counter = 0; counter &lt; fUids.Length(); counter++)</span>
<a href="#l15.20"></a><span id="l15.20">   {</span>
<a href="#l15.21"></a><span id="l15.21">     if (fFlags[counter] &amp; kImapMsgRecentFlag)</span>
<a href="#l15.22"></a><span id="l15.22">       numUnseenMessages++;</span>
<a href="#l15.23"></a><span id="l15.23">   }</span>
<a href="#l15.24"></a><span id="l15.24">   PR_CExitMonitor(this);</span>
<a href="#l15.25"></a><span id="l15.25" class="difflineminus">-  </span>
<a href="#l15.26"></a><span id="l15.26" class="difflineplus">+</span>
<a href="#l15.27"></a><span id="l15.27">   *result = numUnseenMessages;</span>
<a href="#l15.28"></a><span id="l15.28" class="difflineminus">-  </span>
<a href="#l15.29"></a><span id="l15.29" class="difflineplus">+</span>
<a href="#l15.30"></a><span id="l15.30">   return NS_OK;</span>
<a href="#l15.31"></a><span id="l15.31"> }</span>
<a href="#l15.32"></a><span id="l15.32"> </span>
<a href="#l15.33"></a><span id="l15.33"> NS_IMETHODIMP nsImapFlagAndUidState::GetPartialUIDFetch(bool *aPartialUIDFetch)</span>
<a href="#l15.34"></a><span id="l15.34"> {</span>
<a href="#l15.35"></a><span id="l15.35">   NS_ENSURE_ARG_POINTER(aPartialUIDFetch);</span>
<a href="#l15.36"></a><span id="l15.36">   *aPartialUIDFetch = fPartialUIDFetch;</span>
<a href="#l15.37"></a><span id="l15.37">   return NS_OK;</span>
<a href="#l15.38"></a><span id="l15.38" class="difflineat">@@ -184,17 +184,17 @@ int32_t nsImapFlagAndUidState::NumberOfD</span>
<a href="#l15.39"></a><span id="l15.39">   return fNumberDeleted;</span>
<a href="#l15.40"></a><span id="l15.40"> }</span>
<a href="#l15.41"></a><span id="l15.41"> 	</span>
<a href="#l15.42"></a><span id="l15.42"> // since the uids are sorted, start from the back (rb)</span>
<a href="#l15.43"></a><span id="l15.43"> </span>
<a href="#l15.44"></a><span id="l15.44"> uint32_t  nsImapFlagAndUidState::GetHighestNonDeletedUID()</span>
<a href="#l15.45"></a><span id="l15.45"> {</span>
<a href="#l15.46"></a><span id="l15.46">   uint32_t msgIndex = fUids.Length();</span>
<a href="#l15.47"></a><span id="l15.47" class="difflineminus">-  do </span>
<a href="#l15.48"></a><span id="l15.48" class="difflineplus">+  do</span>
<a href="#l15.49"></a><span id="l15.49">   {</span>
<a href="#l15.50"></a><span id="l15.50">     if (msgIndex &lt;= 0)</span>
<a href="#l15.51"></a><span id="l15.51">       return(0);</span>
<a href="#l15.52"></a><span id="l15.52">     msgIndex--;</span>
<a href="#l15.53"></a><span id="l15.53">     if (fUids[msgIndex] &amp;&amp; !(fFlags[msgIndex] &amp; kImapMsgDeletedFlag))</span>
<a href="#l15.54"></a><span id="l15.54">       return fUids[msgIndex];</span>
<a href="#l15.55"></a><span id="l15.55">   }</span>
<a href="#l15.56"></a><span id="l15.56">   while (msgIndex &gt; 0);</span>
<a href="#l15.57"></a><span id="l15.57" class="difflineat">@@ -203,24 +203,24 @@ uint32_t  nsImapFlagAndUidState::GetHigh</span>
<a href="#l15.58"></a><span id="l15.58"> </span>
<a href="#l15.59"></a><span id="l15.59"> </span>
<a href="#l15.60"></a><span id="l15.60"> // Has the user read the last message here ? Used when we first open the inbox to see if there</span>
<a href="#l15.61"></a><span id="l15.61"> // really is new mail there.</span>
<a href="#l15.62"></a><span id="l15.62"> </span>
<a href="#l15.63"></a><span id="l15.63"> bool nsImapFlagAndUidState::IsLastMessageUnseen()</span>
<a href="#l15.64"></a><span id="l15.64"> {</span>
<a href="#l15.65"></a><span id="l15.65">   uint32_t msgIndex = fUids.Length();</span>
<a href="#l15.66"></a><span id="l15.66" class="difflineminus">-  </span>
<a href="#l15.67"></a><span id="l15.67" class="difflineplus">+</span>
<a href="#l15.68"></a><span id="l15.68">   if (msgIndex &lt;= 0)</span>
<a href="#l15.69"></a><span id="l15.69">     return false;</span>
<a href="#l15.70"></a><span id="l15.70">   msgIndex--;</span>
<a href="#l15.71"></a><span id="l15.71">   // if last message is deleted, it was probably filtered the last time around</span>
<a href="#l15.72"></a><span id="l15.72">   if (fUids[msgIndex] &amp;&amp; (fFlags[msgIndex] &amp; (kImapMsgSeenFlag | kImapMsgDeletedFlag)))</span>
<a href="#l15.73"></a><span id="l15.73">     return false;</span>
<a href="#l15.74"></a><span id="l15.74" class="difflineminus">-  return true; </span>
<a href="#l15.75"></a><span id="l15.75" class="difflineplus">+  return true;</span>
<a href="#l15.76"></a><span id="l15.76"> }</span>
<a href="#l15.77"></a><span id="l15.77"> </span>
<a href="#l15.78"></a><span id="l15.78"> // find a message flag given a key with non-recursive binary search, since some folders</span>
<a href="#l15.79"></a><span id="l15.79"> // may have thousand of messages, once we find the key set its index, or the index of</span>
<a href="#l15.80"></a><span id="l15.80"> // where the key should be inserted</span>
<a href="#l15.81"></a><span id="l15.81"> </span>
<a href="#l15.82"></a><span id="l15.82"> imapMessageFlagsType nsImapFlagAndUidState::GetMessageFlagsFromUID(uint32_t uid, bool *foundIt, int32_t *ndx)</span>
<a href="#l15.83"></a><span id="l15.83"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/imap/src/nsImapFlagAndUidState.h</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapFlagAndUidState.h</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -20,17 +20,17 @@ class nsImapFlagAndUidState : public nsI</span>
<a href="#l16.4"></a><span id="l16.4"> {</span>
<a href="#l16.5"></a><span id="l16.5"> public:</span>
<a href="#l16.6"></a><span id="l16.6">     NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l16.7"></a><span id="l16.7">     nsImapFlagAndUidState(int numberOfMessages);</span>
<a href="#l16.8"></a><span id="l16.8"> </span>
<a href="#l16.9"></a><span id="l16.9">     NS_DECL_NSIIMAPFLAGANDUIDSTATE</span>
<a href="#l16.10"></a><span id="l16.10"> </span>
<a href="#l16.11"></a><span id="l16.11">     int32_t               NumberOfDeletedMessages();</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-    </span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+</span>
<a href="#l16.14"></a><span id="l16.14">     imapMessageFlagsType  GetMessageFlagsFromUID(uint32_t uid, bool *foundIt, int32_t *ndx);</span>
<a href="#l16.15"></a><span id="l16.15"> </span>
<a href="#l16.16"></a><span id="l16.16">     bool         IsLastMessageUnseen(void);</span>
<a href="#l16.17"></a><span id="l16.17">     bool         GetPartialUIDFetch() {return fPartialUIDFetch;}</span>
<a href="#l16.18"></a><span id="l16.18">     void         SetPartialUIDFetch(bool isPartial) {fPartialUIDFetch = isPartial;}</span>
<a href="#l16.19"></a><span id="l16.19">     uint32_t     GetHighestNonDeletedUID();</span>
<a href="#l16.20"></a><span id="l16.20">     uint16_t     GetSupportedUserFlags() { return fSupportedUserFlags; }</span>
<a href="#l16.21"></a><span id="l16.21"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -2538,17 +2538,17 @@ nsImapIncomingServer::GetSubscribeListen</span>
<a href="#l17.4"></a><span id="l17.4">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l17.5"></a><span id="l17.5">   return mInner-&gt;GetSubscribeListener(aListener);</span>
<a href="#l17.6"></a><span id="l17.6"> }</span>
<a href="#l17.7"></a><span id="l17.7"> </span>
<a href="#l17.8"></a><span id="l17.8"> NS_IMETHODIMP</span>
<a href="#l17.9"></a><span id="l17.9"> nsImapIncomingServer::Subscribe(const char16_t *aName)</span>
<a href="#l17.10"></a><span id="l17.10"> {</span>
<a href="#l17.11"></a><span id="l17.11">   NS_ENSURE_ARG_POINTER(aName);</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-  </span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+</span>
<a href="#l17.14"></a><span id="l17.14">   return SubscribeToFolder(nsDependentString(aName), true, nullptr);</span>
<a href="#l17.15"></a><span id="l17.15"> }</span>
<a href="#l17.16"></a><span id="l17.16"> </span>
<a href="#l17.17"></a><span id="l17.17"> NS_IMETHODIMP</span>
<a href="#l17.18"></a><span id="l17.18"> nsImapIncomingServer::Unsubscribe(const char16_t *aName)</span>
<a href="#l17.19"></a><span id="l17.19"> {</span>
<a href="#l17.20"></a><span id="l17.20">   NS_ENSURE_ARG_POINTER(aName);</span>
<a href="#l17.21"></a><span id="l17.21"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -207,17 +207,17 @@ nsImapMailFolder::nsImapMailFolder() :</span>
<a href="#l18.4"></a><span id="l18.4">   m_supportedUserFlags = 0;</span>
<a href="#l18.5"></a><span id="l18.5">   m_namespace = nullptr;</span>
<a href="#l18.6"></a><span id="l18.6">   m_pendingPlaybackReq = nullptr;</span>
<a href="#l18.7"></a><span id="l18.7"> }</span>
<a href="#l18.8"></a><span id="l18.8"> </span>
<a href="#l18.9"></a><span id="l18.9"> nsImapMailFolder::~nsImapMailFolder()</span>
<a href="#l18.10"></a><span id="l18.10"> {</span>
<a href="#l18.11"></a><span id="l18.11">   delete m_folderACL;</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-    </span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+</span>
<a href="#l18.14"></a><span id="l18.14">   // cleanup any pending request</span>
<a href="#l18.15"></a><span id="l18.15">   delete m_pendingPlaybackReq;</span>
<a href="#l18.16"></a><span id="l18.16"> }</span>
<a href="#l18.17"></a><span id="l18.17"> </span>
<a href="#l18.18"></a><span id="l18.18"> NS_IMPL_ADDREF_INHERITED(nsImapMailFolder, nsMsgDBFolder)</span>
<a href="#l18.19"></a><span id="l18.19"> NS_IMPL_RELEASE_INHERITED(nsImapMailFolder, nsMsgDBFolder)</span>
<a href="#l18.20"></a><span id="l18.20"> NS_IMPL_QUERY_HEAD(nsImapMailFolder)</span>
<a href="#l18.21"></a><span id="l18.21">     NS_IMPL_QUERY_BODY(nsIMsgImapMailFolder)</span>
<a href="#l18.22"></a><span id="l18.22" class="difflineat">@@ -1262,17 +1262,17 @@ NS_IMETHODIMP nsImapMailFolder::ApplyRet</span>
<a href="#l18.23"></a><span id="l18.23">     rv = mDatabase-&gt;EnumerateMessages(getter_AddRefs(hdrs));</span>
<a href="#l18.24"></a><span id="l18.24">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.25"></a><span id="l18.25">     bool hasMore = false;</span>
<a href="#l18.26"></a><span id="l18.26"> </span>
<a href="#l18.27"></a><span id="l18.27">     PRTime cutOffDay =</span>
<a href="#l18.28"></a><span id="l18.28">       MsgConvertAgeInDaysToCutoffDate(numDaysToKeepOfflineMsgs);</span>
<a href="#l18.29"></a><span id="l18.29"> </span>
<a href="#l18.30"></a><span id="l18.30">     nsCOMPtr &lt;nsIMsgDBHdr&gt; pHeader;</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineminus">-    // so now cutOffDay is the PRTime cut-off point. Any offline msg with </span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+    // so now cutOffDay is the PRTime cut-off point. Any offline msg with</span>
<a href="#l18.33"></a><span id="l18.33">     // a date less than that will get marked for pending removal.</span>
<a href="#l18.34"></a><span id="l18.34">     while (NS_SUCCEEDED(rv = hdrs-&gt;HasMoreElements(&amp;hasMore)) &amp;&amp; hasMore)</span>
<a href="#l18.35"></a><span id="l18.35">     {</span>
<a href="#l18.36"></a><span id="l18.36">       nsCOMPtr&lt;nsISupports&gt; supports;</span>
<a href="#l18.37"></a><span id="l18.37">       rv = hdrs-&gt;GetNext(getter_AddRefs(supports));</span>
<a href="#l18.38"></a><span id="l18.38">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.39"></a><span id="l18.39">       pHeader = do_QueryInterface(supports, &amp;rv);</span>
<a href="#l18.40"></a><span id="l18.40">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.41"></a><span id="l18.41" class="difflineat">@@ -1951,17 +1951,17 @@ NS_IMETHODIMP nsImapMailFolder::ReadFrom</span>
<a href="#l18.42"></a><span id="l18.42">   element-&gt;GetInt32Property(&quot;nextUID&quot;, &amp;m_nextUID);</span>
<a href="#l18.43"></a><span id="l18.43">   int32_t lastSyncTimeInSec;</span>
<a href="#l18.44"></a><span id="l18.44">   if ( NS_FAILED(element-&gt;GetInt32Property(&quot;lastSyncTimeInSec&quot;, (int32_t *) &amp;lastSyncTimeInSec)) )</span>
<a href="#l18.45"></a><span id="l18.45">     lastSyncTimeInSec = 0U;</span>
<a href="#l18.46"></a><span id="l18.46"> </span>
<a href="#l18.47"></a><span id="l18.47">   // make sure that auto-sync state object is created</span>
<a href="#l18.48"></a><span id="l18.48">   InitAutoSyncState();</span>
<a href="#l18.49"></a><span id="l18.49">   m_autoSyncStateObj-&gt;SetLastSyncTimeInSec(lastSyncTimeInSec);</span>
<a href="#l18.50"></a><span id="l18.50" class="difflineminus">-  </span>
<a href="#l18.51"></a><span id="l18.51" class="difflineplus">+</span>
<a href="#l18.52"></a><span id="l18.52">   return rv;</span>
<a href="#l18.53"></a><span id="l18.53"> }</span>
<a href="#l18.54"></a><span id="l18.54"> </span>
<a href="#l18.55"></a><span id="l18.55"> NS_IMETHODIMP nsImapMailFolder::WriteToFolderCacheElem(nsIMsgFolderCacheElement *element)</span>
<a href="#l18.56"></a><span id="l18.56"> {</span>
<a href="#l18.57"></a><span id="l18.57">   nsresult rv = nsMsgDBFolder::WriteToFolderCacheElem(element);</span>
<a href="#l18.58"></a><span id="l18.58">   element-&gt;SetInt32Property(&quot;boxFlags&quot;, m_boxFlags);</span>
<a href="#l18.59"></a><span id="l18.59">   element-&gt;SetInt32Property(&quot;hierDelim&quot;, (int32_t) m_hierarchyDelimiter);</span>
<a href="#l18.60"></a><span id="l18.60" class="difflineat">@@ -1976,17 +1976,17 @@ NS_IMETHODIMP nsImapMailFolder::WriteToF</span>
<a href="#l18.61"></a><span id="l18.61">   // store folder's last sync time</span>
<a href="#l18.62"></a><span id="l18.62">   if (m_autoSyncStateObj)</span>
<a href="#l18.63"></a><span id="l18.63">   {</span>
<a href="#l18.64"></a><span id="l18.64">     PRTime lastSyncTime;</span>
<a href="#l18.65"></a><span id="l18.65">     m_autoSyncStateObj-&gt;GetLastSyncTime(&amp;lastSyncTime);</span>
<a href="#l18.66"></a><span id="l18.66">     // store in sec</span>
<a href="#l18.67"></a><span id="l18.67">     element-&gt;SetInt32Property(&quot;lastSyncTimeInSec&quot;, (int32_t) (lastSyncTime / PR_USEC_PER_SEC));</span>
<a href="#l18.68"></a><span id="l18.68">   }</span>
<a href="#l18.69"></a><span id="l18.69" class="difflineminus">-   </span>
<a href="#l18.70"></a><span id="l18.70" class="difflineplus">+</span>
<a href="#l18.71"></a><span id="l18.71">   return rv;</span>
<a href="#l18.72"></a><span id="l18.72"> }</span>
<a href="#l18.73"></a><span id="l18.73"> </span>
<a href="#l18.74"></a><span id="l18.74"> NS_IMETHODIMP</span>
<a href="#l18.75"></a><span id="l18.75"> nsImapMailFolder::MarkMessagesFlagged(nsIArray *messages, bool markFlagged)</span>
<a href="#l18.76"></a><span id="l18.76"> {</span>
<a href="#l18.77"></a><span id="l18.77">   nsresult rv;</span>
<a href="#l18.78"></a><span id="l18.78">   // tell the folder to do it, which will mark them read in the db.</span>
<a href="#l18.79"></a><span id="l18.79" class="difflineat">@@ -2797,24 +2797,24 @@ NS_IMETHODIMP nsImapMailFolder::UpdateIm</span>
<a href="#l18.80"></a><span id="l18.80">     }</span>
<a href="#l18.81"></a><span id="l18.81">     DeleteStoreMessages(hdrsToDelete);</span>
<a href="#l18.82"></a><span id="l18.82">     EnableNotifications(nsIMsgFolder::allMessageCountNotifications, false);</span>
<a href="#l18.83"></a><span id="l18.83">     mDatabase-&gt;DeleteMessages(keysToDelete.Length(), keysToDelete.Elements(), nullptr);</span>
<a href="#l18.84"></a><span id="l18.84">     EnableNotifications(nsIMsgFolder::allMessageCountNotifications, true);</span>
<a href="#l18.85"></a><span id="l18.85">   }</span>
<a href="#l18.86"></a><span id="l18.86">   int32_t numUnreadFromServer;</span>
<a href="#l18.87"></a><span id="l18.87">   aSpec-&gt;GetNumUnseenMessages(&amp;numUnreadFromServer);</span>
<a href="#l18.88"></a><span id="l18.88" class="difflineminus">-  </span>
<a href="#l18.89"></a><span id="l18.89" class="difflineplus">+</span>
<a href="#l18.90"></a><span id="l18.90">   bool partialUIDFetch;</span>
<a href="#l18.91"></a><span id="l18.91">   flagState-&gt;GetPartialUIDFetch(&amp;partialUIDFetch);</span>
<a href="#l18.92"></a><span id="l18.92" class="difflineminus">-  </span>
<a href="#l18.93"></a><span id="l18.93" class="difflineplus">+</span>
<a href="#l18.94"></a><span id="l18.94">   // For partial UID fetches, we can only trust the numUnread from the server.</span>
<a href="#l18.95"></a><span id="l18.95">   if (partialUIDFetch)</span>
<a href="#l18.96"></a><span id="l18.96">     numNewUnread = numUnreadFromServer;</span>
<a href="#l18.97"></a><span id="l18.97" class="difflineminus">-    </span>
<a href="#l18.98"></a><span id="l18.98" class="difflineplus">+</span>
<a href="#l18.99"></a><span id="l18.99">   // If we are performing biff for this folder, tell the</span>
<a href="#l18.100"></a><span id="l18.100">   // stand-alone biff about the new high water mark</span>
<a href="#l18.101"></a><span id="l18.101">   if (m_performingBiff &amp;&amp; numNewUnread)</span>
<a href="#l18.102"></a><span id="l18.102">   {</span>
<a href="#l18.103"></a><span id="l18.103">     // We must ensure that the server knows that we are performing biff.</span>
<a href="#l18.104"></a><span id="l18.104">     // Otherwise the stand-alone biff won't fire.</span>
<a href="#l18.105"></a><span id="l18.105">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l18.106"></a><span id="l18.106">     if (NS_SUCCEEDED(GetServer(getter_AddRefs(server))) &amp;&amp; server)</span>
<a href="#l18.107"></a><span id="l18.107" class="difflineat">@@ -3042,17 +3042,17 @@ nsresult nsImapMailFolder::NormalEndHead</span>
<a href="#l18.108"></a><span id="l18.108"> </span>
<a href="#l18.109"></a><span id="l18.109">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l18.110"></a><span id="l18.110">   rv = GetServer(getter_AddRefs(server));</span>
<a href="#l18.111"></a><span id="l18.111">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.112"></a><span id="l18.112"> </span>
<a href="#l18.113"></a><span id="l18.113">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer = do_QueryInterface(server);</span>
<a href="#l18.114"></a><span id="l18.114">   rv = imapServer-&gt;GetIsGMailServer(&amp;m_isGmailServer);</span>
<a href="#l18.115"></a><span id="l18.115">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.116"></a><span id="l18.116" class="difflineminus">-  </span>
<a href="#l18.117"></a><span id="l18.117" class="difflineplus">+</span>
<a href="#l18.118"></a><span id="l18.118">   newMsgHdr-&gt;SetMessageKey(m_curMsgUid);</span>
<a href="#l18.119"></a><span id="l18.119">   TweakHeaderFlags(aProtocol, newMsgHdr);</span>
<a href="#l18.120"></a><span id="l18.120">   uint32_t messageSize;</span>
<a href="#l18.121"></a><span id="l18.121">   if (NS_SUCCEEDED(newMsgHdr-&gt;GetMessageSize(&amp;messageSize)))</span>
<a href="#l18.122"></a><span id="l18.122">     mFolderSize += messageSize;</span>
<a href="#l18.123"></a><span id="l18.123">   m_msgMovedByFilter = false;</span>
<a href="#l18.124"></a><span id="l18.124"> </span>
<a href="#l18.125"></a><span id="l18.125">   nsMsgKey highestUID = 0;</span>
<a href="#l18.126"></a><span id="l18.126" class="difflineat">@@ -3421,17 +3421,17 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil</span>
<a href="#l18.127"></a><span id="l18.127">   //</span>
<a href="#l18.128"></a><span id="l18.128">   //  This routine is called indirectly from ApplyFiltersToHdr in two</span>
<a href="#l18.129"></a><span id="l18.129">   //  circumstances, controlled by m_filterListRequiresBody:</span>
<a href="#l18.130"></a><span id="l18.130">   //</span>
<a href="#l18.131"></a><span id="l18.131">   //  If false, after headers are parsed in NormalEndHeaderParseStream.</span>
<a href="#l18.132"></a><span id="l18.132">   //  If true, after the message body is downloaded in NormalEndMsgWriteStream.</span>
<a href="#l18.133"></a><span id="l18.133">   //</span>
<a href="#l18.134"></a><span id="l18.134">   //  In NormalEndHeaderParseStream, the message has not been added to the</span>
<a href="#l18.135"></a><span id="l18.135" class="difflineminus">-  //  database, and it is important that database notifications and count </span>
<a href="#l18.136"></a><span id="l18.136" class="difflineplus">+  //  database, and it is important that database notifications and count</span>
<a href="#l18.137"></a><span id="l18.137">   //  updates do not occur. In NormalEndMsgWriteStream, the message has been</span>
<a href="#l18.138"></a><span id="l18.138">   //  added to the database, and database notifications and count updates</span>
<a href="#l18.139"></a><span id="l18.139">   //  should be performed.</span>
<a href="#l18.140"></a><span id="l18.140">   //</span>
<a href="#l18.141"></a><span id="l18.141"> </span>
<a href="#l18.142"></a><span id="l18.142">   NS_ENSURE_ARG_POINTER(filter);</span>
<a href="#l18.143"></a><span id="l18.143">   NS_ENSURE_ARG_POINTER(applyMore);</span>
<a href="#l18.144"></a><span id="l18.144"> </span>
<a href="#l18.145"></a><span id="l18.145" class="difflineat">@@ -3539,17 +3539,17 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil</span>
<a href="#l18.146"></a><span id="l18.146">                mDatabase-&gt;MarkMDNNeeded(msgKey, false, nullptr);</span>
<a href="#l18.147"></a><span id="l18.147">                mDatabase-&gt;MarkMDNSent(msgKey, true, nullptr);</span>
<a href="#l18.148"></a><span id="l18.148">             }</span>
<a href="#l18.149"></a><span id="l18.149">             nsresult err = MoveIncorporatedMessage(msgHdr, mDatabase, actionTargetFolderUri, filter, msgWindow);</span>
<a href="#l18.150"></a><span id="l18.150">             if (NS_SUCCEEDED(err))</span>
<a href="#l18.151"></a><span id="l18.151">               m_msgMovedByFilter = true;</span>
<a href="#l18.152"></a><span id="l18.152">           }</span>
<a href="#l18.153"></a><span id="l18.153">           // don't apply any more filters, even if it was a move to the same folder</span>
<a href="#l18.154"></a><span id="l18.154" class="difflineminus">-          *applyMore = false; </span>
<a href="#l18.155"></a><span id="l18.155" class="difflineplus">+          *applyMore = false;</span>
<a href="#l18.156"></a><span id="l18.156">         }</span>
<a href="#l18.157"></a><span id="l18.157">         break;</span>
<a href="#l18.158"></a><span id="l18.158">         case nsMsgFilterAction::CopyToFolder:</span>
<a href="#l18.159"></a><span id="l18.159">         {</span>
<a href="#l18.160"></a><span id="l18.160">           nsCString uri;</span>
<a href="#l18.161"></a><span id="l18.161">           rv = GetURI(uri);</span>
<a href="#l18.162"></a><span id="l18.162"> </span>
<a href="#l18.163"></a><span id="l18.163">           if (!actionTargetFolderUri.Equals(uri))</span>
<a href="#l18.164"></a><span id="l18.164" class="difflineat">@@ -3679,17 +3679,17 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil</span>
<a href="#l18.165"></a><span id="l18.165">               junkScore == nsIJunkMailPlugin::IS_HAM_SCORE)</span>
<a href="#l18.166"></a><span id="l18.166">           {</span>
<a href="#l18.167"></a><span id="l18.167">             nsTArray&lt;nsMsgKey&gt; *keysToClassify = m_moveCoalescer-&gt;GetKeyBucket(</span>
<a href="#l18.168"></a><span id="l18.168">                        (junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE) ? 0 : 1);</span>
<a href="#l18.169"></a><span id="l18.169">             NS_ASSERTION(keysToClassify, &quot;error getting key bucket&quot;);</span>
<a href="#l18.170"></a><span id="l18.170">             if (keysToClassify)</span>
<a href="#l18.171"></a><span id="l18.171">               keysToClassify-&gt;AppendElement(msgKey);</span>
<a href="#l18.172"></a><span id="l18.172">             if (msgIsNew &amp;&amp; junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE)</span>
<a href="#l18.173"></a><span id="l18.173" class="difflineminus">-            {              </span>
<a href="#l18.174"></a><span id="l18.174" class="difflineplus">+            {</span>
<a href="#l18.175"></a><span id="l18.175">               msgIsNew = false;</span>
<a href="#l18.176"></a><span id="l18.176">               mDatabase-&gt;MarkHdrNotNew(msgHdr, nullptr);</span>
<a href="#l18.177"></a><span id="l18.177">               // nsMsgDBFolder::SendFlagNotifications by the call to</span>
<a href="#l18.178"></a><span id="l18.178">               // SetBiffState(nsMsgBiffState_NoMail) will reset numNewMessages</span>
<a href="#l18.179"></a><span id="l18.179">               // only if the message is also read and database notifications</span>
<a href="#l18.180"></a><span id="l18.180">               // are active, but we are not going to mark it read in this</span>
<a href="#l18.181"></a><span id="l18.181">               // action, preferring to leave the choice to the user.</span>
<a href="#l18.182"></a><span id="l18.182">               // So correct numNewMessages.</span>
<a href="#l18.183"></a><span id="l18.183" class="difflineat">@@ -3815,17 +3815,17 @@ NS_IMETHODIMP nsImapMailFolder::SetImapF</span>
<a href="#l18.184"></a><span id="l18.184"> NS_IMETHODIMP nsImapMailFolder::PlaybackOfflineFolderCreate(const nsAString&amp; aFolderName, nsIMsgWindow *aWindow, nsIURI **url)</span>
<a href="#l18.185"></a><span id="l18.185"> {</span>
<a href="#l18.186"></a><span id="l18.186">   nsresult rv;</span>
<a href="#l18.187"></a><span id="l18.187">   nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.188"></a><span id="l18.188">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.189"></a><span id="l18.189">   return imapService-&gt;CreateFolder(this, aFolderName, this, url);</span>
<a href="#l18.190"></a><span id="l18.190"> }</span>
<a href="#l18.191"></a><span id="l18.191"> </span>
<a href="#l18.192"></a><span id="l18.192" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l18.193"></a><span id="l18.193" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l18.194"></a><span id="l18.194"> nsImapMailFolder::ReplayOfflineMoveCopy(nsMsgKey *aMsgKeys, uint32_t aNumKeys,</span>
<a href="#l18.195"></a><span id="l18.195">                                         bool isMove, nsIMsgFolder *aDstFolder,</span>
<a href="#l18.196"></a><span id="l18.196">                                         nsIUrlListener *aUrlListener, nsIMsgWindow *aWindow)</span>
<a href="#l18.197"></a><span id="l18.197"> {</span>
<a href="#l18.198"></a><span id="l18.198">   nsresult rv;</span>
<a href="#l18.199"></a><span id="l18.199"> </span>
<a href="#l18.200"></a><span id="l18.200">   nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(aDstFolder);</span>
<a href="#l18.201"></a><span id="l18.201">   if (imapFolder)</span>
<a href="#l18.202"></a><span id="l18.202" class="difflineat">@@ -3834,19 +3834,19 @@ nsImapMailFolder::ReplayOfflineMoveCopy(</span>
<a href="#l18.203"></a><span id="l18.203">     nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l18.204"></a><span id="l18.204">     nsCOMPtr&lt;nsIMsgDatabase&gt; dstFolderDB;</span>
<a href="#l18.205"></a><span id="l18.205">     aDstFolder-&gt;GetMsgDatabase(getter_AddRefs(dstFolderDB));</span>
<a href="#l18.206"></a><span id="l18.206">     if (dstFolderDB)</span>
<a href="#l18.207"></a><span id="l18.207">     {</span>
<a href="#l18.208"></a><span id="l18.208">       // find the fake header in the destination db, and use that to</span>
<a href="#l18.209"></a><span id="l18.209">       // set the pending attributes on the real headers. To do this,</span>
<a href="#l18.210"></a><span id="l18.210">       // we need to iterate over the offline ops in the destination db,</span>
<a href="#l18.211"></a><span id="l18.211" class="difflineminus">-      // looking for ones with matching keys and source folder uri. </span>
<a href="#l18.212"></a><span id="l18.212" class="difflineplus">+      // looking for ones with matching keys and source folder uri.</span>
<a href="#l18.213"></a><span id="l18.213">       // If we find that offline op, its &quot;key&quot; will be the key of the fake</span>
<a href="#l18.214"></a><span id="l18.214" class="difflineminus">-      // header, so we just need to get the header for that key </span>
<a href="#l18.215"></a><span id="l18.215" class="difflineplus">+      // header, so we just need to get the header for that key</span>
<a href="#l18.216"></a><span id="l18.216">       // from the dest db.</span>
<a href="#l18.217"></a><span id="l18.217">       nsTArray&lt;nsMsgKey&gt; offlineOps;</span>
<a href="#l18.218"></a><span id="l18.218">       if (NS_SUCCEEDED(dstFolderDB-&gt;ListAllOfflineOpIds(&amp;offlineOps)))</span>
<a href="#l18.219"></a><span id="l18.219">       {</span>
<a href="#l18.220"></a><span id="l18.220">         nsCString srcFolderUri;</span>
<a href="#l18.221"></a><span id="l18.221">         GetURI(srcFolderUri);</span>
<a href="#l18.222"></a><span id="l18.222">         nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp;</span>
<a href="#l18.223"></a><span id="l18.223">         for (uint32_t opIndex = 0; opIndex &lt; offlineOps.Length(); opIndex++)</span>
<a href="#l18.224"></a><span id="l18.224" class="difflineat">@@ -4321,17 +4321,17 @@ void nsImapMailFolder::FindKeysToAdd(con</span>
<a href="#l18.225"></a><span id="l18.225">       if (uidOfMessage &amp;&amp; uidOfMessage != nsMsgKey_None &amp;&amp; (showDeletedMessages || ! (flags &amp; kImapMsgDeletedFlag)))</span>
<a href="#l18.226"></a><span id="l18.226">       {</span>
<a href="#l18.227"></a><span id="l18.227">         if (mDatabase)</span>
<a href="#l18.228"></a><span id="l18.228">         {</span>
<a href="#l18.229"></a><span id="l18.229">           bool dbContainsKey;</span>
<a href="#l18.230"></a><span id="l18.230">           if (NS_SUCCEEDED(mDatabase-&gt;ContainsKey(uidOfMessage, &amp;dbContainsKey)) &amp;&amp;</span>
<a href="#l18.231"></a><span id="l18.231">               dbContainsKey)</span>
<a href="#l18.232"></a><span id="l18.232">           {</span>
<a href="#l18.233"></a><span id="l18.233" class="difflineminus">-            // this is expected in the partial uid fetch case because the </span>
<a href="#l18.234"></a><span id="l18.234" class="difflineplus">+            // this is expected in the partial uid fetch case because the</span>
<a href="#l18.235"></a><span id="l18.235">             // flag state does not contain all messages, so the db has</span>
<a href="#l18.236"></a><span id="l18.236">             // messages the flag state doesn't know about.</span>
<a href="#l18.237"></a><span id="l18.237">             if (!partialUIDFetch)</span>
<a href="#l18.238"></a><span id="l18.238">               NS_ERROR(&quot;db has key - flagState messed up?&quot;);</span>
<a href="#l18.239"></a><span id="l18.239">             continue;</span>
<a href="#l18.240"></a><span id="l18.240">           }</span>
<a href="#l18.241"></a><span id="l18.241">         }</span>
<a href="#l18.242"></a><span id="l18.242">         keysToFetch.AppendElement(uidOfMessage);</span>
<a href="#l18.243"></a><span id="l18.243" class="difflineat">@@ -4807,17 +4807,17 @@ nsresult nsImapMailFolder::HandleCustomF</span>
<a href="#l18.244"></a><span id="l18.244">     nsAutoCString msgJunkScore;</span>
<a href="#l18.245"></a><span id="l18.245">     msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_SPAM_SCORE);</span>
<a href="#l18.246"></a><span id="l18.246">     mDatabase-&gt;SetStringProperty(uidOfMessage, &quot;junkscore&quot;, msgJunkScore.get());</span>
<a href="#l18.247"></a><span id="l18.247">   }</span>
<a href="#l18.248"></a><span id="l18.248">   else</span>
<a href="#l18.249"></a><span id="l18.249">     messageClassified = false;</span>
<a href="#l18.250"></a><span id="l18.250">   if (messageClassified)</span>
<a href="#l18.251"></a><span id="l18.251">   {</span>
<a href="#l18.252"></a><span id="l18.252" class="difflineminus">-    // only set the junkscore origin if it wasn't set before. </span>
<a href="#l18.253"></a><span id="l18.253" class="difflineplus">+    // only set the junkscore origin if it wasn't set before.</span>
<a href="#l18.254"></a><span id="l18.254">     nsCString existingProperty;</span>
<a href="#l18.255"></a><span id="l18.255">     dbHdr-&gt;GetStringProperty(&quot;junkscoreorigin&quot;, getter_Copies(existingProperty));</span>
<a href="#l18.256"></a><span id="l18.256">     if (existingProperty.IsEmpty())</span>
<a href="#l18.257"></a><span id="l18.257">       dbHdr-&gt;SetStringProperty(&quot;junkscoreorigin&quot;, &quot;imapflag&quot;);</span>
<a href="#l18.258"></a><span id="l18.258">   }</span>
<a href="#l18.259"></a><span id="l18.259">   return (userFlags &amp; kImapMsgSupportUserFlag) ?</span>
<a href="#l18.260"></a><span id="l18.260">           dbHdr-&gt;SetStringProperty(&quot;keywords&quot;, keywords.get()) : NS_OK;</span>
<a href="#l18.261"></a><span id="l18.261"> }</span>
<a href="#l18.262"></a><span id="l18.262" class="difflineat">@@ -4829,17 +4829,17 @@ nsresult nsImapMailFolder::SyncFlags(nsI</span>
<a href="#l18.263"></a><span id="l18.263">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.264"></a><span id="l18.264">   bool partialUIDFetch;</span>
<a href="#l18.265"></a><span id="l18.265">   flagState-&gt;GetPartialUIDFetch(&amp;partialUIDFetch);</span>
<a href="#l18.266"></a><span id="l18.266"> </span>
<a href="#l18.267"></a><span id="l18.267">   // update all of the database flags</span>
<a href="#l18.268"></a><span id="l18.268">   int32_t messageIndex;</span>
<a href="#l18.269"></a><span id="l18.269">   uint32_t messageSize;</span>
<a href="#l18.270"></a><span id="l18.270"> </span>
<a href="#l18.271"></a><span id="l18.271" class="difflineminus">-  // Take this opportunity to recalculate the folder size, if we're not a </span>
<a href="#l18.272"></a><span id="l18.272" class="difflineplus">+  // Take this opportunity to recalculate the folder size, if we're not a</span>
<a href="#l18.273"></a><span id="l18.273">   // partial (condstore) fetch.</span>
<a href="#l18.274"></a><span id="l18.274">   int64_t newFolderSize = 0;</span>
<a href="#l18.275"></a><span id="l18.275"> </span>
<a href="#l18.276"></a><span id="l18.276">   flagState-&gt;GetNumberOfMessages(&amp;messageIndex);</span>
<a href="#l18.277"></a><span id="l18.277"> </span>
<a href="#l18.278"></a><span id="l18.278">   uint16_t supportedUserFlags;</span>
<a href="#l18.279"></a><span id="l18.279">   flagState-&gt;GetSupportedUserFlags(&amp;supportedUserFlags);</span>
<a href="#l18.280"></a><span id="l18.280"> </span>
<a href="#l18.281"></a><span id="l18.281" class="difflineat">@@ -5700,17 +5700,17 @@ nsImapMailFolder::EndMessage(nsIMsgMailN</span>
<a href="#l18.282"></a><span id="l18.282"> </span>
<a href="#l18.283"></a><span id="l18.283"> NS_IMETHODIMP</span>
<a href="#l18.284"></a><span id="l18.284"> nsImapMailFolder::NotifySearchHit(nsIMsgMailNewsUrl * aUrl,</span>
<a href="#l18.285"></a><span id="l18.285">                                   const char* searchHitLine)</span>
<a href="#l18.286"></a><span id="l18.286"> {</span>
<a href="#l18.287"></a><span id="l18.287">   NS_ENSURE_ARG_POINTER(aUrl);</span>
<a href="#l18.288"></a><span id="l18.288">   nsresult rv = GetDatabase();</span>
<a href="#l18.289"></a><span id="l18.289">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.290"></a><span id="l18.290" class="difflineminus">-  </span>
<a href="#l18.291"></a><span id="l18.291" class="difflineplus">+</span>
<a href="#l18.292"></a><span id="l18.292">   // expect search results in the form of &quot;* SEARCH &lt;hit&gt; &lt;hit&gt; ...&quot;</span>
<a href="#l18.293"></a><span id="l18.293">   // expect search results in the form of &quot;* SEARCH &lt;hit&gt; &lt;hit&gt; ...&quot;</span>
<a href="#l18.294"></a><span id="l18.294">   nsCString tokenString(searchHitLine);</span>
<a href="#l18.295"></a><span id="l18.295">   char *currentPosition = PL_strcasestr(tokenString.get(), &quot;SEARCH&quot;);</span>
<a href="#l18.296"></a><span id="l18.296">   if (currentPosition)</span>
<a href="#l18.297"></a><span id="l18.297">   {</span>
<a href="#l18.298"></a><span id="l18.298">     currentPosition += strlen(&quot;SEARCH&quot;);</span>
<a href="#l18.299"></a><span id="l18.299">     bool shownUpdateAlert = false;</span>
<a href="#l18.300"></a><span id="l18.300" class="difflineat">@@ -5856,17 +5856,17 @@ nsImapMailFolder::HeaderFetchCompleted(n</span>
<a href="#l18.301"></a><span id="l18.301">                                             m_numServerRecentMessages,</span>
<a href="#l18.302"></a><span id="l18.302">                                             m_numServerUnseenMessages,</span>
<a href="#l18.303"></a><span id="l18.303">                                             m_nextUID);</span>
<a href="#l18.304"></a><span id="l18.304">         m_autoSyncStateObj-&gt;OnNewHeaderFetchCompleted(keysToDownload);</span>
<a href="#l18.305"></a><span id="l18.305">       }</span>
<a href="#l18.306"></a><span id="l18.306">     }</span>
<a href="#l18.307"></a><span id="l18.307">     if (!notifiedBodies)</span>
<a href="#l18.308"></a><span id="l18.308">       aProtocol-&gt;NotifyBodysToDownload(nullptr, 0/*keysToFetch.Length() */);</span>
<a href="#l18.309"></a><span id="l18.309" class="difflineminus">-   </span>
<a href="#l18.310"></a><span id="l18.310" class="difflineplus">+</span>
<a href="#l18.311"></a><span id="l18.311">     nsCOMPtr &lt;nsIURI&gt; runningUri;</span>
<a href="#l18.312"></a><span id="l18.312">     aProtocol-&gt;GetRunningUrl(getter_AddRefs(runningUri));</span>
<a href="#l18.313"></a><span id="l18.313">     if (runningUri)</span>
<a href="#l18.314"></a><span id="l18.314">     {</span>
<a href="#l18.315"></a><span id="l18.315">       nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(runningUri);</span>
<a href="#l18.316"></a><span id="l18.316">       if (mailnewsUrl)</span>
<a href="#l18.317"></a><span id="l18.317">         mailnewsUrl-&gt;GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l18.318"></a><span id="l18.318">     }</span>
<a href="#l18.319"></a><span id="l18.319" class="difflineat">@@ -7149,17 +7149,17 @@ nsresult nsImapMailFolder::CopyMessagesO</span>
<a href="#l18.320"></a><span id="l18.320">       nsMsgKey fakeTop = fakeBase + srcCount;</span>
<a href="#l18.321"></a><span id="l18.321">       // Check that we have enough room for the fake headers. If fakeTop</span>
<a href="#l18.322"></a><span id="l18.322">       // is &lt;= highWaterMark, we've overflowed.</span>
<a href="#l18.323"></a><span id="l18.323">       if (fakeTop &lt;= highWaterMark || fakeTop == nsMsgKey_None)</span>
<a href="#l18.324"></a><span id="l18.324">       {</span>
<a href="#l18.325"></a><span id="l18.325">         rv = FindOpenRange(fakeBase, srcCount);</span>
<a href="#l18.326"></a><span id="l18.326">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.327"></a><span id="l18.327">       }</span>
<a href="#l18.328"></a><span id="l18.328" class="difflineminus">-      // N.B. We must not return out of the for loop - we need the matching </span>
<a href="#l18.329"></a><span id="l18.329" class="difflineplus">+      // N.B. We must not return out of the for loop - we need the matching</span>
<a href="#l18.330"></a><span id="l18.330">       // end notifications to be sent.</span>
<a href="#l18.331"></a><span id="l18.331">       // We don't need to acquire the semaphor since this is synchronous</span>
<a href="#l18.332"></a><span id="l18.332">       // on the UI thread but we should check if the offline store is locked.</span>
<a href="#l18.333"></a><span id="l18.333">       bool isLocked;</span>
<a href="#l18.334"></a><span id="l18.334">       GetLocked(&amp;isLocked);</span>
<a href="#l18.335"></a><span id="l18.335">       nsCOMPtr&lt;nsIInputStream&gt; inputStream;</span>
<a href="#l18.336"></a><span id="l18.336">       bool reusable = false;</span>
<a href="#l18.337"></a><span id="l18.337">       nsCOMPtr&lt;nsIOutputStream&gt; outputStream;</span>
<a href="#l18.338"></a><span id="l18.338" class="difflineat">@@ -7560,69 +7560,69 @@ nsImapMailFolder::CopyMessages(nsIMsgFol</span>
<a href="#l18.339"></a><span id="l18.339"> </span>
<a href="#l18.340"></a><span id="l18.340">   rv = srcFolder-&gt;GetServer(getter_AddRefs(srcServer));</span>
<a href="#l18.341"></a><span id="l18.341">   if(NS_FAILED(rv)) goto done;</span>
<a href="#l18.342"></a><span id="l18.342"> </span>
<a href="#l18.343"></a><span id="l18.343">   rv = GetServer(getter_AddRefs(dstServer));</span>
<a href="#l18.344"></a><span id="l18.344">   if(NS_FAILED(rv)) goto done;</span>
<a href="#l18.345"></a><span id="l18.345"> </span>
<a href="#l18.346"></a><span id="l18.346">   NS_ENSURE_TRUE(dstServer, NS_ERROR_NULL_POINTER);</span>
<a href="#l18.347"></a><span id="l18.347" class="difflineminus">-  </span>
<a href="#l18.348"></a><span id="l18.348" class="difflineplus">+</span>
<a href="#l18.349"></a><span id="l18.349">   rv = dstServer-&gt;Equals(srcServer, &amp;sameServer);</span>
<a href="#l18.350"></a><span id="l18.350">   if (NS_FAILED(rv)) goto done;</span>
<a href="#l18.351"></a><span id="l18.351"> </span>
<a href="#l18.352"></a><span id="l18.352">   // in theory, if allowUndo is true, then this is a user initiated</span>
<a href="#l18.353"></a><span id="l18.353">   // action, and we should do it pseudo-offline. If it's not</span>
<a href="#l18.354"></a><span id="l18.354">   // user initiated (e.g., mail filters firing), then allowUndo is</span>
<a href="#l18.355"></a><span id="l18.355">   // false, and we should just do the action.</span>
<a href="#l18.356"></a><span id="l18.356" class="difflineminus">-  if (!WeAreOffline() &amp;&amp; sameServer &amp;&amp; allowUndo) </span>
<a href="#l18.357"></a><span id="l18.357" class="difflineplus">+  if (!WeAreOffline() &amp;&amp; sameServer &amp;&amp; allowUndo)</span>
<a href="#l18.358"></a><span id="l18.358">   {</span>
<a href="#l18.359"></a><span id="l18.359">     // complete the copy operation as in offline mode</span>
<a href="#l18.360"></a><span id="l18.360">     rv = CopyMessagesOffline(srcFolder, messages, isMove, msgWindow, listener);</span>
<a href="#l18.361"></a><span id="l18.361"> </span>
<a href="#l18.362"></a><span id="l18.362">     NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), &quot;error offline copy&quot;);</span>
<a href="#l18.363"></a><span id="l18.363">     // We'll warn if this fails, but we should still try to play back</span>
<a href="#l18.364"></a><span id="l18.364">     // offline ops, because it's possible the copy got far enough to</span>
<a href="#l18.365"></a><span id="l18.365">     // create the offline ops.</span>
<a href="#l18.366"></a><span id="l18.366"> </span>
<a href="#l18.367"></a><span id="l18.367" class="difflineminus">-    // We make sure that the source folder is an imap folder by limiting pseudo-offline </span>
<a href="#l18.368"></a><span id="l18.368" class="difflineminus">-    // operations to the same imap server. If we extend the code to cover non imap folders </span>
<a href="#l18.369"></a><span id="l18.369" class="difflineplus">+    // We make sure that the source folder is an imap folder by limiting pseudo-offline</span>
<a href="#l18.370"></a><span id="l18.370" class="difflineplus">+    // operations to the same imap server. If we extend the code to cover non imap folders</span>
<a href="#l18.371"></a><span id="l18.371">     // in the future (i.e. imap folder-&gt;local folder), then the following downcast</span>
<a href="#l18.372"></a><span id="l18.372">     // will cause either a crash or compiler error. Do not forget to change it accordingly.</span>
<a href="#l18.373"></a><span id="l18.373">     nsImapMailFolder *srcImapFolder = static_cast&lt;nsImapMailFolder*&gt;(srcFolder);</span>
<a href="#l18.374"></a><span id="l18.374" class="difflineminus">-    </span>
<a href="#l18.375"></a><span id="l18.375" class="difflineplus">+</span>
<a href="#l18.376"></a><span id="l18.376">     // lazily create playback timer if it is not already</span>
<a href="#l18.377"></a><span id="l18.377">     // created</span>
<a href="#l18.378"></a><span id="l18.378" class="difflineminus">-    if (!srcImapFolder-&gt;m_playbackTimer) </span>
<a href="#l18.379"></a><span id="l18.379" class="difflineplus">+    if (!srcImapFolder-&gt;m_playbackTimer)</span>
<a href="#l18.380"></a><span id="l18.380">     {</span>
<a href="#l18.381"></a><span id="l18.381">       rv = srcImapFolder-&gt;CreatePlaybackTimer();</span>
<a href="#l18.382"></a><span id="l18.382">       NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.383"></a><span id="l18.383">     }</span>
<a href="#l18.384"></a><span id="l18.384" class="difflineminus">-    </span>
<a href="#l18.385"></a><span id="l18.385" class="difflineminus">-    if (srcImapFolder-&gt;m_playbackTimer) </span>
<a href="#l18.386"></a><span id="l18.386" class="difflineplus">+</span>
<a href="#l18.387"></a><span id="l18.387" class="difflineplus">+    if (srcImapFolder-&gt;m_playbackTimer)</span>
<a href="#l18.388"></a><span id="l18.388">     {</span>
<a href="#l18.389"></a><span id="l18.389">       // if there is no pending request, create a new one, and set the timer. Otherwise</span>
<a href="#l18.390"></a><span id="l18.390">       // use the existing one to reset the timer.</span>
<a href="#l18.391"></a><span id="l18.391">       // it is callback function's responsibility to delete the new request object</span>
<a href="#l18.392"></a><span id="l18.392" class="difflineminus">-      if (!srcImapFolder-&gt;m_pendingPlaybackReq) </span>
<a href="#l18.393"></a><span id="l18.393" class="difflineplus">+      if (!srcImapFolder-&gt;m_pendingPlaybackReq)</span>
<a href="#l18.394"></a><span id="l18.394">       {</span>
<a href="#l18.395"></a><span id="l18.395">         srcImapFolder-&gt;m_pendingPlaybackReq = new nsPlaybackRequest(srcImapFolder, msgWindow);</span>
<a href="#l18.396"></a><span id="l18.396">         if (!srcImapFolder-&gt;m_pendingPlaybackReq)</span>
<a href="#l18.397"></a><span id="l18.397">           return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.398"></a><span id="l18.398">       }</span>
<a href="#l18.399"></a><span id="l18.399"> </span>
<a href="#l18.400"></a><span id="l18.400">       srcImapFolder-&gt;m_playbackTimer-&gt;InitWithNamedFuncCallback(PlaybackTimerCallback,</span>
<a href="#l18.401"></a><span id="l18.401">                                                                 (void *) srcImapFolder-&gt;m_pendingPlaybackReq,</span>
<a href="#l18.402"></a><span id="l18.402">                                                                 PLAYBACK_TIMER_INTERVAL_IN_MS,</span>
<a href="#l18.403"></a><span id="l18.403">                                                                 nsITimer::TYPE_ONE_SHOT,</span>
<a href="#l18.404"></a><span id="l18.404">                                                                 &quot;nsImapMailFolder::PlaybackTimerCallback&quot;);</span>
<a href="#l18.405"></a><span id="l18.405">     }</span>
<a href="#l18.406"></a><span id="l18.406">     return rv;</span>
<a href="#l18.407"></a><span id="l18.407">   }</span>
<a href="#l18.408"></a><span id="l18.408" class="difflineminus">-  else </span>
<a href="#l18.409"></a><span id="l18.409" class="difflineplus">+  else</span>
<a href="#l18.410"></a><span id="l18.410">   {</span>
<a href="#l18.411"></a><span id="l18.411">     // sort the message array by key</span>
<a href="#l18.412"></a><span id="l18.412"> </span>
<a href="#l18.413"></a><span id="l18.413">     uint32_t numMsgs = 0;</span>
<a href="#l18.414"></a><span id="l18.414">     messages-&gt;GetLength(&amp;numMsgs);</span>
<a href="#l18.415"></a><span id="l18.415">     nsTArray&lt;nsMsgKey&gt; keyArray(numMsgs);</span>
<a href="#l18.416"></a><span id="l18.416">     for (uint32_t i = 0; i &lt; numMsgs; i++)</span>
<a href="#l18.417"></a><span id="l18.417">     {</span>
<a href="#l18.418"></a><span id="l18.418" class="difflineat">@@ -7634,23 +7634,23 @@ nsImapMailFolder::CopyMessages(nsIMsgFol</span>
<a href="#l18.419"></a><span id="l18.419">         keyArray.AppendElement(key);</span>
<a href="#l18.420"></a><span id="l18.420">       }</span>
<a href="#l18.421"></a><span id="l18.421">     }</span>
<a href="#l18.422"></a><span id="l18.422">     keyArray.Sort();</span>
<a href="#l18.423"></a><span id="l18.423"> </span>
<a href="#l18.424"></a><span id="l18.424">     nsCOMPtr&lt;nsIMutableArray&gt; sortedMsgs(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l18.425"></a><span id="l18.425">     rv = MessagesInKeyOrder(keyArray, srcFolder, sortedMsgs);</span>
<a href="#l18.426"></a><span id="l18.426">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.427"></a><span id="l18.427" class="difflineminus">-    </span>
<a href="#l18.428"></a><span id="l18.428" class="difflineplus">+</span>
<a href="#l18.429"></a><span id="l18.429">     if (WeAreOffline())</span>
<a href="#l18.430"></a><span id="l18.430">       return CopyMessagesOffline(srcFolder, sortedMsgs, isMove, msgWindow, listener);</span>
<a href="#l18.431"></a><span id="l18.431" class="difflineminus">-    </span>
<a href="#l18.432"></a><span id="l18.432" class="difflineplus">+</span>
<a href="#l18.433"></a><span id="l18.433">     nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l18.434"></a><span id="l18.434">     NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l18.435"></a><span id="l18.435" class="difflineminus">-    </span>
<a href="#l18.436"></a><span id="l18.436" class="difflineplus">+</span>
<a href="#l18.437"></a><span id="l18.437">     SetPendingAttributes(sortedMsgs, isMove);</span>
<a href="#l18.438"></a><span id="l18.438"> </span>
<a href="#l18.439"></a><span id="l18.439">     // if the folders aren't on the same server, do a stream base copy</span>
<a href="#l18.440"></a><span id="l18.440">     if (!sameServer)</span>
<a href="#l18.441"></a><span id="l18.441">     {</span>
<a href="#l18.442"></a><span id="l18.442">       rv = CopyMessagesWithStream(srcFolder, sortedMsgs, isMove, true, msgWindow, listener, allowUndo);</span>
<a href="#l18.443"></a><span id="l18.443">       goto done;</span>
<a href="#l18.444"></a><span id="l18.444">     }</span>
<a href="#l18.445"></a><span id="l18.445" class="difflineat">@@ -7691,17 +7691,17 @@ nsImapMailFolder::CopyMessages(nsIMsgFol</span>
<a href="#l18.446"></a><span id="l18.446">           undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eMoveMsg);</span>
<a href="#l18.447"></a><span id="l18.447">       }</span>
<a href="#l18.448"></a><span id="l18.448">       else</span>
<a href="#l18.449"></a><span id="l18.449">         undoMsgTxn-&gt;SetTransactionType(nsIMessenger::eCopyMsg);</span>
<a href="#l18.450"></a><span id="l18.450">       m_copyState-&gt;m_undoMsgTxn = undoMsgTxn;</span>
<a href="#l18.451"></a><span id="l18.451">     }</span>
<a href="#l18.452"></a><span id="l18.452"> </span>
<a href="#l18.453"></a><span id="l18.453">   }//endif</span>
<a href="#l18.454"></a><span id="l18.454" class="difflineminus">-  </span>
<a href="#l18.455"></a><span id="l18.455" class="difflineplus">+</span>
<a href="#l18.456"></a><span id="l18.456"> done:</span>
<a href="#l18.457"></a><span id="l18.457">   if (NS_FAILED(rv))</span>
<a href="#l18.458"></a><span id="l18.458">   {</span>
<a href="#l18.459"></a><span id="l18.459">     (void) OnCopyCompleted(srcSupport, rv);</span>
<a href="#l18.460"></a><span id="l18.460">     if (isMove)</span>
<a href="#l18.461"></a><span id="l18.461">     {</span>
<a href="#l18.462"></a><span id="l18.462">       srcFolder-&gt;EnableNotifications(allMessageCountNotifications, true);  //enable message count notification</span>
<a href="#l18.463"></a><span id="l18.463">       NotifyFolderEvent(kDeleteOrMoveMsgFailed);</span>
<a href="#l18.464"></a><span id="l18.464" class="difflineat">@@ -8094,17 +8094,17 @@ nsImapMailFolder::CopyFileMessage(nsIFil</span>
<a href="#l18.465"></a><span id="l18.465">           msgToReplace-&gt;SetOfflineMessageSize(0);</span>
<a href="#l18.466"></a><span id="l18.466">           messages-&gt;AppendElement(msgToReplace);</span>
<a href="#l18.467"></a><span id="l18.467">           SetPendingAttributes(messages, false);</span>
<a href="#l18.468"></a><span id="l18.468">         }</span>
<a href="#l18.469"></a><span id="l18.469">     }</span>
<a href="#l18.470"></a><span id="l18.470"> </span>
<a href="#l18.471"></a><span id="l18.471">     bool isMove = (msgToReplace ? true : false);</span>
<a href="#l18.472"></a><span id="l18.472">     rv = InitCopyState(srcSupport, messages, isMove, isDraftOrTemplate,</span>
<a href="#l18.473"></a><span id="l18.473" class="difflineminus">-                       false, aNewMsgFlags, aNewMsgKeywords, listener, </span>
<a href="#l18.474"></a><span id="l18.474" class="difflineplus">+                       false, aNewMsgFlags, aNewMsgKeywords, listener,</span>
<a href="#l18.475"></a><span id="l18.475">                        msgWindow, false);</span>
<a href="#l18.476"></a><span id="l18.476">     if (NS_FAILED(rv))</span>
<a href="#l18.477"></a><span id="l18.477">       return OnCopyCompleted(srcSupport, rv);</span>
<a href="#l18.478"></a><span id="l18.478"> </span>
<a href="#l18.479"></a><span id="l18.479">     m_copyState-&gt;m_streamCopy = true;</span>
<a href="#l18.480"></a><span id="l18.480">     nsCOMPtr&lt;nsISupports&gt; copySupport;</span>
<a href="#l18.481"></a><span id="l18.481">     if( m_copyState )</span>
<a href="#l18.482"></a><span id="l18.482">       copySupport = do_QueryInterface(m_copyState);</span>
<a href="#l18.483"></a><span id="l18.483" class="difflineat">@@ -8198,17 +8198,17 @@ nsImapMailFolder::CopyStreamMessage(nsIM</span>
<a href="#l18.484"></a><span id="l18.484">       }</span>
<a href="#l18.485"></a><span id="l18.485">     }</span>
<a href="#l18.486"></a><span id="l18.486">     nsCOMPtr&lt;nsIURI&gt; dummyNull;</span>
<a href="#l18.487"></a><span id="l18.487">     rv = m_copyState-&gt;m_msgService-&gt;CopyMessage(uri.get(), streamListener,</span>
<a href="#l18.488"></a><span id="l18.488">                                                 isMove &amp;&amp; !m_copyState-&gt;m_isCrossServerOp, nullptr, aMsgWindow,</span>
<a href="#l18.489"></a><span id="l18.489">                                                 getter_AddRefs(dummyNull));</span>
<a href="#l18.490"></a><span id="l18.490">     if (NS_FAILED(rv))</span>
<a href="#l18.491"></a><span id="l18.491">       MOZ_LOG(IMAP, mozilla::LogLevel::Info, (&quot;CopyMessage failed: uri %s\n&quot;, uri.get()));</span>
<a href="#l18.492"></a><span id="l18.492" class="difflineminus">-  } </span>
<a href="#l18.493"></a><span id="l18.493" class="difflineplus">+  }</span>
<a href="#l18.494"></a><span id="l18.494">   return rv;</span>
<a href="#l18.495"></a><span id="l18.495"> }</span>
<a href="#l18.496"></a><span id="l18.496"> </span>
<a href="#l18.497"></a><span id="l18.497"> nsImapMailCopyState::nsImapMailCopyState() :</span>
<a href="#l18.498"></a><span id="l18.498">     m_isMove(false), m_selectedState(false),</span>
<a href="#l18.499"></a><span id="l18.499">     m_isCrossServerOp(false), m_curIndex(0),</span>
<a href="#l18.500"></a><span id="l18.500">     m_totalCount(0), m_streamCopy(false), m_dataBuffer(nullptr),</span>
<a href="#l18.501"></a><span id="l18.501">     m_dataBufferSize(0), m_leftOver(0), m_allowUndo(false),</span>
<a href="#l18.502"></a><span id="l18.502" class="difflineat">@@ -8409,17 +8409,17 @@ nsImapMailFolder::CopyFileToOfflineStore</span>
<a href="#l18.503"></a><span id="l18.503">     } while (newLine);</span>
<a href="#l18.504"></a><span id="l18.504"> </span>
<a href="#l18.505"></a><span id="l18.505">     msgParser-&gt;FinishHeader();</span>
<a href="#l18.506"></a><span id="l18.506">     uint32_t resultFlags;</span>
<a href="#l18.507"></a><span id="l18.507">     if (offlineStore)</span>
<a href="#l18.508"></a><span id="l18.508">       fakeHdr-&gt;OrFlags(nsMsgMessageFlags::Offline | nsMsgMessageFlags::Read, &amp;resultFlags);</span>
<a href="#l18.509"></a><span id="l18.509">     else</span>
<a href="#l18.510"></a><span id="l18.510">       fakeHdr-&gt;OrFlags(nsMsgMessageFlags::Read, &amp;resultFlags);</span>
<a href="#l18.511"></a><span id="l18.511" class="difflineminus">-    if (offlineStore)          </span>
<a href="#l18.512"></a><span id="l18.512" class="difflineplus">+    if (offlineStore)</span>
<a href="#l18.513"></a><span id="l18.513">       fakeHdr-&gt;SetOfflineMessageSize(fileSize);</span>
<a href="#l18.514"></a><span id="l18.514">     mDatabase-&gt;AddNewHdrToDB(fakeHdr, true /* notify */);</span>
<a href="#l18.515"></a><span id="l18.515"> </span>
<a href="#l18.516"></a><span id="l18.516">     // Call FinishNewMessage before setting pending attributes, as in</span>
<a href="#l18.517"></a><span id="l18.517">     //   maildir it copies from tmp to cur and may change the storeToken</span>
<a href="#l18.518"></a><span id="l18.518">     //   to get a unique filename.</span>
<a href="#l18.519"></a><span id="l18.519">     if (offlineStore)</span>
<a href="#l18.520"></a><span id="l18.520">     {</span>
<a href="#l18.521"></a><span id="l18.521" class="difflineat">@@ -8775,17 +8775,17 @@ NS_IMETHODIMP nsImapMailFolder::RenameCl</span>
<a href="#l18.522"></a><span id="l18.522">   if (NS_SUCCEEDED(rv) &amp;&amp; unusedDB)</span>
<a href="#l18.523"></a><span id="l18.523">   {</span>
<a href="#l18.524"></a><span id="l18.524">     //need to set the folder name</span>
<a href="#l18.525"></a><span id="l18.525">     nsCOMPtr &lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l18.526"></a><span id="l18.526">     rv = unusedDB-&gt;GetDBFolderInfo(getter_AddRefs(folderInfo));</span>
<a href="#l18.527"></a><span id="l18.527"> </span>
<a href="#l18.528"></a><span id="l18.528">     //Now let's create the actual new folder</span>
<a href="#l18.529"></a><span id="l18.529">     rv = AddSubfolderWithPath(folderNameStr, dbFile, getter_AddRefs(child));</span>
<a href="#l18.530"></a><span id="l18.530" class="difflineminus">-    if (!child || NS_FAILED(rv)) </span>
<a href="#l18.531"></a><span id="l18.531" class="difflineplus">+    if (!child || NS_FAILED(rv))</span>
<a href="#l18.532"></a><span id="l18.532">       return rv;</span>
<a href="#l18.533"></a><span id="l18.533">     nsAutoString unicodeName;</span>
<a href="#l18.534"></a><span id="l18.534">     rv = CopyMUTF7toUTF16(NS_LossyConvertUTF16toASCII(folderNameStr), unicodeName);</span>
<a href="#l18.535"></a><span id="l18.535">     if (NS_SUCCEEDED(rv))</span>
<a href="#l18.536"></a><span id="l18.536">       child-&gt;SetPrettyName(unicodeName);</span>
<a href="#l18.537"></a><span id="l18.537">     imapFolder = do_QueryInterface(child);</span>
<a href="#l18.538"></a><span id="l18.538">     if (imapFolder)</span>
<a href="#l18.539"></a><span id="l18.539">     {</span>
<a href="#l18.540"></a><span id="l18.540" class="difflineat">@@ -8820,17 +8820,17 @@ NS_IMETHODIMP nsImapMailFolder::RenameCl</span>
<a href="#l18.541"></a><span id="l18.541">     msgFolder-&gt;GetParent(getter_AddRefs(msgParent));</span>
<a href="#l18.542"></a><span id="l18.542">     msgFolder-&gt;SetParent(nullptr);</span>
<a href="#l18.543"></a><span id="l18.543">     // Reset online status now that the folder is renamed.</span>
<a href="#l18.544"></a><span id="l18.544">     nsCOMPtr &lt;nsIMsgImapMailFolder&gt; oldImapFolder = do_QueryInterface(msgFolder);</span>
<a href="#l18.545"></a><span id="l18.545">     if (oldImapFolder)</span>
<a href="#l18.546"></a><span id="l18.546">       oldImapFolder-&gt;SetVerifiedAsOnlineFolder(false);</span>
<a href="#l18.547"></a><span id="l18.547">     nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l18.548"></a><span id="l18.548">     if (notifier)</span>
<a href="#l18.549"></a><span id="l18.549" class="difflineminus">-      notifier-&gt;NotifyFolderRenamed(msgFolder, child);   </span>
<a href="#l18.550"></a><span id="l18.550" class="difflineplus">+      notifier-&gt;NotifyFolderRenamed(msgFolder, child);</span>
<a href="#l18.551"></a><span id="l18.551"> </span>
<a href="#l18.552"></a><span id="l18.552">     // Do not propagate the deletion until after we have (synchronously) notified</span>
<a href="#l18.553"></a><span id="l18.553">     // all listeners about the rename.  This allows them to access properties on</span>
<a href="#l18.554"></a><span id="l18.554">     // the source folder without experiencing failures.</span>
<a href="#l18.555"></a><span id="l18.555">     if (msgParent)</span>
<a href="#l18.556"></a><span id="l18.556">       msgParent-&gt;PropagateDelete(msgFolder, true, nullptr);</span>
<a href="#l18.557"></a><span id="l18.557">     NotifyItemAdded(child);</span>
<a href="#l18.558"></a><span id="l18.558">   }</span>
<a href="#l18.559"></a><span id="l18.559" class="difflineat">@@ -9473,17 +9473,17 @@ NS_IMETHODIMP nsImapMailFolder::ChangePe</span>
<a href="#l18.560"></a><span id="l18.560">   return NS_OK;</span>
<a href="#l18.561"></a><span id="l18.561"> }</span>
<a href="#l18.562"></a><span id="l18.562"> </span>
<a href="#l18.563"></a><span id="l18.563"> void nsImapMailFolder::NotifyHasPendingMsgs()</span>
<a href="#l18.564"></a><span id="l18.564"> {</span>
<a href="#l18.565"></a><span id="l18.565">   InitAutoSyncState();</span>
<a href="#l18.566"></a><span id="l18.566">   nsresult rv;</span>
<a href="#l18.567"></a><span id="l18.567">   nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l18.568"></a><span id="l18.568" class="difflineminus">-  if (NS_SUCCEEDED(rv)) </span>
<a href="#l18.569"></a><span id="l18.569" class="difflineplus">+  if (NS_SUCCEEDED(rv))</span>
<a href="#l18.570"></a><span id="l18.570">     autoSyncMgr-&gt;OnFolderHasPendingMsgs(m_autoSyncStateObj);</span>
<a href="#l18.571"></a><span id="l18.571"> }</span>
<a href="#l18.572"></a><span id="l18.572"> </span>
<a href="#l18.573"></a><span id="l18.573"> /* void changePendingUnread (in long aDelta); */</span>
<a href="#l18.574"></a><span id="l18.574"> NS_IMETHODIMP nsImapMailFolder::ChangePendingUnread(int32_t aDelta)</span>
<a href="#l18.575"></a><span id="l18.575"> {</span>
<a href="#l18.576"></a><span id="l18.576">   ChangeNumPendingUnread(aDelta);</span>
<a href="#l18.577"></a><span id="l18.577">   return NS_OK;</span>
<a href="#l18.578"></a><span id="l18.578" class="difflineat">@@ -9529,23 +9529,23 @@ NS_IMETHODIMP nsImapMailFolder::GetAutoS</span>
<a href="#l18.579"></a><span id="l18.579"> }</span>
<a href="#l18.580"></a><span id="l18.580"> </span>
<a href="#l18.581"></a><span id="l18.581"> NS_IMETHODIMP nsImapMailFolder::InitiateAutoSync(nsIUrlListener *aUrlListener)</span>
<a href="#l18.582"></a><span id="l18.582"> {</span>
<a href="#l18.583"></a><span id="l18.583">   nsCString folderName;</span>
<a href="#l18.584"></a><span id="l18.584">   GetURI(folderName);</span>
<a href="#l18.585"></a><span id="l18.585">   MOZ_LOG(gAutoSyncLog, mozilla::LogLevel::Debug, (&quot;Updating folder: %s\n&quot;, folderName.get()));</span>
<a href="#l18.586"></a><span id="l18.586"> </span>
<a href="#l18.587"></a><span id="l18.587" class="difflineminus">-  // HACK: if UpdateFolder finds out that it can't open </span>
<a href="#l18.588"></a><span id="l18.588" class="difflineminus">-  // the folder, it doesn't set the url listener and returns </span>
<a href="#l18.589"></a><span id="l18.589" class="difflineminus">-  // no error. In this case, we return success from this call </span>
<a href="#l18.590"></a><span id="l18.590" class="difflineplus">+  // HACK: if UpdateFolder finds out that it can't open</span>
<a href="#l18.591"></a><span id="l18.591" class="difflineplus">+  // the folder, it doesn't set the url listener and returns</span>
<a href="#l18.592"></a><span id="l18.592" class="difflineplus">+  // no error. In this case, we return success from this call</span>
<a href="#l18.593"></a><span id="l18.593">   // but the caller never gets a notification on its url listener.</span>
<a href="#l18.594"></a><span id="l18.594">   bool canOpenThisFolder = true;</span>
<a href="#l18.595"></a><span id="l18.595">   GetCanOpenFolder(&amp;canOpenThisFolder);</span>
<a href="#l18.596"></a><span id="l18.596" class="difflineminus">-  </span>
<a href="#l18.597"></a><span id="l18.597" class="difflineplus">+</span>
<a href="#l18.598"></a><span id="l18.598">   if (!canOpenThisFolder)</span>
<a href="#l18.599"></a><span id="l18.599">   {</span>
<a href="#l18.600"></a><span id="l18.600">     MOZ_LOG(gAutoSyncLog, mozilla::LogLevel::Debug, (&quot;Cannot update folder: %s\n&quot;, folderName.get()));</span>
<a href="#l18.601"></a><span id="l18.601">     return NS_ERROR_FAILURE;</span>
<a href="#l18.602"></a><span id="l18.602">   }</span>
<a href="#l18.603"></a><span id="l18.603"> </span>
<a href="#l18.604"></a><span id="l18.604">   // create auto-sync state object lazily</span>
<a href="#l18.605"></a><span id="l18.605">   InitAutoSyncState();</span>
<a href="#l18.606"></a><span id="l18.606" class="difflineat">@@ -9574,20 +9574,20 @@ NS_IMETHODIMP nsImapMailFolder::Initiate</span>
<a href="#l18.607"></a><span id="l18.607">                                         m_nextUID);</span>
<a href="#l18.608"></a><span id="l18.608">   // Issue a STATUS command and see if any counts changed.</span>
<a href="#l18.609"></a><span id="l18.609">   m_autoSyncStateObj-&gt;SetState(nsAutoSyncState::stStatusIssued);</span>
<a href="#l18.610"></a><span id="l18.610">   // The OnStopRunningUrl method of the autosync state obj</span>
<a href="#l18.611"></a><span id="l18.611">   // will check if the counts or next uid have changed,</span>
<a href="#l18.612"></a><span id="l18.612">   // and if so, will issue an UpdateFolder().</span>
<a href="#l18.613"></a><span id="l18.613">   rv = UpdateStatus(m_autoSyncStateObj, nullptr);</span>
<a href="#l18.614"></a><span id="l18.614">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.615"></a><span id="l18.615" class="difflineminus">-  </span>
<a href="#l18.616"></a><span id="l18.616" class="difflineplus">+</span>
<a href="#l18.617"></a><span id="l18.617">   // record the last update time</span>
<a href="#l18.618"></a><span id="l18.618">   m_autoSyncStateObj-&gt;SetLastUpdateTime(PR_Now());</span>
<a href="#l18.619"></a><span id="l18.619" class="difflineminus">-  </span>
<a href="#l18.620"></a><span id="l18.620" class="difflineplus">+</span>
<a href="#l18.621"></a><span id="l18.621">   return NS_OK;</span>
<a href="#l18.622"></a><span id="l18.622"> }</span>
<a href="#l18.623"></a><span id="l18.623"> </span>
<a href="#l18.624"></a><span id="l18.624"> nsresult nsImapMailFolder::CreatePlaybackTimer()</span>
<a href="#l18.625"></a><span id="l18.625"> {</span>
<a href="#l18.626"></a><span id="l18.626">   nsresult rv = NS_OK;</span>
<a href="#l18.627"></a><span id="l18.627">   if (!m_playbackTimer)</span>
<a href="#l18.628"></a><span id="l18.628">   {</span>
<a href="#l18.629"></a><span id="l18.629" class="difflineat">@@ -9595,26 +9595,26 @@ nsresult nsImapMailFolder::CreatePlaybac</span>
<a href="#l18.630"></a><span id="l18.630">     NS_ASSERTION(NS_SUCCEEDED(rv),&quot;failed to create pseudo-offline operation timer in nsImapMailFolder&quot;);</span>
<a href="#l18.631"></a><span id="l18.631">   }</span>
<a href="#l18.632"></a><span id="l18.632">   return rv;</span>
<a href="#l18.633"></a><span id="l18.633"> }</span>
<a href="#l18.634"></a><span id="l18.634"> </span>
<a href="#l18.635"></a><span id="l18.635"> void nsImapMailFolder::PlaybackTimerCallback(nsITimer *aTimer, void *aClosure)</span>
<a href="#l18.636"></a><span id="l18.636"> {</span>
<a href="#l18.637"></a><span id="l18.637">   nsPlaybackRequest *request = static_cast&lt;nsPlaybackRequest*&gt;(aClosure);</span>
<a href="#l18.638"></a><span id="l18.638" class="difflineminus">-  </span>
<a href="#l18.639"></a><span id="l18.639" class="difflineplus">+</span>
<a href="#l18.640"></a><span id="l18.640">   NS_ASSERTION(request-&gt;SrcFolder-&gt;m_pendingPlaybackReq == request, &quot;wrong playback request pointer&quot;);</span>
<a href="#l18.641"></a><span id="l18.641" class="difflineminus">-  </span>
<a href="#l18.642"></a><span id="l18.642" class="difflineplus">+</span>
<a href="#l18.643"></a><span id="l18.643">   RefPtr&lt;nsImapOfflineSync&gt; offlineSync = new nsImapOfflineSync(request-&gt;MsgWindow, nullptr, request-&gt;SrcFolder, true);</span>
<a href="#l18.644"></a><span id="l18.644">   if (offlineSync)</span>
<a href="#l18.645"></a><span id="l18.645">   {</span>
<a href="#l18.646"></a><span id="l18.646">     mozilla::DebugOnly&lt;nsresult&gt; rv = offlineSync-&gt;ProcessNextOperation();</span>
<a href="#l18.647"></a><span id="l18.647">     NS_ASSERTION(NS_SUCCEEDED(rv), &quot;pseudo-offline playback is not successful&quot;);</span>
<a href="#l18.648"></a><span id="l18.648">   }</span>
<a href="#l18.649"></a><span id="l18.649" class="difflineminus">-  </span>
<a href="#l18.650"></a><span id="l18.650" class="difflineplus">+</span>
<a href="#l18.651"></a><span id="l18.651">   // release request struct</span>
<a href="#l18.652"></a><span id="l18.652">   request-&gt;SrcFolder-&gt;m_pendingPlaybackReq = nullptr;</span>
<a href="#l18.653"></a><span id="l18.653">   delete request;</span>
<a href="#l18.654"></a><span id="l18.654"> }</span>
<a href="#l18.655"></a><span id="l18.655"> </span>
<a href="#l18.656"></a><span id="l18.656"> void nsImapMailFolder::InitAutoSyncState()</span>
<a href="#l18.657"></a><span id="l18.657"> {</span>
<a href="#l18.658"></a><span id="l18.658">   if (!m_autoSyncStateObj)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.h</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.h</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -76,17 +76,17 @@ public:</span>
<a href="#l19.4"></a><span id="l19.4">     bool m_streamCopy;</span>
<a href="#l19.5"></a><span id="l19.5">     char *m_dataBuffer; // temporary buffer for this copy operation</span>
<a href="#l19.6"></a><span id="l19.6">     nsCOMPtr&lt;nsIOutputStream&gt; m_msgFileStream;         // temporary file (processed mail)</span>
<a href="#l19.7"></a><span id="l19.7">     uint32_t m_dataBufferSize;</span>
<a href="#l19.8"></a><span id="l19.8">     uint32_t m_leftOver;</span>
<a href="#l19.9"></a><span id="l19.9">     bool m_allowUndo;</span>
<a href="#l19.10"></a><span id="l19.10">     bool m_eatLF;</span>
<a href="#l19.11"></a><span id="l19.11">     uint32_t m_newMsgFlags; // only used if there's no m_message</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-    nsCString m_newMsgKeywords; // ditto </span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+    nsCString m_newMsgKeywords; // ditto</span>
<a href="#l19.14"></a><span id="l19.14">     // If the server supports UIDPLUS, this is the UID for the append,</span>
<a href="#l19.15"></a><span id="l19.15">     // if we're doing an append.</span>
<a href="#l19.16"></a><span id="l19.16">     nsMsgKey m_appendUID;</span>
<a href="#l19.17"></a><span id="l19.17"> </span>
<a href="#l19.18"></a><span id="l19.18"> private:</span>
<a href="#l19.19"></a><span id="l19.19">     virtual ~nsImapMailCopyState();</span>
<a href="#l19.20"></a><span id="l19.20"> };</span>
<a href="#l19.21"></a><span id="l19.21"> </span>
<a href="#l19.22"></a><span id="l19.22" class="difflineat">@@ -191,17 +191,17 @@ struct nsPlaybackRequest</span>
<a href="#l19.23"></a><span id="l19.23"> </span>
<a href="#l19.24"></a><span id="l19.24"> class nsImapMailFolder :  public nsMsgDBFolder,</span>
<a href="#l19.25"></a><span id="l19.25">                           public nsIMsgImapMailFolder,</span>
<a href="#l19.26"></a><span id="l19.26">                           public nsIImapMailFolderSink,</span>
<a href="#l19.27"></a><span id="l19.27">                           public nsIImapMessageSink,</span>
<a href="#l19.28"></a><span id="l19.28">                           public nsICopyMessageListener,</span>
<a href="#l19.29"></a><span id="l19.29">                           public nsIMsgFilterHitNotify</span>
<a href="#l19.30"></a><span id="l19.30"> {</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineminus">- static const uint32_t PLAYBACK_TIMER_INTERVAL_IN_MS = 500; </span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+ static const uint32_t PLAYBACK_TIMER_INTERVAL_IN_MS = 500;</span>
<a href="#l19.33"></a><span id="l19.33"> public:</span>
<a href="#l19.34"></a><span id="l19.34">   nsImapMailFolder();</span>
<a href="#l19.35"></a><span id="l19.35"> </span>
<a href="#l19.36"></a><span id="l19.36">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l19.37"></a><span id="l19.37"> </span>
<a href="#l19.38"></a><span id="l19.38">   // nsIMsgFolder methods:</span>
<a href="#l19.39"></a><span id="l19.39">   NS_IMETHOD GetSubFolders(nsISimpleEnumerator **aResult) override;</span>
<a href="#l19.40"></a><span id="l19.40"> </span>
<a href="#l19.41"></a><span id="l19.41" class="difflineat">@@ -369,17 +369,17 @@ protected:</span>
<a href="#l19.42"></a><span id="l19.42">   void EndOfflineDownload();</span>
<a href="#l19.43"></a><span id="l19.43"> </span>
<a href="#l19.44"></a><span id="l19.44">   /**</span>
<a href="#l19.45"></a><span id="l19.45">    * At the end of a file-to-folder copy operation, copy the file to the</span>
<a href="#l19.46"></a><span id="l19.46">    * offline store and/or add to the message database, (if needed).</span>
<a href="#l19.47"></a><span id="l19.47">    *</span>
<a href="#l19.48"></a><span id="l19.48">    * @param srcFile       file containing the message key</span>
<a href="#l19.49"></a><span id="l19.49">    * @param msgKey        key to use for the new messages</span>
<a href="#l19.50"></a><span id="l19.50" class="difflineminus">-   */   </span>
<a href="#l19.51"></a><span id="l19.51" class="difflineplus">+   */</span>
<a href="#l19.52"></a><span id="l19.52">   nsresult CopyFileToOfflineStore(nsIFile *srcFile, nsMsgKey msgKey);</span>
<a href="#l19.53"></a><span id="l19.53"> </span>
<a href="#l19.54"></a><span id="l19.54">   nsresult MarkMessagesImapDeleted(nsTArray&lt;nsMsgKey&gt; *keyArray, bool deleted, nsIMsgDatabase *db);</span>
<a href="#l19.55"></a><span id="l19.55"> </span>
<a href="#l19.56"></a><span id="l19.56">   // Notifies imap autosync that it should update this folder when it</span>
<a href="#l19.57"></a><span id="l19.57">   // gets a chance.</span>
<a href="#l19.58"></a><span id="l19.58">   void NotifyHasPendingMsgs();</span>
<a href="#l19.59"></a><span id="l19.59">   void UpdatePendingCounts();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/imap/src/nsImapOfflineSync.h</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapOfflineSync.h</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -73,17 +73,17 @@ protected:</span>
<a href="#l20.4"></a><span id="l20.4">   nsCOMPtr &lt;nsIMsgDatabase&gt; m_currentDB;</span>
<a href="#l20.5"></a><span id="l20.5">   nsCOMPtr &lt;nsIUrlListener&gt; m_listener;</span>
<a href="#l20.6"></a><span id="l20.6">   int32_t	mCurrentUIDValidity;</span>
<a href="#l20.7"></a><span id="l20.7">   int32_t	mCurrentPlaybackOpType;	// kFlagsChanged -&gt; kMsgCopy -&gt; kMsgMoved</span>
<a href="#l20.8"></a><span id="l20.8">   bool	m_mailboxupdatesStarted;</span>
<a href="#l20.9"></a><span id="l20.9">   bool          m_mailboxupdatesFinished;</span>
<a href="#l20.10"></a><span id="l20.10">   bool	m_pseudoOffline;		// for queueing online events in offline db</span>
<a href="#l20.11"></a><span id="l20.11">   bool	m_createdOfflineFolders;</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-  </span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+</span>
<a href="#l20.14"></a><span id="l20.14"> };</span>
<a href="#l20.15"></a><span id="l20.15"> </span>
<a href="#l20.16"></a><span id="l20.16"> class nsImapOfflineDownloader : public nsImapOfflineSync</span>
<a href="#l20.17"></a><span id="l20.17"> {</span>
<a href="#l20.18"></a><span id="l20.18"> public:</span>
<a href="#l20.19"></a><span id="l20.19">   nsImapOfflineDownloader(nsIMsgWindow *window, nsIUrlListener *listener);</span>
<a href="#l20.20"></a><span id="l20.20">   virtual ~nsImapOfflineDownloader();</span>
<a href="#l20.21"></a><span id="l20.21">   virtual nsresult  ProcessNextOperation() override; // this kicks off download</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -174,17 +174,17 @@ public:</span>
<a href="#l21.4"></a><span id="l21.4">   static  bool    HandlingMultipleMessages(const nsCString &amp;messageIdString);</span>
<a href="#l21.5"></a><span id="l21.5">   // escape slashes and double quotes in username/passwords for insecure login.</span>
<a href="#l21.6"></a><span id="l21.6">   static void EscapeUserNamePasswordString(const char *strToEscape, nsCString *resultStr);</span>
<a href="#l21.7"></a><span id="l21.7"> </span>
<a href="#l21.8"></a><span id="l21.8">   // used to start fetching a message.</span>
<a href="#l21.9"></a><span id="l21.9">   void GetShouldDownloadAllHeaders(bool *aResult);</span>
<a href="#l21.10"></a><span id="l21.10">   void GetArbitraryHeadersToDownload(nsCString &amp;aResult);</span>
<a href="#l21.11"></a><span id="l21.11">   virtual void AdjustChunkSize();</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-  virtual void FetchMessage(const nsCString &amp;messageIds, </span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+  virtual void FetchMessage(const nsCString &amp;messageIds,</span>
<a href="#l21.14"></a><span id="l21.14">     nsIMAPeFetchFields whatToFetch,</span>
<a href="#l21.15"></a><span id="l21.15">     const char *fetchModifier = nullptr,</span>
<a href="#l21.16"></a><span id="l21.16">     uint32_t startByte = 0, uint32_t numBytes = 0,</span>
<a href="#l21.17"></a><span id="l21.17">     char *part = 0);</span>
<a href="#l21.18"></a><span id="l21.18">   void FetchTryChunking(const nsCString &amp;messageIds,</span>
<a href="#l21.19"></a><span id="l21.19">     nsIMAPeFetchFields whatToFetch,</span>
<a href="#l21.20"></a><span id="l21.20">     bool idIsUid,</span>
<a href="#l21.21"></a><span id="l21.21">     char *part,</span>
<a href="#l21.22"></a><span id="l21.22" class="difflineat">@@ -483,17 +483,17 @@ private:</span>
<a href="#l21.23"></a><span id="l21.23">                            nsIMsgIncomingServer *aServer);</span>
<a href="#l21.24"></a><span id="l21.24">   nsresult ChooseAuthMethod();</span>
<a href="#l21.25"></a><span id="l21.25">   void MarkAuthMethodAsFailed(eIMAPCapabilityFlags failedAuthMethod);</span>
<a href="#l21.26"></a><span id="l21.26">   void ResetAuthMethods();</span>
<a href="#l21.27"></a><span id="l21.27"> </span>
<a href="#l21.28"></a><span id="l21.28">   // All of these methods actually issue protocol</span>
<a href="#l21.29"></a><span id="l21.29">   void Capability(); // query host for capabilities.</span>
<a href="#l21.30"></a><span id="l21.30">   void ID(); // send RFC 2971 app info to server</span>
<a href="#l21.31"></a><span id="l21.31" class="difflineminus">-  void EnableCondStore(); </span>
<a href="#l21.32"></a><span id="l21.32" class="difflineplus">+  void EnableCondStore();</span>
<a href="#l21.33"></a><span id="l21.33">   void StartCompressDeflate();</span>
<a href="#l21.34"></a><span id="l21.34">   nsresult BeginCompressing();</span>
<a href="#l21.35"></a><span id="l21.35">   void Language(); // set the language on the server if it supports it</span>
<a href="#l21.36"></a><span id="l21.36">   void Namespace();</span>
<a href="#l21.37"></a><span id="l21.37">   void InsecureLogin(const char *userName, const nsCString &amp;password);</span>
<a href="#l21.38"></a><span id="l21.38">   nsresult AuthLogin(const char *userName, const nsString &amp;password, eIMAPCapabilityFlag flag);</span>
<a href="#l21.39"></a><span id="l21.39">   void ProcessAuthenticatedStateURL();</span>
<a href="#l21.40"></a><span id="l21.40">   void ProcessAfterAuthenticated();</span>
<a href="#l21.41"></a><span id="l21.41" class="difflineat">@@ -581,21 +581,21 @@ private:</span>
<a href="#l21.42"></a><span id="l21.42">   virtual char const *GetType() override {return &quot;imap&quot;;}</span>
<a href="#l21.43"></a><span id="l21.43"> </span>
<a href="#l21.44"></a><span id="l21.44">   // Quota support</span>
<a href="#l21.45"></a><span id="l21.45">   void GetQuotaDataIfSupported(const char *aBoxName);</span>
<a href="#l21.46"></a><span id="l21.46"> </span>
<a href="#l21.47"></a><span id="l21.47">   // CondStore support - true if server supports it, and the user hasn't disabled it.</span>
<a href="#l21.48"></a><span id="l21.48">   bool UseCondStore();</span>
<a href="#l21.49"></a><span id="l21.49">   // false if pref &quot;mail.server.serverxxx.use_condstore&quot; is false;</span>
<a href="#l21.50"></a><span id="l21.50" class="difflineminus">-  bool m_useCondStore; </span>
<a href="#l21.51"></a><span id="l21.51" class="difflineplus">+  bool m_useCondStore;</span>
<a href="#l21.52"></a><span id="l21.52">   // COMPRESS=DEFLATE support - true if server supports it, and the user hasn't disabled it.</span>
<a href="#l21.53"></a><span id="l21.53">   bool UseCompressDeflate();</span>
<a href="#l21.54"></a><span id="l21.54">   // false if pref &quot;mail.server.serverxxx.use_compress_deflate&quot; is false;</span>
<a href="#l21.55"></a><span id="l21.55" class="difflineminus">-  bool m_useCompressDeflate; </span>
<a href="#l21.56"></a><span id="l21.56" class="difflineplus">+  bool m_useCompressDeflate;</span>
<a href="#l21.57"></a><span id="l21.57">   // these come from the nsIDBFolderInfo in the msgDatabase and</span>
<a href="#l21.58"></a><span id="l21.58">   // are initialized in nsImapProtocol::SetupWithUrl.</span>
<a href="#l21.59"></a><span id="l21.59">   uint64_t mFolderLastModSeq;</span>
<a href="#l21.60"></a><span id="l21.60">   int32_t mFolderTotalMsgCount;</span>
<a href="#l21.61"></a><span id="l21.61">   uint32_t mFolderHighestUID;</span>
<a href="#l21.62"></a><span id="l21.62">   uint32_t mFolderNumDeleted;</span>
<a href="#l21.63"></a><span id="l21.63"> </span>
<a href="#l21.64"></a><span id="l21.64">   bool m_isGmailServer;</span>
<a href="#l21.65"></a><span id="l21.65" class="difflineat">@@ -628,20 +628,20 @@ private:</span>
<a href="#l21.66"></a><span id="l21.66">   nsDataHashtable&lt;nsCStringHashKey, int32_t&gt; m_specialXListMailboxes;</span>
<a href="#l21.67"></a><span id="l21.67"> </span>
<a href="#l21.68"></a><span id="l21.68"> </span>
<a href="#l21.69"></a><span id="l21.69">   nsIImapHostSessionList * m_hostSessionList;</span>
<a href="#l21.70"></a><span id="l21.70"> </span>
<a href="#l21.71"></a><span id="l21.71">   bool m_fromHeaderSeen;</span>
<a href="#l21.72"></a><span id="l21.72"> </span>
<a href="#l21.73"></a><span id="l21.73">   nsString mAcceptLanguages;</span>
<a href="#l21.74"></a><span id="l21.74" class="difflineminus">-  </span>
<a href="#l21.75"></a><span id="l21.75" class="difflineplus">+</span>
<a href="#l21.76"></a><span id="l21.76">   // progress stuff</span>
<a href="#l21.77"></a><span id="l21.77">   void SetProgressString(uint32_t aStringIndex);</span>
<a href="#l21.78"></a><span id="l21.78" class="difflineminus">-  </span>
<a href="#l21.79"></a><span id="l21.79" class="difflineplus">+</span>
<a href="#l21.80"></a><span id="l21.80">   nsCString     m_progressStringName;</span>
<a href="#l21.81"></a><span id="l21.81">   uint32_t      m_stringIndex;</span>
<a href="#l21.82"></a><span id="l21.82">   int32_t       m_progressCurrentNumber[IMAP_NUMBER_OF_PROGRESS_STRINGS];</span>
<a href="#l21.83"></a><span id="l21.83">   int32_t       m_progressExpectedNumber;</span>
<a href="#l21.84"></a><span id="l21.84">   nsCString     m_lastProgressStringName;</span>
<a href="#l21.85"></a><span id="l21.85">   int32_t       m_lastPercent;</span>
<a href="#l21.86"></a><span id="l21.86">   int64_t       m_lastProgressTime;</span>
<a href="#l21.87"></a><span id="l21.87">   nsCOMPtr&lt;nsIStringBundle&gt; m_bundle;</span>
<a href="#l21.88"></a><span id="l21.88" class="difflineat">@@ -718,17 +718,17 @@ public:</span>
<a href="#l21.89"></a><span id="l21.89"> protected:</span>
<a href="#l21.90"></a><span id="l21.90">   virtual ~nsImapMockChannel();</span>
<a href="#l21.91"></a><span id="l21.91">   nsCOMPtr &lt;nsIURI&gt; m_url;</span>
<a href="#l21.92"></a><span id="l21.92"> </span>
<a href="#l21.93"></a><span id="l21.93">   nsCOMPtr&lt;nsIURI&gt; m_originalUrl;</span>
<a href="#l21.94"></a><span id="l21.94">   nsCOMPtr&lt;nsILoadGroup&gt; m_loadGroup;</span>
<a href="#l21.95"></a><span id="l21.95">   nsCOMPtr&lt;nsILoadInfo&gt; m_loadInfo;</span>
<a href="#l21.96"></a><span id="l21.96">   nsCOMPtr&lt;nsIStreamListener&gt; m_channelListener;</span>
<a href="#l21.97"></a><span id="l21.97" class="difflineminus">-  nsISupports * m_channelContext; </span>
<a href="#l21.98"></a><span id="l21.98" class="difflineplus">+  nsISupports * m_channelContext;</span>
<a href="#l21.99"></a><span id="l21.99">   nsresult m_cancelStatus;</span>
<a href="#l21.100"></a><span id="l21.100">   nsLoadFlags mLoadFlags;</span>
<a href="#l21.101"></a><span id="l21.101">   nsCOMPtr&lt;nsIProgressEventSink&gt; mProgressEventSink;</span>
<a href="#l21.102"></a><span id="l21.102">   nsCOMPtr&lt;nsIInterfaceRequestor&gt; mCallbacks;</span>
<a href="#l21.103"></a><span id="l21.103">   nsCOMPtr&lt;nsISupports&gt; mOwner;</span>
<a href="#l21.104"></a><span id="l21.104">   nsCOMPtr&lt;nsISupports&gt; mSecurityInfo;</span>
<a href="#l21.105"></a><span id="l21.105">   nsCOMPtr&lt;nsIRequest&gt; mCacheRequest; // the request associated with a read from the cache</span>
<a href="#l21.106"></a><span id="l21.106">   nsCString mContentType;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/imap/src/nsImapSearchResults.cpp</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapSearchResults.cpp</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -17,17 +17,17 @@ nsImapSearchResultSequence::nsImapSearch</span>
<a href="#l22.4"></a><span id="l22.4"> nsImapSearchResultSequence *nsImapSearchResultSequence::CreateSearchResultSequence()</span>
<a href="#l22.5"></a><span id="l22.5"> {</span>
<a href="#l22.6"></a><span id="l22.6">   return new nsImapSearchResultSequence;</span>
<a href="#l22.7"></a><span id="l22.7"> }</span>
<a href="#l22.8"></a><span id="l22.8"> </span>
<a href="#l22.9"></a><span id="l22.9"> void nsImapSearchResultSequence::Clear(void)</span>
<a href="#l22.10"></a><span id="l22.10"> {</span>
<a href="#l22.11"></a><span id="l22.11">     int32_t i = Length();</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-    while (0 &lt;= --i) </span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+    while (0 &lt;= --i)</span>
<a href="#l22.14"></a><span id="l22.14">     {</span>
<a href="#l22.15"></a><span id="l22.15">       char* string = ElementAt(i);</span>
<a href="#l22.16"></a><span id="l22.16">       PR_Free(string);</span>
<a href="#l22.17"></a><span id="l22.17">     }</span>
<a href="#l22.18"></a><span id="l22.18">     nsTArray&lt;char*&gt;::Clear();</span>
<a href="#l22.19"></a><span id="l22.19"> }</span>
<a href="#l22.20"></a><span id="l22.20"> </span>
<a href="#l22.21"></a><span id="l22.21"> nsImapSearchResultSequence::~nsImapSearchResultSequence()</span>
<a href="#l22.22"></a><span id="l22.22" class="difflineat">@@ -40,17 +40,17 @@ void nsImapSearchResultSequence::ResetSe</span>
<a href="#l22.23"></a><span id="l22.23"> {</span>
<a href="#l22.24"></a><span id="l22.24">   Clear();</span>
<a href="#l22.25"></a><span id="l22.25"> }</span>
<a href="#l22.26"></a><span id="l22.26"> </span>
<a href="#l22.27"></a><span id="l22.27"> void nsImapSearchResultSequence::AddSearchResultLine(const char *searchLine)</span>
<a href="#l22.28"></a><span id="l22.28"> {</span>
<a href="#l22.29"></a><span id="l22.29">   // The first add becomes node 2.  Fix this.</span>
<a href="#l22.30"></a><span id="l22.30">   char *copiedSequence = PL_strdup(searchLine + 9); // 9 == &quot;* SEARCH &quot;</span>
<a href="#l22.31"></a><span id="l22.31" class="difflineminus">-  </span>
<a href="#l22.32"></a><span id="l22.32" class="difflineplus">+</span>
<a href="#l22.33"></a><span id="l22.33">   if (copiedSequence)	// if we can't allocate this then the search won't hit</span>
<a href="#l22.34"></a><span id="l22.34">     AppendElement(copiedSequence);</span>
<a href="#l22.35"></a><span id="l22.35"> }</span>
<a href="#l22.36"></a><span id="l22.36"> </span>
<a href="#l22.37"></a><span id="l22.37"> </span>
<a href="#l22.38"></a><span id="l22.38"> nsImapSearchResultIterator::nsImapSearchResultIterator(nsImapSearchResultSequence &amp;sequence) :</span>
<a href="#l22.39"></a><span id="l22.39"> fSequence(sequence)</span>
<a href="#l22.40"></a><span id="l22.40"> {</span>
<a href="#l22.41"></a><span id="l22.41" class="difflineat">@@ -69,24 +69,24 @@ void  nsImapSearchResultIterator::ResetI</span>
<a href="#l22.42"></a><span id="l22.42"> }</span>
<a href="#l22.43"></a><span id="l22.43"> </span>
<a href="#l22.44"></a><span id="l22.44"> int32_t nsImapSearchResultIterator::GetNextMessageNumber()</span>
<a href="#l22.45"></a><span id="l22.45"> {</span>
<a href="#l22.46"></a><span id="l22.46">   int32_t returnValue = 0;</span>
<a href="#l22.47"></a><span id="l22.47">   if (fPositionInCurrentLine)</span>
<a href="#l22.48"></a><span id="l22.48">   {	</span>
<a href="#l22.49"></a><span id="l22.49">     returnValue = atoi(fPositionInCurrentLine);</span>
<a href="#l22.50"></a><span id="l22.50" class="difflineminus">-    </span>
<a href="#l22.51"></a><span id="l22.51" class="difflineplus">+</span>
<a href="#l22.52"></a><span id="l22.52">     // eat the current number</span>
<a href="#l22.53"></a><span id="l22.53">     while (isdigit(*++fPositionInCurrentLine))</span>
<a href="#l22.54"></a><span id="l22.54">       ;</span>
<a href="#l22.55"></a><span id="l22.55" class="difflineminus">-    </span>
<a href="#l22.56"></a><span id="l22.56" class="difflineplus">+</span>
<a href="#l22.57"></a><span id="l22.57">     if (*fPositionInCurrentLine == 0xD)	// found CR, no more digits on line</span>
<a href="#l22.58"></a><span id="l22.58">     {</span>
<a href="#l22.59"></a><span id="l22.59">       fCurrentLine = (char *) fSequence.SafeElementAt(++fSequenceIndex);</span>
<a href="#l22.60"></a><span id="l22.60">       fPositionInCurrentLine = fCurrentLine;</span>
<a href="#l22.61"></a><span id="l22.61">     }</span>
<a href="#l22.62"></a><span id="l22.62">     else	// eat the space</span>
<a href="#l22.63"></a><span id="l22.63">       fPositionInCurrentLine++;</span>
<a href="#l22.64"></a><span id="l22.64">   }</span>
<a href="#l22.65"></a><span id="l22.65" class="difflineminus">-  </span>
<a href="#l22.66"></a><span id="l22.66" class="difflineplus">+</span>
<a href="#l22.67"></a><span id="l22.67">   return returnValue;</span>
<a href="#l22.68"></a><span id="l22.68"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mailnews/imap/src/nsImapSearchResults.h</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapSearchResults.h</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -8,31 +8,31 @@</span>
<a href="#l23.4"></a><span id="l23.4"> </span>
<a href="#l23.5"></a><span id="l23.5"> #include &quot;nsTArray.h&quot;</span>
<a href="#l23.6"></a><span id="l23.6"> </span>
<a href="#l23.7"></a><span id="l23.7"> class nsImapSearchResultSequence : public nsTArray&lt;char*&gt;</span>
<a href="#l23.8"></a><span id="l23.8"> {</span>
<a href="#l23.9"></a><span id="l23.9"> public:</span>
<a href="#l23.10"></a><span id="l23.10">     virtual ~nsImapSearchResultSequence();</span>
<a href="#l23.11"></a><span id="l23.11">     static nsImapSearchResultSequence *CreateSearchResultSequence();</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-    </span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+</span>
<a href="#l23.14"></a><span id="l23.14">     virtual void AddSearchResultLine(const char *searchLine);</span>
<a href="#l23.15"></a><span id="l23.15">     virtual void ResetSequence();</span>
<a href="#l23.16"></a><span id="l23.16">     void  Clear();</span>
<a href="#l23.17"></a><span id="l23.17" class="difflineminus">-    </span>
<a href="#l23.18"></a><span id="l23.18" class="difflineplus">+</span>
<a href="#l23.19"></a><span id="l23.19">     friend class nsImapSearchResultIterator;</span>
<a href="#l23.20"></a><span id="l23.20"> private:</span>
<a href="#l23.21"></a><span id="l23.21">     nsImapSearchResultSequence();</span>
<a href="#l23.22"></a><span id="l23.22"> };</span>
<a href="#l23.23"></a><span id="l23.23"> </span>
<a href="#l23.24"></a><span id="l23.24"> class nsImapSearchResultIterator {</span>
<a href="#l23.25"></a><span id="l23.25"> public:</span>
<a href="#l23.26"></a><span id="l23.26">     nsImapSearchResultIterator(nsImapSearchResultSequence &amp;sequence);</span>
<a href="#l23.27"></a><span id="l23.27">     virtual ~nsImapSearchResultIterator();</span>
<a href="#l23.28"></a><span id="l23.28" class="difflineminus">-    </span>
<a href="#l23.29"></a><span id="l23.29" class="difflineplus">+</span>
<a href="#l23.30"></a><span id="l23.30">     void  ResetIterator();</span>
<a href="#l23.31"></a><span id="l23.31">     int32_t GetNextMessageNumber();   // returns 0 at end of list</span>
<a href="#l23.32"></a><span id="l23.32"> private:</span>
<a href="#l23.33"></a><span id="l23.33">     nsImapSearchResultSequence &amp;fSequence;</span>
<a href="#l23.34"></a><span id="l23.34">     int32_t fSequenceIndex;</span>
<a href="#l23.35"></a><span id="l23.35">     char  *fCurrentLine;</span>
<a href="#l23.36"></a><span id="l23.36">     char  *fPositionInCurrentLine;</span>
<a href="#l23.37"></a><span id="l23.37"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mailnews/imap/src/nsImapServerResponseParser.h</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapServerResponseParser.h</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -116,17 +116,17 @@ public:</span>
<a href="#l24.4"></a><span id="l24.4">   virtual uint16_t  SettablePermanentFlags() { return fSettablePermanentFlags;}</span>
<a href="#l24.5"></a><span id="l24.5">   void SetFlagState(nsIImapFlagAndUidState *state);</span>
<a href="#l24.6"></a><span id="l24.6">   bool GetDownloadingHeaders();</span>
<a href="#l24.7"></a><span id="l24.7">   bool GetFillingInShell();</span>
<a href="#l24.8"></a><span id="l24.8">   void UseCachedShell(nsIMAPBodyShell *cachedShell);</span>
<a href="#l24.9"></a><span id="l24.9">   void SetHostSessionList(nsIImapHostSessionList *aHostSession);</span>
<a href="#l24.10"></a><span id="l24.10">   char  *fAuthChallenge;    // the challenge returned by the server in</span>
<a href="#l24.11"></a><span id="l24.11">                             //response to authenticate using CRAM-MD5 or NTLM</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-  bool            fCondStoreEnabled;  </span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+  bool            fCondStoreEnabled;</span>
<a href="#l24.14"></a><span id="l24.14">   bool            fUseModSeq;  // can use mod seq for currently selected folder</span>
<a href="#l24.15"></a><span id="l24.15">   uint64_t        fHighestModSeq;</span>
<a href="#l24.16"></a><span id="l24.16"> </span>
<a href="#l24.17"></a><span id="l24.17"> protected:</span>
<a href="#l24.18"></a><span id="l24.18">   virtual void    flags();</span>
<a href="#l24.19"></a><span id="l24.19">   virtual void    envelope_data();</span>
<a href="#l24.20"></a><span id="l24.20">   virtual void    xaolenvelope_data();</span>
<a href="#l24.21"></a><span id="l24.21">   virtual void    parse_address(nsAutoCString &amp;addressLine);</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineat">@@ -241,17 +241,17 @@ private:</span>
<a href="#l24.23"></a><span id="l24.23">   char          *fXSenderInfo; /* changed per message download */</span>
<a href="#l24.24"></a><span id="l24.24">   char          *fLastAlert; /* used to avoid displaying the same alert over and over */</span>
<a href="#l24.25"></a><span id="l24.25">   char          *fMsgID; /* MessageID for Gmail only (X-GM-MSGID) */</span>
<a href="#l24.26"></a><span id="l24.26">   char          *fThreadID; /* ThreadID for Gmail only (X-GM-THRID) */</span>
<a href="#l24.27"></a><span id="l24.27">   char          *fLabels; /* Labels for Gmail only (X-GM-LABELS) [will include parens, removed while passing to hashTable ]*/</span>
<a href="#l24.28"></a><span id="l24.28">   nsCString     fManageListsUrl;</span>
<a href="#l24.29"></a><span id="l24.29">   nsCString    fManageFiltersUrl;</span>
<a href="#l24.30"></a><span id="l24.30">   char          *fFolderAdminUrl;</span>
<a href="#l24.31"></a><span id="l24.31" class="difflineminus">-  nsCString    fServerIdResponse; // RFC </span>
<a href="#l24.32"></a><span id="l24.32" class="difflineplus">+  nsCString    fServerIdResponse; // RFC</span>
<a href="#l24.33"></a><span id="l24.33"> </span>
<a href="#l24.34"></a><span id="l24.34">   int32_t fFetchResponseIndex;</span>
<a href="#l24.35"></a><span id="l24.35"> </span>
<a href="#l24.36"></a><span id="l24.36">   // used for aborting a fetch stream when we're pseudo-Interrupted</span>
<a href="#l24.37"></a><span id="l24.37">   int32_t numberOfCharsInThisChunk;</span>
<a href="#l24.38"></a><span id="l24.38">   int32_t charsReadSoFar;</span>
<a href="#l24.39"></a><span id="l24.39">   bool fLastChunk;</span>
<a href="#l24.40"></a><span id="l24.40"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/imap/src/nsImapService.cpp</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapService.cpp</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -93,29 +93,29 @@ NS_IMPL_ISUPPORTS(nsImapService,</span>
<a href="#l25.4"></a><span id="l25.4">                    nsIContentHandler)</span>
<a href="#l25.5"></a><span id="l25.5"> </span>
<a href="#l25.6"></a><span id="l25.6"> nsImapService::nsImapService()</span>
<a href="#l25.7"></a><span id="l25.7"> {</span>
<a href="#l25.8"></a><span id="l25.8">   mPrintingOperation = false;</span>
<a href="#l25.9"></a><span id="l25.9">   if (!gInitialized)</span>
<a href="#l25.10"></a><span id="l25.10">   {</span>
<a href="#l25.11"></a><span id="l25.11">     nsresult rv;</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv)); </span>
<a href="#l25.13"></a><span id="l25.13" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; prefBranch) </span>
<a href="#l25.14"></a><span id="l25.14" class="difflineplus">+    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l25.15"></a><span id="l25.15" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; prefBranch)</span>
<a href="#l25.16"></a><span id="l25.16">     {</span>
<a href="#l25.17"></a><span id="l25.17">       prefBranch-&gt;GetBoolPref(&quot;mail.imap.mime_parts_on_demand&quot;, &amp;gMIMEOnDemand);</span>
<a href="#l25.18"></a><span id="l25.18">       prefBranch-&gt;GetIntPref(&quot;mail.imap.mime_parts_on_demand_threshold&quot;, &amp;gMIMEOnDemandThreshold);</span>
<a href="#l25.19"></a><span id="l25.19">     }</span>
<a href="#l25.20"></a><span id="l25.20"> </span>
<a href="#l25.21"></a><span id="l25.21">     // initialize auto-sync service</span>
<a href="#l25.22"></a><span id="l25.22">     nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l25.23"></a><span id="l25.23" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; autoSyncMgr) </span>
<a href="#l25.24"></a><span id="l25.24" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; autoSyncMgr)</span>
<a href="#l25.25"></a><span id="l25.25">     {</span>
<a href="#l25.26"></a><span id="l25.26">       // auto-sync manager initialization goes here</span>
<a href="#l25.27"></a><span id="l25.27" class="difflineminus">-      // assign new strategy objects here... </span>
<a href="#l25.28"></a><span id="l25.28" class="difflineplus">+      // assign new strategy objects here...</span>
<a href="#l25.29"></a><span id="l25.29">     }</span>
<a href="#l25.30"></a><span id="l25.30">     NS_ASSERTION(autoSyncMgr != nullptr, &quot;*** Cannot initialize nsAutoSyncManager service.&quot;);</span>
<a href="#l25.31"></a><span id="l25.31"> </span>
<a href="#l25.32"></a><span id="l25.32">     gInitialized = true;</span>
<a href="#l25.33"></a><span id="l25.33">   }</span>
<a href="#l25.34"></a><span id="l25.34"> }</span>
<a href="#l25.35"></a><span id="l25.35"> </span>
<a href="#l25.36"></a><span id="l25.36"> nsImapService::~nsImapService()</span>
<a href="#l25.37"></a><span id="l25.37" class="difflineat">@@ -181,17 +181,17 @@ NS_IMETHODIMP nsImapService::SelectFolde</span>
<a href="#l25.38"></a><span id="l25.38">   if (WeAreOffline())</span>
<a href="#l25.39"></a><span id="l25.39">     return NS_MSG_ERROR_OFFLINE;</span>
<a href="#l25.40"></a><span id="l25.40"> </span>
<a href="#l25.41"></a><span id="l25.41">   bool canOpenThisFolder = true;</span>
<a href="#l25.42"></a><span id="l25.42">   nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(aImapMailFolder);</span>
<a href="#l25.43"></a><span id="l25.43">   if (imapFolder)</span>
<a href="#l25.44"></a><span id="l25.44">     imapFolder-&gt;GetCanOpenFolder(&amp;canOpenThisFolder);</span>
<a href="#l25.45"></a><span id="l25.45"> </span>
<a href="#l25.46"></a><span id="l25.46" class="difflineminus">-  if (!canOpenThisFolder) </span>
<a href="#l25.47"></a><span id="l25.47" class="difflineplus">+  if (!canOpenThisFolder)</span>
<a href="#l25.48"></a><span id="l25.48">     return NS_OK;</span>
<a href="#l25.49"></a><span id="l25.49"> </span>
<a href="#l25.50"></a><span id="l25.50">   nsresult rv;</span>
<a href="#l25.51"></a><span id="l25.51">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.52"></a><span id="l25.52">   nsAutoCString urlSpec;</span>
<a href="#l25.53"></a><span id="l25.53">   char hierarchyDelimiter = GetHierarchyDelimiter(aImapMailFolder);</span>
<a href="#l25.54"></a><span id="l25.54">   rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl),</span>
<a href="#l25.55"></a><span id="l25.55">                             aImapMailFolder, aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.56"></a><span id="l25.56" class="difflineat">@@ -232,19 +232,19 @@ NS_IMETHODIMP nsImapService::LiteSelectF</span>
<a href="#l25.57"></a><span id="l25.57">                                               nsIURI **aURL)</span>
<a href="#l25.58"></a><span id="l25.58"> {</span>
<a href="#l25.59"></a><span id="l25.59">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.60"></a><span id="l25.60"> </span>
<a href="#l25.61"></a><span id="l25.61">   return FolderCommand(aImapMailFolder, aUrlListener,</span>
<a href="#l25.62"></a><span id="l25.62">                        &quot;/liteselect&gt;&quot;, nsIImapUrl::nsImapLiteSelectFolder, aMsgWindow, aURL);</span>
<a href="#l25.63"></a><span id="l25.63"> }</span>
<a href="#l25.64"></a><span id="l25.64"> </span>
<a href="#l25.65"></a><span id="l25.65" class="difflineminus">-NS_IMETHODIMP nsImapService::GetUrlForUri(const char *aMessageURI, </span>
<a href="#l25.66"></a><span id="l25.66" class="difflineminus">-                                          nsIURI **aURL, </span>
<a href="#l25.67"></a><span id="l25.67" class="difflineminus">-                                          nsIMsgWindow *aMsgWindow) </span>
<a href="#l25.68"></a><span id="l25.68" class="difflineplus">+NS_IMETHODIMP nsImapService::GetUrlForUri(const char *aMessageURI,</span>
<a href="#l25.69"></a><span id="l25.69" class="difflineplus">+                                          nsIURI **aURL,</span>
<a href="#l25.70"></a><span id="l25.70" class="difflineplus">+                                          nsIMsgWindow *aMsgWindow)</span>
<a href="#l25.71"></a><span id="l25.71"> {</span>
<a href="#l25.72"></a><span id="l25.72">   nsAutoCString messageURI(aMessageURI);</span>
<a href="#l25.73"></a><span id="l25.73"> </span>
<a href="#l25.74"></a><span id="l25.74">   if (messageURI.Find(NS_LITERAL_CSTRING(&quot;&amp;type=application/x-message-display&quot;)) != kNotFound)</span>
<a href="#l25.75"></a><span id="l25.75">     return NS_NewURI(aURL, aMessageURI);</span>
<a href="#l25.76"></a><span id="l25.76"> </span>
<a href="#l25.77"></a><span id="l25.77">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l25.78"></a><span id="l25.78">   nsAutoCString msgKey;</span>
<a href="#l25.79"></a><span id="l25.79" class="difflineat">@@ -276,32 +276,32 @@ NS_IMETHODIMP nsImapService::GetUrlForUr</span>
<a href="#l25.80"></a><span id="l25.80">     urlSpec.Append(msgKey);</span>
<a href="#l25.81"></a><span id="l25.81">     rv = url-&gt;SetSpecInternal(urlSpec);</span>
<a href="#l25.82"></a><span id="l25.82">     imapUrl-&gt;QueryInterface(NS_GET_IID(nsIURI), (void **) aURL);</span>
<a href="#l25.83"></a><span id="l25.83">   }</span>
<a href="#l25.84"></a><span id="l25.84"> </span>
<a href="#l25.85"></a><span id="l25.85">   return rv;</span>
<a href="#l25.86"></a><span id="l25.86"> }</span>
<a href="#l25.87"></a><span id="l25.87"> </span>
<a href="#l25.88"></a><span id="l25.88" class="difflineminus">-NS_IMETHODIMP nsImapService::OpenAttachment(const char *aContentType, </span>
<a href="#l25.89"></a><span id="l25.89" class="difflineplus">+NS_IMETHODIMP nsImapService::OpenAttachment(const char *aContentType,</span>
<a href="#l25.90"></a><span id="l25.90">                                             const char *aFileName,</span>
<a href="#l25.91"></a><span id="l25.91" class="difflineminus">-                                            const char *aUrl, </span>
<a href="#l25.92"></a><span id="l25.92" class="difflineminus">-                                            const char *aMessageUri, </span>
<a href="#l25.93"></a><span id="l25.93" class="difflineminus">-                                            nsISupports *aDisplayConsumer, </span>
<a href="#l25.94"></a><span id="l25.94" class="difflineminus">-                                            nsIMsgWindow *aMsgWindow, </span>
<a href="#l25.95"></a><span id="l25.95" class="difflineplus">+                                            const char *aUrl,</span>
<a href="#l25.96"></a><span id="l25.96" class="difflineplus">+                                            const char *aMessageUri,</span>
<a href="#l25.97"></a><span id="l25.97" class="difflineplus">+                                            nsISupports *aDisplayConsumer,</span>
<a href="#l25.98"></a><span id="l25.98" class="difflineplus">+                                            nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.99"></a><span id="l25.99">                                             nsIUrlListener *aUrlListener)</span>
<a href="#l25.100"></a><span id="l25.100"> {</span>
<a href="#l25.101"></a><span id="l25.101">   // okay this is a little tricky....we may have to fetch the mime part</span>
<a href="#l25.102"></a><span id="l25.102" class="difflineminus">-  // or it may already be downloaded for us....the only way i can tell to </span>
<a href="#l25.103"></a><span id="l25.103" class="difflineplus">+  // or it may already be downloaded for us....the only way i can tell to</span>
<a href="#l25.104"></a><span id="l25.104">   // distinguish the two events is to search for ?section or ?part</span>
<a href="#l25.105"></a><span id="l25.105" class="difflineminus">-  </span>
<a href="#l25.106"></a><span id="l25.106" class="difflineplus">+</span>
<a href="#l25.107"></a><span id="l25.107">   nsAutoCString uri(aMessageUri);</span>
<a href="#l25.108"></a><span id="l25.108">   nsAutoCString urlString(aUrl);</span>
<a href="#l25.109"></a><span id="l25.109">   MsgReplaceSubstring(urlString, &quot;/;section&quot;, &quot;?section&quot;);</span>
<a href="#l25.110"></a><span id="l25.110" class="difflineminus">-  </span>
<a href="#l25.111"></a><span id="l25.111" class="difflineplus">+</span>
<a href="#l25.112"></a><span id="l25.112">   // more stuff i don't understand</span>
<a href="#l25.113"></a><span id="l25.113">   int32_t sectionPos = urlString.Find(&quot;?section&quot;);</span>
<a href="#l25.114"></a><span id="l25.114">   // if we have a section field then we must be dealing with a mime part we need to fetchf</span>
<a href="#l25.115"></a><span id="l25.115">   if (sectionPos &gt; 0)</span>
<a href="#l25.116"></a><span id="l25.116">   {</span>
<a href="#l25.117"></a><span id="l25.117">     uri.Append(Substring(urlString, sectionPos));</span>
<a href="#l25.118"></a><span id="l25.118">     uri += &quot;&amp;type=&quot;;</span>
<a href="#l25.119"></a><span id="l25.119">     uri += aContentType;</span>
<a href="#l25.120"></a><span id="l25.120" class="difflineat">@@ -367,56 +367,56 @@ NS_IMETHODIMP nsImapService::OpenAttachm</span>
<a href="#l25.121"></a><span id="l25.121">                             nullptr, aDisplayConsumer, msgKey, uriMimePart);</span>
<a href="#l25.122"></a><span id="l25.122">       }</span>
<a href="#l25.123"></a><span id="l25.123">     } // if we got a message sink</span>
<a href="#l25.124"></a><span id="l25.124">   } // if we parsed the message uri</span>
<a href="#l25.125"></a><span id="l25.125"> </span>
<a href="#l25.126"></a><span id="l25.126">   return rv;</span>
<a href="#l25.127"></a><span id="l25.127"> }</span>
<a href="#l25.128"></a><span id="l25.128"> </span>
<a href="#l25.129"></a><span id="l25.129" class="difflineminus">-NS_IMETHODIMP nsImapService::FetchMimePart(nsIURI *aURI, </span>
<a href="#l25.130"></a><span id="l25.130" class="difflineminus">-                                           const char *aMessageURI, </span>
<a href="#l25.131"></a><span id="l25.131" class="difflineminus">-                                           nsISupports *aDisplayConsumer, </span>
<a href="#l25.132"></a><span id="l25.132" class="difflineminus">-                                           nsIMsgWindow *aMsgWindow, </span>
<a href="#l25.133"></a><span id="l25.133" class="difflineminus">-                                           nsIUrlListener *aUrlListener, </span>
<a href="#l25.134"></a><span id="l25.134" class="difflineplus">+NS_IMETHODIMP nsImapService::FetchMimePart(nsIURI *aURI,</span>
<a href="#l25.135"></a><span id="l25.135" class="difflineplus">+                                           const char *aMessageURI,</span>
<a href="#l25.136"></a><span id="l25.136" class="difflineplus">+                                           nsISupports *aDisplayConsumer,</span>
<a href="#l25.137"></a><span id="l25.137" class="difflineplus">+                                           nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.138"></a><span id="l25.138" class="difflineplus">+                                           nsIUrlListener *aUrlListener,</span>
<a href="#l25.139"></a><span id="l25.139">                                            nsIURI **aURL)</span>
<a href="#l25.140"></a><span id="l25.140"> {</span>
<a href="#l25.141"></a><span id="l25.141">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l25.142"></a><span id="l25.142">   nsAutoCString messageURI(aMessageURI);</span>
<a href="#l25.143"></a><span id="l25.143">   nsAutoCString msgKey;</span>
<a href="#l25.144"></a><span id="l25.144">   nsAutoCString mimePart;</span>
<a href="#l25.145"></a><span id="l25.145">   nsAutoCString folderURI;</span>
<a href="#l25.146"></a><span id="l25.146">   nsMsgKey key;</span>
<a href="#l25.147"></a><span id="l25.147" class="difflineminus">-  </span>
<a href="#l25.148"></a><span id="l25.148" class="difflineplus">+</span>
<a href="#l25.149"></a><span id="l25.149">   nsresult rv = DecomposeImapURI(messageURI, getter_AddRefs(folder), msgKey);</span>
<a href="#l25.150"></a><span id="l25.150">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.151"></a><span id="l25.151">   rv = nsParseImapMessageURI(aMessageURI, folderURI, &amp;key, getter_Copies(mimePart));</span>
<a href="#l25.152"></a><span id="l25.152">   if (NS_SUCCEEDED(rv))</span>
<a href="#l25.153"></a><span id="l25.153">   {</span>
<a href="#l25.154"></a><span id="l25.154">     nsCOMPtr&lt;nsIImapMessageSink&gt; imapMessageSink(do_QueryInterface(folder, &amp;rv));</span>
<a href="#l25.155"></a><span id="l25.155">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.156"></a><span id="l25.156">     {</span>
<a href="#l25.157"></a><span id="l25.157">       nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(aURI);</span>
<a href="#l25.158"></a><span id="l25.158">       nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; msgurl (do_QueryInterface(aURI));</span>
<a href="#l25.159"></a><span id="l25.159" class="difflineminus">-      </span>
<a href="#l25.160"></a><span id="l25.160" class="difflineplus">+</span>
<a href="#l25.161"></a><span id="l25.161">       msgurl-&gt;SetMsgWindow(aMsgWindow);</span>
<a href="#l25.162"></a><span id="l25.162">       msgurl-&gt;RegisterListener(aUrlListener);</span>
<a href="#l25.163"></a><span id="l25.163" class="difflineminus">-      </span>
<a href="#l25.164"></a><span id="l25.164" class="difflineplus">+</span>
<a href="#l25.165"></a><span id="l25.165">       if (!mimePart.IsEmpty())</span>
<a href="#l25.166"></a><span id="l25.166">       {</span>
<a href="#l25.167"></a><span id="l25.167">         return FetchMimePart(imapUrl, nsIImapUrl::nsImapMsgFetch, folder, imapMessageSink,</span>
<a href="#l25.168"></a><span id="l25.168">           aURL, aDisplayConsumer, msgKey, mimePart);</span>
<a href="#l25.169"></a><span id="l25.169">       }</span>
<a href="#l25.170"></a><span id="l25.170">     }</span>
<a href="#l25.171"></a><span id="l25.171">   }</span>
<a href="#l25.172"></a><span id="l25.172">   return rv;</span>
<a href="#l25.173"></a><span id="l25.173"> }</span>
<a href="#l25.174"></a><span id="l25.174"> </span>
<a href="#l25.175"></a><span id="l25.175"> NS_IMETHODIMP nsImapService::DisplayMessage(const char *aMessageURI,</span>
<a href="#l25.176"></a><span id="l25.176" class="difflineminus">-                                            nsISupports *aDisplayConsumer,  </span>
<a href="#l25.177"></a><span id="l25.177" class="difflineplus">+                                            nsISupports *aDisplayConsumer,</span>
<a href="#l25.178"></a><span id="l25.178">                                             nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.179"></a><span id="l25.179">                                             nsIUrlListener *aUrlListener,</span>
<a href="#l25.180"></a><span id="l25.180">                                             const char *aCharsetOverride,</span>
<a href="#l25.181"></a><span id="l25.181">                                             nsIURI **aURL)</span>
<a href="#l25.182"></a><span id="l25.182"> {</span>
<a href="#l25.183"></a><span id="l25.183">   nsresult rv;</span>
<a href="#l25.184"></a><span id="l25.184"> </span>
<a href="#l25.185"></a><span id="l25.185">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l25.186"></a><span id="l25.186" class="difflineat">@@ -543,33 +543,33 @@ NS_IMETHODIMP nsImapService::DisplayMess</span>
<a href="#l25.187"></a><span id="l25.187">         int32_t dontMarkAsReadPos = uriStr.Find(&quot;&amp;markRead=false&quot;);</span>
<a href="#l25.188"></a><span id="l25.188">         bool markReadAuto = true;</span>
<a href="#l25.189"></a><span id="l25.189">         prefBranch-&gt;GetBoolPref(&quot;mailnews.mark_message_read.auto&quot;, &amp;markReadAuto);</span>
<a href="#l25.190"></a><span id="l25.190">         bool markReadDelay = false;</span>
<a href="#l25.191"></a><span id="l25.191">         prefBranch-&gt;GetBoolPref(&quot;mailnews.mark_message_read.delay&quot;, &amp;markReadDelay);</span>
<a href="#l25.192"></a><span id="l25.192">         forcePeek = (!markReadAuto || markReadDelay || (dontMarkAsReadPos != kNotFound));</span>
<a href="#l25.193"></a><span id="l25.193">       }</span>
<a href="#l25.194"></a><span id="l25.194"> </span>
<a href="#l25.195"></a><span id="l25.195" class="difflineminus">-      rv = FetchMessage(imapUrl, forcePeek ? nsIImapUrl::nsImapMsgFetchPeek : nsIImapUrl::nsImapMsgFetch, </span>
<a href="#l25.196"></a><span id="l25.196" class="difflineminus">-                        folder, imapMessageSink, aMsgWindow, aDisplayConsumer, msgKey, false, </span>
<a href="#l25.197"></a><span id="l25.197" class="difflineplus">+      rv = FetchMessage(imapUrl, forcePeek ? nsIImapUrl::nsImapMsgFetchPeek : nsIImapUrl::nsImapMsgFetch,</span>
<a href="#l25.198"></a><span id="l25.198" class="difflineplus">+                        folder, imapMessageSink, aMsgWindow, aDisplayConsumer, msgKey, false,</span>
<a href="#l25.199"></a><span id="l25.199">                         (mPrintingOperation) ? NS_LITERAL_CSTRING(&quot;print&quot;) : NS_LITERAL_CSTRING(&quot;&quot;), aURL);</span>
<a href="#l25.200"></a><span id="l25.200">     }</span>
<a href="#l25.201"></a><span id="l25.201">   }</span>
<a href="#l25.202"></a><span id="l25.202">   return rv;</span>
<a href="#l25.203"></a><span id="l25.203"> }</span>
<a href="#l25.204"></a><span id="l25.204"> </span>
<a href="#l25.205"></a><span id="l25.205"> </span>
<a href="#l25.206"></a><span id="l25.206"> nsresult nsImapService::FetchMimePart(nsIImapUrl *aImapUrl,</span>
<a href="#l25.207"></a><span id="l25.207">                                       nsImapAction aImapAction,</span>
<a href="#l25.208"></a><span id="l25.208" class="difflineminus">-                                      nsIMsgFolder *aImapMailFolder, </span>
<a href="#l25.209"></a><span id="l25.209" class="difflineplus">+                                      nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.210"></a><span id="l25.210">                                       nsIImapMessageSink *aImapMessage,</span>
<a href="#l25.211"></a><span id="l25.211">                                       nsIURI **aURL,</span>
<a href="#l25.212"></a><span id="l25.212" class="difflineminus">-                                      nsISupports *aDisplayConsumer, </span>
<a href="#l25.213"></a><span id="l25.213" class="difflineplus">+                                      nsISupports *aDisplayConsumer,</span>
<a href="#l25.214"></a><span id="l25.214">                                       const nsACString &amp;messageIdentifierList,</span>
<a href="#l25.215"></a><span id="l25.215" class="difflineminus">-                                      const nsACString &amp;mimePart) </span>
<a href="#l25.216"></a><span id="l25.216" class="difflineplus">+                                      const nsACString &amp;mimePart)</span>
<a href="#l25.217"></a><span id="l25.217"> {</span>
<a href="#l25.218"></a><span id="l25.218">   NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l25.219"></a><span id="l25.219">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.220"></a><span id="l25.220">   NS_ENSURE_ARG_POINTER(aImapMessage);</span>
<a href="#l25.221"></a><span id="l25.221"> </span>
<a href="#l25.222"></a><span id="l25.222">   // create a protocol instance to handle the request.</span>
<a href="#l25.223"></a><span id="l25.223">   // NOTE: once we start working with multiple connections, this step will be much more complicated...but for now</span>
<a href="#l25.224"></a><span id="l25.224">   // just create a connection and process the request.</span>
<a href="#l25.225"></a><span id="l25.225" class="difflineat">@@ -618,46 +618,46 @@ nsresult nsImapService::FetchMimePart(ns</span>
<a href="#l25.226"></a><span id="l25.226">           aImapServer(do_QueryInterface(aMsgIncomingServer, &amp;rv));</span>
<a href="#l25.227"></a><span id="l25.227">         if (NS_SUCCEEDED(rv) &amp;&amp; aImapServer)</span>
<a href="#l25.228"></a><span id="l25.228">           aImapServer-&gt;PseudoInterruptMsgLoad(aImapMailFolder, nullptr, &amp;interrupted);</span>
<a href="#l25.229"></a><span id="l25.229">       }</span>
<a href="#l25.230"></a><span id="l25.230">     }</span>
<a href="#l25.231"></a><span id="l25.231">     // if the display consumer is a docshell, then we should run the url in the docshell.</span>
<a href="#l25.232"></a><span id="l25.232">     // otherwise, it should be a stream listener....so open a channel using AsyncRead</span>
<a href="#l25.233"></a><span id="l25.233">     // and the provided stream listener....</span>
<a href="#l25.234"></a><span id="l25.234" class="difflineminus">-    </span>
<a href="#l25.235"></a><span id="l25.235" class="difflineplus">+</span>
<a href="#l25.236"></a><span id="l25.236">     nsCOMPtr&lt;nsIDocShell&gt; docShell(do_QueryInterface(aDisplayConsumer, &amp;rv));</span>
<a href="#l25.237"></a><span id="l25.237">     if (NS_SUCCEEDED(rv) &amp;&amp; docShell)</span>
<a href="#l25.238"></a><span id="l25.238">     {</span>
<a href="#l25.239"></a><span id="l25.239">       nsCOMPtr&lt;nsIDocShellLoadInfo&gt; loadInfo;</span>
<a href="#l25.240"></a><span id="l25.240">       // DIRTY LITTLE HACK --&gt; if we are opening an attachment we want the docshell to</span>
<a href="#l25.241"></a><span id="l25.241">       // treat this load as if it were a user click event. Then the dispatching stuff will be much</span>
<a href="#l25.242"></a><span id="l25.242">       // happier.</span>
<a href="#l25.243"></a><span id="l25.243">       if (aImapAction == nsImapUrl::nsImapOpenMimePart)</span>
<a href="#l25.244"></a><span id="l25.244">       {</span>
<a href="#l25.245"></a><span id="l25.245">         docShell-&gt;CreateLoadInfo(getter_AddRefs(loadInfo));</span>
<a href="#l25.246"></a><span id="l25.246">         loadInfo-&gt;SetLoadType(nsIDocShellLoadInfo::loadLink);</span>
<a href="#l25.247"></a><span id="l25.247">       }</span>
<a href="#l25.248"></a><span id="l25.248" class="difflineminus">-      </span>
<a href="#l25.249"></a><span id="l25.249" class="difflineplus">+</span>
<a href="#l25.250"></a><span id="l25.250">       rv = docShell-&gt;LoadURI(url, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, false);</span>
<a href="#l25.251"></a><span id="l25.251">     }</span>
<a href="#l25.252"></a><span id="l25.252">     else</span>
<a href="#l25.253"></a><span id="l25.253">     {</span>
<a href="#l25.254"></a><span id="l25.254">       nsCOMPtr&lt;nsIStreamListener&gt; aStreamListener = do_QueryInterface(aDisplayConsumer, &amp;rv);</span>
<a href="#l25.255"></a><span id="l25.255">       if (NS_SUCCEEDED(rv) &amp;&amp; aStreamListener)</span>
<a href="#l25.256"></a><span id="l25.256">       {</span>
<a href="#l25.257"></a><span id="l25.257">         nsCOMPtr&lt;nsIChannel&gt; aChannel;</span>
<a href="#l25.258"></a><span id="l25.258">         nsCOMPtr&lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l25.259"></a><span id="l25.259">         nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(aImapUrl, &amp;rv);</span>
<a href="#l25.260"></a><span id="l25.260">         if (NS_SUCCEEDED(rv) &amp;&amp; mailnewsUrl)</span>
<a href="#l25.261"></a><span id="l25.261">           mailnewsUrl-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l25.262"></a><span id="l25.262" class="difflineminus">-        </span>
<a href="#l25.263"></a><span id="l25.263" class="difflineplus">+</span>
<a href="#l25.264"></a><span id="l25.264">         rv = NewChannel(url, getter_AddRefs(aChannel));</span>
<a href="#l25.265"></a><span id="l25.265">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.266"></a><span id="l25.266" class="difflineminus">-        </span>
<a href="#l25.267"></a><span id="l25.267" class="difflineplus">+</span>
<a href="#l25.268"></a><span id="l25.268">         // we need a load group to hold onto the channel. When the request is finished,</span>
<a href="#l25.269"></a><span id="l25.269">         // it'll get removed from the load group, and the channel will go away,</span>
<a href="#l25.270"></a><span id="l25.270">         // which will free the load group.</span>
<a href="#l25.271"></a><span id="l25.271">         if (!loadGroup)</span>
<a href="#l25.272"></a><span id="l25.272">           loadGroup = do_CreateInstance(NS_LOADGROUP_CONTRACTID);</span>
<a href="#l25.273"></a><span id="l25.273"> </span>
<a href="#l25.274"></a><span id="l25.274">         aChannel-&gt;SetLoadGroup(loadGroup);</span>
<a href="#l25.275"></a><span id="l25.275"> </span>
<a href="#l25.276"></a><span id="l25.276" class="difflineat">@@ -680,42 +680,42 @@ nsresult nsImapService::FetchMimePart(ns</span>
<a href="#l25.277"></a><span id="l25.277">   return rv;</span>
<a href="#l25.278"></a><span id="l25.278"> }</span>
<a href="#l25.279"></a><span id="l25.279"> </span>
<a href="#l25.280"></a><span id="l25.280"> //</span>
<a href="#l25.281"></a><span id="l25.281"> // rhp: Right now, this is the same as simple DisplayMessage, but it will change</span>
<a href="#l25.282"></a><span id="l25.282"> // to support print rendering.</span>
<a href="#l25.283"></a><span id="l25.283"> //</span>
<a href="#l25.284"></a><span id="l25.284"> NS_IMETHODIMP nsImapService::DisplayMessageForPrinting(const char *aMessageURI,</span>
<a href="#l25.285"></a><span id="l25.285" class="difflineminus">-                                                       nsISupports *aDisplayConsumer,  </span>
<a href="#l25.286"></a><span id="l25.286" class="difflineplus">+                                                       nsISupports *aDisplayConsumer,</span>
<a href="#l25.287"></a><span id="l25.287">                                                        nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.288"></a><span id="l25.288">                                                        nsIUrlListener *aUrlListener,</span>
<a href="#l25.289"></a><span id="l25.289" class="difflineminus">-                                                       nsIURI **aURL) </span>
<a href="#l25.290"></a><span id="l25.290" class="difflineplus">+                                                       nsIURI **aURL)</span>
<a href="#l25.291"></a><span id="l25.291"> {</span>
<a href="#l25.292"></a><span id="l25.292">   mPrintingOperation = true;</span>
<a href="#l25.293"></a><span id="l25.293">   nsresult rv = DisplayMessage(aMessageURI, aDisplayConsumer, aMsgWindow, aUrlListener, nullptr, aURL);</span>
<a href="#l25.294"></a><span id="l25.294">   mPrintingOperation = false;</span>
<a href="#l25.295"></a><span id="l25.295">   return rv;</span>
<a href="#l25.296"></a><span id="l25.296"> }</span>
<a href="#l25.297"></a><span id="l25.297"> </span>
<a href="#l25.298"></a><span id="l25.298" class="difflineminus">-NS_IMETHODIMP nsImapService::CopyMessage(const char *aSrcMailboxURI, </span>
<a href="#l25.299"></a><span id="l25.299" class="difflineminus">-                                         nsIStreamListener *aMailboxCopy, </span>
<a href="#l25.300"></a><span id="l25.300" class="difflineplus">+NS_IMETHODIMP nsImapService::CopyMessage(const char *aSrcMailboxURI,</span>
<a href="#l25.301"></a><span id="l25.301" class="difflineplus">+                                         nsIStreamListener *aMailboxCopy,</span>
<a href="#l25.302"></a><span id="l25.302">                                          bool moveMessage,</span>
<a href="#l25.303"></a><span id="l25.303" class="difflineminus">-                                         nsIUrlListener *aUrlListener, </span>
<a href="#l25.304"></a><span id="l25.304" class="difflineminus">-                                         nsIMsgWindow *aMsgWindow, </span>
<a href="#l25.305"></a><span id="l25.305" class="difflineplus">+                                         nsIUrlListener *aUrlListener,</span>
<a href="#l25.306"></a><span id="l25.306" class="difflineplus">+                                         nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.307"></a><span id="l25.307">                                          nsIURI **aURL)</span>
<a href="#l25.308"></a><span id="l25.308"> {</span>
<a href="#l25.309"></a><span id="l25.309">   NS_ENSURE_ARG_POINTER(aSrcMailboxURI);</span>
<a href="#l25.310"></a><span id="l25.310">   NS_ENSURE_ARG_POINTER(aMailboxCopy);</span>
<a href="#l25.311"></a><span id="l25.311" class="difflineminus">-  </span>
<a href="#l25.312"></a><span id="l25.312" class="difflineplus">+</span>
<a href="#l25.313"></a><span id="l25.313">   nsresult rv;</span>
<a href="#l25.314"></a><span id="l25.314">   nsCOMPtr&lt;nsISupports&gt; streamSupport;</span>
<a href="#l25.315"></a><span id="l25.315">   streamSupport = do_QueryInterface(aMailboxCopy, &amp;rv);</span>
<a href="#l25.316"></a><span id="l25.316">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.317"></a><span id="l25.317" class="difflineminus">-  </span>
<a href="#l25.318"></a><span id="l25.318" class="difflineplus">+</span>
<a href="#l25.319"></a><span id="l25.319">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l25.320"></a><span id="l25.320">   nsAutoCString msgKey;</span>
<a href="#l25.321"></a><span id="l25.321">   rv = DecomposeImapURI(nsDependentCString(aSrcMailboxURI), getter_AddRefs(folder), msgKey);</span>
<a href="#l25.322"></a><span id="l25.322">   if (NS_SUCCEEDED(rv))</span>
<a href="#l25.323"></a><span id="l25.323">   {</span>
<a href="#l25.324"></a><span id="l25.324">     nsCOMPtr&lt;nsIImapMessageSink&gt; imapMessageSink(do_QueryInterface(folder, &amp;rv));</span>
<a href="#l25.325"></a><span id="l25.325">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.326"></a><span id="l25.326">     {</span>
<a href="#l25.327"></a><span id="l25.327" class="difflineat">@@ -732,41 +732,41 @@ NS_IMETHODIMP nsImapService::CopyMessage</span>
<a href="#l25.328"></a><span id="l25.328">         nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; msgurl (do_QueryInterface(imapUrl));</span>
<a href="#l25.329"></a><span id="l25.329">         folder-&gt;HasMsgOffline(key, &amp;hasMsgOffline);</span>
<a href="#l25.330"></a><span id="l25.330">         if (msgurl)</span>
<a href="#l25.331"></a><span id="l25.331">           msgurl-&gt;SetMsgIsInLocalCache(hasMsgOffline);</span>
<a href="#l25.332"></a><span id="l25.332">       }</span>
<a href="#l25.333"></a><span id="l25.333">       // now try to download the message</span>
<a href="#l25.334"></a><span id="l25.334">       nsImapAction imapAction = nsIImapUrl::nsImapOnlineToOfflineCopy;</span>
<a href="#l25.335"></a><span id="l25.335">       if (moveMessage)</span>
<a href="#l25.336"></a><span id="l25.336" class="difflineminus">-        imapAction = nsIImapUrl::nsImapOnlineToOfflineMove; </span>
<a href="#l25.337"></a><span id="l25.337" class="difflineminus">-      rv = FetchMessage(imapUrl,imapAction, folder, imapMessageSink,aMsgWindow, </span>
<a href="#l25.338"></a><span id="l25.338" class="difflineplus">+        imapAction = nsIImapUrl::nsImapOnlineToOfflineMove;</span>
<a href="#l25.339"></a><span id="l25.339" class="difflineplus">+      rv = FetchMessage(imapUrl,imapAction, folder, imapMessageSink,aMsgWindow,</span>
<a href="#l25.340"></a><span id="l25.340">                         streamSupport, msgKey, false, EmptyCString(), aURL);</span>
<a href="#l25.341"></a><span id="l25.341">     } // if we got an imap message sink</span>
<a href="#l25.342"></a><span id="l25.342" class="difflineminus">-  } // if we decomposed the imap message </span>
<a href="#l25.343"></a><span id="l25.343" class="difflineplus">+  } // if we decomposed the imap message</span>
<a href="#l25.344"></a><span id="l25.344">   return rv;</span>
<a href="#l25.345"></a><span id="l25.345"> }</span>
<a href="#l25.346"></a><span id="l25.346"> </span>
<a href="#l25.347"></a><span id="l25.347"> NS_IMETHODIMP nsImapService::CopyMessages(uint32_t aNumKeys,</span>
<a href="#l25.348"></a><span id="l25.348">                                           nsMsgKey*aKeys,</span>
<a href="#l25.349"></a><span id="l25.349">                                           nsIMsgFolder *srcFolder,</span>
<a href="#l25.350"></a><span id="l25.350">                                           nsIStreamListener *aMailboxCopy,</span>
<a href="#l25.351"></a><span id="l25.351">                                           bool moveMessage,</span>
<a href="#l25.352"></a><span id="l25.352">                                           nsIUrlListener *aUrlListener,</span>
<a href="#l25.353"></a><span id="l25.353" class="difflineminus">-                                          nsIMsgWindow *aMsgWindow, </span>
<a href="#l25.354"></a><span id="l25.354" class="difflineplus">+                                          nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.355"></a><span id="l25.355">                                           nsIURI **aURL)</span>
<a href="#l25.356"></a><span id="l25.356"> {</span>
<a href="#l25.357"></a><span id="l25.357">   NS_ENSURE_ARG_POINTER(aMailboxCopy);</span>
<a href="#l25.358"></a><span id="l25.358">   NS_ENSURE_ARG_POINTER(aKeys);</span>
<a href="#l25.359"></a><span id="l25.359"> </span>
<a href="#l25.360"></a><span id="l25.360">   nsresult rv;</span>
<a href="#l25.361"></a><span id="l25.361">   nsCOMPtr&lt;nsISupports&gt; streamSupport = do_QueryInterface(aMailboxCopy, &amp;rv);</span>
<a href="#l25.362"></a><span id="l25.362" class="difflineminus">-  if (!streamSupport || NS_FAILED(rv)) </span>
<a href="#l25.363"></a><span id="l25.363" class="difflineplus">+  if (!streamSupport || NS_FAILED(rv))</span>
<a href="#l25.364"></a><span id="l25.364">     return rv;</span>
<a href="#l25.365"></a><span id="l25.365" class="difflineminus">-  </span>
<a href="#l25.366"></a><span id="l25.366" class="difflineplus">+</span>
<a href="#l25.367"></a><span id="l25.367">   nsCOMPtr&lt;nsIMsgFolder&gt; folder = srcFolder;</span>
<a href="#l25.368"></a><span id="l25.368">   if (NS_SUCCEEDED(rv))</span>
<a href="#l25.369"></a><span id="l25.369">   {</span>
<a href="#l25.370"></a><span id="l25.370">     nsCOMPtr&lt;nsIImapMessageSink&gt; imapMessageSink(do_QueryInterface(folder, &amp;rv));</span>
<a href="#l25.371"></a><span id="l25.371">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.372"></a><span id="l25.372">     {</span>
<a href="#l25.373"></a><span id="l25.373">       // we generate the uri for the first message so that way on down the line,</span>
<a href="#l25.374"></a><span id="l25.374">       // GetMessage in nsCopyMessageStreamListener will get an unescaped username</span>
<a href="#l25.375"></a><span id="l25.375" class="difflineat">@@ -782,28 +782,28 @@ NS_IMETHODIMP nsImapService::CopyMessage</span>
<a href="#l25.376"></a><span id="l25.376">       rv = CreateStartOfImapUrl(uri, getter_AddRefs(imapUrl), folder, aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.377"></a><span id="l25.377">       nsImapAction action;</span>
<a href="#l25.378"></a><span id="l25.378">       if (moveMessage) // don't use ?: syntax here, it seems to break the Mac.</span>
<a href="#l25.379"></a><span id="l25.379">         action = nsIImapUrl::nsImapOnlineToOfflineMove;</span>
<a href="#l25.380"></a><span id="l25.380">       else</span>
<a href="#l25.381"></a><span id="l25.381">         action = nsIImapUrl::nsImapOnlineToOfflineCopy;</span>
<a href="#l25.382"></a><span id="l25.382">       imapUrl-&gt;SetCopyState(aMailboxCopy);</span>
<a href="#l25.383"></a><span id="l25.383">       // now try to display the message</span>
<a href="#l25.384"></a><span id="l25.384" class="difflineminus">-      rv = FetchMessage(imapUrl, action, folder, imapMessageSink, aMsgWindow, </span>
<a href="#l25.385"></a><span id="l25.385" class="difflineplus">+      rv = FetchMessage(imapUrl, action, folder, imapMessageSink, aMsgWindow,</span>
<a href="#l25.386"></a><span id="l25.386">                         streamSupport, messageIds, false, EmptyCString(), aURL);</span>
<a href="#l25.387"></a><span id="l25.387">       // ### end of copy operation should know how to do the delete.if this is a move</span>
<a href="#l25.388"></a><span id="l25.388" class="difflineminus">-      </span>
<a href="#l25.389"></a><span id="l25.389" class="difflineplus">+</span>
<a href="#l25.390"></a><span id="l25.390">     } // if we got an imap message sink</span>
<a href="#l25.391"></a><span id="l25.391" class="difflineminus">-  } // if we decomposed the imap message </span>
<a href="#l25.392"></a><span id="l25.392" class="difflineplus">+  } // if we decomposed the imap message</span>
<a href="#l25.393"></a><span id="l25.393">   return rv;</span>
<a href="#l25.394"></a><span id="l25.394"> }</span>
<a href="#l25.395"></a><span id="l25.395"> </span>
<a href="#l25.396"></a><span id="l25.396" class="difflineminus">-NS_IMETHODIMP nsImapService::Search(nsIMsgSearchSession *aSearchSession, </span>
<a href="#l25.397"></a><span id="l25.397" class="difflineminus">-                                    nsIMsgWindow *aMsgWindow, </span>
<a href="#l25.398"></a><span id="l25.398" class="difflineminus">-                                    nsIMsgFolder *aMsgFolder, </span>
<a href="#l25.399"></a><span id="l25.399" class="difflineplus">+NS_IMETHODIMP nsImapService::Search(nsIMsgSearchSession *aSearchSession,</span>
<a href="#l25.400"></a><span id="l25.400" class="difflineplus">+                                    nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.401"></a><span id="l25.401" class="difflineplus">+                                    nsIMsgFolder *aMsgFolder,</span>
<a href="#l25.402"></a><span id="l25.402">                                     const char *aSearchUri)</span>
<a href="#l25.403"></a><span id="l25.403"> {</span>
<a href="#l25.404"></a><span id="l25.404">   NS_ENSURE_ARG_POINTER(aSearchUri);</span>
<a href="#l25.405"></a><span id="l25.405">   NS_ENSURE_ARG_POINTER(aMsgFolder);</span>
<a href="#l25.406"></a><span id="l25.406">   nsresult rv;</span>
<a href="#l25.407"></a><span id="l25.407"> </span>
<a href="#l25.408"></a><span id="l25.408">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.409"></a><span id="l25.409">   nsCOMPtr &lt;nsIUrlListener&gt; urlListener = do_QueryInterface(aSearchSession, &amp;rv);</span>
<a href="#l25.410"></a><span id="l25.410" class="difflineat">@@ -913,36 +913,36 @@ NS_IMETHODIMP nsImapService::SaveMessage</span>
<a href="#l25.411"></a><span id="l25.411"> </span>
<a href="#l25.412"></a><span id="l25.412">   bool hasMsgOffline = false;</span>
<a href="#l25.413"></a><span id="l25.413"> </span>
<a href="#l25.414"></a><span id="l25.414">   if (folder)</span>
<a href="#l25.415"></a><span id="l25.415">     folder-&gt;HasMsgOffline(strtoul(msgKey.get(), nullptr, 10), &amp;hasMsgOffline);</span>
<a href="#l25.416"></a><span id="l25.416"> </span>
<a href="#l25.417"></a><span id="l25.417">   nsAutoCString urlSpec;</span>
<a href="#l25.418"></a><span id="l25.418">   char hierarchyDelimiter = GetHierarchyDelimiter(folder);</span>
<a href="#l25.419"></a><span id="l25.419" class="difflineminus">-  rv = CreateStartOfImapUrl(nsDependentCString(aMessageURI), getter_AddRefs(imapUrl), </span>
<a href="#l25.420"></a><span id="l25.420" class="difflineplus">+  rv = CreateStartOfImapUrl(nsDependentCString(aMessageURI), getter_AddRefs(imapUrl),</span>
<a href="#l25.421"></a><span id="l25.421">                             folder, aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.422"></a><span id="l25.422" class="difflineminus">-  if (NS_SUCCEEDED(rv)) </span>
<a href="#l25.423"></a><span id="l25.423" class="difflineplus">+  if (NS_SUCCEEDED(rv))</span>
<a href="#l25.424"></a><span id="l25.424">   {</span>
<a href="#l25.425"></a><span id="l25.425">     nsCOMPtr&lt;nsIImapMessageSink&gt; imapMessageSink(do_QueryInterface(folder, &amp;rv));</span>
<a href="#l25.426"></a><span id="l25.426" class="difflineminus">-    NS_ENSURE_SUCCESS(rv, rv);  </span>
<a href="#l25.427"></a><span id="l25.427" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.428"></a><span id="l25.428">     nsCOMPtr&lt;nsIMsgMessageUrl&gt; msgUrl = do_QueryInterface(imapUrl, &amp;rv);</span>
<a href="#l25.429"></a><span id="l25.429">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.430"></a><span id="l25.430">     msgUrl-&gt;SetMessageFile(aFile);</span>
<a href="#l25.431"></a><span id="l25.431">     msgUrl-&gt;SetAddDummyEnvelope(aAddDummyEnvelope);</span>
<a href="#l25.432"></a><span id="l25.432">     msgUrl-&gt;SetCanonicalLineEnding(canonicalLineEnding);</span>
<a href="#l25.433"></a><span id="l25.433"> </span>
<a href="#l25.434"></a><span id="l25.434">     nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(msgUrl);</span>
<a href="#l25.435"></a><span id="l25.435">     if (mailnewsUrl)</span>
<a href="#l25.436"></a><span id="l25.436">       mailnewsUrl-&gt;SetMsgIsInLocalCache(hasMsgOffline);</span>
<a href="#l25.437"></a><span id="l25.437"> </span>
<a href="#l25.438"></a><span id="l25.438">     nsCOMPtr &lt;nsIStreamListener&gt; saveAsListener;</span>
<a href="#l25.439"></a><span id="l25.439">     mailnewsUrl-&gt;GetSaveAsListener(aAddDummyEnvelope, aFile, getter_AddRefs(saveAsListener));</span>
<a href="#l25.440"></a><span id="l25.440"> </span>
<a href="#l25.441"></a><span id="l25.441" class="difflineminus">-    return FetchMessage(imapUrl, nsIImapUrl::nsImapSaveMessageToDisk, folder, imapMessageSink, </span>
<a href="#l25.442"></a><span id="l25.442" class="difflineplus">+    return FetchMessage(imapUrl, nsIImapUrl::nsImapSaveMessageToDisk, folder, imapMessageSink,</span>
<a href="#l25.443"></a><span id="l25.443">                         aMsgWindow, saveAsListener, msgKey, false, EmptyCString(), aURL);</span>
<a href="#l25.444"></a><span id="l25.444">   }</span>
<a href="#l25.445"></a><span id="l25.445">   return rv;</span>
<a href="#l25.446"></a><span id="l25.446"> }</span>
<a href="#l25.447"></a><span id="l25.447"> </span>
<a href="#l25.448"></a><span id="l25.448"> /* fetching RFC822 messages */</span>
<a href="#l25.449"></a><span id="l25.449"> /* imap4://HOST&gt;fetch&gt;&lt;UID&gt;&gt;MAILBOXPATH&gt;x */</span>
<a href="#l25.450"></a><span id="l25.450"> /*   'x' is the message UID */</span>
<a href="#l25.451"></a><span id="l25.451" class="difflineat">@@ -976,20 +976,20 @@ NS_IMETHODIMP nsImapService::AddImapFetc</span>
<a href="#l25.452"></a><span id="l25.452">     urlSpec.Append(aAdditionalHeader);</span>
<a href="#l25.453"></a><span id="l25.453">   }</span>
<a href="#l25.454"></a><span id="l25.454"> </span>
<a href="#l25.455"></a><span id="l25.455">   return aUrl-&gt;SetSpecInternal(urlSpec);</span>
<a href="#l25.456"></a><span id="l25.456"> }</span>
<a href="#l25.457"></a><span id="l25.457"> </span>
<a href="#l25.458"></a><span id="l25.458"> NS_IMETHODIMP nsImapService::FetchMessage(nsIImapUrl *aImapUrl,</span>
<a href="#l25.459"></a><span id="l25.459">                                           nsImapAction aImapAction,</span>
<a href="#l25.460"></a><span id="l25.460" class="difflineminus">-                                          nsIMsgFolder *aImapMailFolder, </span>
<a href="#l25.461"></a><span id="l25.461" class="difflineplus">+                                          nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.462"></a><span id="l25.462">                                           nsIImapMessageSink *aImapMessage,</span>
<a href="#l25.463"></a><span id="l25.463">                                           nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.464"></a><span id="l25.464" class="difflineminus">-                                          nsISupports *aDisplayConsumer, </span>
<a href="#l25.465"></a><span id="l25.465" class="difflineplus">+                                          nsISupports *aDisplayConsumer,</span>
<a href="#l25.466"></a><span id="l25.466">                                           const nsACString &amp;messageIdentifierList,</span>
<a href="#l25.467"></a><span id="l25.467">                                           bool aConvertDataToText,</span>
<a href="#l25.468"></a><span id="l25.468">                                           const nsACString &amp;aAdditionalHeader,</span>
<a href="#l25.469"></a><span id="l25.469">                                           nsIURI **aURL)</span>
<a href="#l25.470"></a><span id="l25.470"> {</span>
<a href="#l25.471"></a><span id="l25.471">   NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l25.472"></a><span id="l25.472">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.473"></a><span id="l25.473">   NS_ENSURE_ARG_POINTER(aImapMessage);</span>
<a href="#l25.474"></a><span id="l25.474" class="difflineat">@@ -1044,17 +1044,17 @@ nsresult nsImapService::GetMessageFromUr</span>
<a href="#l25.475"></a><span id="l25.475">   rv = aImapUrl-&gt;SetImapAction(aImapAction);</span>
<a href="#l25.476"></a><span id="l25.476">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.477"></a><span id="l25.477"> </span>
<a href="#l25.478"></a><span id="l25.478">   nsCOMPtr&lt;nsIURI&gt; url(do_QueryInterface(aImapUrl));</span>
<a href="#l25.479"></a><span id="l25.479"> </span>
<a href="#l25.480"></a><span id="l25.480">   // if the display consumer is a docshell, then we should run the url in the docshell.</span>
<a href="#l25.481"></a><span id="l25.481">   // otherwise, it should be a stream listener....so open a channel using AsyncRead</span>
<a href="#l25.482"></a><span id="l25.482">   // and the provided stream listener....</span>
<a href="#l25.483"></a><span id="l25.483" class="difflineminus">-  </span>
<a href="#l25.484"></a><span id="l25.484" class="difflineplus">+</span>
<a href="#l25.485"></a><span id="l25.485">   nsCOMPtr&lt;nsIDocShell&gt; docShell(do_QueryInterface(aDisplayConsumer, &amp;rv));</span>
<a href="#l25.486"></a><span id="l25.486">   if (aImapMailFolder &amp;&amp; docShell)</span>
<a href="#l25.487"></a><span id="l25.487">   {</span>
<a href="#l25.488"></a><span id="l25.488">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; aMsgIncomingServer;</span>
<a href="#l25.489"></a><span id="l25.489">     rv = aImapMailFolder-&gt;GetServer(getter_AddRefs(aMsgIncomingServer));</span>
<a href="#l25.490"></a><span id="l25.490">     if (NS_SUCCEEDED(rv) &amp;&amp; aMsgIncomingServer)</span>
<a href="#l25.491"></a><span id="l25.491">     {</span>
<a href="#l25.492"></a><span id="l25.492">       bool interrupted;</span>
<a href="#l25.493"></a><span id="l25.493" class="difflineat">@@ -1076,42 +1076,42 @@ nsresult nsImapService::GetMessageFromUr</span>
<a href="#l25.494"></a><span id="l25.494">     if (aMsgWindow &amp;&amp; mailnewsUrl)</span>
<a href="#l25.495"></a><span id="l25.495">       mailnewsUrl-&gt;SetMsgWindow(aMsgWindow);</span>
<a href="#l25.496"></a><span id="l25.496">     if (NS_SUCCEEDED(rv) &amp;&amp; streamListener)</span>
<a href="#l25.497"></a><span id="l25.497">     {</span>
<a href="#l25.498"></a><span id="l25.498">       nsCOMPtr&lt;nsIChannel&gt; channel;</span>
<a href="#l25.499"></a><span id="l25.499">       nsCOMPtr&lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l25.500"></a><span id="l25.500">       if (NS_SUCCEEDED(rv) &amp;&amp; mailnewsUrl)</span>
<a href="#l25.501"></a><span id="l25.501">         mailnewsUrl-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l25.502"></a><span id="l25.502" class="difflineminus">-      </span>
<a href="#l25.503"></a><span id="l25.503" class="difflineplus">+</span>
<a href="#l25.504"></a><span id="l25.504">       rv = NewChannel(url, getter_AddRefs(channel));</span>
<a href="#l25.505"></a><span id="l25.505">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.506"></a><span id="l25.506" class="difflineminus">-      </span>
<a href="#l25.507"></a><span id="l25.507" class="difflineplus">+</span>
<a href="#l25.508"></a><span id="l25.508">       // we need a load group to hold onto the channel. When the request is finished,</span>
<a href="#l25.509"></a><span id="l25.509">       // it'll get removed from the load group, and the channel will go away,</span>
<a href="#l25.510"></a><span id="l25.510">       // which will free the load group.</span>
<a href="#l25.511"></a><span id="l25.511">       if (!loadGroup)</span>
<a href="#l25.512"></a><span id="l25.512">         loadGroup = do_CreateInstance(NS_LOADGROUP_CONTRACTID);</span>
<a href="#l25.513"></a><span id="l25.513"> </span>
<a href="#l25.514"></a><span id="l25.514">       rv = channel-&gt;SetLoadGroup(loadGroup);</span>
<a href="#l25.515"></a><span id="l25.515">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.516"></a><span id="l25.516" class="difflineminus">-      </span>
<a href="#l25.517"></a><span id="l25.517" class="difflineplus">+</span>
<a href="#l25.518"></a><span id="l25.518">       if (aConvertDataToText)</span>
<a href="#l25.519"></a><span id="l25.519">       {</span>
<a href="#l25.520"></a><span id="l25.520">         nsCOMPtr&lt;nsIStreamListener&gt; conversionListener;</span>
<a href="#l25.521"></a><span id="l25.521">         nsCOMPtr&lt;nsIStreamConverterService&gt; streamConverter = do_GetService(&quot;@mozilla.org/streamConverters;1&quot;, &amp;rv);</span>
<a href="#l25.522"></a><span id="l25.522">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.523"></a><span id="l25.523">         rv = streamConverter-&gt;AsyncConvertData(&quot;message/rfc822&quot;,</span>
<a href="#l25.524"></a><span id="l25.524">                                                &quot;*/*&quot;, streamListener, channel, getter_AddRefs(conversionListener));</span>
<a href="#l25.525"></a><span id="l25.525">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.526"></a><span id="l25.526">         streamListener = conversionListener; // this is our new listener.</span>
<a href="#l25.527"></a><span id="l25.527">       }</span>
<a href="#l25.528"></a><span id="l25.528"> </span>
<a href="#l25.529"></a><span id="l25.529">       nsCOMPtr&lt;nsISupports&gt; aCtxt = do_QueryInterface(url);</span>
<a href="#l25.530"></a><span id="l25.530" class="difflineminus">-      //  now try to open the channel passing in our display consumer as the listener </span>
<a href="#l25.531"></a><span id="l25.531" class="difflineplus">+      //  now try to open the channel passing in our display consumer as the listener</span>
<a href="#l25.532"></a><span id="l25.532">       rv = channel-&gt;AsyncOpen(streamListener, aCtxt);</span>
<a href="#l25.533"></a><span id="l25.533">     }</span>
<a href="#l25.534"></a><span id="l25.534">     else // do what we used to do before</span>
<a href="#l25.535"></a><span id="l25.535">     {</span>
<a href="#l25.536"></a><span id="l25.536">       // I'd like to get rid of this code as I believe that we always get a docshell</span>
<a href="#l25.537"></a><span id="l25.537">       // or stream listener passed into us in this method but i'm not sure yet...</span>
<a href="#l25.538"></a><span id="l25.538">       // I'm going to use an assert for now to figure out if this is ever getting called</span>
<a href="#l25.539"></a><span id="l25.539"> #if defined(DEBUG_mscott) || defined(DEBUG_bienvenu)</span>
<a href="#l25.540"></a><span id="l25.540" class="difflineat">@@ -1121,20 +1121,20 @@ nsresult nsImapService::GetMessageFromUr</span>
<a href="#l25.541"></a><span id="l25.541">                                        aDisplayConsumer, aURL);</span>
<a href="#l25.542"></a><span id="l25.542">     }</span>
<a href="#l25.543"></a><span id="l25.543">   }</span>
<a href="#l25.544"></a><span id="l25.544">   return rv;</span>
<a href="#l25.545"></a><span id="l25.545"> }</span>
<a href="#l25.546"></a><span id="l25.546"> </span>
<a href="#l25.547"></a><span id="l25.547"> // this method streams a message to the passed in consumer, with an optional stream converter</span>
<a href="#l25.548"></a><span id="l25.548"> // and additional header (e.g., &quot;header=filter&quot;)</span>
<a href="#l25.549"></a><span id="l25.549" class="difflineminus">-NS_IMETHODIMP nsImapService::StreamMessage(const char *aMessageURI, </span>
<a href="#l25.550"></a><span id="l25.550" class="difflineminus">-                                           nsISupports *aConsumer, </span>
<a href="#l25.551"></a><span id="l25.551" class="difflineplus">+NS_IMETHODIMP nsImapService::StreamMessage(const char *aMessageURI,</span>
<a href="#l25.552"></a><span id="l25.552" class="difflineplus">+                                           nsISupports *aConsumer,</span>
<a href="#l25.553"></a><span id="l25.553">                                            nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.554"></a><span id="l25.554" class="difflineminus">-                                           nsIUrlListener *aUrlListener, </span>
<a href="#l25.555"></a><span id="l25.555" class="difflineplus">+                                           nsIUrlListener *aUrlListener,</span>
<a href="#l25.556"></a><span id="l25.556">                                            bool aConvertData,</span>
<a href="#l25.557"></a><span id="l25.557">                                            const nsACString &amp;aAdditionalHeader,</span>
<a href="#l25.558"></a><span id="l25.558">                                            bool aLocalOnly,</span>
<a href="#l25.559"></a><span id="l25.559">                                            nsIURI **aURL)</span>
<a href="#l25.560"></a><span id="l25.560"> {</span>
<a href="#l25.561"></a><span id="l25.561">   NS_ENSURE_ARG_POINTER(aMessageURI);</span>
<a href="#l25.562"></a><span id="l25.562"> </span>
<a href="#l25.563"></a><span id="l25.563">   nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l25.564"></a><span id="l25.564" class="difflineat">@@ -1152,17 +1152,17 @@ NS_IMETHODIMP nsImapService::StreamMessa</span>
<a href="#l25.565"></a><span id="l25.565">   if (NS_SUCCEEDED(rv))</span>
<a href="#l25.566"></a><span id="l25.566">   {</span>
<a href="#l25.567"></a><span id="l25.567">     nsCOMPtr&lt;nsIImapMessageSink&gt; imapMessageSink(do_QueryInterface(folder, &amp;rv));</span>
<a href="#l25.568"></a><span id="l25.568">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.569"></a><span id="l25.569">     {</span>
<a href="#l25.570"></a><span id="l25.570">       nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.571"></a><span id="l25.571">       nsAutoCString urlSpec;</span>
<a href="#l25.572"></a><span id="l25.572">       char hierarchyDelimiter = GetHierarchyDelimiter(folder);</span>
<a href="#l25.573"></a><span id="l25.573" class="difflineminus">-      rv = CreateStartOfImapUrl(nsDependentCString(aMessageURI), getter_AddRefs(imapUrl), </span>
<a href="#l25.574"></a><span id="l25.574" class="difflineplus">+      rv = CreateStartOfImapUrl(nsDependentCString(aMessageURI), getter_AddRefs(imapUrl),</span>
<a href="#l25.575"></a><span id="l25.575">                                 folder, aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.576"></a><span id="l25.576">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.577"></a><span id="l25.577">       nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; msgurl (do_QueryInterface(imapUrl));</span>
<a href="#l25.578"></a><span id="l25.578">       nsCOMPtr&lt;nsIURI&gt; url(do_QueryInterface(imapUrl));</span>
<a href="#l25.579"></a><span id="l25.579"> </span>
<a href="#l25.580"></a><span id="l25.580">       // This option is used by the JS Mime Emitter, in case we want a cheap</span>
<a href="#l25.581"></a><span id="l25.581">       // streaming, for example, if we just want a quick look at some header,</span>
<a href="#l25.582"></a><span id="l25.582">       // without having to download all the attachments...</span>
<a href="#l25.583"></a><span id="l25.583" class="difflineat">@@ -1307,21 +1307,21 @@ NS_IMETHODIMP nsImapService::IsMsgInMemC</span>
<a href="#l25.584"></a><span id="l25.584">     if (NS_SUCCEEDED(rv) &amp;&amp; exists) {</span>
<a href="#l25.585"></a><span id="l25.585">       *aResult = true;</span>
<a href="#l25.586"></a><span id="l25.586">     }</span>
<a href="#l25.587"></a><span id="l25.587">   }</span>
<a href="#l25.588"></a><span id="l25.588"> </span>
<a href="#l25.589"></a><span id="l25.589">   return NS_OK;</span>
<a href="#l25.590"></a><span id="l25.590"> }</span>
<a href="#l25.591"></a><span id="l25.591"> </span>
<a href="#l25.592"></a><span id="l25.592" class="difflineminus">-nsresult nsImapService::CreateStartOfImapUrl(const nsACString &amp;aImapURI, </span>
<a href="#l25.593"></a><span id="l25.593" class="difflineplus">+nsresult nsImapService::CreateStartOfImapUrl(const nsACString &amp;aImapURI,</span>
<a href="#l25.594"></a><span id="l25.594">                                              nsIImapUrl **imapUrl,</span>
<a href="#l25.595"></a><span id="l25.595">                                              nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.596"></a><span id="l25.596">                                              nsIUrlListener *aUrlListener,</span>
<a href="#l25.597"></a><span id="l25.597" class="difflineminus">-                                             nsACString &amp;urlSpec, </span>
<a href="#l25.598"></a><span id="l25.598" class="difflineplus">+                                             nsACString &amp;urlSpec,</span>
<a href="#l25.599"></a><span id="l25.599">                                              char &amp;hierarchyDelimiter)</span>
<a href="#l25.600"></a><span id="l25.600"> {</span>
<a href="#l25.601"></a><span id="l25.601">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.602"></a><span id="l25.602"> </span>
<a href="#l25.603"></a><span id="l25.603">   nsCString hostname;</span>
<a href="#l25.604"></a><span id="l25.604">   nsCString username;</span>
<a href="#l25.605"></a><span id="l25.605">   nsCString escapedUsername;</span>
<a href="#l25.606"></a><span id="l25.606"> </span>
<a href="#l25.607"></a><span id="l25.607" class="difflineat">@@ -1330,24 +1330,24 @@ nsresult nsImapService::CreateStartOfIma</span>
<a href="#l25.608"></a><span id="l25.608">   rv = aImapMailFolder-&gt;GetUsername(username);</span>
<a href="#l25.609"></a><span id="l25.609">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.610"></a><span id="l25.610">   if (!username.IsEmpty())</span>
<a href="#l25.611"></a><span id="l25.611">     MsgEscapeString(username, nsINetUtil::ESCAPE_XALPHAS, escapedUsername);</span>
<a href="#l25.612"></a><span id="l25.612"> </span>
<a href="#l25.613"></a><span id="l25.613">   int32_t port = nsIImapUrl::DEFAULT_IMAP_PORT;</span>
<a href="#l25.614"></a><span id="l25.614">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l25.615"></a><span id="l25.615">   rv = aImapMailFolder-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l25.616"></a><span id="l25.616" class="difflineminus">-  if (NS_SUCCEEDED(rv)) </span>
<a href="#l25.617"></a><span id="l25.617" class="difflineplus">+  if (NS_SUCCEEDED(rv))</span>
<a href="#l25.618"></a><span id="l25.618">   {</span>
<a href="#l25.619"></a><span id="l25.619">     server-&gt;GetPort(&amp;port);</span>
<a href="#l25.620"></a><span id="l25.620">     if (port == -1 || port == 0) port = nsIImapUrl::DEFAULT_IMAP_PORT;</span>
<a href="#l25.621"></a><span id="l25.621">   }</span>
<a href="#l25.622"></a><span id="l25.622"> </span>
<a href="#l25.623"></a><span id="l25.623">   // now we need to create an imap url to load into the connection. The url</span>
<a href="#l25.624"></a><span id="l25.624" class="difflineminus">-  // needs to represent a select folder action. </span>
<a href="#l25.625"></a><span id="l25.625" class="difflineplus">+  // needs to represent a select folder action.</span>
<a href="#l25.626"></a><span id="l25.626">   rv = CallCreateInstance(kImapUrlCID, imapUrl);</span>
<a href="#l25.627"></a><span id="l25.627">   if (NS_SUCCEEDED(rv) &amp;&amp; *imapUrl)</span>
<a href="#l25.628"></a><span id="l25.628">   {</span>
<a href="#l25.629"></a><span id="l25.629">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(*imapUrl, &amp;rv);</span>
<a href="#l25.630"></a><span id="l25.630">     if (NS_SUCCEEDED(rv) &amp;&amp; mailnewsUrl &amp;&amp; aUrlListener)</span>
<a href="#l25.631"></a><span id="l25.631">       mailnewsUrl-&gt;RegisterListener(aUrlListener);</span>
<a href="#l25.632"></a><span id="l25.632">     nsCOMPtr&lt;nsIMsgMessageUrl&gt; msgurl(do_QueryInterface(*imapUrl));</span>
<a href="#l25.633"></a><span id="l25.633">     (*imapUrl)-&gt;SetExternalLinkUrl(false);</span>
<a href="#l25.634"></a><span id="l25.634" class="difflineat">@@ -1375,32 +1375,32 @@ nsresult nsImapService::CreateStartOfIma</span>
<a href="#l25.635"></a><span id="l25.635">   }</span>
<a href="#l25.636"></a><span id="l25.636">   return rv;</span>
<a href="#l25.637"></a><span id="l25.637"> }</span>
<a href="#l25.638"></a><span id="l25.638"> </span>
<a href="#l25.639"></a><span id="l25.639"> /* fetching the headers of RFC822 messages */</span>
<a href="#l25.640"></a><span id="l25.640"> /* imap4://HOST&gt;header&gt;&lt;UID/SEQUENCE&gt;&gt;MAILBOXPATH&gt;x */</span>
<a href="#l25.641"></a><span id="l25.641"> /*   'x' is the message UID or sequence number list */</span>
<a href="#l25.642"></a><span id="l25.642"> /* will not affect the 'SEEN' flag */</span>
<a href="#l25.643"></a><span id="l25.643" class="difflineminus">-NS_IMETHODIMP nsImapService::GetHeaders(nsIMsgFolder *aImapMailFolder, </span>
<a href="#l25.644"></a><span id="l25.644" class="difflineminus">-                                        nsIUrlListener *aUrlListener, </span>
<a href="#l25.645"></a><span id="l25.645" class="difflineplus">+NS_IMETHODIMP nsImapService::GetHeaders(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.646"></a><span id="l25.646" class="difflineplus">+                                        nsIUrlListener *aUrlListener,</span>
<a href="#l25.647"></a><span id="l25.647">                                         nsIURI **aURL,</span>
<a href="#l25.648"></a><span id="l25.648">                                         const nsACString &amp;messageIdentifierList,</span>
<a href="#l25.649"></a><span id="l25.649">                                         bool messageIdsAreUID)</span>
<a href="#l25.650"></a><span id="l25.650"> {</span>
<a href="#l25.651"></a><span id="l25.651">   // create a protocol instance to handle the request.</span>
<a href="#l25.652"></a><span id="l25.652">   // NOTE: once we start working with multiple connections, this step will be much more complicated...but for now</span>
<a href="#l25.653"></a><span id="l25.653">   // just create a connection and process the request.</span>
<a href="#l25.654"></a><span id="l25.654">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.655"></a><span id="l25.655"> </span>
<a href="#l25.656"></a><span id="l25.656">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.657"></a><span id="l25.657">   nsAutoCString urlSpec;</span>
<a href="#l25.658"></a><span id="l25.658">   char hierarchyDelimiter = GetHierarchyDelimiter(aImapMailFolder);</span>
<a href="#l25.659"></a><span id="l25.659"> </span>
<a href="#l25.660"></a><span id="l25.660" class="difflineminus">-  nsresult rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), aImapMailFolder, </span>
<a href="#l25.661"></a><span id="l25.661" class="difflineplus">+  nsresult rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), aImapMailFolder,</span>
<a href="#l25.662"></a><span id="l25.662">                                      aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.663"></a><span id="l25.663">   if (NS_SUCCEEDED(rv) &amp;&amp; imapUrl)</span>
<a href="#l25.664"></a><span id="l25.664">   {</span>
<a href="#l25.665"></a><span id="l25.665">     nsCOMPtr&lt;nsIURI&gt; uri = do_QueryInterface(imapUrl);</span>
<a href="#l25.666"></a><span id="l25.666"> </span>
<a href="#l25.667"></a><span id="l25.667">     rv = imapUrl-&gt;SetImapAction(nsIImapUrl::nsImapMsgFetch);</span>
<a href="#l25.668"></a><span id="l25.668">     rv = SetImapUrlSink(aImapMailFolder, imapUrl);</span>
<a href="#l25.669"></a><span id="l25.669"> </span>
<a href="#l25.670"></a><span id="l25.670" class="difflineat">@@ -1427,30 +1427,30 @@ NS_IMETHODIMP nsImapService::GetHeaders(</span>
<a href="#l25.671"></a><span id="l25.671"> }</span>
<a href="#l25.672"></a><span id="l25.672"> </span>
<a href="#l25.673"></a><span id="l25.673"> </span>
<a href="#l25.674"></a><span id="l25.674"> /* peeking at the start of msg bodies */</span>
<a href="#l25.675"></a><span id="l25.675"> /* imap4://HOST&gt;header&gt;&lt;UID&gt;&gt;MAILBOXPATH&gt;x&gt;n */</span>
<a href="#l25.676"></a><span id="l25.676"> /*   'x' is the message UID */</span>
<a href="#l25.677"></a><span id="l25.677"> /*   'n' is the number of bytes to fetch */</span>
<a href="#l25.678"></a><span id="l25.678"> /* will not affect the 'SEEN' flag */</span>
<a href="#l25.679"></a><span id="l25.679" class="difflineminus">-NS_IMETHODIMP nsImapService::GetBodyStart(nsIMsgFolder *aImapMailFolder, </span>
<a href="#l25.680"></a><span id="l25.680" class="difflineminus">-                                          nsIUrlListener *aUrlListener, </span>
<a href="#l25.681"></a><span id="l25.681" class="difflineplus">+NS_IMETHODIMP nsImapService::GetBodyStart(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.682"></a><span id="l25.682" class="difflineplus">+                                          nsIUrlListener *aUrlListener,</span>
<a href="#l25.683"></a><span id="l25.683">                                           const nsACString &amp;messageIdentifierList,</span>
<a href="#l25.684"></a><span id="l25.684">                                           int32_t numBytes,</span>
<a href="#l25.685"></a><span id="l25.685">                                           nsIURI **aURL)</span>
<a href="#l25.686"></a><span id="l25.686"> {</span>
<a href="#l25.687"></a><span id="l25.687">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.688"></a><span id="l25.688"> </span>
<a href="#l25.689"></a><span id="l25.689">   nsresult rv;</span>
<a href="#l25.690"></a><span id="l25.690">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.691"></a><span id="l25.691">   nsAutoCString urlSpec;</span>
<a href="#l25.692"></a><span id="l25.692"> </span>
<a href="#l25.693"></a><span id="l25.693">   char hierarchyDelimiter = GetHierarchyDelimiter(aImapMailFolder);</span>
<a href="#l25.694"></a><span id="l25.694" class="difflineminus">-  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), aImapMailFolder, </span>
<a href="#l25.695"></a><span id="l25.695" class="difflineplus">+  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), aImapMailFolder,</span>
<a href="#l25.696"></a><span id="l25.696">     aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.697"></a><span id="l25.697">   if (NS_SUCCEEDED(rv) &amp;&amp; imapUrl)</span>
<a href="#l25.698"></a><span id="l25.698">   {</span>
<a href="#l25.699"></a><span id="l25.699">     rv = imapUrl-&gt;SetImapAction(nsIImapUrl::nsImapMsgPreview);</span>
<a href="#l25.700"></a><span id="l25.700">     rv = SetImapUrlSink(aImapMailFolder, imapUrl);</span>
<a href="#l25.701"></a><span id="l25.701"> </span>
<a href="#l25.702"></a><span id="l25.702">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.703"></a><span id="l25.703">     {</span>
<a href="#l25.704"></a><span id="l25.704" class="difflineat">@@ -1541,28 +1541,28 @@ nsImapService::VerifyLogon(nsIMsgFolder </span>
<a href="#l25.705"></a><span id="l25.705">     if (aURL)</span>
<a href="#l25.706"></a><span id="l25.706">       uri.forget(aURL);</span>
<a href="#l25.707"></a><span id="l25.707">   }</span>
<a href="#l25.708"></a><span id="l25.708">   return rv;</span>
<a href="#l25.709"></a><span id="l25.709"> }</span>
<a href="#l25.710"></a><span id="l25.710"> </span>
<a href="#l25.711"></a><span id="l25.711"> // Noop, used to update a folder (causes server to send changes).</span>
<a href="#l25.712"></a><span id="l25.712"> NS_IMETHODIMP nsImapService::Noop(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.713"></a><span id="l25.713" class="difflineminus">-                                  nsIUrlListener *aUrlListener, </span>
<a href="#l25.714"></a><span id="l25.714" class="difflineplus">+                                  nsIUrlListener *aUrlListener,</span>
<a href="#l25.715"></a><span id="l25.715">                                   nsIURI **aURL)</span>
<a href="#l25.716"></a><span id="l25.716"> {</span>
<a href="#l25.717"></a><span id="l25.717">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.718"></a><span id="l25.718"> </span>
<a href="#l25.719"></a><span id="l25.719">   return FolderCommand(aImapMailFolder, aUrlListener,</span>
<a href="#l25.720"></a><span id="l25.720">                        &quot;/selectnoop&gt;&quot;, nsIImapUrl::nsImapSelectNoopFolder, nullptr, aURL);</span>
<a href="#l25.721"></a><span id="l25.721"> }</span>
<a href="#l25.722"></a><span id="l25.722" class="difflineminus">-    </span>
<a href="#l25.723"></a><span id="l25.723" class="difflineplus">+</span>
<a href="#l25.724"></a><span id="l25.724"> // FolderStatus, used to update message counts</span>
<a href="#l25.725"></a><span id="l25.725"> NS_IMETHODIMP nsImapService::UpdateFolderStatus(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.726"></a><span id="l25.726" class="difflineminus">-                                                nsIUrlListener *aUrlListener, </span>
<a href="#l25.727"></a><span id="l25.727" class="difflineplus">+                                                nsIUrlListener *aUrlListener,</span>
<a href="#l25.728"></a><span id="l25.728">                                                 nsIURI **aURL)</span>
<a href="#l25.729"></a><span id="l25.729"> {</span>
<a href="#l25.730"></a><span id="l25.730">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.731"></a><span id="l25.731"> </span>
<a href="#l25.732"></a><span id="l25.732">   return FolderCommand(aImapMailFolder, aUrlListener,</span>
<a href="#l25.733"></a><span id="l25.733">                        &quot;/folderstatus&gt;&quot;, nsIImapUrl::nsImapFolderStatus, nullptr, aURL);</span>
<a href="#l25.734"></a><span id="l25.734"> }</span>
<a href="#l25.735"></a><span id="l25.735"> </span>
<a href="#l25.736"></a><span id="l25.736" class="difflineat">@@ -1575,17 +1575,17 @@ NS_IMETHODIMP nsImapService::Expunge(nsI</span>
<a href="#l25.737"></a><span id="l25.737">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.738"></a><span id="l25.738"> </span>
<a href="#l25.739"></a><span id="l25.739">   return FolderCommand(aImapMailFolder, aUrlListener,</span>
<a href="#l25.740"></a><span id="l25.740">                        &quot;/Expunge&gt;&quot;, nsIImapUrl::nsImapExpungeFolder, aMsgWindow, aURL);</span>
<a href="#l25.741"></a><span id="l25.741"> }</span>
<a href="#l25.742"></a><span id="l25.742"> </span>
<a href="#l25.743"></a><span id="l25.743"> /* old-stle biff that doesn't download headers */</span>
<a href="#l25.744"></a><span id="l25.744"> NS_IMETHODIMP nsImapService::Biff(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.745"></a><span id="l25.745" class="difflineminus">-                                  nsIUrlListener *aUrlListener, </span>
<a href="#l25.746"></a><span id="l25.746" class="difflineplus">+                                  nsIUrlListener *aUrlListener,</span>
<a href="#l25.747"></a><span id="l25.747">                                   nsIURI **aURL,</span>
<a href="#l25.748"></a><span id="l25.748">                                   uint32_t uidHighWater)</span>
<a href="#l25.749"></a><span id="l25.749"> {</span>
<a href="#l25.750"></a><span id="l25.750">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.751"></a><span id="l25.751"> </span>
<a href="#l25.752"></a><span id="l25.752">   // static const char *formatString = &quot;biff&gt;%c%s&gt;%ld&quot;;</span>
<a href="#l25.753"></a><span id="l25.753">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.754"></a><span id="l25.754">   nsAutoCString urlSpec;</span>
<a href="#l25.755"></a><span id="l25.755" class="difflineat">@@ -1619,49 +1619,49 @@ NS_IMETHODIMP nsImapService::Biff(nsIMsg</span>
<a href="#l25.756"></a><span id="l25.756"> </span>
<a href="#l25.757"></a><span id="l25.757"> NS_IMETHODIMP nsImapService::DeleteFolder(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.758"></a><span id="l25.758">                                           nsIUrlListener *aUrlListener,</span>
<a href="#l25.759"></a><span id="l25.759">                                           nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.760"></a><span id="l25.760">                                           nsIURI **aURL)</span>
<a href="#l25.761"></a><span id="l25.761"> {</span>
<a href="#l25.762"></a><span id="l25.762">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.763"></a><span id="l25.763"> </span>
<a href="#l25.764"></a><span id="l25.764" class="difflineminus">-  // If it's an aol server then use 'deletefolder' url to </span>
<a href="#l25.765"></a><span id="l25.765" class="difflineplus">+  // If it's an aol server then use 'deletefolder' url to</span>
<a href="#l25.766"></a><span id="l25.766">   // remove all msgs first and then remove the folder itself.</span>
<a href="#l25.767"></a><span id="l25.767">   bool removeFolderAndMsgs = false;</span>
<a href="#l25.768"></a><span id="l25.768">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l25.769"></a><span id="l25.769">   if (NS_SUCCEEDED(aImapMailFolder-&gt;GetServer(getter_AddRefs(server))) &amp;&amp; server)</span>
<a href="#l25.770"></a><span id="l25.770">   {</span>
<a href="#l25.771"></a><span id="l25.771">     nsCOMPtr &lt;nsIImapIncomingServer&gt; imapServer = do_QueryInterface(server);</span>
<a href="#l25.772"></a><span id="l25.772" class="difflineminus">-    if (imapServer) </span>
<a href="#l25.773"></a><span id="l25.773" class="difflineplus">+    if (imapServer)</span>
<a href="#l25.774"></a><span id="l25.774">       imapServer-&gt;GetIsAOLServer(&amp;removeFolderAndMsgs);</span>
<a href="#l25.775"></a><span id="l25.775">   }</span>
<a href="#l25.776"></a><span id="l25.776" class="difflineminus">-  </span>
<a href="#l25.777"></a><span id="l25.777" class="difflineplus">+</span>
<a href="#l25.778"></a><span id="l25.778">   return FolderCommand(aImapMailFolder, aUrlListener,</span>
<a href="#l25.779"></a><span id="l25.779" class="difflineminus">-                       removeFolderAndMsgs ? &quot;/deletefolder&gt;&quot; : &quot;/delete&gt;&quot;, </span>
<a href="#l25.780"></a><span id="l25.780" class="difflineplus">+                       removeFolderAndMsgs ? &quot;/deletefolder&gt;&quot; : &quot;/delete&gt;&quot;,</span>
<a href="#l25.781"></a><span id="l25.781">                        nsIImapUrl::nsImapDeleteFolder, aMsgWindow, aURL);</span>
<a href="#l25.782"></a><span id="l25.782"> }</span>
<a href="#l25.783"></a><span id="l25.783"> </span>
<a href="#l25.784"></a><span id="l25.784" class="difflineminus">-NS_IMETHODIMP nsImapService::DeleteMessages(nsIMsgFolder *aImapMailFolder, </span>
<a href="#l25.785"></a><span id="l25.785" class="difflineminus">-                                            nsIUrlListener *aUrlListener, </span>
<a href="#l25.786"></a><span id="l25.786" class="difflineplus">+NS_IMETHODIMP nsImapService::DeleteMessages(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.787"></a><span id="l25.787" class="difflineplus">+                                            nsIUrlListener *aUrlListener,</span>
<a href="#l25.788"></a><span id="l25.788">                                             nsIURI **aURL,</span>
<a href="#l25.789"></a><span id="l25.789">                                             const nsACString &amp;messageIdentifierList,</span>
<a href="#l25.790"></a><span id="l25.790">                                             bool messageIdsAreUID)</span>
<a href="#l25.791"></a><span id="l25.791"> {</span>
<a href="#l25.792"></a><span id="l25.792">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.793"></a><span id="l25.793"> </span>
<a href="#l25.794"></a><span id="l25.794">   // create a protocol instance to handle the request.</span>
<a href="#l25.795"></a><span id="l25.795">   // NOTE: once we start working with multiple connections, this step will be much more complicated...but for now</span>
<a href="#l25.796"></a><span id="l25.796">   // just create a connection and process the request.</span>
<a href="#l25.797"></a><span id="l25.797">   nsresult rv;</span>
<a href="#l25.798"></a><span id="l25.798">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.799"></a><span id="l25.799">   nsAutoCString urlSpec;</span>
<a href="#l25.800"></a><span id="l25.800"> </span>
<a href="#l25.801"></a><span id="l25.801">   char hierarchyDelimiter = GetHierarchyDelimiter(aImapMailFolder);</span>
<a href="#l25.802"></a><span id="l25.802" class="difflineminus">-  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), aImapMailFolder, </span>
<a href="#l25.803"></a><span id="l25.803" class="difflineplus">+  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), aImapMailFolder,</span>
<a href="#l25.804"></a><span id="l25.804">     aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.805"></a><span id="l25.805">   if (NS_SUCCEEDED(rv) &amp;&amp; imapUrl)</span>
<a href="#l25.806"></a><span id="l25.806">   {</span>
<a href="#l25.807"></a><span id="l25.807">     rv = imapUrl-&gt;SetImapAction(nsIImapUrl::nsImapMsgFetch);</span>
<a href="#l25.808"></a><span id="l25.808">     rv = SetImapUrlSink(aImapMailFolder, imapUrl);</span>
<a href="#l25.809"></a><span id="l25.809"> </span>
<a href="#l25.810"></a><span id="l25.810">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.811"></a><span id="l25.811">     {</span>
<a href="#l25.812"></a><span id="l25.812" class="difflineat">@@ -1682,17 +1682,17 @@ NS_IMETHODIMP nsImapService::DeleteMessa</span>
<a href="#l25.813"></a><span id="l25.813">         rv = GetImapConnectionAndLoadUrl(imapUrl, nullptr, aURL);</span>
<a href="#l25.814"></a><span id="l25.814">     }</span>
<a href="#l25.815"></a><span id="l25.815">   }</span>
<a href="#l25.816"></a><span id="l25.816">   return rv;</span>
<a href="#l25.817"></a><span id="l25.817"> }</span>
<a href="#l25.818"></a><span id="l25.818"> </span>
<a href="#l25.819"></a><span id="l25.819"> // Delete all messages in a folder, used to empty trash</span>
<a href="#l25.820"></a><span id="l25.820"> NS_IMETHODIMP nsImapService::DeleteAllMessages(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.821"></a><span id="l25.821" class="difflineminus">-                                               nsIUrlListener *aUrlListener, </span>
<a href="#l25.822"></a><span id="l25.822" class="difflineplus">+                                               nsIUrlListener *aUrlListener,</span>
<a href="#l25.823"></a><span id="l25.823">                                                nsIURI **aURL)</span>
<a href="#l25.824"></a><span id="l25.824"> {</span>
<a href="#l25.825"></a><span id="l25.825">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.826"></a><span id="l25.826"> </span>
<a href="#l25.827"></a><span id="l25.827">   return FolderCommand(aImapMailFolder, aUrlListener,</span>
<a href="#l25.828"></a><span id="l25.828">                       &quot;/deleteallmsgs&gt;&quot;, nsIImapUrl::nsImapSelectNoopFolder, nullptr, aURL);</span>
<a href="#l25.829"></a><span id="l25.829"> }</span>
<a href="#l25.830"></a><span id="l25.830"> </span>
<a href="#l25.831"></a><span id="l25.831" class="difflineat">@@ -1741,25 +1741,25 @@ nsresult nsImapService::DiddleFlags(nsIM</span>
<a href="#l25.832"></a><span id="l25.832">                                     const nsACString &amp;messageIdentifierList,</span>
<a href="#l25.833"></a><span id="l25.833">                                     const char *howToDiddle,</span>
<a href="#l25.834"></a><span id="l25.834">                                     imapMessageFlagsType flags,</span>
<a href="#l25.835"></a><span id="l25.835">                                     bool messageIdsAreUID)</span>
<a href="#l25.836"></a><span id="l25.836"> {</span>
<a href="#l25.837"></a><span id="l25.837">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.838"></a><span id="l25.838"> </span>
<a href="#l25.839"></a><span id="l25.839">   // create a protocol instance to handle the request.</span>
<a href="#l25.840"></a><span id="l25.840" class="difflineminus">-  // NOTE: once we start working with multiple connections, </span>
<a href="#l25.841"></a><span id="l25.841" class="difflineplus">+  // NOTE: once we start working with multiple connections,</span>
<a href="#l25.842"></a><span id="l25.842">   //       this step will be much more complicated...but for now</span>
<a href="#l25.843"></a><span id="l25.843">   // just create a connection and process the request.</span>
<a href="#l25.844"></a><span id="l25.844">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.845"></a><span id="l25.845">   nsAutoCString urlSpec;</span>
<a href="#l25.846"></a><span id="l25.846"> </span>
<a href="#l25.847"></a><span id="l25.847">   char hierarchyDelimiter = GetHierarchyDelimiter(aImapMailFolder);</span>
<a href="#l25.848"></a><span id="l25.848">   nsresult rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl),</span>
<a href="#l25.849"></a><span id="l25.849" class="difflineminus">-                                     aImapMailFolder, aUrlListener, urlSpec, hierarchyDelimiter); </span>
<a href="#l25.850"></a><span id="l25.850" class="difflineplus">+                                     aImapMailFolder, aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.851"></a><span id="l25.851">   if (NS_SUCCEEDED(rv) &amp;&amp; imapUrl)</span>
<a href="#l25.852"></a><span id="l25.852">   {</span>
<a href="#l25.853"></a><span id="l25.853">     rv = imapUrl-&gt;SetImapAction(nsIImapUrl::nsImapMsgFetch);</span>
<a href="#l25.854"></a><span id="l25.854">     rv = SetImapUrlSink(aImapMailFolder, imapUrl);</span>
<a href="#l25.855"></a><span id="l25.855"> </span>
<a href="#l25.856"></a><span id="l25.856">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.857"></a><span id="l25.857">     {</span>
<a href="#l25.858"></a><span id="l25.858">       nsCOMPtr&lt;nsIURI&gt; uri = do_QueryInterface(imapUrl);</span>
<a href="#l25.859"></a><span id="l25.859" class="difflineat">@@ -1784,37 +1784,37 @@ nsresult nsImapService::DiddleFlags(nsIM</span>
<a href="#l25.860"></a><span id="l25.860">   }</span>
<a href="#l25.861"></a><span id="l25.861">   return rv;</span>
<a href="#l25.862"></a><span id="l25.862"> }</span>
<a href="#l25.863"></a><span id="l25.863"> </span>
<a href="#l25.864"></a><span id="l25.864"> nsresult nsImapService::SetImapUrlSink(nsIMsgFolder *aMsgFolder, nsIImapUrl *aImapUrl)</span>
<a href="#l25.865"></a><span id="l25.865"> {</span>
<a href="#l25.866"></a><span id="l25.866">   NS_ENSURE_ARG_POINTER(aMsgFolder);</span>
<a href="#l25.867"></a><span id="l25.867">   NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l25.868"></a><span id="l25.868" class="difflineminus">-  </span>
<a href="#l25.869"></a><span id="l25.869" class="difflineplus">+</span>
<a href="#l25.870"></a><span id="l25.870">   nsresult rv;</span>
<a href="#l25.871"></a><span id="l25.871">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; incomingServer;</span>
<a href="#l25.872"></a><span id="l25.872">   nsCOMPtr&lt;nsIImapServerSink&gt; imapServerSink;</span>
<a href="#l25.873"></a><span id="l25.873" class="difflineminus">-    </span>
<a href="#l25.874"></a><span id="l25.874" class="difflineplus">+</span>
<a href="#l25.875"></a><span id="l25.875">   rv = aMsgFolder-&gt;GetServer(getter_AddRefs(incomingServer));</span>
<a href="#l25.876"></a><span id="l25.876">   if (NS_SUCCEEDED(rv) &amp;&amp; incomingServer)</span>
<a href="#l25.877"></a><span id="l25.877">   {</span>
<a href="#l25.878"></a><span id="l25.878">     imapServerSink = do_QueryInterface(incomingServer);</span>
<a href="#l25.879"></a><span id="l25.879">     if (imapServerSink)</span>
<a href="#l25.880"></a><span id="l25.880">       aImapUrl-&gt;SetImapServerSink(imapServerSink);</span>
<a href="#l25.881"></a><span id="l25.881">   }</span>
<a href="#l25.882"></a><span id="l25.882" class="difflineminus">-   </span>
<a href="#l25.883"></a><span id="l25.883" class="difflineplus">+</span>
<a href="#l25.884"></a><span id="l25.884">   nsCOMPtr&lt;nsIImapMailFolderSink&gt; imapMailFolderSink = do_QueryInterface(aMsgFolder);</span>
<a href="#l25.885"></a><span id="l25.885">   if (NS_SUCCEEDED(rv) &amp;&amp; imapMailFolderSink)</span>
<a href="#l25.886"></a><span id="l25.886">     aImapUrl-&gt;SetImapMailFolderSink(imapMailFolderSink);</span>
<a href="#l25.887"></a><span id="l25.887" class="difflineminus">-  </span>
<a href="#l25.888"></a><span id="l25.888" class="difflineplus">+</span>
<a href="#l25.889"></a><span id="l25.889">   nsCOMPtr&lt;nsIImapMessageSink&gt; imapMessageSink = do_QueryInterface(aMsgFolder);</span>
<a href="#l25.890"></a><span id="l25.890">   if (NS_SUCCEEDED(rv) &amp;&amp; imapMessageSink)</span>
<a href="#l25.891"></a><span id="l25.891">     aImapUrl-&gt;SetImapMessageSink(imapMessageSink);</span>
<a href="#l25.892"></a><span id="l25.892" class="difflineminus">-  </span>
<a href="#l25.893"></a><span id="l25.893" class="difflineplus">+</span>
<a href="#l25.894"></a><span id="l25.894">   nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(aImapUrl);</span>
<a href="#l25.895"></a><span id="l25.895">   mailnewsUrl-&gt;SetFolder(aMsgFolder);</span>
<a href="#l25.896"></a><span id="l25.896"> </span>
<a href="#l25.897"></a><span id="l25.897">   return NS_OK;</span>
<a href="#l25.898"></a><span id="l25.898"> }</span>
<a href="#l25.899"></a><span id="l25.899"> </span>
<a href="#l25.900"></a><span id="l25.900"> NS_IMETHODIMP nsImapService::DiscoverAllFolders(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.901"></a><span id="l25.901">                                                 nsIUrlListener *aUrlListener,</span>
<a href="#l25.902"></a><span id="l25.902" class="difflineat">@@ -1822,17 +1822,17 @@ NS_IMETHODIMP nsImapService::DiscoverAll</span>
<a href="#l25.903"></a><span id="l25.903">                                                 nsIURI **aURL)</span>
<a href="#l25.904"></a><span id="l25.904"> {</span>
<a href="#l25.905"></a><span id="l25.905">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.906"></a><span id="l25.906"> </span>
<a href="#l25.907"></a><span id="l25.907">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.908"></a><span id="l25.908">   nsAutoCString urlSpec;</span>
<a href="#l25.909"></a><span id="l25.909"> </span>
<a href="#l25.910"></a><span id="l25.910">   char hierarchyDelimiter = GetHierarchyDelimiter(aImapMailFolder);</span>
<a href="#l25.911"></a><span id="l25.911" class="difflineminus">-  nsresult rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), aImapMailFolder, </span>
<a href="#l25.912"></a><span id="l25.912" class="difflineplus">+  nsresult rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), aImapMailFolder,</span>
<a href="#l25.913"></a><span id="l25.913">                                      aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.914"></a><span id="l25.914">   if (NS_SUCCEEDED (rv))</span>
<a href="#l25.915"></a><span id="l25.915">   {</span>
<a href="#l25.916"></a><span id="l25.916">     rv = SetImapUrlSink(aImapMailFolder, imapUrl);</span>
<a href="#l25.917"></a><span id="l25.917"> </span>
<a href="#l25.918"></a><span id="l25.918">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.919"></a><span id="l25.919">     {</span>
<a href="#l25.920"></a><span id="l25.920">       nsCOMPtr&lt;nsIURI&gt; uri = do_QueryInterface(imapUrl);</span>
<a href="#l25.921"></a><span id="l25.921" class="difflineat">@@ -1882,32 +1882,32 @@ NS_IMETHODIMP nsImapService::DiscoverChi</span>
<a href="#l25.922"></a><span id="l25.922">                                               nsIURI **aURL)</span>
<a href="#l25.923"></a><span id="l25.923"> {</span>
<a href="#l25.924"></a><span id="l25.924">   NS_ENSURE_ARG_POINTER(aImapMailFolder);</span>
<a href="#l25.925"></a><span id="l25.925"> </span>
<a href="#l25.926"></a><span id="l25.926">   nsCOMPtr&lt;nsIImapUrl&gt; aImapUrl;</span>
<a href="#l25.927"></a><span id="l25.927">   nsAutoCString urlSpec;</span>
<a href="#l25.928"></a><span id="l25.928"> </span>
<a href="#l25.929"></a><span id="l25.929">   char hierarchyDelimiter = GetHierarchyDelimiter(aImapMailFolder);</span>
<a href="#l25.930"></a><span id="l25.930" class="difflineminus">-  nsresult rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(aImapUrl), aImapMailFolder, </span>
<a href="#l25.931"></a><span id="l25.931" class="difflineplus">+  nsresult rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(aImapUrl), aImapMailFolder,</span>
<a href="#l25.932"></a><span id="l25.932">                                      aUrlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.933"></a><span id="l25.933">   if (NS_SUCCEEDED (rv))</span>
<a href="#l25.934"></a><span id="l25.934">   {</span>
<a href="#l25.935"></a><span id="l25.935">     rv = SetImapUrlSink(aImapMailFolder, aImapUrl);</span>
<a href="#l25.936"></a><span id="l25.936">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.937"></a><span id="l25.937">     {</span>
<a href="#l25.938"></a><span id="l25.938">       if (!folderPath.IsEmpty())</span>
<a href="#l25.939"></a><span id="l25.939">       {</span>
<a href="#l25.940"></a><span id="l25.940">         nsCOMPtr&lt;nsIURI&gt; uri = do_QueryInterface(aImapUrl);</span>
<a href="#l25.941"></a><span id="l25.941">         urlSpec.AppendLiteral(&quot;/discoverchildren&gt;&quot;);</span>
<a href="#l25.942"></a><span id="l25.942">         urlSpec.Append(hierarchyDelimiter);</span>
<a href="#l25.943"></a><span id="l25.943">         urlSpec.Append(folderPath);</span>
<a href="#l25.944"></a><span id="l25.944">         rv = uri-&gt;SetSpecInternal(urlSpec);</span>
<a href="#l25.945"></a><span id="l25.945"> </span>
<a href="#l25.946"></a><span id="l25.946" class="difflineminus">-        // Make sure the uri has the same hierarchy separator as the one in msg folder </span>
<a href="#l25.947"></a><span id="l25.947" class="difflineplus">+        // Make sure the uri has the same hierarchy separator as the one in msg folder</span>
<a href="#l25.948"></a><span id="l25.948">         // obj if it's not kOnlineHierarchySeparatorUnknown (ie, '^').</span>
<a href="#l25.949"></a><span id="l25.949">         char uriDelimiter;</span>
<a href="#l25.950"></a><span id="l25.950">         nsresult rv1 = aImapUrl-&gt;GetOnlineSubDirSeparator(&amp;uriDelimiter);</span>
<a href="#l25.951"></a><span id="l25.951">         if (NS_SUCCEEDED (rv1) &amp;&amp; hierarchyDelimiter != kOnlineHierarchySeparatorUnknown &amp;&amp;</span>
<a href="#l25.952"></a><span id="l25.952">             uriDelimiter != hierarchyDelimiter)</span>
<a href="#l25.953"></a><span id="l25.953">           aImapUrl-&gt;SetOnlineSubDirSeparator(hierarchyDelimiter);</span>
<a href="#l25.954"></a><span id="l25.954"> </span>
<a href="#l25.955"></a><span id="l25.955">         if (NS_SUCCEEDED(rv))</span>
<a href="#l25.956"></a><span id="l25.956" class="difflineat">@@ -1942,17 +1942,17 @@ NS_IMETHODIMP nsImapService::OnlineMessa</span>
<a href="#l25.957"></a><span id="l25.957"> </span>
<a href="#l25.958"></a><span id="l25.958">   rv = aDstFolder-&gt;GetServer(getter_AddRefs(dstServer));</span>
<a href="#l25.959"></a><span id="l25.959">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.960"></a><span id="l25.960"> </span>
<a href="#l25.961"></a><span id="l25.961">   bool sameServer;</span>
<a href="#l25.962"></a><span id="l25.962">   rv = dstServer-&gt;Equals(srcServer, &amp;sameServer);</span>
<a href="#l25.963"></a><span id="l25.963">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.964"></a><span id="l25.964"> </span>
<a href="#l25.965"></a><span id="l25.965" class="difflineminus">-  if (!sameServer) </span>
<a href="#l25.966"></a><span id="l25.966" class="difflineplus">+  if (!sameServer)</span>
<a href="#l25.967"></a><span id="l25.967">   {</span>
<a href="#l25.968"></a><span id="l25.968">     NS_ASSERTION(false, &quot;can't use this method to copy across servers&quot;);</span>
<a href="#l25.969"></a><span id="l25.969">     // *** can only take message from the same imap host and user accnt</span>
<a href="#l25.970"></a><span id="l25.970">     return NS_ERROR_FAILURE;</span>
<a href="#l25.971"></a><span id="l25.971">   }</span>
<a href="#l25.972"></a><span id="l25.972"> </span>
<a href="#l25.973"></a><span id="l25.973">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.974"></a><span id="l25.974">   nsAutoCString urlSpec;</span>
<a href="#l25.975"></a><span id="l25.975" class="difflineat">@@ -2074,17 +2074,17 @@ nsresult nsImapService::OfflineAppendFro</span>
<a href="#l25.976"></a><span id="l25.976">           msgParser-&gt;SetNewMsgHdr(newMsgHdr);</span>
<a href="#l25.977"></a><span id="l25.977">           // set the new key to fake key so the msg hdr will have that for a key</span>
<a href="#l25.978"></a><span id="l25.978">           msgParser-&gt;SetNewKey(fakeKey);</span>
<a href="#l25.979"></a><span id="l25.979">           bool needMoreData = false;</span>
<a href="#l25.980"></a><span id="l25.980">           char * newLine = nullptr;</span>
<a href="#l25.981"></a><span id="l25.981">           uint32_t numBytesInLine = 0;</span>
<a href="#l25.982"></a><span id="l25.982">           do</span>
<a href="#l25.983"></a><span id="l25.983">           {</span>
<a href="#l25.984"></a><span id="l25.984" class="difflineminus">-            newLine = inputStreamBuffer-&gt;ReadNextLine(inputStream, numBytesInLine, needMoreData); </span>
<a href="#l25.985"></a><span id="l25.985" class="difflineplus">+            newLine = inputStreamBuffer-&gt;ReadNextLine(inputStream, numBytesInLine, needMoreData);</span>
<a href="#l25.986"></a><span id="l25.986">             if (newLine)</span>
<a href="#l25.987"></a><span id="l25.987">             {</span>
<a href="#l25.988"></a><span id="l25.988">               msgParser-&gt;ParseAFolderLine(newLine, numBytesInLine);</span>
<a href="#l25.989"></a><span id="l25.989">               rv = offlineStore-&gt;Write(newLine, numBytesInLine, &amp;bytesWritten);</span>
<a href="#l25.990"></a><span id="l25.990">               free(newLine);</span>
<a href="#l25.991"></a><span id="l25.991">             }</span>
<a href="#l25.992"></a><span id="l25.992">           } while (newLine);</span>
<a href="#l25.993"></a><span id="l25.993">           msgParser-&gt;FinishHeader();</span>
<a href="#l25.994"></a><span id="l25.994" class="difflineat">@@ -2110,17 +2110,17 @@ nsresult nsImapService::OfflineAppendFro</span>
<a href="#l25.995"></a><span id="l25.995">           inputStream = nullptr;</span>
<a href="#l25.996"></a><span id="l25.996">           aListener-&gt;OnStopRunningUrl(aUrl, NS_OK);</span>
<a href="#l25.997"></a><span id="l25.997">           delete inputStreamBuffer;</span>
<a href="#l25.998"></a><span id="l25.998">         }</span>
<a href="#l25.999"></a><span id="l25.999">         offlineStore-&gt;Close();</span>
<a href="#l25.1000"></a><span id="l25.1000">       }</span>
<a href="#l25.1001"></a><span id="l25.1001">     }</span>
<a href="#l25.1002"></a><span id="l25.1002">   }</span>
<a href="#l25.1003"></a><span id="l25.1003" class="difflineminus">-          </span>
<a href="#l25.1004"></a><span id="l25.1004" class="difflineplus">+</span>
<a href="#l25.1005"></a><span id="l25.1005">   if (destDB)</span>
<a href="#l25.1006"></a><span id="l25.1006">     destDB-&gt;Close(true);</span>
<a href="#l25.1007"></a><span id="l25.1007">   return rv;</span>
<a href="#l25.1008"></a><span id="l25.1008"> }</span>
<a href="#l25.1009"></a><span id="l25.1009"> </span>
<a href="#l25.1010"></a><span id="l25.1010"> /* append message from file url */</span>
<a href="#l25.1011"></a><span id="l25.1011"> /* imap://HOST&gt;appendmsgfromfile&gt;DESTINATIONMAILBOXPATH */</span>
<a href="#l25.1012"></a><span id="l25.1012"> /* imap://HOST&gt;appenddraftfromfile&gt;DESTINATIONMAILBOXPATH&gt;UID&gt;messageId */</span>
<a href="#l25.1013"></a><span id="l25.1013" class="difflineat">@@ -2175,17 +2175,17 @@ NS_IMETHODIMP nsImapService::AppendMessa</span>
<a href="#l25.1014"></a><span id="l25.1014">       if (idsAreUids)</span>
<a href="#l25.1015"></a><span id="l25.1015">         urlSpec.Append(uidString);</span>
<a href="#l25.1016"></a><span id="l25.1016">       else</span>
<a href="#l25.1017"></a><span id="l25.1017">         urlSpec.Append(sequenceString);</span>
<a href="#l25.1018"></a><span id="l25.1018">       urlSpec.Append('&gt;');</span>
<a href="#l25.1019"></a><span id="l25.1019">       if (!messageId.IsEmpty())</span>
<a href="#l25.1020"></a><span id="l25.1020">         urlSpec.Append(messageId);</span>
<a href="#l25.1021"></a><span id="l25.1021">     }</span>
<a href="#l25.1022"></a><span id="l25.1022" class="difflineminus">-    </span>
<a href="#l25.1023"></a><span id="l25.1023" class="difflineplus">+</span>
<a href="#l25.1024"></a><span id="l25.1024">     rv = uri-&gt;SetSpecInternal(urlSpec);</span>
<a href="#l25.1025"></a><span id="l25.1025">     if (WeAreOffline())</span>
<a href="#l25.1026"></a><span id="l25.1026">     {</span>
<a href="#l25.1027"></a><span id="l25.1027">       // handle offline append to drafts or templates folder here.</span>
<a href="#l25.1028"></a><span id="l25.1028">       return OfflineAppendFromFile(aFile, uri, aDstFolder, messageId, inSelectedState, aListener, aURL, aCopyState);</span>
<a href="#l25.1029"></a><span id="l25.1029">     }</span>
<a href="#l25.1030"></a><span id="l25.1030">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.1031"></a><span id="l25.1031">       rv = GetImapConnectionAndLoadUrl(imapUrl, nullptr, aURL);</span>
<a href="#l25.1032"></a><span id="l25.1032" class="difflineat">@@ -2214,47 +2214,47 @@ nsresult nsImapService::GetImapConnectio</span>
<a href="#l25.1033"></a><span id="l25.1033">     aImapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l25.1034"></a><span id="l25.1034">     if (imapAction != nsIImapUrl::nsImapMsgFetch &amp;&amp; imapAction != nsIImapUrl::nsImapSaveMessageToDisk)</span>
<a href="#l25.1035"></a><span id="l25.1035">       return NS_MSG_ERROR_OFFLINE;</span>
<a href="#l25.1036"></a><span id="l25.1036">   }</span>
<a href="#l25.1037"></a><span id="l25.1037"> </span>
<a href="#l25.1038"></a><span id="l25.1038">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; aMsgIncomingServer;</span>
<a href="#l25.1039"></a><span id="l25.1039">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; msgUrl = do_QueryInterface(aImapUrl);</span>
<a href="#l25.1040"></a><span id="l25.1040">   nsresult rv = msgUrl-&gt;GetServer(getter_AddRefs(aMsgIncomingServer));</span>
<a href="#l25.1041"></a><span id="l25.1041" class="difflineminus">-    </span>
<a href="#l25.1042"></a><span id="l25.1042" class="difflineplus">+</span>
<a href="#l25.1043"></a><span id="l25.1043">   if (aURL)</span>
<a href="#l25.1044"></a><span id="l25.1044">   {</span>
<a href="#l25.1045"></a><span id="l25.1045">     nsCOMPtr&lt;nsIURI&gt; msgUrlUri = do_QueryInterface(msgUrl);</span>
<a href="#l25.1046"></a><span id="l25.1046">     msgUrlUri.forget(aURL);</span>
<a href="#l25.1047"></a><span id="l25.1047">   }</span>
<a href="#l25.1048"></a><span id="l25.1048"> </span>
<a href="#l25.1049"></a><span id="l25.1049">   if (NS_SUCCEEDED(rv) &amp;&amp; aMsgIncomingServer)</span>
<a href="#l25.1050"></a><span id="l25.1050">   {</span>
<a href="#l25.1051"></a><span id="l25.1051">     nsCOMPtr&lt;nsIImapIncomingServer&gt; aImapServer(do_QueryInterface(aMsgIncomingServer, &amp;rv));</span>
<a href="#l25.1052"></a><span id="l25.1052">     if (NS_SUCCEEDED(rv) &amp;&amp; aImapServer)</span>
<a href="#l25.1053"></a><span id="l25.1053">       rv = aImapServer-&gt;GetImapConnectionAndLoadUrl(aImapUrl, aConsumer);</span>
<a href="#l25.1054"></a><span id="l25.1054">   }</span>
<a href="#l25.1055"></a><span id="l25.1055">   return rv;</span>
<a href="#l25.1056"></a><span id="l25.1056"> }</span>
<a href="#l25.1057"></a><span id="l25.1057"> </span>
<a href="#l25.1058"></a><span id="l25.1058"> NS_IMETHODIMP nsImapService::MoveFolder(nsIMsgFolder *srcFolder,</span>
<a href="#l25.1059"></a><span id="l25.1059" class="difflineminus">-                                        nsIMsgFolder *dstFolder, </span>
<a href="#l25.1060"></a><span id="l25.1060" class="difflineminus">-                                        nsIUrlListener *urlListener, </span>
<a href="#l25.1061"></a><span id="l25.1061" class="difflineminus">-                                        nsIMsgWindow *msgWindow, </span>
<a href="#l25.1062"></a><span id="l25.1062" class="difflineplus">+                                        nsIMsgFolder *dstFolder,</span>
<a href="#l25.1063"></a><span id="l25.1063" class="difflineplus">+                                        nsIUrlListener *urlListener,</span>
<a href="#l25.1064"></a><span id="l25.1064" class="difflineplus">+                                        nsIMsgWindow *msgWindow,</span>
<a href="#l25.1065"></a><span id="l25.1065">                                         nsIURI **url)</span>
<a href="#l25.1066"></a><span id="l25.1066"> {</span>
<a href="#l25.1067"></a><span id="l25.1067">   NS_ENSURE_ARG_POINTER(srcFolder);</span>
<a href="#l25.1068"></a><span id="l25.1068">   NS_ENSURE_ARG_POINTER(dstFolder);</span>
<a href="#l25.1069"></a><span id="l25.1069"> </span>
<a href="#l25.1070"></a><span id="l25.1070">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.1071"></a><span id="l25.1071">   nsAutoCString urlSpec;</span>
<a href="#l25.1072"></a><span id="l25.1072">   nsresult rv;</span>
<a href="#l25.1073"></a><span id="l25.1073"> </span>
<a href="#l25.1074"></a><span id="l25.1074">   char default_hierarchyDelimiter = GetHierarchyDelimiter(dstFolder);</span>
<a href="#l25.1075"></a><span id="l25.1075" class="difflineminus">-  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), dstFolder, </span>
<a href="#l25.1076"></a><span id="l25.1076" class="difflineplus">+  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), dstFolder,</span>
<a href="#l25.1077"></a><span id="l25.1077">                             urlListener, urlSpec, default_hierarchyDelimiter);</span>
<a href="#l25.1078"></a><span id="l25.1078">   if (NS_SUCCEEDED(rv) &amp;&amp; imapUrl)</span>
<a href="#l25.1079"></a><span id="l25.1079">   {</span>
<a href="#l25.1080"></a><span id="l25.1080">     rv = SetImapUrlSink(dstFolder, imapUrl);</span>
<a href="#l25.1081"></a><span id="l25.1081">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.1082"></a><span id="l25.1082">     {</span>
<a href="#l25.1083"></a><span id="l25.1083">       nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailNewsUrl = do_QueryInterface(imapUrl);</span>
<a href="#l25.1084"></a><span id="l25.1084">       if (mailNewsUrl)</span>
<a href="#l25.1085"></a><span id="l25.1085" class="difflineat">@@ -2281,28 +2281,28 @@ NS_IMETHODIMP nsImapService::MoveFolder(</span>
<a href="#l25.1086"></a><span id="l25.1086">         rv = GetImapConnectionAndLoadUrl(imapUrl, nullptr, url);</span>
<a href="#l25.1087"></a><span id="l25.1087">       }</span>
<a href="#l25.1088"></a><span id="l25.1088">     }</span>
<a href="#l25.1089"></a><span id="l25.1089">   }</span>
<a href="#l25.1090"></a><span id="l25.1090">   return rv;</span>
<a href="#l25.1091"></a><span id="l25.1091"> }</span>
<a href="#l25.1092"></a><span id="l25.1092"> </span>
<a href="#l25.1093"></a><span id="l25.1093"> NS_IMETHODIMP nsImapService::RenameLeaf(nsIMsgFolder *srcFolder,</span>
<a href="#l25.1094"></a><span id="l25.1094" class="difflineminus">-                                        const nsAString &amp;newLeafName, </span>
<a href="#l25.1095"></a><span id="l25.1095" class="difflineplus">+                                        const nsAString &amp;newLeafName,</span>
<a href="#l25.1096"></a><span id="l25.1096">                                         nsIUrlListener *urlListener,</span>
<a href="#l25.1097"></a><span id="l25.1097" class="difflineminus">-                                        nsIMsgWindow *msgWindow, </span>
<a href="#l25.1098"></a><span id="l25.1098" class="difflineplus">+                                        nsIMsgWindow *msgWindow,</span>
<a href="#l25.1099"></a><span id="l25.1099">                                         nsIURI **url)</span>
<a href="#l25.1100"></a><span id="l25.1100"> {</span>
<a href="#l25.1101"></a><span id="l25.1101">   NS_ENSURE_ARG_POINTER(srcFolder);</span>
<a href="#l25.1102"></a><span id="l25.1102"> </span>
<a href="#l25.1103"></a><span id="l25.1103">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.1104"></a><span id="l25.1104">   nsAutoCString urlSpec;</span>
<a href="#l25.1105"></a><span id="l25.1105"> </span>
<a href="#l25.1106"></a><span id="l25.1106">   char hierarchyDelimiter = GetHierarchyDelimiter(srcFolder);</span>
<a href="#l25.1107"></a><span id="l25.1107" class="difflineminus">-  nsresult rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), srcFolder, </span>
<a href="#l25.1108"></a><span id="l25.1108" class="difflineplus">+  nsresult rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), srcFolder,</span>
<a href="#l25.1109"></a><span id="l25.1109">                             urlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.1110"></a><span id="l25.1110">   if (NS_SUCCEEDED(rv))</span>
<a href="#l25.1111"></a><span id="l25.1111">   {</span>
<a href="#l25.1112"></a><span id="l25.1112">     rv = SetImapUrlSink(srcFolder, imapUrl);</span>
<a href="#l25.1113"></a><span id="l25.1113">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.1114"></a><span id="l25.1114">     {</span>
<a href="#l25.1115"></a><span id="l25.1115">       nsCOMPtr&lt;nsIURI&gt; uri = do_QueryInterface(imapUrl);</span>
<a href="#l25.1116"></a><span id="l25.1116">       nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailNewsUrl = do_QueryInterface(imapUrl);</span>
<a href="#l25.1117"></a><span id="l25.1117" class="difflineat">@@ -2349,17 +2349,17 @@ NS_IMETHODIMP nsImapService::CreateFolde</span>
<a href="#l25.1118"></a><span id="l25.1118"> {</span>
<a href="#l25.1119"></a><span id="l25.1119">   NS_ENSURE_ARG_POINTER(parent);</span>
<a href="#l25.1120"></a><span id="l25.1120"> </span>
<a href="#l25.1121"></a><span id="l25.1121">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.1122"></a><span id="l25.1122">   nsAutoCString urlSpec;</span>
<a href="#l25.1123"></a><span id="l25.1123">   nsresult rv;</span>
<a href="#l25.1124"></a><span id="l25.1124"> </span>
<a href="#l25.1125"></a><span id="l25.1125">   char hierarchyDelimiter = GetHierarchyDelimiter(parent);</span>
<a href="#l25.1126"></a><span id="l25.1126" class="difflineminus">-  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), parent, </span>
<a href="#l25.1127"></a><span id="l25.1127" class="difflineplus">+  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), parent,</span>
<a href="#l25.1128"></a><span id="l25.1128">                             urlListener, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.1129"></a><span id="l25.1129">   if (NS_SUCCEEDED(rv) &amp;&amp; imapUrl)</span>
<a href="#l25.1130"></a><span id="l25.1130">   {</span>
<a href="#l25.1131"></a><span id="l25.1131">     rv = SetImapUrlSink(parent, imapUrl);</span>
<a href="#l25.1132"></a><span id="l25.1132">     if (NS_SUCCEEDED(rv))</span>
<a href="#l25.1133"></a><span id="l25.1133">     {</span>
<a href="#l25.1134"></a><span id="l25.1134">       nsCOMPtr&lt;nsIURI&gt; uri = do_QueryInterface(imapUrl);</span>
<a href="#l25.1135"></a><span id="l25.1135"> </span>
<a href="#l25.1136"></a><span id="l25.1136" class="difflineat">@@ -2388,18 +2388,18 @@ NS_IMETHODIMP nsImapService::CreateFolde</span>
<a href="#l25.1137"></a><span id="l25.1137">       if (NS_SUCCEEDED(rv))</span>
<a href="#l25.1138"></a><span id="l25.1138">         rv = GetImapConnectionAndLoadUrl(imapUrl, nullptr, url);</span>
<a href="#l25.1139"></a><span id="l25.1139">     } // if (NS_SUCCEEDED(rv))</span>
<a href="#l25.1140"></a><span id="l25.1140">   } // if (NS_SUCCEEDED(rv) &amp;&amp; imapUrl)</span>
<a href="#l25.1141"></a><span id="l25.1141">   return rv;</span>
<a href="#l25.1142"></a><span id="l25.1142"> }</span>
<a href="#l25.1143"></a><span id="l25.1143"> </span>
<a href="#l25.1144"></a><span id="l25.1144"> NS_IMETHODIMP nsImapService::EnsureFolderExists(nsIMsgFolder *parent,</span>
<a href="#l25.1145"></a><span id="l25.1145" class="difflineminus">-                                                const nsAString &amp;newFolderName, </span>
<a href="#l25.1146"></a><span id="l25.1146" class="difflineminus">-                                                nsIUrlListener *urlListener, </span>
<a href="#l25.1147"></a><span id="l25.1147" class="difflineplus">+                                                const nsAString &amp;newFolderName,</span>
<a href="#l25.1148"></a><span id="l25.1148" class="difflineplus">+                                                nsIUrlListener *urlListener,</span>
<a href="#l25.1149"></a><span id="l25.1149">                                                 nsIURI **url)</span>
<a href="#l25.1150"></a><span id="l25.1150"> {</span>
<a href="#l25.1151"></a><span id="l25.1151">   NS_ENSURE_ARG_POINTER(parent);</span>
<a href="#l25.1152"></a><span id="l25.1152"> </span>
<a href="#l25.1153"></a><span id="l25.1153">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.1154"></a><span id="l25.1154">   nsAutoCString urlSpec;</span>
<a href="#l25.1155"></a><span id="l25.1155">   nsresult rv;</span>
<a href="#l25.1156"></a><span id="l25.1156"> </span>
<a href="#l25.1157"></a><span id="l25.1157" class="difflineat">@@ -2416,17 +2416,17 @@ NS_IMETHODIMP nsImapService::EnsureFolde</span>
<a href="#l25.1158"></a><span id="l25.1158">       GetFolderName(parent, folderName);</span>
<a href="#l25.1159"></a><span id="l25.1159">       urlSpec.AppendLiteral(&quot;/ensureExists&gt;&quot;);</span>
<a href="#l25.1160"></a><span id="l25.1160">       urlSpec.Append(hierarchyDelimiter);</span>
<a href="#l25.1161"></a><span id="l25.1161">       if (!folderName.IsEmpty())</span>
<a href="#l25.1162"></a><span id="l25.1162">       {</span>
<a href="#l25.1163"></a><span id="l25.1163">         urlSpec.Append(folderName);</span>
<a href="#l25.1164"></a><span id="l25.1164">         urlSpec.Append(hierarchyDelimiter);</span>
<a href="#l25.1165"></a><span id="l25.1165">       }</span>
<a href="#l25.1166"></a><span id="l25.1166" class="difflineminus">-      nsAutoCString utfNewName; </span>
<a href="#l25.1167"></a><span id="l25.1167" class="difflineplus">+      nsAutoCString utfNewName;</span>
<a href="#l25.1168"></a><span id="l25.1168">       CopyUTF16toMUTF7(PromiseFlatString(newFolderName), utfNewName);</span>
<a href="#l25.1169"></a><span id="l25.1169">       nsCString escapedFolderName;</span>
<a href="#l25.1170"></a><span id="l25.1170">       MsgEscapeString(utfNewName, nsINetUtil::ESCAPE_URL_PATH, escapedFolderName);</span>
<a href="#l25.1171"></a><span id="l25.1171">       urlSpec.Append(escapedFolderName);</span>
<a href="#l25.1172"></a><span id="l25.1172"> </span>
<a href="#l25.1173"></a><span id="l25.1173">       rv = uri-&gt;SetSpecInternal(urlSpec);</span>
<a href="#l25.1174"></a><span id="l25.1174">       if (NS_SUCCEEDED(rv))</span>
<a href="#l25.1175"></a><span id="l25.1175">         rv = GetImapConnectionAndLoadUrl(imapUrl, nullptr, url);</span>
<a href="#l25.1176"></a><span id="l25.1176" class="difflineat">@@ -2443,17 +2443,17 @@ NS_IMETHODIMP nsImapService::ListFolder(</span>
<a href="#l25.1177"></a><span id="l25.1177"> </span>
<a href="#l25.1178"></a><span id="l25.1178">   return FolderCommand(aImapMailFolder, aUrlListener,</span>
<a href="#l25.1179"></a><span id="l25.1179">                        &quot;/listfolder&gt;&quot;, nsIImapUrl::nsImapListFolder, nullptr, aURL);</span>
<a href="#l25.1180"></a><span id="l25.1180"> }</span>
<a href="#l25.1181"></a><span id="l25.1181"> </span>
<a href="#l25.1182"></a><span id="l25.1182"> NS_IMETHODIMP nsImapService::GetScheme(nsACString &amp;aScheme)</span>
<a href="#l25.1183"></a><span id="l25.1183"> {</span>
<a href="#l25.1184"></a><span id="l25.1184">   aScheme.AssignLiteral(&quot;imap&quot;);</span>
<a href="#l25.1185"></a><span id="l25.1185" class="difflineminus">-  return NS_OK; </span>
<a href="#l25.1186"></a><span id="l25.1186" class="difflineplus">+  return NS_OK;</span>
<a href="#l25.1187"></a><span id="l25.1187"> }</span>
<a href="#l25.1188"></a><span id="l25.1188"> </span>
<a href="#l25.1189"></a><span id="l25.1189"> NS_IMETHODIMP nsImapService::GetDefaultPort(int32_t *aDefaultPort)</span>
<a href="#l25.1190"></a><span id="l25.1190"> {</span>
<a href="#l25.1191"></a><span id="l25.1191">   NS_ENSURE_ARG_POINTER(aDefaultPort);</span>
<a href="#l25.1192"></a><span id="l25.1192">   *aDefaultPort = nsIImapUrl::DEFAULT_IMAP_PORT;</span>
<a href="#l25.1193"></a><span id="l25.1193">   return NS_OK;</span>
<a href="#l25.1194"></a><span id="l25.1194"> }</span>
<a href="#l25.1195"></a><span id="l25.1195" class="difflineat">@@ -2475,57 +2475,57 @@ NS_IMETHODIMP nsImapService::AllowPort(i</span>
<a href="#l25.1196"></a><span id="l25.1196">   *aRetVal = true;</span>
<a href="#l25.1197"></a><span id="l25.1197">   return NS_OK;</span>
<a href="#l25.1198"></a><span id="l25.1198"> }</span>
<a href="#l25.1199"></a><span id="l25.1199"> </span>
<a href="#l25.1200"></a><span id="l25.1200"> NS_IMETHODIMP nsImapService::GetDefaultDoBiff(bool *aDoBiff)</span>
<a href="#l25.1201"></a><span id="l25.1201"> {</span>
<a href="#l25.1202"></a><span id="l25.1202">   NS_ENSURE_ARG_POINTER(aDoBiff);</span>
<a href="#l25.1203"></a><span id="l25.1203">   // by default, do biff for IMAP servers</span>
<a href="#l25.1204"></a><span id="l25.1204" class="difflineminus">-  *aDoBiff = true;    </span>
<a href="#l25.1205"></a><span id="l25.1205" class="difflineplus">+  *aDoBiff = true;</span>
<a href="#l25.1206"></a><span id="l25.1206">   return NS_OK;</span>
<a href="#l25.1207"></a><span id="l25.1207"> }</span>
<a href="#l25.1208"></a><span id="l25.1208"> </span>
<a href="#l25.1209"></a><span id="l25.1209"> NS_IMETHODIMP nsImapService::GetDefaultServerPort(bool isSecure, int32_t *aDefaultPort)</span>
<a href="#l25.1210"></a><span id="l25.1210"> {</span>
<a href="#l25.1211"></a><span id="l25.1211">   nsresult rv = NS_OK;</span>
<a href="#l25.1212"></a><span id="l25.1212" class="difflineminus">-  </span>
<a href="#l25.1213"></a><span id="l25.1213" class="difflineplus">+</span>
<a href="#l25.1214"></a><span id="l25.1214">   // Return Secure IMAP Port if secure option chosen i.e., if isSecure is TRUE</span>
<a href="#l25.1215"></a><span id="l25.1215">   if (isSecure)</span>
<a href="#l25.1216"></a><span id="l25.1216">     *aDefaultPort = nsIImapUrl::DEFAULT_IMAPS_PORT;</span>
<a href="#l25.1217"></a><span id="l25.1217" class="difflineminus">-  else    </span>
<a href="#l25.1218"></a><span id="l25.1218" class="difflineplus">+  else</span>
<a href="#l25.1219"></a><span id="l25.1219">     rv = GetDefaultPort(aDefaultPort);</span>
<a href="#l25.1220"></a><span id="l25.1220" class="difflineminus">-  </span>
<a href="#l25.1221"></a><span id="l25.1221" class="difflineplus">+</span>
<a href="#l25.1222"></a><span id="l25.1222">   return rv;</span>
<a href="#l25.1223"></a><span id="l25.1223"> }</span>
<a href="#l25.1224"></a><span id="l25.1224"> </span>
<a href="#l25.1225"></a><span id="l25.1225"> // this method first tries to find an exact username and hostname match with the given url</span>
<a href="#l25.1226"></a><span id="l25.1226" class="difflineminus">-// then, tries to find any account on the passed in imap host in case this is a url to </span>
<a href="#l25.1227"></a><span id="l25.1227" class="difflineplus">+// then, tries to find any account on the passed in imap host in case this is a url to</span>
<a href="#l25.1228"></a><span id="l25.1228"> // a shared imap folder.</span>
<a href="#l25.1229"></a><span id="l25.1229"> nsresult nsImapService::GetServerFromUrl(nsIImapUrl *aImapUrl, nsIMsgIncomingServer **aServer)</span>
<a href="#l25.1230"></a><span id="l25.1230"> {</span>
<a href="#l25.1231"></a><span id="l25.1231">   nsresult rv;</span>
<a href="#l25.1232"></a><span id="l25.1232">   nsCString folderName;</span>
<a href="#l25.1233"></a><span id="l25.1233">   nsAutoCString userPass;</span>
<a href="#l25.1234"></a><span id="l25.1234">   nsAutoCString hostName;</span>
<a href="#l25.1235"></a><span id="l25.1235">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(aImapUrl);</span>
<a href="#l25.1236"></a><span id="l25.1236" class="difflineminus">-  </span>
<a href="#l25.1237"></a><span id="l25.1237" class="difflineplus">+</span>
<a href="#l25.1238"></a><span id="l25.1238">   // if we can't get a folder name out of the url then I think this is an error</span>
<a href="#l25.1239"></a><span id="l25.1239">   aImapUrl-&gt;CreateCanonicalSourceFolderPathString(getter_Copies(folderName));</span>
<a href="#l25.1240"></a><span id="l25.1240">   if (folderName.IsEmpty())</span>
<a href="#l25.1241"></a><span id="l25.1241">   {</span>
<a href="#l25.1242"></a><span id="l25.1242">     rv = mailnewsUrl-&gt;GetFileName(folderName);</span>
<a href="#l25.1243"></a><span id="l25.1243">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1244"></a><span id="l25.1244">   }</span>
<a href="#l25.1245"></a><span id="l25.1245" class="difflineminus">-  </span>
<a href="#l25.1246"></a><span id="l25.1246" class="difflineplus">+</span>
<a href="#l25.1247"></a><span id="l25.1247">   nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager = do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l25.1248"></a><span id="l25.1248">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1249"></a><span id="l25.1249" class="difflineminus">-  </span>
<a href="#l25.1250"></a><span id="l25.1250" class="difflineplus">+</span>
<a href="#l25.1251"></a><span id="l25.1251">   rv = accountManager-&gt;FindServerByURI(mailnewsUrl, false, aServer);</span>
<a href="#l25.1252"></a><span id="l25.1252" class="difflineminus">-  </span>
<a href="#l25.1253"></a><span id="l25.1253" class="difflineplus">+</span>
<a href="#l25.1254"></a><span id="l25.1254">   // look for server with any user name, in case we're trying to subscribe</span>
<a href="#l25.1255"></a><span id="l25.1255">   // to a folder with some one else's user name like the following</span>
<a href="#l25.1256"></a><span id="l25.1256">   // &quot;IMAP://userSharingFolder@server1/SharedFolderName&quot;</span>
<a href="#l25.1257"></a><span id="l25.1257">   if (NS_FAILED(rv) || !aServer)</span>
<a href="#l25.1258"></a><span id="l25.1258">   {</span>
<a href="#l25.1259"></a><span id="l25.1259">     nsAutoCString turl;</span>
<a href="#l25.1260"></a><span id="l25.1260">     rv = mailnewsUrl-&gt;GetSpec(turl);</span>
<a href="#l25.1261"></a><span id="l25.1261">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1262"></a><span id="l25.1262" class="difflineat">@@ -2534,17 +2534,17 @@ nsresult nsImapService::GetServerFromUrl</span>
<a href="#l25.1263"></a><span id="l25.1263">     rv = NS_MutateURI(NS_STANDARDURLMUTATOR_CONTRACTID).SetSpec(turl).Finalize(url);</span>
<a href="#l25.1264"></a><span id="l25.1264">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1265"></a><span id="l25.1265"> </span>
<a href="#l25.1266"></a><span id="l25.1266">     url-&gt;SetUserPass(EmptyCString());</span>
<a href="#l25.1267"></a><span id="l25.1267">     rv = accountManager-&gt;FindServerByURI(url, false, aServer);</span>
<a href="#l25.1268"></a><span id="l25.1268">     if (*aServer)</span>
<a href="#l25.1269"></a><span id="l25.1269">       aImapUrl-&gt;SetExternalLinkUrl(true);</span>
<a href="#l25.1270"></a><span id="l25.1270">   }</span>
<a href="#l25.1271"></a><span id="l25.1271" class="difflineminus">-  </span>
<a href="#l25.1272"></a><span id="l25.1272" class="difflineplus">+</span>
<a href="#l25.1273"></a><span id="l25.1273">     // if we can't extract the imap server from this url then give up!!!</span>
<a href="#l25.1274"></a><span id="l25.1274">   NS_ENSURE_TRUE(*aServer, NS_ERROR_FAILURE);</span>
<a href="#l25.1275"></a><span id="l25.1275">   return rv;</span>
<a href="#l25.1276"></a><span id="l25.1276"> }</span>
<a href="#l25.1277"></a><span id="l25.1277"> </span>
<a href="#l25.1278"></a><span id="l25.1278"> NS_IMETHODIMP nsImapService::NewURI(const nsACString &amp;aSpec,</span>
<a href="#l25.1279"></a><span id="l25.1279">                                     const char *aOriginCharset,  // ignored</span>
<a href="#l25.1280"></a><span id="l25.1280">                                     nsIURI *aBaseURI,</span>
<a href="#l25.1281"></a><span id="l25.1281" class="difflineat">@@ -2656,33 +2656,33 @@ NS_IMETHODIMP nsImapService::NewChannel2</span>
<a href="#l25.1282"></a><span id="l25.1282">   *aRetVal = nullptr;</span>
<a href="#l25.1283"></a><span id="l25.1283"> </span>
<a href="#l25.1284"></a><span id="l25.1284">   nsresult rv;</span>
<a href="#l25.1285"></a><span id="l25.1285">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(aURI, &amp;rv);</span>
<a href="#l25.1286"></a><span id="l25.1286">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1287"></a><span id="l25.1287">   nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(imapUrl, &amp;rv);</span>
<a href="#l25.1288"></a><span id="l25.1288">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1289"></a><span id="l25.1289"> </span>
<a href="#l25.1290"></a><span id="l25.1290" class="difflineminus">-  // imap can't open and return a channel right away...the url needs to go in the imap url queue </span>
<a href="#l25.1291"></a><span id="l25.1291" class="difflineplus">+  // imap can't open and return a channel right away...the url needs to go in the imap url queue</span>
<a href="#l25.1292"></a><span id="l25.1292">   // until we find a connection which can run the url..in order to satisfy necko, we're going to return</span>
<a href="#l25.1293"></a><span id="l25.1293">   // a mock imap channel....</span>
<a href="#l25.1294"></a><span id="l25.1294">   nsCOMPtr&lt;nsIImapMockChannel&gt; channel = do_CreateInstance(kCImapMockChannel, &amp;rv);</span>
<a href="#l25.1295"></a><span id="l25.1295">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1296"></a><span id="l25.1296">   channel-&gt;SetURI(aURI);</span>
<a href="#l25.1297"></a><span id="l25.1297"> </span>
<a href="#l25.1298"></a><span id="l25.1298">   rv = channel-&gt;SetLoadInfo(aLoadInfo);</span>
<a href="#l25.1299"></a><span id="l25.1299">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1300"></a><span id="l25.1300"> </span>
<a href="#l25.1301"></a><span id="l25.1301">   nsCOMPtr&lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l25.1302"></a><span id="l25.1302">   mailnewsUrl-&gt;GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l25.1303"></a><span id="l25.1303">   if (msgWindow)</span>
<a href="#l25.1304"></a><span id="l25.1304">   {</span>
<a href="#l25.1305"></a><span id="l25.1305">     nsCOMPtr&lt;nsIDocShell&gt; msgDocShell;</span>
<a href="#l25.1306"></a><span id="l25.1306">     msgWindow-&gt;GetRootDocShell(getter_AddRefs(msgDocShell));</span>
<a href="#l25.1307"></a><span id="l25.1307" class="difflineminus">-    if (msgDocShell) </span>
<a href="#l25.1308"></a><span id="l25.1308" class="difflineplus">+    if (msgDocShell)</span>
<a href="#l25.1309"></a><span id="l25.1309">     {</span>
<a href="#l25.1310"></a><span id="l25.1310">       nsCOMPtr &lt;nsIProgressEventSink&gt; prevEventSink;</span>
<a href="#l25.1311"></a><span id="l25.1311">       channel-&gt;GetProgressEventSink(getter_AddRefs(prevEventSink));</span>
<a href="#l25.1312"></a><span id="l25.1312">       nsCOMPtr&lt;nsIInterfaceRequestor&gt; docIR(do_QueryInterface(msgDocShell));</span>
<a href="#l25.1313"></a><span id="l25.1313">       channel-&gt;SetNotificationCallbacks(docIR);</span>
<a href="#l25.1314"></a><span id="l25.1314">       // we want to use our existing event sink.</span>
<a href="#l25.1315"></a><span id="l25.1315">       if (prevEventSink)</span>
<a href="#l25.1316"></a><span id="l25.1316">         channel-&gt;SetProgressEventSink(prevEventSink);</span>
<a href="#l25.1317"></a><span id="l25.1317" class="difflineat">@@ -2730,17 +2730,17 @@ NS_IMETHODIMP nsImapService::NewChannel2</span>
<a href="#l25.1318"></a><span id="l25.1318">     nsAutoCString userPass;</span>
<a href="#l25.1319"></a><span id="l25.1319">     rv = mailnewsUrl-&gt;GetUserPass(userPass);</span>
<a href="#l25.1320"></a><span id="l25.1320">     server-&gt;GetKey(serverKey);</span>
<a href="#l25.1321"></a><span id="l25.1321">     nsCString fullFolderName;</span>
<a href="#l25.1322"></a><span id="l25.1322">     if (parent)</span>
<a href="#l25.1323"></a><span id="l25.1323">       fullFolderName = folderName;</span>
<a href="#l25.1324"></a><span id="l25.1324">     if (!parent &amp;&amp; !folderName.IsEmpty())  // check if this folder is another user's folder</span>
<a href="#l25.1325"></a><span id="l25.1325">     {</span>
<a href="#l25.1326"></a><span id="l25.1326" class="difflineminus">-      fullFolderName = nsIMAPNamespaceList::GenerateFullFolderNameWithDefaultNamespace(serverKey.get(), </span>
<a href="#l25.1327"></a><span id="l25.1327" class="difflineplus">+      fullFolderName = nsIMAPNamespaceList::GenerateFullFolderNameWithDefaultNamespace(serverKey.get(),</span>
<a href="#l25.1328"></a><span id="l25.1328">                                                                                        folderName.get(),</span>
<a href="#l25.1329"></a><span id="l25.1329">                                                                                        userPass.get(),</span>
<a href="#l25.1330"></a><span id="l25.1330">                                                                                        kOtherUsersNamespace,</span>
<a href="#l25.1331"></a><span id="l25.1331">                                                                                        nullptr);</span>
<a href="#l25.1332"></a><span id="l25.1332">       // if this is another user's folder, let's see if we're already subscribed to it.</span>
<a href="#l25.1333"></a><span id="l25.1333">       rv = imapRoot-&gt;FindOnlineSubFolder(fullFolderName, getter_AddRefs(subFolder));</span>
<a href="#l25.1334"></a><span id="l25.1334">       aFolder = do_QueryInterface(subFolder);</span>
<a href="#l25.1335"></a><span id="l25.1335">       if (aFolder)</span>
<a href="#l25.1336"></a><span id="l25.1336" class="difflineat">@@ -2750,17 +2750,17 @@ NS_IMETHODIMP nsImapService::NewChannel2</span>
<a href="#l25.1337"></a><span id="l25.1337">     // the other user's namespace, in which case, we shouldn't try to subscribe to it.</span>
<a href="#l25.1338"></a><span id="l25.1338">     if (!parent &amp;&amp; !folderName.IsEmpty() &amp;&amp; !fullFolderName.IsEmpty())</span>
<a href="#l25.1339"></a><span id="l25.1339">     {</span>
<a href="#l25.1340"></a><span id="l25.1340">       // this folder doesn't exist - check if the user wants to subscribe to this folder.</span>
<a href="#l25.1341"></a><span id="l25.1341">       nsCOMPtr&lt;nsIPrompt&gt; dialog;</span>
<a href="#l25.1342"></a><span id="l25.1342">       nsCOMPtr&lt;nsIWindowWatcher&gt; wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID, &amp;rv));</span>
<a href="#l25.1343"></a><span id="l25.1343">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1344"></a><span id="l25.1344">       wwatch-&gt;GetNewPrompter(nullptr, getter_AddRefs(dialog));</span>
<a href="#l25.1345"></a><span id="l25.1345" class="difflineminus">-      </span>
<a href="#l25.1346"></a><span id="l25.1346" class="difflineplus">+</span>
<a href="#l25.1347"></a><span id="l25.1347">       nsString statusString, confirmText;</span>
<a href="#l25.1348"></a><span id="l25.1348">       nsCOMPtr&lt;nsIStringBundle&gt; bundle;</span>
<a href="#l25.1349"></a><span id="l25.1349">       rv = IMAPGetStringBundle(getter_AddRefs(bundle));</span>
<a href="#l25.1350"></a><span id="l25.1350">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1351"></a><span id="l25.1351">         // need to convert folder name from mod-utf7 to unicode</span>
<a href="#l25.1352"></a><span id="l25.1352">       nsAutoString unescapedName;</span>
<a href="#l25.1353"></a><span id="l25.1353">       if (NS_FAILED(CopyMUTF7toUTF16(fullFolderName, unescapedName)))</span>
<a href="#l25.1354"></a><span id="l25.1354">         CopyASCIItoUTF16(fullFolderName, unescapedName);</span>
<a href="#l25.1355"></a><span id="l25.1355" class="difflineat">@@ -2812,25 +2812,25 @@ NS_IMETHODIMP nsImapService::NewChannel2</span>
<a href="#l25.1356"></a><span id="l25.1356">         }</span>
<a href="#l25.1357"></a><span id="l25.1357">       }</span>
<a href="#l25.1358"></a><span id="l25.1358">       // error out this channel, so it'll stop trying to run the url.</span>
<a href="#l25.1359"></a><span id="l25.1359">       rv = NS_ERROR_FAILURE;</span>
<a href="#l25.1360"></a><span id="l25.1360">       *aRetVal = nullptr;</span>
<a href="#l25.1361"></a><span id="l25.1361">     }</span>
<a href="#l25.1362"></a><span id="l25.1362">     // this folder exists - check if this is a click on a link to the folder</span>
<a href="#l25.1363"></a><span id="l25.1363">     // in which case, we'll select it.</span>
<a href="#l25.1364"></a><span id="l25.1364" class="difflineminus">-    else if (!fullFolderName.IsEmpty())  </span>
<a href="#l25.1365"></a><span id="l25.1365" class="difflineminus">-    {         </span>
<a href="#l25.1366"></a><span id="l25.1366" class="difflineplus">+    else if (!fullFolderName.IsEmpty())</span>
<a href="#l25.1367"></a><span id="l25.1367" class="difflineplus">+    {</span>
<a href="#l25.1368"></a><span id="l25.1368">       nsCOMPtr&lt;nsIMsgFolder&gt; imapFolder;</span>
<a href="#l25.1369"></a><span id="l25.1369">       nsCOMPtr&lt;nsIImapServerSink&gt; serverSink;</span>
<a href="#l25.1370"></a><span id="l25.1370" class="difflineminus">-      </span>
<a href="#l25.1371"></a><span id="l25.1371" class="difflineplus">+</span>
<a href="#l25.1372"></a><span id="l25.1372">       mailnewsUrl-&gt;GetFolder(getter_AddRefs(imapFolder));</span>
<a href="#l25.1373"></a><span id="l25.1373">       imapUrl-&gt;GetImapServerSink(getter_AddRefs(serverSink));</span>
<a href="#l25.1374"></a><span id="l25.1374">       // need to see if this is a link click - one way is to check if the url is set up correctly</span>
<a href="#l25.1375"></a><span id="l25.1375" class="difflineminus">-      // if not, it's probably a url click. We need a better way of doing this. </span>
<a href="#l25.1376"></a><span id="l25.1376" class="difflineplus">+      // if not, it's probably a url click. We need a better way of doing this.</span>
<a href="#l25.1377"></a><span id="l25.1377">       if (!imapFolder)</span>
<a href="#l25.1378"></a><span id="l25.1378">       {</span>
<a href="#l25.1379"></a><span id="l25.1379">         nsCOMPtr&lt;nsIMsgMailSession&gt; mailSession = do_GetService(NS_MSGMAILSESSION_CONTRACTID, &amp;rv);</span>
<a href="#l25.1380"></a><span id="l25.1380">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1381"></a><span id="l25.1381">         nsCOMPtr &lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l25.1382"></a><span id="l25.1382">         rv = mailSession-&gt;GetTopmostMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l25.1383"></a><span id="l25.1383">         if (NS_SUCCEEDED(rv) &amp;&amp; msgWindow)</span>
<a href="#l25.1384"></a><span id="l25.1384">         {</span>
<a href="#l25.1385"></a><span id="l25.1385" class="difflineat">@@ -2935,63 +2935,63 @@ NS_IMETHODIMP nsImapService::GetCanDelet</span>
<a href="#l25.1386"></a><span id="l25.1386">   return NS_OK;</span>
<a href="#l25.1387"></a><span id="l25.1387"> }</span>
<a href="#l25.1388"></a><span id="l25.1388"> </span>
<a href="#l25.1389"></a><span id="l25.1389"> NS_IMETHODIMP nsImapService::GetCanDuplicate(bool *aCanDuplicate)</span>
<a href="#l25.1390"></a><span id="l25.1390"> {</span>
<a href="#l25.1391"></a><span id="l25.1391">   NS_ENSURE_ARG_POINTER(aCanDuplicate);</span>
<a href="#l25.1392"></a><span id="l25.1392">   *aCanDuplicate = true;</span>
<a href="#l25.1393"></a><span id="l25.1393">   return NS_OK;</span>
<a href="#l25.1394"></a><span id="l25.1394" class="difflineminus">-}        </span>
<a href="#l25.1395"></a><span id="l25.1395" class="difflineplus">+}</span>
<a href="#l25.1396"></a><span id="l25.1396"> </span>
<a href="#l25.1397"></a><span id="l25.1397"> NS_IMETHODIMP nsImapService::GetCanGetMessages(bool *aCanGetMessages)</span>
<a href="#l25.1398"></a><span id="l25.1398"> {</span>
<a href="#l25.1399"></a><span id="l25.1399">   NS_ENSURE_ARG_POINTER(aCanGetMessages);</span>
<a href="#l25.1400"></a><span id="l25.1400">   *aCanGetMessages = true;</span>
<a href="#l25.1401"></a><span id="l25.1401">   return NS_OK;</span>
<a href="#l25.1402"></a><span id="l25.1402" class="difflineminus">-}        </span>
<a href="#l25.1403"></a><span id="l25.1403" class="difflineplus">+}</span>
<a href="#l25.1404"></a><span id="l25.1404"> </span>
<a href="#l25.1405"></a><span id="l25.1405"> NS_IMETHODIMP nsImapService::GetCanGetIncomingMessages(bool *aCanGetIncomingMessages)</span>
<a href="#l25.1406"></a><span id="l25.1406"> {</span>
<a href="#l25.1407"></a><span id="l25.1407">   NS_ENSURE_ARG_POINTER(aCanGetIncomingMessages);</span>
<a href="#l25.1408"></a><span id="l25.1408">   *aCanGetIncomingMessages = true;</span>
<a href="#l25.1409"></a><span id="l25.1409">   return NS_OK;</span>
<a href="#l25.1410"></a><span id="l25.1410" class="difflineminus">-}    </span>
<a href="#l25.1411"></a><span id="l25.1411" class="difflineplus">+}</span>
<a href="#l25.1412"></a><span id="l25.1412"> </span>
<a href="#l25.1413"></a><span id="l25.1413"> NS_IMETHODIMP nsImapService::GetShowComposeMsgLink(bool *showComposeMsgLink)</span>
<a href="#l25.1414"></a><span id="l25.1414"> {</span>
<a href="#l25.1415"></a><span id="l25.1415">   NS_ENSURE_ARG_POINTER(showComposeMsgLink);</span>
<a href="#l25.1416"></a><span id="l25.1416">   *showComposeMsgLink = true;</span>
<a href="#l25.1417"></a><span id="l25.1417">   return NS_OK;</span>
<a href="#l25.1418"></a><span id="l25.1418"> }</span>
<a href="#l25.1419"></a><span id="l25.1419"> </span>
<a href="#l25.1420"></a><span id="l25.1420"> NS_IMETHODIMP nsImapService::GetFoldersCreatedAsync(bool *aAsyncCreation)</span>
<a href="#l25.1421"></a><span id="l25.1421"> {</span>
<a href="#l25.1422"></a><span id="l25.1422">   NS_ENSURE_ARG_POINTER(aAsyncCreation);</span>
<a href="#l25.1423"></a><span id="l25.1423">   *aAsyncCreation = true;</span>
<a href="#l25.1424"></a><span id="l25.1424">   return NS_OK;</span>
<a href="#l25.1425"></a><span id="l25.1425"> }</span>
<a href="#l25.1426"></a><span id="l25.1426"> </span>
<a href="#l25.1427"></a><span id="l25.1427" class="difflineminus">-NS_IMETHODIMP nsImapService::GetListOfFoldersWithPath(nsIImapIncomingServer *aServer, </span>
<a href="#l25.1428"></a><span id="l25.1428" class="difflineminus">-                                                      nsIMsgWindow *aMsgWindow, </span>
<a href="#l25.1429"></a><span id="l25.1429" class="difflineplus">+NS_IMETHODIMP nsImapService::GetListOfFoldersWithPath(nsIImapIncomingServer *aServer,</span>
<a href="#l25.1430"></a><span id="l25.1430" class="difflineplus">+                                                      nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.1431"></a><span id="l25.1431">                                                       const nsACString &amp;folderPath)</span>
<a href="#l25.1432"></a><span id="l25.1432"> {</span>
<a href="#l25.1433"></a><span id="l25.1433">   nsresult rv;</span>
<a href="#l25.1434"></a><span id="l25.1434">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server = do_QueryInterface(aServer);</span>
<a href="#l25.1435"></a><span id="l25.1435" class="difflineminus">-  if (!server) </span>
<a href="#l25.1436"></a><span id="l25.1436" class="difflineplus">+  if (!server)</span>
<a href="#l25.1437"></a><span id="l25.1437">     return NS_ERROR_FAILURE;</span>
<a href="#l25.1438"></a><span id="l25.1438"> </span>
<a href="#l25.1439"></a><span id="l25.1439">   nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l25.1440"></a><span id="l25.1440">   rv = server-&gt;GetRootMsgFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l25.1441"></a><span id="l25.1441"> </span>
<a href="#l25.1442"></a><span id="l25.1442">   NS_ENSURE_TRUE(NS_SUCCEEDED(rv) &amp;&amp; rootMsgFolder, NS_ERROR_FAILURE);</span>
<a href="#l25.1443"></a><span id="l25.1443"> </span>
<a href="#l25.1444"></a><span id="l25.1444">   nsCOMPtr&lt;nsIUrlListener&gt; listener = do_QueryInterface(aServer, &amp;rv);</span>
<a href="#l25.1445"></a><span id="l25.1445">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1446"></a><span id="l25.1446" class="difflineminus">-  if (!listener) </span>
<a href="#l25.1447"></a><span id="l25.1447" class="difflineplus">+  if (!listener)</span>
<a href="#l25.1448"></a><span id="l25.1448">     return NS_ERROR_FAILURE;</span>
<a href="#l25.1449"></a><span id="l25.1449"> </span>
<a href="#l25.1450"></a><span id="l25.1450">   // Locate the folder so that the correct hierarchical delimiter is used in the folder</span>
<a href="#l25.1451"></a><span id="l25.1451">   // pathnames, otherwise root's (ie, '^') is used and this is wrong.</span>
<a href="#l25.1452"></a><span id="l25.1452">   nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l25.1453"></a><span id="l25.1453">   if (rootMsgFolder &amp;&amp; !folderPath.IsEmpty())</span>
<a href="#l25.1454"></a><span id="l25.1454">   {</span>
<a href="#l25.1455"></a><span id="l25.1455">     // If the folder path contains 'INBOX' of any forms, we need to convert it to uppercase</span>
<a href="#l25.1456"></a><span id="l25.1456" class="difflineat">@@ -3008,60 +3008,60 @@ NS_IMETHODIMP nsImapService::GetListOfFo</span>
<a href="#l25.1457"></a><span id="l25.1457">       tokenStr.Assign(tempFolderName);</span>
<a href="#l25.1458"></a><span id="l25.1458"> </span>
<a href="#l25.1459"></a><span id="l25.1459">     if (tokenStr.LowerCaseEqualsLiteral(&quot;inbox&quot;) &amp;&amp;</span>
<a href="#l25.1460"></a><span id="l25.1460">         !tokenStr.EqualsLiteral(&quot;INBOX&quot;))</span>
<a href="#l25.1461"></a><span id="l25.1461">       changedStr.AppendLiteral(&quot;INBOX&quot;);</span>
<a href="#l25.1462"></a><span id="l25.1462">     else</span>
<a href="#l25.1463"></a><span id="l25.1463">       changedStr.Append(tokenStr);</span>
<a href="#l25.1464"></a><span id="l25.1464"> </span>
<a href="#l25.1465"></a><span id="l25.1465" class="difflineminus">-    if (slashPos &gt; 0 ) </span>
<a href="#l25.1466"></a><span id="l25.1466" class="difflineplus">+    if (slashPos &gt; 0 )</span>
<a href="#l25.1467"></a><span id="l25.1467">       changedStr.Append(remStr);</span>
<a href="#l25.1468"></a><span id="l25.1468"> </span>
<a href="#l25.1469"></a><span id="l25.1469">     rv = rootMsgFolder-&gt;FindSubFolder(changedStr, getter_AddRefs(msgFolder));</span>
<a href="#l25.1470"></a><span id="l25.1470">   }</span>
<a href="#l25.1471"></a><span id="l25.1471">   return DiscoverChildren(msgFolder, listener, folderPath, nullptr);</span>
<a href="#l25.1472"></a><span id="l25.1472"> }</span>
<a href="#l25.1473"></a><span id="l25.1473"> </span>
<a href="#l25.1474"></a><span id="l25.1474" class="difflineminus">-NS_IMETHODIMP nsImapService::GetListOfFoldersOnServer(nsIImapIncomingServer *aServer, </span>
<a href="#l25.1475"></a><span id="l25.1475" class="difflineplus">+NS_IMETHODIMP nsImapService::GetListOfFoldersOnServer(nsIImapIncomingServer *aServer,</span>
<a href="#l25.1476"></a><span id="l25.1476">                                                       nsIMsgWindow *aMsgWindow)</span>
<a href="#l25.1477"></a><span id="l25.1477"> {</span>
<a href="#l25.1478"></a><span id="l25.1478">   nsresult rv;</span>
<a href="#l25.1479"></a><span id="l25.1479"> </span>
<a href="#l25.1480"></a><span id="l25.1480">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server = do_QueryInterface(aServer);</span>
<a href="#l25.1481"></a><span id="l25.1481" class="difflineminus">-  if (!server) </span>
<a href="#l25.1482"></a><span id="l25.1482" class="difflineplus">+  if (!server)</span>
<a href="#l25.1483"></a><span id="l25.1483">     return NS_ERROR_FAILURE;</span>
<a href="#l25.1484"></a><span id="l25.1484"> </span>
<a href="#l25.1485"></a><span id="l25.1485">   nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l25.1486"></a><span id="l25.1486">   rv = server-&gt;GetRootMsgFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l25.1487"></a><span id="l25.1487"> </span>
<a href="#l25.1488"></a><span id="l25.1488">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1489"></a><span id="l25.1489" class="difflineminus">-  if (!rootMsgFolder) </span>
<a href="#l25.1490"></a><span id="l25.1490" class="difflineplus">+  if (!rootMsgFolder)</span>
<a href="#l25.1491"></a><span id="l25.1491">     return NS_ERROR_FAILURE;</span>
<a href="#l25.1492"></a><span id="l25.1492"> </span>
<a href="#l25.1493"></a><span id="l25.1493">   nsCOMPtr&lt;nsIUrlListener&gt; listener = do_QueryInterface(aServer, &amp;rv);</span>
<a href="#l25.1494"></a><span id="l25.1494">   NS_ENSURE_TRUE(NS_SUCCEEDED(rv) &amp;&amp; listener, NS_ERROR_FAILURE);</span>
<a href="#l25.1495"></a><span id="l25.1495"> </span>
<a href="#l25.1496"></a><span id="l25.1496">   return DiscoverAllAndSubscribedFolders(rootMsgFolder, listener, nullptr);</span>
<a href="#l25.1497"></a><span id="l25.1497" class="difflineminus">-} </span>
<a href="#l25.1498"></a><span id="l25.1498" class="difflineplus">+}</span>
<a href="#l25.1499"></a><span id="l25.1499"> </span>
<a href="#l25.1500"></a><span id="l25.1500"> NS_IMETHODIMP nsImapService::SubscribeFolder(nsIMsgFolder *aFolder,</span>
<a href="#l25.1501"></a><span id="l25.1501" class="difflineminus">-                                             const nsAString &amp;aFolderName, </span>
<a href="#l25.1502"></a><span id="l25.1502" class="difflineminus">-                                             nsIUrlListener *urlListener, </span>
<a href="#l25.1503"></a><span id="l25.1503" class="difflineplus">+                                             const nsAString &amp;aFolderName,</span>
<a href="#l25.1504"></a><span id="l25.1504" class="difflineplus">+                                             nsIUrlListener *urlListener,</span>
<a href="#l25.1505"></a><span id="l25.1505">                                              nsIURI **url)</span>
<a href="#l25.1506"></a><span id="l25.1506"> {</span>
<a href="#l25.1507"></a><span id="l25.1507"> </span>
<a href="#l25.1508"></a><span id="l25.1508" class="difflineminus">-  return ChangeFolderSubscription(aFolder, aFolderName, </span>
<a href="#l25.1509"></a><span id="l25.1509" class="difflineplus">+  return ChangeFolderSubscription(aFolder, aFolderName,</span>
<a href="#l25.1510"></a><span id="l25.1510">                                   &quot;/subscribe&gt;&quot;, urlListener, url);</span>
<a href="#l25.1511"></a><span id="l25.1511"> }</span>
<a href="#l25.1512"></a><span id="l25.1512"> </span>
<a href="#l25.1513"></a><span id="l25.1513"> nsresult nsImapService::ChangeFolderSubscription(nsIMsgFolder *folder,</span>
<a href="#l25.1514"></a><span id="l25.1514" class="difflineminus">-                                                 const nsAString &amp;folderName, </span>
<a href="#l25.1515"></a><span id="l25.1515" class="difflineplus">+                                                 const nsAString &amp;folderName,</span>
<a href="#l25.1516"></a><span id="l25.1516">                                                  const char *command,</span>
<a href="#l25.1517"></a><span id="l25.1517" class="difflineminus">-                                                 nsIUrlListener *urlListener, </span>
<a href="#l25.1518"></a><span id="l25.1518" class="difflineplus">+                                                 nsIUrlListener *urlListener,</span>
<a href="#l25.1519"></a><span id="l25.1519">                                                  nsIURI **url)</span>
<a href="#l25.1520"></a><span id="l25.1520"> {</span>
<a href="#l25.1521"></a><span id="l25.1521">   NS_ENSURE_ARG_POINTER(folder);</span>
<a href="#l25.1522"></a><span id="l25.1522"> </span>
<a href="#l25.1523"></a><span id="l25.1523">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.1524"></a><span id="l25.1524">   nsAutoCString urlSpec;</span>
<a href="#l25.1525"></a><span id="l25.1525">   nsresult rv;</span>
<a href="#l25.1526"></a><span id="l25.1526">   char hierarchyDelimiter = GetHierarchyDelimiter(folder);</span>
<a href="#l25.1527"></a><span id="l25.1527" class="difflineat">@@ -3085,18 +3085,18 @@ nsresult nsImapService::ChangeFolderSubs</span>
<a href="#l25.1528"></a><span id="l25.1528">       if (NS_SUCCEEDED(rv))</span>
<a href="#l25.1529"></a><span id="l25.1529">         rv = GetImapConnectionAndLoadUrl(imapUrl, nullptr, url);</span>
<a href="#l25.1530"></a><span id="l25.1530">     }</span>
<a href="#l25.1531"></a><span id="l25.1531">   }</span>
<a href="#l25.1532"></a><span id="l25.1532">   return rv;</span>
<a href="#l25.1533"></a><span id="l25.1533"> }</span>
<a href="#l25.1534"></a><span id="l25.1534"> </span>
<a href="#l25.1535"></a><span id="l25.1535"> NS_IMETHODIMP nsImapService::UnsubscribeFolder(nsIMsgFolder *aFolder,</span>
<a href="#l25.1536"></a><span id="l25.1536" class="difflineminus">-                                               const nsAString &amp;aFolderName, </span>
<a href="#l25.1537"></a><span id="l25.1537" class="difflineminus">-                                               nsIUrlListener *aUrlListener, </span>
<a href="#l25.1538"></a><span id="l25.1538" class="difflineplus">+                                               const nsAString &amp;aFolderName,</span>
<a href="#l25.1539"></a><span id="l25.1539" class="difflineplus">+                                               nsIUrlListener *aUrlListener,</span>
<a href="#l25.1540"></a><span id="l25.1540">                                                nsIURI **aUrl)</span>
<a href="#l25.1541"></a><span id="l25.1541"> {</span>
<a href="#l25.1542"></a><span id="l25.1542"> </span>
<a href="#l25.1543"></a><span id="l25.1543">   return ChangeFolderSubscription(aFolder, aFolderName,</span>
<a href="#l25.1544"></a><span id="l25.1544">                                   &quot;/unsubscribe&gt;&quot;, aUrlListener, aUrl);</span>
<a href="#l25.1545"></a><span id="l25.1545"> }</span>
<a href="#l25.1546"></a><span id="l25.1546"> </span>
<a href="#l25.1547"></a><span id="l25.1547"> NS_IMETHODIMP nsImapService::GetFolderAdminUrl(nsIMsgFolder *aImapMailFolder,</span>
<a href="#l25.1548"></a><span id="l25.1548" class="difflineat">@@ -3165,17 +3165,17 @@ NS_IMETHODIMP nsImapService::FetchCustom</span>
<a href="#l25.1549"></a><span id="l25.1549"> {</span>
<a href="#l25.1550"></a><span id="l25.1550">   NS_ENSURE_ARG_POINTER(anImapFolder);</span>
<a href="#l25.1551"></a><span id="l25.1551">   NS_ENSURE_ARG_POINTER(aMsgWindow);</span>
<a href="#l25.1552"></a><span id="l25.1552"> </span>
<a href="#l25.1553"></a><span id="l25.1553">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.1554"></a><span id="l25.1554">   nsAutoCString urlSpec;</span>
<a href="#l25.1555"></a><span id="l25.1555">   nsresult rv;</span>
<a href="#l25.1556"></a><span id="l25.1556">   char hierarchyDelimiter = GetHierarchyDelimiter(anImapFolder);</span>
<a href="#l25.1557"></a><span id="l25.1557" class="difflineminus">-  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), anImapFolder, </span>
<a href="#l25.1558"></a><span id="l25.1558" class="difflineplus">+  rv = CreateStartOfImapUrl(EmptyCString(), getter_AddRefs(imapUrl), anImapFolder,</span>
<a href="#l25.1559"></a><span id="l25.1559">                             nullptr, urlSpec, hierarchyDelimiter);</span>
<a href="#l25.1560"></a><span id="l25.1560">   if (NS_SUCCEEDED(rv) &amp;&amp; imapUrl)</span>
<a href="#l25.1561"></a><span id="l25.1561">   {</span>
<a href="#l25.1562"></a><span id="l25.1562">     // nsImapUrl::SetSpec() will set the imap action properly</span>
<a href="#l25.1563"></a><span id="l25.1563">     rv = imapUrl-&gt;SetImapAction(nsIImapUrl::nsImapUserDefinedFetchAttribute);</span>
<a href="#l25.1564"></a><span id="l25.1564"> </span>
<a href="#l25.1565"></a><span id="l25.1565">     nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailNewsUrl = do_QueryInterface(imapUrl);</span>
<a href="#l25.1566"></a><span id="l25.1566">     mailNewsUrl-&gt;SetMsgWindow(aMsgWindow);</span>
<a href="#l25.1567"></a><span id="l25.1567" class="difflineat">@@ -3245,19 +3245,19 @@ NS_IMETHODIMP nsImapService::StoreCustom</span>
<a href="#l25.1568"></a><span id="l25.1568">         rv = GetImapConnectionAndLoadUrl(imapUrl, nullptr, aURL);</span>
<a href="#l25.1569"></a><span id="l25.1569">     }</span>
<a href="#l25.1570"></a><span id="l25.1570">   } // if we have a url to run....</span>
<a href="#l25.1571"></a><span id="l25.1571"> </span>
<a href="#l25.1572"></a><span id="l25.1572">   return rv;</span>
<a href="#l25.1573"></a><span id="l25.1573"> }</span>
<a href="#l25.1574"></a><span id="l25.1574"> </span>
<a href="#l25.1575"></a><span id="l25.1575"> </span>
<a href="#l25.1576"></a><span id="l25.1576" class="difflineminus">-NS_IMETHODIMP nsImapService::DownloadMessagesForOffline(const nsACString &amp;messageIds, </span>
<a href="#l25.1577"></a><span id="l25.1577" class="difflineminus">-                                                        nsIMsgFolder *aFolder, </span>
<a href="#l25.1578"></a><span id="l25.1578" class="difflineminus">-                                                        nsIUrlListener *aUrlListener, </span>
<a href="#l25.1579"></a><span id="l25.1579" class="difflineplus">+NS_IMETHODIMP nsImapService::DownloadMessagesForOffline(const nsACString &amp;messageIds,</span>
<a href="#l25.1580"></a><span id="l25.1580" class="difflineplus">+                                                        nsIMsgFolder *aFolder,</span>
<a href="#l25.1581"></a><span id="l25.1581" class="difflineplus">+                                                        nsIUrlListener *aUrlListener,</span>
<a href="#l25.1582"></a><span id="l25.1582">                                                         nsIMsgWindow *aMsgWindow)</span>
<a href="#l25.1583"></a><span id="l25.1583"> {</span>
<a href="#l25.1584"></a><span id="l25.1584">   NS_ENSURE_ARG_POINTER(aFolder);</span>
<a href="#l25.1585"></a><span id="l25.1585"> </span>
<a href="#l25.1586"></a><span id="l25.1586">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl;</span>
<a href="#l25.1587"></a><span id="l25.1587">   nsAutoCString urlSpec;</span>
<a href="#l25.1588"></a><span id="l25.1588">   nsresult rv;</span>
<a href="#l25.1589"></a><span id="l25.1589">   char hierarchyDelimiter = GetHierarchyDelimiter(aFolder);</span>
<a href="#l25.1590"></a><span id="l25.1590" class="difflineat">@@ -3295,35 +3295,35 @@ NS_IMETHODIMP nsImapService::MessageURIT</span>
<a href="#l25.1591"></a><span id="l25.1591">                                  getter_AddRefs(folder), &amp;msgKey);</span>
<a href="#l25.1592"></a><span id="l25.1592">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l25.1593"></a><span id="l25.1593">   rv = folder-&gt;GetMessageHeader(msgKey, aRetVal);</span>
<a href="#l25.1594"></a><span id="l25.1594">   NS_ENSURE_SUCCESS(rv,rv);</span>
<a href="#l25.1595"></a><span id="l25.1595"> </span>
<a href="#l25.1596"></a><span id="l25.1596">   return NS_OK;</span>
<a href="#l25.1597"></a><span id="l25.1597"> }</span>
<a href="#l25.1598"></a><span id="l25.1598"> </span>
<a href="#l25.1599"></a><span id="l25.1599" class="difflineminus">-NS_IMETHODIMP nsImapService::PlaybackAllOfflineOperations(nsIMsgWindow *aMsgWindow, </span>
<a href="#l25.1600"></a><span id="l25.1600" class="difflineminus">-                                                          nsIUrlListener *aListener, </span>
<a href="#l25.1601"></a><span id="l25.1601" class="difflineplus">+NS_IMETHODIMP nsImapService::PlaybackAllOfflineOperations(nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.1602"></a><span id="l25.1602" class="difflineplus">+                                                          nsIUrlListener *aListener,</span>
<a href="#l25.1603"></a><span id="l25.1603">                                                           nsISupports **aResult)</span>
<a href="#l25.1604"></a><span id="l25.1604"> {</span>
<a href="#l25.1605"></a><span id="l25.1605">   NS_ENSURE_ARG_POINTER(aResult);</span>
<a href="#l25.1606"></a><span id="l25.1606"> </span>
<a href="#l25.1607"></a><span id="l25.1607">   nsresult rv;</span>
<a href="#l25.1608"></a><span id="l25.1608">   nsImapOfflineSync *goOnline = new nsImapOfflineSync(aMsgWindow, aListener, nullptr);</span>
<a href="#l25.1609"></a><span id="l25.1609">   if (goOnline)</span>
<a href="#l25.1610"></a><span id="l25.1610">   {</span>
<a href="#l25.1611"></a><span id="l25.1611" class="difflineminus">-    rv = goOnline-&gt;QueryInterface(NS_GET_IID(nsISupports), (void **) aResult); </span>
<a href="#l25.1612"></a><span id="l25.1612" class="difflineplus">+    rv = goOnline-&gt;QueryInterface(NS_GET_IID(nsISupports), (void **) aResult);</span>
<a href="#l25.1613"></a><span id="l25.1613">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1614"></a><span id="l25.1614">     if (NS_SUCCEEDED(rv) &amp;&amp; *aResult)</span>
<a href="#l25.1615"></a><span id="l25.1615">       return goOnline-&gt;ProcessNextOperation();</span>
<a href="#l25.1616"></a><span id="l25.1616">   }</span>
<a href="#l25.1617"></a><span id="l25.1617">   return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l25.1618"></a><span id="l25.1618"> }</span>
<a href="#l25.1619"></a><span id="l25.1619"> </span>
<a href="#l25.1620"></a><span id="l25.1620" class="difflineminus">-NS_IMETHODIMP nsImapService::DownloadAllOffineImapFolders(nsIMsgWindow *aMsgWindow, </span>
<a href="#l25.1621"></a><span id="l25.1621" class="difflineplus">+NS_IMETHODIMP nsImapService::DownloadAllOffineImapFolders(nsIMsgWindow *aMsgWindow,</span>
<a href="#l25.1622"></a><span id="l25.1622">                                                           nsIUrlListener *aListener)</span>
<a href="#l25.1623"></a><span id="l25.1623"> {</span>
<a href="#l25.1624"></a><span id="l25.1624">   RefPtr&lt;nsImapOfflineDownloader&gt; downloadForOffline = new nsImapOfflineDownloader(aMsgWindow, aListener);</span>
<a href="#l25.1625"></a><span id="l25.1625">   if (downloadForOffline)</span>
<a href="#l25.1626"></a><span id="l25.1626">   {</span>
<a href="#l25.1627"></a><span id="l25.1627">     // hold reference to this so it won't get deleted out from under itself.</span>
<a href="#l25.1628"></a><span id="l25.1628">     nsresult rv = downloadForOffline-&gt;ProcessNextOperation();</span>
<a href="#l25.1629"></a><span id="l25.1629">     return rv;</span>
<a href="#l25.1630"></a><span id="l25.1630" class="difflineat">@@ -3346,18 +3346,18 @@ NS_IMETHODIMP nsImapService::GetCacheSto</span>
<a href="#l25.1631"></a><span id="l25.1631">     rv = cacheStorageService-&gt;MemoryCacheStorage(lci, getter_AddRefs(mCacheStorage));</span>
<a href="#l25.1632"></a><span id="l25.1632">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1633"></a><span id="l25.1633">   }</span>
<a href="#l25.1634"></a><span id="l25.1634"> </span>
<a href="#l25.1635"></a><span id="l25.1635">   NS_IF_ADDREF(*result = mCacheStorage);</span>
<a href="#l25.1636"></a><span id="l25.1636">   return rv;</span>
<a href="#l25.1637"></a><span id="l25.1637"> }</span>
<a href="#l25.1638"></a><span id="l25.1638"> </span>
<a href="#l25.1639"></a><span id="l25.1639" class="difflineminus">-NS_IMETHODIMP nsImapService::HandleContent(const char *aContentType, </span>
<a href="#l25.1640"></a><span id="l25.1640" class="difflineminus">-                                           nsIInterfaceRequestor *aWindowContext, </span>
<a href="#l25.1641"></a><span id="l25.1641" class="difflineplus">+NS_IMETHODIMP nsImapService::HandleContent(const char *aContentType,</span>
<a href="#l25.1642"></a><span id="l25.1642" class="difflineplus">+                                           nsIInterfaceRequestor *aWindowContext,</span>
<a href="#l25.1643"></a><span id="l25.1643">                                            nsIRequest *request)</span>
<a href="#l25.1644"></a><span id="l25.1644"> {</span>
<a href="#l25.1645"></a><span id="l25.1645">   NS_ENSURE_ARG_POINTER(request);</span>
<a href="#l25.1646"></a><span id="l25.1646"> </span>
<a href="#l25.1647"></a><span id="l25.1647">   nsresult rv;</span>
<a href="#l25.1648"></a><span id="l25.1648">   nsCOMPtr&lt;nsIChannel&gt; aChannel = do_QueryInterface(request, &amp;rv);</span>
<a href="#l25.1649"></a><span id="l25.1649">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1650"></a><span id="l25.1650"> </span>
<a href="#l25.1651"></a><span id="l25.1651" class="difflineat">@@ -3381,17 +3381,17 @@ NS_IMETHODIMP nsImapService::HandleConte</span>
<a href="#l25.1652"></a><span id="l25.1652">       nsCString unescapedUriStr;</span>
<a href="#l25.1653"></a><span id="l25.1653">       MsgUnescapeString(uriStr, 0, unescapedUriStr);</span>
<a href="#l25.1654"></a><span id="l25.1654">       nsCOMPtr &lt;nsIMessengerWindowService&gt; messengerWindowService = do_GetService(NS_MESSENGERWINDOWSERVICE_CONTRACTID,&amp;rv);</span>
<a href="#l25.1655"></a><span id="l25.1655">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1656"></a><span id="l25.1656"> </span>
<a href="#l25.1657"></a><span id="l25.1657">       rv = messengerWindowService-&gt;OpenMessengerWindowWithUri(&quot;mail:3pane&quot;, unescapedUriStr.get(), nsMsgKey_None);</span>
<a href="#l25.1658"></a><span id="l25.1658">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l25.1659"></a><span id="l25.1659">     }</span>
<a href="#l25.1660"></a><span id="l25.1660" class="difflineminus">-  } </span>
<a href="#l25.1661"></a><span id="l25.1661" class="difflineminus">-  else </span>
<a href="#l25.1662"></a><span id="l25.1662" class="difflineplus">+  }</span>
<a href="#l25.1663"></a><span id="l25.1663" class="difflineplus">+  else</span>
<a href="#l25.1664"></a><span id="l25.1664">   {</span>
<a href="#l25.1665"></a><span id="l25.1665">     // The content-type was not x-application-imapfolder</span>
<a href="#l25.1666"></a><span id="l25.1666">     return NS_ERROR_WONT_HANDLE_CONTENT;</span>
<a href="#l25.1667"></a><span id="l25.1667">   }</span>
<a href="#l25.1668"></a><span id="l25.1668"> </span>
<a href="#l25.1669"></a><span id="l25.1669">   return rv;</span>
<a href="#l25.1670"></a><span id="l25.1670"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/imap/src/nsImapService.h</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapService.h</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -44,20 +44,20 @@ protected:</span>
<a href="#l26.4"></a><span id="l26.4">   virtual ~nsImapService();</span>
<a href="#l26.5"></a><span id="l26.5">   char GetHierarchyDelimiter(nsIMsgFolder *aMsgFolder);</span>
<a href="#l26.6"></a><span id="l26.6"> </span>
<a href="#l26.7"></a><span id="l26.7">   nsresult GetFolderName(nsIMsgFolder *aImapFolder, nsACString &amp;aFolderName);</span>
<a href="#l26.8"></a><span id="l26.8"> </span>
<a href="#l26.9"></a><span id="l26.9">   // This is called by both FetchMessage and StreamMessage</span>
<a href="#l26.10"></a><span id="l26.10">   nsresult GetMessageFromUrl(nsIImapUrl *aImapUrl,</span>
<a href="#l26.11"></a><span id="l26.11">                              nsImapAction aImapAction,</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-                             nsIMsgFolder *aImapMailFolder, </span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+                             nsIMsgFolder *aImapMailFolder,</span>
<a href="#l26.14"></a><span id="l26.14">                              nsIImapMessageSink *aImapMessage,</span>
<a href="#l26.15"></a><span id="l26.15">                              nsIMsgWindow *aMsgWindow,</span>
<a href="#l26.16"></a><span id="l26.16" class="difflineminus">-                             nsISupports *aDisplayConsumer, </span>
<a href="#l26.17"></a><span id="l26.17" class="difflineplus">+                             nsISupports *aDisplayConsumer,</span>
<a href="#l26.18"></a><span id="l26.18">                              bool aConvertDataToText,</span>
<a href="#l26.19"></a><span id="l26.19">                              nsIURI **aURL);</span>
<a href="#l26.20"></a><span id="l26.20"> </span>
<a href="#l26.21"></a><span id="l26.21">   nsresult CreateStartOfImapUrl(const nsACString &amp;aImapURI,  // a RDF URI for the current message/folder, can be empty</span>
<a href="#l26.22"></a><span id="l26.22">                                 nsIImapUrl  **imapUrl,</span>
<a href="#l26.23"></a><span id="l26.23">                                 nsIMsgFolder *aImapFolder,</span>
<a href="#l26.24"></a><span id="l26.24">                                 nsIUrlListener *aUrlListener,</span>
<a href="#l26.25"></a><span id="l26.25">                                 nsACString &amp;urlSpec,</span>
<a href="#l26.26"></a><span id="l26.26" class="difflineat">@@ -66,20 +66,20 @@ protected:</span>
<a href="#l26.27"></a><span id="l26.27">   nsresult GetImapConnectionAndLoadUrl(nsIImapUrl *aImapUrl,</span>
<a href="#l26.28"></a><span id="l26.28">                                        nsISupports *aConsumer,</span>
<a href="#l26.29"></a><span id="l26.29">                                        nsIURI **aURL);</span>
<a href="#l26.30"></a><span id="l26.30"> </span>
<a href="#l26.31"></a><span id="l26.31">   nsresult SetImapUrlSink(nsIMsgFolder *aMsgFolder, nsIImapUrl *aImapUrl);</span>
<a href="#l26.32"></a><span id="l26.32"> </span>
<a href="#l26.33"></a><span id="l26.33">   nsresult FetchMimePart(nsIImapUrl *aImapUrl,</span>
<a href="#l26.34"></a><span id="l26.34">                          nsImapAction aImapAction,</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineminus">-                         nsIMsgFolder *aImapMailFolder, </span>
<a href="#l26.36"></a><span id="l26.36" class="difflineplus">+                         nsIMsgFolder *aImapMailFolder,</span>
<a href="#l26.37"></a><span id="l26.37">                          nsIImapMessageSink *aImapMessage,</span>
<a href="#l26.38"></a><span id="l26.38">                          nsIURI **aURL,</span>
<a href="#l26.39"></a><span id="l26.39" class="difflineminus">-                         nsISupports *aDisplayConsumer, </span>
<a href="#l26.40"></a><span id="l26.40" class="difflineplus">+                         nsISupports *aDisplayConsumer,</span>
<a href="#l26.41"></a><span id="l26.41">                          const nsACString &amp;messageIdentifierList,</span>
<a href="#l26.42"></a><span id="l26.42">                          const nsACString &amp;mimePart);</span>
<a href="#l26.43"></a><span id="l26.43"> </span>
<a href="#l26.44"></a><span id="l26.44">   nsresult FolderCommand(nsIMsgFolder *imapMailFolder,</span>
<a href="#l26.45"></a><span id="l26.45">                          nsIUrlListener *urlListener,</span>
<a href="#l26.46"></a><span id="l26.46">                          const char *aCommand,</span>
<a href="#l26.47"></a><span id="l26.47">                          nsImapAction imapAction,</span>
<a href="#l26.48"></a><span id="l26.48">                          nsIMsgWindow *msgWindow,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/mailnews/imap/src/nsImapStringBundle.cpp</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapStringBundle.cpp</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -10,17 +10,17 @@</span>
<a href="#l27.4"></a><span id="l27.4"> #include &quot;nsImapStringBundle.h&quot;</span>
<a href="#l27.5"></a><span id="l27.5"> #include &quot;nsIServiceManager.h&quot;</span>
<a href="#l27.6"></a><span id="l27.6"> #include &quot;nsIURI.h&quot;</span>
<a href="#l27.7"></a><span id="l27.7"> #include &quot;nsServiceManagerUtils.h&quot;</span>
<a href="#l27.8"></a><span id="l27.8"> #include &quot;mozilla/Services.h&quot;</span>
<a href="#l27.9"></a><span id="l27.9"> </span>
<a href="#l27.10"></a><span id="l27.10"> #define IMAP_MSGS_URL       &quot;chrome://messenger/locale/imapMsgs.properties&quot;</span>
<a href="#l27.11"></a><span id="l27.11"> </span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-extern &quot;C&quot; </span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+extern &quot;C&quot;</span>
<a href="#l27.14"></a><span id="l27.14"> nsresult</span>
<a href="#l27.15"></a><span id="l27.15"> IMAPGetStringByName(const char* stringName, char16_t **aString)</span>
<a href="#l27.16"></a><span id="l27.16"> {</span>
<a href="#l27.17"></a><span id="l27.17">   nsCOMPtr &lt;nsIStringBundle&gt; sBundle;</span>
<a href="#l27.18"></a><span id="l27.18">   nsresult rv = IMAPGetStringBundle(getter_AddRefs(sBundle));</span>
<a href="#l27.19"></a><span id="l27.19">   if (NS_SUCCEEDED(rv) &amp;&amp; sBundle) {</span>
<a href="#l27.20"></a><span id="l27.20">     nsAutoString string;</span>
<a href="#l27.21"></a><span id="l27.21">     rv = sBundle-&gt;GetStringFromName(stringName, string);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/mailnews/imap/src/nsImapUndoTxn.cpp</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapUndoTxn.cpp</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -100,27 +100,27 @@ nsImapMoveCopyMsgTxn::UndoTransaction(vo</span>
<a href="#l28.4"></a><span id="l28.4">     if (m_srcIsPop3)</span>
<a href="#l28.5"></a><span id="l28.5">     {</span>
<a href="#l28.6"></a><span id="l28.6">       rv = UndoMailboxDelete();</span>
<a href="#l28.7"></a><span id="l28.7">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.8"></a><span id="l28.8">     }</span>
<a href="#l28.9"></a><span id="l28.9">     else</span>
<a href="#l28.10"></a><span id="l28.10">     {</span>
<a href="#l28.11"></a><span id="l28.11">       nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder = do_QueryReferent(m_srcFolder, &amp;rv);</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-      if (NS_FAILED(rv) || !srcFolder) </span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+      if (NS_FAILED(rv) || !srcFolder)</span>
<a href="#l28.14"></a><span id="l28.14">         return rv;</span>
<a href="#l28.15"></a><span id="l28.15">       nsCOMPtr&lt;nsIUrlListener&gt; srcListener = do_QueryInterface(srcFolder, &amp;rv);</span>
<a href="#l28.16"></a><span id="l28.16" class="difflineminus">-      if (NS_FAILED(rv)) </span>
<a href="#l28.17"></a><span id="l28.17" class="difflineplus">+      if (NS_FAILED(rv))</span>
<a href="#l28.18"></a><span id="l28.18">         return rv;</span>
<a href="#l28.19"></a><span id="l28.19">       m_onStopListener =   do_GetWeakReference(srcListener);</span>
<a href="#l28.20"></a><span id="l28.20"> </span>
<a href="#l28.21"></a><span id="l28.21">       // ** make sure we are in the selected state; use lite select</span>
<a href="#l28.22"></a><span id="l28.22">       // folder so we won't hit performance hard</span>
<a href="#l28.23"></a><span id="l28.23">       rv = imapService-&gt;LiteSelectFolder(srcFolder, srcListener, nullptr, nullptr);</span>
<a href="#l28.24"></a><span id="l28.24" class="difflineminus">-      if (NS_FAILED(rv)) </span>
<a href="#l28.25"></a><span id="l28.25" class="difflineplus">+      if (NS_FAILED(rv))</span>
<a href="#l28.26"></a><span id="l28.26">         return rv;</span>
<a href="#l28.27"></a><span id="l28.27">       bool deletedMsgs = true; //default is true unless imapDelete model</span>
<a href="#l28.28"></a><span id="l28.28">       nsMsgImapDeleteModel deleteModel;</span>
<a href="#l28.29"></a><span id="l28.29">       rv = GetImapDeleteModel(srcFolder, &amp;deleteModel);</span>
<a href="#l28.30"></a><span id="l28.30"> </span>
<a href="#l28.31"></a><span id="l28.31">       // protect against a bogus undo txn without any source keys</span>
<a href="#l28.32"></a><span id="l28.32">       // see bug #179856 for details</span>
<a href="#l28.33"></a><span id="l28.33">       NS_ASSERTION(!m_srcKeyArray.IsEmpty(), &quot;no source keys&quot;);</span>
<a href="#l28.34"></a><span id="l28.34" class="difflineat">@@ -130,26 +130,26 @@ nsImapMoveCopyMsgTxn::UndoTransaction(vo</span>
<a href="#l28.35"></a><span id="l28.35">       if (!m_srcMsgIdString.IsEmpty())</span>
<a href="#l28.36"></a><span id="l28.36">       {</span>
<a href="#l28.37"></a><span id="l28.37">         if (NS_SUCCEEDED(rv) &amp;&amp; deleteModel == nsMsgImapDeleteModels::IMAPDelete)</span>
<a href="#l28.38"></a><span id="l28.38">           CheckForToggleDelete(srcFolder, m_srcKeyArray[0], &amp;deletedMsgs);</span>
<a href="#l28.39"></a><span id="l28.39"> </span>
<a href="#l28.40"></a><span id="l28.40">         if (deletedMsgs)</span>
<a href="#l28.41"></a><span id="l28.41">           rv = imapService-&gt;SubtractMessageFlags(srcFolder,</span>
<a href="#l28.42"></a><span id="l28.42">                                                  this, nullptr,</span>
<a href="#l28.43"></a><span id="l28.43" class="difflineminus">-                                                 m_srcMsgIdString, </span>
<a href="#l28.44"></a><span id="l28.44" class="difflineplus">+                                                 m_srcMsgIdString,</span>
<a href="#l28.45"></a><span id="l28.45">                                                  kImapMsgDeletedFlag,</span>
<a href="#l28.46"></a><span id="l28.46">                                                  m_idsAreUids);</span>
<a href="#l28.47"></a><span id="l28.47">         else</span>
<a href="#l28.48"></a><span id="l28.48">           rv = imapService-&gt;AddMessageFlags(srcFolder,</span>
<a href="#l28.49"></a><span id="l28.49">                                             srcListener, nullptr,</span>
<a href="#l28.50"></a><span id="l28.50">                                             m_srcMsgIdString,</span>
<a href="#l28.51"></a><span id="l28.51">                                             kImapMsgDeletedFlag,</span>
<a href="#l28.52"></a><span id="l28.52">                                             m_idsAreUids);</span>
<a href="#l28.53"></a><span id="l28.53" class="difflineminus">-        if (NS_FAILED(rv)) </span>
<a href="#l28.54"></a><span id="l28.54" class="difflineplus">+        if (NS_FAILED(rv))</span>
<a href="#l28.55"></a><span id="l28.55">           return rv;</span>
<a href="#l28.56"></a><span id="l28.56"> </span>
<a href="#l28.57"></a><span id="l28.57">         finishInOnStopRunningUrl = true;</span>
<a href="#l28.58"></a><span id="l28.58">         if (deleteModel != nsMsgImapDeleteModels::IMAPDelete)</span>
<a href="#l28.59"></a><span id="l28.59">           rv = imapService-&gt;GetHeaders(srcFolder, srcListener, nullptr,</span>
<a href="#l28.60"></a><span id="l28.60">                                        m_srcMsgIdString, true);</span>
<a href="#l28.61"></a><span id="l28.61">       }</span>
<a href="#l28.62"></a><span id="l28.62">     }</span>
<a href="#l28.63"></a><span id="l28.63" class="difflineat">@@ -165,17 +165,17 @@ nsImapMoveCopyMsgTxn::UndoTransaction(vo</span>
<a href="#l28.64"></a><span id="l28.64">     dstListener = do_QueryInterface(dstFolder, &amp;rv);</span>
<a href="#l28.65"></a><span id="l28.65">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.66"></a><span id="l28.66">     // ** make sure we are in the selected state; use lite select folder</span>
<a href="#l28.67"></a><span id="l28.67">     // so we won't potentially download a bunch of headers.</span>
<a href="#l28.68"></a><span id="l28.68">     rv = imapService-&gt;LiteSelectFolder(dstFolder,</span>
<a href="#l28.69"></a><span id="l28.69">       dstListener, nullptr, nullptr);</span>
<a href="#l28.70"></a><span id="l28.70">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.71"></a><span id="l28.71">     rv = imapService-&gt;AddMessageFlags(dstFolder, dstListener,</span>
<a href="#l28.72"></a><span id="l28.72" class="difflineminus">-                                      nullptr, m_dstMsgIdString, </span>
<a href="#l28.73"></a><span id="l28.73" class="difflineplus">+                                      nullptr, m_dstMsgIdString,</span>
<a href="#l28.74"></a><span id="l28.74">                                       kImapMsgDeletedFlag, m_idsAreUids);</span>
<a href="#l28.75"></a><span id="l28.75">   }</span>
<a href="#l28.76"></a><span id="l28.76">   return rv;</span>
<a href="#l28.77"></a><span id="l28.77"> }</span>
<a href="#l28.78"></a><span id="l28.78"> </span>
<a href="#l28.79"></a><span id="l28.79"> NS_IMETHODIMP</span>
<a href="#l28.80"></a><span id="l28.80"> nsImapMoveCopyMsgTxn::RedoTransaction(void)</span>
<a href="#l28.81"></a><span id="l28.81"> {</span>
<a href="#l28.82"></a><span id="l28.82" class="difflineat">@@ -188,34 +188,34 @@ nsImapMoveCopyMsgTxn::RedoTransaction(vo</span>
<a href="#l28.83"></a><span id="l28.83">     if (m_srcIsPop3)</span>
<a href="#l28.84"></a><span id="l28.84">     {</span>
<a href="#l28.85"></a><span id="l28.85">       rv = RedoMailboxDelete();</span>
<a href="#l28.86"></a><span id="l28.86">       if (NS_FAILED(rv)) return rv;</span>
<a href="#l28.87"></a><span id="l28.87">     }</span>
<a href="#l28.88"></a><span id="l28.88">     else if (!m_srcMsgIdString.IsEmpty())</span>
<a href="#l28.89"></a><span id="l28.89">     {</span>
<a href="#l28.90"></a><span id="l28.90">       nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder = do_QueryReferent(m_srcFolder, &amp;rv);</span>
<a href="#l28.91"></a><span id="l28.91" class="difflineminus">-      if (NS_FAILED(rv) || !srcFolder) </span>
<a href="#l28.92"></a><span id="l28.92" class="difflineplus">+      if (NS_FAILED(rv) || !srcFolder)</span>
<a href="#l28.93"></a><span id="l28.93">         return rv;</span>
<a href="#l28.94"></a><span id="l28.94">       nsCOMPtr&lt;nsIUrlListener&gt; srcListener = do_QueryInterface(srcFolder, &amp;rv);</span>
<a href="#l28.95"></a><span id="l28.95">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.96"></a><span id="l28.96"> </span>
<a href="#l28.97"></a><span id="l28.97">       bool deletedMsgs = false;  //default will be false unless imapDeleteModel;</span>
<a href="#l28.98"></a><span id="l28.98">       nsMsgImapDeleteModel deleteModel;</span>
<a href="#l28.99"></a><span id="l28.99">       rv = GetImapDeleteModel(srcFolder, &amp;deleteModel);</span>
<a href="#l28.100"></a><span id="l28.100" class="difflineminus">-      </span>
<a href="#l28.101"></a><span id="l28.101" class="difflineplus">+</span>
<a href="#l28.102"></a><span id="l28.102">       // protect against a bogus undo txn without any source keys</span>
<a href="#l28.103"></a><span id="l28.103">       // see bug #179856 for details</span>
<a href="#l28.104"></a><span id="l28.104">       NS_ASSERTION(!m_srcKeyArray.IsEmpty(), &quot;no source keys&quot;);</span>
<a href="#l28.105"></a><span id="l28.105">       if (m_srcKeyArray.IsEmpty())</span>
<a href="#l28.106"></a><span id="l28.106">         return NS_ERROR_UNEXPECTED;</span>
<a href="#l28.107"></a><span id="l28.107" class="difflineminus">-      </span>
<a href="#l28.108"></a><span id="l28.108" class="difflineplus">+</span>
<a href="#l28.109"></a><span id="l28.109">       if (NS_SUCCEEDED(rv) &amp;&amp; deleteModel == nsMsgImapDeleteModels::IMAPDelete)</span>
<a href="#l28.110"></a><span id="l28.110">         rv = CheckForToggleDelete(srcFolder, m_srcKeyArray[0], &amp;deletedMsgs);</span>
<a href="#l28.111"></a><span id="l28.111" class="difflineminus">-      </span>
<a href="#l28.112"></a><span id="l28.112" class="difflineplus">+</span>
<a href="#l28.113"></a><span id="l28.113">       // Make sure we are in the selected state; use lite select</span>
<a href="#l28.114"></a><span id="l28.114">       // folder so performance won't suffer.</span>
<a href="#l28.115"></a><span id="l28.115">       rv = imapService-&gt;LiteSelectFolder(srcFolder, srcListener, nullptr, nullptr);</span>
<a href="#l28.116"></a><span id="l28.116">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.117"></a><span id="l28.117">       if (deletedMsgs)</span>
<a href="#l28.118"></a><span id="l28.118">       {</span>
<a href="#l28.119"></a><span id="l28.119">         rv = imapService-&gt;SubtractMessageFlags(srcFolder,</span>
<a href="#l28.120"></a><span id="l28.120">                                                srcListener, nullptr,</span>
<a href="#l28.121"></a><span id="l28.121" class="difflineat">@@ -233,33 +233,33 @@ nsImapMoveCopyMsgTxn::RedoTransaction(vo</span>
<a href="#l28.122"></a><span id="l28.122">   }</span>
<a href="#l28.123"></a><span id="l28.123">   if (!m_dstMsgIdString.IsEmpty())</span>
<a href="#l28.124"></a><span id="l28.124">   {</span>
<a href="#l28.125"></a><span id="l28.125">     nsCOMPtr&lt;nsIMsgFolder&gt; dstFolder = do_QueryReferent(m_dstFolder, &amp;rv);</span>
<a href="#l28.126"></a><span id="l28.126">     if (NS_FAILED(rv) || !dstFolder) return rv;</span>
<a href="#l28.127"></a><span id="l28.127"> </span>
<a href="#l28.128"></a><span id="l28.128">     nsCOMPtr&lt;nsIUrlListener&gt; dstListener;</span>
<a href="#l28.129"></a><span id="l28.129"> </span>
<a href="#l28.130"></a><span id="l28.130" class="difflineminus">-    dstListener = do_QueryInterface(dstFolder, &amp;rv); </span>
<a href="#l28.131"></a><span id="l28.131" class="difflineplus">+    dstListener = do_QueryInterface(dstFolder, &amp;rv);</span>
<a href="#l28.132"></a><span id="l28.132">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.133"></a><span id="l28.133">     // ** make sure we are in the selected state; use lite select</span>
<a href="#l28.134"></a><span id="l28.134">     // folder so we won't hit performance hard</span>
<a href="#l28.135"></a><span id="l28.135">     rv = imapService-&gt;LiteSelectFolder(dstFolder, dstListener, nullptr, nullptr);</span>
<a href="#l28.136"></a><span id="l28.136">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.137"></a><span id="l28.137">     rv = imapService-&gt;SubtractMessageFlags(dstFolder,</span>
<a href="#l28.138"></a><span id="l28.138">                                            dstListener, nullptr,</span>
<a href="#l28.139"></a><span id="l28.139">                                            m_dstMsgIdString,</span>
<a href="#l28.140"></a><span id="l28.140">                                            kImapMsgDeletedFlag,</span>
<a href="#l28.141"></a><span id="l28.141">                                            m_idsAreUids);</span>
<a href="#l28.142"></a><span id="l28.142">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.143"></a><span id="l28.143">     nsMsgImapDeleteModel deleteModel;</span>
<a href="#l28.144"></a><span id="l28.144">     rv = GetImapDeleteModel(dstFolder, &amp;deleteModel);</span>
<a href="#l28.145"></a><span id="l28.145">     if (NS_FAILED(rv) || deleteModel == nsMsgImapDeleteModels::MoveToTrash)</span>
<a href="#l28.146"></a><span id="l28.146">     {</span>
<a href="#l28.147"></a><span id="l28.147" class="difflineminus">-      rv = imapService-&gt;GetHeaders(dstFolder, dstListener, </span>
<a href="#l28.148"></a><span id="l28.148" class="difflineplus">+      rv = imapService-&gt;GetHeaders(dstFolder, dstListener,</span>
<a href="#l28.149"></a><span id="l28.149">                                    nullptr, m_dstMsgIdString, true);</span>
<a href="#l28.150"></a><span id="l28.150">     }</span>
<a href="#l28.151"></a><span id="l28.151">   }</span>
<a href="#l28.152"></a><span id="l28.152">   return rv;</span>
<a href="#l28.153"></a><span id="l28.153"> }</span>
<a href="#l28.154"></a><span id="l28.154"> </span>
<a href="#l28.155"></a><span id="l28.155"> nsresult</span>
<a href="#l28.156"></a><span id="l28.156"> nsImapMoveCopyMsgTxn::SetCopyResponseUid(const char* aMsgIdString)</span>
<a href="#l28.157"></a><span id="l28.157" class="difflineat">@@ -304,17 +304,17 @@ nsImapMoveCopyMsgTxn::UndoMailboxDelete(</span>
<a href="#l28.158"></a><span id="l28.158">         if (NS_FAILED(rv) || !dstFolder) return rv;</span>
<a href="#l28.159"></a><span id="l28.159"> </span>
<a href="#l28.160"></a><span id="l28.160">         nsCOMPtr&lt;nsIMsgDatabase&gt; srcDB;</span>
<a href="#l28.161"></a><span id="l28.161">         nsCOMPtr&lt;nsIMsgDatabase&gt; dstDB;</span>
<a href="#l28.162"></a><span id="l28.162">         rv = srcFolder-&gt;GetMsgDatabase(getter_AddRefs(srcDB));</span>
<a href="#l28.163"></a><span id="l28.163">         if (NS_FAILED(rv)) return rv;</span>
<a href="#l28.164"></a><span id="l28.164">         rv = dstFolder-&gt;GetMsgDatabase(getter_AddRefs(dstDB));</span>
<a href="#l28.165"></a><span id="l28.165">         if (NS_FAILED(rv)) return rv;</span>
<a href="#l28.166"></a><span id="l28.166" class="difflineminus">-        </span>
<a href="#l28.167"></a><span id="l28.167" class="difflineplus">+</span>
<a href="#l28.168"></a><span id="l28.168">         uint32_t count = m_srcKeyArray.Length();</span>
<a href="#l28.169"></a><span id="l28.169">         uint32_t i;</span>
<a href="#l28.170"></a><span id="l28.170">         nsCOMPtr&lt;nsIMsgDBHdr&gt; oldHdr;</span>
<a href="#l28.171"></a><span id="l28.171">         nsCOMPtr&lt;nsIMsgDBHdr&gt; newHdr;</span>
<a href="#l28.172"></a><span id="l28.172">         for (i = 0; i &lt; count; i++)</span>
<a href="#l28.173"></a><span id="l28.173">         {</span>
<a href="#l28.174"></a><span id="l28.174">             oldHdr = m_srcHdrs[i];</span>
<a href="#l28.175"></a><span id="l28.175">             NS_ASSERTION(oldHdr, &quot;fatal ... cannot get old msg header\n&quot;);</span>
<a href="#l28.176"></a><span id="l28.176" class="difflineat">@@ -532,17 +532,17 @@ nsImapOfflineTxn::~nsImapOfflineTxn()</span>
<a href="#l28.177"></a><span id="l28.177"> // Open the database and find the key for the offline operation that we want to</span>
<a href="#l28.178"></a><span id="l28.178"> // undo, then remove it from the database, we also hold on to this</span>
<a href="#l28.179"></a><span id="l28.179"> // data for a redo operation.</span>
<a href="#l28.180"></a><span id="l28.180"> NS_IMETHODIMP nsImapOfflineTxn::UndoTransaction(void)</span>
<a href="#l28.181"></a><span id="l28.181"> {</span>
<a href="#l28.182"></a><span id="l28.182">   nsresult rv;</span>
<a href="#l28.183"></a><span id="l28.183"> </span>
<a href="#l28.184"></a><span id="l28.184">   nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder = do_QueryReferent(m_srcFolder, &amp;rv);</span>
<a href="#l28.185"></a><span id="l28.185" class="difflineminus">-  if (NS_FAILED(rv) || !srcFolder) </span>
<a href="#l28.186"></a><span id="l28.186" class="difflineplus">+  if (NS_FAILED(rv) || !srcFolder)</span>
<a href="#l28.187"></a><span id="l28.187">     return rv;</span>
<a href="#l28.188"></a><span id="l28.188">   nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; op;</span>
<a href="#l28.189"></a><span id="l28.189">   nsCOMPtr &lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l28.190"></a><span id="l28.190">   nsCOMPtr &lt;nsIMsgDatabase&gt; srcDB;</span>
<a href="#l28.191"></a><span id="l28.191">   nsCOMPtr &lt;nsIMsgDatabase&gt; destDB;</span>
<a href="#l28.192"></a><span id="l28.192"> </span>
<a href="#l28.193"></a><span id="l28.193">   rv = srcFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), getter_AddRefs(srcDB));</span>
<a href="#l28.194"></a><span id="l28.194">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.195"></a><span id="l28.195" class="difflineat">@@ -626,19 +626,19 @@ NS_IMETHODIMP nsImapOfflineTxn::UndoTran</span>
<a href="#l28.196"></a><span id="l28.196">   srcDB-&gt;Close(true);</span>
<a href="#l28.197"></a><span id="l28.197">   srcFolder-&gt;SummaryChanged();</span>
<a href="#l28.198"></a><span id="l28.198">   return NS_OK;</span>
<a href="#l28.199"></a><span id="l28.199"> }</span>
<a href="#l28.200"></a><span id="l28.200"> </span>
<a href="#l28.201"></a><span id="l28.201"> NS_IMETHODIMP nsImapOfflineTxn::RedoTransaction(void)</span>
<a href="#l28.202"></a><span id="l28.202"> {</span>
<a href="#l28.203"></a><span id="l28.203">   nsresult rv;</span>
<a href="#l28.204"></a><span id="l28.204" class="difflineminus">-  </span>
<a href="#l28.205"></a><span id="l28.205" class="difflineplus">+</span>
<a href="#l28.206"></a><span id="l28.206">   nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder = do_QueryReferent(m_srcFolder, &amp;rv);</span>
<a href="#l28.207"></a><span id="l28.207" class="difflineminus">-  if (NS_FAILED(rv) || !srcFolder) </span>
<a href="#l28.208"></a><span id="l28.208" class="difflineplus">+  if (NS_FAILED(rv) || !srcFolder)</span>
<a href="#l28.209"></a><span id="l28.209">     return rv;</span>
<a href="#l28.210"></a><span id="l28.210">   nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; op;</span>
<a href="#l28.211"></a><span id="l28.211">   nsCOMPtr &lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l28.212"></a><span id="l28.212">   nsCOMPtr &lt;nsIMsgDatabase&gt; srcDB;</span>
<a href="#l28.213"></a><span id="l28.213">   nsCOMPtr &lt;nsIMsgDatabase&gt; destDB;</span>
<a href="#l28.214"></a><span id="l28.214">   rv = srcFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), getter_AddRefs(srcDB));</span>
<a href="#l28.215"></a><span id="l28.215">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l28.216"></a><span id="l28.216"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/mailnews/imap/src/nsImapUtils.h</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapUtils.h</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -24,54 +24,54 @@ static const char kDeletedHdrCountProper</span>
<a href="#l29.4"></a><span id="l29.4"> </span>
<a href="#l29.5"></a><span id="l29.5"> extern nsresult</span>
<a href="#l29.6"></a><span id="l29.6"> nsImapURI2FullName(const char* rootURI, const char* hostname, const char* uriStr,</span>
<a href="#l29.7"></a><span id="l29.7">                    char **name);</span>
<a href="#l29.8"></a><span id="l29.8"> </span>
<a href="#l29.9"></a><span id="l29.9"> extern nsresult</span>
<a href="#l29.10"></a><span id="l29.10"> nsParseImapMessageURI(const char* uri, nsCString&amp; folderURI, uint32_t *key, char **part);</span>
<a href="#l29.11"></a><span id="l29.11"> </span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-extern nsresult </span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+extern nsresult</span>
<a href="#l29.14"></a><span id="l29.14"> nsBuildImapMessageURI(const char *baseURI, uint32_t key, nsCString&amp; uri);</span>
<a href="#l29.15"></a><span id="l29.15"> </span>
<a href="#l29.16"></a><span id="l29.16"> extern nsresult</span>
<a href="#l29.17"></a><span id="l29.17"> nsCreateImapBaseMessageURI(const nsACString&amp; baseURI, nsCString&amp; baseMessageURI);</span>
<a href="#l29.18"></a><span id="l29.18"> </span>
<a href="#l29.19"></a><span id="l29.19"> void AllocateImapUidString(uint32_t *msgUids, uint32_t &amp;msgCount, nsImapFlagAndUidState *flagState, nsCString &amp;returnString);</span>
<a href="#l29.20"></a><span id="l29.20"> void ParseUidString(const char *uidString, nsTArray&lt;nsMsgKey&gt; &amp;keys);</span>
<a href="#l29.21"></a><span id="l29.21"> void AppendUid(nsCString &amp;msgIds, uint32_t uid);</span>
<a href="#l29.22"></a><span id="l29.22"> </span>
<a href="#l29.23"></a><span id="l29.23"> class nsImapMailboxSpec : public nsIMailboxSpec</span>
<a href="#l29.24"></a><span id="l29.24"> {</span>
<a href="#l29.25"></a><span id="l29.25"> public:</span>
<a href="#l29.26"></a><span id="l29.26">   nsImapMailboxSpec();</span>
<a href="#l29.27"></a><span id="l29.27" class="difflineminus">-  </span>
<a href="#l29.28"></a><span id="l29.28" class="difflineplus">+</span>
<a href="#l29.29"></a><span id="l29.29">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l29.30"></a><span id="l29.30">   NS_DECL_NSIMAILBOXSPEC</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineminus">-    </span>
<a href="#l29.32"></a><span id="l29.32" class="difflineplus">+</span>
<a href="#l29.33"></a><span id="l29.33">   nsImapMailboxSpec&amp; operator= (const nsImapMailboxSpec&amp; aCopy);</span>
<a href="#l29.34"></a><span id="l29.34" class="difflineminus">-  </span>
<a href="#l29.35"></a><span id="l29.35" class="difflineplus">+</span>
<a href="#l29.36"></a><span id="l29.36">   nsCOMPtr&lt;nsIImapFlagAndUidState&gt; mFlagState;</span>
<a href="#l29.37"></a><span id="l29.37" class="difflineminus">-  nsIMAPNamespace                  *mNamespaceForFolder;  </span>
<a href="#l29.38"></a><span id="l29.38" class="difflineminus">-  </span>
<a href="#l29.39"></a><span id="l29.39" class="difflineplus">+  nsIMAPNamespace                  *mNamespaceForFolder;</span>
<a href="#l29.40"></a><span id="l29.40" class="difflineplus">+</span>
<a href="#l29.41"></a><span id="l29.41">   uint32_t  mBoxFlags;</span>
<a href="#l29.42"></a><span id="l29.42">   uint32_t  mSupportedUserFlags;</span>
<a href="#l29.43"></a><span id="l29.43">   int32_t   mFolder_UIDVALIDITY;</span>
<a href="#l29.44"></a><span id="l29.44">   uint64_t  mHighestModSeq;</span>
<a href="#l29.45"></a><span id="l29.45">   int32_t   mNumOfMessages;</span>
<a href="#l29.46"></a><span id="l29.46">   int32_t   mNumOfUnseenMessages;</span>
<a href="#l29.47"></a><span id="l29.47">   int32_t   mNumOfRecentMessages;</span>
<a href="#l29.48"></a><span id="l29.48">   int32_t   mNextUID;</span>
<a href="#l29.49"></a><span id="l29.49">   nsCString mAllocatedPathName;</span>
<a href="#l29.50"></a><span id="l29.50">   nsCString mHostName;</span>
<a href="#l29.51"></a><span id="l29.51">   nsString  mUnicharPathName;</span>
<a href="#l29.52"></a><span id="l29.52">   char      mHierarchySeparator;</span>
<a href="#l29.53"></a><span id="l29.53">   bool      mFolderSelected;</span>
<a href="#l29.54"></a><span id="l29.54">   bool      mDiscoveredFromLsub;</span>
<a href="#l29.55"></a><span id="l29.55">   bool      mOnlineVerified;</span>
<a href="#l29.56"></a><span id="l29.56" class="difflineminus">-  </span>
<a href="#l29.57"></a><span id="l29.57" class="difflineplus">+</span>
<a href="#l29.58"></a><span id="l29.58">   nsImapProtocol *mConnection;	// do we need this? It seems evil</span>
<a href="#l29.59"></a><span id="l29.59"> </span>
<a href="#l29.60"></a><span id="l29.60"> private:</span>
<a href="#l29.61"></a><span id="l29.61">   virtual ~nsImapMailboxSpec();</span>
<a href="#l29.62"></a><span id="l29.62"> };</span>
<a href="#l29.63"></a><span id="l29.63"> </span>
<a href="#l29.64"></a><span id="l29.64"> #endif //NS_IMAPUTILS_H</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

