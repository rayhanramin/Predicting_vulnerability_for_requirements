<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 842:65e54c7a5fe0704129c2dbb3fb46a7ba01d24629</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 65e54c7a5fe0704129c2dbb3fb46a7ba01d24629" />
<meta property="og:url" content="/comm-central/rev/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629" />
<meta property="og:description" content="status commit: end of day." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 65e54c7a5fe0704129c2dbb3fb46a7ba01d24629 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629">shortlog</a> |
<a href="/comm-central/log/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629">files</a> |
changeset |
<a href="/comm-central/raw-rev/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629">raw</a>  | <a href="/comm-central/archive/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
status commit: end of day.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 13 Jul 2008 21:03:53 -0700</td></tr>

<tr>
 <td>changeset 842</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629">65e54c7a5fe0704129c2dbb3fb46a7ba01d24629</a></td>
</tr>



<tr>
<td>parent 841</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/8161aff784b04d9b38c9b09aba8741e4700b54b5">8161aff784b04d9b38c9b09aba8741e4700b54b5</a>
</td>
</tr>

<tr>
<td>child 843</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/08c1108dcb03447af0a8bc9ce26a2bb94f7cc675">08c1108dcb03447af0a8bc9ce26a2bb94f7cc675</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=65e54c7a5fe0704129c2dbb3fb46a7ba01d24629">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">status commit: end of day.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/explattr.js">modules/explattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/explattr.js">file</a> |
<a href="/comm-central/annotate/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/explattr.js">annotate</a> |
<a href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/explattr.js">diff</a> |
<a href="/comm-central/comparison/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/explattr.js">comparison</a> |
<a href="/comm-central/log/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/explattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/65e54c7a5fe0704129c2dbb3fb46a7ba01d24629/modules/indexer.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -114,93 +114,118 @@ GlodaConversation.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">       this._messages = this._datastore.getMessagesByConversationID(this._id,</span>
<a href="#l1.5"></a><span id="l1.5">                                                                    false);</span>
<a href="#l1.6"></a><span id="l1.6">     }</span>
<a href="#l1.7"></a><span id="l1.7">     return this._messages;</span>
<a href="#l1.8"></a><span id="l1.8">   }</span>
<a href="#l1.9"></a><span id="l1.9"> };</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-function GlodaMessage(aDatastore, aID, aFolderID, aFolderURI, aMessageKey,</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-                      aConversationID, aConversation, aParentID,</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+function GlodaMessage(aDatastore, aID, aFolderID, aMessageKey,</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+                      aConversationID, aConversation,</span>
<a href="#l1.16"></a><span id="l1.16">                       aHeaderMessageID, aBodySnippet) {</span>
<a href="#l1.17"></a><span id="l1.17">   this._datastore = aDatastore;</span>
<a href="#l1.18"></a><span id="l1.18">   this._id = aID;</span>
<a href="#l1.19"></a><span id="l1.19">   this._folderID = aFolderID;</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineminus">-  this._folderURI = aFolderURI;</span>
<a href="#l1.21"></a><span id="l1.21">   this._messageKey = aMessageKey;</span>
<a href="#l1.22"></a><span id="l1.22">   this._conversationID = aConversationID;</span>
<a href="#l1.23"></a><span id="l1.23">   this._conversation = aConversation;</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineminus">-  this._parentID = aParentID;</span>
<a href="#l1.25"></a><span id="l1.25">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l1.26"></a><span id="l1.26">   this._bodySnippet = aBodySnippet;</span>
<a href="#l1.27"></a><span id="l1.27"> </span>
<a href="#l1.28"></a><span id="l1.28">   // for now, let's always cache this; they should really be forgetting about us</span>
<a href="#l1.29"></a><span id="l1.29">   //  if they want to forget about the underlying storage anyways...</span>
<a href="#l1.30"></a><span id="l1.30">   this._folderMessage = null;</span>
<a href="#l1.31"></a><span id="l1.31">   this._attributes = null;</span>
<a href="#l1.32"></a><span id="l1.32"> }</span>
<a href="#l1.33"></a><span id="l1.33"> </span>
<a href="#l1.34"></a><span id="l1.34"> GlodaMessage.prototype = {</span>
<a href="#l1.35"></a><span id="l1.35">   get id() { return this._id; },</span>
<a href="#l1.36"></a><span id="l1.36">   get folderID() { return this._folderID; },</span>
<a href="#l1.37"></a><span id="l1.37">   get messageKey() { return this._messageKey; },</span>
<a href="#l1.38"></a><span id="l1.38">   get conversationID() { return this._conversationID; },</span>
<a href="#l1.39"></a><span id="l1.39">   // conversation is special</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-  get parentID() { return this._parentID; },</span>
<a href="#l1.41"></a><span id="l1.41">   get headerMessageID() { return this._headerMessageID; },</span>
<a href="#l1.42"></a><span id="l1.42">   get bodySnippet() { return this._bodySnippet; },</span>
<a href="#l1.43"></a><span id="l1.43"> </span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+  get folderURI() {</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+    if (this._folderID)</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+      return this._datastore._mapFolderID(this._folderID);</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+    else</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+      return null;</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+  },</span>
<a href="#l1.50"></a><span id="l1.50">   get conversation() {</span>
<a href="#l1.51"></a><span id="l1.51">     if (this._conversation == null) {</span>
<a href="#l1.52"></a><span id="l1.52">       this._conversation = this._datastore.getConversationByID(</span>
<a href="#l1.53"></a><span id="l1.53">         this._conversationID);</span>
<a href="#l1.54"></a><span id="l1.54">     }</span>
<a href="#l1.55"></a><span id="l1.55">     return this._conversation;</span>
<a href="#l1.56"></a><span id="l1.56">   },</span>
<a href="#l1.57"></a><span id="l1.57"> </span>
<a href="#l1.58"></a><span id="l1.58">   set messageKey(aMessageKey) { this._messageKey = aMessageKey; },</span>
<a href="#l1.59"></a><span id="l1.59">   set folderURI(aFolderURI) {</span>
<a href="#l1.60"></a><span id="l1.60">     this._folderID = this._datastore._mapFolderURI(aFolderURI);</span>
<a href="#l1.61"></a><span id="l1.61">   },</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineminus">-</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+  </span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+  _ghost: function gloda_message_ghost() {</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+    this._folderID = null;</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+    this._messageKey = null;</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+  },</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+  </span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+  _nuke: function gloda_message_nuke() {</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+    this._id = null;</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineplus">+    this._folderID = null;</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineplus">+    this._messageKey = null;</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineplus">+    this._conversationID = null;</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+    this._conversation = null;</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+    this._headerMessageID = null;</span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+    this._bodySnippet = null;</span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+    </span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+    this._datastore = null;</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+  },</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+  </span>
<a href="#l1.81"></a><span id="l1.81">   /**</span>
<a href="#l1.82"></a><span id="l1.82">    * Return the underlying nsIMsgDBHdr from the folder storage for this, or</span>
<a href="#l1.83"></a><span id="l1.83">    *  null if the message does not exist for one reason or another.</span>
<a href="#l1.84"></a><span id="l1.84">    */</span>
<a href="#l1.85"></a><span id="l1.85">   get folderMessage() {</span>
<a href="#l1.86"></a><span id="l1.86">     if (this._folderMessage != null)</span>
<a href="#l1.87"></a><span id="l1.87">       return this._folderMessage;</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineminus">-    if (this._folderURI == null || this._messageKey == null)</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineplus">+    if (this._folderID == null || this._messageKey == null)</span>
<a href="#l1.90"></a><span id="l1.90">       return null;</span>
<a href="#l1.91"></a><span id="l1.91"> </span>
<a href="#l1.92"></a><span id="l1.92">     let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l1.93"></a><span id="l1.93">                      getService(Ci.nsIRDFService);</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineminus">-    let folder = rdfService.GetResource(this._folderURI);</span>
<a href="#l1.95"></a><span id="l1.95" class="difflineplus">+    let folder = rdfService.GetResource(this.folderURI);</span>
<a href="#l1.96"></a><span id="l1.96">     if (folder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l1.97"></a><span id="l1.97">       this._folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineplus">+      if (this._folderMessage != null) {</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+        // verify the message-id header matches what we expect...</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+        if (this._folderMessage.messageId != this._headerMessageId)</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+          this._folderMessage = null;</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+      }</span>
<a href="#l1.103"></a><span id="l1.103">       return this._folderMessage;</span>
<a href="#l1.104"></a><span id="l1.104">     }</span>
<a href="#l1.105"></a><span id="l1.105"> </span>
<a href="#l1.106"></a><span id="l1.106" class="difflineminus">-    throw &quot;Unable to locate folder message for: &quot; + this._folderURI + &quot;:&quot; +</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineminus">-          this._messageKey;</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineplus">+    // this only gets logged if things have gone very wrong.  we used to throw</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+    //  here, but it's unlikely our caller can do anything more meaningful than</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+    //  treating this as a disappeared message.</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+    LOG.error(&quot;Unable to locate folder message for: &quot; + this._folderID + &quot;:&quot; +</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineplus">+              this._messageKey);</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineplus">+    return null;</span>
<a href="#l1.114"></a><span id="l1.114">   },</span>
<a href="#l1.115"></a><span id="l1.115">   </span>
<a href="#l1.116"></a><span id="l1.116">   get attributes() {</span>
<a href="#l1.117"></a><span id="l1.117">     if (this._attributes == null) {</span>
<a href="#l1.118"></a><span id="l1.118">       this._attributes = this._datastore.getMessageAttributes(this); </span>
<a href="#l1.119"></a><span id="l1.119">     }</span>
<a href="#l1.120"></a><span id="l1.120">     </span>
<a href="#l1.121"></a><span id="l1.121">     return this._attributes;</span>
<a href="#l1.122"></a><span id="l1.122">   },</span>
<a href="#l1.123"></a><span id="l1.123">   </span>
<a href="#l1.124"></a><span id="l1.124" class="difflineminus">-  clearAttributes: function gloda_message_clearAttributes() {</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineminus">-    this._datastore.clearMessageAttributes(this);</span>
<a href="#l1.126"></a><span id="l1.126" class="difflineminus">-  },</span>
<a href="#l1.127"></a><span id="l1.127" class="difflineminus">-  </span>
<a href="#l1.128"></a><span id="l1.128">   getAttributeInstances: function gloda_message_getAttributeInstances(aAttr) {</span>
<a href="#l1.129"></a><span id="l1.129">     return [attrParamVal for each (attrParamVal in this.attributes) if</span>
<a href="#l1.130"></a><span id="l1.130">             (attrParamVal[0] == aAttr)];</span>
<a href="#l1.131"></a><span id="l1.131">   },</span>
<a href="#l1.132"></a><span id="l1.132">   </span>
<a href="#l1.133"></a><span id="l1.133">   getSingleAttribute: function gloda_message_getSingleAttribute(aAttr) {</span>
<a href="#l1.134"></a><span id="l1.134">     let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l1.135"></a><span id="l1.135">     if (instances.length &gt; 0)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -51,17 +51,17 @@ Cu.import(&quot;resource://gloda/modules/log4</span>
<a href="#l2.4"></a><span id="l2.4"> </span>
<a href="#l2.5"></a><span id="l2.5"> Cu.import(&quot;resource://gloda/modules/datamodel.js&quot;);</span>
<a href="#l2.6"></a><span id="l2.6"> </span>
<a href="#l2.7"></a><span id="l2.7"> let GlodaDatastore = {</span>
<a href="#l2.8"></a><span id="l2.8">   _log: null,</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10">   /* ******************* SCHEMA ******************* */</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  _schemaVersion: 3,</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  _schemaVersion: 4,</span>
<a href="#l2.14"></a><span id="l2.14">   _schema: {</span>
<a href="#l2.15"></a><span id="l2.15">     tables: {</span>
<a href="#l2.16"></a><span id="l2.16">       </span>
<a href="#l2.17"></a><span id="l2.17">       // ----- Messages</span>
<a href="#l2.18"></a><span id="l2.18">       folderLocations: {</span>
<a href="#l2.19"></a><span id="l2.19">         columns: [</span>
<a href="#l2.20"></a><span id="l2.20">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l2.21"></a><span id="l2.21">           &quot;folderURI TEXT&quot;,</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -100,17 +100,19 @@ let GlodaDatastore = {</span>
<a href="#l2.23"></a><span id="l2.23">        *  sentinel values if this somehow impacts performance.</span>
<a href="#l2.24"></a><span id="l2.24">        */</span>
<a href="#l2.25"></a><span id="l2.25">       messages: {</span>
<a href="#l2.26"></a><span id="l2.26">         columns: [</span>
<a href="#l2.27"></a><span id="l2.27">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l2.28"></a><span id="l2.28">           &quot;folderID INTEGER REFERENCES folderLocations(id)&quot;,</span>
<a href="#l2.29"></a><span id="l2.29">           &quot;messageKey INTEGER&quot;,</span>
<a href="#l2.30"></a><span id="l2.30">           &quot;conversationID INTEGER NOT NULL REFERENCES conversations(id)&quot;,</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-          &quot;parentID INTEGER REFERENCES messages(id)&quot;,</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+          // we used to have the parentID, but because of the very real</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+          //  possibility of multiple copies of a message with a given</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+          //  message-id, the parentID concept is unreliable.</span>
<a href="#l2.35"></a><span id="l2.35">           &quot;headerMessageID TEXT&quot;,</span>
<a href="#l2.36"></a><span id="l2.36">           &quot;bodySnippet TEXT&quot;,</span>
<a href="#l2.37"></a><span id="l2.37">         ],</span>
<a href="#l2.38"></a><span id="l2.38">         </span>
<a href="#l2.39"></a><span id="l2.39">         indices: {</span>
<a href="#l2.40"></a><span id="l2.40">           messageLocation: ['folderID', 'messageKey'],</span>
<a href="#l2.41"></a><span id="l2.41">           headerMessageID: ['headerMessageID'],</span>
<a href="#l2.42"></a><span id="l2.42">           conversationID: ['conversationID'],</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineat">@@ -126,19 +128,19 @@ let GlodaDatastore = {</span>
<a href="#l2.44"></a><span id="l2.44">         columns: [</span>
<a href="#l2.45"></a><span id="l2.45">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l2.46"></a><span id="l2.46">           &quot;attributeType INTEGER&quot;,</span>
<a href="#l2.47"></a><span id="l2.47">           &quot;extensionName TEXT&quot;,</span>
<a href="#l2.48"></a><span id="l2.48">           &quot;name TEXT&quot;,</span>
<a href="#l2.49"></a><span id="l2.49">           &quot;parameter BLOB&quot;,</span>
<a href="#l2.50"></a><span id="l2.50">         ],</span>
<a href="#l2.51"></a><span id="l2.51">         </span>
<a href="#l2.52"></a><span id="l2.52" class="difflineminus">-        triggers: [</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineplus">+        triggers: {</span>
<a href="#l2.54"></a><span id="l2.54">           delete: &quot;DELETE FROM messageAttributes WHERE attributeID = OLD.id&quot;,</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineminus">-        ],</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+        },</span>
<a href="#l2.57"></a><span id="l2.57">       },</span>
<a href="#l2.58"></a><span id="l2.58">       </span>
<a href="#l2.59"></a><span id="l2.59">       messageAttributes: {</span>
<a href="#l2.60"></a><span id="l2.60">         columns: [</span>
<a href="#l2.61"></a><span id="l2.61">           &quot;conversationID INTEGER NOT NULL REFERENCES conversations(id)&quot;,</span>
<a href="#l2.62"></a><span id="l2.62">           &quot;messageID INTEGER NOT NULL REFERENCES messages(id)&quot;,</span>
<a href="#l2.63"></a><span id="l2.63">           &quot;attributeID INTEGER NOT NULL REFERENCES attributeDefinitions(id)&quot;,</span>
<a href="#l2.64"></a><span id="l2.64">           &quot;value NUMERIC&quot;,</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineat">@@ -556,16 +558,31 @@ let GlodaDatastore = {</span>
<a href="#l2.66"></a><span id="l2.66">         </span>
<a href="#l2.67"></a><span id="l2.67">     ics.execute();</span>
<a href="#l2.68"></a><span id="l2.68">     </span>
<a href="#l2.69"></a><span id="l2.69">     return new GlodaConversation(this, this.dbConnection.lastInsertRowID,</span>
<a href="#l2.70"></a><span id="l2.70">                                  aSubject, aOldestMessageDate,</span>
<a href="#l2.71"></a><span id="l2.71">                                  aNewestMessageDate);</span>
<a href="#l2.72"></a><span id="l2.72">   },</span>
<a href="#l2.73"></a><span id="l2.73"> </span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+  get _deleteConversationByIDStatement() {</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+    let statement = this._createStatement(</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+      &quot;DELETE FROM conversations WHERE id = :conversationID&quot;);</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+    this.__defineGetter__(&quot;_deleteConversationByIDStatement&quot;,</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+                          function() statement);</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+    return this._deleteConversationByIDStatement; </span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+  },</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+  deleteConversationByID: function gloda_ds_deleteConversationByID(</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+                                      aConversationID) {</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+    let dcbids = this._deleteConversationByIDStatement;</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+    dcbids.params.conversationID = aConversationID;</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+    dcbids.execute();</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+  },</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+</span>
<a href="#l2.89"></a><span id="l2.89">   get _selectConversationByIDStatement() {</span>
<a href="#l2.90"></a><span id="l2.90">     let statement = this._createStatement(</span>
<a href="#l2.91"></a><span id="l2.91">       &quot;SELECT * FROM conversations WHERE id = :conversationID&quot;);</span>
<a href="#l2.92"></a><span id="l2.92">     this.__defineGetter__(&quot;_selectConversationByIDStatement&quot;, function() statement);</span>
<a href="#l2.93"></a><span id="l2.93">     return this._selectConversationByIDStatement; </span>
<a href="#l2.94"></a><span id="l2.94">   }, </span>
<a href="#l2.95"></a><span id="l2.95"> </span>
<a href="#l2.96"></a><span id="l2.96">   getConversationByID: function gloda_ds_getConversationByID(aConversationID) {</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineat">@@ -579,44 +596,41 @@ let GlodaDatastore = {</span>
<a href="#l2.98"></a><span id="l2.98">         row[&quot;subject&quot;], row[&quot;oldestMessageDate&quot;], row[&quot;newestMessageDate&quot;]);</span>
<a href="#l2.99"></a><span id="l2.99">     }</span>
<a href="#l2.100"></a><span id="l2.100">     this._selectConversationByIDStatement.reset();</span>
<a href="#l2.101"></a><span id="l2.101">     </span>
<a href="#l2.102"></a><span id="l2.102">     return conversation;</span>
<a href="#l2.103"></a><span id="l2.103">   },</span>
<a href="#l2.104"></a><span id="l2.104">   </span>
<a href="#l2.105"></a><span id="l2.105">   /* ********** Message ********** */</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineminus">-  </span>
<a href="#l2.107"></a><span id="l2.107" class="difflineminus">-  // memoizing message statement creation</span>
<a href="#l2.108"></a><span id="l2.108">   get _insertMessageStatement() {</span>
<a href="#l2.109"></a><span id="l2.109">     let statement = this._createStatement(</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineminus">-      &quot;INSERT INTO messages (folderID, messageKey, conversationID, parentID, \</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineplus">+      &quot;INSERT INTO messages (folderID, messageKey, conversationID, \</span>
<a href="#l2.112"></a><span id="l2.112">                              headerMessageID, bodySnippet) \</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineminus">-              VALUES (:folderID, :messageKey, :conversationID, :parentID, \</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineplus">+              VALUES (:folderID, :messageKey, :conversationID, \</span>
<a href="#l2.115"></a><span id="l2.115">                       :headerMessageID, :bodySnippet)&quot;);</span>
<a href="#l2.116"></a><span id="l2.116">     this.__defineGetter__(&quot;_insertMessageStatement&quot;, function() statement);</span>
<a href="#l2.117"></a><span id="l2.117">     return this._insertMessageStatement; </span>
<a href="#l2.118"></a><span id="l2.118">   }, </span>
<a href="#l2.119"></a><span id="l2.119">   </span>
<a href="#l2.120"></a><span id="l2.120">   createMessage: function gloda_ds_createMessage(aFolderURI, aMessageKey,</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineminus">-                              aConversationID, aParentID, aHeaderMessageID,</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+                              aConversationID, aHeaderMessageID,</span>
<a href="#l2.123"></a><span id="l2.123">                               aBodySnippet) {</span>
<a href="#l2.124"></a><span id="l2.124">     let folderID;</span>
<a href="#l2.125"></a><span id="l2.125">     if (aFolderURI != null) {</span>
<a href="#l2.126"></a><span id="l2.126">       folderID = this._mapFolderURI(aFolderURI);</span>
<a href="#l2.127"></a><span id="l2.127">     }</span>
<a href="#l2.128"></a><span id="l2.128">     else {</span>
<a href="#l2.129"></a><span id="l2.129">       folderID = null;</span>
<a href="#l2.130"></a><span id="l2.130">     }</span>
<a href="#l2.131"></a><span id="l2.131">     </span>
<a href="#l2.132"></a><span id="l2.132">     let ims = this._insertMessageStatement;</span>
<a href="#l2.133"></a><span id="l2.133">     ims.params.folderID = folderID;</span>
<a href="#l2.134"></a><span id="l2.134">     ims.params.messageKey = aMessageKey;</span>
<a href="#l2.135"></a><span id="l2.135">     ims.params.conversationID = aConversationID;</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineminus">-    ims.params.parentID = aParentID;</span>
<a href="#l2.137"></a><span id="l2.137">     ims.params.headerMessageID = aHeaderMessageID;</span>
<a href="#l2.138"></a><span id="l2.138">     ims.params.bodySnippet = aBodySnippet;</span>
<a href="#l2.139"></a><span id="l2.139"> </span>
<a href="#l2.140"></a><span id="l2.140">     try {</span>
<a href="#l2.141"></a><span id="l2.141">        ims.execute();</span>
<a href="#l2.142"></a><span id="l2.142">     }</span>
<a href="#l2.143"></a><span id="l2.143">     catch(ex) {</span>
<a href="#l2.144"></a><span id="l2.144">        throw(&quot;error executing statement... &quot; +</span>
<a href="#l2.145"></a><span id="l2.145" class="difflineat">@@ -631,43 +645,60 @@ let GlodaDatastore = {</span>
<a href="#l2.146"></a><span id="l2.146">                             aHeaderMessageID, aBodySnippet);</span>
<a href="#l2.147"></a><span id="l2.147">   },</span>
<a href="#l2.148"></a><span id="l2.148">   </span>
<a href="#l2.149"></a><span id="l2.149">   get _updateMessageStatement() {</span>
<a href="#l2.150"></a><span id="l2.150">     let statement = this._createStatement(</span>
<a href="#l2.151"></a><span id="l2.151">       &quot;UPDATE messages SET folderID = :folderID, \</span>
<a href="#l2.152"></a><span id="l2.152">                            messageKey = :messageKey, \</span>
<a href="#l2.153"></a><span id="l2.153">                            conversationID = :conversationID, \</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineminus">-                           parentID = :parentID, \</span>
<a href="#l2.155"></a><span id="l2.155">                            headerMessageID = :headerMessageID, \</span>
<a href="#l2.156"></a><span id="l2.156">                            bodySnippet = :bodySnippet \</span>
<a href="#l2.157"></a><span id="l2.157">               WHERE id = :id&quot;);</span>
<a href="#l2.158"></a><span id="l2.158">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l2.159"></a><span id="l2.159">     return this._updateMessageStatement; </span>
<a href="#l2.160"></a><span id="l2.160">   }, </span>
<a href="#l2.161"></a><span id="l2.161">   </span>
<a href="#l2.162"></a><span id="l2.162">   updateMessage: function gloda_ds_updateMessage(aMessage) {</span>
<a href="#l2.163"></a><span id="l2.163">     let ums = this._updateMessageStatement;</span>
<a href="#l2.164"></a><span id="l2.164">     ums.params.id = aMessage.id;</span>
<a href="#l2.165"></a><span id="l2.165">     ums.params.folderID = aMessage.folderID;</span>
<a href="#l2.166"></a><span id="l2.166">     ums.params.messageKey = aMessage.messageKey;</span>
<a href="#l2.167"></a><span id="l2.167">     ums.params.conversationID = aMessage.conversationID;</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineminus">-    ums.params.parentID = aMessage.parentID;</span>
<a href="#l2.169"></a><span id="l2.169">     ums.params.headerMessageID = aMessage.headerMessageID;</span>
<a href="#l2.170"></a><span id="l2.170">     ums.params.bodySnippet = aMessage.bodySnippet;</span>
<a href="#l2.171"></a><span id="l2.171">     </span>
<a href="#l2.172"></a><span id="l2.172">     ums.execute();</span>
<a href="#l2.173"></a><span id="l2.173">   },</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineplus">+</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineplus">+  get _updateMessageStatement() {</span>
<a href="#l2.176"></a><span id="l2.176" class="difflineplus">+    let statement = this._createStatement(</span>
<a href="#l2.177"></a><span id="l2.177" class="difflineplus">+    this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l2.178"></a><span id="l2.178" class="difflineplus">+    return this._updateMessageStatement; </span>
<a href="#l2.179"></a><span id="l2.179" class="difflineplus">+  }, </span>
<a href="#l2.180"></a><span id="l2.180" class="difflineplus">+</span>
<a href="#l2.181"></a><span id="l2.181" class="difflineplus">+  updateMessageFoldersByKeyPurging:</span>
<a href="#l2.182"></a><span id="l2.182" class="difflineplus">+      function gloda_ds_updateMessageFoldersByKeyPurging(aSrcFolderURI,</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineplus">+        aMessageKeys, aDestFolderURI) {</span>
<a href="#l2.184"></a><span id="l2.184" class="difflineplus">+    let srcFolderID = this._mapFolderURI(aSrcFolderURI);</span>
<a href="#l2.185"></a><span id="l2.185" class="difflineplus">+    let destFolderID = this._mapFolderURI(aDestFolderURI);</span>
<a href="#l2.186"></a><span id="l2.186" class="difflineplus">+    </span>
<a href="#l2.187"></a><span id="l2.187" class="difflineplus">+    let sqlStr = &quot;UPDATE messages SET folderID = :newFolderID, \</span>
<a href="#l2.188"></a><span id="l2.188" class="difflineplus">+                                      messageKey = NULL, \</span>
<a href="#l2.189"></a><span id="l2.189" class="difflineplus">+                   WHERE folderID = :id \</span>
<a href="#l2.190"></a><span id="l2.190" class="difflineplus">+                     AND messageKey IN (&quot; + messageKeys.join(&quot;, &quot;) + &quot;)&quot;);</span>
<a href="#l2.191"></a><span id="l2.191" class="difflineplus">+    let statement = this._createStatement(sqlStr);</span>
<a href="#l2.192"></a><span id="l2.192" class="difflineplus">+    statement.execute();</span>
<a href="#l2.193"></a><span id="l2.193" class="difflineplus">+  }</span>
<a href="#l2.194"></a><span id="l2.194">   </span>
<a href="#l2.195"></a><span id="l2.195">   _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l2.196"></a><span id="l2.196">     return new GlodaMessage(this, aRow[&quot;id&quot;], aRow[&quot;folderID&quot;],</span>
<a href="#l2.197"></a><span id="l2.197">                             this._mapFolderID(aRow[&quot;folderID&quot;]),</span>
<a href="#l2.198"></a><span id="l2.198">                             aRow[&quot;messageKey&quot;],</span>
<a href="#l2.199"></a><span id="l2.199">                             aRow[&quot;conversationID&quot;], null,</span>
<a href="#l2.200"></a><span id="l2.200" class="difflineminus">-                            aRow[&quot;parentID&quot;],</span>
<a href="#l2.201"></a><span id="l2.201">                             aRow[&quot;headerMessageID&quot;], aRow[&quot;bodySnippet&quot;]);</span>
<a href="#l2.202"></a><span id="l2.202">   },</span>
<a href="#l2.203"></a><span id="l2.203"> </span>
<a href="#l2.204"></a><span id="l2.204">   get _selectMessageByIDStatement() {</span>
<a href="#l2.205"></a><span id="l2.205">     let statement = this._createStatement(</span>
<a href="#l2.206"></a><span id="l2.206">       &quot;SELECT * FROM messages WHERE id = :id&quot;);</span>
<a href="#l2.207"></a><span id="l2.207">     this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l2.208"></a><span id="l2.208">       function() statement);</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineat">@@ -708,51 +739,107 @@ let GlodaDatastore = {</span>
<a href="#l2.210"></a><span id="l2.210">     this._selectMessageByLocationStatement.reset();</span>
<a href="#l2.211"></a><span id="l2.211">     </span>
<a href="#l2.212"></a><span id="l2.212">     if (message == null)</span>
<a href="#l2.213"></a><span id="l2.213">       this._log.error(&quot;Error locating message with key=&quot; + aMessageKey +</span>
<a href="#l2.214"></a><span id="l2.214">                       &quot; and URI &quot; + aFolderURI);</span>
<a href="#l2.215"></a><span id="l2.215">     </span>
<a href="#l2.216"></a><span id="l2.216">     return message;</span>
<a href="#l2.217"></a><span id="l2.217">   },</span>
<a href="#l2.218"></a><span id="l2.218" class="difflineplus">+</span>
<a href="#l2.219"></a><span id="l2.219" class="difflineplus">+  get _selectMessageIDsByFolderStatement() {</span>
<a href="#l2.220"></a><span id="l2.220" class="difflineplus">+    let statement = this._createStatement(</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineplus">+      &quot;SELECT id FROM messages WHERE folderID = :folderID&quot;);</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineplus">+    this.__defineGetter__(&quot;_selectMessageIDsByFolderStatement&quot;,</span>
<a href="#l2.223"></a><span id="l2.223" class="difflineplus">+      function() statement);</span>
<a href="#l2.224"></a><span id="l2.224" class="difflineplus">+    return this._selectMessageIDsByFolderStatement;</span>
<a href="#l2.225"></a><span id="l2.225" class="difflineplus">+  },</span>
<a href="#l2.226"></a><span id="l2.226">   </span>
<a href="#l2.227"></a><span id="l2.227" class="difflineplus">+  getMessageIDsByFolderID:</span>
<a href="#l2.228"></a><span id="l2.228" class="difflineplus">+      function gloda_ds_getMessageIDsFromFolderID(aFolderID) {</span>
<a href="#l2.229"></a><span id="l2.229" class="difflineplus">+    let messageIDs = [];</span>
<a href="#l2.230"></a><span id="l2.230" class="difflineplus">+    </span>
<a href="#l2.231"></a><span id="l2.231" class="difflineplus">+    let smidbfs = this._selectMessageIDsByFolderStatement;</span>
<a href="#l2.232"></a><span id="l2.232" class="difflineplus">+    smidbfs.params.folderID = aFolderID;</span>
<a href="#l2.233"></a><span id="l2.233" class="difflineplus">+    </span>
<a href="#l2.234"></a><span id="l2.234" class="difflineplus">+    while (smidbfs.step()) {</span>
<a href="#l2.235"></a><span id="l2.235" class="difflineplus">+      smidbfs.push(smidbfs.row[&quot;id&quot;]);</span>
<a href="#l2.236"></a><span id="l2.236" class="difflineplus">+    }</span>
<a href="#l2.237"></a><span id="l2.237" class="difflineplus">+    smidbfs.reset();</span>
<a href="#l2.238"></a><span id="l2.238" class="difflineplus">+    </span>
<a href="#l2.239"></a><span id="l2.239" class="difflineplus">+    return messageIDs;</span>
<a href="#l2.240"></a><span id="l2.240" class="difflineplus">+  },</span>
<a href="#l2.241"></a><span id="l2.241" class="difflineplus">+  </span>
<a href="#l2.242"></a><span id="l2.242" class="difflineplus">+  /**</span>
<a href="#l2.243"></a><span id="l2.243" class="difflineplus">+   * Given a list of Message-ID's, return a matching list of lists of messages</span>
<a href="#l2.244"></a><span id="l2.244" class="difflineplus">+   *  matching those Message-ID's.  So if you pass an array with three</span>
<a href="#l2.245"></a><span id="l2.245" class="difflineplus">+   *  Message-ID's [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], you would get back an array containing</span>
<a href="#l2.246"></a><span id="l2.246" class="difflineplus">+   *  3 lists, where the first list contains all the messages with a message-id</span>
<a href="#l2.247"></a><span id="l2.247" class="difflineplus">+   *  of &quot;a&quot;, and so forth.  The reason a list is returned rather than null/a</span>
<a href="#l2.248"></a><span id="l2.248" class="difflineplus">+   *  message is that we accept the reality that we have multiple copies of</span>
<a href="#l2.249"></a><span id="l2.249" class="difflineplus">+   *  messages with the same ID.</span>
<a href="#l2.250"></a><span id="l2.250" class="difflineplus">+   */</span>
<a href="#l2.251"></a><span id="l2.251">   getMessagesByMessageID: function gloda_ds_getMessagesByMessageID(aMessageIDs) {</span>
<a href="#l2.252"></a><span id="l2.252">     let msgIDToIndex = {};</span>
<a href="#l2.253"></a><span id="l2.253">     let results = [];</span>
<a href="#l2.254"></a><span id="l2.254">     for (let iID=0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l2.255"></a><span id="l2.255">       let msgID = aMessageIDs[iID];</span>
<a href="#l2.256"></a><span id="l2.256" class="difflineminus">-      results.push(null);</span>
<a href="#l2.257"></a><span id="l2.257" class="difflineplus">+      results.push([]);</span>
<a href="#l2.258"></a><span id="l2.258">       msgIDToIndex[msgID] = iID;</span>
<a href="#l2.259"></a><span id="l2.259">     } </span>
<a href="#l2.260"></a><span id="l2.260"> </span>
<a href="#l2.261"></a><span id="l2.261">     // Unfortunately, IN doesn't work with statement binding mechanisms, and</span>
<a href="#l2.262"></a><span id="l2.262">     //  a chain of ORed tests really can't be bound unless we create one per</span>
<a href="#l2.263"></a><span id="l2.263">     //  value of N (seems silly).</span>
<a href="#l2.264"></a><span id="l2.264">     let quotedIDs = [&quot;'&quot; + msgID.replace(&quot;'&quot;, &quot;\\'&quot;, &quot;g&quot;) + &quot;'&quot; for each</span>
<a href="#l2.265"></a><span id="l2.265">                      (msgID in aMessageIDs)]</span>
<a href="#l2.266"></a><span id="l2.266">     let sqlString = &quot;SELECT * FROM messages WHERE headerMessageID IN (&quot; +</span>
<a href="#l2.267"></a><span id="l2.267">                     quotedIDs + &quot;)&quot;;</span>
<a href="#l2.268"></a><span id="l2.268">     let statement = this._createStatement(sqlString);</span>
<a href="#l2.269"></a><span id="l2.269">     </span>
<a href="#l2.270"></a><span id="l2.270">     while (statement.step()) {</span>
<a href="#l2.271"></a><span id="l2.271" class="difflineminus">-      results[msgIDToIndex[statement.row[&quot;headerMessageID&quot;]]] =</span>
<a href="#l2.272"></a><span id="l2.272" class="difflineminus">-        this._messageFromRow(statement.row);</span>
<a href="#l2.273"></a><span id="l2.273" class="difflineplus">+      results[msgIDToIndex[statement.row[&quot;headerMessageID&quot;]]].push(</span>
<a href="#l2.274"></a><span id="l2.274" class="difflineplus">+        this._messageFromRow(statement.row));</span>
<a href="#l2.275"></a><span id="l2.275">     }</span>
<a href="#l2.276"></a><span id="l2.276">     statement.reset();</span>
<a href="#l2.277"></a><span id="l2.277">     </span>
<a href="#l2.278"></a><span id="l2.278">     return results;</span>
<a href="#l2.279"></a><span id="l2.279">   },</span>
<a href="#l2.280"></a><span id="l2.280"> </span>
<a href="#l2.281"></a><span id="l2.281" class="difflineplus">+  get _deleteMessageByIDStatement() {</span>
<a href="#l2.282"></a><span id="l2.282" class="difflineplus">+    let statement = this._createStatement(</span>
<a href="#l2.283"></a><span id="l2.283" class="difflineplus">+      &quot;DELETE FROM messages WHERE id = :id&quot;);</span>
<a href="#l2.284"></a><span id="l2.284" class="difflineplus">+    this.__defineGetter__(&quot;_deleteMessageByIDStatement&quot;,</span>
<a href="#l2.285"></a><span id="l2.285" class="difflineplus">+                          function() statement);</span>
<a href="#l2.286"></a><span id="l2.286" class="difflineplus">+    return this._deleteMessageByIDStatement; </span>
<a href="#l2.287"></a><span id="l2.287" class="difflineplus">+  },</span>
<a href="#l2.288"></a><span id="l2.288" class="difflineplus">+  </span>
<a href="#l2.289"></a><span id="l2.289" class="difflineplus">+  deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l2.290"></a><span id="l2.290" class="difflineplus">+    let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l2.291"></a><span id="l2.291" class="difflineplus">+    dmbids.params.id = aMessageID;</span>
<a href="#l2.292"></a><span id="l2.292" class="difflineplus">+    dmbids.execute();</span>
<a href="#l2.293"></a><span id="l2.293" class="difflineplus">+  },</span>
<a href="#l2.294"></a><span id="l2.294" class="difflineplus">+</span>
<a href="#l2.295"></a><span id="l2.295" class="difflineplus">+  get _deleteMessagesByConversationIDStatement() {</span>
<a href="#l2.296"></a><span id="l2.296" class="difflineplus">+    let statement = this._createStatement(</span>
<a href="#l2.297"></a><span id="l2.297" class="difflineplus">+      &quot;DELETE FROM messages WHERE conversationID = :conversationID&quot;);</span>
<a href="#l2.298"></a><span id="l2.298" class="difflineplus">+    this.__defineGetter__(&quot;_deleteMessagesByConversationIDStatement&quot;,</span>
<a href="#l2.299"></a><span id="l2.299" class="difflineplus">+                          function() statement);</span>
<a href="#l2.300"></a><span id="l2.300" class="difflineplus">+    return this._deleteMessagesByConversationIDStatement; </span>
<a href="#l2.301"></a><span id="l2.301" class="difflineplus">+  },</span>
<a href="#l2.302"></a><span id="l2.302" class="difflineplus">+</span>
<a href="#l2.303"></a><span id="l2.303">   /**</span>
<a href="#l2.304"></a><span id="l2.304" class="difflineminus">-   * Delete messages by databse ID.  This is the ONLY form of message deletion</span>
<a href="#l2.305"></a><span id="l2.305" class="difflineminus">-   *  we support because attribute clean-up demands that we actually know the</span>
<a href="#l2.306"></a><span id="l2.306" class="difflineminus">-   *  IDs of the messages we are deleting (so that we can delete attributes that</span>
<a href="#l2.307"></a><span id="l2.307" class="difflineminus">-   *  reference those message IDs. </span>
<a href="#l2.308"></a><span id="l2.308" class="difflineplus">+   * Delete messages by conversation ID.  For use by the indexer's deletion</span>
<a href="#l2.309"></a><span id="l2.309" class="difflineplus">+   *  logic, NOT you.</span>
<a href="#l2.310"></a><span id="l2.310">    */</span>
<a href="#l2.311"></a><span id="l2.311" class="difflineminus">-  deleteMessagesByID: function gloda_ds_deleteMessagesByID(aFolderID){</span>
<a href="#l2.312"></a><span id="l2.312" class="difflineplus">+  deleteMessagesByConversationID:</span>
<a href="#l2.313"></a><span id="l2.313" class="difflineplus">+      function gloda_ds_deleteMessagesByConversationID(aConversationID) {</span>
<a href="#l2.314"></a><span id="l2.314" class="difflineplus">+    let dmbcids = this._deleteMessagesByConversationIDStatement;</span>
<a href="#l2.315"></a><span id="l2.315" class="difflineplus">+    dmbcids.params.conversationID = aConversationID;</span>
<a href="#l2.316"></a><span id="l2.316" class="difflineplus">+    dmbcids.execute();</span>
<a href="#l2.317"></a><span id="l2.317">   },</span>
<a href="#l2.318"></a><span id="l2.318">   </span>
<a href="#l2.319"></a><span id="l2.319">   // could probably do with an optimized version of this...</span>
<a href="#l2.320"></a><span id="l2.320">   getMessageByMessageID: function gloda_ds_getMessageByMessageID(aMessageID) {</span>
<a href="#l2.321"></a><span id="l2.321">     var ids = [aMessageID];</span>
<a href="#l2.322"></a><span id="l2.322">     var messages = this.getMessagesByMessageID(ids);</span>
<a href="#l2.323"></a><span id="l2.323">     return messages.pop();</span>
<a href="#l2.324"></a><span id="l2.324">   },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/explattr.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/explattr.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -89,20 +89,16 @@ let GlodaExplicitAttr = {</span>
<a href="#l3.4"></a><span id="l3.4">                         bindName: &quot;tags&quot;,</span>
<a href="#l3.5"></a><span id="l3.5">                         singular: true,</span>
<a href="#l3.6"></a><span id="l3.6">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l3.7"></a><span id="l3.7">                         objectNoun: Gloda.NOUN_DATE,</span>
<a href="#l3.8"></a><span id="l3.8">                         parameterNoun: Gloda.NOUN_TAG,</span>
<a href="#l3.9"></a><span id="l3.9">                         explanation: this._strBundle.getString(</span>
<a href="#l3.10"></a><span id="l3.10">                                        &quot;attrTagExplanation&quot;),</span>
<a href="#l3.11"></a><span id="l3.11">                         });</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-                        this, Gloda.kAttrExplicit,</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-                        Gloda.BUILT_IN, FA_TAG, Gloda.kMultiple,</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-                        Gloda.NOUN_MESSAGE, Gloda.NOUN_DATE, Gloda.NOUN_TAG,</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">-                        &quot;&quot;);</span>
<a href="#l3.16"></a><span id="l3.16">     // Star</span>
<a href="#l3.17"></a><span id="l3.17">     this._attrStar = Gloda.defineAttribute({</span>
<a href="#l3.18"></a><span id="l3.18">                         provider: this,</span>
<a href="#l3.19"></a><span id="l3.19">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l3.20"></a><span id="l3.20">                         attributeType: Gloda.kAttrExplicit,</span>
<a href="#l3.21"></a><span id="l3.21">                         attributeName: &quot;star&quot;,</span>
<a href="#l3.22"></a><span id="l3.22">                         bind: true,</span>
<a href="#l3.23"></a><span id="l3.23">                         bindName: &quot;starred&quot;,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -168,17 +168,17 @@ let Gloda = {</span>
<a href="#l4.4"></a><span id="l4.4">   NOUN_DATE: 10,</span>
<a href="#l4.5"></a><span id="l4.5">   NOUN_TAG: 50,</span>
<a href="#l4.6"></a><span id="l4.6">   NOUN_CONVERSATION: 101,</span>
<a href="#l4.7"></a><span id="l4.7">   NOUN_MESSAGE: 102,</span>
<a href="#l4.8"></a><span id="l4.8">   NOUN_CONTACT: 103,</span>
<a href="#l4.9"></a><span id="l4.9">   NOUN_IDENTITY: 104,</span>
<a href="#l4.10"></a><span id="l4.10">   </span>
<a href="#l4.11"></a><span id="l4.11">   /** Next Noun ID to hand out, these don't need to be persisted (for now). */</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-  _nextNounID = 1000,</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+  _nextNounID: 1000,</span>
<a href="#l4.14"></a><span id="l4.14"> </span>
<a href="#l4.15"></a><span id="l4.15">   _nounNameToNounID: {},</span>
<a href="#l4.16"></a><span id="l4.16">   _nounIDToMeta: {},</span>
<a href="#l4.17"></a><span id="l4.17">   </span>
<a href="#l4.18"></a><span id="l4.18">   defineNoun: function gloda_ns_defineNoun(aNounMeta) {</span>
<a href="#l4.19"></a><span id="l4.19">     let nounID = this._nextNounID++;</span>
<a href="#l4.20"></a><span id="l4.20">     this._nounNameToNounID[aNounDef.name] = nounID; </span>
<a href="#l4.21"></a><span id="l4.21">     this._nounIDToMeta[nounID] = aNounMeta;</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineat">@@ -444,17 +444,17 @@ let Gloda = {</span>
<a href="#l4.23"></a><span id="l4.23">   getAttrDef: function gloda_ns_getAttrDef(aPluginName, aAttrName) {</span>
<a href="#l4.24"></a><span id="l4.24">     let compoundName = aPluginName + &quot;:&quot; + aAttrName;</span>
<a href="#l4.25"></a><span id="l4.25">     return GlodaDatastore._attributes[compoundName];</span>
<a href="#l4.26"></a><span id="l4.26">   },</span>
<a href="#l4.27"></a><span id="l4.27">   </span>
<a href="#l4.28"></a><span id="l4.28">   processMessage: function gloda_ns_processMessage(aMessage, aMsgHdr) {</span>
<a href="#l4.29"></a><span id="l4.29">     // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l4.30"></a><span id="l4.30">     //  before applying the new attributes.</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">-    aMessage.clearAttributes();</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+    aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l4.33"></a><span id="l4.33">     </span>
<a href="#l4.34"></a><span id="l4.34">     let allAttribs = [];</span>
<a href="#l4.35"></a><span id="l4.35">   </span>
<a href="#l4.36"></a><span id="l4.36">     for(let i = 0; i &lt; this._attrProviderOrder.length; i++) {</span>
<a href="#l4.37"></a><span id="l4.37">       let attribs = this._attrProviderOrder[i].process(aMessage, aMsgHdr);</span>
<a href="#l4.38"></a><span id="l4.38">       allAttribs = allAttribs.concat(attribs);</span>
<a href="#l4.39"></a><span id="l4.39">     }</span>
<a href="#l4.40"></a><span id="l4.40">     </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -254,22 +254,26 @@ let GlodaIndexer = {</span>
<a href="#l5.4"></a><span id="l5.4">             this._log.debug(&quot;Done with indexing folder because: &quot; + ex);</span>
<a href="#l5.5"></a><span id="l5.5">             this._indexingFolder = null;</span>
<a href="#l5.6"></a><span id="l5.6">             this._indexingIterator = null;</span>
<a href="#l5.7"></a><span id="l5.7">           }</span>
<a href="#l5.8"></a><span id="l5.8">         }</span>
<a href="#l5.9"></a><span id="l5.9">         else if (this._indexQueue.length) {</span>
<a href="#l5.10"></a><span id="l5.10">           let item = this._indexQueue.shift();</span>
<a href="#l5.11"></a><span id="l5.11">           let itemType = item[0];</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+          let actionType = item[1];</span>
<a href="#l5.13"></a><span id="l5.13">           </span>
<a href="#l5.14"></a><span id="l5.14" class="difflineminus">-          if (itemType == &quot;account&quot;) {</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+          // Index an account.  (can't actually happen right now)</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+          if ((itemType == &quot;account&quot;) &amp;&amp; (actionType &gt; 1)) {</span>
<a href="#l5.17"></a><span id="l5.17">             this.indexAccount(item[1]);</span>
<a href="#l5.18"></a><span id="l5.18">           }</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineminus">-          else if (itemType == &quot;folder&quot;) {</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineminus">-            let folderURI = item[1];</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+          // Index an added folder (new, or just re-scanning)</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+          else if ((itemType == &quot;folder&quot;) &amp;&amp; (actionType &gt; 0)) {</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+            let folderID = item[2];</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+            let folderURI = GlodaDatastore._mapFolderID(folderID);</span>
<a href="#l5.25"></a><span id="l5.25">             </span>
<a href="#l5.26"></a><span id="l5.26">             this._log.debug(&quot;Folder URI: &quot; + folderURI);</span>
<a href="#l5.27"></a><span id="l5.27">   </span>
<a href="#l5.28"></a><span id="l5.28">             let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l5.29"></a><span id="l5.29">                              getService(Ci.nsIRDFService);</span>
<a href="#l5.30"></a><span id="l5.30">             let folder = rdfService.GetResource(folderURI);</span>
<a href="#l5.31"></a><span id="l5.31">             if (folder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l5.32"></a><span id="l5.32">               this._indexingFolder = folder;</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineat">@@ -299,16 +303,48 @@ let GlodaIndexer = {</span>
<a href="#l5.34"></a><span id="l5.34">                 this._log.error(&quot;Problem indexing folder: &quot; +</span>
<a href="#l5.35"></a><span id="l5.35">                                 folder.prettiestName + &quot;, skipping.&quot;);</span>
<a href="#l5.36"></a><span id="l5.36">                 this._log.error(&quot;Error was: &quot; + ex);</span>
<a href="#l5.37"></a><span id="l5.37">                 this._indexingFolder = null;</span>
<a href="#l5.38"></a><span id="l5.38">                 this._indexingIterator = null;</span>
<a href="#l5.39"></a><span id="l5.39">               }</span>
<a href="#l5.40"></a><span id="l5.40">             }</span>
<a href="#l5.41"></a><span id="l5.41">           }</span>
<a href="#l5.42"></a><span id="l5.42" class="difflineplus">+          // Delete a folder that has gone away</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineplus">+          // [&quot;folder&quot;, -1, folder ID]</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineplus">+          else if ((itemType == &quot;folder&quot;) &amp;&amp; (actionType &lt; 0)) {</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineplus">+            let folderID = item[2];</span>
<a href="#l5.46"></a><span id="l5.46" class="difflineplus">+            // we simply convert the messages in the folder to message ids</span>
<a href="#l5.47"></a><span id="l5.47" class="difflineplus">+            //  which we re-queue.</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineplus">+            let messageIDs = GlodaDatastore.getMessageIDsByFolderID(folderID);</span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+            let delMsgsQueue = [[&quot;message&quot;, -1, msgId] for each</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineplus">+                                (msgId in messageIDs)];</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineplus">+            this._indexingFolderCount++;</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+            this._indexingMessageCount = 0;</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+            this._indexingMessageGoal = delMsgsQueue.length;</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+          }</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+          // Index a newly added message</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+          // [&quot;message&quot;, 1, folder ID, message key]</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+          else if ((itemType == &quot;message&quot;) &amp;&amp; (actionType &gt; 0)) {</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+            let folderID = item[2];</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+            let messageKey = item[3];</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+          }</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+          // Index a moved message (sadly basically adding for now)</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+          // [&quot;message&quot;, 0, folder ID, header message-id]</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+          else if ((itemType == &quot;message&quot;) &amp;&amp; (actionType === 0)) {</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+          </span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+          }</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+          // Delete a message that has gone away</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+          // [&quot;message&quot;, -1, message database ID]</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+          else if ((itemType == &quot;message&quot;) &amp;&amp; (actionType &lt; 0)) {</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+            let messageID = item[2];</span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+            let message = GlodaDatastore.getMessageByID(messageID);</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineplus">+            if (message !== null)</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+              this._deleteMessage(message);</span>
<a href="#l5.73"></a><span id="l5.73" class="difflineplus">+          }</span>
<a href="#l5.74"></a><span id="l5.74">         }</span>
<a href="#l5.75"></a><span id="l5.75">         else {</span>
<a href="#l5.76"></a><span id="l5.76">           this._log.info(&quot;Done indexing, disabling timer renewal.&quot;);</span>
<a href="#l5.77"></a><span id="l5.77">           this._indexingActive = false;</span>
<a href="#l5.78"></a><span id="l5.78">           this._indexingFolderCount = 0;</span>
<a href="#l5.79"></a><span id="l5.79">           this._indexingFolderGoal = 0;</span>
<a href="#l5.80"></a><span id="l5.80">           this._indexingMessageCount = 0;</span>
<a href="#l5.81"></a><span id="l5.81">           this._indexingMessageGoal = 0;</span>
<a href="#l5.82"></a><span id="l5.82" class="difflineat">@@ -327,42 +363,48 @@ let GlodaIndexer = {</span>
<a href="#l5.83"></a><span id="l5.83">     }</span>
<a href="#l5.84"></a><span id="l5.84">   },</span>
<a href="#l5.85"></a><span id="l5.85"> </span>
<a href="#l5.86"></a><span id="l5.86">   indexEverything: function glodaIndexEverything() {</span>
<a href="#l5.87"></a><span id="l5.87">     this._log.info(&quot;Queueing all accounts for indexing.&quot;);</span>
<a href="#l5.88"></a><span id="l5.88">     let msgAccountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l5.89"></a><span id="l5.89">                             getService(Ci.nsIMsgAccountManager);</span>
<a href="#l5.90"></a><span id="l5.90">     </span>
<a href="#l5.91"></a><span id="l5.91" class="difflineplus">+    GlodaDatastore._beginTransaction();</span>
<a href="#l5.92"></a><span id="l5.92">     let sideEffects = [this.indexAccount(account) for each</span>
<a href="#l5.93"></a><span id="l5.93">                        (account in fixIterator(msgAccountManager.accounts,</span>
<a href="#l5.94"></a><span id="l5.94">                                                Ci.nsIMsgAccount))];</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineplus">+    GlodaDatastore._commitTransaction();</span>
<a href="#l5.96"></a><span id="l5.96">   },</span>
<a href="#l5.97"></a><span id="l5.97"> </span>
<a href="#l5.98"></a><span id="l5.98">   indexAccount: function glodaIndexAccount(aAccount) {</span>
<a href="#l5.99"></a><span id="l5.99">     let rootFolder = aAccount.incomingServer.rootFolder;</span>
<a href="#l5.100"></a><span id="l5.100">     if (rootFolder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l5.101"></a><span id="l5.101">       this._log.info(&quot;Queueing account folders for indexing: &quot; + aAccount.key);</span>
<a href="#l5.102"></a><span id="l5.102"> </span>
<a href="#l5.103"></a><span id="l5.103" class="difflineplus">+      GlodaDatastore._beginTransaction();</span>
<a href="#l5.104"></a><span id="l5.104">       let folders =</span>
<a href="#l5.105"></a><span id="l5.105" class="difflineminus">-              [[&quot;folder&quot;, folder.URI] for each</span>
<a href="#l5.106"></a><span id="l5.106" class="difflineplus">+              [[&quot;folder&quot;, 1, GlodaDatastore._mapFolderURI(folder.URI)] for each</span>
<a href="#l5.107"></a><span id="l5.107">               (folder in fixIterator(rootFolder.subFolders, Ci.nsIMsgFolder))];</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+      GlodaDatastore._commitTransaction();</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineplus">+      </span>
<a href="#l5.110"></a><span id="l5.110">       this._indexingFolderGoal += folders.length;</span>
<a href="#l5.111"></a><span id="l5.111">       this._indexQueue = this._indexQueue.concat(folders);</span>
<a href="#l5.112"></a><span id="l5.112">       this.indexing = true;</span>
<a href="#l5.113"></a><span id="l5.113">     }</span>
<a href="#l5.114"></a><span id="l5.114">     else {</span>
<a href="#l5.115"></a><span id="l5.115">       this._log.info(&quot;Skipping Account, root folder not nsIMsgFolder&quot;);</span>
<a href="#l5.116"></a><span id="l5.116">     }</span>
<a href="#l5.117"></a><span id="l5.117">   },</span>
<a href="#l5.118"></a><span id="l5.118"> </span>
<a href="#l5.119"></a><span id="l5.119">   indexFolder: function glodaIndexFolder(aFolder) {</span>
<a href="#l5.120"></a><span id="l5.120">     this._log.info(&quot;Queue-ing folder for indexing: &quot; + aFolder.prettiestName);</span>
<a href="#l5.121"></a><span id="l5.121">     </span>
<a href="#l5.122"></a><span id="l5.122" class="difflineminus">-    this._indexQueue.push([&quot;folder&quot;, aFolder.URI]);</span>
<a href="#l5.123"></a><span id="l5.123" class="difflineplus">+    this._indexQueue.push([&quot;folder&quot;, 1,</span>
<a href="#l5.124"></a><span id="l5.124" class="difflineplus">+                          GlodaDatastore._mapFolderURI(aFolder.URI)]);</span>
<a href="#l5.125"></a><span id="l5.125">     this.indexing = true;</span>
<a href="#l5.126"></a><span id="l5.126">   },</span>
<a href="#l5.127"></a><span id="l5.127"> </span>
<a href="#l5.128"></a><span id="l5.128">   </span>
<a href="#l5.129"></a><span id="l5.129">   /* *********** Event Processing *********** */</span>
<a href="#l5.130"></a><span id="l5.130"> </span>
<a href="#l5.131"></a><span id="l5.131">   /* ***** Folder Changes ***** */  </span>
<a href="#l5.132"></a><span id="l5.132">   /**</span>
<a href="#l5.133"></a><span id="l5.133" class="difflineat">@@ -391,73 +433,115 @@ let GlodaIndexer = {</span>
<a href="#l5.134"></a><span id="l5.134">      *  try and index the message immediately, or hold onto a less specific</span>
<a href="#l5.135"></a><span id="l5.135">      *  form of message information than the nsIMsgDBHdr.  (If we were to</span>
<a href="#l5.136"></a><span id="l5.136">      *  process immediately, it might appropriate to consider having a</span>
<a href="#l5.137"></a><span id="l5.137">      *  transaction open that is commited by timer/sufficient activity, since it</span>
<a href="#l5.138"></a><span id="l5.138">      *  is conceivable we will see a number of these events in fairly rapid</span>
<a href="#l5.139"></a><span id="l5.139">      *  succession.)</span>
<a href="#l5.140"></a><span id="l5.140">      */</span>
<a href="#l5.141"></a><span id="l5.141">     msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l5.142"></a><span id="l5.142" class="difflineminus">-      this.indexer._indexQueue.push([&quot;message&quot;, 1, aMsgHdr]);</span>
<a href="#l5.143"></a><span id="l5.143" class="difflineplus">+      this.indexer._indexQueue.push(</span>
<a href="#l5.144"></a><span id="l5.144" class="difflineplus">+        [&quot;message&quot;, 1,</span>
<a href="#l5.145"></a><span id="l5.145" class="difflineplus">+         GlodaDatastore._mapFolderURI(aMsgHdr.folder.URI),</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineplus">+         aMsgHdr.messageKey]);</span>
<a href="#l5.147"></a><span id="l5.147">       this.indexer.indexing = true; </span>
<a href="#l5.148"></a><span id="l5.148">     },</span>
<a href="#l5.149"></a><span id="l5.149">     </span>
<a href="#l5.150"></a><span id="l5.150">     /**</span>
<a href="#l5.151"></a><span id="l5.151">      * Handle real, actual deletion (move to trash and IMAP deletion model</span>
<a href="#l5.152"></a><span id="l5.152">      *  don't count; we only see the deletion here when it becomes forever,</span>
<a href="#l5.153"></a><span id="l5.153">      *  or rather _just before_ it becomes forever.  Because the header is</span>
<a href="#l5.154"></a><span id="l5.154">      *  going away, we need to either process things immediately or extract the</span>
<a href="#l5.155"></a><span id="l5.155">      *  information required to purge it later without the header.</span>
<a href="#l5.156"></a><span id="l5.156">      *</span>
<a href="#l5.157"></a><span id="l5.157">      * We opt to process all of the headers immediately, inside a transaction.</span>
<a href="#l5.158"></a><span id="l5.158">      *  We do this because deletions may actually be a batch deletion of many,</span>
<a href="#l5.159"></a><span id="l5.159">      *  many messages, which could be a lot to queue</span>
<a href="#l5.160"></a><span id="l5.160">      */</span>
<a href="#l5.161"></a><span id="l5.161">     msgsDeleted: function gloda_indexer_msgsDeleted(aMsgHdrs) {</span>
<a href="#l5.162"></a><span id="l5.162" class="difflineplus">+      // TODO progress indicator for here</span>
<a href="#l5.163"></a><span id="l5.163">       for (let iMsgHdr=0; iMsgHdr &lt; aMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l5.164"></a><span id="l5.164">         let msgHdr = aMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l5.165"></a><span id="l5.165">         this.indexer._indexQueue.push([&quot;message&quot;, -1, msgHdr]);</span>
<a href="#l5.166"></a><span id="l5.166">       }</span>
<a href="#l5.167"></a><span id="l5.167">       this.indexer.indexing = true;</span>
<a href="#l5.168"></a><span id="l5.168">     },</span>
<a href="#l5.169"></a><span id="l5.169">     </span>
<a href="#l5.170"></a><span id="l5.170">     /**</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineminus">-     * Process a move or copy.  Moves are immediately processed, while copies</span>
<a href="#l5.172"></a><span id="l5.172" class="difflineminus">-     *  are treated as additions and accordingly queued for subsequent indexing.</span>
<a href="#l5.173"></a><span id="l5.173" class="difflineplus">+     * Process a move or copy.  Copies are treated as additions and accordingly</span>
<a href="#l5.174"></a><span id="l5.174" class="difflineplus">+     *  queued for subsequent indexing.  Moves are annoying in that, in theory,</span>
<a href="#l5.175"></a><span id="l5.175" class="difflineplus">+     *  we should be able to just alter the location information and be done</span>
<a href="#l5.176"></a><span id="l5.176" class="difflineplus">+     *  with it.  Unfortunately, we have no clue what the messageKey is for</span>
<a href="#l5.177"></a><span id="l5.177" class="difflineplus">+     *  the moved message until we go looking.  For now, we &quot;simply&quot; move the</span>
<a href="#l5.178"></a><span id="l5.178" class="difflineplus">+     *  messages into the destination folder, wiping their message keys, and</span>
<a href="#l5.179"></a><span id="l5.179" class="difflineplus">+     *  scheduling them all for re-indexing based on their message ids, which</span>
<a href="#l5.180"></a><span id="l5.180" class="difflineplus">+     *  may catch some same-folder duplicates.</span>
<a href="#l5.181"></a><span id="l5.181" class="difflineplus">+     *</span>
<a href="#l5.182"></a><span id="l5.182" class="difflineplus">+     * @TODO Handle the move case better, avoiding a full reindexing of the</span>
<a href="#l5.183"></a><span id="l5.183" class="difflineplus">+     *     messages when possible.  (In fact, the _indexMessage method basically</span>
<a href="#l5.184"></a><span id="l5.184" class="difflineplus">+     *     has enough information to try and give this a whirl, but it's not</span>
<a href="#l5.185"></a><span id="l5.185" class="difflineplus">+     *     foolproof, hence not done and this issue yet to-do.  </span>
<a href="#l5.186"></a><span id="l5.186">      */</span>
<a href="#l5.187"></a><span id="l5.187">     msgsMoveCopyCompleted: function gloda_indexer_msgsMoveCopyCompleted(aMove,</span>
<a href="#l5.188"></a><span id="l5.188">                              aSrcMsgHdrs, aDestFolder) {</span>
<a href="#l5.189"></a><span id="l5.189" class="difflineminus">-      for () {</span>
<a href="#l5.190"></a><span id="l5.190" class="difflineminus">-        let msgHdr;</span>
<a href="#l5.191"></a><span id="l5.191" class="difflineminus">-        this.indexer._indexQueue.push([&quot;message&quot;, 1, msgHdr]);</span>
<a href="#l5.192"></a><span id="l5.192" class="difflineplus">+      if (aMove) {</span>
<a href="#l5.193"></a><span id="l5.193" class="difflineplus">+        let srcFolder = aSrcMsgHdrs.queryElementAt(0, Ci.nsIMsgDBHdr).folder;</span>
<a href="#l5.194"></a><span id="l5.194" class="difflineplus">+        let messageKeys = [msgHdr.messageKey for each</span>
<a href="#l5.195"></a><span id="l5.195" class="difflineplus">+                           (msgHdr in fixIterator(aSrcMsgHdrs, Ci.nsIMsgDBHdr)];</span>
<a href="#l5.196"></a><span id="l5.196" class="difflineplus">+        // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l5.197"></a><span id="l5.197" class="difflineplus">+        GlodaDatastore.updateMessageFoldersByKeyPurging(srcFolder.URI,</span>
<a href="#l5.198"></a><span id="l5.198" class="difflineplus">+                                                        messageKeys,</span>
<a href="#l5.199"></a><span id="l5.199" class="difflineplus">+                                                        aDestFolder.URI);</span>
<a href="#l5.200"></a><span id="l5.200" class="difflineplus">+        // and now let us queue the re-indexings...</span>
<a href="#l5.201"></a><span id="l5.201" class="difflineplus">+        for (let iSrcMsgHdr=0; iSrcMsgHdrs &lt; aSrcMsgHdrs.length; iSrcMsgHdr++) {</span>
<a href="#l5.202"></a><span id="l5.202" class="difflineplus">+          let msgHdr = aSrcMsgHdrs.queryElementAt(iSrcMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l5.203"></a><span id="l5.203" class="difflineplus">+          this.indexer._indexQueue.push([&quot;message&quot;, 0,</span>
<a href="#l5.204"></a><span id="l5.204" class="difflineplus">+            GlodaDatastore._mapFolderURI(msgHdr.folder.URI), msgHdr.messageId]);</span>
<a href="#l5.205"></a><span id="l5.205" class="difflineplus">+        }</span>
<a href="#l5.206"></a><span id="l5.206" class="difflineplus">+        // TODO progress indicator for here, also indexing flag        </span>
<a href="#l5.207"></a><span id="l5.207" class="difflineplus">+      }</span>
<a href="#l5.208"></a><span id="l5.208" class="difflineplus">+      else {</span>
<a href="#l5.209"></a><span id="l5.209" class="difflineplus">+        // TODO progress indicator for here, also indexing flag</span>
<a href="#l5.210"></a><span id="l5.210" class="difflineplus">+        for (let iSrcMsgHdr=0; iSrcMsgHdrs &lt; aSrcMsgHdrs.length; iSrcMsgHdr++) {</span>
<a href="#l5.211"></a><span id="l5.211" class="difflineplus">+          let msgHdr = aSrcMsgHdrs.queryElementAt(iSrcMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l5.212"></a><span id="l5.212" class="difflineplus">+          this.indexer._indexQueue.push([&quot;message&quot;, 1,</span>
<a href="#l5.213"></a><span id="l5.213" class="difflineplus">+            GlodaDatastore._mapFolderURI(msgHdr.folder.URI),</span>
<a href="#l5.214"></a><span id="l5.214" class="difflineplus">+            msgHdr.messageKey]);</span>
<a href="#l5.215"></a><span id="l5.215" class="difflineplus">+        }</span>
<a href="#l5.216"></a><span id="l5.216">       }</span>
<a href="#l5.217"></a><span id="l5.217">     },</span>
<a href="#l5.218"></a><span id="l5.218">     </span>
<a href="#l5.219"></a><span id="l5.219">     /**</span>
<a href="#l5.220"></a><span id="l5.220">      * Handles folder no-longer-exists-ence.  We want to delete all messages</span>
<a href="#l5.221"></a><span id="l5.221">      *  located in the folder.</span>
<a href="#l5.222"></a><span id="l5.222">      */</span>
<a href="#l5.223"></a><span id="l5.223">     folderDeleted: function gloda_indexer_folderDeleted(aFolder) {</span>
<a href="#l5.224"></a><span id="l5.224" class="difflineplus">+      this._indexingFolderGoal++;</span>
<a href="#l5.225"></a><span id="l5.225" class="difflineplus">+      this.indexer._indexQueue.push([&quot;folder&quot;, -1,</span>
<a href="#l5.226"></a><span id="l5.226" class="difflineplus">+        GlodaDatastore._mapFolderURI(aFolder.URI)]);</span>
<a href="#l5.227"></a><span id="l5.227" class="difflineplus">+      this.indexing = true;</span>
<a href="#l5.228"></a><span id="l5.228">     },</span>
<a href="#l5.229"></a><span id="l5.229">     </span>
<a href="#l5.230"></a><span id="l5.230">     /**</span>
<a href="#l5.231"></a><span id="l5.231">      * Handle a folder being copied.  I do not believe the MailNews code is</span>
<a href="#l5.232"></a><span id="l5.232">      *  capable of generating a case where aMove is true, but just in case we'll</span>
<a href="#l5.233"></a><span id="l5.233">      *  dispatch to our sibling method, folderRenamed.</span>
<a href="#l5.234"></a><span id="l5.234">      *</span>
<a href="#l5.235"></a><span id="l5.235">      * Folder copying is conceptually all kinds of annoying (I mean, why would</span>
<a href="#l5.236"></a><span id="l5.236">      *  you really need to duplicate all those messages?) but is easily dealt</span>
<a href="#l5.237"></a><span id="l5.237">      *  with by queueing the destination folder for initial indexing. </span>
<a href="#l5.238"></a><span id="l5.238">      */</span>
<a href="#l5.239"></a><span id="l5.239">     folderMoveCopyCompleted: function gloda_indexer_folderMoveCopyCompleted(</span>
<a href="#l5.240"></a><span id="l5.240">                                aMove, aSrcFolder, aDestFolder) {</span>
<a href="#l5.241"></a><span id="l5.241">       if (aMove) {</span>
<a href="#l5.242"></a><span id="l5.242">         return this.folderRenamed(aSrcFolder, aDestFolder);</span>
<a href="#l5.243"></a><span id="l5.243">       }</span>
<a href="#l5.244"></a><span id="l5.244" class="difflineminus">-      this.indexer._indexQueue.push([&quot;folder&quot;, aDestFolder.URI]);</span>
<a href="#l5.245"></a><span id="l5.245" class="difflineplus">+      this._indexingFolderGoal++;</span>
<a href="#l5.246"></a><span id="l5.246" class="difflineplus">+      this.indexer._indexQueue.push([&quot;folder&quot;, 1,</span>
<a href="#l5.247"></a><span id="l5.247" class="difflineplus">+        this._mapFolderURI(aDestFolder.URI)]);</span>
<a href="#l5.248"></a><span id="l5.248">       this.indexer.indexing = true;</span>
<a href="#l5.249"></a><span id="l5.249">     },</span>
<a href="#l5.250"></a><span id="l5.250">     </span>
<a href="#l5.251"></a><span id="l5.251">     /**</span>
<a href="#l5.252"></a><span id="l5.252">      * We just need to update the URI &lt;-&gt; ID maps and the row in the database,</span>
<a href="#l5.253"></a><span id="l5.253">      *  all of which is actually done by the datastore for us.</span>
<a href="#l5.254"></a><span id="l5.254">      */</span>
<a href="#l5.255"></a><span id="l5.255">     folderRenamed: function gloda_indexer_folderRenamed(aOrigFolder,</span>
<a href="#l5.256"></a><span id="l5.256" class="difflineat">@@ -539,65 +623,51 @@ let GlodaIndexer = {</span>
<a href="#l5.257"></a><span id="l5.257">       return this.indexer.strBundle.getString(&quot;shutdownTaskName&quot;);</span>
<a href="#l5.258"></a><span id="l5.258">     },</span>
<a href="#l5.259"></a><span id="l5.259">   }, </span>
<a href="#l5.260"></a><span id="l5.260">   </span>
<a href="#l5.261"></a><span id="l5.261">   /**</span>
<a href="#l5.262"></a><span id="l5.262">    * Attempt to extract the original subject from a message.  For replies, this</span>
<a href="#l5.263"></a><span id="l5.263">    *  means either taking off the 're[#]:' (or variant, including other language</span>
<a href="#l5.264"></a><span id="l5.264">    *  variants), or in a Microsoft specific-ism, from the Thread-Topic header.</span>
<a href="#l5.265"></a><span id="l5.265" class="difflineminus">-   *</span>
<a href="#l5.266"></a><span id="l5.266" class="difflineminus">-   * Ideally, we would just be able to call NS_MsgStripRE to do the bulk of the</span>
<a href="#l5.267"></a><span id="l5.267" class="difflineminus">-   *  work for us, especially since the subject may be encoded.</span>
<a href="#l5.268"></a><span id="l5.268" class="difflineplus">+   * Since we are using the nsIMsgDBHdr's subject field, this is already done</span>
<a href="#l5.269"></a><span id="l5.269" class="difflineplus">+   *  for us, and we don't actually need to do any extra work.  Hooray!</span>
<a href="#l5.270"></a><span id="l5.270">    */</span>
<a href="#l5.271"></a><span id="l5.271">   _extractOriginalSubject: function glodaIndexExtractOriginalSubject(aMsgHdr) {</span>
<a href="#l5.272"></a><span id="l5.272" class="difflineminus">-    // mailnews.localizedRe contains a comma-delimited list of alternate</span>
<a href="#l5.273"></a><span id="l5.273" class="difflineminus">-    //  prefixes.</span>
<a href="#l5.274"></a><span id="l5.274" class="difflineminus">-    // NS_MsgStripRE does this, and bug 139317 proposes adding this to</span>
<a href="#l5.275"></a><span id="l5.275" class="difflineminus">-    //  nsIMimeConverter</span>
<a href="#l5.276"></a><span id="l5.276" class="difflineminus">-    </span>
<a href="#l5.277"></a><span id="l5.277" class="difflineminus">-    // HACK FIXME: for now, we just return the subject without any processing </span>
<a href="#l5.278"></a><span id="l5.278">     return aMsgHdr.mime2DecodedSubject;</span>
<a href="#l5.279"></a><span id="l5.279">   },</span>
<a href="#l5.280"></a><span id="l5.280">   </span>
<a href="#l5.281"></a><span id="l5.281">   _indexMessage: function gloda_index_indexMessage(aMsgHdr) {</span>
<a href="#l5.282"></a><span id="l5.282" class="difflineminus">-  </span>
<a href="#l5.283"></a><span id="l5.283">     // -- Find/create the conversation the message belongs to.</span>
<a href="#l5.284"></a><span id="l5.284">     // Our invariant is that all messages that exist in the database belong to</span>
<a href="#l5.285"></a><span id="l5.285">     //  a conversation.</span>
<a href="#l5.286"></a><span id="l5.286">     </span>
<a href="#l5.287"></a><span id="l5.287">     // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l5.288"></a><span id="l5.288">     // (references are ordered from old [0] to new [n-1])</span>
<a href="#l5.289"></a><span id="l5.289">     let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l5.290"></a><span id="l5.290">                       (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l5.291"></a><span id="l5.291">     // also see if we already know about the message...</span>
<a href="#l5.292"></a><span id="l5.292">     references.push(aMsgHdr.messageId);</span>
<a href="#l5.293"></a><span id="l5.293" class="difflineminus">-    // (ancestors have a direct correspondence to the message id)</span>
<a href="#l5.294"></a><span id="l5.294" class="difflineminus">-    let ancestors = this._datastore.getMessagesByMessageID(references);</span>
<a href="#l5.295"></a><span id="l5.295" class="difflineplus">+    // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l5.296"></a><span id="l5.296" class="difflineplus">+    let ancestorLists = this._datastore.getMessagesByMessageID(references);</span>
<a href="#l5.297"></a><span id="l5.297">     // pull our current message lookup results off</span>
<a href="#l5.298"></a><span id="l5.298">     references.pop();</span>
<a href="#l5.299"></a><span id="l5.299" class="difflineminus">-    let curMsg = ancestors.pop();</span>
<a href="#l5.300"></a><span id="l5.300" class="difflineminus">-    </span>
<a href="#l5.301"></a><span id="l5.301" class="difflineminus">-    if (curMsg != null) {</span>
<a href="#l5.302"></a><span id="l5.302" class="difflineminus">-      // we already know about the guy, which means he was either previously</span>
<a href="#l5.303"></a><span id="l5.303" class="difflineminus">-      // a ghost or he is a duplicate...</span>
<a href="#l5.304"></a><span id="l5.304" class="difflineminus">-      if (curMsg.messageKey != null) {</span>
<a href="#l5.305"></a><span id="l5.305" class="difflineminus">-        this._log.info(&quot;Attempting to re-index message: &quot; + aMsgHdr.messageId</span>
<a href="#l5.306"></a><span id="l5.306" class="difflineminus">-                        + &quot; (&quot; + aMsgHdr.subject + &quot;)&quot;);</span>
<a href="#l5.307"></a><span id="l5.307" class="difflineminus">-        return;</span>
<a href="#l5.308"></a><span id="l5.308" class="difflineminus">-      } </span>
<a href="#l5.309"></a><span id="l5.309" class="difflineminus">-    }</span>
<a href="#l5.310"></a><span id="l5.310" class="difflineplus">+    let candidateCurMsgs = ancestorLists.pop();</span>
<a href="#l5.311"></a><span id="l5.311">     </span>
<a href="#l5.312"></a><span id="l5.312">     let conversationID = null;</span>
<a href="#l5.313"></a><span id="l5.313">     </span>
<a href="#l5.314"></a><span id="l5.314">     // (walk from closest to furthest ancestor)</span>
<a href="#l5.315"></a><span id="l5.315" class="difflineminus">-    for (let iAncestor=ancestors.length-1; iAncestor &gt;= 0; --iAncestor) {</span>
<a href="#l5.316"></a><span id="l5.316" class="difflineminus">-      let ancestor = ancestors[iAncestor];</span>
<a href="#l5.317"></a><span id="l5.317" class="difflineplus">+    for (let iAncestor=ancestorLists.length-1; iAncestor &gt;= 0; --iAncestor) {</span>
<a href="#l5.318"></a><span id="l5.318" class="difflineplus">+      let ancestorList = ancestorLists[iAncestor];</span>
<a href="#l5.319"></a><span id="l5.319">       </span>
<a href="#l5.320"></a><span id="l5.320" class="difflineminus">-      if (ancestor != null) { // ancestor.conversationID cannot be null</span>
<a href="#l5.321"></a><span id="l5.321" class="difflineplus">+      if (ancestorList.length &gt; 0) {</span>
<a href="#l5.322"></a><span id="l5.322" class="difflineplus">+        // we only care about the first instance of the message because we are</span>
<a href="#l5.323"></a><span id="l5.323" class="difflineplus">+        //  able to guarantee the invariant that all messages with the same</span>
<a href="#l5.324"></a><span id="l5.324" class="difflineplus">+        //  message id belong to the same conversation. </span>
<a href="#l5.325"></a><span id="l5.325" class="difflineplus">+        let ancestor = ancestorList[0];</span>
<a href="#l5.326"></a><span id="l5.326">         if (conversationID === null)</span>
<a href="#l5.327"></a><span id="l5.327">           conversationID = ancestor.conversationID;</span>
<a href="#l5.328"></a><span id="l5.328">         else if (conversationID != ancestor.conversationID)</span>
<a href="#l5.329"></a><span id="l5.329">           this._log.error(&quot;Inconsistency in conversations invariant on &quot; +</span>
<a href="#l5.330"></a><span id="l5.330">                           ancestor.messageID + &quot;.  It has conv id &quot; +</span>
<a href="#l5.331"></a><span id="l5.331">                           ancestor.conversationID + &quot; but expected &quot; + </span>
<a href="#l5.332"></a><span id="l5.332">                           conversationID);</span>
<a href="#l5.333"></a><span id="l5.333">       }</span>
<a href="#l5.334"></a><span id="l5.334" class="difflineat">@@ -608,57 +678,166 @@ let GlodaIndexer = {</span>
<a href="#l5.335"></a><span id="l5.335">       // (the create method could issue the id, making the call return</span>
<a href="#l5.336"></a><span id="l5.336">       //  without waiting for the database...)</span>
<a href="#l5.337"></a><span id="l5.337">       conversation = this._datastore.createConversation(</span>
<a href="#l5.338"></a><span id="l5.338">           this._extractOriginalSubject(aMsgHdr), null, null);</span>
<a href="#l5.339"></a><span id="l5.339">       conversationID = conversation.id;</span>
<a href="#l5.340"></a><span id="l5.340">     }</span>
<a href="#l5.341"></a><span id="l5.341">     </span>
<a href="#l5.342"></a><span id="l5.342">     // Walk from furthest to closest ancestor, creating the ancestors that don't</span>
<a href="#l5.343"></a><span id="l5.343" class="difflineminus">-    //  exist, and updating any to have correct parentID's if they don't have</span>
<a href="#l5.344"></a><span id="l5.344" class="difflineminus">-    //  one.  (This is possible if previous messages that were consumed in this</span>
<a href="#l5.345"></a><span id="l5.345" class="difflineplus">+    //  exist. (This is possible if previous messages that were consumed in this</span>
<a href="#l5.346"></a><span id="l5.346">     //  thread only had an in-reply-to or for some reason did not otherwise</span>
<a href="#l5.347"></a><span id="l5.347">     //  provide the full references chain.)</span>
<a href="#l5.348"></a><span id="l5.348" class="difflineminus">-    let lastAncestorId = null;</span>
<a href="#l5.349"></a><span id="l5.349" class="difflineminus">-    for (let iAncestor=0; iAncestor &lt; ancestors.length; ++iAncestor) {</span>
<a href="#l5.350"></a><span id="l5.350" class="difflineminus">-      let ancestor = ancestors[iAncestor];</span>
<a href="#l5.351"></a><span id="l5.351" class="difflineplus">+    for (let iAncestor=0; iAncestor &lt; ancestorLists.length; ++iAncestor) {</span>
<a href="#l5.352"></a><span id="l5.352" class="difflineplus">+      let ancestorList = ancestorLists[iAncestor];</span>
<a href="#l5.353"></a><span id="l5.353">       </span>
<a href="#l5.354"></a><span id="l5.354" class="difflineminus">-      if (ancestor === null) {</span>
<a href="#l5.355"></a><span id="l5.355" class="difflineplus">+      if (ancestorList.length == 0) {</span>
<a href="#l5.356"></a><span id="l5.356">         this._log.debug(&quot;creating message with: null, &quot; + conversationID +</span>
<a href="#l5.357"></a><span id="l5.357" class="difflineminus">-                        &quot;, &quot; + lastAncestorId + &quot;, &quot; + references[iAncestor] +</span>
<a href="#l5.358"></a><span id="l5.358" class="difflineplus">+                        &quot;, &quot; + references[iAncestor] +</span>
<a href="#l5.359"></a><span id="l5.359">                         &quot;, null.&quot;);</span>
<a href="#l5.360"></a><span id="l5.360" class="difflineminus">-        ancestor = this._datastore.createMessage(null, null, // no folder loc</span>
<a href="#l5.361"></a><span id="l5.361" class="difflineminus">-                                                 conversationID,</span>
<a href="#l5.362"></a><span id="l5.362" class="difflineminus">-                                                 lastAncestorId,</span>
<a href="#l5.363"></a><span id="l5.363" class="difflineminus">-                                                 references[iAncestor],</span>
<a href="#l5.364"></a><span id="l5.364" class="difflineminus">-                                                 null); // no snippet</span>
<a href="#l5.365"></a><span id="l5.365" class="difflineminus">-        ancestors[iAncestor] = ancestor;</span>
<a href="#l5.366"></a><span id="l5.366" class="difflineplus">+        let ancestor = this._datastore.createMessage(null, null, // ghost</span>
<a href="#l5.367"></a><span id="l5.367" class="difflineplus">+                                                     conversationID,</span>
<a href="#l5.368"></a><span id="l5.368" class="difflineplus">+                                                     references[iAncestor],</span>
<a href="#l5.369"></a><span id="l5.369" class="difflineplus">+                                                     null); // no snippet</span>
<a href="#l5.370"></a><span id="l5.370" class="difflineplus">+        ancestorLists[iAncestor].push(ancestor);</span>
<a href="#l5.371"></a><span id="l5.371">       }</span>
<a href="#l5.372"></a><span id="l5.372" class="difflineminus">-      else if (ancestor.parentID === null) {</span>
<a href="#l5.373"></a><span id="l5.373" class="difflineminus">-        ancestor._parentID = lastAncestorId;</span>
<a href="#l5.374"></a><span id="l5.374" class="difflineminus">-        this._datastore.updateMessage(ancestor);</span>
<a href="#l5.375"></a><span id="l5.375" class="difflineminus">-      }</span>
<a href="#l5.376"></a><span id="l5.376" class="difflineminus">-      </span>
<a href="#l5.377"></a><span id="l5.377" class="difflineminus">-      lastAncestorId = ancestor.id;</span>
<a href="#l5.378"></a><span id="l5.378">     }</span>
<a href="#l5.379"></a><span id="l5.379">     // now all our ancestors exist, though they may be ghost-like...</span>
<a href="#l5.380"></a><span id="l5.380">     </span>
<a href="#l5.381"></a><span id="l5.381" class="difflineplus">+    // find if there's a ghost version of our message or we already have indexed</span>
<a href="#l5.382"></a><span id="l5.382" class="difflineplus">+    //  this message.</span>
<a href="#l5.383"></a><span id="l5.383" class="difflineplus">+    let curMsg = null;</span>
<a href="#l5.384"></a><span id="l5.384" class="difflineplus">+    for (let iCurCand=0; iCurCand &lt; candidateCurMsgs.length; iCurCand++) {</span>
<a href="#l5.385"></a><span id="l5.385" class="difflineplus">+      let candMsg = candidateCurMsgs[iCurCand];</span>
<a href="#l5.386"></a><span id="l5.386" class="difflineplus">+      </span>
<a href="#l5.387"></a><span id="l5.387" class="difflineplus">+      // if we are in the same folder and we have the same message key, we</span>
<a href="#l5.388"></a><span id="l5.388" class="difflineplus">+      //  are definitely the same, stop looking.</span>
<a href="#l5.389"></a><span id="l5.389" class="difflineplus">+      // if we are in the same folder and the candidate message has a null</span>
<a href="#l5.390"></a><span id="l5.390" class="difflineplus">+      //  message key, we treat it as our best option unless we find an exact</span>
<a href="#l5.391"></a><span id="l5.391" class="difflineplus">+      //  key match. (this would happen because the 'move' notification case</span>
<a href="#l5.392"></a><span id="l5.392" class="difflineplus">+      //  has to deal with not knowing the target message key.  this case</span>
<a href="#l5.393"></a><span id="l5.393" class="difflineplus">+      //  will hopefully be somewhat improved in the future to not go through</span>
<a href="#l5.394"></a><span id="l5.394" class="difflineplus">+      //  this path which mandates re-indexing of the message in its entirety.)</span>
<a href="#l5.395"></a><span id="l5.395" class="difflineplus">+      // if we are in the same folder and the candidate message's underlying</span>
<a href="#l5.396"></a><span id="l5.396" class="difflineplus">+      //  message no longer exists/matches, we'll assume we are the same but</span>
<a href="#l5.397"></a><span id="l5.397" class="difflineplus">+      //  were betrayed by a re-indexing or something, but we have to make sure</span>
<a href="#l5.398"></a><span id="l5.398" class="difflineplus">+      //  a perfect match doesn't turn up.</span>
<a href="#l5.399"></a><span id="l5.399" class="difflineplus">+      if (candMsg.folderURI === aMsgHdr.folder.URI) {</span>
<a href="#l5.400"></a><span id="l5.400" class="difflineplus">+        if ((candMsg.messageKey === aMsgHdr.messageKey) || </span>
<a href="#l5.401"></a><span id="l5.401" class="difflineplus">+            (candMsg.messageKey === null)) {</span>
<a href="#l5.402"></a><span id="l5.402" class="difflineplus">+          curMsg = candMsg;</span>
<a href="#l5.403"></a><span id="l5.403" class="difflineplus">+          break;</span>
<a href="#l5.404"></a><span id="l5.404" class="difflineplus">+        }</span>
<a href="#l5.405"></a><span id="l5.405" class="difflineplus">+        if (candMsg.messageKey === null)</span>
<a href="#l5.406"></a><span id="l5.406" class="difflineplus">+          curMsg = candMsg;</span>
<a href="#l5.407"></a><span id="l5.407" class="difflineplus">+        else if ((curMsg === null) &amp;&amp; (candMsg.folderMessage === null))</span>
<a href="#l5.408"></a><span id="l5.408" class="difflineplus">+          curMsg = candMsg;</span>
<a href="#l5.409"></a><span id="l5.409" class="difflineplus">+      }</span>
<a href="#l5.410"></a><span id="l5.410" class="difflineplus">+      // our choice of last resort, but still okay, is a ghost message</span>
<a href="#l5.411"></a><span id="l5.411" class="difflineplus">+      else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l5.412"></a><span id="l5.412" class="difflineplus">+        curMsg = candMsg;</span>
<a href="#l5.413"></a><span id="l5.413" class="difflineplus">+      }</span>
<a href="#l5.414"></a><span id="l5.414" class="difflineplus">+    }</span>
<a href="#l5.415"></a><span id="l5.415" class="difflineplus">+    </span>
<a href="#l5.416"></a><span id="l5.416">     if (curMsg === null) {</span>
<a href="#l5.417"></a><span id="l5.417" class="difflineminus">-      this._log.debug(&quot;creating message with: &quot; + aMsgHdr.folder.URI +</span>
<a href="#l5.418"></a><span id="l5.418" class="difflineminus">-                      &quot;, &quot; + conversationID +</span>
<a href="#l5.419"></a><span id="l5.419" class="difflineminus">-                      &quot;, &quot; + lastAncestorId + &quot;, &quot; + aMsgHdr.messageId +</span>
<a href="#l5.420"></a><span id="l5.420" class="difflineminus">-                      &quot;, null.&quot;);</span>
<a href="#l5.421"></a><span id="l5.421">       curMsg = this._datastore.createMessage(aMsgHdr.folder.URI,</span>
<a href="#l5.422"></a><span id="l5.422">                                              aMsgHdr.messageKey,                </span>
<a href="#l5.423"></a><span id="l5.423">                                              conversationID,</span>
<a href="#l5.424"></a><span id="l5.424" class="difflineminus">-                                             lastAncestorId,</span>
<a href="#l5.425"></a><span id="l5.425">                                              aMsgHdr.messageId,</span>
<a href="#l5.426"></a><span id="l5.426">                                              null); // no snippet</span>
<a href="#l5.427"></a><span id="l5.427">      }</span>
<a href="#l5.428"></a><span id="l5.428">      else {</span>
<a href="#l5.429"></a><span id="l5.429">         curMsg.folderURI = aMsgHdr.folder.URI;</span>
<a href="#l5.430"></a><span id="l5.430">         curMsg.messageKey = aMsgHdr.messageKey;</span>
<a href="#l5.431"></a><span id="l5.431">         this._datastore.updateMessage(curMsg);</span>
<a href="#l5.432"></a><span id="l5.432">      }</span>
<a href="#l5.433"></a><span id="l5.433">      </span>
<a href="#l5.434"></a><span id="l5.434">      Gloda.processMessage(curMsg, aMsgHdr);</span>
<a href="#l5.435"></a><span id="l5.435">   },</span>
<a href="#l5.436"></a><span id="l5.436" class="difflineplus">+  </span>
<a href="#l5.437"></a><span id="l5.437" class="difflineplus">+  /**</span>
<a href="#l5.438"></a><span id="l5.438" class="difflineplus">+   * Wipe a message out of existence from our index.  This is slightly more</span>
<a href="#l5.439"></a><span id="l5.439" class="difflineplus">+   *  tricky than one would first expect because there are potentially</span>
<a href="#l5.440"></a><span id="l5.440" class="difflineplus">+   *  attributes not immediately associated with this message that reference</span>
<a href="#l5.441"></a><span id="l5.441" class="difflineplus">+   *  the message.  Not only that, but deletion of messages may leave a</span>
<a href="#l5.442"></a><span id="l5.442" class="difflineplus">+   *  conversation posessing only ghost messages, which we don't want, so we</span>
<a href="#l5.443"></a><span id="l5.443" class="difflineplus">+   *  need to nuke the moot conversation and its moot ghost messages.</span>
<a href="#l5.444"></a><span id="l5.444" class="difflineplus">+   * For now, we are actually punting on that trickiness, and the exact</span>
<a href="#l5.445"></a><span id="l5.445" class="difflineplus">+   *  nuances aren't defined yet because we have not decided whether to store</span>
<a href="#l5.446"></a><span id="l5.446" class="difflineplus">+   *  such attributes redundantly.  For example, if we have subject-pred-object,</span>
<a href="#l5.447"></a><span id="l5.447" class="difflineplus">+   *  we could actually store this as attributes (subject, id, object) and</span>
<a href="#l5.448"></a><span id="l5.448" class="difflineplus">+   *  (object, id, subject).  In such a case, we could query on (subject, *)</span>
<a href="#l5.449"></a><span id="l5.449" class="difflineplus">+   *  and use the results to delete the (object, id, subject) case.  If we</span>
<a href="#l5.450"></a><span id="l5.450" class="difflineplus">+   *  don't redundantly store attributes, we can deal with the problem by</span>
<a href="#l5.451"></a><span id="l5.451" class="difflineplus">+   *  collecting up all the attributes that accept a message as their object</span>
<a href="#l5.452"></a><span id="l5.452" class="difflineplus">+   *  type and issuing a delete against that.  For example, delete (*, [1,2,3],</span>
<a href="#l5.453"></a><span id="l5.453" class="difflineplus">+   *  message id).</span>
<a href="#l5.454"></a><span id="l5.454" class="difflineplus">+   * (We are punting because we haven't implemented support for generating</span>
<a href="#l5.455"></a><span id="l5.455" class="difflineplus">+   *  attributes like that yet.)</span>
<a href="#l5.456"></a><span id="l5.456" class="difflineplus">+   *</span>
<a href="#l5.457"></a><span id="l5.457" class="difflineplus">+   * @TODO: implement deletion of attributes that reference (deleted) messages</span>
<a href="#l5.458"></a><span id="l5.458" class="difflineplus">+   */</span>
<a href="#l5.459"></a><span id="l5.459" class="difflineplus">+  _deleteMessage: function gloda_index_deleteMessage(aMessage) {</span>
<a href="#l5.460"></a><span id="l5.460" class="difflineplus">+    // -- delete our attributes</span>
<a href="#l5.461"></a><span id="l5.461" class="difflineplus">+    // delete the message's attributes (if we implement the cascade delete, that</span>
<a href="#l5.462"></a><span id="l5.462" class="difflineplus">+    //  could do the honors for us... right now we define the trigger in our</span>
<a href="#l5.463"></a><span id="l5.463" class="difflineplus">+    //  schema but the back-end ignores it)</span>
<a href="#l5.464"></a><span id="l5.464" class="difflineplus">+    aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l5.465"></a><span id="l5.465" class="difflineplus">+    </span>
<a href="#l5.466"></a><span id="l5.466" class="difflineplus">+    // -- delete our message or ghost us, and maybe nuke the whole conversation</span>
<a href="#l5.467"></a><span id="l5.467" class="difflineplus">+    // look at the other messages in the conversation.</span>
<a href="#l5.468"></a><span id="l5.468" class="difflineplus">+    let conversationMsgs = aMessage._datastore.getMessagesByConversationID(</span>
<a href="#l5.469"></a><span id="l5.469" class="difflineplus">+                             aMessage.conversationID, true);</span>
<a href="#l5.470"></a><span id="l5.470" class="difflineplus">+    let ghosts = [];</span>
<a href="#l5.471"></a><span id="l5.471" class="difflineplus">+    let twinMessage = null;</span>
<a href="#l5.472"></a><span id="l5.472" class="difflineplus">+    for (let iMsg=0; iMsg &lt; conversationMsgs.length; iMsg++) {</span>
<a href="#l5.473"></a><span id="l5.473" class="difflineplus">+      let convMsg = conversationMsgs[iMsg];</span>
<a href="#l5.474"></a><span id="l5.474" class="difflineplus">+      </span>
<a href="#l5.475"></a><span id="l5.475" class="difflineplus">+      // ignore our message</span>
<a href="#l5.476"></a><span id="l5.476" class="difflineplus">+      if (convMsg.id == aMessage.id)</span>
<a href="#l5.477"></a><span id="l5.477" class="difflineplus">+        continue;</span>
<a href="#l5.478"></a><span id="l5.478" class="difflineplus">+      </span>
<a href="#l5.479"></a><span id="l5.479" class="difflineplus">+      if (convMsg.folderID !== null) {</span>
<a href="#l5.480"></a><span id="l5.480" class="difflineplus">+        if (convMsg.headerMessageID == aMessage.headerMessageID) {</span>
<a href="#l5.481"></a><span id="l5.481" class="difflineplus">+          twinMessage = convMsg;</span>
<a href="#l5.482"></a><span id="l5.482" class="difflineplus">+        }</span>
<a href="#l5.483"></a><span id="l5.483" class="difflineplus">+      }</span>
<a href="#l5.484"></a><span id="l5.484" class="difflineplus">+      else {</span>
<a href="#l5.485"></a><span id="l5.485" class="difflineplus">+        ghosts.push(convMsg);</span>
<a href="#l5.486"></a><span id="l5.486" class="difflineplus">+      }</span>
<a href="#l5.487"></a><span id="l5.487" class="difflineplus">+    }</span>
<a href="#l5.488"></a><span id="l5.488" class="difflineplus">+    </span>
<a href="#l5.489"></a><span id="l5.489" class="difflineplus">+    // is everyone else a ghost? (note that conversationMsgs includes us, but</span>
<a href="#l5.490"></a><span id="l5.490" class="difflineplus">+    //  ghosts cannot)</span>
<a href="#l5.491"></a><span id="l5.491" class="difflineplus">+    if ((conversationsMsgs.length - 1) == ghosts.length) {</span>
<a href="#l5.492"></a><span id="l5.492" class="difflineplus">+      // obliterate the conversation including aMessage.</span>
<a href="#l5.493"></a><span id="l5.493" class="difflineplus">+      // since everyone else is a ghost they have no attributes.  however, the</span>
<a href="#l5.494"></a><span id="l5.494" class="difflineplus">+      //  conversation may some day have attributes targeted against it, so it</span>
<a href="#l5.495"></a><span id="l5.495" class="difflineplus">+      //  gets a helper.</span>
<a href="#l5.496"></a><span id="l5.496" class="difflineplus">+      this._deleteConversationOfMessage(aMessage);</span>
<a href="#l5.497"></a><span id="l5.497" class="difflineplus">+      aMessage._nuke();</span>
<a href="#l5.498"></a><span id="l5.498" class="difflineplus">+    }</span>
<a href="#l5.499"></a><span id="l5.499" class="difflineplus">+    else { // there is at least one real message out there, so the only q is...</span>
<a href="#l5.500"></a><span id="l5.500" class="difflineplus">+      // do we have a twin (so it's okay to delete us) or do we become a ghost?</span>
<a href="#l5.501"></a><span id="l5.501" class="difflineplus">+      if (twinMessage !== null) { // just delete us</span>
<a href="#l5.502"></a><span id="l5.502" class="difflineplus">+        aMessage._datastore.deleteMessageByID(aMessage.id);</span>
<a href="#l5.503"></a><span id="l5.503" class="difflineplus">+        aMesssage._nuke();</span>
<a href="#l5.504"></a><span id="l5.504" class="difflineplus">+      }</span>
<a href="#l5.505"></a><span id="l5.505" class="difflineplus">+      else { // ghost us</span>
<a href="#l5.506"></a><span id="l5.506" class="difflineplus">+        aMessage._ghost();</span>
<a href="#l5.507"></a><span id="l5.507" class="difflineplus">+        aMessage._datastore.updateMessage(aMessage);</span>
<a href="#l5.508"></a><span id="l5.508" class="difflineplus">+      }</span>
<a href="#l5.509"></a><span id="l5.509" class="difflineplus">+    }</span>
<a href="#l5.510"></a><span id="l5.510" class="difflineplus">+  },</span>
<a href="#l5.511"></a><span id="l5.511" class="difflineplus">+  </span>
<a href="#l5.512"></a><span id="l5.512" class="difflineplus">+  /**</span>
<a href="#l5.513"></a><span id="l5.513" class="difflineplus">+   * Delete an entire conversation, using the passed-in message which must be</span>
<a href="#l5.514"></a><span id="l5.514" class="difflineplus">+   *  the last non-ghost in the conversation and have its attributes all</span>
<a href="#l5.515"></a><span id="l5.515" class="difflineplus">+   *  deleted.  This function issues the batch delete of all the ghosts (and the</span>
<a href="#l5.516"></a><span id="l5.516" class="difflineplus">+   *  message), and in the future will take care to nuke any attributes</span>
<a href="#l5.517"></a><span id="l5.517" class="difflineplus">+   *  referencing the conversation.</span>
<a href="#l5.518"></a><span id="l5.518" class="difflineplus">+   */</span>
<a href="#l5.519"></a><span id="l5.519" class="difflineplus">+  _deleteConversationOfMessage:</span>
<a href="#l5.520"></a><span id="l5.520" class="difflineplus">+      function gloda_index_deleteConversationOfMessage(aMessage) {</span>
<a href="#l5.521"></a><span id="l5.521" class="difflineplus">+    aMessage._datastore.deleteMessagesByConversationID(aMessage.conversationID);</span>
<a href="#l5.522"></a><span id="l5.522" class="difflineplus">+    aMessage._datastore.deleteConversationByID(aMessage.conversationID);</span>
<a href="#l5.523"></a><span id="l5.523" class="difflineplus">+  },</span>
<a href="#l5.524"></a><span id="l5.524"> };</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

