<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 932:9082e6d74f2d06a0a0556585ec78174fbe276cc0</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 9082e6d74f2d06a0a0556585ec78174fbe276cc0" />
<meta property="og:url" content="/comm-central/rev/9082e6d74f2d06a0a0556585ec78174fbe276cc0" />
<meta property="og:description" content="indexer status commit; want a separate commit for some collection changes." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 9082e6d74f2d06a0a0556585ec78174fbe276cc0 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/9082e6d74f2d06a0a0556585ec78174fbe276cc0">shortlog</a> |
<a href="/comm-central/log/9082e6d74f2d06a0a0556585ec78174fbe276cc0">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/9082e6d74f2d06a0a0556585ec78174fbe276cc0">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/9082e6d74f2d06a0a0556585ec78174fbe276cc0">files</a> |
changeset |
<a href="/comm-central/raw-rev/9082e6d74f2d06a0a0556585ec78174fbe276cc0">raw</a>  | <a href="/comm-central/archive/9082e6d74f2d06a0a0556585ec78174fbe276cc0.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
indexer status commit; want a separate commit for some collection changes.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sat, 20 Sep 2008 22:41:26 -0700</td></tr>

<tr>
 <td>changeset 932</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/9082e6d74f2d06a0a0556585ec78174fbe276cc0">9082e6d74f2d06a0a0556585ec78174fbe276cc0</a></td>
</tr>



<tr>
<td>parent 931</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/c2df7b8472375d2cff1684a8b6aec7f15355840f">c2df7b8472375d2cff1684a8b6aec7f15355840f</a>
</td>
</tr>

<tr>
<td>child 933</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/eb07537051591a8ed2254f56804f20f64e2f7d8a">eb07537051591a8ed2254f56804f20f64e2f7d8a</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=9082e6d74f2d06a0a0556585ec78174fbe276cc0">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">indexer status commit; want a separate commit for some collection changes.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/fundattr.js">modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/public.js">modules/public.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/public.js">file</a> |
<a href="/comm-central/annotate/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/public.js">annotate</a> |
<a href="/comm-central/diff/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/public.js">diff</a> |
<a href="/comm-central/comparison/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/public.js">comparison</a> |
<a href="/comm-central/log/9082e6d74f2d06a0a0556585ec78174fbe276cc0/modules/public.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -205,19 +205,16 @@ function GlodaMessage(aDatastore, aID, a</span>
<a href="#l1.4"></a><span id="l1.4">   this.date = aDate;</span>
<a href="#l1.5"></a><span id="l1.5">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7">   // only set _deleted if we're deleted, otherwise the undefined does our</span>
<a href="#l1.8"></a><span id="l1.8">   //  speaking for us.</span>
<a href="#l1.9"></a><span id="l1.9">   if (aDeleted)</span>
<a href="#l1.10"></a><span id="l1.10">     this._deleted = aDeleted;</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  // for now, let's always cache this; they should really be forgetting about us</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-  //  if they want to forget about the underlying storage anyways...</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineminus">-  this._folderMessage = undefined;</span>
<a href="#l1.15"></a><span id="l1.15">   // the list of attributes, un-processed</span>
<a href="#l1.16"></a><span id="l1.16">   this._attributes = null;</span>
<a href="#l1.17"></a><span id="l1.17"> }</span>
<a href="#l1.18"></a><span id="l1.18"> </span>
<a href="#l1.19"></a><span id="l1.19"> GlodaMessage.prototype = {</span>
<a href="#l1.20"></a><span id="l1.20">   NOUN_ID: 102,</span>
<a href="#l1.21"></a><span id="l1.21">   get id() { return this._id; },</span>
<a href="#l1.22"></a><span id="l1.22">   get folderID() { return this._folderID; },</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineat">@@ -265,38 +262,37 @@ GlodaMessage.prototype = {</span>
<a href="#l1.24"></a><span id="l1.24">     this._headerMessageID = null;</span>
<a href="#l1.25"></a><span id="l1.25">     </span>
<a href="#l1.26"></a><span id="l1.26">     this._datastore = null;</span>
<a href="#l1.27"></a><span id="l1.27">   },</span>
<a href="#l1.28"></a><span id="l1.28">   </span>
<a href="#l1.29"></a><span id="l1.29">   /**</span>
<a href="#l1.30"></a><span id="l1.30">    * Return the underlying nsIMsgDBHdr from the folder storage for this, or</span>
<a href="#l1.31"></a><span id="l1.31">    *  null if the message does not exist for one reason or another.</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+   * This method no longer caches the result, so it's up to you.</span>
<a href="#l1.33"></a><span id="l1.33">    */</span>
<a href="#l1.34"></a><span id="l1.34">   get folderMessage() {</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineminus">-    if (this._folderMessage !== undefined)</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineminus">-      return this._folderMessage;</span>
<a href="#l1.37"></a><span id="l1.37">     if (this._folderID === null || this._messageKey === null)</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineminus">-      return this._folderMessage = null;</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+      return null;</span>
<a href="#l1.40"></a><span id="l1.40">     let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l1.41"></a><span id="l1.41">                      getService(Ci.nsIRDFService);</span>
<a href="#l1.42"></a><span id="l1.42">     let folder = rdfService.GetResource(</span>
<a href="#l1.43"></a><span id="l1.43">                    this._datastore._mapFolderID(this._folderID));</span>
<a href="#l1.44"></a><span id="l1.44">     if (folder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineminus">-      this._folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineminus">-      if (this._folderMessage !== null) {</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+      let folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+      if (folderMessage !== null) {</span>
<a href="#l1.49"></a><span id="l1.49">         // verify the message-id header matches what we expect...</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-        if (this._folderMessage.messageId != this._headerMessageID) {</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+        if (folderMessage.messageId != this._headerMessageID) {</span>
<a href="#l1.52"></a><span id="l1.52">           LOG.info(&quot;Message with message key does not match expected &quot; +</span>
<a href="#l1.53"></a><span id="l1.53">                    &quot;header! (&quot; + this._headerMessageID + &quot; expected, got &quot; +</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineminus">-                   this._folderMessage.messageId + &quot;)&quot;);</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineminus">-          this._folderMessage = null;</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+                   folderMessage.messageId + &quot;)&quot;);</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+          folderMessage = null;</span>
<a href="#l1.58"></a><span id="l1.58">         }</span>
<a href="#l1.59"></a><span id="l1.59">       }</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineminus">-      return this._folderMessage;</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+      return folderMessage;</span>
<a href="#l1.62"></a><span id="l1.62">     }</span>
<a href="#l1.63"></a><span id="l1.63"> </span>
<a href="#l1.64"></a><span id="l1.64">     // this only gets logged if things have gone very wrong.  we used to throw</span>
<a href="#l1.65"></a><span id="l1.65">     //  here, but it's unlikely our caller can do anything more meaningful than</span>
<a href="#l1.66"></a><span id="l1.66">     //  treating this as a disappeared message.</span>
<a href="#l1.67"></a><span id="l1.67">     LOG.info(&quot;Unable to locate folder message for: &quot; + this._folderID + &quot;:&quot; +</span>
<a href="#l1.68"></a><span id="l1.68">              this._messageKey);</span>
<a href="#l1.69"></a><span id="l1.69">     return null;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -250,17 +250,17 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l2.4"></a><span id="l2.4">  *  needs to be addressed, and may be best addressed at layers above</span>
<a href="#l2.5"></a><span id="l2.5">  *  datastore.js.</span>
<a href="#l2.6"></a><span id="l2.6">  */</span>
<a href="#l2.7"></a><span id="l2.7"> let GlodaDatastore = {</span>
<a href="#l2.8"></a><span id="l2.8">   _log: null,</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10">   /* ******************* SCHEMA ******************* */</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  _schemaVersion: 7,</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  _schemaVersion: 8,</span>
<a href="#l2.14"></a><span id="l2.14">   _schema: {</span>
<a href="#l2.15"></a><span id="l2.15">     tables: {</span>
<a href="#l2.16"></a><span id="l2.16">       </span>
<a href="#l2.17"></a><span id="l2.17">       // ----- Messages</span>
<a href="#l2.18"></a><span id="l2.18">       folderLocations: {</span>
<a href="#l2.19"></a><span id="l2.19">         columns: [</span>
<a href="#l2.20"></a><span id="l2.20">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l2.21"></a><span id="l2.21">           &quot;folderURI TEXT NOT NULL&quot;,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/fundattr.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/fundattr.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -497,13 +497,11 @@ let GlodaFundAttr = {</span>
<a href="#l3.4"></a><span id="l3.4">     // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l3.5"></a><span id="l3.5">     //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l3.6"></a><span id="l3.6">     //  available.  (which we'll simply pass to everyone... it can help body</span>
<a href="#l3.7"></a><span id="l3.7">     //  logic for quoting purposes, etc. too.)</span>
<a href="#l3.8"></a><span id="l3.8">     </span>
<a href="#l3.9"></a><span id="l3.9">     // -- Date</span>
<a href="#l3.10"></a><span id="l3.10">     attribs.push([this._attrDate.id, aMsgHdr.date]);</span>
<a href="#l3.11"></a><span id="l3.11">     </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-    this._log.debug(&quot;returning attribs: &quot; + attribs);</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-    </span>
<a href="#l3.14"></a><span id="l3.14">     return attribs;</span>
<a href="#l3.15"></a><span id="l3.15">   },</span>
<a href="#l3.16"></a><span id="l3.16"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -1300,18 +1300,16 @@ let Gloda = {</span>
<a href="#l4.4"></a><span id="l4.4">         if (parameterValue != null)</span>
<a href="#l4.5"></a><span id="l4.5">           attribID = attrib.bindParameter(parameterValue);</span>
<a href="#l4.6"></a><span id="l4.6">         else</span>
<a href="#l4.7"></a><span id="l4.7">           attribID = attrib.id;</span>
<a href="#l4.8"></a><span id="l4.8">         outAttribs.push([attribID, attribDesc[2]]);</span>
<a href="#l4.9"></a><span id="l4.9">       }</span>
<a href="#l4.10"></a><span id="l4.10">     }</span>
<a href="#l4.11"></a><span id="l4.11">     </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-    this._log.debug(&quot;about to insert: &quot; + outAttribs);</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">-    </span>
<a href="#l4.14"></a><span id="l4.14">     GlodaDatastore.insertMessageAttributes(aMessage, outAttribs);</span>
<a href="#l4.15"></a><span id="l4.15">     aMessage._replaceAttributes(memAttribs);</span>
<a href="#l4.16"></a><span id="l4.16">     </span>
<a href="#l4.17"></a><span id="l4.17">     if (aIsNew)</span>
<a href="#l4.18"></a><span id="l4.18">       GlodaCollectionManager.itemsAdded(aMessage.NOUN_ID, [aMessage]);</span>
<a href="#l4.19"></a><span id="l4.19">     else</span>
<a href="#l4.20"></a><span id="l4.20">       GlodaCollectionManager.itemsModified(aMessage.NOUN_ID, [aMessage]);</span>
<a href="#l4.21"></a><span id="l4.21">   },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -352,16 +352,22 @@ let GlodaIndexer = {</span>
<a href="#l5.4"></a><span id="l5.4"> </span>
<a href="#l5.5"></a><span id="l5.5">       let notificationService =</span>
<a href="#l5.6"></a><span id="l5.6">         Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l5.7"></a><span id="l5.7">         getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l5.8"></a><span id="l5.8">       notificationService.addListener(this._msgFolderListener,</span>
<a href="#l5.9"></a><span id="l5.9">                                       Ci.nsIMsgFolderNotificationService.all);</span>
<a href="#l5.10"></a><span id="l5.10">       </span>
<a href="#l5.11"></a><span id="l5.11">       this._enabled = true;</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+      </span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+      // if we have an accumulated desire to index things, kick it off again.</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+      if (this._indexingDesired) {</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+        this._indexingDesired = false; // it's edge-triggered for now</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+        this.indexing = true;</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+      }</span>
<a href="#l5.18"></a><span id="l5.18">     }</span>
<a href="#l5.19"></a><span id="l5.19">     else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l5.20"></a><span id="l5.20">       // remove observer; no more events to observe!</span>
<a href="#l5.21"></a><span id="l5.21">       let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l5.22"></a><span id="l5.22">                               getService(Ci.nsIObserverService);</span>
<a href="#l5.23"></a><span id="l5.23">       observerService.removeObserver(this, &quot;network:offline-status-changed&quot;);</span>
<a href="#l5.24"></a><span id="l5.24">       observerService.removeObserver(this._shutdownTask, &quot;msg-shutdown&quot;, false);</span>
<a href="#l5.25"></a><span id="l5.25">   </span>
<a href="#l5.26"></a><span id="l5.26" class="difflineat">@@ -410,17 +416,17 @@ let GlodaIndexer = {</span>
<a href="#l5.27"></a><span id="l5.27">    * Set this to true to indicate there is indexing work to perform.  This does</span>
<a href="#l5.28"></a><span id="l5.28">    *  not mean indexing will begin immediately (if it wasn't active), however.</span>
<a href="#l5.29"></a><span id="l5.29">    *  If suppressIndexing has been set, we won't do anything until indexing is</span>
<a href="#l5.30"></a><span id="l5.30">    *  no longer suppressed.</span>
<a href="#l5.31"></a><span id="l5.31">    */</span>
<a href="#l5.32"></a><span id="l5.32">   set indexing(aShouldIndex) {</span>
<a href="#l5.33"></a><span id="l5.33">     if (!this._indexingDesired &amp;&amp; aShouldIndex) {</span>
<a href="#l5.34"></a><span id="l5.34">       this._indexingDesired = true;</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineminus">-      if (!this._indexingActive &amp;&amp; !this._suppressIndexing) {</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+      if (this.enabled &amp;&amp; !this._indexingActive &amp;&amp; !this._suppressIndexing) {</span>
<a href="#l5.37"></a><span id="l5.37">         this._log.info(&quot;+++ Indexing Queue Processing Commencing&quot;);</span>
<a href="#l5.38"></a><span id="l5.38">         this._indexingActive = true;</span>
<a href="#l5.39"></a><span id="l5.39">         this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l5.40"></a><span id="l5.40">                                      this._indexInterval,</span>
<a href="#l5.41"></a><span id="l5.41">                                      Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l5.42"></a><span id="l5.42">       }</span>
<a href="#l5.43"></a><span id="l5.43">     }</span>
<a href="#l5.44"></a><span id="l5.44">   },</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineat">@@ -443,16 +449,32 @@ let GlodaIndexer = {</span>
<a href="#l5.46"></a><span id="l5.46">         this._log.info(&quot;+++ Indexing Queue Processing Resuming&quot;);</span>
<a href="#l5.47"></a><span id="l5.47">         this._indexingActive = true;</span>
<a href="#l5.48"></a><span id="l5.48">         this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l5.49"></a><span id="l5.49">                                      this._indexInterval,</span>
<a href="#l5.50"></a><span id="l5.50">                                      Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l5.51"></a><span id="l5.51">     }</span>
<a href="#l5.52"></a><span id="l5.52">   },</span>
<a href="#l5.53"></a><span id="l5.53"> </span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+  _indexingSweepActive: false,</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+  /**</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+   * Indicate that an indexing sweep is desired.  We kick-off an indexing</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+   *  sweep at start-up and whenever we receive an event-based notification</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+   *  that we either can't process as an event or that we normally handle</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+   *  during the sweep pass anyways.</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+   */</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+  set indexingSweepNeeded(aNeeded) {</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+    if (!this._indexingSweepActive &amp;&amp; aNeeded) {</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+      this._indexQueue.push(new IndexingJob(&quot;sweep&quot;, 0, null));</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+      this._indexingJobGoal++;</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+      this._indexingSweepActive = true;</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+      this.indexing = true;</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+    }</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+  },</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+</span>
<a href="#l5.70"></a><span id="l5.70">   /**</span>
<a href="#l5.71"></a><span id="l5.71">    * Indicates that we have pending deletions to process, meaning that there</span>
<a href="#l5.72"></a><span id="l5.72">    *  are gloda message rows flagged for deletion.  If this value is a boolean,</span>
<a href="#l5.73"></a><span id="l5.73">    *  it means the value is known reliably.  If this value is null, it means</span>
<a href="#l5.74"></a><span id="l5.74">    *  that we don't know, likely because we have started up and have not checked</span>
<a href="#l5.75"></a><span id="l5.75">    *  the database.</span>
<a href="#l5.76"></a><span id="l5.76">    */</span>
<a href="#l5.77"></a><span id="l5.77">   pendingDeletions: null,</span>
<a href="#l5.78"></a><span id="l5.78" class="difflineat">@@ -853,17 +875,16 @@ let GlodaIndexer = {</span>
<a href="#l5.79"></a><span id="l5.79">         //  with a quasi-redundant outer loop that shunts control back inside</span>
<a href="#l5.80"></a><span id="l5.80">         //  if we left the loop due to an exception (without consuming all the</span>
<a href="#l5.81"></a><span id="l5.81">         //  tokens.)</span>
<a href="#l5.82"></a><span id="l5.82">         try {</span>
<a href="#l5.83"></a><span id="l5.83">           switch (this._actualWorker.next()) {</span>
<a href="#l5.84"></a><span id="l5.84">             case kWorkSync:</span>
<a href="#l5.85"></a><span id="l5.85">               break;</span>
<a href="#l5.86"></a><span id="l5.86">             case kWorkAsync:</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineminus">-              commit</span>
<a href="#l5.88"></a><span id="l5.88">               yield kWorkAsync;</span>
<a href="#l5.89"></a><span id="l5.89">               break;</span>
<a href="#l5.90"></a><span id="l5.90">             case kWorkDone:</span>
<a href="#l5.91"></a><span id="l5.91">               this._actualWorker.close();</span>
<a href="#l5.92"></a><span id="l5.92">               this._actualWorker = null;</span>
<a href="#l5.93"></a><span id="l5.93">               break;</span>
<a href="#l5.94"></a><span id="l5.94">           }</span>
<a href="#l5.95"></a><span id="l5.95">         }</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineat">@@ -946,25 +967,100 @@ let GlodaIndexer = {</span>
<a href="#l5.97"></a><span id="l5.97">     return true;</span>
<a href="#l5.98"></a><span id="l5.98">   },</span>
<a href="#l5.99"></a><span id="l5.99"> </span>
<a href="#l5.100"></a><span id="l5.100">   /**</span>
<a href="#l5.101"></a><span id="l5.101">    * Performs the folder sweep, locating folders that should be indexed, and</span>
<a href="#l5.102"></a><span id="l5.102">    *  creating a folder indexing job for them, and rescheduling itself for</span>
<a href="#l5.103"></a><span id="l5.103">    *  execution after that job is completed.  Once it indexes all the folders,</span>
<a href="#l5.104"></a><span id="l5.104">    *  if we believe we have deletions to process (or just don't know), it kicks</span>
<a href="#l5.105"></a><span id="l5.105" class="difflineminus">-   *  off a deletion processing job. </span>
<a href="#l5.106"></a><span id="l5.106" class="difflineplus">+   *  off a deletion processing job.</span>
<a href="#l5.107"></a><span id="l5.107" class="difflineplus">+   *</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+   * Folder traversal logic is based off the spotlight/vista indexer code; we</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineplus">+   *  retrieve the list of servers and folders each time want to find a new</span>
<a href="#l5.110"></a><span id="l5.110" class="difflineplus">+   *  folder to index.  This avoids needing to maintain a perfect model of the</span>
<a href="#l5.111"></a><span id="l5.111" class="difflineplus">+   *  folder hierarchy at all times.  (We may eventually want to do that, but</span>
<a href="#l5.112"></a><span id="l5.112" class="difflineplus">+   *  this is sufficient and safe for now.)  Although our use of dirty flags on</span>
<a href="#l5.113"></a><span id="l5.113" class="difflineplus">+   *  the folders allows us to avoid tracking the 'last folder' we processed,</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineplus">+   *  we do so to avoid getting 'trapped' in a folder with a high rate of</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineplus">+   *  changes.</span>
<a href="#l5.116"></a><span id="l5.116">    */</span>
<a href="#l5.117"></a><span id="l5.117">   _worker_indexingSweep: function gloda_worker_indexingSweep(aJob) {</span>
<a href="#l5.118"></a><span id="l5.118">     // walk the folders</span>
<a href="#l5.119"></a><span id="l5.119" class="difflineminus">-    RESUMECODING HERE WHERE THE SYNTAX IS NOT SO GOOD</span>
<a href="#l5.120"></a><span id="l5.120" class="difflineplus">+    let accountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l5.121"></a><span id="l5.121" class="difflineplus">+                           getService(Ci.nsIMsgAccountManager);</span>
<a href="#l5.122"></a><span id="l5.122" class="difflineplus">+    let servers = accountManager.allServers;</span>
<a href="#l5.123"></a><span id="l5.123" class="difflineplus">+    let foundFolder = false;</span>
<a href="#l5.124"></a><span id="l5.124" class="difflineplus">+    let useNextFolder = false;</span>
<a href="#l5.125"></a><span id="l5.125" class="difflineplus">+  </span>
<a href="#l5.126"></a><span id="l5.126" class="difflineplus">+    for (let i = 0; i &lt; servers.Count() &amp;&amp; !foundFolder; i++)</span>
<a href="#l5.127"></a><span id="l5.127" class="difflineplus">+    {</span>
<a href="#l5.128"></a><span id="l5.128" class="difflineplus">+      let server = servers.QueryElementAt(i, Ci.nsIMsgIncomingServer);</span>
<a href="#l5.129"></a><span id="l5.129" class="difflineplus">+      let rootFolder = server.rootFolder;</span>
<a href="#l5.130"></a><span id="l5.130" class="difflineplus">+      </span>
<a href="#l5.131"></a><span id="l5.131" class="difflineplus">+      // ignore news accounts for now.</span>
<a href="#l5.132"></a><span id="l5.132" class="difflineplus">+      if (rootFolder.URI.indexOf('news://') == 0)</span>
<a href="#l5.133"></a><span id="l5.133" class="difflineplus">+        continue;</span>
<a href="#l5.134"></a><span id="l5.134" class="difflineplus">+      </span>
<a href="#l5.135"></a><span id="l5.135" class="difflineplus">+      let allFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l5.136"></a><span id="l5.136" class="difflineplus">+                         createInstance(Ci.nsISupportsArray);</span>
<a href="#l5.137"></a><span id="l5.137" class="difflineplus">+      rootFolder.ListDescendents(allFolders);</span>
<a href="#l5.138"></a><span id="l5.138" class="difflineplus">+      let numFolders = allFolders.Count();</span>
<a href="#l5.139"></a><span id="l5.139" class="difflineplus">+      for (let folderIndex = 0; folderIndex &lt; numFolders &amp;&amp; !foundFolder;</span>
<a href="#l5.140"></a><span id="l5.140" class="difflineplus">+           folderIndex++)</span>
<a href="#l5.141"></a><span id="l5.141" class="difflineplus">+      {</span>
<a href="#l5.142"></a><span id="l5.142" class="difflineplus">+        let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l5.143"></a><span id="l5.143" class="difflineplus">+                                                            Ci.nsIMsgFolder);</span>
<a href="#l5.144"></a><span id="l5.144" class="difflineplus">+                                                            </span>
<a href="#l5.145"></a><span id="l5.145" class="difflineplus">+        let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineplus">+        // we only index local folders or IMAP folders that are marked offline.</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineplus">+        if (!isLocal &amp;&amp; !(folder.flags&amp;Ci.nsMsgFolderFlags.Offline) )</span>
<a href="#l5.148"></a><span id="l5.148" class="difflineplus">+          continue;</span>
<a href="#l5.149"></a><span id="l5.149" class="difflineplus">+</span>
<a href="#l5.150"></a><span id="l5.150" class="difflineplus">+        // if no folder was indexed (or the pref's not set), just use the first folder</span>
<a href="#l5.151"></a><span id="l5.151" class="difflineplus">+        if (!aJob.lastFolderIndexedUri || useNextFolder)</span>
<a href="#l5.152"></a><span id="l5.152" class="difflineplus">+        {</span>
<a href="#l5.153"></a><span id="l5.153" class="difflineplus">+          // make sure the folder is dirty before accepting this job...</span>
<a href="#l5.154"></a><span id="l5.154" class="difflineplus">+          let isDirty = true;</span>
<a href="#l5.155"></a><span id="l5.155" class="difflineplus">+          try {</span>
<a href="#l5.156"></a><span id="l5.156" class="difflineplus">+            isDirty = folder.GetStringProperty(this.GLODA_DIRTY_PROPERTY) !=</span>
<a href="#l5.157"></a><span id="l5.157" class="difflineplus">+                        &quot;0&quot;; </span>
<a href="#l5.158"></a><span id="l5.158" class="difflineplus">+          }</span>
<a href="#l5.159"></a><span id="l5.159" class="difflineplus">+          catch (ex) {}</span>
<a href="#l5.160"></a><span id="l5.160" class="difflineplus">+          </span>
<a href="#l5.161"></a><span id="l5.161" class="difflineplus">+          if (!isDirty)</span>
<a href="#l5.162"></a><span id="l5.162" class="difflineplus">+            continue; </span>
<a href="#l5.163"></a><span id="l5.163" class="difflineplus">+        </span>
<a href="#l5.164"></a><span id="l5.164" class="difflineplus">+          aJob.lastFolderIndexedUri = folder.URI;</span>
<a href="#l5.165"></a><span id="l5.165" class="difflineplus">+          this._indexingJobGoal += 2;</span>
<a href="#l5.166"></a><span id="l5.166" class="difflineplus">+          // add a job for the folder indexing</span>
<a href="#l5.167"></a><span id="l5.167" class="difflineplus">+          this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 0,</span>
<a href="#l5.168"></a><span id="l5.168" class="difflineplus">+              this._datastore._mapFolderURI(aJob.lastFolderIndexedUri)));</span>
<a href="#l5.169"></a><span id="l5.169" class="difflineplus">+          // re-schedule this job (although this worker will die)</span>
<a href="#l5.170"></a><span id="l5.170" class="difflineplus">+          this._indexQueue.push(aJob);</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineplus">+          yield kWorkDone;</span>
<a href="#l5.172"></a><span id="l5.172" class="difflineplus">+        }</span>
<a href="#l5.173"></a><span id="l5.173" class="difflineplus">+        else</span>
<a href="#l5.174"></a><span id="l5.174" class="difflineplus">+        {</span>
<a href="#l5.175"></a><span id="l5.175" class="difflineplus">+          if (aJob.LastFolderIndexedUri == folder.URI)</span>
<a href="#l5.176"></a><span id="l5.176" class="difflineplus">+            useNextFolder = true;</span>
<a href="#l5.177"></a><span id="l5.177" class="difflineplus">+        }</span>
<a href="#l5.178"></a><span id="l5.178" class="difflineplus">+      }</span>
<a href="#l5.179"></a><span id="l5.179" class="difflineplus">+    }</span>
<a href="#l5.180"></a><span id="l5.180" class="difflineplus">+    </span>
<a href="#l5.181"></a><span id="l5.181">     // consider deletion</span>
<a href="#l5.182"></a><span id="l5.182">     if (this.pendingDeletion || this.pendingDeletion === null) {</span>
<a href="#l5.183"></a><span id="l5.183" class="difflineminus">-      </span>
<a href="#l5.184"></a><span id="l5.184" class="difflineplus">+      this._indexingJobGoal++;</span>
<a href="#l5.185"></a><span id="l5.185" class="difflineplus">+      this._indexQueue.push(new IndexingJob(&quot;delete&quot;, 0, null));</span>
<a href="#l5.186"></a><span id="l5.186" class="difflineplus">+      // no need to set this.indexing to true, it must be true if we are here.</span>
<a href="#l5.187"></a><span id="l5.187">     }</span>
<a href="#l5.188"></a><span id="l5.188" class="difflineplus">+    </span>
<a href="#l5.189"></a><span id="l5.189" class="difflineplus">+    // we don't have any more work to do...</span>
<a href="#l5.190"></a><span id="l5.190" class="difflineplus">+    this._indexingSweepActive = false;</span>
<a href="#l5.191"></a><span id="l5.191" class="difflineplus">+    yield kWorkDone;</span>
<a href="#l5.192"></a><span id="l5.192">   },</span>
<a href="#l5.193"></a><span id="l5.193"> </span>
<a href="#l5.194"></a><span id="l5.194">   /**</span>
<a href="#l5.195"></a><span id="l5.195">    * Index the contents of a folder.</span>
<a href="#l5.196"></a><span id="l5.196">    */</span>
<a href="#l5.197"></a><span id="l5.197">   _worker_folderIndex: function gloda_worker_folderAdd(aJob) {</span>
<a href="#l5.198"></a><span id="l5.198">     yield this._indexerEnterFolder(aJob.id, true);</span>
<a href="#l5.199"></a><span id="l5.199">     aJob.goal = this._indexingFolder.getTotalMessages(false);</span>
<a href="#l5.200"></a><span id="l5.200" class="difflineat">@@ -1212,29 +1308,55 @@ let GlodaIndexer = {</span>
<a href="#l5.201"></a><span id="l5.201">      *  try and index the message immediately, or hold onto a less specific</span>
<a href="#l5.202"></a><span id="l5.202">      *  form of message information than the nsIMsgDBHdr.  (If we were to</span>
<a href="#l5.203"></a><span id="l5.203">      *  process immediately, it might appropriate to consider having a</span>
<a href="#l5.204"></a><span id="l5.204">      *  transaction open that is commited by timer/sufficient activity, since it</span>
<a href="#l5.205"></a><span id="l5.205">      *  is conceivable we will see a number of these events in fairly rapid</span>
<a href="#l5.206"></a><span id="l5.206">      *  succession.)</span>
<a href="#l5.207"></a><span id="l5.207">      */</span>
<a href="#l5.208"></a><span id="l5.208">     msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l5.209"></a><span id="l5.209" class="difflineminus">-      this.indexer._log.debug(&quot;msgAdded notification&quot;);</span>
<a href="#l5.210"></a><span id="l5.210" class="difflineplus">+      // make sure the message is eligible for indexing...</span>
<a href="#l5.211"></a><span id="l5.211" class="difflineplus">+      let msgFolder = aMsgHdr.folder;</span>
<a href="#l5.212"></a><span id="l5.212" class="difflineplus">+      if (msgFolder.URI.indexOf(&quot;news://&quot;) == 0)</span>
<a href="#l5.213"></a><span id="l5.213" class="difflineplus">+        return;</span>
<a href="#l5.214"></a><span id="l5.214" class="difflineplus">+      let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.215"></a><span id="l5.215" class="difflineplus">+      if (!isFolderLocal &amp;&amp; !(msgFolder.flags&amp;Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l5.216"></a><span id="l5.216" class="difflineplus">+        return;</span>
<a href="#l5.217"></a><span id="l5.217" class="difflineplus">+      </span>
<a href="#l5.218"></a><span id="l5.218" class="difflineplus">+      // mark the folder dirty so we know to look in it, but there is no need</span>
<a href="#l5.219"></a><span id="l5.219" class="difflineplus">+      //  to mark the message because it will lack a gloda-id anyways.</span>
<a href="#l5.220"></a><span id="l5.220" class="difflineplus">+      // (but don't mark it if it's already marked, as it could result in </span>
<a href="#l5.221"></a><span id="l5.221" class="difflineplus">+      //  useless commits.)</span>
<a href="#l5.222"></a><span id="l5.222" class="difflineplus">+      // XXX if we used our own folder rep here, this would be much cheaper...</span>
<a href="#l5.223"></a><span id="l5.223" class="difflineplus">+      let folderAlreadyDirty = true;</span>
<a href="#l5.224"></a><span id="l5.224" class="difflineplus">+      try {</span>
<a href="#l5.225"></a><span id="l5.225" class="difflineplus">+        folderAlreadyDirty = msgFolder.getStringProperty(</span>
<a href="#l5.226"></a><span id="l5.226" class="difflineplus">+          this.indexer.GLODA_DIRTY_PROPERTY) != &quot;0&quot;;</span>
<a href="#l5.227"></a><span id="l5.227" class="difflineplus">+      } catch (ex) {}</span>
<a href="#l5.228"></a><span id="l5.228" class="difflineplus">+      if (!folderAlreadyDirty)</span>
<a href="#l5.229"></a><span id="l5.229" class="difflineplus">+        msgFolder.setStringProperty(this.indexer.GLODA_DIRTY_PROPERTY, &quot;1&quot;);</span>
<a href="#l5.230"></a><span id="l5.230" class="difflineplus">+</span>
<a href="#l5.231"></a><span id="l5.231">       if (this.indexer._pendingAddJob === null) {</span>
<a href="#l5.232"></a><span id="l5.232">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l5.233"></a><span id="l5.233">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l5.234"></a><span id="l5.234">         this.indexer._indexingJobGoal++;</span>
<a href="#l5.235"></a><span id="l5.235">       }</span>
<a href="#l5.236"></a><span id="l5.236">       // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l5.237"></a><span id="l5.237">       if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l5.238"></a><span id="l5.238" class="difflineminus">-          this._indexMaxEventQueueMessages)</span>
<a href="#l5.239"></a><span id="l5.239" class="difflineplus">+          this._indexMaxEventQueueMessages) {</span>
<a href="#l5.240"></a><span id="l5.240">         this.indexer._pendingAddJob.items.push(</span>
<a href="#l5.241"></a><span id="l5.241">           [GlodaDatastore._mapFolderURI(aMsgHdr.folder.URI),</span>
<a href="#l5.242"></a><span id="l5.242">            aMsgHdr.messageKey]);</span>
<a href="#l5.243"></a><span id="l5.243" class="difflineminus">-      this.indexer.indexing = true;</span>
<a href="#l5.244"></a><span id="l5.244" class="difflineplus">+        this.indexer.indexing = true;</span>
<a href="#l5.245"></a><span id="l5.245" class="difflineplus">+        this.indexer._log.debug(&quot;msgAdded notification, event indexing&quot;);</span>
<a href="#l5.246"></a><span id="l5.246" class="difflineplus">+      }</span>
<a href="#l5.247"></a><span id="l5.247" class="difflineplus">+      else {</span>
<a href="#l5.248"></a><span id="l5.248" class="difflineplus">+        this.indexer.indexingSweepNeeded = true;</span>
<a href="#l5.249"></a><span id="l5.249" class="difflineplus">+        this.indexer._log.debug(&quot;msgAdded notification, sweep indexing&quot;);</span>
<a href="#l5.250"></a><span id="l5.250" class="difflineplus">+      }</span>
<a href="#l5.251"></a><span id="l5.251">     },</span>
<a href="#l5.252"></a><span id="l5.252">     </span>
<a href="#l5.253"></a><span id="l5.253">     /**</span>
<a href="#l5.254"></a><span id="l5.254">      * Handle real, actual deletion (move to trash and IMAP deletion model</span>
<a href="#l5.255"></a><span id="l5.255">      *  don't count; we only see the deletion here when it becomes forever,</span>
<a href="#l5.256"></a><span id="l5.256">      *  or rather _just before_ it becomes forever.  Because the header is</span>
<a href="#l5.257"></a><span id="l5.257">      *  going away, we need to either process things immediately or extract the</span>
<a href="#l5.258"></a><span id="l5.258">      *  information required to purge it later without the header.</span>
<a href="#l5.259"></a><span id="l5.259" class="difflineat">@@ -1356,16 +1478,17 @@ let GlodaIndexer = {</span>
<a href="#l5.260"></a><span id="l5.260">             // we _do not_ need to mark the folder as dirty, because the</span>
<a href="#l5.261"></a><span id="l5.261">             //  message added events will cause that to happen.</span>
<a href="#l5.262"></a><span id="l5.262">           }</span>
<a href="#l5.263"></a><span id="l5.263">         }</span>
<a href="#l5.264"></a><span id="l5.264">        // copy case</span>
<a href="#l5.265"></a><span id="l5.265">         else {</span>
<a href="#l5.266"></a><span id="l5.266">           // mark the folder as dirty; we'll get to it later.</span>
<a href="#l5.267"></a><span id="l5.267">           aDestFolder.setStringProperty(this.GLODA_DIRTY_PROPERTY, &quot;1&quot;);</span>
<a href="#l5.268"></a><span id="l5.268" class="difflineplus">+          this.indexingSweepNeeded = true;</span>
<a href="#l5.269"></a><span id="l5.269">         }</span>
<a href="#l5.270"></a><span id="l5.270">       } catch (ex) {</span>
<a href="#l5.271"></a><span id="l5.271">         this.indexer._log.error(&quot;Problem encountered during message move/copy&quot; +</span>
<a href="#l5.272"></a><span id="l5.272">           &quot;: &quot; + ex);</span>
<a href="#l5.273"></a><span id="l5.273">       }</span>
<a href="#l5.274"></a><span id="l5.274">     },</span>
<a href="#l5.275"></a><span id="l5.275">     </span>
<a href="#l5.276"></a><span id="l5.276">     /**</span>
<a href="#l5.277"></a><span id="l5.277" class="difflineat">@@ -1418,16 +1541,17 @@ let GlodaIndexer = {</span>
<a href="#l5.278"></a><span id="l5.278">                                aMove, aSrcFolder, aDestFolder) {</span>
<a href="#l5.279"></a><span id="l5.279">       this.indexer._log.debug(&quot;folderMoveCopy notification (Move: &quot; + aMove</span>
<a href="#l5.280"></a><span id="l5.280">                               + &quot;)&quot;);</span>
<a href="#l5.281"></a><span id="l5.281">       if (aMove) {</span>
<a href="#l5.282"></a><span id="l5.282">         let targetURI = aDestFolder.URI +</span>
<a href="#l5.283"></a><span id="l5.283">                         srcURI.substring(srcURI.lastIndexOf(&quot;/&quot;));</span>
<a href="#l5.284"></a><span id="l5.284">         return this._folderRenameHelper(aSrcFolder, targetURI);</span>
<a href="#l5.285"></a><span id="l5.285">       }</span>
<a href="#l5.286"></a><span id="l5.286" class="difflineplus">+      this.indexingSweepNeeded = true;</span>
<a href="#l5.287"></a><span id="l5.287">     },</span>
<a href="#l5.288"></a><span id="l5.288">     </span>
<a href="#l5.289"></a><span id="l5.289">     /**</span>
<a href="#l5.290"></a><span id="l5.290">      * We just need to update the URI &lt;-&gt; ID maps and the row in the database,</span>
<a href="#l5.291"></a><span id="l5.291">      *  all of which is actually done by the datastore for us.</span>
<a href="#l5.292"></a><span id="l5.292">      * This method needs to deal with the complexity where local folders will</span>
<a href="#l5.293"></a><span id="l5.293">      *  generate a rename notification for each sub-folder, but IMAP folders</span>
<a href="#l5.294"></a><span id="l5.294">      *  will generate only a single notification.  Our logic primarily handles</span>
<a href="#l5.295"></a><span id="l5.295" class="difflineat">@@ -1495,69 +1619,70 @@ let GlodaIndexer = {</span>
<a href="#l5.296"></a><span id="l5.296">     </span>
<a href="#l5.297"></a><span id="l5.297">     /**</span>
<a href="#l5.298"></a><span id="l5.298">      * Helper method to do the leg-work associated with flagging a message</span>
<a href="#l5.299"></a><span id="l5.299">      *  for re-indexing because of some change in meta-state that happened to</span>
<a href="#l5.300"></a><span id="l5.300">      *  it.  Job-wise, we treat this as a message addition; we are uniquely</span>
<a href="#l5.301"></a><span id="l5.301">      *  identifying the message by providing its folder ID and message key, and</span>
<a href="#l5.302"></a><span id="l5.302">      *  the indexer will cleanly map this to the existing gloda message.</span>
<a href="#l5.303"></a><span id="l5.303">      */</span>
<a href="#l5.304"></a><span id="l5.304" class="difflineminus">-    _reindexChangedMessage: function(aMsgHdr) {</span>
<a href="#l5.305"></a><span id="l5.305" class="difflineplus">+    _reindexChangedMessage: function gloda_indexer_reindexChangedMessage(</span>
<a href="#l5.306"></a><span id="l5.306" class="difflineplus">+        aMsgHdr) {</span>
<a href="#l5.307"></a><span id="l5.307" class="difflineplus">+      // make sure the message is eligible for indexing...</span>
<a href="#l5.308"></a><span id="l5.308" class="difflineplus">+      let msgFolder = aMsgHdr.folder;</span>
<a href="#l5.309"></a><span id="l5.309" class="difflineplus">+      if (msgFolder.URI.indexOf(&quot;news://&quot;) == 0)</span>
<a href="#l5.310"></a><span id="l5.310" class="difflineplus">+        return;</span>
<a href="#l5.311"></a><span id="l5.311" class="difflineplus">+      let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l5.312"></a><span id="l5.312" class="difflineplus">+      if (!isFolderLocal &amp;&amp; !(msgFolder.flags&amp;Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l5.313"></a><span id="l5.313" class="difflineplus">+        return;</span>
<a href="#l5.314"></a><span id="l5.314" class="difflineplus">+    </span>
<a href="#l5.315"></a><span id="l5.315">       // mark the message as dirty</span>
<a href="#l5.316"></a><span id="l5.316">       // (We could check for the presence of the gloda message id property</span>
<a href="#l5.317"></a><span id="l5.317">       //  first to know whether we technically need the dirty property.  I'm</span>
<a href="#l5.318"></a><span id="l5.318">       //  not sure whether it is worth the high-probability exception cost.) </span>
<a href="#l5.319"></a><span id="l5.319" class="difflineminus">-      aMsgHdr.setUint32Property(this.GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l5.320"></a><span id="l5.320" class="difflineplus">+      aMsgHdr.setUint32Property(this.indexer.GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l5.321"></a><span id="l5.321">       // mark the folder dirty too, so we know to look inside</span>
<a href="#l5.322"></a><span id="l5.322" class="difflineminus">-      aMsgHdr.folder.setStringProperty(this.GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l5.323"></a><span id="l5.323" class="difflineplus">+      msgFolder.setStringProperty(this.indexer.GLODA_DIRTY_PROPERTY, &quot;1&quot;);</span>
<a href="#l5.324"></a><span id="l5.324">       </span>
<a href="#l5.325"></a><span id="l5.325">       if (this.indexer._pendingAddJob === null) {</span>
<a href="#l5.326"></a><span id="l5.326">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l5.327"></a><span id="l5.327">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l5.328"></a><span id="l5.328">         this.indexer._indexingJobGoal++;</span>
<a href="#l5.329"></a><span id="l5.329">       }</span>
<a href="#l5.330"></a><span id="l5.330">       // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l5.331"></a><span id="l5.331">       if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l5.332"></a><span id="l5.332">           this._indexMaxEventQueueMessages)</span>
<a href="#l5.333"></a><span id="l5.333">         this.indexer._pendingAddJob.items.push(</span>
<a href="#l5.334"></a><span id="l5.334" class="difflineminus">-          [GlodaDatastore._mapFolderURI(aMsgHdr.folder.URI),</span>
<a href="#l5.335"></a><span id="l5.335" class="difflineplus">+          [GlodaDatastore._mapFolderURI(msgFolder.URI),</span>
<a href="#l5.336"></a><span id="l5.336">            aMsgHdr.messageKey]);</span>
<a href="#l5.337"></a><span id="l5.337">       this.indexer.indexing = true;</span>
<a href="#l5.338"></a><span id="l5.338">     },</span>
<a href="#l5.339"></a><span id="l5.339">   </span>
<a href="#l5.340"></a><span id="l5.340" class="difflineminus">-    /**</span>
<a href="#l5.341"></a><span id="l5.341" class="difflineminus">-     * Find out when folders are added or new messages show up in a newsgroup.</span>
<a href="#l5.342"></a><span id="l5.342" class="difflineminus">-     */</span>
<a href="#l5.343"></a><span id="l5.343">     OnItemAdded: function gloda_indexer_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l5.344"></a><span id="l5.344">     },</span>
<a href="#l5.345"></a><span id="l5.345" class="difflineminus">-    </span>
<a href="#l5.346"></a><span id="l5.346" class="difflineminus">-    /**</span>
<a href="#l5.347"></a><span id="l5.347" class="difflineminus">-     * Find out when messages disappear from a newsgroup.</span>
<a href="#l5.348"></a><span id="l5.348" class="difflineminus">-     */</span>
<a href="#l5.349"></a><span id="l5.349">     OnItemRemoved: function gloda_indexer_OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l5.350"></a><span id="l5.350">     },</span>
<a href="#l5.351"></a><span id="l5.351" class="difflineminus">-    </span>
<a href="#l5.352"></a><span id="l5.352" class="difflineminus">-    /**</span>
<a href="#l5.353"></a><span id="l5.353" class="difflineminus">-     * Do nothing, we get our header change notifications directly from the</span>
<a href="#l5.354"></a><span id="l5.354" class="difflineminus">-     *  nsMsgDatabase.</span>
<a href="#l5.355"></a><span id="l5.355" class="difflineminus">-     */</span>
<a href="#l5.356"></a><span id="l5.356">     OnItemPropertyChanged: function gloda_indexer_OnItemPropertyChanged(</span>
<a href="#l5.357"></a><span id="l5.357">                              aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l5.358"></a><span id="l5.358">     },</span>
<a href="#l5.359"></a><span id="l5.359">     OnItemIntPropertyChanged: function gloda_indexer_OnItemIntPropertyChanged(</span>
<a href="#l5.360"></a><span id="l5.360">                                 aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l5.361"></a><span id="l5.361">     },</span>
<a href="#l5.362"></a><span id="l5.362">     OnItemBoolPropertyChanged: function gloda_indexer_OnItemBoolPropertyChanged(</span>
<a href="#l5.363"></a><span id="l5.363">                                 aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l5.364"></a><span id="l5.364">     },</span>
<a href="#l5.365"></a><span id="l5.365">     OnItemUnicharPropertyChanged:</span>
<a href="#l5.366"></a><span id="l5.366">         function gloda_indexer_OnItemUnicharPropertyChanged(</span>
<a href="#l5.367"></a><span id="l5.367">           aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l5.368"></a><span id="l5.368">       </span>
<a href="#l5.369"></a><span id="l5.369">     },</span>
<a href="#l5.370"></a><span id="l5.370" class="difflineplus">+    /**</span>
<a href="#l5.371"></a><span id="l5.371" class="difflineplus">+     * Notice when user activity changes a message's status, or automated</span>
<a href="#l5.372"></a><span id="l5.372" class="difflineplus">+     *  junk processing flags a message as junk.</span>
<a href="#l5.373"></a><span id="l5.373" class="difflineplus">+     */</span>
<a href="#l5.374"></a><span id="l5.374">     OnItemPropertyFlagChanged: function gloda_indexer_OnItemPropertyFlagChanged(</span>
<a href="#l5.375"></a><span id="l5.375">                                 aMsgHdr, aProperty, aOldValue, aNewValue) {</span>
<a href="#l5.376"></a><span id="l5.376">       if (aProperty == this._kStatusAtom ||</span>
<a href="#l5.377"></a><span id="l5.377">           aProperty == this._kFlaggedAtom ||</span>
<a href="#l5.378"></a><span id="l5.378">           aProperty == this._kJunkStatusChangedAtom) {</span>
<a href="#l5.379"></a><span id="l5.379">         if (this.indexer.enabled) {</span>
<a href="#l5.380"></a><span id="l5.380">           this.indexer._log.debug(&quot;ItemPropertyFlagChanged notification&quot;);</span>
<a href="#l5.381"></a><span id="l5.381">           this._reindexChangedMessage(aMsgHdr);</span>
<a href="#l5.382"></a><span id="l5.382" class="difflineat">@@ -1744,36 +1869,35 @@ let GlodaIndexer = {</span>
<a href="#l5.383"></a><span id="l5.383">     let curMsg = null;</span>
<a href="#l5.384"></a><span id="l5.384">     this._log.debug(candidateCurMsgs.length + &quot; candidate messages&quot;);</span>
<a href="#l5.385"></a><span id="l5.385">     for (let iCurCand=0; iCurCand &lt; candidateCurMsgs.length; iCurCand++) {</span>
<a href="#l5.386"></a><span id="l5.386">       let candMsg = candidateCurMsgs[iCurCand];</span>
<a href="#l5.387"></a><span id="l5.387"> </span>
<a href="#l5.388"></a><span id="l5.388">       this._log.debug(&quot;candidate folderID: &quot; + candMsg.folderID +</span>
<a href="#l5.389"></a><span id="l5.389">                       &quot; messageKey: &quot; + candMsg.messageKey);</span>
<a href="#l5.390"></a><span id="l5.390">       </span>
<a href="#l5.391"></a><span id="l5.391" class="difflineminus">-      // if we are in the same folder and we have the same message key, we</span>
<a href="#l5.392"></a><span id="l5.392" class="difflineminus">-      //  are definitely the same, stop looking.</span>
<a href="#l5.393"></a><span id="l5.393" class="difflineminus">-      // if we are in the same folder and the candidate message has a null</span>
<a href="#l5.394"></a><span id="l5.394" class="difflineminus">-      //  message key, we treat it as our best option unless we find an exact</span>
<a href="#l5.395"></a><span id="l5.395" class="difflineminus">-      //  key match. (this would happen because the 'move' notification case</span>
<a href="#l5.396"></a><span id="l5.396" class="difflineminus">-      //  has to deal with not knowing the target message key.  this case</span>
<a href="#l5.397"></a><span id="l5.397" class="difflineminus">-      //  will hopefully be somewhat improved in the future to not go through</span>
<a href="#l5.398"></a><span id="l5.398" class="difflineminus">-      //  this path which mandates re-indexing of the message in its entirety.)</span>
<a href="#l5.399"></a><span id="l5.399" class="difflineminus">-      // if we are in the same folder and the candidate message's underlying</span>
<a href="#l5.400"></a><span id="l5.400" class="difflineminus">-      //  message no longer exists/matches, we'll assume we are the same but</span>
<a href="#l5.401"></a><span id="l5.401" class="difflineminus">-      //  were betrayed by a re-indexing or something, but we have to make sure</span>
<a href="#l5.402"></a><span id="l5.402" class="difflineminus">-      //  a perfect match doesn't turn up.</span>
<a href="#l5.403"></a><span id="l5.403">       if (candMsg.folderURI == aMsgHdr.folder.URI) {</span>
<a href="#l5.404"></a><span id="l5.404" class="difflineminus">-        if ((candMsg.messageKey == aMsgHdr.messageKey) || </span>
<a href="#l5.405"></a><span id="l5.405" class="difflineminus">-            (candMsg.messageKey === null)) {</span>
<a href="#l5.406"></a><span id="l5.406" class="difflineplus">+        // if we are in the same folder and we have the same message key, we</span>
<a href="#l5.407"></a><span id="l5.407" class="difflineplus">+        //  are definitely the same, stop looking.</span>
<a href="#l5.408"></a><span id="l5.408" class="difflineplus">+        if (candMsg.messageKey == aMsgHdr.messageKey) {</span>
<a href="#l5.409"></a><span id="l5.409">           curMsg = candMsg;</span>
<a href="#l5.410"></a><span id="l5.410">           break;</span>
<a href="#l5.411"></a><span id="l5.411">         }</span>
<a href="#l5.412"></a><span id="l5.412" class="difflineplus">+        // if we are in the same folder and the candidate message has a null</span>
<a href="#l5.413"></a><span id="l5.413" class="difflineplus">+        //  message key, we treat it as our best option unless we find an exact</span>
<a href="#l5.414"></a><span id="l5.414" class="difflineplus">+        //  key match. (this would happen because the 'move' notification case</span>
<a href="#l5.415"></a><span id="l5.415" class="difflineplus">+        //  has to deal with not knowing the target message key.  this case</span>
<a href="#l5.416"></a><span id="l5.416" class="difflineplus">+        //  will hopefully be somewhat improved in the future to not go through</span>
<a href="#l5.417"></a><span id="l5.417" class="difflineplus">+        //  this path which mandates re-indexing of the message in its entirety)</span>
<a href="#l5.418"></a><span id="l5.418">         if (candMsg.messageKey === null)</span>
<a href="#l5.419"></a><span id="l5.419">           curMsg = candMsg;</span>
<a href="#l5.420"></a><span id="l5.420" class="difflineplus">+        // if we are in the same folder and the candidate message's underlying</span>
<a href="#l5.421"></a><span id="l5.421" class="difflineplus">+        //  message no longer exists/matches, we'll assume we are the same but</span>
<a href="#l5.422"></a><span id="l5.422" class="difflineplus">+        //  were betrayed by a re-indexing or something, but we have to make</span>
<a href="#l5.423"></a><span id="l5.423" class="difflineplus">+        //  sure a perfect match doesn't turn up.</span>
<a href="#l5.424"></a><span id="l5.424">         else if ((curMsg === null) &amp;&amp; (candMsg.folderMessage === null))</span>
<a href="#l5.425"></a><span id="l5.425">           curMsg = candMsg;</span>
<a href="#l5.426"></a><span id="l5.426">       }</span>
<a href="#l5.427"></a><span id="l5.427">       // our choice of last resort, but still okay, is a ghost message</span>
<a href="#l5.428"></a><span id="l5.428">       else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l5.429"></a><span id="l5.429">         curMsg = candMsg;</span>
<a href="#l5.430"></a><span id="l5.430">       }</span>
<a href="#l5.431"></a><span id="l5.431">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/public.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/public.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -6,16 +6,28 @@ const Cc = Components.classes;</span>
<a href="#l6.4"></a><span id="l6.4"> const Ci = Components.interfaces;</span>
<a href="#l6.5"></a><span id="l6.5"> const Cr = Components.results;</span>
<a href="#l6.6"></a><span id="l6.6"> const Cu = Components.utils;</span>
<a href="#l6.7"></a><span id="l6.7"> </span>
<a href="#l6.8"></a><span id="l6.8"> Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l6.9"></a><span id="l6.9"> Cu.import(&quot;resource://gloda/modules/everybody.js&quot;);</span>
<a href="#l6.10"></a><span id="l6.10"> Cu.import(&quot;resource://gloda/modules/indexer.js&quot;);</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+// an initial sweep is required.  this will not actually trigger anything if</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+//  things are disabled, of course.</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+// delay the initial sweep until after thunderbird has had a chance to start-up</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+//  fully.</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+let timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+timer.initWithCallback(function() {</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+    GlodaIndexer.indexingSweepNeeded = true;</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+    timer = null;</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+  },</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+  5000,</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+  Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+</span>
<a href="#l6.24"></a><span id="l6.24"> /**</span>
<a href="#l6.25"></a><span id="l6.25">  * Expose some junk </span>
<a href="#l6.26"></a><span id="l6.26">  */</span>
<a href="#l6.27"></a><span id="l6.27"> function proxy(aSourceObj, aSourceAttr, aDestObj, aDestAttr) {</span>
<a href="#l6.28"></a><span id="l6.28">   aDestObj[aDestAttr] = function() {</span>
<a href="#l6.29"></a><span id="l6.29">     return aSourceObj[aSourceAttr].apply(aSourceObj, arguments);</span>
<a href="#l6.30"></a><span id="l6.30">   };</span>
<a href="#l6.31"></a><span id="l6.31"> }</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

